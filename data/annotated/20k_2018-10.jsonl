{"id": "4l3BRB", "name": "Arabesque", "author": "nabehide", "description": "my first post!", "tags": ["green"], "likes": 4, "viewed": 1012, "published": "Public API", "date": "1539954619", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265358979;\n\nconst float period = 5.0;\nconst float a = 0.4;\nconst float offset = 2.5;\n\nfloat line(vec2 p, float width){\n    return (1.0 - step(width*0.5, abs(p.y))) * (1.0 - step(0.0, p.x) - step(p.x, -1.0));\n}\n\nmat2 rot(float t){\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy*2.0-iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float t = mod(iTime, period);\n    \n    vec3 draw = vec3(0.0);\n    \n    vec3 color = vec3(0.01, 1.0, 0.01);\n    \n    vec2 pos = p;\n    \n    // cross\n    pos = vec2(pos.x*(sin(pos.y+t*PI*a+offset))/2.0, pos.y*(sin(pos.x+t*PI*a+offset))/2.0);\n    \n    // change line width\n    pos = vec2(pos.x*(sin(-t*PI*a+offset)+1.001)/2.0, pos.y*(cos(-t*PI*a+offset)+1.001)/2.0);\n    \n    // spiral\n    pos *= rot((sin(t*PI*a+offset)+1.0)/length(p));\n    \n    // rotation\n    pos *= rot(t*PI*2.0);\n    \n    float width = 0.01;\n    draw += line(pos, width) * color;\n    \n    // Output to screen\n    fragColor = vec4(draw,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l3BRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 142, 142, 233], [235, 235, 253, 253, 305], [307, 307, 364, 364, 1069]], "test": "valid"}
{"id": "4l3BW7", "name": "Cone SDF", "author": "rlm72", "description": "Example of SDF for a cone (based on Jamie Wong's ray marching tutorial)", "tags": ["example"], "likes": 3, "viewed": 569, "published": "Public", "date": "1539773334", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Part 3 Challenges\n * - Make the camera move up and down while still pointing at the cube\n * - Make the camera roll (stay looking at the cube, and don't change the eye point)\n * - Make the camera zoom in and out\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Signed distance function for a cube centered at the origin\n * with width = height = length = 2.0\n */\nfloat cubeSDF(vec3 p) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.0;\n}\n\nfloat coneSDF( vec3 p, vec2 c )\n{\n    float q = length(p.xz);\n    return dot(c,vec2(q,p.y));\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    return coneSDF(p, vec2(sqrt(3.0)*0.5, 0.5));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(9.0, 2.0, 0.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l3BW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[348, 456, 479, 630, 1067], [1069, 1158, 1183, 1183, 1213], [1215, 1215, 1248, 1248, 1309], [1311, 1551, 1575, 1575, 1626], [1628, 2049, 2140, 2140, 2446], [2461, 2715, 2780, 2780, 2912], [2914, 3003, 3032, 3032, 3342], [3344, 3836, 3976, 3976, 4566], [4568, 4938, 5023, 5023, 5823], [5825, 6152, 6201, 6236, 6462], [6464, 6464, 6521, 6521, 7364]], "test": "valid"}
{"id": "4l3Bzf", "name": "loading ring with glow", "author": "feiss", "description": "simple loading ring", "tags": ["ring", "glow", "loading"], "likes": 2, "viewed": 151, "published": "Public", "date": "1540395402", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// parameters\n#define progress mod(iTime /4.0, 1.0)\n#define minRadius 0.1\n#define maxRadius 0.18\n#define blur 0.003\n#define glow 0.1\n\n#define PI 3.14159265358979\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5, 0.5);\n    float r = uv.x * uv.x + uv.y * uv.y;\n    float col = (1.0 - smoothstep(maxRadius, maxRadius + blur, r)) * smoothstep(minRadius, minRadius + blur, r);\n    float gl = (1.0 - smoothstep(minRadius, maxRadius + glow, r)) * smoothstep(minRadius - glow, maxRadius, r);\n    float a = (PI + atan(uv.y, uv.x)) / (PI * 2.0);\n\tfloat p = 1.0 - progress;\n    col *= smoothstep(p, p + blur, a);\n    gl *= smoothstep(p - glow * 0.5, p + glow * 0.5, a);\n    fragColor = vec4(col + gl, col, col, col + gl);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l3Bzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[163, 163, 220, 220, 772]], "test": "valid"}
{"id": "4l3Bzs", "name": "book conveyor tank paternosta ", "author": "ollj", "description": "mouse.x sets page size\nmouse.y sets \"book phase\"\ni failed at the boundary overlap area.\npage count and distance between page are also parametrized.\nbut i wanted a simpler ui demo.", "tags": ["tank", "book", "conveyor", "kinematic", "pmod", "kerning", "paternosta", "panzer", "slinky", "euclideanrythm", "paramettrization"], "likes": 4, "viewed": 384, "published": "Public API", "date": "1540606506", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\ni wanted\nhttps://www.shadertoy.com/view/XtcfRs\nwith more than \"pages\"\n\nproblem:\n- flipping pages of a book, or items on a conveyor belt\n- should use mod() folding\n- simple approach is only c1 continuous, it shows in the border.\n- to flatten pages on the top arch, i would still need a long mod() neighborhood.\n- - looping over the whole round top half may still be simpler and faster.\n\n- just normalizing a vector field of isoline-pages would likely much simpler here.\n- ,but not stretching the uvw map on that one\n- would involve arclength() calculations aslongside isolines.\n- - quadratic Bezier knee() function would likely be just fine.\n\nin its current state , its gradient is just horrible, barely useful for a tracing/fragment-shader\nor a rather shitty 2d texture.\nits not acomplete distancefield, more a modular arithmetic playground.\n\nit made me realize that i had to develope a pModInterval with bounds:\nhttps://www.shadertoy.com/view/lt3Bzs\n\n*/\n\n//_start_ constant irrationals\n#define pib acos(0.)\n#define pi acos(-1.)\n#define tau pi*2.\n//float tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n//eul=exp(1.)???\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(),good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n\n//__end__ constant irrationals\n//_start_ basics\n\n#define ve0 float\n#define ve1 vec2\n#define ve2 vec3\n#define ve3 vec4\n#define norma normalize\n#define dd(a) dot(a,a)\n#define u2(a) ((a)*2.-1.)\n#define u5(a) ((a)*.5+.5)\n#define sat(x)clamp(x,0.,1.)\n#define cosu5(a) u5(cos(a))\n\n#define viewZoom(t,u,r,m) 11.\n#define Aa(t,u,r,m) min(r.x,r.y)\n//(hl2(r)/floor(mix(1.,hl2(r)*.1,u5(-cos(t)))))\n//viewZoom() returns a float; is defined in a local channel context, to quickly modify its scaling\n//divide by/aa for hairline drawing and sharp smoothstep()\n//fta insists on TURM-parameters because it contains Viewzoom(), that (locally) insists on TURM\n#define fra(t,u,r,m) (u-.5*r.xy)*viewZoom(t,u,r,m)/(r.y)\n\nve0 ad(ve3 a){return dot(ve3(1),a);}ve0 ad(vec3 a){return dot(ve2(1),a);}ve0 ad(vec2 a){return a.x+a.y;}//add vector components\n//for deferred shading IDs:\n#define minx(a,b) mix(b,a,step(a.x,b.x))\n#define manx(a,b) mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b) -minx(-a,-b)\n\nfloat ss(float a,float b){return smoothstep(b,-b,a);}\nvec2 ss(vec2 a,float b){return smoothstep(b,-b,a);}\nvec3 ss(vec3 a,float b){return smoothstep(b,-b,a);}\nvec4 ss(vec4 a,float b){return smoothstep(b,-b,a);}\n#define aA(t,u,r,m) min(r.x,r.y)\n\n/*i am overthinking this, dot radius shall be irrelevant\n//only distance between dots matters.\n*/\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod(inout float p, float size//mercury.sexy hg_sdf \n){float halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat pModPolar(inout vec2 u,float t,float m//mercury.sexy hg_sdf\n){float g=pi/t\n ,a=atan(u.y,u.x)-g-m\n ,r=length(u)\n ,c=floor(a*.5/g)\n ;a=mod(a,g*2.)-g\n ;u=vec2(cos(a),sin(a))*r\n ;//if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\n\n\nfloat arg(vec2 a){return atan(a.y,a.x);}\nvec2 c2p(vec2 a){return vec2(arg(a),length(a));}\nvec2 p2c(vec2 a){return vec2(cos(a.y),sin(a.y))*a.x;}\n\n\nfloat pageshape(vec2 u,float s){\n ;u.y=abs(u.y)\n ;float l=1.6\n ;u.x=abs(u.x-+l*s)\n ;u.x-=l\n ;return max(u.x,u.y)\n ;}\n\nbool bookBound(float e,float p//limits page numbers\n){return abs(e*2.+.5)<p\n ;}\n\n//return .xy is position of a dot, .zw a normalVector\n//m.x is distance between papers\n//m.y is m.y os phase (what pages are open)\n//m.z is number of pages \n//m.w is paper thickness\n//the upper bow is always a half-unitCircle around vec2(0)\nvec4 bookPaternosterBeta(float t,vec2 u,vec3 r,vec4 m\n){vec4 c=vec4(1)\n ;m.y=m.y*2.-1.\n ;m.y=1.-m.y*.5\n ;//m.x=(m.x*9.+1.)\n ;m.x=1./(abs(m.x*19.)+1.1)\n ;m.z=1.6/m.x\n ;m.w=min(abs(m.x),1.)\n ;m.x=m.w*.5\n ;float p=2. //p is half the number of pages\n ;float e\n ;if(u.y<0.//bottom\n ){c.z=abs(u.x)\n  ;if(u.x<0.//bottom left\n  ){\n   ;float g=2.\n   ;vec2 v=u\n   ;v.y=v.y-pi       \n   ;v.y=v.y+m.y\n   ;float e=pMod(v.y,m.x*2.*pi)\n   ;if(bookBound(e,m.z)\n   ){v=v+vec2(1,0)\n    ;c.x=pageshape(v,-1.)     \n   ;}\n  ;}else{//bottom right\n   ;vec2 v=u\n   ;v.y-=m.y\n   ;float e=pMod(v.y,m.x*2.*pi)\n   ;if(bookBound(e-1.,m.z)\n   ){v=v-vec2(1,0)\n    ;c.x=pageshape(v,1.)\n   ;}\n  ;}\n ;}\n ;if(u.y>0.){//top\n  ;vec2 v=u.yx*vec2(1,-1)//quater rotation and quater offset to rotate the atan() discontinuity \"down\"\n  ;float e = pModPolar(v,1./m.x,m.y-pi*.5); v -= vec2(1,0);\n  ;if(bookBound(e,m.z)\n  ){c.y=pageshape(v,1.)\n  ;}\n  ;c.z=length(u)\n ;}\n ;c.z=abs(c.z-1.)\n ;c.xy-=m.w\n ;c.z-=.03 \n ;//c.xy=min(c.xy,min(c.zz,min(c.yx,c.yy)))\n ;c.w=max(c.z,min(c.y,c.x))\n ;c.w=mix(ss(c.w,2./aA(t,u,r,m)),fract(c.w),.1)\n ;c.xyz=mix(ss(c.xyz,2./aA(t,u,r,m)),fract(c.xyz),.1)\n     \n ;c.xy+=c.ww\n ;//initial versions return .rgba to debug this shit\n ;return sat(c)\n ;}\n\nve3 mainEntry(ve0 t,ve1 u,ve2 r,ve3 m\n){ve3 c=ve3(1)\n ;u   =fra(t,u   ,r,m)\n ;if(m.z>0.\n ){m.xy=fra(t,m.xy,r,m)\n  ;m.zw=fra(t,m.zw,r,m)\n ;}else{\n  ;m.x=(cos(iTime)*.4-.5)*viewZoom(t,u,r,m)\n  ;m.y=sin(iTime*1.61)*.4*viewZoom(t,u,r,m)\n ;}\n ;c.w=length(u-m.xy)\n ;vec4 b=bookPaternosterBeta(t,u,r,m)\n ;//c.y=length(u-b.xy)\n ;c.xyzw-=.1\n ;c=mix(ss(c,2./aA(t,u,r,m)),fract(c),.1)\n ;c.xy+=c.ww\n ;c.w=1.\n ;c=sat(c)\n ;//c=max(c,b)\n ;c=b\n ;return c;}\n\nvoid mainImage(out ve3 o,in ve1 u){o=mainEntry(iTime,u,iResolution,iMouse);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l3Bzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2180, 2180, 2194, 2194, 2216], [2216, 2216, 2231, 2231, 2253], [2253, 2253, 2268, 2268, 2284], [2452, 2452, 2478, 2478, 2505], [2506, 2506, 2530, 2530, 2557], [2558, 2558, 2582, 2582, 2609], [2610, 2610, 2634, 2634, 2661], [2795, 2939, 3000, 3000, 3119], [3121, 3121, 3189, 3189, 3341], [3344, 3344, 3362, 3362, 3384], [3385, 3385, 3402, 3402, 3433], [3434, 3434, 3451, 3451, 3487], [3490, 3490, 3522, 3522, 3606], [3608, 3608, 3662, 3662, 3687], [3689, 3930, 3986, 3986, 5161], [5163, 5163, 5203, 5203, 5603], [5605, 5605, 5640, 5640, 5681]], "test": "error"}
{"id": "4l3fz4", "name": "Lightning!-Nature", "author": "jkashimura", "description": "HW", "tags": ["beginner"], "likes": 1, "viewed": 116, "published": "Public", "date": "1539046410", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = tan(a)+1.;\n  float f = cos(a);\n  return mat2(r, f, -f, r);\n}\n\n\nfloat pole(vec2 v, float r){\n  return length(v)-r;\n}\nfloat sphere(vec3 v, float r){\n  return length(v)-r;\n}\nfloat box(vec3 v, float r, float m) {\n  return max(length(v.xy)-r, abs(v.z)-m);\n}\n\n\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n//=======================\n\nShape vines(vec3 c){\n  Shape shape;\n  float vine;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n\n  // Shape Attributes\n  float twist = 10.; // Vine Repeat\n  float vineOffset = 3.; // Leaf Offset\n\n\n\tvineOffset += cos(iTime*0.5)*1.;\n\n  // Stems\n  vec3 i = c;\n    i.xz *= rot(c.y*.5+cos(iTime)*0.25);\n    float detail = pModPolar(i.xz, twist); \n    \n    float x = mix(-2., 1., mod(detail, 10.));// Small Ripples\n    //float x = mix(0., 1., pModPolar(i.xy, 10.)); \n    \n    i.x = abs(i.x)-cos(iTime); //mirror\n    i.x -= vineOffset; // Offset Stems\n  \tfloat stemWidth = 0.25; //width\n  \tvine = pole(i.xz, stemWidth+0.02*sin(i.y*x));\n\n\n  vec4 color = vec4(.05, 0., .5+cos(iTime)*.5, 1.); //color\n    \n    float pattern = (tan(c.z*10.)*.3) +\n        cos(sin(c.x*2.)); //pattern of stem\n\n  shape.dist = vine;\n  shape.color = color;\n  shape.color *= pattern;\n\n  return shape;\n}\n\n\nShape orb(vec3 c){\n  Shape shape;\n  float orb;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n\n  // Stems\n  vec3 i = c;\n    i.xz *= rot(iTime); //rotation along x and z\n    i.y = repeat(i.y, 0.5); //repeat in y\n    i.x = abs(i.x)-0.5; //mirror in x\n    i.z = abs(i.z)-0.5; //mirror in z\n    orb = sphere(i, cos(sin(iTime)*2.)*0.25);\n    \n\n  vec4 color = vec4(3., 2.5, 0.4, 1.); //color\n\n  shape.dist = orb;\n  shape.color = color;\n\n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape vines = vines(c);\n  Shape orbs = orb(c);\n    \n  float df = mixShapes(vines.dist, orbs.dist, 1.);\n  vines.dist = df;\n    \n  vines.color = mix(vines.color, \n                    orbs.color, \n                    mixColors(orbs.dist, vines.dist, 1.));\n\n  return vines;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., -10.);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(cos(iTime)*.1,cos(iTime)*.1,cos(iTime)*.5, 1.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.05){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.01){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    c.dist  *= smoothstep(0., 1., length(v.y/v.x)); //smoothstep in middle of screen\n    // Output to screen\n    scene += f * c.dist;\n\n\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l3fz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 164, 186, 186, 253], [255, 255, 273, 273, 346], [349, 349, 377, 377, 401], [402, 402, 432, 432, 456], [457, 457, 494, 494, 538], [542, 542, 585, 585, 628], [630, 630, 673, 673, 739], [741, 741, 780, 780, 936], [964, 964, 984, 984, 1869], [1872, 1872, 1890, 1890, 2355], [2358, 2358, 2376, 2376, 2650], [2652, 2652, 2709, 2709, 3273]], "test": "valid"}
{"id": "4l3fzS", "name": "Tile zoom", "author": "AntoineC", "description": "Infinite zoom on morphing tiles.", "tags": ["2d", "loop", "minimalist"], "likes": 26, "viewed": 344, "published": "Public", "date": "1540153939", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Infinite zoom on morphing tiles.\n// Recreation of a bees & bombs animation\n// https://beesandbombs.tumblr.com/post/179092048114/grids\n\n#define Pi     3.14159265359\n#define Tau    6.28318530718\n#define Rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define Rot45  Rot(Pi/4.0)\n\n\n#define TileCount 7.0\n#define Duration 6.0\n\n\n// IQ’s Exact signed distance of a rectangle\nfloat RectangleSd(vec2 p, float size)\n{\n    vec2 d = abs(p)-vec2(size);\n    return length(max(d, vec2(0))) + min(max(d.x, d.y), 0.0);\n}\n\n\nfloat Phase(vec2 uvi, vec2 uvf, float t)\n{\n    vec2 uv = (uvi + vec2(0.5))/TileCount + (uvf+1.0)/(2.0*TileCount);\n    return smoothstep(0.6, 0.0, (atan(-uv.x, -uv.y) + Pi)/Tau-1.6*t+0.6);\n}\n\n\nfloat Tile(vec2 uv, vec2 uvi, float eps, float t, float zoom)\n{\n    // Square:\n    float sq = RectangleSd(uv, 1.0);\n   \n    // Corner diamonds:\n    float cdt = min(t, 0.75)/0.75;\n    float cds = sqrt(2.0*0.5*0.5);\n    float cd = RectangleSd(Rot45*(uv-vec2(-1.,-1.)), cds*Phase(uvi,vec2(-1.,-1.),cdt));\n    cd = min(  RectangleSd(Rot45*(uv-vec2( 1.,-1.)), cds*Phase(uvi,vec2( 1.,-1.),cdt)), cd);\n    cd = min(  RectangleSd(Rot45*(uv-vec2( 1., 1.)), cds*Phase(uvi,vec2( 1., 1.),cdt)), cd);\n    cd = min(  RectangleSd(Rot45*(uv-vec2(-1., 1.)), cds*Phase(uvi,vec2(-1., 1.),cdt)), cd);\n\n    // Side squares:\n    float sst = max(t-0.25, 0.0)/0.75;\n    float sss = 0.5;\n    float ss = RectangleSd(uv-vec2(-1., 0.), sss*Phase(uvi,vec2(-1., 0.),sst));\n    ss = min(  RectangleSd(uv-vec2( 1., 0.), sss*Phase(uvi,vec2( 1., 0.),sst)), ss);\n    ss = min(  RectangleSd(uv-vec2( 0., 1.), sss*Phase(uvi,vec2( 0., 1.),sst)), ss);\n    ss = min(  RectangleSd(uv-vec2( 0.,-1.), sss*Phase(uvi,vec2( 0.,-1.),sst)), ss);\n    \n    // Combine:\n    float sd = sq;\n    sd = min(max(sd, -cd), cd);\n    sd = min(max(sd, -ss), ss);\n \n    // Stroke:\n    float width = 14.0/(zoom*450.0);\n    return smoothstep(width, (width+eps), abs(sd));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized coordinates:\n    float eps = 1.0/iResolution.y;\n    vec2  uv  = eps*(fragCoord - 0.5*iResolution.xy);\n\tfloat t   = fract(iTime / Duration);\n\n    // Zoom:\n    float zoom = pow(2.0, t);\n    uv /= zoom;\n    eps /= zoom;\n    \n    // Tiling:\n    vec2 uvf, uvi;\n    uv = uv*TileCount - vec2(0.5);\n    uvi = floor(uv);\n    uvf = 2.0*fract(uv)-1.0;\n    eps *= 2.0*TileCount;\n\n    // Render tile:\n    float c = 0.95*Tile(uvf, uvi, eps, fract(t), zoom);\n    \n    // Output to screen\n    fragColor = vec4(vec3(pow(c,0.45)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l3fzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[320, 367, 406, 406, 502], [505, 505, 547, 547, 694], [697, 697, 760, 775, 1906], [1909, 1909, 1966, 1997, 2504]], "test": "valid"}
{"id": "4lcfR4", "name": "raytrace fancy", "author": "dabadab", "description": "somewhat souped up version of https://www.shadertoy.com/view/Xl3fR4\nkey toggles (all ON for default):\nM - movement\nA - 2x AA\nS - adaptive 16x AA\nR - temporal randomization for 16x AA\n\n", "tags": ["raytrace"], "likes": 6, "viewed": 282, "published": "Public API", "date": "1538691540", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI_2 = 1.57079632679489661923; \n\n\n// ---------------------------------------------------\n\n// taken from https://www.shadertoy.com/view/XsBXRV\n#define KEY_A 65\n#define KEY_B 66\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_I 73\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_T 84\n#define KEY_U 85\n#define KEY_V 86\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n\nbool keyToggled(int key)\n{\n\treturn texture(iChannel2, vec2((float(key)+0.5)/256.0,0.75)).x>0.0;\n}\n\n\n// ---------------------------------------------------\n\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n   vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n   vec3 ww = normalize(target - origin);\n   vec3 uu = normalize(cross(ww, rr));\n   vec3 vv = normalize(cross(uu, ww));\n\n   return mat3(uu, vv, ww);\n}\n\n\n// ---------------------------------------------------\n\n// taken from IQ: http://www.iquilezles.org/www/articles/warp/warp.htm\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 x )\n{\n\treturn sin(1.5*x.x)*sin(1.5*x.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\nfloat pattern( in vec2 p )\n{\n    vec2 q = vec2( fbm( p + vec2(0.0,0.0) ),\n                  fbm( p + vec2(5.2,1.3) ) );\n\n    vec2 r = vec2( fbm( p + 4.0*q + vec2(1.7,9.2) ),\n                  fbm( p + 4.0*q + vec2(8.3,2.8) ) );\n\n    return fbm( p + 4.0*r )/4.0;\n}\n\n// ------------------------------------------------------\n\n// the classic random function\nfloat rand(vec2 st) {\n    st.x += iTime;\n    st.y += iTime;\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n// ------------------------------------------------------\n\nbool isMoving() { return(!keyToggled(KEY_M)); }\nbool isAdaptiveAAEnabled() { return(!keyToggled(KEY_S)); }\nbool isSimpleAAEnabled() { return(!keyToggled(KEY_A)); }\nbool isRandomAAEnabled() { return(!keyToggled(KEY_R)); }\n\n\n// ------------------------------------------------------\n\nvec3 getSkyColor(in vec3 ray) {\n    float sinAngle = ray.y / length(ray);\n    vec3 bottom = vec3(0.54, 0.77, 0.98);\n    vec3 top = vec3(0.13, 0.39, 0.68);\n    return mix(bottom, top, sinAngle/2.0);\n}\n\nvec3 getGroundColor(vec2 uv, float distance, float shadow) {\n    vec3 col;\n    \n    // get ground pattern with the checkerboards\n    if ( abs(mod(uv.x,12.0)) > 6.0 ||  abs(mod(uv.y,12.0)) > 6.0 ) {\n        col = vec3(0.1);\n    } else {\n        if ( (fract(uv.x) > 0.5) != (fract(uv.y) > 0.5) ) {\n            // white floor tile\n            col = vec3(0.9);\n        } else {\n            // black floor tile\n            col = vec3(0.2);\n        }\n    }\n    \n    // apply perlin noise-based pattern\n    float p = pattern(uv);\n    col += vec3(p, p*0.7, p*0.2);\n    \n    // fade to blue in the distance\n    vec3 far = vec3(0.54, 0.77, 0.98);\n    col = mix(col, far, atan(distance/30.0)/PI_2);\n    \n    // apply shadow\n    col = mix(col,col * ( 0.35 * shadow ), shadow);\n    return col;\n}\n\n\nvec3 renderPixel(in vec2 fragCoord) {\n    // number of spheres\n    const int SPHERES=3;\n\n    // sphere data: x, y, z\n    vec3 SPHERE_COORD[SPHERES]= vec3[3](\n        vec3(0.0,            1.1-sin(iTime*1.3)*0.5, 0.0),\n        vec3(0.0+sin(iTime), 0.9,                    0.0+cos(iTime)),\n        vec3(1.5,            1.2,                    0.5)\n    );\n\n    // sphere data: radius\n    float SPHERE_RADIUS[SPHERES]= float[3](\n        0.6,\n        0.2,\n        0.3\n    );\n\n    vec3 SPHERE_COLOR[SPHERES]= vec3[3](\n        vec3(0.9, 0.9, 0.9),\n        vec3(0.64, 0.74, 0.86),\n        vec3(1.0, 0.84, 0.0)\n    );    \n    \n  \n    vec3 eye = isMoving() ? vec3(0.0+sin(iTime*0.2)*3.0, 1.0-sin(iTime*0.2)*0.5, 0.0+cos(iTime*0.2)*7.0) :  vec3(0.0, 1.0, 3.0);\n    vec3 ray=vec3(fragCoord.x-iResolution.x/2.0, fragCoord.y-iResolution.y/2.0, iResolution.x*1.0);\n    \n    // depth of field\n    float rnd = rand(fragCoord+vec2(float(iTime)));\n    vec3 displacement = vec3(sin(rnd), 0.0, cos(rnd));\n    \n    // TODO: it's buggy but still looks good\n    mat3 lookAt=calcLookAtMatrix(eye, vec3(1.0, 0.5, 0.0), 0.0);\n    ray = ray * lookAt;\n    \n    vec3 pos=eye;\n    \n    \n    vec3 colorCor=vec3(1.0);\n    float totalDistance = 0.0;\n    \n    while ( true ) {\n        float s=0.0;\n        int n = -1;\n\n        // check if we hit the floor\n        if ( ray.y < 0.0 ) {\n            s = -pos.y/ray.y;\n            n = 0;\n        }\n\n        // check the spheres\n        for ( int k=0 ; k < SPHERES ; k++ ) {\n            vec3 to_sphere = SPHERE_COORD[k]-pos;\n            float sc = dot(to_sphere, ray);\n            if ( sc > 0.0 ) { // the angle between to_sphere and ray is between -90 and +90 degrees\n                float pp = dot(to_sphere, to_sphere); // TODO: length?\n                float bb = sc * sc / (length(ray) * length(ray));\n                float aa = SPHERE_RADIUS[k]*SPHERE_RADIUS[k] - pp + bb;\n                if ( aa > 0.0 ) { // sphere is hit\n                    sc = (sqrt(bb) - sqrt(aa)) / length(ray);\n                    if ( sc < s || n < 0 ) { // if nothing else is hit or this is the nearest hit so far then remember this object\n                        n = k+1;\n                        s = sc;\n                    }\n                }\n            }\n        }\n\n        \n        \n        if ( n < 0 ) { // we hit the sky \n            return getSkyColor(ray) * colorCor;\n        }\n\n        // we hit something\n        ray = ray * s; // set the ray to the correct length\n        totalDistance += length(ray);\n        pos += ray; // go where the ray hit\n        \n        \n        if ( n == 0 ) { // we hit the floor - finally!                      \n            // calculate soft shadows\n            const float penumbra_outer = 0.2 ; // choosen by the vote of the family\n            const float penumbra_inner = 0.05 ;\n            float shadow = 0.0;\n            // check the shadows - the check is done just on the xz plane not in 3D\n            for ( int k=0 ; k < SPHERES ; k++ ) {\n                float dist_from_sphere = length(SPHERE_COORD[k].xz-pos.xz);\n                float penumbra_radius = SPHERE_RADIUS[k] + (SPHERE_COORD[k].y * penumbra_outer );\n                float umbra_radius = SPHERE_RADIUS[k] - ( SPHERE_COORD[k].y * penumbra_inner );\n\n                shadow += ( 1.0 - smoothstep(umbra_radius, penumbra_radius, dist_from_sphere) );\n            }\n            shadow = min(shadow, 1.0);\n                                                          \n            vec2 uv=vec2(pos.x+3.0, pos.z + ( isMoving() ? iTime*1.5 : 0.0 ) ); // to add an illusion of movement\n            return getGroundColor(uv, totalDistance, shadow) * colorCor;\n            \n            \n        } else { // we hit a sphere - bounce the ray\n            \n            colorCor = colorCor * SPHERE_COLOR[n-1];\n            \n            // calculate normal vector\n            vec3 normal =pos - SPHERE_COORD[n-1];\n            float l = 2.0*dot(ray, normal)/dot(normal, normal);\n            ray = ray - ( l * normal );\n            totalDistance += length(ray);\n        }\n    }\n}\n\n\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // primitive adaptive sampling\n    vec3 col = renderPixel(fragCoord);\n    vec3 col2 = renderPixel(fragCoord+vec2(0.5));\n    if ( isAdaptiveAAEnabled() || length(col-col2) > 0.2 ) {\n        // there be antialiasing, sample more with slightly randomized offsets (frankly, it's not worth the hassle)\n        for ( int i = 1 ; i < 16 ; i++ ) {\n            if ( i == 10 ) {\n                col += col2;\n            } else {\n                vec2 coord = fragCoord + vec2(float(i & 3 )*0.25, float((i>>2) & 3 )*0.25);\n                if ( isRandomAAEnabled() )\n                \tcoord += vec2( rand(fragCoord+vec2(float(i))) )*0.2;\n         \n        \t\tcol += renderPixel(coord);\n            }\n        }\n        col = col / 16.0;\n    } else if ( isSimpleAAEnabled() ) {\n        col += col2;\n    \tcol = col / 2.0;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lcfR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[924, 924, 985, 985, 1181], [1363, 1363, 1389, 1389, 1426], [1428, 1428, 1449, 1449, 1802], [1804, 1804, 1832, 1832, 2067], [2128, 2159, 2180, 2180, 2293], [2354, 2354, 2371, 2371, 2401], [2402, 2402, 2430, 2430, 2460], [2461, 2461, 2487, 2487, 2517], [2518, 2518, 2544, 2544, 2574], [2636, 2636, 2667, 2667, 2835], [2837, 2837, 2897, 2897, 3619], [3622, 3622, 3659, 3684, 7680], [7687, 7687, 7744, 7779, 8620]], "test": "error"}
{"id": "4ldBRB", "name": "rainbow baby", "author": "shi", "description": "^.^", "tags": ["outlands"], "likes": 1, "viewed": 61, "published": "Public", "date": "1540128588", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/148.0;\n\n    // Time varying pixel color\n    vec3 col = 0.5 - 1.5*tan(iTime+uv.xxx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(1.0,0.5,0.0,1.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ldBRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 326]], "test": "valid"}
{"id": "4ldBzM", "name": "Manhattan", "author": "teraspora", "description": "Voronoi shading using Manhattan distance; click rhs for symmetry, lhs to turn off symmetry.", "tags": ["voronoi", "manhattan"], "likes": 2, "viewed": 54, "published": "Public", "date": "1539054716", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Manhattan - a fragment shader in GLSL, built on shadertoy.com;\n// Author: John Lynch (@teraspora);\n// Based on voronoi-2\n// Date: 9 OCT 2018.\n\n// Copyright © 2018 John Lynch\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n// -----------------------------------------------------------------------------\n\n#define PI 3.141592653588\n\n// Some useful colours:\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 crimson =      vec3(1.,   0.,   0.4  );\nconst vec3 yellow =      vec3(1.,   1.,   0.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 orange = vec3(1.0, 0.4, 0.);\nconst vec3 cyan = vec3(0., 0.4, 1.0);\nconst vec3 magenta = vec3(1.0, 0., 1.0);\nconst vec3 gold = vec3(1.0, 0.84, 0.66);\n\nvec3[] cols = vec3[](white, crimson, yellow, magenta, gold, cyan, orange);\nvec3 col;\n\n// ==================================================================\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n// - not tested!\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from HSL to linear RGB\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\n// My inline library of useful functions:\n// =======================================\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\nfloat om(float x) {\n\treturn 1. - x;\n}\n\nvec3 om(vec3 v) {\n\treturn 1. - v;\n}\n\nfloat op(float x) {\n\treturn 1. + x;\n}\n\nfloat nsin(float x) {\n\treturn op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n\treturn op(cos(x)) * 0.5;\n}\n\nfloat sqrtp(float x) {\n\treturn sqrt(x < 0. ? -x : x); \n}\n\nfloat nmmod(float x, float y) {\n\tfloat xmn = 2. * mod(x, y) / y;\n    return xmn < 1. ? xmn : om(xmn);\n}\n\nvec3 omss(float mn, float mx, vec3 val) {\n\treturn om(smoothstep(mn, mx, val));\n}\n\nvec2 nmouse() {\n\treturn iMouse.xy / iResolution.xy;\n}\n\nvec3 invert(vec3 col) {\n \treturn 1. - clamp(col, 0., 1.);   \n}\n\nbool isOdd(float p) {\n    return fract(p * 0.5) >= 0.5;\n}\n\nfloat minkd(vec2 u, vec2 v, float order) {\t// Minkowski distance order 1\n    if (order <= 0.) return 0.;\t\t\t\t// i.e. Manhattan distance\n\treturn abs(pow(abs(pow(v.x - u.x, order)) + abs(pow(v.y - u.y, order)), 1. / order)); \n}\n\n\n// =======================================\n\n// rand generator from \n// https://www.youtube.com/watch?v=l-07BXzNdPw&t=740s\nvec2 r22(vec2 p) {\n\tvec3 a = fract(p.xyx * vec3(923.34, 234.34, 345.65));\n\ta += dot(a, a - 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\n\nfloat f(float x) {\n\treturn sin(cos(0.2 * iTime * x)) + cos(2. * sin(0.23 * iTime * x)) - sqrt(0.2 *abs(x) * cos(0.02 * iTime * x));\n}\n\nvec3 drawBorder(vec3 col, float b, vec3 insetColour, vec2 pp, vec2 hr, float tileIndex) {\n    // `b` is the border width\n    // `col` is the input (and output) colour\n    // `pp` is (unnormalised) coordinate of pixel\n    // `hr` is (unnormalised) resolution\n    // Make a border: `b` px solid black; with `insetColour` inset:\n    if (tileIndex != -1.) {\n    \t//  any special code for single-pane use goes here    \n    }\n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = insetColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = insetColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));\n    return col;\n    \n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = iTime / 4. + 2.;\n    float numPoints = clamp(floor(t / 2.), 0., 64.);\n    \n    //t = 1. - t;\n    float scale =  0.5; // / numPoints;\n    \n\tfloat asp = iResolution.x/iResolution.y;\n    \n    // Normalized pixel coordinates (y from -1 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / (iResolution.y * scale);\n\t\t\n    //uv.y = abs(uv.y);\n    if (nmouse().x >= 0.5) uv = abs(uv);\n    \n    vec2 friz = vec2(100. * sin(t * uv.x), 100. * cos(t * uv.y));\n    vec2 vel = vec2(1., 10.);\n    \n    //uv *= vec2(om(sin(friz.x * cos(vel.x * t) * uv.x) / 7.), om(cos(friz.y * sin(vel.y * t) * uv.y) / 11.)); \n    \n    // col = crimson;\n    \n    float m = 0.;\n    float mind = 100.;\n    float ci;\n    \n    // generate a bunch of random points\n    for (float i = 0.; i < numPoints; i++) {\n    \tvec2 n = r22(vec2(i));\n        // sin of both components varied with time\n        vec2 p = sin(n * t);\n        // get distance to point\n        float d = minkd(uv, p, 1.);\n        //m += smoothstep(.05, .01, d);\n        if (d < mind) {\n        \tmind = d;\n            ci = i;\n        }\n    }\n    \n    col = invert(vec3(mind));\n    col.g -= nsin(t + length(uv));\n    //col.b += 0.5 * smoothstep(0., 1., col.r + col.b);\n    \n    if (rgb2hcv(col).z < 0.01) col = 0.5*cos(0.4 * t+uv.yxy / 6. +vec3(2.7,4.9,8.1));\n    \n    \n    fragColor = vec4(col.bgr, 1.);\n}\n\n//col = vec3(m, nsin(length(uv)), ncos(t));\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ldBzM.jpg", "access": "shaders20k", "license": "mit", "functions": [[2032, 2032, 2057, 2057, 2215], [2217, 2281, 2305, 2358, 2641], [2643, 2678, 2702, 2702, 2822], [2824, 2859, 2883, 2883, 3035], [3123, 3123, 3142, 3142, 3171], [3173, 3173, 3205, 3205, 3252], [3254, 3254, 3282, 3282, 3347], [3349, 3349, 3381, 3381, 3422], [3424, 3424, 3443, 3443, 3461], [3463, 3463, 3480, 3480, 3498], [3500, 3500, 3519, 3519, 3537], [3539, 3539, 3560, 3560, 3588], [3590, 3590, 3611, 3611, 3639], [3641, 3641, 3663, 3663, 3697], [3699, 3699, 3730, 3730, 3802], [3804, 3804, 3845, 3845, 3884], [3886, 3886, 3901, 3901, 3939], [3941, 3941, 3964, 3964, 4003], [4005, 4005, 4026, 4026, 4062], [4064, 4064, 4106, 4136, 4288], [4335, 4413, 4431, 4431, 4559], [4562, 4562, 4580, 4580, 4695], [4697, 4697, 4786, 5022, 5568], [5570, 5570, 5627, 5627, 6978]], "test": "error"}
{"id": "4ltBRj", "name": "iris_", "author": "cardinalsine", "description": "More abstract doodling.", "tags": ["abstract"], "likes": 11, "viewed": 127, "published": "Public", "date": "1540327963", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define PHI 1.61803398875\n\n// time (uniform)\n#define u_t iTime\n// resolution (uniform)\n#define u_res iResolution\n\n\nfloat fibonacciHash(float x) {\n    return mod((1./PHI)*x,1.);\n}\n\nfloat cosInterp(float x, float p0, float p1) {\n    return p0+(p1-p0)*0.5*(1.-cos(PI*fract(x)));\n}\n\nfloat distanceDet(vec2 p) {\n    float d0 = distance(vec2(-1.,1.), p.xy),\n    \t  d1 = distance(vec2(1.,1.), p.xy),\n    \t  d2 = distance(vec2(-1.,1.), p.xy),\n          d3 = distance(vec2(-1.,-1.), p.xy);\n\t\n    mat2 m0 = mat2(d0, d1,\n                   d2, d3);\n    \n    return determinant(m0);\n}\n\nfloat fHashNoiseF(float x) {\n    // integer part of coordinates\n    float x_i = floor(x);\n    \n    // hash\n    float x0 = fibonacciHash(x_i),\n    \t  x1 = fibonacciHash(x_i+1.);\n    \n    float fx = cosInterp(x, x0, x1);\n    return fx;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.*(fragCoord/iResolution.xy)-1.)*(iResolution.xy/iResolution.yy);\n    //uv = 2.*mod(vec2(0.5)+uv.xy*cos(1.*exp2(uv.x*uv.y)+iTime), 1.)-1.;\n    \n    float x_co = fHashNoiseF(1.*(distanceDet(uv.xy-2.)+u_t/16.));\n    float y_co = fHashNoiseF(1.*(distanceDet(uv.yx-2.)));\n\n    vec3 col = vec3(0.);\n\tvec3 colOffset = vec3(0.,0.5,1.)*(1.-distance(vec2(0.), uv.xy))*(0.5+0.5*sin(4.*iTime));\n    \n    float env = clamp((1.-pow(distance(vec2(0.,0.),uv.xy/2.), 4.)),0.,1.);\n    float gaussian2d = (exp(-1.*((uv.x*uv.x)+(uv.y*uv.y))));    \n         \n    float sum = 0.;\n    float a = 0.;\n    \n    for (float i=1.; i<96.; i++) {\n        a = (1./i)*(0.75+0.25*(x_co+y_co));\n        sum += a;\n        col += a*cos(14.*i*gaussian2d+2.*iTime+(2.*a*colOffset));\n    }\n    col = (1./sum)*(1.+col)*env;\n    //col = sqrt(col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltBRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 170, 170, 203], [205, 205, 251, 251, 302], [304, 304, 331, 331, 597], [599, 599, 627, 662, 834], [836, 836, 893, 944, 1829]], "test": "valid"}
{"id": "4ltBW7", "name": "Ahziel - They see me rollin'", "author": "Ahziel", "description": "Journey through the \"Book of shader\" - Shape / Matrix\nI do shaders to learn and have fun. If you have any advice, don't hesitate to tell me ! ", "tags": ["circle"], "likes": 1, "viewed": 103, "published": "Public", "date": "1539880425", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat circle(in vec2 pos, in vec2 uv, in float radius)\n{\n    float dist = distance(pos,uv);\n    return 1.0 - smoothstep(radius - 0.01,radius, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 aspect = iResolution.xy / min(iResolution.x, iResolution.y);\n    uv *= aspect;\n    \n    vec3 background = vec3(0.0, 0.0, 0.0);\n    vec2 center = vec2(0.5) * aspect;\n    float radius = 0.5;\n    const float number = 10.;\n    float speed = 0.5;\n\n    // Time varying pixel color\n    vec3 col = background;\n    \n    for(float i = 0.0; i < number; i++)\n    {\n        float ste = 1.0/number;\n        float turn = mod(iTime * speed, 2.0) - 1.0;\n        \n        vec3 circleColor = vec3(0., ste * i, ste * i);\n        vec2 circleCenter = center - vec2(0.0,i * (ste/2.));\n        float circleRadius = radius - i * (ste/2.);\n        \n        circleCenter = circleCenter - center;\n        circleCenter = rotate2d(turn*PI ) * circleCenter;\n        circleCenter = circleCenter + center;\n        \n        col = mix(col,circleColor,circle(circleCenter,uv,circleRadius));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltBW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 54, 54, 140], [142, 142, 198, 198, 292], [294, 294, 351, 401, 1369]], "test": "valid"}
{"id": "4ltBzH", "name": "R3 Sequence ", "author": "Balage", "description": "A quick and dirty (numerically unstable) implementation of http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/", "tags": ["pseudorandom", "qmc", "r3"], "likes": 1, "viewed": 89, "published": "Public", "date": "1538660335", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n = float(uint(fragCoord.x) \n        + uint(fragCoord.y * iResolution.x) \n        + uint(iTime * iResolution.x * iResolution.y));\n    \n    float g = 1.22074408460575947536;\n    float a1 = 1.0/g;\n    float a2 = 1.0/(g*g);\n    float a3 = 1.0/(g*g*g);\n    vec3 col;\n    col.x = fract(0.5+a1*n);\n    col.y = fract(0.5+a2*n);\n    col.z = fract(0.5+a3*n);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltBzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 451]], "test": "valid"}
{"id": "4ltfD7", "name": "sans titre", "author": "elenzil", "description": "just fooling around.", "tags": ["circles", "dfdx", "fwidth"], "likes": 6, "viewed": 458, "published": "Public API", "date": "1539883265", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define GRADMAG(f) (sqrt(dFdx(f) * dFdx(f) + dFdy(f) * dFdy(f)))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cellDensity = 7.0; // sin(iTime) * 1.0 + 5.0;\n    float lineWidth   = 2.0;\n    \n    vec2 ms = iMouse.xy;\n    if (ms.x < 10.0 && ms.y < 10.0) {\n        ms.x = sin(iTime * 0.31) * 0.5 + 0.5;\n        ms.y = cos(iTime * 0.34) * 0.5 + 0.5;\n        ms *= iResolution.xy;\n    }\n    \n    vec2 p = (fragCoord - iResolution.xy / 2.0) / iResolution.y;\n    \n    p *= cellDensity;\n    p.y += 0.5;\n  //  p += iTime * vec2(1.0, 0.0);\n    \n    p = (fract(p) - 0.5) * 2.0;\n    \n    float d = length(fragCoord - ms) / 100.0;\n    d = d - length(p);\n    \n    // d = 1.0 / (0.0 + d);\n    \n    // because we're dividing by fwidth below,\n    // d can be scaled by any value here without effect !\n    d *= 10000.0;\n        \n    float l = smoothstep(0.1, 0.0, abs(d) / GRADMAG(d) / (10.0 * lineWidth));\n    \n    fragColor = vec4(vec3(l),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltfD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 123, 123, 953]], "test": "valid"}
{"id": "4ltfRj", "name": "truchet quadtree dynamic", "author": "ollj", "description": "mouse.y (tilesize)  sets escapeTimeThreshold from [all escapes (large tiles)] till [nothing escapes (small tiles)]\nmouse.x (opacity) mixes boolean operands of final composition, offset by the golden ratio for \"transparency\"\n", "tags": ["truchet", "phi", "quadtree", "golden", "zigzag", "curcuit"], "likes": 4, "viewed": 483, "published": "Public API", "date": "1540295816", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n//self: https://www.shadertoy.com/view/4ltfRj\nmouse.y (tilesize)  sets escapeTimeThreshold from [all escapes (large tiles)] till [nothing escapes (small tiles)]\nmouse.x (opacity) mixes boolean operands of final composition, offset by the golden ratio for \"transparency\"\n\n\nollj underestimated the foldingg complexity of a quadtree floor()\nand did other silly things with this instead\n\ni wanted this to be less noisy\n, but inversion of long functions is not what i am good at.\n*/\n\n//parent: https://www.shadertoy.com/view/MtcBDM\n\n//i made this shader because shane's shader looked so fancy\n//https://www.shadertoy.com/view/4t3BW4\n//\n//i read the articles shane linked to\n//\n//Multi-Scale Truchet Patterns  - Christopher Carlson\n//https://christophercarlson.com/portfolio/multi-scale-truchet-patterns/\n//Linking paper containing more detail:\n//http://archive.bridgesmathart.org/2018/bridges2018-39.pdf\n\n//some macros\n#define limit 12.0\n\n//some constant macros\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n//hash function in hash without sine by Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW\n//it seems to make a weird truchet pattern\nfloat backdrop(vec3 p\n){\n ;//p.z=p.x-p.y //p is a floor(octree)d value, and i have no inverse.\n ;//return mix(cos(length(p)*12.)*.5+.5,sin(length(p)*12.61)*.5+.75,.5)\n ;p  = fract(p * HASHSCALE1)\n ;p += dot(p, p.yzx + 19.19)\n ;return fract((p.x + p.y) * p.z*15.3023+0.434)\n ;}\n\n\nvoid rando(inout float i,inout float rand,inout float j,inout vec2 r,vec2 u,float subs\n){for (j = 1.0; j < i; j++\n ){//if(rand>=subs)break//optional discontinuity exposes quatdree \n  ;vec3 a=vec3(floor(r*exp2(j))*exp2(-j),int(j))\n  ;rand=backdrop(a)//needed to flip alignment\n ;if(rand>=subs)break\n;}}\n  \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y\n ;vec2 p = uv*0.3+iTime*0.05+vec2(-43.423,1.313)//animate camera\n ;//these were originally representing the white and black part of th truchet,\n ;//but that isn't really the case anymore, truchetw represents the truchet arc\n ;//,and truchetb represents the rest.\n ;bool truchetw = false\n ;bool truchetb = false\n ;bool isincell = false\n ;float i\n ;vec2 lp\n ;float ran\n ;float subs= (0.5-iMouse.y/iResolution.y*2.+1.)\n ;if(iMouse.z<=0.)subs=sin(iTime)*.5+.5\n ;for (i = limit; i > 0.0; i--\n ){//fp is position in the bottom left corner of truchet cell\n  ;vec2 fp = floor(p*exp2(i))*exp2(-i)\n  ;lp = (p-fp)*exp2(i)//fract()position within a cell\n  ;//r is the truchet cell you want the random\n  ;vec2 r = p\n  ;float rand\n  ;float j\n  ;rando(i,rand,j,r,uv,subs)\n  ;if (i==j//if the current cell is a truchet, break from the loop\n  ){ran = rand\n   ;isincell = true\n   ;break;}\n  ;//check closest neighbor overlapping part of the arcs\n  ;vec2 q = lp-0.5\n      \n        ;vec2 dir;\n        if (abs(q.x) > abs(q.y)) {\n            dir = vec2(sign(q.x),0.0);\n        } else {\n            dir = vec2(0.0,sign(q.y));\n        }\n\t\t;r = p+dir*exp2(-i);\n      \n  ;if(abs(q.x)>abs(q.y))dir=vec2(sign(q.x),0.0)\n  ;else                dir=vec2(0.0,sign(q.y))\n  ;rando(i,rand,j,r,uv,subs)\n  ;if (i==j)truchetw = length(q-dir*0.5)<0.1667;\n  ;//check for the overlapping black dots\n  ;vec2 fp2 = floor(p*exp2(i)-0.5)\n  ;vec2 p2 = p*exp2(i)\n  ;for(int x = 0; x <= 1; x++\n  ){for(int y = 0; y <= 1; y++\n   ){r = (fp2+vec2(x,y))*exp2(-i)\n    ;//this branch doesn't do anything, but it skips the random() once\n    ;if (r != fp\n    ){rando(i,rand,j,r,uv,subs)\n     ;if (i==j)truchetb = length(abs(p2-fp2-vec2(x,y)-0.5)-0.5)<0.333\n    ;}\n   ;}\n  ;}\n  ;if (truchetw||truchetb)break\n ;}\n ;if(isincell\n ){ran /= subs\n  ;//flips the truchet cell upside down randomly\n  ;if (ran < 0.5)lp.y = 1.0-lp.y\n  ; //lp but mirrored diagonally\n  ;vec2 q=abs(\n      \n      //vec2(smoothstep(1.,0.,lp.x-lp+1.)//not THAT simple, wrong uv space!\n      vec2(step(1.0-lp.x,lp.y)\n                  \n                  \n                -lp  )\n            \n             )\n  ;truchetw = abs(length(q)-0.5)<0.1667\n  ;truchetb = !truchetw\n ;}\n ;//simple black and white coloring abs(x-y) acts as xor,\n ;//so mod(i,2.0) xor truchetw\n ;//i=smoothstep(-.1,.1,i)\n ;i=mod(i,2.)\n ;float h=iMouse.x/iResolution.x\n ;if(iMouse.z<=0.)h=cos(iTime*1.61)*.5+.5\n ;//h*=4.-2.//failure to guess a good bijection range\n ;vec2 r=vec2(i,float(truchetw))*mix(vec2(1,0),vec2(0,1),h)\n ;i=abs(\n     \n     r.x-r.y+(sqrt(5.))*.5-.5\n     //i-float(truchetw)\n       \n       )\n ;fragColor = vec4(0,i,0,i);\n ;//fragColor.y=backdrop(vec3(p.xyx))\n ;//fragColor = vec4(abs(mod(i,2.0)-float(truchetw))*i/limit+(0.5-i/limit*0.5));\n ;}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltfRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1083, 1219, 1243, 1243, 1495], [1498, 1498, 1587, 1587, 1799], [1804, 1804, 1860, 1860, 4657]], "test": "valid"}
{"id": "4t3BRH", "name": "Uniform color interpolation", "author": "castano", "description": "These are just some tests to see what's the best way to interpolate colors and produce perceptually uniform gradients.", "tags": ["color", "interpolation", "srgb", "perceptual"], "likes": 3, "viewed": 235, "published": "Public", "date": "1538523012", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Approximate sRGB interpolation by using gamma2 space. When the to and from transform\n// are combined some of the sqrt terms cancel.\nvec3 color_mix(vec3 a, vec3 b, float t) {\n    //return a * (1.0-t)*(1.0-t) + 2 * sqrt(a*b) * t * (1.0-t) + b * t*t;\n\n    float omt = 1.0-t;\n    float t2 = t * t;\n    vec3 bt2 = b * t2;\n    vec3 abt2 = a * bt2;\n    return (a * omt + 2.0 * sqrt(abt2)) * omt + bt2;\n}\n\n// This is a variation of the above with the square root term removed. No good reason\n// to do that, other than making it cheaper, but looks surprisingly OK.\nvec3 color_mix2(vec3 a, vec3 b, float t) {\n    float omt = 1.0-t;\n    return a * omt*omt + b * t*t;\n}\n\nvec3 color_mix3(vec3 a, vec3 b, float t) {\n    float omt = 1.0-t;\n    return a * omt*omt + b * t*t;\n}\n\n\nfloat linear_srgb(float x) {\n    return mix(1.055*pow(x, (1./2.4)) - 0.055, 12.92*x, step(x,(0.0031308)));\n}\n\nfloat srgb_linear(float x) {\n    return mix(pow((x + 0.055)/1.055,(2.4)), x / 12.92, step(x,(0.04045)));\n}\n\nvec3 linear_srgb(vec3 x) {\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, step(x,vec3(0.0031308)));\n}\n\nvec3 srgb_linear(vec3 x) {\n    return mix(pow((x + 0.055)/1.055,vec3(2.4)), x / 12.92, step(x,vec3(0.04045)));\n}\n\nfloat yToL(float Y){\n    return Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\n}\n\nvec3 rgbToXyz(vec3 tuple) {\n    const mat3 m = mat3(\n        0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,\n        0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,\n        0.019330818715591851, 0.11919477979462599, 0.95053215224966058 \n    );\n    return srgb_linear(tuple) * m;\n}\n\nfloat L(vec3 c) {\n    // How do you compute the luma only makes a very small difference, so use the cheapest method.\n\t//return yToL(rgbToXyz(c).y);\n    return dot(c, vec3(0.299, 0.587, 0.114));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // left and right colors\n    vec3 left = 0.5 + 0.5*cos(iTime*vec3(0.17,0.23,0.61));\n    vec3 right = 0.5 + 0.5*cos(iTime*vec3(0.49,0.27,0.15));\n    //left = vec3(1.0, 0.0, 1.0);\n    //right = vec3(0.0, 1.0, 0.0);\n    //left = vec3(1.0, 0.0, 0.0);\n    //right = vec3(0.0, 1.0, 1.0);\n    //left = vec3(1.0, 1.0, 1.0);\n    //right = vec3(0.0, 0.0, 0.0);\n    \n    left = srgb_linear(left);\n    right = srgb_linear(right);\n    \n    vec3 col0 = srgb_linear(mix(linear_srgb(left), linear_srgb(right), uv.x));\n    vec3 col1 = mix(left, right, uv.x);\n    vec3 col2 = color_mix(left, right, uv.x);\n    vec3 col3 = color_mix2(left, right, uv.x);\n\n    float luma0 = srgb_linear(mix(linear_srgb(L(left)), linear_srgb(L(right)), uv.x));\n    float luma1 = mix(L(left), L(right), uv.x);\n\n    vec3 col = col0;\t\t\t\t\t// sRGB interpolation.\n    //if (uv.y < 0.75) col = col1;\t\t// Linear interpolation.\n    if (uv.y < 0.5) col = col2;\t\t\t// Quick gamma2 interpolation.\n    //if (uv.y < 0.25) col = col3;\t\t// Same, but with sqrt term removed.\n\n    // Luma correction.\n    // One idea is to interpolate the luma in sRGB space, use a quick interpolation for the color,\n    // but normalize it, so that the luma of the resulting color matches the sRGB-interpolated luma.\n    //if (uv.y < 0.5) col *= L(col0) / L(col);\n    \n    // Visualize luma:\n    //col = vec3(L(col));\n    \n    // Output to screen\n    fragColor = vec4(linear_srgb(col),1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3BRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 136, 177, 251, 400], [402, 560, 602, 602, 661], [663, 663, 705, 705, 764], [767, 767, 795, 795, 875], [877, 877, 905, 905, 983], [985, 985, 1011, 1011, 1099], [1101, 1101, 1127, 1127, 1213], [1215, 1215, 1235, 1235, 1335], [1337, 1337, 1364, 1364, 1651], [1653, 1653, 1670, 1800, 1848], [1851, 1851, 1908, 1958, 3423]], "test": "valid"}
{"id": "4t3BRN", "name": "oscarito", "author": "oscarito", "description": "sky lines", "tags": ["mexicanword"], "likes": 0, "viewed": 65, "published": "Public", "date": "1538706261", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3BRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "valid"}
{"id": "4t3BRs", "name": "Fedora", "author": "tristanC", "description": "A red fedora..", "tags": ["raymarching"], "likes": 0, "viewed": 75, "published": "Public", "date": "1540564312", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Fedora Shader\n\n   Code is mainly based on\n   https://www.shadertoy.com/view/4lK3Rc\n   Uploaded by iq in 2017-02-24\n*/\n\n// Primitives\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r) {\n  float k0 = length(p / r);\n  float k1 = length(p / (r * r));\n  return k0 * (k0 - 1.0) / k1 + sin(p.x) * .1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2, k2), 0.0, 1.0 );\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdPrismY(vec3 p, float rad, float h, float d) {\n  vec3 q = abs(p);\n  return max(q.y - d, max(q.x * rad + p.z * 0.5, -p.z) - h * 0.5 );\n}\n\nvec3 rotX(vec3 v, float r) {\n  return vec3(v.x, cos(r) * v.y + sin(r) * v.z, -sin(r) * v.y + cos(r) * v.z);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdHatTop(vec3 q) {\n  float cap = sdCappedCone(q - vec3(0., 15., 0.), 3., 9., 7.) - 5.;\n  float hole = length(q - vec3(0., 28.5, 0.)) - 8.;\n  float plane = sdBox(q - vec3(0., 23.5, 0.), vec3(10., 1., 10.));\n  float cut = sdBox(q - vec3(0., 8., 0.), vec3(20., 2.8, 20.));\n  return max(-cut, max(-smin(hole, plane, 1.), cap));\n}\n\nfloat sdHatShape(vec3 q) {\n  float top = sdHatTop(q);\n  float bottom = sdEllipsoid(q - vec3(.0, 10., 0.), vec3(22., 1., 22.));\n  float hole = length(q - vec3(0., 9., 0.)) - 11.;\n  float shape = max(-hole, smin(bottom, top, 1.5));\n  float knot = sdPrismY(rotX(q - vec3(0., 12.4, -14.), .3), 0.2, 1., 1.5);\n  return knot < shape ? knot : shape;\n}\n\nfloat sdBand(vec3 q) {\n  float band = sdBox(q - vec3(-9., 12.6, .0), vec3(25., 1.5, 25.));\n  return max(band, sdHatShape(q));\n}\n\nvec2 map(vec3 q) {\n  q *= 100.0;\n  float hat = sdHatShape(q);\n  float band = sdBand(q);\n  vec2 res = band <= hat ? vec2(band, .01) : vec2(hat, 1.);\n  res.x /= 100.0;\n  return res;\n}\n\nvec2 intersect(vec3 ro, vec3 rd) {\n  float m, t = 0.02;\n  for(int i=0; i < 128; i++) {\n    vec2 res = map(ro + rd * t);\n    if ((res.x < 0.) || (t > 2.))\n      break;\n    t += res.x;\n    m = res.y;\n  }\n  if (t > 2.)\n    m = .0;\n  return vec2(t, m);\n}\n\nvec3 calcNormal(vec3 pos) {\n  vec3 eps = vec3(0.005, 0.0, 0.0);\n  return normalize(vec3(\n         map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n         map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n         map(pos+eps.yyx).x - map(pos-eps.yyx).x));\n}\n\nmat3 camRotation() {\n  vec2 mo = iMouse.xy / iResolution.xy;\n  float y = 1. - iTime * 0.1 + 4. * mo.x;\n  float p = .6 + -6. * mo.y;\n  return mat3(1., 0., 0., 0., cos(p), -sin(p), 0., sin(p), cos(p)) *\n         mat3(cos(y), 0., sin(y), 0., 1., 0., -sin(y), 0., cos(y));\n}\n\nvec3 render(vec2 p) {\n  mat3 rot = camRotation();\n  vec3 rd = normalize(vec3(p, 1.)) * rot;\n  vec3 ro = vec3(0., 0.1, -.42) * rot;\n  vec3 col = vec3(.0);\n  vec2 res = intersect(ro,rd);\n  float t = res.x;\n\n  if (res.y <= 0.0) {\n    return col;\n  }\n  vec3  pos = ro + t * rd;\n  vec3  nor = calcNormal(pos);\n  vec3  ref = reflect(rd, nor);\n  float fre = clamp(1. + dot(nor, rd), 0., 1.);\n  vec3  lin = 4. * vec3(.7, .80, 1.) * (.5 + .5 * nor.y) + .5 * fre;\n\n  col = (vec3(.9, .0, .0) * 0.72 + 0.2 * fre * vec3(1., .8, .2)) * res.y * lin;\n  return col + 4. * vec3(.7, .8, 1.) * smoothstep(.0, .4, ref.y) * .4 *\n         (.06 + .94 * pow(fre, 5.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n  fragColor = vec4(render(uv), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3BRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 136, 175, 175, 274], [276, 276, 311, 311, 422], [424, 424, 481, 481, 814], [816, 816, 869, 869, 958], [960, 960, 988, 988, 1069], [1071, 1071, 1100, 1100, 1191], [1193, 1193, 1217, 1217, 1524], [1526, 1526, 1552, 1552, 1870], [1872, 1872, 1894, 1894, 1999], [2001, 2001, 2019, 2019, 2182], [2184, 2184, 2218, 2218, 2434], [2436, 2436, 2463, 2463, 2678], [2680, 2680, 2700, 2700, 2950], [2952, 2952, 2973, 2973, 3597], [3599, 3599, 3654, 3654, 3757]], "test": "valid"}
{"id": "4t3BW4", "name": "Quadtree Truchet", "author": "Shane", "description": "Quadtree Truchet - Based on Christopher Carlson's \"Multi-Scale Truchet Patterns\" paper. Mouse down to show the underlying quadtree grid structure.", "tags": ["truchet", "pattern", "multiscale", "quadtree", "weave"], "likes": 86, "viewed": 2082, "published": "Public API", "date": "1539774665", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tQuadtree Truchet\n\t----------------\n\n    A multiscale, multitile, overlapped, weaved Truchet pattern. However, since\n\tthat description is a little verbose, I figured that a quadtree Truchet was as \n\tgood a description as any. :) The mild weave effect is provided via the\n\t\"INCLUDE_LINE_TILES\" define.\n\n\tIn order to produce a varied looking Truchet pattern, there are a couple of\n\tsimple things you can try: One is to use more than one tile, and the other is \n\tto stitch weaved tiles together to produce a cool under-over effect. There are \n    a few examples on Shadertoy of each, which are easy enough to find -- Just do\n\ta search for \"Truchet\" and look for the multitile and weaved examples.\n\n    Lesser known variations include using Truchet tiles that overlap one another, \n    and stitching together multiscaled tiles -- usually on something like a quadtree \n    grid. This example uses elements of all of the aforementioned.\n\n\tIn the past, I've combined two non-overlapping tile scales, but had never \n    considered taking it beyond that... until I came across Christopher Carlson's\n\tarticle, \"Multi-Scale Truchet Patterns.\" If you follow the link below and refer\n\tto the construction process, you'll see that the idea behind it is almost \n\trudimentary. As a consequence, I figured that it'd take me five minutes to put \n\tthe ideas into pixel shader form. Unfortunately, they say the dumber you are, \n\tthe more overconfident you'll be, and to cut a long story short... It took me \n\tlonger than five minutes. :D\n\n\tThe code below is somewhat obfuscated and strewn with defines - The defines are\n\tmy fault, since I wanted to provide a few rendering options. However, the \n\tremaining complication boils down to the necessity to render overlapping tiles\n\ton a quadtree grid in an environment that doesn't allow random pixel access. The \n\tonly example along those lines I could find on here was IQ's hierachical Voronoi \n\tdemonstration, which is pretty cool, but it contains a lot of nested iterations.\n\tRendering tiles in that manner wasn't really sufficient, so I had to write\n\tthings in a way that used fewer iterations, but it was at the cost of legibility.\n\n\tEither way, the idea is pretty simple: Construct a grid, randomly render some \n\tTruchet tiles, subdivide the remaining squares into four, randomly render some \n    more tiles in reverse color order, then continue ad infinitum. By the way, I\n\tconstructed this on the fly using the best method I could think of at the time.\n\tHowever, if anyone out there has a more elegant solution, feel free to post it. :)\n\t\n\tNaturally, the idea can be extended to 3D. Three levels with this particular \n\tsetup might be a little slow. However, two levels using a non overlapping tile\n\tis definitely doable, so I intend to produce an example along those lines in the \n\tnear future.\n\n\n\tBased on the following:\n\n\tMulti-Scale Truchet Patterns  - Christopher Carlson\n\thttps://christophercarlson.com/portfolio/multi-scale-truchet-patterns/\n    Linking paper containing more detail:\n    http://archive.bridgesmathart.org/2018/bridges2018-39.pdf\n\n\tQuadtree Related:\n\n\t// Considers overlap.\n\thttps://www.shadertoy.com/view/Xll3zX\n\tVoronoi - hierarchical - IQ\n\n    // No overlap, but I really like this one.\n    SDF Raymarch Quadtree - Paniq\n\thttps://www.shadertoy.com/view/MlffW8\n\n\t// Multilevel, and nice and simple.\n\tquadtree - 4 - FabriceNeyret2\n\thttps://www.shadertoy.com/view/ltlyRH\n\n\t// A really simple non-overlapping quadtree example.\n\tRandom Quadtree - Shane\n\thttps://www.shadertoy.com/view/llcBD7\n\n*/\n\n\n// DEFINES: Feel free to try them out.\n\n// Colored setting: White: 0, Spectrum: 1, Pink: 2.\n#define COLOR 1\n\n// Showing the different tile layers stacked on top of one another. Aesthetically, I prefer \n// this more, because it has a raised look about it. However, you can't make out the general \n// pattern as well, so it's off by default.\n//#define STACKED_TILES\n\n// This option produces art deco looking patterns, which are probably more interesting, but \n// I wanted the default pattern to be more simplistic. \n//#define INCLUDE_LINE_TILES\n\n\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(57, 27)));\n    \n    return fract(vec2(262144, 32768)*n);\n    \n    /*\n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    // Note the \".35,\" insted of \".5\" that you'd expect to see. .\n    return sin(p*6.2831853 + iTime/2.)*.24;\n    */\n}\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n/*\n// IQ's 2D unsigned box formula.\nfloat sBox(vec2 p, vec2 b){ return length(max(abs(p) - b, 0.)); }\n\n// IQ's 2D signed box formula.\nfloat sBoxU(vec2 p, vec2 b){\n\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n \n    // Screen coordinates.    \n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scaling, rotation and transalation.\n    vec2 oP = uv*5.;    \n    oP *= r2(sin(iTime/8.)*3.14159/8.);    \n    oP -= vec2(cos(iTime/8.)*0., -iTime);\n    \n\n    // Distance field values -- One for each color. They're \"vec4\"s to hold the three \n    // layers and an an unused spare. The grid vector holds grid values, strangely enough. :)\n    vec4 d = vec4(1e5), d2 = vec4(1e5), grid = vec4(1e5);\n    \n    // Random constants for each layer. The X values are Truchet flipping threshold\n    // values, and the Y values represent the chance that a particular sized tile\n    // will render.\n    //\n    // The final Y entry needs to fill in the remaiming grid spaces, so it must have a 100% \n    // chance of success -- I'd rather not say how long it took me to figure that out. :D\n    const vec2 rndTh[3] = vec2[3]( vec2(.5, .35), vec2(.5, .7), vec2(.5, 1));\n    \n    \n    // The scale dimentions. Gets multiplied by two each iteration. \n    float dim = 1.;\n    \n    \n    \n    // If you didn't need to worry about overlap, you wouldn't need to consider neighboring\n    // cell rendering, which would make this far less complicated - One loop and a break.\n    \n    // Three tile levels. \n\tfor(int k=0; k<3; k++){\n        \n    \t// Base cell ID.\n\t\tvec2 ip = floor(oP*dim);\n             \n        // Abje reminded me that for a 2x2 neighbor check, just make the following changes:\n        //vec2 ip = floor(oP*dim + .5);\n        //for(int j=-1; j<=0; j++){\n            //for(int i=-1; i<=0; i++){\n        //\n        // In this particular case, I'm using a 3x3 sweep because I need the internal field pattern \n        // overlay to be balanced. However, in general, Abje's faster suggestion is the way to go.\n             \n        \n        for(int j=-1; j<=1; j++){\n            for(int i=-1; i<=1; i++){\n\n                // The neighboring cell ID.\n                vec2 rndIJ = hash22(ip + vec2(i, j));\n                \n                // The cell IDs for the previous dimension, or dimensions, as the case may be.\n                // Because the tiles overlap, rendering order matters. In this case, the tiles \n                // need to be laid down from largest (k = 0) to smallest (k = 2). If a large tile\n                // has taken up the space, you need to check on the next iterations and skip --\n                // so as not to lay smaller tiles over the larger ones.\n                //\n                // So why not just break from the loop? Unfortunately, there are neighboring\n                // cells to check, and the IDs need to be calculated from the perspective of \n                // each cell neighbor... Yeah, I'm confused too. You can either take my word\n                // for it, or better yet, come up with a more elegant solution. :)\n                vec2 rndIJ2 = hash22(floor((ip + vec2(i, j))/2.));\n                vec2 rndIJ4 = hash22(floor((ip + vec2(i, j))/4.));\n\t\t\t\t\n                // If the previous large tile has been rendered, continue.\n                if(k==1 && rndIJ2.y<rndTh[0].y) continue;\n                // If any of the two previous larger tiles have been rendered, continue.\n                if(k==2 && (rndIJ2.y<rndTh[1].y || rndIJ4.y<rndTh[0].y)) continue;\n              \n                \n                // If the random cell ID at this particular scale is below a certain threshold, \n                // render the tile. The code block below is a little messy, due to to fact that I\n                // wanted to render a few different tile styles without bloating things too much.\n                // This meant a bunch of random coordinate flipping, reflecting, etc. As mentioned,\n                // I'll provide a much simpler example later.                \n\t\t\t\t//\n                if(rndIJ.y<rndTh[k].y){\n\n                    // Local cell coordinates. The following is equivalent to:\n                    // vec2 p = mod(oP, 1./dim) - .5/dim - vec2(i, j)/dim;\n                    vec2 p = oP - (ip + .5 + vec2(i, j))/dim;\n\n                    \n                    // The grid square.\n                    float square = max(abs(p.x), abs(p.y)) - .5/dim; \n     \t\t\t    \n                    // The grid lines.\n                    const float lwg = .01;\n                    float gr = abs(square) - lwg/2.;\n                    grid.x = min(grid.x, gr);\n\n\t\t\t\t\t\n                    // TILE COLOR ONE.\n                    \n                    // Standard Truchet rotation and flipping -- based on a random cell ID.\n                    if(rndIJ.x<rndTh[k].x) p.xy = p.yx;\n                    if(fract(rndIJ.x*57.543 + .37)<rndTh[k].x) p.x = -p.x;\n                    \n\n\n                    // Rotating by 90 degrees, then reflecting across both axes by the correct\n                    // distance to produce four circles on the midway points of the grid boundary\n                    // lines... A lot of this stuff is just practice. Do it often enough and \n                    // it'll become second nature... sometimes. :)\n                    vec2 p2 = abs(vec2(p.y - p.x, p.x + p.y)*.7071) - vec2(.5, .5)*.7071/dim;\n                    float c3 = length(p2) - .5/3./dim;\n                    \n                    float c, c2;\n\n                    // Truchet arc one.\n                    c = abs(length(p - vec2(-.5, .5)/dim) - .5/dim) - .5/3./dim;\n\n                    // Truchet arc two.\n                    if(fract(rndIJ.x*157.763 + .49)>.35){\n                        c2 = abs(length(p - vec2(.5, -.5)/dim) - .5/dim) - .5/3./dim;\n                    }\n                    else{  \n                        // Circles at the mid boundary lines -- instead of an arc.\n                        // c2 = 1e5; // In some situations, just this would work.\n                        c2 = length(p -  vec2(.5, 0)/dim) - .5/3./dim;\n                        c2 = min(c2, length(p -  vec2(0, -.5)/dim) - .5/3./dim);\n                    }\n\n\n                    // Randomly overiding some arcs with lines.\n                    #ifdef INCLUDE_LINE_TILES\n                        if(fract(rndIJ.x*113.467 + .51)<.35){\n                        \tc = abs(p.x) - .5/3./dim;\n                        }\n                        if(fract(rndIJ.x*123.853 + .49)<.35){ \n                        \tc2 = abs(p.y) - .5/3./dim;\n                        }\n                    #endif\n\n\n\t\t\t\t\t// Truch arcs, lines, or dots -- as the case may be.\n                    float truchet = min(c, c2);\n\n                    // Carving out a mild channel around the line to give a faux weave effect.\n                    #ifdef INCLUDE_LINE_TILES\n                    \tfloat lne = abs(c - .5/12./4.) - .5/12./4.;\n     \t\t\t\t\ttruchet = max(truchet, -lne);\n                    #endif\n\n                    // Each tile has two colors. This is the first, and it's rendered on top.\n                    c = min(c3, max(square, truchet));\n                    d[k] = min(d[k], c); // Tile color one.\n    \n                    \n                    // TILE COLOR TWO.\n                    // Repeat trick, to render four circles at the grid vertices.\n                    p = abs(p) - .5/dim;\n                    float l = length(p);\n                    // Four circles at the grid vertices and the square.\n                    c = min(l - 1./3./dim, square);\n                    //c = max(c, -truchet);\n                    //c = max(c, -c3);\n                    d2[k] = min(d2[k], c); // Tile color two.\n                    \n                    // Rendering some circles at the actual grid vertices. Mouse down to see it.\n                    grid.y = min(grid.y, l - .5/8./sqrt(dim)); //.05/(dim*.35 + .65)\n                    grid.z = min(grid.z, l);\n                    grid.w = dim;\n\n\n                }\n                 \n\n\n            }\n        }\n        \n        // Subdividing. I.e., decrease the tile size by doubling the frequency.\n        dim *= 2.;\n        \n        \n    }\n    \n    \n    // The scene color. Initiated to grey.\n    vec3 col = vec3(.25);\n    \n    \n    // Just a simple lined pattern.\n    float pat3 = clamp(sin((oP.x - oP.y)*6.283*iResolution.y/24.)*1. + .9, 0., 1.)*.25 + .75;\n    // Resolution based falloff... Insert \"too may different devices these days\" rant here. :D\n    float fo = 5./iResolution.y;\n    \n    \n    // Tile colors. \n    vec3 pCol2 = vec3(.125);    \n    vec3 pCol1 = vec3(1);\n    \n    //The spectrum color option overides the pink option.\n    #if COLOR ==  1\n    pCol1 = vec3(.7, 1.4, .4);//Spectrum.\n    #elif COLOR ==  2\n    // Pink version.\n    pCol1 = mix(vec3(1, .1, .2), vec3(1, .1, .5), uv.y*.5 + .5);;\n    pCol2 = vec3(.1, .02, .06); \n    #endif\n    \n    \n    \n    \n\t#ifdef STACKED_TILES\n        // I provided this as an option becaue I thought it might be useful\n        // to see the tile layering process.\n\n        float pw = .02;\n        d -= pw/2.;\n        d2 -= pw/2.;\n    \n        // Render each two-colored tile, switching colors on alternating iterations.\n    \tfor (int k=0; k<3; k++){\n\n            col = mix(col, vec3(0), (1. - smoothstep(0., fo*5., d2[k]))*.35);\n            col = mix(col, vec3(0), 1. - smoothstep(0., fo, d2[k]));\n            col = mix(col, pCol2, 1. - smoothstep(0., fo, d2[k] + pw));  \n\n            col = mix(col, vec3(0), (1. - smoothstep(0., fo*5., d[k]))*.35);\n            col = mix(col, vec3(0), 1. - smoothstep(0., fo, d[k]));\n            col = mix(col, pCol1, 1. - smoothstep(0., fo, d[k] + pw));\n            \n            vec3 temp = pCol1; pCol1 = pCol2; pCol2 = temp;\n        }\n\n        col *= pat3;\n    \n    #else\n   \n        // Combining the tile layers into a continuous surface. I'd like to say that\n        // I applied years of topological knowledge to arrive at this, but like most\n        // things, I threw a bunch of formulas at the screen in frustration until I \n        // fluked the solution. :D There was a bit of logic applied though. :)\n        d.x = max(d2.x, -d.x);\n        d.x = min(max(d.x, -d2.y), d.y);\n        d.x = max(min(d.x, d2.z), -d.z);\n\n        // A couple of distance field patterns and a shade.\n        float pat = clamp(-sin(d.x*6.283*20.) - .0, 0., 1.);\n        float pat2 = clamp(sin(d.x*6.283*16.)*1. + .9, 0., 1.)*.3 + .7;\n        float sh = clamp(.75 + d.x*2., 0., 1.);\n\n        #if COLOR == 1\n\n            col *= pat;\n\n    \t\t// Render the combined shape.\n            d.x = -(d.x + .03);\n\n            col = mix(col, vec3(0), (1. - smoothstep(0., fo*5., d.x)));\n            col = mix(col, vec3(0), 1. - smoothstep(0., fo, d.x));\n            col = mix(col, vec3(.8, 1.2, .6), 1. - smoothstep(0., fo*2., d.x + .02));\n            col = mix(col, vec3(0), 1. - smoothstep(0., fo*2., d.x + .03));\n            col = mix(col, vec3(.7, 1.4, .4)*pat2, 1. - smoothstep(0., fo*2., d.x + .05));\n\n            col *= sh; \n\n        #else\n\n            //d.x -= .01;\n            col = pCol1;\n\n    \t\t// Render the combined shape.\n            col = mix(col, vec3(0), (1. - smoothstep(0., fo*5., d.x))*.35);\n            col = mix(col, vec3(0), 1. - smoothstep(0., fo, d.x));\n            col = mix(col, pCol2, 1. - smoothstep(0., fo, d.x + .02));\n\n\n            col *= pat3; // Line decroation.\n        #endif\n\n\t#endif\n    \n  \n \n    // Mild spotlight.\n    col *= max(1.15 - length(uv)*.5, 0.);\n    \n    \n    // Click the left mouse button to show the underlying quadtree grid structure. It's\n    // helpful to see the cell borders to see the random tile constructions.\n    if(iMouse.z>0.){\n        \n        \n        vec3 vCol1 = vec3(.8, 1, .7);\n        vec3 vCol2 = vec3(1, .7, .4);\n        \n        #if COLOR == 2\n        vCol1 = vCol1.zxy;\n        vCol2 = vCol2.zyx;\n        #endif\n        \n        // Grid lines.\n        vec3 bg = col;\n        col = mix(col, vec3(0), (1. - smoothstep(0., .02, grid.x - .02))*.7);\n        col = mix(col, vCol1 + bg/2., 1. - smoothstep(0., .01, grid.x));\n\n        // Circles on the grid vertices.\n        fo = 10./iResolution.y/sqrt(grid.w);\n        col = mix(col, vec3(0), (1. - smoothstep(0., fo*3., grid.y - .02))*.5);\n    \tcol = mix(col, vec3(0), 1. - smoothstep(0., fo, grid.y - .02));\n        col = mix(col, vCol2, 1. - smoothstep(0., fo, grid.y));\n        col = mix(col, vec3(0), 1. - smoothstep(0., fo, grid.z - .02/sqrt(grid.w)));\n    }\n    \n    \n    // Mix the colors, if the spectrum option is chosen.\n    #if COLOR == 1\n    col = mix(col, col.yxz, uv.y*.75 + .5); //.zxy\n    col = mix(col, col.zxy, uv.x*.7 + .5); //.zxy\n    #endif\n    \n\n    // Rough gamma correction, and output to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3BW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[4102, 4124, 4145, 4494, 4768], [4770, 4803, 4823, 4823, 4881], [5130, 5130, 5184, 5217, 17738]], "test": "valid"}
{"id": "4t3Bz7", "name": "deep-sea-life", "author": "teraspora", "description": "A bunch of sine waves dancing under the sea.   Click in th right half  for more symmetry. Watch for 2 minutes at least!    Full-screen! :)", "tags": ["slow", "flowing"], "likes": 0, "viewed": 191, "published": "Public", "date": "1538964905", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653588\n//#define f fragCoord.xy\n// Some useful colours:\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 crimson =      vec3(1.,   0.,   0.4  );\nconst vec3 yellow =      vec3(1.,   1.,   0.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 orange = vec3(1.0, 0.4, 0.);\nconst vec3 cyan = vec3(0., 0.4, 1.0);\nconst vec3 magenta = vec3(1.0, 0., 1.0);\nconst vec3 gold = vec3(1.0, 0.84, 0.66);\n\nvec3[] cols = vec3[](white, crimson, yellow, magenta, gold, cyan, orange);\nvec3 col;\n\n// My inline library of useful functions:\n// =======================================\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\nfloat om(float x) {\n\treturn 1. - x;\n}\n\nvec3 om(vec3 v) {\n\treturn 1. - v;\n}\n\nfloat op(float x) {\n\treturn 1. + x;\n}\n\nfloat nsin(float x) {\n\treturn op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n\treturn op(cos(x)) * 0.5;\n}\n\nfloat sqrtp(float x) {\n\treturn sqrt(x < 0. ? -x : x); \n}\n\nfloat nmmod(float x, float y) {\n\tfloat xmn = 2. * mod(x, y) / y;\n    return xmn < 1. ? xmn : om(xmn);\n}\n\nvec3 omss(float mn, float mx, vec3 val) {\n\treturn om(smoothstep(mn, mx, val));\n}\n\nvec2 nmouse() {\n\treturn iMouse.xy / iResolution.xy;\n}\n\nvec3 invert(vec3 col) {\n \treturn 1. - clamp(col, 0., 1.);   \n}\n\nbool isOdd(float p) {\n    return fract(p * 0.5) >= 0.5;\n}\n\n// =======================================\n\n\n\nfloat scale = 0.4;\n\nfloat f(float x) {\n\treturn sin(cos(0.2 * iTime * x)) + cos(2. * sin(0.23 * iTime * x)) - sqrt(0.2 *abs(x) * cos(0.02 * iTime * x));\n}\n\nvec3 drawBorder(vec3 col, float b, vec3 insetColour, vec2 pp, vec2 hr, float tileIndex) {\n    // `b` is the border width\n    // `col` is the input (and output) colour\n    // `pp` is (unnormalised) coordinate of pixel\n    // `hr` is (unnormalised) resolution\n    // Make a border: `b` px solid black; with `insetColour` inset:\n    if (tileIndex != -1.) {\n    \t//  any special code for single-pane use goes here    \n    }\n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = insetColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = insetColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = iTime;\n    float asp = iResolution.x/iResolution.y;\n    // Normalized pixel coordinates (y from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.y - vec2(0.5 * asp, 0.5)) / scale;\n\tuv = rotate(uv, PI * 0.5);\n    \n    uv.y = abs(uv.y);\n    if (nmouse().x >= 0.5) uv.x = abs(uv.x);\n    float c = mod(t, 128.) - 104.;\n    if (c > 0.) uv = rotate(uv, c * PI / 12.);\n    float a = 5.;\n    float b = 8.;\n    uv.x += 0.1 * cos(a * uv.y + b * uv.x);\n    col = crimson;\n    \n\n    \n    float d = 1.0;\n    col *= step(uv.y, f(uv.x)) - step(uv.y + d, f(uv.x));\n    if (col != black && mod(length(uv), 0.1) > 0.05) {\n        col = invert(col);\n        col.g *= nsin(t / 6.);\n    }\n    col.r *= nsin(iTime * 0.015625);    \n        \n    if (col == black) {\n        col = 0.2 * nsin(iTime * 0.03125) * sin(iTime * 0.425 + length(uv) + vec3(0.,2.,4.));\n    \t}\n    \n    // Border code:    \n    // ============    \n    float borderWidth = 6.;\n    vec3 borderInsetLineColour = white;\n \tcol = drawBorder(col, borderWidth, borderInsetLineColour, fragCoord, iResolution.xy, -1.);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3Bz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[604, 604, 623, 623, 652], [654, 654, 686, 686, 733], [735, 735, 763, 763, 828], [830, 830, 862, 862, 903], [905, 905, 924, 924, 942], [944, 944, 961, 961, 979], [981, 981, 1000, 1000, 1018], [1020, 1020, 1041, 1041, 1069], [1071, 1071, 1092, 1092, 1120], [1122, 1122, 1144, 1144, 1178], [1180, 1180, 1211, 1211, 1283], [1285, 1285, 1326, 1326, 1365], [1367, 1367, 1382, 1382, 1420], [1422, 1422, 1445, 1445, 1484], [1486, 1486, 1507, 1507, 1543], [1611, 1611, 1629, 1629, 1744], [1746, 1746, 1835, 2071, 2608], [2610, 2610, 2667, 2667, 3796]], "test": "error"}
{"id": "4t3fD4", "name": "Voronoi Diagrams", "author": "victorpapa98", "description": "Supervision 1", "tags": ["voronoi"], "likes": 3, "viewed": 143, "published": "Public", "date": "1539705572", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 3d view, illumination and view to world matrix from \n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n\nconst int MAX_MARCHING_STEPS = 10000;\nconst float MIN_DIST = 0.001;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst int NUMBER_OF_POINTS = 12;\n\nconst vec3[NUMBER_OF_POINTS] color = vec3[](vec3(1.0, 1.0, 1.0), vec3(0.1, 0.4, 0.1),\n                                          vec3(0.0, 1.0, 0.0), vec3(0.0, 1.0, 1.0),\n                                          vec3(1.0, 0.0, 0.0), vec3(1.0, 0.0, 1.0),\n                                          vec3(1.0, 1.0, 0.0), vec3(1.0, 1.0, 1.0),\n                                          vec3(0.0, 0.5, 0.5), vec3(0.4, 0.4, 0.0),\n                                          vec3(0.0, 0.0, 0.9), vec3(0.0, 0.5, 0.9));\n\nconst vec2[NUMBER_OF_POINTS] points = vec2[](vec2(0.0, 10.0), vec2(2.0, 4.0),\n                                          vec2(7.0, -2.0), vec2(0.0, 0.0),\n                                          vec2(-3.0, 4.0), vec2(5.0, 2.0),\n                                          vec2(2.0,  7.0), vec2(6.0, -3.0),\n                                          vec2(4.0, 1.0), vec2(-5.0, -5.0),\n                                          vec2(6.0, 6.0), vec2(-6.0, -6.0));\n    \n\nfloat diffSDF(float a, float b){\n\treturn max(a, -b);\n}\n\nfloat unionSDF(float a, float b){\n \treturn min(a, b);   \n}\n\nfloat intersectSDF(float a, float b){\n\treturn max(a, b);   \n}\n\nfloat planeSDF(vec3 p, vec4 normal){\n    normal = normalize(normal);\n \treturn (dot(p, normal.xyz) + normal.w) / length(normal.xyz);   \n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) { \n\n    return planeSDF(samplePoint, vec4(0.0, 1.0, 0.0, 0.0));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        \n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec2 translateForRotate(vec3 p){\n    vec3 n = vec3(normalize(p.xz).x, p.y, normalize(p.xz).y);    \n    \n    return vec2(p.x - n.x, p.z - n.z);\n}\n\nvec3 rotateAroundY_cw(vec3 p){\n    \n    float c = cos(iTime);\n    float s = sin(iTime);\n    \n    return (mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    ) * vec4(p, 1.0)).xyz;\n}\n\nvec3 rotateAroundY_ccw(vec3 p){\n    \n    float c = cos(iTime);\n    float s = sin(iTime);\n    \n    return (mat4(\n        vec4(c, 0, -s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    ) * vec4(p, 1.0)).xyz;\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    \n    //determine the color of the pixel, depending on the nearest point\n    float dist = distance(p, rotateAroundY_ccw(vec3(points[0].x, 0.0, points[0].y)));\n    k_d = color[0];\n    for (int i=1; i<NUMBER_OF_POINTS; i++){\n        \n        float newDist = distance(p, (i % 2 == 0) ? \n                                 \trotateAroundY_ccw(vec3(points[i].x, 0.0, points[i].y))\n                                   :rotateAroundY_cw(vec3(points[i].x, 0.0, points[i].y)));\n        if (dist > newDist){\n            dist = newDist;\n            k_d = color[i];\n        }\n\t}\n    \n    if (dist < 0.2) // radius of a point\n        k_d = vec3(0.0);\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.6, 0.6, 0.6);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(1.0, 40.0, 0.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3fD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1266, 1266, 1298, 1298, 1320], [1322, 1322, 1355, 1355, 1380], [1382, 1382, 1419, 1419, 1443], [1445, 1445, 1481, 1481, 1581], [1584, 1824, 1858, 1858, 1922], [1924, 2345, 2436, 2436, 2751], [2766, 3020, 3085, 3085, 3217], [3219, 3308, 3337, 3337, 3647], [3649, 3649, 3681, 3681, 3793], [3795, 3795, 3825, 3825, 4038], [4040, 4040, 4071, 4071, 4284], [4286, 4778, 4918, 4918, 6150], [6152, 6522, 6607, 6607, 7407], [7409, 7736, 7785, 7820, 8046], [8048, 8048, 8105, 8105, 8949]], "test": "valid"}
{"id": "4t3fDj", "name": "healing particles", "author": "chulini", "description": "Additive tinted circles with blurred borders moving using simplex noise around the center.", "tags": ["circle", "random", "particles"], "likes": 4, "viewed": 130, "published": "Public", "date": "1541005013", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat circle(vec2 uv, vec2 p, float r, float blur){\n    float d = length(uv-p);\n    float c = smoothstep(r+blur,r,d);\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float c;\n    for(int i = 0; i < 20; i++){\n        c += circle(uv,vec2(\n            snoise(vec2(iTime*.2, rand(float(i)*123.512) )),\n            snoise(vec2(rand(float(i+7890123)),iTime*.2))\n        )*.2,(.8+.5*sin(iTime*3.0))*.05,.08);    \n    }\n    //c*=.5;\n    vec3 u_colorMult = vec3(.5,.5,1);\n    fragColor = vec4(vec3(c)*u_colorMult.rgb,c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3fDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 61], [63, 63, 84, 84, 904], [906, 906, 926, 926, 964], [966, 966, 1017, 1017, 1099], [1102, 1102, 1159, 1159, 1609]], "test": "valid"}
{"id": "4t3fRs", "name": "Vapour Infused", "author": "ShaderBombay", "description": "Distilled", "tags": ["gin"], "likes": 1, "viewed": 90, "published": "Public", "date": "1540568947", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.9 + 0.1*cos(iTime+uv.xyx+vec3(0,4,8));\n\n    // Output to screen\n    fragColor = vec4(col,iTime);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3fRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 296]], "test": "valid"}
{"id": "4tcBDn", "name": "Domain warping test", "author": "edo_m18", "description": "Fractal Brownian Motion test\n\nReference: https://thebookofshaders.com/13/\nSee also: http://www.iquilezles.org/www/articles/morenoise/morenoise.htm", "tags": ["fractal", "fbm", "domainwarping"], "likes": 15, "viewed": 476, "published": "Public", "date": "1539156204", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Fractal Brownian Motion\n *\n * Reference: https://thebookofshaders.com/13/\n * \n * See also: http://www.iquilezles.org/www/articles/morenoise/morenoise.htm\n */\n\n#define NUM_OCTAVES 5\n\nconst vec3 color = vec3(0, 0.745, 0.9);\n\n\n// Get random value\nfloat random(in vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// Get noise\nfloat noise(in vec2 st)\n{\n    // Splited integer and float values.\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float a = random(i + vec2(0.0, 0.0));\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    \n    // -2.0f^3 + 3.0f^2\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// fractional brown motion\n//\n// Reduce amplitude multiplied by 0.5, and frequency multiplied by 2.\nfloat fbm(in vec2 st)\n{\n\tfloat v = 0.0;\n    float a = 0.5;\n    \n    for (int i = 0; i < NUM_OCTAVES; i++)\n    {\n    \tv += a * noise(st);\n        st = st * 2.0;\n        a *= 0.5;\n    }\n    \n    return v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate normalized UV values.\n    vec2 st = fragCoord / iResolution.xy;\n        \n    vec2 q = vec2(0.0);\n    q.x = fbm(st + vec2(0.0));\n    q.y = fbm(st + vec2(1.0));\n    \n    // These numbers(such as 1.7, 9.2, etc.) are not special meaning.\n    vec2 r = vec2(0.0);\n    r.x = fbm(st + (1.0 * q) + vec2(1.7, 9.2) + (0.15 * iTime));\n    r.y = fbm(st + (1.0 * q) + vec2(8.3, 2.8) + (0.12 * iTime));\n    \n    // Calculate 'r' is that getting domain warping.\n    float f = fbm(st + r);\n    \n    // f^3 + 0.6f^2 + 0.5f\n    float coef = (f * f * f + (0.6 * f * f) + (0.5 * f));\n    \n    fragColor = vec4(coef * color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tcBDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 251, 277, 277, 353], [355, 368, 393, 434, 808], [810, 910, 933, 933, 1114], [1117, 1117, 1174, 1213, 1802]], "test": "valid"}
{"id": "4tcBW4", "name": "CIE L*a*b* sRGB Gamut (spinning)", "author": "Tynach", "description": "Spinning sRGB gamut in the L*a*b* colorspace. Now with proper perspective.\n\nClick+drag to freely rotate. Click the furthest left pixels to animate it again.\n\nInspired in part by nmz's similar shader:\nhttps://www.shadertoy.com/view/XddGRN", "tags": ["color", "rgb", "lab", "spinning", "cielab", "srgb", "cie"], "likes": 4, "viewed": 457, "published": "Public", "date": "1539662297", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/******************************************************************************\n * Scroll to just above the functions to change the parameters used to draw   *\n * the diagram                                                                *\n ******************************************************************************/\n\nprecision highp float;\nprecision highp int;\n\n#define PI 3.1415926535897932384626433832795\n#define EULER 2.7182818284590452353602874713527\n\n\n/*\n * Structures\n */\n\n// Parameters for transfer characteristics (gamma curves)\nstruct transfer {\n\t// Exponent used to linearize the signal\n\tfloat power;\n\n\t// Offset from 0.0 for the exponential curve\n\tfloat off;\n\n\t// Slope of linear segment near 0\n\tfloat slope;\n\n\t// Values below this are divided by slope during linearization\n\tfloat cutoffToLinear;\n\n\t// Values below this are multiplied by slope during gamma correction\n\tfloat cutoffToGamma;\n};\n\n// Parameters for a colorspace\nstruct rgb_space {\n\t// Chromaticity coordinates (xyz) for Red, Green, and Blue primaries\n\tmat3 primaries;\n\n\t// Chromaticity coordinates (xyz) for white point\n\tvec3 white;\n\n\t// Linearization and gamma correction parameters\n\ttransfer trc;\n};\n\n\n/*\n * Preprocessor 'functions' that help build colorspaces as constants\n */\n\n// Turns 6 chromaticity coordinates into a 3x3 matrix\n#define Primaries(r1, r2, g1, g2, b1, b2)\\\n\tmat3(\\\n\t\tr1, r2, 1.0 - r1 - r2,\\\n\t\tg1, g2, 1.0 - g1 - g2,\\\n\t\tb1, b2, 1.0 - b1 - b2)\n\n// Creates a whitepoint's xyz chromaticity coordinates from the given xy coordinates\n#define white(x, y)\\\n\tvec3(x, y, (1.0 - x - y))\n\n#define Bright(w)\\\n\t((w)/w.y)\n\n// Creates a scaling matrix using a vec3 to set the xyz scalars\n#define diag(v)\\\n\tmat3(\\\n\t\t(v).x, 0.0, 0.0,\\\n\t\t0.0, (v).y, 0.0,\\\n\t\t0.0, 0.0, (v).z)\n\n// Creates a conversion matrix that turns RGB colors into XYZ colors\n#define rgbToXyz(space)\\\n\tspace.primaries*diag((inverse(space.primaries)*Bright(space.white)))\n\n// Creates a conversion matrix that turns XYZ colors into RGB colors\n#define xyzToRgb(space)\\\n\tinverse(rgbToXyz(space))\n\n// Creates a conversion matrix converts linear RGB colors from one colorspace to another\n#define conversionMatrix(f, t)\\\n\txyzToRgb(t)*rgbToXyz(f)\n\n\nconst mat3 CIECAM02 = mat3(\n\t0.7328, -0.7036, 0.003,\n\t0.4296, 1.6975, 0.0136,\n\t-0.1624, 0.0061, 0.9834\n);\n\nconst mat3 HUNT = mat3(\n\t0.38971, -0.22981, 0,\n\t0.68898, 1.1834, 0,\n\t-0.07868, 0.04641, 1\n);\n\nconst mat3 CIECAM97_1 = mat3(\n\t0.8951, -0.7502, 0.0389,\n\t0.2664, 1.7135, -0.0685,\n\t-0.1614, 0.0367, 1.0296\n);\n\nconst mat3 CIECAM97_2 = mat3(\n\t0.8562, -0.836, 0.0357,\n\t0.3372, 1.8327, -0.0469,\n\t-0.1934, 0.0033, 1.0112\n);\n\n// Converts from L*a*b* to nonlinear XYZ; calling\n// toLinear() afterward completes the conversion\nconst mat3 frLab = mat3(\n\t1, 0, 0,\n\t1, 1, 1,\n\t0, 0, 1\n)*mat3(\n\t1.16/500.0, 0, 0,\n\t0, 1.0/100.0, 0,\n\t0, 0, -1.16/200.0\n);\n\n\n/*\n * Chromaticities for RGB primaries\n */\n\n// Identity RGB\nconst mat3 primariesIdentity = mat3(1.0);\n\n// CIE 1931 RGB\nconst mat3 primariesCie = Primaries(\n\t0.72329, 0.27671,\n\t0.28557, 0.71045,\n\t0.15235, 0.02\n);\n\n// Original 1953 NTSC primaries\nconst mat3 primariesNtsc = Primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.14, 0.08\n);\n\n// Never-popular and antiquated 'HDTV' primaries based mostly on 1953 NTSC\nconst mat3 primaries240m = Primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.15, 0.06\n);\n\n// European Broadcasting Union primaries for SDTV and Rec. 601 (625 lines)\nconst mat3 primariesEbu = Primaries(\n\t0.64, 0.33,\n\t0.29, 0.6,\n\t0.15, 0.06\n);\n\n// P22 Phosphor primaries (allegedly; only found one source)\n// Used by older versions of SMPTE-C, before specific chromaticities were given\nconst mat3 primariesP22 = Primaries(\n\t0.61, 0.342,\n\t0.298, 0.588,\n\t0.151, 0.064\n);\n\n// Modern day SMPTE-C primaries, used in modern NTSC and Rec. 601 (525 lines)\nconst mat3 primariesSmpteC = Primaries(\n\t0.63, 0.34,\n\t0.31, 0.595,\n\t0.155, 0.07\n);\n\n// Alleged primaries for old Sony TVs with a very blue whitepoint\nconst mat3 primariesSony = Primaries(\n\t0.625, 0.34,\n\t0.28, 0.595,\n\t0.155, 0.07\n);\n\n// Rec. 709 (HDTV) and sRGB primaries\nconst mat3 primaries709 = Primaries(\n\t0.64, 0.33,\n\t0.3, 0.6,\n\t0.15, 0.06\n);\n\n// Rec. 709 (HDTV) and sRGB primaries\nconst mat3 primariesAdobe = Primaries(\n\t0.64, 0.33,\n\t0.21, 0.71,\n\t0.15, 0.06\n);\n\n// DCI-P3 primaries\nconst mat3 primariesDciP3 = Primaries(\n\t0.68, 0.32,\n\t0.265, 0.69,\n\t0.15, 0.06\n);\n\n// Rec. 2020 UHDTV primaries\nconst mat3 primaries2020 = Primaries(\n\t0.708, 0.292,\n\t0.17, 0.797,\n\t0.131, 0.046\n);\n\n// If the HUNT XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesHunt = Primaries(\n\t0.8374, 0.1626,\n\t2.3, -1.3,\n\t0.168, 0.0\n);\n\n// If the CIECAM97_1 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam971 = Primaries(\n\t0.7, 0.306,\n\t-0.357, 1.26,\n\t0.136, 0.042\n);\n\n// If the CIECAM97_2 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam972 = Primaries(\n\t0.693, 0.316,\n\t-0.56, 1.472,\n\t0.15, 0.067\n);\n\n// If the CIECAM02 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam02 = Primaries(\n\t0.711, 0.295,\n\t-1.476, 2.506,\n\t0.144, 0.057\n);\n\n// LMS primaries as chromaticity coordinates, computed from\n// http://www.cvrl.org/ciepr8dp.htm, and\n// http://www.cvrl.org/database/text/cienewxyz/cie2012xyz2.htm\n/*const mat3 primariesLms = Primaries(\n\t0.73840145, 0.26159855,\n\t1.32671635, -0.32671635,\n\t0.15861916, 0.0\n);*/\n\n// Same as above, but in fractional form\nconst mat3 primariesLms = Primaries(\n\t194735469.0/263725741.0, 68990272.0/263725741.0,\n\t141445123.0/106612934.0, -34832189.0/106612934.0,\n\t36476327.0/229961670.0, 0.0\n);\n\n\n/*\n * Chromaticities for white points\n */\n\n// Standard Illuminant C. White point for the original 1953 NTSC color system\nconst vec3 whiteC = white(0.310063, 0.316158);\n\n// Standard illuminant E (also known as the 'equal energy' white point)\nconst vec3 whiteE = vec3(1.0);\n\n// Alleged whitepoint to use with the P22 phosphors (D65 might be more proper)\nconst vec3 whiteP22 = white(0.313, 0.329);\n\n// Standard illuminant D65. Note that there are more digits here than specified\n// in either sRGB or Rec 709, so in some cases results may differ from other\n// software. Color temperature is roughly 6504 K (originally 6500K, but complex\n// science stuff made them realize that was innaccurate)\nconst vec3 whiteD65 = white(0.312713, 0.329016);\n\n// Standard illuminant D65 according to sRGB, Rec. 709, and other display standards\nconst vec3 whiteD65S = white(0.3127, 0.3290);\n\n// Standard illuminant D50. Just included for the sake of including it. Content\n// for Rec. 709 and sRGB is recommended to be produced using a D50 whitepoint.\n// For the same reason as D65, the color temperature is 5003 K instead of 5000 K\nconst vec3 whiteD50 = white(0.34567, 0.35850);\n\n// Standard illuminant D50 according to ICC standards (they specify a hex value\n// for the 16-bit integer representation, as well as a specific way to decode it,\n// so I did some math to figure out exactly the values they expect)\n//const vec3 whiteD50I = white(31595.0/91393.0, 32768.0/91393.0);\n\n// Floating point representation of ICC D50\nconst vec3 whiteD50I = white(3214.0/9297.0, 10000.0/27891.0);\n\n// White point for DCI-P3 Theater\nconst vec3 whiteTheater = white(0.314, 0.351);\n\n// Very blue white point for old Sony televisions. Color temperature of 9300 K.\n// Use with the 'primariesSony' RGB primaries defined above\nconst vec3 whiteSony = white(0.283, 0.298);\n\n\n/*\n * Gamma curve parameters\n */\n\n// Linear gamma\nconst transfer gam10 = transfer(1.0, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.2; not linear near 0. Was defined abstractly to be used by early\n// NTSC systems, before SMPTE 170M was modified to specify a more exact curve\nconst transfer gam22 = transfer(2.2, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.4; not linear near 0. Seems a popular choice among some people\n// online, so I included it. I don't think any standard uses this\nconst transfer gam24 = transfer(2.4, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.5; not linear near 0. Approximately what old Sony TVs used\nconst transfer gam25 = transfer(2.5, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.8; not linear near 0. Loosely defined gamma for European SDTV\nconst transfer gam28 = transfer(2.8, 0.0, 1.0, 0.0, 0.0);\n\n// Modern SMPTE 170M, as well as Rec. 601, Rec. 709, and a rough approximation\n// for Rec. 2020 content as well. Do not use with Rec. 2020 if you work with\n// high bit depths!\nconst transfer gam170m = transfer(1.0/0.45, 0.099, 4.5, 0.0812, 0.018);\n\n// Gamma for sRGB. This is the only difference between sRGB and Rec. 709\nconst transfer gamSrgb = transfer(2.4, 0.055, 12.92, 0.04045, 0.0031308);\n\n// Gamma for the CIE L*a*b* Lightness scale\nconst transfer gamLab = transfer(3.0, 0.16, 243.89/27.0, 0.08, 216.0/24389.0);\n\n\n/*\n * RGB Colorspaces\n */\n\n// CIE 1931 RGB\nconst rgb_space Cie1931 = rgb_space(primariesCie, whiteE, gam10);\n\n// Identity RGB\nconst rgb_space Identity = rgb_space(primariesIdentity, whiteE, gam10);\n\n// Original 1953 NTSC\nconst rgb_space Ntsc = rgb_space(primariesNtsc, whiteC, gam22);\n\n// Mostly unused and early HDTV standard (SMPTE 240M)\nconst rgb_space Smpte240m = rgb_space(primaries240m, whiteD65S, gam22);\n\n// European Broadcasting Union SDTV\nconst rgb_space Ebu = rgb_space(primariesEbu, whiteD65S, gam28);\n\n// Original, imprecise colorspace for NTSC after 1987 (probably incorrect)\nconst rgb_space SmpteC = rgb_space(primariesP22, whiteD65S, gam22);\n\n// Modern SMPTE \"C\" colorimetry\nconst rgb_space Smpte170m = rgb_space(primariesSmpteC, whiteD65S, gam170m);\n\n// Old Sony displays using high temperature white point\nconst rgb_space Sony = rgb_space(primariesSony, whiteSony, gam25);\n\n// Rec. 709 (HDTV)\nconst rgb_space Rec709 = rgb_space(primaries709, whiteD65S, gam170m);\n\n// sRGB (mostly the same as Rec. 709, but different gamma)\nconst rgb_space Srgb = rgb_space(primaries709, whiteD65S, gamSrgb);\n\n// Adobe RGB monitors\nconst rgb_space AdobeRgb = rgb_space(primariesAdobe, whiteD65S, gam22);\n\n// DCI-P3 D65\nconst rgb_space DciP3D65 = rgb_space(primariesDciP3, whiteD65S, gam170m);\n\n// DCI-P3 D65\nconst rgb_space DciP3Theater = rgb_space(primariesDciP3, whiteTheater, gam170m);\n\n// Rec. 2020\nconst rgb_space Rec2020 = rgb_space(primaries2020, whiteD65S, gam170m);\n\n// Hunt primaries, balanced against equal energy white point\nconst rgb_space HuntRgb = rgb_space(primariesHunt, whiteE, gam10);\n\n// CIE CAM 1997 primaries v1, balanced against equal energy white point\nconst rgb_space Ciecam971Rgb = rgb_space(primariesCiecam971, whiteE, gam10);\n\n// CIE CAM 1997 primaries v2, balanced against equal energy white point\nconst rgb_space Ciecam972Rgb = rgb_space(primariesCiecam972, whiteE, gam10);\n\n// CIE CAM 2002 primaries, balanced against equal energy white point\nconst rgb_space Ciecam02Rgb = rgb_space(primariesCiecam02, whiteE, gam10);\n\n// Lms primaries, balanced against equal energy white point\nconst rgb_space LmsRgb = rgb_space(primariesLms, whiteE, gam10);\n\n\n/**********************************************************\n *                                                        *\n *  Change these to adjust various conversion parameters  *\n *                                                        *\n **********************************************************/\n\n// Display colorspace\nconst rgb_space disp = rgb_space(primaries709, whiteD65S, gamSrgb);\n\n// Color Appearance Model (or 'reference') white point\nconst vec3 whiteCam = whiteD50I;\n\n// camMat is an easy way to set the transformation matrix, but both\n// toCam and frCam are what should be used, as they're adapted to the\n// color appearance model white point\nconst mat3 camMat = CIECAM97_1;\nconst mat3 toCam = inverse(diag(camMat*Bright(whiteCam)))*camMat;\nconst mat3 frCam = inverse(camMat)*diag(camMat*Bright(whiteCam));\n\n// Modify XYZ↔RGB matrices to perform whitepoint adaptation using a\n// wrong Von Kries transformation matrix (CIECAM97_1 has nonlinearities\n// in the 'S' cone that is not accounted for in ICC profiles)\nconst mat3 toRgb = xyzToRgb(disp)*frCam*diag((toCam*Bright(disp.white))/(toCam*Bright(whiteCam)))*toCam;\nconst mat3 toXyz = frCam*diag((toCam*Bright(whiteCam))/(toCam*Bright(disp.white)))*toCam*rgbToXyz(disp);\n\n// This might be easier to understand (← shows matrix multiplication):\n// toRgb = XYZtoRGB←LMStoXYZ←diag(whiteDispInLMS/whiteCamInLMS)←XYZtoLMS\n// toXyz = LMStoXYZ←diag(whiteCamInLMS/whiteDispInLMS)←XYZtoLMS←RGBtoXYZ\n\n\n/*\n * Conversion Functions\n */\n\n// Converts display RGB colors to a linear light scale\nvec4 toLinear(vec4 color, const transfer trc)\n{\n\tbvec4 cutoff = lessThan(color, vec4(trc.cutoffToLinear));\n\tvec4 higher = pow((color + trc.off)/(1.0 + trc.off), vec4(trc.power));\n\tvec4 lower = color/trc.slope;\n\n\tcolor = mix(higher, lower, cutoff);\n\n\treturn color;\n}\n\n// Gamma-corrects RGB colors to be sent to a display\nvec4 toGamma(vec4 color, const transfer trc)\n{\n\tbvec4 cutoff = lessThan(color, vec4(trc.cutoffToGamma));\n\tvec4 higher = (1.0 + trc.off)*pow(color, vec4(1.0/trc.power)) - trc.off;\n\tvec4 lower = color*trc.slope;\n\n\tcolor = mix(higher, lower, cutoff);\n\n\treturn color;\n}\n\n// Turns colors that are out-of-gamut transparent\nvec4 gamutTrim(vec4 color, float luma)\n{\n\tfloat low = min(color.r, min(color.g, min(color.b, 0.0)));\n\tfloat high = max(color.r, max(color.g, max(color.b, 1.0)));\n\n\tcolor.a = float(int(low == 0.0 && high == 1.0));\n\n\treturn color;\n}\n\n// Converts from XYZ to RGB, with white point adaptation\nvec4 convert(vec4 color)\n{\n\tfloat luma = color.y;\n\n\t// Convert from XYZ to RGB, then remove out-of-gamut colors\n\tcolor.rgb = toRgb*color.xyz;\n\tcolor = gamutTrim(color, luma);\n\n\treturn color;\n}\n\n\n// Perspective parameters\n// Chosen so that RGB #FF00FF barely touches the boundaries while spinning\n#define FAR (4.73513408)\n#define NEAR (3.26486592)\n#define FOV (2.0*atan(0.5))\n//#define RIGHT (1.25)\n//#define TOP (1.25)\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat minRes = min(iResolution.x, iResolution.y);\n\tvec2 ab = (fragCoord - iResolution.xy/2.0)/minRes;\n\n\t// Color chosen to match the background of this image:\n\t// https://en.wikipedia.org/wiki/File:Lab_color_space.png\n\tfragColor = toLinear(vec4(vec3(104.0/255.0), 1), disp.trc);\n\n\tvec4 color;\n\tvec2 angle;\n\n\tif (iMouse.z == 0.0) {\n\t\tangle = vec2(0, iTime*PI*2.0/5.0);\n\t} else {\n\t\tangle = vec2(-1, 1)*(iMouse.yx - (iResolution.yx - minRes)/2.0)/minRes*PI*2.0 - PI;\n\t}\n\n\tvec2 sinAng = sin(angle);\n\tvec2 cosAng = cos(angle);\n\n\tmat4 movement = mat4( // Swap .y and .z\n\t\t1, 0, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 0, 1\n\t)*inverse(mat4( // View matrix\n\t\t1.0/tan(FOV/2.0), 0, 0, 0,\n\t\t0, 1.0/tan(FOV/2.0), 0, 0,\n\t\t0, 0, -FAR/(FAR - NEAR), -1,\n\t\t0, 0, -FAR*NEAR/(FAR - NEAR), 0\n\t)*mat4( // World matrix\n\t\t1, 0, 0, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, -4, 1\n\t)*mat4( // Model matrix\n\t\t1, 0, 0, 0,\n\t\t0, cosAng.x, sinAng.x, 0,\n\t\t0, -sinAng.x, cosAng.x, 0,\n\t\t0, 0, 0, 1\n\t)*mat4(\n\t\tcosAng.y, 0, -sinAng.y, 0,\n\t\t0, 1, 0, 0,\n\t\tsinAng.y, 0, cosAng.y, 0,\n\t\t0, 0, 0, 1\n\t)*mat4(\n\t\t1.0/128.0, 0, 0, 0,\n\t\t0, 1.0/128.0, 0, 0,\n\t\t0, 0, 1.0/128.0, 0,\n\t\t0, 0, 0, 1\n\t)*mat4(\n\t\t1, 0, 0, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, -50, 1\n\t));\n\n\t// Steps is set to 120, but since white and black are\n\t// infinitely small, only perform steps 1 to 119\n\tconst float steps = 120.0 - 1.0;\n\n\t// Steps are counted backwards, because we're going from\n\t// further away to closer to the camera; the last sample\n\t// to give us a color is what we want to show\n\n\t// We could instead quit early, but in anaother shader\n\t// I'm working on I have 2 gamuts semi-transparent and\n\t// overlapping, so they can be compared\n\tfor (float i = steps; i > 0.0; --i) {\n\t\tcolor = vec4(ab, i/steps, 1);\n\n\t\tcolor = movement*color;\n\t\tcolor /= color.w;\n\t\tcolor.a = 1.0;\n\n\t\t// Convert to XYZ\n\t\tcolor.xyz = frLab*color.rgb;\n\t\tcolor = toLinear(color, gamLab);\n\t\tcolor.xyz *= Bright(whiteCam);\n\n\t\t// Convert to RGB\n\t\tcolor = convert(color);\n\t\tfragColor.rgb = mix(fragColor.rgb, color.rgb, color.a);\n\t}\n\n\tfragColor = toGamma(fragColor, disp.trc);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tcBW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[12564, 12619, 12666, 12666, 12884], [12886, 12939, 12985, 12985, 13204], [13206, 13256, 13296, 13296, 13486], [13488, 13545, 13571, 13571, 13737], [13966, 13966, 14021, 14021, 16105]], "test": "error"}
{"id": "4tcfR7", "name": "Nature.3 Genetics Merging", "author": "tqle", "description": "Nature projects, experiment #3. Attempt to recreate Spiderman's genetics", "tags": ["nature"], "likes": 1, "viewed": 92, "published": "Public", "date": "1538961647", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//define functions, as to not be redundant\n#define repeat(v, r) (mod(v, r)-r/2.)\n//constructors, similar to that of a class in Java\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n//parametize vec2 -> randomize float\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n//rotating distance of objects\nmat2 rot(float a){\n  float r = sin(a);\n  float f = cos(a);\n  return mat2(sin(r), cos(f), sin(-f), cos(r));\n}\n\n//* Shapes *//\nfloat pole(vec2 v, float r){\n  return length(v)-r;\n}\nfloat sphere(vec3 v, float r){\n  return length(v)-r;\n}\nfloat box(vec3 v, float r, float m) {\n  return max(length(v.xy) - r, abs(v.z) - m);\n}\n\n//* Mixers *//\n\nfloat mixColors(float r, float v, float z) {\n  return clamp(.75 + 0.5 * (v - r) / z, .1, 1.);\n}\n\nfloat mixShapes(float v, float f, float r) {\n  float z = mixColors(v, f, r);\n  return mix(f, v, z) - r * z *(1. - z);\n}\n\n//parametize vec2 -> polar coordinates \nfloat pModPolar(inout vec2 v, float r) {\n  float f = 6.28318 / r;\n  float z = atan(v.y, v.x) + f * 0.5;\n  float m = floor(z / f);\n  z = mod(z, f) - f * 0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n//* Shaping functions *//\nShape vines(vec3 c) {\n  Shape shape;\n  float vine;\n  shape.dist = 2000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n\n  // Shape Attributes\n  float twist = 19.75; // Vine Repeat\n  float vineOffset = 2.75; // Leaf Offset\n\n\n\tvineOffset += cos(iTime*0.5)*1.;\n\n  // Stems\n  vec3 i = c;\n    i.xz *= rot(c.y*0.35+iTime*0.25);\n    float detail = pModPolar(i.xz, twist); \n    \n    float x = mix(-2., 1., mod(detail, 10.));// Small Ripples\n    //float x = mix(0., 1., pModPolar(i.xy, 10.)); \n    \n    \n    i.x -= vineOffset; // Offset Stems\n  \tfloat stemWidth = 0.25;\n  \tvine = pole(i.xz, stemWidth+0.02*sin(i.y*x));\n\n\n  vec4 color = vec4(0.1, 0.75, 0.4, 1. + cos(iTime));\n    \n    float pattern = cos(sin(c.z*10.)) /\n        cos(sin(c.y*2.));\n\n  shape.dist = vine;\n  shape.color = color;\n  shape.color /= pattern;\n\n  return shape;\n}\n\n\nShape orb(vec3 c){\n  Shape shape;\n  float orb;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n\n  // Stems\n  vec3 i = c;\n    i.xz *= rot(iTime);\n    i.y = repeat(i.y, 0.5);\n    i.x = abs(i.x)-0.5;\n    i.x = abs(i.x)-0.5;\n    orb = sphere(i, cos(sin(iTime)*1.25)*0.25);\n    \n\n  vec4 color = vec4(3.1 + cos(iTime), 0.75 - abs(tan(iTime)), 0.4, 1. - abs(pow(cos(iTime), 2.)));\n\n  shape.dist = orb;\n  shape.color = color;\n\n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape vines = vines(c);\n  Shape orbs = orb(c);\n    \n  float df = mixShapes(vines.dist, orbs.dist, 1.);\n  vines.dist = df;\n    \n  vines.color = mix(vines.color, \n                    orbs.color*2., \n                    mixColors(orbs.dist, vines.dist, 1.));\n\n  return vines;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  //remapping coordinate system -.5 -> .5\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  //setting camera positioning\n  vec3 cam = vec3(0., 0., -10.);\n  //normalizing coordinate vector \n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(.25);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.05){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.01){\n      fragColor = c.color * (1. - z) + cos(iTime); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tcfR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 214, 236, 236, 303], [304, 335, 353, 353, 443], [445, 460, 488, 488, 512], [513, 513, 543, 543, 567], [568, 568, 605, 605, 653], [671, 671, 715, 715, 766], [768, 768, 812, 812, 887], [889, 929, 969, 969, 1137], [1138, 1164, 1185, 1185, 2004], [2007, 2007, 2025, 2025, 2477], [2480, 2480, 2498, 2498, 2775], [2777, 2777, 2834, 2876, 3369]], "test": "valid"}
{"id": "4tcfW7", "name": "reciprocal zoom moire", "author": "khlorghaal", "description": " ", "tags": ["zoom", "function", "numerical", "alias"], "likes": 4, "viewed": 257, "published": "Public", "date": "1539779676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv= uv*2.-1.;\n    float l= cos(uv.x*uv.y*exp(5.+mod(iTime*1.,25.)));\n    l= l*.5+.5;\n    vec3 col = vec3(pow(l,2.2));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tcfW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 252]], "test": "valid"}
{"id": "4tdBDn", "name": "VR Gasket", "author": "shau", "description": "Apollonian gasket and fractal from GUIL in VR", "tags": ["fractals", "apollonian", "vr"], "likes": 22, "viewed": 903, "published": "Public API", "date": "1539377757", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by SHAU - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n/*\nBased on Apollonian II by IQ and Apollonian structure by Shane\nTurbulance fractal based on Marble by Guil\n*/\n\n#define FAR 20.\n#define EPS 0.001\n#define T iTime * 1.\n#define R iResolution.xy\n#define SD .46\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//IQ cosine palattes\n//http://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 PT(float t) {return vec3(.5) + vec3(.5) * cos(6.28318 * (vec3(1) * t * 0.1 + vec3(0, .33, .67)));}\n\nvec3 tile(vec3 p) {\n    return abs(mod(p, 2.) - 1.); // - vec3(1.);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;    \n}\n\nvec2 nearest(vec2 a, vec2 b){ \n    return mix(a, b, step(b.x, a.x));\n}\n\nvec3 map(vec3 p) {\n    \n    float scale = 1.;\n\n    vec3 q = p;\n    for (int i = 0; i < 8; i++) {\n        q = mod(q - 1., 2.) - 1.;\n        q -= sign(q) * (0.05 + sin(T * 0.14) * 0.02);\n        float k = (1.1 + sin(T * 0.1) * -0.1) / dot(q, q);\n        q *= k;\n        scale *= k;\n    }\n\n    float t = (.25 * length(q) / scale);\n    \n    p = tile(p);\n    float b = sdSphere(p - vec3(1), SD);\n    \n    return vec3(nearest(vec2(t, 1.), vec2(b, 2.)), b);\n}\n\n//tetrahedral normal\nvec3 normal(vec3 p) {  \n    vec2 e = vec2(-1., 1.) * EPS;   \n\treturn normalize(e.yxx * map(p + e.yxx).x + e.xxy * map(p + e.xxy).x + \n\t\t\t\t\t e.xyx * map(p + e.xyx).x + e.yyy * map(p + e.yyy).x);   \n}\n\n//IQ - http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\nfloat AO(vec3 p, vec3 n) {\n    float ra = 0., w = 1., d = 0.;\n    for (float i = 1.; i < 5.; i += 1.){\n        d = i / 5.;\n        ra += w * (d - map(p + n * d).x);\n        w *= .5;\n    }\n    return 1. - clamp(ra, 0., 1.);\n}\n\n//fractal from GUIL\n//https://www.shadertoy.com/view/MtX3Ws\nvec2 csqr(vec2 a) {return vec2(a.x * a.x - a.y * a.y, 2.0 * a.x * a.y);}\n\nfloat fractal(vec3 p) {\n\t\n\tfloat res = 0.0;\n\tfloat x = .7;\n    \n    p = tile(p);\n    p.yz *= rot(T * .6);\n    \n    vec3 c = p;\n\t\n    for (int i = 0; i < 10; ++i) {\n        p = x * abs(p) / dot(p, p) - x;\n        p.yz = csqr(p.yz);\n        p = p.zxy;\n        res += exp(-19. * abs(dot(p, c)));   \n\t}\n    return res / 2.;\n}\n\nfloat fractalMarch(vec3 ro, vec3 rd) {\n    \n    float c = 0., t = EPS;\n    \n    for (int i = 0; i < 50; i++) {\n        \n        vec3 p = ro + t * rd;\n        \n        vec3 q = tile(p);\n        float b = sdSphere(q - vec3(1), SD);\n        if (b > EPS) break;\n        \n        float bc = sdSphere(q - vec3(1), .01);\n        bc = 1. / (1. + bc * bc * 20.);\n        \n        float fs = fractal(p); \n        t += 0.02 * exp(-2.0 * fs);\n        \n        c += 0.04 * bc;\n    } \n    \n    return c;\n}\nvec3 render(vec3 ro, vec3 rd) {\n    \n    float mint = FAR;\n    \n    vec3 pc = vec3(0), bg = pc, gc = PT(T), p = pc;\n    vec3 ld = normalize(vec3(3., 4., -1.));\n    \n    //ray marching\n    float t = 0., id = 0.;\n    for (int i = 0; i < 96; i++) {\n        p = ro + rd * t;\n        vec3 ns = map(p);\n        if (ns.x < EPS || t > FAR) {\n            id = ns.y;\n            break;\n        }\n        \n        float lt = 1. / (1. + ns.z * ns.z * 140.);\n        bg += gc * lt * 0.03;\n        \n        t += ns.x;\n    }\n    \n    //*\n    if (id > 0.) {\n        \n        mint = t;\n        \n        vec3 n = normal(p);\n        float ao = AO(p, n);\n        float dif = max(dot(ld, n), 0.05);\n        float spc = pow(max(dot(reflect(-ld, n), -rd), 0.), 32.);\n        float frs = pow(clamp(dot(n, rd) + 1., 0., 1.), 2.);\n        \n        if (id == 1.) {\n            \n            //apollonian\n            pc = vec3(0.1) * dif;\n            pc += vec3(0.1, 0.2, 0.4) * max(n.y, 0.);\n            pc += gc * 0.6 * spc;\n        }\n        \n        if (id == 2.) {\n            \n            //ball\n            pc = gc * dif * 0.4;   \n            pc += gc * fractalMarch(p, rd) * (1. - frs) * .6;\n            pc += vec3(1) * spc; \n            frs = pow(clamp(dot(n, rd) + 1., 0., 1.), 2.) * 64.; \n            pc += gc * frs * 0.04 * dif; \n        }        \n        \n        pc *= ao;\n    }\n    //*/\n    \n    pc += bg;\n    pc *= exp(-0.2 * mint);\n    \n    return pc * 1.6;\n}\n\nvoid camera(vec2 U, inout vec3 ro, inout vec3 rd, inout vec3 la) {\n    \n    vec2 uv = (U - R * .5) / R.y;\n    \n    ro = la - vec3(0, sin(T * 0.2) * 0.3, -3.0); \n    ro.xz *= rot(T * 0.1);\n    \n    vec3 fwd = normalize(la - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n\n    rd = normalize(fwd + 1.4 * uv.x * rgt + 1.4 * uv.y * cross(fwd, rgt));\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n\n    vec3 ro, rd, la = vec3(-1, 1, -2);\n    camera(U, ro, rd, la);\n    \n    vec3 pc = render(ro, rd);\n    \n    C = vec4(pc,1.0);\n}\n\nvoid mainVR(out vec4 C, vec2 U, vec3 fro, vec3 frd) {    \n    \n    vec3 ro = fro + vec3(1, 1, T * -0.2); //camera\n    vec3 pc = render(ro, frd);\n\tC = vec4(pc, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdBDn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[379, 379, 398, 398, 444], [446, 530, 548, 548, 633], [635, 635, 654, 654, 704], [706, 706, 739, 739, 771], [773, 773, 802, 802, 843], [845, 845, 863, 863, 1297], [1299, 1320, 1341, 1341, 1518], [1520, 1598, 1624, 1624, 1822], [1824, 1884, 1903, 1903, 1956], [1958, 1958, 1981, 1981, 2279], [2281, 2281, 2319, 2319, 2772], [2773, 2773, 2804, 2804, 4220], [4222, 4222, 4288, 4288, 4579], [4581, 4581, 4617, 4617, 4748], [4750, 4750, 4803, 4803, 4915]], "test": "valid"}
{"id": "4tdBRs", "name": "Fog Texture Shader", "author": "Nihilistic_Furry", "description": "Shades the image with a subtle fog effect. This is intended to be multiplied with a texture.", "tags": ["fog", "visualeffect", "texturemultiplier"], "likes": 3, "viewed": 419, "published": "Public API", "date": "1540658971", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Time varying pixel depth\n    vec3 depth = 0.5 + 0.2 * cos(iTime + uv.xyx * 5.0 + vec3 (0, 2, 4));\n    \n    //Create 2D fog effect\n    vec3 col = vec3 (depth.r, depth.r, depth.r) * vec3 (depth.g, depth.g, depth.g) + vec3 (depth.b, depth.b, depth.b);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdBRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 111, 474]], "test": "valid"}
{"id": "4tdBRX", "name": "LSD Triangle", "author": "Vizalkar", "description": "Don't do drugs, make shaders instead", "tags": ["triangle"], "likes": 20, "viewed": 564, "published": "Public", "date": "1540464852", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define TWO_PI 6.28318530718\n#define PI 3.14159265\n#define palette(t) pal(t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) )\n\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    \n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n                 43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n        (c - a)* u.y * (1.0 - u.x) +\n        (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nmat2 rot(in float theta)\n{\n    return mat2(cos(theta),-sin(theta), sin(theta), cos(theta));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = vec2(0.5) - uv;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    float rotime = iTime*0.2;\n    \n    float theta = atan(uv.y,uv.x);\n    \n    float radius = sdEquilateralTriangle(uv*rot(PI)*3. + vec2(0,.2));\n    \n    vec2 fuv = uv*rot(rotime);\n    vec2 fbm1 = vec2(fbm(fuv), fbm(fuv + iTime*0.1 + 0.2));\n    vec2 fbm2 = vec2(fbm(fuv + fbm1.x + 0.120*iTime), fbm(uv + fbm1.y - 0.220*iTime) );\n    \n    float thmod = (theta+fbm2.x*fbm2.y*1.0/(radius))/PI + 1.;\n    \n    \n    \n    vec3 fbmColor = palette(thmod +iTime*0.2 + fbm2.y) * (fbm2.x*fbm2.x*fbm2.x*fbm2.x +0.7);\n    fbmColor = mix(fbmColor, vec3(1.,1.,1.), fbm(uv*iTime*0.001)+0.4)*0.9;\n\n    fbmColor = mix(fbmColor, vec3(0.9,0.15,0.25)*0.3, pow(radius,.5)-0.4);\n\n    vec3 col = smoothstep(0.,1.,radius*35.) * fbmColor;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdBRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 230, 272, 272, 499], [501, 501, 529, 529, 646], [648, 726, 753, 753, 1127], [1152, 1152, 1178, 1178, 1516], [1518, 1518, 1586, 1586, 1629], [1631, 1631, 1657, 1657, 1724], [1726, 1726, 1783, 1833, 2715]], "test": "valid"}
{"id": "4tdBzM", "name": "floating cushion", "author": "teraspora", "description": "?", "tags": ["water"], "likes": 1, "viewed": 102, "published": "Public", "date": "1539053916", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// floating cushion - a fragment shader in GLSL, built on shadertoy.com;\n// Author: John Lynch (@teraspora);\n// Based on voronoi-2\n// Date: 9 OCT 2018.\n\n// Copyright © 2018 John Lynch\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n// -----------------------------------------------------------------------------\n\n#define PI 3.141592653588\n\n// Some useful colours:\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 crimson =      vec3(1.,   0.,   0.4  );\nconst vec3 yellow =      vec3(1.,   1.,   0.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 orange = vec3(1.0, 0.4, 0.);\nconst vec3 cyan = vec3(0., 0.4, 1.0);\nconst vec3 magenta = vec3(1.0, 0., 1.0);\nconst vec3 gold = vec3(1.0, 0.84, 0.66);\n\nvec3[] cols = vec3[](white, crimson, yellow, magenta, gold, cyan, orange);\nvec3 col;\n\n// ==================================================================\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n// - not tested!\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from HSL to linear RGB\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\n// My inline library of useful functions:\n// =======================================\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\nfloat om(float x) {\n\treturn 1. - x;\n}\n\nvec3 om(vec3 v) {\n\treturn 1. - v;\n}\n\nfloat op(float x) {\n\treturn 1. + x;\n}\n\nfloat nsin(float x) {\n\treturn op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n\treturn op(cos(x)) * 0.5;\n}\n\nfloat sqrtp(float x) {\n\treturn sqrt(x < 0. ? -x : x); \n}\n\nfloat nmmod(float x, float y) {\n\tfloat xmn = 2. * mod(x, y) / y;\n    return xmn < 1. ? xmn : om(xmn);\n}\n\nvec3 omss(float mn, float mx, vec3 val) {\n\treturn om(smoothstep(mn, mx, val));\n}\n\nvec2 nmouse() {\n\treturn iMouse.xy / iResolution.xy;\n}\n\nvec3 invert(vec3 col) {\n \treturn 1. - clamp(col, 0., 1.);   \n}\n\nbool isOdd(float p) {\n    return fract(p * 0.5) >= 0.5;\n}\n\nfloat minkd(vec2 u, vec2 v, float order) {\t// Minkowski distance order 1\n    if (order <= 0.) return 0.;\t\t\t\t// i.e. Manhattan distance\n\treturn abs(pow(abs(pow(v.x - u.x, order)) + abs(pow(v.y - u.y, order)), 1. / order)); \n}\n\n\n// =======================================\n\n// rand generator from \n// https://www.youtube.com/watch?v=l-07BXzNdPw&t=740s\nvec2 r22(vec2 p) {\n\tvec3 a = fract(p.xyx * vec3(923.34, 234.34, 345.65));\n\ta += dot(a, a - 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\n\nfloat f(float x) {\n\treturn sin(cos(0.2 * iTime * x)) + cos(2. * sin(0.23 * iTime * x)) - sqrt(0.2 *abs(x) * cos(0.02 * iTime * x));\n}\n\nvec3 drawBorder(vec3 col, float b, vec3 insetColour, vec2 pp, vec2 hr, float tileIndex) {\n    // `b` is the border width\n    // `col` is the input (and output) colour\n    // `pp` is (unnormalised) coordinate of pixel\n    // `hr` is (unnormalised) resolution\n    // Make a border: `b` px solid black; with `insetColour` inset:\n    if (tileIndex != -1.) {\n    \t//  any special code for single-pane use goes here    \n    }\n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = insetColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = insetColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));\n    return col;\n    \n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = iTime / 24.;\n    float numPoints = 1.;\n    t = 1. - t;\n    \n    float scale =  1. / numPoints;\n    \n    if (t < 24.) scale += 0.1 * sin(t);\n    \n\tfloat asp = iResolution.x/iResolution.y;\n    // Normalized pixel coordinates (y from -1 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / (iResolution.y * scale);\n\t\t\n    //uv.y = abs(uv.y);\n    //if (nmouse().x >= 0.5) \n    uv = abs(uv);\n    \n    vec2 friz = vec2(100. * sin(t * uv.x), 100. * cos(t * uv.y));\n    vec2 vel = vec2(1., 10.);\n    \n    uv *= vec2(om(sin(friz.x * cos(vel.x * t) * uv.x) / 7.), om(cos(friz.y * sin(vel.y * t) * uv.y) / 11.)); \n    \n    // col = crimson;\n    \n    float m = 0.;\n    float mind = 100.;\n    float ci;\n    \n    // generate a bunch of random points\n    for (float i = 0.; i < numPoints; i++) {\n    \tvec2 n = r22(vec2(i));\n        // sin of both components varied with time\n        vec2 p = sin(n * t);\n        // get distance to point\n        float d = minkd(uv, p, 1.);\n        //m += smoothstep(.05, .01, d);\n        if (d < mind) {\n        \tmind = d;\n            ci = i;\n        }\n    }\n    \n    col = invert(vec3(mind));\n    col.g -= nsin(t + length(uv));\n    col.b += 0.5 * smoothstep(0., 1., col.r + col.b);\n    \n    if (rgb2hcv(col).z < 0.01) col = 0.5 + 0.5*cos(4. * t+uv.xyx+vec3(27,49,81));\n    \n    \n    fragColor = vec4(col.bgr, 1.);\n}\n\n//col = vec3(m, nsin(length(uv)), ncos(t));\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdBzM.jpg", "access": "shaders20k", "license": "mit", "functions": [[2039, 2039, 2064, 2064, 2222], [2224, 2288, 2312, 2365, 2648], [2650, 2685, 2709, 2709, 2829], [2831, 2866, 2890, 2890, 3042], [3130, 3130, 3149, 3149, 3178], [3180, 3180, 3212, 3212, 3259], [3261, 3261, 3289, 3289, 3354], [3356, 3356, 3388, 3388, 3429], [3431, 3431, 3450, 3450, 3468], [3470, 3470, 3487, 3487, 3505], [3507, 3507, 3526, 3526, 3544], [3546, 3546, 3567, 3567, 3595], [3597, 3597, 3618, 3618, 3646], [3648, 3648, 3670, 3670, 3704], [3706, 3706, 3737, 3737, 3809], [3811, 3811, 3852, 3852, 3891], [3893, 3893, 3908, 3908, 3946], [3948, 3948, 3971, 3971, 4010], [4012, 4012, 4033, 4033, 4069], [4071, 4071, 4113, 4143, 4295], [4342, 4420, 4438, 4438, 4566], [4569, 4569, 4587, 4587, 4702], [4704, 4704, 4793, 5029, 5575], [5577, 5577, 5634, 5634, 6986]], "test": "error"}
{"id": "4tdBzn", "name": "Day & Night", "author": "Shadeyboi", "description": "Sun & Moon Rotations (Nature project 3/3)", "tags": ["natureproject"], "likes": 1, "viewed": 85, "published": "Public", "date": "1538526510", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.2, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\n\nfloat pole(vec2 v, float r){\n  return length(v)-r;\n}\n/*float sphere(vec3 v, float r){\n  return length(v)-r;\n}\nfloat box(vec3 v, float r, float m) {\n  return max(length(v.xy)-r, abs(v.z)-m);\n}\n*/\n\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.2;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n//=======================\n\nShape vines(vec3 c){\n  Shape shape;\n  float vine;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n\n  // Shape Attributes\n  float twist = 20.; // Ray Repeat\n  float vineOffset = 7.; // Ray Offset\n\n\n  // Stems\n  vec3 i = c;\n    //i.x += repeat(i.x, 10.);\n    i.yz *= rot(c.y*.1-1.);\n    i.xz *= rot(c.y*0.1+iTime*.3);\n    float detail = pModPolar(i.yz, twist); //Different coordinates affect the pattern\n    float x = mix(0., 1., mod(detail, 3.)); // Small Ripples\n    i.x -= vineOffset; // Offset Rays, inverts sun & moon\n  \tfloat stemWidth = 0.25;\n  \tvine = pole(i.xz, stemWidth+0.02*sin(i.y*x));\n\n\n  vec4 color = vec4(sin(iTime*.3)+.2, sin(iTime*.3 + .1)-0.2, -sin(iTime*.3), 1.);\n    \n  shape.dist = vine;\n  shape.color = color;\n\n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape vines = vines(c);\n  return vines;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(0., sin(iTime*.3)*1.5, -8.);\n  vec3 f = normalize(vec3(v, 1.1));\n  vec3 scene = cam;\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.01){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdBzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 164, 186, 186, 253], [255, 255, 273, 273, 343], [346, 346, 374, 374, 398], [543, 543, 586, 586, 629], [631, 631, 674, 674, 740], [742, 742, 781, 781, 937], [965, 965, 985, 985, 1748], [1751, 1751, 1769, 1769, 1813], [1815, 1815, 1872, 1872, 2299]], "test": "valid"}
{"id": "4tdfDH", "name": "point lights", "author": "GraphicsFromScratch", "description": "point lights", "tags": ["light"], "likes": 3, "viewed": 289, "published": "Public", "date": "1539474415", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct point_light\n{\n    vec3 p;\n    vec3 i;\n};\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nfloat sdf(in vec3 p, out int matid)\n{\n    vec2 c = vec2(4.5);\n\tp.xz = mod(p.xz, c) - 0.5 * c;\n    \n    float sphere_sdf = length(p - vec3(0, 1, 0)) - 1.0;\n    float box_sdf = sdBox(p - vec3(0, 1, 0), vec3(0.8));\n    float obj_sdf = max(-sphere_sdf, box_sdf);\n    float floor_sdf = abs(p.y);\n    \n    float sdf = min(obj_sdf, floor_sdf);\n    if (sdf == obj_sdf)\n    {\n        matid = 1;\n    }\n    else\n    {\n        matid = 0;\n    }\n    \n    return sdf;\n}\n\nvec3 sdf_n(in vec3 p)\n{\n    vec3 res = vec3(0);\n    \n    int ignored;\n    res.x = sdf(p + vec3(0.001, 0, 0), ignored) - sdf(p, ignored);\n    res.y = sdf(p + vec3(0, 0.001, 0), ignored) - sdf(p, ignored);\n    res.z = sdf(p + vec3(0, 0, 0.001), ignored) - sdf(p, ignored);\n    \n    return normalize(res);\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, out int matid)\n{\n\tfloat t = 0.0;\n    matid = -1;\n    for (int i = 0; i < 256; ++i)\n    {\n        int curr_matid = -1;\n\t\tfloat d = sdf(ro + t*rd, curr_matid);\n        if (d < 0.0001)\n        {\n            matid = curr_matid;\n            break;\n        }\n        t += d;\n    }\n    return t;\n}\n\nfloat dir_shadow(in vec3 p, in vec3 l)\n{\n    float t = 0.15;\n    float t_max = 20.0;\n    \n    float res = 1.0;\n    for (int i = 0; i < 256; ++i)\n    {\n        if (t > t_max) break;\n        \n        int ignored;\n        float d = sdf(p + t*l, ignored);\n        if (d < 0.01)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 8.0 * d / t);\n    }\n    \n    return res;\n}\n\nfloat point_shadow(in vec3 p, in vec3 light_p)\n{\n    vec3 l = normalize(light_p - p);\n        \n    float t = 0.15;\n    float t_max = distance(light_p, p);\n    \n    float res = 1.0;\n    for (int i = 0; i < 256; ++i)\n    {\n        if (t > t_max) break;\n        \n        int ignored;\n        float d = sdf(p + t*l, ignored);\n        if (d < 0.01)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 64.0 * d / t);\n    }\n    \n    return res;\n}\n\nfloat ao(in vec3 p, in vec3 n)\n{\n    float e = 0.1;\n    float res = 0.0;\n    \n#define AO_ITER 5\n    \n    int ignored;\n    float weight = 0.5;\n    for (int i = 1; i <= AO_ITER; ++i)\n    {\n        float d = e * float(i);\n        res += weight * (1.0 - (d - sdf(p + d * n, ignored)));\n        weight *= 0.5;\n    }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float cam_d = 3.0;\n    float time = 0.3 * iTime;\n    vec3 ro = vec3(cam_d*sin(time), 2.5, cam_d*cos(time));\n    vec3 at = vec3(0, 1, 0);\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0,1,0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 1.73 * cam_z);\n\t\n    vec3 col = vec3(0);\n    \n    int matid = -1;\n    float t = intersect(ro, rd, matid);\n    if (matid != -1)\n    { \n        vec3 p = ro + t*rd;\n        vec3 n = sdf_n(p);\n        \n#define PLIGHT_COUNT 5 \n        point_light plights[PLIGHT_COUNT];\n        plights[0] = point_light(vec3(3.0*sin(2.0*iTime), 1, 1.0+cos(iTime)), vec3(1, 0, 0));\n        plights[1] = point_light(vec3(3.0*sin(0.5*iTime), 1.0, 3.0*cos(iTime+10.0)), vec3(0, 1, 1));\n        plights[2] = point_light(vec3(6.0*cos(1.5*iTime+2.0), 1.0, 3.0*sin(0.2*iTime-4.0)), vec3(1, 1, 0));\n        plights[3] = point_light(vec3(3.0*cos(0.2*iTime-1.0), 1.0, 4.0*sin(0.5*iTime)), vec3(1, 0.2, 0.5));\n        plights[4] = point_light(vec3(cos(iTime), 1.0, sin(iTime)), vec3(1, 0.4, 1));\n        \n        vec3 direct_light = vec3(0);\n        for (int plight_index = 0; plight_index < PLIGHT_COUNT; ++plight_index)\n        {\n            vec3 light_i = plights[plight_index].i;\n            vec3 light_p = plights[plight_index].p;\n        \tfloat light_r = dot(light_p - p, light_p - p);\n        \tvec3 l = normalize(light_p - p);\n        \n        \tdirect_light += point_shadow(p, light_p) * max(0.0, dot(n, l)) * light_i / (light_r * light_r);\n        }\n\n        vec3 indirect_light = ao(p, n) * vec3(0.3);\n        \n        vec3 albedo = vec3(0.9);      \n\t\tcol = albedo * (0.7 * direct_light + indirect_light);\n        \n        col = mix(col, vec3(0), clamp(pow(t / 30.0, 2.0), 0.0, 1.0));\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdfDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 80, 80, 167], [169, 169, 204, 204, 249], [251, 251, 288, 288, 705], [707, 707, 730, 730, 1011], [1013, 1013, 1069, 1069, 1343], [1345, 1345, 1385, 1385, 1744], [1746, 1746, 1794, 1794, 2216], [2218, 2218, 2250, 2250, 2551], [2553, 2553, 2610, 2610, 4539]], "test": "valid"}
{"id": "4tdfDM", "name": "__sphere__", "author": "monada", "description": " ", "tags": [], "likes": 0, "viewed": 60, "published": "Public", "date": "1539865317", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphere2( vec2 p, float radius )\n{\n    return max( 0.0, radius - length( p ) );\n}\n\n#define mod3_      vec3(.1031, .11369, .13787)\n\nvec3 hash3(vec3 p3) {\n  p3 = fract(p3 * mod3_);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return -1. + 2. * fract(vec3((p3.x + p3.y) * p3.z, (p3.x+p3.z) * p3.y, (p3.y+p3.z) * p3.x));\n}\n\nfloat perlin_noise3(vec3 p) {\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3. - 2. * pf);\n    \n    return   mix(\n      mix(\n            mix(\n                dot(pf - vec3(0, 0, 0), hash3(pi + vec3(0, 0, 0))), \n                dot(pf - vec3(1, 0, 0), hash3(pi + vec3(1, 0, 0))),\n                w.x),\n            mix(\n                dot(pf - vec3(0, 0, 1), hash3(pi + vec3(0, 0, 1))), \n                dot(pf - vec3(1, 0, 1), hash3(pi + vec3(1, 0, 1))),\n                w.x),\n      w.z),\n        mix(\n            mix(\n                dot(pf - vec3(0, 1, 0), hash3(pi + vec3(0, 1, 0))), \n                dot(pf - vec3(1, 1, 0), hash3(pi + vec3(1, 1, 0))),\n                w.x),\n            mix(\n                dot(pf - vec3(0, 1, 1), hash3(pi + vec3(0, 1, 1))), \n                dot(pf - vec3(1, 1, 1), hash3(pi + vec3(1, 1, 1))),\n                w.x),\n       w.z),\n  w.y);\n}\n\nfloat noise_sum_abs3(vec3 p) {\n    float f = 0.;\n    p = p * 3.;\n    f += 1.0000 * abs(perlin_noise3(p)); p = 2. * p;\n    f += 0.5000 * abs(perlin_noise3(p)); p = 3. * p;\n  f += 0.2500 * abs(perlin_noise3(p)); p = 4. * p;\n  f += 0.1250 * abs(perlin_noise3(p)); p = 5. * p;\n  f += 0.0625 * abs(perlin_noise3(p)); p = 6. * p;\n    \n    return f;\n}\n\nvec3 ligtning( vec2 fragCoord, vec2 uv )\n{\n    vec3 p3 = vec3(\n        fragCoord.xy/iResolution.x,\n        iTime*0.04\n    );\n    \n    float noise = noise_sum_abs3(vec3(p3*12.0+12.0));\n\n    float t = clamp((uv.x * -uv.x * 0.16) + 0.15, 0.0, 1.);\n    float l = uv.y; //mix( abs( uv.y ), 0.05, abs( uv.x ) );\n  //  l =  ( smoothstep( -0.7, 0.0, uv.x ) * (\n  //        1.0 - smoothstep( 0.0, 0.7, uv.x ) ) ) * abs( uv.y );\n    \n    float r = 0.6;\n     l = sphere2( uv, r );\n    \n\n    float i = pow( abs( noise * -t  + l ), 0.3 );\n                          \n    vec3 col = vec3(1.8, 1.60, 1.8);\n    \n    col = col * -i + col;                    \n  //  col = col * col;\n    col = col * col;\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n   \n    float pulsSpeed = 2.0;\n    float r = 1.0;\n    \n    float val = pow( sphere2( uv, 1.0 ) * 1.4, 2.2 );\n    \n    val = val + val * abs( sin( pow( length( uv ), 0.04 ) * 10.0 - iTime*pulsSpeed ) );\n   \n    vec3 color = vec3( 0.6, 1.3, 1.5 );\n    \n\n    fragColor.xyz = color * val;\n    fragColor.xyz *= ligtning( fragCoord, uv );\n    fragColor.xyz += color * val;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdfDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 86], [136, 136, 157, 157, 317], [319, 319, 348, 348, 1224], [1226, 1226, 1256, 1256, 1570], [1572, 1572, 1614, 1614, 2279], [2282, 2282, 2339, 2339, 2821]], "test": "valid"}
{"id": "4tdfDN", "name": "It's a Bloody Shader Innit", "author": "milolouis", "description": "soft shaders", "tags": ["shader"], "likes": 0, "viewed": 372, "published": "Public API", "date": "1539700019", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const bool lines = true;\n    int scale = 3;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2(fragCoord.x/(iResolution.x / 3.0), fragCoord.y/(iResolution.y / 2.0));\n    \n    float speed = 32.0; //divisor\n    \n    // Time varying pixel color    \n    float r = 20.0 + 64.0*cos(sin(iTime/(speed * 2.0))+uv.x) + 64.0*sin(cos(iTime/(speed / 2.0))+uv.y);\n    float g = 40.0 + 50.0*sin(sin(iTime/(speed))+uv.x) + 50.0*cos(cos(iTime/(speed))+uv.y);\n    float b = 60.0 + 64.0*sin(sin(iTime/(speed / 2.0))+uv.x) + 64.0*sin(cos(iTime/(speed * 2.0))+uv.y);\n    \n    \n    if(lines) {\n        \n    if(int(r) % scale == 0)\n    {\n        r = 0.0;\n    }\n    \n    if(int(g) % scale == 0)\n    {\n        g = 0.0;\n    }\n    \n    if(int(b) % scale == 0)\n    {\n        b = 0.0;\n    }\n        \n    }\n    \n    vec3 col = vec3(r/255.0, g/255.0, b/255.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdfDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 967]], "test": "valid"}
{"id": "4tdfRN", "name": "Nature Project-Tree", "author": "cake7914", "description": "A gnarled tree that opens and closes trunk + cool pulsing leaves ", "tags": ["trees"], "likes": 0, "viewed": 63, "published": "Public", "date": "1538838134", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define repeat(v, r) (mod(v, r)-r/2.) //easy repeat function\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) { //gets a \"random\" value\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){ // rotate function\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\n\nfloat pole(vec2 v, float r){ //draws a pole\n  return length(v)-r;\n}\nfloat sphere(vec3 v, float r){ //draws a sphere\n  return length(v)-r;\n}\nfloat box(vec3 v, float r, float m) { //draws a box\n  return max(length(v.xy)-r, abs(v.z)-m);\n}\n\n\n\nfloat mixColors(float r, float v, float z){ //mixes the color together\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){ // mixes the shapes together\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n//=======================\n\nShape vines(vec3 c){\n  Shape shape;\n  float vine;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n\n  // Shape Attributes\n  float twist = 20.; // Vine Repeat \n  float vineOffset = 4.; // Leaf Offset\n\n\n\t//vineOffset += cos(iTime*0.5)*1.;\n\n  // Stems\n  vec3 i = c;\n    i.zx *= rot(c.y*0.1+iTime*0.25);\n    i.x = abs(i.x)-5.; //mirrors it\n    i.x = abs(i.x)-5.; //mirrors it again\n    i.x = abs(i.x)-5.; //mirrors it again, gnarled tree look\n\n    float detail = pModPolar(i.xz, twist); \n    \n    float x = mix(-6., 7., mod(detail, 10.));//  Ripples\n    //float x = mix(0., 1., pModPolar(i.xy, 10.)); \n    \n    \n    i.x -= vineOffset; // Offset Stems\n  \tfloat stemWidth = 0.5;\n  \tvine = pole(i.xz, stemWidth+0.02*sin(i.y*x)); //makes vines\n\n\n  vec4 color = vec4(0.9, 0.5, 0.5, 1.); //trunk color\n    \n    float pattern = cos(sin(c.z*10.));//cos(sin(c.y*2.));\n\n  shape.dist = vine;\n  shape.color = color;\n  shape.color /= pattern; //adds in pattern\n\n  return shape;\n}\n\n\nShape orb(vec3 c){\n  Shape shape;\n  float orb;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n\n  // Stems\n  vec3 i = c;\n    //i.xy *= rot(iTime); //rotate around clockwise\n    //i.yz *= rot(iTime); //rotate into/out of screen\n    i.x = repeat(i.x, 10.); //repeat on the x axis 10 apart\n    i.y = repeat(i.y, 10.); // repeat on the y axis 10 apart\n    //i.x = abs(i.x)-0.5;\n    //i.x = abs(i.x)-0.5;\n    orb = sphere(i, sin(iTime*5.)+2.*1.5); // orb size, fluctuates \n    \n\n  vec4 color = vec4(.3, 0.8, 0.4, 1.); //orbs color\n\n  shape.dist = orb;\n  shape.color = color;\n\n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape vines = vines(c);\n  Shape orbs = orb(c);\n    \n  float df = mixShapes(vines.dist, orbs.dist, 1.);\n  vines.dist = df;\n    \n  vines.color = mix(vines.color, \n                    orbs.color*5., \n                    mixColors(orbs.dist, vines.dist, 1.)); //mix colors \n\n  return vines;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., -75.); //zoom out in the z\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(.1, .6, .9, 1.); // background color = sky\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.05){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.01){\n      fragColor = c.color*(.5-z); // Hit  - invert pixels, darker color shading\n      f += smoothstep(0., 0.1, length(v));\n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdfRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 187, 209, 233, 300], [302, 302, 320, 339, 409], [412, 412, 440, 455, 479], [480, 480, 510, 527, 551], [552, 552, 589, 603, 647], [651, 651, 694, 721, 764], [766, 766, 809, 838, 904], [906, 906, 945, 945, 1101], [1129, 1129, 1149, 1149, 2124], [2127, 2127, 2145, 2145, 2749], [2752, 2752, 2770, 2770, 3061], [3063, 3063, 3120, 3120, 3655]], "test": "valid"}
{"id": "4tdfRX", "name": "HypnoTriangle", "author": "Vizalkar", "description": "Quick graphics", "tags": ["triangle"], "likes": 3, "viewed": 139, "published": "Public", "date": "1540470155", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    \n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nmat2 rot(in float theta)\n{\n    return mat2(cos(theta),-sin(theta), sin(theta), cos(theta));\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n                 43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n        (c - a)* u.y * (1.0 - u.x) +\n        (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = vec2(0.5) - uv;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv.y -= 0.1;\n    \n    vec2 noisevec = vec2(\n        noise(uv+ iTime*0.5),\n        noise(uv*rot(0.5) + iTime*0.5+ 1.554));\n        \n    float triDist = sdEquilateralTriangle((noisevec*0.05+uv)*rot(PI));\n    vec3 col = vec3(smoothstep(0.,1.,sin(triDist*(200. + sin(iTime*0.2)*50.))));\n\tcol *= smoothstep(1.,0.,sdEquilateralTriangle((uv*2.)*rot(PI))*25.);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdfRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 126, 168, 168, 395], [397, 397, 423, 423, 490], [492, 492, 520, 520, 637], [639, 717, 744, 744, 1118], [1120, 1120, 1177, 1232, 1754]], "test": "valid"}
{"id": "4tdfzH", "name": "voronoigo", "author": "teraspora", "description": "A first, probably erroneous, attempt at a Voronoi diagram animation using Minkowski distance of variable order (seems prettiest and clearest for order 1 (Manhattan distance).\nUh-oh, I think my pseudo-random number generator is far too slow!", "tags": ["voronoi", "minkowski", "erroneous"], "likes": 2, "viewed": 98, "published": "Public", "date": "1538666343", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// voronoi-attempt - a fragment shader in GLSL, built on shadertoy.com;\n// Author: John Lynch (@teraspora);\n// Date: 04 OCT 2018.\n\n// Attempt to draw the borders of a Voronoi diagram and animate\n// them by varying various parameters with time.   I don't think it's\n// precisely correct; it looks reasonable at first, then some black \n// borders expand and take over.   Need to find the bug! \n\n// It runs pretty slow, probably because my Heath Robinson \n// pseudorandom number generator is needlessly complex and doesn't\n// even do the job properly!   Must research better algorithms\n// for randomness... noise function??   Can't use iTime as I need\n// the numbers to be consistent across frames.\n\n// -----------------------------------------------------------------------------\n\n// Copyright © 2018 John Lynch\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// -----------------------------------------------------------------------------\n\nconst float PI = 3.141592654;\nconst float TWO_PI = 6.283185307;\nconst float HALF_PI = 1.5707963267948966;\n\n// Some useful colours:\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 crimson =      vec3(1.,   0.,   0.3  );\nconst vec3 yellow =      vec3(1.,   1.,   0.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 orange = vec3(1.0, 0.4, 0.);\nconst vec3 cyan = vec3(0., 0.4, 1.0);\nconst vec3 magenta = vec3(1.0, 0., 1.0);\nconst vec3 gold = vec3(1.0, 0.84, 0.66);\n\nvec3[] cols = vec3[](white, crimson, yellow, magenta, gold, cyan, orange);\n\n// ==================================================================\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n// - not tested!\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// My inline library of useful functions:\n\n// =======================================\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\n// float dot(vec2 u, vec2 v) {\n// \treturn u.x * v.x + u.y * v.y;\n// }\n\nfloat om(float x) {\n\treturn 1. - x;\n}\n\nvec3 om(vec3 v) {\n\treturn 1. - v;\n}\n\nfloat op(float x) {\n\treturn 1. + x;\n}\n\nfloat nsin(float x) {\n\treturn op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n\treturn op(cos(x)) * 0.5;\n}\n\nfloat sqrtp(float x) {\n\treturn sqrt(x < 0. ? -x : x); \n}\n\nfloat nmmod(float x, float y) {\n\tfloat xmn = 2. * mod(x, y) / y;\n    return xmn < 1. ? xmn : om(xmn);\n}\n\nvec3 omss(float mn, float mx, vec3 val) {\n\treturn om(smoothstep(mn, mx, val));\n}\n\nvec2 nmouse() {\n\treturn iMouse.xy / iResolution.xy;\n}\n// =======================================\n\nvec3 drawBorder(vec3 col, float b, vec3 insetColour, vec2 pp, vec2 hr, float tileIndex) {\n    // `b` is the border width\n    // `col` is the input (and output) colour\n    // `pp` is (unnormalised) coordinate of pixel\n    // `hr` is (unnormalised) resolution\n    // Make a border: `b` px solid black; with `insetColour` inset:\n    if (tileIndex != -1.) {\n    \t//  any special code for single-pane use goes here    \n    }\n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = insetColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = insetColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));\n    return col;\n}\n\nvec2 psrandv2(float seed, int i) {\n    vec2 a;\n    a.x = cos(fract(cos(seed * 458333.003736561)) * (319.50207 + 10352.9911 * float(i)));\n\ta.y = sin(cos(fract(sin(seed * 4032.9908442016)) * (2786.2227 + 7046.88813 * float(i))));\n\ta.x *= fract(100000. * fract(dot(a, a.yx + vec2(26332.16598469, 7004.8112))));\n    a.y *= fract(1000. * fract(dot(rotate(a, float(i) * 69.4177), a.yx + vec2(91104.33554432, 8112.7004))));\n    return a * 0.5;\n}\n\nfloat minkd(vec2 u, vec2 v, float order) {\t// Minkowski distance; order = 1\n    if (order <= 0.) return 0.;\t\t\t\t// => Manhattan distance\n\treturn abs(pow(abs(pow(v.x - u.x, order)) + abs(pow(v.y - u.y, order)), 1. / order)); \n}\n\n\nfloat qtime() {\n\treturn mod(float(iTime), 4.) - 2.;\n}\n// MAIN METHOD:\n\nvec3 doStuff(vec2 pixel, vec2 res) {\n    // just takes a pixel and a context and outputs a\n    // colour to mainImage, which keeps things organised\n    // and encapsulated.\n    \n    \n    // Set this var to the number of tiles across and down:\n    float tileDim = 3.;\n    float numTiles = tileDim * tileDim;\n        \n    // the output vector, before normalisation,\n    // giving the position the program needs to know!-\n    vec2 pp = pixel;\n    vec2 hr = res / tileDim;\t// resolution of one tile\n    \n    // ===============================================================\n    \n    // Normalisation and tiling:\n    // ========================\n    \n    // Make numTiles sub-frames:\n    vec2 n = vec2(float(int(pixel.x / res.x * tileDim)), float(int(pixel.y / res.y * tileDim)));\n    \n    float tile = numTiles -(n.y * tileDim + n.x) - 1.; \n    // start at 1 so we don't lose stuff when multiplying\n    float toe = fract(tile / 2.) * 4. - 1.; // returns 1. if tile index odd, -1. if even;\n    float tile2 = tile * tile;\n    \n    // Offset the start of each rendition:\n    float time = tile * 32. + iTime;\n    // shift back to the first tile if in any other tile:\n    pp.x -= hr.x * n.x;\n    pp.y -= hr.y * n.y;\n    // normalise to [0, 1[, then shift to make unit quad with origin in centre\n    vec2 q = pp / hr - 0.5;     \n    // then scale:\n    float scaleFactor = 1.0;\n    // q /= scaleFactor;\n       \n    // ===============================================================================================\n    // ===============================================================================================\n    \n    // Main code for the shader goes here:\n    // ===============================================================================================\n    \n    // q *= 2.; \n    q = rotate(q, toe * (iTime * 0.02 * (numTiles - tile - 1.) + (tile - 1.) * 0.25 * PI));\t// vary angle for each tile\n    \n    float inc = 0.003;\n    vec2[4] k = vec2[](vec2(-1., -1.), vec2(-1., 1.), vec2(1., -1.), vec2(1., 1.));\n    \n    float order = 1.;\t// minkowski order (1 = Euclidean, 2 = Manhattan)\n    \n    vec3 col;\n    \n    //Initialise points[] array:\n    \n    // int numPoints = 6 + int(mod(iTime * 0.125, 128.));\n    int numPoints = 8 + int(128. * sin (iTime / 512.));\n    \n    vec2 points[140];\n    \n    float sa = 313.95920007897932 * (numTiles - tile);\n    float sb = 25.2649677703343 * tile;\n    float rseed = fract(cos(fract(sin(sa + cos(fract(sa) * sb)))));\n    \n    for (int i = 0; i < numPoints; i++) {\n    \tpoints[i] = psrandv2(rseed, i) + k[int(mod(float(i), 4.))] * inc * mod(iTime, 128.) * 2.8;\n        float hue = float(i) / float(numPoints - 1);\n        col = hue2rgb(hue);\n    }\n    \n    // My algorithm to draw the edges:\n    // Iterate through the points and find the two nearest to q.\n    // Give our point a hue determined by the i0, index of the \n    // closest point.\n    // Then if the differences in the distances of q to each of\n    // these two points is less than some small threshold value, \n    // it's roughly equidistant from the two nearest points, so \n    // make q black, as it's on the border.\n    \n    // Note: old code commented out and left ror reference and possible later re-use\n    \n    float mind0 = 1.;   // set min distances high\n    float mind1 = 1.;  // 2nd smallest distance\n    int i0 = 144;\n    int i1 = 144;\n    for (int i = 0; i < numPoints; i++) {   // find two closest points\n        \n        // TEST:\n        float k = 0.01;\n        q += k * sin(iTime / 20.);\n        \n        float d = minkd(q, points[i], 1.);\n        if (d <= mind0) {\t\t// new closest pt.\n            mind1 = mind0;\n            mind0 = d;\n            i1 = i0;\n            i0 = i;\n        }\n        else if (d <= mind1) {\t// new next-closest pt.\n            mind1 = d;\n            i1 = i;\n        }        \n    }\n    \n    // float hue = float(toe < 0. ? i0 : (numPoints - 1 - i0)) / float(numPoints - 1);\n    // float hueInv = 1. - hue;\n    // col = hue2rgb(toe > 0. ? hue : hueInv);\n    // col.g *= 0.8;\n    \n    col = vec3(abs(mod(float(i0), 3.) - 1.));\n    // col = vec3(mod(float(i0), 3.) / 2., mod(float(i0), 5.) / 4., mod(float(i0), 7.) / 6.);\n    col.g *=  sqrt(mind1);\n    //col.b *= distance(q, points[i0]);\n    col.b *= length(q) * nsin(iTime / 3.);\n    \n    //col *= smoothstep(0.01, 0.02, abs(minkd(q, points[i0], order) - minkd(q, points[i1], order)));\n    col = toe > 0. ? col : col.bgr;\n    col.g *= 0.8;\n    // draw coloured dots:\n    float d = 0.005;\n    float m = mod(iTime, 32.) - 28.;\n    if (m > 0.) {\n        d *=2. * (m + tile / numTiles);\n        col *= step(0.5, 1. - col.g); // make white rings black\n    }\n    float s = iTime + 50. * length(q);\n    float c = float(cols.length());\n    if (col.r == 0. && mind0 < d) col = cols[int(mod(s, c))];\n    \n    // todo: convert above to step /smoothstep\n    col.g *= nsin(tile * tile);\n    // ===============================================================================================\n    // ===============================================================================================\n    \n    // Border code:    \n    // ===============================================================================================\n    \n    float borderWidth = 3.;\n    vec3 borderInsetLineColour = white;\n    col = drawBorder(col, borderWidth, borderInsetLineColour, pp, hr, tile);\n    \n    // finally return the colour to caller(mainImage()):     \n    return col;\n}\t// END doStuff()\n    \n// ===============================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    float borderWidth = 6.;\n    vec3 borderInsetLineColour = white;\n \tvec3 col = doStuff(fragCoord, iResolution.xy);\n    col = drawBorder(col, borderWidth, borderInsetLineColour, fragCoord, iResolution.xy, -1.);\n    // finally return the colour:\n    fragColor = vec4(col, 1.0);        \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdfzH.jpg", "access": "shaders20k", "license": "mit", "functions": [[2736, 2736, 2761, 2761, 2919], [3008, 3008, 3027, 3027, 3056], [3058, 3058, 3090, 3090, 3137], [3139, 3139, 3167, 3167, 3232], [3234, 3234, 3266, 3266, 3307], [3380, 3380, 3399, 3399, 3417], [3419, 3419, 3436, 3436, 3454], [3456, 3456, 3475, 3475, 3493], [3495, 3495, 3516, 3516, 3544], [3546, 3546, 3567, 3567, 3595], [3597, 3597, 3619, 3619, 3653], [3655, 3655, 3686, 3686, 3758], [3760, 3760, 3801, 3801, 3840], [3842, 3842, 3857, 3857, 3895], [3940, 3940, 4029, 4265, 4802], [4804, 4804, 4838, 4838, 5242], [5244, 5244, 5286, 5319, 5469], [5472, 5472, 5487, 5487, 5525], [11092, 11092, 11149, 11149, 11441]], "test": "error"}
{"id": "4ttBzN", "name": "Nature Project-Sun", "author": "cake7914", "description": "Cool sun, cycle of being reborn", "tags": ["sun"], "likes": 1, "viewed": 127, "published": "Public", "date": "1538843027", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define repeat(v, r) (mod(v, r)-r/2.) //repeat function\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){ //rotates object\n  float r = cos(a); \n  float f = tan(a);\n  return mat2(r, f, -f, r);\n}\n\nfloat sphere(vec3 v, float r){ //creates sphere\n  return length(v)-r;\n}\n\nvoid pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tp = mod(p + halfsize, size) - halfsize;\n}\n\n// Converts v to Polar Coordinates, then repeat based on r\nvoid pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n}\n//=======================\n\n\nShape sun(vec3 c){\n  Shape shape;\n  float s;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n\n\n  vec3 i = c;\n    \n    i.xy *= rot(c.z*0.1+iTime*0.5); // Twist Coord System\n    pModPolar(i.xy, 15.); // Twist Repeat\n    i.x -= abs(sin(iTime*10.))*1.; // Offset from origin\n    pMod1(i.x, 3.);\n  \ts = sphere(i, 1.4); // Create sphere\n\n    // Plug-in distance to object and color\n    vec4 color = vec4(.9, 0.9, 0.2, 1.); //yellow color for sun\n  \tshape.dist = s;\n  \tshape.color = color;\n\n  return shape;\n}\n\n\n// Map all objects within scene\nShape map(vec3 c){\n  Shape sun = sun(c);\n  return sun;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., -100.); // Setup Camera, zoom out\n  vec3 f = normalize(vec3(v, 1.)); // Frustrum\n  vec3 scene = cam;\n  fragColor = vec4(0.); // Background Color\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist; // Step to SDF\n\n\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ttBzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 182, 204, 204, 271], [273, 273, 291, 308, 379], [381, 381, 411, 428, 452], [454, 454, 493, 493, 564], [566, 625, 663, 663, 783], [812, 812, 830, 830, 1347], [1350, 1382, 1400, 1400, 1438], [1440, 1440, 1497, 1497, 1984]], "test": "error"}
{"id": "4ttfDr", "name": "parquetDeform hex in disguise", "author": "ollj", "description": "cosine set deformation between square and hex lattice, with works surprisingly well\ni was searching this shader of mine, and could not find it, i thought i uploaded or labeled it well,neither was ture so far. i might just have forgotten to ever submit it.", "tags": ["deformation", "hex", "lattice", "disguise", "parquet"], "likes": 6, "viewed": 458, "published": "Public API", "date": "1539229741", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat TAU=6.28318530718;\nfloat L=10.0;\n\n\nfloat miv(vec2 a){return min(a.x,a.y);}\n#define u2(a)((a)*2.-1.)\n////ss2t(a)changes a seesaw waves output(range [0..1])to a triangle wave.\n#define ss2t(a)a=abs(u2(a))\n\n\n\n\n//;return vec4(length(p-m));//to make a mouse work within a lattice as frame,you mzst delay this till the end.\n//meaning,you do it on a differential(between p and m)of all transforms.\n//;if(length(p)<.03)return vec4(0,0,0,1);return vec4(1);}\n\nvec2 hash(vec2 p,float z\n){vec3 p3=vec3(p,z+10.0*floor(iTime/40.0))\n ;p3=fract(p3*.1031)\n ;p3+=dot(p3,p3.yzx+19.19)\n ;float t=TAU*fract((p3.x+p3.y)*p3.z)\n ;return vec2(cos(t),sin(t));}\n//F andd G are known as \"skew constants\",scale a skew matrix to translate between orthogonal(square)and BarycentricRombus(tri/hex)\nfloat F=0.36602540378;//sqrt(3.)*.5-.5\nfloat G=0.21132486540;//(sqrt(3.)*.5-.5)/sqrt(3.)-.5-(.5/sqrt(3.))\n//https://www.shadertoy.com/view/Xs2fRd\nvec2 skew(vec2 p){float f=(p.x+p.y)*F;return p+vec2(f,f);}\nvec2 unskew(vec2 q){float g=(q.x+q.y)*G;return q-vec2(g,g);}\nvec4 sSkew(float t,vec2 p,vec2 m//time,fragmentPosition,MousePosition\n){ ;p*=4.;m*=4.//zoom\n ;t/=5.//;t=.5//debug overwrite\n ;t+=1.61*sin(p.x/iResolution.x)-cos(p.y/iResolution.y)//optional,transition between square and hex,over p.x,over time.\n//;t=fract(t);t=ss2t(t)//seesaw shape is less confusing than cosine shape:\n//;t=cos(t*5.)*.5+.5;//cosine shape instead of the asbovem,strangely causes brick pattern.\n ;t=cos(t)*.5+.5;//cosine shape instead of the asbovem,strangely causes brick pattern.less steep\n//;t=(p.x+iResolution.x)/iResolution.x/2.//debug overwrite t=0 makes a square patern,t=1 makes a hex pattern,\n ;p/=100.;m/=100.//treat this like a rotation matrix\n ;p=t*skew(p)+(1.-t)*p;m=t*skew(m)+(1.-t)*m//,except that its a skew matrix that lerps over T from L2 to L3\n ;vec2 q=vec2(0),n=vec2(0);//used only within the loop\n ;float r=999990.;//remember longest distance\n ;for(float i=-1.;i<2.;i++\n){for(float j=-1.;j<2.;j++){//i tried a voronoi,but mostly failed?\n  ;q=fract(p)-vec2(i,j)//fract,with voronoi L2 3x3-offsets \n   ;n=fract(m)\n   ;q=t*unskew(q)+(1.-t)*q;n=t*unskew(n)+(1.-t)*n\n   ;r=min(length(q-n),r)\n ;}};return vec4(r);}\n\n//skewed and then unskewed noise for a 2-simplex lattice.(equilateral triangles)is simplicial 2d noise\n//,but not necessarily what we mean by \"simplex noise\"\n//,because you could still do fbm with this and turn it into simplicial-value-noise.\n//actual simplex,nouse is smarter simoplicial-complex folding than this.this is the least common of value and gradient noise!\nfloat noise(vec2 p,float r2,float z,vec2 q){vec2 h=hash(q,z),d=unskew(q)-p;z=d.x*d.x+d.y*d.y\n ;return pow(max(0.,r2-z),4.)*dot(d,h);}\nfloat noise(vec2 p,float r2,float z \n){vec2 q=skew(p),r=fract(q);q=floor(q);return \n  noise(p,r2,z,q)\n+noise(p,r2,z,q+1.)\n+noise(p,r2,z,q+mix(vec2(0,1),vec2(1,0),vec2(step(r.y,r.x))));}\nfloat noise(vec2 p,float r2){float k=0.,o=1.;for(float z=.0;z<L;++z){k+=noise(p/o,r2,z)*o;o*=2.;}return k;}\nvec4 sNoise(float T,vec2 p\n){T=(T-10.)/2.\n ;float N=floor(T),pT=T/10.,k=0.,o=1.\n ;p/=pow(2.,6.64385618977*(1.-pT))\n ;T-=floor(T)\n ;for(float z=0.;z<N;++z){k+=noise(p/o,.5,z)*o;o*=2.;}\n ;float m=T\n ;if(N<1.)m=1.\n ;k+=m*noise(p/o,0.5,N)*o\n ;k=.5+pow(2.,(1.-pT)*8.96578428466)*0.1*k\n ;return vec4(k,k,k,1.);}\n\nvec4 sLatice(float T,vec2 p){T=(T-5.)/5.\n ;return vec4(vec3(.5+50.*pow(100000.,1.-sqrt(T))*noise(p/100.,.5*T,0.)),1);}\n\n\n\nvec4 sIsoWorld(float T,vec2 p){\n ;T=min(1.,(T-30.)/3.)\n ;float k=noise(p,.5)\n ;k=max(0.,min(1.,.5+.1*k))\n ;vec4 r;\n ;if(k<.5)r=vec4(0.,k,.7+.6*k,1.)\n ;else if(k<.55)r=vec4(1.,4.*(k-.5)+.8,.6,1.)//ocean?\n ;else if(k<.8)r=vec4(0,.5*k+.5,0,0)//sand?\n ;else if(k<.85)r=vec4(0,-9.*k+8.,0,1.)//dtrrs(bright green)?\n ;else r=vec4(0,(1.-k)*.3+.4,0,1)//grass(dark green)?\n ;return(1.-T)*vec4(k,k,k,1.)+T*r;}\n\nvoid mainImage(out vec4 o,vec2 p\n){p=p-.5*iResolution.xy\n ;vec2 m=iMouse.xy-.5*iResolution.xy;\n ;float T=iTime;\n//;T=mod(T,40.)\n ;o=vec4(.5,.5,.5,1.)\n//;if(T<5.)\n ;o=sSkew(T,p,m)\n//;else if(T<10.)o=sLatice(T,p-m)\n//;else if(T<30.)o=sNoise(T,p-m)\n//;else    o=sIsoWorld(T,p-m)\n ;}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ttfDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 60, 60, 81], [456, 456, 483, 483, 640], [641, 918, 936, 936, 976], [977, 977, 997, 997, 1037], [1038, 1038, 1110, 1110, 2182], [2184, 2553, 2597, 2597, 2686], [2687, 2687, 2726, 2726, 2872], [2873, 2873, 2902, 2902, 2980], [2981, 2981, 3010, 3010, 3286], [3288, 3288, 3317, 3317, 3406], [3410, 3410, 3441, 3441, 3808], [3810, 3810, 3845, 3845, 4089]], "test": "valid"}
{"id": "4ttfR4", "name": "Nature Project- Raining", "author": "tiff", "description": "imitates rain falling", "tags": ["raining"], "likes": 0, "viewed": 134, "published": "Public", "date": "1538887025", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// Rotate\nmat2 rot(float a){\n    return mat2(cos(a), -sin(a),\n                sin(a), cos(a));\n}\n\n// SDF Sphere\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n}\n\nfloat random(vec2 v) {\n  return fract(tan(dot(v*.1, vec2(200.654, .746)))*.4);\n}\n\n// Map distance to all objects in the scene\nfloat map(vec3 p)\n{\n    float radius = 0.05;\n    \n    // Transform coordinate space so spheres repeat\n    vec3 q = fract(p)*0.45 -0.37;\n\n    // Signed distance of sphere\n    return sphere(q, radius);\n}\n\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0;\n    for (int i = 0; i < 75; ++i) {\n        vec3 p = origin +r *t ;\n        float d = map(p);\n        t += d;\n        }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv*3.0- 1.5; // Remap the space to -1. to 1.\n    uv.x *= iResolution.x/iResolution.y;   \n    \t\n   \tfloat FOV = 1.0;\n   \tvec3 ray = normalize(vec3(uv, FOV));\n    \n    // Rotate Y towards Z\n    //ray.yz *= -rot(iTime*0.1);    \n    \n    vec3 origin = vec3(random(uv), tan(random(uv))*8.+iTime *2., 0.0);\n    float t = trace(origin, ray);\n       \n    float linearFog = 2.0 / (1.0 - t*0.2);\n    float expFog = 3.0 / (t*t*0.1);\n    \n    vec3 color = vec3(0.1, 0.1, 1.0);\n    \n    vec3 fc = vec3(expFog)*color;\n    //vec3 fc = vec3(expFog) / cos(color)- color*0.7\n\n    // Output pixels to screen\n    fragColor = vec4(fc,2.0);\n\n    \n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ttfR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 12, 30, 30, 98], [100, 114, 149, 149, 180], [182, 182, 204, 204, 262], [264, 308, 327, 327, 509], [512, 512, 547, 547, 699], [702, 702, 759, 809, 1490]], "test": "valid"}
{"id": "4ttfRM", "name": "voronoi-2", "author": "teraspora", "description": "2nd attempt, using algorithm from https://www.youtube.com/watch?v=l-07BXzNdPw&t=740s, but using Manhattan distance metric.", "tags": ["voronoi"], "likes": 1, "viewed": 978, "published": "Public", "date": "1539041544", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Another take on Voronoi, this time using \n// Martijn's random function and also his algorithm for \n// mapping the distance\n#define PI 3.141592653588\n\n// Some useful colours:\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 crimson =      vec3(1.,   0.,   0.4  );\nconst vec3 yellow =      vec3(1.,   1.,   0.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 orange = vec3(1.0, 0.4, 0.);\nconst vec3 cyan = vec3(0., 0.4, 1.0);\nconst vec3 magenta = vec3(1.0, 0., 1.0);\nconst vec3 gold = vec3(1.0, 0.84, 0.66);\n\nvec3[] cols = vec3[](white, crimson, yellow, magenta, gold, cyan, orange);\nvec3 col;\n\n// ==================================================================\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n// - not tested!\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from HSL to linear RGB\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\n// My inline library of useful functions:\n// =======================================\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\nfloat om(float x) {\n\treturn 1. - x;\n}\n\nvec3 om(vec3 v) {\n\treturn 1. - v;\n}\n\nfloat op(float x) {\n\treturn 1. + x;\n}\n\nfloat nsin(float x) {\n\treturn op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n\treturn op(cos(x)) * 0.5;\n}\n\nfloat sqrtp(float x) {\n\treturn sqrt(x < 0. ? -x : x); \n}\n\nfloat nmmod(float x, float y) {\n\tfloat xmn = 2. * mod(x, y) / y;\n    return xmn < 1. ? xmn : om(xmn);\n}\n\nvec3 omss(float mn, float mx, vec3 val) {\n\treturn om(smoothstep(mn, mx, val));\n}\n\nvec2 nmouse() {\n\treturn iMouse.xy / iResolution.xy;\n}\n\nvec3 invert(vec3 col) {\n \treturn 1. - clamp(col, 0., 1.);   \n}\n\nbool isOdd(float p) {\n    return fract(p * 0.5) >= 0.5;\n}\n\nfloat minkd(vec2 u, vec2 v, float order) {\t// Minkowski distance order 1\n    if (order <= 0.) return 0.;\t\t\t\t// i.e. Manhattan distance\n\treturn abs(pow(abs(pow(v.x - u.x, order)) + abs(pow(v.y - u.y, order)), 1. / order)); \n}\n\n\n// =======================================\n\n// rand generator from \n// https://www.youtube.com/watch?v=l-07BXzNdPw&t=740s\nvec2 r22(vec2 p) {\n\tvec3 a = fract(p.xyx * vec3(923.34, 234.34, 345.65));\n\ta += dot(a, a - 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\n\nfloat f(float x) {\n\treturn sin(cos(0.2 * iTime * x)) + cos(2. * sin(0.23 * iTime * x)) - sqrt(0.2 *abs(x) * cos(0.02 * iTime * x));\n}\n\nvec3 drawBorder(vec3 col, float b, vec3 insetColour, vec2 pp, vec2 hr, float tileIndex) {\n    // `b` is the border width\n    // `col` is the input (and output) colour\n    // `pp` is (unnormalised) coordinate of pixel\n    // `hr` is (unnormalised) resolution\n    // Make a border: `b` px solid black; with `insetColour` inset:\n    if (tileIndex != -1.) {\n    \t//  any special code for single-pane use goes here    \n    }\n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = insetColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = insetColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));\n    return col;\n    \n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = iTime / 3.;\n    float scale = 0.5;\n    \n    if (t < 24.) scale += 0.1 * sin(t);\n    \n\tfloat asp = iResolution.x/iResolution.y;\n    // Normalized pixel coordinates (y from -1 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / (iResolution.y * scale);\n\t\t\n    uv.y = abs(uv.y);\n    //if (nmouse().x >= 0.5) \n    uv = abs(uv);\n    \n    // col = crimson;\n    float numPoints = t / 4.;\n    float m = 0.;\n    float mind = 100.;\n    float ci;\n    \n    // generate a bunch of random points\n    for (float i = 0.; i < numPoints; i++) {\n    \tvec2 n = r22(vec2(i));\n        // sin of both components varied with time\n        vec2 p = sin(n * t);\n        // get distance to point\n        float d = minkd(uv, p, 1.);\n        //m += smoothstep(.05, .01, d);\n        if (d < mind) {\n        \tmind = d;\n            ci = i;\n        }\n    }\n    \n    col = invert(vec3(mind));\n    col.g -= nsin(t + length(uv));\n    col.b += 0.5 * smoothstep(0., 1., col.r + col.b);\n    \n    if (rgb2hcv(col).z < 0.01) col = 0.5 + 0.5*cos(t+uv.xyx+vec3(27,49,81));\n    \n    \n    fragColor = vec4(col, 1.);\n}\n\n//col = vec3(m, nsin(length(uv)), ncos(t));\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ttfRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[829, 829, 854, 854, 1012], [1014, 1078, 1102, 1155, 1438], [1440, 1475, 1499, 1499, 1619], [1621, 1656, 1680, 1680, 1832], [1920, 1920, 1939, 1939, 1968], [1970, 1970, 2002, 2002, 2049], [2051, 2051, 2079, 2079, 2144], [2146, 2146, 2178, 2178, 2219], [2221, 2221, 2240, 2240, 2258], [2260, 2260, 2277, 2277, 2295], [2297, 2297, 2316, 2316, 2334], [2336, 2336, 2357, 2357, 2385], [2387, 2387, 2408, 2408, 2436], [2438, 2438, 2460, 2460, 2494], [2496, 2496, 2527, 2527, 2599], [2601, 2601, 2642, 2642, 2681], [2683, 2683, 2698, 2698, 2736], [2738, 2738, 2761, 2761, 2800], [2802, 2802, 2823, 2823, 2859], [2861, 2861, 2903, 2933, 3085], [3132, 3210, 3228, 3228, 3356], [3359, 3359, 3377, 3377, 3492], [3494, 3494, 3583, 3819, 4365], [4367, 4367, 4424, 4424, 5514]], "test": "error"}
{"id": "4tVyDd", "name": "ambient-278", "author": "teraspora", "description": "ambient", "tags": ["ambient"], "likes": 0, "viewed": 1282, "published": "Public API", "date": "1538403187", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ambient-278 - a fragment shader in OpenGL, built on shadertoy.com;\n// Author: John Lynch (teraspora);\n// Date: 26 SEP 2018.\n\nconst float PI = 3.141592654;\nconst float TWO_PI = 6.283185307;\n\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 cyan =       vec3(0.0,  1.,   0.84);\nconst vec3 magenta =    vec3(1.0,  0.,   1.0 );\nconst vec3 blue =       vec3(0.0,  0.6,  0.84);\nconst vec3 gold =       vec3(1.0,  0.84, 0.66);\nconst vec3 orange =     vec3(1.0,  0.2,  0.0 );\nconst vec3 yellow =     vec3(1.0,  1.0,  0.0 );\nconst vec3 dark_blue =  vec3(0.0,  0.05, 0.15);\nconst vec3 crimson =    vec3(0.76, 0.0,  0.42);\n    \nvec3[] cols = vec3[](magenta, cyan, crimson, blue, orange, yellow);\nint cl = cols.length();\n\n// ==================================================================\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n// - not tested!\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from HSL to linear RGB\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\nfloat tileIndex;\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\nfloat om(float x) {\n\treturn 1. - x;\n}\n\nvec3 om(vec3 v) {\n\treturn 1. - v;\n}\n\nfloat op(float x) {\n\treturn 1. + x;\n}\n\nfloat nsin(float x) {\n\treturn op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n\treturn op(cos(x)) * 0.5;\n}\n\nfloat sqrtp(float x) {\n\treturn sqrt(x < 0. ? -x : x); \n}\n\nfloat nmmod(float x, float y) {\n\tfloat xmn = 2. * mod(x, y) / y;\n    return xmn < 1. ? xmn : om(xmn);\n}\n\nvec3 omss(float mn, float mx, vec3 val) {\n\treturn om(smoothstep(mn, mx, val));\n}\n\nvec2 nmouse() {\n\treturn iMouse.xy / iResolution.xy;\n}\n\nvec3 drawBorder(vec3 col, float b, vec3 insetColour, vec2 pp, vec2 hr, float tileIndex) {\n    // `col` is the input colour\n    // `pp` is (unnormalised) coordinate of pixel\n    // `hr` is (unnormalised) resolution\n    // Make a border: `b` px solid black; with `insetColour` inset:\n    if (tileIndex != -1.) {\n    \tpp -= hr / 2.;\n        pp = rotate(pp, 0.3 * iTime * tileIndex / 4.);\n        pp = pp + vec2(cos(iTime) + tileIndex * cos(iTime * 2.), sin(iTime) + 16. * cos(iTime / tileIndex)) * 4.;\n    \t\n    \n    }\n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = insetColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = insetColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));\n    return col;\n}\n\n\n\n// MAIN METHOD:\n\nvec3 mainCode(vec2 pixel, vec2 res) {\n    float time = iTime;\n    \n    // Set this var to the number of tiles acroos and down:\n    float tileDim = 1.;\n    float numTiles = tileDim * tileDim;\n        \n    // the output vector, before normalisation,\n    // giving the position the program needs to know!-\n    vec2 pp = pixel;\n    vec2 hr = res / tileDim;\t// resolution of one tile\n    \n    // MUTABLE VARIABLES\n    float scaleFactor = 1.0;\n    \n    // ===============================================================\n    // Make numTiles sub-frames:\n    vec2 n = vec2(float(int(pixel.x / res.x * tileDim)), float(int(pixel.y / res.y * tileDim)));\n    \n    float tile = numTiles -(n.y * tileDim + n.x) - 1.; \n    // start at 1 so we don't lose stuff when multiplying\n    float toe = fract(tile / 2.) * 4. - 1.; // returns 1. if tile index odd, -1. if even;\n    float tile2 = tile * tile;\n    \n    // shift back to the first tile if in any other tile:\n    pp.x -= hr.x * n.x;\n    pp.y -= hr.y * n.y;\n    // normalise to [0, 1[, shift to make unit quad with origin in centre\n    vec2 q = pp / hr - 0.5;     // normalise\n    // then scale:\n    q /= scaleFactor;\n    // ===============================================================================================\n    \n    q *= 16. * op(nmmod(time, 111.));\n    q = rotate(q, time / 4.);\n    vec3 col = mix(yellow, crimson, sin(q.y) );\n\tfloat lambda = 64.;\n    float mt = mod(time, lambda);\n    float rmin = (mt < 14. ? 14. - mt : 0.) / 20.; \n    col *= step(rmin, length(q) * cos(arg(q) * time)); \n    col.g *= ncos(time * 0.25);\n    col.b = ncos(TWO_PI * sin(length(q) * mod(time, 277.)));\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return col;\n}\n    // ===============================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    float borderWidth = 6.;\n    vec3 borderInsetLineColour = white;\n \tvec3 col = mainCode(fragCoord, iResolution.xy);\n    col = drawBorder(col, borderWidth, borderInsetLineColour, fragCoord, iResolution.xy, -1.);\n    // finally return the colour:\n    fragColor = vec4(col, 1.0);; \n        \n}\n    \n    \n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tVyDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[980, 980, 1005, 1005, 1163], [1165, 1229, 1253, 1306, 1589], [1591, 1626, 1650, 1650, 1770], [1772, 1807, 1831, 1831, 1983], [2003, 2003, 2022, 2022, 2051], [2053, 2053, 2085, 2085, 2132], [2134, 2134, 2162, 2162, 2227], [2229, 2229, 2261, 2261, 2302], [2304, 2304, 2323, 2323, 2341], [2343, 2343, 2360, 2360, 2378], [2380, 2380, 2399, 2399, 2417], [2419, 2419, 2440, 2440, 2468], [2470, 2470, 2491, 2491, 2519], [2521, 2521, 2543, 2543, 2577], [2579, 2579, 2610, 2610, 2682], [2684, 2684, 2725, 2725, 2764], [2766, 2766, 2781, 2781, 2819], [2821, 2821, 2910, 3102, 3779], [3800, 3800, 3837, 3837, 5552], [5557, 5640, 5697, 5697, 5993]], "test": "error"}
{"id": "lddyRl", "name": "That stone ", "author": "valerysntx", "description": "got made wrong computation for acceptable result", "tags": ["procedural", "noise", "rock", "wet", "stone"], "likes": 4, "viewed": 339, "published": "Public", "date": "1540296137", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Wet stone\" by TDM. https://shadertoy.com/view/ldSSzV\n// 2018-03-01 00:06:30\n\n/*\n\"Wet stone\" by Alexander Alekseev aka TDM - 2014\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tdmaav@gmail.com\n*/\n\n#define SMOOTH\n\nconst int NUM_STEPS = 56;\nconst int AO_SAMPLES = 4;\nconst vec2 AO_PARAM = vec2(01.2, 5.8);\nconst vec2 CORNER_PARAM = vec2(0.5, 23.0);\nconst float INV_AO_SAMPLES = 1.0 / float(AO_SAMPLES);\nconst float TRESHOLD \t= 0.1;\nconst float EPSILON \t= 1e-3;\nconst float LIGHT_INTENSITY = 01.5;\nconst vec3 RED \t\t= vec3(1.0,0.0,1.0) * LIGHT_INTENSITY;\nconst vec3 ORANGE \t= vec3(0.0,0.0,0.3) * LIGHT_INTENSITY;\nconst vec3 BLUE \t= vec3(0.0,0.0,1.0) * LIGHT_INTENSITY;\nconst vec3 WHITE \t= vec3(1.0,1.0,0.8) * LIGHT_INTENSITY;\n\nconst float DISPLACEMENT = 0.1;\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat hash11(float p) {\n    return fract(sin(p * 727.1)*435.545);\n}\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*437.545);\n}\nvec3 hash31(float p) {\n\tvec3 h = vec3(127.231,491.7,718.423) * p;\t\n    return fract(sin(h)*435.543);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\n// fBm\nfloat fbm3(vec3 p, float a, float f) {\n    return noise_3(p);\n}\n\nfloat fbm3_high(vec3 p, float a, float f) {\n    float ret = 0.0;    \n    float amp = 1.0;\n    float frq = 1.0;\n    for(int i = 0; i < 4; i++) {\n        float n = pow(noise_3(p * frq),2.0);\n        ret += n * amp;\n        frq *= f;\n        amp *= a * (pow(n,0.2));\n    }\n    return ret;\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) { return pow(max(dot(n,l),0.0),p); }\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + s) / (3.1415 * 9.0);\n    return pow(max(dot(reflect(e,n),l),0.1),s) * nrm;\n}\n\n// distance functions\nfloat plane(vec3 gp, vec4 p) {\n\treturn dot(p.xyz,gp+p.xyz*p.w);\n}\nfloat sphere(vec3 p,float r) {\n\treturn length(p)-r;\n}\nfloat capsule(vec3 p,float r,float h) {\n    p.y -= clamp(p.y,-h,h);\n\treturn length(p)-r;\n}\nfloat cylinder(vec3 p,float r,float h) {\n\treturn max(abs(p.y/h),capsule(p,r,h));\n}\nfloat box(vec3 p,vec3 s) {\n\tp = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\nfloat rbox(vec3 p,vec3 s) {\n\tp = abs(p)-s;\n    return length(p-min(p,0.0));\n}\nfloat quad(vec3 p,vec2 s) {\n\tp = abs(p) - vec3(s.x,0.0,s.y);\n    return max(max(p.x,p.y),p.z);\n}\n\n// boolean operations\nfloat boolUnion(float a,float b) { return min(a,b); }\nfloat boolIntersect(float a,float b) { return max(a,b); }\nfloat boolSub(float a,float b) { return max(a,-b); }\n\n// smooth operations. thanks to iq\nfloat boolSmoothIntersect(float a, float b, float k ) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(a,b,h) + k*h*(1.0-h);\n}\nfloat boolSmoothSub(float a, float b, float k ) {\n    return boolSmoothIntersect(a,-b,k);\n}\t\n\n// world\nfloat rock(vec3 p) {    \n    float d = sphere(p,1.0);    \n    for(int i = 0; i < 9; i++) {\n        float ii = float(i);\n        float r = 2.5 + hash11(ii);\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\n        #ifdef SMOOTH\n        d = boolSmoothSub(d,sphere(p+v*r,r * 0.8), 0.03);\n        #else\n    \td = boolSub(d,sphere(p+v*r,r * 0.8));\n        #endif        \n    }\n    return d;\n}\n\nfloat map(vec3 p) {\n    float d = rock(p) + fbm3(p*4.0,0.4,2.96) * DISPLACEMENT;\n    d = boolUnion(d,plane(p,vec4(0.0,1.0,0.0,1.0)));\n    return d;\n}\n\nfloat map_detailed(vec3 p) {\n    float d = rock(p) + fbm3_high(p*4.0,0.4,2.96) * DISPLACEMENT;\n    d = boolUnion(d,plane(p,vec4(0.0,1.0,0.0,1.0)));\n    return d;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float dens) {\n    vec3 n;\n    n.x = map_detailed(vec3(p.x+EPSILON,p.y,p.z));\n    n.y = map_detailed(vec3(p.x,p.y+EPSILON,p.z));\n    n.z = map_detailed(vec3(p.x,p.y,p.z+EPSILON));\n    return normalize(n-map_detailed(p));\n}\nvec2 getOcclusion(vec3 p, vec3 n) {\n    vec2 r = vec2(0.5);\n    for(int i = 0; i < AO_SAMPLES; i++) {\n        float f = float(i)*INV_AO_SAMPLES;\n        float hao = 0.01+f*AO_PARAM.x;\n        float hc = 0.01+f*CORNER_PARAM.x;\n        float dao = map_detailed(p + n * hao) - TRESHOLD;\n        float dc = map_detailed(p - n * hc) - TRESHOLD;\n        r.x += clamp(hao-dao,0.0,1.0) * (1.0-f);\n        r.y += clamp(hc+dc,0.0,1.0) * (1.0-f);\n    }    \n    r.x = pow(clamp(1.0-r.x*INV_AO_SAMPLES*AO_PARAM.y,0.0,1.0),1.5);\n    r.y = clamp(r.y*INV_AO_SAMPLES*CORNER_PARAM.y,1.0,0.1);\n    return r;\n}\nvec2 spheretracing(vec3 ori, vec3 dir, out vec3 p) {\n    vec2 td = vec2(0.0);\n    for(int i = 0; i < NUM_STEPS; i++) {\n        p = ori + dir * td.x;\n        td.y = map(p);\n        if(td.y < TRESHOLD) break;\n        td.x += (td.y-TRESHOLD) * 0.9;\n    }\n    return td;\n}\n\n// stone\nvec3 getStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\n    c = min(c + pow(noise_3(vec3(p.x*20.0,0.0,p.z*20.0)),70.0) * 8.0, 1.0);\n    float ic = pow(1.0-c,0.5);\n    vec3 base = vec3(0.42,0.3,0.2) * 0.6;\n    vec3 sand = vec3(0.51,0.41,0.32);\n    vec3 color = mix(base,sand,c);\n        \n    float f = pow(1.0 - max(dot(n,-e),0.0), 1.5) * 0.75 * ic;\n    color = mix(color,vec3(1.0),f);    \n    color += vec3(diffuse(n,l,0.5) * WHITE);\n    color += vec3(specular(n,l,e,8.0) * WHITE * 1.5 * ic);\n    n = normalize(n - normalize(p) * 0.4);    \n    color += vec3(specular(n,l,e,80.0) * WHITE * 1.5 * ic);    \n    return color;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 iuv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    vec2 uv = iuv;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.23;\n        \n    // ray\n    vec3 ang = vec3(0.0,0.2,time);\n    if(iMouse.z > 0.0) ang = vec3(0.0,clamp(2.0-iMouse.y*0.01,0.0,3.1415),iMouse.x*0.01);\n\tmat3 rot = fromEuler(ang);\n    \n    vec3 ori = vec3(0.0,0.0,2.7);\n    vec3 dir = normalize(vec3(uv.xy,-2.0));    \n    ori = ori * rot;\n    dir = dir * rot;\n    \n    // tracing\n    vec3 p;\n    vec2 td = spheretracing(ori,dir,p);\n    vec3 n = getNormal(p,td.y);\n    vec2 occ = getOcclusion(p,n);\n    vec3 light = normalize(vec3(0.0,-1.0,1.0)); \n         \n    // color\n    vec3 color = vec3(1.0);    \n    if(td.x < 15.5 && p.y > -0.89) color = getStoneColor(p,occ.y,light,n,dir);\n    color *= occ.x;\n    \n    // desat\n\tcolor = mix( color, vec3(dot(color,vec3(0.33))), 0.6);\n\t\n    // gamma\n\tcolor = pow( color, vec3(0.45) );\n\n\t// tint\n\tcolor *= vec3(1.0,1.04,1.0);\n\t\n\t// vigneting\n\tcolor *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n               \n    // post\n    float vgn = smoothstep(1.2,0.7,abs(iuv.y)) * smoothstep(1.1,0.8,abs(iuv.x));\n    color *= 1.0 - (1.0 - vgn) * 0.15;\t\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lddyRl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[814, 822, 848, 848, 1194], [1195, 1195, 1218, 1218, 1262], [1263, 1263, 1285, 1285, 1359], [1360, 1360, 1382, 1382, 1462], [1464, 1476, 1502, 1502, 2123], [2125, 2132, 2170, 2170, 2195], [2197, 2197, 2240, 2240, 2484], [2486, 2498, 2536, 2536, 2571], [2572, 2572, 2618, 2618, 2720], [2722, 2744, 2774, 2774, 2809], [2810, 2810, 2840, 2840, 2863], [2864, 2864, 2903, 2903, 2954], [2955, 2955, 2995, 2995, 3037], [3038, 3038, 3064, 3064, 3115], [3116, 3116, 3143, 3143, 3193], [3194, 3194, 3221, 3221, 3290], [3292, 3314, 3348, 3348, 3367], [3368, 3368, 3406, 3406, 3425], [3426, 3426, 3458, 3458, 3478], [3480, 3515, 3570, 3570, 3657], [3658, 3658, 3707, 3707, 3749], [3752, 3761, 3781, 3781, 4150], [4152, 4152, 4171, 4171, 4301], [4303, 4303, 4331, 4331, 4466], [4468, 4479, 4515, 4515, 4723], [4724, 4724, 4759, 4759, 5314], [5315, 5315, 5367, 5367, 5583], [5585, 5594, 5655, 5655, 6223], [6225, 6233, 6290, 6290, 7563]], "test": "valid"}
{"id": "ll3BDN", "name": "Chanel Final", "author": "Flopine", "description": "Result of the actual performance at the Chanel Foundation gala (still coded in 15 minutes)", "tags": ["raymarching", "performance", "15mins"], "likes": 24, "viewed": 645, "published": "Public", "date": "1539638234", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui and Coyhot for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n\n#define ITER 64.\n#define PI 3.141592\n#define time iTime\n#define BPM 25./2.\n#define tempo BPM/60.\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.*PI*(c*t+d));}\n\nfloat random (vec2 st)\n{return fract(sin(dot(st.xy, vec2(12.2544, 35.1571)))*5418.548416);}\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y, p.x);\n    float l = length(p);\n    a = mod(a-per/2., per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\nvec2 mo(vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y > p.x) p.xy = p.yx;\n    return p;\n}\n\nfloat stmin(float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5 * (u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvec2 path (float t)\n{\n    float a = sin(t*0.2 + 1.5), b = sin(t*0.2);\n    return vec2(a, a*b);\n}\n\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\nfloat od (vec3 p, float d)\n{return dot(p, normalize(sign(p)))-d;}\n\nfloat cyl (vec2 p, float r)\n{return length(p)-r;}\n\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p.xyz, p.yzx);\n    return min(p.x, min(p.y,p.z)) - d;\n}\n\nfloat prim1 (vec3 p)\n{\n    float c = cyl(p.xz, 0.1);\n    float per = 2.;\n    p.y += time*tempo;\n    p.y = mod (p.y-per/2., per)-per/2.;\n    return smin(sphe(p, 0.3), c, 0.5);\n  \n}\n\nfloat prim2 (vec3 p)\n{\n    float s = sphe(p,1.);\n    float o = od(p,.9);\n    p.xz *= rot(p.y*0.7);\n    p.xz = moda(p.xz, 2.*PI/5.);\n    p.x -= 1.;\n    return smin(prim1(p), max(-o,s), 0.5);\n}\n\nfloat prim3 (vec3 p)\n{\n    p.xy = mo(p.xy, vec2(2.));\n    return prim2(p);\n}\n\nfloat prim4 (vec3 p)\n{\n    p.yz *= rot(p.x*0.1);\n    p.xy = moda(p.xy, 2.*PI/4.);\n    p.x -= 4.;\n    return prim3(p);\n}\n\nfloat prim5 (vec3 p)\n{\n    float per = 8.;\n    p.xy *= rot(p.z*0.2);\n    p.z = mod(p.z-per/2., per) -per/2.;\n    return prim4(p);\n} \n\nfloat prim6 (vec3 p)\n{\n    p.z -= time;\n    p.xz *= rot(time*tempo);\n    p.xy *= rot(time*tempo);\n    p *= 1.2;\n    return stmin(od(p, 1.), sphe(p,1.), 0.5, 4.);\n}\n\n\n\nfloat g = 0.;\nfloat SDF(vec3 p)\n{\n    float d = smin(prim5(p), prim6(p), 0.5);\n    g+=0.1/(0.1+d*d); \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(0.001,0.001,-10. + time); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n\n    float shad = 0.;\n    float dither = random(uv);\n\n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/ITER;\n            break;\n        }\n        d *= 0.9 + dither*0.1;\n        p += d*rd * 0.7;\n    }\n\n    float t = length(ro-p);\n\n    vec3 pal = palette\n        (length(uv),\n         vec3(0.5),\n         vec3(0.5),\n         vec3(0.5),\n         vec3(0.,0.3,0.7));\n\n    vec3 c = vec3(shad) * pal;\n    c = mix(c, vec3(0.,0.,0.2), 1.-exp(-0.001 *t *t));\n    c += g* 0.04 * (1.-length(uv));\n\n    fragColor = vec4(c,1.);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3BDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 279, 335, 335, 366], [368, 368, 392, 392, 459], [461, 461, 492, 492, 618], [620, 620, 645, 645, 711], [713, 713, 762, 762, 868], [870, 870, 911, 911, 988], [990, 990, 1009, 1009, 1052], [1054, 1054, 1075, 1075, 1150], [1152, 1152, 1182, 1182, 1202], [1204, 1204, 1232, 1232, 1269], [1271, 1271, 1300, 1300, 1320], [1322, 1322, 1351, 1351, 1442], [1444, 1444, 1472, 1472, 1556], [1558, 1558, 1580, 1580, 1737], [1739, 1739, 1761, 1761, 1930], [1932, 1932, 1954, 1954, 2008], [2010, 2010, 2032, 2032, 2129], [2131, 2131, 2153, 2153, 2262], [2265, 2265, 2287, 2287, 2428], [2446, 2446, 2465, 2465, 2549], [2551, 2551, 2608, 2608, 3395]], "test": "valid"}
{"id": "ll3BR4", "name": "Waterrr", "author": "Noge", "description": "cool", "tags": ["water"], "likes": 4, "viewed": 165, "published": "Public", "date": "1538737522", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int firstOctave = 3;\nconst int octaves = 8;\nconst float persistence = 0.6;\n\n\n//Based on https://www.shadertoy.com/view/4lB3zz by madweedfall\n\n//Not able to use bit operator like <<, so use alternative noise function from YoYo\n//\n//https://www.shadertoy.com/view/Mls3RS\n//\n//And it is a better realization I think\nfloat noise(int x,int y)\n{   \n    float fx = float(x);\n    float fy = float(y);\n    \n    return 2.0 * fract(sin(dot(vec2(fx, fy) ,vec2(12.9898,78.233))) * 43758.5453) - 1.0;\n}\n\nfloat smoothNoise(int x,int y)\n{\n    return noise(x,y)/4.0+(noise(x+1,y)+noise(x-1,y)+noise(x,y+1)+noise(x,y-1))/8.0+(noise(x+1,y+1)+noise(x+1,y-1)+noise(x-1,y+1)+noise(x-1,y-1))/16.0;\n}\n\nfloat COSInterpolation(float x,float y,float n)\n{\n    float r = n*3.1415926;\n    float f = (1.0-cos(r))*0.5;\n    return x*(1.0-f)+y*f;\n    \n}\n\nfloat InterpolationNoise(float x, float y)\n{\n    int ix = int(x);\n    int iy = int(y);\n    float fracx = x-float(int(x));\n    float fracy = y-float(int(y));\n    \n    float v1 = smoothNoise(ix,iy);\n    float v2 = smoothNoise(ix+1,iy);\n    float v3 = smoothNoise(ix,iy+1);\n    float v4 = smoothNoise(ix+1,iy+1);\n    \n   \tfloat i1 = COSInterpolation(v1,v2,fracx);\n    float i2 = COSInterpolation(v3,v4,fracx);\n    \n    return COSInterpolation(i1,i2,fracy);\n    \n}\n\nfloat PerlinNoise2D(float x,float y)\n{\n    float sum = 0.0;\n    float frequency =0.0;\n    float amplitude = 0.0;\n    for(int i=firstOctave;i<octaves + firstOctave;i++)\n    {\n        frequency = pow(2.0,float(i));\n        amplitude = pow(persistence,float(i));\n        sum = sum + InterpolationNoise(x*frequency,y*frequency)*amplitude;\n    }\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\t\t{\n\t\t\tvec2 uv = fragCoord.xy / iResolution.xy;\n            \n\t\t\tfloat t = iTime + 100.0;\n            \n            float x = uv.x;\n\t\t\t//float x = ((uv.x - 0.5) * (0.4 + 0.4 * uv.y));\n            \n            //layer1\n\t\t\tfloat x1 = x+t*0.01;\n\t\t\tfloat y1 = uv.y+3.0+0.05*cos(t*2.0)+t*0.01;\n\t\t\tfloat noise1 = 0.5+2.0*PerlinNoise2D(x1,y1);\n            \n            //layer2\n\t\t\tfloat x2 = x+t*0.05;\n\t\t\tfloat y2 = uv.y+3.0+0.1*cos(t);\n\t\t\tfloat noise2 = 0.5+2.0*PerlinNoise2D(x2,y2);\n                        \n\t\t\tfloat noise = 1.2*noise1+0.6*noise2;\n            \n            //round noise\n\t\t\tfloat a = floor(noise*10.0)/10.0;\n\n\t\t\tfloat b = floor(noise*50.)/50.;\n\t\t\tfloat c = floor(noise2*50.0);\n            \n\t\t\tfloat final = a;\n            \n            //Add shine\n\t\t\tif((b==0.7||b==0.9||b==0.5||b==1.1||b==0.5)\n\t\t\t   &&noise2>0.50\n\t\t\t){\n\t\t\t\tfinal=0.2+0.2*noise2;\n\t\t\t}    \n\t\t\tfragColor = vec4(1.0-final,1.0-0.5*final,1.0-0.25*final,1.0);\n\t\t}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3BR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 319, 345, 345, 494], [496, 496, 528, 528, 682], [684, 684, 733, 733, 825], [827, 827, 871, 871, 1287], [1289, 1289, 1327, 1327, 1652], [1654, 1654, 1713, 1713, 2642]], "test": "valid"}
{"id": "ll3BW7", "name": "Digital Brain Purple", "author": "coler706", "description": "Copy/Remix of Digital Brain.https://www.shadertoy.com/view/4sl3Dr", "tags": ["fractal"], "likes": 11, "viewed": 760, "published": "Public", "date": "1539807961", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// by srtuss, 2013\n\n// rotate position around axis\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\n// 1D random numbers\nfloat rand(float n)\n{\n    return fract(sin(n) * 43758.5453123);\n}\n\n// 2D random numbers\nvec2 rand2(in vec2 p)\n{\n\treturn fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\n\n// 1D noise\nfloat noise1(float p)\n{\n\tfloat fl = floor(p);\n\tfloat fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n// voronoi distance noise, based on iq's articles\nfloat voronoi(in vec2 x)\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\t\n\tvec2 res = vec2(8.0);\n\tfor(int j = -1; j <= 1; j ++)\n\t{\n\t\tfor(int i = -1; i <= 1; i ++)\n\t\t{\n\t\t\tvec2 b = vec2(i, j);\n\t\t\tvec2 r = vec2(b) - f + rand2(p + b);\n\t\t\t\n\t\t\t// chebyshev distance, one of many ways to do this\n\t\t\tfloat d = max(abs(r.x), abs(r.y));\n\t\t\t\n\t\t\tif(d < res.x)\n\t\t\t{\n\t\t\t\tres.y = res.x;\n\t\t\t\tres.x = d;\n\t\t\t}\n\t\t\telse if(d < res.y)\n\t\t\t{\n\t\t\t\tres.y = d;\n\t\t\t}\n\t\t}\n\t}\n\treturn res.y - res.x;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float flicker = noise1(iTime * 2.0) * 0.8 + 0.4;\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = (uv - 0.5) * 2.0;\n\tvec2 suv = uv;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\t\n\tfloat v = 0.0;\n\t\n\t// that looks highly interesting:\n\t//v = 1.0 - length(uv) * 1.3;\n\t\n\t\n\t// a bit of camera movement\n\tuv *= 0.6 + sin(iTime * 0.1) * 0.4;\n\tuv = rotate(uv, sin(iTime * 0.3) * 1.0);\n\tuv += iTime * 0.4;\n\t\n\t\n\t// add some noise octaves\n\tfloat a = 0.6, f = 1.0;\n\t\n\tfor(int i = 0; i < 3; i ++) // 4 octaves also look nice, its getting a bit slow though\n\t{\t\n\t\tfloat v1 = voronoi(uv * f + 5.0);\n\t\tfloat v2 = 0.0;\n\t\t\n\t\t// make the moving electrons-effect for higher octaves\n\t\tif(i > 0)\n\t\t{\n\t\t\t// of course everything based on voronoi\n\t\t\tv2 = voronoi(uv * f * 0.5 + 50.0 + iTime);\n\t\t\t\n\t\t\tfloat va = 0.0, vb = 0.0;\n\t\t\tva = 1.0 - smoothstep(0.0, 0.1, v1);\n\t\t\tvb = 1.0 - smoothstep(0.0, 0.08, v2);\n\t\t\tv += a * pow(va * (0.5 + vb), 2.0);\n\t\t}\n\t\t\n\t\t// make sharp edges\n\t\tv1 = 1.0 - smoothstep(0.0, 0.3, v1);\n\t\t\n\t\t// noise is used as intensity map\n\t\tv2 = a * (noise1(v1 * 5.5 + 0.1));\n\t\t\n\t\t// octave 0's intensity changes a bit\n\t\tif(i == 0)\n\t\t\tv += v2 * flicker;\n\t\telse\n\t\t\tv += v2;\n\t\t\n\t\tf *= 3.0;\n\t\ta *= 0.7;\n\t}\n\n\t// slight vignetting\n\tv *= exp(-0.6 * length(suv)) * 1.2;\n\t\n\tvec3 cexp = vec3(2.0, 4.0, 1.0);\n\tcexp *= 1.4;\n\t\n\t// old blueish color set\n\t//vec3 cexp = vec3(6.0, 4.0, 2.0);\n\t\n\tvec3 col = vec3(pow(v, cexp.x), pow(v, cexp.y), pow(v, cexp.z)) * 2.0;\n\t\n\tfragColor = vec4(min(col,vec3(1.0))*0.75, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3BW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 51, 81, 81, 155], [157, 178, 199, 199, 243], [245, 266, 289, 289, 381], [383, 395, 418, 418, 507], [509, 559, 585, 585, 1024], [1028, 1028, 1085, 1085, 2579]], "test": "valid"}
{"id": "ll3BWH", "name": "CharacterDemo", "author": "tqle", "description": "How to build a character", "tags": ["demo"], "likes": 0, "viewed": 69, "published": "Public", "date": "1539619717", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat sphere(vec3 v, float r){\n  return length(v)-r;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n\ta = -a;\n\tfloat m = min(a, b);\n\t//avoid the expensive computation where not needed (produces discontinuity though)\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/n/2.0;\n\t\tcolumnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\n\t\tpR45(p);\n\t\tp.y += columnradius;\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += -columnradius*sqrt(2.)/2.;\n\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\tpMod1(p.y,columnradius*2.);\n\n\t\tfloat result = -length(p) + columnradius;\n\t\tresult = max(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn -min(result, b);\n\t} else {\n\t\treturn -m;\n\t}\n}\n\n\n\n//=======================\n\nShape character(vec3 c){\n  Shape shape;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n    \n  vec3 p = c; // Body\n  vec3 e = c; // Eyes\n  vec3 a = c; // Arms\n  vec3 m = c; // Mouth\n  vec3 h = c; //\n\n  \n    // Body\n    float body = fBox(p, vec3(1.));\n    \n    // Eyes\n    e.x = abs(e.x)-1.; // Mirror\n    float eye = fBox(e+vec3(0.5, -0.2, 1.0), \n                     vec3(0.25, 0.25, 0.5));\n    float pupil = sphere(e + vec3(0.475, -0.15, .5 + abs(sin(iTime))), 0.2);\n    // Arms\n    a.x = abs(a.x)-2.3;\n    float arm = fBox(a+vec3(1.1, 0.2, 0.85),\n                     vec3(0.25, 0.5, 0.25));\n    \n    \n    // Mouth\n    float mouth = fBox(m+vec3(0., 0.5, 0.75),\n                      vec3(0.5, 0.1, 0.5));\n    // Hat\n    float hat = sphere(h - vec3(.0, 1.25, 0.), .5);\n    h.yz *= rot(radians(90.));\n    h.xy *= rot(iTime*.5);\n    pModPolar(h.yx, 20.);\n    h.y /= cos(sin(c.z));\n   \tfloat spin = fBox(h - vec3(.0, 1.5, -1.3), \n                      vec3(.1, 1., .05));\n    spin -= cos(sin(c.x *.5));\n    //\n    shape.dist = max(body, -eye); // Difference\n    shape.dist = min(shape.dist, arm);\n    shape.dist = max(shape.dist, -mouth);\n    shape.dist = fOpUnionColumns(shape.dist, hat, .5, 3.);\n    shape.dist = min(shape.dist, spin);\n    shape.dist = fOpUnionColumns(shape.dist, pupil, .45, 5.);\n    //shape.dist = min(body, eye); // Union\n    //shape.dist = max(body, eye); // Intersect\n\n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape face = character(c);\n  return face;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., -5.);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n    scene.yx *= rot(iTime);\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.00001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3BWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 164, 186, 186, 253], [255, 255, 273, 273, 343], [346, 391, 439, 439, 513], [515, 515, 545, 545, 569], [571, 571, 591, 591, 626], [628, 664, 692, 692, 773], [777, 777, 820, 820, 863], [865, 865, 908, 908, 974], [976, 976, 1015, 1015, 1171], [1172, 1172, 1197, 1197, 1237], [1239, 1239, 1279, 1279, 1400], [1402, 1402, 1461, 1461, 2072], [2073, 2073, 2137, 2137, 2727], [2758, 2758, 2782, 2782, 4201], [4204, 4204, 4222, 4222, 4268], [4270, 4270, 4327, 4327, 4769]], "test": "error"}
{"id": "ll3BWM", "name": "Dodgy corkscrew", "author": "rlm72", "description": "An attempt at an SDF of a corkscrew", "tags": ["sdf"], "likes": 1, "viewed": 143, "published": "Public", "date": "1539789055", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Part 3 Challenges\n * - Make the camera move up and down while still pointing at the cube\n * - Make the camera roll (stay looking at the cube, and don't change the eye point)\n * - Make the camera zoom in and out\n */\n\nconst int MAX_MARCHING_STEPS = 1024;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.1415926535897932384626433832795;\n\n/**\n * Signed distance function for a cube centered at the origin\n * with width = height = length = 2.0\n */\nfloat cubeSDF(vec3 p) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 p) {\n    return length(p) - 5.0;\n}\n\nfloat torusSDF( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat myAtan(float z, float x) {\n    // return of (x, y) from 0 (inclusive) up to 2 pi\n    if (x > 0.0 && z >= 0.0) {\n        return atan(z, x);\n    } else if (x == 0.0 && z >= 0.0) {\n        return PI / 2.0;\n    } else if (x < 0.0 && z >= 0.0) {\n        return PI - atan(z, -x);\n    } else if (x > 0.0 && z < 0.0) {\n        return 2.0*PI - atan(-z, x);\n    } else if (x == 0.0 && z < 0.0) {\n        return 3.0 * PI / 2.0;\n    } else if (x < 0.0 && z < 0.0) {\n        return PI + atan(-z, -x);\n    }\n}\n\nfloat twistyTorusSDF(vec3 p, vec2 t) {\n    float shift = (myAtan(p.z, p.x)) / (2.0 * PI);\n    vec3 new_p = p;\n    new_p.y = mod(p.y, 5.0);\n    return torusSDF(new_p - vec3(0, shift * 5.0, 0), t);\n}\n\n\nfloat groundSDF(vec3 p, float level) {\n    return (p.y - level);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    return twistyTorusSDF(p, vec2(2.0, 0.5));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the eye to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += 0.1*dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n/**\nReturns a number to multiply the illumination by.\nk is softness of shadows\n*/\nfloat softShadowMarch(vec3 eye, vec3 marchingDirection, float start, float end, float k) {\n    float depth = start;\n    float res = 1.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn 0.0;\n        }\n         depth += 0.1*dist;\n        //res = min(res, k*dist/depth);\n        if (depth >= end) {\n            return res;\n        }\n    }\n    return res;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    float lightToPointDist = length(p - lightPos);\n    float res = softShadowMarch(lightPos, normalize(p - lightPos),\n                                EPSILON, lightToPointDist - 22.0*EPSILON, 50.0);\n\tres = 1.0;\n    \n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return res * lightIntensity * (k_d * dotLN);\n    }\n    return res * lightIntensity * (k_d * dotLN + 0.0 * k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(10.0 * sin(1.8*iTime),\n                          9.0,\n                          8.0 * cos(1.8*iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    /*\n    vec3 light2Pos = vec3(10.0 * sin(1.3 * iTime),\n                          15.0 * cos(1.3 * iTime),\n                          8.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);\n*/\n    \n    //vec3 light3Pos = vec3(0,1.0,0.0);\n    //vec3 light3Intensity = vec3(5, 1, 0);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                            //      light3Pos,\n                           //       light3Intensity); \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(27.0 * sin(0.5 * iTime), 14.0, 27.0 * cos(0.5 * iTime));\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 2.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(1.2, 1.2, 1.4);\n    vec3 K_d = vec3(0.8, 0.8, 0.8);\n    vec3 K_s = vec3(0.1, 0.1, 0.1);\n    float shininess = 2.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3BWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[402, 510, 533, 684, 1121], [1123, 1212, 1237, 1237, 1267], [1269, 1269, 1303, 1303, 1368], [1370, 1370, 1402, 1456, 1871], [1873, 1873, 1911, 1911, 2070], [2073, 2073, 2111, 2111, 2139], [2141, 2381, 2405, 2405, 2453], [2455, 2877, 2968, 2968, 3278], [3280, 3362, 3452, 3452, 3822], [3837, 4091, 4156, 4156, 4288], [4290, 4379, 4408, 4408, 4718], [4720, 5212, 5352, 5352, 6176], [6178, 6548, 6633, 6633, 7705], [7707, 8034, 8083, 8118, 8344], [8346, 8346, 8403, 8403, 9286]], "test": "error"}
{"id": "ll3Bzr", "name": "Numerous Digits", "author": "yx", "description": "Experiment.", "tags": ["2tweets", "ryojiikeda"], "likes": 9, "viewed": 559, "published": "Public API", "date": "1538412626", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define d(p,d) float((int[](480599,143911,476951,476999,350020,464711,464727,476228,481111,481095)[d]>>p.x+p.y*4)&1)\nvoid mainImage(out vec4 c,vec2 f){c+=d(ivec2(mod(f,vec2(4,6))),int(fract(sin(dot((floor(iTime*30.)*.17+floor(f/vec2(4,6))),vec2(12.9345,4.3742))*1301.156))*10.));}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3Bzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 151, 151, 280]], "test": "error"}
{"id": "ll3BzS", "name": "Breathing Mandelbrot.n", "author": "t3knomanser", "description": "Mandelbrot fractal wired to \"breathe\"", "tags": ["fractal", "mandelbrot"], "likes": 0, "viewed": 79, "published": "Public", "date": "1539983126", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERS 1000.\n#define RADIUS 256.\n#define SCALE 1./256.\n#define C vec2(0.004*sin(iTime*0.5), 0.001*cos(iTime*0.4))\n#define STEPS 5\n\nvec3 palette[STEPS];\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nfloat mandelbrot(vec2 st) {\n    float iter = 0., maxIter = ITERS;\n    vec2 s = st;\n    while ((st.x * st.x + st.y * st.y) < RADIUS && iter < maxIter) {\n        float x = st.x;\n        st.x = x * x - st.y * st.y + s.x;\n        st.y = 2.*x*st.y + s.y;\n        st += C;\n        iter += 1.;\n    }\n    return iter;\n}\n\nvoid buildPalette() {\n    palette[0] = vec3(0., 0.004, 0.0);\n    palette[1] = vec3(0.055, 0.227, 0.153);\n    palette[2] = vec3(0.173, 0.294, 0.075);\n    palette[3] = vec3(0.278, 0.318, 0.078);\n    palette[4] = vec3(0.49, 0.706, 0.612);\n}\n\nvec3 palletize(float c) {\n    float stp = 1.0/float(STEPS);\n    vec3 col = mix(palette[0], palette[1], smoothstep(0., stp, c));\n    for (int i = 1; i < STEPS; i++) {\n        float weight = smoothstep(stp*(float(i) + 1.), stp*(float(i)  + 2.), c);\n        col = mix(col, palette[i], weight);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    buildPalette();\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //start in the mandelbrot space\n\tuv.x *= 3.5;\n    uv.x -= 2.5;\n    uv.y *= 2.;\n    uv.y -= 1.;\n    //find your spot in the fractal\n    uv *= scale(vec2(SCALE, SCALE));\n    uv -= vec2(0.835, 0.203);\n\n    //draw it\n    float c = 1. - mandelbrot(uv) / ITERS;\n    vec3 col = palletize(c);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3BzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 184, 184, 247], [249, 249, 276, 276, 560], [562, 562, 583, 583, 799], [1117, 1117, 1174, 1174, 1635]], "test": "valid"}
{"id": "ll3fD8", "name": "Intersection of sphere and line", "author": "gaz", "description": "Intersection of sphere and line", "tags": ["3d"], "likes": 6, "viewed": 183, "published": "Public", "date": "1539354797", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\t\n}\n\nfloat deLine(vec3 p, vec3 v, vec3 c)\n{\n\treturn length(cross(p - c, normalize(v)))-0.05;\n}\n\nfloat dePoint(vec3 p, vec3 c)\n{\n\treturn length(p - c) -0.2;\n}\n\nfloat deCircle(vec3 p, vec3 c, vec3 n, float r)\n{\n\tp -= c;\n\treturn max(abs(dot(p, n))-0.01, abs(length(cross(p, n))-r))-0.05;\n}\n\n#define Info \\\n    vec3 axis = normalize(vec3(1,5,1));\\\n    vec3 ro = vec3(-1,sin(iTime), 8.0+4.0*sin(iTime));\\\n    vec3 rd = normalize(vec3(1,0,3));\\\n    vec3 o = vec3(0);\\\n    vec3 u = normalize(cross(ro,rd));\\\n    vec3 w = normalize(cross(u,rd));\\\n    float l = dot(ro,w);\\\n    float r =5.0;\\\n    vec3 v = w*l;\\\n    vec3 a = v -sqrt(r*r-l*l)*rd;\\\n    vec3 b = v +sqrt(r*r-l*l)*rd;\n\n#define V_axis(p) deLine(p,axis,o)\n#define V_ro(p) deLine(p,ro,o)\n#define V_rd(p) deLine(p,rd,ro)\n#define V_u(p) deLine(p,u,ro)\n#define V_w(p) deLine(p,w,o)\n#define P_o(p) dePoint(p,o)\n#define P_ro(p) dePoint(p,ro)\n#define P_v(p) dePoint(p,v)\n#define P_a(p) dePoint(p,a)\n#define P_b(p) dePoint(p,b)\n#define C_axis(p) deCircle(p,o,axis,r)\n#define C_a(p) deCircle(p,o,normalize(cross(a,axis)),r)\n#define C_b(p) deCircle(p,o,normalize(cross(b,axis)),r)\n\n#define Color(a,b) if (a(p)<0.01) return b;\n#define R vec3(1,0,0)\n#define G vec3(0,1,0)\n#define B vec3(0,0,1)\n\nvec3 doColor(vec3 p)\n{\n    Info\n\tColor(V_axis, R)\n\tColor(V_axis, G)\n\tColor(V_ro, G)\n\tColor(V_rd, vec3(1,0.5,0))\n\tColor(V_u, G)\n\tColor(V_w, G)\n\tColor(P_o, G)\n\tColor(P_ro, vec3(1))\n\tColor(P_v, B)\n\tColor(P_a, R)\n\tColor(P_b, R)\n\tColor(C_axis, B)\n\tColor(C_a, B)\n\tColor(C_b, B)\n\n\treturn vec3(1);\n}\n\n#define De(a) de = min(de, a(p)); \nfloat map(vec3 p)\n{\n    Info\n\tfloat de = 1.0;\n\tDe(V_axis)\n\tDe(V_ro)\n\tDe(V_rd)\n\tDe(V_u)\n\tDe(V_w)\n\tDe(P_o)\n\tDe(P_ro)\n\tDe(P_v)\n\tDe(P_a)\n\tDe(P_b)\n\tDe(C_axis)\n\tDe(C_a)\n\tDe(C_b)\n\treturn de;\n}\n\nmat3 lookat(vec3 eye, vec3 target, vec3 up)\n{\n    vec3 w = normalize(target-eye), u = normalize(cross(w,up));\n    return mat3(u,cross(u,w),w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 d = normalize(vec3((fragCoord * 2.0 - iResolution.xy) / iResolution.y,2));\n \tvec3 p = vec3(0,5,18);\n\tp.xz = rotate(iTime*0.5) * p.xz;\n\tvec3 ta = vec3(0);\n\td = lookat(p,ta,vec3(0,1,0)) * d;\n\tfloat t=0., x;\n\tvec3 col = vec3(0.2);\n\tfor (float i=1.; i>0.; i-=.01) \n  \t{\n\t\tt +=x =map(p);\n\t\tif(x < 0.01){\n\t\t\tcol = i*i*i*(1.0+doColor(p));\n\t\t\tbreak;\n\t\t}\n\t\tp+=d*x;\n\t}\n    col = pow(col, vec3(2));\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3fD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 72], [74, 74, 112, 112, 163], [165, 165, 196, 196, 226], [228, 228, 277, 277, 355], [1819, 1819, 1864, 1864, 1963], [1965, 1965, 2022, 2022, 2448]], "test": "valid"}
{"id": "ll3fzB", "name": "sin test 00", "author": "shi", "description": "-", "tags": ["outlands"], "likes": 0, "viewed": 40, "published": "Public", "date": "1540032990", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n//    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 col = vec3(uv.x,0.5-uv.y,0);\n    \n    if(uv.y>sin(iTime+uv.x)*0.5+0.5)\n    {\n        col.rgb=vec3(1.0,1.0,0.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3fzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 428]], "test": "valid"}
{"id": "llcBRr", "name": "linefuncs", "author": "t3knomanser", "description": "Simple line generating functions for use in another project", "tags": ["lines", "library"], "likes": 3, "viewed": 86, "published": "Public", "date": "1538416160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float line(vec2 uv, float m, float b, float thickness, float fuzz) {\n    float y = m * uv.x + b;\n    float d = thickness - distance(uv, vec2(uv.x, y));\n    d =  smoothstep(0., thickness, d);\n    if (uv.y >= y - thickness && uv.y <= y + thickness) {\n        return mix(1., d, fuzz);\n    }\n    return 0.;\n}\n\nfloat line(vec2 uv, float m, float b) {\n    return line(uv, m, b, iResolution.y / 100000., 0.);\n}\n\nfloat line(vec2 uv, float m, float b, float thickness) {\n    return line(uv, m, b, thickness, 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float v = 0.;\n    float slopMod = 20.0 * smoothstep(-1., 1., sin(iTime * 0.25));\n    for (float i = 0.; i < 250.; i++) {\n    \tv += line(uv, i / slopMod, 0., 2./iResolution.y, 1.);\n        v += line(uv, -i / slopMod, 1., 2./iResolution.y, 1.);\n    }\n    vec3 col = vec3(v);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llcBRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 68, 68, 304], [306, 306, 345, 345, 403], [405, 405, 461, 461, 505], [507, 507, 564, 614, 994]], "test": "valid"}
{"id": "llcBWN", "name": "Spinning Lines", "author": "t3knomanser", "description": "A simple rotating line demo. Again, just testing.", "tags": ["lines", "geometry", "sinusoidal"], "likes": 1, "viewed": 88, "published": "Public", "date": "1539632381", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat line(vec2 uv, float m, float b, float thickness, float fuzz) {\n    float y = m * uv.x + b;\n    float d = thickness - distance(uv, vec2(uv.x, y));\n    d =  smoothstep(0., thickness, d);\n    if (uv.y >= y - thickness && uv.y <= y + thickness) {\n        return mix(1., d, fuzz);\n    }\n    return 0.;\n}\n\nfloat line(vec2 uv, float m, float b) {\n    return line(uv, m, b, iResolution.y / 100000., 0.);\n}\n\nfloat line(vec2 uv, float m, float b, float thickness) {\n    return line(uv, m, b, thickness, 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv += vec2(-0.5, -0.5);\n    uv = rotate2d(iTime) * uv;\n    vec3 point = vec3(\n        line(uv, 0., 0., 1./iResolution.y, 0.25)\n    );\n    for (float i = -10.; i < 10.; i+=1.) {\n        uv += vec2(0., (1.0 / 1000.)*i);\n        uv *= rotate2d(sin(iTime*0.125*i));\n        point += vec3(\n            line(uv, 0., 0., 0.5/iResolution.y, 0.25)\n        );\n    }\n\n    // Output to screen\n    fragColor = vec4(point,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llcBWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 114], [116, 116, 184, 184, 420], [422, 422, 461, 461, 519], [521, 521, 577, 577, 621], [623, 623, 680, 730, 1191]], "test": "valid"}
{"id": "llcfR7", "name": "Distance to line segment", "author": "matonga", "description": "Distance to line segment", "tags": ["2d"], "likes": 6, "viewed": 173, "published": "Public", "date": "1539024754", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n\t*/\n    //vec2 p1 = vec2 (50, 50);\n    /*vec2 p1 = iMouse.xy;\n   \tvec2 p2 = vec2 (300, 80);*/\n    vec2 p1 = vec2 (.5 + .3 * cos (iTime * .5), .5 + .3 * sin (iTime * .7)) * iResolution.xy;\n   \tvec2 p2 = vec2 (.5 + .2 * cos (iTime * 1.1), .5 + .2 * sin (iTime * .9)) * iResolution.xy;\n    \n    vec4 colA = vec4(clamp (5.0 - length (fragCoord - p1), 0.0, 1.0));\n    vec4 colB = vec4(clamp (5.0 - length (fragCoord - p2), 0.0, 1.0));\n    \n    vec2 a_p1 = fragCoord - p1;\n    vec2 p2_p1 = p2 - p1;\n    float h = clamp (dot (a_p1, p2_p1) / dot (p2_p1, p2_p1), 0.0, 1.0);\n    float d = length (a_p1 - p2_p1 * h);\n    \n    vec4 colC = clamp (vec4(.5 - 5.0 * cos ((d - iTime * 10.0) * 3.1415926 / 20.0)), 0.0, 1.0) * vec4 (1.0, .73, .0, .0);\n    vec4 colD = vec4(clamp (2.5 - d, 0.0, 1.0));\n    \n    fragColor = max (max (colA, colB), max (colC, colD));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llcfR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 393, 1146]], "test": "valid"}
{"id": "llcfRf", "name": "Cone - intersection", "author": "iq", "description": "Intersection of a ray and a generic (oriented in any direction) capped cone. I got it down to a single square root and one division. Many rejections are actually sqrt/div free! Computes normals too, but naturally code simplifies even further if you don't.", "tags": ["3d", "raycast"], "likes": 21, "viewed": 2505, "published": "Public API", "date": "1540444715", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Intersection of a ray and a capped cone oriented in an arbitrary direction\n\n// List of ray-surface intersectors at https://www.shadertoy.com/playlist/l3dXRf\n//\n// and http://iquilezles.org/www/articles/intersectors/intersectors.htm\n\n\n// Other cone functions:\n//\n// Cone bbox:         https://www.shadertoy.com/view/WdjSRK\n// Cone distance:     https://www.shadertoy.com/view/tsSXzK\n// Cone intersection: https://www.shadertoy.com/view/llcfRf\n\n\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nvec4 iCappedCone( in vec3  ro, in vec3  rd, \n                  in vec3  pa, in vec3  pb, \n                  in float ra, in float rb )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    vec3  ob = ro - pb;\n    \n    float m0 = dot(ba,ba);\n    float m1 = dot(oa,ba);\n    float m2 = dot(ob,ba); \n    float m3 = dot(rd,ba);\n\n    //caps\n         if( m1<0.0 ) { if( dot2(oa*m3-rd*m1)<(ra*ra*m3*m3) ) return vec4(-m1/m3,-ba*inversesqrt(m0)); }\n    else if( m2>0.0 ) { if( dot2(ob*m3-rd*m2)<(rb*rb*m3*m3) ) return vec4(-m2/m3, ba*inversesqrt(m0)); }\n    \n    // body\n    float m4 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n    float rr = ra - rb;\n    float hy = m0 + rr*rr;\n    \n    float k2 = m0*m0    - m3*m3*hy;\n    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return vec4(-1.0);\n\n    float t = (-k1-sqrt(h))/k2;\n\n    float y = m1 + t*m3;\n    if( y>0.0 && y<m0 ) \n    {\n        return vec4(t, normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y));\n    }\n    \n    return vec4(-1.0);\n}\n\n#define AA 3\n\nvec3 pattern( in vec2 uv )\n{\n    vec3 col = vec3(0.6);\n    col += 0.4*smoothstep(-0.01,0.01,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        #if 1\n        vec3  pa = vec3(-0.1,-0.1,0.2);\n        vec3  pb = vec3( 0.4, 0.3,0.3);\n        float ra = 0.4;\n        float rb = 0.1;\n        #else\n        vec3  pa = 0.4*cos(iTime*vec3(1.0,1.3,0.8)+vec3(0.0,2.0,4.0));\n        vec3  pb = 0.4*cos(iTime*vec3(0.9,1.1,0.7)+vec3(1.0,3.0,6.0));\n        float ra = 0.2 + 0.1*sin(iTime*1.7+0.0);\n        float rb = 0.2 + 0.1*sin(iTime*1.8+2.0);\n        #endif\n        \n        // raytrace\n        vec4 tnor = iCappedCone( ro, rd, pa, pb, ra, rb );\n\n        float t = tnor.x;\n    \n        // shading/lighting\t\n        vec3 col = vec3(0.08)*(1.0-0.3*length(p)) + 0.02*rd.y;\n        if( t>0.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = tnor.yzw;\n            vec3 lig = normalize(vec3(0.7,0.6,0.3));\n            vec3 hal = normalize(-rd+lig);\n\t\t    float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n\t\t    float amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n            \n            vec3 w = normalize(pb-pa);\n            vec3 u = normalize(cross(w,vec3(0,0,1)));\n            vec3 v = normalize(cross(u,w) );\n            vec3 q = (pos-pa)*mat3(u,v,w);\n            col = pattern( vec2(16.0,64.0)*vec2(atan(q.y,q.x),q.z) );\n\n\t\t    col *= vec3(0.2,0.3,0.4)*amb + vec3(1.0,0.9,0.7)*dif;\n            \n            col += 0.4*pow(clamp(dot(hal,nor),0.0,1.0),12.0)*dif;\n\n        }\n\n        // gamma\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llcfRf.jpg", "access": "shaders20k", "license": "mit", "functions": [[1527, 1527, 1552, 1552, 1571], [1573, 1573, 1709, 1709, 2674], [2690, 2690, 2718, 2718, 2908]], "test": "valid"}
{"id": "lldBDn", "name": "Parthenon 2", "author": "dr2", "description": "  An alternative Parthenon, newly built.\n  Upgraded visuals and faster compilation.\n", "tags": ["reflection", "fire", "temple", "architecture"], "likes": 22, "viewed": 649, "published": "Public API", "date": "1539247587", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Parthenon 2\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  An alternative Parthenon, newly built.\n  Upgraded visuals and faster compilation.\n  Mouse overrides observer motion; mouse in lower box for day view; mouse in upper \n  box (left/right half) for exterior day/night views.\n*/\n\n#define AA  0   // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Noiseff (float p);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 wPt[10], qHit, fCylPos, sunDir;\nfloat tp[10], vel, dstFar, tCur, tCyc, fCylRad, fCylLen, flmFlkr, grDep, angHit;\nint idObj;\nbool isNt;\nconst int idBase = 1, idCol = 2, idColEnd = 3, idRoof = 4, idRoofV = 5, idGal = 6, idAltr = 7,\n   idLogs = 8, idCoal = 9, idPost = 10, idBall = 11, idMnt = 12;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat MountDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, r, h, s;\n  h = grDep;\n  q = p;\n  q.y -= - h;\n  r = 20. - 0.7 * q.y / h;\n  s = 0.2 * (Noisefv2 (4. * q.xz) - 1.);\n  d = 0.9 * max (SmoothMin (PrRoundCylDf (q.xzy, r * (1. + 0.1 * s), h + s, h + s),\n     PrCylDf (q.xzy, r + 0.5, 0.01), 0.5), 0.01 - q.y);\n  DMINQ (idMnt);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  vec2 cs;\n  float dMin, d, da, db, wr;\n  dMin = dstFar;\n  dMin = MountDf (p, dMin);\n  q = p;\n  d = PrBoxDf (q, vec3 (8.6, 0.101, 12.6));\n  q.y -= 0.3;\n  d = max (min (d, PrBoxDf (q, vec3 (8.2, 0.201, 12.2))),\n     - PrBoxDf (q, vec3 (2., 0.25, 6.)));\n  DMINQ (idBase);\n  q.y -= 5.52;\n  d = max (PrBoxDf (q, vec3 (7.5, 0.05, 11.5)),\n     - PrBoxDf (q, vec3 (2.5, 5., 6.5)));\n  q.xz = mod (q.xz + vec2 (1.), 2.) - 1.;\n  d = max (d, - PrBoxDf (q, vec3 (0.5, 5., 0.5)));\n  DMINQ (idGal);\n  q = p;  q.y -= 1.;\n  db = max (PrBoxDf (q, vec3 (8., 4.9, 12.)), - PrBox2Df (q.xz, vec2 (2., 6.)));\n  q = p;  q.xz = mod (q.xz, 2.) - 1.;  q.y -= 3.14;\n  wr = q.y / 2.36;\n  d = max (PrCylDf (q.xzy, 0.3 * (1.05 - 0.05 * wr * wr), 2.36), db);\n  DMINQ (idCol);\n  q = p;  q.xz = mod (q.xz, 2.) - 1.;  q.y = abs (q.y - 3.14) - 2.43;\n  d = PrCylDf (q.xzy, 0.4, 0.07);\n  q.y -= 0.14;\n  d = max (min (d, PrBoxDf (q, vec3 (0.5, 0.07, 0.5))), db);\n  DMINQ (idColEnd);\n  q = p;  q.x = abs (q.x) - 3.;  q.y -= 8.2;\n  q.xy = Rot2D (q.xy, 0.15 * pi);\n  d = PrBoxDf (q, vec3 (6., 0.07, 12.3));\n  q.x += 0.25;\n  q.xz = mod (q.xz, vec2 (1., 2.)) - vec2 (0.5, 1.);\n  d = max (d, - PrBox2Df (q.xz, vec2 (0.25, 0.5)));\n  DMINQ (idRoof);\n  q = p;  q.xz = abs (q.xz);  q -= vec3 (4.1, 7.68, 11.6);\n  d = PrBoxDf (q, vec3 (4.3, 1.9, 0.1));\n  q.xy = Rot2D (q.xy, 0.15 * pi);\n  q.xy -= vec2 (-0.4, -2.);\n  d = max (d, PrBoxDf (q, vec3 (4.3, 1.9, 0.1)));\n  q = p;  q.xz = abs (q.xz);  q -= vec3 (2.89, 7.7, 11.6);\n  da = PrBoxDf (q, vec3 (3.2, 1.4, 1.));\n  q.xy = Rot2D (q.xy, 0.15 * pi);\n  q.xy -= vec2 (-0.25, -1.5);\n  d = max (d, - max (da, PrBoxDf (q, vec3 (3.2, 1.4, 1.))));\n  DMINQ (idRoofV);\n  q = p;  q.y -= 7.7;  q.z = abs (q.z) - 11.6;\n  d = PrCylDf (q.xzy, 0.09, 1.4);\n  DMINQ (idRoofV);\n  q.y -= 0.4;\n  d = PrSphDf (q, 0.4);\n  DMINQ (idBall);\n  q = p;  q.xz = abs (q.xz);  q -= vec3 (8.5, 0.6, 12.5);\n  d = PrCylDf (q.xzy, 0.05, 0.5);\n  DMINQ (idPost);\n  q.y -= 0.7;\n  d = PrSphDf (q, 0.2);\n  DMINQ (idBall);\n  q = p;  q.y -= 1.5;\n  d = min (max (max (PrSphDf (q, 0.78), -0.01 + q.y), -0.3 - q.y),\n     PrCylDf ((q - vec3 (0., -0.7, 0.)).xzy, 0.15, 0.42));\n  DMINQ (idAltr);\n  qq = p;  qq.y -= fCylPos.y - fCylLen + 0.09;\n  d = PrCylDf (qq.xzy, fCylRad, 0.1);\n  if (d < 0.05) {\n    qq.xz = Rot2D (qq.xz, -0.5 * pi);\n    cs = sin (pi * vec2 (1.3, 0.8));\n    for (int j = 0; j < 5; j ++) {\n      qq.xz = Rot2Cs (qq.xz, cs);\n      q = qq;  q.x += 0.21;\n      d = PrRoundCylDf (q, 0.05 - 0.01 * sin (10. * pi * q.z), 0.02, 0.666);\n      DMINQ (idLogs);\n    }\n    q = p;  q.y -= fCylPos.y - fCylLen - 0.02;\n    d = PrCylDf (q.xzy, fCylRad- 0.03, 0.01);\n    DMINQ (idCoal);\n  } else dMin = min (dMin, d);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dLight)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dLight) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat BlkHit (vec3 ro, vec3 rd, vec3 blkSize)\n{\n  vec3 v, tm, tp, u;\n  float dn, df;\n  rd += 0.00001;\n  v = ro / rd;\n  tp = blkSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  return (df > 0. && dn < df) ? dn : dstFar;\n}\n\nvec2 CylHit (vec3 ro, vec3 rd, float cylRad, float cylHt)\n{\n  vec3 s;\n  float dCylIn, dCylOut, a, ai, b, w, ws, srdy;\n  dCylIn = dstFar;\n  dCylOut = dstFar;\n  rd += 0.00001;\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - cylRad * cylRad);\n  if (w > 0.) {\n    ws = sqrt (w);\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      ai =  1. / a;\n      dCylIn = (- b - ws) * ai;\n      dCylOut = (- b + ws) * ai;\n    }\n    if (a > 0.) s = ro + dCylIn * rd;\n    else s.y = cylHt;\n    if (abs (s.y) > cylHt) {\n      if (srdy * ro.y < - cylHt) {\n        dCylIn = - (srdy * ro.y + cylHt) / abs (rd.y);\n        if (length (ro.xz + dCylIn * rd.xz) > cylRad) dCylIn = dstFar;\n      } else dCylIn = dstFar;\n    }\n    if (dCylIn < dstFar) {\n      if (a > 0.) s = ro + dCylOut * rd;\n      else s.y = cylHt;\n      if (abs (s.y) > cylHt && srdy * ro.y < cylHt)\n         dCylOut = (- srdy * ro.y + cylHt) / abs (rd.y);\n    }\n  }\n  return vec2 (dCylIn, dCylOut);\n}\n\nfloat FlmAmp (vec3 ro, vec3 rd, vec2 dst)\n{\n  vec3 p, q;\n  float fh, fr, aSum, a, d;\n  const float ns = 24.;\n  p = ro + dst.x * rd;\n  d = dst.x + fCylRad / ns;\n  aSum = 0.;\n  for (float j = 0.; j < ns; j ++) {\n    p = ro + d * rd;\n    fr = 1. - length (p.xz) / fCylRad;\n    fh = 0.5 * (1. - p.y / fCylLen);\n    q = 2. * p;\n    q.xz = Rot2D (q.xz, 0.3 * q.y);\n    a = 1.1 * Fbm3 (q - vec3 (0., 4. * tCur, 0.));\n    q = 5. * p;\n    q.xz = Rot2D (q.xz, -0.4 * q.y);\n    a += 0.9 * Fbm3 (q - vec3 (0., 5. * tCur, 0.));\n    aSum += max (0.3 * fr * fr * fh * (a * a - 0.6), 0.);\n    q = 73. * p;\n    aSum += step (0.85, Fbm3 (q - vec3 (0., 16. * tCur, 0.))) * smoothstep (0.1, 0.2, fr) *\n       smoothstep (0.3, 0.4, fh);\n    d += fCylRad / ns;\n    if (d > dst.y || aSum > 1.) break;\n  }\n  return clamp (aSum, 0., 1.);\n}\n\nvec4 GrndCol (vec2 p)\n{\n  return vec4 (mix (vec3 (0.22, 0.2, 0.2), vec3 (0.2, 0.2, 0.22),\n     smoothstep (0.3, 0.7, Fbm2 (4. * p))), 0.);\n}\n\nvec4 ObjCol ()\n{\n  vec4 col;\n  vec2 vc;\n  vc = vec2 (0.);\n  if (idObj == idMnt) {\n    col = GrndCol (qHit.xz) * (1. + 0.2 * smoothstep (0.5, 0.9 * grDep, qHit.y));\n  } else if (idObj == idBase) {\n    col = vec4 (0.9, 0.9, 0.95, 0.1);\n    vc = vec2 (0.5, 32.);\n  } else if (idObj == idCol) {\n    col = vec4 (0.9, 0.9, 0.7, 0.1) * (1. - 0.3 * Fbm2 (128. * vec2 (qHit.y, 4. * angHit))) *\n     (0.6 + 0.4 * SmoothBump (0.02, 0.98, 0.02, mod (8. * qHit.y / 2.36, 1.)));\n  } else if (idObj == idColEnd) {\n    col = vec4 (0.9, 0.9, 0.7, 0.1);\n    vc = vec2 (0.3, 128.);\n  } else if (idObj == idRoof) {\n    col = vec4 (0.8, 0.3, 0.1, 0.1) *\n       (1. - 0.4 * SmoothBump (0.98, 1.02, 0.01, mod (qHit.z, 2.))) *\n       (1. - 0.4 * SmoothBump (0.48, 0.52, 0.01, mod (qHit.x, 1.)));\n  } else if (idObj == idRoofV) {\n    col = vec4 (0.8, 0.3, 0.1, 0.1);\n  } else if (idObj == idGal) {\n    col = vec4 (0.9, 0.9, 0.7, 0.1);\n    vc = vec2 (0.3, 128.);\n  } else if (idObj == idPost) {\n    col = vec4 (0.8, 0.1, 0.1, 0.1);\n  } else if (idObj == idAltr) {\n    col = vec4 (0.3, 0.3, 0.9, 0.2);\n    if (qHit.y < -0.4) col = mix (col, vec4 (0.5, 0., 0., -1.), SmoothBump (0.3, 0.6, 0.05,\n       0.5 + 0.5 * sin (2. * pi * (4. * qHit.y - 0.5 * tCur))));\n  } else if (idObj == idBall) {\n    col = vec4 (0.2, 0.5, 0.3, -1.);\n  }\n  if (vc.x > 0.) col *= 1. - vc.x * Fbm3 (vc.y * qHit);\n  return col;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, rds, mDir, vn, p;\n  float mRad, bs, ts, ds, fd, att, attSum, d, sd;\n  if (isNt) {\n    mDir = normalize (vec3 (0., 0.04, -1.));\n    mRad = 0.02;\n    col = vec3 (0.02, 0.02, 0.04) + vec3 (0.06, 0.04, 0.02) *\n       pow (clamp (dot (rd, mDir), 0., 1.), 16.);\n    bs = dot (rd, mDir);\n    ts = bs * bs - dot (mDir, mDir) + mRad * mRad;\n    if (ts > 0.) {\n      ts = bs - sqrt (ts);\n      if (ts > 0.) {\n        vn = normalize ((ts * rd - mDir) / mRad);\n        col += 0.8 * vec3 (1., 0.9, 0.5) * clamp (dot (vec3 (-0.77, 0.4, 0.5), vn) *\n           (1. - 0.3 * Noisefv3 (4. * vn)), 0., 1.);\n      }\n    }\n    if (ts < 0.) {\n      rds = floor (2000. * rd);\n      rds = 0.00015 * rds + 0.1 * Noisefv3 (0.0005 * rds.yzx);\n      for (int j = 0; j < 19; j ++) rds = abs (rds) / dot (rds, rds) - 0.9;\n      col += 0.5 * smoothstep (0.01, 0.04, rd.y) * vec3 (0.8, 0.8, 0.6) *\n         min (1., 0.5e-3 * pow (min (6., length (rds)), 5.));\n    }\n  } else {\n    p = ro + rd * (200. - ro.y) / rd.y;\n    ds = 0.1 * sqrt (length (ro - p));\n    fd = 0.001 / (smoothstep (0., 10., ds) + 0.1);\n    p.xz *= fd;\n    p.xz += 0.05 * tCur;\n    p *= 3.;\n    att = Fbm2 (p.xz);\n    attSum = att;\n    fd *= 3.;\n    d = fd;\n    ds *= fd;\n    for (int j = 0; j < 4; j ++) {\n      attSum += Fbm2 (p.xz + d * sunDir.xz);\n      d += ds;\n    }\n    sd = clamp (dot (sunDir, rd), 0., 1.);\n    col = mix (vec3 (0.5, 0.75, 1.), mix (vec3 (0.7, 1., 1.), vec3 (1., 0.4, 0.1),\n       0.25 + 0.75 * sd), exp (-2. * (3. - sd) * max (rd.y - 0.1, 0.))) +\n       0.3 * (vec3 (1., 0.4, 0.2) * pow (sd, 256.) + vec3 (1., 0.8, 0.7) * pow (sd, 1024.));\n    attSum = 1. - smoothstep (1., 9., attSum);\n    col = mix (vec3 (0.4, 0., 0.2), mix (col, vec3 (0.2),\n       att * (0.001 + 0.999 * smoothstep (0.001, 0.004, rd.y))), attSum) +\n       vec3 (1., 0.4, 0.) * pow (attSum * att, 4.) * (pow (sd, 8.) + 0.5);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 row, rdw, rdo, foVec, col, vn, vnw;\n  vec2 dstFlm, vf;\n  float dstObj, dstWat, dstGrnd, fIntens, lDist, sh, a, f;\n  int idObjF;\n  bool flmRefl, objRefl, hideFlm, ltSun;\n  grDep = 3.;\n  fCylPos = vec3 (0., 3.53, 0.);\n  fCylRad = 0.8;\n  fCylLen = 2.;\n  dstFlm = CylHit (ro - fCylPos, rd, fCylRad, fCylLen);\n  dstWat = BlkHit (ro - vec3 (0., 0.4, 0.), rd, vec3 (2., 0.01, 6.));\n  row = ro + dstWat * rd;\n  vnw = VaryNf (0.4 * row + 0.1 * tCur, vec3 (0., 1., 0.), 0.1);\n  flmRefl = false;\n  if (dstWat < min (dstFlm.x, dstFar)) {\n    rdw = reflect (rd, vnw);\n    row += 0.01 * rdw;\n    dstFlm = CylHit (row - fCylPos, rdw, fCylRad, fCylLen);\n    flmRefl = true;\n  } else {\n    row = ro;\n    rdw = rd;\n  }\n  fIntens = (dstFlm.x < dstFar) ? FlmAmp (row - fCylPos, rdw, dstFlm) : 0.;\n  flmFlkr = Noiseff (tCur * 64.);\n  dstObj = ObjRay (ro, rd);\n  objRefl = false;\n  rdo = rd;\n  if (dstWat < min (dstObj, dstFar)) {\n    ro += dstWat * rd;\n    rd = reflect (rd, vnw);\n    dstObj = ObjRay (ro, rd);\n    objRefl = true;\n  }\n  idObjF = idObj;\n  ltSun = false;\n  sh = 1.;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idCol) {\n      angHit = atan (qHit.z, - qHit.x) / (2. * pi);\n      vn.xz = Rot2D (vn.xz, -0.15 * pi * sin (pi * (0.5 - mod (12. * (angHit + 0.5), 1.))));\n    }\n    vf = vec2 (0.);\n    if (idObj == idCol || idObj == idColEnd) vf = vec2 (16., 0.3);\n    else if (idObj == idAltr) vf = vec2 (8., 1.);\n    else if (idObj == idBase) vf = vec2 (16., 1.);\n    else if (idObj == idRoof) vf = vec2 (32., 0.5);\n    else if (idObj == idMnt) vf = mix (vec2 (4., 2.), vec2 (16., 4.), smoothstep (0., 0.05, qHit.y));\n    if (vf.x > 0.) vn = VaryNf (vf.x * qHit, vn, vf.y);\n    if (idObj == idLogs || idObj == idCoal) {\n       f = clamp (1.2 * Fbm3 ((idObj == idLogs) ? 32. * vec3 (qHit.z,\n          atan (qHit.y, - qHit.x) / (2. * pi), 2. * length (qHit.xy) - 0.03 * tCur) :\n          vec3 (64. * qHit.xz, qHit.y + 0.5 * tCur).xzy) - 0.2, 0.1, 1.);\n       col = (idObj == idLogs) ? vec3 (1., 0.7 * f, 0.3 * f * f) * (0.5 +\n          0.5 * max (- dot (rd, VaryNf (4. * qHit, vn, 1.)), 0.)) *\n          (1. - 0.5 * smoothstep (0.5, 0.666, abs (qHit.z))) :\n          f * vec3 (1., 0.2, 0.1) * (1. - 0.5 * pow (length (qHit.xz) / fCylRad, 4.));\n       col = min (3. * f * col * (1. + 0.1 * flmFlkr), 1.);\n    } else {\n      col4 = ObjCol ();\n      if (col4.a < 0.) {\n        col = col4.rgb * (0.2 + 0.8 * max (- dot (rd, vn), 0.));\n      } else {\n        if (isNt) {\n          foVec = fCylPos - ro;\n          lDist = length (foVec);\n          foVec /= lDist;\n        }\n        sh = ObjSShadow (ro, (isNt ? foVec : sunDir), (isNt ? lDist : dstFar));\n        if (isNt) {\n          f = (0.3 + 0.7 * smoothstep (0., 0.05, - dot (rd, vn))) * max (dot (vn, foVec), 0.);\n          col = col4.rgb * (0.05 + 0.15 * f + 5. * sh * f * (0.6 + 0.4 * flmFlkr) *\n             pow (lDist, -1.5) * vec3 (1., 0.3, 0.2));\n        } else ltSun = true;\n      }\n    }\n  } else if (rd.y < 0.) {\n    if (! isNt) sh = ObjSShadow (ro - ((ro.y + grDep)) / rd.y * rd, sunDir, dstFar);\n    dstGrnd = - (ro.y + grDep) / rd.y;\n    ro += dstGrnd * rd;\n    vn = VaryNf (4. * ro, vec3 (0., 1., 0.), 2. * (1. - smoothstep (0.5, 1., dstGrnd / dstFar)));\n    col4 = GrndCol (ro.xz);\n    if (isNt) col4 *= 0.1;\n    ltSun = true;\n  } else {\n    a = atan (rd.x, - rd.z);\n    if (rd.y < 0.02 * Fbm1 (32. * a) + 0.005) {\n      col = mix (vec3 (0.1, 0.1, 0.11), vec3 (0.2, 0.1, 0.),\n         0.5 + 0.5 * dot (rd, - normalize (vec3 (sunDir.xz, 0.).xzy))) *\n         (1. - 0.3 * Fbm2 (128. * vec2 (a, rd.y)));\n      if (isNt) col*= 0.1;\n    } else col = SkyCol (ro, rd);\n  }\n  if (ltSun) {\n    col = col4.rgb * (0.1 + 0.1 * max (dot (vn, - normalize (vec3 (sunDir.xz, 0.).xzy)), 0.) +\n       0.1 * max (vn.y, 0.) + 0.8 * sh * max (dot (sunDir, vn), 0.)) +\n       col4.a * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    col *= vec3 (1., 0.9, 0.8);\n  }\n  hideFlm = (dstObj < dstFar && idObjF == idAltr);\n  if (flmRefl == objRefl) hideFlm = hideFlm || (dstObj < dstFlm.x);\n  else hideFlm = hideFlm || (objRefl ? (dstWat < dstFlm.x) : (dstObj < dstWat));\n  if (! hideFlm) col = mix (col, mix (vec3 (1., 0.2, 0.2), vec3 (0.8, 0.6, 0.2),\n     smoothstep (0.5, 0.8, fIntens)), fIntens);\n  if (objRefl) col = mix (col, max (- dot (rdo, VaryNf (0.4 * row + 0.1 * tCur,\n     vec3 (0., 1., 0.), 0.5)), 0.) * vec3 (0., 0.2, 0.8), 0.15);\n  return col;\n}\n\nvoid TrackInit ()\n{\n  wPt[0] = vec3 (0., 3., -16.);\n  wPt[1] = vec3 (0., 3., -10.);\n  wPt[2] = vec3 (-0.5, 3., -6.2);\n  wPt[3] = vec3 (-2.6, 3., -6.2);\n  wPt[4] = vec3 (-2.6, 3., 8.1);\n  wPt[5] = wPt[4] * vec3 (-1., 1., 1.);\n  wPt[6] = wPt[3] * vec3 (-1., 1., 1.);\n  wPt[7] = wPt[2];\n  wPt[8] = wPt[1];\n  wPt[9] = wPt[0];\n  tp[0]  = 0.;\n  for (int j = 0; j < 9; j ++) tp[j + 1] = tp[j] + length (wPt[j + 1] - wPt[j]); \n  vel = 0.5;\n  tCyc = tp[9] / vel;\n}\n\nvec3 TrackPath (float t)\n{\n  vec4 va, vb;\n  vec3 ro;\n  float tVu, s;\n  int jVu;\n  tVu = mod (t, tCyc) * vel;\n  for (int j = 0; j < 9; j ++) {\n    if (tVu < tp[j + 1]) {\n      va = vec4 (wPt[j], tp[j]);\n      vb = vec4 (wPt[j + 1], tp[j + 1]);\n      jVu = j;\n      break;\n    }\n  }\n  s = (tVu - va.w) / (vb.w - va.w);\n  ro = mix (va.xyz, vb.xyz, s);\n  if (jVu == 3 || jVu == 5) ro.y += SmoothBump (0.2, 0.8, 0.1, s);\n  return ro;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, u, col;\n  vec2 canvas, uv, ori, ca, sa, mMid[2], ut[2], mSize;\n  float el, az, asp, zmFac, hLkAt, vuId, regId;\n  bool vuTrk;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  isNt = true;\n  vuTrk = true;\n  asp = canvas.x / canvas.y;\n  mSize = (1./6.) * vec2 (asp, 1.);\n  mMid[0] = vec2 (asp, 1. - mSize.y) * vec2 (1. - mSize.y, -1.);\n  mMid[1] = vec2 (asp, -1. + mSize.y) * vec2 (1. - mSize.y, -1.);\n  ut[0] = abs (uv - mMid[0]) - mSize;\n  ut[1] = abs (uv - mMid[1]) - mSize;\n  vuId = 0.;\n  if (max (ut[0].x, ut[0].y) < 0.) {\n    uv = (uv - mMid[0]) / mSize.y;\n    isNt = ! isNt;\n    vuId = 1.;\n  } else if (max (ut[1].x, ut[1].y) < 0.) {\n    uv = (uv - mMid[1]) / mSize.y;\n    vuTrk = false;\n    vuId = 2.;\n  }\n  regId = 0.;\n  if (min (mPtr.x, - mPtr.y) > 0.5 - mSize.y) regId = 1.;\n  else if (min (mPtr.x, mPtr.y) > 0.5 - mSize.y) regId = 2.;\n  if (mPtr.z > 0. && regId == 2.) {\n    vuTrk = (vuId == 1.);\n    isNt = (vuId == 2.);\n    if (mPtr.x > 0.5 - 0.5 * mSize.y) isNt = ! isNt;\n  } else {\n    if (vuId == 2.) isNt = false;\n  }\n  if (mPtr.z > 0. && regId == 1.) isNt = ! isNt;\n  TrackInit ();\n  if (vuTrk) {\n    hLkAt = 3.;\n    zmFac = 1.2;\n    if (mPtr.z > 0. && regId == 0.) {\n      ro = TrackPath (tCyc * (mPtr.x + 0.5));\n      hLkAt += 5. * mPtr.y;\n    } else {\n      ro = 0.5 * (TrackPath (tCur + 0.2) + TrackPath (tCur - 0.2));\n    }\n    vd = normalize (vec3 (0., hLkAt, 0.) - ro);\n    u = - vd.y * vd;\n    vuMat = mat3 (vec3 (vd.z, 0., - vd.x) / sqrt (1. - vd.y * vd.y),\n       vec3 (u.x, 1. + u.y, u.z) / sqrt (1. - vd.y * vd.y), vd);\n  } else {\n    az = 0.1 * pi * (floor (0.3 * tCur) + smoothstep (0.9, 1., mod (0.3 * tCur, 1.)));\n    el = -0.02 * pi;\n    el = clamp (el, -0.4 * pi, 0. * pi);\n    ori = vec2 (el, az);\n    ca = cos (ori);\n    sa = sin (ori);\n    vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n            mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n    ro = vuMat * vec3 (0., 1., -40.);\n    zmFac = 2.7;\n  }\n  sunDir = normalize (vec3 (1., 0.3, 1.));\n  dstFar = 100.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  for (int k = 0; k < 2; k ++) {\n    if (max (ut[k].x, ut[k].y) < 0. && min (abs (ut[k].x), abs (ut[k].y)) * canvas.y < 2.)\n       col = vec3 (0.2, 0.2, 0.1);\n  }\n  fragColor = vec4 (pow (clamp (col, 0., 1.), vec3 (0.8)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldBDn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1327, 1327, 1363, 1363, 1671], [1673, 1673, 1695, 1695, 4398], [4400, 4400, 4433, 4433, 4610], [4612, 4612, 4633, 4633, 4833], [4835, 4835, 4886, 4886, 5121], [5123, 5123, 5170, 5170, 5413], [5415, 5415, 5474, 5474, 6398], [6400, 6400, 6443, 6443, 7214], [7216, 7216, 7239, 7239, 7356], [7358, 7358, 7374, 7374, 8734], [8736, 8736, 8768, 8768, 10658], [10660, 10660, 10695, 10695, 15156], [15158, 15158, 15177, 15177, 15613], [15615, 15615, 15641, 15641, 16045], [16047, 16047, 16103, 16103, 18829], [18831, 18831, 18863, 18863, 18963], [18965, 18965, 18998, 18998, 19087], [19089, 19089, 19122, 19122, 19149], [19151, 19151, 19193, 19193, 19244], [19246, 19246, 19303, 19303, 19467], [19469, 19469, 19514, 19514, 19617], [19619, 19619, 19676, 19676, 19759], [19761, 19761, 19791, 19791, 19904], [19906, 19906, 19937, 19937, 20001], [20035, 20035, 20059, 20059, 20112], [20114, 20114, 20138, 20138, 20268], [20270, 20270, 20294, 20294, 20514], [20516, 20516, 20541, 20541, 20687], [20689, 20689, 20714, 20714, 20900], [20902, 20902, 20927, 20927, 21152], [21154, 21154, 21176, 21176, 21330], [21332, 21332, 21353, 21353, 21508], [21510, 21510, 21531, 21531, 21686], [21688, 21688, 21717, 21717, 21929], [21931, 21931, 21970, 21970, 22150]], "test": "error"}
{"id": "lldBRj", "name": "Polka polka dots", "author": "Vizalkar", "description": "Basic polka dots", "tags": ["dots"], "likes": 3, "viewed": 224, "published": "Public", "date": "1540319801", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define brickColor(t) palette(t, vec3(.5), vec3(.5), vec3(1.), vec3(0.00, 0.33, 0.67))\n\n\nvec3 palette (in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec2 brickTile(vec2 _st, float _zoom){\n    _st *= _zoom;\n\n    // Here is where the offset is happening\n    _st.x += 2.*(step(1., mod(_st.y,2.0))-0.500) * ( fract(iTime)) * step(1.,mod(iTime,2.));\n    \n    _st.y += 2.*(step(1., mod(_st.x,2.0))-0.500) * ( fract(iTime+1.)) * step(1.,mod(iTime+1.,2.));\n\t\n    return fract(_st);\n}\n\nfloat box(vec2 _st, vec2 _size){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 uv = smoothstep(_size,_size+vec2(1e-4),_st);\n    uv *= smoothstep(_size,_size+vec2(1e-4),vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nfloat circle (vec2 _st, float radius)\n{\t_st -= 0.5;\n\treturn 1.-smoothstep(radius, radius*1.1,dot(_st,_st)*4.);    \n}\n\nfloat saw (in float t)\n{\n    return\n    fract(t*step(1., mod(t,2.))\n    +\n    (1.- t*step(1., mod(t+1.,2.))));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 _st = fragCoord/iResolution.xy;\n    vec3 color = vec3(0.0);\n\n    _st = _st*2. -1.;\n    \n    _st.x *= iResolution.x/iResolution.y;\n    \n    // Apply the brick tiling\n    vec2 st = brickTile(_st,5.0 + 2.*saw(iTime/50.));\n     \n    color = circle(st, 0.4 + 0.2*sin(iTime*6.)) * 0.7 *(vec3(.7) + brickColor(iTime/5. + _st.x)*0.4);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldBRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 206, 206, 249], [251, 251, 289, 289, 577], [579, 579, 611, 611, 782], [784, 784, 823, 823, 900], [902, 902, 926, 926, 1014], [1016, 1016, 1069, 1069, 1441]], "test": "valid"}
{"id": "lldBRn", "name": "Noise Functions", "author": "sujay", "description": "collection of noise functions", "tags": ["noise"], "likes": 4, "viewed": 763, "published": "Public", "date": "1538490506", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise1d(float n){\n    return fract(cos(n*89.42)*343.42);\n}\nfloat noise2d(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(1.0,73))) * 43758.5453);\n}\n\nvec2 hash2( vec2 p )\n{\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*sin(iTime);\n\n    vec3 col = vec3(noise2d(uv));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldBRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 64], [65, 65, 88, 88, 150], [152, 152, 174, 174, 267], [269, 269, 326, 376, 508]], "test": "valid"}
{"id": "lldBzX", "name": "Environment- Fantasy Highway", "author": "rlarp", "description": "Environment. A highway that has been heavily tampered with. ", "tags": ["color", "distance", "environment", "functions", "broken", "signed", "highway"], "likes": 6, "viewed": 113, "published": "Public", "date": "1540514448", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Shape{\n  float dist;\n  vec4 color;\n};\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n\nfloat fOpEngrave(float a, float b, float r) {\n\treturn max(a, (a + r - abs(b))*sqrt(0.5));\n}\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2.* s)) - s)));\n}\n\n// Shapes --------\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n//=======================\n\nShape environment(vec3 c){\n  Shape shape;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n    \n  vec3 g = c; // Ground\n  vec3 ph = c; // Placeholder\n  vec3 w = c; // Blob Walls\n  vec3 s = c; // Lamp Stand\n  vec3 a = c; // Lamp\n  vec3 h = c; // Holes\n  vec3 as = c; // Arch Stand\n  vec3 ar = c; // Arch\n  vec3 sig = c; // Sign\n  vec3 ab = c; // Arrow Base \n  vec3 ah = c; // Arrow Head \n  \n\n  // Ground\n  vec4 gColor = vec4(0.8, 1.0, 0.4, 1.0); \n  pMod1(g.z, 1.); \n  float ground = fBox(g+vec3(0.,1.8,0.4), vec3(4.5, 0.5, 3.)); \n  \n  // PlaceHolder\n  vec4 pColor = vec4(0.,0.,0.,0.); \n  float placeHolder = fBox(ph+vec3(2.,2. ,4.), vec3(3., 0., 3.)); \n   \n     \n  // Blob Walls \n  vec4 wColor = vec4(1., 0.1, 0.2, 1.0); \n  w.x = abs(w.x) - 7.;\n  pMod1(w.y, -1.); \n  pMod1(w.z, 4.); \n  float wall = fSphere(w+vec3(2.5,0.5,-0.5), 0.4); \n  wall = fOpPipe(ground, wall, 2.); \n    \n  // Lamp Stand\n  vec4 sColor = vec4(1., 1., 1., 1.); \n  s.x = abs(s.x) - 2.3; \n  //s.z = abs(s.z) - 4.; \n  pMod1(s.z, 16.); \n  float stand = fBox(s+vec3(0., 0., -1.), vec3(0.2, 1.5, 0.2)); \n    \n  // Lamp\n  vec4 aColor = vec4(1., 1., 0., 1.); \n  pMod1(a.z, 16.); \n  float lamp = fBox(a+vec3(0., -1.3, -1.), vec3(2., 0.2, 0.2)); \n  lamp = fOpPipe(stand, lamp, .3); \n    \n  // Arch Stand\n  vec4 asColor = vec4(0., sin(iTime), 1., 1.); \n  as.x = abs(as.x) - 2.3; \n  pMod1(as.z, 16.); \n  float aStand = fBox(as+vec3(0.,0., -7.5), vec3(0.2, 1.5, 0.2)); \n    \n  // Arch\n  vec4 arColor = vec4(0., sin(iTime), 1., 1.); \n  pMod1(ar.z, 16.); \n  float arch = fBox(ar+vec3(-0.2, -1.3, -7.5), vec3(2.3, 0.2, 0.2)); \n    \n  // Holes\n  vec4 hColor = vec4(1.0, 0., 1., 1.); \n  pMod1(h.z, 4.); \n  float hole = fSphere(h+vec3(0.,1.8, 0.), 0.5); \n    \n  // Sign \n  pMod1(sig.z, 16.); \n  float signn = fBox(sig+vec3(0., -1.3, -7.4), vec3(1.25, 0.75, 0.2)); \n\n  // Arrow \n  vec4 abColor = vec4(1., 0.5, 0.5, 1.); \n  vec4 ahColor = vec4(1., 0.5, 0.5, 1.); \n  pMod1(ab.z, 16.);\n  pMod1(ah.z, 16.); \n  float arrowBase = fBox(ab+vec3(0., -1., -7.3), vec3(0.2, 0.3, 0.2));\n  float arrowHead = sdTriPrism(ah+vec3(0., -1.3, -7.2), vec2(0.4, .1));\n    \n  ground = fOpUnionColumns(ground, wall, 1.3, 4.);    \n  ground = fOpEngrave(ground, hole, 0.5); \n                          \n  shape.dist = max(ground, -placeHolder); \n  shape.dist = min(shape.dist, wall); \n  shape.dist = min(shape.dist, stand); \n  shape.dist = min(shape.dist, lamp); \n  shape.dist = min(shape.dist, hole); \n  shape.dist = min(shape.dist, aStand); \n  shape.dist = min(shape.dist, arch); \n  shape.dist = min(shape.dist, signn);\n  shape.dist = min(shape.dist, arrowBase); \n  shape.dist = min(shape.dist, arrowHead);\n    \n  shape.color = mix(gColor, pColor, mixColors(placeHolder, ground, 0.0));  \n  shape.color = mix(shape.color, wColor, mixColors(wall, shape.dist, 1.0));\n  shape.color = mix(shape.color, sColor, mixColors(stand, shape.dist, 0.0));\n  shape.color = mix(shape.color, aColor, mixColors(lamp, shape.dist, 0.1)); \n  shape.color = mix(shape.color, hColor, mixColors(hole, shape.dist, 0.1)); \n  shape.color = mix(shape.color, arColor, mixColors(arch, shape.dist, 0.1)); \n  shape.color = mix(shape.color, asColor, mixColors(aStand, shape.dist, 0.1)); \n  shape.color = mix(shape.color, abColor, mixColors(arrowBase, shape.dist, 0.1));\n  shape.color = mix(shape.color, ahColor, mixColors(arrowHead, shape.dist, 0.1)); \n    \n  return shape; \n}\n\n\nShape map(vec3 c){\n  Shape enviro = environment(c);\n  return enviro;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n \n  vec3 cam = vec3(0., 0., iTime*3.);\n  cam.xy *= rot(radians(90.));\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  //  scene.yx *= rot(iTime);\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.0001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldBzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 123, 145, 145, 212], [214, 214, 232, 232, 302], [304, 304, 324, 324, 359], [361, 361, 386, 386, 426], [429, 429, 474, 474, 520], [522, 522, 565, 565, 608], [610, 610, 653, 653, 719], [721, 721, 754, 754, 780], [783, 783, 823, 823, 944], [946, 946, 1005, 1005, 1616], [1618, 1618, 1676, 1676, 1785], [1807, 1843, 1871, 1871, 1952], [1954, 1954, 1996, 1996, 2030], [2032, 2032, 2064, 2064, 2089], [2091, 2091, 2127, 2127, 2214], [2243, 2243, 2269, 2269, 5643], [5646, 5646, 5664, 5664, 5716], [5718, 5718, 5775, 5775, 6252]], "test": "error"}
{"id": "lldfDr", "name": "truchet portals", "author": "abje", "description": "A truchet shader with portals.\nIt has portals that move you 2 truchet cells forward in the portals direction.\nIt starts to reverse after 125 seconds.\nThere are some bugs that i need to fix.", "tags": ["3d", "raymarching", "voxels", "truchet"], "likes": 19, "viewed": 766, "published": "Public API", "date": "1539276598", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n#define dir3(num) vec3(equal(abs(dir),vec3(num)))\n\n#define dot2(p) dot(p,p)\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n#define pi acos(-1.0) //3.14\n#define FAR 20.0      //raymarching and fog max distance\n#define portals 0.22   //portal amount, from 0.0 to 1.0\n\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash31(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.x + p3.y)*p3.z);\n}\n\nfloat mid(vec3 p) {\n    //if(var3)\n    p = min(p,p.yzx);\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat torus(vec3 p, vec2 r) {//creates 4 toruses\n    return length(vec2(abs(abs(length(p.xy)-r.x)-0.05),abs(p.z)-0.05))-r.y;\n}\n\nfloat map(vec3 p) {\n    \n    vec3 p2 = mod(p,2.0)-1.0;\n    vec3 floorpos = floor(p*0.5);\n    float len = 1e10;\n    \n    //the truchet flipping\n    vec3 flipping = floor(hash33(floorpos)+0.5)*2.0-1.0;\n    \n    //actually flipping the truchet\n    vec3 p3 = p2*flipping;\n    \n    //positions relative to truchet centers\n    mat3 truchet = mat3(\n        vec3(+p3.yz+vec2(-1.0, 1.0),p3.x),\n        vec3(+p3.zx+vec2(-1.0, 1.0),p3.y),\n        vec3(+p3.yx+vec2( 1.0,-1.0),p3.z)\n    );\n    \n    //finding distance to truchet\n    len = min(min(\n        torus(truchet[0],vec2(1.0,0.01)),\n        torus(truchet[1],vec2(1.0,0.01))),\n        torus(truchet[2],vec2(1.0,0.01)));\n    \n    return len;\n}\n\n//normal calculation\nvec3 findnormal(vec3 p, float len) {\n    const vec2 eps = vec2(0.01,0.0);\n    \n    return normalize(vec3(\n        len-map(p-eps.xyy),\n        len-map(p-eps.yxy),\n        len-map(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 floorpos = vec3(0.0,0.0,0.0);\n    vec3 pos = vec3(1.0,1.0,0.0);\n    vec3 dir = vec3(3.0,2.0,1.0);\n    int num = 2;\n    float time = abs(mod(iTime*0.4+50.0,100.0)-50.0);\n    for (float i = 0.0; i <= floor(time); i++) {\n        \n        pos += dir*dir3(1);\n        \n    \tvec3 flipping = floor(hash33(floorpos)+0.5)*2.0-1.0; //the truchet flipping\n        \n        dir *= flipping;\n        \n        int num2 = (num-int(dot(dir,dir3(1)))+3)%3;\n        float back = dir[num2];\n        dir[num2] = dir[num];\n        dir[num] = -back;\n        num = num2;\n        \n        dir *= flipping;\n        \n        vec3 portalpos = floorpos+dir*dir3(1)*0.5;\n        if (hash31(portalpos) >= portals) {\n            portalpos += dir*dir3(1)*2.0;\n        }\n        if (hash31(portalpos) < portals) {\n            floorpos += dir*dir3(1)*2.0;\n        \tpos += dir*dir3(1)*4.0;\n        }\n        floorpos += dir*dir3(1);\n        pos += dir*dir3(1);\n    }\n\t\n    vec3 flipping = floor(hash33(floorpos)+0.5)*2.0-1.0; //the truchet flipping\n    vec3 dir2 = dir;\n    \n    dir *= flipping;\n    \n    int num2 = (num-int(dot(dir,dir3(1)))+3)%3;\n    float back = dir[num2];\n    dir[num2] = dir[num];\n    dir[num] = -back;\n    num = num2;\n    \n    dir *= flipping;\n\t\n    //animation\n    pos += dir2*vec3(equal(abs(dir2),vec3(1.0)))*(sin(fract(time)*3.14*0.5));\n    pos += dir*dir3(1)*(1.0-cos(fract(time)*3.14*0.5));\n    \n    //normal pointing towards where the camera moves, would be nice if the camera was looking in that direction\n    vec3 forward = dir2*vec3(equal(abs(dir2),vec3(1.0)))*cos(fract(time)*3.14*0.5)+dir*dir3(1)*sin(fract(time)*3.14*0.5);\n    \n    /*\n    mat3 rotation = mat3(\n        vec3(0.0),\n        vec3(0.0),\n        vec3(0.0));\n    rotation[2] = forward;\n    rotation[1] = normalize(cross(forward,vec3(1)));\n    rotation[0] = cross(rotation[1],forward);\n    */\n    \n    mat3 rotation = mat3(\n        vec3(0.0),\n        vec3(0.0),\n        vec3(0.0));\n    \n    vec2 t = vec2(cos(fract(time)*3.14*0.5),sin(fract(time)*3.14*0.5));\n\trotation[2] = normalize(dir2*vec3(equal(abs(dir2),vec3(1)))*t.x+dir*dir3(1)*t.y);\n    rotation[1] = normalize(dir2*vec3(equal(abs(dir2),vec3(2)))*t.x+dir*dir3(2)*t.y);\n    rotation[0] = normalize(dir2*vec3(equal(abs(dir2),vec3(3)))*t.x+dir*dir3(3)*t.y);\n    \n    \n    \n    vec3 ro = pos+rotation[1]*0.125;\n    vec3 rd = normalize(vec3(uv,1.0));\n    \n    if (length(iMouse.xy) > 40.0) {\n    \trd.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n    \trd.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n    }\n    \n    rd = rd*transpose(rotation);\n    \n    \n    bool hit = true;\n    float len;\n    float dist = 0.0;\n    \n    //floorpos = floor(ro*0.5);\n    vec3 signdir = sign(rd);\n    vec3 invdir = 2.0/(abs(rd)+0.0001);\n    vec3 dists = abs(-signdir*0.5-0.5+ro*0.5-floorpos)*invdir;\n    \n    for (int i = 0; i < 100; i++) {\n        float smallest = min(min(dists.x,dists.y),dists.z);\n        len = map(ro);\n        if (len < 1.0/iResolution.y*(dist+1.0)||dist>FAR) {\n            hit = dist < FAR;\n            break;\n        }\n        \n        len = min(len,smallest);\n        \n        ro += rd*len;\n        dist += len;\n        \n        smallest -= len;\n        dists -= len;\n        if (smallest <= 0.0) {\n            vec3 mask = step(dists,vec3(smallest));\n            vec3 localpos = (ro+dot(mask*dists,vec3(1))*rd) - floorpos*2.0-1.0;\n            \n            vec2 q = vec2(dot(mask.yzx,localpos),dot(mask.zxy,localpos));\n            \n            vec3 portalpos = floorpos+mask*signdir*0.5;\n            vec4 random = vec4(hash31(portalpos),hash33(portalpos));\n            random.x = random.x/portals;\n            //vec3 randompos = floor(hash33(portalpos)*100.0-50.0);\n            \n            float portalsize = 0.0;\n            \n            if (random.x > 1.0) {\n                \n            \tportalpos += mask*signdir*2.0;\n                random = vec4(hash31(portalpos),hash33(portalpos));\n                random.x = random.x/portals;\n                \n            }\n            if (random.x > 1.0) {\n                portalsize=100.0;\n        \t} else {\n                float t = iTime*random.x+random.y;\n\n                portalsize =\n                    length(q)\n                    +sin(atan(q.x,q.y)* 8.0+t    )*0.04*sin(t*2.0)\n                    +sin(atan(q.x,q.y)*16.0+t*1.5)*0.02*sin(t*4.0);\n            }\n            \n            \n            if (portalsize < 0.4) {\n                //vec3 randdirection = vec3(equal(vec3(1,2,3),vec3(clamp(floor(random.x*3.0),0.0,3.0))));\n                \n                floorpos += mask*signdir;\n                vec3 localpos = ro-floorpos*2.0;\n                floorpos += mask*signdir*2.0;\n                ro = floorpos*2.0+localpos;\n                \n                //randdirection *= floor(0.5+random.yzw)*2.0-1.0;\n                \n            } else if (portalsize < 0.45) {\n                fragColor = vec4(-mask*signdir*0.5+0.5,1);\n                fragColor = vec4(random.xzwy);\n                return;\n            } else {\n                floorpos += mask*signdir;\n            }\n            dists = (1.0-mask)*dists+mask*invdir;\n        }\n        \n    }\n    if (hit) {\n        \n\t\tfragColor = vec4(findnormal(ro,len)*0.5+0.5,1.0);\n        fragColor /= (dist*dist*0.0005*FAR+1.0);\n        //if (all(equal(floor(ro*0.5),floorpos))) fragColor = 1.0-fragColor;\n    }\n}", "image_inputs": [{"id": "XsfGzn", "previewfilepath": "/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldfDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[408, 478, 500, 500, 609], [611, 681, 704, 704, 807], [809, 809, 828, 843, 901], [903, 903, 932, 951, 1029], [1031, 1031, 1050, 1050, 1716], [1718, 1739, 1775, 1775, 1932], [1934, 1934, 1991, 1991, 7410]], "test": "valid"}
{"id": "lldfR4", "name": "v0+mgr0", "author": "teraspora", "description": ".", "tags": ["multiple"], "likes": 1, "viewed": 90, "published": "Public", "date": "1538865099", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// v0+mgr0 - a fragment shader in GLSL, built on shadertoy.com;\n// Author: John Lynch (@teraspora);\n// Date: 06 OCT 2018.\n\n// Just combining voronoigo x8 with merry-go-round in the middle\n// -----------------------------------------------------------------------------\n\n// Copyright © 2018 John Lynch\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// -----------------------------------------------------------------------------\n\nconst float PI = 3.141592654;\nconst float TWO_PI = 6.283185307;\nconst float HALF_PI = 1.5707963267948966;\n\n// Some useful colours:\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 crimson =      vec3(1.,   0.,   0.3  );\nconst vec3 yellow =      vec3(1.,   1.,   0.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 orange = vec3(1.0, 0.4, 0.);\nconst vec3 cyan = vec3(0., 0.4, 1.0);\nconst vec3 magenta = vec3(1.0, 0., 1.0);\nconst vec3 gold = vec3(1.0, 0.84, 0.66);\n\nvec3[] cols = vec3[](white, crimson, yellow, magenta, gold, cyan, orange);\n\n// ==================================================================\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n// - not tested!\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\n// My inline library of useful functions:\n\n// =======================================\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\n// float dot(vec2 u, vec2 v) {\n// \treturn u.x * v.x + u.y * v.y;\n// }\n\nfloat om(float x) {\n\treturn 1. - x;\n}\n\nvec3 om(vec3 v) {\n\treturn 1. - v;\n}\n\nfloat op(float x) {\n\treturn 1. + x;\n}\n\nfloat nsin(float x) {\n\treturn op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n\treturn op(cos(x)) * 0.5;\n}\n\nfloat sqrtp(float x) {\n\treturn sqrt(x < 0. ? -x : x); \n}\n\nfloat nmmod(float x, float y) {\n\tfloat xmn = 2. * mod(x, y) / y;\n    return xmn < 1. ? xmn : om(xmn);\n}\n\nvec3 omss(float mn, float mx, vec3 val) {\n\treturn om(smoothstep(mn, mx, val));\n}\n\nvec2 nmouse() {\n\treturn iMouse.xy / iResolution.xy;\n}\n// =======================================\n\nvec3 drawBorder(vec3 col, float b, vec3 insetColour, vec2 pp, vec2 hr, float tileIndex) {\n    // `b` is the border width\n    // `col` is the input (and output) colour\n    // `pp` is (unnormalised) coordinate of pixel\n    // `hr` is (unnormalised) resolution\n    // Make a border: `b` px solid black; with `insetColour` inset:\n    if (tileIndex != -1.) {\n    \t//  any special code for single-pane use goes here    \n    }\n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = insetColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = insetColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));\n    return col;\n}\n\nvec2 psrandv2(float seed, int i) {\n    vec2 a;\n    a.x = cos(fract(cos(seed * 458333.003736561)) * (319.50207 + 10352.9911 * float(i)));\n\ta.y = sin(cos(fract(sin(seed * 4032.9908442016)) * (2786.2227 + 7046.88813 * float(i))));\n\ta.x *= fract(100000. * fract(dot(a, a.yx + vec2(26332.16598469, 7004.8112))));\n    a.y *= fract(1000. * fract(dot(rotate(a, float(i) * 69.4177), a.yx + vec2(91104.33554432, 8112.7004))));\n    return a * 0.5;\n}\n\nfloat minkd(vec2 u, vec2 v, float order) {\t// Minkowski distance; order = 1\n    if (order <= 0.) return 0.;\t\t\t\t// => Manhattan distance\n\treturn abs(pow(abs(pow(v.x - u.x, order)) + abs(pow(v.y - u.y, order)), 1. / order)); \n}\n\n\nfloat mtime(float period) {\n\treturn mod(iTime, period) / period;\n}\n\n\n\n// ..........................................................\n\nfloat f(float x, float tile) {\n    float t = iTime * 0.01;\n    return exp(cos(15. * mtime(182.) * x) / 4. + cos(11. * mtime(113.) * x) * 1.2);       \n}\n\nfloat g(float x, float tile) {\n \tfloat t = iTime * 0.01;\n    return log(sin(3. * mtime(193.) * x) * 69. + cos(119. * mtime(252.) * x) / 12. + sin(7. * x) / 17.);       \n}\n\n\n// MAIN METHOD:\n\nvec3 doStuff(vec2 pixel, vec2 res) {\n    // just takes a pixel and a context and outputs a\n    // colour to mainImage, which keeps things organised\n    // and encapsulated.\n    \n    \n    // Set this var to the number of tiles across and down:\n    float tileDim = 3.;\n    float numTiles = tileDim * tileDim;\n        \n    // the output vector, before normalisation,\n    // giving the position the program needs to know!-\n    vec2 pp = pixel;\n    vec2 hr = res / tileDim;\t// resolution of one tile\n    vec3 col = magenta;\n    \n    // ===============================================================\n    \n    // Normalisation and tiling:\n    // ========================\n    \n    // Make numTiles sub-frames:\n    vec2 n = vec2(float(int(pixel.x / res.x * tileDim)), float(int(pixel.y / res.y * tileDim)));\n    \n    float tile = numTiles -(n.y * tileDim + n.x) - 1.; \n    // start at 1 so we don't lose stuff when multiplying\n    float toe = fract(tile / 2.) * 4. - 1.; // returns 1. if tile index odd, -1. if even;\n    float tile2 = tile * tile;\n    \n    // Offset the start of each rendition:\n    float time = tile * 32. + iTime;\n    // shift back to the first tile if in any other tile:\n    pp.x -= hr.x * n.x;\n    pp.y -= hr.y * n.y;\n    // normalise to [0, 1[, then shift to make unit quad with origin in centre\n    vec2 q = pp / hr - 0.5;     \n    // then scale:\n    float scaleFactor = 1.0;\n    // q /= scaleFactor;\n       \n    // ===============================================================================================\n    // ===============================================================================================\n    \n    // Main code for the shader goes here:\n    // ===============================================================================================\n    \n    if (tile != 4.) {\n    // q *= 2.; \n    q = rotate(q, toe * (iTime * 0.02 * (numTiles - tile - 1.) + (tile - 1.) * 0.25 * PI));\t// vary angle for each tile\n    \n    float inc = 0.003;\n    vec2[4] k = vec2[](vec2(-1., -1.), vec2(-1., 1.), vec2(1., -1.), vec2(1., 1.));\n    \n    float order = 1.;\t// minkowski order (1 = Euclidean, 2 = Manhattan)\n    \n    \n    //Initialise points[] array:\n    \n    // int numPoints = 6 + int(mod(iTime * 0.125, 128.));\n    int numPoints = 8 + int(128. * sin (iTime / 512.));\n    \n    vec2 points[140];\n    \n    float sa = 313.95920007897932 * (numTiles - tile);\n    float sb = 25.2649677703343 * tile;\n    float rseed = fract(cos(fract(sin(sa + cos(fract(sa) * sb)))));\n    \n    for (int i = 0; i < numPoints; i++) {\n    \tpoints[i] = psrandv2(rseed, i) + k[int(mod(float(i), 4.))] * inc * mod(iTime, 128.) * 2.8;\n        float hue = float(i) / float(numPoints - 1);\n        col = hue2rgb(hue);\n    }\n    \n    // My algorithm to draw the edges:\n    // Iterate through the points and find the two nearest to q.\n    // Give our point a hue determined by the i0, index of the \n    // closest point.\n    // Then if the differences in the distances of q to each of\n    // these two points is less than some small threshold value, \n    // it's roughly equidistant from the two nearest points, so \n    // make q black, as it's on the border.\n    \n    // Note: old code commented out and left ror reference and possible later re-use\n    \n    float mind0 = 1.;   // set min distances high\n    float mind1 = 1.;  // 2nd smallest distance\n    int i0 = 144;\n    int i1 = 144;\n    for (int i = 0; i < numPoints; i++) {   // find two closest points\n        \n        // TEST:\n        float k = 0.01;\n        q += k * sin(iTime / 20.);\n        \n        float d = minkd(q, points[i], 1.);\n        if (d <= mind0) {\t\t// new closest pt.\n            mind1 = mind0;\n            mind0 = d;\n            i1 = i0;\n            i0 = i;\n        }\n        else if (d <= mind1) {\t// new next-closest pt.\n            mind1 = d;\n            i1 = i;\n        }        \n    }\n    \n    // float hue = float(toe < 0. ? i0 : (numPoints - 1 - i0)) / float(numPoints - 1);\n    // float hueInv = 1. - hue;\n    // col = hue2rgb(toe > 0. ? hue : hueInv);\n    // col.g *= 0.8;\n    \n    col = vec3(abs(mod(float(i0), 3.) - 1.));\n    // col = vec3(mod(float(i0), 3.) / 2., mod(float(i0), 5.) / 4., mod(float(i0), 7.) / 6.);\n    col.g *=  sqrt(mind1);\n    //col.b *= distance(q, points[i0]);\n    col.b *= length(q) * nsin(iTime / 3.);\n    \n    //col *= smoothstep(0.01, 0.02, abs(minkd(q, points[i0], order) - minkd(q, points[i1], order)));\n    col = toe > 0. ? col : col.bgr;\n    col.g *= 0.8;\n    // draw coloured dots:\n    float d = 0.005;\n    float m = mod(iTime, 32.) - 28.;\n    if (m > 0.) {\n        d *=2. * (m + tile / numTiles);\n        col *= step(0.5, 1. - col.g); // make white rings black\n    }\n    float s = iTime + 50. * length(q);\n    float c = float(cols.length());\n    if (col.r == 0. && mind0 < d) col = cols[int(mod(s, c))];\n    \n    // todo: convert above to step /smoothstep\n    col.g *= nsin(tile * tile);\n    }\n    // .................................\n    \n    \n    \n    \n    else {\n    \n    // .................................\n    // other code for centre tile:\n    \n    float t = iTime / 2048.;;\n    \n    // first scale:\n    float scaleFactor = 15.0;\n    float yscale = 0.2;\n    q *= scaleFactor;\n    q.y *= yscale;\n    t = t * 128.;\n    q.y *= hr.x /hr.y;\n    q.x *= 0.35;\n    q = abs(q);\n    q = rotate(q, t * 6.);\n    float phi = abs(arg(q));\n    q = polar(length(q), mod(phi, PI / 16.)); \n    \n    vec2 s0 = vec2(q.x - t, q.y);\n    vec2 s1 = vec2(q.x + 2. * t, q.y);\n    float k = 1.;\n    float delta = 0.4;\n    float yd0 = s0.y + delta;\n    float yd1 = s1.y + delta;\n    \n    float rc = f(s0.x, k) * q.x;\n    float bc = g(s1.x, k) * q.x;\n        \n    float hue = (smoothstep(s0.y, yd0, rc) - smoothstep(yd0, yd0 + delta, rc))\n     + (smoothstep(s1.y, yd1, bc) - smoothstep(yd1, yd1 + delta, bc));\n    col = hue2rgb(hue);\n    col.r = 0.6;\n    col.g = 0.;\n    col *= 0.7;\n    hue = rgb2hsl(col).x;\n        \n    col.g  = 0.;\n    col.b += nsin(iTime / 4.) / 2.;    \n    col.r += nsin(iTime / 7.) / 5.;    \n    //col = black;\n      \n    }\n\n    // ===============================================================================================\n    // ===============================================================================================\n    \n    // Border code:    \n    // ===============================================================================================\n    \n    float borderWidth = 3.;\n    vec3 borderInsetLineColour = white;\n    col = drawBorder(col, borderWidth, borderInsetLineColour, pp, hr, tile);\n    \n    // finally return the colour to caller(mainImage()):\n    return col;\n}\t// END doStuff()\n    \n// ===============================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    float borderWidth = 6.;\n    vec3 borderInsetLineColour = white;\n \tvec3 col = doStuff(fragCoord, iResolution.xy);\n    col = drawBorder(col, borderWidth, borderInsetLineColour, fragCoord, iResolution.xy, -1.);\n    // finally return the colour:\n    fragColor = vec4(col, 1.0);        \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldfR4.jpg", "access": "shaders20k", "license": "mit", "functions": [[2227, 2227, 2252, 2252, 2410], [2411, 2475, 2499, 2552, 2835], [2837, 2872, 2896, 2896, 3048], [3137, 3137, 3156, 3156, 3185], [3187, 3187, 3219, 3219, 3266], [3268, 3268, 3296, 3296, 3361], [3363, 3363, 3395, 3395, 3436], [3509, 3509, 3528, 3528, 3546], [3548, 3548, 3565, 3565, 3583], [3585, 3585, 3604, 3604, 3622], [3624, 3624, 3645, 3645, 3673], [3675, 3675, 3696, 3696, 3724], [3726, 3726, 3748, 3748, 3782], [3784, 3784, 3815, 3815, 3887], [3889, 3889, 3930, 3930, 3969], [3971, 3971, 3986, 3986, 4024], [4069, 4069, 4158, 4394, 4931], [4933, 4933, 4967, 4967, 5371], [5373, 5373, 5415, 5448, 5598], [5601, 5601, 5628, 5628, 5667], [5734, 5734, 5764, 5764, 5885], [5887, 5887, 5917, 5917, 6057], [12791, 12791, 12848, 12848, 13140]], "test": "error"}
{"id": "lldfR7", "name": "FTLS", "author": "shau", "description": "Experiment with pseudo 3D backgrounds ", "tags": ["3d", "vr"], "likes": 11, "viewed": 1055, "published": "Public API", "date": "1539130094", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define T iTime * 8.\n#define PI2 6.28318\n#define R iResolution.xy\n\n//Dave Hoskins\n//https://www.shadertoy.com/view/4djSRW\nfloat H1(float p) {\n\tvec3 x  = fract(vec3(p) * .1031);\n    x += dot(x, x.yzx + 19.19);\n    return fract((x.x + x.y) * x.z);\n}\n\n//IQ cosine palattes\n//http://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 PT(float t) {return vec3(.5) + vec3(.5) * cos(6.28318 * (vec3(1) * t + vec3(0, .33, .67)));}\n\nvec3 render(vec3 rd) {\n    float a = (atan(rd.y, rd.x) / PI2) + .5, //polar  0-1\n          l = floor(a * 24.) / 24.; //split into 24 segemnts\n    vec3 c = PT(H1(l + T * .0001)) * step(.1, fract(a * 24.)); //segment colour and edge\n    float m = mod(abs(rd.y) + H1(l) * 4. - T * .01, .3); //split segments \n    return c * step(m, .16) * m * 16. * max(abs(rd.y), 0.); //split segments\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n    \n    //ray direction\n    vec2 uv = (U - R * .5) / R.y;\n    vec3 f = vec3(0, 0, 1),\n         r = vec3(f.z, 0, -f.x),\n         d = normalize(f + 1. * uv.x * r + 1. * uv.y * cross(f, r));\n        \n    C = vec4(render(d), 1.);\n}\n\nvoid mainVR(out vec4 C, vec2 U, vec3 ro, vec3 rd) {\n    C = vec4(render(rd), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldfR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 122, 141, 141, 247], [249, 333, 351, 351, 430], [432, 432, 454, 454, 816], [818, 818, 854, 879, 1083], [1085, 1085, 1136, 1136, 1168]], "test": "valid"}
{"id": "lldfR8", "name": "BullShat", "author": "Noge", "description": "Amazing", "tags": ["haha"], "likes": 2, "viewed": 72, "published": "Public", "date": "1538670758", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = (\n        vec3(\n            //cos(abs(uv.y-0.5)+iTime*2.0),\n            //cos(abs(uv.y-0.5)-iTime),\n            0.5*(0.5-abs(uv.y-0.5+cos(iTime*8.0)/3.0))*6.0,\n            0.5*(0.5-abs(uv.x-0.5+cos(iTime*4.0)/3.0))*8.0,\n            0.5*(0.5-abs(uv.x-0.5+cos(iTime*2.0)/3.0))*8.0\n        )\n        \n    );\n    col=col+vec3(0,-0.5,-0.5);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldfR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 106, 588]], "test": "valid"}
{"id": "lldfW7", "name": "TripointVoronoi", "author": "uynet", "description": "diagram", "tags": ["voronoi"], "likes": 1, "viewed": 81, "published": "Public", "date": "1539907621", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 iCol(int i){\n    switch(i){\n        case 0 : return vec3(0.8,0.9,.1);\n        case 1 : return vec3(1,.6,0.6);\n        case 2 : return vec3(1,1,.6);\n    }\n}\n\nvec3 dCol(float d){\n    return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float asp = iResolution.x/iResolution.y;\n    uv.x *= asp;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    vec2[3] p;\n    p[0] = vec2(0.9 + 0.3 * sin(iTime),0.5 + 0.4*cos(iTime));\n    p[1] =vec2(0.9 + 0.6 * sin(iTime*1.72),0.4 + 0.3*cos(iTime*1.31));\n    p[2] =vec2(0.9 + 0.3 * sin(iTime*1.14),0.5 + 0.5*cos(iTime*0.72));\n    \n    float dmin = 999.0f;\n    int minI = 0;\n\n    for(int i=0;i<3;i++){\n        if(length(uv-p[i])<0.01f)col = vec3(1);\n        float d = length(uv - p[i]);\n        if(abs(d) < 0.01f){\n            col = dCol(d);\n            fragColor = vec4(col,1.0);\n            return;\n        }\n        if(dmin > d){\n            dmin = d;\n            minI = i;\n        }\n        \n    }\n    col = iCol(minI);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldfW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 160], [162, 162, 181, 181, 203]], "test": "error"}
{"id": "lldfz4", "name": "Nature Project- Beating Heart", "author": "tiff", "description": "beating heart", "tags": ["beatingheart"], "likes": 2, "viewed": 65, "published": "Public", "date": "1538888243", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    \n    \n    // Time varying pixel color\n    vec3 col = vec3(1., .05, .05);\n\n    uv.x *= 1.2; //pulls in the top \n    uv.y -= sqrt(abs(uv.x))*.5; //creates shape of the heart\n    \n    uv.xy *= sin(iTime); //creates motion of beating heart\n    \n    float d = length(uv);\n    \n    float c = smoothstep(.3, .28,d); //draws shape\n\n    float pct = distance(uv, vec2(0.5) *-.9)*smoothstep(.8, uv.x, uv.y); //distance to centre, creates gradient\n     \n    col = vec3(c)*col * pct; //adds shape, color and gradient \n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldfz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 736]], "test": "valid"}
{"id": "llGcD3", "name": "Dark clouds", "author": "grumdrig", "description": "I was shooting for something else but I kind of like this thing I made along the way.", "tags": ["clouds", "silverlining"], "likes": 5, "viewed": 209, "published": "Public", "date": "1538459986", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rand(vec3 xyz) {\n    return fract(vec3(sin(dot(xyz, vec3(43.238, 27.874, 57.982))),\n    \t\t\t\t  sin(dot(xyz, vec3(91.922, 11.838, 77.133))),\n    \t\t\t\t  sin(dot(xyz, vec3(43.238, 27.874, 57.982))))*\n                 vec3(9283.9502,8329.9128,3201.1984));\n}\n\n\nvec3 curp(vec3 v0, float t, vec3 v1) {\n    t = t * t * (3.0 - 2.0 * t);\n    return mix(v0, v1, t);\n}\n\nvec3 lerp(vec3 v0, float t, vec3 v1) {\n    return mix(v0, v1, t);\n}\n\nvec3 noise(vec3 xyz) {\n    vec3 v0 = floor(xyz);\n    vec3 f = xyz - v0;\n    return\n      curp(curp(lerp(rand(v0),               f.z, rand(v0 + vec3(0,0,1))),\n                f.y,\n                lerp(rand(v0 + vec3(0,1,0)), f.z, rand(v0 + vec3(0,1,1)))),\n           f.x,\n           curp(lerp(rand(v0 + vec3(1,0,0)), f.z, rand(v0 + vec3(1,0,1))),\n                f.y,\n                lerp(rand(v0 + vec3(1,1,0)), f.z, rand(v0 + vec3(1,1,1)))));\n}\n\nvec3 simplex(vec3 xyz, int octaves) {\n    float a = 1.0;\n    vec3 result = vec3(0);\n    for (int o = 1 << octaves; o > 0; o >>= 1, a /= 2.) {\n        result += (2. * noise(xyz / float(o)) - 1.) * a;\n    }\n    return result;\n}\n        \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.x - vec2(0.5, 0.5 * iResolution.y / iResolution.x);\n    vec3 per = simplex(vec3(uv * 120., iTime * 2.), 5);\n    float a = dot(normalize(per), normalize(vec3(uv, 0.1)));\n    a = 1. * pow(a, 5.);\n    fragColor.rgb = vec3(a) * 1.;\n    fragColor.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGcD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 256], [259, 259, 297, 297, 359], [361, 361, 399, 399, 428], [430, 430, 452, 452, 875], [877, 877, 914, 914, 1102], [1113, 1113, 1170, 1170, 1459]], "test": "valid"}
{"id": "lltBRB", "name": "BallRoller", "author": "Del", "description": "A Rolling Ball...", "tags": ["tunnel", "raymarch", "ball", "rolling"], "likes": 32, "viewed": 950, "published": "Public", "date": "1540140732", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Ball roller - attempting to learn some raymarching techniques from the masters...\n//\n// raymarching base code from Shane's awesome 'Mountain Path' https://www.shadertoy.com/view/ldjyzc\n// Del - 21/10/2018\n//\n// some slight mods: improved ball rolling, single box for rails, single texture etc.\n\n#define FAR 120.\n#define BALLSIZE 1.25\n#define PI 3.14159\n#define\tTAU 6.28318\n\nfloat objID;\nfloat svObjID;\nvec3 m_ballpos;\t\t// ball position\nmat3 m_ballmat;\t\t// rotation matrix\n\n// Fabrice's concise, 2D rotation formula.\n//mat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\n//vec3 tex3D( sampler2D t, in vec3 p, in vec3 n )\n//{\n//    p*=0.4;\n//    n = max(abs(n), 0.001);\n//    n /= dot(n, vec3(1));\n//\tvec3 tx = texture(t, p.yz).xyz;\n//    vec3 ty = texture(t, p.zx).xyz;\n//    vec3 tz = texture(t, p.xy).xyz;\n//    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n//}\n\n// Smooth maximum, based on IQ's smooth minimum.\n//float smax(float a, float b, float s){\n//    \n//    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n//    return mix(b, a, h) + h*(1. - h)*s;\n//}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\n//vec3 rotateY(vec3 p, float a)\n//{\n//  float sa = sin(a);\n//  float ca = cos(a);\n//  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n//}\n//vec3 rotateZ(vec3 p, float a)\n//{\n//  float sa = sin(a);\n//  float ca = cos(a);\n//  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n//}\n\n// out: 0->val->0\nfloat SmoothTri2(float t, float val)\n{\n    return val * (1.0-(0.5+cos(t*TAU)*0.5));\n}\n\n// Blended path(s)\nvec2 path(in float z)\n{ \n\tfloat t = mod(z,68.0)/68.0;\n\tfloat m = SmoothTri2(t,1.0);\n    vec2 path1 = vec2(sin(z*0.1)*0.5,(cos(z*0.2)*0.75)-1.0);\n    vec2 path2 = vec2((sin(z*.15)*2.5), (cos(z*0.13)*1.25)+1.0); // Path 3.\n    return mix(path1,path2,m);\n}\n\n// internal cylinder\nfloat DirtyTunnel(vec3 p, float d)\n{\n\tfloat d2 = d - length(p.xy);\n\n    // tunnel noise...\n    float k = dot(sin(p*1. - cos(p.yzx*1.57)), vec3(.333))*.57;\n    k += dot(sin(p*2. - cos(p.yzx*3.14)), vec3(.333))*.13;\n    d2-=k;\n    return d2;\n}\n\n\n#if 0\n// http://mercury.sexy/hg_sdf/\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat filth(in vec3 p, vec2 pth,float z)\n{\n    vec3 p2 = p;\n    p2.xy += pth;\n    \n\tfloat c = pMod1(p2.z,16.0);\n    \n    float r = hash(vec2(c+(c*0.31),c+(c*0.61)));\n\n    if (r>0.6)\n    {\n        float h = 4.0;\t// *r;\n\t    float dist3 = sdBox(p2-vec3(0.0,h-0.5,0.0),vec3(2.7,0.5,0.5));\n\t    p2.x -= 2.7;\n\t    float dist = sdBox(p2,vec3(0.5,h,0.5));\n\t    p2.x += 5.4;\n\t    float dist2 = sdBox(p2,vec3(0.5,h,0.5));\n\t\tdist=min(dist,dist2);\n        \n\t\t//return smin(dist,dist3,0.9);\n\t\treturn min(dist,dist3);\n        \n    }\n    return 1.0;\n}\n#endif\n\n\nfloat map(vec3 p)\n{\n    vec2 pth = path(p.z);\n\n    // ROAD (1 box)\n    vec3 pp2 = p;\n    pp2.xy += pth;\n    pp2.y += 3.0;\t\t// road Yoffset\n    float dist = sdBox(pp2,vec3(3.5,0.2,200000.0));\n    \n    // RAILS (1 box, abs mirror)\n    pp2.x = abs(pp2.x);\n    pp2.x -= 1.3;\n    float rails = sdBox(pp2,vec3(0.125,0.5,200000.0));\n    \n    dist = smin(rails,dist,0.2);\n    // debug\n\t//dist = smin(filth(p, pth, p.z),dist,0.2);    \n\n    // + tunnel (-yoff)\n    vec3 p2 = p;\n    p2.xy += pth;\n\tfloat d2 = DirtyTunnel(p2-vec3(0.0,1.0,0.0),5.0);\n\n    objID = step(d2, dist); // Tunnel, Ground...\n    \n    // Ball (hack)\n    dist = smin(dist,d2,0.2);\n    vec3 bp = p-m_ballpos;\n\tfloat balldist = sdSphere(bp,BALLSIZE);\n    \n\tdist = min(balldist,dist);\n    if (dist>=balldist)\n        objID = 2.5;\t\t// or Ball!\n    if (dist>=rails)\n        objID = 3.5;\t\t// or Rail!\n    \n    return dist;\n}\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd)\n{\n    float t = 0., d;\n    for (int i=0; i<160; i++)\n    {\n        d = map(ro + rd*t);\n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR)\n            break;\n        t += d;\n    }\n    return min(t, FAR);\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k, float t)\n{\n    const int maxIterationsShad = 48; \n    vec3 rd = lp-ro;\n    float shade = 1.;\n    float dist = .0025*(t*.125 + 1.);\n    float end = max(length(rd), 0.0001);\n    rd /= end;\n    for (int i=0; i<maxIterationsShad; i++)\n    {\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n        dist += clamp(h, .07, .5); \n        if (h<0.0 || dist > end)\n            break; \n    }\n    return min(max(shade, 0.) + 0.1, 1.); \n}\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p )\n{\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n//vec3 BallTexture2(vec2 pos)\n//{\n//    float y = mod(pos.y+0.5,2.0)-0.5;\n//\tfloat s = smoothstep( y-0.5, y, 0.0) - smoothstep( y, y+0.5, 0.0); \n//    vec3 col = mix(vec3(0.7,0.5,0.8)*1.2,vec3(0.7,0.5,0.8)*0.5,s);\n//    return col;\n//}\n\nvec3 BallTexture(vec2 pos)\n{\n    // lines\n    float f = mod( floor(pos.y),2.0) + 0.75;\n    vec3 col = f*vec3(0.7,0.5,0.8);\n    return col;\n}\n\n\n// Coloring / texturing the scene objects, according to the object IDs.\nvec3 getObjectColor(vec3 p, vec3 n)\n{\n    vec3 tx = vec3(1.0*1.0,0.98*0.98,0.95*0.95);\n    \n    if(svObjID<.5)\n    {\n        //vec2 pth = path(p.z);\n        //tx = tex3D(iChannel0, (p - vec3(pth.xy - .5, .0)), n );\t// Shane tex3d\n        \n        vec2 _uv = p.xz;\n        _uv += path(p.z);\n        tx = texture(iChannel0,_uv*0.1).xyz*vec3(0.8,1.1,0.8);\n        tx*=tx;\n        \n    }\n    else if(svObjID<1.5)\n    {\n        float scale = 0.25;\n        p.xy += path(p.z);\n        p*= scale;\n        tx = texture(iChannel0, (vec2(p.z , atan(p.x, p.y)) / 6.28)).xyz;\t// Cylinder\n        tx*=tx;\n    }\n    else if(svObjID<2.6)\n    {\n        vec3 p2 = n;\n        p2 = m_ballmat*p2;\n        p2 = rotateX(p2,-m_ballpos.z);\n        //p2 = normalize(p2);\n        //p2 = rotateZ(p2,3.14/2.0);\n        vec2 _uv;\n        _uv.x = 0.5 + atan(p2.z, p2.x) / TAU;\n        _uv.y = 0.5 - asin(p2.y) / PI;\n\t\ttx = BallTexture(_uv*7.0);\t\t\t\t\t// sphere\n\t\t//tx = BallTexture2(_uv*5.0);\t\t\t\t// sphere\n    \t//tx = texture(iChannel0, _uv*2.).rgb;\n        tx*=tx;\n    }\n    return tx;\n}\n\n// Using the hit point, unit direction ray, etc, to color the scene. Diffuse, specular, falloff, etc. \n// It's all pretty standard stuff.\nvec3 doColor(in vec3 ro, in vec3 rd, in vec3 lp, float t)\n{\n    // Initiate the scene (for this pass) to zero.\n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR)\n    { // If we've hit a scene object, light it up.\n        \n        // Surface hit point.\n        vec3 sp = ro + rd*t;\n\n        // Retrieving the normal at the hit point, plus the edge and curvature values.\n        vec3 sn = getNormal(sp);\n        \n        // Shading. Shadows, ambient occlusion, etc. We're only performing this on the \n        // first pass. Not accurate, but faster, and in most cases, not that noticeable.\n        // In fact, the shadows almost didn't make the cut, but it didn't quite feel \n        // right without them.\n        float sh = softShadow(sp + sn*.002, lp, 16., t); // Set to \"1.,\" if you can do without them.\n        float ao = calcAO(sp, sn);\n        sh = (sh + ao*.3)*ao;\n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n        // Attenuating the light, based on distance.\n        float atten = 3./(1. + lDist*0.01 + lDist*lDist*0.00008);\n        // Standard diffuse term.\n        float diff = max(dot(sn, ld), 0.);\n        //diff = pow(diff, 2.)*.66 + pow(diff, 4.)*.34;\n        // Standard specualr term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.0);\n        vec3 objCol = getObjectColor(sp, sn);\n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol*(diff + ao*.5 + vec3(1, .7, .5)*spec*1.);\n        // Apply the attenuation and shadows.\n        sceneCol *= atten*sh;\n    }\n    // Return the color. Done once for each pass.\n    return sceneCol;\n}\n\n\nmat3 rotate3d(vec3 axis, float angle)\n{\n    //axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\nmat3 lookat(vec3 o, vec3 t)\n{\n\tvec3 dir = normalize(t-o);\n    float yAxis = atan(dir.x,dir.z);\n    float xAxis = -asin(dir.y);\n    return rotate3d(vec3(1,0,0),xAxis)*rotate3d(vec3(0,1,0),yAxis);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime*7.5); // Camera position, doubling as the ray origin.\n    \n    \n\tvec3 lk = ro + vec3(0.0, 0.0, 0.25);  // \"Look At\" position.\n   \n    // Light position.\n    //vec3 lp = ro + vec3(10., FAR*.24, FAR*.52)*3.;\n    vec3 lp = ro + vec3(10., FAR*.24, FAR*.22)*3.;\n    \n    m_ballpos = ro;\n    vec3 BallLookAt = ro;\n\n    // camera look ahead\n    ro.xy-=path(ro.z);\n    lk.xy-=path(lk.z);\n\n    // position the ball infront of the camera (on the path)\n    m_ballpos.z += 8.0;\n    m_ballpos.y -= 1.5;\n    m_ballpos.xy -= path(m_ballpos.z);\n    \n    BallLookAt.z += 8.05;\n    //BallLookAt.y -= 1.5;\n    BallLookAt.xy -= path(BallLookAt.z);\n    BallLookAt.y = m_ballpos.y;\n    \n    m_ballmat = lookat(m_ballpos,BallLookAt);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = (forward + FOV*uv.x*right + FOV*uv.y*up);\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.15, 0.)) ));\n    \n    // Trace the scene.    \n    float t = trace(ro, rd);\n    \n    svObjID = objID; // Save the object ID, for use in the coloring equation.\n    \n    // Retrieving the color at the initial hit point.\n    vec3 sceneColor = doColor(ro, rd, lp, t);\n    \n    // APPLYING FOG\n    // Fog - based off of distance from the camera.\n    float fog = smoothstep(0., .95, t/FAR); // t/FAR; \n    \n    vec3 fogCol = vec3(0.5,0.5,0.5);\n    sceneColor = mix(sceneColor, fogCol, fog); // exp(-.002*t*t), etc. fog.zxy \n\n    // Clamping the scene color, then presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0.0, 1.0)), 1.0);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltBRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1161, 1161, 1202, 1202, 1291], [1293, 1293, 1324, 1324, 1415], [1417, 1417, 1452, 1452, 1478], [1481, 1481, 1512, 1512, 1618], [1921, 1939, 1977, 1977, 2024], [2026, 2045, 2068, 2068, 2298], [2300, 2321, 2357, 2357, 2562], [3610, 3610, 3629, 3629, 4488], [4490, 4523, 4554, 4554, 4753], [4756, 4756, 4810, 4810, 5313], [5315, 5387, 5416, 5531, 5727], [5729, 5729, 5769, 5769, 6028], [6267, 6267, 6295, 6308, 6407], [6410, 6482, 6519, 6519, 7537], [7539, 7677, 7736, 7787, 9429], [9432, 9432, 9471, 9501, 9947], [9948, 9948, 9977, 9977, 10144], [10146, 10146, 10203, 10230, 12100]], "test": "error"}
{"id": "lltBW8", "name": "Visual Sine", "author": "liju", "description": "Sine wave visualization", "tags": ["sine"], "likes": 0, "viewed": 69, "published": "Public", "date": "1539513560", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float plotline(vec2 uv, float line)\n{\n    float pixelsize = 6.0/iResolution.y;\n    \n    return\tsmoothstep( line-pixelsize, line, uv.y ) - \n        \tsmoothstep( line, line+pixelsize, uv.y );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float uvx = uv.x;\n\n    \n    vec4 bg = vec4(0.6,0.6,0.6,1.0);\n    \n    if( uv.x < 0.8)\n    {\n        uv.x = uv.x*6.0;\n    \n        uv.y = uv.y*4.0;\n        \n    \tfloat lineA = 2.0+sin(4.0*sin(2.0*iTime+uv.x));\n    \n    \tfloat lineB = 2.0+sin(2.0*iTime+uv.x);\n        \n    \tlineA = plotline(uv,lineA) * uvx*2.0;\n    \n    \tlineB = plotline(uv,lineB) * uvx*2.0;\n    \n    \tbg = mix(bg,vec4(1.0,1.0,1.0,1.0),lineA);\n        \n    \tbg = mix(bg,vec4(0.2,0.2,0.2,1.0),lineB);\n        \n    }\n\n    fragColor = vec4(bg);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltBW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 191], [193, 193, 250, 250, 809]], "test": "valid"}
{"id": "lltBWB", "name": "Planet Fall", "author": "iq", "description": "Pretty much a modification to Klems' shader [url]https://www.shadertoy.com/view/XlcfRs[/url]. Make AA 1 in line 7 if it renders too slow for you", "tags": ["3d", "raymarching", "fractal", "distancefield", "sdf"], "likes": 146, "viewed": 10770, "published": "Public API", "date": "1540958965", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright Inigo Quilez, 2018 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// Pretty much a modification to Klems' shader (https://www.shadertoy.com/view/XlcfRs)\n// Youtube version: https://www.youtube.com/watch?v=q1OBrqtl7Yo\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // Change AA to 1 if it renders too slow for you\n#endif\n\n//#define INTERACTIVE\n\nmat3 makeBase( in vec3 w )\n{\n\tfloat k = inversesqrt(1.0-w.y*w.y);\n    return mat3( vec3(-w.z,0.0,w.x)*k, \n                 vec3(-w.x*w.y,1.0-w.y*w.y,-w.y*w.z)*k,\n                 w);\n}\n\n#define ZERO (min(iFrame,0))\n\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in float rad )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h,-b+h);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( in vec3 p, in float b, in float r )\n{\n    float h = clamp( p.z/b, 0.0, 1.0 );\n    return length( p - vec3(0.0,0.0,b)*h ) - r;//*(0.2+1.6*h);\n}\n\n// modified Keinert et al's inverse Spherical Fibonacci Mapping\nvec4 inverseSF( in vec3 p, const in float n )\n{\n    const float PI = 3.14159265359;\n\tconst float PHI = 1.61803398875;\n\n    float phi = min(atan(p.y,p.x),PI);\n    float k   = max(floor(log(n*PI*sqrt(5.0)*(1.-p.z*p.z))/log(PHI+1.)),2.0);\n    float Fk  = pow(PHI,k)/sqrt(5.0);\n    vec2  F   = vec2(round(Fk),round(Fk*PHI));\n    vec2  G   = PI*(fract((F+1.0)*PHI)-(PHI-1.0));    \n    \n    mat2 iB = mat2(F.y,-F.x,G.y,-G.x)/(F.y*G.x-F.x*G.y);\n    vec2 c = floor(iB*0.5*vec2(phi,n*p.z-n+1.0));\n\n    float ma = 0.0;\n    vec4 res = vec4(0);\n    for( int s=0; s<4; s++ )\n    {\n        vec2 uv = vec2(s&1,s>>1);\n        float i = dot(F,uv+c);\n        float phi = 2.0*PI*fract(i*PHI);\n        float cT = 1.0 - (2.0*i+1.0)/n;\n        float sT = sqrt(1.0-cT*cT);\n        vec3 q = vec3(cos(phi)*sT, sin(phi)*sT,cT);\n        float a = dot(p,q);\n        if (a > ma)\n        {\n            ma = a;\n            res.xyz = q;\n            res.w = i;\n        }\n    }\n    return res;\n}\n\nfloat map( in vec3 p, out vec4 color, const in bool doColor )\n{\n    float lp = length(p);\n    float dmin = lp-1.0;\n    {\n    vec3 w = p/lp;\n    vec4 fibo = inverseSF(w, 700.0);\n    float hh = 1.0 - smoothstep(0.05,0.1,length(fibo.xyz-w));\n    dmin -= 0.07*hh;\n    color = vec4(0.05,0.1,0.1,1.0)*hh * (1.0+0.5*sin(fibo.w*111.1));\n    }\n    \n    \n    float s = 1.0;\n    \n    #ifdef INTERACTIVE\n  //float tt = mod(iTime,5.0);\n    float tt = 4.0*iMouse.x/iResolution.x;\n    vec3  fp = smoothstep(0.0,1.0,tt-vec3(0,1,2));\n    #endif\n    \n    for( int i=0; i<3; i++ )\n    {\n        float h = float(i)/float(3-1);\n        \n        vec4 f = inverseSF(normalize(p), 65.0 + h*75.0);\n        \n        // snap\n        p -= f.xyz;\n\n        // orient to surface\n        p = p*makeBase(f.xyz);\n\n        // scale\n        float scale = 6.6 + 2.0*sin(111.0*f.w);\n        p *= scale;\n        p.xy *= 1.2;\n        \n        //translate\n        p.z -= 3.0 - length(p.xy)*0.6*sin(f.w*212.1);\n            \n        // measure distance\n        s *= scale;\n        #ifdef INTERACTIVE\n        float d = sdCapsule( p+vec3(0,0,6), 6.0*fp[i], mix(-40.0,0.42*fp[i],smoothstep(0.0,0.1,fp[i])) );\n        #else\n        float d = sdCapsule( p, -6.0, 0.42 );\n        #endif\n        d /= s;\n\n        if( d<dmin )\n        {\n            if( doColor )\n            {\n                color.w *= smoothstep(0.0, 5.0/s, dmin-d);\n\n                if( i==0 ) \n                {\n                    color.xyz = vec3(0.425,0.36,0.1)*1.1;  // fall\n                  //color.xyz = vec3(0.4,0.8,0.1);         // summer\n                  //color.xyz = vec3(0.4,0.4,0.8);         // winter\n                }\n\n                color.zyx += 0.3*(1.0-sqrt(h))*sin(f.w*1111.0+vec3(0.0,1.0,2.0));\n                color.xyz = max(color.xyz,0.0);\n            }\n            dmin = d;\n        }\n        else\n        {\n          color.w *= 0.4*(0.1 + 0.9*smoothstep(0.0, 1.0/s, d-dmin));\n        }\n    }\n    \n    return dmin;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float ep )\n{\n    vec4 kk;\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep, kk, false ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep, kk, false ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep, kk, false ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep, kk, false ) );\n#else\n    // prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*ep, kk, false);\n    }\n    return normalize(n);\n#endif    \n    \n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n    vec2 bound = sphIntersect( ro, rd, 2.1 );\n    tmin = max(tmin,bound.x);\n    tmax = min(tmax,bound.y);\n    \n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n    \tvec4 kk;\n\t\tfloat h = map( ro + rd*t, kk, false );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat raycast(in vec3 ro, in vec3 rd, in float tmin, in float tmax  )\n{\n    vec4 kk;\n    float t = tmin;\n\tfor( int i=0; i<512; i++ )\n    {\n\t\tvec3 p = ro + t*rd;\n        float h = map(p,kk,false);\n\t\tif( abs(h)<(0.15*t/iResolution.x) ) break;\n\t\tt += h*0.5;\n        if( t>tmax ) return -1.0;;\n\t}\n    //if( t>tmax ) t=-1.0;\n\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float an = (iTime-10.0)*0.05;\n    \n    // camera\t\n    vec3 ro = vec3( 4.5*sin(an), 0.0, 4.5*cos(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world rotation\n    mat3 ca = makeBase( normalize(ta-ro) );\n\n    // render    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.2) );\n    \n        // background\n        vec3 col = vec3(0.1,0.14,0.18) + 0.1*rd.y;\n\n        // bounding volume\n        vec2 bound = sphIntersect( ro, rd, 2.1 );\n\t\tif( bound.x>0.0 )\n        {\n        // raycast\n        float t = raycast(ro, rd, bound.x, bound.y );\n        if( t>0.0 )\n        {\n            // local geometry            \n            vec3 pos = ro + t*rd;\n        \tvec3 nor = calcNormal(pos, 0.01);\n            vec3 upp = normalize(pos);\n            \n            // color and occlusion\n            vec4 mate; map(pos, mate, true);\n            \n            // lighting            \n            col = vec3(0.0);\n        \n            // key ligh\n            {\n                // dif\n                vec3 lig = normalize(vec3(1.0,0.0,0.7));\n                float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\n                float sha = calcSoftshadow( pos+0.0001*nor, lig, 0.0001, 2.0, 6.0 );\n                col += mate.xyz*dif*vec3(1.8,0.6,0.5)*1.1*vec3(sha,sha*0.3+0.7*sha*sha,sha*sha);\n\t\t\t\t// spec\n                vec3 hal = normalize(lig-rd);\n                float spe = clamp( dot(nor,hal), 0.0, 1.0 );\n                float fre = clamp( dot(-rd,lig), 0.0, 1.0 );\n                fre = 0.2 + 0.8*pow(fre,5.0);\n                spe *= spe;\n                spe *= spe;\n                spe *= spe;\n                col += 1.0*(0.25+0.75*mate.x)*spe*dif*sha*fre;\n            }\n\n            // back light\n           \t{\n                vec3 lig = normalize(vec3(-1.0,0.0,0.0));\n                float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\n                col += mate.rgb*dif*vec3(1.2,0.9,0.6)*0.2*mate.w;\n            }\n\n            // dome light\n            {\n                float dif = clamp(0.3+0.7*dot(nor,upp),0.0,1.0);\n                #if 0\n                dif *= 0.05 + 0.95*calcSoftshadow( pos+0.0001*nor, upp, 0.0001, 1.0, 1.0 );\n                col += mate.xyz*dif*5.0*vec3(0.1,0.1,0.3)*mate.w;\n                #else\n                col += mate.xyz*dif*3.0*vec3(0.1,0.1,0.3)*mate.w*(0.2+0.8*mate.w);\n                #endif\n            }\n            \n            // fake sss\n            {\n                float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n                col += 0.3*vec3(1.0,0.3,0.2)*mate.xyz*mate.xyz*fre*fre*mate.w;\n            }\n            \n            // grade/sss\n            {\n            \tcol = 2.0*pow( col, vec3(0.7,0.85,1.0) );\n            }\n            \n            // exposure control\n            col *= 0.7 + 0.3*smoothstep(0.0,25.0,abs(iTime-31.0));\n            \n            // display fake occlusion\n            //col = mate.www;\n        }\n        }\n    \n \n        // gamma\n        col = pow( col, vec3(0.4545) );\n    \n        tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // vignetting\n \tvec2 q = fragCoord/iResolution.xy;\n    tot *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltBWB.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[929, 929, 957, 957, 1113], [1145, 1213, 1272, 1272, 1430], [1432, 1502, 1556, 1556, 1661], [4655, 4719, 4764, 4764, 5317], [5319, 5381, 5468, 5468, 5862], [5864, 5864, 5935, 5935, 6200]], "test": "error"}
{"id": "lltBWM", "name": "Contour lines", "author": "8x", "description": "My attempt to create contour lines. First implementation was using a laplace filter matrix, now using fwidth. Thanks for your help! ", "tags": ["filter", "gradient", "sinus", "matrix", "fwidth", "laplace"], "likes": 18, "viewed": 1278, "published": "Public", "date": "1539887794", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float wave(float x, float y) \n{\n    return sin(10.0*x+10.0*y) / 5.0 +\n           sin(20.0*x+15.0*y) / 3.0 +\n           sin(4.0*x+10.0*y) / -4.0 +\n           sin(y) / 2.0 +\n           sin(x*x*y*20.0) + \n           sin(x * 20.0 + 4.0) / 5.0 +\n           sin(y * 30.0) / 5.0 + \n    \t   sin(x) / 4.0; \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float z = wave(uv.x, uv.y) + 2.0;\n    \n    \n    z *= 4.0 * sin(1.57 + iTime / 5.0);\n    float d = fract(z);\n    if(mod(z, 2.0) > 1.) d = 1.-d;\n     \n\n    d = d/fwidth(z);\n    fragColor = vec4(d);\n\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltBWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 304], [306, 306, 363, 413, 657]], "test": "valid"}
{"id": "lltczN", "name": "Dots, Spirals and Sound", "author": "Vovosunt", "description": "Same as the previous one but with audio animation.", "tags": ["2d", "sound", "fake3d"], "likes": 14, "viewed": 271, "published": "Public", "date": "1538404419", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define smooth (1.0 / iResolution.x)\n#define PI      3.14159265359\n#define lines 5.0\n#define rings 77.0\n#define swirl 2.0\n#define size 0.005\n#define poss 0.12\n#define widths 0.015\n#define time (iTime * 1.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = (fragCoord.xy -0.5 * iResolution.xy)/ iResolution.x;\n    float width = widths;\n    float pos = poss;\n    \n    vec2 mouse = (iMouse.xy -0.5 * iResolution.xy) / iResolution.x;\n    {\n        float a =(atan(st.x,st.y) + PI)/PI/2.;\n        float aa = (floor(a * rings) + 0.5)/rings;\n        aa = aa * 2.0 * PI - PI;\n        float ll = pos;\n\n        vec2 center = vec2(ll*sin(aa),ll*cos(aa));\n    \tfloat dist= texture(iChannel0,vec2(floor(a * rings)/rings,0.0)).x; \n    \t//float dist = length(center - mouse);\n        //dist = 1.0 - dist;\n        //dist = pow(dist,14.);\n        width = widths + 0.05 * dist;\n        pos += 0.1 * dist;\n    }\n    \n        \n    vec3 finCol = vec3(0.0);\n    float maxz = 0.0;\n    \n    \n    for(float i = 0.0; i < lines; ++i){\n    \n        float il = i /lines;\n        \n    \tfloat a =(atan(st.x,st.y) + PI)/PI/2.;\n    \tfloat aa = (floor(a * rings) + 0.5)/rings;\n    \taa = aa * 2.0 * PI - PI;\n    \tfloat offset = floor(a * rings)/rings * 2.0 * PI * swirl + il * 2.0 * PI;\n    \tfloat rt = cos(time + offset)/2.0 + 0.5;\n    \tfloat rm = sin(time + offset)/2.0 + 0.5;\n    \tfloat ll = mix(pos - width,pos + width,rt);\n    \n    \tvec2 center = vec2(ll*sin(aa),ll*cos(aa));\n\n        float ring = length(center - st);\n        ring = smoothstep(smooth,-smooth,ring -size *(1.0 +  rm)/2.0);\n        finCol = max(finCol,ring * (0.25 + rm)/1.25);\n    }\n    \n\tfragColor = vec4(finCol,1.0);\n}\n", "image_inputs": [{"id": "4s2XRd", "previewfilepath": "https://soundcloud.com/leagueoflegends/legends-never-die", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/leagueoflegends/legends-never-die", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltczN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 208, 265, 265, 1677]], "test": "error"}
{"id": "lltfD7", "name": "Metaeaux - Aurora", "author": "metaeaux", "description": "Playing around with audio-reactive visuals using some of my music on soundcloud: https://soundcloud.com/metaeaux/to-exist-is-to-wonder", "tags": ["aurora"], "likes": 17, "viewed": 1478, "published": "Public API", "date": "1539927870", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float quintic(float x) {\n \treturn x*x*x*(6.*x*x-15.*x+10.);\n}\n\nfloat fft(float p) {\n    return texture(iChannel0, vec2(p, 0.25)).x;\n}\n\nconst float fac = 43758.5453123;\n\nfloat hash(float p) {\n    return fract(fac*sin(p));\n}\n\nfloat noise(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    \n    float fac = 43758.5453123;\n    const float upper = 100.;\n    vec3 m = vec3(1., 10., 100.);\n    vec2 o = vec2(1., 0.);\n    \n    float n000 = hash(dot((i + o.yyy), m));\n    float n001 = hash(dot((i + o.xyy), m));\n    float n010 = hash(dot((i + o.yxy), m));\n    float n011 = hash(dot((i + o.xxy), m));\n    float n100 = hash(dot((i + o.yyx), m));\n    float n101 = hash(dot((i + o.xyx), m));\n    float n110 = hash(dot((i + o.yxx), m));\n    float n111 = hash(dot((i + o.xxx), m));\n    \n    float fx = quintic(f.x);\n    float fy = quintic(f.y);\n    float fz = quintic(f.z);\n    \n    float px00 = mix(n000, n001, fx);\n    float px01 = mix(n010, n011, fx);\n    \n    float px10 = mix(n100, n101, fx);\n    float px11 = mix(n110, n111, fx);\n    \n    float py0 = mix(px00, px01, fy);\n    float py1 = mix(px10, px11, fy);\n    \n    return mix(py0, py1, fz);\n}\n\n\nfloat noise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    vec2 m = vec2(100., 1.);\n    vec2 o = vec2(1., 0.);\n    \n    float n00 = hash(dot((i + o.yy), m));\n    float n01 = hash(dot((i + o.xy), m));\n    float n10 = hash(dot((i + o.yx), m));\n    float n11 = hash(dot((i + o.xx), m));\n    \n    float fx = quintic(f.x);\n    float px0 = mix(n00, n01, fx);\n    float px1 = mix(n10, n11, fx);\n    \n    return mix(px0, px1, quintic(f.y));\n}\n\nfloat ocean(vec2 p) {\n    float f = fft(abs(1.-p.x))*0.2 + fft(abs(p.x))*0.52;\n    \n    float speed = .8;\n    vec2 v01 = vec2( 1.,  0.) * iTime*speed;\n    vec2 v02 = vec2( 0.,  1.) * iTime*speed;\n    vec2 v03 = vec2( 1.,  1.) * iTime*speed;\n    vec2 v04 = vec2(-1.,  0.) * iTime*speed;\n    vec2 v05 = vec2(-1.,  0.) * iTime*speed;\n    vec2 v06 = vec2(-1., -1.) * iTime*speed;\n    \n    f += 0.50000*noise(p*1.0  + v01); //*fft(p.x);\n    f += 0.25000*noise(p*2.1  + v02);\n    f += 0.12500*noise(p*3.9  + v03);\n    f += 0.06250*noise(p*8.1  + v04);\n    f += 0.03215*noise(p*15.8 + v05);\n    f += 0.01608*noise(p*32.3 + v06);\n    \n    f = (3.-2.*f)*f*f;\n    \n    return f;\n    \n}\n\nfloat map(in vec3 p) {   \n    float o = ocean(p.xz * 0.08) * 3.;\n    return p.y + 0.5 + o;\n}\n\nfloat calcShadow(in vec3 ro, in vec3 rd, float tmax) {\n    float r = 1.;\n    float t = 0.;\n    for(int i = 0; i < 128; i++) {\n        float h = map(ro + t * rd);\n        r = min(r, tmax*h/t);\n        if (r < 0.01) break;\n        if (t > tmax) break;\n        t += h;\n    }\n    return clamp(r, 0., 1.);\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n    \n}\n\n\nconst vec3 SUN_DIR = normalize(vec3(-0.2, 0.15, -0.8));\nconst vec3 SUN_COL = vec3(0.95, 0.8, 0.85);\n\nvec3 sky(in vec3 rd, float fac) {\n    vec3 stars = pow(vec3(noise(rd.xy*iResolution.x)), vec3(90.));\n    rd.y = max(0., rd.y);\n    \n    vec3 blue = 0.6* vec3(0.02, 0.09, 0.2) -rd.y*0.12;\n    vec3 sunset = blue * (cos(fac * 6.28)*.7 + 1.); \n    return sunset + stars;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 1000.);\n    float an = 1.2;\n    vec3 up = normalize(vec3(cos(an), 1., sin(an)));\n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww, up));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    vec3 rd = normalize(vec3(p.x*uu + p.y*vv - 2.*ww));\n    \n    float m = -1.;\n    float t = 0.;\n    float tmax = 300.;\n    for(int i = 0; i<512; i++) {\n        float h  = map(ro + rd * t);\n        if ( h<0.01 ) { m = 1.; break; };\n        if ( t>tmax ) break;\n        t += h;\n    }\n    \n    float sunsetFac = mod(iTime*0.12 + fft(0.1), 1.);\n    vec3 skyCol = sky(rd, sunsetFac);\n    vec3 col = skyCol;\n\n    \n    vec3 vol = vec3(0.);\n    float den = 0.;\n    float h = noise(fragCoord+p);\n    float dh = 0.1*tmax / 32.0;\n    rd.y  = -rd.y;\n    rd.xz = rd.xz*mat2(0.8, -0.6, 0.6, 0.8);\n    for (int i = 0; i < 32; i++) {\n        vec3 pos = ro + h*rd;\n        vec3 dir = SUN_DIR - pos;\n        vec3 l = (vec3(0.1, 0.99, 0.1)*calcShadow(pos, normalize(dir), length(dir)));\n        float d = noise(pos + 2.*vec3(iTime, -iTime, -iTime));\n            \n        d *= exp(-0.85*pos.y);\n       \n        den += d*0.001;\n        vol += l*den;\n        \n        if(den > 1.) break;\n        \n        h += dh;\n    }\n    col += pow(vec3(vol), vec3(1.5));\n    \n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Mtf3zn", "previewfilepath": "https://soundcloud.com/metaeaux/to-exist-is-to-wonder", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/metaeaux/to-exist-is-to-wonder", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltfD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 61], [63, 63, 83, 83, 133], [169, 169, 190, 190, 222], [224, 224, 248, 248, 1148], [1151, 1151, 1175, 1175, 1606], [1608, 1608, 1629, 1629, 2283], [2285, 2285, 2307, 2307, 2377], [2379, 2379, 2433, 2433, 2681], [2683, 2683, 2711, 2711, 2904], [3008, 3008, 3041, 3041, 3276], [3279, 3279, 3336, 3336, 4773]], "test": "error"}
{"id": "lltfDN", "name": "Basket Weavers", "author": "PianiGiani", "description": "Another experiment with lines and loops", "tags": ["flow", "shapes", "movement"], "likes": 7, "viewed": 179, "published": "Public", "date": "1539727829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n#define WD 2.\n#define nTime (iTime*0.3)+5000.\n#define FACT vec2(0.3,0.13)\n\nfloat Dline(vec2 p, vec2 a, vec2 b) {\n\t// line drawing function from BigWings\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.1);\n    return length(pa-ba*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    \n    float param = asin(cos(float(iFrame)/4000.))*20.; // triangular parameter\n    \n    for ( float i = 0.; i<7.; i+=0.1)\n    {\n    for ( float ii = 14.; ii<20.; ii+=0.5)\n    {\n    float d1 = sin(nTime-ii)-cos(i+nTime+param);\n    float d2 = sin(nTime-i)+cos(ii+i)-sin(ii);\n    float d3 = sin(nTime-ii)+cos(i+nTime-param);\n    float d4 = sin(nTime-i)-cos(ii+i)+sin(ii-param);\n    \n    float d = Dline(uv, vec2(d1,d2)*FACT, vec2(d3,d4)*FACT);\n\n    float m = S(WD/200., (WD/200.)-(0.02), d)*WD;\n    \n    float col1 = (cos(nTime+ii)/2.+0.6);\n    float col2 = (sin((ii+nTime))/2.+0.5);\n   // float col3 = (cos((i+nTime)/9.)/ii+0.5);\n        \n    col = max(col,vec3(m*col1,m*col2,m*col2));\n    }\n    }\n    \n    // Output to screen\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltfDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 147, 187, 309], [312, 312, 369, 419, 1300]], "test": "valid"}
{"id": "lltfRj", "name": "Hilbert 3D", "author": "dr2", "description": "3D Hilbert curves", "tags": ["fractal", "curve"], "likes": 40, "viewed": 1202, "published": "Public API", "date": "1540321917", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Hilbert 3D\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// 3D Hilbert curves (algorithm derived from al13n's \"Space Filling Curve\")\n\n#define AA  0\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nvec3 HsvToRgb (vec3 c);\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\n\nvec3 ltPos, qHilb;\nfloat dstFar, tCur, szFac, cFac, vShift, zDisp;\nint idObj, nIter;\nbool doSh;\nconst int maxIter = 5;\nconst float pi = 3.14159, sqrt3 = 1.73205;\n\nvec3 HilbCrv (vec3 p)\n{\n  vec3 s;\n  vec2 cv;\n  float lLen, cLen, dp, xRev, zRev, zAdd;\n  cLen = 1. / (2. * cFac - 1.);\n  lLen = cFac * cFac * (1. - ((1. - 0.25 * pi) * cFac - 1.) * cLen);\n  dp = 1. + cLen;\n  xRev = 1.;\n  zRev = 1.;\n  zAdd = 0.;\n  for (int j = 0; j < maxIter; j ++) {\n    lLen *= 0.125;\n    dp *= 0.5;\n    s = sign (p);\n    zAdd += lLen * zRev * s.z * (4. - s.y * (2. - s.x));\n    if (s.x > 0.) p = p.zxy * vec3 (- s.z, 1., - s.y);\n    else if (s.y > 0.) p = p.yxz * vec3 (-1., -1., - s.z);\n    else if (s.z > 0.) p = p.yzx * vec3 (1., -1., 1.);\n    else p = p.zyx;\n    p += dp * vec3 (1., ((s.x + s.y < 0.) ? 1. : -1.), 1.);\n    if (s.x + s.z < 0.) xRev = - xRev;\n    else if (s.x > 0.) {\n      if (s.y != s.z) zRev = - zRev;\n    } else zRev = - zRev;\n    if (j == nIter - 1) break;\n  }\n  cv = vec2 (p.y, - p.z) + cLen;\n  if (min (cv.x, cv.y) > 0.) p.yz = vec2 (length (cv) - cLen, (atan (cv.x, cv.y) - 0.25 * pi) * cLen);\n  else if (p.y + p.z < 0.) p.yz = p.zy * vec2 ( -1., 1.) + vec2 (0., (1. - 0.25 * pi) * cLen);\n  else p.z -= (1. - 0.25 * pi) * cLen;\n  p.xz *= vec2 (xRev, zRev);\n  p.z += zAdd;\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, w;\n  q = p / szFac;\n  q.y -= vShift;\n  q.xz = Rot2D (q.xz, pi + 0.25 * pi * sin (0.03 * 2. * pi * tCur));\n  q = RotToDir (vec3 (-1., 1., 1.) / sqrt3, vec3 (0., 1., 0.), q);\n  w = 0.5 / cFac;\n  d = PrRoundBoxDf (q, vec3 (1. - 0.26 * w), 0.01);\n  if (doSh || d < 0.1) {\n    qHilb = HilbCrv (q);\n    q = qHilb;\n    q.z = mod (q.z + zDisp, w) - 0.5 * w;\n    d = max (d, min (PrRoundBox2Df (q.xy, vec2 (0.1 * w), 0.05 * w), PrSphDf (q, 0.4 * w)));\n    idObj = 1;\n  }\n  dMin = 0.7 * szFac * d;\n  q = p;\n  q.y -= 0.02;\n  d = PrCylDf (q.xzy, 0.8, 0.02);\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  doSh = true;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, ltDir;\n  float dstObj, dstGrnd, vdl, sh, att, h;\n  cFac = pow (2., float (nIter));\n  zDisp = 1. * tCur / cFac;\n  szFac = 1. + 0.8 / cFac;\n  vShift = (sqrt3 - 1.3 / cFac) + 0.04;\n  doSh = false;\n  dstObj = ObjRay (ro, rd);\n  dstGrnd = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  if (min (dstObj, dstGrnd) < dstFar) {\n    ltDir = normalize (ltPos);\n    if (dstObj < dstGrnd) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      vdl = max (dot (vn, ltDir), 0.);\n      h = 0.05 * zDisp * cFac;\n      if (idObj == 1) h += 0.5 + 0.5 * qHilb.z / (cFac * cFac);\n      if (idObj == 1 || length (ro.xz) < 0.6) {\n        col = HsvToRgb (vec3 (mod (h, 1.), 1., 1.));\n        vdl *= vdl * vdl;\n      } else col = vec3 (0.5);\n    } else {\n      ro += dstGrnd * rd;\n      vn = vec3 (0., 1., 0.);\n      col = vec3 (0.4) * (0.7 + 0.3 * Fbm2 (4. * ro.xz));\n      vdl = max (dot (vn, ltDir), 0.);\n    }\n    att = smoothstep (0.9, 0.95, dot (normalize (ltPos - ro), ltDir));\n    sh = ObjSShadow (ro, ltDir);\n    col = att * (col * (0.2 + 0.8 * sh * vdl) +\n       0.2 * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.));\n  } else col = vec3 (0.);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, ltEl, ltAz, ns;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.25 * pi, 0.05 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., sqrt3, -10.);\n  zmFac = 5. + 10. * abs (az) / pi;\n  ltEl = -0.2 * pi * (1. + 0.2 * sin (0.2 * 2. * pi * tCur));\n  ltAz = pi + 0.2 * pi * cos (0.25 * 2. * pi * tCur);\n  ltPos = vec3 (0., 0., 20.);\n  ltPos.yz = Rot2D (ltPos.yz, ltEl);\n  ltPos.xz = Rot2D (ltPos.xz, ltAz);\n  dstFar = 100.;\n  ns = mod (0.25 * tCur, float (2 * (maxIter - 1) - 1));\n  nIter = 2 + int (min (ns, 2. * float (maxIter - 1) - ns));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p)\n{\n  vec3 n;\n  float c;\n  n = normalize (cross (v1, v2));\n  c = dot (v1, v2);\n  return c * p + sqrt (1. - c * c) * cross (n, p) + (1. - c) * dot (n, p) * n;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltfRj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[659, 659, 682, 682, 1790], [1792, 1792, 1814, 1814, 2446], [2448, 2448, 2481, 2481, 2658], [2660, 2660, 2681, 2681, 2881], [2883, 2883, 2920, 2920, 3157], [3159, 3159, 3194, 3194, 4377], [4379, 4379, 4435, 4435, 5822], [5824, 5824, 5870, 5870, 5917], [5919, 5919, 5966, 5966, 6013], [6015, 6015, 6048, 6048, 6075], [6077, 6077, 6119, 6119, 6170], [6173, 6173, 6197, 6197, 6319], [6321, 6321, 6363, 6363, 6519], [6521, 6521, 6551, 6551, 6664], [6698, 6698, 6722, 6722, 6852], [6854, 6854, 6879, 6879, 7065], [7067, 7067, 7088, 7088, 7243]], "test": "error"}
{"id": "lltfRS", "name": "bubblebutt", "author": "shi", "description": "-", "tags": ["outlands"], "likes": 1, "viewed": 50, "published": "Public", "date": "1540128602", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*32.0;\n\n    // Time varying pixel color\n    vec3 a = 0.5 + 1.0*sin(iTime+uv.yyy+vec3(0,2,4));\n    a += sin(iTime+uv.xyy+vec3(0,2,4));\n    a += cos(iTime+uv.yxy+vec3(0,1,4));\n\n    // Output to screen\n    fragColor = vec4(a,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltfRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 375]], "test": "valid"}
{"id": "lltfWS", "name": "raymarched heart", "author": "Benstyle", "description": "a small heart", "tags": ["raymarching"], "likes": 0, "viewed": 72, "published": "Public", "date": "1540913128", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define maxStep 512\n#define epsilon 0.0001\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvec2 rot2D(vec2 v, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    \n    return mat2(c,-s,s,c)*v;\n}\n\n\nfloat smoothAbs(float x)\n{\n    \n    return sqrt(x*x + 0.01);\n    \n}\n\n///// Fonctions de distance ///\n\nfloat forme( vec3 p, vec3 o, float r )\n{\n \tvec3 u = p - o;\n    \n    \n    u.y += -1.8*smoothAbs(u.x)*((23.+smoothAbs(u.x))/100.);\n    \n    u.z *= 1.5;\n    \n    \n    \n    float os = sin(2.*iTime + 0.9*p.y);\n    r = r+ os*os*os*os*.1;\n    \n    \n    return length( u) - r;\n}\n\nfloat sol(vec3 p, vec3 o)\n{\n return p.y - o.y;   \n}\n\nfloat sphere(vec3 p, float r)\n{\n return length(p)-r;   \n}\n\n\n///////\n\n\n\nfloat map(vec3 p) // ici on met en place la scène    \n{\n    \n    \n    \n    vec2 pRot = rot2D(p.xz, p.y/4. + iTime);\n    \n    \n    \n    float d1 = forme(vec3(pRot.x, p.y, pRot.y), vec3(0.), 1.);\n    \n    \n    \n    float d2 = sol(p, vec3(0.,-1.3,0.));\n    \n    \n    \n    \n    return min(d1,d2);\n}\n\n\n\n/// fonction de raymarching ( on recherche une intersection )\n\n\nvec3 intersection(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    \n    float d = 0.;\n    \n    for(int i = 0; i <= maxStep; i++)\n    {\n        \n        d = map(ro + t*rd);\n        \n        if (d < epsilon) /// si on est trop près, on s'arrête\n        {\n            break;\n        }\n        \n        t += d;\n        \n          \n        \n    }\n\n\n\n\treturn ro + t*rd; /// on renvoie l endroit ( approché ) d une intersection\n}\n\n\nvec3 normale(vec3 p )\n{\n    vec3 u = vec3(0.);\n    vec3 a = vec3(1.,0.,0.);\n    vec3 b = vec3(0.,1.,0.);\n    vec3 c = vec3(0.,0.,1.);\n    u.x += map(p + epsilon*a) - map(p - epsilon*a);\n    u.y += map(p + epsilon*b) - map(p - epsilon*b); ///on calcule la normale du point considéré\n    u.z += map(p + epsilon*c) - map(p - epsilon*c);\n    \n    \n    \n\treturn normalize(u);\n}\n\n\n\n\n //definition des lumieres\n\nvec3 l1Pos = vec3(2.,2.,3.);\nvec3 l1Int = vec3(0.8,0.,0.);\n\n/// ici on définit une fonction d ombre\n\nfloat smoothShadow(vec3 p, vec3 lPos, vec3 lInt)\n{\n    vec3 rd = normalize(lPos - p);\n    \n    \n    vec3 pImp = intersection(p + rd , rd); //on envoie un rayon jusqu'à la source de lumière et on regarde si il y arrive\n    \n    float d = length(lPos - p);\n    \n    if(map(pImp) > 10.*epsilon)\n       {\n           return 0.;\n       }\n     return 0.8/d; \n    \n}\n\n\n///on définit un matériau pour la scène\nvec3 BaseShading(vec3 p, vec3 ro)\n{\n    vec3 n = normale(p);\n    \n    vec3 col = vec3(0.);\n     \n    \n    \n    \n    if (map(p) < epsilon)\n    {\n        vec3 l1 = normalize(l1Pos - p); /// vecteur unitaire dirigé vers la source de lumière 1\n        vec3 rop = normalize(ro-p); /// vecteur unitaire dirigé vers la caméra\n        \n        float d = dot(l1, n) + 1.;\n        \n        d = (d+1.)/2.;\n        \n        col += max(0., d-.5) * l1Int; //diffuse simple\n        \n        ///spec\n        \n        vec3 reflet = (l1 - 2.*dot(l1,n)*n); //calcul du rayon réfléchi\n        \n        float a =  max(0.,dot(-reflet,rop));\n        //a = a*a;\n        a = a*a;\n        \n        col += a*.5;\n        \n        \n                    \n        col += (vec3(0.8,1.,1.) - dot(rop,n)) * .8; //bords blancs\n        \n        \n        \n        \n        col -= smoothShadow(p, l1Pos, l1Int);\n        \n        \n        \n        \n        return col;\n        \n    }\n    \n    \n    return vec3(0.);\n}\n\n\n\n    \n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy -.5;\n    \n    float ratio = iResolution.x/iResolution.y;\n    \n    uv.x *= ratio;\n\n    \n    vec3 ro = vec3(0.,0.,4.);\n    \n    vec3 rd = normalize(vec3(uv.xy, -1.));\n    \n    \n    \n    \n    vec3 inter = intersection(ro, rd);\n    \n    \n    \n    \n    \n    vec3 col = BaseShading(inter,ro);\n    \n    col *= smoothstep(1.,0.3, length(uv.xy ));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltfWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 88, 88, 168], [171, 171, 197, 197, 238], [273, 273, 313, 313, 543], [545, 545, 572, 572, 596], [598, 598, 629, 629, 655], [669, 669, 725, 725, 964], [1032, 1032, 1069, 1069, 1450], [1453, 1453, 1476, 1476, 1827], [1962, 1962, 2012, 2012, 2322], [2325, 2368, 2403, 2403, 3350], [3365, 3365, 3422, 3422, 3868]], "test": "valid"}
{"id": "lt3BD4", "name": "Midterm Shader", "author": "cjramsden", "description": "Moving 'eclipse' over a yellow sun", "tags": ["shader", "midterm"], "likes": 0, "viewed": 170, "published": "Public", "date": "1539618430", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Moon Variables\nvec2 moonPos = vec2(0.45,0.5);\nfloat moonRadius = 0.35;\nconst float ECLIPSE_FREQ = 0.3;\nconst float ECLIPSE_MAGN = 0.4;\n\n// Sun Variables\nvec2 sunPos = vec2(0.35,0.5);\nfloat sunRadius = 0.3;\n\n// All Other Variables\nconst float SMOOTH_BY = 0.01;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n// Normalized pixel coordinates (from 0 to 1)\nvec2 uv = fragCoord/iResolution.xy;\n// x-focused aspect ratio\nfloat aspectRatio = iResolution.x/iResolution.y;\n// Correcting UV, circle positions by the Aspect Ratio\nuv.x *= aspectRatio;\nsunPos.x *= aspectRatio;\nmoonPos.x *= aspectRatio;\n// Creates a 'horizon' effect for the background\nvec3 horizon = vec3(1.0,uv.y,0.0);\n\n// Layer Setup\nvec4 BGLayer = vec4(horizon,1.0);\nvec4 LayerOne = vec4(0.0,0.0,0.0,0.0);\nvec4 LayerTwo = vec4(0.0,0.0,0.0,0.0);\n\n// Makes the moon / eclipse animate\nmoonPos.x += sin(iTime*ECLIPSE_FREQ)*ECLIPSE_MAGN;\n// Creates the sun and moon circles\nfloat sun = smoothstep(sunRadius, sunRadius+SMOOTH_BY,distance(sunPos,uv));\nfloat moon = smoothstep(moonRadius, moonRadius+SMOOTH_BY, distance(moonPos,uv)); \n    \n// Draws Layer One (The Sun) and Layer Two (The Eclipse / Moon)\nLayerOne = vec4(1.0,0.9,0.2, moon);\nLayerTwo = vec4(horizon,sun);\n\n// Overlays the Sun over the Background\nvec4 outColor = mix(BGLayer,LayerOne,LayerOne.a);\n// Overlays the Eclipse over the Sun\noutColor = mix(outColor, LayerTwo, LayerTwo.a);\n\n// Output to screen\nfragColor = outColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3BD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[264, 264, 321, 367, 1455]], "test": "valid"}
{"id": "lt3BRf", "name": "eye ball", "author": "mastersun", "description": "not finished yet", "tags": ["eyeball"], "likes": 3, "viewed": 131, "published": "Public", "date": "1540426305", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n        (c - a)* u.y * (1.0 - u.x) +\n        (d - b) * u.x * u.y;\n}\nmat2 m = mat2(0.8, 0.6, -0.6, 0.8);\nfloat fbm(vec2 p) {\n\tfloat f = 0.0;\n    f += 0.5 * noise(p); p *= m * 2.0;\n    f += 0.25 * noise(p); p *= m * 2.0;\n    f += 0.125 * noise(p); p *= m * 2.0;\n    f += 0.0625 * noise(p); p *= m * 2.0;\n    f /= 0.9375;\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = 2./iResolution.y;\n\tvec2 uv = (fragCoord - 0.5 * iResolution.xy)*2.0 / iResolution.y;\n    float radius = 0.7;\n   \tfloat r = length(uv);\n    \n    float ss = 0.5 + 0.5 * sin(3.5 * iTime);\n    float anim = 1. + 0.2 * ss * clamp(1. - r, 0., 1.);\n    r *= anim;\n    \n    vec3 col = vec3(1., 1., 1.);\n    if (length(uv) < radius) {\n        col = vec3(0.31, 0.235, 0.043);\n        float angle = atan(uv.y / uv.x);\n        angle += 0.05 * fbm(20.0 * uv);\n        col = mix(col, vec3(0.682, 0.475, 0.113), fbm(vec2(r, angle * 0.3)));\n        \n        float white_fiber = smoothstep(0.3, 1.0, fbm(vec2(r * 6., angle * 20.)));\n        col = mix(col, vec3(1., 1., 1.), white_fiber);\n        \n        float black_fiber = smoothstep(0.3, 1.0, fbm(vec2(r * 7., angle * 15.)));\n        col = mix(col, vec3(0.3, 0.3, 0.3), black_fiber);\n        float outter_pupil = smoothstep(0.12, 0.35, r);\n        col = mix(vec3(0.9, 0.6, 0.2), col, outter_pupil);\n        float pupil = smoothstep(0.12 - 5. * e, 0.12 + 5. * e, r);\n        col = mix(vec3(0.094, 0.063, 0.0078), col, pupil);\n        \n        float f = smoothstep(radius - 0.3, radius, r);\n        col *= 1. - 0.5 * f;\n              \n        float border = smoothstep(radius - 0.1, radius, r);\n    \tcol = mix(col, vec3(1., 1., 1.), border);\n        \n        float high_light = smoothstep(0.35, 0., length(uv - vec2(0.15, 0.2)));\n        col = mix(col, vec3(0.9), high_light);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3BRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 13, 40, 40, 157], [159, 246, 272, 272, 749], [786, 786, 805, 805, 1016], [1018, 1018, 1075, 1075, 2543]], "test": "valid"}
{"id": "lt3BRs", "name": "Cemetery ", "author": "tqle", "description": "Environment, halls of Vahalla. Tribute to Vikings", "tags": ["environment"], "likes": 4, "viewed": 108, "published": "Public", "date": "1540822600", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define repeat(v, r) (mod(v, r)-r/2.)\n//construct Shape class\nstruct Shape {\n  float dist;\n  vec4 color;\n};\n//repeating variables, coordinates, shapes. Replaces repeat()\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}       \nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}       \nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n//rotating shapes using matrix/linear algebra\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n//creates a pole\nfloat pole(vec2 v, float r){\n  return length(v)-r;\n}\n//creates a sphere\nfloat sphere(vec3 v, float r){\n  return length(v) - r;\n}\n//creates a box\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n//creats a ring\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n//unionizes shapes, making stairs from intersection\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b - r;\n\treturn min(min(a,b), 0.5*(u + a + abs((mod(u - a + s, 2.*s)) - s)));\n}\n//\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\nfloat mixColors(float r, float v, float z) {\n  return clamp(0.5 + 0.5*(v - r)/z, 0., 1.);\n}\nfloat mixShapes(float v, float f, float r) {\n  float z = mixColors(v, f, r);\n  return mix(f, v, z) - r*z*(1. - z);\n}\nfloat pModPolar(inout vec2 v, float r) {\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x) + f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f) - f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\nfloat opTwist(vec3 p) {\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return float(q);\n}\nfloat sdEllipsoid(in vec3 p, in vec3 r) {\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0 - 1.0)/k1;\n}\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\nfloat sdCappedCylinder(vec3 p, vec2 h) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nvec3 mod289(vec3 x) { return x - floor(x*(1.0/289.0))*289.0; }\nvec2 mod289(vec2 x) { return x - floor(x*(1.0 / 289.0))*289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0) + 1.0)*x); }\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v - i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute(i.y + vec3(0.0, i1.y, 1.0))\n        + i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m;\n    m = m*m;\n    vec3 x = 2.0*fract(p*C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314*(a0*a0 + h*h);\n    vec3 g;\n    g.x  = a0.x*x0.x + h.x*x0.y;\n    g.yz = a0.yz*x12.xz + h.yz*x12.yw;\n    return 130.0*dot(m, g);\n}\nShape animation(vec3 c){\n  Shape shape; \n  vec4 color = vec4(1.134, .25, .25, 1.);  \n  //INSTANTIATING, MODDING VECS\n  vec3 lan = c;\n    lan.z = repeat(lan.z, 5.);\n    lan.x = repeat(lan.x, 4.);\n    lan.x = abs(lan.x) - .75;\n  //EVALUATING VECS\n  vec3 hal = c;\n\tpMod1(hal.z, 10.);\n  vec3 bod = c;\n    pMod1(bod.z, 10.);\n  vec3 or = c;\n    pMod1(or.z, 10.);\n  vec3 ortwo = c;\n    pMod1(ortwo.z, 10.);\n  vec3 fr = c;\n    pMod1(fr.z, 15.);\n  vec3 doo = c;\n    pMod1(doo.z, 15.);\n  vec3 dootwo = c;\n    pMod1(dootwo.z, 15.);\n  float lantern = sdCappedCylinder(lan - vec3(.5*cos(iTime)*sin(iTime), .5*sin(iTime), 0.), vec2(.1, .09));\n  float halo = sdTorus(hal - vec3(0., 2., 0.), vec2(.25, .01));\n  float body = fCone(bod - vec3(0., -.5, 0.), .1, 3.);\n  float orb = sphere(or - vec3(.025 + sin(iTime), 2.75 - cos(iTime), 0. + sin(iTime)*2.), .1);\n  float orbtwo = sphere(or - vec3(-0.025 + cos(iTime), 0. - sin(iTime), 0. + sin(iTime)*2.), .1);\n  float frame = fBox(fr - vec3(1., 0., 0.), vec3(.25, .5, .1));\n  float door = fBox(doo - vec3(1., 0., 0.), vec3(.2, .45, .1));\n  float doortwo = fBox(doo - vec3(1., 0., 0.), vec3(.15, .4, .1));\n  \t\n  \n  //MIXING SHAPES\n  shape.dist = lantern;\n  shape.dist = min(shape.dist, halo); \n  shape.dist = min(shape.dist, body);\n  //shape.dist = fOpUnionStairs(shape.dist, orb, .1, 3.);\n  shape.dist = min(shape.dist, orb);\n  //shape.dist = fOpDifferenceStairs(shape.dist, orbtwo, .1, 5.);\n  shape.dist = min(shape.dist, orbtwo);\n  shape.dist = fOpUnionStairs(shape.dist, frame, .1, 2.);\n  shape.dist = fOpDifferenceStairs(shape.dist, door, .1, 2.);\n  shape.dist = fOpDifferenceStairs(shape.dist, doortwo, .1, 2.);\n  //INSTANTIATING, MODDING COLORS\n  vec4 lanCol = vec4(sin(iTime), 10.*lan.x*cos(iTime), 0., 1.);\n    \n  vec4 bodCol = vec4(1., 1., 1. + cos(iTime)*.5, 1.);\n  vec4 halCol = bodCol;\n  vec4 orCol = vec4(1. * cos(iTime)*10., 24./255., 1./255., 1.);\n  vec4 orTwoCol = orCol;\n  vec4 frCol = vec4(fr.x + sin(iTime) + 244./255., fr.y*cos(iTime) - 10./255., cos(fr.y*fr.x*iTime) + 1./255., 1.);\n  //shape.color = lanCol;\n  shape.color = mix(lanCol, bodCol, mixColors(body, lantern, 0.));\n  shape.color = mix(shape.color, orCol, mixColors(orb, shape.dist, 1.));\n  shape.color = mix(shape.color, orTwoCol, mixColors(orbtwo, shape.dist, 1.));\n  shape.color = mix(shape.color, frCol, mixColors(frame, shape.dist, 1.));\n    lanCol.rg += snoise(lan.xy*.1) + .5*sin(iTime);\n    lanCol.gb -= snoise(lan.yz*.25) + cos(iTime);\n  //MIXING COLORS\n    \n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape anim = animation(c);\n  return anim;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\n  \n  vec3 cam = vec3(1., .75, iTime);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(0.);\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); \n    if(c.dist < 0.001){\n      fragColor = c.color*(1. - z); \n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3BRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 170, 210, 210, 331], [339, 339, 359, 359, 384], [385, 385, 405, 405, 440], [442, 442, 462, 462, 507], [515, 515, 537, 537, 604], [605, 651, 669, 669, 739], [740, 757, 785, 785, 809], [810, 829, 859, 859, 885], [886, 902, 930, 930, 1011], [1012, 1028, 1059, 1059, 1129], [1130, 1182, 1240, 1240, 1346], [1347, 1350, 1415, 1415, 1456], [1457, 1457, 1520, 1520, 1560], [1561, 1561, 1609, 1609, 1694], [1695, 1695, 1739, 1739, 1786], [1787, 1787, 1831, 1831, 1903], [1904, 1904, 1944, 1944, 2104], [2105, 2105, 2128, 2128, 2271], [2272, 2272, 2313, 2313, 2404], [2405, 2405, 2454, 2454, 2952], [2953, 2953, 2993, 2993, 3092], [3093, 3093, 3114, 3114, 3155], [3156, 3156, 3177, 3177, 3220], [3221, 3221, 3243, 3243, 3280], [3281, 3281, 3303, 3303, 4323], [4324, 4324, 4348, 4348, 6821], [6824, 6824, 6842, 6842, 6888], [6890, 6890, 6947, 6947, 7310]], "test": "error"}
{"id": "lt3BRX", "name": "Breathing Fractal 149 Characters", "author": "mathmasterzach", "description": "Move the mouse!\nA variant of my fractal here https://www.shadertoy.com/view/4ttBWM that uses the same formulas but changes the exponents x^2+y^2 to various other values around 2.\nAs always, let me know if you have any ideas to reduce the character count.", "tags": ["2d", "fractal", "monochrome", "codegolf", "breathing"], "likes": 8, "viewed": 552, "published": "Public API", "date": "1540405267", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by @mathmasterzach\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//coyote optimizes the shader length further to arrive at 149 characters!\n/*#define mainImage(o,p)\\\n    for( vec2 r = iResolution.xy, q = 2.*(p+p-r)/r.y; o.a++ < 20.; )\\\n        o += length( q = abs(q)/dot(pow(q,2.+.3*sin(iTime+o.aa)),p/p) - iMouse.xy/r) / 70.*/\n\n//GregRostami does it again! 154 Characters! Wow!\n/*#define mainImage(o,p)\\\n    for( vec2 r = iResolution.xy, q = 2.*(p+p-r)/r.y; o.a++ < 20.; )\\\n        o += length( q = abs(q)/dot(pow(q,vec2(2.+.3*sin(iTime+o.a))),p/p) - iMouse.xy/r) / 70.*/\n\n//Smallest version with NVIDIA fix. 152 Characters. Thanks coyote!\nvoid mainImage(out vec4 o, vec2 p) {\n    for(\n         vec2 r = iResolution.xy, q = 2.*(p+p-r)/r.y;\n         o.a++ < 20.;\n         o += length( q = q/dot(pow(q,2.+.3*sin(iTime+o.aa)),r/r) - iMouse.xy/r ) / 70.\n       )\n        q = abs(q); }\n\n//My initial version, 158 Characters\n//The dot product in this one works to add the components of a Vector2\n/*#define mainImage(o,p)                                                    \\\n    for( vec2 r = iResolution.xy, q = 2.*(p+p-r)/r.y; o.a++ < 20.; )      \\\n        o += length( q = abs(q)/dot(pow(q,vec2(2.+.3*sin(iTime+o.a))),vec2(1)) - iMouse.xy/r) / 7e1*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3BRX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[627, 694, 730, 730, 934]], "test": "valid"}
{"id": "lt3BW8", "name": "distort square", "author": "dots19", "description": "distort square", "tags": ["2d", "sdf", "distortion", "square"], "likes": 11, "viewed": 175, "published": "Public", "date": "1539337688", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n#define TWOPI PI*2.0\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 norm = 2.0*(fragCoord.xy-0.5*iResolution.xy)/iResolution.xy;\n    \n\t\n    vec2 boxcd=rotate(uv, iTime/12.0);\n    vec2 displace;\n    displace.x = sin(iTime*6.0+(boxcd.x*TWOPI*2.0));\n    displace.y = cos(iTime*8.0+(boxcd.y*TWOPI*2.0));\n    \n    //float box=sdBox(boxcd, vec2((cos(iTime)*0.5+0.5)*0.2));\n    float box=sdBox(boxcd, vec2(0.3));\n    box+=(displace.x*displace.y)*cos(iTime)*1.2;\n    \n    float circle=clamp(0.0, 1.0, sdCircle(uv, 0.));\n    \n    float thickness = 0.1;\n    float wireframe = smoothstep(thickness, thickness+0.15, abs(box));\n    \n    vec3 bg1 = vec3(0.364,0.496,0.500);\n    vec3 bg2 = vec3(0.171,0.233,0.235);\n    vec3 background = mix(bg1, bg2, pow(norm.x, 2.0)+pow(norm.y, 2.0));\n    vec3 fg1 = vec3(0.98, 0.93, 0.9);\n    vec3 fg2 = vec3(0.569,0.740,0.726);\n    vec3 foreground = mix(fg1, fg2, pow(norm.x, 2.0)+pow(circle, 2.0));\n    \n    vec3 col = mix(foreground, background, wireframe);\n\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3BW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 72, 72, 156], [158, 158, 195, 195, 279], [281, 281, 316, 316, 342], [344, 344, 401, 401, 1427]], "test": "valid"}
{"id": "lt3Bzs", "name": "pmod extension interval-bound", "author": "ollj", "description": "iMouse.x sets sphere period (distance.x between spheres)\niMouse.y sets MAX number of spheres\n\nOR there is bounding interval for the middle line.", "tags": ["conveyor", "bound", "pmod", "mstretch", "kerning", "inverval", "followpath"], "likes": 4, "viewed": 430, "published": "Public API", "date": "1540607448", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this hand fan polar symmetry was done by gaz before, similar but different\n//https://www.shadertoy.com/view/4tXGDS\n// https://www.shadertoy.com/view/4tX3DS\n//but it did not use an explicir pmox-subroutine\n\n/*\n//this shader improves on pModInterval\nparent: https://www.shadertoy.com/view/4ttyDN\nby adding a bound to pModInterval\nthis is needed for conveyor-arcs/chains/BookBinding as in\nincomplete: https://www.shadertoy.com/view/4l3Bzs\n\nproblem:\n- flipping/moving pages of a book, or items on a conveyor belt\n- should use mod() folding\n- simple approach is only c1 continuous, it shows in the border.\n- to flatten pages on the top arch, i would still need a long mod() neighborhood.\n- - looping over the whole round top half may still be simpler and faster.\n\n- just normalizing a vector field of isoline-pages would likely much simpler here.\n- ,but not stretching the uvw map on that one\n- would involve arclength() calculations aslongside isolines.\n- - quadratic Bezier (20s cartoon kinematic) knee() function would likely be just fine.\n\nthis function can make an array of dots follow along a segmented path\n, like dots that move around the corners of an F-shape.\nyou just have to get the phase right.\nand then you can hash colors via (hash(r.y)) textureID\n\npModR with bound does not behave too well for negative periods (support for that is hacky and bad)\npModR with bound also hints at how you can use a hash to make some dots invisible\n, by shifting their (r.y) identity to (floor(r.y)-floor(n)), and offsetting their fract() gradient equally.\n\n*/\n\n//_start_ constant irrationals\n#define pib acos(0.)\n#define pi acos(-1.)\n#define tau pi*2.\n//float tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n//eul=exp(1.)???\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(),good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n\n//__end__ constant irrationals\n//_start_ basics\n\n#define ve0 float\n#define ve1 vec2\n#define ve2 vec3\n#define ve3 vec4\n#define norma normalize\n#define dd(a) dot(a,a)\n#define u2(a) ((a)*2.-1.)\n#define u5(a) ((a)*.5+.5)\n#define sat(x)clamp(x,0.,1.)\n#define cosu5(a) u5(cos(a))\n\n#define viewZoom(t,u,r,m) 9.\n#define Aa(t,u,r,m) min(r.x,r.y)\n//(hl2(r)/floor(mix(1.,hl2(r)*.1,u5(-cos(t)))))\n//viewZoom() returns a float; is defined in a local channel context, to quickly modify its scaling\n//divide by/aa for hairline drawing and sharp smoothstep()\n//fta insists on TURM-parameters because it contains Viewzoom(), that (locally) insists on TURM\n#define fra(t,u,r,m) (u-.5*r.xy)*viewZoom(t,u,r,m)/(r.y)\n\n\n\nve0 ad(ve3 a){return dot(ve3(1),a);}ve0 ad(vec3 a){return dot(ve2(1),a);}ve0 ad(vec2 a){return a.x+a.y;}//add vector components\n//for deferred shading IDs:\n#define minx(a,b) mix(b,a,step(a.x,b.x))\n#define manx(a,b) mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b) -minx(-a,-b)\n\nfloat ss(float a,float b){return smoothstep(b,-b,a);}\nvec2 ss(vec2 a,float b){return smoothstep(b,-b,a);}\nvec3 ss(vec3 a,float b){return smoothstep(b,-b,a);}\nvec4 ss(vec4 a,float b){return smoothstep(b,-b,a);}\n#define aA(t,u,r,m) min(r.x,r.y)\n\n\n//rgba colorspace matrices\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nvec3 rainbow(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbowt(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbow(float a){return rainbow(a,1./3.);}\nvec3 rainbowt(float a){return rainbowt(a,1./3.);}\n#define ToRgb(a) return c.z*mix(vec3(1.),sat(a(-c.x)),c.y);}\nvec3 angleToColor(vec3 c){ToRgb(rainbow)//cos-mix\n//vec3 hsv2rgb(vec3 c){ToRgb(rainbow2)//linear-mix not identical to the below, but close\nvec3 hsv2rgb(const vec3 c){return c.z*mix(vec3(1),sat(abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),c.y);}\nvec3 rgb2hsv(vec3 a){vec4 K=vec4(0,-1,2,-3)/3.//https://www.shadertoy.com/view/MdGfWm\n ;vec4 P=mix(vec4(a.bg,K.wz),vec4(a.gb,K.xy),step(a.b,a.g));vec4 Q=mix(vec4(P.xyw,a.r),vec4(a.r,P.yzx),step(P.x,a.r))\n ;float D=Q.x-min(Q.w,Q.y),E=1e-10;return vec3(abs(Q.z+(Q.w-Q.y)/(6.*D+E)),D/(Q.x+E),Q.x);}\nvec4 ut(vec4 a,ve0 b){return a*(1.-b);}//v41 ut(v41 a,vec1 b){return mu(a,(1.-b));}\nvec3 ut(vec3 a,ve0 b){return a*(1.-b);}//v31 ut(v31 a,vec1 b){return mu(a,(1.-b));}\nvec2 ut(vec2 a,ve0 b){return a*(1.-b);}//v21 ut(v21 a,vec1 b){return mu(a,(1.-b));}\nve0 ut(ve0 a,ve0 b){return a*(1.-b);}//v11 ut(v11 a,vec1 b){return mu(a,(1.-b));}//#define ut(a,b) (a*(1.-b))\n#define Over 0.\n#define Atop 1.\n#define Out 2.\n#define Xor 3.\n#define In 4.\n//note; colors atop of identical color is a too easy debugging culpit.\n//note,that atop may returns the alpha of a,and not the alpha max(a,b)\nvec4 pdOut(vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+a*b.w;}\nvec4 pdXor(vec4 a,vec4 b){return ut(b,a.w)+ut(a,b.w);}\nvec4 pdIn(vec4 a,vec4 b){return a*b.w;}//pdIn() is just multiplication,note swapped AB case here\n\n/*i am overthinking this, dot radius shall be irrelevant\n//only distance between dots matters.\n*/\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod(inout float p, float size//mercury.sexy hg_sdf \n){float halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat pModPolar(inout vec2 u,float t,float m//mercury.sexy hg_sdf\n){float g=pi/t\n ,a=atan(u.y,u.x)-g-m\n ,r=length(u)\n ,c=floor(a*.5/g)\n ;a=mod(a,g*2.)-g\n ;u=vec2(cos(a),sin(a))*r\n ;//if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\n\n\nfloat arg(vec2 a){return atan(a.y,a.x);}\nvec2 c2p(vec2 a){return vec2(arg(a),length(a));}\nvec2 p2c(vec2 a){return vec2(cos(a.x),sin(a.x))*a.y;}//.x  to .x is correct!\n\n\nfloat pageshape(vec2 u,float s){\n ;u.y=abs(u.y)\n ;float l=1.6\n ;u.x=abs(u.x-+l*s)\n ;u.x-=l\n ;return max(u.x,u.y)\n ;}\n\nbool bookBound(float e,float p//limits page numbers\n){return abs(e*2.+.5)<p\n ;}\n\nfloat BookBottomLeft(vec2 u,vec4 m,inout vec4 c\n){\n ;vec2 v=u\n ;v.y=v.y-pi       \n ;v.y=v.y+m.y\n ;float e=pMod(v.y,m.x*2.*pi)\n ;if(bookBound(e,m.z)\n ){v=v+vec2(1,0)\n  ;c.x=pageshape(v,-1.)     \n  ;}\n ;return c.x;\n ;}\n\n\nfloat BookBottomRight(vec2 u,vec4 m,inout vec4 c\n){\n   ;vec2 v=u\n   ;v.y-=m.y\n   ;float e=pMod(v.y,m.x*2.*pi)\n       \n   ;if(bookBound(e-1.,m.z)\n   ){v=v-vec2(1,0)\n    ;c.x=pageshape(v,1.)\n   ;}\n    ;return c.x;}\n\nfloat BookTop(vec2 u,vec4 m,inout vec4 c\n){\n  ;vec2 v=u.yx*vec2(1,-1)//quater rotation and quater offset to rotate the atan() discontinuity \"down\"\n  ;float e = pModPolar(v,1./m.x,m.y-pi*.5); v -= vec2(1,0);\n  ;if(bookBound(e,m.z)\n  ){c.y=pageshape(v,1.)\n  ;}\n ;c.z=length(u)\n ;return c.y\n ;}\n\n//return .xy is position of a dot, .zw a normalVector\n//m.x is distance between papers\n//m.y is m.y os phase (what pages are open)\n//m.z is number of pages \n//m.w is paper thickness\n//the upper bow is always a half-unitCircle around vec2(0)\nvec4 bookPaternosterBeta(float t,vec2 u,vec3 r,vec4 m\n){vec4 c=vec4(1)\n ;m.y=m.y*2.-1.\n ;m.y=1.-m.y    \n ;//m.x=(m.x*9.+1.)\n ;m.x=1./(abs(m.x*19.)+1.1)\n ;m.z=1./m.x\n ;m.w=min(abs(m.x),1.)\n ;m.x=m.w*.5\n ;float p=2. //p is half the number of pages\n ;float e\n \n   //;if(u.y<0.//bottom\n //){c.z=abs(u.x)\n //;if(u.x<0.)\n ;e=BookBottomLeft(u,m,c)\n // ;else \n  //;e=BookBottomRight(u,m,c)\n/// ;}\n// ;if(u.y>0.)\n ;//e=BookTop(u,m,c)\n ;c.xyzw=vec4(e)\n     /*\n ;c.z=abs(c.z-1.)\n ;c.xy-=m.w\n ;c.z-=.03 */\n ;//c.xy=min(c.xy,min(c.zz,min(c.yx,c.yy)))\n ;c.w=max(c.z,min(c.y,c.x))\n ;c.w=mix(ss(c.w,2./aA(t,u,r,m)),fract(c.w),.1)\n ;c.xyz=mix(ss(c.xyz,2./aA(t,u,r,m)),fract(c.xyz),.1)\n     \n ;c.xy+=c.ww\n ;//initial versions return .rgba to debug this shit\n ;return sat(c)\n ;}\n\n\n                   \n//hg_sdf pmod extensions\n//problem, pMod alone has no good efficient interval bound with gradients outside of the bound interval\n//pmodInterval() exists, but it has (numerically) bad branches.\n//pModr() fixes this\n//[s] sets period-length, n sets number of [c0 discontinuities] == [tileBorderCount]\nfloat pmod(inout float u,float s){float r=floor(u/s+.5);u=fract(u/s+.5)*s;return r;} //http://mercury.sexy/hg_sdf/                 \n\nve0 pModr(inout ve0 p,ve0 s,ve0 n//n==number of repeats (discontinuities), where the smallest discontinuity is at [s]\n){float q=p\n ,f=pmod(q,s)\n ;p=p+.5*s\n ;float o=mix(q,p-s*n,step(n,f ))\n ;      o=mix(o,p    ,step(f,0.))\n ;vec2 r=vec2(o,clamp(f,0.,n))\n ;p=r.x;return r.y;}\n//for u<0 and u>s*n the space condinues linearily, without repetition, this is different from hg_sdf.\n//it also does not set a start, you must just shift u instead\nfloat pModR(inout float p,ve0 s,ve0 n){ve0 r=pModr(p,s,n);p-=s*.5\n ;return (r);}//offset the output for more utility. //floor seems necessary\n//minor flaw; for s==0. special linear case, it still splits a line in 2 segments.\n//pModN() is pModR(), but it ensures a fixed maximum bounding interval via halfpace-cuttoff of N\nfloat pModR(inout float p,ve0 s,ve0 n,ve0 bound\n){n=clamp(n,0.,bound/s)////bound*s/n is the maximum number of n with size s that fits within bound\n ;//problem here is that the righmost one remains, and must be oferwritten by its left neighbor.\n ;float g=sign(n);n=abs(n)//my patch is sign-sensetibve.\n ;float q=p// itcan be caught for having a non integer id (as that interpolates for that one)\n ;float f=pModR(q,s,n)//and this sign batched hack still fails, too much, so just avoid negative intervals on this bound-one!\n ;if(fract(f)!=0.){//if the last dot has a non-integer-id\n     if(p*g>s*(n-1.)){//if we are on the tile of the last dot\n         f=floor(n);p=(p-(s*n)+fract(n)*s)*g;}//it iserased by flooring() its id and shifting it to the identity of its left neighbor\n      //this means, there still exists an invisible border, and both of its sides are seamless.\n     \n     \n         ;}else p=q\n ;return f\n ;}//a bound of pi makes sense in polar coords.\n\n#define repeats (floor(abs(m.y*8.))+2.)\n#define period m.x \n\n\n                        \n\nfloat pModPolar2(inout vec2 u,float t,float m//mercury.sexy hg_sdf\n){float g=pi/t\n ,a=atan(u.y,u.x)-g-m//angle\n ,r=length(u)//distance\n ,c=floor(a*.5/g)//segment factor\n ;a=mod(a,g*2.)-g\n ;u=vec2(cos(a),sin(a))*r\n ;//if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\n/**/\n                          \nvec2 top(vec2 u,vec4 m\n){vec2 r=vec2(2)\n ;//r.x=pModPolar2(u,m.x,m.y)\n ;//r.y=pModPolar2(u,3.,4.)\n ;//r.x=u.y\n ;m.x=abs(m.x) \n ;m.y=pi*.5//m.y is phase!!! //only swivel in positive .my, negative ones are a bit buggy!!!\n     //pi*.5 is a quater rotation\n    //i want to add a totation to that, that is a .5/m.x\n ;m.y+=.45/m.x\n      \n      \n ;m.x=abs(m.x)*7. //m.x is number of segments in a full circle\n ;vec2 v=u.yx*vec2(1,-1)//quater rotation and quater offset to rotate the atan() discontinuity \"down\"\n ;r.y = pModPolar(v,m.x,m.y-pi*.5); v -= vec2(1,0);\n ;//if(bookBound(r.x,m.z)\n ;float h=floor((m.x+m.y)/4.)-2.\n ;if(r.y>h){r.y=floor((m.x+m.y)/4.)-2.\n   \n    ;v=u\n    ;//v.x=abs(u.x)\n    ;m.y+=(h+3.)*m.x//m.y/pi/2.//+m.y/pi/8.\n    ;//pModPolar(v,m.x,m.y-pi*.5);\n    ;v.x+=1.\n    ;//v=c2p(v)\n    ;//v=p2c(v)\n     \n ;}\n   ;h=floor((m.x+m.y)/4.)+1.\n ;if(-r.y>h\n ){r.y=-floor((m.x+m.y)/4.)-1.//*floor(m.y/4.)\n    \n     \n    ;v=u\n    ;m.y+=h*m.x//m.y/pi/2.//+m.y/pi/8.\n    ;//pModPolar(v,m.x,m.y-pi*.5);\n    ;v.x-=1.\n     //;r.y-=1.\n\n ;}\n  \n\n ;v=abs(v)\n  ;r.x=max(v.x,v.y)-.05\n ;//}\n\n ;return r;}\n                          \nvec2 right(vec2 u,vec4 m\n){vec2 r=vec2(0)//.x is a distance, .y is a textureID.\n ;u-=vec2(0,m.y)\n ;r.y=pModR(u.x,period,repeats,2.)//2. is a bound max interval, in which all periods occur\n ;u=abs(u)\n ;r.x=length(u)-.1//max(u.x,u.y)\n ;return r;}\n\nvec2 left(vec2 u,vec4 m\n){vec2 r=vec2(1)//.x is a distance, .y is a textureID.\n ;u+=vec2(0,m.y)\n ;r.y=pModR(u.x,period,repeats)\n ;u=abs(u)\n ;r.x=length(u)-.1//max(u.x,u.y)\n ;return r;}\n\n\nvec4 take2(float t,vec2 u,vec3 r,vec4 m\n){vec4 c=vec4(0,0,0,1)\n ;m.x=1.//m.x sets period\n ;m.y=0.//m.y sets phase\n ;vec2 a=right(u,m)\n ;return c;}\n\nve3 mainEntry(ve0 t,ve1 u,ve2 r,ve3 m\n){ve3 c=ve3(1)\n ;u   =fra(t,u   ,r,m)\n ;if(m.z>0.\n ){m.xy=fra(t,m.xy,r,m)\n  ;m.zw=fra(t,m.zw,r,m)\n ;}else m.xy=vec2(cos(iTime)*.75,1)\n ;c.xy=top(u+3.,m)\n ;c.xy=minx(c.xy,right(u,m))\n ;c.xy=minx(c.xy,left(u,m))\n     ;c.x-=.02\n ;vec4 col=vec4(rainbow(c.y*u5(sqrt(5.)),2./6.),1)\n ;c=mix(ss(c.xxxx,.04),fract(c.xxxx),.2)*mix(vec4(1),col,cos(iTime*1.61))\n ;return c;}\n\nvoid mainImage(out ve3 o,in ve1 u){o=mainEntry(iTime,u,iResolution,iMouse);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3Bzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2777, 2777, 2791, 2791, 2813], [2813, 2813, 2828, 2828, 2850], [2850, 2850, 2865, 2865, 2881], [3049, 3049, 3075, 3075, 3102], [3103, 3103, 3127, 3127, 3154], [3155, 3155, 3179, 3179, 3206], [3207, 3207, 3231, 3231, 3258], [3398, 3511, 3541, 3541, 3575], [3575, 3634, 3665, 3665, 3700], [3700, 3763, 3785, 3785, 3810], [3811, 3811, 3834, 3834, 3860]], "test": "error"}
{"id": "lt3fDS", "name": "Procedural Pattern ", "author": "ollj", "description": "connotated and mildly crunched/fixed fork of \nhttps://www.shadertoy.com/view/4dfyzf", "tags": ["procedural", "2d", "basic", "texture", "pattern", "collection"], "likes": 48, "viewed": 1735, "published": "Public API", "date": "1540849135", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//---------------------------------------------------------\n// Shader: 2dProceduralPattern.glsl  by gPlatl\n//\n// A collection of 2d procedural pattern types.\n// Press mouse button and select pattern in x direction & zoom in y direction.\n//\n//   v1.0  2017-02-22  initial release\n//   v1.1  2017-02-24  changed mod(x,1.) => fract(x)\n//   v1.2  2017-03-15  pattern menu added\n//   v1.3  2017-04-11  sine pattern added\n//   v1.4  2017-04-30  brick wall pattern added\n//   v1.5  2017-05-07  GearPattern added\n//   v1.6  2017-05-30  HexagonalTruchetPattern added\n//   v1.7  2017-06-10  QCirclePattern added\n//   v1.8  2017-08-05  StarPattern added\n//   v1.9  2017-09-02  Basketwork Pattern added\n//   v1.10 2018-07-14  Diamond Pattern added\n//   v1.11 2018-09-15  RosettePattern added\n//   v1.12 2018-10-11  Wallpaper70sPattern added\n//   v1.13 2018-10-11  MinimalWeavePattern added\n//\n// tags:   procedural, pattern, 2d, basic, texture, collection\n// note:   procedural pattern routines will return values from 0.0 .. 1.0\n//\n// references:\n//   Procedural Patterns          http://slideplayer.com/slide/6400090/\n//   Antialiasing Proc. Textures  http://www.yaldex.com/open-gl/ch17lev1sec4.html\n//---------------------------------------------------------\n\n#define patternCount 23.0\n\n#define PI 3.141592\n\nbool ANIMATE = true;   // false if mousePressed\n\n#define pi acos(-1.)\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,0.,1.)\n#define aA(z) (z/min(iResolution.x,iResolution.y))\n\n\nfloat mi(vec2 a){return min(a.x,a.y);}\nfloat mi(vec3 a){return min(a.x,mi(a.yz));}\nfloat ma(vec2 a){return max(a.x,a.y);}\nfloat mu(vec2 a){return a.x*a.y;}\nfloat ad(vec2 a){return a.x+a.y;}\nfloat su(vec2 a){return a.x-a.y;}\nfloat sq2(float a){return a*a;}\n\n\n//i think gears are a VERY special thing, too complex for this SIMPLE patter ncollection\n//gears must be seperate collection because\n//- gears logically overlap, on a lattice this means: https://www.shadertoy.com/results?query=halfspace\n//- polar coordinates invite complex transdorms, including sphere inversion\n//- gears (due to polar complex numbers) quickly extend into 3d and 4d)\nfloat GearPattern(in vec2 uv     // coordinates\n                 ,in float wn    // vertical wheel count\n                 ,in int tn      // tooth count\n                 ,in float time) // rotation time\n{float g = (step(1.0, uv.x * wn) - 0.5) * time;\n  uv = fract(uv * wn) - 0.5;\n  float r = clamp(0.48, 0.4, 0.45 + 0.12*sin(atan(uv.x,uv.y) * float(tn) + g));\n  return smoothstep(r, r + 0.01, 1.1*length(uv));}\n\nfloat CheckerSignMuFract(vec2 u){return sign(mu(.5-fract(u)));}\n\n\n//sat(sin()) or mu(sin()) is pretty lame/inconsistent for patterns\nfloat CheckerSatMuSin(vec2 u){return sat(88.*mu(sin(u*8.)));}//rounded white checkerboard\nfloat Checker1ByMuSin(vec2 u){return 1./mu(sin(u));}\nfloat TartanKaro(  vec2 u){return .5*ad(sat(10.*sin(u)));}\nfloat TartanSquare(vec2 u){return 4.*mu(sat(10.*sin(u)));}\n\nfloat SquareHolePattern(vec2 u\n){u.x=mu(sin(u*2.))\n ;return smoothstep(.1,.0, sq2(u.x)*2.5);}\n\nfloat Grid( vec2 u){\n ;//return ad(abs(fract(u)-.5))//initially was mu(), without -.5 offset, but thats just too trivial\n ;return mi(abs(fract(u)-.5))//, and BrickPattern() without shift\n ;}\n\nfloat BrickPattern(vec2 p\n){//p*=vec2 (1,2)  // scale\n ;vec2 f=floor(p)\n ;p.x-=step(f.y,2.*floor(f.y*.5))*.5// brick shift\n ;p=abs (fract (p + 0.5) - 0.5)\n ;//p=smoothstep (0.03, 0.08, p)\n ;return min(p.x,p.y)\n ;}\n\nvec2 toTri(vec2 u){return vec2(u.x,(u.y*sqrt(3.)+u.x)*.5);}\n\nfloat TrianglePattern(vec2 u){return step(su(fract(toTri(u))),0.);}//non-homogeneous doesnt smoothstep()\n\nfloat RhombStar(vec2 u\n){u.x=sq2(su(fract(toTri(u))))\n ;return step(.25,u.x)//this is less silly\n ;//return smoothstep(.5,.0,u.x)//rather silly (optical illusion) //doesnt mix well with above line)\n ;}\n\nfloat hexBorder(vec2 u//subroutine of HexagonalGrid()\n){\n ;u.x*=sqrt(3.)*2./3.\n ;u.y+= 0.5 * mod(floor(u.x), 2.0)\n ;u = abs(fract(u)-.5)\n ;return abs(max(u.x*1.5+u.y,u.y*2.)-1.)\n ;}//return smoothstep(0., gridThickness,d);\n\nbool fuckme(vec2 a){float b=(1.-a.y)*.5// return hexagonal gridID pattern with 3 colors\n ;return a.y>1.&&(abs(b-a.x+a.y)>-b);}\nbool fuckus(vec2 p){ return 1.>ma(p-p.yx)&&max(-mi(p),ma(p)-2.)<0.;}\nfloat hexId3Hues(in vec2 p\n){p =toTri(p)\n ;p = mod(p,vec2(3))\n ;     if(fuckus(p))return .0\n ;else if(fuckme(p))return .5\n ;else              return 1.\n ;}\n\nfloat hexTruchet(vec2 p//https://www.shadertoy.com/view/Xdt3D8 \n){float s=sqrt(3.)\n ;vec2 h=p+vec2(s,.45)*p.y/3.//hex skew\n ;vec2 f=fract(h);h=floor(h)//fractFloor\n ;float v=fract(ad(h)/3.)//+offsetFract\n ;h+=mix(vec2(step(.3,v)),step(f.yx,f),step(.6,v))//(v<.6)?(v<.3)?h:h++:h+=step(f.yx,f)\n ;p+=vec2(1,2.-sqrt(3.))*h.y*.5-h\n ;v=sign(cos(1234.*cos(h.x+9.*h.y)))//v is -1 or 1, appears a bit random\n ;vec3 a=vec3(dd(p-v*vec2(-2, 0)*.5)\n             ,dd(p-v*vec2( 1, s)*.5)\n             ,dd(p-v*vec2( 1,-s)*.5))\n ;v=(.5-sqrt(mi(a)))*v//all below lines are optional modifiers, each line can be commented out individually\n ;//v*=.5\n ;//v=v+.25 \n ;v=abs(v)\n ;v=1.-(1.-v*2.)\n ;float z=8.\n ;return smoothstep(aA(z),-aA(z),v-(cos(iTime)*(.5-aA(z))+.5))\n ;return v\n ;}\n\n\n//vec2 cs(vec2 u){return vec2(cos(u.x),sin(u.y));}\n\nfloat sinePattern(vec2 p){return sin(p.x*20.+cos(p.y*12.));}//trivial elegance, not normalized, but not noticable\nfloat SinePatternCrissCross(vec2 p){return .5+sinePattern(p)*sinePattern(p.yx);}\n\n\n//euclidean length has p=2, this allows for other p.\nfloat lengthP(in vec2 u, in float p){return pow(pow(abs(u.x),p)+pow(abs(u.y),p),1./p);}\n\n//cute small silly noneuclidean squared-circle, whos corners are dark.\nfloat QCirclePattern(vec2 u){return sin(lengthP(fract(u*4./2.)*2.-1.,4.)*16.);}\n\nfloat StarPattern(vec2 p//ttps://www.shadertoy.com/view/4sKXzy \n){p= abs(fract(p*1.5)-.5)//adorable stars, smoothstep() of it is nice, too.\n ;return max(ma(p),mi(p)*2.);}\n\nfloat weaveSub(vec2 u,float p){return step(.2,abs(fract(u.x)))*(.65+.35*sin(p*(u.y-ceil(u.x))));}\nfloat weave(vec2 u,float r//https://www.shadertoy.com/view/ltXcDn \n){float a=weaveSub(u,pi/r)//step(.2,abs(fract(u.x)))*(.65 +.35*sin(pi*.5*(u.y-ceil(u.x))))\n ;u=u.yx;u.y++ //flip//offset\n ;float b=weaveSub(u,pi/r) //step(.2,abs(fract(u.x)))*(.65 +.35*sin(pi*.5*(u.y-ceil(u.x))))\n ;return max (a,b);}\nfloat weave(vec2 u){return weave(u,1.);}\n\nfloat truchetTiny70s(vec2 p,float time// https://www.shadertoy.com/view/ls33DN by Shane\n){p.x*=sign(cos(length(ceil(p))*time))\n ;return cos(min(length(p=fract(p)),length(--p))*44.);}\n\n\nfloat xof(float a,float b){return float(int(a)^int(b));}//typecasting, not doing type float bitwise xor!\nfloat anf(float a,float b){return float(int(a)&int(b));}//typecasting, not doing type float bitwise and!\nfloat anf(int   a,float b){return float(int(a)&int(b));}//typecasting, not doing type float bitwise and!\n\n//https://www.shadertoy.com/view/XtcBWH\nfloat weaveInt(vec2 coord// https://www.shadertoy.com/view/XttBWn\n){ivec2 uv=ivec2(floor(coord*5.))//type float as much as possible by ollj, to lerp.\n ;float a=floor(mod(iTime,7.))*4.\n ;float bg  =.0//backdrop\n ;float warp=.5//horizontal\n ;float weft=1.//vertical      \n ;vec2 f=floor(vec2(uv.xy)*.5)\n ;a=anf(uv.x^uv.y,a)\n ;vec2 h=vec2(xof(float(uv.x),f.x),xof(float(uv.y),f.y))\n ;h=fract(h/2.)*2.\n ;vec3 i=smoothstep(1.,0.,vec3(a,h.xy))//if only these booleans where floats.\n ;float d=mix(weft,bg,i.z)\n ;float e=mix(warp,bg,i.y)\n ;float c=mix(d,e,i.x)//trilin mix\n ;//c=mix(1.,0.,i.x-(i.z+i.y)*.5)//many other options feasible...\n ;return c;}//https://en.wikipedia.org/wiki/Striation         ==ridged\n//likely needs a bokeh-ed soerpinsky: https://www.shadertoy.com/view/MlcfDB\n\nfloat demo(vec2 u){\n   ;return weaveInt(u)\n   ;// return smoothstep(-.1,.1,StarPattern(u)-cos(iTime)*.5-.5)\n        ;}\n\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord\n){\n  float aspect = iResolution.y / iResolution.x;\n  vec2 mpos = iMouse.xy / iResolution.y;\n  vec2 uv = fragCoord.xy / iResolution.y - vec2(0.5);\n\n  float time = iTime\n ;ANIMATE = iMouse.z < 1.0\n ;// get pattern\n ;int pType = int( mpos.x * patternCount * aspect)\n ;if (uv.y<-0.4//menu view\n ){pType = int(fragCoord.xy/iResolution.y*patternCount*aspect);\n  uv *= 28.\n ;}else{\n  ;uv *= (0.2 + mpos.y) * 10.0\n  ;if (ANIMATE   // rotate and scale position\n  ){float ra = time*0.12\n   ;float cost = cos(ra)\n   ;float sint = sin(ra)\n   ;uv = vec2(cost*uv.x + sint*uv.y, sint*uv.x - cost*uv.y)\n   ;uv *= (1.2+0.3*sin(0.5*time))   // scale\n  ;}}\n ;//pType=999\n ;float p // = HexagonalGrid(uv, 0.5, 0.1);\n ;p=demo(uv)\n ;if      (pType == 0) p = hexBorder (uv*1.25)\n ;else if (pType == 1) p = hexBorder(uv*1.25) //HexagonalGrid2() is just BAD, skewed and discontinuous\n ;else if (pType == 2) p = hexId3Hues(uv*2.0)\n ;else if (pType == 3) p = hexTruchet (uv*3.)\n ;else if (pType == 4) p = CheckerSignMuFract(uv)\n ;else if (pType == 5) p = Checker1ByMuSin(uv*8.0)\n ;else if (pType == 6) p = TrianglePattern(uv)\n ;else if (pType == 7) p = RhombStar(uv)\n ;else if (pType == 8) p = TartanKaro(uv)\n ;else if (pType == 9) p = TartanSquare(uv)\n ;else if (pType ==10) p = SquareHolePattern(uv)  \n ;else if (pType ==11) p = sinePattern(uv)\n ;else if (pType ==12) p = Grid(uv)\n ;else if (pType ==13) p = BrickPattern(uv)\n //;else if (pType ==13) p = BrickPattern2(uv)//is just a much worse variant of BrickPattern()\n ;else if (pType ==14) p = GearPattern(uv, 1.5, 12, iTime * 6.5)\n ;else if (pType ==15) p = QCirclePattern(uv)\n ;else if (pType ==16) p = StarPattern(uv)\n ;else if (pType ==17) p = weave(uv)\n ;else if (pType ==18) p = weave(uv,2.)\n ;else if (pType ==19) p = weave(uv,3.)\n ;else if (pType ==20) p = weave(uv,4.)\n //;else if (pType ==19) p = DiamondPattern(uv)    //is just a distorted grid()\n //;else if (pType ==20) p = triRosettePattern(uv) //disqualified, for looping a wallpaper-group:\n ;else if (pType ==21) p = truchetTiny70s(uv, iTime*0.1)\n ;else if (pType ==22) p = weaveInt(uv)\n ;else                 p = demo(uv)\n ;vec4 color1 = vec4 (0.2+0.2*sin(time)\n                     ,0.2+0.2*sin(time*0.789)\n                     ,0.2+0.2*sin(time*0.665), 1.0)\n ;vec4 color2 = vec4 (0.9)\n ;//fragColor = mix(color1, color2, p)\n ;fragColor = vec4(p)\n ;}\n\n\n//disqualified, for looping a wallpaper-group: https://en.wikipedia.org/wiki/Wallpaper_group\n//i haver standards, and looping trough a kifs is WAY below that.\n#define DumbEnoughToLoopAWallpaperGroup(U) .004/abs(length(mod(U,d+d)-d)-d.x)\nfloat triRosettePattern(vec2 p//https://www.shadertoy.com/view/4lGyz3\n){vec2 d=vec2(sqrt(3.),3)/3.\n ;vec4 O=vec4(0)\n ;for(; O.a++ < 4.; O += DumbEnoughToLoopAWallpaperGroup(p) +DumbEnoughToLoopAWallpaperGroup(p += d*.5))p.x+=d.x\n ;return O.x;}\n\n\n//---------------------------------------------------------\n// return antialiased hexagonal grid color\n//---------------------------------------------------------\n/* //this one is just lazy and bad!\nfloat HexagonalGrid2 (in vec2 position)\n{\n  vec2 pos = position ;\n  pos.x *= 1.1;\n  pos.y += 0.5 * mod(floor(pos.x), 2.0);\n  pos = abs(fract(pos) - 0.5);\n  float d = abs(max(pos.x*2.5 + pos.y, pos.y*3.0) - 1.0);\n  return smoothstep(0.30, .1, d);\n;}\n*/\n\n/*\n// return brick wall pattern\nfloat BrickPattern2(in vec2 p){//brickpattern2 is just a the dumb cousin of BrickPattern()\n    const float vSize = 0.30;\n  const float hSize = 0.05;\n  p.y *= 2.5;    // scale y\n  if(mod(p.y, 2.0) < 1.0) p.x += 0.5;\n  p = p - floor(p);\n  if((p.x+hSize) > 1.0 || (p.y < vSize)) return 1.0;\n  return 0.0;\n}*/\n\n/*\nfloat DiamondPattern(vec2 u//https://www.shadertoy.com/view/lsVczV\n){u=abs(fract(u)-.5)\n ;return (ma(u));}//without distortions and cosine/smoothstep/scaling, this is just a grid()\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3fDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1476, 1476, 1493, 1493, 1514], [1515, 1515, 1532, 1532, 1558], [1559, 1559, 1576, 1576, 1597], [1598, 1598, 1615, 1615, 1631], [1632, 1632, 1649, 1649, 1665], [1666, 1666, 1683, 1683, 1699], [1700, 1700, 1719, 1719, 1731], [1734, 2119, 2323, 2323, 2529], [2531, 2531, 2564, 2564, 2594], [2597, 2664, 2694, 2694, 2725], [2725, 2754, 2784, 2784, 2806], [2807, 2807, 2834, 2834, 2865], [2866, 2866, 2893, 2893, 2924], [2926, 2926, 2959, 2959, 3019], [3021, 3021, 3041, 3041, 3211], [3213, 3213, 3241, 3266, 3426], [3428, 3428, 3447, 3447, 3487], [3489, 3489, 3519, 3519, 3556], [3595, 3595, 3620, 3620, 3796], [3798, 3798, 3854, 3854, 3979], [4022, 4022, 4042, 4042, 4148], [4149, 4149, 4169, 4169, 4217], [4218, 4218, 4247, 4247, 4373], [4375, 4375, 4441, 4441, 5135], [5190, 5190, 5216, 5216, 5250], [5250, 5304, 5340, 5340, 5384], [5387, 5440, 5477, 5477, 5527], [5529, 5600, 5629, 5629, 5679], [5681, 5681, 5747, 5747, 5851], [5853, 5853, 5884, 5884, 5950], [5951, 5951, 6020, 6020, 6251], [6252, 6252, 6272, 6272, 6292], [6294, 6294, 6384, 6384, 6476], [6479, 6479, 6506, 6506, 6535], [6535, 6584, 6611, 6611, 6640], [6640, 6689, 6716, 6716, 6745], [6795, 6835, 6903, 6903, 7478], [7614, 7614, 7633, 7633, 7732], [7735, 7735, 7786, 7786, 10130], [10370, 10370, 10442, 10442, 10613]], "test": "valid"}
{"id": "lt3fRj", "name": "Extracredit bear", "author": "jkashimura", "description": "extracredit", "tags": ["beginner"], "likes": 1, "viewed": 73, "published": "Public", "date": "1540228214", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define repeat (v, r) (mod(v, r) - r/2.)\n\nstruct Shape {\n    float dist;\n    vec4 color;\n};\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n    return fract(sin(dot(v*1., vec2(324.654, 156.546)))*46556.2);\n}\nmat2 rot(float a) {\n    float r = cos(a);\n    float f = sin(a);\n    return mat2(r, f, -f, r);\n}\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float h) {\n    float d = length(p.xz) - r;\n    d = max(d, abs(p.y) - h);\n    return d;\n}\nfloat sphere(vec3 v, float r) {\n    return length(v) - r;\n}\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\nfloat mixColors(float r, float v, float z) {\n    return clamp(.5 + .5*(v - r)/z, 0., 1.);\n}\nfloat mixShapes(float v, float f, float r) {\n    float z = mixColors(v, f, r);\n    return mix(f, v, z) - r*z*(1. - z);\n}\nfloat pModPolar(inout vec2 v, float r) {\n    float f = 6.28318/r;\n    float z = atan(v.y, v.x) + f*.5;\n    float m = floor(z/f);\n    z = mod(z, f) - f*.5;\n    v = vec2(cos(z), sin(z))*length(v);\n    return m;\n}\nvoid pR45(inout vec2 p) {\n    p = (p + vec2(p.y, -p.x))*sqrt(.5);\n}\nfloat pMod1(inout float p, float size) {\n    float halfSize = size*.5;\n    float c = floor((p + halfSize)/size);\n    p = mod(p + halfSize, size) - halfSize;\n    return c;\n}\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n    if((a < r) && (b < r)) {\n        vec2 p = vec2(a, b);\n        float columnradius = r*sqrt(2.)/((n - 1.)*2. + sqrt(2.));\n        pR45(p);\n        p.x -= sqrt(2.)/2.*r;\n        p.x += columnradius*sqrt(2.);\n        if(mod(n, 2.) == 1.) {\n            p.y += columnradius;\n        }\n        pMod1(p.y, columnradius*2.);\n        float result = length(p) - columnradius;\n        result = min(result, p.x);\n        result = min(result, a);\n        return min(result, b);\n    } else {\n        return min(a, b);\n    }\n}\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n    a = -a;\n    float m = min(a, b);\n    if((a < r) && (b < r)) {\n        vec2 p = vec2(a, b);\n        float columnradius = r*sqrt(2.)/n/2.;\n        columnradius = r*sqrt(2.)/((n - 1.)*2. + sqrt(2.));\n        pR45(p);\n        p.y += columnradius;\n        p.x -= sqrt(2.)/2.*r;\n        p.x += -columnradius*sqrt(2.)/2.;\n       \t\n        if(mod(n, 2.) == 1.) {\n            p.y += columnradius;\n        }\n        pMod1(p.y, columnradius*2.);\n        float result = -length(p) + columnradius;\n        result = max(result, p.x);\n        result = min(result, a);\n        return -min(result, b);\n    } else {\n        return -m;\n    }\n}\n\nShape character(vec3 c) {\n    Shape shape;\n    shape.dist = 1000.;\n    shape.color = vec4(1.);\n    //instiating vars\n    vec3 b = c;//body\n    vec3 h = c;//head\n    vec3 e = c;//eyes\n    vec3 eb = c; //eyeball\n    vec3 n = c;//nose\n    vec3 m = c;//mouth\n   \tvec3 a = c;//ear\n    vec3 w = c;//wing\n    vec3 f = c;//arm\n    vec3 l = c;//left\n    vec3 lf = c; //left foot\n    vec3 rf = c; //left foot\n    \n    \n    //mouth\n    //m.x = abs(m.x)-.3;\n    m.y *= cos(sin(m.y*5.)*1.23);\n    float mouth = sphere(m - vec3(0., .2 , - 2.),.1); \n    \n    //nose\n    vec4 nColor = vec4(0.,0.,0.,1.); //red   \n    float nose = fBox(e - vec3(0., .4, - 2.), vec3(.02,.04,.05));\n    \n    //eye\n    vec4 eColor = vec4(0.,0.,0.,1.); //black\n    e.x = abs(e.x) - .3; //mirror\n    float eye = sphere(e - vec3(0., .6, - 2.), .1); \n    \n    \n    //eyeball\n    vec4 ebColor = vec4(1.,1.,1.,1.); //white\n    eb.x = abs(eb.x) - .3; //mirror\n    float eyeball = sphere(eb - vec3(-.1, .4,   -3.), 0.03); //animate the blink by using trig \n    \n    \n    //head\n    vec4 hColor = vec4(1.,.5,0.,1.); //brown\n    float head = sphere(h-vec3(0,.8,0), 1.1);\n    \n    //ear\n    vec4 aColor = vec4(1.,.6,0.,1.); //brown\n    a.x = abs(a.x) - 1.; //mirror\n    float ears = sphere(a - vec3(-0.5, 1., - 2.), .2);\n   \n    //wing\n    b.x *= cos(sin(b.x*.5)*cos(iTime));//stretch\n    float body1 = sphere(b - vec3(0., -1.,  0.), 1.); \n    \n    //body\n    vec4 bbColor = vec4(1.,1.,1.,1.); //white\n    b.y *= cos(sin(b.y*.4)*cos(iTime)*1.4);//stretch  \n    float body = sphere(b - vec3(0., -.5,  -1.9), .3); \n    \n    //belly\n    vec4 bColor = vec4(1.,.4,0.,1.); //brown\n    w.y *= cos(sin(w.y*2.)*1.23);//stretch    \n    w.x = abs(w.x)+.4;//mirror\n    w.xy *= rot(radians(20.)); //rotate\n    float belly = sphere(w - vec3(-.5, -.5,  -2.5), .3);\n    \n    bColor /= cos(sin(w.x*10.)) + cos(sin(w.y*10.));\n    \n    //arm\n    vec4 rColor = vec4(1.,.5,0.,1.); //brown\n    f.y *= cos(sin(f.y*2.)*1.23);//stretch \n    float arm = sphere(f - vec3(.4,-.2,-2.-abs(cos(iTime))*.2),.2);\n    \n    //left arm\n    vec4 lColor = vec4(1.,.5,0.,1.); //brown\n    l.y *= cos(sin(l.y*2.)*1.23);//stretch \n    float larm = sphere(l - vec3(-.4,-.2,-2.-abs(sin(iTime))*.2),.2);\n    \n    //left foot\n    vec4 lfColor = vec4(1.,.5,0.,1.); //brown\n    float lfoot = sphere(lf - vec3(.4,-1.2,-2.-abs(sin(iTime))*.2),.2);\n    \n    //right foot\n    vec4 rfColor = vec4(1.,.5,0.,1.); //brown\n    float rfoot = sphere(rf - vec3(-.4,-1.2,-2.-abs(cos(iTime))*.2),.2);\n    //float ears = fBox(m - vec3(2., -1, - 2.), vec3(.075, .025, .005));\n   \n    shape.dist = min(body, head);\n    shape.dist = min(shape.dist, body1);\n    shape.dist = min(shape.dist, mouth);\n    shape.dist = min(shape.dist, eye);\n    shape.dist = min(shape.dist, eyeball);\n    shape.dist = min(shape.dist, nose);\n    shape.dist = min(shape.dist, belly);\n    shape.dist = min(shape.dist, ears);\n    shape.dist = min(shape.dist, arm);\n    shape.dist = min(shape.dist, larm);\n    shape.dist = min(shape.dist, lfoot);\n    shape.dist = min(shape.dist, rfoot);\n\n    \n    //shape.dist = fOpUnionColumns(shape.dist, head, .1, 5.);\n    \n    \n    shape.color = mix(shape.color, eColor,mixColors(eye,shape.dist,1.));\n    shape.color = mix(shape.color, ebColor,mixColors(eyeball,shape.dist,1.));    \n    shape.color = mix(shape.color, bColor,mixColors(belly,shape.dist,1.));\n    shape.color = mix(shape.color, hColor,mixColors(head,shape.dist,1.));\n    shape.color = mix(shape.color, aColor,mixColors(ears,shape.dist,1.)); \n    shape.color = mix(shape.color, rColor,mixColors(arm,shape.dist,.1)); \n    shape.color = mix(shape.color, lfColor,mixColors(lfoot,shape.dist,.1)); \n\tshape.color = mix(shape.color, rfColor,mixColors(rfoot,shape.dist,.1)); \n    shape.color = mix(shape.color, lColor,mixColors(larm,shape.dist,.1));     shape.color = mix(shape.color, bbColor,mixColors(body,shape.dist,1.)); \n\n    return shape;\n}\n\nShape map(vec3 c){\n  Shape shape = character(c);\n  return shape;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 v = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., -5.);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  \tscene.yx *= rot(iTime);\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1; z <= 1.;z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.00001){\n      fragColor = c.color*(1. - z); // Hit  - invert pixels\n      break;\n    }\n    scene += f*c.dist;\n\n\n  }\n}\n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3fRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 170, 192, 192, 260], [261, 261, 280, 280, 356], [357, 402, 445, 445, 523], [524, 524, 555, 555, 583], [584, 584, 604, 604, 642], [643, 679, 707, 707, 794], [795, 795, 839, 839, 886], [887, 887, 931, 931, 1007], [1008, 1008, 1048, 1048, 1218], [1219, 1219, 1244, 1244, 1286], [1287, 1287, 1327, 1327, 1459], [1460, 1460, 1519, 1519, 2034], [2035, 2035, 2099, 2099, 2728], [2730, 2730, 2755, 2755, 6630], [6632, 6632, 6650, 6650, 6698], [6700, 6700, 6755, 6755, 7192]], "test": "error"}
{"id": "lt3fW8", "name": "Webcam 'Giant in a lake'", "author": "BenWheatley", "description": "Webcam \"Giant in a lake\" effect.", "tags": ["water", "water", "webcam"], "likes": 13, "viewed": 1326, "published": "Public API", "date": "1539339697", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Webcam 'Giant in a lake' effect by Ben Wheatley - 2018\n * License MIT License\n * Contact: github.com/BenWheatley\n */\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 pixelSize = vec2(1,1) / iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb; \n    float mirrorPos = 0.3;\n    if (uv.y < mirrorPos) {\n        float distanceFromMirror = mirrorPos - uv.y;\n        float sine = sin((log(distanceFromMirror)*20.0) + (iTime*2.0));\n        float dy = 30.0*sine;\n        float dx = 0.0;\n        dy *= distanceFromMirror;\n        vec2 pixelOff = pixelSize * vec2(dx, dy);\n        vec2 tex_uv = uv + pixelOff;\n        tex_uv.y = (0.6 /* magic number! */) - tex_uv.y;\n        col = texture(iChannel0, tex_uv).rgb;\n        \n        float shine = (sine + dx*0.05) * 0.05;\n        col += vec3(shine, shine, shine);\n    }\n   \t\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3fW8.jpg", "access": "shaders20k", "license": "mit", "functions": [[125, 125, 182, 182, 953]], "test": "error"}
{"id": "lt3fWN", "name": "Chanel Doodle #1", "author": "Flopine", "description": "15 minutes improvisation training for a performance at the Chanel Foundation gala", "tags": ["raymarching", "performance", "15mins"], "likes": 6, "viewed": 173, "published": "Public", "date": "1539635715", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui and Coyhot for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n#define ITER 64.\n#define PI 3.141592\n#define time iTime\n#define BPM 143./2.\n#define tempo BPM/60.\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.*PI*(c*t+d));}\n\nvec2 moda (vec2 p, float per)\n{\n  float a = atan(p.y, p.x);\n  float l = length(p);\n  a = mod(a-per/2., per)-per/2.;\n  return vec2(cos(a),sin(a))*l;\n}\n\nvec2 mo(vec2 p, vec2 d)\n{\n  p = abs(p)-d;\n  if (p.y > p.x) p.xy = p.yx;\n  return p;\n}\n\nfloat stmin(float a, float b, float k, float n)\n{\n  float st = k/n;\n  float u = b-k;\n  return min(min(a,b), 0.5 * (u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat smin( float a, float b, float k )\n{\n  float h = max( k-abs(a-b), 0.0 );\n  return min(a, b) - h*h*0.25/k;\n}\n\nfloat pulse (float s)\n{return exp(-fract(time * tempo) * s);}\n\nfloat tiktak(float period)\n{\n  float tik = floor(time*tempo)+pow(fract(time*tempo),3.);\n  tik *= 3.*period;\n  return tik;\n}\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\nfloat od (vec3 p, float d)\n{return dot(p, normalize(sign(p)))-d;}\n\nfloat cyl (vec2 p, float r)\n{return length(p)-r;}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat prim1 (vec3 p)\n{\n\nfloat c = cyl(p.xz, 0.2);\n\nvec3 pp = p;\nfloat per = 3.;\np.y = mod(p.y-per/2., per)-per/2.;\nfloat s = sphe(p, .5);\n\nreturn smin(s, c , 0.5);\n}\n\nfloat prim2 (vec3 p)\n{\n\np.xz *= rot(p.y*0.1);\np.xz = moda(p.xz, 2.*PI/5.);\np.x -= 3.;\np.x += sin(p.y*0.5 + time);\nreturn prim1(p);\n}\n\n\nfloat g = 0.;\nfloat SDF(vec3 p)\n{\n  p.xz *= rot(time*tempo/2.);\n  p.xy = mo(p.xy, vec2(1.,2.));\n  p.xz = mo(p.xz, vec2(1.));\nfloat d = min(smin(sphe (p, 1. - pulse(1.)*0.5), od(p,.5), 0.8), prim2(p)); \n  g+=0.1/(0.1+d*d); \n  return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec3 ro = vec3(0.001,0.001,-7.); vec3 p = ro;\n  vec3 rd = normalize(vec3(uv,1.));\n\n  float shad = 0.;\n\n  for (float i=0.; i<ITER; i++)\n  {\n    float d = SDF(p);\n    if (d<0.001)\n    {\n      shad = i/ITER;\n      break;\n    }\n    p += d*rd*0.2;\n  }\n\n  float t = length(ro-p);\n\n  vec3 pal = palette\n  (length(uv) + time*tempo/2.,\n  vec3(0.5),\n  vec3(0.5),\n  vec3(1.),\n  vec3(0.,0.3,0.7));\n\n  vec3 c = vec3(1.-shad) * pal;\n  c = mix(c, vec3(0.,0.3,0.7), 1.-exp(-0.01*t*t));\n  c+=g*0.02;\n  fragColor = vec4(pow(c,vec3(0.45)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3fWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 279, 335, 335, 366], [368, 368, 399, 399, 517], [519, 519, 544, 544, 604], [606, 606, 655, 655, 755], [757, 757, 798, 798, 869], [871, 871, 894, 894, 932], [934, 934, 962, 962, 1057], [1059, 1059, 1078, 1078, 1121], [1123, 1123, 1153, 1153, 1173], [1175, 1175, 1203, 1203, 1240], [1242, 1242, 1271, 1271, 1291], [1293, 1293, 1322, 1322, 1409], [1411, 1411, 1433, 1433, 1576], [1578, 1578, 1600, 1600, 1710], [1727, 1727, 1746, 1746, 1949], [1952, 1952, 2009, 2009, 2635]], "test": "valid"}
{"id": "lt3fzj", "name": "flowers_periodic_gamma_init", "author": "wxs", "description": "Unofortunately it still only really looks good near the center, and my initial jitter experiments have been failures.", "tags": ["cppn"], "likes": 1, "viewed": 346, "published": "Public API", "date": "1540239582", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define N_HIDDEN 64\n\nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\n\n\nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\nbufA[0] = vec4(5.5229673,4.6336145,0.32251385,6.2336287) + mat4(vec4(7.929101943969727,1.8680975437164307,5.282817840576172,1.335081696510315),vec4(6.40048885345459,10.911112785339355,5.710175514221191,3.2174267768859863),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[1] = vec4(0.92673945,5.510801,5.7878923,3.4094863) + mat4(vec4(9.46456241607666,5.742208480834961,4.836627006530762,3.681884765625),vec4(7.781929969787598,7.350441932678223,5.431681156158447,1.79822838306427),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[2] = vec4(1.9038666,2.002624,5.306078,4.3478446) + mat4(vec4(2.165930986404419,4.592442512512207,6.321033477783203,2.5442633628845215),vec4(4.549664497375488,4.175715923309326,2.4776484966278076,6.15303373336792),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[3] = vec4(4.736449,4.498103,2.1716383,1.6620586) + mat4(vec4(6.867297172546387,3.519904851913452,2.556973457336426,1.0280416011810303),vec4(2.215717077255249,2.7205262184143066,6.759027004241943,4.799482822418213),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[4] = vec4(6.2450805,3.4882815,2.1426363,4.6573863) + mat4(vec4(3.115823745727539,9.722407341003418,8.343886375427246,3.0061302185058594),vec4(9.178009986877441,2.323615312576294,5.706693172454834,6.043638706207275),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[5] = vec4(6.1504483,2.0174665,2.8344715,3.7011302) + mat4(vec4(3.461993932723999,3.9749135971069336,5.922208309173584,3.5996906757354736),vec4(10.838000297546387,2.9056448936462402,10.656293869018555,3.535773277282715),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[6] = vec4(2.7608836,4.531166,0.84178466,4.5258527) + mat4(vec4(4.563502788543701,18.398193359375,5.149980068206787,5.571099281311035),vec4(3.013946056365967,0.4056667387485504,6.251698970794678,3.951154947280884),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[7] = vec4(0.09189694,1.3810596,2.29294,1.9994028) + mat4(vec4(1.9264535903930664,4.220382213592529,2.971323013305664,10.859575271606445),vec4(5.809052467346191,11.347599983215332,5.744701862335205,2.8633499145507812),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[8] = vec4(1.7880569,5.1181984,5.127368,2.8185883) + mat4(vec4(1.804829716682434,6.541291236877441,5.593873500823975,3.523404359817505),vec4(3.8857932090759277,8.387980461120605,4.863153457641602,7.03821325302124),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[9] = vec4(4.6259274,3.1109855,4.7688985,5.0529943) + mat4(vec4(1.7312583923339844,2.6023471355438232,8.448616981506348,2.688322067260742),vec4(4.92233419418335,2.382366418838501,3.6137425899505615,10.982731819152832),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[10] = vec4(0.5453321,4.3250628,6.1060524,0.081448555) + mat4(vec4(2.6021666526794434,3.408484935760498,7.456984043121338,4.321142673492432),vec4(5.440805912017822,12.484932899475098,2.2298953533172607,7.607587814331055),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[11] = vec4(3.0543761,3.3568108,1.3488034,0.8831847) + mat4(vec4(5.347343921661377,8.43726921081543,5.014606952667236,3.878462314605713),vec4(2.3133864402770996,6.203373432159424,7.148248672485352,4.1567277908325195),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[12] = vec4(4.829323,3.1762035,4.4057164,2.846884) + mat4(vec4(7.4628753662109375,1.7592393159866333,5.882620811462402,7.164809226989746),vec4(3.8397796154022217,8.81448745727539,1.1405972242355347,5.306056022644043),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[13] = vec4(4.140318,2.01575,3.315786,1.3231536) + mat4(vec4(9.95779037475586,4.38463020324707,10.47618579864502,8.735001564025879),vec4(8.290224075317383,7.534869194030762,4.467377662658691,1.4578293561935425),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[14] = vec4(5.0968466,1.8190563,0.08829089,3.330865) + mat4(vec4(5.000452041625977,1.3572379350662231,4.084152698516846,4.119621753692627),vec4(10.15761661529541,22.089447021484375,4.729427814483643,7.957424163818359),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[15] = vec4(3.5846217,3.884341,2.3849711,4.7107377) + mat4(vec4(7.657059669494629,12.819743156433105,7.465062141418457,4.857611179351807),vec4(5.13007116317749,2.0512330532073975,6.399020195007324,4.62611198425293),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufB[0] = sin(bufA[0]);\nbufB[16] = cos(bufA[0]);\nbufB[1] = sin(bufA[1]);\nbufB[17] = cos(bufA[1]);\nbufB[2] = sin(bufA[2]);\nbufB[18] = cos(bufA[2]);\nbufB[3] = sin(bufA[3]);\nbufB[19] = cos(bufA[3]);\nbufB[4] = sin(bufA[4]);\nbufB[20] = cos(bufA[4]);\nbufB[5] = sin(bufA[5]);\nbufB[21] = cos(bufA[5]);\nbufB[6] = sin(bufA[6]);\nbufB[22] = cos(bufA[6]);\nbufB[7] = sin(bufA[7]);\nbufB[23] = cos(bufA[7]);\nbufB[8] = sin(bufA[8]);\nbufB[24] = cos(bufA[8]);\nbufB[9] = sin(bufA[9]);\nbufB[25] = cos(bufA[9]);\nbufB[10] = sin(bufA[10]);\nbufB[26] = cos(bufA[10]);\nbufB[11] = sin(bufA[11]);\nbufB[27] = cos(bufA[11]);\nbufB[12] = sin(bufA[12]);\nbufB[28] = cos(bufA[12]);\nbufB[13] = sin(bufA[13]);\nbufB[29] = cos(bufA[13]);\nbufB[14] = sin(bufA[14]);\nbufB[30] = cos(bufA[14]);\nbufB[15] = sin(bufA[15]);\nbufB[31] = cos(bufA[15]);\nbufA[0] = vec4(-0.02671118,0.112036355,-0.100514375,-0.024114015) + mat4(vec4(0.08919076,-0.15831625,0.135713,0.051650718),vec4(-0.07506181,-0.017092166,-0.2606622,0.0967784),vec4(0.019842269,0.14400719,-0.029944882,0.049570367),vec4(0.02671603,0.031325754,-0.19494267,-0.11804662)) * bufB[0] + mat4(vec4(0.39278334,0.13065043,-0.117667906,-0.17220561),vec4(-0.114897884,-0.17305073,-0.0319885,-0.14678955),vec4(0.2223491,-0.003209436,-0.11002445,-0.09887819),vec4(-0.12798066,0.13511366,-0.0777276,-0.03169002)) * bufB[1] + mat4(vec4(0.17481032,-0.03547473,-0.08514929,-0.081925936),vec4(0.030829333,0.082976855,-0.034817535,-0.051751245),vec4(-0.07026553,0.19322285,0.16869096,0.07250417),vec4(-0.09074127,-0.014071925,-0.028861305,0.00096096686)) * bufB[2] + mat4(vec4(0.31519908,0.028243296,0.06196734,0.16757683),vec4(0.043964587,-0.2142533,-0.0068562087,0.28676528),vec4(0.10120941,-0.124885134,0.06482282,-0.062027197),vec4(0.073739864,-0.07966016,-0.21933772,0.01893642)) * bufB[3] + mat4(vec4(-0.1397226,-0.33615375,-0.24152645,0.34794098),vec4(-0.031956356,-0.316536,-0.090487614,-0.051089466),vec4(0.0045854603,0.01429024,-0.026441228,-0.00878936),vec4(-0.038350992,0.12157187,0.0853218,-0.0522399)) * bufB[4] + mat4(vec4(0.07002569,-0.031417366,0.15290561,-0.17712928),vec4(-0.107539915,0.18516654,-0.036599733,0.074143216),vec4(0.09647719,-0.021705044,-0.017965307,-0.26241973),vec4(-0.20124069,0.04079465,-0.042394884,0.012605441)) * bufB[5] + mat4(vec4(-0.18739827,0.13077113,-0.006898285,0.095760934),vec4(-0.051682677,-0.013112838,-0.040752575,0.29204032),vec4(0.087885715,0.14488238,0.016908769,0.09537741),vec4(0.009414258,-0.16613166,-0.1215387,-0.08721844)) * bufB[6] + mat4(vec4(0.14761855,0.15302528,0.0005465549,-0.002779772),vec4(-0.085322455,0.17676115,-0.05649245,0.025791137),vec4(-0.03583909,-0.1375423,-0.21043432,0.107406065),vec4(-0.0031154356,0.2605672,-0.22941472,-0.044759333)) * bufB[7] + mat4(vec4(0.2319611,0.07755097,0.0579179,0.28558323),vec4(0.21330395,0.09077062,-0.14930266,0.12034514),vec4(0.056348868,0.09955945,-0.15739116,-0.119875826),vec4(0.15186432,-0.12350289,-0.07693368,-0.11977535)) * bufB[8] + mat4(vec4(-0.29159608,0.12077728,0.4015945,0.057948712),vec4(0.39383343,-0.21541524,0.15256722,0.008609677),vec4(-0.1821129,-0.12291453,-0.08105293,0.15968087),vec4(0.032235432,-0.08535079,-0.042606864,-0.018571954)) * bufB[9] + mat4(vec4(0.09287421,0.081007876,-0.12128114,-0.034290116),vec4(0.046242926,-0.100778304,0.19480348,-0.01687432),vec4(0.13914052,0.31291884,0.06900487,0.18665206),vec4(0.08970233,-0.21767655,-0.20699747,0.10571189)) * bufB[10] + mat4(vec4(0.07321214,-0.116850145,-0.029831028,-0.030029945),vec4(0.06231138,-0.118999705,0.2147651,0.07021226),vec4(-0.012426936,0.00778794,-0.0606358,0.12889527),vec4(0.09984635,0.18184343,-0.1239324,-0.1264881)) * bufB[11] + mat4(vec4(0.02155677,-0.062318716,0.011919368,0.08417645),vec4(0.07482725,0.14198408,-0.16540094,-0.09426458),vec4(0.14102246,0.2661211,-0.25469536,0.14155385),vec4(0.03283022,-0.07142093,-0.09481857,0.21649888)) * bufB[12] + mat4(vec4(0.17290467,0.06284695,0.03463629,0.11718546),vec4(0.08441261,0.22652996,-0.14582069,0.21116954),vec4(-0.048504356,0.023297219,-0.025181266,0.00028328135),vec4(-0.005860378,0.09250633,0.03881111,-0.09989294)) * bufB[13] + mat4(vec4(0.1652826,0.22010551,-0.26935592,-0.23790205),vec4(-0.027134147,-0.1130062,0.053130623,-0.001943993),vec4(-0.069825895,0.24754529,-0.0057024155,0.022361938),vec4(-0.121510684,0.08110115,0.13558027,0.080863334)) * bufB[14] + mat4(vec4(-0.01466077,-0.21732937,-0.2560884,0.16061741),vec4(-0.23818778,-0.06622728,0.07429921,-0.22540231),vec4(-0.14754505,-0.011888504,-0.06950895,-0.056959916),vec4(0.095114544,-0.12727132,-0.12089674,0.024870947)) * bufB[15] + mat4(vec4(0.017413415,0.072018005,-0.10776621,-0.06879695),vec4(-0.108149424,-0.007651666,-0.07206954,0.048778094),vec4(-0.0317751,-0.094654314,0.027515726,-0.04987938),vec4(0.22803688,0.09867,0.011534847,0.39614436)) * bufB[16] + mat4(vec4(0.07928925,-0.08826059,0.18927303,0.2632632),vec4(0.06639758,0.08935773,-0.096028514,0.04087789),vec4(-0.035496935,-0.025788896,0.059087534,0.031913124),vec4(0.13239318,-0.14443262,0.07465342,0.14258431)) * bufB[17] + mat4(vec4(-0.1954509,0.17053725,0.036024436,0.077469625),vec4(-0.11863913,-0.07336276,0.09706636,0.10677877),vec4(-0.4543575,0.22047488,0.09582487,0.0768463),vec4(0.11326035,0.015419992,0.011069477,-0.028933974)) * bufB[18] + mat4(vec4(-0.19081578,0.02293488,0.08818128,0.015838008),vec4(0.06461804,-0.0016106914,0.12632759,-0.10701849),vec4(-0.06385351,-0.11605552,0.18699218,-0.046799753),vec4(-0.2614213,-0.03261676,0.014895784,0.09546338)) * bufB[19] + mat4(vec4(0.19814834,-0.07821319,0.057651583,0.15420052),vec4(-0.15346703,-0.018868547,-0.06753848,0.12217972),vec4(0.1254645,-0.24283618,0.013584587,-0.06829737),vec4(-0.10923062,0.12968197,-0.009253847,0.039386522)) * bufB[20] + mat4(vec4(-0.13401009,-0.07370651,0.022134429,-0.14646725),vec4(-0.15922822,-0.09833199,-0.036402825,0.12037199),vec4(-0.16205315,-0.07530175,-0.15460631,0.14927858),vec4(-0.14506388,0.051238347,-0.054825358,0.010984334)) * bufB[21] + mat4(vec4(-0.273818,-0.025691181,0.16256776,-0.024456074),vec4(0.24317308,0.16415475,0.12633474,-0.03355621),vec4(-0.098716624,-0.107962705,0.0722849,0.016512632),vec4(0.10085371,-0.24031368,-0.066662714,0.043721966)) * bufB[22] + mat4(vec4(0.065803595,-0.22155298,0.06353272,0.035150833),vec4(0.10504035,-0.13919406,-0.07030094,0.011683735),vec4(-0.053361345,0.09045229,0.1314524,0.2946974),vec4(0.048316784,-0.015156117,-0.15853739,-0.29385948)) * bufB[23] + mat4(vec4(-0.09977385,-0.027728328,0.07888995,0.22035123),vec4(-0.05885499,0.12981392,-0.10890281,0.011864505),vec4(-0.021599572,0.02568873,-0.10925194,-0.05881699),vec4(0.00082544365,0.087212615,0.1851126,-0.041382104)) * bufB[24] + mat4(vec4(0.2562885,0.060258467,0.060870945,0.027613154),vec4(0.17627573,-0.09222617,0.09604785,-0.0129113905),vec4(0.19663246,0.05281389,0.22521687,-0.10249362),vec4(0.059192915,-0.066716135,-0.047857504,-0.08568323)) * bufB[25] + mat4(vec4(0.015972912,-0.019756548,0.024574826,-0.2464137),vec4(0.09899375,-0.15719418,-0.058604345,0.045785535),vec4(-0.011457175,-0.14750361,-0.0023933456,-0.13423851),vec4(0.021311069,-0.11395929,0.048772663,0.14569303)) * bufB[26] + mat4(vec4(0.1094753,0.10418443,0.13570434,0.09354897),vec4(-0.046690486,0.013031637,0.008502261,0.06255009),vec4(-0.070809826,-0.009788813,-0.03162433,0.07978599),vec4(0.0518267,-0.17104569,0.06211135,-0.09641118)) * bufB[27] + mat4(vec4(0.08731595,0.14677988,0.26830575,0.004232078),vec4(-0.12623328,-0.046367474,-0.33631292,-0.32302824),vec4(-0.112600595,0.25619727,-0.24564183,-0.027385116),vec4(0.21163991,-0.13110764,-0.077701434,0.03211277)) * bufB[28] + mat4(vec4(0.004919589,-0.015258152,-0.07054722,-0.07307259),vec4(-0.07374673,0.20842664,0.17780831,-0.055437025),vec4(-0.22340478,0.112239614,0.22786711,-0.25890988),vec4(-0.047852192,-0.13177876,0.16913968,-0.20651004)) * bufB[29] + mat4(vec4(-0.16431184,-0.01800299,-0.005623348,0.015538251),vec4(0.1379306,0.005856027,0.019067582,-0.049917594),vec4(0.2165535,0.10380648,-0.16184416,0.18756582),vec4(-0.06763376,0.10094273,-0.109949976,0.05370108)) * bufB[30] + mat4(vec4(0.003368366,0.060612533,0.24951622,-0.10061869),vec4(-0.07797953,-0.19238698,-0.076071516,0.22575311),vec4(0.00040278028,0.00022941979,-0.06158029,-0.07759184),vec4(-0.065672696,-0.020269027,-0.106867574,-0.05346603)) * bufB[31];\nbufA[1] = vec4(0.033203736,-0.11977001,-0.03217471,-0.012726413) + mat4(vec4(0.14046004,0.043487266,0.040743154,-0.11051021),vec4(-0.2632798,-0.0041936305,-0.082323916,0.177778),vec4(0.0656691,-0.059527785,0.14735207,-0.104505226),vec4(-0.023776764,0.08293811,0.017196182,-0.17866512)) * bufB[0] + mat4(vec4(0.028795902,0.06403569,0.04422415,0.018971926),vec4(-0.18282351,0.060622547,0.18709338,-0.10405064),vec4(0.13505062,0.00071958685,0.09924523,0.062153477),vec4(0.027971823,0.04935319,-0.045882393,-0.06938651)) * bufB[1] + mat4(vec4(0.028160997,-0.10766137,-0.14243396,-0.012433438),vec4(-0.050989892,0.06002456,0.04633291,0.17734598),vec4(-0.064098455,-0.013108328,0.19837521,-0.15379345),vec4(0.1051412,-0.16220036,-0.1167696,0.081889875)) * bufB[2] + mat4(vec4(-0.09247215,0.03495125,0.044726554,-0.07099918),vec4(0.1189488,-0.04360534,-0.021344455,-0.041728336),vec4(-0.04902381,0.05573165,0.0052174698,-0.12464463),vec4(0.021370668,0.037203833,0.01587978,0.11687197)) * bufB[3] + mat4(vec4(0.15937784,0.067833364,0.08844068,0.10539431),vec4(-0.0608474,-0.14763343,-0.1873289,-0.12261744),vec4(0.02607887,0.07982589,0.13540687,-0.16760804),vec4(0.015804237,-0.13788234,-0.06095726,0.08663496)) * bufB[4] + mat4(vec4(0.08864407,0.29459754,-0.101434685,0.033080377),vec4(-0.29394278,-0.053589262,0.041626487,0.21049215),vec4(0.1473835,0.22660077,0.05466978,0.067913845),vec4(0.16033217,0.13498606,-0.08168438,-0.006615192)) * bufB[5] + mat4(vec4(0.20756702,-0.09355165,-0.15074444,0.2211734),vec4(0.11413395,-0.13425153,0.060896043,-0.14168954),vec4(0.17594662,-0.062082965,0.3312132,-0.27496457),vec4(0.043245554,0.0528848,0.074461475,-0.17584509)) * bufB[6] + mat4(vec4(-0.011931277,0.21983768,-0.016173135,-0.21652707),vec4(0.15873016,-0.04244525,-0.016719071,0.0074235853),vec4(-0.18992946,0.013378318,-0.19113888,0.0050270488),vec4(0.24199975,-0.1877472,0.1829898,0.13271514)) * bufB[7] + mat4(vec4(0.069957964,-0.1970902,0.02437829,0.13416244),vec4(0.26509705,-0.04423102,-0.14289044,-0.19336794),vec4(0.04206231,-0.15406048,0.029329063,0.083563365),vec4(-0.1738535,0.12848137,0.02116981,0.110192716)) * bufB[8] + mat4(vec4(-0.08386131,0.05547924,0.05893555,-0.1420576),vec4(-0.13995436,-0.11205055,0.0009938416,0.07014366),vec4(-0.099791504,0.17905605,0.09286505,-0.030938707),vec4(-0.08712527,0.13714173,-0.15902373,0.07222677)) * bufB[9] + mat4(vec4(-0.08166462,0.13775332,-0.02142197,-0.090068184),vec4(0.07955603,-0.03130133,0.06400933,-0.09594054),vec4(0.11372598,0.11184042,0.06348548,-0.0063127372),vec4(0.1426823,-0.019803438,0.06881466,-0.12659456)) * bufB[10] + mat4(vec4(0.11625189,-0.23739721,-0.12980014,-0.121682666),vec4(-0.0050927857,-0.18381006,0.14182112,-0.08737033),vec4(0.03189663,-0.05254506,0.07995488,0.094651185),vec4(-0.17740288,0.013675711,0.15755469,0.006730898)) * bufB[11] + mat4(vec4(0.004596597,0.085894786,0.08154156,0.13890882),vec4(0.047225453,0.16194855,0.12696926,0.12810472),vec4(0.12625062,-0.26038906,0.35143337,-0.063226886),vec4(-0.18027541,0.07873042,0.111502066,0.1314858)) * bufB[12] + mat4(vec4(0.33179116,-0.13438535,-0.18098345,0.0025028414),vec4(-0.17416257,0.20558722,-0.006766828,0.24520835),vec4(-0.11981419,0.33567068,-0.008600599,-0.011109326),vec4(-0.20188344,0.12817052,0.14217675,-0.15035622)) * bufB[13] + mat4(vec4(-0.23282371,0.15568365,-0.0014772804,0.23262873),vec4(0.22646898,0.12912157,-0.054670524,-0.13730332),vec4(-0.08827622,0.15960664,0.1607224,0.1034404),vec4(-0.12541866,0.054617856,-0.004484127,0.067310974)) * bufB[14] + mat4(vec4(0.02358945,0.15001497,0.003471006,0.14111596),vec4(0.331006,0.2235367,0.2851841,-0.07482197),vec4(-0.14606825,-0.117186,-0.10071485,0.22844063),vec4(-0.028547226,-0.024880879,-0.05211756,0.0067149126)) * bufB[15] + mat4(vec4(-0.003374604,-0.003920451,-0.09546001,0.13875839),vec4(0.04129445,-0.095827565,0.20494926,0.07031132),vec4(-0.034643102,0.108883455,0.055432625,-0.23737615),vec4(0.084077135,0.10756382,-0.16157605,-0.08397951)) * bufB[16] + mat4(vec4(0.07144752,0.061997812,-0.09592961,-0.19582248),vec4(-0.13910006,-0.062451527,0.089308135,0.1062779),vec4(0.045364562,-0.011553095,0.13582805,0.06799385),vec4(0.08631019,0.02746202,0.19692478,0.31312764)) * bufB[17] + mat4(vec4(0.12740773,0.051633798,0.13053428,0.11317333),vec4(0.2312294,0.17174919,-0.009573466,0.04529877),vec4(0.15399602,0.08406865,0.13747406,0.13780874),vec4(0.075005166,0.03624583,0.19039635,0.010591566)) * bufB[18] + mat4(vec4(0.103040345,0.03494258,0.14100255,0.24608585),vec4(0.09336147,-0.09079984,-0.033917375,-0.036393646),vec4(0.14932524,0.108069696,-0.1404198,0.00933359),vec4(-0.110687174,-0.10142217,0.0881459,0.1128272)) * bufB[19] + mat4(vec4(-0.13689338,-0.23775135,0.033764243,-0.43340608),vec4(0.19163525,0.22353768,-0.2093264,-0.18827565),vec4(0.08269367,-0.023584763,0.185819,0.051784057),vec4(0.24225025,-0.041794028,-0.025530694,-0.053291295)) * bufB[20] + mat4(vec4(0.13470443,-0.19890781,-0.08304012,0.012534182),vec4(-0.06317355,0.050752647,0.054833844,0.14691034),vec4(0.043120325,0.20166986,-0.110501304,-0.091597684),vec4(-0.05988104,-0.104738355,-0.19650398,0.096138105)) * bufB[21] + mat4(vec4(0.048704617,0.17667347,0.041765895,-0.021739079),vec4(-0.26051936,-0.09267684,0.0050980803,-0.015015017),vec4(-0.052309867,-0.13577977,-0.06705758,-0.12965392),vec4(0.26447847,-0.08332747,-0.038296174,0.054170884)) * bufB[22] + mat4(vec4(-0.0497438,0.0347455,0.05759371,-0.20355132),vec4(-0.031864136,-0.10661217,0.03575431,-0.03752308),vec4(-0.06823412,0.022884382,-0.26777396,0.031288054),vec4(-0.24914116,0.046375174,0.031284694,0.02117956)) * bufB[23] + mat4(vec4(-0.027923,0.19009708,0.12925509,0.1181086),vec4(-0.20793507,0.20409764,-0.10949957,0.13341792),vec4(-0.0055618426,0.04323652,-0.030888077,0.046022184),vec4(0.03371529,-0.15674648,-0.086572714,0.0066274796)) * bufB[24] + mat4(vec4(0.080285035,0.012582867,0.101316184,-0.0018583299),vec4(0.14430565,-0.03675413,0.010173002,-0.0660716),vec4(0.026562737,0.028127238,-0.020909177,-0.22011212),vec4(0.1470163,0.10152774,0.08014572,0.064044766)) * bufB[25] + mat4(vec4(0.08085624,0.031801905,-0.11527024,-0.21979174),vec4(-0.006424858,-0.043482844,0.08125194,-0.046291575),vec4(-0.018563889,-0.19572476,0.02681466,-0.1542506),vec4(-0.008884994,-0.06842286,-0.2698551,0.12341308)) * bufB[26] + mat4(vec4(0.030251434,0.014256644,0.017339805,0.027983086),vec4(0.02508312,0.05883055,0.1092435,0.12127551),vec4(-0.10075049,-0.10776872,-0.10877225,0.10885852),vec4(0.023838343,0.091507636,0.06681959,-0.013105805)) * bufB[27] + mat4(vec4(-0.015678335,0.08174615,0.13333485,-0.18132588),vec4(-0.04598691,0.021885207,-0.019663002,-0.44457102),vec4(0.07323596,-0.09915303,-0.14090523,-0.022602357),vec4(0.15479316,0.06541813,-0.017482525,-0.15424742)) * bufB[28] + mat4(vec4(-0.10599349,0.038448483,0.019779349,-0.04604485),vec4(-0.12715966,0.05670578,-0.061424077,0.1958705),vec4(0.035600398,-0.008813547,-0.38420945,0.061960414),vec4(0.10955231,-0.11163671,-0.038627964,0.1421886)) * bufB[29] + mat4(vec4(-0.19505236,-0.05042113,0.0004332671,-0.15094985),vec4(0.09484016,0.0068646045,-0.16101877,0.05583388),vec4(0.03903655,-0.046397064,0.0941475,-0.09721246),vec4(0.032981392,-0.0141218705,0.0836361,-0.00031592173)) * bufB[30] + mat4(vec4(-0.123080924,-0.012027454,0.01570284,0.072961606),vec4(0.08595524,0.015826005,-0.044173073,-0.11477531),vec4(0.05368488,0.03466083,-0.010011108,-0.14914127),vec4(-0.012653154,-0.064498454,0.06407052,-0.05717025)) * bufB[31];\nbufA[2] = vec4(0.05356682,0.13744551,0.0020867493,-0.063327104) + mat4(vec4(-0.24726853,-0.017512107,-0.0031710046,-0.1984558),vec4(-0.12219253,0.057547435,-0.048030246,-0.004034821),vec4(-0.15719691,0.07992829,-0.0944009,0.11305939),vec4(-0.21976554,-0.07928298,0.09194043,0.13884124)) * bufB[0] + mat4(vec4(-0.08996135,-0.045380387,-0.17637771,-0.12061582),vec4(-0.16580205,0.22057995,0.013319223,0.062214714),vec4(0.04315302,-0.12971723,0.029528502,0.107209764),vec4(0.12664157,-0.17674501,-0.005964303,-0.1217096)) * bufB[1] + mat4(vec4(0.050336163,-0.12026181,0.12960725,0.02069624),vec4(0.15919061,0.11227077,0.10313473,-0.13052619),vec4(0.1320101,-0.02733335,0.037948783,0.013970191),vec4(0.20752248,-0.0672652,0.16186099,-0.030125499)) * bufB[2] + mat4(vec4(0.32280624,-0.18557483,-0.022800857,-0.032858174),vec4(0.0026270985,0.0885679,0.17899188,-0.15757848),vec4(-0.14252235,-0.101753466,0.2430828,-0.006761153),vec4(-0.16592434,-0.3087009,0.2908108,0.13577609)) * bufB[3] + mat4(vec4(0.0023920736,0.07842311,-0.020020809,0.10221627),vec4(-0.25221395,0.1122392,-0.12446288,0.03822513),vec4(0.055441074,0.1885443,0.067699395,-0.033011746),vec4(0.056228492,-0.036769543,0.05783564,0.09719141)) * bufB[4] + mat4(vec4(0.12049914,-0.13139588,0.046631034,0.1515993),vec4(0.15210979,-0.11740077,-0.24362677,-0.10187156),vec4(-0.044386156,0.1788465,-0.10016655,0.2252573),vec4(0.057550784,0.12642746,0.0001414569,-0.16953245)) * bufB[5] + mat4(vec4(0.075749554,-0.1940833,-0.012423391,0.08288552),vec4(0.3204709,-0.0050166533,0.14815307,-0.1335414),vec4(-0.16277586,-0.10936399,-0.1044122,-0.030167082),vec4(-0.24718663,0.041993834,-0.06335834,0.23820925)) * bufB[6] + mat4(vec4(-0.09658452,-0.123578094,0.02874423,0.051967088),vec4(0.012404922,0.19295077,-0.10941164,-0.062365104),vec4(-0.14786565,0.12894917,-0.10370244,-0.08360851),vec4(0.34754494,-0.11501367,0.09881162,-0.1018906)) * bufB[7] + mat4(vec4(0.09127045,-0.11454851,0.21853524,-0.015155673),vec4(-0.1978591,0.0755531,0.15435317,-0.025623906),vec4(-0.14786671,0.028878117,-0.010843096,-0.089088485),vec4(-0.1900323,-0.24375209,-0.076338395,0.048892967)) * bufB[8] + mat4(vec4(-0.013379569,0.0031282178,0.12693675,0.067729004),vec4(0.043925647,-0.15288411,-0.035889555,-0.036316346),vec4(0.0917014,0.122270696,0.097467564,0.2057326),vec4(0.0010636572,-0.08136818,0.06753837,-0.045696586)) * bufB[9] + mat4(vec4(0.05698838,0.13134456,-0.053082578,-0.15414834),vec4(-0.1523721,-0.023919454,0.03145729,-0.21855131),vec4(-0.13168573,0.067231044,-0.07307072,-0.19438021),vec4(0.06285358,0.09545976,0.08104726,0.14418744)) * bufB[10] + mat4(vec4(0.115591,-0.061482962,0.009184294,0.07070854),vec4(-0.03699874,0.02590274,-0.0767581,0.20932052),vec4(0.17298251,-0.070878595,-0.092642315,0.13457404),vec4(-0.07762719,-0.28958163,0.15716925,0.02185272)) * bufB[11] + mat4(vec4(-0.12253431,-0.124595545,0.08368244,-0.06427523),vec4(0.14126413,0.16144538,-0.07820251,0.15923549),vec4(-0.04047888,-0.33423492,0.14497802,-0.2845018),vec4(0.15957263,0.059976004,0.07121137,-0.021785466)) * bufB[12] + mat4(vec4(0.061213166,0.13866681,0.05889561,0.11637488),vec4(0.049246117,-0.040842183,-0.4198953,0.13786176),vec4(0.019240996,-0.14673473,-0.092120185,-0.014180543),vec4(-0.10045101,-0.07302797,0.13714147,0.3799292)) * bufB[13] + mat4(vec4(0.08823512,-0.13893151,-0.06877979,0.15978573),vec4(0.02006753,-0.12211716,-0.16746171,-0.074851386),vec4(-0.1825262,-0.180692,0.07150367,0.069428325),vec4(0.014294284,-0.08234722,-0.047960676,0.003793606)) * bufB[14] + mat4(vec4(0.15515426,0.018996278,0.013408229,-0.106607415),vec4(0.027088204,0.107917964,-0.08545663,-0.08071434),vec4(0.16154863,0.05565786,0.048371583,-0.04781005),vec4(-0.009119142,0.018860893,-0.04970876,0.05391394)) * bufB[15] + mat4(vec4(0.06637901,0.021688646,-0.03255857,-0.044008773),vec4(-0.022995042,0.07934093,0.080898054,-0.038785838),vec4(-0.17816879,0.0027675678,0.19860664,0.099491365),vec4(-0.10213156,-0.025168704,0.3933556,0.022017408)) * bufB[16] + mat4(vec4(0.0837567,-0.1804962,-0.05682784,0.011319926),vec4(0.14045025,0.017449994,0.14946362,-0.06893391),vec4(-0.059478033,-0.09290871,-0.06801506,0.019522361),vec4(0.023126803,0.14964375,0.24360734,0.0042193993)) * bufB[17] + mat4(vec4(0.11044138,0.15587911,0.07329928,-0.014002698),vec4(-0.03860027,0.04068194,-0.21462995,0.047848985),vec4(0.03422021,0.29654124,-0.080487736,-0.02256285),vec4(0.008480374,0.14582953,-0.22319539,-0.05637399)) * bufB[18] + mat4(vec4(0.0868613,-0.035313934,-0.07412206,-0.09430868),vec4(-0.05589975,0.13988328,0.24649659,0.019120023),vec4(0.004005439,-0.18627584,0.0668998,0.0057930523),vec4(0.062250324,0.05183016,-0.07563086,-0.14934368)) * bufB[19] + mat4(vec4(0.23049551,0.11880632,0.031154994,-0.32855263),vec4(-0.2905987,-0.029092152,-0.0819702,0.04507177),vec4(0.13062766,0.14639644,0.002871844,0.0053242776),vec4(0.1432603,0.0016563421,-0.09652339,0.02656438)) * bufB[20] + mat4(vec4(-0.121630654,-0.021730442,-0.14472601,-0.02257366),vec4(0.05526809,0.0512496,-0.022704484,-0.092393875),vec4(0.00089247513,-0.042175684,-0.09311158,-0.1201656),vec4(-0.061942432,0.098001614,0.016040644,-0.06480932)) * bufB[21] + mat4(vec4(-0.037972216,0.043394707,0.05978438,-0.13859434),vec4(0.09870289,-0.028728092,0.10903784,0.3347071),vec4(0.04197379,-0.12776196,-0.02030207,0.0005392572),vec4(0.077556446,0.06774355,-0.010697179,0.08037872)) * bufB[22] + mat4(vec4(-0.04493957,-0.16411777,-0.09478079,-0.19292407),vec4(0.06878603,0.16798072,-0.027759442,-0.32140782),vec4(0.006554183,0.15005228,0.22486892,0.14661822),vec4(-0.049471058,0.38267234,0.15069513,0.18742605)) * bufB[23] + mat4(vec4(0.2751627,0.10371417,0.11268862,0.025214292),vec4(-0.13890946,0.024152549,-0.097735286,0.089279704),vec4(0.13302924,0.09370553,0.060135037,0.018344423),vec4(-0.33198014,0.078328855,-0.062077172,-0.08613417)) * bufB[24] + mat4(vec4(-0.046214614,-0.04221137,0.06768806,0.10590832),vec4(-0.08214151,0.11324874,0.1350237,-0.011021623),vec4(0.27692917,0.081676476,-0.16634242,0.11912724),vec4(-0.017518518,-0.090756,0.13754624,-0.19154777)) * bufB[25] + mat4(vec4(-0.08797584,0.057502456,0.04581562,-0.23594853),vec4(-0.27510566,-0.110862084,-0.004648939,-0.30747518),vec4(-0.0017078783,0.16919546,-0.03356646,0.11816402),vec4(0.0016400488,0.06540688,-0.18067446,0.20330362)) * bufB[26] + mat4(vec4(-0.2750489,-0.12975623,-0.05990859,-0.080136895),vec4(0.0013530371,-0.111671604,-0.02001881,-0.028732266),vec4(0.08243013,-0.061372355,-0.14506587,-0.029205687),vec4(-0.058246788,0.13932553,-0.076614775,-0.080779575)) * bufB[27] + mat4(vec4(0.2326003,0.0421923,0.057200473,0.16866878),vec4(-0.14475296,-0.1882445,0.0072268597,0.06242827),vec4(0.29645342,0.2379454,-0.15236546,0.08543636),vec4(-0.14352873,-0.115364216,0.023405556,0.006470649)) * bufB[28] + mat4(vec4(-0.03655225,0.120120436,0.14134422,0.042844567),vec4(-0.030394567,0.17448913,0.03232823,0.0342998),vec4(0.17155051,0.05625016,-0.030348385,0.08989854),vec4(0.16317247,-0.09317326,-0.105144195,-0.05473928)) * bufB[29] + mat4(vec4(0.023452202,-0.10695031,-0.17242578,0.16662176),vec4(0.040174313,-0.08628716,0.1639814,-0.051519997),vec4(0.13829784,0.2491087,0.07915371,0.049112923),vec4(0.020830914,0.0029068845,0.06479206,-0.110817)) * bufB[30] + mat4(vec4(0.0022311509,0.028151225,-0.036437415,0.02501414),vec4(0.14743,0.07753075,0.10936337,-0.2548955),vec4(-0.00023833622,-0.07527913,0.09056733,-0.017737148),vec4(0.13076289,-0.053537827,0.034661766,0.0070992587)) * bufB[31];\nbufA[3] = vec4(-0.06234701,-0.05315703,-0.048303112,-0.07507754) + mat4(vec4(0.15917185,0.20270446,-0.0021538239,-0.09877482),vec4(0.044071205,-0.2179226,0.07777954,-0.2697668),vec4(0.03426565,-0.03691306,0.09565945,-0.12705575),vec4(0.13294391,0.112454474,0.047545023,0.048063688)) * bufB[0] + mat4(vec4(-0.21905419,-0.048069656,0.14812782,0.088519484),vec4(-0.06932096,-0.017748166,-0.26687533,0.011056737),vec4(0.104899555,-0.10983288,0.1461167,0.03220598),vec4(0.111768916,0.2703922,-0.07902371,0.038843192)) * bufB[1] + mat4(vec4(0.13715647,-0.06544357,0.15044639,0.13326463),vec4(0.15792945,0.0049888184,-0.017551765,0.08488796),vec4(0.11226404,0.0713715,-0.020177338,-0.031317458),vec4(0.023556119,0.05076172,-0.17558108,0.042522646)) * bufB[2] + mat4(vec4(-0.16000396,-0.05488659,-0.0117742345,0.12232403),vec4(-0.06776146,-0.109524675,0.046990033,-0.01018698),vec4(-0.010036704,-0.13681886,0.13066573,0.061734058),vec4(-0.004142786,-0.044848464,0.094441384,0.1410709)) * bufB[3] + mat4(vec4(-0.09206468,0.036200482,-0.19981995,0.16135053),vec4(-0.11274925,0.18855217,0.1353632,0.10920112),vec4(0.30318695,0.015016884,0.074017316,-0.054641098),vec4(0.108386464,-0.19413832,-0.045001153,0.03189209)) * bufB[4] + mat4(vec4(0.07365314,-0.11304431,0.05588945,-0.022597931),vec4(0.13488212,0.14167927,0.15671924,0.006989414),vec4(-0.43135387,-0.08441157,-0.12184854,-0.027892303),vec4(-0.047795713,-0.112620436,-0.044251703,0.08471352)) * bufB[5] + mat4(vec4(0.15910915,0.15024701,0.0115549425,-0.30512002),vec4(-0.26008618,0.021911807,0.27520022,0.12975441),vec4(0.13972814,-0.02620225,-0.17947721,0.009730211),vec4(-0.13070719,0.07207824,-0.15600365,0.16396248)) * bufB[6] + mat4(vec4(0.08331618,-0.123558044,-0.07431316,-0.15591413),vec4(0.0708238,0.076124035,0.047701847,-0.08865249),vec4(-0.115831584,0.17117015,-0.10840079,0.17458424),vec4(-0.13623908,0.2823634,-0.10667742,0.124809206)) * bufB[7] + mat4(vec4(-0.14345393,-0.012831825,0.18025652,0.20737518),vec4(0.0028712032,-0.032706667,0.08029798,-0.10365325),vec4(-0.04893822,0.030643271,-0.080087095,-0.015399627),vec4(-0.1673039,-0.1552892,-0.17609026,-0.0034893302)) * bufB[8] + mat4(vec4(0.061845586,0.10349354,-0.018433016,-0.20708345),vec4(-0.06515234,0.010440617,0.11217257,0.2089932),vec4(-0.06939437,0.12709527,-0.069496445,-0.021555977),vec4(0.0072807865,0.008716653,0.23156182,0.049325578)) * bufB[9] + mat4(vec4(-0.010443638,-0.23233703,0.047441382,0.07093614),vec4(0.034322817,-0.13656983,-0.15344769,0.08078029),vec4(-0.20122875,-0.044240993,-0.053842254,-0.035699457),vec4(0.042720843,0.16248547,0.0061762715,0.20099759)) * bufB[10] + mat4(vec4(-0.094392195,0.1031521,0.06269134,0.019601071),vec4(0.05476465,-0.13813853,0.35119867,-0.052729007),vec4(0.025259407,-0.041575897,-0.0056395745,-0.030732704),vec4(0.058504727,0.22340131,-0.047025293,-0.0069392817)) * bufB[11] + mat4(vec4(0.07597817,0.13842398,0.20301594,0.08287378),vec4(0.17965527,0.070328236,-0.056378998,-0.120876856),vec4(0.013351132,0.067281194,-0.14898701,0.04402798),vec4(0.23775758,0.09383026,0.08885974,0.25119868)) * bufB[12] + mat4(vec4(-0.0491191,0.10391782,-0.17446457,-0.08105544),vec4(0.027068025,-0.06124323,-0.008141798,-0.06524164),vec4(0.1784929,0.008053542,0.21736377,-0.21821447),vec4(-0.10410384,-0.25643826,-0.14445136,0.34779823)) * bufB[13] + mat4(vec4(-0.040786445,-0.025029302,-0.061948907,-0.12133093),vec4(-0.009614239,-0.16445014,0.13486117,0.07454942),vec4(-0.020231912,-0.1297522,-0.11168336,0.00028502464),vec4(0.12853514,-0.06397231,0.10056462,-0.09993666)) * bufB[14] + mat4(vec4(0.11950586,-0.0014269517,-0.039215975,-0.14728074),vec4(0.24629125,0.2084904,-0.3661241,0.0017533657),vec4(-0.14195336,0.060744517,0.08591852,0.08057275),vec4(0.068980224,-0.061183795,0.08101586,-0.082472295)) * bufB[15] + mat4(vec4(-0.11197043,0.19660707,-0.07145732,-0.0010225405),vec4(0.13247095,-0.058852017,-0.0013332808,-0.17101753),vec4(-0.15512027,0.10360942,-0.07185275,0.10540058),vec4(-0.057244442,0.078092225,0.2718684,-0.043720406)) * bufB[16] + mat4(vec4(-0.09160837,0.06544278,-0.027806414,-0.16880538),vec4(-0.10931652,-0.079405166,-0.022875154,0.20490268),vec4(0.0847539,0.04889196,-0.002703819,-0.112125374),vec4(0.31429762,-0.039500013,-0.002733348,-0.020108752)) * bufB[17] + mat4(vec4(0.26623458,0.14792468,0.1674639,0.014817713),vec4(-0.016579682,-0.056894995,0.012761468,0.023572236),vec4(0.2295703,-0.060114995,-0.1355437,-0.13036637),vec4(0.009395728,-0.08642,-0.08784549,-0.12021277)) * bufB[18] + mat4(vec4(0.046598192,-0.22933193,0.044845924,-0.19189936),vec4(0.12040762,-0.052239902,0.21182618,-0.13905066),vec4(0.076450564,-0.047149967,-0.2907493,-0.18152155),vec4(-0.12582831,-0.12758511,-0.032883625,-0.009321255)) * bufB[19] + mat4(vec4(0.18915573,-0.013045477,-0.035394736,-0.03478086),vec4(0.13549945,-0.09988392,0.05221624,-0.021237982),vec4(0.14302345,-0.007954113,-0.042861488,-0.013247553),vec4(0.15187036,-0.13133843,0.037927482,0.0014996247)) * bufB[20] + mat4(vec4(-0.024715176,-0.19796231,-0.19351433,-0.06245232),vec4(-0.058598556,-0.026349178,-0.19051003,-0.20360363),vec4(-0.15753546,0.0028423541,-0.09292903,0.14145881),vec4(-0.1391446,-0.039021946,-0.021735149,-0.010354179)) * bufB[21] + mat4(vec4(0.026763719,-0.06724242,0.10265053,-0.1501459),vec4(0.027302092,0.06464789,0.18718866,0.3713665),vec4(-0.11386443,-0.0017108604,-0.030160349,-0.07017453),vec4(-0.040617038,-0.19587581,-0.32256085,-0.0016679625)) * bufB[22] + mat4(vec4(0.11515264,-0.00033207802,0.04012249,0.19822627),vec4(-0.1458926,0.2426184,-0.02823269,0.09445513),vec4(-0.09758332,0.25652114,-0.15826176,-0.06353464),vec4(-0.124056056,0.5081092,0.064451165,-0.026980571)) * bufB[23] + mat4(vec4(0.097792305,0.026547406,-0.03496173,-0.0005757544),vec4(-0.035526857,-0.060748007,-0.078049086,0.133205),vec4(-0.16304556,0.018621435,0.040016208,-0.27777928),vec4(-0.16035217,0.08096325,-0.0038864366,0.14061044)) * bufB[24] + mat4(vec4(0.012746278,0.044068865,0.058225103,-0.11872858),vec4(0.10952728,-0.10121634,-0.10265196,0.061730895),vec4(0.043868646,0.04038293,0.06878464,-0.32488865),vec4(0.06739442,-0.014335737,0.02307465,0.15468618)) * bufB[25] + mat4(vec4(-0.054692805,-0.037493367,0.1084818,0.3459919),vec4(0.22759157,0.1577757,-0.22968847,-0.1166311),vec4(0.037180882,-0.05085764,0.07746537,0.031663265),vec4(-0.17837489,0.0016407369,-0.24554817,-0.07842569)) * bufB[26] + mat4(vec4(0.08426722,-0.0880871,0.03882244,0.02835861),vec4(-0.037027907,0.020818405,-0.07570084,0.07690048),vec4(-0.21118997,0.0845673,0.10873714,-0.18936108),vec4(-0.08343348,0.07474076,0.21482973,-0.029636143)) * bufB[27] + mat4(vec4(0.12874284,0.26962778,-0.22237307,-0.1368643),vec4(-0.13145952,0.020025386,-0.3133118,-0.08540563),vec4(-0.0065221656,-0.042683344,0.12727645,-0.027180946),vec4(0.060923632,-0.11805708,0.035346005,-0.25482318)) * bufB[28] + mat4(vec4(-0.10745883,0.09090659,-0.0430926,0.10626475),vec4(-0.0285061,-0.18217286,0.09344423,0.013455657),vec4(0.122060165,0.26988614,0.21698634,0.21292496),vec4(0.017103918,0.032536164,0.09506207,0.11480778)) * bufB[29] + mat4(vec4(0.17080037,-0.035428,0.038311306,0.027958216),vec4(-0.022396637,-0.050189637,0.13596323,-0.17639893),vec4(0.11012558,-0.009348712,-0.07498255,-0.009119205),vec4(0.06490147,0.1677573,0.047937855,0.058716755)) * bufB[30] + mat4(vec4(0.08664512,0.008811128,-0.13850312,-0.1712201),vec4(0.04119664,-0.079529904,-0.19756787,-0.065053865),vec4(-0.09758769,-0.22060338,-0.06344787,-0.08515451),vec4(-0.09875153,-0.116465956,0.035531558,-0.03743906)) * bufB[31];\nbufA[4] = vec4(0.0077752564,-0.05851089,-0.12639314,-0.031054903) + mat4(vec4(0.13199903,0.09559471,0.12995388,0.07936725),vec4(-0.05156243,0.11746496,0.09606528,0.18377009),vec4(0.1593356,0.17365743,0.049119905,-0.10021009),vec4(0.14060543,0.26357988,-0.08571987,0.3084956)) * bufB[0] + mat4(vec4(-0.26424325,0.11771553,0.07379327,-0.027981963),vec4(-0.03645705,-0.12347009,0.0837142,-0.12924047),vec4(0.0646227,0.13712215,-0.026670638,0.1289861),vec4(0.0997266,-0.0819851,-0.02691393,0.19814722)) * bufB[1] + mat4(vec4(-0.056049258,-0.24686792,0.14749865,0.024286997),vec4(0.00826394,0.030291157,-0.060407266,-0.087694734),vec4(-0.09947015,0.057625946,-0.088545695,0.07788777),vec4(-0.16052276,-0.08018694,-0.20183593,0.0026985474)) * bufB[2] + mat4(vec4(0.0006169493,-0.18723887,-0.071048744,-0.024914088),vec4(0.18827006,0.053992786,-0.062285773,-0.15745272),vec4(-0.36225367,0.30625913,0.20465176,0.00043061544),vec4(0.11079026,-0.060103413,-0.04507898,-0.081145935)) * bufB[3] + mat4(vec4(-0.23006608,-0.17940912,-0.010183569,0.12238582),vec4(0.0584795,-0.16681866,-0.24037856,-0.121340886),vec4(-0.047114126,-0.003063622,0.042982843,0.06147065),vec4(0.30108282,-0.055601563,-0.02987209,0.15888314)) * bufB[4] + mat4(vec4(0.12688997,-2.9075076e-05,-0.08803257,-0.19901258),vec4(-0.12185065,0.079368316,0.031470153,0.09251093),vec4(-0.092129424,-0.0009343104,-0.048624355,-0.475182),vec4(-0.078198984,0.004669434,-0.028508548,0.0185075)) * bufB[5] + mat4(vec4(-0.0751545,0.09881345,-0.033226363,-0.035270702),vec4(-0.13222146,-0.03764015,0.07892079,-0.16578007),vec4(-0.09204091,0.033890717,-0.22305495,-0.0044976715),vec4(-0.04493001,0.04175334,0.060244076,-0.02704778)) * bufB[6] + mat4(vec4(-0.034719586,-0.10117658,0.016725745,-0.07767069),vec4(0.14101015,-0.1379308,0.054926604,-0.07797772),vec4(-0.104442,0.025492104,0.16492212,0.0519982),vec4(0.016602475,-0.028432755,-0.07952434,-0.020085247)) * bufB[7] + mat4(vec4(-0.0030398956,-0.14174284,-0.21111873,0.027127834),vec4(0.24364895,-0.14458795,-0.124028735,-0.108334646),vec4(-0.14440234,-0.13228492,-0.060229633,0.11609437),vec4(-0.22502874,-0.03573353,0.06248856,-0.16268824)) * bufB[8] + mat4(vec4(-0.1459324,-0.08959992,-0.10390606,0.011193035),vec4(-0.11935093,-0.042289875,0.11189167,-0.17803411),vec4(-0.08638364,-0.22242723,-0.14467974,-0.27471203),vec4(0.19594829,0.12462225,0.115119234,0.2213057)) * bufB[9] + mat4(vec4(-0.050894603,0.02578574,0.1860635,-0.06359478),vec4(-0.14664899,0.31841463,-0.16319491,-0.02433593),vec4(-0.22035022,0.068554446,-0.084478304,-0.032006823),vec4(-0.047145873,0.045015037,-0.1077262,0.16107893)) * bufB[10] + mat4(vec4(-0.21937996,-0.0016410691,0.11257014,0.17365591),vec4(0.040931467,0.12826747,0.02569803,-0.00019659416),vec4(0.037210647,0.07664041,-0.0473158,0.12759203),vec4(0.25769493,-0.052415997,0.04241294,0.16198759)) * bufB[11] + mat4(vec4(-0.35899726,-0.19146943,-0.055111796,0.13171303),vec4(-0.02301989,0.20219027,0.3180034,-0.0762531),vec4(0.22168787,-0.08696429,0.016115513,-0.14309198),vec4(-0.018147228,-0.045624826,0.11496083,0.047027145)) * bufB[12] + mat4(vec4(-0.066481486,0.12274506,-0.023435578,-0.16231085),vec4(0.029378405,0.0010826433,0.07046942,-0.030141111),vec4(-0.11574993,-0.049700238,-0.3067353,0.14704305),vec4(-0.13099691,-0.158711,-0.2270191,0.28719848)) * bufB[13] + mat4(vec4(-0.16107184,0.069147594,-0.14274527,-0.1696865),vec4(-0.055283673,-0.0068256627,0.16197371,0.24761976),vec4(-0.100289725,0.07557568,0.042194396,-0.030605415),vec4(-0.0038003246,0.04428877,0.054280814,-0.0517621)) * bufB[14] + mat4(vec4(0.055109996,0.062830284,0.12579395,0.26009655),vec4(0.03953747,-0.087370716,-0.03587562,0.06147631),vec4(-0.19772612,0.051616125,0.013424805,-0.011140862),vec4(-0.054275356,0.081618704,0.064589955,0.035602003)) * bufB[15] + mat4(vec4(0.035463642,-0.20759217,0.11161526,-0.21411994),vec4(-0.1659716,0.090528145,0.06638816,-0.030243628),vec4(0.015738055,0.0025517028,-0.28244442,-0.009310118),vec4(-0.08726836,0.026844935,-0.15157144,0.049514364)) * bufB[16] + mat4(vec4(-0.006513281,-0.22327834,-0.0042043296,0.09192327),vec4(-0.15765844,-0.008431232,-0.14473061,0.16853565),vec4(0.110077,0.108007826,-0.22578846,-0.074441165),vec4(0.12926945,0.062413223,-0.055523444,-0.19021463)) * bufB[17] + mat4(vec4(0.06452579,0.10753344,-0.037286635,0.06853815),vec4(0.07435978,-0.075260505,-0.01369335,-0.14302118),vec4(-0.0032316044,0.14825979,-0.16543518,-0.08409541),vec4(0.10453965,-0.1326261,-0.09817445,0.019304333)) * bufB[18] + mat4(vec4(-0.21841668,0.29181975,-0.051770873,-0.20143664),vec4(0.009733095,0.021961672,0.007972952,0.0012751584),vec4(-0.21909745,-0.07184662,-0.11038671,-0.08353057),vec4(0.13152365,0.20072739,0.08628652,-0.08559766)) * bufB[19] + mat4(vec4(0.06689408,0.2329659,-0.055427592,-0.07158394),vec4(-0.012931177,0.040365625,-0.034646444,0.12627804),vec4(0.06524958,0.2125357,0.035356764,-0.0037397312),vec4(0.03171255,0.1282517,0.024768038,-0.07584423)) * bufB[20] + mat4(vec4(0.06445464,0.036500618,0.06575671,-0.18072009),vec4(-0.07833226,-0.06645956,-0.11967668,-0.0742326),vec4(0.11937329,-0.013096252,-0.24931268,-0.030441467),vec4(0.1312801,0.14100443,0.014386488,-0.0022557708)) * bufB[21] + mat4(vec4(0.075399876,0.18288581,-0.043877024,-0.0113137355),vec4(-0.049846932,0.040608756,-0.18815438,-0.013569585),vec4(0.1663052,-0.021325223,-0.10633423,-0.11331319),vec4(-0.012632544,0.097759925,0.1167756,-0.018108502)) * bufB[22] + mat4(vec4(0.2269093,-0.07092231,0.022981673,0.06064689),vec4(0.038098905,0.025690135,0.1397525,-0.006113639),vec4(0.13923249,0.027950376,-0.1805926,-0.06969377),vec4(-0.06402827,-0.07610231,-0.1528103,-0.017127637)) * bufB[23] + mat4(vec4(-0.086025655,-0.046312287,-0.14210665,0.01596282),vec4(0.108392924,-0.21209143,-0.09994943,-0.023156669),vec4(-0.013645493,0.2331619,0.0662472,-0.01310238),vec4(0.037034094,-0.0026932927,0.08222955,-0.08134204)) * bufB[24] + mat4(vec4(0.12670231,-0.03319634,-0.06285411,-0.07323508),vec4(0.086218506,0.0062769665,-0.10423611,0.010606633),vec4(-0.009602057,0.03499318,0.18889518,0.07672752),vec4(-0.12195031,0.048469856,-0.089942284,-0.18592769)) * bufB[25] + mat4(vec4(0.006576503,-0.09940702,0.07862664,-0.07435779),vec4(0.089555524,-0.07975259,-0.056221396,-0.03589269),vec4(-0.26552358,0.36928248,0.12373256,0.095800795),vec4(0.14998138,0.039700463,-0.103799574,-0.13347907)) * bufB[26] + mat4(vec4(-0.030116556,0.061779168,0.12492384,0.07495742),vec4(0.1384453,0.11111198,0.09440552,0.04406969),vec4(0.07079438,-0.0703553,0.20812806,0.030968169),vec4(-0.034000766,-0.01890472,0.044618145,0.08344952)) * bufB[27] + mat4(vec4(0.16627063,0.023464458,0.1852688,0.0327974),vec4(0.23529667,0.15729465,-0.03376509,0.051837914),vec4(0.04988789,0.01991007,-0.3543474,-0.15904938),vec4(0.017038744,0.07824726,-0.08175188,0.18327305)) * bufB[28] + mat4(vec4(-0.030186452,0.28477,-0.23776609,-0.18262014),vec4(0.035900105,-0.10587136,0.09342581,-0.26178065),vec4(-0.14960186,0.001951579,-0.09027971,0.22748238),vec4(0.20426255,-0.1590581,-0.12241566,-0.054323662)) * bufB[29] + mat4(vec4(-0.007398875,-0.2823905,0.06876272,0.1816609),vec4(-0.033493858,0.098839104,-0.071906425,-0.15702942),vec4(0.007825571,0.09291983,-0.065128505,-0.024077684),vec4(0.040275637,-0.19000551,0.06888711,0.30353647)) * bufB[30] + mat4(vec4(-0.0023531718,0.105898924,-0.0022774797,0.040834446),vec4(-0.047028683,0.11969515,0.27592865,-0.07671624),vec4(-0.11061831,0.012549253,0.12323466,0.07449536),vec4(-0.05667514,0.09748688,0.054116372,0.07527698)) * bufB[31];\nbufA[5] = vec4(-0.070550315,-0.115090854,0.026356293,0.03798456) + mat4(vec4(-0.0797441,-0.016642991,-0.025969874,0.1834736),vec4(0.030914614,-0.021342041,-0.014931696,0.075415544),vec4(-0.10476379,-0.1098219,-0.060618896,-0.07770499),vec4(-0.12767771,-0.06435189,0.10853732,0.02871964)) * bufB[0] + mat4(vec4(0.13184428,0.014881179,-0.11616117,0.1279995),vec4(0.012065576,0.04954174,0.04776206,-0.14089464),vec4(-0.19307396,0.10539942,-0.04904055,-0.070381396),vec4(-0.36000657,0.23433596,-0.011405107,-0.22039428)) * bufB[1] + mat4(vec4(0.19966702,0.13180813,0.08356979,-0.010283269),vec4(0.07642542,0.114399694,-0.18332592,0.09661582),vec4(0.12440596,-0.15878446,-0.0693635,-0.26795027),vec4(-0.11956698,-0.13893242,-0.113394454,-0.04490438)) * bufB[2] + mat4(vec4(-0.055335477,-0.045439057,-0.14303714,-0.07012191),vec4(0.20368838,-0.100505814,-0.06845951,-0.058465526),vec4(-0.04528941,0.02092062,0.24465403,-0.048509788),vec4(0.019705111,-0.033191282,0.04776373,0.05590903)) * bufB[3] + mat4(vec4(-0.07697968,0.07587025,-0.076849654,0.090327315),vec4(0.088295616,-0.11989482,-0.19685428,0.265575),vec4(0.18194228,-0.0863201,0.19412111,0.14708361),vec4(-0.03593427,-0.07489283,-0.04845583,0.085127525)) * bufB[4] + mat4(vec4(0.15254465,-0.13831995,-0.09510458,0.096425116),vec4(-0.20698208,-0.010504089,0.07301142,0.025010552),vec4(0.26540956,0.10385245,0.05540415,0.043540407),vec4(0.026404262,-0.035054527,0.07313407,0.015359558)) * bufB[5] + mat4(vec4(-0.2577705,-0.058493193,0.013014104,0.08223175),vec4(0.13662772,0.13660553,0.04573544,-0.31941688),vec4(0.02655036,-0.09151733,0.024610832,-0.02749839),vec4(-0.16481073,-0.2649486,0.0880756,-0.049896833)) * bufB[6] + mat4(vec4(-0.010389288,0.100405775,-0.17631292,0.14759949),vec4(0.0033137188,0.056062963,0.052902985,0.010109131),vec4(-0.16352518,0.025960866,-0.020851752,-0.07739819),vec4(-0.060774513,0.0008831213,0.16042207,-0.08764647)) * bufB[7] + mat4(vec4(0.109968156,0.23568518,0.026366873,0.28184146),vec4(0.05736885,-0.04129255,-0.019017033,-0.046954855),vec4(-0.25627455,-0.13295214,0.10762606,0.052001484),vec4(-0.28179884,-0.035534147,-0.093350455,-0.21153006)) * bufB[8] + mat4(vec4(-0.062807195,-0.03578911,-0.05573264,0.091351785),vec4(0.044763573,-0.026398793,0.0057617943,0.07563546),vec4(-0.10439293,0.30028793,-0.06468646,-0.1043533),vec4(-0.08066829,-0.31994888,-0.022166122,-0.1081294)) * bufB[9] + mat4(vec4(-0.06442852,-0.023726165,-0.1377548,0.13546991),vec4(-0.018478934,0.16407348,-0.041875698,0.05020235),vec4(0.25757083,0.09288449,-0.07835685,0.10296925),vec4(0.15992208,-0.06345493,0.14044814,-0.08369892)) * bufB[10] + mat4(vec4(-0.19080955,0.25543702,-0.034947462,0.20793481),vec4(0.05050626,0.018604107,-0.27773756,-0.015999721),vec4(-0.0892528,-0.09279593,0.1357158,0.055389818),vec4(0.16840269,0.17759617,-0.17001647,0.098406844)) * bufB[11] + mat4(vec4(0.06549799,0.007873787,0.20360456,-0.04762032),vec4(-0.18728635,-0.28428137,-0.15041994,-0.2255408),vec4(0.18916608,-0.3296011,-0.21016857,0.06500077),vec4(0.14481708,0.15933755,-0.006322791,0.07828436)) * bufB[12] + mat4(vec4(-0.049145237,-0.047449492,0.06698801,-0.0050953147),vec4(-0.06385692,-0.08308782,-0.18121809,-0.10838519),vec4(-0.016666988,-0.058953248,0.02118825,-0.015685266),vec4(0.10485539,-0.2061324,0.09623538,-0.13765553)) * bufB[13] + mat4(vec4(0.06507668,0.0015557448,-0.050440695,-0.09036971),vec4(-0.1671122,-0.03203197,-0.10443965,0.06934584),vec4(-0.05056605,0.020478658,0.053662106,0.0025831936),vec4(-0.10159394,0.12305679,-0.24807751,-0.14145169)) * bufB[14] + mat4(vec4(0.0938608,-0.10945549,0.1297393,-0.033545803),vec4(-0.04866893,0.12039849,-0.19290991,0.13269188),vec4(-0.0087313745,0.21452872,0.026227493,0.1408725),vec4(-0.0677564,0.026739292,-0.03885623,0.12544915)) * bufB[15] + mat4(vec4(0.06504522,-0.031038309,-0.03172993,0.050555315),vec4(0.094452314,-0.017132504,0.24421623,0.11285316),vec4(-0.08651093,0.08740251,0.057291966,0.039370976),vec4(0.05199187,0.13369796,0.104006015,0.21969585)) * bufB[16] + mat4(vec4(-0.04170174,0.07704841,0.21473953,-0.19611157),vec4(0.048035316,-0.027620034,0.07940327,0.11931678),vec4(-0.0069885547,-0.1884928,-0.033271372,0.031405285),vec4(0.20410785,-0.065744445,0.13409324,0.31297654)) * bufB[17] + mat4(vec4(0.029189149,0.14087719,0.24592052,0.17812033),vec4(-0.12512098,-0.29072252,-0.037768137,-0.2281928),vec4(0.14504944,0.0052741044,0.10838169,0.003875964),vec4(0.055896685,0.06741867,-0.11913328,-0.011407734)) * bufB[18] + mat4(vec4(0.12343297,-0.16565631,0.015314884,0.13256913),vec4(0.04768946,-0.04368591,-0.18393539,-0.11337108),vec4(0.026738517,-0.0720443,-0.023030192,-0.13495645),vec4(0.14361286,-0.15756316,0.1838833,-0.024311496)) * bufB[19] + mat4(vec4(-0.08360638,-0.0912064,0.047351535,-0.22563386),vec4(0.012179518,-0.042926773,-0.112077504,-0.260747),vec4(-0.09909691,-0.1795644,-0.13195601,-0.068791136),vec4(0.19036743,0.09341417,0.13588654,0.095190704)) * bufB[20] + mat4(vec4(0.1753703,0.18193981,0.059227288,-0.018333374),vec4(-0.12077493,0.029928593,0.097688094,-0.13182646),vec4(0.010157344,0.09421914,-0.17126743,0.115065865),vec4(0.05392453,-0.1832035,-0.043373317,-0.12235052)) * bufB[21] + mat4(vec4(0.08805015,-0.21224405,-0.0031072677,-0.06349437),vec4(-0.09662296,-0.017353898,0.20272167,0.1167893),vec4(0.038871784,0.22044463,0.06531852,0.016194208),vec4(-0.080448985,0.06390788,-0.010704681,-0.1523248)) * bufB[22] + mat4(vec4(0.1790373,-0.058379147,-0.043680545,0.038055092),vec4(0.008352624,0.023370825,-0.13639835,0.009558393),vec4(-0.069506325,0.116962776,0.102749914,0.087681845),vec4(0.12419915,0.22493641,0.06936545,0.14683959)) * bufB[23] + mat4(vec4(0.067593314,-0.039994977,0.18957572,0.1883468),vec4(-0.18075186,0.19395892,-0.05494769,0.44504514),vec4(0.0030015607,0.07843457,-0.0448026,-0.09077328),vec4(-0.12669674,-0.17925534,-0.009513978,0.013280194)) * bufB[24] + mat4(vec4(-0.08057951,0.09221119,-0.054962974,-0.050558124),vec4(0.11331714,-0.21099088,-0.052594073,-0.037606973),vec4(-0.18361609,0.040998414,0.26651463,0.14907654),vec4(-0.015001914,-0.03025352,-0.057911217,-0.16332048)) * bufB[25] + mat4(vec4(0.18945503,0.022099635,-0.029556656,-0.08249073),vec4(-0.24025697,-0.14863414,-0.061992113,0.072823346),vec4(0.14247417,-0.11365751,0.11511176,0.14655735),vec4(0.006953176,-0.014472516,-0.14509268,-0.12088595)) * bufB[26] + mat4(vec4(0.11306555,-0.2516028,-0.12710862,-0.0042825765),vec4(-0.05848351,0.055285934,0.060706012,0.033995688),vec4(-0.19049278,0.024157954,-0.05031648,0.088124976),vec4(0.15667412,-0.021893425,-0.14449765,-0.04670968)) * bufB[27] + mat4(vec4(-0.33625594,0.03186121,-0.008026597,-0.07059912),vec4(-0.03164936,-0.07048825,-0.18576553,0.18575244),vec4(0.27296183,0.04962323,0.014320929,-0.15906224),vec4(-0.021400774,-0.14701462,0.07905491,0.039565966)) * bufB[28] + mat4(vec4(0.16143109,0.12704428,-0.00068607467,-0.15089205),vec4(-0.1844215,-0.029073607,-0.10571101,0.07473562),vec4(-0.116600744,0.081271335,0.11330746,-0.05501381),vec4(-0.16064045,0.18995197,-0.09132313,0.06801623)) * bufB[29] + mat4(vec4(0.026641319,0.029868392,0.070003696,-0.12933885),vec4(0.103891134,-0.10703244,-0.008322217,0.008817065),vec4(0.07257328,-0.003619137,-0.13464066,0.08789431),vec4(-0.017109858,-0.26525742,0.00986907,0.033242274)) * bufB[30] + mat4(vec4(-0.19496818,-0.032177795,0.07064954,-0.074700825),vec4(0.12228699,0.12341974,0.047879554,0.05319837),vec4(-0.23328151,0.08156003,-0.1648789,-0.22805804),vec4(0.03306794,0.032414578,0.05310036,0.007255043)) * bufB[31];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.06769321,0.04555448,-0.016084509,-0.09410236) + mat4(vec4(0.019410204,-0.02314456,-0.04931446,0.07998216),vec4(0.1097334,0.046945877,-0.07996728,0.17939997),vec4(-0.0032632807,-0.049412657,-0.13568021,-0.26693848),vec4(0.29658833,-0.009669306,0.20369725,-0.18330464)) * bufB[0] + mat4(vec4(-0.28890073,-0.13746455,0.08642335,-0.073433414),vec4(0.18698065,-0.08213012,-0.17691709,-0.07453875),vec4(0.028508991,-0.2908294,-0.0189773,0.21156695),vec4(0.11192709,-0.14794181,-0.11264025,-0.023099309)) * bufB[1] + mat4(vec4(0.1297415,0.11644507,-0.020909207,-0.08370885),vec4(0.3192625,0.27538916,0.040002402,-0.26644993),vec4(0.33794245,0.006147092,-0.10450444,0.09636414),vec4(0.13461863,-0.24235968,-0.178267,0.06603743)) * bufB[2] + mat4(vec4(0.1125006,-0.35699615,0.035533357,-0.41166016),vec4(0.00856739,0.09511594,0.124389485,-0.22586325),vec4(-0.17324698,-0.04765755,-0.113272585,0.0059118145),vec4(-0.14622799,-0.08759303,-0.06299926,0.11743553)) * bufB[3] + mat4(vec4(-0.025970852,-0.13869664,-0.12596028,0.01580123),vec4(-0.12530562,-0.2897936,0.048507735,0.32352114),vec4(-0.08941328,0.15454838,-0.052995883,-0.28387588),vec4(-0.23497705,-0.19351849,0.16605414,-0.13726646)) * bufB[4] + mat4(vec4(0.00953148,-0.026558248,-0.42188865,0.17591561),vec4(0.120713435,-0.011829892,-0.33094475,0.07205545),vec4(0.14038971,-0.2529366,-0.10884441,-0.048021242),vec4(-0.17818104,-0.1716864,-0.13498606,0.121030204)) * bufB[5] + mat4(vec4(0.11376218,-0.03221745,-0.03612851,-0.005141351),vec4(-0.38311046,0.19073677,0.24559242,0.28886396),vec4(0.085951604,-0.27736396,0.14904109,0.21995029),vec4(0.09011963,0.19333634,0.021162571,-0.14111161)) * bufB[6] + mat4(vec4(0.21813692,0.07384482,-0.07456834,-0.15491597),vec4(-0.10591927,0.06872126,0.14914587,0.026169356),vec4(-0.15505871,0.17615165,-0.21476011,-0.08064862),vec4(0.12810144,-0.14834349,0.05887387,0.11744219)) * bufB[7] + mat4(vec4(-0.13953355,0.08063538,-0.16395149,-0.12925082),vec4(-0.12313073,0.25663388,0.19558397,0.052206233),vec4(-0.028273562,-0.026526414,0.002456112,-0.24675553),vec4(0.13853495,0.044896618,0.16590421,0.009260901)) * bufB[8] + mat4(vec4(-0.03982579,0.13532454,-0.26790938,-0.21840318),vec4(-0.25994664,-0.18203367,0.15111928,0.025160646),vec4(0.26035246,-0.081373945,0.094255716,0.0016000808),vec4(0.0974225,0.042523623,0.027073279,0.10839409)) * bufB[9] + mat4(vec4(0.009429303,-0.16929376,-0.3352747,0.29059526),vec4(0.11819084,0.3066618,-0.11208833,-0.01885992),vec4(-0.2031235,-0.0860792,-0.097873196,0.24079514),vec4(0.041551,0.014729146,-0.15217213,-0.17437668)) * bufB[10] + mat4(vec4(-0.09210062,-0.07494733,0.13509203,0.0043904115),vec4(0.19957045,0.14937481,0.17304476,0.45124942),vec4(0.24329485,-0.15992133,0.14999968,-0.01355216),vec4(-0.08846304,-0.21756819,0.0487725,0.12783997)) * bufB[11];\nbufA[1] = vec4(-0.017990874,-0.028882429,-0.04287657,-0.043697644) + mat4(vec4(-0.2919217,-0.13301265,-0.064326726,-0.15111595),vec4(-0.27888873,-0.09826435,0.009326041,0.26050168),vec4(-0.116749264,0.16767538,-0.12297447,-0.14206974),vec4(0.20764266,-0.0748217,0.14124449,-0.16582324)) * bufB[0] + mat4(vec4(0.2789784,0.19328009,0.02378251,-0.18242201),vec4(-0.02720791,-0.052236084,-0.1902955,-0.014166102),vec4(0.12074122,0.29094672,-0.20885539,0.30309528),vec4(-0.05326788,0.17379719,0.073986895,0.26517037)) * bufB[1] + mat4(vec4(-0.16835164,-0.21727002,0.2715305,-0.09142877),vec4(-0.07830516,-0.0018945585,0.020668838,0.33915386),vec4(0.09370452,0.40008602,0.13709147,-0.00032759306),vec4(-0.37257767,0.044089254,-0.15653269,-0.30892643)) * bufB[2] + mat4(vec4(0.07229225,0.21209171,0.22933257,-0.1328815),vec4(-0.12544669,-0.17245136,-0.19993876,0.07409766),vec4(0.04002313,0.15382339,0.32108033,-0.46114603),vec4(-0.09419657,-0.014320795,-0.0602584,-0.24591815)) * bufB[3] + mat4(vec4(-0.0007635966,-0.07624405,-0.07080928,-0.04666251),vec4(-0.0144388955,0.121290654,0.047336206,0.41837105),vec4(0.018247267,0.06153509,-0.08156113,-0.17563854),vec4(-0.44392887,0.20199993,-0.12483701,-0.010309319)) * bufB[4] + mat4(vec4(0.25764766,-0.26865706,0.22818786,-0.006547572),vec4(-0.36339387,-0.14120983,0.27326652,0.09494871),vec4(0.061382778,-0.04013195,0.22854991,0.033171266),vec4(-0.07803278,0.13033949,0.05760152,-0.33986482)) * bufB[5] + mat4(vec4(0.27469152,0.18931642,0.28480205,-0.07079059),vec4(0.055861667,0.005582764,-0.25433207,0.10406535),vec4(0.04706693,0.10387835,0.037059113,0.18760157),vec4(-0.039265268,0.21512419,-0.1784985,0.4029348)) * bufB[6] + mat4(vec4(0.21574081,0.021554202,-0.012003535,0.27175263),vec4(-0.02122544,0.11033031,-0.264046,0.009541006),vec4(-0.030145405,0.023548115,0.096470356,0.02535482),vec4(0.048854776,-0.066553935,-0.02829831,-0.28974155)) * bufB[7] + mat4(vec4(-0.082537994,-0.0037907986,-0.12543897,-0.022031466),vec4(-0.027419573,-0.17595728,0.19294618,0.18224654),vec4(0.019603161,0.024408739,0.038727902,-0.022957863),vec4(-0.15959217,0.063809365,-0.37964302,-0.054344554)) * bufB[8] + mat4(vec4(0.2782948,-0.057065897,-0.29962295,-0.1209313),vec4(0.0322659,0.3171488,-0.09062179,0.17207663),vec4(-0.2998067,-0.2530498,0.02332039,-0.14998576),vec4(-0.05366879,-0.10902481,0.010221515,-0.18466564)) * bufB[9] + mat4(vec4(0.07518991,-0.14710887,0.081976414,-0.16020851),vec4(0.012058665,0.091102555,0.031530507,-0.026416346),vec4(0.036341697,-0.054465048,-0.024551002,-0.16475704),vec4(0.23243895,-0.095906064,0.14079107,0.4081496)) * bufB[10] + mat4(vec4(0.09265983,-0.08732754,0.21866643,-0.17126706),vec4(0.26824674,0.013588419,-0.10754345,0.09021153),vec4(-0.19551946,-0.2153523,0.24810803,0.18401891),vec4(0.07957885,0.13873428,-0.04490296,-0.13406993)) * bufB[11];\nbufA[2] = vec4(0.029625293,0.025425326,0.00778473,0.022897718) + mat4(vec4(-0.096403725,0.07931519,0.04103575,0.035214666),vec4(0.1368734,-0.23382145,0.12109788,0.1812066),vec4(0.28813994,0.01687571,0.37594208,0.15409327),vec4(0.16356845,0.072397366,-0.05959637,0.21173176)) * bufB[0] + mat4(vec4(-0.024956252,-0.2404088,0.046223234,-0.10377764),vec4(0.09807966,-0.074789725,-0.025606198,-0.05577066),vec4(0.005218177,0.059550416,-0.15550704,-0.26553953),vec4(0.09678296,-0.066786535,0.0053338804,-0.054847717)) * bufB[1] + mat4(vec4(0.015101913,0.15180753,-0.35128248,0.026227186),vec4(-0.22963464,0.06963178,-0.22155783,0.4009034),vec4(0.0835392,0.15010065,0.23433918,-0.23878725),vec4(0.2701081,-0.07881506,-0.116454214,-0.29056275)) * bufB[2] + mat4(vec4(-0.08963089,0.3157079,-0.20329487,0.05995142),vec4(0.095053785,-0.23536305,-0.16591325,0.06590368),vec4(0.21853226,0.24977218,0.2021521,0.42998192),vec4(0.09487686,-0.06997326,-0.06739372,0.023420364)) * bufB[3] + mat4(vec4(-0.062553726,0.22590303,0.07906015,-0.2781458),vec4(0.048961524,0.22433342,-0.26374042,-0.34520516),vec4(-0.3457022,-0.02333572,-0.0222176,-0.13097863),vec4(0.0031433008,0.10721182,0.25753516,-0.04098935)) * bufB[4] + mat4(vec4(0.015439387,-0.1033265,-0.0613824,0.15689254),vec4(-0.24036485,-0.006476437,0.111120306,0.20479056),vec4(0.0074568857,0.065598644,-0.09320863,0.052917346),vec4(0.01455664,0.08608134,-0.2004489,-0.14954838)) * bufB[5] + mat4(vec4(0.11084327,0.055923082,-0.12775116,-0.2643896),vec4(-0.16923879,0.037954845,-0.028941356,0.121818624),vec4(-0.15086488,0.117854185,0.31840816,0.06226447),vec4(-0.4234536,-0.2761551,0.02267645,-0.04265376)) * bufB[6] + mat4(vec4(0.0072185243,0.13982697,0.025676904,0.13732575),vec4(0.19080526,0.071468525,-0.27084884,-0.016341293),vec4(-0.049279355,0.045573,0.14468491,-0.077718094),vec4(0.095700026,-0.2953341,-0.05458494,-0.06120592)) * bufB[7] + mat4(vec4(0.085262865,0.24222107,0.22194055,-0.21268365),vec4(-0.01916209,0.2079997,-0.031407863,0.21049419),vec4(-0.14037526,-0.3295857,-0.055586766,0.00026297),vec4(0.001350461,-0.13928537,-0.15757395,0.027141588)) * bufB[8] + mat4(vec4(0.051557448,-0.08815601,0.24773873,0.2747005),vec4(-0.17254458,-0.31928238,0.08311401,0.15229763),vec4(0.05512096,0.14705193,0.29860845,0.17647704),vec4(0.072815545,-0.188317,-0.0034946406,0.03442814)) * bufB[9] + mat4(vec4(-0.008531893,0.0065837987,0.060319766,0.024855753),vec4(-0.10000291,0.1687885,-0.11104558,0.06796853),vec4(0.2481193,0.0037506542,0.05091883,-0.10893237),vec4(-0.037222777,-0.24889848,0.033454962,0.02018472)) * bufB[10] + mat4(vec4(0.013336343,-0.03891751,0.19535634,-0.13797365),vec4(-0.10618952,0.10064945,-0.07326489,0.07840515),vec4(0.15640247,0.15892452,0.28743148,-0.050532877),vec4(-0.21415444,-0.20660123,0.08073011,0.10662761)) * bufB[11];\nbufA[3] = vec4(-0.112686425,-0.049731385,-0.03363251,-0.0013176479) + mat4(vec4(-0.26257876,-0.122043036,-0.011247013,-0.18448205),vec4(-0.02907341,0.0013493509,0.031425636,-0.033363644),vec4(0.27406377,-0.292096,-0.13906619,0.1404142),vec4(0.27512562,0.009229463,-0.2660977,-0.042157926)) * bufB[0] + mat4(vec4(0.04636014,-0.06980492,-0.09143609,0.30330202),vec4(0.026355494,-0.5012992,-0.0013263264,-0.08485968),vec4(0.03643949,0.17185782,-0.1526723,-0.33204928),vec4(-0.24055633,0.30905533,0.008249159,-0.16199361)) * bufB[1] + mat4(vec4(-0.03733175,0.010417285,0.12694064,-0.18112653),vec4(-0.12725022,0.3096085,0.1526603,0.08671142),vec4(-0.14087439,-0.2542634,-0.33416143,-0.015649006),vec4(-0.06066969,-0.05515558,0.08780878,0.28652763)) * bufB[2] + mat4(vec4(-0.083942845,0.17553793,0.3179007,-0.0028504455),vec4(0.024855148,0.12888451,-0.049740307,0.04123264),vec4(-0.17177583,0.014806677,0.05120816,0.19005804),vec4(0.34628272,-0.020043856,-0.015241141,0.12191321)) * bufB[3] + mat4(vec4(-0.35714063,0.03055863,0.2861286,-0.028004345),vec4(0.06666078,-0.2652174,0.09776092,-0.009009644),vec4(0.18146887,0.06568561,0.018860305,-0.32328612),vec4(-0.086198546,-0.047320146,0.17241737,0.046713285)) * bufB[4] + mat4(vec4(-0.037533235,-0.13274325,-0.2082281,0.1306521),vec4(0.3718569,0.0358765,0.016402941,0.05907869),vec4(-0.26432642,-0.06635786,0.25363347,0.08325605),vec4(-0.094095744,0.24909402,0.020753667,-0.19821568)) * bufB[5] + mat4(vec4(0.1256498,0.40684223,0.12948754,-0.07797269),vec4(-0.24736181,0.15291364,0.046838872,0.13664821),vec4(0.35139126,0.073013134,-0.041972898,-0.17867583),vec4(0.034478743,0.02415748,0.04118022,0.34693092)) * bufB[6] + mat4(vec4(0.07846382,0.0852619,0.2643431,0.10078602),vec4(-0.17540735,-0.20465353,0.21262144,0.11110751),vec4(0.04771951,-0.23180832,0.038489662,-0.29846907),vec4(0.015097673,-0.11400904,-0.0745408,0.10156425)) * bufB[7] + mat4(vec4(-0.16603938,0.070835486,-0.49525332,0.19193245),vec4(-0.0059387083,0.006145159,0.12632802,-0.24856079),vec4(0.08042548,-0.21339789,0.12711033,0.05430857),vec4(0.3728552,-0.07405574,0.25768122,-0.09449643)) * bufB[8] + mat4(vec4(0.14260615,-0.15309362,0.1389153,-0.04086269),vec4(-0.08091303,-0.22168571,-0.095276944,-0.18820229),vec4(0.05820415,0.11401009,-0.10431003,0.030169627),vec4(0.0031010108,-0.09988698,-0.15907809,0.015838211)) * bufB[9] + mat4(vec4(0.1550772,-0.019868044,0.3050443,0.08400888),vec4(-0.054302912,0.009946516,0.085833356,0.07287437),vec4(0.23889935,-0.024058636,-0.08220387,0.19196537),vec4(-0.18075684,0.03439728,0.14445877,-0.01129475)) * bufB[10] + mat4(vec4(-0.038600743,0.13605769,0.07942827,0.03615642),vec4(0.0074892524,0.26081404,-0.03840575,-0.019466994),vec4(-0.06359095,0.06803994,-0.12503524,0.08627063),vec4(0.10820672,-0.17638701,0.04072384,0.038709138)) * bufB[11];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.027574603,0.057547294,0.034251034,0.07985284) + mat4(vec4(0.120557845,-0.15496126,0.17164205,-0.04784239),vec4(0.24268375,-0.15668897,0.019056022,-0.126254),vec4(-0.15402475,0.42842278,-0.12768798,-0.25739318),vec4(0.08446971,-0.032088738,0.05431795,0.13908894)) * bufB[0] + mat4(vec4(-0.3438272,0.03791995,-0.1720076,0.16620763),vec4(-0.329771,0.12025226,-0.040631175,-0.30682114),vec4(0.23107262,-0.051938344,-0.14230402,-0.27508065),vec4(-0.11149832,-0.26834887,-0.25145826,0.06225356)) * bufB[1] + mat4(vec4(0.23856974,0.08643132,0.26950368,0.08442979),vec4(-0.016529843,-0.11435715,-0.32802615,0.013881935),vec4(0.20166224,0.095194444,0.10052942,-0.41230375),vec4(0.097310014,-0.14132315,-0.059222177,0.20595628)) * bufB[2] + mat4(vec4(-0.076692894,-0.019068101,-0.23807597,-0.6054069),vec4(0.16741426,0.16284019,-0.22408974,-0.09404145),vec4(-0.20968144,-0.026540538,-0.06775996,0.27951533),vec4(-0.066491134,-0.36825788,0.12774946,0.033898667)) * bufB[3] + mat4(vec4(-0.13336448,-0.14668715,-0.10086052,0.0388802),vec4(0.11046495,0.0038096588,0.32835937,0.18806987),vec4(0.124436885,0.056173477,0.033469517,0.031091813),vec4(-0.2186167,-0.04430253,-0.31871796,-0.18060118)) * bufB[4] + mat4(vec4(-0.47595006,-0.31557775,0.20679328,0.062108375),vec4(-0.20024407,-0.17531216,-0.24923614,-0.1831774),vec4(0.027664008,-0.18547873,-0.07021963,0.17989303),vec4(-0.21424337,0.19151449,-0.033371393,-0.11041138)) * bufB[5] + mat4(vec4(-0.060404815,-0.25271025,0.0044475878,-0.14541319),vec4(0.043209203,-0.44866508,-0.22826058,-0.0135329515),vec4(0.16954874,-0.18269801,0.17263009,-0.19341646),vec4(-0.13067077,-0.1701182,-0.040685114,-0.22007269)) * bufB[6] + mat4(vec4(0.3988689,0.109508984,-0.027814772,-0.27231014),vec4(0.1654366,0.08808117,-0.11341853,-0.30786887),vec4(0.27148464,0.14253546,0.10545652,0.12658344),vec4(0.02044869,-0.33024383,0.42254654,0.3192172)) * bufB[7] + in0;\nbufA[1] = vec4(-0.0042780633,-0.038549613,-0.059415963,0.11649833) + mat4(vec4(-0.061413717,-0.096167654,-0.076638155,-0.0351876),vec4(0.15094498,-0.14243002,0.013077049,-0.110952646),vec4(0.3980348,0.6136594,-0.0415999,0.13035847),vec4(-0.08690546,-0.041035682,0.24497712,0.096579984)) * bufB[0] + mat4(vec4(0.34237504,-0.08476422,0.019066809,-0.24996454),vec4(-0.029408433,-0.23041292,-0.007163242,0.262717),vec4(0.31955096,0.07347669,0.072513714,-0.15318453),vec4(0.39638168,0.26459372,-0.038988855,0.03146525)) * bufB[1] + mat4(vec4(-0.037740055,-0.06320379,0.18559958,0.10602739),vec4(0.054380316,-0.0033011786,0.10860913,-0.022446487),vec4(0.115154564,0.057659753,-0.16680646,0.094025575),vec4(0.033985715,0.1238091,0.1520702,-0.039206643)) * bufB[2] + mat4(vec4(-0.13654785,-0.14616579,0.36837068,-0.004980384),vec4(-0.4166728,0.035932705,0.084772944,0.30493128),vec4(0.29636917,-0.110217124,0.0040035346,0.03286598),vec4(0.16518125,-0.21266322,-0.011431895,0.04922445)) * bufB[3] + mat4(vec4(-0.09759047,0.41641814,-0.305356,0.01880349),vec4(0.13146086,0.36565107,0.023112824,-0.04661755),vec4(0.029194003,-0.18959662,0.16331813,0.19203731),vec4(-0.20284529,0.03553754,0.21406688,-0.23129557)) * bufB[4] + mat4(vec4(0.27623966,0.018991366,-0.1188741,-0.016738134),vec4(0.19162326,-0.043198254,-0.06933288,0.18732536),vec4(-0.28379712,0.34010023,0.18990137,-0.5125632),vec4(-0.029243017,-0.061256167,-0.08303281,-0.15567856)) * bufB[5] + mat4(vec4(0.21417068,0.039146032,0.27884948,-0.28892022),vec4(-0.13238482,0.08666904,-0.07866592,-0.27347532),vec4(0.09332943,-0.16535297,-0.05996046,-0.012719842),vec4(-0.18989973,0.062697545,-0.15083192,0.13599181)) * bufB[6] + mat4(vec4(0.11458554,0.22305663,0.10006651,0.2519844),vec4(-0.11634232,0.30248174,0.010262993,0.11145806),vec4(0.012151545,0.08136212,-0.009974484,0.2042309),vec4(-0.37446845,0.19273905,0.20106441,-0.062316593)) * bufB[7] + in1;\nbufA[2] = vec4(-0.13765012,-0.041211404,-0.043572385,0.035264328) + mat4(vec4(0.19286688,-0.13524304,0.026128165,-0.15458992),vec4(0.025166206,0.1096082,-0.22444594,-0.04700384),vec4(0.14428005,-0.031935338,-0.11163797,-0.20972717),vec4(0.10247841,-0.01908923,-0.50822073,-0.13723496)) * bufB[0] + mat4(vec4(0.044105995,-0.19353375,-0.27016205,0.48274913),vec4(-0.05436599,0.24001716,-0.011463939,-0.37148756),vec4(0.17014992,-0.05408794,0.12278765,0.2959372),vec4(0.0869734,0.09110002,-0.07117176,0.0037264465)) * bufB[1] + mat4(vec4(-0.369537,0.08020519,-0.12351035,-0.04950298),vec4(-0.11014544,0.15058075,0.13005082,-0.0738156),vec4(-0.40539372,-0.12917331,-0.090592325,0.12334123),vec4(0.16116391,-0.25248408,-0.08801508,0.049998786)) * bufB[2] + mat4(vec4(0.0564991,0.0045854873,-0.025648681,-0.27213377),vec4(0.16394232,0.0136266565,-0.055233557,-0.01710913),vec4(0.05571861,-0.04604251,-0.33242628,0.34583774),vec4(0.11468192,-0.114893444,0.07227799,0.2115452)) * bufB[3] + mat4(vec4(0.22526723,0.33683354,-0.3333447,-0.18045741),vec4(-0.12323194,-0.27797028,0.16104543,0.04298753),vec4(-0.26511413,-0.011058374,0.13069889,0.008900923),vec4(0.4111441,-0.11166419,-0.020271301,0.02480999)) * bufB[4] + mat4(vec4(0.04877615,0.08910096,0.19645533,0.18713629),vec4(-0.09269531,-0.16152984,-0.03134278,-0.021944297),vec4(0.104285374,0.022983624,-0.08325611,0.011664695),vec4(-0.25287005,0.020785768,-0.1064212,-0.028669238)) * bufB[5] + mat4(vec4(-0.30575252,-0.052273557,0.4432594,-0.253222),vec4(0.107633345,-0.12585238,-0.05541285,-0.38173681),vec4(-0.24854408,-0.29456988,0.14935748,0.23999669),vec4(-0.14231074,0.18717082,0.009167871,-0.17251195)) * bufB[6] + mat4(vec4(0.32034844,0.26082203,-0.09102769,0.18252215),vec4(0.017151095,-0.11734672,-0.09131696,-0.21070789),vec4(0.31802538,0.080273174,0.030981721,0.173225),vec4(0.21290441,0.37803215,0.16751985,0.15646514)) * bufB[7] + in2;\nbufA[3] = vec4(-0.05296801,-0.050781403,-0.10709663,0.051837754) + mat4(vec4(0.03489369,0.23157087,0.24408801,-0.18060173),vec4(0.19870184,-0.08138828,-0.0973784,0.4129442),vec4(-0.19330366,-0.11443972,-0.22907801,-0.0672779),vec4(0.29431573,0.0760258,-0.023398198,0.3084032)) * bufB[0] + mat4(vec4(-0.29732832,-0.21275285,-0.115311846,-0.23945104),vec4(0.0453187,0.15775004,0.071428336,-0.049867474),vec4(-0.09994444,-0.18439123,0.05347085,0.026645884),vec4(-0.16548829,0.4064549,-0.103691146,0.052460063)) * bufB[1] + mat4(vec4(-0.018533597,-0.07645561,-0.072749585,0.12444671),vec4(0.0872531,0.117787585,0.2356843,-0.30864325),vec4(0.13454387,-0.24103615,-0.099157915,0.055601485),vec4(-0.27947423,-0.17562898,0.06879409,-0.18578564)) * bufB[2] + mat4(vec4(-0.048618197,0.18302484,0.0968681,0.17255262),vec4(0.094453245,-0.18081129,-0.06266592,0.06008873),vec4(0.14486003,0.17024611,0.22998038,0.28721234),vec4(0.43118864,0.2347019,-0.08538042,-0.13952579)) * bufB[3] + mat4(vec4(0.00122241,-0.07423036,-0.022106651,-0.03792851),vec4(0.081401534,-0.41829327,-0.2751647,0.2033748),vec4(-0.41150853,0.21310931,-0.0020555933,-0.35060012),vec4(0.08796119,-0.21882597,-0.28425616,-0.24398586)) * bufB[4] + mat4(vec4(0.31457996,-0.054438565,0.2846599,-0.07958078),vec4(-0.41606474,0.047399253,-0.2298865,-0.11266802),vec4(0.054759514,0.24505097,-0.15362933,0.010331793),vec4(0.15515521,0.1819936,-0.08639274,-0.10933472)) * bufB[5] + mat4(vec4(-0.052048814,0.31388435,0.3241708,-0.27124098),vec4(-0.05023088,0.030168362,-0.13650282,0.12881313),vec4(0.31736913,-0.00857205,0.056402083,-0.050586957),vec4(0.2641879,-0.13481402,-0.061070874,-0.4528798)) * bufB[6] + mat4(vec4(0.023783252,0.19689894,0.065851286,0.14256129),vec4(0.063927226,0.34189564,-0.2985093,0.06503236),vec4(-0.44013575,-0.0004973813,0.5419669,0.29235843),vec4(-0.29244074,0.15771702,0.09940247,0.032900654)) * bufB[7] + in3;\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.049934298,-0.037952848,-0.040651653,-0.024434566) + mat4(vec4(-0.15336514,-0.16389078,-0.08529802,-0.016809493),vec4(-0.18207178,-0.03706043,0.12684624,0.17090012),vec4(-0.07489555,-0.31514025,-0.29738408,0.20714855),vec4(0.05424719,-0.14070857,0.16205432,0.018488066)) * bufB[0] + mat4(vec4(-0.02937417,-0.32614753,0.12728961,0.031987835),vec4(0.22526498,0.08901456,-0.0024004302,-0.23501015),vec4(-0.27501836,-0.3077296,0.53023416,0.35859454),vec4(-0.20514935,0.17559609,-0.44343197,0.19133061)) * bufB[1] + mat4(vec4(0.21072312,0.18030019,-0.011838276,0.267343),vec4(0.2662896,0.1891304,-0.04876678,-0.1779402),vec4(-0.08966184,0.27102044,0.09981558,-0.1959605),vec4(0.099822275,-0.20085807,0.0998945,0.030627044)) * bufB[2] + mat4(vec4(-0.10125832,0.12745361,-0.01365777,-0.25165823),vec4(0.0081671,0.32125425,-0.020791966,0.15082285),vec4(0.093511544,-0.08286684,-0.00029488024,0.10712239),vec4(0.10843773,0.42633134,-0.22819239,0.012852014)) * bufB[3] + mat4(vec4(0.00595758,0.2877439,0.15114371,0.20579015),vec4(-0.24630293,0.22842832,0.18191092,0.009548075),vec4(-0.23719198,-0.017726757,0.0987444,0.48806712),vec4(-0.46771955,-0.078735635,0.123292655,-0.07543896)) * bufB[4] + mat4(vec4(0.40662262,-0.13089308,-0.22399175,0.08026816),vec4(0.1987055,0.18181407,0.053146794,-0.069538966),vec4(0.038846996,-0.22380127,0.31040016,0.05254699),vec4(0.06897451,0.09625374,0.23822418,-0.049552348)) * bufB[5] + mat4(vec4(-0.16341661,0.06366518,-0.16757123,0.17964385),vec4(0.20331375,-0.12043058,-0.023873208,-0.067342505),vec4(0.15858749,0.07015251,-0.22745708,0.27028167),vec4(-0.022261739,-0.1700685,0.12253448,-0.15694685)) * bufB[6] + mat4(vec4(-0.24267478,0.16334398,0.06331323,0.2939909),vec4(-0.02707888,0.026308028,0.047349222,-0.52206796),vec4(-0.111906834,-0.21018934,-0.29338196,-0.036969725),vec4(0.42438293,0.23504975,-0.22781727,0.12901233)) * bufB[7];\nbufA[1] = vec4(0.0036119074,-0.006172163,0.12358337,-0.060681634) + mat4(vec4(-0.18502447,-0.16787499,0.18074016,0.056391805),vec4(0.277378,-0.20167856,-0.17201303,0.3281222),vec4(-0.16195047,-0.29780853,0.12595665,0.33317807),vec4(0.017640451,0.09077398,-0.025645072,0.21130882)) * bufB[0] + mat4(vec4(0.16886634,0.037889246,-0.037679024,-0.20418528),vec4(-0.034161866,0.35876763,-0.30844668,0.22826605),vec4(0.12392933,0.22224405,-0.15481628,0.22323212),vec4(0.06966975,0.16755104,-0.07733593,-0.030001596)) * bufB[1] + mat4(vec4(-0.13943362,-0.22588561,-0.07082024,0.39733952),vec4(0.02508139,-0.45302492,0.06458632,-0.03817348),vec4(-0.003050106,-0.23720098,-0.25832143,0.100070074),vec4(0.3896112,-0.26660448,0.0050734486,0.02623584)) * bufB[2] + mat4(vec4(0.04924153,0.037633616,0.2692719,-0.2832078),vec4(-0.042303506,0.13575123,0.24698769,-0.052335914),vec4(-0.26483995,0.20045854,-0.030767651,0.14498027),vec4(0.33335692,0.4374497,0.0010398218,0.118979864)) * bufB[3] + mat4(vec4(-0.008872869,-0.34152168,-0.10152434,-0.29057923),vec4(-0.1628259,0.21253252,-0.08706478,0.21243086),vec4(-0.14495172,-0.070897505,-0.37060037,0.05132659),vec4(0.26858073,0.1039999,0.08001497,-0.119883575)) * bufB[4] + mat4(vec4(0.074907266,-0.22277372,-0.67247254,-0.12971053),vec4(0.13732417,-0.123624004,0.18977383,0.21625212),vec4(0.006776139,0.22049819,-0.15203142,0.28709325),vec4(-0.18386863,0.07866433,-0.008973188,-0.1898435)) * bufB[5] + mat4(vec4(0.051479187,-0.33334312,-0.34375876,0.1422885),vec4(-0.11276934,-0.22004989,0.056841996,0.16678977),vec4(0.021887263,0.26489666,0.041776255,0.13294545),vec4(-0.18388781,-0.27879196,0.09160501,0.1338148)) * bufB[6] + mat4(vec4(0.14957187,0.1040843,0.15685591,0.056754485),vec4(-0.12756881,0.30668533,-0.28844166,-0.3619307),vec4(0.17336477,0.36606532,0.11862276,0.096585155),vec4(0.049265955,-0.4411267,-0.009279562,0.008202361)) * bufB[7];\nbufA[2] = vec4(0.069337524,0.017736042,-0.09325608,-0.0016209302) + mat4(vec4(0.028910814,0.11477614,0.11524461,0.20864661),vec4(0.10968078,0.21961853,-0.19669148,-0.14053945),vec4(0.2563501,-0.22957973,-0.041379694,-0.2768244),vec4(0.06906355,-0.24767809,-0.5335628,-0.3418408)) * bufB[0] + mat4(vec4(-0.052778557,-0.0663672,-0.28049594,0.05113284),vec4(-0.15392673,0.18220988,0.026544688,-0.15192932),vec4(0.22301254,0.14882837,-0.1585417,0.11303769),vec4(0.38009635,0.03758628,0.27415738,0.48043996)) * bufB[1] + mat4(vec4(0.0415019,-0.26755354,0.055180196,-0.12796317),vec4(-0.0962846,-0.21439038,0.020738224,-0.08716052),vec4(0.26784113,-0.10983661,0.36715397,-0.0146908425),vec4(0.2389211,-0.19756086,0.054582834,-0.057499357)) * bufB[2] + mat4(vec4(-0.15768564,-0.10071644,0.14040808,0.14374088),vec4(-0.07611261,0.16831352,0.09900081,0.19679885),vec4(0.056243837,-0.31125447,-0.0017908242,0.06966152),vec4(0.1524315,-0.055671945,0.13588294,-0.05644733)) * bufB[3] + mat4(vec4(0.122623354,0.17836353,0.25730833,0.075934045),vec4(0.09728637,0.084932216,-0.039509814,-0.19462074),vec4(0.52856296,0.07419923,-0.25028017,-0.030769844),vec4(-0.020726759,-0.17464666,0.13542257,0.1494787)) * bufB[4] + mat4(vec4(-0.05547106,-0.15686893,-0.06530931,-0.25168297),vec4(-0.20519894,-0.2718188,0.25867262,-0.18885365),vec4(0.14532399,-0.019350914,-0.2012876,-0.0034075691),vec4(-0.04800251,-0.17038497,-0.31025282,0.13833126)) * bufB[5] + mat4(vec4(-0.20102026,0.1765321,-0.023999829,0.06293463),vec4(0.45127377,0.42386696,0.11918664,0.17706716),vec4(0.065423176,0.045656614,-0.2315844,0.05096715),vec4(-0.031058745,0.14427376,-0.07409829,0.080405176)) * bufB[6] + mat4(vec4(-0.14989424,-0.10206942,0.2657445,-0.12531221),vec4(-0.062252246,-0.18126798,0.07869556,-0.053343028),vec4(0.0019801587,0.23903833,0.122239076,0.059165023),vec4(0.103624016,0.14645217,0.12846795,-0.040232446)) * bufB[7];\nbufA[3] = vec4(-0.015231454,0.0789862,-0.013775984,0.05697838) + mat4(vec4(0.027323669,-0.12424361,-0.12484207,-0.09582115),vec4(0.113849446,0.026696125,-0.39725056,-0.048339445),vec4(0.3491863,0.24764013,-0.13395286,0.1877074),vec4(-0.023756996,0.061744593,-0.12064723,0.4598982)) * bufB[0] + mat4(vec4(0.31362125,-0.24487081,-0.07428262,0.046347864),vec4(0.15145612,0.15324464,-0.14009391,0.16937724),vec4(-0.38456365,-0.34376234,0.107338354,0.08404853),vec4(0.056827497,0.005066981,-0.05862731,0.33069643)) * bufB[1] + mat4(vec4(-0.11668658,-0.33337414,0.32240644,-0.20269293),vec4(0.032154795,-0.13489032,-0.09040184,0.2347411),vec4(0.18515344,-0.1405427,-0.18646611,0.044684663),vec4(0.15126422,-0.12851161,-0.014706673,0.20410179)) * bufB[2] + mat4(vec4(0.1862758,0.16393922,0.25523832,0.34135172),vec4(-0.43272308,-0.06835256,-0.36128485,-0.10834407),vec4(-0.11391301,-0.21298863,-0.16842452,-0.0010077511),vec4(-0.16761573,-0.030539377,-0.06385622,0.4532627)) * bufB[3] + mat4(vec4(-0.34789327,-0.11589374,0.05017751,-0.05554635),vec4(0.17366914,0.054005492,0.3210117,0.011966791),vec4(0.15363275,0.13092266,0.19070792,0.101196505),vec4(0.41067442,-0.38683826,-0.15576175,-0.16476287)) * bufB[4] + mat4(vec4(0.035009395,-0.035123218,-0.28201392,0.5489721),vec4(-0.13636036,0.009159357,-0.1143205,-0.0468341),vec4(-0.025709629,-0.17773893,-0.21851695,-0.14880964),vec4(-0.22885408,0.12592663,-0.2972787,-0.2501563)) * bufB[5] + mat4(vec4(-0.3541946,-0.14625625,-0.14668876,0.30006236),vec4(-0.031957287,0.2322868,-0.2885915,-0.07655508),vec4(0.56694025,-0.061025526,0.26998606,0.11196037),vec4(0.100298576,-0.00466066,-0.10914842,0.093337215)) * bufB[6] + mat4(vec4(0.028620554,-0.41942042,-0.07904964,-0.34491155),vec4(0.28053746,-0.11043848,0.1588362,-0.19909146),vec4(0.17948301,0.092193805,-0.120130554,-0.006750173),vec4(-0.18413553,-0.3182824,-0.06031717,-0.09577962)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.038118795,0.02430001,0.04183509,0.08609029) + mat4(vec4(0.21708915,0.1473316,0.17622347,0.21889235),vec4(0.021014411,-0.0042686244,-0.17403272,0.23684147),vec4(0.12082083,-0.21381918,0.29005426,0.13250771),vec4(0.1182419,0.48014548,-0.14995934,0.07717702)) * bufB[0] + mat4(vec4(-0.031051606,0.15002409,0.119592436,0.1346307),vec4(0.15994082,-0.29714444,-0.10665684,-0.23135604),vec4(-0.1747925,-0.37463796,-0.28106728,0.09998887),vec4(-0.2714148,0.22160493,-0.1827385,-0.21936864)) * bufB[1] + mat4(vec4(0.23479226,0.068501964,-0.00663496,0.104667686),vec4(-0.14252518,0.10154688,-0.18013442,0.20918015),vec4(0.4578706,0.2364244,-0.12854557,-0.1809493),vec4(-0.22760347,-0.26776677,0.24982156,0.24095811)) * bufB[2] + mat4(vec4(0.18551196,0.19572012,-0.039857842,0.18002833),vec4(0.061877366,-0.10873334,0.04845827,-0.11192393),vec4(0.11547266,0.21455064,-0.44021696,-0.38114706),vec4(-0.2866575,0.24242012,-0.4173503,-0.048558094)) * bufB[3] + mat4(vec4(-0.24303435,0.29656446,0.018461453,0.022915918),vec4(-0.014736233,-0.25512114,-0.06867819,-0.116288215),vec4(0.0044039325,-0.054563876,0.0044004573,0.0019890293),vec4(-0.018700566,-0.5151411,-0.17048754,-0.1088815)) * bufB[4] + mat4(vec4(-0.23291814,0.25856793,0.12519713,-0.0014990781),vec4(-0.15793234,-0.13113086,-0.08632251,0.16645914),vec4(-0.122906074,0.10538196,0.19554825,-0.15580618),vec4(0.27730235,0.34456697,0.23550907,0.14531662)) * bufB[5] + mat4(vec4(0.20380093,0.07618578,-0.012344529,-0.18769316),vec4(-0.265706,0.133998,0.28002498,0.04274696),vec4(0.01916627,0.0017099336,-0.034602918,0.026334144),vec4(-0.31474087,0.10386056,0.025421282,0.31730977)) * bufB[6] + mat4(vec4(0.14064534,0.32221162,0.18082844,-0.47954577),vec4(0.38270122,-0.09114245,0.027675148,-0.1513467),vec4(0.094318815,-0.20463005,0.52309173,-0.30138913),vec4(0.08956877,-0.07334525,0.1342298,-0.16806494)) * bufB[7];\nbufA[1] = vec4(-0.017408026,0.19102159,-0.04087589,0.053100403) + mat4(vec4(-0.10789756,-0.14267918,0.18324381,0.39013323),vec4(0.18794696,0.13823447,0.19199187,-0.26076055),vec4(-0.1997785,0.03243356,0.09521224,-0.021155776),vec4(-0.12692893,0.3239783,0.110560305,0.3640746)) * bufB[0] + mat4(vec4(-0.27898836,0.054843105,-0.06220807,0.07463293),vec4(0.060170818,-0.011488801,-0.30115923,-0.10677238),vec4(-0.26522428,0.36417177,-0.05654458,-0.029350078),vec4(-0.2502884,-0.21866523,-0.07427058,-0.0003164257)) * bufB[1] + mat4(vec4(-0.4454805,0.060650498,-0.1773837,0.2902209),vec4(0.27821085,0.103541486,0.15637359,0.01491871),vec4(0.022710131,0.1270187,0.23375307,-0.022916263),vec4(-0.24004082,-0.0127528,-0.07275079,0.12521246)) * bufB[2] + mat4(vec4(0.29933932,0.11926987,-0.58173144,0.010649095),vec4(0.22154091,-0.06738369,-0.20345137,-0.08366547),vec4(-0.34924978,-0.04213246,0.27281883,0.00097061123),vec4(-0.059580766,0.15885308,0.03260232,-0.08935448)) * bufB[3] + mat4(vec4(-0.019327708,0.13166161,0.25400034,0.08964408),vec4(0.3837582,-0.40585947,0.35260135,-0.2364376),vec4(-0.21501248,-0.40485212,-0.25291556,-0.31590316),vec4(-0.10746688,0.62694776,0.20324922,-0.11257204)) * bufB[4] + mat4(vec4(-0.101761475,0.026586317,-0.13762191,0.30636486),vec4(-0.014768378,-0.032699935,0.022575146,0.21479012),vec4(-0.15961632,0.029071042,0.30016765,0.08467493),vec4(0.017790925,-0.042181678,0.13964514,-0.24683198)) * bufB[5] + mat4(vec4(-0.04545021,-0.20402691,-0.2658807,0.38270506),vec4(0.16782017,-0.030704133,0.09716176,-0.07857725),vec4(0.14579633,0.16206492,0.0015394654,-0.20718859),vec4(-0.11555571,0.008751145,-0.4377345,-0.17175053)) * bufB[6] + mat4(vec4(0.16068594,-0.10667073,-0.20156786,0.004708405),vec4(-0.3612511,-0.47502357,-0.3190023,0.14624211),vec4(-0.13436554,-0.31531048,-0.19090633,0.09088477),vec4(-0.030413046,-0.10866716,0.10292848,-0.25354)) * bufB[7];\nbufA[2] = vec4(0.067246504,-0.0039205146,0.03289775,-0.049752314) + mat4(vec4(0.63415843,-0.06740752,-0.06515131,0.21724395),vec4(0.078772984,-0.14877911,-0.55398357,-0.16528027),vec4(-0.48972845,0.38865298,0.07365621,0.16471091),vec4(-0.16539162,-0.014019803,0.014843559,0.073699735)) * bufB[0] + mat4(vec4(-0.08006514,-0.38053018,0.15273286,0.35548723),vec4(-0.04467902,-0.026063645,-0.054749135,0.026078008),vec4(-0.03826126,0.25458667,-0.16239773,0.28997156),vec4(0.042236596,0.15486854,0.1591179,0.010341674)) * bufB[1] + mat4(vec4(0.15948309,0.2986207,0.31023872,0.37250614),vec4(0.09424838,0.0880497,-0.044233475,-0.17775954),vec4(0.10440532,-0.042408463,-0.25166813,0.26918095),vec4(-0.11005989,-0.07310659,0.086415745,-0.11539745)) * bufB[2] + mat4(vec4(-0.17122935,0.010425843,-0.019455511,-0.24537209),vec4(0.16845348,-0.3012269,0.4002959,-0.14917727),vec4(0.316956,0.039256543,-0.08079198,0.069850355),vec4(-0.1713605,-0.26931402,0.3150823,0.19267602)) * bufB[3] + mat4(vec4(0.20651838,-0.35258484,-0.35799387,-0.038470168),vec4(-0.27784154,-0.1418198,0.22708406,-0.22540537),vec4(-0.10190092,0.5801356,-0.015506015,-0.31615293),vec4(-0.1543267,0.0074472544,0.04380187,-0.077297084)) * bufB[4] + mat4(vec4(0.11302338,0.29322526,0.002531075,-0.24199018),vec4(-0.028214203,-0.20052554,-0.13864426,0.17205386),vec4(-0.50549316,0.2117255,-0.25320294,-0.08489791),vec4(-0.122194916,-0.104406334,-0.2110241,0.239724)) * bufB[5] + mat4(vec4(-0.2444617,0.033089254,0.10137647,-0.08968276),vec4(0.035555154,-0.19768271,0.38259608,0.1978487),vec4(-0.36190546,-0.04896943,-0.14045157,-0.10463358),vec4(0.011405287,-0.15916064,0.18570729,-0.10164357)) * bufB[6] + mat4(vec4(0.25152355,0.35227814,0.434889,0.07748467),vec4(-0.21773233,0.011068056,0.061246663,0.23180497),vec4(0.6271409,-0.26283213,0.012713463,0.6705281),vec4(-0.095200576,0.6048891,-0.07493896,-0.116092175)) * bufB[7];\nbufA[3] = vec4(-0.00886213,-0.064900726,-0.048324782,-0.0066939835) + mat4(vec4(0.34498402,-0.13479295,0.41927692,0.19171348),vec4(0.27518812,0.5337371,-0.18013893,-0.11460351),vec4(-0.1795156,0.31065512,0.2812593,-0.032361005),vec4(-0.06964406,0.10232171,0.1859168,0.07198622)) * bufB[0] + mat4(vec4(0.25142187,0.25734526,0.023569895,0.13395445),vec4(-0.13967319,-0.059411865,0.19620217,-0.16571279),vec4(0.015116805,-0.0025642489,-0.08410096,-0.51320916),vec4(0.461239,0.41339567,0.15569887,-0.13983688)) * bufB[1] + mat4(vec4(-0.13662362,0.13241547,-0.07184836,0.20215413),vec4(0.046928752,-0.13218571,0.021165261,-0.07097132),vec4(0.39850813,-0.107199214,0.2222806,-0.0770592),vec4(-0.1513634,0.2724626,-0.12513706,0.11368163)) * bufB[2] + mat4(vec4(-0.2877315,-0.26233575,0.007892861,-0.12826063),vec4(0.20212759,-0.39626282,-0.51133645,-0.0066680354),vec4(-0.102501474,-0.014827375,-0.047148976,0.03338679),vec4(0.46547544,-0.057162944,-0.024002628,-0.6112334)) * bufB[3] + mat4(vec4(0.21821284,0.1532215,0.04949893,-0.22153375),vec4(-0.1522374,-0.014507289,0.19644639,0.103768505),vec4(-0.40997502,0.096998714,-0.024574041,-0.35028154),vec4(-0.118210025,0.032354712,-0.020492427,-0.050278936)) * bufB[4] + mat4(vec4(0.04371411,-0.19235179,-0.19026755,-0.02326834),vec4(0.0028526087,-0.16525953,0.19433823,0.42775247),vec4(0.2086738,0.3536641,0.32019407,0.15098731),vec4(-0.16066098,-0.026725153,-0.12335005,0.11701615)) * bufB[5] + mat4(vec4(0.2140134,-0.0022334303,0.27307117,0.09422618),vec4(0.06929379,-0.06617008,0.072971016,0.4435076),vec4(-0.09441598,-0.29464513,0.06450295,-0.15865971),vec4(0.14090092,-0.062120795,0.20375142,-0.07462755)) * bufB[6] + mat4(vec4(-0.044630606,-0.6010422,-0.024422253,-0.28699523),vec4(0.3755385,0.012235064,-0.10151258,-0.05682495),vec4(-0.36234835,0.2755552,0.11501763,0.25040784),vec4(-0.21945104,-0.0221516,-0.31940636,0.08457831)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.054172963,-0.13180768,0.037089337,-0.075898245) + mat4(vec4(0.1917158,0.093396865,-0.115854144,0.14674237),vec4(0.11448008,0.00082922634,0.042860698,0.024726473),vec4(0.07607114,-0.4021969,0.18310528,0.038054686),vec4(-0.23216377,0.10464455,0.298471,-0.15910043)) * bufB[0] + mat4(vec4(-0.006018113,0.10220143,-0.005245638,0.180312),vec4(-0.07429465,-0.045714792,-0.18394734,-0.53957087),vec4(-0.28485662,-0.79973006,0.13962108,0.11271518),vec4(-0.05679622,-0.26708633,0.12747583,0.07927418)) * bufB[1] + mat4(vec4(0.46819898,0.16432397,0.051241126,-0.18843308),vec4(0.17855456,0.23084126,-0.1694347,0.23265557),vec4(-0.08942992,0.1422846,-0.20940891,0.49853033),vec4(-0.05698436,-0.16126382,-0.35026658,0.14865305)) * bufB[2] + mat4(vec4(-0.000875254,-0.1700821,0.33183402,-0.29088807),vec4(-0.45842576,-0.24159248,0.2674128,0.025954355),vec4(-0.2014145,0.31262675,0.028777506,-0.05171993),vec4(-0.08540758,-0.18085173,0.15470305,-0.12764749)) * bufB[3] + mat4(vec4(-0.117004685,0.043129724,-0.49583286,0.089376844),vec4(0.23200575,0.008282543,0.2464215,0.21043143),vec4(0.15053047,0.34004226,-0.10893084,-0.21945435),vec4(0.2557994,0.33008838,-0.11016672,-0.0009624634)) * bufB[4] + mat4(vec4(-0.22641924,0.34105465,-0.17545298,0.18686302),vec4(0.21040969,0.23062348,-0.05575124,0.09742794),vec4(0.064852245,0.18050545,0.11408253,0.26309717),vec4(-0.4053009,-0.42782554,0.23868893,-0.14554513)) * bufB[5] + mat4(vec4(0.09521665,0.22790495,0.113356814,0.19841985),vec4(-0.1411702,-0.22011575,0.11021097,-0.3858919),vec4(-0.38064268,0.16891514,-0.27080944,-0.05151359),vec4(-0.09607713,-0.13014664,-0.223865,-0.0930838)) * bufB[6] + mat4(vec4(-0.08173186,0.009810713,0.42674708,-0.35050353),vec4(0.0913546,0.1680379,-0.17733784,0.08849819),vec4(-0.10314821,0.38151932,0.13421799,0.123299725),vec4(0.109580934,-0.09532332,-0.4098288,-0.14061432)) * bufB[7];\nbufA[1] = vec4(-0.036025316,0.043657765,-0.11512244,0.0117511125) + mat4(vec4(-0.0060629924,0.0628504,-0.0320409,-0.12917934),vec4(0.20425114,0.070116065,0.16154961,0.43989488),vec4(-0.24157469,-0.2063758,-0.12235699,0.21862002),vec4(-0.15028194,0.09470488,-0.17637312,-0.011748038)) * bufB[0] + mat4(vec4(-0.1762261,0.07261402,-0.17900817,-0.06615863),vec4(-0.21845317,0.3271815,-0.33205202,0.275927),vec4(0.2072892,-0.089625716,-0.19478709,0.36799693),vec4(0.051692415,-0.11710544,0.22493264,-0.37363085)) * bufB[1] + mat4(vec4(-0.3389396,-0.24357136,0.43605813,-0.017556785),vec4(0.6917401,-0.19456443,0.09285297,0.046591245),vec4(-0.21985923,-0.5410343,0.011474367,0.05341537),vec4(-0.07470886,0.013864663,-0.1157914,-0.3662077)) * bufB[2] + mat4(vec4(0.38371912,0.007352819,-0.37972382,-0.17760661),vec4(0.115333244,0.26071194,-0.013018851,0.14123084),vec4(0.20888881,-0.13971628,-0.031762328,0.1732383),vec4(-0.14400804,0.20343664,-0.23480414,0.37440687)) * bufB[3] + mat4(vec4(0.1337171,0.13521098,0.12679577,-0.06479968),vec4(-0.28843698,-0.23521781,0.28599718,0.25756714),vec4(0.31309077,0.01690751,0.20716807,-0.29253307),vec4(0.23480156,0.15056562,0.2436397,-0.070230074)) * bufB[4] + mat4(vec4(-0.14914206,0.21160893,0.19191049,-0.2224785),vec4(0.03436206,-0.0299771,0.2724348,0.038962297),vec4(-0.41322422,-0.03860639,0.1906185,0.106265366),vec4(0.027786456,0.21607375,0.101040855,0.28141537)) * bufB[5] + mat4(vec4(-0.23108925,-0.22014071,0.08716948,0.095286325),vec4(0.31924015,-0.06368316,-0.18552807,0.11297166),vec4(0.17155837,0.028615234,0.05743727,0.37152073),vec4(0.18238412,-0.044102218,-0.016843194,-0.34021932)) * bufB[6] + mat4(vec4(-0.17051043,0.037566435,0.18242341,0.37376124),vec4(-0.026918797,-0.002218556,0.0042589963,-0.0010416387),vec4(0.08518216,-0.3462021,-0.23335569,-0.098386094),vec4(0.07198513,0.005370286,0.29487187,-0.26213828)) * bufB[7];\nbufA[2] = vec4(0.032147452,0.08476319,0.054760613,0.11267975) + mat4(vec4(-0.0020659787,0.06965377,-0.40213904,-0.46569344),vec4(-0.004397735,-0.15717997,0.0026181748,0.1252578),vec4(0.508873,-0.047173534,-0.062002063,-0.24048045),vec4(0.30441245,0.52177656,-0.14711808,0.19910075)) * bufB[0] + mat4(vec4(0.16240606,-0.23650259,0.11500867,0.15444289),vec4(0.14012776,0.33635655,0.069585524,-0.13560474),vec4(-0.36468256,-0.20054768,0.023062613,-0.1908867),vec4(0.09343451,0.04631219,0.10114437,0.1806391)) * bufB[1] + mat4(vec4(0.2678051,-0.052577402,-0.27955496,0.091433674),vec4(-0.0016408648,0.2287555,0.030401912,0.11049865),vec4(-0.114179455,0.4744171,0.22372267,-0.032901578),vec4(-0.15004657,0.10970804,0.18972488,-0.21474478)) * bufB[2] + mat4(vec4(0.445304,-0.1643777,0.037419654,0.061373413),vec4(0.048244074,-0.15143341,-0.36908647,-0.052191705),vec4(-0.1996691,-0.1524997,0.22119363,-0.04703976),vec4(0.36467254,0.17836328,-0.06814333,-0.04744664)) * bufB[3] + mat4(vec4(0.013587208,0.17956553,-0.32270506,-0.21389125),vec4(-0.11340837,-0.45158425,0.5623003,0.104348056),vec4(0.34211978,-0.26412016,-0.16492741,-0.09616217),vec4(0.06112045,0.49537972,0.18565623,-0.22461534)) * bufB[4] + mat4(vec4(0.01867504,-0.48307157,0.13138646,-0.11832307),vec4(0.12124698,-0.2666298,0.46386123,-0.2665105),vec4(-0.22596481,0.21339415,-0.13902842,0.15040804),vec4(0.15595493,-0.05672539,-0.13191563,0.22418414)) * bufB[5] + mat4(vec4(0.15059868,-0.0853827,-0.047613245,0.02574853),vec4(-0.08181986,0.22810477,0.09840127,-0.0066110296),vec4(-0.26031378,-0.18715626,0.045741063,-0.019575914),vec4(0.092018925,-0.37528747,0.20374829,-0.031072397)) * bufB[6] + mat4(vec4(-0.11536147,0.266249,-0.27580708,0.16067336),vec4(-0.069645904,-0.040447615,-0.10616833,0.19585672),vec4(-0.13628653,0.1758487,-0.07131761,-0.27721295),vec4(0.21627788,0.13642676,0.298671,0.27141953)) * bufB[7];\nbufA[3] = vec4(0.016732132,-0.005056173,0.23500523,0.14827657) + mat4(vec4(0.18229648,-0.12894554,0.2752071,0.119297266),vec4(-0.38352975,0.29369017,-0.050966244,-0.22519918),vec4(0.15879597,0.04607486,-0.13806143,0.18096828),vec4(0.13159415,-0.012542169,-0.088686034,-0.12240905)) * bufB[0] + mat4(vec4(0.24823615,0.07896642,0.183998,-0.31142038),vec4(-0.13843869,-0.026213026,-0.07156599,0.038774785),vec4(0.024064701,-0.11422374,-0.21654703,-0.5401731),vec4(-0.05690305,0.2808002,0.21811764,0.1201489)) * bufB[1] + mat4(vec4(-0.009518689,0.11799261,0.23036948,-0.02422999),vec4(-0.31360698,0.14981873,-0.26246634,-0.23057285),vec4(0.031446785,0.048677113,-0.08924765,0.3076625),vec4(-0.013785071,0.07826209,0.2494896,-0.09941341)) * bufB[2] + mat4(vec4(-0.5073556,-0.12220867,-0.06210687,-0.13971578),vec4(-0.09673431,-0.16581851,-0.548159,-0.071718454),vec4(-0.110940956,-0.2486094,0.29569831,-0.069115385),vec4(0.060223848,-0.18210575,-0.1075014,-0.46776932)) * bufB[3] + mat4(vec4(-0.068108596,-0.23126191,-0.08101168,0.19461639),vec4(-0.14149146,-0.13083526,0.097440965,0.045422062),vec4(-0.1034446,0.11104031,-0.22368462,-0.14770725),vec4(0.14547497,0.20831703,-0.62753606,-0.09797028)) * bufB[4] + mat4(vec4(0.1770714,-0.017870506,0.19088972,-0.3709298),vec4(0.16079201,-0.08388943,-0.07779869,-0.2893383),vec4(0.49861383,0.0034350837,0.2037035,-0.19965333),vec4(0.26830196,-0.02379027,-0.16868879,0.045200173)) * bufB[5] + mat4(vec4(-0.45648593,0.1814146,0.009706705,0.05008894),vec4(-0.021101044,0.1893686,0.009548464,-0.07828054),vec4(0.08032667,-0.24800824,-0.3091467,-0.06468115),vec4(-0.34749323,0.15325479,-0.25976413,0.24853708)) * bufB[6] + mat4(vec4(0.34019312,-0.16898558,-0.13928175,-0.009629051),vec4(0.39932725,0.36101866,0.061155047,0.23891822),vec4(-0.15656912,-0.04158126,-0.121879585,-0.19160801),vec4(-0.1895124,0.028336667,-0.13379082,0.3308133)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.036756314,0.20774716,0.24753915,0.027942285) + mat4(vec4(-0.015229305,-0.02903422,-0.22201225,0.39836535),vec4(0.20958677,0.37816572,-0.015337241,0.20850459),vec4(-0.32982385,-0.080582246,0.0567803,-0.21409574),vec4(0.8022821,-0.14531387,-0.45605683,0.032471552)) * bufB[0] + mat4(vec4(0.13416426,0.19029577,-0.26268047,-0.2646597),vec4(-0.2842382,0.13195495,0.14457309,0.32319748),vec4(-0.09002824,0.121869996,0.14727114,0.087861806),vec4(-0.07759329,0.11366991,-0.06990413,0.05641107)) * bufB[1] + mat4(vec4(0.14874361,0.15181804,0.025143426,-0.117714874),vec4(-0.023704838,-0.00055354746,-0.24096161,0.28451988),vec4(0.4548604,0.053565998,0.5764727,-0.0012647721),vec4(-0.1332374,-0.43923387,-0.17877416,0.045617063)) * bufB[2] + mat4(vec4(-0.02068838,-0.4625029,0.2578971,0.009260977),vec4(0.23422466,0.102474876,-0.07541919,0.13814037),vec4(-0.0568657,-0.099517904,-0.5899896,0.26966146),vec4(-0.14521834,-0.36573583,-0.08317962,0.05980874)) * bufB[3] + mat4(vec4(0.16649811,-0.20969377,-0.5165304,0.25473577),vec4(0.4341348,0.043259054,-0.07556746,-0.01192529),vec4(-0.09578775,0.117904715,0.46338314,-0.2495272),vec4(-0.008646729,-0.22457948,0.5789809,0.3406956)) * bufB[4] + mat4(vec4(-0.37961712,-0.026681669,-0.08929787,-0.19961981),vec4(0.043673195,-0.46644875,-0.08814107,0.09744702),vec4(0.10592598,-0.34438035,0.31372237,-0.29046783),vec4(-0.27459988,0.11319124,0.21728364,-0.2291664)) * bufB[5] + mat4(vec4(0.40702596,0.14037567,-0.09540228,0.18665393),vec4(-0.0099590225,-0.09269774,-0.018813102,-0.3166441),vec4(-0.33779007,-0.40224823,-0.01351886,0.17736682),vec4(0.04059553,0.39181343,0.23987523,-0.42457515)) * bufB[6] + mat4(vec4(-0.25704297,0.13984314,0.31497866,0.18535797),vec4(0.011432523,0.10916869,-0.10722106,0.07995262),vec4(0.16957869,-0.22123098,0.1500526,0.14583541),vec4(0.014906158,-0.32391685,-0.1312607,-0.023024777)) * bufB[7];\nbufA[1] = vec4(0.46593526,0.036177434,0.06725093,-0.28059682) + mat4(vec4(0.23181808,0.13407703,-0.045185253,0.13983737),vec4(-0.3092881,0.013972204,-0.02295093,0.018841159),vec4(0.103429236,-0.06574603,0.38813707,-0.10968015),vec4(-0.32056773,0.45648277,-0.7135794,0.4767607)) * bufB[0] + mat4(vec4(0.10919684,0.40075067,0.008485489,0.074146055),vec4(0.25748712,-0.15494213,0.42584115,-0.21502708),vec4(0.37903774,-0.08792558,-0.082045734,-0.31590173),vec4(0.21652547,-0.21645887,0.13841797,-0.3927338)) * bufB[1] + mat4(vec4(0.16777447,-0.23371103,-0.16266394,-0.39636564),vec4(0.20761335,-0.42229077,-0.12855881,0.016761675),vec4(0.09105356,-0.12978584,-0.25831038,-0.011473507),vec4(-0.22217493,0.1239433,-0.055709146,0.015506086)) * bufB[2] + mat4(vec4(-0.065011576,0.027136173,-0.13745321,-0.18217929),vec4(0.0811662,-0.18708833,-0.27395827,0.36446893),vec4(-0.06949819,0.21191648,-0.0047355336,0.15223885),vec4(-0.1347847,-0.20898333,-0.06319368,-0.088675365)) * bufB[3] + mat4(vec4(-0.2101114,0.07828467,-0.20658185,0.012636952),vec4(-0.26756218,-0.15982759,-0.05772771,0.09858922),vec4(-0.024783397,0.004144543,-0.006125087,-0.0926037),vec4(-0.1301829,-0.2647065,-0.03653441,0.1431554)) * bufB[4] + mat4(vec4(-0.112977825,-0.17488636,0.26353815,-0.2996014),vec4(-0.32679746,0.011601015,-0.33879417,-0.0028400896),vec4(-0.08401964,-0.091699675,-0.3559786,0.49013335),vec4(-0.0859612,0.0845628,0.20273422,0.037245348)) * bufB[5] + mat4(vec4(0.1475162,0.13893895,-0.069529295,0.08139408),vec4(0.004632704,-0.15862343,-0.14818312,0.102737874),vec4(0.3596295,0.33627847,0.2331262,-0.14367014),vec4(0.09034015,0.12032441,-0.10248859,0.21218017)) * bufB[6] + mat4(vec4(0.115525454,-0.290103,0.23906943,-0.16730317),vec4(0.11643035,0.3360917,-0.03829521,0.19374174),vec4(-0.16647197,0.10389662,0.010095055,0.09623057),vec4(-0.07118785,-0.006897062,0.011194879,0.2973026)) * bufB[7];\nbufA[2] = vec4(-0.06225421,0.0034581153,0.07959781,0.27581975) + mat4(vec4(-0.3656078,-0.32077602,0.049264025,-0.102455445),vec4(-0.08837617,-0.15332448,0.08703315,0.0449923),vec4(0.09812739,0.41926,-0.16133997,0.18834881),vec4(0.53321546,-0.12870792,0.24636008,-0.5755111)) * bufB[0] + mat4(vec4(-0.029600997,-0.061254714,-0.046466623,-0.121304005),vec4(-0.27073812,0.02494717,-0.09021566,0.258797),vec4(-0.186367,-0.16186394,0.06501124,0.12190456),vec4(-0.14224842,0.13899915,-0.21024172,0.21415783)) * bufB[1] + mat4(vec4(-0.17421295,-0.17543574,-0.25727183,0.013605263),vec4(-0.1286979,0.014583826,0.13898861,0.019512087),vec4(-0.084667586,-0.19159275,0.091463305,-0.19996348),vec4(-0.42291683,0.31295598,-0.023705008,0.061287235)) * bufB[2] + mat4(vec4(0.065041475,4.4074208e-05,-0.15776218,-0.051138494),vec4(-0.18266103,-0.03953239,-0.13551965,0.18241607),vec4(-0.42452857,-0.2562794,0.14536425,0.15369366),vec4(-0.3708915,-0.19894803,0.07624353,-0.016724106)) * bufB[3] + mat4(vec4(-0.20127185,0.14483654,0.11321073,-0.24125567),vec4(-0.05967705,-0.27588293,-0.012242985,-0.18147609),vec4(0.036819585,-0.07734192,0.16063663,0.11696024),vec4(-0.07356594,-0.09015502,-0.34551528,0.17901213)) * bufB[4] + mat4(vec4(0.12904297,-0.13683309,-0.39413497,0.41075516),vec4(-0.028613534,0.43513948,0.13655952,-0.29642758),vec4(-0.05274595,0.021839406,0.10183883,0.008013819),vec4(0.048925325,0.035921667,-0.42707053,-0.00097247923)) * bufB[5] + mat4(vec4(-0.2629169,-0.044459622,0.31403053,0.037351556),vec4(-0.22182192,0.16391733,0.038330175,0.040236983),vec4(-0.14570226,-0.3937073,0.09281743,-0.07290846),vec4(0.26854974,-0.12272264,-0.33266243,-0.20005974)) * bufB[6] + mat4(vec4(-0.13695125,-0.22930434,0.0961466,0.5331427),vec4(0.3354983,0.34226868,0.1346062,-0.076693326),vec4(0.25980148,0.1282972,0.08996564,-0.13141891),vec4(-0.15375012,-0.17221671,0.01729891,-0.09257224)) * bufB[7];\nbufA[3] = vec4(-0.12428049,0.11932427,-0.16545595,-0.05756119) + mat4(vec4(0.016324203,0.0070503717,0.13745423,-0.56379133),vec4(-0.19603537,0.11958066,0.31541392,-0.053679757),vec4(-0.10590099,-0.15287338,-0.13932653,0.008889222),vec4(-0.1542453,0.33893818,0.4605079,0.111481026)) * bufB[0] + mat4(vec4(0.13896489,0.13849023,0.0698311,0.22967015),vec4(0.093788415,-0.7542201,-0.088264756,-0.03815472),vec4(0.0040467298,-0.106772944,0.11790971,-0.10323042),vec4(0.10662829,-0.07528042,-0.11350304,0.36212942)) * bufB[1] + mat4(vec4(-0.1112188,0.0975154,-0.025458515,0.012633374),vec4(-0.05663213,0.30507877,-0.08481582,0.14739148),vec4(0.036127545,0.07103541,0.043744124,0.056217972),vec4(-0.14915968,-0.22765511,0.18193997,-0.55641687)) * bufB[2] + mat4(vec4(0.07675106,-0.15374899,-0.22060814,-0.29905078),vec4(-0.37921005,-0.115961395,0.22808306,-0.042249214),vec4(-0.10346143,0.35511273,-0.113885194,-0.044545405),vec4(-0.19591857,0.10451849,0.17417444,-0.6351259)) * bufB[3] + mat4(vec4(0.0023037351,0.33194482,-0.24521172,0.009198964),vec4(-0.59184253,0.38043132,0.17684245,0.1856419),vec4(0.45147082,-0.2680794,0.007978488,-0.28623423),vec4(0.24982135,-0.2248209,-0.3056736,-0.18358383)) * bufB[4] + mat4(vec4(0.1731478,-0.10336841,-0.21723112,0.062322244),vec4(-0.2654957,0.14919546,0.15112634,0.22317669),vec4(-0.15194492,-0.03046003,0.40650797,-0.31239823),vec4(0.1455402,-0.34104812,-0.17257068,-0.016693505)) * bufB[5] + mat4(vec4(0.05444248,0.11907101,0.08428865,-0.2917412),vec4(-0.30951703,0.22640795,0.33268008,-0.015672958),vec4(0.1918213,-0.06847681,-0.17199175,-0.05304332),vec4(0.19157998,-0.04304072,-0.03659898,0.16631436)) * bufB[6] + mat4(vec4(0.1599987,-0.14866163,-0.21668372,0.19095702),vec4(-2.9426796e-05,-0.5987385,-0.13603349,0.11258819),vec4(0.43154883,-0.29944405,0.24117982,0.15394574),vec4(-0.1275458,-0.17521957,0.29330072,0.12679692)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.263863742351532,0.035836268216371536,0.10443878173828125,0.0) + mat4(vec4(-0.08396118879318237,-0.10623916983604431,-0.09789670258760452,0.0),vec4(0.17725767195224762,0.1097036749124527,0.11010914295911789,0.0),vec4(0.12010131776332855,0.15580756962299347,0.13584083318710327,0.0),vec4(-0.04991045221686363,-0.11938060820102692,-0.007656275760382414,0.0)) * bufB[0] + mat4(vec4(0.06106119975447655,0.027121054008603096,0.21879155933856964,0.0),vec4(-0.06853193044662476,-0.044354770332574844,-0.0380147248506546,0.0),vec4(0.08501219004392624,0.1289045512676239,0.1582133024930954,0.0),vec4(-0.09080769866704941,-0.06330578029155731,-0.1113947406411171,0.0)) * bufB[1] + mat4(vec4(0.08060590922832489,0.07974909245967865,-0.12938962876796722,0.0),vec4(0.02694082446396351,-0.09001751989126205,-0.0991106927394867,0.0),vec4(-0.09161287546157837,-0.1198924332857132,-0.1008528620004654,0.0),vec4(0.08323775976896286,0.1245943084359169,0.21026970446109772,0.0)) * bufB[2] + mat4(vec4(0.13390710949897766,0.19986627995967865,0.1081508919596672,0.0),vec4(-0.1714293658733368,-0.10607593506574631,-0.16661226749420166,0.0),vec4(-0.15257330238819122,-0.03343602642416954,-0.07700520008802414,0.0),vec4(0.026539664715528488,0.18922770023345947,0.017614802345633507,0.0)) * bufB[3] + mat4(vec4(-0.11334364861249924,-0.19739952683448792,-0.11451253294944763,0.0),vec4(0.08358342200517654,0.08518606424331665,0.018476059660315514,0.0),vec4(0.03842373937368393,0.054493531584739685,0.06034700199961662,0.0),vec4(0.01005870383232832,0.03315720707178116,-0.030239909887313843,0.0)) * bufB[4] + mat4(vec4(0.033736180514097214,0.08137354254722595,0.0859951302409172,0.0),vec4(-0.050395283848047256,-0.13080228865146637,-0.14714986085891724,0.0),vec4(-0.17226126790046692,-0.05426861718297005,-0.14663107693195343,0.0),vec4(-0.04087897762656212,0.09960252046585083,-0.06162802129983902,0.0)) * bufB[5] + mat4(vec4(0.05477866530418396,-0.07451740652322769,-0.18346306681632996,0.0),vec4(-0.046939749270677567,-0.11765880882740021,-0.03384514898061752,0.0),vec4(-0.14875680208206177,-0.13643665611743927,-0.010204277001321316,0.0),vec4(0.0515187568962574,0.12010318040847778,0.02667689137160778,0.0)) * bufB[6] + mat4(vec4(-0.11144999414682388,-0.122743621468544,0.023166414350271225,0.0),vec4(-0.15750819444656372,-0.11615343391895294,-0.16643980145454407,0.0),vec4(-0.08450669795274734,-0.14052613079547882,-0.1501125991344452,0.0),vec4(0.005754927173256874,0.07355061173439026,0.027643321081995964,0.0)) * bufB[7];\nreturn vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n\n        uv.x *= iResolution.x / iResolution.y;\n        uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(1., -1.) * 4. * (uv - vec2(0.5, 0.5));\n    fragColor = cppn_fn(uv, uv.x, sin(iTime), 0., 0.);\n\n    // Output to screen\n    //fragColor = cppn_fn(uv, sin(iTime), sin(2.*iTime), sin(3.*iTime), sin(4.*iTime));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3fzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 145, 145, 103877], [103879, 103879, 103936, 103986, 104476]], "test": "valid"}
{"id": "ltcBD4", "name": "Owl!!", "author": "jkashimura", "description": "Project", "tags": ["beginner"], "likes": 0, "viewed": 113, "published": "Public", "date": "1539830943", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define repeat (v, r) (mod(v, r) - r/2.)\n\nstruct Shape {\n    float dist;\n    vec4 color;\n};\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n    return fract(sin(dot(v*1., vec2(324.654, 156.546)))*46556.2);\n}\nmat2 rot(float a) {\n    float r = cos(a);\n    float f = sin(a);\n    return mat2(r, f, -f, r);\n}\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float h) {\n    float d = length(p.xz) - r;\n    d = max(d, abs(p.y) - h);\n    return d;\n}\nfloat sphere(vec3 v, float r) {\n    return length(v) - r;\n}\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\nfloat mixColors(float r, float v, float z) {\n    return clamp(.5 + .5*(v - r)/z, 0., 1.);\n}\nfloat mixShapes(float v, float f, float r) {\n    float z = mixColors(v, f, r);\n    return mix(f, v, z) - r*z*(1. - z);\n}\nfloat pModPolar(inout vec2 v, float r) {\n    float f = 6.28318/r;\n    float z = atan(v.y, v.x) + f*.5;\n    float m = floor(z/f);\n    z = mod(z, f) - f*.5;\n    v = vec2(cos(z), sin(z))*length(v);\n    return m;\n}\nvoid pR45(inout vec2 p) {\n    p = (p + vec2(p.y, -p.x))*sqrt(.5);\n}\nfloat pMod1(inout float p, float size) {\n    float halfSize = size*.5;\n    float c = floor((p + halfSize)/size);\n    p = mod(p + halfSize, size) - halfSize;\n    return c;\n}\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n    if((a < r) && (b < r)) {\n        vec2 p = vec2(a, b);\n        float columnradius = r*sqrt(2.)/((n - 1.)*2. + sqrt(2.));\n        pR45(p);\n        p.x -= sqrt(2.)/2.*r;\n        p.x += columnradius*sqrt(2.);\n        if(mod(n, 2.) == 1.) {\n            p.y += columnradius;\n        }\n        pMod1(p.y, columnradius*2.);\n        float result = length(p) - columnradius;\n        result = min(result, p.x);\n        result = min(result, a);\n        return min(result, b);\n    } else {\n        return min(a, b);\n    }\n}\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n    a = -a;\n    float m = min(a, b);\n    if((a < r) && (b < r)) {\n        vec2 p = vec2(a, b);\n        float columnradius = r*sqrt(2.)/n/2.;\n        columnradius = r*sqrt(2.)/((n - 1.)*2. + sqrt(2.));\n        pR45(p);\n        p.y += columnradius;\n        p.x -= sqrt(2.)/2.*r;\n        p.x += -columnradius*sqrt(2.)/2.;\n       \t\n        if(mod(n, 2.) == 1.) {\n            p.y += columnradius;\n        }\n        pMod1(p.y, columnradius*2.);\n        float result = -length(p) + columnradius;\n        result = max(result, p.x);\n        result = min(result, a);\n        return -min(result, b);\n    } else {\n        return -m;\n    }\n}\n\nShape character(vec3 c) {\n    Shape shape;\n    shape.dist = 1000.;\n    shape.color = vec4(1.);\n    //instiating vars\n    vec3 b = c;//body\n    vec3 h = c;//head\n    vec3 e = c;//eyes\n    vec3 n = c;//nose\n    vec3 m = c;//mouth\n   \tvec3 a = c;//ear\n    vec3 w = c;//wing\n    \n    \n    //mouth\n    //m.x = abs(m.x)-.3;\n    float mouth = sphere(m - vec3(0., .2 , - 2.),.1); \n    \n    \n    //nose\n    vec4 nColor = vec4(1.,.4,0.,1.); //brown    \n    float nose = fBox(e - vec3(0., .4, - 2.), vec3(.02,.04,.05));\n    \n    //eye\n    vec4 eColor = vec4(1.,1.,1.,1.); //white\n    e.x = abs(e.x) - .3; //mirror\n    float eye = sphere(e - vec3(0., .6, - 2.), .1); \n    float lids = sphere(e - vec3(.0001, .7,   -1.-abs(sin(iTime))), 0.08); //animate the blink by using trig \n    \n    \n    //head\n    vec4 hColor = vec4(1.,.5,0.,1.); //brown\n    float head = sphere(h-vec3(0,.8,0), 1.1);\n    \n    //ear\n    vec4 aColor = vec4(1.,.8,0.,1.); //brown\n    a.x = abs(a.x) - 1.; //mirror\n    float ears = fBox(a- vec3(.2, 2.1,  2.), vec3(.2, .4, .2));\n   \n    //wing\n    b.x *= cos(sin(b.x*.5)*cos(iTime));//stretch\n    float body1 = sphere(b - vec3(0., -1.,  0.), 1.); \n    \n    //body\n    b.y *= cos(sin(b.y*.4)*cos(iTime)*1.4);//stretch  \n    float body = sphere(b - vec3(0., -.5,  -2.), .3); \n    \n    //belly\n    vec4 bColor = vec4(1.,1.,1.,1.); //white\n    w.y *= cos(sin(w.y*2.)*1.23);//stretch    \n    w.x = abs(w.x)+.4;//mirror\n    w.xy *= rot(radians(90.)); //rotate\n    float belly = sphere(w - vec3(-.5, -.5,  -2.1), .3);\n    \n    bColor /= cos(sin(w.x*10.)) + cos(sin(w.y*10.));\n    \n    \n    //float ears = fBox(m - vec3(2., -1, - 2.), vec3(.075, .025, .005));\n   \n    shape.dist = min(body, head);\n    shape.dist = min(shape.dist, body1);\n    shape.dist = min(shape.dist, eye);\n    shape.dist = min(shape.dist, nose);\n    shape.dist = min(shape.dist, belly);\n    shape.dist = min(shape.dist, ears); \n    shape.dist = fOpUnionColumns(shape.dist, lids, .1, 3.);\n    shape.dist = fOpUnionColumns(shape.dist, head, .1, 5.);\n    \n    \n    shape.color = mix(nColor, eColor,mixColors(eye*0.1,nose,abs(sin(iTime))));\n    shape.color = mix(shape.color, bColor,mixColors(belly,shape.dist,1.));\n    shape.color = mix(shape.color, hColor,mixColors(head,shape.dist,1.));\n    shape.color = mix(shape.color, aColor,mixColors(ears,shape.dist,1.));                                  \n            \n    return shape;\n}\n\nShape map(vec3 c){\n  Shape shape = character(c);\n  return shape;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 v = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., -5.);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  \tscene.yx *= rot(iTime);\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1; z <= 1.;z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.00001){\n      fragColor = c.color*(1. - z); // Hit  - invert pixels\n      break;\n    }\n    scene += f*c.dist;\n\n\n  }\n}\n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcBD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 170, 192, 192, 260], [261, 261, 280, 280, 356], [357, 402, 445, 445, 523], [524, 524, 555, 555, 583], [584, 584, 604, 604, 642], [643, 679, 707, 707, 794], [795, 795, 839, 839, 886], [887, 887, 931, 931, 1007], [1008, 1008, 1048, 1048, 1218], [1219, 1219, 1244, 1244, 1286], [1287, 1287, 1327, 1327, 1459], [1460, 1460, 1519, 1519, 2034], [2035, 2035, 2099, 2099, 2728], [2730, 2730, 2755, 2755, 5127], [5129, 5129, 5147, 5147, 5195], [5197, 5197, 5252, 5252, 5689]], "test": "error"}
{"id": "ltcBRH", "name": "Circles w/ Layer & Step", "author": "cjramsden", "description": "Connor Ramsden's Three Circles with Layers for EGP-200-03", "tags": ["circles", "layers", "step"], "likes": 0, "viewed": 118, "published": "Public", "date": "1538578204", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Circle Variables\nvec2 positionOne = vec2(0.4, 0.5);\nvec2 positionTwo = vec2(0.5, 0.5);\nvec2 positionThree = vec2(0.6, 0.5);\nfloat radius = 0.2;\nconst float CIRCLE_FREQ = 1.0;\nconst float CIRCLE_MAG = 2.0;\n// Color Variables\nvec3 red = vec3(1.0,0.0,0.0);\nvec3 green = vec3(0.0,1.0,0.0);\nvec3 blue = vec3(0.0,0.0,1.0);\nvec3 bgCol = vec3(1.0,1.0,1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalizes screen coords\n    vec2 uv = fragCoord/iResolution.xy;\n    // Corrects Aspect Ratio x-wise\n    float aspectRatio = iResolution.x / iResolution.y;\n    // Corrects UV by Aspect Ratio\n    uv.x *= aspectRatio;\n    // Corrects Circle(s) Position(s) by Aspect Ratio\n    positionOne.x *= aspectRatio;\n    positionTwo.x *= aspectRatio;\n    positionThree.x *= aspectRatio;\n    \n    // Initializes Layers for output\n    vec4 BGLayer = vec4(bgCol, 1.0);\n    vec4 LayerOne = vec4(0.0,0.0,0.0,0.0);\n    vec4 LayerTwo = vec4(0.0,0.0,0.0,0.0);\n    vec4 LayerThree = vec4(0.0,0.0,0.0,0.0);\n    \n    \n    // Modifies middle circle y-value by a moving value\n    positionTwo.y = (sin(iTime)+CIRCLE_FREQ)/CIRCLE_MAG;    \n\n    // Draws a circle, and makes it red on Layer One\n    float interpOne = step(length(positionOne - uv), radius);\n    LayerOne = vec4(red, interpOne);\n    // Draws a circle, and makes it Blue on Layer Two\n    float interpTwo = step(length(positionTwo - uv), radius);\n    LayerTwo = vec4(blue, interpTwo);\n    // Draws a circle, and makes it Green on Layer Three\n    float interpThree = step(length(positionThree - uv), radius);\n    LayerThree = vec4(green, interpThree);\n    // Mixes Layers Background, One, Two, and Three to display all three circles\n    vec4 Comp = mix(BGLayer, LayerOne, LayerOne.a);\n    Comp = mix(Comp, LayerTwo, LayerTwo.a);\n    Comp = mix(Comp, LayerThree, LayerThree.a);\n    // outputs our mix(es) to screen\n    fragColor = Comp;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcBRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[353, 353, 410, 442, 1887]], "test": "valid"}
{"id": "ltcBRn", "name": "data.exhaustion", "author": "yx", "description": "Coded in about half an hour while barely conscious, after seeing Ryoji Ikeda's Datamatics 2.0 live.", "tags": ["ikeda"], "likes": 6, "viewed": 528, "published": "Public API", "date": "1538350163", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define fGlobalTime iTime\n\nfloat noise(float a)\n{\n  return fract(a*126.38921+13.156);\n}\n\nfloat noise2d(vec2 a)\n{\n  return fract(sin(dot(a,vec2(12.9345,4.3742)))*131.1563);\n}\n\nfloat verticalNoise(int a){\n  float n = noise(float(a));\n  return (n*.5+.5) * (n>.5?-1.:1.);\n}\n\nfloat digit(ivec2 p, int d)\n{\n  int[16] font=int[16](\n    0xEAAAE0,\n    0x4C44E0,\n    0xE2E8E0,\n    0xE2E2E0,\n    0xAAE220,\n    0xE8E2E0,\n    0xE8EAE0,\n    0xE22220,\n    0xEAEAE0,\n    0xEAE2E0,\n    0xEAEAA0,\n    0xCACAC0,\n    0xE888E0,\n    0xCAAAC0,\n    0xE8E8E0,\n    0xE8E880\n  );\n  return float((font[d]>>((3-p.x)+p.y*4))&1);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  int cellx = int(floor(uv.x * 8.));\n  float speed = 1.;\n  float verticalShift = fract(verticalNoise(cellx) * fGlobalTime * speed);\n  uv.y += verticalShift;\n  int celly = int(floor((uv.y) * 8.));\n  vec2 subspace = fract(uv*8.);\n  bool isNumbers = (celly&1)!=0;\n\n  vec2 cellsize = iResolution.xy/8.;\n  ivec2 pixelspace = ivec2(subspace * cellsize);\n\n  if(isNumbers)\n  {\n    out_color = vec4(digit(pixelspace%ivec2(4,6),int(noise2d(fract(fGlobalTime)+3.*vec2(pixelspace/ivec2(4,6)))*16.)));\n    out_color *= step(.5,noise2d(fract(fGlobalTime)+.5*vec2(pixelspace/ivec2(4,6))));\n  }\n  else\n  {\n    out_color = vec4(noise2d(subspace) * (noise2d(vec2(cellx,celly)+fract(fGlobalTime))));\n    out_color *= noise(uv.x*noise(uv.x+fract(fGlobalTime))+float(celly)*5.1);\n    out_color *= noise(uv.y*noise(uv.y+fract(fGlobalTime))+float(cellx)*7.1);\n    out_color *= 3.;\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcBRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 49, 49, 87], [89, 89, 112, 112, 173], [175, 175, 202, 202, 269], [602, 602, 654, 654, 1561]], "test": "valid"}
{"id": "ltcBzS", "name": "Some fx", "author": "bytewave", "description": "Some fx", "tags": ["somefx"], "likes": 8, "viewed": 791, "published": "Public", "date": "1539982879", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 cell = floor(p);\n    \n    float BottomLeft = hash(cell);\n    float BottomRight = hash(cell + vec2(1.,0.));\n    float TopLeft =  hash(cell + vec2(0.,1.));\n    float TopRight = hash(cell + vec2(1.,1.));\n    \n    vec2 posLocal = fract(p);\n    \n    vec2 u = posLocal*posLocal*(3.0-2.*posLocal);\n    \n    float BottomLine = mix(BottomLeft,BottomRight,u.x);\n    float TopLine = mix(TopLeft,TopRight,u.x);\n    \n    float CellInterpolationFinal = mix(BottomLine,TopLine,u.y);\n    \n    return CellInterpolationFinal;\n}\n\nfloat perlinNoise(vec2 p,float iteration)\n{\n    float outValue = 0.;\n    \n    for(float i = 0.0;i < iteration;i += 1. )\n    {\n        float freq = pow(2.,i);\n        float Amp = 1. / freq;\n        \n        outValue += sin((noise(p * freq) * Amp));\n    }\n    return outValue;\n}\n\n\nvec2 Turbul(inout vec2 p,float freq,float amp)\n{\n\tp.x += sin(iTime*5. + p.y * freq) * amp;\n    p.y += sin(iTime*5. + p.x * freq) * amp;\n    return p;\n}\n\nvoid rotate(inout vec2 p,float angle,vec2 rotationOrigin)\n{\n    p -= rotationOrigin;\n    p *= mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n    p += rotationOrigin;\n}\n\nvec4 fx(vec2 p)\n{\n    vec3 col = 0.5 + 0.5*cos(iTime+p.xyx+vec3(0,2,4));\n    \n    float noiseVal = 1.;\n    float l = length(p*1.)*3.;\n        \n    rotate(p,l*l*l,vec2(0.,0.));\n        \n    p += perlinNoise(p * 2.,2.)*.1 * noiseVal;\n    p -= perlinNoise(p * 4.,2.)*.05 * noiseVal;\n    p += perlinNoise(p * 8.,2.)*.025 * noiseVal;\n    p -= perlinNoise(p * 8.,2.)*.0125 * noiseVal;\n    \n    Turbul(p,20.,0.05 );\n    Turbul(p,50.,0.0125 );\n    \n    float c = 1. - max( pow(length(p*5.),0.75)*1.,0.);\n    c =  1. - abs((sin(iTime) * 0.5 + 0.5) - c)*1.;\n    return vec4(c*col,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\t\n    // Output to screen\n    fragColor = fx(uv)+fx(-uv*1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcBzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 113], [115, 115, 136, 136, 655], [657, 657, 700, 700, 933], [936, 936, 984, 984, 1087], [1089, 1089, 1148, 1148, 1261], [1263, 1263, 1280, 1280, 1840], [1842, 1842, 1899, 1899, 2064]], "test": "valid"}
{"id": "ltcfWN", "name": "Chanel Doodle #4", "author": "Flopine", "description": "15 minutes improvisation training for a performance at the Chanel Foundation gala", "tags": ["raymarching", "performance", "15mins"], "likes": 3, "viewed": 111, "published": "Public", "date": "1539636583", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui and Coyhot for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n\n#define ITER 64.\n#define PI 3.141592\n#define time iTime\n#define BPM 50./2.\n#define tempo BPM/60.\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.*PI*(c*t+d));}\n\nfloat random (vec2 st)\n{return fract(sin(dot(st.xy, vec2(12.2544, 35.1571)))*5418.548416);}\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y, p.x);\n    float l = length(p);\n    a = mod(a-per/2., per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\nvec2 mo(vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y > p.x) p.xy = p.yx;\n    return p;\n}\n\nfloat stmin(float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5 * (u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat pulse (float s)\n{return exp(-fract(time * tempo) * s);}\n\nfloat tiktak(float period)\n{\n    float tik = floor(time*tempo)+pow(fract(time*tempo),3.);\n    tik *= 3.*period;\n    return tik;\n}\n\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\nfloat od (vec3 p, float d)\n{return dot(p, normalize(sign(p)))-d;}\n\nfloat cyl (vec2 p, float r)\n{return length(p)-r;}\n\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p.xyz, p.yzx);\n    return min(p.x, min(p.y,p.z)) - d;\n}\n\nfloat prim1 (vec3 p)\n{\n    return max(-sc(p, 0.5), sphe(p, 1.));\n}\n\nfloat prim2 (vec3 p)\n{\n    float p1 = prim1(p);\n    p.xz *= rot(time);\n    p.xy *= rot(time);\n    return min (p1, od(p,1.2 - pulse(0.1)));\n}\n\nfloat prim3(vec3 p)\n{\n    float p1 = prim2(p);\n    p.xz *= rot(time*0.5);\n    p.xz *= rot(p.y*0.8);\n    p.xz = moda(p.xz, 2.*PI/5.);\n    p.x -= 1.;\n    return smin(p1, cyl(p.xz, 0.1), 0.7);\n\n}\n\nfloat prim4 (vec3 p)\n{\n    p.yz *= rot(PI/2.);\n    p.xy = mo(p.xy, vec2(1., 2.));\n    p.xz = mo(p.xz, vec2(1.));\n    return prim3(p);\n}\n\nfloat prim5 (vec3 p)\n{\n    float per = 6.;\n    p.y = mod(p.y - per/2., per) - per/2.;\n    return prim4(p);\n}\n\nfloat prim6 (vec3 p)\n{\n    float p1 = prim5(p);\n    float per = 6.;\n    p.y = mod(p.y - per/2., per) - per/2.;\n    p.xy = moda(p.xy, 2.*PI/5.);\n    p.x -= 5.;\n    return min(p1,prim5(p));\n}\n\nfloat g = 0.;\nfloat SDF(vec3 p)\n{\n    float d = prim6(p);\n    g+=0.1/(0.1+d*d); \n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    uv += texture(iChannel0, uv+vec2(time*0.2,time*0.1)).r*0.02;\n\n    vec3 ro = vec3(0.001,0.001 + time*tempo,-8.); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n\n    float shad = 0.;\n    float dither = random(uv);\n\n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/ITER;\n            break;\n        }\n        d *= 0.9 + dither*0.1;\n        p += d*rd ;\n    }\n\n    float t = length(ro-p);\n\n    vec3 pal = palette\n        (length(uv),\n         vec3(0.5),\n         vec3(0.5),\n         vec3(0.5),\n         vec3(0.1,0.,0.7));\n\n    vec3 c = vec3(shad) * pal;\n    c = mix(c, vec3(0.,0.3,.3), 1.-exp(-0.001*t*t));\n    c += g *0.08*(1.-length(uv*0.7));\n    fragColor = vec4(c,1.);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcfWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 279, 335, 335, 366], [368, 368, 392, 392, 459], [461, 461, 492, 492, 618], [620, 620, 645, 645, 711], [713, 713, 762, 762, 868], [870, 870, 911, 911, 988], [990, 990, 1009, 1009, 1052], [1054, 1054, 1077, 1077, 1115], [1117, 1117, 1145, 1145, 1246], [1248, 1248, 1278, 1278, 1298], [1300, 1300, 1328, 1328, 1365], [1367, 1367, 1396, 1396, 1416], [1418, 1418, 1447, 1447, 1538], [1540, 1540, 1568, 1568, 1652], [1654, 1654, 1676, 1676, 1720], [1722, 1722, 1744, 1744, 1862], [1864, 1864, 1885, 1885, 2056], [2058, 2058, 2080, 2080, 2193], [2195, 2195, 2217, 2217, 2303], [2305, 2305, 2327, 2327, 2494], [2510, 2510, 2529, 2529, 2592], [2595, 2595, 2652, 2652, 3504]], "test": "error"}
{"id": "ltcfWS", "name": "Glitchy Static Effect", "author": "Nihilistic_Furry", "description": "Adds procedural glitchy static effect to default shader. This uses the famous \"rand () one-liner\" function. The background can be changed to anything, and the effect could be toggled on and off based off of what is going on in a game, for example.", "tags": ["noise", "static", "glitchy"], "likes": 1, "viewed": 231, "published": "Public API", "date": "1540822771", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Rand one-liner\nfloat rand(vec2 co)\n{\n\treturn fract (sin (dot (co.xy, vec2 (12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos (iTime + uv.xyx + vec3 (0, 2, 4));\n    \n    // If time is in glitch state, \n    if (rand (vec2 (iTime, iTime)) > 0.9) \n    {\n        float noise = rand (uv * iTime);\n        col *= vec3 (noise, noise, noise);\n    }\n\n    // Output to screen\n    fragColor = vec4 (col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcfWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 18, 39, 39, 113], [115, 115, 170, 220, 601]], "test": "valid"}
{"id": "ltcfz2", "name": "Minimal Dual-Level Truchet", "author": "Shane", "description": "A fairly minimal dual-level Truchet pattern implementation -- utilizing a large non-overlapping tile and a complimentary smaller one.", "tags": ["truchet", "dual", "minimal", "multiscale", "quadtree"], "likes": 20, "viewed": 806, "published": "Public API", "date": "1540385476", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t\n\tMinimal Dual Level Truchet\n\t--------------------------\n\n\tThis is a fairly minimal dual-level Truchet pattern implementation -- utilizing \n\ta large non-overlapping tile and a complimentary smaller one. Obviously, it's \n    less interesting than the multiscale version constructed with overlapping tiles, \n\tbut it has a certain clean appeal to it.\n\n\tI've put it together for anyone who's interested in the process, but doesn't have \n\ttime to decipher the logic in my \"Quadtree Truchet\" example. By the way, Abje has \n\tan interesting version, which I've linked to below.\n\n\tI've made the two-iteration quadtree loop as minimal, yet readable, as possible,\n\tbut it could be cut down further. However, I'll leave it to the code golfers to \n    write the one or two tweet version. :)\n\n    I really held back on the rendering, but I at least wanted to make it look \n\tpresentable. When rendering a 2D distance field, I usually like to take advantage \n\tof the pixel shader environment and mix in a few layers. This has the standard \n\tshadow, edge and opaque layers, with some additional field-based patterns and \n\thighlighting. For anyone not familiar with the process, it's worth learning,\n\tbecause you can add some extra dimension to your flat 2D imagery, which, on a lot \n\tof occasions, can provide more viual interest.\n\n\tAnyway, 2D extruded and 3D versions are next. I also have a more interesting \n    looking tri-level example, so I should probably post that as well.\n\n\t\n\t// Multiscale versions with overlapping tiles:\n\n\t// More elaborate quadtree example.\n\tQuadtree Truchet - Shane\n\thttps://www.shadertoy.com/view/4t3BW4\n\n    // Abje always has an interesting way of coding things. :)\n\tblack and white truchet quadtree - abje\n\thttps://www.shadertoy.com/view/MtcBDM\n\n\t// A really simple non-overlapping quadtree example.\n\tRandom Quadtree - Shane\n\thttps://www.shadertoy.com/view/llcBD7\n\t\n\n*/\n\n// Standard single scale (one level) Truchet pattern -- otherwise knows as a \n// Truchet pattern. :) Actually, I find it effectively illustrates how the\n// dual scale pattern relates to the regular one.\n//#define SINGLE_SCALE\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p){ \n\n    // Faster, but doesn't disperse things quite as nicely.\n    return fract(vec2(262144, 32768)*sin(dot(p, vec2(57, 27))));\n}\n \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Screen coordinates, plus some screen resolution restriction to stop the\n    // fullscreen version from looking too bloated... unless people are on a high\n    // PPI device, in which case you'd need a PPI variable to account for that,\n    // which isn't standard or trivial at present. Either way, it's all too hard,\n    // so I'll make do with this hack. :)\n    float iRy = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iRy;\n    \n    // Scaling and translation.\n    vec2 oP = uv*4. + vec2(.5, iTime/2.);\n\n    \n    // Distance tile values and random entries. Each represents the chance that\n    // a tile for each layer will be rendered. For instance, the large tile \n    // will have a 50% chance, and the remaining smaller tiles will have a 100% \n    // chance. I.e., they'll fill in the rest of the squares.\n    vec2 d = vec2(1e5), rndTh = vec2(.5, 1);\n    \n    #ifdef SINGLE_SCALE\n    rndTh.x = 1.;\n    #endif\n\n    // Initial cell dimension.\n    float dim = 1.;    \n    \n    for(int k=0; k<2; k++){\n        \n        // Base cell ID.\n\t\tvec2 ip = floor(oP*dim);\n        \n        // Unique random ID for the cell.\n        vec2 rnd = hash22(ip);\n\n       \n\t\t// If the random cell ID at this particular scale is below a certain threshold, \n        // render the tile. \n        if(rnd.x<rndTh[k]){\n            \n            // Tile construction: By the way, the tile designs you use are limited by your imagination. \n        \t// I chose the ones that seemed most logical at the time -- Arcs and grid vertice circles.\n\n           \n            // Local cell coordinate.\n            vec2 p = oP - (ip + .5)/dim; // Equivalent to: mod(oP, 1./dim) - .5/dim;\n            \n            // Grid lines.\n \t\t    d.y = abs(max(abs(p.x), abs(p.y)) - .5/dim) - .0075;\n         \n             \n            // Use the unique random cell number to flip half the tiles vertically, which,\n            // in this case, has the same effect as rotating by 90 degrees.\n            p.y *= rnd.y>.5? 1. : -1.;\n           \n            // Arc width: Arranged to be one third of the cell side length. This is half that\n            // length, but it gets doubled below.\n            float aw = .5/3./dim;\n\n            // Rendering the two arcs by rendering one arc flipped across the diagonal: It's an old \n            // trick that works in some situations, like this one. Alternatively, you could uncomment \n            // the diagonal reflection line below and render another arc on the opposite diagonal.\n            p = p.x>-p.y? p : -p.yx;\n            d.x = abs(length(p - .5/dim) - .5/dim) - aw;\n            \n            // Negate the arc distance field values on the second tile.\n            d.x *= k==1? -1. : 1.;\n          \n            #ifndef SINGLE_SCALE \n            // Placing circles at the four corner grid vertices. If you're only rendering one \n            // level (rndTh[0]=1.), you won't need them... unless you like the look, I guess. :)\n            d.x = min(d.x, (length(abs(p) - .5/dim) - aw));\n            #endif\n             \n            // Increasing the overall width of the pattern slightly.\n            d.x -= .01;\n \n            // Since we don't need to worry about neighbors\n            break;\n\n        }\n        \n        // Subdividing. I.e., decrease the cell size by doubling the frequency.\n        // Equivalent to writing \"dim = exp2(float(k))\" at the top of the loop.\n        dim *= 2.;\n        \n    }\n    \n    // RENDERING.\n    //\n    // A lot of the following lines are for decorative purposes.\n    \n    // Scene color. Initiated to the background.\n    vec3 col = vec3(.1);\n\n    // Render the grid lines.\n    float fo = 4./iRy;\n    col = mix(col, vec3(0), (1. - smoothstep(0., fo*5., d.y - .01))*.5); // Shadow.\n    col = mix(col, vec3(1), (1. - smoothstep(0., fo, d.y))*.15); // Overlay.\n \n\n    // Render the tiles. This is a lazy way to do things, but it gets the job done.\n    fo = 10./iRy/sqrt(dim);\n    float sh = max(.75 - d.x*10., 0.); // Distance field-based shading.\n    sh *= clamp(-sin(d.x*6.283*18.) + .75, -.25, 1.) + .25; // Pattern overlay.\n\n    col = mix(col, vec3(0), (1. - smoothstep(0., fo*5., d.x))*.75); // Shadow.\n    col = mix(col, vec3(0), 1. - smoothstep(0., fo, d.x)); // Outline.\n    // Greyish, shaded, pattern overlay.\n    col = mix(col, vec3(.3)*sh, 1. - smoothstep(0., fo, d.x + .015)); \n    // Pinkish, shaded color.\n    // abs(d.x + .12) - .02 = max(d.x + .1, -(d.x + .14))));\n    col = mix(col, vec3(.8, .03, .1)*sh, 1. - smoothstep(0., fo, abs(d.x + .12) - .02));\n      \n    \n     \n    // UV color mixing.\n    col = mix(col, col.xzy, uv.y*.5 + .5);\n    \n    // Mild spotlight.\n    col *= max(1.25 - length(uv)*.25, 0.);\n    \n\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcfz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2120, 2142, 2162, 2224, 2291], [2295, 2295, 2349, 2720, 7131]], "test": "valid"}
{"id": "ltcfzl", "name": "trig deformed sphere", "author": "MonterMan", "description": "a sphere deformed with periodic functions.", "tags": ["sphere"], "likes": 1, "viewed": 97, "published": "Public", "date": "1540592984", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(in vec3 p)\n{\n    p = fract(p * vec3(821.35, 356.17, 671.313));\n    p += dot(p, p+23.5);\n    return fract(p.x*p.y*p.z);\n}\n\nfloat noise(in vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    \n    float a = hash(ip + vec3(0, 0, 0));\n    float b = hash(ip + vec3(1, 0, 0));\n    float c = hash(ip + vec3(0, 1, 0));\n    float d = hash(ip + vec3(1, 1, 0));\n    float e = hash(ip + vec3(0, 0, 1));\n    float f = hash(ip + vec3(1, 0, 1));\n    float g = hash(ip + vec3(0, 1, 1));\n    float h = hash(ip + vec3(1, 1, 1));\n    \n    vec3 t = smoothstep(vec3(0), vec3(1), fp);\n    return mix(mix(mix(a, b, t.x), mix(c, d, t.x), t.y),\n               mix(mix(e, f, t.x), mix(g, h, t.x), t.y), t.z);\n}\n\nfloat fbm(in vec3 p)\n{   \n    float res = 0.0;\n    float amp = 0.5;\n    float freq = 2.0;\n    for (int i = 0; i < 5; ++i)\n    {\n        res += amp * noise(freq * p);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return res;\n}\n\nfloat bi_fbm(in vec3 p)\n{\n    return 2.0 * fbm(p) - 1.0;\n}\n\nvec3 warp(in vec3 p)\n{\n    float t = 4.0*p.y + 2.0*iTime;\n    p.xz += vec2(sin(t), cos(t));\n    return p;\n}\n\nfloat map(in vec3 p)\n{\n    p = mix(p, warp(p), 0.5 * (1.0 + cos(iTime)));\n    return 0.5 * (length(p) - 1.0);\n}\n\nvec3 map_n(in vec3 p)\n{\n    vec2 e = vec2(0, 0.001);\n    return normalize(vec3(map(p + e.yxx), map(p + e.xyx), map(p + e.xxy)) - map(p));\n}\n\nvec3 color_map(in float t)\n{\n    vec3 a = vec3(1, 0, 0);\n    vec3 b = vec3(1, 0.3, 0);\n    vec3 c = vec3(1, 0.7, 0);\n    vec3 d = vec3(1, 0.3, 0);\n    \n    if (t < 0.333)\n    {\n        return mix(a, b, 3.0*t);\n    }\n    else if (t < 0.666)\n    {\t\n        return mix(b, c, 3.0*(t - 0.3333));\n    }\n    else\n    {\n        return mix(c, d, 3.0*(t - 0.6666));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 at = vec3(0);\n    vec3 ro = vec3(0, 0, -3);\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0,1,0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(cam_x * uv.x + cam_y * uv.y + 1.73 * cam_z);\n    \n    int iter = 0;\n    int matid = -1;\n    float t = 0.001;\n    float t_max = 20.0;\n    for (int i = 0; i < 256; ++i)\n    {\n        if (t > t_max) break;\n        \n        float d = map(ro + t*rd);\n        if (d < 0.001)\n        {\n            matid = 0;\n            iter = i;\n            break;\n        }\n        t += d;\n    }\n    \n    float occ = 1.0 - float(iter) / 256.0;\n    \n    vec3 sky = vec3(0.6, 0.7, 0.8);\n    vec3 col = sky;\n    if (matid != -1)\n    {\n        vec3 p = ro + t*rd;\n        vec3 n = map_n(p);\n        vec3 l = normalize(vec3(0.5, 0.4, -0.5));\n        vec3 sun = vec3(1.5);\n        vec3 albedo = vec3(0.9) * color_map(fbm(warp(p)));\n        \n        vec3 direct_light = max(0.0, dot(n, l)) * sun;\n        vec3 indirect_light = pow(occ, 10.0) * (0.2 * sky);\n        \n        col = (indirect_light + direct_light) * albedo;\n    }\n    \n    col = 1.0-exp(-col);\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcfzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 131], [133, 133, 157, 157, 704], [706, 706, 728, 728, 936], [938, 938, 963, 963, 996], [998, 998, 1020, 1020, 1105], [1107, 1107, 1129, 1129, 1218], [1220, 1220, 1243, 1243, 1359], [1361, 1361, 1389, 1389, 1724], [1726, 1726, 1783, 1783, 3070]], "test": "valid"}
{"id": "ltdBDH", "name": "Character Project- Penguin", "author": "tiff", "description": "Penguin Character", "tags": ["penguin"], "likes": 2, "viewed": 107, "published": "Public", "date": "1539552327", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\nmat2 rot2D(float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(co, si, -si, co);\n}\n\n\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x - sa*p.y, sa*p.x + ca*p.y, p.z);\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat sphere(vec3 v, float r){\n  return length(v)-r;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n//Cone shape\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0.)));\n\t}\n\treturn d;\n}\n\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nfloat fOpUnionRound(float a, float b, float r) { //rounds intersection of two objects\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n\nfloat fOpUnionColumns(float a, float b, float r, float n) { //creates columns/ripples when the shapes/distance fields overlaps\n    //a 1st distance field\n    //b 2nd distance field\n    //r is how fast it's merging\n    //n is how many repitions/ripples/columns\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\n//=======================\n\nShape character(vec3 c){\n  Shape shape;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n    \n  vec3 h = c; // Head\n  vec3 b = c; // Body\n  vec3 rf = c; // Feet\n  vec3 lf = c;\n  vec3 a = c; // Arms \n  vec3 e = c; // Eyes\n  vec3 bk = c; //Beak  \n  vec3 ice = c; //iceberg\n  \n  \n    //Head\n    float head = sphere(h+vec3(0., -0.65, 0.),.75); //create head\n    vec4 hColor = vec4(.75, .9, 1., 1.);\n\n    \n    //Body\n    b.y *= .9;\n    float body = sphere(b+vec3(0., 0.5, 0.),.99); // create body\n    vec4 bColor = vec4(1., 1., 1., 1.);\n\n    \n \t//Feet\n    lf.yz *= rot(sin(iTime*1.5)*.2);\n    float feet1 = sphere(lf+vec3(.3, 1.5, -.2),.12); // create bottom of Feet\n    float feet2 = sphere(lf+vec3(.5, 1.5,.3),.12); // create top of Feet\n    float feet = fOpUnionRound(feet1, feet2, 1.); // merge to make one Feet\n    \n    rf.yz *= rot(cos(iTime*1.5)*.2);\n    float rfeet1 = sphere(rf+vec3(-.3, 1.5,- .2),.12); // create bottom of Feet\n    float rfeet2 = sphere(rf+vec3(-.5, 1.5,.3),.12); // create top of Feet\n    float rightfeet = fOpUnionRound(rfeet1, rfeet2, 1.); // merge to make one Feet\n    vec4 fColor = vec4(1.5, 1.2, -0.2, 1.);\n    \n    //Arms\n    a.x = abs(a.x) -2.;\n    \n    a.y *= cos(sin(a.x*1.8))*.5;\n    a.z *= cos(sin(a.x*2.5));\n    a.zx *= cos(sin(60.))*.75;\n    float arm = sphere(a + vec3(.85, 0.2, .25), .2);\n    \n    //Eyes\n    e.x = abs(e.x) -1.;\n    float eyes = sphere(e+vec3(.75, -.63, .75),.2);\n    float pupil = sphere(e+vec3(.78, -.6, .6),.12);\n    //Pupil Color\n    vec4 eColor = vec4(-.5, -.5, -.5, 1.);\n    vec4 pColor = vec4(2., 2., 2., 1.);\n    \n     //Beak\n    bk -= vec3(0.,0.25,-.7); //moving the center to (0,1,0)\n    //if bk was (0,1,0) it will now be (0,1,0)-(0,1,0)=(0,0,0) center\n    \n    pModPolar(bk.zy, 1.0); \n    bk -= vec3(0.,0.,0.); //moving center after modpolar making it happen 12 times\n    bk.yz *= rot(radians(-90.0)); //rotate beak\n    \n    bk.z *=1.7;//compress beak\n    float beak = fCone(bk, .2 ,.3);\n    vec4 bkColor = vec4(1.2, 1.2, .1, 1.);\n\n    \n    //Iceberg\n    float iceberg = fCylinder(ice+vec3(0., 1.7, 0.), 1.75, .075);\n    vec4 iceColor = vec4(.1, .5, .7, 1.);\n    \n    \n    \n    //draw shapes to screen\n    shape.dist = fOpUnionRound(head, body, .25); //merge head and body\n    shape.dist = min(shape.dist, feet);\n    shape.dist = min(shape.dist, rightfeet);\n    \n    shape.dist = fOpUnionRound(shape.dist, arm, .06);\n    shape.dist = max(shape.dist, -eyes);\n    shape.dist = min(shape.dist, pupil);\n    shape.dist = min(shape.dist, beak);\n    shape.dist = min(shape.dist, iceberg);\n    \n    shape.color = mix(hColor, bColor, mixColors(head, body, 0.5));\n    shape.color = mix(shape.color, fColor, mixColors(feet, body, .3));\n    shape.color = mix(shape.color, fColor, mixColors(rightfeet, body, 0.3));\n    shape.color = mix(shape.color, bkColor, mixColors(beak, shape.dist, .01));\n    shape.color = mix(shape.color, iceColor, mixColors(iceberg, body, 1.));\n    shape.color = mix(shape.color, eColor, mixColors(eyes, shape.dist, 0.01));\n    shape.color = mix(shape.color, pColor, mixColors(pupil, shape.dist, 0.01));\n\n    \n\n    \n  return shape;\n}\n\n\nShape map(vec3 c){\n  //c.xz *= rot(iTime);\n    \n  Shape face = character(c);\n  return face;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., -5.);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n    scene.xy *= rot(iTime);\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.0001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdBDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 164, 186, 186, 253], [255, 255, 273, 273, 343], [344, 344, 365, 365, 438], [441, 441, 472, 472, 576], [578, 578, 609, 609, 714], [716, 716, 747, 747, 851], [853, 898, 946, 946, 1020], [1022, 1022, 1052, 1052, 1076], [1078, 1078, 1098, 1098, 1133], [1135, 1171, 1199, 1199, 1280], [1282, 1295, 1344, 1344, 1844], [1847, 1847, 1890, 1890, 1933], [1935, 1935, 1978, 1978, 2044], [2046, 2046, 2085, 2085, 2241], [2243, 2243, 2283, 2283, 2404], [2406, 2406, 2431, 2431, 2471], [2473, 2473, 2521, 2558, 2643], [2646, 2646, 2705, 2905, 3516], [3545, 3545, 3569, 3569, 6690], [6693, 6693, 6711, 6735, 6786], [6788, 6788, 6845, 6845, 7285]], "test": "error"}
{"id": "ltdBR4", "name": "Lava lamp blobs", "author": "pxndx", "description": "Blobs of lava float around like in a lava lamp", "tags": ["lavalamp", "blob", "lava"], "likes": 2, "viewed": 496, "published": "Public", "date": "1538860038", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat q(float a, vec2 b, vec2 c, vec2 xy) {\n\tvec2 qq = - (xy - b) * (xy - b)/(4.0 * c * c);\n\treturn a * exp(qq.x + qq.y);\n}\n\nvec3 colormap(float q) {\n    return \n        vec3(0.2, 0.8, 1.0)\n        + vec3(0.2, 0.7, 0.5) * smoothstep(vec3(0.4, 0.69, 0.7), vec3(0.69, 1.6, 5.5), vec3(q))\n        + vec3(0.6, -0.6, -0.9) * smoothstep(0.69, 0.7, q);\n}\n\nfloat blob(float a, vec2 center, float size, vec2 xy, vec2 range, vec2 speed) {\n    \n    vec2 b = center + range * cos( rand(center) + iTime / speed);\n    \n    vec2 c = mix(\n        vec2(2.0 * size, 0.0),\n        vec2(0.0, 2.0 * size),\n        0.5 - 0.08 * sin(2.0 * iTime/(speed.y))\n    );\n\treturn q(a, b, c, xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float smallest = min(iResolution.x, iResolution.y);\n    vec2 r = (iResolution.xy - smallest) / 2.0;\n    vec2 uv = (fragCoord - r) / smallest - 0.5;\n    \n    float fq = 0.0;\n    for (int i = 0; i < 25; i += 1) {\n        fq += blob(\n            mix(0.9, 1.0 ,rand(vec2(i, 1))),\n            vec2(\n                mix(-0.5, 0.5, rand(vec2(i, 2))),\n                0.0\n            ),\n            mix(0.03, 0.07, rand(vec2(i, 3))),\n            uv,\n            vec2(\n                mix(0.0, 0.6, rand(vec2(i, 4))),\n                0.5\n            ),\n            vec2(\n                mix(10.0, 22.0, rand(vec2(i, 5))),\n                mix(5.0, 7.0, rand(vec2(i, 6)))\n            )\n\n        );\n    }\n   \n    fragColor.xyz = colormap(fq);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdBR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [94, 94, 137, 137, 217], [219, 219, 243, 243, 441], [443, 443, 522, 522, 759], [761, 761, 818, 818, 1555]], "test": "valid"}
{"id": "ltdBR8", "name": "Into The Retro (DAC-FRA 2018)", "author": "teessider", "description": "This is the shader which was made for my talk at the Digital Art Conference Frankfurt 2018. Brushed up on my raymarching stuff and learned some stuff along the way. Set myself the challenge of not using textures.", "tags": ["grid", "80s", "retro", "pyramid", "fra", "2018", "dacfra", "dac"], "likes": 23, "viewed": 1376, "published": "Public", "date": "1538699181", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* By Andrew \"teessider\" Bell\nMade for my talk at Digital Art Conference Frankfurt 2018.\n\nLink to talk slides:\nhttps://docs.google.com/presentation/d/1FNYOsMmWiEzUhIcq-FBusBHGARw9IpcFf6XB8OK4Xf0/edit?usp=sharing\n\nThis is based on the dac-fra.com website graphic.\n\nSome improvements I would like to make (After the talk):\n- Floating Pyramid inside shapes\n- DAC-FRA text\n- Make the Floating Pyramid spin a cool way!\n\n*/\n\n// A couple of helper macros - coming from HLSL ;) and others too!\n#define mad(m, a, b) m*a+b\n#define rcp(x) 1.0/x\n#define saturate(a) clamp( a, 0.0, 1.0 ) // It seems that (not sure if this is a WebGL thing) the whitespace matters in macros!\n#define testMask(x) vec3( x )\n\n#define PI 3.1415\n#define TAU 6.2831\n\n// RAYMARCH LOOP PARAMS\n#define MAX_STEPS 64\n#define MAX_DIST 30.0\n#define EPSILON 0.01\n////\n\n// OBJECT IDs\n#define BACKGROUND -1.0\n#define FLOOR 1.0\n#define PYRAMID 2.0\n\n\n#define UV_SCALE 150.0\n#define SPEED 6.0\n#define GRID_SIZE 0.75\n\n////// IQ STUFF\n// IQ DISTANCE FUNCTIONS\nfloat sdSphere(vec3 point, float radius)\n{\n    return length(point) - radius;\n}\n\nfloat sdPlane2(vec3 point, vec4 normal)\n{\n    return dot(point, normal.xyz) + normal.w;\n}\n\nfloat sdBox( vec3 point, vec3 b )\n{\n    vec3 d = abs(point) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdPryamid4(vec3 p, vec3 h ) // h = { cos a, sin a, height }\n{\n    // Tetrahedron = Octahedron - Cube\n    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n \n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n    float octa = d - h.z;\n    //return max(-box,octa); // Subtraction\n    return max(box,octa); // Subtraction, opposite\n }\n\n\n// Operator - Union\n// Includes support for the IDs\nvec2 opU(vec2 d1, vec2 d2)\n{\n    // the < operator can only deal with scalars so just the DF is used. NEED IT LIKE THIS BECAUSE OF IDs\n    return(d1.x < d2.x) ? d1 : d2;\n}\n\n\n// More info here: http://iquilezles.org/www/articles/voronoise/voronoise.htm\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat iqnoise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    float inv_v = 1.0-v;\n    inv_v *= inv_v;\n    inv_v *= inv_v;\n\t\t\n\t//float k = 63.0*pow(1.0-v,4.0) + 1.0;\n    float k = 63.0*inv_v + 1.0;\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return va/wt;\n}\n////// END IQ STUFF\n\n// This is where all the Distance Fields (DFs) are added into the scene\n// also know as map() in iq's shaders :D\nvec2 scene(in vec3 point)\n{\n    // To make the sphere move along with the camera, for now it has the same speed added to it plus an offset\n    // Z is depth in this case ;)\n    // For some reason, the shape is off center if set to 0.0 ? \n    vec2 pyramid = vec2(sdPryamid4(point - vec3(0.05, sin(iTime*PI)+4.0, iTime*20.0+1.0), vec3(0.65,0.33,1.0)), PYRAMID);\n\n\n    // FOR TESTING ONLY\n    //vec2 sphere1 = vec2(sdSphere(point-vec3(0.0, sin(iTime*PI)+4.0, iTime*20.0+15.0), 8.0), PYRAMID);\n\n    float mountainsHeight = mix(1.0, smoothstep(-.05, 1., iqnoise(point.xz*.75, 1.0, 1.0)*.25), saturate(abs(point.x)-3.0));\n    vec2 mountainsGround = vec2(sdPlane2(point, vec4(0.0, mountainsHeight, 0.0, 0.0)), FLOOR);\n\n    vec2 result = opU(mountainsGround, pyramid);\n\n    return result;\n}\n\n\n//// MORE IQ STUFF\n// http://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n// Normals can be estimated from a gradient!\nvec3 calculateNormal(in vec3 point)\n{\n    vec2 h = vec2(EPSILON, 0.0); // Some small value(s)\n    return normalize(vec3(scene(point + h.xyy).x - scene(point - h.xyy).x,\n                          scene(point + h.yxy).x - scene(point - h.yxy).x,\n                          scene(point + h.yyx).x - scene(point - h.yyx).x));\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.12*float(i)*0.25 + 0.01;\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return saturate(1.0 - 3.0*occ);    \n}\n//// END IQ STUFF\n\nvec2 raymarch(in vec3 origin, in vec3 ray)\n{\n    float t = 0.0; // t is the clipping plane where anything below this is removed.\n    float id = -1.0; // For the Background\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec2 dist = scene(origin + ray * t);\n        if (dist.x < EPSILON)\n        {\n            break; // We are inside the surface.\n        }\n        // Move along the ray in constant steps\n        t += dist.x;\n        // Since each element has an ID, we want that there too!\n        id = dist.y;\n\n        if (t >= MAX_DIST)\n        {\n            id = BACKGROUND;\n            return vec2(MAX_DIST, id); //We are too far away!\n        }\n    }\n    return vec2(t, id);\n}\n\nvec4 render(in vec3 rayOrigin, in vec3 rayDirection)\n{\n    // INITIALISE finalColor so it be used later and fed into \n    vec3 finalColor = vec3(0.0);\n\n    // BACKGROUND\n    vec3 bgColor = mix(vec3(0.345,0.212,0.388), vec3(0.145,0.357,0.612), saturate(rayDirection.x));\n    float stars = smoothstep(0.745, 1.0, iqnoise(rayDirection.xy*UV_SCALE, 1.0, 1.0)); // ORIGINALLY USED UVs BUT USING RAY DIRECTION IS WAY COOLER\n    vec3 scene_background = 0.2*stars + bgColor;\n\n    // SCENE THAT ISNT THE BACKGROUND (BUT BEFORE \"POST PROCESS\" STUFF)\n    vec2 result = raymarch(rayOrigin, rayDirection);\n    if (result.y > BACKGROUND)\n    {\n\n        vec3 point = result.x * rayDirection + rayOrigin;\n        vec3 normal = calculateNormal(point);\n\n        vec3 lightDir = normalize(vec3(1.0, 1.0, -4.0));\n        float nDotL = saturate(dot(normal, lightDir));\n\n        if (result.y == FLOOR)\n        {\n            vec2 gridUVs = mod(point.xz, 1.5); //GRID SIZE\n            gridUVs = round(mad(GRID_SIZE, 0.5, gridUVs)); // GRID LINE SIZE\n            float grid = saturate(mad(-gridUVs.x, gridUVs.y, 1.0));\n\n            vec3 gridColor = vec3(0.345,0.212,0.388);\n\n            float fog = saturate(saturate(1.0-exp(-result.x*0.1)-0.8)*8.0);\n\n            finalColor = mix(gridColor+scene_background, scene_background, saturate(max(fog, 1.-grid)));\n            finalColor *= sqrt(calcAO(point, normal)); // Only want AO on FLOOR but not as intense\n        }\n        else\n        {\n            /// CURRENTLY ONLY FOR PYRAMID\n            vec3 sunColor = vec3(1.0, 0.5, 0.0);\n            vec3 ambientColor = vec3(0.0, 0.0, 0.0);\n            //finalColor = saturate(mix(nDotL * sunColor, finalColor, 1.0-exp(-result.x*0.1))); // SIMPLE FOG TEST\n            finalColor = pow(saturate(nDotL * sunColor +ambientColor), vec3(0.4545));  // Simple Gamma Correction\n            //finalColor = -normal.zzz; // FOR INSIDE MASK EVENTUALLY\n            //finalColor = (result.yyy-1.5)*fract(-iTime*0.5)*2.5-0.1; //PULSING TEST\n        }\n    }\n    else\n    {\n        finalColor = scene_background;\n    }\n    return vec4(finalColor, 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Remap from [0-1] to [-1-1] so that 0 is the middle point in\n    // Also apply aspect ratio correction too\n    vec2 orig_uv = fragCoord.xy / iResolution.xy;\n    vec2 uv = mad(2.0, orig_uv, -1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // RAYMARCH STUFF - THE SCENE\n    vec3 ray_orig = vec3(0.0, 3.0, -5.0);\n    ray_orig += vec3(0.0, 0.0, iTime*20.);\n    vec3 ray_dir = normalize(vec3(uv, 1.16)); // ray_dir.z is FOV\n    vec3 sceneColor = render(ray_orig, ray_dir).xyz;\n\n    // SCANLINES\n    vec3 linesColor = vec3(0.0, 0.04, 0.08);\n    float linesAlpha = sin(uv.y * UV_SCALE + (iTime * SPEED));\n    sceneColor = (linesColor * linesAlpha) + sceneColor;\n\n    // VIGNETTE\n    float vignette = sqrt(orig_uv.x * orig_uv.y *(1.0-orig_uv.x) * (1.0-orig_uv.y) * 16.0);\n    sceneColor *= vignette;\n    fragColor = vec4(sceneColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdBR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[968, 1009, 1051, 1051, 1088], [1090, 1090, 1131, 1131, 1179], [1181, 1181, 1216, 1216, 1311], [1312, 1312, 1379, 1418, 1843], [1846, 1898, 1926, 2032, 2069], [2072, 2150, 2172, 2172, 2323], [2325, 2325, 2371, 2371, 2907], [2929, 3042, 3069, 3279, 3824], [3827, 3959, 3996, 3996, 4281], [4283, 4283, 4325, 4325, 4618], [4638, 4638, 4682, 4682, 5325], [5327, 5327, 5381, 5444, 7432], [7435, 7435, 7490, 7603, 8339]], "test": "valid"}
{"id": "ltdBRj", "name": "Nerdery Vector Field", "author": "JustinMullin", "description": "An attempt to quickly reproduce the animated vector field effect at nerdery.com\n\nFeel free to mess with the constants at the top to get various effects. =)", "tags": ["vectorfield"], "likes": 6, "viewed": 166, "published": "Public", "date": "1540318913", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float scale = 20.0;\n\nconst float freqA = 0.4;\nconst float freqB = 0.5;\nconst float freqC = 0.7;\nconst float freqD = 0.2;\n\nconst float freqModA = 0.2;\nconst float freqModB = 0.5;\nconst float freqModC = 0.3;\nconst float freqModD = 0.2;\n\nfloat distanceToSegment(vec2 a, vec2 b, vec2 v) {\n    vec2 vA = v - a;\n    vec2 bA = b - a;\n    float projection = clamp(dot(vA, bA) / dot(bA, bA), 0.0, 1.0);\n\treturn length(vA - bA * projection);\t\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / scale;\n    \n    vec2 offset = 2.0 * fract(uv) - 1.0;\n    vec2 vector = vec2(\n        0.5 * cos(iTime*freqA + floor(uv.x) * freqModA) +\n        0.5 * sin(iTime*freqB + floor(uv.y) * freqModB),\n        0.5 * sin(iTime*freqC + floor(uv.x) * freqModC) +\n        0.5 * cos(iTime*freqD + floor(uv.y) * freqModD)\n    );\n    \n    float strength = 1.0-distanceToSegment(vec2(0.0), vector, offset)*8.0;\n    fragColor = vec4(0.5 * strength);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdBRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[241, 241, 290, 290, 440], [442, 442, 497, 497, 956]], "test": "valid"}
{"id": "ltdBRM", "name": "Pf341 - Supervision FGx", "author": "patrico", "description": "Working through GLSL examples and building SDF for Supervision on Friday 19th October 2018", "tags": ["sdf"], "likes": 2, "viewed": 107, "published": "Public", "date": "1539725678", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n#define RENDER_DEPTH 800\n#define CLOSE_ENOUGH 0.00001\n\n#define GRADIENT(pt, func) vec3( \\\n    func(vec3(pt.x + 0.0001, pt.y, pt.z)) - func(vec3(pt.x - 0.0001, pt.y, pt.z)), \\\n    func(vec3(pt.x, pt.y + 0.0001, pt.z)) - func(vec3(pt.x, pt.y - 0.0001, pt.z)), \\\n    func(vec3(pt.x, pt.y, pt.z + 0.0001)) - func(vec3(pt.x, pt.y, pt.z - 0.0001)))\n\n//Array of lights in our scene\nconst vec3 LIGHT_POS[] = vec3[](vec3(5.0));\n\n//---------------------------------------------------------------------------------------\n// Transformations\n//---------------------------------------------------------------------------------------\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s, c, 0, 0),\n        vec4(0, 0, 1.0, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0.0, 1.0, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\n//---------------------------------------------------------------------------------------\n// Signed Distance Functions\n//---------------------------------------------------------------------------------------\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cube(vec3 p, vec3 dim) {\n    vec3 d = abs(p) - dim;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdPlane(vec3 p, vec3 n) {\n    return dot(p, normalize(n));\n}\n\nfloat cylinder(vec3 p, float r) {\n \treturn length(p.xz) - r;\n}\n\nfloat hemisphere(vec3 p, float r) {\n \tfloat sphere = sphere(p, r);\n    float plane = sdPlane(p, vec3(0.0, -1.0, 0.0));\n    return max(sphere, plane);\n}\n\nfloat cone(vec3 p, vec2 hr) {\n    vec2 nhr = normalize(hr);\n    float q = length(p.xz);\n    return dot(nhr, vec2(q, p.y));\n}\n\n\nfloat igloo(vec3 p) {\n    mat4 r = inverse(rotateZ(PI/2.0));\n    float c = max(cylinder((r * vec4(p, 1.0)).xyz , 0.4), sdPlane((r * vec4(p, 1.0)).xyz,(r * vec4(vec3(0, -1.0, 0), 1.0)).xyz));\n    float p1 = sdPlane((r * vec4(p - vec3(0.0, 0.0, 0.0), 1.0)).xyz,(r * vec4(vec3(1.0, 0.0, 0.0), 1.0)).xyz);\n    float p2 = sdPlane((r * vec4(p + vec3(1.25, 0.0, 0.0), 1.0)).xyz,(r * vec4(vec3(-1.0, 0.0, 0.0), 1.0)).xyz);\n    float capped = max(p1, max(c, p2));\n    float h =  max(hemisphere(p, 1.0), sdPlane(p, vec3(0, -1.0, 0)));\n    return min(capped, h);\n}\n\nfloat tetrahedron(vec3 p) {\n    vec3 p1 = p - vec3(1.0, 1.0, 1.0);\n    vec3 p2 = p - vec3(1.0, -1.0, -1.0);\n    vec3 p3 = p - vec3(-1.0, 1.0, -1.0);\n    vec3 p4 = p - vec3(-1.0, -1.0, 1.0);\n    \n    vec3 normal1 = cross(p2 - p1, p3 - p1);\n    vec3 normal2 = cross(p4 - p1, p2 - p1);\n    vec3 normal3 = cross(p3 - p1, p4 - p1);\n    vec3 normal4 = cross(p4 - p2, p3 - p2);\n    \n    float plane1 = sdPlane(p1, normal1);\n    float plane2 = sdPlane(p1, normal2);\n    float plane3 = sdPlane(p1, normal3);\n    float plane4 = sdPlane(p2, normal4);\n \n    \n    return max(max(plane1, plane2), max(plane3, plane4));   \n}\n\nfloat corkscrew(vec3 p) {\n   p.x = p.x - cos(p.y/0.5);\n   p.z = p.z - sin(p.y/0.5);\n   float cy = cylinder(p, 1.0);\n   return cy;\n}\n\nfloat scene(vec3 p) {\n    float flr = sdPlane(p - vec3(0, -3.0, 0), vec3(0, 1, 0));\n \t//return min(igloo(p), flr);  \n    //return min(tetrahedron(p), flr);\n    return min(corkscrew(p), flr);\n}\n\n//---------------------------------------------------------------------------------------\n// Auxiliary helper functions\n//---------------------------------------------------------------------------------------\n\nvec3 getNormal(vec3 pt) {\n    return normalize(GRADIENT(pt, scene));\n}\n\n//---------------------------------------------------------------------------------------\n// Illumination and Shading\n//---------------------------------------------------------------------------------------\n\nfloat shade(vec3 eye, vec3 pt, vec3 n) {\n    float val = 0.0;\n\n    //Ambient Lighting\n    val += 0.2;\n\n    //Cast ray towards our light sources and add it to the illumination depending\n    //on the angle with the normal to the surface\n    for (int i = 0; i < LIGHT_POS.length(); i++) {\n        vec3 l = normalize(LIGHT_POS[i] - pt); \n        val += max(dot(n, l), 0.0);\n    }\n\n    return val;\n}\n\nvec3 illuminate(vec3 camPos, vec3 rayDir, vec3 pt) {\n    vec3 c, n;\n    //Using the SDF normal approximation\n    n = getNormal(pt);\n\t\n    //Everything is white\n    c = vec3(1.0);\n    return shade(camPos, pt, n) * c ;\n}\n\n//---------------------------------------------------------------------------------------\n// Ray Marching Algorithm\n//---------------------------------------------------------------------------------------\n\nvec3 castRay(vec3 camPos, vec3 rayDir) {\n    //Using the ray marching approach\n    int step = 0;\n    float t = 0.0;\n    \n    for (float d = 1000.0; step < RENDER_DEPTH && abs(d) > CLOSE_ENOUGH; t += abs(d)) {\n        d = scene(camPos + t * rayDir)/2.0;\n        step++;\n    }\n    \n    if (step == RENDER_DEPTH) {\n        return vec3(0.0, 0.0, 0.0); //getBackground(rayDir);\n    } else {\n        return illuminate(camPos, rayDir, camPos + t * rayDir);\n    }\n}\n\n//---------------------------------------------------------------------------------------\n// Set-up\n//---------------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    //The direction in which the camera is pointing\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\n//---------------------------------------------------------------------------------------\n// Output\n//---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Normalize the 2d coordinates [-1, 1]\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    //Fix the x axis to original resolution\n    p.x *= iResolution.x / iResolution.y;\n    \n    //Setting the camera - origin, lookat\n    vec3 origin = vec3(10.0*sin(iTime), 1.8, 10.0*cos(iTime));\n    vec3 look = vec3(0.0);\n    \n    \n    mat3 camera = setCamera(origin, look, 0.0);\n    vec3 direction = camera * normalize(vec3(p.xy, 2.0));\n    \n    vec3 color = castRay(origin, direction);\n    \n    fragColor = vec4(color, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdBRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[665, 665, 692, 692, 879], [881, 881, 908, 908, 1097], [1309, 1309, 1340, 1340, 1368], [1370, 1370, 1400, 1400, 1497], [1499, 1499, 1530, 1530, 1565], [1567, 1567, 1600, 1600, 1629], [1631, 1631, 1666, 1666, 1782], [1784, 1784, 1813, 1813, 1908], [1911, 1911, 1932, 1932, 2464], [2466, 2466, 2493, 2493, 3075], [3077, 3077, 3102, 3102, 3208], [3210, 3210, 3231, 3231, 3402], [3615, 3615, 3640, 3640, 3685], [3896, 3896, 3936, 3936, 4290], [4292, 4292, 4344, 4344, 4510], [4719, 4719, 4759, 4797, 5176], [5369, 5369, 5433, 5485, 5737], [5930, 5930, 5987, 6030, 6522]], "test": "error"}
{"id": "ltdBzr", "name": "fbm multiple octave noise", "author": "hellochar", "description": "fbm with multiple octave noise", "tags": ["fbm"], "likes": 16, "viewed": 321, "published": "Public", "date": "1538504070", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvec2 u_resolution;\n//uniform vec2 u_mouse;\nvec2 u_mouse;\nfloat u_time;\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nvec2 random2(in vec2 st) {\n    return normalize(vec2(\n        random(st * vec2(42.9401, 941.2301) + vec2(-9534.1, 41.4394)) * 2. - 1.,\n    \trandom(st * vec2(-456.321, 14.6943) + vec2(-585.456, 14.658)) * 2. - 1.\n    ));\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0., 1., f);\n\n    return mix(\n        \tmix(a, b, u.x),\n        \tmix(c, d, u.x),\n        \tu.y\n    );\n}\n\nvec2 noise2 (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 a = random2(i);\n    vec2 b = random2(i + vec2(1.0, 0.0));\n    vec2 c = random2(i + vec2(0.0, 1.0));\n    vec2 d = random2(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0., 1., f);\n\n    return mix(\n        \tmix(a, b, u.x),\n        \tmix(c, d, u.x),\n        \tu.y\n    );\n}\n\nvec2 octaveNoise2(in vec2 st) {\n    const int octaves = 6;\n    vec2 samplePoint = st;\n    float falloff = 0.5;\n    float amplitude = 1.;\n    vec2 sum = vec2(0.);\n    for (int i = 0; i < octaves; i++) {\n        sum += noise2(samplePoint) * amplitude;\n        amplitude *= falloff;\n        samplePoint = vec2(23.592, 504.2491) + samplePoint / falloff;\n    }\n    // totalAmplitude*scalar = 1; totalAmplitude = 1 / (1 - r), where r = falloff\n    // scalar / (1 - r) = 1 -> scalar = (1 - r)\n    float amplitudeScalar = 1. - falloff;\n    return sum * amplitudeScalar;\n}\n\nfloat octaveNoise(in vec2 st) {\n    const int octaves = 6;\n    vec2 samplePoint = st;\n    float falloff = 0.5;\n    float amplitude = 1.;\n    float sum = 0.;\n    for (int i = 0; i < octaves; i++) {\n        sum += noise(samplePoint) * amplitude;\n        amplitude *= falloff;\n        samplePoint = vec2(23.592, 504.2491) + samplePoint / falloff;\n    }\n    // totalAmplitude*scalar = 1; totalAmplitude = 1 / (1 - r), where r = falloff\n    // scalar / (1 - r) = 1 -> scalar = (1 - r)\n    float amplitudeScalar = 1. - falloff;\n    return sum * amplitudeScalar;\n}\n\n// the idea is to use the output of the noise function to modify the input to a noise function\nfloat noiseWarpingNoise(in vec2 st) {\n    float noisyValue = octaveNoise(st * u_mouse.x / u_resolution.x * 10.) * u_mouse.y / u_resolution.y * 10.;\n    return octaveNoise(vec2(noisyValue) + st);\n}\n\nfloat noiseWarpingNoise2(in vec2 st) {\n    float noisyValue = octaveNoise(st * u_mouse.x / u_resolution.x * 10.) * u_mouse.y / u_resolution.y * 10.;\n    float noisyValue2 = octaveNoise((vec2(noisyValue) + st) * u_mouse.x / u_resolution.x * 10.) * u_mouse.y / u_resolution.y * 10.;\n    float noisyValue3 = octaveNoise(vec2(noisyValue2) + st);\n    return noisyValue3;\n}\n\nfloat noise2WarpingNoise(in vec2 st) {\n    vec2 noisy2Value = octaveNoise2(st * u_mouse.x / u_resolution.x * 10.) * u_mouse.y / u_resolution.y * 10.;\n    float noisyValue2 = octaveNoise(noisy2Value + st);\n    return noisyValue2;\n}\n\nvec2 iterativeNoise2WarpingNoise(in vec2 st, in vec2 offset) {\n    const int iterations = 5;\n    vec2 noisy2Value = vec2(u_time / 100.0);\n    float scalarInput = u_mouse.x / u_resolution.x * 0.1;\n    float scalarValue = u_mouse.y / u_resolution.y * 2.;\n    for (int i = 0; i < iterations; i++) {\n        vec2 v = (st + noisy2Value) * (1. + scalarInput);\n        noisy2Value = octaveNoise2(v) * scalarValue + offset;\n    }\n    return noisy2Value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    u_resolution = iResolution.xy;\n    u_time = iTime;\n    u_mouse = mix(iMouse.xy + u_resolution * 0.1, u_resolution * 0.7, 0.5);\n    vec2 st = fragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n    st -= vec2(0.5, 0.5);\n\n    vec3 color = vec3(0.);\n    // color = vec3(noiseWarpingNoise(st * 10.));\n    // color = vec3(noise2WarpingNoise(st * 10.));\n    float r = length(iterativeNoise2WarpingNoise(st, vec2(0.)));\n    float g = length(iterativeNoise2WarpingNoise(st, vec2(0.005, 0.005)));\n    float b = length(iterativeNoise2WarpingNoise(st, vec2(0.01, 0.01)));\n    color = vec3(r, g, b);\n    color = pow(color, vec3(2.));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdBzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 145, 145, 262], [264, 264, 290, 290, 485], [487, 487, 513, 513, 839], [841, 841, 867, 867, 1193], [1195, 1195, 1226, 1226, 1758], [1760, 1760, 1791, 1791, 2317], [2319, 2414, 2451, 2451, 2610], [2612, 2612, 2650, 2650, 2979], [2981, 2981, 3019, 3019, 3211], [3213, 3213, 3275, 3275, 3660], [3662, 3662, 3719, 3719, 4402]], "test": "valid"}
{"id": "ltdBzX", "name": "Environment Project- Ship", "author": "cake7914", "description": "Ship", "tags": ["ship"], "likes": 5, "viewed": 108, "published": "Public", "date": "1540572688", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}    \n    \n    \n// Maximum/minumum elements of a vector    \nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}    \n    \n    \nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\n\nfloat pole(vec2 v, float r){\n  return length(v)-r;\n}\n\nfloat sphere(vec3 v, float r){\n  return length(v)-r;\n}\n\n\n\n// ============================\n// http://mercury.sexy/hg_sdf/\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\nfloat fOpTongue(float a, float b, float ra, float rb) {\n\treturn min(a, max(a - ra, abs(b) - rb));\n}\n// ============================\n\n\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n\n\n//=======================\n\nShape Ship(vec3 c){\n  Shape shape;\n\n  c.z = repeat(c.z, 1.22); // Repeat\n  c.x = abs(c.x)-0.5; // Mirror\n  \n  // Ship\n  vec3 shipOffset = vec3(1.2, 0.1, 0.);\n\n  \t// Walls\n  \tvec4 sColor = vec4(.1, 0.4, 0.4, 1.);\n    //vec4 sColor = vec4(.5, .3, .1, 1.);\n  \tfloat walls = fBox(c-shipOffset, vec3(0.2, 6., 0.5));\n  \n  \t// Windows\n  \tvec4 wColor = vec4(.2, .2, .2, 1.);\n  \tfloat windows = sphere(c-shipOffset, .5);\n    \n    // Seats\n    vec4 fColor = vec4(.5, .2, .2, 1.);\n    float seats = fBox(c-vec3(0., -1.5, 0.), vec3(.5, 1., 0.));\n    \n    // Engraving\n    float engraving = fBox(c-vec3(1., 1.2, 0.), vec3(.4, .15, 4));\n    \n\n  shape.dist = fOpTongue(walls, windows, .08, .1);\n  shape.dist = min(shape.dist, seats);\n  shape.dist = max(shape.dist, -engraving);\n  \n                         \n  shape.color = mix(sColor, wColor, mixColors(windows, walls, 0.));    \n  shape.color = mix(shape.color, fColor, mixColors(seats, shape.dist, 2.));\n\n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape ship = Ship(c);\n  return ship;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., iTime);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdBzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 308, 348, 348, 469], [484, 528, 548, 548, 573], [575, 575, 595, 595, 630], [632, 632, 652, 652, 697], [712, 712, 734, 734, 801], [803, 803, 821, 821, 891], [894, 894, 922, 922, 946], [948, 948, 978, 978, 1002], [1006, 1069, 1097, 1097, 1178], [1180, 1276, 1334, 1334, 1444], [1446, 1500, 1565, 1565, 1606], [1608, 1608, 1671, 1671, 1711], [1713, 1713, 1768, 1768, 1812], [1848, 1848, 1891, 1891, 1934], [1936, 1936, 1979, 1979, 2045], [2047, 2047, 2086, 2086, 2242], [2272, 2272, 2291, 2291, 3230], [3233, 3233, 3251, 3251, 3292], [3294, 3294, 3351, 3351, 3765]], "test": "valid"}
{"id": "ltdfR7", "name": "Nematomorpha", "author": "PianiGiani", "description": "A simplified version of another shader I posed earlier", "tags": ["line", "wobble", "curves"], "likes": 11, "viewed": 262, "published": "Public", "date": "1539119074", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define nTime (iTime*0.5)+1000. // speed\n\nfloat DDot(vec2 p1,vec2 p2) {\n    return 1.3-(distance(p1,p2)*300.);\n}\n\n\nfloat Wobble(float i,float factor) {\n\tfloat wob1 = sin((i+nTime+i+i)*10.)/10.+sin(nTime/3.)/85.+sin(nTime/5.)/85.;\n    float wob2 = sin((i+nTime+i+i)*10.)/10.+sin((i+nTime)*3.)*0.5+sin((i+nTime)*5.)*0.4; \n    return mix(wob2,wob1,factor);\n}\n\nfloat Curv(float i,float ii) {\n\treturn(cos((nTime/3.)+ii+ii)*(sin((i*ii+i)*(i+6.))/(7.*atan(nTime/3.))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float factor = 0.3;\n    float ii=1.+(sin(nTime/20.));\n    vec3 col1=vec3(0.);\n    \n    for (float i=0.00; i<= 1.05;i+=0.004) {\n    \n   \t\tvec2 cc= vec2(i+Curv(i,i+sin(iTime+ii)),(Wobble(i,factor)+Curv(i,ii)*4.));\n        float col = DDot(uv, (cc * vec2(1.,factor)) + vec2(0.,0.5) );\n        vec3 col2 = vec3(col * ii, col*(sin(i)+.5),col*(sin(ii)+.5));\n    \tcol1 = max(col2,col1);\n\n    }\n    fragColor = vec4(col1,0.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdfR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 71, 71, 112], [115, 115, 151, 151, 355], [357, 357, 387, 387, 464], [466, 466, 523, 573, 1038]], "test": "valid"}
{"id": "ltdfWM", "name": "Particles illusions 1", "author": "Thorgrimar", "description": "This is only a superposition of little circles which move along a radius.", "tags": ["particules"], "likes": 7, "viewed": 483, "published": "Public API", "date": "1539892963", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi (3.14159265359)\n#define twopi (6.28318530718)\n\n\n// thank you CPU\nvec2 cartToPol(vec2 coordCart) { return vec2( length(coordCart), atan(coordCart.y,coordCart.x)); }\n\nvec3 colorCircle(vec2 center, float radius, vec3 color, vec2 pos)\n{\n    \n    float d = distance(center, pos);\n    float dmr = d - radius;\n    if (dmr < 0.) {\n        return color;\n    }\n    return vec3(0.);\n}\n\nvec3 colorEmitterCircles(vec2 center, float emittRadius, float circleRadius, vec3 color, float angleRot, float nbrPieces, vec2 pos)\n{\n    float circleSpeed = 0.8;\n    // period T between two pop must be > 2.*circleRadius/circleSpeed\n    float T = 4.*circleRadius/circleSpeed;\n\tvec2 coordPol = cartToPol(pos - center);\n    float r = coordPol.x;\n    float th = coordPol.y;\n    if (r < emittRadius + circleRadius) {\n        // on each piece : \n        float numPiece = floor((th - angleRot)/twopi*nbrPieces);\n        float anglePath = twopi*(numPiece+0.5)/nbrPieces + angleRot;\n        float nT = nbrPieces*T;\n        vec2 centerCircle = center + mod(iTime - numPiece*T, nT)/nT*emittRadius*vec2(cos(anglePath), sin(anglePath));\n        return colorCircle(centerCircle, circleRadius, color, pos);\n    } else {\n        return vec3(0.);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (uv.x from -1.0 to 1.0)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x; \n\n    vec3 col = vec3(0.);\n    \n    vec2 center = vec2(-0.5, 0.);\n    float emittRadius = .5; \n    float radiusCircles = 0.01;\n    vec3 color1 = vec3(.4, .4, .6);\n    float angleRot = 0.;\n    float nbrPieces = 10.;\n    for (int i=0; i<40; i++) {\n        col += colorEmitterCircles(center, emittRadius, radiusCircles, color1, angleRot, nbrPieces, uv);\n        angleRot += 0.1*iTime/2.;\n    }\n    \n    center = vec2(0.5, 0.);\n    radiusCircles = 0.01;\n    angleRot = 0.;\n    nbrPieces = 100.;\n    for (int i=0; i<30; i++) {\n        col += colorEmitterCircles(center, emittRadius, radiusCircles, color1, angleRot, nbrPieces, uv);\n        angleRot += 0.1*iTime/2.;\n    }\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdfWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 76, 108, 108, 174], [176, 176, 243, 243, 384], [386, 386, 519, 519, 1224], [1227, 1227, 1284, 1344, 2189]], "test": "valid"}
{"id": "ltdfzM", "name": "Flowing neon lines", "author": "Deadtotem", "description": "Trying to figure out how canvas and length command works, happy with the final approach. ", "tags": ["colors", "lines", "flow", "neon"], "likes": 2, "viewed": 221, "published": "Public", "date": "1539115685", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\t\t\tvec3 c;\n\t\t\t\tfloat time = iTime;\n\t\t\t\tfloat l;\n    \t\t\tvec2 res = iResolution.xy;\n\n    \t\t    vec3 color = 0.5 + 0.5*cos(time+vec3(2,4,4));\n    \n\t\t\t\tfor (int i=0;i<10;i++){\n\t\t\t\t\t \n                    \n\t\t\t\t\t\n\t\t\t\t\tvec2 uv;\n                    vec2 canvas = fragCoord.xy/res;\n\t\t\t\t\tcanvas.x *=res.x/res.y; \n                    \n\t\t\t\t\ttime+=0.175;\n\t\t\t\t\tl= length(canvas);\n                    l*=.22;\n\t\t\t\t\tuv+=canvas/l*(sin(time)+1.75)*abs(cos(l*19.-time*.17));\n                    \n                    c+=(.00175/length((mod(uv.x,sin(time*-.8)*1.85)-0.601)));\n\n\t\t\t\t}\n\n    // Output to screen\n    fragColor = vec4( c*color/l,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdfzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 682]], "test": "valid"}
{"id": "lttBDB", "name": "Fluffy Things", "author": "iq", "description": "Antother variation of Klem's shader [url]https://www.shadertoy.com/view/XlcfRs[/url]", "tags": ["procedural", "3d", "raymarching", "distancefield", "sdf"], "likes": 53, "viewed": 2922, "published": "Public API", "date": "1540980321", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2018\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n\nmat3 makeBase( in vec3 w )\n{\n\tfloat k = inversesqrt(1.0-w.y*w.y);\n    return mat3( vec3(-w.z,0.0,w.x)*k, \n                 vec3(-w.x*w.y,1.0-w.y*w.y,-w.y*w.z)*k,\n                 w);\n}\n\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in float rad )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h,-b+h);\n}\n\n// modified Keinert et al's inverse Spherical Fibonacci Mapping\nvec4 inverseSF( in vec3 p, in float n )\n{\n    const float PI = 3.14159265359;\n\tconst float PHI = 1.61803398875;\n\n    float phi = min(atan(p.y,p.x),PI);\n    float k   = max(floor(log(n*PI*sqrt(5.0)*(1.-p.z*p.z))/log(PHI+1.)),2.0);\n    float Fk  = pow(PHI,k)/sqrt(5.0);\n    vec2  F   = vec2(round(Fk),round(Fk*PHI));\n    vec2  G   = PI*(fract((F+1.0)*PHI)-(PHI-1.0));    \n    \n    mat2 iB = mat2(F.y,-F.x,G.y,-G.x)/(F.y*G.x-F.x*G.y);\n    vec2 c = floor(iB*0.5*vec2(phi,n*p.z-n+1.0));\n\n    float ma = 0.0;\n    vec4 res = vec4(0);\n    for( int s=0; s<4; s++ )\n    {\n        vec2 uv = vec2(s&1,s>>1);\n        float i = dot(F,uv+c);\n        float phi = 2.0*PI*fract(i*PHI);\n        float cT = 1.0 - (2.0*i+1.0)/n;\n        float sT = sqrt(1.0-cT*cT);\n        vec3 q = vec3(cos(phi)*sT, sin(phi)*sT,cT);\n        float a = dot(p,q);\n        if (a > ma)\n        {\n            ma = a;\n            res.xyz = q;\n            res.w = i;\n        }\n    }\n    return res;\n}\n\nfloat map( in vec3 p, out vec4 color, const in bool doColor )\n{\n    float lp = length(p);\n    float dmin = lp-1.0;\n    \n    \n    float pp = 0.5+0.5*sin(60.0*lp); pp *= pp; pp *= pp; pp *= pp; pp *= pp;\n    dmin = min(dmin,p.y+1.0+0.02*pp);\n    \n    \n\n    color = vec4(0.4,0.5,0.3,1.0)*0.9;\n    \n    float s = 1.0;\n    \n    //dmin = min( dmin,lp-2.15 );\n    \n    for( int i=0; i<2; i++ )\n    {\n        float h = float(i)/float(2-1);\n        \n        // Trick. Do not check the 2x2 neighbors, just snap to the\n        // closest point. This is wrong and produces discontinuities\n        // in the march, but it's okeish for the purposes of this shader\n        vec4 fibo = inverseSF(normalize(p), 65.0+35.0*h);\n        \n        // snap\n        p -= fibo.xyz;\n        \n        // orient to surface\n        p *= makeBase(normalize( fibo.xyz + 0.08*sin(fibo.y + 2.0*iTime + vec3(0.0,2.0,4.0))));\n\n        // scale\n        float scale = 7.0 + 3.0*sin(111.0*fibo.w);\n        if( i==0 ) scale += 4.0*(1.0-smoothstep(-0.5,-0.4,fibo.y));\n        scale *= 1.0 + 3.0*smoothstep(0.9,1.0,cos(0.25*iTime + fibo.w*141.7));\n        p *= scale;\n        \n        // translate and deform\n        p.z -= 2.3 + length(p.xy)*1.1*abs(sin(fibo.w*212.1));\n\n        //-----\n        \n        s *= scale;\n\t\t// distance to line segment/capsule \n        float d = length( p - vec3(0.0,0.0,clamp(p.z,-6.0,0.0)) ) - 0.1;\n        d /= s;\n\n        if( d<dmin )\n        {\n            if( doColor )\n            {\n                color.w *= smoothstep(0.0, 5.0/s, dmin-d);\n                if( i==0 ) color = vec4(0.4,0.5,0.4,1.0);\n                color.xyz += 0.3*(1.0-0.45*h)*sin(fibo.w*211.0+vec3(0.0,1.0,2.0));\n                color.xyz = max(color.xyz,0.0);\n            }\n            dmin = d;\n        }\n        else\n        {\n          color.w *= 0.4*(0.1 + 0.9*smoothstep(0.0, 1.0/s, d-dmin));\n        }\n    }\n    \n    return dmin;\n}\n\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float ep )\n{\n    vec4 kk;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep, kk, false ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep, kk, false ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep, kk, false ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep, kk, false ) );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmax, const float k )\n{\n    vec2 bound = sphIntersect( ro, rd, 2.15 );\n    tmax = min(tmax,bound.y);\n    \n\tfloat res = 1.0;\n    float t = 0.0;\n    //float t = max(0.0,bound.x);\n    for( int i=0; i<45; i++ )\n    {\n    \tvec4 kk;\n\t\tfloat h = map( ro + rd*t, kk, false );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float an = (iTime-10.0)*0.05 - 0.4;\n    \n    // camera\t\n    vec3 ro = vec3( 4.5*sin(an), 0.0, 4.5*cos(an) );\n    vec3 ta = vec3( 0.0, 0.2, 0.0 );\n    // camera-to-world transformation\n    mat3 ca = makeBase( normalize(ta-ro) );\n    \n    // render    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,2.3) );\n\n    // background\n    vec3 bak = vec3(0.1,0.14,0.18)*1.2 + 0.15*rd.y;\n\n    vec4 col = vec4(0.0);\n\n    // bounding volume\n    vec2 bound = sphIntersect( ro, rd, 2.15 );\n    if( bound.x>0.0 )\n    {\n        // raymarch\n        vec4 kk;\n        float t = bound.x;\n        for( int i=0; i<350; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            \n            // evaluate distance\n            vec4 mate;\n            float h = map(pos,mate,true);\n\n            // color contribution            \n            float px = t*0.012;\n            if( h<px )\n            {\n                // surface normal                \n                vec3 nor = calcNormal(pos, px*0.5);\n\n                // start lighting                \n                vec3 lcol = vec3(0.0);\n\n                // key ligh\n                {\n                    //dif\n                    vec3 lig = normalize(vec3(1.0,1.0 ,0.7));\n                    float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\n                    float sha = calcSoftshadow( pos+0.01*lig, lig, 2.0, 6.0 );\n                    lcol += mate.xyz*dif*vec3(3.0,0.7,0.5)*1.2*vec3(sha,sha*0.3+0.7*sha*sha,sha*sha);\n                    // spec\n                    vec3 hal = normalize(lig-rd);\n                    float spe = clamp( dot(nor,hal), 0.0, 1.0 );\n                    float fre = clamp( dot(-rd,lig), 0.0, 1.0 );\n                    fre = 0.05 + 0.95*pow(fre,5.0);\n                    spe *= spe; spe *= spe;\n                    col += 1.0*spe*dif*sha*fre*mate.w;\n                }\n\n                // back light\n                {\n                    vec3 lig = normalize(vec3(-1.0,0.0,0.0));\n                    float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\n                    lcol += mate.rgb*dif*vec3(1.0,0.9,0.6)*0.06*mate.w;\n                }\n\n                // dome light\n                {\n                    float dif = clamp(0.3+0.7*nor.y,0.0,1.0);\n                    lcol += mate.xyz*dif*1.0*vec3(0.1,0.2,0.4)*mate.w*(0.2+0.8*mate.w);\n                }\n\n                // fake sss\n                {\n                    float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n                    lcol += 0.8*vec3(1.0,0.3,0.2)*mate.xyz*mate.xyz*fre*fre*mate.w;\n                    //lcol += 0.2*mate.xyz*mate.xyz*fre*fre*mate.w;\n                }\n\n                // grade\n                lcol = 0.85*pow( lcol, vec3(0.75,0.9,1.0) );\n            \n\n                // composite front to back\n                float al = clamp(1.0-h/px,0.0,1.0);\n                lcol.rgb *= al;\n    \t\t\tcol = col + vec4(lcol,al)*(1.0-col.a);\n                if( col.a>0.995 || abs(h)<0.0001 ) break;\n            }\n\n\n            // march ray            \n            t += h*0.5;\n            if( t>bound.y ) break;\n            //if( col.a>0.995 || abs(h)<0.0001 || t>bound.y ) break;\n        }\n    }\n\n\n    // composite with background    \n    vec3 tot = bak*(1.0-col.w) + col.xyz;\n\n    // gain\n    tot *= 0.7 + 0.3*smoothstep( 0.0, 15.0, abs(iTime-25.0) );\n    \n    // gamma\n    tot = pow( tot, vec3(0.4545) );\n\n\n    // vignetting\n \tvec2 q = fragCoord/iResolution.xy;\n    tot *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\n\n    // output    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lttBDB.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[597, 597, 625, 625, 781], [783, 851, 910, 910, 1068], [1070, 1134, 1175, 1175, 2089], [3994, 4058, 4103, 4103, 4365], [4367, 4429, 4504, 4504, 4902], [4904, 4904, 4961, 4961, 8546]], "test": "error"}
{"id": "lttBDH", "name": "warp sphere", "author": "MonterMan", "description": "domain warpped sphere", "tags": ["fbmwarp"], "likes": 14, "viewed": 404, "published": "Public", "date": "1539543818", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(in vec3 p)\n{\n    p = fract(p * vec3(821.35, 356.17, 671.313));\n    p += dot(p, p+23.5);\n    return fract(p.x*p.y*p.z);\n}\n\nfloat noise(in vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    \n    float a = hash(ip + vec3(0, 0, 0));\n    float b = hash(ip + vec3(1, 0, 0));\n    float c = hash(ip + vec3(0, 1, 0));\n    float d = hash(ip + vec3(1, 1, 0));\n    float e = hash(ip + vec3(0, 0, 1));\n    float f = hash(ip + vec3(1, 0, 1));\n    float g = hash(ip + vec3(0, 1, 1));\n    float h = hash(ip + vec3(1, 1, 1));\n    \n    vec3 t = smoothstep(vec3(0), vec3(1), fp);\n    return mix(mix(mix(a, b, t.x), mix(c, d, t.x), t.y),\n               mix(mix(e, f, t.x), mix(g, h, t.x), t.y), t.z);\n}\n\nfloat fbm(in vec3 p)\n{   \n    float res = 0.0;\n    float amp = 0.5;\n    float freq = 2.0;\n    for (int i = 0; i < 5; ++i)\n    {\n        res += amp * noise(freq * p);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return res;\n}\n\nfloat bi_fbm(in vec3 p)\n{\n    return 2.0 * fbm(p) - 1.0;\n}\n\nvec3 warp(in vec3 p)\n{\n    p = p + bi_fbm(0.4*p + mod(0.5*iTime, 100.0));\n    p = p + bi_fbm(0.4*p - mod(0.3*iTime, 100.0));\n    return p;\n}\n\nfloat map(in vec3 p)\n{\n    p = mix(p, warp(p), 0.5 * (1.0 + cos(iTime)));\n    return 0.5 * (length(p) - 1.0);\n}\n\nvec3 map_n(in vec3 p)\n{\n    vec2 e = vec2(0, 0.001);\n    return normalize(vec3(map(p + e.yxx), map(p + e.xyx), map(p + e.xxy)) - map(p));\n}\n\nvec3 color_map(in float t)\n{\n    vec3 a = vec3(1, 0, 0);\n    vec3 b = vec3(1, 0.3, 0);\n    vec3 c = vec3(1, 0.7, 0);\n    vec3 d = vec3(1, 0.3, 0);\n    \n    if (t < 0.333)\n    {\n        return mix(a, b, 3.0*t);\n    }\n    else if (t < 0.666)\n    {\t\n        return mix(b, c, 3.0*(t - 0.3333));\n    }\n    else\n    {\n        return mix(c, d, 3.0*(t - 0.6666));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 at = vec3(0);\n    vec3 ro = vec3(0, 0, -3);\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0,1,0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(cam_x * uv.x + cam_y * uv.y + 1.73 * cam_z);\n    \n    int iter = 0;\n    int matid = -1;\n    float t = 0.001;\n    float t_max = 20.0;\n    for (int i = 0; i < 256; ++i)\n    {\n        if (t > t_max) break;\n        \n        float d = map(ro + t*rd);\n        if (d < 0.001)\n        {\n            matid = 0;\n            iter = i;\n            break;\n        }\n        t += d;\n    }\n    \n    float occ = 1.0 - float(iter) / 256.0;\n    \n    vec3 sky = vec3(0.6, 0.7, 0.8);\n    vec3 col = sky;\n    if (matid != -1)\n    {\n        vec3 p = ro + t*rd;\n        vec3 n = map_n(p);\n        vec3 l = normalize(vec3(0.5, 0.4, -0.5));\n        vec3 sun = vec3(1.5);\n        vec3 albedo = vec3(0.9) * color_map(fbm(warp(p)));\n        \n        vec3 direct_light = max(0.0, dot(n, l)) * sun;\n        vec3 indirect_light = pow(occ, 10.0) * (0.2 * sky);\n        \n        col = (indirect_light + direct_light) * albedo;\n    }\n    \n    col = 1.0-exp(-col);\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lttBDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 131], [133, 133, 157, 157, 704], [706, 706, 728, 728, 936], [938, 938, 963, 963, 996], [998, 998, 1020, 1020, 1138], [1140, 1140, 1162, 1162, 1251], [1253, 1253, 1276, 1276, 1392], [1394, 1394, 1422, 1422, 1757], [1759, 1759, 1816, 1816, 3103]], "test": "valid"}
{"id": "lttBzM", "name": "Transformations & CSG", "author": "GraphicsFromScratch", "description": "trans & csg", "tags": ["csg"], "likes": 3, "viewed": 142, "published": "Public", "date": "1539112201", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nfloat sdf(in vec3 p, out int matid)\n{\n    vec2 c = vec2(sin(iTime) + 2.5);\n\tp.xz = mod(p.xz, c) - 0.5 * c;\n    \n    float sphere_sdf = length(p - vec3(0, 1, 0)) - 1.0;\n    float box_sdf = sdBox(p - vec3(0, 1, 0), vec3(0.8));\n    float obj_sdf = max(-sphere_sdf, box_sdf);\n    float floor_sdf = abs(p.y);\n    \n    float sdf = min(obj_sdf, floor_sdf);\n    if (sdf == obj_sdf)\n    {\n        matid = 1;\n    }\n    else\n    {\n        matid = 0;\n    }\n    \n    return sdf;\n}\n\nvec3 sdf_n(in vec3 p)\n{\n    vec3 res = vec3(0);\n    \n    int ignored;\n    res.x = sdf(p + vec3(0.001, 0, 0), ignored) - sdf(p, ignored);\n    res.y = sdf(p + vec3(0, 0.001, 0), ignored) - sdf(p, ignored);\n    res.z = sdf(p + vec3(0, 0, 0.001), ignored) - sdf(p, ignored);\n    \n    return normalize(res);\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, out int matid)\n{\n\tfloat t = 0.0;\n    matid = -1;\n    for (int i = 0; i < 256; ++i)\n    {\n        int curr_matid = -1;\n\t\tfloat d = sdf(ro + t*rd, curr_matid);\n        if (d < 0.0001)\n        {\n            matid = curr_matid;\n            break;\n        }\n        t += d;\n    }\n    return t;\n}\n\nfloat shadow(in vec3 p, in vec3 l)\n{\n    float t = 0.15;\n    float t_max = 20.0;\n    \n    float res = 1.0;\n    for (int i = 0; i < 256; ++i)\n    {\n        if (t > t_max) break;\n        \n        int ignored;\n        float d = sdf(p + t*l, ignored);\n        if (d < 0.01)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 8.0 * d / t);\n    }\n    \n    return res;\n}\n\nfloat ao(in vec3 p, in vec3 n)\n{\n    float e = 0.1;\n    float res = 0.0;\n    \n#define AO_ITER 5\n    \n    int ignored;\n    float weight = 0.5;\n    for (int i = 1; i <= AO_ITER; ++i)\n    {\n        float d = e * float(i);\n        res += weight * (1.0 - (d - sdf(p + d * n, ignored)));\n        weight *= 0.5;\n    }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float cam_d = 3.0;\n    float time = 0.3 * iTime;\n    vec3 ro = vec3(cam_d*sin(time), 2.5, cam_d*cos(time));\n    vec3 at = vec3(0, 1, 0);\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0,1,0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 1.73 * cam_z);\n\t\n    vec3 col = vec3(0);\n    \n    int matid = -1;\n    float t = intersect(ro, rd, matid);\n    if (matid != -1)\n    { \n        vec3 l = normalize(vec3(0.5, 0.5, -0.2));\n        vec3 n = sdf_n(ro + t*rd);\n        vec3 sun_light = vec3(1);\n        float projected_ratio = max(0.0, dot(l, n));\n        vec3 direct_light = shadow(ro + t*rd, l) * sun_light * projected_ratio;\n        vec3 indirect_light = ao(ro + t*rd, n) * vec3(0.3);\n        \n        vec3 albedo = vec3(0.9);      \n\t\tcol = albedo * (0.7 * direct_light + indirect_light);\n        \n        col = mix(col, vec3(0), pow(t / 30.0, 2.0));\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lttBzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 118], [120, 120, 155, 155, 200], [202, 202, 239, 239, 669], [671, 671, 694, 694, 975], [977, 977, 1033, 1033, 1307], [1309, 1309, 1345, 1345, 1704], [1706, 1706, 1738, 1738, 2039], [2041, 2041, 2098, 2098, 3179]], "test": "valid"}
{"id": "lttBzN", "name": "impulse_glass", "author": "mrange", "description": "Messing around with refractions. I am quite new to shader programming\n  and raymarching so while I think the code might not be very good I also think that\n  what makes ShaderToy.com so good is that programmers are sharing what they do, \n  big and small.", "tags": ["glass"], "likes": 128, "viewed": 5142, "published": "Public API", "date": "1538908235", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by mrange/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// Messing around with refractions. I am quite new to shader programming\n//  and raymarching so while I think the code might not be very good I also think that\n//  what makes ShaderToy.com so good is that programmers are sharing what they do, \n//  big and small. I too want to share in the hope it might help someone on my level.\n// \n// Inpiration and code from shaders:\n//  https://www.shadertoy.com/view/4ds3zn (iq, inspirations and various functions)\n//  https://www.shadertoy.com/view/XljGDz (otaviogood, \"skybox\")\n//  https://www.shadertoy.com/view/Xl2GDW (purton, inspiration for reflection)\n// Music: Levi Patel - As she passes (Soundcloud)\n// Blogs:\n//  Raymarching explained: http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\n//  Distance Estimators: www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//  Cool primitives: http://mercury.sexy/hg_sdf/\n\n#define TOLERANCE       0.000001\n#define MAX_RAY_LENGTH  16.0\n#define MAX_BOUNCES     8\n#define MAX_RAY_MARCHES 90\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n#define DEG2RAD         (PI/180.0)\n\n#define PERIODTIME      25.0\n#define FADETIME        4.0\n\n#define TIMEINPERIOD    (mod(iTime, PERIODTIME))\n#define PERIOD          (mod(floor(iTime / PERIODTIME), 9.0))\n//#define PERIOD          8\n\n#define AA              0\n\nfloat sgn(float x)\n{\n  return (x<0.0)?-1.0:1.0;\n}\n\nfloat smin(float a, float b, float k)\n{\n  float res = exp( -k*a ) + exp( -k*b );\n  return -log( res )/k;\n}\n\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset)\n{\n  float t = dot(p, planeNormal)+offset;\n  if (t < 0.0)\n  {\n    p = p - (2.0*t)*planeNormal;\n  }\n  return sgn(t);\n}\n\nvoid pR(inout vec2 p, float a)\n{\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat maxComp(in vec3 p)\n{\n  return max(p.x,max(p.y,p.z));\n}\n\nfloat lengthN(in vec3 v, in float n)\n{\n  v = abs(v);\n  v = pow(v, vec3(n));\n  return pow(v.x + v.y + v.z, 1.0/n);\n}\n\nfloat sdRoundCube(in vec3 p, float r)\n{\n  return lengthN(p, 8.0) - r;\n}\n\nvec3 pMod3(inout vec3 p, vec3 size)\n{\n  vec3 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5, size) - size*0.5;\n  return c;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3  di = abs(p) - b;\n  float mc = maxComp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n  return length(p) - r;\n}\n\nfloat impulse1(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.3);\n  ref    = 0.2;\n  trans  = 0.9;\n  absorb = 0.5*vec3(1.0, 2.0, 3.0);\n\n  float s  = sdSphere(p, 0.6);\n  float is = sdSphere(p, 0.8);\n  float rc = sdRoundCube(p, 1.0);\n\n  float d = rc;\n  d = max(d, -is);\n  d = min(d, s);\n  if (d == s)\n  {\n    absorb = 1.0*vec3(1.0, -1.0, -2.0);\n  }\n  return d;\n}\n\nfloat impulse2(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.3);\n  ref    = 0.2;\n  trans  = 0.9;\n  absorb = 0.5*vec3(1.0, 2.0, 3.0);\n\n  float s1 = sdBox(p, vec3(1.0));\n  float s3 = sdSphere(p, 0.4);\n  pMod3(p, vec3(1.0));\n  float s2 = sdSphere(p, 0.48);\n  float s = max(s1, -s2);\n  s = min(s, s3);\n  if (s == s3)\n  {\n    absorb = 1.0*vec3(1.0, -1.0, -2.0);\n  }\n\n  return s;\n}\n\nfloat mandelbulb(in vec3 p)\n{\n  vec3 w = p;\n  float m = dot(w,w);\n\n  float dz = 1.0;\n\n  dz = 8.0*pow(sqrt(m),7.0)*dz + 1.0;\n\n  float r = length(w);\n  float b = 8.0*acos(w.y/r);\n  float a = 8.0*atan(w.x, w.z);\n  vec3 v  = vec3(sin(b)*sin(a), cos(b), sin(b)*cos(a));\n  w = p + pow(r,8.0)*v;\n\n  m = dot(w,w);\n\n  return 0.25*log(m)*sqrt(m)/dz;\n}\n\n\nfloat impulse3(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.3);\n  ref    = 0.2;\n  trans  = 0.9;\n  absorb = 0.5*vec3(1.0, 2.0, 3.0);\n\n  float rc = sdRoundCube(p, 1.0);\n  float s  = 0.9;\n  float mb = mandelbulb(p/s)*s;\n  float s1 = sdSphere(p, 0.4);\n  float d = rc;\n  d = max(d, -mb);\n  d = min(d, s1);\n  if (d == s1)\n  {\n    absorb = 1.0*vec3(1.0, -1.0, -2.0);\n  }\n  return d;\n}\n\nfloat bubbles(in vec3 p)\n{\n  vec3 pp = p - vec3(0.1) - vec3(0.0, iTime*0.15 + 10.0, 0.0);\n  pReflect(pp, normalize(vec3(1.0, 0.5, 0.2)), 0.3);\n  pReflect(pp, normalize(vec3(0.2, 0.5, 1.0)), 0.2);\n  pMod3(pp, vec3(0.5, 0.3, 0.4));\n\n  vec3 ppp = p - vec3(0.2) - vec3(0.0, iTime*0.05 + 10.0, 0.0);\n  pReflect(ppp, normalize(vec3(0.7, 0.5, 0.4)), 0.3);\n  pReflect(ppp, normalize(vec3(0.5, 0.4, 0.7)), 0.1);\n  pMod3(ppp, vec3(0.7, 0.6, 0.4));\n\n  float ss = sdSphere(pp, 0.05);\n  float sss = sdSphere(ppp, 0.1);\n\n  return smin(ss, sss, 20.0);\n}\n\nfloat impulse4(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.3);\n  ref    = 0.2;\n  trans  = 0.9;\n  absorb = 0.5*vec3(1.0, 2.0, 3.0);\n\n  float sb = sdRoundCube(p, 1.0);\n  float s = 2.5;\n  float bs = bubbles(p/s)*s;\n\n  return max(sb, -bs);\n}\n\nfloat impulse5(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.3);\n  ref    = 0.2;\n  trans  = 0.9;\n  absorb = 0.5*vec3(1.0, 2.0, 3.0);\n\n  float sb = sdRoundCube(p, 1.0);\n  float t  = TIMEINPERIOD;\n  float s  = 2.5 / (1.0 + 4.0*t/PERIODTIME);\n  float bs = bubbles(p/s)*s;\n\n  return max(sb, -bs);\n}\n\n\nfloat distanceField(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  int period = int(PERIOD);\n  float i = 10000000.0;\n  if (period == 0)      i = impulse1(p, col, ref, trans, absorb);\n  else if (period == 1) i = impulse2(p, col, ref, trans, absorb);\n  else if (period == 2) i = impulse4(p, col, ref, trans, absorb);\n  else if (period == 3) i = impulse3(p, col, ref, trans, absorb);\n  else if (period == 4) i = impulse2(p, col, ref, trans, absorb);\n  else if (period == 5) i = impulse3(p, col, ref, trans, absorb);\n  else if (period == 6) i = impulse2(p, col, ref, trans, absorb);\n  else if (period == 7) i = impulse5(p, col, ref, trans, absorb);\n  else if (period == 8) i = impulse1(p, col, ref, trans, absorb);\n\n  float rc = sdRoundCube(p - vec3(0.0, -5.05, 0.0), 4.0);\n\n  float d = min(rc, i);\n  if (d == rc)\n  {\n    col    = vec3(1.0);\n    ref    = 0.2;\n    trans  = 0.0;\n  }\n  return d;\n}\n\nvec3 saturate(in vec3 a)   { return clamp(a, 0.0, 1.0); }\nvec2 saturate(in vec2 a)   { return clamp(a, 0.0, 1.0); }\nfloat saturate(in float a) { return clamp(a, 0.0, 1.0); }\n\nconst vec3 lightPos1 = 100.0*vec3(-0.3, 0.0, 1.0);\nconst vec3 lightPos2 = 100.0*vec3(-0.5, -0.1, -1.2);\n\nconst vec3 lightCol1 = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\nconst vec3 lightCol2 = vec3(8.0/8.0,6.0/8.0,7.0/8.0);\n\nvec3 getSkyColor(vec3 rayDir)\n{\n  vec3 lightDir1 = normalize(lightPos1);\n  vec3 lightDir2 = normalize(lightPos2);\n\n  float ld1      = max(dot(lightDir1, rayDir), 0.0);\n  float ld2      = max(dot(lightDir2, rayDir), 0.0);\n  vec3 final     = vec3(0.125);\n\n  if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n  float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n  final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n\n  final += pow(lightCol1, vec3(2.0, 1.5, 1.5)) * pow(ld1, 8.0);\n  final += lightCol1 * pow(ld1, 200.0);\n  final += pow(lightCol2, vec3(2.0, 1.5, 1.5)) * pow(ld2, 8.0);\n  final += lightCol2 * pow(ld2, 200.0);\n  return final;\n}\n\nvec3 normal(in vec3 pos)\n{\n  vec3  eps = vec3(.0001,0.0,0.0);\n  vec3 col;\n  float ref;\n  float trans;\n  vec3 nor;\n  vec3 absorb;\n  nor.x = distanceField(pos+eps.xyy, col, ref, trans, absorb) - distanceField(pos-eps.xyy, col, ref, trans, absorb);\n  nor.y = distanceField(pos+eps.yxy, col, ref, trans, absorb) - distanceField(pos-eps.yxy, col, ref, trans, absorb);\n  nor.z = distanceField(pos+eps.yyx, col, ref, trans, absorb) - distanceField(pos-eps.yyx, col, ref, trans, absorb);\n  return normalize(nor);\n}\n\nfloat rayMarch(in float dmod, in vec3 ro, inout vec3 rd, float mint, float minstep, out int rep, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  float t = mint;\n  for (int i = 0; i < MAX_RAY_MARCHES; i++)\n  {\n    float distance_ = distanceField(ro + rd*t, col, ref, trans, absorb);\n    float distance = dmod*distance_;\n    if (distance < TOLERANCE*t || t > MAX_RAY_LENGTH) break;\n    t += max(distance, minstep);\n    rep = i;\n  }\n  return t;\n}\n\nfloat softShadow(in vec3 pos, in vec3 ld, in float ll, float mint, float k)\n{\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  vec3 col;\n  float ref;\n  float trans;\n  vec3 absorb;\n  for (int i=0; i<24; i++)\n  {\n    float distance = distanceField(pos + ld*t, col, ref, trans, absorb);\n    res = min(res, k*distance/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, distance);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)\n{\n  col=pow(clamp(col,0.0,1.0),vec3(0.75));\n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n  vec3 lightPos = 1.5*vec3(1.5, 3.0, 1.0);\n\n  vec3 final  = vec3(0.0);\n\n  vec3 ragg   = vec3(1.0);\n\n  float tdist = 0.0;\n\n  int period = int(PERIOD);\n\n  float refraction = 0.9;\n\n  if (period == 4) refraction = 1.2;\n  if (period == 5) refraction = 0.75;\n  if (period == 6) refraction = -0.8;\n\n  bool inside = false;\n\n  float mint    = 0.01;\n  float minstep = 0.001;\n\n  for (int i = 0; i < MAX_BOUNCES; ++i)\n  {\n    if (maxComp(ragg) <  0.01) break;\n    float dmod  = inside ? -1.0 : 1.0;\n    vec3 absorb ;\n    vec3 col    ;\n    float ref   ;\n    float trans ;\n    int rep     ;\n    float t     = rayMarch(dmod, ro, rd, mint, minstep, rep, col, ref, trans, absorb);\n    tdist       += t;\n\n    vec3 pos    = ro + t*rd;\n\n    vec3 nor = vec3(0.0, 1.0, 0.0);\n\n    if (t < MAX_RAY_LENGTH)\n    {\n      // Ray intersected object\n      nor = normal(pos);\n    }\n    else\n    {\n      // Ray intersected sky\n      final += ragg*getSkyColor(rd);\n      break;\n    }\n\n    float fresnel = pow(1.0 - abs(dot(nor, rd)), 2.0);\n\n    ref = mix(ref, 1.0, fresnel);\n    trans = mix(trans, 0.0, fresnel);\n\n    float mref = refraction;\n\n    if (inside)\n    {\n      nor = -nor;\n      mref = 1.0/refraction;\n    }\n\n    vec3 refl = reflect(rd, nor);\n    vec3 refr = refract(rd, nor, mref);\n\n    vec3 lv   = lightPos - pos;\n    vec3  ld  = normalize(lv);\n    float ll  = length(lv);\n    // TODO: Rework shadow to \"work\" with transparent objects\n    float sha = 1.0;\n    if (!inside)\n    {\n      sha = softShadow(pos, ld, ll, 0.01, 64.0);\n    }\n\n    float dif = max(dot(nor,ld),0.0);\n    float occ = 1.0 - float(rep)/float(MAX_RAY_MARCHES);\n    float l   = dif*sha*occ;\n\n\n    vec3 lr   = vec3(0.0);\n\n    float lin = mix(0.2, 1.0, l);\n\n    vec3 sky  = getSkyColor(refl);\n    vec3 mcol = mix(lin*col + lr, sky, ref);\n\n    vec3 beer = vec3(1.0);\n\n    if (inside)\n    {\n      beer = exp(-absorb*t);\n    }\n    final      += (1.0 - trans)*ragg*beer*mcol;\n    ragg       *= trans*beer;\n\n    ro        = pos;\n\n    if (refr == vec3(0.0))\n    {\n        rd = refl;\n    }\n    else\n    {\n      rd = refr;\n      inside = !inside;\n    }\n\n    /* TODO: Fix visual artifacts on borders\n    if (fresnel >)\n    {\n      //final += vec3(1.0);\n      mint = 0.1;\n      minstep = 0.01;\n    }\n    else\n    {\n      minstep = 0.001;\n    }\n    */\n  }\n\n\n  return final;\n}\n\nvec3 getSample(in vec2 p)\n{\n  float time   = TIMEINPERIOD;\n  int period   = int(PERIOD);\n\n  vec3 ro  = vec3(3.0, 0.1, 0.0);\n  if (period == 5) ro = 1.5*vec3(1.0, 1.5, 0.0);\n  if (period == 8) ro += 3.0*vec3(smoothstep(FADETIME, PERIODTIME, time));\n\n  vec3 la  = vec3(0.0);\n\n  pR(ro.xz, iTime/PERIODTIME);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n  vec3 col = render(ro, rd);\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  float time = TIMEINPERIOD;\n  vec2 q=fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n#if AA == 0\n  vec3 col = getSample(p);\n#elif AA == 1\n  vec3 col  = vec3(0.0);\n  vec2 unit = 1.0/iResolution.xy;\n  for(int y = 0; y < 2; ++y)\n  {\n    for(int x = 0; x < 2; ++x)\n    {\n      col += getSample(p - 0.5*unit + unit*vec2(x, y));\n    }\n  }\n\n  col /= 4.0;\n#endif\n\n  float whiteIn  = 1.0 - smoothstep(0.0, FADETIME, time);\n  float whiteOut = smoothstep(PERIODTIME - FADETIME, PERIODTIME, time);\n\n  if (iTime > PERIODTIME*9.0) whiteOut = 1.0;\n\n  fragColor = vec4(mix(postProcess(col, q), vec3(1.0), whiteOut + whiteIn), 1.0);\n}\n", "image_inputs": [{"id": "4lfGRn", "previewfilepath": "https://soundcloud.com/levipatel/as-she-passes", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/levipatel/as-she-passes", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lttBzN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1464, 1464, 1484, 1484, 1513], [1515, 1515, 1554, 1554, 1621], [1623, 1623, 1685, 1685, 1800], [1802, 1802, 1834, 1834, 1877], [1879, 1879, 1905, 1905, 1939], [1941, 1941, 1979, 1979, 2056], [2058, 2058, 2097, 2097, 2129], [2131, 2131, 2168, 2168, 2263], [2265, 2265, 2294, 2294, 2385], [2387, 2387, 2420, 2420, 2446], [2448, 2448, 2538, 2538, 2854], [2856, 2856, 2946, 2946, 3279], [3281, 3281, 3310, 3310, 3622], [3625, 3625, 3715, 3715, 4051], [4053, 4053, 4079, 4079, 4591], [4593, 4593, 4683, 4683, 4880], [4882, 4882, 4972, 4972, 5224], [5227, 5227, 5322, 5322, 6149], [6151, 6151, 6179, 6179, 6208], [6209, 6209, 6237, 6237, 6266], [6267, 6267, 6295, 6295, 6324], [6540, 6540, 6571, 6571, 7272], [7274, 7274, 7300, 7300, 7780], [7782, 7782, 7943, 7943, 8244], [8246, 8246, 8323, 8323, 8716], [8718, 8718, 8760, 8760, 9008], [9010, 9010, 9047, 9047, 11358], [11360, 11360, 11387, 11387, 11886], [11888, 11888, 11943, 11943, 12607]], "test": "valid"}
{"id": "lttfR8", "name": "background fan", "author": "morimea", "description": "just random background", "tags": ["2d", "background"], "likes": 9, "viewed": 550, "published": "Public API", "date": "1538718193", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// License - CC0 or use as you wish\n\n#define MD(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n#define PI (4.0 * atan(1.0))\n#define TWO_PI PI*2.\n\nconst vec3 green_ = vec3(0x58, 0x8b, 0x8c) / float(0xff);\nconst vec3 green2 = vec3(0x22, 0x2e, 0x2a) / float(0xff);\nconst vec3 white_ = vec3(0xe3, 0xe4, 0xdf) / float(0xff);\nconst vec3 black_ = vec3(0x84, 0x82, 0x85) / float(0xff);\n\nvec3 background_col(vec2 p){\n    if(p.y>0.35) return smoothstep(0.55,0.4,p.y)*green_;\n    return white_;\n}\n\nvec3 background_black(vec2 p){\n    return smoothstep(0.,-0.5,p.y)*black_;;\n}\n\nfloat xRandom(float x) {\n    return fract(dot(sin(x * 591.32 ), cos(x * 391.32 )));\n}\n\n//using http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\n//layer 1\nfloat l1(vec2 p){\n    vec2 res = vec2(16./9.,1.);\n    vec2 op=p;\n    p=vec2((mod(floor(op.y/(1.))*.689+op.x,res.x/2.)-res.x/1.9),mod(op.y,1.)-1./2.);\n    float d;\n    d=smoothstep(0.005,0.01,sdLine(p,vec2(-res.x/2.,-0.5),vec2(-res.x/2.+0.2,0.5)));\n    d=min(d,smoothstep(0.005,0.01,sdLine(p,vec2(-res.x/2.+0.3,-0.5),vec2(-res.x/2.+0.5,0.5))));\n    d=min(d,smoothstep(0.0,0.008,sdLine(p,vec2(-res.x/2.+0.325,-0.5),vec2(-res.x/2.+0.525,0.5))));\n    p=vec2(mod(op.x,res.x),mod(floor(op.x/(res.x))*0.25+op.y,0.4)-0.4*1.5);\n    d=min(d,smoothstep(0.005,0.01,sdLine(p,vec2(-res.x,-0.),vec2(res.x,-0.5))));\n    return d;\n}\n\n//layer 2\nfloat l2(vec2 p){\n    vec2 op=p;\n    float d;\n    p.x=mod(p.x,0.5)-0.5/2.;\n    p.y+=-0.051;\n    d=smoothstep(0.025,0.03,sdLine(p,vec2(0.,0.3),vec2(-0.4,0.6)));\n    d=min(d,smoothstep(0.015,0.02,sdLine(p,vec2(0.,0.3),vec2(0.4,0.6))));\n    d=min(d,smoothstep(0.015,0.02,sdLine(p,vec2(-0.02,0.34),vec2(0.38,0.64))));\n    p=op;\n    d*=step(0.4,p.y);\n    \n    p.x=mod(p.x+0.35,0.7)-0.7/2.;\n    d=max(d,smoothstep(0.01,0.005,sdCircle(p,0.28)));\n    \n    //p=op;\n    \n    d=min(d,smoothstep(0.005,0.01,sdCircle(p,0.123)));\n    \n    vec2 res = iResolution.xy / iResolution.y;\n    //fan speed\n    //p*=MD(mod(iTime*8.*(0.5-xRandom(floor((op.x+(0.35))/0.7))),TWO_PI));\n    p*=MD(mod(iTime*3.*((1.+0.2*floor(mod(((op.x+(0.35))/(0.7)),3.)))*.5-\n                        (1.-0.2*floor(mod(((op.x+(0.35))/(0.7)),5.)))*\n                        min(clamp(floor(mod(((op.x+(0.35*3.))/(0.7*3.)),2.))-\n                                     floor(mod(((op.x+(0.35))/(0.7)),2.)),-1.,1.),\n                            floor(mod(((op.x+(0.35*3.))/(0.7*3.)),2.)))),\n              TWO_PI));\n    float a = atan(p.x,p.y);\n    float r = length(p);\n    p = vec2(a/(TWO_PI),r);\n \tp = (1.0 * p) - vec2(0.5,0.42);\n    p.xy=p.yx;\n    p.y=mod(p.y,0.142)-0.142/2.;\n    d=min(d,smoothstep(0.007,0.01,\n                       sdBox(p+vec2(0.142+0.068,0.), //circle radius 0.123+fan borders=0.142\n                             vec2(0.068,0.025))));\n    d=min(d,smoothstep(0.005,0.01,sdBox(p+vec2(0.242+0.068,0.),vec2(0.068,0.0125))));\n    \n    return d;\n}\n\n//layer 3\nfloat l3(vec2 p){\n    float d;\n    d=smoothstep(0.005,0.0,abs(p.y+0.38));\n    p.x=mod(p.x,0.025)-0.025/2.;\n    if(p.y<-0.38)\n    d=max(d,smoothstep(0.005,0.0,abs(p.x)));\n    return d;\n}\n\nvec3 map_bg(vec2 p){\n    p.x+=iTime/15.; //scroll speed\n    vec2 op=p;\n    float d=l1(p);\n    vec3 col;\n    p=(op+1.)*MD(-.32);\n    d=min(d,l1(p));\n    p=op;\n    col=d*background_col(p);\n    d=min(d,l2(p));\n    col=mix(col,background_black(p),1.-d);\n    p=op;\n    p.x+=iTime/60.; //scroll speed 2\n    d=l3(p);\n    col=mix(col,green2,d);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n    vec2 uv = (fragCoord.xy) / iResolution.y - res/2.0;\n    //uv*=2.0;\n    vec3 col;\n    \n    col = map_bg(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lttfR8.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[375, 375, 403, 403, 481], [483, 483, 513, 513, 559], [561, 561, 585, 585, 646], [648, 731, 780, 780, 899], [901, 901, 936, 936, 962], [964, 964, 1001, 1001, 1085], [1087, 1097, 1114, 1114, 1712], [1714, 1724, 1741, 1741, 3236], [3238, 3248, 3265, 3265, 3433], [3435, 3435, 3455, 3455, 3789], [3791, 3791, 3848, 3848, 4065]], "test": "error"}
{"id": "lttfRX", "name": "quadtree truchet many rings", "author": "abje", "description": "i made this trying to copy shane's [url=https://www.shadertoy.com/view/XttBW7]Tri Scale Truchet[/url].", "tags": ["truchet", "quadtree"], "likes": 9, "viewed": 439, "published": "Public API", "date": "1540575020", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define HASHSCALE3 vec3(.6531, .5563, .7498)\n\n//subdivision limit\n#define limit 3.0\n#define thickness 0.01\n//how many subdivisions\n#define subs 0.4\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(10.0*fract((p3.x + p3.y) * p3.z*15.3023+0.434));\n}\n\nvec2 repeat(float a, float b) {\n    return vec2(mod(a,b),mod(-a,b));\n}\n\nfloat ripple(vec2 p, float rep) {\n    p -= max(dot(p,vec2( 1,1)),0.0);\n    p -= max(dot(p,vec2(-1,1)),0.0)*vec2(-1,1);\n    \n    float l0 = length(p+0.5);\n    \n    float l2 = floor(l0/rep);\n    \n    vec2 lens = repeat(l0+rep*0.5,rep);\n    \n    float len = 1.0;\n    \n    float s = rep*(0.5+l2);\n    \n    float a = s*s-0.5;\n    if (a > 0.0)\n    {\n        vec2 p1 = sqrt(a*0.5)*vec2(1,-1);\n        \n        vec2 p2=p1+0.5;\n        \n        if (dot(vec2(-p2.y,p2.x),p+0.5)>0.0)\n        {\n            lens.y = length(p-p1);\n        }\n    }\n    \n    return min(lens.x,lens.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float T = iTime*0.1;\n    //normalize fragCoord to uv\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y\n    //some random movement stuff\n        +vec2(sin(T*6.28*exp2(-T)),cos(T*6.28*exp2(-T)))*T*4.0;\n\t\n    //lp is position in cell from 0 to 1\n    vec2 lp = fract(uv);\n    //fp is cell's bottom left corner position\n    vec2 fp = floor(uv);\n    //i is quadtree subdivisions\n    float i;\n    //size is the size of the quadtree cell\n    float size = 1.0;\n    //this is the quadtree loop, finds where the pixel lands on the quadtree\n    for (i = 0.0; i < limit; i++) {\n        //breaks randomly out of the loop (creates a random quadtree)\n        float rand = hash13(vec3(fp,i));\n        if (rand > subs||i==limit) {\n            break;\n        }\n        \n        //doubles the cell position\n        lp *= 2.0;\n        //checks which cell in the subdivision the pixel lands on\n        vec2 q = step(1.0,lp);\n        //if lp is over 1 subtract by 1\n        lp -= q;\n        //half size because of subdivision\n        size *= 0.5;\n        //moves to new cell position\n        fp += q*size;\n    }\n    //flips the truchet cell randomly\n    float rand = hash13(vec3(fp,-i-1.0));\n    if (rand < 0.5) lp.x = 1.0-lp.x;\n    \n    float a = exp2(i-limit-1.0);\n    //length to bottom left corner, or top right (whichever is closest\n    float t = length(lp-step(1.0,lp.x+lp.y));\n    //repeats the length with mod to make many rings\n    float len = ripple(lp-0.5,a*2.0);//abs(mod(t,a*2.0)-a);\n    \n    //normalize len\n    len *= size;\n    len -= thickness;\n    \n    //antialiasing\n    float mask = clamp(len*iResolution.y*0.5-0.5,0.0,1.0);\n    \n    vec2 p2 = abs(lp-0.5);\n    float e = min((1.0-max(p2.x,p2.y)*2.0)*size*iResolution.y*0.125,1.0);\n    \n    vec3 col1 = texture(iChannel0,uv*0.2).rgb;\n    col1 = mix(vec3(0.3,0.8,0.5),col1,e);\n    //shadows\n    col1 /= max(1.0,3.0-len*90.0);\n    \n    vec3 col2 = mix(vec3(0,0.5,0.8),vec3(0.5,0.2,0.76),sin(len/thickness*2.0+1.0));\n    \n    fragColor = vec4(mix(col2,col1,mask),1);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lttfRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 149, 172, 172, 306], [308, 308, 339, 339, 378], [380, 380, 413, 413, 951], [953, 953, 1010, 1060, 3084]], "test": "error"}
{"id": "ltyyD3", "name": "ambient-277", "author": "teraspora", "description": "test", "tags": ["test"], "likes": 0, "viewed": 65, "published": "Public", "date": "1538672466", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// More Experiments with panes\n// Author: John Lynch (teraspora);\n// Date: 26 SEP 2018.\n\nconst float HALF = 0.5;\nconst float PI = 3.141592654;\nconst float TWO_PI = 6.283185307;\n\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 cyan =       vec3(0.0,  1.,   0.84);\nconst vec3 magenta =    vec3(1.0,  0.,   1.0 );\nconst vec3 blue =       vec3(0.0,  0.6,  0.84);\nconst vec3 gold =       vec3(1.0,  0.98, 0.84);\nconst vec3 orange =     vec3(1.0,  0.2,  0.0 );\nconst vec3 yellow =     vec3(1.0,  1.0,  0.0 );\nconst vec3 dark_blue =  vec3(0.0,  0.05, 0.15);\nconst vec3 crimson =    vec3(0.76, 0.0,  0.42);\n    \nvec3[] cols = vec3[](magenta, cyan, crimson, blue, orange, yellow);\nint cl = cols.length();\n\n// bitmaps of the 10 decimal digits, given in octal for ease of visualisation\nconst uint[] digits = uint[](07642424276u, 01010101010u, 07602764076u, 07602760276u,\n                             04040447604u, 07640760276u, 04040764276u, 07602020202u,\n                             07642764276u, 07642760202u);\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\nfloat om(float x) {\n\treturn 1. - x;\n}\n\nint largestPrimeLessThan(int n) {\n    if (n < 3) return 2;\n\tbool prime[2048];\n    for (int i = 0; i < prime.length(); i++) {\n    \tprime[i] = true;\n    }    \n    for (int p = 2; p * p <= n; p++) { \n        if (prime[p]) { \n            for (int i = p * 2; i <= n; i += p) \n                prime[i] = false; \n        } \n    } \n\tfor (int i = n - 1; i >= 0; i--) {\n    \tif (prime[i]) return i;\n    }    \n}\n\n\n// MAIN METHOD:\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    int num = int(iTime);\n    // Set this var to the number of tiles acroos and down:\n    float tileDim = 1.;\n    float numTiles = tileDim * tileDim;\n    \n    // some shorter names:\n    float fx = fragCoord.x;\n    float fy = fragCoord.y;\n    float resx = iResolution.x;\n    float resy = iResolution.y;\n    vec2 f = fragCoord.xy;\n    vec2 hr = iResolution.xy / tileDim;\n    \n    // MUTABLE VARIABLES\n    float scaleFactor = 1.0;\n    \n    // ===============================================================\n    // the output vector giving the position the program needs to know!-\n    vec2 pp = f;\n    // Make numTiles sub-frames:\n    vec2 n = vec2(float(int(f.x / resx * tileDim)), float(int(f.y / resy * tileDim)));\n    \n    float tile = tileDim == 1. ? -1. : numTiles -(n.y * tileDim + n.x) - 1.;\t// start at 1 so we don't lose stuff when multiplying\n    float toe = fract(tile / 2.) * 4. - 1.; // returns 1. if tile index odd, -1. if even;\n    float tile2 = tile * tile;\n    \n    // shift back to the first tile if in any other tile:\n    pp.x -= hr.x * n.x;\n    pp.y -= hr.y * n.y;\n    // normalise to [0, 1[, shift to make unit quad with origin in centre\n    vec2 q = pp / hr - 0.5;     // normalise\n    // then scale:\n    q /= scaleFactor;\n    \n    // control factors for changing colours\n        \n\n        // Initial colour set:\n    vec3 col = mix(yellow, cyan, length(q));\n\t\n    switch(int(tile)) {\n        case -1:\n        float time = 277. - iTime;\n        col.b *= (sin(time / 6.) + 1.);\n        col.g *= (cos(time / 11.) + 1.);\n        \n        //col *= \t  om(step(0.05, length(q)))\n        vec2 qq = q;\n        qq *= abs(cos(time * 0.5) + time);\n        float s = 0.005 + 0.02 * cos(length(qq) * 9.);\n        col *= step(s, mod(length(qq), 0.004))   \t\n             \t\n            ;\n        \n        \tbreak;\n        case 1: \n        \tq = mod(q, 0.25) * 1.5;\n        \tq.x -= 0.2; \n        \n        \tcol = mix(white, crimson, sqrt(sin(abs(q.y) + abs(q.x))));\n        \tcol.b *= (sin(iTime) + 1.);\n        \tfloat sign = 1.;\n        \tif(mod(iTime, 64.) < 32.) sign = -1.;\n        \tq = rotate(q, sign * iTime );\n        \tcol *= smoothstep(0.01, 0.06, abs(q.x));\n        \tcol *= smoothstep(0.01, 0.06, abs(q.y));\n        \tcol *= smoothstep(0.4, 0.45, 1. - smoothstep(0.4, 0.45, length(q)));\n        \tcol *= (1. + 0.1 * sin( 10. * atan(q.y, q.x)));\t\n    \t\n        \tq.x += 0.4; \n        \n        \tcol = mix(white, crimson, sqrt(sin(abs(q.y) + abs(q.x))));\n        \tcol.b *= (sin(iTime) + 1.);\n        \t\n        \tif(mod(iTime, 64.) < 32.) sign = -1.;\n        \tq = rotate(q, sign * iTime );\n        \tcol *= smoothstep(0.01, 0.06, abs(q.x));\n        \tcol *= smoothstep(0.01, 0.06, abs(q.y));\n        \tcol *= smoothstep(0.4, 0.45, 1. - smoothstep(0.4, 0.45, length(q)));\n        \tcol *= (1. + 0.1 * sin( 10. * atan(q.y, q.x)));\t\n                \t\n            break;\n        case 4: \n        \tq += vec2(0.1 * sin(iTime / 4.), -0.15 * cos(iTime / 4.));\n        \tq = rotate(q, iTime / 4.);\n        \tq *= 1.8 * sqrt(abs(sin(iTime / 32.)));\n        \tint t = int(iTime);\n        \t\n        \n        \n        \tq.y *= 88.0 *abs(cos(q.x * 8.)) * abs(sin(iTime / 32.));\n    \t\t\n        \n        \tcol = mix(cyan, crimson, sin(q.y));\n        \tcol.g *= ((-cos(iTime / 5.) + 1.) * 0.5);\n    \t\tnum = largestPrimeLessThan(t);\n        \n        \tfloat rows = 5.;\n    \t\tfloat columns = 54.;\n    \t\t// width and height of a digit in rows of bit-blocks\n    \t\tfloat dw = 6.;\n    \t\tfloat dh = 5.;\n\n    \t\t// populate the bitmap array with bitmaps for the appropriate digits:\n    \t\tuint[] bitmap = uint[10](0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u);\n    \t\tfor (int i = 0, divisor = 100000000; i < 9; i++, divisor /= 10) {\t\n        \t    int m = num / divisor;\n        \t\tbitmap[i] = digits[m];\n        \t    num -= m * divisor;\n        \t}\n        \tvec2 box = vec2(0.9, 0.2);\n    \t\tvec2 padding = (-box + 1.) / 2.;\n    \t\t\n        \tif (q.x >= -0.5 + padding.x && q.x < 0.5 - padding.x\n        \t\t  && q.y >= -0.5 + padding.y && q.y < 0.5 - padding.y) {        \n        \t\tvec2 p = (q * vec2(1., -1.) + vec2(0.5, 0.5) - padding) / box;\n        \t    float bx = float(p.x * columns);\n        \t    float by = float(p.y * rows);\n        \t    float place = bx / dw;\n        \t    float dx = bx - floor(place) * dw;\n        \t    float dy = floor(by);\n        \t    uint digit = bitmap[int(place)]; \n        \t    int bitx = int(dy * dw + dx);\n        \t    int charSize = int(dw * dh);\n        \t    bitx = charSize - bitx ;\n        \t    col *= (1. - float((digit >> bitx) & 1u));        \n            }       \n            break;\n        case 8: \n            col = mix(blue, magenta, sqrt(sin(abs(q.y))));\n        \tq.x -= 0.1;\n        \tq.y += 0.1;\n        \tq = mod(q, 0.2) * .16;\t\n            q = rotate(q, iTime);\n\t\t\tfloat r = (sin( 6. * atan(q.x, q.y)) + 1.) * 0.1;\n        \t\n        \tcol *=  smoothstep(r, r + 0.01, length(q));\n        \t//q.x += 0.1;\n        \t//col *= 0.;\n        \t\n        break;\n        \t\n        default: \t\t // some rotation and translation for a bit of variation!\n        \tif (fract((numTiles + 37.) / tile) == 0.0) q = rotate(q, 0.5 * PI);\n        \tq *= 1.0 + sin(iTime / 20.) * tile / numTiles * toe;    \n        \tq = rotate(q, iTime / 10.);\n\t\t\t\n        \n        \tcol.b = 0.*sin(iTime  / 6.);\n\n        \tfloat freq = 10. + float(int(sqrt(tile))) + 10. * sin(iTime / 100.);\n        \tfloat rmin = 0.15;\n        \tfloat rinc = 0.06;\n        \tfloat k = 0.25 + 0.1 * sin(iTime) * sin(tile);\n\n        \t// shift the tree:\n        \tq.x += 0.2 * sin(iTime / 2.) * toe;\n        \tq.x -= 0.2 * sin(iTime / 10.) * toe;\n\n        \tfloat phi = sin(iTime / 2. + tile) * 0.2;\n        \tq = rotate(q, phi);    \n        \t// r has all the info to make fronds and splay them:\n        \tr = rmin + k * cos(atan(q.y, q.x) * freq + 40. * q.x  + 1.4 * toe);\n        \tq = rotate(q, -phi);    \n        \tq = rotate(q, phi * toe * 2.);    \n\n        \t// make trunk wavy:\n        \tfloat trunkAngle = 0.2 * toe * cos(iTime / 10.);\n        \tfloat trunkWaviness = tile;\n        \tfloat barkRoughness = 0.002;\n        \tfloat barkIndentation = 60.;\n        \tfloat baseSize = -.19;    \n\n        \t// make arms:\n        \tcol *= smoothstep(r, r + rinc, length(q));\n        \t// and a trunk:\n        \tr = 0.04 * tile / numTiles;\n        \tr += barkRoughness * cos(barkIndentation * q.y);\n        \tr += exp(baseSize * pp.y);\n\t\n        \tcol *= 1. - (1. - smoothstep(r, r+ 0.001, abs(q.x - trunkAngle * sin(trunkWaviness * q.y)))) \n                  * (1. - smoothstep(0.0, 0.01, q.y));    \n        \t\n            break;\n    }    \n    \n \n    \n    // ===============================================================================\n\n    // Make a border: 8px solid black; with line inset:\n    float b = 6.;   // border width    \n    vec3 borderInsetLineColour = white;\n    \n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = borderInsetLineColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = borderInsetLineColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));\n    \n    // Black out a 'random' tile...\n    // if (int(mod(tile * 79., numTiles)) == int(mod(iTime * 2., numTiles))) col = black;\n    \n    \n    // and finally return the colour:\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltyyD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1062, 1062, 1081, 1081, 1110], [1112, 1112, 1144, 1144, 1191], [1193, 1193, 1221, 1221, 1286], [1288, 1288, 1320, 1320, 1361], [1363, 1363, 1382, 1382, 1400], [1402, 1402, 1435, 1435, 1802]], "test": "error"}
{"id": "Ml3BDN", "name": "Hyperbole", "author": "t3knomanser", "description": "More spinning lines", "tags": ["simple", "lines", "demo", "geometry"], "likes": 1, "viewed": 71, "published": "Public", "date": "1539638655", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat line(vec2 uv, float m, float b, float thickness, float fuzz) {\n    float y = m * uv.x + b;\n    float d = thickness - distance(uv, vec2(uv.x, y));\n    d =  smoothstep(0., thickness, d);\n    if (uv.y >= y - thickness && uv.y <= y + thickness) {\n        return mix(1., d, fuzz);\n    }\n    return 0.;\n}\n\nfloat line(vec2 uv, float m, float b) {\n    return line(uv, m, b, iResolution.y / 100000., 0.);\n}\n\nfloat line(vec2 uv, float m, float b, float thickness) {\n    return line(uv, m, b, thickness, 0.);\n}\n\nfloat line(vec2 uv, float thickness) {\n    return line(uv, 0., 0., thickness);\n}\n\nvec2 translate(vec2 uv, vec2 offset) {\n    return uv - offset;\n}\n\nvec3 p = vec3(1.0, 0.3333, 1.0);\nvec3 b = vec3(0.3333, 1.0, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float numLines = 30. * smoothstep(0.0, 1., abs(sin(iTime*0.15)));\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = translate(uv, vec2(0.5, 0.5));\n    uv *= rotate2d(-iTime);\n\tvec3 col;\n    for (float i = -numLines; i < numLines; i++) {\n        vec2 shift = uv * rotate2d(i * 2. * 3.14 / numLines);\n        shift += translate(uv, vec2(0., 0.1));\n        col += vec3(\n            line(shift, 1.5/iResolution.x)\n        ) * (i < 0. ? p : b);\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3BDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 114], [116, 116, 184, 184, 420], [422, 422, 461, 461, 519], [521, 521, 577, 577, 621], [623, 623, 661, 661, 703], [705, 705, 743, 743, 769], [838, 838, 895, 945, 1453]], "test": "valid"}
{"id": "Ml3BzB", "name": "horn of Geryon", "author": "balkhan", "description": "slow and unoptimized :)\n\nThis is my take on this : http://crawl.chaosforge.org/Horn_of_Geryon\n", "tags": ["3d", "raymarching", "horn", "dcss"], "likes": 25, "viewed": 412, "published": "Public", "date": "1540024631", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nfloat \tt;\n\n#define I_MAX\t\t100\n#define E\t\t\t0.001\n#define FAR\t\t\t30.\n\n#define UNIFORM_ROTATION\n\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nvec2\trot(vec2 p, vec2 ang);\nvoid\trotate(inout vec2 v, float angle);\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\n\nvec3\tid;\nvec3\th;\n\nvec2 skew (vec2 st) {\n    vec2 r = vec2(0.0);\n    r.x = 1.5*st.x;\n    r.y = st.y+0.5*r.x;\n    return r;\n}\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    h *= 0.;\n    t = iTime;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2\tR = iResolution.xy, uv  = (f-R*.5)/R.yy;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(-.0, .0, 2.-iTime*.0);\n    \n    vec4\tinter = (march(pos, dir));\n\n    col = h*1.;\n    c_out =  vec4(col, h.x);\n}\n\n/*\n* Leon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\n#define PI 3.14159\n#define TAU PI*2.\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    id.x = 3.14*floor((a-an*.5)*count)/count;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\nfloat hash1( vec2  p ) { float n = dot(p,vec2(127.1,311.7) ); return fract(sin(n)*43758.5453); }\n\n// iq's hexagons\nfloat hexagon( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\tid.z = hash1((pi + ca - cb*ma).xy)*3.14;\n\treturn step(e*1., .015);;\n}\n// iq's hexagons\n\nfloat\tscene(vec3 p)\n{\n    float\tmind = 1e5;\n    float var = .0, var1 = .0, var2 = .0;\n\n    vec3\tpr = p;\n\tpr.z-=-10.;\n    rotate(pr.zy, iTime*.1250*.0+iMouse.x*.01*2.+.0);\n    rotate(pr.xz, iTime*.2*4.0*.0+iMouse.y*.01*2. +0.*1.57);\n    \n    // compute angle x^y\n    var1 = atan(pr.x, pr.y);\n    // prepare space for toris creation\n    vec2 q = vec2(length(pr.xy)-5.0, pr.z-var1*1.*1.0 );\n\n    // I use this for texcoord in torus deformed space\n    var2 = atan(q.x, q.y);\n    vec2 tcd = 2.*vec2(vec2(1.0*var2/6.28, +2.0*var1/6.28).xy*1.);\n    // hexagon function courtesy of iq\n    var = 1.-hexagon(tcd*13.*1.);\n    // this value will be used to rotate the space\n    // since it will go into a sine, remap it [-3.14 : +3.14]\n    // we take value from texture\n    id.y = length(texture(iChannel0, .2050*vec2(+var2*1.0, q.y*-.1250*0.+1.0*var1).xy*1.\n                    ).x)*6.28-3.14;\n    // this is the triangle pattern\n    tcd = skew(tcd);\n    tcd = fract(tcd*26.);\n    // add triangle pattern to rotate value\n    id.y += 10.*max(step(tcd.x,tcd.y)*1.*sin(iTime*.125+id.z*200.+1.57), .0);\n    // add hexagon id to rotate value\n    id.y += id.z*10.;\n    // make a sine of rotate value\n    id.y = 1.14*sin(id.y*.5+iTime*.5125*3.0)/max(1., 1.+sin(var1+iTime*.0) );\n    \n    // rotate the space of the toris that will be created\n    rotate(q.xy, id.y-iTime*.125*-.0 +var1*.0);\n    \n    // making 8 toris, give them a different color each (id given in modA function)\n    q.xy = modA(q.xy, 8.);\n    // pull the toris appart from toris space center depending on angle x^y\n    q.x += -.75-.505*var1;\n\n    // compute length of toris\n\tmind = mylength(q)-.325205+.0+1.0*-.12500*var1-.06*abs(sin(id.z*1.+iTime*3.50))*2.0;//+.25*sin(iTime+id.x*5.+var1*0.);\n\n    // we NEED a cap or else depending on view direction we'll have a load of artifacts\n    // this is due to atan(x, y) near y == 0.\n    // so compute length of a toris to put on the open end of the horn\n    vec2 qq = vec2(length(pr.yz-vec2(-5., 3.14*1.0))-2.35, pr.x-.01);\n    float ming = max(abs(qq.x)-.7, abs(qq.y)-.025 )-0.;\n    \n    mind = min(mind, ming);\n    \n    // this is one way to do transparency in raymarching\n    mind = mix(mind, abs(mind)+.01, .5+.5*sin(iTime*.25+id.z));\n    \n    // return distfield * fudgevalue to lessen artifacts\n    return(mind)*1.*.5;\n}\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec4\tret = vec4(0.0, 0.0, 0.0, 0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x*1.;\n        float\td = 5.;\n        // this is the lighting\n        // the color is choosen by the id of the torus with basic sine coloring\n        h += (1.0*1.*\n            .00125/max(.1, dist.x*dist.x*.1+.0250502501*8.0) \n             )\n            *\n            vec3\n        (\n    \t\t1.+(sin(1.0*(id.x)+0.00) )\n            ,\n            1.+(sin(1.0*(id.x)+1.04) )\n            ,\n            1.+(sin(1.0*(id.x)+2.08) )\n        )\n            ;\n        if ( dist.x < E || dist.y >= FAR)\n            break;\n        ret.x++;\n    }\n    ret.w = dist.y;\n    ret.y = dist.x;\n    return (ret);\n}\n\n// Utilities\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret = 1e5;\n    \n    p = p*p;\n    p = p*p;\n    p = p*p;\n    \n    ret = p.x + p.y + p.z;\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret = 1e5;\n    \n    p = p*p;\n    p = p*p;\n    p = p*p;\n    \n    ret = p.x + p.y;\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3BzB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[424, 424, 445, 445, 529], [531, 531, 574, 574, 838], [949, 949, 982, 982, 1159], [1161, 1161, 1185, 1185, 1257], [1259, 1276, 1302, 1302, 1841], [1860, 1860, 1881, 1881, 4181], [4183, 4183, 4215, 4215, 5032], [5048, 5048, 5072, 5072, 5216], [5218, 5218, 5242, 5242, 5380], [5382, 5382, 5422, 5422, 5497], [5499, 5499, 5527, 5527, 5635], [5638, 5638, 5688, 5688, 5948], [5950, 5950, 5972, 5972, 6178]], "test": "error"}
{"id": "Ml3fWN", "name": "Chanel Doodle #3", "author": "Flopine", "description": "15 minutes improvisation training for a performance at the Chanel Foundation gala", "tags": ["raymarching", "performance", "15mins"], "likes": 4, "viewed": 142, "published": "Public", "date": "1539636033", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui and Coyhot for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n\n#define ITER 64.\n#define PI 3.141592\n#define time iTime\n#define BPM 143./2.\n#define tempo BPM/60.\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.*PI*(c*t+d));}\n\nvec2 moda (vec2 p, float per)\n{\n  float a = atan(p.y, p.x);\n  float l = length(p);\n  a = mod(a-per/2., per)-per/2.;\n  return vec2(cos(a),sin(a))*l;\n}\n\nvec2 mo(vec2 p, vec2 d)\n{\n  p = abs(p)-d;\n  if (p.y > p.x) p.xy = p.yx;\n  return p;\n}\n\nfloat stmin(float a, float b, float k, float n)\n{\n  float st = k/n;\n  float u = b-k;\n  return min(min(a,b), 0.5 * (u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat smin( float a, float b, float k )\n{\n  float h = max( k-abs(a-b), 0.0 );\n  return min( a, b ) - h*h*0.25/k;\n}\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat pulse (float s)\n{return exp(-fract(time * tempo) * s);}\n\nfloat tiktak(float period)\n{\n  float tik = floor(time*tempo)+pow(fract(time*tempo),3.);\n  tik *= 3.*period;\n  return tik;\n}\n\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\nfloat od (vec3 p, float d)\n{return dot(p, normalize(sign(p)))-d;}\n\nfloat cyl (vec2 p, float r)\n{\n\nreturn length(p)-r;}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat prim1 (vec3 p)\n{\n    p.xz *= rot(time);\n    p.xz *= rot(p.y*0.5);\n    p.xz = moda(p.xz, 2.*PI/5.);\n    p.x -= 1.;\n    return cyl(p.xz, 0.1);\n}\n\nfloat prim2 (vec3 p)\n{\n    p.xy *= rot(time);\n    p.xy *= rot(p.z*0.5);\n    p.xy = moda(p.xy, 2.*PI/3.);\n    p.x -= 1.5;\n    p.xz = moda(p.xz, 2.*PI/5.);\n    p.x -= 1.;\n    return cyl(p.xz, 0.1);\n}\n\nfloat prim3 (vec3 p)\n{\n    p.xy = mo(p.xy, vec2(1.5, 0.8));\n    p.xz = moda(p.xz, 2.*PI/5.);\n    p.x -= 2.;\n    return stmin(prim1(p),prim2(p), 0.5, 3.);\n}\n\nfloat prim4 (vec3 p)\n{\n    float s = sphe(p,1. + pulse(0.2));\n    float o = od (p, 1.2);\n    return smin(s,o, 0.1);\n}\n\nfloat g = 0.;\nfloat SDF(vec3 p)\n{\n    p.xz += sin(time);\n    p.xy += sin(time*0.5);\n    float d = smin(prim4(p),prim3(p), 0.5);\n    g+=0.1/(0.1+d*d); \n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(fragCoord/iResolution.xy) -1.;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    uv += texture(iChannel0, uv+vec2(time*0.2,time*0.1)).r*0.05;\n    vec3 ro = vec3(0.001,0.001,-8.); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n\n    float shad = 0.;\n\n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/ITER;\n            break;\n        }\n        p += d*rd*0.5;\n    }\n\n    float t = length(ro-p);\n\n    vec3 pal = palette\n        (length(uv),\n         vec3(0.5),\n         vec3(0.5),\n         vec3(0.1),\n         vec3(0.,0.1,0.4));\n\n    vec3 c = vec3(1.-shad)*(1.-pal*0.3);\n    c = mix(c, pal, 1.-exp(-0.01*t*t));\n    c += g*0.01 * length(uv)*sin(time)*2.;\n  \tfragColor = vec4(c,1.);\n}\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3fWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[280, 280, 336, 336, 367], [369, 369, 400, 400, 518], [520, 520, 545, 545, 605], [607, 607, 656, 656, 756], [758, 758, 799, 799, 872], [874, 874, 893, 893, 936], [938, 938, 961, 961, 999], [1001, 1001, 1029, 1029, 1124], [1126, 1126, 1156, 1156, 1176], [1178, 1178, 1206, 1206, 1243], [1245, 1245, 1274, 1274, 1296], [1298, 1298, 1327, 1327, 1414], [1416, 1416, 1438, 1438, 1564], [1566, 1566, 1588, 1588, 1763], [1765, 1765, 1787, 1787, 1920], [1922, 1922, 1944, 1944, 2039], [2055, 2055, 2074, 2074, 2207], [2210, 2210, 2267, 2267, 3041]], "test": "error"}
{"id": "Ml3fzH", "name": "[twitch] Datamatics Dot Plotter", "author": "yx", "description": "Coded live on twitch stream in Bonzomatic, and tidied/ported to shadertoy.\nUnedited Bonzomatic shader here: [url]https://gist.github.com/willkirkby/b2f315e2e0ae582127a6d04843835d5e[/url]", "tags": ["twitch", "ryojiikeda"], "likes": 12, "viewed": 637, "published": "Public API", "date": "1538603964", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float FONT_SCALE = 2.;\nconst float POINT_SIZE = 1.5;\nconst float LINE_SIZE = 1.;\nconst float FOV = 2.;\nconst int NUM_POINTS = 128;\nconst float SPEED = 1.;\n\nfloat noise(float a)\n{\n  return fract(sin(a)*43758.5453123);\n}\n\nvec2 rotate(vec2 a, float b)\n{\n  float c = cos(b);\n  float s = sin(b);\n  return vec2(\n    a.x * c - a.y * s,\n    a.x * s + a.y * c\n  );\n}\n\nvoid spin(inout vec3 p)\n{\n  p.yz = rotate(p.yz, cos(iTime*.01)*.15+.1);  // tweaked for shadertoy\n  p.xz = rotate(p.xz, iTime * .1);\n}\n\nmat4 projMtx()\n{\n  float aspect = iResolution.x / iResolution.y;\n  float nearz = 0.1;\n  float farz = 100.;\n  return mat4(\n    1./(aspect*tan(FOV/2.)), 0,0,0,\n    0,-1./tan(FOV/2.),0,0,\n    0,0,(-nearz-farz)/(nearz-farz),(2.*farz*nearz)/(nearz-farz),\n    0,0,1,0\n  );\n}\n\nvec3 cameraPos()\n{\n  vec3 pos = vec3(0,0,-2.);\n  spin(pos);\n  return pos;\n}\n\nvec3 rayDir()\n{\n  vec2 uv = (gl_FragCoord.xy/iResolution.xy)-.5;\n  uv.x *= iResolution.x / iResolution.y;\n  uv *= 2.;\n\n  vec3 dir = normalize(vec3(\n    uv,(4.8/tan(FOV/2.)) // where's the 4.8 from?!??!?!?!?!\n  ));\n  spin(dir);\n  return dir;\n}\n\nmat4 cameraMtx()\n{\n  vec3 pos = cameraPos();\n  vec3 dir = vec3(0,0,1);\n\n  spin(dir);\n\n  vec3 up = vec3(0,1,0);\n  vec3 right = cross(dir, up);\n  up = cross(right, dir);\n  mat4 orientation = mat4(\n    right.x, up.x, dir.x, 0,\n    right.y, up.y, dir.y, 0,\n    right.z, up.z, dir.z, 0,\n    0,0,0,1\n  );\n  mat4 translation = mat4(\n    1,0,0,0,\n    0,1,0,0,\n    0,0,1,0,\n    -pos.x, -pos.y, -pos.z, 1\n  );\n  return orientation * translation;\n}\n\nvec2 project(vec3 p3, mat4 mtx)\n{\n  vec4 p = mtx * vec4(p3,1);\n  p /= p.w;\n  return (p.xy*.5+.5)*iResolution.xy;\n}\n\nvoid drawLine2D(inout vec4 fragColor, vec2 a, vec2 b, vec4 color)\n{\n  a-=.5;\n  b-=.5;\n  vec2 midpoint = (a+b)*.5;\n  float radius = distance(a,b)*.5;\n  vec2 normal = normalize((b-a).yx*vec2(-1,1));\n  float d = dot(normal, gl_FragCoord.xy-midpoint);\n  fragColor += (clamp(LINE_SIZE-abs(d),0.,1.) * smoothstep(radius+.5,radius-.5,distance(gl_FragCoord.xy,midpoint))) * color;\n}\n\nvoid drawLine3D(inout vec4 fragColor, vec3 a, vec3 b, vec4 color, mat4 mtx)\n{\n  vec2 pa = project(a, mtx);\n  vec2 pb = project(b, mtx);\n  drawLine2D(fragColor, pa, pb, color);\n}\n\nvoid drawPoint2D(inout vec4 fragColor, vec2 a, vec4 color)\n{\n  a-=.5;\n  float d = distance(a,gl_FragCoord.xy);\n  fragColor += smoothstep(POINT_SIZE,POINT_SIZE-1.,d) * color;\n}\n\nvoid drawPoint3D(inout vec4 fragColor, vec3 a, vec4 color, mat4 mtx)\n{\n  drawPoint2D(fragColor,project(a,mtx),color);\n}\n\nvoid drawCrosshair3D(inout vec4 fragColor, vec3 a, vec4 color, mat4 mtx)\n{\n  vec2 o = vec2(.007, 0);\n  drawLine3D(fragColor, a+o.xyy, a-o.xyy, color, mtx);\n  drawLine3D(fragColor, a+o.yxy, a-o.yxy, color, mtx);\n  drawLine3D(fragColor, a+o.yyx, a-o.yyx, color, mtx);\n}\n\nvoid drawDotGrid3D(inout vec4 fragColor, float y, vec4 color)\n{\n  vec3 camPos = cameraPos();\n  vec3 rayDir = rayDir();\n\n  float distGrid = (camPos.y - y) / -rayDir.y;\n  vec3 hitGrid = abs(camPos + rayDir * distGrid);\n\n  if (hitGrid.x <= 1. && hitGrid.z <= 1.)\n  {\n    vec2 gridUv = fract(hitGrid.xz * 16.);\n    float dotSize = distGrid*.07; //length(dFdy(hitGrid.xz * 16.)) * 2.;\n    fragColor += smoothstep(dotSize,0.,length(gridUv-.5)) * color;\n  }\n}\n\nvoid drawBarcodeGrid3D(inout vec4 fragColor, float y)\n{\n  vec3 camPos = cameraPos();\n  vec3 rayDir = rayDir();\n\n  float distGrid = (camPos.y - y) / -rayDir.y;\n  vec3 hitGrid = camPos + rayDir * distGrid;\n  vec2 absHitGrid = abs(hitGrid.xz);\n\n  if (absHitGrid.x <= 1. && absHitGrid.y <= 1.)\n  {\n    vec2 gridUv = hitGrid.xz*.5+.5;\n    float speed = .3;\n    gridUv.x += iTime*speed;\n    float mask = 1.-step(1./32.,mod(gridUv.x,4.));\n    float barcode = step(.5, fract(iTime*2.+noise(floor(gridUv.y * 256.)+.1*floor(gridUv.x*64.))));\n    fragColor += mask * barcode * .5;\n  }\n}\n\nvec3 starPosition(int i)\n{\n  float f = float(i);\n  vec3 p = vec3(\n    noise(f),\n    1.-float(i)/float(NUM_POINTS),//noise(f+.1),  // tweaked for shadertoy\n    noise(f+.2)\n  );\n  p=p*2.-1.;\n  p/=sqrt(3.);\n  p*=pow(length(p), 2.3);\n  return clamp(p*1.2,-1.,1.);\n}\n\nvoid textWriter(inout vec4 fragColor, ivec2 p, int digit)\n{\n  p--;\n  int[10]font=int[10](\n    0x75557,\n    0x23227,\n    0x74717,\n    0x74747,\n    0x55744,\n    0x71747,\n    0x71757,\n    0x74444,\n    0x75757,\n    0x75747\n  );\n  if (p.x<0||p.y<0||p.x>=3||p.y>=5) return;\n  fragColor += float((font[digit]>>(p.x+p.y*4))&1);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  out_color = vec4(0);\n\n  mat4 mtx = projMtx() * cameraMtx();\n  float time = iTime * SPEED;\n\n  int currentPointIdx = int(floor(time)) % NUM_POINTS;\n  int nextPointIdx = (currentPointIdx+1) % NUM_POINTS;\n  float timeBetweenPoints = fract(time);\n\n  vec3 currentPoint = starPosition(currentPointIdx);\n  vec3 nextPoint = starPosition(nextPointIdx);\n  vec3 lerpPoint = mix(currentPoint, nextPoint, timeBetweenPoints < .5 ? 0. : timeBetweenPoints*2.-1.);\n\n  for(int i=0;i<NUM_POINTS;++i)\n  {\n    drawCrosshair3D(out_color, starPosition(i), i <= currentPointIdx ? vec4(1,0,0,1) : vec4(1), mtx);\n  }\n\n  drawLine3D(out_color, vec3(lerpPoint.x,lerpPoint.y,-1), vec3(lerpPoint.x,lerpPoint.y,1), vec4(1), mtx);\n  drawLine3D(out_color, vec3(-1,lerpPoint.y,lerpPoint.z), vec3(1,lerpPoint.y,lerpPoint.z), vec4(1), mtx);\n  drawLine3D(out_color, vec3(-1,lerpPoint.y,-1), vec3(1,lerpPoint.y,-1), vec4(1), mtx);\n  drawLine3D(out_color, vec3(1,lerpPoint.y,-1), vec3(1,lerpPoint.y,1), vec4(1), mtx);\n  drawLine3D(out_color, vec3(1,lerpPoint.y,1), vec3(-1,lerpPoint.y,1), vec4(1), mtx);\n  drawLine3D(out_color, vec3(-1,lerpPoint.y,1), vec3(-1,lerpPoint.y,-1), vec4(1), mtx);\n  if (timeBetweenPoints < .5)\n  {\n    drawLine3D(out_color, lerpPoint, vec3(lerpPoint.x, 0, lerpPoint.z), vec4(1), mtx);\n    vec2 screenPoint = project(lerpPoint, mtx);\n    for(int x=0;x<7;++x)\n      textWriter(out_color, ivec2((gl_FragCoord.xy-4.-screenPoint)/FONT_SCALE-vec2(x*4,0)), int(noise(float(x+7*currentPointIdx))*10.));\n  }\n\n  float gridHeight = (1. - fract(time / 8.) * 2.);\n  drawDotGrid3D(out_color, gridHeight, vec4(1.-abs(gridHeight)) * .5);\n  if (gridHeight < 0.)\n    drawDotGrid3D(out_color, 0., vec4(1.+gridHeight) * .5);\n\n  drawBarcodeGrid3D(out_color, lerpPoint.y);\n\n  out_color = clamp(out_color, 0., 1.);\n  out_color = pow(out_color, vec4(1.3,1.15,1,1));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3fzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 184, 184, 224], [226, 226, 256, 256, 363], [365, 365, 390, 390, 499], [501, 501, 517, 517, 769], [771, 771, 789, 789, 846], [848, 848, 863, 863, 1090], [1092, 1092, 1110, 1110, 1529], [1531, 1531, 1564, 1564, 1645], [1647, 1647, 1714, 1714, 2021], [2023, 2023, 2100, 2100, 2200], [2202, 2202, 2262, 2262, 2377], [2379, 2379, 2449, 2449, 2498], [2500, 2500, 2574, 2574, 2767], [2769, 2769, 2832, 2832, 3221], [3223, 3223, 3278, 3278, 3798], [3800, 3800, 3826, 3826, 4061], [4386, 4386, 4438, 4438, 6379]], "test": "valid"}
{"id": "MlcBDH", "name": "Green Wavy Circle", "author": "scratch13764", "description": "I made a circle... cool! It's green, and doesn't seem to want to stay a circle...", "tags": ["circle", "wavy", "green"], "likes": 2, "viewed": 105, "published": "Public", "date": "1539391299", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy; //\n    \n    uv -= .5; //\n    \n    uv.x *= iResolution.x/iResolution.y; //\n    \n    uv.x += sin(iTime*2.)*0.1*uv.y;\n    \n    uv.y += sin(iTime*3.)*0.1*uv.x;\n    \n    float d = length(uv); //\n        \n    float col = (smoothstep(0.35, 0.3, d)); //\n    \n    if (d<0.3){\n    \n    col = (smoothstep(0.25, 0.3, d));\n    \n    }\n\n    fragColor = vec4(0.0,col,0.0,1.0); //\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlcBDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 464]], "test": "valid"}
{"id": "MlcBRr", "name": "First Environment Shader", "author": "Shadeyboi", "description": "Dungeony Hallway?", "tags": ["environment"], "likes": 2, "viewed": 68, "published": "Public", "date": "1540572691", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}    \n    \n    \n// Maximum/minumum elements of a vector    \nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}    \n    \n    \nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\n\nfloat pole(vec2 v, float r){\n  return length(v)-r;\n}\n\nfloat sphere(vec3 v, float r){\n  return length(v)-r;\n}\n\n\n\n\n// ============================\n// http://mercury.sexy/hg_sdf/\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat fOpUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n\n// ============================\n\n\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n\n\n//=======================\n\nShape Hallway(vec3 c){\n  Shape shape;\n    vec4 color = vec4(.65);\n    vec3 a = c;\n    vec3 l = c;\n    vec3 f = c;\n    vec3 s = c;\n    vec3 co = c;\n    \n    c.z = repeat(c.z, 2.);\n    a.z = repeat(a.z, 1.5);\n    l.z = repeat(l.z, 3.);\n    f.z = repeat(f.z, 2.);\n    s.z = repeat(s.z, 3.);\n    co.z = repeat(co.z, 2.);\n    \n    c.x = abs(c.x)-.5;\n    vec4 colColor = vec4(.4, .4, .1, .9);\n    float b1 = fBox(c-vec3(0.7, .0, 0.), vec3(.2, 1.1, 0.2)); //Columns\n    float b2 = fBox(c-vec3(0.7, .8, 0.), vec3(.3, 0.1, 1.)); //Connectors\n    \n    co.x = abs(co.x)-.5;\n    co.z = abs(co.z)-.4;\n    float c1 = fBox(co-vec3(.5, -.1, -0.2), vec3(.1, .617, .1)); //Corner Cutouts\n    \n    a.xy *= rot(-a.x*.5);\n    vec4 roofColor = vec4(.5, .5, .3, 1.);\n    float b3 = fBox(a-vec3(0., 1.1, 0.), vec3(.42, .1, .8)); //Roof\n    \n    vec4 flColor = vec4(.8, .8, 0., .7);\n    float fl = fBox(f-vec3(0., -.9, 0.), vec3(1.4, .05, 1.)); //Floor\n    \n    l.yz *= rot(radians(90.));\n    vec4 lColor = vec4(1., 1., 0., 1.);\n    float lights = sdCone(l-vec3(0., 0., -.8), vec2(.7, .3));\n    \n    vec4 sColor = vec4(1., 1., 0., 1.);\n    float sOrb = sphere(s-vec3(0., .9, 0.), .05);\n    s.z = repeat(s.z, 1.2);\n    s.x = abs(s.x)-.2;\n    s.z = abs(s.z)-.3;\n    s.xz *= random(s.xz)*2.;\n    float sDrops = sphere(s-vec3(0., -.8, 0.), .01);\n    \n    shape.dist = fOpUnionStairs(b1, b2, .2, 5.);\n    shape.dist = fOpUnionChamfer(b3, shape.dist, .05);\n    shape.dist = fOpUnionStairs(shape.dist, fl, .2, 3.);\n    shape.dist = min(shape.dist, lights);\n    shape.dist = fOpUnionRound(shape.dist, sOrb, .1);\n    shape.dist = max(shape.dist, -c1);\n    shape.dist = min(shape.dist, sDrops);\n    \n    shape.color = color;\n    shape.color = mix(roofColor, colColor, mixColors(b1, b3, .5));\n    shape.color = mix(shape.color, flColor, mixColors(fl, shape.dist, .5));\n    shape.color = mix(shape.color, lColor, mixColors(lights, shape.dist, .5));\n    shape.color = mix(shape.color, sColor, mixColors(sOrb, shape.dist, .5));\n    \n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape hall = Hallway(c);\n  return hall;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., iTime);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.0001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlcBRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 308, 348, 348, 469], [484, 528, 548, 548, 573], [575, 575, 595, 595, 630], [632, 632, 652, 652, 697], [712, 712, 734, 734, 801], [803, 803, 821, 821, 891], [894, 894, 922, 922, 946], [948, 948, 978, 978, 1002], [1007, 1070, 1098, 1098, 1179], [1181, 1277, 1335, 1335, 1445], [1447, 1501, 1566, 1566, 1607], [1609, 1609, 1672, 1672, 1712], [1714, 1714, 1746, 1774, 1835], [1837, 1837, 1885, 1885, 1970], [1972, 1972, 2022, 2022, 2071], [2109, 2109, 2152, 2152, 2195], [2197, 2197, 2240, 2240, 2306], [2308, 2308, 2347, 2347, 2503], [2533, 2533, 2555, 2555, 4544], [4547, 4547, 4565, 4565, 4609], [4611, 4611, 4668, 4668, 5082]], "test": "valid"}
{"id": "MlcBRs", "name": "glowballs", "author": "mds2", "description": "glowing raymarched things", "tags": ["raymarch", "sdf", "glow"], "likes": 13, "viewed": 1071, "published": "Public API", "date": "1540602311", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DIST 500.0\n\n#define INTEGRATE_UNBOUNDED_STUFF 1\n// set to 0 to make the density of the glowy stuff 1/(distance^2)\n// by default it's 1/distance, which means the total glow contribution grows with MAX_DIST\n// I think it looks better with 1/distance\n// but, hey, neither of these functions come from \"physics\"\n// (or, if they do, it is only by coincidence)\n//\n// p.s. looks really nice when MAX_DIST is huge (thanks @CLPB for pointing this out)\n\nconst vec3 light = vec3(0.48, 0.64, -0.6);\n\nvec3 ball1;\nvec3 ball2;\nvec3 ball3;\n\nvec3 radii;\n\nfloat sdf1(in vec3 pt) {\n    return length(max(vec3(0.0), abs(pt - ball1) - 0.5 * radii.x)) - 0.25 * radii.x;\n}\n\nfloat sdf2(in vec3 pt) {\n    vec2 tor = vec2(length(pt.xy - ball2.xy) - 0.75 * radii.y, pt.z);\n    return length(tor) - 0.25* radii.y;\n}\n\nfloat sdf3(in vec3 pt) {\n    return length(pt - ball3) - radii.z;\n}\n\nvec3 sdfs(in vec3 pt) {\n    return vec3(sdf1(pt), sdf2(pt), sdf3(pt));\n}\n\nfloat sdf(in vec3 pt) {\n    return min(sdf1(pt), min(sdf2(pt), sdf3(pt)));\n}\n\nfloat min_comp(in vec3 comps) {\n    return min(comps.x, min(comps.y, comps.z));\n}\n\nvec3 sdf_grad(in vec3 pt) {\n    float f = sdf(pt);\n    const float h = 0.001;\n    const float h_inv = 1000.0;\n    \n    return vec3(sdf(pt + vec3(h, 0.0, 0.0)) - f,\n                sdf(pt + vec3(0.0, h, 0.0)) - f,\n                sdf(pt + vec3(0.0, 0.0, h)) - f);\n}\n\nfloat raymarch(in vec3 orig, in vec3 dir, out vec3 integral) {\n    integral = vec3(0.0);\n    float curr = 0.0;\n    const float step_ratio = 0.25;\n    vec3 curr_sdf = sdfs(orig);\n    float dist = step_ratio * min_comp(curr_sdf);\n    vec3 next_sdf = sdfs(orig + dir * dist);\n    // integral from 0 to d of 1/(a+bx) =\n    // screw it, just average some things.\n    integral = dist * (0.25 / curr_sdf + 1.0 / (curr_sdf + next_sdf) + 0.25 / next_sdf);\n    float total_dist = dist;\n    const vec3 thresh = vec3(0.004);\n    for (int i = 0; i < 128; ++i) {\n        curr_sdf = next_sdf;\n        dist = step_ratio * min_comp(curr_sdf);\n        total_dist += dist;\n        next_sdf = sdfs(orig + total_dist * dir);\n        vec3 mid = 0.5 * (curr_sdf + next_sdf);\n#if INTEGRATE_UNBOUNDED_STUFF        \n        integral += dist * (0.25 / max(thresh, curr_sdf) + \n                            0.5 / max(thresh, mid ) + \n                            0.25 / max(thresh, next_sdf));\n#else\n        integral += dist * (0.25 / max(thresh, curr_sdf * curr_sdf) + \n                            0.5 / max(thresh , mid * mid ) + \n                            0.25 / max(thresh, next_sdf * next_sdf));\n#endif        \n        if (min_comp(next_sdf) < 1.0e-3 || total_dist > MAX_DIST) {\n            return total_dist;\n        }\n    }\n    return total_dist;\n}\n        \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 orig = vec3(0.0, 0.1, -1.25);\n    vec3 dir = normalize(vec3(uv, 1.0));\n    \n    mat3 tilt = mat3(1.0, 0.0, 0.0,\n                0.0, 0.28, -0.96,\n                0.0, 0.96, 0.28); \n    orig = tilt * orig;\n    dir = tilt * dir;\n    \n    float theta = 0.6 * iTime;\n    float ct = cos(theta);\n    float st = sin(theta);\n    \n    float rad = 0.6;\n\n    ball1 = rad * vec3(ct, st, 0.0);\n\n    ct = cos(theta + 2.0 * 3.141592654 / 3.0);\n    st = sin(theta + 2.0 * 3.141592654 / 3.0);\n    ball2 = rad * vec3(ct, st, 0.0);\n    \n    ct = cos(theta - 2.0 * 3.141592654 / 3.0);\n    st = sin(theta - 2.0 * 3.141592654 / 3.0);\n    ball3 = rad * vec3(ct, st, 0.0);\n\n    vec3 integral;\n    \n    radii = 0.3 + 0.2 * vec3(texture(iChannel0, vec2(0.0, 0.0)).r,\n                             texture(iChannel0, vec2(0.5, 0.0)).r,\n                             texture(iChannel0, vec2(1.0, 0.0)).r);\n    \n    float raydist = raymarch(orig, dir, integral);\n\n#if INTEGRATE_UNBOUNDED_STUFF    \n    vec3 col = smoothstep(0.15 * (1.0 *  radii), vec3(0.0), 0.45/(integral));\n#else\n    vec3 col = smoothstep(0.15 * (1.0 *  radii), vec3(0.0), 1.5/(integral));    \n#endif    \n    \n    if (raydist < MAX_DIST) {\n        vec3 pt = orig + raydist * dir;\n        vec3 norm = normalize(sdf_grad(pt));\n        vec3 bounce = normalize(reflect(dir, norm));\n        col += 0.25 * smoothstep(0.95, 1.0, dot(bounce, light)) * vec3(0.9, 0.8, 1.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Mtf3Rr", "previewfilepath": "https://soundcloud.com/cascaderecords/nikitch-kuna-maze-potheads", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/cascaderecords/nikitch-kuna-maze-potheads", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlcBRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[550, 550, 574, 574, 661], [663, 663, 687, 687, 799], [801, 801, 825, 825, 868], [870, 870, 893, 893, 942], [944, 944, 967, 967, 1020], [1022, 1022, 1053, 1053, 1103], [1105, 1105, 1132, 1132, 1369], [1371, 1371, 1433, 1433, 2698], [2709, 2709, 2766, 2816, 4363]], "test": "error"}
{"id": "MlcBW7", "name": "Simplicity Galaxy 2", "author": "coler706", "description": "Inspired by https://www.shadertoy.com/view/MslGWN", "tags": ["fractal"], "likes": 25, "viewed": 2376, "published": "Public", "date": "1539809863", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CBS\n//Parallax scrolling fractal galaxy.\n//Inspired by JoshP's Simplicity shader: https://www.shadertoy.com/view/lslGWr\n\n// http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\nfloat field(in vec3 p,float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\n// Less iterations for second layer\nfloat field2(in vec3 p, float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 18; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\nvec3 nrand3( vec2 co )\n{\n\tvec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\n\tvec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\n\tvec3 c = mix(a, b, 0.5);\n\treturn c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\tvec2 uvs = uv * iResolution.xy / max(iResolution.x, iResolution.y);\n\tvec3 p = vec3(uvs / 4., 0) + vec3(1., -1.3, 0.);\n\tp += .2 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));\n\t\n\tfloat freqs[4];\n\t//Sound\n\tfreqs[0] = noise(vec3( 0.01*100.0, 0.25 ,iTime/10.0) );\n\tfreqs[1] = noise(vec3( 0.07*100.0, 0.25 ,iTime/10.0) );\n\tfreqs[2] = noise(vec3( 0.15*100.0, 0.25 ,iTime/10.0) );\n\tfreqs[3] = noise(vec3( 0.30*100.0, 0.25 ,iTime/10.0) );\n\n\tfloat t = field(p,freqs[2]);\n\tfloat v = (1. - exp((abs(uv.x) - 1.) * 6.)) * (1. - exp((abs(uv.y) - 1.) * 6.));\n\t\n    //Second Layer\n\tvec3 p2 = vec3(uvs / (4.+sin(iTime*0.11)*0.2+0.2+sin(iTime*0.15)*0.3+0.4), 1.5) + vec3(2., -1.3, -1.);\n\tp2 += 0.25 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));\n\tfloat t2 = field2(p2,freqs[3]);\n\tvec4 c2 = mix(.4, 1., v) * vec4(1.3 * t2 * t2 * t2 ,1.8  * t2 * t2 , t2* freqs[0], t2);\n\t\n\t\n\t//Let's add some stars\n\t//Thanks to http://glsl.heroku.com/e#6904.0\n\tvec2 seed = p.xy * 2.0;\t\n\tseed = floor(seed * iResolution.x);\n\tvec3 rnd = nrand3( seed );\n\tvec4 starcolor = vec4(pow(rnd.y,40.0));\n\t\n\t//Second Layer\n\tvec2 seed2 = p2.xy * 2.0;\n\tseed2 = floor(seed2 * iResolution.x);\n\tvec3 rnd2 = nrand3( seed2 );\n\tstarcolor += vec4(pow(rnd2.y,40.0));\n\t\n\tfragColor = mix(freqs[3]-.3, 1., v) * vec4(1.5*freqs[2] * t * t* t , 1.2*freqs[1] * t * t, freqs[3]*t, 1.0)+c2+starcolor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlcBW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 223, 245, 245, 290], [291, 291, 311, 311, 356], [357, 357, 375, 375, 414], [416, 416, 436, 436, 927], [928, 928, 960, 960, 1347], [1349, 1385, 1419, 1419, 1806], [1808, 1808, 1832, 1832, 2015], [2018, 2018, 2075, 2075, 3498]], "test": "valid"}
{"id": "MlcfWN", "name": "Chanel Doodle #5", "author": "Flopine", "description": "15 minutes improvisation training for a performance at the Chanel Foundation gala", "tags": ["raymarching", "performance", "15mins"], "likes": 4, "viewed": 145, "published": "Public", "date": "1539637414", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui and Coyhot for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n\n#define ITER 64.\n#define PI 3.141592\n#define time iTime\n#define BPM 143./2.\n#define tempo BPM/60.\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.*PI*(c*t+d));}\n\nfloat random (vec2 st)\n{return fract(sin(dot(st.xy, vec2(12.2544, 35.1571)))*5418.548416);}\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y, p.x);\n    float l = length(p);\n    a = mod(a-per/2., per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\nvec2 mo(vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y > p.x) p.xy = p.yx;\n    return p;\n}\n\nfloat stmin(float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5 * (u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\nfloat od (vec3 p, float d)\n{return dot(p, normalize(sign(p)))-d;}\n\nfloat cyl (vec2 p, float r)\n{return length(p)-r;}\n\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p.xyz, p.yzx);\n    return min(p.x, min(p.y,p.z)) - d;\n}\n\nfloat prim1(vec3 p)\n{\n    float s = sphe(p,1.);\n    p.xz *= rot(time*tempo);\n    p.xz *= rot(p.y*0.5);\n    p.xz = moda(p.xz, 2.* PI/5.);\n    p.x -= .8;\n    return smin(s,cyl(p.xz, 0.1), 0.5);\n}\n\nfloat prim2(vec3 p)\n{\n    float p1 = max(-od(p,.9), prim1(p));\n    p.xz *= rot(time);\n    p.xy *= rot(time);\n    return min(p1, od(p, 0.5));\n}\n\nfloat prim3(vec3 p)\n{\n    p.xy = mo(p.xy, vec2(3.,2.));\n    return prim2(p);\n}\n\nfloat prim4 (vec3 p)\n{\n    float per = 3.;\n    p.xy *= rot(p.z*0.2);\n    p.z = mod(p.z-per/2., per)- per/2.;\n    return prim3(p);\n}\n\nfloat prim5 (vec3 p)\n{\n    float p1 = prim4(p);\n    p.z -= time*tempo;\n    p.xz *= rot(time);\n    p.xy *= rot(time);\n    float p2 = stmin(od(p, .5), sphe(p,.5), 0.5, 5.);\n    return min(p1, p2);\n}\n\nfloat g = 0.;\nfloat SDF(vec3 p)\n{\n    float d = prim5(p); \n    g += 0.1/(0.1+d*d);\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    uv += texture(iChannel0, uv+time).r*0.02;\n    \n    vec3 ro = vec3(0.001,0.001,-10.+time*tempo); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n\n    float shad = 0.;\n    float dither = random(uv);\n\n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/ITER;\n            break;\n        }\n        d *= 0.9 + dither*0.1;\n        p += d*rd;\n    }\n\n    float t = length(ro-p);\n\n    vec3 pal = palette\n        (length(uv),\n         vec3(0.5),\n         vec3(0.5),\n         vec3(0.5),\n         vec3(0.1,0.,0.8));\n\n    vec3 pal1 = palette\n        (abs(uv.y),\n         vec3(0.5),\n         vec3(0.5),\n         vec3(0.4),\n         vec3(0.3,0.,0.));\n\n    vec3 c = vec3(shad) * pal;\n    c = mix(c, pal1*0.3, 1.- exp(-.001*t*t));\n    c += g*0.08*length(uv);\n    fragColor = vec4(c,1.);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlcfWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[280, 280, 336, 336, 367], [369, 369, 393, 393, 460], [462, 462, 493, 493, 619], [621, 621, 646, 646, 712], [714, 714, 763, 763, 869], [871, 871, 912, 912, 989], [991, 991, 1010, 1010, 1053], [1055, 1055, 1085, 1085, 1105], [1107, 1107, 1135, 1135, 1172], [1174, 1174, 1203, 1203, 1223], [1225, 1225, 1254, 1254, 1345], [1347, 1347, 1375, 1375, 1459], [1461, 1461, 1482, 1482, 1654], [1656, 1656, 1677, 1677, 1798], [1800, 1800, 1821, 1821, 1878], [1880, 1880, 1902, 1902, 2011], [2013, 2013, 2035, 2035, 2209], [2225, 2225, 2244, 2244, 2309], [2312, 2312, 2369, 2369, 3319]], "test": "error"}
{"id": "Mlcfzr", "name": "layer practice (itmcg)", "author": "antlion2017", "description": "practice with layering", "tags": ["learning"], "likes": 1, "viewed": 78, "published": "Public", "date": "1539621633", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float t = 0.5;\n\nvec2 circpos1 = vec2(0.45, 0.5);\nfloat circsize = 0.1;\nvec4 circolor1 = vec4(1.0,0.0,0.0,0.0);\n\nvec2 circpos2 = vec2(0.55, 0.5);\nvec4 circolor2 = vec4(0.0,1.0,0.0,0.0);\n\nvec2 circpos3 = vec2(0.5, 0.4);\nvec4 circolor3 = vec4(0.0,0.0,1.0,0.0);\n\nvec4 bgcolor = vec4(1.0,1.0,1.0,1.0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float aspectRatio = iResolution.x/iResolution.y;\n    \n    uv.x *= aspectRatio;\n    \n    circpos3.y += (sin(iTime*4.0)+1.0)/10.0;\n    \n    if(length(circpos1 - uv) < circsize)\n        circolor1 = vec4(circolor1.rgb, 0.5);\n    if(length(circpos2 - uv) < circsize)\n        circolor2 = vec4(circolor2.rgb, 0.5);\n    if(length(circpos3 - uv) < circsize)\n        circolor3 = vec4(circolor3.rgb, 0.5);\n    vec3 col = vec3(1.0,1.0,1.0);\n    col = mix(bgcolor.rgb, circolor1.rgb, circolor1.a);\n    col = mix(col.rgb, circolor2.rgb, circolor2.a);\n    col = mix(col.rgb, circolor3.rgb, circolor3.a);\n    \n    //t = (sin(iTime*2.0)+1.0)/2.0;\n    \n    //vec4 nyan = texture(iChannel0, uv);\n\n    //vec4 star = texture(iChannel1, uv);\n    \n    //vec3 col = mix(nyan.rgb, star.rgb, t);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mlcfzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[299, 299, 356, 406, 1280]], "test": "valid"}
{"id": "MldBRN", "name": "Nature Project- Ocean Waves", "author": "tiff", "description": "Mimicking ocean waves", "tags": ["oceanwaves"], "likes": 0, "viewed": 85, "published": "Public", "date": "1538894032", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random(vec2 v) {\n  return fract(tan(dot(v*.1, vec2(200.654, .746)))*.4);\n}\n\n//drawing a band\nfloat Band(float t, float start, float end, float blur){\n    float step1 = smoothstep(start - blur, start + blur, t); //start of band\n    float step2 = smoothstep(end + blur, end - blur, t); //end of band\n\n    return step1*step2; //multiplying both sides to make the band \n}\n\n//drawing a rectangle\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur){\n\tfloat band1 = Band(uv.x, left, right, blur); //vertical band\n    float band2 = Band(uv.y, bottom, top, blur); //horizontal band\n    return band1 * band2; //multiplying the bands to make a rectangle\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float t = iTime*1.5;\n    \n    uv -= .5; //-0.5 <> 0.5\n    uv.x *= iResolution.x/iResolution.y;\n    uv*= 7.;\n    uv = fract(uv)-.5;\n    uv *= smoothstep(uv.x, uv.x, .8);\n    \n    vec3 color = vec3(0.1, 0.35, 1.);\n    vec3 col = vec3(1.);\n    \n    float mask = 0.;\n    float mask2 = 0.;\n    \n    float x = uv.x;\n    float m = sin(t+x*6.2)*.15;\n    float m1 = cos(t-x*6.2)*.15; //cos curve for second wave\n    float y = uv.y-m;\n    float y1 = uv.y-m1;\n       \n\n    mask = Rect(vec2(x,y), -1., 1., -.35, -.15, .01); //top sine wave\n    mask2 = Rect(vec2(x,y1), -1., 1., .15, .35, .01); //bottom cosine wave\n   \n    float c = mix(uv.x, uv.x, iTime);\n                  \n    //color = color/random(uv)-random(uv)+c;\n    //color += smoothstep(color.x*color.y, color.x*color.y, length(uv.xy));\n    color = mix(color/random(uv), color-random(uv), .5);\n    \n    col = color+mask+mask2; \n    \n    \n    // Output to screen\n    fragColor = vec4(col,color);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MldBRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 80], [82, 99, 155, 155, 373], [375, 397, 479, 479, 681], [684, 684, 741, 796, 1795]], "test": "valid"}
{"id": "MldfD7", "name": "laplace kernel asymptote Isoline", "author": "ollj", "description": "mouse on right end side approaches noise IFF pi is poorly estimated 3.14\nelse (pi=acos(-1.)) would look ideal, wich it never will\nand so i found a strange (only strange for mouse all the way to the right) thesis more confirmed, while 3 domains oscillate.", "tags": ["noise", "sobel", "filter", "pi", "precision", "matrix", "contour", "fwidth", "fwidth", "isoline", "laplace", "planck", "calculus", "epslon", "irrational"], "likes": 7, "viewed": 637, "published": "Public API", "date": "1539929693", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//self: https://www.shadertoy.com/view/MldfD7\n//parents:\n//https://www.shadertoy.com/view/lltBWM\n//https://www.shadertoy.com/view/ldfBzs\n//https://www.shadertoy.com/view/XdlyzS\n\n//modulation==number of lines== linedensity\n#define linedensity ((1.-(iMouse.x+1.)/iResolution.x))\n\n/*\n\nassuming we have infinite precision, then:\nred-green=blue\nred-green=blue\nred-green=blue\nbut we do not have infinite precision, but still inherit irrational pi, so the difference is \"noise\"\nThat difference is tiny, and amplified by smoothstep() to a point where \"yellow\" ceases to be noticable.\n(best iff paused on time==0)\n\ncalculus with short intervals and short wavelengths in general are funny in this asymptotic way.\nto a point where you forget that [blue] is a crude neighborhood-loop , while [red-green] is analysis.\n\nblue layer is a laplachian filter; 3 2d neighborhoods (a lot like a common voronoi, but for filtering)\nred and green are fwidth() estimates (isoline and zebra scaling)\n, to normalize an isoline by dividinf by an estimated first derivative\n\n\nthis allows you to use                fwidth(cos(gradient/pi))   (==Zebra) \n                      or TriangleWave(fwidth(cos(gradient/pi)))  (==Isoline contour)\nto approach the asymptotic case of a laplachian \n  (slide mouse to the right to approach asymptote of a [minimal interval of 1px]==[maximum linedensity of 1Line/pixel])\n  (that makes the asymptotic case a space-filling case\n , which by definition should appear like a fractal z-order curve, but defined by a (distorting) gradient.\n\n, but the asymptote is approached via calculus+TaylorPolynomials (inherent in fwidth())\nfor a better understnding of a good hash just being about a low precision epsilon, close to an asymptote.\n\n//this is done on a trigonometric wave; cos(gradient/pi)\n, and the precision of pi makes a HUGE difference between the red green layer\n, and the difference between red and green fits to the degenerated case of blue.\n\nmouse on right end side approaches noise IFF pi is poorly estimated 3.14\nelse (pi=acos(-1.)) would look ideal, wich it never will\nand so i found a strange (only strange for mouse all the way to the right) thesis more confirmed, while 3 domains oscillate.\n*/\n\nconst mat3 laplace=mat3\n (0, 1,0\n ,1,-4,1\n ,0,1,0);//laplache filter matrix\n\n\nconst mat3 sobel=mat3\n (1,0,-1\n ,2,0,-2\n ,1,0,-1);//sovel filter matrix\n\n    \n\nfloat wave(float x, float y){return //noisy epcircles\n  sin(10.*x+10.*y)/5. \n +sin(20.*x+15.*y)/3. \n -sin( 4.*x+10.*y)/4. \n +sin(y)          /2.\n +sin(x*x*y*20.)\n +sin(x*20.+ 4.)  /5.\n +sin(y*30.    )  /5.\n +sin(x        )  /4.\n ;}\n\n#define MousePi mix(acos(-.1),3.14,(iMouse.y-1.)/iResolution.y)\n//mix(acos(-.1),3.14,(iMouse.y-1.)/iResolution.y)\n\n\n\nfloat fwidCosZebra(vec2 u,float p){\n ;float s= (wave(u.x, u.y))\n ;s= (-cos(s/linedensity*p*2.))\n ;s=smoothstep(.1*linedensity,.0,.1*((s/8.)/fwidth((s))))\n ;return s;}\nfloat fwidCosIso(vec2 u,float p){\n ;float sum = (wave(u.x, u.y))\n ;sum= (sin(sum/linedensity*p))\n ;sum=1.-abs((smoothstep(.025*linedensity,-.025*linedensity,.1*linedensity*((((sum/8.))/fwidth((sum))))))*2.-1.)\n ;return sum;}\n//above 2 are tinted green for p=3.14     ,which makes for a decent hash\n//above 2 are tinted red   for p=acos(-1.),which also shows the pattern of \"blue\" below in it\n//below is always tinted blue, it appears to be a red afterglow, but thats not an opticall illusion!\nfloat neighbor33laplace(vec2 u\n){float sum=0.\n ;for(int i = 0; i < 3; i++\n ){for(int j = 0; j < 3; j++\n  ){vec2 point = u +(vec2(i, j) -  1.) / iResolution.xy\n   ;float color=wave(point.x, point.y)\n   ;color=fract(color/linedensity)  // make it edgy\n   ;sum+=color*laplace[i][j]//acc+\n   ;}}return sum;}\n\nvoid mainImage(out vec4 o,vec2 u\n){u=u/iResolution.xy\n ;vec2 m=iMouse.xy/iResolution.xy\n ;vec4 c=vec4(0)\n //u.y looks less like noise and morelike seeing a precision error.\n //needs base-pi arithmetic ;)\n //u.x has less precision, appears \"better\", as it hides in its onw noise.\n ;     if(u.x<.5)c.x=  fwidCosIso(u-m,acos(-1.))//red left         half\n ;else if(u.y<.5)c.x=fwidCosZebra(u-m,acos(-1.))//red lower  right quadrant\n ;     if(u.x<.5)c.y=  fwidCosIso(u-m,3.14)     //gren left        half\n ;else if(u.y<.5)c.y=fwidCosZebra(u-m,3.14)     //gren lower right quadrant\n ;c.z=neighbor33laplace(u-m)                    //blue all         quadrants\n ;//c.x=mix(0.,c.x,cos(iTime*1.16)*.5+.5)//oscillate brightness of red   over time\n ;//c.y=mix(0.,c.x,cos(iTime*2.16)*.5+.5)//oscillate brightness of green over time\n ;//c.z=mix(0.,c.z,cos(iTime     )*.5+.5)//oscillate brightness of blue  over time\n ;c.xyz=mix(vec3(0),c.xyz,cos(iTime*vec3(1,1.62,2.61))*.5+.5)//3 above lines in one\n \n //while red and green only differ in the precision of Pi=3.14 OR pi=acos(-1.)\n //note how ONLY the (nearly) [degenerate case] of [mouse all the way to the right] lacks yellow\n //, because then green and red differ too much.\n //the strangest thing here is that there is a smooth transition towards that asymptote.\n // AND that even the asymptotic case is a very common laplachian (==the blue layer)\n ;o=vec4(c.xyz,1)\n ;}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MldfD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2368, 2368, 2397, 2397, 2599], [2718, 2718, 2753, 2753, 2884], [2885, 2885, 2918, 2918, 3109], [3110, 3378, 3411, 3411, 3681], [3683, 3683, 3718, 3718, 5090]], "test": "valid"}
{"id": "MldfDn", "name": "Bottom of Water", "author": "kaneta", "description": "caustics technique reference\nhttps://medium.com/@evanwallace/rendering-realtime-caustics-in-webgl-2a99a29a0b2c", "tags": ["3d", "raymarching", "water", "caustics"], "likes": 48, "viewed": 3292, "published": "Public API", "date": "1539257354", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Use_Perlin\n//#define Use_Value\n//#define Use_Simplex\n\n// ========= Hash ===========\n\n// Grab from https://www.shadertoy.com/view/4djSRW\n//#define MOD3 vec3(.1031,.11369,.13787)\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n// ========= Noise ===========\n\nfloat value_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n        \t\t\tmix(hash31(pi + vec3(0, 0, 0)), hash31(pi + vec3(1, 0, 0)), w.x),\n        \t\t\tmix(hash31(pi + vec3(0, 0, 1)), hash31(pi + vec3(1, 0, 1)), w.x), \n                    w.z),\n        \t\tmix(\n                    mix(hash31(pi + vec3(0, 1, 0)), hash31(pi + vec3(1, 1, 0)), w.x),\n        \t\t\tmix(hash31(pi + vec3(0, 1, 1)), hash31(pi + vec3(1, 1, 1)), w.x), \n                    w.z),\n        \t\tw.y);\n}\n\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    // thx nikita: https://www.shadertoy.com/view/XsX3zB\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nfloat noise(vec3 p) {\n#ifdef Use_Perlin\n    return perlin_noise(p * 2.0);\n#elif defined Use_Value\n    return value_noise(p * 2.0);\n#elif defined Use_Simplex\n    return simplex_noise(p);\n#endif\n    \n    return 0.0;\n}\n\n\nfloat sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat bottom(vec3 ro, vec3 ray)\n{\n    float t = 0.0;\n    for (int i = 0; i < 256; i++) {\n        float res = plane(ro + ray * t, vec4(0.0, 1.0, 0.0, 10.0));\n        if( res < 0.00001 ) return t;\n        t += res;\n    }\n\n    return -1.0;\n}\n\nfloat map(vec3 p)\n{\n\tfloat pl = plane(p, vec4(0.0, 1.0, 0.0, 10.0));\n    float s = sphere(p - vec3(1.5, -8.0, 0.0), 1.0);\n    float b = box(p - vec3(-1.5, -8.0, 0.0), vec3(1.0));\n    float d = min(pl, s);\n    d = min(b, d);\n    return d;\n}\n\nvec2 scene(vec3 ro, vec3 ray)\n{\n    float t = 0.0;\n    for (int i = 0; i < 256; i++) {\n        float res = map(ro+ray*t);\n        if( res < 0.00001 ) return vec2(t, res);\n        t += res;\n    }\n\n    return vec2(-1.0);\n}\n\nvec2 intersect2(vec3 ro, vec3 ray)\n{\n    float t = 0.0;\n    for (int i = 0; i < 256; i++) {\n        float res = plane((ro+ray*t), vec4(0.0, 1.0, 0.0, 10.0));\n        if( res < 0.00001 ) return vec2(t, res);\n        t += res;\n    }\n\n    return vec2(-1.0);\n}\n\nvec2 water(vec3 ro, vec3 ray)\n{\n    float t = 0.0;\n    for (int i = 0; i < 64; i++) {\n        float res = plane(ro+ray*t, vec4(0.0, 1.0, 0.0, -1.0));\n        if( res < 0.0001 ) return vec2(t, res);\n        t += res;\n    }\n\n    return vec2(-1.0);\n}\n\nvec3 waterNormal(vec3 p, float e) {\n    vec3 ee = vec3(e, 0., 0.);\n    vec3 pp = p * 1.0;\n\tfloat h1 = noise(p + ee.xyy);\n    float h2 = noise(p - ee.xyy);\n    float h3 = noise(p + ee.yyx);\n    float h4 = noise(p - ee.yyx);\n    vec3 du = vec3(1., 0., h2 - h1);\n    vec3 dv = vec3(0., 1., h4 - h3);\n    return normalize(cross(du, dv)) * 0.5 + 0.5;\n    //return vec3(h1, h2, h3);\n}\n\nfloat caustics(vec3 p, vec3 lp) {\n    vec3 ray = normalize(p - lp);\n\n    vec2 shadow = scene(lp, ray);\n    float l = distance(lp + ray * shadow.x, p);\n    if (l > 0.01) {\n        return 0.0;\n    }\n\n    vec2 d = water(lp, ray);\n    vec3 waterSurface = lp + ray * d.x;\n\n    vec3 refractRay = refract(ray, vec3(0., 1., 0.), 1.0/1.333);\n    float beforeHit = bottom(waterSurface, refractRay);\n    vec3 beforePos = waterSurface + refractRay * beforeHit;\n\n    vec3 noisePos = waterSurface + vec3(0.,iTime * 2.0,0.);\n    float height = noise(noisePos);\n    vec3 deformedWaterSurface = waterSurface + vec3(0., height, 0.);\n\n    refractRay = refract(ray, waterNormal(noisePos, 0.5), 1.0/1.333);\n    float afterHit = bottom(deformedWaterSurface, refractRay);\n    vec3 afterPos = deformedWaterSurface + refractRay * afterHit;\n\n    float beforeArea = length(dFdx(beforePos)) * length(dFdy(beforePos));\n    float afterArea = length(dFdx(afterPos)) * length(dFdy(afterPos));\n    return max(beforeArea / afterArea, .001);\n}\n\nvec3 normal(vec3 pos, float e )\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nmat3 createCamera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // fragment position\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // camera\n    vec3 ro = vec3(sin(iTime * 0.1) * 10.0, 0.0, cos(iTime * 0.1) * 10.0) * 2.0;\n    vec3 ta = vec3(0.0, -8.0, 0.0);\n    mat3 cm = createCamera(ro, ta, 0.0);\n    vec3 ray = cm * normalize(vec3(p, 4.0));\n    \n    // marching loop\n    vec2 res = scene(ro, ray);\n    \n    // hit check\n    if(res.y > -0.5) {\n        vec3 p = ro + ray * res.x;\n       \tvec3 n = normal(p, 0.0001);\n        vec3 l = vec3(10.0, 10.0, 10.0);\n        vec3 v = -normalize(p - l);\n        fragColor = vec4(normal(ro + ray * res.x, 0.0001), 1.0);\n        float c = caustics(ro + ray * res.x, l) * 0.6;\n        vec3 co = vec3(c,c,c) *  + vec3(0.02,0.15,0.27);\n        float li = max(dot(v, n), 0.0);\n        vec3 col = co * li + vec3(0.02,0.15,0.27);\n        col = pow(col, vec3(1.0/2.2));\n        fragColor = vec4(mix(col, vec3(0.02,0.15,0.27), res.x / 100.0), 1.0);\n    }else{\n        fragColor = vec4(vec3(0.0), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MldfDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[232, 232, 255, 255, 370], [372, 372, 394, 394, 546], [580, 580, 607, 607, 1140], [1142, 1142, 1170, 1170, 2109], [2111, 2111, 2140, 2140, 2857], [2859, 2859, 2880, 2880, 3074], [3077, 3077, 3110, 3110, 3134], [3136, 3136, 3165, 3165, 3252], [3254, 3254, 3285, 3311, 3342], [3344, 3344, 3377, 3377, 3582], [3584, 3584, 3603, 3603, 3823], [3825, 3825, 3856, 3856, 4045], [4047, 4047, 4083, 4083, 4303], [4305, 4305, 4336, 4336, 4552], [4554, 4554, 4589, 4589, 4932], [4934, 4934, 4967, 4967, 5942], [5944, 5944, 5977, 5977, 6185], [6187, 6187, 6235, 6235, 6414], [6416, 6416, 6473, 6498, 7500]], "test": "valid"}
{"id": "MldfR4", "name": "Nature Project- Snakes", "author": "cake7914", "description": "snakies", "tags": ["snakes"], "likes": 1, "viewed": 93, "published": "Public", "date": "1538869912", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){ //rotation\n  float r = sin(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\n\nfloat pole(vec2 v, float r){\n  return length(v)-r;\n}\n/*float sphere(vec3 v, float r){\n  return length(v)-r;\n}\nfloat box(vec3 v, float r, float m) {\n  return max(length(v.xy)-r, abs(v.z)-m);\n}\n*/\n\n\nfloat mixColors(float r, float v, float z){ //mixes colors together\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){ //mixes the shapes together\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){ \n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n//=======================\n\nShape snakes(vec3 c){\n  Shape shape;\n  float snake;\n  shape.dist = 100.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n\n  // Shape Attributes\n  float twist = 10.; // Snake Repeat\n  float snakeOffset = 9.; // Snake Offset\n\n\n  // Stems\n  vec3 i = c;\n    i.xy *= rot(c.x*0.09+iTime*.5); //rotation\n    float detail = pModPolar(i.xz, twist);  \n    float x = mix(10., 4., mod(detail, 8.)); // Larger Ripples\n    i.x -= snakeOffset; // Offset snakes\n    i.x = repeat(i.x, 20.); //repeat them\n\n  \tfloat snakeWidth = sin(iTime*2.)+5.; // width of stems\n  \tsnake = pole(i.xz, snakeWidth+0.002*cos(i.y*x));\n    vec4 color = vec4(0.0, 0.95, 0.85, 1.); //color of seaweed\n\n  shape.dist = snake;\n  shape.color = color;\n\n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape snakes = snakes(c);\n  return snakes;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y; //coordinate system\n\n  \n  vec3 cam = vec3(0., 10., -400.); //camera location\n  vec3 f = normalize(vec3(v, 6.));\n  vec3 scene = cam;\n  fragColor = vec4(.1, .7, .1, 1.); //background color\n\n  // Ray Marcher\n  for(float x = 0.1 ; x <= 1.; x += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.01){\n      fragColor = c.color*(.66-x); // Hit  - invert pixels- \"brightness\" of inverting\n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MldfR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 164, 186, 186, 253], [255, 255, 273, 284, 354], [357, 357, 385, 385, 409], [554, 554, 597, 621, 664], [666, 666, 709, 737, 803], [805, 805, 844, 844, 1001], [1029, 1029, 1050, 1050, 1767], [1770, 1770, 1788, 1788, 1835], [1837, 1837, 1894, 1894, 2405]], "test": "valid"}
{"id": "Mldfz2", "name": "Smoky effect", "author": "Thominator", "description": "Trying noise chaining to do smoky effect.", "tags": ["noise"], "likes": 4, "viewed": 160, "published": "Public", "date": "1540377400", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 light = vec3(0, 0, 0);\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n//2D Noise function from user iq\nfloat hash(vec2 p)\n{\n    p  = 45.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n//3D Noise function from user iq\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n\nfloat rand(vec2 co){\n    return 2.0*cos(fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \t//Pixel coordinate between -1 and 1\n  \tvec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n    //Pixel coordinate between 0 and 1\n    vec2 p = fragCoord.xy / iResolution.xy;\n    //Pixel coordinate adapted to the resolution\n    vec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\t\n    //Setting up the light position\n    vec2 mouse = (iMouse.xy/iResolution.xy)*2.0-1.0;\n    light = vec3(mouse, 0);\n    \n    //Computing the first fractal noise value\n\tfloat f = 0.0;\n\tuv *= 8.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n    //Using the noise value to give the point a depth\n\tvec3 point1 = vec3(pixel, f);\n    \n    float a=iTime*0.065;\n  \tpoint1 = rotateY(point1, a);\n    //point1 *= 1.5+cos(iTime*0.05)/2.0;\n    \n    //Computing the second factal noise value using the point previously calculated\n\tvec3 q = 7.0*point1;\n    float f2  = 0.5000*noise( q ); q = m3*q*2.01;\n    f2 += 0.2500*noise( q ); q = m3*q*2.02;\n    f2 += 0.1250*noise( q ); q = m3*q*2.03;\n    f2 += 0.0625*noise( q ); q = m3*q*2.01;\n   \n    //Using the value to compute a new point\n    vec3 point2 = vec3(pixel, f2);\n    \n    //Calculatinf the distance between the light and thoses points\n\tvec3 diff = light-point1;\n    float dist = sqrt(dot(diff, diff));\n    float c1 = 1.0/(dist*dist*dist*5.0);\n    \n    vec3 diff2 = light-point2;\n    float dist2 = sqrt(dot(diff2, diff2));\n    float c2 = 1.0/(0.0001+(dist2*dist2*dist2*5.0));\n\n    //uv = p*vec2(iResolution.x/iResolution.y,1.0);;\n    //fragColor = (f2*c2)*texture(iChannel0, vec2(uv.x+0.05*f, uv.y+0.05*f));//*/ vec4(f, f, f, 1.0);\n\t\n    //if(iMouse.w < 0.0)\n\t\tfragColor = f*vec4(c2, c2, c2, 1);\n    //else\n\t\t//fragColor = f2*vec4(c1, c1, c1, 1);    \n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mldfz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 187, 187, 285], [287, 287, 318, 318, 417], [419, 419, 450, 450, 549], [551, 584, 604, 604, 708], [710, 710, 736, 736, 1030], [1033, 1066, 1086, 1086, 1181], [1183, 1183, 1209, 1209, 1683], [1686, 1686, 1706, 1706, 1787], [1789, 1789, 1846, 1884, 3693]], "test": "valid"}
{"id": "Mldfzr", "name": "my house", "author": "rdcorning", "description": "this is a house", "tags": ["egp200"], "likes": 0, "viewed": 48, "published": "Public", "date": "1538676875", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//house data\nvec2 housePos = vec2(0.5, 0.4);\nfloat houseLengthX = 0.3;\nfloat houseLengthY = 0.2;\nvec3 houseColor = vec3(0.9, 0.9, 0.0);\n//window1 data\nvec2 windowPos = vec2(0.35, 0.35);\nvec3 windowColor = vec3(0.2, 0.5, 1.0);\nfloat windowLength = 0.07;\n//window2 data\nvec2 window2Pos = vec2(0.65, 0.35);\nvec3 window2Color = vec3(0.2, 0.5, 1.0);\nfloat window2Length = 0.07;\n//chimny data\nvec2 chimnyPos = vec2(.35, 0.8);\nvec3 chimneyColor = vec3(0.8, 0.4, 0.0);\nfloat chimnyLengthX = 0.05;\nfloat chimnyLengthY = 0.075;\n//sunset\nfloat brightness = 1.0;\n\nvec4 BG = vec4(0.0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //list to do\n    \n    //1. make rectange for house\n    //2. make 2 square for windows\n    //3. make square for chimny\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aRatio = iResolution.y / iResolution.x;\n    uv.y *= aRatio;\n    \n    //----------------------------------------------------------------------------------------------------------------------\n    //create house\n    vec4 houseLayer = vec4(0.0);\n    housePos.y *= aRatio;\n    if((length(housePos.x - uv.x) < houseLengthX) && (length(housePos.y - uv.y) < houseLengthY))\n    {\n        houseLayer = vec4(houseColor, 1.0);\n    }\n    //----------------------------------------------------------------------------------------------------------------------\n    //create window1\n    vec4 windowLayer = vec4(0.0);\n    windowPos.y *= aRatio;\n    if((length(windowPos.x - uv.x) < windowLength) && (length(windowPos.y - uv.y) < windowLength))\n    {\n        windowLayer = vec4(windowColor, 0.7);\n    }\n    //----------------------------------------------------------------------------------------------------------------------\n    //create window2\n    vec4 window2Layer = vec4(0.0);\n    window2Pos.y *= aRatio;\n    if((length(window2Pos.x - uv.x) < window2Length) && (length(window2Pos.y - uv.y) < window2Length))\n    {\n        window2Layer = vec4(window2Color, 0.7);\n    }\n    //----------------------------------------------------------------------------------------------------------------------\n    //create chinmey\n    chimnyPos.y *= aRatio;\n    vec4 chinmeyLayer = vec4(0.0);\n    if((length(chimnyPos.x - uv.x) < chimnyLengthX) && (length(chimnyPos.y - uv.y) < chimnyLengthY))\n    {\n        chinmeyLayer = vec4(chimneyColor, 1.0);\n    }\n    //----------------------------------------------------------------------------------------------------------------------\n    //create sunset\n    vec4 sunSet = vec4(1.0, uv.y, 0.3, 1.0);\n   \tsunSet.rg *= abs(cos(iTime) * brightness);\n\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec4 Comp = mix(BG, sunSet, sunSet.a);\n    Comp = mix (Comp, houseLayer, houseLayer.a);\n    Comp = mix (Comp, windowLayer, windowLayer.a);\n    Comp = mix (Comp, window2Layer, window2Layer.a);\n    Comp = mix (Comp, chinmeyLayer, chinmeyLayer.a);\n\n\n\n\n    \n   \tfragColor = Comp;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mldfzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[573, 573, 630, 807, 3001]], "test": "valid"}
{"id": "MljyRd", "name": "Space-filling curve", "author": "al13n", "description": "A Peano-like curve in 3d.\n\n(I wanted to make more out of it (there's some commented out unfinished stuff in the code, try commenting out the first line of sdf_particle) but never got around to doing it, so publishing as is.)", "tags": ["procedural", "fractal", "hilbert", "spacefilling"], "likes": 18, "viewed": 574, "published": "Public API", "date": "1538796218", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 100\n#define STOPDIST 1e-3\n#define FUDGE 1.\n#define ITERS 4\n#define PI 3.141592653589793\n\nvec3 color=vec3(1.,1.,1.);\nvec3 cam_pos;\nfloat total_len;\n\nvec3 peano_transform(vec3 p){\n    const float blockiness = ITERS>0 ? .8 : 1.;\n    const float gap=pow(2.,float(-ITERS))/(1.-pow(2.,float(-ITERS))+blockiness);\n    const float final_piece=2.*(pow(2.,float(-ITERS))-gap*(1.-pow(2.,float(-ITERS)))) + PI*.5*gap;\n    \n    float sublen=total_len=pow(8.,float(ITERS))*final_piece;\n    float s=1.;\n\tfloat add=0.;\n    float rev=1.;\n    float flip=1.;\n    for(int i=0;i<ITERS;++i){\n        sublen*=1./8.;\n        float a=(s+gap)*.5;\n        vec3 sp=sign(p);\n        if(sp==vec3(-1.,-1.,-1.)){p=vec3(+p.z+a,+p.y+a,+p.x+a); add-=rev*sublen*3.5; flip*=-1.; }\n        if(sp==vec3(+1.,-1.,-1.)){p=vec3(+p.z+a,+p.x-a,+p.y+a); add-=rev*sublen*2.5; }\n        if(sp==vec3(+1.,+1.,-1.)){p=vec3(+p.z+a,+p.x-a,-p.y+a); add-=rev*sublen*1.5; rev*=-1.; }\n        if(sp==vec3(-1.,+1.,-1.)){p=vec3(-p.y+a,-p.x-a,+p.z+a); add-=rev*sublen*0.5; flip*=-1.; }\n        if(sp==vec3(-1.,+1.,+1.)){p=vec3(-p.y+a,-p.x-a,-p.z+a); add+=rev*sublen*0.5; flip*=-1.; rev*=-1.; }\n        if(sp==vec3(+1.,+1.,+1.)){p=vec3(-p.z+a,+p.x-a,-p.y+a); add+=rev*sublen*1.5; }\n        if(sp==vec3(+1.,-1.,+1.)){p=vec3(-p.z+a,+p.x-a,+p.y+a); add+=rev*sublen*2.5; rev*=-1.; }\n        if(sp==vec3(-1.,-1.,+1.)){p=vec3(+p.y+a,-p.z+a,+p.x+a); add+=rev*sublen*3.5; rev*=-1.; }\n        s=(s-gap)*.5;\n    }\n    if(p.y>-gap && p.z<gap) p=vec3(p.x,length(p.yz-vec2(-gap,gap))-gap,(atan(p.y+gap,gap-p.z)-PI*.25)*gap);\n    else if(-p.y>p.z) p=vec3(p.x,-p.z,p.y+(1.-PI*.25)*gap);\n    else p.z+=(PI*.25-1.)*gap;\n    p.z=p.z*rev+add;\n    p.x*=flip;\n    return p;\n}\n\nfloat sdf_particle(vec3 p){\n    return length(p.xy)-.02;\n    float z=p.z*7.+iTime;\n    p.xy*=mat2(cos(z*1.3),sin(z*1.3),-sin(z*1.3),cos(z*1.3));\n    p.yz*=mat2(cos(z*1.7),sin(z*1.7),-sin(z*1.7),cos(z*1.7));\n    p.zx*=mat2(cos(z*2.1),sin(z*2.1),-sin(z*2.1),cos(z*2.1));\n    p=abs(p);\n    //return max(max(p.x,p.y),p.z)-.02;\n    return length(p)-.02;\n}\n\nfloat sdf_inner(vec3 p){\n    const float period=.05;\n    float z=p.z+iTime*.1;\n    p.z=mod(z,period)-.5*.05;\n    if(mod(floor(z/period),10.)==0.) color=vec3(.8,.2,.2)*4.;\n    else color=vec3(.2,.8,.2)*1.5;\n    return sdf_particle(p);\n    \n    const float blockiness = ITERS>0 ? .5 : 1.;\n    const float gap=pow(2.,float(-ITERS))/(1.-pow(2.,float(-ITERS))+blockiness);\n    const float final_piece=2.*(pow(2.,float(-ITERS))-gap*(1.-pow(2.,float(-ITERS)))) + PI*.5*gap;\n    //color=vec3(fract(p.z), fract(p.z*2.3), fract(p.z*1.7))*2.;\n \t\n    //float ang=sin(p.z+iTime*1.3)*sin(iTime*3.);\n    float ang=p.z*2.;\n    float thickness=pow(max(0.,sin(p.z*3.+iTime*3.)-.95)*20.,.4)*.03+.02;\n    //float thickness=step(.93,sin(p.z*3.+iTime*3.))*.03+.02;\n    //float thickness=.04;\n    p.xy*=mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\n    p.xy=abs(p.xy);\n    //return length(p.xy)-thickness;\n    return max(p.x,p.y)-thickness;\n}\n\nfloat sdf_main(vec3 p){\n    vec3 ap=abs(p);\n    float d_bbox=-1.1+max(max(ap.x,ap.y),ap.z);\n    float d_cam=.2-distance(p,cam_pos);\n    float d_cuts=max(d_bbox,d_cam);\n\n    float d_curve=sdf_inner(peano_transform(p));\n    if(d_cuts>d_curve && abs(d_curve)<1e-2) color=vec3(3.);\n    return max(d_cuts,d_curve);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy*2.-iResolution.xy)/iResolution.x;\n    vec2 mouse=(iMouse.xy*2.-iResolution.xy)/iResolution.x;\n    vec2 click=(iMouse.zw*2.-iResolution.xy)/iResolution.x;\n    \n    vec2 pan;\n    if(iMouse.z<=0.){\n        //pan=vec2(iTime/3., sin(iTime/2.)*.4); // inside view\n        pan=vec2(iTime/1., sin(iTime/2.)*.4); // outside view\n    }else{\n     \tpan=mouse-click;\n        pan.x*=6.;\n        pan.y*=1.5;\n    }\n\n    //vec3 pos0=vec3(sin(pan.x),pan.y,cos(pan.x))*.8; // inside view\n    vec3 pos0=vec3(sin(pan.x),pan.y,cos(pan.x))*3.; // outside view\n    cam_pos=pos0;\n    //vec3 dir=normalize(cross(-pos0,vec3(0.,1.,0.))); // inside view\n    vec3 dir=normalize(-pos0); // outside view\n    vec3 xdir=normalize(cross(vec3(0.,1.,0.),dir));\n    vec3 ydir=normalize(cross(xdir,dir));\n    dir+=uv.x*xdir+uv.y*ydir;\n    dir=normalize(dir);\n\n    vec3 pos=pos0;\n    for(int i=0;i<STEPS;++i){\n    \tfloat d=sdf_main(pos)*FUDGE;\n        pos+=dir*d;\n        if(abs(d)<STOPDIST){\n            fragColor=vec4(vec3(sqrt(float(i)/float(STEPS)))*color,1.);\n            return;\n        }\n        if(length(pos)>1e3){\n            fragColor=vec4(vec3(sqrt(float(i)/float(STEPS)))*vec3(1.,.5,.7),1.);\n            return;\n        }\n    }\n\tfragColor = vec4(.2,.5,.7, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljyRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 191, 191, 1707], [1709, 1709, 1736, 1736, 2059], [2061, 2061, 2085, 2085, 2978], [2980, 2980, 3003, 3003, 3291], [3293, 3293, 3350, 3350, 4613]], "test": "valid"}
{"id": "MltBRj", "name": "unit quaternion as rotation", "author": "GraphicsFromScratch", "description": "quaternion", "tags": ["quaternion"], "likes": 4, "viewed": 487, "published": "Public", "date": "1540320989", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define T_MAX 15.0\n\nstruct point_light\n{\n    vec3 p;\n    vec3 i;\n};\n\nvec4 quat(in vec3 v, in float a)\n{\n    return vec4(v * sin(a / 2.0), cos(a / 2.0));\n}\n\nvec4 quat_inv(in vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\nvec4 p2q(in vec3 p)\n{\n    return vec4(p, 0);\n}\n\nvec4 q_mul(in vec4 q1, in vec4 q2)\n{\n    return vec4(q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y, \n                q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x, \n                q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w, \n                q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z);\n}\n\nvec3 rotate(in vec3 p, in vec3 v, in float a)\n{\n    vec4 q = quat(v, a);\n    return q_mul(q_mul(q, p2q(p)), quat_inv(q)).xyz;\n}\n\nvec3 rotateq(in vec3 p, in vec4 q)\n{\n    return q_mul(q_mul(q, p2q(p)), quat_inv(q)).xyz;\n}\n    \nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nfloat obj_sdf(in vec3 p)\n{\n    vec4 r1 = quat(vec3(0,1,0), 0.0);\n    vec4 r2 = quat(vec3(0,1,0), 1.7);\n    vec4 r = normalize(mix(r1, r2, 0.5 + 0.5*sin(iTime)));\n    p = rotateq(p, r);\n    \n    vec3 dp = vec3(0, 1, 0);\n\tfloat sphere_sdf = length(p - dp) - 1.0;\n    float box_sdf = sdBox(p - dp, vec3(0.8));\n    float res = max(-sphere_sdf, box_sdf);\n    return res;\n}\n\nfloat sdf(in vec3 p, out int matid)\n{\n    float obj_sdf = obj_sdf(p);\n    float floor_sdf = abs(p.y);\n    \n    float sdf = min(obj_sdf, floor_sdf);\n    if (sdf == obj_sdf)\n    {\n        matid = 1;\n    }\n    else\n    {\n        matid = 0;\n    }\n    \n    return sdf;\n}\n\nvec3 sdf_n(in vec3 p)\n{\n    vec3 res = vec3(0);\n    \n    int ignored;\n    res.x = sdf(p + vec3(0.001, 0, 0), ignored) - sdf(p, ignored);\n    res.y = sdf(p + vec3(0, 0.001, 0), ignored) - sdf(p, ignored);\n    res.z = sdf(p + vec3(0, 0, 0.001), ignored) - sdf(p, ignored);\n    \n    return normalize(res);\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, out int matid)\n{\n\tfloat t = 0.0;\n    matid = -1;\n    for (int i = 0; i < 256; ++i)\n    {\n        if (t > T_MAX)\n        {\n            break;\n        }\n        \n        int curr_matid = -1;\n\t\tfloat d = sdf(ro + t*rd, curr_matid);\n        if (d < 0.0001)\n        {\n            matid = curr_matid;\n            break;\n        }\n        t += d;\n    }\n    return t;\n}\n\nfloat dir_shadow(in vec3 p, in vec3 l)\n{\n    float t = 0.15;\n    float t_max = 20.0;\n    \n    float res = 1.0;\n    for (int i = 0; i < 256; ++i)\n    {\n        if (t > t_max) break;\n        \n        int ignored;\n        float d = sdf(p + t*l, ignored);\n        if (d < 0.01)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 8.0 * d / t);\n    }\n    \n    return res;\n}\n\nfloat point_shadow(in vec3 p, in vec3 light_p)\n{\n    vec3 l = normalize(light_p - p);\n        \n    float t = 0.15;\n    float t_max = distance(light_p, p);\n    \n    float res = 1.0;\n    for (int i = 0; i < 256; ++i)\n    {\n        if (t > t_max) break;\n        \n        int ignored;\n        float d = sdf(p + t*l, ignored);\n        if (d < 0.01)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 64.0 * d / t);\n    }\n    \n    return res;\n}\n\nfloat ao(in vec3 p, in vec3 n)\n{\n    float e = 0.1;\n    float res = 0.0;\n    \n#define AO_ITER 5\n    \n    int ignored;\n    float weight = 0.5;\n    for (int i = 1; i <= AO_ITER; ++i)\n    {\n        float d = e * float(i);\n        res += weight * (1.0 - (d - sdf(p + d * n, ignored)));\n        weight *= 0.5;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec2 fragCoord)\n{\n   \tvec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n     \n    float cam_d = 3.0;\n    float time = 0.6;\n    vec3 ro = vec3(cam_d*sin(time), 2.5, cam_d*cos(time));\n    vec3 at = vec3(0, 1, 0);\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0,1,0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 1.73 * cam_z);\n\t\n    vec3 sky = vec3(0.02);\n    vec3 col = vec3(0);\n    \n    int matid = -1;\n    float t = intersect(ro, rd, matid);\n    if (matid != -1)\n    { \n        vec3 p = ro + t*rd;\n        vec3 n = sdf_n(p);\n        \n#define PLIGHT_COUNT 1 \n        point_light plights[PLIGHT_COUNT];\n        plights[0] = point_light(vec3(2, 1, 1), vec3(20));\n\n        vec3 direct_light = vec3(0);\n        for (int plight_index = 0; plight_index < PLIGHT_COUNT; ++plight_index)\n        {\n            vec3 light_i = plights[plight_index].i;\n            vec3 light_p = plights[plight_index].p;\n        \tfloat light_r = dot(light_p - p, light_p - p);\n        \tvec3 l = normalize(light_p - p);\n        \n        \tdirect_light += point_shadow(p, light_p) * max(0.0, dot(n, l)) * light_i / (light_r * light_r);\n        }\n\n        vec3 indirect_light = ao(p, n) * sky;\n        \n        vec3 albedo = vec3(0.9);      \n\t\tcol = albedo * (0.7 * direct_light + indirect_light);\n        \n        col = mix(col, vec3(0), clamp(pow(t / T_MAX, 2.0), 0.0, 1.0));\n    }\n    \n    return col;\n}\n\nvec3 tonemap(in vec3 col)\n{\n    return col / (1.0 + col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if 0\n    vec3 col = tonemap(render(fragCoord));\n#else\n    vec3 col = vec3(0);\n    col += tonemap(render(fragCoord + vec2(0.25, 0.25)));\n    col += tonemap(render(fragCoord + vec2(0.25, -0.25)));\n    col += tonemap(render(fragCoord + vec2(-0.25, -0.25)));\n    col += tonemap(render(fragCoord + vec2(-0.25, 0.25)));\n    col /= 4.0;\n#endif\n    \n    col = sqrt(col);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltBRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 103, 103, 154], [156, 156, 182, 182, 214], [216, 216, 237, 237, 262], [264, 264, 300, 300, 558], [560, 560, 607, 607, 687], [689, 689, 725, 725, 780], [786, 786, 817, 817, 904], [906, 906, 941, 941, 986], [988, 988, 1014, 1014, 1355], [1357, 1357, 1394, 1394, 1622], [1624, 1624, 1647, 1647, 1928], [1930, 1930, 1986, 1986, 2331], [2333, 2333, 2373, 2373, 2732], [2734, 2734, 2782, 2782, 3204], [3206, 3206, 3238, 3238, 3539], [3541, 3541, 3573, 3573, 5058], [5060, 5060, 5087, 5087, 5119], [5121, 5121, 5178, 5178, 5576]], "test": "valid"}
{"id": "MltBRN", "name": "HeightMap plane", "author": "edo_m18", "description": "HeightMap plane test.\n\nIs this right approach to HeightMap distance field..?", "tags": ["hiehgtmap"], "likes": 6, "viewed": 564, "published": "Public", "date": "1538890634", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPS 0.01\n\nvec3 cameraPos = vec3(0.0, 2.0, 1.5);\nvec4 plane = vec4(0.0, 1.0, 0.0, 2.0);\nvec3 lightDir = vec3(1.0, 1.0, 1.0);\nvec3 skyCol = vec3(0, 0.745, 0.9);\n\nconst float heightFactor = 3.0; // height factor. will multiply to texture texel.\n\nfloat distPlane(in vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) * n.w;\n}\n\nfloat distFunc(in vec3 p)\n{\n    float d = distPlane(p, plane);\n    vec4 tex = texture(iChannel0, mod(p.xz * 0.2, 1.0));\n    tex *= heightFactor;\n\treturn d - tex.x;\n}\n\nvec3 getNormal(in vec3 p)\n{\n    const float e = EPS;\n    const vec3 dx = vec3(e, 0, 0);\n    const vec3 dy = vec3(0, e, 0);\n    const vec3 dz = vec3(0, 0, e);\n    \n    float d = distFunc(p);\n    \n    return normalize(vec3(\n    \td - distFunc(p - dx),\n    \td - distFunc(p - dy),\n    \td - distFunc(p - dz)\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 R = iResolution.xy;\n    vec2 p = (fragCoord.xy * 2.0 - R.xy) / min(R.x, R.y);\n    \n    vec4 m = iMouse / iResolution.xxxx;\n    \n    vec3 origin = cameraPos;\n    float t = iTime * 0.01;\n    const float cd = 3.0;\n    const float sp = 2.0;\n    float x = cos(t * sp) * cd;\n    float z = sin(t * sp) * cd;\n    \n    vec3 target = vec3(0, 2.5, 0);\n    \n    vec3 cPos = origin + vec3(x, 0, z);\n    //vec3 cDir = normalize(vec3(m.x, -m.y, -1.0));\n    vec3 cDir = normalize(cPos - target);\n    vec3 cSide = normalize(cross(cDir, vec3(0, 1, 0)));\n    vec3 cUp = normalize(cross(cSide, cDir));\n    \n    float targetDepth = 1.3;\n    \n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    \n    const int maxSteps = 128;\n    \n    float d = 0.0;\n    float depth = 0.0;\n    vec3 pos;\n    \n    vec3 col = vec3(0.0);\n    \n    for (int i = 0; i < maxSteps; i++)\n    {\n        pos = cPos + ray * depth;\n        d = distFunc(pos) * 0.1;\n        \n        if (d <= EPS)\n        {\n            break;\n        }\n        \n        depth += d;\n    }\n    \n    if (d <= EPS)\n    {\n        vec3 n = getNormal(pos);\n        float diff = dot(n, normalize(lightDir));\n        float fog = 1.0 - exp(-depth * 0.12);\n        col = mix(vec3(diff), skyCol, fog);\n    }\n    else\n    {\n        col = skyCol;\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltBRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 251, 287, 287, 321], [323, 323, 350, 350, 488], [490, 490, 517, 517, 801], [803, 803, 858, 858, 2223]], "test": "error"}
{"id": "MltBRS", "name": "test1023", "author": "candy9599", "description": "null", "tags": ["null"], "likes": 1, "viewed": 108, "published": "Public", "date": "1540107692", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// FRAGMENT SHADER FOR SHADERTOY\n\n// Constants.\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 6;\nconst int NUM_PLANES = 2;\nconst int NUM_SPHERES = 4;\nconst int NUM_CONES = 1;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.3, 0.5, 1.0 );\n\n // Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0; \n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Define new struct types.\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Cone_t {\n\t// Half angle\n\tfloat cosa;\n\t// Height\n\tfloat h;\n\t// Tip position\n\tvec3 c;\n\t// Axis\n\tvec3 v;\n\tint materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n\t// Ambient coefficient.\n    vec3 k_a;   \n    // Diffuse coefficient.\n    vec3 k_d;   \n    // Reflected specular coefficient.\n    vec3 k_r;   \n    // Global reflection coefficient.\n    vec3 k_rg;  \n    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n    float n;    \n};\n\n// Global scene data.\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nCone_t Cone[NUM_CONES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n// Initializes the scene.\nvoid InitScene()\n{\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 0.0;\n    Plane[0].C = 1.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 4;\n\n    // Vertical plane.\n    Plane[1].A = -1.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 0.0;\n    Plane[1].D = 5.1;\n    Plane[1].materialID = 0;\n\n    // Center silver sphere.\n    Sphere[0].center = vec3( -2., 0., 2.5);\n    Sphere[0].radius = 2.5;\n    Sphere[0].materialID = 1;\n\n    // Blue sphere.\n    Sphere[1].center = vec3( 3. * cos(iTime) - 2., 3. * sin(iTime), 1.5 );\n    Sphere[1].radius = 0.5;\n    Sphere[1].materialID = 2;\n\n    // Big sphere shell.\n    Sphere[2].center = vec3( 0., 0., 0. );\n    Sphere[2].radius = 16.;\n    Sphere[2].materialID = 4;\n  \n    // Green sphere.\n    Sphere[3].center = vec3( .5 * cos(3. * iTime) + 2., .5 * sin(3. * iTime), 0.4 );\n    Sphere[3].radius = .3;\n    Sphere[3].materialID = 5;\n\n    // Cone\n    Cone[0].cosa = 0.95;\n    Cone[0].h = 3.4;\n    Cone[0].c = vec3(2.0, 0.0, 0.0);\n    Cone[0].v = vec3(0.0, 0.0, 1.0);\n    Cone[0].materialID = 3;\n\n    // Vertical plane: Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.4 );\n    Material[0].k_a = 0.9 * Material[0].k_d;\n    Material[0].k_r = 1.2 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Center sphere: Silver material.\n    Material[1].k_d = vec3( 0.5, 0.5, 0.5);\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 4.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 128.0;\n\n    // Blue sphere: Blue plastic material.\n    Material[2].k_d = vec3( 0.2, 0.2, 0.8 );\n    Material[2].k_a = 0.4 * Material[2].k_d;\n    Material[2].k_r = vec3( 0.5, 0.5, 0.5);\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 64.0;\n\n    // Cone: Gold material.\n    Material[3].k_d = vec3( 0.8, 0.7, 0.1 );\n    Material[3].k_a = 0.2 * Material[1].k_d;\n    Material[3].k_r = 2.0 * Material[1].k_d;\n    Material[3].k_rg = 0.5 * Material[1].k_r;\n    Material[3].n = 64.0;\n\n    // Horizontal plane: Red material.\n    Material[4].k_d = vec3( 0.2, 0.1, 0.1 );\n    Material[4].k_a = 0.2 * Material[0].k_d;\n    Material[4].k_r = 0.2 * Material[0].k_d;\n    Material[4].k_rg = 0.1 * Material[0].k_r;\n    Material[4].n = 128.0;\n    \n    // Green sphere: Green plastic material.\n    Material[5].k_d = vec3( 0.4, 0.8, 0.4 );\n    Material[5].k_a = 0.4 * Material[5].k_d;\n    Material[5].k_r = vec3( 0.5, 0.5, 0.5);\n    Material[5].k_rg = 0.5 * Material[5].k_r;\n    Material[5].n = 64.0;\n\n    // Light 0.\n    Light[0].position = vec3( 4.0, -2.0, 9.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    // Light 1.\n    Light[1].position = vec3( 2.0, 8.0, 8.0 );\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n}\n\n// Computes intersection between a plane and a ray.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n// Computes intersection between a plane and a ray for shadow ray intersection.\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n// Computes intersection between a sphere and a ray.\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n\t// A vector from sphere center towards ray origin\n    vec3 V = ray.o - sph.center;\n    float a0 = dot(V,V) - sph.radius * sph.radius;\n    float DdotV = dot(ray.d, V);\n\n    if (DdotV <= 0.0) {\n    \t// When the ray shoots towards the sphere\n    \tfloat discr = DdotV * DdotV - a0;\n    \tif (discr >= 0.0) {\n    \t\t// Smaller intersection point\n    \t\tt = -DdotV - sqrt(discr);\n    \t\thitPos = ray.o + t * ray.d;\n    \t\thitNormal = normalize(hitPos - sph.center);\n    \t\treturn (t >= tmin && t<= tmax);\n    \t}\n    }\n\treturn false;\n}\n\n// Computes intersection between a sphere and a ray for shadow ray intersection.\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    // A vector from sphere center towards ray origin\n    vec3 V = ray.o - sph.center;\n    float a0 = dot(V,V) - sph.radius * sph.radius;\n    float DdotV = dot(ray.d, V);\n\n    if (DdotV <= 0.0) {\n    \t// When the ray shoots towards the sphere\n    \tfloat discr = DdotV * DdotV - a0;\n    \tif (discr >= 0.0) {\n    \t\tfloat t = -DdotV - sqrt(discr);\n    \t\treturn (t >= tmin && t<= tmax);\n    \t}\n    }\n\treturn false;\n}\n\n// Computes intersection between a cone and a ray.\nbool IntersectCone( in Cone_t cone, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 co = ray.o - cone.c;\n\n    float a = dot(ray.d, cone.v)*dot(ray.d, cone.v) - cone.cosa * cone.cosa;\n    float b = 2. * (dot(ray.d, cone.v) * dot(co, cone.v) - dot(ray.d, co) * cone.cosa * cone.cosa);\n    float c = dot(co, cone.v) * dot(co, cone.v) - dot(co, co) * cone.cosa * cone.cosa;\n\n    float det = b * b - 4. * a * c;\n    if (det < 0.) return false;\n\n    det = sqrt(det);\n    float t1 = (-b - det) / (2. * a);\n    float t2 = (-b + det) / (2. * a);\n\n    t = t1;\n    if (t < 0. || t2 > 0. && t2 < t) t = t2;\n    if (t < 0.) return false;\n\n    vec3 cp = ray.o + t * ray.d - cone.c;\n    float h = dot(cp, cone.v);\n    if (h < 0. || h > cone.h) return false;\n\n    hitPos = ray.o + t * ray.d;\n    hitNormal = normalize(cp * dot(cone.v, cp) / dot(cp, cp) - cone.v);\n\n    return (t >= tmin && t<= tmax);\n}\n\n// Computes intersection between a cone and a ray for shadow ray intersection.\nbool IntersectCone( in Cone_t cone, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 co = ray.o - cone.c;\n\n    float a = dot(ray.d, cone.v)*dot(ray.d, cone.v) - cone.cosa * cone.cosa;\n    float b = 2. * (dot(ray.d, cone.v) * dot(co, cone.v) - dot(ray.d, co) * cone.cosa * cone.cosa);\n    float c = dot(co, cone.v) * dot(co, cone.v) - dot(co, co) * cone.cosa * cone.cosa;\n\n    float det = b * b - 4. * a * c;\n    if (det < 0.) return false;\n\n    det = sqrt(det);\n    float t1 = (-b - det) / (2. * a);\n    float t2 = (-b + det) / (2. * a);\n\n    float t = t1;\n    if (t < 0. || t2 > 0. && t2 < t) t = t2;\n    if (t < 0.) return false;\n    vec3 cp = ray.o + t * ray.d - cone.c;\n    float h = dot(cp, cone.v);\n    if (h < 0. || h > cone.h) return false;\n\n    return (t >= tmin && t<= tmax);\n}\n\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a + \n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n// Casts a ray into the scene and returns color computed at the nearest hit position.\nvec3 CastRay( in Ray_t ray, \n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg ) \n{\n    // Find whether and where the ray hits some object. \n    bool hasHitSomething = false;\n    // The ray parameter t at the nearest hit point.\n    float nearest_t = DEFAULT_TMAX;\n    // 3D position of the nearest hit point.   \n    vec3 nearest_hitPos; \n    // Normal vector at the nearest hit point.             \n    vec3 nearest_hitNormal;\n    // MaterialID of the object at the nearest hit point.          \n    int nearest_hitMatID;             \n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    // Try interesecting input ray with all the planes and spheres,\n    // and record the front-most (nearest) interesection.\n    for (int i = 0; i < NUM_SPHERES; i++ ) {\n    \t// Try intersect with spheres\n    \ttemp_hasHit = IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n                      temp_t, temp_hitPos, temp_hitNormal);\n\n    \t// If intersect with spheres, compare and find the nearest\n    \tif (temp_hasHit && temp_t < nearest_t) {\n    \t\thasHitSomething = true;\n    \t\tnearest_t = temp_t;\n    \t\tnearest_hitPos = temp_hitPos;\n    \t\tnearest_hitNormal = temp_hitNormal;\n    \t\tnearest_hitMatID = Sphere[i].materialID;\n    \t}\n    \t\n    }\n\n    for (int i = 0; i < NUM_PLANES; i++ ) {\n    \t// Try intersect with planes\n    \t// Use nearest_t as input tmax to determine whether the intersection point\n    \t//with planes is the nearest\n    \ttemp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, nearest_t,\n                      temp_t, temp_hitPos, temp_hitNormal);\n\n    \t// If hit, then now the hit point is nearer than spheres if any\n    \tif (temp_hasHit && temp_t < nearest_t ) {\n    \t\thasHitSomething = true;\n    \t\tnearest_t = temp_t;\n    \t\tnearest_hitPos = temp_hitPos;\n    \t\tnearest_hitNormal = temp_hitNormal;\n    \t\tnearest_hitMatID = Plane[i].materialID;\n    \t}\n    \t\n    }\n\n    for (int i = 0; i < NUM_CONES; i++ ) {\n    \t// Try intersect with cones\n    \t// Use nearest_t as input tmax to determine whether the intersection point\n    \t//with planes is the nearest\n    \ttemp_hasHit = IntersectCone(Cone[i], ray, DEFAULT_TMIN, nearest_t,\n                      temp_t, temp_hitPos, temp_hitNormal);\n\n    \t// If hit, then now the hit point is nearer than spheres if any\n    \tif (temp_hasHit && temp_t < nearest_t ) {\n    \t\thasHitSomething = true;\n    \t\tnearest_t = temp_t;\n    \t\tnearest_hitPos = temp_hitPos;\n    \t\tnearest_hitNormal = temp_hitNormal;\n    \t\tnearest_hitMatID = Cone[i].materialID;\n    \t}\n    \t\n    }\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );\n\n    // For each light source, make a shadow ray, and check if the shadow ray\n    // intersects any of the objects.\n    Ray_t ShadowRay[NUM_LIGHTS];\n    bool inshadow[NUM_LIGHTS];\n    for (int i = 0; i < NUM_LIGHTS; i++ ) {\n    \t// Make a shadow ray (from surface to light) for each light\n    \tShadowRay[i].o = nearest_hitPos;\n    \tShadowRay[i].d = normalize(Light[i].position - ShadowRay[i].o);\n\n    \tfor (int j = 0; j < NUM_SPHERES; j++ ) {\n    \t\t// If already in shadow, inshadow[i] becomes inaccessible\n    \t\tif(!inshadow[i]) {\n    \t\t\t// The point is in shadow if the shadow ray intersects with anything\n    \t\tinshadow[i] = IntersectSphere(Sphere[j], ShadowRay[i], DEFAULT_TMIN, \n    \t\t\tdistance(nearest_hitPos, Light[i].position));\n    \t\t}\n    \t}\n    \t// If not occluded, consider intersection with planes\n    \tif (!inshadow[i]) {\n    \t\tfor(int j = 0; j < NUM_PLANES; j++ ) {\n    \t\t\t// If already in shadow, inshadow[i] becomes inaccessible\n    \t\t\tif(!inshadow[i]) {\n    \t\t\t\tinshadow[i] = IntersectPlane(Plane[j], ShadowRay[i], DEFAULT_TMIN, \n    \t\t\t\tdistance(nearest_hitPos, Light[i].position));\n    \t\t\t}\n    \t\t}\n    \t}\n\n    \t// If not occluded, consider intersection with cones\n    \tif (!inshadow[i]) {\n    \t\tfor(int j = 0; j < NUM_CONES; j++ ) {\n    \t\t\t// If already in shadow, inshadow[i] becomes inaccessible\n    \t\t\tif(!inshadow[i]) {\n    \t\t\t\tinshadow[i] = IntersectCone(Cone[j], ShadowRay[i], DEFAULT_TMIN, \n    \t\t\t\tdistance(nearest_hitPos, Light[i].position));\n    \t\t\t}\n    \t\t}\n    \t}\n\n    \tI_local += PhongLighting( ShadowRay[i].d, nearest_hitNormal, - ray.d, inshadow[i], \n    \t\tMaterial[nearest_hitMatID], Light[i] );\n    }\n\n    \n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    vec3 cam_pos = vec3( 4. * cos(iTime / 2.) + 1., 10.0, 1. * sin(iTime / 2.) + 3.);\n    vec3 cam_lookat = vec3( 0., 0., 0. );\n    vec3 cam_up_vec = vec3( 0.0, 0.0, 1.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ ) \n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltBRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1772, 1798, 1816, 1841, 4634], [4636, 4853, 5008, 5008, 5338], [5340, 5420, 5503, 5503, 5715], [5717, 5770, 5928, 5979, 6452], [6454, 6535, 6620, 6674, 7033], [7035, 7086, 7240, 7240, 8052], [8054, 8133, 8215, 8215, 8927], [8929, 9010, 9141, 9141, 9554], [9556, 9642, 9757, 9814, 14190], [14192, 14397, 14454, 14454, 15914]], "test": "valid"}
{"id": "MltBW8", "name": "sphere tracing 3", "author": "stuxxnet42", "description": "sphere tracing 3", "tags": ["sphere", "tracing"], "likes": 1, "viewed": 95, "published": "Public", "date": "1539480217", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//threshold for hit testing\nconst float epsilon = 1.0;\n\n// Distance field of a sphere at c with radius r, sampled at p.\nfloat sphere(vec3 c, float r, vec3 p) {\n\treturn length(p - c) - r;\n}\n// The Scene\nfloat distanceField(vec3 pos) {\n    pos.x = pos.x+20.0*cos(0.1*pos.x+2.31);\n    pos.y = pos.y + 20.0*sin(0.1*pos.y+4.0*iTime);\n    //pos.x = mod(pos.x, 300.0);\n\tfloat s1 = sphere(vec3(400.0,150.0*cos(iTime*2.0),0.0), 250., pos);\n    float s2 = sphere(vec3(-400.0,150.0*sin(iTime*2.0),0.0), 250., pos);\n    vec3 pos2 = vec3(pos.x * cos(iTime*0.1) - pos.y * sin(iTime*0.1), pos.x * sin(iTime*0.1) + pos.y * cos(iTime*0.1), pos.z);\n    pos2.y*=1.0-0.1*cos(iTime*3.0);\n    float s3 = sphere(vec3(250.0,250.0*sin(iTime*2.0),300.0), 200., pos2);\n\treturn min(min(s1,s2),s3);\n}\n\n// Approximates the normal vector at pos.\nvec3 distanceFieldNormal(vec3 pos) {\n\t// Method of central differences.\n\tconst float s = 1. / 2.;\n\t\n\tvec3 n = vec3(distanceField(pos + vec3(s, 0, 0)) - distanceField(pos - vec3(s, 0, 0)),\n\t\t\t\t  distanceField(pos + vec3(0, s, 0)) - distanceField(pos - vec3(0, s, 0)),\n\t\t\t\t  distanceField(pos + vec3(0, 0, s)) - distanceField(pos - vec3(0, 0, s)));\n\treturn normalize(n);\n}\n\n\n// Light source intensity\nconst float i_a = 0.3;\nconst float i_d = 0.6;\nconst float i_s = 0.4;\n\n// Material reflectiveness and color\nconst float k_a = 0.6;\nconst float k_d = 0.7;\nconst float k_s = 0.8;\nconst float alpha = 8.;\nconst vec3 matColor = vec3(1, 0.2, 0.7);\n\nconst vec3 lightpos = vec3(0.0, 1.0, -1.0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat near = -iResolution.x * 1.2 / 2.;\n\tfloat far  =  iResolution.x * 1.2 / 2.;\n\t\n\tvec3 cameraPosition = vec3(0, 0, -1);\n\t\n\tvec3 pos = vec3(fragCoord.xy - iResolution.xy / 2., near);\n\t\n\tvec3 npos = pos / iResolution.x;\n\t\n\tvec3 dir = normalize(npos - cameraPosition);\n\tvec3 toEye = -dir;\n\tfragColor = vec4(0.0, 0.0, 0.0, 1);\n    int stepsTaken = 0;\n    for (int steps = 0; steps < 50; ++steps) {\n\t\tstepsTaken = steps;\n\t\tfloat d = distanceField(pos);\n\n\t\tif (d < epsilon) {\n            vec3 normal = distanceFieldNormal(pos);\n\t\t\tvec3 nl_m = normalize(lightpos);\n\t\t\tvec3 r_m = -reflect(nl_m, normal);\n            \n            float ambient = i_a * k_a;\n            float k_d_2 = 0.5+0.5*cos(pos.z*0.2);\n\t\t\tfloat diffuse = i_d * k_d_2 * max(dot(nl_m, normal), 0.);\n\t\t\tfloat spec    = i_s * k_s * pow(max(dot(r_m, toEye), 0.), alpha);\n            \n            vec3 light = matColor * (ambient + diffuse) + spec;\n            light.x += 0.1*cos(pos.x*0.1);\n            light.y += 0.5*cos((pos.y*pos.x*0.01));\n            \n\t\t\tfragColor = vec4(light, 1);\n\t\t\treturn;\n\t\t} else {\n\t\t\tpos += d * dir;\n\t\t}\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltBW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 120, 159, 159, 188], [189, 202, 233, 233, 771], [773, 815, 851, 886, 1185], [1502, 1502, 1559, 1559, 2656]], "test": "valid"}
{"id": "MltBWM", "name": "Trippy heart", "author": "cras", "description": "Basically shoved https://www.shadertoy.com/view/XsfGRn and http://glslsandbox.com/e#29611.0 together. \nThank you inigo and Robert!", "tags": ["heart", "trippy"], "likes": 19, "viewed": 502, "published": "Public", "date": "1539887896", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/min(iResolution.y,iResolution.x);\n    \n    // heart shape\n    p *= 0.6;\n    p.y = -0.1 - p.y*1.2 + abs(p.x)*(1.0-abs(p.x));\n    float r = length(p);\n\tfloat d = 0.5;\n\n    \n\t// heart color\n    float mX = (sin(iTime * 0.5) + 1.0) * 0.2;\n    float mY = (cos(iTime * 0.5) + 1.0) * 0.2;\n\tvec3 hcol = vec3((fragCoord.xy)/(iResolution.y),mX);\n    for (int i = 0; i < 100; i++){\n    \thcol.xzy = vec3(1.3,0.999,0.7)*(abs((abs(hcol)/dot(hcol,hcol)-vec3(1.0,1.0,mY))));\n    }\n    \n    // apply one more iteration for background color\n    vec3 bcol = vec3(0.0);\n    bcol.xzy = vec3(1.3,0.999,0.7)*(abs((abs(hcol)/dot(hcol,hcol)-vec3(1.0,1.0,mY))));\n    \n    bcol.r *= 0.5;\n    hcol.r *= 2.0;\n   \n    vec3 col = mix( bcol, hcol, smoothstep( -0.15, 0.15, (d-r)) );\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltBWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 882]], "test": "valid"}
{"id": "MltfWN", "name": "Swirl Optical Illusion", "author": "Jamie_Pendergast", "description": "Swirl swirl swirl! Star at the center and they move!", "tags": ["2d", "illusion", "matrix"], "likes": 2, "viewed": 533, "published": "Public API", "date": "1539720344", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotationMatrix(float theta)\n{\n    return mat2(\n        cos(theta),-sin(theta),\n        sin(theta),cos(theta)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 originalUV = uv;\n    uv.x *= iResolution.x / iResolution.y;\n    uv = fract(uv * 4.) * 2. - 1.;\n\n    for(int i = 0; i < 6; i++)\n        uv *= rotationMatrix(acos(dot(uv,uv)) + iTime * float(i));\n    \n    vec3 col = vec3(uv,distance(uv,originalUV));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltfWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 122], [124, 124, 181, 181, 521]], "test": "valid"}
{"id": "Mltfzf", "name": "Fibonacci's Fugu", "author": "dr2", "description": "Prickly fish", "tags": ["bubble", "fish", "thorn", "spike", "swim"], "likes": 17, "viewed": 670, "published": "Public API", "date": "1540544885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Fibonacci's Fugu\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Prickly fish; motivated by kali's \"Puffy\" (mouseable)\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 RotToDirLim (vec3 v1, vec3 v2, vec3 p, float aMax);\nvec2 Rot2D (vec2 q, float a);\nfloat Minv3 (vec3 p);\nvec3 Hashv3f (float p);\n\nvec3 qBody, ltDir, bGrid, eyePos, vuPos;\nfloat dstFar, tCur, bodyEx, spkEx, mthShp;\nint idObj;\nconst int idBody = 1, idFinV = 2, idFinL = 3, idTail = 4, idMouth = 5, idEye = 6, idBub = 7;\nconst float pi = 3.14159, phi = 1.618034;\n\nfloat BubDf (vec3 p, vec3 pw, vec3 vr)\n{\n  vec3 b;\n  float s, t, r, d, a;\n  t = tCur;\n  vr -= 0.5;\n  s = pow (fract (dot (vr, vec3 (1.)) * 100.), 4.);\n  pw.y += t;\n  pw = 7. * pw + 2. * pi * vr + vec3 (t, 0., t);\n  d = sin ((t + vr.y) * 3. * pi * (1. - s)) * 0.3 * vr.x * (1. - s);\n  a = vr.z * t;\n  b = d * vec3 (cos (a), 0., sin (a));\n  r = 0.1 + s * (0.02 * dot (sin (pw), vec3 (1.)) - 0.05);\n  return 0.9 * PrSphDf (p - 0.1 * b, 0.1 * r);\n}\n\nfloat DstBub (vec3 p, vec3 cId)\n{\n  vec3 vr;\n  vr = Hashv3f (dot (cId, vec3 (31., 33., 35.)));\n  return (vr.x * smoothstep (2., 5., length (cId)) > 0.9) ?\n     BubDf (p - bGrid * (cId + 0.5), p, vr) : dstFar;\n}\n\nfloat BObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cId, s;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  dHit = eps;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + dHit * rd;\n    p.y -= 0.4 * tCur + 40.;\n    cId = floor (p / bGrid);\n    d = DstBub (p, cId);\n    s = (bGrid * (cId + step (0., rd)) - p) / rd;\n    d = min (d, Minv3 (s) + eps);\n    if (d < eps || dHit > dstFar) break;\n    dHit += d;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nfloat BObjDf (vec3 p)\n{\n  return DstBub (p, floor (p / bGrid));\n}\n\nvec3 BObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  p.y -= 0.4 * tCur + 40.;\n  v = vec4 (BObjDf (p + e.xxx), BObjDf (p + e.xyy), BObjDf (p + e.yxy), BObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec4 SphFib (vec3 v, float n)\n{   // Keinert et al's inverse spherical Fibonacci mapping\n  vec4 b;\n  vec3 vf, vfMin;\n  vec2 ff, c;\n  float fk, ddMin, dd, a, z, ni;\n  ni = 1. / n;\n  fk = pow (phi, max (2., floor (log (n * pi * sqrt (5.) * dot (v.xy, v.xy)) /\n     log (phi + 1.)))) / sqrt (5.);\n  ff = vec2 (floor (fk + 0.5), floor (fk * phi + 0.5));\n  b = vec4 (ff * ni, pi * (fract ((ff + 1.) * phi) - (phi - 1.)));\n  c = floor ((0.5 * mat2 (b.y, - b.x, b.w, - b.z) / (b.y * b.z - b.x * b.w)) *\n     vec2 (atan (v.y, v.x), v.z - (1. - ni)));\n  ddMin = 4.1;\n  for (int j = 0; j < 4; j ++) {\n    a = dot (ff, vec2 (j - 2 * (j / 2), j / 2) + c);\n    z = 1. - (2. * a + 1.) * ni;\n    vf = vec3 (sin (2. * pi * fract (phi * a) + vec2 (0.5 * pi, 0.)) * sqrt (1. - z * z), z);\n    dd = dot (vf - v, vf - v);\n    if (dd < ddMin) {\n      ddMin = dd;\n      vfMin = vf;\n    }\n  }\n  return vec4 (sqrt (ddMin), vfMin);\n}\n\nvec2 SpkShp ()\n{\n  vec4 f4;\n  vec3 uf;\n  float s;\n  f4 = SphFib (normalize (qBody + vec3 (0., 0., 0.1)), 4096.);\n  uf = f4.yzw;\n  s = smoothstep (0.95, 0.99, dot (uf, normalize (vec3 (0., 0.24, 1.))));\n  if (s == 0.) s = smoothstep (0.92, 0.99, dot (uf, normalize (vec3 (0., 0.35, -1.))));\n  if (s == 0.) s = smoothstep (0.9, 0.94, dot (uf, normalize ((eyePos - vec3 (0., 0., -0.03)) *\n     vec3 (sign (uf.x), 1., 1.))));\n  if (s == 0.) s = smoothstep (0.97, 0.99, dot (uf, normalize (vec3 (sign (uf.x), 0., 0.25))));\n  if (s == 0.) s = smoothstep (0.97, 0.99, dot (uf, normalize (vec3 (0., sign (uf.y), -0.1))));\n  return vec2 (1. - s, f4.x);\n}\n\nfloat DstBody (vec3 p)\n{\n  vec3 q;\n  vec2 spk;\n  float spkLen, db, dt;\n  qBody = p;\n  spk = SpkShp ();\n  spkLen = spk.x * (1. - smoothstep (0.001, 0.02, spk.y)) * (0.001 + 0.04 * spkEx);\n  p.y -= -0.03 * bodyEx;\n  p.x *= 1. + 1.5 * (p.y + 0.2) * (p.y + 0.2);\n  p.xy *= 1. + 0.5 * smoothstep (0., 0.5, - p.z);\n  q = (p - vec3 (0., 0.2 + 0.025 * bodyEx, 0.5 * (p.y - 0.2) - 0.14)) * vec3 (1.4, 1.7, 0.6);\n  dt = PrSphDf (q, 0.4 - 0.2 * smoothstep (0., 1.5, 1.3 - p.z) + spkLen);\n  q = p * vec3 (1.2, 1.2, 1. + 0.5 * smoothstep (0., 0.5, - p.y - p.z));\n  db = PrSphDf (q, 0.37 + smoothstep (0., 1.7, - p.z) + 0.03 * bodyEx + spkLen);\n  q = qBody;\n  q.yz -= vec2 (0.1, 0.1);\n  q.xy *= vec2 (0.5, 1.) + vec2 (0.1, -0.4) * mthShp;\n  db = max (db, - PrCylDf (q, 0.02, 0.3));\n  return SmoothMin (db, dt, 0.05);\n}\n\nfloat DstMth (vec3 p)\n{\n  p.yz -= vec2 (0.1, 0.34 + 0.02 * bodyEx - 2. * p.x * p.x);\n  p.xy *= vec2 (0.5 + 0.1 * mthShp, 1. - 0.5 * mthShp);\n  return PrCylAnDf (p, 0.015, 0.0015, 0.03);\n}\n\nfloat DstTail (vec3 p)\n{\n  float d, r, a;\n  p.yz -= vec2 (0.11, -0.45);\n  p.xz = Rot2D (p.xz, 0.5 * cos (2. * tCur - 3. * p.y + 5. * p.z));\n  a = 0.003 * sin (32. * atan (p.y, p.z));\n  r = length (p.yz);\n  d = min (0.01 - 0.008 * smoothstep (0.15, 0.25, r) - abs (p.x -\n     a * smoothstep (0.04, 0.08, r)), 0.35 - 0.05 * p.y - 0.01 * cos (a * 1024.) - r);\n  d = - SmoothMin (abs (p.y) + 0.3 * p.z, SmoothMin (-0.3 * abs (p.y) - p.z, d, 0.02), 0.02);\n  return d;\n}\n\nfloat DstFinL (vec3 p)\n{\n  float d, r, a, t, w;\n  t = 5. * tCur + 0.2 * sign (p.x);\n  p.x = abs (p.x) - 0.26 - 0.02 * bodyEx;\n  p.xz = Rot2D (p.xz, 0.4 * pi);\n  w = 0.15 * (1. - 0.15 * bodyEx) * (1. + 5. * length (p));\n  p.yz = Rot2D (p.yz, 0.2 + 0.5 * w * cos (t + 2. * atan (p.x, - p.y)) - 0.5 * pi);\n  p.xz = Rot2D (p.xz, 1.2 + 0.75 * bodyEx + w * sin (t - w) - 0.5 * pi);\n  a = atan (p.x, - p.y);\n  r = length (p.xy);\n  d = min (0.01 - 0.008 * smoothstep (0.2, 0.3, r) -\n     abs (p.z + 0.002 * sin (32. * a) * smoothstep (0.05, 0.08, r)),\n     0.4 - 0.15 * smoothstep (1., 3., abs (a)) - 0.01 * cos (32. * a) - r);\n  d = - 0.9 * SmoothMin (-0.2 * p.x + p.y, SmoothMin (p.x - 0.7 * p.y, d, 0.02), 0.02);\n  return d;\n}\n\nfloat DstFinV (vec3 p)\n{\n  float d, r, a, y;\n  p.y = abs (p.y + 0.035 * bodyEx) - 0.035 * bodyEx - 0.26 - 0.02 * sign (p.y);\n  p.z -= -0.1;\n  y = smoothstep (0., 0.2, p.y);\n  p.z *= 1. - 0.3 * y * y;\n  a = - cos (4. * tCur + 5. * (- p.y + p.z)) * (0.1 - 0.3 * p.z);\n  p.xz = Rot2D (p.xz, a);\n  p.xy = Rot2D (p.xy, a);\n  a = 0.0025 * sin (32. * atan (p.y, p.z));\n  r = length (p.yz);\n  d = min (0.01 - 0.009 * smoothstep (0.1, 0.2, r) -\n     abs (p.x + a * smoothstep (0.04, 0.1, r)), 0.22 - 0.015 * cos (512. * a) - r);\n  d = - SmoothMin (p.y + 0.4 * p.z, SmoothMin (-0.4 * p.y - p.z, d, 0.02), 0.02);\n  return d;\n}\n\nfloat FObjDf (vec3 p)\n{\n  float dMin, d, a, c;\n  c = cos (2. * tCur);\n  a = -0.5 * smoothstep (-0.2, 1.1, - p.z) * c;\n  p.xz = Rot2D (p.xz, 0.1 * c + a);\n  p.xy = Rot2D (p.xy, 0.5 * a);\n  dMin = 0.3 * DstBody (p);\n  idObj = idBody;\n  d = DstMth (p);\n  if (abs (d) < dMin) idObj = idMouth;\n  dMin = SmoothMin (dMin, d, 0.01);\n  d = 0.6 * DstTail (p);\n  if (d < dMin) idObj = idTail;\n  dMin = SmoothMin (dMin, d, 0.01);\n  d = 0.7 * DstFinL (p);\n  if (d < dMin) idObj = idFinL;\n  dMin = SmoothMin (dMin, d, 0.01);\n  d = 0.7 * DstFinV (p);\n  if (d < dMin) idObj = idFinV;\n  dMin = SmoothMin (dMin, d, 0.01);\n  p.x = abs (p.x);\n  d = PrSphDf (p - eyePos, 0.13);\n  if (d < dMin) idObj = idEye;\n  dMin = SmoothMin (dMin, d, 0.02);\n  return dMin;\n}\n\nfloat FObjRay (vec3 ro, vec3 rd)\n{\n  float d, h;\n  d = 0.;\n  for (int j = 0; j < 120; j ++) {\n    h = FObjDf (ro + d * rd);\n    d += h;\n    if (h < 0.0005 || d > dstFar) break;\n  }\n  return d;\n}\n\nvec3 FObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (FObjDf (p + e.xxx), FObjDf (p + e.xyy), FObjDf (p + e.yxy), FObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat FObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = 0; j < 30; j ++) {\n    h = FObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nfloat TurbLt (vec3 p, vec3 n, float t)\n{\n  vec4 b;\n  vec2 q, qq;\n  float c, tt;\n  q = 2. * pi * mod (vec2 (dot (p.yzx, n), dot (p.zxy, n)), 1.) - 256.;\n  t += 11.;\n  c = 0.;\n  qq = q;\n  for (float j = 1.; j <= 7.; j ++) {\n    tt = t * (1. + 1. / j);\n    b = sin (tt + vec4 (- qq + vec2 (0.5 * pi, 0.), qq + vec2 (0., 0.5 * pi)));\n    qq = q + tt + b.xy + b.zw;\n    c += 1. / length (q / sin (qq));\n  }\n  return clamp (pow (abs (1.25 - abs (0.167 + 40. * c)), 8.), 0., 1.);\n}\n\nfloat WatShd (vec3 rd)\n{\n  vec2 p;\n  float t, h;\n  p = 20. * rd.xz / rd.y;\n  t = tCur * 2.;\n  h = sin (p.x * 2. + t * 0.77 + sin (p.y * 0.73 - t)) +\n     sin (p.y * 0.81 - t * 0.89 + sin (p.x * 0.33 + t * 0.34)) +\n     (sin (p.x * 1.43 - t) + sin (p.y * 0.63 + t)) * 0.5;\n  h *= smoothstep (0.5, 1., rd.y) * 0.04;\n  return h;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = 4. * tCur;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return vec3 (0.2, 0.5, 1.) * (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + gd * 0.05);\n}\n\nvec4 FObjCol (vec3 p)\n{\n  vec4 col4;\n  vec3 ve;\n  vec2 spk;\n  float s, t;\n  col4 = vec4 (0.9, 0.9, 0.5, 0.2);\n  if (idObj == idBody) {\n    col4.rgb *= 0.7 + 0.3 * smoothstep (-0.1, 0.1, qBody.y);\n    spk = SpkShp ();\n    col4.rgb = mix (col4.rgb, vec3 (0.9, 0.7, 0.7), 0.5 * smoothstep (0., 0.01, spk.x) *\n       SmoothBump (0.25, 0.75, 0.1, mod (128. * atan (0.7 * qBody.x, qBody.y - 0.1) / pi, 1.)));\n    col4 = mix (col4, vec4 (0.9, 0.9, 0.95, 0.5), step (0.02, spk.x) * step (spk.y, 0.02));\n  } else if (idObj == idMouth) {\n    col4 = vec4 (0.9, 0.7, 0.7, 0.3);\n  } else if (idObj == idFinV || idObj == idFinL) {\n    col4.rgb = mix (col4.rgb, vec3 (1., 1., 0.8), smoothstep (0.4, 0.5, length (p)));\n  } else if (idObj == idTail) {\n    col4.rgb = mix (col4.rgb, vec3 (1., 1., 0.8), smoothstep (0.6, 0.7, length (p)));\n  } else if (idObj == idEye) {\n    if (abs (p.y - eyePos.y - 0.04) < 0.001 + 0.1 * SmoothBump (0.13, 0.87, 0.07,\n       mod (0.5 * tCur, 1.))) {\n      ve = eyePos * vec3 (sign (p.x), 1., 1.);\n      ve = RotToDirLim (normalize (vuPos - ve), vec3 (sign (p.x), 0., 0.), p - ve, 0.35 * pi);\n      s = length (ve.yz);\n      t = (1. - step (s, 0.06 + 0.02 * SmoothBump (0.25, 0.75, 0.25,\n         mod (12. * atan (ve.y, ve.z) / pi, 1.))));\n      col4.rgb = (vec3 (0.25, 0.5, 0.25) + vec3 (0.75, 0.5, 0.75) * smoothstep (0.07, 0.1, s)) * t;\n      col4.a = (t == 0.) ? -1. : 0.3;\n    } else idObj = idBody;\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col, bgCol;\n  float dstFish, dstBub, spec, sh;\n  bgCol = BgCol (rd);\n  dstFish = FObjRay (ro, rd);\n  dstBub = BObjRay (ro, rd);\n  if (min (dstBub, dstFish) < dstFar) {\n    if (dstFish < dstBub) {\n      ro += dstFish * rd;\n      vn = FObjNf (ro);\n      col4 = FObjCol (ro);\n      col = col4.rgb;\n      spec = col4.a;\n      sh = FObjSShadow (ro, ltDir);\n      if (spec >= 0.) col = mix (col, BgCol (reflect (rd, vn)), 0.2);\n    } else if (dstBub < dstFar) {\n      ro += dstBub * rd;\n      vn = BObjNf (ro);\n      col = mix (vec3 (1.), BgCol (reflect (rd, vn)), 0.7);\n      spec = 0.5;\n      sh = 1.;\n      idObj = idBub;\n    }\n    if (spec >= 0.) {\n      col = col * (0.1 + 0.2 * bgCol + 0.7 * sh * max (dot (vn, ltDir), 0.)) +\n         spec * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n      col += 0.3 * TurbLt (0.5 * ro, abs (vn), 0.5 * tCur) * smoothstep (-0.3, -0.1, vn.y);\n      if (idObj == idBub) col *= 0.5 + 0.5 * clamp (rd.y + 1., 0., 1.5);\n    } else {\n      rd = reflect (rd, vn);\n      col = 0.5 * (BgCol (rd) + WatShd (rd));\n    }\n    col = mix (col, bgCol, smoothstep (0.3, 0.95, min (dstBub, dstFish) / dstFar));\n  } else col = bgCol + WatShd (rd);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = - pi;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  } else {\n    az += 2. * pi * sin (0.01 * pi * tCur);\n    el -= 0.1 + 0.3 * pi * sin (0.016 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  zmFac = 3.;\n  ro = vuMat * vec3 (0., 0., -2. - 0.5 * sin (0.35 * tCur));\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ltDir = normalize (vec3 (0.5, 2., 1.));\n  bGrid = vec3 (0.5);\n  mthShp = sin (6. * tCur);\n  bodyEx = SmoothBump (0.25, 0.75, 0.15, mod (0.4 * tCur, 1.));\n  spkEx = SmoothBump (0.65, 0.85, 0.05, mod (0.2 * tCur, 1.));\n  eyePos = vec3 (0.13);\n  vuPos = ro;\n  dstFar = 10.;\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (clamp (col, 0., 1.), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 RotToDirLim (vec3 v1, vec3 v2, vec3 p, float aMax)\n{\n  vec3 n;\n  float c;\n  n = normalize (cross (v1, v2));\n  c = max (dot (v1, v2), cos (aMax));\n  return c * p + sqrt (1. - c * c) * cross (n, p) + (1. - c) * dot (n, p) * n;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nconst float cHashM = 43758.54;\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mltfzf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[777, 777, 817, 817, 1221], [1223, 1223, 1256, 1256, 1433], [1435, 1435, 1469, 1469, 1969], [1971, 1971, 1994, 1994, 2036], [2038, 2038, 2060, 2060, 2291], [2293, 2293, 2324, 2381, 3201], [3203, 3203, 3219, 3219, 3848], [3850, 3850, 3874, 3874, 4654], [4656, 4656, 4679, 4679, 4843], [4845, 4845, 4869, 4869, 5309], [5311, 5311, 5335, 5335, 6032], [6034, 6034, 6058, 6058, 6649], [6651, 6651, 6674, 6674, 7391], [7393, 7393, 7427, 7427, 7587], [7589, 7589, 7611, 7611, 7815], [7817, 7817, 7855, 7855, 8078], [8080, 8080, 8120, 8120, 8554], [8556, 8556, 8580, 8580, 8883], [8885, 8885, 8907, 8907, 9276], [9278, 9278, 9301, 9301, 10718], [10720, 10720, 10755, 10755, 11976], [11978, 11978, 12034, 12034, 13171], [13173, 13173, 13206, 13206, 13233], [13235, 13235, 13277, 13277, 13328], [13330, 13330, 13383, 13383, 13444], [13446, 13446, 13491, 13491, 13594], [13596, 13596, 13653, 13653, 13736], [13738, 13738, 13795, 13795, 13969], [13971, 13971, 14001, 14001, 14114], [14116, 14116, 14138, 14138, 14176], [14210, 14210, 14234, 14234, 14294]], "test": "valid"}
{"id": "Mltfzn", "name": "square_flip", "author": "sporadiclizard", "description": "this is the code for a gif I made. It uses mobius transformations to deform the plane. I tried to explain the square switching in the code itself, hopefully it's somewhat understandable.", "tags": ["grid", "mobius", "loop", "sporadiclizard"], "likes": 20, "viewed": 252, "published": "Public", "date": "1538498799", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 2*pi\n#define TAU 6.283185307179\n\nvec2 cxmul(vec2 z, vec2 w) {\n    return mat2(z, -z.y, z.x) * w; //vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec2 cxdiv(vec2 z, vec2 w) {\n    return cxmul(z, vec2(w.x, -w.y)) / dot(w,w);\n}\n\nvec2 mobius(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d) {\n    return cxdiv(cxmul(a,z) + b, cxmul(c,z) + d); \n}\n\n// mobius transformation described with which complex numbers \n// it sends zero, one and infinity to.\n// 0 -> q, 1 -> r, inf -> s\nvec2 mobi3(vec2 z, vec2 q, vec2 r, vec2 s) {\n    return cxdiv(cxmul(z - q, r - s), cxmul(z - s, r - q));\n}\n\nvec2 rotate(vec2 v, float a) {\n  float s = sin(a);\n  float c = cos(a);\n  mat2 m = mat2(c, -s, s, c);\n  return m * v;\n}\n\nconst float scale = 1.5;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tfloat time = iTime*0.25;\n    \n    // centered around origin, [-1, 1];\n    vec2 pos = ( 2. * fragCoord - iResolution.xy ) / iResolution.y; \n    \n    vec2 zero = vec2( .15, 0.);\n    vec2 one =  vec2( -.15, 0.);\n    vec2 inf =  vec2( 0., 1.5);\n\n    // mobius transformed position - deforms the plane \n    vec2 posi = mobi3(pos, zero, one, inf);\n  \t\n    // switch for the two phases of the animation\n    // 0 for 0 < (iTime % 2) < 1\n    // 1 for 1 < (iTime % 2) < 2 \n    float sw = mod(floor(2.*time),2.);\n\n    // make a grid with the inverted position\n    // the switch moves the grid for when the visual \"switch\" happens\n    vec2 gposi = -1. + 2. * fract((scale*posi + sw*0.5 - time));\n    \n    // eased time for smooth rotation anim \n    float eased = 0.5*(1.-cos(mod(time,0.5)*TAU));\n    // switch direction for the two phases of the animation\n    eased *= mix(1., -1., sw);\n    gposi = rotate(gposi, eased*TAU/4.);\n    \n    // distance function for a 45 degree rotated square, or a diamond\n    float diamond = smoothstep(0., 1., (abs(gposi.x)+abs(gposi.y))*0.5);\n    \n    // this flips the colors of the diamond for the different phases of the anim\n    // together with the grid movement, this produced the visual \"switch\"\n    // from black squares on white bg to white squares on black bg\n    float switchedDiamond = 2. * mix(1.-diamond, diamond, sw);\n    \n    // use the distance func to make squares \n    // float colVal = pow(switchedDiamond, 20.);\n\n    // antialiased version by FabriceNeyret2 - Thank you!\n    // it blurs the edges more where the squares are smaller  \n    float b = 40. / ( iResolution.y * length(pos-vec2(0.,1.)) ); \n    float colVal = smoothstep(-b,b,switchedDiamond-1.);\n\n    // Output to screen\n    fragColor = vec4(vec3(colVal),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mltfzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 64, 64, 147], [149, 149, 177, 177, 228], [230, 230, 283, 283, 336], [338, 468, 512, 512, 574], [576, 576, 606, 606, 694], [722, 722, 779, 779, 2546]], "test": "valid"}
{"id": "Mltfzr", "name": "EGP200_LayedHouse", "author": "adamclarke", "description": "Layering and shape drawing exercise", "tags": ["layers"], "likes": 0, "viewed": 77, "published": "Public", "date": "1538508203", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 BgCol;\n\nvec2 HousePos = vec2(0.5, 0.5);\nfloat HouseSideLength = 0.2;\nvec4 HouseCol;\n\nvec2 ChimneyPos = vec2(0.55, 0.74);\nfloat ChimneyWidth = 0.02;\nfloat ChimneyLength = 0.1;\nvec4 ChimneyCol = vec4(1.0, 0.5, 0.0, 1.0);\n\nvec2 Window1Pos = vec2(0.48, 0.5);\nfloat Window1SideLength = 0.05;\nvec2 Window2Pos = vec2(0.55, 0.5);\nfloat Window2SideLength = 0.02;\nvec4 WindowCol;\n\nvec4 Layers[] = vec4[4](\n    vec4(0.0),\n    vec4(0.0),\n    vec4(0.0),\n    vec4(0.0)\n);\n\nbool VisibleLayers[] = bool[4](\n    true,\n    true,\n    true,\n    true\n); \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Aspect Ratio Correction\n    float aspectRatio = iResolution.y / iResolution.x;\n    uv.y *= aspectRatio;\n    HousePos.y *= aspectRatio;\n    ChimneyPos.y *= aspectRatio;\n    Window1Pos.y *= aspectRatio;\n    Window2Pos.y *= aspectRatio;\n    \n    // Custom UVs\n    float houseUvX = (uv.x - HousePos.x - HouseSideLength / 2.0) / ((HousePos.x - HouseSideLength / 2.0) - (HousePos.x + HouseSideLength / 2.0));\n    float houseUvY = 1.0 - (uv.y - HousePos.y - HouseSideLength / 2.0) / ((HousePos.y - HouseSideLength / 2.0) - (HousePos.y + HouseSideLength / 2.0));\n    vec2 houseUv = vec2(houseUvX, houseUvY);\n    float chimneyUvY = (uv.y - ChimneyPos.y - ChimneyLength / 2.0) / ((ChimneyPos.y - ChimneyLength / 2.0) - (ChimneyPos.y + ChimneyLength / 2.0));\n    \n    // Textures and animation\n    BgCol = texture(iChannel2, uv);\n    HouseCol = texture(iChannel1, houseUv);\n    WindowCol = texture(iChannel0, houseUv);\n    ChimneyCol.r = 1.0 - chimneyUvY + sin(iTime); // Animate chimney r channel\n    \n    // Draw Background Layer\n    Layers[0] = BgCol;\n    \n    // Draw Chimney Layer\n    Layers[1] = ChimneyCol;\n    Layers[1].a = (step(uv.x, ChimneyPos.x - ChimneyWidth / 2.0) - step(uv.x, ChimneyPos.x + ChimneyWidth / 2.0))\n        * (step(uv.y, ChimneyPos.y - ChimneyLength / 2.0) - step(uv.y, ChimneyPos.y + ChimneyLength / 2.0));\n    \n    // Draw House Layer\n    Layers[2] = HouseCol;\n    Layers[2].a = (step(uv.x, HousePos.x - HouseSideLength / 2.0) - step(uv.x, HousePos.x + HouseSideLength / 2.0))\n        * (step(uv.y, HousePos.y - HouseSideLength / 2.0) - step(uv.y, HousePos.y + HouseSideLength / 2.0));\n    \n    // Draw Windows Layer\n    Layers[3] = WindowCol;\n    \n    float window1Interp = (step(uv.x, Window1Pos.x - Window1SideLength / 2.0) - step(uv.x, Window1Pos.x + Window1SideLength / 2.0))\n        * (step(uv.y, Window1Pos.y - Window1SideLength / 2.0) - step(uv.y, Window1Pos.y + Window1SideLength / 2.0));\n    float window2Interp = (step(uv.x, Window2Pos.x - Window2SideLength / 2.0) - step(uv.x,  Window2Pos.x + Window2SideLength / 2.0))\n        * (step(uv.y, Window2Pos.y - Window2SideLength / 2.0) - step(uv.y, Window2Pos.y + Window2SideLength / 2.0));\n    \n    Layers[3].a = window1Interp + window2Interp;\n    \n    // Interpolate for layered effect\n    vec4 col = BgCol;\n    for(int i = 0; i < Layers.length(); i++)\n    {\n        if(VisibleLayers[i])\n        {\n        \tcol = mix(col, Layers[i], Layers[i].a);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col.rgb, 1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "XdfGRr", "previewfilepath": "/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mltfzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[540, 540, 597, 647, 3204]], "test": "error"}
{"id": "MltyzN", "name": "Dots and Spirals", "author": "Vovosunt", "description": "Mouse x for ring count, mouse y for ring curvature.", "tags": ["2d", "fake3d"], "likes": 6, "viewed": 144, "published": "Public", "date": "1538404279", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define smooth (1.0 / iResolution.x)\n#define PI      3.14159265359\n#define liness 8.0\n#define rings 32.0\n#define swirls 8.0\n#define size 0.005\n#define pos 0.15\n#define width 0.055\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = (fragCoord.xy -0.5 * iResolution.xy)/ iResolution.x;\n        \n    vec3 finCol = vec3(0.0);\n    float lines = floor(iMouse.x / iResolution.x * liness + 1.);\n    float swirl = floor(iMouse.y / iResolution.y * swirls + 1.);\n    float maxz = 0.0;\n    \n    \n    for(float i = 0.0; i < lines; ++i){\n    \n        float il = i /lines;\n        \n    \tfloat a =(atan(st.x,st.y) + PI)/PI/2.;\n    \tfloat aa = (floor(a * rings) + 0.5)/rings;\n    \taa = aa * 2.0 * PI - PI;\n    \tfloat offset = floor(a * rings)/rings * 2.0 * PI * swirl + il * 2.0 * PI;\n    \tfloat rt = cos(iTime * 1.0 + offset)/2.0 + 0.5;\n    \tfloat rm = sin(iTime * 1.0 + offset)/2.0 + 0.5;\n    \tfloat ll = mix(pos - width,pos + width,rt);\n    \n    \tvec2 center = vec2(ll*sin(aa),ll*cos(aa));\n\n        float ring = length(center - st);\n        ring = smoothstep(smooth,-smooth,ring -size *(1.0 +  rm)/2.0);\n        //vec3 color = vec3(il, fract(il*2.0),fract(il*3.0)) + vec3(0.15);\n        //float xm = (0.25 + rm)/1.25;\n        //if(maxz < xm){\n        //    finCol = mix(finCol,color * xm,ring);\n        //    maxz = xm;\n        //}\n        //finCol = mix(finCol, color *ring * (0.25 + rm)/1.25, step(maxz - rm,0.0));\n        finCol = max(finCol,ring * (0.25 + rm)/1.25);\n    }\n    \n\tfragColor = vec4(finCol,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltyzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 238, 238, 1519]], "test": "valid"}
{"id": "MlVyD3", "name": "Eye of a Hurricane", "author": "Shadeyboi", "description": "Beginning of nature project to have a top-view of a hurricane design (Nature project 2/3)", "tags": ["natureproject"], "likes": 1, "viewed": 136, "published": "Public", "date": "1538407378", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, -f, f, r);\n}\n\n\nfloat pole(vec2 v, float r){\n  return length(v)-r*2.;\n}\nfloat sphere(vec3 v, float r){\n  return length(v)-r;\n}\nfloat box(vec3 v, float r, float m) {\n  return max(length(v.xy), abs(v.z)-m);\n}\n\n\n\nfloat mixColors(float r, float v, float z){\n  return clamp((v-r), 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x);\n  float m = floor(z/f)+z;\n  z = mod(z, f)-f*.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n//=======================\n\nShape storm(vec3 c){\n  Shape shape;\n  float wall;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n\n  // Shape Attributes\n  float twist = 30.; // Hurricane piece Repeat\n  float wallOffset = 4.; // Column Offset, affects camera view\n\n\n  // Stems\n  vec3 i = c;\n    i.yz *= rot(c.y*0.1+1.5); //Shows top-view of hurricane\n    i.xz *= rot(c.y*.1+iTime*.1); //Spins hurricane, last float controls speed\n    float detail = pModPolar(i.xz, twist*1.1); \n    float x = mix(0., 1., mod(detail, 7.6)); // Split column orbs\n    i.x -= wallOffset-.5; // Offset columns\n  \tfloat stemWidth = .7; //Oscillates width of columns\n  \twall = pole(i.xz, stemWidth+.06*sin(i.y*x));\n\n\n  vec4 color = vec4(.7, .6, .7, .5);\n\t\t//Oscillates colors through most of R-B, and down to black\n  shape.dist = wall;\n  shape.color = color;\n    \n  float pattern = cos(sin(c.z*5.)) / cos(sin(c.y*2.));\n  shape.color /= pattern;\n\n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape hurricane = storm(c);\n  return hurricane;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(cos(iTime)*.1, sin(iTime)*.1, -11.);\n    //Above trig functions rotate camera around perimeter of hurricane\n    //Also effect the speed of movement around the hurricane\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(.7, .7, .7, .85); //Sets a cloudy/stormy gray background\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.04){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.015){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVyD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 164, 186, 186, 253], [255, 255, 273, 273, 343], [346, 346, 374, 374, 401], [402, 402, 432, 432, 456], [457, 457, 494, 494, 536], [540, 540, 583, 583, 616], [618, 618, 661, 661, 727], [729, 729, 768, 768, 919], [947, 947, 967, 967, 1887], [1890, 1890, 1908, 1908, 1960], [1962, 1962, 2019, 2019, 2638]], "test": "valid"}
{"id": "Mt3BD4", "name": "Character Project-SNOWMAN", "author": "cake7914", "description": "snowman", "tags": ["snowman"], "likes": 1, "viewed": 78, "published": "Public", "date": "1540035185", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\n    \n// first object gets a capenter-style tongue attached\nfloat fOpTongue(float a, float b, float ra, float rb) {\n\treturn min(a, max(a - ra, abs(b) - rb));\n}\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat sphere(vec3 v, float r){\n  return length(v)-r;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nShape snowman(vec3 s){\n  Shape shape;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n    \n  vec3 h = s; // Head\n  vec3 b = s; // Body\n  vec3 t = s; // Bottom\n  vec3 u = s; // Buttons\n  vec3 a = s; // Arms\n  vec3 f = s; // Fingers\n  vec3 e = s; // Eyes\n  vec3 r = s; // Hat\n  vec3 m = s; // Mouth\n  vec3 g = s; // Ground\n  vec3 c = s; // Clouds\n  vec3 w = s; // Snow\n  vec3 q = s; // Snowball\n    \n  // Head\n  vec4 hColor = vec4(1., 1., .2, 1.); \n  float head = sphere(s-vec3(0., 2.9, 0.), 2.);\n  \n  // Body\n  vec4 bColor = vec4(.2, 0.5, 0., 1.);\n  float body = sphere(b-vec3(0., -1.5, 0), 3.);\n    \n  // Bottom\n  vec4 tColor = vec4(1., 0., 0., 1.);\n  float bottom = sphere(t-vec3(0., -6., 0), 3.75);\n  \n  // Buttons\n  vec4 uColor = vec4(0., 0., 0., 1.);\n  float button1 = sphere(u-vec3(0., -2., -2.75), .5); // I cannot just repeat along the y axis because of the different\n  float button2 = sphere(u-vec3(0., -0.3, -2.5), .5); // Circumferences of the circles - different buttons have to be farther out, etc\n  \n  // Arms\n  vec4 aColor = vec4(.5, .2, .3, 1.);\n  a.x  = abs(a.x);\n  a.xy *= rot(radians(35.)*sin(iTime)+.5); // Happy snowman :)\n  float arms = fBox(a-vec3(3.5, -2., 0.), vec3(2., .3, 2.));\n  \n  // Fingers\n  //f.x = abs(f.x);\n  //f.xy *= rot(radians(35.)*sin(iTime)); // Happy snowman :)\n  //float finger1 = fBox(f-vec3(5.6, -1.5, 0.), vec3(.2, .5, .5));\n  //float finger2 = fBox(f-vec3(5.6, -2.75, 0.), vec3(.2, .5, .5));\n    \n  // Eyes\n  vec4 eColor = vec4(.2, .6, .7, 1.);\n  e.x = abs(e.x);\n  float eyes = sphere(e-vec3(.75, 3., -2.), .45);\n    \n  // Mouth\n  vec4 mColor = vec4(1., 1., 1., 1.);\n  float mouth = fBox(m-vec3(0., 2., -2.), vec3(1., .25, 1.));\n    \n  // Hat\n  vec4 rColor = vec4(.1, .1, 1., 1.);\n  float hatBottom = fBox(r-vec3(0., 5., 0.), vec3(2., .35, 1.));\n  float hatTop = fBox(r-vec3(0., 6.5, 0.), vec3(1., 1.5, 1.));\n  \n  // Clouds\n  vec4 cColor = vec4(.5, .5, sin(iTime)+.75*3., 1.);\n  float repeat = pMod1(c.x,9.75);\n  c.x = abs(c.x);\n  float clouds = sphere(c-vec3(4., 9., 0.), 3.);\n  \n  // Snow\n  vec4 wColor = vec4(1., 1., 1., 1.);\n  float repeat2 = pMod1(w.x,10.);\n  float repeat3 = pMod1(w.y,8.);\n  w.x = abs(w.x)+1.;\n  w.y = abs(w.y);\n  float snow = sphere(w-vec3(4., 3., 0.), .4);\n    \n  // Snowball\n  q.xy *= rot(radians(35.)*sin(iTime)+.5);\n  float snowball = sphere(q-vec3(6., -2., 0.), 1.25);\n    \n  // Ground\n  vec4 gColor = vec4(2., 2., 2., 1.);\n  float ground = fBox(g-vec3(0., -10., 0.), vec3(20., 2., 0.));\n\n  shape.dist = min(shape.dist, head);\n  shape.dist = min(shape.dist, body);\n  shape.dist = min(shape.dist, bottom);\n  shape.dist = max(shape.dist, -button1);\n  shape.dist = max(shape.dist, -button2);\n  shape.dist = min(shape.dist, arms);\n  //shape.dist = min(shape.dist, finger1);\n  //shape.dist = min(shape.dist, finger2);\n  shape.dist = max(shape.dist, -eyes);\n  shape.dist = max(shape.dist, -mouth);\n  shape.dist = min(shape.dist, hatBottom);\n  shape.dist = min(shape.dist, hatTop);\n  shape.dist = min(shape.dist, clouds);\n  shape.dist = min(shape.dist, snow);\n  shape.dist = min(shape.dist, snowball);\n\n  shape.dist = fOpUnionColumns(shape.dist, ground, 3., 3.); // float fOpUnionColumns(float a, float b, float r, float n)\n  \n  //shape.color = hColor;\n    \n    shape.color = mix(hColor, bColor, mixColors(body, head, 0.));    \n    shape.color = mix(tColor, shape.color, mixColors(shape.dist, bottom, 0.));\n  \tshape.color = mix(uColor, shape.color, mixColors(shape.dist, button1, 0.));\n    shape.color = mix(uColor, shape.color, mixColors(shape.dist, button2, 0.));\n    shape.color = mix(aColor, shape.color, mixColors(shape.dist, arms, 0.));\n  \tshape.color = mix(eColor, shape.color, mixColors(shape.dist, eyes, 0.));\n  \tshape.color = mix(mColor, shape.color, mixColors(shape.dist, mouth, 0.));\n    shape.color = mix(rColor, shape.color, mixColors(shape.dist, hatBottom, 0.));\n    shape.color = mix(rColor, shape.color, mixColors(shape.dist, hatTop, 0.));\n  \tshape.color = mix(gColor, shape.color, mixColors(shape.dist, ground, 0.));\n  \tshape.color = mix(wColor, shape.color, mixColors(shape.dist, snow, 0.));\n  \tshape.color = mix(cColor, shape.color, mixColors(shape.dist, clouds, 0.));\n\tshape.color = mix(wColor, shape.color, mixColors(shape.dist, snowball, 0.));\n\n  return shape;\n}\n\n\nShape map(vec3 s){\n  Shape face = snowman(s);\n  return face;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., -20.);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  //scene.xz *= rot(sin(iTime*2.));\n  fragColor = vec4(0.1);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape s = map(scene); // Calc SDF\n    if(s.dist < 0.0001){\n      fragColor = s.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n      \n    scene += f * s.dist;\n\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3BD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 223, 278, 278, 322], [323, 323, 345, 345, 412], [414, 414, 432, 432, 502], [505, 550, 598, 598, 672], [674, 674, 704, 704, 728], [730, 730, 750, 750, 785], [787, 823, 851, 851, 932], [934, 1078, 1118, 1118, 1239], [1241, 1241, 1284, 1284, 1327], [1329, 1329, 1372, 1372, 1438], [1440, 1440, 1479, 1479, 1635], [1637, 1673, 1698, 1698, 1738], [1740, 1740, 1799, 1799, 2410], [2412, 2412, 2434, 2434, 6698], [6701, 6701, 6719, 6719, 6763], [6765, 6765, 6822, 6822, 7278]], "test": "error"}
{"id": "Mt3BDS", "name": "Motion Illusion animated", "author": "wax78", "description": "Shader tweak based on https://www.shadertoy.com/view/4ldBR2", "tags": ["optical", "illusion", "motion"], "likes": 5, "viewed": 200, "published": "Public", "date": "1540824158", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork from wax78 to animate it for fun.\n\n// Motion Illusion - @P_Malin\n// https://www.shadertoy.com/view/4ldBR2\n\n\n// Lunchtime hacked version of that motion illusion image.\n// Sorry, I don't know the original source.\n// Update: original apparently by @BeauDeeley \n// https://stock.adobe.com/fr/images/optical-motion-illusion-illustration-a-sphere-are-rotation-around-of-a-moving-hyperboloid-abstract-fantasy-in-a-surreal-style/131366127?fbclid=IwAR1sFHeKn93GoVRJrhmOYQTmCPr8Gi_Rwu2ZuKIeYIg9Uz2B\n\n// Code loosely based on https://www.shadertoy.com/view/XsdcDr\n\n#define HEX_PATTERN 1\n\n#define ENABLE_AA 1\n\n#define REVERSE_DIRECTION 0\n\n\nfloat MAX_DIST = 1000.0;\n\n#define PI 3.141592654\n#define TAU  (PI * 2.0)\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n    float fPersp = 3.0;\n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fPersp);\n\n\treturn vDir;\n}\n\nvec4 Scene_SphereA( vec3 vPos )\n{\n    float xPos = -0.5;\n    //flost xPos = -0.5 * sin(iTime)\n    vec3 vSphereDomain = vPos - vec3( xPos, 0.0, 2.0 );\n    float fSphereRadius = 0.4;\n    float fSphereDist = length( vSphereDomain ) - fSphereRadius;\n    vec3 vSphereDir = vSphereDomain / fSphereRadius;\n    //vec2 vSphereUV = vec2( vSphereDir.y, atan( vSphereDir.z, vSphereDir.x )) * 2.0;\n    // Sphere UV code from \twj\n    vec2 vSphereUV = vec2(acos(vSphereDir.y / length(vSphereDir)), atan( vSphereDir.z, vSphereDir.x ))*2.0 ;\n    vec4 vSphereResult = vec4( fSphereDist, vSphereUV, 2.0 );    \n    \n    return vSphereResult;\n}\n\nvec4 Scene_Pillar( vec3 vPos )\n{\n    float fPillarRadius = 1.0 - cos( vPos.y * 2.0 );\n    fPillarRadius = 0.4 + fPillarRadius * fPillarRadius * 0.5;\n    vec2 vPillarOffset = vPos.xz - vec2(0.0, 3.0);\n    float fPillarDist = length( vPillarOffset ) - fPillarRadius;\n    vec2 vPillarUV = vec2( vPos.y * 4.0, 2.5 * atan( vPillarOffset.y, vPillarOffset.x ) );\n    vec4 vPillarResult = vec4( fPillarDist, vPillarUV, 1.0 );\n    \n    return vPillarResult;\n}\n\nvec4 Scene_GetDistance( vec3 vPos )\n{\n\tvec4 vResult = vec4( MAX_DIST, 0.0, 0.0, 0.0 );\n\n    vec2 vWallUV = vec2(vPos.y, -vPos.x) * 1.5;\n    vec4 vWallResult = vec4( -vPos.z + 5.0, vWallUV, 0.0 );\n    \n    if ( vWallResult.x < vResult.x )\n    {\n        vResult = vWallResult;\n    }\n\n\tvec4 vPillarResult = Scene_Pillar( vPos );\n    \n    if ( vPillarResult.x < vResult.x )\n    {\n        vResult = vPillarResult;\n    }\n    \n\tvec4 vSphereResult = Scene_SphereA( vPos );\n    \n    if ( vSphereResult.x < vResult.x )\n    {\n        vResult = vSphereResult;\n    }\n\n    return vResult;\n}\n\nvec3 Scene_GetNormal( const in vec3 vPos )\n{\n    const float fDelta = 0.0001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( e.yxx * fDelta + vPos ).x * e.yxx + \n        Scene_GetDistance( e.xxy * fDelta + vPos ).x * e.xxy + \n        Scene_GetDistance( e.xyx * fDelta + vPos ).x * e.xyx + \n        Scene_GetDistance( e.yyy * fDelta + vPos ).x * e.yyy;\n    \n    return normalize( vNormal );\n}   \n\nvec4 Scene_Trace( vec3 vRayOrigin, vec3 vRayDir, float minDist, float maxDist )\n{\t\n    vec4 vResult = vec4(0);\n    \n\tfloat t = minDist;\n\tconst int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n        float epsilon = 0.0001 * t;\n\t\tvResult = Scene_GetDistance( vRayOrigin + vRayDir * t );\n        if ( abs(vResult.x) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n\t        t = maxDist;\n            break;\n        }               \n        \n        t += vResult.x;\n\t}\n    \n    vResult.x = t;\n    \n    return vResult;\n}    \n\n\n#if HEX_PATTERN\n\n// Returns vec4( distance to edge, distance to centre, vec2( hexagon co-ordinate ) )\n// hexagon co-ordinate integer part is hexagon I.D.\n// hexagon co-ordinate fractional part is uv within the hexagon\nvec4 Hexagon( vec2 pos ) \n{\n    vec2 vScale = vec2( 1.0, sqrt(3.0) );\n    \n    vec2 p = pos * vScale;\n      \n    // :\n    // :\n    // o--+--+--+--+--+--o\n    // |  : /:  |  :\\ :  |\n    // |  :/ :  |  : \\:  |\n    // +--+--+--o--+--+--+\n    // |  :\\ :  |  : /:  |\n    // |  : \\:  |  :/ :  |\n    // o--+--+--+--+--+--o - - - - \n    \n    vec2 f = fract( p );\n    \n    vec2 index = floor( p );\n    index.x *= 2.0;\n    \n    vec2 c;    \n    \n    vec2 t = abs( f - vec2(0.5, 0.5) );\n\n    // get hexagon center and index\n    \n    // (6.0, 2.0) = dimensions of repeating grid above\n    if ( t.x * 6.0 < -t.y * 2.0 + 2.0 )\n    {\n        c = vec2(0.5);        \n    }\n    else\n    {\n        if ( f.x > 0.5 )\n        {\n            c.x = 1.0; \n\n            index.x += 1.0;\n        }\n        else\n        {\n            index.x -= 1.0;\n            c.x = 0.0;\n        }\n        \n        if ( f.y > 0.5 )\n        {\n            c.y = 1.0;            \n            index.y += 1.0;\n        }\n        else\n        {\n            c.y = 0.0;\n        }\n    }\n            \n    vec2 offset = (f - c) / vScale;\n    float d = length( offset );\n    \n    vec2 vDir[3] = vec2[3]( \n        vec2(  0.0, \t\t\t\t1.0 ), \n        vec2( -sqrt(3.0) / 2.0,\t1.0 / 2.0 ),\n        vec2(  sqrt(3.0) / 2.0,\t1.0 / 2.0 ) );    \n    \n    float s = 10000.0;\n    \n    for ( int i=0; i<3; i++ )\n    {\n        float d = 1.0 - abs( dot( offset, vDir[i] ) ) * 2.0 * sqrt(3.0);\n        s = min( s, d );\n    }\n    \n    vec2 vUV = index + offset * 1.5 + 0.5;\n    \n    return vec4(s, d, vUV );\n}\n\n\nvec3 HexPattern( vec2 vUV, vec3 colInner, vec3 colEdge )\n{\n    // uncomment to actually scroll :P\n    //vUV.y -= iTime * 0.01;\n    \n    vec4 hex = Hexagon( vUV );\n    \n    float edgeShade = step( fract(hex.w), 0.5 );\n\n    vec3 col = colInner; \n    col = mix( col, vec3(edgeShade), step(hex.x, 0.3) ); // black / white edge\n    col = mix( col, colEdge, step(hex.x, 0.15) ); ; // Yellow Surround\n        \n    return col;\n}\n\n\n#endif\n\n\n\nvec3 MotionTextureGradient( float f )\n{\n#if 0\n    vec3 cols[] = vec3[](\n        vec3(1,0,0),\n        vec3(1,0,1),\n        vec3(0.95,0,1) * 0.75\n        );\n\n    f *= float( cols.length() );    \n\n    int c1 = int( floor(f) ) % cols.length();\n    int c2 = (c1 + 1) % cols.length();\n    float b = clamp( f - float(c1), 0.0, 1.0 );\n    \n    //b = smoothstep(0.0,1.0,b);\n    return mix( cols[c1], cols[c2], b );    \n#else    \n    vec3 vColA = vec3( 255-253, 255-27, 255-32 ) / 255.0;\n\tvec3 vColB = vec3( 255-198, 255-48, 255-249 ) / 255.0;\n    \n    //vec3 vColA = vec3(1,1,0);\n    //vec3 vColB = vec3(1,.1,0);\n        \n    float fCol = sin(f * TAU) * 0.5 + 0.5;\n    float fLum = sin((f + 0.25) * TAU) * 0.5 + 0.5;\n        \n    float fLumA = 0.9;\n    float fLumB = 1.0;\n\n    return mix( vColA, vColB, fCol ) * mix( fLumA, fLumB, fLum );\n#endif    \n}\n\nvec3 MotionTexture( vec2 vUV, float obj )\n{\n    // hack by wax\n    if ( obj < 0.5 )\n    {\n\t    vUV.x+=iTime/5.0;\n    }\n    else\n    if ( obj < 1.5 )\n\t    vUV.x-=iTime/5.0;\n    else\n    if ( obj < 2.5 )\n\t    vUV-=iTime/5.0;\n     // hack by wax\n    \n#if HEX_PATTERN\n    \n    \n    vec3 innerCol = vec3(1.0);\n\n    if ( obj < 0.5 )\n    {\n        innerCol = vec3(70, 30, 123) / 255.;\n    }\n    else\n    if ( obj < 1.5 )\n    {\n        innerCol = vec3(113, 36, 132) / 255.;\n    }\n    else\n    if ( obj < 2.5 )\n    {\n        innerCol = vec3(133, 39, 76) / 255.;\n    }\n    \n    return HexPattern( vUV * 1.0 + 0.1, innerCol, vec3(198, 161, 57) / 255. );\n#else\n    float x = fract( vUV.x );\n\n    float fOffset = floor( x * 2.0 ) / 2.0;\n    float y = fract( vUV.y + fOffset );\n    \n\treturn MotionTextureGradient( y );\n#endif    \n}\n\nvec3 GetSceneColour( const in vec3 vRayOrigin,  const in vec3 vRayDir )\n{\n    float theta = atan(vRayDir.x, vRayDir.y);\n    vec4 vScene = Scene_Trace( vRayOrigin, vRayDir, 0.0, MAX_DIST );\n    float fDist = vScene.x;\n\tvec3 vPos = vRayOrigin + vRayDir * fDist;\n\t\n    vec3 vNormal = Scene_GetNormal( vPos );\n    vec2 vUV = vScene.yz; \n    \n    \n    if ( fDist > 350.0 )\n    {\n        vUV = vec2(0);\n    }   \n\n#if REVERSE_DIRECTION\n    vUV.y = 1.0 - vUV.y;\n#endif    \n    \n    vec3 vTex = MotionTexture(vUV + 0.25, vScene.w );\n    \n    vTex = vTex * vTex;\n    \n    \n    \n    vec3 vResult = vTex;\n    \n    // Hacked darkening\n    if ( vScene.w == 0.0 )\n    {\n        // darken back wall\n        vResult *= 1.0 - (0.6 / (0.2 + Scene_Pillar( vPos ).x));\n        vResult *= 1.0 - (0.43 / (0.25 + Scene_SphereA( vPos ).x));\n        vResult *= 0.8;\n    }\n    \n    if ( vScene.w == 1.0 )\n    {\n        // darken pillar\n        vResult *= 1.0 - (0.43 / (0.25 + Scene_SphereA( vPos ).x));\n        vResult *= max(0.0, -vNormal.z) * 0.8 + 0.2;\n        vResult *= 1.5;\n    }\n\n    if ( vScene.w == 2.0 )\n    {\n        \n        vResult *= max(0.0, -vNormal.z);\n    }\n\n    \n    vResult *= 1.5;\n\n    return sqrt(vResult);\n}\n\nvoid mainImageNoAA( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n\n\tvec3 vCameraPos = vec3(0.0, 0.0, 0.0);\n\tvec3 vCameraTarget = vec3(0.0, 0.0, 10.0);\n    \n\tvec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir);\n    \t    \n\tfragColor = vec4(vResult, 1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if ENABLE_AA\n    fragColor = vec4(0);\n    float count = 0.0;\n\n    float AA_Size = 4.0;\n    \n    for ( float aaY = 0.; aaY < AA_Size; aaY++ )\n    {\n        for ( float aaX = 0.; aaX < AA_Size; aaX++ )\n        {\n            vec4 vSample;\n            mainImageNoAA( vSample, fragCoord + vec2(aaX, aaY) / AA_Size );\n            \n            fragColor += vSample;\n        \tcount += 1.0;\n        }\t\n    }\n    \n    fragColor /= count;\n#else    \n    mainImageNoAA(fragColor, fragCoord);\n#endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3BDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1258, 1258, 1291, 1291, 1881], [1883, 1883, 1915, 1915, 2333], [2335, 2335, 2372, 2372, 2911], [3342, 3342, 3423, 3423, 3924], [6959, 6959, 7002, 7021, 7776], [8984, 8984, 9045, 9045, 9392], [9396, 9396, 9453, 9453, 9942]], "test": "error"}
{"id": "Mt3BRj", "name": "Square cubed", "author": "AntoineC", "description": "Squishing rhombus to morph from squares to cubes!", "tags": ["2d", "loop", "minimalist"], "likes": 22, "viewed": 213, "published": "Public", "date": "1540328824", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ----------------------------------------------------------------------------------------\n//\t\"Square Cubed\" by Antoine Clappier - Oct 2018\n//\n//\tLicensed under:\n//  A Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n//\thttp://creativecommons.org/licenses/by-nc-sa/4.0/\n// ----------------------------------------------------------------------------------------\n\n\n#define Pi     3.14159265359\n#define Tau    6.28318530718\n\n#define ToRad(a)     ((a)*Pi/180.0)\n#define ToDeg(a)     ((a)*180.0/Pi)\n\n#define Rot(a)       mat3(cos(ToRad(a)),-sin(ToRad(a)),0.,sin(ToRad(a)),cos(ToRad(a)),0.,0.,0.,1.)\n#define RotP(a,p)    (Translate(-p)*Rot(a)*Translate(p))\n#define Rot45        Rot(45.0)\n#define Scale(s)     mat3(1./(s),0.,0.,0.,1./(s),0.,0.,0.,1.0)\n#define Translate(t) mat3(1.,0.,0.,0.,1.,0.,-(t).x,-(t).y,1.0)\n\n\n#define Count 2.0\n#define Duration 15.0\n\n// -----------------------------------------------------------\n// -----------------------------------------------------------\n\n// IQ’s Exact signed distance of a Rhombus\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat RhombusSd(in vec3 p, in vec2 size) \n{\n    vec2 q = abs(p.xy);\n\n    float h = clamp( (-2.0*ndot(q,size) + ndot(size,size) )/dot(size,size), -1.0, 1.0 );\n    float d = length( q - 0.5*size*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*size.y + q.y*size.x - size.x*size.y );\n}\n\nfloat RhombusSd(in vec2 p, in vec2 size) \n{\n    vec2 q = abs(p);\n\n    float h = clamp( (-2.0*ndot(q,size) + ndot(size,size) )/dot(size,size), -1.0, 1.0 );\n    float d = length( q - 0.5*size*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*size.y + q.y*size.x - size.x*size.y );\n}\n\n// -----------------------------------------------------------\n// -----------------------------------------------------------\n\n\nvec4 Tile(vec2 uvi, vec2 uvf, float eps, float t)\n{\n    // Tweeners:\n    float t0 = smoothstep(    0.0, 1.0/3.0, t);\n    float t1 = smoothstep(1.0/3.0, 2.0/3.0, t);\n    float t2 = smoothstep(2.0/3.0,     1.0, t);\n    float ts = mix(t0, 1.0-t2, step(0.5,t));\n \n    // Cube/hexagon center:\n    float cc = sqrt(3.0)/6.0;\n    vec2 ccc = vec2(cc-0.5, 0.5-cc);\n    \n    // Post rotation and translation:\n    mat3 post;\n    post =  Translate(ccc*(t2-t0));\n    post *= Rot(180.*t1);\n    \n   \n    // Rhombus transforms:\n    mat3 tfm0, tfm1, tfm2;\n    tfm0  = Rot45*Translate(vec2(-0.5,0.5));\n    tfm0 *= post;\n\n    tfm1 =  Rot(135.)*Translate(vec2(-0.5,-0.5));\n    tfm1 *= RotP(30.*(t0-t2), vec2(-1.0,0.0));\n    tfm1 *= post;\n    \n    tfm2  = Rot(135.)*Translate(vec2(0.5,0.5));\n    tfm2 *= RotP(30.*(t2-t0), vec2(0.0,1.0));\n    tfm2 *= post;\n                     \n    // Rhombus size:\n    vec2 s = vec2(1.0, mix(1.0, sqrt(3.0)/3.0, ts)) / sqrt(2.0);\n    \n    // Draw Rhombus:\n    vec3 uvh = vec3(uvf,1.0);\n    vec4 c = vec4(0.0);\n    eps *= 1.5;\n    c = mix(vec4(vec3(0.2),1.0), c, smoothstep(0.0, eps, RhombusSd(tfm2*uvh, s)));\n    c = mix(vec4(vec3(0.8),1.0), c, smoothstep(0.0, eps, RhombusSd(tfm0*uvh, s)));\n    c = mix(vec4(vec3(0.5),1.0), c, smoothstep(0.0, eps, RhombusSd(tfm1*uvh, s)));\n\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized coordinates:\n    float eps = 2.0/iResolution.y;\n    vec2  uv =  eps*(fragCoord - 0.5*iResolution.xy);\n\tfloat t  = fract(iTime/Duration);\n    \n    // Rotate field:\n    float tr = 0.3*t+0.7*smoothstep(0.0, 1.0, t);\n    uv = (Rot(-180.*tr)*vec3(uv,1.)).xy;\n    \n    // Tiling:\n    vec2 uvf, uvi;\n    uv = uv*Count - vec2(0.5);\n    uvi = floor(uv);\n    uvf = 2.0*fract(uv)-1.0;\n    eps *= 2.0*Count;\n\n    // Render tile:\n    vec4 tile = Tile(uvi, uvf, eps, t);\n    vec4 col = mix(vec4(0.0), tile, tile.a);\n  \n    // Output:\n    fragColor = col;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3BRj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-4.0", "functions": [[1012, 1057, 1086, 1086, 1114], [1115, 1115, 1158, 1158, 1394], [1396, 1396, 1439, 1439, 1672], [1802, 1802, 1853, 1870, 3105], [3108, 3108, 3165, 3196, 3731]], "test": "valid"}
{"id": "Mt3fWN", "name": "Chanel Doodle #2", "author": "Flopine", "description": "15 minutes improvisation training for a performance at the Chanel Foundation gala", "tags": ["raymarching", "performance", "15mins"], "likes": 4, "viewed": 126, "published": "Public", "date": "1539635694", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui and Coyhot for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n#define ITER 64.\n#define PI 3.141592\n#define time iTime\n#define BPM 50.\n#define tempo BPM/60.\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.*PI*(c*t+d));}\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y, p.x);\n    float l = length(p);\n    a = mod(a-per/2., per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\nvec2 mo(vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y > p.x) p.xy = p.yx;\n    return p;\n}\n\nfloat stmin(float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5 * (u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat pulse (float s)\n{return exp(-fract(time * tempo) * s);}\n\nfloat tiktak(float period)\n{\n    float tik = floor(time*tempo)+pow(fract(time*tempo),3.);\n    tik *= 3.*period;\n    return tik;\n}\n\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\nfloat od (vec3 p, float d)\n{\n    p.xy *= rot(time*0.2);\n    p.xz *= rot(time*0.5);\n    return dot(p, normalize(sign(p)))-d;\n}\n\nfloat cyl (vec2 p, float r)\n{return length(p)-r;}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat prim1(vec3 p)\n{\n    p.xy *= rot(p.z*0.2);\n    p.xy = moda(p.xy, 2.*PI/3.);\n\n    p.x -= 2.;\n    p.xz = moda(p.xz, 2.*PI/5.);\n    p.x -= 0.8;\n    return cyl(p.xz, 0.1);\n}\n\nfloat prim2 (vec3 p)\n{\n    float per = 3.;\n    p.z = mod(p.z-per/2., per)-per/2.;\n    return prim1(p);\n}\n\nfloat prim3 (vec3 p)\n{\n    float pr = prim2(p);\n    p.xy *= rot(p.z);\n    p.xy = moda(p.xy, 2.*PI/5.);\n    p.x -= .7;\n    return smin(pr,cyl (p.xy, 0.1), 1.);\n}\n\nfloat g = 0.;\nfloat SDF(vec3 p)\n{\n  float d = min(prim3(p),max(-od(vec3(p.x,p.y,p.z-time), 0.8),sphe(vec3(p.x,p.y,p.z-time),1.)));\n  g+=0.1/(0.1+d*d); \n  return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    uv += texture(iChannel0, uv+vec2(time*0.2,time*0.1)).r*0.06;\n    vec3 ro = vec3(0.001,0.001,-4. + time); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n\n    float shad = 0.;\n\n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/ITER;\n            break;\n        }\n        p += d*rd*0.8;\n    }\n\n    float t = length(ro-p);\n\n    vec3 pal = palette\n    (length(uv),\n    vec3(0.5),\n    vec3(0.5),\n    vec3(0.5),\n    vec3(0.,0.3,0.4));\n\n    vec3 c = vec3(1.-shad)*(1.-pal);\n    c = mix(c, pal, 1.-exp(-0.001*t*t));\n    c+= g*0.016*length(uv)*2.;\n    fragColor = vec4(pow(c, vec3(0.45)),1.);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3fWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[275, 275, 331, 331, 362], [364, 364, 395, 395, 521], [523, 523, 548, 548, 614], [616, 616, 665, 665, 771], [773, 773, 814, 814, 891], [893, 893, 912, 912, 955], [957, 957, 980, 980, 1018], [1020, 1020, 1048, 1048, 1149], [1151, 1151, 1181, 1181, 1201], [1203, 1203, 1231, 1231, 1328], [1330, 1330, 1359, 1359, 1379], [1381, 1381, 1410, 1410, 1497], [1499, 1499, 1520, 1520, 1673], [1675, 1675, 1697, 1697, 1779], [1781, 1781, 1803, 1803, 1941], [1957, 1957, 1976, 1976, 2108], [2111, 2111, 2168, 2168, 2927]], "test": "error"}
{"id": "Mt3fz2", "name": "Animated Cursor", "author": "parameterized", "description": "animated cursor test", "tags": ["2d", "animated", "cursor"], "likes": 1, "viewed": 364, "published": "Public API", "date": "1540251766", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define M_PI 3.1415926535897932384626433832795\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/min(iResolution.x, iResolution.y);\n    \n    vec3 col = vec3(0.0);\n    if (distance(uv, vec2(0.0)) < 0.06) {\n    \tcol = vec3(1.0);\n    }\n    for (int i=0; i < 5; i++) {\n    \tfloat a = -iTime*0.5 + float(i)*M_PI*2.0/5.0;\n        float d = 0.15 + sin(iTime)*0.02;\n        vec2 p = vec2(cos(a), sin(a))*d;\n        if (distance(uv, p) < 0.03) {\n        \tcol = vec3(1.0);\n        }\n    }\n\t\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3fz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 106, 106, 571]], "test": "valid"}
{"id": "Mt3fz8", "name": "Linear(Nonlinear) programming", "author": "hk_shao", "description": "Linear(Nonlinear) programming", "tags": ["linear", "programming", "nonlinear"], "likes": 1, "viewed": 364, "published": "Public API", "date": "1538580534", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define LINE_SIZE 2.0\n#define GRID_LINE_SIZE 1.0\n#define GRID_AXIS_SIZE 3.0\n#define GRID_LINES 1.0\n#define GRAD_OFFS vec2(0.0001 * ZOOM, 0.0)\n#define GRAD(f, p) (vec2(f(p) - f(p + GRAD_OFFS.xy), f(p) - f(p + GRAD_OFFS.yx)) / GRAD_OFFS.xx)\n#define PLOT(f, c, d, p) d = mix(c(d, p), d, smoothstep(0.0, (LINE_SIZE / iResolution.y * ZOOM), abs(f(p) / length(GRAD(f,p)))))\n\n#define PI (atan(1.0) * 4.0)\n#define ZOOM 10.0\n\nfloat Func(vec2 p)\n{\n\treturn float(!(\n\t\t(p.y > 1.0) &&\n\t\t(p.y - p.x * p.x > 0.0) &&\n\t\t(p.y < 5.0)\n\t));\n}\n\nfloat Target(vec2 p)\n{\n\treturn p.x * p.x * p.x + p.y * p.y;\n}\n\nvec3 Color(vec3 d, vec2 p)\n{\n\treturn d * 0.8 * (clamp(10.0 - abs(tan(iTime)) * Target(p), 0.0, 1.0)) + vec3(1, 0, 1);\n}\n\n// table properties\nconst int columns = 5;\nconst int rows = 6;\nconst int tableCol = 6;\nconst int[] table = int[](\n14, 17, 25, 21, 19, 14, // 0\n14,  4,  4,  4, 12,  4, // 1\n31,  8,  4,  2, 17, 14, // 2\n14, 17,  1,  6,  1, 31, // 3\n 2, 31, 18, 10,  6,  2, // 4\n14, 17,  1, 30, 16, 31, // 5\n14, 17, 17, 30, 16, 14, // 6\n 4,  4,  4,  2,  1, 31, // 7\n14, 17, 17, 14, 17, 14, // 8\n14,  1, 15, 17, 17, 14, // 9\n12, 12,  0,  0,  0,  0, // .\n 0,  0, 31,  0,  0,  0, // -\n 4,  4, 31,  4,  4,  0);// +\n\nvec2 uvmap(vec2 uv){\n    return (2.*uv-iResolution.xy)/iResolution.y;\n}\n\n//print(uv, center, width, height, index)\nfloat print(vec2 uv, vec2 c, float w, float h, int ind)\n{\n    float r = 0.;\n    vec2 wh = vec2(w/float(columns),h/float(rows));\n    vec2 o =  vec2(w,h)/2.; // origin\n    vec2 bmin=c-o, bmax=c+o; // min and max boundaries\n    \n    // no need to render ouside boundaries.\n    if(uv.x<bmin.x||uv.y<bmin.y|| \n       uv.x>bmax.x||uv.y>bmax.y) return 0.;\n    \n    c = bmin; // move center to the origin\n    for(int row=0;row<rows;row++){\n        int map = table[ind*tableCol+row];\n        for(int col=0;col<columns;col++){\n            vec2 p0 = c+wh*vec2(col,row), p1 = p0+wh;\n            vec2 lb = step(p0,uv);\n            vec2 ub = 1.-step(p1,uv);\n            \n            int shift = columns-col-1;\n            if(((map&(1<<shift))>>shift)==1) \n                r += lb.x*lb.y*ub.x*ub.y;\n        }\n    }\n    return r;\n}\n\nfloat printNumber(vec2 uv, vec2 c, float w, float h, float num, int decN, float spacing, bool center)\n{\n    w*=iResolution.y/iResolution.x; // keep aspect ratio\n    spacing*=iResolution.y/iResolution.x;\n    \n    float r = 0.;\n    bool neg = num<0.; num=abs(num);\n    float cd = float(decN);\n    float cn = max(ceil(log(num)/log(10.)),1.);\n    float dec = fract(num)*pow(10., 6.0);\n    \n    if(center) // move to origin\n    {\n        c.x += (cn+cd-1.)*(w+spacing)/2.;\n        if(decN>0) c.x+=spacing;\n        if(neg)c.x+=(w+spacing)/2.;\n    }\n    else\n    {\n        c.x += (cn+cd-1.)*(w+spacing)+w;        \n        if(decN>0) c.x+=spacing*2.;\n        if(neg)c.x+=w+spacing;\n    }\n        \n    // print fractions\n    for(int i=0;i<decN;i++,dec/=10.){\n        int val = int(mod(dec,10.));\n        r += print(uv, c, w, h, val);\n        c.x-=w+spacing; // move left\n    }\n    if(decN>0) // print dot separator\n    {\n        c.x+=spacing;\n        r += print(uv, c, w, h, 10);\n        c.x-=w;\n    }\n    // print whole part\n    for(int i=0;i<int(cn);i++,num/=10.){\n        int val = int(mod(num,10.));\n        r += print(uv, c, w, h, val);\n        c.x-=w+spacing; // move left\n    }\n    if(neg) r+=print(uv, c, w, h, 11); // print sign\n    return r;\n}\n\nfloat grid(vec2 p)\n{\n\tvec2 uv = mod(p,1.0 / GRID_LINES);\n\n\tfloat halfScale = 1.0 / GRID_LINES / 2.0;\n\n\tfloat gridRad = (GRID_LINE_SIZE / iResolution.y) * ZOOM;\n\tfloat grid = halfScale - max(abs(uv.x - halfScale), abs(uv.y - halfScale));\n\tgrid = smoothstep(0.0, gridRad, grid);\n\n\tfloat axisRad = (GRID_AXIS_SIZE / iResolution.y) * ZOOM;\n\tfloat axis = min(abs(p.x), abs(p.y));\n\taxis = smoothstep(axisRad - 0.05, axisRad, axis);\n\n\treturn min(grid, axis);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = ((gl_FragCoord.xy - iMouse.xy) / iResolution.y) * ZOOM;\n\n\tvec3 col = vec3(grid(uv) * 0.45 + 0.55);\n\n\t\tPLOT(Func, Color, col, uv);\n    \n    vec2 xx = fragCoord.xy / iResolution.y +\n\t\tvec2((iResolution.y - iResolution.x) /\n\t\t\t(2.0 * iResolution.y), 0.0);\n\n\tif (any(lessThan(abs(xx - 0.5), vec2(0.002))) &&\n\t\t((distance(vec2(0.5), xx) < 0.02))) {\n\t\t\tcol *= 0.4;\n\t}\n    \n    float px = ((iResolution.x / 2.0 - iMouse.x) / iResolution.y) * ZOOM;\n    col -= printNumber(uvmap(fragCoord.xy), vec2(-0.5, -0.90), 0.1, 0.1, px, 6, 0.1, true);\n    float py = ((iResolution.y / 2.0 - iMouse.y) / iResolution.y) * ZOOM;\n    col -= printNumber(uvmap(fragCoord.xy), vec2(0.5, -0.90), 0.1, 0.1, py, 6, 0.1, true);\n    \n\tfragColor = vec4(col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3fz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[417, 417, 437, 437, 521], [523, 523, 545, 545, 584], [586, 586, 614, 614, 705], [1199, 1199, 1219, 1219, 1270], [1272, 1314, 1371, 1371, 2129], [2131, 2131, 2234, 2234, 3374], [3376, 3376, 3396, 3396, 3829], [3832, 3832, 3887, 3887, 4633]], "test": "error"}
{"id": "MtcBDM", "name": "truchet quadtree distance", "author": "abje", "description": "just like [url=https://www.shadertoy.com/view/4t3BW4]shane's quadtree truchet shader[/url].", "tags": ["2d", "truchet", "quadtree"], "likes": 16, "viewed": 722, "published": "Public API", "date": "1540231457", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//i made this shader because shane's shader looked so fancy\n//https://www.shadertoy.com/view/4t3BW4\n//\n//Multi-Scale Truchet Patterns  - Christopher Carlson\n//https://christophercarlson.com/portfolio/multi-scale-truchet-patterns/\n//Linking paper containing more detail:\n//http://archive.bridgesmathart.org/2018/bridges2018-39.pdf\n\n//some macros\n#define subs 0.4\n#define limit 5.0\n//#define grid\n\n//some constant macros\n#define HASHSCALE3 vec3(.6531, .5563, .7498)\n\n//hash function in hash without sine by Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW\n//it seems to make a weird truchet pattern\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z*15.3023+0.434);\n}\n\nfloat checktree(float i, vec2 r) {\n    for (float j = 0.0; j < i; j++) {\n        vec2 h = floor(r*exp2(j))*exp2(-j);\n        float rand = hash13(vec3(h,int(j)));\n        if (rand >= subs) {\n            return j;\n        }\n    }\n    return i;\n}\n\nfloat truchet(vec2 p, int type) {\n    float len;\n    if (type == 0)\n    {\n        p = p+step(p.x+p.y,0.0)-0.5;\n        len = abs(length(p)-0.5)-0.1667;\n    }\n    else if (type == 1)\n    {\n        len = -length(abs(p)-0.5)+0.3333;\n    }\n    else if (type == 2)\n    {\n        vec2 dir;\n        if (abs(p.x) > abs(p.y)) {\n            dir = vec2(sign(p.x),0.0);\n        } else {\n            dir = vec2(0.0,sign(p.y));\n        }\n        len = abs(length(p-dir*0.5))-0.1667;\n    }\n    else if (type == 3)\n    {\n        vec2 dir;\n        if (abs(p.x) > abs(p.y)) {\n            dir = vec2(sign(p.x),0.0);\n        } else {\n            dir = vec2(0.0,sign(p.y));\n        }\n        len = min(abs(length(p-0.5)-0.5),abs(length(p-dir*0.5)))-0.1667;\n    }\n    else if (type == 4)\n    {\n        p = abs(p)-0.1667;\n\n        len = -length(min(p,0.0))+max(min(p.x,p.y),0.0);\n    }\n    else if (type == 5)\n    {\n        p.y = abs(p.y);\n\n        len = min(p.y,length(p-vec2(0,0.5)))-0.1667;\n    }\n    else if (type == 6)\n    {\n        p.x = abs(p.x);\n        len = min(max(-p.y-0.1667,-length(p-0.5)+0.3333),length(p+vec2(0,0.5))-0.1667);      \n    }\n    return len;\n}\n\nfloat quadtruchet(vec2 p) {\n    float len = 0.0;\n    \n    float j = checktree(limit, p);\n    float i = j;\n    \n    //the position in the bottom left corner of the truchet cell\n    vec2 fp = floor(p*exp2(i))*exp2(-i);\n\n    //the local position on the truchet cell (always 0-1)\n    vec2 lp = (p-fp)*exp2(i);\n    \n    float rand = fract(hash13(vec3(fp,-i))*10.0);\n    vec2 q = lp-0.5;\n\n    int celltype = int(rand*7.0);\n    int rots = int(fract(rand*7.0)*4.0);\n\n    for (int i = 0; i < rots; i++) {\n        q = vec2(q.y,-q.x);\n    }\n    \n    float l = truchet(q,celltype);\n    \n    len = l*exp2(-i)*(1.0-mod(i,2.0)*2.0);\n    //len = l*exp2(-i);\n    \n    for (i = i; i <= limit; i++) {\n        \n        //the position in the bottom left corner of the truchet cell\n        fp = floor(p*exp2(i))*exp2(-i);\n\t\t\n        //the local position on the truchet cell (always 0-1)\n        lp = (p-fp)*exp2(i);\n\n        //check for the overlapping black dots\n        vec2 p2 = p*exp2(i);\n        vec2 fp2 = floor(p2-0.5);\n        for(int x = -1; x <= 2; x++) {\n            for(int y = -1; y <= 2; y++) {\n                vec2 r = (fp2+vec2(x,y))*exp2(-i);\n                //this branch doesn't do anything, but it skips the random() once\n                if (r != fp)\n                {\n                    j = checktree(i, r);\n\n                    if (i==j) {\n                        float l = length(abs(p2-fp2-vec2(x,y)-0.5)-0.5)-0.3333;\n                        float s = mod(i,2.0)*2.0-1.0;\n                        len = min(l*exp2(-i),len*s)*s;\n                    }\n                }\n            }\n        }\n\t}\n    return len;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates (from -1 to 1)\n    float scale = 1.0;\n    vec2 uv = scale*(fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    //\"world space\" coordinates, always moves up to the right.\n    vec2 p = uv+iTime*0.1+vec2(-24,21);\n    \n    float len = quadtruchet(p);\n    \n    float a = exp2(checktree(limit,p));\n    \n    #ifdef grid\n    vec2 lp = abs(fract(p*a)*2.0-1.0);\n    float b = max(lp.x,lp.y);\n    a /= iResolution.y*0.2;\n    b = max(b-1.0+1.0*a,0.0)/a;\n    #endif\n    \n    //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n    vec3 col = 1.0 - sign(len)*vec3(0.1,0.4,0.7);\n\tcol *= min(1.0 - exp(-6.0*abs(len)),0.8);\n\tcol *= 0.8 + 0.2*cos(200.0*abs(len));\n\tcol = mix( col, vec3(1), 1.0-min(abs(len)*0.25*iResolution.y,1.0) );\n    \n    #ifdef grid\n    col += b;\n    #endif\n    \n    fragColor = vec4(col,1);\n    \n\t//fragColor = vec4(vec3(sqrt(len*iResolution.y/scale*0.5)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtcBDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[465, 601, 624, 624, 746], [748, 748, 782, 782, 991], [993, 993, 1026, 1026, 2141], [2143, 2143, 2170, 2170, 3757], [3759, 3759, 3816, 3856, 4729]], "test": "valid"}
{"id": "MtcBRn", "name": "Sierpinski Carpet Fractal Zoom", "author": "koi", "description": "A simple looping Sierpinski Carpet fractal zoom animation.", "tags": ["procedural", "fractal", "zoom", "animated", "animation"], "likes": 5, "viewed": 238, "published": "Public", "date": "1538350197", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord - iResolution.xy / 2.0;\n    vec2 offset = vec2(-0.5);\n    \n    float col = 0.0;\n    float t = iTime / 1.5;\n    \n    float scale = pow(3.0, mod(t, 2.0) + 1.0);\n    float size = iResolution.y * scale;\n    float rot = t / 2.0;\n\n    pos = mat2(cos(-rot), sin(-rot), -sin(-rot), cos(-rot)) * pos;\n    pos += offset * iResolution.y * (scale * 0.5 - 0.5);\n\n    while(size > 1.0) {\n        size /= 3.0;\n        ivec2 ip = ivec2(round(pos / size));\n\n        if(ip.x == 0 && ip.y == 0) {\n            col = min(size*size, 1.0);\n            break;\n        } else {\n            pos -= vec2(ip) * size;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col, col, col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtcBRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 756]], "test": "valid"}
{"id": "MtcBW7", "name": "First shader attempt", "author": "cras", "description": "Not particularly interesting, but I'm still getting my head wrapped around the basic concepts. ", "tags": ["grid"], "likes": 9, "viewed": 142, "published": "Public", "date": "1539809448", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(in vec2 _st, in float _radius){\n    vec2 l = _st-vec2(0.5);\n    return 1.-smoothstep(_radius-(_radius*0.2),\n                         _radius+(_radius*0.2),\n                         dot(l,l)*4.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //aspect ratio normalized coords\n    vec2 uv = (fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    //center point\n    vec2 c = normalize(-iResolution.xy / iResolution.y);\n    \n    //distance to center\n    float d = distance(uv, c);\n    \n    //vary size by time + sin wave\n    float size = sin(d * 5.0 + float(iFrame) * 0.05) + 1.1;\n    \n    //scale and gridifiy\n    uv *= 18.;\n    uv = fract(uv);\n\n    vec3 col = vec3(circle(uv, size));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtcBW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 210], [212, 212, 269, 306, 750]], "test": "valid"}
{"id": "MtcBz7", "name": "Stranger mandelbrot", "author": "avataren", "description": "Multiple scene mandelbrot shader, using minimum iteration count with early exit for antialiasing.", "tags": ["fractal", "mandelbrot", "reactive", "zoom", "antialiasing"], "likes": 2, "viewed": 177, "published": "Public", "date": "1539040774", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Smooth\n#define MaxIter 1024.\n#define aa 2. //antialiasing steps\n#define aa_delta 1./aa\n#define AspectRatio iResolution.x/iResolution.y\n//#define StillImage\n\n//optimization to skip major parts of the set if zoomed out\nbool opt1(vec2 c)\n{\n    float a=(c.x-0.25);\n    float y2 = c.y*c.y;\n    float p=sqrt(a*a+y2);\n    float b = c.x+1.;\n    return (c.x < (p-2.*p*p+0.25)) || b*b+y2 < (1./16.);\n}\n//pretty standard mandelbrot iteration, with early exit for antialiasing\nfloat Mandelbrot(vec2 c, float minIter)\n{\n    if (opt1(c)) return MaxIter; //try for early exit\n    vec2 z = c;\n    float i;\n    for (i=0.;i<MaxIter;i++){\n        if( dot(z,z)>(4.) ) break; //escapes to infinity\n        if (minIter < i) {\n            i=MaxIter; //early antialiasing exit\n            break;\n        }\n        z = vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y) + c; //iterate mandelbrot formula\n    }\n\n    #ifdef Smooth\n   \tfloat sl = i - log2(log2(dot(z,z))) + 4.0; //IQs smoothing formula\n    return sl; //this gives some banding with current aa method, but looks kinda cool too\n    #else\n    return i;\n    #endif\n}\n//2d rotation\nvec2 rotate (vec2 v,float r)\n{\n    float s = sin(r);\n    float c = cos(r);\n    mat2 rot = mat2(c,-s,s,c);\n    return v*rot;\n}\n//list of interesting locations to zoom in to\nvec2 getLocation(int idx)\n{\n    vec2 locations[7]= vec2[](\n    vec2 ( -1.25066,0.02012),\n    vec2 ( -0.0452407411, 0.9868162204352258),\n    vec2 ( 0.452721018749286, 0.39649427698014),\n    vec2 ( -1.7590170270659, 0.01916067191295),\n    vec2 ( -0.235125, 0.827215),\n    vec2 ( 0.2549870375144766, -0.0005679790528465),\n    vec2 ( 0.2929859127507, 0.6117848324958));\n    return locations[idx];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tfloat fft = texelFetch(iChannel0,ivec2(1,0),0).x;\n    \n    vec3 col = vec3(0);\n    float t = iTime*0.1;\n    \n    #ifdef StillImage\n    t=200.;\n    #endif\n    //iterate between various locations over time\n    int lidx=int(mod(floor(t*.3),7.));\n    vec2 location=getLocation(lidx);\n    vec2 colUV;\n    //minIter is used to find the lowest iteration sample when antialiasing\n    float minIter = MaxIter;\n    float mandelColor = 0.;\n     //fudge some zoom factor together\n    float zoom = pow(((sin(t)*0.5+0.5)*.25+.001),1.8);\n    //antialiasing loop\n    for (float y=0.;y<aa;y++)\n        for (float x=0.;x<aa;x++)\n        {\n\t\t    // Normalized pixel coordinates (from -2 to 2)\n            vec2 uv = fragCoord/(iResolution.xy+vec2(x,y)*aa_delta)*4.-2.;\n            uv.x*=AspectRatio;\n            uv=rotate(uv,t)*zoom+location;    \n            float sampleIter = Mandelbrot(uv, minIter);//fetch mandelbrot sample\n            \n            if (sampleIter < minIter)\n            {\n                //store the minimum value found in antialiasing steps\n                //this gives cleaner image then supersampling and averaging\n                minIter = sampleIter; //update the new minimum iteration count found\n                colUV = uv; //store the captured \"uv\" coordinate used in calculation for color calculation later\n            }\n        }\n    \n    if (minIter < MaxIter) //prevent flickering inside set\n\t\tmandelColor = minIter/MaxIter;\n    //simple music reaction\n    //mandelColor*=(0.5+fft);\n    //pick some nice colors\t\n \tcol = (0.5 + 0.5*cos(mandelColor*64.+colUV.xyy+vec3(.1,.2,.3)))*pow(mandelColor,0.05);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "XtXGRr", "previewfilepath": "https://soundcloud.com/user-365177788/stranger-things-main-theme", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/user-365177788/stranger-things-main-theme", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtcBz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 225, 244, 244, 399], [400, 473, 514, 514, 1091], [1092, 1106, 1136, 1136, 1231], [1674, 1674, 1731, 1731, 3382]], "test": "error"}
{"id": "MtcBzf", "name": "semistructured", "author": "cardinalsine", "description": "Attempted to create a pseudorandom noise algorithm somewhat inspired by Perlin noise. I can't say it's on par with Perlin noise, but I think it's visually interesting.", "tags": ["abstract"], "likes": 6, "viewed": 118, "published": "Public", "date": "1540453729", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define PHI 1.61803398875\n\n// time (uniform)\n#define u_t iTime\n// resolution (uniform)\n#define u_res iResolution\n\nfloat sinStep(float x, float w) {\n    float y = (x+(1./w)*sin(w*x));\n    return y;\n}\n\nfloat fibonacciHash(float x) {\n    return mod((1./PHI)*x,1.);\n}\n\nfloat cosInterp(float x, float p0, float p1) {\n    return p0+(p1-p0)*0.5*(1.-cos(PI*fract(x)));\n}\n\nfloat linInterp(float x, float p0, float p1) {\n    return p0+(p1-p0)*fract(x);\n}\n\nfloat distanceDet(vec2 p) {\n    float d0 = distance(vec2(-1.,1.), p.xy),\n    \t  d1 = distance(vec2(1.,1.), p.xy),\n    \t  d2 = distance(vec2(-1.,1.), p.xy),\n          d3 = distance(vec2(-1.,-1.), p.xy);\n\t\n    mat2 m0 = mat2(d0, d1,\n                   d2, d3);\n    \n    return determinant(m0);\n}\n\nfloat fHashNoiseF(float x) {\n    // integer part of coordinates\n    float x_i = floor(x);\n    \n    // hash\n    float x0 = fibonacciHash(x_i),\n    \t  x1 = fibonacciHash(x_i+1.);\n    \n    float fx = cosInterp(x, x0, x1);\n    return fx;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (-1.+2.*(fragCoord/u_res.xy))*(u_res.xy/u_res.xx);\n    \n    float r = distance(vec2(0.0),uv.xy);\n    float theta = atan(uv.y/uv.x);\n\t\n    float x_co = fHashNoiseF(8.*(distanceDet(uv.xy-2.))+4.*sinStep(u_t/8.,PI));\n    float y_co = fHashNoiseF(8.*(distanceDet(uv.yx-2.))+4.*sinStep(u_t/8.+0.5,PI));\n    \n    float sum = 0.;\n    float a = 0.;\n    vec3 col = vec3(0.);\n    for(float i = 1.; i < 128.; i++) {\n        a = exp2(-(i-1.)*0.5);\n        sum += a;\n        col += a*cos(i*PI*cos(PI*(2.*r-u_t/4.+0.5*(x_co+y_co)*(1.+exp2(-6.+(r*r))*vec3(0.,0.5,1.)))));\n    }\n    col = 0.5*(1.+col)/sum;\n \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtcBzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 172, 172, 223], [225, 225, 255, 255, 288], [290, 290, 336, 336, 387], [389, 389, 435, 435, 469], [471, 471, 498, 498, 764], [766, 766, 794, 829, 1001], [1004, 1004, 1061, 1112, 1776]], "test": "valid"}
{"id": "MtcfRf", "name": "Carnival Entrance", "author": "Shadeyboi", "description": "Environment Shader #2", "tags": ["environment"], "likes": 2, "viewed": 72, "published": "Public", "date": "1540572700", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}    \n    \n    \n// Maximum/minumum elements of a vector    \nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}    \n    \n    \nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\n\n// ============================\n// http://mercury.sexy/hg_sdf/\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\nfloat sphere(vec3 v, float r){\n  return length(v)-r;\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat fOpUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n// ============================\n\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n\n\n//=======================\n\nShape Hallway(vec3 c){\n  Shape shape;\n    vec4 color = vec4(.65);\n    vec3 r = c;\n    vec3 t = c;\n    vec3 g = c;\n    vec3 cut = c;\n    vec3 s = c;\n    vec3 l = c;\n    \n    c.z = repeat(c.z, 2.);\n    r.z = repeat(r.z, 1.5);\n    t.z = repeat(t.z, 3.);\n    g.z = repeat(g.z, 2.);\n    cut.z = repeat(cut.z, 2.);\n    s.z = repeat(s.z, 2.);\n    l.z = repeat(l.z, 2.);\n    \n    //Columns, connecting bar, and floor\n    c.x = abs(c.x)-.5;\n    vec4 colColor = vec4(1.);\n    float c1 = sdCylinder(c-vec3(1.4, .0, 0.), vec3(.1, 1.1, 0.3)); //Columns\n    float b1 = fBox(c-vec3(1.5, .8, 0.), vec3(.3, 0.1, 1.)); //Connecting Bar\n    float fl = fBox(c-vec3(0., -1., 0.), vec3(1.8, .05, 1.)); //Floor\n    \n    //Column cutouts\n    cut.x = abs(cut.x)-.5;\n    float c2 = sdCylinder(cut-vec3(1.4, 0., -.2), vec3(.1, 1., .1));\n    \n    //Chandelier Hangings\n    g.x = abs(g.x*2.)-.5;\n    g.y -= .3;\n    g.xy *= rot(g.x+radians(75.));\n    vec4 hangColor = vec4(0., 0., 1., 0.);\n    float g1 = fBox(g-vec3(.3, -.5, 0.), vec3(.05, 1.5, .04));\n    \n    //Roof\n    r.xy *= rot(-r.x*.25);\n    vec4 roofC = vec4(1., 0., 0., 1.);\n    float ro = fBox(r-vec3(0., 1.5, 0.), vec3(1.2, .1, .8)); \n    \n    //Side Streamers\n    s.x = abs(s.x)-.54;\n    s.yz *= rot(-s.z+radians(90.));\n    vec4 streamers = vec4(abs(sin(iTime)), 0., cos(iTime), 1.);\n    float s1 = fBox(s-vec3(1.5, 0., .1), vec3(.05, 1.5, .04));\n    \n    //Lights\n    l.x = abs(l.x)-.33;\n    vec4 lColor = vec4(1., 1., 0., 1.);\n    float light = sphere(l-vec3(0., .75, 0.), .1);\n    \n    shape.dist = fOpUnionChamfer(c1, b1, .1);\n    shape.dist = fOpUnionChamfer(ro, shape.dist, .01);\n    shape.dist = fOpUnionChamfer(shape.dist, fl, .2);\n    shape.dist = fOpUnionChamfer(shape.dist, g1, .25);\n    shape.dist = max(shape.dist, -c2);\n    shape.dist = fOpUnionStairs(shape.dist, s1, .2, .2);\n    shape.dist = fOpUnionRound(shape.dist, light, .05);\n    \n    shape.color = color;\n    shape.color = mix(colColor, roofC, mixColors(ro, c1, .01));\n    shape.color = mix(hangColor, shape.color, mix(shape.dist, g1, .6));\n    shape.color = mix(streamers, shape.color, mix(shape.dist, s1, .99));\n    shape.color = mix(lColor, shape.color, mix(shape.dist, light, .999999999));\n    \n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape hall = Hallway(c);\n  return hall;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., iTime);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.0001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtcfRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 308, 348, 348, 469], [484, 528, 548, 548, 573], [575, 575, 595, 595, 630], [632, 632, 652, 652, 697], [712, 712, 734, 734, 801], [803, 803, 821, 821, 891], [894, 957, 985, 985, 1066], [1068, 1068, 1104, 1104, 1138], [1141, 1141, 1171, 1171, 1195], [1197, 1293, 1351, 1351, 1461], [1463, 1517, 1582, 1582, 1623], [1625, 1625, 1688, 1688, 1728], [1730, 1730, 1778, 1778, 1863], [1865, 1865, 1915, 1915, 1964], [2000, 2000, 2043, 2043, 2086], [2088, 2088, 2131, 2131, 2197], [2199, 2199, 2238, 2238, 2394], [2424, 2424, 2446, 2446, 4645], [4648, 4648, 4666, 4666, 4710], [4712, 4712, 4769, 4769, 5183]], "test": "valid"}
{"id": "MtcfRs", "name": "Japanese Temple Walkway", "author": "tqle", "description": "Tribute to Japanese Temples", "tags": ["environment"], "likes": 2, "viewed": 112, "published": "Public", "date": "1540605323", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define repeat(v, r) (mod(v, r)-r/2.)\n//construct Shape class\nstruct Shape {\n  float dist;\n  vec4 color;\n};\n//repeating variables, coordinates, shapes. Replaces repeat()\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}       \nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}       \nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n//rotating shapes using matrix/linear algebra\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n//creates a pole\nfloat pole(vec2 v, float r){\n  return length(v)-r;\n}\n//creates a sphere\nfloat sphere(vec3 v, float r){\n  return length(v) - r;\n}\n//creates a box\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n//creats a ring\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n//unionizes shapes, making stairs from intersection\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b - r;\n\treturn min(min(a,b), 0.5*(u + a + abs((mod(u - a + s, 2.*s)) - s)));\n}\n//\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\nfloat mixColors(float r, float v, float z) {\n  return clamp(0.5 + 0.5*(v - r)/z, 0., 1.);\n}\nfloat mixShapes(float v, float f, float r) {\n  float z = mixColors(v, f, r);\n  return mix(f, v, z) - r*z*(1. - z);\n}\nfloat pModPolar(inout vec2 v, float r) {\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x) + f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f) - f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\nfloat opTwist(vec3 p) {\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return float(q);\n}\nfloat sdEllipsoid(in vec3 p, in vec3 r) {\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0 - 1.0)/k1;\n}\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\nfloat sdCappedCylinder(vec3 p, vec2 h) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nvec3 mod289(vec3 x) { return x - floor(x*(1.0/289.0))*289.0; }\nvec2 mod289(vec2 x) { return x - floor(x*(1.0 / 289.0))*289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0) + 1.0)*x); }\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v - i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute(i.y + vec3(0.0, i1.y, 1.0))\n        + i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m;\n    m = m*m;\n    vec3 x = 2.0*fract(p*C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314*(a0*a0 + h*h);\n    vec3 g;\n    g.x  = a0.x*x0.x + h.x*x0.y;\n    g.yz = a0.yz*x12.xz + h.yz*x12.yw;\n    return 130.0*dot(m, g);\n}\nShape animation(vec3 c){\n  Shape shape; \n  vec4 color = vec4(1.134, .25, .25, 1.);  \n  vec3 fr = c; //frame\n    fr.z = repeat(fr.z, 5.);\n    fr.x = abs(fr.x) - 1.5;\n    //fr.x = repeat(fr.x, 5.);\n    pMod1(fr.x, 5.);\n    //fr.xz *= rot(iTime);\n  vec3 ha = c; //handle\n    ha.z = repeat(ha.x, 5.);\n    ha.x = abs(ha.x) - 2.;\n  vec3 tor = c;\n    tor.z = repeat(tor.z, 5.);\n    tor.x = abs(tor.x) - 1.5;\n    tor.x *= sin(tor.x*100000000000. - iTime*2.);\n    //tor.y *= sin(tor.y*15. - iTime*2.)*(2. - tor.x)*.03;\n    //tor += sin(tor.x*15. -iTime*2.)*(2. - tor.y)*.03;\n    //tor.xy *= rot(radians(180.));\n  vec3 tor2 = c;\n    tor2.z = repeat(tor2.z, 5.);\n    tor2.x = abs(tor2.x) - 1.5;\n    tor2.x *= sin(tor2.x*100000000000. - iTime*2.);\n  \n  vec3 tor3 = c;\n    tor3.z = repeat(tor3.z, 5.);\n  vec3 st = c; //stars\n    st.z = repeat(st.x, 2.);\n    st.x = abs(st.x) - .1*sin(iTime);\n  //vec3 tali = c;\n    //tali.z = repeat(tali.z, 5.);\n    //tali.x = abs(tali.x) - .1;\n    //tali.y = abs(tali.y) - .25;\n    ////tali.z += sin(iTime);\n    //pMod1(tali.z, 16.);\n    \n  vec3 lan = c;\n    //lan.z = repeat(lan.z, 20.);\n    pMod1(lan.z, 15.);\n    //pMod1(lan.z, sin(iTime)*1.);\n    mod289(lan);\n  vec3 b = c;\n    pMod1(b.z, 15.);\n    //pMod1(b.z, sin(iTime)*1.);\n  \n  float frame = fBox(fr - vec3(0., 0., 0.), vec3(.05, 2., .05)); \n  float handle = sdTorus(ha - vec3(0., 0., 0.), vec2(.7, .1));\n  float torch = fCone(tor - vec3(0., 1.5, 0.), .05, .1);\n  float torch2 = fCone(tor2 - vec3(0., 1.9, 0.), .05, .1);\n  float torch3 = sdCappedCylinder(tor3 - vec3(0., 1.75, 0.), vec2(.03, .15));\n  float stars = sphere(st - vec3(0., 0., 0.), .01);\n  float lantern = sphere(lan - vec3(.5*cos(iTime)*sin(iTime), .5*sin(iTime), 0.), .1);\n  float box = fBox(b - vec3(.5*cos(iTime)*sin(iTime), .5*sin(iTime), 0.), vec3(.075, .075, .075));\n  //float talisman = fBox(tali - vec3(0., 0., 0.), vec3(.02,.15, .01));\n  \n  shape.dist = fOpUnionStairs(frame, handle, .1, 2.);\n  //shape.dist = min(shape.dist, torch);\n  shape.dist = fOpUnionStairs(shape.dist, torch, .1, 3.);\n  shape.dist = fOpUnionStairs(shape.dist, torch2, .1, 3.);\n  shape.dist = min(shape.dist, torch3);\n  shape.dist = min(shape.dist, stars);\n  shape.dist = min(shape.dist, lantern);\n  shape.dist = max(-box, shape.dist);\n  //shape.dist = fOpDifferenceStairs(shape.dist, box, .1, 3.);\n  //shape.dist = fOpUnionStairs(shape.dist, talisman, .1, 3.);\n  vec4 frCol = vec4(1., 1., 22./255., 1.);\n  vec4 torCol =  vec4(2., 0., 2., cos(10.*iTime));\n  vec4 stCol = vec4(0., 0., 0., 0.);\n  vec4 lanCol = vec4(1.*sin(iTime*cos(lan.x)*100.), 10.*lan.x, 224./255., 1.);\n  vec4 haCol = vec4(0., 1. - cos(iTime), 1.*sin(iTime)*cos(iTime), 1.);\n  //shape.color = color;\n  shape.color = mix(color, torCol, mixColors(torch, shape.dist, 0.));\n  shape.color = mix(shape.color, stCol, mixColors(stars, shape.dist, 0.));\n  //shape.color = mix(color, torCol, mixColors(shape.dist, torch*10., 0.));\n  \n    lanCol.rg += snoise(lan.yz*.1) + .5*sin(iTime);\n    lanCol.gb += snoise(lan.xy*.1) + 1.*cos(iTime);\n    //haCol.g *= ha.z*.1*cos(iTime);\n    //frCol.rg -= snoise(fr.yz*.1*sin(iTime)) + .75*cos(iTime);\n   \t//shape.color.rg += snoise(c.yz*.25) + 1.5*sin(iTime)*cos(iTime);\n  shape.color = mix(shape.color,  lanCol, mixColors(lantern, shape.dist, 1.0));\n  shape.color = mix(shape.color, haCol, mixColors(handle, shape.dist, 1.0));\n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape anim = animation(c);\n  return anim;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., iTime);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(0.);\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); \n    if(c.dist < 0.001){\n      fragColor = c.color*(1. - z); \n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtcfRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 170, 210, 210, 331], [339, 339, 359, 359, 384], [385, 385, 405, 405, 440], [442, 442, 462, 462, 507], [515, 515, 537, 537, 604], [605, 651, 669, 669, 739], [740, 757, 785, 785, 809], [810, 829, 859, 859, 885], [886, 902, 930, 930, 1011], [1012, 1028, 1059, 1059, 1129], [1130, 1182, 1240, 1240, 1346], [1347, 1350, 1415, 1415, 1456], [1457, 1457, 1520, 1520, 1560], [1561, 1561, 1609, 1609, 1694], [1695, 1695, 1739, 1739, 1786], [1787, 1787, 1831, 1831, 1903], [1904, 1904, 1944, 1944, 2104], [2105, 2105, 2128, 2128, 2271], [2272, 2272, 2313, 2313, 2404], [2405, 2405, 2454, 2454, 2952], [2953, 2953, 2993, 2993, 3092], [3093, 3093, 3114, 3114, 3155], [3156, 3156, 3177, 3177, 3220], [3221, 3221, 3243, 3243, 3280], [3281, 3281, 3303, 3303, 4323], [4324, 4324, 4348, 4348, 7693], [7696, 7696, 7714, 7714, 7760], [7762, 7762, 7819, 7819, 8181]], "test": "error"}
{"id": "MtcfzM", "name": "yin-yang", "author": "teraspora", "description": ".", "tags": ["yinyang"], "likes": 2, "viewed": 1017, "published": "Public", "date": "1539005901", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653588\n//#define f fragCoord.xy\n// Some useful colours:\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 crimson =      vec3(1.,   0.,   0.4  );\nconst vec3 yellow =      vec3(1.,   1.,   0.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 orange = vec3(1.0, 0.4, 0.);\nconst vec3 cyan = vec3(0., 0.4, 1.0);\nconst vec3 magenta = vec3(1.0, 0., 1.0);\nconst vec3 gold = vec3(1.0, 0.84, 0.66);\n\nvec3[] cols = vec3[](white, crimson, yellow, magenta, gold, cyan, orange);\nvec3 col;\n\n// My inline library of useful functions:\n// =======================================\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\nfloat om(float x) {\n\treturn 1. - x;\n}\n\nvec3 om(vec3 v) {\n\treturn 1. - v;\n}\n\nfloat op(float x) {\n\treturn 1. + x;\n}\n\nfloat nsin(float x) {\n\treturn op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n\treturn op(cos(x)) * 0.5;\n}\n\nfloat sqrtp(float x) {\n\treturn sqrt(x < 0. ? -x : x); \n}\n\nfloat nmmod(float x, float y) {\n\tfloat xmn = 2. * mod(x, y) / y;\n    return xmn < 1. ? xmn : om(xmn);\n}\n\nvec3 omss(float mn, float mx, vec3 val) {\n\treturn om(smoothstep(mn, mx, val));\n}\n\nvec2 nmouse() {\n\treturn iMouse.xy / iResolution.xy;\n}\n\nvec3 invert(vec3 col) {\n \treturn 1. - clamp(col, 0., 1.);   \n}\n\nbool isOdd(float p) {\n    return fract(p * 0.5) >= 0.5;\n}\n\n// =======================================\n\n// rand generator from \n// https://www.youtube.com/watch?v=l-07BXzNdPw&t=740s\nvec2 r22(vec2 p) {\n\tvec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n\ta += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\n\nfloat f(float x) {\n\treturn sin(cos(0.2 * iTime * x)) + cos(2. * sin(0.23 * iTime * x)) - sqrt(0.2 *abs(x) * cos(0.02 * iTime * x));\n}\n\nvec3 drawBorder(vec3 col, float b, vec3 insetColour, vec2 pp, vec2 hr, float tileIndex) {\n    // `b` is the border width\n    // `col` is the input (and output) colour\n    // `pp` is (unnormalised) coordinate of pixel\n    // `hr` is (unnormalised) resolution\n    // Make a border: `b` px solid black; with `insetColour` inset:\n    if (tileIndex != -1.) {\n    \t//  any special code for single-pane use goes here    \n    }\n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = insetColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = insetColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));\n    return col;\n    \n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = 24. - iTime / 24.;\n    float scale = 0.6 * sin(t / 2.);\n\tfloat asp = iResolution.x/iResolution.y;\n    // Normalized pixel coordinates (y from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.y - vec2(0.5 * asp, 0.5)) / scale;\n\t//uv.y = abs(uv.y);\n    if (nmouse().x >= 0.5) uv = abs(uv);\n    \n    uv += 0.5 * cos(t / 12.) * vec2(cos(uv.x * t), sin(uv.y * t));\n    uv.x += 8. * nsin(t / 10.) * ncos(t / 10.) * sin(uv.y);\n    uv.y += .04 * ncos(uv.x * t / 3.) * ncos(t / 7.) * sin(44. * uv.y);\n    \n    \n    \n    col = vec3(sin(3. * sin(t) * length(uv) * 40.) + sin(t * 6.  + uv.x * 20.));\n    col.b *= length(uv);\n    col.r *= nsin(abs(length(uv* 1000.) + uv.x));\n    col.g = ncos(13. * sin(6. *t) * length(uv) * 50.) + cos(t * 0.125  + (uv.x + uv.y * 0.02 * nsin(t)));\n    \n    \n    \n    \n    \n    \n    // Border code:    \n    // ============    \n    float borderWidth = 6.;\n    vec3 borderInsetLineColour = orange;\n \tcol = drawBorder(col, borderWidth, borderInsetLineColour, fragCoord, iResolution.xy, -1.);\n    \n    // Output to screen\n    fragColor = vec4(col.gbr, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtcfzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[604, 604, 623, 623, 652], [654, 654, 686, 686, 733], [735, 735, 763, 763, 828], [830, 830, 862, 862, 903], [905, 905, 924, 924, 942], [944, 944, 961, 961, 979], [981, 981, 1000, 1000, 1018], [1020, 1020, 1041, 1041, 1069], [1071, 1071, 1092, 1092, 1120], [1122, 1122, 1144, 1144, 1178], [1180, 1180, 1211, 1211, 1283], [1285, 1285, 1326, 1326, 1365], [1367, 1367, 1382, 1382, 1420], [1422, 1422, 1445, 1445, 1484], [1486, 1486, 1507, 1507, 1543], [1589, 1667, 1685, 1685, 1813], [1816, 1816, 1834, 1834, 1949], [1951, 1951, 2040, 2276, 2822], [2824, 2824, 2881, 2881, 3966]], "test": "error"}
{"id": "MtdBD8", "name": "Alien Structures", "author": "ChrisWebb", "description": "A small collection of fractal scenes. Enjoy!", "tags": ["fractal"], "likes": 42, "viewed": 1114, "published": "Public", "date": "1539514058", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 1 // Plop this on 2/3 for a nicer, slower image\n#define MAX_STEPS 512\n#define PRECISION 0.0005\n#define ITERATIONS 20\n\nstruct kf\n{\n    float time;\n    vec3 pos;\n    vec3 dir;\n    float rotation;\n    float yOffset;\n    float scale;\n    vec3 offset;\n    float fov;\n    float fade;\n    vec3 g0Pos;\n    float g0Size;\n    float g0Strength;\n    vec3 g0c0;\n    vec3 g0c1;\n    float g1Strength;\n    vec3 g1c0;\n    vec3 g1c1;\n};\n    \n//#define OVERRIDE_FRAME 14\n//#define TIME_SKIP 150.0\n\nkf frames[] = kf[] \n(          \n    kf(0.0, vec3(1.5,-2.25, 3.5), vec3(0.0,0.0,-1.0), 0.0, 0.735, 1.75, vec3(2.8,0.5,0.025), 1.0, 3.0, \n       vec3(0.0,0.0, 1.0), 2.0,\n       1.0, vec3(0.2, 0.7, 0.5), vec3(0.2, 0.5, 0.5), \n       5.0, vec3(0.0, 0.5, 0.5), vec3(0.2, 0.9, 0.0)),\n    \n    kf(30.0, vec3(1.65,-1.5, 4.0), vec3(0.0,5.0,0.0), 0.05, 0.735, 1.75, vec3(2.8,0.5,0.025), 0.5, 0.5, \n       vec3(0.0,0.0, 1.0), 2.0,\n       0.5, vec3(0.7, 0.7, 0.0), vec3(0.0, 0.5, 0.7), \n       5.0, vec3(0.0, 0.5, 0.5), vec3(0.2, 0.9, 0.0)),\n        \n\t//----------\n    \n    kf(30.0, vec3(0.0,0.0, 5.035), vec3(0.0,0.0,1.0), 0.0, 0.74, 1.8, vec3(2.8,0.5,0.0), 0.35, 0.5, \n       vec3(0.0,0.0, 5.04), 0.03, \n       2.0, vec3(1.0, 0.3, 0.1), vec3(0.9, 0.25, 0.1), \n       1.5, vec3(0.5, 0.2, 0.0), vec3(0.5, 0.95, 0.0)),\n    \n    kf(60.0, vec3(0.0,0.0, 4.975), vec3(1.0,1.0,0.0), 0.0, 0.74, 1.8, vec3(2.8,0.5,0.0), 1.0, 0.5, \n       vec3(0.0,0.0, 5.04), 0.01, \n       1.0, vec3(1.0, 0.5, 0.0), vec3(0.9, 0.05, 0.0), \n       1.0, vec3(0.5, 0.1, 0.0), vec3(0.5, 0.7, 0.0)),\n\n    //----------\n    \n    kf(60.0, vec3(-1.10,0.0, 3.5), vec3(-1.0, 0.0,-1.0), 0.0, 0.74, 1.8, vec3(2.1,2.1,0.4), 3.0, 0.5, \n       vec3(0.0,0.0, 5.04), 0.1, \n       2.0, vec3(0.5, 0.4, 0.9), vec3(0.2, 0.5, 0.7), \n       2.0, vec3(0.73, 0.5, 0.1), vec3(0.5, 0.95, 0.3)),\n    \n    kf(80.0, vec3(0.0,0.0, 4.8), vec3(0.0,0.0,-1.0), 0.0, 0.74, 1.8, vec3(2.1,2.1,0.4), 1.0, 0.5, \n       vec3(0.0,0.0, 5.04), 0.1, \n       1.0, vec3(0.5, 0.4, 0.9), vec3(0.2, 0.5, 0.7), \n       10.0, vec3(0.73, 0.5, 0.1), vec3(0.5, 0.95, 0.3)),\n    \n    //----------   \n\n    kf(80.0, vec3(2.5, 2.5, 0.0), vec3(0.0,0.0,1.0), 1.0, 0.74, 1.8, vec3(1.59,0.2,0.065), 1.0, 0.5, \n       vec3(0.0,0.0, 5.5), 0.1, \n       1.0, vec3(0.4, 0.78, 0.91), vec3(0.6, 0.3, 0.75), \n       4.0, vec3(0.4, 0.78, 0.91), vec3(0.6, 0.3, 0.75)),\n\n    kf(100.0, vec3(1.5, 1.5, 0.1), vec3(-0.4,-0.3,1.0), 0.0, 0.74, 1.8, vec3(1.59,0.2,0.065), 1.0, 0.5, \n       vec3(0.0,0.0, 5.45), 0.5, \n       1.0, vec3(0.4, 0.78, 0.91), vec3(0.6, 0.3, 0.75), \n       4.0, vec3(0.4, 0.78, 0.91), vec3(0.6, 0.3, 0.75)),\n    \n    //----------   \n\n    kf(100.0, vec3(0.0,0.1, 2.25), vec3(1.0,0.0,0.7), 0.0, 0.75, 1.8, vec3(2.59,0.5,0.05), 1.0, 0.5, \n       vec3(0.0,0.1, 2.25), 1.0, \n       0.5, vec3(0.7, 0.2, 0.2), vec3(0.3, 0.3, 0.9), \n       3.0, vec3(0.7, 0.2, 0.2), vec3(0.3, 0.3, 0.9)),\n\n    kf(120.0, vec3(0.0,1.5, 2.35), vec3(1.0,-0.5,0.7), 0.0, 0.75, 1.8, vec3(2.59,0.5,0.05), 0.85, 0.5, \n       vec3(0.0,0.1, 2.25), 01.5, \n       0.5, vec3(0.2, 0.2, 0.5), vec3(0.3, 0.3, 0.9), \n       3.0, vec3(0.5, 0.2, 0.2), vec3(0.3, 0.3, 0.9)),\n\n    //----------   \n\n    kf(120.0, vec3(0.0,0.0, 4.0), vec3(1.0,0.0,0.0), 1.0, 1.25, 2.5, vec3(2.028,1.0,0.48), 1.0, 0.5, \n       vec3(0.0,0.0, 5.04), 0.3, \n       1.0, vec3(0.5, 0.4, 0.9), vec3(0.2, 0.5, 0.7), \n       5.0, vec3(0.73, 0.5, 0.1), vec3(0.5, 0.95, 0.3)),\n\n    kf(150.0, vec3(0.0,1.0, 2.0), vec3(1.0,0.0,1.0), 0.0, 1.4, 3.25, vec3(4.0,0.5,0.8), 1.0, 1.0, \n       vec3(0.0,0.0, 5.04), 0.3, \n       1.0, vec3(0.5, 0.4, 0.9), vec3(0.2, 0.5, 0.7), \n       5.0, vec3(0.73, 0.5, 0.1), vec3(0.5, 0.95, 0.3)),\n    \n    //----------   \n\n    kf(150.0, vec3(3.0, 3.0, 0.5), vec3(-1.0,-1.0,-1.0), 0.0, 0.64, 1.8, vec3(1.659,0.02,0.0765), 1.0, 0.5, \n       vec3(0.0,0.0, 5.04), 0.1, \n       1.0, vec3(0.5, 0.4, 0.9), vec3(0.2, 0.5, 0.6), \n       2.0, vec3(0.3, 0.5, 0.5), vec3(0.9, 0.2, 0.0)),\n\n    kf(180.0, vec3(2.5, 2.5, 1.0), vec3(-1.0,-1.0,1.0), 0.0, 0.64, 1.8, vec3(1.659,0.02,0.0765), 1.0, 0.5, \n       vec3(0.0,0.0, 0.0), 5.0,\n       0.5, vec3(0.9, 0.2, 0.0), vec3(0.3, 0.5, 0.5), \n       3.0, vec3(0.3, 0.4, 0.5), vec3(0.9, 0.2, 0.0)),\n    \n    //----------   \n\n    kf(180.0, vec3(2.0, 2.0, 1.0), vec3(1.0,1.0,1.0), 0.0, 0.64, 1.8, vec3(1.45,0.01,0.17), 1.0, 0.5, \n       vec3(2.0, 2.0, 1.0), 0.0, \n       0.3, vec3(1.0, 0.0, 0.0), vec3(0.2, 0.2, 0.2), \n       3.5, vec3(0.4, 0.4, 0.9), vec3(0.9, 0.3, 0.3)),\n\n    kf(210.0, vec3(1.75, 1.75, 0.99), vec3(1.0,-1.0,1.0), 1.0, 0.64, 1.8, vec3(1.45,0.01,0.17), 1.0, 0.5, \n       vec3(2.0, 2.0, 1.0), 0.0, \n       0.3, vec3(1.0, 1.0, 1.0), vec3(0.2, 0.2, 0.2), \n       3.5, vec3(0.3, 0.4, 1.0), vec3(1.0, 0.4, 0.3))\n);\n\nkf interpFrames(kf a, kf b, float t)\n{\n  \tkf f;\n    f.time = t;\n    f.pos = mix(a.pos, b.pos, t);\n    f.dir = mix(a.dir, b.dir, t);\n    f.rotation = mix(a.rotation, b.rotation, t);\n    f.yOffset = mix(a.yOffset, b.yOffset, t);\n    f.scale = mix(a.scale, b.scale, t);\n    f.offset = mix(a.offset, b.offset, t);\n    f.fov = mix(a.fov, b.fov, t);\n    float totalTime = b.time-a.time;\n    f.fade = clamp(0.0, 1.0, min(t * (totalTime/a.fade), (1.0-t) * (totalTime/b.fade)));    \n    f.g0Pos = mix(a.g0Pos, b.g0Pos, t);\n    f.g0Size = mix(a.g0Size, b.g0Size, t);\n    f.g0Strength = mix(a.g0Strength, b.g0Strength, t);\n    f.g0c0 = mix(a.g0c0, b.g0c0, t);\n\tf.g0c1 = mix(a.g0c1, b.g0c1, t);    \n    f.g1Strength = mix(a.g1Strength, b.g1Strength, t);\n    f.g1c0 = mix(a.g1c0, b.g1c0, t);\n\tf.g1c1 = mix(a.g1c1, b.g1c1, t);\n    return f;  \n}\n\nkf evaluateFrame()\n{\n    #ifdef OVERRIDE_FRAME\n   \treturn frames[OVERRIDE_FRAME];\n    #endif\n    float t = 0.0;\n    float timeLoop = mod(iTime, frames[frames.length()-1].time);\n    \n    #ifdef TIME_SKIP\n    timeLoop = mod(iTime + TIME_SKIP, frames[frames.length()-1].time);\n    #endif\n    \n    int i = 0;\n    for(; i < frames.length()-1; ++i)\n    {\n        if(timeLoop < frames[i+1].time)\n        {\n            float tTime = frames[i+1].time - frames[i].time;\n            float tUp = timeLoop - frames[i].time;\n            t = tUp / tTime;\n            break;\n        }\n    }\n    \n    return interpFrames(frames[i], frames[i+1], t);\n}\n\nfloat map(vec3 p, kf f)\n{\n    p /= 2.0;\n    float ov = 1.0 / 3.0;\n\tfloat r;\n\tint i = 0;\n\twhile (i < ITERATIONS && dot(p, p) < 10000.0)\n\t{\n\t\tp.xy = abs(p.xy);\n\t\tif(p.y > p.x) p.xy = p.yx;\n\t\tp.y = f.yOffset - abs(p.y - f.yOffset);\n\t\tp.x += ov;\n\t\tif(p.z > p.x) p.xz = p.zx;\n\t\tp.x -= ov;\n\t\tp.x -= ov;\n\t\tif(p.z > p.x) p.xz = p.zx;\n\t\tp.x += ov;\n\t\tp = f.scale * (p - f.offset) + f.offset;\n\t\tr = dot(p, p);\n\t\t++i;\n\t}\n\n\treturn abs(length(p) - length(f.offset)) * pow(f.scale, float(-i));\n}\n\nvec3 render(in vec3 ro, in vec3 rd, in vec2 uv, kf frame)\n{ \n    const float breakout = 20.0;\n    \n    int iteration = 0;\n    float depth = 0.0;\n    \n    for(; iteration < MAX_STEPS; ++iteration)\n    {\n\t    float precis = PRECISION * depth;\n\t    float dist = map(ro + rd * depth, frame);\n        \n        if(dist < precis || depth > breakout) \n        {\n            break;\n        }\n        depth += dist;\n    }\n    \n    vec3 pos = ro + depth * rd;\n    \n    float glow0 = float(iteration) / float(MAX_STEPS);\n    glow0 = clamp(pow(glow0 * 3.0, 1.0), 0.0, 1.0);\n    float glow1 = pow(glow0, 3.20);\n    \n    float distFromPoint = clamp(0.0, 1.0, distance(pos, frame.g0Pos) / frame.g0Size);\n\t\n    vec3 glowColor0 = mix(frame.g0c0, frame.g0c1, clamp(distFromPoint, 0.0, 1.0));\n    vec3 col = glowColor0 * glow0 * frame.g0Strength;\n    \n    vec3 glowColor1 = mix(frame.g1c0, frame.g1c1, clamp(0.0, 1.0, uv.y/2.0));\n\tcol.rgb += glowColor1 * glow1 * frame.g1Strength;\n    \n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tkf frame = evaluateFrame();\n    \n    vec3 cSum = vec3(0.0, 0.0, 0.0);\n    \n    for(int i = 0; i < AA; ++i)\n    {\n        for(int j = 0; j < AA; ++j)\n        {\n            vec2 o = vec2(float(i),float(j)) / float(AA) - 0.5;\n            vec2 p = (-iResolution.xy + 2.0 * (fragCoord+o)) / iResolution.y;\n            vec3 ro = frame.pos;\n            float cr = frame.rotation;\n            vec3 cw = normalize(frame.dir);\n            vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n            vec3 cu = normalize(cross(cw ,cp));\n            vec3 cv = normalize(cross(cu, cw));\n            mat3 ca = mat3(cu, cv, cw);\n            vec3 rd = ca * normalize(vec3(p.xy, 2.0 * frame.fov));\n\n            cSum += render(ro, rd, p, frame);\n        }\n    }\n    \n    cSum /= float(AA*AA);\n    \n    #ifndef OVERRIDE_FRAME\n    cSum.rgb *= frame.fade;\n    #endif\n\n    cSum = pow(cSum, vec3(0.4545));\n    cSum = cSum * 1.2 - 0.1;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv *=  1.0 - uv.yx;\n    \n    cSum *= clamp(0.0, 1.0, pow(uv.x*uv.y * 5.0, 0.1));\n    \n    float n = texture(iChannel0, fragCoord.xy/iChannelResolution[0].xy).r;\n    cSum.rgb += mix(-3.0 / 255.0, 3.0 / 255.0, n);\n\n    fragColor = vec4(cSum, 1.0);\n}\n\n", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtdBD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[4699, 4699, 4737, 4737, 5529], [5531, 5531, 5551, 5551, 6164], [6166, 6166, 6191, 6191, 6646], [6648, 6648, 6707, 6707, 7628], [7630, 7630, 7685, 7685, 8887]], "test": "error"}
{"id": "MtdBRj", "name": "BIMMExperiment2", "author": "mssososophie", "description": "Adding music ", "tags": ["outlands"], "likes": 1, "viewed": 50, "published": "Public", "date": "1540319500", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*4.0;\n    \n    float fft=texture(iChannel0,vec2(440.0/11025.0,0.6)).r;\n            +texture(iChannel0,vec2(200.0/11025.0,0.2)).r;\n            +texture(iChannel0,vec2(125.0/11025.0,1)).r;\n    \t\t+texture(iChannel0,vec2(1000.0/11025.0,1)).r;\n   \n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*tan(iTime+fft+uv.yxy+vec3(0,4,4));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtdBRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 543]], "test": "error"}
{"id": "MtdBWN", "name": "Spiral Graph", "author": "AntoineC", "description": "Sine spiral with amplitude modulation. Better in full screen!", "tags": ["2d", "spiral"], "likes": 19, "viewed": 210, "published": "Public", "date": "1539887335", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define Pi     3.14159265359\n#define Tau    6.28318530718\n#define Rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define RadiusIncrease 0.08\n\n\n\nfloat TriangleSd(vec2 uv, float radius)\n{\n\treturn max(0.866025*abs(uv.x) + 0.5*uv.y, -uv.y) - 0.5*radius;\n}\n\nfloat Triangle(vec2 uv)\n{\n    uv = Rot(-0.3*iTime) * uv;\n    return smoothstep(0.782, 1.0, 1.0-TriangleSd(uv, 0.5 + 0.1*cos(iTime)));\n}\n\nfloat SpiralTurn(vec2 uv, float turn)\n{\n    // Polar coordinates:\n    float r = length(uv);\n    float a = Pi+atan(uv.y, uv.x);\n    \n    // Turn angle:\n    a += Tau*turn;\n    \n    // Polar function:\n    float tr = Triangle(uv);\n    float am = 0.35*tr*smoothstep(0.0, 0.1, r);\n    float p = RadiusIncrease*(a/Tau + am*sin(-4.0*iTime+0.54*a*a));\n    \n    return r-p;\n}\n\n\nfloat SpiralTurnDe(vec2 uv, float turn)\n{\n    // IQ's |f|/|Grad(f)| distance estimator:\n    float f = SpiralTurn(uv, turn);\n    vec2 eps = vec2(0.00005, 0);\n    vec2 grad = vec2(\n        SpiralTurn(uv + eps.xy, turn) - SpiralTurn(uv - eps.xy, turn),\n        SpiralTurn(uv + eps.yx, turn) - SpiralTurn(uv - eps.yx, turn)) / (2.0*eps.x);\n    \n    return f/length(grad);\n}\n\n\nfloat Spiral(vec2 uv, float eps)\n{\n    // Modulation source:\n    float tr = Triangle(uv);\n\n    // Split in concentric rings:\n    float r = length(uv);\n    float turn = floor(r/RadiusIncrease);\n    \n    // Draw a spiral contained in a ring + adjacent ones to handle overlap:\n    float thick = 0.0040*tr;\n    float aa = 1.2*eps;\n    float d;\n    d  = smoothstep(thick, thick+aa, abs(SpiralTurnDe(uv, turn)));\n    d *= smoothstep(thick, thick+aa, abs(SpiralTurnDe(uv, turn+1.0)));\n    d *= smoothstep(thick, thick+aa, abs(SpiralTurnDe(uv, turn-1.0)));\n    return d;\n}\n\n\n// Randomly dither colors for smoother gradients\nvoid Dither(inout vec4 fragColor, in vec2 fragCoord)\n{\n    // Position + Time Hash (based on Dave Hoskins hash33):\n    vec3 p3 = fract(vec3(fragCoord, iFrame) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    vec3 hash = fract((p3.xxy + p3.yxx)*p3.zyx);\n    \n    // RGB Dithering:\n    float softness = 255.0; // Should be 255. Lower value for grainy/fuzzy effect.\n    fragColor.rgb = (floor(softness*fragColor.rgb) + step(hash, fract(softness*fragColor.rgb)))/softness;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized coordinates:\n    float eps = 2.0/iResolution.y;\n    vec2  uv =  eps*(fragCoord - 0.5*iResolution.xy);\n    uv.x = -uv.x;\n    \n    //uv *= Rot(-0.15*iTime);\n    \n    // Polar:\n    float r = length(uv);\n    //float a = atan(uv.y, uv.x);\n\n    \n    // Back:\n    vec3 back = vec3(0.20, 0.25, 0.3);\n    // - Add vignetting:\n    back *= mix(0.237, 1.0, pow(smoothstep(2.0, 2.0*0.45, r), 4.0*0.1637));\n\n        \n    // Disk:\n    vec3 disk = vec3(0.904, 0.902, 0.827);\n    \n    // - Add Grid:\n    float grid = mod(floor(r/RadiusIncrease), 2.0);\n    disk = mix(disk, vec3(0.836,0.848,0.840), grid);\n    \n    // - Add inner shadow:\n    disk *= mix(0.023, 1.0, pow(smoothstep(0.9, 0.75, r), 0.4));\n    \n    // - Add spiral:\n    disk = mix(0.2*disk, disk, pow(Spiral(uv, eps), 0.45));\n\n    \n    // Combine Back and Disk:\n    float mask = smoothstep(0.9+eps, 0.9, r);\n    vec3 col = mix(back, disk, mask);\n\n    \n    // Output:\n    fragColor = vec4(col,1.0);\n    \n    \n    // Dither post-process:\n    Dither(fragColor, fragCoord);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtdBWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 142, 183, 183, 249], [251, 251, 276, 276, 386], [388, 388, 427, 453, 753], [756, 756, 797, 843, 1125], [1128, 1128, 1162, 1188, 1692], [1695, 1744, 1798, 1858, 2232], [2235, 2235, 2292, 2323, 3327]], "test": "valid"}
{"id": "MtdBz2", "name": "Triangle Trip", "author": "cold_code", "description": "A 2d shader. had some fun with procedurally generated triangles.", "tags": ["procedural", "triangle", "varonoi"], "likes": 14, "viewed": 594, "published": "Public API", "date": "1540358917", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2018 Patryk Ozga\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions: The above copyright\n// notice and this permission notice shall be included in all copies or\n// substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\",\n// WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n// TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\n// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR\n// THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 randPt(vec2 co) {\n  float f1 = rand(co);\n  float f2 = rand(co * f1);\n  return vec2(f1 * .8 + .1, f2 * .8 + .1);\n}\n\nvec2 sqPoint(vec2 sq) {\n  float time = 2. * iTime + 1.;\n  //time = 2.;\n  vec2 curPt = randPt(floor(sq) * floor(time));\n  vec2 nextPt = randPt(floor(sq) * floor(time + 1.));\n  return fract(time) * (nextPt - curPt) + curPt;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h);\n}\n\nfloat distToShade(float d) {\n  float time = (1. + .3 * cos(3. * iTime));\n  //time = 1.;\n  return smoothstep(0.01, 1., 1. / (100. * time * d));\n}\n\nfloat cross2d(vec2 u, vec2 v) { return u.x * v.y - u.y * v.x; }\n\nfloat triArea(vec2 a, vec2 b, vec2 c) { return cross2d(b - a, c - a) / 2.; }\n\nconst vec3[4] palette = vec3[4](vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5),\n                                vec3(2.0, 1.0, 0.0), vec3(0.5, 0.20, 0.25));\n\nconst float _2PI = 6.28318;\n\nvec3 pal(in float t, in vec3[4] pal) {\n  return pal[0] + pal[1] * cos(_2PI * (pal[2] * t + pal[3]));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n\n  float scale = 1.25 *(pow(sin( iTime/8.) + 4., 1.5));\n  //scale = 2.;\n  vec2 sq = uv * scale + 1.;\n  vec2 uvSq = fract(sq);\n  vec2 sqPt = sqPoint(sq);\n  float c = 0.;\n  vec3 col = vec3(0.);\n  vec2[] offsets = vec2[](vec2(-1, -1), vec2(-1, 0), vec2(0, 1), vec2(1, 1),\n                          vec2(1, 0), vec2(0, -1)\n                          // vec2(-1, 1),\n                          // vec2(0, 0),\n                          // vec2(1, -1),\n  );\n\n  vec2 sqPtLast = sqPoint(sq + offsets[5]) + offsets[5];\n  for (int i = 0; i < 6; ++i) {\n    vec2 off = offsets[i];\n    vec2 sq2 = sq + off;\n    vec2 sqPt2 = sqPoint(sq2) + off;\n\n    //vec2 triCenter = (sqPt2 + sqPtLast + sqPt) / 3.;\n\n    float a = triArea(sqPt, sqPt2, sqPtLast);\n    // col.g += smoothstep(.1, 0., length(triCenter - uvSq));\n    float r1 = cross2d(uvSq - sqPt, sqPtLast - sqPt);\n    float r2 = cross2d(sqPt2 - sqPt, uvSq - sqPt);\n    \n      r1 = smoothstep(0., .001, r1);\n    r2 = smoothstep(0., .001, r2);\n    col += r1 * r2 * pal(a, palette);\n\n    float d = sdLine(uvSq, sqPt, sqPt2);\n    c += distToShade(d);\n\n    sqPtLast = sqPt2;\n  }\n\n  vec2[] diagOffsets = vec2[](vec2(-1, 0), vec2(0, 1),\n                              // vec2(-1, 0), vec2(0, -1),\n                              // vec2(1, 0), vec2(0, 1),\n                              vec2(1, 0), vec2(0, -1));\n  for (int i = 0; i < 4; i += 2) {\n    vec2 off1 = diagOffsets[ i];\n    vec2 sq1 = sq + off1;\n    vec2 sqPt1 = sqPoint(sq1) + off1;\n    vec2 vPt1 = sqPt1 - uvSq;\n\n    vec2 off2 = diagOffsets[ i + 1];\n    vec2 sq2 = sq + off2;\n    vec2 sqPt2 = sqPoint(sq2) + off2;\n\n    vec2 off3 = vec2(off1.x, off2.y);\n    vec2 sq3 = sq + off3;\n    vec2 sqPt3 = sqPoint(sq3) + off3;\n\n    float a = triArea(sqPt1,sqPt2, sqPt3);\n    \n    float r1 = cross2d(uvSq - sqPt2, sqPt1 - sqPt2);\n    float r2 = smoothstep(.01, 0., r1);\n    r1 = smoothstep(0., .001, r1);\n    col *= r2;\n    col += r1*pal(a, palette);\n\n    float d = sdLine(uvSq, sqPt1, sqPt2);\n    c += distToShade(d);\n  }\n\n  col -= vec3(c);\n  fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtdBz2.jpg", "access": "shaders20k", "license": "mit", "functions": [[1116, 1116, 1137, 1137, 1208], [1210, 1210, 1232, 1232, 1328], [1330, 1330, 1353, 1353, 1553], [1555, 1555, 1602, 1602, 1721], [1723, 1723, 1751, 1751, 1867], [1869, 1869, 1900, 1900, 1932], [1934, 1934, 1973, 1973, 2010]], "test": "error"}
{"id": "MtdBzN", "name": "fingerbob3d", "author": "Del", "description": "fingerbob", "tags": ["fingerbob"], "likes": 5, "viewed": 516, "published": "Public API", "date": "1538931223", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// fingerbob3d\n\n\n//------------------------------------------------------------------------\n// Camera\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    vec2 mouse2 = vec2(0.0);\n    if (iMouse.z > 0.5)\n    {\n        mouse2 = mouse;\n        mouse2.y -= 0.1;\n    }\n    \n//    float an = 0.3*iTime + 10.0*mouse.x;\n    float an = 10.0*mouse2.x;\n    mouse2.y *= 4.0;\n\tcamPos = vec3(5.5*sin(an),0.0+mouse2.y*2.0,5.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n    \n//------------------------------------------------------------------------\n// Modelling \n//------------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdEllipsoid(const in  vec3 p, const in vec3 r) {\n  return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat fakeEllipsoid( vec3 p, vec3 s ) {\n\tvec3 lp = p / s;\n\tvec3 ep = normalize(lp) * s;\n\treturn length(p - ep) * sign(length(lp) - 1.0);\n}\n\nfloat cylinder( vec3 p, vec2 rh )\n{\n\tvec2 cp = vec2( length(p.xz), p.y );\n\treturn length( max(abs(cp) - rh, 0.0) );\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 opUnionRound(const in vec2 a, const in vec2 b, const in float r)\n{\n    vec2 res = vec2(smin(a.x,b.x,r),(a.x<b.x) ? a.y : b.y);\n    return res;\n}\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\n\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n\n// http://mercury.sexy/hg_sdf/\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\n#define PI 3.1415926\n#define DEG2RAD ((PI * 2.0) / 360.0)\n\n\n// model\n\n    // Return 2x2 rotation matrix\n    // With vector swizzle/mask can use as a 3x3 xform\n    // For y, you need to invert \n    // angle in radians\n    // ========================================\n    mat2 Rot2(float a ) {\n        float c = cos( a );\n        float s = sin( a );\n        return mat2( c, -s, s, c );\n    }\n\n\n    // ========================================\n    float sdCappedCylinder( vec3 p, vec2 h )\n    {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n\n    vec3 opCheapBend( vec3 p, float angle )\n    {\n        mat2  m = Rot2( angle * p.y );\n        vec3  q = vec3( m*p.yx, p.z );\n        return q;\n    }\n\n\nvec3 CalcBend(vec3 bodyp)\n{\n    float ang = sin(iTime) * 8.;\n    ang += sin(iTime*0.37) * 4.;\n    \n    bodyp.y += 2.0;\n\tbodyp = opCheapBend(bodyp,(ang)*DEG2RAD);\n    //bodyp.z -= 1.0;\n    bodyp = rotateZ(bodyp,90.0*DEG2RAD);\n    bodyp.y -= 2.0;\n    return bodyp;\n    \n}\n\nfloat smin( float a, float b )\n{\n    float k = 3.0;\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n\n\nvec2 doModel( vec3 p )\n{\n    //float c = pMod1(p.z,7.5);\n    //p.x += 2.75*c;\t\t\t\t// fucked because of mirroring\n    //pMod1(p.x,5.5);\n\n    vec2 res = vec2(0.0,0.0);\t\t\t// distance,material index\n    //p.z += 0.8;\n    \n    vec3 bodyp = p;\n    bodyp = CalcBend(bodyp);\n    \n\n    float d3 = sdEllipsoid(bodyp-vec3(0.0,1.4,0.0),vec3(0.95));\n    \n    float d1 = sdCappedCylinder(bodyp,vec2(0.8,1.8));\n    \n    d1 = smin(d3,d1);\n    \n    \n    float d2 = sdPlane(p-vec3(0.0,-1.8,0.0));\t\t// checkered floor distance...\n\n    res = vec2(d1,2.0);\n    res = opUnionRound(res,vec2(d2,1.0),0.1);\n\n    return res;\n}\n\n\nmat2 rotate(float a)\n{\n    float sa = sin(a), ca = cos(a);\n\treturn mat2(ca, -sa, sa, ca);\n}\n\nfloat circle(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\n\n//======================\n// Line functions\n//======================\n\nfloat distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// bend(Y)\nvec2 opBendTest( vec2 p, float angle )\n{\n    mat2 m = rotate( angle * p.x );\n    return   m*p.xy;\n}\n\n// NAND, our only primitive\nfloat csg_nand (float a, float b) {\n    return -max(a,b);\n}\n\n// aka A AND NOT B, NOT(NAND(A,NOT(B)))\nfloat csg_sub (float a, float b) {\n    float o = csg_nand(a, csg_nand(b, b));\n    return csg_nand(o, o);\n}\n// NAND(NOT(A),NOT(B))\nfloat csg_or (float a, float b) {\n    return csg_nand(\n        csg_nand(a,a),\n        csg_nand(b,b));\n}\n\nfloat Eye(vec2 p,vec2 offset)\n{\n    float rad = 0.06;\n    float rad2 = 0.057;\n    float d = circle(p,rad);\n    float d2 = circle(p,rad2);\n    float d3 = circle(p+offset,0.015);\t// pupil\n    // blink\n    float blink = step(sin(iTime * 2.8 + cos(iTime * 2.0) * 2.0), 0.95);\n\td3 = max(d3,1.0-blink);\n    d = csg_sub(d,d2);\n    d = csg_or(d,d3);\n    return d;\n    \n}\n\n\nvec4 FaceTest(vec2 p)\n{\n    p.y += 0.1;\n\n    vec4 color = vec4(0.0,0.0,0.0,1.0);\n    vec2 p1 = vec2(-0.15,-0.03);\n    vec2 p2 = vec2(0.15,-0.03);\n    float dist = 100.0;\n\n    vec2 offset1 = vec2(0.015,0.02);\n    vec2 offset2 = vec2(-0.015,0.02);\n    float d2 = Eye(p+vec2(-0.08,-0.2),offset1);\n    float d3 = Eye(p+vec2(0.08,-0.2),offset2);\n\n    p = opBendTest(p,DEG2RAD*140.0);\t////sin(iTime));\n    float d1 = distanceToSegment(p1,p2,p);\n\n    dist = min(dist,d2);\n    dist = min(dist,d3);\n    dist = smoothstep(0.0,0.01, dist);\t\t// alias,thickness\n    \n    float b = 0.0;\n    \n    b += 1.0-dist;\n\n    // mouth\n    dist = smoothstep(0.004,0.015, d1);\t\t// alias,thickness\n    b += 1.0-dist;\n    b = 1.0-b;\n    \n\tcolor = vec4(b*0.7,b*0.1,b*0.2,0.5);\n    \n    return color;\n    \n}\n\n\n// Mellow purple II flow background - Del 17/06/2018\n//const float PI = 3.14159;\n\nvec2 _rotate(vec2 p, float a)\n{\n    float sa = sin(a), ca = cos(a);\n\treturn p * mat2(ca, -sa, sa, ca);\n}\n\nfloat pModPolar(inout vec2 p, float repetitions)\n{\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\nvec4 MellowGreen(vec2 pos)\n{\n\tpos = _rotate(pos,iTime*0.09);\n\n  \tpModPolar(pos,11.0);    \n\n    pos = abs(pos*0.2);\t\t\t// Mirror, Zoom etc\n    \n    //pos.y *= sin(pos.x);\n    vec4 col = vec4(0.32,0.59,0.35,1.0);\n    float tt = iTime*0.8;\n    float iter = (pos.x*pos.y);\n    iter *= 0.5+sin(pos.x*0.5+tt*0.15)+0.5;\n    float r = sin(pos.y);\n    r += .26;\n    float d1 = sin(tt+pos.x+pos.y);\n    float val = sin(tt+iter*PI );\n    float brightness = 0.25 / abs( d1 * val - r);\n    brightness = brightness/(brightness + 8.);\n    col += brightness;\n    return col*0.2;\n}\n\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal.\n//------------------------------------------------------------------------\n// c = colour index (added by del for some materials)\n// c.a == specular val fudged in...\nvec4 doMaterial( in vec3 pos, in vec3 nor,float c )\n{\n    if (c<=1.0)\n    {\n        // checker floor\n        //float f = mod( floor(0.25*pos.z) + floor(0.25*pos.x), 2.0);\n        //f+=0.5;\n        //vec4 col = f*vec4(0.3,0.3,0.1,0.0);\n\n        vec4 col = MellowGreen(pos.xz);\n        col.w = 0.2;\n        \n\t    return col;\n    }\n    else if (c<=2.0)\n    {\n        vec3 bodyp = pos;\n        bodyp = CalcBend(bodyp);\n        vec3 q = normalize( bodyp );\n        //vec2 uv = vec2( atan(q.z,q.x), acos(-q.y ) );\n \t\tvec2 uv = vec2(atan(q.x,q.z), q.y) / PI ;\n        return FaceTest(uv);\n    }\n    //else if (c<=3.0)\n    //{\n\t//\treturn vec4(0.3, 0.0, 0.0,3.0);\t// feet/gloves\n    //}\n\n\treturn vec4(0.0, 0.0, 0.0,2.0);\t// eyes\n    \n//    return vec3(0.2,0.07,0.01);\n    \n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec4 mat )\n{\n    \n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(0.7,0.875,0.89));\t\t// dir\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0;\n    if( dif>0.01 )\n        sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n\tfloat spec = pow(dif, 160.0) *mat.a;\n    \n    \n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mat.xyz*lin;\n    col+=spec;\n\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.001*dis*dis);\n\n    return col;\n}\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 50.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\t//float res = -1.0;\n    vec2 res = vec2(-1.0,0.0);\n    float c = 0.0;\n    \n    for( int i=0; i<120; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n        vec2 res2 = doModel( ro+rd*t );\n\t    h = res2.x;\n        c = res2.y;\n        \n        t += h*0.75;\t\t// hack * for extreme bend\n    }\n\n    if( t<maxd )\n    {\n        res.x = t;\n        res.y = c;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t).x;\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    \n    vec2 uv3 = (fragCoord/iResolution.xy)-vec2(0.5,0.5);\n\tfloat distSqr = dot(uv3, uv3)+0.5;\n\tfloat vignette = 1.4 - distSqr;\n    \n    \n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n  \tvec3 col = mix( vec3(0.0,0.24, 0.0), vec3(0.1, 0.05, 0.3), fragCoord.y / iResolution.y );\n\n\t// raymarch\n    vec2 res = calcIntersection( ro, rd ); \n    float t = res.x;\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec4 mat = doMaterial( pos, nor, res.y );\n\n        col = doLighting( pos, nor, rd, t, mat );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n    col *= vignette;\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtdBzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 177, 258, 258, 563], [736, 736, 761, 761, 776], [893, 893, 924, 924, 1015], [1018, 1018, 1057, 1057, 1156], [1158, 1158, 1193, 1193, 1275], [1277, 1277, 1318, 1318, 1411], [1563, 1563, 1596, 1596, 1622], [1625, 1625, 1656, 1656, 1762], [1763, 1763, 1794, 1794, 1901], [1902, 1902, 1933, 1933, 2039], [2041, 2216, 2256, 2256, 2377], [2454, 2649, 2670, 2670, 2768], [2775, 2823, 2869, 2869, 2984], [2990, 2990, 3035, 3035, 3137], [3140, 3140, 3167, 3167, 3409], [3411, 3411, 3443, 3443, 3533], [3537, 3537, 3561, 3670, 4136], [4139, 4139, 4161, 4161, 4230], [4232, 4232, 4268, 4268, 4298], [4370, 4370, 4421, 4421, 4535], [4537, 4548, 4588, 4588, 4647], [4649, 4677, 4712, 4712, 4736], [4738, 4778, 4812, 4812, 4884], [4885, 4908, 4941, 4941, 5011], [5013, 5013, 5044, 5044, 5375], [5378, 5378, 5401, 5401, 6155], [6240, 6240, 6271, 6271, 6344], [6346, 6346, 6396, 6396, 6634], [6636, 6636, 6664, 6664, 7199], [7202, 7585, 7638, 7638, 8350], [8563, 8563, 8647, 8647, 9319], [9321, 9321, 9370, 9370, 9976], [9978, 9978, 10010, 10010, 10430], [10432, 10432, 10480, 10480, 10908], [10910, 10910, 10974, 10974, 11152], [11154, 11154, 11211, 11211, 12669]], "test": "error"}
{"id": "MtdfD7", "name": "Cannon-Thurston V2 (wrong!)", "author": "DaveBachman", "description": "In this test we count how many fund domain hops we need to do to get close to the origin\nin the Poincare ball, and color the sphere accordingly.", "tags": ["hyperbolic"], "likes": 4, "viewed": 100, "published": "Public", "date": "1539928002", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Joint work with Dave Bachman. \n// In this test we count how many fund domain hops we need to do to get close to the origin\n//in the Poincare ball, and color the sphere accordingly\n\nvec4 c2q(in vec2 a){\n    return vec4(a.x, a.y, 0.0, 0.0);\n}\n\nvec4 qonj(in vec4 q){\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 qinv(in vec4 q){\n \treturn qonj(q) / (q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w);\n}\n\nvec4 qmul(in vec4 p, in vec4 q){\n    return vec4(p.x*q.x - p.y*q.y - p.z*q.z - p.w*q.w,\n                p.x*q.y + p.y*q.x + p.z*q.w - p.w*q.z,\n                p.x*q.z - p.y*q.w + p.z*q.x + p.w*q.y,\n                p.x*q.w + p.y*q.z - p.z*q.y + p.w*q.x);\n}\n\nvec4 qdiv(in vec4 p, in vec4 q){\n    return qmul(p, qinv(q));\n}\n\nvec4 qmob(in vec2[4] M, in vec4 z){ // see Ahlfors 1981 Mob tsfms p14\n    vec4 a = c2q(M[0]);\n    vec4 b = c2q(M[1]);\n    vec4 c = c2q(M[2]);\n    vec4 d = c2q(M[3]);\n    return qdiv( qmul(a,z)+b, qmul(c,z)+d ); // if z.w = 0 then result.w = 0\n}\n\n    \nconst float sqrt3 = sqrt(3.0);\nconst vec2 w = vec2(0.5, 0.5*sqrt3);\nconst vec2 winv = vec2(0.5, -0.5*sqrt3);\nconst vec2 c0 = vec2(0.0,0.0);\nconst vec2 c1 = vec2(1.0,0.0);\nconst vec2 ci = vec2(0.0,1.0);\nconst vec4 qj = vec4(0.0,0.0,1.0,0.0);\n\nfloat origin_distance(in vec4 q){\n    //vec4 x  = qdiv(q-qj,c2q(c1)-qmul(q,qj));\n    vec4 x = qmul(qinv(qmul(q,qj)-c2q(c1)),qj-q);\n    return length(x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 t1[4];\n\tt1[0] = c1;\n\tt1[1] = -w;\n\tt1[2] = c1;\n\tt1[3] = winv;  // is this really the only way to assign values to the array??\n    vec2 t1inv[4];\n    t1inv[0] = winv;\n    t1inv[1] = w;\n    t1inv[2] = -c1;\n    t1inv[3] = c1;\n    vec2 t2[4];\n    t2[0] = c1;\n    t2[1] = w;\n    t2[2] = c0;\n    t2[3] = c1;\n    vec2 t2inv[4];\n    t2inv[0] = c1;\n    t2inv[1] = -w;\n    t2inv[2] = -c0;\n    t2inv[3] = c1;\n    vec2 t3[4];\n    t3[0] = -winv;\n    t3[1] = -w;\n    t3[2] = w;\n    t3[3] = -w - c1;\n    vec2 t3inv[4];\n    t3inv[0] = -w - c1;\n    t3inv[1] = w;\n    t3inv[2] = -w;\n    t3inv[3] = -winv; //all these should have det 1 now\n    \n    vec2 p = vec2(0.1,0.001) + 1.0*(-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    //vec4 q = vec4(p, 0.001+0.1*(0.75 + cos(iTime) + 0.25*cos(2.0*iTime)), 0.0);\n\t//vec4 q = vec4(0.0,1.0, 0.0001, 0.0);\n    \n    float ball_radius = 0.9999;\n    \n    vec4 q;\n    vec3 col;\n    \n    if(length(p)<1.0){\n\t\tvec4 ball_pt = vec4(sqrt(1.0-length(p)*length(p)),p,0.0);\n        ball_pt = vec4(ball_pt.x * cos(iTime) + ball_pt.y * sin(iTime), -ball_pt.x * sin(iTime) + ball_pt.y * cos(iTime), ball_pt.z, ball_pt.w);\n        //ball_pt = (0.999-0.15*cos(iTime))*ball_pt;\n        ball_pt = 0.999*ball_pt;\n      \tq = qdiv(ball_pt + qj,qmul(qj,ball_pt)+c2q(c1));\n        int crossing_count = 0;\n\t    for(int i=0;i<512;i++){\n    \t    vec4 q1=qmob(t1,q);\n        \tfloat d1=origin_distance(q1);\n\n\t        vec4 q2=qmob(t2,q);\n\t        float d2=origin_distance(q2);\n\n\t        vec4 q3=qmob(t3,q);\n    \t    float d3=origin_distance(q3);\n\n        \tvec4 q1inv=qmob(t1inv,q);\n        \tfloat d1inv=origin_distance(q1inv);\n\n\t        vec4 q2inv=qmob(t2inv,q);\n    \t    float d2inv=origin_distance(q2inv);\n\n\t        vec4 q3inv=qmob(t3inv,q);\n    \t   \tfloat d3inv = origin_distance(q3inv);\n\n\t        float dbest=d1;\n    \t    vec4 qbest=q1;\n        \tint crossing_change = 0;\n        \n\t        if (d2 < dbest){\n    \t    \tdbest = d2;\n        \t    qbest=q2;\n            \tcrossing_change=-1;\n\t        }\n\n    \t    if (d3 < dbest){\n        \t\tdbest = d3;\n            \tqbest=q3;\n      \t      crossing_change=-1;\n        \t}\n        \n\t        if (d1inv < dbest){\n    \t    \tdbest = d1inv;\n        \t    qbest=q1inv;\n            \tcrossing_change=0;\n\t        }\n        \n    \t    if (d2inv < dbest){\n        \t\tdbest = d2inv;\n            \tqbest=q2inv;\n           \t \tcrossing_change=1;\n\t        }\n\n\t        if (d3inv < dbest){\n    \t    \tdbest = d3inv;\n        \t    qbest=q3inv;\n            \tcrossing_change=1;\n\t        }\n        \n     \t   if (dbest < origin_distance(q)){\n        \t    q=qbest;\n            \tcrossing_count=crossing_count+crossing_change;\n\t        }\n    \t    else break;\n\t}                \n    float c = 0.5+float(crossing_count)/10.0;\n    col = vec3(c,c,c);\n    }\n    \t\n    else{\n        col = vec3(0.0,0.0,0.0);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtdfD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 204, 204, 243], [245, 245, 266, 266, 308], [310, 310, 331, 331, 393], [395, 395, 427, 427, 650], [652, 652, 684, 684, 715], [1210, 1210, 1243, 1290, 1364], [1367, 1367, 1424, 1424, 4285]], "test": "error"}
{"id": "MtdfRB", "name": "Extracredit-ZenOhDBZ", "author": "tqle", "description": "extracredit", "tags": ["extracredit"], "likes": 0, "viewed": 59, "published": "Public", "date": "1540215655", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define repeat (v, r) (mod(v, r) - r/2.)\n\nstruct Shape {\n    float dist;\n    vec4 color;\n};\n//Randomizing vectors, parametizes a vec2 to return a float\nfloat random(vec2 v) {\n    return fract(sin(dot(v*1., vec2(324.654, 156.546)))*46556.2);\n}\n//Rotating shape using matrix transformation\nmat2 rot(float a) {\n    float r = cos(a);\n    float f = sin(a);\n    return mat2(r, f, -f, r);\n}\n//Produces a cylinder, \nfloat fCylinder(vec3 p, float r, float h) {\n    float d = length(p.xz) - r;\n    d = max(d, abs(p.y) - h);\n    return d;\n}\n//Produces a sphere\nfloat sphere(vec3 v, float r) {\n    return length(v) - r;\n}\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n//Produces a box\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n//Mixing colors, where the 3rd parameter is the mixing ratio \nfloat mixColors(float r, float v, float z) {\n    return clamp(.5 + .5*(v - r)/z, 0., 1.);\n}\n//Mixing shapes, or blending the pixels projected onto the screen\nfloat mixShapes(float v, float f, float r) {\n    float z = mixColors(v, f, r);\n    return mix(f, v, z) - r*z*(1. - z);\n}\n//Produces a cone(circular base)\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\nfloat sdEllipsoid(in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0 - 1.0)/k1;\n}\n\n//float opTwist(vec3 p) {\n//    float c = cos(20.0*p.y);\n//    float s = sin(20.0*p.y);\n//    mat2  m = mat2(c,-s,s,c);\n//    vec3  q = vec3(m*p.xz,p.y);\n//    return primitive(q);\n//}\n//Changing coordinate system to polar coordinates, making it easy to stretch shapes\nfloat pModPolar(inout vec2 v, float r) {\n    float f = 6.28318/r;\n    float z = atan(v.y, v.x) + f*.5;\n    float m = floor(z/f);\n    z = mod(z, f) - f*.5;\n    v = vec2(cos(z), sin(z))*length(v);\n    return m;\n}\nvoid pR45(inout vec2 p) {\n    p = (p + vec2(p.y, -p.x))*sqrt(.5);\n}\n//Modifying the coordinate system\nfloat pMod1(inout float p, float size) {\n    float halfSize = size*.5;\n    float c = floor((p + halfSize)/size);\n    p = mod(p + halfSize, size) - halfSize;\n    return c;\n}\n//Similar to smooth step function, removing edges of shapes\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n//Rotating shapes on Y axis\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n//Blending shapes, merging them together while creating rippples\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n    if((a < r) && (b < r)) {\n        vec2 p = vec2(a, b);\n        float columnradius = r*sqrt(2.)/((n - 1.)*2. + sqrt(2.));\n        pR45(p);\n        p.x -= sqrt(2.)/2.*r;\n        p.x += columnradius*sqrt(2.);\n        if(mod(n, 2.) == 1.) {\n            p.y += columnradius;\n        }\n        pMod1(p.y, columnradius*2.);\n        float result = length(p) - columnradius;\n        result = min(result, p.x);\n        result = min(result, a);\n        return min(result, b);\n    } else {\n        return min(a, b);\n    }\n}\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\nfloat sdCappedCylinder(vec3 p, vec2 h) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n    a = -a;\n    float m = min(a, b);\n    if((a < r) && (b < r)) {\n        vec2 p = vec2(a, b);\n        float columnradius = r*sqrt(2.)/n/2.;\n        columnradius = r*sqrt(2.)/((n - 1.)*2. + sqrt(2.));\n        pR45(p);\n        p.y += columnradius;\n        p.x -= sqrt(2.)/2.*r;\n        p.x += -columnradius*sqrt(2.)/2.;\n       \t\n        if(mod(n, 2.) == 1.) {\n            p.y += columnradius;\n        }\n        pMod1(p.y, columnradius*2.);\n        float result = -length(p) + columnradius;\n        result = max(result, p.x);\n        result = min(result, a);\n        return -min(result, b);\n    } else {\n        return -m;\n    }\n}\n//Projecting shapes\nShape character(vec3 c) {\n    Shape shape;\n    shape.dist = 1000.;\n    shape.color = vec4(1.);\n    //instiating vars\n   \tvec3 h = c; //head \n    vec3 be = c; //beak\n    vec3 e = c; //eyes \n    vec3 p = c; //pupil\n    vec3 br = c; //brows\n    vec3 b = c; //body \n    vec3 f = c; //feathers/halo\n    vec3 arone = c; //arms\n    vec3 artwo = c;\n    vec3 pro = c; //propeller \n    vec3 m = c;\n    \n    vec4 hColor = vec4(1., 1., 1., 1.);\n    h.x *= cos(sin(h.x*3.))*.6;\n    float head = sphere(h - vec3(0., 1., 0.), 1.);\n    m.xy *= cos(sin(m.x*3.));\n    float mouth = fBox(m - vec3(0., .6, -1.5), vec3(.1, .1, .1));\n    be.xy *= rot(radians(270.));\n    vec4 beColor = vec4(.9, 0., 0., .5);\n    float beak = fCone(be - vec3(-.85, .8, -.4), .25, .5);\n    p.x = abs(p.x) - .45;\n    float pupil = sphere(p - vec3(0., .95, -1.25), .1);\n    e.x = abs(e.x) - .085;\n    float eyes = sphere(e - vec3(.4, 1., -1.), .15);\n   \t//float eyes = sphere(e - vec3(.4, 1., -1.), .2);\n    //float pupil = sphere(p - vec3(.5, 1., -1.25), .07);\n    br.xy *= rot(radians(350.));\n    //br.x +=  sin(br.x*5. - iTime*1.5)*(2. - br.y)*.3;\n    vec4 brColor = vec4(0., 0., 0., 1.);\n    float brow = fBox(br - vec3(.3, 1.3, -1.), vec3(.25, .07, .25));\n    arone.xy *= rot(radians(80.));\n    vec4 aroneColor = vec4(0., 0., 0., 1.);\n\tfloat armone = sdEllipsoid(arone - vec3(-.5, .75, -1.), vec3(.5, .25, .5));\n    artwo.xy *= rot(radians(100.));\n    vec4 artwoColor = vec4(0., 0., 0., 1.);\n    float armtwo = sdEllipsoid(artwo - vec3(-.5, -.75, -1.), vec3(.5, .25, .5));\n    vec4 bColor = vec4(1., 1., .9, 1.);\n    float body = sphere(b - vec3(0., -.5, 0.), 1.25);\n\tpro.x += sin(pro.x*15. - iTime*2.)*(2. - pro.y)*.03;\n    pro.xy *= rot(radians(180.));\n    vec4 proColor = vec4(1., 0., 0., .9);\n    float propeller = fCone(pro - vec3(0., 1.6, 0.), .5, 1.);\n    //Create effects of an Emperor penguin, crown on top of head\n    //f.x = abs(f.x)-.1; \n  \t//f.x = abs(f.x)-0.1; \n  \t//f.x += sin(f.y*15. - iTime * 2.)*(2. - f.y)*.03; \n  \t//float feathers = fCone(f + vec3(0., -1.25, 2.5), .14, .3); \n    f.xy *= rot(radians(5.*sin(iTime)));\n    vec4 haColor = vec4(1., 1., 0., 1.);\n    float halo = sdTorus(f - vec3(0., 2.25, 0.), vec2(.7, .1));\n    shape.dist = head;\n    //shape.dist = fOpUnionRound(shape.dist, beak, .15);\n    shape.dist = min(shape.dist, eyes);\n    shape.dist = min(shape.dist, pupil);\n    //shape.dist = min(shape.dist, brow);\n    shape.dist = fOpUnionRound(shape.dist, body, .1);\n    //shape.dist = fOpUnionRound(shape.dist, feathers, .1);\n    shape.dist = min(shape.dist, halo);\n    shape.dist = min(shape.dist, armone);\n    shape.dist = min(shape.dist, armtwo);\n    shape.dist = min(shape.dist, propeller);\n    shape.dist = min(shape.dist, mouth);\n   \n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n    shape.color = mix(bColor, hColor, mixColors(head, body, 0.));\n    //shape.color = mix(shape.color, brColor, mixColors(brow, shape.dist, .1));\n    shape.color = mix(shape.color, haColor, mixColors(halo, shape.dist, .1));\n    //shape.color = mix(shape.color, beColor, mixColors(beak, shape.dist, .1));\n    shape.color = mix(shape.color, aroneColor*10., mixColors(armone, shape.dist, .25));\n    shape.color = mix(shape.color, artwoColor*10., mixColors(armtwo, shape.dist, .25));\n    shape.color = mix(shape.color, proColor*10., mixColors(propeller, shape.dist, .1));\n    return shape;\n}\n\nShape map(vec3 c){\n  Shape shape = character(c);\n  return shape;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  //modifying the coordinate system \n  vec2 v = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\n  //setting camera position \n  vec3 cam = vec3(0., 0., -8.5);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  scene.yx *= rot(iTime);\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1; z <= 1.;z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.00001){\n      fragColor = c.color*(1. - z); // Hit  - invert pixels\n      break;\n    }\n    scene += f*c.dist;\n\n\n  }\n}\n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtdfRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 152, 174, 174, 242], [243, 288, 307, 307, 383], [384, 408, 451, 451, 529], [530, 550, 581, 581, 609], [610, 610, 630, 630, 668], [669, 686, 714, 714, 801], [802, 864, 908, 908, 955], [956, 1022, 1066, 1066, 1142], [1143, 1176, 1225, 1225, 1723], [1724, 1724, 1766, 1766, 1857], [1859, 2128, 2168, 2168, 2338], [2339, 2339, 2364, 2364, 2406], [2407, 2441, 2481, 2481, 2613], [2614, 2674, 2722, 2722, 2807], [2808, 2808, 2863, 2863, 2949], [2950, 2950, 3004, 3004, 3046], [3047, 3075, 3106, 3106, 3211], [3212, 3277, 3336, 3336, 3851], [3852, 3852, 3883, 3883, 3953], [3954, 3954, 3994, 3994, 4093], [4095, 4095, 4159, 4159, 4788], [4789, 4809, 4834, 4834, 8192], [8194, 8194, 8212, 8212, 8260], [8262, 8262, 8317, 8354, 8817]], "test": "error"}
{"id": "MttBRf", "name": "Dungeon!", "author": "jkashimura", "description": "Environment #2", "tags": ["beginner"], "likes": 7, "viewed": 85, "published": "Public", "date": "1540570719", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Shape{\n  float dist;\n  vec4 color;\n};\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float h) {\n    float d = length(p.xz) - r;\n    d = max(d, abs(p.y) - h);\n    return d;\n}\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\nfloat sphere(vec3 v, float r) {\n    return length(v) - r;\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2.* s)) - s)));\n}\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\n//=======================\n\nShape environment(vec3 c){\n  Shape shape;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n    \n  // Coordinate Systems\n  vec3 g = c; // Ground\n  vec3 l = c; // light\n  vec3 ga = c; //Gates\n  vec3 s = c; // Side\n  vec3 t = c; //torch\n  vec3 d = c; //door\n    \n  // Ground\n  vec4 gColor = vec4(1., 0.5, 0.5, 1.0);//purple\n  g.xy *= rot(radians(90.)); //rotate\n  g.y = abs(g.y) - 4.; //mirror\n  g.x = abs(g.x) - 4.5;//mirror\n\n  float ground = fBox(g+vec3(2.,0.,2.), vec3(0.25, 3.25, 2000000.75));\n  \n    \n  // light\n  vec4 lColor = vec4(0.,0.,0.,1.);//black\n  l.xy *= rot(radians(90.)); //rotate\n  l.zy *= rot(radians(90.)); //rotate\n  l.z = abs(l.x) - 5. ;//mirror\n  pMod1(l.y, 2.);//distance\n    \n  \n  \n  float light = fCylinder(l+vec3(1.6,0.9,2.1), 1.,1.); \n    \n  // Gates\n  vec4 gaColor = vec4(0.1, 0.1, 0.1, 1.); //grey \n  ga.z = abs(ga.z) + 5.; //mirror\n  ga.x = abs(ga.x) - cos(iTime)*2.8; //mirror\n  pMod1(ga.z, 8.);//distance\n  ga.xy *= rot(radians(90.));//rotate\n  float gates = fBox(ga+vec3(0.,3.,1.5), vec3(2., 1., 0.)); \n  gates = fOpUnionStairs(ground, gates, 1., 4.);\n    \n  float b1 = fBox(c-vec3(1.,0.,0.), vec3(0.5, 0.1, 0.7));\n  \n    \n  // Side \n  vec4 sColor = vec4(0., .0, .5, 1.0); //blue\n  s.x = abs(s.x) - 6.; //mirror\n  pMod1(s.z, 4.5); //distance\n  float side = fBox(s+vec3(3.,1., -5.), vec3(.2, 1.5, 7.)); \n  side = fOpUnionColumns(ground, side,1., 4.); \n    \n  //Torch\n  vec4 tColor = vec4(1.,0.,0.,1.); //red\n  t.y *= cos(sin(t.y*7.)*1.23);//stretch  \n  //t.z = abs(t.z);//mirror\n  t.x = abs(t.x)-2.8;//mirror\n  pMod1(t.z, 3.);//distance\n  float torch = sphere(t-vec3(0.,0.1,0.), .1);\n    \n  //door\n  s.x = abs(s.x) - 5.; //mirror\n  pMod1(d.z, 5.); //distance\n  float door = fBox(s+vec3(2.,1., 0.), vec3(.5, 0.25, 0.3));\n\n      \n  shape.dist = min(ground, gates);\n  shape.dist = min(shape.dist, side); \n  shape.dist = min(shape.dist, torch);\n  shape.dist = fOpDifferenceStairs(shape.dist, door, .3,2.);  \n    \n  shape.color = mix(shape.color, lColor, mixColors(light, shape.dist, 0.1));\n  shape.color = mix(shape.color, gColor, mixColors(ground, shape.dist, 0.1));\n  shape.color = mix(shape.color, gaColor, mixColors(gates, shape.dist, 0.5));\n  shape.color = mix(shape.color, sColor, mixColors(side, shape.dist, 0.3)); \n  shape.color = mix(shape.color, tColor, mixColors(torch, shape.dist, 1.)); \n\n  return shape; \n}\n\n\nShape map(vec3 c){\n  Shape enviro = environment(c);\n  return enviro;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n \n  vec3 cam = vec3(0., 0., iTime*3.);\n  cam.xy *= rot(radians(90.));\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.0001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MttBRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 123, 145, 145, 212], [214, 214, 232, 232, 302], [303, 348, 391, 391, 469], [470, 470, 519, 519, 1018], [1020, 1020, 1051, 1051, 1079], [1080, 1080, 1100, 1100, 1135], [1137, 1173, 1201, 1201, 1282], [1286, 1286, 1329, 1329, 1372], [1374, 1374, 1417, 1417, 1483], [1485, 1485, 1518, 1518, 1544], [1546, 1546, 1585, 1585, 1741], [1743, 1743, 1768, 1768, 1808], [1810, 1810, 1850, 1850, 1971], [1973, 1973, 2032, 2032, 2643], [2645, 2645, 2703, 2703, 2812], [2813, 2813, 2876, 2876, 2916], [2945, 2945, 2971, 2971, 5322], [5325, 5325, 5343, 5343, 5395], [5397, 5397, 5454, 5454, 5901]], "test": "error"}
{"id": "MttBRS", "name": "Float with Caustics", "author": "kaneta", "description": "I added caustics to this post\nhttps://www.shadertoy.com/view/lssXD4\n\ncaustics technique reference\nhttps://medium.com/@evanwallace/rendering-realtime-caustics-in-webgl-2a99a29a0b2c\nhttps://www.shadertoy.com/view/MldfDn", "tags": ["3d", "raymarching", "water", "caustics"], "likes": 50, "viewed": 2416, "published": "Public API", "date": "1540105714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 64\n#define EPSILON .001\n\n#define M_PI 3.14159265358979\n\nconst vec3 LightSource = vec3(3.,20.5, 3.);\n\nvec3 WaterColor = vec3(0.4, 0.9, 1);\n\nconst float WaterHeight = 0.;\nconst float MaxWaveAmplitude = 0.03;\n\nconst float HeightPool = 1.;\nconst float HalfSizePool = 3.;\nconst float DepthPool = 3.0;\n\nstruct MaterialInfo {\n\tvec3 Kd;\n\tfloat Shininess;\n};\n\nfloat CyclicTime()\n{\n\treturn mod(iTime, 30.);\n}\n\nfloat WaveAmplitude() {\n\treturn MaxWaveAmplitude * exp(-CyclicTime() / 10.);\n}\n\nfloat WaterWave(vec3 a) {\n    float wave = 0.0;\n    vec3 org = a;\n    float amp = WaveAmplitude();\n    wave += amp * min(pow(distance(org, vec3(0.0)), -1.), 2.0) * sin((2. * a.x * a.x + 2. * a.z * a.z) - 15. * CyclicTime());\n\treturn wave;\n}\n\nfloat BallOscillation() {\n\treturn sin(5. * CyclicTime() + 4.) * exp(-CyclicTime() / 6.) + 0.3;\n}\n\nfloat PoolBottom(vec3 a) {\n\treturn a.y + DepthPool + .01;\n}\n\nfloat BackWall(vec3 a) {\n\treturn a.z + HalfSizePool + .01;\n}\n\nfloat LeftWall(vec3 a) {\n\treturn a.x + HalfSizePool + .01;\n}\n\nfloat WaterSurface2(vec3 a) {\n\tvec3 sz = vec3(HalfSizePool, 0, HalfSizePool);\n\treturn length(max(abs(a + vec3(0, 0.0, 0)) - sz, 0.));\n}\n\nfloat WaterSurface(vec3 a) {\n\tvec3 sz = vec3(HalfSizePool, 0, HalfSizePool);\n\treturn length(max(abs(a + vec3(0, WaterWave(a), 0)) - sz, 0.));\n}\n\nfloat Pool(vec3 a) {\n\treturn min(PoolBottom(a), min(LeftWall(a), BackWall(a)));\n}\n\nfloat Pool2(vec3 a) {\n\treturn min(PoolBottom(a), min(LeftWall(a), BackWall(a)));\n}\n\nfloat Ball(vec3 a) {\n\treturn length(a + vec3(0., BallOscillation(), 0.)) - 0.75;\n}\n\nfloat Scene(vec3 a) {\n\treturn min(WaterSurface(a), min(Ball(a), Pool(a)));\n}\n\nbool IsWaterSurface(vec3 a)\n{\n\tfloat closest = Ball(a);\n\tfloat dist = Pool(a);\n\tif (dist < closest) {\n\t\tclosest = dist;\n\t}\t\n\tdist = WaterSurface(a);\n\tif (dist < closest) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool IsWater(vec3 pos)\n{\n\treturn (pos.y < (WaterHeight - MaxWaveAmplitude));\n}\n\nbool IsPool(vec3 pos)\n{\n    return Pool(pos) < 0.01;\n}\n\nbool IsBall(vec3 pos)\n{\n    return Ball(pos) < 0.01;\n}\n\nvec3 PoolColor(vec3 pos) {\t\t\n\tif ((pos.y > HeightPool) || (pos.x > HalfSizePool) || (pos.z > HalfSizePool)) \n\t\treturn vec3(0.0);\n\tfloat tileSize = 0.2;\n\tfloat thickness = 0.015;\n\tvec3 thick = mod(pos, tileSize);\n\tif ((thick.x > 0.) && (thick.x < thickness) || (thick.y > 0.) && (thick.y < thickness) || (thick.z > 0.) && (thick.z < thickness))\n\t\treturn vec3(1);\n\treturn vec3(sin(floor((pos.x + 1.) / tileSize)) * cos(floor((pos.y + 1.) / tileSize)) * sin(floor((pos.z + 1.) / tileSize)) + 3.);\n}\n\nMaterialInfo Material(vec3 a) {\n\tMaterialInfo m = MaterialInfo(vec3(.5, .56, 1.), 50.);\n\tfloat closest = Ball(a);\n\n\tfloat dist = WaterSurface(a);\n\tif (dist < closest) {\n\t\tclosest = dist;\n\t\tm.Kd = WaterColor;\n\t\tm.Shininess = 120.;\n\t}\n\tdist = Pool(a);\n\tif (dist < closest) {\n\t\tm.Kd = PoolColor(a);\t\t\n\t\tm.Shininess = 0.;\n\t}\n\treturn m;\n}\n\nvec3 Normal(vec3 a) {\n\tvec2 e = vec2(.001, 0.);\n\tfloat s = Scene(a);\n\treturn normalize(vec3(\n\t\tScene(a+e.xyy) - s,\n\t\tScene(a+e.yxy) - s,\n\t\tScene(a+e.yyx) - s));\n}\n\nfloat Occlusion(vec3 at, vec3 normal) {\n\tfloat b = 0.;\n\tfor (int i = 1; i <= 4; ++i) {\n\t\tfloat L = .06 * float(i);\n\t\tfloat d = Scene(at + normal * L);\t\t\n\t\tb += max(0., L - d);\n\t}\n\treturn min(b, 1.);\n}\n\nvec3 LookAt(vec3 pos, vec3 at, vec3 rDir) {\n\tvec3 f = normalize(at - pos);\n\tvec3 r = cross(f, vec3(0., 1., 0.));\n\tvec3 u = cross(r, f);\n\treturn mat3(r, u, -f) * rDir;\n}\n\nfloat Trace(vec3 rPos, vec3 rDir, float distMin) {\n\tfloat L = distMin;\n\tfor (int i = 0; i < MAX_STEPS; ++i) {\n\t\tfloat d = Scene(rPos + rDir * L);\n\t\tL += d;\n\t\tif (d < EPSILON * L) break;\n\t}\n\treturn L;\n}\n\nvec3 Lighting(vec3 at, vec3 normal, vec3 eye, MaterialInfo m, vec3 lColor, vec3 lPos) {\n\tvec3 lDir = lPos - at;\n\t\n\tvec3 lDirN = normalize(lDir);\n\tfloat t = Trace(at, lDirN, EPSILON*2.);\n\tif (t < length(lDir)) {\n\t\tvec3 pos = at + lDirN * t;\n\t\tif(!IsWaterSurface(pos))\n\t\t\treturn vec3(0.);\n\t}\n\tvec3 color = m.Kd * lColor * max(0., dot(normal, normalize(lDir)));\n\t\n\tif (m.Shininess > 0.) {\n\t\tvec3 h = normalize(normalize(lDir) + normalize(eye - at));\n\t\tcolor += lColor * pow(max(0., dot(normal, h)), m.Shininess) * (m.Shininess + 8.) / 25.;\n\t}\n\treturn color / dot(lDir, lDir);\n}\n\n\nfloat beforeWater(vec3 ro, vec3 ray)\n{\n    float t = 0.0;\n    for (int i = 0; i < 64; i++) {\n        float res = WaterSurface2(ro+ray*t);\n        if( res < 0.0001 ) return t;\n        t += res;\n    }\n\n    return -1.0;\n}\n\nfloat water(vec3 ro, vec3 ray)\n{\n    float t = 0.0;\n    for (int i = 0; i < 128; i++) {\n        float res = WaterSurface(ro+ray*t);\n        if( res < 0.01 ) return t;\n        t += res*0.5;\n    }\n\n    return -1.0;\n}\n\nfloat pool(vec3 ro, vec3 ray)\n{\n    float t = 0.0;\n    for (int i = 0; i < 64; i++) {\n        float res = Pool(ro+ray*t);\n        if( res < 0.001 ) return t;\n        t += res;\n    }\n\n    return -1.0;\n}\n\nfloat caustics(vec3 p, vec3 lp) {\n    vec3 ray = normalize(p - lp);\n    \n    float d = beforeWater(lp, ray);\n    vec3 inter = lp + ray * d;\n\n    \n    if (d < -0.5) {\n    \treturn (0.0);\n    }\n    \n    //d = water(lp, ray);\n    //vec3 surfpos = lp + ray * d;\n    vec3 surfpos = inter - vec3(0., WaterWave(inter) - 0.01, 0.);\n    \n    vec3 refractRay = refract(ray, vec3(0., 1., 0.), 1./1.333);\n    float beforeHit = pool(inter, refractRay);\n    vec3 beforePos = inter + refractRay * beforeHit;\n    //return beforePos.y;\n    float tp = (-beforePos.y - DepthPool) / refractRay.y;\n    beforePos += refractRay * tp;\n\n    refractRay = refract(ray, Normal(surfpos), 1./1.333);\n    float afterHit = pool(surfpos, refractRay);\n    vec3 afterPos = surfpos + refractRay * afterHit;\n    tp = (-afterPos.y - DepthPool) / refractRay.y;\n    afterPos += refractRay * tp;\n\n    float beforeArea = length(dFdx(beforePos)) * length(dFdy(beforePos));\n    float afterArea = length(dFdx(afterPos)) * length(dFdy(afterPos));\n    return max(beforeArea / afterArea, .001);\n}\n\nvec3 Shade(vec3 rpos, vec3 rdir, float t)\n{\n\tvec3 pos = rpos + rdir * t;\n\tvec3 nor = Normal(pos);\n\t\n\tbool waterSurface = IsWaterSurface(pos);\n\tbool water = IsWater(pos);\n\tvec3 waterSurfaceLight = vec3(0);\n    vec3 light = vec3(50.);\n\tif (waterSurface)\n\t{\n\t\tvec3 refractionDir = refract(normalize(rdir), nor, 1./1.333);\n\n\t\twaterSurfaceLight = Lighting(pos, nor, rpos, Material(pos), light, LightSource);\n\n\t\tfloat wt = Trace(pos, refractionDir, 0.03);\t\t\n\t\tpos += refractionDir * wt;\n\t\tnor = Normal(pos);\n\t}\n\tMaterialInfo mat = Material(pos);\n\n\tvec3 color = .11 * mat.Kd;\n\n\t\n\tif (water || waterSurface) {\n        if (IsPool(pos) || (IsBall(pos) && water)) {\n            color += Lighting(pos, nor, rpos, mat, light, LightSource) * vec3(caustics(pos, LightSource));\n            color *= WaterColor;\n        }\n        if (waterSurface) {\n\t\t\tcolor += waterSurfaceLight;\n        }\n    } else {\n        color += Lighting(pos, nor, rpos, mat, light, LightSource);\n    }\n\treturn color;\n}\n\nvec3 Camera(vec2 px) {\n\tvec2 uv = px.xy / iResolution.xy * 2. - 1.;\t\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    float x = M_PI * 0.15;\n    float y = 4.;\n   \n\tif (iMouse.z>=1.) {\n    \tx = (iMouse.x/iResolution.x - .5)*7.;\n    \ty = (iMouse.y/iResolution.y)*7.;\n    \tx = clamp(x, -0.2, 1.8);\n    }\n    \n\tvec3 rayStart = vec3(sin(x) * 10.0, y * 1.5, cos(x) * 10.0);\n\tvec3 rayDirection = LookAt(rayStart, vec3(0, sin(iTime * 0.5) -1.5, 0), normalize(vec3(uv, -3.)));\n\t\n\tfloat path = Trace(rayStart, rayDirection, 0.);\t\n\treturn Shade(rayStart, rayDirection, path);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 col = Camera(fragCoord.xy);\n\tfragColor = vec4(col, 0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MttBRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[369, 369, 389, 389, 416], [418, 418, 441, 441, 496], [498, 498, 523, 523, 738], [740, 740, 765, 765, 836], [838, 838, 864, 864, 897], [899, 899, 923, 923, 959], [961, 961, 985, 985, 1021], [1023, 1023, 1052, 1052, 1158], [1160, 1160, 1188, 1188, 1303], [1305, 1305, 1325, 1325, 1386], [1388, 1388, 1409, 1409, 1470], [1472, 1472, 1492, 1492, 1554], [1556, 1556, 1577, 1577, 1632], [1634, 1634, 1663, 1663, 1840], [1842, 1842, 1866, 1866, 1920], [1922, 1922, 1945, 1945, 1976], [1978, 1978, 2001, 2001, 2032], [2034, 2034, 2060, 2060, 2529], [2531, 2531, 2562, 2562, 2864], [2866, 2866, 2887, 2887, 3028], [3030, 3030, 3069, 3069, 3230], [3232, 3232, 3275, 3275, 3400], [3402, 3402, 3452, 3452, 3603], [3605, 3605, 3692, 3692, 4179], [4182, 4182, 4220, 4220, 4400], [4402, 4402, 4434, 4434, 4616], [4618, 4618, 4649, 4649, 4819], [4821, 4821, 4854, 4854, 5868], [5870, 5870, 5913, 5913, 6847], [6849, 6849, 6871, 6871, 7415], [7417, 7417, 7474, 7474, 7538]], "test": "valid"}
{"id": "MttfR2", "name": "flowers2", "author": "wxs", "description": "Different target", "tags": ["cppn"], "likes": 5, "viewed": 425, "published": "Public API", "date": "1540347743", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N_HIDDEN 16\n\nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\n\n\nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\nbufA[0] = vec4(-0.008329778,0.13643943,0.13512562,-0.09506213) + mat4(vec4(-0.25991716980934143,-0.38576751947402954,-0.01909691095352173,0.17496752738952637),vec4(0.4146137535572052,0.533898115158081,-0.18997739255428314,-0.1385313719511032),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[1] = vec4(0.122495756,-0.13693002,-0.11677887,0.031946845) + mat4(vec4(0.6816356182098389,0.4805877208709717,0.37732377648353577,0.08900109678506851),vec4(0.9319760799407959,0.03582743555307388,1.0947446823120117,0.5574575066566467),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[2] = vec4(-0.0028767572,-0.07100725,0.0029229666,0.13617152) + mat4(vec4(-0.11175279319286346,0.21171505749225616,-0.7185731530189514,1.7684638500213623),vec4(1.193227767944336,0.3166559636592865,-0.26040512323379517,0.17798124253749847),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[3] = vec4(0.024559079,-0.22725414,-0.025607808,-0.019015905) + mat4(vec4(-0.5794887542724609,0.005143200512975454,0.03960299491882324,-1.4242994785308838),vec4(0.12803010642528534,-0.4641987383365631,-0.858701765537262,-0.6116234660148621),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.30115673,-0.153414,0.26151296,-0.1355598) + mat4(vec4(0.18450339,0.08675532,0.041731402,-0.08739926),vec4(0.22953199,-0.09638246,0.10020578,-0.50066715),vec4(0.24617225,-0.27308735,0.18039098,0.15695944),vec4(-0.18107162,0.1832596,-0.073430784,0.19985566)) * bufB[0] + mat4(vec4(0.06262173,0.052811842,-0.23387522,-0.33428553),vec4(-0.101538226,0.20686825,-0.036468055,-0.14128076),vec4(-0.0593654,-0.14821616,-0.187064,-0.13318443),vec4(0.096051924,0.19872965,0.37323877,-0.26623756)) * bufB[1] + mat4(vec4(0.0474437,0.073062524,0.12744606,-0.37006575),vec4(0.025315627,-0.37820068,-0.15778236,0.005380772),vec4(-0.10161813,-0.15155895,-0.10044746,0.5135371),vec4(0.27480492,-0.022316288,0.020973284,-0.23063861)) * bufB[2] + mat4(vec4(-0.18433255,-0.17448121,-0.19797808,0.24941756),vec4(-0.41347134,-0.042204212,0.04431286,0.11049353),vec4(-0.017919082,-0.12076564,0.39129192,-0.08417349),vec4(0.12087339,0.059964105,0.15479162,0.18934336)) * bufB[3] + mat4(vec4(0.26923597,0.1171622,-0.016217487,-0.005634133),vec4(-0.023382645,-0.25113583,-0.03669521,-0.16838394),vec4(0.0016031398,-0.04296739,-0.40364993,0.20151363),vec4(-0.40691265,0.10078256,-0.27681726,0.37968746)) * bufB[4] + mat4(vec4(-0.1755073,-0.10969158,-0.11137789,0.2522997),vec4(-0.41854995,0.26203194,-0.60378176,0.024424171),vec4(0.13063371,-0.24757363,-0.33867255,0.22592959),vec4(-0.074051835,-0.30337837,-0.13681585,0.090834126)) * bufB[5] + mat4(vec4(0.002077526,0.08462271,0.08649992,-0.0055176215),vec4(-0.09085779,0.07794882,-0.5386057,0.019339904),vec4(-0.27606675,0.04326003,0.05234255,-0.12300623),vec4(-0.38018638,0.12885018,0.105298586,-0.16881017)) * bufB[6] + mat4(vec4(-0.43846887,0.30782977,-0.11853517,0.32883772),vec4(-0.23755547,-0.14778171,-0.36180878,-0.21309543),vec4(-0.16172118,0.16760768,-0.43661433,-0.08538214),vec4(0.001575182,0.5936468,-0.11013039,-0.19003196)) * bufB[7];\nbufA[1] = vec4(0.25764376,0.06594146,0.08940438,0.38832578) + mat4(vec4(-0.10246681,-0.15983695,0.092950374,-0.024413219),vec4(0.22206458,-0.22953545,-0.0002878831,-0.054475546),vec4(0.39325684,0.30818453,0.17473592,0.10043376),vec4(0.08548661,0.14204554,-0.13296649,-0.10695486)) * bufB[0] + mat4(vec4(0.2125138,-0.059738617,0.31645304,0.12944409),vec4(-0.2664293,0.2683091,0.0017726383,-0.039513215),vec4(-0.23816103,-0.1561321,-0.05281193,-0.24550305),vec4(0.00029582158,-0.3030517,0.083345965,-0.23827249)) * bufB[1] + mat4(vec4(-0.037401494,-0.15634786,0.16816865,-0.17563893),vec4(-0.2948631,-0.25265965,-0.09071548,-0.09425818),vec4(0.025544573,0.26843143,-0.4052102,0.069290414),vec4(-0.1624957,-0.024641072,0.66756296,-0.15765922)) * bufB[2] + mat4(vec4(-0.02575986,-0.003738694,-0.24619229,0.2218758),vec4(-0.016528944,-0.101555936,-0.07783527,-0.26588538),vec4(-0.040188443,0.15539211,-0.16453099,-0.10853908),vec4(0.03188239,0.035078216,-0.22785783,-0.09208334)) * bufB[3] + mat4(vec4(-0.44507283,0.21615578,-0.23626633,0.11215745),vec4(-0.43220723,0.27154583,0.036194228,-0.36737037),vec4(-0.1683786,0.0068786507,-0.050186604,-0.33862388),vec4(-0.26716417,0.24944335,-0.1834667,-0.17524621)) * bufB[4] + mat4(vec4(0.16335498,-0.33947402,0.15981816,0.098767675),vec4(-0.023585655,0.24741334,-0.47183624,-0.40097338),vec4(-0.04513012,-0.040366717,-0.1023472,0.09000929),vec4(-0.2543874,0.05038225,0.14946586,0.16131422)) * bufB[5] + mat4(vec4(-0.17938921,0.04716639,-0.05702639,0.08121418),vec4(-0.00481687,-0.4287295,-0.30081183,-0.14451426),vec4(0.007545995,0.21639572,-0.33537996,-0.23772417),vec4(-0.16501534,-0.4474303,0.17412893,-0.21161954)) * bufB[6] + mat4(vec4(-0.21755596,0.112951085,-0.30110827,-0.73916763),vec4(0.07242148,0.03950105,-0.13273437,-0.16865543),vec4(-0.20329352,-0.17835261,0.19459921,0.06832675),vec4(-0.05260988,0.2090617,0.01572721,0.23368897)) * bufB[7];\nbufA[2] = vec4(0.10436799,0.0954159,0.16160423,-0.07476421) + mat4(vec4(-0.029262815,-0.27342927,0.016133783,0.07240549),vec4(-0.0068899416,0.010233524,0.13771363,-0.04608036),vec4(-0.12389541,-0.12883233,0.20843184,0.008711129),vec4(-0.14723802,-0.36024845,-0.028952748,-0.015115803)) * bufB[0] + mat4(vec4(0.010286615,0.08305632,-0.06720398,0.3223737),vec4(-0.025726404,-0.44611436,0.016621687,0.057985775),vec4(0.113327764,-0.073726356,0.32313538,-0.02570328),vec4(0.3200009,-0.11345375,-0.23396498,-0.010005707)) * bufB[1] + mat4(vec4(0.059546687,-0.39515036,0.36323375,-0.088270895),vec4(-0.11873733,0.019932328,-0.04216234,-0.27579293),vec4(0.039231032,0.058854084,-0.05972087,0.23868257),vec4(-0.023543667,0.5188833,0.08399108,-0.037194096)) * bufB[2] + mat4(vec4(-0.05059641,0.1340166,0.28064215,0.09014537),vec4(-0.11244127,-0.120329596,-0.24550958,0.16149129),vec4(0.0011374069,-0.017321585,-0.271746,-0.045810517),vec4(0.18859223,0.14368159,-0.032316994,0.021008013)) * bufB[3] + mat4(vec4(-0.22392054,0.071124606,-0.32447907,-0.24825792),vec4(-0.2205502,0.081914775,-0.14221534,-0.28697547),vec4(-0.07556515,-0.35098398,-0.06912167,0.11678695),vec4(-0.014957248,-0.05595934,-0.13545717,-0.18253012)) * bufB[4] + mat4(vec4(0.21159399,-0.14694601,-0.030727891,0.054061763),vec4(0.27709365,-0.41671264,-0.41658485,0.29709846),vec4(0.40073606,0.028473886,0.088263996,-0.016979655),vec4(-0.03759912,-0.24653025,-0.023087377,0.042507477)) * bufB[5] + mat4(vec4(0.10869448,0.019809838,0.18439372,-0.083700694),vec4(-0.3852635,-0.3953206,-0.15770625,0.16581891),vec4(-0.21904725,-0.39947042,-0.3104424,-0.058406044),vec4(0.2448761,-0.010693942,-0.09846988,0.089923576)) * bufB[6] + mat4(vec4(-0.03354407,-0.08508571,-0.37980348,-0.20953979),vec4(-0.053174406,-0.41227505,0.040033944,0.039441526),vec4(-0.1651667,0.06554743,0.083810054,0.09029163),vec4(-0.31803986,0.13509306,0.05776849,-0.16511042)) * bufB[7];\nbufA[3] = vec4(-0.25656548,-0.24421322,-0.032423873,0.15208125) + mat4(vec4(0.07122801,-0.0920305,0.30874708,0.14035088),vec4(0.032004803,-0.012237988,-0.07359746,-0.03958445),vec4(0.0037997235,-0.16220342,0.1312074,-0.07131075),vec4(0.27011022,0.056446,0.11170321,-0.19188657)) * bufB[0] + mat4(vec4(-0.10263501,0.025609814,0.08954666,0.3545437),vec4(0.22851874,0.159227,0.2578123,-0.11385505),vec4(-0.0015616517,-0.11936503,0.014609009,-0.19396074),vec4(0.17606916,-0.04539859,-0.13608783,-0.030440148)) * bufB[1] + mat4(vec4(0.1800258,0.008215414,0.013955838,-0.07172057),vec4(-0.02984967,-0.04638955,0.2457754,-0.14181818),vec4(-0.2124334,0.4455868,-0.06687008,9.51261e-05),vec4(0.14411515,0.03514234,-0.26680982,-0.24760433)) * bufB[2] + mat4(vec4(-0.015187081,-0.14032602,0.16210413,-0.019505994),vec4(0.20846151,-0.14427114,-0.23696989,-0.34669647),vec4(0.07842329,-0.27851123,-0.062005784,-0.054116406),vec4(0.40399668,0.0490637,-0.17684983,-0.08170066)) * bufB[3] + mat4(vec4(0.08155734,0.11908173,-0.35671708,-0.28765723),vec4(0.322696,0.3807196,-0.024984948,-0.025533298),vec4(0.15465075,-0.09520042,-0.063420475,-0.47986075),vec4(0.036680877,0.091030486,0.057514332,-0.7901983)) * bufB[4] + mat4(vec4(0.04312756,-0.13410631,0.3130718,-0.16046095),vec4(0.25215098,0.2575254,0.4850197,-0.2155333),vec4(-0.08914507,-0.07591513,-0.29899102,-0.08564013),vec4(0.30685914,-0.06260427,-0.38679412,0.0066785775)) * bufB[5] + mat4(vec4(-0.21336512,-0.23881641,-0.10162808,0.14260451),vec4(0.13891159,-0.11497336,-0.2803644,-0.4529842),vec4(0.10951331,0.08236249,0.33005854,-0.4009274),vec4(0.27533227,0.036352683,0.07699905,0.019261917)) * bufB[6] + mat4(vec4(0.5245626,0.43660834,0.10322585,-0.23476882),vec4(0.4070818,-0.308628,-0.1288215,-0.23087826),vec4(0.09988004,0.037553985,-0.6540771,0.10653846),vec4(0.1492059,0.059781976,0.4175862,-0.0651073)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.056769036,-0.07046935,0.009082505,-0.12148532) + mat4(vec4(-0.2960342,0.09175605,0.24703364,-0.20456472),vec4(0.083596505,-0.25587213,-0.2767922,0.06918224),vec4(0.34105155,0.32106632,-0.1406333,-0.18790738),vec4(-0.016544083,0.12513563,-0.09900387,0.06646368)) * bufB[0] + mat4(vec4(-0.32693762,0.14166313,-0.23699708,-0.08340852),vec4(-0.084252775,0.6133936,0.06994689,-0.06431675),vec4(-0.6297832,-0.13570252,-0.42925647,-0.20333102),vec4(-0.2652746,-0.042675547,-0.04072883,-0.17420478)) * bufB[1] + mat4(vec4(0.011379636,-0.2561374,0.0033306573,0.082131945),vec4(0.18502915,-0.104736626,-0.07013449,0.018395204),vec4(0.038984664,-0.12988824,0.1452364,-0.06967745),vec4(-0.32392827,-0.0017813263,0.020661768,-0.08943912)) * bufB[2] + mat4(vec4(0.45212004,-0.16346826,-0.018151594,0.09137668),vec4(0.2641011,-0.05968234,-0.12553543,0.27040526),vec4(0.24095479,0.07693146,-0.60708797,0.34561065),vec4(0.101161756,-0.1011108,0.112325504,-0.005864328)) * bufB[3] + mat4(vec4(-0.03836545,0.136737,-0.17205437,-0.002124345),vec4(0.26990747,0.4151754,-0.18319659,0.24869521),vec4(0.10073372,-0.076591775,0.29068965,0.0058539663),vec4(-0.22950257,-0.3954869,-0.082919285,-0.06648309)) * bufB[4] + mat4(vec4(-0.080206685,0.4353825,-0.070264176,0.15170494),vec4(0.13588455,-0.08495916,0.26092452,0.016158722),vec4(-0.2171739,-0.22905813,-0.35996443,0.36902696),vec4(-0.24520802,0.27742094,0.21397337,-0.5361416)) * bufB[5] + mat4(vec4(-0.0008015047,0.16509816,0.014245942,0.12088501),vec4(-0.013204433,0.48652685,-0.026038406,-0.08869798),vec4(0.09268708,0.3683132,0.1371111,-0.08972431),vec4(0.095000535,0.3566337,0.19429114,0.08379958)) * bufB[6] + mat4(vec4(-0.07217676,0.072942816,-0.3378467,0.27749532),vec4(-0.001503741,-0.29984808,0.25344795,0.08572254),vec4(-0.12113398,-0.48327467,0.25811967,0.37428704),vec4(-0.03762059,-0.17695273,0.07509458,0.36593983)) * bufB[7];\nbufA[1] = vec4(-0.09431444,-0.10180386,-0.05768599,-0.20391285) + mat4(vec4(-0.03014161,-0.20899163,0.14757612,0.06857928),vec4(-0.20544839,0.22973394,-0.43388966,0.29656425),vec4(-0.2016828,0.33751777,0.12971564,0.16663615),vec4(-0.12232752,0.21880224,0.24483219,-0.21956292)) * bufB[0] + mat4(vec4(0.2704765,0.22125223,0.1941447,0.033770654),vec4(0.08346577,0.050987937,-0.2570702,-0.2769914),vec4(-0.29651213,-0.028500993,-0.05201888,-0.28019127),vec4(-0.06312965,-0.07547818,0.15790734,-0.05033716)) * bufB[1] + mat4(vec4(-0.16415359,0.11736855,0.14219481,-0.036059488),vec4(-0.016768597,-0.061076846,-0.19599576,-0.11080785),vec4(-0.19419503,-0.36082822,-0.17417921,-0.15061072),vec4(0.14860111,-0.10622545,0.21598725,0.18537338)) * bufB[2] + mat4(vec4(0.22923917,0.086171605,-0.36882693,0.08691402),vec4(-0.07168065,0.17263727,-0.12928319,-0.097306274),vec4(0.37172076,-0.012902125,0.072674796,-0.10071044),vec4(-0.05781506,-0.055121012,-0.12073989,0.10010179)) * bufB[3] + mat4(vec4(0.3311006,-0.073664,0.21880884,0.20152365),vec4(0.09874292,0.0450283,-0.005871097,0.19020997),vec4(-0.29705876,0.10225652,0.1915691,0.04240956),vec4(0.1318571,0.102979235,-0.17844257,0.091262266)) * bufB[4] + mat4(vec4(-0.2268249,0.17523162,-0.1623547,-0.15945637),vec4(-0.30150256,0.039638627,-0.2916851,0.21904813),vec4(-0.0051142396,0.1529729,0.16564631,0.47888967),vec4(0.12484544,0.26785076,0.47410727,0.0073525948)) * bufB[5] + mat4(vec4(-0.4790775,-0.13152592,-0.09060186,0.074485056),vec4(-0.21259187,-0.05552373,-0.21176395,-0.064857215),vec4(-0.14158083,0.21443935,0.22549514,-0.23398463),vec4(0.027120009,0.0073317164,0.33047527,0.29218605)) * bufB[6] + mat4(vec4(0.22165853,-0.101765305,-0.0391057,0.108298115),vec4(-0.13935639,0.009525865,-0.05093859,-0.0625136),vec4(0.35548088,0.19276129,0.06862899,-0.15511332),vec4(0.38228145,0.33064348,-0.058728617,0.03169069)) * bufB[7];\nbufA[2] = vec4(0.16778633,-0.4233184,-0.08215437,-0.15148725) + mat4(vec4(-0.14803156,-0.34667647,-0.40746903,-0.14856546),vec4(-0.35862783,-0.13408707,-0.009567324,0.008888431),vec4(-0.0052248756,-0.120507546,0.037043504,0.034718413),vec4(0.2896529,-0.07597241,0.10570704,0.25153542)) * bufB[0] + mat4(vec4(0.31133673,-0.24839891,0.43284747,0.380012),vec4(0.20385419,-0.29638365,-0.09926053,0.28994277),vec4(-0.25634375,0.2940599,-0.103608966,-0.15405627),vec4(0.36653814,-0.10294668,0.081609555,-0.11018339)) * bufB[1] + mat4(vec4(0.096789524,-0.33161995,-0.23277575,0.18993329),vec4(0.0420551,-0.4163869,-0.27361336,-0.17294955),vec4(-0.013005573,0.102188185,-0.1702626,-0.007824905),vec4(0.025449907,0.15320766,0.15153563,-0.29598007)) * bufB[2] + mat4(vec4(0.1192001,0.1259328,0.40135366,0.33216906),vec4(0.03915595,0.0065117506,0.05527106,0.3198141),vec4(-0.056866895,-0.16511859,-0.028584646,0.18601866),vec4(0.20148346,-0.18901843,-0.08906913,0.1350952)) * bufB[3] + mat4(vec4(-0.16053124,0.024371056,0.06777477,0.3539614),vec4(0.11635692,0.14651194,0.0642655,0.36723098),vec4(-0.10467804,0.21875314,0.2599807,0.16478322),vec4(0.026163654,-0.4655783,-0.022472417,-0.16419701)) * bufB[4] + mat4(vec4(-0.47462994,0.47489217,0.33346835,-0.06612881),vec4(-0.22618948,0.09305927,-0.10975707,-0.40048462),vec4(0.22499815,0.04634622,-0.19268516,0.012705158),vec4(-0.06520171,-0.19897099,-0.34057885,-0.0020580622)) * bufB[5] + mat4(vec4(0.20438056,0.18377014,0.14087051,-0.11916892),vec4(-0.11054143,0.039558552,0.30259332,-0.051608074),vec4(-0.1284895,-0.26857162,0.02672697,-0.2317112),vec4(-0.2707007,-0.010632684,0.25270295,-0.16364214)) * bufB[6] + mat4(vec4(-0.16935116,0.47599927,0.17385975,0.11176594),vec4(-0.21389058,-0.17007744,-0.27602592,-0.2533412),vec4(-0.2771242,0.12816238,-0.15326461,0.06030539),vec4(-0.26131353,0.3304488,0.08711266,0.38965532)) * bufB[7];\nbufA[3] = vec4(-0.18520768,-0.30519095,0.065542355,0.010839418) + mat4(vec4(0.14980827,0.051399663,0.026922474,-0.028241508),vec4(-0.11879984,-0.061117552,-0.007518598,0.13123158),vec4(0.04428204,-0.3007077,-0.03308128,0.08688913),vec4(0.032580733,0.046805803,0.01541442,-0.2042465)) * bufB[0] + mat4(vec4(-0.0048736623,-0.34984794,-0.14768678,0.28179184),vec4(-0.09193778,-0.055666674,-0.1203879,-0.2269837),vec4(-0.23994946,-0.21818826,0.15307784,-0.1080069),vec4(-0.18368901,-0.35117236,0.0099914,0.017920135)) * bufB[1] + mat4(vec4(0.39228898,-0.11500055,-0.22545819,0.07518325),vec4(-0.19452241,-0.20142673,0.117226966,-0.39835486),vec4(0.14853963,0.050963633,0.28388587,0.14044899),vec4(-0.2520418,0.10934454,0.09663372,-0.16488227)) * bufB[2] + mat4(vec4(-0.10201075,0.13569434,0.1502058,0.18673992),vec4(0.042242136,0.18047617,-0.069704734,-0.22638671),vec4(-0.06602754,-0.18658188,-0.29976207,0.34378386),vec4(0.34909582,-0.35657194,0.071950346,0.08617134)) * bufB[3] + mat4(vec4(0.2722614,0.010649264,-0.09310109,-0.05188016),vec4(-0.14526123,0.06754469,0.058461845,-0.06958889),vec4(0.38774398,0.36914805,0.16355796,0.31445345),vec4(0.11709047,-0.27576837,0.20966546,-0.1859215)) * bufB[4] + mat4(vec4(-0.15212919,0.23555183,-0.16081959,0.014660682),vec4(0.008293111,0.208572,-0.034084007,0.24098948),vec4(-0.21049216,-0.19345503,0.32111484,0.12003333),vec4(-0.21010485,-0.0109820645,-0.28839642,-0.28823358)) * bufB[5] + mat4(vec4(0.3252997,0.22852047,-0.07970058,0.12966476),vec4(-0.16536802,-0.010858776,0.12784804,-0.16215616),vec4(0.20896707,0.22627641,0.18811293,-0.21661887),vec4(0.08409432,0.17862868,0.15529558,-0.029298313)) * bufB[6] + mat4(vec4(0.49570578,0.12090713,0.0067580035,-0.14734423),vec4(0.048136357,-0.0016314018,-0.52559555,-0.28720313),vec4(0.15642725,0.20714818,-0.13443641,-0.54239786),vec4(0.5233088,0.15195625,0.3437759,-0.30970198)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.005406815,0.005701481,-0.15065385,0.008380438) + mat4(vec4(-0.02057804,0.14429715,0.19196603,0.46051124),vec4(-0.21046273,-0.028216526,0.07324222,0.14282213),vec4(0.022819992,-0.33865166,0.17777653,0.036827024),vec4(-0.031352,0.12665449,0.07942269,0.0028280518)) * bufB[0] + mat4(vec4(0.0017791309,-0.093007,-0.03274235,-0.07238441),vec4(-0.21494147,-0.41238153,-0.14977449,0.09247578),vec4(0.07388558,-0.080175154,-0.16410834,0.010461479),vec4(0.06711442,0.34955993,-0.058712587,0.14018688)) * bufB[1] + mat4(vec4(-0.017821882,-0.31686682,-0.36801285,0.27773094),vec4(-0.14882651,-0.18952169,0.19767232,-0.066994965),vec4(-0.1158158,-0.21717235,0.03686355,0.13219407),vec4(-0.1509075,-0.029196845,0.1795061,-0.064638875)) * bufB[2] + mat4(vec4(-0.013593799,-0.2860148,0.054850385,0.09217051),vec4(0.0995374,-0.40128314,0.21210197,-0.0936229),vec4(0.19729008,-0.017187603,-0.46309495,-0.16143803),vec4(-0.15379824,0.18370393,-0.025873432,-0.04675905)) * bufB[3] + mat4(vec4(0.034327872,0.5731546,0.06379851,-0.19303384),vec4(-0.098518275,0.42173114,-0.0070214486,-0.08192155),vec4(-0.20675728,0.12628663,-0.26907584,0.17465043),vec4(-0.32773098,0.17093486,0.021291362,-0.009479172)) * bufB[4] + mat4(vec4(0.077154845,-0.1349438,0.30278745,-0.16715421),vec4(0.025314873,0.059733454,-0.006555374,-0.019097272),vec4(-0.1112395,-0.38208547,-0.031273484,0.10405001),vec4(-0.09974311,0.055669956,-0.17361279,-0.15624078)) * bufB[5] + mat4(vec4(-0.121160075,-0.05540393,0.19576916,-0.13745707),vec4(-0.20945808,0.15886381,0.36135596,-0.096324876),vec4(0.10815808,0.08353698,-0.2989308,0.103924446),vec4(0.15111805,-0.2385302,-0.005960988,-0.13465805)) * bufB[6] + mat4(vec4(0.0075415922,-0.23324879,0.08203952,0.38335252),vec4(0.024672013,-0.28815797,0.12700191,-0.6151926),vec4(0.17727552,-0.43930194,0.0059733633,0.1510616),vec4(0.46197256,-0.3099705,0.11713478,0.12759359)) * bufB[7] + in0;\nbufA[1] = vec4(0.01281326,0.037485838,-0.082998894,0.15163909) + mat4(vec4(-0.22680736,0.13737686,-0.10846125,-0.13789302),vec4(-0.26171297,0.11305608,0.15074712,0.17194934),vec4(0.5516714,-0.09755871,0.16601284,0.16707438),vec4(-0.26753446,-0.052757885,0.13769269,-0.08976561)) * bufB[0] + mat4(vec4(0.08884045,-0.018955527,0.21075323,-0.24658655),vec4(-0.09314625,0.06580511,0.26234117,0.088027455),vec4(0.04316541,0.07304315,0.08905832,-0.08580608),vec4(-0.13397485,0.08150203,-0.19198824,-0.3497098)) * bufB[1] + mat4(vec4(-0.031616986,0.09435827,-0.04904276,0.3325359),vec4(-0.28874496,-0.053415615,0.08093159,-0.14439958),vec4(-0.05556562,0.07795172,-0.057500567,-0.33271593),vec4(-0.13731419,0.15523475,0.14824079,-0.2884996)) * bufB[2] + mat4(vec4(0.04894054,0.0052709403,0.14115481,-0.29210517),vec4(0.22909519,-0.105840854,0.13885133,-0.27956522),vec4(0.13409759,-0.28823674,-0.06644852,-0.016484708),vec4(-0.23416775,-0.12731832,-0.043891843,-0.21462832)) * bufB[3] + mat4(vec4(0.21711186,0.31651545,0.16218409,-0.2532424),vec4(0.03773381,-0.43822017,-0.75508034,-0.29549393),vec4(0.105392575,-0.040693033,-0.062112913,0.114940956),vec4(-0.015055838,0.07354495,0.15546432,-0.12315)) * bufB[4] + mat4(vec4(0.18074684,0.172662,-0.017558692,-0.15310864),vec4(0.059722897,-0.07958027,0.20200746,0.04762335),vec4(-0.1339366,-0.11769009,-0.2840241,-0.18113674),vec4(0.07142384,-0.17236868,-0.050255857,-0.11662052)) * bufB[5] + mat4(vec4(-0.29946956,-0.1982713,0.021897266,-0.1966643),vec4(-0.1559179,-0.025532017,-0.075919494,-0.30950993),vec4(0.02949946,-0.2585172,0.050769288,-0.40031597),vec4(0.056046344,-0.014436277,0.080743775,-0.1237822)) * bufB[6] + mat4(vec4(-0.23923454,-0.04771665,0.15711032,-0.038577076),vec4(0.36314484,-0.18161117,-0.14780721,0.025251841),vec4(-0.12753141,-0.08680282,0.0034476218,0.014923065),vec4(0.23895276,-0.06622451,0.3588994,0.23705874)) * bufB[7] + in1;\nbufA[2] = vec4(-0.1442509,0.17729095,-0.12469963,-0.17577207) + mat4(vec4(-0.06862597,0.11010722,0.06986576,0.28321984),vec4(-0.2564274,-0.286691,0.23251969,-0.07978788),vec4(0.09382159,-0.2632569,-0.38322672,-0.30827892),vec4(-0.06953131,-0.025185473,-0.07881187,-0.22400318)) * bufB[0] + mat4(vec4(-0.024199039,0.39018777,0.058474485,0.04193132),vec4(-0.28647462,0.30675995,0.24542493,-0.29699293),vec4(-0.09084822,0.33611283,0.18543331,0.25373587),vec4(0.104015686,-0.089017875,0.11014771,-0.14220697)) * bufB[1] + mat4(vec4(0.12854408,0.3209586,0.12611829,-0.27873126),vec4(0.21658592,-0.50921917,0.05517761,0.35147828),vec4(0.0049923863,0.14936604,0.08331018,0.010819444),vec4(-0.23994514,0.08360619,0.37914503,0.08014407)) * bufB[2] + mat4(vec4(-0.124565504,-0.061258156,0.004622946,0.13285992),vec4(0.06816185,-0.2824252,-0.2490843,-0.11076737),vec4(-0.04030296,0.024774466,-0.32467055,0.18381347),vec4(0.13905501,0.17494158,-0.13522163,-0.2651778)) * bufB[3] + mat4(vec4(-0.35614377,-0.020808855,-0.1834878,0.1660327),vec4(0.37123826,-0.40996242,-0.16655143,0.0054926905),vec4(-0.033927444,-0.09348732,-0.21976326,-0.2264714),vec4(-0.089729816,-0.02977646,0.27803084,0.056917768)) * bufB[4] + mat4(vec4(-0.25761008,0.1691003,-0.1540317,0.44987962),vec4(-0.17765895,0.12794328,0.24020891,0.06099001),vec4(-0.1414189,0.080038734,-0.062228188,-0.08350475),vec4(-0.10061149,0.15470864,-0.0728909,0.0746955)) * bufB[5] + mat4(vec4(0.21054015,0.15916178,0.18348964,0.027703254),vec4(0.19589771,0.53731805,0.26067877,0.2085587),vec4(0.0012512731,-0.040517684,0.003303992,0.22812049),vec4(0.0070051136,-0.047784656,-0.2421378,0.17264585)) * bufB[6] + mat4(vec4(0.0048338696,-0.16822286,-0.47493702,-0.22609034),vec4(0.6550718,-0.15008813,0.06281838,0.30121046),vec4(0.048850805,-0.25830334,0.18334185,0.0377929),vec4(-0.34156463,0.07861952,-0.08612575,-0.008271701)) * bufB[7] + in2;\nbufA[3] = vec4(0.04332562,-0.118950926,-0.21152577,-0.04915556) + mat4(vec4(0.14215255,0.39357293,0.561595,0.048610147),vec4(0.23508838,-0.1290592,-0.043299984,0.19818844),vec4(-0.06413184,0.0040182574,0.059721246,0.21342412),vec4(0.0010589472,-0.19199455,0.15138987,-0.18334255)) * bufB[0] + mat4(vec4(0.19041741,0.07025352,0.3799678,-0.16955915),vec4(-0.2652107,0.26020235,0.35124466,-0.064608715),vec4(0.11672326,-0.056918137,-0.12743966,0.008792086),vec4(0.035820365,0.22741151,0.24107295,0.09679704)) * bufB[1] + mat4(vec4(0.06793589,-0.05465874,0.025076952,0.079881355),vec4(-0.44889706,0.24972318,0.35315806,0.1964564),vec4(0.21944372,0.07074956,0.28126866,0.26326358),vec4(0.30229428,-0.044386063,0.08033578,-0.09447145)) * bufB[2] + mat4(vec4(0.13387857,0.20467868,0.024142828,0.47943547),vec4(-0.5037326,0.39969635,0.3616522,0.00463136),vec4(-0.21640837,-0.18674168,-0.3452712,-0.16720091),vec4(0.24303402,0.1548094,-0.023808056,-0.08743061)) * bufB[3] + mat4(vec4(0.23756202,0.3583093,-0.10083488,-0.05953554),vec4(0.020163713,-0.020056421,0.30077657,-0.36260054),vec4(-0.22575168,-0.14623241,0.16193429,0.057052694),vec4(0.12740725,0.5502781,0.017349461,0.10392539)) * bufB[4] + mat4(vec4(-0.34001645,-0.08397853,-0.052932408,0.59005386),vec4(-0.28164664,0.14499703,0.14473026,0.15952623),vec4(0.08346816,0.112244815,0.25061625,0.17011753),vec4(-0.21025527,0.30798033,0.1317948,-0.13785441)) * bufB[5] + mat4(vec4(-0.21958917,-0.055781174,-0.137925,0.09049443),vec4(0.1563768,-0.047336005,-0.21108896,0.1661427),vec4(0.27713105,-0.17056003,-0.29749432,-0.18576758),vec4(-0.1283026,-0.37159333,-0.13972187,-0.0005363338)) * bufB[6] + mat4(vec4(-0.15211746,-0.17080976,-0.04568485,0.4352548),vec4(0.37752703,0.4887401,0.09564433,-0.32983407),vec4(-0.093706585,-0.015826682,0.20218281,0.07667692),vec4(-0.26946303,-0.09620327,0.16809261,0.09473652)) * bufB[7] + in3;\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.039614867,-0.07883583,0.012340474,-0.13548662) + mat4(vec4(-0.17622864,-0.11330251,0.3311737,0.075372465),vec4(-0.18843761,-0.28204617,-0.031898588,-0.09970055),vec4(0.02909415,-0.09980266,0.099549994,-0.023187742),vec4(0.13271578,-0.21259539,-0.08857076,0.094280444)) * bufB[0] + mat4(vec4(0.18595828,-0.026177863,0.38511953,0.3879493),vec4(0.036255185,-0.11689323,-0.24756725,0.09113605),vec4(-0.13446176,0.1376567,0.23019795,-0.104120195),vec4(0.17102568,0.08190366,-0.020408383,0.08264481)) * bufB[1] + mat4(vec4(-0.15182294,-0.15591127,0.08204874,0.1597702),vec4(0.31669772,0.32236394,-0.37462324,-0.27400088),vec4(0.043091282,-0.2242104,-0.18598752,0.22345631),vec4(0.32225975,0.28068134,0.121497504,0.38231242)) * bufB[2] + mat4(vec4(0.042630997,-0.55417466,0.06816745,0.12785129),vec4(0.41800293,0.005607225,0.30333018,0.16598816),vec4(0.12622876,0.07860956,-0.23912275,-0.13676634),vec4(0.20416152,-0.024948997,0.16951999,-0.1387267)) * bufB[3] + mat4(vec4(-0.0760394,-0.2379567,-0.024891514,0.0501179),vec4(-0.26696116,-0.07325005,-0.1502373,0.029668773),vec4(0.11355438,0.24587911,-0.05089334,0.1184927),vec4(-0.2652183,-0.07211221,-0.16301511,0.3305838)) * bufB[4] + mat4(vec4(-0.100351825,-0.055545494,0.17063345,0.0027896855),vec4(-0.11810918,-0.03907058,-0.16169666,0.14337282),vec4(0.034325052,0.23006295,0.26292524,-0.17637457),vec4(0.24928375,0.27796343,0.0081261415,0.306225)) * bufB[5] + mat4(vec4(0.068815134,0.061996773,-0.3141432,-0.057319548),vec4(0.022805076,0.02754764,-0.3467771,-0.2569143),vec4(0.101735234,-0.07820878,0.23510478,-0.2570504),vec4(0.16128598,0.12674305,0.06256814,0.34919184)) * bufB[6] + mat4(vec4(-0.14067641,0.33706614,-0.33097193,-0.3074201),vec4(-0.010782188,-0.047955044,-0.14637436,0.16426659),vec4(0.08625645,-0.40729126,0.13161783,0.14207527),vec4(0.033232626,0.28658834,-0.22945009,0.31340238)) * bufB[7];\nbufA[1] = vec4(0.14253156,0.0033868675,-0.0069088372,0.04429701) + mat4(vec4(0.03357241,0.12081505,-0.24874637,-0.25582406),vec4(0.09081603,0.41674903,0.5231966,0.5459891),vec4(-0.4299673,-0.098456256,-0.1344062,0.087999865),vec4(0.42678326,-0.12935698,0.07099579,-0.050402734)) * bufB[0] + mat4(vec4(0.06887466,0.047941774,-0.5839112,-0.23810086),vec4(0.25918084,-0.12917994,-0.19700238,-0.29071286),vec4(0.029452335,-0.0054775868,-0.15401621,-0.4969767),vec4(-0.3252765,0.1969661,-0.40962502,-0.23609598)) * bufB[1] + mat4(vec4(-0.2643873,0.19988622,0.19650173,0.31901374),vec4(0.03635586,-0.082848676,-0.110314295,-0.30986863),vec4(0.06744874,0.46853408,0.16080752,0.19812575),vec4(0.0898939,-0.06413938,0.09214596,0.2107356)) * bufB[2] + mat4(vec4(0.096682526,0.09416329,-0.23410909,0.04942552),vec4(-0.123873405,0.035220526,0.36525175,0.040916666),vec4(0.17454371,-0.16089793,-0.122387804,-0.03972647),vec4(0.10161288,-0.41341683,0.020982042,-0.2956273)) * bufB[3] + mat4(vec4(-0.1666072,0.41429546,-0.7005369,0.11927152),vec4(-0.20553479,0.14910188,-0.11991277,-0.069529474),vec4(-0.34645882,0.13934067,0.36291888,-0.15154588),vec4(-0.34851983,-0.006234711,-0.02604358,-0.038422223)) * bufB[4] + mat4(vec4(0.18085626,0.0002592121,-0.75002426,-0.06784274),vec4(-0.14554746,-0.08719805,-0.09552336,0.196885),vec4(-0.05491115,-0.16607137,-0.21940966,-0.30599642),vec4(0.051984765,-0.3673441,0.1959866,0.13426039)) * bufB[5] + mat4(vec4(-0.055003773,-0.18027875,0.15282534,-0.2414773),vec4(0.37248957,-0.07455567,0.19359252,0.025767647),vec4(0.020144772,0.10582441,0.37170368,0.04121702),vec4(-0.11467046,-0.44550094,0.46889675,-0.06878526)) * bufB[6] + mat4(vec4(-0.10175787,-0.093045495,0.11349479,-0.12093265),vec4(-0.121551916,0.021621294,0.12311361,0.024594348),vec4(-0.07597838,0.18976521,-0.24577078,-0.12676163),vec4(0.010623192,0.10628531,-0.02741392,-0.038984172)) * bufB[7];\nbufA[2] = vec4(0.11102799,0.050078925,-0.105852686,0.024168422) + mat4(vec4(-0.15752184,-0.052421845,0.13566856,-0.19810914),vec4(0.18957086,-0.07059331,0.27994323,-0.41103542),vec4(-0.16541353,0.056133527,0.91136533,0.02339049),vec4(0.0071852617,0.12538539,0.23059551,0.121299885)) * bufB[0] + mat4(vec4(0.15435565,0.1626537,-0.04323894,0.10691437),vec4(0.14324443,0.015158395,0.14613315,0.036062542),vec4(0.2550864,0.025695376,0.19154336,0.32481518),vec4(0.21651876,0.15824352,-0.37258092,-0.14094722)) * bufB[1] + mat4(vec4(0.06421141,-0.23211747,0.075908706,-0.27133998),vec4(-0.04206031,0.11300852,-0.4548028,0.2939357),vec4(0.18064092,0.1931701,-0.012356966,-0.15634537),vec4(0.23923716,-0.07265148,0.26018298,-0.30444452)) * bufB[2] + mat4(vec4(0.35392815,0.13370553,-0.2735485,0.18015286),vec4(-0.07298759,0.05136682,0.1732451,0.0022575743),vec4(-0.102157384,0.054713156,0.2506185,0.2708515),vec4(-0.36743966,-0.22118887,0.07443567,0.27383247)) * bufB[3] + mat4(vec4(0.092695005,-0.030841168,-0.056779757,-0.4114464),vec4(0.28399184,-0.16092119,-0.16378333,-0.19672547),vec4(0.14860605,-0.19218767,-0.25285044,-0.091848366),vec4(-0.120526314,-0.009162819,0.007142169,-0.09771431)) * bufB[4] + mat4(vec4(0.2858991,0.12388717,-0.37148827,0.046219558),vec4(-0.11367414,0.052994795,0.022017313,0.015220558),vec4(-0.5663094,-0.02714209,-0.18371114,0.09323176),vec4(0.24591103,-0.12389786,-0.035545804,-0.4732009)) * bufB[5] + mat4(vec4(-0.32300755,0.07441039,-0.099722914,0.044315938),vec4(-0.18177377,0.33117402,-0.22160006,0.22036989),vec4(-0.3392019,0.21339507,-0.31845766,0.34245768),vec4(0.16918138,-0.10818785,0.12316375,0.047398414)) * bufB[6] + mat4(vec4(-0.23979461,0.0028056568,0.086611226,0.19062452),vec4(0.29978728,-0.2238078,0.10998529,0.10461417),vec4(0.40013638,-0.26255473,0.32934204,-0.081920624),vec4(-0.33401,-0.23397884,-0.34321603,0.14947698)) * bufB[7];\nbufA[3] = vec4(0.14196587,-0.11181563,-0.032106742,0.11785179) + mat4(vec4(-0.0150512,0.026725404,-0.20713153,-0.08202803),vec4(0.447398,0.0058848634,-0.148138,0.1464222),vec4(0.008122197,0.16083701,0.214155,-0.12977716),vec4(0.09978976,-0.09263113,-0.2019766,0.15772615)) * bufB[0] + mat4(vec4(-0.33133414,-0.21934226,-0.3745263,0.21338437),vec4(-0.11748086,0.11273471,-0.06762261,-0.106167406),vec4(-0.09473596,0.13914526,0.05936137,-0.2549971),vec4(-0.014103318,-0.22300713,-0.26451674,-0.062142763)) * bufB[1] + mat4(vec4(0.2342867,-0.03446889,0.07771559,-0.2149995),vec4(0.11495662,0.17089158,0.25580674,-0.15536682),vec4(-0.24328645,0.19753405,0.32199433,-0.15318118),vec4(-0.25371954,0.08919961,-0.10112662,-0.0108326385)) * bufB[2] + mat4(vec4(0.24826388,0.17225704,0.28927416,-0.18760192),vec4(0.12191174,0.26538402,0.39160544,0.49542946),vec4(0.10370899,0.042906005,0.123512104,0.29022995),vec4(-0.092137255,0.3516994,0.27675882,0.10385627)) * bufB[3] + mat4(vec4(-0.19044559,-0.28506663,-0.03286695,0.27758676),vec4(-0.33978894,-0.32152277,-0.0059672943,0.5476129),vec4(-0.41557518,0.032821305,-0.20306607,-0.26709956),vec4(-0.14978278,0.20041388,-0.13337278,0.0464024)) * bufB[4] + mat4(vec4(0.3337385,0.061378982,-0.06808302,0.17525738),vec4(0.019232867,0.20394896,0.16384833,0.24276023),vec4(0.2257088,-0.06866714,-0.16136444,-0.32929304),vec4(-0.5474415,0.09128013,0.031060496,-0.1258238)) * bufB[5] + mat4(vec4(-0.348729,-0.051873684,-0.006128635,-0.015481744),vec4(0.21594281,-0.13228649,0.6226639,-0.26033807),vec4(0.072145514,-0.019371279,0.048454087,-0.38878495),vec4(-0.16641994,0.0989696,0.17080563,-0.12210048)) * bufB[6] + mat4(vec4(-0.23380892,0.1389992,0.002680187,-0.17948754),vec4(0.1433916,0.11339912,0.40136757,0.34369975),vec4(-0.24471538,0.25565168,0.17155387,0.17803738),vec4(-0.26694646,-0.27326223,0.15414901,-0.21836497)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.1299334,-0.11465917,-0.079171106,-0.037259024) + mat4(vec4(-0.07837415,0.108525746,-0.07531798,0.2316897),vec4(0.2558319,0.09949203,0.1254163,-0.16402745),vec4(-0.3090709,-0.3371421,-0.16241968,-0.028009372),vec4(0.2100166,0.22394459,0.07542414,0.3756034)) * bufB[0] + mat4(vec4(0.21766134,-0.043178592,-0.24104135,0.28435907),vec4(-0.073986396,0.04818164,0.14176433,-0.14003985),vec4(-0.3616696,0.022880714,0.054159876,-0.32577878),vec4(-0.13863525,-0.18543155,-0.17842321,-0.0447668)) * bufB[1] + mat4(vec4(-0.031615652,0.46905187,-0.26187795,0.31178924),vec4(0.19223593,0.0921056,0.26286343,-0.088441245),vec4(0.3446561,-0.098761566,-0.024020188,-0.2758269),vec4(-0.09280279,-0.11258884,0.4436057,-0.011283196)) * bufB[2] + mat4(vec4(-0.3545105,0.013269235,-0.0846183,-0.075288005),vec4(0.279383,0.07957753,0.03071519,0.39394346),vec4(0.011682056,0.33128053,0.26023832,0.14921373),vec4(-0.07112926,-0.13321956,-0.3810629,-0.18469128)) * bufB[3] + mat4(vec4(-0.15670569,-0.08947047,0.08667148,0.14445388),vec4(0.2307785,-0.24129167,0.34521493,0.109787375),vec4(-0.1948635,-0.0006097016,-0.4403744,-0.07611382),vec4(-0.117447875,-0.112793125,0.35836366,-0.17141116)) * bufB[4] + mat4(vec4(-0.033780824,0.14014332,0.02127595,0.115414314),vec4(0.29874817,-0.05305135,0.11985247,0.0915274),vec4(0.10711604,-0.3063062,0.100648016,-0.13386275),vec4(0.31036514,-0.08266527,-0.03181212,-0.38944784)) * bufB[5] + mat4(vec4(0.27953574,0.00981731,0.20553036,-0.13683338),vec4(-0.051202405,0.053863313,-0.006260761,-0.13866438),vec4(-0.08289556,-0.036041327,0.4197954,0.12613383),vec4(0.04250722,0.2079204,-0.18023825,-0.35562223)) * bufB[6] + mat4(vec4(0.1603629,-0.1877259,0.0841323,0.015094997),vec4(-0.06552282,0.2272923,0.15663818,0.08159631),vec4(0.041025545,0.3513384,-0.3701612,0.1683984),vec4(0.0018221503,0.11949082,-0.1969195,-0.30545822)) * bufB[7];\nbufA[1] = vec4(0.051145896,-0.020174274,0.006863628,-0.017334107) + mat4(vec4(-0.33931822,0.017359363,0.31603968,0.18610261),vec4(-0.112603955,-0.007027214,0.0063523985,0.036589522),vec4(-0.07774429,-0.27025342,-0.06650276,-0.16006462),vec4(0.20667428,0.2961606,0.37299174,-0.26196858)) * bufB[0] + mat4(vec4(0.13285434,0.0032536387,0.22408114,0.3368839),vec4(0.17359853,0.08700109,0.20379488,-0.03213292),vec4(-0.09040576,0.1298744,0.23341653,0.06634485),vec4(-0.25916108,0.5143617,0.3567248,-0.021107879)) * bufB[1] + mat4(vec4(0.18456633,-0.1806247,0.40711737,0.0056169974),vec4(-0.08424874,-0.208814,0.26751885,-0.017872449),vec4(-0.40405077,0.12645288,0.2170207,0.42885643),vec4(-0.005183535,-0.76621795,0.00030556263,0.40521473)) * bufB[2] + mat4(vec4(-0.10315122,0.18771103,0.1735565,-0.01705532),vec4(-0.22813019,0.22087911,0.019462235,-0.019480184),vec4(0.012202848,-0.002245766,0.21016705,0.15074502),vec4(-0.6923007,0.16432413,0.33635336,0.12864587)) * bufB[3] + mat4(vec4(0.24086586,0.07472799,0.12788928,0.12911755),vec4(0.21733178,-0.31005812,0.12765774,0.018655552),vec4(-0.21808472,-0.18119733,-0.11974907,-0.14903428),vec4(0.35310426,-0.20762229,-0.15191406,-0.18146336)) * bufB[4] + mat4(vec4(-0.07597971,-0.1271686,0.2420175,0.03406029),vec4(0.073405355,0.0014648909,-0.18118626,0.11414365),vec4(-0.10911877,0.5213942,-0.2120881,-0.059163187),vec4(-0.38470903,-0.40762258,0.12877995,-0.3214409)) * bufB[5] + mat4(vec4(-0.0025352703,-0.24562947,0.07768711,0.3711662),vec4(0.21502423,-0.03893429,0.33032727,-0.10715082),vec4(0.21682103,0.09125661,0.39906877,-0.11414161),vec4(-0.23290208,0.40410516,0.3771348,-0.28279924)) * bufB[6] + mat4(vec4(0.14425795,-0.25616038,0.03535628,0.08981336),vec4(0.002965323,0.022024555,0.12203388,0.14409828),vec4(-0.10486275,0.12313388,0.18069397,0.31940266),vec4(0.017941052,0.12526725,-0.004737992,0.07076735)) * bufB[7];\nbufA[2] = vec4(-0.02628015,-0.039568942,0.14823201,0.04552179) + mat4(vec4(0.027555615,0.2963665,0.01533595,-0.04690746),vec4(-0.078537375,0.08642248,-0.23807213,0.30708152),vec4(0.099544115,0.5366135,0.010840528,-0.2189161),vec4(0.40609583,0.2937758,-0.51835823,0.013657428)) * bufB[0] + mat4(vec4(-0.13270874,-0.43327987,0.41828528,-0.16183354),vec4(2.5442103e-05,-0.3011118,-0.043477107,-0.01019933),vec4(0.13160917,-0.18042631,0.09099083,0.06048839),vec4(0.19320828,0.016767252,0.1900263,-0.47179297)) * bufB[1] + mat4(vec4(0.1616023,0.06084078,0.06987341,0.09897729),vec4(0.012206725,-0.22661361,-0.10052155,0.023642633),vec4(-0.08456143,0.5375713,0.15371442,0.3081002),vec4(-0.17756367,-0.26068565,-0.07890068,-0.0571747)) * bufB[2] + mat4(vec4(-0.2082013,0.28180256,0.54736775,-0.39567095),vec4(0.004739496,0.14818376,0.29314232,-0.03485737),vec4(-0.22198287,-0.023023508,0.08139069,-0.074938826),vec4(0.17706496,0.29777142,-0.030895231,0.2956038)) * bufB[3] + mat4(vec4(0.20387892,-0.15993257,-0.019768363,0.48520243),vec4(-0.036044322,0.58513063,-0.21064568,0.19374655),vec4(-0.267658,-0.103006266,0.2657844,0.29029486),vec4(-0.17480281,-0.14487061,0.32412472,0.072722964)) * bufB[4] + mat4(vec4(0.2747343,0.20204167,-0.4524403,-0.04773532),vec4(0.019172333,0.048497,0.20137437,-0.29862922),vec4(-0.17420755,-0.018759884,-0.04136406,0.18980196),vec4(0.1810832,0.25037396,-0.109261654,-0.11301968)) * bufB[5] + mat4(vec4(-0.023864599,0.0019716893,0.08508374,-0.1125676),vec4(0.26895598,0.15920344,0.07432843,0.0015936197),vec4(0.451248,0.049590103,-0.35189578,-0.12821348),vec4(-0.15444167,0.14794233,-0.11993095,-0.08797972)) * bufB[6] + mat4(vec4(0.22262584,0.3116589,-0.09431919,0.06574677),vec4(0.10229206,-0.18849619,-0.01634958,0.012470095),vec4(0.25820166,-0.04592126,-0.0019641607,-0.25378883),vec4(-0.42271462,0.25384933,0.17303897,0.34895438)) * bufB[7];\nbufA[3] = vec4(-0.08947355,-0.020534739,-0.09460644,-0.039571926) + mat4(vec4(0.21604629,0.3027395,0.2558379,0.32230094),vec4(-0.098084696,0.27156726,-0.033474304,-0.4899341),vec4(0.14123145,-0.37334183,0.26527268,0.3023368),vec4(0.26759243,-0.13161494,0.18754151,0.13561249)) * bufB[0] + mat4(vec4(0.01012348,0.43719473,-0.09186279,-0.11292335),vec4(-0.114642285,-0.08582375,-0.10244746,0.030632254),vec4(-0.16036081,0.03190614,-0.04157043,-0.3017888),vec4(-0.24555306,-0.3642154,-0.21838309,-0.0046515185)) * bufB[1] + mat4(vec4(0.16888766,-0.045031562,0.081422254,0.31577635),vec4(0.29599714,0.18065843,0.022206804,-0.29149127),vec4(-0.24696214,0.17372693,0.07479869,0.35735077),vec4(-0.304936,0.37414837,0.07307542,-0.1748199)) * bufB[2] + mat4(vec4(-0.08249723,-0.014604075,-0.18542497,-0.02720799),vec4(0.423736,0.26231456,0.02961526,0.34396708),vec4(-0.023335714,0.1897429,-0.19670115,-0.20679376),vec4(-0.21388471,-0.3266238,-0.39266568,0.07500393)) * bufB[3] + mat4(vec4(-0.16216707,0.16120228,0.23246339,0.16377963),vec4(0.21503738,0.10650665,-0.06921592,0.23852193),vec4(-0.087579325,-0.23562606,-0.047575977,-0.22949934),vec4(0.10340035,-0.10992287,-0.06632226,-0.07849305)) * bufB[4] + mat4(vec4(0.28481522,0.19803005,0.23376743,-0.18009181),vec4(0.03826728,0.2613198,0.46638137,-0.029574186),vec4(-0.14956038,0.060595088,-0.20659302,0.24569389),vec4(0.16720434,-0.2720544,0.11032161,0.12063501)) * bufB[5] + mat4(vec4(0.13562323,0.22397578,-0.07844708,0.275673),vec4(0.29124436,0.1608493,-0.06382908,0.092331864),vec4(0.07125274,0.19791889,0.00071704003,-0.06559778),vec4(-0.10062356,-0.41129127,-0.21534753,-0.07163337)) * bufB[6] + mat4(vec4(0.379133,0.08444176,0.2908684,-0.24877557),vec4(-0.0021548462,0.09455302,0.25630388,-0.1693447),vec4(-0.077833004,0.31773263,0.13706355,0.02701238),vec4(-0.32784545,0.017035374,-0.45377272,0.44615188)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.046324983,0.1430053,-0.008603342,-0.03248318) + mat4(vec4(0.14541167,-0.26776007,0.08689229,-0.35869613),vec4(0.39970508,0.0064119776,0.36590886,-0.10152253),vec4(-0.051007226,-0.14197148,0.34606802,0.18160118),vec4(0.13234533,-0.38261715,0.29165167,0.3288196)) * bufB[0] + mat4(vec4(-0.07804325,0.27334288,0.08574016,-0.09600658),vec4(-0.31024268,-0.28935835,-0.24074036,-0.05455464),vec4(0.27860555,0.15034679,0.103114694,0.25640914),vec4(-0.09815567,-0.0040645134,-0.18022957,0.3362258)) * bufB[1] + mat4(vec4(0.1327985,-0.6033742,0.111169174,-0.005620698),vec4(0.1754346,-0.20522098,0.24461383,-0.2443663),vec4(-0.24207787,0.21121578,0.40561232,-0.004993987),vec4(0.42202806,0.31950277,-0.03177499,-0.17533429)) * bufB[2] + mat4(vec4(-0.1007753,-0.26449206,0.22238328,0.1780475),vec4(0.20188642,0.083634436,0.2061927,0.102157384),vec4(0.16346191,-0.23798557,0.11422102,0.090127386),vec4(0.034306586,-0.37589929,-0.09921196,0.09384098)) * bufB[3] + mat4(vec4(-0.23852697,-0.10632884,-0.0385698,0.11672974),vec4(0.18380462,0.02999167,0.5572186,-0.09003092),vec4(0.23224883,0.32271877,-0.08798353,0.07708934),vec4(-0.09367435,0.12378396,0.01391787,-0.43357822)) * bufB[4] + mat4(vec4(-0.4064566,-0.17841206,0.16933736,0.068506405),vec4(-0.059523057,-0.17347452,-0.07700125,-0.067589425),vec4(-0.15965806,-0.049944896,-0.17836775,-0.014305362),vec4(0.48724958,0.13375688,-0.05297128,0.10899574)) * bufB[5] + mat4(vec4(0.16093685,0.024780236,-0.04173822,-0.01987002),vec4(0.21588115,-0.4210094,0.16895929,0.10542273),vec4(-0.010760903,-0.33951798,-0.05458757,-0.40503588),vec4(0.04410167,0.1586839,0.15906051,0.2353181)) * bufB[6] + mat4(vec4(-0.09524602,-0.16088058,0.0744574,-0.035253484),vec4(-0.2215974,0.034785017,0.024153482,0.13747872),vec4(0.123459086,-0.0787627,0.24466577,0.13146554),vec4(-0.2916143,0.08315811,0.35453808,0.17628613)) * bufB[7];\nbufA[1] = vec4(0.10883519,0.13420755,-0.054487024,0.094305426) + mat4(vec4(-0.26632014,-0.073722646,0.13714164,-0.2865917),vec4(0.23080501,-0.06731865,0.5086659,0.22912474),vec4(-0.26743183,0.19056857,0.1905223,0.01011431),vec4(0.08153697,0.0011713904,0.2266609,-0.12516403)) * bufB[0] + mat4(vec4(-0.16332415,0.07360927,0.20692137,-0.4111418),vec4(0.45385897,0.052008405,0.28673154,0.2736018),vec4(0.09832236,-0.05827522,0.33919275,0.15235233),vec4(-0.08771196,0.17068449,0.048230946,0.22479329)) * bufB[1] + mat4(vec4(0.521389,0.093952656,0.04867278,0.41025445),vec4(-0.23126958,-0.3274292,0.2085643,-0.032401808),vec4(0.2974199,-0.46639815,-0.06663563,-0.26418078),vec4(0.0540967,0.10175608,-0.22014296,-0.0067863264)) * bufB[2] + mat4(vec4(-0.37468156,0.17945342,0.24073602,-0.05037095),vec4(-0.33514237,0.19500583,0.32842106,0.16085945),vec4(-0.14022352,0.20579633,0.18421492,0.27691293),vec4(0.016545027,0.095278285,0.13866161,0.13393192)) * bufB[3] + mat4(vec4(-0.23987687,0.20244214,-0.09163971,0.24847937),vec4(0.20005324,-0.07109761,-0.27174726,-0.080783255),vec4(6.763404e-05,0.118684314,0.15805218,-0.15927699),vec4(-0.0889577,0.25011793,-0.34496948,-0.1455841)) * bufB[4] + mat4(vec4(0.34170017,0.18582858,0.12924306,-0.022562206),vec4(0.31293,-0.25030687,-0.22075716,-0.32703808),vec4(0.072952054,0.016258385,-0.33004662,-0.5626507),vec4(-0.14545868,0.4907275,0.44056833,0.4602337)) * bufB[5] + mat4(vec4(0.24887076,-0.027127506,-0.3359747,-0.19327034),vec4(0.2832071,-0.25137162,0.2914474,0.05604647),vec4(0.026214192,-0.10871645,0.011700705,0.052902758),vec4(-0.20099694,-0.037060138,0.018411413,-0.047186073)) * bufB[6] + mat4(vec4(0.40126193,0.10322068,-0.2065769,0.049522687),vec4(-0.07916278,0.088052705,0.47156295,0.7845247),vec4(-0.06743841,0.12408232,0.2213892,0.088163465),vec4(0.20205422,-0.40712586,0.0067379414,-0.08798639)) * bufB[7];\nbufA[2] = vec4(-0.031364284,0.10188529,0.110247925,0.12455355) + mat4(vec4(-0.5311692,-0.17803851,0.032691866,-0.015378361),vec4(-0.33594987,-0.30535808,-0.060663912,-0.3776027),vec4(-0.2935809,0.28458366,-0.5291224,0.14012843),vec4(0.097821005,-0.03421614,-0.27018282,-0.0028124517)) * bufB[0] + mat4(vec4(-0.030928504,0.05817593,-0.30021885,-0.13711658),vec4(0.33680472,0.06047982,-0.05667528,0.19802721),vec4(-0.008077377,-0.11978201,-0.06601925,-0.099432886),vec4(-0.31317753,0.121062316,0.21848865,-0.2273258)) * bufB[1] + mat4(vec4(-0.08517513,-0.0011725725,-0.19095099,-0.2877632),vec4(-0.26795414,-0.051092166,0.19246991,0.44156033),vec4(-0.021602873,0.122011036,0.029787103,-0.0015289703),vec4(-0.4777258,-0.008327879,0.07301149,0.16889234)) * bufB[2] + mat4(vec4(-0.17070779,-0.08619661,-0.11298657,-0.043772392),vec4(-0.722296,-0.1312612,-0.2242846,0.15021962),vec4(-0.2972977,-0.12606734,-0.22759458,0.02481306),vec4(0.018743614,-0.49178925,0.05139305,0.41673788)) * bufB[3] + mat4(vec4(-0.12327744,0.24211136,0.11878229,0.30606455),vec4(-0.073683925,0.10633262,-0.1147398,-0.24701022),vec4(-0.10970711,-0.05685874,0.10133477,-0.15647388),vec4(0.11814546,0.11253097,0.08362991,-0.09701386)) * bufB[4] + mat4(vec4(-0.09291835,-0.2942121,0.445119,0.051097464),vec4(-0.13165087,0.021413425,0.051321596,0.15122823),vec4(-0.015777843,0.19031611,-0.3161099,-0.10756161),vec4(-0.25800633,0.19867066,0.16213956,-0.15714458)) * bufB[5] + mat4(vec4(0.2502753,0.29764345,-0.5311983,-0.21384414),vec4(-0.04097953,-0.44396356,-0.1798994,0.24746063),vec4(0.116129555,-0.038925294,-0.28326306,-0.19112222),vec4(0.108902186,0.10365821,-0.009041497,0.5232102)) * bufB[6] + mat4(vec4(-0.17676656,0.22820954,0.068536274,-0.2216452),vec4(-0.28961864,0.17771894,0.24207866,-0.03337169),vec4(0.15118125,-0.12463709,-0.32916218,-0.28362593),vec4(-0.15946484,-0.35393274,0.001998377,0.10232835)) * bufB[7];\nbufA[3] = vec4(-0.024721792,0.1090405,0.043303233,-0.040530775) + mat4(vec4(0.17239483,-0.027085751,0.0715132,0.018869756),vec4(-0.061439164,0.06527737,0.2176323,-0.18129787),vec4(0.3527687,0.043856133,0.31338945,-0.084015675),vec4(-0.08070885,-0.053440556,-0.047957376,-0.09227305)) * bufB[0] + mat4(vec4(0.007940593,0.39397883,0.057423566,-0.0019909465),vec4(-0.06275251,-0.19636354,-0.047960993,0.22930965),vec4(-0.19126701,0.015025587,0.0066935136,-0.0658788),vec4(-0.40577155,-0.18665533,0.064148486,-0.38105485)) * bufB[1] + mat4(vec4(-0.06350082,0.16595311,0.31821194,0.4040173),vec4(-0.10707523,-0.35813135,0.195493,0.044322725),vec4(-0.23583761,0.4116748,-0.22031152,-0.42322126),vec4(-0.13033968,-0.055132307,-0.12469438,-0.11316331)) * bufB[2] + mat4(vec4(-0.0673849,0.2254886,0.25710326,0.5049663),vec4(-0.23005657,0.065363556,0.40940362,0.2281175),vec4(-0.10020001,-0.048065767,-0.124790035,0.27946714),vec4(-0.08255473,-0.17190821,-0.040375087,-0.18399696)) * bufB[3] + mat4(vec4(-0.19154564,-0.17467977,0.17569911,-0.060075086),vec4(0.060080804,0.31548804,0.21423711,-0.10229123),vec4(-0.034556545,0.042714965,0.17616299,0.0774582),vec4(0.08458164,-0.10776907,0.10505902,0.017433504)) * bufB[4] + mat4(vec4(-0.056702137,0.08856198,0.38321814,-0.019025525),vec4(0.466169,-0.349182,0.105154574,0.137811),vec4(0.32444042,-0.018367989,0.5210292,-0.035243437),vec4(-0.087442495,0.21829955,0.19141454,0.13516411)) * bufB[5] + mat4(vec4(0.3910148,0.15345894,-0.06309488,0.056107342),vec4(0.16527012,-0.32608378,0.15191585,0.07622407),vec4(0.15092812,0.19543125,0.11893726,0.27028388),vec4(-0.3247053,-0.3545971,-0.19580668,-0.12277352)) * bufB[6] + mat4(vec4(0.0636803,0.13549444,-0.15190181,0.2547424),vec4(-0.19976531,0.21370333,-0.16764261,-0.12802151),vec4(-0.23463982,0.34082222,0.066488326,0.18256834),vec4(0.110129915,0.2790213,0.35847434,-0.31801853)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.13900103,0.041510686,0.08983543,-0.08458218) + mat4(vec4(-0.60256714,-0.0678324,-0.17149773,-0.047940243),vec4(0.20566651,-0.05877832,0.41351494,0.08764482),vec4(0.10123222,0.0027272985,0.09755745,0.041875318),vec4(0.053242072,0.13771082,-0.1152834,-0.16862883)) * bufB[0] + mat4(vec4(0.07315272,0.20240773,-0.02450506,0.16643246),vec4(0.21304354,0.22375026,-0.036415517,-0.19388483),vec4(-0.030250277,0.068704434,0.008761831,-0.054743633),vec4(0.03231734,-0.10496492,-0.29137838,-0.28751945)) * bufB[1] + mat4(vec4(0.05576505,0.091329895,0.13445905,0.07428296),vec4(0.21681908,0.4862186,0.55597025,0.038084544),vec4(0.72809243,0.22923052,-0.3468831,0.21864067),vec4(0.0605215,0.20939526,0.10140833,0.21867475)) * bufB[2] + mat4(vec4(-0.06700859,-0.4205829,0.15985468,-0.4843067),vec4(0.24820118,0.5531504,0.42065573,0.17281644),vec4(0.49058643,-0.03109403,0.01587322,0.0917154),vec4(0.13356665,-0.21113662,-0.09370774,-0.40457308)) * bufB[3] + mat4(vec4(0.15228328,-0.19329356,-0.31441814,0.16568959),vec4(0.019525066,0.15204306,-0.15554866,-0.3152564),vec4(-0.11133737,-0.2527882,-0.038563773,0.043732073),vec4(-0.071897864,-0.33808786,0.2696194,0.13287884)) * bufB[4] + mat4(vec4(0.11144552,-0.15986419,-0.31416702,0.30319062),vec4(-0.2610091,0.12204996,0.2694896,-0.13071513),vec4(0.39747113,0.029649375,-0.22249256,-0.11513841),vec4(0.11121966,0.029545076,0.24212858,-0.3444144)) * bufB[5] + mat4(vec4(-0.051285304,0.09220445,-0.28843272,0.10691118),vec4(0.11091391,0.071866855,-0.004679933,0.0118657),vec4(-0.09253588,0.0917382,0.2680046,-0.26168227),vec4(-0.46615344,-0.05375852,-0.23231651,-0.42587826)) * bufB[6] + mat4(vec4(0.0883837,-0.08630106,0.059445444,0.15645982),vec4(0.31787542,-0.14282817,-0.048420917,-0.329207),vec4(0.0102213295,-0.35442215,0.1373097,-0.31161267),vec4(-0.17484485,-0.17795697,0.27185687,-0.6010367)) * bufB[7];\nbufA[1] = vec4(0.0101067135,0.15423705,0.105475076,0.012280452) + mat4(vec4(-0.06532151,-0.10028901,-0.0034945942,-0.109600775),vec4(-0.3790057,0.06482199,0.009109789,-0.08135192),vec4(0.10032691,-0.21124567,3.170513e-06,-0.016711641),vec4(-0.19931737,-0.28947836,-0.09977323,0.11223894)) * bufB[0] + mat4(vec4(-0.043008734,0.19051598,-0.092952006,0.37271515),vec4(0.31120238,-0.033732746,0.04811328,-0.3613907),vec4(0.8568236,-0.23234998,-0.28541455,-0.38563633),vec4(0.6333872,0.053632353,0.015098633,0.01696152)) * bufB[1] + mat4(vec4(-0.06831188,0.28138867,-0.07094848,-0.06813615),vec4(-0.40249726,0.04202281,0.2206281,-0.280665),vec4(-0.021830697,0.10540799,0.63992244,0.36796668),vec4(-0.13978033,0.19826873,0.41172713,0.45213094)) * bufB[2] + mat4(vec4(-0.027920365,0.05343942,-0.34370774,0.22391687),vec4(0.22030213,-0.32105199,-0.10476417,0.019448966),vec4(-0.033507325,0.18399866,-0.058794267,0.07826003),vec4(0.42241076,-0.007104337,-0.09993217,-0.2751464)) * bufB[3] + mat4(vec4(-0.22640629,-0.11486795,0.039576642,0.07604001),vec4(-0.123036705,0.19703756,-0.17190415,0.048625246),vec4(0.118657716,0.09989513,-0.15099463,0.00057764817),vec4(-0.026641976,0.29093486,0.015053804,0.26277283)) * bufB[4] + mat4(vec4(0.035926886,0.4919222,0.08648695,0.13743684),vec4(0.022979261,-0.4786249,-0.15779805,-0.053398196),vec4(-0.23450884,-0.055367667,-0.12206835,-0.21706212),vec4(0.013857644,-0.27722126,0.06698891,-0.04939962)) * bufB[5] + mat4(vec4(0.07942121,-0.20566978,0.2819478,-0.0781187),vec4(0.08854592,0.09028892,0.090130895,-0.33009627),vec4(0.428787,-0.12133452,-0.4934282,-0.13405742),vec4(-0.06887148,-0.076631844,0.0702823,0.15574211)) * bufB[6] + mat4(vec4(-0.0096879145,-0.0008558977,-0.21432035,-0.030686032),vec4(-0.094406046,0.13545063,0.21826062,0.41099113),vec4(0.08405962,0.14222248,0.10727438,0.08414427),vec4(-0.07493227,-0.020360202,-0.30740738,-0.26757026)) * bufB[7];\nbufA[2] = vec4(-0.029043278,0.08019826,-0.014751056,-0.026854957) + mat4(vec4(0.46952638,0.15495533,0.3767439,0.2186915),vec4(0.10831453,-0.19525772,0.11542457,-0.16341591),vec4(0.100296535,-0.011407808,0.13894995,-0.011449596),vec4(0.0369875,0.16044347,0.49727488,0.1101165)) * bufB[0] + mat4(vec4(-0.33208978,0.39984104,-0.2827975,0.09568298),vec4(-0.02059991,0.14389104,0.21133462,0.06989219),vec4(-0.06625609,0.17510705,0.5697215,0.85072494),vec4(-0.020460434,0.1866591,0.3793318,0.5507203)) * bufB[1] + mat4(vec4(-0.15831578,0.06119745,-0.29236484,-0.60928226),vec4(0.0217727,-0.031861406,-0.1862033,-0.32635936),vec4(-0.16517009,-0.078612775,0.09539681,0.21558738),vec4(-0.26778454,0.118694864,-0.33808592,0.29576796)) * bufB[2] + mat4(vec4(-0.20561491,0.025718499,-0.4247169,-0.18014307),vec4(0.17062855,0.2092707,0.21636888,-0.07190688),vec4(-0.020702261,0.29903373,-0.060395725,-0.12369677),vec4(-0.09696196,0.24385369,-0.079062514,0.2478821)) * bufB[3] + mat4(vec4(-0.0009706506,-0.04764907,0.37554318,0.18717115),vec4(0.002334285,0.09307405,-0.44977394,-0.33786786),vec4(0.33765796,-0.31848285,-0.065081604,-0.08605011),vec4(-0.0411158,-0.20112014,0.0034940827,-0.47297746)) * bufB[4] + mat4(vec4(-0.20892346,-0.115903035,-0.36151147,0.20017244),vec4(-0.18746775,0.11291934,0.1268668,-0.120954454),vec4(-0.0152828125,-0.010312361,0.25515613,0.40520093),vec4(-0.25428307,-0.30087903,-0.18096602,0.50045246)) * bufB[5] + mat4(vec4(0.19116129,-0.24656403,0.38209638,0.065283805),vec4(-0.076520905,0.19750099,-0.14246991,0.023179466),vec4(0.15512714,0.16781777,-0.09705151,0.41669482),vec4(-0.30876678,0.17195047,-0.1507161,-0.12231207)) * bufB[6] + mat4(vec4(0.022182005,0.021270305,-0.6458219,-0.24759641),vec4(-0.030958686,-0.13630167,0.06294352,-0.11359085),vec4(0.08004009,0.32498434,-0.027036456,-0.17973924),vec4(-0.0650473,-0.0628154,0.12366582,-0.39292926)) * bufB[7];\nbufA[3] = vec4(-0.06682932,0.015805507,-0.1775746,-0.0076624714) + mat4(vec4(0.20112409,0.22498736,-0.15489507,-0.13224734),vec4(-0.29793122,-0.46366638,-0.32998624,0.05616186),vec4(-0.2939789,0.008995114,0.027697159,-0.3455997),vec4(-0.08696424,0.08077454,0.14101116,-0.025209682)) * bufB[0] + mat4(vec4(-0.22973579,-0.010960238,0.5234139,-0.2912561),vec4(0.036149528,0.20913474,-0.51356924,0.025040995),vec4(0.1401506,-0.052048415,0.5404467,-0.17234275),vec4(0.22688805,0.1326564,-0.29118106,-0.22075559)) * bufB[1] + mat4(vec4(-0.097883604,-0.053973354,0.04941441,-0.06963733),vec4(0.10250587,-0.025288904,-0.5235431,0.020084463),vec4(-0.4689445,-0.07533641,-0.5108425,0.68066776),vec4(0.15779212,-0.55755025,0.04164033,0.19965085)) * bufB[2] + mat4(vec4(0.19360578,0.41041344,0.45329678,-0.00034967612),vec4(-0.47625768,0.31128317,0.00019259274,-0.3938636),vec4(-0.041595284,-0.4467621,-0.04722894,-0.25998026),vec4(0.48424774,0.077403456,0.15029916,-0.22916791)) * bufB[3] + mat4(vec4(0.06597392,-0.0072687455,-0.37120223,0.20128362),vec4(0.086853825,0.010213598,0.5070665,-0.29372993),vec4(0.055171277,0.0131529635,-0.12838423,-0.03939455),vec4(0.37733078,0.31778985,0.22801846,0.07972345)) * bufB[4] + mat4(vec4(-0.77323586,-0.2668026,-0.40773928,0.23994902),vec4(-0.06911923,-0.33875534,-0.376328,-0.032106955),vec4(-0.5318628,0.050366182,-0.3204291,-0.3491552),vec4(-0.02453477,0.3221653,-0.38121656,-0.029938448)) * bufB[5] + mat4(vec4(-0.09231794,-0.089099765,-0.5497195,0.35335642),vec4(-0.031438638,-0.09901638,0.19538346,-0.086193286),vec4(0.30559525,0.29933494,-0.17119549,-0.34210664),vec4(0.3220364,0.18584475,0.60491186,-0.32401684)) * bufB[6] + mat4(vec4(0.39632556,0.13852368,-0.37140763,-0.1742633),vec4(-0.5386724,-0.23173448,0.72728384,-0.36038995),vec4(0.11874976,0.2630129,0.40737405,0.00092617323),vec4(0.009205084,0.19720168,0.043929428,-0.02932457)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.21799545,0.029610766,0.27457607,-0.1027607) + mat4(vec4(0.30289757,-0.4322932,0.24519059,-0.05454607),vec4(0.4895191,0.026492191,0.17700572,-0.047061346),vec4(0.0743924,0.15914872,-0.162719,0.053425517),vec4(0.20081308,0.09446157,0.26522797,0.36262846)) * bufB[0] + mat4(vec4(-0.33542943,-0.29795408,0.04525382,-0.016472813),vec4(0.023889834,-0.030595943,0.21829312,-0.24116233),vec4(0.20193411,-0.040497042,0.06321513,0.03429014),vec4(-0.17460504,0.4743598,0.11468722,-0.25804675)) * bufB[1] + mat4(vec4(0.24276431,0.3423049,-0.19366989,-0.069441564),vec4(-0.2270461,-0.15216003,0.19607599,0.20766555),vec4(0.084595524,-0.39761165,0.045940254,0.48795024),vec4(0.021445893,-1.3359475,0.20014386,0.20047961)) * bufB[2] + mat4(vec4(0.10740733,-0.18422796,-0.24291742,0.042514738),vec4(0.40668246,-0.07715401,-0.05397016,0.17158635),vec4(-0.6307199,-0.0021633797,0.0055198353,-0.2626901),vec4(-0.13555941,0.17897579,-0.1468692,-0.18807015)) * bufB[3] + mat4(vec4(0.041104976,0.14241791,0.11344197,-0.34475893),vec4(-0.19804491,-0.21251239,-0.20916633,0.16783649),vec4(0.112740085,-0.40065998,-0.18532681,-0.07176703),vec4(0.46826705,0.0105626155,-0.13955323,0.04513465)) * bufB[4] + mat4(vec4(-0.09019216,-0.36479044,0.255963,-0.115792155),vec4(0.08759771,0.020189146,-0.17855504,0.009703933),vec4(0.033382624,-0.079446316,0.21806602,-0.037028395),vec4(-0.08477682,0.2742842,0.36179957,0.07405599)) * bufB[5] + mat4(vec4(-0.010052945,-0.12029802,-0.00044898933,-0.3176683),vec4(-0.28184572,0.12666835,0.12668738,-0.73120403),vec4(0.086260505,0.25633517,-0.25899613,0.35419533),vec4(0.1683306,0.4571686,0.06913147,-0.28469676)) * bufB[6] + mat4(vec4(0.09373823,0.09705682,0.34985682,-0.020933218),vec4(-0.21543178,-0.1810157,-0.03979139,-0.05305641),vec4(0.3130527,0.25758892,-0.060589828,0.06839991),vec4(0.06836467,-0.24451067,0.17742722,0.07536648)) * bufB[7];\nbufA[1] = vec4(0.19076346,-0.020926088,-0.052418992,0.17075664) + mat4(vec4(-0.018899225,0.12139625,-0.43519905,0.3072528),vec4(-0.05677264,0.060709666,0.37912968,0.13236363),vec4(0.20700231,0.117519215,-0.015247125,-0.0056541916),vec4(0.19568855,0.13695145,-0.22870715,-0.27588606)) * bufB[0] + mat4(vec4(-0.024941387,0.03812515,0.1738492,0.3741541),vec4(0.30171618,0.416943,0.006758365,-0.13650464),vec4(0.21283658,0.23435882,-0.042038754,0.014591026),vec4(0.05982658,0.09676244,-0.16851416,-0.14203249)) * bufB[1] + mat4(vec4(0.065389924,0.012564912,0.064759895,0.17648213),vec4(0.1285675,0.23411727,0.093901575,0.120427355),vec4(-0.010264513,-0.104667425,0.15069374,0.38103887),vec4(-0.10534763,0.14238182,-0.36581397,-0.021929415)) * bufB[2] + mat4(vec4(-0.55940205,-0.57947624,0.23716791,-0.36859825),vec4(-0.3047939,-0.025204893,0.43032664,0.25912973),vec4(-0.45430058,-0.33575252,0.60962325,-0.2899753),vec4(0.31375283,0.09242649,0.012802985,-0.36282673)) * bufB[3] + mat4(vec4(0.35298112,0.13812199,-0.23401548,-0.3189025),vec4(-0.44893253,-0.3599472,0.08356643,0.2607642),vec4(-0.0054795756,-0.073947676,-0.051138166,0.2743837),vec4(-0.030638922,-0.10842574,0.19859208,-0.26485568)) * bufB[4] + mat4(vec4(0.053794406,0.0239303,0.32188502,-0.06543959),vec4(-0.19937702,-0.33047625,-0.036500446,-0.2396466),vec4(0.07886474,-0.50303835,0.5312998,0.39228508),vec4(0.28176105,-0.060994938,-0.20080122,0.005747079)) * bufB[5] + mat4(vec4(-0.027731817,-0.048190173,-0.27395123,0.11772681),vec4(-0.267189,-0.0014319926,0.100982755,-0.28004226),vec4(-0.060612153,0.022918377,0.013097455,0.21906349),vec4(-0.080808215,0.13691205,-0.90077865,0.28833812)) * bufB[6] + mat4(vec4(0.046435524,0.13737361,0.73068994,0.07984126),vec4(0.2916035,-0.13825582,0.25658157,-0.17349042),vec4(0.0946222,-0.10597672,-0.60721695,-0.17664467),vec4(-0.07533355,-0.09908029,0.2869386,0.021177247)) * bufB[7];\nbufA[2] = vec4(0.028885785,0.09503762,-0.083900236,0.028918749) + mat4(vec4(0.26264268,0.30882034,-0.06260339,-0.30487707),vec4(0.060021203,0.05317858,-0.50110316,0.004279975),vec4(-0.21470688,-0.014764784,-0.21886602,-0.03856349),vec4(0.27591246,0.22317931,-0.073886864,-0.27982932)) * bufB[0] + mat4(vec4(-0.14544393,-0.39593858,0.42146584,0.08474324),vec4(0.45008278,-0.11105947,0.2764982,0.23249282),vec4(0.25964049,0.2621837,0.11881637,0.01582897),vec4(0.07754522,0.30700764,0.24958734,0.02291646)) * bufB[1] + mat4(vec4(-0.14474835,0.32151014,0.00089722854,-0.00567708),vec4(-0.008689193,0.17439482,0.21625689,0.1629201),vec4(-0.26397702,0.06653781,0.23613355,-0.056809604),vec4(-0.16456138,-0.2330893,0.28101346,-0.27567247)) * bufB[2] + mat4(vec4(-0.29547328,-0.0026339667,-0.28479865,0.40765905),vec4(0.07968346,-0.13894847,-0.31064013,-0.03531938),vec4(-0.17414054,-0.13873184,0.43179238,0.10694129),vec4(0.23655021,0.07547378,0.17643088,-0.0021161146)) * bufB[3] + mat4(vec4(0.15216525,0.0909225,-0.3825668,-0.0709346),vec4(0.15217978,0.1661092,0.27455404,0.28340808),vec4(-0.24292065,-0.16695067,0.16305448,0.1751038),vec4(-0.25323966,-0.1360718,-0.07476706,0.2911232)) * bufB[4] + mat4(vec4(-0.27957055,-0.17361309,-0.1533033,-0.1464968),vec4(-0.30967724,-0.13498306,-0.16334693,0.10522931),vec4(-0.06191563,0.33343166,0.12551498,-0.16875538),vec4(0.11660682,0.024639595,0.048954923,0.06521756)) * bufB[5] + mat4(vec4(0.18002544,-0.12857789,0.29884684,-0.033697344),vec4(0.27368742,0.04728428,0.10856077,0.17818235),vec4(-0.18814531,-0.2681813,0.040883258,-0.2108363),vec4(0.083469585,0.589638,-0.17368047,0.07507938)) * bufB[6] + mat4(vec4(-0.14353904,-0.26004988,-0.2011538,0.116540276),vec4(0.3169752,-0.22169441,0.04035296,-0.12113924),vec4(0.07891379,0.084850036,-0.39684555,-0.940626),vec4(-0.4498947,-0.27286008,0.47552592,0.0823779)) * bufB[7];\nbufA[3] = vec4(0.0048283413,0.24594802,-0.043517407,0.3453841) + mat4(vec4(-0.041159805,0.2077914,0.58888894,0.62493426),vec4(-0.2193658,-0.07374952,0.100776844,-0.10375685),vec4(-0.13331443,-0.15694095,0.08807272,-0.051628616),vec4(0.31961808,0.021534681,-0.28250027,0.031098532)) * bufB[0] + mat4(vec4(0.21131203,-0.2857003,0.50447947,0.17197755),vec4(0.30979082,0.1602082,-0.21012276,0.16486189),vec4(0.5461784,0.37196887,0.041236874,-0.08808645),vec4(0.47715366,0.19276978,-0.13779299,0.31126472)) * bufB[1] + mat4(vec4(-0.3456462,-0.0131533155,-0.26826918,-0.12320668),vec4(-0.30888712,-0.2567594,0.040986206,-0.010599418),vec4(0.28574887,0.15862015,0.40234032,-0.3288726),vec4(0.15925413,0.18603341,0.2964406,-0.14653695)) * bufB[2] + mat4(vec4(-0.38586417,-0.8474433,0.22741196,-0.53041506),vec4(-0.027309218,-0.49037412,0.21124445,-0.44647744),vec4(-0.14923355,-0.4565726,-0.16432644,-0.45419076),vec4(0.42011252,-0.090646714,-0.19014168,0.32511878)) * bufB[3] + mat4(vec4(0.014707656,0.22300647,0.065318145,0.2303655),vec4(-0.066187605,-0.073618725,0.038928263,0.10260947),vec4(0.09959509,0.20838293,-0.09849867,0.14099632),vec4(-0.06392389,-0.058571443,0.57207,0.4416264)) * bufB[4] + mat4(vec4(-0.36652893,0.1646266,0.16657011,-0.39369422),vec4(-0.32829136,0.055655003,-0.36144668,-0.3682184),vec4(-0.2782272,-0.31838912,0.0427844,0.03992518),vec4(0.022757743,0.09175641,-0.15130708,-0.11687119)) * bufB[5] + mat4(vec4(-0.0356832,0.2510203,-0.16453981,0.19522268),vec4(-0.14610931,0.24838537,-0.31339905,-0.29608613),vec4(0.47190267,-0.062381133,-0.5537839,-0.1657633),vec4(-0.028991597,0.18681063,0.31830847,0.14454238)) * bufB[6] + mat4(vec4(-0.36106417,-0.20217709,0.53508735,-0.054451145),vec4(0.09869053,0.004329711,-0.44422096,0.10970068),vec4(0.1551813,0.36988458,-0.836284,0.27993843),vec4(-0.700342,0.16402543,0.15162598,0.35378584)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.061871946,-0.049355954,-0.14719099,0.25146234) + mat4(vec4(0.038071703,-0.5059257,-0.093143865,0.18611845),vec4(-0.14832383,0.13878526,-0.025958514,0.06902537),vec4(0.44756255,0.07853336,-0.09887245,-0.20598075),vec4(0.0789442,0.14753331,0.285214,-0.09456832)) * bufB[0] + mat4(vec4(0.32788604,-0.07914926,0.009890696,0.27268952),vec4(0.38324663,-0.14228402,-0.23855211,-0.21096504),vec4(0.17017283,0.1804927,-0.15886065,-0.67970467),vec4(0.10318432,-0.18971358,-0.103098914,0.3228334)) * bufB[1] + mat4(vec4(-0.113092855,0.016843267,0.043316055,0.004810082),vec4(0.063373044,-0.2083365,0.38641912,0.58325326),vec4(-0.047651596,0.004328686,0.04801772,0.108380616),vec4(-0.027564643,0.34035817,0.0072390977,0.21758349)) * bufB[2] + mat4(vec4(0.057378843,-0.15117943,0.15898487,-0.31202567),vec4(0.0009089365,-0.2030098,-0.07212627,0.34265682),vec4(-0.033143822,0.31361157,0.03951873,-0.10117066),vec4(-0.0040379656,-0.23439977,-0.20153166,0.21921548)) * bufB[3] + mat4(vec4(0.19455472,-0.08041442,-0.23315118,-0.36865783),vec4(-0.33233884,-0.47929466,0.15956691,0.31658822),vec4(-0.25778618,-0.10102709,0.013643286,-0.083212994),vec4(-0.20175132,-0.22929537,-0.316784,-0.06959392)) * bufB[4] + mat4(vec4(-0.028700134,-0.34940323,-0.44378954,0.12402561),vec4(-0.5613712,0.25790277,-0.21884294,-0.19975054),vec4(-0.22976331,-1.2742413,0.123688415,-0.1475012),vec4(-0.20807433,0.06597902,-0.017602758,0.09402777)) * bufB[5] + mat4(vec4(0.27349192,0.16190901,-0.37220657,-0.2947972),vec4(-0.2074733,-0.081548974,-0.17932709,0.11848693),vec4(0.014841763,-0.025085399,-0.568769,-0.0023984306),vec4(0.54717183,0.6636093,-0.18706691,-0.65929765)) * bufB[6] + mat4(vec4(0.036910146,0.075620495,-0.13085847,-0.45781228),vec4(0.23681574,0.16282815,-0.11910413,-0.20066716),vec4(0.08889945,0.25330514,-0.3957826,0.32414895),vec4(0.07759132,0.17484733,0.41719934,0.16263545)) * bufB[7];\nbufA[1] = vec4(0.10100238,-0.0062162485,-0.36451152,-0.1027564) + mat4(vec4(-0.34114903,-0.11138022,-0.16774842,-0.1682507),vec4(0.15116721,0.12111084,-0.060732592,-0.32879338),vec4(-0.15599893,-0.07435988,0.19047904,0.043952398),vec4(-0.1972436,-0.27081567,0.25577858,-0.16835435)) * bufB[0] + mat4(vec4(0.04841256,0.13144352,-0.24255042,0.05945068),vec4(0.2953168,-0.2220734,-0.032167554,-0.27467367),vec4(-0.06757002,-0.34413737,-0.27363133,0.057503264),vec4(-0.032339178,-0.39266294,-0.17819178,0.0018549152)) * bufB[1] + mat4(vec4(0.24904378,0.049468048,0.08784355,0.47841835),vec4(-0.019471906,0.30917457,-0.021964597,0.2926005),vec4(-0.06699119,-5.916343e-05,-0.11775704,0.05974276),vec4(-0.2523329,0.0009017621,-0.0959635,-0.25665984)) * bufB[2] + mat4(vec4(0.18248579,-0.15975273,0.07466595,-0.17716648),vec4(0.44093502,0.02159268,-0.19046685,0.14458877),vec4(0.22272721,-0.7897607,0.03895257,0.01553713),vec4(0.057270877,-0.032675,-0.24181886,-0.19336621)) * bufB[3] + mat4(vec4(-0.020345451,0.10756951,-0.29262164,-0.062819496),vec4(0.17030409,0.3460687,-0.30554733,0.12556024),vec4(-0.19234245,-0.01981037,0.13751566,-0.443166),vec4(0.14549533,0.22085078,-0.13840057,-0.006236094)) * bufB[4] + mat4(vec4(-0.6116839,-0.06696641,-0.05582205,-0.40570658),vec4(0.047862902,0.08344438,-0.009831637,-0.32123432),vec4(0.2386655,-0.20510545,-0.024017898,-0.3279229),vec4(0.3431683,-0.37996393,0.0019153053,-0.21404748)) * bufB[5] + mat4(vec4(-0.28904793,-0.16190626,-0.11748028,-0.09161085),vec4(-0.011128594,0.16813633,-0.12894319,-0.24114662),vec4(0.2347892,-0.07036448,-0.04255896,0.16190782),vec4(-0.31828898,0.06468139,0.1569948,0.3067965)) * bufB[6] + mat4(vec4(-0.032506995,-0.54837877,-0.3576445,0.28892848),vec4(0.059663627,-0.11993978,0.076331995,-0.1621605),vec4(0.032766826,1.0265088,-0.32502824,-0.14465715),vec4(0.44830704,-0.25882664,-0.39271635,0.08691267)) * bufB[7];\nbufA[2] = vec4(-0.07768292,0.18447931,0.12394769,-0.07765631) + mat4(vec4(-0.039099876,-0.16239342,-0.38078934,-0.011016991),vec4(0.034038246,-0.21598442,-0.16854882,0.10207297),vec4(0.019252488,-0.12298657,0.3125583,-0.14731325),vec4(0.15615724,-0.50643486,-0.28220132,0.17040877)) * bufB[0] + mat4(vec4(0.3247847,0.27257952,0.50292516,-0.054854695),vec4(0.07072639,-0.05266226,0.35136095,0.061870005),vec4(-0.5554262,0.12189619,-0.16817194,0.9168094),vec4(-0.19450042,0.17736688,0.29727408,-0.013837221)) * bufB[1] + mat4(vec4(0.35680303,0.2863582,0.13199876,-0.0604098),vec4(0.08589459,0.15579276,-0.2694531,-0.29793918),vec4(-0.3130453,-0.25195903,-0.39535636,0.02537164),vec4(-0.35988626,-0.20149437,-0.057529543,0.4828181)) * bufB[2] + mat4(vec4(0.3069376,0.086086355,0.058712635,-0.35602933),vec4(0.12796143,0.29988515,0.10300578,-0.5003323),vec4(-0.2794453,0.047420267,-0.10823236,0.3305706),vec4(-0.20966765,0.3335208,0.15756534,-0.21735597)) * bufB[3] + mat4(vec4(0.0325562,0.1329358,0.09758211,-0.152141),vec4(0.43819106,0.4990334,-0.39038765,-0.49278286),vec4(-0.0502192,-0.21387886,-0.02185327,-0.08508645),vec4(-0.09646106,-0.37866378,0.108100735,-0.047393594)) * bufB[4] + mat4(vec4(0.1635007,-0.14194277,-0.09363721,0.13834383),vec4(-0.048071954,-0.11004734,-0.089336716,0.04447344),vec4(0.94926625,0.25912964,-0.26926947,-0.9316333),vec4(-0.034327578,0.15380377,-0.027083477,-0.25063968)) * bufB[5] + mat4(vec4(-0.1182481,-0.23396567,-0.21736842,0.23274517),vec4(-0.06071844,-0.02687763,-0.01871847,0.24468784),vec4(0.060483426,0.18990822,-0.020213554,0.47014698),vec4(-0.091261275,0.08851764,-0.028107444,0.6299197)) * bufB[6] + mat4(vec4(-0.117545515,-0.025868198,0.23789503,0.37019286),vec4(0.50888836,0.12083939,0.004513383,-0.018193353),vec4(0.04919953,-0.051134996,0.112229735,0.20443602),vec4(-0.16555876,0.38174883,0.2318862,0.11267033)) * bufB[7];\nbufA[3] = vec4(-0.08124984,-0.055906072,0.07544636,-0.007763398) + mat4(vec4(-0.0099631045,0.06949586,0.16665418,-0.5032622),vec4(0.09768833,0.2308679,-0.1410091,-0.20305128),vec4(-0.38302675,0.15369198,0.24295689,-0.17497198),vec4(0.13791957,-0.059046462,-0.12466715,-0.23011798)) * bufB[0] + mat4(vec4(-0.39871028,-0.09665398,0.37181634,0.049350448),vec4(-0.2371592,0.25458577,0.33887464,-0.17065538),vec4(0.2968954,-0.14469136,-0.5492235,0.13087815),vec4(0.048004564,-0.16400783,0.033715572,-0.071483344)) * bufB[1] + mat4(vec4(-0.32544112,0.40765098,0.2155276,0.13822837),vec4(-0.37557727,0.14673199,0.32286665,-0.0035225498),vec4(0.16657835,-0.47874027,-0.18362057,0.6542411),vec4(0.12154856,0.39515105,-0.3188827,0.39030698)) * bufB[2] + mat4(vec4(0.080835775,-0.28742346,0.2610799,0.59830797),vec4(-0.21891648,0.23070689,0.48359522,-0.09025431),vec4(0.046844922,0.30233613,0.055634696,0.16338962),vec4(-0.32151932,-0.31545812,0.30703047,-0.23595949)) * bufB[3] + mat4(vec4(-0.00079377287,-0.14823408,0.07771782,-0.19196689),vec4(-0.3481196,0.3260803,0.32298735,-0.26501083),vec4(0.14742719,0.15969937,-0.10767669,-0.14775178),vec4(-0.14278051,0.021655057,0.14831997,-0.09404377)) * bufB[4] + mat4(vec4(-0.073266,-0.25332886,-0.11494226,-0.23117048),vec4(0.4037155,-0.107688114,-0.3311602,-0.37919644),vec4(-0.13447471,-0.7344687,0.38025153,-0.37645483),vec4(-0.0065407814,-0.048900273,-0.123870775,0.27734122)) * bufB[5] + mat4(vec4(-0.100599304,-0.1579135,-0.30404583,-0.20491675),vec4(-0.1844966,-0.050315276,0.28054413,-0.22333995),vec4(-0.02763808,0.08984614,0.17985648,0.4226694),vec4(0.5800526,0.42415616,-0.24759136,0.61097586)) * bufB[6] + mat4(vec4(-0.07740162,-0.15221961,0.20084657,0.023429839),vec4(-0.44233376,0.23153673,0.060016476,0.038170293),vec4(0.063232936,0.6564741,-0.06473889,0.5059796),vec4(-0.19703048,-0.03035563,0.27782753,0.47055003)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.09434308111667633,0.0497264564037323,-0.1371731013059616,0.0) + mat4(vec4(-0.11588159203529358,-0.23272757232189178,-0.15619763731956482,0.0),vec4(-0.352074533700943,-0.3233867287635803,-0.30261173844337463,0.0),vec4(-0.022156361490488052,0.0017781760543584824,0.09282662719488144,0.0),vec4(0.028449108824133873,-0.006726493127644062,-0.07546474039554596,0.0)) * bufB[0] + mat4(vec4(0.14149396121501923,0.22419056296348572,-0.23537421226501465,0.0),vec4(-0.06886552274227142,-0.1533975750207901,-0.05294659733772278,0.0),vec4(-0.01370984222739935,-0.06295962631702423,0.13145436346530914,0.0),vec4(-0.1677694320678711,-0.1330019235610962,-0.25664231181144714,0.0)) * bufB[1] + mat4(vec4(0.038798507302999496,0.044030968099832535,0.045872125774621964,0.0),vec4(-0.12149263918399811,0.19545650482177734,-0.15795235335826874,0.0),vec4(-0.07070725411176682,-0.09371525794267654,-0.1781398504972458,0.0),vec4(-0.28821611404418945,-0.3589743673801422,-0.15115401148796082,0.0)) * bufB[2] + mat4(vec4(-0.12702612578868866,-0.003341980744153261,0.17099131643772125,0.0),vec4(-0.15383177995681763,-0.1496926099061966,-0.26108741760253906,0.0),vec4(0.2693166434764862,0.08106687664985657,-0.19946801662445068,0.0),vec4(-0.11212553083896637,-0.01362596731632948,-0.1973170042037964,0.0)) * bufB[3] + mat4(vec4(-0.029221253469586372,-0.05586677044630051,0.07633066177368164,0.0),vec4(-0.010472191497683525,-0.054875973612070084,-0.07564079016447067,0.0),vec4(0.02571520023047924,0.04623362794518471,-0.1738329827785492,0.0),vec4(0.2929246723651886,0.46773406863212585,0.30930060148239136,0.0)) * bufB[4] + mat4(vec4(0.21854709088802338,0.047922588884830475,-0.023359661921858788,0.0),vec4(0.332742840051651,0.406627893447876,0.5051886439323425,0.0),vec4(0.06439870595932007,0.030425947159528732,-0.01923348754644394,0.0),vec4(0.06635231524705887,0.08262679725885391,0.17895933985710144,0.0)) * bufB[5] + mat4(vec4(-0.41410282254219055,-0.28186824917793274,-0.5343008637428284,0.0),vec4(0.012581834569573402,-0.16600698232650757,-0.15867914259433746,0.0),vec4(0.062151797115802765,0.02798880636692047,0.2262849509716034,0.0),vec4(-0.29458579421043396,-0.40009650588035583,-0.31507381796836853,0.0)) * bufB[6] + mat4(vec4(0.06179565563797951,-0.05449203774333,-0.18274325132369995,0.0),vec4(-0.17378494143486023,-0.24309781193733215,-0.22442875802516937,0.0),vec4(0.07781253010034561,-0.12984102964401245,-0.3047514855861664,0.0),vec4(-0.3497634828090668,-0.4292391240596771,-0.5344883799552917,0.0)) * bufB[7];\nreturn vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n\n        uv.x *= iResolution.x / iResolution.y;\n        uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(1., -1.) * 2. * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    fragColor = cppn_fn(uv, sin(iTime), sin(2.*iTime), sin(3.*iTime), sin(4.*iTime));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MttfR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 144, 144, 74446], [74448, 74448, 74505, 74555, 74987]], "test": "valid"}
{"id": "MttfRH", "name": "Stage Play", "author": "spookyfox", "description": "stage", "tags": ["stage"], "likes": 2, "viewed": 215, "published": "Public", "date": "1538687197", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float SKY = -1.;\nfloat FLOOR = 0.;\n\nfloat sdPlane(vec3 p, float s, float h) {\n    return s * p.y + h;\n}\n\nfloat sdCylinder(vec3 p) {\n    return length(p.xz - vec2(0, .2)) - .1;\n}\n\nfloat sMin(float a, float b, float k) {\n    // https://www.iquilezles.org/www/articles/smin/smin.htm\n    float h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nvec2 opU(vec2 dm1, vec2 dm2) {\n    // https://www.shadertoy.com/view/Xds3zN\n    return dm1.x < dm2.x ? dm1 : dm2;\n}\n\nvec2 map(vec3 p) {\n    p.x = mod(p.x, 2.0) - 0.5 * 2.0;\n    p.z = mod(p.z, 2.0) - 0.5 * 2.0;\n    vec2 dm;\n    dm = opU(vec2(sdPlane(p, 1., 1.), FLOOR), vec2(sdPlane(p, -1., 1.), FLOOR));\n    dm = vec2(sMin(dm.x, sdCylinder(p), 1.), FLOOR);\n   \treturn dm;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    // Shortest distance and material key.\n    vec2 dm;\n    // Current step size.\n    float s = 0.;\n    for (int i = 0; i < 256; i++) {\n        // Current position in the scene.\n        vec3 p = ro + rd * s;\n        dm = map(p);\n        s += dm.x;\n    }\n    if (dm.x > 0.1) {\n        // Our ray hasn't hit anything.\n        dm.y = SKY;\n    }\n    return vec2(s, dm.y);\n}\n\nvec3 normal(vec3 p) {\n    // Tetrahedron technique\n    // http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n    float h = 0.0001;\n\tvec2 k = vec2(1, -1);\n    return normalize(\n        k.xxx * map(p + k.xxx * h).x +\n        k.xyy * map(p + k.xyy * h).x +\n        k.yxy * map(p + k.yxy * h).x +\n        k.yyx * map(p + k.yyx * h).x);\n}\n\n// General lighting resource: http://www.sunandblackcat.com/tipFullView.php?l=eng&topicid=30\nvec3 light(vec3 ro, vec3 p, vec3 l) {\n\tvec3 n = normal(p);\n    \n    // Material properties (chrome).\n    // https://people.eecs.ku.edu/~jrmiller/Courses/672/InClass/3DLighting/MaterialProperties.html\n    vec3 ka = vec3(.25);\n    vec3 kd = vec3(.4);\n    vec3 ks = vec3(.774597);\n    float es = 76.8; // Larger -> smaller highlight.\n    \n    // Ambient.\n    // https://en.wikipedia.org/wiki/Shading#Ambient_lighting\n    float a = 0.5;\n    \n    // Diffuse.\n    // https://en.wikipedia.org/wiki/Lambertian_reflectance\n    float d = clamp(dot(n, normalize(l - p)), 0., 1.);\n    \n    // Specular.\n    // https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\n    vec3 v = normalize(ro - l);\n    vec3 h = normalize(v + l);\n    float s;\n    if (dot(n, l) > 0.) {\n        // Surface is oriented to the light source.\n        s = pow(clamp(dot(n, h), 0., 1.), es);\n    } else {\n        s = 0.;\n    }\n\n    return a * ka + d * kd + s * ks;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 c;\n    // Render by coloring intersections.\n    vec2 dm = rayMarch(ro, rd);\n    if (dm.y == FLOOR) {\n        // The intersection.\n        vec3 p = ro + rd * dm.x;\n        // The point light.\n        vec3 l = vec3(2, 2, -2);\n        c = light(ro, p, l);   \n    } else {\n        c = vec3(0);\n    }\n    // Gamma correction.\n    return pow(c, vec3(0.4545));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Remap xy to [-1, 1] and correct aspect ratio.\n    vec2 xy = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // z: Start behind the screen.\n\tvec3 ro = vec3(0, 0, iTime);\n    // z: Go through the screen.\n    vec3 rd = normalize(vec3(xy, 1));\n\n    fragColor = vec4(render(ro, rd), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MttfRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 77, 77, 103], [105, 105, 131, 131, 177], [179, 179, 218, 279, 377], [379, 379, 409, 454, 494], [496, 496, 514, 514, 752], [754, 754, 787, 830, 1157], [1159, 1159, 1180, 1277, 1502], [1504, 1597, 1634, 1634, 2534], [2536, 2536, 2567, 2567, 2932], [2934, 2934, 2989, 3042, 3296]], "test": "valid"}
{"id": "MttfW8", "name": "Water Wave sample2", "author": "edo_m18", "description": "Water Wave sample.\n\nI referred this post \"https://www.shadertoy.com/view/Ms2SD1\"\n\nI have commented each functions and expressions.\n\nI have posted an article of this code commentary, but in Japanese.\nhttps://qiita.com/edo_m18/items/a575606a60b21f0d2c57", "tags": ["wave"], "likes": 16, "viewed": 1373, "published": "Public", "date": "1539697288", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * Refer: \"https://www.shadertoy.com/view/Ms2SD1\"\n */\n\nconst int NUM_STEPS = 8;\nconst float PI\t \t= 3.141592;\nconst float EPSILON\t= 1e-3;\n\n#define EPSILON_NRM (0.1 / iResolution.x)\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\n\n// sea\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.1, 0.19, 0.22);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\nconst mat2 octave_m = mat2(1.6, 1.2, -1.2, 1.6);\n\n// Get random value.\nfloat hash(vec2 p)\n{\n\tfloat h = dot(p, vec2(127.1, 311.7));\t\n    return fract(sin(h) * 43758.5453123);\n}\n\n// Get Noise.\nfloat noise(in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    // u = -2.0f^3 + 3.0f^2\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n    \n    // Get each grid vertices.\n    // +---+---+\n    // | a | b |\n    // +---+---+\n    // | c | d |\n    // +---+---+\n    float a = hash(i + vec2(0.0,0.0));\n    float b = hash(i + vec2(1.0,0.0));\n    float c = hash(i + vec2(0.0,1.0));\n    float d = hash(i + vec2(1.0,1.0));\n    \n    // Interpolate grid parameters with x and y.\n    float result = mix(mix(a, b, u.x),\n                        mix(c, d, u.x), u.y);\n    \n    // Normalized to '-1 - 1'.\n    return (2.0 * result) - 1.0;\n}\n\n// lighting\nfloat diffuse(vec3 n, vec3 l, float p)\n{\n    return pow(dot(n, l) * 0.4 + 0.6, p);\n}\n\nfloat specular(vec3 n, vec3 l, vec3 e, float s)\n{\n    float nrm = (s + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(e, n), l), 0.0), s) * nrm;\n}\n\n// Get sky color by 'eye' position.\n// So, The color changed smoothly by eye level.\nvec3 getSkyColor(vec3 e)\n{\n    e.y = max(e.y, 0.0);\n    float r = pow(1.0 - e.y, 2.0);\n    float g = 1.0 - e.y;\n    float b = 0.6 + (1.0 - e.y) * 0.4;\n    return vec3(r, g, b);\n}\n\n// Get sea wave octave.\nfloat sea_octave(vec2 uv, float choppy)\n{\n    uv += noise(uv);        \n    vec2 wv = 1.0 - abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv, swv, wv);\n    return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);\n}\n\n// p is ray position.\nfloat map(vec3 p)\n{\n    float freq = SEA_FREQ; // => 0.16\n    float amp = SEA_HEIGHT; // => 0.6\n    float choppy = SEA_CHOPPY; // => 4.0\n    \n    // XZ plane.\n    vec2 uv = p.xz;\n    \n    float d, h = 0.0;    \n    \n    // ITER_GEOMETRY => 3\n    for (int i = 0; i < ITER_GEOMETRY; i++)\n    {       \n    \td = sea_octave((uv + SEA_TIME) * freq, choppy);\n    \td += sea_octave((uv - SEA_TIME) * freq, choppy);\n        h += d * amp;\n    \tuv *= octave_m;\n        freq *= 2.0;\n        amp *= 0.2;\n        choppy = mix(choppy, 1.0, 0.2);\n    }\n    \n    return p.y - h;\n}\n\n// p is ray position.\n// This function calculate detail map with more iteration count.\nfloat map_detailed(vec3 p)\n{\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    \n    vec2 uv = p.xz;\n    \n    float d, h = 0.0;\n    \n    // ITER_FRAGMENT = 5\n    for (int i = 0; i < ITER_FRAGMENT; i++)\n    {        \n    \td = sea_octave((uv + SEA_TIME) * freq, choppy);\n    \td += sea_octave((uv - SEA_TIME) * freq, choppy);\n        h += d * amp;        \n    \tuv *= octave_m;\n        freq *= 2.0;\n        amp *= 0.2;\n        choppy = mix(choppy, 1.0, 0.2);\n    }\n    \n    return p.y - h;\n}\n\n// p = ray position\n// n = surface normal\n// l = light\n// eye = eye\n// dist = ray marching distance\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist)\n{\n    float fresnel = clamp(1.0 - dot(n, -eye), 0.0, 1.0);\n    fresnel = pow(fresnel, 3.0) * 0.65;\n        \n    vec3 reflected = getSkyColor(reflect(eye, n));    \n    vec3 refracted = SEA_BASE + diffuse(n, l, 80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted, reflected, fresnel);\n    \n    float atten = max(1.0 - dot(dist, dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    color += vec3(specular(n, l, eye,60.0));\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps)\n{\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x + eps, p.y, p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x, p.y, p.z + eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\n// Get Height Map\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p)\n{\n    float tm = 0.0;\n    \n    float tx = 1000.0;\n    \n    // Calculate 1000m far distance map.\n    float hx = map(ori + dir * tx);\n    \n    // if hx over 0.0 is that ray on the sky. right?\n    if(hx > 0.0)\n    {\n        p = vec3(0.0);\n        return tx;   \n    }\n    \n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    \n    // NUM_STEPS = 8\n    for (int i = 0; i < NUM_STEPS; i++)\n    {\n        // Calculate weight for 'tm' and 'tx' mixing.\n        float f = hm / (hm - hx);\n        \n        tmid = mix(tm, tx, f);                   \n        p = ori + dir * tmid;\n        \n    \tfloat hmid = map(p);\n        \n\t\tif (hmid < 0.0)\n        {\n        \ttx = tmid;\n            hx = hmid;\n        }\n        else\n        {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    \n    return tmid;\n}\n\n// main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n \n    const vec3 light = normalize(vec3(0.0, 1.0, 0.8)); \n    \n    // ray \n    vec3 ori = vec3(0.0, 3.5, 5.0);\n    vec3 dir = normalize(vec3(uv.xy, -2.0));\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori, dir, p);\n    \n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist, dist) * EPSILON_NRM);\n    \n    // color\n    vec3 sky = getSkyColor(dir);\n    vec3 sea = getSeaColor(p, n, light, dir, dist);\n    \n    // This is coefficient for smooth blending sky and sea.\n    float t = pow(smoothstep(0.0, -0.05, dir.y), 0.3);\n    vec3 color = mix(sky, sea, t);\n    \n    // post\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MttfW8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[694, 715, 735, 735, 819], [821, 835, 859, 859, 1460], [1462, 1474, 1514, 1514, 1558], [1560, 1560, 1609, 1609, 1709], [1711, 1795, 1821, 1821, 1973], [1975, 1999, 2040, 2040, 2219], [2221, 2243, 2262, 2262, 2804], [2806, 2893, 2921, 2921, 3419], [3421, 3521, 3584, 3584, 4087], [4089, 4100, 4135, 4135, 4334], [4336, 4354, 4410, 4410, 5222], [5224, 5232, 5287, 5287, 5976]], "test": "valid"}
{"id": "Mttfzl", "name": "Square weave", "author": "saidwho12", "description": "This is just a simple weave shader I made as a test.", "tags": ["2d", "square", "colored", "weave"], "likes": 7, "viewed": 155, "published": "Public", "date": "1540825880", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// by FabriceNeyret2 - 297 chars\nvoid mainImage(out vec4 O, vec2 U) \n{\n    vec2 R = iResolution.xy,\n         p =  ( 2.*U - R) / R.y\n             * mat2(cos( .6*sin(iTime * 1.26)  + vec4(0,33,11,0))); // https://www.shadertoy.com/view/XlsyWX \n\n    p.y -= .5*iTime;\n    p = fract(p)*2.-1.;\n     \n    vec4 t = abs( p.xyxy - .5*vec4(1,1,-1,-1) ) -.2,\n         C = vec4(.95, .5,  .5 , 0);        // base color\n    \n    O = mat4( C, C.yxyw, C.yyxw, C.xyxw )   // colors = swap of base RGB\n        * (   clamp(-300.*t, 0.,1.)                // mask\n            * clamp( 1. - exp(-15.*t.yzwx), 0.,1.) // shadow\n          );\n}\n\n/*\n#define saturate(x) clamp(x,0.0,1.0)\n#define mainImage(O,u)\\\n    vec2 p = fract(u/100.)*2.-1.;\\\n    \\\n    mat4 c = mat4( .95, .5,  .5 , 0,\\\n                     .5,  .95, .5 , 0,\\\n                     .5,  .5,  .95, 0,\\\n                     .95, .5,  .95, 0);\\\n    \\\n    vec4 t = abs( p.xyxy - .5*vec4(1,1,-1,-1) ) - .2,\\\n      m = saturate(-t*1e2),\\\n      s = 1. - saturate(exp(-15.*t.yzwx));\\\n    m *= s;\\\n    O = c * m;\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mttfzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 33, 70, 70, 617]], "test": "error"}
{"id": "MttfzS", "name": "Sphere Voronoi", "author": "cfrezksa", "description": "Mainly based on iq's Voronoi tessellation https://www.shadertoy.com/view/ldl3W8\n\nmapped to a sphere.\n\nUse mouse to rotate.", "tags": ["3d", "voronoi"], "likes": 10, "viewed": 526, "published": "Public API", "date": "1540132812", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.1415926\n#define ANIMATE\n\nvec2 scale=vec2(32.0,64.0);\n\n// sphere of size ra centered at point ce\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h < 0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec2 perturb(vec2 o) {\n    //return 0.5 + 0.5*sin( iTime + 6.2831*o );   \n    return  0.5+0.5*o*vec2(sin(2.0*iTime+6.2831*o.x), cos(2.0*iTime+6.2831*o.x));\n\n}\n\nvec2 mg;\nvec2 mo;\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( mod(n + g,scale) );\n\t\t#ifdef ANIMATE\n        o = perturb(o);//0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n            mo = o;\n        }\n    }\n\n   \n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( mod(n + g,scale)  );\n\t\t#ifdef ANIMATE\n        o = perturb(o);\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\t\n    return vec3( md, mr );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\t{\n        \n        \n\tvec2 position=(fragCoord.xy/iResolution.xy);\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    //float s = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n    //if( iMouse.z<0.001 ) s=0.0;\n    \n\tvec3 ro = vec3(0.0, 0.0, 4.0 );\n\tvec3 rd = normalize( vec3(p,-2.0) );\n\t        \n    vec2 sphere = sphIntersect(ro, rd, vec3(0.0), 1.5);\n        if (sphere.x < 0.0) {\n         fragColor=vec4(0.5); return;   \n        }\n        \n    vec3 q = ro + sphere.x * rd;\n    vec3 n = -normalize(q);\n        \n    float r = length(n);\n    float theta = acos(n.y/r) / PI;\n    float phi   = (atan(n.z,n.x) / PI + 1.0)/2.0;\n    phi = fract(phi + iMouse.x/iResolution.x);    \n    theta = fract(theta + (1.0-iMouse.y/iResolution.y));\n\n        \n    vec2 x = vec2(theta, phi);\n    vec3 c = voronoi(scale * x);\n\n\tfloat dd = length( c.yz );\n\t// isolines\n    vec3 col = mo.xyx;//vec3(0.2,0.4, 0.6);\n    // borders\t\n    col = mix( vec3(0.0), col, smoothstep( 0.0, 0.1, c.x ) );\n    // feature points\n        \n\t//col = mix( vec3(1.0,0.6,0.1), col, smoothstep( 0.0, 0.12, dd) );\n\t//col += vec3(0.0,0.6,0.1)*(smoothstep( 0.0, 0.04, dd));\n    //col = vec3(dd);\n\n    //vec2 tint = hash2(floor(scale*x));\n    //col = 0.5 * col + 0.5 * vec3(tint, 1);   \n    //col = vec3(x, tint.x);\n\n\tfragColor = dot(n,rd) * vec4(col,1.0);\n        \n    //fragColor = vec4(x, r, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MttfzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 110, 177, 177, 397], [399, 399, 421, 452, 542], [544, 544, 566, 617, 702], [723, 723, 750, 750, 1883], [1886, 1886, 1944, 1944, 3314]], "test": "valid"}
{"id": "XdKfRV", "name": "Ahziel - Multicolor sin waves", "author": "Ahziel", "description": "Journey through the \"Book of shader\" - Functions\nI do shaders to learn and have fun. If you have any advice, don't hesitate to tell me ! ", "tags": ["graph"], "likes": 1, "viewed": 145, "published": "Public", "date": "1539617772", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWO_PI 6.28318530718\n\nfloat plotX(vec2 st, float pct){\n  return  smoothstep( pct-0.01, pct, st.y) -\n          smoothstep( pct, pct+0.01, st.y);\n}\n\nfloat plotY(vec2 st, float pct){\n  return  smoothstep( pct-0.01, pct, st.x) -\n          smoothstep( pct, pct+0.01, st.x);\n}\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat wave(in vec2 st, in float freq, bool isVertical, bool isLfromR)\n{\n    float coord;\n    coord = st.y * float(isVertical) + (1.0 - float(isVertical)) * st.x;\n    float amplitude = 1.0 - coord;\n    \n    float pct;\n    \n    if(isLfromR)\n    {\n        pct = cos((coord + iTime) * freq) / 2.0 + 0.5;\n    \tpct = 0.5 * coord + pct * amplitude ;\n    }\n    else\n    {\n        pct = -cos((amplitude + iTime) * freq) / 2.0 + 0.5;\n    \tpct = 0.5 * amplitude + pct * coord ;\n    }\n    \n    float pos = plotY(st, pct) * float(isVertical) + (1.0 - float(isVertical)) * plotX(st, pct);\n    return pos;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n    \n    float freq = 0.1;\n    \n    vec2 toCenter = vec2(0.5)-st;\n    float angle = atan(toCenter.y,toCenter.x);\n    float radius = length(toCenter)*2.0;\n\n    vec3 color = hsb2rgb(vec3((angle/TWO_PI)+0.5,radius,1.0));    \n    \n    float waves;\n    const float size = 10.0;\n    \n    for(float i = 0.0; i < size; i++)\n    {\n\t\twaves = waves + wave(st,freq * float(i),false,false);\n\t\twaves = waves + wave(st,freq * float(i),false,true);\n\t\twaves = waves + wave(st,freq * float(i),true,false);\n\t\twaves = waves + wave(st,freq * float(i),true,true);\n    }\n    \n    \n    vec3 res;\n    res = res + vec3(waves) * color;\n\n    // Output to screen\n    fragColor = vec4(res,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdKfRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 62, 62, 153], [155, 155, 187, 187, 278], [280, 280, 306, 306, 539], [541, 541, 612, 612, 1133], [1136, 1136, 1193, 1193, 1900]], "test": "valid"}
{"id": "Xl3fDB", "name": "shortest quadtree (170ch)", "author": "FabriceNeyret2", "description": " simplied variant of [url]https://shadertoy.com/view/Xt3fDB[/url]\ngolfed variant of [url]https://shadertoy.com/view/lljSDy[/url]", "tags": ["2tweets", "short", "quadtree", "golf"], "likes": 8, "viewed": 457, "published": "Public API", "date": "1540807589", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// simplied variant of https://shadertoy.com/view/Xt3fDB\n// golfed variant of https://shadertoy.com/view/lljSDy\n\nvoid mainImage(out vec4 O, vec2 u) {\n\n    vec2 U =  u/iResolution.y, f,\n         P = .5+.5* vec2(cos(iTime),sin(iTime*.7));\n    for ( float r = 1.; r > .01; r /= 2. )\n         length(P-r) - .2 < 1.4*r\n          ?   U -= f = step(r,U)*r,\n        \t  P -= f,\n        \t  O.rg += f/r*.2\n          : f; }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3fDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 149, 149, 411]], "test": "valid"}
{"id": "Xl3fWr", "name": "Cosmic scene", "author": "Thominator", "description": "This is the result of a practical lesson on implicit surfaces. \n\nThe base of the code was provided by Eric Galin.\n\nThis is great", "tags": ["space", "planet", "asteroids", "implicitsurfaces"], "likes": 10, "viewed": 227, "published": "Public", "date": "1540999439", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int Steps = 750;\nconst float Epsilon = 0.005; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\n// Matrix for fractal noise\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n//Usefull for asteroid belt rotations\nvec3 rotateU(vec3 p, vec3 u, float a)\n{\t\n  \tfloat sa = sin(a);\n  \tfloat ca = cos(a);\n    float f1 = u.x*u.y*(1.0-ca); \n    float f2 = u.x*u.z*(1.0-ca);\n    float f3 = u.y*u.z*(1.0-ca);\n    float nx = (ca+u.x*u.x*(1.0-ca))*p.x + \n        (f1-u.z*sa)*p.y +\n        (f2+u.y*sa)*p.z;\n    \n    float ny = (f1+u.z*sa)*p.x + \n        (ca+u.y*u.y*(1.0-ca))*p.y +\n        (f3-u.x*sa)*p.z;\n    \n    float nz = (f2-u.y*sa)*p.x +\n        (f3+u.x*sa)*p.y +\n        (ca+u.z*u.z*(1.0-ca))*p.z;\n    \n    return vec3(nx, ny, nz);\n}\n\n//2D Noise function from user iq\nfloat hash(vec2 p)\n{\n    p  = 45.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n//3D Noise function from user iq\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Value of the lambda aka Liptschitz constant\n// e : energy associated to the primitive\n// R : radius associated to the primitive\nfloat lambda(float e, float R){\n    // maximum of the falloff function derivative\n    const float lambda_zero = 96. / (25. * sqrt(5.));\n    \n    return e * lambda_zero / R;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\n// lam : pseudo-calculated lambda\nfloat point(vec3 p, vec3 c, \n            float e,float R, out float lam)\n{\n  lam = lambda(e, R)/dot(p-c, p-c);\n  return e*falloff(length(p-c),R);\n}\n\n// Calculate the distance of a point to a segment\n// p : point\n// a : starting point of the segment\n// b : ending point of the segment\nfloat distSegment(vec3 p, vec3 a, vec3 b)\n{\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    float L = length(ab);\n    float d = dot(ap, ab)/(dot(ab,ab));\n    if (d < 0.0)\n    {\n        return length(p-a);\n    }\n    if (d > 1.0)\n    {\n        return length(p-b);\n    }\n    else\n    {\n        vec3 pp = a + d*ab;\n    \treturn length(p-pp);\n    } \n}\n\n// Segment\n// p : point\n// a : starting point of the segment\n// b : ending point of the segment\n// e : energy associated to skeleton\n// R : large radius\n// lam : pseudo-calculated lambda\nfloat Segment(vec3 p, vec3 a, vec3 b, \n              float e, float R, out float lam)\n{\n    float dist = distSegment(p, a, b);\n    lam = lambda(e, R)/dist;\n    return e*falloff(dist, R);\n}\n\n// Circle\n// p : point\n// c : center of the circle\n// r : radius of the circle\n// n : orientation of the circle\n// e : energy associated to skeleton\n// R : large radius\n// lam : pseudo-calculated lambda\nfloat Circle(vec3 p, vec3 c, float r, vec3 n, \n             float e, float R, out float lam)\n{\t\n    vec3 cp = c-p;\n    float l = dot(n, cp);\n    float h = sqrt(dot(cp, cp) - l*l);\n    float hcr = h-r;\n    float dist = sqrt(hcr*hcr+l*l);\n    lam = lambda(e, R)/dist;\n    return e*falloff(dist, R);\n}\n\n// Non regular circle\n// p : point\n// c : center of the circle\n// r : radius of the circle\n// n : orientation of the circle\n// f : flatening agent\n// e : energy associated to skeleton\n// R : large radius\n// lam : pseudo-calculated lambda\nfloat FlatCircle(vec3 p, vec3 c, float r, vec3 n, float f, \n                 float e, float R, out float lam)\n{\t\n    vec3 cp = p-c;\n    float l = dot(n, cp);\n    float h = sqrt(dot(cp, cp) - l*l);\n    float hcr = h-r;\n    float d = sqrt(hcr*hcr+l*l*f*f);\n    float la = lambda(e, R);\n    \n    //For death ray\n    //lam = la*f/h;\n    //Normal lambda calculation\n    //lam = la*f/d;\n    //Optimized optimisation\n    lam = 0.5*la*f/d;\n    return e*falloff(d, R);\n}\n \n// Asteroids : fractal noise\n// tp  : point\n// d   : density of the field\n// len : distance of the point to the field\n// R   : large radius\nfloat Asteroids(vec3 tp, float d, float len, float R)\n{\n    float noi = 0.0;\n    //If we are close nough to care about the asteroïds\n    if(len < R){\n    \tvec3 q = 3.0*tp;//vec3(x, y, z);\n    \tnoi  = 0.5000*noise( q ); q = m3*q*2.01;\n    \tnoi += 0.2500*noise( q ); q = m3*q*2.02;\n    \tnoi += 0.1250*noise( q ); q = m3*q*2.03;\n        \n        //Second noise calculation : clumpy uneven results\n        /*\n        q = vec3(noi*tp.x, noi*tp.y, noi*tp.z);\n    \tnoi  = 1.0000*noise( q ); q = m3*q*2.01;\n    \tnoi += 0.25000*noise( q ); q = m3*q*2.02;\n    \t//*/\n    }\n    \n    //density factor\n    float sc = 1.0/d;\n    //distance to the asteroids\n    return sc*noi;\n}\n\n// Asteroid field\n// p : point\n// c : center of field\n// r : radius of the field\n// d : density of the field\n// e : energy associated to skeleton\n// R : large radius\n// lam : pseudo-calculated lambda\nfloat Asterofield(vec3 p, vec3 c, float r, float d, \n                  float e,float R, out float lam)\n{\n    // Distance to the center\n    vec3 cp = p-c;\n    // Distance to the shell\n    float len = length(cp)-r;\n    \n    // The distance calculated for the asteroids (distances are squared)\n    float afact = Asteroids(cp, d, len*len, R*R);\n    \n    // General distance\n    // \"Proper\" way, disturbing the distance with a noise\n    //float dist = sqrt(len*len)+afact;\n    // \"Wtf way, disturbing the distance calculation in itself\n    float dist = sqrt(len*len+afact*afact);\n    \n    // If we are near the asteroids we need more precisions\n    float l = lambda(e, R);\n    if (afact > 0.0)\n        // Very specific, dangerous\n        //lam = 4.0*l/(dist*dist);\n        //Usual\n        lam = 4.0*l/dist;\n    else\n        lam = l/dist;\n    return e*falloff(dist, R);\n}\n\n// Asteroid belt\n// p : point\n// c : center of belt\n// r : radius of the belt\n// n : orientation of the belt\n// d : density of the belt\n// f : flatness of the belt\n// e : energy associated to skeleton\n// R : large radius\n// lam : pseudo-calculated lambda\nfloat Asteroidbelt(vec3 p, vec3 c, float r, vec3 n, float d, float f, \n                   float e, float R, out float lam)\n{\n    // Distance to the center of the circle\n    vec3 cp = p-c;\n    //Comment to prevent the belt from rotating\n    cp = rotateU(cp, n, 0.5*iTime);\n    // Distance to the circle \n    float l = dot(n, cp);\n    float h = sqrt(dot(cp, cp) - l*l);\n    float hcr = h-r;\n    \n    // The distance calculated for the asteroids (distances are squared)\n    float afact = Asteroids(cp, d, hcr*hcr+l*l, R*R);\n    \n    //General distance\n    // \"Proper\" way, disturbing the distance with a noise\n    //float dist = sqrt(hcr*hcr+l*l*f*f)+afact;\n    // Better results if afact is added in the square root\n    float dist = sqrt(hcr*hcr+l*l*f*f+afact*afact);\n    float la = lambda(e, R);\n    \n    // If we are near the asteroids we need more precisions\n    if (afact > 0.0)\n        // Very specific, dangerous\n        //lam = 5.0*la*f/(dist*dist);\n        // usual\n        lam = 4.0*la*f/dist;\n    else\n        lam = la*f/dist;\n    \n    return e*falloff(dist, R);\n}\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n\n// Intersection\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Intersection(float a,float b)\n{\n    return min(a,b);\n}\n\n// Substraction\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Substraction(float a,float b)\n{\n    return min(a, 2.0*T-b);\n}\n\n\n//OBJECTS\n//AsteroStar\nfloat AsteroStar(vec3 p, out float lam)\n{\n    float lam2 = 0.0;\n    float v = Asterofield(p, vec3( 0.0, 0.0, 0.0), 3.0*abs(cos(0.10*iTime)), 0.4, \n                          1.0, 1.3, lam);\n    v = Blend(v, point(p,vec3(0.0, 0.0,0.0),1.0*abs(sin(0.10*iTime)),3.5, lam2));\n    lam = max(lam, lam2);\n    return v;\n}\n\n//MegaBelt\nfloat MegaBelt(vec3 p, out float lam)\n{\n    float lam2 = 0.0;\n    float v = Asteroidbelt(p, vec3(0.0, 0.0, 0.0), 5.5, normalize(vec3(0.0, .71, .71)), \n                              0.3, 3.0, 1.0, 2.0, lam);\n    v = Blend(v, point(p,vec3(5.0, -2.0,2.0),1.0,1.5, lam2));\n    lam = max(lam, lam2);\n    return v;\n}\n\n//Saturn\nfloat Saturn(vec3 p, out float lam)\n{\n    float lam2 = 0.0;\n    float v = point(p,vec3(-7.0, 2.0,2.0),1.0,2.5, lam);\n    v = Blend(v, FlatCircle(p, vec3(-7.0, 2.0,2.0), 2.0, normalize(vec3(1.0, 0.8, 0.0)), \n                           17.5, 1.0, 0.8, lam2));\n    lam = max(lam, lam2);\n    return v;\n}\n\n//Loner\nfloat Loner(vec3 p, out float lam)\n{\n    float lam2;\n    float v = point(p,vec3(5.0,-2.5,-10.0),1.0,1.5, lam);\n    v = Blend(v, Asteroidbelt(p, vec3(5.0,-2.5,-10.0), 1.5, normalize(vec3(0.71, 0.71, 0.0)), \n                              0.3, 1.0, 1.0, 1.3, lam2));\n    lam = max(lam, lam2);\n    return v;\n}\n\n//Binary planets\nfloat Binary(vec3 p, out float lam)\n{\n    float lam2 = 0.0;\n    float v = point(p,vec3(7.0, 0.0,6.0),1.0,1.5, lam);\n    v = Blend(v,point(p,vec3(7.0, 1.0,4.0),1.0,1.5, lam2));\n    lam = max(lam, lam2);\n    v = Blend(v,Asteroidbelt(p, vec3(7.0, 1.0, 4.0), 1.5, normalize(vec3(-0.19, .98, 0.0)), \n                              0.4, 1.0, 1.0, 1.3, lam2));    \n    lam = max(lam, lam2);\n    return v;\n}\n\n//Blob\nfloat Blob(vec3 p, out float lam)\n{\n    float lam2 = 0.0;\n    float v = point(p,vec3(0.0, 5.0,-1.0),1.0,1.5, lam);\n    v = Blend(v, point(p,vec3(0.0, 5.5,-1.0),0.8,0.5, lam2));\n    lam = max(lam, lam2);\n    v = Blend(v, point(p,vec3(0.0, 5.2,-2.0),0.8,0.5, lam2));\n    lam = max(lam, lam2);\n    return v;\n}\n\n//Scene\nfloat Scene(vec3 p, out float lam)\n{\n    float lam2;\n\tfloat v_astar = AsteroStar(p, lam);\n    float v_abelt = MegaBelt(p, lam2);\n    lam = max(lam, lam2);\n    float v_saturn = Saturn(p, lam2);\n    lam = max(lam, lam2);\n    float v_loner = Loner(p, lam2);\n    lam = max(lam, lam2);\n    float v_binary = Binary(p, lam2);\n    lam = max(lam, lam2);\n    float v_blob = Blob(p, lam2);\n    lam = max(lam, lam2);\n    \n    float v = Union(v_astar, v_abelt);\n    v = Union(v, v_saturn);\n    v = Union(v, v_loner);\n    v = Union(v, v_binary);\n    v = Union(v, v_blob);\n    return v;\n}\n\n// Potential field of the object\n// p : point\n// lam : pseudo-calculated lambda\nfloat object(vec3 p, out float lam)\n{\n  p.z=-p.z;\n    lam = 1.0;\n    //Circle\n  \t//float v = Circle(p, vec3(0.0, 0.0, 0.0), 4.0, normalize(vec3(0.0, .71, .71)), 1.0, 1.8, lam);\n    //FlatCircle\n  \t//float v = FlatCircle(p, vec3(0.0, 0.0, 0.0), 4.0, normalize(vec3(0.0, 0.0, 1.0)), 10.0, 1.0, 1.4, lam);\n    //Segment\n  \t//float v = Segment(p, vec3(-1.0, -2.0, -3.0), vec3(1.0, 1.0, -3.0), 1.0, 3.0, lam);\n    //AsteroidField\n    //float v = Asterofield(p, vec3( 0.0, 0.0, 0.0), 3.0, 0.4, 1.0, 1.3, lam);\n    //AsteroidBelt\n    /*float v = Asteroidbelt(p, vec3(0.0,0.0,0.0), 3.5, normalize(vec3(0.71, 0.71, 0.0)), \n                              0.4, 4.0, 1.0, 2.0, lam);//*/\n    //Scene\n\tfloat v = Scene(p, lam);\n    return v-T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  float l;\n  float v = object(p, l);\n  n.x = object( vec3(p.x+eps, p.y, p.z), l ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z), l ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps), l ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n    float l;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p, l);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s, out float lam)\n{\n  h = false;\n\tlam = 1.0;\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\tfloat l;\n    \n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p, l);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          lam = l;\n          break;\n      }\n      // Move along ray\n      //t += max(Epsilon,abs(v)/4.0);\n      // Move along the ray but faster\n      t += max(Epsilon,abs(v)/l);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n    //return vec3(0, 0, 0);\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  //const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightPos = vec3(0.0, 0.0, 0.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.25*background(-n);\n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(-n, l));\n\n  c += diff*lightColor;\n  \n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n    return vec3(3.*t, t, 3.*t);\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\t//pixel*=2.0;\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 25.0);\n\n  // vec2 mouse = iMouse.xy / iResolution.xy;\n  float a=3.14;\n  // Uncomment to have the scene rotation\n  a=iTime*0.25;\n  ro = rotateY(ro, a);\n  rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n  float lam;\n  float t = SphereTrace(ro, rd, hit,s, lam);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n    // Shade object with \"lambda\"\n    // rgb = vec3(1.0/lam, 1.0/lam, 1.0/lam);\n  }\n  else\n  {\n      float star = rand(pixel);  \n      if(star > 0.9985)\n          rgb = vec3(1, 1, 1);\n      else\n          rgb = vec3(0, 0, 0);\n  }\n\n  // Add step shading to have a cool dusty effect\n  rgb += ShadeSteps(s);\n    \n  fragColor=vec4(rgb, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3fWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[365, 379, 410, 410, 508], [510, 510, 541, 541, 640], [642, 642, 673, 673, 772], [774, 812, 851, 851, 1326], [1328, 1361, 1381, 1381, 1485], [1487, 1487, 1513, 1513, 1807], [1809, 1842, 1862, 1862, 1957], [1959, 1959, 1985, 1985, 2459], [2461, 2528, 2563, 2563, 2636], [2638, 2769, 2800, 2850, 2943], [2969, 3117, 3191, 3191, 3264], [3266, 3401, 3444, 3444, 3740], [3742, 3929, 4016, 4016, 4117], [4119, 4322, 4416, 4416, 4620], [4622, 4860, 4971, 4971, 5321], [5324, 5464, 5519, 5519, 6127], [6129, 6329, 6433, 6463, 7194], [7196, 7451, 7575, 7619, 8523], [8525, 8616, 8646, 8646, 8664], [8666, 8754, 8784, 8784, 8807], [8809, 8904, 8941, 8941, 8964], [8966, 9061, 9098, 9098, 9128], [9131, 9154, 9195, 9195, 9466], [9468, 9479, 9518, 9518, 9789], [9791, 9800, 9837, 9837, 10099], [10101, 10109, 10145, 10145, 10414], [10416, 10433, 10470, 10470, 10831], [10833, 10840, 10875, 10875, 11146], [11148, 11156, 11192, 11192, 11729], [11731, 11811, 11848, 11848, 12540], [12542, 12582, 12613, 12613, 12856], [12858, 12963, 13014, 13014, 13464], [13466, 13571, 13643, 13643, 14216], [14218, 14238, 14264, 14292, 14364], [14366, 14427, 14455, 14519, 14840], [15014, 15014, 15034, 15034, 15106], [15108, 15108, 15165, 15165, 16235]], "test": "valid"}
{"id": "Xl3fzX", "name": "Hilbert curve", "author": "a0a", "description": "My first shader toy: a space filling Hilbert curve (or at least a part of it)\n\nCode is far from optimal; I brute-forced the segments, and I'm not quite sure how to repeat and rotate each block, or even solve the recursion. \n\nThoughts & comments welcome!", "tags": ["hilbertspacefillingcurve"], "likes": 7, "viewed": 244, "published": "Public", "date": "1540380333", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Info on Hilbert curves: http://mathworld.wolfram.com/HilbertCurve.html\n// https://arxiv.org/pdf/1109.2323.pdf\n// \n// Inspiration from https://www.shadertoy.com/view/XtjXW3\n\n\n#define AA 1   // make this 1 is your machine is too slow\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = (p-a), ba = (b-a);\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRotXZ(vec3 p)\n{\t\n    float angle = 3.1415/2.0;\n\treturn vec3(cos(angle) * p.x + sin(angle) * p.z, p.y, -sin(angle) * p.x + cos(angle) * p.z);\n}\n\nvec3 opRotYZ(vec3 p)\n{\t\n    float angle = 3.1415/2.0;\n\treturn vec3(p.x,cos(angle) * p.y + sin(angle) * p.z, -sin(angle) * p.y + cos(angle) * p.z);\n}\n\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//------------------------------------------------------------------\n\nvec2 hilbert(in vec3 center, float scale)\n{\n\tvec2 o =         vec2( sdCapsule(   center ,vec3(-.5,-.5, .5)*scale, vec3(-.5,-.5,-.5)*scale, 0.01  ), 31.9 );\n\t     o = opU( o, vec2( sdCapsule(   center ,vec3( .5,-.5,-.5)*scale, vec3( .5, .5,-.5)*scale, 0.01  ), 31.9 ) );\n\t     o = opU( o, vec2( sdCapsule(   center ,vec3( .5, .5,-.5)*scale, vec3( .5, .5, .5)*scale, 0.01  ), 31.9 ) );\n\t     o = opU( o, vec2( sdCapsule(   center ,vec3( .5, .5, .5)*scale, vec3(-.5, .5, .5)*scale, 0.01  ), 31.9 ) );\n\t     o = opU( o, vec2( sdCapsule(   center ,vec3(-.5, .5, .5)*scale, vec3(-.5, .5,-.5)*scale, 0.01  ), 31.9 ) );\n\t     o = opU( o, vec2( sdCapsule(   center ,vec3(-.5, .5,-.5)*scale, vec3(-.5,-.5,-.5)*scale, 0.01  ), 31.9 ) );\n\t     o = opU( o, vec2( sdCapsule(   center ,vec3( .5,-.5, .5)*scale, vec3( .5,-.5,-.5)*scale, 0.01  ), 31.9 ) );\n\t     o = opU( o, vec2( sdCapsule(   center ,vec3( .5,-.5,-.5)*scale, vec3( .5,-.5, .5)*scale, 0.01  ), 31.9 ) );\n\treturn o;\n}\n\nvec2 hilbertBlock(in vec3 botLeft, in vec3 topRight, float scale)\n{\n\tvec3 center = botLeft + (topRight - botLeft) / 2.;\n\tvec3 offset = (topRight - botLeft) * scale;\t\n\tvec3 offsetSub1 = offset / 2.; offsetSub1.z*=-1.0;\n\tvec3 offsetSub2 = offset / 2.; offsetSub2.z*=-1.0; offsetSub2.y*=-1.0;\n\tvec3 offsetSub3 = offset / 2.; offsetSub3.z*=-1.0; offsetSub3.x*=-1.0;\n\t\n\tvec2 o = \t    \t\thilbert( \topRotYZ(opRotXZ(\t\t\t\t\t\t\t\t\t\tcenter + offset * vec3(-1, 1,-1) )\t\t)\t\t,\t scale);\n\t\t o = opU( o,vec2( \tsdCapsule( \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcenter, -(offset+offsetSub1) * vec3(-1, 1,-1), -(offset+offsetSub1) * vec3(-1, 1, 1), 0.01), 71.9 ) );\n\t\t o = opU( o,\t\thilbert( \topRotXZ(opRotYZ(opRotXZ(opRotXZ(\t\t\t\t\t\tcenter + offset * vec3(-1, 1, 1) )\t\t)))\t\t,\t scale));\n\t\t o = opU( o,vec2( \tsdCapsule( \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcenter, -(offset+offsetSub2) * vec3(-1, 1, 1), -(offset+offsetSub2) * vec3(-1,-1, 1), 0.01), 71.9 ) );\n\t\t o = opU( o,\t\thilbert( \topRotXZ(opRotYZ(opRotXZ(opRotXZ(\t\t\t\t\t\tcenter + offset * vec3(-1,-1, 1) )\t\t)))\t\t,\t scale));\n\t\t o = opU( o,vec2( \tsdCapsule( \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcenter, -(offset+offsetSub1) * vec3(-1,-1, 1), -(offset+offsetSub1) * vec3(-1,-1,-1), 0.01), 71.9 ) );\n\t\t o = opU( o,\t\thilbert( \topRotYZ(opRotYZ(\t\t\t\t\t\t\t\t\t\tcenter + offset * vec3(-1,-1, -1) \t\t))\t\t,\t scale));\n\t\t o = opU( o,vec2( \tsdCapsule( \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcenter, -(offset+offsetSub3) * vec3(-1,-1,-1), -(offset+offsetSub3) * vec3( 1,-1,-1), 0.01), 71.9 ) );\n\t\t o = opU( o,\t\thilbert( \topRotYZ(opRotYZ(\t\t\t\t\t\t\t\t\t\tcenter + offset * vec3( 1,-1,-1) \t\t))\t\t,\t scale));\n\t\t o = opU( o,vec2( \tsdCapsule( \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcenter, -(offset+offsetSub1) * vec3( 1,-1,-1), -(offset+offsetSub1) * vec3( 1,-1, 1), 0.01), 71.9 ) );\n\t\t o = opU( o,\t\thilbert( \topRotXZ(opRotYZ(opRotYZ(opRotYZ(\t\t\t\t\t\tcenter + offset * vec3( 1,-1, 1) \t\t))))\t,\t scale));\n\t\t o = opU( o,vec2( \tsdCapsule( \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcenter, -(offset+offsetSub2) * vec3( 1,-1, 1), -(offset+offsetSub2) * vec3( 1, 1, 1), 0.01), 71.9 ) );\n\t\t o = opU( o,\t\thilbert( \topRotXZ(opRotYZ(opRotYZ(opRotYZ(\t\t\t\t\t\tcenter + offset * vec3( 1, 1,  1) \t\t))))\t,\t scale));\n\t\t o = opU( o,vec2( \tsdCapsule( \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcenter, -(offset+offsetSub1) * vec3( 1, 1, 1), -(offset+offsetSub1) * vec3( 1, 1, -1), 0.01), 71.9 ) );\n\t\t o = opU( o,\t\thilbert( \topRotYZ(opRotXZ(opRotXZ(opRotXZ(\t\t\t\t\t\tcenter + offset * vec3( 1, 1,-1) \t\t))))\t,\t scale));\n\n\treturn o;\n}\n\nvec2 map( in vec3 pos )\n{\n \n\tvec3 center = pos - vec3(0,.7, 0);\t\t\t\t\t\t\t\t\t\t\t\t\n\tvec2 o = \t\t\thilbert (center,1.2);\t\t\t\t\t\t\t\t\t\t// slightly oversized to show the idea\n\t\t //o = opU( o, \thilbert(opRep(center,vec3(.25,.25,.25)),.125) );            // repeating does not include rotation :/?\n\t\t o = opU( o, \thilbertBlock( center               - vec3(.5), center               + vec3(.5),.25) );\n\t\t //o = opU( o, \thilbertBlock( center + vec3(1,0,0) - vec3(.5), center + vec3(1,0,0) + vec3(.5),.25) ); //next block\n\t\t \n\t\n\n\tvec2 res = opU( vec2( sdPlane(     pos),1. ),\n\t\t\t\t\to);\n        \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.2;\n    float tmax = 20.0;\n   \n#if 1\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0004*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 10.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n\t\t// camera\t\n        vec3 ro = vec3( 4.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.5*sin(0.1*time + 6.0*mo.x) );\n        vec3 ta = vec3( -0.5, -0.4, 0.5 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.2) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3fzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[306, 306, 331, 331, 346], [348, 348, 400, 400, 518], [520, 520, 556, 556, 655], [657, 657, 682, 682, 719], [721, 721, 746, 746, 804], [806, 806, 831, 831, 896], [968, 968, 1001, 1001, 1027], [1029, 1029, 1059, 1059, 1092], [1094, 1094, 1116, 1116, 1243], [1245, 1245, 1267, 1267, 1393], [1396, 1396, 1426, 1426, 1455], [1457, 1457, 1481, 1481, 1613], [1685, 1685, 1728, 1728, 2651], [2653, 2653, 2720, 2720, 4974], [4976, 4976, 5001, 5001, 5566], [5568, 5568, 5608, 5608, 6227], [6230, 6230, 6308, 6308, 6570], [6572, 6572, 6604, 6604, 7043], [7045, 7045, 7087, 7087, 7386], [7388, 7464, 7500, 7521, 7744], [7746, 7746, 7785, 7785, 9487], [9489, 9489, 9541, 9541, 9718]], "test": "valid"}
{"id": "XlcBR7", "name": "Hologram/Iridescence Raymarching", "author": "Aj_", "description": "Hologram/iridescence effect on a ray marched cube. \nIridescence effect is based off of this awesome post by MinionsArt: https://www.patreon.com/posts/quick-game-art-15466787\nUse mouse to add extra rotation", "tags": ["raymarching", "iridescence", "hologram"], "likes": 20, "viewed": 2010, "published": "Public API", "date": "1538956028", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float iridStrength = 0.5;\nconst float iridSaturation = 0.7;\nconst float fresnelStrength = 3.;\nconst vec3 lightCol = vec3(.02, .7, .02);\n\nvec2 mouse;\n#define MRX(X) mat3(1., 0., 0. ,0., cos(X), -sin(X) ,0., sin(X), cos(X))\t//x axis rotation matrix\n#define MRY(X) mat3(cos(X), 0., sin(X),0., 1., 0.,-sin(X), 0., cos(X))\t//y axis rotation matrix\t\n#define MRZ(X) mat3(cos(X), -sin(X), 0.\t,sin(X), cos(X), 0.\t,0., 0., 1.)\t//z axis rotation matrix\n#define MRF(X,Y,Z) MRZ(Z)*MRY(Y)*MRX(X)\t//x,y,z combined rotation macro\n#define ROT MRF(iTime * .1 + mouse.y, iTime * .2 + mouse.x, iTime * .3)\nconst int iter = 256;\nconst float far = 1000.;\n#define EPSILON 0.00001\n\n//iq's signed-box distance function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoxR(vec3 p, vec3 b) {\n    p = p * ROT;\n    return sdBox(p, b);\n}\n\nvec3 normalBoxR(vec3 p, vec3 b) {\n     float dx = sdBoxR(vec3(p.x + EPSILON, p.y, p.z), b) - sdBoxR(vec3(p.x - EPSILON, p.y, p.z), b);\n    float dy = sdBoxR(vec3(p.x, p.y + EPSILON, p.z), b) - sdBoxR(vec3(p.x, p.y - EPSILON, p.z), b);\n    float dz = sdBoxR(vec3(p.x, p.y, p.z + EPSILON), b) - sdBoxR(vec3(p.x, p.y, p.z - EPSILON), b);\n    return vec3(dx, dy, dz);\n}\n\n\n\nvec3 normalBox(vec3 p, vec3 b) {\n    float dx = sdBox(vec3(p.x + EPSILON, p.y, p.z), b) - sdBox(vec3(p.x - EPSILON, p.y, p.z), b);\n    float dy = sdBox(vec3(p.x, p.y + EPSILON, p.z), b) - sdBox(vec3(p.x, p.y - EPSILON, p.z), b);\n    float dz = sdBox(vec3(p.x, p.y, p.z + EPSILON), b) - sdBox(vec3(p.x, p.y, p.z - EPSILON), b);\n    return vec3(dx, dy, dz);\n}\n\n\n//Color palette function taken from iq's shader @ https://www.shadertoy.com/view/ll2GD3\n#define  pal(t) ( .5 + .5* cos( 6.283*( t + vec4(0,1,2,0)/3.) ) )\n\n//rgb to grey scale\nvec3 greyScale(vec3 color, float lerpVal) {\n    \n    float greyCol = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;\n    vec3 grey = vec3(greyCol, greyCol, greyCol);\n    vec3 newColor = mix(color, grey, lerpVal);\n    return newColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mouse = iMouse.xy/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(.5);\n    uv.x*= iResolution.x/iResolution.y;\n    uv*=5.;\n\n    vec3 camPos = vec3(0., 0., -20.);\n    vec3 screen = vec3(uv.x, uv.y, -5.);\n    vec3 rayDir = normalize(screen - camPos);\n    \n    vec3 box = vec3(2. , 2., 2.);\n    \n    float depth = 0.;\n   \n    for(int i=0;i<iter;i++) {\n        vec3 tpc = camPos + rayDir * depth;\n        tpc = tpc*ROT;\n        float distc = sdBox(tpc, box);\n        if(distc < EPSILON){\n            break;\n        }        \n        if(depth > far) {            \n            break;\n        }\n        depth+=distc;\n    }\n    \n    vec3 p = camPos + rayDir * depth;\n    vec3 pc = camPos + rayDir * depth;\n    vec3 rpc = pc*ROT;\n    float c = sdBox(rpc, box);\n    vec3 nc = normalize(normalBox(rpc, box));\n    vec3 nco = normalize(normalBoxR(pc, box)); //normal for calculating fresnel\n  \tc = smoothstep(1.,.07, c);\n    \n  \tvec3 up; \n    //calculating up and right surface vectors for texturing\n    if(abs(dot(vec3(0., 0., 1.), nc)) > 1. - EPSILON \n       || abs(dot(vec3(0., 0., -1.), nc)) > 1. - EPSILON ) \n    {\n        up = vec3(0., 1., 0.) ;\n    }\n    else \n    {\n    \tup = normalize(cross(vec3(0., 0., 1.), nc));\n    }\n    vec3 right;\n  \tif(abs(dot(up, nc)) > 1. - EPSILON \n      || abs(dot(-up, nc)) > 1. - EPSILON ) \n    {\n        right = vec3(1., 0., 0.);//* -sign(nc.y) ;\n    }\n    else \n    {\n   \t\tright = normalize(cross(nc, up));\n    }\n    vec3 rpco = (rpc - box * (up + right))/(box*2.);\n    float dRight = (dot((rpco), right));//right surface vector\n    float dUp = dot(rpco, up);//up surface vector\n    \n    //lights\n    vec3 lightPos = vec3(2., 2., -5.);\n    vec3 lightDir = normalize(-lightPos);\n    float ldc = dot(lightDir, -nc);\n    vec3 rflct = reflect(normalize(pc - lightPos), nc);\n    float spec = dot(rflct, normalize(camPos - pc));\n   \n    vec2 uvm = (abs(vec2(dRight, dUp))); //texture uv\n    vec4 tex = texture(iChannel0, uvm);\n    vec4 greyTex = vec4(greyScale(tex.rgb, 1.), 1.);\n    float fres = 1. - dot(nco, normalize(camPos - pc));\n    fres *= fresnelStrength;\n    vec4 irid = pal((c)+(fres * greyTex)) ; //iridescence    \n    vec3 col = ((.4 + .3* ldc + pow(spec, 2.) * 0.3) * lightCol) * .3 * c;\n    col += greyScale(irid.rgb , 1. - iridSaturation) * c * iridStrength;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlcBR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[665, 701, 732, 732, 819], [821, 821, 851, 851, 894], [896, 896, 929, 929, 1261], [1265, 1265, 1297, 1297, 1622], [1780, 1800, 1843, 1843, 2036], [2038, 2038, 2095, 2095, 4452]], "test": "error"}
{"id": "XlcBRX", "name": "Triangulated Heightfield Trick", "author": "fizzer", "description": "Here is a trick to raytrace a triangulated heightfield taking only 1 sample of the heightfield for each triangle tested against the ray and reducing the ray-vs-triangle test to a ray-vs-plane test. Primary rays and shadow rays are both raytraced.", "tags": ["raytracing", "heightfield", "polygonal"], "likes": 134, "viewed": 16273, "published": "Public", "date": "1540372321", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Rays traverse a uniform grid and are tested against a triangle (actually this is just\n// a ray-versus-plane test). Rather than sampling the heightfield 3 times to get the triangle\n// vertices, previous vertices are kept and only one of the vertices is updated at each step.\n// So the heightfield is only sampled once per step.\n//\n// The algorithm is similar to triangle strip rasterisation, in that each new vertex\n// together with previous 2 vertices define a triangle.\n//\n\n//\n// The shaders of this series:\n//\n//   Triangulated Heightfield Trick 1 - https://www.shadertoy.com/view/XlcBRX (Rigid, right-triangle)\n//   Triangulated Heightfield Trick 2 - https://www.shadertoy.com/view/tlXSzB (Rigid, equilateral)\n//   Triangulated Heightfield Trick 3 - https://www.shadertoy.com/view/ttsSzX (Deforming, equilateral)\n//   Tetrahedral Voxel Traversal      - https://www.shadertoy.com/view/wtfXWB (Rigid, tetrahedron)\n//\n\n\n// Use this to toggle between taking 1 sample of the heightfield and taking\n// 3 samples (to fully construct the triangle on every step).\n#define SINGLE_SAMPLE 1\n\nfloat minh = 0.0, maxh = 6.0;\nvec3 nn = vec3(0);\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat noise(vec3 p)\n{\n    return hash(p.x + p.y*57.0 + p.z*117.0);\n}\n\nfloat valnoise(vec3 p)\n{\n    vec3 c = floor(p);\n    vec3 f = smoothstep(0., 1., fract(p));\n    return mix(\n        mix (mix(noise(c + vec3(0, 0, 0)), noise(c + vec3(1, 0, 0)), f.x),\n             mix(noise(c + vec3(0, 1, 0)), noise(c + vec3(1, 1, 0)), f.x), f.y),\n        mix (mix(noise(c + vec3(0, 0, 1)), noise(c + vec3(1, 0, 1)), f.x),\n             mix(noise(c + vec3(0, 1, 1)), noise(c + vec3(1, 1, 1)), f.x), f.y),\n        f.z);\n}\n\nfloat fbm(vec3 p)\n{\n    float f = 0.;\n    for(int i = 0; i < 5; ++i)\n        f += (valnoise(p * exp2(float(i))) - .5) / exp2(float(i));\n    return f;\n}\n\nfloat height(vec2 p)\n{\n    float h = mix(minh, maxh * 1.3, pow(clamp(.2 + .8 * fbm(vec3(p / 6., 0.)), 0., 1.), 1.3));\n    h += valnoise(vec3(p, .3));\n    return h;\n}\n\n// The raytracing function\nvec3 tr2(vec3 o,vec3 r)\n{\n    // Start ray at upper Y bounds\n    if(o.y > maxh)\n        o += r * (maxh - o.y) / r.y;\n    \n    vec2 oc = vec2(floor(o.x), floor(o.z)), c;\n    vec2 dn = normalize(vec2(-1, 1));\n    vec3 ta, tb, tc;\n\n    // Initialise the triangle vertices\n    ta = vec3(oc.x, height(oc + vec2(0, 0)), oc.y);\n    tc = vec3(oc.x + 1., height(oc + vec2(1, 1)), oc.y + 1.);\n    if(fract(o.z) < fract(o.x))\n        tb = vec3(oc.x + 1., height(oc + vec2(1, 0)), oc.y + 0.);\n    else\n        tb = vec3(oc.x, height(oc + vec2(0, 1)), oc.y + 1.);\n\n    float t0 = 1e-4, t1;\n\n    // Ray slopes\n    vec2 dd = vec2(1) / r.xz;\n    float dnt = 1.0 / dot(r.xz, dn);\n    \n    float s = max(sign(dnt), 0.);\n    c = ((oc + max(sign(r.xz), 0.)) - o.xz) * dd;\n\n    vec3 rs = sign(r);\n\n    for(int i = 0; i < 450; ++i)\n    {  \n        t1 = min(c.x, c.y);\n\n        // Test ray against diagonal plane\n        float dt = dot(oc - o.xz, dn) * dnt;\n        if(dt > t0 && dt < t1)\n            t1 = dt;\n \n#if !SINGLE_SAMPLE\n        // Sample the heightfield for all three vertices.\n        vec2 of = (dot(o.xz + r.xz * (t0 + t1) * .5 - oc, dn) > 0.) ? vec2(0, 1) : vec2(1, 0);\n        tb = vec3(oc.x + of.x, height(oc + of), oc.y + of.y);\n        ta = vec3(oc.x, height(oc + vec2(0, 0)), oc.y);\n        tc = vec3(oc.x + 1., height(oc + vec2(1, 1)), oc.y + 1.);\n#endif        \n\n        // Test ray against triangle plane\n        vec3 hn = cross(ta - tb, tc - tb);\n        float hh = dot(ta - o, hn) / dot(r, hn);\n\n        if(hh > t0 && hh < t1)\n        {\n            // Intersection with triangle has been found\n            nn = hn;\n            return o + r * hh;\n        }\n\n#if SINGLE_SAMPLE\n        vec2 offset;\n        \n        // Get an \"axis selector\", which has 1.0 for the near (intersected) axis\n        // and 0.0 for the far one\n        vec2 ss = step(c, c.yx);\n\n        // Get the coordinate offset of where to read the next vertex height from\n        if(dt >= t0 && dt < c.x && dt < c.y)\n        {\n            offset = vec2(1. - s, s);\n        }\n        else\n        {\n            offset = dot(r.xz, ss) > 0. ? vec2(2, 1) : vec2(-1, 0);\n\n            if(c.y < c.x)\n                offset = offset.yx;\n        }\n\n        // Get the next vertex\n        vec3 tnew = vec3(oc + offset, height(oc + offset)).xzy;\n\n        // Update the triangle vertices.\n        if(dt >= t0 && dt < c.x && dt < c.y)\n        {\n            tb = tnew;\n        }\n        else\n        {\n            // Swap vertex order based on sign of ray axis\n            if(dot(r.xz, ss) > 0.)\n            {\n                ta = tb;\n                tb = tc;\n                tc = tnew;\n            }\n            else\n            {\n                tc = tb;\n                tb = ta;\n                ta = tnew;\n            }\n\n            // Step the grid coordinates along to the next cell\n            oc.xy += rs.xz * ss;\n            c.xy += dd.xy * rs.xz * ss;\n        }\n#else\n        // Get an \"axis selector\", which has 1.0 for the near (intersected) axis\n        // and 0.0 for the far one\n        vec2 ss = step(c, c.yx);\n        \n        if(dt < t0 || dt >= c.x || dt >= c.y)\n        {\n            // Step the grid coordinates along to the next cell\n            oc.xy += rs.xz * ss;\n            c.xy += dd.xy * rs.xz * ss;\n        }\n        \n#endif\n        t0 = t1;\n\n        // Test if the ray left the upper Y bounds\n        if(((maxh - o.y) / r.y < t0 && r.y > 0.) || t0 > 200.)\n            return vec3(10000);\n\n    }\n    return vec3(10000);\n}\n\n// Ray direction function\nvec3 rfunc(vec2 uv)\n{\n    vec3 r = normalize(vec3(uv.xy, -1.3));\n    float ang = .7;\n    r.yz *= mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n    return r;\n}\n\nfloat chequer(vec2 p)\n{\n    return step(0.5, fract(p.x + step(0.5, fract(p.y)) * 0.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 t = uv * 2. - 1. + 1e-3;\n    t.x *= iResolution.x / iResolution.y;\n\n    // Setup primary ray\n    vec3 o = vec3(1.4, 9.5, -iTime), r = rfunc(t);\n\n    // Trace primary ray\n    vec3 rp = tr2(o, r);\n\n    // Surface normal\n    vec3 n = normalize(nn);\n    if(n.y < 0.)\n        n =- n;\n\n    // Checkerboard pattern\n    vec3 col = vec3(mix(.8, 1., chequer(rp.xz / 2.)));\n\n    if(fract(rp.z) < fract(rp.x))\n\t\tcol *= .7;\n    \n    // Light direction\n    vec3 ld = normalize(vec3(1.5, 1, -2));\n\n    // Directional shadow (raytraced)\n    vec3 rp2 = tr2(rp + n*1e-4 + ld * 1e-4, ld);\n    if(distance(rp, rp2) < 1000.)\n        col *= .4 * vec3(.65, .65, 1);\n\n    // Basic colouration\n    col *= mix(vec3(1, .8, .5) / 2., vec3(.3, 1, .3) / 4., 1. - clamp(rp.y / 2., 0., 1.));\n    col = mix(col, vec3(1) * .7, pow(clamp((rp.y - 2.5) / 2., 0., 1.), 2.));\n\n    // Directional light falloff\n    col *= pow(.5 + .5 * dot(n, ld), 1.);\n    \n    // Fog\n    col = mix(vec3(.65, .65, 1), col, exp2(-distance(rp, o) / 1024.));\n\n    // Clamp and gamma-correct\n    fragColor.rgb = pow(clamp(col * 2., 0., 1.), vec3(1. / 2.2));\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlcBRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1136, 1136, 1157, 1157, 1198], [1200, 1200, 1221, 1221, 1268], [1270, 1270, 1294, 1294, 1704], [1706, 1706, 1725, 1725, 1857], [1859, 1859, 1881, 1881, 2024], [2026, 2053, 2078, 2113, 5555], [5557, 5583, 5604, 5604, 5742], [5744, 5744, 5767, 5767, 5833], [5835, 5835, 5892, 5892, 7048]], "test": "valid"}
{"id": "XlcBW4", "name": "loopy", "author": "teraspora", "description": "loops", "tags": ["loops"], "likes": 0, "viewed": 71, "published": "Public", "date": "1539572717", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nfloat zig(vec2 p, float n, float r, float d) {\n    // n = order, r = radius, d = extra length\n \tfloat l = length(p);\n    l += sin(n * abs(arg(p))) * d;\n\treturn 1. - step(r, l) - step(0.04 - r, -l);\n      \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = iTime;\n    vec3 col;\n   \n    vec2 uv = 2. * fragCoord/iResolution.xy - 1.;\n    uv /= 3.;\n    uv *= 0.5 * vec2(sin(t / 17.), cos(t / 19.));\n\t \n    float a = zig(uv, 160. * sin(t / 12.), 0.5 * sin(t / 17.), 0.48 * sin(t / 19.));\n    float b = zig(uv, 128. * sin(t / 16.), 0.5 * sin(t / 13.), 0.2 * sin(t / 13.));\n    float c = zig(uv, 256. * sin(t / 15.), 0.5 * sin(t / 11.), 0.4 * sin(t / 17.));\n    float d = zig(uv, 64. * sin(t / 14.), 0.5 * sin(t / 19.), 0.2 * sin(t / 17.));\n    \n    col = vec3(a + b, b + c, c + a);\n    col.r += d;\n    float m = a + b + c + d;\n    // vec3 base = sin(t / 4. * vec3(.345, .456, .567)) * .4 + .6; \n    // col = vec3(m); // * base;\n    // col *= (1. + cos(iTime / 16.+uv.yyx+vec3(0,2,4))) / 2.;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlcBW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 48], [50, 50, 96, 143, 256], [258, 258, 315, 315, 1161]], "test": "valid"}
{"id": "XlcBzB", "name": "Ahziel - Groovy flower", "author": "Ahziel", "description": "Journey through the \"Book of shader\" - Shape / Function\nI do shaders to learn and have fun. If you have any advice, don't hesitate to tell me ! ", "tags": ["sin", "disk"], "likes": 3, "viewed": 413, "published": "Public", "date": "1539976670", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nfloat circle(in vec2 pos, in vec2 uv, in float radius)\n{\n    float dist = distance(pos,uv);\n    return 1.0 - smoothstep(radius - 0.01,radius, dist);\n}\n\nfloat oscillation(in float angle, in float freq, in float rand)\n{\n    return sin(mod( sign(rand - 0.5) * angle + iTime,2. *PI) * freq * floor(rand * 10.));\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 aspect = iResolution.xy / min(iResolution.x, iResolution.y);\n    uv *= aspect;\n    \n    vec2 center = vec2(0.5) * aspect;\n    vec2 pos = uv - center;\n    float angle = atan(pos.x,pos.y)+PI;\n    \n    // Background color\n    vec3 background = vec3(0.0, 0.0, 0.0);\n    vec3 col = background;\n    \n    // Information for the loop\n    const float numberOfCircle = 10.;\n    const float numberOfOscillation = 10.;\n    \n    for(float i = 0.; i < numberOfCircle; i++)\n    {\n       \tfloat ste = 1.0/numberOfCircle;\n\n        // Information for the function\n        float osci = 0.;\n        float amplitude = 0.01;\n\n        for(float j = 0.; j < numberOfOscillation; j++)\n        {\n            float freq = 1.0;\n            osci += oscillation(angle,freq,rand(vec2(j ,i )));\n        } \n        \n        // Information about circle\n        vec3 circleColor = vec3(ste * i,  ste * i, 1.0);\n        float radius = 0.45 - i * (ste/2.) + osci * amplitude;\n\n\t\t// Creation of the circle\n        col = mix(col,circleColor,circle(center,uv,radius));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlcBzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 82, 82, 176], [178, 178, 243, 243, 335], [337, 337, 357, 357, 429], [432, 432, 489, 539, 1681]], "test": "valid"}
{"id": "XlcBzH", "name": "Psychodelic Pattern", "author": "clara3ME", "description": "Psychodelic pattern nuff said", "tags": ["lsd", "psychodelic"], "likes": 7, "viewed": 508, "published": "Public API", "date": "1538554612", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846264338327950\n#define TWO_PI PI * 2.0\n\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (fragCoord - .5 *iResolution.xy) / iResolution.y;\n    float angle = atan(pos.y, pos.x) / PI;\n\tfloat arms = fract(angle * 3.0);\n    arms = abs(arms-0.5)*2.0;\n    \n    float dist = length(pos);\n    \n    dist = mix(dist,pow(dist,0.5),1.0);\n    \n    dist -= iTime*0.1;\n    \n    float green = sin((dist + arms*0.5) * 20.0)*0.5+0.5;\n    green += sin((dist - arms*0.5 + sin(iTime*0.4)) * 20.0);\n    green = clamp(green,0.0,1.0);\n    \n    float pink = sin((dist - arms*0.5) * 15.0)*0.5+0.5;\n    pink += sin((dist + arms*0.5) * 15.0);\n    pink = clamp(pink,0.0,1.0);\n    \n    vec3 color = vec3(0.1,0.05,0.8);\n    \n    color = mix(color,vec3(1.0,0.2,0.8),pink);\n    color = mix(color,vec3(0.2,1.0,0.05),green);\n    \n    color = rgb2hsv(color);\n    color.r += sin(iTime*0.3);\n    color = hsv2rgb(color);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlcBzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 130, 152, 152, 483], [485, 544, 566, 566, 735], [737, 737, 794, 794, 1662]], "test": "valid"}
{"id": "XlcBzN", "name": "Another sound shader", "author": "fatamoto", "description": "bbb", "tags": ["aaa"], "likes": 5, "viewed": 518, "published": "Public", "date": "1538732768", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sin1(float x, float offset) {\n\treturn (sin(x-offset)+1.0)/1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/iResolution.xy;\n    vec2 uvD = fragCoord.xy/iResolution.xy;\n    \n    uv.x *= iResolution.x/iResolution.y;\n\t\n    \n    vec3 col = vec3(0.,0.,0.);\n    float d = texture(iChannel0, vec2(((uvD.x+0.50)/4.0), 0.0)).x - 0.5;\n    float g = texture(iChannel0, vec2(((uvD.x+0.51)/4.0), 0.0)).x - 0.5;\n   \n\tfloat s = d; //sin(4.0*uv.x + iTime)* 0.5;\n    float b = g;//sin(3.8*uv.x + iTime+0.15)* 0.5;\n    \n    float c0 = 0.009/abs(s-uv.y);\n    float c1 = 0.005/abs(b-uv.y);\n    float z = min(c0, c1);\n    \n    col = vec3(0.5+sin1(4.0*uv.x+iTime, 0.0), \n               0.5+sin1(4.0*uv.x+iTime, 3.14/2.0), \n               0.5+sin1(4.0*uv.x+iTime, 3.14/3.0)) * z;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlcBzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 70], [72, 72, 129, 129, 870]], "test": "error"}
{"id": "XlcfD7", "name": "Tetrahedron2", "author": "rlm72", "description": "An SDF rendering of a tetrahedron", "tags": ["sdf"], "likes": 0, "viewed": 111, "published": "Public", "date": "1539786099", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Part 3 Challenges\n * - Make the camera move up and down while still pointing at the cube\n * - Make the camera roll (stay looking at the cube, and don't change the eye point)\n * - Make the camera zoom in and out\n */\n\nconst int MAX_MARCHING_STEPS = 1024;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.1415926535897932384626433832795;\n\n/**\n * Signed distance function for a cube centered at the origin\n * with width = height = length = 2.0\n */\nfloat cubeSDF(vec3 p) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 p) {\n    return length(p) - 5.0;\n}\n\nvec3 barycentric(vec3 p, vec3 a, vec3 b, vec3 c) {\n vec3 v0 = b - a, v1 = c - a, v2 = p - a;\n float d00 = dot(v0, v0);\n float d01 = dot(v0, v1);\n float d11 = dot(v1, v1);\n float d20 = dot(v2, v0);\n float d21 = dot(v2, v1);\n float denom = d00 * d11 - d01 * d01;\n float v = (d11 * d20 - d01 * d21) / denom;\n float w = (d00 * d21 - d01 * d20) / denom;\n float u = 1.0 - v - w;\n return vec3(u, v, w);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat tetraSDF(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d) {\n    float[4] lengths = float[4](length(a - p), length(b - p), length(c - p), length(d - p));\n    int max_index = 0;\n    float max_dist = -1.0;\n    for (int i = 0; i < 4; i++) {\n        if (lengths[i] > max_dist) {\n            max_dist = lengths[i];\n            max_index = i;\n        }\n    }\n    if (max_index == 0) {\n        return udTriangle(p, b, c, d);\n    } else if (max_index == 1) {\n        return udTriangle(p, a, c, d);\n    } else if (max_index == 2) {\n        return udTriangle(p, a, b, d);\n    } else if (max_index == 3) {\n        return udTriangle(p, a, b, c);\n    }\n}\n\nfloat groundSDF(vec3 p, float level) {\n    return (p.y - level);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    return min(tetraSDF(p, vec3(0,0,0), vec3(5,0,0), vec3(0,5,0), vec3(0,0,-5)), groundSDF(p, -1.0));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the eye to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n/**\nReturns a number to multiply the illumination by.\nk is softness of shadows\n*/\nfloat softShadowMarch(vec3 eye, vec3 marchingDirection, float start, float end, float k) {\n    float depth = start;\n    float res = 1.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn 0.0;\n        }\n        depth += dist;\n        //res = min(res, k*dist/depth);\n        if (depth >= end) {\n            return res;\n        }\n    }\n    return res;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    float lightToPointDist = length(p - lightPos);\n    float res = softShadowMarch(lightPos, normalize(p - lightPos),\n                                EPSILON, lightToPointDist - 12.0*EPSILON, 50.0);\n\t//res = 1.0;\n    \n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return res * lightIntensity * (k_d * dotLN);\n    }\n    return res * lightIntensity * (k_d * dotLN + 0.0 * k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(10.0 * sin(1.8*iTime),\n                          9.0,\n                          8.0 * cos(1.8*iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(10.0 * sin(1.3 * iTime),\n                          15.0 * cos(1.3 * iTime),\n                          8.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);\n    \n    //vec3 light3Pos = vec3(0,1.0,0.0);\n    //vec3 light3Intensity = vec3(5, 1, 0);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                            //      light3Pos,\n                           //       light3Intensity); \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(23.0 * sin(0.5 * iTime), 4., 23.0 * cos(0.5 * iTime));\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 2.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(1.2, 1.2, 1.4);\n    vec3 K_d = vec3(0.8, 0.8, 0.8);\n    vec3 K_s = vec3(0.1, 0.1, 0.1);\n    float shininess = 2.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlcfD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[402, 510, 533, 684, 1121], [1123, 1212, 1237, 1237, 1267], [1269, 1269, 1319, 1319, 1666], [1668, 1668, 1693, 1693, 1712], [1713, 1713, 1765, 1765, 2272], [2913, 2913, 2951, 2951, 2979], [2981, 3221, 3245, 3245, 3349], [3351, 3773, 3864, 3864, 4170], [4172, 4254, 4344, 4344, 4709], [4724, 4978, 5043, 5043, 5175], [5177, 5266, 5295, 5295, 5605], [5607, 6099, 6239, 6239, 7065], [7067, 7437, 7522, 7522, 8584], [8586, 8913, 8962, 8997, 9223], [9225, 9225, 9282, 9282, 10163]], "test": "error"}
{"id": "XlcfzS", "name": "Sliding Penguins", "author": "dr2", "description": "More penguin amusement", "tags": ["snow", "penguin", "sled"], "likes": 16, "viewed": 769, "published": "Public API", "date": "1539944615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Sliding Penguins\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nvec3 Noisev3v2 (vec2 p);\nfloat Fbm2s (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_PENG 3\n\nmat3 pngMat[N_PENG], pMat;\nvec3 pngPos[N_PENG], pPos, qHit, sunDir, trkA, trkF;\nfloat dstFar, tCur, fAng;\nint idObj;\nbool doSh;\nconst float pi = 3.14159;\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkA, sin (trkF * t)), 0.5 * cos (0.007 * t) * cos (0.01 * t), t);\n}\n\nvec3 TrackDir (float t)\n{\n  return vec3 (dot (trkF * trkA, cos (trkF * t)), 0., 1.);\n}\n\nvec3 TrackAcc (float t)\n{\n  return vec3 (dot (trkF * trkF * trkA, - sin (trkF * t)), 0., 0.);\n}\n\nfloat GrndHt (vec2 p)\n{\n  float w;\n  w = p.x - TrackPath (p.y).x;\n  return SmoothMin (8. * Fbm2s (0.05 * p), 0.1 * w * w - 0.5, 0.5) + Fbm2s (0.1 * p);\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 250; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0. || s > dstFar) break;\n    sLo = s;\n    s += max (0.01 * s, 0.4 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  const vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat PengDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, dh;\n  p.xz *= -1.;\n  q = p;\n  d = PrEllipsDf (q.xzy, vec3 (1.3, 1.2, 1.4));\n  q.y -= 1.5;\n  dh = PrEllipsDf (q.xzy, vec3 (0.8, 0.6, 1.3));\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.3, 2., -0.4);\n  d = SmoothMin (d, max (dh, - PrCylDf (q, 0.15, 0.3)), 0.2);\n  DMINQ (1);\n  q = p;\n  q.yz -= vec2 (1.6, -0.6);\n  d = max (PrEllipsDf (q, vec3 (0.4, 0.2, 0.6)), 0.01 - abs (q.y));\n  DMINQ (2);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.3, 2., -0.4);\n  d = PrSphDf (q, 0.15);\n  DMINQ (3);\n  q = p;\n  q.x = abs (q.x);\n  q.xy -= vec2 (0.6, -1.05);\n  q.yz = Rot2D (q.yz, -0.5 * pi);\n  q.y -= -0.6;\n  d = PrCylDf (q.xzy, 0.12, 0.7);\n  DMINQ (4);\n  q -= vec3 (0.1, -0.67, -0.4);\n  q.xz = Rot2D (q.xz, -0.07 * pi);\n  d = PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05));\n  q.z -= 0.5;\n  q.xz = Rot2D (q.xz, 0.15 * pi);\n  q.z -= -0.5;\n  d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n  q.z -= 0.5;\n  q.xz = Rot2D (q.xz, -0.3 * pi);\n  q.z -= -0.5;\n  d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n  DMINQ (5);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (1.1, 0.3, -0.2);\n  q.yz = Rot2D (q.yz, -0.25 * pi);\n  q.xy = Rot2D (q.xy, fAng) - vec2 (0.1, -0.4);\n  d = PrEllipsDf (q.xzy, vec3 (0.05, 0.25, 0.9));\n  DMINQ (6);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d, dMin;\n  dMin = dstFar;\n  for (int j = 0; j < N_PENG; j ++) {\n    q = p - pngPos[j];\n    d = PrSphDf (q, 3.);\n    if (doSh || d < 0.1) dMin = PengDf (pngMat[j] * q, dMin);\n    else dMin = min (dMin, d);\n  }\n  q = p;\n  q.x -= TrackPath (p.z).x;\n  q.y -= 2.;\n  q.z = mod (q.z + 20., 40.) - 20.;\n  d = 0.8 * PrTorusDf (q, 0.3, 7.);\n  DMINQ (7);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float sh, d, h;\n  doSh = true;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 30; j ++) {\n    p = ro + d * rd;\n    h = p.y - GrndHt (p.xz);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float f;\n  rd.y = abs (rd.y) + 0.0001;\n  ro.xz += 0.5 * tCur;\n  f = Fbm2s (0.02 * (rd.xz * (100. - ro.y) / rd.y + ro.xz));\n  col = vec3 (0.1, 0.2, 0.4);\n  col = mix (col, vec3 (0.8), clamp (3. * (f - 0.5) * rd.y + 0.1, 0., 1.));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, vns;\n  float dstGrnd, dstObj, gg, dx, sh;\n  doSh = false;\n  dstGrnd = GrndRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstGrnd) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj != 3) {\n      if (idObj == 1) col4 = (qHit.z < -0.2 || qHit.z > 0.4 && abs (qHit.x) < 0.04 ||\n         qHit.z < 0.4 && length (qHit.xy) < 0.2) ? vec4 (0.9, 0.9, 0.9, 0.1) :\n         vec4 (0.15, 0.15, 0.2, 0.1);\n      else if (idObj == 2) col4 = vec4 (1., 0.8, 0.2, 0.2);\n      else if (idObj == 4) col4 = vec4 (0.8, 0.8, 0., 0.2);\n      else if (idObj == 5) col4 = vec4 (0.9, 0.9, 0., 0.2);\n      else if (idObj == 6) col4 = vec4 (0.2, 0.2, 0.25, 0.1);\n      else if (idObj == 7) col4 = vec4 (0.3, 0.4, 0.7, 0.2);\n      sh = ObjSShadow (ro, sunDir);\n      col = col4.rgb * (0.2 + 0.1 * max (- dot (vn.xz, normalize (sunDir.xz)), 0.) +\n         0.7 * sh * max (dot (vn, sunDir), 0.)) +\n         sh * col4.a * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    } else col = SkyCol (ro, reflect (rd, vn));\n  } else if (dstGrnd < dstFar) {\n    ro += dstGrnd * rd;\n    vn = GrndNf (ro);\n    gg = smoothstep (0.6, 0.9, vn.y);\n    vn = VaryNf (4. * ro, vn, 0.5);\n    vns = normalize (Noisev3v2 (128. * ro.xz) - 0.5);\n    vns.y = abs (vns.y);\n    dx = abs (ro.x - TrackPath (ro.z).x);\n    col = vec3 (1.) * mix (1.1, 1., gg) * (0.7 +\n       0.3 * mix (Noisefv2 (vec2 (16. * dx, 0.5 * ro.z)), 1., smoothstep (0., 2., dx)));\n    sh = min (GrndSShadow (ro, sunDir), ObjSShadow (ro, sunDir));\n    col = col * (0.2 + 0.1 * max (- dot (vn.xz, normalize (sunDir.xz)), 0.) +\n       0.7 * sh * max (dot (vn, sunDir), 0.)) +\n       0.3 * sh * gg * smoothstep (0.3, 0.5, dot (vn, sunDir)) *\n       pow (max (dot (normalize (sunDir - rd), vns), 0.), 8.);\n  } else col = SkyCol (ro, rd);\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nvoid PengPM (float s, float dir)\n{\n  vec3 vel, va, acc, ort, cr, sr;\n  pPos = TrackPath (s);\n  vel = TrackDir (s);\n  acc = TrackAcc (s);\n  pPos.x -= 50. * acc.x;\n  va = cross (acc, vel) / length (vel);\n  ort = vec3 (-0.1 * dir, atan (vel.z, vel.x) - 0.5 * dir * pi,\n     12. * dir * length (va) * sign (va.y));\n  cr = cos (ort);\n  sr = sin (ort);\n  pMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 rd, ro;\n  vec2 canvas, uv;\n  float spd;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  tCur = mod (tCur, 600.) - 300.;\n  trkA = 5. * vec3 (1.9, 2.9, 4.3);\n  trkF = 0.18 * vec3 (0.23, 0.17, 0.13);\n  spd = 10.;\n  for (int j = 0; j < N_PENG; j ++) {\n    PengPM (spd * tCur + 15. * float (j + 1), 1.);\n    pPos.y = GrndHt (pPos.xz) + 1.35;\n    pPos.y += max (0., 0.5 * cos (0.13 * pPos.z) * cos (0.2 * pPos.z));\n    pngPos[j] = pPos;\n    pngMat[j] = pMat;\n  }\n  if (mod (0.1 * tCur, 2.) > 1.2) PengPM (spd * tCur, 1.);\n  else PengPM (spd * tCur + 15. * float (N_PENG + 1), -1.);\n  ro = pPos;\n  ro.y += 3.;\n  rd = normalize (vec3 (uv, 2.6)) * pMat;\n  fAng = -0.2 * pi + 0.1 * pi * SmoothBump (0.25, 0.75, 0.1, mod (0.2 * tCur, 1.)) *\n     sin (16. * pi * tCur);\n  sunDir = normalize (vec3 (0., 1.5, 1.));\n  sunDir.xz = Rot2D (sunDir.xz, 0.3 * pi * sin (0.1 * tCur));\n  dstFar = 250.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec4 h;\n  vec3 g;\n  vec2 ip, fp, ffp;\n  ip = floor (p);\n  fp = fract (p);\n  ffp = fp * fp * (3. - 2. * fp);\n  h = Hashv4f (dot (ip, vec2 (1., 57.)));\n  g = vec3 (h.y - h.x, h.z - h.x, h.x - h.y - h.z + h.w);\n  return vec3 (h.x + dot (g.xy, ffp) + g.z * ffp.x * ffp.y,\n     30. * fp * fp * (fp * fp - 2. * fp + 1.) * (g.xy + g.z * ffp.yx));\n}\n\nfloat Fbm2s (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.75);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlcfzS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[740, 740, 766, 766, 855], [857, 857, 882, 882, 943], [945, 945, 970, 970, 1040], [1042, 1042, 1065, 1065, 1195], [1197, 1197, 1231, 1231, 1716], [1718, 1718, 1740, 1740, 1885], [1958, 1958, 1993, 1993, 3270], [3272, 3272, 3294, 3294, 3673], [3675, 3675, 3708, 3708, 3885], [3887, 3887, 3908, 3908, 4106], [4108, 4108, 4146, 4146, 4414], [4416, 4416, 4453, 4453, 4674], [4676, 4676, 4708, 4708, 4971], [4973, 4973, 5008, 5008, 6863], [6865, 6865, 6899, 6899, 7393], [7395, 7395, 7451, 7451, 8453], [8455, 8455, 8488, 8488, 8515], [8517, 8517, 8559, 8559, 8610], [8612, 8612, 8655, 8655, 8719], [8721, 8721, 8756, 8756, 8818], [8820, 8820, 8866, 8866, 8923], [8925, 8925, 8955, 8955, 9068], [9070, 9070, 9115, 9115, 9218], [9220, 9220, 9277, 9277, 9360], [9394, 9394, 9418, 9418, 9548], [9550, 9550, 9574, 9574, 9637], [9639, 9639, 9664, 9664, 9850], [9852, 9852, 9877, 9877, 10221], [10223, 10223, 10245, 10245, 10398], [10400, 10400, 10429, 10429, 10641], [10643, 10643, 10682, 10682, 10862]], "test": "error"}
{"id": "XldBWn", "name": "Fractal striations", "author": "xentrac", "description": "This was an idea about how to get a somewhat random one-dimensional \"noise\" pattern with some coherence across multiple length scales: u ^ u << 2. I added some cubic sampling jitter to break up the obtrusive aliasing patterns from the rotation.", "tags": ["fractal", "1d"], "likes": 1, "viewed": 297, "published": "Public API", "date": "1539203625", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float scale = 1./min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord*scale;\n    float t = iTime / 40.;\n\n    vec2 fpos = fragCoord/iResolution.xy;\n    float jitter = 20. * (fpos.x + fpos.y + fract(iTime));\n    jitter = 2. * sin(iTime/16.18) * fract(jitter*jitter*jitter);\n\n    int u = int(dot(uv, 300. * vec2(cos(t), sin(t))) + jitter);\n    float i = float((u ^ u << 2) * 15 & 255)/255.0;\n    \n    fragColor = vec4(0.5 + 0.5*i*vec3(1,5,2),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XldBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 512]], "test": "valid"}
{"id": "XldfD8", "name": "leproshader", "author": "dots19", "description": "Yarr!", "tags": ["2d", "star"], "likes": 6, "viewed": 680, "published": "Public", "date": "1539450722", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define PI2 6.28318530\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvec2 scale(vec2 v, vec2 s)\n{\n    mat2 m = mat2(s.x, 0.0, 0.0, s.y);\n    return m * v;\n}\n\nfloat astroid(vec2 p, float n, float coeff,\n              float a, float b, float c)\n{\n    float phi=atan(p.y, p.x);\n    float r = length(p);\n    float xmax = sqrt(-log(2.0*exp(-a*a)-1.0)/(b*b));\n    float r0 = xmax*coeff;\n    float eq=r0+(1.0/c)*sqrt(-log(2.0*exp(-a*a)-\n          exp(-b*b*xmax*xmax*sin((phi-PI/2.0)*\n          (n/2.0))*sin((phi-PI/2.0)*(n/2.0)))));\n    return r-eq;\n}\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n\t\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n\t\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n    if( d < 0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\nfloat sdCaps( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n        \n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    \n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = 2.0*(fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    vec2 norm = fragCoord.xy/iResolution.xy;\n    vec2 pnorm = 2.0*(fragCoord.xy-0.5*iResolution.xy)/iResolution.xy;\n    \n    vec2 starscale = scale(p, vec2(1.0, 1.0));\n    \n    //red star\n    float star1_raw = astroid(starscale*3.5, 5.0, 0.09, 0.80, 0.13, 1.0);\n    float star1 = smoothstep(0.01, 0.06, star1_raw);\n    \n    //black star\n    float star2_raw = astroid(rotate(starscale*4.0, radians(180.0)), 5.0, 0.09, 0.79, 0.13, 1.0);\n    float star2 = smoothstep(0.01, 0.06, star2_raw);\n    \n    //outline1\n    float staroutline1 = 1.0-smoothstep(0.12, 0.15, star1_raw);\n    float staroutline2 = 1.0-smoothstep(0.12, 0.15, star2_raw);\n    float staroutline = clamp(staroutline1+staroutline2, 0.0, 1.0);\n    \n    //face\n    float face_raw = sdEllipse(p, vec2(0.43, 0.57));\n    face_raw = clamp(face_raw ,0.0, 1.0);\n    float face = smoothstep(0.01, 0.02, face_raw);\n    \n    //outline2\n    float commonoutline = (1.0-smoothstep(-1., 1.0, star1_raw))+\n        \t\t\t\t  (1.0-smoothstep(-1., 1.0, star2_raw))+\n        \t\t\t\t  (1.0-smoothstep(-0.05, 0.5, face_raw));\n    commonoutline = clamp(commonoutline, 0.0, 1.0);\n    \n    //eyes\n    vec2 eyepos = vec2(-0.25, -0.08);\n    vec2 mirror = p;\n    mirror.x=abs(mirror.x);\n    vec2 eyecd = rotate(mirror+eyepos, radians(113.0));\n    float eye = sdCaps(eyecd, 0.06, 0.09, 0.08);\n    eye=smoothstep(0.01, 0.021, eye);\n    \n    //top triangles\n    vec2 tri1pos = vec2(-0.2, -0.24);\n    vec2 tri1cd = rotate(mirror+tri1pos, radians(110.0));\n    float tri1 = sdTri(tri1cd, vec2 (0.04, 0.3));\n    tri1=smoothstep(0.0, 0.01, tri1);\n    \n    //bottom triangles\n    vec2 tri2pos = vec2(-0.1, 0.1);\n    vec2 tri2cd = rotate(mirror+tri2pos, radians(210.0));\n    float tri2 = sdTri(tri2cd, vec2 (0.02, 0.3));\n    tri2=smoothstep(0.0, 0.01, tri2);\n    \n    //pulps\n    \n    float blink = (cos(iTime*3.0)*0.5+0.5)*0.3+0.5;\n    vec2 pulppos = vec2(-0.15, -0.05);\n    vec2 pulpcd = rotate(mirror+pulppos, radians(210.0));\n    float pulp = sdCircle(pulpcd, 0.01);\n    pulp = clamp(pulp, 0.0, 1.0);\n    pulp = pow(pulp, 0.25);\n    pulp = smoothstep(0.00, blink, pulp);\n    \n    //background\n    \n    float rnorm = clamp(length(pnorm), 0.0, 1.0);\n    float r = atan(p.y, p.x);\n    r += -iTime*0.1;\n    float a = length(p);\n    float strips = cos((r+a*2.)*8.0)*0.5+0.5;\n    strips = smoothstep(0.47, 0.53, strips);\n    float bgmixfact = pow(rnorm*0.8, 1.5);\n    \n    //mixing\n    vec3 bg1 = vec3(0.447,0.680,0.700);\n    vec3 bg2 = vec3(0.249,0.379,0.390);\n    vec3 bgcolor = mix(bg1, bg2, strips)*1.0;\n    vec3 bgmask = vec3(0.049,0.055,0.049);\n    vec3 back = bgcolor;\n    vec3 outlinecolor = vec3(0.137,0.155,0.142);\n    vec3 staroutcolor = vec3(0.936,0.950,0.921);\n    vec3 star1_color = vec3(0.855,0.324,0.316);\n    vec3 star2_color = vec3(0.137,0.155,0.142);\n    vec3 facecolor1 = vec3(0.950,0.920,0.881);\n    vec3 facecolor2 = vec3(0.830,0.719,0.637);\n    vec3 eyecolor = star2_color;\n    vec3 tricolor = star1_color;\n    vec3 facecolor = mix(facecolor1, facecolor2, pow(norm.x,3.));\n    vec3 pulpcolor = vec3(0.960,0.230,0.138);\n    vec3 lay0 = mix(back, outlinecolor, commonoutline);\n    vec3 lay1 = mix(lay0, staroutcolor, staroutline);\n    vec3 lay2 = mix(star1_color, lay1, star1);\n    vec3 lay3 = mix(star2_color, lay2, star2);\n    vec3 lay4 = mix(facecolor, lay3, face);\n    vec3 lay5 = mix(eyecolor, lay4, eye);\n    vec3 lay6 = mix(tricolor, lay5, tri1);\n    vec3 lay7 = mix(tricolor, lay6, tri2);\n    vec3 lay8 = mix(pulpcolor, lay7, pulp);\n    vec3 lay9 = mix(lay8, bgmask, bgmixfact);\n    vec3 col = vec3(lay9);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XldfD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 76, 76, 160], [162, 162, 190, 190, 249], [251, 251, 337, 337, 637], [639, 639, 681, 681, 1711], [1713, 1713, 1766, 1766, 2024], [2026, 2026, 2063, 2063, 2377], [2379, 2379, 2414, 2414, 2440], [2442, 2442, 2499, 2499, 6149]], "test": "valid"}
{"id": "XldfDM", "name": "__sphere2__", "author": "monada", "description": "  ", "tags": [], "likes": 0, "viewed": 63, "published": "Public", "date": "1539865948", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle( vec2 p, vec2 center, float r )\n{\n    p = p - center;\n    float len = abs( length( normalize( p ) * r )  - length( p )  );\n   \n    return pow( len, 0.2 );\n}\n\nfloat sphere( vec2 p, float r )\n{\n    return 0.8 * max( 0.0, r - length( p ) );\n}\n\nfloat pulse( vec2 p )\n{\n    return 1.2 + 0.2 * sin( length( p ) * 20. - iTime * 5.0 );\n}\n\nvec3 neon( float v )\n{\n    vec3 col = vec3( 1.9, 1.5, 1.7 );\n    \n    col = col * -v + col;\n    col = col * col;\n    col = col * col;\n    \n    return col;\n}\n\nvec2 rotate2( vec2 p, float r, float a )\n{\n    float c = cos( a );\n    float s = sin( a );\n    \n    return mat2(\n    c * r, s * r,\n            -s * r, c * r ) * p;\n}\n\nvec3 hash(vec3 p3) {\n    p3 = fract( p3 * vec3( .1031, .11369, .13787 ) );\n    p3 += dot( p3, p3.yxz + 19.19 );\n    return -1. + 2. * fract(vec3((p3.x + p3.y) * p3.z, (p3.x+p3.z) * p3.y, (p3.y+p3.z) * p3.x));\n}\n\nfloat noise_perlin( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n \n    vec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat noise4( vec3 p )\n{\n float f;\n    f  = 0.5000 * noise_perlin( p ); \n f += 0.2500 * noise_perlin( p * 2. );\n f += 0.1250 * noise_perlin( p * 4. ); \n f += 0.0625 * noise_perlin( p * 8. );\n return f;\n}\n\nfloat noise_sum_abs(vec3 p) {\n    float f = 0.;\n    p = p * 3.;\n    f += 1.0000 * abs( noise_perlin( p ) );\n    f += 0.5000 * abs( noise_perlin( p * 2. ) );\n    f += 0.2500 * abs( noise_perlin( p * 3. ) );\n    f += 0.1250 * abs( noise_perlin( p * 4. ) );\n    f += 0.0625 * abs( noise_perlin( p * 5. ) );\n    \n    return f;\n}\n\n\nvec3 energy( vec2 p )\n{\n\n    float t = clamp( -p.x * p.x * 0.16 + 0.25, 0.0, 1.0 );\n\n    float s =  sphere( p, 0.8 ) * pulse( p ) * 2.2;\n    float s2 = 1.3 * sphere( p, 1.8 );\n    \n    float n = noise_sum_abs( vec3( p.xy, iTime * 0.04 ) * 2.0  );    \n\n    float v = pow( abs( n * -t + s2 ), 1.0 );\n   \n    vec3 baseCol = vec3( 2.8, 1.5, 1.2 ) * s;\n    \n    return neon( v ) * baseCol;\n}\n\nvec3 lightningImpl( vec2 p )\n{\n    float t = clamp( -p.x * p.x * 0.26 + 0.25, 0.0, 1.0  );\n    float n = noise4( vec3( p.xy, iTime ) * 8.0 );\n\n    float v = pow( abs( p.y + n * -t  ), 0.2 );\n    float sh = sphere( p, 0.8 );\n    \n    return neon( v ) * sh;\n}\n\nfloat cos_a = cos( 0.4 );\nfloat sin_a = sin( 0.5 );\n\n\nvec3 lightning( vec2 p )\n{\n    vec3 col;\n    float cont_val = cos_a * sin_a * 1.3;\n    \n    for( int i = 0; i < 3; ++i )\n    {\n        col += lightningImpl( p );\n        p = p * cont_val;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p =  2.0 * uv - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\n    fragColor.xyz = energy( p ) + lightning( p );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XldfDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 169], [171, 171, 204, 204, 252], [254, 254, 277, 277, 342], [344, 344, 366, 366, 500], [502, 502, 544, 544, 667], [669, 669, 689, 689, 879], [881, 881, 914, 914, 1742], [1744, 1744, 1768, 1768, 1947], [1949, 1949, 1978, 1978, 2273], [2276, 2276, 2299, 2299, 2662], [2664, 2664, 2694, 2694, 2921], [2977, 2977, 3003, 3003, 3193], [3195, 3195, 3252, 3252, 3419]], "test": "valid"}
{"id": "XldfW8", "name": "Zuul pyramid logo", "author": "tristanC", "description": "Testing map scene using Inigo's distance functions.", "tags": ["procedural", "3d", "raymarching", "distancefields", "primitives"], "likes": 7, "viewed": 197, "published": "Public", "date": "1539421743", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Zuul-ci pyramid logo in 3D\n\n   Code is mainly based on\n   https://www.shadertoy.com/view/Xds3zN\n   Uploaded by iq in 2013-03-25\n\n    and\n\n   https://www.shadertoy.com/view/ldKGWW\n   Uploaded by wjbgrafx on 2016-02-04\n\n\n   More resources:\n   http://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n   http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n*/\n// Set to 1 if too slow\n#define AA 2\n\n// Comment to remove scene elements\n#define SKY\n#define MONSTER\n#define FLOOR\n\nconst vec3 cam = vec3(0., 0., -2.7 );\n#define PI 3.141592653589793\n#define PITCH 0.328\n#define YAW -0.8\n#define DEG60 0.866025\n\n// Primitives\nconst mat3 rotX180 = mat3(1.0,     0.0,     0.0,\n                          0.0,  cos(PI), sin(PI),\n                          0.0, -sin(PI), cos(PI));\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec2 opU(vec2 d1, vec2 d2) {\n  return (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat pMirror (inout float p, float dist) {\n  float s = sign(p);\n  p = abs(p) - dist;\n  return s;\n}\n\nfloat sdPlane(vec3 p) {\n  return p.y;\n}\n\nfloat sdTriPrism(vec3 p, vec2 h) {\n  vec3 q = abs(p);\n  return max(q.z - h.y,\n         max(q.x * 0.4 + p.y * 0.5, -p.y) - h.x * 0.5);\n}\n\nfloat sdPrismZ(vec3 p, float angleRads, float height, float depth) {\n  vec3 q = abs(p);\n  return max(q.z - depth,\n         max(q.x * angleRads + p.y * 0.5, -p.y ) - height * 0.5);\n}\n\nfloat sdPrismX(vec3 p, float angleRads, float height, float depth) {\n    vec3 q = abs(p);\n    return max(q.x - depth,\n           max(q.z * angleRads + p.y * 0.5, -p.y) - height * 0.5 );\n}\n\nfloat sdPyramid(vec3 p, float angleRads, float height, float depth) {\n  vec3 q = abs(p);\n  return max(sdPrismX(p, angleRads, height, depth),\n             sdPrismZ(p, angleRads, height, depth));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat dot2(vec3 v) {\n  return dot(v,v);\n}\n\nfloat udTriangle(vec3 p, vec3 a, vec3 b, vec3 c) {\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross(ba, ac);\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n// Zuul logo primitives\nfloat sdHollowPyramid(vec3 p) {\n  float pyramid = sdPyramid(p, DEG60, 1.0, 1.0);\n  pyramid = max(pyramid, -sdPyramid(p - vec3( 0.0, 0.,  0.5), DEG60, .9, .9));\n  pyramid = max(pyramid, -sdBox(p, vec3(.45, 0.45, 0.45)));\n  return pyramid;\n}\n\nfloat sdHollowBox(vec3 pos, vec3 size, float hole) {\n  float box = sdBox(pos, size);\n  box = max(box, -sdBox(pos, size * vec3(2., hole, hole)));\n  box = max(box, -sdBox(pos, size * vec3(hole, hole, 2.)));\n  return box;\n}\n\nfloat sdInnerFrame(vec3 pos) {\n  float left  = sdHollowBox(pos + vec3(0.06, .1, .0), vec3(.39, .48, .45), 0.87);\n  float right = sdHollowBox(pos + vec3(.0, .1, -.06), vec3(.45, .48, .39), 0.87);\n  return left < right ? left : right;\n}\n\nfloat sdPilar(vec3 pos) {\n  return sdBox(pos + vec3( .000, .15, -.424), vec3(.026, .35, .026));\n}\n\nfloat sdRoof(vec3 pos) {\n return sdTriPrism((pos - vec3(.44, .492, .0)) * rotX180, vec2(.05, .45));\n}\n\nfloat sdZuul(vec3 pos) {\n  vec3 p = pos;\n  pMirror(p.x, 0.0);\n  pMirror(p.z, 0.0);\n  float pyramid = sdHollowPyramid(p);\n  float mainBox = sdHollowBox(p, vec3(.45, .517, .45), 0.87);\n  float innerBox = sdInnerFrame(p);\n  float lowerPlateau = sdBox(p - vec3(.0, .21, .0), vec3(.45, .026, .45));\n  float pilar = sdPilar(p);\n  float entranceWall = udTriangle(\n      p, vec3(.78, -.45, .45), vec3(.39, -.45, .451), vec3(.39, .34, .451));\n  float roof = sdRoof(p);\n\n  float closer = pyramid;\n  closer = smin(closer, lowerPlateau, .01);\n  closer = smin(closer, entranceWall, .01);\n  closer = closer < mainBox ? closer : mainBox;\n  closer = closer < roof ? closer : roof;\n  closer = closer < innerBox ? closer : innerBox;\n  closer = closer < pilar ? closer : pilar;\n  float socle = sdBox(pos + vec3(.0, .6, .0), vec3(2., .1, 2.));\n  return max(closer, -socle);\n}\n\n#ifdef MONSTER\n// Julia - Quaternion\n// https://www.shadertoy.com/view/MsfGRr\nconst int numIterations = 11;\n\nvec4 qsqr(vec4 a) {\n  return vec4(a.x*a.x - a.y*a.y - a.z*a.z - a.w*a.w,\n              2.0*a.x*a.y,\n              2.0*a.x*a.z,\n              2.0*a.x*a.w);\n}\n\nfloat juliaQ(vec3 p, vec4 c) {\n  vec4 z = vec4(p, 0.0) * 3.6;\n  float md2 = 20.0;\n  float mz2 = dot(z, z);\n\n  vec4 trap = vec4(abs(z.xyz), dot(z, z));\n\n  for (int i=0; i<numIterations; i++) {\n    md2 *= 4.0 * mz2;\n    z = qsqr(z) + c;\n    trap = min(trap, vec4(abs(z.xyz), dot(z, z)));\n    mz2 = dot(z, z);\n    if (mz2>4.0)\n      break;\n  }\n  return 0.25 * sqrt(mz2 / md2) * log(mz2);\n}\n#endif\n\n// The scene\nvec2 scene(vec3 pos) {\n  vec2 res = vec2(sdZuul(pos), 29.);\n  #ifdef FLOOR\n  float plane = sdPlane(pos + vec3(.0, 1., .0));\n  // Does not work well, but tries to remove the floor when under it...\n  if (plane > .0)\n    res = opU(res, vec2(plane, 1.));\n  #endif\n  #ifdef MONSTER\n  vec4 c = 0.45*cos(vec4(0.5,3.9,1.4,1.1) + (iTime*1.5)*vec4(1.2,1.7,1.3,2.5) ) - vec4(0.3,0.0,0.0,0.0);\n  res = opU(res, vec2(juliaQ(pos + vec3(.0, .13, .0), c), 49.));\n  #endif\n  return res;\n}\n\nvec3 calcNormal(vec3 pos) {\n  vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n  return normalize(e.xyy * scene(pos + e.xyy).x +\n                   e.yyx * scene(pos + e.yyx).x +\n                   e.yxy * scene(pos + e.yxy).x +\n                   e.xxx * scene(pos + e.xxx).x);\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i=0; i < 5; i++) {\n    float hr = 0.01 + 0.12 * float(i) / 4.0;\n    vec3 aopos = nor * hr + pos;\n    float dd = scene(aopos).x;\n    occ += -(dd - hr) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nvec2 castRay(vec3 ro, vec3 rd) {\n  const float tmin = 0.2;\n  const float tmax = 20.0;\n  float t = tmin;\n  float m;\n  for (int i=0; i < 300; i++) {\n    vec2 res = scene(ro + rd * t);\n    if (res.x < 0.0001 || t > tmax) break;\n    t += res.x;\n    m = res.y;\n  }\n  if (t > tmax) m = -1.0;\n  return vec2(t, m);\n}\n\n// Improved soft shadow by Sebastian Aaltonen\n// From: http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow(vec3 ro, vec3 rd, float mint, float maxt) {\n  float k = 32.;\n  float res = 1.0;\n  float ph = 1e20;\n  for (float t=mint; t < maxt; ) {\n    float h = scene(ro + rd * t).x;\n    if (h < 0.001)\n      return 0.0;\n    float y = h * h / (2.0 * ph);\n    float d = sqrt(h * h - y * y);\n    res = min(res, k * d / max(0.0, t-y));\n    ph = h;\n    t += h;\n  }\n  return res;\n}\n\n#ifdef FLOOR\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox(vec2 p) {\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;\n}\n#endif\n\n#ifdef SKY\nvec3 skyColor(vec3 rd) {\n  float offset = (.95 - clamp(rd.y, 0.0, 0.2))*.7;\n  return vec3(.5)+vec3(.5)*cos(6.28*(vec3(1.)*offset+vec3(0.0,0.10,0.20)));\n}\n#endif\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 col = vec3(.0);\n  #ifdef SKY\n  col = skyColor(rd);\n  #endif\n  vec2 res = castRay(ro, rd);\n  float t = res.x;\n  float m = res.y;\n\n  if (m > 0.) {\n    vec3 pos = ro + t * rd;\n    vec3 nor = calcNormal(pos);\n    vec3 ref = reflect(rd, nor);\n    col = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n    #ifdef FLOOR\n    if (m < 1.5) {\n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.01 + f*vec3(0.1);\n    }\n    #endif\n    // lightning\n    float occ = calcAO(pos, nor);\n    vec3  lig = normalize(vec3(0.1, 0.5, -0.6));\n    vec3  hal = normalize(lig - rd);\n    float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float dif = clamp(dot(nor, lig), 0.0, 1.0);\n    float bac = clamp(dot(nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float dom = smoothstep(-0.2, 0.2, ref.y );\n    float fre = pow(clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n    dif *= calcSoftshadow(pos, lig, 0.02, 2.5) * 0.2;\n    dom *= calcSoftshadow(pos, ref, 0.02, 2.5);\n\n    float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 16.0);\n    spe *= dif * (0.04 + 0.96 * pow(clamp(1.0 + dot(hal, rd), 0.0, 1.0), 5.0));\n\n    vec3 lin = vec3(0.0);\n    lin += 3.30 * dif * vec3(1.00, 0.80, 0.55);\n    lin += 0.40 * amb * vec3(0.40, 0.60, 1.00) * occ;\n    lin += 0.40 * dom * vec3(0.40, 0.60, 1.00) * occ;\n    lin += 0.50 * bac * vec3(0.25, 0.25, 0.25) * occ;\n    lin += 0.25 * fre * vec3(1.00, 1.00, 1.00) * occ;\n    col *= lin;\n    col += 50.0 * spe * vec3(1.00, 0.90, 0.70);\n    col = mix(col,  vec3(.0), 1.0 - exp(-0.0002 * t * t * t));\n  }\n  #ifdef SKY\n  // fog\n  float rayDist = length(ro + rd * t);\n  col = mix( col, skyColor(rd), 1.0 - 1.0 / exp( rayDist * 0.05));\n  #endif\n  return vec3(clamp(col, 0.0, 1.0));\n}\n\nfloat smoothStair(float frame) {\n  return frame - sin(frame) / 1.9;\n}\n\nmat3 camRotation() {\n  float yaw, pitch;\n  if( iMouse.z > 0.0 ) {\n    yaw = (iMouse.x / iResolution.x - 0.5) * 4.;\n    pitch = (iMouse.y / iResolution.y - 0.5) * 4.;\n  } else {\n    yaw = -.35 + smoothStair(iTime * 2.) / 2.;\n    pitch = PITCH;\n  }\n  return mat3(1.0,        0.0,        0.0,\n              0.0, cos(pitch), -sin(pitch),\n              0.0, sin(pitch),  cos(pitch)) *\n         mat3(cos(yaw),   0.0,  sin(yaw),\n              0.0,        1.0,      0.0,\n             -sin(yaw),   0.0,  cos(yaw));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  mat3 rot = camRotation();\n  vec3 tot = vec3(0.0);\n#if AA>1\n  for( int m=0; m<AA; m++ )\n  for( int n=0; n<AA; n++ ) {\n    vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n    vec2 uv = (gl_FragCoord.xy+o) / iResolution.xy*2.-1.;\n#else\n    vec2 uv = gl_FragCoord.xy / iResolution.xy*2.-1.;\n#endif\n\n    uv.y *= iResolution.y / iResolution.x;\n\n    vec3 dir = normalize(vec3(uv, 1.)) * rot;\n    vec3 pos = cam * rot;\n\n    vec3 col = render(pos, dir);\n    // gamma\n    col = pow(col, vec3(0.4));\n\n    tot += col;\n#if AA>1\n  }\n  tot /= float(AA*AA);\n#endif\n  fragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XldfW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[792, 792, 831, 831, 930], [932, 932, 960, 960, 994], [996, 996, 1039, 1039, 1095], [1097, 1097, 1120, 1120, 1136], [1138, 1138, 1172, 1172, 1273], [1275, 1275, 1343, 1343, 1456], [1458, 1458, 1526, 1526, 1645], [1647, 1647, 1716, 1716, 1842], [1844, 1844, 1873, 1873, 1964], [1966, 1966, 1986, 1986, 2007], [2009, 2009, 2059, 2059, 2554], [2556, 2580, 2611, 2611, 2819], [2821, 2821, 2873, 2873, 3041], [3043, 3043, 3073, 3073, 3277], [3279, 3279, 3304, 3304, 3376], [3378, 3378, 3402, 3402, 3479], [3481, 3481, 3505, 3505, 4336], [5000, 5013, 5035, 5035, 5484], [5486, 5486, 5513, 5513, 5761], [5763, 5763, 5797, 5797, 6069], [6071, 6071, 6103, 6103, 6379], [6381, 6499, 6563, 6563, 6882], [7412, 7412, 7443, 7443, 9181], [9183, 9183, 9215, 9215, 9252], [9254, 9254, 9274, 9274, 9761]], "test": "error"}
{"id": "XltBzM", "name": "forest fire-Nature", "author": "jkashimura", "description": "HW", "tags": ["beginner"], "likes": 1, "viewed": 97, "published": "Public", "date": "1539048946", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))/46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\n\nfloat pole(vec2 v, float r){\n  return length(v)-r;\n}\nfloat sphere(vec3 v, float r){\n  return length(v)-r;\n}\nfloat box(vec3 v, float r, float m) {\n  return max(length(v.xy)-r, abs(v.z)-m);\n}\n\n\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n//=======================\n\nShape vines(vec3 c){\n  Shape shape;\n  float vine;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n\n  // Shape Attributes\n  float twist = 10.; // Vine Repeat\n  float vineOffset = 3.; // Leaf Offset\n\n\n\tvineOffset -= tan(iTime*0.5)+0.5;\n\n  // Stems\n  \tvec3 i = c;\n    i.xz *= rot(c.y*0.35+iTime); \n    i.y = repeat(i.y, .8); //repeat\n\n    float detail = pModPolar(i.xz, twist); \n    \n    //float x = mix(-2., 1., mod(detail, 1.));// Small Ripples\n    //float x = mix(0., 1., pModPolar(i.xy, 10.)); \n    \n    \n    i.x -= vineOffset; // Offset Stems\n  \tfloat stemWidth = cos(iTime)*.9;\n  \tvine = pole(i.xz, stemWidth+0.02*sin(i.y));\n\n\n  vec4 color = vec4(.1, .1, sin(iTime)*.5+0.8, 1.);\n    \n    float pattern = cos(sin(c.z*10.)) /\n        cos(sin(c.y*2.));\n\n  shape.dist = vine;\n  shape.color = color;\n  shape.color /= pattern;\n\n  return shape;\n}\n\n\nShape orb(vec3 c){\n  Shape shape;\n  float orb;\n  shape.dist = 0.1; // Draw Distance\n  shape.color = vec4(1.,0.5,1.,1.); // Initial Color\n\n  // Stems\n  vec3 i = c;\n    i.xy *= rot(iTime); //rotate\n    i.y = repeat(i.y, .8); //repeat\n    i.x = repeat(i.x, 0.8);\n\n    i.x = abs(i.x)-0.5; //duplicate\n    i.z = abs(i.z)-0.5;\n    orb = sphere(i, cos(sin(iTime)*1.25)*0.25);\n    \n\n  vec4 color = vec4(4.1, 0.75, 7.4, 1.);\n\n  shape.dist = orb;\n  shape.color = color;\n\n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape vines = vines(c);\n  Shape orbs = orb(c);\n    \n  float df = mixShapes(vines.dist, orbs.dist, 1.);\n  vines.dist = df;\n    \n  vines.color = mix(vines.color, \n                    orbs.color*2., \n                    mixColors(orbs.dist, vines.dist, 1.));\n\n  return vines;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., -10.);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.05){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.01){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    c.dist *= smoothstep(0., cos(iTime)*.2+.2, length(v.x/v.y)); //line in middle\n    scene += f * c.dist;\n\n\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XltBzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 164, 186, 186, 253], [255, 255, 273, 273, 343], [346, 346, 374, 374, 398], [399, 399, 429, 429, 453], [454, 454, 491, 491, 535], [539, 539, 582, 582, 625], [627, 627, 670, 670, 736], [738, 738, 777, 777, 933], [961, 961, 981, 981, 1837], [1840, 1840, 1858, 1858, 2318], [2321, 2321, 2339, 2339, 2616], [2618, 2618, 2675, 2675, 3169]], "test": "valid"}
{"id": "XltfRn", "name": "Dots For SFD in an SDF", "author": "Tezza48", "description": "Here you go :D", "tags": ["sdf", "dots"], "likes": 2, "viewed": 191, "published": "Public", "date": "1538430532", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.x;\n    \n    vec2 points[1080];\n    \n    float offset = 0.05;\n    float initial = 0.08;\n    \n    float i = 0.0;\n    \n    float speed = 500.0;\n    \n\tfor (int r = 0; r < 18; r++)\n\t{\n\t\tfor (int a = 0; a < 60; a++)\n\t\t{\n\t\t\tfloat x = sin(PI / 6.0 * float(a) * iTime * float(r + 1)  / speed);\n\t\t\tfloat y = cos(-PI / 6.0 * float(a) * iTime * float(r + 1) / speed);\n\t\t\tvec2 p = vec2(x * (offset * float(r) + initial), y * (offset * float(r) + initial));\n            i += smoothstep(0.005, 0.004, length(uv - p));\n\t\t}\n\t}\n    \n    // Output to screen\n    fragColor = vec4(i);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XltfRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 127, 754]], "test": "valid"}
{"id": "Xltfz2", "name": "F I S S U R E", "author": "cardinalsine", "description": "Abstract doodling. Playing with sums of sinusoids.", "tags": ["abstract"], "likes": 11, "viewed": 155, "published": "Public", "date": "1540327901", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n#define PHI 1.6180339887498948482\n\n\nmat2 rotate(float theta) {\n    mat2 m = mat2(cos(theta), sin(theta),\n                  -sin(theta), cos(theta)\n                 );\n    return m;\n}\n\nfloat sinStep(float x, float w) {\n    float y = (x+(1./w)*sin(w*x));\n    return y;\n}\n    \nfloat sinc(float x, float w) {\n    float y = sin(w*x)/(w*x);\n    return y;\n}\n\n\nfloat gaussianWindow1D(float x) {\n    return exp(-(x*x));\n}\n\nfloat gaussianWindow2D(vec2 uv) {\n    return exp(-(uv.x*uv.x+uv.y*uv.y));\n}\n\nfloat absPolyWindow(float x, float p) {\n    return 1.-pow(abs(x),p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (-1.+2.*(fragCoord/iResolution.xy))*(iResolution.xy/iResolution.yy);\n    \n    float f = PI;\n    float theta = 0.25*f*sinStep(iTime,f);\n    uv *= rotate(theta);\n    \n    float df = distance(vec2(0.,0.), uv.xy);\n        \n    vec3 colOffset = (1.-df)*1.75*vec3(0.,1.,2.)*(0.5+0.5*cos(PI/2.+1.*f*iTime+0.25*f*sin(f*iTime)));\n    \n    //float win = clamp((1.-pow(df, 4.)),0.,1.);\n   \tfloat win = gaussianWindow1D(uv.y+uv.x);\n    \n    float sum = 0.;\n    float a = 0.;\n    float m = 16.;\n    float zoom = (0.75-0.25*cos(f*iTime));\n    vec3 col = vec3(0.,0.,0.);\n    \n    for (float i=1.; i<64.; i++) {\n        a = (1./i)*(1.+(sinc(iTime,PI*i*m)))*0.5;\n        sum += a;\n        col += a*cos(f*((2.+cos(iTime*f/2.))+i*sinStep(iTime, f))+(16.*i*exp((2.*(uv.x*uv.y)*zoom))+colOffset));\n    }\n    \n    col = (1.+col)*(1./sum)*win;\n    // Output to screen\n    fragColor = vec4(1.-col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xltfz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 107, 107, 227], [229, 229, 262, 262, 313], [319, 319, 349, 349, 395], [398, 398, 431, 431, 457], [459, 459, 492, 492, 534], [536, 536, 575, 575, 606], [608, 608, 665, 715, 1610]], "test": "valid"}
{"id": "Xt3BDH", "name": "Moon Prototype", "author": "Besisi", "description": "Moon Prototype", "tags": ["moon"], "likes": 2, "viewed": 75, "published": "Public", "date": "1539311545", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(vec2 p) \n{\n\treturn fract(sin(dot(p.xy, vec2(5.34, 7.13)))*5865.273458);   \n}\n\nvec2 hash2(vec2 p ) \n{\n\treturn fract(sin(vec2(dot(p, vec2(123.4, 748.6)), dot(p, vec2(547.3, 659.3))))*5232.85324);   \n}\n\nfloat noise(vec2 p) \n{\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    f = f * f * f * (3.0 - 2.0 * f);\n    vec2 add = vec2(1.0, 0.0);\n    float h = mix( mix(hash(n+add.yy), hash(n+add.xy), f.x), \n                   mix(hash(n+add.yx), hash(n+add.xx), f.x), f.y);\n        \n    return h;\n}\n\n//inspiration and a few lines of code from IQ's Pirates https://www.shadertoy.com/view/ldXXDj\nfloat fbm(vec2 p) \n{\n\tfloat h = 0.0;\n\tfloat a = 0.5;\n\tfor (int i = 0;i<4;i++) \n    {\n      //h+=noise(p)*a;\n\t\th+= texture(iChannel0, p).x*a; \n\t\tp*=2.0;\n\t\ta*=0.5;\n    }\n\treturn h;\n}\n\nvec3 project(vec2 p) \n{\n \treturn vec3(p.x, p.y, sqrt(-(p.x*p.x+p.y*p.y-0.24)));   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     //set uv coordinates\n\tvec2 uv = (-iResolution.xy+2.0*fragCoord.xy) / iResolution.y;\n    //project regular coordinates onto curved surface\n    vec3 n = project(uv);\n    //vec3 n = vec3(1.0f, 1.0f, 1.0f);\n    \n    //compute shading for curved moon\n    float angle = iTime;\n    vec3 sun = vec3(sin(angle*0.5)*2.0, 0.0, cos(angle*0.5)*2.0);\n    //vec3 sun = vec3(0.0f, 1.0f, 0.0f);\n    vec3 I = sun;\n    I = normalize(I);\n    float s = dot(n, I);\n    s = clamp(s*1.9, 0.0, 1.0);\n\n    //moon\n    float dist = length(uv);\n    vec3 moon = vec3(0.99, 0.99, 0.9);\n    moon = moon*(1.0-0.2*smoothstep(0.4, 0.44, dist));\n    //vec3 vtex = vec3(0.9+0.1*voronoi(uv*10.0));\n    vec3 vtex = vec3(0.0f, 0.0f, 0.0f);\n\tfragColor = vec4(((mix(moon, vtex, fbm(uv*0.02))))*s, 1.0);   \n   \n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3BDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 87], [89, 89, 111, 111, 209], [211, 211, 233, 233, 501], [503, 597, 617, 617, 777], [779, 779, 802, 802, 863], [866, 866, 923, 949, 1698]], "test": "error"}
{"id": "Xt3BDM", "name": "Metaeaux - Moon Clouds", "author": "metaeaux", "description": "added clouds", "tags": ["volumetrics"], "likes": 18, "viewed": 761, "published": "Public API", "date": "1539823649", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FOG 1\n#define SUNSET 0\n\nfloat quintic(float x) {\n \treturn x*x*x*(6.*x*x-15.*x+10.);\n}\n\nconst float fac = 43758.5453123;\n\nfloat hash(float p) {\n    return fract(fac*sin(p));\n}\n\nfloat noise(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    \n    float fac = 43758.5453123;\n    const float upper = 100.;\n    vec3 m = vec3(1., 10., 100.);//vec3(1., upper, upper*upper);\n    vec2 o = vec2(1., 0.);\n    \n    float n000 = hash(dot((i + o.yyy), m));\n    float n001 = hash(dot((i + o.xyy), m));\n    float n010 = hash(dot((i + o.yxy), m));\n    float n011 = hash(dot((i + o.xxy), m));\n    float n100 = hash(dot((i + o.yyx), m));\n    float n101 = hash(dot((i + o.xyx), m));\n    float n110 = hash(dot((i + o.yxx), m));\n    float n111 = hash(dot((i + o.xxx), m));\n    \n    float fx = quintic(f.x);\n    float fy = quintic(f.y);\n    float fz = quintic(f.z);\n    \n    float px00 = mix(n000, n001, fx);\n    float px01 = mix(n010, n011, fx);\n    \n    float px10 = mix(n100, n101, fx);\n    float px11 = mix(n110, n111, fx);\n    \n    float py0 = mix(px00, px01, fy);\n    float py1 = mix(px10, px11, fy);\n    \n    return mix(py0, py1, fz);\n}\n\n\nfloat noise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    vec2 m = vec2(100., 1.);\n    vec2 o = vec2(1., 0.);\n    \n    float n00 = hash(dot((i + o.yy), m));\n    float n01 = hash(dot((i + o.xy), m));\n    float n10 = hash(dot((i + o.yx), m));\n    float n11 = hash(dot((i + o.xx), m));\n    \n    float fx = quintic(f.x);\n    float px0 = mix(n00, n01, fx);\n    float px1 = mix(n10, n11, fx);\n    \n    return mix(px0, px1, quintic(f.y));\n}\n\nfloat ocean(in vec2 p) {\n    float f = 0.;\n    \n    float speed = .4;\n    vec2 v01 = vec2( 1.,  0.) * iTime*speed;\n    vec2 v02 = vec2( 0.,  1.) * iTime*speed;\n    vec2 v03 = vec2( 1.,  1.) * iTime*speed;\n    vec2 v04 = vec2(5.,  0.) * iTime*speed;\n    vec2 v05 = vec2(8.,  0.) * iTime*speed;\n    vec2 v06 = vec2(4., 1.) * iTime*speed;\n    \n    f += 0.50000*noise(p*1.0  + v01);\n    f += 0.25000*noise(p*2.1  + v02);\n    f += 0.12500*noise(p*3.9  + v03);\n    f += 0.06250*noise(p*8.1  + v04);\n    f += 0.03215*noise(p*15.8 + v05);\n    f += 0.01608*noise(p*32.3 + v06);\n    \n    f = (3.-2.*f)*f*f;\n    \n    f = 0.5*f + 0.25*f*sin(iTime) + 0.5;\n    \n    return f;\n    \n}\n\nfloat map(in vec3 p) {   \n    float o = ocean(p.xz * 0.08) * 3.;\n    return p.y + 0.5 + o;\n}\n\nfloat calcShadow(in vec3 ro, in vec3 rd, float tmax) {\n    float r = 1.;\n    float t = 0.;\n    for(int i = 0; i < 128; i++) {\n        float h = map(ro + t * rd);\n        r = min(r, tmax*h/t);\n        if (r < 0.01) break;\n        if (t > tmax) break;\n        t += h;\n    }\n    return clamp(r, 0., 1.);\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n    \n}\n\n\nconst vec3 SUN_DIR = normalize(vec3(-0.2, 0.15, -0.8));\n#if SUNSET\nconst vec3 SUN_COL = vec3(0.9, 0.4, 0.2);\n#else\nconst vec3 SUN_COL = vec3(0.95, 0.8, 0.85);\n#endif\n\nvec3 sky(in vec3 rd, vec3 sunDir, float fac) {\n    rd.y = max(0., rd.y);\n    \n    #if SUNSET\n    vec3 blue = vec3(0.2, 0.6, 0.9)-rd.y*0.85;\n    vec3 sunset = mix(blue, SUN_COL*0.9, exp(-rd.y*8.));\n    \n    vec3 sun = 5.*pow(dot(sunDir, rd), 90.) * SUN_COL;\n    return sunset * fac + sun;\n    #else\n    \n    vec3 blue = 0.6* vec3(0.02, 0.09, 0.2) -rd.y*0.1;\n    vec3 sunset = blue; //mix(blue, blue, exp(-rd.y*8.));\n    \n    vec3 sun = smoothstep(0.989, 0.99, dot(sunDir, rd)) * SUN_COL;\n    return sunset + sun;\n    \n    #endif\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 1000.);\n    \n    vec3 up = vec3(0., 1., 0.);\n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww, up));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    vec3 rd = normalize(vec3(p.x*uu + p.y*vv - 3.0*ww));\n    \n    float m = -1.;\n    float t = 0.;\n    float tmax = 300.;\n    for(int i = 0; i<512; i++) {\n        float h  = map(ro + rd * t);\n        if ( h<0.01 ) { m = 1.; break; };\n        if ( t>tmax ) break;\n        t += h;\n    }\n    \n    float sunsetFac = mod(iTime*0.02, 1.);\n    vec3 sunDir = normalize(SUN_DIR + vec3(0., -sunsetFac*0.4,0.));\n    vec3 skyCol = sky(rd, sunDir, 1.-sunsetFac);\n    vec3 col = vec3(0.);\n    \n    if (m > 0.) {\n        vec3 nor = calcNormal(ro + rd * t);\n        vec3 ref = reflect(rd, nor);\n        vec3 refCol = sky(ref, sunDir, 1.-sunsetFac);\n        \n        float d = dot(sunDir, nor);\n        vec3 dif = refCol*clamp(d, 0., 1.);\n        vec3 amb = vec3(0.01, 0.03, 0.08);\n        vec3 spec = refCol*pow(clamp(d+0.9, 0.,1.), 200.0);\n        \n        col = amb + mix(dif, spec, 0.4);\n    }\n\n    // fade out the horizon\n    col = mix(col, skyCol, pow(min(t, tmax)/tmax, 2.));\n    \n    // volumetrics\n    #if FOG\n    vec3 vol = vec3(0.);\n    float den = 0.;\n    float h = noise(p);\n    float dh = 0.3*tmax / 32.0;\n    \n    for (int i = 0; i < 32; i++) {\n        vec3 pos = ro + h*rd;\n        vec3 dir = sunDir - pos;\n        vec3 l = (SUN_COL*calcShadow(pos, normalize(dir), length(dir)));\n        float d = noise(pos + 2.*vec3(iTime, -iTime, -iTime)) * exp(-0.85*pos.y);\n       \n        den += d*0.002;\n        vol += l*den;\n        \n        h += dh;\n        if (h > t) break;\n        \n    }\n    col += pow(vec3(vol), vec3(.75))*0.1;\n    #endif\n    \n    col = pow(col, vec3(0.4545));\n    \n    // fade out\n    col *= smoothstep(0., 0.1, 1.-sunsetFac);\n    // fade in\n    col *= smoothstep(0., 0.01, sunsetFac);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3BDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 56, 56, 93], [129, 129, 150, 150, 182], [184, 184, 208, 208, 1139], [1142, 1142, 1166, 1166, 1597], [1599, 1599, 1623, 1623, 2267], [2269, 2269, 2291, 2291, 2361], [2363, 2363, 2417, 2417, 2665], [2667, 2667, 2695, 2695, 2888], [3058, 3058, 3104, 3104, 3587], [3590, 3590, 3647, 3647, 5676]], "test": "error"}
{"id": "Xt3fDB", "name": "shortest quadtree 3b (246ch)", "author": "FabriceNeyret2", "description": "golfed variant of [url]https://shadertoy.com/view/lljSDy[/url]", "tags": ["2tweets", "short", "quadtree", "golf"], "likes": 13, "viewed": 470, "published": "Public API", "date": "1540806125", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// golfed variant of https://shadertoy.com/view/lljSDy\n\nvoid mainImage(out vec4 O, vec2 u) {\n\n    float r =.2, t=iTime, H=iResolution.y, i=r;\n    vec2  U =  u/H, f,\n          P = .5+.5* cos(vec2(t,t*.7+11.));\n    for ( O.b = .25 ; ++i < 8. ;\n        min(f.x,f.y) < 3.*r/H    ?  O--\n    \t: length(P-1.) - r < 1.4 ?\n        \t  f = 2.*step(1.,U),\n        \t  U += U - f,\n        \t  P += P - f,  r += r,\n        \t  O += .13\n        : O )\n        f = min( U, 2.-U ),\n    length(P-U) < r ? O.gb-- : U; }             /*\n\n\n\n\n\n\n// --- 250 chars ( 2018 version )\n\n#define mainImage(O,u)                          \\\n                                                \\\n    float r=.2, t=iTime, H=iResolution.y, i=0.; \\\n    vec2 U =  u/H, f,                           \\\n         P = .5+.5* vec2(cos(t),sin(t*.7));     \\\n                                                \\\n    for ( O.b = .25; i<7.; i++ )                \\\n        f = min( U, 2.-U ),                     \\\n        min(f.x,f.y) < 3.*r/H    ?  O--         \\\n    \t: length(P-1.) - r < 1.4 ?              \\\n        \t  f = 2.*step(1.,U),                \\\n        \t  U += U - f,                       \\\n        \t  P += P - f,  r += r,              \\\n        \t  O += .13                          \\\n        : O;                                    \\\n\tlength(P-U) < r ? O.gb-- : U               /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3fDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 92, 92, 496]], "test": "valid"}
{"id": "Xt3fR4", "name": "Dandelion-Nature", "author": "jkashimura", "description": "HW", "tags": ["beginner"], "likes": 2, "viewed": 71, "published": "Public", "date": "1538701433", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\n//sphere\nfloat distSphere(vec3 v, float r){ //distance of sphere\n\treturn length(v) - r;\n}\n\nfloat sphere(vec3 v, float r){\n   //tiny sphere that goes in and out\n  float minDist = distSphere(v + vec3(cos(iTime), 0., 0.), 0.3);\n  float dist = distSphere(v - vec3(.7, 0.15, 0.), 0.05) + 0.005 * sin(iTime);\n    minDist = min(minDist, dist);\n  return minDist;\n}\n\nvec4 yay(vec2 v){\n    vec4 col = vec4(.9,.65,.1, 1.);\n    \n    float d = length(v); \n    d = length(v-vec2(.25,-.2));\n    \n    return col;\n}\n\nvoid pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tp = mod(p + halfsize, size) - halfsize;\n}\n\n// Converts v to Polar Coordinates, then repeat based on r\nvoid pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n}\n//=======================\n\n\nShape orbs(vec3 c){\n  Shape shape;\n  float s;\n  shape.dist = 2000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n\n\n  vec3 i = c;\n    i.x = abs(i.x)-(2.5+cos(iTime)*.001);\n    i.zx *= rot(c.x*0.1+iTime*0.5); // Twist Coord Sys\n    i.yz *= rot(c.z*0.2+iTime*0.5);\n    //i.xy *= rot(c.z*0.1+iTime*0.5);\n    pModPolar(i.xy, 18.); // Twist Repeat\n    i.x -= abs(cos(iTime*0.5))*3.; // Offset from origin\n    i.y -= abs(cos(iTime)*.01);\n    i.z -= abs(sin(iTime)*.01);\n    //pMod1(i.z, 3.);\n  \ts = sphere(i, 10.); // Create sphere\n\n    // Plug-in distance to object and color\n    vec4 color = vec4(1.,1.,.95+(sin(iTime)*0.1),.5);\n  \tshape.dist = s;\n  \tshape.color = color;\n\t\n  return shape;\n}\n\n\n// Map all objects within scene\nShape map(vec3 c){\n  Shape orb = orbs(c);\n  return orb;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(cos(iTime), sin(iTime), -10.); // Setup Camera\n  vec3 f = normalize(vec3(v, 1.)); // Frustrum\n    \n  vec3 scene = cam;\n  fragColor = vec4(0.); // Background Color\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.001){\n      fragColor = c.color*(cos(z)); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist; // Step to SDF\n     \n      \n\n    // Output to screen\n    fragColor = vec4(.7+cos(iTime)*0.1,0.7+cos(iTime)*.1,1.,1.0);\n\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3fR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 164, 186, 186, 253], [255, 255, 273, 273, 343], [345, 354, 388, 409, 434], [436, 436, 466, 504, 701], [703, 703, 720, 720, 843], [845, 845, 884, 884, 955], [957, 1016, 1054, 1054, 1174], [1203, 1203, 1222, 1222, 1904], [1907, 1939, 1957, 1957, 1996], [2000, 2000, 2057, 2057, 2659]], "test": "valid"}
{"id": "Xt3fW4", "name": "Mixing Color Circles", "author": "scratch13764", "description": "Just 3 circles that go around and overlap... like flashlights on a wall.", "tags": ["circles", "rgb"], "likes": 2, "viewed": 153, "published": "Public", "date": "1539574247", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    \n    float red;\n    float green;\n    float blue;\n    \n    float dist;\n    vec2 dif;\n    \n    float blur;\n    \n    float x;\n    float y;\n    \n    float offset;\n    \n    //general\n    \n    blur = 0.005 + (sin(iTime*0.3)+1.0)/10.0;\n    offset = sin(iTime*1.3) * 0.4;\n    \n    //green circle\n    \n    x = sin(radians(0.0) + iTime / 3.0) * offset;\n    y = cos(radians(0.0) + iTime / 3.0) * offset;\n    \n    dif = vec2(x-uv.x, y-uv.y);\n    dist = length (dif);\n    \n    green = smoothstep(0.3,0.3-blur,dist);\n    \n    \n    //red circle\n    \n    x = sin(radians(120.0) + iTime / 3.0) * offset;\n    y = cos(radians(120.0) + iTime / 3.0) * offset;\n    \n    dif = vec2(x-uv.x, y-uv.y);\n    dist = length (dif);\n    \n    red = smoothstep(0.3,0.3-blur,dist);\n    \n    \n    //blue circle\n    \n    x = sin(radians(240.0) + iTime / 3.0) * offset;\n    y = cos(radians(240.0) + iTime / 3.0) * offset;\n    \n    dif = vec2(x-uv.x, y-uv.y);\n    dist = length (dif);\n    \n    \n    blue = smoothstep(0.3,0.3-blur,dist);\n    //Output\n    fragColor = vec4(red,green,blue,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3fW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1181]], "test": "valid"}
{"id": "Xt3fWH", "name": "Mandelbrot Set Rainbow ", "author": "Thorgrimar", "description": "Testing fractals.", "tags": ["fractal"], "likes": 0, "viewed": 191, "published": "Public API", "date": "1539292550", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 col0 = vec3(0.839, 0., 0.223); //red\nvec3 col1 = vec3(0., 0.517, 0.839); // blue\nvec3 col2 = vec3(0.705, 1., 0.541); // green\nconst float third = 1./3.;\nvec3 colRange(float t) {\n    if (t <= third) {\n        return mix(col0, col1, t/third);\n    }\n    if (t <= third*2.) {\n        return mix(col1, col2, (t-third)/third);\n    }\n    return mix(col2, col0, (t-2.*third)/third);\n}\n\nconst float R2 = 1000.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pointZoomed = vec2(-0.743643887037151, 0.13185790420533);;\n    // Normalized pixel coordinates (from -1.0 to 1.0 for x)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    float n;\n    vec2 zn;\n    float twoPown = 1.;\n    float maxIter = 100.;\n    float sqModulus;\n    \n    float maxX = 1.5/exp(mod(10.*iTime/100., 18.));\n    vec2 pointC = maxX * uv + pointZoomed;\n    vec3 col = vec3(0.);\n    bool isInSet = true;\n    \n    // points of the set known\n    float va = pointC.x - .25;\n    float p2 = va*va + pointC.y*pointC.y;\n    if ( pointC.x > sqrt(p2) - 2.*p2 + .25 || (pointC.x+1.)*(pointC.x+1.)+pointC.y*pointC.y > 1./16.){\n        \n        zn = vec2(0.);\n        n = 0. ;\n        for(int i=1; n<maxIter; i++) {\n            n += 1.;\n            twoPown = twoPown*2.;\n            zn = vec2(zn.x*zn.x - zn.y*zn.y, 2.*zn.x*zn.y) + pointC;\n            sqModulus = dot(zn, zn);\n            if (sqModulus > 1000000.) {\n                isInSet = false;\n                float V = log(sqModulus)/twoPown;\n        \t\tcol = colRange(mod(log(V)/10. - iTime, 1.));\n                break;\n            }\n        }\n    }\n        \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3fWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 183, 183, 382], [409, 409, 466, 466, 1717]], "test": "valid"}
{"id": "XtcBDH", "name": "Domain warping with color", "author": "edo_m18", "description": "Domain warping with color pattern.", "tags": ["noise", "fbm", "domainwarping"], "likes": 9, "viewed": 637, "published": "Public", "date": "1539319514", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Fractal Brownian Motion\n *\n * Reference: https://thebookofshaders.com/13/\n * \n * See also: http://www.iquilezles.org/www/articles/morenoise/morenoise.htm\n *         : http://www.iquilezles.org/www/articles/warp/warp.htm\n */\n\nconst vec3 mixColor1 = vec3(0.8, 0.35, 0.12);\nconst vec3 mixColor2 = vec3(0.3, 0.75, 0.69);\n\n#define NUM_OCTAVES 5\n\n\n// Get random value\nfloat random(in vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// Get noise\nfloat noise(in vec2 st)\n{\n    // Splited integer and float values.\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float a = random(i + vec2(0.0, 0.0));\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    \n    // -2.0f^3 + 3.0f^2\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// fractional brown motion\n//\n// Reduce amplitude multiplied by 0.5, and frequency multiplied by 2.\nfloat fbm(in vec2 st)\n{\n\tfloat v = 0.0;\n    float a = 0.5;\n    \n    for (int i = 0; i < NUM_OCTAVES; i++)\n    {\n    \tv += a * noise(st);\n        st = st * 2.0;\n        a *= 0.5;\n    }\n    \n    return v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate normalized UV values.\n    vec2 st = fragCoord / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n        \n    vec2 q = vec2(0.0);\n    q.x = fbm(st + vec2(0.0));\n    q.y = fbm(st + vec2(1.0));\n    \n    // These numbers(such as 1.7, 9.2, etc.) are not special meaning.\n    vec2 r = vec2(0.0);\n    r.x = fbm(st + (4.0 * q) + vec2(1.7, 9.2) + (0.15 * iTime));\n    r.y = fbm(st + (4.0 * q) + vec2(8.3, 2.8) + (0.12 * iTime));\n    \n    // Mixed color by 'q' and 'r'.\n    color = mix(color, mixColor1, clamp(length(q), 0.0, 1.0));\n    color = mix(color, mixColor2, clamp(length(r), 0.0, 1.0));\n    \n    // Calculate by 'r' is that getting domain warping.\n    float f = fbm(st + 4.0 * r);\n    \n    // f^3 + 0.6f^2 + 0.5f\n    float coef = (f * f * f + (0.6 * f * f) + (0.5 * f));\n    color *= coef;\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtcBDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[349, 369, 395, 395, 471], [473, 486, 511, 552, 926], [928, 1028, 1051, 1051, 1232], [1235, 1235, 1292, 1331, 2140]], "test": "valid"}
{"id": "XtcBDj", "name": "CJ Voxel tunnel simplified", "author": "chrisjj", "description": "lsdlive's https://www.shadertoy.com/view/MscBRs , simplified for inspection of the voxel method.\n\nSee also https://www.shadertoy.com/view/lt3BDj ", "tags": ["test"], "likes": 4, "viewed": 315, "published": "Public", "date": "1540990767", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Simplified by CJ.\n\n\n// @lsdlive\n\n// This was my shader for the shader showdown at Outline demoparty 2018 in Nederland.\n// Shader showdown is a live-coding competition where two participants are\n// facing each other during 25 minutes.\n// (Round 1)\n\n// I don't have access to the code I typed at the event, so it might be\n// slightly different.\n\n// Original algorithm on shadertoy from fb39ca4: https://www.shadertoy.com/view/4dX3zl\n// I used the implementation from shane: https://www.shadertoy.com/view/MdVSDh\n\n// Thanks to shadertoy community & shader showdown paris.\n \n// This is under CC-BY-NC-SA (shadertoy default licence)\n\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 path(float t) {\n\tfloat a = sin(t*.2 + 1.5), b = sin(t*.2);\n\treturn vec2(2.*a, a*b);\n}\n\nfloat g = 0.;\nfloat de(vec3 p) {\n\tp.xy -= path(p.z);\n\n\tfloat d = -length(p.xy) + 4.;// tunnel (inverted cylinder)\n\n//\tp.xy += vec2(cos(p.z + iTime)*sin(iTime), cos(p.z + iTime));\n//\tp.z -= 6. + iTime * 6.;\n//\td = min(d, dot(p, normalize(sign(p))) - 1.); // octahedron (LJ's formula)\n\t// I added this in the last 1-2 minutes, but I'm not sure if I like it actually!\n\n\t// Trick inspired by balkhan's shadertoys.\n\t// Usually, in raymarch shaders it gives a glow effect,\n\t// here, it gives a colors patchwork & transparent voxels effects.\n\tg += .01 / (.01 + d * d);\n\treturn d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tfloat dt = iTime * 1.;\n\tvec3 ro = vec3(0, 0, -5. + dt);\n\tvec3 ta = vec3(0, 0, dt);\n\n\tro.xy += path(ro.z);\n\tta.xy += path(ta.z);\n\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 right = cross(fwd, vec3(0, 1, 0));\n\tvec3 up = cross(right, fwd);\n\tvec3 rd = normalize(fwd + uv.x*right + uv.y*up);\n\n\trd.xy *= r2d(sin(-ro.x / 3.14)*.3);\n\n\t// Raycast in 3d to get voxels.\n\t// Algorithm fully explained here in 2D (just look at dde algo):\n\t// http://lodev.org/cgtutor/raycasting.html\n\t// Basically, tracing a ray in a 3d grid space, and looking for \n\t// each voxel (think pixel with a third dimension) traversed by the ray.\n\tvec3 p = floor(ro) + .5;\n\tvec3 mask;\n\tvec3 drd = 1. / abs(rd);\n\trd = sign(rd);\n\tvec3 side = drd * (rd * (p - ro) + .5);\n\n\tfloat t = 0., ri = 0.;\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tri = i;\n\n\t\t/*\n\t\t// sphere tracing algorithm (for comparison)\n\t\tp = ro + rd * t;\n\t\tfloat d = de(p);\n\t\tif(d<.001) break;\n\t\tt += d;\n\t\t*/\n\n\t\tif (de(p) < 0.) break;// distance field\n\t\t\t\t\t\t\t  // we test if we are inside the surface\n\n\t\tmask = step(side, side.yzx) * step(side, side.zxy);\n\t\t// minimum value between x,y,z, output 0 or 1\n\n\t\tside += drd * mask;\n\t\tp += rd * mask;\n\t}\n\tt = length(p - ro);\n\n\tvec3 c = vec3(1) * length(mask * vec3(1., .5, .75));\n\tc = mix(vec3(.2, .2, .7), vec3(.2, .1, .2), c);\n\tc += g * .4;\n\tc.r += sin(iTime)*0. + .42*sin(p.z*.25 - iTime * 0.);// red rings\n\tc = mix(c, vec3(.2, .1, .2), 1. - exp(-.001*t*t));// fog\n\n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtcBDj.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[633, 633, 652, 652, 712], [714, 714, 734, 734, 804], [820, 820, 838, 838, 1380], [1382, 1382, 1437, 1437, 2983]], "test": "valid"}
{"id": "XtcBWH", "name": "striated weave", "author": "xentrac", "description": "This combines the weave pattern with the fractal striations to get some kind of semblance of a fabric composed of yarn. It works better at some scales (and some weaves) than others.", "tags": ["textile"], "likes": 3, "viewed": 426, "published": "Public API", "date": "1539288528", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 striation(in vec2 uv, in vec3 color, in vec2 angle) {\n    int u = int(dot(uv, angle));\n    return float((u ^ u << 2) * 15 & 255) / 255. * color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float t = iTime / 10.;\n    vec2 r = vec2(cos(t), sin(t));\n    vec2 uvf = mat2(r, -r.y, r.x) * fragCoord/mod(t/2., 6.);\n\tivec2 uv = ivec2(floor(uvf));\n\n    int mask = 4 + (int(iTime / 2.) & 7) << 2;\n    \n    vec2 fpos = uvf/iResolution.xy;\n    float jitter = 20. * (fpos.x + fpos.y + fract(iTime));\n    jitter = .4 * fract(jitter*jitter*jitter);\n    \n    vec3 bg = vec3(.1, .1, .1),\n    \twarp = striation(vec2(float((uv.x & -2) ^ 112) + mod(uvf.x, 2.) + jitter, uvf.y),\n        \t             vec3(8. * uvf/iResolution.xy, 1.), vec2(.8, .1)),\n        weft = striation(vec2(uvf.x, float((uv.y & -2) ^ 84) + mod(uvf.y, 2.) + jitter),\n                \t     vec3(1,3,2), vec2(.1, .7));\n\n    fragColor = vec4(((uv.x^uv.y) & mask) == 0\n                     ? 1 == ((uv.x ^ uv.x >> 1) & 1) ? warp : bg\n                     : 1 == ((uv.y ^ uv.y >> 1) & 1) ? weft : bg,\n                     1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtcBWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 151]], "test": "valid"}
{"id": "XtcBzr", "name": "Intrinsic Gravity Colors", "author": "digital", "description": "A recreation of one of my favorite scenes from Intrinsic Gravity.\nhttps://www.youtube.com/watch?v=-ZxPhDC-r3w", "tags": ["2d", "color"], "likes": 10, "viewed": 142, "published": "Public", "date": "1538453548", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n\nfloat sdCircle( vec2 p, float r )\n{\n \tfloat param = 1.0 - (length(p) - r);\n    \n    param = smoothstep(0.0, 0.1, param);\n    return param;;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 scene(vec2 uv, float time)\n{\n    float dist = (2.97 - 2.97*cos(min(PI,time)))/2.0;\n    float radius = 0.500; // circles just touching\n    float circles = 12.0;\n    float alpha = 0.20; // color intensity\n    \n    radius += smoothstep(4.6, 5.0, time)*0.615 +\n        smoothstep(6.5, 6.7, time)*0.47 + \n        smoothstep(8.5, 8.7, time)*0.57 + \n        smoothstep(9.5, 12.0, time)*12.0;\n    \n    vec3 col = vec3(0.0);\n    \n    for(int i = 0; i < int(circles); i++) {\n        float x = dist*cos(2.0*PI*float(i)/circles);\n        float y = dist*sin(2.0*PI*float(i)/circles);\n        vec2 pos = uv/0.1;\n        pos.x += x;\n        pos.y += y;\n        float hue = float(i)/circles;\n        \n        float sdf = clamp(sdCircle(pos, radius), 0.0, alpha);\n        col = col + hsv2rgb(vec3(hue, 0.8, sdf));\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    uv *=1.20;\n    \n    float period = 23.0;\n    float rot = iTime*0.2;\n    uv *= mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    \n    float time = mod(iTime, period);\n    \n    vec3 white = scene(uv, time);\n    vec3 black = vec3(1.0) - scene(uv, time-period/2.0);\n    \n    // fade in the first pass and fade back to normal state on last pass\n    white =  mix(vec3(0.0), white,\n                 smoothstep(0.0, 1.0,time) -\n                 smoothstep(period-1.0, period,time)\n                );\n    \n    // transition between \"scenes\"\n    vec3 col = mix(white, black, smoothstep(0.0, 0.1, -sin(2.0*PI*time/period)));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtcBzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 57, 57, 163], [165, 165, 187, 187, 350], [352, 352, 385, 385, 1182], [1184, 1184, 1241, 1291, 2009]], "test": "valid"}
{"id": "XtcfDM", "name": "my universe", "author": "mastersun", "description": "my universe, not finished yet", "tags": ["star"], "likes": 23, "viewed": 722, "published": "Public", "date": "1539754615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float N21(vec2 p) {\n\tp = fract(p * vec2(233.34, 851.73));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\nvec2 N22(vec2 p) {\n\tfloat n = N21(p);\n    return vec2(n, N21(p + n));\n}\n\nvec2 getPos(vec2 id, vec2 offset) {\n\tvec2 n = N22(id + offset);\n    float x = cos(iTime * n.x);\n    float y = sin(iTime * n.y);\n    return vec2(x, y) * 0.4 + offset;\n}\n\nfloat distanceToLine(vec2 p, vec2 a, vec2 b) {\n\tvec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - t * ba);\n}\n\nfloat getLine(vec2 p, vec2 a, vec2 b) {\n\tfloat distance = distanceToLine(p, a, b);\n    float dx = 15./iResolution.y;\n    return smoothstep(dx, 0., distance) * smoothstep(1.2, 0.3, length(a - b));\n}\n\nfloat layer(vec2 st) {\n    float m = 0.;\n    vec2 gv = fract(st) - 0.5;\n    vec2 id = floor(st);\n    // m = gv.x > 0.48 || gv.y > 0.48 ? 1. : 0.;\n    // vec2 pointPos = getPos(id, vec2(0., 0.));\n    // m += smoothstep(0.05, 0.03, length(gv - pointPos));\n    \n    float dx=15./iResolution.y;\n    // m += smoothstep(-dx,0., abs(gv.x)-.5);\n    // m += smoothstep(-dx,0., abs(gv.y)-.5);\n    // m += smoothstep(dx, 0., length(gv - pointPos)-0.03);\n    \n    vec2 p[9];\n    int i = 0;\n    for (float x = -1.; x <= 1.; x++) {\n        for (float y = -1.; y <= 1.; y++) {\n        \tp[i++] = getPos(id, vec2(x, y));\n        }\n    }\n    \n    for (int j = 0; j <= 8; j++) {\n    \tm += getLine(gv, p[4], p[j]);\n        vec2 temp = (gv - p[j]) * 20.;\n        m += 1./dot(temp, temp) * (sin(10. * iTime + fract(p[j].x) * 20.) * 0.5 + 0.5);\n        \n    }\n    \n    m += getLine(gv, p[1], p[3]);\n    m += getLine(gv, p[1], p[5]);\n    m += getLine(gv, p[3], p[7]);\n    m += getLine(gv, p[5], p[7]);\n    \n    // m += smoothstep(0.05, 0.04, length(st - vec2(0., 0.)));\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float m = 0.;\n    \n    float theta = iTime * 0.1;\n    mat2 rot = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n    vec2 gradient = uv;\n    uv = rot * uv;\n    \n    for (float i = 0.; i < 1.0 ; i += 0.25) {\n    \tfloat depth = fract(i + iTime * 0.1);\n        m += layer(uv * mix(10., 0.5, depth) + i * 20.) * smoothstep(0., 0.2, depth) * smoothstep(1., 0.8, depth);\n    }\n    \n    vec3 baseColor = sin(vec3(3.45, 6.56, 8.78) * iTime * 0.2) * 0.5 + 0.5;\n    \n    vec3 col = (m - gradient.y) * baseColor;\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtcfDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 116], [118, 118, 136, 136, 189], [191, 191, 226, 226, 358], [360, 360, 406, 406, 535], [537, 537, 576, 576, 734], [736, 736, 758, 758, 1797], [1799, 1799, 1856, 1856, 2498]], "test": "valid"}
{"id": "XtcfR4", "name": "pinhole", "author": "cubisttriangle", "description": "playing with shapes. not very efficient calculation. open to improvements.\n\nbased on: https://www.shadertoy.com/view/MdtXWX", "tags": ["pinhole"], "likes": 0, "viewed": 80, "published": "Public", "date": "1538968862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1).\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Set the colors for the background and shape.\n    vec4 bgColor = vec4(0.3, 0.3, 0.3, 1.0);\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    // A factor to create some movement.\n    float move = sin(iTime * 0.6);\n    \n    // Center of ring.\n    vec2  absRingCenter = vec2(0.5, 0.5);\n    \n    // Move the ring into the screen center.\n    vec2  ringCenter = absRingCenter * iResolution.xy;\n    \n    // Define the thickness of the ring scaled to x-axis.\n    float ringThickness = 0.85;\n    \n    // Define the radius of the outside of the ring, scaled to the x-axis.\n    float ringOuterRadius = 0.2 * iResolution.x * move * sign(move);\n    \n    // Define the inner radius base on the outer radius and ring thickness.\n    float ringInnerRadius = ringOuterRadius * ringThickness;\n    \n    // Calculate the distance of the current frag to the ring center.\n    vec2 vecFromCenter = fragCoord - ringCenter;\n    \n    // Convert the center point to a magnitude.\n    float radius = length(vecFromCenter);\n\n    // Calculate if a frag falls on the ring.\n    float param = saturate(radius - ringInnerRadius) * saturate(ringOuterRadius - radius);\n    \n    // Calculate if a frag falls on the base.\n    // Anti-aliasing fudge factor.\n    float fudge = 0.994;    \n    float leftBound = ringCenter.x - ringOuterRadius * fudge;\n    float rightBound = ringCenter.x + ringOuterRadius * fudge;\n    \n    if ( (leftBound <= fragCoord.x && fragCoord.x <= rightBound) && \n          fragCoord.y <= ringCenter.y && (ringOuterRadius*0.9 <= radius) )\n    {\n        param = 1.0;\n    }    \n\n    // Lerp between the shapecolor and bg color based on on previous calculations.\n    fragColor = mix(bgColor, color, param);\n\n    // Approximate linear-to-sRGB conversion (improves anti-aliasing quality)\n    fragColor.rgb = sqrt(fragColor.rgb);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtcfR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 58], [60, 60, 117, 168, 2024]], "test": "valid"}
{"id": "XtcfRH", "name": "Polar Grid Motion", "author": "Shane", "description": "Utilizing a repeat polar grid to plot objects moving along a transcendental rose curve path.", "tags": ["grid", "particles", "curve", "motion", "polar", "rose", "rosace"], "likes": 45, "viewed": 1368, "published": "Public API", "date": "1538661185", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tPolar Grid Motion\n\t-----------------\n\n\tUtilizing a repeat polar grid to plot objects moving along a transcendental rose \n    curve path.\n\n\tI wanted to post something nice and simple that the average GPU could handle. This \n    was inspired in part by Vovosunt's \"Dots and Spirals,\" but was based on Fabrice's \n    original \"rosace 3\" example. They say small things amuse small minds, and at the \n    time, that particular example kept me busy for ages. :)\n\n\tThe particle movement is pretty standard. Each object moves in a circular path with a \n    varying radius and Z position based on transcendental functions according to angular \n    position. For anyone not quite familiar with it, I've provided some links below.\n\n\tThe only mildly tricky bit was the rendering process. That involved keeping track of\n\tpotentially overlapping objects, then sorting prior to rendering. There are three\n\tpolar partitioned grids overlapping one another, but arranged radially and depthwise\n\tto look like they form a continuous closed curve. Potential overlapping objects\n\tconsist of three overlapping polar cells (one for each loop) and each of their adjacent \n    polar neighbors (the two on either side). That's nine altogether, which is not very \n    taxing on the average GPU. Therefore, I wouldn't expect any frame rate problems.\n\n\tI've tried to keep things relatively simple, but there's still a bit of esoteric \n\tdressing up code in there. For anyone who'd like to make something similar, you'd be \n    better off starting from scratch, then using this, Vovosunt's or Fabrices example as \n    a guide.\n\t\n\tAnyway, I'd call this a pseudo 3D example. At some stage, I'll try to come up with a\n\traymarched variation. By the way, there's a \"TRANSPARENT\" and \"RANDOM_VARIATION\" \n\tdefine below, for anyone bored enough to try them. :)\n\n\n    Examples:\n\n\t// Really nice.\n\tDots and Spirals - Vovosunt\n\thttps://www.shadertoy.com/view/MltyzN\n    \n    // The original that I based this off of.\n    rosace 3 ( 215 chars) - FabriceNeyret2 \n\thttps://www.shadertoy.com/view/ls3XWM\n\n    // A much simpler demonstration of the key motion concept.\n\tLinear motion - ABizard \n\thttps://www.shadertoy.com/view/4lKyzd\n\n\tLinks:\n\n    Rose (mathematics)\n    https://en.wikipedia.org/wiki/Rose_(mathematics)\n\n\tROSE\n    https://www.mathcurve.com/courbes2d.gb/rosace/rosace.shtml\n\n*/\n\n\n\n// A custom transparent overlay effect. The thing I like about pixel shaders is that\n// Photoshop layer effects are almost rudimentary.\n//#define TRANSPARENT\n\n\n// Making use of the individual particle ID to produce a random variation.\n//#define RANDOM_VARIATION\n\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values, but that's not an issue here.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\nvec3 getLight(vec3 p, vec3 n, vec3 lp){\n    \n    vec3 ld = lp - p;\n    float lDist = length(ld);\n    ld /= lDist;\n    float diff = max(dot(ld, n), 0.);\n    float atten = 1.5/(1. + lDist*lDist);\n    vec3 light = vec3(1)*(diff + .5)*atten;\n    \n    return light;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 U ){\n\n\tvec2 R = iResolution.xy;\n    \n    // Setting a minimum resolution, since fullscreen looks too bloated... Of course,\n    // that would ruin a mobile phone fullscreen settings... Too many systems, so it's\n    // impossible to win without seriously ruining your code. I miss the days when we were \n    // all on 17 inch screens... but not the grainy PPI. Definitely don't miss that. :)\n    float yRes = min(R.y, 800.);\n    \n    // Screen coordinates. This started with a discussion on Fabrice's rosace example\n    // (See the link above). Hence, the confusing minimal variable names. :)\n    U = (2.*U - R)/yRes;\n    \n   \n    //U *= 1. + dot(U, U)*.025; // Makeshift fisheye, if that's your thing.\n    \n     \n    // Three lines of 21, so 63 objects in all. There's nothing special about 21. It's\n    // just the number I settled on. Higher numbers work, but object size needs to be\n    // reduced, since overlap becomes a problem.\n    const float num = 21.;\n    \n    \n    // The scene light. Placed just above the scene.\n    vec3 lp = vec3(0, 0, 1); // Moving light: vec3(.3*cos(t), .2*sin(t), 1).\n    // The object normals. Trivial, in this case, since all are facing the same way.\n    vec3 n = vec3(0, 0, -1);\n    \n    \n\n    \n    \n    \n    // SCENE BACKGROUND.\n    //\n    // Just some noise, lines, and square geometry. Hopefully, self explanatory.\n    \n    // Initialize the background do a brownish gradient.\n    vec3 bg = vec3(.5, .45, .4);\n    \n    #ifdef TRANSPARENT\n    \tbg /= 2.;\n    #endif\n    \n    // Apply some light to the background.\n    vec3 light = getLight( vec3(U, 2.6), n,lp);\n    bg *= light;\n     \n    // Apply some subtle marbly noise.\n    float ns = fbm(U*5. + 17.3);\n    ns = mix(ns, sin(ns*32. - cos(ns*34.)), .125);\n    bg *= max(ns, 0.)*.4 + .8;\n    \n    // Apply a grainy randomized diagonal pattern. It's subtle, but I prefer it.\n    // Without it, the background seems a little too clean.\n    float pat = clamp(sin((U.x - U.y)*min(R.y, 800.)/1.5)*1. + .5, 0., 1.);\n    float rnd = fract(sin(dot(U, vec2(11.27, 112.43)))*43758.5453);\n    if(rnd>.5) pat *= .6; \n    else pat *= 1.4;\n    bg *= pat*.3 + .75;  \n    \n\n    \n    // Initiate the scene color to the background.\n    vec3 col = bg;\n    \n    // Render some border objects to frame things a little bit.\n    //\n    // Border sights: The background corners looked a little empty, so I threw \n    // these in to balance things out... Not sure if it worked, but it's done now. :)\n    vec2 b = vec2(iResolution.x/iResolution.y, 1) - .1;\n    vec2 q = abs(U);\n    float bord = max(q.x - b.x, q.y - b.y);\n    bord = max(bord, -(bord + .11));\n    bord = max(bord, -min(q.x - b.x + .22, q.y - b.y + .22));\n    //bord = max(bord, -(bord + .02));\n\n    \n    // Render the border sight... edge things, or whatever they are.\n    float falloff = 1./min(R.y, 800.);\n    col = mix(col, vec3(0), (1. - smoothstep(0., falloff*12., bord ))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., falloff, bord))*.7);\n    col = mix(col, bg*2.2, (1. - smoothstep(0., falloff, bord + .01)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., falloff, bord + .035)));\n    col = mix(col, bg*1.2, (1. - smoothstep(0., falloff, bord + .044)));   \n    \n    \n    \n    // OBJECT MOVEMENT.\n    //\n    // Moving the cell objects around the rose curve path whilst storing their \n    // positions for rendering.\n    \n    // Nine storage vectors: XYZ hold the 3D positions of the center object and each\n    // of its 8 polar neighbors. The W position holds the object ID.\n    //\n    // When taking polar coordinates into account, there are a potential 9 objects that \n    // could possibly overlap. Therefore, Z distances on all 9 need to be sorted to get \n    // the rendering order correct. If you spaced out the objects more, then you could\n    // probably get away with 3.\n    vec4 c[9];\n    \n    vec4 p; // Utility storage for the object position and ID.\n  \n    // A bit of global rotation -- Rotating the collection of objects as a whole.\n    float t = iTime/4.;\n    // Alternatively, you could take \"t\" out of the loop below, and globally rotate\n    // \"U\" itself.\n    //float t = iTime/4., cs = cos(t), sn = sin(t);\n    //U *= mat2(cs, sn, -sn, cs);\n    \n    // Storing \"atan\" to save a couple of extra calls. Not overly necessary, but my\n    // oldschool brain still thinks of it as an expensive function. :)\n    float a0 = atan(U.y, U.x) - t;\n    \n    // Due to overlap, polar neighbors need to be considered. If the cell objects are \n    // smaller, then it's not a problem, but I wanted a bit of object density.\n    //\n    for(int i=0; i<3; i++){ // Adjacent polar angle cells.\n         \n        float a = a0; // Polar angle.\n    \t\t\n        for(int j=0; j<3; j++) {  // Three intertwining overlapping revolutions.\n          \n            // Current cell angle.\n            //\n            // Note the \"i - 1\" figure. That's because we're considering overlapping\n            // cells to the left and right of \"ia,\" and not two to the right... It took\n            // me a while to realize that oversight. :)\n            //\n            // Cell index.\n        \tfloat ia = mod(floor(a*num/6.283) + float(i - 1), num*3.);\n            // Set the object ID to the cell index.\n            p.w = ia; \n            // Covert cell index to a polar angle.\n            ia = (ia/num + .5/num)*6.283;\n          \n            // Move X and Y along a rose curve path... or a rosace path, as Fabrice calls \n            // it, which I'll assume is the French rosette discription. Without going into \n            // detail, it's a circular path with a varying sinusoidal radius that gives it\n            // that interesting overlapping look.\n            //\n            // By the way, figures of 2./3., 4./3, 7./3. will also produce patterns. For \n            // other patterns, an adjustment of the \"j\" loop here and below and the \"c\" \n            // array size would be necessary... I'm sure you'll figure it out. :)\n            float off = ia*5./3. + iTime;\n        \t// The X and Y positions. Basically, a circle of varying radius.\n            p.xy = (.55 - .25*sin(off))*vec2(cos(ia + t), sin(ia + t));\n            \n            // By varying the Z component with a complementing offset, the objects move\n            // along an interwoven closed path. Obviously, if you set Z to a constant, all \n            // objects would be coplanar and things wouldn't work.\n        \tp.z = 2. + cos(off - 3.14159/5.)*.35;\n            //p.z = (2. + cos(a*5./3. + iTime - 3.14159/5.)*.35);\n   \n            \n            // Store the current cell postion and ID for usage in the rendering loop.\n            c[i*3 + j] = p;\n\n            // Increase the polar angle. Altogether, there'll be three whole revolutions.\n            a += 6.283; \n        \n        \t\n    \t}\n        \n    }\n    \n    // OVERLAPPING NEIGHBORING OBJECT SORTING.\n        \n    // Super lazy distance ordering: Since there are only 45 ((9 + 1)*9/2) iterations --\n    // or something along those lines -- performing a quick swap, the GPU shouldn't really \n    // notice. Also, I've heard that for small datasets, keeping the algorithm simple\n    // (branchless, etc) is more important than iteration count, but I don't know for sure.\n    //\n    // By the way, I think there's a quick vector swap somewhere, so I should probably \n    // track that down.\n    //\n    // On a side note, you could probably get away with a Z-buffer test and do away with the \n    // ordering, but it might disturb the smooth rendering.\n    //\n\tfor(int i=0; i<9; i++){\n        for(int j=i + 1; j<9; j++){\n            // Branchless swaps are possible (see below), but I'm a little paranoid \n            // regarding precision issues, so I'm sticking to what I know. :)\n            if(c[i].z<c[j].z){ \n                vec4 temp = c[i]; c[i] = c[j]; c[j] = temp;\n                \n                // Branchless swap: It works fine on my machine, but I can't\n                // guarantee it'll work in all situations, or that it's faster.\n                // If someone knows one way or the other, I'd love to know.\n                //c[i] = c[i] + c[j]; c[j] = c[i] - c[j]; c[i] = c[i] - c[j];\n            }\n        }\n\t}\n    \n    // OBJECT RENDERING.\n\n    for(int i=0; i<3; i++){ // Adjacent polar angle cells.\n\n        for (int j=0; j<3; j++) {  // Three intertwining overlapping revolutions.\n            \n            // Obtaining the position and ID for the current cell.\n            p = c[i*3 + j];\n            \n            // Using the Z coordi\n            float sz = .175/p.z;\n            float d = length(U - p.xy) - sz;\n            \n            // Main object color \n            #ifdef RANDOM_VARIATION   \n                // Object ID based random value.\n            \tfloat rnd = fract(sin(p.w + 37.)*43758.5453);\n                // Annulus. Equivalent to: max(d, -(d + sz*.75)).\n            \tif(rnd>.5) d = (abs(d + sz*.375) - sz*.375); \n            \n            \t// Random color variations.\n            \t#ifdef TRANSPARENT\n                vec3 pCol = mod(p.w, 3.)==0.?  vec3(1.5, .9, .3) : vec3(1.5, .24, .52);\n                #else\n            \t//vec3 pCol = rnd>.25? vec3(1, .75, .25) : vec3(.6, .9, .25);\n            \tvec3 pCol = mod(p.w, 3.)==0.? vec3(.35) : vec3(1, .22, .45);\n                #endif\n            #else\n            \tvec3 pCol = vec3(1, .75, .25);\n            #endif\n\n            \n            // Lighting the object. Very simple.\n            light = getLight(p.xyz, n, lp);\n\n            // Circular smoothstep falloff, based in the radial inverse.\n            falloff = .0005/sz;\n            \n            // Rendering the simple pattern on the discs. By the way, you could use some\n            // repeat trickery, and cut these steps down, but this isn't a GPU intensive\n            // example, and I wanted to try different variations, and so forth. Also, for \n            // readability, I wanted \"col\" written on the left, so these could be trimmed\n            // down further.\n            //\n            // Shadow, edges, color, etc.\n            //\n            \n            #ifdef TRANSPARENT\n            \tpCol = (col + .1)*pCol*light*3.;\n                // Alternate: Fade between transparent and opaque.\n                //pCol = mix(pCol*light, (col + .1)*pCol*light*3., smoothstep(-.1, .1, sin(iTime/4.)));            \n            #else\n            \tpCol *= light;\n            #endif\n            \n            col = mix(col, vec3(0), (1. - smoothstep(0., falloff*10., d - .0035))*.5);\n            col = mix(col, vec3(0), 1. - smoothstep(0., falloff, d));\n            col = mix(col, pCol, 1. - smoothstep(0., falloff, d + .01));\n            col = mix(col, vec3(0), 1. - smoothstep(0., falloff, d + sz - sz*.4));\n            col = mix(col, vec3(light), 1. - smoothstep(0., falloff, d + sz - sz*.4 + .01));\n            col = mix(col, vec3(0), 1. - smoothstep(0., falloff, d + sz - sz*.2 + .01));\n\n\n        }\n\n    }\n  \n    \n\t// POSTPROCESSING.\n    \n\t// A bit of color mixing, based on the canvas Y coordinate.\n    //col = mix(col.xzy, col, .75);\n    col = mix(col.xzy, col, U.y*.3 + .65);\n    \n    #ifndef RANDOM_VARIATION\n\t#ifdef TRANSPARENT\n    col = col.zyx;\n    #endif \n    #endif \n \n    // Rough gamma correction.\n    O = vec4(sqrt(max(col, 0.)), 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtcfRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2619, 2873, 2892, 2892, 3097], [3099, 3177, 3195, 3195, 3268], [3271, 3271, 3310, 3310, 3533], [3536, 3536, 3576, 3576, 14819]], "test": "error"}
{"id": "Xtcfzf", "name": "Pulsing ring", "author": "aferriss", "description": "Pulsing ring ", "tags": ["pulse", "ring", "eased"], "likes": 3, "viewed": 876, "published": "Public API", "date": "1540399211", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float speed = 1.0;\nfloat offset = 0.1;\nfloat size = 4.0;\n\nfloat exponentialIn(float t) {\n  return t == 0.0 ? t : pow(2.0, 12.0 * (t - 1.0));\n}\n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n\t\n    uv = uv * 2.0 - 1.0;\n    uv *= size;\n    uv = uv * 0.5 + 0.5;\n    \n    uv.x *= aspect;\n\n    uv -= vec2(0.5*aspect, 0.5);\n    \n    float l = 1.0 - length(uv);\n    \n    float t = mod(iTime*speed, 1.0);\n    float t2 = mod(iTime*speed + offset, 1.0);\n    \n    t = clamp(exponentialIn(t), 0.0,1.0);\n    t2 = clamp(exponentialIn(t2), 0.0,1.0); \n    \n    float circle1 = smoothstep(0.0, 0.01, l * t);\n\tfloat circle2 = smoothstep(0.0, 0.01, l * t2);\n    \n    float pulse = circle2 - circle1;\n    pulse = clamp(pulse, 0.0,1.0);\n    //pulse = smoothstep(0.3, 0.5, pulse);\n    // Output to screen\n    fragColor = vec4(pow(pulse*1.5, 2.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtcfzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 88, 88, 142], [144, 144, 222, 222, 297], [300, 300, 357, 357, 1084]], "test": "valid"}
{"id": "Xtcfzj", "name": "goldenAngle GIllumination bayer", "author": "ollj", "description": "drag mouse\n\nnote how light sources cast a shadow from another light source, tinted by whatever light reaches into the shadow.\nlacks reflections (just add portal-logic and brdf)\nlacks curvature of a fresnelIntegral (extension to brdf or curved spacetime?)\n", "tags": ["gi", "bayer", "radiosity", "weave", "laplachian", "crepusculariy", "lightshape", "softshaddow", "lightsdf"], "likes": 22, "viewed": 1315, "published": "Public API", "date": "1540201308", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n[lightsdf] samples occlusion diagonally (root of unity?)\n,to estimate non-point-light-emnmitters (like a pseudo-DFT?)\nThis fails for large curvature and convex emmitters\n, but gives you some cheap decent RADiosity almost for free\n, but still looks decent. (roudned corners of convex square emmitter)\n, but it LOD-scales VERY nicely, can be VERY fast and look convincing (see in lowres)\nBayer matrix is used in favor of better (and more dynamic) performance;\n\nmy scaling of bayerMatrix*X/iResolution seems off (semi intentionally)\nmaking the bayer matix exponentially lower res than screenspace resolution.\nthis way it keeps (inverse-)cubic performance on low res\n, while getting exponentially better quality on higher res.\n- this is mostly a lowres-preview opengl-crashing evasion.\n- but also demoes how you could to a buas \n-, by [DistanceToScreenCenter*DistanceToMouseCursor] of [ /XdXBzH ]\n\nthis shader does not rotate bayer matrixces, like [ /ltKcDt ] does.\n- mostly because i tend to not trust complex transforms on bayer-hyperplane moire.\n- but also because this shader samples rotated anyways.\n\nthis shader does not use any frame buffers\n, which should easily get performance/quality a lot higher\n, but also makes the shader a lot less compatible to bifferless canvases.\n*/\n\n//crepuscularity with bayer    (with RADiosity)\n//self   (bayer,instead of hash)            : https://www.shadertoy.com/view/Xtcfzj\n\n//crepuscularity without bayer (with RADiosity)\n//parent (hash instead of bayer)            : https://www.shadertoy.com/view/lldcDf\n//crepuscularity with 3dto2d differenceGrad : https://www.shadertoy.com/view/4lXBW2\n\n//crepuscularity without bayer (no RADiosity? hard to tell.)\n//dr2-noise with a bias for3d derivatives   : https://www.shadertoy.com/view/llXfRs\n//in comparison to slow 3d (crashes opengl) : https://www.shadertoy.com/view/lltfRB\n//\n//crepuscularity with (no RADiosity)\n//crepuscularity with highres Bayer         : https://www.shadertoy.com/view/4dyXWy\n//crepuscularity with highres Bayer2        : https://www.shadertoy.com/view/ltsyWl\n//crepuscularity with only 3 hyperplaneTaps : https://www.shadertoy.com/view/ltKcDt\n\n//compare that to [bayer-toggled bokeh  (no radiosity, no crepuscularity):\n//then you can define \"quality\" depentant on \"eye focus\"\n//- \"eye focus\" is something like DistanceToScreenCenter*DistanceToMouseCursor\n//- scale that gradient by a bayer matrix and use that as if(){} quality-bias\n//- ,that toggles/mixes 4 Crepuscularity/Radiosity/bokeh-compositions, as in\n//- https://www.shadertoy.com/view/XdXBzH\n//this works best for \"bokeh\" as it implies correlated things;focus/peripheralVision\n//,but it should work just as well to set bayer-quality for crepuscularity/radiosity\n\n//2d zoom\n#define ViewZoom 10.\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define Aa (min(iResolution.x,iResolution.y)/ViewZoom)\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y//usually first function of mainImage(),not typecast.\n\n\n#define pi acos(-1.)//trig definition for 3.14...can be better for smarter compilers.\n#define vec1 float\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n#define ss(a,u)smoothstep(a,-a,u)\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\nvec1 miv(vec2 a){return min(a.y,a.x);}vec1 miv(vec3 a){return min(a.z,miv(a.xy));}vec1 miv(vec4 a){return min(miv(a.zw),miv(a.xy));}\n#define mav(a)-miv(-a)\n#define cs(a) vec2(cos(a),sin(a))\n\n//fract(dot(1031))hash summer 2018 seems ot be generally superior to fract(sin())hashes\nvec3 g3(vec1 a){return vec3(a);}\nvec3 g3(vec2 a){return a.xyx;}\nvec3 g3(vec3 a){return a;}\nvec4 g4(vec1 a){return vec4(a);}\nvec4 g4(vec2 a){return a.xyxy;}\nvec4 g4(vec3 a){return a.xyzy;}\nvec4 g4(vec4 a){return a;}\n//hashes by David Hoskins,Creative Commons Attribution-ShareAlike 4.0 International Public License\n//parent https://www.shadertoy.com/view/4djSRW\n#define hs vec4(.1031,.1030,.0973,.1099)\n//#define HASHSCALE3 vec3(443.897,441.423,437.195,444.129)//For smaller input rangers like audio tick or 0-1 UVs use these...\n#define hout1(a)fract((a.x+a.y)*a.z)\n#define hout2(a)fract((a.xx+a.yz)*a.zy)\n#define hout3(a)fract((a.xxy+a.yzz)*a.zyx)\n#define hout4(a)fract((a.xxyz+a.yzzw)*a.zywx)\n#define h3mid(a)((a)+dot(a,a.yzx+19.19))\n#define h4mid(a)((a)+dot(a,a.wzxy+19.19))\n//hashes are named by output type,NEVER by input type\n//hash1 mirrors at y=x and has strong banding on diagonals.\n//only hash4 takes in vec4.all hash functions take vey1,v3c2,vec3 in (a vec4 generalizations is a mild overkill for most vec2,vec3 contexts)\n#define hash1(a)hout1(h3mid(fract(hs.x*g3(a))))\n#define hash2(a)hout2(h3mid(fract(hs.xyz*g3(a))))\n#define hash3(a)hout3(h3mid(fract(hs.xyz*g3(a))))\n#define hash4(a)hout4(h4mid(hs*g4(a)))\n//not sure if its this shaders fault,likely a fract()error,but the avobe hsh gives bad lines.\n//float hash1(float n){ return fract(sin(n)*1e4);}\n\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nvec3 rainbow(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbow2(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbow(float a){return rainbow(a,1./3.);}\nvec3 rainbow2(float a){return rainbow2(a,1./3.);}\n\n\n\n\n\n\n\n\n\n\n#define SAMPLES 64.\n#define iterBayerMat 1\n#define bayer2x2(a)(4-(a).x-((a).y<<1))%4\n\nfloat boxSDF(vec2 p,vec2 s\n){vec2 r=abs(p)-s\n ;return min(max(r.x,r.y),0.)+length(max(r,vec2(0)));}\n\nvec3 colormap(float x\n){//float s=sin(x*6.28)\n ;return vec3(1,vec2(-1,1)*sign(x))*.25+.25;}\n\nvoid AddObj(inout float dist,inout vec3 color,float d,vec3 c\n){if(dist>d){dist=d;color=c;}}\n\nvec4 scene(vec2 u,vec2 m\n){float dist=1e9;\n ;vec3 color=vec3(0)\n ;AddObj(dist,color,boxSDF(u-vec2(-3,1),vec2(1,1)),vec3(.6,.8,1.))\n ;AddObj(dist,color,length(u-vec2(3,1))- 1.,vec3(1,.9,.8))\n ;AddObj(dist,color,length(u-vec2(.3*sin(iTime),-2))- 0.5,vec3(0,.1,0))\n ;AddObj(dist,color,boxSDF(u-m,vec2(1.5,0.1)),vec3(.3,.1,.1))\n ;return vec4(color,dist);}\n\nvec3 trace(vec2 p,vec2 dir,vec2 m\n){for (int a=128;a>0;a--\n){vec4 s=scene(p,m)\n  ;if(s.w<1e-1)return s.xyz\n  ;if(s.w>10.)return vec3(0)\n  ;p+=dir*s.w;\n }return vec3(0);}\n\n//return bayer matrix(bitwise operands for speed over compatibility)\nfloat GetBayerFromCoordLevel(vec2 pixelpos//https://www.shadertoy.com/view/XtV3RG\n){ivec2 p=ivec2(pixelpos);int a=0\n ;for(int i=0;i<iterBayerMat;i++\n){a+=bayer2x2(p>>(iterBayerMat-1-i)&1)<<(2*i)\n ;}return float(a)/float(2<<(iterBayerMat*2-1));}\n\n//float hash1(vec2 _st){return fract(sin(dot(_st.xy,vec2(12.9898,78.233)))*43758.5453123);}\nvoid mainImage(out vec4 fragColor,vec2 u\n){u=fra(u)//(u-(iResolution.xy*.5))/iResolution.y*ViewZoom\n ;vec2 m=vec2(0)\n ;if(iMouse.z<=0.)m.xy=vec2(.5)+vec2(cos(iTime),sin(iTime*1.61))*.3*ViewZoom\n ;else m=fra(iMouse.xy)\n ;vec3 c=vec3(0)\n ;float phi=sqrt(5.)*.5-.5\n ;for(float i=0.;i<SAMPLES;i++\n){\n  ;float scale=1.//pi //some values make more sense, i have no clue why-\n  //;float t=(i+hash1(u.x-u.y+i+iTime))/SAMPLES*2.*pi\n  ;float t=(i+GetBayerFromCoordLevel(u*phi*ViewZoom*iResolution.x+i+iTime*1.61)/scale)/SAMPLES*2.*pi*scale\n  ;c+=trace(u,cs(t),m)\n  ;}\n ;c/=SAMPLES\n ;fragColor=vec4(c*2.,1);}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtcfzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3235, 3235, 3252, 3252, 3275], [3275, 3275, 3292, 3292, 3315], [3315, 3315, 3332, 3332, 3348], [3476, 3476, 3493, 3493, 3514], [3514, 3514, 3531, 3531, 3558], [3558, 3558, 3575, 3575, 3608], [3667, 3755, 3771, 3771, 3787], [3788, 3788, 3804, 3804, 3818], [3819, 3819, 3835, 3835, 3845], [3846, 3846, 3862, 3862, 3878], [3879, 3879, 3895, 3895, 3910], [3911, 3911, 3927, 3927, 3942], [3943, 3943, 3959, 3959, 3969], [5197, 5310, 5340, 5340, 5374], [5374, 5433, 5464, 5464, 5499], [5499, 5562, 5584, 5584, 5609], [5610, 5610, 5633, 5633, 5659], [5756, 5756, 5785, 5785, 5855], [5857, 5857, 5881, 5902, 5948], [5950, 5950, 6013, 6013, 6041], [6043, 6043, 6070, 6070, 6394], [6396, 6396, 6432, 6432, 6565], [6567, 6636, 6720, 6720, 6880], [6882, 6974, 7017, 7017, 7571]], "test": "valid"}
{"id": "XtdBW8", "name": "Bouncy line thing.", "author": "scratch13764", "description": "IT WORKS YEASS\n", "tags": ["line", "distance", "point"], "likes": 0, "viewed": 63, "published": "Public", "date": "1539407072", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= 0.5; //Puts the origin at the center of the screen\n\n    float col;\n        \n    float lm = sin(iTime); //slope\n    float lb = sin(iTime*0.8)/3.0; //intercept\n    \n//Slope/intercept declarations manipulate line\n    //second line\n    float lmp = 0.0-(1.0/lm); //calculates the slope of the perpendicular line\n    float lbp = uv.y-lmp*uv.x; //and the intercept\n    \n    //Intersection\n    float ix = (lbp-lb)/(lm-lmp); //Intersection Y\n    float iy = lm*(ix)+lb; //Intersection X based off of the first equation\n    //distance\n    float dist = sqrt(pow((uv.x - ix),2.0)+pow((uv.y - iy),2.0));\n    \n    col = smoothstep(0.1,0.0,dist);\n                     \n    fragColor = vec4(vec3(col),1.0); //OOH shiny\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtdBW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 816]], "test": "valid"}
{"id": "XtdfD8", "name": "Little Match Girl2", "author": "PianiGiani", "description": "An experiment with movement & lines", "tags": ["lines", "movement", "sines"], "likes": 4, "viewed": 197, "published": "Public", "date": "1539432791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n#define WD 2.\n#define nTime (iTime*0.6)+500.\n#define FACT vec2(0.2,0.2)\n\nfloat Dline(vec2 p, vec2 a, vec2 b) {\n\t// line drawing function from BigWings\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.1);\n    return length(pa-ba*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.); // vec3(.6,.9,.02);\n    \n    for ( float i = 0.; i<10.; i+=0.5)\n    {\n    for ( float ii = 0.; ii<10.; ii+=0.6)\n    {\n    float d1 = sin(ii+nTime)+cos(i);\n    float d2 = sin(nTime)-cos(i);\n    float d3 = cos(nTime+i);\n    float d4 = cos(nTime+ii)+sin(nTime+ii);\n    \n    float d = Dline(uv, vec2(d1,d2)*FACT, vec2(d3,d4)*FACT);\n\n    float m = S(WD/200., (WD/200.)-(0.02), d)*WD;\n    \n    float col1 = (cos(nTime+ii)/2.+0.6);\n    float col2 = (sin((ii+nTime))/2.+0.5);\n    float col3 = (cos((i+nTime)/9.)/ii+0.5);\n        \n    col = max(col,vec3(m*col1,m*col2,m*col2));\n    }\n    }\n    \n    // Output to screen\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtdfD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 145, 185, 307], [310, 310, 367, 417, 1179]], "test": "valid"}
{"id": "XtdfW8", "name": "clamp to border emulation", "author": "kusma", "description": "This is a prototype for emulation-code of clamp to border behavior on vulkan.\n\nTODO: Mipmapping should be possible by using textureSize(sampler, textureQueryLod(sampler, uv).x) instead of the passed size. But, you know, WebGL ¯\\_(ツ)_/¯", "tags": ["texture", "clamping"], "likes": 3, "viewed": 578, "published": "Public", "date": "1539416108", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Emulate GL_CLAMP and GL_CLAMP_TO_BORDER on top of GL_CLAMP_TO_EDGE\n *\n * sampler needs to have GL_TEXTURE_WRAP_S and/or GL_TEXTURE_WRAP_T set to\n * GL_CLAMP_TO_EDGE for the emulated dimensions for this to work as expected.\n */\n\nvec2 textureQueryLod(sampler2D sampler, vec2 P)\n{\n    vec2 pos = P * vec2(textureSize(sampler, 0)); // OpImageQuerySizeLod\n    vec2 ddx = dFdx(pos);\n    vec2 ddy = dFdy(pos);\n    float tmp = max(dot(ddx, ddx), dot(ddy, ddy));\n    float lambda = log2(tmp) * 0.5; // log2(x)/2 == log2(sqrt(x))\n    // HACK: there's really much more that should be going on here, but we need to know about the sampler-state to figure that bit out.\n    float lod = max(lambda, 0.0);\n    return vec2(lod);\n}\n\nvec4 textureBorderClamp(sampler2D sampler, vec2 uv, vec2 size, vec4 borderColor, bvec2 wrap)\n{\n#if 1\n    float lod = textureQueryLod(sampler, uv).y + 1.5 + cos(iTime); // OpImageQueryLod\n    ivec2 size0 = textureSize(sampler, int(floor(lod))); // OpImageQuerySizeLod\n    ivec2 size1 = textureSize(sampler, int(ceil(lod))); // OpImageQuerySizeLod\n    size = mix(vec2(size0), vec2(size1), fract(lod));\n    vec4 ret = textureLod(sampler, uv, lod); // OpImageSampleExplicitLod\n#else\n    vec4 ret = texture(sampler, uv); // OpImageSampleImplicitLod\n#endif\n\n    vec2 limit = vec2(1.0, 0.5); // 0.5 for GL_CLAMP, 1.0 for GL_CLAMP_TO_BORDER\n    vec2 factors = clamp(0.5 + (abs(uv - 0.5) - 0.5) * vec2(size), vec2(0.0), limit);    \n    if (wrap.x)\n    \tret = mix(ret, borderColor, factors.x);\n    if (wrap.y)\n        ret = mix(ret, borderColor, factors.y);\n    return ret;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y) + 0.5;\n\n    vec4 borderColor = vec4(0.5 + 0.5 * cos(iTime), 0.5, 0.5 + 0.5 * sin(iTime), 1.0);\n    fragColor = textureBorderClamp(iChannel0, uv, iChannelResolution[0].xy, borderColor, bvec2(true, true));\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtdfW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 231, 280, 280, 716], [718, 718, 812, 812, 1583], [1589, 1589, 1646, 1646, 1937]], "test": "error"}
{"id": "XtdfWr", "name": "Voxel Edges teste", "author": "djtornados", "description": "teste", "tags": ["teste"], "likes": 1, "viewed": 542, "published": "Public API", "date": "1539217615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//\n// Shading technique explained here:\n//\n// http://www.iquilezles.org/www/articles/voxellines/voxellines.htm\n//\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec3 m = abs( n );\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn x*m.x + y*m.y + z*m.z;\n}\n\nfloat mapTerrain( vec3 p )\n{\n\tp *= 0.1; \n\tp.xz *= 0.6;\n\t\n\tfloat time = 0.5 + 0.15*iTime;\n\tfloat ft = fract( time );\n\tfloat it = floor( time );\n\tft = smoothstep( 0.7, 1.0, ft );\n\ttime = it + ft;\n\tfloat spe = 1.4;\n\t\n\tfloat f;\n    f  = 0.5000*noise( p*1.00 + vec3(0.0,1.0,0.0)*spe*time );\n    f += 0.2500*noise( p*2.02 + vec3(0.0,2.0,0.0)*spe*time );\n    f += 0.1250*noise( p*4.01 );\n\treturn 25.0*f-10.0;\n}\n\nvec3 gro = vec3(0.0);\n\nfloat map(in vec3 c) \n{\n\tvec3 p = c + 0.5;\n\t\n\tfloat f = mapTerrain( p ) + 0.25*p.y;\n\n    f = mix( f, 1.0, step( length(gro-p), 5.0 ) );\n\n\treturn step( f, 0.5 );\n}\n\nvec3 lig = normalize( vec3(-0.4,0.3,0.7) );\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir )\n{\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = -1.0;\n\tvec3 mm = vec3(0.0);\n\tfor( int i=0; i<128; i++ ) \n\t{\n\t\tif( map(pos)>0.5 ) { res=1.0; break; }\n\t\tmm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\tvec3 nor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    // intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn t*res;\n}\n\nvec3 path( float t, float ya )\n{\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.0,1.2) + vec2(0.1,0.9) );\n\t     p +=  50.0*sin( 0.04*t*vec2(1.3,1.0) + vec2(1.0,4.5) );\n\t\n\treturn vec3( p.x, 18.0 + ya*4.0*sin(0.05*t), p.y );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nfloat maxcomp( in vec4 v )\n{\n    return max( max(v.x,v.y), max(v.z,v.w) );\n}\n\nfloat isEdge( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\n{\n    vec2 st = 1.0 - uv;\n\n    // edges\n    vec4 wb = smoothstep( 0.85, 0.99, vec4(uv.x,\n                                           st.x,\n                                           uv.y,\n                                           st.y) ) * ( 1.0 - va + va*vc );\n    // corners\n    vec4 wc = smoothstep( 0.85, 0.99, vec4(uv.x*uv.y,\n                                           st.x*uv.y,\n                                           st.x*st.y,\n                                           uv.x*st.y) ) * ( 1.0 - vb + vd*vb );\n    return maxcomp( max(wb,wc) );\n}\n\nfloat calcOcc( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\n{\n    vec2 st = 1.0 - uv;\n\n    // edges\n    vec4 wa = vec4( uv.x, st.x, uv.y, st.y ) * vc;\n\n    // corners\n    vec4 wb = vec4(uv.x*uv.y,\n                   st.x*uv.y,\n                   st.x*st.y,\n                   uv.x*st.y)*vd*(1.0-vc.xzyw)*(1.0-vc.zywx);\n    \n    return wa.x + wa.y + wa.z + wa.w +\n           wb.x + wb.y + wb.z + wb.w;\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\n\t\n    // raymarch\t\n\tvec3 vos, dir;\n\tfloat t = castRay( ro, rd, vos, dir );\n\tif( t>0.0 )\n\t{\n        vec3 nor = -dir*sign(rd);\n        vec3 pos = ro + rd*t;\n        vec3 uvw = pos - vos;\n\t\t\n\t\tvec3 v1  = vos + nor + dir.yzx;\n\t    vec3 v2  = vos + nor - dir.yzx;\n\t    vec3 v3  = vos + nor + dir.zxy;\n\t    vec3 v4  = vos + nor - dir.zxy;\n\t\tvec3 v5  = vos + nor + dir.yzx + dir.zxy;\n        vec3 v6  = vos + nor - dir.yzx + dir.zxy;\n\t    vec3 v7  = vos + nor - dir.yzx - dir.zxy;\n\t    vec3 v8  = vos + nor + dir.yzx - dir.zxy;\n\t    vec3 v9  = vos + dir.yzx;\n\t    vec3 v10 = vos - dir.yzx;\n\t    vec3 v11 = vos + dir.zxy;\n\t    vec3 v12 = vos - dir.zxy;\n \t    vec3 v13 = vos + dir.yzx + dir.zxy; \n\t    vec3 v14 = vos - dir.yzx + dir.zxy ;\n\t    vec3 v15 = vos - dir.yzx - dir.zxy;\n\t    vec3 v16 = vos + dir.yzx - dir.zxy;\n\n\t\tvec4 vc = vec4( map(v1),  map(v2),  map(v3),  map(v4)  );\n\t    vec4 vd = vec4( map(v5),  map(v6),  map(v7),  map(v8)  );\n\t    vec4 va = vec4( map(v9),  map(v10), map(v11), map(v12) );\n\t    vec4 vb = vec4( map(v13), map(v14), map(v15), map(v16) );\n\t\t\n\t\tvec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\n\t\t\t\n        // wireframe\n        float www = 1.0 - isEdge( uv, va, vb, vc, vd );\n        \n        vec3 wir = smoothstep( 0.4, 0.5, abs(uvw-0.5) );\n        float vvv = (1.0-wir.x*wir.y)*(1.0-wir.x*wir.z)*(1.0-wir.y*wir.z);\n\n        col = 2.0*texture( iChannel1,0.01*pos.xz ).zyx; \n        col += 0.8*vec3(0.1,0.3,0.4);\n        col *= 0.5 + 0.5*texcube( iChannel2, 0.5*pos, nor ).x;\n        col *= 1.0 - 0.75*(1.0-vvv)*www;\n\t\t\n        // lighting\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n        float sky = 0.5 + 0.5*nor.y;\n        float amb = clamp(0.75 + pos.y/25.0,0.0,1.0);\n        float occ = 1.0;\n\t\n        // ambient occlusion\n        occ = calcOcc( uv, va, vb, vc, vd );\n        occ = 1.0 - occ/8.0;\n        occ = occ*occ;\n        occ = occ*occ;\n        occ *= amb;\n\n        // lighting\n        vec3 lin = vec3(0.0);\n        lin += 2.5*dif*vec3(1.00,0.90,0.70)*(0.5+0.5*occ);\n        lin += 0.5*bac*vec3(0.15,0.10,0.10)*occ;\n        lin += 2.0*sky*vec3(0.40,0.30,0.15)*occ;\n\n        // line glow\t\n        float lineglow = 0.0;\n        lineglow += smoothstep( 0.4, 1.0,     uv.x )*(1.0-va.x*(1.0-vc.x));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.x )*(1.0-va.y*(1.0-vc.y));\n        lineglow += smoothstep( 0.4, 1.0,     uv.y )*(1.0-va.z*(1.0-vc.z));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.y )*(1.0-va.w*(1.0-vc.w));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y*      uv.x )*(1.0-vb.x*(1.0-vd.x));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y* (1.0-uv.x))*(1.0-vb.y*(1.0-vd.y));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*(1.0-uv.x))*(1.0-vb.z*(1.0-vd.z));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*     uv.x )*(1.0-vb.w*(1.0-vd.w));\n\t\t\n        vec3 linCol = 2.0*vec3(5.0,0.6,0.0);\n        linCol *= (0.5+0.5*occ)*0.5;\n        lin += 3.0*lineglow*linCol;\n\t\t\n        col = col*lin;\n        col += 8.0*linCol*vec3(1.0,2.0,3.0)*(1.0-www);//*(0.5+1.0*sha);\n        col += 0.1*lineglow*linCol;\n        col *= min(0.1,exp( -0.07*t ));\n\t\n        // blend to black & white\t\t\n        vec3 col2 = vec3(1.3)*(0.5+0.5*nor.y)*occ*www*(0.9+0.1*vvv)*exp( -0.04*t );;\n        float mi = sin(-1.57+0.5*iTime);\n        mi = smoothstep( 0.70, 0.75, mi );\n        col = mix( col, col2, mi );\n\t}\n\n\t// gamma\t\n\tcol = pow( col, vec3(0.45) );\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // inputs\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n    if( iMouse.w<=0.00001 ) mo=vec2(0.0);\n\t\n\tfloat time = 2.0*iTime + 50.0*mo.x;\n    // camera\n\tfloat cr = 0.2*cos(0.1*iTime);\n\tvec3 ro = path( time+0.0, 1.0 );\n\tvec3 ta = path( time+5.0, 1.0 ) - vec3(0.0,6.0,0.0);\n\tgro = ro;\n\n    mat3 cam = setCamera( ro, ta, cr );\n\t\n\t// build ray\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    vec3 rd = normalize( cam * vec3(p.xy,-2.5) );\n\n    vec3 col = render( ro, rd );\n    \n\t// vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tfloat time = 1.0*iTime;\n\n    float cr = 0.0;\n\tvec3 ro = path( time+0.0, 0.0 ) + vec3(0.0,0.7,0.0);\n\tvec3 ta = path( time+2.5, 0.0 ) + vec3(0.0,0.7,0.0);\n\n    mat3 cam = setCamera( ro, ta, cr );\n\n    vec3 col = render( ro + cam*fragRayOri, cam*fragRayDir );\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtdfWr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[240, 240, 266, 266, 476], [478, 478, 531, 531, 683], [685, 685, 713, 713, 1088], [1113, 1113, 1136, 1136, 1275], [1322, 1322, 1393, 1393, 1930], [1932, 1932, 1964, 1964, 2148], [2150, 2150, 2202, 2202, 2380], [2382, 2382, 2410, 2410, 2458], [2460, 2460, 2524, 2524, 3077], [3079, 3079, 3144, 3144, 3485], [3487, 3487, 3526, 3526, 7070], [7072, 7072, 7129, 7144, 7867], [7869, 7869, 7963, 7963, 8262]], "test": "error"}
{"id": "XttBDB", "name": "Static Race", "author": "dedmoros", "description": "Just a sketch", "tags": ["sinewavepattern"], "likes": 1, "viewed": 384, "published": "Public API", "date": "1540873093", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1416\n#define AR 1./iResolution\n\nfloat nsin(float x) {\n\treturn sin(x)*.5+.5;\n}\n\nfloat line(vec2 u, float y, float thickness) {\n\treturn step(u.y+y, AR.y*thickness)-step(u.y+y,-AR.y*thickness);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float animation = nsin(iTime*.25);\n    float amplitude = min(iTime*.5, .5);\n\tfloat y1 = sin(uv.x*PI*350.+500.*animation)*amplitude;\n    float y2 = sin(uv.x*PI*350.+500.*animation+.03)*amplitude;\n    float y3 = sin(uv.x*PI*350.+500.*animation+.05)*amplitude;\n    float c1 = line(uv-.5, y1, 5.);\n    float c2 = line(uv-.5, y2, 8.);\n    float c3 = line(uv-.5, y3, 10.);\n    vec3 col = vec3(c1,c2,c3);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttBDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 66, 66, 90], [92, 92, 138, 138, 205], [207, 207, 264, 314, 813]], "test": "valid"}
{"id": "XttBDS", "name": "Fire-esque Color and Movement", "author": "Nihilistic_Furry", "description": "Uses perlin noise with rotating vectors to create a natural movement pattern, and uses visual effects to make that look a bit like fire.", "tags": ["perlinnoise", "fire"], "likes": 3, "viewed": 270, "published": "Public API", "date": "1540854949", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Random normalized vectors with numbers from random.org (changable)\nconst vec2 x0y0 = vec2 (0.632267, -0.774750);\nconst vec2 x1y0 = vec2 (0.697355, 0.716726);\n\n// Ease function\nfloat ease (float p) \n{\n    return p * p * p * (p * (p * 6.0 - 15.0) + 10.0); \n}\n\n// Creates perlin noise for \nfloat perlin (float x, float y)\n{\n    vec2 xy00 = vec2 (x, y);\n    vec2 xy10 = vec2 (x - 1.0, y);\n    vec2 xy01 = vec2 (x, y - 1.0);\n    vec2 xy11 = vec2 (x - 1.0, y - 1.0);\n    \n    vec2 x0y1 = vec2 (cos (iTime * 2.0), sin (iTime * 5.0));\n    vec2 x1y1 = vec2 (cos (iTime * 3.0), sin (iTime * 3.0));\n    \n    \n    float s = dot (x0y0, xy00);\n    float t = dot (x1y0, xy10);\n    float u = dot (x0y1, xy01);\n    float v = dot (x1y1, xy11);\n    \n    float sx = ease (x);\n    float sy = ease (y);\n    \n    float a = s + sx * (t - s);\n    float b = u + sx * (v - u);\n    \n    return a + sy * (b - a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Perlin noise root\n    float per = perlin (uv.x, uv.y);\n    \n    // Fix noise\n    per = (per + 1.0) * 0.5;\n    \n    // Output to screen\n    fragColor = vec4((per * 0.4 + 0.6) / (1.0 - uv.y * 0.3), per * 0.5 / (0.8 - uv.y * 0.5), 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttBDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 179, 202, 202, 259], [261, 290, 323, 323, 888], [890, 890, 947, 997, 1288]], "test": "valid"}
{"id": "XttBR2", "name": "Nebshed", "author": "Thominator", "description": "Using noise chaining to create a colored gaz effect", "tags": ["noise"], "likes": 3, "viewed": 108, "published": "Public", "date": "1540316307", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 light = vec3(0, 0, 0);\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n//2D Noise function from user iq\nfloat hash(vec2 p)\n{\n    p  = 45.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n//3D Noise function from user iq\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat rand(vec2 co){\n    return 2.0*cos(fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \t//Pixel coordinate between -1 and 1\n  \tvec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n    //Pixel coordinate between 0 and 1\n    vec2 p = fragCoord.xy / iResolution.xy;\n    //Pixel coordinate adapted to the resolution\n    vec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);\n    \n    //Computing the first fractal noise value\n\tfloat f = 0.0;\n\tuv *= 8.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n    \n    float f2 = f;\n    \n    //Using the noise value to give the point a depth\n\tvec3 point1 = vec3(pixel, 1.0+f);\n    \n    //Transformation for animation purpose\n    vec3 diff = light-point1;\n    float c = 1.0-dot(diff, diff);\n    float a=iTime*0.025;\n  \tpoint1 = rotateZ(point1, a);\n    point1 *= 1.5+cos(iTime*0.05)/2.0;\n    \n\t//Computing the second factal noise value using the point previously calculated\n    vec3 q = 8.0*point1;\n    f  = 0.5000*noise( q ); q = m3*q*2.01;\n    f += 0.2500*noise( q ); q = m3*q*2.02;\n    f += 0.1250*noise( q ); q = m3*q*2.03;\n    f += 0.0625*noise( q ); q = m3*q*2.01;\n    \n    vec3 point2 = vec3(pixel, 0.3+f);\n\n\tdiff = light-point2;\n    c = 0.8-dot(diff, diff);\n    fragColor = vec4(c*c*f2, 0.5*c*c*c*c*f, c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttBR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 193, 193, 291], [293, 293, 324, 324, 423], [425, 425, 456, 456, 555], [557, 590, 610, 610, 714], [716, 716, 742, 742, 1036], [1039, 1072, 1092, 1092, 1187], [1189, 1189, 1215, 1215, 1689], [1691, 1691, 1711, 1711, 1792], [1794, 1794, 1851, 1889, 3184]], "test": "valid"}
{"id": "XttBR4", "name": "Nature-Entangling of Flower Buds", "author": "rlarp", "description": "Attempt to create the effect of (basic) flower buds getting entangled", "tags": ["education", "organic", "nature", "school", "flowers", "buds", "entangled", "entangling"], "likes": 0, "viewed": 88, "published": "Public", "date": "1538786357", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{ // Basic constructor for shape \n  float dist; // Distance from center\n  vec4 color; // Color of shape \n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec3 v) { // Utility function that utilizes the fract() function to create recurring patterns.\n  return fract(tan(dot(v*100.1, vec3(400.654, 160.546, 100.)))*46.2);\n}\n\nmat2 rot(float a){ // Rotates and gives the rotated matrix \n  float r = cos(a);\n  float f = sin(a);\n  return mat2(-r, -f, f, -r);\n}\n\nfloat sphere(vec3 v, float r){ // Creates a sphere \n  return length(v)-r;\n}\n\n\nfloat pole(vec2 v, float r){ // Creates a pole \n  return length(v)-r;\n}\n\nfloat mixColors(float r, float v, float z){ \n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\n\nfloat mixShapes(float v, float f, float r){ // Mixes both the color and the shape of objects.\t\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n//=======================\n\nShape vines(vec3 c){ // Creates a vine shape (kind of an extension of Shape\n  Shape shape; // Creates basic Shape first\n  float vine;\n  shape.dist = 100.; // Draw Distance\n  shape.color = vec4(3.); // Initial Color\n\n  // Shape Attributes\n  float twist = 5.; // Vine Repeat\n  float vineOffset = 5.; // Leaf Offset\n\n\n  // Stems\n    random(c);// Passes vec3 c through the random function first\n  \tvec3 i = c;\n    i.xz *= rot(c.y*0.2+iTime*0.2); // Rotates the vines about the xz system.\n    float detail = pModPolar(i.xz, twist); \n    float x = mix(5., 5.1, mod(detail, 1.)); // Small Ripples\n    i.x -= vineOffset; // Offset Stems\n  \tfloat stemWidth = .15;\n    //stemWidth/= 10000000.;\n  \tvine = pole(i.xz, stemWidth+0.02*sin(i.y*x));\n\n\n  vec4 color = vec4(0.4, 1.0, 0.4, 10.); // Initialize vine color\n\n  shape.dist = vine;\n  shape.color = color;\n\n  return shape; \n}\n\nShape orb(vec3 c){\n  Shape shape;\n  float orb;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n\n  // Stems\n  vec3 i = c;\n    //i.xz *= rot(iTime);\n    i.y = repeat(i.y, 2.5); // Repeats the orbs in they y direction every 2.5 pixels.\n    i.y = abs(i.y)-2.5;\n    i.x = abs(i.x)-1.5;\n    orb = sphere(i, cos(sin(iTime)*0.25)*2.25);\n    \n\n  vec4 color = vec4(0.8, 1., 0.8, 1.); // Initializes color\n\n  shape.dist = orb;\n  shape.color = color;\n\n  return shape;\n}\n\n \nShape map(vec3 c, vec3 c1){\n  Shape vines = vines(c); // Create vines\n  Shape orbs = orb(c); // Create orbs\n \n  float df = mixShapes(vines.dist, orbs.dist, 1.); // Mix vines and orbs\n  vines.dist = df;\n    \n  vines.color = mix(vines.color, \n                    orbs.color*0.8, \n                    mixColors(orbs.dist*=0.9, vines.dist, 0.0)); // Mixes the colors \n\treturn vines; // Returns everything as one \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y; // Normalize \n  \n  \n  vec3 cam = vec3(0., sin(iTime)-3.5, -10.); // Dictates where the camera is/will move. \n  random(cam+0.5);\n  vec3 f = normalize(vec3(v, .9));\n  random(f);\n  vec3 scene = cam;\n  random(scene);\n  vec3 scene1 = cam *= 5.; \n  fragColor = vec4(0.2);\n\n  // Ray Marcher\n  for(float z = 0.001 ; z <= 10.; z += 0.1){\n    Shape c = map(scene, scene1); // Calc SDF\n    if(c.dist < 0.4){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\t\n\n  }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttBR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 239, 261, 346, 418], [420, 420, 438, 479, 551], [553, 553, 583, 604, 628], [631, 631, 659, 678, 702], [704, 704, 747, 747, 791], [794, 794, 837, 888, 954], [956, 956, 995, 995, 1151], [1179, 1179, 1199, 1254, 2044], [2046, 2046, 2064, 2064, 2537], [2541, 2541, 2568, 2568, 2956], [2958, 2958, 3015, 3015, 3587]], "test": "valid"}
{"id": "XttBRj", "name": "Multicolored recursive FBM", "author": "dust", "description": "Experimenting with computing multicolored + recursive fbm() values. Still using Perlin noise as a basis function.", "tags": ["procedural", "2d", "2d", "fractal", "noise", "noise", "perlinnoise", "fbm", "perlin", "rgb", "recursive", "fbmnoise"], "likes": 4, "viewed": 127, "published": "Public", "date": "1540289618", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Slow, high-quality 2D hash adapted from nimitz's\n// WebGL2 hash collection\n// (https://www.shadertoy.com/view/Xt3cDn)\nvec2 hash22(uvec2 p)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n    uint h32 = p.y + PRIME32_5 + p.x*PRIME32_3;\n    h32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17))); //Initial testing suggests this line could be omitted for extra perf\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    h32 = h32^(h32 >> 16);\n    uvec2 rz = uvec2(h32, h32*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);\n}\n\n// Specialty Perlin ease-in/out function\nvec2 soften(vec2 t)\n{\n    vec2 t3 = t * t * t;\n    vec2 t4 = t3 * t;\n    vec2 t5 = t4 * t;\n    return 6.0f * t5 - \n           15.0f * t4 +\n           10.0f * t3;\n}\n\n// Perlin noise function, taking corner + pixel positions as input\nfloat Perlin(vec2 uv)\n{\n    // Find corner coordinates\n    vec4 lwrUpr = vec4(floor(uv), ceil(uv));\n    mat4x2 crnrs = mat4x2(lwrUpr.xw, lwrUpr.zw,\n                          lwrUpr.xy, lwrUpr.zy);\n    \n    // Generate gradients at each corner\n    mat4x2 dirs = mat4x2(hash22(uvec2(floatBitsToUint(crnrs[0]))),\n                         hash22(uvec2(floatBitsToUint(crnrs[1]))),\n                         hash22(uvec2(floatBitsToUint(crnrs[2]))),\n                         hash22(uvec2(floatBitsToUint(crnrs[3]))));\n    \n    // Shift gradients into [-1...0...1]\n    dirs *= 2.0f;\n    dirs -= mat4x2(vec2(1.0f), vec2(1.0f), \n                   vec2(1.0f), vec2(1.0f));\n    \n    // Normalize\n    dirs[0] = normalize(dirs[0]);\n    dirs[1] = normalize(dirs[1]);\n    dirs[2] = normalize(dirs[2]);\n    dirs[3] = normalize(dirs[3]);\n    \n    // Find per-cell pixel offset\n    vec2 offs = mod(uv, 1.0f);\n    \n    // Compute gradient weights for each corner; take each offset relative\n    // to corners on the square in-line\n    vec4 values = vec4(dot(dirs[0], (offs - vec2(0.0f, 1.0f))),\n                       dot(dirs[1], (offs - vec2(1.0f))),\n                       dot(dirs[2], (offs - vec2(0.0f))),\n                       dot(dirs[3], (offs - vec2(1.0f, 0.0f))));\n    \n    // Return smoothly interpolated values\n    vec2 softXY = soften(offs);\n    return mix(mix(values.z, \n                   values.w, softXY.x),\n               mix(values.x, \n                   values.y, softXY.x),\n               softXY.y);\n}\n\n// Compute fractal noise for a given pixel position\n//#define SCALING_FBM\nfloat fbm(vec2 uv)\n{\n    const uint depth = 5u;\n    const vec2 dFreq = vec2(1.01f, 1.08f);\n    const float dAmpl = 1.1f;\n    vec2 sfreq = vec2(1.01f); // Starting noise scaling frequency\n    vec2 rfreq = vec2(1.1f); // Starting noise rotational frequency\n    float ampl = 0.25f; // Starting noise intensity\n    float f = 0.0f;\n    for (uint i = 0u; i < depth; i += 1u)\n    {\n        f += ampl * abs(Perlin(uv));\n        float fi = float(i);\n        uv += vec2(cos(fi), \n                   sin(fi)) * (iTime * 0.25f) * rfreq;\n        #ifdef SCALING_FBM\n        \tuv *= sfreq;\n            sfreq *= dFreq + vec2(0.1f * float(i));\n        #endif\n        rfreq *= dFreq + vec2(0.1f * float(i));\n        ampl *= dAmpl;\n    }\n    return f;\n}\n\n//#define NOISE_MIRR\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to [1.0 / [cellSize]])\n    const float cellSize = 0.0825f;\n    #ifdef NOISE_MIRR\n    \tfloat hAspect = (iResolution.x / iResolution.y) * 0.5f;\n    \tvec2 uv = abs((fragCoord / iResolution.y) - vec2(hAspect, 0.5f)) / cellSize;\n    #else\n    \tvec2 uv = (fragCoord / iResolution.y) / cellSize;\n    #endif\n    // Generate per-channel fbm()\n    // fbm(p + fbm(p + fbm(p)))\n    // FBM recursion function from iq through the Book of Shaders:\n    // http://www.iquilezles.org/www/articles/warp/warp.htm\n    // https://thebookofshaders.com/13/\n    float fbm0 = fbm(uv + vec2(\n        \t\t\t fbm(uv + vec2(\n                    \t fbm(uv)))));\n    vec2 uu = uv + vec2(1.0f, 0.0f);\n    float fbm1 = fbm(uu + vec2(\n        \t\t\t fbm(uu + vec2(\n                    \t fbm(uu)))));\n    vec2 vv = uv + vec2(0.0f, 1.0f);\n    float fbm2 = fbm(vv + vec2(\n        \t\t\t fbm(vv + vec2(\n                    \t fbm(vv)))));\n\tvec3 rgb = vec3(fbm0, fbm1, fbm2);\n    \n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttBRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 122, 144, 144, 653], [655, 696, 717, 717, 859], [861, 928, 951, 982, 2432], [2434, 2508, 2528, 2528, 3241], [3243, 3264, 3319, 3386, 4351]], "test": "valid"}
{"id": "XttBRX", "name": "Distance field dance A", "author": "Sleng", "description": "Variation of distance field explanation from https://thebookofshaders.com/07/?lan=ru", "tags": ["distancefield", "abstract", "ornament"], "likes": 11, "viewed": 289, "published": "Public API", "date": "1540460460", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Mark Serdtse\n// Variation of distance field explanation \n// from https://thebookofshaders.com/07/?lan=ru\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 st = fragCoord/iResolution.xy;\n    \n  st.x -= 0.2; \n  st.x *= iResolution.x/iResolution.y;\n    \n  vec3 color = 0.5 + 0.5*cos(iTime+st.xyx+vec3(0,2,4));\n  float d = 0.0;\n    \n  st = st *2.-1.;\n    \n  float sin_factor = sin(iTime/5.);\n  float cos_factor = cos(iTime/5.);\n    \n  st = st* mat2(cos_factor, sin_factor, -sin_factor, cos_factor);\n    \n\n  d = length(abs(sin(abs(st*2.)+iTime))*(sin(abs(cos(st.x)*sin(st*5.))*.8)/2.));\n\n    \n  float mask = sin(d*50.0);\n      \n  color = color*mask;\n    \n  fragColor = vec4(color,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttBRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 166, 166, 702]], "test": "valid"}
{"id": "XttBW7", "name": "Tri Scale Truchet", "author": "Shane", "description": "A tri-scale Truchet pattern, constructed with non-overlapping tiles.", "tags": ["truchet", "pattern", "multiscale", "quadtree"], "likes": 35, "viewed": 878, "published": "Public API", "date": "1540385520", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t\n\tTri Scale Truchet\n\t-----------------\n\n\tThis is just a demonstration to show that it's possible to produce a\n\tmultiscale Truchet pattern with non-overlapping tiles. The reason \n\tthat is of interest is that it's faster and can be more easily \n\tadapted to a 3D situation. By the way, I'll put one of those together\n\tpretty soon.\n\n\tThis was a pretty easy example to understand... before I kind of went \n    overboard and filled it with defines and esoteric aesthetic code.\n\n\tThankfully, I quickly put together a minimal dual level Truchet example\n\tto accompany it, which is much easier to digest -- The link is below,\n    for anyone interested.\n\n    \n    // Far less code, and much easier to understand.\n\tMinimal Dual-Level Truchet - Shane\n    https://www.shadertoy.com/view/ltcfz2\n\n\t// More elaborate quadtree example.\n\tQuadtree Truchet - Shane\n\thttps://www.shadertoy.com/view/4t3BW4\n\n\t// Abje always has an interesting way of coding things. :)\n\tblack and white truchet quadtree - abje\n\thttps://www.shadertoy.com/view/MtcBDM\n\n\n*/\n\n\n// Display the background grid lines.\n#define SHOW_GRID\n\n// Three levels or two. Comment it out for two.\n#define TRI_LEVEL\n\n// Various curve shapes, for anyone curious.\n// Circle: 0, Octagon: 1, Dodecahedron: 2, Hexadecagon: 3\n#define SHAPE 0\n\n// Just the arcs.\n//#define ARCS_ONLY\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p){ \n\n    // Faster, but doesn't disperse things quite as nicely.\n    return fract(vec2(262144, 32768)*sin(dot(p, vec2(57, 27))));\n    \n}\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values, but that's not an issue here.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 27, 57, 84) + dot(i, vec2(27, 57)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\n// Distance formula with various shape metrics.\n// See the \"SHAPE\" define above.\nfloat dist(vec2 p){\n    \n    #if SHAPE == 0\n    // Standard circular shaped curves.\n    return length(p);\n    #else\n        p = abs(p);\n        #if SHAPE == 1\n        \t// Octagon.\n        \treturn max(max(p.x, p.y), (p.x + p.y)*.7071);\n        #elif SHAPE == 2\n        \t// Dodecahedron.\n        \tvec2 p2 = p*.8660254 + p.yx*.5;\n        \treturn max(max(p2.x, p2.y), max(p.x, p.y));\n        #else\n        \t// Hexadecagon (regular, 16 sideds) -- There'd be a better formula for this.\n        \tvec2 p2 = r2(3.14159/8.)*p;\n        \tfloat c = max(max(p2.x, p2.y), (p2.x + p2.y)*.7071);\n        \treturn max(c, max(max(p.x, p.y), (p.x + p.y)*.7071));\n        #endif\n    #endif\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Resolution restriction to avoid a blurry, bloated looking image in fullscreen,\n    // This doesn't account for varying PPI, so if you went fullscreen on a high resolution\n    // cell phone, you'd want a higher restriction number. Generally speaking, it's \n    // impossible to make a pixel-precise image look even roughly the same on all systems.\n    // By the way, this was coded on a 17 inch laptop with a 1920 x 1080 resolution on the\n    // 800 x 450 canvas.\n    float iRy = min(iResolution.y, 800.); \n    \n    // Screen coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iRy;\n    \n    // Scaling and translation.\n    vec2 oP = uv*4. + vec2(.5, iTime/2.);\n    \n    // Distance file values.\n    vec4 d = vec4(1e5);\n    \n    // Initial cell dimension.\n    float dim = 1.;\n    \n    // Random entries -- One for each layer. The X values represent the chance that\n    // a tile for that particular layer will be rendered. For instance, the large\n    // tile will have a 35% chance, the middle tiles, 70%, and the remaining smaller\n    // tiles will have a 100% chance. I.e., they'll fill in the rest of the squares.\n    \n    vec2 rndTh[3] = vec2[3]( vec2(.35, .5), vec2(.7, .5), vec2(1, .5));\n    \n    // Set the second level random X value to \"1.\" to ensure that the loop breaks on \n    // the second iteration... which is a long way to say, \"Two levels only.\" :)\n    #ifndef TRI_LEVEL\n    rndTh[0].x = .5; rndTh[1].x = 1.;\n    #endif\n    \n    \n    // Grid line width, and a global diagonal-side variable.\n    const float lwg = .015;\n    float side = 1e5;\n    \n    // Random variable.\n    vec2 rnd = vec2(0);\n    \n    \n    for(int k=0; k<3; k++){\n    \t\n        // Base cell ID.\n\t\tvec2 ip = floor(oP*dim);\n        \n        // Unique random ID for the cell.\n        rnd = hash22(ip);\n\n        \n\t\t// If the random cell ID at this particular scale is below a certain threshold, \n        // render the tile.         \n        if(rnd.x<rndTh[k].x){\n            \n            // Tile construction: By the way, the tile designs you use are limited by your imagination. \n        \t// I chose the ones that seemed most logical at the time -- Arcs and grid vertice circles.\n      \n            // Local cell coordinate.\n            vec2 p = oP - (ip + .5)/dim; // Equivalent to: mod(oP, 1./dim) - .5/dim;\n            \n            // Reusing \"rnd\" to calculate a new random number. Not absolutely necessary,\n            // but I wanted to mix things up a bit more.\n            rnd = fract(rnd*27.63 + float(k*57 + 1));\n           \n            // Grid lines.\n \t        d.y = abs(max(abs(p.x), abs(p.y)) - .5/dim) - lwg/2.;\n\n            \n            // Use the unique random cell number to flip half the tiles vertically, which,\n            // in this case, has the same effect as rotating by 90 degrees.\n            p.y *= rnd.y<.5? 1. : -1.;\n           \n            \n            // Arc width: Arranged to be one third of the cell side length. This is half that\n            // length, but it gets doubled below.\n            float aw = .5/3./dim;\n\n            // Tile rendering: The arcs, circles, etc. I made the tiles up as I went along,\n            // but it's just a positioning of arcs and circles, so I'm hoping it's pretty \n            // straight forward. \n            float c1 = abs(dist(p - vec2(.5)/dim) - .5/dim) - aw;\n            \n            // Arcs only, or a mixture of arcs and circles.\n            #ifdef ARCS_ONLY\n            float c2 = abs(dist(p - vec2(-.5)/dim) - .5/dim) - aw;\n            #else\n            float c2;\n            if(fract(rnd.y*57.53 +.47)<.35) {\n                c2 = dist(p - vec2(-.5, 0)/dim) - aw;\n                c2 = min(c2, dist(p - vec2(0, -.5)/dim) - aw);\n            }\n            else c2 = abs(dist(p - vec2(-.5)/dim) - .5/dim) - aw;\n            #endif\n            \n            // Combining the arc and\\or circle elements.\n            d.x = min(c1, c2);\n            \n            // Determining which side of the diagonal the blue neon tri-level lines are on.\n            // That way, you can blink them individually.\n            side = c1>c2? 0. : 1.57*(rnd.y*.5 + 1.);\n            \n            \n            // Negate the arc distance field values on the second tile.\n            d.x *= k==1? -1. : 1.;\n            \n             \n            // Four mid border circles. There's some 90 degree rotation and repeat\n            // trickery hidden in amongst this. If you're not familiar with it, it's\n            // not that hard, and gets easier with practice.\n            vec2 p2 = abs(vec2(p.y - p.x, p.x + p.y)*.7071) - .5*.7071/dim;\n            p2 = vec2(p2.y - p2.x, p2.x + p2.y)*.7071;\n            float c3 = dist(p2) - aw/2.; \n             \n            \n            \n            // Placing circles at the four corner grid vertices. If you're only rendering\n            // one level (rndTh[0].x=1.), you won't need them... unless you like them, I guess. :)\n            p = abs(p) - .5/dim;\n            if(k<2 && rndTh[0].x<.99) d.x = min(d.x, (dist(p) - aw));\n            \n            // Depending upon which tile scale we're rendering at, draw some circles,\n            // or cut some holes. If you look at the individual tiles in the example,\n            // you can see why.\n            if(rndTh[1].x<.99){\n                \n                // Cut out some mid border holes on the first iteration. \n                if(k==0) d.x = max(d.x, -c3); \n                \n                // On the middle iteration, cut out vertice corner holes.\n                // On the other iterations, add smaller vertice holes.\n                // I made this up as I went along, so there's probably a\n                // more elegant way to go about it.\n                if(k==1) d.x = max(d.x, -(dist(p) - aw));\n            \telse d.x = max(d.x, -(dist(p) - aw/2.));\n                \n            \t\n            }\n            \n            \n            // Increasing the overall width of the pattern slightly.\n            d.x -= .01;\n\n            // Since we don't need to worry about neighbors\n            break;\n\n        }\n        \n        // Subdividing. I.e., decrease the cell size by doubling the frequency.\n        dim *= 2.;\n        \n    }\n    \n   \n    \n    // RENDERING.\n    //\n    // More complicated than you need to make it. Most of the following lines were \n    // coded on the fly for decorative purposes.\n    \n    // Background.\n    vec3 bg = vec3(.1);//*vec3(1, .9, .95);\n    //float pat =  clamp(sin((oP.x - oP.y)*6.283*iResolution.y/22.5) + .75, 0., 1.);\n    //bg *= (pat*.35 + .65);\n    float ns = fbm(oP*32.); // Noise.\n    bg *= ns*.5 + .5; // Apply some noise to the background.\n    \n    // Scene color. Initiated to the background.\n    vec3 col = bg;\n\n    // Falloff variable.\n    float fo;\n  \n    // Render the grid lines.\n    fo = 4./iRy;\n    #ifdef SHOW_GRID\n    col = mix(col, vec3(0), (1. - smoothstep(0., fo*5., d.y - .01))*.5); // Shadow.\n    col = mix(col, vec3(1), (1. - smoothstep(0., fo, d.y))*.15); // Overlay.\n    #endif\n\n\n    // Pattern falloff, overlay color, shade and electronic looking overlay.\n    fo = 10./iRy/sqrt(dim);\n    // Distance field color: I couldn't seem to make vibrant color work, so fell\n    // back go greyscale with a dash of color. It's a cliche, but it often works. :)\n    vec3 pCol = vec3(.3, .25, .275);\n    float sh = max(.75 - d.x*10., 0.); // Distance field-based shading.\n    sh *= clamp(-sin(d.x*6.283*18.) + .75, -.25, 1.) + .25; // Overlay pattern.\n\n\n    // Drop shadow, edges and overlay.\n    col = mix(col, vec3(0), (1. - smoothstep(0., fo*5., d.x))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., fo, d.x));\n    col = mix(col, pCol*sh, 1. - smoothstep(0., fo, d.x + .015));\n\n    // Darkening the rounded quads around the lit centers.\n    col = mix(col, bg*sh, 1. - smoothstep(0., fo, max(d.x + .1, -(d.x + .14))));\n   \n    #ifdef TRI_LEVEL\n        // Apply some blue blinking neon to the tri level pattern.\n    \tvec3 neon = mix(col, col*vec3(1.5, .1, .3).yxz*2., 1. - smoothstep(.7, .9, sin(rnd.y*6.283 + iTime*4. + side)));\n    \tcol = mix(col, col*neon, 1. - smoothstep(0., fo, d.x + .16));\n    #else\n        // Apply some animated noisy reddish neon to the dual level pattern. \n    \tvec3 neon = mix(bg, col*vec3(1.5, .1, .3)*2., smoothstep(-.5, .5, n2D(oP*3. + vec2(iTime*2.))*2. - 1.));\n    \tcol = mix(col, neon, 1. - smoothstep(0., fo, d.x + .16));// + .125\n    #endif\n            \n   \n      \n    // Add some subtle noise.        \n    col *= ns*.25 + .75;\n    \n    \n    // A bit of gradential color mixing.\n    col = mix(col.xzy, col, sign(uv.y)*uv.y*uv.y*2. + .5);\n    col = mix(col.xzy, col, (-uv.y*.66 - uv.x*.33) + .5);\n    \n    // Mild spotlight.\n    col *= max(1.25 - length(uv)*.25, 0.);\n      \n\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttBW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1318, 1340, 1360, 1422, 1494], [1496, 1529, 1549, 1549, 1607], [1609, 1863, 1882, 1882, 2086], [2088, 2166, 2184, 2184, 2257], [2260, 2341, 2360, 2360, 3015], [3017, 3017, 3071, 3547, 11867]], "test": "error"}
{"id": "XttBzr", "name": "Soleil levant", "author": "shantee", "description": "Je voulais obtenir une scène avec un soleil, et ça a donné ça. Je progresse (un peu).", "tags": ["soleil"], "likes": 0, "viewed": 130, "published": "Public", "date": "1538474429", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Sphere(vec2 pos){\n    return smoothstep(length(pos)+0.5,length(pos),0.51);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec4 col = vec4(0.0);\n    vec2 uv = fragCoord/iResolution.y - 0.5; // Ha!\n    vec4 bg = vec4(.11, 0.352, 0.729,1.0);\n    vec4 fl = vec4(.4,.6,0.1,1.0)*smoothstep(0.0,-0.05,uv.y+0.15);\n    vec2 sPos = uv+sin(iTime)*0.5;\n    vec4 sol = vec4(0.9, 0.725, 0.2,1.0)+Sphere(sPos)+\n        mix(.1,.0,sin(iTime)*5.0);\n    \n  \n    col += mix(col,bg,bg.a);\n    col = mix(col,sol,sol.a);\n \n    col = mix(col,fl ,fl.a);\n\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttBzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 82], [83, 83, 140, 140, 577]], "test": "valid"}
{"id": "XttfRB", "name": "Swirly Bits", "author": "villain749", "description": "Learning about domain repetition and manipulation", "tags": ["2d", "swirly", "domainmanipulation"], "likes": 3, "viewed": 117, "published": "Public", "date": "1540074622", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec2 REPS = vec2(3.0, 2.0);\nconst float AMP = .325;\n\nvec2 hash(vec2 vec) {\n    return fract(sin(vec2(dot(vec,vec2(622.1,311.7)),dot(vec,vec2(269.5,383.3))))*42758.5453);\n}\n\nfloat sineNoise(float x) {\n    return (sin(3.0 * x) + sin(7.0 * x) + sin(9.0 * x) + sin(13.0 * x) + sin(17.0 * x) + sin(31.0 * x)) * 0.12 + 0.5;\n}\n\n\nvec4 drawSwirlyBits(vec2 uv, float t, vec2 uv_off, float seed,  vec3 color) {\n\n    uv += uv_off;\n\n    //scale the domain\n    vec2 p = uv * REPS;\n\n    // up and down ocilation of entire domain\n    uv.y += cos((t + seed) * .99) * 0.10;\n\n    // add a wave to domain\n    p.y += sin((uv.x - t * 0.1) * 8.5) * AMP;\n    p.x += cos((uv.y + t * 0.2) * 3.5) * AMP;\n\n    // get index for each row and column\n    vec2 index = floor(p);\n\n    // repeat the domain\n    p = fract(p);\n    // range -1 to 1\n    p = p * 2.0 - 1.0;\n\n    // use atan2 to paramertize each cell with a cirle\n    float spiral = atan(p.x, p.y);\n\n    // get a random value per cell\n    float rdm = hash(index + seed).x; \n\n    // shifts the clock for each cell\n    float cell_time = t + rdm * 3.0;\n\n    // radar scan line\n    float epsilon = 2.5;\n    float cur_spot = mod(cell_time, 6.28) - 3.14;\n    float radar_line = abs(spiral - cur_spot) < epsilon ? (spiral - cur_spot) / epsilon : 0.0;\n    radar_line = clamp(radar_line, 0.0, 1.0);\n    radar_line = pow(radar_line, 3.5);\n    radar_line = clamp(radar_line, 0.0, 1.0);\n\n    // radar ring\n    float delta = 0.09 + (rdm - 0.5)  * 0.05;\n    float ring_cur = mod((-cell_time ) * (1.0 / 6.28), 1.0);\n    // test making ring wavey \n    delta += sineNoise(spiral * .34 + seed + rdm)  * 0.05;\n    // make a tadpole like profile modulating the radar line\n    float profile = 1.0 - abs(1.0 - (radar_line * 1.5));\n    // apply the profile to our delta\n    delta *= profile ;\n    float ring_gradient = length(p);\n    float radar_ring = abs(ring_gradient - ring_cur) < delta ? 0.999 : 0.0;\n\n    // get the little swimmy bits\n    float bits = clamp(min(radar_line, radar_ring), 0.0, 1.0);\n\n    // each cell is randomly more gray sinking into background\n    bits *= rdm;\n\n    // fade them smoothly into and out of existance by reshaping cur_spot\n    // put in zero to one range\n    float fade = (cur_spot + 3.1415) / 6.2831;\n    // make linear symertrical\n    fade = 1.0 - abs(1.0 - (fade * 2.0));\n    // make non-linear so we can see the bit longer\n    //fade = pow(fade, 0.45);\n    // apply fade\n    bits *= fade;\n\n    // give the bits a whitish tip, fading out at the tail\n    color = mix(color, vec3(1.0), bits) * bits;\n    \n    return vec4(color, bits);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = iTime;\n\tvec2 uv = (gl_FragCoord.xy / iResolution.xy);\n     // correct for image aspect...this still doesn't look right to me\n    float aspect =  iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    // range -1 to 1\n    vec2 p = uv * 2.0 - 1.0;\n    // a very dark background gradient\n    vec4 bg = vec4(0.0, uv.y * 0.03, (1.0 - length(p) / 1.8) * 0.07, 0.0);\n\n    // compositing five instances of swirly bits\n    vec4 swirly1 = drawSwirlyBits(uv * 0.65, t, vec2(0.5, 9.4), 12.0, vec3(0.0, 1.0, 0.0));\n    // this one is transposed 90 degrees\n    vec2 uv_tilted = vec2(uv.y, uv.x);\n    vec4 swirly2 = drawSwirlyBits(uv_tilted, t * 1.25, vec2(33.0, 0.0), 0.1, vec3(0.4, 0.0, 1.0));\n    vec4 swirly3 = drawSwirlyBits(uv * vec2(-1.5, 1.5), t * 1.5, vec2(0.0, 2.0), 42.0, vec3(0.8, .6, .0));\n    // this one spins clockwise\n    float slow = t * 0.1;\n    mat2 rot1 = mat2(cos(-slow), sin(-slow), -sin(-slow), cos(-slow));\n    vec2 uv_rot1 = rot1 * p;\n    vec4 swirly4 = drawSwirlyBits(uv_rot1 * 0.35, t * 0.94, vec2(0.0, 2.0), 1.0, vec3(0.0, 1.0, 1.0));   \n    // this one spins counter clockwise\n    slow = slow * 1.2;\n    mat2 rot = mat2(cos(slow), sin(slow), -sin(slow), cos(slow));\n    vec2 uv_rot = rot * p;\n    vec4 swirly5 = drawSwirlyBits(uv_rot * 0.7, t * 1.1, vec2(0.0, 2.0), 71.0, vec3(1.0, 0.0, 1.0));\n    \n    // doing a z composite on all 5\n    if (swirly1.w > bg.w) {\n        bg = swirly1;\n    }\n    if (swirly2.w > bg.w) {\n        bg = swirly2;\n    }\n    if (swirly3.w > bg.w) {\n        bg = swirly3;\n    }\n    if (swirly4.w > bg.w) {\n        bg = swirly4;\n    }\n    if (swirly5.w > bg.w) {\n        bg = swirly5;\n    }\n\n    // testing subtle usage \n    //bg = vec4(0.0, 0.1, 0.25, 0.0) + bg.w * 0.045;\n\n    fragColor = vec4(bg.xyz, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttfRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 80, 80, 177], [179, 179, 205, 205, 325], [328, 328, 405, 405, 2583], [2585, 2585, 2642, 2642, 4407]], "test": "valid"}
{"id": "XttfRN", "name": "Menger Sponge - iOS AR", "author": "reinder", "description": "This is an experiment to create an \"AR shader\" by implementing the mainVR-function and using the WebCam texture as background. Use the [url=https://itunes.apple.com/us/app/shadertoy/id717961814]Shadertoy iOS app[/url] to view this shader.", "tags": ["menger", "ar", "sponge", "ios"], "likes": 3, "viewed": 1093, "published": "Public API", "date": "1538844868", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Menger Sponge - iOS AR. Created by Reinder Nijhoff 2018\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/XttfRN\n//\n// This is an experiment to create an \"AR shader\" by implementing the mainVR-function and \n// using the WebCam texture as background. If you view this shader with the Shadertoy iOS \n// app[1], you can walk around the cube to view it from all sides.\n//\n// If you don't have an iOS device (or if you don't have the app installed) you can find a\n// screen capture of the shader in action here: https://youtu.be/7woT6cTx-bo.\n//\n// The SDF of this shader is based on the \"Menger Sponge\" shader by Íñigo Quílez:\n// https://www.shadertoy.com/view/4sX3Rn\n//\n// [1] https://itunes.apple.com/us/app/shadertoy/id717961814\n//\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3  di = abs(p) - b;\n  float mc = max(di.x,max(di.y,di.z));\n  return min(mc,length(max(di,0.0)));\n}\n\nfloat boxIntersect( in vec3 ro, in vec3 rd, in vec3 rad ) {\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return 1e30;\n\treturn tN;\n}\n\nfloat map( in vec3 p ) {\n    float d = sdBox(p,vec3(1.0));\n    float s = .5;\n    for( int m=0; m<4; m++ ) {\n        vec3 a = fract( p*s )-.5;\n        s *= 3.;\n        vec3 r = abs(1.-6.*abs(a));\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/(2.*s);\n\n        if( c>d ) {\n          d = c;\n        }\n    }\n    return d;\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; \n    for( int i=0; i<32; i++ ) {\n\t\tfloat h = map( ro + rd*t );\n       \tfloat y = h*h/(2.0*ph);\n        float d = sqrt(max(0.,h*h-y*y));\n        res = min( res, 8.0*d/max(0.0001,t-y) );\n        ph = h;\n        t += h;//min(h, .1);// clamp( h, 0.02, 0.10 );\n        if( res<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ) {\n        float hr = 0.01 + 0.5*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.9;\n    }\n    return clamp( 1. - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 calcNormal(in vec3 pos) {\n    vec3  eps = vec3(.001,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\n    nor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\n    nor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\n    return normalize(nor);\n}\n\nvec4 tex3D( sampler2D sam, in vec3 p, in vec3 n ) {\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv, in sampler2D tex ) {\n    ro *= 2.; // scale scene\n    const float tmax = 100.;\n    vec3 lightDir = normalize(vec3(0.7,1.,.2));\n    float tmin = boxIntersect(ro, rd, vec3(1.));\n    if (all(lessThan(abs(ro),vec3(1)))) tmin = 0.01;\n    \n    float t = tmin;\n    for( int i=0; i<64; i++ ) {\n\t    float precis = 0.001*t;\n\t    float d = map( ro+rd*t );\n        if( abs(d)<precis || t>tmax ) break;\n        t += d;\n    }\n    \n    vec3 col = texture(tex, uv).xyz;\n    // Use mipmap level 9 to get an average environment color from the webcam texture\n    // used for lighting.\n    vec3 lightColor = pow(.25 + .75 * texelFetch(tex, ivec2(0), 9).rgb, vec3(2.2)) * 3.;\n    \n    if (t < tmax) {\n        vec3 p = ro + t * rd;\n  \t\tvec3 n = calcNormal(p);\n        vec3 ref = reflect(rd, n);\n\n        float ao = .4 + .6 * calcAO(p, n);\n        float sh = .4 + .6 * calcSoftshadow(p, lightDir, 0.005, 1.);\n    \n        float diff = max(0.,dot(lightDir,n)) * ao * sh;\n        float amb  = (.4+.2*n.y) * ao * sh;\n\t\tfloat spe = pow(clamp(dot(ref,lightDir), 0., 1.),8.) * sh * .5;\n           \n        vec3 mat = tex3D(iChannel2, p, n).rgb;\n        col = (amb + diff) * mix(vec3(.4,.6,.8),vec3(.1,.2,.3),mat.r) + spe * dot(mat,mat);\n        col *= lightColor;\n    }\n    \n    // gamma\n    col = mix(col, sqrt(clamp(col,vec3(0),vec3(1))), .95);\n    \n    return clamp(col,vec3(0),vec3(1));\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n   \n    float a = .3 * iTime;\n    vec3 ro = 2. * vec3( sin(a), .1, cos(a) );\n    vec3 ta = vec3( 0.0, 0., 0.0 );\n    \n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    vec3 col = render( ro, rd, fragCoord.xy/iResolution.xy, iChannel1 );\n    fragColor = vec4(col,1.0);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\n    ro += vec3(0,0.5,1.5);\n    vec3 col = render( ro, rd, fragCoord.xy/iResolution.xy, iChannel0 );\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttfRN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-4.0", "functions": [[827, 827, 858, 858, 962], [964, 964, 1023, 1023, 1278], [1280, 1280, 1304, 1304, 1694], [1696, 1696, 1774, 1774, 2173], [2175, 2175, 2217, 2217, 2507], [2509, 2509, 2539, 2539, 2765], [2767, 2767, 2818, 2818, 2963], [2965, 2965, 3034, 3034, 4378], [4380, 4380, 4432, 4432, 4609], [4611, 4611, 4668, 4668, 5043], [5045, 5045, 5123, 5123, 5256]], "test": "error"}
{"id": "XttfzM", "name": "Goblets", "author": "teraspora", "description": "goblets", "tags": ["goblets"], "likes": 1, "viewed": 56, "published": "Public", "date": "1539055884", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Manhattan - a fragment shader in GLSL, built on shadertoy.com;\n// Author: John Lynch (@teraspora);\n// Based on voronoi-2\n// Date: 9 OCT 2018.\n\n// Copyright © 2018 John Lynch\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n// -----------------------------------------------------------------------------\n\n#define PI 3.141592653588\n\n// Some useful colours:\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 crimson =      vec3(1.,   0.,   0.4  );\nconst vec3 yellow =      vec3(1.,   1.,   0.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 orange = vec3(1.0, 0.4, 0.);\nconst vec3 cyan = vec3(0., 0.4, 1.0);\nconst vec3 magenta = vec3(1.0, 0., 1.0);\nconst vec3 gold = vec3(1.0, 0.84, 0.66);\n\nvec3[] cols = vec3[](white, crimson, yellow, magenta, gold, cyan, orange);\nvec3 col;\n\n// ==================================================================\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n// - not tested!\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from HSL to linear RGB\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\n// My inline library of useful functions:\n// =======================================\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\nfloat om(float x) {\n\treturn 1. - x;\n}\n\nvec3 om(vec3 v) {\n\treturn 1. - v;\n}\n\nfloat op(float x) {\n\treturn 1. + x;\n}\n\nfloat nsin(float x) {\n\treturn op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n\treturn op(cos(x)) * 0.5;\n}\n\nfloat sqrtp(float x) {\n\treturn sqrt(x < 0. ? -x : x); \n}\n\nfloat nmmod(float x, float y) {\n\tfloat xmn = 2. * mod(x, y) / y;\n    return xmn < 1. ? xmn : om(xmn);\n}\n\nvec3 omss(float mn, float mx, vec3 val) {\n\treturn om(smoothstep(mn, mx, val));\n}\n\nvec2 nmouse() {\n\treturn iMouse.xy / iResolution.xy;\n}\n\nvec3 invert(vec3 col) {\n \treturn 1. - clamp(col, 0., 1.);   \n}\n\nbool isOdd(float p) {\n    return fract(p * 0.5) >= 0.5;\n}\n\nfloat minkd(vec2 u, vec2 v, float order) {\t// Minkowski distance order 1\n    if (order <= 0.) return 0.;\t\t\t\t// i.e. Manhattan distance\n\treturn abs(pow(abs(pow(v.x - u.x, order)) + abs(pow(v.y - u.y, order + 2.5)), 1. / order)); \n}\n\n\n// =======================================\n\n// rand generator from \n// https://www.youtube.com/watch?v=l-07BXzNdPw&t=740s\nvec2 r22(vec2 p) {\n\tvec3 a = fract(p.xyx * vec3(4483.34, 234.34, 345.65));\n\ta += dot(a, a - 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\n\nfloat f(float x) {\n\treturn sin(cos(0.2 * iTime * x)) + cos(2. * sin(0.23 * iTime * x)) - sqrt(0.2 *abs(x) * cos(0.02 * iTime * x));\n}\n\nvec3 drawBorder(vec3 col, float b, vec3 insetColour, vec2 pp, vec2 hr, float tileIndex) {\n    // `b` is the border width\n    // `col` is the input (and output) colour\n    // `pp` is (unnormalised) coordinate of pixel\n    // `hr` is (unnormalised) resolution\n    // Make a border: `b` px solid black; with `insetColour` inset:\n    if (tileIndex != -1.) {\n    \t//  any special code for single-pane use goes here    \n    }\n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = insetColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = insetColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));\n    return col;\n    \n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = iTime / 4. + 2.;\n    float numPoints = clamp(floor(t / 2.), 0., 64.);\n    \n    //t = 1. - t;\n    float scale =  0.5; // / numPoints;\n    \n\tfloat asp = iResolution.x/iResolution.y;\n    \n    // Normalized pixel coordinates (y from -1 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / (iResolution.y * scale);\n\t\t\n    //uv.y = abs(uv.y);\n    if (nmouse().x >= 0.5) uv = abs(uv);\n    \n    vec2 friz = vec2(100. * sin(t * uv.x), 100. * cos(t * uv.y));\n    vec2 vel = vec2(1., 10.);\n    \n    //uv *= vec2(om(sin(friz.x * cos(vel.x * t) * uv.x) / 7.), om(cos(friz.y * sin(vel.y * t) * uv.y) / 11.)); \n    \n    // col = crimson;\n    \n    float m = 0.;\n    float mind = 100.;\n    float ci;\n    \n    // generate a bunch of random points\n    for (float i = 0.; i < numPoints; i++) {\n    \tvec2 n = r22(vec2(i));\n        // sin of both components varied with time\n        vec2 p = sin(n * t);\n        // get distance to point\n        float d = minkd(uv, p, 1.);\n        //m += smoothstep(.05, .01, d);\n        if (d < mind) {\n        \tmind = d;\n            ci = i;\n        }\n    }\n    \n    col = invert(vec3(mind));\n    col.g -= nsin(t + length(uv));\n    //col.b += 0.5 * smoothstep(0., 1., col.r + col.b);\n    \n    if (rgb2hcv(col).z < 0.01) col = 0.5*cos(0.4 * t+uv.yxy / 6. +vec3(2.7,4.9,8.1));\n    \n    \n    fragColor = vec4(col.bgr, 1.);\n}\n\n//col = vec3(m, nsin(length(uv)), ncos(t));\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttfzM.jpg", "access": "shaders20k", "license": "mit", "functions": [[2032, 2032, 2057, 2057, 2215], [2217, 2281, 2305, 2358, 2641], [2643, 2678, 2702, 2702, 2822], [2824, 2859, 2883, 2883, 3035], [3123, 3123, 3142, 3142, 3171], [3173, 3173, 3205, 3205, 3252], [3254, 3254, 3282, 3282, 3347], [3349, 3349, 3381, 3381, 3422], [3424, 3424, 3443, 3443, 3461], [3463, 3463, 3480, 3480, 3498], [3500, 3500, 3519, 3519, 3537], [3539, 3539, 3560, 3560, 3588], [3590, 3590, 3611, 3611, 3639], [3641, 3641, 3663, 3663, 3697], [3699, 3699, 3730, 3730, 3802], [3804, 3804, 3845, 3845, 3884], [3886, 3886, 3901, 3901, 3939], [3941, 3941, 3964, 3964, 4003], [4005, 4005, 4026, 4026, 4062], [4064, 4064, 4106, 4136, 4294], [4341, 4419, 4437, 4437, 4566], [4569, 4569, 4587, 4587, 4702], [4704, 4704, 4793, 5029, 5575], [5577, 5577, 5634, 5634, 6985]], "test": "error"}
