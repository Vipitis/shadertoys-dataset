{"id": "4dBcRz", "name": "[ Famous curves ] - #5", "author": "Yrai", "description": "#5 - Epitrochoid", "tags": ["2d", "curve", "blend", "rotation", "path", "parametric", "epitrochoid"], "likes": 3, "viewed": 480, "published": "Public API", "date": "1490519372", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/*\n   Epitrochoid facts:\n  --------------------\n\t- (a) The circle of radius b rolls on the outside of the circle of radius a. The point P is at a\n\t\t  distance c from the center of the circle of radius b.\n\n*/\n\n#define res_            iResolution\n#define time_           iTime\n#define trace_len_      322\n#define eps_            .2\n\n#define crot(a)  mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvec2  domain(vec2 uv, float s);\nvec2  parametric(float t);\nfloat trace(vec2 p, float t);\nfloat _union_chamfer(float a, float b, float r);\n\nvoid mainImage(out vec4 o, vec2 f) {\n\tvec2 p = domain(f, 6.);\n    vec2 np = f / res_.xy;\n    \n  \tp *= crot(time_*.2);\n    \n    // t -> [0., 5.]\n    float t = time_ * sign(sin(time_));\n    \n    // Epitrochoid traces\n    float dtrace = smoothstep(0.19, 0.01, trace(p, t));\n    // Axis\n    float ax = min(\n        smoothstep(0., 0.02, abs(p.x)),\n        smoothstep(0., 0.02, abs(p.y))\n    );\n    // Origin\n    float org = smoothstep(0.09, 0., length(p)-.01);\n    \n    // Palette \n    vec3 gray   = vec3(.2);\n    vec3 white  = vec3(5.);\n    \n    // Shading\n    vec3 c  = vec3(0.);\n    c = mix(c, gray, fract(1.-ax));\n    c = mix(c, white, org);\n    \n    c = mix(c, vec3(1.), dtrace);\n\tc = mix(c, vec3(1., 0., 0.), dtrace/length(p*2.2)*3.);\n    c.b += dtrace*p.x;\n    \n    o = vec4(c, 1.);\n}\nfloat _union_chamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n\nvec2 parametric(float t) {\n    t /= atan(t, 2.*t);\n\tfloat a = 2.;\n    float b = 1.2;\n    float c = 1.9;\n    return vec2( (a+b)*cos(t) - c*cos((a/b + 1.) * t), (a+b)*sin(t) - c*sin((a/b + 1.) * t) );\n}\n\nfloat trace(vec2 p, float t) {\n    float d = 1e10;\n    float e = 0.;\n    for(int i = 0; i < trace_len_; i++) {\n    \td  = _union_chamfer(d, distance(p, parametric(t-e)), parametric(t).y * .15);\n        e += eps_; \n    }\n    return d;\n}\n\nvec2 domain(vec2 uv, float s) {\n    return (2. * uv.xy - res_.xy) / res_.y * s;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dBcRz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[89, 612, 648, 648, 1398], [1399, 1399, 1448, 1448, 1497], [1500, 1500, 1526, 1526, 1700], [1702, 1702, 1732, 1732, 1936], [1938, 1938, 1969, 1969, 2019]]}
{"id": "4dBczh", "name": "Little Box", "author": "chapter9", "description": "Simple, Raymarch, SDF", "tags": ["simple", "raymarch", "sdf"], "likes": 0, "viewed": 79, "published": "Public", "date": "1490747312", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI=3.14159265;\n\n// Floor\nvec2 objPlane(in vec3 p, in float offset, in int materialID)\n{\n  return vec2(p.y+offset,materialID);\n}\n\nvec2 opAdd(in vec2 obj0, in vec2 obj1)\n{\n    float r = min(obj0.x,obj1.x);\n\treturn vec2(r, r == obj0.x ? obj0.y : obj1.y);\n}\n\nvec2 obSub(in vec2 obj0, in vec2 obj1)\n{\n    float r = max(obj0.x,-obj1.x);\n\treturn vec2(r, r > obj0.x ? obj0.y : obj1.y);\n}\n\nvec2 objSphere(in vec3 p, in float r, in int materialID)\n{\n  float d = length(p) - r;\n  return vec2(d,materialID);\n}\n\nvec2 objCube( vec3 p, vec3 b, in int materialID)\n{\n  float d = length(max(abs(p)-b,0.0));\n  return vec2(d,materialID);\n}\n\nvec2 vScene(in vec3 p)\n{\n  return opAdd(\n      \t\tobjPlane(p,1.0,0),\n      \t\tobSub(\n                objCube(p,vec3(1.0,1.0,1.0),1),\n                objSphere(p,1.25,2)\n            )\n      \t );\n}\n\nvec3 material0(in vec3 p) \n{\n  if (fract(p.x*0.2)>0.2)\n  {\n    if (fract(p.z*0.2)>0.2)\n      return vec3(0,0.1,0.2);\n    else\n      return vec3(1,1,1);\n  }\n  else\n  {\n    if (fract(p.z*.2)>.2)\n      return vec3(1,1,1);\n    else\n      return vec3(0.3,0.2,0);\n   }\n}\nvec3 material1(in vec3 p) { return vec3(1.7,1.2,2.0); }\nvec3 material2(in vec3 p) { return vec3(1.0,0.0,0.0); }\n\nvec3 SetupCamera(vec3 camPos, vec3 camLookAt, vec3 worldUp, vec2 uv)\n{\n  // Camera setup.\n  vec3 camDir=normalize(camLookAt-camPos);\n  vec3 camRight=normalize(cross(worldUp,camDir));\n  vec3 camUp=cross(camDir,camRight);\n  vec3 vcv=(camPos+camDir);\n  vec3 scrCoord=vcv+uv.x*camRight*iResolution.x/iResolution.y+uv.y*camUp;\n  return normalize(scrCoord-camPos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Texture Coordinate\n  vec2 uv = fragCoord.xy/iResolution.xy - 0.5;\n    \n  // Mouse Coordinate\n  vec2 m = iMouse.xy/iResolution.xy*PI*vec2(2.0,0.5);\n\n  // Camera\n  const float cameraDistance = 4.0;\n  const vec3 cameraUp = vec3(0,1,0);\n  const vec3 cameraLookAt = vec3(0,0,0);\n  const float cameraFar=100.0;\n  const float cameraNear=0.001;\n  vec3 cameraPos=vec3(cos(m.y)*cos(m.x),sin(m.y),cos(m.y)*sin(m.x))*cameraDistance; \n  vec3 scp=SetupCamera(cameraPos, cameraLookAt, cameraUp, uv);\n    \n  // Raymarching.\n  const int rayCount = 200;\n  vec2 rayDistance=vec2(0.001,0.0 /* Material ID */);\n  vec3 c,p,N;\n\n  float f=0.0;\n  for(int i=0;i<rayCount;i++)\n  {\n    if ((abs(rayDistance.x) < cameraNear) || (f > cameraFar)) \n      break;\n    \n    f+=rayDistance.x;  \n    p=cameraPos+scp*f; // rayPoint\n    rayDistance = vScene(p);\n  }\n  \n  if (f < cameraFar)\n  {\n    // y is used to manage materials.\n    if (rayDistance.y<=0.0) \n      c = material0(p);\n    else if (rayDistance.y<=1.0) \n      c = material1(p);\n    else if (rayDistance.y<=2.0) \n      c = material2(p);\n        \n    // Lighting\n\tconst vec3 e=vec3(0.00001,0,0);\n    vec3 n = vec3(rayDistance.x-vScene(p-e.xyy).x,\n                  rayDistance.x-vScene(p-e.yxy).x,\n                  rayDistance.x-vScene(p-e.yyx).x);\n    N = normalize(n);\n\tvec3 L = vec3(sin(iTime)*20.0,20.0,cos(iTime)*20.0);\n    float b=dot(N,normalize(cameraPos-p+L));\n    \n    //simple phong lighting, LightPosition = CameraPosition\n    fragColor=vec4((b*c+pow(b,16.0))*(1.0-f*.001),1.0);\n  }\n  else \n    fragColor=vec4(0,0,0,1); //background color\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dBczh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 31, 93, 93, 133], [135, 135, 175, 175, 259], [261, 261, 301, 301, 385], [387, 387, 445, 445, 503], [505, 505, 555, 555, 625], [627, 627, 651, 651, 820], [822, 822, 850, 850, 1086], [1087, 1087, 1114, 1114, 1142], [1143, 1143, 1170, 1170, 1198], [1200, 1200, 1270, 1289, 1560], [1562, 1562, 1619, 1643, 3202]]}
{"id": "4dfyDs", "name": "YAM - Yet Another Mandelbulb", "author": "1vx_437312114", "description": "Since mandelbulbs have become trendy again on shadertoys lately, here is my take. Based on  https://www.shadertoy.com/view/4sXcWj just with another map function. I commented the code extensively hoping it might help other people to start. Thanks to all.", "tags": ["procedural", "3d", "raymarching", "fractal", "distancefield", "mandelbulb"], "likes": 4, "viewed": 395, "published": "Public", "date": "1490231268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on https://www.shadertoy.com/view/ltfSWn\n// created by inigo quilez - iq\n// (see http://iquilezles.org/www/articles/mandelbulb/mandelbulb.htm for details)\n//\n// and the blog entry \"Distance Estimated 3D Fractals (V): The Mandelbulb & Different\n// DE Approximations\" by Mikael Hvidtfeldt Christensen\n// (see http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/)\n//\n//\n// Code for 4x rotated-grid SSAA for antialiasing taken from\n// https://www.shadertoy.com/view/XsXXWS by Morgan Mc Guire (Morgan3D)\n//\n// (take also a look at the excellent documented source code if you need a very good and very detailed\n// explanation of how to render mandelbulbs!)\n//\n//\n// For an explanation of how to archieve realistic looking outdoor lighting take a look at:\n//\n// http://iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n//\n// and for raymarching in general: \"rendering worlds with two triangles\"\n//\n// http://iquilezles.org/www/material/nvscene2008/nvscene2008.htm\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Thanks to iq for the great tutorials, for shadertoy and everything else\n\n\n// set to true for antialiasing (enhances rendering quality but decreases speed by a factor of 4!)\n#define ANTIALIASING false\n\n\n// globals (are bad, i know, but make life sometimes easier :-) )\nfloat dr;\n\n//Fractal\nconst int   NUM_ITERATIONS  = 5;\nconst float SCALE           = 3.0; \n      vec3  OFFSET          = vec3(1.0, 1.0, 1.0);\n\t  mat3  m               = mat3(1,0,0,0,1,0,0,0,1);//Initialized in main function\n\n\n// background color function, computes skycolor based on ray direction (used, if the ray hits nothing)\nvec3 skyColor(vec3 rd)\n{\n    vec3 sunDir = vec3(0.0, -1.0, 0.0);\n    vec3 sunColor = vec3(1.6, 1.8, 2.2);\n\n    float sunAmount = max(dot(rd, sunDir), 0.0);\n    float v = pow(1.0 - max(rd.y, 0.0), 6.0);\n    vec3 sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\n\n    sky += sunColor * sunAmount * sunAmount * 0.25 + sunColor * min(pow(sunAmount, 800.0) * 1.5, 0.3);\n\n\n    return clamp(sky, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n}\n\n\n// signed distance field function (mandelbulb power 8)\nfloat map(vec3 p)\n{\n\tconst int itMax = 14;\n\n    vec3 w = p;\n\n    float r = 0.0;\n    float dist = 0.0;\n\n    dr = 1.0;\n\n\n    for(int it = 0; it < itMax; it++)\n    {\n        r = length(w);\n\n        if (r > 2.0)\n        {\n            dist = 0.5 * log(r) * r / dr;\n\n            break;\n        }\n\n        // extract polar coordinates\n        float theta = acos(w.z / r);\n        float phi =  atan(w.y, w.x);\n\n        // scale and rotate point\n        float rp2 = w.x * w.x + w.y * w.y + w.z * w.z;\n        float rp4 = rp2 * rp2;\n\n        float radPower = rp4 * rp4;\n        float phiPower = phi * 8.0;\n        float thetaPower = theta * 8.0;\n\n\n        // convert back to cartesian coordinates\n        float sinTheta = sin(thetaPower);\n        float sinPhi   = sin(phiPower);\n        float cosTheta = cos(thetaPower);\n        float cosPhi   = cos(phiPower);\n\n        w.x = radPower * sinTheta * cosPhi;\n        w.y = radPower * sinTheta * sinPhi;\n        w.z = radPower * cosTheta;\n\n        // add c\n        w += p;\n\n        // compute dr\n        float r2 = r * r;\n        float r4 = r2 * r2;\n        dr *= r4 * r2 * r * 8.0 + 1.0;\n    }\n\n    return dist;\n}\n\n\n// raymarching with distance field\nfloat intersect( in vec3 ro, in vec3 rd)\n{\n    const int maxStepCount = 256;\t// maximum no. of steps to march\n    const float tMax = 100.0;\t\t// maximum distance to march\n    const float epsilon = 0.0003;\t// determines precision (smaller values for more details\n    \t\t\t\t\t\t\t\t// and more noise due to holes from precision problems)\n\n\tfloat t = 0.0;\n\n    // march!\n    for(int i = 0; i < maxStepCount; i++)\n    {\n        // march forward along the ray, compute point p on ray for this step\n        vec3 p = ro + rd * t;\n\n        // get distance to nearest surface from distance field\n        float distance = map(p);\n\n        // if we're already marched too far (t > tMax),\n        // or we're close enough (less than epsilon) to the surface (we have \"hit\" it)\n        if ((t > tMax) || (distance < epsilon))\n            break;\n\n        // march further along the ray with the maximal distance possible,\n        // which is distance to the closest surface from the actual position\n        // taken from the signed distance field describing the mandelbulb\n        // this ensures, that we haven't gone too far, so that we are not already inside the mandelbulb\n        t += distance;\n    }\n\n    // if we're not exceeded the maximum marching distance, return ray parameter t for\n    // computating the hit surface position\n    if( t < tMax )\n   \t\treturn t;\n    else\n        return -1.0;\t// we missed it, signal this with -1.0\n}\n\n\n// cheap distance field soft shadow computation\n// (see article \"free penumbra shadows for raymarching distance fields\":\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm)\nfloat softShadow(vec3 surfacePoint, vec3 lightDir)\n{\n    vec3 origin = surfacePoint + 0.001 * lightDir;\n\n    vec3 ro = origin;\n    vec3 rd = lightDir;\n\n\n    const float k = 2.0; // 8.0\n    float res = 1.0;\n\tfloat t = 0.0;\n\n    for (int i = 0; i < 100; i++)\n    {\n        float h = map(ro + rd * t);\n\n        if (h < 0.0001)\n            return 0.0;\n\n        if (t > 100.0)\n            break;\n\n        res = min(res, k * h / t);\n        t += h;\n    }\n\n    return res;\n}\n\n\n// numerically approximate normal via discrete gradient computation (first order)\nvec3 computeNormal(vec3 surfacePoint)\n{\n    const float epsilon =  0.001;\n\n    vec3 epsX = vec3(epsilon, 0.0, 0.0);\n    vec3 epsY = vec3(0.0, epsilon, 0.0);\n    vec3 epsZ = vec3(0.0, 0.0, epsilon);\n\n    float dx = map(surfacePoint + epsX) - map(surfacePoint - epsX);\n    float dy = map(surfacePoint + epsY) - map(surfacePoint - epsY);\n    float dz = map(surfacePoint + epsZ) - map(surfacePoint - epsZ);\n\n    vec3 n = normalize(vec3(dx, dy, dz));\n\n    return n;\n}\n\n\n// cheap distance field ambient occlusion computation\nfloat computeAO(vec3 surfacePoint, vec3 normal)\n{\n    const float k = 5.0;\n    const float delta = 0.005;\n\n    float sum = 0.0;\n\n    for(float i = 0.0; i < 10.0; i+=1.0)\n    {\n        float factor = 1.0 / pow(2.0, i);\n        vec3 samplePoint = surfacePoint + normal * i * delta;\n\n        sum += factor * (i * delta - map(samplePoint));\n    }\n\n    return 1.0 - k * sum;\n}\n\n\n// compute fragment color by raymarching the whole scene, given 2D coords\nvec3 raymarch(vec2 point)\n{\n    // scene parameters\n    const vec3 cameraLookAt = vec3(0.0, 0.1, 0.0);\n\n    const vec3 light1 = vec3(  0.577, 0.577, -0.577 );\n\tconst vec3 light2 = vec3( -0.707, 0.000,  0.707 );\n\n\tconst float fov = 1.2;\t// change for bigger field of view\n\n\n    // compute aspect ratio 'corrected' pixel position\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 xy = -1.0 + 2.0 * point.xy / iResolution.xy;\n\n    vec2 s = xy * vec2(aspectRatio, 1.0);\n\n\n    // slow down time ... (and start 30 s later)\n    float time = iTime * 0.5 + 16.0;\n\n\t// some magic for camera movement ...  (time dependent camera radius and rotations)\n\tfloat r = 2.3 + 0.1  * cos(0.29 * time);\n    vec3  ro = vec3( r * cos(0.33 * time), 0.8 * r * sin(0.37 * time), r * sin(0.31 * time) ); // ray origin\n\tfloat cr = 0.5 * cos(0.1 * time);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\n    // compute orthonormal camera basis\n    vec3 cameraDir = normalize(cameraLookAt - ro);\n\tvec3 cameraRight = normalize(cross(cameraDir, cp));\n\tvec3 cameraUp = normalize(cross(cameraRight, cameraDir));\n\n    // compute ray direction for perspective camera\n\tvec3 rd = normalize( s.x  * cameraUp + s.y * cameraRight + fov * cameraDir );\n\n\n\tvec3 col;\n\tvec3 tra;\n\n    // intersect ray (ray origin (ro), ray direction (rd) with scene,\n    // get ray parameter t for determining hit surface point\n    float t = intersect(ro, rd);\n\t\t\n\t\t\n    // nothing hit -> background color based on ray direction\n    if( t < 0.0 )\n        col = skyColor(rd);\n\telse\n\t{\n        // hit at t, compute position, normal, reflection, usw. (see links above)\n\t\tvec3 pos = ro + t * rd;\n        vec3 nor = computeNormal(pos);\n        vec3 hal = normalize( light1 - rd);\n        vec3 ref = reflect( rd, nor );\n\n        // for using resoluts of orbit traps for color\n\t\tfloat trc = 0.1 * log(dr);\n\n        // position based color for 'colorful' coloration :-)\n        tra = vec3(trc, trc, 0) * abs(pos);\n\n\n        col = vec3(0.7, 0.2, 0.2);\n\t\tcol = mix( col, vec3(1.0, 0.5, 0.2), sqrt(tra.y) );\n\t\tcol = mix( col, vec3(1.0, 1.0, 1.0), tra.x );\n\n        // compute diffuse components from both lights\n\t\tfloat dif1 = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat dif2 = clamp( 0.5 + 0.5*dot( light2, nor ), 0.0, 1.0 );\n\n        // add other lighting components (ambient occlusion, softshadows, specular)\n        // see iq article (http://iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm)\n        float occ =  0.05 * computeAO(pos, nor);\n        float sha = softShadow(pos, light1);\n        float fre = 0.04 + 0.96 * pow( clamp(1.0 - dot(-rd, nor), 0.0, 1.0), 5.0 );\n        float spe = pow( clamp(dot(nor, hal),0.0, 1.0), 12.0 ) * dif1 * fre * 8.0;\n\n        // some color magic\n        // 'good artists copy, great artists steal' - this is stolen from:\n        // https://www.shadertoy.com/view/ltfSWn\n\t\tvec3 lin  = 1.5 * vec3(0.15, 0.20, 0.23) * (0.7 + 0.3 * nor.y) * (0.2 + 0.8 * occ);\n\t\t     lin += 3.5 * vec3(1.00, 0.90, 0.60) * dif1 * sha;\n\t\t     lin += 4.1 * vec3(0.14, 0.14, 0.14) * dif2 * occ;\n             lin += 2.0 * vec3(1.00, 1.00, 1.00) * spe * sha * occ;\n             lin += 2.0 * vec3(0.20, 0.30, 0.40) * (0.02 + 0.98 * occ);\n             lin += 2.0 * vec3(0.8, 0.9, 1.0) * smoothstep( 0.0, 1.0, ref.y ) * occ;\n\n\t\tcol *= lin;\n        col += spe * 1.0 * occ * sha;\n\t}\n\n\n    // cheap gamma correction (for gamma = 1.0 / 2.0, close to 'official' lcd screen gamma = 1.0 / 2.2)\n\tcol = sqrt( col );\n\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color;\n\n\n\tif(!ANTIALIASING)\n\t\t// single sample for speed\n\t\tcolor = raymarch(gl_FragCoord.xy);\n\telse\n    \t// 4x rotated-grid SSAA for antialiasing\n    \t// (taken from https://www.shadertoy.com/view/XsXXWS by Morgan3D)\n\t\tcolor =   (\traymarch(gl_FragCoord.xy + vec2(-0.125, -0.375)) +\n\t\t\t \t\traymarch(gl_FragCoord.xy + vec2(+0.375, -0.125)) +\n\t\t\t\t\traymarch(gl_FragCoord.xy + vec2(+0.125, +0.375)) +\n\t\t\t \t\traymarch(gl_FragCoord.xy + vec2(-0.375, +0.125))\t) / 4.0;\n\n\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dfyDs.jpg", "access": "shaders20k", "license": "gpl-3.0-plus OR cc-by-sa-3.0", "functions": [[1641, 1744, 1768, 1768, 2186], [2189, 2244, 2263, 2263, 3394], [3397, 3432, 3474, 3474, 4852], [4855, 5039, 5091, 5091, 5506], [5509, 5591, 5630, 5630, 6053], [6056, 6110, 6159, 6159, 6481], [6484, 6558, 6585, 6609, 10044], [10046, 10046, 10103, 10103, 10608]]}
{"id": "4dfyWj", "name": "ResolveTestVR", "author": "TimothyLottes", "description": "Comparison of VR resolve methods", "tags": ["antialiasing", "msaa", "vrresolveshader"], "likes": 2, "viewed": 461, "published": "Public", "date": "1489798863", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// CHANGE THIS MODE DEFINE TO TRY DIFFERENT OPTIONS\n//  \n// Sorry, only looks right at 1920x1080 non-full-screen.\n//\n\n// Major under-sampling in the center.\n// Major over-sampling towards the ends.\n// Warp not intended to look like VR, but have similar properties.\n// All of these are linear filtering operations.\n\n// 0 Red ......... NoAA Resolve Then Nearest Warp\n// 1 Orange ...... NoAA Resolve Then Bilinear Warp\n// 2 Gold ........ 4xSGSSAA Box Resolve Then Bilinear Warp\n// 3 Yellow ...... 4xSGSSAA Gaussian Resolve With Warp + Noise\n\n#define MODE 3\n\n//================================================================================\n\n#define F1 float\n#define F2 vec2\n#define F3 vec3\n#define F4 vec4\n\n// Kernel scale.\n// This is a horrible hack, but maybe good enough for now.\nF1 Kern(F2 p){\n // Convert to {-1 to 1} space.\n p=p/iResolution.xy;p=p*2.0-1.0;\n p=abs(p);\n p=p*p*0.5+p*0.5;\n return 0.5*p.x+0.5*p.y;}\n\n// Warp (given integer coordinates).\n// This is a proxy for a VR warp.\nF2 Warp(F2 p){\n // Convert to {-1 to 1} space.\n p=p/iResolution.xy;p=p*2.0-1.0;\n // Transform.\n p=p*abs(p)*0.5+p*0.5;\n // Convert back to integer.\n p=p*0.5+0.5;p*=iResolution.xy;return p;}\n\n// Unwarp.\nF2 Unwarp(F2 p){\n // Convert to {-1 to 1} space.\n p=p/iResolution.xy;p=p*2.0-1.0;\n // Invert transform.\n F2 pp=p;\n p=abs(p);\n p=0.5*(sqrt(8.0*p+1.0)-1.0);\n if(pp.x<0.0)p.x=-p.x;\n if(pp.y<0.0)p.y=-p.y;\n // Convert back to integer.\n p=p*0.5+0.5;p*=iResolution.xy;return p;}\n\n// Convert from linear to sRGB.\nF1 Srgb(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\n\n// Convert from sRGB to linear.\nF1 Linear(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}    \n\n//\n// Semi-Poor Quality Temporal Noise\n//\n\n// Base.\n// Ripped ad modified from: https://www.shadertoy.com/view/4djSRW\nF1 Noise(F2 p,F1 x){p+=x;\n F3 p3=fract(F3(p.xyx)*10.1031);\n p3+=dot(p3,p3.yzx+19.19);\n return fract((p3.x+p3.y)*p3.z)*2.0-1.0;}\n\n// Step 1 in generation of the dither source texture.\nF1 Noise1(F2 uv,F1 n){\n F1 a=1.0,b=2.0,c=-12.0,t=1.0;   \n return (1.0/max(a*4.0+b*4.0,-c))*(\n  Noise(uv+F2(-1.0,-1.0)*t,n)*a+\n  Noise(uv+F2( 0.0,-1.0)*t,n)*b+\n  Noise(uv+F2( 1.0,-1.0)*t,n)*a+\n  Noise(uv+F2(-1.0, 0.0)*t,n)*b+\n  Noise(uv+F2( 0.0, 0.0)*t,n)*c+\n  Noise(uv+F2( 1.0, 0.0)*t,n)*b+\n  Noise(uv+F2(-1.0, 1.0)*t,n)*a+\n  Noise(uv+F2( 0.0, 1.0)*t,n)*b+\n  Noise(uv+F2( 1.0, 1.0)*t,n)*a+\n 0.0);}\n    \n// Step 2 in generation of the dither source texture.\nF1 Noise2(F2 uv,F1 n){\n F1 a=1.0,b=2.0,c=-2.0,t=1.0;   \n return (1.0/(a*4.0+b*4.0))*(\n  Noise1(uv+F2(-1.0,-1.0)*t,n)*a+\n  Noise1(uv+F2( 0.0,-1.0)*t,n)*b+\n  Noise1(uv+F2( 1.0,-1.0)*t,n)*a+\n  Noise1(uv+F2(-1.0, 0.0)*t,n)*b+\n  Noise1(uv+F2( 0.0, 0.0)*t,n)*c+\n  Noise1(uv+F2( 1.0, 0.0)*t,n)*b+\n  Noise1(uv+F2(-1.0, 1.0)*t,n)*a+\n  Noise1(uv+F2( 0.0, 1.0)*t,n)*b+\n  Noise1(uv+F2( 1.0, 1.0)*t,n)*a+\n 0.0);}\n\n// Compute temporal dither from integer pixel position uv.\nF1 Noise3(F2 uv){return Noise2(uv,fract(iTime));}    \n\n// Energy preserving dither, for {int pixel pos,color,amount}.\nF1 Noise4(F2 uv,F1 c,F1 a){\n // Grain value {-1 to 1}.\n F1 g=Noise3(uv)*2.0;\n // Step size for black in non-linear space.\n F1 rcpStep=1.0/(256.0-1.0);\n // Estimate amount negative which still quantizes to zero.\n F1 black=0.5*Linear(rcpStep);\n // Estimate amount above 1.0 which still quantizes to 1.0.\n F1 white=2.0-Linear(1.0-rcpStep);\n // Add grain.\n return clamp(c+g*min(c+black,min(white-c,a)),0.0,1.0);}\n\n//\n// Pattern\n//\n\n// Dummy shader given pixel position.\nF1 Shade(F2 p){\n p.xy+=sin(iTime)*2.0;\n F2 pp=F2(p.x+p.y/16.0,p.y+p.x/16.0);\n pp*=pp;\n F1 x=sin(pp.x/800.0)>0.0?0.5:0.0;\n F1 y=sin(pp.y/1000.0)>0.0?0.5:0.0;\n return x+y;}\n\n// 4xMSAA pattern for quad given integer coordinates.\n//\n//  . x . . | < pixel\n//  . . . x |\n//  x . . .\n//  . . x .\n//\n//  01\n//  23\n//\nF2 Quad4(F2 pp){\n int q=(int(pp.x)&1)+((int(pp.y)&1)<<1);\n if(q==0)return pp+F2( 0.25,-0.25);\n if(q==1)return pp+F2( 0.25, 0.25);\n if(q==2)return pp+F2(-0.25,-0.25);\n         return pp+F2(-0.25, 0.25);}\n\n// Rotate {0.0,r} by a {-1.0 to 1.0}. \nF2 Rot(F1 r,F1 a){return F2(r*cos(a*3.14159),r*sin(a*3.14159));}\n\n// Rotate {pp} by a {0.0 to 1.0}. \nF2 Rot2(F2 pp,F1 a){\n a*=3.14159*2.0;\n F1 cosA=cos(a);\n F1 sinA=sin(a);\n return F2(dot(pp,F2(cosA,sinA)),dot(pp,F2(-sinA,cosA)));}\n\n//\n// RESOLVES\n//\n    \n// Single center sample, nearest warp.\nF1 ResolveNoAA(F2 pp){return Shade(floor(Warp(pp)));}\n\n// Single center sample, bilinear warp.\nF1 ResolveNoAABi(F2 pp){\n pp=Warp(pp);\n F2 ii=floor(pp);\n F1 a=Shade(ii);\n F1 b=Shade(ii+F2(1.0,0.0));\n F1 c=Shade(ii+F2(0.0,1.0));\n F1 d=Shade(ii+F2(1.0,1.0));\n F2 ff=pp-ii;\n a=mix(a,b,ff.x);\n c=mix(c,d,ff.x);\n a=mix(a,c,ff.y);\n return a;}\n\nF1 Shade4(F2 pp){return\n Shade(pp+F2( 0.125,-0.375))*0.25+\n Shade(pp+F2(-0.375,-0.125))*0.25+\n Shade(pp+F2( 0.375, 0.125))*0.25+\n Shade(pp+F2(-0.125, 0.375))*0.25;}\n\n// 4xSGSSAA box resolve, bilinear warp.\nF1 Resolve4xBi(F2 pp){\n pp=Warp(pp);\n F2 ii=floor(pp);\n F1 a=Shade4(ii);\n F1 b=Shade4(ii+F2(1.0,0.0));\n F1 c=Shade4(ii+F2(0.0,1.0));\n F1 d=Shade4(ii+F2(1.0,1.0));\n F2 ff=pp-ii;\n a=mix(a,b,ff.x);\n c=mix(c,d,ff.x);\n a=mix(a,c,ff.y);\n return a;}\n\n// Resolve With Warp\n\nvoid M44(inout F1 sumC,inout F1 sumW,F2 pp,F2 mm){\n F1 kern=Kern(mm);\n kern*=3.0;\n F2 jj=Quad4(pp);\n F1 c=Shade(jj);\n jj=Unwarp(jj);\n F2 vv=mm-jj;\n F1 w=exp2(-(0.5+kern)*dot(vv,vv));    \n sumC+=c*w;sumW+=w;}\n\nvoid M4(inout F1 sumC,inout F1 sumW,F2 pp,F2 mm){\n M44(sumC,sumW,pp+F2( 0.125,-0.375),mm);\n M44(sumC,sumW,pp+F2(-0.375,-0.125),mm);\n M44(sumC,sumW,pp+F2( 0.375, 0.125),mm);\n M44(sumC,sumW,pp+F2(-0.125, 0.375),mm);}\n\n// 4xSGSSAA Gaussian Resolve With Warp\n// Over-kill on the number of filter taps taken for the resolve,\n// this is not required in practice,\n// just don't have time for an optimal implementation.\nF1 ResolveM4(F2 pp){\n F2 ww=floor(Warp(pp));\n F1 sumC=0.0;\n F1 sumW=0.0;\n // \n M4(sumC,sumW,ww+F2(-1.0,-2.0),pp);\n M4(sumC,sumW,ww+F2( 0.0,-2.0),pp);\n M4(sumC,sumW,ww+F2( 1.0,-2.0),pp);\n //\n M4(sumC,sumW,ww+F2(-2.0,-1.0),pp);\n M4(sumC,sumW,ww+F2(-1.0,-1.0),pp);\n M4(sumC,sumW,ww+F2( 0.0,-1.0),pp);\n M4(sumC,sumW,ww+F2( 1.0,-1.0),pp);\n M4(sumC,sumW,ww+F2( 2.0,-1.0),pp);\n //\n M4(sumC,sumW,ww+F2(-2.0, 0.0),pp);\n M4(sumC,sumW,ww+F2(-1.0, 0.0),pp);\n M4(sumC,sumW,ww+F2( 0.0, 0.0),pp);\n M4(sumC,sumW,ww+F2( 1.0, 0.0),pp);\n M4(sumC,sumW,ww+F2( 2.0, 0.0),pp);\n //   \n M4(sumC,sumW,ww+F2(-2.0, 1.0),pp);\n M4(sumC,sumW,ww+F2(-1.0, 1.0),pp);\n M4(sumC,sumW,ww+F2( 0.0, 1.0),pp);\n M4(sumC,sumW,ww+F2( 1.0, 1.0),pp);\n M4(sumC,sumW,ww+F2( 2.0, 1.0),pp);\n //\n M4(sumC,sumW,ww+F2(-1.0, 2.0),pp);\n M4(sumC,sumW,ww+F2( 0.0, 2.0),pp);\n M4(sumC,sumW,ww+F2( 1.0, 2.0),pp);\n // \n return sumC/sumW;}\n\n\n\n\n\n//\n// ENTRY\n//\n\nvoid mainImage(out F4 fragColor,in F2 fragCoord){\n F2 pp=fragCoord;\n F1 cc=0.0;\n int ss=MODE;\n // Red\n if(ss==0){\n  if(pp.y<8.0){fragColor.xyz=F3(1.0,0.0,0.0);return;}\n  cc=ResolveNoAA(pp);}\n // Orange\n else if(ss==1){\n  if(pp.y<8.0){fragColor.xyz=F3(1.0,0.5,0.0);return;}\n  cc=ResolveNoAABi(pp);}\n // Gold\n else if(ss==2){\n  if(pp.y<8.0){fragColor.xyz=F3(1.0,0.75,0.0);return;}\n  cc=Resolve4xBi(pp);}\n // Yellow\n else if(ss==3){\n  if(pp.y<8.0){fragColor.xyz=F3(1.0,1.0,0.0);return;}\n  cc=ResolveM4(pp);\n  cc=Noise4(pp,cc,1.0/16.0);}\n // Output   \n fragColor.x=Srgb(cc);\n fragColor.yxz=fragColor.xxx;}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dfyWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[708, 784, 798, 830, 918], [920, 991, 1005, 1037, 1179], [1181, 1192, 1208, 1240, 1463], [1465, 1497, 1511, 1511, 1567], [1569, 1601, 1617, 1617, 1670], [1719, 1794, 1814, 1814, 1921], [1923, 1977, 1999, 1999, 2374], [2380, 2434, 2456, 2456, 2833], [2835, 2894, 2911, 2911, 2943], [2949, 3012, 3039, 3066, 3420], [3440, 3478, 3493, 3493, 3648], [3650, 3787, 3803, 3803, 3989], [3991, 4030, 4048, 4048, 4094], [4096, 4131, 4151, 4151, 4261], [4286, 4325, 4347, 4347, 4378], [4380, 4420, 4444, 4444, 4660], [4662, 4662, 4679, 4679, 4826], [4828, 4868, 4890, 4890, 5110], [5112, 5134, 5184, 5184, 5341], [5343, 5343, 5392, 5392, 5557], [5559, 5755, 5775, 5775, 6632], [6638, 6654, 6703, 6703, 7255]]}
{"id": "4dfyzB", "name": "Gibberish", "author": "sea", "description": "Looks super weird.", "tags": ["perlinnoise"], "likes": 4, "viewed": 300, "published": "Public", "date": "1488608992", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hash (vec3 p)\n{\n    p = vec3(dot(p, vec3(189.0, 75.0, 121.0)), dot(p, vec3(122.0, 220.0, 62.0)), dot(p, vec3(34.0, 96.0, 162.0)));\n    return fract(sin(p) * 4328395.432885) * 2.0 - 1.0;\n}\n\nfloat perlin3 (vec3 p)\n{\n    vec3 lbb = floor(p);\n    vec3 rtf = ceil(p);\n    \n    vec3 ltb = vec3(lbb.x, rtf.y, lbb.z);\n    vec3 rbb = vec3(rtf.x, lbb.y, lbb.z);\n    vec3 rtb = vec3(rtf.x, rtf.y, lbb.z);\n    vec3 rbf = vec3(rtf.x, lbb.y, rtf.z);\n    vec3 lbf = vec3(lbb.x, lbb.y, rtf.z);\n    vec3 ltf = vec3(lbb.x, rtf.y, rtf.z);\n    \n    vec3 glbb = hash(lbb);\n    vec3 gltb = hash(ltb);\n    vec3 grbb = hash(rbb);\n    vec3 grtb = hash(rtb);\n    vec3 grbf = hash(rbf);\n    vec3 grtf = hash(rtf);\n    vec3 glbf = hash(lbf);\n    vec3 gltf = hash(ltf);\n    \n    vec3 dlbb = p - lbb;\n    vec3 dltb = p - ltb;\n    vec3 drbb = p - rbb;\n    vec3 drtb = p - rtb;\n    vec3 drbf = p - rbf;\n    vec3 drtf = p - rtf;\n    vec3 dlbf = p - lbf;\n    vec3 dltf = p - ltf;\n    \n    float d1 = dot(dlbb, glbb);\n    float d2 = dot(dltb, gltb);\n    float d3 = dot(drbb, grbb);\n    float d4 = dot(drtb, grtb);\n    float d5 = dot(drbf, grbf);\n    float d6 = dot(drtf, grtf);\n    float d7 = dot(dlbf, glbf);\n    float d8 = dot(dltf, gltf);\n    \n    p = mod(p, 1.0);\n    p = p * p * (3.0 - 2.0 * p);\n    \n    float x1 = mix(d1, d3, p.x);\n    float x2 = mix(d2, d4, p.x);\n    float x3 = mix(d7, d5, p.x);\n    float x4 = mix(d8, d6, p.x);\n    \n    float y1 = mix(x1, x2, p.y);\n    float y2 = mix(x3, x4, p.y);\n    \n    return mix(y1, y2, p.z);\n}\n\nvec2 rotate (vec2 p, float r)\n{\n    r *= 3.1415926 / 180.0;\n    float x = p.x * cos(r) - p.y * sin(r);\n    float y = p.x * sin(r) + p.y * cos(r);\n    return vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    \n    vec2 ws = uv;\n    ws.x *= iResolution.x / iResolution.y;\n    ws *= 8.0;\n    \n    ws = rotate(ws, 45.0 * cos(iTime) * abs(uv.x) * 1.0 + iTime * 25.0);\n    \n    float r = perlin3(vec3(ws, iTime));\n\n    ws = rotate(ws, r * 180.0);\n    ws = mod(ws, 2.0);\n    float c = dot(ws, vec2(1.0, 1.0)) * 0.5 - 0.5 * length(abs(uv * 2.0 - 1.0));\n\tfragColor = vec4(c, c, c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dfyzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 192], [194, 194, 218, 218, 1514], [1516, 1516, 1547, 1547, 1686], [1688, 1688, 1745, 1745, 2175]]}
{"id": "4dlcz2", "name": "Jfranmp - Clouds v2", "author": "jfranmp", "description": "A simple cloud based on thebookofshaders.com", "tags": ["cloudsv2"], "likes": 5, "viewed": 164, "published": "Public", "date": "1488979012", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// author: Juan Francisco\n// title: Clouds\n\n#define NUM_OCTAVES 10\n\nfloat random (in vec2 _st) { \n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233))) * \n        43758.5453123);\n}\n\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2( cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    //mat2 rot = mat2( 0, 3. * sin(0.5), 0, cos(0.50));\n    \n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    \n    return v;\n}\n\nvec3 grayscale(in vec3 _rgb) {\n    vec3 base = vec3(0.2989, 0.587, 0.114);\n    float lum = base.r * _rgb.r + base.g * _rgb.g + base.b * _rgb.b;\n    return vec3(lum);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 st = fragCoord.xy/ iResolution.xy * 5. + iTime / 25.;\n    vec3 color = vec3(0);\n\n    vec2 q = vec2(0.);\n    q.x = fbm( st + 0.00*iTime);\n    q.y = fbm( st + vec2(1.0));\n    \n    vec2 r = vec2(0.);\n    r.x = fbm( st + 1.0*q + vec2(1.7,9.2)+ 0.15*iTime );\n    r.y = fbm( st + 1.0*q + vec2(8.3,2.8)+ 0.126*iTime);\n\n    float f = fbm( st + fbm(st + fbm(st)));\n\n    color = mix(vec3(0.198,0.629,0.667),\n                vec3(0.666667,0.666667,0.498039),\n                clamp((f*f)*4.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0,0,0.164706),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(0.666667,1,1),\n                clamp(length(r.x),0.0,1.0));\n    \n    float x = .5 + fbm(st);\n    float nt = noise(vec2(iTime * .013, iTime * .013));\n    float v1 = pow(length(r), 2.5 + 1.5 * (1. - nt));\n    float v2 = 1.;\n    float alpha = mix(v2, v1, nt);\n    \n    vec3 colorv = 1. * color + f*f*f*color*color;\n    vec3 tint = vec3(0.682,0.933,1.000);\n    \n    // tint image\n    vec3 c1 = vec3(0.051,0.739,1.000);\n    vec3 c2 = vec3(1.000,0.080,0.089);\n    vec3 c3 = vec3(1.000,0.985,0.067);\n    \n    vec3 total = vec3(.0);\n    total = mix(c1, c2, noise(st));\n    total = mix(total, c3, noise(st * .75));\n    \n    fragColor = vec4(total * grayscale(colorv),alpha);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dlcz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 68, 96, 96, 207], [209, 209, 236, 236, 620], [622, 622, 648, 648, 1033], [1035, 1035, 1065, 1065, 1202], [1204, 1204, 1260, 1260, 2581]]}
{"id": "4dScRR", "name": "Headache Experiment 5", "author": "aiekick", "description": "Headache Experiment 5", "tags": ["experiment", "headache", "5"], "likes": 8, "viewed": 492, "published": "Public API", "date": "1490479911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nmat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\t// get rotation matrix near z\n\nvec2 df(vec3 p)\n{\n    p.xy -= sin(p.z*0.02)*5.;\n   \tfloat a = 0.72 * atan(p.x,p.y) * cos(p.z*0.025) * 2.;\n    p.xy *= mat2(cos(a),-sin(a),sin(a),cos(a));\n\tp = mod(p,6.)-3.;\n    float cyl = min(max(abs(p.x),abs(p.y)),length(p.yz));\n\treturn vec2(cyl-0.4, 0);\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nfloat SubDensity(vec3 p, float ms) \n{\n\treturn df(p - nor(p,0.0001) * ms).x/ms;\n}\n\nvec2 shade(vec3 ro, vec3 rd, float d, vec3 lp, vec3 ldo, float li)\n{\n\tvec3 p = ro + rd * d;\n\tvec3 n = nor(p, 0.1);\n\tvec3 ldp = normalize(lp-n*1.5-p);\n\tvec3 refl = reflect(rd,n);\n\tfloat amb = 0.6;\n\tfloat diff = clamp( dot( n, ldp ), 0.0, 1.0);\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4.);\n\tfloat spe = pow(clamp( dot( refl, ldo ), 0.0, 1.0 ), 16.);\n\tfloat sss = 1. - SubDensity(p, 0.1);\n\treturn vec2(\n        (diff + fre + spe) * amb * li,\n        (diff + fre + sss) * amb * li + spe\n    );\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tfloat t = iTime * 35.;\n\n    vec3 ld = vec3(0.,1., .5);\n    \n\tvec3 ro = vec3(0,0,t);\n    ro.xy += sin(t*0.02)*5.;\n\tvec3 cu = vec3(0,1,0);\n\tvec3 tg = ro + vec3(0,0,.1);\n\t\n\tfloat fov = .5;\n\tvec3 z = normalize(tg - ro);\n\tvec3 x = normalize(cross(cu, z));\n\tvec3 y = normalize(cross(z, x));\n\tvec3 rd = normalize(z + fov * (uv.x * x + uv.y * y));\n\t\n\tfloat s = 1., d = 1.;\n\tfloat dm = 100.;\n\t\n\tfor (float i=0.; i<250.; i++)\n\t{\n\t\tif (log(d/s/1e3)>0. || d>dm) break;\n\t\td += (s = df(ro + rd * d).x) * .4;\n\t}\n\t\n    fragColor.rgb = GetSky(rd, ld, vec3(1.5));\n    \n\tif (d<dm)\n\t{\n\t\tvec2 sh = shade(ro, rd, d, ro, ld, 1.);\n\t\tfragColor.rgb = mix( \n            vec3(.5,1,.8) * sh.x * 0.1 + vec3(0.8,0.5,0.2) * sh.y * 1.2, \n            fragColor.rgb, \n            1.0 - exp( -0.001*d*d ) ); \n\t}\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dScRR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 214, 233, 233, 291], [292, 323, 340, 340, 581], [583, 583, 615, 615, 793], [795, 857, 914, 914, 1202], [1204, 1204, 1241, 1241, 1284], [1286, 1286, 1354, 1354, 1787], [1789, 1789, 1843, 1843, 2681]]}
{"id": "4dscWX", "name": "Torus2D", "author": "TomCat", "description": "2D or 3D? Drag your mouse and have fun!", "tags": ["2d", "circles", "interactive", "torus"], "likes": 7, "viewed": 148, "published": "Public", "date": "1490145651", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CUT .25\n#define STEP 50.\n#define SPEED 8.\n#define PI2 6.28318\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ROT = iResolution.y / iMouse.y;\n    float FIRST = iMouse.x - iResolution.y;\n\n    float n = abs(FIRST);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv + uv - 1.;\n    uv *= iResolution.xy / iResolution.yy;\n    vec3 color = vec3(CUT);\n    float a = 0.;\n    for (float q = 0.; q < n; q++) {\n        float angle = q/n*PI2 + iTime/SPEED;\n        vec2 center = vec2(sin(angle)/1., cos(angle)/ROT);\n        vec2 d = center-uv;\n        if (d.x*d.x+d.y*d.y < 0.5) {\n        \ta = STEP;\n            color += 1./a;\n        }\n    }\n    if(color.x > 1.) color = 1.-(color-1.);\n    if(color.x < 0.) color = -1.*color;\n    if(FIRST < 0.) color += (.5*float(1&int(color*a))-.5);\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dscWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 128, 128, 846]]}
{"id": "4dsyWB", "name": "Ray bending 2", "author": "granskog", "description": "Rays pulled downwards on each iteration.", "tags": ["ray", "spheres", "bending", "inception"], "likes": 6, "viewed": 174, "published": "Public", "date": "1489681465", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdfPlane(in vec3 pos, in vec3 n) {\n    return dot(pos, n);\n}\n\nfloat sdfSphere(in vec3 pos, in float radius) {\n\treturn length(pos) - radius;   \n}\n\nfloat sdfUnion(in float a, in float b) {\n\treturn min(a, b);   \n}\n\nfloat samp(in vec3 pos) {\n \tvec3 spos = vec3(mod(pos.x, .7f) - 0.35f, pos.y, mod(pos.z, 0.7f) - 0.35f);\n    float sphere = sdfSphere(spos, 0.5f);\n    return sphere;\n}\n\n\n\nvec3 march(in vec3 origin, in vec3 dir, in float maxlen) {\n\tfloat dist = 0.0f;\n    vec3 pos = origin;\n    vec3 d = dir;\n    \n    while (dist < maxlen) {\n    \tfloat t = samp(pos);\n        if (t < 0.001f) {\n        \tfloat fx = samp(vec3(pos.x + 0.0001f, pos.y, pos.z)) - samp(vec3(pos.x - 0.0001f, pos.y, pos.z));\n\t\t\tfloat fy = samp(vec3(pos.x, pos.y + 0.0001f, pos.z)) - samp(vec3(pos.x, pos.y - 0.0001f, pos.z));\n\t\t\tfloat fz = samp(vec3(pos.x, pos.y, pos.z + 0.0001f)) - samp(vec3(pos.x, pos.y, pos.z - 0.0001f));\n\t\t\tvec3 normal = normalize(vec3(fx, fy, fz));\n            if (dot(-d, normal) < 0.0f) normal = -normal;\n            return vec3(max(normal.y, 0.4f));\n        }\n        \n        d = normalize(d + vec3(0, -0.0025f, 0));\n        \n        dist += 0.01f;\n        pos += 0.01f * d;\n    }\n    \n    return vec3(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float time = iTime;\n    \n    vec3 campos = vec3(-1.0f + iTime, 1.5f, -4.0f + iTime);\n    vec3 dir = normalize(vec3(1.5f, 1.0f, 1.0f));\n    vec3 side = normalize(cross(dir, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(side, dir));\n    float fov = 128.0f / 180.0f * 3.141592;\n   \tfloat ifov = 1.0f / tan(fov / 2.0f);\n    vec2 ndc = vec2(uv.x * 2.0f - 1.0f, (uv.y * 2.0f - 1.0));\n    ndc.y *= iResolution.y / iResolution.x;\n    \n    vec3 rdir = normalize(side * ndc.x + up * ndc.y + dir * ifov);\n    \n    vec3 c = march(campos, rdir, 50.0f);\n    \n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dsyWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 66], [68, 68, 115, 115, 150], [152, 152, 192, 192, 216], [218, 218, 243, 243, 384], [388, 388, 446, 446, 1212], [1215, 1215, 1272, 1272, 1892]]}
{"id": "4dsyWs", "name": "super egg world", "author": "halcy", "description": "twitter simulator 2017", "tags": ["egg"], "likes": 1, "viewed": 123, "published": "Public", "date": "1490364196", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// codapalette\nvec3 palette(float i) {\n\tif(i<4.0) {\n\t\tif(i<2.0) {\n\t\t\tif(i<1.0) return vec3(0.0,0.0,0.0);\n\t\t\telse return vec3(1.0,3.0,31.0);\n\t\t}\n\t\telse {\n\t\t\tif(i<3.0) return vec3(1.0,3.0,53.0);\n\t\t\telse return vec3(28.0,2.0,78.0);\n\t\t}\n\t}\n\telse if(i<8.0) {\n\t\tif(i<6.0) {\n\t\t\tif(i<5.0) return vec3(80.0,2.0,110.0);\n\t\t\telse return vec3(143.0,3.0,133.0);\n\t\t}\n\t\telse {\n\t\t\tif(i<7.0) return vec3(181.0,3.0,103.0);\n\t\t\telse return vec3(229.0,3.0,46.0);\n\t\t}\n\t}\n\telse {\n\t\tif(i<10.0) {\n\t\t\tif(i<9.0) return vec3(252.0,73.0,31.0);\n\t\t\telse return vec3(253.0,173.0,81.0);\n\t\t}\n\t\telse if(i<12.0) {\n\t\t\tif(i<11.0) return vec3(254.0,244.0,139.0);\n\t\t\telse return vec3(239.0,254.0,203.0);\n\t\t}\n\t\telse {\n\t\t\treturn vec3(242.0,255.0,236.0);\n\t\t}\n\t}\n}\n\nvec4 colour(float c) {\n\tc*=12.0;\n\tvec3 col1=palette(c)/256.0;\n\tvec3 col2=palette(c+1.0)/256.0;\n\treturn vec4(mix(col1,col2,c-floor(c)),1.0);\n}\n\n// twitter simulator 2017\nfloat distfunc(vec3 pos) {\n    pos.y += sin(pos.z * 0.1) * 4.0;\n    float sky = pow(abs(pos.x) * -pos.y, 0.5);\n    if(pos.y > 0.0) {\n        return(0.0);\n    }\n\treturn((cos(pos.x) + sin(pos.z) + pos.y - 3.0) + sky);\n}\n\n// iteration shaded ray marcher with some bonus stuff\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float time=iTime;\n\tvec2 coords=(2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n\n\tvec3 ray_dir=normalize(vec3(coords,1.0+0.0*sqrt(coords.x*coords.x+coords.y*coords.y)));\n\tvec3 ray_pos=vec3(0, sin(time) * 4.0 - 4.0, -time * 10.0);\n\n\tfloat a=cos(time * 0.1)*10.0;\n\tray_dir=ray_dir*mat3(\n\t\tcos(a),0.0,sin(a),\n\t\t0.0,1.0,0.0,\n\t\t-sin(a),0.0,cos(a)\n\t);\n\n\tfloat i=192.0;\n\tfor(int j=0;j<192;j++)\n\t{\n\t\tfloat dist=distfunc(ray_pos);\n\t\tray_pos+=dist*ray_dir*0.5;\n\n\t\tif(abs(dist)<0.001) { i=float(j); break; }\n\t}\n    \n    float c=i/192.0;\n    c = c < 0.1 ? 0.1 : c;\n    float badving = pow(clamp(1.0 - length(coords) + 0.7, 0.0, 1.0), 0.4);\n    float badlines =  mod(fragCoord.y, 2.0) < 1.0 ? 0.8 : 1.0;\n    vec4 col = colour(1.0 - c) * badving * badlines;\n    float interpval = 1.0 - clamp(length(col) - 0.2, 0.0, 1.0);\n    fragColor = mix(col, colour(texture(iChannel0, ray_dir.xy).x), interpval);\n}  \n ", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dsyWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 15, 38, 38, 719], [721, 721, 743, 743, 862], [864, 890, 916, 916, 1107], [1109, 1163, 1219, 1219, 2131]]}
{"id": "4dXcWB", "name": "Mellow rainbow blob", "author": "bwestlin", "description": "Raymarching adaptation of https://www.shadertoy.com/view/ldGSWV", "tags": ["raymarching", "sound", "sines"], "likes": 5, "viewed": 133, "published": "Public", "date": "1489594048", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n#define ic0 iChannel0\n\nconst float EPS = 0.001;\nconst float MAX_ITER = 40.0;\nconst float MAX_T = 100.0;\n\nvec3 simple_camera(vec2 uv) {\n    vec3 forward = vec3(0.0, 0.0, -1.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 side = vec3(1.0, 0.0, 0.0);\n    return normalize(forward + uv.x * side + uv.y * up);\n}\n\nfloat opU( float d1, float d2 ) {\n  return min(d1, d2);\n}\n\n// Smooth minimum : http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat sdSphere(vec3 p, float s) {\n  return length(p)-s;\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) + n.w;\n}\n\n/*\n\tReturn the closest distance to any surface from point p.\n */\nfloat map(vec3 p) {\n    //float s1 = sdSphere(p - vec3(0.0, 0.0 + sin(iTime * 2.0), -3.0), 1.0);\n    float s1 = sdSphere(p - vec3(0.0, -0.5 + texture(ic0, vec2(.1, 0.)).x * 2. + sin(iTime * 2.0)/ 5., -3.0), 0.7 + texture(ic0, vec2(.4, 0.)).x);\n    float s2 = sdPlane(p - vec3(0.0, -1.0, 0.0), vec4(0.0, 1.0, 0.0, 1.0));\n    return smin(s1, s2, 4.0);\n}\n\n\nfloat intersect(vec3 origin, vec3 rayDir) \n{\n    float t = 0.0;\n    float dt = 0.1;\n    \n    for (float i = 0.0; i < MAX_ITER; i += 1.0) {\n        t += dt;\n        \n        dt = map(t * rayDir + origin);\n        if (abs(t) < EPS) {\n            break;\n        }\n        \n        if (t > MAX_T) {\n            t = 0.0;\n            break;\n        }\n\n    }\n\treturn t;\n}\n\n\n\nvec3 plasma(vec2 uv) {\n    float s1 = .5 + .5 * min(texture(ic0, vec2(.1, 0.) ).x * 1.5, 1.);\n    float s2 = .5 + .5 * min(texture(ic0, vec2(.4, 0.) ).x * 1.5, 1.);\n    float s3 = .5 + .5 * min(texture(ic0, vec2(.6, 0.) ).x * 1.5, 1.);\n    float s4 = .5 + .5 * min(texture(ic0, vec2(.9, 0.) ).x * 1.5, 1.);\n    \n    vec2 p1 = vec2(0., 0.);\n    vec2 p2 = vec2(0., 1.);\n    vec2 p3 = vec2(1., 1.0);\n    vec2 p4 = vec2(1., 0.);\n       \n    float c1 = .5 + .5 * sin(distance(uv, p1) * 10. * s1 + t + s1 / 4.);\n    float c2 = .5 + .5 * sin(distance(uv, p2) * 10. * s2 + t + s2 / 4.);\n    float c3 = .5 + .5 * sin(distance(uv, p3) * 10. * s3 + t + s3 / 4.);\n    float c4 = .5 + .5 * sin(distance(uv, p4) * 25. * s4 + t * 3. + s4 / 4.);\n           \n\treturn vec3(c1 + c4 * .33, c2 + c4 * .33, c3 + c4 * .33);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 cameraOrigin = vec3(0.0);\n    vec3 rayDir = simple_camera(uv);\n        \n    vec3 color = vec3((uv.y - 0.5) * (1.5 + sin(t * .2) * .5), 0.0, uv.y);\n    \n    float t = intersect(cameraOrigin, rayDir);\n    \n    if (t > 0.0) {\n        // calculate intersection point\n        vec3 hit = cameraOrigin + t * rayDir;        \n        \n        // get the color of the pixel\n        //color = texture(iChannel0, hit.xy).xyz;\n        color = plasma(hit.xy / 7.);\n        \n        // fade with distance\n        color *= vec3(6.0 / (t*t));\n    }\n    \n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dXcWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 150, 150, 322], [324, 324, 357, 357, 381], [383, 452, 493, 493, 586], [589, 589, 622, 622, 646], [648, 648, 679, 679, 713], [715, 780, 799, 876, 1131], [1134, 1134, 1178, 1178, 1498], [1502, 1502, 1524, 1524, 2304], [2306, 2306, 2363, 2363, 3052]]}
{"id": "4dXczX", "name": "PS20-GRAPROG", "author": "River01", "description": "PS20-GRAPROG", "tags": ["ps20graprog"], "likes": 1, "viewed": 122, "published": "Public", "date": "1489581838", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nfloat rand(vec2 uv)\n{\n    //return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Gradient noise\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\nfloat circle(vec2 uv, float radius, vec2 position)\n{\n    float value = smoothstep(distance(position+noise(uv*20.+iTime)*.05,uv), radius, .93);\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x*=ratio;\n    \n    float value = circle(uv, .12, vec2(0.5*ratio,0.8));\n    value += circle(uv, .07, vec2(0.5*ratio,0.7));\n    value += circle(uv, .09, vec2(0.5*ratio,0.59));\n    value += circle(uv, .09, vec2(0.47*ratio,0.53));\n    value += circle(uv, .09, vec2(0.53*ratio,0.53));\n    value += circle(uv, .089, vec2(0.41*ratio,0.51));\n    value += circle(uv, .08, vec2(0.59*ratio,0.51));\n    value += circle(uv, .088, vec2(0.497*ratio,0.43));\n    value += circle(uv, .036, vec2(0.40*ratio,0.41));\n    value += circle(uv, .036, vec2(0.40*ratio,0.39));\n    value += circle(uv, .036, vec2(0.594*ratio,0.42));\n    value += circle(uv, .036, vec2(0.594*ratio,0.39));\n    value += circle(uv, .042, vec2(0.5*ratio,0.37));\n    value += circle(uv, .06, vec2(0.5*ratio,0.35));\n    value += circle(uv, .046, vec2(0.51*ratio,0.33));\n    value += circle(uv, .046, vec2(0.49*ratio,0.33));\n    value += circle(uv, .046, vec2(0.52*ratio,0.32));\n    value += circle(uv, .046, vec2(0.48*ratio,0.32));\n    value += circle(uv, .048, vec2(0.53*ratio,0.31));\n    value += circle(uv, .048, vec2(0.47*ratio,0.31));\n    value += circle(uv, .048, vec2(0.53*ratio,0.30));\n    value += circle(uv, .048, vec2(0.47*ratio,0.30));\n    value += circle(uv, .048, vec2(0.5*ratio,0.30));\n    value += circle(uv, .05, vec2(0.54*ratio,0.29));\n    value += circle(uv, .05, vec2(0.46*ratio,0.29));\n    value += circle(uv, .048, vec2(0.5*ratio,0.29));\n    value += circle(uv, .05, vec2(0.54*ratio,0.27));\n    value += circle(uv, .05, vec2(0.46*ratio,0.27));\n    value += circle(uv, .058, vec2(0.5*ratio,0.28));\n    value += circle(uv, .05, vec2(0.54*ratio,0.26));\n    value += circle(uv, .05, vec2(0.46*ratio,0.26));\n    value += circle(uv, .058, vec2(0.5*ratio,0.27));\n    value += circle(uv, .05, vec2(0.54*ratio,0.25));\n    value += circle(uv, .05, vec2(0.46*ratio,0.25));\n    value += circle(uv, .058, vec2(0.5*ratio,0.26));\n    value += circle(uv, .05, vec2(0.54*ratio,0.24));\n    value += circle(uv, .05, vec2(0.46*ratio,0.24));\n    value += circle(uv, .058, vec2(0.5*ratio,0.25));\n    value += circle(uv, .05, vec2(0.54*ratio,0.23));\n    value += circle(uv, .05, vec2(0.46*ratio,0.23));\n    value += circle(uv, .058, vec2(0.5*ratio,0.24));\n    value += circle(uv, .05, vec2(0.549*ratio,0.22));\n    value += circle(uv, .05, vec2(0.459*ratio,0.22));\n    value += circle(uv, .058, vec2(0.5*ratio,0.23));\n    value += circle(uv, .05, vec2(0.549*ratio,0.21));\n    value += circle(uv, .05, vec2(0.459*ratio,0.21));\n    value += circle(uv, .058, vec2(0.5*ratio,0.22));\n    value += circle(uv, .05, vec2(0.55*ratio,0.20));\n    value += circle(uv, .05, vec2(0.45*ratio,0.20));\n    value += circle(uv, .058, vec2(0.5*ratio,0.22));\n    value += circle(uv, .05, vec2(0.55*ratio,0.20));\n    value += circle(uv, .05, vec2(0.45*ratio,0.20));\n    value += circle(uv, .058, vec2(0.5*ratio,0.21));\n    value += circle(uv, .05, vec2(0.55*ratio,0.19));\n    value += circle(uv, .05, vec2(0.45*ratio,0.19));\n    value += circle(uv, .058, vec2(0.5*ratio,0.20));\n    value += circle(uv, .05, vec2(0.55*ratio,0.18));\n    value += circle(uv, .05, vec2(0.45*ratio,0.18));\n    value += circle(uv, .06, vec2(0.5*ratio,0.19));\n    value += circle(uv, .05, vec2(0.559*ratio,0.17));\n    value += circle(uv, .05, vec2(0.441*ratio,0.17));\n    value += circle(uv, .06, vec2(0.5*ratio,0.19));\n    value += circle(uv, .05, vec2(0.559*ratio,0.17));\n    value += circle(uv, .05, vec2(0.441*ratio,0.17));\n    value += circle(uv, .06, vec2(0.5*ratio,0.18));\n    value += circle(uv, .05, vec2(0.56*ratio,0.16));\n    value += circle(uv, .05, vec2(0.44*ratio,0.16));\n    value += circle(uv, .064, vec2(0.5*ratio,0.17));\n    value += circle(uv, .05, vec2(0.56*ratio,0.15));\n    value += circle(uv, .05, vec2(0.44*ratio,0.15));\n    value += circle(uv, .064, vec2(0.5*ratio,0.16));\n    value += circle(uv, .05, vec2(0.56*ratio,0.14));\n    value += circle(uv, .05, vec2(0.44*ratio,0.14));\n    value += circle(uv, .064, vec2(0.5*ratio,0.15));\n    value += circle(uv, .05, vec2(0.56*ratio,0.13));\n    value += circle(uv, .05, vec2(0.44*ratio,0.13));\n    value += circle(uv, .064, vec2(0.5*ratio,0.14));\n    value += circle(uv, .05, vec2(0.569*ratio,0.12));\n    value += circle(uv, .05, vec2(0.431*ratio,0.12));\n    value += circle(uv, .07, vec2(0.5*ratio,0.13));\n    value += circle(uv, .05, vec2(0.57*ratio,0.11));\n    value += circle(uv, .05, vec2(0.43*ratio,0.11));\n    value += circle(uv, .07, vec2(0.5*ratio,0.12));\n    value += circle(uv, .05, vec2(0.57*ratio,0.10));\n    value += circle(uv, .05, vec2(0.43*ratio,0.10));\n    value += circle(uv, .07, vec2(0.5*ratio,0.11));\n    value += circle(uv, .05, vec2(0.57*ratio,0.09));\n    value += circle(uv, .05, vec2(0.43*ratio,0.09));\n    value += circle(uv, .074, vec2(0.5*ratio,0.10));\n    value += circle(uv, .05, vec2(0.579*ratio,0.08));\n    value += circle(uv, .05, vec2(0.421*ratio,0.08));\n    value += circle(uv, .074, vec2(0.5*ratio,0.09));\n    value += circle(uv, .05, vec2(0.579*ratio,0.07));\n    value += circle(uv, .05, vec2(0.421*ratio,0.07));\n    value += circle(uv, .074, vec2(0.5*ratio,0.08));\n    value += circle(uv, .05, vec2(0.58*ratio,0.06));\n    value += circle(uv, .05, vec2(0.42*ratio,0.06));\n    value += circle(uv, .074, vec2(0.5*ratio,0.07));\n    value += circle(uv, .05, vec2(0.58*ratio,0.05));\n    value += circle(uv, .05, vec2(0.42*ratio,0.05));\n    value += circle(uv, .08, vec2(0.5*ratio,0.06));\n    value += circle(uv, .05, vec2(0.58*ratio,0.04));\n    value += circle(uv, .05, vec2(0.42*ratio,0.04));\n    value += circle(uv, .1, vec2(0.5*ratio,0.05));\n    value += circle(uv, .05, vec2(0.589*ratio,0.03));\n    value += circle(uv, .05, vec2(0.411*ratio,0.03));\n    value += circle(uv, .12, vec2(0.5*ratio,0.04));\n    value += circle(uv, .05, vec2(0.589*ratio,0.02));\n    value += circle(uv, .05, vec2(0.411*ratio,0.02));\n    value += circle(uv, .12, vec2(0.5*ratio,0.03));\n    value += circle(uv, .05, vec2(0.59*ratio,0.01));\n    value += circle(uv, .05, vec2(0.41*ratio,0.01));\n    value += circle(uv, .12, vec2(0.5*ratio,0.02));\n    value += circle(uv, .05, vec2(0.59*ratio,0.0));\n    value += circle(uv, .05, vec2(0.41*ratio,0.0));\n    \n    value += circle(uv, .031, vec2(0.401*ratio,0.34));\n    value += circle(uv, .031, vec2(0.599*ratio,0.34));\n    value += circle(uv, .031, vec2(0.401*ratio,0.338));\n    value += circle(uv, .031, vec2(0.599*ratio,0.338));\n    value += circle(uv, .031, vec2(0.401*ratio,0.336));\n    value += circle(uv, .031, vec2(0.599*ratio,0.336));\n    value += circle(uv, .031, vec2(0.401*ratio,0.334));\n    value += circle(uv, .031, vec2(0.599*ratio,0.334));\n    value += circle(uv, .031, vec2(0.401*ratio,0.331));\n    value += circle(uv, .031, vec2(0.599*ratio,0.331));\n    value += circle(uv, .031, vec2(0.401*ratio,0.329));\n    value += circle(uv, .031, vec2(0.599*ratio,0.329));\n    value += circle(uv, .031, vec2(0.401*ratio,0.327));\n    value += circle(uv, .031, vec2(0.599*ratio,0.327));\n    value += circle(uv, .031, vec2(0.401*ratio,0.325));\n    value += circle(uv, .031, vec2(0.599*ratio,0.325));\n    value += circle(uv, .031, vec2(0.401*ratio,0.322));\n    value += circle(uv, .031, vec2(0.599*ratio,0.322));\n    value += circle(uv, .031, vec2(0.401*ratio,0.32));\n    value += circle(uv, .031, vec2(0.599*ratio,0.32));\n    value += circle(uv, .031, vec2(0.401*ratio,0.318));\n    value += circle(uv, .031, vec2(0.599*ratio,0.318));\n    value += circle(uv, .031, vec2(0.401*ratio,0.316));\n    value += circle(uv, .031, vec2(0.599*ratio,0.316));\n    value += circle(uv, .031, vec2(0.401*ratio,0.314));\n    value += circle(uv, .031, vec2(0.599*ratio,0.314));\n    value += circle(uv, .031, vec2(0.401*ratio,0.312));\n    value += circle(uv, .031, vec2(0.599*ratio,0.312));\n    value += circle(uv, .031, vec2(0.401*ratio,0.31));\n    value += circle(uv, .031, vec2(0.599*ratio,0.31));\n    value += circle(uv, .031, vec2(0.401*ratio,0.307));\n    value += circle(uv, .031, vec2(0.599*ratio,0.307));\n    value += circle(uv, .027, vec2(0.401*ratio,0.305));\n    value += circle(uv, .027, vec2(0.599*ratio,0.305));\n    value += circle(uv, .027, vec2(0.401*ratio,0.301));\n    value += circle(uv, .027, vec2(0.599*ratio,0.301));\n    value += circle(uv, .027, vec2(0.401*ratio,0.297));\n    value += circle(uv, .027, vec2(0.599*ratio,0.297));\n    value += circle(uv, .027, vec2(0.401*ratio,0.293));\n    value += circle(uv, .027, vec2(0.599*ratio,0.293));\n    value += circle(uv, .027, vec2(0.409*ratio,0.289));\n    value += circle(uv, .027, vec2(0.591*ratio,0.289));\n    value += circle(uv, .027, vec2(0.409*ratio,0.285));\n    value += circle(uv, .027, vec2(0.591*ratio,0.285));\n    value += circle(uv, .027, vec2(0.409*ratio,0.278));\n    value += circle(uv, .027, vec2(0.591*ratio,0.278));\n    value += circle(uv, .027, vec2(0.409*ratio,0.274));\n    value += circle(uv, .027, vec2(0.591*ratio,0.274));\n    value += circle(uv, .027, vec2(0.409*ratio,0.27));\n    value += circle(uv, .027, vec2(0.591*ratio,0.27));\n    value += circle(uv, .024, vec2(0.409*ratio,0.262));\n    value += circle(uv, .024, vec2(0.591*ratio,0.262));\n    value += circle(uv, .024, vec2(0.409*ratio,0.254));\n    value += circle(uv, .024, vec2(0.591*ratio,0.254));\n    value += circle(uv, .024, vec2(0.409*ratio,0.246));\n    value += circle(uv, .024, vec2(0.591*ratio,0.246));\n    \n\tfragColor = vec4(vec3(value),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dXczX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 76, 251, 317], [319, 334, 359, 359, 870], [872, 890, 948, 948, 1086], [1088, 1088, 1115, 1115, 1513], [1515, 1532, 1553, 1553, 1600], [1601, 1601, 1622, 1622, 1669], [1670, 1670, 1692, 1692, 1727], [1729, 1729, 1751, 1751, 2799], [2802, 2802, 2854, 2854, 2964], [2966, 2966, 3023, 3023, 12425]]}
{"id": "4dXyRf", "name": "GRAPROG Creature", "author": "lyradss", "description": "Creature that moves-like-jagger", "tags": ["tags"], "likes": 0, "viewed": 63, "published": "Public", "date": "1489582146", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvec3 colorB1 = vec3(0.000, 0.000, 0.400);\nvec3 colorR1 = vec3(0.820, 0.031, 0.114);\nvec3 colorO = vec3(1.000,0.549,0.000);\nvec3 colorY = vec3(1.000,1.000,0.000);\nvec3 colorB = vec3(0.000,0.000,1.000);\nvec3 colorLB = vec3(0.000,0.749,1.000);\nvec3 colorG = vec3(0.000, 1.000, 0.000);\nvec3 colorR = vec3(1.000, 0.000, 0.000);\nvec3 colorS = vec3(0.647, 0.949, 0.952);\nvec3 colorW = vec3(1.000, 1.000, 1.000);\nvec3 colorP = vec3(1.000, 0.078, 0.576);\nvec3 colorA = vec3(0.831, 0.404, 0.098);\n\n\nfloat rand(vec2 uv)\n{\n    //return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Gradient noise\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat createPolygon(vec2 uv, int sides)\n{\n\n    float a = atan(uv.x,uv.y) + PI;\n\tfloat r = TWO_PI / float(sides);\n  \n\t// Shaping function that modulate the distance\n\tfloat dist = cos(floor(.5+a/r)*r-a)*length(uv);\n    float offset = gnoise(uv*.2+iTime)*.2;\n    //float value = 1.-step(radius, dist);\n    float value = 1. - smoothstep(.4, .42, dist * 3.95); \n    \n    return value;\n}\n\nfloat createPolygon2(vec2 uv, int sides)\n{\n\n    float a = atan(uv.x,uv.y) + PI;\n\tfloat r = TWO_PI / float(sides);\n  \n\t// Shaping function that modulate the distance\n\tfloat dist = cos(floor(.5+a/r)*r-a)*length(uv/2.5);\n    float offset = gnoise(uv*.2+iTime)*.2;\n    //float value = 1.-step(radius, dist);\n    float value = 1. - smoothstep(.4, .42, dist * 3.95); \n    \n    return value;\n}\n\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle)); \n}\t\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    \n    \n    float zoom = .2;\n    float scale = .1;\n    float offset = gnoise(uv*zoom+iTime)*scale;\n    float offset2 = gnoise(uv*zoom+iTime)*.05;\n    float offset3 = snoise(uv*zoom+iTime)*.1;\n\t\n    \n    vec3 color = vec3(0.0);\n\n    //float zoom = 4. * 3.;\n    //float scale = .04  * 9.;\n    //float offset = snoise(uv*zoom+iTime)*scale;\n\t\n    //float value = step(.5 + offset , uv.x) - step (.52+offset, uv.x);\n    //value /= rand(uv*iTime);\n    \n    float value = step(.2 + offset3, uv.y) - step(.65 + offset3, uv.y);\n    value *= step(.4 + offset, uv.x) - step(.7 + offset, uv.x);\n    value += step(.301 + offset, uv.x) - step(.4 + offset, uv.x);\n    value += step(.6 + offset, uv.x) - step(.701 + offset, uv.x);\n    value -= step(.91 + offset3, uv.y);\n    value *= step(.35 + offset , uv.y);\n    \n    color = value * colorG;\n    \n    //triangle\n    vec2 shapePos = vec2(0.503, 0.3);\n    //uv.x *= ratio; \n    uv -= shapePos;\n    uv *= rotate2d(1.045);\n    value += createPolygon(uv - offset, 3);\n    \n    \n    color += value * colorB;\n    \n    //Body\n    shapePos -= vec2(0.45, 0.33);\n    uv -= shapePos;\n    uv *= rotate2d(2.1);\n    \n    value += createPolygon2(uv + offset2, 4);\n    \n    color += value * colorB1;\n    \n    \n    \n    \n    //value = step(.45 * mouse.y + r, uv.x) - step (.60 * mouse.y + r, uv.x);\n    \n\n    //color = value * colorR;\n    //color = value * colorY;\n    //color = value * mix(colorY, colorB, abs(sin(iTime * 600000.)));\n    //color += value * mixcolorR, colorO, abs(sin(iTime * 600000.)));\n  \n  \n    //uv - fract(uv);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dXyRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[544, 544, 565, 740, 806], [808, 823, 848, 848, 1359], [1361, 1379, 1437, 1437, 1575], [1577, 1577, 1604, 1604, 2002], [2004, 2021, 2042, 2042, 2089], [2090, 2090, 2111, 2111, 2158], [2159, 2159, 2181, 2181, 2216], [2218, 2218, 2240, 2240, 3288], [3290, 3290, 3331, 3331, 3671], [3673, 3673, 3715, 3715, 4059], [4062, 4062, 4090, 4090, 4159], [4164, 4164, 4221, 4221, 5949]]}
{"id": "4l3XD8", "name": "Droplet (Ray Marching Exercise)", "author": "ereif", "description": "Lab 10 for CS123", "tags": ["lab"], "likes": 1, "viewed": 179, "published": "Public", "date": "1488576875", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPHERE 0\n#define PLANE 1\n#define NO_INTERSECT 2\n#define DISPLACEMENT_FACTOR 0.1\n\n// Data structure for raymarching results\nstruct PrimitiveDist {\n    float dist;\n    int primitive; // Can be SPHERE, PLANE, or NO_INTERSECT\n};\n\n// Helper function for tri3.\nfloat tri(in float x) {\n\treturn abs(fract(x)-.5);\n}\n\n// Triangle noise. Use it as a sample displacement map for task 7.\nvec3 tri3(in vec3 p) {\n    return vec3(tri(p.z+tri(p.y*1.)), \n                tri(p.z+tri(p.x*1.)), \n                tri(p.y+tri(p.x*1.)));\n}\n\n// TODO [Task 8] Make a displacement map\n// You can check out tri3 above and the functions in the handout as inspiration\nfloat calcDisplacement(in vec3 p) {\n    //return (sin(p.x)/2.0 * sin(p.y*p.y) + sin(iTime))*1.2;\n    float r = sqrt(p.x*p.x + p.z*p.z);\n    float radiusWithTime = sqrt(p.x*p.x + p.z*p.z) * 7.0  - 9.0 * iTime;\n    \n    float zeroerOut = max(r - 0.5, 0.0);\n    \n    //if (r < 0.5) {\n       // if (mod(iTime*9.0, 9.0) > 4.5) {\n        //\treturn 0.0;\n        //}\n        //return r*r + 2.0*sin(9.0 *iTime);\n        //return (min(p.x, p.z));\n    //}\n    float widthOfWaves = - 1.0;\n    float invHeight = 5.0;\n    return p.y*invHeight + widthOfWaves + sin(radiusWithTime);\n}\n\n// TODO [Task 6] Implement triplanar texture mapping\n// If you want, you can play around with the textures in iChannels 0 and 1\n// The textures should show no distortion\nvec3 texCube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec4 zPlane = texture(sam, vec2(p.x, p.y));\n    vec4 xPlane = texture(sam, vec2(p.y, p.z));\n    vec4 yPlane = texture(sam, vec2(p.x, p.z));\n    \n    vec4 color = zPlane*abs(n.z) + xPlane*abs(n.x) + yPlane*abs(n.y);\n    return vec3(normalize(color));\n}\n\n// Signed distance to the twisted sphere.\nfloat sdTwistedSphere(vec3 p) {\n    vec3 spherePosition = vec3(0.0, 0.25, 0.0);\n    float radius = 1.5;\n    float primitive = length(p - spherePosition) - radius;\n    return primitive + calcDisplacement(p);\n}\n\nfloat sdFloor(vec3 p) {\n    return p.y;\n}\n\nPrimitiveDist map(vec3 p) {\n    // TODO [Task 3] Implement distance map\n    float sph = sdTwistedSphere(p);\n    float flo = sdFloor(p);\n    if (sph > flo) {\n        return PrimitiveDist(flo, PLANE);\n    } else {\n        return PrimitiveDist(sph, SPHERE);\n    }\n}\n\n// TODO [Task 4] Calculate surface normals\nconst float epsilon = 0.001;\nconst vec2 e = vec2(epsilon, 0.0); // For swizzling\nvec3 calcNormal(vec3 p) {\n    float x = map(p + e.xyy).dist - map(p - e.xyy).dist;\n    float y = map(p + e.yxy).dist - map(p - e.yxy).dist;\n    float z = map(p + e.yyx).dist - map(p - e.yyx).dist;\n\n    return normalize(vec3(x, y, z));\n}\n\nfloat shadow(vec3 ro, vec3 rd, float k) {\n    float marchDist = 0.001;\n    float boundingVolume = 25.0;\n    float darkness = 1.0;\n    float threshold = 0.001;\n    \n    for(int i = 0; i < 30; i++) {\n        if(marchDist > boundingVolume) continue;\n        float h = map(ro + rd * marchDist).dist;\n        // TODO [Task 7] Modify the loop to implement soft shadows\n            darkness = min(darkness, k * h / marchDist);\n        marchDist += h * 0.7;\n    }\n    \n    return darkness;\n}\n\n\nPrimitiveDist raymarch(vec3 ro, vec3 rd) {\n    \n    // TODO [Task 2] Implement ray marching algorithm\n    // Fill in parameters\n    float marchDist = 0.001;\n    float boundingDist = 50.0;\n    float threshold = 0.0001;\n    \n    // Fill in the iteration count\n    for (int i = 0; i < 1000; i++) {\n        // Fill in loop body\n        vec3 worldSpaceRay = ro + rd*marchDist;\n        PrimitiveDist dist = map(worldSpaceRay);\n        \n        // Exit\n        if (dist.dist < threshold){\n        \treturn PrimitiveDist(marchDist, dist.primitive);\n        }\n        if (dist.dist > boundingDist) {\n        \tbreak;\n        }       \n        marchDist += 0.1 * dist.dist;\n    }\n    \n    return PrimitiveDist(-1.0, NO_INTERSECT);\n}\n\nvec3 render(vec3 ro, vec3 rd, float t, int which) {\n    \n    // Col is the final color of the current pixel.\n    vec3 col = vec3(0.);\n    vec3 pos = ro + rd * t;\n    // Light vector\n    vec3 lig = normalize(vec3(1.0,0.6,0.5));\n    \n    // Normal vector\n    vec3 nor = calcNormal(pos);\n    // Ambient\n    float ambient = 0.1;\n    // Diffuse\n    float diffuse = clamp(dot(nor, lig), 0.0, 1.0);\n    // Specular\n    float shineness = 32.0; \n    float specular = pow(clamp(dot(rd, reflect(lig, nor)), 0.0, 1.0), 32.0);\n    \n    float darkness = shadow(pos, lig, 18.0);\n    // Applying the phong lighting model to the pixel.\n    col += vec3(((ambient + diffuse + specular) * darkness));\n    \n    // TODO [Task 5] Assign different intersected objects with different materials\n    // Make things pretty!\n    vec3 material = vec3(0.0);\n    if (which == PLANE) {\n        material = texCube(iChannel0, pos, nor);\n    } else if (which == SPHERE) {\n        material = texCube(iChannel1, pos, nor);\n    } else {\n        material = vec3(0.0);\n    }\n    \n    // Blend the material color with the original color.\n    col = mix(col, material, 0.4);\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n   \n    vec3 rayOrigin = vec3(6.0 * sin(iTime * .3), 4.8, 6.0 * cos(iTime * .3));\n    \n    float focalLength = 2.0;\n    \n    // The target we are looking at\n    vec3 target = vec3(0.0);\n    // Look vector\n    vec3 look = normalize(rayOrigin - target);\n    // Up vector\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // Set up camera matrix\n    vec3 cameraForward = -look;\n    vec3 cameraRight = normalize(cross(cameraForward, up));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraForward)); \n  \n    // TODO [Task 1] Construct the ray direction vector\n    float u = fragCoord.x/iResolution.x * 2.0 - 1.0;\n    float v = fragCoord.y/iResolution.y * 2.0 - 1.0;\n    u *= iResolution.x/iResolution.y;\n    vec2 uv = vec2(u, v);\n    vec3 rayDirection = vec3(uv, focalLength);\n    \n    vec3 x = cameraRight * rayDirection.x;\n    vec3 y = cameraUp * rayDirection.y;\n    vec3 z = cameraForward * rayDirection.z;\n    \n    rayDirection = normalize(x + y + z);\n        \n    PrimitiveDist rayMarchResult = raymarch(rayOrigin, rayDirection);\n    vec3 col = vec3(0.0);\n    if (rayMarchResult.primitive != NO_INTERSECT) {\n      col = render(rayOrigin, rayDirection, rayMarchResult.dist, rayMarchResult.primitive);\n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l3XD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[234, 263, 286, 286, 314], [316, 383, 405, 405, 524], [526, 647, 682, 743, 1215], [1217, 1387, 1440, 1440, 1696], [1698, 1740, 1771, 1771, 1948], [1950, 1950, 1973, 1973, 1991], [1993, 1993, 2020, 2064, 2255], [2364, 2381, 2406, 2406, 2617], [2619, 2619, 2660, 2660, 3102], [3105, 3105, 3147, 3232, 3824], [3826, 3826, 3877, 3934, 4974], [4976, 4976, 5031, 5031, 6271]]}
{"id": "4s2czR", "name": "Ultimate Library", "author": "dr2", "description": "Even more books (use the mouse to look around, click in lower-right corner for b/w image)", "tags": ["raymarch", "hexagon", "books"], "likes": 15, "viewed": 634, "published": "Public API", "date": "1490640567", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Ultimate Library\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvec2 HexCellId (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nvec3 RgbToHsv (vec3 c);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\n\nconst float pi = 3.14159;\nconst float sqrt3 = 1.73205;\n\nvec3 ltDir, lbPos;\nvec2 idCell, szGr, bsa1, bsa2;\nfloat dstFar, tCur, rdRm, htRm, wlThk, rdHol, spShf, htShf;\nint idObj;\nbool bwImg;\nconst int idRm = 1, idRal = 2, idBks = 3, idShlf = 4, idLt = 5, idBl = 6;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float d, dMin, r, a, dWid, wdShf;\n  dMin = dstFar;\n  dWid = 0.15 * szGr.x;\n  wdShf = 0.06 * rdRm;\n  q = p;\n  idCell = HexCellId (q.xz / szGr.x);\n  q.xz -= vec2 (2. * idCell.x + idCell.y, sqrt3 * idCell.y) * szGr.x;\n  r = length (q.xz);\n  a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n  q.y = mod (q.y + szGr.y, 2. * szGr.y) - szGr.y;\n  qq = q;\n  q.xz = Rot2D (q.xz, 2. * pi * ((floor (6. * a + 0.5)) / 6.));\n  d = max (PrCylAnDf (q.xzy, rdRm, wlThk, htRm), dWid - abs (q.z));\n  d = min (d, max (htRm - abs (q.y), rdHol - 0.05 - r));\n  if (d < dMin) {dMin = d;  idObj = idRm; }\n  q = qq;  q.y -= - htRm + 0.6 * htRm;\n  d = PrTorusDf (q.xzy, 0.06, rdHol);\n  q = qq;  q.y -= - htRm + 0.3 * htRm;\n  q.y = abs (abs (q.y) - 0.1 * htRm);\n  d = min (d, PrTorusDf (q.xzy, 0.04, rdHol));\n  q = qq;  q.y -= - htRm + 0.3 * htRm;\n  q.xz = Rot2D (q.xz, 2. * pi * ((floor (18. * a) + 0.5) / 18.));\n  q.x += rdHol;\n  d = min (d, PrCylDf (q.xzy, 0.04, 0.3 * htRm));\n  if (d < dMin) { dMin = d;  idObj = idRal; }\n  q = qq;\n  q.xz = Rot2D (q.xz, 2. * pi * ((floor (6. * a) + 0.5) / 6.));\n  q.z = abs (q.z);\n  d = max (abs (r - rdRm + wlThk + 1. * wdShf) - 0.5 * wdShf, dot (q.xz, bsa2));\n  d = max (d, abs (q.y) - htRm);\n  if (d < dMin) {dMin = d;  idObj = idBks; }\n  d = max (abs (r - rdRm + wlThk + wdShf) - wdShf, dot (q.xz, bsa1));\n  d = max (d, min (abs (mod (q.y + 0.5 * spShf, spShf) - 0.5 * spShf) - htShf,\n     - dot (q.xz, bsa2)));\n  d = max (d, abs (q.y) - htRm);\n  if (d < dMin) {dMin = d;  idObj = idShlf; }\n  q.z = abs (q.z);\n  q -= vec3 (- 0.7 * rdRm, htRm - 0.04, 0.8);\n  d = PrCylDf (q.xzy, 0.3, 0.03);\n  if (d < dMin) {dMin = d;  idObj = idLt; }\n  d = PrSphDf (p - lbPos, 0.4);\n  if (d < dMin) { dMin = d;  idObj = idBl; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  float f;\n  p *= 4.;\n  f = dot (vec3 (Fbm2 (p.zy * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.xy * vec2 (1., 0.1))), abs (n));\n  return 0.8 * mix (vec3 (0.9, 0.5, 0.3), vec3 (0.55, 0.35, 0.1), f);\n}\n\nfloat GlowCol (vec3 ro, vec3 rd, float dstHit)\n{\n  vec3 ld;\n  float d, wGlow;\n  wGlow = 0.;\n  ld = lbPos - ro;\n  d = length (ld);\n  ld /= d;\n  if (d < dstHit) wGlow += pow (max (dot (rd, ld), 0.), 1024.);\n  return clamp (0.5 * wGlow, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 roo, col, vn, q, ld, bgCol;\n  vec2 gbRm, gbBk, g, bt;\n  float dstObj, r, a, bh, s, cRm, idFlr, lbCol, fr, spec;\n  bool isLit;\n  wlThk = 0.04 * szGr.x;\n  rdRm = szGr.x - 0.7 * wlThk;\n  rdHol = 0.5 * rdRm;\n  htRm = 0.93 * szGr.y;\n  spShf = htRm / 3.;\n  htShf = 0.05 * spShf;\n  bsa1 = vec2 (sin (1.2 * 2. * pi / 24.), cos (1.2 * 2. * pi / 24.));\n  bsa2 = vec2 (sin (1.16 * 2. * pi / 24.), cos (1.16 * 2. * pi / 24.));\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  isLit = true;\n  bgCol = (abs (rd.y) < 0.5) ? 0.5 * vec3 (0.7, 0.5, 0.) : ((rd.y > 0.) ?\n     vec3 (0.5, 0.5, 0.55) : vec3 (0., 0., 0.2));\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    q = ro;\n    q.xz -= vec2 (2. * idCell.x + idCell.y, sqrt3 * idCell.y) * szGr.x;\n    r = length (q.xz);\n    a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n    idFlr = floor (q.y / (2. * szGr.y) + 0.5);\n    gbRm = idCell + idFlr;\n    cRm = Noisefv2 (gbRm * vec2 (17., 11.));\n    q.y = mod (q.y + szGr.y, 2. * szGr.y) - szGr.y;\n    vn = ObjNf (ro);\n    spec = 0.1;\n    if (idObj == idRm) {\n      if (r < rdHol + 0.05) col = vec3 (0.6, 0.6, 0.7);\n      else if (vn.y < -0.99 && r < 0.99 * rdRm) col = vec3 (1.);\n      else if (r >= 0.99 * rdRm && vn.y <= 0.99) {\n        col = HsvToRgb (vec3 (Noisefv2 (vec2 (33. * idFlr + 1., 1.)), 0.4, 0.8));\n        if (abs (vn.y) < 0.01) col *= 0.6 + 0.3 * q.y / htRm;\n        isLit = false;\n      } else if (r > 0.99 * (rdRm - wlThk) ||\n          r >= 0.99 * rdRm && vn.y > 0.99) col = vec3 (0.7, 0.5, 0.);\n      else {\n        fr = (r - rdHol) / (rdRm - rdHol);\n        col = mix (vec3 (0.7), HsvToRgb (vec3 (cRm, 1., 1.)),\n           SmoothBump (0.1, 0.3, 0.05, mod (7. * fr, 1.))) * \n           (0.5 + 0.5 * smoothstep (0.1, 0.3, abs (0.5 - mod (6. * a - 0.5, 1.))) *\n           smoothstep (0.3, 0.6, fr));\n        g = vec2 (5. * (mod (6. * mod (a + 1./12., 1.), 1.) - 0.5), r - 0.835 * rdRm);\n        if (length (max (abs (g) - vec2 (0.5, 0.15), 0.)) < 0.1) {\n          col = vec3 (0.8);\n          if (ShowInt (vec2 (g.x - 0.5, g.y + 0.13),\n             vec2 (1., 0.25), 4., dot (mod (vec2 (42., 24.) + idCell, 100.),\n             vec2 (100., 1.))) != 0.) {\n            col = vec3 (0.1);\n            isLit = false;\n          }\n        }\n        g.y = r - 1.1 * rdHol;\n        if (length (max (abs (g) - vec2 (0.5, 0.15), 0.)) < 0.1) {\n          col = vec3 (0.8);\n          if (ShowInt (vec2 (g.x - 0.5, g.y + 0.12), vec2 (1., 0.25), 4.,\n             2048. + idFlr) != 0.) {\n            col = vec3 (0.1);\n            isLit = false;\n          }\n        }\n      }\n    } else if (idObj == idRal) {\n      col = vec3 (1.2, 1.2, 1.);\n      spec = 0.5;\n    } else if (idObj == idBks) {\n      bt = vec2 (5000. * a, 200. * q.y);\n      a = 52. * mod (6. * a + 0.5, 1.);\n      gbBk = floor (vec2 (q.y / spShf, a));\n      bh = (0.7 + 0.3 * Fbm2 ((gbRm + gbBk) * vec2 (19., 31.))) * spShf;\n      q.y = mod (q.y, spShf);\n      if (q.y < bh) {\n        q.xy = vec2 (2. * mod (a, 1.) - 1., q.y / bh - 0.5);\n        col = vec3 (HsvToRgb (vec3 (mod (cRm +\n           0.5 * (Fbm2 (gbBk * vec2 (17., 11.)) - 0.5), 1.), 1.,\n           SmoothBump (0.08, 0.92, 0.01, 0.55 + 0.45 * q.x))));\n        if (abs (abs (q.y) - 0.35) < 0.01 || abs (q.x) < 0.3 && abs (q.y) < 0.2 &&\n           Noisefv2 ((gbRm + gbBk) * vec2 (19., 31.) + floor (bt)) > 0.7) {\n          col *= 1.6;\n        } else {\n          spec = 0.3;\n          vn.xz = Rot2D (vn.xz, q.x);\n        }\n      } else {\n        col = vec3 (0.02);\n        isLit = false;\n      }\n    } else if (idObj == idShlf) {\n      q = vec3 (5. * (mod (6. * a, 1.) - 0.5), ro.y, r);\n      col = WoodCol (q, vn);\n    } else if (idObj == idLt) {\n      col = vec3 (1., 1., 0.7) * (0.5 - 0.5 * vn.y);\n      isLit = false;\n    } else if (idObj == idBl) {\n      col = (0.75 + 0.25 * dot (rd, normalize (lbPos - ro))) *\n         HsvToRgb (vec3 (0.14 + 0.02 * sin (4. * tCur), 1., 1.));\n      isLit = false;\n    }\n    if (idObj != idBl) {\n      ld = lbPos - ro;\n      s = length (ld);\n      ld /= s;\n      lbCol = 2. * clamp (dot (vn, ld), 0., 1.) / (1. + s * s);\n    }\n    if (isLit) col = col * (0.2 + 2. * lbCol +\n       0.5 * max (0., max (dot (vn, ltDir), 0.)) +\n       spec * pow (max (0., dot (ltDir, reflect (rd, vn))), 16.));\n  } else col = bgCol;\n  col = mix (col, bgCol, smoothstep (0.6, 1., min (dstObj / dstFar, 1.)));\n  if (bwImg && idObj != idBl) col = vec3 (1.) * pow (RgbToHsv (col).b, 1.5);\n  col = mix (col, vec3 (1., 1., 0.5), GlowCol (roo, rd, dstObj));\n  col = clamp (col, 0., 1.);\n  return col;\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  vec2 tp[7], td[6];\n  float dir, tc, tm;\n  tc = floor (t / 27.);\n  tm = mod (t, 27.);\n  p.y = 0.1 + 0.2 * sin (0.6 * t) + 2. * tc;\n  td[0] = vec2 (1., 0.);\n  tp[0] = vec2 (-0.5 + 2. * tc + step (13., tm), -0.5 * sqrt3);\n  if (tm < 26.) {\n    dir = -1. + 2. * step (13., tm);\n    tm = mod (tm, 13.);\n    if (tm < 12.) {\n      dir *= -1. + 2. * step (6., tm);\n      tm = mod (tm, 6.);\n      td[1] = vec2 (0.5, 0.5 * sqrt3 * dir);\n      td[2] = vec2 (-0.5, 0.5 * sqrt3 * dir);\n      td[3] = - td[0];\n      td[4] = - td[1];\n      td[5] = - td[2];\n      for (int k = 0; k < 6; k ++) tp[k + 1] = tp[k] + td[k];\n      if (tm < 1.)      p.xz = tp[0] + td[0] * tm;\n      else if (tm < 2.) p.xz = tp[1] + td[1] * (tm - 1.); \n      else if (tm < 3.) p.xz = tp[2] + td[2] * (tm - 2.); \n      else if (tm < 4.) p.xz = tp[3] + td[3] * (tm - 3.); \n      else if (tm < 5.) p.xz = tp[4] + td[4] * (tm - 4.); \n      else if (tm < 6.) p.xz = tp[5] + td[5] * (tm - 5.); \n    } else {\n      p.xz = tp[0] + td[0] * (tm - 12.);\n    }\n  } else {\n    p.xz = tp[0] + td[0];\n    p.y += 2. * (tm - 26.);\n  }\n  p.xz *= 4. * szGr.x;\n  p.y *= szGr.y;\n  return p;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, fpF, fpB, vd;\n  vec2 uv, ori, ca, sa;\n  float el, az, spd;\n  uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  bwImg = false;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    if (mPtr.x > 0.4 && mPtr.y < -0.4) bwImg = true;\n    else {\n      az = az + 2. * pi * mPtr.x;\n      el = el + 0.95 * pi * mPtr.y;\n    }\n  }\n  szGr = vec2 (10., 3.3);\n  spd = 0.12;\n  lbPos = 0.5 * (TrackPath (spd * tCur + 0.4) + TrackPath (spd * tCur + 0.6));\n  fpF = TrackPath (spd * tCur + 0.1);\n  fpB = TrackPath (spd * tCur - 0.1);\n  ro = 0.5 * (fpF + fpB);\n  vd = fpF - fpB;\n  ori = vec2 (el, az + ((length (vd.xz) > 0.) ? atan (vd.x, vd.z) : 0.5 * pi));\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 1.6));\n  dstFar = 300.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 2.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nvec2 HexCellId (vec2 p)\n{\n  vec3 c, r, dr;\n  p.y *= (1./sqrt3);\n  c.xz = vec2 (0.5 * (p.x - p.y), p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (2., step (dr.yzx, dr) + step (dr.zxy, dr)) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec3 RgbToHsv (vec3 c)\n{\n  vec4 p, q;\n  float d;\n  const float e = 1.e-10;\n  p = mix (vec4 (c.bg, vec2 (-1., 2./3.)), vec4 (c.gb, vec2 (0., -1./3.)),\n     step (c.b, c.g));\n  q = mix (vec4 (p.xyw, c.r), vec4 (c.r, p.yzx), step (p.x, c.r));\n  d = q.x - min (q.w, q.y);\n  return vec3 (abs (q.z + (q.w - q.y) / (6. * d + e)), d / (q.x + e), q.x);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return step (abs (q.x), 0.12) * step (abs (q.y), 0.6);\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.5, 2.2);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.)) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (sgn < 0.) {\n      if (idChar == mxChar - nDig - 1.) s = ShowDig (q, -1);\n      else ++ v;\n    }\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s2czR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 829, 851, 851, 2611], [2613, 2613, 2646, 2646, 2822], [2824, 2824, 2845, 2845, 3052], [3054, 3054, 3085, 3085, 3302], [3304, 3304, 3352, 3352, 3548], [3550, 3550, 3585, 3585, 8108], [8110, 8110, 8136, 8136, 9281], [9283, 9283, 9336, 9336, 10446], [10448, 10448, 10481, 10481, 10508], [10510, 10510, 10552, 10552, 10603], [10605, 10605, 10658, 10658, 10719], [10721, 10721, 10767, 10767, 10824], [10826, 10826, 10851, 10851, 11088], [11090, 11090, 11147, 11147, 11230], [11232, 11232, 11262, 11262, 11320], [11443, 11443, 11467, 11467, 11514], [11516, 11516, 11541, 11541, 11740], [11742, 11742, 11763, 11763, 11918], [11920, 11920, 11944, 11944, 12080], [12082, 12082, 12106, 12106, 12427], [12429, 12429, 12452, 12452, 12511], [12584, 12584, 12616, 12616, 13158], [13160, 13160, 13220, 13220, 13795]]}
{"id": "4sfcDs", "name": "ChocWarp", "author": "JavasCrypt20", "description": "Made this in a still hour and it reminds me to the background animations of the playstation3 os", "tags": ["waves", "wave", "uv", "animation", "background", "dots", "uvs", "dot", "ps3", "os", "manipulation"], "likes": 3, "viewed": 589, "published": "Public API", "date": "1490258233", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//  //  SOME PROCEDURAL PATTERN- GENERATORS  //  //\nfloat PatChecker(vec2 uvs,  float countX, float countY ){\n    return mod( floor( countX * uvs.x) + floor( countY * uvs.y), 2.0);\n}\nfloat PatGradSaw( float uvAxis, float count){\n\treturn fract( count * uvAxis);\n}\nfloat PatGradSawMirr( float uvAxis, float count){\n\treturn abs( fract( count * uvAxis)* 2.0 - 1.0);\n}\nfloat PatSinWave( float uvX, float uvY, float count ){\n\treturn smoothstep(0.0, 0.06, 0.2 - 0.1 * sin( count * uvX) - uvY);\n}\nfloat PatDots( vec2 uvs, float count, float size){\n\treturn smoothstep( size , size + 0.425, length( fract( count * uvs) - 0.5));\n}\nfloat PatBricks( vec2 uvs, float size, float gap, float smoothness){\n\treturn smoothstep(0.54-gap-smoothness,0.54-gap,\n           max(abs(fract(size*uvs.x-0.5*mod(floor(size*uvs.y),2.0))-0.5),\n           abs(fract(size*uvs.y)-0.5)));\n}\nfloat panX( float uvx, float speed){\n    return uvx + iTime * speed;\n}\nfloat panY( float uvy, float speed){\n    return uvy + iTime * speed;\n}\n\n//  // MAIN SHADER  //  //\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x = uv.x * ( iResolution.x / iResolution.y);\n    float bricks = PatBricks( vec2( uv.x + iTime / 10.0, uv.y - iTime / 10.0), 2.0, 0.001, 1.0);\n    float bricks2 = PatBricks( vec2( -uv.x + iTime / 24.0, -uv.y + iTime / 36.0), 32.0, 0.1, 0.95);\n    bricks = bricks * 1.5 * bricks2 - bricks2;\n    bricks = clamp( pow( bricks, 1.5),0.0,1.0);\n    bricks /= 60.0;\n    float waves = 1.0 - PatDots( vec2( uv.x+bricks, panY( uv.y+bricks, 0.1)), 1.68, 0.35);\n    float waves2 = ( 1.0 - PatSinWave( panX( -uv.x , 0.18), abs ( uv.y / 1.3  - 0.31 - waves / 12.0) , 3.2 ));\n    float waves3 = PatGradSawMirr( panX( uv.x - pow((waves2 - waves)/ 4.0, 0.2) , 0.25 ), 0.5);\n    float result = abs ( ( waves * waves2) / waves2 * waves3 * (waves2 + waves3)) / 4.0;\n\tfloat red = pow( result, 1.8 + 0.6 * cos (iTime)- waves );\n    float green = result * 1.8 + 0.6 * sin (iTime)* waves2 * result;\n    float blue = pow( result, 0.6 + sin (iTime)* result* -waves2 );\n    fragColor = vec4( red, green, blue, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sfcDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 52, 109, 109, 182], [183, 183, 228, 228, 262], [263, 263, 312, 312, 363], [364, 364, 418, 418, 488], [489, 489, 539, 539, 619], [620, 620, 688, 688, 854], [855, 855, 891, 891, 925], [926, 926, 962, 962, 996], [998, 1025, 1081, 1081, 2119]]}
{"id": "4sfcWH", "name": "Vorotoris", "author": "balkhan", "description": "raymarched tori with voronoi displacement map", "tags": ["raymarching", "voronoi", "torus"], "likes": 17, "viewed": 388, "published": "Public", "date": "1488323338", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define I_MAX\t250\n#define E\t\t0.001\n\n/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\n/*\n* comment/uncomment these defines\n*/\n#define\tROT\n#define\tAO\n//#define ED // somewhat different rendering\n//#define BYE_BYE_FPS // transparency\n//#define SIMPLEX // simplex3d\n#define NOISE_OFFSET // to blur the voronoi\n\n\n\nfloat\tde(vec3 pos);\nfloat\tde(vec3 pos, vec4 rad);\nfloat\tsdTorus( vec3 p, vec2 t );\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nfloat\tsmin(float a, float b, float k);\nvec2\trot(vec2 p, vec2 ang);\nvec2\tuv;\nfloat\tt;\t\t\t\t//time\nfloat\tst; \t\t\t//sin(time)\nfloat\tct; \t\t\t//cos(time)\nfloat\tvor;\t\t\t//voronoi\nvec3\tnoise_texture;\t//blurr\n\n// a switch used when transparency is active to optimize a bit\nfloat\ttilt;\n\n//3D simplex noise from nikat : https://www.shadertoy.com/view/XsX3zB\n\n// -------------the simplex--------------- //\n\nconst float F3 =  0.3333333; // magic numbers : 1/3\nconst float G3 =  0.1666667; //\t\t\t\t\t1/6\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-.5;\n}\n\nfloat simplex3d(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t vec4 w, d;\n\t \n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t w = max(0.6 - w, 0.0);\n\t \n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t return dot(d, vec4(52.0));\n}\n\n// -------------the simplex--------------- //\n\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// -------------blackbody----------------- //\n\nvoid mainImage(out vec4 o, in vec2 f )\n{\n    tilt = 0.;\n    t = iTime /4.;\n    st = sin(t);\n    ct = cos(t);\n    vor = 0.;\n\n    vec2 R = iResolution.xy;\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec4\tcol = vec4(0.0);\n    vec3\tpos = vec3(.0, .0, 11.0);\n\n    vec4\tinter = (march(pos, dir));\n\n    /*\n\t* lighting originally taken from gltracy : https://www.shadertoy.com/view/XsB3Rm\n\t*/    \n    if (inter.w <= 20.) // else ray didn't hit anything\n\t{\n\t\tvec3\tv = pos+inter.w*dir;\n        #ifdef\tBYE_BYE_FPS\n        vec3\tn = vec3(0.);\n        if (tilt > 0.) // only calculate normal when we need it\n            n = calcNormal(v, E, dir);\n        #else\n        vec3\tn = calcNormal(v, E, dir);\n        #endif\n        vec3\tev = normalize(v - pos);\n\t\tvec3\tref_ev = reflect(ev, n);\n        vec3\tlight_pos   = vec3(10.0, 10.0, 50.0);\n\t\tvec3\tlight_color = vec3(.1, .4, .7)*(1.-blackbody(vor*1500.) );\n        vec3\tvl = normalize(light_pos - v);\n\t\tfloat\tdiffuse  = max(0.0, dot(vl, n));\n\t\tfloat\tspecular = pow(max(0.0, dot(vl, ref_ev)), 4.);\n        col.xyz = light_color * (specular)+ diffuse * vec3(.6, .2, .2)*(1.-blackbody(vor*1500.) );\n    }\n    #ifdef AO\n    // basic AO\n    col.xyz += (vec3(inter.x /40.))*mix(vec3(.1, .4, .7), vec3(.6, .2, .2), st );\n    #endif\n    #ifdef ED\n    col = col/2. + col*(50.*(dFdx(col)*dFdy(col)) )/2.;\n    #endif\n   \to = col;\n}\n\nvec3 hash( vec3 p )\n{\n\tp = vec3(\tdot(p,vec3(127.1,311.7, 520.6 )),\n\t\tdot(p,vec3(269.5,183.3, 150.9 )),\n\t\tdot(p, vec3(285.1, 422.4, 211.8 ) ) );\n\treturn fract( (p)*18.5453); // sin(p)\n}\n\n// I took a 2d voronoi from iq, then tweaked it a bit, original : https://www.shadertoy.com/view/MslGD8\n\nfloat\tvoronoi3d( in vec3 x)\n{\n    #ifdef\tSIMPLEX\n    x += .5*vec3(simplex3d(x/1.5+t) );\n    #endif\n\tvec3 n = floor( x * 2.);\n\tvec3 f = fract( x * 2.);\n   \n\tvec3 m = vec3( 8., 8., 8. );\n\tfor (float k=-1.; k<=1.; k++)\n    {\n\t\tfor( float j=-1.; j<=1.; j++ )\n        {\n\t\t\tfor( float i=-1.; i<=1.; i++ )\n\t\t\t{\n\t\t\t\tvec3  \tg = vec3( (i), (j), (k) );\n\t\t\t\tvec3  \to = hash( n + g );\n\t\t\t\tvec3 \tr = g - f + (.5+.5*sin( t*4. +6.2831*o));\n\t\t\t\tfloat\td = dot( r, r );\n\t\t\t\tif( d < m.x )\n\t\t\t\t\tm = vec3( d,o.xy);\n\t\t\t}\n        }\n    }\n\treturn float( ( (m.x) ) );\n}\n\nfloat\tscene(vec3 p)\n{\n    float\tmind = 1e5;\n\tfloat\tming = 1e5;\n \tfloat\tminh = 1e5;\n\n    mind = (sdTorus(p, vec2(7.5, .5)+ct*2.*exp(-t*4.+.75) ) - 1.25 )-(vor )/7.;\n\tming = (sdTorus(p+vec3(0.,0., 0.+ct), vec2(4.5, .5)-ct*1.*exp(-t+2.) ) - 1. )+(vor )/7.;\n    minh = (sdTorus(p, vec2(3., 0.)-ct*2.*exp(-t+.5) ) - 2. )-(vor )/20.;\n\n    mind = min(mind, minh);\n    mind = max(mind, -ming);\n\n    #ifdef BYE_BYE_FPS\n    if (vor > -.0)\n    {\n\t    mind = minh;\n        tilt++;\n    }\n    #endif\n    return(mind);\n}\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0);\n    vec3\tp = vec3(0.0);\n    vec4\ts = vec4(0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        \n        #ifdef ROT\n\t\tp.xz *= mat2(ct,st,-st, ct);\n\t\t#endif\n        \n        dist.x = scene(p);\n        dist.y += dist.x;\n        if (dist.x < E || dist.y > 20. || tilt > 0.)\n        {\n            if (dist.y > 20.)\n                break;\n            dist.y -= dist.x;\n            for (int i = -1; i < 15; ++i)\n            {\n                p = pos + dir * dist.y;\n                #ifdef ROT\n\t\t\t    p.xz *= mat2(ct,st,-st, ct);\n\t\t\t    #endif\n\n                #ifdef NOISE_OFFSET\n                noise_texture = vec3(texture(iChannel0, (uv.xy) ).xy*.057, 0. );\n                #endif\n\n                vor = voronoi3d(p + noise_texture * .75 );\n\n                dist.x = scene(p);\n\t            dist.y += dist.x;\n                if (dist.x < E*2. || dist.y > 20.)\n                {\n                \tbreak;\n                }\n            }\n            break;\n        }\n        s.x++;\n    }\n    s.w = dist.y;\n    return (s);\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length(p.xy)-t.x,p.z);\n\n    return length(q)-t.y;\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float   fov = 1.;\n\tvec3    forw  = vec3(0.0, 0.0, -1.0);\n\tvec3    right = vec3(1.0, 0.0, 0.0);\n\tvec3    up    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sfcWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[959, 1023, 1045, 1045, 1241], [1243, 1243, 1268, 1268, 1868], [2030, 2252, 2280, 2280, 2605], [2607, 2654, 2694, 2694, 4026], [4028, 4028, 4049, 4049, 4212], [4214, 4319, 4348, 4348, 4862], [4864, 4864, 4885, 4885, 5369], [5371, 5371, 5403, 5403, 6479], [6481, 6555, 6588, 6588, 6655], [6657, 6657, 6685, 6685, 6793], [6795, 6795, 6845, 6845, 7108], [7110, 7110, 7132, 7132, 7339]]}
{"id": "4sfyRB", "name": "RayMarch Template", "author": "rhino1181", "description": "Basic raymarcher", "tags": ["raymarched"], "likes": 4, "viewed": 152, "published": "Public", "date": "1488585337", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdSphere(vec3 pos, float radius)\n{\n    //return sqrt(pos.x*pos.x + pos.y*pos.y + pos.z*pos.z)-radius;\n    return length(pos) - radius;\n}\n\n\nfloat distFunc(vec3 pos)\n{\n    vec3 spherePos = vec3(0.0, 0.0, 5.0);\n    vec3 spherePos2 = spherePos + vec3(3.0 * sin(iTime), 3.0 * cos(iTime), 0.0);\n    vec3 delta = spherePos - pos;\n    vec3 delta2 = spherePos2 - pos;\n    float s1 = sdSphere(delta, 1.0);\n    float s2 = sdSphere(delta2, 0.5);\n    return min(s1, s2);\n}\n\nvec2 rotateAroundPoint(vec2 p, vec2 o, float offset, float speed)\n{\n    vec2 newPos;\n    newPos.x = sin((iTime * speed) + offset) * (p.x - o.x) - cos((iTime * speed) + offset) * (p.y - o.y) + o.x;\n    newPos.y = cos((iTime * speed) + offset) * (p.x - o.x) + sin((iTime * speed) + offset) * (p.y - o.y) + o.y;\n    return newPos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camPos = vec3(0.0, 0.0, 10.0);\n    //camPos.xz = rotateAroundPoint(camPos.xz, vec2(0.0), 0.0, 1.0);\n    //camPos.xz = vec2(2.0 * sin(iTime), 2.0 * cos(iTime));\n    \n    vec3 camTarget = vec3(0.0);\n    vec3 worldUp = vec3(0.0, 1.0, 0.0);\n    \n    vec3 camDir = normalize(camTarget - camPos);\n    \n    vec3 camRight = normalize(cross(worldUp, camPos));\n    vec3 camUp = cross(camDir, camRight); \n    \n    vec3 lightPos = vec3(3.0 * sin(iTime), 0.0, 10.0);\n    \n    vec2 screenPos = -1.0 + (2.0 * fragCoord.xy / iResolution.xy);\n    screenPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 rayDir = normalize(camRight * screenPos.x + camUp * screenPos.y + camDir);\n    \n    const int MAX_ITER = 100;\n    const float MAX_DIST = 20.0;\n    const float EPSILON = 0.001;\n    \n    float totalDist = 0.0;\n    vec3 pos = camPos;\n    float dist = EPSILON;\n    \n    for(int i = 0; i < MAX_ITER; i++)\n    {\n        if(dist < EPSILON || totalDist > MAX_DIST)\n            break;\n        \n        dist = distFunc(pos);\n        totalDist += dist;\n        pos += rayDir * dist;\n    }\n    \n    if(dist < EPSILON)\n    {\n     \tvec2 eps = vec2(0.0, EPSILON);\n        vec3 normal = normalize(vec3(\n            distFunc(pos + eps.yxx) - distFunc(pos - eps.yxx),\n            distFunc(pos + eps.xyx) - distFunc(pos - eps.xyx),\n            distFunc(pos + eps.xxy) - distFunc(pos - eps.xxy)));\n        \n        float diffuse = dot(normalize(lightPos-pos), normal);\n        float spec = pow(diffuse, 50.0);\n        vec3 ambient = vec3(0.05, 0.05, 0.05);\n        vec3 diffuseColor = vec3(0.42, 0.25, 1.0) * diffuse;\n        vec3 color = vec3(diffuseColor + spec + ambient);\n        fragColor = vec4(color, 1.0);\n    }\n    else\n    {\n        fragColor = vec4(0.0);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sfyRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 107, 142], [145, 145, 171, 171, 465], [467, 467, 534, 534, 796], [798, 798, 855, 855, 2613]]}
{"id": "4sjyRz", "name": "2dsdf", "author": "psykotic", "description": "fooling around. poly is \"kaleidoscopic max norm\", not euclidean, so using it for aa will blur the vertices for very acute angles, but it makes it easy to do miter joints for outlining. could fix with voronoi regions as in roundrect.", "tags": ["2d"], "likes": 11, "viewed": 642, "published": "Public", "date": "1490644102", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dunion(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat dintersect(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat halfplane(vec2 p, vec2 n, float d) {\n    return dot(n, p) + d;\n}\n\nfloat disk(vec2 p, vec2 c, float r) {\n    return distance(c, p) - r;\n}\n\nfloat poly(vec2 p, float n, vec2 c, float r) {\n    float pi = 3.1415926;\n    p -= c;\n    float b = 2.0*pi / n;\n    float a = atan(p.y, p.x);\n    a = mod(a + 0.5*b, b) - 0.5*b;\n    return length(p)*cos(a) - r;\n}\n\nfloat roundrect(vec2 p, vec2 c, vec2 r) {\n    p = abs(p - c) - r;\n\tif (p.x >= 0.0 && p.y >= 0.0)\n        return length(p);\n    else\n        return max(p.x, p.y);\n}\n\nvec2 rotate(vec2 v, vec2 c, float a) {\n    v -= c;\n    vec2 w = vec2(cos(a), sin(a));\n    return c + vec2(w.x * v.x - w.y * v.y, w.y * v.x + w.x * v.y);\n}\n\nfloat ramp(float x) {\n    return x;\n}\n\nvec4 over(vec4 c1, vec4 c2) {\n    return c1 + (1.0 - c1.a) * c2;\n}\n\nfloat scene(vec2 p) {\n    float t = 0.5 * sin(iTime) + 0.5;\n    float t2 = 0.5 * sin(2.0 * iTime) + 0.5;\n    float boxdist = roundrect(p, vec2(1.45, 0.35 + 0.3 * t2), vec2(0.15 + 0.08 * t2, 0.15));\n    p = rotate(p, vec2(0.5, 0.5), iTime);\n    float sides = 3.0 + 3.0 * t;\n    float radius = 0.1 + 0.15 * t2;\n    float dist = dunion(boxdist,\n      \t\t\t\t\tdunion(poly(p, sides, vec2(0.3, 0.5), 0.2),\n                        disk(p, vec2(0.9, 0.5), radius)));\n    return dist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float pixwidth = length(1.0 / iResolution.xy);\n\tvec2 pos = fragCoord.xy / iResolution.y;\n    \n    float aawidth = 1.0; // 0.0 to turn off aa or > 1.0 to see sdf falloff.\n    float aa = aawidth * pixwidth;\n\n    float dist = scene(pos);\n    float dist2 = scene(pos + vec2(-0.02, 0.02));\n\n    vec4 interior = vec4(0.9, 0.2, 0.2, 0.0);\n    \n    if (dist <= 0.0)\n        interior.a = 1.0;\n    else if (dist < aa)\n        interior.a = ramp(1.0 - dist / aa);\n\n    interior.rgb *= interior.a;\n    \n\tvec4 outline = vec4(0.15, 0.15, 0.15, 0.0);\n    float outline_radius = pixwidth * 10.0;\n    if (dist >= -aa) {\n        if (dist < 0.0)\n            outline.a = ramp(1.0 - (-dist / aa));\n        else if (dist <= outline_radius)\n        \toutline.a = 1.0;\n\t\telse if (dist < outline_radius + aa)\n            outline.a = ramp(1.0 - (dist - outline_radius) / aa);\n    }\n        \n    outline.rgb *= outline.a;\n\n    vec4 shadow = vec4(0.1, 0.1, 0.1, 0.0);\n    if (dist2 <= outline_radius)\n        shadow.a = 1.0;\n     else if (dist2 < outline_radius + aa)\n        shadow.a = ramp(1.0 - (dist2 - outline_radius) / aa);\n\n    shadow.a *= 0.2;\n    shadow.rgb *= shadow.a;\n    \n    vec4 background = vec4(0.6, 0.6, 0.8, 1.0);\n\n    fragColor = over(outline, over(interior, over(shadow, background)));\n}\n\t", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sjyRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 60], [62, 62, 100, 100, 126], [128, 128, 170, 170, 198], [200, 200, 237, 237, 270], [272, 272, 318, 318, 482], [484, 484, 525, 525, 647], [649, 649, 687, 687, 803], [805, 805, 826, 826, 842], [844, 844, 873, 873, 910], [912, 912, 933, 933, 1386], [1388, 1388, 1443, 1443, 2726]]}
{"id": "4slcDB", "name": "Land of Green Gold", "author": "TimoKinnunen", "description": "Combines a fir tree shader with a voronoi shader to take you on a helicopter ride with the forestry service over an endless lush northern type forest. Future work: add some hills, lakes, maybe roads.", "tags": ["voronoi", "tree", "forest", "fir"], "likes": 19, "viewed": 1091, "published": "Public API", "date": "1489702294", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////////\n// Land of Green Gold by Timo Kinnunen 2017\n//\n// Based on Fur Trees by eiffie\n// @ https://www.shadertoy.com/view/lts3zr\n//\n// Based on Faster Voronoi Edge Distance by tomkh\n// @ https://www.shadertoy.com/view/llG3zy\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define NO_DEBUG\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// by Tomasz Dobrowolski' 2016\n\n// Based on https://www.shadertoy.com/view/ldl3W8 by Inigo Quilez\n// And his article: http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n\n// This is based on Inigo Quilez's distance to egdes,\n// except I consider here faster variants:\n// * 3x3 scan at the cost of small inaccuracies\n// * 4x4 scan in the second pass that has no accuracy-loss to IQ's version\n// * 4x4 in both passes that is more accurate than original IQ's version\n//   (and still has less iterations 32=4*4*2 vs 34=3*3+5*5)\n\n// Original IQ's algorithm is flawed (mathematically incorrect)\n// i.e. for all possible hash functions, as in this counter-example:\n// https://www.shadertoy.com/view/4lKGRG\n\n// Basically in the original IQ's implementation,\n// he was storing closest cell \"mg\" in the first pass\n// and using it for the second pass.\n// If we want 3x3 scan in the second pass it is enough to continue search\n// from the same (current fragment) cell and limit search space\n// to only neighbouring cells (thus \"mg\" can be ignored).\n// In fact, searching around \"mg\" makes it worse (see my illustration below).\n// For 4x4 variant we have to set the center of search \n// based on which half of the current fragment cell we are in.\n// Note: \n//   The second pass scan area has nothing to do with the position\n//   of the closest point.\n//   Here is an illustration of my improved algorithm:\n//   http://ricedit.com/second_order_voronoi_03.png\n\n// Pick approximation level:\n//   0 = 3x3 scan for both passes (occasional issues, but the fastest)\n//   1 = 3x3 + 4x4 scan (good in most cases, if every cell has diameter < 1)\n//   2 = 4x4 scan for both passes (improved accuracy)\n//   3 = 3x3 + 5x5 scan (original IQ's)\n#define SECOND_PASS 0\n\n//#define ANIMATE\n\n// How far cells can go off center during animation (must be <= .5)\n#define ANIMATE_D .5\n\n// Points cannot be closer than sqrt(EPSILON)\n#define EPSILON .00001\n\n// How freely are cell centers placed (must be <= 1.)\n#define PLACE_D .875\n\nvec2 hash2(vec2 p)\n{\n    #if 1\n       // Dave Hoskin's hash as in https://www.shadertoy.com/view/4djSRW\n       vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n       p3 += dot(p3, p3.yzx+19.19);\n       vec2 o = PLACE_D*(fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y))-.5)+.5;\n    #else\n       // Texture-based\n       vec2 o = texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n    #endif\n    #ifdef ANIMATE\n       o = 0.5 + ANIMATE_D*sin( iTime + o*6.2831853 );\n    #endif\n   return o;\n}\nstruct VoronoiData {\n    float md;\n    vec2 mr;\n    vec2 mi;\n};\n#if SECOND_PASS == 0\n//---------------------------------------------------------------\n// Fastest version with 3x3 scan in the second pass\n//---------------------------------------------------------------\nVoronoiData voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mr;\n    vec2 mi;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mi = n + g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders,\n    // visits only neighbouring cells\n    //----------------------------------\n    md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON ) {// skip the same cell\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n        }\n    }\n\n    return VoronoiData( md, mr, mi );\n}\n\n\n#elif SECOND_PASS == 1\n//---------------------------------------------------------------\n// Approximation with 4x4 scan in the second pass\n// Good enough in most cases\n//---------------------------------------------------------------\n\nVoronoiData voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mr;\n    vec2 mi;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mi = n + g;\n        }\n    }\n    \n    // Set center of search based on which half of the cell we are in,\n    // since 4x4 is not centered around \"n\".\n    vec2 mg = step(.5,f) - 1.;\n\n    //----------------------------------\n    // second pass: distance to borders,\n    // visits two neighbours to the right/down\n    //----------------------------------\n    md = 8.0;\n    for( int j=-1; j<=2; j++ )\n    for( int i=-1; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON ) // skip the same cell\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return VoronoiData( md, mr, mi );\n}\n\n#elif SECOND_PASS == 2\n//---------------------------------------------------------------\n// 4x4 scan in both passes = most accurate\n//---------------------------------------------------------------\n\nVoronoiData voronoi( in vec2 x )\n{\n#if 1\n    // slower, but better handles big numbers\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    vec2 h = step(.5,f) - 2.;\n    n += h; f -= h;\n#else\n    vec2 n = floor(x - 1.5);\n    vec2 f = x - n;\n#endif\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mr;\n    vec2 mi;\n\n    float md = 8.0;\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mi = n + g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON ) // skip the same cell\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return VoronoiData( md, mr, mi );\n}\n\n#else\n//---------------------------------------------------------------\n// Slowest with 5x5 scan in the second pass\n// Original Implementation by Inigo Quilez \n// as in https://www.shadertoy.com/view/ldl3W8\n//---------------------------------------------------------------\n\nVoronoiData voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n    vec2 mi;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n            mi = n + g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return VoronoiData( md, mr, mi );\n}\n\n//---------------------------------------------------------------\n#endif\n\nvec3 plot( vec2 p, float ss )\n{\n    VoronoiData c = voronoi( p );\n    \n    // Colors:\n    vec3 interior = vec3(.3,.2,.2);\n    vec3 border = vec3(.5,.6,0);\n    vec3 point = vec3(.025,.025,.0125);\n    \n    float d = length(c.mr);\n    vec3 col =\n        mix(\n            mix(\n                interior*(.63-1.1*c.md),\n                border*.2+.25*c.md,\n                smoothstep(.22,.04,c.md)\n            ),\n            point,\n            smoothstep(.427,.05,d)\n        );\n    \n    return col;\n}\n\nvoid mainImage00( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc = step(512., iResolution.y)*4. + 4.; // scale differently for fullscreen\n\tfloat ss = sc / iResolution.y; // size of 1 pixel\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5) * ss;\n    fragColor = vec4(plot(uv, ss), 1.);\n}\n\n\n\n\n//attempting some distance estimated fur and shading with one extra DE calc\n#define AUTO_OVERSTEP\n\n#define time iTime\n#define size iResolution\n\n#define TAO 6.283\nvec2 rotate(vec2 v, float angle) {return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\nvec2 kaleido(vec2 v, float power){return rotate(v,floor(.5+atan(v.x,-v.y)*power/TAO)*TAO/power);}\n\nvec2 kaleido6(vec2 v){return rotate(v,floor(0.5+atan(v.x,-v.y)*0.95493)*1.0472);}\nvec2 kaleido12(vec2 v){return rotate(v,floor(0.5+atan(v.x,-v.y)*1.90986)*0.5236);}\nfloat rndStart(vec2 co){return 0.1+0.9*fract(sin(dot(co,vec2(123.42,117.853)))*412.453);}\n\nvec3 mcol;//material color\nmat2 r45=mat2(0.7071,0.7071,-0.7071,0.7071);\nmat2 r30=mat2(0.866,0.5,-0.5,0.866);\nmat2 rtrn=mat2(0.9689,-0.2474,0.2474,0.9689);\n\nVoronoiData theVoro;\nfloat DE(in vec3 z0){\n    VoronoiData voro = voronoi( z0.xz );\n    theVoro = voro;\n    vec2 id = voro.mi;\n    z0.xz = voro.mr;\n\n\tfloat cyl=length(z0.xz);\n\tfloat d=100.0,dt=cyl+z0.y*0.025;\n    \n\tfor(int i=0;i<2;i++){\n\t\tvec3 z=z0;\n        z.xz=rotate(z.xz,id.x*2.+id.y*3.+float(i*2));\n\t\tz.y+=float(i)*(0.125+.0625*mod(id.x-id.y,2.0));\n\t\tfloat c=floor(z.y*4.0);\n\t\t//z.yz=rotate(z.yz,-z.z*0.79*(1.0+c*0.1));\n\t\tfloat bm=-z.y-2.0+cyl*0.01;\n\t\tz.y=mod(z.y,0.25)-0.05;\n\t\tif(i<=1)z.xz=z.xz*rtrn*float(i+i-1);\n\t\tz.xz=kaleido(z.xz,2.0-c);\n\t\tz.yz=rtrn*z.yz;\n\t\tbm=max(bm,-z.z+c*0.086);//0.065);\n\t\tdt=min(dt,max(max(abs(z.x),abs(z.y)),bm))-0.001-z.z*0.003;\n\t\tfloat c2=floor(z.z*16.0);\n\t\tz.z=mod(z.z,0.0625)-0.045;//0.049;\n\t\tz.xy=rotate(z.xy,c2*0.25);\n\t\tz.xy=kaleido12(z.xy);\n\t\tz.yz=z.yz*r30;\n\t\td=min(d,max(max(max(abs(z.x),abs(z.z)),-z.y-0.05+c*0.005),bm));\n\t}\n\tif(dt<d){\n\t\td=dt;\n\t\tmcol=vec3(0.5,0.1,0.0);\n\t}else{\n\t\tmcol=vec3(0.5,0.6,0.2);\n\t\t//mcol*=1.0+(-z0.y*0.5975)*abs(z0.x+z0.z)/cyl;\n\t}\n    mcol*=cyl + 0.5 + z0.y*0.5;//kind of what iq suggested\n\n\treturn max(0.0,max(d,max(z0.y,-z0.y-2.0)));\n}\n\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\nfloat fog(float t){return exp(-t*0.02);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat zoom=2.0;\n    float px=2.0/(size.y*zoom);//find the pixel size\n    float ipx = 1.0/px;\n\tfloat tim=time;\n\n    #ifndef NO_DEBUG\n    float mark0 = fragCoord.x-iResolution.x*.5;\n    float mark1 = abs(mark0)-iResolution.x*.1875;\n    float mark2 = mark1-iResolution.x*.0625;\n    float mark3 = mark1-iResolution.x*.1250;\n    float mark4 = mark1-iResolution.x*.1875;\n    float mark5 = mark1-iResolution.x*.2500;\n\ttim += mark0>0.?30.:0.;\n    #endif\n\n    tim *= 0.3;\n\t//position camera\n\tvec3 ro=vec3(0.5*sin(tim*0.43),18.*(sin(tim*.4)+.975),tim*20.);\n\tvec3 rd=normalize(vec3((2.0*fragCoord.xy-size.xy)/size.y,zoom));\n\trd=lookat(vec3(-1.15*4.+8.*0.75*sin(tim),1.-1.5*sin(tim*.02),tim*20.+2.0)-ro,vec3(0.0,1.0,0.0))*rd;\n\t//ro=eye;rd=normalize(dir);\n\tvec3 ld=normalize(vec3(-0.4,0.75,-0.4));//direction to light\n\tvec3 bcol=1.0-clamp(vec3(rd.y,rd.y+0.1*exp(-abs(rd.y*15.0)),0.5*exp(-abs(rd.y*5.0))),0.,1.);//backcolor\n\t//march\n    \n\tfragColor=vec4(0,0,0,1);\n    \n\tfloat tG=abs((-2.0-ro.y)/rd.y);\n    float d;\n    float pd=10.0;\n    float os=0.0;\n    float steps=0.0;\n\tvec2 g=ro.xz+rd.xz*tG;\n    float noise = rndStart(fragCoord.xy);\n    const float rndBands = 1.;\n\tfloat t=floor(rndBands*DE(ro)*noise+.5)/rndBands;\n\tfloat MIN_DIST=px*0.1;\n    vec3 pos;\n\tvec4 col=vec4(0.0);//color accumulator\n\tfor(int i=0;i<78;i++){\n        pos = ro+rd*t;\n\t\td=DE(pos);\n\t\tfloat d1=max(d,px*t*0.5);\n#ifdef AUTO_OVERSTEP\n\t\tif(d1>os){\t\t//we have NOT stepped over anything\n\t\t\tif(t>tG)break;\n\t\t\tos=0.28*d1*d1/pd;//calc overstep based on ratio of this step to last\n\t\t\tsteps=d1+os;\t//add in the overstep\n\t\t\tpd=d1;\t//save this step length for next calc\n\t\t}else{\n\t\t\tsteps=-os;d1=1.0;pd=10.0;os=0.0;//remove ALL of overstep\n\t\t}\n#else\n\t\t\tsteps=d1;\n#endif\n\t\tif(d1<px*t){\n\t\t\tvec3 scol=mix(mcol,bcol,clamp(min(t*0.05,1.0),0.,1.));\n\t\t\tfloat d2=DE(pos+ld*px*t);\n\t\t\tfloat shad=1.4-0.5*clamp((d2/d)+1.,0.,10.);\n\t\t\tscol=scol*shad+vec3(0.02,0.05, -0.125)*(shad+1.5);\n            vec2 q = mod(pos.xz,2.0)-vec2(1.0);\n            scol *= clamp(length(q) + 0.8 + pos.y*0.5,0.,1.);\n\t\t\tfloat alpha=(1.0-col.w)*clamp(1.0-d1/(px*t),0.,1.);\n            //alpha=1.;\n\t\t\tcol+=vec4(clamp(scol,0.0,1.0),1.0)*alpha;\n\t\t\tif(col.w>0.99)break;\n\t\t}\n\t\tt+=steps;\n\t}\n    \n\n    float treeMask = col.a;\n    float horizon = .5+.5*cos(radians(clamp(rd.y*12.*180.,-180.,180.)));\n    float attenFar = clamp(log(max(1.0,(1./30.)*mix(t,t-25.,horizon)))*2.5,0.,1.);//smoothstep(50.0,75.0,t);\n    float distantFog = (1.0-0.292*attenFar);\n    float onlyFog = fog(abs(t));\n    float fogNear=1.92-.325*col.w-col.w*onlyFog;\n    float farFog = 1.0-fogNear;\n    float treeMaskFar = 1.0-treeMask*clamp(fogNear*10.,0.,1.);\n    float horizonFog = pow(horizon*.99,16.)*treeMaskFar;\n    float groundCover = fogNear*(1.0-col.a)*distantFog;\n    vec4 groundCol = vec4(0,0,0,clamp(-64.0*rd.y,0.,1.));\n\t//color the ground \n\tif(groundCol.a>0.0){\n        vec3 gcol = plot(g,px);\n\t\tro+=rd*tG;\n\t\tfloat s=1.0,dst=0.1;\n\t\tt=DE(ro)*rndStart(fragCoord.xy);\n\t\tfor(int i=0;i<4;i++){\n\t\t\tfloat d=max(0.0,DE(ro+ld*t)*1.5)+0.05;\n\t\t\ts=min(s,3.0*d/t);\n\t\t\tt+=dst;\n            dst*=2.0;\n\t\t}\n\t\tgcol*=0.2+0.8*s;\n        //col.rgb+=clamp(gcol*fogNear*(1.0-col.a)*(1.0-0.292*attenFar),0.,1.);\n        //col.a+=(1.0-col.a)*clamp(fogNear*(1.0-col.a)*(1.0-0.292*attenFar),0.,1.);\n        groundCol.rgb+= clamp(gcol*groundCover,0.,1.);\n        groundCol.a+=(1.0-col.a)*clamp(groundCover,0.,1.);\n        //groundCol.rgb = clamp(gcol*fogNear*(1.0-col.a)*(1.0-0.292*attenFar),0.,1.);\n    }\n    float groundMask = (1.-col.a);\n    col+=groundCol*groundMask;\n    float skyMask = (1.-col.a);\n    //col.a+=(1.0-col.a)*clamp(fogNear*(1.0-col.a)*(1.0-0.292*attenFar),0.,1.);\n    col.rgb += clamp(bcol*skyMask,0.,1.);\n    //col.rgb = mix(col.rgb,bcol,attenFar);\n    //col.rgb = mix(col.rgb,bcol,attenFar*(1.0-col.a));\n    col.rgb = mix(col.rgb,bcol,horizonFog);\n    col.rgb += bcol*horizon*.5;\n    //col.rgb = mix(col.rgb,bcol,attenFar*(1.0-col.a)*(1.0-horizonFog)+horizonFog);\n    float noSkyMask = clamp(1.-onlyFog,0.,1.);\n    float groundedFog = clamp((fogNear-.8)*(treeMask+horizon*.5)*1.75,0.,1.)*.25;\n    col.rgb += bcol*(groundedFog);\n    \n\tfragColor=vec4(col.rgb,1.0);\n    #ifndef NO_DEBUG\n  \tfragColor.rgb=mark1>0.?vec3(0,0,1)*vec3(groundCover,groundMask,treeMaskFar):fragColor.rgb;\n  \tfragColor.rgb=mark2>0.?vec3(1,1,1)*vec3(attenFar,distantFog,farFog):fragColor.rgb;\n  \tfragColor.rgb=mark3>0.?vec3(0,1,0)*vec3(onlyFog,fogNear,treeMask):fragColor.rgb;\n  \tfragColor.rgb=mark4>0.?vec3(1,1,1)*vec3(horizon,horizonFog,skyMask):fragColor.rgb;\n  \tfragColor.rgb=mark5>0.?vec3(0,1,0)*vec3(noSkyMask,groundedFog,skyMask):fragColor.rgb;\n    #endif\n\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4slcDB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[2405, 2481, 2501, 2501, 2977], [8498, 8498, 8529, 8529, 8991], [8993, 8993, 9052, 9052, 9286], [9291, 9453, 9487, 9487, 9534], [9535, 9535, 9569, 9569, 9632], [9634, 9634, 9656, 9656, 9715], [9716, 9716, 9739, 9739, 9798], [9799, 9799, 9823, 9823, 9888], [9900, 10067, 10088, 10088, 11150], [11152, 11152, 11181, 11181, 11266], [11267, 11267, 11286, 11286, 11307], [11309, 11309, 11365, 11365, 15985]]}
{"id": "4slcRS", "name": "Trip in Tron", "author": "ocb", "description": "Basic primitives for direct ray-interception -faster than ray marching- and reflection (sphere, cone, cylinder, box)\nanimated maze using Truchet pattern algo (from book of shader)\n\nUSE MOUSE TO CHANGE THE MAX CAMERA TRAVEL.\n", "tags": ["3d", "raytracing", "primitives", "cone", "cylinder"], "likes": 26, "viewed": 1031, "published": "Public API", "date": "1488723455", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: ocb\n// Title: Trip in Tron\n// Checking basic primitives (sphere, cone, cylinder, 3D rect) in Ray Intercepting (direct calculation of ray impact on object)\n// The 2 solutions of shpere/ray interception is calculated to allow the inside view of sphere (use for the shock wave)\n// pulses are calculated in 3D using max distance inside the object (bottom of parabol).\n\n// Use mouse (clic and right/left) to change the max camera travel\n\n#define PI 3.141592653589793\n#define INFINI 1000000000.\n#define maxSph 3\n#define maxCone 2\n#define maxRec 2\n\n\n\nfloat random (in vec2 st,float time) { \t\t\t\t\t\t\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123+time);\n}\n\n\n// from TheBookOfShader\nvec2 truchetPattern(in vec2 st, in float i){\n    \n    if (i > 0.75) {\n        st = vec2(1.) - st;\n    } else if (i > 0.5) {\n        st = vec2(1.0-st.x,st.y);\n    } else if (i > 0.25) {\n        st = 1.0-vec2(1.0-st.x,st.y);\n    }\n    return st;\n}\n\n// tower skin\nfloat dataFlow(vec2 o, vec2 dim, vec2 pos){\n    float taux = 0.;\n    vec2 p = pos - o;\n \n \tfloat i = floor( abs(p.x)/dim.x * 20.);\n    float f = fract( abs(p.x)/dim.x * 20.);\n    \n    taux =  step(.8*(sin(iTime*.1)+1.)/2.+.1, random(vec2(i,p.y/2000000.),iTime*.1))*step(.8,random(vec2(p.y/1000000.),1.))  *step(.1,f)*(1.-step(.9,f));\n    taux += smoothstep(.9,1.,p.x/dim.x)+(1.-smoothstep(.0,.1,p.x/dim.x)) ;    \n        \n    return taux;\n}\n\n\nfloat groundImpact(in vec3 pos,in float gndSurface, in vec3 N_ray){\n    float t = INFINI;\n    t = (gndSurface-pos.y)/N_ray.y;\n    \n    if (t <= 0.){\n        t = INFINI;\n    }\n    return t;\n}\n\n\nvec2 sphereImpact(in vec3 pos, in vec3 sphO, in float sphR, in vec3 N_ray){\n    \n    float t = INFINI;\n    float t1, t2;\n    vec3 delta = pos - sphO;\n    float dmin = 0.;\n    \n    // Sphere interception\n    // pre-calculation\n    float dot_delta_N_ray = dot(delta, N_ray);\n    float c = dot(delta,delta) - sphR*sphR;\n    \n    float discr = dot_delta_N_ray*dot_delta_N_ray - c;\n    \n    if (discr >= 0.){\n       \tfloat sqrt_discr = sqrt(discr);\n        t1= (-dot_delta_N_ray + sqrt_discr);\n        t2= (-dot_delta_N_ray - sqrt_discr);\n        t = min(t1,t2) ;\n        if (t <= 0.001){\n            t = max(t1,t2);\n            if (t <= 0.001) t = INFINI;\n        } \n    }\n        \n    dmin = abs(c - dot_delta_N_ray*dot_delta_N_ray)/sphR;\n    \n    return vec2(t, dmin);\n}\n\nfloat rectImpact(in vec3 pos, in vec3 recO, in vec3 recD, in vec3 N_ray, inout vec3 norm){\n    \n    float t = INFINI;\n    float t1,t2,t3;\n    float d1,d2,d3;\n\n    \n    \tif(recO.z+recD.z-pos.z<0.){\n        \tt1 = (recO.z+recD.z-pos.z)/N_ray.z;\n        \td1 = 1.;\n    \t}\n    \telse if(recO.z-pos.z>0.000){\n    \t\tt1 = (recO.z-pos.z)/N_ray.z;\n    \t\td1 = -1.;\n\t\t}\n    \telse{t1=-1.;}\n    \n    \tif(recO.y+recD.y-pos.y<0.){\n        \tt2 = (recO.y+recD.y-pos.y)/N_ray.y;\n        \td2 = 1.;\n    \t}\n    \telse if(recO.y-pos.y>0.){\n        \tt2 = (recO.y-pos.y)/N_ray.y;\n        \td2 = -1.;\n    \t}\n    \telse{t2=-1.;}\n\n    \tif(recO.x+recD.x-pos.x<0.){\n        \tt3 = (recO.x+recD.x-pos.x)/N_ray.x;\n        \td3 = 1.;\n    \t}\n    \telse if(recO.x-pos.x>0.){\n        \tt3 = (recO.x-pos.x)/N_ray.x;\n        \td3 = -1.;\n    \t}\n    \telse{t3=-1.;}\n\n\n    \tvec3 pos1 = pos + N_ray*t1;\n    \tvec3 pos2 = pos + N_ray*t2;\n    \tvec3 pos3 = pos + N_ray*t3;\n    \n    \tif(t1>0.001 && all(bvec2 (step(recO.xy,pos1.xy)*(1.-step(recO.xy+recD.xy,pos1.xy))))){\n        \tt = t1;\n        \tnorm = vec3 (0.,0.,d1);\n    \t}\n\t\telse\n    \tif(t2>0.001 && all(bvec2 (step(recO.xz,pos2.xz)*(1.-step(recO.xz+recD.xz,pos2.xz))))){\n        \tt = t2;\n        \tnorm = vec3 (0.,d2,0.);\n    \t}\n    \telse\n    \tif(t3>0.001 && all(bvec2 (step(recO.yz,pos3.yz)*(1.-step(recO.yz+recD.yz,pos3.yz))))){\n        \tt = t3;\n        \tnorm = vec3 (d3,0.,0.);\n    \t}\n    \n    return t;\n}\n\nvec2 cylinderImpact(in vec2 pos, in vec2 cylO, in float cylR, in vec2 N_ray){\n    float t=INFINI, minDist=0.;\n    vec2 delta = pos - cylO;\n\n    // circle interception\n    // pre-calculation\n    float dot_N_ray_Sq = dot(N_ray,N_ray);\n    float dot_delta_N_ray = dot(delta, N_ray);\n    float c = dot(delta,delta) - cylR*cylR;\n    \n    float discr = dot_delta_N_ray*dot_delta_N_ray - dot_N_ray_Sq*c;\n    \n    if (discr >= 0.){\n        float sqrt_discr = sqrt(discr);\n        t= min((-dot_delta_N_ray + sqrt_discr)/(dot_N_ray_Sq),\n        \t\t(-dot_delta_N_ray - sqrt_discr)/(dot_N_ray_Sq));\n        if (t < 0.001) t=INFINI;\n    }\n    \n    minDist = abs(c-dot_delta_N_ray*dot_delta_N_ray/dot_N_ray_Sq)/cylR;\n    \n\treturn vec2(t,minDist);\n}\n    \nvec2 coneImpact(in vec3 pos, in vec3 coneO, in float coneH, in float coneR, in vec3 N_ray){\n    float t = INFINI, minDist=INFINI;\n    vec3 delta = pos - coneO;\n    \n    float Dy = coneH - delta.y;\n    float r2 = coneR*coneR/(coneH*coneH);\n\t\n    // circle interception\n    // pre-calculation\n    float dot_N_ray_Sq_XZ = dot(N_ray.xz,N_ray.xz);\n    float dot_delta_N_ray_XZ = dot(delta.xz, N_ray.xz);\n    float c = dot(delta.xz,delta.xz) - r2*Dy*Dy;\n    float calc = dot_delta_N_ray_XZ + r2*Dy*N_ray.y;\n    \n    float discr = calc*calc - (dot_N_ray_Sq_XZ - r2*N_ray.y*N_ray.y) * c;\n    \n    if (discr >= 0.){\n        float sqrt_discr = sqrt(discr);\n        float t1 = (-calc + sqrt_discr)/(dot_N_ray_Sq_XZ - r2*N_ray.y*N_ray.y);\n        float t2 = (-calc - sqrt_discr)/(dot_N_ray_Sq_XZ - r2*N_ray.y*N_ray.y);\n       \n        if (t1 <= 0.001) t1 = INFINI;\n        else if (-N_ray.y*t1 + Dy < 0.) t1 = INFINI;\n        else if (-N_ray.y*t1 + Dy > coneH) t1 = INFINI;\n        \n        if (t2 <= 0.001) t2 = INFINI;\n        else if (-N_ray.y*t2 + Dy < 0.) t2 = INFINI;\n        else if (-N_ray.y*t2 + Dy > coneH) t2 = INFINI;\n        \n        t = min(t1,t2);  \n        if (t < INFINI) minDist = abs(c-calc*calc/(dot_N_ray_Sq_XZ - r2*N_ray.y*N_ray.y))/(coneR/coneH);\n    }\n    \n\treturn vec2(t,minDist);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy-.5;\n    st.x *= iResolution.x/iResolution.y;\n\n    // object def\n    \n    //sphere\n    vec3 sphO[maxSph];\n    float sphR[maxSph];\n    \n    sphO[0] = vec3(40.*sin(iTime*.45),5.*sin(iTime*.2)+30.,60.*cos(iTime*.3));\n    sphR[0] = 5.;\n    sphO[1] = vec3(50.*sin(iTime*.4),8.*sin(iTime*.3)+35.,50.*cos(iTime*.35));\n    sphR[1] = 4.;\n    sphO[2] = vec3(60.*sin(iTime*.35),5.*sin(iTime*.2)+40.,30.*cos(iTime*.4));\n    sphR[2] = 3.;\n    \n    //cube\n    vec3 recO[maxRec];\n    vec3 recD[maxRec];\n    vec3 normRect[maxRec];\n    \n    recO[0] = vec3(-20,0.,-20.);\n    recD[0] = vec3(5.,4000.,5.);\n    recO[1] = vec3(20,0.,20.);\n    recD[1] = vec3(5.,4000.,5.);\n    \n    //cylinder\n    vec3 XcylO = vec3(0.,10.,0.);\n    float XcylR = 1.;\n    vec3 ZcylO = vec3(0.,10.,0.);\n    float ZcylR = 1.;\n    \n    // sphere for impact\n    vec3 sphXO = XcylO;\n    float sphXR = 1000.*fract(iTime*.1);\n    \n    //cone\n    \n    vec3 coneO[maxCone];\n    float coneH[maxCone];\n    float coneR[maxCone];\n    \n    coneO[0] = vec3(20.,0.,-20.);\n    coneH[0] = 40.;\n    coneR[0] = 6.;\n    coneO[1] = vec3(-20.,0.,20.);\n    coneH[1] = 40.;\n    coneR[1] = 6.;\n    \n    \n    // camera target is switching from shere1 and cylinders crossing\n    vec3 camTarget = sphO[0]*(1.+sin(iTime*.2))/2. + XcylO*(1.+sin(iTime*.2+PI))/2.;\n    //vec3 camTarget = recO[0]+vec3(0.,0.,0.);\n    //vec3 camTarget = coneO[0]+ vec3(0.,20.,0.);\n    \n    int hitObj = -1000;\t// -1000 is Sky, -1 is Ground\n    \n    // camera def\n    float focal = 1.;\n    //rau, alpha, theta cam position\n    float rau = (1.-iMouse.x/iResolution.x)*500.*(sin(iTime/11.)+1.) + 10.,\n          alpha = -iTime/5.,\n          theta = (sin(iTime/7.)/2.+0.5)*(PI/2.-.3)+0.05;\n    \n    //float cosT = cos(theta), sinT = sin(theta), cosA = cos(alpha), sinA = sin(alpha);\t// pre-calculate  \n\t\n    // cam pos\n    vec3 screenPos = rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha)) + camTarget;\t\n    vec3 pos = screenPos;\n    \n    // 2 rotations. working. more elegant solution below (iq)\n\t//vec3 N_ray = normalize(vec3(st.x*cosA - (-st.y*sinT - focal*cosT)*sinA,\t\t\t\t// ray rotation\n    //                             st.y*cosT - focal*sinT,\n    //                             st.x*sinA + (-st.y*sinT - focal*cosT)*cosA));\n    \n    //screen coordinates\n\tvec3 ww = normalize( camTarget - screenPos );\n    vec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\t// create view ray\n\tvec3 N_ray = normalize( st.x*uu + st.y*vv + focal*ww );\n    \n    \n    float ground = 0.;\n    vec3 N_normPos = vec3(0.);\n    \n\n    vec3 color = vec3(.0);\n    \n    vec2 infoCone[maxCone];\n        infoCone[0] = vec2 (INFINI);\n        infoCone[1] = vec2 (INFINI);\n    \n    for (int rayNbr = 0; rayNbr <4; rayNbr++){\t\t// Max 4 reflects\n    \n    \tfloat t = INFINI; \t// parametric distance\n    \tfloat temp = INFINI;\n        // result infos for sphere, cylinder X and Z\n        // info contain t and max distance reach inside the obj.\n        vec2 infoS = vec2(INFINI);\n        vec2 infoX = vec2 (INFINI), infoZ = vec2 (INFINI);\n        \n        float explDist = 0.;\n        hitObj = -1000;\n    \n        // explosion sphere\n        \n        infoS = sphereImpact(pos, sphXO, sphXR, N_ray);\n    \tif(infoS.x<INFINI){\n            t = infoS.x;\n            hitObj = 50;\n            explDist = infoS.y;\n        }\n        \n    \t// sphere obj impact\n    \tfor (int i = 0; i<maxSph; i++){\n    \t\tinfoS = sphereImpact(pos, sphO[i], sphR[i], N_ray);\n    \t\tif(infoS.x<t){\n            \tt = infoS.x;\n            \thitObj = i;\n        \t}\n    \t}\n    \n        //rect  obj impact\n        for (int i = 0; i<maxRec; i++){\n        \ttemp = rectImpact(pos,recO[i], recD[i],N_ray, normRect[i]);\n        \tif(temp<t){\n            \tt = temp;\n             \thitObj = 10+i;\n            }\n        }\n        \n        infoX = cylinderImpact(pos.yz, XcylO.yz, XcylR, N_ray.yz);\n        if(infoX.x<t){\n            t = infoX.x;\n            hitObj = 20;\n        }\n        \n        infoZ = cylinderImpact(pos.xy, ZcylO.xy, ZcylR, N_ray.xy);\n        if(infoZ.x<t){\n            t = infoZ.x;\n            hitObj = 21;\n        }\n        \n        for (int i = 0; i<maxCone; i++){ \n        \tinfoCone[i] = coneImpact(pos, coneO[i], coneH[i], coneR[i], N_ray);\n        \tif(infoCone[i].x<t){\n                t = infoCone[i].x;\n                hitObj = 30+i;\n            }\n        }\n        \n        \n    \t// ground impact\n    \ttemp = groundImpact(pos, ground, N_ray );\n    \tif (temp<t){\n        \tt = temp;\n        \thitObj = -1;\n    \t}\n     \t\n        \n        \n        if (hitObj >= 0){\t// if Object hit, do raytrace again\n            \n            pos += t*N_ray;\t// with new pos\n            \t\t\t\t// and new ray (calculated below after finding Normal vec\n            \n            if (hitObj == 0) N_normPos = normalize(pos - sphO[0]);\n  \t\t\telse if (hitObj == 1) N_normPos = normalize(pos - sphO[1]);\n          \telse if (hitObj == 2) N_normPos = normalize(pos - sphO[2]);\n            \n            else if (hitObj == 10){\n                N_normPos = normRect[0];\n                if (bool(normRect[0].x)) color.gb += .3*dataFlow( recO[0].zy, recD[0].zy, pos.zy);\n                else color.gb += .3*dataFlow( recO[0].xy, recD[0].xy, pos.xy);\n                if (N_ray.y <0.) color.b += min(.2,-N_ray.y);\n                color.b += .2*(1.-smoothstep(0.,10.,pos.y));\n            }\n            else if (hitObj == 11){\n                N_normPos = normRect[1];\n            \tif (bool(normRect[1].x)) color.gb += .3*dataFlow( recO[1].zy, recD[1].zy, pos.zy);\n                else color.gb += .3*dataFlow( recO[1].xy, recD[1].xy, pos.xy);\n                if (N_ray.y <0.) color.b += min(.2,-N_ray.y);\n                color.b += .2*(1.-smoothstep(0.,10.,pos.y));\n            }\n            else if (hitObj == 20){\n                N_normPos = normalize(vec3(0.,pos.y-XcylO.y,pos.z-XcylO.z));\n                color.r += max(.0,pow(infoX.y,2.)-smoothstep(.0, .8, fract(iTime*.1+pos.x*0.00025)));\n                //color.r += min(1.,.05/infoX.y);\n            }\n            else if (hitObj == 21){\n                N_normPos = normalize(vec3(pos.x-ZcylO.x,pos.y-ZcylO.y,0.));\n                color.gb += max(0.,infoZ.y-smoothstep(0., .4, fract(iTime*3.+pos.z*0.01)));\n                color.gb += min(1.,.1/infoZ.y);\n            } \n            \n            else if (hitObj == 30){\n                N_normPos = normalize(vec3(pos.x - coneO[0].x,\n                                           coneR[0]*coneR[0]/(coneH[0]*coneH[0])*(coneH[0] + coneO[0].y - pos.y),\n                                           pos.z-coneO[0].z));\n                if (infoCone[0].y != INFINI) color.b += .4*min(1.,30./pow(infoCone[0].y,2.));\n                color.b += .4*(1.-smoothstep(0.,10.,pos.y));\n                \n            }\n            else if (hitObj == 31){\n                N_normPos = normalize(vec3(pos.x - coneO[1].x,\n                                           coneR[1]*coneR[1]/(coneH[1]*coneH[1])*(coneH[1] + coneO[1].y - pos.y),\n                                           pos.z-coneO[1].z));\n\t\t\t\tif (infoCone[1].y != INFINI) color.b += .4*min(1.,30./pow(infoCone[1].y,2.));\n                color.b += .4*(1.-smoothstep(0.,10.,pos.y));\n            }\n            \n            else if (hitObj == 50){\n                color.r += .5*min(1.,10000./explDist/pos.y/pos.y)*min(.9, smoothstep(0.,1.,(1.-fract(iTime*.1))));\n            }\n            \n            if(hitObj != 50){\n            \tN_ray = reflect(N_ray,N_normPos);\t\t\t// and new ray\n        \t\t//color += vec3(.0,.05,.1);\n            }\n        }\n        \n        else if (hitObj == -1) {\n            pos += t*N_ray;\t\t// ground: stop ray trace\n            break;\n        }\n        else break;\t\t\t\t// Sky: stop raytrace\n    }\n    \n    if (hitObj >= 0){\t\t\t// if ray still bouncing between 2 spheres, ray must be finished\n    \tfloat t = groundImpact(pos, ground, N_ray );\t//consider no more objects\n    \tif (t == INFINI) hitObj = -1000;\t\t\t\t// ray finish in sky\n    \telse {\t\t\t\t\t\t\t\t\t\t\t// or on ground\n        \thitObj = -1;\n        \tpos += t*N_ray;\n    \t}\n    }\n    \n    if (hitObj == -1) {\t// ground hit\n        \n        vec2 ipos = floor(vec2(pos.x,pos.z)*.01);  // integer\n    \tvec2 fpos = fract(vec2(pos.x,pos.z)*.01);  // fraction\n\t\tvec2 tile = truchetPattern(fpos, random(ipos, iTime*.05));\t\t// generate Maze\n        vec2 tileXL = truchetPattern(fract(vec2(pos.x,pos.z)*.5), random( floor(vec2(pos.x,pos.z)*.5) , iTime*.1 ));\t\t// used for impact effect \n        \n        // Maze\t\t//min(1.,(-N_ray.y)*5.) = distance fog to limit aliasing\n        vec2 p = pos.xz+20.*iTime;\n    \tvec2 vapor = max(vec2(0.),1.+.3*sin(.03*p)+.2*sin(.1*p));\n        float v = vapor.x*vapor.y;\n        color.b += .3*v*min(1.,(-N_ray.y)*5.)*(smoothstep(tile.x-0.02*v,tile.x,tile.y) - smoothstep(tile.x,tile.x+0.02*v,tile.y));\n        color.b += v*min(1.,(-N_ray.y)*5.)*.005/(length(tile-fract(iTime+random(ipos,1.)))+.01);\t// Head on top of Truchet pattern\n        \n        color.b += .7*(1.-smoothstep(coneR[0],coneR[0]*3.,length(coneO[0].xz-pos.xz)))\n            \t\t\t*(smoothstep(tileXL.x-0.1,tileXL.x,tileXL.y)- smoothstep(tileXL.x,tileXL.x+0.1,tileXL.y));\n        color.b += .7*(1.-smoothstep(coneR[1],coneR[1]*3.,length(coneO[1].xz-pos.xz)))\n            \t\t\t*(smoothstep(tileXL.x-0.1,tileXL.x,tileXL.y)- smoothstep(tileXL.x,tileXL.x+0.1,tileXL.y));\n        \n        vec2 recC = recO[0].xz+recD[0].xz/2.;\n        color.b += .7*(1.-smoothstep(recD[0].x,recD[0].x*3.,abs(recC.x-pos.x)))*(1.-smoothstep(recD[0].z,recD[0].z*4.,abs(recC.y-pos.z)))\n            \t\t\t*(smoothstep(tileXL.x-0.1,tileXL.x,tileXL.y)- smoothstep(tileXL.x,tileXL.x+0.1,tileXL.y));\n        recC = recO[1].xz+recD[1].xz/2.;\n        color.b += .7*(1.-smoothstep(recD[1].x,recD[1].x*3.,abs(recC.x-pos.x)))*(1.-smoothstep(recD[1].z,recD[1].z*4.,abs(recC.y-pos.z)))\n            \t\t\t*(smoothstep(tileXL.x-0.1,tileXL.x,tileXL.y)- smoothstep(tileXL.x,tileXL.x+0.1,tileXL.y));\n        \n    \tcolor.r += .9* min(.9, smoothstep(.2,1.,(1.-fract(iTime*.1))*(.7*(smoothstep(tileXL.x-0.1,tileXL.x,tileXL.y)-\n              .7*smoothstep(tileXL.x,tileXL.x+0.1,tileXL.y))+.3*(1.-smoothstep(.0,.2,length(tileXL-fract(iTime*5.)))) )*(1.-smoothstep(0.,600000.*fract(iTime*.1), pos.x*pos.x+ pos.z*pos.z)) ));  //ground impact\n        \n        color.b += .2- min(.2,-N_ray.y);\n\t\n    }\n    if (hitObj == -1000) {\t\t// ray goes to the sky\n        color += vec3(max((N_ray.x+1.)/2.*(-4.*N_ray.y+1.)/2.,0.),.1*(1.-N_ray.y),.2*(1.-N_ray.y));\n        color += vec3(.0,.0,.1);\n    }\n    \n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4slcRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[376, 555, 593, 593, 677], [680, 704, 748, 748, 949], [951, 965, 1008, 1008, 1405], [1408, 1408, 1475, 1475, 1598], [1601, 1601, 1676, 1676, 2369], [2371, 2371, 2461, 2461, 3776], [3778, 3778, 3855, 3855, 4511], [4517, 4517, 4608, 4608, 5812], [5815, 5815, 5872, 5872, 16434]]}
{"id": "4slcW2", "name": "Babel's Library", "author": "dr2", "description": "Lots of books", "tags": ["raymarch", "architecture", "books"], "likes": 12, "viewed": 560, "published": "Public API", "date": "1489952945", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Babel's Library\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\n\nconst float pi = 3.14159;\n\nmat3 vuMat;\nvec3 ltDir;\nvec2 bsa1, bsa2, bsa3;\nfloat dstFar, tCur, spFlr, spShf, htShf, htFlr, rOut, wFlr, wWal;\nint idObj;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a, rBar;\n  dMin = dstFar;\n  rBar = rOut - 2. * wFlr + 0.05;\n  q = p;\n  a = atan (q.z, - q.x) / (2. * pi);\n  d = abs (length (q.xz) - rOut) - wWal;\n  q.y = mod (q.y - 5.5 + 0.5 * spFlr, spFlr) - 0.5 * spFlr;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (8. * a) + 0.5) / 8.);\n  q.z = abs (q.z);\n  d = max (d, - max ((length (q.zy) - 1.5),\n     - min (abs (q.y) - 0.03, dot (q.xz, bsa3))));\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  q = p;\n  q.y = mod (q.y + 0.5 * spFlr, spFlr) - 0.5 * spFlr;\n  d = PrCylAnDf (q.xzy, rOut - wFlr, wFlr, htFlr);\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (16. * a) + 0.5) / 16.);\n  q.x -= - rBar;\n  q.z = abs (q.z) - 0.25;\n  d = length (q.xz) - 0.15;\n  if (d < dMin) { dMin = d;  idObj = 3; }\n  q = p;\n  q.y = mod (q.y - 3. + 0.5 * spFlr, spFlr) - 0.5 * spFlr;\n  d = PrTorusDf (q.xzy, 0.08, rBar);\n  if (d < dMin) { dMin = d;  idObj = 4; }\n  q = p;\n  q.y = abs (abs (mod (q.y - 1.5 + 0.5 * spFlr, spFlr) - 0.5 * spFlr) - 0.6) - 0.3;\n  d = PrTorusDf (q.xzy, 0.04, rBar);\n  if (d < dMin) { dMin = d;  idObj = 4; }\n  q = p;\n  a = mod (a - 1./16. + 0.5, 1.) - 0.5;\n  q.xz = Rot2D (q.xz, 2. * pi * ((floor (8. * a) + 0.5) / 8. + 1. / 16.));\n  q.z = abs (q.z);\n  d = max (abs (length (q.xz) - rOut + wWal + 0.3 * wFlr) - 0.3 * wFlr,\n     dot (q.xz, bsa2));\n  if (d < dMin) { dMin = d;  idObj = 5; }\n  d = max (abs (length (q.xz) - rOut + wWal + 0.4 * wFlr) - 0.4 * wFlr,\n     dot (q.xz, bsa1));\n  d = max (d, min (abs (mod (mod (q.y, spFlr) + htFlr + 0.167 * spShf, spShf) -\n     0.5 * spShf) - htShf, - dot (q.xz, bsa2)));\n  if (d < dMin) { dMin = d;  idObj = 6; }\n  q.y = mod (q.y + 0.5 * spFlr + htFlr, spFlr) - 0.5 * spFlr;\n  d = max (PrTorusDf (q.xzy, 0.15, rOut - 1.5 * wFlr), dot (q.xz, bsa1));\n  if (d < dMin) { dMin = d;  idObj = 7; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  float f;\n  p *= 4.;\n  f = dot (vec3 (Fbm2 (p.zy * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.xy * vec2 (1., 0.1))), abs (n));\n  return mix (vec3 (0.8, 0.5, 0.3), vec3 (0.55, 0.35, 0.1), f);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, q;\n  vec2 gb;\n  float dstObj, a, s, bh, spec;\n  int idObjT;\n  rOut = 20.;\n  wFlr = 4.;\n  wWal = 0.5;\n  spFlr = 8.;\n  htShf = 0.05;\n  htFlr = 0.2;\n  spShf = 0.167 * (spFlr - htFlr) - htShf;\n  bsa1 = vec2 (sin (1.2 * 2. * pi / 32.), cos (1.2 * 2. * pi / 32.));\n  bsa2 = vec2 (sin (0.95 * 1.2 * 2. * pi / 32.), cos (0.95 * 1.2 * 2. * pi / 32.));\n  bsa3 = vec2 (sin (0.01 * 2. * pi / 32.), cos (0.01 * 2. * pi / 32.));\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    spec = 0.1;\n    q = ro;\n    a = 8. * atan (q.z, - q.x) / (2. * pi);\n    gb = floor (vec2 (q.y / spFlr, a));\n    if (idObj == 1) {\n      col = vec3 (0.6, 0.6, 0.55);\n      col *= 1. - 0.6 * smoothstep (0.15, 0.45, abs (0.5 - mod (a - 0.5, 1.)));\n      q.xy = vec2 (5. * (mod (a, 1.) - 0.5), 0.5 * (mod (q.y, spFlr) - 2.5));\n      if (abs (q.x) < 0.325 && abs (q.y) < 0.125) {\n        if (ShowInt (vec2 (q.x - 0.3, q.y + 0.09),\n           vec2 (0.6, 0.15), 4., mod (4242. + gb.x, 10000.)) != 0.)\n           col = vec3 (0.8, 0.6, 0.);\n      }\n      vn = VaryNf (100. * ro, vn, 2.);\n    } else if (idObj == 2) {\n      if (abs (vn.y) > 0.9) {\n        if (vn.y > 0.) col = vec3 (0.4, 0.2, 0.2) * (0.5 + 0.5 * smoothstep (0., 0.4,\n           (1. - (rOut - length (ro.xz)) / (2. * wFlr))));\n        else col = vec3 (0.8) *(1. - 0.4 * smoothstep (0.3, 0.5,\n           abs (rOut - 1.5 * wFlr - length (ro.xz)) / wFlr));\n        col *= 1. - 0.6 * smoothstep (0.15, 0.45, abs (0.5 - mod (a - 0.5, 1.)));\n      } else col = vec3 (0.65, 0.7, 0.7);\n      vn = VaryNf (100. * ro, vn, 1.);\n    } else if (idObj == 3) {\n      col = vec3 (0.7);\n      spec = 0.1;\n    } else if (idObj == 4) {\n      col = vec3 (0.5, 0.5, 0.55);\n      spec = 0.8;\n    } else if (idObj == 5) {\n      q.y = mod (q.y, spFlr) + htFlr + 0.5 * spShf + 0.167 * spShf;\n      gb = 0.5 * (gb + floor (vec2 (q.y / spShf, 48. * mod (a, 1.))));\n      bh = (0.7 + 0.3 * Fbm2 (gb * vec2 (19., 31.))) * spShf;\n      q.y = mod (q.y, spShf);\n      if (q.y < bh) { \n        s = mod (48. * mod (a, 1.), 1.);\n        col = vec3 (HsvToRgb (vec3 (Fbm2 (gb * vec2 (17., 11.)), 1.,\n           SmoothBump (0.08, 0.92, 0.01, 0.1 + 0.9 * s) *\n           (1. - 0.5 * step (abs (abs (q.y / bh - 0.5) - 0.35), 0.02)))));\n        vn.xz = Rot2D (vn.xz, 2. * (s - 0.5));\n        vn = VaryNf (20. * ro, vn, 1.);\n      } else col = vec3 (0.1);\n    } else if (idObj == 6) {\n      col = WoodCol (vec3 (5. * (mod (a, 1.) - 0.5), ro.y, length (ro.xz)), vn);\n    } else if (idObj == 7) {\n      col = vec3 (1., 1., 0.6) * 0.5 * (1. - vn.y);\n    }\n    if (idObj != 7) {\n      col = col * (0.2 + 0.8 * max (dot (vn, ltDir), 0.) +\n         spec * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.));\n      col *= smoothstep (0.7, 0.85, dot (rd, - ltDir)) *\n         (1. - 0.7 * smoothstep (0.5, 0.7, dstObj / 50.));\n    } \n  } else {\n    col = vec3 (0., 0., 0.07);\n    rd = (rd + vec3 (1., 0.7, 0.3));\n    for (int j = 0; j < 14; j ++) rd = 11. * abs (rd) / dot (rd, rd) - 3.;\n    col += min (1., 1.5e-6 * pow (min (16., length (rd)), 5.)) *\n       vec3 (0.7, 0.6, 0.6);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  az = -0.2 * tCur;\n  el = -0.17 * pi * sin (0.2 * tCur);\n  dstFar = 100.;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 2.1));\n  ro = vuMat * vec3 (0., 0., -10.);\n  ro.y += tCur;\n  ltDir = vuMat * vec3 (0., 0., -1.);\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n)) * (1. / 1.9375);\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return step (abs (q.x), 0.12) * step (abs (q.y), 0.6);\n}\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv < 5) {\n    if (iv == -1) k = 8;\n    else if (iv == 0) k = 119;\n    else if (iv == 1) k = 36;\n    else if (iv == 2) k = 93;\n    else if (iv == 3) k = 109;\n    else k = 46;\n  } else {\n    if (iv == 5) k = 107;\n    else if (iv == 6) k = 122;\n    else if (iv == 7) k = 37;\n    else if (iv == 8) k = 127;\n    else k = 47;\n  }\n  q = (q - 0.5) * vec2 (1.5, 2.2);\n  d = 0.;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx - vo);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy - vp);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy - vm);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy + vm);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy + vp);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.)) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (sgn < 0.) {\n      if (idChar == mxChar - nDig - 1.) s = ShowDig (q, -1);\n      else ++ v;\n    }\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4slcW2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 606, 628, 628, 2484], [2486, 2486, 2519, 2519, 2695], [2697, 2697, 2718, 2718, 2931], [2933, 2933, 2964, 2964, 3175], [3177, 3177, 3212, 3212, 6408], [6410, 6410, 6466, 6466, 7084], [7086, 7086, 7132, 7132, 7189], [7191, 7191, 7244, 7244, 7305], [7307, 7307, 7364, 7364, 7447], [7449, 7449, 7479, 7479, 7537], [7660, 7660, 7684, 7684, 7731], [7733, 7733, 7758, 7758, 7937], [7939, 7939, 7960, 7960, 8115], [8117, 8117, 8146, 8146, 8374], [8376, 8376, 8415, 8415, 8638], [8640, 8640, 8664, 8664, 8800], [8802, 8802, 8825, 8825, 8884], [8886, 8886, 8918, 8918, 9856], [9858, 9858, 9918, 9918, 10493]]}
{"id": "4slcz2", "name": "Jfranmp - Clouds v1", "author": "jfranmp", "description": "A simple clouds based on thebookofshaders.com", "tags": ["clouds"], "likes": 7, "viewed": 272, "published": "Public", "date": "1488980294", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// author: Juan Francisco\n// title: Clouds\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define NUM_OCTAVES 10\n\nfloat random (in vec2 _st) { \n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233))) * \n        43758.5453123);\n}\n\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2( cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    //mat2 rot = mat2( 0, 3. * sin(0.5), 0, cos(0.50));\n    \n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    \n    return v;\n}\n\nvec3 grayscale(in vec3 _rgb) {\n    vec3 base = vec3(0.2989, 0.587, 0.114);\n    float lum = base.r * _rgb.r + base.g * _rgb.g + base.b * _rgb.b;\n    return vec3(lum);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 st = fragCoord.xy/ iResolution.xy * 5. + iTime / 25.;\n    vec3 color = vec3(0);\n\n    vec2 q = vec2(0.);\n    q.x = fbm( st + 0.00*iTime);\n    q.y = fbm( st + vec2(1.0));\n    \n    vec2 r = vec2(0.);\n    r.x = fbm( st + 1.0*q + vec2(1.7,9.2)+ 0.15*iTime );\n    r.y = fbm( st + 1.0*q + vec2(8.3,2.8)+ 0.126*iTime);\n\n    float f = fbm( st + fbm(st + fbm(st)));\n\n    color = mix(vec3(0.198,0.629,0.667),\n                vec3(0.666667,0.666667,0.498039),\n                clamp((f*f)*4.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0,0,0.164706),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(0.666667,1,1),\n                clamp(length(r.x),0.0,1.0));\n    \n    float x = .5 + fbm(st);\n    float nt = noise(vec2(iTime * .013, iTime * .013));\n    float v1 = pow(length(r), 2.5 + 1.5 * (1. - nt));\n    float v2 = 1.;\n    float alpha = mix(v2, v1, nt);\n    \n    vec3 colorv = 1. * color + f*f*f*color*color;\n    vec3 tint = vec3(0.682,0.933,1.000);\n    \n    fragColor = vec4(tint * grayscale(colorv),alpha);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4slcz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 114, 142, 142, 253], [255, 255, 282, 282, 666], [668, 668, 694, 694, 1079], [1081, 1081, 1111, 1111, 1248], [1250, 1250, 1306, 1306, 2373]]}
{"id": "4slczf", "name": "Game Maker Studio-Circles", "author": "Glim888", "description": "A shader for Game Maker Studio\n\nMy App´s:\nBluetooth Multiplayer: play.google.com/store/apps/details?id=com.gaming_apps.bluetooth_game_duel\nWater Physics Simulation: play.google.com/store/apps/details?id=com.gaming_apps.water_physics_simulation\n", "tags": ["stuff", "glim888", "gamemakerstudioshader"], "likes": 4, "viewed": 273, "published": "Public", "date": "1489177412", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define width .015\t\t//width of the circles\n#define z 1.5;\t\t\t//speed for move func()\n\n\n\nvec3 circle(in vec2 uv,in vec2 pos,in vec3 color,in float rad)\n{\n float dist = distance(uv.xy,pos.xy);  \n   \n return color*=width/abs((dist-rad));    \n}\n\nvec2 distortion(inout vec2 uv)\n{\n    float amplitude = abs(sin(iTime));\n    if(amplitude > 0.9){\n    \t//uv.x += mod(iTime,0.004);\n        uv.x *= clamp(sin(1000.0*uv.y),0.9,1.0);         \n    }\n       \n    return uv;\n}\n\n\nvec2 move(inout vec2 uv)\n{\n  uv *= sin(iTime)- z;\n    \n  return uv;  \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //scale screen + mouse to center\n\tvec2 uv = (fragCoord.xy - (iResolution.xy/2.0)) / iResolution.xy;\n\tuv *= 2.0; \n    uv.x *= iResolution.x/iResolution.y; //müssen mehr x-Werte werden (0-1.xx)\n    \n    vec2 mouse = (iMouse.xy - (iResolution.xy/2.0)) / iResolution.xy;\n    mouse*=2.0;\n    mouse.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.0);;\n    \n    uv = distortion(uv);\n    //uv = move(uv);\n    \n    for(int i=0; i < 100;i++)\n        {\n        float ii = float(i);\n        float rad = ii*3000.0/(iTime*300.0);\n        col += circle(uv,vec2(0.0,0.0),vec3(0.2,1.0,0.2),rad);        \n        }\n    \n    \n    \n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4slczf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 151, 151, 239], [241, 241, 273, 273, 459], [462, 462, 488, 488, 533], [537, 537, 594, 631, 1259]]}
{"id": "4slyDB", "name": "dip blue", "author": "Netgfx", "description": "a knockoff out of @doodm electic sinusoid", "tags": ["tron", "line", "glow"], "likes": 6, "viewed": 209, "published": "Public", "date": "1489697866", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),sin(angle),sin(angle));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\t\n\tfloat bg = (cos(uv.x*3.14159*2.0) + sin((uv.y)*3.14159)) * 0.1;\n\t\n\tvec2 p = uv/2.8*cos(20.0)/iTime - bg/0.1;\n    vec2 v = rotate2d(iTime) * uv/0.1;\n    p *= vec2(v.x, v.y);\n    vec2 p2 = uv*2.0 - 1.0;\n\tp *= 35.0;\n    p2 *= 15.0;\n\tvec2 sfunc = vec2(p.x, p.y);\n    vec2 sfunc2 = vec2(p2.x, p2.x);\n\tsfunc.y /= 0.1; // Thickness fix\n    sfunc2.y /= 0.1;\n    p *= vec2(v.x, v.y);\n\t\n\tvec3 c = vec3(abs(sfunc.y));\n    vec3 c2 = vec3(abs(sfunc2.y));\n\tc = pow(c, vec3(-0.5));\n    c2 = pow(c2, vec3(-0.5));\n\tc *= vec3(0.3,0.85,1.0);\n    c2 *= vec3(0.3,0.85,1.0);\n\n\tfragColor = vec4(c+c2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4slyDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 92], [93, 93, 150, 150, 822]]}
{"id": "4sscD7", "name": "Testing Illumination", "author": "SalikSyed", "description": "A simple strobing horizontal fluorescent light.", "tags": ["test"], "likes": 3, "viewed": 182, "published": "Public", "date": "1488502614", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat computeIllumination(vec2 start, float len, vec2 uv) {\n    vec2 p0 = vec2(start.x, start.y);\n    vec2 p1 = vec2(start.x + len, start.y);\n\t// compute illumination based on equation:\n\treturn log(p1.x-uv.x + length(uv - p1)) - log(p0.x-uv.x + length(uv-p0));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // testing out \n    // contribution to O=(0,0) of 1 edge, \n    // assumed horizontal from P0=(x0,y) to P1=(x1,y): ln(x1 + ||OP1||) - ln(x0+||OP0||)\n\t\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n   \t\n    \n    float illumination = 0.0;\n    vec2 start = vec2(0.2, 0.5);\n    illumination += 0.25*(0.5*sin(iTime)+0.5) * computeIllumination(start, 0.4, uv);\n    \n\tfragColor = vec4(vec3(sqrt(illumination)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sscD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 61, 61, 265], [267, 267, 324, 481, 747]]}
{"id": "4sscDS", "name": "Sine Wave Zion 2", "author": "tomachi", "description": "boom", "tags": ["fractal"], "likes": 9, "viewed": 470, "published": "Public API", "date": "1489675406", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Concept: an animation of wave harmonics\n// show 1st, 2nd, 3rd order harmonics somehow \n\nfloat divs = 2.2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 m = iMouse; \n    if ( m.x == 0. && m.y == 0.) {\n        m.x = iResolution.x / 2.;\n        m.y = iResolution.y / 2.;\n\n    }\n\tfloat dist = m.x - ( iResolution.x / 2.0 ); // centererd\n    float speed = 0.0009; // 0.9 camera movement to plane \n    float timespeed =   0.1 ; // 0.1 wave movement on the ribbons\n    float igt = iTime; // shorter version of time\n   \n    //float t = 7.0 - (iTime * speed);\n    \n    // MOUSE: multiple by my or mx to get value between 1 and 2\n    float my = float( (m.y + iResolution.y ) / iResolution.y );\n    float mx = float( (m.x + iResolution.y ) / iResolution.x );\n\n    float t = 8.0 - speed ;\n\n    // divs create staggered / staged division:\n    //divs += t / 0.20;\n    \n    // let the mouse distance be the divs number, usually 1\n    // idea: mouse to the far right equals 1\n    divs += t / ( ( m.x + 2. ) /  iResolution.x );\n    \n\tvec2 div = vec2( divs, divs*iResolution.y/iResolution.x );\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    // center on screen\n    \n    uv -= 0.1 + (iTime*0.0001);\t\n    \n    \n    float b = 1.0*divs/iResolution.x;\t// blur over 2.4 pixels\n    //float b = 1000.1;\t// sharp - no blur\n\n    vec2 xy = div*uv;\n    \n    vec2 S; // speed of fundamental\n    vec2 S2; // speed of 1st octave\n\tvec2 S3; // speed of 2nd harmonic (perfect fifth?)\n\n    \n\tS.x = (xy.x + xy.y)*(xy.x - xy.y)*0.5;\t\t// \"velocity potential\"\n\tS2.x = (xy.x + xy.y)*(xy.x - xy.y)*0.5;\t\t// \"velocity potential\"\n\tS3.x = (xy.x + xy.y)*(xy.x - xy.y)*0.5;\t\t// \"velocity potential\"\n\n    S.y = xy.x*xy.y;\t\t\t\t\t\t// stream function\n\tS2.y = xy.x*xy.y;\t\t\t\t\t\t// stream function\t\n\tS3.y = xy.x*xy.y;\t\t\t\t\t\t// stream function\n\n    \n    \n    // speed of the dots\n    S.x   -=  iTime        *timespeed;\t\t\t\t\t\t// animate stream\n    S2.x  -=  iTime        *timespeed; // + (my * 20. );\t\t\t\t\t\t// animate stream\n    S3.x  -=  iTime        *timespeed; // + (my * 20.);\t\t\t\t\t\t// animate stream\n\n    //S2.x -= (iTime + my) *timespeed; //  * (m.y - (iResolution.y/2.) / iResolution.y) ;\t\t\t\t\t\t// animate stream\n\t//S3.x -= (iTime + my * 2. ) *timespeed; //  * (m.y - (iResolution.y/2.) / iResolution.y) ;\t\t\t\t\t\t// animate stream\n    \n    \n    \n\t// HERE IS THE WAVE HARMONICS \n    // SXY IS FUNDAMENTAL WAVE2 IS 2ND HARMONIC\n    // sxy is *probably* the main wave\n    // wave2 is the 2nd harmonic\n    \n    vec2 sxy =   sin(3.14159 * S  * 1.0 );\n    vec2 wave2 = sin(3.14159 * S2 * 1.1 ); // 2.00 is double\n    vec2 wave3 = sin(3.14159 * S3 * 1.2 ); // 3.00 is double\n    \n    \n    // w2 is the 2nd harmonic\n    float a = sxy.x * sxy.y;\t\t// combine sine waves using product\n    float w2 = wave2.x * wave2.y;\t// combine sine waves using product\n    float w3 = wave3.x * wave3.y;\t// combine sine waves using product\n    \n    // not sure what this does but we will do it to w2, w3 as well\n    a = 0.5*a + 0.5;\t\t\t\t\t\t\t// remap to [0..1]\n\ta = smoothstep( 0.85-b, 0.85+b, a );\t\t// threshold\n    \n    w2 = 0.5*a + 0.5;\t\t\t\t\t\t\t// remap to [0..1]\n\tw2 = smoothstep( 0.85-b, 0.85+b, a );\t\t// threshold\n    \n    w3 = 0.5*a + 0.5;\t\t\t\t\t\t\t// remap to [0..1]\n\tw3 = smoothstep( 0.85-b, 0.85+b, a );\t\t// threshold\n    \n    float c = sqrt( a  );\t\t\t\t\t\t// correct for gamma\n\tfloat w2gamma = sqrt( w2 );\t\t\t\t\t// correct for gamma\n\tfloat w3gamma = sqrt( w3 );\t\t\t\t\t// correct for gamma\n    \n    float red, green, blue;\n    \n    red   =    sxy.x - sxy.y ;\n    green =  wave2.x - wave2.y;\n    blue  =  wave3.x - wave3.y;\n    \n    float crossover = my * -1.;\n    \n    if (red < crossover) {\n       red = red * -1.;\n    }\n    if (green < crossover) {\n        green = green * -1.;\n    } \n    if (blue < crossover) {\n        blue = blue * -1.;\n    } \n    \n    \n    fragColor = vec4( red, green, blue, 1.0);\n    //fragColor = vec4(sxy.x, c, sxy.y, 1.0);\n\n    \n    //red =  sxy.x + wave2.y;\n    //green =  sxy.x + wave2.y;\n    //blue =  sxy.x + wave2.y;\n    \n        \n    //red =  sxy.x + wave2.y;\n    //green =  sxy.x + wave2.y;\n    //blue =  sxy.x + wave2.y;\n    \n        \n    //red =  sxy.x + sxy.y + wave2.x + wave2.y + wave3.x + wave3.y;\n    //green =   wave2.x - wave2.y;\n    //blue =   wave3.x - wave3.y;\n    \n    \n    // NICE WHITE RIBBON TYPE WAVE\n    //red =  sxy.x + sxy.y + wave2.x + wave2.y + wave3.x + wave3.y;\n    //green =  sxy.x + sxy.y + wave2.x + wave2.y + wave3.x + wave3.y;\n    //blue =  sxy.x + sxy.y + wave2.x + wave2.y + wave3.x + wave3.y;\n\n    // blue lines yellow and white balls\n    // fragColor = vec4(c, c, sxy.y, 1.0);\n    \n    \n    // blue lines yellow and white balls\n    //fragColor = vec4(  (c*2.0) - (w2gamma*2.0)  - (w3gamma*3.0) , c*2.0, sxy.y + wave2.y, 1.0);\n    //fragColor = vec4(  (c*2.0) - (w2gamma*2.0)  , c*2.0, sxy.y + wave2.y, 1.0);\n    //fragColor = vec4(c*2.0, wave2.y, sxy.y + wave2.y, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sscDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 110, 167, 167, 4883]]}
{"id": "4ssyWs", "name": "Journey to the edge of precision", "author": "tomachi", "description": "Witness the edge of your machines graphics card as you approach \"zion\" at about 42 seconds in! This is a MANDELBROT set zoom.", "tags": ["fractal", "mandelbrot", "zoom", "maths", "float"], "likes": 2, "viewed": 333, "published": "Public API", "date": "1490364271", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// this version by TOMACHI\n// based on code from: https://www.shadertoy.com/view/4df3Rn \n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// See here for more information on smooth iteration count:\n//\n// http://iquilezles.org/www/articles/mset_smooth/mset_smooth.htm\n\n\n// increase this if you have a very fast GPU\n#define AA 2\n\n// SET ZOOM LEVELS\n#define start 0.78\n#define end 0.65\n// SET PLAYBACK SPEED\n#define speed 0.1\n#define maxiters 400\n// SET ZOOM TARGET\n\n// #define vec2 target vec2(-.745,.186) + start + end * cos(0.);\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    float t = (iTime*speed) +2.;\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+vec2(float(m),float(n))/float(AA)))/iResolution.y;\n        float w = float(AA*m+n);\n        float time = t + 0.5*(1.0/24.0)*w/float(AA*AA);\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n        float time = t*.1;\n#endif\n    \t// SET ZOOM LEVELS - the next line zooms in and out on sine wave\n        float zoo = start + end*cos(0.509*time);\n        float coa = cos( 0.0055*(1.0-zoo)*time );\n        float sia = sin( 0.0055*(1.0-zoo)*time );\n        zoo = pow( zoo,8.0);\n        vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\n        float clickX = 0.;\n        float clickY = 0.;\n\n        if (iMouse.x != 0. && iMouse.y != 0.) {\n       \t\tclickX = (iMouse.x - (iResolution.x / 2.))*-0.015*zoo;\n       \t\tclickY = (iMouse.y - (iResolution.y / 2.))*-0.015*zoo;\n        }\n        \n        \n        \n        // I thikn this is the magic co-ords we zoom to?\n        vec2 c = vec2(-.745+clickX,.186+clickY) + xy*zoo;\n\n            \n        \n        const float B = 256.0;\n        float l = 0.0; // should be zero \n\t    vec2 z  = vec2(0.0);\n        for( int i=0; i<maxiters; i++ )\n        {\n            // z = z*z + c\t\t\n    \t\tz = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\n            if( dot(z,z)>(B*B) ) {\n                break;\n            }\n            if ( l  == 1.1 ) { \n                            l = z.x + z.y;\n   \n            }\n    \t\tl += 1.0;\n            \n        }\n\n    \t// ------------------------------------------------------\n        // smooth interation count\n    \t//float sl = l - log(log(length(z))/log(256.0))/log(2.0);\n        \n        // equivalent optimized smooth interation count\n    \tfloat sl = l - log2(log2(dot(z,z))) + 4.0; \n    \t// ------------------------------------------------------\n\t\n        // original that alternates between jagged and smooth:\n        //float al = smoothstep( -0.1, 0.0, sin(0.5*6.2831*t ) );\n       \n        // toms always smooth:\n        // float al = smoothstep( -0.1, 0.0, 0.1 );\n\t\tfloat al = 1.1;\n        l = mix( l, sl, al );\n\n        col += 0.5 + 0.5*cos( 3.0 + l*0.15 + vec3(0.0,0.6,1.0));\n#if AA>1\n    }\n    col /= float(AA*AA);\n#endif\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ssyWs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[542, 610, 667, 667, 3024]]}
{"id": "4ssyzj", "name": "Basic Loading Graphic", "author": "VoidChicken", "description": "*sigh* I must be really bored to resort to making these.", "tags": ["2d", "loading"], "likes": 10, "viewed": 193, "published": "Public", "date": "1488952964", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 DARK_UI = vec3(.12);\nvec3 BU_BLUE = vec3(.2,.4,.7);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 c = DARK_UI;\n    float q = smoothstep(0.,1.,mod(iTime/15.,.1)/.1);\n    float m = clamp(length(uv)*5.,0.,1.);\n    if (abs(length(uv)-q/5.)<.005) {\n    \tc=mix(BU_BLUE,DARK_UI,m);    \n    }\n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ssyzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 114, 114, 431]]}
{"id": "4sXcWj", "name": "Menger Sponge Reloaded", "author": "1vx_437312114", "description": "Menger sponge with point rotation.", "tags": ["procedural", "3d", "raymarching", "fractal", "distancefield", "menger", "sponge", "mengersponge"], "likes": 23, "viewed": 681, "published": "Public", "date": "1489806340", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on https://www.shadertoy.com/view/4sX3Rn\n// created by inigo quilez - iq\n// (see http://www.iquilezles.org/www/articles/menger/menger.htm for details)\n//\n// For an explanation of how to archieve realistic looking outdoor lighting take a look at\n// another excellent article of iq:\n//\n// http://iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n//\n// and for raymarching in general the classic article \"rendering worlds with two triangles\"\n//\n// http://iquilezles.org/www/material/nvscene2008/nvscene2008.htm\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Thanks to iq for the great tutorials, for shadertoy and everything else\n\n\n#define point_rotation true\n\n\n// globals (are bad, i know, but make life sometimes easier :-) )\nfloat dr;\n\n//Fractal\nconst int   NUM_ITERATIONS  = 5;\nconst float SCALE           = 3.0; \n      vec3  OFFSET          = vec3(1.0, 1.0, 1.0);\n\t  mat3  m               = mat3(1,0,0,0,1,0,0,0,1);//Initialized in main function\n\n\n// background color function, computes skycolor based on ray direction (used, if the ray hits nothing)\nvec3 skyColor(vec3 rd)\n{\n    vec3 sunDir = vec3(0.0, -1.0, 0.0);\n    vec3 sunColor = vec3(1.6, 1.8, 2.2);\n\n    float sunAmount = max(dot(rd, sunDir), 0.0);\n    float v = pow(1.0 - max(rd.y, 0.0), 6.0);\n    vec3 sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\n\n    sky += sunColor * sunAmount * sunAmount * 0.25 + sunColor * min(pow(sunAmount, 800.0) * 1.5, 0.3);\n\n\n    return clamp(sky, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n}\n\n\nfloat map(vec3 p)\n{\n\tfloat orbit = 1e20;\n    \n    for(int n = 0; n < NUM_ITERATIONS; n++) \n    {\n\t\tif(point_rotation)\n\t\t{\n\t\t\tfloat factor = 3.14159265 * 2.0 * (sin(iTime * 0.01));   \n    \n\t\t\tfloat si = sin(factor);\n\t\t\tfloat co = cos(factor);   \n\t\t\t\n\t\t\tmat3 xrot = mat3(\n\t\t\t\t 1.0,   0.0,  0.0,\n\t\t\t\t 0.0,    co,   si,\n\t\t\t\t 0.0,   -si,   co\n\t\t\t);\n\t\t\t\n\t\t\tmat3 yrot = mat3(\n\t\t\t\t   co,  0.0,  -si,\n\t\t\t\t  0.0,  1.0,  0.0,\n\t\t\t\t   si,  0.0,  co\n\t\t\t);\n\t\t\t\n\t\t\tmat3 zrot = mat3(\n\t\t\t\t   co,   si, 0.0,\n\t\t\t\t  -si,   co, 0.0,\n\t\t\t\t  0.0,  0.0, 1.0\n\t\t\t);\n\t\t\t\n\t\t\tp = p * xrot * yrot * zrot;\n\t\t}\n\t\t\n    \tp = abs(p);\n        \n    \tif(p.x < p.y)\tp.xy = p.yx;\n    \tif(p.x < p.z) \tp.xz = p.zx;\n    \tif(p.y < p.z) \tp.zy = p.yz;\t \n        \n    \tp.z -=  0.5 * OFFSET.z * (SCALE - 1.0) / SCALE;\n    \tp.z  = -abs(p.z);\n    \tp.z +=  0.5 * OFFSET.z * (SCALE - 1.0) / SCALE;\n        \n        p *= m;\n        \n   \t\tp   *= SCALE;  \n\t\tp.x -= OFFSET.x * (SCALE - 1.0);\n\t\tp.y -= OFFSET.y * (SCALE - 1.0);\n        \n        orbit = min(orbit, length(p));\n    }\n    \n    //distance to a cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    float dis = min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n    \n    //back to real scale\n    dis *= pow(SCALE, float(-NUM_ITERATIONS));\n    \n    dr = orbit;\n    \n    return dis;\n}\n\n\n// raymarching with distance field\nfloat intersect( in vec3 ro, in vec3 rd)\n{\n    const int maxStepCount = 256;\t// maximum no. of steps to march\n    const float tMax = 100.0;\t\t// maximum distance to march\n    const float epsilon = 0.0003;\t// determines precision (smaller values for more details\n    \t\t\t\t\t\t\t\t// and more noise due to holes from precision problems)\n\n\tfloat t = 0.0;\n\n    // march!\n    for(int i = 0; i < maxStepCount; i++)\n    {\n        // march forward along the ray, compute point p on ray for this step\n        vec3 p = ro + rd * t;\n\n        // get distance to nearest surface from distance field\n        float distance = map(p);\n\n        // if we're already marched too far (t > tMax),\n        // or we're close enough (less than epsilon) to the surface (we have \"hit\" it)\n        if ((t > tMax) || (distance < epsilon))\n            break;\n\n        // march further along the ray with the maximal distance possible,\n        // which is distance to the closest surface from the actual position\n        // taken from the signed distance field describing the mandelbulb\n        // this ensures, that we haven't gone too far, so that we are not already inside the mandelbulb\n        t += distance;\n    }\n\n    // if we're not exceeded the maximum marching distance, return ray parameter t for\n    // computating the hit surface position\n    if( t < tMax )\n   \t\treturn t;\n    else\n        return -1.0;\t// we missed it, signal this with -1.0\n}\n\n\n// cheap distance field soft shadow computation\n// (see iq article \"free penumbra shadows for raymarching distance fields\":\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm)\nfloat softShadow(vec3 surfacePoint, vec3 lightDir)\n{\n    vec3 origin = surfacePoint + 0.001 * lightDir;\n\n    vec3 ro = origin;\n    vec3 rd = lightDir;\n\n\n    const float k = 2.0; // 8.0\n    float res = 1.0;\n\tfloat t = 0.0;\n\n    for (int i = 0; i < 100; i++)\n    {\n        float h = map(ro + rd * t);\n\n        if (h < 0.0001)\n            return 0.0;\n\n        if (t > 100.0)\n            break;\n\n        res = min(res, k * h / t);\n        t += h;\n    }\n\n    return res;\n}\n\n\n// numerically approximate normal via discrete gradient computation (first order)\nvec3 computeNormal(vec3 surfacePoint)\n{\n    const float epsilon =  0.001;\n\n    vec3 epsX = vec3(epsilon, 0.0, 0.0);\n    vec3 epsY = vec3(0.0, epsilon, 0.0);\n    vec3 epsZ = vec3(0.0, 0.0, epsilon);\n\n    float dx = map(surfacePoint + epsX) - map(surfacePoint - epsX);\n    float dy = map(surfacePoint + epsY) - map(surfacePoint - epsY);\n    float dz = map(surfacePoint + epsZ) - map(surfacePoint - epsZ);\n\n    vec3 n = normalize(vec3(dx, dy, dz));\n\n    return n;\n}\n\n\n// cheap distance field ambient occlusion computation\nfloat computeAO(vec3 surfacePoint, vec3 normal)\n{\n    const float k = 5.0;\n    const float delta = 0.005;\n\n    float sum = 0.0;\n\n    for(float i = 0.0; i < 10.0; i+=1.0)\n    {\n        float factor = 1.0 / pow(2.0, i);\n        vec3 samplePoint = surfacePoint + normal * i * delta;\n\n        sum += factor * (i * delta - map(samplePoint));\n    }\n\n    return 1.0 - k * sum;\n}\n\n\n// compute fragment color by raymarching the whole scene, given 2D coords\nvec3 raymarch(vec2 point)\n{\n    // scene parameters\n    const vec3 cameraLookAt = vec3(0.0, 0.1, 0.0);\n\n    const vec3 light1 = vec3(  0.577, 0.577, -0.577 );\n\tconst vec3 light2 = vec3( -0.707, 0.000,  0.707 );\n\n\tconst float fov = 1.2;\t// change for bigger field of view\n\n\n    // compute aspect ratio 'corrected' pixel position\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 xy = -1.0 + 2.0 * point.xy / iResolution.xy;\n\n    vec2 s = xy * vec2(aspectRatio, 1.0);\n\n\n    // slow down time ...\n    float time = iTime * 0.5;\n\n\t// some iq magic for camera movement ...  (time dependent camera radius and rotations)\n\tfloat r = 2.3 + 0.1  * cos(0.29 * time);\n    vec3  ro = vec3( r * cos(0.33 * time), 0.8 * r * sin(0.37 * time), r * sin(0.31 * time) ); // ray origin\n\tfloat cr = 0.5 * cos(0.1 * time);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\n    // compute orthonormal camera basis\n    vec3 cameraDir = normalize(cameraLookAt - ro);\n\tvec3 cameraRight = normalize(cross(cameraDir, cp));\n\tvec3 cameraUp = normalize(cross(cameraRight, cameraDir));\n\n    // compute ray direction for perspective camera\n\tvec3 rd = normalize( s.x  * cameraUp + s.y * cameraRight + fov * cameraDir );\n\n\n\tvec3 col;\n\tvec3 tra;\n\n    // intersect ray (ray origin (ro), ray direction (rd) with scene,\n    // get ray parameter t for determining hit surface point\n    float t = intersect(ro, rd);\n\t\t\n\t\t\n    // nothing hit -> background color based on ray direction\n    if( t < 0.0 )\n        col = skyColor(rd);\n\telse\n\t{\n        // hit at t, compute position, normal, reflection, usw. (see links above)\n\t\tvec3 pos = ro + t * rd;\n        vec3 nor = computeNormal(pos);\n        vec3 hal = normalize( light1 - rd);\n        vec3 ref = reflect( rd, nor );\n\n        // for using resoluts of orbit traps for color\n\t\tfloat trc = 0.1 * log(dr);\n\n        // position based color for 'colorful' coloration :-)\n        tra = vec3(trc, trc, 0) * abs(pos);\n\n\n        col = vec3(0.7, 0.2, 0.2);\n\t\tcol = mix( col, vec3(1.0, 0.5, 0.2), sqrt(tra.y) );\n\t\tcol = mix( col, vec3(1.0, 1.0, 1.0), tra.x );\n\n        // compute diffuse components from both lights\n\t\tfloat dif1 = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat dif2 = clamp( 0.5 + 0.5*dot( light2, nor ), 0.0, 1.0 );\n\n        // add other lighting components (ambient occlusion, softshadows, specular)\n        // see iq article (http://iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm)\n        float occ =  0.05 * computeAO(pos, nor);\n        float sha = softShadow(pos, light1);\n        float fre = 0.04 + 0.96 * pow( clamp(1.0 - dot(-rd, nor), 0.0, 1.0), 5.0 );\n        float spe = pow( clamp(dot(nor, hal),0.0, 1.0), 12.0 ) * dif1 * fre * 8.0;\n\n        // some color magic\n        // 'good artists copy, great artists steal'. for the original see: \n        // https://www.shadertoy.com/view/ltfSWn\n\t\tvec3 lin  = 1.5 * vec3(0.15, 0.20, 0.23) * (0.7 + 0.3 * nor.y) * (0.2 + 0.8 * occ);\n\t\t     lin += 3.5 * vec3(1.00, 0.90, 0.60) * dif1 * sha;\n\t\t     lin += 4.1 * vec3(0.14, 0.14, 0.14) * dif2 * occ;\n             lin += 2.0 * vec3(1.00, 1.00, 1.00) * spe * sha * occ;\n             lin += 2.0 * vec3(0.20, 0.30, 0.40) * (0.02 + 0.98 * occ);\n             lin += 2.0 * vec3(0.8, 0.9, 1.0) * smoothstep( 0.0, 1.0, ref.y ) * occ;\n\n\t\tcol *= lin;\n        col += spe * 1.0 * occ * sha;\n\t}\n\n\n    // cheap gamma correction (for gamma = 1.0 / 2.0, close to 'official' lcd screen gamma = 1.0 / 2.2)\n\tcol = sqrt( col );\n\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color;\n\n\t// single sample for speed\n\tcolor = raymarch(fragCoord.xy);\n\t\t\n\n\tfragColor = vec4( color, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXcWj.jpg", "access": "shaders20k", "license": "gpl-3.0-plus OR cc-by-sa-3.0", "functions": [[1024, 1127, 1151, 1151, 1569], [1572, 1572, 1591, 1591, 2861], [2864, 2899, 2941, 2941, 4319], [4322, 4509, 4561, 4561, 4976], [4979, 5061, 5100, 5100, 5523], [5526, 5580, 5629, 5629, 5951], [5954, 6028, 6055, 6079, 9488], [9490, 9490, 9547, 9547, 9664]]}
{"id": "4sXyD7", "name": "Perlin Plasma", "author": "jscoggin", "description": "Perlin Plasma", "tags": ["procedural", "noise"], "likes": 0, "viewed": 138, "published": "Public", "date": "1488410089", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//  Classic Perlin 3D Noise \n//  by Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat noise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 5.0;\n    float color1 = noise(vec3((iTime / 3.0) + 0.0, fragCoord.x / (iResolution.x / scale), fragCoord.y / (iResolution.y / scale)));\n    float color2 = noise(vec3((iTime / 3.0) + 1.0, fragCoord.x / (iResolution.x / scale), fragCoord.y / (iResolution.y / scale)));\n    float color3 = noise(vec3((iTime / 3.0) + 2.0, fragCoord.x / (iResolution.x / scale), fragCoord.y / (iResolution.y / scale)));\n    fragColor = vec4(color1, color2, color3, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXyD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 56, 77, 77, 114], [115, 115, 142, 142, 190], [191, 191, 210, 210, 246], [248, 248, 268, 268, 2540], [2542, 2542, 2599, 2599, 3068]]}
{"id": "4sXyz2", "name": "Organic segment test", "author": "Zavie", "description": "Playing around with a segment SDF to get something a little more life-like.", "tags": ["test", "sdf", "demoscene", "organic", "segment"], "likes": 21, "viewed": 875, "published": "Public API", "date": "1488888506", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nAn experiment at creating an organic looking segment.\n\nThe function was used for modelling the statue of Poseidon in the\ntemple scene of the 64kB intro \"H - Immersion\", by Ctrl-Alt-Test.\n\n > http://www.ctrl-alt-test.fr/?page_id=444\n > https://www.youtube.com/watch?v=27PN1SsXbjM\n\n-- \nZavie / Ctrl-Alt-Test\n\n*/\n\nvec3 debugDistance(float d, vec3 color)\n{\n    float iso =\n        smoothstep(0.92, 0.98, abs(fract(d) * 2. - 1.)) +\n        smoothstep(0.8, 0.95, abs(fract(5.*d) * 2. - 1.))*0.5;\n    return mix(vec3(1.), color, iso)* mix(0.8, 1., float(d > 0.)) * smoothstep(0.02,0.06, abs(d));\n}\n\nfloat exponentialSmoothMmin(float a, float b, float k)\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat polynomialSmoothMmin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat segmentDistance(vec2 p, vec2 a, vec2 b, out float h)\n{\n\tvec2 ap = p - a;\n\tvec2 ab = b - a;\n\th = clamp(dot(ap, ab) / dot(ab, ab), 0., 1.);\n\treturn length(ap - ab * h);\n}\n\nvec4 limb(vec2 p, vec2 a, vec2 b, float ra, float rb, float fill, float k)\n{\n\tfloat da = length(a - p) - ra;\n\tfloat db = length(b - p) - rb;\n    float h;\n    float dmid = segmentDistance(p, a, b, h);\n\n    float bump = sin(2.*3.14159265358979 * (pow(h, 0.9) - 0.25)) * 0.5 + 0.5;\n    dmid -= mix(ra, rb, h + fill * bump);\n\n    float d = exponentialSmoothMmin(dmid, min(da, db), k);\n    return vec4(d, da, db, dmid);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 8.*fragCoord.xy / iResolution.y;\n\n    vec2 p1 = vec2(sin(2.*iTime), cos(iTime))+vec2(3.);\n    vec2 p2 = vec2(sin(3.*iTime), cos(1.2*iTime))+vec2(10., 4.);\n    \n    vec4 d = limb(uv, p1, p2, 0.85, 1.5, 0.8, 5.);\n\n    \n    vec3 color = 1.\n        * debugDistance(d.x, vec3(0.8, 0.8, 0.8))\n        * debugDistance(d.y, vec3(0.8, 0.5, 1.))\n        * debugDistance(d.z, vec3(0.5, 0.8, 1.))\n        * debugDistance(d.w, vec3(0.5, 1.0, 0.5))\n        ;\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXyz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 315, 356, 356, 594], [596, 596, 652, 652, 723], [725, 725, 782, 782, 875], [877, 877, 937, 937, 1051], [1053, 1053, 1129, 1129, 1469], [1471, 1471, 1528, 1528, 2016]]}
{"id": "4sXyzB", "name": "Waaaahhhh", "author": "sea", "description": "What I yelled when I got the rotation working, needs optimization.", "tags": ["rotate", "perlinnosie"], "likes": 1, "viewed": 88, "published": "Public", "date": "1488606270", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hash (vec3 p)\n{\n    p = vec3(dot(p, vec3(189.0, 75.0, 121.0)), dot(p, vec3(122.0, 220.0, 62.0)), dot(p, vec3(34.0, 96.0, 162.0)));\n    return fract(sin(p) * 4328395.432885) * 2.0 - 1.0;\n}\n\nfloat perlin3 (vec3 p)\n{\n    vec3 lbb = floor(p);\n    vec3 rtf = ceil(p);\n    \n    vec3 ltb = vec3(lbb.x, rtf.y, lbb.z);\n    vec3 rbb = vec3(rtf.x, lbb.y, lbb.z);\n    vec3 rtb = vec3(rtf.x, rtf.y, lbb.z);\n    vec3 rbf = vec3(rtf.x, lbb.y, rtf.z);\n    vec3 lbf = vec3(lbb.x, lbb.y, rtf.z);\n    vec3 ltf = vec3(lbb.x, rtf.y, rtf.z);\n    \n    vec3 glbb = hash(lbb);\n    vec3 gltb = hash(ltb);\n    vec3 grbb = hash(rbb);\n    vec3 grtb = hash(rtb);\n    vec3 grbf = hash(rbf);\n    vec3 grtf = hash(rtf);\n    vec3 glbf = hash(lbf);\n    vec3 gltf = hash(ltf);\n    \n    vec3 dlbb = p - lbb;\n    vec3 dltb = p - ltb;\n    vec3 drbb = p - rbb;\n    vec3 drtb = p - rtb;\n    vec3 drbf = p - rbf;\n    vec3 drtf = p - rtf;\n    vec3 dlbf = p - lbf;\n    vec3 dltf = p - ltf;\n    \n    float d1 = dot(dlbb, glbb);\n    float d2 = dot(dltb, gltb);\n    float d3 = dot(drbb, grbb);\n    float d4 = dot(drtb, grtb);\n    float d5 = dot(drbf, grbf);\n    float d6 = dot(drtf, grtf);\n    float d7 = dot(dlbf, glbf);\n    float d8 = dot(dltf, gltf);\n    \n    p = mod(p, 1.0);\n    p = p * p * (3.0 - 2.0 * p);\n    \n    float x1 = mix(d1, d3, p.x);\n    float x2 = mix(d2, d4, p.x);\n    float x3 = mix(d7, d5, p.x);\n    float x4 = mix(d8, d6, p.x);\n    \n    float y1 = mix(x1, x2, p.y);\n    float y2 = mix(x3, x4, p.y);\n    \n    return mix(y1, y2, p.z);\n}\n\nvec3 rotate (vec3 p, vec3 r)\n{\n    r *= 3.1415926 / 180.0;\n    \n    mat4 pitch = mat4(\n    \t1.0, 0.0, 0.0, 0.0,\n        0.0, cos(r.x), -sin(r.x), 0.0,\n        0.0, sin(r.x), cos(r.x), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n    \n    mat4 yaw = mat4(\n    \tcos(r.y), 0.0, -sin(r.y), 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        sin(r.y), 0.0, cos(r.y), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n    \n    mat4 roll = mat4(\n    \tcos(r.z), -sin(r.z), 0.0, 0.0,\n        sin(r.z), cos(r.z), 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n    \n    return (vec4(p, 1.0) * pitch * yaw * roll).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 ws = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    vec3 ro = vec3(0.0, 1.0, -2.0);\n    vec3 rd = vec3(ws, 1.0);\n    \n    for (float i = 0.0; i < 20.0; i += 0.1) \n    {\n        vec3 p = ro + rd * i;\n        p = rotate(p, vec3(0.0, p.y * 3.6, p.z * 36.0 * cos(iTime * 0.1)));\n        float r = perlin3(vec3(p.x, 0.0, p.z + iTime * 1.0)) - 0.5;\n        if (p.y < r)\n        {\n            color = vec3(r + 0.5);\n            break;\n        }\n    }\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXyzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 192], [194, 194, 218, 218, 1514], [1516, 1516, 1546, 1546, 2122], [2124, 2124, 2181, 2181, 2712]]}
{"id": "4sXyzX", "name": "Jellyfish Creature_PS20", "author": "Gracefrnandz", "description": "3 - 9 - 17", "tags": ["jellyfish"], "likes": 0, "viewed": 79, "published": "Public", "date": "1489024488", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 white = vec3(1., 1., 1. );\n\nfloat circle(vec2 uv, vec2 center, float radius)\n{\n    float bilog = step(distance(center,uv), radius);\n    return bilog;\n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat rectangle(vec2 uv, vec2 position, vec2 size, float angle)\n{\n    float leftSide = position.x;\n    float rightSide = position.x + size.x;\n    float bottom = position.y;\n    float top = position.y + size.y;\n    uv *= rotate2d(angle);\n    \n    float rect = step(leftSide, uv.x) - step(rightSide, uv.x); \n    float rect2 = step(bottom, uv.y) - step(top, uv.y);\n    \n    return (rect * rect2);\n}\n\n\nmat2 scale2d(float value)\n{\n    return mat2(value, 0, 0,value);\n}\n\nfloat rand(vec2 uv)\n{\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv += ((sin(iTime) + 0.1)/5.0);\n    \n    float n = noise(uv  * 15. + iTime) * .05;\n    float n2 = noise(uv * 10. + iTime) * .05;\n    \n    vec2 position2 = vec2(0.5 , 0.7);\n    float circle1 = circle(uv, position2, .15 + n);\n    \n    vec2 position = vec2(0.2, 0.4);\n    vec2 size = vec2(0.02, 0.4);\n    float rectangle1 = rectangle(uv + n2, position, size, .270);\n    \n    vec2 position3 = vec2(0.42, 0.25);\n    vec2 size3 = vec2(0.02, 0.4);\n    float rectangle2 = rectangle(uv + n2, position3, size3, .0);\n    \n    vec2 position4 = vec2(0.5, 0.25);\n    vec2 size4 = vec2(0.02, 0.4);\n    float rectangle3 = rectangle(uv + n2, position4, size4, .0);\n    \n    vec2 position5 = vec2(0.59, 0.25);\n    vec2 size5 = vec2(0.02, 0.4);\n    float rectangle4 = rectangle(uv + n2, position5, size5, .0);\n    \n    vec2 position6 = vec2(0.78, 0.1);\n    vec2 size6 = vec2(0.02, 0.4);\n    float rectangle5 = rectangle(uv + n2, position6, size6, -.270);\n    \n    fragColor = vec4(vec3(circle1 + rectangle1 + rectangle2 + rectangle3 + rectangle4 + rectangle5) * white, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXyzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 83, 83, 156], [158, 158, 186, 186, 254], [256, 256, 321, 321, 651], [654, 654, 681, 681, 719], [721, 721, 742, 742, 808], [810, 810, 835, 835, 1346], [1348, 1348, 1405, 1405, 2561]]}
{"id": "4t33zs", "name": "circle test2222", "author": "fscur", "description": "circle test", "tags": ["test"], "likes": 0, "viewed": 62, "published": "Public", "date": "1489120563", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926535897932384626433832795;\n\nfloat circle(vec2 p, float r)\n{\n\treturn length(p) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n    uv *= 5.0;\n    \n    \n    float t = iTime;\n    float x = cos(t * PI);\n    float y = sin(t * PI);\n    \n    \n    float c = uv.y * y;\n    float d = uv.x * x;\n    \n    float a = (atan(c, d) / PI) + 1.0;\n    \n    vec2 p = vec2(x, y);\n    \n    \n    vec2 q = uv - p;\n    float e = smoothstep(0.0, 0.0 + 0.001, circle(q, 1.0));\n    \n    \n    \n    vec3 color = vec3(1.0);\n    \n\tfragColor = vec4(e, 0.0, a, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t33zs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 84, 84, 109], [111, 111, 168, 168, 700]]}
{"id": "4ttGDH", "name": "Abstract Glassy Field", "author": "Shane", "description": "An abstract, blobby-looking field - rendered in the style of hot, glowing, fluid-filled glass. All produced using cheap low-budget pseudoscience. :)", "tags": ["raymarch", "refraction", "glass", "blob", "glow", "field", "hot"], "likes": 262, "viewed": 19455, "published": "Public API", "date": "1490104585", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tAbstract Glassy Field\n\t---------------------\n\n\tAn abstract, blobby-looking field - rendered in the style of hot, glowing glass. It was \n\tproduced using cheap low-budget psuedoscience. :)\n\n\tThe surface was constructed with a spherized sinusoidal function, of sorts. I like it, because \n\tit's very cheap to produce, mildly reminiscent of noise and allows a camera to pass through it \n\twithout having to resort to trickery.\n\n\tThe fluid filled glass look is fake, but at least interesting to look at. Basically, it was\n\tproduced by indexing the reflected and refracted surface rays into a 3D tri-planar texture\n\tlookup. By the way, I've tried the real thing on this particular surface - with multiple ray \n\tbounces and so forth - and to say it's slower is an understatement. :)\n\n\tBy the way, if anyone is aware of some cheap and simple improvements, corrections, etc, feel\n\tfree to let me know.\n\n*/\n\n#define FAR 50. // Far plane, or maximum distance.\n\n//float objID = 0.; // Object ID\n\nfloat accum; // Used to create the glow, by accumulating values in the raymarching function.\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) - a);\treturn mat2(v, -v.y, v.x); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.zy).xyz;\n    vec3 ty = texture(t, p.xz).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\n// Camera path.\nvec3 camPath(float t){\n  \n    //return vec3(0, 0, t); // Straight path.\n    //return vec3(-sin(t/2.), sin(t/2.)*.5 + 1.57, t); // Windy path.\n    \n    //float s = sin(t/24.)*cos(t/12.);\n    //return vec3(s*12., 0., t);\n    \n    float a = sin(t * 0.11);\n    float b = cos(t * 0.14);\n    return vec3(a*4. -b*1.5, b*1.7 + a*1.5, t);\n    \n}\n\n\n// A fake, noisy looking field - cheaply constructed from a spherized sinusoidal\n// combination. I came up with it when I was bored one day. :) Lousy to hone in\n// on, but it has the benefit of being able to guide a camera through it.\nfloat map(vec3 p){\n \n    p.xy -= camPath(p.z).xy; // Perturb the object around the camera path.\n    \n     \n\tp = cos(p*.315*1.25 + sin(p.zxy*.875*1.25)); // 3D sinusoidal mutation.\n    \n    \n    float n = length(p); // Spherize. The result is some mutated, spherical blob-like shapes.\n\n    // It's an easy field to create, but not so great to hone in one. The \"1.4\" fudge factor\n    // is there to get a little extra distance... Obtained by trial and error.\n    return (n - 1.025)*1.33;\n    \n}\n\n/*\n// Alternative, even more abstract, field.\nfloat map(vec3 p){\n    \n    p.xy -= camPath(p.z).xy; // Perturb the object around the camera path.\n   \n\tp = cos(p*.1575 + sin(p.zxy*.4375)); // 3D sinusoidal mutation.\n    \n    // Spherize. The result is some mutated, spherical blob-like shapes.\n    float n = dot(p, p); \n    \n    p = sin(p*3.+cos(p.yzx*3.)); // Finer bumps. Subtle.\n    \n    return (n - p.x*p.y*p.z*.35 - .9)*1.33; // Combine, and we're done.\n    \n}\n*/\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n)\n{\n\tfloat sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.35/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(vec3 p){\n\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), \n                          map(p + e.yxy) - map(p - e.yxy), map(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    accum = 0.;\n    float t = 0.0, h;\n    for(int i = 0; i < 128; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.001*(t*.25 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h;\n        \n        // Simple distance-based accumulation to produce some glow.\n        if(abs(h)<.35) accum += (.35-abs(h))/24.;\n        \n    }\n\n    return min(t, FAR);\n}\n\n\n// Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 24; \n\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n\n        dist += clamp(h, 0.01, 0.2);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (abs(h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.4, 1.0); \n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tpl(tx, p - e.xyy, n), tpl(tx, p - e.yxy, n), tpl(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tpl(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n\n// Simple environment mapping.\nvec3 envMap(vec3 rd, vec3 n){\n    \n    vec3 col = tpl(iChannel1, rd*4., n);\n    return smoothstep(0., 1., col);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    float speed = 4.;\n    vec3 o = camPath(iTime*speed); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime*speed + .25);  // \"Look At\" position.\n    vec3 l = camPath(iTime*speed + 2.) + vec3(0, 1, 0); // Light position, somewhere near the moving camera.\n\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/2.; ///3. FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0, -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    //vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n    vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    r = normalize(vec3(r.xy, (r.z - length(r.xy)*.125)));\n\n\n    // Raymarch.\n    float t = trace(o, r);\n    \n    // Save the object ID directly after the raymarching equation, since other equations that\n    // use the \"map\" function will distort the results. I leaned that the hard way. :)\n    //float sObjID = objID;\n\n    // Initialize the scene color to the background.\n    vec3 col = vec3(0);\n    \n    // If the surface is hit, light it up.\n    if(t<FAR){\n    \n        // Position.\n        vec3 p = o + r*t;\n\t\t\n        // Normal.\n        vec3 n = nr(p);\n        \n        // Sometimes, it's handy to keep a copy of the normal. In this case, I'd prefer the\n        // bumps on the surface to not have as much influence on the reflrection and \n        // refraction vectors, so I tone down the bumped normal with this. See the reflection\n        // and refraction lines.\n        vec3 svn = n;\n        \n        // Texture bump the normal.\n        float sz = 1./3.; \n        n = db(iChannel0, p*sz, n, .1/(1. + t*.25/FAR));\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n\n        \n        float at = 1./(1. + d*.05 + d*d*.0125); // Light attenuation.\n        \n        // Ambient occlusion and shadowing.\n        float ao =  cao(p, n);\n        float sh = sha(p, l, 0.04, d, 16.);\n        \n        // Diffuse, specular, fresnel. Only the latter is being used here.\n        float di = max(dot(l, n), 0.);\n        float sp = pow(max( dot( reflect(r, n), l ), 0.), 64.); // Specular term.\n        float fr = clamp(1.0 + dot(r, n), .0, 1.); // Fresnel reflection term.\n \n         \n        \n        // Texturing - or coloring - the surface. The \"color\"' of glass is provide by the surrounds...\n        // of it's contents, so just make it dark.\n        vec3 tx = vec3(.05); // tpl(iChannel0, p*sz, n);\n         \n\n\t\t// Very simple coloring.\n        col = tx*(di*.1 + ao*.25) + vec3(.5, .7, 1)*sp*2. + vec3(1, .7, .4)*pow(fr, 8.)*.25;\n \n        // Very cheap, and totally fake, reflection and refraction. Obtain the reflection and\n        // refraction vectors at the surface, then pass them to the environment mapping function.\n        // Note that glass and fluid have different refractive indices, so I've fudged them into \n        // one figure.\n        vec3 refl = envMap(normalize(reflect(r, svn*.5 + n*.5)), svn*.5 + n*.5);\n        vec3 refr = envMap(normalize(refract(r, svn*.5 + n*.5, 1./1.35)), svn*.5 + n*.5);\n        \n        /*\n\t\t// You can also index into a 3D texture, but I prefer the above.\n        vec3 refl = texture(iChannel2, normalize(reflect(r, svn*.5 + n*.5))).xyz;\n        vec3 refr = texture(iChannel2, normalize(refract(r, svn*.5 + n*.5, 1./1.31))).xyz;\n        refl *= refl*.5;\n        refr *= refr*.5;\n        */\n        \n        // More fake physics that looks like real physics. :) Mixing the reflection and refraction \n        // colors according to a Fresnel variation.\n        vec3 refCol = mix(refr, refl, pow(fr, 5.)); //(refr + refl)*.5; // Adding them, if preferred.\n        \n        // Obviously, the reflected\\refracted colors will involve lit values from their respective\n        // hit points, but this is fake, so we're just combining it with a portion of the surface \n        // diffuse value.\n        col += refCol*((di*di*.25+.75) + ao*.25)*1.5; // Add the reflected color. You could combine it in other ways too.\n        \n        // Based on IQ's suggestion: Using the diffuse setting to vary the color slightly in the\n        // hope that it adds a little more depth. It also gives the impression that Beer's Law is \n        // taking effect, even though it clearly isn't. I might try to vary with curvature - or some other\n        // depth guage - later to see if it makes a difference.\n        col = mix(col.xzy, col, di*.85 + .15); \n        \n        // Glow.\n        // Taking the accumulated color (see the raymarching function), tweaking it to look a little\n        // hotter, then combining it with the object color.\n        vec3 accCol = vec3(1, .3, .1)*accum;\n        vec3 gc = pow(min(vec3(1.5, 1, 1)*accum, 1.), vec3(1, 2.5, 12.))*.5 + accCol*.5;\n        col += col*gc*12.;\n        \n        \n        // Purple electric charge.\n        float hi = abs(mod(t/1. + iTime/3., 8.) - 8./2.)*2.;\n        vec3 cCol = vec3(.01, .05, 1)*col*1./(.001 + hi*hi*.2);\n        col += mix(cCol.yxz, cCol, n3D(p*3.));\n \t\t// Similar effect.\n        //vec3 cCol = vec3(.01, .05, 1)*col*abs(tan(t/1.5 + iTime/3.));\n        //col += cCol;\n \n        \n        // Apply some shading.\n        col *= ao*sh*at;\n\n        \n    }\n    \n    \n    // Blend in a bit of light fog for atmospheric effect.\n    vec3 fog = vec3(.125, .04, .05)*(r.y*.5 + .5);    \n    col = mix(col, fog, smoothstep(0., .95, t/FAR)); // exp(-.002*t*t), etc. fog.zxy\n\n    \n    // Subtle vignette.\n    u = fragCoord/iResolution.xy;\n    col = mix(vec3(0), col, pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y) , .125)*.5 + .5);\n\n \n    \n    // Rough gamma correction, and we're done.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n    \n    \n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ttGDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1081, 1233, 1254, 1254, 1320], [1323, 1481, 1527, 1527, 2035], [2038, 2054, 2076, 2272, 2390], [2393, 2628, 2646, 2646, 3120], [3591, 3743, 3776, 3776, 4018], [4021, 4121, 4137, 4137, 4323], [4327, 4348, 4384, 4384, 4958], [4961, 4973, 5049, 5049, 5633], [5636, 5718, 5773, 5773, 6272], [6274, 6417, 6435, 6435, 6781], [6785, 6816, 6845, 6845, 6929], [6932, 6932, 6988, 7022, 12944]]}
{"id": "ld2czz", "name": "Drone Flight", "author": "dr2", "description": "Flight through terrain adapted from Shane's \"Canyon Pass\"", "tags": ["raymarch", "flight", "drone", "canyon"], "likes": 1, "viewed": 620, "published": "Public API", "date": "1490723058", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Drone Flight\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Flight through terrain adapted from Shane's \"Canyon Pass\"\n\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrRCylDf (vec3 p, float r, float rt, float h);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nconst float pi = 3.14159;\n\nvec3 dronePos, ltPos;\nvec2 aTilt;\nfloat dstFar, tCur;\nint idObj;\nconst int idDrBod = 1, idDrLamp = 2, idDrCam = 3;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d;\n  const float dSzFac = 6.;\n  dMin = dstFar;\n  dMin *= dSzFac;\n  qq = dSzFac * (p - dronePos);\n  qq.yz = Rot2D (qq.yz, - aTilt.y);\n  qq.yx = Rot2D (qq.yx, - aTilt.x);\n  q = qq;\n  q.y -= 0.05;\n  d = PrRCylDf (q.xzy, 0.2, 0.03, 0.07);\n  if (d < dMin) { dMin = d;  idObj = idDrBod; }\n  q.y -= 0.07;\n  d = PrRoundBoxDf (q, vec3 (0.06, 0.02, 0.12), 0.04);\n  if (d < dMin) { dMin = d;  idObj = idDrLamp; }\n  q = qq;\n  q.y -= -0.05;\n  d = PrSphDf (q, 0.17);\n  if (d < dMin) { dMin = d;  idObj = idDrCam; }\n  q = qq;\n  q.xz = abs (q.xz) - 0.7;\n  d = min (PrCylAnDf (q.xzy, 0.5, 0.05, 0.05), PrCylDf (q.xzy, 0.1, 0.03));\n  q -= vec3 (-0.4, -0.15, -0.4);\n  d = min (d, PrRCylDf (q.xzy, 0.05, 0.03, 0.2));\n  q -= vec3 (-0.3, 0.2, -0.3);\n  q.xz = Rot2D (q.xz, 0.25 * pi);\n  d = min (d, min (PrRCylDf (q, 0.05, 0.02, 1.), PrRCylDf (q.zyx, 0.05, 0.02, 1.)));\n  if (d < dMin) { dMin = d;  idObj = idDrBod; }\n  return dMin / dSzFac;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 50; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (vec2 (sin (t * 0.15), cos (t * 0.17)) * mat2 (4., -1.5, 1.3, 1.7), t);\n}\n\nfloat GrndDf (vec3 p)\n{\n  vec3 pt;\n  float s;\n  p.xy -= TrackPath (p.z).xy;\n  s = p.y + 3.;\n  pt = abs (fract (p + abs (fract (p.zxy) - 0.5)) - 0.5);\n  p += (pt - 0.25) * 0.3;\n  return min (length (cos (0.6 * p + 0.8 * sin (1.3 * p.zxy))) - 1.1,\n     s + 0.07 * dot (pt, vec3 (1.)));\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = GrndDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nfloat GrndAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = 0; j < 8; j ++) {\n    d = float (j + 1) / 8.;\n    ao += max (0., d - 3. * GrndDf (ro + rd * d));\n  }\n  return clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (GrndDf (p + e.xxx), GrndDf (p + e.xyy),\n     GrndDf (p + e.yxy), GrndDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 16; j ++) {\n    h = GrndDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.2, 0.1 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.3 + 0.7 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn, ltDir;\n  float dstGrnd, dstObj, ltDist, atten, spec;\n  bgCol = vec3 (0.8, 0.8, 0.9);\n  dstGrnd = GrndRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (min (dstGrnd, dstObj) < dstFar) {\n    ltDir = ltPos - ro;\n    ltDist = length (ltDir);\n    ltDir /= ltDist;\n    atten = 1. / (1. + 0.002 * ltDist * ltDist);\n    if (dstGrnd < dstObj) {\n      ro += rd * dstGrnd;\n      vn = GrndNf (ro);\n      vn = VaryNf (5. * ro, vn, 50.);\n      col = mix (vec3 (0.5, 0.4, 0.1), vec3 (0.4, 0.8, 0.4),\n         clamp (0.5 + vn.y, 0., 1.)) *\n         (0.2 + 0.8 * max (dot (vn, ltDir), 0.) +\n         pow (max (dot (reflect (ltDir, vn), rd), 0.0), 32.)) *\n         (0.1 + 0.9 * atten * min (GrndSShadow (ro, ltDir), GrndAO (ro, vn)));\n      col = mix (col, bgCol, smoothstep (0.45, 0.99, dstGrnd / dstFar));\n    } else {\n      ro += rd * dstObj;\n      vn = ObjNf (ro);\n      if (idObj == idDrBod) {\n        col = vec3 (1.5, 1., 1.5);\n        spec = 0.5;\n      } else if (idObj == idDrLamp) {\n        col = mix (vec3 (0.3, 0.3, 2.), vec3 (2., 0., 0.),\n           step (0., sin (10. * tCur)));\n        spec = -1.;\n      } else if (idObj == idDrCam) {\n        col = vec3 (0.1, 0.1, 0.1);\n        spec = 1.;\n      }\n      if (spec >= 0.)\n        col = col * (0.2 + 0.8 * GrndSShadow (ro, ltDir)) *\n           (0.1 + 0.9 * atten * (max (dot (ltDir, vn), 0.) +\n           spec * pow (max (dot (reflect (rd, vn), ltDir), 0.), 64.)));\n    }\n  } else col = bgCol;\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, fpF, fpB, vd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, s, ss;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  s = 4. * tCur;\n  ss = s + 2.5 + 1.5 * cos (0.1 * s);\n  dronePos = TrackPath (ss);\n  aTilt = vec2 (12. * (TrackPath (ss + 0.1).x - dronePos.x), 0.2);\n  fpF = TrackPath (s + 0.1);\n  fpB = TrackPath (s - 0.1);\n  ro = 0.5 * (fpF + fpB);\n  vd = fpF - fpB;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az = az + 2. * pi * mPtr.x;\n    el = el + 0.95 * pi * mPtr.y;\n  }\n  ori = vec2 (el, az + ((length (vd.xz) > 0.) ? atan (vd.x, vd.z) : 0.5 * pi));\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 1.6));\n  ltPos = ro + 10. * normalize (vec3 (-0.5, 1., -1.));\n  dstFar = 30.;\n  fragColor = vec4 (ShowScene (ro, rd), 2.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n)) * (1. / 1.9375);\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld2czz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[120, 622, 644, 644, 1593], [1595, 1595, 1628, 1628, 1803], [1805, 1805, 1826, 1826, 2033], [2035, 2035, 2061, 2061, 2149], [2151, 2151, 2174, 2174, 2436], [2438, 2438, 2472, 2472, 2649], [2651, 2651, 2684, 2684, 2868], [2870, 2870, 2892, 2892, 3109], [3111, 3111, 3149, 3149, 3388], [3390, 3390, 3425, 3425, 4933], [4935, 4935, 4988, 4988, 6036], [6038, 6038, 6071, 6071, 6098], [6100, 6100, 6142, 6142, 6193], [6195, 6195, 6248, 6248, 6309], [6311, 6311, 6364, 6364, 6543], [6545, 6545, 6591, 6591, 6638], [6640, 6640, 6670, 6670, 6728], [6851, 6851, 6875, 6875, 6922], [6924, 6924, 6949, 6949, 7148], [7150, 7150, 7179, 7179, 7407], [7409, 7409, 7448, 7448, 7671]]}
{"id": "ld2yRR", "name": "Tricky Shit", "author": "JavasCrypt20", "description": "Added a  light mousecontrol for the pattern color and uvs.\nJust a little playing around with the first things i learned now about shader coding.", "tags": ["procedural", "2d", "mouse", "math", "imouse"], "likes": 7, "viewed": 229, "published": "Public", "date": "1490685155", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime / 2.2 \nfloat poSin ( float toCalc){\n    return 0.5 + 0.5 * sin( toCalc);\n}\nfloat poCos ( float toCalc){\n    return 0.5 + 0.5 * cos( toCalc);\n}\nfloat pillows ( vec2 uv){\n\treturn distance( sin( uv.x), sin( uv.y));\n}\nfloat ringsHard ( vec2 uv, float repeat){\n\treturn poSin( distance( uv , vec2( 0.0) ) * repeat);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord){\n    vec2 ctrl \t= vec2(1.0, 2.0);\n    float ctrl2 = 1.0;\n    if( iMouse.x != 0.0 && iMouse.y != 0.0){\n    \tctrl \t= vec2(iMouse.x/iResolution.x*1.5, (iMouse.y/iResolution.y+0.82)*1.8);\n        ctrl2\t= 0.01 + pow ( iMouse.x * iMouse.y, 0.75);   \n    }\n\tvec2 uv \t= \t(fragCoord.xy / iResolution.xy) - 0.5;\n    uv.x \t\t*= \t(iResolution.x / iResolution.y);\n    vec2 tempUv = \tuv;\n    float grey \t= \tringsHard(uv, (1.0 - cos(time / 2.5)) * 7.0);\n    float pil \t= \tpillows((uv * sin(time / 6.0) * ( 1.0 + ctrl.x * 90.0)) - (grey * (0.6 + ctrl.x + poSin(time))));\n    vec2 distort= \tvec2(grey, 1.6- grey) * ctrl.y * pil;\n    distort\t\t+= \tctrl2 * distort / 3000.0;\n    float grey2 = \t1.0 - ringsHard(uv / 3.0 * sin(time / 3.0) + abs(distort / ctrl.y) , poCos(time * 1.5)* 2.0);\n    grey2 \t\t*= \t((pil + grey2) * grey) * grey;\n    uv \t\t\t= \ttempUv;\n    float damp \t= \tclamp(pow((1.0 - distance(uv, vec2(0.0))) / 2.0, ctrl.y) * ctrl.y * 0.6, 0.0, 1.0);\n    float r \t= \t(grey2 + distort.y) * (distort.x * grey) / ctrl.y * damp;\n    float g \t= \tabs((grey2 - distort.x) * (distort.y - grey2)) / 4.5 * damp;\n    float b \t= \tpow(grey2, 0.9 + poCos(time / 2.7)) * 4.0 * damp;\n    fragColor \t= \tvec4(r,g,b ,1.0);//r,g,b   vec3(soundS)\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld2yRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 54, 54, 93], [94, 94, 122, 122, 161], [162, 162, 187, 187, 232], [233, 233, 274, 274, 330], [332, 332, 387, 387, 1601]]}
{"id": "ldfcRS", "name": "isovalues", "author": "FabriceNeyret2", "description": ".", "tags": ["noise", "contour"], "likes": 11, "viewed": 701, "published": "Public API", "date": "1488641442", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// --- noise from procedural pseudo-Perlin (better but not so nice derivatives) ---------\n                    // ( adapted from IQ )\n\nfloat noise3( vec3 x ) {\n    vec3 p = floor(x),f = fract(x);\n\n    f = f*f*(3.-2.*f);  // or smoothstep     // to make derivative continuous at borders\n\n#define hash3(p)  fract(sin(1e3*dot(p,vec3(1,57,-13.7)))*4375.5453)        // rand\n    \n    return mix( mix(mix( hash3(p+vec3(0,0,0)), hash3(p+vec3(1,0,0)),f.x),       // triilinear interp\n                    mix( hash3(p+vec3(0,1,0)), hash3(p+vec3(1,1,0)),f.x),f.y),\n                mix(mix( hash3(p+vec3(0,0,1)), hash3(p+vec3(1,0,1)),f.x),       \n                    mix( hash3(p+vec3(0,1,1)), hash3(p+vec3(1,1,1)),f.x),f.y), f.z);\n}\n\n#define noise(x) (noise3(x)+noise3(x+11.5)) / 2. // pseudoperlin improvement from foxes idea \n\n\n\nvoid mainImage( out vec4 O, vec2 U ) // ------------ draw isovalues\n{\n    U *= 8./iResolution.y;\n    float n = noise(vec3(U,.1*iTime)),\n          v = sin(6.28*10.*n);\n    v = smoothstep(1.,0., .5*abs(v)/fwidth(v));\n\tO = v * (.5+.5*sin(12.*n+vec4(0,2.1,-2.1,0)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldfcRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 134, 158, 158, 721], [820, 820, 889, 889, 1084]]}
{"id": "ldfcWs", "name": "[ Famous curves ] - #2", "author": "Yrai", "description": "#2 - Astroid", "tags": ["2d", "curve", "parametric", "astroid"], "likes": 4, "viewed": 460, "published": "Public API", "date": "1490303100", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/*\n   Astroid facts:\n  ----------------\n\t- (a) Also called the tetracuspid because it has four cusps.\n\t- (b) Curve can be formed by rolling a circle of radius a/4 on the inside of a circle of radius a.\n\t- (c) The curve can also be formed as the envelop produced when a line segment is moved with\n\t\t  each end on one of a pair of perpendicular axes (glissette)\n*/\n\n#define res_            iResolution\n#define time_           iTime\n#define trace_len_      48\n#define eps_            0.1\n\nvec2  domain(vec2 uv, float s);\nvec2  parametric(float t);\nfloat trace(vec2 p, float t);\n\nvoid mainImage(out vec4 o, vec2 f) {\n\tvec2 p = domain(f, 8.);\n    \n    // t -> [0., 5.]\n    float t = abs(sin(time_)*5.);\n    \n    // Astroid traces\n    float dtrace = smoothstep(0.008, 0.001, trace(p, t));\n    float dtrace_s0 = smoothstep(0.16 + sin(time_)*.1, 0.001, trace(p, t));\n    \n    // Axis\n    float ax = min(\n        smoothstep(0., 0.02, abs(p.x)),\n        smoothstep(0., 0.02, abs(p.y))\n    );\n    // Origin\n    float org = smoothstep(0.09, 0., length(p)-.01);\n    \n    // Palette \n    vec3 gray   = vec3(.2);\n    vec3 white  = vec3(5.);\n    \n    // Shading\n    vec3 c  = vec3(0.);\n    c = mix(c, gray, 1.-ax);\n    c = mix(c, white, org);\n    \n    c = mix(c, white, dtrace);\n    c = mix(c, vec3(0.5, 1., 1.1) + vec3(abs(sin(time_)), abs(sin(time_)), 0.), dtrace_s0);\n    c.b += dtrace_s0;\n    \n    o = vec4(sqrt(c), 1.);\n}\n\nvec2 parametric(float t) {\n\tfloat a = 4.;\n    return vec2(a*cos(t)*cos(t)*cos(t), a*sin(t)*sin(t)*sin(t));\n}\n\nfloat trace(vec2 p, float t) {\n    float d = 1e10;\n    float e = 0.;\n    for(int i = 0; i < trace_len_; i++) {\n    \td  = min(d, distance(p, parametric(t-e)));\n        e += eps_; \n    }\n    return d;\n}\n\nvec2 domain(vec2 uv, float s) {\n    return (2. * uv.xy - res_.xy) / res_.y * s;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldfcWs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[89, 665, 701, 701, 1499], [1501, 1501, 1527, 1527, 1609], [1611, 1611, 1641, 1641, 1811], [1813, 1813, 1844, 1844, 1894]]}
{"id": "ldfyzf", "name": "universal wallpaper", "author": "jes5199", "description": "sinusoidals of the levels of all three of chromogeometry's relativistic conics", "tags": ["2d", "wallpaper"], "likes": 3, "viewed": 148, "published": "Public", "date": "1489134468", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float D3DX_SRGB_to_FLOAT(float val)\n{\n    if( val < 0.04045 )\n        val /= 12.92;\n    else\n        val = pow((val + 0.055)/1.055,2.4);\n    return val;\n}\n\nvec3 D3DX_SRGB_to_FLOAT(vec3 val)\n{\n    return vec3(\n        D3DX_SRGB_to_FLOAT(val.r),\n        D3DX_SRGB_to_FLOAT(val.g),\n        D3DX_SRGB_to_FLOAT(val.b)\n    );\n}\n\nfloat signpower(float n, float p){\n    return sign(n) * abs(pow(n,p));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = (fragCoord.xy - (iResolution.xy / 2.0));\n\n    float pi = acos(-1.);\n    float period = exp2(6.) * pi;\n    float x = sin(uv.x / period) * period;\n    float y = sin(uv.y / period) * period;\n    float t = .0001 + iTime  / 20000.;\n\n    float power = 5.;\n    float red   = signpower(sin(( x*x+y*y)*t),power);\n    float green = signpower(sin((2.*x*y ) *t),power);\n    float blue  = signpower(sin(( x*x-y*y)*t),power);\n    //float alpha = (sin(x*y*t*sin(x*t)*sin(y*t))+ 1.)/2.;\n\n\n\tfloat avg = (red + blue + green) / 3.;\n    vec3 gray = vec3(avg, 0, avg) * 0.9;\n    //vec3 rbg = vec3(red/1.5, green/2., blue);\n    vec3 r;\n    float mute = 0.9;\n    if(red > 0.) {\n       r = vec3(red, 0, 0);\n    } else {\n       r = vec3(0, -red, -red) * mute;\n    }\n    vec3 g;\n    if(green > 0.) {\n       g = vec3(0, green, 0);\n    } else {\n       g = vec3(-green, 0, -green) * mute;\n    }\n\n    vec3 b;\n    if(blue > 0.) {\n       b = vec3(0, 0, blue);\n    } else {\n       b = vec3(-blue, -blue, 0) * mute;\n    }\n    \n    vec3 color = max(max(r,g),b);//r+g+b;// * vec3(0.9,0.8,1);\n    \n    color = D3DX_SRGB_to_FLOAT(color);\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldfyzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 154], [156, 156, 191, 191, 321], [323, 323, 357, 357, 395], [398, 398, 455, 455, 1603]]}
{"id": "ldfyzl", "name": "Rainier mood", "author": "Zavie", "description": "Improving upon https://www.shadertoy.com/view/XslcWn by avoiding using pixel derivatives (which are shared by 2x2 blocs, thus give an aliased look).\nTo do: fix a glitch between tiles.\n\nClick and drag to change scale.", "tags": ["2d", "rain", "ripple", "hash"], "likes": 185, "viewed": 60861, "published": "Public API", "date": "1489383273", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nA quick experiment with rain drop ripples.\n\nThis effect was written for and used in the launch scene of the\n64kB intro \"H - Immersion\", by Ctrl-Alt-Test.\n\n > http://www.ctrl-alt-test.fr/productions/h-immersion/\n > https://www.youtube.com/watch?v=27PN1SsXbjM\n\n-- \nZavie / Ctrl-Alt-Test\n\n*/\n\n// Maximum number of cells a ripple can cross.\n#define MAX_RADIUS 2\n\n// Set to 1 to hash twice. Slower, but less patterns.\n#define DOUBLE_HASH 0\n\n// Hash functions shamefully stolen from:\n// https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float resolution = 10. * exp2(-3.*iMouse.x/iResolution.x);\n\tvec2 uv = fragCoord.xy / iResolution.y * resolution;\n    vec2 p0 = floor(uv);\n\n    vec2 circles = vec2(0.);\n    for (int j = -MAX_RADIUS; j <= MAX_RADIUS; ++j)\n    {\n        for (int i = -MAX_RADIUS; i <= MAX_RADIUS; ++i)\n        {\n\t\t\tvec2 pi = p0 + vec2(i, j);\n            #if DOUBLE_HASH\n            vec2 hsh = hash22(pi);\n            #else\n            vec2 hsh = pi;\n            #endif\n            vec2 p = pi + hash22(hsh);\n\n            float t = fract(0.3*iTime + hash12(hsh));\n            vec2 v = p - uv;\n            float d = length(v) - (float(MAX_RADIUS) + 1.)*t;\n\n            float h = 1e-3;\n            float d1 = d - h;\n            float d2 = d + h;\n            float p1 = sin(31.*d1) * smoothstep(-0.6, -0.3, d1) * smoothstep(0., -0.3, d1);\n            float p2 = sin(31.*d2) * smoothstep(-0.6, -0.3, d2) * smoothstep(0., -0.3, d2);\n            circles += 0.5 * normalize(v) * ((p2 - p1) / (2. * h) * (1. - t) * (1. - t));\n        }\n    }\n    circles /= float((MAX_RADIUS*2+1)*(MAX_RADIUS*2+1));\n\n    float intensity = mix(0.01, 0.15, smoothstep(0.1, 0.6, abs(fract(0.05*iTime + 0.5)*2.-1.)));\n    vec3 n = vec3(circles, sqrt(1. - dot(circles, circles)));\n    vec3 color = texture(iChannel0, uv/resolution - intensity*n.xy).rgb + 5.*pow(clamp(dot(n, normalize(vec3(1., 0.7, 0.5))), 0., 1.), 6.);\n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldfyzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[440, 594, 616, 616, 738], [740, 740, 761, 761, 880], [882, 882, 939, 939, 2346]]}
{"id": "ldlcRf", "name": "Tribute - Journey!", "author": "Shakemayster", "description": "This is just a tribute, to the greatest game in the world, ah,\nguh fli-goo ga goo buh dee\nOoh guh goo bee, ooh guh guh bee guh guh bee\nFli-goo gee goo, a-fli-guh woo wa mama Lucifer!", "tags": ["clouds", "sky", "character", "tribute", "desert", "journey", "scarf", "sphericalclouds", "traveller", "tomb"], "likes": 546, "viewed": 71356, "published": "Public API", "date": "1489785393", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tBefore you continue reading, feast your eyes on these beautiful Color Schemes (0,1,2)\n*/\n\n// Modify the number to 0,1,2 or 3 and press play button at bottom for different schemes.\n#define COLOR_SCHEME 1\n\n/*\n\tThis shader is just a tribute to \"Journey\" game by That Game Company. Some answers:\n\t1) No, I do not have any affiliation with That Game Company.\n\t2) Yes, Journey is one of the best games ever made\n\t3) It has taken me around 3-4 months from start to finish, evenings and weekends\n\t4) Most of the time was spent getting the details right\n\t5) Yes, the character needs more work. One day I will finish it\n\t6) Yes, if anybody comes up with something cool to add, I would love to improve :)\n\t7) There is nothing mathemagically amazing in this shader. I hope you do find it pretty though!\n\t8) Yes, the code is fairly ugly. But look at the colors - PRETTY!\n\t9) If you have any other questions, I will be happy to answer\n\n\tThis shader started as a learning playground, but around January, I finished my second round of Journey\n\tand thought, well why the hell not, and so here we are.\n\n\tSpecial thanks to Thibault Girard and Jack Hamilton for their artistic input. Also bigs up to Peter Pimley\n\tfor his constant optimism.\n\n\tYou are hereby granted your wish to follow me on twitter: @shakemayster\n\n\tOther authors (With BIG thanks !!!) \n\tDave_Hoskins\n\tDila\n\tMaurogik\n\tFabriceNeyret2\n*/\n\n#define RGB vec3\n#define mul(a,b) b*a\n#define saturate(a) clamp( a, 0.0, 1.0 )\n\n\n#if COLOR_SCHEME == 0\nconst float _FogMul = -0.00100 ;\nconst float _FogPow = 1.82000 ;\nconst float _IncorrectGammaCorrect = 1.00000 ;\nconst vec3 _LightDir = vec3(-0.22632, 0.88099, -0.4155) ;\nconst float _Brightness = 1.00000 ;\nconst float _Contrast = 1.00000 ;\nconst float _Saturation = 1.00000 ;\nconst vec3 _SunStar = vec3(14.7, 1.47, 0.1) ;\nconst float _SunSize = 26.00000 ;\nconst float _SunScale = 15.00000 ;\nconst float _ExposureOffset = 11.10000 ;\nconst float _ExposurePower = 0.52000 ;\nconst float _ExposureStrength = 0.09000 ;\nconst RGB _SunColor = RGB(1, 0.73741, 0.63971) ;\nconst RGB _Zenith = RGB(0.67128, 0.94118, 0.69204) ;\nconst float _ZenithFallOff = 1.42000 ;\nconst RGB _Nadir = RGB(0, 0, 0) ;\nconst float _NadirFallOff = 1.91000 ;\nconst RGB _Horizon = RGB(0.80147, 0.80147, 0.80147) ;\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\nconst RGB _CharacterMainColor = RGB(0.57353, 0.1488, 0.067474) ;\nconst RGB _CharacterTerrainCol = RGB(0.375, 0.21885, 0.15993) ;\nconst RGB _CharacterCloakDarkColor = RGB(0.38971, 0.10735, 0.054444) ;\nconst RGB _CharacterYellowColor = RGB(0.64706, 0.35588, 0) ;\nconst RGB _CharacterWhiteColor = RGB(1, 1, 1) ;\nconst float _CharacterBloomScale = 0.87000 ;\nconst float _CharacterDiffScale = 1.50000 ;\nconst float _CharacterFreScale = 1.77000 ;\nconst float _CharacterFrePower = 3.84000 ;\nconst float _CharacterFogScale = 20.00000 ;\nconst float _CloudTransparencyMul = 0.90000 ;\nconst RGB _CloudCol = RGB(1, 0.96957, 0.88235) ;\nconst RGB _BackCloudCol = RGB(0.66176, 0.64807, 0.62284) ;\nconst RGB _CloudSpecCol = RGB(0.17647, 0.062284, 0.062284) ;\nconst RGB _BackCloudSpecCol = RGB(0.11029, 0.05193, 0.020275) ;\nconst float _CloudFogStrength = 0.50000 ;\nconst RGB _TombMainColor = RGB(0.47735, 0.59559, 0.49705) ;\nconst RGB _TombScarfColor = RGB(0.45588, 0.093858, 0.093858) ;\nconst RGB _PyramidCol = RGB(0.30147, 0.28329, 0.21059) ;\nconst vec2 _PyramidHeightFog = vec2(38.66, 1.05) ;\nconst RGB _TerrainCol = RGB(0.76863, 0.55294, 0.47059) ;\nconst RGB _TerrainSpecColor = RGB(0.32353, 0.32123, 0.31877) ;\nconst float _TerrainSpecPower = 55.35000 ;\nconst float _TerrainSpecStrength = 1.56000 ;\nconst float _TerrainGlitterRep = 7.00000 ;\nconst float _TerrainGlitterPower = 1.94000 ;\nconst RGB _TerrainRimColor = RGB(0, 0, 0) ;\nconst float _TerrainRimPower = 5.59000 ;\nconst float _TerrainRimStrength = 2.00000 ;\nconst float _TerrainRimSpecPower = 1.46000 ;\nconst float _TerrainFogPower = 2.11000 ;\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.28) ;\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\nconst RGB _TerrainShadowColor = RGB(0.40441, 0.34106, 0.31818) ;\nconst RGB _TerrainDistanceShadowColor = RGB(1, 0.81471, 0.74265) ;\nconst float _TerrainDistanceShadowPower = 0.11000 ;\nconst RGB _FlyingHelperMainColor = RGB(0.80882, 0.11671, 0.017842) ;\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\nconst RGB _FlyingHelperYellowColor = RGB(1, 0.56187, 0.0073529) ;\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\nconst float _FlyingHelperBloomScale = 1.91000 ;\nconst float _FlyingHelperFrePower = 1.00000 ;\nconst float _FlyingHelperFreScale = 0.85000 ;\nconst float _FlyingHelperFogScale = 4.00000 ;\n#endif\n\n#if COLOR_SCHEME == 1\nconst float _FogMul = -0.00800 ;\nconst float _FogPow = 1.00000 ;\nconst float _IncorrectGammaCorrect = 1.00000 ;\nconst vec3 _LightDir = vec3(-0.23047, 0.87328, -0.42927) ;\nconst float _Brightness = 0.40000 ;\nconst float _Contrast = 0.83000 ;\nconst float _Saturation = 1.21000 ;\nconst vec3 _SunStar = vec3(14.7, 1.47, 0.1) ;\nconst float _SunSize = 26.00000 ;\nconst float _SunScale = 15.00000 ;\nconst float _ExposureOffset = 11.10000 ;\nconst float _ExposurePower = 0.52000 ;\nconst float _ExposureStrength = 0.09000 ;\nconst RGB _SunColor = RGB(1, 0.95441, 0.77206) ;\nconst RGB _Zenith = RGB(0.77941, 0.5898, 0.41263) ;\nconst float _ZenithFallOff = 2.36000 ;\nconst RGB _Nadir = RGB(1, 0.93103, 0) ;\nconst float _NadirFallOff = 1.91000 ;\nconst RGB _Horizon = RGB(0.96324, 0.80163, 0.38954) ;\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\nconst RGB _CharacterMainColor = RGB(0.60294, 0.1515, 0.062067) ;\nconst RGB _CharacterTerrainCol = RGB(0.35294, 0.16016, 0.12197) ;\nconst RGB _CharacterCloakDarkColor = RGB(0.25735, 0.028557, 0.0056769) ;\nconst RGB _CharacterYellowColor = RGB(0.88971, 0.34975, 0) ;\nconst RGB _CharacterWhiteColor = RGB(0.9928, 1, 0.47794) ;\nconst float _CharacterBloomScale = 0.70000 ;\nconst float _CharacterDiffScale = 1.50000 ;\nconst float _CharacterFreScale = 1.77000 ;\nconst float _CharacterFrePower = 3.84000 ;\nconst float _CharacterFogScale = 4.55000 ;\nconst float _CloudTransparencyMul = 0.90000 ;\nconst RGB _CloudCol = RGB(1, 0.84926, 0.69853) ;\nconst RGB _BackCloudCol = RGB(0.66176, 0.64807, 0.62284) ;\nconst RGB _CloudSpecCol = RGB(0.17647, 0.062284, 0.062284) ;\nconst RGB _BackCloudSpecCol = RGB(0.11029, 0.05193, 0.020275) ;\nconst float _CloudFogStrength = 0.50000 ;\nconst RGB _TombMainColor = RGB(0.64706, 0.38039, 0.27451) ;\nconst RGB _TombScarfColor = RGB(0.38971, 0.10029, 0.10029) ;\nconst RGB _PyramidCol = RGB(0.69853, 0.40389, 0.22086) ;\nconst vec2 _PyramidHeightFog = vec2(38.66, 1.3) ;\nconst RGB _TerrainCol = RGB(0.56618, 0.29249, 0.1915) ;\nconst RGB _TerrainSpecColor = RGB(1, 0.77637, 0.53676) ;\nconst float _TerrainSpecPower = 55.35000 ;\nconst float _TerrainSpecStrength = 1.56000 ;\nconst float _TerrainGlitterRep = 7.00000 ;\nconst float _TerrainGlitterPower = 3.20000 ;\nconst RGB _TerrainRimColor = RGB(0.16176, 0.13131, 0.098724) ;\nconst float _TerrainRimPower = 5.59000 ;\nconst float _TerrainRimStrength = 1.61000 ;\nconst float _TerrainRimSpecPower = 2.88000 ;\nconst float _TerrainFogPower = 2.11000 ;\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.28) ;\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\nconst RGB _TerrainShadowColor = RGB(0.48529, 0.13282, 0) ;\nconst RGB _TerrainDistanceShadowColor = RGB(0.70588, 0.4644, 0.36851) ;\nconst float _TerrainDistanceShadowPower = 0.11000 ;\nconst RGB _FlyingHelperMainColor = RGB(0.85294, 0.11759, 0.012543) ;\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\nconst RGB _FlyingHelperYellowColor = RGB(1, 0.3931, 0) ;\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\nconst float _FlyingHelperBloomScale = 2.61000 ;\nconst float _FlyingHelperFrePower = 1.00000 ;\nconst float _FlyingHelperFreScale = 0.85000 ;\nconst float _FlyingHelperFogScale = 1.75000 ;\n#endif\n\n#if COLOR_SCHEME == 2\nconst float _FogMul = -0.00100 ;\nconst float _FogPow = 1.68000 ;\nconst float _IncorrectGammaCorrect = 1.00000 ;\nconst vec3 _LightDir = vec3(-0.23047, 0.87328, -0.42927) ;\nconst float _Brightness = 0.40000 ;\nconst float _Contrast = 0.82000 ;\nconst float _Saturation = 1.21000 ;\nconst vec3 _SunStar = vec3(14.7, 1.47, 0.1) ;\nconst float _SunSize = 26.00000 ;\nconst float _SunScale = 15.00000 ;\nconst float _ExposureOffset = 11.10000 ;\nconst float _ExposurePower = 0.52000 ;\nconst float _ExposureStrength = 0.09000 ;\nconst RGB _SunColor = RGB(0.97059, 0.97059, 0.97059) ;\nconst RGB _Zenith = RGB(0.98039, 0.83137, 0.53725) ;\nconst float _ZenithFallOff = 2.36000 ;\nconst RGB _Nadir = RGB(0, 0, 0) ;\nconst float _NadirFallOff = 1.91000 ;\nconst RGB _Horizon = RGB(0.84559, 0.77688, 0.6031) ;\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\nconst RGB _CharacterMainColor = RGB(0.60294, 0.1515, 0.062067) ;\nconst RGB _CharacterTerrainCol = RGB(0.5, 0.3404, 0.12868) ;\nconst RGB _CharacterCloakDarkColor = RGB(0.31618, 0.14042, 0.039522) ;\nconst RGB _CharacterYellowColor = RGB(0.64706, 0.30233, 0) ;\nconst RGB _CharacterWhiteColor = RGB(1, 1, 1) ;\nconst float _CharacterBloomScale = 0.87000 ;\nconst float _CharacterDiffScale = 1.50000 ;\nconst float _CharacterFreScale = 1.77000 ;\nconst float _CharacterFrePower = 3.84000 ;\nconst float _CharacterFogScale = 12.47000 ;\nconst float _CloudTransparencyMul = 0.80000 ;\nconst RGB _CloudCol = RGB(0.99216, 0.9451, 0.76471) ;\nconst RGB _BackCloudCol = RGB(0.66176, 0.64807, 0.62284) ;\nconst RGB _CloudSpecCol = RGB(0.17647, 0.062284, 0.062284) ;\nconst RGB _BackCloudSpecCol = RGB(0.11029, 0.05193, 0.020275) ;\nconst float _CloudFogStrength = 0.50000 ;\nconst RGB _TombMainColor = RGB(0.94118, 0.82759, 0.45675) ;\nconst RGB _TombScarfColor = RGB(0.44118, 0.19989, 0.14922) ;\nconst RGB _PyramidCol = RGB(0.92647, 0.73579, 0.3338) ;\nconst vec2 _PyramidHeightFog = vec2(38.66, 4.65) ;\nconst RGB _TerrainCol = RGB(0.71324, 0.5076, 0.236) ;\nconst RGB _TerrainSpecColor = RGB(0.32353, 0.32123, 0.31877) ;\nconst float _TerrainSpecPower = 55.35000 ;\nconst float _TerrainSpecStrength = 0.03000 ;\nconst float _TerrainGlitterRep = 7.00000 ;\nconst float _TerrainGlitterPower = 3.20000 ;\nconst RGB _TerrainRimColor = RGB(0, 0, 0) ;\nconst float _TerrainRimPower = 5.59000 ;\nconst float _TerrainRimStrength = 1.61000 ;\nconst float _TerrainRimSpecPower = 0.38000 ;\nconst float _TerrainFogPower = 2.11000 ;\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.28) ;\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\nconst RGB _TerrainShadowColor = RGB(0.66912, 0.52969, 0.369) ;\nconst RGB _TerrainDistanceShadowColor = RGB(1, 0.75466, 0.43382) ;\nconst float _TerrainDistanceShadowPower = 0.11000 ;\nconst RGB _FlyingHelperMainColor = RGB(0.91912, 0.30412, 0.21626) ;\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\nconst RGB _FlyingHelperYellowColor = RGB(0.98529, 0.60477, 0.12316) ;\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\nconst float _FlyingHelperBloomScale = 1.91000 ;\nconst float _FlyingHelperFrePower = 1.00000 ;\nconst float _FlyingHelperFreScale = 0.85000 ;\nconst float _FlyingHelperFogScale = 4.00000 ;\n#endif\n\n#if COLOR_SCHEME == 3\nconst float _FogMul = -0.00100 ;\nconst float _FogPow = 1.82000 ;\nconst float _IncorrectGammaCorrect = 1.00000 ;\nconst vec3 _LightDir = vec3(-0.29644, 0.6859, -0.66458) ;\nconst float _Brightness = 1.00000 ;\nconst float _Contrast = 1.00000 ;\nconst float _Saturation = 1.00000 ;\nconst vec3 _SunStar = vec3(20.45, 1.49, 0.5) ;\nconst float _SunSize = 26.09000 ;\nconst float _SunScale = 15.04000 ;\nconst float _ExposureOffset = 13.72000 ;\nconst float _ExposurePower = 0.60000 ;\nconst float _ExposureStrength = 0.02000 ;\nconst RGB _SunColor = RGB(0.51471, 0.79919, 1) ;\nconst RGB _Zenith = RGB(0, 0.053922, 0.16176) ;\nconst float _ZenithFallOff = 1.42000 ;\nconst RGB _Nadir = RGB(0.21569, 0.2549, 0.36078) ;\nconst float _NadirFallOff = 1.91000 ;\nconst RGB _Horizon = RGB(0.35191, 0.30223, 0.47794) ;\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\nconst RGB _CharacterMainColor = RGB(0.36765, 0.097656, 0.045956) ;\nconst RGB _CharacterTerrainCol = RGB(0.083261, 0.11379, 0.16176) ;\nconst RGB _CharacterCloakDarkColor = RGB(0.073529, 0.011604, 0) ;\nconst RGB _CharacterYellowColor = RGB(0.60294, 0.33162, 0) ;\nconst RGB _CharacterWhiteColor = RGB(1, 1, 1) ;\nconst float _CharacterBloomScale = 0.87000 ;\nconst float _CharacterDiffScale = 1.50000 ;\nconst float _CharacterFreScale = 1.77000 ;\nconst float _CharacterFrePower = 19.83000 ;\nconst float _CharacterFogScale = 60.00000 ;\nconst float _CloudTransparencyMul = 0.90000 ;\nconst RGB _CloudCol = RGB(0.0069204, 0.15969, 0.23529) ;\nconst RGB _BackCloudCol = RGB(0, 0.10969, 0.15441) ;\nconst RGB _CloudSpecCol = RGB(0.11765, 0.11765, 0.11765) ;\nconst RGB _BackCloudSpecCol = RGB(0.080882, 0.080882, 0.080882) ;\nconst float _CloudFogStrength = 0.50000 ;\nconst RGB _TombMainColor = RGB(0.23789, 0.27707, 0.40441) ;\nconst RGB _TombScarfColor = RGB(0.066176, 0, 0.034229) ;\nconst RGB _PyramidCol = RGB(0, 0, 0) ;\nconst vec2 _PyramidHeightFog = vec2(38.66, 1.92) ;\nconst RGB _TerrainCol = RGB(0, 0.058832, 0.10294) ;\nconst RGB _TerrainSpecColor = RGB(0.24622, 0.29188, 0.33824) ;\nconst float _TerrainSpecPower = 55.35000 ;\nconst float _TerrainSpecStrength = 1.56000 ;\nconst float _TerrainGlitterRep = 7.00000 ;\nconst float _TerrainGlitterPower = 1.94000 ;\nconst RGB _TerrainRimColor = RGB(0.091021, 0.057093, 0.16176) ;\nconst float _TerrainRimPower = 5.59000 ;\nconst float _TerrainRimStrength = 2.00000 ;\nconst float _TerrainRimSpecPower = 1.46000 ;\nconst float _TerrainFogPower = 2.11000 ;\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.37) ;\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\nconst RGB _TerrainShadowColor = RGB(0.11029, 0.11029, 0.11029) ;\nconst RGB _TerrainDistanceShadowColor = RGB(0.0034061, 0.073181, 0.15441) ;\nconst float _TerrainDistanceShadowPower = 0.06000 ;\nconst RGB _FlyingHelperMainColor = RGB(0.12661, 0.004109, 0.13971) ;\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\nconst RGB _FlyingHelperYellowColor = RGB(0.48529, 0.2711, 0) ;\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\nconst float _FlyingHelperBloomScale = 1.91000 ;\nconst float _FlyingHelperFrePower = 1.00000 ;\nconst float _FlyingHelperFreScale = 0.85000 ;\nconst float _FlyingHelperFogScale = 5.51000 ;\n#endif\n\n//==========================================================================================\n// Play with these at your own risk. Expect, unexpected results!\n//==========================================================================================\n\nconst mat4 _CameraInvViewMatrix = mat4( 1, 0, 0, 1.04, \n0, 0.9684963, 0.2490279, 2.2, \n0, 0.2490279, -0.9684963, 18.6, \n0, 0, 0, 1 ) ;\nconst vec3 _CameraFOV = vec3(1.038, 0.78984, -1) ;\nconst vec3 _CameraPos = vec3(1.0, 2.2, 18.6) ;\nconst vec4 _CameraMovement = vec4(0.15, 0.1, 0.2, 0.25) ;\n\nconst vec3 _WindDirection = vec3(-0.27, -0.12, 0) ;\n\nconst float _DrawDistance = 70.00000 ;\nconst float _MaxSteps = 64.00000 ;\n\nconst vec3 _SunPosition = vec3(0.2, 56, -40.1) ;\nconst float _CharacterRotation = 0.17000 ;\nconst vec3 _CharacterPosition = vec3(0.52, 2.35, 17.6) ;\nconst vec3 _CharacterScale = vec3(0.4, 0.53, 0.38) ;\nconst float _MainClothRotation = 0.30000 ;\nconst vec3 _MainClothScale = vec3(0.3, 0.68, 0.31) ;\nconst vec3 _MainClothPosition = vec3(0, -0.12, 0) ;\nconst vec3 _MainClothBotCutPos = vec3(0, -0.52, 0) ;\nconst vec3 _MainClothDetail = vec3(6, 0.04, 1.3) ;\nconst float _HeadScarfRotation = -0.19000 ;\nconst vec3 _HeadScarfPosition = vec3(-0.005, -0.16, -0.01) ;\nconst vec3 _HeadScarfScale = vec3(0.18, 0.2, 0.03) ;\nconst float _HeadRotationX = -0.30000 ;\nconst float _HeadRotationY = 0.29000 ;\nconst float _HeadRotationZ = 0.00000 ;\nconst vec3 _HeadPos = vec3(0, -0.04, 0.01) ;\nconst vec3 _LongScarfPos = vec3(0.01, -0.15, 0.09) ;\nconst vec3 _LongScarfScale = vec3(0.05, 1.25, 0.001) ;\nconst vec4 _LongScarfWindStrength = vec4(0.3, 4.52, 5.2, 0.02) ;\nconst float _LongScarfRotX = 1.43000 ;\nconst float _LongScarfMaxRad = 1.99000 ;\nconst vec3 _FacePosition = vec3(0, -0.01, 0.05) ;\nconst vec3 _FaceSize = vec3(0.038, 0.05, 0.03) ;\nconst vec3 _UpperLeftLegA = vec3(-0.02, -0.37, 0.01) ;\nconst vec3 _UpperLeftLegB = vec3(-0.02, -0.67, -0.059999) ;\nconst vec3 _UpperLeftLegParams = vec3(0.026, 1, 1) ;\nconst vec3 _LowerLeftLegA = vec3(-0.02, -0.67, -0.059999) ;\nconst vec3 _LowerLeftLegB = vec3(-0.02, -0.77, 0.12) ;\nconst vec3 _LowerLeftLegParams = vec3(0.028, 0.03, 0.01) ;\nconst vec3 _UpperRightLegA = vec3(0.07, -0.5, 0.02) ;\nconst vec3 _UpperRightLegB = vec3(0.07, -0.61, 0.09) ;\nconst vec3 _UpperRightLegParams = vec3(0.026, 1, 1) ;\nconst vec3 _LowerRightLegA = vec3(0.07, -0.61, 0.09) ;\nconst vec3 _LowerRightLegB = vec3(0.07, -0.91, 0.22) ;\nconst vec3 _LowerRightLegParams = vec3(0.028, 0.03, 0.01) ;\nconst vec3 _BodyPos = vec3(0, -0.45, -0.03) ;\nconst vec3 _CharacterTrailOffset = vec3(0.72, 0.01, 0.06) ;\nconst vec3 _CharacterTrailScale = vec3(0.001, 0, 0.5) ;\nconst vec3 _CharacterTrailWave = vec3(1.97, 0, 0.34) ;\nconst vec2 _CharacterHeightTerrainMix = vec2(1.95, -30) ;\nconst vec3 _CloudNoiseStrength = vec3(0.2, 0.16, 0.1) ;\nconst vec3 _FrontCloudsPos = vec3(9.91, 8.6, -12.88) ;\nconst vec3 _FrontCloudsOffsetA = vec3(-9.1, 3.04, 0) ;\nconst vec3 _FrontCloudsOffsetB = vec3(-2.97, 3.72, -0.05) ;\nconst vec3 _FrontCloudParams = vec3(5.02, 3.79, 5) ;\nconst vec3 _FrontCloudParamsA = vec3(3.04, 0.16, 2) ;\nconst vec3 _FrontCloudParamsB = vec3(1.34, 0.3, 3.15) ;\nconst vec3 _BackCloudsPos = vec3(29.99, 13.61, -18.8) ;\nconst vec3 _BackCloudsOffsetA = vec3(24.87, -1.49, 0) ;\nconst vec3 _BackCloudParams = vec3(7.12, 4.26, 1.68) ;\nconst vec3 _BackCloudParamsA = vec3(6.37, 2.23, 2.07) ;\nconst vec3 _PlaneParams = vec3(7.64, 10.85, 3.76) ;\nconst vec3 _CloudGlobalParams = vec3(0.123, 2.1, 0.5) ;\nconst vec3 _CloudBackGlobalParams = vec3(0.16, 1.4, -0.01) ;\nconst vec3 _CloudNormalMod = vec3(0.26, -0.13, 1.22) ;\nconst float _CloudSpecPower = 24.04000 ;\nconst float _CloudPyramidDistance = 0.14500 ;\nconst vec3 _TombPosition = vec3(5, 5, 9.28) ;\nconst vec3 _TombScale = vec3(0.07, 0.5, 0.006) ;\nconst vec3 _TombBevelParams = vec3(0.44, 0.66, 0.01) ;\nconst float _TombRepScale = 0.79000 ;\nconst vec3 _TombCutOutScale = vec3(0.39, 0.06, -14.92) ;\nconst vec3 _TombScarfOffset = vec3(0, 0.46, 0) ;\nconst vec3 _TombScarfWindParams = vec3(-1.61, 6, 0.05) ;\nconst vec3 _TombScarfScale = vec3(0.03, 0.002, 0.5) ;\nconst float _TombScarfRot = -0.88000 ;\nconst mat4 _TombScarfMat = mat4( 0.9362437, 0, -0.3513514, 0, \n0, 1, 0, 0, \n0.3513514, 0, 0.9362437, 0, \n0, 0, 0, 1 ) ;\nconst vec3 _PyramidPos = vec3(0, 10.9, -50) ;\nconst vec3 _PyramidScale = vec3(34.1, 24.9, 18) ;\nconst vec3 _PrismScale = vec3(1, 1.9, 1) ;\nconst vec3 _PyramidNoisePrams = vec3(1.5, 1, 1) ;\nconst vec3 _PrismEyeScale = vec3(0.7, 1.9, 51.5) ;\nconst vec3 _PyramidEyeOffset = vec3(2.0, -4.9, 0) ;\nconst float _PrismEyeWidth = 5.86000 ;\nconst float _TerrainMaxDistance = 30.04000 ;\nconst float _SmallDetailStrength = 0.00600 ;\nconst vec3 _SmallWaveDetail = vec3(3.19, 16, 6.05) ;\nconst vec2 _WindSpeed = vec2(2, 0.6) ;\nconst float _MediumDetailStrength = 0.05000 ;\nconst vec2 _MediumWaveDetail = vec2(2, 50) ;\nconst vec3 _MediumWaveOffset = vec3(0.3, -2, 0.1) ;\nconst vec2 _LargeWaveDetail = vec2(0.25, 0.73) ;\nconst vec3 _LargeWavePowStre = vec3(0.6, 2.96, -2.08) ;\nconst vec3 _LargeWaveOffset = vec3(-3.65, 4.41, -11.64) ;\nconst vec3 _FlyingHelperPos = vec3(2.15, 4.68, 14.4) ;\nconst vec3 _FlyingHelperScale = vec3(0.25, 0.001, 0.3) ;\nconst vec3 _FlyingHelperMovement = vec3(0.44, 1.44, -2.98) ;\nconst vec3 _FlyingHelperScarfScale = vec3(0.1, 0.001, 1.5) ;\nconst vec3 _FlyingHelperScarfWindParams = vec3(-0.06, 0.31, 0.47) ;\nconst vec3 _FlyingHelperScarfWindDetailParams = vec3(3.93, 0.005, -45.32) ;\nconst vec3 _FlyingHelperSideScarfOffset = vec3(0.16, -0.01, 0) ;\nconst vec3 _FlyingHelperSideScarfScale = vec3(0.06, 0.001, 0.8) ;\nconst vec4 _FlyingScarfSideWindParams = vec4(2.46, -1.59, -0.05, 0.21) ;\n\n// Material ID definitions\n#define MAT_PYRAMID 1.0\n\n#define MAT_TERRAIN 10.0\n#define MAT_TERRAIN_TRAIL 11.0\n\n#define MAT_BACK_CLOUDS 20.0\n#define MAT_FRONT_CLOUDS 21.0\n\n#define MAT_TOMB 30.0\n#define MAT_TOMB_SCARF 31.0\n\n#define MAT_FLYING_HELPERS 40.0\n#define MAT_FLYING_HELPER_SCARF 41.0\n\n#define MAT_CHARACTER_BASE 50.0\n#define MAT_CHARACTER_MAIN_CLOAK 51.0\n#define MAT_CHARACTER_NECK_SCARF 52.0\n#define MAT_CHARACTER_LONG_SCARF 53.0\n#define MAT_CHARACTER_FACE 54.0\n\n#define TEST_MAT_LESS( a, b ) a < (b + 0.1)\n#define TEST_MAT_GREATER( a, b ) a > (b - 0.1)\n\n//==========================================================================================\n// Primitive functions by IQ\n//==========================================================================================\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n\treturn length( max( abs(p) - b, 0.0) ) - r;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) +\n\t\tlength(max(d, 0.0));\n}\n\nfloat sdCylinder(vec3 p, vec2 h)\n{\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - h;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n\t// n must be normalized\n\treturn dot(p, n.xyz) + n.w;\n}\n\nvec2 sdSegment( in vec3 p, vec3 a, vec3 b )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r)\n{\n\treturn (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\n//==========================================================================================\n// distance field operations\n//==========================================================================================\nvec2 min_mat( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 smin_mat( vec2 a, vec2 b, float k, float c )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    float x = mix( b.x, a.x, h ) - k*h*(1.0-h);\n    return vec2( x, ( h < c ) ? b.y : a.y);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n//==========================================================================================\n// Rotations\n//==========================================================================================\nvoid rX(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.y = c * q.y - s * q.z;\n    p.z = s * q.y + c * q.z;\n}\n\nvoid rY(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x + s * q.z;\n    p.z = -s * q.x + c * q.z;\n}\n\nvoid rZ(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x + s * q.y;\n    p.y = -s * q.x + c * q.y;\n}\n\n//==========================================================================================\n// Value noise and its derivatives: https://www.shadertoy.com/view/MdX3Rr\n//==========================================================================================\nvec3 noised( in vec2 x )\n{\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\n#if 0\n    // texel fetch version\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\n#else    \n    // texture version    \n    vec2 p = floor(x);\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\n#endif\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\n//==========================================================================================\n// Noise function: https://www.shadertoy.com/view/4sfGRH \n//==========================================================================================\nfloat pn(vec3 p) {\n    vec3 i = floor(p); \n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n    vec3 f = cos((p-i)*3.141592653589793)*(-.5) + .5;  \n\ta = mix(sin(cos(a)*a), sin(cos(1.+a)*(1.+a)), f.x);\n    a.xy = mix(a.xz, a.yw, f.y);   \n\treturn mix(a.x, a.y, f.z);\n}\n\n//==========================================================================================\n// Sin Wave approximation http://http.developer.nvidia.com/GPUGems3/gpugems3_ch16.html\n//==========================================================================================\nvec4  SmoothCurve( vec4 x ) {  \n  return x * x * ( 3.0 - 2.0 * x );  \n}\n\nvec4 TriangleWave( vec4 x ) {  \n  return abs( fract( x + 0.5 ) * 2.0 - 1.0 );  \n}\n\nvec4 SmoothTriangleWave( vec4 x ) {  \n  return SmoothCurve( TriangleWave( x ) );  \n}  \n\nfloat SmoothTriangleWave( float x )\n{\n  return SmoothCurve( TriangleWave( vec4(x,x,x,x) ) ).x;  \n}  \n\nvoid Bend(inout vec3 vPos, vec2 vWind, float fBendScale)\n{\n\tfloat fLength = length(vPos);\n\tfloat fBF = vPos.y * fBendScale;  \n\tfBF += 1.0;  \n\tfBF *= fBF;  \n\tfBF = fBF * fBF - fBF;  \n\tvec3 vNewPos = vPos;  \n\tvNewPos.xz += vWind.xy * fBF;  \n\tvPos.xyz = normalize(vNewPos.xyz)* fLength;  \n}\n\n//==========================================================================================\n// Modified cone versions for scarf and main cloak\n//==========================================================================================\nfloat sdScarfCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = (p.y - h);\n    float si = 0.5*(r1-r2)/h;\n    p.z = mix(p.z, p.z * 0.2, q);\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nvec2 sdCloakCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = (p.y - h);\n    r2 = (q * r2) + 0.08;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return vec2(length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.), q);\n}\n\n//==========================================================================================\n// Character\n//==========================================================================================\nvec3 headScarfMatUVW;\nfloat sdHeadScarf(vec3 pos)\n{\n\t\n    vec3 headScarfPos = pos - _HeadScarfPosition;\n    rX( headScarfPos, _HeadScarfRotation );\n\n    float distanceToTop =  min(0.0,(pos.y + 0.01));\n\n    // Put a slight twist in the middle. Gives the feel that the head scarf\n    // is sitting on shoulders. Very subtle, but I can see it :D\n    float midBend = abs( fract( distanceToTop + 0.5 ) * 2.0 - 1.0 );\n    headScarfPos.x += (cos( 2.0 + headScarfPos.y * 50.0 ) * 0.05 * midBend);\n    headScarfPos.z += (sin( 2.0 + headScarfPos.y * 50.0 ) * 0.03 * midBend);\n\n    // Apply wind to head Scarf    \n    headScarfPos += SmoothTriangleWave(vec4(pos.xyz * 5.0+ iTime,1.0) ).xyz * 0.05 * distanceToTop;\n\n    // Scarf shape    \n    float headScarf = sdScarfCone(headScarfPos, _HeadScarfScale.x, _HeadScarfScale.y, _HeadScarfScale.z );\n    headScarf = max(headScarf, -sdScarfCone(headScarfPos, _HeadScarfScale.x, _HeadScarfScale.y, _HeadScarfScale.z - 0.011));\n    \n    // Cut out the bottom of the head scarf. I have no idea what I was thinking, when I wrote this\n    vec3 cutOutPos = headScarfPos - vec3( 0.0, 0.08, 0.0);\n    vec3 r = vec3(0.12, 0.8, 0.2);\n    float smallestSize = min(min(r.x,r.y),r.z);\n\tvec3 dp = cutOutPos/r;\n    float h = min(1.0, abs(1.0 - abs(dp.y)) );\n\n    // Apply some crazy power until it looks like a scarf sitting on shoulders\n    h =  pow(h, 5.5);\n    \n    float rad = h ;\n    float d = length( cutOutPos/r );\n    \n    float cutOut = (d - rad) * smallestSize;\n    headScarf\t= max(headScarf, cutOut);\n\n    // material information\n    float materialVal = 1.0 - pow(d - rad, 0.02);\n\theadScarfMatUVW = smoothstep( -1.0, 1.0, materialVal / _HeadScarfScale);\n\n\t// Chop the top off, to make room for head\n    vec3 headPos = pos - vec3(0.0, 0.25, 0.0);\n    float head   = sdBox(headPos, vec3(0.2, 0.19, 0.2)); \n    headScarf = max(headScarf, -head);\n    \n    return headScarf;\n}\nvec3 mainCloakMatUVW;\nfloat sdMainCloak(vec3 pos)\n{\n    vec3 cloakPos = pos - _MainClothPosition;\n    float q =  min(0.0,(cloakPos.y + 0.05));\n    rX( cloakPos, _MainClothRotation );\n    \n    // Apply detailing\n    cloakPos += SmoothTriangleWave(vec4(pos.xyz * _MainClothDetail.x + iTime,1.0) ).xyz * _MainClothDetail.y * q;\n    \n    // Add main Wind direction\n    Bend(cloakPos, _WindDirection.xy, _MainClothDetail.z);\n    \n    vec2 cloak = sdCloakCone( cloakPos, _MainClothScale.y, _MainClothScale.x, _MainClothScale.z);\n    // Cut out the internals of the cloak\n    cloak.x = max( cloak.x, -sdCloakCone( cloakPos, _MainClothScale.y * 1.05, _MainClothScale.x * 0.95, _MainClothScale.z * 1.01).x);\n\n    // UV Information\n    mainCloakMatUVW = smoothstep( -1.0, 1.0, cloakPos / _MainClothScale);\n\n    // Cut out the top section\n    vec3 headPos = cloakPos - vec3(0.0, 0.69, 0.0);\n    float head   = sdBox(headPos, vec3(0.2, 0.67, 0.2)); \n\tcloak.x = max(cloak.x, -head);\n    \n    // Cut the bottom\n    float bottomCut   = sdPlane(cloakPos - _MainClothBotCutPos); \n    cloak.x = max(cloak.x, -bottomCut);\n    \n    return cloak.x;\n}\n\nfloat earWigs(in vec3 pos) \n{   \n\t// Symmetrical ear wigs. Is that even a word... Ear Wigs!\n    pos.x = abs(pos.x);\n\n    vec2  earWig = sdSegment( pos, vec3(0.02, 0.11, 0.0), vec3(0.07, 0.16, 0.05));\n    float ear  = earWig.x - 0.026  + (earWig.y * 0.03);\n    return ear;\n}\n\n\nfloat sdHead( vec3 pos )\n{\n    vec3 headPos = pos - _HeadPos;\n\n    // Slight tilt\n    rY(headPos, _HeadRotationY ); // 1.2\n    rX(headPos, _HeadRotationX );\n\n    float head = sdCylinder( headPos, vec2(0.05, 0.13) );\n    head = smin(earWigs(headPos), head, 0.04 );\n    return head;\n}\n\nvec3 longScarfMatUVW;\nfloat sdScarf(vec3 pos) \n{\n    vec3 scarfPos = pos - _LongScarfPos;\n    vec3 scale \t= _LongScarfScale;\n\n\n    float distanceToPoint = max(0.0,length(scarfPos) - 0.04);\n    scarfPos.x += (sin( scarfPos.z * _LongScarfWindStrength.x + iTime ) * 0.1 * distanceToPoint);\n    scarfPos.y += (sin( scarfPos.z * _LongScarfWindStrength.y + iTime ) * 0.1 * distanceToPoint);\n\n    // Apply detailing\n    scarfPos += SmoothTriangleWave(vec4(pos.xyz * _LongScarfWindStrength.z + iTime,1.0) ).xyz * _LongScarfWindStrength.w * distanceToPoint;\n\n    // Essentially a box pivoted at a specific point\n    vec3 scarfOffset = vec3(0.0, 0.0, -scale.y);\n\n    rX(scarfPos, _LongScarfRotX) ;\n    float scarf = sdBox(scarfPos - scarfOffset.xzy , scale);\n\n    longScarfMatUVW = smoothstep(-1.0, 1.0, ( scarfPos - scarfOffset.xzy ) / scale);\n\n    return max(scarf, sdSphere( scarfPos, _LongScarfMaxRad ));\n}\n\nfloat sdLegs( in vec3 pos  )\n{\n    vec2  upperLeftLeg = sdSegment( pos, _UpperLeftLegA, _UpperLeftLegB );\n    float leftLeg  = upperLeftLeg.x - _UpperLeftLegParams.x;\n    vec2 lowerLeftLeg = sdSegment( pos, _LowerLeftLegA, _LowerLeftLegB );\n    leftLeg  = smin( leftLeg, lowerLeftLeg.x - _LowerLeftLegParams.x + (lowerLeftLeg.y * _LowerLeftLegParams.y), _LowerLeftLegParams.z);\n\n    // cut bottom of left leg otherwise looks nasty with harsh tip\n    leftLeg = max( leftLeg, -(length( pos - _LowerLeftLegB) - 0.06 ) );\n\n    vec2  upperRightLeg = sdSegment( pos, _UpperRightLegA, _UpperRightLegB );\n    float rightLeg  = upperRightLeg.x - _UpperRightLegParams.x;\n    vec2 lowerRightLeg = sdSegment( pos, _LowerRightLegA, _LowerRightLegB );\n    rightLeg  = smin( rightLeg, lowerRightLeg.x - _LowerRightLegParams.x + (lowerRightLeg.y * _LowerRightLegParams.y), _LowerRightLegParams.z);\n\n    return min( leftLeg, rightLeg );\n}\n\nvec2 sdFace( vec3 pos, vec2 currentDistance )\n{\n    vec3 headPos = pos - vec3(0.0, -0.05, 0.0);\n    rX( headPos, _HeadRotationX );\n    rY(headPos, _HeadRotationY );\n\n    // head hole - Fire in the hole!    \n    // OK this does not look right. Actually looks like there was \"fire in the hole\" for \n    // the poor travellers face. Need to come back to it one day and finish it. Maybe!\n    vec3 headHole = headPos - vec3(0.0, 0.1, -0.07);\n    float hole = sdEllipsoid( headHole,vec3(0.05, 0.03, 0.04) );\n    hole  = smin ( hole, sdEllipsoid( headHole - vec3(0.0, -0.03, 0.0), vec3(0.03,0.03, 0.04)), 0.05 );\n\n    // Cut it OUT!\n    float character =  smax( currentDistance.x, -hole, 0.001);\n\n    // face. Meh just an ellipsoid. Need to add eyes and bandana\n    float face = sdEllipsoid( headHole - _FacePosition.xyz, _FaceSize );\n    return smin_mat( vec2(face, MAT_CHARACTER_FACE), vec2(character,currentDistance.y), 0.01, 0.2 );\n}\n\nvec2 sdCharacter( vec3 pos )\n{\n    // Now we are in character space - Booo YA! - I never ever say Boooo YA!. Peter Pimley \n    // says that. Peter: have you been putting comments in my code?\n    pos -= _CharacterPosition;\n    vec3 scale = _CharacterScale;\n    float scaleMul = min(scale.x, min(scale.y, scale.z));\n    \n    rY(pos, _CharacterRotation);\n\n    pos /= scale;\n\n    float mainCloak = sdMainCloak( pos );\n    vec2  mainCloakMat = vec2(mainCloak, MAT_CHARACTER_MAIN_CLOAK );\n\n    float headScarf = sdHeadScarf(pos);\n    vec2  headScarfMat = vec2(headScarf, MAT_CHARACTER_NECK_SCARF );\n\n    float longScarf = sdScarf(pos);\n    vec2  longScarfMat = vec2( longScarf, MAT_CHARACTER_LONG_SCARF );\n    headScarfMat = smin_mat( headScarfMat, longScarfMat, 0.02, 0.1 );\n\n    float head      = sdHead( pos );\n    vec2  headMat\t= vec2( head, MAT_CHARACTER_BASE );\n    headScarfMat    = smin_mat(headScarfMat, headMat, 0.05, 0.75);\n\n    vec2  characterMat = min_mat(mainCloakMat, headScarfMat); \n    characterMat = sdFace( pos, characterMat );\n\n    vec2 legsMat = vec2( sdLegs(pos), MAT_CHARACTER_BASE );\n    characterMat = min_mat( characterMat, legsMat );\n\n    // chope the bottom. This is to chop the bottom of right leg. Though\n    // I have positioned the character so that the right leg is hidden by terrain. \n    // Commenting it out for now\n//    characterMat.x = max( characterMat.x, -sdPlane( pos - vec3(0.0, -0.85, 0.0) ) );\n    characterMat.x *= scaleMul;\n\n\n    return characterMat;\n}\n\n//==========================================================================================\n// Clouds\n//==========================================================================================\nfloat sdCloud( in vec3 pos, vec3 cloudPos, float rad, float spread, float phaseOffset, vec3 globalParams)\n{ \n\t// Clouds are simple. A bunch of spheres with varying phase offset, size and \n\t// frequency values. They are also scaled along the z-Axis so more like circles\n\t// than spheres. With additional noise to make them look fluffy. \n\t// While rendering them we \"perturb\" #SpellCheck the normals to get strong specular\n\t// highlights\n\n\t// Add noise to the clouds\n\tpos += pn( pos ) * _CloudNoiseStrength;\n\tpos = pos - cloudPos;\n\n\t// Make us 2d-ish - My artists have confirmed me: 2D is COOL!\n\tpos.z /= globalParams.x;\n\n\t// Repeat the space\n\tfloat repitition = rad * 2.0 + spread;\n\tvec3  repSpace = pos - mod( pos - repitition * 0.5, repitition);\n\n\t// Create the overall shape to create clouds on\n\tpos.y +=  sin(phaseOffset + repSpace.x * 0.23  )  * globalParams.y ;\n\n\t// Creates clouds with offset on the main path\n\tpos.y +=  sin(phaseOffset + repSpace.x * 0.9 ) * globalParams.z;\n\n\t// repeated spheres\n\tpos.x = fract( (pos.x + repitition * 0.5) / repitition ) * repitition - repitition * 0.5;\n\n\t// return the spheres  \n\tfloat sphere = length(pos)- rad;\n\treturn sphere * globalParams.x;\n}\n\nvec2 sdClouds( in vec3 pos )\n{\n\t// Two layers of clouds. A layer in front of the big pyramid\n    float c1 = sdCloud( pos, _FrontCloudsPos, _FrontCloudParams.x, _FrontCloudParams.y, _FrontCloudParams.z, _CloudGlobalParams );\n    float c2 = sdCloud( pos, _FrontCloudsPos + _FrontCloudsOffsetA, _FrontCloudParamsA.x, _FrontCloudParamsA.y, _FrontCloudParamsA.z, _CloudGlobalParams );\n    float c3 = sdCloud( pos, _FrontCloudsPos + _FrontCloudsOffsetB, _FrontCloudParamsB.x, _FrontCloudParamsB.y, _FrontCloudParamsB.z, _CloudGlobalParams);\n    float frontClouds = min(c3, min(c1, c2));\n\n    // This plane hides the empty spaces between the front cloud spheres. Not needed\n    // for back spheres, they are covered by front spheres\n  \tfloat mainPlane = length(pos.z - _FrontCloudsPos.z) / _CloudGlobalParams.x + (pos.y - _PlaneParams.y  + sin(_PlaneParams.x + pos.x * 0.23 ) * _PlaneParams.z);// - rad;\n  \tfrontClouds = min(mainPlane * _CloudGlobalParams.x, frontClouds);\n\n\t// Second layer behind the big Pyramid\n    float c4 = sdCloud( pos, _BackCloudsPos, _BackCloudParams.x, _BackCloudParams.y, _BackCloudParams.z, _CloudBackGlobalParams );\n    float c5 = sdCloud( pos, _BackCloudsPos + _BackCloudsOffsetA, _BackCloudParamsA.x, _BackCloudParamsA.y, _BackCloudParamsA.z, _CloudBackGlobalParams );\n    float backClouds = min(c4,c5);\n    return min_mat(vec2(frontClouds,MAT_FRONT_CLOUDS), vec2(backClouds,MAT_BACK_CLOUDS));\n}\n\n//==========================================================================================\n// This should really be called Kites. No such thing as Flying Helplers...\n//==========================================================================================\nvec3 helperScarfMatUVW;\nfloat sdHelperScarf(vec3 pos, vec3 scarfOffset, vec3 originalPos ) \n{\n    vec3 scarfPos = pos - scarfOffset;\n\n    vec3 scale = _FlyingHelperScarfScale;\n\n    // How far are we from pivot of scarf\n    float distanceToPoint = length(scarfPos );\n\n    // Apply some motion\n    scarfPos += SmoothTriangleWave(vec4(pos.xyz * _FlyingHelperScarfWindDetailParams.x + iTime,1.0) ).xyz * _FlyingHelperScarfWindDetailParams.y * distanceToPoint;\n\n    vec2 wave;\n    wave.x = SmoothTriangleWave( scarfPos.z * _FlyingHelperScarfWindParams.x  );\n    wave.y = SmoothTriangleWave( scarfPos.z * _FlyingHelperScarfWindParams.z  );\n\n    scarfPos.xy += ( wave * _FlyingHelperScarfWindParams.y * distanceToPoint);\n    vec3  pivotOffset = vec3(0.0, 0.0, scale.z);\n    float scarf = sdBox(scarfPos - pivotOffset, scale);\n\n    // Move us along the z-axis because we chop a sphere in the box. Shows borders otherwise\n    vec3 UVWOffset = vec3(0.0, 0.0, 1.0);\n    helperScarfMatUVW = smoothstep(-1.0, 1.0, ( scarfPos + UVWOffset - pivotOffset.xzy ) / scale);\n\n    // Two scarf on each side of the big'un\n    pivotOffset.z = _FlyingHelperSideScarfScale.z;\n\n\twave.y = originalPos.x > 0.0 ? wave.y * _FlyingScarfSideWindParams.x : wave.y * _FlyingScarfSideWindParams.y;\n\tscarfPos.xy += scarfPos.x > 0.0 ? wave * _FlyingScarfSideWindParams.z : wave * _FlyingScarfSideWindParams.w;\n\n\t// legit mirroring!\n\tscarfPos.x = -abs(scarfPos.x);\n\tfloat sideScarfs = sdBox(scarfPos - pivotOffset + _FlyingHelperSideScarfOffset, _FlyingHelperSideScarfScale);\n\n\t// Just override the helperScarfMatUVW value for side scarfs. Too tired to create another variable and use that, not too tired\n\t// to write this long comment of no value\n    helperScarfMatUVW = scarf < sideScarfs ? helperScarfMatUVW : smoothstep(-1.0, 1.0, ( scarfPos - pivotOffset + _FlyingHelperSideScarfOffset ) / _FlyingHelperSideScarfScale);\n\n    // Combine'em\n    scarf = min( scarf, sideScarfs );\n    return scarf;\n}\n\nvec2 sdFlyingHelpers( vec3 pos )\n{\n\tvec3 originalPos = pos;\n\tfloat flyingHelper = _DrawDistance;\n\n\t// Using pos.x to determine, whether we are rendering left or right scarf.\n\tvec3 helperPos = _FlyingHelperPos;\n\thelperPos = pos.x > 0.0 ? helperPos - _FlyingHelperMovement : helperPos;\n\n\t// Rest is just mirroring\n\tpos.x = abs(pos.x);\n\tpos = pos - helperPos;\n\n\tfloat helperScarf = sdHelperScarf( pos, vec3(0.0, 0.0, 0.0), originalPos);\n\n\t// Main helper is a box with a cutout sphere at back. In-game it is more sophisticated. But\n\t// I am running out of time. Maybe will do a proper one, one day!\n\tfloat helper = sdBox( pos, _FlyingHelperScale );\n\thelper\t= max( helper, -sdSphere( pos - vec3(0.0, 0.0, _FlyingHelperScale.z ), _FlyingHelperScale.z) );\n\n\t// Material and combine scarf with main body\n\tvec2 helperMat = smin_mat( vec2(helper,MAT_FLYING_HELPERS), vec2(helperScarf,MAT_FLYING_HELPER_SCARF), 0.01, 0.1);\n\thelperScarfMatUVW = helper < helperScarf ? smoothstep(-1.0, 1.0, (pos + vec3(0.0,0.0,_FlyingHelperScale.z*0.5)) / _FlyingHelperScale) : helperScarfMatUVW;\n\n\treturn helperMat;\n}\n\n//==========================================================================================\n// The big mountain in the distance. Again, not a pyramid\n//==========================================================================================\nfloat sdBigMountain( in vec3 pos )\n{\n    float scaleMul = min(_PyramidScale.x, min(_PyramidScale.y, _PyramidScale.z));\n    vec3 posPyramid\t= pos - _PyramidPos;\n\n    // Apply noise derivative, then we can use a blocky looking texture to make the mountain\n    // look edgy (for lack of better word)\n    float derNoise\t\t= sin(noised(posPyramid.xz * _PyramidNoisePrams.x).x) * _PyramidNoisePrams.y;\n    posPyramid.x\t\t= posPyramid.x + derNoise;\n\n    posPyramid /= _PyramidScale;\n    float pyramid = sdTriPrism(  posPyramid, _PrismScale.xy ) * scaleMul;\n\n    // The piercing eye. Which is just an inverted pyrmaid on top of main pyramid.\n    float eyeScale = _PyramidScale.x;\n\n    vec3 posEye = pos;\n    posEye.y = _PrismEyeScale.z - pos.y;\n    posEye.x = pos.x * _PrismEyeWidth;\n\n\tfloat eye = sdTriPrism(  (posEye -_PyramidEyeOffset) / eyeScale, _PrismEyeScale.xy ) * eyeScale;\n\treturn max(pyramid, -eye);\n}\n\n//==========================================================================================\n// Main desert shape\n//==========================================================================================\nfloat sdLargeWaves( in vec3 pos )\n{\n\t// The main shape of terrain. Just sin waves, along X and Z axis, with a power\n\t// curve to make the shape more pointy \n\n    // Manipulate the height as we go in the distance\n    // We want terrain to be a specific way closer to character, showing a path, but the path \n    // gets muddier as wo go in the distance.\n\n    float distZ = abs(pos.z - _CameraPos.z);\n    float distX = abs(pos.x - _CameraPos.x);\n    float dist = (distZ ) + (distX * 0.1);\n    dist = dist * dist * 0.01;\n\n    float detailNoise = noised(pos.xz).x * -2.5; \n\tfloat largeWaves = (sin(_LargeWaveOffset.z + pos.z * _LargeWaveDetail.y + pos.z * 0.02)  \n\t\t\t\t\t  * sin((_LargeWaveOffset.x + dist) + (pos.x * _LargeWaveDetail.x) ) * 0.5) + 0.5;\n    largeWaves = -_LargeWaveOffset.y + pow( largeWaves, _LargeWavePowStre.x) *  _LargeWavePowStre.y - detailNoise * 0.1 ;// - (-pos.z*_LargeWavePowStre.z);// \n\n    // Smoothly merge with the bottom plane of terrain\n    largeWaves = smin(largeWaves, _LargeWavePowStre.z, 0.2);\n    largeWaves = (largeWaves - dist);\n    return largeWaves * 0.9;\n}\n\nfloat sdSmallWaves( in vec3 pos )\n{\n\t// The small waves are used for adding detail to the main shape of terrain\n\tfloat distanceToCharacter = length( pos.xz - _CharacterPosition.xz );\n\n    // movement to give feel of wind blowing\n    float detailNoise = noised(pos.xz).x * _SmallWaveDetail.z; \n\tfloat smallWaves = sin(pos.z * _SmallWaveDetail.y + detailNoise + iTime * _WindSpeed.y ) * \n\t\t\t\t\t   sin(pos.x * _SmallWaveDetail.x + detailNoise + iTime * _WindSpeed.x ) * _SmallDetailStrength;// * min(1.0, distanceToCharacter);\n\t\n\treturn smallWaves * 0.9;\n}\n\nfloat sdTerrain( in vec3 pos)\n{\n\tfloat smallWaves = sdSmallWaves( pos );\n\tfloat largeWaves = sdLargeWaves( pos );\n\n    return (smallWaves + largeWaves);\n}\n\nvec2 sdDesert( in vec3 pos, in float terrain )\n{\n    float distanceToPos = length(pos.xz - _CameraPos.xz);\n    if( distanceToPos > _TerrainMaxDistance)\n        return vec2(_DrawDistance, 0.0);\t\n\n   \tfloat mat = 9.0;//length(pos.xyz) > 9.0 ? 10.0 : 40.0;\n    return vec2( pos.y + terrain, MAT_TERRAIN );\n}\n\n//==========================================================================================\n// Character trail in the sand\n//==========================================================================================\nfloat sdCharacterTrail( vec3 pos, in float terrain )\n{\n\tvec3 trailOffset = (_CharacterPosition);\n\ttrailOffset.yz  += (_CharacterTrailOffset).yz;\n    trailOffset.y = -terrain + _CharacterTrailOffset.y; \n\n    vec3 trailPos = pos - trailOffset;\n    float distanceToPoint = length(trailPos);\n    trailPos.x -= _CharacterTrailOffset.x * distanceToPoint;\n\n    // Make it wavy\n    trailPos.x += (SmoothTriangleWave( trailPos.z * _CharacterTrailWave.x  ) * _CharacterTrailWave.z * distanceToPoint);\n\n    float trail = sdBox(trailPos - vec3(0.0, 0.0, _CharacterTrailScale.z) , _CharacterTrailScale);\n    return trail;\n}\n\n//==========================================================================================\n// The tombs\n//==========================================================================================\nfloat sdTombScarf(vec3 pos, vec3 scarfOffset, float t ) \n{ \n\t//  scarfs, done same as other scarfs\n\n    vec3 scarfPos = pos - scarfOffset;\n\n    scarfPos =  (mul(  _TombScarfMat, vec4(scarfPos,1.0) )).xyz;\n\n    vec3 scale = _TombScarfScale;\n    scale.z  += (t + 1.0 ) * 0.2;\n\n    // How far are we from pivot of scarf\n    float distanceToPoint = max(0.0,length(scarfPos) - 0.1);\n\n    // Make the scarf thicker as it goes out\n    scale.x += distanceToPoint * 0.04;\n\n    // Apply some motion\n    scarfPos.x += (sin( pos.z * _TombScarfWindParams.x + iTime) * _TombScarfWindParams.z * distanceToPoint);\n    scarfPos.y += (sin( pos.z * _TombScarfWindParams.y + iTime) * _TombScarfWindParams.z * distanceToPoint);\n\n     vec3 pivotOffset = vec3(0.0, 0.0, scale.z);\n    rX(scarfPos, _TombScarfRot + ((t - 0.5)* 0.15) + SmoothTriangleWave((iTime + 1.45) * 0.1) * 0.3 );\n\n    float scarf = sdBox(scarfPos - pivotOffset , scale);\n    return scarf;\n}\n\nvec2 sdTombs( in vec3 p )\n{\n\tvec2 mainTomb = vec2(_DrawDistance, MAT_TOMB);\n\n\t// We draw two tombs, t goes -1 -> 1 so we can use negative and positive values\n\t// to mainpulate them both individually\n\tfor( float t = -1.0; t <= 1.0; t += 2.0 )\n\t{\n\t\tvec3 tombPos = (_TombPosition + vec3(-0.25 * t, t * 0.05, 0.1 * t ));\n\n\t\tvec3 pos = p - tombPos;\n\t\trZ( pos, 0.1 * t );\n\n\t\tfloat tombScarf = sdTombScarf( pos, _TombScarfOffset, t + 1.0);\n\n\t\tpos.x = abs(pos.x);\n\n\t\t// Taper them beyond a certain height. Rest is just a rounded box\n\t\tpos.x += abs( pos.y > _TombBevelParams.x  ? (pos.y - _TombBevelParams.x) * _TombBevelParams.y: 0.0 );\n\t\tfloat tTomb = sdRoundBox( pos, _TombScale, _TombBevelParams.z);\n\n\t\t// Cut out a sphere at top\n\t\ttTomb = max( tTomb, -sdSphere( pos - vec3(0.0, _TombCutOutScale.x, 0.0), _TombCutOutScale.y ) );\n\n\t\t// create scarfs at cut off points\n\t\tvec2 tTombMat = min_mat( vec2(tTomb, MAT_TOMB), vec2(tombScarf, MAT_TOMB_SCARF));\n\t\tmainTomb = min_mat( mainTomb, tTombMat);\n\t}\n\treturn mainTomb;\n}\n\n//==========================================================================================\n// The main map function\n//==========================================================================================\nvec2 map( in vec3 pos )\n{\n\tvec2 character = sdCharacter(pos);\n\tvec2 res = character;\n\n\t// I am assuming that since character covers a large portion of screen\n\t// This early out should help and same with the terrain. Assumption only, \n\t// need to look into it \n    if( res.x > 0.01 )\n    {\n    \tfloat desert = sdTerrain(pos);\n\t    vec2 terrain   = sdDesert( pos, desert );\n\t    vec2 trail\t   = vec2(-sdCharacterTrail(pos, desert), MAT_TERRAIN_TRAIL );\n\t    terrain.y\t\t= terrain.x > trail.x ? terrain.y : trail.y;\n\t\tterrain.x\t\t= smax( terrain.x, trail.x, 0.05);\n\n\t\tres\t= min_mat( res, terrain); \n        if( terrain.x > 0.01 )\n        {\n\t\t\tvec2 tombs\t   =  sdTombs(pos);\n            res = smin_mat( res, tombs, 0.2, 0.15 );\n\n            vec2 pyramid   = vec2(sdBigMountain(pos), MAT_PYRAMID);\n            res = min_mat( res, pyramid );\n\n            vec2 clouds\t   = sdClouds(pos);\n            res = min_mat( res, clouds );\n\n            vec2 flyingHelpers = sdFlyingHelpers( pos );\n            res = min_mat( res, flyingHelpers );\n        }\n\t}\n    return res;\n}\n\n\n//==========================================================================================\n// Used for generating normals. As it turns out that only the big mountain doesn't need\n// normals. Everything else does. Hey Ho!\n//==========================================================================================\nvec2 mapSimple( in vec3 pos )\n{\n\treturn map( pos );\n\t/*\n    vec2 character = sdCharacter(pos);\n    vec2 flyingHelpers = vec2( sdFlyingHelpers( pos ), 50.0 );\n    vec2 clouds\t   = sdClouds(pos);\n   \tfloat desert   = sdTerrain(pos);\n    vec2 terrain   = sdDesert( pos, desert );\n    terrain.x = smax( terrain.x, -sdCharacterTrail(pos, desert), 0.1 );\n    vec2 tombs\t   =  vec2(sdTombs(pos), 50.0);\n\n    vec2 res = character;\n    min_mat( res, flyingHelpers );\n\tres = min_mat( res, clouds );\n    res\t= min_mat( res, terrain); \n    res\t= min_mat( res, flyingHelpers); \n    res = smin_mat( res, tombs, 0.2, 0.15 );\n    return res;\n    */\n}\n\n//==========================================================================================\n// Raycasting: https://www.shadertoy.com/view/Xds3zN\n//==========================================================================================\nvec3 castRay(vec3 ro, vec3 rd) \n{\n    float tmin = 0.1;\n    float tmax = _DrawDistance;\n   \n    float t = tmin;\n    float m = -1.0;\n    float p = 0.0;\n    float maxSteps = _MaxSteps;\n    float j = 0.0;\n    for( float i = 0.0; i < _MaxSteps; i += 1.0 )\n    {\n        j = i;\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) \n        \tbreak;\n        t += res.x;\n\t    m = res.y;\n    }\n\tp = j / maxSteps;\n    if( t>tmax ) m=-1.0;\n    return vec3( t, m, p );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*mapSimple( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*mapSimple( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*mapSimple( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*mapSimple( pos + e.xxx ).x );\n}\n\n//==========================================================================================\n// Ambient Occlusion, only applied to the Traveller\n//==========================================================================================\nfloat AmbientOcclusion(vec3 p, vec3 N, float stepSize, float k)\n{\n    float r = 0.0;\n    float t = 0.0;\n  \n    for(int i = 0; i < 2; i++)\n    {\n        t += stepSize;\n        r += (1.0 / pow(2.0, t)) * (t - sdCharacter(p + (N * t)).x);\n    }\n    return max(0.0, 1.0 - (k * r));\n}\n\n//==========================================================================================\n// Simplified version of Traveller for shadow casting\n//==========================================================================================\nfloat sdCharacterShadow( vec3 pos )\n{\n    pos -= _CharacterPosition;\n    vec3 scale = _CharacterScale;\n    float scaleMul = min(scale.x, min(scale.y, scale.z));\n    \n    rY(pos, _CharacterRotation);\n\n    pos /= scale;\n\n    float mainCloak = sdMainCloak( pos );\n    float longScarf = sdScarf(pos);\n\n    return min( mainCloak, longScarf) * scaleMul;\n}\n\n//==========================================================================================\n// Only character, flying helpers and tombs cast shadows. Only terrain recieves shadows\n//==========================================================================================\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 100; ++i)\n    {\n        if (t >= maxt) {\n            break;\n        }\n    \tfloat flyingHelpers = sdFlyingHelpers( ro + rd * t).x;\n    \tfloat tombs = sdTombs( ro + rd * t ).x;\n        float h = min( sdCharacterShadow( ro + rd*t), min(flyingHelpers, tombs) );\n        if( h<0.001 )\n            return 0.1;\n        res = min( res, k*h/t );\n        t += h;\n    }\n\treturn res;\n}\n\n//==========================================================================================\n// Hi Hussain!\n// Again, somebody wrote Hi Hussain here. It wasn't me, but hi back atcha!\n// Sky\n//==========================================================================================\nvec3 sky( vec3 ro, vec3 rd )\n{\n    // Sun calculation\n    float sunDistance = length( _SunPosition );\n\n    vec3 delta = _SunPosition.xyz - (ro + rd * sunDistance);\n    float dist \t= length(delta);\n\n    // Turn Sun into a star, because the big mountain has a star like shape\n    // coming from top\n    delta.xy *= _SunStar.xy;\n    float sunDist = length(delta);\n    float spot = 1.0 - smoothstep(0.0, _SunSize, sunDist);\n    vec3 sun = clamp(_SunScale * spot * spot * spot, 0.0, 1.0) * _SunColor.rgb;\n\t\n\t// Changing color on bases of distance from Sun. To get a strong halo around\n\t// the sun\n   \tfloat expDist = clamp((dist - _ExposureOffset)  * _ExposureStrength, 0.0, 1.0);\n   \tfloat expControl = pow(expDist,_ExposurePower);\n\n    // Sky colors\n    float y = rd.y;\n    float zen = 1.0 - pow (min (1.0, 1.0 - y), _ZenithFallOff);\n    vec3 zenithColor\t= _Zenith.rgb  * zen;\n    zenithColor = mix( _SunColor.rgb, zenithColor, expControl );\n\n    float nad = 1.0 - pow (min (1.0, 1.0 + y), _NadirFallOff);\n    vec3 nadirColor\t= _Nadir.rgb * nad;\n\n    float hor = 1.0 - zen - nad;\n    vec3 horizonColor\t= _Horizon.rgb * hor;\n\n    // Add stars for Color Scheme 3\nfloat stars  = 0.0;\n#if COLOR_SCHEME == 3\n    vec3 starPos = ro + ( (rd + vec3(iTime * 0.001, 0.0, 0.0) ) * sunDistance);\n    starPos.xyz += iTime*0.01 + noised(starPos.xy) * 3.0;\n\n    starPos      = mod( starPos, 1.5) - 0.75;\n    stars  \t\t = length(starPos);\n\n\tfloat starsA \t= (step( 0.9, 1.0 - stars) * 1.0 - (stars)) * 2.0;\n\tfloat starsB\t= (step( 0.93, 1.0 - stars) * 1.0 - (stars)) * 1.5;\n\tstars = starsA + starsB;\n\n    stars = stars * pow(zen * expControl, 5.0);\n    stars = step( 0.01, stars) * stars * 2.0;\n#endif\n    return stars + (sun * _SunStar.z + zenithColor + horizonColor + nadirColor);\n}\n\n//==========================================================================================\n// The rendering, based on: https://www.shadertoy.com/view/Xds3zN\n//==========================================================================================\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n\t// res.z contains the iteration count / max iterations. This gives kind of a nice glow\n\t// effect around foreground objects. Looks particularly nice on sky, with clouds in\n\t// front and also on terrain. Gives rim kind of look!\n\tvec3 res\t= castRay(ro,rd);\n\tvec3 skyCol = sky( ro, rd );\n\tvec3 col\t= skyCol;\n\n\t#if defined (DEBUG_PERFORMANCE)\n\treturn (res.z);\n\t#endif\n\n\tfloat t = res.x;\n\tfloat m = res.y;\n\n\tvec3 pos = ro + t*rd;\n\n\t// Return sky\n\tif( m < 0.0 )\n\t{\n\t\t// Bloom for the background clouds. We want Big Mountain to be engulfed with fog. So just chop out\n\t\t// areas around right and left side of BigMountain for creating fake bloom for background clouds by\n\t\t// using the iteration count needed to generate the distance function\n\t\tfloat rightSideCloudDist = length( (ro + rd * length(_SunPosition)) - vec3(45.0, -5.0, _SunPosition.z));\n\t\tfloat leftSideCloudDist = length( (ro + rd * length(_SunPosition)) - vec3(-50.0, -5.0, _SunPosition.z));\n\t\tif( rightSideCloudDist < 40.0 )\n\t\t{\n\t\t\tfloat smoothCloudBloom = 1.0 - smoothstep( 0.8, 1.0, rightSideCloudDist / 40.0);\n\t\t\treturn col + res.z * res.z * 0.2 * smoothCloudBloom;\n\t\t}\n\t\telse if( leftSideCloudDist < 40.0 )\n\t\t{\n\t\t\tfloat smoothCloudBloom = 1.0 - smoothstep( 0.8, 1.0, leftSideCloudDist / 40.0);\n\t\t\treturn col + res.z * res.z * 0.2 * smoothCloudBloom;\n\t\t}\n        else\n\t\t\treturn col;\n\t}\n\n\tfloat skyFog = 1.0-exp( _FogMul * t * pow(pos.y, _FogPow) );\n\t#if defined (DEBUG_FOG)\n\treturn (skyFog);\n\t#endif\n\n\t// Render the big mountain. Keep track of it's color, so we can use it for transparency for clouds later\n\tvec3 pyramidCol = vec3(0.0, 0.0, 0.0);\n\tpyramidCol\t\t= mix( _PyramidCol, skyCol, skyFog * 0.5  ); \n\n\tif( TEST_MAT_LESS( m, MAT_PYRAMID) )\n\t{\n\t\t// Height fog, with strong fade to sky \n\t\tfloat nh = (pos.y / _PyramidHeightFog.x);\n\t\tnh = nh*nh*nh*nh*nh;\n\t\tfloat heightFog = pow(clamp(1.0 - (nh), 0.0, 1.0), _PyramidHeightFog.y);\n\t\theightFog\t\t= clamp( heightFog, 0.0, 1.0 );\n\t\tpyramidCol\t\t= mix( pyramidCol, skyCol, heightFog ); \n\t\treturn pyramidCol;       \n\t}\n\n\t// Calculate normal after calculating sky and big mountain\n\tvec3 nor = calcNormal(pos);\n\t// Terrain: https://archive.org/details/GDC2013Edwards\n\tif( TEST_MAT_LESS (m, MAT_TERRAIN_TRAIL ) )\n\t{\n\t\tfloat shadow = softShadow( pos - (rd * 0.01), _LightDir.xyz, _TerrainShadowParams.x, _TerrainShadowParams.y, _TerrainShadowParams.z);\n\t\tshadow\t\t = clamp( shadow + _TerrainShadowParams.w, 0.0, 1.0 );\n\n\t\tvec3 shadowCol = mix( shadow * _TerrainShadowColor, _TerrainDistanceShadowColor, pow(skyFog, _TerrainFogPower * _TerrainDistanceShadowPower) );\n\n\t\t// Strong rim lighting\n\t\tfloat rim\t= (1.0 - saturate(dot( nor , -rd ))); \n\t\trim\t\t\t= saturate(pow( rim, _TerrainRimPower)) *_TerrainRimStrength ; \n\t\tvec3 rimColor\t= rim * _TerrainRimColor;\n\n\t\t// Specular highlights\n\t\tvec3 ref\t\t= reflect(rd, nor);\n\t    vec3 halfDir\t= normalize(_LightDir + rd);\n\n\t    // The strong ocean specular highlight\n\t    float mainSpec = clamp( dot( ref, halfDir ), 0.0, 1.0 );\n\t    if ( TEST_MAT_LESS( m, MAT_TERRAIN ) )\n\t        mainSpec = pow( mainSpec, _TerrainSpecPower ) * _TerrainSpecStrength * 2.0 ;\n\t    else\n\t        mainSpec = pow( mainSpec, _TerrainSpecPower ) * _TerrainSpecStrength * 4.0;\n\n\t    float textureGlitter  = textureLod(iChannel1,pos.xz * _TerrainGlitterRep, 2.2).x * 1.15;\n\t    textureGlitter\t= pow(textureGlitter , _TerrainGlitterPower);\n\t    mainSpec \t\t*= textureGlitter;\n\n\t\t// The glitter around terrain, looks decent based on rim value\n\t    float rimSpec\t= (pow(rim, _TerrainRimSpecPower)) * textureGlitter;\n\t    vec3 specColor\t= (mainSpec + rimSpec) * _TerrainSpecColor;\n\t\tvec3 terrainCol\t= mix( (rimColor + specColor * shadow) + _TerrainCol, skyCol, pow(skyFog, _TerrainFogPower) ) + res.z * 0.2;  \n\n\t\t// maybe add a fake AO from player, just a sphere should do!\n\t\treturn mix( shadowCol, terrainCol, shadow );\n\t}\n\n\t// Clouds\n\tif( TEST_MAT_LESS (m, MAT_FRONT_CLOUDS ) )\n\t{\n\t\t// Modify the normals so that they create strong specular highlights\n\t\t// towards the top edge of clouds\n\t\tnor\t\t\t\t= normalize( nor + _CloudNormalMod);\n\t\tfloat dotProd\t= dot( nor, vec3(1.0,-3.5,1.0) );\n\n\t\tfloat spec\t\t=  1.0 -  clamp( pow(dotProd, _CloudSpecPower), 0.0, 1.0 );\n\t\tspec \t\t\t*= 2.0;\n\t\tvec3 cloudCol\t= spec * _CloudSpecCol + _CloudCol;\n\n\t\t// Transparency for mountain\n\t\tif( sdBigMountain( pos + (rd * t * _CloudPyramidDistance)) < 0.2 )\n\t \t{\n\t \t\tcloudCol = mix( pyramidCol, cloudCol, _CloudTransparencyMul ); \n\t\t}\n\n\t\t// Mixing for backdrop mountains. Backdrop mountains take more color from Sky. Foreground mountains\n\t\t// retain their own color values, so I can adjust their darkness\n\t\tvec3 inCloudCol = mix(cloudCol, _BackCloudCol + skyCol * 0.5 + spec * _BackCloudSpecCol, MAT_FRONT_CLOUDS - m);\n\t\treturn mix( inCloudCol , skyCol, skyFog * _CloudFogStrength );    \n\t}\n\n\t// Tombs\n\tif( TEST_MAT_LESS(m, MAT_TOMB_SCARF ) )\n\t{\n\t\t// Simple strong diffuse\n\t\tfloat diff\t= clamp(dot(nor,_LightDir) + 1.0, 0.0, 1.0);\n\t\tvec3 col\t= mix( _TombMainColor, _TombScarfColor * 2.0, m - MAT_TOMB );\n\t\treturn mix( diff * col, skyCol, skyFog);\n\t}\n\n\t// Flying Helpers\n\tif( TEST_MAT_LESS(m, MAT_FLYING_HELPER_SCARF ) )\n\t{\n\t\tfloat fres\t= pow( clamp(1.0+dot(nor,rd) + 0.75,0.0,1.0), _FlyingHelperFrePower ) * _FlyingHelperFreScale;\n\t\tfloat diff\t= clamp(dot(nor,_LightDir) + 1.5,0.0,1.0);\n\t\tvec3 col = _FlyingHelperYellowColor;\n\n\t\t// The main head\n\t\tif ( TEST_MAT_LESS( m, MAT_FLYING_HELPERS ) )\n\t\t{\n\t\t\tcol = _FlyingHelperMainColor;\n\n\t\t\t// Yellow borders\n\t\t\tfloat outerBorder = step( 0.95, abs(helperScarfMatUVW.x * 2.0 - 1.0) );\n\t\t\tcol  = mix( col * diff, _FlyingHelperYellowColor,  outerBorder );\n\n\t\t\t// cubes in middle\n\t\t\tfloat rectsY = abs(helperScarfMatUVW.z * 2.0 - 1.0);\n\t\t\tfloat rectsX = abs(helperScarfMatUVW.x * 2.0 - 1.0);\n\n\t\t\tfloat circles = 1.0 - (length( vec2(rectsY, rectsX) ) - 0.1);\n\t\t\tcircles = step( 0.5, circles );\n\n\t\t\t// Ideally want to do a separate bass for bloom. maybe one day\n\t\t\tfloat bloomCircle = 1.0 - (length( vec2(rectsY, rectsX) ) - 0.1); \n\t\t\tfloat bloom  = max( bloomCircle - 0.5, 0.0);\n\n\t\t\trectsY = step( 0.5, abs(rectsY * 2.0 - 1.0) );\n\t\t\trectsX = 1.0 - step( 0.5, abs(helperScarfMatUVW.x * 2.0 - 1.0) );\n\n\t\t\tfloat rects = min(rectsX, rectsY);\n\n\t\t\tfloat symbolsX = fract(rects/(helperScarfMatUVW.z * 20.0) * 20.0);\n\t\t\tfloat symbolsY = fract(rects/(helperScarfMatUVW.x * 2.0) * 2.0);\n\t\t\tfloat symbolsZ = fract(rects/((helperScarfMatUVW.z + 0.1) * 16.0) * 16.0);\n\t\t\tfloat symbolsW = fract(rects/((helperScarfMatUVW.x + 0.1) * 3.0) * 3.0);\n\n\t\t\tfloat symbols = symbolsY;\n\t\t\tsymbols = max( symbols, symbolsZ );\n\t\t\tsymbols = min(symbols , max(symbolsX, symbolsW));\n\t\t\tsymbols = step( 0.5, symbols ); \n\n\t\t\tsymbols = min( symbols, circles );\n\n\t\t\t//  float rects = min(rectsX, max(circles,rectsY));\n\n\t\t\tcol = mix( col, _FlyingHelperYellowColor, circles);\n\t\t\tcol = mix( col, _FlyingHelperWhiteColor * 2.0, symbols)  + bloom  * _FlyingHelperBloomScale;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// The scarfs, just have a yellow border\n\t\t\tfloat outerBorder = step( 0.9, abs(helperScarfMatUVW.x * 2.0 - 1.0) );\n\t\t\tcol \t= mix( _FlyingHelperMainColor * diff, _FlyingHelperYellowColor,  outerBorder );\n\t\t}\n\t\treturn mix( fres * col, skyCol, skyFog * _FlyingHelperFogScale );\n\t}\n\n\t// Character\n\tif( TEST_MAT_GREATER (m, MAT_CHARACTER_BASE ) )\n\t{\n\t\tfloat diff = _CharacterDiffScale * clamp( dot( nor, _LightDir ), 0.0, 1.0 );\n\n\t\t// Why did I fudge these normals, I can't remember. It does look good though, so keep it :)\n\t\tnor\t\t= normalize( nor + vec3(0.3,-0.1,1.0));\n\t\tnor.y\t*= 0.3;\n\n\t\tfloat fres\t= pow( clamp( 1.0 + dot(nor,rd) + 0.75, 0.0, 1.0), _CharacterFrePower ) * _CharacterFreScale;\n\t\tvec3 col\t= _CharacterMainColor;\n\n\t\t// Just base color\n\t\tif( TEST_MAT_LESS( m, MAT_CHARACTER_BASE) )\n\t\t{\n\t\t\t// Add sand fade to legs. Mixing terrain color at bottom of legs\n\t\t\tfloat heightTerrainMix\t= pow((pos.y / _CharacterHeightTerrainMix.x), _CharacterHeightTerrainMix.y);\n\t\t\theightTerrainMix\t\t= clamp( heightTerrainMix, 0.0, 1.0 );\n\t\t\tcol\t= mix( _CharacterMainColor, _CharacterTerrainCol, heightTerrainMix );\n\t\t}\n\t\t// Main Cloak\n\t\telse if( TEST_MAT_LESS( m,MAT_CHARACTER_MAIN_CLOAK) )\n\t\t{\n\t\t\t// Cone kind of shapes\n\t\t\tfloat rectsX\t= fract(atan(mainCloakMatUVW.x/ mainCloakMatUVW.z) * 7.0) ;\n\t\t\trectsX\t\t\t= abs(rectsX * 2.0 - 1.0);\n\t\t\tfloat rects\t\t= rectsX;\n\t\t\trects\t\t\t= step( 0.5, rects * (1.0 - mainCloakMatUVW.y*3.5) );\n\t\t\tcol = mix( col, _CharacterCloakDarkColor, rects );\n\n\t\t\t// Yellow borders, two lines\n\t\t\tfloat outerBorder\t\t= step( 0.915, abs(mainCloakMatUVW.y * 2.0 - 1.0) );\n\t\t\tfloat betweenBorders\t= step( 0.88, abs(mainCloakMatUVW.y * 2.0 - 1.0) );\n\t\t\tfloat innerBorder\t\t= step( 0.87, abs(mainCloakMatUVW.y * 2.0 - 1.0) );\n\n\t\t\tinnerBorder = min( innerBorder, 1.0 - betweenBorders );\n\n\t\t\tcol  = mix( col, _CharacterCloakDarkColor,  betweenBorders );\n\t\t\tcol  = mix( col, _CharacterYellowColor,  outerBorder );\n\t\t\tcol  = mix( col, _CharacterYellowColor,  innerBorder);\n\n\t\t\t// The verticle cubes/lines running across the bottom of cloak\n\t\t\tfloat cubes = abs(fract(atan(mainCloakMatUVW.x/ mainCloakMatUVW.z) * 10.0)  * 2.0 - 1.0);\n\t\t\tcubes\t\t= min(betweenBorders, step( 0.9, cubes) );\n\t\t\tcol\t\t\t= mix( col, _CharacterYellowColor,  cubes);\n\t\t}\n\t\t// headscarf\n\t\telse if( TEST_MAT_LESS( m, MAT_CHARACTER_NECK_SCARF) )\n\t\t{\n\t\t\tcol = mix( col, _CharacterYellowColor, step( 0.7, headScarfMatUVW.y) );\n\t\t}\n\t\t// Long Scarf\n\t\telse if( TEST_MAT_LESS( m, MAT_CHARACTER_LONG_SCARF) )\n\t\t{\n\t\t\tcol = _CharacterYellowColor;\n\n\t\t\t// Yellow borders, two lines\n\t\t\tfloat outerBorder = step( 0.9, abs(longScarfMatUVW.x * 2.0 - 1.0) );\n\t\t\tfloat innerBorder = step( 0.7, abs(longScarfMatUVW.x * 2.0 - 1.0) );\n\n\t\t\tinnerBorder = min( innerBorder, 1.0 - step( 0.8, abs(longScarfMatUVW.x * 2.0 - 1.0) ) );\n\n\t\t\t// Mix borders\n\t\t\tcol  = mix( col, _CharacterMainColor,  outerBorder );\n\t\t\tcol  = mix( col, _CharacterMainColor,  innerBorder);\n\n\t\t\t// cubes in middle\n\t\t\tfloat rectsY = abs(fract( longScarfMatUVW.y/ 0.10 ) * 2.0 - 1.0);// - 0.5 * 0.10;\n\t\t\tfloat rectsX = abs(longScarfMatUVW.x * 2.0 - 1.0);\n\n\t\t\tfloat circles = 1.0 - (length( vec2(rectsY, rectsX) ) - 0.1);\n\t\t\tcircles = step( 0.5, circles );\n\n\t\t\tfloat bloomCircle\t= 1.0 - (length( vec2(rectsY, rectsX * 0.7) ) - 0.1); \n\t\t\tfloat bloom \t\t= max( bloomCircle - 0.45, 0.0);\n\n\t\t\trectsY = step( 0.5, abs(rectsY * 2.0 - 1.0) );\n\t\t\trectsX = 1.0 - step( 0.5, abs(longScarfMatUVW.x * 2.0 - 1.0) );\n\n\t\t\tfloat rects = min(rectsX, rectsY);\n\n\t\t\t// There are better ways of doing symbols. Spend some time on it, buddy!\n\t\t\tfloat symbolsX = fract(rects/(longScarfMatUVW.y * 0.17) * 10.0);\n\t\t\tfloat symbolsY = fract(rects/(longScarfMatUVW.x * 18.5) * 10.0);\n\n\t\t\tfloat symbols\t= symbolsX;\n\t\t\tsymbols\t\t\t= max( symbols, symbolsY );\n\t\t\tsymbols\t\t\t= step( 0.5, symbols ); \n\n\t\t\tsymbols = min( symbols, circles );\n\n\t\t\t//        float rects = min(rectsX, max(circles,rectsY));\n\t\t\tcol = mix( col, _CharacterMainColor, circles);\n\t\t\tcol = mix( col, _CharacterWhiteColor * 2.0, symbols)  + bloom * _CharacterBloomScale;\n\n\t\t\t// White glow and disintegrating the scarf, showing depleting scarf energy. Needs bloom effect :(\n\t\t\tcol = mix( col, _CharacterMainColor, 1.0 - smoothstep(0.4, 0.6, longScarfMatUVW.y));\n\t\t\tvec3 whiteMiddle = mix( col, _CharacterWhiteColor + bloom * _CharacterBloomScale, step(0.48, longScarfMatUVW.y));\n\t\t\tcol = mix( whiteMiddle, col, step(0.5, longScarfMatUVW.y));\n\t\t}\n\t\t// Face\n\t\telse if( TEST_MAT_LESS( m, MAT_CHARACTER_FACE)  )\n\t\t{\n\t\t\tcol = vec3(0,0,0);\n\t\t}\n\t\tfloat ao = AmbientOcclusion(pos - (rd * 0.01), nor, _CharacterAOParams.x, _CharacterAOParams.y); \n\t\treturn ao * mix( (fres + diff) * col, skyCol, skyFog * _CharacterFogScale );\n\t}\n\treturn vec3( clamp(col * 0.0,0.0,1.0) );\n}\n\n\nfloat rand(float n)\n{\n\treturn fract(sin(n) * 43758.5453123);\n}\n\nfloat noise(float p)\n{\n\tfloat fl = floor(p);\n\tfloat fc = fract(p);\n    fc = fc*fc*(3.0-2.0*fc);\n    return mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Move camera using noise. This is probably quite expensive way of doing it :(\n\tfloat unitNoiseX = (noise(iTime * _CameraMovement.w ) * 2.0)  - 1.0;\n\tfloat unitNoiseY = (noise((iTime * _CameraMovement.w ) + 32.0) * 2.0)  -1.0;\n\tfloat unitNoiseZ = (noise((iTime * _CameraMovement.w ) + 48.0) * 2.0)  -1.0;\n\tvec3 ro = _CameraPos + vec3(unitNoiseX, unitNoiseY, unitNoiseZ) * _CameraMovement.xyz;\n\n\n\tvec3 screenRay\t\t= vec3(fragCoord / iResolution.xy, 1.0);\n\tvec2 screenCoord\t= screenRay.xy * 2.0 - 1.0;\n\n\t// Screen ray frustum aligned\n\tscreenRay.xy = screenCoord * _CameraFOV.xy;\n    screenRay.x\t\t\t*= 1.35;\n\tscreenRay.z  = -_CameraFOV.z;\n\tscreenRay /= abs( _CameraFOV.z); \n\n    // In camera space\n\tvec3 rd = normalize(mul( _CameraInvViewMatrix, vec4(screenRay,0.0))).xyz;\n\n\t// Do the render\n\tvec4 col = vec4(render(ro, rd), 0.0);\n\n\t// No it does not need gamma correct or tone mapping or any other effect that you heard about\n\t// and thought was cool. This is not realistic lighting\n\n\t// vignette\n\tfloat vig = pow(1.0 - 0.4 * dot(screenCoord, screenCoord), 0.6) * 1.25;\n\tvig = min( vig, 1.0);\n\tcol *= vig;\n\n\t// Final color\n\tfragColor =  col;\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}, {"id": "4djGDV", "previewfilepath": "https://soundcloud.com/awintory/journey-i-was-born-for-this?in=awintory/sets/journey", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/awintory/journey-i-was-born-for-this?in=awintory/sets/journey", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldlcRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20459, 20674, 20717, 20717, 20764], [20766, 20766, 20799, 20799, 20824], [20826, 20826, 20851, 20851, 20866], [20868, 20868, 20897, 20897, 20988], [20990, 20990, 21024, 21024, 21125], [21127, 21127, 21158, 21183, 21214], [21216, 21216, 21261, 21261, 21386], [21388, 21388, 21429, 21429, 21488], [21490, 21490, 21526, 21526, 21774], [21776, 21991, 22025, 22025, 22058], [22060, 22060, 22101, 22101, 22194], [22196, 22196, 22247, 22247, 22395], [22397, 22397, 22438, 22438, 22527], [22529, 22728, 22760, 22760, 22880], [22882, 22882, 22914, 22914, 23035], [23037, 23037, 23069, 23069, 23190], [23192, 23452, 23478, 23478, 24294], [24296, 24540, 24558, 24558, 24821], [24823, 25096, 25125, 25125, 25167], [25169, 25169, 25198, 25198, 25250], [25252, 25252, 25287, 25287, 25336], [25340, 25340, 25377, 25377, 25438], [25442, 25442, 25500, 25500, 25729], [25731, 25968, 26038, 26038, 26289], [26291, 26291, 26360, 26360, 26612], [26614, 26835, 26864, 26864, 28713], [28736, 28736, 28765, 28765, 29843], [29845, 29845, 29874, 29936, 30118], [30121, 30121, 30147, 30147, 30403], [30427, 30427, 30453, 30453, 31305], [31307, 31307, 31337, 31337, 32228], [32230, 32230, 32277, 32277, 33160], [33162, 33162, 33192, 33352, 34655], [34657, 34853, 34960, 35317, 36042], [36044, 36044, 36074, 36136, 37463], [37465, 37750, 37819, 37819, 39688], [39690, 39690, 39724, 39724, 40779], [40781, 41025, 41061, 41061, 41927], [41929, 42136, 42171, 42488, 43228], [43230, 43230, 43265, 43341, 43782], [43784, 43784, 43815, 43815, 43938], [43940, 43940, 43988, 43988, 44244], [44246, 44463, 44517, 44517, 45073], [45075, 45274, 45332, 45372, 46211], [46213, 46213, 46240, 46240, 47224], [47226, 47437, 47462, 47462, 48495], [48498, 48814, 48845, 48845, 49448], [49450, 49689, 49722, 49722, 50193], [50195, 50195, 50227, 50227, 50459], [50461, 50699, 50764, 50764, 50978], [50980, 51220, 51257, 51257, 51569], [51571, 51845, 51922, 51922, 52360], [52362, 52645, 52675, 52698, 54406], [54408, 54660, 54699, 54928, 66286], [66289, 66289, 66310, 66310, 66351], [66353, 66353, 66375, 66375, 66496], [66499, 66499, 66556, 66637, 67698]]}
{"id": "ldlczH", "name": "weird terrain", "author": "polyrhythm", "description": "raymarched  terrain", "tags": ["terrain"], "likes": 4, "viewed": 177, "published": "Public", "date": "1488784586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265359\nconst vec3 SUN_DIR = normalize(vec3(0.2, 1.0, -0.75));\n\n// ----------\n// Noise\n// ----------\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n\n  vec2 i1;\n\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n\n  i = mod289(i); \n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n// ---------------\n// transformations\n// ---------------\nfloat degToRad(float deg) {\n  return deg * (PI / 180.0);\n}\n\nmat3 rotateY(float deg) {\n  float theta = degToRad(deg);\n  float sinTh = sin(theta);\n  float cosTh = cos(theta);\n  return mat3(cosTh, 0.0, sinTh,\n              0.0,   1.0, 0.0,\n             -sinTh, 0.0, cosTh);\n}\n\nmat3 scale(vec3 s) {\n  return mat3(s.x, 0.0, 0.0,\n              0.0, s.y, 0.0,\n              0.0, 0.0, s.z);\n}\n\n// ---------------\n// terrain\n// ---------------\nfloat terrainMap(vec2 pos) {\n  float scale = 0.01;\n  const float amplitude = 13.0;\n  pos *= scale;\n  float time = iTime / 5.0;\n  return snoise(pos) * amplitude;\n}\n\n// ---------------\n// raytrace\n// ---------------\nvec2 trace(vec3 ro, vec3 rd) {\n  float dist, th;\n  const int MAX_STEPS = 400;\n  const float minT = 5.0;\n  const float maxT = 400.0;\n  float t = minT;\n  float origT = t;\n  float origDist = 0.0;\n  float height = 0.0;\n\n  for (int i = 0; i < MAX_STEPS; i++) {\n    th = 0.001 * t;\n    vec3 p = ro + rd * t;\n    float env = terrainMap(p.xz);\n    dist = p.y - env;\n    height = p.y;\n    if (dist < th) {\n      break;\n    }\n\n    origT = t;\n    origDist = dist;\n    t += 0.01 * t * dist * 0.6;\n\n    if (t > maxT) break;\n  }\n\n  if (t > maxT) return vec2(-1.0);\n\n  t = origT + (th - origDist) * (t - origT) / (dist - origDist);\n\n  return vec2(t, height);\n}\n\nvec3 getNormal(const vec3 pos) {\n  const float epsilon = 0.02;\n  vec3 n = vec3(terrainMap(vec2(pos.x - epsilon, pos.z)) - terrainMap(vec2(pos.x + epsilon, pos.z)),\n                2.0 * epsilon,\n                terrainMap(vec2(pos.x, pos.z - epsilon)) - terrainMap(vec2(pos.x, pos.z + epsilon)));\n\n  return normalize(n);\n}\n\n// ---------------\n// render\n// ---------------\nvec3 renderSky(vec3 ro, vec3 rd) {\n  vec3 col = 0.9 * vec3(0.8, 0.9, 1.0) - rd.y * vec3(0.75, 0.36, 0.4);\n\n  return col;\n}\n\nvec3 getMaterial(vec3 pos, vec3 n) {\n  vec3 green = vec3(0.2, 0.8, 0.1);\n  vec3 brown = vec3(0.9, 0.8, 0.3);\n\n  return 0.65 * mix(brown, green, smoothstep(0.4, 0.9, n.y));\n}\n\nfloat getShading(vec3 pos, vec3 n, float height) {\n  return saturate(dot(SUN_DIR, n)) + height * 0.035;\n}\n\nvec3 applyFog(vec3 colour, float dist) {\n  float fogAmount = 1.0 - exp(-dist * colour.z * 0.1);\n  vec3 fogColour = vec3(0.5, 0.6, 0.7) * 0.8;\n  return mix(colour, fogColour, fogAmount);\n}\n\nvec3 terrainColour(vec3 ro, vec3 rd, vec2 env) {\n  vec3 pos = ro + rd * env.x;\n\n  vec3 n = getNormal(pos);\n  float s = getShading(pos, n, env.y);\n  vec3 m = getMaterial(pos, n);\n\n  return applyFog(m * s, env.x);\n}\n\nvec4 render(vec3 ro, vec3 rd) {\n  vec4 col = vec4(0.0);\n  vec2 env = trace(ro, rd);\n  if (env.x != -1.0) {\n    col = vec4(terrainColour(ro, rd, env), 1.0);\n  }\n\n  return col;\n}\n\n// ---------------\n// Setup\n// ---------------\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n  p *= iResolution.xy / iResolution.y;\n\n  vec3 colour = vec3(0.0);\n\n  vec3 origin = vec3(0.0, 20.0, -40.0);\n  origin.z += iTime * 1.5;\n  origin.x += iTime;\n  vec3 target = vec3(0.0, 0.0, 0.0);\n  target.z += iTime * 1.5;\n  target.x += iTime;\n  mat3 toWorld = setCamera(origin, target, 0.0);\n  vec3 rd = toWorld * normalize(vec3(p.xy, 1.25));\n\n  // sky\n  colour = renderSky(origin, rd);\n\n  // terrain\n  vec4 terrain = render(origin, rd);\n  colour = colour * (1.0 - terrain.w) + terrain.xyz;\n\n  fragColor = vec4(colour, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldlczH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 158, 179, 179, 228], [230, 230, 251, 251, 300], [302, 302, 324, 324, 361], [363, 363, 387, 387, 1350], [1352, 1409, 1436, 1436, 1467], [1469, 1469, 1494, 1494, 1681], [1683, 1683, 1703, 1703, 1793], [1795, 1844, 1872, 1872, 2006], [2008, 2058, 2088, 2088, 2703], [2705, 2705, 2737, 2737, 3027], [3029, 3077, 3111, 3111, 3199], [3201, 3201, 3237, 3237, 3374], [3376, 3376, 3426, 3426, 3481], [3483, 3483, 3523, 3523, 3670], [3672, 3672, 3720, 3720, 3885], [3887, 3887, 3918, 3918, 4063], [4065, 4112, 4176, 4176, 4428], [4430, 4430, 4485, 4485, 5065]]}
{"id": "ldlyzl", "name": "Tonemapping", "author": "Persegan", "description": "tonemapping", "tags": ["tonemapping"], "likes": 0, "viewed": 89, "published": "Public", "date": "1489513629", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 returnV(vec4 value)\n{\n    vec4 valuetoreturn = ((value*(0.22f*value+0.1f*0.3f)+0.2f*0.01f)/(value*(0.22f*value+0.3f)+0.2f*0.3f)) - 0.01f/0.3f;\n    return valuetoreturn;\n}\n\n\nfloat returnF(float value)\n{\n    float valuetoreturn = ((value*(0.22f*value+0.1f*0.3f)+0.2f*0.01f)/(value*(0.22f*value+0.3f)+0.2f*0.3f)) - 0.01f/0.3f;\n    return valuetoreturn;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv += vec2(sin(iTime)*.1, cos(iTime*3.)*.2);\n\tfragColor = vec4(uv,.5+0.5*sin(iTime),1.0);\n    vec4 color = texture(iChannel0, uv*vec2(.2, 1.));\n    uv += vec2(sin(iTime)*.1, cos(iTime*3.)*.2);\n    color += texture (iChannel1,  uv);\n\n   \tfragColor += texture(iChannel0, uv * .2+vec2(.3) )* vec4(uv,0.5+0.5*sin(iTime),1.0);\n \tfragColor += color;   \n    //fragColor = fragColor*0.5;\n    fragColor = returnV(fragColor) / returnF(11.2f);\n}\n\n\n", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldlyzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 175], [178, 178, 206, 206, 356], [360, 360, 417, 417, 902]]}
{"id": "ldscD4", "name": "Squarez", "author": "voz", "description": "Squarez", "tags": ["squarez"], "likes": 5, "viewed": 449, "published": "Public API", "date": "1488396215", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Do not redistribute.\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n//-----------------UTILITY FUNCTIONS--------------\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((saw(float(__LINE__)*PI*GR*E))*iTime+1000.0)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n\n#define flux(x) (vec3(cos(x*2.0*PI),cos(4.0*PI/3.0+x*2.0*PI),cos(2.0*PI/3.0+x*2.0*PI))*.5+.5)\n#define circle(x) (vec2(cos((x)*2.0*PI),sin(2.0*PI*(x))))\n\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define ZIN (vec3(0.0, 0.0, 1.0))\n\n#define MIN_DIM (min(iResolution.x, iResolution.y))\n\nvec2 remap(vec2 uv, vec4 start, float r1, vec4 end, float r2)\n{\n    \n    vec3 c1 = vec3(start.xy, 0.0);\n    vec3 d1 = vec3(start.zw, 0.0);\n    \n    vec3 c2 = vec3(end.xy, 0.0);\n    vec3 d2 = vec3(end.zw, 0.0);    \n\n    uv = (rotatePoint(vec3((uv+c1.xy)*d1.xy, 0.0), ZIN, r1).xy);\n    uv = (rotatePoint(vec3((uv+c2.xy)*d2.xy, 0.0), ZIN, r2).xy);\n    \n    \n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float scale = 1.0;//4.0*(sin(time)+GR);\n    \n    float aspect = iResolution.x/iResolution.y;\n    uv *= 2.0;\n    uv -= 1.0;\n    \n    vec2 uv0 = uv;\n    \n    const int max_i = 4;\n    \n    float sum = 0.0;\n\tvec2 detail = vec2(1.0);\n    vec2 last = uv;\n    \n    for(int i = 0 ; i < max_i; i++)\n    {\n        \n        float j = float(i)/float(max_i);\n        sum += smoothstep(0.0, 1.0/PI, 1.0-abs(uv.y-saw(uv.x*(1.0+sin(time)))))*sqrt(detail.x*detail.y);\n     \n        \n        vec4 start = vec4(0.0, 0.0, 1.0, 1.0);\n        vec4 end = vec4(circle(j), (2.0/GR-j/GR), 2.0/GR-j/GR);\n        \n        \n        float theta1 = time;\n        float theta2 = theta1+j;\n        vec2 save = uv;\n        detail *= abs(cos(uv*2.0*PI));\n        uv = remap(sin(uv*2.0*PI), start, theta1, end, theta2);\n        \n        last =save;\n    }\n    \n    float map = sum/float(max_i)*5.0;\n    float b = smoothstep(0.0, 1.0/PI/E, saw(map));\n    float w = 1.0-smoothstep(0.0, 1.0/PI/E, saw(map+time));\n\tfragColor = vec4(saw(uv), 0.0, 1.0);\n\tfragColor = vec4(flux(map)*b+w, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldscD4.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[152, 204, 224, 224, 329], [330, 330, 348, 348, 387], [389, 389, 407, 407, 456], [458, 458, 476, 476, 535], [538, 1210, 1273, 1273, 1581], [1583, 1583, 1640, 1640, 2746]]}
{"id": "ldscDM", "name": "Wood Shader Toy", "author": "otaviogood", "description": "Pine-style wood shader. Experimenting with some new noise functions... Not sure they're the best for this, but good enough.", "tags": ["procedural", "wood", "material", "train", "pine"], "likes": 43, "viewed": 1394, "published": "Public API", "date": "1488524540", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// ---------------- Config ----------------\n// This is an option that lets you render high quality frames for screenshots. It enables\n// stochastic antialiasing and motion blur automatically for any shader.\n//#define NON_REALTIME_HQ_RENDER\nconst float frameToRenderHQ = 22.0; // Time in seconds of frame to render\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\n\n//#define MANUAL_CAMERA\n\n// --------------------------------------------------------\n// These variables are for the non-realtime block renderer.\nfloat localTime = 0.0;\nfloat seed = 1.0;\n\n// Animation variables\nfloat fade = 1.0;\nfloat exposure = 1.0;\nvec3 poofPos = vec3(0.0);\nfloat poofCycle = 0.0;\n\n// lighting vars\nvec3 sunDir = normalize(vec3(0.93, 1.0, 1.0));\nconst vec3 sunCol = vec3(250.0, 220.0, 200.0) / 3555.0;\nconst vec3 horizonCol = vec3(0.95, 0.95, 0.95)*1.3;\nconst vec3 skyCol = vec3(0.13,0.28,0.95);\nconst vec3 groundCol = vec3(0.003,0.7,0.75);\n\n// ---- noise functions ----\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\n// noise functions\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\n\n// Noise generator from https://otaviogood.github.io/noisegen/\n// Params: 3D, Seed 1, Waves 128, Octaves 7, Smooth 1\nfloat NoiseGen(vec3 p) {\n    // This is a bit faster if we use 2 accumulators instead of 1.\n    // Timed on Linux/Chrome/TitanX Pascal\n    float wave0 = 0.0;\n    float wave1 = 0.0;\n    wave0 += sin(dot(p, vec3(-1.316, 0.918, 1.398))) * 0.0783275458;\n    wave1 += sin(dot(p, vec3(0.295, -0.176, 2.167))) * 0.0739931495;\n    wave0 += sin(dot(p, vec3(-0.926, 1.445, 1.429))) * 0.0716716966;\n    wave1 += sin(dot(p, vec3(-1.878, -0.174, 1.258))) * 0.0697839187;\n    wave0 += sin(dot(p, vec3(-1.995, 0.661, -0.908))) * 0.0685409863;\n    wave1 += sin(dot(p, vec3(-1.770, 1.350, -0.905))) * 0.0630152419;\n    wave0 += sin(dot(p, vec3(2.116, -0.021, 1.161))) * 0.0625361712;\n    wave1 += sin(dot(p, vec3(0.405, -1.712, -1.855))) * 0.0567751048;\n    wave0 += sin(dot(p, vec3(1.346, 0.945, 1.999))) * 0.0556465603;\n    wave1 += sin(dot(p, vec3(-0.397, -0.573, 2.495))) * 0.0555747667;\n    wave0 += sin(dot(p, vec3(0.103, -2.457, -1.144))) * 0.0516322279;\n    wave1 += sin(dot(p, vec3(-0.483, -1.323, 2.330))) * 0.0513093320;\n    wave0 += sin(dot(p, vec3(-1.715, -1.810, -1.164))) * 0.0504567036;\n    wave1 += sin(dot(p, vec3(2.529, 0.479, 1.011))) * 0.0500811899;\n    wave0 += sin(dot(p, vec3(-1.643, -1.814, -1.437))) * 0.0480875812;\n    wave1 += sin(dot(p, vec3(1.495, -1.905, -1.648))) * 0.0458268348;\n    wave0 += sin(dot(p, vec3(-1.874, 1.559, 1.762))) * 0.0440084357;\n    wave1 += sin(dot(p, vec3(1.068, -2.090, 2.081))) * 0.0413624154;\n    wave0 += sin(dot(p, vec3(-0.647, -2.197, -2.237))) * 0.0401592830;\n    wave1 += sin(dot(p, vec3(-2.146, -2.171, -1.135))) * 0.0391682940;\n    wave0 += sin(dot(p, vec3(2.538, -1.854, -1.604))) * 0.0349588163;\n    wave1 += sin(dot(p, vec3(1.687, 2.191, -2.270))) * 0.0342888847;\n    wave0 += sin(dot(p, vec3(0.205, 2.617, -2.481))) * 0.0338465332;\n    wave1 += sin(dot(p, vec3(3.297, -0.440, -2.317))) * 0.0289423448;\n    wave0 += sin(dot(p, vec3(1.068, -1.944, 3.432))) * 0.0286404261;\n    wave1 += sin(dot(p, vec3(-3.681, 1.068, 1.789))) * 0.0273625684;\n    wave0 += sin(dot(p, vec3(3.116, 2.631, -1.658))) * 0.0259772492;\n    wave1 += sin(dot(p, vec3(-1.992, -2.902, -2.954))) * 0.0245830241;\n    wave0 += sin(dot(p, vec3(-2.409, -2.374, 3.116))) * 0.0245592756;\n    wave1 += sin(dot(p, vec3(0.790, 1.768, 4.196))) * 0.0244078334;\n    wave0 += sin(dot(p, vec3(-3.289, 1.007, 3.148))) * 0.0241328015;\n    wave1 += sin(dot(p, vec3(3.421, -2.663, 3.262))) * 0.0199736126;\n    wave0 += sin(dot(p, vec3(3.062, 2.621, 3.649))) * 0.0199230290;\n    wave1 += sin(dot(p, vec3(4.422, -2.206, 2.621))) * 0.0192399437;\n    wave0 += sin(dot(p, vec3(2.714, 3.022, 4.200))) * 0.0182510631;\n    wave1 += sin(dot(p, vec3(-0.451, 4.143, -4.142))) * 0.0181293526;\n    wave0 += sin(dot(p, vec3(-5.838, -0.360, -1.536))) * 0.0175114826;\n    wave1 += sin(dot(p, vec3(-0.278, -4.565, 4.149))) * 0.0170799341;\n    wave0 += sin(dot(p, vec3(-5.893, -0.163, -2.141))) * 0.0167655258;\n    wave1 += sin(dot(p, vec3(4.855, -4.153, 0.606))) * 0.0163155335;\n    wave0 += sin(dot(p, vec3(4.498, 0.987, -4.488))) * 0.0162770287;\n    wave1 += sin(dot(p, vec3(-1.463, 5.321, -3.315))) * 0.0162569125;\n    wave0 += sin(dot(p, vec3(-1.862, 4.386, 4.749))) * 0.0154338176;\n    wave1 += sin(dot(p, vec3(0.563, 3.616, -5.751))) * 0.0151952226;\n    wave0 += sin(dot(p, vec3(-0.126, 2.569, -6.349))) * 0.0151089405;\n    wave1 += sin(dot(p, vec3(-5.094, 4.759, 0.186))) * 0.0147947096;\n    wave0 += sin(dot(p, vec3(1.319, 5.713, 3.845))) * 0.0147035221;\n    wave1 += sin(dot(p, vec3(7.141, -0.327, 1.420))) * 0.0140573910;\n    wave0 += sin(dot(p, vec3(3.888, 6.543, 0.547))) * 0.0133309850;\n    wave1 += sin(dot(p, vec3(-1.898, -3.563, -6.483))) * 0.0133171360;\n    wave0 += sin(dot(p, vec3(1.719, 7.769, 0.340))) * 0.0126913718;\n    wave1 += sin(dot(p, vec3(-2.210, -7.836, 0.102))) * 0.0123746071;\n    wave0 += sin(dot(p, vec3(6.248, -5.451, 1.866))) * 0.0117861898;\n    wave1 += sin(dot(p, vec3(1.627, -7.066, -4.732))) * 0.0115417453;\n    wave0 += sin(dot(p, vec3(4.099, -7.704, 1.474))) * 0.0112591564;\n    wave1 += sin(dot(p, vec3(7.357, 3.788, 3.204))) * 0.0112252325;\n    wave0 += sin(dot(p, vec3(-2.797, 6.208, 6.253))) * 0.0107206906;\n    wave1 += sin(dot(p, vec3(6.130, -5.335, -4.650))) * 0.0105693992;\n    wave0 += sin(dot(p, vec3(5.276, -5.576, -5.438))) * 0.0105139072;\n    wave1 += sin(dot(p, vec3(9.148, 2.530, -0.383))) * 0.0103996383;\n    wave0 += sin(dot(p, vec3(3.894, 2.559, 8.357))) * 0.0103161113;\n    wave1 += sin(dot(p, vec3(-6.604, 8.024, -0.289))) * 0.0094066875;\n    wave0 += sin(dot(p, vec3(-5.925, 6.505, -6.403))) * 0.0089444733;\n    wave1 += sin(dot(p, vec3(9.085, 10.331, -0.451))) * 0.0069245599;\n    wave0 += sin(dot(p, vec3(-8.228, 6.323, -9.900))) * 0.0066251015;\n    wave1 += sin(dot(p, vec3(10.029, -3.802, 12.151))) * 0.0058122824;\n    wave0 += sin(dot(p, vec3(-10.151, -6.513, -11.063))) * 0.0057522358;\n    wave1 += sin(dot(p, vec3(-1.773, -16.284, 2.828))) * 0.0056578101;\n    wave0 += sin(dot(p, vec3(11.081, 8.687, -9.852))) * 0.0054614334;\n    wave1 += sin(dot(p, vec3(-3.941, -4.386, 16.191))) * 0.0054454253;\n    wave0 += sin(dot(p, vec3(-6.742, 2.133, -17.268))) * 0.0050050132;\n    wave1 += sin(dot(p, vec3(-10.743, 5.698, 14.975))) * 0.0048323955;\n    wave0 += sin(dot(p, vec3(-9.603, 12.472, 14.542))) * 0.0043264378;\n    wave1 += sin(dot(p, vec3(13.515, 14.345, 8.481))) * 0.0043208884;\n    wave0 += sin(dot(p, vec3(-10.330, 16.209, -9.742))) * 0.0043013736;\n    wave1 += sin(dot(p, vec3(-8.580, -6.628, 19.191))) * 0.0042005922;\n    wave0 += sin(dot(p, vec3(-17.154, 10.620, 11.828))) * 0.0039482427;\n    wave1 += sin(dot(p, vec3(16.330, 14.123, -10.420))) * 0.0038474789;\n    wave0 += sin(dot(p, vec3(-21.275, 10.768, -3.252))) * 0.0038320501;\n    wave1 += sin(dot(p, vec3(1.744, 7.922, 23.152))) * 0.0037560829;\n    wave0 += sin(dot(p, vec3(-3.895, 21.321, 12.006))) * 0.0037173885;\n    wave1 += sin(dot(p, vec3(-22.705, 2.543, 10.695))) * 0.0036484394;\n    wave0 += sin(dot(p, vec3(-13.053, -16.634, -13.993))) * 0.0036291121;\n    wave1 += sin(dot(p, vec3(22.697, -11.230, 1.417))) * 0.0036280459;\n    wave0 += sin(dot(p, vec3(20.646, 14.602, 3.400))) * 0.0036055008;\n    wave1 += sin(dot(p, vec3(5.824, -8.717, -23.680))) * 0.0035501527;\n    wave0 += sin(dot(p, vec3(6.691, 15.499, 20.079))) * 0.0035029508;\n    wave1 += sin(dot(p, vec3(9.926, -22.778, 9.144))) * 0.0034694278;\n    wave0 += sin(dot(p, vec3(-9.552, -27.491, 2.197))) * 0.0031359281;\n    wave1 += sin(dot(p, vec3(21.071, -17.991, -11.566))) * 0.0030453280;\n    wave0 += sin(dot(p, vec3(9.780, 1.783, 28.536))) * 0.0030251754;\n    wave1 += sin(dot(p, vec3(8.738, -18.373, 22.725))) * 0.0029960272;\n    wave0 += sin(dot(p, vec3(14.105, 25.703, -8.834))) * 0.0029840058;\n    wave1 += sin(dot(p, vec3(-24.926, -17.766, -4.740))) * 0.0029487709;\n    wave0 += sin(dot(p, vec3(1.060, -1.570, 32.535))) * 0.0027980099;\n    wave1 += sin(dot(p, vec3(-24.532, -19.629, -16.759))) * 0.0025538949;\n    wave0 += sin(dot(p, vec3(28.772, -21.183, -9.935))) * 0.0024494819;\n    wave1 += sin(dot(p, vec3(-28.413, 22.959, 8.338))) * 0.0024236674;\n    wave0 += sin(dot(p, vec3(-27.664, 22.197, 13.301))) * 0.0023965996;\n    wave1 += sin(dot(p, vec3(-27.421, 20.643, 18.713))) * 0.0023203498;\n    wave0 += sin(dot(p, vec3(18.961, -7.189, 35.907))) * 0.0021967023;\n    wave1 += sin(dot(p, vec3(-23.949, 4.885, 33.762))) * 0.0021727461;\n    wave0 += sin(dot(p, vec3(35.305, 8.594, 20.564))) * 0.0021689816;\n    wave1 += sin(dot(p, vec3(30.364, -11.608, -27.199))) * 0.0021357139;\n    wave0 += sin(dot(p, vec3(34.268, 26.742, 0.958))) * 0.0020807976;\n    wave1 += sin(dot(p, vec3(-26.376, -17.313, -32.023))) * 0.0020108850;\n    wave0 += sin(dot(p, vec3(31.860, -32.181, -2.834))) * 0.0019919601;\n    wave1 += sin(dot(p, vec3(25.590, 32.340, 21.381))) * 0.0019446179;\n    wave0 += sin(dot(p, vec3(-17.771, -23.941, 37.324))) * 0.0018898258;\n    wave1 += sin(dot(p, vec3(-38.699, 19.953, -22.675))) * 0.0018379538;\n    wave0 += sin(dot(p, vec3(-46.284, 11.672, -15.411))) * 0.0017980056;\n    wave1 += sin(dot(p, vec3(-32.023, -43.976, -7.378))) * 0.0016399251;\n    wave0 += sin(dot(p, vec3(-42.390, -21.165, -31.889))) * 0.0015752176;\n    wave1 += sin(dot(p, vec3(-18.949, -40.461, 39.107))) * 0.0015141244;\n    wave0 += sin(dot(p, vec3(-21.507, -5.939, -58.531))) * 0.0014339601;\n    wave1 += sin(dot(p, vec3(-51.745, -43.821, 9.651))) * 0.0013096306;\n    wave0 += sin(dot(p, vec3(39.239, 25.971, -52.615))) * 0.0012701774;\n    wave1 += sin(dot(p, vec3(-49.669, -35.051, -36.306))) * 0.0012661695;\n    wave0 += sin(dot(p, vec3(-49.996, 35.309, 38.460))) * 0.0012398870;\n    wave1 += sin(dot(p, vec3(27.000, -65.904, -36.267))) * 0.0011199347;\n    wave0 += sin(dot(p, vec3(-52.523, -26.557, 57.693))) * 0.0010856391;\n    wave1 += sin(dot(p, vec3(-42.670, 0.269, -71.125))) * 0.0010786551;\n    wave0 += sin(dot(p, vec3(-9.377, 64.575, -68.151))) * 0.0009468199;\n    wave1 += sin(dot(p, vec3(14.571, -29.160, 106.329))) * 0.0008019719;\n    wave0 += sin(dot(p, vec3(-21.549, 103.887, 36.882))) * 0.0007939609;\n    wave1 += sin(dot(p, vec3(-42.781, 110.966, -9.070))) * 0.0007473261;\n    wave0 += sin(dot(p, vec3(-112.686, 18.296, -37.920))) * 0.0007409259;\n    wave1 += sin(dot(p, vec3(71.493, 33.838, -96.931))) * 0.0007121903;\n    return wave0+wave1;\n}\n\nconst float PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir, float sunFilter)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 / dist;\n    sunIntensity += exp(-dist*(40.0 + 110.0 * sunFilter))*7000.0;\n\tsunIntensity = min(sunIntensity, 8000.0);\n\treturn sunCol * sunIntensity*0.2;\n}\n\nvec3 GetEnvMap(vec3 rayDir, vec3 sunDir, float sunFilter)\n{\n    // fade the sky color, multiply sunset dimming\n    vec3 finalColor = mix(horizonCol, skyCol, pow(saturate(rayDir.y), 0.47))*0.95;\n\n    // add the sun\n    finalColor += GetSunColorSmall(rayDir, sunDir, sunFilter);\n    return finalColor;\n}\n\n// min function that supports materials in the y component\nvec2 matmin(vec2 a, vec2 b)\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\n\n// ---- shapes defined by distance fields ----\n// See this site for a reference to more distance functions...\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n// signed box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\nfloat cyl(vec3 p, float rad)\n{\n    return length(p.xy) - rad;\n}\n\nfloat cylcap(vec3 p, float rad, float lenrad)\n{\n    return max(abs(p.z) - lenrad, length(p.xy) - rad);\n}\n\nfloat sSphere(vec3 p, float rad)\n{\n    return length(p) - rad;\n}\n\nvec3 RepeatOffset(vec3 a, float len)\n{\n    return fract(a+vec3(-0.5, 0.0, 0.0)) - 0.5 * len;\n}\n\n// This is the distance function that defines all the scene's geometry.\n// The input is a position in space.\n// The output is the distance to the nearest surface, a material index,\n// and the difference between the iceberg distance and the water distance.\nvec2 DistanceToObject(vec3 p)\n{\n    float dist;\n\n    vec3 lp = p + vec3(0.0, 1.5, 0.0);\n    dist = sdBox(lp, vec3(1.75, 0.2, 0.5));\n    dist = max(dist, (lp.x + lp.y)*0.72 - 1.1);\n    dist = min(dist, cylcap(p.zyx + vec3(0.0, 0.85, -0.2), 0.45, 1.15));\n    dist = min(dist, sdBox(p + vec3(1.5, 0.5, 0.0), vec3(0.5, 0.75, 0.5)));\n    dist = max(dist, -cyl(p + vec3(1.6, 0.25, 0.0), 0.25));\n    dist = min(dist, cylcap(p.zxy + vec3(0.0, -0.6, 0.0), 0.2, 0.5));\n    dist = min(dist, cylcap(p.zxy + vec3(0.0, 0.25, 0.3), 0.15, 0.35));\n    dist = min(dist, sdBox(p + vec3(1.4, -0.3, 0.0), vec3(0.8, 0.1, 0.6)));\n\n    float table = sdBox(p + vec3(0.0, 2.125, 0.0), vec3(46.0, 0.1, 6.0));\n    vec2 distAndMat = matmin(vec2(table, 1.0), vec2(dist, 0.0));\n\n    vec3 mirror = abs(p + vec3(0.4, 1.5, 0.0)) + vec3(-1.0, 0.0, -0.7);\n    dist = cylcap(mirror, 0.5, 0.1);\n    dist = min(dist, cylcap(mirror, 0.125, 0.15));\n    vec2 wheels = vec2(dist, 2.0);\n    distAndMat = matmin(distAndMat, wheels);\n\n    dist = length(p + poofPos) - (0.2 + poofCycle*0.5);\n    distAndMat = matmin(distAndMat, vec2(dist, 3.0));\n\n    return distAndMat;\n}\n\nfloat repramp(float x) {\n\treturn pow(sin(x)*0.5+0.5, 8.0) + cos(x)*0.7 + 0.7;\n}\n\nvec3 TraceOneRay(vec3 camPos, vec3 rayVec, out vec3 normal, out vec2 distAndMat, out float t) {\n    normal = vec3(0.0);\n    distAndMat = vec2(0.0, -1.0);  // Distance and material\n    vec3 finalColor = vec3(0.0);\n\t// ----------------------------- Ray march the scene ------------------------------\n\tt = 0.0;\n\tconst float maxDepth = 32.0; // farthest distance rays will travel\n\tvec3 pos = vec3(0.0);\n    const float smallVal = 0.000625;\n\t// ray marching time\n    for (int i = 250; i >= 0; i--)\t// This is the count of the max times the ray actually marches.\n    {\n        // Step along the ray.\n        pos = (camPos + rayVec * t);\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        distAndMat = DistanceToObject(pos);\n\n        // move down the ray a safe amount\n        t += distAndMat.x;\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if ((t > maxDepth) || (abs(distAndMat.x) < smallVal)) break;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\t// If a ray actually hit the object, let's light it.\n    if (t <= maxDepth)\n\t{\n        float dist = distAndMat.x;\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy).x,\n                           dist - DistanceToObject(pos - smallVec.yxy).x,\n                           dist - DistanceToObject(pos - smallVec.yyx).x);\n        normal = normalize(normalU);\n\n        // calculate ambient occlusion values.\n        float ambientS = 1.0;\n        vec2 distAndMatA = DistanceToObject(pos + normal * 0.4);\n        ambientS *= saturate(distAndMatA.x*2.5);\n        distAndMatA = DistanceToObject(pos + normal * 0.8);\n        ambientS *= saturate(distAndMatA.x*1.25);\n        ambientS = max(0.05, ambientS);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.1;\n\t\tfor (int i = 0; i < 20; i++)\n        {\n            float tempDist = DistanceToObject(pos + sunDir * iter).x;\n\t        sunShadow *= saturate(tempDist*20.0);\n            if (tempDist <= 0.0) break;\n            iter += max(0.05, tempDist);\n        }\n        sunShadow = saturate(sunShadow);\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(rayVec, normal);\n\n        // ------ Calculate texture color  ------\n        vec3 texColor = vec3(0.0);\n        if (distAndMat.y == 2.0) {\n\t\t    vec3 mirror = pos + vec3(0.4, 1.5, 0.0) + vec3(-1.0, 0.0, -0.7);\n            mirror.xz = RepeatOffset((pos + vec3(0.4, 1.5, 0.0)) + vec3(-1.0, 0.0, -0.7), 1.0).xz;\n            pos = RotateZ(mirror, -localTime/(PI/4.0));\n        }\n        if (distAndMat.y == 1.0) pos = pos.yxz + vec3(20.0, 2.0+localTime, 0.0);\n        if (distAndMat.y == 3.0) {\n            pos += poofPos;\n\t        pos.xzy = pos;\n        }\n\n        // Wood shader\n        float rings = repramp(length(pos.xz + vec2(NoiseGen(pos*vec3(8.0, 1.5, 8.0)), NoiseGen(-pos*vec3(8.0, 1.5, 8.0)+4.5678))*0.05)*64.0) / 1.8;\n        rings -= NoiseGen(pos *1.0)*0.75;\n        texColor = mix(vec3(0.3, 0.19, 0.075)*0.95, vec3(1.0, 0.73, 0.326)*0.4, rings)*1.5;\n        texColor = max(vec3(0.0), texColor);\n        float rough = (NoiseGen(pos*64.0*vec3(1.0, 0.2, 1.0))*0.1+0.9);\n        texColor *= rough;\n        texColor = saturate(texColor);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(14.0)*sunCol * saturate(dot(sunDir, normal)) * sunShadow;\n        lightColor += skyCol * ((normal.y) * 0.5 + 0.5) * 0.5 * ambientS;\n\n        // apply the light to the texture.\n        finalColor = texColor * lightColor;\n        finalColor *= 2.0;\n\n        // specular highlight\n        finalColor += GetEnvMap(ref + rough*0.5, sunDir, 0.0)*0.005 * (0.5 - rings*0.5) * sunShadow * rough;\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n        //finalColor = vec3(1.0)*ambientS;\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw background.\n        finalColor =vec3(0.9);\n    }\n    return finalColor;\n}\n\n// Input is UV coordinate of pixel to render.\n// Output is RGB color.\nvec3 RayTrace(in vec2 fragCoord )\n{\n    fade = 1.0;\n\n\tvec3 camPos, camUp, camLookat;\n\t// ------------------- Set up the camera rays for ray marching --------------------\n    // Map uv to [-1.0..1.0]\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    uv /= 3.0;  // zoom in\n\n#ifdef MANUAL_CAMERA\n    // Camera up vector.\n\tcamUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0,0);\n\n    // debugging camera\n    float mx=-iMouse.x/iResolution.x*PI*2.0;\n\tfloat my=iMouse.y/iResolution.y*3.14*0.95 + PI/2.0;\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*9.0;\n#else\n    // Repeat the animation after time t3\n    float time = localTime *0.25;\n    camPos = vec3(0.0, 0.4, 8.0);\n    camPos.x = sin(time)*7.0;\n    camPos.y += (-cos(time*2.0)+1.0)*4.0;\n    camPos.z = cos(time)*7.0;\n    camUp=vec3(0,1,0);\n    camLookat=vec3(0,-0.5,0.5);\n#endif\n\n    // ---- animation ----\n    poofCycle = fract(localTime*0.25);\n    poofPos = -vec3(0.6 - poofCycle*poofCycle*12.0, poofCycle * 4.0 + 0.5, 0.0);\n\n\t// Camera setup for ray tracing / marching\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n    vec3 normal;\n    vec2 distAndMat;\n    float t;\n    vec3 finalColor = TraceOneRay(camPos, rayVec, normal, distAndMat, t);\n\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= exposure;\n\n\t// output the final color without gamma correction - will do gamma later.\n\treturn vec3(clamp(finalColor, 0.0, 1.0));\n}\n\n#ifdef NON_REALTIME_HQ_RENDER\n// This function breaks the image down into blocks and scans\n// through them, rendering 1 block at a time. It's for non-\n// realtime things that take a long time to render.\n\n// This is the frame rate to render at. Too fast and you will\n// miss some blocks.\nconst float blockRate = 20.0;\nvoid BlockRender(in vec2 fragCoord)\n{\n    // blockSize is how much it will try to render in 1 frame.\n    // adjust this smaller for more complex scenes, bigger for\n    // faster render times.\n    const float blockSize = 64.0;\n    // Make the block repeatedly scan across the image based on time.\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\n    // ugly bug with mod.\n    //float blockX = mod(frame, blockRes.x);\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\n    // Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef NON_REALTIME_HQ_RENDER\n    // Optionally render a non-realtime scene with high quality\n    BlockRender(fragCoord);\n#endif\n\n    // Do a multi-pass render\n    vec3 finalColor = vec3(0.0);\n#ifdef NON_REALTIME_HQ_RENDER\n    for (float i = 0.0; i < antialiasingSamples; i++)\n    {\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\n        // Set this to the time in seconds of the frame to render.\n\t    localTime = frameToRenderHQ;\n        // This line will motion-blur the renders\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\n        vec2 jittered = fragCoord.xy + vec2(\n            Hash21(fragCoord + seed),\n            Hash21(fragCoord*7.234567 + seed)\n            );\n        // don't antialias if only 1 sample.\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\n        // Accumulate one pass of raytracing into our pixel value\n\t    finalColor += RayTrace(jittered);\n        // Change the random seed for each pass.\n\t    seed *= 1.01234567;\n    }\n    // Average all accumulated pixel intensities\n    finalColor /= antialiasingSamples;\n#else\n    // Regular real-time rendering\n    localTime = iTime;\n    finalColor = RayTrace(fragCoord);\n#endif\n\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldscDM.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[1546, 1575, 1594, 1594, 1639], [1640, 1640, 1659, 1659, 1690], [1691, 1691, 1714, 1714, 1750], [1751, 1751, 1774, 1774, 1845], [1846, 1846, 1868, 1868, 1955], [1956, 1956, 1978, 1978, 2031], [2032, 2051, 2074, 2074, 2145], [2146, 2146, 2169, 2169, 2255], [2256, 2256, 2297, 2297, 2340], [2342, 2459, 2483, 2593, 11702], [11732, 11732, 11755, 11755, 11784], [11785, 11785, 11808, 11808, 11837], [11838, 11838, 11863, 11863, 11892], [11894, 11894, 11927, 11927, 12044], [12045, 12045, 12078, 12078, 12194], [12195, 12195, 12228, 12228, 12345], [12347, 12425, 12491, 12491, 12765], [12767, 12767, 12826, 12877, 13068], [13070, 13129, 13158, 13158, 13208], [13391, 13420, 13454, 13454, 13565], [13567, 13567, 13597, 13597, 13630], [13632, 13632, 13679, 13679, 13736], [13738, 13738, 13772, 13772, 13802], [13804, 13804, 13842, 13842, 13898], [13900, 14156, 14187, 14187, 15280], [15282, 15282, 15306, 15306, 15361], [15363, 15363, 15458, 15458, 20280], [20282, 20352, 20387, 20387, 22060], [23392, 23392, 23449, 23449, 24808]]}
{"id": "ldscRB", "name": "3D Kali", "author": "lherm", "description": "My attempt at a 3D Kaliset", "tags": ["raymarch", "kali"], "likes": 10, "viewed": 1308, "published": "Public API", "date": "1488821894", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define r(p, a) {p = cos(a) * p + sin(a) * vec2(p.y, -p.x);}\n#define time iTime\nfloat fftsmooth(float a, sampler2D s)\n{\n    //from nick shelton\n    //FFT_smooth_n = FFTRaw_n * alpha + FFT_smooth_n-1 * (1 - alpha)\n    float audio = texture(s, vec2(.5)).r;\n    return audio * a + audio-1. * (1.-a);\n    \n}\n\n#define PSD fftsmooth(.5, iChannel0)\n\nfloat trap = 0.;\n\nfloat map(vec3 pos)\n{\n\tvec4 p = vec4(pos, 1.);\n\tfloat d = 100.;\n\tfor (int i = 0; i < 5; i++)\n\t{\n        // Kali set formula: abs(p) / dot(p, p)\n\t\tp = abs(p)/clamp(dot(p,p), -1., 1.)-vec4(1., 1.3, .6, .4);\n\t\tr(p.xz, time + PSD);\n\t\tr(p.yz, time + PSD);\n\t\tr(p.xy, time + PSD);\n\t\t\n\t\t\n\t\td = min(d, length(p.x*p.y*p.z*p.w)-.5);\n        \n        // Alternate formula using code from https://www.shadertoy.com/view/XsGXWc\n\t\t//d = min(d, sin(p.x*p.y*p.z));\n\t\ttrap = distance(p, vec4(0.));\n\t}\n\treturn d;\n}\n\nvec3 calcNormal(vec3 p)\n{\n\tvec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(map(p+e.xyy)-map(p-e.xyy), map(p+e.yxy)-map(p-e.yxy), map(p+e.yyx)-map(p-e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // Fun effect to go with the fractal from https://www.shadertoy.com/view/XtSGDK\n    //#define DEFORM\n    #ifdef DEFORM\n    float r2 = dot(uv, uv);\n    uv /= r2;\n    #endif\n    \n\tvec3 ro = vec3(uv, 1.);\n\tvec3 rd = normalize(vec3(uv, -1.));\n\t\n\tfloat t = 0.;\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tfloat m = map(ro + rd * t);\n\t\tt+=m;\n\t\tif (t > 40. || m < 0.02) break;\n\t}\n\t\n\tif (t > 40.)\n\t{\n\t\tfragColor = vec4(0.);\n\t\treturn;\n\t}\n\t\n\tvec3 p = ro + rd * t;\n\tvec3 n = calcNormal(p);\n\t\n\tvec3 lp = vec3(1., 3., 5.);\n\tvec3 ld = lp - p;\n\tfloat len = length(ld);\n\tld /= len;\n\tfloat diff = max(dot(ld, n), 0.);\n\tfloat atten = min(1., 1./len);\n\tfloat amb = .25;\n\tfloat spec = pow(max(dot(normalize(ro-p), reflect(-ld, n)), 0.), 8.);\n\t\n\tvec3 col = vec3(trap, trap*trap, pow(trap, 4.)) * ((diff+amb)+spec)*atten;\n\t\n\tcol /= abs(sin(vec3(.5, .2, .9) + col + time + PSD));\n\tfragColor = vec4( col, 1.0 );\n\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldscRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 119, 212, 303], [361, 361, 382, 382, 856], [858, 858, 883, 883, 1017], [1019, 1019, 1076, 1076, 2032]]}
{"id": "ldscRl", "name": "Pixelation_Effect", "author": "Persegan", "description": "pixelation effect", "tags": ["pixelation"], "likes": 0, "viewed": 64, "published": "Public", "date": "1489511641", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = floor(uv *50.0f)/50.0f; //modify this line for pixel size\n    uv += vec2(sin(iTime)*.1, cos(iTime*3.)*.2);\n\tfragColor = vec4(uv,.5+0.5*sin(iTime),1.0);\n    vec4 color = texture(iChannel0, uv*vec2(.2, 1.));\n    uv += vec2(sin(iTime)*.1, cos(iTime*3.)*.2);\n    color += texture (iChannel1,  uv);\n\n   \tfragColor += texture(iChannel0, uv * .2+vec2(.3) )* vec4(uv,0.5+0.5*sin(iTime),1.0);\n \tfragColor += color;   \n    fragColor = fragColor*0.3;\n}\n", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldscRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 554]]}
{"id": "ldscz2", "name": "Rows in Shadertoy", "author": "Ippokratis", "description": "Adapted from Keijiro's repository\nhttps://github.com/keijiro/ShaderSketches/blob/master/Rows.glsl", "tags": ["keijiro", "rows", "adapted"], "likes": 5, "viewed": 156, "published": "Public", "date": "1489021474", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Adapted from\n//https://github.com/keijiro/ShaderSketches/blob/master/Rows.glsl\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst float PI = 3.141592;\n\tfloat time = iTime;\n\n    \n    vec2 coord = gl_FragCoord.xy;\n    vec2 size = iResolution.xx / vec2(60, 15);\n    float y = coord.y / size.y;\n    float scr = 3.0 + 3.0 * fract(floor(y) * 12433.34);\n    float x = coord.x / size.x + scr * time;\n \n    float t = time * 1.1;\n    float t01 = fract(t);\n    float phase = floor(x) * 2353.48272 + floor(y) * 2745.32782 + floor(t);\n\n    float h = mix(\n        fract(sin(phase    ) * 1423.84),\n        fract(sin(phase + 1.0) * 1423.84),\n        smoothstep(0.8, 1.0, t01) * 1.3 - smoothstep(0.5, 0.8, t01) * 0.3\n    );\n\n    float c1 = (0.4 - abs(0.4 - fract(x))) / 0.8 * size.x;\n    float c2 = (h - fract(y)) * size.y;\n    float c = clamp(c1, 0.0, 1.0) * clamp(c2, 0.0, 1.0);\n\n    fragColor = vec4(c, c, c, 1);\n\t\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldscz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 82, 139, 139, 920]]}
{"id": "ldsyzf", "name": "Mandelbrot Rainbow", "author": "AlainGalvan", "description": "What happens if you make a Mandelbrot look like a tangent space normal map?", "tags": ["fractal", "map", "normal"], "likes": 0, "viewed": 98, "published": "Public", "date": "1489252915", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXSTEPS 64\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 0.005 * (64. * pow(1.1 + sin(5. + (.5 * iTime)), .97));\n    \n\tvec2 uv = zoom * ((-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y) + vec2(-.745,.186);\n    \n    // Mandelbrot Main\n    vec2 z = vec2(0.);\n    for (int i = 0; i < MAXSTEPS; i++) \n    {\n        // z = z^2 + c\n        float c = 2.0;\n        z = vec2( z.x*z.x - z.y*z.y, c*z.x*z.y ) + uv;\n    }\n    \n     vec2 col1 = vec2(smoothstep(0., 1., z));\n     vec2 col2 = vec2(smoothstep(0., 1., -z));\n     vec3 outCol = vec3(col1 + col2 + vec2(.5, .5), 0.98);\n    \n     fragColor = vec4(outCol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldsyzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 78, 651]]}
{"id": "ldXcRs", "name": "360 north south", "author": "zproxy", "description": "360", "tags": ["360"], "likes": 0, "viewed": 117, "published": "Public", "date": "1489418370", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define xWebGLTexture360height iResolution.y \n#define xWebGLTexture360height iResolution.y\n\n\n#define uIPD 0.0\n    \nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1. - c;\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\n\n\n\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n \n  \nfloat stars(in vec3 p)\n{\n   \n    //vec3 q = fract(p*22.)-0.5;\n    //vec3 q = fract(p*2.)-0.5;\n    vec3 q = fract(p*3.)-0.5;\n   \n    \n\n    \n    return 1.-smoothstep(0.,.5,length(q));\n}\n\nvec3 startrails(in vec3 rd)\n{\n \n\n    //        if (rd.z < 0.)\n    //    if (rd.y < 0.)\n    //if (rd.x < 0.)\n    //return vec3(1.0, 0,0);\n    \n    float col0 = stars( normalize(rotx(rd, iTime * 0.01)));\n\n    float col = col0;\n\n    for (int i = -180; i < -30; i++)\n    {\n    \tfloat col1 = stars( normalize(rotx(rd, iTime * 0.01 + (float(i) * (1./20.) ))));\n        \n    \tcol += col1;    \n    }\n    \n    \n    if (col < 0.)\n        col = 0.;\n    if (col > 1.)\n        col = 1.;\n    \n    return vec3(1.0 - col);\n}\n\n\n\nfloat atan2(float y, float x)\n{\n  float t0, t1, t2, t3, t4;\n\n  t3 = abs(x);\n  t1 = abs(y);\n  t0 = max(t3, t1);\n  t1 = min(t3, t1);\n  t3 = float(1) / t0;\n  t3 = t1 * t3;\n\n  t4 = t3 * t3;\n  t0 =         - float(0.013480470);\n  t0 = t0 * t4 + float(0.057477314);\n  t0 = t0 * t4 - float(0.121239071);\n  t0 = t0 * t4 + float(0.195635925);\n  t0 = t0 * t4 - float(0.332994597);\n  t0 = t0 * t4 + float(0.999995630);\n  t3 = t0 * t3;\n\n  t3 = (abs(y) > abs(x)) ? float(1.570796327) - t3 : t3;\n  t3 = (x < 0.) ?  float(3.141592654) - t3 : t3;\n  t3 = (y < 0.) ? -t3 : t3;\n\n  return t3;\n}\n\n void mainImage0( out vec4 fragColor, in vec2 fragCoord, vec2 thetaphi, vec3 rd, float IPD )\n {\n  \n    vec3 col = startrails( rd);\n\n  \n\n    //float tOver = clamp(iTimeDelta-(1./60.),0.,1.);\n    \n    \n    //col = (col + past.rgb) * 0.995;\n    //col = (col + past.gbr) * 0.995;\n    \n    \n\tfragColor = vec4(col, 1.0);\n }\n\n \n\n// called by drawArrays\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord )\n{\n    bool drag = iMouse.w > 0.0;\n    \n    float grid = 16.;\n    float gridt = 2.;\n    \n    bool indexx = int(int(fragCoord.x  / grid) * int(grid)) == int(fragCoord.x);\n    bool indexy = int(int(fragCoord.y  / grid) * int(grid)) == int(fragCoord.y);\n    //bool indext = int(int(float(iFrame)  / grid) * int(grid)) == int(iFrame);\n    bool indext = int(int(float(iTime)  / gridt) * int(gridt)) == int(iTime);\n    \n    \n    \n    if (drag || (indext&&(indexy||indexx)))\n\n\n    {\n   if ( int(fragCoord.x + 2.) > int(iMouse.x))\n   if ( int(fragCoord.x - 2.) < int(iMouse.x))\n    {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n      if ( int(fragCoord.y + 2.) > int(iMouse.y))\n   if ( int(fragCoord.y - 2.) < int(iMouse.y))\n    {\n        fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n        return;\n    }\n    }\n  \n\n\t\n\tbool RvL = true;\n\t \n\tvec4 fragColorR = vec4(1.0, 0.0, 0.0, 1.0);\n\tvec2 fragCoordR = vec2(gl_FragCoord.x, gl_FragCoord.y / 1.0);\n\tvec2 texCoordR0 = vec2((iResolution.x - fragCoordR.x)/iResolution.x, fragCoordR.y/(iResolution.y/1.0))  + vec2(0.25, 0.0);\n\tvec2 thetaphiR = ((texCoordR0 * vec2(2.0, 2.0)) - vec2(1.0)) * vec2(3.1415926535897932384626433832795, 1.5707963267948966192313216916398); \n\t\n    vec3 rd = vec3(\n        // x:\n        cos(thetaphiR.y) * cos(thetaphiR.x ), \n        // y:\n        sin(thetaphiR.y), \n        \n        // z:\n        cos(thetaphiR.y) * sin(thetaphiR.x )\n    );\n    \n    \n       //rd *= rotationMatrix(vec3(1.0, 0.0, 0.0), 90.);\n    \n    rd *= rotationMatrix(vec3(0.0, 1.0, 0.0), ((-0. -  iMouse.x * 2.) / 360.) * 3.14);\n    //rd *= rotationMatrix(vec3(0.0, 0.0, 1.0), 90.);\n    rd *= rotationMatrix(vec3(0.0, 0.0, 1.0), ((90. + cos(iTime) * 1. -  iMouse.y * 2.0) / 360.) * 3.14);\n    \n    \n //  \n //  float thetaphiR_y_sin = rd.y;\n //  float thetaphiR_y = asin(rd.y);\n\n //  //float thetaphiR_x_sin = rd.z / cos(asin(rd.y));\n //  \n //  float thetaphiR_x_viaasin = asin(rd.z / cos(thetaphiR_y)) + 1.0;\n //  \n //  // red\n //  float thetaphiR_x_viaacos = acos( rd.z / cos(thetaphiR_y)) + 1.0;\n //  \n  //  float thetaphiR_x2 = asin(rd.x / cos(asin(rd.y)));\n    \n    \n    //\n\t//mainImage0(\n\t//fragColorR, \n\t// fragCoordR, \n\t//thetaphiR , \n\t// rd, \n\t// uIPD  \n\t//\n\t//);\n\t\n\t// lets not shadow the non stereo area.\n\t//fragColorLvR.rgb *= \n\t//\t1.0 - abs(RvL ? thetaphiR.y : thetaphiL.y) * 0.6;\n\t\n  \n //   float thetaphiR_x_viaacos_fixup = thetaphiR_x_viaacos;\n    \n    \n   // bool edge = abs(thetaphiR_y) < 1.55 && abs(thetaphiR_y) > 0.025;\n   // // show the target value near edge\n   // if ( edge   )\n   // {\n   // \n   //    if (thetaphiR_y < 0.)\n   //    {\n   //        \n   //        // thetaphiRR_x_validfor_25to75\n//\n   //         fragColorR.g = 0.;\n//\n   //         fragColorR.b = 0.;\n   //         //fragColorR.r = (thetaphiR_x_viaacos / 3.14) ;\n   //         fragColorR.r = (thetaphiR_x_viaacos_fixup / 3.14) ;\n//\n   //     }\n   //     else\n   //     {\n//\n   //         fragColorR.g = 0.;\n//\n   //         fragColorR.r = 0.;\n   //         fragColorR.b = thetaphiR_x_viaasin / 3.14;\n   //     }\n   // }\n   // else\n   // {\n   //     \n   //     \n   // \tif (thetaphiR.y < 0.)\n   //    {\n//\n   //         fragColorR.g = 0.;\n//\n   //         fragColorR.b = 0.;\n   //         fragColorR.r = thetaphiR.x  / 3.14;\n//\n   //     }\n   //     else\n   //     {\n//\n   //         fragColorR.g = 0.;\n//\n   //         fragColorR.r = 0.;\n   //         fragColorR.b = thetaphiR.x  / 3.14;\n   //     }\n   // }\n    \n    \n    //if(indext)\n    {\n   \t\t// lat=atan2(z,sqrt(x*x+y*y))\n        // lng=atan2(y,x)\n        \n        // http://http.developer.nvidia.com/Cg/atan2.html\n        \n        vec3 rdn = normalize(rd);\n        \n        float lng = atan2(rd.y, rd.x);\n        \n        \n        //  arccos(sqrt(x^2+y^2)/x)\n         //float lat=atan2(sqrt(rdn.x*rdn.x+rdn.y*rdn.y),rdn.z);\n         //float lat=acos(sqrt(rdn.x*rdn.x+rdn.y*rdn.y)*sign(rdn.y));\n        float lat=acos(rdn.x);\n        // 0..314\n    //if (lat > 1.2)\n   \n        \n        // show y\n        \n        //if (lat < 3.0)\n        {\n            // north is red\n            \n            fragColorR.r = lat / 3.14;\n            fragColorR.b = 1.-lat / 3.14;\n        }\n            \n     //fragColorR.g = (lat + 1.) / 2.0;\n    \n    }\n    \n\n\n\tfragColor = fragColorR;\n    \n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldXcRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 117, 162, 162, 628], [635, 635, 662, 662, 750], [756, 756, 780, 849, 939], [941, 941, 970, 1077, 1449], [1453, 1453, 1484, 1484, 2027], [2030, 2030, 2124, 2124, 2346], [2351, 2375, 2432, 2432, 6700]]}
{"id": "ldXcRX", "name": "Cubic Bezier", "author": "rhino1181", "description": "Basic Bezier curve", "tags": ["2d", "bezier"], "likes": 1, "viewed": 122, "published": "Public", "date": "1489063406", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 Rect(vec2 uv, vec2 pos, float width, float height, vec4 color, out bool isThis)\n{\n    if((uv.x > (pos.x - (width / 2.0))) && (uv.x < (pos.x + (width / 2.0))) &&\n       (uv.y > (pos.y - (height / 2.0))) && (uv.y < (pos.y + (height / 2.0))))\n    {\n        isThis = true;\n        return color;\n    }\n    \n    return vec4(0.0);\n}\n\nbool MouseCheck(vec2 pos, float width, float height)\n{\n    if((iMouse.x > (pos.x - (width / 2.0))) && (iMouse.x < (pos.x + (width / 2.0))) &&\n       (iMouse.y > (pos.y - (height / 2.0))) && (iMouse.y < (pos.y + (height / 2.0))))\n    {\n        return true;\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    \n    vec2 posOne = vec2(20.0, 20.0);  \n    vec2 posTwo = vec2(iResolution.x / 5.0, iResolution.y - 20.0);\n    vec2 posThree = vec2(iResolution.x / 1.2, iResolution.y - 20.0);\n    vec2 posFour = vec2(iResolution.x - 20.0, 20.0);\n\n    //if(MouseCheck(posOne, 50.0, 50.0))\n    //\tposOne = iMouse.xy;\n    \n    vec4 curveColor = vec4(0.437,1.0,0.687,1.0);\n    vec4 mainNodeColor = vec4(1.0,0.216,0.292,1.0);\n    vec4 secondNodeColor = vec4(0.294,0.558,1.0,1.0);\n    \n    vec2 lerpPosOne = vec2(mix(posOne, posTwo, 0.5+0.5*(sin(iTime))));\n    vec2 lerpPosTwo = vec2(mix(posTwo, posThree, 0.5+0.5*(sin(iTime))));\n    vec2 lerpPosThree = vec2(mix(posThree, posFour, 0.5+0.5*(sin(iTime))));\n    vec2 lerpPosFour = vec2(mix(lerpPosOne, lerpPosTwo, 0.5+0.5*(sin(iTime))));\n    vec2 lerpPosFive = vec2(mix(lerpPosTwo, lerpPosThree, 0.5+0.5*(sin(iTime))));\n    vec2 lerpPosSix = vec2(mix(lerpPosFour, lerpPosFive, 0.5+0.5*(sin(iTime))));\n    \n    vec4 final = vec4(0.0);\n    \n    bool checker = false;\n    vec4 layerOne = Rect(uv, posOne, 50.0, 50.0, vec4(1.0), checker);\n    if(checker)\n        final = layerOne;\n    \n    checker = false;\n    vec4 layerTwo = Rect(uv, posTwo, 50.0, 50.0, vec4(1.0), checker);\n\tif(checker)\n        final = layerTwo;\n    \n    checker = false;\n    vec4 layerThree = Rect(uv, posThree, 50.0, 50.0, vec4(1.0), checker);\n\tif(checker)\n        final = layerThree;\n    \n    checker = false;\n    vec4 layerFour = Rect(uv, posFour, 50.0, 50.0, vec4(1.0), checker);\n\tif(checker)\n        final = layerFour;\n \n    checker = false;\n    vec4 layerFive = Rect(uv, lerpPosOne, 10.0, 10.0, mainNodeColor, checker);\n\tif(checker)\n        final = layerFive;\n    \n    checker = false;\n    vec4 layerSix = Rect(uv, lerpPosTwo, 10.0, 10.0, mainNodeColor, checker);\n\tif(checker)\n        final = layerSix;\n    \n    checker = false;\n    vec4 layerSeven = Rect(uv, lerpPosThree, 10.0, 10.0, mainNodeColor, checker);\n\tif(checker)\n        final = layerSeven;\n    \n    checker = false;\n    vec4 layerEight = Rect(uv, lerpPosFour, 10.0, 10.0, secondNodeColor, checker);\n\tif(checker)\n        final = layerEight;\n    \n    checker = false;\n    vec4 layerNine = Rect(uv, lerpPosFive, 10.0, 10.0, secondNodeColor, checker);\n\tif(checker)\n        final = layerNine;\n    \n    checker = false;\n    vec4 layerTen = Rect(uv, lerpPosSix, 30.0, 30.0, curveColor, checker);\n\tif(checker)\n        final = layerTen;\n\n    \n    fragColor = final;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldXcRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 86, 86, 330], [332, 332, 386, 386, 618], [620, 620, 677, 677, 3124]]}
{"id": "ldXczX", "name": "Wythoff construction", "author": "mattz", "description": "All of the convex regular uniform polyhedra, in one big shader.", "tags": ["tiling", "spherical", "symmetry", "polyhedron", "wythoff", "buckyball"], "likes": 63, "viewed": 4911, "published": "Public", "date": "1489078707", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Wythoff construction demo, by mattz.\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   Mouse rotates (or click in bottom left for auto-rotate).\n\n   Keys do things:\n\n     D - toggle demo mode (no other keys work until you leave demo mode)\n\n     S - toggle sphere\n     C - toggle color scheme\n     T - toggle triangle visualizations\n\n     1,2 - toggle bits of first angle divisor (p)\n     3,4 - toggle bits of second angle divisor (q)\n     5,6 - toggle bits of third angle divisor (r)\n     7,8 - toggle bits of pipe location\n\n   Much of the code below could be simplified. There's probably a lot\n   of unnecessary normalization going on, for instance.\n\n   Also note the distance function only goes to the OUTSIDE of the\n   polyhedron, it is not a proper signed distance function (alas!)\n\n   Here are some helpful links that I used to learn about the math:\n\n     https://en.wikipedia.org/wiki/Wythoff_construction\n     http://www.gregegan.net/APPLETS/26/WythoffNotes.html\n     https://en.wikipedia.org/wiki/Spherical_polyhedron\n     https://en.wikipedia.org/wiki/List_of_uniform_polyhedra_by_Wythoff_symbol\n\n   Nope, I haven't yet figured out how to make snub polyhedra (type\n   4?) or the non-convex (star-like) uniform polyhedra yet. \n\n   I also never figured out how to antialias the edges of my raymarched shapes. Someday.\n\n   Tweet @matt_zucker with suggestions/comments/questions.\n\n*/\n\n// Here are some Wythoff symbols for well-known polyhedra:\n#define WS_TET   vec4(3,2,3,0) // Tetrahedron\n#define WS_OCT   vec4(4,2,3,0) // Octahedron\n#define WS_CUBE  vec4(3,2,4,0) // Cube\n#define WS_IKE   vec4(5,2,3,0) // Icosahedron\n#define WS_DOE   vec4(3,2,5,0) // Dodecahedron\n#define WS_CO    vec4(2,3,4,0) // Cuboctahedron\n#define WS_ID    vec4(2,3,5,0) // Icosidodecahedron\n#define WS_TUT   vec4(2,3,3,1) // Truncated tetrahedron\n#define WS_TOE   vec4(2,4,3,1) // Truncated octahedron\n#define WS_TIC   vec4(2,3,4,1) // Truncated cube\n#define WS_TI    vec4(2,5,3,1) // Truncated icosahedron \n#define WS_TID   vec4(2,3,5,1) // Truncated dodecahedron\n#define WS_SIRCO vec4(3,4,2,1) // Rhombicuboctahedron\n#define WS_SRID  vec4(3,5,2,1) // Rhombicosidodecahedron\n#define WS_GIRCO vec4(2,3,4,2) // Truncated cuboctahedron\n#define WS_GRID  vec4(2,3,5,2) // Truncated icosidodecahedron\n\n// Symbol of polyhedron to render.\nvec4 wythoff_symbol = WS_IKE;\n\n//////////////////////////////////////////////////////////////////////\n// Toggles for display:\n\nfloat demo_mode = 1.0;\nfloat color_by_face = 1.0;\nfloat show_triangles = 0.0;\nfloat sphericity = 0.0;\n\n// Demo also scales up/down object\nfloat scale = 1.0;\n\n//////////////////////////////////////////////////////////////////////\n// Keys and other handy constants:\n\nconst float KEY_C = 67.5/256.0;\nconst float KEY_D = 68.5/256.0;\nconst float KEY_R = 82.5/256.0; \nconst float KEY_S = 83.5/256.0;\nconst float KEY_T = 84.5/256.0;\n\nconst float KEY_1 = 49.5/256.0;\nconst float KEY_2 = 50.5/256.0;\nconst float KEY_3 = 51.5/256.0;\nconst float KEY_4 = 52.5/256.0;\nconst float KEY_5 = 53.5/256.0;\nconst float KEY_6 = 54.5/256.0;\nconst float KEY_7 = 55.5/256.0;\nconst float KEY_8 = 56.5/256.0;\n\nconst float pi = 3.141592653589793;\n\nconst float farval = 1e5;\n\nconst vec3 bg_color = vec3(0.9);\n\nconst mat3 basic_palette = mat3(vec3(1,1,0),\n                                vec3(1,0,0),\n                                vec3(0,0,1));\n\n// Light vector\nvec3 L = normalize(vec3(1.0, 0.5, 2.0));\n\n//////////////////////////////////////////////////////////////////////\n// Compare key state to default\n\nfloat key_state(float key, float default_state) {\n    return abs( texture(iChannel0, vec2(key, 0.75)).x - default_state );\n}\n\n//////////////////////////////////////////////////////////////////////\n// Axis-aligned rotations\n\nmat3 rot_x(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\nmat3 rot_y(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n}\n\nmat3 rot_z(in float t) {\n    float cz = cos(t), sz = sin(t);\n    return mat3(cz, -sz, 0.,\n                sz, cz, 0.,\n                0., 0., 1.);\n}\n\n//////////////////////////////////////////////////////////////////////\n// Constructs a spherical triangle from angle divisors p,q,r. The\n// three great circles will meet at angles pi/p, pi/q, pi/r.\n//\n// Great circles are represented as unit vectors corresponding to\n// their antipode. For instance, the great circle along the xy plane\n// is simply the vector (0, 0, 1).\n//\n// Everything you ever want to do with points and lines on spheres\n// boils down to dot products and cross products.\n//\n// If two great circles l1 and l2 meet at an angle theta, then\n//\n//   dot(l1, l2) = -cos(theta) = cos(pi - theta)\n//\n// So if the great circles are perpendicular, dot(l1, l2) = 0. And if\n// a unit vector v lies on a great circle l, then dot(l, v) = 0, too.\n//\n// This returns tri, a matrix of great circles. If a point v is inside\n// the triangle, then dot(tri[i], p) > 0 for all i.\n\nmat3 construct_tri(in vec3 pqr) {\n\n    // take pi/p, pi/q, pi/r\n    vec3 angles = pi/pqr;\n\n    // get cosines\n    vec3 c = cos(angles);\n\n    // only need sin(pi/p)\n    float sp = sin(angles.x);\n\n    // We want to construct three great circles l1, l2, l3 with the\n    // following properties:\n    //\n    //   dot(l1, l2) = -cp\n    //   dot(l2, l3) = -cq\n    //   dot(l3, l1) = -cr\n\n    // Without loss of generality we can fix one great circle at (1, 0, 0):\n    vec3 l1 = vec3(1, 0, 0);\n\n    // The next one is simply rotated by pi/p radians along the z axis:\n    vec3 l2 = vec3(-c.x, sp, 0);\n\n    // Now we need to solve a linear system:\n    //\n    //   dot(l3, l1) = x3*1 + y3*0 + z3*0 = x3 = -cr\n    //   dot(l3, l2) = -x3*cp + y3*sp + z3*0 = -cq\n    //\n    // Substituting 1 into 2, we get cr*cp + y3*sp = -cq, which means\n    // y3 = -(cq + cr*cp)/sp\n    float x3 = -c.z;\n    float y3 = -(c.y + c.x*c.z)/sp;\n\n    // z3 is chosen to make sure that l3 is a unit vector\n    float z3 = sqrt(1.0 - x3*x3 - y3*y3);\n    \n    vec3 l3 = vec3(x3, y3, z3);\n\n    // Now we have all our great circles\n    return mat3(l1, l2, l3);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// This ridiculously handy function helps us solve a bunch of problems\n// thanks to point-line duality:\n//\n//   - it constructs one of the two points of intersection of the\n//     great circles a & b\n//\n//   - it constructs the great circle passing through the unit vectors\n//     a & b on the sphere\n//\n//   - it constructs the altitude from a point a to line b, or from a\n//     line a to a point b.\n\nvec3 intersect(vec3 a, vec3 b) {\n    return normalize(cross(a, b));\n}\n\n//////////////////////////////////////////////////////////////////////\n// Constructs the great circle bisecting the angle formed by two great\n// circles l1 and l2.\n\nvec3 bisect(vec3 l1, vec3 l2) {\n    return intersect(cross(l1, l2), 0.5*(l1+l2));\n}\n\n//////////////////////////////////////////////////////////////////////\n// Given a spherical triangle and a point x on a sphere, this\n// repeatedly mirrors x along edges of the triangle until it lands\n// inside.\n//\n// When I started this project, I thought I was going to have to\n// mirror the triangle until it landed on the point, but it turns out,\n// with all of the cross products flying around, that you have to\n// track the parity (even or odd) if you flip the triangle, and it\n// proved to be too much bookkeeping.\n//\n// Frankly, I'm not exactly sure why this works, or why 15 flips is\n// the magic number that gets every point inside the destination\n// triangle.\n//\n// I'm probably going to make another shader at some point to try to\n// understand why this converges. \n//\n// Upon return: the point x is inside the triangle, and the matrix M\n// holds the product of all mirror transformations. Its determinant\n// (not actually used anywhere except for visualization) is -1 for odd\n// number of flips, +1 for even.\n\nvoid flip_into_tri(in mat3 tri,\n                   inout vec3 x,\n                   out mat3 M) {\n    \n    // d holds signs of point/edge decisions for each edge of the triangle.\n    // if its components are all non-negative, we win.\n    vec3 d = x * tri; \n\n    // initialize M as the identity transformation\n    M = mat3(1.0);\n\n    // 5 iterations is the magic number\n    for (int k=0; k<5; ++k) {    \n\n        // if inside already, quit flippin'\n        if (min(d[0], min(d[1], d[2])) >= 0.0) { break; }\n\n        // for each edge of the triangle\n        for (int j=0; j<3; ++j) {\n\n            // if we are \"outside\" this edge\n            if (d[j] < 0.0) {\n\n                // flip along this edge\n                vec3 tj = tri[j];                \n\n                // update M by flipping each column\n                M = mat3(reflect(M[0], tj),\n                         reflect(M[1], tj),\n                         reflect(M[2], tj));\n\n                // reflect x\n                x = reflect(x, tj);\n\n                // update d\n                d = x * tri;\n                \n            }\n        }\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Precondition: we have flipped point x into the triangle. Now we do\n// the meat of the Wythoff construction method. First, we choose a\n// vertex, tri_vert, inside the triangle, according to the type of\n// triangle:\n//\n//    p | q r : the vertex is placed at point P\n//\n//    p q | r : the vertex is placed at the point on PQ that bisects\n//              the angle at R\n//\n//    p q r | : the vertex is placed at the incenter (intersection of\n//              bisectors)\n//\n// Then from the given vertex, we drop altitudes to one or more edges\n// of the triangle. Those altitudes will correspond the edges of our\n// polyhedron, and the vertex itself will become a polyhedron vertex.\n//\n// Once the point and altitudes are constructed, we need to classify x\n// as being in one of up to three possible regions (corresponding to\n// red, yellow, and blue in the simple color display) created by\n// splitting the triangle along the altitudes.\n//\n// In addition to which of the three regions we are selecting (encoded\n// as a one-hot vec3), we also compute the normal point (the triangle\n// vertex corresponding to that region), and the great circle\n// corresponding to the closest polyhedron edge.\n//\n// The dot product between x and edge may be positive or negative.\n\nvoid check_domain(in mat3 tri,\n                  in vec3 x,\n                  in float type,\n                  out vec3 tri_vert,\n                  out vec3 tri_region,\n                  out vec3 face_normal,\n                  out vec3 edge) {\n        \n    // Construct the three triangle vertices\n    vec3 p0 = intersect(tri[1], tri[2]); // Q\n    vec3 p1 = intersect(tri[2], tri[0]); // R\n    vec3 p2 = intersect(tri[0], tri[1]); // P\n     \n\n    // Place vertex for each type\n    if (type == 0.0) {\n        \n        // Place the vertex at P\n        tri_vert = p2;\n        \n    } else { \n        \n        // Bisect the angle at R\n        vec3 l_b1 = bisect(tri[2], tri[0]);\n\n        if (type == 1.0) {\n\n            // Get the intersection with edge PQ\n        \ttri_vert = intersect(l_b1, tri[1]);\n        \n        } else {\n        \n            // Place the vertex at the incenter\n            vec3 l_b2 = bisect(tri[0], tri[1]);\n            tri_vert = intersect(l_b1, l_b2);\n            \n        }\n        \n    }\n        \n    // In the worst case we will have to look at all three\n    // altitudes, so we might as well construct them now.\n    vec3 l_a0 = intersect(tri_vert, tri[0]);\n    vec3 l_a1 = intersect(tri_vert, tri[1]);\n    vec3 l_a2 = intersect(tri_vert, tri[2]);\n\n    // The altitudes were constructed so they all wind the same\n    // direction around the point p. That gives the code below\n    // some nice symmetry:\n    float d0 = dot(x, l_a0);\n    float d1 = dot(x, l_a1);\n    float d2 = dot(x, l_a2);\n\n    if (d1 < 0.0 && d2 >= 0.0) {\n        tri_region = vec3(1.0, 0, 0);\n        edge = abs(d1) < abs(d2) ? l_a1 : l_a2;\n    } else if (d2 < 0.0 && d0 >= 0.0) {\n        tri_region = vec3(0, 1.0, 0);\n        edge = abs(d2) < abs(d0) ? l_a2 : l_a0;\n    } else {\n        tri_region = vec3(0, 0, 1.0);\n        edge = abs(d0) < abs(d1) ? l_a0 : l_a1;\n    }\n\n    // Once we know the region, the polyhedron face normal is just the\n    // corresponding vertex P, Q, or R.\n    face_normal = mat3(p0, p1, p2) * tri_region;\n        \n}\n\n//////////////////////////////////////////////////////////////////////\n// Wrapper function for the functions above. Four main steps:\n//\n//   1) construct the spherical triangle\n//   2) flip the point x until it lies inside\n//   3) figure out what region of the triangle x is in\n//   4) clean up by mapping the triangle vertex, normal, and edge\n//      through the inverse of the transform that x underwent\n\nvoid wythoff(in vec4 wythoff_symbol, \n             in vec3 x,\n             out mat3 tri,\n             out mat3 M,\n             out vec3 tri_vert,\n             out vec3 tri_region,\n             out vec3 face_normal,\n             out vec3 edge) {\n\n    vec3 pqr = wythoff_symbol.xyz;\n    float type = wythoff_symbol.w;\n\n    // step 1\n    tri = construct_tri(pqr);\n\n    // step 2\n    flip_into_tri(tri, x, M);\n\n    // step 3\n    check_domain(tri, x, type, tri_vert, tri_region, face_normal, edge);\n\n    // step 4\n    face_normal = face_normal * M;\n    tri_vert = tri_vert * M;\n    edge = edge * M;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Distance function for raymarching.\n\nfloat map(in vec3 pos) {\n\n    // Handle scaling\n    pos /= scale;\n\n    // Get length of point & distance to sphere\n    float d = length(pos);\n    float d_sphere = d - 1.0;\n\n    // Do wythoff construction\n    mat3 tri, M;\n    vec3 tri_vert, tri_region, face_normal, edge;\n    \n    wythoff(wythoff_symbol, pos, tri, M, \n            tri_vert, tri_region, face_normal, edge);\n\n    // Compute distance to exterior of polyhedron\n    float d_poly = dot(pos, face_normal) - dot(face_normal, tri_vert);\n\n    // Mix polyhedron/sphere and go\n    return mix(d_poly, d_sphere, sphericity) * scale;\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// RGB from hue\n\nvec3 hue(float h) {\n    vec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n    return h >= 1.0 ? vec3(h-1.0) : clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\n//////////////////////////////////////////////////////////////////////\n// IQ's normal calculation\n\nvec3 calc_normal( in vec3 pos ) {\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n                    map(pos+eps.xyy) - map(pos-eps.xyy),\n                    map(pos+eps.yxy) - map(pos-eps.yxy),\n                    map(pos+eps.yyx) - map(pos-eps.yyx) );\n    return normalize(nor);\n}\n\n//////////////////////////////////////////////////////////////////////\n// Based on IQ's ray marcher\n\nvec2 cast_ray( in vec3 ro, in vec3 rd) {\n\n    const int rayiter = 25;\n    const float dmax = 20.0;\n    \n    const float precis = 0.01;   \n    float h=8.0;\n\n    float t = 0.0;\n    float m = 1.0;\n\n    for( int i=0; i<rayiter; i++ ) {\n        if( abs(h)<precis||t>dmax ) continue;//break;\n        t += h;\n        h = map( ro+rd*t );\n    }    \n\n    if (t > dmax) {\n        m = -1.0;\n    }\n\n    return vec2(t, m);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// Color for ray\n\nvec3 shade(vec3 ro, vec3 rd) {\n\n    // Do raymarching\n    vec2 tm = cast_ray(ro, rd);\n\n    if (tm.y < 0.0) {\n\n        // No hit\n        return bg_color;\n\n    } else {\n\n        // We hit the polyhedron\n        vec3 p = ro + rd*tm.x;\n\n        // Redo Wythoff construcion to get vertex, region, normal, edge.\n        vec3 x = normalize(p);\n\n        mat3 tri, M;\n        vec3 tri_vert, tri_region, face_normal, edge;\n    \n        wythoff(wythoff_symbol, x, tri, M, \n                tri_vert, tri_region, face_normal, edge);\n\n        //////////////////////////////////////////////////\n        // Black lines\n\n        // Look at distance from edge to draw black lines\n        float d_black = abs(dot(edge, x)) - 0.005;\n\n        // Look at points on sphere\n        d_black = min(d_black, length(x - tri_vert) - 0.03*sphericity);\n\n        // Distance to coverage\n        float k_black = smoothstep(0.0, 0.01, d_black);\n\n        //////////////////////////////////////////////////\n        // Face coloring\n        \n        // Normal to RGB\n        vec3 per_face_color = face_normal*0.5 + 0.5;\n\n        // Red/Yellow/Blue\n        vec3 basic_color = basic_palette * tri_region;\n        \n        // Mix per-face/basic\n        vec3 base_color = mix(basic_color, per_face_color, color_by_face);\n\n        //////////////////////////////////////////////////\n        // Even/odd triangle coloring\n\n        // Light version of color for even triangles\n        vec3 lighter = 0.6*base_color + 0.4;\n\n        // Signed distances to triangle edge (note always positive\n        // cause M*x is guaranteed inside triangle)\n        vec3 d = M * x * tri;\n\n        // Get min dist for shading\n        float tri_dist = min(d.x, min(d.y, d.z));\n\n        // For odd triangles\n        vec3 darker = lighter * 0.8;\n\n        // In-between color for AA\n        vec3 mid = lighter * 0.9;\n\n        // Compute parity as determinant of reflection matrix\n        float parity = dot(M[0], cross(M[1], M[2]));\n\n        // Base color for even/odd\n        vec3 tri_color = parity < 0.0 ? darker : lighter;\n\n        // AA\n        tri_color = mix(mid, tri_color,\n                        smoothstep(0.0, 0.005, abs(tri_dist)));\n\n        //////////////////////////////////////////////////\n        // Final shading\n\n        vec3 final_color = mix(base_color, tri_color, show_triangles);\n      \n        vec3 n = calc_normal(p);\n    \n        float nDotL = clamp(dot(n, L), 0.0, 1.0);\n\n        return k_black * final_color * (nDotL * 0.5 + 0.5);\n\n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// Decode numbers 2,3,4,5 or 0,1,2,3 from two key toggles. This is\n// a very gross user interface\n\nfloat keys_to_num(float key, float default_value, float bias) {\n\n    default_value -= bias;\n\n    float hi = key_state(key, floor(default_value/2.0));\n    float lo = key_state(key+1.0/256.0, mod(default_value, 2.0));\n\n    return 2.0*hi + lo + bias;\n  \n}\n\n//////////////////////////////////////////////////////////////////////\n// Does GLSL support constant arrays across the board yet? \n\nvec4 choose_shape(float index) {\n\n    if (index < 1.0) {\n        return WS_TET;\n    } else if (index < 2.0) {\n        return WS_OCT;\n    } else if (index < 3.0) {\n        return WS_CUBE;\n    } else if (index < 4.0) {\n        return WS_IKE;\n    } else if (index < 5.0) {\n        return WS_DOE;\n    } else if (index < 6.0) {\n        return WS_CO;\n    } else if (index < 7.0) {\n        return WS_ID;\n    } else if (index < 8.0) {\n        return WS_TUT;\n    } else if (index < 9.0) {\n        return WS_TOE;\n    } else if (index < 10.0) {\n        return WS_TIC;\n    } else if (index < 11.0) {\n        return WS_TI;\n    } else if (index < 12.0) {\n        return WS_TID;\n    } else if (index < 13.0) {\n        return WS_SIRCO;\n    } else if (index < 14.0) {\n        return WS_SRID;\n    } else if (index < 15.0) {\n        return WS_GIRCO;\n    } else {\n        return WS_GRID;\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Distance to character in SDF font texture\n\nfloat font2d_dist(vec2 tpos, float size, vec2 offset) {\n\n    float scl = 0.63/size;\n    vec2 uv = tpos*scl;\n    vec2 font_uv = (uv+vec2(0.3, 0.2)+offset)*(1.0/16.0);\n    \n    float k = texture(iChannel1, font_uv, -100.0).w + 1e-6;\n    \n    vec2 box = abs(uv-vec2(0.2, 0.3))-0.5;\n        \n    return max(k-127.0/255.0, max(box.x, box.y))/scl;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Generate label for Wythoff symbol using SDF font texture\n\nvec2 label_symbol(vec2 text_pos, float text_size) {\n    \n    float d = farval;\n    \n    for (int i=0; i<3; ++i) {\n        d = min(d, font2d_dist(text_pos, text_size, vec2(wythoff_symbol[i], 12.0)));\n        text_pos -= vec2(1.0, 0)*text_size;\n        \n        if (wythoff_symbol.w == float(i)) {\n            text_pos += vec2(0.25, 0) * text_size;\n            d = min(d, font2d_dist(text_pos, text_size, vec2(12.0, 8.0)));\n            text_pos -= vec2(0.75, 0) * text_size;\n        }      \n        \n    }\n    \n    return vec2(smoothstep(vec2(0.0), vec2(1.0), d - vec2(2.0, 0.0)));\n    \n}\n\n\n\n//////////////////////////////////////////////////////////////////////\n// Main program\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 fragCoordText = fragCoord;\n    float reveal_mode = key_state(KEY_R, 0.0);\n    \n    demo_mode = key_state(KEY_D, demo_mode);\n    float text_size = 24.0;\n\n    if(reveal_mode > 0.0 && demo_mode == 0.0) {\n        \n        wythoff_symbol.x =     2.0 * abs( floor(2.0*fract(4.0*fragCoord.x/iResolution.x)) - floor((wythoff_symbol.x - 2.0)/2.0) ) + abs( floor(2.0*fract(8.0*fragCoord.x/iResolution.x)) - mod((wythoff_symbol.x - 2.0), 2.0) ) + 2.0;\n        wythoff_symbol.y =     2.0 * abs( floor(2.0*fract(1.0*fragCoord.x/iResolution.x)) - floor((wythoff_symbol.y - 2.0)/2.0) ) + abs( floor(2.0*fract(2.0*fragCoord.x/iResolution.x)) - mod((wythoff_symbol.y - 2.0), 2.0) ) + 2.0;\n        wythoff_symbol.z =     2.0 * abs( floor(2.0*fract(6.0*fragCoord.y/iResolution.y)) - floor((wythoff_symbol.z - 2.0)/2.0) ) + abs( floor(2.0*fract(3.0*fragCoord.y/iResolution.y)) - mod((wythoff_symbol.z - 2.0), 2.0) ) + 2.0;\n        wythoff_symbol.w = min(2.0 * abs( floor(2.0*fract(1.5*fragCoord.y/iResolution.y)) - floor((wythoff_symbol.w      )/2.0) ) + abs( floor(1.5*fract(1.0*fragCoord.y/iResolution.y)) - mod((wythoff_symbol.w      ), 2.0) ), 2.0);\n\n        fragCoordText = mod(fragCoord*3.,iResolution.xy/vec2(16,12)*3.);\n        fragCoord = mod(fragCoord*vec2(16,12),iResolution.xy)*vec2(1,16./12.);\n        fragCoord.y -= iResolution.y*.125;\n        text_size = 24.0;\n        \n\n    }\n \n    //////////////////////////////////////////////////\n    // Set up model view and projection\n    \n    float t = iTime;\n    \n    const vec3 tgt = vec3(0);\n    const vec3 cpos = vec3(1.0,1.0,1.0)*10.005;\n    const vec3 up = vec3(0, 0, 1);\n    const float fovy = 0.125;\n\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) * fovy / (iResolution.y);\n\n    vec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,up)),\n        ry = cross(rx,rz);\n         \n    float thetay = t * 0.6;\n    float thetax = t * 0.3;\n\n    if (max(iMouse.x, iMouse.y) > 20.0) { \n        thetax = (iMouse.y - .5*iResolution.y) * -4.5/iResolution.y; \n        thetay = (iMouse.x - .5*iResolution.x) * 4.0/iResolution.x; \n    }\n\n    mat3 Rmouse = rot_x(thetax)*rot_y(thetay);\n    mat3 Rview = mat3(rx,ry,rz)*Rmouse;    \n    L = Rview*Rmouse*(L*Rview);\n  \n    vec3 rd = Rview*normalize(vec3(uv, 1.)),\n        ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n\n    //////////////////////////////////////////////////\n    // Inititialize Wythoff symbol and settings\n    \n\n    if (demo_mode > 0.0) {\n\n        const float d_scale = 1.0;\n        const float d_long = 5.0;\n\n        const float t_appear = 0.5;\n        const float t_big = t_appear + d_scale;\n        const float t_poly_start = t_big + d_long;\n        const float t_poly_end = t_poly_start + 0.5;\n        const float t_color_start = t_poly_end + d_long;\n        const float t_color_end = t_color_start + 0.5;\n        const float t_shrink = t_color_end + d_long;\n        const float t_final = t_shrink + d_scale;\n        \n        float stage = floor(t / t_final);\n        float ts = mod(t, t_final);\n\n        sphericity = smoothstep(t_poly_end, t_poly_start, ts);\n\n        show_triangles = sphericity;\n        \n        color_by_face = smoothstep(t_color_start, t_color_end, ts);\n\n        scale = min(smoothstep(t_appear, t_big, ts),\n                    smoothstep(t_final, t_shrink, ts));\n        \n        float shape = mod(stage + 3.0, 16.0);\n\n        wythoff_symbol = choose_shape(shape);\n\n    } else {\n\n        color_by_face = key_state(KEY_C, color_by_face);\n        show_triangles = key_state(KEY_T, show_triangles);\n        sphericity = key_state(KEY_S, 0.0);\n    \n        if (reveal_mode == 0.0) {\n            wythoff_symbol.x = keys_to_num(KEY_1, wythoff_symbol.x, 2.0);\n            wythoff_symbol.y = keys_to_num(KEY_3, wythoff_symbol.y, 2.0);\n            wythoff_symbol.z = keys_to_num(KEY_5, wythoff_symbol.z, 2.0);\n            wythoff_symbol.w = min(keys_to_num(KEY_7, wythoff_symbol.w, 0.0), 2.0);\n        }\n\n    }\n\n    //////////////////////////////////////////////////\n    // Now composite our scene\n\n    // Don't attempt to render obviously bogus polyhedra.\n    bool valid = dot(1.0/wythoff_symbol.xyz, vec3(1.0)) > 1.0;\n\n    vec3 scene_color = bg_color;\n    vec3 text_color = valid ? vec3(0) : vec3(0.7, 0, 0);\n\n    if (valid && scale > 0.0) {\n        scene_color = shade(ro, rd);\n        text_color = vec3(0);\n    }\n\n    // Composite in text\n    vec2 text_pos = fragCoordText.xy - 12.49;\n\n    vec2 k = label_symbol(text_pos, text_size);\n\n    scene_color = mix(bg_color, scene_color, k.x);\n    scene_color = mix(text_color, scene_color, k.y);\n\n    // Done!\n    fragColor = vec4(scene_color, 1.0);\n\t\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldXczX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[3460, 3564, 3613, 3613, 3688], [3690, 3788, 3812, 3812, 3933], [3935, 3935, 3959, 3959, 4079], [4081, 4081, 4105, 4105, 4229], [4231, 5110, 5143, 5173, 6237], [6239, 6713, 6745, 6745, 6782], [6784, 6949, 6980, 6980, 7032], [7034, 8056, 8153, 8289, 9168], [9170, 10505, 10748, 10802, 12542], [12544, 12951, 13195, 13195, 13551], [13553, 13663, 13687, 13710, 14250], [14252, 14340, 14359, 14359, 14476], [14478, 14577, 14610, 14610, 14873], [14875, 14976, 15016, 15016, 15387], [15389, 15478, 15508, 15531, 17980], [17982, 18152, 18215, 18215, 18404], [18406, 18538, 18570, 18570, 19418], [19420, 19537, 19592, 19592, 19885], [19887, 20019, 20070, 20070, 20605], [20609, 20697, 20754, 20754, 25383]]}
{"id": "ldXyRs", "name": "sin curve'n stuff", "author": "Pinillya", "description": "Trying a tutorial", "tags": ["smily"], "likes": 2, "viewed": 117, "published": "Public", "date": "1490451483", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle (float rad, vec2 position, vec2 uv, float blur)\n{\n    float dist = length(uv-position);\n   \tfloat c = smoothstep(rad, rad-blur, dist);\n    return c;\n}\n\nfloat Band(float t, float start, float end, float blur)   \n{\n    float step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    return step1 * step2;\n}\n\nfloat Rect(vec2 uv, float left, float right, float bott, float top, float blur)\n{\n    float rect = Band(uv.x, left, right, blur);\n    rect *= Band(uv.y, bott, top, blur);\n    return rect;\n}\n\nfloat remap01(float a, float b, float t)\n{\n \treturn (t-a) / (b-a);\n}\n\nfloat remap(float a, float b, float c, float d, float t)\n{\n \treturn remap01(a, b, t) * (d-c) + c; \n}\n\nfloat Smily (vec2 uv, float size, vec2 position)\n{\n    float face = Circle(0.5*size, vec2(.0)+position, uv, 0.03*size);\n    \n    face -= Circle(0.1*size, vec2(-.13*size, .2*size)+position, uv, 0.01*size);\n    face -= Circle(0.1*size, vec2(.13*size, .2*size)+position, uv, 0.01*size);\n    \n    float mouth = Circle(0.35*size, vec2(.0, .0)+position, uv, 0.01*size);\n    mouth -= Circle(0.35*size, vec2(.0, .1*size)+position, uv, 0.01*size);\n        \n    face -= mouth;\n    \n  \treturn face;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; // uv.y 1 on top of screen pixel coordiant\n    float t = iTime;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    float x = uv.x;\n    float y = uv.y;\n    \n    //vec3 col = vec3(1., 0., 1.);\n\t//float smily = Smily(uv, 1.1, vec2(.2, .1));\n    //col *= mask;\n  \t//col *= vec3(1., 1., 1.);\n    //col *= mask;\n    \n    //x += y*0.2;\n    \n    float m = sin(t + x * 8.)* .1;\n    y -= m;\n    \n    float blur = remap(-.5, .5, .01, .25, x);\n    //blur = blur*blur;\n\t\n    blur = pow(blur*4., 3.);\n    \n    float mask = Rect(vec2(x, y), -.5, .5, -.1, .1, blur);\n    //mask += Rect(vec2(x, y), -.2 + y *.3, .1 + y * 0.7, -.2, -.0, .01);\n    fragColor = vec4(vec3(mask), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldXyRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 62, 62, 163], [165, 165, 225, 225, 363], [365, 365, 446, 446, 554], [556, 556, 598, 598, 624], [626, 626, 684, 684, 726], [728, 728, 778, 778, 1217], [1220, 1220, 1277, 1277, 1993]]}
{"id": "llySRV", "name": "fBm Domain Warping", "author": "capnslipp", "description": "Fractal Brownian Motion - Domain Warping example from https://thebookofshaders.com/13/", "tags": ["fractal", "fbm", "brownianmotion"], "likes": 18, "viewed": 1267, "published": "Public API", "date": "1488584220", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat random (in vec2 _st) { \n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))* \n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nfloat fbm ( in vec2 _st) {\n    int numOctaves = int(min(10.0, log2(iResolution.x))) - 3;\n    \n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), \n                    -sin(0.5), cos(0.50));\n    \n    // Unrolled loop; because GL won't let me compare against a non-constant.\n    if (numOctaves >= 1) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    if (numOctaves >= 2) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    if (numOctaves >= 3) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    if (numOctaves >= 4) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    if (numOctaves >= 5) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    if (numOctaves >= 6) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    if (numOctaves >= 7) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    if (numOctaves >= 8) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    if (numOctaves >= 9) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    if (numOctaves >= 10) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy*3.;\n    // st += st * abs(sin(u_time*0.1)*3.0);\n    vec3 color = vec3(0.0);\n\n    vec2 q = vec2(0.);\n    q.x = fbm( st + 0.00*iTime);\n    q.y = fbm( st + vec2(1.0));\n\n    vec2 r = vec2(0.);\n    r.x = fbm( st + 1.0*q + vec2(1.7,9.2)+ 0.15*iTime );\n    r.y = fbm( st + 1.0*q + vec2(8.3,2.8)+ 0.126*iTime);\n\n    float f = fbm(st+r);\n\n    color = mix(vec3(0.101961,0.619608,0.666667),\n                vec3(0.666667,0.666667,0.498039),\n                clamp((f*f)*4.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0,0,0.164706),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(0.666667,1,1),\n                clamp(length(r.x),0.0,1.0));\n\n    fragColor = vec4((f*f*f+.6*f*f+.5*f)*color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llySRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 183, 211, 211, 321], [323, 401, 428, 428, 812], [814, 814, 840, 840, 2384], [2386, 2386, 2443, 2443, 3221]]}
{"id": "ls2cRR", "name": "Smoke sphere ivpodvi", "author": "ivpodvi", "description": "perspective smoke sphere", "tags": ["perspectivesmokesphere"], "likes": 0, "viewed": 104, "published": "Public", "date": "1490693042", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Projection mx params\n#define fovY 1.5\n#define near 0.01\n#define far 10.0\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\n// Projection mx\nmat4 getProjection(float asp)\n{\n\tconst float tanHalfFovy = tan(fovY * 0.5);\n\tmat4 projMx = mat4(1.0 / (tanHalfFovy * asp), 0.0, 0.0, 0.0,\n                \t 0.0, 1.0 / tanHalfFovy, 0.0, 0.0,\n                \t 0.0, 0.0, -(far + near) / (far - near), -1.0,\n                \t 0.0, 0.0, -2.0 * far * near / (far - near), 0.0);\n\n    return projMx;\n}\n// View mx\nmat4 viewMx = mat4(1.0, 0.0, 0.0,0.,\n                  0.0, 1.0, 0.0, 0.0,\n                  0.0, 0.0, 1.0, 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n\n// sphere\n#define sphPos vec3(0.0, 0.0, -3.0)\n#define sphR 0.5\n#define PI 3.1415\n#define TwoPI 2.0 * PI\n\nconst float maxDepth = 4.7;\nconst int stepsNum = 200;\n\nfloat getFog(vec3 coord)\n{\n    float value = 0.0;\n    vec4 tex = 1.0 - texture(iChannel0, coord.xy);\n\n    value = tex.r + sin(((2.0 * tex.r - 1.0) + iTime * 0.3) * TwoPI) * 0.5;\n\n    return value * 0.5;\n}\n\nfloat intersectSphere(Ray ray, float angle)\n{\n    vec3 sPos = sphPos;\n    sPos.x += sin(iTime * 0.3 + angle);\n    sPos.y += cos(iTime * 0.3 + angle);\n    sPos.z += sin(iTime + angle);\n\n    float stepVal = maxDepth / float(stepsNum);\n    vec3 cur = ray.origin;\n    float value = 0.0;\n    for (int i = 0; i < stepsNum; ++i)\n    {\n        cur += ray.direction * stepVal;\n\t\tfloat d = distance(cur, sPos);\n\n        if (d > sphR)\n            continue;\n\n        float localValue = (stepVal * float(stepsNum - i) / maxDepth) * 0.1;\n        float ft = getFog(cur - sPos);\n        value += localValue * ft;\n    }\n\n    return clamp(1.0 - value, 0.0, 1.0);\n}\n\nvec3 getPixelForBox(Ray ray)\n{\n    float r = 1.0 - intersectSphere(ray, 0.0);\n    float g = 1.0 - intersectSphere(ray, TwoPI * 0.33); // Not optimal\n    float b = 1.0 - intersectSphere(ray, TwoPI * 0.66); // Not optimal\n\n    return vec3(r, g, b);\n}\n\nvec4 getPixelColor(Ray ray)\n{\n    vec4 baseColor = vec4(0.0, 0.0, 0.0, 0.0);\n    baseColor += vec4(getPixelForBox(ray), 0.0);\n\n    return baseColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    mat4 projMx = getProjection(iResolution.y / iResolution.x);\n    mat4 projInv = inverse(projMx);\n    mat4 viewInv = inverse(viewMx);\n\n    Ray ray;\n    ray.origin = (vec4(0.0, 0.0, 0.0, 1.0) * viewInv).xyz;\n    ray.direction = (vec4(uv, 1.0, 0.0) * projMx).xyz;\n\n    vec4 color = getPixelColor(ray);\n//    fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    fragColor = color;\n}\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls2cRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 149, 180, 180, 492], [657, 817, 843, 843, 1021], [1023, 1023, 1068, 1068, 1669], [1671, 1671, 1701, 1701, 1919], [1921, 1921, 1950, 1950, 2071], [2073, 2073, 2129, 2129, 2555]]}
{"id": "lsfcDs", "name": "hot plasma tunnel", "author": "balkhan", "description": "A cool little tunnel featuring nice ARTefacts. ", "tags": ["3d", "raymarching", "nolights"], "likes": 15, "viewed": 254, "published": "Public", "date": "1490832974", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Shape deformations\n//#define LESS_ARTIFACTS // 2 next defines Only works with this defined\n //#define NO_DOORS\n //#define SQUARE\n//#define BOULDERS\n#define ROTATE\n\n//#define SHOW_SUBSTRACTOR\n\n// Colors Modes (only one enabled at a time)\n#define BLACKBODY\n//#define GRIDS\n// #define GEODESIC // sub-mode of GRID\n//#define SINUSITE\n//#define HEATWAVES\n\nfloat\tt;\t\t// time\nfloat\ta;\t\t// angle used both for camera path and distance estimator\nfloat\tg;\t\t// used for coloring\nfloat\tst;\t\t// sin(t)\n\n#define I_MAX\t\t100\n#define E\t\t\t0.001\n\n#define\t\tFWD_SPEED\t-7.\t// the speed at wich the tunnel travel towards you\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec2\trot(vec2 p, vec2 ang);\nvoid\trotate(inout vec2 v, float angle);\n\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// -------------blackbody----------------- //\n\nfloat\tde_0(vec3 p)\n{\n\tfloat\tmind = 1e5;\n\tvec3\tpr = p;\n\n    #ifdef ROTATE\n    // rotate x and y based on z and time\n\trotate(pr.xy, (a)*.15) ;\n\t#endif\n    \n    // take the fractional part of the ray (p), \n    // and offset it to get a range from [0.,1.] to [-.5, .5]\n    // this is a space partitioning trick I saw on \"Data Transfer\" by srtuss : https://www.shadertoy.com/view/MdXGDr\n\tpr.xyz = fract(pr.xyz);\n\tpr -= .5;\n    \n    // magic numbers : .666 == 2/3, 2.09 == 2*(3.14/3), 4.18 == 4*(3.14/3)\n    // dephasing is needed in order to get the lattice\n    pr.y *= sin(t*1.+0.00+p.z+p.y-p.x);\n    pr.x *= sin(t*1.+2.09+p.z+p.y-p.x);\n    pr.z *= sin(t*1.+4.18+p.z+p.y-p.x);\n\n    mind = min(mind, (length(pr.xyz)-.3025));\n\treturn (mind * abs(sin(t*.05)) );\n}\n\nfloat\tde_1(vec3 p) // substractor\n{\n\tfloat\tmind = 1e5;\n\tvec3\tpr = p;\n\n    #ifndef\tLESS_ARTIFACTS\n    pr.x/=max(.01,-fract(p.z*.01)+.5+sin( (pr.y)*.3675-.5+(sin(pr.z*.25))*.3)-.5)*9.;\n    #else\n        #ifdef NO_DOORS\n\t    pr.x/=max(.15,( length(sin(p.z*.25) + p.y*.5))-.5);\n\t\t#else\n    \t #ifndef SQUARE\n         pr.x/=max(.052,-fract(p.z*.01)+.5+sin( (pr.y)*.3675-.5+(sin(pr.z*.25))*.3)-.5)*9.;\n    \t #else\n    \t pr.x/= (fract( abs(pr.y)*.06125-.9+(sin(pr.z*.5))*.1)-.5);\n    \t#endif\n     #endif\n    #endif\n    #ifdef BOULDERS\n    pr.x*=sin(p.y)-sin(p.z*2.)*.5;\n    #endif\n\tvec2\tq;\n    \n\tq = vec2(length(pr.yx) - 3., 0. );\n\n    q.y = rot(q.xy, vec2(-1., 0.)).x;\n\n\tmind = length(q) - 3.;\n\n\treturn mind;\n}\n\nfloat\tde_2(vec3 p)\n{\n    #ifdef SHOW_SUBSTRACTOR\n    return (20.-de_1(p));\n    #else\n    return (de_0(p)-de_1(p)*.125);\n    #endif\n}\n\nfloat\tscene(vec3 p)\n{\n    float\tmind = 1e5;\n    a = ( .8*(p.y*.015 + p.x*.015 + p.z *.15)  + t*3.);\n\n\trotate(p.yx, ( (a*10.)*exp(-t))*.75) ;\t// the starting spiral in the tunnel\n\tp.y += 4.;\n\tmind = de_2(p);\n\t\n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp =    vec3(0.0, 0.0, 0.0);\n    vec2\ts =    vec2(0.0, 0.0);\n    vec3\tdirr = dir;\t\t\t\t\t\t// temporary variable for rotation\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tdirr = dir;\n    \trotate(dirr.zx, .05*dist.y*st );\n    \tp = pos + dirr * dist.y;\n        #ifdef GRIDS\n        g = p.z*p.y*p.x*.001;\n        g -= (step(sin(5.*p.z-1.57), .5) * step(sin(5.*p.x-1.57) , .5) \n             + step(sin(20.*p.z-1.57), .5) * step(sin(20.*p.x-1.57) , .5)); \t    \n        #endif\n        dist.x = scene(p);\n        dist.y += dist.x;\n        if (dist.x < E || dist.y > 30.)\n        {\n            break;\n        }\n        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    g = 0.;\n    t  = iTime*.5;\n    st = sin(t);\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y; // Thanks Fabrice\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, t*FWD_SPEED);\n\n    vec2\tinter = (march(pos, dir));\n\n    #ifdef\tBLACKBODY\n    o.xyz = blackbody( ( 15.-inter.y+.051*inter.x ) * 75. );\n    return ;\n    #endif\n    #ifdef\tSINUSITE\n    o.xyz = inter.y*.05*vec3(abs(sin(dir.x*3.14+t+1.04)), abs(sin(dir.y*3.14+t+2.09)), abs(sin(dir.z*3.14+t+3.14)));\n    return ;\n    #endif\n    #ifdef\tGEODESIC\n\tfloat\tg = (pos+dir*inter.y).y;\n    #endif\n    #ifdef\tGRIDS\n   \to.xyz = vec3(abs(sin(t+1.32+1.04*g)), abs(sin(t+1.32+2.09*g)), abs(sin(t+1.32+3.14*g)))*inter.x*.005;\n    return ;\n\t#endif\n    #ifdef\tHEATWAVES\n    o.xyz = vec3(abs(sin(t+1.04+(15.-inter.y*.05) )), abs(sin(t+2.09+(15.-inter.y*.05) )), abs(sin(t+3.14+(15.-inter.y*.05) )));\n    return ;\n    #endif\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsfcDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[843, 1065, 1093, 1093, 1418], [1420, 1467, 1487, 1487, 2223], [2225, 2225, 2260, 2260, 2928], [2930, 2930, 2950, 2950, 3062], [3064, 3064, 3085, 3085, 3293], [3295, 3295, 3327, 3327, 4026], [4028, 4028, 4069, 4069, 4984], [4986, 5000, 5040, 5040, 5115], [5117, 5117, 5145, 5145, 5253], [5255, 5255, 5277, 5277, 5483]]}
{"id": "lsfcWB", "name": "Bouncing Curves", "author": "jscoggin", "description": "bouncing curves", "tags": ["procedural"], "likes": 1, "viewed": 78, "published": "Public", "date": "1489629127", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scaledTime = iTime / 10.0;\n    vec4 color = vec4(cos(scaledTime + 10.0), cos(scaledTime + 20.0), cos(scaledTime + 30.0), 1.0);\n    float height = sin(fragCoord.x / cos(iTime / 50.0)) + 1.0;\n    if(height > fragCoord.y / iResolution.y * 2.0)\n    {\n        //color = height / 2.0;\n        color = vec4(cos(scaledTime), cos(scaledTime + 10.0), cos(scaledTime + 20.0), 1.0);\n    }\n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsfcWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 466]]}
{"id": "lsfyRS", "name": "Monjori by Mic ThreeJS Demo ", "author": "MichaelPohoreski", "description": "Converted to ShaderToy\n\nThanks for cleanup suggestions!", "tags": ["procedural"], "likes": 13, "viewed": 717, "published": "Public", "date": "1488630009", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nConverted to ShaderToy by Michael Pohoreski\n\nOriginally from:\nhttp://www.pouet.net/prod.php?which=52761\n\nImplemented\nhttps://threejs.org/examples/webgl_shader.html\n\nExplanation\nhttp://stackoverflow.com/questions/9151238/can-anyone-explain-what-this-glsl-fragment-shader-is-doing\n\nYou'll have to excuse the crappy formatting -- that is the original code.\nI'm slowly cleaning it up.\n\nThanks to Fabrice for suggestions!\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // gl_FragCoord is the position of the pixel being drawn\n    // so this code makes p a value that goes from -1 to +1 \n    // x and y\n    vec2 p = (2.0 * fragCoord.xy / iResolution.xy) - 1.0;\n\n    // a = the time speed up by 40\n    // The 5.0 is to keep ShaderToy at the same speed of the original\n    float a = (iTime*5.0) * 40.0;\n\n    // declare a bunch of variables.\n    float d,e,f,g=1.0/40.0,h,i,r,q;\n\n    // e goes from 0 to 400 across the screen\n    //   = 400 * [(p.x*0.5) + 0.5 ]\n    //   = 400 * 0.5 * (p.x + 1)\n    //   = 200 * p.x + 200\n    // But p.x ranges from -1 to +1\n    // e = 0 to 400\n    e = 400.0*(p.x*0.5+0.5);\n\n    // f goes from 0 to 400 down the screen\n    f = 400.0*(p.y*0.5+0.5);\n\n    // e and f could be simplified as:\n    //vec2 ef = 200.0 * (p + 1.0);\n    \n    // i goes from 200 + or - 20 based\n    // on the sin of e * 1/40th + the slowed down time / 150\n    // or in other words slow down even more.\n    // e * 1/40 means e goes from 0 to 1\n    i = 200.0+sin(e*g+a/150.0)*20.0;\n    \n    // d is 200 + or - 18.0 + or - 7\n    // the first +/- is cos of 0.0 to 0.5 down the screen\n    // the second +/i is cos of 0.0 to 1.0 across the screen\n    d = 200.0+cos(f*g/2.0)*18.0+cos(e*g)*7.0;\n\n    // I'm stopping here. You can probably figure out the rest\n    // see answer\n//  r=sqrt(pow(i-e,2.0)+pow(d-f,2.0));\n    r = length( vec2( i-e, d-f ) );\n    q = f/r;\n\n    e = (r*cos(q))-a/2.0;\n    f = (r*sin(q))-a/2.0;\n    d = sin(e*g)*176.0 + sin(e*g)*164.0 + r;\n\n    h = ((f+d)+a/2.0)*g;\n    i = cos(h+r*p.x/1.3)*(e+e+a) + cos(q*g*6.0)*(r+h/3.0);\n\n    h = sin(f*g)*144.0-sin(e*g)*212.0*p.x;\n    h = (h+(f-e)*q+sin(r-(a+h)/7.0)*10.0+i/4.0)*g;\n\n//  i += cos(h*2.3*sin(a/350.0-q)) * 184.0*sin(q-(r*4.3+a/12.0)*g) + tan(r*g+h)*184.0*cos(r*g+h);\n    i += cos(h*2.3*sin(a/350.0-q)) * 184.0*sin(q-(r*4.3+a/12.0)*g) + sin(r*g+h)*184.0;\n\n    // Split into 4 segments\n    i  = mod(i/5.6,256.0)/64.0;\n\n    if (i <  0.0) i += 4.0;\n    if (i >= 2.0) i  = 4.0-i;\n\n    d  = r/350.0;\n    d += sin(d*d*8.0)*0.52;\n\n    f = (sin(a*g)+1.0)/2.0;\n//  fragColor = vec4(vec3(f*i/1.6,i/2.0+d/13.0,i)*d*p.x+vec3(i/1.3+d/8.0,i/2.0+d/18.0,i)*d*(1.0-p.x),1.0);\n    fragColor = d * mix(\n        vec4( i/1.3+d/8., i/2.+d/18., i, 0) ,\n        vec4( f*i/1.6 ,   i/2.+d/13., i, 0) ,\n        p.x\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsfyRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 425, 482, 619, 2780]]}
{"id": "lslcRB", "name": "Tubes Grid", "author": "aiekick", "description": "Tubes Grid", "tags": ["grid", "tubes"], "likes": 12, "viewed": 559, "published": "Public API", "date": "1488822256", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nmat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\t// get rotation matrix near z\n\nfloat tubes(vec3 p, float a, float o)\n{\n    p *= RotZ(p.z * 0.2 + a);\n   \tp.z = mod(p.z + o,1.) - .5;\n    p.x -= 0.2 + sin(iTime * 2.) * 0.5;\n    p.x += length(p.xy) - (.7 + ((cos(iTime * 3.)*.5+.5)*0.3));\n    p.z += p.x;\n    return length(p.xz) - 0.1;\n}\n\nvec2 df(vec3 p)\n{\n    float t0 = tubes(p, 0., 0.);\n    float t1 = tubes(p, 3.14159, 0.5);\n    float d = min(t0,t1);\n\treturn vec2(d,0);\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nfloat SubDensity(vec3 p, float ms) \n{\n\treturn df(p - nor(p,0.0001) * ms).x/ms;\n}\n\nvec2 shade(vec3 ro, vec3 rd, float d, vec3 lp, vec3 ldo, float li)\n{\n\tvec3 p = ro + rd * d;\n\tvec3 n = nor(p, 0.1);\n\tvec3 ldp = normalize(lp-n*1.5-p);\n\tvec3 refl = reflect(rd,n);\n\tfloat amb = 0.6;\n\tfloat diff = clamp( dot( n, ldp ), 0.0, 1.0);\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4.);\n\tfloat spe = pow(clamp( dot( refl, ldo ), 0.0, 1.0 ), 16.);\n\tfloat sss = 1. - SubDensity(p, 0.1);\n\treturn vec2(\n        (diff + fre + spe) * amb * li,\n        (diff + fre + sss) * amb * li + spe\n    );\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tfloat t = iTime * 5.;\n\n    vec3 ld = vec3(0.,1., .5);\n    \n\tvec3 ro = vec3(0,0,t);\n\tvec3 cu = vec3(0,1,0);\n\tvec3 tg = ro + vec3(0,0,.1);\n\t\n\tfloat fov = .5;\n\tvec3 z = normalize(tg - ro);\n\tvec3 x = normalize(cross(cu, z));\n\tvec3 y = normalize(cross(z, x));\n\tvec3 rd = normalize(z + fov * (uv.x * x + uv.y * y));\n\t\n\tfloat s = 1., d = 0.;\n\tfloat dm = 200.;\n\t\n\tfor (float i=0.; i<250.; i++)\n\t{\n\t\tif (log(d*d/s/1e5)>0. || d>dm) break;\n\t\td += (s = df(ro + rd * d).x) * .3;\n\t}\n\t\n    fragColor.rgb = GetSky(rd, ld, vec3(1.5));\n    \n\tif (d<dm)\n\t{\n\t\tvec2 sh = shade(ro, rd, d, ro, ld, 1.);\n\t\tfragColor.rgb = mix( \n            vec3(.49,1,.32) * sh.y * .6 + vec3(.45,0,.72) * sh.x * 1.2, \n            fragColor.rgb, \n            1.0 - exp( -0.001*d*d ) ); \n\t}\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslcRB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 214, 233, 233, 291], [292, 323, 362, 362, 577], [579, 579, 596, 596, 715], [717, 717, 749, 749, 927], [929, 991, 1048, 1048, 1336], [1338, 1338, 1375, 1375, 1418], [1420, 1420, 1488, 1488, 1921], [1923, 1923, 1977, 1977, 2786]]}
{"id": "lslcWX", "name": "BlackRedPixelsGradientRotation", "author": "nikitazu", "description": "Redness vs Greenness rotating", "tags": ["study"], "likes": 0, "viewed": 97, "published": "Public", "date": "1490185960", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float median( float x )\n{\n    return 2.0 * x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float rotation = sin(iTime);\n    \n    vec2 relativePoint = fragCoord.xy / iResolution.xy;\n    \n    float kx = rotation;\n    float ky = 1.0 - kx;\n    \n    float redness = relativePoint.x * kx + relativePoint.y * ky;\n    float greenness = 1.0 - redness;\n    \n    fragColor = vec4(\n        median(redness)\n      , median(greenness)\n      , 0.0\n      , 1.0\n    );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslcWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 47], [49, 49, 106, 106, 472]]}
{"id": "lslyDj", "name": "FlagRussia", "author": "ArtDov", "description": "Flag", "tags": ["flag"], "likes": 2, "viewed": 67, "published": "Public", "date": "1489998846", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.141592;\nconst float KPT180 = 0.017453;\n    \nfloat cloth (vec3 p, vec2 b){\n\tb = vec2(abs(b.x),abs(b.y));\n    float rad = KPT180*90.0;\n    vec3 d = abs(p) - (b.xy,1.0);\n    //b.x *= b.x*cos(rad) - b.y*sin(rad);\n  // b *= length(vec2(cos(rad), -sin(rad)));\n    //b *= mat2(0.5,0.0, 0.0, 0.5);\n    return  2.0*(b.y + b.x);\n}\nfloat rayTrace(vec3 o, vec3 r, vec2 uvcloth){\n     float t = 0.0;\n    for(int i=0; i<64;i++){\n        vec3 p;\n        vec2 b = uvcloth;\n       // clamp(b.x, 0.1,0.8);clamp(b.y, 0.4,0.7);\n        float d = cloth(p, b);\n        p = o + d*t;\n        t+=d * 0.33333;\n    }\n    return t;\n}\nvec2 rot_uv(vec2 uv, float angle){\n\tfloat rad = KPT180*angle;\n    return uv *= mat2(cos(rad), -sin(rad), sin(rad), cos(rad));\n}\nvec3 drawRectangle (in vec2 uvRectangle, float time, float scale, vec3 segmentColor,out float coefficientScale){\n    \n   \n    uvRectangle = 2.0*uvRectangle - 1.0;\n    uvRectangle.x *= iResolution.x/iResolution.y;\n    uvRectangle.y *= iResolution.y/iResolution.x*3.0;\n    uvRectangle.y += 0.7*fract(0.8*cos(0.8*cos((length(uvRectangle.x)*sin(time))))-2.5);\n    uvRectangle.x -= 0.1*fract(2.1*sin(cos((length(uvRectangle.y)*sin(time))+0.1))-0.5);\n    uvRectangle.x *= 0.32;\n    coefficientScale = length(uvRectangle.y);\n    uvRectangle = rot_uv(uvRectangle, 45.0);\n    uvRectangle *=scale;\n    \n    vec3 r = normalize(vec3(uvRectangle,1.0));\n    vec3 o = vec3(0.0,0.0,time);\n    float t = rayTrace(o, r, uvRectangle);\n    vec3 fc = vec3(t);\n    \n    if (fc.x<0.99)fc = vec3(0.0);\n  \n  \tfc=vec3(1.0,1.0,1.0)-fc;\n    \n    fc*= segmentColor;\n    fc = clamp(fc, 0.0, 1.0);\n    return fc;\n}\n\nfloat heigh (vec2 uv){\nreturn clamp(abs((cos(iTime/1.0)+0.8)*uv.x*uv.y*length(uv)-0.5), 0.2 , 1.2);\n}\n\nfloat heigh2 (vec2 uv){\nreturn 1.1*fract(clamp(abs((2.2*sin(iTime)+4.0)*1.2*length(uv)*uv.x), 0.1 , 0.95)) - 1.4;\n}\n\nfloat heigh3 (vec2 uv){\n    return 0.8*tan(0.01*uv.y*length(uv)*(cos(iTime))-10.0) - 2.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    float time = iTime;\n\tvec2 uvRectangle = fragCoord.xy / iResolution.xy;\n    vec2 bluePosition = vec2(0.0,0.0);\n    vec2 whitePosition = vec2(0.0,-0.33);\n    vec2 redPosition = vec2(0.0,0.33);\n    vec3 fcBackground = vec3(.0);\n    vec3 fc0 = drawRectangle(uvRectangle + whitePosition, time, 0.03, vec3(1.0, 1.0, 1.0), bluePosition.y);\n    vec3 fc1 = drawRectangle(uvRectangle , time, 0.03, vec3(0.1, 0.2, 0.6), whitePosition.y);\n    vec3 fc2 = drawRectangle(uvRectangle + redPosition, time, 0.03, vec3(0.9, 0.0, 0.0), whitePosition.y);\n    vec4 sumfc = vec4 (0.0);\n\tsumfc += vec4(fc0,1.0);\n    sumfc += vec4(fc1,1.0);\n    sumfc += vec4(fc2,1.0);\n    \n    \n    //////////////////////////////////////////////////////\n    vec2 uv =  fragCoord.xy/iResolution.xy;\n    uv.x = uv.x+0.1*cos(iTime);\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x *= 0.5;\n    float uvScale = 2.0;\n    float h = heigh(rot_uv(uv,15.0*iTime));\n    vec3 noise = vec3(heigh2(rot_uv(uv, 5.0*cos(iTime))));\n    vec3 noise1 = vec3(heigh3(uv));\n    vec3 col = vec3(h);\n    col+= vec3(0.4,0.4,0.4);\n    \n    sumfc.xyz*=col;\n    sumfc.xyz+=col/4.0;\n    sumfc.xyz*=noise/2.5;\n    sumfc.xyz*=noise1/2.5;\n    float sx,sy,sz; sx = 3.0; sy = sx; sz = sx; \n    sumfc *= mat4(sx ,0.1,0.0,0.0,\n                  0.0, sy,0.0,0.0,\n                  0.0, 0.0,sz,0.0,\n                  0.0,0.0,0.0,1.0);\n\tsumfc = clamp(sumfc, 0.0, 1.0);\n\tfragColor = sumfc;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslyDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 92, 92, 339], [340, 340, 385, 385, 624], [625, 625, 659, 659, 752], [753, 753, 865, 865, 1636], [1638, 1638, 1660, 1660, 1739], [1741, 1741, 1764, 1764, 1856], [1858, 1858, 1881, 1881, 1949], [1950, 1950, 2007, 2007, 3426]]}
{"id": "lslyR2", "name": "Rainbow Spinner", "author": "akohdr", "description": "Determines polar angle from aspect corrected centred coordinates.  \nPhases and masks rotating RGB fields to produce rainbow spinner.\n", "tags": ["color"], "likes": 30, "viewed": 458, "published": "Public", "date": "1489873010", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Andrew Wild - akohdr/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define iR iResolution.xy\n#define iT iTime\n#define T (9.*iT)\n//#define T (9.*sin(iT))\n#define PI 3.14159265359\n\nvoid mainImage( out vec4 k, in vec2 p )\n{\n \tvec4 h = vec4(1,2,3,0);\t\t\t// relative RGB phase\n//\th *= PI/2. * sin(iT);\t\t\t// opt. temporal phase shift\n    \n\tvec2 UV = p / iR,\t\t\t\t// scaled coord.\n//\t     O = iR/2.-p,\t\t\t\t// centered coord.  (wrong, ooops)\n//\t     O = p-.5*iR,\t\t\t\t// centered coord.  (corrected @Fab)\n//\t     C = O / iR.y;\t\t\t\t// aspect corrected coord.\n    \t C = (p - .5*iR) / iR.y;\t// direct centered aspect corrected coord. @Fab\n    \n    float r = length(C),\t\t\t// radius\n    \t  d = abs(r-.3),\t\t\t// dist to ring\n//\t      a = atan(C.y/C.x) +\t\t// angle\n//\t          PI*step(0.,C.x);\t\t// quadrant adj.\n          a = atan(C.y,C.x);\t\t// hadn't seen two param atan() @Fab\n    \n\tk = sin(T+a-h);\t\t\t\t\t// phase & spin\n\tk *= .1-d;\t\t\t\t\t\t// transform into ring\n\tk /= r;\t\t\t\t\t\t\t// brighten\n\tk *= step(d,.1);\t\t\t\t// bagel mask\n\tk *= 2.;\t\t\t\t\t\t// increase colour\n//\tk += UV.y/3.;\t\t\t\t\t// background\n}\n\n/*\nvoid mainImage( out vec4 k,  vec2 C )\n{\n    float r = length( C -= .5*(k.xy=iResolution.xy) ) / k.y;        \n\tk = sin( 9.*iTime + atan(C.y,C.x) -vec4(1,2,3,0) )\n        * max(.1-abs(r-.3), 0.) *2. / r;\t\t\t\t\t\n} // 159\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslyR2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[189, 240, 281, 281, 1132]]}
{"id": "lsscD7", "name": "Enigmatic Delights", "author": "voz", "description": "Definitely not copyrighted correctly, iapafoto. Please help correct.", "tags": ["enigmatic", "delights"], "likes": 0, "viewed": 476, "published": "Public API", "date": "1488560297", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Do not redistribute.\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define NN 2.7182818284\n#define GR 1.61803398875\n\n//-----------------UTILITY FUNCTIONS--------------\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((.125-.25*saw(float(__LINE__)*PI*GR*NN)/PI/GR/NN)*iTime+1000.0)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n\n#define flux(x) (vec3(cos(x*2.0*PI),cos(4.0*PI/3.0+x*2.0*PI),cos(2.0*PI/3.0+x*2.0*PI))*.5+.5)\n#define circle(x) (vec2(cos((x)*2.0*PI),sin(2.0*PI*(x))))\n\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define ZIN (vec3(0.0, 0.0, 1.0))\n\nvec2 remap(vec2 uv, vec4 start, float r1, vec4 end, float r2)\n{\n    \n    vec3 c1 = vec3(start.xy, 0.0);\n    vec3 d1 = vec3(start.zw, 0.0);\n    \n    vec3 c2 = vec3(end.xy, 0.0);\n    vec3 d2 = vec3(end.zw, 0.0);    \n\n    uv = (rotatePoint(vec3(uv, 0.0)-c1, ZIN, r1).xy*d1.xy);\n    uv = (rotatePoint(vec3(uv, 0.0)-c2, ZIN, r2).xy*d2.xy);\n    \n    \n    return uv;\n}\n\nvec4 transform(vec2 uv)\n{\n    \n    float scale = GR*2.0;\n    uv = uv*scale-scale/2.0;\n    \n    vec2 uv0 = uv;\n    \n    const int max_i = 6;\n    \n    float map = 1.0;\n\tfloat detail = 1.0;\n\n    vec4 start = vec4(circle(time)*0.5+1.0,\n                     vec2(sin(time*2.0+PI)*0.1+1.0));\n    vec4 end = vec4(circle(time)*0.5+1.0,\n                    vec2(1.0));\n    \n    for(int i = 0 ; i < max_i; i++)\n    {\n        map += (smoothstep(0.0, 1.0/PI/GR, abs(uv.y-uv.x)));\n        float j = float(i)/float(max_i-1);\n        \n        float theta1 = time;\n        float theta2 = time;\n        vec2 last = uv;\n        uv = (remap(uv, start, theta1, end, theta2));\n        uv = saw(uv/2.0)*2.0-1.0;\n    }\n  \tmap = pow(map, 1.0/float(max_i));\n    float b = 1.0-smoothstep(0.0, 1.0/PI, map);\n\t//fragColor = vec4(saw(uv), 0.0, 1.0);\n\treturn vec4(flux(map*2.0*PI)*2.0-1.0, 1.0);\n}\n\n// Need to be redesigned for WebGL 2.0   :'(\n\n/* Created by Sebastien Durand - 2014 */                    #define G(a) for(int i=0;i<a;i++)\n/*     License  Creative Commons      */                     #define U(a,b) (a.x*b.y-b.x*a.y)\n/*     Attribution-NonCommercial      */                                  #define N normalize\n/*   ShareAlike 3.0 Unported License. */                                      #define F float\n                                                                               #define W vec3\n                                                                               #define V vec2\n                                     F K,v=1.16;\n                                        V R,\n                              Q=V(1,.72),A[15],T[4];W L,\n                          Y=W(0,.4,0),E,P,O;F B(V m,V n,V o){                     V q=P.xy;\n                     m-=q;n-=q;o-=q;F x=.5*U(o,m),y=U(n,o),z=U(m,n)             ;q=m*(x+y)\n     +n*(z-y)-o*(x+z);q.x=-q.x;m-=n+=n-o;K=clamp(.5*U((o+(y*z-x*x)*q.          yx/dot(q,\n   q)),m)/(x+x+y+z),0.,1.);q=o+K*(n-o+K*m);      return sqrt(dot(q,q)         +P*P).z;}                      \n F M(W            p){P=p+O;                                       F a=       9.,y=P.y,                                   b=min( \n min(B           (V(-.6,.78),V(-v,.84),R),  B(R,V(-1.2,.42),V(-.72,.24      ))) -.06\n ,max(           P.y-.9,min(abs(B(V(v,.96),V(1.04,.9),Q)-.07)-.01,B(Q,V    (.92,.48\n ),V(          .72,.42))*(.25+.75*K)-.08)));P=W(sqrt(dot(P,P)-y*y),y,0);G (7)a=min\n (a,(B         (A[i+i],A[i+i+1],A[i+i+2])-.02)*.7);return a<b?a:b;}void mainImage\n  (out        vec4 o,V x) {L=N(W(Q,1));R=V(-v,.63);E=Y/1e3;T[0]=V(201616,401e2);\n  T[1]=       V(151620.2,313016.1);T[2\n   ]=V(       214.14,353432.3);T[3]=V(5.04,4040.39);G(15)A[i]=V(4,3)*fract(T[i/\n    4]/pow   (1e2, F(i-4*(i/4))));V r=iResolution.xy,m=iMouse.xy/r,p=(x+x-r)/r\n      .y; F s=.3,h, t=3.*(iDate.w+m.x); O=3.*W(cos(t),.7-m.y,sin(t));W c=W(.8\n         -s*length(p)),w=N(Y-O),u=N(cross(w,Y)),d=N(p.x*u+p.y*cross(u,w)+w+w\n          );t=0.; G(99) if((t+=h=M(d*t))>5.)break;if(h<E.y) { O+=t*d;vec3 lol=saw(O);w=transform((vec2(atan(lol.z, lol.x)/PI*.5+.5, asin(lol.y)*.5+.5))).rgb; G(18)s=min(s,M(L*(h+=.02))/\n             h);c=mix(c,mix(Y*(s>0.?3.*s+2.:2.),W(pow(max(dot(reflect(L\n                  ,w), d),0.), 99.)), .3),dot(w,-d));} o.grb = flux(length(c));}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsscD7.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[153, 205, 225, 225, 330], [331, 331, 349, 349, 388], [390, 390, 408, 408, 457], [459, 459, 477, 477, 536], [539, 1177, 1240, 1240, 1538], [1540, 1540, 1565, 1565, 2407], [2455, 3214, 3231, 3231, 3529], [3553, 3553, 3573, 3573, 4000], [4000, 4000, 4042, 4042, 4787]]}
{"id": "lsscDN", "name": "Ray Based Fractal", "author": "Passion", "description": "Messing around with inout/in defined variables.", "tags": ["fractal", "ray", "in", "inout"], "likes": 5, "viewed": 262, "published": "Public", "date": "1488354375", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\nconst int NUM_ITER = 5;\nconst int NUM_ITER_FBM = 5;\n\n//const int NUM_ITER = 6;\n//const int NUM_ITER_FBM = 3;\n\nvoid doFractal( inout vec3 r, in int iter);\nvoid finalOutput( inout vec4 c, in vec3 c1, in vec3 c2, in float vin, in vec3 r);\n\nfloat hash(float n){\n    return fract(sin(n) * 4121.15393);\n}\n\nfloat noise( in vec3 x ){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n//Fbm function\nfloat fbm(vec3 n) {\n    float total = 0.0, amplitude = 1.0;\n    //n.x+=iTime;\n    for (int i = 0; i < NUM_ITER_FBM; i++) {\n        total += noise(n) * amplitude;\n        n += n;\n        amplitude *= 0.5;\n    }\n    return total;\n}\nmat2 r2(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(s, -c, c, s);\n}\n\n\nvoid mainImage( out vec4 outFinal, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    float vinette = 1.-pow(length(uv*uv*uv*uv)*1.01,10.);\n   \n    outFinal = vec4(0.0);\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv, uv)*.5));\n    r.xy *= r2(-t*.25);\n    r.yz *= r2(t*.5);\n    r.zx *= r2(t*.75);\n\n \tdoFractal(r, NUM_ITER);\n    \n    vec3 c1 = vec3(noise(r*7.),\n                   sin(fbm(r*.6)), \n                   cos(noise(r*8.)));\n    \n    //r+=abs(.1*t+r*2.23);\n    \n    vec3 c2 = vec3(cos(fbm(r*8.+noise(r*5.5))), \n                   cos(fbm(7.*r)), \n                   cos(r*6. - noise(5.*r)));\n    \n    finalOutput(outFinal, c1, c2, vinette, r);\n}\n\nvoid finalOutput( inout vec4 c, in vec3 c1, in vec3 c2, in float vin, in vec3 r){\n    vec3 gammaVal = vec3(1.0/1.5);\n    c =vec4(pow(mix( c2, c1, (noise(2.*r))), gammaVal) ,1.0)*vin;\n    gammaVal = vec3(2.5/1.0);\n    c = pow(sqrt(c), vec4(gammaVal, 1.0));\n}\n    \n//The Fractal\nvoid doFractal( inout vec3 rayIN, in int iter ){\n    for(int i = 0; i<NUM_ITER; i++){\n        \n        rayIN.xz*=r2(t*.16);\n        \n        rayIN = abs(rayIN) / dot(rayIN,rayIN);\n        rayIN.x = abs(rayIN.x+cos(t*.2)*.75);\n        rayIN.x = abs(rayIN.x-.8);\n        \n        rayIN.xy = abs(r2(-t*.1)*rayIN.xy);\n        rayIN.y = abs(rayIN.y-.5);\n        rayIN.y = abs(rayIN.y+.03+sin(t)*.25);\n        \n        rayIN.zy = abs(r2(-t*.25)*rayIN.zy);\n        rayIN.z = abs(rayIN.z-.5);\n        rayIN.z = abs(rayIN.z+.03+sin(-t)*.15);\n\t\t\n        /*\n        rayIN.xz*=r2(t*.16);\n        \n        rayIN = abs(rayIN) / dot(rayIN,rayIN);\n        rayIN.x = abs(rayIN.x+cos(t*.2)*.75);\n        rayIN.x = abs(rayIN.x-.8);\n        \n        rayIN.xy = abs(r2(-t*.1)*rayIN.xy);\n        rayIN.y = abs(rayIN.y-.5);\n        rayIN.y = abs(rayIN.y+.03+sin(t)*.25);\n        \n        rayIN.zy = abs(r2(t*.25)*rayIN.zy);\n        rayIN.z = abs(rayIN.z-.5);\n        rayIN.z = abs(rayIN.z+.03+sin(-t)*.15);\n\t\t*/\n    }   \n    rayIN = abs(rayIN) / float(NUM_ITER);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsscDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 253, 273, 273, 314], [316, 316, 341, 341, 711], [712, 727, 746, 746, 956], [957, 957, 974, 974, 1050], [1053, 1053, 1109, 1109, 1801], [1803, 1803, 1884, 1884, 2060], [2066, 2080, 2128, 2128, 3121]]}
{"id": "lssczX", "name": "Space Popcorn", "author": "kp1197", "description": "my first attempt at raymarching", "tags": ["raymarch"], "likes": 0, "viewed": 122, "published": "Public", "date": "1489216140", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\nvec4 _texture(vec3 pos, float material)\n{\n    \n    if (material==0.) // ball\n    {\n    \tvec4 col = 0.9+0.4*textureLod(iChannel0, (0.1*(pos).xy + 0.1*(pos).yz * 0.1*pos.zx), 0.0);\n        return col * col;\n    }\n    else if (material==1.) // ground\n    {\n        return textureLod(iChannel1, (0.1*pos.xy + 0.1*pos.yz + vec2(0.0,time)), 0.0) + vec4(0.0,sin(time),1.0,0.0);\n    }\n    else if (material == 2.) // sky\n    {\n        return 0.5*textureLod(iChannel2, 0.01*time + 0.002*pos.xy, 0.0) + 0.5*textureLod(iChannel1, 0.1*time+0.003*pos.yx, 0.0);\n    }\n    else // default\n    {\n        return vec4(0.);\n    }\n}\n\nvec3 sphereCenter()\n{\n  return vec3(cos(-time), mod(3.*-time,30.)-20., sin(-time)+5.);   \n}\n\nvec3 lightPos()\n{\n    return vec3(sin(time),0.,1.);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 world_dist(vec3 pos)\n{\n    vec3 c = sphereCenter();\n    vec3 rel_pos = pos - c;\n    float spherecenterdist = length(rel_pos);\n    float displacement = 0.2*length(_texture(pos,1.));\n    float heightfield = pos.y + 1.0 + 0.2*sin(5.*spherecenterdist) / spherecenterdist + displacement;\n    float spheredisplacement = 0.5*length(sin(2.0*time) + _texture(1.*rel_pos,0.));\n    float spheredist = spherecenterdist - spheredisplacement;\n    float dist = smin(heightfield,spheredist,2.9);\n    float mat = heightfield < spheredist ? 1. : 0.;\n    return vec2(dist,mat);\n}\n\nvec3 normal(vec3 pos)\n{\n    vec3 e = vec3(0.0001,0.0,0.0);\n    float d1 = world_dist(pos+e.xyz).x - world_dist(pos-e.xyz).x;\n    float d2 = world_dist(pos+e.yxz).x - world_dist(pos-e.yxz).x;\n    float d3 = world_dist(pos+e.yzx).x - world_dist(pos-e.yzx).x;\n    return normalize(vec3(d1,d2,d3));\n}\n\nvoid rayMarch(vec3 r, vec2 uv, out vec4 fragColor)\n{\n    // distance to object + material of closest object\n    vec2 _d = world_dist(r);\n    \n    // distance from camera focal point\n    float d = 1.0;\n    \n    vec3 rayPos = r * d;\n    \n    // march\n    for(int march = 0; march <= 128; march++)\n    {\n        // if more than 20 units from camera...\n        if (d > 20.)\n        {\n            // sky\n            fragColor = _texture(vec3(uv,0.),1.);\n            return;\n        }\n        \n        // if less than eps units from object\n        if (_d.x < 0.05)\n        {\n            // calculate illumination\n            vec3 lightWorldVec = lightPos()-(rayPos);\n            float lightDist = length(lightWorldVec);\n            float brightness = 0.5 + (0.25/lightDist) * dot(normal(rayPos),lightWorldVec);\n            vec3 relPos = rayPos - sphereCenter();\n            float distFromSphere = length(relPos);\n            \n            if (_d.y == 0.)\n            {\n                fragColor = brightness * _texture(relPos,_d.y);\n            }\n            else\n            {\n                float _mix = 1./length(distFromSphere);\n                fragColor =_mix + brightness * _texture(rayPos, _d.y) + _mix*_mix*_texture(relPos,2.);\n            }\n            \n            // sample the material of the closest object\n            \n            return;\n        }\n        \n        // otherwise, recalculate distance to closest object\n        _d = world_dist(rayPos);\n        \n        // move ray to \n\t\td += 0.7*_d.x;\n        rayPos = r * d;\n    }\n    fragColor.x = 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = vec2(fragCoord.x / iResolution.y, fragCoord.y / iResolution.y) - vec2(0.5 * (iResolution.x/iResolution.y), 0.5);\n    vec3 r = normalize(vec3(uv, 1.0));\n    rayMarch(r, uv, fragColor);\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lssczX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 61, 61, 632], [634, 634, 655, 655, 725], [727, 727, 744, 744, 780], [782, 782, 823, 823, 916], [918, 918, 945, 945, 1483], [1485, 1485, 1508, 1508, 1781], [1783, 1783, 1835, 1890, 3346], [3348, 3348, 3405, 3405, 3608]]}
{"id": "lssyRf", "name": "Vector balls Loading Screen", "author": "skaven", "description": "Fast made shader for a loading screen. Idea come from Amiga Nexus demo. Vector balls is the first thing I've seen running on Amiga 500. Memories. Click in view to change loading progress.", "tags": ["loadingscreen"], "likes": 3, "viewed": 144, "published": "Public", "date": "1489226991", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nfloat circle(vec2 coord, float radius, float aa)\n{\n    return smoothstep(radius-aa, radius+aa, sqrt(dot(coord,coord)));\n}\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    \n    float pixelSize = 1.0/iResolution.x;\n    vec2 uvvign = uv;\n    uvvign += vec2(hash(uv*11.17), hash(uv*9.98))*pixelSize * 10.0;\n    float vignette = 1.7 - sqrt(dot(uv+uvvign,uv+uvvign));\n\tuv.y *= iResolution.y / iResolution.x;\n    \n    float randomIncl = iMouse.y/iResolution.y * 0.1;\n    float loading = max(iMouse.x/iResolution.x-0.9,0.0) * 100.0 + 1.0;\n    float loadingThes = 0.8 - iMouse.x/iResolution.x - 0.2;\n    float col = 1.0;\n    for (int i = 0;i<10;i++)\n    {\n        float t = float(i) / 10.0 + iTime * 0.2;\n        vec2 coord = vec2(cos(t * PI * 2.0) * 0.25, sin(t * PI * 2.0) * 0.05); \n        \n        float radius = sin(t * 21.11) * 0.2+0.8;\n        radius *= clamp((float(i)-loadingThes*10.0), 0.0, 1.0);\n        radius *= 1.0 + coord.y * 14.0;\n        \n        radius *= loading;\n        coord.y += sin(t * 3.6 * PI) * randomIncl;\n        col = min(col, circle(uv + coord, radius * 0.05, pixelSize));\n    }\n    \n    fragColor = vec4(0.3,0.3,0.3,1.0) * vignette * col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lssyRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 70, 70, 141], [143, 143, 200, 200, 304], [306, 306, 363, 363, 1426]]}
{"id": "lssyRX", "name": "Graphing4Dummies", "author": "mgrant8164", "description": "Drag cursor (mouse button held down) left/right to adjust viewport rotation.", "tags": ["graphing"], "likes": 1, "viewed": 157, "published": "Public", "date": "1489185995", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//unused at this point\n//#define VIEWRAD 15.0\n\n//Super Sampling Enabled?\n//#define SS\n//Super Sampling Level [1-...] (applied if enabled)\n#define SSA 1\n\n//screen/viewport field of view (as %)\n#define FOV vec2(100.,100.)/100.\n//distance from viewport to target\n#define VIEWDIST 20.0\n//number of iterations to complete of newton's method (zero approx)\n#define NEWT_N 100\n\n//color z multiplier (implementation & function dependant)\n#define CMULT .25\n\n//graphing function definitions\n//F_f : function to graph\n//F_df: derivative (with dx and dy) of function to graph\n/***Test Case 1***/\n/*\n#define F_f  sin(iTime)*(-sin(y-x)+cos(x+y))\n#define F_df sin(iTime)*(-cos(y-x)*(dy-dx)-sin(x+y)*(dx+dy))\n//*/\n/***Test Case 2***/\n/*\n#define F_f  x*x+y*y\n#define F_df x*dx+y*dy\n//*/\n/***Test Case 3 (?)***/\n/*\n#define F_f  sqrt(abs(x-y))/10.\n#define F_df 1./sqrt(abs(x-y))*abs(dx-dy)/10.\n//*/\n/***Test Case 4***/\n//*\n#define F_f  sin(sqrt(x*x+y*y)-iTime*4.)\n#define F_df cos(sqrt(x*x+y*y)-iTime*4.)/(2.*sqrt(x*x+y*y))*(2.*x*dx+2.*y*dy)\n//*/\n/***Test Case 5***/\n/*\n#define F_f sin(x*x+y*y)-cos(x*y)\n#define F_df cos(x*x+y*y)*(2.*x*dx+2.*y*dy)+sin(x*y)*(dx+dy)\n//*/\n\n//constants definitions\n#define PI  3.14159265359\n#define TAU 6.28318530718\n\nvec2 va = vec2(0.,PI/4.);\n\nvec2 soff;\nvec3 target = vec3(0.,0.,0.);\nvec3 vpp;\nvec3 vpr;\n\n//pixel\nvec3 ray = vec3(0.);\n\n\n//unused at this moment\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n//returns a color based upon the specified z value\nvec4 getc(float z) {\n    float dpc = max(min(z*CMULT,1.),-1.)/2.+0.5;\n    return vec4(dpc,1.-dpc,0.,1.);\n    //return vec4(vec3(1.-dpc-.3),1.);\n}\n\n//returns f(x,y)\nfloat f(vec2 inp) {\n    float x = inp.x;\n    float y = inp.y;\n    return F_f;\n}\n//returns f'(x,y), given dx and dy\nfloat df(vec2 inp, vec2 dinp) {\n    float x = inp.x;\n    float y = inp.y;\n    float dx = dinp.x;\n    float dy = dinp.y;\n    return F_df;\n}\n//returns g(t), the value of raycasted f(x,y)\nfloat g(float t) {\n    return t*ray.z+vpp.z-f(ray.xy*t+vpp.xy);\n}\n//returns g'(t), needed for newton's method\nfloat dg(float t) {\n    return ray.z-df(t*ray.xy+vpp.xy,ray.xy);\n}\n\n//calculates (hopefully) the first zero of g(t), yields t\nfloat gzero() {\n    float cx = length(vpp.xy);\n    float cy = g(cx); //current yield\n    for(int s = 0; s < 1000; s++) {\n        cx += .1;\n        float ccy = g(cx);\n        if(sign(cy) != sign(ccy)) break;\n        cy = ccy;\n    }\n    cx -= .1;\n    for(int i = 0; i < NEWT_N; i++) {\n        cx = cx - g(cx)/dg(cx);\n    }\n    return cx;\n}//*/\n/*\nfloat gzero() {\n    float cx = length(vpp.xy);\n    float cg;\n    float px = cx - 1.;\n    float pg = g(cx);\n    for(int i = 0; i < NEWT_N; i++) {\n        float cg = g(cx);\n        cx = cx - cg*((cx-px)/(cg-pg));\n        px = cx;\n        pg = cg;\n    }\n    return cx;\n}//*/\n\n\nvec4 mainimg(in vec4 fragColor, in vec2 fragCoord ) {\n    \n    \n    //regulate viewport and FOV settings <1., >=1.>\n    vec2 cod = (fragCoord.xy - soff)/min(soff.x,soff.y)*FOV;\n    //rotate viewport aim vector and normalize to get pixel x offset vector\n    //vec3 vox = normalize(vec3(vpr.y, -vpr.x, 0.));\n    vec3 vox = normalize(cross(vpr, vec3(0.0,0.0,1.0)));\n    //rotate viewport aim vector and normalize to get pixel y offset vector\n    //vec3 voy = normalize(vec3(vpr.xy*vpr.z,length(vpr.xy)));\n    vec3 voy = normalize(cross(vpr, vec3(-vpr.y,vpr.x,0.0)));\n    \n    //set pxp to the 3d position of current pixel, 1. away from vp origin\n    vec3 pxp = normalize(vpp)*(length(vpp)-1.);\n    //add pixel x offest to position\n    pxp += vox * cod.x;\n    //add pixel y offset to position\n    pxp += voy * cod.y;\n    \n    //calculate vp origin to pixel location vector (for direction)\n    //no need to normalize, this is done next\n    ray = pxp - vpp;\n    //make ray a normalized vec2 with a slope as z\n    //these become t (vec2 multiplier) and z (float multiplier)\n    ray = ray/length(ray.xy);\n    \n    //calculate zero using newton's method\n    float cx = gzero();\n    \n    //intersection as x and y coords relative to vp origin, and z as pixel depth\n    vec3 intc = vec3(ray.xy*cx,g(cx));\n    //float depth = distance(intc);\n    \n    //absolute intersection position\n    vec3 abp = vec3(vpp.xy+cx*ray.xy,0.);\n    abp.z = f(abp.xy);\n    \n    //finally, set the color as a function of the z (=height=f(intersection))\n    //of the final intersection point\n    //fragColor = getc(abp.z);\n    //fragColor = getc(df(abp.xy,));\n    \n    /*Deprecated beyond this point, for now*/\n    \n    //if(length(abp.xy - target.xy) < VIEWRAD) {\n    if(cx>0.) {\n        fragColor = getc(abp.z);\n    } else {\n        fragColor = vec4(0.,0.,0.,1.);\n    }\n    return fragColor;\n}\n\nvoid perframe(vec2 fragCoord) {\n\t//center screen coordinates\n    soff = iResolution.xy * 0.5;\n    //target for viewport to point at\n    target = vec3(0.,0.,0.);\n    //set screen x rotation to mouse position (percentage * 2pi)\n    va.x = iMouse.x/iResolution.x*TAU;\n    va.y = iMouse.y/iResolution.y*PI/1.5-PI/2.;\n    //calculate final viewport position from rotation and distance from target\n    vpp = vec3(sin(va.y)*vec2(cos(va.x),sin(va.x)),cos(va.y))*VIEWDIST;\n    //direction vector from viewport to target\n    //vpr = normalize(target-vpp);\n    //vpp = vec3(0.0, 0.0, 0.0);\n    vpr = normalize(vec3( sin(va.y) * vec2(cos(va.x), sin(va.x)), cos(va.y) ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    perframe(fragCoord);\n    #ifdef SS\n    fragColor = vec4(0.);\n    for(float x = 0.; x < 1.; x += 1./float(SSA)) {\n        for(float y = 0.; y < 1.; y += 1./float(SSA)) {\n        \tfragColor += mainimg(fragColor, fragCoord+vec2(x,y));\n    \t}\n    }\n    fragColor /= float(SSA*SSA);\n    #else\n    fragColor = mainimg(fragColor, fragCoord);\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lssyRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1348, 1372, 1417, 1417, 2045], [2047, 2098, 2118, 2118, 2243], [2245, 2262, 2281, 2281, 2341], [2342, 2377, 2408, 2408, 2515], [2516, 2562, 2580, 2580, 2627], [2628, 2672, 2691, 2691, 2738], [2740, 2798, 2813, 2813, 3135], [3135, 3417, 3470, 3532, 5278], [5280, 5280, 5311, 5340, 5940], [5942, 5942, 5999, 5999, 6351]]}
{"id": "lssyW2", "name": "voxel 3x3x3 fractal", "author": "abje", "description": "an experiment in voxel raycasting with varying voxel size. mouse goes through many possible variations. the define in line 5 makes you dizzy. 2d version\nby tsone [url]https://www.shadertoy.com/view/Xl2XRG[/url]\n", "tags": ["voxel", "mengersponge"], "likes": 7, "viewed": 814, "published": "Public API", "date": "1490024560", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(spin) mat2(cos(spin),-sin(spin),sin(spin),cos(spin))\n\nfloat time;\n\n//#define dizzy\n#define steps 500\n#define detail 4\n\n\n// ray box intersection by iq https://www.shadertoy.com/view/ld23DV\nvec4 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\n\treturn vec4( tN, nor );\n}\n\n/*\nwhat to fix:\n\"sign(dir)*0.001\" is wrong\n*/\n\nfloat map(vec3 p) {\n    p = mod(p,3.0);\n    int num = int(p.x)+int(p.y)*3+int(p.z)*9;\n    if(iMouse.x < 20.5) return float((int(time*5.0)*45354647)&1<<num)-0.5; //129928175\n    if(iMouse.x < 40.5) return float((129928175)&1<<num)-0.5; //129928175\n    return float(int((iMouse.x*123678.0+iMouse.y*321876.0))&1<<num)-0.5;\n    //return dot(p-1.0,p-1.0)-max(abs(p.x)+p.y,-p.y)*max(abs(p.y)+p.z,-p.z)*max(abs(p.z)+p.x,-p.x); // the pifometer change\n    //return -p.x-p.y-p.z+2.5;\n    //return -(dot(p-1.0,p-1.0)-1.0);\n}\n\n\n#define rotmat(spin) mat2(sin(spin),cos(spin),-cos(spin),sin(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime*0.2;\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    #ifdef dizzy\n    uv *= rot(0.5*(length(uv))*sin(time)+time*0.2);\n    #endif\n    \n    vec3 cam = vec3(cos(time)*3.0+1.5,1.5,1.5+sin(time)*3.0);\n    //cam.y = clamp(0.5+abs(fract(cam.z/6.0)-0.5)*6.0,1.5,2.5);\n    vec3 pos = cam;\n    vec3 dir = normalize(vec3(uv,-1.0));\n    \n    dir.xz *= rotmat(time);\n    \n    vec4 box = iBox(pos-1.5, dir, vec3(1.5));\n    if (abs(box.x) > 0.01) {\n    \tpos += dir*max(box.x,0.0)-box.yzw*0.00001;\n        \n        vec3 invdir = 1.0/abs(dir);\n        vec3 signdir = sign(dir);\n        vec3 floorpos = floor(pos);\n        vec3 mask = abs(box.yzw);\n\n        float dist = box.x;\n        vec3 localpos = pos;\n        vec3 localfloor = floorpos;\n        float stepsize = 1.0;\n        float count = 0.0;\n\t\tbool hit = true;\n        for (int i = 0; i < steps; i++) {\n            if (count > float(detail)||dist > 8.0) break;\n            bool len = map(localfloor)<0.0;\n\n            if((max(max(localfloor.x,localfloor.y),localfloor.z) > 2.5||min(min(localfloor.x,localfloor.y),localfloor.z) < -0.5)) {\n                if (count < 0.5) {\n                    hit = false;\n                    break;\n                } else {\n                    stepsize *= 3.0;\n                    count--;\n                    floorpos -= localfloor*stepsize/3.0-mask*signdir*stepsize;\n                    pos+= signdir*0.00001*mask;\n                    localpos = mod(pos/stepsize-signdir*mask,3.0)+signdir*mask;\n\n                    localfloor = floor(localpos);\n                }\n            } else\n            if (!len && count <= float(detail)) {\n\n                stepsize /= 3.0;\n                count++;\n                localpos = localpos*3.0-localfloor*3.0;\n                vec3 pos2d = floor(localpos)*(1.0-mask)+mask*(-sign(dir)+1.0);\n                localfloor = pos2d;\n                floorpos += localfloor*stepsize;\n            } else {\n\n\n                vec3 dists = abs((signdir*0.5+0.5)-(localpos-localfloor))*invdir;\n\n                float m = min(min(dists.x,dists.y),dists.z);\n\n                mask = step(dists,vec3(m));\n\n                dist += m*stepsize;\n                pos += m*dir*stepsize;\n                localpos += m*dir;\n                localfloor += mask*signdir;\n                floorpos += mask*signdir*stepsize;\n            }\n        }\n        if (dist < 7.9&&hit) {\n            fragColor = vec4(abs(.5+.5*mask), 1);\n        }\n    }\n    /*if (all(lessThan(fragCoord,vec2(50.0,50.0)))) {\n        \n        fragColor = vec4(1.0-num(fragCoord-vec2(37.5,22.5),20.0,int(1.0/iTimeDelta)));\n    }*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lssyW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 200, 251, 290, 658], [660, 707, 726, 726, 1221], [1293, 1293, 1350, 1350, 3981]]}
{"id": "lsXcWs", "name": "Bibliotheque", "author": "dr2", "description": "Another library, with lots more books (use the mouse)", "tags": ["raymarching", "library", "books"], "likes": 7, "viewed": 535, "published": "Public API", "date": "1490299026", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Bibliotheque\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRCylDf (vec3 p, float r, float rt, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\n\nconst float pi = 3.14159;\n\nvec3 ltDir;\nvec2 bsa1, bsa2;\nfloat dstFar, tCur, szRg, rdRm, htRm, rdCl, htCl, wdDr, spShf, htShf, rdLt, htLt;\nint idObj;\nconst int idRm = 1, idCol = 2, idChr = 3, idBks = 4, idShlf = 5, idNm = 6, idLt = 7;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  vec2 w;\n  float dMin, d, a, r;\n  dMin = dstFar;\n  q = p;\n  q.xz = mod (q.xz + szRg, 2. * szRg) - szRg;\n  r = length (q.xz);\n  a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n  d = max (r - rdRm, - q.y - htRm);\n  qq = q;  qq.y -= - htCl;\n  d = max (d, length (qq) - rdCl);\n  qq = q;  qq.y -= -0.2;\n  qq = abs (qq);\n  w = vec2 (min (qq.x, qq.z), qq.y) - vec2 (wdDr, htRm - 0.2);\n  d = - min (d, min (max (w.x, w.y), 0.));\n  if (d < dMin) { dMin = d;  idObj = idRm; }\n  qq.xz += step (qq.x, qq.z) * (qq.zx - qq.xz) - vec2 (rdRm, wdDr);\n  d = PrCylDf (qq.xzy, 0.3, htRm - 0.2);\n  if (d < dMin) { dMin = d;  idObj = idCol; }\n  qq = q;  qq.y -= 0.7 - htRm;\n  d = PrRCylDf (qq.xzy, 2.5, 0.1, 0.7);\n  if (d < dMin) { dMin = d;  idObj = idChr; }\n  qq = q;  qq.y -= 1.65 - htRm;\n  d = PrCylDf (qq.xzy, 1., 0.25);\n  if (d < dMin) { dMin = d;  idObj = idNm; }\n  q.xz = Rot2D (q.xz, 2. * pi * ((floor (4. * a) + 0.5) / 4.));\n  q.z = abs (q.z);\n  d = max (abs (r - rdRm + 0.6) - 0.6, dot (q.xz, bsa2));\n  d = max (d, abs (q.y) - htRm);\n  if (d < dMin) { dMin = d;  idObj = idBks; }\n  d = max (abs (r - rdRm + 0.9) - 0.9, dot (q.xz, bsa1));\n  d = max (d, min (abs (mod (q.y + 0.5 * spShf, spShf) -\n     0.5 * spShf) - htShf, - dot (q.xz, bsa2)));\n  d = max (d, abs (q.y) - htRm);\n  if (d < dMin) { dMin = d;  idObj = idShlf; }\n  qq = q;  qq.y -= rdCl - htCl - 0.4;\n  d = PrCylDf (qq.xzy, 2., 0.15);\n  qq = q;  qq.y -= htLt;\n  d = min (d, max (PrTorusDf (qq.xzy, 0.15, rdLt), dot (q.xz, bsa1)));\n  if (d < dMin) { dMin = d;  idObj = idLt; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  float f;\n  p *= 4.;\n  f = dot (vec3 (Fbm2 (p.zy * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.xy * vec2 (1., 0.1))), abs (n));\n  return 0.7 * mix (vec3 (0.8, 0.5, 0.3), vec3 (0.55, 0.35, 0.1), f);\n}\n\nvec3 FloorCol (vec2 p)\n{\n  return mix (vec3 (0.8, 0.4, 0.2), vec3 (0.5, 0.25, 0.1),\n     Fbm2 (20. * vec2 (1., 0.1) * p.xy)) *\n     (0.5 + 0.5 * SmoothBump (0.03, 0.97, 0.01, mod (3. * p.x, 1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, q;\n  vec2 gbRm, gbBk;\n  float dstObj, a, s, bh, r, cRm;\n  int idObjT;\n  bool isLit;\n  rdRm = 18.;\n  rdCl = 1.3 * rdRm; \n  htCl = sqrt (rdCl * rdCl - rdRm * rdRm) - htRm - 1.;\n  rdLt = 0.9 * rdRm;\n  htLt = sqrt (rdCl * rdCl - rdLt * rdLt) - htCl;\n  wdDr = 2.5;\n  htShf = 0.07;\n  spShf = 0.167 * (2. * htRm - htShf);\n  bsa1 = vec2 (sin (1. * 2. * pi / 16.), cos (1. * 2. * pi / 16.));\n  bsa2 = vec2 (sin (0.97 * 1. * 2. * pi / 16.), cos (0.97 * 1. * 2. * pi / 16.));\n  isLit = true;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    if (idObj == idNm) {\n      if (ro.y + rd.y * dstObj > 1.9 - htRm - 0.01) {\n        ro += rd * dstObj;\n        rd = reflect (rd, vec3 (0., 1., 0.));\n        ro += 0.01 * rd;\n        dstObj = ObjRay (ro, rd);\n      }\n    }\n  }\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    q = ro;\n    gbRm = floor (q.xz / (2. * szRg) + 0.5);\n    cRm = mod (31. * Fbm2 (gbRm * vec2 (17., 11.)), 1.);\n    q.xz = mod (q.xz + szRg, 2. * szRg) - szRg;\n    r = length (q.xz);\n    a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n    if (idObj == idRm) {\n      a *= 4.;\n      if (ro.y < - (htRm - 0.001)) {\n        if (r > 2. * wdDr) col = FloorCol ((min (abs (q.x), abs (q.z)) < wdDr) ?\n           ((abs (q.x) < abs (q.z)) ? ro.xz : ro.zx) :\n           vec2 (r, 20. * (mod (a, 1.) - 0.5)));\n        else col = HsvToRgb (vec3 (cRm, 1., 0.7)) *\n           (1. - 0.1 * smoothstep (0.4, 0.6, Fbm2 (3. * ro.xz)));\n        s = mix (1. - 0.3 * smoothstep (0.3, 0.6, r / rdRm),\n           0.8 + 0.2 * smoothstep (0.1, 0.3, abs (0.5 - mod (a - 0.5, 1.))),\n           smoothstep (0.7, 0.85, r / rdRm));\n        col *= s;\n        isLit = false;\n      } else if (r > rdRm + 0.001) {\n        col = vec3 (0., 0., 0.3 + 0.5 * (htRm + ro.y) / (2. * htRm - 0.4));\n        isLit = false;\n      } else if (ro.y < htRm - 0.4) {\n        col = vec3 (0.6, 0.6, 0.7);\n        if (r < rdRm)\n           vn.xz = Rot2D (vn.xz, 0.5 * (mod (100. * mod (a, 1.), 1.) - 0.5));\n      } else if (ro.y < htRm + 1.001) {\n        col = vec3 (0.6, 0.6, 0.7);\n      } else {\n        s = mix (1. - 0.3 * smoothstep (0.4, 0.7, r / rdRm),\n           0.7 + 0.3 * smoothstep (0.2, 0.3, abs (0.5 - mod (a - 0.5, 1.))),\n           smoothstep (0.75, 0.95, r / rdRm));\n        col = vec3 (0., 0., 0.3) + vec3 (0.4, 0.4, 0.3) * s;\n        s = 0.;\n        rd = (normalize (q) + vec3 (1., 0.7, 0.3) +\n           0.1 * normalize (vec3 (gbRm.x, 0.1, gbRm.y)));\n        for (int j = 0; j < 19; j ++) rd = abs (rd) / dot (rd, rd) - 0.9;\n        s += min (1., 0.5e-3 * pow (min (6., length (rd)), 5.));  \n        col += s * vec3 (0.4, 0.4, 0.15);\n        isLit = false;\n      }\n      if (isLit) vn = VaryNf (100. * ro, vn, 2.);\n    } else if (idObj == idCol) {\n      a = abs (1. - 2. * mod (atan (vn.z, vn.x) / (2. * pi), 1.));\n      col = HsvToRgb (vec3 (cRm, 1., 0.9)) *\n         (0.8 + 0.2 * smoothstep (0.3, 0.7,\n         Fbm2 (gbRm + vec2 (5. * a, 10. * ro.y + 0.3 * sin (8. * pi * a)))));\n    } else if (idObj == idChr) {\n      col = vec3 (0.3, 0.2, 0.);\n      if (r > 0.2) col *=\n         0.4 + 0.6 * SmoothBump (-0.4, 0.4, 0.05, mod (4. * a + 0.5, 1.) - 0.5);\n    } else if (idObj == idBks) {\n      a = 120. * mod (mod (4. * a + 1./8., 4.), 4.);\n      gbBk = floor (vec2 (q.y / spShf, a));\n      bh = (0.7 + 0.3 * Fbm2 ((gbRm + gbBk) * vec2 (19., 31.))) * spShf;\n      q.y = mod (q.y, spShf);\n      if (q.y < bh) { \n        s = mod (a, 1.);\n        col = vec3 (HsvToRgb (vec3 (mod (cRm +\n           0.4 * (Fbm2 (gbBk * vec2 (17., 11.)) - 0.5), 1.), 1.,\n           0.9 * SmoothBump (0.08, 0.92, 0.01, 0.1 + 0.9 * s) *\n           (1. - 0.3 * step (abs (abs (q.y / bh - 0.5) - 0.35), 0.02)))));\n        vn.xz = Rot2D (vn.xz, 2. * (s - 0.5));\n        vn = VaryNf (20. * ro, vn, 1.);\n      } else col = vec3 (0.1);\n    } else if (idObj == idShlf) {\n      q = vec3 (5. * (mod (4. * a, 1.) - 0.5), ro.y, r);\n      col = WoodCol (q, vn);\n    } else if (idObj == idLt) {\n      col = vec3 (1., 1., 0.6) * 0.5 * (1. - vn.y);\n      isLit = false;\n    } else if (idObj == idNm) {\n      col = vec3 (0.8, 0.8, 0.);\n      q.xy = vec2 (-2. * (mod (3. * a + 0.5 * tCur + 0.5, 1.) - 0.5),\n         ro.y - (1.65 - htRm));\n      if (abs (q.x) < 0.6 && abs (q.y) < 0.2) {\n        if (ShowInt (vec2 (q.x - 0.45, q.y + 0.13),\n           vec2 (1., 0.25), 4., dot (mod (vec2 (42., 24.) + gbRm, 100.),\n           vec2 (100., 1.))) != 0.) col = vec3 (0.8, 0., 0.);\n      }\n      isLit = false;\n    }\n    if (isLit) col = col * (0.5 + 0.5 * max (dot (vn, ltDir), 0.) +\n       0.1 * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.));\n    col = mix (col, vec3 (0.1, 0.1, 0.15), smoothstep (0.6, 1., dstObj / dstFar));\n  } else {\n    col = 0.5 * vec3 (0.6, 0.6, 0.7);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  float s, cCount;\n  t *= 10.;\n  p.y = htRm * (0.1 * SmoothBump (0.2, 0.8, 0.1, mod (0.08 * t, 1.)) + 0.1);\n  s = mod (t, 11.);\n  if (s < 7.) p.xz = (s < 4.) ? vec2 (0., s) : vec2 (s - 4., 4.);\n  else p.xz = (s < 9.) ? vec2 (3., 11. - s) : vec2 (12. - s, 2.);\n  cCount = floor (t / 11.);\n  if (mod (cCount, 2.) == 0.) p.x *= -1.;\n  else p.x -= 1.;\n  p.z += 2. * cCount;\n  p.xz *= 2. * szRg;\n  return p;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, fpF, fpB, vd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, spd;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  szRg = 20.;\n  htRm = 4.;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  }\n  spd = 0.02;\n  fpF = TrackPath (spd * tCur + 0.02);\n  fpB = TrackPath (spd * tCur - 0.02);\n  ro = 0.5 * (fpF + fpB);\n  vd = fpF - fpB;\n  ori = vec2 (el, az - (atan (vd.z, vd.x) - 0.5 * pi));\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 1.7));\n  dstFar = 400.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n)) * (1. / 1.9375);\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return step (abs (q.x), 0.12) * step (abs (q.y), 0.6);\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.5, 2.2);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);\n  DSG (q.xy - vp);\n  DSG (q.xy - vm);\n  DSG (q.yx);\n  DSG (q.xy + vm);\n  DSG (q.xy + vp);\n  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.)) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (sgn < 0.) {\n      if (idChar == mxChar - nDig - 1.) s = ShowDig (q, -1);\n      else ++ v;\n    }\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsXcWs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 728, 750, 750, 2311], [2313, 2313, 2346, 2346, 2522], [2524, 2524, 2545, 2545, 2758], [2760, 2760, 2791, 2791, 3008], [3010, 3010, 3034, 3034, 3208], [3210, 3210, 3245, 3245, 8069], [8071, 8071, 8097, 8097, 8512], [8514, 8514, 8570, 8570, 9489], [9491, 9491, 9533, 9533, 9584], [9586, 9586, 9639, 9639, 9818], [9820, 9820, 9866, 9866, 9923], [9925, 9925, 9982, 9982, 10065], [10067, 10067, 10097, 10097, 10155], [10278, 10278, 10302, 10302, 10349], [10351, 10351, 10376, 10376, 10575], [10577, 10577, 10598, 10598, 10753], [10755, 10755, 10784, 10784, 11012], [11014, 11014, 11053, 11053, 11276], [11278, 11278, 11302, 11302, 11438], [11440, 11440, 11463, 11463, 11522], [11595, 11595, 11627, 11627, 12174], [12176, 12176, 12236, 12236, 12811]]}
{"id": "lsXyDl", "name": "[ Famous curves ] - #1", "author": "Yrai", "description": "For the sake of math, curve gallery must be made :)\n\nVisualizing curves trace by multiple circles with origins obtained at time t_i, t_i-1, ... , t_trace_len_ (with step eps_)\nAlso interesting case of asymptote intersection.", "tags": ["2d", "intersection", "trace", "trail", "parametric", "curvetrail", "curvetrace", "asymptote"], "likes": 4, "viewed": 574, "published": "Public API", "date": "1490289235", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define res_            iResolution\n#define time_           iTime\n#define trace_len_      830\n#define eps_            0.01\n\nvec2  domain(vec2 uv, float s);\nvec2  parametric(float t);\nfloat trace(vec2 p, float t);\n\nvoid mainImage(out vec4 o, vec2 f) {\n\tvec2 p = domain(f, 8.);\n    \n    // t -> [0., 5.]\n    float t = abs(sin(time_)*5.);\n    // Distance from point in space to point at parametrized curve\n    // on time t_i and trace_len_ points backward in time giving \n    // a path of points to draw circles at (curves \"trace\")\n    float dtrace = smoothstep(0.08, 0., trace(p, t));\n    \n    // x - y diagonal line acting as many times intersected asimptote\n    float asymptote = smoothstep(0.05, 0., abs(p.x-p.y));\n    // Axis\n    float ax = min(\n        smoothstep(0., 0.02, abs(p.x)),\n        smoothstep(0., 0.02, abs(p.y))\n    );\n    // Origin\n    float org = smoothstep(0.09, 0., length(p)-.02);\n    \n    // Palette \n    vec3 orange = vec3(257., 111., 24.) / 255.;\n    vec3 gray   = vec3(.2);\n    vec3 white  = vec3(5.);\n    vec3 red    = vec3(1., 0., 0.);\n    \n    // Shading\n    vec3 c  = vec3(0.);\n    c = mix(c, gray, asymptote);\n    c = mix(c, orange, dtrace);\n    c = mix(c, gray, 1.-ax);\n    c = mix(c, red, org);\n    \n    o = vec4(sqrt(c), 1.);\n}\n\nvec2 parametric(float t) {\n\tfloat n = 22.;\n    return vec2(t + cos(n*t) / t, t + sin(n*t) / t);\n}\n\nfloat trace(vec2 p, float t) {\n    float d = 1e10;\n    float e = 0.;\n    for(int i = 0; i < trace_len_; i++) {\n    \td  = min(d, distance(p, parametric(t-e)));\n        e += eps_; \n    }\n    return d;\n}\n\nvec2 domain(vec2 uv, float s) {\n    return (2. * uv.xy - res_.xy) / res_.y * s;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsXyDl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1, 303, 339, 339, 1348], [1350, 1350, 1376, 1376, 1447], [1449, 1449, 1479, 1479, 1649], [1651, 1651, 1682, 1682, 1732]]}
{"id": "lsXyzX", "name": "Line of Sight", "author": "dr2", "description": "Hexagonal grid line of sight", "tags": ["grid", "hexagons", "lineofsight"], "likes": 11, "viewed": 797, "published": "Public API", "date": "1489075055", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Line of Sight\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Hexagonal grid line of sight (all cells that line intersects - unlike Bresenham\n  which only shows one cell per row/column).\n\n  The hexagonal grid tutorial http://www.redblobgames.com/grids/hexagons\n  covers everything except the line-of-sight problem.\n\n  Mouse moves line end.\n*/\n\n#define SQRT3 1.7320508\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (SQRT3/2.) - p.x + 0.5 * min (p.x - SQRT3 * p.y, 0.);\n}\n\nbool HexOnLine (vec2 v, vec2 b)\n{\n  vec3 w;\n  w = abs (vec3 (v.x, 0.5 * (v.x + SQRT3 * v.y), 0.5 * (v.x - SQRT3 * v.y)));\n  return (abs (b.x * v.y - b.y * v.x) < max (w.x, max (w.y, w.z)));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 col;\n  vec2 canvas, uv, va, cId, pMid, s1, s2, ds, db, r;\n  float tCur, scale, dEdge, lenLn, d, a;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  scale = 10.;\n  a = 0.3 * tCur;\n  va = vec2 (canvas.x / canvas.y, 1.);\n  r = vec2 (cos (a), sin (a)) * va;\n  s1 = (mPtr.z > 0.) ? 2. * mPtr.xy * va : - 0.4 * r;\n  s2 = s1 + 1.3 * r;\n  ds = s2 - s1;\n  lenLn = length (ds);\n  cId = PixToHex (scale * uv);\n  pMid = HexToPix (cId) / scale;\n  db = pMid - s1;\n  d = (lenLn > 0.) ? dot (db, ds) / lenLn : 0.;\n  dEdge = HexEdgeDist (scale * (uv - pMid));\n  if (all (equal (PixToHex (scale * s1), cId)) ||\n      all (equal (PixToHex (scale * s2), cId)) ||\n      d > 0. && d < lenLn && HexOnLine (ds, scale * db)) {\n    col = HsvToRgb (vec3 (1., 1. - 1.2 * dEdge,\n       min (1. + 0.2 * sin (50. * dEdge), 1.)));\n    col = mix (col, vec3 (0., 0., 1.), step (length (uv - pMid), 0.015));\n  } else col = vec3 (0.2);\n  col = mix (vec3 (0., 1., 0.), col, step (0.04, dEdge));\n  db = uv - s1;\n  d = (lenLn > 0.) ? dot (db, ds) / lenLn : 0.;\n  if (d > 0. && d < lenLn) col = mix (col, vec3 (1., 1., 0.),\n     (1. - smoothstep (0.003, 0.004, sqrt (max (0., dot (db, db) - d * d)))));\n  if (mPtr.z > 0. && scale * length (uv - 2. * mPtr.xy * va) < 0.15) col *= 2.;\n  fragColor = vec4 (clamp (col, 0., 1.), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsXyzX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[121, 433, 457, 457, 687], [689, 689, 713, 713, 773], [775, 775, 803, 803, 883], [885, 885, 918, 918, 1076], [1078, 1078, 1102, 1102, 1238], [1240, 1240, 1293, 1293, 2724]]}
{"id": "lt2SDc", "name": "Morula Ion Channel Formation", "author": "tomachi", "description": "Living cell division simulation of the early embryo. Adapted from source by MU6K, this is a large number of meta balls in the same place that gradually move into different positions. Inspired by Hexaballs here: https://www.shadertoy.com/view/Mss3WN ", "tags": ["simulation"], "likes": 10, "viewed": 350, "published": "Public API", "date": "1489668710", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nAdapted from https://www.shadertoy.com/view/Mss3WN by tomachi\n\nby mu6k, Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n I have no idea how I ended up here, but it demosceneish enough to publish.\n You can use the mouse to rotate the camera around the 'object'.\n If you can't see the shadows, increase occlusion_quality.\n If it doesn't compile anymore decrease object_count and render_steps.\n\n 15/06/2013:\n - published\n \n 16/06/2013:\n - modified for better performance and compatibility\n\n muuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuusk!*/\n\n#define occlusion_enabled\n#define occlusion_quality 4\n//#define occlusion_preview\n\n#define noise_use_smoothstep\n\n#define light_color vec3(0.1,0.4,0.6)\n#define light_direction normalize(vec3(.2,1.0,-0.2))\n#define light_speed_modifier 1.0\n\n#define object_color vec3(0.9,0.1,0.1)\n#define object_count 12\n#define object_speed_modifier 2.0\n\n#define render_steps 33\n\nfloat hash(float x)\n{\n\treturn fract(sin(x*.0127863)*17143.321);\n}\n\nfloat hash(vec2 x)\n{\n\treturn fract(cos(dot(x.xy,vec2(2.31,53.21))*124.123)*412.0); \n}\n\nvec3 cc(vec3 color, float factor,float factor2) //a wierd color modifier\n{\n\tfloat w = color.x+color.y+color.z;\n\treturn mix(color,vec3(w)*factor,w*factor2);\n}\n\nfloat hashmix(float x0, float x1, float interp)\n{\n\tx0 = hash(x0);\n\tx1 = hash(x1);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(0.0,1.0,interp);\n\t#endif\n\treturn mix(x0,x1,interp);\n}\n\nfloat noise(float p) // 1D noise\n{\n\tfloat pm = mod(p,1.0);\n\tfloat pd = p-pm;\n\treturn hashmix(pd,pd+1.0,pm);\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\nfloat max3(float a, float b, float c)//returns the maximum of 3 values\n{\n\treturn max(a,max(b,c));\n}\n\nvec3 bpos[object_count];//position for each metaball\n\nfloat dist(vec3 p)//distance function\n{\n\tfloat d=1024.0;\n\tfloat nd;\n\tfor (int i=0 ;i<object_count; i++)\n\t{\n\t\tvec3 np = p+bpos[i];\n\t\tfloat shape0 = max3(abs(np.x),abs(np.y),abs(np.z))-1.0;\n\t\tfloat shape1 = length(np)-1.0;\n\t\tnd = shape0+(shape1-shape0)*2.0;\n\t\td = mix(d,nd,smoothstep(-0.10,+0.10,d-nd));\n\t}\n\treturn d;\n}\n\nvec3 normal(vec3 p,float e) //returns the normal, uses the distance function\n{\n\tfloat d=dist(p);\n\treturn normalize(vec3(dist(p+vec3(e,0,0))-d,dist(p+vec3(0,e,0))-d,dist(p+vec3(0,0,e))-d));\n}\n\nvec3 light = light_direction; //global variable that holds light direction\n\nvec3 background(vec3 d)//render background\n{\n\tfloat t=iTime*0.5*light_speed_modifier;\n\tfloat qq = dot(d,light)*.5+.5;\n\tfloat bgl = qq;\n\tfloat q = (bgl+noise(bgl*6.0+t)*.85+noise(bgl*12.0+t)*.85);\n\tq+= pow(qq,32.0)*2.0;\n\tvec3 sky = vec3(0.1,0.4,0.6)*q;\n\treturn sky;\n}\n\nfloat occlusion(vec3 p, vec3 d)//returns how much a point is visible from a given direction\n{\n\tfloat occ = 1.0;\n\tp=p+d;\n\tfor (int i=0; i<occlusion_quality; i++)\n\t{\n\t\tfloat dd = dist(p);\n\t\tp+=d*dd;\n\t\tocc = min(occ,dd);\n\t}\n\treturn max(.0,occ);\n}\n\nvec3 object_material(vec3 p, vec3 d)\n{\n\tvec3 color = normalize(object_color*light_color);\n\tvec3 n = normal(p,0.1);\n\tvec3 r = reflect(d,n);\t\n\t\n\tfloat reflectance = dot(d,r)*.5+.5;reflectance=pow(reflectance,2.0);\n\tfloat diffuse = dot(light,n)*.5+.5; diffuse = max(.0,diffuse);\n\t\n\t#ifdef occlusion_enabled\n\t\tfloat oa = occlusion(p,n)*.4+.6;\n\t\tfloat od = occlusion(p,light)*.95+.05;\n\t\tfloat os = occlusion(p,r)*.95+.05;\n\t#else\n\t\tfloat oa=1.0;\n\t\tfloat ob=1.0;\n\t\tfloat oc=1.0;\n\t#endif\n\t\n\t#ifndef occlusion_preview\n\t\tcolor = \n\t\tcolor*oa*.2 + //ambient\n\t\tcolor*diffuse*od*.7 + //diffuse\n\t\tbackground(r)*os*reflectance*.7; //reflection\n\t#else\n\t\tcolor=vec3((oa+od+os)*.3);\n\t#endif\n\t\n\treturn color;\n}\n\n#define offset1 4.7\n#define offset2 4.6\n#define cells  = 6 + int(iTime);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //int cells = 6 + int(iTime);\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\t\n    float t = iTime*.1*object_speed_modifier - 1.0;\n\t\n    //if ( iTime > float(cells) ) { cells++ }\n \n\tfor (int i=0; i<object_count; i++) //position for each metaball\n\t{\n\t\tbpos[i] = 1.3*vec3(\n\t\t\tsin(t*float(i)*0.1),\n\t\t\tsin(t*float(i)*0.01),\n\t\t\tsin(t*float(i)*-0.2));\n        \n        \n       /* bpos[i] = 1.0*vec3(\n\t\t\tsin(t*0.967+float(i)*42.0),\n\t\t\tsin(t*.423+float(i)*152.0),\n\t\t\tsin(t*.76321+float(i))); // */\n\t}\n\t\n\t//setup the camera\n\tvec3 p = vec3(.0,0.0,-4.0);\n\tp = rotate_x(p,mouse.y*9.0+offset1);\n\tp = rotate_y(p,mouse.x*9.0+offset2);\n\tvec3 d = vec3(uv,1.0);\n\td.z -= length(d)*.3; //lens distort\n\td = normalize(d);\n\td = rotate_x(d,mouse.y*9.0+offset1);\n\td = rotate_y(d,mouse.x*9.0+offset2);\n\t\n\t//and action!\n\tfloat dd;\n\tvec3 color;\n\tfor (int i=0; i<render_steps; i++) //raymarch\n\t{\n\t\tdd = dist(p);\n\t\tp+=d*dd*.7;\n\t\tif (dd<.04 || dd>5.0) break;\n\t}\n\t\n\tif (dd<5.0002) //close enough or edge\n\t\tcolor = object_material(p,d) * 1.1 ;\n    \t//color = vec3(0, 0, 255);\n\telse\n\t\tcolor = background(d);\n\t\n\t//post procesing\n\tcolor *=.85;\n\tcolor = mix(color,color*color,0.3);\n\tcolor -= hash(color.xy+uv.xy)*.015;\n\tcolor -= length(uv)*.1;\n\tcolor =cc(color,.5,.6);\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2SDc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[614, 921, 942, 942, 986], [988, 988, 1008, 1008, 1073], [1075, 1075, 1149, 1149, 1232], [1234, 1234, 1283, 1283, 1419], [1421, 1421, 1455, 1455, 1530], [1532, 1532, 1568, 1568, 1685], [1687, 1687, 1723, 1723, 1841], [1843, 1843, 1915, 1915, 1942], [1968, 1998, 2037, 2037, 2315], [2317, 2317, 2395, 2395, 2507], [2539, 2585, 2629, 2629, 2851], [2853, 2853, 2946, 2946, 3096], [3098, 3098, 3136, 3136, 3788], [3863, 3863, 3920, 3954, 5310]]}
{"id": "MdfcRS", "name": "isovalues 2", "author": "FabriceNeyret2", "description": "better seen in fullscreen", "tags": ["noise", "contour"], "likes": 19, "viewed": 1243, "published": "Public API", "date": "1488641730", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// see also analytical derivatives version: https://www.shadertoy.com/view/XdlyzS\n\n// --- noise from procedural pseudo-Perlin ( adapted from IQ ) ---------\n\nfloat noise3( vec3 x ) {\n    vec3 p = floor(x),f = fract(x);\n\n    f = f*f*(3.-2.*f);  // or smoothstep     // to make derivative continuous at borders\n\n#define hash3(p)  fract(sin(1e3*dot(p,vec3(1,57,-13.7)))*4375.5453)        // rand\n    \n    return mix( mix(mix( hash3(p+vec3(0,0,0)), hash3(p+vec3(1,0,0)),f.x),       // triilinear interp\n                    mix( hash3(p+vec3(0,1,0)), hash3(p+vec3(1,1,0)),f.x),f.y),\n                mix(mix( hash3(p+vec3(0,0,1)), hash3(p+vec3(1,0,1)),f.x),       \n                    mix( hash3(p+vec3(0,1,1)), hash3(p+vec3(1,1,1)),f.x),f.y), f.z);\n}\n\n#define noise(x) (noise3(x)+noise3(x+11.5)) / 2. // pseudoperlin improvement from foxes idea \n\n\n\nvoid mainImage( out vec4 O, vec2 U ) // ------------ draw isovalues\n{\n    U *= 8./iResolution.y;\n    float n = noise(vec3(U,.1*iTime)),\n          v = sin(6.28*10.*n);\n    v = smoothstep(-1.,1., .7*abs(v)/fwidth(v));  // first try with (0.,1. was not so good )\n    n = floor(n*20.)/20.;\n\tO = v * (.5+.5*cos(12.*n+vec4(0,2.1,-2.1,0)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdfcRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 157, 181, 181, 744], [843, 843, 912, 912, 1178]]}
{"id": "MdfcRX", "name": "inspiration of star wars ui", "author": "yasuo", "description": "It's just an experiment.", "tags": ["transparent", "starwars"], "likes": 7, "viewed": 772, "published": "Public API", "date": "1489066550", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/**\nThis code is based on \"https://www.shadertoy.com/view/Md3SDB\". \nFrom my side, I just replaced geometory model to startwars ship model which I used iq's distance function. \n*/\n\nstruct tweenObj {\n    vec3 pos;\n};\n\nconst bool GlowEnabled = true;\nconst float WallDistance = 0.01;\nconst float GlowDistance = 0.00574;\n\nconst bool Jitter = true;\nconst float MarchDumping = 0.658;\nconst float Far = 64.0;\nconst int MaxSteps = 128;\n\n#define PI 3.141592\n#define RADIANS(x) ((x) * (PI / 180.0))\n\nvec4 QuatRotate (float x,float y,float z,float deg){\t\n    float rad = deg * (PI / 180.0) / 2.0;\n    float s = sin(rad);\n    return vec4(\n        cos(rad), //w\n        x * s, //x\n        y * s, //y\n        z * s //z\n    );\n}\n\nmat4 QuatRotateConvertToMatrix(vec4 q){\n    float s = sqrt(q.w * q.w + q.x * q.x + q.y * q.y\n                   + q.z * q.z);\n    s = 2.0 / (s * s);\n    float vx = q.x * s;\n    float vy = q.y * s;\n    float vz = q.z * s;\n    float wx = vx * q.w;\n    float wy = vy * q.w;\n    float wz = vz * q.w;\n    float sx = q.x * vx;\n    float sy = q.y * vy;\n    float sz = q.z * vz;\n    float cx = q.y * vz;\n    float cy = q.z * vx;\n    float cz = q.x * vy;\n\n    return mat4(\n        1.0 - sy - sz,\n        cz + wz,\n        cy - wy,\n        0.0,\n        cz - wz,\n        1.0 - sx - sz,\n        cx + wx,\n        0.0,\n        cy + wy,\n        cx - wx,\n        1.0 - sx - sy,\n        0.0,\n        0.0,\n        0.0,\n        0.0,\n        1.0\n    );\n}\n\nfloat line( vec2 a, vec2 b, vec2 p ) {\n    vec2 aTob = b - a;\n    vec2 aTop = p - a;\n\n    float t = dot( aTop, aTob ) / dot( aTob, aTob);\n\n    t = clamp( t, 0.0, 1.0);\n\n    float d = length( p - (a + aTob * t) );\n    d = 0.001 / d;\n\n    d = pow(d, 10.0);\n    return clamp( d, 0.0, 0.6 );\n}\n\n// Hash by iq\nfloat hash(float h) {\n    return fract(sin(h) * 43758.5453123);\n}\n\n// from http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// from http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdHexPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\n// from http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat dot2( in vec2 v ) { \n    return dot(v,v);\n}\n\n// bottom radius, top radius, height\nfloat sdCappedCone (vec3 p, vec3 s) {\n    vec2 q = vec2(length(p.xy),p.z);\n\n    vec2 ba = vec2(s.x - s.y, -2.0*s.z);\n    vec2 pa = vec2(q.x - s.y, q.y - s.z);\n\n    vec2 d = pa - ba * clamp(dot(pa,ba) / dot(ba,ba),0.0,1.0);\n    vec2 h0 = vec2(max(q.x - s.x,0.0),q.y + s.z);\n    vec2 h1 = vec2(max(q.x - s.y,0.0),q.y - s.z);\n\n    return sqrt(min(dot2(d),min(dot2(h0),dot2(h1))))\n        * sign(max(dot(pa,vec2(-ba.y, ba.x)), abs(q.y) - s.z));\n}\n\nfloat combine(float d1, float d2 ) {\n    if ( d1 < d2 ) return d1;\n    return d2;\n}\n\nfloat cubicOut(float t) {\n\tfloat f = t - 1.0;\n  \treturn f * f * f + 1.0;\n    /*\n    return t < 0.5\n        ? 4.0 * t * t * t\n        : -0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n    */\n}\n\nfloat tween(float t, float dur, float delay, float val, float now){\n    return cubicOut(clamp(t-delay,0.0,dur)/dur)*(val-now);\n}\n\nfloat map(vec3 p) {\n    tweenObj tobj;\n    tweenObj tobj2;\n    tobj.pos = vec3(0);\n    tobj2.pos = vec3(0);\n    float t = mod(iTime,4.0);\n\n    float val = tween(t,1.0,1.0,0.05,tobj.pos.x);\n    tobj.pos.x = val;\n    val += tween(t,1.0,3.2,0.0,tobj.pos.x);\n    tobj.pos.x = val;\n\n    float val2 = tween(t,1.0,1.2,0.03,tobj2.pos.x);\n    tobj2.pos.x = val2;\n    val2 += tween(t,1.0,3.0,0.0,tobj2.pos.x);\n    tobj2.pos.x = val2;\n\n    float v1 = sdHexPrism(p+vec3(0.0,0.0,0.15+tobj.pos.x), vec2(0.18,0.006) );\n    float v2 = sdHexPrism(p+vec3(0.0,0.0,0.14+tobj.pos.x), vec2(0.05,0.005) );\n    float v3 = sdHexPrism(p+vec3(0.0,0.0,-0.15-tobj.pos.x), vec2(0.18,0.006) );\n    float v4 = sdHexPrism(p+vec3(0.0,0.0,-0.14-tobj.pos.x), vec2(0.05,0.005) );\n    float v5 = sdCapsule(p, vec3(0), vec3(0), 0.08);\n\n    mat4 m = QuatRotateConvertToMatrix(QuatRotate(1.0,0.0,0.0,-180.0));\n    vec4 pos1 = (vec4(p,1.0)+vec4(0.0,0.0,0.10+tobj2.pos.x,0.05));\n    float v6 = sdCappedCone(pos1.xyz, vec3(0.015,0.04,0.045) );\n\n    vec4 pos2 = (vec4(p,1.0)+vec4(0.0,0.0,-0.10-tobj2.pos.x,0.05))*m;\n    float v7 = sdCappedCone(pos2.xyz, vec3(0.015,0.04,0.045) );\n\n    float res1 = combine(v1,v2);\n    float res2 = combine(v3,v4);\n    float res3 = combine(v5,v6);\n    float res4 = combine(v7,res1);\n    float res5 = combine(res2,res3);\n    float res6 = combine(res4,res5);\n    return res6;\n}\n\nfloat shapeProgress(float t) {\n    t = mod(t, 15.0);\n\n    float prog = 0.0;\n    prog += smoothstep(2.0, 3.0, t);\n    prog += smoothstep(5.0, 6.0, t);\n    prog += smoothstep(8.0, 9.0, t);\n    prog += smoothstep(11.0, 12.0, t);\n    prog += smoothstep(14.0, 15.0, t);\n\n    return prog;\n}\n\nvec3 render(vec3 ro, vec3 rd, mat4 m) {\n    float tmin = 0.0;\n    float tmax = Far;\n\n    float precis = 0.002;\n    float t = tmin;\n\n    vec3 accu = vec3(0.0);\n    float steps = 0.0;\n    float glowFactor = 0.0;\n\n    for (int i = 0; i < MaxSteps; i++) {\n        steps = float(i);\n        vec4 p = vec4(ro + rd * t,1.0)*m;\n        float d = map(p.xyz);\n        float absd = abs(d);\n\n        if (Jitter) {\n            absd *= 0.8 + hash(absd) * 0.2;\n        }\n\n        if (t > tmax) {\n            break;\n        }\n\n        glowFactor += pow(1.0 - smoothstep(0.0, GlowDistance, d), 14.0)\n            * step(0.0, d);\n        float f = absd * (1.0 - smoothstep(0.0, WallDistance, absd));\n        accu += vec3(f);\n\n        t += max(0.0001, absd * MarchDumping);\n    }\n    glowFactor /= steps;\n\n    if (GlowEnabled) {\n        accu += 0.7 * pow(glowFactor, 1.2) * vec3(0.0, 1.0, 1.0);\n    }\n    return accu;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime;\n    vec2 p = fragCoord.xy / iResolution.xy;\n    vec2 uv = 2.0 * p - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    vec3 rd = normalize(vec3(uv, 3.5));\n    vec4 rotVec = QuatRotate(0.0,1.0,0.0,(time*20.0));//(time*10.0)\n    mat4 m = QuatRotateConvertToMatrix(rotVec);\n    vec3 col = render(ro, rd, m);\n    col = pow(col, vec3(1.2));\n\n    // left side UI\n    p = fragCoord.xy / iResolution.xy;\n    p -= .5;\n    p.y += mod(p.y+time*-0.2,1.0)-0.5;\n\n    vec3 colorUI = vec3(line(vec2(-0.499,1.0),vec2(-0.499,0.0),p));\n    colorUI += vec3(line(vec2(-0.37,1.0),vec2(-0.37,0.0),p));\n    colorUI += vec3(line(vec2(-0.499,1.0),vec2(-0.37,1.0),p));\n    colorUI += vec3(line(vec2(-0.499,0.0),vec2(-0.37,0.0),p));\n\n    colorUI += vec3(line(vec2(-0.434,0.9),vec2(-0.434,0.1),p));\n    colorUI += vec3(line(vec2(-0.48,0.5),vec2(-0.38,0.5),p));\n\n    colorUI += vec3(line(vec2(-0.499,0),vec2(-0.499,-1.0),p));\n    colorUI += vec3(line(vec2(-0.37,0),vec2(-0.37,-1.0),p));\n    colorUI += vec3(line(vec2(-0.499,0),vec2(-0.37,0),p));\n    colorUI += vec3(line(vec2(-0.499,-1.0),vec2(-0.37,-1.0),p));\n    colorUI += vec3(line(vec2(-0.434,-0.1),vec2(-0.434,-0.9),p));\n    colorUI += vec3(line(vec2(-0.48,-0.5),vec2(-0.38,-0.5),p));\n\n    p = fragCoord.xy / iResolution.xy;\n    p -= .5;\n    p.y += mod(p.y+time*-0.4,1.0)-0.5;\n\n    colorUI += vec3(line(vec2(-0.24,1.0),vec2(-0.24,0.0),p));\n    colorUI += vec3(line(vec2(-0.37,1.0),vec2(-0.24,1.0),p));\n    colorUI += vec3(line(vec2(-0.37,0.0),vec2(-0.24,0.0),p));\n\n    colorUI += vec3(line(vec2(-0.305,0.9),vec2(-0.305,0.1),p));\n    colorUI += vec3(line(vec2(-0.36,0.5),vec2(-0.25,0.5),p));\n\n    colorUI += vec3(line(vec2(-0.24,0),vec2(-0.24,-1.0),p));\n    colorUI += vec3(line(vec2(-0.37,0),vec2(-0.24,0),p));\n    colorUI += vec3(line(vec2(-0.37,-1.0),vec2(-0.24,-1.0),p));\n\n    colorUI += vec3(line(vec2(-0.305,-0.1),vec2(-0.305,-0.9),p));\n    colorUI += vec3(line(vec2(-0.36,-0.5),vec2(-0.25,-0.5),p));\n\n    // right side UI\n    p = fragCoord.xy / iResolution.xy;\n    p -= .5;\n    p.y += mod(p.y+time*0.5,1.0)-0.5;\n    colorUI += vec3(line(vec2(0.24,0.5),vec2(0.24,0.0),p));\n    colorUI += vec3(line(vec2(0.24,-0.2),vec2(0.24,-0.5),p));\n\n    p = fragCoord.xy / iResolution.xy;\n    p -= .5;\n    p.y += mod(p.y+time*0.2,0.8)-0.4;\n    colorUI += vec3(line(vec2(0.26,0.0),vec2(0.275,0.0),p))*vec3(1.0,0.0,0.0)*vec3(sin(time*5.0));\n    colorUI += vec3(line(vec2(0.26,0.0),vec2(0.275,0.06),p))*vec3(1.0,0.0,0.0)*vec3(sin(time*5.0));\n\n    colorUI += vec3(line(vec2(0.28,0.0),vec2(0.295,0.06),p))*vec3(sin(time*0.1*5.0));\n    colorUI += vec3(line(vec2(0.30,0.0),vec2(0.315,0.06),p))*vec3(sin(time*0.1*5.0));\n\n    colorUI += vec3(line(vec2(0.32,0.06),vec2(0.335,0.0),p))*vec3(sin(time*0.2*5.0));\n    colorUI += vec3(line(vec2(0.32,0.0),vec2(0.335,0.0),p))*vec3(sin(time*0.2*5.0));\n\n    colorUI += vec3(line(vec2(0.34,0.06),vec2(0.355,0.0),p))*vec3(sin(time*0.3*5.0));\n\n    colorUI += vec3(line(vec2(0.36,0.06),vec2(0.375,0.0),p))*vec3(sin(time*0.4*5.0));\n    colorUI += vec3(line(vec2(0.36,0.06),vec2(0.375,0.06),p))*vec3(sin(time*0.4*5.0));\n\n    colorUI += vec3(line(vec2(0.38,0.03),vec2(0.395,0.03),p))*vec3(sin(time*0.5*5.0));\n    colorUI += vec3(line(vec2(0.40,0.03),vec2(0.415,0.03),p))*vec3(sin(time*0.5*5.0));\n\n    colorUI += vec3(line(vec2(0.42,0.0),vec2(0.435,0.06),p))*vec3(sin(time*0.6*5.0));\n    colorUI += vec3(line(vec2(0.44,0.0),vec2(0.455,0.06),p))*vec3(sin(time*0.6*5.0));\n\n    colorUI += vec3(line(vec2(0.46,0.0),vec2(0.475,0.0),p))*vec3(1.0,0.0,0.0)*vec3(sin(time*0.7*5.0));\n    colorUI += vec3(line(vec2(0.46,0.0),vec2(0.475,0.06),p))*vec3(1.0,0.0,0.0)*vec3(sin(time*0.7*5.0));\n\n    //\n    colorUI += vec3(line(vec2(0.26,0.2),vec2(0.275,0.26),p));\n    colorUI += vec3(line(vec2(0.28,0.2),vec2(0.295,0.26),p));\n\n    colorUI += vec3(line(vec2(0.30,0.2),vec2(0.315,0.2),p))*vec3(1.0,0.0,0.0);\n    colorUI += vec3(line(vec2(0.30,0.2),vec2(0.315,0.26),p))*vec3(1.0,0.0,0.0);\n\n    colorUI += vec3(line(vec2(0.32,0.2),vec2(0.335,0.2),p));\n    colorUI += vec3(line(vec2(0.32,0.26),vec2(0.335,0.2),p));\n\n    colorUI += vec3(line(vec2(0.34,0.2),vec2(0.355,0.26),p));\n\n    colorUI += vec3(line(vec2(0.36,0.26),vec2(0.375,0.26),p));\n    colorUI += vec3(line(vec2(0.36,0.26),vec2(0.375,0.2),p));\n\n    colorUI += vec3(line(vec2(0.38,0.2),vec2(0.395,0.26),p));\n    colorUI += vec3(line(vec2(0.40,0.2),vec2(0.415,0.26),p));\n\n    colorUI += vec3(line(vec2(0.42,0.26),vec2(0.435,0.2),p));\n    colorUI += vec3(line(vec2(0.44,0.26),vec2(0.455,0.2),p));\n\n    colorUI += vec3(line(vec2(0.46,0.26),vec2(0.475,0.2),p));\n    colorUI += vec3(line(vec2(0.46,0.2),vec2(0.475,0.2),p));\n\n    //\n    colorUI += vec3(line(vec2(0.26,0.46),vec2(0.275,0.4),p))*vec3(sin(time*0.1*5.0));\n    colorUI += vec3(line(vec2(0.26,0.4),vec2(0.275,0.4),p))*vec3(sin(time*0.1*5.0));\n\n    colorUI += vec3(line(vec2(0.28,0.4),vec2(0.295,0.46),p))*vec3(sin(time*0.5*5.0));\n    colorUI += vec3(line(vec2(0.30,0.4),vec2(0.315,0.46),p))*vec3(sin(time*0.5*5.0));\n\n    colorUI += vec3(line(vec2(0.32,0.46),vec2(0.335,0.4),p))*vec3(sin(time*0.2*5.0));\n\n    colorUI += vec3(line(vec2(0.34,0.46),vec2(0.355,0.4),p))*vec3(sin(time*0.2*5.0));\n\n    colorUI += vec3(line(vec2(0.36,0.4),vec2(0.375,0.46),p))*vec3(sin(time*0.3*5.0));\n    colorUI += vec3(line(vec2(0.36,0.46),vec2(0.375,0.46),p))*vec3(sin(time*0.3*5.0));\n\tcolorUI*=vec3(0.5,0.9,1.0);\n    fragColor = vec4(colorUI+col*vec3(3.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdfcRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 490, 542, 542, 713], [715, 715, 754, 754, 1448], [1450, 1450, 1488, 1488, 1739], [1741, 1755, 1776, 1776, 1820], [1822, 1897, 1949, 1949, 2076], [2078, 2153, 2189, 2189, 2273], [2275, 2350, 2375, 2375, 2399], [2401, 2438, 2475, 2475, 2880], [2882, 2882, 2918, 2918, 2965], [2967, 2967, 2992, 2992, 3148], [3150, 3150, 3217, 3217, 3278], [3280, 3280, 3299, 3299, 4642], [4644, 4644, 4674, 4674, 4928], [4930, 4930, 4969, 4969, 5829], [5831, 5831, 5888, 5888, 11328]]}
{"id": "MdfcWs", "name": "flaming portal", "author": "gsynuh", "description": "noob to shaders so...\ncomments are welcome :)", "tags": ["fbm"], "likes": 1, "viewed": 158, "published": "Public", "date": "1490303110", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define PI_INV 0.31830988618\n#define TAU 6.28318530718\n#define DEG2RAD 0.01745329251\n#define RAD2DEG 57.2957795131\n#define SEED 935.45111\n#define OCTAVES 7\n\nfloat random (vec2 st) {\n    return fract(SEED + sin(dot(st.xy,vec2(12.9898,78.233)))* 43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n//The Book of shaders\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nmat2 scale(float sx,float sy) {\n  return mat2(sx,.0,.0,sy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   float time = iTime;\n   vec2 uv = fragCoord.xy / iResolution.xy;\n   vec2 center = uv+vec2(-0.5);\n    \n   \n   vec2 uv1  = vec2(center);\n    \n   vec3 color = vec3(0.);\n    \n   uv1 = scale(2.2,0.8) * center + vec2(.0,.1);\n    \n  float t1 = fbm(uv1 + vec2(0.0,-time*2.1)) * 6.;\n  float t2 = fbm(uv1 + vec2(0.0,-time*1.4) + vec2(34.3333,42.22111)) * 6.;\n\n  float c1 = length(uv1*t1);\n  float c2 = length(uv1*t2*4. + vec2(0.0,-.7));\n  float c3 = length(uv1*2. + vec2(0.0,-.5));\n\n  float finalC = c1 + c2 + c3;\n  finalC = finalC/3.;\n\n  float s = 0.999;\n  float th = 0.08;\n\n  float portal = 1. - smoothstep(finalC,s-th,s+th);\n\n  float portalCenter = step(finalC,1.);\n\n  float smoke = fbm(uv*0.8 + vec2(.0,-time*0.24));\n  smoke = smoke * smoke * smoke;\n\n  float otherWorld = fbm(uv*3.4 + vec2(.0,time*0.33));\n  otherWorld =  otherWorld ;\n\n  color = mix(vec3(0.42,0.,0.),vec3(1.,1.,0.),smoke);\n  color = mix(color,vec3(1.,0.93,0.),portal);\n\n  vec3 otherColor = mix(vec3(0.4,0.4,.3),vec3(0.,0.12,.24),otherWorld);\n\n  color = mix(color,otherColor,portalCenter);\n\n  fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdfcWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 182, 206, 206, 286], [288, 366, 392, 392, 772], [774, 796, 820, 842, 1096], [1098, 1098, 1129, 1129, 1159], [1161, 1161, 1218, 1218, 2304]]}
{"id": "MdlcDB", "name": "Voronoi : Hexagons to polygons", "author": "qmuntada", "description": "Simple addition to Iq shader : https://www.shadertoy.com/view/MslGD8", "tags": ["voronoi", "hexagons", "polygons"], "likes": 12, "viewed": 1391, "published": "Public API", "date": "1489789064", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// Modified by qmuntada (2017)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\n// return distance, and cell id\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n\tvec3 m = vec3(8.0);\n    for(int j=-1; j<=1; j++)\n    for(int i=-1; i<=1; i++)\n    {\n        vec2  g = vec2(float(i), float(j));\n        vec2  o = hash(n + g) * (cos(iTime) + 1.0) / 2.0;\n        \n        if (mod(n.x, 2.0) - float(i) == -1.0 || mod(n.x, 2.0) - float(i) == 1.0)\n            o.y += 0.5;\n        \n       \tvec2  r = g - f + o;\n        \n\t\tfloat d = dot(r, r);\n        if(d < m.x)\n            m = vec3(d, o);\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/max(iResolution.x,iResolution.y);\n    \n    // computer voronoi patterm\n    vec2 c = voronoi( (14.0+6.0*sin(0.2*iTime))*p );\n\n    // colorize\n    vec3 col = 0.5 + 0.5 * cos(c.y * 3.0 + vec3(0.0,1.0,2.0) );\t\n    col *= clamp(1.0 - 0.5 * c.x * c.x, 0.0, 1.0);\n    col -= (1.0-smoothstep( 0.05, 0.05, c.x));\n\t\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdlcDB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 156, 177, 177, 268], [270, 302, 329, 329, 843], [845, 845, 902, 902, 1270]]}
{"id": "MdlcDS", "name": "Rounded Voro Rocks", "author": "Dain", "description": "\nThis is Shane's 3d Celltile modified to use Fabrice's rounded voronoi formula.\nAlso tries to vary rock size etc\n\nShanes Cellular Tile Tunnel:\nhttps://www.shadertoy.com/view/MscSDB\nRounded Voronoi:\nhttps://www.shadertoy.com/view/ll3GRM\n", "tags": ["voronoi", "cell", "trabeculae", "celltile"], "likes": 17, "viewed": 988, "published": "Public API", "date": "1489747242", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/*\n//Dain: this is mostly Shane's Cellular Tile Tunnel:  https://www.shadertoy.com/view/MscSDB\n\n//I marked the stuff I changed with a comment followed by my name\n\n    Cellular Tiled Tunnel\n    ---------------------\n    \n    I've always liked the look of a 2nd order Voronoi surface. IQ's Leizex demo is a great\n\tprerendered example, and for anyone who can remember, Tomasz Dobrowolski's Suboceanic\n\twas cutting edge back in the day.\n\n\tAnyway, I've always wanted to get a proper example working in a shader... Yeah, I need\n\tbigger dreams. :) Unfortunately, I kind of realized that it wasn't going to be possible \n\tuntil GPUs become even faster than they already are, so I figured I'd try the next best \n\tthing and come up with a way to emulate the look with something cheap. This is the \n\tresult. It's not perfect, but it looks surprisingly similar.\n\n\tThe regular 2nd order Voronoi algorithm involves a \"lot\" of operations. In general,\n\t27 cell checks - all involving a bunch of vector arithmetic, fract, sin, floor, \n\tcomparisons, etc... It's possible to cut down on cell checks, perform a bunch of\n\toptimizations, etc, but it's still too much work for a raymarcher.\n\n\tThe surface here is produced via a repeat 3D tile approach. The look is achieved by \n\tperforming 2nd order distance checks on the tiles. I used a highly scientific approach\n\twhich involved crossing my fingers, doing the distance checks and hoping for the best. :)\n\tAmazingly, it produced the result I was looking for.\n\n\tI covered the tile construction in other \"cell tile\" examples, so I'll spare you the \n\tdetails, but it's pretty simple. The only additions here are the second order distance\n\tchecks.\n\n\tIn order to show the surface itself, I've made the example geometric looking - I hope\n\tyou like brown, or whatever color that is. :) Note that individual cell regions are \n\tcolored\tdifferently. I did that to show that it could be done, but I'm not convinced \n\tthat it adds to the aesthetics in any meaningful way.\n\n\tAnyway, I have a few more interesting examples that I'll put up pretty soon.\n\t\n    Related examples: \n\n    Cellular Tiling - Shane\n    https://www.shadertoy.com/view/4scXz2\n\n\t// For comparison, this example uses the standard 2nd order Voronoi algorithm. For fun,\n\t// I dropped the cell tile routine into it and it ran a lot faster.\n\tVoronoi - rocks - iq\n\thttps://www.shadertoy.com/view/MsXGzM\n\n\trgba leizex - Inigo Quilez\n\thttp://www.pouet.net/prod.php?which=51829\n\thttps://www.youtube.com/watch?v=eJBGj8ggCXU\n\thttp://www.iquilezles.org/prods/index.htm\n\n\tTomasz Dobrowolski - Suboceanic\n\thttp://www.pouet.net/prod.php?which=18343\n\n*/\n\n#define PI 3.14159265358979\n#define FAR 50. // Maximum allowable ray distance.\n\n// Grey scale.\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\n// Non-standard vec3-to-vec3 hash function.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n// 2x2 matrix rotation.\nmat2 rot2(float a){\n    \n    float c = cos(a); float s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\tvec3 tx = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return tx*tx;\n}\n\n\n// The cellular tile routine. Draw a few objects (four spheres, in this case) using a minumum\n// blend at various 3D locations on a cubic tile. Make the tile wrappable by ensuring the \n// objects wrap around the edges. That's it.\n//\n// Believe it or not, you can get away with as few as three spheres. If you sum the total \n// instruction count here, you'll see that it's way, way lower than 2nd order 3D Voronoi.\n// Not requiring a hash function provides the biggest benefit, but there is also less setup.\n// \n// The result isn't perfect, but 3D cellular tiles can enable you to put a Voronoi looking \n// surface layer on a lot of 3D objects for little cost.\n//\n//Dain: for alternative rocks\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat drawSphere(in vec3 p){\n    \n    //Dain: warp space with sin so the rocks are of varying size\n    p += sin(p);\n    \n    // Anything that wraps the domain will suffice, so any of the following will work.\n    //p = cos(p*3.14159)*0.5; \n    //p = abs(cos(p*3.14159)*0.5);    \n    p = fract(p)-.5;    \n    \n    //Dain: a few alternative rock styles\n    //return abs(p.x) + abs(p.y) + abs(p.z);   //big sharp rocks\n\t//return abs(sdBox(p, vec3(0.9, .10, 0.82))); //long jagged rocks\n    \n    return dot(p, p);\n    \n    // Other metrics to try.\n    \n    //p = abs(fract(p)-.5);\n    //return dot(p, vec3(.5));\n    \n    //p = abs(fract(p)-.5);\n    //return max(max(p.x, p.y), p.z);\n    \n    //p = cos(p*3.14159)*0.5; \n    //p = abs(cos(p*3.14159)*0.5);\n    //p = abs(fract(p)-.5);\n    //return max(max(p.x - p.y, p.y - p.z), p.z - p.x);\n    //return min(min(p.x - p.y, p.y - p.z), p.z - p.x);\n    \n}\n//Dain: alternative shape that makes big jagged rocks(not used)\nfloat drawOct(in vec3 p){\n   // p += sin(p);\n    p = fract(p)-.5; \n    return abs(p.x) + abs(p.y) + abs(p.z);   //big sharp rocks\n}\n// Faster (I'm assuming), more streamlined version. See the comments below for an expanded explanation.\n// The function below is pretty quick also, and can be expanded to include more spheres. This one\n// takes advantage of the fact that only four object need sorting. With three spheres, it'd be even\n// better.\nfloat cellTile(in vec3 p){\n  //  p *= 2.0;\n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawSphere(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawSphere(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .4, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawSphere(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw), v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    //Dain: get 3 closest and use Fabrice's smooth voronoi \n    float m =  min(v.x, v.y);\n    float m2 = min(v.z, v.w);\n    float m3 = max(v.z, v.w);\n    \n    //Dain: if you want a more euclidean distance..\n   // m = sqrt(m);\n   // m2 = sqrt(m2);\n   // m3 = sqrt(m3);\n    \n    //Dain: use Fabrice's formula to produce smooth result\n    return min(2./(1./max(m2 - m, .001) + 1./max(m3 - m, .001)), 1.)*2.5;\n    \n  \n}\n\n/*\n// Draw some spheres throughout a repeatable cubic tile. The offsets were partly based on \n// science, but for the most part, you could choose any combinations you want. Note the \n// normalized planar positional roation between sphere rendering to really mix things up. This \n// particular function is used by the raymarcher, so involves fewer spheres.\n//\nfloat cellTile(in vec3 p){\n\n    // Storage for the closest distance metric, second closest and the current\n    // distance for comparisson testing.\n    //\n    // Set the maximum possible value - dot(vec3(.5), vec3(.5)). I think my reasoning is\n    // correct, but I have lousy deductive reasoning, so you may want to double check. :)\n    vec3 d = (vec3(.75)); \n   \n    \n    // Draw some overlapping objects (spheres, in this case) at various positions on the tile.\n    // Then do the fist and second order distance checks. Very simple.\n    d.z = drawSphere(p - vec3(.81, .62, .53));\n    d.x = min(d.x, d.z); //d.y = max(d.x, min(d.y, d.z)); // Not needed on the first iteration.\n    \n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawSphere(p - vec3(.39, .2, .11));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .24, .06));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071; \n    d.z = drawSphere(p - vec3(.2, .82, .64));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n\n     \n\t// More spheres means better patterns, but slows things down.\n    //p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    //d.z = drawSphere(p - vec3(.48, .29, .2));\n    //d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    //p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    //d.z = drawSphere(p - vec3(.06, .87, .78));\n    //d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z); \n\t\n\n    \n    // Returning what I'm hoping is a normalized result. Not that it\n    // matters too much, but I'd like it normalized.\n    // 2.66 seems to work, but I'll double check at some stage.\n    // d.x: Minimum distance. Regular round Voronoi looking.\n    // d.y - d.x - Maximum minus minimum, for that beveled Voronoi look.\n    //\n    return (d.y - d.x)*2.66; \n    //return 1. - d.x*2.66;\n    //return 1. - sqrt(d.x)*1.63299; // etc.\n\n    \n}\n*/\n\n// Just like the function above, but used to return the regional cell ID...\n// kind of. Either way, it's used to color individual raised sections in\n// the same way that a regular Voronoi function can. It's only called once,\n// so doesn't have to be particularly fast. It's kept separate to the\n// raymarched version, because you don't want to be performing ID checks\n// several times a frame when you don't have to. By the way, that applies\n// to identifying any object in any scene.\n//\n// By the way, it's customary to bundle the respective distance and cell\n// ID into a vector (vec3(d.x, d.y, cellID)) and return that, but I'm \n// keeping it simple here.\n//\nint cellTileID(in vec3 p){\n    \n    int cellID = 0;\n    \n    // Storage for the closest distance metric, second closest and the current\n    // distance for comparisson testing.\n    vec3 d = (vec3(.75)); // Set the maximum.\n    \n    // Draw some overlapping objects (spheres, in this case) at various positions on the tile.\n    // Then do the fist and second order distance checks. Very simple.\n    d.z = drawSphere(p - vec3(.81, .62, .53)); if(d.z<d.x) cellID = 1;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawSphere(p - vec3(.39, .2, .11)); if(d.z<d.x) cellID = 2;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .24, .06)); if(d.z<d.x) cellID = 3;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n   \n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071; \n    d.z = drawSphere(p - vec3(.2, .82, .64)); if(d.z<d.x) cellID = 4;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n\n/* \n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawSphere2(p - vec3(.48, .29, .2)); if(d.z<d.x) cellID = 5;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere2(p - vec3(.06, .87, .78)); if(d.z<d.x) cellID = 6;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z); \n*/ \n    \n    return cellID;\n    \n}\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ float s = sin(z/24.)*cos(z/16.); return vec2(s*9., 0); }\n\n// Standard tunnel distance function with some perturbation thrown into the mix. A tunnel is just a tube \n// with a smoothly shifting center as you traverse lengthwise. The walls of the tube are perturbed by the\n// cheap 3D surface function I described above.\nfloat map(vec3 p){\n\n    \n    float sf = cellTile(p/2.5);\n    \n    // Tunnel bend correction, of sorts. Looks nice, but slays framerate, which is disappointing. I'm\n    // assuming that \"tan\" function is the bottleneck, but I can't be sure.\n    //vec2 g = (path(p.z + 0.1) - path(p.z - 0.1))/0.2;\n    //g = cos(atan(g));\n    p.xy -= path(p.z);\n    //p.xy *= g;\n  \n    // Round tunnel.\n    // For a round tunnel, use the Euclidean distance: length(p.xy).\n    return 1.- length(p.xy*vec2(0.5, 0.7071)) + (0.5-sf)*.35;\n\n    \n/*\n    // Rounded square tunnel using Minkowski distance: pow(pow(abs(tun.x), n), pow(abs(tun.y), n), 1/n)\n    vec2 tun = abs(p.xy)*vec2(0.5, 0.7071);\n    tun = pow(tun, vec2(8.));\n    float n =1.-pow(tun.x + tun.y, 1.0/8.) + (0.5-sf)*.35;\n    return n;//min(n, p.y + FH);\n*/\n    \n/*\n    // Square tunnel.\n    // For a square tunnel, use the Chebyshev(?) distance: max(abs(tun.x), abs(tun.y))\n    vec2 tun = abs(p.xy - path(p.z))*vec2(0.5, 0.7071);\n    float n = 1.- max(tun.x, tun.y) + (0.5-sf)*.5;\n    return n;\n*/\n \n}\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.0, h;\n    for(int i = 0; i < 96; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.002*(t*.125 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h*.8;\n        \n    }\n\n    return min(t, FAR);\n    \n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ. By the way, there is an \n// aesthetic difference between this and the regular six tap version. Sometimes, it's noticeable,\n// and other times, like this example, it's not.\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n/*\n// Standard normal function. 6 taps.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function, and in many cases, it gives really, really nice results. For a better version, and \n// usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 2.;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// From an intuitive sense, the function returns a weighted difference between a surface \n// value and some surrounding values. Almost common sense... almost. :)\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-1., 1.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 0.125/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\n/*\n// Oldschool hatching effect. Interesting under the right circumstances.\nvec3 ch(in vec3 col, in vec2 fragCoord){\n    \n    vec3 fColor = col;\n    \n    float lum = dot(col, vec3(.299, .587, .114));// length(col);\n\tfloat mx = 1./7.; // 1.732/7.;\n    \n    float rgt = fragCoord.x + fragCoord.y;\n    float lft = fragCoord.x - fragCoord.y;\n    \n    fColor = col*4.; col *= .6;\n    \n    if (lum < mx*6. && mod(rgt, 8.) == 0.) fColor = col;\n    if (lum < mx*5. && mod(lft, 8.) == 0.) fColor = col;\n    if (lum < mx*4. && mod(rgt, 4.) == 0.) fColor = col;\n    if (lum < mx*3. && mod(lft, 4.) == 0.) fColor = col;\n    if (lum < mx*2. && mod(rgt, 2.) == 0.) fColor = col;\n    if (lum < mx*1. && mod(lft, 2.) == 0.) fColor = col;\n    \n    return min(fColor, 1.);\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lookAt = vec3(0.0, 0.0, iTime*6.);  // \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 0.1, -0.5); // Camera position, doubling as the ray origin.\n \n    // Light positioning. One is a little behind the camera, and the other is further down the tunnel.\n \tvec3 light_pos = camPos + vec3(0.0, 0.125, 4.125);// Put it a bit in front of the camera.\n\tvec3 light_pos2 = camPos + vec3(0.0, 0.0, 8.0);// Put it a bit in front of the camera.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlight_pos.xy += path(light_pos.z);\n\tlight_pos2.xy += path(light_pos2.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Swiveling the camera from left to right when turning corners.\n    rd.xy = rot2( path(lookAt.z).x/32. )*rd.xy;\n\t\t\n    // Standard ray marching routine.\n    float t = trace(camPos, rd);\n\t\n    // The final scene color. Initated to black.\n\tvec3 sceneCol = vec3(0.);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n\t\n    \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = t * rd+camPos;\n\t    vec3 sn = calcNormal(sp);\n        \n        // Texture scale factor.\n        const float tSize0 = 1./1.; \n        const float tSize1 = 1./1.;\n    \t\n    \t// Texture-based bump mapping.\n\t    //if (sp.y<-(FH-0.005)) sn = doBumpMap(iChannel1, sp*tSize1, sn, 0.025); // Floor.\n\t    //else sn = doBumpMap(iChannel0, sp*tSize0, sn, 0.025); // Walls.\n        \n        sn = doBumpMap(iChannel1, sp*tSize0, sn, 0.02);\n        //sn = doBumpMap(sp, sn, 0.01);\n\t    \n\t    // Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);\n    \t\n    \t// Light direction vectors.\n\t    vec3 ld = light_pos-sp;\n\t    vec3 ld2 = light_pos2-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDdist = max(length(ld), 0.001);\n\t    float lDdist2 = max(length(ld2), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDdist;\n\t    ld2 /= lDdist2;\n\t    \n\t    // Light attenuation, based on the distances above. In case it isn't obvious, this\n        // is a cheap fudge to save a few extra lines. Normally, the individual light\n        // attenuations would be handled separately... No one will notice, or care. :)\n\t    float atten = 1./(1. + lDdist*.125 + lDdist*lDdist*.05);\n        float atten2 =  1./(1. + lDdist2*.125 + lDdist2*lDdist2*.05);\n    \t\n    \t// Ambient light.\n\t    float ambience = 0.75;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n\t    float diff2 = max( dot(sn, ld2), 0.0);\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 64.);\n\t    float spec2 = pow(max( dot( reflect(-ld2, sn), -rd ), 0.0 ), 64.);\n    \t\n    \t// Curvature.\n\t    float crv = clamp(curve(sp, 0.125)*0.5+0.5, .0, 1.);\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n \n        \n        vec3 texCol = tex3D(iChannel0, sp*tSize0, sn);\n        \n        //texCol = min(texCol*1.5, 1.);\n        //texCol = vec3(1)*dot(texCol, vec3(0.299, 0.587, 0.114));\n        //texCol = smoothstep(-.0, .6, texCol); // etc.\n        \n        //texCol = texCol*vec3(1., .5, .2); \n        int id = cellTileID(sp/2.5);\n        if(id == 4) texCol = texCol*vec3(1., .5, .3); \n        if(id == 3) texCol = texCol*.5 + texCol*vec3(.5, .25, .15); \n        \n    \t\n    \t// Darkening the crevices. Otherwise known as cheap, scientifically-incorrect shadowing.\t\n\t    float shading =  crv*0.75+0.25; \n    \t\n        //Dain: put some green in the cracks\n        vec3 crevColor = tex3D(iChannel2, sp*tSize0, sn);\n        texCol = mix(texCol, crevColor, pow(1.0 - crv, 16.0));\n       // ambience *= crv;\n    \t// Combining the above terms to produce the final color. It was based more on acheiving a\n        // certain aesthetic than science.\n        //\n        // Shiny.\n        sceneCol = (texCol*(diff + ambience + spec) + spec*vec3(.7, .9, 1))*atten;\n        sceneCol += (texCol*(diff2 + ambience + spec2) + spec2*vec3(.7, .9, 1))*atten2;\n        //\n        // Other combinations:\n        //\n        // Glow.\n        //float gr = dot(texCol, vec3(0.299, 0.587, 0.114));\n        //sceneCol = (gr*(diff + ambience*0.25) + spec*texCol*2. + fre*crv*texCol.zyx*2.)*atten;\n        //sceneCol += (gr*(diff2 + ambience*0.25) + spec2*texCol*2. + fre*crv*texCol.zyx*2.)*atten2;\n        \n        // Shading.\n        sceneCol *= shading*ao;\n        \n        //Dain: turned off the lines to show the smooth surface\n        // Drawing the lines on the surface.      \n       // sceneCol *= clamp(abs(curve(sp, 0.035)), .0, 1.)*.5 + 1.;  // Glow lines.\n       // sceneCol *= 1. - smoothstep(0., 4., abs(curve(sp, 0.0125)))*vec3(.82, .85, .88); // Darker.\n\t   \n\t\n\t}\n    \n    // Some simple post processing effects.\n    //float a = dot(sceneCol, vec3(0.299, 0.587, 0.114));\n    //sceneCol = min(vec3(a*3., pow(a, 2.5)*2., pow(a, 6.)), 1.); // Fire palette.\n    //sceneCol = floor(sceneCol*15.999)/15.; // Oldschool effect.  \n    // Oldschool hatching effect. Uncomment the \"ch\" function to use this one.\n    //sceneCol = ch(clamp(sceneCol, 0., 1.), fragCoord); \n\t\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n    \n\t\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdlcDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2706, 2721, 2743, 2743, 2787], [2789, 2833, 2853, 2853, 2962], [2964, 2988, 3007, 3007, 3081], [3083, 3149, 3199, 3199, 3421], [3424, 4117, 4148, 4148, 4235], [4237, 4237, 4265, 4335, 5132], [5133, 5197, 5222, 5241, 5328], [5329, 5642, 5668, 5787, 6629], [8950, 9612, 9638, 9638, 11047], [11050, 11150, 11172, 11172, 11229], [11231, 11491, 11509, 11509, 12532], [12535, 12556, 12592, 12592, 13027], [13029, 13216, 13278, 13278, 13788], [13791, 14035, 14062, 14171, 14331], [14564, 14922, 14965, 14965, 15310], [15312, 15684, 15719, 15719, 15923], [15925, 16686, 16742, 16769, 22606]]}
{"id": "MdlyDB", "name": "Multi Material", "author": "aym0", "description": "multi material study\ninspired by https://github.com/petershirley/raytracinginoneweekend", "tags": ["raytracing"], "likes": 0, "viewed": 127, "published": "Public", "date": "1489774135", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265358979323;\nvec2 vTexCoord;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat srand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453) * 2.0 - 1.0;\n}\n\nfloat rand(float seed){\n    vec2 co = vec2(seed, seed + 100.0);\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat srand(float seed){\n    vec2 co = vec2(seed, seed + 100.0);\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453) * 2.0 - 1.0;\n}\n\nvec3 getRandomVector(vec2 co){\n    \n    vec3 dir = vec3(srand(co + vec2(0.3, -0.3)), srand(co + vec2(-0.2, -0.1)), srand(co + vec2(-0.1, -0.4)));\n    float r = rand(co);\n\n    return r * normalize(dir);\n    \n}\n\nvec2 getRandomVector2(vec2 co) {\n    vec2 dir = vec2(srand(co + vec2(0.3, -0.3)), srand(co + vec2(-0.2, -0.1)));\n    float r = rand(co);\n    \n    return r * normalize(dir);\n}\n\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction looking at\n};\n\nstruct Sphere {\n    // geometry\n    float r; // radius\n    vec3 c;  // center\n    \n    // material\n    int mat; // 0: lambert, 1: metal\n    vec3 albedo; // for attenuation\n    float fuzz;  // for metal reflection\n    float ref_idx; // for dielectric refraction ratio\n};\n\nstruct Intersection {\n    bool hit;\n    vec3 p;\n    vec3 n;\n    vec3 color;\n    float t;\n    Sphere rec;\n};\n\nvoid scatterLambert(inout Ray R, in Intersection I){\n    R.o = I.p;\n    R.d = I.n + getRandomVector(vTexCoord + R.d.yx * 10.0);\n}\n\nvoid scatterMetal(inout Ray R, in Intersection I) {\n    R.o = I.p;\n    R.d = reflect(R.d, I.n) + I.rec.fuzz * getRandomVector(vTexCoord + R.d.yx * 10.0);;\n}\n\nfloat schlick(float cosine, float ref_idx) {\n    float r0 = (1.0 - ref_idx) / (1.0 + ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);\n}\n\nvoid scatterDielectric(inout Ray R, in Intersection I) {\n    vec3 outward;\n    vec3 reflected = reflect(R.d, I.n);\n    float ni;\n    float cosine;\n    float reflect_prob;\n    \n    if (dot(R.d, I.n) > 0.0) {\n        outward = - I.n;\n        ni = I.rec.ref_idx;\n        cosine = dot(R.d, I.n) / length(R.d);\n        cosine = sqrt(1.0 - I.rec.ref_idx * I.rec.ref_idx * (1.0 - cosine * cosine));\n    } else {\n        outward = I.n;\n        ni = 1.0 / I.rec.ref_idx;\n        cosine = - dot(R.d, I.n) / length(R.d);\n    }\n    \n    vec3 refracted = refract(R.d, outward, ni);\n    \n    if (length(refracted) > 0.0) {\n        reflect_prob = schlick(cosine, I.rec.ref_idx);\n    } else {\n        reflect_prob = 1.0;\n    }\n    \n    R.o = I.p;\n    if (rand(vTexCoord + R.d.yx * 10.0) < reflect_prob) {\n        R.d = reflected;\n    } else {\n        R.d = refracted;\n    }\n}\n\nvoid initSphere(inout Sphere s, in float r, in vec3 c) {\n    s.r = r;\n    s.c = c;\n}\n\nvoid setMaterial(inout Sphere s, in int m, in vec3 col, in float f, in float ref) {\n    s.mat = m;\n    s.albedo = col;\n    s.fuzz = f;\n    s.ref_idx = ref;\n}\n\nvoid calcColor(inout Ray R, inout Intersection I) {\n    \n    I.color *= I.rec.albedo;\n    \n    if (I.rec.mat == 0) {\n        scatterLambert(R, I);\n    } else if (I.rec.mat == 1) {\n        scatterMetal(R, I);\n    } else if (I.rec.mat == 2) {\n        scatterDielectric(R, I);\n    }\n    \n}\n\nvoid intersectSphere(inout Ray R, in Sphere S, inout Intersection I){\n    \n    vec3 L = R.o - S.c;\n    \n    float a = dot(R.d, R.d);\n    float b = dot(L, R.d);\n    float c = dot(L, L) - S.r * S.r;\n    \n    float discriminant = b * b - a * c;\n    \n    if (discriminant > 0.0) {\n        float t = (- b - sqrt(discriminant))/a;\n        if (t > 0.001 && t < I.t) {\n            \n            I.p = R.o + t * R.d;\n            I.n = normalize(I.p - S.c);\n            \n            I.t = t;\n            I.hit = true;\n            I.rec = S;\n            \n            return;\n        }\n        t = (- b + sqrt(discriminant))/a;\n        if (t > 0.001 && t < I.t) {\n            \n            I.p = R.o + t * R.d;\n            I.n = normalize(I.p - S.c);\n            \n            I.t = t;\n            I.hit = true;\n            I.rec = S;\n            \n            return;\n        }\n    }\n}\n\nstruct Camera {\n    vec3 pos;\n    vec3 lookAt;\n    vec3 vUp;\n    float fov;\n    float aspect;\n    float aparture;\n    float focus_dist;\n    \n    vec3 lower_left_corner;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 u, v, w;\n    float lens_radius;\n};\n\nvoid initCamera(inout Camera C){\n    C.lens_radius = C.aparture * 0.5;\n    float theta = C.fov * PI / 180.0;\n    float half_height = tan(theta * 0.5);\n    float half_width = C.aspect * half_height;\n    \n    C.w = normalize(C.pos - C.lookAt);\n    C.u = normalize(cross(C.vUp, C.w));\n    C.v = cross(C.w, C.u);\n    \n    C.lower_left_corner = C.pos - half_width * C.focus_dist * C.u - half_height * C.focus_dist * C.v - C.focus_dist * C.w;\n    C.horizontal = 2.0 * half_width * C.focus_dist * C.u;\n    C.vertical = 2.0 * half_height * C.focus_dist * C.v;\n    \n}\n\nvoid createRay(inout Ray R, in Camera C, in float s, in float t) {\n    vec2 rd = C.lens_radius * getRandomVector2(vTexCoord * vec2(s, t));\n    vec3 offset = C.u * rd.x + C.v * rd.y;\n    \n    R.o = C.pos + offset;\n    R.d = C.lower_left_corner + s * C.horizontal + t * C.vertical - R.o;\n    \n}\n\nSphere earth;\nSphere slist[8];\n\nbool hitCheck(inout Ray R, inout Intersection I) {\n    I.hit = false;\n    I.p = vec3(0.0);\n    I.n = vec3(0.0);\n    I.t = 1.0e+30;\n    \n    intersectSphere(R, earth, I);\n    \n    for (int i = 0; i < 8; i++) {\n        intersectSphere(R, slist[i], I);\n    }\n    \n    return I.hit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tvTexCoord = fragCoord.xy;\n    \n    initSphere(earth, 100.0, vec3(0.0, - 102.0, 0.0));\n    setMaterial(earth, 1, vec3(0.6, 0.6, 0.6), 0.1, 0.0);\n    \n    float st = 2.0 * PI / 8.0;\n    float t = iTime;\n    \n    for (int i = 0; i < 8; i++) {\n        \n        \n        if (mod(float(i), 4.0) == 1.0) {\n            \n            initSphere(slist[i],\n                       0.4,\n                       vec3(cos(t) * sin(3.0 * t + st * float(i)),\n                            sin(t) * cos(4.0 * t + st * float(i)),\n                            cos(t + st *float(i))) * 2.0\n                       );\n            \n            setMaterial(slist[i], 0, vec3(0.2, 0.9, 1.0), 0.0, 0.0);\n            \n        } else if (mod(float(i), 4.0) == 3.0) {\n            \n            initSphere(slist[i],\n                       0.4,\n                       vec3(cos(t) * sin(3.0 * t + st * float(i)),\n                            sin(t) * cos(4.0 * t + st * float(i)),\n                            cos(t + st * float(i))) * 2.0\n                       );\n            \n            setMaterial(slist[i], 0, vec3(1.0, 0.3, 0.3), 0.0, 0.0);\n            \n        } else {\n            \n            initSphere(slist[i],\n                       0.2 * (sin(t) + 1.0) + 0.3,\n                       vec3(cos(t) * sin(4.0 * t + st * float(i)),\n                            sin(t) * cos(4.0 * t + st *float(i)),\n                            cos(t + st * float(i))) * 2.0\n                       );\n            \n            setMaterial(slist[i], 2, vec3(1.0), 0.0, 1.5);\n            \n            \n        }\n        \n        \n    }\n    \n    float size = 2.0 / min(iResolution.x, iResolution.y);\n    \n    float r = 4.0 + 3.5 * sin(t * 0.8);\n    \n    Camera cam;\n    cam.pos = vec3(r * sin(t), 0.5 * cos(t * 0.5) + 0.5, r * cos(t));\n    cam.lookAt = vec3(0.0, 0.0, 0.0);\n    cam.vUp = vec3(0.0, 1.0, 0.0);\n    cam.fov = 60.0;\n    cam.aspect = 4.0/3.0;\n    cam.focus_dist = 4.0;\n    cam.aparture = 0.05;\n    \n    initCamera(cam);\n    \n    Ray ray;\n    Intersection inter;\n    \n    vec3 destColor = vec3(0.0);\n    \n    float rs = 1.1;\n    \n    for (int i = 0; i < 5; i++) {\n        inter.color = vec3(1.0);\n        \n        createRay(ray, cam, p.x + size * srand(rs*t + 0.5), p.y + size * srand(rs*t));\n        \n        rs *= 1.2;\n        \n        if (hitCheck(ray, inter)) {\n            \n            int counter = 0;\n            \n            for (int i = 0; i < 10; i++) {\n                if (hitCheck(ray, inter)) {\n                    calcColor(ray, inter);\n                } else {\n                \tbreak;\n                }\n            }\n            \n        }\n    \n        destColor += inter.color;\n        \n    }\n    \n    destColor /= 5.0;\n    \n    fragColor = vec4(sqrt(destColor.r), sqrt(destColor.g), sqrt(destColor.b), 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdlyDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 75, 75, 147], [149, 149, 170, 170, 254], [256, 256, 279, 279, 391], [393, 393, 417, 417, 541], [543, 543, 573, 573, 751], [753, 753, 785, 785, 927], [1384, 1384, 1436, 1436, 1513], [1515, 1515, 1566, 1566, 1671], [1673, 1673, 1717, 1717, 1840], [1842, 1842, 1898, 1898, 2701], [2703, 2703, 2759, 2759, 2787], [2789, 2789, 2872, 2872, 2946], [2948, 2948, 2999, 2999, 3234], [3236, 3236, 3305, 3305, 4106], [4362, 4362, 4394, 4394, 4920], [4922, 4922, 4988, 4988, 5214], [5248, 5248, 5298, 5298, 5528], [5530, 5530, 5586, 5586, 8412]]}
{"id": "MdlyDs", "name": "Volumetric Stanford Bunny", "author": "SebH", "description": "Volumetric 32x32x32 Stanford Bunny with volumetric lighting, shadow and noise.\nThe shader does not compile on some platform for some reason. Set \"VOLUME_FILTERING_NEAREST 1\" can fix that issue (Thanks Fabrice for the investigation).", "tags": ["voxel", "volumetricscattering", "stanfordbunny"], "likes": 123, "viewed": 8240, "published": "Public API", "date": "1490479496", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// By SebH \n// https://twitter.com/SebHillaire\n// Use mouse left to rotate camera (X axis) and change noise strength (Y axis)\n//\n// Warning: \n// Does not compile on all platforms/driver due to the packedBunny array which is\n// a ugly hacky way to get volume asset texture in shader toy. \n// A right way to do that would be to have loadable textures from weblinks.\n// Set \"VOLUME_FILTERING_NEAREST 1\" can fix that issue.\n//\n\n\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n#define uint2 uvec2\n#define uint3 uvec3\n#define uint4 uvec4\n\n////////// Parameters\n\n// Participating media properties. have fun tweaking those :)\nfloat3 scattering = 25.0*float3(0.25,0.5,1.0);\nfloat3 absorption = 0.0 * float3(0.75,0.5,0.0);\n\n// Default noise erosion strength\nfloat erosionStrength = 1.0;\n\n////////// Options\n\n#define VOLUME_FILTERING_NEAREST 0\n\n#define FBM_NOISE 1\n\n#define BASIC_ANIMATED_NOISE 1\n\n//0, 1 or 2\n#define BASIC_ANIMATED_MEDIA 0\n\n\n\n//////////////////////////////////////////////////\n// Bunny volume data\n//////////////////////////////////////////////////\n\n// Packed 32^3 bunny data as 32x32 uint where each bit represents density per voxel\n#define BUNNY_VOLUME_SIZE 32\nconst uint packedBunny[1024] = uint[1024](0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,917504u,917504u,917504u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1966080u,12531712u,16742400u,16742400u,16723968u,16711680u,8323072u,4128768u,2031616u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,6144u,2063360u,16776704u,33553920u,33553920u,33553920u,33553920u,33520640u,16711680u,8323072u,8323072u,2031616u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,268435456u,402653184u,134217728u,201326592u,67108864u,0u,0u,7168u,2031104u,16776960u,33554176u,33554176u,33554304u,33554176u,33554176u,33554176u,33553920u,16744448u,8323072u,4128768u,1572864u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,805306368u,939524096u,402653184u,478150656u,260046848u,260046848u,260046848u,125832192u,130055680u,67108608u,33554304u,33554304u,33554304u,33554304u,33554304u,33554304u,33554304u,33554176u,16776704u,8355840u,4128768u,917504u,0u,0u,0u,0u,0u,0u,0u,0u,0u,805306368u,1056964608u,1056964608u,528482304u,528482304u,260046848u,260046848u,260046848u,130039296u,130154240u,67108739u,67108807u,33554375u,33554375u,33554370u,33554368u,33554368u,33554304u,33554304u,16776960u,8330240u,4128768u,393216u,0u,0u,0u,0u,0u,0u,0u,0u,939524096u,1040187392u,1040187392u,520093696u,251658240u,251658240u,260046848u,125829120u,125829120u,130088704u,63045504u,33554375u,33554375u,33554375u,33554407u,33554407u,33554370u,33554370u,33554374u,33554310u,16776966u,4144642u,917504u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,15360u,130816u,262017u,4194247u,33554383u,67108847u,33554415u,33554407u,33554407u,33554375u,33554375u,33554318u,2031502u,32262u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,31744u,130816u,262019u,2097151u,134217727u,134217727u,67108863u,33554415u,33554407u,33554415u,33554383u,2097102u,982926u,32262u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,31744u,130816u,524263u,117964799u,127926271u,134217727u,67108863u,16777215u,4194303u,4194303u,2097151u,1048574u,65422u,16134u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3u,31751u,130951u,524287u,252182527u,261095423u,261095423u,59768830u,2097150u,1048574u,1048575u,262143u,131070u,65534u,16134u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,7u,31751u,130959u,503840767u,520617982u,529530879u,261095423u,1048575u,1048574u,1048574u,524286u,524287u,131070u,65534u,16134u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3u,1799u,32527u,134348750u,1040449534u,1057488894u,520617982u,51380223u,1048575u,1048575u,524287u,524287u,524287u,131070u,65534u,15886u,6u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1536u,3968u,8175u,65535u,1006764030u,1040449534u,1057488894u,50855934u,524286u,524286u,524287u,524287u,524286u,262142u,131070u,65534u,32270u,14u,6u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3968u,8160u,8191u,805371903u,2080505854u,2114191358u,101187582u,34078718u,524286u,524286u,524286u,524286u,524286u,524286u,262142u,131070u,32766u,8078u,3590u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8128u,8176u,16383u,2013331455u,2080505854u,235143166u,101187582u,524286u,1048574u,1048574u,1048574u,1048574u,524286u,524286u,262142u,131070u,32766u,16382u,8070u,1024u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8160u,8184u,1879064574u,2013331455u,470024190u,67371006u,524286u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,524286u,262142u,65534u,16382u,8160u,1024u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8128u,8184u,805322750u,402718719u,134479870u,524286u,524286u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,65534u,16382u,16368u,1792u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3968u,8184u,16382u,131071u,262142u,524286u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,65534u,16382u,16368u,1792u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1792u,8184u,16380u,65535u,262143u,524286u,524286u,1048574u,1048574u,1048575u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,65534u,16376u,16368u,1792u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8176u,16376u,32767u,262143u,524286u,1048574u,1048574u,1048575u,1048575u,1048575u,1048575u,1048574u,1048574u,524286u,262142u,32766u,16376u,8176u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4032u,8184u,32766u,262142u,524286u,524286u,1048575u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,32766u,16376u,8176u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,384u,8184u,32766u,131070u,262142u,524286u,1048575u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,524286u,131070u,32766u,16368u,1920u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4080u,32764u,65534u,262142u,524286u,524286u,524286u,1048574u,1048574u,524286u,524286u,524286u,262142u,131070u,32764u,8160u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,256u,16376u,32760u,131068u,262140u,262142u,524286u,524286u,524286u,524286u,524286u,262142u,131070u,65532u,16368u,3840u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3968u,32752u,65528u,131068u,262142u,262142u,262142u,262142u,262142u,262142u,262140u,131064u,32752u,7936u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8064u,32736u,65528u,131070u,131070u,131070u,131070u,131070u,131070u,65532u,32752u,8160u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3456u,16376u,32764u,65534u,65534u,65534u,32766u,32764u,16380u,4048u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,48u,2680u,8188u,8188u,8188u,8188u,4092u,120u,16u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,120u,248u,508u,508u,508u,248u,240u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,96u,240u,504u,504u,504u,240u,96u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,224u,224u,224u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u);\n\n\nfloat sampleBunny(float3 uvs)\n{\n    float3 voxelUvs = max(float3(0.0),min(uvs*float3(BUNNY_VOLUME_SIZE), float3(BUNNY_VOLUME_SIZE)-1.0));\n    uint3 intCoord = uint3(voxelUvs);\n    uint arrayCoord = intCoord.x + intCoord.z*uint(BUNNY_VOLUME_SIZE);\n\t\n    // Very simple clamp to edge. It would be better to do it for each texture sample\n    // before the filtering but that would be more expenssive...\n    // Also adding small offset to catch cube intersection floating point error\n    if(uvs.x<-0.001 || uvs.y<-0.001 || uvs.z<-0.001 ||\n      uvs.x>1.001 || uvs.y>1.001 || uvs.z>1.001)\n    \treturn 0.0;\n   \n    // 1 to use nearest instead\n#if VOLUME_FILTERING_NEAREST\n    // sample the uint representing a packed volume data of 32 voxel (1 or 0)\n    uint bunnyDepthData = packedBunny[arrayCoord];\n    float voxel = (bunnyDepthData & (1u<<intCoord.y)) > 0u ? 1.0 : 0.0;\n#else\n    uint3 intCoord2 = min(intCoord+uint3(1), uint3(BUNNY_VOLUME_SIZE-1));\n    \n    uint arrayCoord00 = intCoord.x  + intCoord.z *uint(BUNNY_VOLUME_SIZE);\n    uint arrayCoord01 = intCoord.x  + intCoord2.z*uint(BUNNY_VOLUME_SIZE);\n    uint arrayCoord10 = intCoord2.x + intCoord.z *uint(BUNNY_VOLUME_SIZE);\n    uint arrayCoord11 = intCoord2.x + intCoord2.z*uint(BUNNY_VOLUME_SIZE);\n    \n    uint bunnyDepthData00 = packedBunny[arrayCoord00];\n    uint bunnyDepthData01 = packedBunny[arrayCoord01];\n    uint bunnyDepthData10 = packedBunny[arrayCoord10];\n    uint bunnyDepthData11 = packedBunny[arrayCoord11];\n        \n    float voxel000 = (bunnyDepthData00 & (1u<<intCoord.y)) > 0u ? 1.0 : 0.0;\n    float voxel001 = (bunnyDepthData01 & (1u<<intCoord.y)) > 0u ? 1.0 : 0.0;\n    float voxel010 = (bunnyDepthData10 & (1u<<intCoord.y)) > 0u ? 1.0 : 0.0;\n    float voxel011 = (bunnyDepthData11 & (1u<<intCoord.y)) > 0u ? 1.0 : 0.0;\n    float voxel100 = (bunnyDepthData00 & (1u<<intCoord2.y)) > 0u ? 1.0 : 0.0;\n    float voxel101 = (bunnyDepthData01 & (1u<<intCoord2.y)) > 0u ? 1.0 : 0.0;\n    float voxel110 = (bunnyDepthData10 & (1u<<intCoord2.y)) > 0u ? 1.0 : 0.0;\n    float voxel111 = (bunnyDepthData11 & (1u<<intCoord2.y)) > 0u ? 1.0 : 0.0;\n    \n    float3 d = voxelUvs - float3(intCoord);\n    \n    voxel000 = mix(voxel000,voxel100, d.y);\n    voxel001 = mix(voxel001,voxel101, d.y);\n    voxel010 = mix(voxel010,voxel110, d.y);\n    voxel011 = mix(voxel011,voxel111, d.y);\n    \n    voxel000 = mix(voxel000,voxel010, d.x);\n    voxel001 = mix(voxel001,voxel011, d.x);\n    \n    float voxel = mix(voxel000,voxel001, d.z);\n#endif\n    \n    return voxel;\n}\n\n//////////////////////////////////////////////////\n// Volume noise from somewhere...\n//////////////////////////////////////////////////\n\nfloat rand(vec3 co)\n{\n    return -1.0 + fract(sin(dot(co.xy,vec2(12.9898 + co.z,78.233))) * 43758.5453) * 2.0;\n}\n\nfloat linearRand(vec3 uv)\n{\n\tvec3 iuv = floor(uv);\n\tvec3 fuv = fract(uv);\n\t\n\tfloat v1 = rand(iuv + vec3(0,0,0));\n\tfloat v2 = rand(iuv + vec3(1,0,0));\n\tfloat v3 = rand(iuv + vec3(0,1,0));\n\tfloat v4 = rand(iuv + vec3(1,1,0));\n\t\n\tfloat d1 = rand(iuv + vec3(0,0,1));\n\tfloat d2 = rand(iuv + vec3(1,0,1));\n\tfloat d3 = rand(iuv + vec3(0,1,1));\n\tfloat d4 = rand(iuv + vec3(1,1,1));\n\t\n\treturn mix(mix(mix(v1,v2,fuv.x),mix(v3,v4,fuv.x),fuv.y),\n\t\t       mix(mix(d1,d2,fuv.x),mix(d3,d4,fuv.x),fuv.y),\n\t\t\t   fuv.z);\n}\n\nfloat linearRandFBM(vec3 uv)\n{\n\tfloat c = (linearRand(uv * 1.0) * 32.0 +\n\t\t\t   linearRand(uv * 2.0) * 16.0 + \n\t\t\t   linearRand(uv * 4.0) * 8.0 + \n\t\t\t   linearRand(uv * 8.0) * 4.0) / 32.0;\n\treturn c * 0.5 + 0.5;\n}\n\n\n//////////////////////////////////////////////////\n// Cube intersection\n//////////////////////////////////////////////////\n\nfloat3 worldPosTocubePos(float3 worldPos)\n{\n    // cube of world space size 4 with bottom face on the ground y=0\n    return worldPos*0.15 + float3(0.0,-0.5,0.0);\n}\n\n// From https://www.shadertoy.com/view/4s23DR\nbool cube(vec3 org, vec3 dir, out float near, out float far)\n{\n\t// compute intersection of ray with all six bbox planes\n\tvec3 invR = 1.0/dir;\n\tvec3 tbot = invR * (-0.5 - org);\n\tvec3 ttop = invR * (0.5 - org);\n\t\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max(tmin.xx, tmin.yz);\n\tnear = max(t0.x, t0.y);\n\tt0 = min(tmax.xx, tmax.yz);\n\tfar = min(t0.x, t0.y);\n\n\t// check for hit\n\treturn near < far && far > 0.0;\n}\n\n\n//////////////////////////////////////////////////\n// Main\n//////////////////////////////////////////////////\n\nfloat3 L = 4.0 * float3(1.0,1.0,1.0);// incoming luminance from light (ignoring its shape, etc.)\nfloat3 Lpos = float3(1.0,1.0,1.0);\t// in volumetric cube space\n\n#define extinction  (absorption + scattering)\n\n// all volumetric computation are done once position has been transform into unit cube space\n\n// Get density for a position\nfloat getDensity(float3 cubePos)\n{\n    float density = sampleBunny(cubePos);\n    if(density==0.0) return 0.0;\t// makes things a tad bit faster\n#if FBM_NOISE\n    float3 noiseUV = cubePos*12.0;\n\t#if BASIC_ANIMATED_NOISE\n    noiseUV += iTime * float3(1.0,0.0,0.0);\n\t#endif\n    density = density * max(0.0, 1.25*erosionStrength*linearRandFBM(noiseUV)*4.0-2.0); // more complex FBM noise\n#else\n    float3 noiseUV = cubePos*16.0;\n\t#if BASIC_ANIMATED_NOISE\n    noiseUV += iTime * float3(1.0,0.0,0.0);\n\t#endif\n    density = density * max(0.0, 0.5 + 0.5*erosionStrength*linearRand(noiseUV));\n#endif\n    return density;\n}\n\n// Get transmittance from a direction and distance onto a point (volume shadows)\nfloat3 getShadowTransmittance(float3 cubePos, float sampledDistance, float stepSizeShadow)\n{\n    float3 shadow = float3(1.0);\n    float3 Ldir = normalize(Lpos-cubePos);\n    for(float tshadow=0.0; tshadow<sampledDistance; tshadow+=stepSizeShadow)\n    {\n        float3 cubeShadowPos = cubePos + tshadow*Ldir;\n        float densityShadow = getDensity(cubeShadowPos);\n        shadow *= exp(-densityShadow * extinction * stepSizeShadow);\n    }\n    return shadow;\n}\n\n// Returns the light distance attenuation\nfloat distanceAttenuation(float distance)\n{\n    float lightMaxRadius = 3.0;\n    float linAtt = clamp((lightMaxRadius-distance)/lightMaxRadius,0.0,1.0);\n    linAtt*=linAtt;\t// some \"fake artistic\" attenuation\n    return linAtt/(distance*distance);\n}\n\nvoid mainImage( out float4 fragColor, in float2 fragCoord )\n{    \n\tfloat2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = float4(uv,0.5+0.5*sin(iTime),1.0);\n    float time = iTime;\n    \n\tvec2 mouseControl = iMouse.xy / iResolution.xy;\n    erosionStrength = iMouse.z>0.0 ? mouseControl.y * 4.0 : erosionStrength;\n    \n#if BASIC_ANIMATED_MEDIA==1\n    float r = floor(time);\n    scattering = abs(25.0* float3(rand(float3(r,0.0,1.0)),rand(float3(r,0.0,5.0)),rand(float3(r,0.0,9.0))));\n    absorption = abs(5.0* float3(rand(float3(r,1.0,2.0)),rand(float3(r,1.0,7.0)),rand(float3(r,1.0,7.0))));\n#elif BASIC_ANIMATED_MEDIA==2\n    float r = time*0.2;\n    scattering = abs(25.0* float3(sin(r*1.1),sin(r*3.3),sin(r*5.5)));\n    absorption = abs( 5.0* float3(sin(r*2.2),sin(r*4.4),sin(r*6.6)));\n\n#endif\n    \n    // View diretion in camera space\n    float3 viewDir = normalize(float3((fragCoord.xy - iResolution.xy*0.5) / iResolution.y, 1.0));\n    viewDir*= float3(0.9,1.0,1.0);\n    \n    Lpos = float3(0.85*cos(time*0.55),1.5, 0.85*sin(time*1.0));\n    \n    // Compute camera properties\n    float  camDist = 10.0;\n    float3 camUp = float3(0,1,0);\n    float3 camPos = float3(camDist*cos(time*0.51),8.0, camDist*sin(time*0.51));\n    camPos = iMouse.z<=0.0 ? camPos : float3(camDist*cos(mouseControl.x*10.0),8.0, camDist*sin(mouseControl.x*10.0));\n    float3 camTarget = float3(0,3.0,0);\n    \n    // And from them evaluted ray direction in world space\n    float3 forward = normalize(camTarget - camPos);\n    float3 left = normalize(cross(forward, camUp));\n    float3 up = cross(left, forward);\n    float3 worldDir = viewDir.x*left + viewDir.y*up + viewDir.z*forward;\n    \n    //////////////////////////////////////////////////////////////////////////////////////////\n    //// Render the flat ground with lighting and volumetric shadows\n    float3 color= float3(0.0, 0.0, 0.0);\n    float3 groundIntersection = camPos + worldDir * abs(camPos.y/worldDir.y);\n    float2 groundUv = groundIntersection.xz*0.1;\n    float3 groundTex = texture(iChannel0, groundUv).xyz;\n    if(worldDir.y<0.0)\n    {\n        // ground position to cube space for lighting evaluation\n    \tfloat3 cubeSpacePos= worldPosTocubePos(groundIntersection)+0.5;\n        \n        float3 shadow = getShadowTransmittance(cubeSpacePos,2.0,0.05);\n\n       \tfloat3 Ldir = Lpos-cubeSpacePos;\n        float Ldist = length(Ldir);\n    \tfloat3 LdirNorm = Ldir / max(0.0001, Ldist);\n        float Lattenuation = distanceAttenuation(Ldist);\n        \n        float N00 = texture(iChannel0, groundUv + float2( 0.001, 0.001)).g;\n        float N01 = texture(iChannel0, groundUv + float2( 0.001,-0.001)).g;\n        float N10 = texture(iChannel0, groundUv + float2(-0.001, 0.001)).g;\n        float N11 = texture(iChannel0, groundUv + float2(-0.001,-0.001)).g;\n        float3 N = cross(normalize(float3(1.0,25.0*(N11-N00),1.0)),normalize(float3(1.0,25.0*(N10-N01),-1.0)));\n        \n        color = groundTex * shadow * Lattenuation * L * dot(N,LdirNorm);\n    }\n    \n    //////////////////////////////////////////////////////////////////////////////////////////\n    //// Compute intersection with cube containing the bunny\n    float near = 0.0;\n    float far  = 0.0;\n    float3 cubeSpacePos= worldPosTocubePos(camPos);\n\tif (cube(cubeSpacePos, worldDir, near, far))\n    {\n    \tfloat3 scatteredLuminance = float3(0.0,0.0,0.0);\n        float3 transmittance = float3(1.0);\n        \n        float stepSize = 0.01;\n        for(float t=near; t<far; t+=stepSize)\n        {\n            float3 cubePos = cubeSpacePos + t*worldDir + 0.5;\n            float density = getDensity(cubePos);\n            \n       \t\tfloat stepSizeShadow = 0.1;\n            float3 shadow = getShadowTransmittance(cubePos,1.0, 0.1);\n            \n            \n    \t\tfloat Ldist = length(Lpos-cubePos);\n            float Lattenuation = distanceAttenuation(Ldist);\n\n#if 0\n            // Scattered luminance ignores phase function (assumes L has it baked in)\n            // This is not energy conservative.\n            scatteredLuminance += Lattenuation * shadow * transmittance * density *scattering * stepSize * L;       \n            transmittance *= exp(-density * extinction * stepSize);\n#else\n            // Improved scattering integration. See slide 28 at http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/\n            vec3 S = L * Lattenuation * shadow * density *scattering;\n            vec3 sampleExtinction = max(vec3(0.0000000001), density * extinction);\n            vec3 Sint = (S - S * exp(-sampleExtinction * stepSize)) / sampleExtinction;\n            scatteredLuminance += transmittance * Sint;\n\n            // Evaluate transmittance to view independentely\n            transmittance *= exp(-sampleExtinction * stepSize);\n#endif\n        }\n        \n        // Apply volumetric on scene\n        color = transmittance*color + scatteredLuminance;\n    }\n    \n    \n    \n    fragColor = float4(pow(color, float3(1.0/2.2)),1.0); // simple linera to gamma\n    \n    \n}\n\n\n", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdlyDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1070, 6910, 6941, 6941, 9422], [9424, 9561, 9582, 9582, 9673], [9675, 9675, 9702, 9702, 10179], [10181, 10181, 10211, 10211, 10393], [10396, 10520, 10563, 10632, 10683], [10685, 10731, 10793, 10850, 11288], [11704, 11734, 11768, 11768, 12345], [12347, 12428, 12520, 12520, 12887], [12889, 12931, 12974, 12974, 13179], [13181, 13181, 13242, 13242, 18179]]}
{"id": "MdlyR2", "name": "Trip in Tron 2", "author": "ocb", "description": "A try with  reflection, transparency and  glow", "tags": ["raytracing", "transparent", "glow", "reflect"], "likes": 17, "viewed": 1349, "published": "Public API", "date": "1489006673", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: ocb\n// Title: Trip in Tron 2\n// testing reflection, transparency and glow\n\n\n#define PI 3.141592653589793\n\n\n// Global\n// object def\n// sphere A and B\nvec3 sphAO;\nfloat sphAR;\nvec3 sphBO;\nfloat sphBR;\nfloat ground;\n\n\nfloat random (in vec2 _st) { \t\t\t\t\t\t\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))* \n        43758.5453123+iTime*.1);\n}\n\nvec2 truchetPattern(in vec2 st, in float index){\n    \n    if (index > 0.75) {\n        st = vec2(1.) - st;\n    } else if (index > 0.5) {\n        st = vec2(1.0-st.x,st.y);\n    } else if (index > 0.25) {\n        st = 1.0-vec2(1.0-st.x,st.y);\n    }\n    return st;\n}\n\nbool groundImpact(inout vec3 pos,in float gndSurface, in vec3 N_ray, out vec3 N_normGnd){\n    bool impact = false;\n    \n    float t = ((gndSurface-pos.y)/N_ray.y);\n    if (t > 0.){\n        impact = true;\n\t\tpos = pos + t*N_ray;\n        N_normGnd = vec3(0., 1., 0.);\n    }\n    return impact;\n}\n\n\nfloat sphereImpact(inout vec3 pos, in vec3 sphO, in float sphR, in vec3 ray, out vec3 normSph){\n    \n    float t_dmin = 0.;\n    float taux = 0.;\n    vec3 delta = pos - sphO;\n\n    // Sphere interception\n    // pre-calculation\n    float b = dot(delta, ray);\n    float d = b*b - (dot(delta,delta) - sphR*sphR);\n    if (d >= 0.){\n        float Vd = sqrt(d);\n        float t = min( -b + Vd, -b - Vd ) ;\n        if (t > 0.){\n            t_dmin =  - b;\n    \t\tvec3 pos_dmin = pos + ray*t_dmin;\n   \t\t\ttaux = min(1./( (length(pos_dmin - sphO)/sphR) +.8)-0.8, 1.) + .5*pow(length(pos_dmin - sphO)/sphR,4.);\n            pos = pos + ray*t;\n            normSph = normalize(pos - sphO);\n        }\n    }\n    return taux;\t// return color index for the glow (center and surface)\n}\n\nvec3 groundColor(in vec3 pos){\n    vec3 col= vec3(0.);\n    \n    \tvec2 ipos = floor(vec2(pos.x,pos.z)*.1);  // integer\n    \tvec2 fpos = fract(vec2(pos.x,pos.z)*.1);  // fraction\n\t\tvec2 tile = truchetPattern(fpos, random( ipos ));\t\t// generate Maze\n        vec2 tileXL = truchetPattern(fract(vec2(pos.x,pos.z)*.1), random( floor(vec2(pos.x,pos.z)*.1) ));\t\t// used for impact effect\n        \n        // Maze\n    \tcol.b += .4*(smoothstep(tile.x-0.05,tile.x,tile.y)-smoothstep(tile.x,tile.x+0.05,tile.y));\n        col.b += .5*(1.-smoothstep(.0,.1,length(tile-fract(iTime*.4))));\t// Head on top of Truchet pattern\n    \t\n        col.rb += .5*(1.-smoothstep(0.,5.*sphAR,length(pos.xz-sphAO.xz)))*(smoothstep(tile.x-0.05,tile.x,tile.y)-\n              \t\t   smoothstep(tile.x,tile.x+0.05,tile.y));\t\t// grid lag below sphere A\n        col.gb += .5*(1.-smoothstep(0.,5.*sphBR,length(pos.xz-sphBO.xz)))*(smoothstep(tile.x-0.05,tile.x,tile.y)-\n              \t\t   smoothstep(tile.x,tile.x+0.05,tile.y));\t\t// grid lag below sphere B\n     \t\n        \n        col += (1.-smoothstep(0.,.02,abs(pos.x)));\t\t\t\t// thin white line (main line)\n        col.rgb += .3*max(0.,1.-atan(abs(pos.x))*2./PI-.1);\t\t// White line glow\n        col.r += (1.-smoothstep(0.,.02,abs(pos.z)));\t\t\t    // thin red line (crossing signal)\n        \n        col.r += max(0.,(1.-smoothstep(0., .6, fract(iTime*.1+pos.x*0.00025)))*((1.-smoothstep(0.,.02,abs(pos.z))) + max(0.,1.-atan(abs(pos.z))*2./PI-.1)));\t//crossing pulse\n        col.b += max(0.,(1.-smoothstep(0., .4, fract(iTime*3.+pos.z*0.01)))*((1.-smoothstep(0.,.02,abs(pos.x))) + max(0.,1.-atan(abs(pos.x))*2./PI-.1)));\t//rapid pulse\n                \n       col.r += 1.*min(.9, smoothstep(0.,1.,(1.-fract(iTime*.1))\n                *( smoothstep(tile.x-0.05,tile.x,tile.y) - smoothstep(tile.x,tile.x+0.05,tile.y)+1.*(1.-smoothstep(.0,.1,length(tileXL-fract(iTime*2.)))) )\n                *(1.-smoothstep(0.,300000.*fract(iTime*.1), pos.x*pos.x+ pos.z*pos.z))*smoothstep(0.,100000.*(fract(iTime*.1)), pos.x*pos.x+ pos.z*pos.z)  ));  //impact\n                                                                      \n       col *= min(.8,10./length(.01*pos))+.2; \t// distance fog\n\n    return col;\n}\n\nvec3 skyColor(in vec3 ray){\n    vec3 col = vec3(0.);\n    col += vec3( max((ray.x+1.)/2.*(-4.*ray.y+1.)/2.,0.),.1*(1.-ray.y),.2*(1.-ray.y) );\n    return col;\n}\n\n\nint ojectReflect(inout vec3 pos, inout vec3 N_ray, inout vec3 color){\n    vec3 posA = pos, posB= pos, N_normPosA = vec3(0.), N_normPosB = vec3(0.);\n    float tauxA, tauxB;\n    bool A_ok = false;\n    bool B_ok = false;\n    \n    tauxA = 1.3*sphereImpact(posA, sphAO, sphAR, N_ray,N_normPosA);\n    tauxB = 1.3*sphereImpact(posB, sphBO, sphBR, N_ray,N_normPosB);\n    \n    A_ok = bool (tauxA);\n    B_ok = bool (tauxB);\n    \n    if (A_ok) {\n        if (B_ok){\n            if (length(posA-pos) < length(posB-pos)){\t\t// A and B are one behind the other\n                \t\t\t\t\t\t\t\t\t\t\t// at the end, both color are mixed\n                color += vec3(0.,tauxB,tauxB);\t\t\t\t// but first, we must get the reflection on the sphere behind.\n                vec3 Sray = reflect(N_ray,N_normPosB);\t\t\t\t\t\t// recursivity would be good\n                if (groundImpact(posB, ground, Sray, N_normPosB) ){\t\t\t// but not allowed by my shader\n       \t\t\t\tcolor += groundColor(posB);\t\t\t\t\t\t\t\t// so here we get the ground or sky reflexion\n    \t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// on the sphere behind\n    \t\t\telse {\t\t\t\t\t\t\t\t\t\t\t\t\t\t// color is added at the sphere basic color tauxB\n        \t\tcolor += skyColor(Sray);\n   \t\t\t\t}\n                color = mix(vec3(tauxA,0.,tauxA),color,.7);\t\t// finally A and B are mixed\n        \t\tpos = posA;\t\t\t\t\t\t\t\t\t\t// and pos and ray of the front sphere is returned.\n        \t\tN_ray = reflect(N_ray,N_normPosA);\n    \t\t}\n    \t\telse{\n                color += vec3(tauxA,.0,tauxA);\n                vec3 Sray = reflect(N_ray,N_normPosA);\n                if (groundImpact(posA, ground, Sray, N_normPosA) ){\n       \t\t\t\tcolor += groundColor(posA);\n    \t\t\t}\n    \t\t\telse {\t\t// ray goes to the sky\n        \t\tcolor += skyColor(Sray);\n   \t\t\t\t}\n                color = mix(vec3(0.,tauxB,tauxB),color,.7);\n        \t\tpos = posB;\n        \t\tN_ray = reflect(N_ray,N_normPosB);   \n            }\n        }\n        else{\n            color.rb += tauxA;\n        \tpos = posA;\n        \tN_ray = reflect(N_ray,N_normPosA);   \n        }\n    }\n    else if (B_ok){\n        color.gb += tauxB;\n        pos = posB;\n        N_ray = reflect(N_ray,N_normPosB);\n    }\n    \n    return int(A_ok)+int(B_ok);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 st = fragCoord.xy/iResolution.xy-.5;\n    st.x *= iResolution.x/iResolution.y;\n    \n    // init global object\n    sphAO = vec3(40.*sin(iTime*.4),15.,60.*cos(iTime*.3));\n\tsphAR = 5.;\n\tsphBO = vec3(80.*sin(iTime*.4),16.,40.*cos(iTime*.3));\n\tsphBR = 6.;\n    ground = 0.;\n    \n    // camera def\n    float focal = 1.;\n    float \trau = 15.*(sin(iTime/11.)+1.)+3.*sphAR,\n    \t\talpha = -iTime/5.,\n    \t\ttheta = (sin(iTime/7.)/2.+.5)*(PI/2.-1.2)-.1;\t//rau, alpha, theta camera position   \n\t\n    vec3 camTarget = (sin(iTime*.2)+1.)*.5*sphAO + (sin(iTime*.2+PI)+1.)*.5*sphBO;  //target going from sphA to sphB\n    \n    vec3 screenPos = rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha))+camTarget;\n    \n    vec3 ww = normalize( camTarget - screenPos );\n    vec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\t// create view ray\n\tvec3 N_ray = normalize( st.x*uu + st.y*vv + focal*ww );\n\n    vec3 N_normPos = vec3(0.);\n    vec3 pos = screenPos;\n\n    vec3 color = vec3(.0);\n    \n    // get color on transparency path\n    // no object hit, only ground or sky\n    vec3 transPos = pos;    \n    vec3 transColor = vec3(0.);\n    if (groundImpact(transPos, ground, N_ray, N_normPos)){\n        transColor = groundColor(transPos);\n    }\n    else {transColor = skyColor(N_ray);}\n    //-------------------------------\n    \n    // calculate reflection\n    if (ojectReflect(pos, N_ray, color)>0){\t\t// first step ray\n        ojectReflect(pos, N_ray, color);\t\t// if sphere hit, second step ray\n    }\n    //-------------------------------\n    \n    // mix reflection and transparency\n    color = mix(color, transColor, .5);\n    \n    // otherwise no object impacted\n    if (groundImpact(pos, ground, N_ray, N_normPos) ){\n       color += groundColor(pos);\n    }\n    else {\t\t// ray goes to the sky\n        color += skyColor(N_ray);\n    }\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdlyR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 226, 254, 254, 379], [381, 381, 429, 429, 642], [644, 644, 733, 733, 935], [938, 938, 1033, 1033, 1700], [1702, 1702, 1732, 1732, 3903], [3905, 3905, 3932, 3932, 4063], [4066, 4066, 4135, 4135, 6213], [6215, 6215, 6272, 6272, 8173]]}
{"id": "MdlyRj", "name": "Trainpoints", "author": "josemorval", "description": "Simple movement pattern with points", "tags": ["circle", "pattern", "blackwhite", "points", "move"], "likes": 7, "viewed": 673, "published": "Public API", "date": "1489078632", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float SmoothCurve(float t){\n return smoothstep(0.0,1.0,t);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv-=0.5;\n    uv.x*= iResolution.x/iResolution.y;\n   \tuv*=0.2 + 3.0*(0.5+0.5*sin(0.3*iTime));\n    \n    float vel = 0.1;\n    vec2 uvrot = uv;\n    uvrot.x = cos(vel*iTime)*uv.x + sin(vel*iTime)*uv.y;\n    uvrot.y = -sin(vel*iTime)*uv.x + cos(vel*iTime)*uv.y;\n\tuv = uvrot;\n    \n    float radius = 0.6;\n    float offset = 0.01;\n    float freq = 3.0;    \n   \t\n    float maskx = 2.0*smoothstep(0.0,0.0,sin(freq*2.0*3.1419*uv.y))-1.0; \n    float masky = 2.0*smoothstep(0.0,0.0,sin(freq*2.0*3.1419*uv.x))-1.0; \n\n    float t = mod(iTime,4.0);\n    \n    if(t<1.0){\n          uv.x += SmoothCurve(t)*maskx;  \n    }else if(t<2.0){\n          uv.y += SmoothCurve(t-1.0)*masky;  \n    }else if(t<3.0){\n          uv.x -= SmoothCurve(t-2.0)*maskx;          \n    }else if(t<4.0){\n          uv.y -= SmoothCurve(t-3.0)*masky;             \n    }\n    \n   \t\n    float f = sin(freq*2.0*3.14159*uv.x)*sin(freq*2.0*3.1419*uv.y);\n    f = 1.0-smoothstep(radius-offset,radius+offset,abs(f));\n    \n    fragColor = vec4(f,f,f,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdlyRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 63], [65, 65, 122, 122, 1171]]}
{"id": "Mdlyz2", "name": "Noise 3/9/2017", "author": "Jops", "description": "noise", "tags": ["noise"], "likes": 1, "viewed": 80, "published": "Public", "date": "1489621882", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\nfloat rand(vec2 uv)\n{\n    //return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nfloat createPoly(int corners, vec2 uv, vec2 pos, float rotate)\n{\n    uv-=pos;\n    //pos.x *= ratio;\n// Number of sides of your shape\n\tint N = corners;\n\n// Angle and radius from the current pixel\n\tfloat a = atan(uv.x,uv.y)+PI + rotate;\n\tfloat r = TWO_PI/float(N);\n  \n// Shaping function that modulate the distance\n    float dist = cos(floor(.5+a/r)*r-a)*length(uv);\n    \n    return dist;\n}\n\nfloat createRectangle(vec2 uv, vec2 pos, vec2 size)\n{\n   \n    \n    float testH = step(pos.x, uv.x ) - step(pos.x + (size.x), uv.x );\n    float testV = step(pos.y, uv.y ) - step(pos.y + (size.y), uv.y );\n    \n    return testV * testH;\n}\n\nfloat createCircle(vec2 uv, vec2 pos, float rad)\n{\n    \n    float testV;\n    \n    testV = 1.-step(rad, distance(pos, uv));\n    //testV = 1.-step(rad, distance(pos, uv) + distance(uv, pos + vec2(0.05)));\n    \n   \t//testV = step(distance(pos, uv), rad);\n    //testV = step(distance(uv,pos), rad);\n  \t//testV = step(distance(uv, pos), rad);\n   \t//testV = step(distance(uv, pos) * distance(uv, pos), rad);\n    //testV += step(distance(uv, pos ) * distance(uv, pos), rad);\n    //testV = step(max(distance(uv,pos + vec2(0.6)), distance(uv, pos)), rad);\n\n\n      \n    //testV = fract(distance(uv,pos)) * (distance(uv, pos));\n    \n    return testV;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 pos = vec2(0.5 * ratio, 0.5);\n    float offset = noise(uv * 6. + iTime) * 0.06;\n    \n  \n    ////////////////////////////////////////////////////////////////////////////\n    //vec2 shapePos = vec2(.5*ratio, .5);\n    //float dist = distance(shapePos, uv)*2.;\n    \n    //uv -= shapePos;\n    //float angle = atan(uv.y, uv.x);\n    //float radius = cos(3.*angle);    \n    ////////////////////////////////////////////////////////////////////////////\n    float value;// = step(0.4 + offset, uv.x) - step(0.5 + offset, uv.x);\n    vec3 randc = vec3(uv * 0.2-0.9*sin(iTime), value) ;\n    //value = createRectangle(uv + offset, vec2(0.5 * ratio, 0.1), vec2(0.01, 0.6));\n    \n   \t//value += createRectangle(uv + offset, vec2(0.45 * ratio, 0.3), vec2(0.01, .5));\n    //value += createRectangle(uv + offset, vec2(0.55 * ratio, 0.3), vec2(0.01, .5));\n    \n    //value += createRectangle(uv + offset, vec2(0.3 * ratio, 0.7), vec2(0.1));\n    //value += createRectangle(uv + offset, vec2(0.355 * ratio, 0.8), vec2(0.1));\n    \n    //value += createRectangle(uv + offset, vec2(0.41 * ratio, 0.9), vec2(0.3,0.1));\n    \n    //value += createRectangle(uv + offset, vec2(0.63 * ratio, 0.7), vec2(0.1));\n    //value += createRectangle(uv + offset, vec2(0.578 * ratio, 0.8), vec2(0.1));\n    \n    //value += step(createPoly(4, uv + offset, vec2(0.88,0.8), 0.8), 0.1);\n    \n    //value += createRectangle(uv + offset, vec2(0.31 * ratio, 0.7), vec2(0.6,0.1));\n    \n  \t//value += step(createPoly(10, uv + offset, vec2(0.61,0.8), 0.8), 0.1);\n  \t//value += step(createPoly(10, uv + offset, vec2(0.68,0.9), 0.8), 0.1);\n    \n    //value += step(createPoly(10, uv + offset, vec2(1.12,0.8), 0.8), 0.1);\n  \t//value += step(createPoly(10, uv + offset, vec2(1.09,0.9), 0.8), 0.1);\n    //////////////////////////////////////////////////////////////////////////////////\n    //value *= fract(sin(uv.x * uv.y * 10000.)*100000.);\n    \n    float id = floor(uv.x*10.);\n    float r = rand(vec2(id));\n    \n    uv.y += r*2.5 * -iTime / 2. ;\n    uv.y = fract(uv.y);\n    \n    value = createCircle(uv + offset , vec2(0.5 *  ratio * abs(sin(iTime) + 1.0),      0.5), 0.1);\n    value += createCircle(uv + offset, vec2(0.5 * ratio * abs(sin(iTime -.11) + 1.0), 0.4), 0.1);\n    value += createCircle(uv + offset, vec2(0.5 * ratio * abs(sin(iTime - .22) + 1.0), 0.3), 0.1);\n    value += createCircle(uv + offset, vec2(0.5 * ratio * abs(sin(iTime - .33) + 1.0), 0.2), 0.1);\n    \n    value += createRectangle(uv + offset, vec2(0.4 * ratio * abs(sin(iTime) + 0.95), 0.5 ) , vec2(0.6, 0.01));\n    value += createRectangle(uv + offset, vec2(0.4 * ratio * abs(sin(iTime  -.11 ) + 0.95), 0.4 ) , vec2(0.6, 0.01));\n    value += createRectangle(uv + offset, vec2(0.4 * ratio * abs(sin(iTime  -.22) + 0.95), 0.3 ) , vec2(0.6, 0.01));\n    value += createRectangle(uv + offset, vec2(0.4 * ratio * abs(sin(iTime  -.33) + 0.95), 0.2 ) , vec2(0.6, 0.01));\n    \n    \n    //uv.y *= 3.;    \n    //vec2 tileIdx = floor(uv);\n   \t//uv = fract(uv);\n    //value = rand(tileIdx / iTime) * sin(5.*angle);\n    //value = rand(tileIdx ) * sin(5.*angle);\n    //value = rand(tileIdx);\n    \n    //value += step(0.4, uv.x ) - step(0.2+.3*.9 * r, uv.x)  ;\n    //value +=  createCircle(uv + offset , vec2(0.5 * ratio,      0.5 * r), 0.1);\n \t\n    \n    \n\t\n\tfragColor = vec4(vec3(value) ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mdlyz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 75, 250, 316], [319, 334, 359, 359, 870], [872, 872, 936, 936, 1260], [1262, 1262, 1315, 1315, 1497], [1499, 1499, 1549, 1549, 2140], [2142, 2142, 2199, 2199, 5625]]}
{"id": "MdscWX", "name": "Raymarching #1", "author": "djeof1", "description": "Just a simple raymarching application", "tags": ["raymarching", "testshader"], "likes": 3, "viewed": 82, "published": "Public", "date": "1490177574", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dist (vec3 d) {\n    vec3 e = fract(d) * 2.0 - 1.0;\n\treturn length(e) - 0.5;\n}\n\nfloat rayMarch(vec3 origin, vec3 ray) {\n    float t = 0.0;\n    for (int i = 0; i < 64; i++) {\n    \tvec3 p = origin + ray + t;\n        float d = dist(p);\n        t += d * 0.5;\n    }\n\treturn t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec3 ray = normalize(vec3(uv,1.0));\n    vec3 origin = vec3(0.0, 0.0, iTime);\n    float march = rayMarch(origin, ray);\n    float fog = 1.0/(1.0 + march*march*0.1);\n    vec3 finalColor = vec3(fog/0.22, fog/0.23, fog/0.13);\n    fragColor = vec4(finalColor,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdscWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 83], [85, 85, 124, 124, 278], [279, 279, 336, 336, 706]]}
{"id": "MdsyWS", "name": "Ray Marching Algorithm", "author": "DanielArgento", "description": "My First implementation of a ray marching algorithm ", "tags": ["raymarch"], "likes": 3, "viewed": 131, "published": "Public", "date": "1489716227", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphereRadius = 0.25;\nconst int iterations = 32;\n\n\n/*Takes a position in 3D space and tels you the distance to the nearest surface of the object\nthat the function defines\n\nIf this float returns:\n1 - outside the object\n0 - on the surface of the object\n-1 - inside the object */\n\nfloat map(vec3 p)\n{\n    \n    //transform the space into a repeating coordinate system\n    vec3 q = fract(p) * 2.0 - 1.0;\n    \n    \n\treturn length(q) - sphereRadius;\n}\n\n//The marching algorithm \n//needs an origin and a ray to march along\n float rayMarch(vec3 o, vec3 r)\n{\n\t//the intersection, this is what's determined when marching\n    float t = 0.0;\n    \n    for(int i = 0; i < iterations; ++i)\n    {\n        vec3 p = o + r * t; //where we are along the ray\n        float d = map(p);\n        t += d * 0.5; //accumulate t until we find the intersection\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //Transform texcoords so they go from -1 - 1\n    uv = uv * 2.0 - 1.0;\n    \n    //Fix aspect ratio or image will blur\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Create the ray we will march on\n    //must be normalized or the ray will poke through geometry when close to camera\n    vec3 r = normalize(vec3(uv, 1.0)); //add z value (FOV) to project uv into 3D space  \n                     \n    vec3 o = vec3(0.0, 0.0, iTime);//set origin back from sphere\n                       \n    float t = rayMarch(o, r); //find the intersection\n                       \n                       \n    //the further away an object is, the darker it gets (VERY HACKEY CODE)                   \n    float fog = 1.0 / (1.0 + t * t * 0.1);\n                       \n    vec3 fc = vec3(fog);\n        \n\tfragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdsyWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 283, 302, 368, 449], [451, 521, 553, 614, 857], [859, 859, 916, 916, 1780]]}
{"id": "MdXcD2", "name": "Juliamorph", "author": "WAHa_06x36", "description": "A quick visualisation of the relationship between the Mandelbrot set and the Julia set corresponding to a given point.\n\nPlay around with the value of z0 on line 26 to change the part of the set to explore!", "tags": ["fractal", "julia", "mandelbrot"], "likes": 11, "viewed": 786, "published": "Public API", "date": "1489916675", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float triangle(float x) {\n\tx -= 1.0;\n    x /= 4.0;\n    x -= floor(x);\n    x *= 4.0;\n    x -= 2.0;\n\tx = abs(x);\n    x -= 1.0;\n    return x;\n}\n\nfloat square(float x) {\n    x /= 4.0;\n    x -= floor(x);\n\treturn 1.0 - 2.0 * step(0.5, x);\n}\n\nvec3 palette(float i) {\n\tfloat x = 0.5 + 0.5*triangle(i / 30.0);\n    return vec3(2.0 * x, 2.0 * x - 0.5, 2.0 * x - 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = (2.0 * fragCoord.xy - iResolution.xy) / max(iResolution.x, iResolution.y);\n    vec2 z0 = vec2(-0.905, 0.25);\n    //vec2 z0 = vec2(-1.748, 0.001);\n    float zoom = 1.0 * exp(7.0 * smoothstep(0.0, 1.0, 0.5 + 0.5 * triangle(iTime / 20.0 + 1.0)));\n\tvec2 z = 2.0 / zoom * pos + z0;\n\n    float t = iTime / 2.0;\n    float r = length(pos);\n    float blend = clamp(2.0 * triangle(t) - square(t + 1.0) * r * 0.5, 0.0, 1.0);\n    \n    vec2 c = mix(z,z0,smoothstep(0.0, 1.0, blend));\n    \n    for(int i = 0; i < 128; i++) {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y);\n        z += c;\n        if(dot(z,z) > 4.0) {    \n\t\t    fragColor = vec4(palette(float(i)),1.0);\n            return;\n        }\n    }\n\n    fragColor = vec4(0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdXcD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 140], [142, 142, 165, 165, 234], [236, 236, 259, 259, 358], [360, 360, 417, 417, 1160]]}
{"id": "MdXcW2", "name": "Experimental II", "author": "pocketmoon", "description": "shadows in light", "tags": ["shadows"], "likes": 2, "viewed": 85, "published": "Public", "date": "1489884585", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Air Lights by Rob James  \"Flying Streetlights in Fog\"\n// Resuurecting my demo's from 2004/2006 \n// initial set up for inscatter calcs.\n// Integrates in-scatter along the eye/fragment line for a number of light sources.\n vec3 LightPosition[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tfloat itotal = 0.0;\n    \n    float brightness = 0.21;\n    \n    LightPosition[0]=vec3(0.01,0,-110.0);\n    LightPosition[1]=vec3(0.06,0,-110.0);\n    LightPosition[2]=vec3(0,0,-110.0);\n    \n    LightPosition[0].x += 0.02* sin(3.32 * iTime); \n    LightPosition[0].y += 0.01* sin(1.37 * iTime); \n    LightPosition[0].z += 30.315* sin(4.22 * iTime)-5.0; \n    \n    LightPosition[1].x -= 0.01* sin(2.11 * iTime); \n    LightPosition[1].y += 0.01* sin(2.132 * iTime); \n    LightPosition[1].z += 25.315* sin(1.33 * iTime)-10.0; \n    \n    LightPosition[2].x += 0.01* sin(2.21 * iTime); \n    LightPosition[2].y -= 0.02* sin(3.12 * iTime); \n    LightPosition[2].z = 200.315* sin(2.08 * iTime)+00.0; \n    \n    float hres = iResolution.y/2.0;\n    vec3 surf = vec3((fragCoord-hres)/iResolution.y,  -1000.0);\n    \n\tfloat fEye ;   \n    float fEye2 ; \n    float U ;\n    vec3 Pi ;\n    float rDist ;\n    float ooDp ;\n\n    // calulate the magnitude of the pixel - far plane vector\n    float mag =dot (surf,surf);//dot prod of v with itself is length squared...\n \n    for (int i = 0 ; i < 3; i++)\n    {\n        U =dot( LightPosition[i], surf)/mag;      // Signed\n\n        //Gives us the point along the eye/frag line that is closest to light soure.\n        // in a roundabout way we normalise the vector and then multiply it back up to\n        // get the point along it closet to the light\n        Pi =  surf * U;\n\n        //The distance between pI and light\n        vec3 t = Pi - LightPosition[i];\n        \n        rDist = length(t);\n\n        ooDp = 1.0/rDist;\n        \n        float len = length(Pi);        \n        \n\n        // inscatter from Pi to infinity\n        fEye = ooDp * 1.570796; // Arctan tends to pi.2 at infinity\n        \n        //Approximate Estimate of Accumulated in-scatter betweeb eye and Pi\n        fEye2 = ooDp * atan(ooDp * len);            \n        \n        fEye += fEye2 ; \n\n        //itotal = itotal + (brightness*fEye)/-LightPosition[i].z;\n        itotal = itotal + (brightness*fEye)/200.0;      \n    }\n    \n   fragColor =vec4 (itotal);    \n   // fragColor =vec4(fEye/200.0,fEye2/200.0, rDist*100.0, 1.0);    \n   // fragColor =vec4(0.0, 0.0, rDist*20.0, 1.0);    \n  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdXcW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 249, 306, 306, 2483]]}
{"id": "MdXyzs", "name": "Broken Screen Simulator", "author": "mgrant8164", "description": "Broken Screen Simulator - A failed project used a prank.", "tags": ["noise", "screen", "static", "broken", "cracked"], "likes": 7, "viewed": 2377, "published": "Public", "date": "1489426496", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 vp = vec3(3.);\nvec3 vpdir = vec3(-3.);\n\n\nvec4 getc(float z) {\n    float dpc = max(min(z,1.),-1.)/2.+0.5;\n    //return vec4(dpc,1.-dpc,0.,1.);\n    return vec4(vec3(1.-dpc-.3),1.);\n}\n\nfloat getdz(vec2 inp) {\n    float x = inp.x;\n    float y = inp.y;\n    return -cos(y-x)-sin(x+y);\n}\n\nfloat getz(vec2 inp) {\n    float x = inp.x;\n    float y = inp.y;\n    return -sin(y-x)+cos(x+y);\n    //return -4.*sin(y*y-x)+cos(x+y);\n}\n\nfloat gettdz(float t, vec2 dir) {\n    return vpdir.z-getdz(dir.xy * t);\n}\n\nfloat gettz(float t, vec2 dir) {\n    return vpdir.z*t+vp.z-getz(dir.xy * t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = 0.03* (fragCoord.xy - (iResolution.xy*.5));// - 0.5;\n    \n    float t = 0.;\n    float cz = vp.z;\n    //float roty = normalize(vpdir.z);\n    //vec2 origin = vp-vec3(0.,uv.x,uv.y);\n    \n    vpdir = vec3(0.)-vp-vec3(normalize(vpdir.xy)*uv.x,uv.y);\n    \n    vec2 dir = normalize(vpdir.xy + uv + iTime/100.);\n    \n    //calculate zero using newton's method\n    float pv = 0., cv = 0.;\n    //x_(n + 1) = x_n - (x_n cos(x_n))/(cos(x_n) - x_n sin(x_n))\n    for(int i = 0; i < 20; i++) {\n        pv = cv;\n        cv = cv - gettz(cv,dir)/gettdz(cv,dir);\n        //if((abs(pv-cv)>0.01) break;\n    }\n    \n    \n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    float z = getz(dir*pv);//.05*\n    fragColor = getc(0.5*z);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdXyzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 66, 66, 185], [187, 187, 210, 210, 285], [287, 287, 309, 309, 422], [424, 424, 457, 457, 497], [499, 499, 531, 531, 577], [579, 579, 636, 636, 1363]]}
{"id": "Ms2yR1", "name": "Green Grotto", "author": "dr2", "description": "Explore the Green Grotto; use the mouse to look around.", "tags": ["reflection", "refraction", "water", "cave", "drone"], "likes": 15, "viewed": 700, "published": "Public API", "date": "1490970591", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Green Grotto\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrRCylDf (vec3 p, float r, float rt, float h);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nconst float pi = 3.14159;\n\nvec3 ltPos[2], dronePos;\nvec2 aTilt;\nfloat dstFar, tCur, htWat;\nint idObj;\nbool uWat;\nconst int idDrBod = 1, idDrLamp = 2, idDrCam = 3;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d;\n  const float dSzFac = 6.;\n  dMin = dstFar;\n  dMin *= dSzFac;\n  qq = dSzFac * (p - dronePos);\n  qq.yz = Rot2D (qq.yz, - aTilt.y);\n  qq.yx = Rot2D (qq.yx, - aTilt.x);\n  q = qq;\n  q.y -= 0.05;\n  d = PrRCylDf (q.xzy, 0.2, 0.03, 0.07);\n  if (d < dMin) { dMin = d;  idObj = idDrBod; }\n  q.y -= 0.07;\n  d = PrRoundBoxDf (q, vec3 (0.06, 0.02, 0.12), 0.04);\n  if (d < dMin) { dMin = d;  idObj = idDrLamp; }\n  q = qq;\n  q.y -= -0.05;\n  d = PrSphDf (q, 0.17);\n  if (d < dMin) { dMin = d;  idObj = idDrCam; }\n  q = qq;\n  q.xz = abs (q.xz) - 0.7;\n  d = min (PrCylAnDf (q.xzy, 0.5, 0.05, 0.05), PrCylDf (q.xzy, 0.1, 0.03));\n  q -= vec3 (-0.4, -0.1, -0.4);\n  d = min (d, PrRCylDf (q.xzy, 0.05, 0.03, 0.15));\n  q -= vec3 (-0.3, 0.2, -0.3);\n  q.xz = Rot2D (q.xz, 0.25 * pi);\n  d = min (d, min (PrRCylDf (q, 0.05, 0.02, 1.), PrRCylDf (q.zyx, 0.05, 0.02, 1.)));\n  if (d < dMin) { dMin = d;  idObj = idDrBod; }\n  return dMin / dSzFac;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (4.7 * sin (t * 0.15) + 2.7 * cos (t * 0.19), 0., t);\n}\n\nfloat CaveDf (vec3 p)\n{\n  float s, d;\n  s = p.y - htWat;\n  p.xy -= TrackPath (p.z).xy;\n  p += 0.1 * (1. - cos (2. * pi * (p + 0.2 * (1. - cos (2. * pi * p.zxy)))));\n  d = 0.7 * (length (cos (0.6 * p - 0.5 * sin (1.4 * p.zxy +\n     0.4 * cos (2.7 * p.yzx)))) - 1.1);\n  if (! uWat) d = min (d, s);\n  return d;\n}\n\nfloat CaveRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    d = CaveDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nfloat CaveAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = 0; j < 8; j ++) {\n    d = float (j + 1) / 8.;\n    ao += max (0., d - 3. * CaveDf (ro + rd * d));\n  }\n  return clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nvec3 CaveNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (CaveDf (p + e.xxx), CaveDf (p + e.xyy),\n     CaveDf (p + e.yxy), CaveDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat CaveSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 16; j ++) {\n    h = CaveDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.2, 0.1 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\nvec3 ObjCol (vec3 ro, vec3 rd, vec3 vn, vec3 ltDir, float atten)\n{\n  vec4 col4;\n  if (idObj == idDrBod) col4 = vec4 (1.2, 0., 0., 0.5);\n  else if (idObj == idDrLamp) col4 = vec4 (mix (vec3 (0.1),\n      vec3 (1.5), step (0., sin (10. * tCur))), -1.);\n  else if (idObj == idDrCam) col4 = vec4 (0.1, 0.1, 0.1, 1.);\n  if (col4.a >= 0.)\n    col4.rgb = col4.rgb * (0.2 + 0.8 * CaveSShadow (ro, ltDir)) *\n       (0.1 + 0.9 * atten * (max (dot (ltDir, vn), 0.) +\n       col4.a * pow (max (dot (reflect (rd, vn), ltDir), 0.), 64.)));\n  return col4.rgb;\n}\n\nvec3 CaveCol (vec3 ro, vec3 rd, vec3 vn, vec3 ltDir, float atten)\n{\n  vec3 col;\n  col = vec3 (0.4, 0.4, 0.6);\n  if (! uWat) col = mix (col, vec3 (0.2, 0.4, 0.2), smoothstep (0.2, 0.8, vn.y));\n  col *= (0.2 + 0.8 * max (dot (vn, ltDir), 0.) +\n     0.5 * pow (max (dot (reflect (ltDir, vn), rd), 0.0), 64.)) *\n     (0.1 + 0.9 * atten * min (CaveSShadow (ro, ltDir), CaveAO (ro, vn)));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, colR, bgCol, ltVec, roo, rdo, row, vnw;\n  float dstCave, dstObj, atten, frFac;\n  bool hitWat;\n  roo = ro;\n  rdo = rd;\n  bgCol = (abs (rd.y) < 0.5) ? vec3 (0.05, 0.05, 0.1) : vec3 (0.01);\n  uWat = false;\n  hitWat = false;\n  dstCave = CaveRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstCave < min (dstObj, dstFar) && ro.y + rd.y * dstCave < htWat + 0.001) {\n    hitWat = true;\n    ro += rd * dstCave;\n    row = ro;\n    vnw = VaryNf (1.5 * ro, vec3 (0., 1., 0.), 0.1);\n    rd = reflect (rd, vnw);\n    ro += 0.01 * rd;\n    dstCave = CaveRay (ro, rd);\n    dstObj = ObjRay (ro, rd);\n  }\n  if (min (dstCave, dstObj) < dstFar) {\n    ltVec = roo + 2. * ltPos[0] - ro;\n    atten = 1. / (1. + 0.01 * dot (ltVec, ltVec));\n    ltVec = normalize (ltVec);\n    if (dstCave < dstObj) {\n      ro += rd * dstCave;\n      col = CaveCol (ro, rd, VaryNf (5. * ro, CaveNf (ro), 10.), ltVec, atten);\n      col = mix (col, bgCol, smoothstep (0.45, 0.99, dstCave / dstFar));\n    } else {\n      ro += rd * dstObj;\n      col = ObjCol (ro, rd, ObjNf (ro), ltVec, atten);\n    }\n  } else col = bgCol;\n  if (hitWat) {\n    frFac = rdo.y * rdo.y;\n    frFac *= frFac;\n    if (frFac > 0.005) {\n      rd = refract (rdo, vnw, 1./1.333);\n      ro = row + 0.01 * rd;\n      uWat = true;\n      dstCave = CaveRay (ro, rd);\n      if (dstCave < dstFar) {\n        ltVec = roo + 2. * ltPos[1] - ro;\n        atten = 1. / (1. + 0.01 * dot (ltVec, ltVec));\n        ltVec = normalize (ltVec);\n        ro += rd * dstCave;\n        colR = CaveCol (ro, rd, VaryNf (5. * ro, CaveNf (ro), 10.), ltVec, atten);\n        colR = mix (colR, bgCol, smoothstep (0.45, 0.99, dstCave / dstFar));\n      } else colR = bgCol;\n      col = mix (col, colR * vec3 (0.4, 1., 0.6) * exp (0.02 * ro.y), frFac);\n    }\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, fpF, fpB, vd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, t, tt, a;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  t = 2. * tCur;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az = az + 2. * pi * mPtr.x;\n    el = el + 0.95 * pi * mPtr.y;\n  } else {\n    tt = mod (floor (0.05 * tCur), 4.);\n    a = 0.45 * pi * SmoothBump (0.8, 0.95, 0.05, mod (0.05 * tCur, 1.));\n    if (tt < 2.) el = (2. * tt - 1.) * a;\n    else az = (2. * tt - 5.) * a;\n  }\n  tt = t + 1. + 7. * SmoothBump (0.2, 0.8, 0.15, mod (0.01 * t, 1.));\n  dronePos = TrackPath (tt);\n  aTilt = vec2 (5. * (TrackPath (tt + 0.1).x - dronePos.x), 0.);\n  fpF = TrackPath (t + 0.1);\n  fpB = TrackPath (t - 0.1);\n  ro = 0.5 * (fpF + fpB);\n  vd = fpF - fpB;\n  ori = vec2 (el, az + ((length (vd.xz) > 0.) ? atan (vd.x, vd.z) : 0.5 * pi));\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 1.5));\n  ltPos[0] = vuMat * normalize (vec3 (0., 1., -1.));\n  ltPos[1] = vuMat * normalize (vec3 (0., -1., -1.));\n  htWat = -0.5;\n  dstFar = 40.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 4; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n)) * (1. / 1.9375);\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2yR1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 638, 660, 660, 1609], [1611, 1611, 1644, 1644, 1820], [1822, 1822, 1843, 1843, 2050], [2052, 2052, 2078, 2078, 2148], [2150, 2150, 2173, 2173, 2459], [2461, 2461, 2495, 2495, 2672], [2674, 2674, 2707, 2707, 2891], [2893, 2893, 2915, 2915, 3132], [3134, 3134, 3172, 3172, 3411], [3413, 3413, 3479, 3479, 3958], [3960, 3960, 4027, 4027, 4358], [4360, 4360, 4395, 4395, 6205], [6207, 6207, 6260, 6260, 7609], [7611, 7611, 7644, 7644, 7671], [7673, 7673, 7715, 7715, 7766], [7768, 7768, 7821, 7821, 7882], [7884, 7884, 7937, 7937, 8116], [8118, 8118, 8164, 8164, 8211], [8213, 8213, 8270, 8270, 8353], [8355, 8355, 8385, 8385, 8443], [8566, 8566, 8590, 8590, 8637], [8639, 8639, 8664, 8664, 8863], [8865, 8865, 8894, 8894, 9122], [9124, 9124, 9163, 9163, 9386]]}
{"id": "MscSDf", "name": "Ripples Grid", "author": "fscur", "description": "Nice grid", "tags": ["ripplesgrid"], "likes": 21, "viewed": 482, "published": "Public", "date": "1489120466", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = 3.141592;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n    \n    \n    vec2 pos = vec2(0.0, 0.0);\n        \n    float dist = length(uv - pos);// * sin(3.141592 * iTime);\n    \n    float time = iTime;\n    \n    float rippleRadius = time;\n    \n    float diff = rippleRadius - dist;\n    \n    float func = sin(pi * diff);\n    \n    uv += uv * func * 0.1;\n    \n    \n    \n    //uv *= vec2(sin(iTime), cos(iTime));\n    \n    float stripes = 10.0;\n    float thickness = 10.0;\n    float sharpness = 2.0;\n    vec2 a = sin(stripes * 0.5 * pi * uv - pi/2.0);\n    vec2 b = abs(a);\n    \n    vec3 color = vec3(0.0);\n    color += 1.0 * exp(-thickness * b.x * (0.8 + 0.5 * sin(pi * iTime)));\n    color += 1.0 * exp(-thickness * b.y);\n    color += 0.5 * exp(-(thickness/4.0) * sin(b.x));\n    color += 0.5 * exp(-(thickness/3.0) * b.y);\n    \n    float ddd = exp(-5.5 * clamp(pow(dist, 3.0), 0.0, 1.0));\n    \n    vec3 t = vec3(uv.x * 0.5+0.5*sin(iTime), uv.y * 0.5+0.5*cos(iTime), pow(cos(iTime), 4.0)) + 0.5;\n    \n    fragColor = vec4(color * t * ddd, 0.0);\n    //fragColor = vec4(ddd);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MscSDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 79, 1211]]}
{"id": "MsfcD7", "name": "Ret_2.", "author": "calx", "description": "Distance Field Reticle. Similar to the other thing I did, just with 100 instructions rather than 1000.\nClick to change the seed, generate a new Reticle.", "tags": ["procedural", "distancefield", "reticle"], "likes": 6, "viewed": 345, "published": "Public", "date": "1488453138", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWO_PI  6.28318530718\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2\tuv          = 2.0 * vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n   \tint     num        \t= 10;\n    float   h_smooth    = 0.0025;\n    float   dist        = length(uv);\n    float  \tdi          = floor(dist * float(num));\n    float   df          = di / float(num);\n    float   seed        = floor(iMouse.x) + 12.0;\n    float   gen         = fract(sin(df)*seed);\n    float   sd          = abs(sin(di));\n    float   sp          = sin(di);\n    float   ro          = gen * TWO_PI;\n    float   th          = ro + ((sp) * iTime); \n    vec2  \tq           = vec2(cos(th)*uv.x + sin(th)*uv.y, -sin(th)*uv.x + cos(th)*uv.y);\n    float   a           = atan(q.x, q.y) * (gen * 5.0);\n    float   act      \t= mod(di, 2.0);\n    float   fs          = 0.1;\n    float   strk        = (gen * fs + 0.005);\n    float   crve        = (strk * 0.25) * (1.0-act);\n    float   sect        = ((4.000 * gen) * act);\n    float   sw          = (0.040 * act) * gen;\n    float   success     = step(gen, sd);\n    float   angle       = (a < 0.0) ? (a + TWO_PI) / TWO_PI : a / TWO_PI;\n    float   ring        = step(sw * (1.0+df*-1.0), fract(angle * sect));\n    float   inner       = smoothstep(df-h_smooth, df+h_smooth,  dist);\n    float   inSlope     = 0.25 * gen;\n    float   outSope     = 0.75 * gen;\n    float   oDist       = dist + smoothstep(inSlope, inSlope + 0.008, angle) * (1.0 - smoothstep(outSope, outSope+0.008, angle)) * crve;  \n    float   outer       = 1.0 -  smoothstep((df + strk - 0.001)-h_smooth, (df + strk - 0.001)+h_smooth, oDist);\n    float   solid       = 1.0 - (strk / fs) ;\n    float   outline     = step(dist, 1.0) * 1.0-step(dist, 0.05);\n    float   final       = inner * outer * ring * outline * solid * success;\n\n    fragColor = vec4 (final*(0.392), final*(0.627+(gen*0.176)), final*(0.392+(df*0.607)), 1.0) * 1.6;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsfcD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 88, 88, 1922]]}
{"id": "MsfcRS", "name": "Simple Ping", "author": "asmith13", "description": "Simple Ping. With tutorial Comments.\n\nEdit: Some comments to help new programmers to understand what is going on.\nAdded a illustration what is going on. great source for undestanding smoothstep:\nhttp://www.fundza.com/rman_shaders/smoothstep/ ", "tags": ["radar", "ping", "sweep"], "likes": 11, "viewed": 383, "published": "Public", "date": "1488645227", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Author: asmith13\n//Free to use as you wish. Have fun\n\n// Radar Bip\n//https://www.shadertoy.com/view/4s2SRt by ndel\n//https://www.shadertoy.com/view/Xsy3zG by Andre\n// mainly from https://www.shadertoy.com/view/MtdGW7 runekill\n\n#define green vec3(0.0,1.0,0.0)\n#define red vec3(1.0,0.0,0.0)\n#define blue vec3(0.0,0.0,1.0)\n\n// returns a vec3 color from every pixel requested.\n// Generates a BnW Ping on normalized 2d coordinate system\nvec3 RadarPing(in vec2 uv, in vec2 center, in float innerTail, \n               in float frontierBorder, in float timeResetSeconds, \n               in float radarPingSpeed, in float fadeDistance)\n{\n    vec2 diff = center-uv;\n    float r = length(diff);\n    float time = mod(iTime, timeResetSeconds) * radarPingSpeed;\n   \n    float circle;\n    // r is the distance to the center.\n    // circle = BipCenter---//---innerTail---time---frontierBorder\n    //illustration\n    //https://sketch.io/render/sk-14b54f90080084bad1602f81cadd4d07.jpeg\n    circle += smoothstep(time - innerTail, time, r) * smoothstep(time + frontierBorder,time, r);\n\tcircle *= smoothstep(fadeDistance, 0.0, r); // fade to 0 after fadeDistance\n        \n    return vec3(circle);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    //normalize coordinates \n    vec2 uv = fragCoord.xy / iResolution.xy; //move coordinates to 0..1\n    uv = uv.xy*2.; // translate to the center\n    uv += vec2(-1.0, -1.0);\n    uv.x *= iResolution.x/iResolution.y; //correct the aspect ratio\n    \n\tvec3 color;\n    // generate some radar pings\n    float fadeDistance = 1.0;\n    float resetTimeSec = 4.0;\n    float radarPingSpeed = 0.3;\n    vec2 greenPing = vec2(-1.0, 0.0);\n    vec2 redPing   = vec2( 0.0, 0.0);\n    vec2 bluePing  = vec2( 1.0, 0.0);\n    color += RadarPing(uv, greenPing, 0.25, 0.025, resetTimeSec, radarPingSpeed, fadeDistance) * green;\n    color += RadarPing(uv, redPing, .01, 0.01, resetTimeSec, radarPingSpeed, fadeDistance) * red;\n    color += RadarPing(uv, bluePing, .01, 0.5, resetTimeSec, radarPingSpeed, fadeDistance) * blue;\n    \n    //return the new color\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsfcRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[323, 434, 630, 630, 1179], [1181, 1181, 1238, 1268, 2104]]}
{"id": "MsfyW2", "name": "Impulse", "author": "dedmoros", "description": "Experiments in plotting functions", "tags": ["sinxplot"], "likes": 4, "viewed": 170, "published": "Public", "date": "1489883447", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nvec2 getPixelUnit()\n{\n\treturn 1./iResolution.xy;\n}\n\nfloat expStep( float x, float k, float n )\n{\n    return clamp(exp( -k*pow(x,n) ), 0., 1.);\n}\n\nfloat plot(float y, float thickness)\n{\n    vec2 px = getPixelUnit();\n    float val = expStep( y, 40., thickness*1. );\n    return clamp(pow(val, 10.)*2., 0., 1.);\n}\n\nfloat plot(float y1, float y2, float thickness)\n{\n    float m = y1-y2;\n    m = abs(m)*70.;\n    return plot(y1, thickness+m);\n}\n        \nfloat impulse(float x)\n{\n\treturn sin( x*PI ) / ( x*PI );\n}\n\nfloat plotImpulse(vec2 p, float repetitions, float amplitude, float offset)\n{\n    vec2 px = getPixelUnit();\n    float sinx1 = impulse(p.x*repetitions);\n    float sinx2 = impulse((p.x+1.5*px.x)*repetitions);\n    float y1 = (p.y-sinx1*amplitude+offset);\n    float y2 = (p.y-sinx2*amplitude+offset);\n    return plot(y1, y2, .9);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= 2.;\n    vec3 c = vec3(1.);\n    vec2 px = getPixelUnit();\n    for(float i = 0.; i < 10.; i ++)\n    {\n        float val = plotImpulse(uv, 2.+i, sin(iTime/(10.+i))*.77, .0);\n        c -= val;\n    }\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsfyW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 47, 47, 76], [78, 78, 122, 122, 170], [172, 172, 210, 210, 335], [337, 337, 386, 386, 463], [473, 473, 497, 497, 531], [533, 533, 610, 610, 860], [862, 862, 919, 919, 1209]]}
{"id": "Msfyzs", "name": "balls with light", "author": "t91", "description": "ray marching", "tags": ["raymarching"], "likes": 3, "viewed": 124, "published": "Public", "date": "1489534409", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3  v_cam_pos = vec3(0.0, 1.0, -6.0);\nvec3  v_cam_forward = vec3(0.0, 0.0, 1.0);\nvec3  v_cam_right = vec3(1.0, 0.0, 0.0);\nvec3  v_cam_up = vec3(0.0, 1.0, 0.0);\nvec3  v_sundir = normalize(vec3(0.0, 1.0, 1.10));\nfloat f_near = 2.3;\n\n#define SPHERE 100\n#define FLOOR 999\n#define WALL 1000\n#define CEIL 1001\n#define INFINITY 99999.0\n\n#define EPSILON 0.00001\n#define MAX_STEPS 400\n\n#define CEIL_HEIGHT 12.0\n#define BOX_RADIUS 20.0\n\n#define PI 3.1415926535\n\nvec3 ToRay(in vec2 fragCoord, in mat3 m)\n{\n    vec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\tvec2 ndc = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0; \n\tvec3 ray = vec3(aspect * ndc, f_near);\n\treturn m * normalize(ray);\n}\n\nvoid Box(vec3 point, out int matid, inout float distance)\n{\n    float boxdist = INFINITY;\n\n    #define TEST(dist, mid) if (dist<distance) { distance = dist; matid=mid; }\n    \n    float zrad = sin(point.x)*0.2 + BOX_RADIUS;\n    float xrad = sin(point.z)*0.2 + BOX_RADIUS;\n    \n    float z = zrad + point.z;\n    float x = xrad + point.x;\n    \n    if (point.z > 0.0)\n    \tz = zrad - point.z;\n\n    if (point.x > 0.0)\n    \tx = xrad - point.x;\n\n    TEST(z, WALL);\n    TEST(x, WALL);\n    TEST(point.y - 0.1*sin(length(point.xz)+iTime), FLOOR);\n    TEST(CEIL_HEIGHT - point.y, CEIL);\n}\n\nvec3 spheres_pos[7];\n\nvoid Sphere(vec3 point, out int matid, inout float distance, float x, float y, int id)\n{   \n    float dist = (1.0 + max(0.0, sin(iTime * 4.0 + (float(id)*PI * 0.25)))) * 3.0;\n    \n    vec3 position = vec3(x * dist, 2.0, y * dist);\n    float radius = 1.0;\n    \n    spheres_pos[id] = position + vec3(0.0, radius * 1.1, 0.0);\n\n    float l2c = length(point - position) - radius;\n\n    if (l2c < distance)\n    {\n        distance = l2c;\n        matid = int((x * 17.0) + (y * 13.0) + 23.0) ^ 0x55555555;\n    }\n}\n\nfloat SceneDistance(vec3 point, out int matid)\n{\n    vec3 offset = vec3(0.0, 3.4, 0.0);\n    float distance = INFINITY;\n\n    Sphere(point, matid, distance, -1.0,  0.0, 0);\n    Sphere(point, matid, distance,  0.0,  0.0, 1);\n    Sphere(point, matid, distance,  1.0,  0.0, 2);\n    Sphere(point, matid, distance,  0.0,  1.0, 3);\n    Sphere(point, matid, distance,  0.0, -1.0, 4);\n\tSphere(point, matid, distance, -2.0, -2.0, 5);\n    Sphere(point, matid, distance,  2.0,  2.0, 6);\n    \n    Box(point, matid, distance);\n\n\n\treturn distance;\n}\n\nvec3 March(vec3 start, vec3 ray, out int matid, out int samples, out float prec)\n{   \n    matid = -1;\n    samples = -1;\n    float step = 0.0;\n    \n\tfor (int i = 0; i < MAX_STEPS; ++i)\n    {\n        step = SceneDistance( start, matid );\n\n        if (step < EPSILON)\n        {\n            prec = step;\n            samples = i;\n            return start;\n        }  \n        \n        start += step * ray;\n    }\n    \n    return vec3(0,0,0);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// calculate normal \n// taken from https://www.shadertoy.com/view/4lGSWt\nfloat df(vec3 p)\n{\n    int matid = 0;\n\treturn SceneDistance(p, matid);\n}\nvec3 calcNormal(vec3 p) {\n\tfloat eps = 0.001;\n\treturn normalize(vec3(\n\t\tdf(p + vec3(eps, 0, 0)) - df(p + vec3(-eps, 0, 0)),\n\t\tdf(p + vec3(0, eps, 0)) - df(p + vec3(0, -eps, 0)),\n\t\tdf(p + vec3(0, 0, eps)) - df(p + vec3(0, 0, -eps))\n\t\t));\n}\n/////////////////////////////////////////////////////////////////////////////\n\nvoid SampleEnv(in vec3 ori, in vec3 dir, out vec3 pos, out vec3 nrm, out int matid, out int samples)\n{\n    float prec;\n    \n    pos = March(ori, dir, matid, samples, prec);   \n    nrm = calcNormal(pos);\n}\n\nvec4 IdToColor(int id)\n{\n    vec4 outc = vec4(0.0);\n\n    outc.x = float((id)%11) * 0.1;\n    outc.y = float((id+3)%11) * 0.1;\n    outc.z = float((id+6)%11) * 0.1;\n    outc.w = 0.7;\n    \n    if (id == FLOOR)\n    {\n    \toutc = vec4(1.3, 1.0, 0.3, 0.1);\n    }\n    else if (id == CEIL)\n    {\n        outc = vec4(1.0, 0.5, 1.0, 1.0);\n    }\n    else if (id == WALL)\n    {\n    \toutc = vec4(3.0, 1.3, 1.0, 0.1);\n    }\n\n    return outc;\n}\n\nfloat AmbientOcclusion(float samples)\n{\n\treturn (1.0-clamp(pow(samples / 400.0, 0.2), 0.0, 1.0));\n}\n\nfloat ShadowSample(vec3 pos, vec3 sunpos)\n{\n    sunpos *= 0.9;\n    int id;\n    int smp;\n    float prec;\n\n    vec3 sundir = normalize(pos-sunpos);\n    \n    vec3 shadow_pos = March(sunpos, sundir, id, smp, prec);\n\n    if (smp < 0)\n        return 1.0;\n    \n    float dist2pos = length(sunpos - pos);\n    float dist2shd = length(sunpos - shadow_pos);\n    \n    float dist = abs(dist2pos - dist2shd);\n    \n    if (dist2shd + 0.01 < dist2pos)\n        return 0.5;\n\telse \n        return 1.0;\n}\n\nfloat Shadow(vec3 pos)\n{\n    float shadow = 0.0;\n\n    for (int i = 0; i < 7; ++i)\n    {\n        shadow += ShadowSample(pos, spheres_pos[i] );\n    }\n    \n\n    return shadow * 0.25;\n}\n\nvec3 AmbientLight()\n{\n\treturn vec3(1.0, 1.0, 1.0) * 0.2;\n}\n\nvec3 SunLight(vec3 nrm)\n{\n\treturn dot(nrm, v_sundir) * vec3(1.0, 1.0, 1.0); // * vec3(0.9, 0.2, 0.2) * 6.0;\n}\n\nvec3 Diffuse(vec3 pos, int id)\n{\n    vec3 color = IdToColor(id).xyz;\n    \n\treturn color;\n}\n\nvec3 Specular(vec3 pos, vec3 nrm, int id)\n{\n    vec3 VertexToEye = normalize(v_cam_pos - pos);\n    float str = 0.0;\n \n    for (int i = 0; i < 7; ++i)\n    {\n        vec3 sundir = normalize(pos - (spheres_pos[i]));\n        \n        vec3 LightReflect  = normalize(reflect(sundir, nrm));\n        \n        str = max(str, dot(VertexToEye, LightReflect));\n       \n    }\n\n    float spec = IdToColor(id).w;\n    \n\tvec3 spc = pow(str, 30.0 * spec) * vec3(1.0, 1.0, 1.0);\n    \n    return spc;\n}\n\nvec3 Reflection(vec3 ray, vec3 pos, vec3 nrm, int surface_id)\n{  \n    vec3 reflected = reflect(ray, nrm);\n    \n    int matid;\n    int samples;\n    float prec;\n    vec3 hit = March(pos.xyz + nrm*0.01, reflected, matid, samples, prec);\n    \n    if (samples < 0)\n\t\treturn vec3(0, 0, 0);\n    \n    \n    return Diffuse(hit.xyz, matid);\n}\n\nvec3 Fog(vec3 pos)\n{\n    float distance = length(pos.xyz - v_cam_pos);\n\n\treturn max(0.0, exp(-distance * 0.01 )) * vec3(1.0, 1.0, 1.0);\n}\n\nmat3 CameraMatrix()\n{\n    float radius = 15.0;\n\n    float param = iTime * 0.3;\n    float height = 4.0;\n    \n    if (iMouse.z > 0.0)\n    {\n    \tparam = iMouse.x * 0.1;//obalTime * 0.3;\n    \theight = 1.0 + iMouse.y * 0.01;\n    \n    }\n\t\n    v_cam_pos.x = sin(param) * radius;\n    v_cam_pos.y = height;\n    v_cam_pos.z = cos(param) * radius;\n    \n    v_cam_forward = -normalize(v_cam_pos);\n    v_cam_forward.y = 0.0;\n    v_cam_forward = normalize(v_cam_forward);\n    \n    v_cam_forward = -normalize(v_cam_pos);\n    \n    v_cam_right   = cross(v_cam_forward, v_cam_up);\n \n    mat3 m;\n    m[0] = v_cam_right;\n    m[1] = v_cam_up;\n    m[2] = v_cam_forward;\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tmat3 cam = CameraMatrix();\n    vec3 ray = ToRay(fragCoord, cam);\n    \n    vec3 pos;\n    vec3 nrm;\n    int matid;\n    int samples;\n    \n    SampleEnv(v_cam_pos, ray, pos, nrm, matid, samples);\n\n    vec4  mat = IdToColor(matid);\n    \n    vec3  dif = Diffuse(pos, matid);\n    vec3  spc = Specular(pos, nrm, matid);\n    vec3  rfl = Reflection(ray, pos, nrm, matid);\n    vec3  amb = AmbientLight();\n    vec3  sun = SunLight(nrm);\n    vec3  fog = Fog(pos);\n    float shd = AmbientOcclusion(float(samples)) * Shadow(pos);\n    \n    vec3 color = vec3(0.0);\n\n    color = (amb + dif + spc + rfl*mat.w) * shd * fog;\n    \n    fragColor.xyz = color;\n    \n    //fragColor.xyz = mat.xyz;\n   // fragColor.xyz = nrm * 0.5 + 0.5;\n    fragColor.w = 1.0;  \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Msfyzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[454, 454, 496, 496, 684], [686, 686, 745, 745, 1263], [1287, 1287, 1375, 1375, 1790], [1792, 1792, 1840, 1840, 2325], [2327, 2327, 2409, 2409, 2764], [2766, 2917, 2935, 2935, 2989], [2990, 2990, 3015, 3015, 3228], [3229, 3308, 3410, 3410, 3512], [3514, 3514, 3538, 3538, 3942], [3944, 3944, 3983, 3983, 4043], [4045, 4045, 4088, 4088, 4529], [4531, 4531, 4555, 4555, 4712], [4714, 4714, 4735, 4735, 4772], [4774, 4774, 4799, 4799, 4883], [4885, 4885, 4917, 4917, 4975], [4977, 4977, 5020, 5020, 5459], [5461, 5461, 5524, 5524, 5792], [5794, 5794, 5814, 5814, 5931], [5933, 5933, 5954, 5954, 6602], [6604, 6604, 6661, 6661, 7405]]}
{"id": "MslcWl", "name": "chladni field", "author": "jes5199", "description": "https://www.desmos.com/calculator/rdpbran7og", "tags": ["2d", "oscillating", "chladni"], "likes": 1, "viewed": 197, "published": "Public", "date": "1490417086", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 0.01;\n\tvec2 uv = zoom * (fragCoord.xy - iResolution.xy / 2.0);\n        \n    float t = iTime;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    float m = 5.;\n    float n = 5. + 4. * sin(t/10.5); // m * (1. + t*t*t / 2.);\n    \n    float a = 1.;\n    float b = 1. + sin(t/1.) * 0.90;\n    \n    float value = (\n       a * sin(m*x) * sin(n*y) + b * sin(n*x) * sin(m*y)\n    );\n\n        \n    float color = (value) * 6.0;\n    \n    if(color > 0.0) {\n      fragColor = 1. - (color * vec4(0.2,1.5,2.,0)); \n    } else {\n      //fragColor = vec4(med, med, low,1.0);\n      fragColor = 1. - (-color * vec4(1,1.5,0.2,0));\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MslcWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 695]]}
{"id": "MslcWX", "name": "Iloinen marjapuuron zoomailu", "author": "Sp3ci", "description": "Drawing some randomized squares", "tags": ["2d", "random"], "likes": 0, "viewed": 89, "published": "Public", "date": "1490176735", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Drawing some randomized squares.\n// by Eerik Kukkonen\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Random function\nfloat random (vec2 st) { \t\t\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))* \n        43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy; \t\t// Normalize the coordinates\n//    vec2 st = iResolution.xy/fragCoord.xy;\t// Mixing the coordinate system on purpose\n    st.x = fragCoord.x/iResolution.y;\t\t\t// Get the proportions 1 by 1 for the squares\n        \n    st.x *= 10.0 - sin(iTime) * 5.0;\t\t// Scale the st to get bigger squares.\t\n    st.y *= 10.0 - sin(iTime) * 5.0; \t\t// Using sin(time) to get some zooming motion.\n    \t\t\t\t\t\t\t\t\t\t\t// Multiplying by 5.0 to get some more motion happening.\n    \n    vec2 ipos = floor(st);  // Get integer coordinates for drawing the squares.\n\n    // Get random blue value based on the ipos coordinates and the time.\n    // It's important to give both x and y to get a random color for a single square.\n    vec3 color = vec3(1.0, 0.5, random( vec2(ipos.x, ipos.y) + (iTime) )); \n\n    fragColor = vec4(color,1.0);\n}\n\n// Jep tuli jonkin verran luettua ja selattua Book of Shadersia.\n// Random-osion pohjalta sitten tein tätä shaderia. Piirtelin jossain vaiheessa ympyrää\n// Youtube-tutoriaalin perusteella.\n\n// Itsearviointi: 3\n\n// Mielestäni tämä voisi olla oikea arvosana palautuksestani. Käytän tehtävässä ajan\n// uniformia kahdessa paikassa saadakseni hieman liikettä kuvaan. Kuitenkaan tämä\n// ei ehkä edistyneisyyden puolesta riitä 5 pisteen suoritukseen.\n// Aihe on hyvin mielenkiintoinen ja hyvin laaja. Ehdotan omaa kurssia shadereista!\n\n// Lähteitä:\n// https://thebookofshaders.com/10/\n// https://youtu.be/u5HAYVHsasc?list=PLGmrMu-IwbguU_nY2egTFmlg691DN7uE5\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MslcWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 123, 147, 147, 258], [260, 260, 317, 317, 1167]]}
{"id": "MslczX", "name": "My 2D Water", "author": "taecg", "description": "模拟2D水面效果", "tags": ["2d", "water"], "likes": 1, "viewed": 664, "published": "Public API", "date": "1489205369", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragCoord.y += sin(iTime+fragCoord.x*0.00125)*80.;\n    \n    float heigth = iResolution.y/2.;\n    \n    if(fragCoord.y<heigth)\n    {\n        fragColor=vec4(0.,fragCoord.y/heigth,0.85,1.);\n    }\n    else\n    {\n        fragColor=vec4(0.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MslczX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 301]]}
{"id": "MslyW2", "name": "Chromatic", "author": "granskog", "description": "Basic test with sine distortions and some chromatic aberration.", "tags": ["basic", "sine", "chromatic", "aberration", "polarcoordinates", "cosine", "twist"], "likes": 10, "viewed": 175, "published": "Public", "date": "1490023314", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    float time = sin(iTime * 0.05) * 100. + 500.;\n    \n    p += 0.015 * sin(time * p.yx * 0.1);\n    p += 0.005 * cos(time * p.xy * 0.01);\n    \n    float r = length(p);\n    float d = pow(r, 0.3) + 0.05;\n    float fade = clamp(r, 0.2, .7);\n    float freq = 1.0;\n    \n    float rr = fade + sin(time * d * 0.5 * freq + 1.15);\n    float gg = fade + sin(time * d * 0.499 * freq + 0.85);\n    float bb = fade + sin(time * d * 0.498 * freq + 0.55);\n    \n    fragColor = vec4(rr,gg,bb,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MslyW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 599]]}
{"id": "MslyW7", "name": "interdimensional rift", "author": "Mopnex", "description": "interdimensional rift", "tags": ["interdimensionalrift"], "likes": 1, "viewed": 129, "published": "Public", "date": "1488536742", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define iterations 4\n#define formuparam2 0.89\n \n#define volsteps 4\n#define stepsize 0.35190\n \n#define zoom 9.900\n#define tile   0.450\n#define speed2  -0.1\n \n#define brightness 0.1\n#define darkmatter 0.400\n#define distfading 0.8560\n#define saturation 0.400\n\n\n#define transverseSpeed -0.1\n#define cloud 0.2\n\n \nfloat triangle(float x, float a)\n{\n \n \nfloat output2 = 2.0*abs(  2.0*  ( (x/a) - floor( (x/a) + 0.5) ) ) - 1.0;\nreturn output2;\n}\n \n\nfloat field(in vec3 p) {\n\nfloat strength = 8. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\nfloat accum = 0.;\nfloat prev = 0.;\nfloat tw = 0.;\n\n\nfor (int i = 0; i < 6; ++i) {\nfloat mag = dot(p, p);\np = abs(p) / mag + vec3(-.5, -.8 + 0.1*sin(iTime*0.2 + 2.0), -1.1+0.3*cos(iTime*0.15));\nfloat w = exp(-float(i) / 7.);\naccum += w * exp(-strength * pow(abs(mag - prev), 2.3));\ntw += w;\nprev = mag;\n}\nreturn max(0., 5. * accum / tw - .7);\n}\n\nfloat Sphere_radius;\n\nvec3 getSurfacePosition(vec2 coord) {\n    \n    float mov_radius;\n    vec2  screen_center;\n    vec3  Sphere_center;\n\n    float index;\n    vec2  tmpv2;\n    float acc;\n    \n    index = 1.0;\n    \n    mov_radius = min(iResolution.x, iResolution.y)*0.25;\n    screen_center = iResolution.xy * 0.5;\n    acc = 0.0;\n    \n    for (int k=0; k<5; k++) {\n        index += 1.0;\n        Sphere_center = vec3(screen_center.x + mov_radius * -cos(iTime*index),\n           screen_center.y + mov_radius * sin(iTime*(5.0-index)*1.013),\n           0.0);\n      \n        tmpv2 = Sphere_center.xy - coord.xy;\n        acc += Sphere_radius/length(tmpv2);\n    }\n    if (acc > 1.00) {\n        acc = 1.0 - 1.0/acc;\n        acc *= Sphere_radius;\n        \n        acc = (Sphere_radius * acc)/(Sphere_radius*0.30 + acc);\n        acc = (Sphere_radius * acc)/(Sphere_radius*0.30 + acc);\n        acc = (Sphere_radius * acc)/(Sphere_radius*0.20 + acc);\n        \n        } else {\n          acc = -200.0;\n      }\n      \n      return vec3(coord, acc);\n  }\n\n  void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 screen_center;\n\n    vec3 ViewDirection;\n    ViewDirection = vec3 (.0,.0,-1.0);\n    \n    float mov_radius;\n    \n    mov_radius = min(iResolution.x, iResolution.y)*0.25;  \n    screen_center = iResolution.xy * 0.5;\n    \n    Sphere_radius = mov_radius*0.2;\n      \n      \n/*******************************************************************************************/\n    vec3 LightColor;\n    vec3 SpecularLightColor[3];\n    vec3 DiffuseLightColor[3];\n    vec3 AmbientLightColor;\n    \n    float DiffuseLightIntensity;\n    float SpecularLightIntensity;\n    float AmbientLightIntensity;\n    \n    DiffuseLightColor[0] = vec3(1.0,0.3,0.2);\n    SpecularLightColor[0] = vec3(0.5,0.7,0.8);\n    \n    DiffuseLightColor[1] = vec3(0.2,0.2,1.0);\n    SpecularLightColor[1] = vec3(0.8,0.8,0.5);\n    \n    DiffuseLightColor[2] = vec3(0.6,1.0,0.2);\n    SpecularLightColor[2] = vec3(0.4,0.5,0.8);\n    \n    AmbientLightColor = vec3(0.1,0.1,0.15);\n    \n    vec3 LightPosition[3];\n    vec3 LightDirection;\n    vec3 SpecularDirection;\n    \n    /***********************************************************/\n    /* Geometry                                                */\n    /***********************************************************/\n    vec3  SurfaceNormal;\n    vec3  SurfacePosition;\n    vec3  Sphere_center;\n    vec3  SurfDX;\n    vec3  SurfDY;\n    vec2  tmpv2;\n    \n    float dist_from_center;\n    \n    dist_from_center = 0.0;\n    \n    float index;\n    float inv;\n    float acc;\n    \n    inv = .0;\n    acc = .0;\n    index = 1.0;\n    \n    SurfacePosition = getSurfacePosition(fragCoord.xy);\n  \n/*****************************************************************************************************************/\n  \nvec2 uv2 = 2. * fragCoord.xy / iResolution.xy - 1.;\nvec2 uvs = uv2 * iResolution.xy / max(iResolution.x, iResolution.y);\n\nfloat time2 = iTime*0.7;       \nfloat speed = speed2;      \nspeed = 0.1;\n\n    float formuparam = formuparam2;\n    \n//get coords and direction\n\nvec2 uv = uvs;\n       \n//mouse rotation\nfloat a_xz = 0.9;\nfloat a_yz = -.6;\nfloat a_xy = 0.9 + iTime*0.04;\n\nmat2 rot_xz = mat2(cos(a_xz),sin(a_xz),-sin(a_xz),cos(a_xz));\nmat2 rot_yz = mat2(cos(a_yz),sin(a_yz),-sin(a_yz),cos(a_yz));\nmat2 rot_xy = mat2(cos(a_xy),sin(a_xy),-sin(a_xy),cos(a_xy));\n\nfloat v2 =1.0;\nvec3 dir=vec3(uv*zoom,1.);\nvec3 from=vec3(0.0, 0.0,0.0);\nvec3 forward = vec3(0.,0.,1.);\n\nfrom.x += transverseSpeed*(1.0)*cos(0.01*iTime) + 0.001*iTime;\nfrom.y += transverseSpeed*(1.0)*sin(0.01*iTime) +0.001*iTime;\n\nfrom.z += 0.003*iTime;\n\ndir.xy*=rot_xy;\nforward.xy *= rot_xy;\n\ndir.xz*=rot_xz;\nforward.xz *= rot_xz;\n\ndir.yz*= rot_yz;\nforward.yz *= rot_yz;\n\nfrom.xy*=-rot_xy;\nfrom.xz*=rot_xz;\nfrom.yz*= rot_yz;\n \n//zoom\nfloat zooom = (time2-3311.)*speed;\nfrom += forward* zooom;\nfloat sampleShift = mod( zooom, stepsize );\n \nfloat zoffset = -sampleShift;\nsampleShift /= stepsize; // make from 0 to 1\n\n//volumetric rendering\nfloat s=0.24;\nfloat s3 = s + stepsize/2.0;\nvec3 v=vec3(0.);\nfloat t3 = 0.0;\n\n\nvec3 backCol2 = vec3(0.);\nfor (int r=0; r<volsteps; r++) {\nvec3 p2=from+(s+zoffset)*dir;// + vec3(0.,0.,zoffset);\nvec3 p3=(from+(s3+zoffset)*dir )* (1.9/zoom);// + vec3(0.,0.,zoffset);\n\np2 = abs(vec3(tile)-mod(p2,vec3(tile*3.5))); // tiling fold\np3 = abs(vec3(tile)-mod(p3,vec3(tile*2.))); // tiling fold\n\n#ifdef cloud\nt3 = field(p3);\n#endif\n\nfloat pa,a=pa=0.;\nfor (int i=0; i<iterations; i++) {\np2=abs(p2)/dot(p2,p2)-formuparam; // the magic formula\nfloat D = abs(length(p2)-pa); // absolute sum of average change\n\nif (i > 2)\n{\na += i > 7 ? min( 12., D) : D;\n}\npa=length(p2);\n}\n\n\na*=a*a; // add contrast\n// brightens stuff up a bit\nfloat s1 = s+zoffset;\n// need closed form expression for this, now that we shift samples\nfloat fade = pow(distfading,max(0.,float(r)-sampleShift));\n\nv+=fade;\n\n// fade out samples as they approach the camera\nif( r == 0 )\nfade *= (1. - (sampleShift));\n// fade in samples as they approach from the distance\nif( r == volsteps-1 )\nfade *= sampleShift;\nv+=vec3(s1,s1*s1,s1*s1*s1*s1)*a*brightness*fade; // coloring based on distance\n\nbackCol2 += mix(.4, 1., v2) * vec3(0.20 * t3 * t3 * t3, 0.4 * t3 * t3, t3 * 0.7) * fade;\n\n\ns+=stepsize;\ns3 += stepsize;\n\n}\n       \nv=mix(vec3(length(v)),v,saturation); //color adjust\n \nvec4 forCol2 = vec4(v*.01,1.);\n\n#ifdef cloud\nbackCol2 *= cloud;\n#endif\n\nbackCol2.b *= 0.01;\nbackCol2.r *= 0.01;\nbackCol2.b = 0.5*mix(backCol2.b, backCol2.g, 1.2);\nbackCol2.g = 0.01;\nbackCol2.bg = mix(backCol2.gb, backCol2.bg, 0.5*(cos(iTime*0.01) + 1.0));\n  \n/*****************************************************************************************************************/\n\n  \n    if (SurfacePosition.z > 0.0) { \n        SurfDX = getSurfacePosition(vec2(fragCoord.x + 1.0, fragCoord.y));\n        SurfDY = getSurfacePosition(vec2(fragCoord.x, fragCoord.y+1.0));\n        SurfDX.z *= 1.0;\n        SurfDY.z *= 1.0;\n        SurfaceNormal = normalize(cross(SurfDX - SurfacePosition, SurfDY - SurfacePosition));\n        } else {\n            SurfaceNormal = vec3(0.0,0.0,0.25);\n        }\n        \n        /***********************************************************/\n        \n        LightColor = vec3(.0,.0,.0);\n        \n        LightPosition[0] = vec3(iResolution.xy, Sphere_radius*3.0);\n        LightPosition[1] = vec3(screen_center.x + cos(iTime*0.92) * mov_radius,\n            screen_center.y - cos(iTime*1.011)* mov_radius,\n            Sphere_radius* 8.0 * cos(iTime*1.013));\n        LightPosition[2] = vec3(screen_center.x + sin(iTime*1.019) * mov_radius,\n            screen_center.y - sin(iTime*1.209) * mov_radius,\n            Sphere_radius* 4.0 * (1.0 + cos(iTime*1.007)));\n        \n        for (int i=0; i<3; i++) {\n            LightDirection = normalize(LightPosition[i] - SurfacePosition);\n            \n            /***********************************************************/\n            /* Diffuse Light                                           */\n            /***********************************************************/\n            \n            DiffuseLightIntensity = clamp(dot(LightDirection, SurfaceNormal),.0,1.0);\n            \n            /***********************************************************/\n            /* Specular Light                                          */\n            /***********************************************************/\n            \n            SpecularDirection = LightDirection - 2.0 * SurfaceNormal * dot(LightDirection, SurfaceNormal);\n            \n            SpecularLightIntensity = clamp(dot(ViewDirection, SpecularDirection),.0,1.0);\n            \n            SpecularLightIntensity *= SpecularLightIntensity*SpecularLightIntensity;\n            SpecularLightIntensity *= SpecularLightIntensity*SpecularLightIntensity;\n            SpecularLightIntensity *= SpecularLightIntensity*SpecularLightIntensity;\n            SpecularLightIntensity *= SpecularLightIntensity*SpecularLightIntensity;\n\n            LightColor += DiffuseLightColor[i] * DiffuseLightIntensity +\n            SpecularLightColor[i] * SpecularLightIntensity;\n            \n            AmbientLightIntensity += clamp(DiffuseLightIntensity,.0,.5);\n        }\n        \n        \n        /***********************************************************/\n        /* Ambient Light                                           */\n        /***********************************************************/\n\n        AmbientLightIntensity = 1.0 - AmbientLightIntensity;\n        \n        \n        /***********************************************************/\n        /* Lighting Finalizing                                     */\n        /***********************************************************/\n        \n        LightColor += AmbientLightIntensity*AmbientLightColor;\n        \n/*************************************************************************************************/\n        if (SurfacePosition.z > 0.0) {\n    fragColor =forCol2+ vec4(LightColor*backCol2,1.0);\n        } else fragColor = vec4(0.0,0.0,0.0,0.0);\n        /*} else {\n            SurfaceNormal = vec3(0.0,0.0,0.0);\n    fragColor = vec4(SurfaceNormal,0.0);\n        }*/\n    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MslyW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[308, 308, 342, 342, 437], [441, 441, 465, 465, 880], [904, 904, 941, 941, 1918], [1922, 1922, 1979, 1979, 10040]]}
{"id": "MslyWB", "name": "Simple spiral", "author": "nomadiclizard", "description": "The simplest spiral. Things can only get more complex from here by adding nonlinearity to the theta, r and iGlobalTime terms.", "tags": ["2d", "spiral"], "likes": 3, "viewed": 307, "published": "Public", "date": "1489760807", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.141592654;\nconst vec4 white = vec4(1.0);\nconst vec4 black = vec4(0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.yy;\n\tfloat r = length(uv);\n    float theta = atan(uv.y, uv.x);   \n    fragColor = fract(2.5 * theta / pi + 7.0 * pow(r, 0.4) - 2.5 * iTime) < 0.5 ? white : black;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MslyWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 148, 148, 376]]}
{"id": "MslyWl", "name": "Headache Experiment 4", "author": "aiekick", "description": "Headache Experiment 4", "tags": ["experiment", "headache", "4"], "likes": 1, "viewed": 435, "published": "Public API", "date": "1490401441", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nvec2 df(vec3 p)\n{\n    p.y -= sin(p.z*0.05)*4.;\n    float a = p.z * 0.01 * atan(p.x,p.y)/3.14159;\n    p.xy *= mat2(cos(a),-sin(a),sin(a),cos(a));\n\tp = mod(p,6.)-3.;\n    p += sin(p*3.)*1.2;\n    float cyl = min(min(length(p.xy),length(p.xz)),length(p.yz));\n\treturn vec2(cyl-0.4, 0);\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nfloat SubDensity(vec3 p, float ms) \n{\n\treturn df(p - nor(p,0.0001) * ms).x/ms;\n}\n\nvec2 shade(vec3 ro, vec3 rd, float d, vec3 lp, vec3 ldo, float li)\n{\n\tvec3 p = ro + rd * d;\n\tvec3 n = nor(p, 0.1);\n\tvec3 ldp = normalize(lp-n*1.5-p);\n\tvec3 refl = reflect(rd,n);\n\tfloat amb = 0.6;\n\tfloat diff = clamp( dot( n, ldp ), 0.0, 1.0);\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4.);\n\tfloat spe = pow(clamp( dot( refl, ldo ), 0.0, 1.0 ), 16.);\n\tfloat sss = 1. - SubDensity(p, 0.1);\n\treturn vec2(\n        (diff + fre + spe) * amb * li,\n        (diff + fre + sss) * amb * li + spe\n    );\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tfloat t = iTime * 15.;\n\n    vec3 ld = vec3(0.,1., .5);\n    \n\tvec3 ro = vec3(0,sin(t*0.05)*4.,t);\n\tvec3 cu = vec3(0,1,0);\n\tvec3 tg = ro + vec3(0,0,.1);\n\t\n\tfloat fov = .5;\n\tvec3 z = normalize(tg - ro);\n\tvec3 x = normalize(cross(cu, z));\n\tvec3 y = normalize(cross(z, x));\n\tvec3 rd = normalize(z + fov * (uv.x * x + uv.y * y));\n\t\n\tfloat s = 1., d = 1.;\n\tfloat dm = 50.;\n\t\n\tfor (float i=0.; i<250.; i++)\n\t{\n\t\tif (log(d*d/s/1e5)>0. || d>dm) break;\n\t\td += (s = df(ro + rd * d).x) * .3;\n\t}\n\t\n    fragColor.rgb = GetSky(rd, ld, vec3(1.5));\n    \n\tif (d<dm)\n\t{\n\t\tvec2 sh = shade(ro, rd, d, ro, ld, 1.);\n\t\tfragColor.rgb = mix( \n            vec3(.49,1,.32) * sh.y * .6 + vec3(.45,0,.72) * sh.x * 1.2, \n            fragColor.rgb, \n            1.0 - exp( -0.001*d*d ) ); \n\t}\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MslyWl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 214, 231, 231, 495], [497, 497, 529, 529, 707], [709, 771, 828, 828, 1116], [1118, 1118, 1155, 1155, 1198], [1200, 1200, 1268, 1268, 1701], [1703, 1703, 1757, 1757, 2579]]}
{"id": "Mslyzf", "name": "hypnotic tunnel", "author": "battlebottle", "description": "a simple tunnel", "tags": ["tunnel"], "likes": 7, "viewed": 645, "published": "Public API", "date": "1489249016", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tvec2 centre = iResolution.xy / 2.0;\n    \n    vec4 col = vec4(0.0,0.0,0.0,1.0);\n    \n    float steps = 16.0;\n    \n    for(float x = -(steps/2.0); x < (steps/2.0); x++){\n    \tfor(float y = -(steps/2.0); y < (steps/2.0); y++){\n    \t\tfloat dist = sqrt(sqrt((distance(fragCoord + vec2(x, y) / steps, centre))) * 100.0);\n    \t\tcol += floor(mod(dist - iTime * 3.0, 2.0));\n    \t}\n    }\n    \n    col /= steps * steps;\n        \n\tfragColor = col * (1.0 - (distance(fragCoord, centre) / iResolution.x));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mslyzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 599]]}
{"id": "MsscWX", "name": "Raymarching #3", "author": "djeof1", "description": "3rd example of raymarching by changing a few variables.", "tags": ["raymarching"], "likes": 2, "viewed": 83, "published": "Public", "date": "1490180675", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dist (vec3 d) {\n    vec3 e = fract(d) * 2.0 - 1.0;\n\treturn length(e) - 0.4;\n}\n\nfloat rayMarch(vec3 origin, vec3 ray) {\n    float t = 0.0;\n    for (int i = 0; i < 64; i++) {\n    \tvec3 p = origin + ray * 2.0 * t;\n        float d = dist(p);\n        t += d * 0.5;\n    }\n\treturn t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv.xy *= 6.0 * sin(iTime);\n    vec3 ray = normalize(vec3(uv,1.0));\n    vec3 origin = vec3(0.0, 0.0, iTime);\n    float march = rayMarch(origin, ray);\n    float fog = 1.0/(1.0 + march*march*0.1);\n    vec3 finalColor = vec3(fog/0.66, fog/0.33, fog/0.22);\n    fragColor = vec4(finalColor,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsscWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 83], [85, 85, 124, 124, 284], [285, 285, 342, 342, 743]]}
{"id": "Mssczf", "name": "RED FANG - No Air", "author": "nint22", "description": "Clone of the RED FANG music video for \"No Air\", found here: https://youtu.be/attb8PujeFc?t=568", "tags": ["redfangmusicvideo"], "likes": 0, "viewed": 90, "published": "Public", "date": "1489275071", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Goal: Clone the visual effect of RED FANG’s music video for No Air, found here: https://youtu.be/attb8PujeFc?t=568\n\n// Constants\nconst float kPI = 3.14159265359;\nconst vec4 kBackgroundColor = vec4( 0.58, 0.47, 0.27, 1.0 );\nconst float kTotalTime = 12.0;\n\n// Equilateral triangle \n// All triangles have these vertex positions relative to a center (0,0)\n// Note the dy: this shift up the triangle to the centroid, so rotations look much better\nconst float dy = 86.0 / 3.0;\nconst vec2 kVertA = vec2( -50.0, 0.0 - dy );\nconst vec2 kVertB = vec2( 50.0, 0.0 - dy );\nconst vec2 kVertC = vec2( 0.0, 100.0 * 0.5 * sqrt(3.0) - dy );\n\n// Rotate a given point\n// Build a 2x2 rotation matrix that you can apply to a vec2 for rotating a point about the origin\nmat2 GetRotationMatrix2D( float theta )\n{\n\t// Simple affine transform matrix\n    return mat2( cos( theta ),-sin( theta ),\n                 sin( theta ), cos( theta ) );\n}\n\n// Geometry functions based on distance-functions: \n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return 1.0 - clamp( length( pa - ba*h ) - r, 0.0, 1.0 );\n}\n\nfloat sdCapsuleAnimated( vec2 p, vec2 a, vec2 b, float r, float t )\n{\n    // Special rule: if t is zero, do nothing\n    if( t <= 0.0 )\n        return 0.0;\n    \n    // Compute moving dest, which is assumed 2nd arg\n    b = a + (b - a) * t;\n    \n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return 1.0 - clamp( length( pa - ba*h ) - r, 0.0, 1.0 );\n}\n\nfloat sdDashedCapsule( vec2 p, vec2 a, vec2 b, float r, float dashT )\n{\n    // Dash pattern\n    float dist = length( a - ((b - a) * dashT + p) );\n    if( mod( dist, 8.0 ) < 4.0 )\n        return 0.0;\n    \n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return 1.0 - clamp( length( pa - ba*h ) - r, 0.0, 1.0 );\n}\n\nfloat sdDashedCapsuleAnimated( vec2 p, vec2 a, vec2 b, float r, float t, float dashT )\n{\n    // Special rule: if t is zero, do nothing\n    if( t <= 0.0 )\n        return 0.0;\n    \n    // Dash pattern\n    float dist = length( a - ((b - a) * dashT + p) );\n    if( mod( dist + dashT, 8.0 ) < 4.0 )\n        return 0.0;\n    \n    // Compute moving dest, which is assumed 2nd arg\n    b = a + (b - a) * t;\n    \n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return 1.0 - clamp( length( pa - ba*h ) - r, 0.0, 1.0 );\n}\n\nfloat sdStrokeTriangle( vec2 p, vec2 a, vec2 b, vec2 c, float r )\n{\n    float total = 0.0;\n    \n    total += sdCapsule( p, a, b, r );\n    total += sdCapsule( p, b, c, r );\n    total += sdCapsule( p, c, a, r );\n    \n    return total;\n}\n\nfloat sdStrokeHexagon1( vec2 fragCoord, vec2 centerPoint )\n{\n    float total = 0.0;\n    \n    vec2 a = centerPoint + kVertA * 1.0;\n    vec2 b = centerPoint + kVertB * 1.0;\n    vec2 c = centerPoint + kVertC * 1.0;\n    \n    vec2 d = centerPoint + kVertA * vec2(1, -1);\n    vec2 e = centerPoint + kVertB * vec2(1, -1);\n    vec2 f = centerPoint + kVertC * vec2(1, -1);\n    \n    total += sdCapsule( fragCoord, b, f, 1.0 );\n    total += sdCapsule( fragCoord, f, a, 1.0 );\n    total += sdCapsule( fragCoord, a, d, 1.0 );\n    total += sdCapsule( fragCoord, d, c, 1.0 );\n    total += sdCapsule( fragCoord, c, e, 1.0 );\n    total += sdCapsule( fragCoord, e, b, 1.0 );\n    \n    return total;\n}\n\nfloat sdStrokeAnimatedTriangle( vec2 p, float thickness, vec2 trans, float scale, float theta, float t )\n{\n    float total = 0.0;\n    const float kFloatThirdTime = ( 1.0 / 3.0 );\n    \n    // Scale, rotate, and translate triangle\n    vec2 a = kVertA * scale * GetRotationMatrix2D( theta ) + trans;\n    vec2 b = kVertB * scale * GetRotationMatrix2D( theta ) + trans;\n    vec2 c = kVertC * scale * GetRotationMatrix2D( theta ) + trans;\n    \n    if( t < kFloatThirdTime  )\n    {\n        total += sdCapsuleAnimated( p, a, b, thickness, t / kFloatThirdTime );\n    }\n    else if( t < (2.0 * kFloatThirdTime) )\n    {\n        total += sdCapsule( p, a, b, thickness );\n        total += sdCapsuleAnimated( p, b, c, thickness, ( t - kFloatThirdTime ) / kFloatThirdTime );\n    }\n    else\n    {\n        total += sdCapsule( p, a, b, thickness );\n        total += sdCapsule( p, b, c, thickness );\n        total += sdCapsuleAnimated( p, c, a, thickness, ( t - 2.0 * kFloatThirdTime ) / kFloatThirdTime );\n    }\n    \n    return total;\n}\n\nfloat sdStrokeAnimatedDashedTriangle( vec2 p, float thickness, vec2 trans, float scale, float theta, float t )\n{\n    float total = 0.0;\n    const float kFloatThirdTime = ( 1.0 / 3.0 );\n    \n    float dashT = -iTime / 5.0;\n    \n    // Scale, rotate, and translate triangle\n    vec2 a = kVertA * scale * GetRotationMatrix2D( theta ) + trans;\n    vec2 b = kVertB * scale * GetRotationMatrix2D( theta ) + trans;\n    vec2 c = kVertC * scale * GetRotationMatrix2D( theta ) + trans;\n    \n    if( t < kFloatThirdTime  )\n    {\n        total += sdDashedCapsuleAnimated( p, a, b, thickness, t / kFloatThirdTime, dashT );\n    }\n    else if( t < (2.0 * kFloatThirdTime) )\n    {\n        total += sdDashedCapsule( p, a, b, thickness, dashT );\n        total += sdDashedCapsuleAnimated( p, b, c, thickness, ( t - kFloatThirdTime ) / kFloatThirdTime, dashT );\n    }\n    else\n    {\n        total += sdDashedCapsule( p, a, b, thickness, dashT );\n        total += sdDashedCapsule( p, b, c, thickness, dashT );\n        total += sdDashedCapsuleAnimated( p, c, a, thickness, ( t - 2.0 * kFloatThirdTime ) / kFloatThirdTime, dashT );\n    }\n    \n    return total;\n}\n\n\nfloat sdStrokeAnimatedHexagonl( vec2 p, float thickness, vec2 trans, float scale, float theta, float t )\n{\n    float total = 0.0;\n    \n    vec2 a = kVertA * scale * GetRotationMatrix2D( theta ) + trans;\n    vec2 b = kVertB * scale * GetRotationMatrix2D( theta ) + trans;\n    vec2 c = kVertC * scale * GetRotationMatrix2D( theta ) + trans;\n    \n    vec2 d = kVertA * vec2(1.0, -1.0) * scale * GetRotationMatrix2D( theta ) + trans;\n    vec2 e = kVertB * vec2(1.0, -1.0) * scale * GetRotationMatrix2D( theta ) + trans;\n    vec2 f = kVertC * vec2(1.0, -1.0) * scale * GetRotationMatrix2D( theta ) + trans;\n    \n    // Animation trick: take the normalized time, grow it by 6, then offset it\n    // based on which segment we're working on, then re-normalize\n    \n    total += sdCapsuleAnimated( p, b, f, 1.0, clamp( (t * 6.0 - 0.0), 0.0, 1.0 ) );\n    total += sdCapsuleAnimated( p, f, a, 1.0, clamp( (t * 6.0 - 1.0), 0.0, 1.0 ) );\n    total += sdCapsuleAnimated( p, a, d, 1.0, clamp( (t * 6.0 - 2.0), 0.0, 1.0 ) );\n    total += sdCapsuleAnimated( p, d, c, 1.0, clamp( (t * 6.0 - 3.0), 0.0, 1.0 ) );\n    total += sdCapsuleAnimated( p, c, e, 1.0, clamp( (t * 6.0 - 4.0), 0.0, 1.0 ) );\n    total += sdCapsuleAnimated( p, e, b, 1.0, clamp( (t * 6.0 - 5.0), 0.0, 1.0 ) );\n    \n    return total;\n}\n\n\n// Normalized time generation method: returns 0.0 until iTime hits the desired time interval, which then normalizes it to [0.0, 1.0]\n// Animation loops after the given max time\nfloat AnimationTime( float startTime, float endTime, float initialDelay, float repeatTime )\n{\n    // Mod based on desired repeat time\n    initialDelay = 0.0;\n    float t = mod( max( 0.0, iTime - initialDelay ), repeatTime );\n    return clamp( ( t - startTime ) / ( endTime - startTime ), 0.0, 1.0 );\n}\n\nfloat Triangle1( vec2 fragCoord, vec2 centerPoint )\n{\n    const float delay = 1.0;\n    \n    // 1 second delay, starts at about full-screen, zooms in until we start rotating..\n    float thicknessAnimation = 1.0 + 5.0 * ( 1.0 - AnimationTime( 0.0, 3.5, delay, kTotalTime ) );\n    float theta = -( 2.0 / 3.0 ) * kPI * sin( 0.5 * kPI * AnimationTime( 4.0, 4.8, delay, kTotalTime ) )\n            \t+ -( 2.0 / 3.0 ) * kPI * sin( 0.5 * kPI * AnimationTime( 7.0, 7.8, delay, kTotalTime ) );\n    float strokeAnimation = AnimationTime( 0.0, 3.5, delay, kTotalTime );\n    float scaleAnimation = 3.5 - sin( 0.5 * kPI * AnimationTime( 0.0, 3.5, delay, kTotalTime ) * 1.0 )\n            \t\t\t + 20.0 * sin( 0.5 * kPI * AnimationTime( 11.0, 14.0, 1.0, kTotalTime ) );\n\n    return sdStrokeAnimatedTriangle( fragCoord, thicknessAnimation, centerPoint, scaleAnimation, theta, strokeAnimation );\n}\n\nfloat Triangle2( vec2 fragCoord, vec2 centerPoint )\n{\n    const float delay = 1.0;\n    \n    float thicknessAnimation = 0.5;\n    float theta = kPI + -( 2.0 / 3.0 ) * kPI * sin( 0.5 * kPI * AnimationTime( 4.0, 4.8, delay, kTotalTime ) )\n        \t\t+ -( 2.0 / 3.0 ) * kPI * sin( 0.5 * kPI * AnimationTime( 7.0, 7.8, delay, kTotalTime ) );\n    float strokeAnimation = AnimationTime( 3.5, 4.5, delay, kTotalTime );\n    float scaleAnimation = 0.5 * ( 3.5 - sin( 0.5 * kPI * AnimationTime( 0.0, 3.5, delay, kTotalTime ) * 1.0 ) )\n        \t\t\t\t + 20.0 * sin( 0.5 * kPI * AnimationTime( 11.0, 14.0, 1.0, kTotalTime ) );\n\n    return sdStrokeAnimatedTriangle( fragCoord, thicknessAnimation, centerPoint, scaleAnimation, theta, strokeAnimation );\n}\n\nfloat Hexagonl1( vec2 fragCoord, vec2 centerPoint )\n{\n    const float delay = 1.0;\n    \n    float strokeAnimation = sin( 0.5 * kPI * AnimationTime( 5.0, 7.0, 1.0, kTotalTime ) );\n    float theta = -( 2.0 / 3.0 ) * kPI * sin( 0.5 * kPI * AnimationTime( 7.0, 7.8, delay, kTotalTime ) );\n    float scaleAnimation = 2.5\n        \t\t\t\t + 20.0 * sin( 0.5 * kPI * AnimationTime( 11.0, 14.0, 1.0, kTotalTime ) );\n\n    return sdStrokeAnimatedHexagonl( fragCoord, 1.0, centerPoint, scaleAnimation, theta, strokeAnimation );\n}\n\nfloat Triangle3( vec2 fragCoord, vec2 centerPoint )\n{\n    const float delay = 1.0;\n    \n    float thicknessAnimation = 0.5\n        \t\t\t\t\t + 2.0 * ( 0.5 + 0.5 * sin( iTime * 8.0 ) ) * sin( 0.5 * kPI * AnimationTime( 7.5, 10.0, 1.0, kTotalTime ) );\n    float theta = -( 2.0 / 3.0 ) * kPI * sin( 0.5 * kPI * AnimationTime( 7.0, 7.8, delay, kTotalTime ) );\n    float strokeAnimation = AnimationTime( 5.5, 7.0, delay, kTotalTime );\n    float scaleAnimation = 1.25\n        \t\t\t\t + 20.0 * sin( 0.5 * kPI * AnimationTime( 11.0, 14.0, 1.0, kTotalTime ) );\n    \n    return sdStrokeAnimatedDashedTriangle( fragCoord, thicknessAnimation, centerPoint, scaleAnimation, theta, strokeAnimation );\n}\n\nfloat Triangle4( vec2 fragCoord, vec2 centerPoint )\n{\n    const float delay = 1.0;\n    \n    float thicknessAnimation = 0.5\n        \t\t\t\t\t + 2.0 * ( 0.5 + 0.5 * sin( iTime * 8.0 + 4.0 ) ) * sin( 0.5 * kPI * AnimationTime( 7.5, 10.0, 1.0, kTotalTime ) );\n    float theta = kPI -( 2.0 / 3.0 ) * kPI * sin( 0.5 * kPI * AnimationTime( 7.0, 7.8, delay, kTotalTime ) );\n    float strokeAnimation = AnimationTime( 5.5, 7.0, delay, kTotalTime );\n    float scaleAnimation = 2.5\n        \t\t\t\t + 20.0 * sin( 0.5 * kPI * AnimationTime( 11.0, 14.0, 1.0, kTotalTime ) );\n    \n    return sdStrokeAnimatedDashedTriangle( fragCoord, thicknessAnimation, centerPoint, scaleAnimation, theta, strokeAnimation );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Compute visual center\n    vec2 centerPoint = iResolution.xy / 2.0;\n    \n    // Sum all the animated geometries\n    float color = 0.0;\n    color += Triangle1( fragCoord, centerPoint );\n    color += Triangle2( fragCoord, centerPoint );\n    color += Hexagonl1( fragCoord, centerPoint );\n    color += Triangle3( fragCoord, centerPoint );\n    color += Triangle4( fragCoord, centerPoint );\n    \n    // Apply final coloring rule: 0.0 means black, 1.0 means background color\n    fragColor = ( 1.0 - clamp( color, 0.0, 1.0 ) ) * kBackgroundColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mssczf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[629, 751, 792, 827, 921], [923, 1046, 1098, 1098, 1250], [1252, 1252, 1321, 1367, 1646], [1648, 1648, 1719, 1739, 2003], [2005, 2005, 2093, 2139, 2558], [2560, 2560, 2627, 2627, 2794], [2796, 2796, 2856, 2856, 3477], [3479, 3479, 3585, 3585, 4497], [4499, 4499, 4611, 4611, 5638], [5641, 5641, 5747, 5747, 6926], [6929, 7106, 7199, 7239, 7407], [7409, 7409, 7462, 7462, 8283], [8285, 8285, 8338, 8338, 9019], [9021, 9021, 9074, 9074, 9534], [9536, 9536, 9589, 9589, 10216], [10218, 10218, 10271, 10271, 10907], [10909, 10909, 10966, 10995, 11513]]}
{"id": "MsSczh", "name": "Cook-Torrance + Oren-Nayar - PBR", "author": "Karambit", "description": "Two simple procedural shapes implementing Phisically Based Rendering", "tags": ["procedural", "raymarching", "pbr", "cook", "torrance", "oren", "nayar"], "likes": 5, "viewed": 1398, "published": "Public API", "date": "1490815335", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat metallic = 1.0;\nfloat roughness = 0.1;\n\nconst float PI = 3.14159265359;\n\nfloat degToRad(float d) \n{\n    return d * PI / 180.0;\n}\n\nmat4 makeYRotation(in float angleInRadians) \n{\n  float c = cos(degToRad(angleInRadians));\n  float s = sin(degToRad(angleInRadians));\n  mat4 r;\n  r[0].xyzw = vec4(c, 0, -s, 0);\n  r[1].xyzw = vec4(0, 1, 0, 0);\n  r[2].xyzw = vec4(s, 0, c, 0);\n  r[3].xyzw = vec4(0, 0, 0, 1);\n\n  return r;\n}\n\nvec3 opTx( vec3 p, mat4 m )\n{\n    vec3 q = mat3(inverse(m))*p;\n    return q;\n}\n\nfloat sdSphere( vec3 p, float s)\n{\n\treturn length(p + vec3(0.0, 0.5, 0.0))-s;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p + vec3(0.0, 0.5, 0.0))-b,0.0))-r;\n}\n\nfloat smin( float a, float b )\n{\n\tfloat k = 0.1;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat map( in vec3 p)\n{\n\tfloat res = 0.0;\n\tfloat resSph = sdSphere(p, 3.0);\n\n\tvec3 q = opTx(p, makeYRotation(5.0 * iTime));\n\tfloat resCube = udRoundBox(q, vec3(2.0), 0.3);\n\n\tres = smin(resCube, resSph);\n    \n    vec2 M = ((iMouse.xy / iResolution.xy)*2.0-1.0)*6.0;\n    vec3 lp = vec3(M.x, M.y, 0.) - vec3(0., 0., -1.5);\n    \n    \n\tfloat sph = sdSphere(p-lp, 1.0);\n\n\treturn min(res, sph);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.002,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 10.0;\n\tfloat h          = 1.0;\n    float t          = 0.0;\n    for( int i=0; i<50; i++ )\n    {\n        if( h<0.001 || t>maxd ) break;\n\t    h = map( ro+rd*t);\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\t\n    return t;\n}\n\nfloat orenNayarDiffuse(\n  vec3 ld,\n  vec3 vd,\n  vec3 sn,\n  float r,\n  float a) {\n  \n  float LdotV = dot(ld, vd);\n  float NdotL = dot(ld, sn);\n  float NdotV = dot(sn, vd);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1., max(NdotL, NdotV), step(.0, s));\n\n  float sigma2 = r * r;\n  float A = 1. - .5 * (sigma2/((sigma2 + .33) + .000001));\n  float B = .45 * sigma2 / (sigma2 + .09) + .00001;\n    \n  float ga = dot(vd-sn*NdotV,sn-sn*NdotL);\n\n  return max(0., NdotL) * (A + B * max(0., ga) * sqrt((1.0-NdotV*NdotV)*(1.0-NdotL*NdotL)) / max(NdotL, NdotV));\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n  \n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n  \n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n  \n    return nom / denom;\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n  \n    return ggx1 * ggx2;\n}\nvec3 F;\nvec3 kS;\nvec3 kD;\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}  \n\nvec3 lighting(in vec3 n, in vec3 lp, in vec3 p)\n{\n\n\n    vec3 ld = normalize(lp - p);\n    vec3 vd = normalize(vec3(0., 0., 5.) - p);\n\tfloat diff = orenNayarDiffuse(ld, vd, n, roughness, 1.0);\n\n\n\tvec3 F0 = vec3(0.04);\n    F0      = mix(F0, vec3(1.0), metallic);\n\n    F = fresnelSchlickRoughness(max(dot(n, vd), 0.0), F0, roughness);\n    kS = F;\n    kD = vec3(1.0) - kS;\n    kD *= 1.0 - metallic;\n\n\tvec3 H = normalize(vd + ld);\n        float distance = length(lp - p);\n        float attenuation = 1.0/pow(distance, 2.0);\n        vec3 radiance     = vec3(1.0) * attenuation;        \n        \n        /* Cook-Torrance BRDF*/\n        float NDF = DistributionGGX(n, H, clamp(roughness, 0.03, 1.0));        \n        float G   = GeometrySmith(n, vd, ld, roughness);      \n        \n        vec3 nominator    = NDF * G * F;\n        float denominator = (4.0 * max(dot(vd, n), 0.0) * max(dot(ld, n), 0.0)) + 0.001; \n        vec3 brdf = nominator / denominator;\n                       \n        vec3 Lo = (kD * vec3(1.0) / PI + brdf) * radiance * diff; \n   \n        \n\treturn vec3(diff) + Lo;\n}\n\nfloat saturate(in float n) {\n\treturn clamp(n, 0., 1.);\n}\n\nfloat sss(in vec3 L, in vec3 N, in vec3 V, in vec3 P){\n    \n\tint iLPower = 2;\n    float fLTScale = 5.;\n    float fLTThickness = 0.5;\n    float fLTAmbient = 0.0;\n    float fLightAttenuation = 2.0 * 1.0/pow(length(P - L), 2.0);\n\n    vec3 vLTLight = normalize(L + N * 0.3);\n    float fLTDot = pow(saturate(dot(V, -vLTLight)), float(iLPower)) * fLTScale; \n    float fLT = fLightAttenuation * (fLTDot + fLTAmbient) * fLTThickness;\n    \n    return fLT;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q = uv * 2.0 - 1.0;\n\tq.x *= 16.0/9.0;\n\n\tvec3 ro = vec3(0.0, 0.0, 5.0 );\n    vec3 rd = normalize( vec3(q,-1.0) );\n\tvec3 col = vec3(0.0);\n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n    \tvec3 pos = ro+rd*t;\n        float d =  max(0.0, 5.0 - t)/2.0;\n        vec3 normal = calcNormal(pos);\n        vec2 M = ((iMouse.xy / iResolution.xy)*2.0-1.0)*6.0;\n        vec3 lp = vec3(M.x, M.y, 0.) - vec3(0., 0., -1);\n        vec3 L = pos - lp;\n        \n        vec3 light = vec3(lighting(normal, lp, pos));\n        \n        light += sss(L, normal, rd, pos) * vec3(0.7, 0.2, 0.1);\n        \n        col = light * vec3(0.2, 0.4, 0.9) + vec3(0.04);\n    }\n    \n    fragColor = vec4(col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsSczh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 107, 107, 136], [138, 138, 184, 184, 424], [426, 426, 455, 455, 504], [506, 506, 540, 540, 585], [587, 587, 632, 632, 694], [696, 696, 728, 728, 837], [839, 839, 862, 862, 1228], [1230, 1230, 1262, 1262, 1474], [1476, 1476, 1519, 1519, 1766], [1768, 1768, 1848, 1848, 2327], [2329, 2329, 2385, 2385, 2654], [2656, 2656, 2712, 2712, 2868], [2869, 2869, 2931, 2931, 3150], [3178, 3178, 3250, 3250, 3334], [3338, 3338, 3387, 3387, 4416], [4418, 4418, 4446, 4446, 4474], [4476, 4476, 4530, 4530, 4924], [4926, 4926, 4983, 4983, 5722]]}
{"id": "Mssczj", "name": "water ripples", "author": "t91", "description": "click in the center of viewport", "tags": ["waterripples"], "likes": 8, "viewed": 358, "published": "Public", "date": "1489010462", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3  v_cam_pos = vec3(0.0, 1.0, -6.0);\nvec3  v_cam_forward = vec3(0.0, 0.0, 1.0);\nvec3  v_cam_right = vec3(1.0, 0.0, 0.0);\nvec3  v_cam_up = vec3(0.0, 1.0, 0.0);\nvec3  v_sundir = normalize(vec3(0.0, 0.3, 1.0));\nfloat f_near = 2.3;\n\n#define FLOOR 999\n#define INFINITY 99999.0\n#define NUM_SRC 5\n\nvec3 ToRay(in vec2 fragCoord, in mat3 m)\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 invResolution = 1.0 / iResolution.xy;\n\tvec2 ndc = (fragCoord.xy * invResolution) * 2.0 - 1.0; \n\tvec3 ray = vec3(aspect * ndc.x, ndc.y, f_near);\n    \n\treturn m * normalize(ray);\n}\n\nfloat HeightAt(vec2 pos, int i)\n{\n    vec4 src[NUM_SRC];\n    src[0] = vec4(-20.0, 0.0, 10.0, 10.0);\n    src[1] = vec4(30.0, 0.0, 10.0, 10.0);\n    src[2] = vec4(0.0, -20.0, 10.0, 10.0);\n    src[3] = vec4(0.0, 40.0, 10.0, 10.0);\n    src[4] = vec4(10.0, 10.0, 15.0, 10.0);\n    \n    vec2 center = src[i].xy;\n    \n    float dist2center = 10.0 + distance(pos, center);\n    float attenuation = exp(-dist2center * 0.031);\n    \n    float strength = src[i].z * attenuation;\n    float freq = src[i].w;\n\n    float H =  sin( dist2center - (iTime * freq) ) * strength / dist2center;\n    \n    return H;\n}\n\nfloat HeightAt(vec2 pos)\n{\n    float sum = 0.0;\n    \n    for (int i = 0; i < NUM_SRC; ++i)\n    {\n        sum += HeightAt(pos, i);\n    }\n    \n    return sum;\n}\n\nfloat Scene(vec3 point, out int id)\n{\n    id = 0;\n    float distance = INFINITY;\n\n    float dist = point.y - HeightAt(point.xz);\n    \n\treturn dist;\n}\n\nvec4 March(vec3 start, vec3 ray, out int id)\n{   \n    float step = 0.0;\n    \n\tfor (int i = 0; i < 100; ++i)\n    {\n        start = start + (step * ray);\n        step = Scene( start, id );\n\n        if (step < 0.0005)\n        {\n            return vec4(start, float(i));\n        }  \n        \n        if (step > 30.0)\n        {\n        \tbreak;\n        }\n\n    }\n    \n    return vec4(0,0,0,-1);\n}\n\n\nfloat ShadowSample(vec3 pos)\n{\n    int id = -1;\n    float shadow = 1.0;\n    vec4 shadow_pos = March(pos + v_sundir * 80.0, -v_sundir, id);\n\n    if (shadow_pos.w < 0.0)\n        return 1.0;\n    \n    float distToShadowCaster = length(shadow_pos.xyz - pos.xyz);\n    \n    shadow = min(1.0, max(0.0, 1.0 - distToShadowCaster));\n    \n    \n    return shadow;\n}\n\nfloat Shadow(vec3 pos)\n{\n    return ShadowSample(pos);\n}\n\nvec3 Ambient()\n{\n\treturn vec3(1.0, 1.0, 1.0) * 0.3;\n}\n\nvec3 Diffuse(vec3 nrm)\n{\n\treturn dot(nrm, v_sundir) * vec3(1.0, 1.0, 1.0);\n}\n\nvec3 Opq(vec3 pos, int id)\n{\n\treturn vec3(1.0, 0.8, 0.3) * 2.0;\n}\n\nvec3 Reflection(vec3 ray, vec4 pos, vec3 nrm, int surface_id)\n{  \n    vec3 reflected = reflect(ray, nrm);\n    \n    int id = -1;\n    vec4 hit = March(pos.xyz + nrm*0.01, reflected, id);\n    \n    vec3 value = Opq(hit.xyz, id);\n    \n    if (hit.w < 0.0)\n    {\n        float sun = dot(reflected, v_sundir);\n        \n        vec3 a = vec3(0.0, 0.3, 1.0) * 2.0;\n        vec3 b = vec3(0.0, 0.3, 1.0) * 5.0;\n        \n\t\tvalue *= mix(a, b, 1.0 - sun);\n    }\n    \n    return value;\n}\n\nvec3 Fog(vec4 pos)\n{\n    if (pos.w < 0.0)\n        return vec3(0.0, 0.0, 0.0);\n    \n    float distance = length(pos.xyz - v_cam_pos);\n\n\treturn max(0.0, exp(-distance * 0.0014 )) * vec3(1.0, 1.0, 1.0);\n}\n\nvec3 Specular(vec3 pos, vec3 nrm)\n{\n    vec3 VertexToEye = normalize(v_cam_pos - pos);\n    vec3 LightReflect  = normalize(reflect(-v_sundir, nrm));\n    \n    float str = max(0.0, dot(VertexToEye, LightReflect));\n    \n\tvec3 spc = pow(str, 100.0) * vec3(1.0, 1.0, 1.0);\n    \n    return spc;\n}\n\nfloat AmbientOcclusion(vec4 pos)\n{\n\treturn (1.0-clamp(pow(pos.w / 100.0, 0.2), 0.0, 1.0));\n}\n\nmat3 CameraMatrix()\n{\n\tfloat radius = 30.0;\n    float param = iMouse.x * 0.6;//obalTime * 0.3;\n    \n    if (iMouse.z > 0.0)\n    {\n        v_cam_pos.x = 0.5 * iResolution.x - iMouse.x; //sin(param) * radius;\n    \tv_cam_pos.y = 20.0;//1.0 + iMouse.y * 0.01;\n    \tv_cam_pos.z = iMouse.y - 0.5 * iResolution.y;//cos(param) * radius;\n    }\n    else\n    {\n    \tv_cam_pos = vec3(0.0, 20.0, -50.0);\n    }\n    \n\n    v_cam_forward = vec3(0.0, -0.5, 1.0);//= -normalize(v_cam_pos);\n    v_cam_forward = normalize(v_cam_forward);\n\n    v_cam_right   = cross(v_cam_forward, v_cam_up);\n \n    mat3 m;\n    m[0] = v_cam_right;\n    m[1] = v_cam_up;\n    m[2] = v_cam_forward;\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tmat3 cam = CameraMatrix();\n\n    int id = -1;\n    \n    vec3 ray   = ToRay(fragCoord, cam);\n    vec4 pos   = March(v_cam_pos, ray, id);\n    \n    \n    \n    int id_alt = -1;\n    vec3 ray_A = ToRay(fragCoord + vec2(0.2, 0.0), cam);\n    vec3 ray_B = ToRay(fragCoord + vec2(0.0, 0.2), cam);\n    vec3 pos_A = March(v_cam_pos, ray_A, id_alt).xyz;\n    vec3 pos_B = March(v_cam_pos, ray_B, id_alt).xyz;\n    vec3 diff1 = normalize(pos.xyz - pos_A);\n    vec3 diff2 = normalize(pos.xyz - pos_B);\n    vec3 nrm = normalize(cross(diff1, diff2));\n\n    vec3  opq = Opq(pos.xyz, id);\n    vec3  rfl = Reflection(ray, pos, nrm, id);\n    vec3  spc = Specular(pos.xyz, nrm);\n    vec3  amb = Ambient();\n    vec3  dif = Diffuse(nrm);\n    vec3  fog = Fog(pos);\n    float shd = Shadow(pos.xyz);\n    \n    vec3 color;\n\n    color = (amb + dif * shd + (spc + rfl)) * opq;\n\n    color *= AmbientOcclusion(pos);\n    fragColor.xyz = color * fog;\n\n    //fragColor.xyz = opq.xyz;\n    fragColor.w = 1.0;  \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mssczj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[294, 294, 336, 336, 574], [576, 576, 609, 609, 1165], [1167, 1167, 1193, 1193, 1325], [1327, 1327, 1364, 1364, 1476], [1478, 1478, 1524, 1524, 1867], [1870, 1870, 1900, 1900, 2222], [2224, 2224, 2248, 2248, 2280], [2282, 2282, 2298, 2298, 2335], [2337, 2337, 2361, 2361, 2413], [2415, 2415, 2443, 2443, 2480], [2482, 2482, 2545, 2545, 2954], [2956, 2956, 2976, 2976, 3157], [3159, 3159, 3194, 3194, 3448], [3450, 3450, 3484, 3484, 3542], [3544, 3544, 3565, 3565, 4219], [4221, 4221, 4278, 4278, 5253]]}
{"id": "MssyDN", "name": "slow cathedrals", "author": "jes5199", "description": "I could just stare at this for a long time", "tags": ["2d", "aliasing"], "likes": 0, "viewed": 82, "published": "Public", "date": "1488596977", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float skip_ahead_seconds = 140.;\n    \n\tvec2 uv = ((skip_ahead_seconds + iTime / 200.0) / 1.0) * ((fragCoord.xy - (iResolution.xy / 2.0)) / iResolution.y);\n    \n    //uv = floor(uv * 2.);\n    float value = (uv.x * sign(uv.y) + uv.y * sign(uv.x)) * sin(uv.x) * sin(uv.y);\n    float color = sin(value) * 3.0;\n    color = color * sign(uv.x) * sign(uv.y); // revision 2\n\n    float low = abs(color);\n    float med = abs(color) - 1.0;\n    float high = abs(color) - 2.0;\n    if(color > 0.0) {\n\t  fragColor = vec4(med*2., high, high,1.0);\n    } else {\n      fragColor = vec4(high, high, med*2.,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MssyDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 660]]}
{"id": "MssyRB", "name": "my lemond bike frame", "author": "polyrhythm", "description": "getting used to modeling in SDF. any ideas on controlling the artifacting around the blends of the cylinders?\n\nflames welcome", "tags": ["bike"], "likes": 5, "viewed": 145, "published": "Public", "date": "1489107485", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define saturate(x) clamp(x, 0.0, 1.0)\n#define SUN_DIR normalize(vec3(0.75, 2.25, 0.75))\n#define GAMMA 2.2\n#define PI 3.14159265359\n\n// -----------------\n// domain distortion\n// -----------------\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// -----------------\n// obj combination\n// -----------------\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\n// -----------------\n// sdf\n// -----------------\nfloat sdCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat sdBoxCheap(vec3 p, vec3 b) {\n\treturn vmax(abs(p) - b);\n}\n\nfloat sdBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\n// -----------------\n// terrain\n// -----------------\nfloat f(vec2 p)\n{\n    return sin(p.x) * sin(p.y);\n}\n\nvec3 getTerrainNormal(vec3 p)\n{\n    vec3 n;\n    float eps = 0.02;\n    n.x = f(vec2(p.x - eps, p.z)) - f(vec2(p.x + eps, p.z));\n    n.y = 2.0 * eps;\n    n.z = f(vec2(p.x, p.z - eps)) - f(vec2(p.x, p.z + eps));\n    \n    return normalize(n);\n}\n\nfloat traceTerrain(vec3 ro, vec3 rd, out float resT)\n{\n    const float minT = 5.0;\n    const float maxT = 10.0;\n    float lh = 0.0;\n    float ly = 0.0;\n    float delta = 0.01;\n    for (float t = minT; t < maxT;) {\n        vec3 p = ro + rd * t;\n        float h = f(p.xz);\n        if (p.y < h) {\n         \tresT = t - delta * delta + (lh - ly) / (p.y - ly - h + lh);\n            return 1.0;\n        }\n        \n        delta = 0.01 * t;\n        t += delta;\n        lh = h;\n        ly = p.y;\n    }\n    \n    return 0.0;\n}\n\n// -----------------\n// scene\n// -----------------\nconst float SPHERE = 1.0;\nconst float GROUND = 2.0;\nconst float FRAME = 3.0;\nconst float WALL = 4.0;\n\nvec2 map(vec3 p)\n{\n    float d1 = p.y + 1.0;\n    \n    vec3 wP = p;\n    wP.x -= 1.6;\n    \n    // wall\n    vec3 wallP = wP;\n    wallP.y -= 0.5;\n    wallP.x += 2.0;\n    float wall = sdBox2Cheap(wallP.xy, vec2(0.1, 2.5));\n    \n    vec3 windowP = wP;\n    windowP.x += 2.3;\n    windowP.y -= 0.75;\n    windowP.z -= 0.1;\n    float window = sdBoxCheap(windowP, vec3(0.5, 0.8, 0.6));\n    \n    wall = max(-window, wall);\n    \n    \n    // position the frame\n    vec3 fP = p;\n    fP.y += 0.35;\n    pR(fP.xy, radians(13.0));\n    \n    // downtube\n    vec3 dtP = fP;\n    dtP.z += 0.1;\n    pR(dtP.yz, radians(-50.0));\n    float downtube = sdCylinder(dtP, 0.05, 0.9);\n    \n    // headtube\n    vec3 htP = fP;\n    htP.y -= 0.65;\n    htP.z += 0.825;\n    pR(htP.yz, radians(20.0));\n    float headtube = sdCylinder(htP, 0.065, 0.2);\n    \n    //toptube\n    vec3 ttP = fP;\n    pR(ttP.yz, radians(95.0));\n    ttP.z += 0.65;\n    ttP.y -= 0.0;\n    float toptube = sdCylinder(ttP, 0.05, 0.80);\n    \n    // seattube\n    vec3 stP = fP;\n    pR(stP.yz, radians(15.0));\n    stP.z -= 0.7;\n    stP.y -= 0.45;\n    float seattube = sdCylinder(stP, 0.05, 0.75);\n    \n    // seatstays\n    vec3 ssP = fP;\n    ssP.x = abs(ssP.x);\n    ssP.z -= 1.22;\n    ssP.x -= 0.1;\n    ssP.y -= 0.1;\n    pR(ssP.zy, radians(35.0));\n    pR(ssP.xy, radians(5.0));\n    float seatstays = sdCylinder(ssP, 0.015, 0.55);\n    \n    // chainstays\n    vec3 csP = fP;\n    csP.x = abs(csP.x);\n    csP.x -= 0.08;\n    csP.z -= 1.1;\n    csP.y += 0.445;\n    pR(csP.zy, radians(100.0));\n    pR(csP.xy, radians(8.0));\n    float chainstays = sdCylinder(csP, csP.y * 0.03 + 0.03, 0.45);\n    \n    float f1 = fOpUnionRound(downtube, seattube, 0.15);\n    float f2 = fOpUnionRound(f1, chainstays, 0.1);\n    float f3 = fOpUnionRound(f2, headtube, 0.05);\n    float f4 = fOpUnionRound(f3, seatstays, 0.05);\n    float frame = fOpUnionRound(f4, toptube, 0.05);\n    \n    vec2 result;\n    \n    result.x = min(frame, min(wall, d1));\n    result.y = FRAME;\n    if (result.x == d1) result.y = GROUND;\n    else if (result.x == wall) result.y = WALL;\n    \n    return result;\n}\n\nvec2 trace(vec3 ro, vec3 rd, out float resT, out vec3 pos)\n{\n    const float EPSILON = 0.002;\n    const float MAX_DIST = 100.0;\n    const int STEPS = 92;\n    float t = 0.0;\n    \n    for (int i = 0; i < STEPS; i++) {\n        pos = ro + rd * t;\n        vec2 d = map(pos);\n        \n        if (d.x < EPSILON) {\n            resT = d.x;\n            \n            return d;\n        }\n        \n        if (d.x > MAX_DIST) {\n            return vec2(-1.0);\n        }\n        \n        t += d.x * 0.7;\n    }\n    \n    return vec2(-1.0);\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float res = 1.0;\n    const float k = 18.0;\n \tfloat t;\n    const float mint = 0.01;\n    const float maxt = 30.0;\n    \n    for (t = mint; t < maxt;)\n    {\n     \tfloat h = map(ro + rd * t).x;\n        if (h < 0.0001) {\n         \treturn 0.0;   \n        }\n        \n        res = min(res, k * h / t);\n        \n        t += h;\n    }\n    \n    return res;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec3 n;\n    const vec3 eps = vec3(0.02, 0.0, 0.0);\n    n.x = map(p + eps.xyy).x - map(p - eps.xyy).x;\n    n.y = map(p + eps.yxy).x - map(p - eps.yxy).x;\n    n.z = map(p + eps.yyx).x - map(p - eps.yyx).x;\n    \n    return normalize(n);\n}\n\nvec3 renderTerrain(vec3 ro, vec3 rd)\n{\n    vec3 sky = vec3(0.1, 0.2, 0.3) + (ro.y * ro.y) * 0.2;\n \tfloat resT;\n    float t = traceTerrain(ro, rd, resT);\n    \n    if (t == 0.0) {\n        return sky;\n    }\n    \n    vec3 n = getTerrainNormal(ro + rd * resT);\n    \n    float incidence = saturate(dot(n, SUN_DIR));\n    vec3 Fd = vec3(0.1, 0.2, 0.3) * incidence;\n    \n    Fd = mix(Fd, vec3(sky), 1.0 - exp(-length(ro + rd * resT) * 0.5) * 3.0);\n    \n    return Fd;\n}           \n\nvec3 render(vec3 ro, vec3 rd, out vec3 pos)\n{\n    vec3 colour = vec3(0.7, 0.7, 0.9);\n    float resT;\n    vec2 t = trace(ro, rd, resT, pos);\n    vec3 volumetric = vec3(0.0);\n    \n    if (pos.x < -0.5) {\n        return renderTerrain(ro, rd);\n    }\n    \n    if (t.x <= 0.0) {\n    \treturn colour;\n    }\n    \n    vec3 diffuseColour;\n    vec3 n;\n    float shininess;\n    \n    if (t.y == GROUND) {\n        diffuseColour = vec3(0.3, 0.7, 0.2);\n        n = vec3(0.0, 1.0, 0.0) + texture(iChannel1, pos.xz * 0.3).xyz;\n    }\n    else if (t.y == FRAME) {\n     \tdiffuseColour = vec3(1.0);\n        n = getNormal(pos);;\n    }\n    else if (t.y == WALL) {\n        diffuseColour = vec3(0.05, 0.2, 0.1);\n        n = getNormal(pos);\n    }\n    \n    float LoV = saturate(dot(SUN_DIR, normalize(-pos)));\n    \n    // diffuse\n    float incidence = saturate(dot(SUN_DIR, n));\n    vec3 Fd = diffuseColour * incidence;\n    \n    if (incidence > 0.0) {\n     \tFd *= shadow(pos, SUN_DIR);   \n    }\n    \n    return Fd;\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 r = iResolution.xy;\n    vec2 m = vec2(0.0);\n    vec2 q = fragCoord.xy / r.xy;\n    vec2 uv = q * 2.0 - 1.0;\n    uv.x *= r.x / r.y;\n    if (iMouse.z > 0.0) {\n   \t    m += (2.0 * iMouse.xy - r.xy) / r.yy;\n    }\n \n    float dist = 2.5;\n    vec3 ro = vec3(dist * clamp(cos(iTime * 0.1 + 6.0 * m.x), 0.5, 1.0),\n                   clamp(1.0 + m.y * 4.0, 0.5, 2.0),\n                   dist * clamp(sin(iTime * 0.1 + 6.0 * m.x), 0.2, 0.25));\n        \n    vec3 target = vec3(0.0);\n    mat3 ca = setCamera(ro, target, 0.0);\n    vec3 rd = ca * normalize(vec3(uv.xy, 1.5));\n    \n    vec3 pos;\n    vec3 colour = render(ro, rd, pos);\n    \n    // indoor \"fog\"\n    if (pos.x > -0.5 || pos.y > 10.0 && pos.x > 1.0) {\n    \tcolour = mix(colour, vec3(0.0), 1.0 - exp(-length(pos)) * 0.5);\n    }\n    \n    // vignette\n    colour *= 0.5 + 0.8 * pow(8.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.25);\n    \n    // gamma correct\n    colour = pow(colour, vec3(1.0 / GAMMA));\n    \n\tfragColor = vec4(colour, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MssyRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 196, 228, 228, 270], [272, 272, 292, 292, 317], [319, 319, 339, 339, 374], [376, 437, 485, 485, 570], [572, 572, 627, 627, 713], [715, 764, 813, 813, 887], [889, 889, 923, 923, 951], [953, 953, 988, 988, 1014], [1016, 1069, 1086, 1086, 1120], [1122, 1122, 1153, 1153, 1362], [1364, 1364, 1418, 1418, 1879], [1881, 2034, 2052, 2052, 4114], [4116, 4116, 4176, 4176, 4641], [4643, 4643, 4675, 4675, 5027], [5029, 5029, 5053, 5053, 5293], [5295, 5295, 5333, 5333, 5755], [5768, 5768, 5813, 5813, 6755], [6757, 6757, 6801, 6801, 6978], [6981, 6981, 7036, 7036, 8029]]}
{"id": "MsSyzR", "name": "[ Famous curves ] - #6", "author": "Yrai", "description": "#6 - Conchoid", "tags": ["2d", "curve", "parametric", "conchoid"], "likes": 1, "viewed": 397, "published": "Public API", "date": "1490556984", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/*\n   Conchoid facts:\n  ----------------\n\t- (a) These curves are also called the conchoids of Nicomedes, after the Greek scholar Nicomedes.\n\t\t  Called conchoids because the shape of their outer branches resembles a conch shell.\n    - (b) All of these curves (except a = 0) have two branches. Both branches approach the vertical\n\t\t  asymptote x = a as x → a from the left or right.\n    - (c) If a < −1, both branches are smooth. When a reaches −1, the right branch acquires a\n\t\t  sharp point, called a cusp.\n    - (d) For −1 < a < 0, the cusp turns into a loop, which becomes large as a → 0\n    - (e) If a = 0, both branches come together and form a circle.\n    - (f) For 0 < a < 1, the left branch has a loop, which shrinks to a cusp when a = 1. For a > 1,\n          the branches become smooth again.\n*/\n\n#define res_            iResolution\n#define time_           iTime\n#define trace_len_      64\n#define eps_            1.\n\nvec2  domain(vec2 uv, float s);\nvec2  parametric(float t);\nfloat trace(vec2 p, float t);\n\nvoid mainImage(out vec4 o, vec2 f) {\n\tvec2 p = domain(f, 8.);\n    \n    // t -> [0., 5.]\n    float t = time_*2.;\n    \n    // Conchoid traces\n    float dtrace = smoothstep(0.08, 0.001, trace(p, t));\n    float dtrace_s0 = smoothstep(0.16, 0.001, trace(p, t));\n    \n    // Axis\n    float ax = min(\n        smoothstep(0., 0.2, abs(p.x)),\n        smoothstep(0., 0.2, abs(p.y))\n    );\n    // Origin\n    float org = smoothstep(0.09, 0., length(p)-.01);\n    \n    // Palette \n    vec3 gray   = vec3(.2);\n    vec3 white  = vec3(5.);\n    \n    // Shading\n    vec3 c  = vec3(0.);\n    c = mix(c, gray, 1.-ax);\n    c = mix(c, white, org);\n    \n    c = mix(c, vec3(1., 11.0, 0.), dtrace_s0);\n    c = mix(c, white, dtrace);\n    //c.b += dtrace_s0/p.x;\n    c = mix(c, vec3(.1, .02, .1), p.x-dtrace);\n        \n    o = vec4(sqrt(c), 1.);\n}\n\nvec2 parametric(float t) {\n\tfloat a = sin(time_*.2)*4.;\n    return vec2(a + cos(t), a*tan(t) + sin(t));\n}\n\nfloat trace(vec2 p, float t) {\n    float d = 1e10;\n    float e = 0.;\n    for(int i = 0; i < trace_len_; i++) {\n    \td  = min(d, distance(p, parametric(t-e)));\n        e += eps_; \n    }\n    return d;\n}\n\nvec2 domain(vec2 uv, float s) {\n    return (2. * uv.xy - res_.xy) / res_.y * s;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsSyzR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[89, 1115, 1151, 1151, 1933], [1935, 1935, 1961, 1961, 2040], [2042, 2042, 2072, 2072, 2242], [2244, 2244, 2275, 2275, 2325]]}
{"id": "MsXcWS", "name": "UV-Distortion-FX", "author": "JavasCrypt20", "description": "This shows the function to manipulate the uv-coordinates of the renderwindow by subtrating another animated pattern that is divided by some amount like a dampening control you could put this in chain to to have more interesting.", "tags": ["fx", "coordinates", "uvediting"], "likes": 4, "viewed": 176, "published": "Public", "date": "1489602432", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float norsin ( float inA ){\n\treturn 0.5 + 0.5 * sin ( inA );\n}\nfloat GRAD ( float inUv, float repeat, float align ){\n\treturn norsin( ( inUv + align ) * pow( repeat, 2.0 ) );\n}\nfloat movingPoints ( float uvx, float uvy, float velX, float velY, float repeat ){\n\treturn GRAD( uvx, repeat, iTime * velX ) *  GRAD( uvy, repeat, iTime * velY );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float a = 0.25;\n    float b = 0.75;\n    float c = 1.5;\n    float d = 8.0;\n    float uvx = uv.x;\n    float uvy = uv.y;\n    float uvxc = uvx * ( iResolution.x / iResolution.y );\n    \n    float grad1 = GRAD ( -uvy + iTime * 1.0, 1.5, -0.5 ) + 0.3;\n    uvxc = uvx * ( iResolution.x/ iResolution.y );\n    float uv1 = GRAD (uvxc + GRAD ( uvy / 4.0 + iTime / 4.0, 1.0, 0.0) * 5.0 , 2.5, 0.0);\n    float r = movingPoints( uvxc-uv1/18.0, uvy+uv1/18.0, 0.0, -0.1, 6.0 );\n    r = min ( 0.3, r );\n    r *= 3.0;\n\tr = min ( 0.9, r );\n    uv1 *= 1.5;\n    uv1 = pow ( uv1, 0.8 );\n    grad1 *= uv1;\n    r *= grad1*0.6;\n\tfragColor = vec4(pow(r,2.5),pow(r,1.7),pow(r,0.9), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsXcWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 62], [63, 63, 116, 116, 175], [176, 176, 258, 258, 340], [343, 343, 400, 400, 1109]]}
{"id": "MsXczS", "name": "Zebra Rorschach", "author": "lherm", "description": "Kind of a failed experiment", "tags": ["raymarch", "2tweets"], "likes": 1, "viewed": 501, "published": "Public API", "date": "1488656842", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, in vec2 w )\n{\n    O-=O;\n    vec2 R = iResolution.xy;\n\tvec3 p = vec3((w+w-R.xy)/R.y, .5), z=normalize(p);\n    for (float i = 1.; i > 0.; i-=.01)\n    {\n        float T = iTime,\n              x = length(cos(p)-cos(p.z-T)*sin(p.y-T))-1.;     \n        O=i*i-O;\n        if (x < .005) break;\n        p += z * i;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsXczS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 340]]}
{"id": "Mt2SWW", "name": "Peter's Purple Plasma", "author": "spluko", "description": "It's purple and it's plasma.", "tags": ["plasma"], "likes": 6, "viewed": 208, "published": "Public", "date": "1489003288", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = 3.1416;\n\nvoid mainImage( out vec4 col, in vec2 coo )\n{\n\tvec2 uv = (coo.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec2 p = vec2(sin(iTime / 3.1), cos(iTime / 3.1));\n    float v = (\n        sin(length(uv - p) * 20.0) + \n        sin(iTime + 10.0 * (uv.x + uv.y)) + \n        sin(iTime / 4.0 + uv.x*6.0*pi) + \n        sin(iTime / 2.8 + uv.y*4.0*pi) + \n        4.0) / 8.0;\n    float i = pow(cos(3.5 * pi * (v + iTime / 10.0)) + 1.0, 10.0) / 1000.0;\n    vec3 c = mix(vec3(0.0), vec3(0.6,0.0,1.0), i);\n\tcol = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2SWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 65, 65, 532]]}
{"id": "MtKGWh", "name": "Radial Grid", "author": "fscur", "description": "Simple radial grid", "tags": ["radialgrid"], "likes": 9, "viewed": 884, "published": "Public API", "date": "1489120432", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = 3.14159265;\nfloat oneDegreeInRadian = 0.01745329251;\n\nvec2 toPolar(vec2 c)\n{   \n \treturn vec2(length(c), atan(-c.y, -c.x) + pi);   \n}\n\nfloat lineSegDist( vec2 uv, vec2 ba, vec2 a, float r )\n{\n    vec2 pa = uv - a - ba*r; ba = -ba*r*2.0;\n    return length( pa - ba*clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 ) );\n}\n\nfloat round_(float value)\n{\n\tif (fract(value) < 0.5)\n        return floor(value);\n    else \n        return ceil(value);\n}\n\nfloat addRadii2(vec2 uv)\n{\n\tvec2 polarUv = toPolar(uv);\n    float theta = polarUv.y; // [0, 2.0 * pi]\n    float d = 45.0;\n    float alpha = d * oneDegreeInRadian;\n    float edge = round(theta/alpha);\n    \n    //float angle = edge/(360.0/d);\n    float angle = edge/(360.0/d) * 2.0 * pi;\n    \n    vec2 end = vec2(cos(angle), sin(angle));\n    \n    float line = lineSegDist(uv, end, vec2(0.0), 2.0);\n    \n    float r = 1.0-smoothstep(0.005, 0.0055, line);\n    \n    return r;\n}\n\nfloat addRadii(vec2 uv)\n{\n    vec2 polarUv = toPolar(uv);\n    float theta = polarUv.y; // [0, 2.0 * pi]\n    float d = 90.0;\n    float alpha = d * oneDegreeInRadian;\n    float edge = floor(theta/alpha);\n    \n    return mod(edge, 2.0) == 0.0 ? 0.0 : 1.0;\n}\n\nfloat addCircles(vec2 uv)\n{\n    float diff = length(uv);\n\tfloat scale = 5.0;\n    float func = exp(-abs(sin(scale * pi * diff)));\n    return smoothstep(0.9, 0.95, func);\n}\n\nfloat addCircle(vec2 uv, float scale)\n{\n    return 0.0;\n}\n\nfloat addCurrentAngle(vec2 uv, float angle)\n{\n\tvec2 rotatedPolarPos0 = toPolar(uv);\n    float detectionEdgeDist0 = (mod(-rotatedPolarPos0.y, 2.0 * pi) - angle) / pi;\n    float currentAngle = smoothstep(0.0, 0.001, detectionEdgeDist0);\n    \n    float diff = length(uv);\n    float func = exp(-abs(sin(3.9269908169872415480783042290994 * diff)));\n    float circle = smoothstep(0.98, 0.99, func);\n    \n    float t = pi * iTime;\n    vec2 end = vec2(cos(-angle), sin(-angle));\n    float line = 1.0-smoothstep(0.010, 0.015, lineSegDist(uv - end, end, vec2(0.0), 1.0));\n    \n    return currentAngle * (1.0 + circle + line);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n    \n    float t = iTime;\n    float dist = length(uv);\n    vec3 color = vec3(0.0);\n    \n    float r = (1.0 - smoothstep(0.0, 1.0, dist));\n    \n    //float currentAngle = addCurrentAngle(uv, (2.0 * abs(cos(t)) * pi));\n    //color += vec3(1.0, 0.0, 0.0) * addCircle(uv, 1.0) * currentAngle * (1.0 - smoothstep(1.1, 1.11, dist));\n    \n    color += vec3(1.0, 0.0, 0.0) * addCircles(uv) * r;\n    color += vec3(0.4, 0.0, 0.0) * addCurrentAngle(uv, (2.0 * abs(cos(t)) * pi)) * (1.0 - smoothstep(0.0, 1.5, dist));\n    color += vec3(0.5, 0.0, 0.0) * addRadii(uv) * r;\n    \n    color += vec3(1.0, 0.0, 0.0) * addRadii2(uv) * (1.0 - smoothstep(0.8, 0.9, dist));\n    \n    //vec3 color = vec3(0.0, 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKGWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 87, 87, 144], [146, 146, 202, 202, 320], [322, 322, 349, 349, 443], [445, 445, 471, 471, 917], [919, 919, 944, 944, 1173], [1175, 1175, 1202, 1202, 1345], [1347, 1347, 1386, 1386, 1404], [1406, 1406, 1451, 1451, 2023], [2025, 2025, 2082, 2082, 2943]]}
{"id": "MttSzS", "name": "Distance Kaleido", "author": "Casheera", "description": "distance kaleido", "tags": ["2d", "distancekaleido"], "likes": 2, "viewed": 88, "published": "Public", "date": "1489745271", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM 6 //Number of centers\nvec2[NUM] c;\n\nvoid moveCenters()\n{\n    for(int i=0; i<NUM; i++)\n    {\n     float fi = 2.0*3.14*(float(i)+0.02*iTime)/float(NUM);\n     c[i]= vec2(0.5*sin(fi), 0.5*cos(fi));\n    }\n}\n\nfloat avgDistance(vec2 uv)\n{\n \tfloat d = 0.0;\n    float k = 100.0+10.0*sin(iTime/5.0);\n    for(int i=0; i<NUM; i++)    \n     \td+= sin(k*distance(uv,c[i])); \n    return d/float(NUM);  \n}\n\nvec4 distToColor(float d)\n{\n    return vec4(0.65,1.0-sin(d*12.0),1.0-cos(d*13.0),1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    moveCenters();\n\tfragColor = distToColor(avgDistance(uv));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MttSzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 68, 68, 213], [215, 215, 243, 243, 400], [402, 402, 429, 429, 490], [492, 492, 549, 549, 681]]}
{"id": "MtyGRz", "name": "Polyhedra", "author": "OctopusX", "description": "  ", "tags": ["raymarch", "polyhedra"], "likes": 29, "viewed": 436, "published": "Public", "date": "1488703826", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//global animation speed\n#define animSpeed 1.0\n\n//alternative Z fold anim\n//#define advFold\n\n#define Phi (0.5*(1.+sqrt(5.0)))\nvec3 n1 = normalize(vec3(-Phi,Phi-1.0,1.0));\nvec3 n2 = normalize(vec3(1.0,-Phi,Phi+1.0));\nvec3 n3 = normalize(vec3(0.0,0.0,-1.0));\nmat4 m;\n\n\n\n//std matrix ------------------\n\nmat4 rotationMatrix(vec3 v, float angle)\n{\n   float c = cos(radians(angle));\n   float s = sin(radians(angle));\n   \n   return mat4(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y, 0.0,\n      (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x, 0.0,\n      (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z, 0.0,\n      0.0, 0.0, 0.0, 1.0);\n}\nmat4 translate(vec3 v) {\n   return mat4(1.0,0.0,0.0,0.0,\n      0.0,1.0,0.0,0.0,\n      0.0,0.0,1.0,0.0,\n      v.x,v.y,v.z,1.0);\n}\nmat4 scale4(float s) {\n   return mat4(s,0.0,0.0,0.0,\n      0.0,s,0.0,0.0,\n      0.0,0.0,s,0.0,\n      0.0,0.0,0.0,1.0);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//sdf --------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat polyhedra(vec3 z)\n{\n    const int steps = 2;\n    \n    //timespeed\n    float ts = iTime *animSpeed;\n    float a = 0.3, a2 = 0.6;\n    \n    float scale = 2.0;\n    float size = 0.66;\n    \n    float ang1 = sin(ts *0.01)*120.0;\n    float ang2 = 64.0;\n        \n    vec3 rot1;\n    rot1.x = sin(ts)*a;\n    rot1.z = cos(ts)*a;\n    rot1.y = sin(0.5 +ts *0.25)*a;\n    \n    vec3 rot2;\n    rot2.x = sin(ts *0.25) *a2;\n    rot2.z = cos(ts *0.5) *a2;\n    rot2.y = sin(0.5 +ts *0.15)*a2;\n\n    \n    vec3 offset;\n    \n    offset.x = sin(ts *2.0) *0.1;\n    offset.z = cos(ts *1.9) *0.1;\n    offset.y = sin(0.5 +ts *1.8)*0.1;\n    \n    vec3 plNormal = normalize(vec3(1.0,-0.1, 0.55));\n    \n    mat4 fracRotation2 = rotationMatrix(normalize(rot2), ang1);\n    mat4 fracRotation1 = rotationMatrix(normalize(rot1), ang2);\n    m =  fracRotation2 * translate(offset) * scale4(scale)\n        \t\t\t   * translate(-offset) * fracRotation1;\n    \n    float s=1.0;\n    float t;\n    \n    //folds\n    float dmin = -10000.0; \n    for(int i=0; i<steps; i++)\n    {\n      \tz = abs(z);\n      \tt=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n      \tt=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n      \tz = abs(z);\n      \tt=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n        t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n      \tz = abs(z);\n        \n      \t//combine\n      \tdmin=max(dmin, s*dot(z-vec3(size,0.0,0.0),plNormal));\n      \tz = (m*vec4(z,1.0)).xyz;  s /= scale;\n        \n        float saw = mod(z.y,0.2);\n        z.y = mix(z.y, saw, sin(ts));\n   \t}\n    \n    #ifdef advFold\n    \tz.x = mod(z.z,1.5);\n    #endif\n    \n    return dmin;\n}\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2 (polyhedra(pos),2.5) *0.9;\n\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    \n    //raymarch\n    for (int i=0; i<50; i++)\n    {\n\t    vec2 res = map( ro +rd*t );\n        if (res.x < precis || t > tmax) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if (t > tmax) m = -1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    //bg\n    vec3 col = vec3(0.12, 0.2, 0.25)*0.35 +rd.y*0.1;\n    \n    //march\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    \n    \n    if (m > -0.5)\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        col = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t//col = vec3(0.15,0.15,0.15);\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n        \n        float base = (1.0-amb) + (1.0-fre);\n        float g = pow(base,0.2);\n        g = clamp(g,0.1,1.0);\n        vec3 glow = vec3(0.5-g, 0.99-g, 1.0-g)*1.0;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n        col += glow;\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime *5.0;\n\n\t// camera\n    float sh = 2.5;\n\tvec3 ro = vec3( sh*cos(0.1*time + 6.0*mo.x), 2.0*mo.y, sh*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3(0.0, 0.0, 0.0);//vec3( -0.5, -0.4, 0.5 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n    //gamma\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [{"id": "MdBGDV", "previewfilepath": "https://soundcloud.com/alessandro-ito/the-crystal-method-keep-hope", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/alessandro-ito/the-crystal-method-keep-hope", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtyGRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[269, 302, 344, 344, 766], [767, 767, 791, 791, 895], [896, 896, 918, 918, 1016], [1018, 1054, 1095, 1095, 1188], [1190, 1224, 1249, 1249, 1264], [1266, 1266, 1301, 1301, 1327], [1329, 1329, 1354, 1354, 2911], [2913, 2987, 3012, 3012, 3078], [3080, 3080, 3120, 3120, 3461], [3464, 3464, 3538, 3538, 3799], [3801, 3801, 3833, 3833, 4054], [4056, 4056, 4098, 4098, 4397], [4400, 4400, 4439, 4449, 6245], [6247, 6247, 6299, 6299, 6476], [6478, 6478, 6535, 6535, 7168]]}
{"id": "XdfcDB", "name": "E360 star SIRIUS", "author": "zproxy", "description": "https://www.shadertoy.com/view/XdXcDB", "tags": ["360"], "likes": 1, "viewed": 81, "published": "Public", "date": "1489591440", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define xWebGLTexture360height iResolution.y \n#define xWebGLTexture360height iResolution.y\n\n\n#define uIPD 0.0\n    \n\n// Created by SHAU - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define EPS 0.001\n#define FAR 50.0 \n#define PI 3.1415\n#define IGT iTime\n\nfloat rand1(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat audio_freq(in sampler2D channel, in float f) {return texture(channel, vec2(f, 0.25)).x;}\nvec3 sound = vec3(0.0);\n\nstruct DistInfo {\n    float d;\n    vec3 lc;\n};\n    \nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\n//http://mercury.sexy/hg_sdf/\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0 * PI / repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a / angle);\n\ta = mod(a,angle) - angle / 2.0;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions / 2.0)) c = abs(c);\n\treturn c;\n}\n\n//modified version of IQs box distance function \n//bc: box center; w: box width\nfloat sdSpikeBox(vec3 rp, vec3 bc, float w) {\n    vec3 b = vec3(w) + length(rp - bc) * 0.5;\n    vec3 d = abs(rp - bc) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));;\n}\n\nfloat dfScene(vec3 rp) {\n    \n    // up to down\n    rp.yz *= rot(IGT * 0.0125);\n    //pModPolar(rp.yz, 5.0);\n    \n    // left to right\n    rp.xy *= rot(IGT * 0.0125);\n    //pModPolar(rp.yx, 16.);\n    return sdSpikeBox(rp,  \n                      \n                      vec3(\n                          0.0, \n                          0.2 , \n                          0.0), \n                      \n                      0.0000);\n}\n\n// Used for Fade effect\nfloat mapTo(float x, float minX, float maxX, float minY, float maxY) {\n    float a = (maxY - minY) / (maxX - minX);\n    float b = minY - a * minX;\n    return a * x + b;\n}\n\n//Shane - hue rotation. I think I'vereturn sdSpikeBox(rp,  vec3(0.0, 1.5 + smoothstep(0., 1., sound.w), 0.0), w); used this in pretty much all of my shaders so far :)\nvec3 rotHue(vec3 p, float a){\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n    return clamp(p*hr, 0., 1.);\n}\n\nfloat raytraceFloor(vec3 ro, vec3 rd, vec3 n, vec3 o) {\n\treturn dot(o - ro, n) / dot(rd, n);\n}\n\n\n\n\n\nDistInfo marchScene(vec3 ro, vec3 rd) {\n    \n    DistInfo di = DistInfo(0., vec3(0.));\n    vec3 rp = vec3(0.0); //ray position\n    \n    for (int i = 0; i < 65; i++) {\n        rp = ro + rd * di.d;\n        float ns = dfScene(rp);\n        di.d += ns;\n        if (ns < EPS || di.d > FAR) break;\n        vec3 col = abs(rp);\n        di.lc += 0.0001 / (ns * ns) * col; //distance field light contribution\n    }\n    return di;\n}\n\n\n\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n \n \n//From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\n//Very happy with this star function, cheap and smooth\nvec3 stars(in vec3 p)\n{\n    // 47fps\n    \n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.5; // too small  and they will flicker\n    \n    // more stars?\n\tfor (float i=0.;i<1.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.7;\n}\n\nvec3 startrails(in vec3 rd)\n{\n    // do not move. we got a blinking star we would need to move too. \n    vec3 col0 = stars( normalize(rotx(rd, iTime * 0.00)));\n\n    vec3 col = col0;\n\n    // our blinky star is fixed via ro? we dont know how to rotate it all in sync yet.\n    \n    if (false)\n    for (int i = -30; i < 0; i++)\n    {\n    \tvec3 col1 = stars( normalize(rotx(rd, iTime * 0.01 + (float(i) * (1./600.) ))));\n        \n    \tcol += col1;    \n    }\n    \n    return col;\n}\n\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1. - c;\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n \n\n\n//void mainImage2(out vec4 fragColor, in vec2 fragCoord)\nvoid mainImage2( out vec4 fragColor, in vec2 fragCoord, vec2 thetaphi, vec3 rd, float IPD )\n {\n    \n    vec3 pc = vec3(0.); //pixel colour\n\n    for (int i = 0; i < 10; i++) {\n        if (i < 3) {\n            sound.x += audio_freq(iChannel0, float(i));    \n        } else if (i < 7) {\n            sound.y += audio_freq(iChannel0, float(i));    \n        } else {\n            sound.z += audio_freq(iChannel0, float(i));    \n        }\n    }\n    \n   ////coordinate system\n   //vec2 uv = fragCoord.xy / iResolution.xy;\n   //uv = uv * 2.0 - 1.0;\n   //uv.x *= iResolution.x / iResolution.y;\n   //\n   ////camera\n   //vec3 rd = normalize(vec3(uv, 2.));\n    \n    \n    \n    \n    \n    \n    float mousex = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n\n    \n    float mousey = (2.0*iMouse.y-iResolution.y) / iResolution.y;\n   \n    \n    \n    \n  //     \n  //  if (abs(mousey) < 1.0)\n  //  \trd *=  rotationMatrix(vec3(1., 0., 0.), radians(16. * mousey));\n  //  \n  //  // allow limited interacton\n  //  rd *=  rotationMatrix(vec3(0., 1., 0.), radians(0. + 2. * 16. * -mousex));\n//\n  //  \n  //  // looks good for 2D viewport\n  //  rd *=  rotationMatrix(vec3(0., 0., 1.), radians(float(iFrame) * 0.1  ));\n  //  //rd *=  rotationMatrix(vec3(0., 0., 1.), radians(float(iFrame) * 0.1  ));\n \n    //rd *=  rotationMatrix(vec3(0., 1., 0.), radians(-270. * -mousex));\n    \n    \n    \n    \n    //vec3 ro = vec3(0.0, 1.0, -0.5);\n    \n    // now its small .\n    //vec3 ro = vec3(0.0, 0.0, -3.0);\n\n    // start top right, and have it all slowly rotate\n    vec3 ro = vec3(-0.5, -0.0, -2.0);\n    // neg x looses color?\n\n    \n    //rotate camera\n    //ro.xy *= rot(sin(IGT) * 0.25);\n    //rd.xy *= rot(sin(IGT) * 0.25); \n    //ro.xz *= rot(IGT);\n    //rd.xz *= rot(IGT);    \n    //ro.yz *= rot(sin(IGT) * 0.125);\n    //rd.yz *= rot(sin(IGT) * 0.125); \n\t//\n    //raytace floor \n    vec3 fn = vec3(0, 1, 0); //floor normal\n\t//float fd = raytraceFloor(ro, rd, fn, vec3(0, -10.0, 0)); //floor distance\n\n    DistInfo di = marchScene(ro, rd);\n    \n    \n       \n    pc += startrails( rd);\n    \n    // 20fps / \n   \n    //if (false)\n    //if (fd > 0.0 && fd < FAR) {\n    //    //disco floor\n    //    vec3 rp = ro + rd * fd; //ray surface intersection\n    //    rp.x += IGT * 0.; //moving checkerboard\n    //    vec2 m  = mod(rp.xz, 4.0) - 2.0;\n    //    vec3 sc = \n    //        m.x * m.y > 0. ? rotHue(vec3(1., 0., 0.), mod(IGT / 16., 6.283)) : vec3(0., 0., 0.);      \n    //    sc *= clamp(pow(sound.z, 2.) * 2., 0.3, 3.0);\n    //    pc += sc / length((m * m) - 1.); \n    //    //fade\n    //\tfloat z = mapTo(fd, 0.0, FAR, 1.0, 0.0);\n    //    //pc = mix(vec3(0.), pc, z * z);\n    //}\n   //\n    //sparkly thing\n    \n    //pc += di.lc;\n    //pc += rotHue(di.lc, mod(IGT / 0.01, 6.283));\n    pc += rotHue(di.lc, mod(IGT / 0.001, 6.283));\n    \n   // //pixel effect from Virgil\n   // float klang1 = sound.z;\n   // vec2 uv2 = -0.3 + 2.0 * fragCoord.xy / iResolution.xy;\n   // pc -= 0.020 * (1.0 -klang1) * rand1(uv2.xy * IGT);\t\t\t\t\t\n   // vec2 g =  .9 + .2 * (1.-klang1) * sin(10.* IGT + uv2 * iResolution.xy);\n   // pc *= g.x * g.y; \n   // \n    fragColor = vec4(pc, 1.0);\n}\n\n\n\nfloat xstars(in vec3 p)\n{\n   \n    //vec3 q = fract(p*22.)-0.5;\n    vec3 q = fract(p*2.)-0.5;\n   \n    \n\n    \n    return 1.-smoothstep(0.,.5,length(q));\n}\n\nvec3 xstartrails(in vec3 rd)\n{\n    //        if (rd.z < 0.)\n    //    if (rd.y < 0.)\n    //if (rd.x < 0.)\n    //return vec3(1.0, 0,0);\n    \n    float col0 = xstars( normalize(rotx(rd, iTime * 0.01)));\n\n    float col = col0;\n\n    for (int i = -180; i < -30; i++)\n    {\n    \tfloat col1 = xstars( normalize(rotx(rd, iTime * 0.01 + (float(i) * (1./20.) ))));\n        \n    \tcol += col1;    \n    }\n    \n    \n    if (col < 0.)\n        col = 0.;\n    if (col > 1.)\n        col = 1.;\n    \n    return vec3(1.0 - col);\n}\n\n\n\n\n\nvoid line_rgb (\n    inout vec4 fragColorR, \n    in float lat180,  \n    in float lat180target, \n    in float lat180radius,\n\n\tvec3 rgb)\n{\n    if (lat180 < (lat180target + lat180radius))\n        if (lat180 >( lat180target - lat180radius))\n            \n \t\t//if (lat180 < 108.)\n     //   if (lat180 > 72.)            \n        {\n\n            \n            //float a = 0.3;\n\n            \n\n            fragColorR.rgb = rgb;\n            //fragColorR.b = a;\n            //fragColorR.g = a;\n\n        }\n}\n\n void mainImage0( out vec4 fragColor, in vec2 fragCoord, vec2 thetaphi, vec3 rd, float IPD )\n {\n    \n   // rd *= rotationMatrix(vec3(0.0, 1.0, 0.0), ((-0. -  iMouse.x * 2.) / 360.) * 3.14);\n   \n     \n    //vec3 col = startrails( rd);\n\n    \n    vec3 scanlines = xstartrails( rd);\n    \n    // cool. a subtle line. blink out. blink in\n  vec3 col = scanlines * 0.19 * (0.8 + sin(iTime * 0.1));\n\n    //float tOver = clamp(iTimeDelta-(1./60.),0.,1.);\n    \n    \n    //col = (col + past.rgb) * 0.995;\n    //col = (col + past.gbr) * 0.995;\n    \n     \n     \n     vec3 rdn = normalize(rd);\n        \n        //float lng = atan2(rdn.y, rdn.x);\n           float lng = asin(rd.y);\n        \n        //  arccos(sqrt(x^2+y^2)/x)\n         //float lat=atan2(sqrt(rdn.x*rdn.x+rdn.y*rdn.y),rdn.z);\n         //float lat=acos(sqrt(rdn.x*rdn.x+rdn.y*rdn.y)*sign(rdn.y));\n        float lat=acos(rdn.x);\n        float lat1 = lat / 3.14;\n        float lat180 = lat * 180. / 3.14;\n        \n        vec2 tex1 = vec2 (\n            -(atan(rd.z, rd.x) / 6.283185307179586476925286766559) + 0.5,\n            acos(-rd.y) / 3.1415926535897932384626433832795\n        );\n     \n     \n     \n     fragColor = vec4(col, 1.0);\n         // upper line\n\n           line_rgb(fragColor, lat180, 90. -16., 0.3, vec3(1.0, 0, 0));\n            \n            \n            // center line\n\n            //line(fragColorR, lat180, 90. - 19., 1., 0.8);\n            line_rgb(fragColor, lat180, 90., 0.1, vec3(1.0, 1.0, 0));\n\n            \n              // lower line\n            //line(fragColorR, lat180, 90. + 19., 1., 0.4);\n            line_rgb(fragColor, lat180, 90.+ 16., 0.3, vec3(0.0, 0.0,1.0));\n    \n\t\n     \n      \n }\n\n \n\n// called by drawArrays\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord )\n{\n    bool drag = iMouse.w > 0.0;\n    \n    float grid = 16.;\n    float gridt = 2.;\n    \n    bool indexx = int(int(fragCoord.x  / grid) * int(grid)) == int(fragCoord.x);\n    bool indexy = int(int(fragCoord.y  / grid) * int(grid)) == int(fragCoord.y);\n    //bool indext = int(int(float(iFrame)  / grid) * int(grid)) == int(iFrame);\n    bool indext = int(int(float(iTime)  / gridt) * int(gridt)) == int(iTime);\n    \n    if (drag || (indext&&(indexy||indexx)))\n\n\n    {\n   if ( int(fragCoord.x + 2.) > int(iMouse.x))\n   if ( int(fragCoord.x - 2.) < int(iMouse.x))\n    {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n      if ( int(fragCoord.y + 2.) > int(iMouse.y))\n   if ( int(fragCoord.y - 2.) < int(iMouse.y))\n    {\n        fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n        return;\n    }\n    }\n    \n\t \n\t\n\tbool RvL = true;\n\t \n\tvec4 fragColorR = vec4(1.0, 0.0, 0.0, 1.0);\n\tvec2 fragCoordR = vec2(gl_FragCoord.x, gl_FragCoord.y / 1.0);\n\tvec2 texCoordR0 = vec2((iResolution.x - fragCoordR.x)/iResolution.x, fragCoordR.y/(iResolution.y/1.0))  + vec2(0.25, 0.0);\n\tvec2 thetaphiR = ((texCoordR0 * vec2(2.0, 2.0)) - vec2(1.0)) * vec2(3.1415926535897932384626433832795, 1.5707963267948966192313216916398); \n\tvec3 rayDirectionR = vec3(cos(thetaphiR.y) * cos(thetaphiR.x ), sin(thetaphiR.y), cos(thetaphiR.y) * sin(thetaphiR.x ));\n\n\nfragColor = vec4(0);\n    \n  //rd *= rotationMatrix(vec3(0.0, 0.0, 1.0), 90.);\n   // rayDirectionR *= rotationMatrix(vec3(0.0, 0.0, 1.0), ((90. + cos(iTime) * 1. -  iMouse.y * 2.0) / 360.) * 3.14);\n    rayDirectionR *= rotationMatrix(vec3(0.0, 1.0, 0.0), ((-0. -  iMouse.x * 2.) / 360.) * 3.14);\n    //rd *= rotationMatrix(vec3(0.0, 0.0, 1.0), 90.);\n    rayDirectionR *= rotationMatrix(vec3(0.0, 0.0, 1.0), ((90. + cos(iTime) * 1. -  iMouse.y * 2.0) / 360.) * 3.14);\n    \n\n    \n    mainImage2(\n\tfragColorR, \n\t fragCoordR, \n\tthetaphiR , \n\t rayDirectionR, \n\t uIPD  \n\t\n\t);\n    \n\t// lets not shadow the non stereo area.\n\t//fragColorLvR.rgb *= \n\t//\t1.0 - abs(RvL ? thetaphiR.y : thetaphiL.y) * 0.6;\n\t\n    //if (thetaphiR.y >0.0)\n    //    fragColorR.b += (0.1 + thetaphiR.y * 0.3);\n \t//else\n    //    fragColorR.g += 0.05;\n    \n\tfragColor += fragColorR;\n    \n       \n\tmainImage0(\n\tfragColorR, \n\t fragCoordR, \n\tthetaphiR , \n\t rayDirectionR, \n\t uIPD  \n\t\n\t);\n\t\n    fragColor += fragColorR;\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdfcDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 304, 326, 326, 399], [400, 400, 452, 452, 494], [572, 572, 591, 591, 643], [645, 788, 838, 838, 1241], [1243, 1323, 1368, 1368, 1516], [1518, 1518, 1542, 1565, 1946], [1948, 1972, 2042, 2042, 2142], [2144, 2311, 2340, 2340, 2699], [2701, 2701, 2756, 2756, 2795], [2801, 2801, 2840, 2840, 3221], [3226, 3226, 3253, 3253, 3341], [3346, 3406, 3427, 3427, 3570], [3572, 3627, 3650, 3663, 4145], [4147, 4147, 4176, 4247, 4622], [4625, 4625, 4670, 4670, 5136], [5141, 5198, 5292, 5292, 8324], [8328, 8328, 8353, 8390, 8480], [8482, 8482, 8512, 8616, 8990], [8996, 8996, 9131, 9131, 9487], [9490, 9490, 9584, 9722, 11153], [11158, 11182, 11239, 11239, 13563]]}
{"id": "XdfcRX", "name": "PS20 - MyCreature", "author": "Anderson", "description": "create a creature", "tags": ["procedural"], "likes": 0, "viewed": 198, "published": "Public", "date": "1489593818", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358\n#define TWO_PI 6.28318530716\n\nfloat rand(vec2 uv)\n{\n    //return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Gradient noise\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n// ROTATE AND SCALE FUNCTIONS-----------------------------------------\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle),-sin(angle), sin(angle), cos(angle));\n}\n\nmat2 scale2d(vec2 value)\n{\n    return mat2(value.x,0,0,value.y);\n}\n\n//SHAPES------------------------------------------------------------\nvec3 polarShape(vec2 uv,float dist, float angle, float radius, float p,vec3 colour)\n{\n    float value = 1.0 - step(radius + p,dist);\n    \n    return vec3(value) * colour;\n}\n\nvec3 circle(vec2 uv, vec2 pos, float radius,vec3 colour, float Noise)\n{\n    float value = step(distance(pos,uv), radius);\n    \n    value *= Noise;\n    \n    return vec3(value) * colour;\n}\n\n//Main Code------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = 1.5;\n    uv.x *= ratio;\n    \n    vec2 pos = vec2(0.5 * ratio,0.5);\n    \n    // Noise\n    float a = noise(uv * 11. + iTime) * 0.1;\n    vec3 color = vec3(0.);\n    float value = 0.;\n\n    // Snow\n    float r = snoise(uv * 2. + iTime * 0.5) * ratio;\n\tvalue = step(0.0 + r ,uv.x) - step(0.4 + r,uv.x);\n    color = vec3(value);\n    \n    // Circle Surround the person\n    color = mix(color, circle(uv,vec2(0.5*ratio,0.5),0.4,vec3(.2,.4,.2),1.), 0.8);\n    \n    // Head\n    uv -= pos;\n    color += circle(uv,vec2(0.,0.2),0.1,vec3(0.2,0.2,1),r);\n    color -= circle(uv,vec2(0.04,0.23),0.02,vec3(0.3,2,.2),2.);\n\n    // Body\n\tuv += pos;\n    value = step(0.62 + a,uv.x) - step(0.85,uv.x);\n    value *= step(0.25,uv.y) - step(0.55,uv.y);\n    value *= r;\n    color -= vec3(value) * vec3(0,1,0);\n    \n\t// Horizontal noise\n    value = step(0.54,uv.x) - step(0.84,uv.x);\n    value *= step(0.48 + a,uv.y) - step(0.57 + a,uv.y);\n    value *= r;\n\tcolor -= vec3(value) * vec3(0.1,0.3,.4);\n    \n    // Lower body\n    value = step(0.76,uv.x)- step(0.79,uv.x);\n    value *= step(0.15,uv.y) - step(0.25,uv.y);\n    value *= r;\n    color += vec3(value) * vec3(0.2,0.2,1);\n\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdfcRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 76, 251, 317], [319, 334, 359, 359, 870], [872, 890, 948, 948, 1086], [1088, 1088, 1115, 1115, 1513], [1515, 1532, 1553, 1553, 1600], [1601, 1601, 1622, 1622, 1669], [1670, 1670, 1692, 1692, 1727], [1729, 1729, 1751, 1751, 2799], [2801, 2873, 2901, 2901, 2968], [2970, 2970, 2996, 2996, 3036], [3038, 3107, 3192, 3192, 3279], [3281, 3281, 3352, 3352, 3467], [3469, 3541, 3598, 3598, 4834]]}
{"id": "XdfcWf", "name": "monsterface", "author": "jgreen23", "description": "monster", "tags": ["monster"], "likes": 5, "viewed": 164, "published": "Public", "date": "1490215344", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//tutorial by https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg\n//source code provided by Martjin Steinrucken and changes made by James Green CPE 471-03\n\n#define sat(x) clamp(x, 0., 1.)\n\n//remaps value to be between 0 and 1\nfloat remap01(float a, float b, float t) \n{\n    return sat((t - a) / (b - a));\n}\n\n//remaps value to custom value\nfloat remap(float a, float b, float c, float d, float t)\n{\n    return sat( (t - a) / (b - a) ) *(d - c) + c;\n}\n\n//makes bounding box within a set area with its own coordinate system\nvec2 within(vec2 uv, vec4 rect)\n{\n\treturn (uv - rect.xy) / (rect.zw - rect.xy);    \n}\n\n//makes an eye\nvec4 Eye(vec2 uv, float side, vec2 mouse, float smile)\n{\n    uv -= .5; //center uv\n    \n    uv.x *= side; //reflect the x axis\n    \n    float d = length(uv); //distance to center\n\t\n    vec4 iris = vec4(1. * smile, .2, .1, 1.); //color of iris\n    \n    vec4 color = mix(vec4(1.), iris, smoothstep(.1,.7,d) * .7); //mix in the iris\n    \n    color.a = smoothstep(.5, .48, d); //bound the eye to this circle\n\n    color.rgb *= 1. - smoothstep(.45, .5, d) * 0.8 * sat(-uv.y - uv.x); //make eye\n    \n\td = length(uv - mouse * 0.2); //newdistance for eye gaze\n\n    color.rgb = mix(color.rgb, vec3(1, 1, 0), smoothstep(.3, .28, d)); //iris outline\n\n    iris.rgb *= 1. + smoothstep(.45, .05, d); //iris color\n\n    color.rgb = mix(color.rgb, iris.rgb, smoothstep(.24, .21, d)); //blend in new iris layer\n    \n    d = length(uv - mouse * 0.305); //new distance for pupil\n    \n    float pupilSize = mix(.25,.16, (1. - smile)); \n    \n    color.rgb = mix(color.rgb, vec3(0.), smoothstep(pupilSize, pupilSize * .85, d)); //blend in pupils\n    \n    float time = iTime;\n    \n    vec2 offset = vec2(sin(time+uv.y*25.), sin(time+uv.x*25.)); //rotating highlights\n    \n \toffset *= 0.04 * smile;\n    \n    uv += offset;\n    \n    float highlight = smoothstep(.1, .09, length(uv-vec2(-.15, .15)));\n    \n    highlight += smoothstep(.07, .05, length(uv+vec2(-.08, .08)));\n    \n    color.rgb = mix(color.rgb, vec3(1.), highlight);\t\t\t// blend in highlight\n    \n    return color;\n}\n\n\nvec4 Mouth(vec2 uv, float smile)\n{\n    uv -= 0.5;\n    vec4 color = vec4(0.5, 0.18, 0.05, 1.0); //dark red\n    uv.y *= 1.5; //make smile\n    uv.y -= uv.x * uv.x * 2. * smile;\n    uv.y -= 0.15 * smile;\n    uv.x *= mix(2.5,1.,smile);\n    float d = length(uv);\n    color.a = smoothstep(.5, .48, d); //bind mouth to this shape\n        \n    float tongueD = length(uv + vec2(0., .5));\n\tcolor.rgb = mix(color.rgb, vec3(1.,.5,.5), smoothstep(.5,.2,tongueD));\n    \n    float teethD = length(uv - vec2(0.35, -.5 - (smile * 0.3)));\n    \n    color.rgb = mix(color.rgb, vec3(1.), smoothstep(.26,.24,teethD));\n    return color;\n}\n\nvec4 Head(vec2 uv)\n{\n    vec2 xy;\n    vec4 texColor = texture(iChannel0,xy);//Get the pixel at xy from iChannel0\n\n    vec4 color = vec4(0.0, 0.8, 0.3, 1.0);\n    \n    float d = length(uv); //distance to center\n    \n    color.a = smoothstep(.5, .49, d);\n\n    float edgeShadow = remap01(0.35, 0.5, d);\n    \n\tedgeShadow *= edgeShadow;\n    \n    color.rgb *= 1. - edgeShadow * .5;\n    \n    color.rgb = mix(color.rgb, vec3(0.0, 0.4, 0.2), smoothstep(.47,.48,d)); //outline\n    \n    float highlight = smoothstep(.41,.405,d) * .89;\n    highlight *= remap(.41 - .1, .0, .75, .0, uv.y);\n    color.rgb = mix(color.rgb, vec3(1.), highlight);\n    \n     d = length(uv - vec2(0.25, -.1));\n    float leftFreckB = smoothstep(.05, .0025, d) * .8;\n    color.rgb = mix(color.rgb, vec3(.0, .7, .1), leftFreckB);\n    \n    d = length(uv - vec2(0.27, -.19));\n    float rightFreckB = smoothstep(.05, .0025, d) * .8;\n    color.rgb = mix(color.rgb, vec3(.0, .7, .1), rightFreckB);\n    \n    d = length(uv - vec2(0.19, -.2));\n    float midFreckB = smoothstep(.05, .0025, d) * .8;\n    color.rgb = mix(color.rgb, vec3(.0, .7, .1), midFreckB);\n    \n    \n    return color;\n}\n\nvec4 Monster(vec2 uv, vec2 mouse, float smile)\n{\n    vec4 color = vec4(0.0);\n    float side = sign(uv.x); //either -1 or + 1\n    uv.x = abs(uv.x);\n    vec4 head = Head(uv);\n    vec4 eye = Eye(within(uv, vec4(.03,-.1,.26,.35)), side, mouse, smile);\n    vec4 mouth = Mouth(within(uv, vec4(-.3,-.4, .3, -.1)), smile);\n    color = mix(color, head, head.a);\n    color = mix(color, eye, eye.a);\n    color = mix(color, mouth, mouth.a);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    uv -= 0.5;\n    mouse -= 0.5;\n    \n    float smile = cos(iTime) * 0.5 + 0.5; //oscillate 0 to 1\n    uv.x *= iResolution.x / iResolution.y;\n    \n    if(mouse.x<-.49 && mouse.y<-.49) {\t\t\t// make it that he looks around when the mouse hasn't been used\n    \tfloat s = sin(iTime*.5);\n        float c = cos(iTime*.38);\n        \n        mouse = vec2(s, c)*.4;\n    }\n    uv -= mouse * (.25 - dot(uv, uv));\n\tfragColor = Monster(uv, mouse, smile);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdfcWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 231, 274, 274, 311], [313, 344, 402, 402, 454], [456, 526, 559, 559, 611], [613, 628, 684, 684, 2078], [2081, 2081, 2115, 2115, 2695], [2697, 2697, 2717, 2717, 3837], [3839, 3839, 3887, 3887, 4287], [4289, 4289, 4346, 4346, 4876]]}
{"id": "XdfyDX", "name": "Light Waves", "author": "mitz", "description": "Meandering light waves march across a dark field of blue", "tags": ["2d", "blue"], "likes": 9, "viewed": 146, "published": "Public", "date": "1490050249", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 blue = vec3(0.04, 0.005, 0.912);\n    vec3 blue2 = vec3(0.045, 0.02, 0.912);\n    vec3 ground = vec3(0.03, 0.02, 0.1);\n\n    vec3 color = mix(blue2, ground, uv.y);\n    \n    float wave = sin(uv.x * 32.0 + iTime*2.0) + sin(uv.x * 23.0 + iTime) + sin(uv.x *25.0 + iTime);\n\tfloat wave2 = sin(uv.x * 43.0 + iTime) + sin(uv.x * 103.0 + iTime) + sin(uv.x *25.0 + iTime);\n\n    float tOff = sin(iTime * 0.3);\n    color = mix(ground, color, wave/30.0 * tOff);\n    \n    color = color / smoothstep(0.1, 0.3, uv.y - 0.23 + wave/35.0)*2.0;\n    color = color / smoothstep(0.1, 0.5, uv.y - 0.23 + wave2/90.0);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdfyDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 735]]}
{"id": "XdfyRB", "name": "WWDC14 Session 609 Slide 43", "author": "capnslipp", "description": "Custom GL delegate rendering from WWDC 2014 - Session 609 What's New in SceneKit - Slide 43 Custom OpenGL/OpenGL ES.\n\nRipped from `AAPLSlideDelegateRendering` class and `SceneDelegate.fsh` in `SceneKitslidesforWWDC2014` sample code; cleaned up for ST.", "tags": ["wwdc", "scenekit"], "likes": 7, "viewed": 570, "published": "Public API", "date": "1488583542", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float factor = 1.0;\nvec3 color = vec3(0.2, 0.5, 1.0);\n\nvec4 t(vec2 uv)\n{\n    float j = sin(uv.y * 3.14 + iTime * 5.0);\n    float i = sin(uv.x * 15.0 - uv.y * 2.0 * 3.14 + iTime * 3.0);\n    float n = -clamp(i, -0.2, 0.0) - 0.0 * clamp(j, -0.2, 0.0);\n    \n    return 3.5 * (vec4(color, 1.0) * n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    vec2 uv;\n    \n    float r = sqrt(dot(p, p));\n    float a = atan(\n        p.y * (0.3 + 0.1 * cos(iTime * 2.0 + p.y)),\n        p.x * (0.3 + 0.1 * sin(iTime + p.x))\n    ) + iTime;\n    \n    uv.x = iTime + 1.0 / (r + .01);\n    uv.y = 4.0 * a / 3.1416;\n    \n    fragColor = mix(vec4(0.0), t(uv) * r * r * 2.0, factor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdfyRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 72, 72, 296], [298, 298, 353, 353, 729]]}
{"id": "XdfyWM", "name": "Alloy Plated Voronoi", "author": "Shane", "description": "Bump mapped, smooth Voronoi layers, sectioned off into fractional contours. Basically, just an excuse to make something shiny. :)", "tags": ["voronoi", "bump", "metal", "alloy"], "likes": 58, "viewed": 3029, "published": "Public API", "date": "1489665830", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tAlloy Plated Voronoi\n\t--------------------\n\n    This was originally a rigid scrolling example, but I thought the movement looked more \n\tinteresting. Obviously, hard, fluid alloy doesn't make a lot of physical sense, so if the \n\tsituation really messes with your sense of correctness, uncomment the \"RIGID_SCOLL\" \n\tdefine... or just pretend it's futuristic alien alloy from another dimension. :D\n\n    From a technical perspective, it's a couple of smooth Voronoi layers (based on IQ's\n\tarticle below), split into fractional contours then bump mapped. Hardly cutting edge,\n    and\tnot all that exciting. One of the things that did require some effort was producing \n\tthe succinct smooth borders with enough quality to allow for pronounced bump mapping\n\twith minimal artifacts. The results are sufficient, but there are probably more efficent \n\tways to achieve the same.\n\n\tI was going for a tarnished silver kind of look. Not sure whether it worked, but it looks\n\tshiny, so that's good enough for me. :) When I first started taking an interest in graphics, \n\tmy idea of producing a metallic looking object was to render it flat grey, then add some \n\tambient lighting... Yes, I was \"that\" naive. :D\n\n\tThese days, I apply a little more science, but a lot of it is still made up. Specular \n\tlighting and fake reflections help add to the illusion, but I find that\tramping the diffuse \n\tlight to a few powers tends to work best. Also, to give the light more angularity, I \n\taccentuated the bump mapping more than I usually would.\n\n\t\n\t\n\n\tSimilar Examples:\n\n\tVoronoi - smooth - iq\n\thttps://www.shadertoy.com/view/ldB3zc\n\n    // Great accompanying article.\n    http://www.iquilezles.org/www/articles/smoothvoronoi/smoothvoronoi.htm\n\n\n    // A cleaner, more simplistic rendering.\n\tSmooth Voronoi Contours - Shane\n    https://www.shadertoy.com/view/4sdXDX\n\n\n*/\n\n//#define RIGID_SCROLL\n\n// Gradient factor. See the \"func\" function. It's a fudge factor used to make the contour lines appear \n// unison in width. It's a mildly expensive calulation, and I'm reusing it, so it's global. I'll try to \n// localize it later.\nfloat gF; \n\n//float sFract(float x, float sm){ float fx = fract(x); return fx - smoothstep(fwidth(x)*sm, 0., 1. - fx); }\n//float sFract(float x, float sm){ float fx = fract(x); return min(fx, fx*(1. - fx)/gF/sm); }//fwidth(x)\n\n// Based on Ollj's smooth \"fract\" formula.\nfloat sFract(float x, float sm){\n    \n    // Extra smoothing factor. \"1\" is the norm.\n    const float sf = .5; \n    \n    // The hardware \"fwidth\" is cheap, but you could take the expensive route and\n    // calculate it by hand if more quality was required.\n    vec2 u = vec2(x, fwidth(x)*sf*sm);\n    \n    // Ollj's original formula with a transcendental term omitted.\n    u.x = fract(u.x);\n    u += (1. - 2.*u)*step(u.y, u.x);\n    return clamp(1. - u.x/u.y, 0., 1.); // Cos term ommitted.\n}\n\n\n\nfloat sFloor(float x){ return x - sFract(x, 1.); } // Only works for nonnegative \"x,\" which is fine here.\n\n\n// Standard hue rotation formula with a bit of streamlining. \nvec3 rotHue(vec3 p, float a){\n\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr, 0., 1.);\n}\n\n\n// Standard 2x2 hash algorithm.\nvec2 hash22(vec2 p) {\n    \n    // Faster, but probaly doesn't disperse things as nicely as other methods.\n    float n = sin(dot(p, vec2(41, 289)));\n    p = fract(vec2(2097152, 262144)*n);\n    #ifdef RIGID_SCROLL\n    return p - .5;\n    #else\n    return cos(p*6.283 + iTime)*.5;\n    //return abs(fract(p+ iTime*.25)-.5)*2. - .5; // Snooker.\n    //return abs(cos(p*6.283 + iTime))*.5; // Bounce.\n    #endif\n\n}\n\n\n// vec3 to vec3 hash algorithm.\nvec3 hash33(vec3 p) { \n\n    // Faster, but doesn't disperse things quite as nicely as the block below it. However, when framerate\n    // is an issue, and it often is, this is the one to use. Basically, it's a tweaked amalgamation I put\n    // together, based on a couple of other random algorithms I've seen around... so use it with caution,\n    // because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; // return fract(vec3(64, 8, 1)*32768.0*n)*2.-1.; \n\n    // I'll assume the following came from IQ.\n    //p = vec3( dot(p, vec3(127.1, 311.7, 74.7)), dot(p, vec3(269.5, 183.3, 246.1)), dot(p, vec3(113.5, 271.9, 124.6)));\n    //return (fract(sin(p)*43758.5453)*2. - 1.);\n\n}\n\n\n\n// Cheap, streamlined 3D Simplex noise... of sorts. I cut a few corners, so it's not perfect, but it's\n// artifact free and does the job. I gave it a different name, so that it wouldn't be mistaken for\n// the real thing.\n// \n// Credits: Ken Perlin, the inventor of Simplex noise, of course. Stefan Gustavson's paper - \n// \"Simplex Noise Demystified,\" IQ, other \"ShaderToy.com\" people, etc.\nfloat tetraNoise(in vec3 p){\n    \n    // Skewing the cubic grid, then determining the first vertice and fractional position.\n    vec3 i = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    \n    // Breaking the skewed cube into tetrahedra with partitioning planes, then determining which side of the \n    // intersecting planes the skewed point is on. Ie: Determining which tetrahedron the point is in.\n    vec3 i1 = step(p.yzx, p), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    \n    // Using the above to calculate the other three vertices. Now we have all four tetrahedral vertices.\n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n  \n\n    // 3D simplex falloff.\n    vec4 v = max(0.5 - vec4(dot(p,p), dot(p1,p1), dot(p2,p2), dot(p3,p3)), 0.0);\n    \n    // Dotting the fractional position with a random vector generated for each corner -in order to determine \n    // the weighted contribution distribution... Kind of. Just for the record, you can do a non-gradient, value \n    // version that works almost as well.\n    vec4 d = vec4(dot(p, hash33(i)), dot(p1, hash33(i + i1)), dot(p2, hash33(i + i2)), dot(p3, hash33(i + 1.)));\n    \n     \n    // Simplex noise... Not really, but close enough. :)\n    return clamp(dot(d, v*v*v*8.)*1.732 + .5, 0., 1.); // Not sure if clamping is necessary. Might be overkill.\n\n}\n\n\n\n// Smooth Voronoi. I'm not sure who came up with the original, but I think IQ\n// was behind this particular algorithm. It's just like the regular Voronoi\n// algorithm, but instead of determining the minimum distance, you accumulate\n// values - analogous to adding metaball field values. The result is a nice\n// smooth pattern. The \"falloff\" variable is a smoothing factor of sorts.\n//\nfloat smoothVoronoi(vec2 p, float falloff) {\n\n    vec2 ip = floor(p); p -= ip;\n\t\n\tfloat d = 1., res = 0.;\n\t\n\tfor(int i=-1; i<=2; i++) {\n\t\tfor(int j=-1; j<=2; j++) {\n            \n\t\t\tvec2 b = vec2(i, j);\n            \n\t\t\tvec2 v = b - p + hash22(ip + b);\n            \n\t\t\td = max(dot(v,v), 1e-8);\n\t\t\t\n\t\t\tres += 1./pow(d, falloff );\n            //res += exp( -16.*d ); // Alternate version.\n\t\t}\n\t}\n\n\treturn pow(1./res, .5/falloff);\n    //return clamp((-(1./16.)*log(res) + .1)/1.1, 0., 1.); // Alternate version.\n}\n\n\n\n// 2D function we'll be creating the fractional contours for. \nfloat func2D(vec2 p){\n    \n    #ifdef RIGID_SCROLL\n    p += vec2(-.2, 0)*iTime; // Scrolling.\n    #endif\n    \n    return smoothVoronoi(p*2., 4.)*.66 + smoothVoronoi(p*6., 4.)*.34;\n    \n}\n\n// For fractional countours, something like \"fract(func(p)*layers\" will work, but the results \n// are aliased, so a smooth \"fract\" function needs to be applied. For nice, even contour lines,\n// the functional curvature needs to be taken into account. Hence the \"fxr\" and \"fyb\" samples.\nfloat func(vec2 p){\n    \n    float f = func2D(p); // Function value.\n   \n    // Samples in the X and Y directions to even up the contour lines according to curvature.\n    vec2 e = vec2(8./iResolution.y, 0);\n    float fxr = func2D(p - e.xy);\n    float fyb = func2D(p - e.yx);\n \n    // Gradient factor. Four samples would be better, but I'm trying to save some calculations.\n    // I made \"gF\" global, for reuse purposes, but I'll try to rectify that later. See the \"sFract\"\n    // function. Press pause, then set \"gF\" to a constant, like \".04,\" to see what it does.\n    // This example would be a lot faster if \"gF\" was set to a constant (since the two samples \n    // above wouldn't be necessary), so if you like that aesthetic more, then that's the way to go.\n    gF = length(f - vec2(fxr, fyb)); \n    \n    const float palNum = 12.; // 12 contour lines.\n    return sFract(f*palNum, 4.); // 4 is a smoothing factor. Getting the balance right can be frustrating.   \n    \n}\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it.\nvec3 envMap(vec3 rd){\n    \n   \n    float c = tetraNoise(rd*3.)*.57 + tetraNoise(rd*6.)*.28 + tetraNoise(rd*12.)*.15; // Noise value.\n    c = smoothstep(.4, 1., c); // Darken and add contast for more of a spotlight look.\n    \n    vec3 col = vec3(c*c*c, c*c, c); // Simple, cool coloring.\n    //vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)); // Warm color.\n    \n    // Mix in the reverse color to tone it down and return.\n    return mix(col, col.zxy, rd*.25 + .25); \n    \n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Screen coordinates.\n\tvec2 u = (fragCoord.xy - iResolution.xy*.5)/iResolution.y;\n    \n    // Function value.\n    float f = func(u);\n    float ssd = func2D(u); // Saving the unpalettized noise value to add a little gradient to the color, etc.\n    \n    // Four sample values around the original. Used for edging and highlighting. Note the \"1.5\" factor in a \n    // couple of samples. I was playing around and liked it more that way, but you can take it out if you want.\n    vec2 e = vec2(2./450., 0);\n    float fxl = func(u + e.xy*1.5);\n    float fxr = func(u - e.xy);\n    float fyt = func(u + e.yx*1.5);\n    float fyb = func(u - e.yx);\n  \n    // Colorizing the the function value.\n    vec3 col = vec3(.5);\n    \n    // Applying some color and hue rotation based on fractional layer and position. Designed to coincide\n    // with the \"func\" function.\n    const float palNum2 = 12.;\n    float fi = (1. - clamp(sFloor(ssd*(palNum2))/(palNum2 - 1.), 0., 1.));\n    fi = mod(fi, 4./12.);\n    \n    if(fi>3./12.) {\n        // Extra color layers. I found it a bit much.\n        //col *= vec3(1, .18, .28);\n        //col = rotHue(col, mod(iTime/3. + 3.14159, 6.2831853) + (length(u*vec2(3., 5.))));        \n        col *= .25;                   \n    }\n    else if(fi>2./12.) {\n        \n        col *= vec3(1, .18, .28);\n        col = rotHue(col, mod(iTime/4., 6.2831853) + (length(u*vec2(2.5, 4.5))));// + iTime*.5\n    }\n    \n    // Adding a bit of noise for a bit more authenticity.\n    vec3 u3 = vec3(u, f); // Fake height, \"ssd,\" according to function value.\n    #ifdef RIGID_SCROLL\n    u3.xy += vec2(-.2, 0)*iTime; // Scrolling.\n    #endif\n    col = min(col*.8 + tetraNoise(u3*128.)*.4, 1.);\n    \n\n   \n    // Extra highlighting to shine up the edges. Purely for aesthetics. Not based on science. :)\n    col += vec3(.5, .7, 1)*(max(f - fyt, 0.) + max(f - fxl, 0.))*1.*ssd*2.;\n\n    \n    vec3 rd = normalize(vec3(u, 1)); // Unit direction vector.\n    vec3 n = normalize(vec3(0, 0, -1) + vec3(fxr - fxl, fyb - fyt, 0)/e.x/1.4*.01); // Bumped normal.\n    vec3 ld = (vec3(.25, .25, -1.) - vec3(u, 0)); // Light direction - Position minus surface point.\n    \n    float dist = length(ld); // Light distance.\n    float atten = 1./(1. + dist*dist*.25); // Light attenuation.\n    \n    ld /= dist; // Normalizing the light dirction vector.\n    \n    \n    float diff = max(dot(ld, n), 0.); // Diffuse.\n    diff = pow(diff, 4.)*.66 + pow(diff, 8.)*.34; // Ramped diffuse - for shininess.\n    float spec = pow(max(dot(reflect(ld, n), rd), 0.), 8.); // Specular.\n    float fres = pow(clamp(dot(rd, n) + 1., 0., 1.), 3.); // Fresnel.\n    \n    // Combining the above terms to produce the lit color.\n    col = col*(diff*2. + .125) + vec3(1, .7, .3)*spec*2. + vec3(.25, .5, 1)*fres*2.;\n    //col += vec3(.5, .7, 1)*diff*diff*.5; // Too much shine. :)\n\n\n    // Fake environment mapping for that reflective look.\n    col += (col*.65 + .35)*envMap(reflect(rd, vec3(0, 0, -1)*.25 + n*.75))*2.; \n\n    // Attenuating, then adding some brown shadowing for a subtle tarnished look.\n    col *= atten*(vec3(f, pow(f, 1.1), pow(f, 1.2))*.85 + .15); \n    \n    \n    //col *= vec3(1.35, .8, .5); // Bronze, copper... kind of.\n  \n    \n    // Subtle, bluish vignette.\n    //u = fragCoord/iResolution.xy;\n    //col = mix(vec3(0, .1, 1), col, pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y) , .125)*.15 + .85);\n\n \t\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdfyWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2336, 2379, 2411, 2464, 2869], [2873, 2873, 2895, 2895, 2923], [2981, 3043, 3072, 3072, 3442], [3445, 3477, 3498, 3582, 3883], [3886, 3918, 3939, 4305, 4684], [4688, 5078, 5106, 5202, 6448], [6452, 6837, 6881, 6881, 7345], [7349, 7412, 7433, 7433, 7598], [7600, 7886, 7905, 7905, 8857], [8859, 8961, 8982, 8982, 9444], [9448, 9448, 9502, 9530, 12956]]}
{"id": "XdfyzB", "name": "and then the sky opened up", "author": "jes5199", "description": "like a door had opened", "tags": ["aliasing", "symmetries"], "likes": 1, "viewed": 73, "published": "Public", "date": "1488607183", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((1220.0 + iTime) / 24.0) * ((fragCoord.xy - (iResolution.xy / 2.0)) / iResolution.y);\n\n    float r = mod(iTime / 100.0 + acos(-1.0) / 4.0, acos(-1.0)*2.0);\n    mat2 rot = mat2(cos(r), -sin(r), sin(r), cos(r));\n    //uv = uv * rot;\n\n    if(uv.x == 0.0) {\n      r = 1.0;\n    } else {\n      r = atan(uv.y / uv.x) * 1.0;\n    }\n    rot = mat2(cos(r), -sin(r), sin(r), cos(r));\n    uv = uv * rot;\n        \n    float value = (uv.x * sign(uv.y) + uv.y * sign(uv.x)) * sin(uv.x) * sin(uv.y);\n    float color = sin(value) * 3.0;\n    color = color * sign(uv.x) * sign(uv.y);\n\n    float low = abs(color);\n    float med = abs(color) - 1.0;\n    float high = abs(color) - 2.0;\n    \n    fragColor = vec4(high, high, low,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdfyzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 781]]}
{"id": "XdfyzX", "name": "Stingray creature", "author": "mcad_30", "description": "noise", "tags": ["2d"], "likes": 0, "viewed": 91, "published": "Public", "date": "1489026302", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n#define TWOPI 6.2831\n\nvec3 colorGray = vec3(0.5, 0.5, 0.5);\nvec3 colorBlack = vec3(0.0, 0.0, 0.0);\n\nfloat createShape(vec2 centerPosition, float side)\n{  \n    float a = atan(centerPosition.y,centerPosition.x);\n    float r = TWOPI/side;\n    return cos(floor(.5+a/r)*r-a)*length(centerPosition.xy);\n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nmat2 scale2d(vec2 size)\n{\n    return mat2(size.x, 0.0, 0.0, size.y);\n}\n\nfloat rand(vec2 uv)\n{\n    //return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\nfloat rectangleMaker(vec2 uv, vec2 size, vec2 position)\n{\n    float x = step(position.x, uv.x) - step(position.x + size.x, uv.x);\n    float y = step(position.y, uv.y) - step(position.y + size.y, uv.y);\n    \n    float rectangle = x*y;\n    \n    return rectangle;\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float n = noise(uv * 200.0 + iTime) * .05;\n\tfloat nOfTail = noise(uv * 50.0 + iTime) * .05;\n    float nOfEyes = noise(uv * 100.0 + iTime) * .05;\n    uv += (sin(iTime) + 0.1)/10.0;\n    vec2 size = vec2(0.01, 0.3);\n    vec2 position = vec2(0.52 - nOfTail,0.25);\n    float rectangle1 = rectangleMaker(uv, size, position);\n        \n    vec2 eyeSize = vec2(0.01, 0.01);\n    vec2 eyePosition = vec2(0.51-nOfEyes,0.67);\n    float leftEye = rectangleMaker(uv, eyeSize, eyePosition);\n    \n    vec2 rightSize = vec2(0.011, 0.01);\n    vec2 rightPosition = vec2(0.54-nOfEyes,0.67);\n    float rightEye = rectangleMaker(uv, rightSize, rightPosition);\n    \n    vec2 squarePosition = vec2(0.5, 0.6);\n    vec3 square1 = vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(45.0 * PI / 180.0);\n    uv *= scale2d(vec2(4.0));\n   \tuv += squarePosition;\n    square1 = vec3(step(createShape(uv - n - squarePosition, 4.0), 0.4));\n    square1 *= colorGray;\n    vec3 creature = (square1- leftEye - rightEye) + rectangle1 ;\n\tfragColor = vec4(vec3(creature),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdfyzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 172, 172, 318], [320, 320, 348, 348, 416], [418, 418, 443, 443, 488], [490, 490, 511, 686, 752], [754, 754, 811, 811, 1016], [1018, 1033, 1058, 1058, 1569], [1571, 1571, 1628, 1628, 2715]]}
{"id": "XdlcWl", "name": "Voxel Tracing", "author": "djeof1", "description": "Shader for rendering minecraft-like voxel environment.", "tags": ["voxel", "glsl", "rendering"], "likes": 1, "viewed": 173, "published": "Public", "date": "1490335023", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y -= .5;\n\tvec3 c, f, p, o, y = vec3(2.0,1.0,2.0);\n    vec3 g = vec3(uv,0.5);\n    g.xz *= mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n    \n\to.x = .01 * sin(2.0 * iTime) * cos(2.0 * iTime) - 4.4;    \n\to.z = iTime * 10.0;\n \to.y = 1.2 * cos((o.z) * 0.1) - 5.0;\n   \n    for ( float i = 0.; i < 32.; i += .05 ) {\n        o += vec3(uv,0.5) * i *.05; \n        c = o;\n        f = fract(c); \n\t\tp = floor(c) * .05;\n\t\tif( cos(p.z) + sin(p.x) > p.y + 1. ) {\n\t  \t\tg = (f.y - .04 * cos((c.x + c.z) * 5.) > .5 ? y : f.x * y.yxz)/i;\n            break;\n        }\n    }\n    fragColor = vec4(g, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdlcWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 696]]}
{"id": "XdlyD2", "name": "Gambling", "author": "tonynogo", "description": "First test with sdf and camera\nI tried to do this shader based on :\nhttps://www.shadertoy.com/view/4ljXRh \nhttps://cis700-procedural-graphics.github.io/files/implicit_surfaces_2_21_17.pdf\nhttp://iquilezles.org/www/articles/distfunctions/distfunctions.htm", "tags": ["sdf", "camera"], "likes": 3, "viewed": 153, "published": "Public", "date": "1490439930", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Camera\nvec3 CameraPos = vec3(7.0, 3.0, -7.0);\nvec3 TargetPoint = vec3(2.0, 0.0, 0.0);\n\nvec3 currentColor = vec3(1.0, 1.0, 1.0);\nconst float EPSILON_RAYMARCH = 0.01;\nconst float EPSILON_NORMAL = 0.0001;\nconst int RAYMARCHING_STEP = 64;\nconst float MOVE_SPEED = 2.0;\nconst float ROTATION_SPEED = 0.2;\n\n// -----TRANSFORMATION-------------------------\n// Repetition (Thx abje)\nvec3 Repetition(vec3 p, vec3 c)\n{\n    return mod(p, c) - 0.5 * c;\n}\n\n// Rotation\nvec3 Rotation( vec3 p, mat3 m )\n{\n    // Removing inverse for better performance (Thx coyote)\n    return m * p;\n}\n\n// Translation\nvec3 Translation(vec3 p, vec3 displacement)\n{\n    return p + displacement;\n}\n//---------------------------------------------\n\n// Union\nfloat Union(float previous, float current, vec3 color)\n{\n    if(previous < current)\n        return previous;\n    \n    currentColor = color;\n\treturn current;\n}\n\n// Intersection\nfloat Intersection(float previous, float current, vec3 color)\n{\n    if(previous > current)\n        return previous;\n    \n    currentColor = color;\n\treturn current;\n}\n\n// Soustraction\nfloat Substract(float previous, float current, vec3 color)\n{\n    if(previous > -current)\n        return previous;\n    \n    currentColor = color;\n\treturn current;\n}\n\n//------SHAPES---------------------------------\n// Sphere\nfloat SD_Circle(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\n// Round Box\nfloat SD_RoundBox(vec3 p, vec3 b, float r)\n{\n  return length(max(abs(p) - b, 0.0)) - r;\n}\n\n// Points of the dice\nfloat SD_DicePoints(vec3 pos)\n{\n    // 1\n    float val = SD_Circle(pos - vec3(-1.5, 0.0, 0.0), 0.3);\n    \n    // 2\n    val = min(val, SD_Circle(pos - vec3(-0.70, 0.70, 1.5), 0.3));\n    val = min(val, SD_Circle(pos - vec3(0.70, -0.70, 1.5), 0.3));\n    \n    // 3\n    val = min(val, SD_Circle(pos - vec3(-0.70, -1.5, 0.7), 0.3));\n    val = min(val, SD_Circle(pos - vec3(0.70, -1.5, -0.7), 0.3));\n    val = min(val, SD_Circle(pos - vec3(0.0, -1.5, 0.0), 0.3));\n    \n    // 4\n    val = min(val, SD_Circle(pos - vec3(0.7, 1.5, 0.7), 0.3));\n    val = min(val, SD_Circle(pos - vec3(-0.70, 1.5, 0.7), 0.3));\n    val = min(val, SD_Circle(pos - vec3(-0.7, 1.5, -0.7), 0.3));\n    val = min(val, SD_Circle(pos - vec3(0.70, 1.5, -0.7), 0.3));\n    \n    // 5\n    val = min(val, SD_Circle(pos - vec3(0.0, 0.0, -1.5), 0.3));\n    val = min(val, SD_Circle(pos - vec3(0.70, 0.70, -1.5), 0.3));\n    val = min(val, SD_Circle(pos - vec3(-0.70, -0.70, -1.5), 0.3));\n    val = min(val, SD_Circle(pos - vec3(0.70, -0.70, -1.5), 0.3));\n    val = min(val, SD_Circle(pos - vec3(-0.70, 0.70, -1.5), 0.3));\n    \n    // 6 \n    val = min(val, SD_Circle(pos - vec3(1.5, 0.70, 0.5), 0.3));\n    val = min(val, SD_Circle(pos - vec3(1.5, 0.70, -0.5), 0.3));\n    val = min(val, SD_Circle(pos - vec3(1.5, 0.0, 0.5), 0.3));\n    val = min(val, SD_Circle(pos - vec3(1.5, 0.0, -0.5), 0.3));\n    val = min(val, SD_Circle(pos - vec3(1.5, -0.70, 0.5), 0.3));\n    val = min(val, SD_Circle(pos - vec3(1.5, -0.70, -0.5), 0.3));\n    return val;\n}\n//---------------------------------------------\n\n\n// Test all the SD function to determine the nearest point\nfloat SceneSDF(vec3 pos)\n{\n    float moveTime = MOVE_SPEED * iTime;\n    //pos = Translation(pos, vec3(moveTime, moveTime, moveTime));\n    pos = Repetition(pos, vec3(12.0, 12.0, 12.0));\n    \n    float rotationTime = ROTATION_SPEED * iTime;\n    \n    pos = Rotation(pos, mat3(1.0, 0.0, 0.0,\n                             0.0, cos(rotationTime), sin(rotationTime),\n                             0.0, -sin(rotationTime),cos(rotationTime)));\n    \n    pos = Rotation(pos, mat3(cos(rotationTime), 0.0, sin(rotationTime),\n                             0.0, 1.0, 0.0,\n                             -sin(rotationTime), 0.0, cos(rotationTime)));\n    \n    float result = 999999999999999999.0;\n    result = Union(result, SD_RoundBox(pos, vec3(1.5, 1.5, 1.5), 0.1), vec3(1.0, 0.0, 0.0));\n    result = Intersection(result, SD_Circle(pos, 2.3), vec3(1.0, 0.0, 0.0));\n    result = Substract(result, SD_DicePoints(pos), vec3(1.0, 1.0, 1.0));\n    return result;\n}\n\n// Lambert lighting\nfloat Lambert(vec3 lightDir, vec3 normal)\n{\n    return max(0.1, dot(lightDir, normal));\n}\n\n// Compute the normal by approximating the nearest points\nvec3 ComputeNormal(vec3 pos, float currentDistance)\n{\n    return normalize(\n        vec3(\n            SceneSDF(pos + vec3(EPSILON_NORMAL, 0.0, 0.0)) - currentDistance,\n            SceneSDF(pos + vec3(0.0, EPSILON_NORMAL, 0.0)) - currentDistance,\n            SceneSDF(pos + vec3(0.0, 0.0, EPSILON_NORMAL)) - currentDistance)\n    );\n}\n\n// Determine the distance of the objects\nfloat RayMarching(vec3 origin, vec3 rayDir)\n{\n    float dist = 0.0;\n    float nearest = 0.0;\n    float result = 0.0;\n    \n    for(int i = 0; i < RAYMARCHING_STEP; i++)\n    {\n        vec3 currentPos = origin + rayDir * dist;\n        nearest = SceneSDF(currentPos);\n        if(nearest <= EPSILON_RAYMARCH)\n        {\n            vec3 lightDir1 = normalize(vec3(1.0, 1.0, -1.0));\n            vec3 normal = ComputeNormal(currentPos, nearest);\n            result = Lambert(lightDir1, normal);\n            return result;\n        }\n        dist += nearest;\n    }\n    return result;\n}\n\n// LookAt Camera\nmat3 setCamera()\n{  \n    vec3 zaxis = normalize(TargetPoint - CameraPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 xaxis = cross(up, zaxis);\n    vec3 yaxis = cross(zaxis, xaxis);\n    \n    return mat3(xaxis, yaxis, zaxis);\n}\n\n// Pixel function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Move the camera\n    CameraPos.z += iTime * MOVE_SPEED;\n    \n    // Move the lookAt point\n    TargetPoint.z += iTime * MOVE_SPEED;\n\n    // Compute LookAt Matrix\n    mat3 lookAtMat = setCamera();\n    \n    // ray direction\n    vec2 p = fragCoord.xy / iResolution.xy - 0.5;\n\tp.x *= iResolution.x / iResolution.y;\n    vec3 RayDir = lookAtMat * normalize( vec3(p.xy,2.0) );\n    \n    float val = RayMarching(CameraPos, RayDir);\n    vec3 col =  val * currentColor;\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdlyD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[303, 376, 409, 409, 443], [445, 457, 490, 550, 570], [572, 587, 632, 632, 663], [713, 722, 778, 778, 880], [882, 898, 961, 961, 1063], [1065, 1081, 1141, 1141, 1244], [1246, 1304, 1345, 1345, 1380], [1382, 1395, 1439, 1439, 1484], [1486, 1508, 1539, 1548, 3002], [3053, 3112, 3138, 3138, 4051], [4053, 4073, 4116, 4116, 4162], [4164, 4222, 4275, 4275, 4554], [4556, 4597, 4642, 4642, 5172], [5174, 5191, 5209, 5209, 5417], [5419, 5437, 5494, 5517, 5989]]}
{"id": "XdlyWf", "name": "Voxel Sponge : Hazard Experiment", "author": "aiekick", "description": "use the code of the shader of abje : [url=https://www.shadertoy.com/view/lssyW2]Voxel Sponge[/url]", "tags": ["experiment", "voxel", "sponge", "hazard"], "likes": 10, "viewed": 609, "published": "Public API", "date": "1490139677", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(spin) mat2(cos(spin),-sin(spin),sin(spin),cos(spin))\n\nfloat time;\n\n/*\nwhat to fix:\npositions are wrong\n\"sign(dir)*0.001\" is wrong\n*/\n\nfloat map(vec3 p) {\n    p = mod(p,3.0);\n    vec3 q = p;\n    //return dot(q-1.0,q-1.0)-max(abs(q.x)+q.y,-q.y)*max(abs(q.y)+q.z,-q.z)*max(abs(q.z)+q.x,-q.x); // the pifometer change\n    return dot(q-1.5,q-1.5)-3.5; // the pifometer change\n    //return dot(p-1.0,p-1.0)-1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime * .5;\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    \n    vec3 cam = vec3(1.5,1.5,time);\n    vec3 pos = cam;\n    vec3 dir = normalize(vec3(uv,1.0));\n    vec3 floorpos = floor(pos);\n    vec3 mask;\n    \n    float dist = 0.0;\n    vec3 localpos = pos;\n    vec3 localfloor = floorpos;\n    float stepsize = 1.0;\n    float count = 0.0;\n    \n    \n    for (int i = 0; i < 12; i++) {\n        float len = map(localfloor);\n        if (len > 0.0) {\n            localpos *= 3.0;\n            localpos = localpos-sign(dir)*1.5+1.5;\n            \n            localfloor = floor(localpos-sign(dir)*0.001);\n            stepsize /= 3.0;\n            \n            if (count > 2.0) {\n                break;\n            }\n            count ++;\n        } else {\n        \n            vec3 dists = abs((sign(dir)*0.5+0.5)-(localpos-localfloor))*1.0/abs(dir);\n\n            float m = min(min(dists.x,dists.y),dists.z);\n\n            mask = step(dists,vec3(m));\n\n            pos += m*dir*stepsize;\n            dist += m*stepsize;\n            localpos += m*dir;\n            localfloor += mask*sign(dir);\n\n            floorpos += mask*sign(dir)*stepsize;\n        }\n    }\n    \n\t//fragColor = vec4(,1.0);\n    fragColor = vec4((.5+.25*(sin((floorpos)*10.0+time)*0.5+0.5)+.25*mask)*.5/dist, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdlyWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 146, 165, 165, 419], [421, 421, 478, 478, 1782]]}
{"id": "XdlyWM", "name": "3D text rendering", "author": "rimina", "description": "Based on https://www.shadertoy.com/view/4ssSDn and http://www.claudiocc.com/the-1k-notebook-part-i/", "tags": ["textrendering"], "likes": 1, "viewed": 127, "published": "Public", "date": "1488452837", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define LENGTH 15\n#define MAXD 100.\n\n#define FAR 80.0\n#define FAR_R 60.0\n#define STEPS 36\n#define GAMMA vec3(2.2)\n\nint text[LENGTH];\n\n/*\nA = 65,\nB = 66,\nC = 67,\nD = 68,\nE = 69,\nF = 70,\nG = 71,\nH = 72,\nI = 73,\nJ = 74,\nK = 75,\nL = 76,\nM = 77,\nN = 78,\nO = 79,\nP = 80,\nQ = 81,\nR = 82,\nS = 83,\nT = 84,\nU = 85,\nV = 86,\nW = 87,\nX = 88,\nY = 89,\nZ = 90,\n*/\n\n// iq's renamed sdCapsule in 2d\nfloat line( vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - .1;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ){\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdf(vec3 p){\n    \n    //d = COMGI\n    //k = AMIKO\n    //r = MGI\n\t//i = GHN\n    //m = MGHNHIO\n    //n = MGIO\n    //a = GIOMJL\n    \n\t// d \n\ttext[0] = 67;\n\ttext[1] = 79;\n\ttext[2] = 77;\n\ttext[3] = 71;\n    text[4] = 73;\n\t\n\t// k\n\ttext[5] = 65;\n\ttext[6] = 77;\n\ttext[7] = 73;\n\ttext[8] = 75;\n\ttext[9] = 79;\n    \n    text[10] = 71; //71, 79, 75, 77, 73\n\ttext[11] = 79;\n\ttext[12] = 75;\n\ttext[13] = 77;\n\ttext[14] = 73;\n    \n    vec3 offset1 = vec3(2.5, 4, 0.0);\n    vec3 offset2 = vec3(0.0, 4, 0.0);\n    vec3 offset3 = vec3(-2.5, 4, 0.0);\n    vec3 offset4 = vec3(-1.25, 1.5, 0.0);\n    vec3 offset5 = vec3(1.25, 1.5, 0.0);\n\t\n\tfloat d = MAXD;\n    float r = 0.15;\n    \n    for (int i=1;i<LENGTH;i++) {\n        \n        if(i < 5){\n            float p0 = float(text[i-1])-65.;\n            float p1 = float(text[i])-65.;\n\n            vec3 c0 = vec3(mod(p0, 3.), -floor(p0/3.), 0.0);\n            vec3 c1 = vec3(mod(p1, 3.), -floor(p1/3.), 0.0);\n            d = min(d, sdCapsule(p-offset1, c0, c1, r));\n\n            vec3 c01 = vec3(mod(p0, 3.), -floor(p0/3.), 0.0);\n            vec3 c11 = vec3(mod(p1, 3.), -floor(p1/3.), 0.0);\n            d = min(d, sdCapsule(p-offset3, c01, c11, r));\n        }\n        else if(i >= 6 && i < 10){\n            float p0 = float(text[i-1])-65.;\n            float p1 = float(text[i])-65.;\n\n            vec3 c0 = vec3(mod(p0, 3.), -floor(p0/3.), 0.0);\n            vec3 c1 = vec3(mod(p1, 3.), -floor(p1/3.), 0.0);\n            d = min(d, sdCapsule(p-offset2, c0, c1, r));\n        }\n        else if(i >= 11){\n            float p0 = float(text[i-1])-65.;\n            float p1 = float(text[i])-65.;\n\n            vec3 c0 = vec3(mod(p0, 3.), -floor(p0/3.), 0.0);\n            vec3 c1 = vec3(mod(p1, 3.), -floor(p1/3.), 0.0);\n            d = min(d, sdCapsule(p-offset4, c0, c1, r));\n\n            vec3 c01 = vec3(mod(p0, 3.), -floor(p0/3.), 0.0);\n            vec3 c11 = vec3(mod(p1, 3.), -floor(p1/3.), 0.0);\n            d = min(d, sdCapsule(p-offset5, c01, c11, r));\n        }\n\t}\n    return d;\n    \n}\n\n\n\nvec3 march(in vec3 ro, in vec3 rd, inout float t){\n\n    vec3 p = ro+rd;\n    for(int i = 0; i < STEPS; ++i){\n        float d = sdf(p);\n        t += d;\n        p += rd*d;\n        \n        if(d < 0.01 || t > FAR){\n            break;\n        }\n        \n    }\n    return p;\n}\n\n\n// Functio to set camera\n// o = camera origin\n// target = camera target (lookAt)\n// cr = right angle\nmat3 setCamera(vec3 o, vec3 target, float cr ){\n\tvec3 cw = normalize(target-o);//z\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);//up\n\tvec3 cu = normalize( cross(cw,cp) );//x\n\tvec3 cv = normalize( cross(cu,cw) );//y\n\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 v = -1.0+2.0*uv;\n    v.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(cos(iTime*0.5)*8.5, 0.0, sin(iTime*0.5)*8.5);\n    vec3 rt = vec3(0.0, 0.0, 0.0);\n    \n    mat3 cam = setCamera(ro, rt, 0.);\n    vec3 rd = normalize(cam*vec3(v.xy, radians(90.)));\n    \n    float t = 0.01;\n    vec3 p = march(ro, rd, t);\n    \n    if(t > FAR){\n        fragColor = vec4(1.0);\n    }\n    else{\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    \n\t\n\t/*vec2 p = 100.*uv;// + .02 * sin(5. * iTime * vec2(uv) + 10.*6.28*uv);\n\tvec2 offset1 = vec2(1.4, 5.5);\n    vec2 offset2 = vec2(1.4*2.7, 5.5);\n    vec2 offset3 = vec2(1.4*4.3, 5.5);\n\t\n\tfloat d = MAXD;\n    \n    for (int i=1;i<LENGTH;i++) {\n        \n        if(i < 5){\n            float p0 = float(text[i-1])-65.;\n            float p1 = float(text[i])-65.;\n\n            vec2 c0 = offset1+vec2(mod(p0, 3.), -floor(p0/3.));\n            vec2 c1 = offset1+vec2(mod(p1, 3.), -floor(p1/3.));\n            d = min(d, line(p, c0, c1));\n\n            vec2 c01 = offset3+vec2(mod(p0, 3.), -floor(p0/3.));\n            vec2 c11 = offset3+vec2(mod(p1, 3.), -floor(p1/3.));\n            d = min(d, line(p, c01, c11));\n        }\n        else if(i >= 6){\n             float p0 = float(text[i-1])-65.;\n            float p1 = float(text[i])-65.;\n\n            vec2 c0 = offset2+vec2(mod(p0, 3.), -floor(p0/3.));\n            vec2 c1 = offset2+vec2(mod(p1, 3.), -floor(p1/3.));\n            d = min(d, line(p, c0, c1));\n        }\n\t}\n    \n\tvec3 color = vec3(smoothstep(0., .05, d));\t\n\tfragColor = vec4(color,1.0);*/\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdlyWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[349, 381, 418, 418, 546], [548, 548, 599, 599, 726], [728, 728, 746, 870, 2735], [2739, 2739, 2789, 2789, 3009], [3012, 3113, 3160, 3160, 3354], [3356, 3356, 3413, 3413, 5001]]}
{"id": "XdlyzS", "name": "isovalues 2b", "author": "FabriceNeyret2", "description": "better seen in fullscreen\n\nAnalytical derivatives version, allowing thinner lines.", "tags": ["noise", "contour"], "likes": 12, "viewed": 947, "published": "Public API", "date": "1488732629", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// analytical derivatives version of https://www.shadertoy.com/view/MdfcRS\n\n// --- noise from procedural pseudo-Perlin ( adapted from IQ ) ---------\n\nfloat noise3( vec3 x , out vec2 g) {\n    vec3 p = floor(x),f = fract(x),\n        F = f*f*(3.-2.*f);  // or smoothstep     // to make derivative continuous at borders\n\n#define hash3(p)  fract(sin(1e3*dot(p,vec3(1,57,-13.7)))*4375.5453)        // rand\n    \n    float v000 = hash3(p+vec3(0,0,0)), v100 = hash3(p+vec3(1,0,0)),\n          v010 = hash3(p+vec3(0,1,0)), v110 = hash3(p+vec3(1,1,0)),\n          v001 = hash3(p+vec3(0,0,1)), v101 = hash3(p+vec3(1,0,1)),\n          v011 = hash3(p+vec3(0,1,1)), v111 = hash3(p+vec3(1,1,1));\n    \n    g.x = 6.*f.x*(1.-f.x)                        // gradients\n          * mix( mix( v100 - v000, v110 - v010, F.y),\n                 mix( v101 - v001, v111 - v011, F.y), F.z);\n    g.y = 6.*f.y*(1.-f.y)\n          * mix( mix( v010 - v000, v110 - v100, F.x),\n                 mix( v011 - v001, v111 - v101, F.x), F.z);\n    \n    return mix( mix(mix( v000, v100, F.x),       // triilinear interp\n                    mix( v010, v110, F.x),F.y),\n                mix(mix( v001, v101, F.x),       \n                    mix( v011, v111, F.x),F.y), F.z);\n}\n\n\nfloat noise(vec3 x, out vec2 g) {     // pseudoperlin improvement from foxes idea \n    vec2 g0,g1;\n    float n = (noise3(x,g0)+noise3(x+11.5,g1)) / 2.;\n    g = (g0+g1)/2.;\n    return n;\n}\n\n\nvoid mainImage( out vec4 O, vec2 U ) // ------------ draw isovalues\n{\n    vec2 R = iResolution.xy;\n    U *= 8./R.y;\n    vec2 g;\n    float n = noise(vec3(U,.1*iTime), g),\n          v = sin(6.28*10.*n);\n    //g = vec2(dFdx(n),dFdy(n));\n    //O = vec4( sin(10.*atan(g.y,g.x)), v, 0,0); return; // debug\n    g *= 6.28*10.*cos(6.28*10.*n) * 8./R.y;\n  //v = tanh(2.*abs(v) / (abs(g.x)+abs(g.y))); // better antialiasing than smoothstep\n    v = tanh(min(2.*abs(v) / (abs(g.x)+abs(g.y)),10.)); // some systems dislike tanh(big)\n    n = floor(n*20.)/20.;\n\tO = v * (.5+.5*cos(12.*n+vec4(0,2.1,-2.1,0)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdlyzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 150, 186, 186, 1226], [1229, 1229, 1262, 1311, 1416], [1419, 1419, 1488, 1488, 2014]]}
{"id": "XdscDS", "name": "Ray-traced Spheres", "author": "Yetman", "description": "A Simple scene of physically-incorrect ray-traced Spheres.", "tags": ["3d", "raytracing", "sphere"], "likes": 3, "viewed": 503, "published": "Public API", "date": "1489664628", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI  3.14159265\n#define PI2 6.28318531\n\n#define SIZE 25\n#define DELTA PI2/float(SIZE/2)\n#define BACKCOLOR_LOWER vec4(0.1,0.3,0.45,1)\n#define BACKCOLOR_UPPER vec4(0,0.025,0.05,1)\n#define DONT_DRAW_MAIN_SPHERE 0\n#define AA\n//#define BLINN\n#define ACES_TM\n//#define EXPOSURE_TM\n//#define REINHARD_TM\n//#define GAMMA_CORRECTION\n\n\nconst float ball_speed = 0.25;\nconst float light_speed = 0.25;\nconst vec3 mainCenter = vec3(0,0,20);\nconst float rotationRadius = 12.0;\nconst float mainRadius = 10.0;\nconst float subRadius = 1.0;\n\nconst vec3 albedo0 = vec3(0.7,0.6,0.1);\nconst vec3 ambient0 = vec3(0.1,0.1,0.05);\nconst vec3 albedo1 = vec3(0.6,0.05,0.1);\nconst vec3 ambient1 = vec3(0.1,0,0.05);\nconst vec3 albedo2 = vec3(0.05,0.6,0.1);\nconst vec3 ambient2 = vec3(0,0.1,0.05);\n\nstruct sphere\n{\n    vec3 center;\n    float radius;\n    vec3 albedo;\n    vec3 ambient;\n};\n\nstruct directional_light\n{\n    vec3 direction;\n};\n\nstruct ray\n{\n    vec3 start;\n    vec3 direction;\n};\n\nstruct ray_hit\n{\n    int idx;\n    float dist;\n};\n\nsphere spheres[SIZE];\ndirectional_light light;\n\nray_hit raySphereIntersect(in ray r, in sphere s)\n{\n    vec3 L = s.center - r.start;\n    float proj = dot(r.direction, L);\n    float dis2 = dot(L,L) - proj*proj;\n\tfloat r2 = s.radius * s.radius;\n    if(dis2 > r2) return ray_hit(-1,proj);\n    float db = sqrt(r2 - dis2);\n    float x = proj - db;\n\tif(x < 0.0) return ray_hit(-1,x);\n\treturn ray_hit(0, x);\n}\n\nray_hit sceneIntersect(in ray r, in int begin, in int end, in int except)\n{\n    ray_hit res = ray_hit(-1,1e12);\n    for(int i = begin; i < end; i++){\n        if(i != except){\n        \tray_hit ires = raySphereIntersect(r, spheres[i]);\n            if(ires.idx >= 0 && ires.dist < res.dist) res = ray_hit(i, ires.dist);\n        }\n    }\n    return res;\n}\n\nvec3 rotfn(float val, float val2)\n{\n    float cosval = cos(val);\n    return normalize(vec3(cos(val2)*cosval,sin(val2)*cosval,sin(val)));\n}\n\nvec4 simplephong(in ray r, in ray_hit h)\n{\n    vec3 point = r.start + h.dist * r.direction;\n    ray_hit lightRes = sceneIntersect(ray(point, -light.direction), DONT_DRAW_MAIN_SPHERE, SIZE, h.idx);\n    vec3 normal = (point - spheres[h.idx].center)/spheres[h.idx].radius;\n    float fresnel = 0.2*pow(1.0+dot(r.direction,normal), 4.0);\n    if(lightRes.idx < 0)\n    {\n        float diffuse = max(dot(-light.direction, normal), 0.0);\n        #ifdef BLINN \n        float specular = pow(max(0.0, -dot(normal, normalize(light.direction + r.direction))), 140.0);\n        #else\n        float specular = pow(max(0.0, -dot(r.direction, reflect(light.direction, normal))), 70.0);\n        #endif\n        return vec4((diffuse+fresnel)*spheres[h.idx].albedo + spheres[h.idx].ambient + specular*vec3(1),1);\n    }\n    else\n        return vec4(fresnel*spheres[h.idx].albedo + spheres[h.idx].ambient,1);\n}\n\nvec4 reflectivephong(in ray r, in ray_hit h)\n{\n    vec3 point = r.start + h.dist * r.direction;\n    ray_hit lightRes = sceneIntersect(ray(point, -light.direction), DONT_DRAW_MAIN_SPHERE, SIZE, h.idx);\n    vec3 normal = normalize(point - spheres[h.idx].center);\n    float fresnel = 0.2*pow(1.0+dot(r.direction,normal), 4.0);\n    vec4 reflected = vec4(0,0,0,1);\n    vec3 refDir = reflect(r.direction, normal);\n    ray_hit refRes = sceneIntersect(ray(point, refDir), DONT_DRAW_MAIN_SPHERE, SIZE, h.idx);\n    if(refRes.idx >= 0){\n        reflected = simplephong(ray(point, refDir), refRes);\n    } else {\n        reflected = mix(BACKCOLOR_LOWER,BACKCOLOR_UPPER,(refDir.y+1.0)/2.0);\n    }\n    if(lightRes.idx < 0)\n    {\n        float diffuse = max(dot(-light.direction, normal), 0.0);\n        #ifdef BLINN \n        float specular = pow(max(0.0, -dot(normal, normalize(light.direction + r.direction))), 140.0);\n        #else\n        float specular = pow(max(0.0, -dot(r.direction, reflect(light.direction, normal))), 70.0);\n        #endif\n        return vec4((diffuse+fresnel)*spheres[h.idx].albedo + spheres[h.idx].ambient + 0.9*reflected.rgb + specular*vec3(1,1,1),1);\n    }\n    else\n        return vec4(fresnel*spheres[h.idx].albedo + spheres[h.idx].ambient + 0.9*reflected.rgb,1);\n}\n\nvec3 coord2dir(vec2 coord)\n{\n    float aspectRatio = iResolution.x/iResolution.y;\n\tvec2 uv = coord / iResolution.xy;\n    uv = (2.0*uv - 1.0)*vec2(aspectRatio,1);\n    return normalize(vec3(uv, 1.0));\n}\n\n#ifdef ACES_TM\n//ACES Filmic Tonemapping Approximation \n//From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm( vec3 x )\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n#endif\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 start = vec3(0,0,0);\n    \n    float stime = iTime*ball_speed;\n    float lstime = iTime*light_speed;\n    \n    light.direction = normalize(vec3(cos(lstime),cos(lstime),sin(lstime)));\n    \n    spheres[0] = sphere(mainCenter, mainRadius, albedo0, ambient0);\n    for(int i = 1; i < SIZE/2+1; i++){\n        spheres[i] = sphere(mainCenter - rotationRadius*rotfn(stime+DELTA*float(i), stime+PI/4.0),\n                            subRadius, albedo1, ambient1);\n    }\n    for(int i = SIZE/2+1; i < SIZE; i++){\n        spheres[i] = sphere(mainCenter - rotationRadius*rotfn(stime+DELTA*float(i)+ DELTA/2.0, stime-PI/4.0),\n                            subRadius, albedo2, ambient2);\n    }\n    \n    fragColor = vec4(0);\n    float depth = 0.0;\n    #ifdef AA\n    for(int i = -1; i < 2; i++){\n        for(int j = -1; j < 2; j++) {\n            vec3 direction = coord2dir(fragCoord+vec2(i,j)/2.0);\n            #else\n            vec3 direction = coord2dir(fragCoord);\n            #endif\n            ray_hit res = sceneIntersect(ray(start, direction), DONT_DRAW_MAIN_SPHERE, SIZE, -1);\n            if(res.idx < 0) {\n                fragColor += mix(BACKCOLOR_LOWER,BACKCOLOR_UPPER,(direction.y+1.0)/2.0);\n                depth += 1000.0;\n            }\n            else {\n                fragColor += reflectivephong(ray(start, direction), res);\n                depth += res.dist;\n            }\n            #ifdef AA\n        }\n    }\n    fragColor /= 9.0;\n    depth /= 9.0;\n    #endif\n    #ifdef ACES_TM\n    //ACES Filmic ToneMapping\n    fragColor = vec4(ACESFilm(fragColor.rgb), 1.0);\n    #elif defined(EXPOSURE_TM)\n    //Exposure ToneMapping\n    const float exposure = 1.0;\n    fragColor = vec4(vec3(1.0) - exp(-fragColor.rgb * exposure), 1.0);\n    #elif defined(REINHARD_TM)\n    //Reinhard Tonemapping\n    fragColor /= vec4((fragColor + vec4(1.0)).rgb, 1.0);\n    #endif\n    #ifdef GAMMA_CORRECTION\n    // Gamma correction \n    const float gamma = 2.2;\n    fragColor = pow(fragColor, vec4(1.0 / gamma));\n    #endif\n    fragColor.a = (mainCenter.z - depth)/mainRadius;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdscDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[260, 1067, 1118, 1118, 1421], [1423, 1423, 1498, 1498, 1773], [1775, 1775, 1810, 1810, 1913], [1915, 1915, 1957, 1957, 2800], [2802, 2802, 2848, 2848, 4081], [4083, 4083, 4111, 4111, 4283], [4621, 4621, 4678, 4678, 6740]]}
{"id": "XdScRR", "name": "[ Famous curves ] - #4", "author": "Yrai", "description": "#4 - Epicycloid", "tags": ["2d", "rotation", "parametric", "epicycloid", "geometryblending"], "likes": 6, "viewed": 492, "published": "Public API", "date": "1490477650", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/*\n   Epicycloid facts:\n  ----------------\n\t- (a) There are four curves which are closely related: epicycloid, epitrochoid, hypocycloid, and\n\t\t  the hypotrochoid. They are all traced by a point P on a circle of radius b which rolls\n          around a fixed circle of radius a.\n\t- (b) For an epicycloid, the circle of radius b rolls on the outside of the circle of radius a. The\n          point P is on the edge of the circle of radius b.\n\t- (c) If a = b: cardioid.\n    - (d) If a = 2b, nephroid.\n*/\n\n#define res_            iResolution\n#define time_           iTime\n#define trace_len_      222\n#define eps_            2.\n\n#define crot(a)  mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvec2  domain(vec2 uv, float s);\nvec2  parametric(float t);\nfloat trace(vec2 p, float t);\nfloat _union_soft(float a, float b, float r);\n\nvoid mainImage(out vec4 o, vec2 f) {\n\tvec2 p = domain(f, 5.);\n  \tp *= crot(time_*.2);\n    \n    // t -> [0., 5.]\n    float t = time_;\n    \n    // Astroid traces\n    float dtrace = smoothstep(0.08, 0.001, trace(p, t));\n    float dtrace_s0 = smoothstep(0.16, 0.001, trace(p, t));\n    \n    // Axis\n    float ax = min(\n        smoothstep(0., 0.02, abs(p.x)),\n        smoothstep(0., 0.02, abs(p.y))\n    );\n    // Origin\n    float org = smoothstep(0.09, 0., length(p)-.01);\n    \n    // Palette \n    vec3 gray   = vec3(.2);\n    vec3 white  = vec3(5.);\n    \n    // Shading\n    vec3 c  = vec3(0.);\n    c = mix(c, gray, fract(1.-ax));\n    c = mix(c, white, org);\n    \n    c = mix(c, vec3(0., 0.3, 1.), dtrace_s0);\n    c = mix(c, gray, dtrace*p.x);\n    c = mix(c, vec3(.1, 1.3, .1), dtrace*abs(p.y)*length(p));\n    c = mix(c, vec3(.1, 1.3, .1), dtrace*-abs(p.y)*length(p));\n    \n    c.b += dtrace_s0;\n    \n    \n    o = vec4(c, 1.);\n}\n\nfloat _union_soft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\nvec2 parametric(float t) {\n\tfloat a = 2.;\n    float b = 1.2;\n    return vec2( (a+b)*cos(t) - b*cos((a/b + 1.) * t), (a+b)*sin(t) - b*sin((a/b + 1.) * t) );\n}\n\nfloat trace(vec2 p, float t) {\n    float d = 1e10;\n    float e = 0.;\n    for(int i = 0; i < trace_len_; i++) {\n    \td  = _union_soft(d, distance(p, parametric(t-e)), sin(time_)*.5);\n        e += eps_; \n    }\n    return d;\n}\n\nvec2 domain(vec2 uv, float s) {\n    return (2. * uv.xy - res_.xy) / res_.y * s;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdScRR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[89, 900, 936, 936, 1821], [1823, 1823, 1869, 1869, 1939], [1941, 1941, 1967, 1967, 2098], [2100, 2100, 2130, 2130, 2323], [2325, 2325, 2356, 2356, 2406]]}
{"id": "XdscRS", "name": "1d perlin noise", "author": "qu1795", "description": "a simple example for 1d perlin noise.", "tags": ["noise", "perlinnoise", "1d", "1dperlinnoise"], "likes": 9, "viewed": 762, "published": "Public API", "date": "1488723782", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(float i)\n{\n    //%in 1d, return a slope\n\tfloat h = i * 127.1;\n\tfloat p = -1. + 2. * fract(sin(h) * 43758.1453123);\n    return p;//sin(p*6.283 + iTime);\n}\nfloat perlin_noise_1d(float d)\n{\n    float i = floor(d);\n    float f = d - i;\n\n    //%interpolation\n    //float y = 6.0 * pow(f, 5.0) - 15.0 * pow(f, 4.0) + 10.0 * pow(f, 3.0);\n    float y = f*f*f* (6. * f*f - 15. * f + 10.);\n\n    float slope1 = hash(i);\n    float slope2 = hash(i + 1.0);\n    float v1 = f;\n    float v2 = f - 1.0;\n\n    float r = mix(slope1 * v1, slope2 * v2, y);\n    r = r * 0.5 + 0.5; //%map to range 0 ~ 1\n    return r;\n}\nfloat perlin_noise_1d_sum(float x)\n{\n    const float persistence = 0.4;\n    const float frequence = 1.0;\n    float amp = persistence,\n        \tfreq = frequence;\n    float total = 0.0;\n\tfor(int i = 0; i < 5; ++i)\n    {\n    \ttotal += perlin_noise_1d(x * freq) * amp;\n        \n        amp *= persistence;\n        freq *= 2.0;\n    }\n    \n    return total;\n}\nvoid mainImage(out vec4 fragColor,  in vec2 fragCoord)\n{\n    float noiseY = perlin_noise_1d(iTime + fragCoord.x * 0.01);\n    float cy = noiseY - fragCoord.y / iResolution.y;\n    cy = smoothstep(0.0, 1.0 / iResolution.y, cy); //for AA purpose\n    fragColor = mix(vec4(1.0), vec4(0.0), 1.0 - cy);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdscRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 50, 164], [165, 165, 197, 197, 605], [606, 606, 642, 642, 959], [960, 960, 1016, 1016, 1256]]}
{"id": "XdscWX", "name": "Bullet", "author": "NCSylvia", "description": "Bullet moving towards target", "tags": ["2d"], "likes": 1, "viewed": 65, "published": "Public", "date": "1490178230", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map (vec3 p) {\n    \n    vec3 q = fract(p) * 2.0 - 1.0;\n        \n    return length(q) - 0.25;\n    \n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    for(int i = 0; i < 32; ++i) {\n       vec3 p = o+r*t;\n        float d = map(p);\n        t += d*1.0;\n    }\n    return t;\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec4 col = vec4(0,0,0,1);\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -= 0.5;\n    \n    if(length(uv) < 0.15 && uv.x > -0.05) {\n        \n        col = mix(vec4(0.52,0.4,0,1), vec4(0.), length(uv));\n        col = mix(col, vec4(0), smoothstep(0.0, 0.2, uv.y));\n        col = mix(col, vec4(0), smoothstep(0.0, -0.2, uv.y));\n    }\n    else {\n        \n    uv = uv*2.0-0.4;\n    uv.x = iResolution.x/iResolution.y;\n    vec3 r = normalize(vec3(uv, 0.8));\n    float time = iTime;\n    vec3 o = vec3(0.0, 0.0, time);\n    float t = trace(o,r);\n    float fog = 1.0/ (1.0 + t * t * 0.1);\n    vec3 fc =  vec3(fog);\n    \n        col = vec4(fc, 2.0);\n    }\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdscWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 105], [107, 107, 136, 136, 280], [282, 282, 339, 339, 1016]]}
{"id": "XdsyWf", "name": "PBRT Cook-Torrance", "author": "AngryBaguette", "description": "WIP", "tags": ["raymarching", "sdf", "signeddistancefield", "brdf", "pbrt"], "likes": 4, "viewed": 303, "published": "Public", "date": "1490366846", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cook-Torrance implementation and Schilck/Beckmann/Smith approximation\n//\n// References:\n// Mathematics for 3d Game Programming & Computer Graphics (second edition)\n// http://simonstechblog.blogspot.fr/2011/12/microfacet-brdf.html\n// http://graphicrants.blogspot.fr/2013/08/specular-brdf-reference.html\n// http://renderwonk.com/publications/s2010-shading-course/gotanda/course_note_practical_implementation_at_triace.pdf\n// https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n//\n// Distance function\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\nconst float GRAD_STEP = 0.1;\nconst float PI_4 = 0.78539816339744;\nconst float PI_2 = 1.57079632679489;\nconst float PI = 3.14159265358979;\nconst float PI2 = 6.28318530717958;\n\n// sqrt(2/PI)\nconst float GSchilkFactor = 0.79788456080286;\n\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct MaterialPhong\n{\n    vec3 Ka;\n    vec3 Kd;\n    vec3 Ks;\n    float e;\n};\n  \n// For typical dielectric materials, n is between 1.3 and 1.7    \nstruct MaterialPBR\n{\n    vec3 Kd;\n    vec3 Ks;\n    float m; \t// roughness 0.0 - 1.0\n    float n;\t// reflectance 1.0 20.0\n};\n\nstruct Light\n{\n    vec3 P;\t\t// pos\n    vec3 Kd;\t// diff\n    vec3 Ks;\t// spec\n    float I;\t// intensity\n};\n    \n// Union\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\n// Substraction\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// Intersection\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n// Twist operator\nvec3 opTwist( vec3 p, float sa )\n{\n    float c = cos(sa*p.y);\n    float s = sin(sa*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\n// Box\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// Sphere\nfloat sdSphere( vec3 p, float r )\n{\n     return length(p)-r;\n}\n\nfloat sdCircle(vec2 uv, vec2 center, float r)\n{\n    vec2 c = (uv - center);\n    return 1.0-clamp(dot(c,c)/r,0.0,1.0);\n}\n    \n// Rotation matrix from euler angle (radian)\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\n\n// The scene\nfloat sdScene(vec3 p)\n{     \n    // twist\n\t//p = fromEuler( vec3(0.0,0.0,p.y) ) * p;\n    p = opTwist(p, 0.5);\n    \n    //return sdSphere(p,1.0);\n    //return sdBox(p,vec3(0.75,0.75,0.5));\n    //return opS( sdSphere(p,1.0), sdBox(p,vec3(0.75,0.75,0.5)) );\n    //return opS( sdBox(p,vec3(0.8,0.8,0.5)), sdSphere(p,1.0) );\n    return opU( sdBox(p,vec3(2.0,2.0,2.0)), sdSphere(p,2.7) );\n}\n\n// Compute through gradient\nvec3 sdSceneNormal(vec3 p) \n{\n    return normalize(vec3(\n        sdScene(vec3(p.x + GRAD_STEP, p.y, p.z)) - sdScene(vec3(p.x - GRAD_STEP, p.y, p.z)),\n        sdScene(vec3(p.x, p.y + GRAD_STEP, p.z)) - sdScene(vec3(p.x, p.y - GRAD_STEP, p.z)),\n        sdScene(vec3(p.x, p.y, p.z  + GRAD_STEP)) - sdScene(vec3(p.x, p.y, p.z - GRAD_STEP))\n    ));\n}\n\n// Ray marching algorithm\nfloat sdRayMarching(Ray ray, float start, float end)\n{\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sdScene(ray.origin + depth * ray.direction);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n// Compute ray\nRay sdRay(vec3 origin, vec2 frag, vec2 res, float fov)\n{\n    Ray ray;\n    ray.origin = origin;\n    vec2 xy = frag - res / 2.0;\n    float z = res.y / tan(fov / 2.0);\n    ray.direction = normalize(vec3(xy, -z));\n    \n    return ray;\n}\n\n\n// Ka,Kd,Ks : Ambient/Diffuse/Specular\n// Ki : intensity\n// e : Specular exponent\n//\n// E : Eye position\n// P : Pixel position\n// N : Normal\n// LP : Light Position\nvec3 Phong(vec3 Ka, vec3 Kd, vec3 Ks, float Ki, float e, vec3 E, vec3 P, vec3 N, vec3 LP)\n{\n    vec3 color = Ka;\n    vec3 L = normalize(LP-P);\n    vec3 V = normalize(E-P);\n    vec3 R = reflect(-L,N);\n    //vec3 H = normalize(V + R);\n    \n    float NDotL = dot(N,L);\n    if(NDotL < 0.0)\n    {\n        return color;\n    }\n    \n    // Diffuse\n    color += NDotL * Kd;\n    \n    // Specular or NDotH\n    float NDotR = max(0.0, dot(V,R));\n    color += pow(NDotR, e) * Ks;\n    \n    return color;\n}\n\n// Fresnel term Cook-Torrance\nfloat FCook(float LDotH, float n)\n{\n    float gmLdotH = (n-LDotH);\n    float gpLdotH = (n+LDotH);\n    float a = (LDotH * gpLdotH - 1.0);\n    float b = (LDotH * gmLdotH + 1.0);\n    float ab = a / b;\n    ab *= ab;\n    return 0.5 * (gmLdotH*gmLdotH) / (gpLdotH*gpLdotH) * ( ab+1.0 );\n}\n\n// Fresnel term Schilk approximation\nfloat FSchilck(float LDotH, float n)\n{\n    float f0 = (1.0-n)/(1.0+n);\n    f0 *= f0;     \n    return f0 + (1.0 - f0) * pow(1.0-LDotH,5.0);\n}\n\n// Cook-Torrance distribution\n// m : roughness\n// ref : Book\nfloat DCook(float NDotH, float m)\n{\n    float NDotH2 = NDotH * NDotH;\n    float NDotH2m = NDotH2 * m * m;\n    return exp((NDotH2 - 1.0) / NDotH2m) / ( 4.0 * NDotH2 * NDotH2m);\n}\n\n// Blinn distribution\nfloat DBlinn(float NDotH, float m)\n{\n    // Blinn distribution\n    float shininess = 2.0 / ( m * m ) - 2.0;\n    return ( shininess + 2.0 ) / 2.0 * pow( NDotH, shininess );\n}\n\n// Beckmann distribution (isotropic)\n// m : roughness\n// ref : http://simonstechblog.blogspot.fr/2011/12/microfacet-brdf.html\nfloat DBeck(float NDotH, float m)\n{\n    float NDotH2 = NDotH * NDotH;\n    float NDotH2m = NDotH2 * m * m;\n    return exp((NDotH2 - 1.0) / NDotH2m) / (PI * NDotH2 * NDotH2m);\n}\n\n// GGX / Trowbridge-Reitz (isotropic)\n// [Walter et al. 2007, \"Microfacet models for refraction through rough surfaces\"]\nfloat DGGX(float NDotH, float m)\n{\n   \tfloat m2 = m * m;\n\tfloat d = ( NDotH * m2 - NDotH ) * NDotH + 1.0;\n\treturn m2 / ( PI*d*d );\n}\n\n// Geometric term Smith using Schlick approximation\nfloat GSmith(float LDotH, float m)\n{\n    float k = m*GSchilkFactor;\n    float f = LDotH / (LDotH*(1.0-k)+k);\n    return f*f;\n}\n    \n// Geometry term is used for describing how much the microfacet is blocked by other microfacet\nfloat GCook(float NDotH, float NDotV, float LDotH, float NDotL)\n{\n    float a = 2.0 * NDotH / LDotH;\n    return min(1.0, min(NDotV,NDotL)*a);  \n}\n\n// GImplicit\n// It is called implicit because when it is used, the microfacet BRDF will only depends on Fresnel equation and distribution function\nfloat GImplicit(float NDotV, float NDotL)\n{\n\treturn NDotL * NDotV;\n}\n\n// E : Eye position\n// P : Pixel position\n// N : Normal\n// LP : Light Position\nvec3 CookTorrance(MaterialPBR material, vec3 E, vec3 P, vec3 N, vec3 LP)\n{\n    vec3 L = normalize(LP-P);\n    float NDotL = dot(N,L);\n    if(NDotL <= 0.0)\n    {\n        return vec3(0.0,0.0,0.0);\n    }\n    \n    vec3 V = normalize(E-P);\n    vec3 H = normalize(L+V);\n        \n    float NDotV = min(dot(N,V) + 1e5,1.0);\n    float NDotH = dot(N,H);\n    float LDotH = dot(L,H); // == dot(V,H)\n    \n    \n    // Compute Fresnel factor\n    float Fs = FCook(LDotH, material.n);\n    float Fd = FCook(NDotL, material.n);\n    //float Fd = FSchilck(LDotH, material.n);\n    \n    // Compute Distribution Factor\n    //float D = DCook(NDotH, material.m);\n    //float D = DBeck(NDotH, material.m);\n    float D = DGGX(NDotH, material.m);\n    \n    // Compute Geometrical Factor\n    //float G = GImplicit(NDotV,NDotL);\n    //float G = GCook(NDotH, NDotV, LDotH, NDotL);\n    float G = GSmith(LDotH,material.m);\n    \n    vec3 Spec = material.Ks * Fs * D * G / ( PI * NDotV * NDotL); \n    vec3 Diff = material.Kd * (1.0 - Fd) ;\n    return (Spec + Diff) * vec3(1.0) * NDotL;\n}\n\n\n// E : Eye position\n// P : Pixel position\n// N : Normal\n// LP : Light Position\nvec3 BRDF2(MaterialPBR material, vec3 E, vec3 P, vec3 N, vec3 LP)\n{\n    vec3 L = normalize(LP-P);\n    float NDotL = dot(N,L);\n    if(NDotL <= 0.0)\n    {\n        return vec3(0.0,0.0,0.0);\n    }\n    \n    vec3 V = normalize(E-P);\n    vec3 H = normalize(L+V);\n        \n    float NDotV = min(dot(N,V) + 1e5,1.0);\n    float NDotH = dot(N,H);\n    float LDotH = dot(L,H); // == dot(V,H)\n    \n    // Compute Distribution Factor\n    //float D = DCook(NDotH, material.m);\n    //float D = DBeck(NDotH, material.m);\n    float D = DGGX(NDotH, material.m);\n    \n    // Compute Geometrical Factor\n    //float G = GImplicit(NDotV,NDotL);\n    //float G = GCook(NDotH, NDotV, LDotH, NDotL);\n    float G = GSmith(LDotH,material.m);\n    \n    // Compute Fresnel factor\n    // Smith approx\n    vec3 Fs = material.Ks * (1.0 - material.Ks) * pow(1.0 - LDotH, 5.0);\n    vec3 Fd = material.Ks * (1.0 - material.Ks) * pow(1.0 - NDotL, 5.0);    \n    \n\tvec3 Spec = Fs * D * G / ( NDotV * NDotL * PI );\n\tvec3 Diff = material.Kd * ( 1.0 - Fd );\n    return (Spec + Diff) * vec3(1.0) * NDotL;\n}\n\n// Unreal fashion Fresnel term\n// E : Eye position\n// P : Pixel position\n// N : Normal\n// LP : Light Position\n// TriAce : http://renderwonk.com/publications/s2010-shading-course/gotanda/course_note_practical_implementation_at_triace.pdf\nvec3 BRDF3(MaterialPBR material, vec3 E, vec3 P, vec3 N, vec3 LP)\n{\n    vec3 L = normalize(LP-P);\n    float NDotL = dot(N,L);\n    if(NDotL <= 0.0)\n    {\n        return vec3(0.0,0.0,0.0);\n    }\n    \n    vec3 V = normalize(E-P);\n    vec3 H = normalize(L+V);\n        \n    float NDotV = min(dot(N,V) + 1e5,1.0);\n    float NDotH = dot(N,H);\n    float LDotH = dot(L,H); // == dot(V,H)\n    \n    // Compute Distribution Factor\n    //float D = DCook(NDotH, material.m);\n    //float D = DBeck(NDotH, material.m);\n    float D = DGGX(NDotH, material.m);\n    \n    // Compute Geometrical Factor\n    //float G = GImplicit(NDotV,NDotL);\n    //float G = GCook(NDotH, NDotV, LDotH, NDotL);\n    float G = GSmith(LDotH,material.m);\n    \n    // Compute Fresnel factor\n    // Smith approx\n    vec3 Fs = material.Ks * (1.0 - material.Ks) * pow(1.0 - LDotH, 5.0);\n    vec3 Fd = material.Ks * (1.0 - material.Ks) * pow(1.0 - NDotL, 5.0);    \n    \n\tvec3 Spec = Fs * D * G / ( NDotV * NDotL * PI );\n\tvec3 Diff = material.Kd * ( 1.0 - Fd );\n    return (Spec + Diff) * vec3(1.0) * NDotL;\n}\n                                          \nvec3 Light1(vec3 E, vec3 P, vec3 N)\n{\n    // Light position\n    vec3 LP = vec3(0.0, 0.0, 6.0);\n    \n    mat3 rot = fromEuler( vec3(0.0, iTime*0.5, iTime*0.5) );\n    LP = rot * LP;\n    \n    \n\n        // Material\n    MaterialPBR material;\n    material.Kd = vec3(1.0,0.71,0.29);\n    material.Ks = vec3(1.0,1.0,1.0);\n    material.m = 0.03;\n    material.n = 1.0;\n    \n    //return Phong(vec3(0.0), material.Kd, material.Ks, 1.0, 64.0, E, P, N, LP);\n    \n    return CookTorrance( material, E, P, N, LP);\n    //return BRDF2( material, E, P, N, LP);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    vec3 E = vec3(0.0, 0.0, 15.0);\n    Ray ray = sdRay(E, fragCoord.xy, iResolution.xy, PI_4);\n    \n    //mat3 rot = fromEuler( vec3(0.0, iTime, iTime) );\n    //ray.origin = rot * ray.origin;\n    //ray.direction = rot * ray.direction;\n    \n        \n    vec3 color = vec3(0.0);\n    float d = sdRayMarching( ray, MIN_DIST, MAX_DIST);\n    if(d < MAX_DIST)\n    {\n        vec3 P = ray.origin + ray.direction * d;\n        vec3 N = sdSceneNormal(P);\n        \n        // Apply Light\n        color += Light1(E,P,N);\n    }\n    else\n    {\n        // No intersection\n        color = vec3(0.3,0.3,0.3);\n    }\n    \n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdsyWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1419, 1428, 1461, 1461, 1486], [1488, 1504, 1537, 1537, 1563], [1565, 1581, 1614, 1614, 1639], [1641, 1659, 1693, 1693, 1825], [1827, 1834, 1865, 1865, 1952], [1954, 1964, 1999, 1999, 2026], [2028, 2028, 2075, 2075, 2147], [2153, 2198, 2224, 2224, 2570], [2572, 2585, 2608, 2669, 2969], [2971, 2999, 3028, 3028, 3344], [3346, 3372, 3426, 3426, 3734], [3736, 3751, 3807, 3807, 3983], [3986, 4150, 4241, 4241, 4640], [4642, 4672, 4707, 4707, 4954], [4956, 4993, 5031, 5031, 5133], [5135, 5196, 5231, 5231, 5373], [5375, 5397, 5433, 5459, 5570], [5572, 5698, 5733, 5733, 5873], [5875, 5996, 6030, 6030, 6128], [6130, 6182, 6218, 6218, 6308], [6314, 6409, 6474, 6474, 6554], [6556, 6703, 6746, 6746, 6771], [6773, 6852, 6926, 6926, 7901], [7904, 7983, 8050, 8050, 9043], [9045, 9282, 9349, 9349, 10342], [10386, 10386, 10423, 10445, 10929], [10931, 10931, 10988, 10988, 11637]]}
{"id": "XdXcDB", "name": "star SIRIUS", "author": "zproxy", "description": "via https://www.shadertoy.com/view/lsfyzf", "tags": ["star"], "likes": 2, "viewed": 97, "published": "Public", "date": "1489591443", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by SHAU - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define EPS 0.001\n#define FAR 50.0 \n#define PI 3.1415\n#define IGT iTime\n\nfloat rand1(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat audio_freq(in sampler2D channel, in float f) {return texture(channel, vec2(f, 0.25)).x;}\nvec3 sound = vec3(0.0);\n\nstruct DistInfo {\n    float d;\n    vec3 lc;\n};\n    \nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\n//http://mercury.sexy/hg_sdf/\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0 * PI / repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a / angle);\n\ta = mod(a,angle) - angle / 2.0;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions / 2.0)) c = abs(c);\n\treturn c;\n}\n\n//modified version of IQs box distance function \n//bc: box center; w: box width\nfloat sdSpikeBox(vec3 rp, vec3 bc, float w) {\n    vec3 b = vec3(w) + length(rp - bc) * 0.5;\n    vec3 d = abs(rp - bc) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));;\n}\n\nfloat dfScene(vec3 rp) {\n    \n    // up to down\n    rp.yz *= rot(IGT * 0.0125);\n    //pModPolar(rp.yz, 5.0);\n    \n    // left to right\n    rp.xy *= rot(IGT * 0.0125);\n    //pModPolar(rp.yx, 16.);\n    return sdSpikeBox(rp,  \n                      \n                      vec3(\n                          0.0, \n                          0.2 , \n                          0.0), \n                      \n                      0.0000);\n}\n\n// Used for Fade effect\nfloat mapTo(float x, float minX, float maxX, float minY, float maxY) {\n    float a = (maxY - minY) / (maxX - minX);\n    float b = minY - a * minX;\n    return a * x + b;\n}\n\n//Shane - hue rotation. I think I'vereturn sdSpikeBox(rp,  vec3(0.0, 1.5 + smoothstep(0., 1., sound.w), 0.0), w); used this in pretty much all of my shaders so far :)\nvec3 rotHue(vec3 p, float a){\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n    return clamp(p*hr, 0., 1.);\n}\n\nfloat raytraceFloor(vec3 ro, vec3 rd, vec3 n, vec3 o) {\n\treturn dot(o - ro, n) / dot(rd, n);\n}\n\n\n\n\n\nDistInfo marchScene(vec3 ro, vec3 rd) {\n    \n    DistInfo di = DistInfo(0., vec3(0.));\n    vec3 rp = vec3(0.0); //ray position\n    \n    for (int i = 0; i < 65; i++) {\n        rp = ro + rd * di.d;\n        float ns = dfScene(rp);\n        di.d += ns;\n        if (ns < EPS || di.d > FAR) break;\n        vec3 col = abs(rp);\n        di.lc += 0.0001 / (ns * ns) * col; //distance field light contribution\n    }\n    return di;\n}\n\n\n\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n \n \n//From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\n//Very happy with this star function, cheap and smooth\nvec3 stars(in vec3 p)\n{\n    // 47fps\n    \n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.5; // too small  and they will flicker\n    \n    // more stars?\n\tfor (float i=0.;i<1.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.7;\n}\n\nvec3 startrails(in vec3 rd)\n{\n    // do not move. we got a blinking star we would need to move too. \n    vec3 col0 = stars( normalize(rotx(rd, iTime * 0.00)));\n\n    vec3 col = col0;\n\n    // our blinky star is fixed via ro? we dont know how to rotate it all in sync yet.\n    \n    if (false)\n    for (int i = -30; i < 0; i++)\n    {\n    \tvec3 col1 = stars( normalize(rotx(rd, iTime * 0.01 + (float(i) * (1./600.) ))));\n        \n    \tcol += col1;    \n    }\n    \n    return col;\n}\n\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1. - c;\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n \n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec3 pc = vec3(0.); //pixel colour\n\n    for (int i = 0; i < 10; i++) {\n        if (i < 3) {\n            sound.x += audio_freq(iChannel0, float(i));    \n        } else if (i < 7) {\n            sound.y += audio_freq(iChannel0, float(i));    \n        } else {\n            sound.z += audio_freq(iChannel0, float(i));    \n        }\n    }\n    \n    //coordinate system\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, 2.));\n    \n    \n    \n    \n    \n    \n    float mousex = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n\n    \n    float mousey = (2.0*iMouse.y-iResolution.y) / iResolution.y;\n   \n    \n    \n    \n       \n    if (abs(mousey) < 1.0)\n    \trd *=  rotationMatrix(vec3(1., 0., 0.), radians(16. * mousey));\n    \n    // allow limited interacton\n    rd *=  rotationMatrix(vec3(0., 1., 0.), radians(0. + 2. * 16. * -mousex));\n\n    \n    // looks good for 2D viewport\n    rd *=  rotationMatrix(vec3(0., 0., 1.), radians(float(iFrame) * 0.1  ));\n    //rd *=  rotationMatrix(vec3(0., 0., 1.), radians(float(iFrame) * 0.1  ));\n \n    //rd *=  rotationMatrix(vec3(0., 1., 0.), radians(-270. * -mousex));\n    \n    \n    \n    \n    //vec3 ro = vec3(0.0, 1.0, -0.5);\n    \n    // now its small .\n    //vec3 ro = vec3(0.0, 0.0, -3.0);\n\n    // start top right, and have it all slowly rotate\n    vec3 ro = vec3(-0.0, -0.0, -2.0);\n    // neg x looses color?\n\n    \n    //rotate camera\n    //ro.xy *= rot(sin(IGT) * 0.25);\n    //rd.xy *= rot(sin(IGT) * 0.25); \n    //ro.xz *= rot(IGT);\n    //rd.xz *= rot(IGT);    \n    //ro.yz *= rot(sin(IGT) * 0.125);\n    //rd.yz *= rot(sin(IGT) * 0.125); \n\t//\n    //raytace floor \n    vec3 fn = vec3(0, 1, 0); //floor normal\n\t//float fd = raytraceFloor(ro, rd, fn, vec3(0, -10.0, 0)); //floor distance\n\n    DistInfo di = marchScene(ro, rd);\n    \n    \n       \n    pc += startrails( rd);\n    \n    // 20fps / \n   \n    //if (false)\n    //if (fd > 0.0 && fd < FAR) {\n    //    //disco floor\n    //    vec3 rp = ro + rd * fd; //ray surface intersection\n    //    rp.x += IGT * 0.; //moving checkerboard\n    //    vec2 m  = mod(rp.xz, 4.0) - 2.0;\n    //    vec3 sc = \n    //        m.x * m.y > 0. ? rotHue(vec3(1., 0., 0.), mod(IGT / 16., 6.283)) : vec3(0., 0., 0.);      \n    //    sc *= clamp(pow(sound.z, 2.) * 2., 0.3, 3.0);\n    //    pc += sc / length((m * m) - 1.); \n    //    //fade\n    //\tfloat z = mapTo(fd, 0.0, FAR, 1.0, 0.0);\n    //    //pc = mix(vec3(0.), pc, z * z);\n    //}\n   //\n    //sparkly thing\n    \n    //pc += di.lc;\n    //pc += rotHue(di.lc, mod(IGT / 0.01, 6.283));\n    pc += rotHue(di.lc, mod(IGT / 0.001, 6.283));\n    \n   // //pixel effect from Virgil\n   // float klang1 = sound.z;\n   // vec2 uv2 = -0.3 + 2.0 * fragCoord.xy / iResolution.xy;\n   // pc -= 0.020 * (1.0 -klang1) * rand1(uv2.xy * IGT);\t\t\t\t\t\n   // vec2 g =  .9 + .2 * (1.-klang1) * sin(10.* IGT + uv2 * iResolution.xy);\n   // pc *= g.x * g.y; \n   // \n    fragColor = vec4(pc, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdXcDB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 186, 208, 208, 281], [282, 282, 334, 334, 376], [454, 454, 473, 473, 525], [527, 670, 720, 720, 1123], [1125, 1205, 1250, 1250, 1398], [1400, 1400, 1424, 1447, 1828], [1830, 1854, 1924, 1924, 2024], [2026, 2193, 2222, 2222, 2581], [2583, 2583, 2638, 2638, 2677], [2683, 2683, 2722, 2722, 3103], [3108, 3108, 3135, 3135, 3223], [3228, 3288, 3309, 3309, 3452], [3454, 3509, 3532, 3545, 4027], [4029, 4029, 4058, 4129, 4504], [4507, 4507, 4552, 4552, 5018], [5023, 5023, 5078, 5078, 8081]]}
{"id": "XdXcDf", "name": "ArtDovWater", "author": "ArtDov", "description": "WaterArtDov", "tags": ["artdov"], "likes": 16, "viewed": 323, "published": "Public", "date": "1490275929", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.141593;\nconst float KPT180 = 0.017453;\nconst float WATER_AMP = 0.35;\nconst float WATER_FRECQ = 4.97;\nconst float WAVE_LENGHT = 5.1;\nconst float WAVE_SPEED = 7.8;\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n#define WATER_TIME (iTime*WAVE_SPEED/6.0)\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(16.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\nfloat frequency(float l) {\n\tfloat w = 2.0*PI/l;\n    return w;\n}\nfloat phase(float w, float speed){\n\tfloat phase = speed*w;\n    return phase;\n}\nfloat waveHeight(float amplitude, vec2 directional, vec2 uv, float w, float time, float phasa){\n    float waveH = float(amplitude* dot(directional, uv) * w +phasa * time);\n\treturn waveH;\n}\nfloat wave_shape(vec2 uv){\n\tvec2 waveShape = 1.0-abs(cos(uv));\n    vec2 smoothWaveShape = abs(sin(uv));\n    waveShape = -(mix(waveShape, smoothWaveShape, waveShape)) + 1.0;\n    return pow(1.0-pow(waveShape.x * waveShape.y,0.6),0.67);\n}\nvec3 rotXAxis(vec3 Directional, float teta){\n    teta = KPT180*teta;\n    Directional.yz *= mat2(cos(teta), sin(teta), -sin(teta), cos(teta));\n    return Directional;\n}\nvec3 rotYAxis(vec3 Directional, float teta){\n    teta = KPT180*teta;\n    Directional.xz *= mat2(cos(teta), -sin(teta), sin(teta), cos(teta));\n    return Directional;\n}\nvec3 rotZAxis(vec3 Directional, float teta){\n    teta = KPT180*teta;\n    Directional.xy *= mat2(cos(teta), -sin(teta), sin(teta), cos(teta));\n    return Directional;\n}\nfloat map(vec3 position){\n    float amplitude = WATER_AMP;\n    float l = WAVE_LENGHT;\n    float s = WAVE_SPEED;\n\tfloat waveH = 0.0; \n    float dif = 0.0;\n    float w = frequency(l);\n    float p = phase(w,s);\n    vec2 directional = vec2(1.1,1.1);\n    vec2 uv = position.xz;\n        for(int i = 0; i<4; i++){\n            dif =  wave_shape(w *(uv+WATER_TIME));\n            dif += wave_shape(w *(uv-WATER_TIME));\n            waveH += dif * amplitude;\n            w*=1.2; amplitude*=0.6;\n        }\n    return  (position.y - waveH) ;\n}\n\nfloat Trace(vec3 origin, vec3 directional, out vec3 position){\n    float t = 0.0;\n    for (int i = 0; i <32; i++){\n        vec3 position = origin + directional * t;\n       \tfloat dif = map(position);\n        t += dif * 0.9;\n    }\n    return t;\n}\n\nfloat mapCircle(vec3 p){\n   return length(p) - 1.0;\n}\nfloat TraceSun(vec3 origin, vec3 directional, out vec3 position){\n    float t = 0.0;\n    for (int i = 0; i <16; i++){\n        vec3 position = origin + directional * t + vec3(0.0,-7.0,-10.0);\n        position.x *=0.78;\n       \tfloat dif = mapCircle(position);\n        t += dif * 0.6;\n    }\n    return t;\n}\n//use float cool)))\nvec3 GradientMap(vec3 heightMap){\nreturn mix(vec3(0.9,0.92,0.91),vec3(0.0,0.5,0.85), heightMap);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n    \n{\n   \t//Init UV\n   \tvec2 uv = fragCoord.xy/iResolution.xy;\n   \tuv = 2.0*uv - 1.0;\n   \tuv.x *= iResolution.x/iResolution.y;\n\t\n    //Init Space \n    vec3 origin = vec3(WAVE_SPEED,1.4,-1.0); \n    vec3 directional = normalize(vec3(uv,1.0)) ;\n    directional = rotXAxis(directional, -60.0 * fract(iTime*0.006));\n    directional = rotZAxis(directional, 0.0);\n    directional = rotYAxis(directional, 15.0);\n    \n    \n   \t//Trace\n    vec3 position = vec3(0.0,0.0,0.0) ;\n    float t = Trace(origin, directional, position);\n    vec3 dist = origin - position;\n    \n    //TraceSun\n    vec3 SunPosition = vec3(0.0);\n    vec3 DirectionalSun = normalize(vec3(uv,1.0)) ;\n    vec3 originSun = vec3(0.0,0.0,0.0); \n    float tSun = TraceSun(originSun, DirectionalSun, SunPosition);\n    \n    //Height Map\n    vec3 hm;\n    float attenuation = 1.0 /(1.0 +t*t*0.08);\n    hm = vec3(attenuation);\n    \n    //HeightMapSun\n    vec3 hms;\n    float attenuationSun = 2.0 /(1.0 +tSun*tSun*0.08);\n    hms = vec3(attenuationSun);\n    \n    //Diffuse\n    vec3 gm; \n    gm = GradientMap(hm);\n    \n    //DiffuseSun\n    hms =1.0* hms*vec3(0.8,0.7,0.1);\n    \n    //Gamma corection\n    float gamma = 1.6;\n    gm = pow(gm, vec3(1.0/gamma));\n    \n    //SumColor\n    vec3 fc = gm + hms;\n\tfragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdXcDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 201, 201, 239], [283, 283, 303, 303, 370], [372, 372, 393, 393, 591], [592, 592, 613, 613, 703], [704, 704, 730, 730, 767], [768, 768, 802, 802, 846], [847, 847, 942, 942, 1035], [1036, 1036, 1062, 1062, 1271], [1272, 1272, 1316, 1316, 1439], [1440, 1440, 1484, 1484, 1607], [1608, 1608, 1652, 1652, 1775], [1776, 1776, 1801, 1801, 2305], [2307, 2307, 2369, 2369, 2552], [2554, 2554, 2578, 2578, 2607], [2608, 2608, 2673, 2673, 2912], [2913, 2933, 2966, 2966, 3031], [3032, 3032, 3094, 3108, 4365]]}
{"id": "XdXcWX", "name": "Green Screen Psychadelic", "author": "jgreen23", "description": "green screen  test", "tags": ["tutorial"], "likes": 2, "viewed": 125, "published": "Public", "date": "1490215334", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = 3.1415926535897;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 z, c;\n    int maxIterations = 256;\n    c = uv;\n    z = c;\n    vec4 color;\n    float cx = uv.x+0.5*sin(iTime/5.0);\n    float cy = uv.y+0.5*cos(iTime/3.0);\n    \n    float v = sin(sqrt(100.0*(cx*cx+cy*cy)));\n    v += sin(uv.x*10.0+iTime);\n    v += cos(uv.y*4.0+iTime);\n    \n    \n    color = vec4(sin(v*pi), cos(v*pi), sin(v*pi + 0.5*pi*v), 1.0);\n    vec2 xy = fragCoord.xy / iResolution.xy;//Condensing this into one line\n    vec4 texColor = texture(iChannel0,xy);//Get the pixel at xy from iChannel0\n    vec4 texColorB = texture(iChannel1,xy);\n    \n    if (texColor.g < 0.2 && texColor.r < 0.25 && texColor.b < 0.25) //if green screen\n    {\n        fragColor = color;\n    }\n    else\n    {\n\n        color = texColor;\n\t\t\n        if (color.r < 0.3 && color.b < 0.1 && color.g < 0.5)\n        {\n             v += sin(uv.x*10.0+iTime);\n             v += cos(uv.y*4.0+iTime);\n             color = vec4(sin(v*pi), cos(v*pi), sin(v*pi + 0.5*pi*v), 1.0);\n        }\n    \tfragColor = vec4(mix(color.rgb, texColor.rgb, .5), 1);//Set the screen pixel to that c\n    }\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdXcWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1196]]}
{"id": "XlK3Rc", "name": "stinky bones 001", "author": "expertmouser", "description": "first shader!\nworking out metaballs.\nfreaky shader is freaky.", "tags": ["metaballs", "n00b"], "likes": 1, "viewed": 460, "published": "Public API", "date": "1488349562", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat sqr(float x) {\n    return x * x;\n}\n\nvec2 screenToWorld(vec2 sp) {\n    const float screenSize = 6.;\n    vec2 fp = ( sp.xy / iResolution.y );\n    fp.x = fp.x * screenSize - (screenSize * iResolution.x / iResolution.y) / 2.;\n    fp.y = fp.y * screenSize - screenSize / 2.;\n    \n    return fp;\n}\n\nvec2 warp(vec2 wp, float f, float s, float ts) {\n\tvec2 ret;\n    \n    vec2 v;\n\n    v.x = wp.x * cos(iTime * ts) + wp.y * sin(iTime * ts);;\n    v.y = wp.x * sin(iTime * ts) - wp.y * cos(iTime * ts);;\n    \n    ret.x = wp.x + cos(v.y * f) * s;\n    ret.y = wp.y + cos(v.x * f) * s;\n    \n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fp = screenToWorld( gl_FragCoord.xy );\n    \n    \n    const float spd1 =   1.01;\n    const float spd2 =  -1.21;\n    const float r    =  2.0;\n    float gt1 = spd1 * iTime;\n    float gt2 = spd2 * iTime;\n    \n    vec2 cp1 = vec2(sin(gt1), cos(gt1)) * r;\n    vec2 cp2 = vec2(sin(gt2), cos(gt2)) * r;\n    cp2 = screenToWorld(iMouse.xy);\n    \n    vec2 fpw1 = warp(fp,  5.0, 0.3,  0.3);\n    vec2 fpw2 = warp(fp, 17.0, 0.2, -0.1);\n   \n    float d = 0.0;\n    float d1 = max(distance(fpw1, cp1) + 0.3 , 0.0);\n    float d2 = max(distance(fpw2 ,cp2) + 0.5, 0.0);\n    d = d1 * d2 * 0.3;\n    d = 1.0 - (d * d);\n//    d = sin(d * 0.4) * 4.0;\n    if (d > 0.0) {\n        float od1 = distance(fp, cp1);\n        float od2 = distance(fp, cp2);\n        d = sin((od1 * od2 - iTime * 1.0) * 4.0) * 0.1 + 0.24;\n        fragColor = vec4(0.75 - d, 0, d, 1.0);\n    }\n    else if (d < -1.0) {\n        float od1 = distance(fp, cp1);\n        float od2 = distance(fp, cp2);\n        d = sin((od1 * od2 + iTime * 4.0) * 1.7) * 0.1 + 0.9;\n        fragColor = vec4(d, 1.7 - d, 0.0, 1.0);\n    }\n    else {\n    \td = abs(d - 0.5);\n    \tfragColor = vec4(-d);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlK3Rc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 41], [43, 43, 72, 72, 298], [300, 300, 348, 348, 599], [601, 601, 658, 658, 1794]]}
{"id": "XsBczz", "name": "Box Ellipsoid Distance", "author": "yasuo", "description": "It's just testing own distance function.", "tags": ["raymarching", "distancefunction", "ellipsoid"], "likes": 2, "viewed": 514, "published": "Public API", "date": "1490546271", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NEAR 0.01\n#define FAR 128.\n#define ITER 128\n\nmat4 matRotateX(float rad)\n{\n    return mat4(1,       0,        0,0,\n                0,cos(rad),-sin(rad),0,\n                0,sin(rad), cos(rad),0,\n                0,       0,        0,1);\n}\n\nmat4 matRotateY(float rad)\n{\n    return mat4( cos(rad),0,-sin(rad),0,\n                0,       1,        0,0,\n                sin(rad),0, cos(rad),0,\n                0,       0,        0,1);\n}\n\nmat4 matRotateZ(float rad)\n{\n    return mat4(cos(rad),-sin(rad),0,0,\n                sin(rad), cos(rad),0,0,\n                0,        0,1,0,\n                0,        0,0,1);\n}\n\nmat3 mat3RotateX(float rad)\n{\n    return mat3(1,       0,        0,\n                0,cos(rad),-sin(rad),\n                0,sin(rad), cos(rad));\n}\n\nfloat sdCustomEllipsoid(vec3 p){\n    vec3 q = (p);\n    float a = (1.0+abs(cos(iTime*0.5))*1.2);\n    float b = (0.6+cos(sin(iTime*0.5))*0.6);\n    return max(abs(q.z)-(1.5+abs(cos(iTime*0.5)*2.0)),max(pow(q.x*0.1/a,2.0)+pow(q.y*0.1/b,2.0),abs(q.y)*0.01)-1.0);\n}\n\nvec4 map( vec3 pos, mat4 m)\n{\n    vec4 q = vec4(pos+vec3(0,0,-80.0),1.0)*m;\n\n    vec3 bodyColor = vec3(0.2,0.9,0.4);\n\n    vec4 rotatedPos1 = (q+vec4( 0, 0, 0, 1.0));\n\n    vec4 val1 = vec4(bodyColor,sdCustomEllipsoid(rotatedPos1.xyz ));\n\n    return val1;\n}\n\nvec2 rot(vec2 p, float a) {\n    return vec2(\n        cos(a) * p.x - sin(a) * p.y,\n        sin(a) * p.x + cos(a) * p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 position = ( fragCoord.xy / iResolution.xy );\n    position -= .5;\n    vec3 dir = vec3( position, 1.0 );\n\n    float aspect = iResolution.x / iResolution.y;\n    dir = normalize(vec3(position * vec2(aspect, 1.0), 1.0));\n    dir.yz = rot(dir.yz, 0.2);\n\n    vec3 pos = vec3(0.0, 10.0, 20.0);\n    mat4 m = matRotateY(iTime)*matRotateZ(iTime);\n\n    vec4 result;\n    int march = 0;\n    for (int i = 0; i < ITER; i++)\n    {\n        result = map(pos, m);\n        march = i;\n        if (result.w < NEAR || result.w > FAR) break;\n        pos += result.w * dir;\n    }\n\n    vec3 col = map(pos, m).xyz;\n    vec4 bgCol;\n    if ( pos.z> 100. )\n    {\n        // bg\n        float temp = length(vec2(position.xy))+0.9;\n        col = vec3(.3,.3,.3)/vec3(temp);\n    }\n    else\n    {\n        //http://prideout.net/blog/?p=22\n        // shade\n\n        vec3 lightPos = vec3(20.0, 20.0, 20.0 );\n        vec3 light2Pos = normalize( lightPos - pos);\n        vec3 eps = vec3( .1, .01, .0 );\n        vec3 n = vec3( result.w - map( pos - eps.xyy, m ).w,\n                      result.w - map( pos - eps.yxy, m ).w,\n                      result.w - map( pos - eps.yyx, m ).w );\n        n = normalize(n);\n\n        float lambert = max(.0, dot( n, light2Pos));\n        col *= vec3(lambert);\n        col += vec3(result.xyz);\n    }\n\n    fragColor = vec4( col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsBczz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 81, 81, 244], [246, 246, 274, 274, 438], [440, 440, 468, 468, 617], [619, 619, 648, 648, 765], [767, 767, 799, 799, 1026], [1028, 1028, 1057, 1057, 1283], [1285, 1285, 1312, 1312, 1406], [1408, 1408, 1465, 1465, 2805]]}
{"id": "XsfcRX", "name": "PS20", "author": "CarebearDrew", "description": "private", "tags": ["private"], "likes": 0, "viewed": 65, "published": "Public", "date": "1489022977", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 red = vec3(1.0,.0,.0);\nvec3 brown = vec3(0.87,0.72,0.52);\nmat2 rotate2d(float angle)\n{\n  return mat2(cos(angle), - sin(angle), sin(angle), cos(angle));   \n}\nfloat Rectangle (vec2 size,vec2 move, vec2 uv){\n\n  \tfloat value = step(move.y,uv.y) - step(move.y+size.y,uv.y);\n    value *= step(move.x,uv.x) - step(move.x+size.x,uv.x);\n    \n    return value;\n   \n}\nvec2 rotation(vec2 pos,vec2 uv)\n{\n    uv -= pos;\n    uv *= rotate2d(iTime);\n    uv += pos;\n    return uv;\n    \n}\nfloat Circle(vec2 pos,float rad, vec2 uv){\t    \n    float value = step(distance(uv,vec2(0.4)),rad);\n    \n    if(distance(pos,uv) > rad)return 0.0;\n    else return 1.0;\n    return value;\n}\nfloat Flower(vec2 uv,vec2 shapePos, float Petals){\n    shapePos = vec2(shapePos.x,shapePos.y);\n    float dist = distance(shapePos,uv)*2.;\n    uv -= shapePos;\n    \n    float angle = atan(uv.y,uv.x);\n    float radius = cos(Petals*angle);\n    return radius;\n    \n}\nfloat rand(vec2 uv){\n    //return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Gradient noise\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p ){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tfloat T = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    //float value = step(0.48+noise(uv*20.+iTime)*0.05,uv.x) - step(0.50+noise(uv*20.+iTime)*0.05,uv.x);\n    float value;\n    vec3 color;\n    \n    //value = Circle(vec2(.5+noise(uv*5.+T)*0.15,0.3+noise(uv*5.+T)*0.15),0.15,(uv));\n   \t//color += value;\n    \n    uv.x *= ratio;\n    //value *= noise(uv*iTime);\n    \n    //color += value * red;\n    \n   \t//color += value*noise(uv);\n    \n    //float zoom = 8.;\n    //float scale = .02;\n    //float offset = noise(uv*zoom+iTime)*scale;\n    //value = step(.5+offset,uv.x) - step(0.52+offset,uv.x);\n    \n    //color += value*red;\n    \n    \n    //value = Flower(uv,vec2(0.5+noise(uv*20.+iTime)*0.05,0.5+noise(uv*20.+iTime)*0.05),8.);\n\t//color += value* red;\n    \n    //value = Circle(vec2(0.5*ratio+snoise(uv*20.+iTime)*0.15,0.6+gnoise(uv*20.+iTime)*0.15),0.05,(uv));\n   \t//color += value *red;\n    //value = Circle(vec2(0.3*ratio+snoise(uv*20.+iTime)*0.15,0.8+gnoise(uv*20.+iTime)*0.15),0.07,(uv));\n   \t//color += value;\n    //value = Circle(vec2(0.7*ratio+snoise(uv*20.+iTime)*0.15,0.8+gnoise(uv*20.+iTime)*0.15),0.07,(uv));\n   \t//color += value;\n    //value = Circle(vec2(0.6+snoise(uv*20.+iTime)*0.15,0.35+gnoise(uv*20.+iTime)*0.15),0.1,(uv));\n   \t//color += value;\n    //value = Circle(vec2(0.9+snoise(uv*20.+iTime)*0.15,0.2+gnoise(uv*20.+iTime)*0.15),0.1,(uv));\n   \t//color += value;\n    //value = Circle(vec2(1.2+snoise(uv*20.+iTime)*0.15,0.35+gnoise(uv*20.+iTime)*0.15),0.1,(uv));\n   \t//color += value;\n    \n    \n    value = Rectangle(vec2(0.05,0.3),vec2(1.0+noise(uv*2.+T)*0.1,0.3+noise(uv+T)*0.1),uv);\n   \tcolor += value*brown;\n    value = Rectangle(vec2(0.05,0.3),vec2(1.1+noise(uv*2.+T)*0.1,0.3+noise(uv+T)*0.1),uv);\n   \tcolor += value*brown;\n    value = Rectangle(vec2(0.7,0.15),vec2(0.45+noise(uv*2.+T)*0.1,0.25+noise(uv*20.+T)*0.05),uv);\n   \tcolor += value*brown;\n    \n    fragColor = vec4(color,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfcRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 91, 91, 161], [162, 162, 209, 209, 361], [362, 362, 395, 395, 474], [475, 475, 517, 517, 662], [663, 663, 713, 713, 924], [925, 925, 945, 1120, 1186], [1188, 1203, 1228, 1228, 1739], [1741, 1759, 1817, 1817, 1955], [1957, 1957, 1983, 1983, 2381], [2383, 2400, 2421, 2421, 2468], [2469, 2469, 2490, 2490, 2537], [2538, 2538, 2560, 2560, 2595], [2597, 2597, 2619, 2619, 3667], [3670, 3670, 3727, 3727, 5700]]}
{"id": "XsfcWB", "name": "GRAPROG Creature-Adona", "author": "bruiser531", "description": "I tried making a Squid", "tags": ["rip"], "likes": 0, "viewed": 79, "published": "Public", "date": "1489572726", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 uv)\n{\n    \n\treturn (fract(sin(dot(uv, vec2(12., 70.)))*1000.));\n    \n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nfloat createPolygon(int sides, vec2 uv, float ratio, float x, float y, float rotate)\n{\n    vec2 coor = vec2(x, y);\n    uv -= vec2(coor.x *ratio, coor.y);\n    float a = atan(uv.x,uv.y)+ 3.14159265359 + rotate;\n\tfloat r = 6.28318530718 / float(sides);\n    float dist = cos(floor(.5+a/r)*r-a)*length(uv);\n    \n    return dist;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv *= ratio;\n    uv *= 20.0;\n    float value = step(15.0 + noise(uv + (iTime) * 2.0), uv.y) - step(15.5 + noise(uv + (iTime) * 2.0), uv.y);\n    value += step(17.0 + noise(uv + (iTime) * 2.0), uv.y) - step(17.5 + noise(uv + (iTime) * 2.0), uv.y);\n    value += step(13.0 + noise(uv + (iTime) * 2.0), uv.y) - step(13.5 + noise(uv + (iTime) * 2.0), uv.y);\n    value += (1.0 - step(7.0, createPolygon(3, uv + noise(uv + iTime), ratio, 15.5, 16.0, 0.52)));\n\tfragColor = vec4(vec3(value), 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfcWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 86], [88, 103, 128, 128, 639], [641, 641, 727, 727, 966], [969, 969, 1026, 1026, 1611]]}
{"id": "XsfcWf", "name": "RocketToMouse", "author": "NCSylvia", "description": "Rocket moves to mouse location", "tags": ["2drocket"], "likes": 1, "viewed": 99, "published": "Public", "date": "1490188463", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map (vec3 p) {\n    \n    vec3 q = fract(p) * 2.0 - 1.0;\n        \n    return length(q) - 0.25;\n    \n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    for(int i = 0; i < 32; ++i) {\n       vec3 p = o+r*t;\n        float d = map(p);\n        t += d*0.5;\n    }\n    return t;\n}\n\n\nvec4 createRocket(vec2 pos, vec2 uv) {\n    \n   \n   vec4 col = mix(vec4(0.), vec4(1.), smoothstep(pos.x-0.035, pos.x, uv.x)); \n    col.rgb = mix(vec3(0.), col.rgb, smoothstep(pos.x+0.035, pos.x, uv.x));\n   \n   return col;\n    \n}\n\nvec4 createRocketTop(vec2 pos, vec2 uv) {\n    \n    vec2 p0 = vec2(pos.x - 0.03, pos.y);\n    vec2 p1 = vec2(pos.x + 0.03, pos.y);\n    vec2 p2 = vec2(pos.x, pos.y+0.1);\n    vec4 col = mix(vec4(0.12, 0.02, 0.20, 1), vec4(0,0,0, 1), length(pos));\n    \n    float area = 0.5 *(-p1.y*p2.x + p0.y*(-p1.x + p2.x) + p0.x*(p1.y - p2.y) + p1.x*p2.y);\n    \n    float s = 1.0/(2.0*area)*(p0.y*p2.x - p0.x*p2.y + (p2.y - p0.y)*uv.x + (p0.x - p2.x)*uv.y);\n    float t = 1.0/(2.0*area)*(p0.x*p1.y - p0.y*p1.x + (p0.y - p1.y)*uv.x + (p1.x - p0.x)*uv.y); \n    if(s > 0.0 && t > 0.0 && 1.0-s-t > 0.0) {\n        \n       //col = vec4(1,0,0,1);\n       col = mix(vec4(0.), vec4(0.87,0.04,0,1), smoothstep(pos.x-0.035, pos.x, uv.x)); \n    col.rgb = mix(vec3(0.), col.rgb, smoothstep(pos.x+0.035, pos.x, uv.x)); \n    }\n    else {\n        col = mix(vec4(0.), vec4(0.01,0.4,0.7,1), smoothstep(pos.x-0.035, pos.x, uv.x)); \n    col.rgb = mix(vec3(0.), col.rgb, smoothstep(pos.x+0.035, pos.x, uv.x)); \n    }\n     return col;\n    \n    \n}\n\n\nvec4 createRocketFire(vec2 pos, vec2 uv, float time) {\n    \n    vec2 p0 = vec2(pos.x - 0.025, pos.y);\n    vec2 p1 = vec2(pos.x + 0.025, pos.y);\n    vec2 p2 = vec2(pos.x, pos.y-0.1);\n    vec4 col = vec4(0,0,0,1); \n    \n    float area = 0.5 *(-p1.y*p2.x + p0.y*(-p1.x + p2.x) + p0.x*(p1.y - p2.y) + p1.x*p2.y);\n    \n    float s = 1.0/(2.0*area)*(p0.y*p2.x - p0.x*p2.y + (p2.y - p0.y)*uv.x + (p0.x - p2.x)*uv.y);\n    float t = 1.0/(2.0*area)*(p0.x*p1.y - p0.y*p1.x + (p0.y - p1.y)*uv.x + (p1.x - p0.x)*uv.y);              \n    //vec4 col = mix(vec4(0.12, 0.02, 0.20, 1), vec4(0,0,0, 1), length(pos));\n    if(s > 0.0 && t > 0.0 && 1.0-s-t > 0.0) {\n    \tif(pos.y - (0.3*abs(sin(time))) < uv.y && 0.3*abs(sin(time)) > 0.1) {\n        \tcol = mix(vec4(0.87,0.04,0,1), vec4(.87, 0.34, 0.03, 1), smoothstep(pos.y-0.1, pos.y, uv.y));\n        \tcol.rgb = mix(vec3(0.), col.rgb, smoothstep(pos.x-0.025, pos.x, uv.x)); \n        \tcol.rgb = mix(vec3(0.), col.rgb, smoothstep(pos.x+0.025, pos.x, uv.x));\n       \t}\n    \telse if(pos.y - (0.2*abs(sin(time))) < uv.y && 0.2*abs(sin(time)) < 0.07) {\n        \tcol = mix(vec4(0.87,0.04,0,1), vec4(.87, 0.34, 0.03, 1), length(uv)*4.0);\n        \tcol.rgb = mix(vec3(0.), col.rgb, smoothstep(pos.x-0.025, pos.x, uv.x)); \n        \tcol.rgb = mix(vec3(0.), col.rgb, smoothstep(pos.x+0.025, pos.x, uv.x));\n    \t}\n        \n      \n    }\n    else {\n        discard;\n        //col = mix(vec4(1), vec4(0.78,0.12,0.11,1), smoothstep(pos.x-0.04, pos.x, uv.x)); \n    //col.rgb = mix(vec3(1), col.rgb, smoothstep(pos.x+0.04, pos.x, uv.x));\n    \n    }\n    \n    return col;\n    \n    \n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    \n    vec2 pos =  vec2(0,-0.20);\n    vec4 col = vec4(0,0,0,0);\n    \n    float time = iTime;\n    \n    \n    pos = iMouse.xy / iResolution.xy-0.5; \n    float angle = 0.2;\n    //pos.x =   cos(angle)*pos.x + sin(angle)*pos.y;\n\t//pos.y = - sin(angle)*pos.x + cos(angle)*pos.y;\n    \n    col = mix(vec4(0.12, 0.02, 0.20, 1), vec4(0,0,0, 1), length(pos));\n    \n    \n    \n    if(uv.x < pos.x+0.03 && uv.x > pos.x-0.03 && pos.y-0.2 < uv.y && pos.y > uv.y) {      \n       col = createRocket(pos, uv);\n    }\n    else if(uv.x < pos.x+0.03 && uv.x > pos.x-0.03 && pos.y < uv.y && pos.y+0.1 > uv.y) {      \n       col = createRocketTop(pos, uv);\n    }\n    else if(uv.x < pos.x+0.025 && uv.x > pos.x-0.025 && pos.y-0.3 < uv.y && pos.y-0.2 > uv.y) {      \n       col = createRocketFire(pos-vec2(0,0.2), uv, time);\n    }\n    else {\n    uv = uv*2.0-1.0;\n    uv.x = iResolution.x/iResolution.y;\n    vec3 r = normalize(vec3(uv, 1.0));\n    //float time = iTime;\n    vec3 o = vec3(0.0,time*4.0,0.0);\n    float t = trace(o,r);\n    float fog = 1.0/ (1.0 + t * t * 0.1);\n    vec3 fc =  vec3(fog);\n    \n    col = vec4(fc, 2.0);\n    \n    }\n    \n    \n    \n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfcWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 105], [107, 107, 136, 136, 280], [283, 283, 321, 321, 510], [512, 512, 553, 553, 1517], [1520, 1520, 1574, 1574, 3110], [3112, 3112, 3132, 3132, 3204], [3206, 3206, 3263, 3263, 4469]]}
{"id": "XsfcWj", "name": "Spiral noise experiment", "author": "LukeRissacher", "description": "One for the golfers...", "tags": ["2d", "noise", "triangle"], "likes": 7, "viewed": 240, "published": "Public", "date": "1489960026", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fractal-layered rotated 2d triangle-wave noise (adapted from octaviogood's sin-noise \n// function in Duke's awesome https://www.shadertoy.com/view/lsyXDK ) with cosine color \n// palette courtesy IQ: http://www.iquilezles.org/www/articles/palettes/palettes.htm\nvoid mainImage(out vec4 c, in vec2 p) {\n\tfloat t, a, n, i = 2.;\n    p = .6 * (2. * p.xy - iResolution.xy) / iResolution.y;\n    t = .03 * iTime + .5;\n    n = 1.5 + .5 * cos(9. * t);\n    for (int j = 0; j < 16; j++) {\n        p = p * cos(t) + vec2(-p.y, p.x) * sin(t); // rotate\n        vec2 f = abs(-.5 + fract(p*i)) / i; // 2d triangle waves\n        n -= f.x + f.y;\n        i *= 1.23;\n    }\n    n = smoothstep(.2, 1., 1.-n);\n    c.rgb = .5 + .5 * cos(6.283 * (vec3(.3, .1, 0.) + n + t));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfcWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 263, 302, 302, 752]]}
{"id": "XsfcWX", "name": "2D Disks", "author": "jgreen23", "description": "short tutorial creating disks", "tags": ["disk"], "likes": 0, "viewed": 63, "published": "Public", "date": "1490215318", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//pulled from https://www.shadertoy.com/view/Md23DV\n//minor changes to change disk size and behavior\n\n#define PI 3.1415926\n#define TWOPI 6.2831\n#define sat(x) clamp(x, 0., 1.)\n\n//create a 2-D disk on the screen\nvoid disk(vec2 r, vec2 center, float radius, vec3 color, inout vec3 pixel) {\n\tif( length(r-center) < radius) {\n\t\tpixel = color;\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse -= 0.5;\n    uv -= 0.5;\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; //move coordinates to center of frame\n\t\n\tvec3 bgCol = vec3(0.3);\n    \n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n    \n\tfloat x = 0.2*cos(iTime*5.0);\n    float radius = 0.2 + 0.1*sin(iTime*2.0);\n\tfloat y = 0.3*cos(iTime*5.0 + PI/2.0);\n    \n\tdisk(r, vec2(x, y), radius, col3, pixel);\n\tdisk(r, mouse, 0.2, col1, pixel);\n    \n    x = y * y * 2.;\n    \n\tdisk(r, vec2(x, y * 2.), .11, vec3(x,x,x), pixel);\n    \n\n\t\n\tfragColor = vec4(pixel, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfcWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 211, 287, 287, 343], [345, 345, 402, 402, 1158]]}
{"id": "XsfczB", "name": "cylinder sponge", "author": "russ", "description": "a menger sponge with cylinders instead of cubes. press space for easter egg. ", "tags": ["menger"], "likes": 23, "viewed": 981, "published": "Public API", "date": "1488784194", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int iter =100;\nconst float eps = 0.001, far = 30.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,.8,1); \n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\nfloat DE(vec3 p){\n    float d = cylIntersection(p);\n    float s = 1.;\n    for(int i = 0;i<5;i++){\n        p *= 3.;\n    \ts*=3.;\n    \tfloat d2 = cylUnion(p) / s;\n        float m = texelFetch(iChannel0, ivec2(32, 0), 0).x * 2. - 1.;\n    \td = max(d,m*d2);\n   \t \tp = mod(p+1. , 2.) - 1.; \t\n    }\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * .4;\n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    float s1 = sin(time), c1 = cos(time);\n    float arg = 1.5*sin(time*.7894)*.5 + .5;\n    float s2 = sin(arg), c2 = cos(arg);\n    vec3 ro = vec3(0, .2, 1)*2.5;\n    ro.yz = mat2(c2,-s2,s2,c2)*ro.yz;\n    ro.xz = mat2(c1,s1,-s1,c1)*ro.xz;\n    vec3 rd = getRay(ro, vec3(0.), uv);\n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfczB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 204, 204, 341], [343, 343, 373, 373, 510], [512, 512, 529, 529, 818], [820, 820, 849, 849, 1037], [1039, 1039, 1080, 1080, 1256], [1258, 1258, 1299, 1299, 1451], [1453, 1453, 1474, 1474, 1604], [1606, 1606, 1633, 1633, 1880], [1882, 1882, 1939, 1939, 2506]]}
{"id": "XsfyDM", "name": "Lightsv2", "author": "Glim888", "description": "glim888\n\nMy App´s:\nBluetooth Multiplayer: play.google.com/store/apps/details?id=com.gaming_apps.bluetooth_game_duel\nWater Physics Simulation: play.google.com/store/apps/details?id=com.gaming_apps.water_physics_simulation", "tags": ["gamemakerstudio", "glim888", "lightsv2"], "likes": 2, "viewed": 644, "published": "Public API", "date": "1488389567", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nconst float POINT_SIZE = 0.09;\nconst float BRIGHTNESS = 0.3;\nconst int LIGHT_CNT = 20;\n\nfloat random(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n///point(global time, uv, center of the point, xScale, yScale,deerection, size )\nfloat point(float time, vec2 _uv, vec2 pos, float xs, float ys, vec2 dir, float size)\n{\n   float hypo = distance(vec2(pos.x + mod(time,2.0)* dir.x *xs,\n                              pos.y + mod(time,2.0)* dir.y *ys),_uv);\n    \n   return size / pow(length (hypo),1.8);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-iResolution.xy*0.5) / iResolution.xy;    \n    uv *= 2.0;\n    \n    float col = 0.0;\n    \n    for(int i=0; i<LIGHT_CNT;i++)\n        {\n        col += point(iTime,uv,vec2(sin(iTime + float(i)*0.5)*2.0,4.0), 0.5,4.0,vec2(0.0,-0.8),POINT_SIZE);            \n        }        \n    col *= BRIGHTNESS;\n\n    \n\tfragColor = vec4(1.0*col,1.0*col,1.0*col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfyDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 130, 130, 202], [205, 286, 373, 373, 555], [558, 558, 615, 615, 988]]}
{"id": "XsfyWS", "name": "Resolve", "author": "TimothyLottes", "description": "Comparison of resolve filters", "tags": ["noise", "antialiasing", "filtering", "resolve"], "likes": 8, "viewed": 782, "published": "Public", "date": "1489526631", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// CHANGE THIS MODE DEFINE TO TRY DIFFERENT OPTIONS\n//  \n// Sorry, only looks right at 1920x1080 non-full-screen.\n//\n\n// 0 Red ......... NoAA\n// 1 Orange ...... NoAA + 2x2 Programmable Pixel Locations + Gaussian Resolve \n// 2 Gold ........ NoAA + Jittered Pixel Locations + Noise\n// 3 Yellow ...... NoAA + Jittered Pixel Locations + Gaussian Resolve + Noise\n// 4 Lime ........ 2xSGSSAA + Box Filter\n// 5 Green ....... 2xSGSSAA + Jittered Pixel Locations + Gaussian Resolve + Noise\n// 6 BlueGreen ... 4xSGSSAA + Box Filter\n// 7 Blue ........ 4xSGSSAA + Jittered Pixel Locations + Gaussian Resolve + Noise\n#define MODE 1\n\n//================================================================================\n\n#define F1 float\n#define F2 vec2\n#define F3 vec3\n#define F4 vec4\n\n// Convert from linear to sRGB.\nF1 Srgb(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\n\n// Convert from sRGB to linear.\nF1 Linear(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}    \n\n//\n// Semi-Poor Quality Temporal Noise\n//\n\n// Base.\n// Ripped ad modified from: https://www.shadertoy.com/view/4djSRW\nF1 Noise(F2 p,F1 x){p+=x;\n F3 p3=fract(F3(p.xyx)*10.1031);\n p3+=dot(p3,p3.yzx+19.19);\n return fract((p3.x+p3.y)*p3.z)*2.0-1.0;}\n\n// Step 1 in generation of the dither source texture.\nF1 Noise1(F2 uv,F1 n){\n F1 a=1.0,b=2.0,c=-12.0,t=1.0;   \n return (1.0/max(a*4.0+b*4.0,-c))*(\n  Noise(uv+F2(-1.0,-1.0)*t,n)*a+\n  Noise(uv+F2( 0.0,-1.0)*t,n)*b+\n  Noise(uv+F2( 1.0,-1.0)*t,n)*a+\n  Noise(uv+F2(-1.0, 0.0)*t,n)*b+\n  Noise(uv+F2( 0.0, 0.0)*t,n)*c+\n  Noise(uv+F2( 1.0, 0.0)*t,n)*b+\n  Noise(uv+F2(-1.0, 1.0)*t,n)*a+\n  Noise(uv+F2( 0.0, 1.0)*t,n)*b+\n  Noise(uv+F2( 1.0, 1.0)*t,n)*a+\n 0.0);}\n    \n// Step 2 in generation of the dither source texture.\nF1 Noise2(F2 uv,F1 n){\n F1 a=1.0,b=2.0,c=-2.0,t=1.0;   \n return (1.0/(a*4.0+b*4.0))*(\n  Noise1(uv+F2(-1.0,-1.0)*t,n)*a+\n  Noise1(uv+F2( 0.0,-1.0)*t,n)*b+\n  Noise1(uv+F2( 1.0,-1.0)*t,n)*a+\n  Noise1(uv+F2(-1.0, 0.0)*t,n)*b+\n  Noise1(uv+F2( 0.0, 0.0)*t,n)*c+\n  Noise1(uv+F2( 1.0, 0.0)*t,n)*b+\n  Noise1(uv+F2(-1.0, 1.0)*t,n)*a+\n  Noise1(uv+F2( 0.0, 1.0)*t,n)*b+\n  Noise1(uv+F2( 1.0, 1.0)*t,n)*a+\n 0.0);}\n\n// Compute temporal dither from integer pixel position uv.\nF1 Noise3(F2 uv){return Noise2(uv,fract(iTime));}    \n\n// Energy preserving dither, for {int pixel pos,color,amount}.\nF1 Noise4(F2 uv,F1 c,F1 a){\n // Grain value {-1 to 1}.\n F1 g=Noise3(uv)*2.0;\n // Step size for black in non-linear space.\n F1 rcpStep=1.0/(256.0-1.0);\n // Estimate amount negative which still quantizes to zero.\n F1 black=0.5*Linear(rcpStep);\n // Estimate amount above 1.0 which still quantizes to 1.0.\n F1 white=2.0-Linear(1.0-rcpStep);\n // Add grain.\n return clamp(c+g*min(c+black,min(white-c,a)),0.0,1.0);}\n\n//\n// Pattern\n//\n\n// Dummy shader given pixel position.\nF1 Shade(F2 p){\n p.xy+=sin(iTime)*2.0;\n F2 pp=F2(p.x+p.y/16.0,p.y+p.x/16.0);\n pp*=pp;\n F1 x=sin(pp.x/800.0)>0.0?0.5:0.0;\n F1 y=sin(pp.y/1000.0)>0.0?0.5:0.0;\n return x+y;}\n\n// 4xMSAA pattern for quad given integer coordinates.\n//\n//  . x . . | < pixel\n//  . . . x |\n//  x . . .\n//  . . x .\n//\n//  01\n//  23\n//\nF2 Quad4(F2 pp){\n int q=(int(pp.x)&1)+((int(pp.y)&1)<<1);\n if(q==0)return pp+F2( 0.25,-0.25);\n if(q==1)return pp+F2( 0.25, 0.25);\n if(q==2)return pp+F2(-0.25,-0.25);\n         return pp+F2(-0.25, 0.25);}\n\n// Rotate {0.0,r} by a {-1.0 to 1.0}. \nF2 Rot(F1 r,F1 a){return F2(r*cos(a*3.14159),r*sin(a*3.14159));}\n\n// Rotate {pp} by a {0.0 to 1.0}. \nF2 Rot2(F2 pp,F1 a){\n a*=3.14159*2.0;\n F1 cosA=cos(a);\n F1 sinA=sin(a);\n return F2(dot(pp,F2(cosA,sinA)),dot(pp,F2(-sinA,cosA)));}\n\n//\n// SINGLE SAMPLE RESOLVES\n//\n    \n// Single center sample.\n//\n//  x\n//\nF1 ResolveNoAA(F2 pp){return Shade(pp);}\n\n//\n// FIXED QUAD RESOLVES\n//\n\n// Single center sample using Quad4 sample positions (no filtering).\n//\n//  x\n//\nF1 ResolveQuad4(F2 pp){return Shade(Quad4(floor(pp)));}\n\n// Gaussian filtered.\nvoid Quad4Gaus(inout F1 sumC,inout F1 sumW,F2 pp,F2 mm){\n F2 jj=Quad4(pp);\n F1 c=Shade(jj);\n F2 vv=mm-jj;\n F1 w=exp2(-2.0*dot(vv,vv));    \n sumC+=c*w; sumW+=w;}   \n\n// Single center sample using Quad4 sample positions (with guassian filtering).\n//\n//  . x x x . \n//  x x x x x \n//  x x x x x \n//  x x x x x \n//  . x x x . \n//\nF1 ResolveQuad4Gaus(F2 pp){\n pp=floor(pp);\n F1 sumC=0.0;\n F1 sumW=0.0;\n Quad4Gaus(sumC,sumW,pp+F2(-1.0,-2.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 0.0,-2.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 1.0,-2.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2(-2.0,-1.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2(-1.0,-1.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 0.0,-1.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 1.0,-1.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 2.0,-1.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2(-2.0, 0.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2(-1.0, 0.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 0.0, 0.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 1.0, 0.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 2.0, 0.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2(-2.0, 1.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2(-1.0, 1.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 0.0, 1.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 1.0, 1.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 2.0, 1.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2(-1.0, 2.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 0.0, 2.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 1.0, 2.0),pp);\n return sumC/sumW;}\n\n// Disc filtered.\nvoid Quad4Disc(inout F1 sumC,inout F1 sumW,F2 pp,F2 mm){\n F2 jj=Quad4(pp);\n F1 c=Shade(jj);\n F2 vv=mm-jj;\n // disc contribution (faster than gaussian)\n //  d=distance\n //  r=radius^2 for 1.0\n //  f=radius^2 to drop to 0.0\n F1 r=0.707*1.75;\n F1 f=r+0.707*0.333;\n r=r*r;f=f*f;\n F1 s=1.0/(r-f);\n F1 t=f/(f-r);    \n F1 w=clamp(dot(vv,vv)*s+t,0.0,1.0);\n sumC+=c*w; sumW+=w;}   \n    \n// Single center sample using Quad4 sample positions (with disc filtering).\n//\n//  . x x x . \n//  x x x x x \n//  x x x x x \n//  x x x x x \n//  . x x x . \n//\nF1 ResolveQuad4Disc(F2 pp){\n pp=floor(pp);\n F1 sumC=0.0;\n F1 sumW=0.0;\n Quad4Disc(sumC,sumW,pp+F2(-1.0,-2.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 0.0,-2.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 1.0,-2.0),pp);\n Quad4Disc(sumC,sumW,pp+F2(-2.0,-1.0),pp);\n Quad4Disc(sumC,sumW,pp+F2(-1.0,-1.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 0.0,-1.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 1.0,-1.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 2.0,-1.0),pp);\n Quad4Disc(sumC,sumW,pp+F2(-2.0, 0.0),pp);\n Quad4Disc(sumC,sumW,pp+F2(-1.0, 0.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 0.0, 0.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 1.0, 0.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 2.0, 0.0),pp);\n Quad4Disc(sumC,sumW,pp+F2(-2.0, 1.0),pp);\n Quad4Disc(sumC,sumW,pp+F2(-1.0, 1.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 0.0, 1.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 1.0, 1.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 2.0, 1.0),pp);\n Quad4Disc(sumC,sumW,pp+F2(-1.0, 2.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 0.0, 2.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 1.0, 2.0),pp);\n return sumC/sumW;}\n\n//\n// POOR QUALITY BOX SGSSAA\n//\n\n// Box filtered 2xSGSSAA.\n//\n//  x .\n//  . x\n//\nF1 ResolveBox2xSSAA(F2 pp){return 0.5*Shade(pp-F2(0.25,0.25))+0.5*Shade(pp+F2(0.25,0.25));}\n\n// Box filtered 4xSGSSAA.\n//\n//  . . x .\n//  x . . .\n//  . . . x\n//  . x . .\n//\nF1 ResolveBox4xSSAA(F2 pp){return\n Shade(pp+F2( 0.125,-0.375))*0.25+\n Shade(pp+F2(-0.375,-0.125))*0.25+\n Shade(pp+F2( 0.375, 0.125))*0.25+\n Shade(pp+F2(-0.125, 0.375))*0.25;}\n\n//\n// POOR QUALITY JITTERED\n//\n\n// Jittered position.\nF2 Jit(F2 pp){\n // Start with better baseline pattern.\n pp=Quad4(pp);\n // Very poor quality (clumping) move in disc around pixel.\n F1 n=Noise(pp,fract(iTime));    \n F1 m=Noise(pp,fract(iTime*0.333))*0.5+0.5;\n m = sqrt(m);\n return pp+Rot(0.707*0.5*m,n);}\n\n// Single poor quality jittered sample.\n//\n//  x\n//\nF1 ResolveJit(F2 pp){return Shade(Jit(floor(pp)));}\n\n// Gaussian filtered jittered tap.\nvoid JitGaus(inout F1 sumC,inout F1 sumW,F2 pp,F2 mm){\n F2 jj=Jit(pp);\n F1 c=Shade(jj);\n F2 vv=mm-jj;\n F1 w=exp2(-4.0*dot(vv,vv));    \n sumC+=c*w; sumW+=w;}   \n\n// Many tap gaussian from poor quality jittered single/sample per pixel\n//\n//  . x x x . \n//  x x x x x \n//  x x x x x \n//  x x x x x \n//  . x x x . \n//\nF1 ResolveJitGaus(F2 pp){\n pp=floor(pp);\n F1 sumC=0.0;\n F1 sumW=0.0;\n JitGaus(sumC,sumW,pp+F2(-1.0,-2.0),pp);\n JitGaus(sumC,sumW,pp+F2( 0.0,-2.0),pp);\n JitGaus(sumC,sumW,pp+F2( 1.0,-2.0),pp);\n JitGaus(sumC,sumW,pp+F2(-2.0,-1.0),pp);\n JitGaus(sumC,sumW,pp+F2(-1.0,-1.0),pp);\n JitGaus(sumC,sumW,pp+F2( 0.0,-1.0),pp);\n JitGaus(sumC,sumW,pp+F2( 1.0,-1.0),pp);\n JitGaus(sumC,sumW,pp+F2( 2.0,-1.0),pp);\n JitGaus(sumC,sumW,pp+F2(-2.0, 0.0),pp);\n JitGaus(sumC,sumW,pp+F2(-1.0, 0.0),pp);\n JitGaus(sumC,sumW,pp+F2( 0.0, 0.0),pp);\n JitGaus(sumC,sumW,pp+F2( 1.0, 0.0),pp);\n JitGaus(sumC,sumW,pp+F2( 2.0, 0.0),pp);\n JitGaus(sumC,sumW,pp+F2(-2.0, 1.0),pp);\n JitGaus(sumC,sumW,pp+F2(-1.0, 1.0),pp);\n JitGaus(sumC,sumW,pp+F2( 0.0, 1.0),pp);\n JitGaus(sumC,sumW,pp+F2( 1.0, 1.0),pp);\n JitGaus(sumC,sumW,pp+F2( 2.0, 1.0),pp);\n JitGaus(sumC,sumW,pp+F2(-1.0, 2.0),pp);\n JitGaus(sumC,sumW,pp+F2( 0.0, 2.0),pp);\n JitGaus(sumC,sumW,pp+F2( 1.0, 2.0),pp);\n return sumC/sumW;}\n\n//\n// POOR QUALITY JITTERED 2x\n//\n\n// Gaussian filtered jittered tap.\nvoid JitGaus2(inout F1 sumC,inout F1 sumW,F2 pp,F2 mm){\n F2 jj=Jit(pp);\n F1 c=Shade(jj/sqrt(2.0));\n F2 vv=mm-jj;\n F1 w=exp2(-2.0*dot(vv,vv));    \n sumC+=c*w; sumW+=w;}   \n\n// Many tap gaussian from poor quality jittered 2/sample per pixel\n//\n//  . x x x . \n//  x x x x x \n//  x x x x x \n//  x x x x x \n//  . x x x . \n//\nF1 ResolveJitGaus2(F2 pp){\n pp*=sqrt(2.0);\n F2 ppp=floor(pp);\n F1 sumC=0.0;\n F1 sumW=0.0;\n JitGaus2(sumC,sumW,ppp+F2(-1.0,-2.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 0.0,-2.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 1.0,-2.0),pp);\n JitGaus2(sumC,sumW,ppp+F2(-2.0,-1.0),pp);\n JitGaus2(sumC,sumW,ppp+F2(-1.0,-1.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 0.0,-1.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 1.0,-1.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 2.0,-1.0),pp);\n JitGaus2(sumC,sumW,ppp+F2(-2.0, 0.0),pp);\n JitGaus2(sumC,sumW,ppp+F2(-1.0, 0.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 0.0, 0.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 1.0, 0.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 2.0, 0.0),pp);\n JitGaus2(sumC,sumW,ppp+F2(-2.0, 1.0),pp);\n JitGaus2(sumC,sumW,ppp+F2(-1.0, 1.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 0.0, 1.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 1.0, 1.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 2.0, 1.0),pp);\n JitGaus2(sumC,sumW,ppp+F2(-1.0, 2.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 0.0, 2.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 1.0, 2.0),pp);\n return sumC/sumW;}\n\n//\n// POOR QUALITY JITTERED 4x\n//\n\n// Gaussian filtered jittered tap.\nvoid JitGaus4(inout F1 sumC,inout F1 sumW,F2 pp,F2 mm){\n F2 jj=Jit(pp);\n F1 c=Shade(jj/sqrt(4.0));\n F2 vv=mm-jj;\n F1 w=exp2(-1.0*dot(vv,vv));    \n sumC+=c*w; sumW+=w;}   \n\n// Many tap gaussian from poor quality jittered 4/sample per pixel\n//\n//  . x x x . \n//  x x x x x \n//  x x x x x \n//  x x x x x \n//  . x x x . \n//\nF1 ResolveJitGaus4(F2 pp){\n pp*=sqrt(4.0);\n F2 ppp=floor(pp);\n F1 sumC=0.0;\n F1 sumW=0.0;\n JitGaus4(sumC,sumW,ppp+F2(-1.0,-2.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 0.0,-2.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 1.0,-2.0),pp);\n JitGaus4(sumC,sumW,ppp+F2(-2.0,-1.0),pp);\n JitGaus4(sumC,sumW,ppp+F2(-1.0,-1.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 0.0,-1.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 1.0,-1.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 2.0,-1.0),pp);\n JitGaus4(sumC,sumW,ppp+F2(-2.0, 0.0),pp);\n JitGaus4(sumC,sumW,ppp+F2(-1.0, 0.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 0.0, 0.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 1.0, 0.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 2.0, 0.0),pp);\n JitGaus4(sumC,sumW,ppp+F2(-2.0, 1.0),pp);\n JitGaus4(sumC,sumW,ppp+F2(-1.0, 1.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 0.0, 1.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 1.0, 1.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 2.0, 1.0),pp);\n JitGaus4(sumC,sumW,ppp+F2(-1.0, 2.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 0.0, 2.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 1.0, 2.0),pp);\n return sumC/sumW;}\n\n//\n// ENTRY\n//\n\nvoid mainImage(out F4 fragColor,in F2 fragCoord){\n F2 pp=fragCoord;\n F1 cc=0.0;\n int ss=MODE;\n // Red\n if(ss==0){\n  if(pp.y<8.0){fragColor.xyz=F3(1.0,0.0,0.0);return;}\n  cc=ResolveNoAA(pp);}\n // Orange\n else if(ss==1){\n  if(pp.y<8.0){fragColor.xyz=F3(1.0,0.5,0.0);return;}\n  cc=ResolveQuad4Gaus(pp);}\n // Gold\n else if(ss==2){\n  if(pp.y<8.0){fragColor.xyz=F3(1.0,0.75,0.0);return;}\n  cc=ResolveJit(pp);\n  cc=Noise4(pp,cc,0.5);}\n // Yellow\n else if(ss==3){\n  if(pp.y<8.0){fragColor.xyz=F3(1.0,1.0,0.0);return;}\n  cc=ResolveJitGaus(pp);\n  cc=Noise4(pp,cc,0.5);}\n // Lime\n else if(ss==4){\n  if(pp.y<8.0){fragColor.xyz=F3(0.5,1.0,0.0);return;}\n  cc=ResolveBox2xSSAA(pp);}\n // Green\n else if(ss==5){\n  if(pp.y<8.0){fragColor.xyz=F3(0.0,1.0,0.0);return;}\n  cc=ResolveJitGaus2(pp);\n  cc=Noise4(pp,cc,0.125);}\n // Green Blue\n else if(ss==6){\n  if(pp.y<8.0){fragColor.xyz=F3(0.0,1.0,0.5);return;}\n  cc=ResolveBox4xSSAA(pp);}\n // Blue\n else if(ss==7){\n  if(pp.y<8.0){fragColor.xyz=F3(0.0,0.0,1.0);return;}\n  cc=ResolveJitGaus4(pp);\n  cc=Noise4(pp,cc,1.0/16.0);}     \n // Output   \n fragColor.x=Srgb(cc);\n fragColor.yxz=fragColor.xxx;}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfyWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[773, 805, 819, 819, 875], [877, 909, 925, 925, 978], [1027, 1102, 1122, 1122, 1229], [1231, 1285, 1307, 1307, 1682], [1688, 1742, 1764, 1764, 2141], [2143, 2202, 2219, 2219, 2251], [2257, 2320, 2347, 2374, 2728], [2748, 2786, 2801, 2801, 2956], [2958, 3095, 3111, 3111, 3297], [3299, 3338, 3356, 3356, 3402], [3404, 3439, 3459, 3459, 3569], [3608, 3645, 3667, 3667, 3685], [3717, 3798, 3821, 3821, 3853], [3855, 3877, 3933, 3933, 4037], [4042, 4203, 4230, 4230, 5196], [5198, 5216, 5272, 5272, 5585], [5594, 5751, 5778, 5778, 6744], [6780, 6828, 6855, 6855, 6919], [6921, 7001, 7028, 7028, 7175], [7209, 7231, 7245, 7285, 7484], [7486, 7538, 7559, 7559, 7589], [7591, 7626, 7680, 7680, 7782], [7787, 7940, 7965, 7965, 8889], [8926, 8961, 9016, 9016, 9128], [9133, 9281, 9307, 9307, 10293], [10330, 10365, 10420, 10420, 10532], [10537, 10685, 10711, 10711, 11697], [11699, 11715, 11764, 11764, 12839]]}
{"id": "XsjcRz", "name": "bp Justice Cross", "author": "blackpolygon", "description": "Randy get yourself together", "tags": ["cross", "justice", "dumbshader"], "likes": 1, "viewed": 148, "published": "Public", "date": "1490648069", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Dumb shader to paint the Justice logo\n * Box and rotate funtions taken from https://thebookofshaders.com/08/\n*/\n\n#define PI 3.14159265359\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle), sin(_angle),cos(_angle));\n}\n\nfloat box(in vec2 _st, in vec2 _size){\n    _size = vec2(0.5) - _size*0.5;\n    vec2 uv = smoothstep(_size, _size+vec2(0.001), _st);\n    uv *= smoothstep(_size, _size+vec2(0.001), vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nfloat jcross(in vec2 _st, float _size){\n    return  box(_st+vec2(0.0, -0.07), vec2(_size - 0.122,_size/4.7)) + \n            box(_st+vec2(0.0,0.05), vec2(_size/4.5,_size*1.316));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/min(iResolution.x,iResolution.y);\n    st.x -= 0.35;\n\n    float cr = jcross(st,0.6);\n    float ax = st.y;\n    \n    st -= vec2(0.5);\n    st = rotate2d( (4.*sin(iTime)*PI) / 5. ) * st;\n    st += vec2(0.5);\n    \n    vec3 c1 = vec3(mix(vec3(0.405,0.002,0.405), vec3(0.006,0.700,0.673), st.y));\n    vec3 c2 = vec3(mix(vec3(0.006,0.700,0.673), vec3(0.405,0.002,0.405), st.y));\n    vec3 bg = vec3(mix(c1, c2, st.x));\n    \n\tvec3 colorCross = mix(vec3(0.985,0.813,0.191), vec3(1.000,0.010,0.725), ax);\n    vec3 colorFinal = mix(bg, colorCross, cr > 0. ? 1.0 : 0.);\n    fragColor = vec4(colorFinal,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsjcRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 142, 170, 170, 240], [242, 242, 280, 280, 459], [461, 461, 500, 500, 640], [643, 643, 700, 700, 1322]]}
{"id": "XslcD2", "name": "2D Quad", "author": "aiekick", "description": "2D Quad", "tags": ["2d", "sphere"], "likes": 7, "viewed": 622, "published": "Public API", "date": "1490062821", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 f, vec2 g )\n{\n    g -= f.xy=iResolution.xy/2.;\n    \n    g /= f.y;\n    \n    float d = pow(abs(.5 - max(abs(g.x),abs(g.y))), .2);\n        \n    g += d;\n    \n    g *= g;\n    \n    f = vec4(g,d,1) * d * (0.8 + 0.2 * cos(10. * d+iTime*10.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XslcD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 261]]}
{"id": "XslyDl", "name": "[ Famous curves ] - #3", "author": "Yrai", "description": "#3 - Cardioid", "tags": ["2d", "curve", "cardioid", "parametric"], "likes": 6, "viewed": 849, "published": "Public API", "date": "1490344053", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/*\n   Cardioid facts:\n  ----------------\n\t- (a) Trace a point on the circle rolling around another circle of equal radius.\n\t- (b) There are exactly three parallel tangents at any given point on the cardioid.\n\t- (c) The tangents at the ends of any chord through the cusp point are at right angles.\n*/\n\n#define res_            iResolution\n#define time_           iTime\n#define trace_len_      64\n#define eps_            0.1\n\nvec2  domain(vec2 uv, float s);\nvec2  parametric(float t);\nfloat trace(vec2 p, float t);\n\nvoid mainImage(out vec4 o, vec2 f) {\n\tvec2 p = domain(f, 8.);\n    \n    // t -> [0., 5.]\n    float t = abs(sin(time_)*5.);\n    \n    // Cardioid traces\n    float dtrace = smoothstep(0.08, 0.001, trace(p, t));\n    float dtrace_s0 = smoothstep(0.16, 0.001, trace(p, t));\n    \n    // Axis\n    float ax = min(\n        smoothstep(0., 0.02, abs(p.x)),\n        smoothstep(0., 0.02, abs(p.y))\n    );\n    // Origin\n    float org = smoothstep(0.09, 0., length(p)-.01);\n    \n    // Palette \n    vec3 gray   = vec3(.2);\n    vec3 white  = vec3(5.);\n    \n    // Shading\n    vec3 c  = vec3(0.);\n    c = mix(c, gray, 1.-ax);\n    c = mix(c, white, org);\n    \n    c = mix(c, vec3(11., 0.0, 0.), dtrace_s0);\n    c = mix(c, white, dtrace);\n    c.b += dtrace_s0;\n    \n    o = vec4(sqrt(c), 1.);\n}\n\nvec2 parametric(float t) {\n\tfloat a = 2.;\n    return vec2(a*( 2.*sin(t) - sin(2.*t) ), a*( 2.*cos(t)-cos(2.*t) ) ); \n}\n\nfloat trace(vec2 p, float t) {\n    float d = 1e10;\n    float e = 0.;\n    for(int i = 0; i < trace_len_; i++) {\n    \td  = min(d, distance(p, parametric(t-e)));\n        e += eps_; \n    }\n    return d;\n}\n\nvec2 domain(vec2 uv, float s) {\n    return (2. * uv.xy - res_.xy) / res_.y * s;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XslyDl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[89, 602, 638, 638, 1375], [1377, 1377, 1403, 1403, 1495], [1497, 1497, 1527, 1527, 1697], [1699, 1699, 1730, 1730, 1780]]}
{"id": "XslyWj", "name": "TestGLSL", "author": "ArtDov", "description": "NewShader", "tags": ["caustic"], "likes": 2, "viewed": 82, "published": "Public", "date": "1489927577", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 p){\n    vec3 q = fract(p)*2.0 - 1.0;\n return length(q) - 0.1;   \n}\nfloat trace(vec3 o, vec3 r){\n    float t = 0.0;\n    for (int i = 0; i < 32; i++){\n        vec3 p = o + r * t;\n       float d = map(p);\n        t += d * 0.35;\n    }\n    return t;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float speedl = 1.0;\n    float time = speedl*iTime;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= 2.0*iResolution.x/ iResolution.y;\n    float scaleUV = 0.5;\n    uv /= scaleUV;\n    vec3 r = normalize(vec3(uv,1.0));\n    float teta = iTime/10.0;\n    \n    r.xz *= mat2(cos(teta), -sin(teta), sin(teta), cos(teta));\n    r.yz *= mat2(cos(teta), sin(teta), -sin(teta), cos(teta));\n    r.xy *= mat2(cos(teta), -sin(teta), sin(teta), cos(teta));\n    \n    r.x += 0.05; r.y += 0.05; r.z -= 0.1;\n   \n\n    vec3 o = vec3(0.0, 0.0, time);\n    float t = trace(o,r);\n    float fog = 1.0/(0.5 + t*t*0.1);\n    vec3 fc = vec3(fog);\n    vec3 blueColor = vec3(0.0,0.5,0.8);\n    fc = fc + blueColor/1.5;\n    vec4 tex0 = texture(iChannel0, uv); \n    vec3 h = vec3( trace(tex0.rgb,r));\n    fc * blueColor;\n    \n    fragColor = vec4(fc*blueColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XslyWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 81], [82, 82, 110, 110, 261], [265, 265, 322, 322, 1192]]}
{"id": "XsscD7", "name": "BasicStuff", "author": "Nihilus", "description": "Basic testing", "tags": ["basic"], "likes": 2, "viewed": 72, "published": "Public", "date": "1488501696", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\n// Anti-aliasing\nfloat aa(float edge, float val)\n{\n    return 1.0 - smoothstep(val, val + 0.00999999, edge);\n}\n\nvec2 point_shr(vec2 p, float val)\n{\n    return p - vec2(val, 0.0);\n}\n\nvec2 point_shl(vec2 p, float val)\n{\n    return p + vec2(val, 0.0);\n}\n\nvec2 point_up(vec2 p, float val)\n{\n    return p - vec2(0.0, val);\n}\n\nvec2 point_down(vec2 p, float val)\n{\n    return p + vec2(0.0, val);\n}\n\nfloat square(vec2 c, float d)\n{\n    return aa(abs(c.x), d) * aa(abs(c.y), d);\n}\n\nfloat circle(vec2 c, float r)\n{\n    // Calculating the length\n    float l = length(c);\n    // Calculating the angle\n    float t = atan(c.y, c.x);\n    // Calculating point coordinates\n    vec2 p = vec2(r*cos(t), r*sin(t));\n    // Determining the circle\n    return aa(length(c), length(p));\n}\n\nfloat triangle(vec2 c, float d)\n{\n    return aa(c.y, d - abs(c.x)) * aa(abs(c.y), d);\n}\n\nfloat romboid(vec2 c, float d)\n{\n    return aa(abs(c.x) + abs(c.y), d);\n}\n\nfloat polygon(vec2 c, int n, float s)\n{\n    // if n = 3, scale down s\n    if(n == 3)\n        s = s/2.0;\n    // Calculating the length of the c vector (c.x, c.y) from the center (0,0)\n    //float l = sqrt(pow(c.x,2.0)+pow(c.y,2.0));\n    float l = length(c);\n    \n    // Calculating the angle at the base (0,0) of the c vector (c.x, c.y)\n    //float a = acos(-c.y/l); //using negative c.y to get the first triangle facing down\n    float a = atan(c.x, c.y) - PI; //subtracting PI to get the first triangle facing down\n    \n    // Calculating the angle at the base (0,0) of each triangle making the polygon\n  \tfloat r = (2.0 * PI) / float(n);\n   \n    /*\n    \tCalculating the index (integer) of the nearest multiple angle of r\n    \te.g. if N = 6 and a = 135 -> r = 360/6 = 60 -> i = 2 -> i * r = 120\n\t*/\n    float i = floor(0.5 + a / r);\n    \n    // Calculating the difference between a and the nearest multiple angle\n    float t = i * r - a;\n    \n    // Calculating the length of the apothem for the current triangle (hint: index)\n    float d = cos(t) * l;\n    \n    return aa(d, s);\n}\n\nfloat add_shape(float color, float shape)\n{\n    return color + shape;\n}\n\nfloat sub_shape(float color, float shape)\n{\n    return color - shape;\n}\n\nfloat add_border(float size, float shape)\n{\n    return size + shape;\n}\n\nfloat sub_border(float size, float shape)\n{\n    return size - shape;\n}\n\nfloat sine(vec2 c, float s, float f, float h)\n{\n    float d = h*sin(f*c.x);\n    return aa(abs(c.y - d), s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*(fragCoord.xy / iResolution.xy) - 1.0) * vec2(iResolution.x/iResolution.y, 1.0);\n    \n    // Save original pixel coordinates\n    vec2 uv_s = uv;\n    vec3 color = vec3(0.0);\n   \n    // Repetition of the field\n    //uv_s.x = mod(uv_s.x, 1.0);\n    //uv_s.y = mod(-pow(uv_s.x, 1.1) + uv_s.y, 1.0);\n    \n    // Field deformation, power\n    //uv_s.y = uv_s.y - pow(uv_s.x, 1.1);\n    \n    // Reflect field\n    //uv_s.x = abs(uv_s.x);\n    //uv_s.y = abs(uv_s.y);\n    \n    // Draw a square\n    uv = point_shr(uv_s, 1.2);\n    uv.y = uv.y - 0.05*sin(iTime);\n    \n    // Add a border to the square\n    float l = atan(uv.x, uv.y);\n   \tfloat border = 0.02*sin(50.0 * l + 10.0*iTime) + 0.02*sin(20.0 * l);\n    float size = 0.2;\n    size = add_border(size, border);\n    color.g = add_shape(color.g, square(uv, size));\n    \n    // Draw a square\n    uv = point_shl(uv_s, 1.2);\n    uv.y = uv.y + 0.15*sin(2.5*iTime);\n    uv.x = uv.x - 0.15*cos(2.5*iTime);\n    \n    l = atan(uv.x, uv.y);\n    border = 0.01*sin(5.0*l + 10.0*iTime);\n    size = 0.2;\n    size = sub_border(size, border);\n    color.g = add_shape(color.g, square(uv, size));\n    \n    // Draw a circle\n    uv = point_up(uv_s, 0.7);\n    uv = point_shl(uv, 1.2);\n    l = atan(uv.x, uv.y);\n    border = 0.02*sin(50.0 * l + 10.0*iTime) + 0.02*cos(20.0 * l);\n    size = 0.2;\n    size = add_border(size, border);\n    color.g = add_shape(color.g, circle(uv, size));\n    \n    // Draw a circle\n    uv = point_up(uv_s, 0.7);\n    uv = point_shr(uv, 1.2);\n    color.g = add_shape(color.g, circle(uv, 0.2));\n    \n    // Subtract a square to the circle\n    uv = point_up(uv_s, 0.7);\n    uv = point_shr(uv, 1.2);\n    color.g = sub_shape(color.g, square(uv, 0.14));\n    \n    // Add a triangle inside the square\n    uv = point_up(uv_s, 0.635);\n    uv = point_shr(uv, 1.2);\n    color.g = add_shape(color.g, polygon(uv, 3, 0.075));\n    \n    // Draw a triangle\n    uv = uv_s;\n    uv = point_down(uv_s, 0.7);\n    uv = point_shl(uv , 1.2);\n    l = atan(uv.x, uv.y);\n    border = 0.02*sin(50.0 * l + 10.0*iTime) + 0.02*cos(20.0 * l);\n    size = 0.16;\n    size = add_border(size, border);\n    color.g = add_shape(color.g, triangle(uv, size));\n    \n    // Draw a romboid\n    uv = point_down(uv_s, 0.7);\n    uv = point_shr(uv , 1.2);\n    color.g = add_shape(color.g, romboid(uv, 0.25));\n    \n    // Subtract a circle to the romboid\n    uv = point_down(uv_s, 0.7);\n    uv = point_shr(uv, 1.2);\n    color.g = sub_shape(color.g, circle(uv, 0.175));\n    \n    // Draw some polygons\n    uv = uv_s;\n    uv = point_down(uv, 1.13);\n    float shift = 0.25;\n    for(int i = 3; i < 11; i++)\n    {\n        uv = point_up(uv, shift);\n    \tcolor.g = add_shape(color.g, polygon(uv, i, 0.1));\n    }\n    \n    // Draw a sine\n    uv = uv_s;\n    uv.x = uv.x + 0.5*iTime;\n    color.r = add_shape(color.r, sine(uv, 0.01, 5.0, 0.3));\n    color.g = add_shape(color.g, sine(uv, 0.01, 5.0, 0.6));\n    color.b = add_shape(color.b, sine(uv, 0.01, 5.0, 0.9));\n        \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsscD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 43, 76, 76, 136], [138, 138, 173, 173, 206], [208, 208, 243, 243, 276], [278, 278, 312, 312, 345], [347, 347, 383, 383, 416], [418, 418, 449, 449, 497], [499, 499, 530, 560, 789], [791, 791, 824, 824, 878], [880, 880, 912, 912, 953], [955, 955, 994, 1024, 2035], [2037, 2037, 2080, 2080, 2108], [2110, 2110, 2153, 2153, 2181], [2183, 2183, 2226, 2226, 2253], [2255, 2255, 2298, 2298, 2325], [2327, 2327, 2374, 2374, 2436], [2438, 2438, 2495, 2495, 5495]]}
{"id": "XssczX", "name": "Moebius Ants", "author": "Klems", "description": "Loosely inspired by an Escher sketch. I had a nice anti-aliasing going on at some point (see line 428) but it was too expensive for this shader. Click the screen to rotate the camera!", "tags": ["3d", "raymarch", "escher", "toon", "insect", "leg", "reproduction"], "likes": 109, "viewed": 4962, "published": "Public API", "date": "1489150642", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define SOFT_STEPS 16\n#define RAYS_STEPS 100\n\n// uncomment this to show a closeup of the ant\n// #define SHOW_ANT\n\n// hopefully this should compile to a const mat2\n#define rot_const(a) (mat2(cos(a), sin(a), -sin(a), cos(a)))\n\n// Fabrice's rotation matrix\nmat2 rot( in float a ) {\n    vec2 v = sin(vec2(PI*0.5, 0) + a);\n    return mat2(v, -v.y, v.x);\n}\n\n// Dave Hoskins hash function\nvec3 hash33( in vec3 p3 ) {\n    #define HASHSCALE3 vec3(.1031, .1030, .0973)\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// iq's functions\nfloat sdBox( in vec3 p, in vec3 b ) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) {\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\nfloat smin( in float a, in float b, in float s ) {\n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0.0, 1.0 );\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\nfloat smax( in float a, in float b, in float s ) {\n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0.0, 1.0 );\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n// intersection of 2 circles, by eiffie (used for the legs IKs)\nvec2 intersect(vec3 c0, vec3 c1) {\n    vec2 dxy = vec2(c1.xy - c0.xy);\n    float d = length(dxy);\n    float a = (c0.z*c0.z - c1.z*c1.z + d*d)/(2.*d);\n    vec2 p2 = c0.xy + (a / d)*dxy;\n    float h = sqrt(c0.z*c0.z - a*a);\n    vec2 rxy = vec2(-dxy.y, dxy.x) * (h/d);\n    return p2 + rxy;\n}\n\n// ant's legs distance function\nfloat deAntLeg(in vec3 p, in vec3 anchor, in vec3 legStart,\n               in float lenStart, in vec3 legEnd, in float lenEnd) {\n    \n\t// express coordinates from the starting leg\n    vec3 inLeg = p - legStart;\n    vec3 legEndInStart = legEnd - legStart;\n    // express coordinates in the leg plane\n    vec3 xDir = normalize(vec3(legEnd.xy - legStart.xy, 0));\n    vec2 planar = vec2(dot(inLeg, xDir), inLeg.z);\n    vec2 endInPlanar = vec2(dot(legEndInStart, xDir), legEndInStart.z);\n    \n    // get intersection\n    vec2 jointPlanar = intersect( vec3(0, 0, lenStart), vec3(endInPlanar, lenEnd) );\n    // go back to 3D space\n    vec3 joint = legStart + xDir*jointPlanar.x + vec3(0, 0, 1)*jointPlanar.y;\n    \n    float d = sdCapsule( p, anchor, legStart, 0.03 );\n    d = smin(d, sdCapsule( p, legStart, joint, 0.02 ), 0.02);\n    d = smin(d, sdCapsule( p, joint, legEnd, 0.015 ), 0.02);\n    return d;\n    \n}\n\n// ant distance function, phase is the animation (between 0 and 1)\nfloat deAnt( in vec3 p, in float phase, out vec3 color1, out vec3 color2, out float roughness ) {\n    \n    color1 = vec3(0.90, 0.18, 0.01);\n    color2 = vec3(0.35, 0.10, 0.01);\n    roughness = 12.0;\n    \n    p = p.zyx;\n    \n    // bounding box optimization\n    float bb = sdBox(p, vec3(1.1, 0.5, 0.5));\n    if (bb > 0.5) {\n        return bb;\n    }\n    \n    p -= vec3(-0.05, 0, 0.75);\n    \n    // 3 parts for the ant\n    const vec2 slopeCenter = vec2(0.4, 0.8);\n    vec2 inSlope = slopeCenter - p.xz;\n    float slope = atan(inSlope.y, inSlope.x);\n    slope /= PI;\n    float part = clamp(floor(slope * 10.0), 3.0, 5.0);\n    slope = (part + 0.5) / 10.0;\n    slope *= PI;\n    vec2 center = slopeCenter - vec2(cos(slope), sin(slope)) * 1.6;\n    vec3 partCenter = vec3(center.x, 0.0, center.y);\n    \n    vec3 inPart = p - partCenter;\n    float side = sign(inPart.y);\n    inPart.y = abs(inPart.y);\n    \n    float dist = bb;\n    \n    if (part > 4.5) {\n        \n        // rotation\n        inPart.x += 0.3;\n        float r = sin(phase*2.0*PI)*0.05;\n        inPart.xz *= rot(r-0.1);\n        inPart.x -= 0.3;\n        \n        // abdomen\n        inPart -= vec3(0.33, 0.0, -0.02);\n        float radius = 0.1 + smoothstep(-0.2, 0.7, -inPart.x) * 0.5;\n        \n        // add ridges\n        float s = cos(-inPart.x*40.0)*0.5+0.5;\n        s *= s; s *= s;\n        radius -= s*0.005;\n        \n        dist = length(inPart) - radius;\n        float sMix = pow(s, 8.0);\n        color1 = mix(vec3(0.1, 0.05, 0.01), vec3(0.6, 0.5, 0.4), sMix);\n        color2 = mix(vec3(0.05, 0.02, 0.01), vec3(0.5, 0.4, 0.2), sMix);\n        roughness = 16.0 - s*12.0;\n        \n    } else if (part > 3.5) {\n        \n        // thorax\n        inPart += vec3(0.02, 0.0, -0.05);\n        inPart.xz *= rot_const(-0.3);\n        \n        // pronotum\n        vec3 inThoraxA = inPart - vec3(-0.13, 0.0, 0.05);\n        float radiusA = 0.10 + smoothstep(-0.1, 0.5, inThoraxA.x) * 0.2;\n        radiusA -= smoothstep(-0.1, 0.2, inThoraxA.z) * 0.1;\n        float thoraxDistA = length(inThoraxA) - radiusA;\n        \n        // propodeum\n        vec3 inThoraxB = inPart - vec3(0.06, 0.0, 0.03);\n        float radiusB = 0.05 + smoothstep(-0.1, 0.4, inThoraxB.x) * 0.2;\n        radiusB -= smoothstep(-0.1, 0.4, inThoraxA.z) * 0.1;\n        float thoraxDistB = length(inThoraxB) - radiusB;\n        dist = smin(thoraxDistA, thoraxDistB, 0.05);\n        \n        // petiole\n        vec3 inThoraxC = inPart - vec3(0.24, 0.0, 0.0);\n        float radiusC = 0.05 - smoothstep(-0.1, 0.2, inThoraxC.z-inThoraxC.x*0.3) * 0.04;\n        float thoraxDistC = sdCapsule( inThoraxC, vec3(0), vec3(-0.03, 0, 0.11), radiusC);\n        dist = smin(dist, thoraxDistC, 0.03);\n        \n        // add ridges\n        vec3 inRidges = inPart - vec3(0.01, 0.0, 0.1);\n        float ridgesDist = abs(length(inRidges) - 0.12);\n        dist += smoothstep(0.02, 0.0, ridgesDist) * 0.004;\n        \n    } else if (part > 2.5) {\n        \n        // head\n        inPart -= vec3(-0.09, 0.0, -0.06);\n        inPart.xz *= rot_const(0.3);\n        float radius = 0.07 + smoothstep(-0.15, 0.4, inPart.x) * 0.3;\n        radius -= smoothstep(0.0, 0.4, abs(inPart.z))*0.2;\n        dist = length(inPart) - radius;\n        \n        // frontal carina\n        vec3 inCarina = inPart - vec3(0.02, 0.0, 0.09);\n        inCarina.xy *= rot_const(-0.4);\n        inCarina.xz *= rot_const(0.1);\n        float carina = sdBox( inCarina, vec3(0.1, 0.05, 0.01) ) - 0.01;\n        dist = smin(dist, carina, 0.05);\n        \n        // antenna\n        vec3 inAntenna = inPart - vec3(-0.03, 0.1, 0.1);\n        inAntenna.yz *= rot_const(-0.4);\n        inAntenna.xz *= rot(sin((phase+side*0.25)*2.0*PI)*0.3-0.2);\n        const vec3 funiculusStart = vec3(0, 0, 0.3);\n        float scapeRadius = 0.007 + inAntenna.z*0.04;\n        float scape = sdCapsule( inAntenna, vec3(0), funiculusStart, scapeRadius );\n        vec3 funiculusDir = normalize(vec3(-0.5, 0.0, -0.1));\n        funiculusDir.xz *= rot(sin((phase+side*0.25)*4.0*PI)*0.2);\n        float funiculusRadius = dot(funiculusDir, inAntenna - funiculusStart);\n        funiculusRadius = abs(sin(funiculusRadius*67.0));\n        funiculusRadius = 0.01 + funiculusRadius*0.004;\n        float funiculus = sdCapsule(inAntenna, funiculusStart, \n                                    funiculusStart+funiculusDir*0.5, funiculusRadius );\n        float antennaDist = min(scape, funiculus);\n        dist = min(dist, antennaDist);\n        \n        // mandibles\n        vec3 inMandibles = inPart;\n        inMandibles.xy *= rot(sin(phase*4.0*PI)*0.1-0.1);\n        float mandiblesOuter = sdEllipsoid( inMandibles, vec3(0.25, 0.14, 0.1) );\n        float mandiblesInner = sdEllipsoid( inMandibles, vec3(0.15, 0.1, 0.4) );\n        float mandibles = smax(mandiblesOuter, -mandiblesInner, 0.05);\n        mandibles = smax(mandibles, 0.005-inMandibles.y+sin(inMandibles.x*300.0)*0.005, 0.01);\n        dist = smin(dist, mandibles, 0.05);\n        \n        // eyes\n        float eyes = sdEllipsoid( inPart - vec3(0.21, 0.15, 0.03), vec3(0.06, 0.05, 0.05 ) );\n        if (eyes < dist) {\n            color1 = color2 = vec3(0.05);\n            roughness = 32.0;\n            dist = eyes;\n        }\n\n    }\n    \n    // add a capsule in the center to connect the parts\n    float connector = sdCapsule( p, vec3(-0.15, 0, -0.63), vec3(0.5, 0, -0.83), 0.03);\n    dist = min(dist, connector);\n    \n    // add legs\n    vec3 inLegs = p;\n    inLegs.y = abs(inLegs.y);\n    phase += side*0.25;\n    \n    float angleA = (phase)*PI*2.0;\n    vec3 legAOffset = vec3(cos(angleA), 0, max(0.0, sin(angleA)))*0.2;\n    float legA = deAntLeg(inLegs, vec3(0.05, 0.0, -0.75),\n                          vec3(0.1, 0.1, -0.82), 0.25, \n                          vec3(-0.2, 0.4, -1.2)+legAOffset, 0.5);\n    float angleB = (phase+0.33)*PI*2.0;\n    vec3 legBOffset = vec3(cos(angleB), 0, max(0.0, sin(angleB)))*0.2;\n    float legB = deAntLeg(inLegs, vec3(0.18, 0.0, -0.8),\n                          vec3(0.2, 0.1, -0.85), 0.3, \n                          vec3(0.3, 0.5, -1.2)+legBOffset, 0.6);\n    float angleC = (phase+0.66)*PI*2.0;\n    vec3 legCOffset = vec3(cos(angleC), 0, max(0.0, sin(angleC)))*0.2;\n    float legC = deAntLeg(inLegs, vec3(0.25, 0.0, -0.8),\n                          vec3(0.3, 0.1, -0.85), 0.4, \n                          vec3(0.6, 0.4, -1.2)+legCOffset, 0.7);\n    \n    float distLegs = min(min(legA, legB), legC);\n    if (distLegs < dist) {\n        color1 = vec3(0.35, 0.10, 0.01);\n        color2 = vec3(0.05, 0.02, 0.01);\n        dist = distLegs;\n    }\n    \n    return dist;\n}\n\n// main distance function, coordinates in, distance and surface parameters out\nfloat de( in vec3 p, out vec3 color1, out vec3 color2, out float roughness ) {\n    \n    color1 = vec3(0.7);\n    color2 = vec3(0.7);\n    roughness = 4.0;\n    \n    #ifdef SHOW_ANT\n    return deAnt(p.zxy, fract(iTime), color1, color2, roughness);\n    #endif\n    \n    // perimeter of the moebius strip is 38\n    #define RADIUS (1.0/(PI*2.0)*38.0)\n    \n    // cylindrical coordinates\n    vec2 cyl = vec2(length(p.xy), p.z);\n    float theta = atan(p.x, p.y);\n    vec2 inCyl = vec2(RADIUS, 0) - cyl;\n    // rotate 180° to form the loop\n    inCyl *= rot(theta*1.5-2.0);\n    // coordinates in a torus (cylindrical coordinates + position on the stripe)\n    vec3 inTor = vec3(inCyl, theta * RADIUS);\n    \n    // add the band\n    float bandDist = sdBox(inTor, vec3(0.05, 1, 100)) - 0.05;\n    float d = bandDist;\n    // add holes\n    vec3 inHole = vec3(mod(inTor.yz, vec2(0.5)) - vec2(0.25), inTor.x);\n    inHole.xyz = inHole.zxy;\n    float holeDist = sdBox(inHole, vec3(0.18));\n    d = smax(d, -holeDist, 0.05);\n    \n    // add ants\n    vec3 inTorObj = vec3(abs(inTor.x), inTor.y, inTor.z + iTime*1.3 + sign(inTor.x));\n    float ant = floor(inTorObj.z / 4.0);\n    vec3 objCenter = vec3(0.6, 0, ant * 4.0 + 2.0);\n    float phase = fract(iTime) + mod(ant, 9.0) / 9.0;\n    vec3 antColor1 = vec3(0.0);\n    vec3 antColor2 = vec3(0.0);\n    float antRoughness = 0.0;\n    float antDist = deAnt(inTorObj-objCenter, phase, antColor1, antColor2, antRoughness);\n    if (antDist < d) {\n        color1 = antColor1;\n        color2 = antColor2;\n        roughness = antRoughness;\n        return antDist;\n    }\n    \n\treturn d;\n}\n\nfloat de( in vec3 p ) {\n    vec3 dummy1 = vec3(0);\n    vec3 dummy2 = vec3(0);\n    float dummy3 = 0.0;\n    return de(p, dummy1, dummy2, dummy3);\n}\n\n// normal from backward difference\nvec3 computeNormal( in vec3 p, in float d ) {\n\tconst vec3 e = vec3(0.0, 0.01, 0.0);\n\treturn normalize(vec3(\n\t\td-de(p-e.yxx),\n\t\td-de(p-e.xyx),\n\t\td-de(p-e.xxy)));\t\n}\n\n// cone trace the soft shadows\nfloat computeSoftShadows( in vec3 from, in vec3 dir, in float theta ) {\n    float sinTheta = sin(theta);\n    float acc = 1.0;\n    float totdist = 0.0;\n    for (int i = 0 ; i < SOFT_STEPS ; i++) {\n        vec3 p = from + totdist * dir;\n        float dist = de(p);\n        float prox = dist / (totdist*sinTheta);\n        acc *= clamp(prox * 0.5 + 0.5, 0.0, 1.0);\n        if (acc < 0.01) break;\n        totdist += max(0.01, dist*0.85);\n    }\n    return acc;\n}\n\n// compute lighting at this position\nvec3 computeColor( in vec3 p, in vec3 dir, in vec2 fragCoord ) {\n    \n    // sunlight and ambient\n    const vec3 sunLight = vec3(0.9, 0.8, 0.6)*9.0;\n    const vec3 sunLightDir = normalize(vec3(-2, -1, 3));\n    const vec3 subLight = vec3(0.4, 0.4, 0.8)*3.0;\n    const vec3 subLightDir = normalize(vec3(2, -1, -8));\n    const vec3 ambLight = vec3(0.7, 0.7, 0.9)*4.0;\n    \n    // compute distance to get the surface albedo\n    vec3 albedo1 = vec3(0);\n    vec3 albedo2 = vec3(0);\n    float roughness = 0.0;\n    float dist = de(p, albedo1, albedo2, roughness);\n    \n    // compute surface normal\n    vec3 normal = computeNormal(p, dist);\n    \n    float specScale = (roughness+1.0)*0.25;\n    float sunLightDiff = max(0.0, dot(normal, sunLightDir));\n    float sunLightSpec = pow(max(0.0, dot(sunLightDir, reflect(dir, normal))), roughness);\n    sunLightSpec *= specScale;\n    float subLightDiff = max(0.0, dot(normal, subLightDir));\n    float subLightSpec = pow(max(0.0, dot(subLightDir, reflect(dir, normal))), roughness);\n    subLightSpec *= specScale;\n    \n   \t// soft shadows\n    float soft = 0.0;\n    if (sunLightDiff > 0.01) {\n        soft = computeSoftShadows(p+normal*0.05, sunLightDir, 0.2);\n    }\n    \n    // fake subsurface scattering\n    float subsurface = max(0.0, dot(normal, -dir));\n    subsurface = pow(subsurface, 4.0);\n    vec3 albedo = mix(albedo2, albedo1, subsurface);\n    \n    // do some arty sketchy stuff on the light\n    float sun = (sunLightDiff+sunLightSpec)*soft;\n    float sub = (subLightDiff+subLightSpec);\n    float amb = 1.0;\n    vec3 lightValues = vec3(sun, sub, amb);\n    \n    // exposition\n    lightValues *= 0.06;\n    // gamma correction\n    lightValues = pow( lightValues, vec3(1.0/2.2) );\n    // cel shading\n    lightValues = floor(lightValues * 7.0) / 6.0;\n    \n    // compose color\n    vec3 color = vec3(0);\n    color += albedo*sunLight*lightValues.x;\n    color += albedo*subLight*lightValues.y;\n    color += albedo*ambLight*lightValues.z;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    // position of the camera\n    vec3 camPos = vec3(-40, 0, 0);\n    // user input\n    vec2 mouse=(iMouse.xy / iResolution.xy - 0.5) * 0.5;\n    mouse *= step(1.0, iMouse.z);\n    camPos.xz *= rot(mouse.y*-3.0+0.4);\n    camPos.xy *= rot(mouse.x*-10.0+0.2);\n    \n    // direction of the camera\n    vec3 forward = normalize(vec3(0) - camPos);\n    // right and top vector\n    vec3 right = normalize(cross(vec3(0, 0, 1), forward));\n    vec3 top = cross(forward, right);\n    \n    // create direction\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.y *= iResolution.y / iResolution.x;\n    uv *= 0.2;\n    #ifdef SHOW_ANT\n    uv *= 0.2;\n    #endif\n    vec3 dir = normalize(forward + right*uv.x + top*uv.y);\n    \n    // some noise is always useful\n    vec3 noise = hash33(vec3(fragCoord.xy, iFrame));\n    \n    bool hit = false;\n    float prevDist = 0.0;\n    float borderAcc = 1.0;\n    \n    float totdist = 0.0;\n    totdist += de(camPos)*noise.x;\n    \n\tfor (int i = 0 ; i < RAYS_STEPS ; i++) {\n\t\tvec3 p = camPos + totdist * dir;\n        float dist = de(p);\n        \n// if you replace 0.0015 by the sine of the pixel angle, you get the average opacity in a pixel\n// by accumulating the opacity front to back you can get an anti-aliased edge\n// problem is you have to compute the normal to shade the surface and get the effective color\n// computing the normal at every steps is too expensive (unless the normal is analytical)\n// nonetheless the border color is constant so we can cone trace it without any trouble\n        \n        // cone trace the border\n        if (dist > prevDist) {\n            float prox = dist / (totdist*0.0015);\n            float alpha = clamp(prox * 0.5 + 0.5, 0.0, 1.0);\n            borderAcc *= alpha;\n        }\n        \n        // hit a surface, stop here\n        if (dist < 0.01) {\n            hit = true;\n            break;\n        }\n        \n        // continue forward\n        totdist += min(dist*0.85, 100.0);\n        prevDist = dist;\n\t}\n    \n    // color and lights\n    if (hit) {\n        vec3 p = camPos + totdist * dir;\n    \tfragColor.rgb = computeColor(p, dir, fragCoord.xy);\n    } else {\n        fragColor.rgb = vec3(0.8, 0.8, 0.9);\n    }\n    \n    // add a black border\n    borderAcc = pow(borderAcc, 8.0);\n    fragColor.rgb = mix(vec3(0), fragColor.rgb, borderAcc);\n    \n    // vigneting\n    vec2 p = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), dot(p, p)*0.2);\n\t\n    // add some noise\n    fragColor.rgb += noise * 0.08 - 0.04;\n    \n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XssczX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 279, 303, 303, 375], [377, 407, 434, 434, 592], [594, 612, 649, 649, 734], [735, 735, 799, 799, 926], [927, 927, 970, 970, 1030], [1031, 1031, 1081, 1081, 1174], [1175, 1175, 1225, 1225, 1318], [1320, 1384, 1418, 1418, 1672], [1674, 1706, 1834, 1885, 2610], [2612, 2679, 2776, 2776, 9236], [9238, 9317, 9395, 9395, 10916], [10918, 10918, 10941, 10941, 11063], [11065, 11100, 11145, 11145, 11263], [11265, 11296, 11367, 11367, 11752], [11754, 11791, 11855, 11888, 13788], [13790, 13790, 13847, 13879, 16392]]}
{"id": "XssyDM", "name": "SmallPlanet", "author": "kuvkar", "description": "Small planet with atmosphere, clouds, shores etc. Look around with mouse. Sunset effect at around 30 seconds.", "tags": ["clouds", "water", "planet", "shadows", "stars", "atmoshpere"], "likes": 29, "viewed": 869, "published": "Public", "date": "1488809876", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n\tSmall planet with atmosphere, clouds, shores, water etc.\n\t---------------------------------------------------------\n\t\t\n    Most of the stuff is pretty basic raytracing/marching, there might be couple of things worth mentioning:\n\n\tI tried a couple of ways to texture a planet. I first tried cube mapping but that caused\n    really ugly seams. I ended up texturing the sphere by mapping the texture onto the planet spherically,\n    and then countering the distortion at the poles by changing uv coordinates from polar to rectangular.\n\tNeeds 2 texture lookups, as both poles need to be countered for distortion. \n\n\tBetter explanation of the process is here: https://www.youtube.com/watch?v=Xxg7pOIDAqQ\n\n\tAtmospheric scattering is not physically accurate at all, but looks good enough and is really fast.\n\t\n\tThere are smaller waves around the shores. They are barely visible now in the windowed mode, I started \n    with camera much closer, and ended up with the shore waves barely being visible. Oh well, at least\n    they can be seen in fullscreen.\n\t\n\tThe nebula is a warped texture that is mapped cylinderically around.\n\n*/\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\nvec3 lightDir = normalize(vec3(0.0, 1.0, -1.0));\nconst float SHELL = 0.25;\nconst float OUTER_SHELL = SHELL + 0.1;\nconst float H = (OUTER_SHELL - SHELL)*.7;\nconst float WATERLEVEL = SHELL+H*0.2;\n#define PI 3.14159265358\n#define PI2 (PI*0.5)\n\n#define DO_CLOUDS\n#define SHADOWS\n\n\nvec2 polar2Rect(in vec2 uv)\n{\n    vec2 _uv = uv;\n    uv.x = cos(_uv.x)*_uv.y;\n    uv.y = sin(_uv.x)*_uv.y;\n    return uv;\n}\n\n// maps a texture to a sphere\nvec4 textureSpherical(in sampler2D tex, in vec3 rp, float scale)\n{\n    float lrp = length(rp);\n    vec2 uv1 = vec2(atan(rp.y, rp.x), acos(rp.z/lrp));\n    vec2 uv2 = uv1; uv2.y = PI-uv1.y;\n    float f=uv1.y;\n\n    uv1=polar2Rect(uv1)*scale;\n    uv2=polar2Rect(uv2)*scale;\n    \n    vec4 c1 = texture(tex, uv1);\n    vec4 c2 = texture(tex, uv2);\n    return mix(c1, c2, smoothstep(PI2-0.01, PI2+0.01, f));\n}\n\nmat3 g_planetRot;\n\nvec3 planetRotatedVec(in vec3 p)\n{\n    return p*g_planetRot;\n}\n\nfloat map(in vec3 rp)\n{\n    float h = textureSpherical(iChannel0, planetRotatedVec(rp), .6).r;\n    h = smoothstep(0.1, 1.0, h);\n    h*=H*.5;\n    return  length(rp) - (SHELL+h);\n}\n\n\nvec3 grad(in vec3 rp)\n{\n    vec2 off = vec2(0.0005, 0.0);\n    vec3 g = vec3(map(rp + off.xyy) - map(rp - off.xyy),\n                  map(rp + off.yxy) - map(rp - off.yxy),\n                  map(rp + off.yyx) - map(rp - off.yyx));\n    return normalize(g);\n}\n\nvec3 traceSphere(in vec3 ro, in vec3 rd, float r, out float t1, out float t2)\n{\n    t1=t2=-1.0;\n    vec3 X = ro + rd * (dot(normalize(-ro), rd)) * length(ro);\n    float disc = r*r-pow(length(X), 2.0);\n    if (disc < 0.0) return vec3(1000000.0);\n    disc=sqrt(disc);\n    vec3 p=X-disc*rd;\n    t1=length(p-ro);t2=t1+disc*2.;\n    return p;\n}\n\nfloat getClouds(in vec3 hitp, float T)\n{\n    hitp *= rotx(-T);\n    vec3 hitp3 = hitp*rotz(T*.7);\n    vec3 hitp2 = hitp*roty(T);\n    \n    if(dot(hitp, hitp) > 10000.) return 0.;\n    float S = 1.;\n    float c = textureSpherical(iChannel0, hitp, .2*S).r*.75;\n    c += textureSpherical(iChannel0, hitp3, .7*S).r*.5*.5;\n    c += textureSpherical(iChannel0, hitp2, 1.4*S).r*.5*.5*.5;\n    c += textureSpherical(iChannel0, hitp, 2.4*S).r*.5*.5*.5*.5;\n    c += textureSpherical(iChannel0, hitp3, 4.4*S).r*.5*.5*.5*.5*.5;\n    return smoothstep(.55, .95, c);\n    \n}\n\nfloat traceClouds(in vec3 ro, in vec3 rd, float depth)\n{\n    float T = iTime*.02;\n    float t1=0.; float t2=0.;\n    if(t1<0.0) return 0.0;\n    vec3 hitp = traceSphere(ro, rd, OUTER_SHELL,t1,t2);\n    vec3 hitp2 = ro+rd*t2;\n    float c = getClouds(hitp, T);\n    if (depth > length(hitp2-ro))\n    {\n        float c2=getClouds(ro+rd*t2,T);\n        c=mix(c, c2, c2);\n    }\n    return c;\n}\n\nvec2 g_uv;\nvec3 g_viewDir;\n#define CLOUDS 0\n#define GROUND 1\n#define WATER 2\n\nvec4 waterTexture(in vec3 rp)\n{\n    rp=planetRotatedVec(rp);\n    float T = iTime*.01;\n    float S=2.0;\n    rp *= rotx(T);\n    float c1=textureSpherical(iChannel1, rp, S).x;\n    rp *= rotx(1.+T);\n    float c2=textureSpherical(iChannel1, rp, S).x;\n    rp *= rotx(2.+T);\n    float c3=textureSpherical(iChannel1, rp, S).x;\n    float B = iTime*2.;\n    float col = mix(c3, mix(c1, c2, 0.5+0.5*(sin(PI*0.5+B)*0.5+0.5)), 0.5+0.5*(sin(B)*0.5+0.5));\n    return vec4(col);\n    \n}\n\nvec3 gradWater(in vec3 rp)\n{\n    vec3 w=normalize(rp);\n    vec3 u=normalize(cross(vec3(0.0, 1.0, 0.0), w));\n    vec3 v=(cross( u,w));\n    \n    float s=.0009;\n    float h1 = waterTexture(rp).x;\n    float h2 = waterTexture(rp+u*s).x;\n    float h3 = waterTexture(rp+v*s).x;\n    \n    float bumpiness=.2;\n    vec3 v1 = normalize(vec3(bumpiness, h1-h2, 0.0));\n    vec3 v2 = normalize(vec3(0.0, bumpiness , h1-h3 ));\n    vec3 g = normalize(cross(v1,v2));\n    mat3 m; m[0]=v;m[1] = u;m[2]=w;\n    return m*g;\n}\n\n// Background nebula\nvec4 texSpace(in sampler2D tex, in vec3 dir)\n{\n    vec2 uv = vec2(atan(dir.x, dir.z), dir.y);\n    uv.x=abs(uv.x);\n\tuv*=.4;\n    vec4 col = texture(tex, uv);\n    uv+=col.rg*.05;\n    col = texture(tex, uv);\n    uv+=col.rg*.1;\n    col = texture(tex, uv);\n    \n    col*=smoothstep(0.1, 1.0, col.r);\n    vec4 col1=vec4(0.2, 0.2, .7, 0.0);\n    vec4 col2=vec4(0.2, 0.9, 0.5, 0.0);\n    vec4 cl=col*vec4(0.0, 0.5, 1.0, 0.0);\n    cl=mix(cl, col1, smoothstep(0.0, 0.4, col.r));\n    cl=mix(cl, col2, smoothstep(0.1, 0.6, col.r));\n    col=cl;\n    \n    col*=smoothstep(0.4, 0., abs(dir.y));\n    col*=smoothstep(1., .5, abs(uv.x));\n    col*= clamp((.6-abs(dir.y))-0.1*sin(2.0*atan(dir.x, dir.z)), 0.0, 1.0);\n    return col;\n}\n\nvec4 bgCol(in vec3 rd)\n{\n    vec4 col=texSpace(iChannel0, rd);\n    col+=smoothstep(0.93, 1.0, textureSpherical(iChannel2, rd, 1.0).g)*texture(iChannel1, vec2(.01*iTime+atan(rd.z, rd.x), rd.y)).r;\n    return col*.2;\n}\n\nfloat doShadows(in vec3 rp)\n{\n    float s = 1.0;\n    rp+=lightDir*.01;\n    \n    for (int i = 0; i < 4; ++i)\n    {\n    \tfloat dist=map(rp);\n        rp+=max(dist, 0.001)*lightDir;\n        s=min(s,dist);\n    }\n    return mix(1.0, clamp(s/0.01, 0.0, 1.0), 0.8);\n}\n\nvoid trace(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    vec4 top =   vec4(.3, .1, .2, .0)*.1;\n    vec4 bottom= vec4(.1, .0, .2, .0)*.1;\n    \n    color = mix(top, bottom, clamp(rd.y+0.5, 0.0, 1.0));\n    \n    color+=bgCol(rd);\n    bool hit = false;\n    vec3 ro = rp;\n    int hitId = CLOUDS;\n    float t1Clouds=0.0;float t2Clouds=0.0;\n    vec3 hitp = traceSphere(ro, rd, OUTER_SHELL,t1Clouds,t2Clouds);\n    \n    float dist = 99.;\n    \n    for (int i = 0; i < 20; ++i)\n    {\n        dist = map(rp);\n        rp += max(0.008, dist) * rd;\n\n        if (dist < 0.0)\n        {\n            hitId = GROUND;\n            break;\n        }\n\n        if (length(ro - rp) > 5.0) break;\n    }\n\n    \n    if (hitId==GROUND)\n    {\n        for (int i = 0; i < 8; ++i)\n        {\n            rp += rd*dist*.4;\n            dist = map(rp);\n        }\n    }\n\n    float depth = length(ro-rp);\n    float t1=0.0;float t2=0.0;\n\tvec3 waterLevelRp = traceSphere(ro, rd, WATERLEVEL+0.00*(sin(iTime*.25)*.5+.5),t1,t2);\n    float wdepth = length(ro-waterLevelRp);\n\t\n    if (wdepth < depth)\n    {\n        hitId=WATER;\n    }\n    \n    float waterLevel = map(waterLevelRp);\n    vec3 gGround = grad(rp);\n    vec3 gWaterSurface = normalize(waterLevelRp);\n    \n    float dGround = clamp(dot(gGround, lightDir), 0.05, 1.0);\n    float dWater = clamp(dot(gWaterSurface, lightDir), 0.05, 1.0);\n    float dGlobal = clamp(dot(normalize(rp), lightDir), 0.05, 1.0);\n    vec3 wg = gradWater(waterLevelRp);\n    dGlobal=(0.9+dGlobal)/(1.9);\n    \n    vec3 H = normalize(-rd+lightDir);\n    float dSpec = clamp(dot(H, wg), 0.0, 1.0);\n    dSpec = pow(dSpec, 56.0)*.7;\n    dSpec*=smoothstep(0.1, 0.2, dGlobal);\n    dGround*=dGlobal;\n    dWater*=dGlobal;\n    \n    if (hitId==GROUND)\n    {\n        vec4 cl = vec4(1.);\n        color=mix(cl, vec4(0.3, 0.5, 0.0, 0.5)*textureSpherical(iChannel2, rp, 16.0), 1.-smoothstep(0., 0.02, length(rp-waterLevelRp)));\n        color*=dGround;\n    }    \n\t\n    ////////\n    // Foam\n    ////////\n    if (hitId==WATER)\n    {\n        \n        float s = smoothstep(.007, .0, waterLevel);\n        vec4 c1 = vec4(0., 0.13,  0.3, 0.0);\n        vec4 c2 = vec4(0., 0.4, 0.6, 0.0);\n        \n        vec4 cl = mix(c1, c2, s);\n\t\tconst int stps = 4;\t\n        const float STP=2.;\n        const float phase=STP/float(stps);\n        float foam = 0.0;\n        const float b=STP/4.;\n        for (int i = 0; i < stps; ++i)\n        {\n            float T=iTime*.2+float(i)*phase;\n            vec3 _rp = waterLevelRp*3.;\n\t\t\tfloat p = mod(T, STP); \n            _rp-=p*gGround*.05;\n            \n            float f = textureSpherical(iChannel3, _rp, 3.0).r;\n\t\t\tf*=smoothstep(0.0, b, p);\n            f*=smoothstep(STP, STP-b, p);\n            foam = max(foam, f);\n        }\n       \tfoam = smoothstep(0.6, .9, foam);\n        foam*=s;\n        foam/=.4;\n        \n        float dFinal = mix(dWater, dGround, dGround);\n        cl += foam;\n        color = cl * dFinal;\n\t    color += vec4(dSpec);\n    }\n\t\n    \n    if (hitId==0 )\n    {\n        // Sun\n        float sund=clamp(dot(rd, lightDir), 0.0, 1.0);\n        float sunocc=clamp(dot(g_viewDir, lightDir), 0.0, 1.0);\n        sunocc=smoothstep(1.002, 0.99, sunocc);\n        float sun=(pow(sund, 40.))*sunocc;\n        sun=max(sun, smoothstep(0.99, 0.995, sund));\n        vec4 suncol=vec4(sun);\n        // cheap atmospeheric scattering effect. \n        //\n        // red scattering, direct light transport from sun to eye\n        vec4 mie=vec4(1.0, 0.2, 0., 1.0)*(t2Clouds-t1Clouds)*pow(sund, 15.)*3.;\n        \n        // blue, how much light gets reflected from ground to eye from sun\n        float rlscatter=clamp(dot(lightDir, reflect(rd,normalize(hitp))),0.2, 1.);\n        vec4 rayleigh=rlscatter*(t2Clouds-t1Clouds)*vec4(.4, .6, 1., 1.0);\n        // \n        vec4 atmos=mix(mie,rayleigh,1.-mie.a);\n        color+=atmos;                 \n        color+=suncol;                \n    }\n    \n    if(hitId!=0)\n    {\n\t    color*=doShadows(hitId==GROUND?rp:waterLevelRp);\n    }\n    \n    if(t1Clouds>=.0)\n    {\n#ifdef SHADOWS\n        vec3 nrp = normalize(rp);\n        float shad=traceClouds(nrp*10., -nrp, wdepth);\n    \n        if (hitId != CLOUDS)\n        {\n            color = mix(color, vec4(0.), shad*.7);\n        }\n#endif\n#ifdef DO_CLOUDS\n        float clouds = traceClouds(ro, rd, wdepth);\n        \n        // fading the clouds a little at the silhouettes\n        clouds*= mix(1.0, smoothstep(0.1, 0.4, abs(dot(rd, normalize(hitp)))), 0.9);\n        // dark side of the planet\n        float darkness=smoothstep(-0.4, 0.5,dot(normalize(hitp), lightDir));\n        color = mix(color, vec4(clouds*darkness), clouds);\n#endif\n    }\n\n    \n}\n\n\nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, 1.0, 0.0)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    return mat3(r, u, f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n\tvec2 uv = ((fragCoord.xy / iResolution.xy)-vec2(.5))*vec2(1.0, iResolution.y/iResolution.x);\n    g_uv = uv;\n    g_planetRot=roty(iTime*.008)*rotz(iTime*.02);\n\n    vec2 im = 16.0 * ((iMouse.xy / iResolution.xy) - vec2(0.5));\n    vec3 rp = vec3(0.0, 0.0, -.8);\n    if(iMouse.z<=0.0) \n    {\t\n        float T=PI*(4.0/3.0)-iTime*.1+6.;\n        im.x=(0.5+0.5*cos(T))*3.;\n    \tim.y=sin(T)*8.;\n    }\n    rp = roty(-im.x) * rp;\n    rp.y = -im.y*.25;\n    \n    vec3 rd = normalize(vec3(uv, 1.0));\n    rd = lookat(rp, vec3(0.0)) * rd;\n    g_viewDir=lookat(rp, vec3(.0))*vec3(0.0, 0.0, 1.0);\n    trace(rp, rd, fragColor);\n    \n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / 2.2));\n\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XssyDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 1129, 1149, 1149, 1276], [1277, 1277, 1297, 1297, 1424], [1425, 1425, 1445, 1445, 1572], [1851, 1851, 1880, 1880, 1974], [1976, 2006, 2072, 2072, 2407], [2428, 2428, 2462, 2462, 2490], [2492, 2492, 2515, 2515, 2670], [2673, 2673, 2696, 2696, 2929], [2931, 2931, 3010, 3010, 3269], [3271, 3271, 3311, 3311, 3825], [3827, 3827, 3883, 3883, 4210], [4290, 4290, 4321, 4321, 4758], [4760, 4760, 4788, 4788, 5261], [5263, 5284, 5330, 5330, 5993], [5995, 5995, 6019, 6019, 6211], [6213, 6213, 6242, 6242, 6472], [6474, 6474, 6528, 6528, 11097], [11100, 11100, 11133, 11133, 11333], [11336, 11336, 11393, 11393, 12095]]}
{"id": "XsXcDs", "name": "Mouse", "author": "TsinglW", "description": "Lovely face.\nGithub:https://github.com/ROOOO/Shadertoy", "tags": ["face", "lovely"], "likes": 7, "viewed": 120, "published": "Public", "date": "1490378586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EARSSIZE 0.25\n#define NOSESIZE 0.05\n#define MOUSTACHELENGTH 0.3\n#define ANTIALIAS 0.01\n#define PI 3.141592654\n\nvec2 scale(vec2 v, vec2 s) {\n\treturn mat2(s.x, 0, 0, s.y) * v;\n}\n\nvec2 rot(vec2 v, float angle) {\n\treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * v;\n}\n\nvec2 animate(vec2 uv) {\n    float tt = mod(iTime, 1.5) / 1.5;  \n    float ss = pow(tt, 0.2) * 0.5 + 0.5;  \n    ss = 1.0 + ss*0.5*sin(tt * PI * 2.0 * 3.0 + uv.y*0.5)*exp(-tt*4.0); \n    uv *= vec2(0.5,1.2) + ss * vec2(0.5,-0.2); \n\treturn uv;\n}\n\nvec4 heart(vec2 uv, vec2 center) {\n    vec2 p = uv - center;\n    float a = atan(p.x, p.y) / PI;\n    float r = length(p) / EARSSIZE;\n    float h = abs(a);\n    float d = (13.0 * h - 22.0 * h * h + 10.0 * h * h * h) / (6.0 - 5.0 * h);\n\tfloat t = smoothstep(-ANTIALIAS, ANTIALIAS, r - d);\n    return vec4(0.8, 0.3, 0.4, 1.0 - t);\n}\n\nvec4 ear(vec2 uv, vec2 center) {\n    float d1 = length(uv - center) - EARSSIZE;\n    float t1 = smoothstep(0.0, ANTIALIAS, d1);\n    float r = 4.5 * EARSSIZE;\n    float d2 = length(uv - vec2(center.x, center.y - r)) - 4.0 * EARSSIZE;\n    float t2 = smoothstep(0.0, ANTIALIAS, d2);\n\treturn vec4(0.3, 0.3, 0.3, d2 > 0.0 ? (1.0 - t1) : t2);\n}\n\nvec4 nose(vec2 uv, vec2 center) {\n    float d = length(uv - center);\n    float t = smoothstep(NOSESIZE, NOSESIZE + ANTIALIAS, d);\n\treturn vec4(0.0, .0, .0, 1.0 - t);\n}\n\nvec4 moustache(vec2 uv, vec2 p) {\n    uv.x = abs(uv.x);\n    float r = length(uv - p);\n    vec2 m = vec2(uv.x, sin(uv.x / MOUSTACHELENGTH * 2.0 * PI - iTime * 5.) * r);\n    m.y /= 5.0;\n    float d = length(uv - m);\n    float t = smoothstep(0.01, 0.01 + ANTIALIAS, d);\n    t = uv.x < p.x || uv.x > p.x + MOUSTACHELENGTH ? 1.0 : t;\n\treturn vec4(1.0, 1.0, 1.0, 1.0 - t);\n}\n\nvec4 mulNoise(vec4 col, float f) {\n    vec3 c = col.rgb * f;\n\treturn vec4(c, col.a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    uv.y += 0.25;\n      \n    vec4 bgCol = vec4(0.7, 0.6, 0.5, 1.0);\n    \n    vec4 nCol = nose(uv, vec2(0.0, 0.0));\n    \n    vec2 m1UV = rot(uv, 30.0 / 180.0);\n    vec4 m1Col = moustache(m1UV, vec2(MOUSTACHELENGTH, 0.0));\n    vec2 m2UV = rot(uv, -30.0 / 180.0);\n    vec4 m2Col = moustache(m2UV, vec2(MOUSTACHELENGTH, 0.0));\n    \n    vec2 e1UV = rot(uv, -PI / 5.0);\n    e1UV = scale(e1UV, vec2(1.0, 1.1));\n    vec2 e2UV = rot(uv, PI / 5.0);\n    e2UV = scale(e2UV, vec2(1.0, 1.1));\n\n    e1UV = animate(e1UV);\n    e2UV = animate(e2UV);\n    \n    vec4 e1Col = ear(e1UV, vec2(0.0, 0.8));\n    vec4 e1hCol = heart(e1UV, vec2(0.0, 0.93));\n    vec4 e2Col = ear(e2UV, vec2(0.0, 0.8));\n    vec4 e2hCol = heart(e2UV, vec2(0.0, 0.93));\n    \n    vec4 col = bgCol;\n    col = mix(col, nCol, nCol.a);\n    col = mix(col, m1Col, m1Col.a);\n\tcol = mix(col, m2Col, m2Col.a);\n\tcol = mix(col, e1Col, e1Col.a);\n    col = mix(col, e1hCol, e1hCol.a);\n\tcol = mix(col, e2Col, e2Col.a);\n    col = mix(col, e2hCol, e2hCol.a);\n\n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXcDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 147, 147, 183], [185, 185, 216, 216, 285], [287, 287, 310, 310, 528], [530, 530, 564, 564, 857], [859, 859, 891, 891, 1196], [1198, 1198, 1231, 1231, 1365], [1367, 1367, 1400, 1400, 1735], [1737, 1737, 1771, 1771, 1823], [1825, 1825, 1882, 1882, 2982]]}
{"id": "XsXcRB", "name": "Constant Time Demo", "author": "openflower", "description": "Demo of possible technique for eventually achieving constant time on CS8EC by 4onen", "tags": ["cs8ec"], "likes": 1, "viewed": 101, "published": "Public", "date": "1488593128", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float n = 10.0;\n\nconst float rateOfTime = 1.0; // = speed of rotation in rad/sec\nconst float screenSize = 2.0;\n\nconst float circleRadius = 1.0; //radius of circes\nconst float d = 2.0; //distance from center of screen to center of circle\nconst float circleWidth = .01;\nconst float bulletWidth = .05;\nconst float lineWidth = .1; //width of line in units of time, not distance\n\n\n\n\n\n//A list of colors. Have fun messing with these!\nconst vec4 bgColor = vec4(0.25,0.0,0.3,1.0);\nconst vec4 polyColor = vec4(5.0,0.0,5.0,1.0);\nconst vec4 lineColor = vec4(1.0,0.99,1.0,1.0);\nconst vec4 capColor = vec4(1.0);\n\nconst float tau = 6.2831853071795864769;\n//START: HELPER FUNCTIONS------------------------------------------------------------------------\n\nbool inFrame(vec2 xy, float radius)\n{\n   return( \n       abs(xy.y) < circleRadius + bulletWidth &&                  //y within bounds of picture and\n      (\n       abs(xy.x) < d                                              //x between centers of circles\n       ||                                                      //or\n       radius < circleRadius + bulletWidth  //inside the two semicircles that stick out\n      )\n   );\n}\n\n\nbool inCircle(vec2 xy)\n{\n    return(abs(length(xy) - circleRadius) < .1);\n}\n\nfloat time()\n{\n    return(mod(iTime,tau)*rateOfTime);\n}\n\n\nbool inBullet(vec2 xy, float radius, float time)\n{\n    return(\n        abs(length(vec2(abs(abs(xy.x)-d),xy.y))-circleRadius) < bulletWidth //&& abs(atan(xy.y,xy.x)-time) < bulletWidth\n        );\n}\n\n\nfloat timeInLine(vec2 xy, float d)\n{\n    float x = xy.x;\n    float y = xy.y;\n    return(2.0*atan((-sqrt(-4.0*d*d*y*y+2.0*d*d+2.0*x*x+2.0*y*y-1.0)+d-x+y)/(2.0*d*y+d+x+y+1.0)));\n}\n\n//----------------------------------------\n\n\n\n\n\n\n\n//MAIN------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Make an aspect ratio out of it and align the origin to the center of the screen\n    vec2 xy = screenSize*(-1.0 + 2.0*fragCoord/iResolution.xy);\n    xy.x *= iResolution.x/iResolution.y;\n \n    \n    \n    \n    float radius = sqrt(pow((abs(xy.x)-d),2.0) + pow((xy.y),2.0));\n    if(abs(radius-1.0)<.005)\n    {\n        fragColor = polyColor;\n        return;\n    }\n    \n    \n    //The current time, in two second loops.\n    //0.0 is 0 seconds, tau is two seconds.\n    float time = time();\n    \n    \n    if (inBullet(xy,radius,time))\n        fragColor = capColor;\n    \n    \n    \n\n  \n    //don't do anything else if the pixel obviously isn't in picture\n    //this step should come before calculation of time\n    //only where it is right now b/c I'm not worried about optimization yet\n    if(abs(xy.y)>1.0 || (abs(xy.x) > 2.0 && radius > 1.0))\n       {\n       fragColor = bgColor;\n       return;\n       }\n    \n    \n    \n    //draw line\n   \t//if (!(r < 1.0 && xy.x < 0.0))\n    if(abs(mod(timeInLine(xy,d)-time,tau/n))<0.1\n       && (!(radius < 1.0 && xy.x < 0.0))||\n       \n       abs(mod(timeInLine(vec2(-xy.x,xy.y),d)+time-tau/4.0,tau/n))<0.1 \n       && (!(radius < 1.0 && xy.x > 0.0))\n\n       //(mod(timeInLine(vec2(-1.0*xy.x,xy.y),d)-time,tau/n)<0.1))\n       \n      )\n    {\n        fragColor = lineColor;\n        return;\n    }\n    \n    \n    \n    \n    fragColor = bgColor;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXcRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[647, 746, 783, 783, 1171], [1174, 1174, 1198, 1198, 1249], [1251, 1251, 1265, 1265, 1306], [1309, 1309, 1359, 1359, 1505], [1508, 1508, 1544, 1544, 1685], [1737, 1816, 1873, 1959, 3250]]}
{"id": "XsXcWS", "name": "Funcky Triangle", "author": "Ahmidou", "description": "A funky and colorful effect done by taking some parts from other shaders and tweaking a bit", "tags": ["2d", "triangle", "colors", "aimation"], "likes": 3, "viewed": 502, "published": "Public API", "date": "1489530452", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// note that your triangle was drawn for 2*h\nbool isInTriangle(vec2 U, float h, float a)\n{\n    float s = sin(a), c = cos(a);\n  \tU *= mat2(c,-s,s,c);\n    \n    return     U.y > - h/3.  // distance from center to each sides\n         && .5*U.y - 1.73/2. * U.x < h/3.\n         && .5*U.y + 1.73/2. * U.x < h/3.;\n}\nvec3 hsv2rgb(float h, float s, float v)\n{\n    h = fract(h);\n    vec3 c = smoothstep(2./6., 1./6., abs(h - vec3(0.5, 2./6., 4./6.)));\n    c.r = 1.-c.r;\n\n    return mix(vec3(s), vec3(1.0), c) * v;\n}\n\nvec3 getRandomColor(float f, float t)\n{\n    return hsv2rgb(f+t, 0.2+cos(sin(f))*0.3, 0.9);\n}\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    float step = 15.0;\n\tvec2  R = iResolution.xy;\n    float t = iTime;\n    O =  vec4(1.0, 1.0, 1.0, 1.0);\n    for(int i = 0; i < int(step); i++) {\n        float m = 1.0/(step+1.0)*float(i);\n        vec3 color = getRandomColor(float(i) *0.05 + 0.01, t);\n\n        bool test = isInTriangle((U-.5*R)/R.y+(float(i)*0.01), mod(1000.0 - t, 1000.0/R.y) * 3.0 - m*15.0, (3.1415 * t)+(float(i)*5.0));\n        if( test )   \n    \t\tO =  vec4(color, 1);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXcWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 45, 90, 90, 307], [308, 308, 349, 349, 504], [506, 506, 545, 545, 598], [600, 600, 639, 639, 1087]]}
{"id": "XsXyzj", "name": "Raymarching_Again", "author": "Nihilus", "description": "TODO:\n- refraction", "tags": ["reflection", "distancefields", "refraction"], "likes": 2, "viewed": 95, "published": "Public", "date": "1488904540", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 512\n#define EPSILON 0.00001\n#define MAX_DISTANCE 40.0\n#define MAX_REFLECTIONS 4\n#define MAX_REFRACTIONS 1\n#define NUM_LIGHTS 1\n//#define ANTIALIASING\n\n#define GLASS_ETA 1.5\n#define METAL_ETA 50.0\n#define MAX_ETA 20.0\n\n#define SKY_ID 0\n#define FLOOR_ID 4\n\n/*\n\tTODO:\n\t- implement refraction properly\n*/\n\n// Utility function to convert from integer RGB to float\nvec3 RGB(int r, int g, int b)\n{\n    return vec3(float(r), float(g), float(b))/255.0;\n}\n\n// Struct to keep track of the distance and the object ID\nstruct Object\n{\n    float d; \t\t\t// distance\n    int id; \t\t\t// used to identify the object\n    float eta; \t\t\t// used for refraction\n    bool reflection; \t// enable reflection\n    bool refraction; \t// enable refraction\n};\n\n// Signed distance of a point p from the surface of a sphere of radius r\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// Signed distance of a point p from the surface of a plane\nfloat sdPlane(vec3 p)\n{ \n    return p.y;\n}\n\n// Signed distance of a point p from the surface of a torus\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Unsigned distance of a point p from the surface of a box\nfloat udBox(vec3 p, vec3 b)\n{\n    return length(max(abs(p) - b, 0.0));\n}\n\n// Union of two objects using distance fields\nObject opUnion(Object ob1, Object ob2)\n{\n    if(ob1.d < ob2.d)\n        return ob1;\n    else\n        return ob2;\n}\n\n// Subtraction of two objects using distance fields\nObject opSubtract(Object ob1, Object ob2)\n{\n    if(-ob1.d < ob2.d)\n        return ob1;\n    else if(-ob2.d < ob1.d)\n        return ob2;\n}\n\n// Find the distance of the point p to the nearest object\n// Scene for testing purpose\nObject map(vec3 p)\n{\n    Object s1 = Object(\n        sdSphere(p - vec3(0.0, 0.6, 0.0), 0.6),\n        6,\n        GLASS_ETA,\n        true,\n        true\n    );\n    \n    Object b1 = Object(\n        udBox(p - vec3(0.0, 0.5, 0.0), vec3(0.5)),\n        6,\n        METAL_ETA,\n        false,\n        true\n    );\n\n    Object b2 = Object(\n        udBox(p - vec3(1.2, 0.5, 1.2), vec3(0.5)),\n        1,\n        METAL_ETA,\n        true,\n        false\n    );\n    Object b3 = Object(\n        udBox(p - vec3(1.2, 0.5, -1.2), vec3(0.5)),\n        2,\n        METAL_ETA,\n        true,\n        false\n    );\n    Object b4 = Object(\n        udBox(p - vec3(-1.2, 0.5, 1.2), vec3(0.5)),\n        3,\n        METAL_ETA,\n        true,\n        false\n    );\n    Object b5 = Object(\n        udBox(p - vec3(-1.2, 0.5, -1.2), vec3(0.5)),\n        5,\n        METAL_ETA,\n        true,\n        false\n    );\n    \n    Object p1 = Object(\n        sdPlane(p),\n        FLOOR_ID,\n        METAL_ETA,\n        true,\n        false\n    );\n    \n    Object res = opUnion(s1, p1);\n    //Object res = opUnion(b1, p1);\n    \n    res = opUnion(res, b2);\n    res = opUnion(res, b3);\n    res = opUnion(res, b4);\n    res = opUnion(res, b5);\n    \n    return res;\n}\n\n// Return the object color based on the id and the point\nvec3 color(int id, vec3 p)\n{\n    if(id == 1)\n    {\n        return RGB(204, 70, 70);\n    }\n    else if(id == 2)\n    {\n        return RGB(94, 204, 30);\n    }\n    else if(id == 3)\n    {\n        return RGB(30, 105, 204);\n    }\n    else if(id == 4)\n    {\n        // Implement checkerboard pattern\n        vec3 grey = RGB(255, 255, 255);\n        float f = mod(floor(4.0*p.z) + floor(4.0*p.x), 2.0);\n        return 0.3 + grey * f;\n    }\n    else if(id == 5)\n    {\n        return RGB(200, 160, 0);\n    }\n    else if(id == 6)\n    {\n        return RGB(255, 255, 255);\n    }\n    return RGB(255, 255, 100);\n}\n\n// Determine the normal of a surface (gradient trick)\nvec3 normal(vec3 p) {\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t\tmap(p + eps.xyz).d - map(p - eps.xyz).d,\n\t\tmap(p + eps.zxy).d - map(p - eps.zxy).d,\n\t\tmap(p + eps.yzx).d - map(p - eps.yzx).d\n\t);\n\treturn normalize(nor);\n}\n\n// Determine light on the surface of an object: Lambertian model\n// https://en.wikipedia.org/wiki/Lambertian_reflectance\nvec3 LambertianLight(vec3 p, int id)\n{\n    // Check if we are dealing with the background\n    if(id == 0)\n        return color(id, p);\n    \n    // Add light to the object (light intensity and source)\n    vec3 li = RGB(255, 255, 255);\n    vec3 ls = vec3(2.0*cos(iTime), 2.5, 2.0*sin(iTime));\n    //vec3 ls = vec3(0.0, 2.5, -1.0);\n    \n    // Determine the normal vector and the Lambertian coefficient\n    vec3 sn = normal(p);\n    vec3 ls_p = normalize(ls - p); // light source to surface point vector\n    float NdotL = clamp(dot(ls_p, sn), 0.0, 1.0);\n    \n    // Determine light intensity based on the distance between the light source and the object\n    float k = 0.2;\n    NdotL *= (1.0 / (1.0 + dot(ls_p, ls_p) * k));\n    \n    // Add ambience light (light color and source)\n    vec3 alc = RGB(255, 255, 255);\n    //alc = vec3(0.0); // Disabling ambient light!\n    vec3 als = vec3(0.0, 1.0, 0.0);\n    \n    // Determine the Lambertian coefficient and the ambience light intensity\n    float aNdotL = 0.5 * dot(sn, normalize(als));\n    float ak = 1.0;\n    aNdotL *= (1.0 / (1.0 + dot(als, als) * ak));\n    \n    // Add object occlusion\n    float occ = 0.5 + 0.5 * sn.y;\n    \n    // Apply the Lambertian reflectance\n    vec3 c = color(id, p);\n    c *= NdotL;\n    c += aNdotL * alc;\n    c += 0.05 * occ; \n    return c;\n}\n\n// Determine the object shadow using the light origin and direction\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat shadow(vec3 origin, vec3 direction) {\n    float hit = 1000.0;\n    float t = EPSILON;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float d = map(origin + direction * t).d;\n        if (d < EPSILON)\n            return 0.05;\n        t += d;\n        hit = min(hit, 20.0 * d / t);\n        if (t > MAX_DISTANCE)\n            break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\n// Determine reflection using Reflected Ray Origin and Direction\nvec3 reflection(vec3 rro, vec3 rrd, vec3 ls)\n{\n    vec3 p = vec3(0.0);\n    vec3 c = vec3(1.0);\n    // Save ray origin\n    vec3 origin = rro;\n    float t = 0.01;\n    Object hit = Object(0.0, 0, 0.0, false, false);\n    // Reflect more times\n    for(int j = 0; j < MAX_REFLECTIONS; j++)\n    {\n        // Raytrace the reflection vector\n        for(int i = 0; i < MAX_STEPS; i++)\n        {\n            // Check if we hit an object in the scene\n            hit = map(rro + rrd * t);\n            if(hit.d < EPSILON)\n                break;\n            // Reset hit object to default\n            hit = Object(hit.d, 0, 0.0, false, false);\n            // Increment the steps\n            t += hit.d;\n            // Check the maximum distance\n            if(t > MAX_DISTANCE)\n                break;\n        }\n        // Check if we hit the sky\n        if(hit.id == SKY_ID)\n        \tbreak;\n        // We hit an object, determine if it reflects\n        if(hit.reflection == false)\n            break;\n        // We hit an object, determine the base color\n        p = rro + rrd * t;\n        // We hit an object, determine if it refracts\n        if(hit.refraction == false)\n        \tc *= color(hit.id, p) * shadow(p, ls);\n        else\n            c *= color(hit.id, p);\n        // Determine new object normal and riflected ray direction\n        vec3 N = normal(p);\n        vec3 L = rrd;\n        vec3 R = normalize(reflect(L, N));\n        rro = p;\n        rrd = R;\n        t = 0.01;\n    }\n    return c;\n}\n\n// Determine refraction using Refraction Ray Origin and Direction\nvec3 refraction(vec3 rro, vec3 rrd, vec3 ls)\n{\n    Object hit = Object(0.0, 0, 0.0, false, false);\n    float t = 0.0;\n    // Raytrace the refraction vector\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        // Check if we hit an object in the scene\n        hit = map(rro + rrd * t);\n        // Check if we exited the object\n\t\tif(hit.d > EPSILON)\n            break;\n        // Reset hit object to default\n        hit = Object(hit.d, 0, 0.0, false, false);\n        // Increment the steps\n        t += 0.01;\n        // Check the maximum distance\n        if(t > MAX_DISTANCE)\n            break;\n    }\n    // Check if we hit the sky or a non refractive material\n    if(hit.id != 0)\n    {\n        // We hit the other face of the object\n        vec3 p = rro + rrd * t;\n        vec3 N = normal(p);\n        vec3 L = normalize(p - rro);\n        vec3 R = refract(L, -N, hit.eta);\n        // Trace to see which object the ray will hit\n        rro = p;\n        rrd = R;\n        t = 0.0;\n        for(int i = 0; i < MAX_STEPS; i++)\n        {\n            // Check if we hit an object in the scene\n            hit = map(rro + rrd * t);\n            if(hit.d < EPSILON)\n                break;\n            // Reset hit object to default\n            hit = Object(hit.d, 0, 0.0, false, false);\n            // Increment the steps\n            t += hit.d;\n            // Check the maximum distance\n            if(t > MAX_DISTANCE)\n                break;\n        }\n    }\n    vec3 c = color(hit.id, rro + rrd * t);\n    \n    if(hit.reflection == true)\n        c *= reflection(rro, rrd, ls);\n    \n    return c;\n}\n\n// Determine light on the surface of an object: Blinn-Phong model\n// https://en.wikipedia.org/wiki/Phong_reflection_model\n// https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\n// p = point on the surface\n// e = direction\n// eye = viewer eye location\n// ls = light source coordinates\n// lc = light color\n// obj = object hit by the ray\nvec3 light(vec3 p, vec3 e, vec3 eye, vec3 ls[4], vec3 lc[4], Object obj)\n{\n    // Check if we hit the background\n    if(obj.id == 0)\n        return color(obj.id, p);\n    \n    // Setup intensities: ambient, diffuse, specular, reflection\n    vec3 ia = RGB(255, 255, 255);\n    vec3 id = RGB(255, 255, 255);\n    vec3 is = RGB(255, 255, 255);\n    vec3 ir = RGB(255, 255, 255);\n    \n    // Setup reflection constants: ambient, diffuse, specular\n    vec3 ka = vec3(0.9);\n    vec3 kd = vec3(0.6);\n    vec3 ks = vec3(0.9);\n        \n    // Setup shininess of the material: specular\n    float a = 64.0;\n    \n    // Define base color\n    vec3 c = vec3(0.0);\n    \n    for(int i = 0; i < NUM_LIGHTS; i++)\n    {\n        // Determine useful vectors\n        vec3 N = normal(p);\t\t\t\t// vector normal to the surface\n        vec3 L = normalize(ls[i] - p); \t// light-point direction\n        vec3 H = normalize(-e + ls[i]); \t// light-eye direction\n\n        // Determine the diffuse and specular coefficients\n        float diff = clamp(dot(L, N), 0.0, 1.0);\n        float spec = clamp(pow(dot(H, N), a), 0.0, 1.0);\n\n        // Add ambient and object light\n        float occ = 0.5 + 0.5 * N.y;\n        float amb = clamp(0.5 + 0.5 * N.y, 0.0, 1.0);\n\n        // Add shadows to the image\n        float sha = shadow(p + N * EPSILON, L);\n\n        // Add surface reflection\n        vec3 esd = normalize(p - eye); // eye-surface direction\n        vec3 R1 = normalize(reflect(esd, N));\n        vec3 refl = reflection(p + N * EPSILON, R1, ls[i]);\n\n        // Determine Blinn-Phong value (with reflection too)\n        vec3 phong =\n            amb * ia * occ * ka\t\t\t\t\t\t\t\t\t\t\t// ambient\n            + diff * id * occ * kd\t\t\t\t\t\t\t\t\t\t// diffuse\n            + diff * spec * is * occ * ks\t\t\t\t\t\t\t\t// specular\n            ;\n        \n        // Check if we need to add reflection to the object\n        if(obj.reflection)\n            phong += diff * refl * ir * occ * exp(-1.4*p.y);\t\t\t\t// reflection\n        \n        // Check if we need to add refraction to the object\n        if(obj.refraction)\n        {\n            // Add surface refraction\n        \tvec3 esd2 = normalize(eye - p);\n        \tvec3 R2 = normalize(refract(esd2, N, 1.0/obj.eta));\n        \tvec3 refr = refraction(p - N * EPSILON, R2, ls[i]);\n            phong += occ * refr;\t\t\t\t\t\t\t\t\t\t// refraction\n        }\n        \n        // The light intensity depends on the distance\n        float li = 3.0; // light intensity tweaker\n        phong *= 1.0/(1.0 + dot(L, L) * li);\n        \n        // Mix lights\n        if(i == 0)\n        {\n            c = color(obj.id, p) * lc[i] * phong;\n            if(!obj.refraction)\n                c *= sha;\n        }\n        else\n        {\n            if(!obj.refraction)\n            \tc += color(obj.id, p) * lc[i] * phong * sha;\n            else\n                c += color(obj.id, p) * lc[i] * phong;\n        }\n        \n    }\n    \n    // Global intensity, let's tweak the shit out of this shader\n    c *= 1.8;\n    \n    return c;\n}\n\n// Raymarching algorithm with distance fields\nvec3 raymarch(vec3 ro, vec3 rd)\n{\n    // Save eye position\n    vec3 eye = ro;\n    // Define standard empty object\n    Object obj = Object(0.0, 0, 0.0, false, false);\n    // Maximum distance\n    float t = 0.0;\n    // Raymarch MAX_STEPS\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        // Passing the point origin to the scene\n        obj = map(ro);\n        // Checking if we hit something\n        if(obj.d < EPSILON)\n            break;\n        // Incrementing the step\n        ro += rd * obj.d;\n        // Reset object to default\n        obj = Object(obj.d, 0, 0.0, false, false);\n        // Keep track of the maximum distance\n        t += obj.d;\n        if(t > MAX_DISTANCE)\n            break;\n    }\n    // Determine pixel color\n    vec3 lc[4], ls[4];\n    lc[0] = vec3(1.0, 1.0, 1.0);\n    lc[1] = vec3(0.0, 0.0, 0.0);\n    lc[2] = vec3(0.0, 0.0, 0.0);\n    lc[3] = vec3(1.0, 1.0, 1.0);\n    ls[0] = vec3(4.0, 5.0, 4.0);\n    ls[1] = vec3(6.0, 5.0, -6.0);\n    ls[2] = vec3(-6.0, 5.0, 6.0);\n    ls[3] = vec3(-2.0, 5.0, -2.0);\n    vec3 color = light(ro, rd, eye, ls, lc, obj);\n    // Add fog to the image (distance)\n    float fogAmount = 1.0 - exp(-t*0.04);\n    return mix(color, RGB(255, 255, 255), fogAmount);\n}\n\n// Total control over the camera\nmat3 setCamera(vec3 origin, vec3 target, float rotation)\n{\n\tvec3 forward = normalize(target - origin);\n\tvec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized coordinates [-1, 1]\n    vec2 uv = 2.0*(fragCoord.xy/iResolution.xy) - 1.0;\n    \n    // Aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Camera position and \"look at\"\n    vec3 origin = vec3(0.0, 1.6, 0.0);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    \n    float speed = 0.5;\n    origin.x += 3.5 * cos(speed*iTime + 0.0*iMouse.x);\n    origin.z += 3.5 * sin(speed*iTime + 0.0*iMouse.y);\n    \n    mat3 toWorld = setCamera(origin, target, 0.0);\n    vec3 direction = toWorld * normalize(vec3(uv.xy, 2.0));\n    \n    // Raymarch scene  \n#ifdef ANTIALIASING\n    vec3 color = vec3(0.0);\n    vec3 point = origin;\n    float AA = 0.00055;\n    //float AA = 0.002;\n    for(int i = 0; i < 10; i++)\n    {\n        if(i == 1)\n        {\n            point.x = origin.x - AA;\n            point.y = origin.y - AA;\n            point.z = origin.z - AA;\n        } else if(i == 2)\n        {\n            point.x = origin.x + AA;\n            point.y = origin.y - AA;\n            point.z = origin.z - AA;\n        } else if(i == 3)\n        {\n            point.x = origin.x - AA;\n            point.y = origin.y + AA;\n            point.z = origin.z - AA;\n        } else if(i == 4)\n        {\n            point.x = origin.x + AA;\n            point.y = origin.y + AA;\n            point.z = origin.z - AA;\n        } else if(i == 5)\n        {\n            point.x = origin.x - AA;\n            point.y = origin.y - AA;\n            point.z = origin.z + AA;\n        } else if(i == 6)\n        {\n            point.x = origin.x + AA;\n            point.y = origin.y - AA;\n            point.z = origin.z + AA;\n        } else if(i == 7)\n        {\n            point.x = origin.x - AA;\n            point.y = origin.y + AA;\n            point.z = origin.z + AA;\n        } else if(i == 8)\n        {\n            point.x = origin.x + AA;\n            point.y = origin.y + AA;\n            point.z = origin.z + AA;\n        }\n    \tcolor += raymarch(point, direction);\n    }\n    color /= 10.0;\n#else\n    vec3 color = raymarch(origin, direction);\n#endif\n    // Adjust the gamma\n    vec3 gamma = vec3(1.0/0.9);\n    color = pow(color, gamma);\n    \n    // Return pixel color\n\tfragColor = vec4(color ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXyzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[320, 377, 408, 408, 463], [744, 817, 850, 850, 878], [880, 940, 963, 963, 982], [984, 1044, 1075, 1075, 1140], [1142, 1202, 1231, 1231, 1274], [1276, 1322, 1362, 1362, 1435], [1437, 1489, 1532, 1532, 1625], [1627, 1714, 1734, 1734, 2916], [2918, 2975, 3003, 3003, 3571], [3573, 3627, 3648, 3648, 3859], [3861, 3982, 4020, 4071, 5296], [5298, 5432, 5475, 5475, 5808], [5810, 5875, 5921, 5921, 7361], [7363, 7429, 7475, 7475, 9014], [9016, 9363, 9437, 9475, 12341], [12343, 12389, 12422, 12447, 13599], [13601, 13634, 13692, 13692, 13938], [13940, 13940, 13995, 14033, 16172]]}
{"id": "XtdGRl", "name": "raymarched fog volume", "author": "chadmiral", "description": "raymarch experiment bed\ncurrently only takes into account light absorption (not scatter)\nmove the light with the mouse!", "tags": ["raymarch", "sdf", "fog", "absorption"], "likes": 8, "viewed": 741, "published": "Public", "date": "1488682168", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MARCH_DIST      2.5\n#define MARCH_COUNT     20\n#define SCATTER_DEPTH   10\n#define SCATTER_DIST    2.5\n#define SPHERE_RADIUS   2.4\n#define SPHERE_DENSITY  3.0\n//#define LIGHT_POS vec3(1.0 * cos(iTime), 10.0, 15.0)\n#define LIGHT_COLOR 1.2 * vec3(0.5, 0.5, 1.0)\n#define ABSORPTION_COLOR 0.0028 * vec3(1.0, 0.85, 0.7)\n#define VOLUME_COLOR 0.045 * vec3(1.0, 0.75, 0.3)\n#define NOISE_SCALE 1.2\n#define BG_COLOR 1.3 * vec3(0.15, 0.25, 0.25)\n\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);\n \n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat get_density_at_pos(vec3 p)\n{\n    float d = (SPHERE_RADIUS - length(p)) / SPHERE_RADIUS;\n    float noise_mult = fbm(NOISE_SCALE * (p + vec3(0.0, 0.0, iTime)));\n    return clamp(noise_mult * SPHERE_DENSITY * d, 0.0, 1.0);\n}\n\n//TODO: actual Rayleigh scattering\nvec3 get_scatter_color(vec3 p)\n{\n    float absorption = 0.0;\n    vec2 m = 2.0 * iMouse.xy / iResolution.xy - 1.0;\n    vec3 light_pos = vec3(20.0 * m, 10.0);\n    vec3 light_dir = normalize(light_pos - p);\n    \n    float t = 0.0;\n    float rd = SCATTER_DIST / float(SCATTER_DEPTH);\n    \n    for(int i = 0; i < SCATTER_DEPTH; i++)\n    {\n    \tvec3 sp = p + t * light_dir;\n        float d = get_density_at_pos(sp);\n        absorption += d;\n    \tt+= rd;\n    }\n    \n   \n    return clamp(LIGHT_COLOR * VOLUME_COLOR - absorption * ABSORPTION_COLOR, 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//1 : retrieve the fragment's coordinates\n\tvec2 uv = ( fragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n\t//preserve aspect ratio\n\tuv.x *= iResolution.x / iResolution.y;\n\n\n\t//2 : camera position and ray direction\n\tvec3 pos = vec3( 0.,0.,-3.);\n\tvec3 dir = normalize( vec3( uv, 1. ) );\n\n\tvec3 ip;\n    float t = 0.0;\n    float density = 0.0;\n    vec3 march_color = BG_COLOR;\n    float rd = MARCH_DIST / float(MARCH_COUNT);\n    for(int i = 0; i < MARCH_COUNT; i++)\n    {\n        ip = pos + dir * t;\n        float d = get_density_at_pos(ip);\n\n        density += d;\n        vec3 c = get_scatter_color(ip);\n        march_color += density * c;\n        t += rd;\n    }\n    \n\n\t//4 : apply color to this fragment\n\tfragColor = vec4(march_color, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtdGRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 443, 464, 464, 503], [505, 505, 529, 529, 947], [949, 949, 970, 970, 1107], [1109, 1109, 1143, 1143, 1336], [1338, 1373, 1405, 1405, 1925], [1928, 1928, 1985, 2028, 2722]]}
