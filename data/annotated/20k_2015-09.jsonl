{"id": "4l2SRW", "name": "Radial dyadic series", "author": "lycium", "description": "Reverse engineered this Tumblr image: https://media.tumblr.com/58a5311456dd38e2ad15ef2b36b2bcd7/tumblr_n9hnl4sY8p1r2geqjo1_500.gif\n\nSorry it's so horrifically unoptimised (the Halton sequence eval).", "tags": ["radial", "symmetry"], "likes": 16, "viewed": 558, "published": "Public API", "date": "1441989062", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//const int num_samples = 2 * 3; // 6\nconst int num_samples = 2*2 * 3*3; // 36\n//const int num_samples = 2*2*2 * 3*3*3; // 8*27 = 160+56 = 216\n\n\nfloat FoldedRadicalInverse(int n, int base)\n{\n\tfloat inv_base = 1.0 / float(base);\n\tfloat inv_base_i = inv_base;\n\tfloat val = 0.0;\n\tint offset = 0;\n\n\tfor (int i = 0; i < 8; ++i)\n\t{\n\t\tint div = (n + offset) / base;\n\t\tint digit = (n + offset) - div * base;\n\t\tval += float(digit) * inv_base_i;\n\t\tinv_base_i *= inv_base;\n\t\tn /= base;\n\t\toffset++;\n\t}\n\n\treturn val;\n}\n\n// simplified impl due to fabrice neyret <3\nfloat imageFunc(vec2 p, float t)\n{\n\tfloat pi = 3.141592653589793238,\n      offset = sin(t) * 4.,\n          r2 = dot(p, p) * 16.,\n\t    freq = exp2( 1. + floor(r2 * 10.)),\n           a = mod(atan(p.y, p.x) / pi * freq + offset, 2.);\n    \n\treturn (r2 < 1.) ? step(1., a) : 0.;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float pixel_r = 1.165;//002412;\n    const float pixel_norm = 1.0 / (3.1415926535897932384626433832795 * pixel_r * pixel_r);\n\tfloat s = 0.0;\n    float w_sum = 0.0;\n\tfor (int i = 0; i < num_samples; ++i)\n\t{\n        float time_aa = (float(i) + 0.5)/float(num_samples) * 0.03333 * 1.0;\n\n        float a = FoldedRadicalInverse(i, 2) * 6.283185307179586476925286766559;\n        float r = sqrt(FoldedRadicalInverse(i, 3)) * pixel_r;\n\t\tvec2 pixel_aa = vec2(cos(a), sin(a)) * r;\n        float pixel_w = max(0.0, pixel_r - r);\n\n\t\tvec2 uv = (fragCoord + pixel_aa - iResolution.xy * 0.5) / (iResolution.x * 1.0);\n\n\t\tfloat t = iTime + time_aa;\n\n\t\ts += imageFunc(uv, t) * pixel_w;\n        w_sum += pixel_w;\n\t}\n\ts *= (1.0 / w_sum); //pixel_norm;// / float(num_samples);\n\ts = pow(s, 1.0 / 2.2);\n\n\tfragColor = vec4(s, s, s, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2SRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 190, 190, 505], [507, 551, 585, 585, 826]], "test": "valid"}
{"id": "4l2Sz1", "name": "Sceneradio @ Wappuradio, live", "author": "Exca", "description": "Coding live for 2 hours @ wappuradio.fi radio broadcast.\nEdit: Live coding ended.", "tags": ["sceneradio"], "likes": 1, "viewed": 161, "published": "Public", "date": "1441691438", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Union\nfloat un(float d1, float d2)\n{\n \treturn min(d1, d2);   \n}\n\n//Subctract\nfloat sub(float d1, float d2)\n{\n    return max(-d1, d2);\n}\n\nfloat sphere(vec3 p, float r)\n{\n \treturn length(p)-r;   \n}\n\n//More shapes\nfloat box(vec3 p, vec3 c)\n{\n \treturn length(max(abs(p)-c, 0.));   \n}\n\n//Smoothing function by iq.\n//Great source for computer graphics: http://www.iquilezles.org/\nfloat smin(float a, float b, float k)\n{\n \tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0., 1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\nfloat repSphere(vec3 p, vec3 c, float r)\n{\n \tvec3 q = mod(p,c)-0.5*c;\n    return sphere(q, r);\n}\n\nfloat repBox(vec3 p, vec3 c, vec3 b)\n{\n \tvec3 q = mod(p,c)-0.5*c;\n    return box(q, b);\n}\n\n\n//Next up, move the camera by some random sine waves\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    uv.x*=aspect;\n    uv = uv*2.-1.;\n    \n    vec3 eye = vec3(sin(iTime*0.1)*30., sin(iTime*0.4)*20., 0.);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 right = vec3(1., 0., 0.);\n    vec3 forward = cross(right, up);\n    \n    float rx = iTime*0.1;\n    float ry = iTime*0.05;\n    float rz = iTime*0.2;\n    mat3 rotX = mat3(1., 0., 0.,\n                     0., cos(rx), -sin(rx),\n                     0., sin(rx), cos(rx));\n    mat3 rotY = mat3(cos(ry), 0., sin(ry),\n                     0., 1., 0.,\n                     -sin(ry), 0, cos(ry));\n    mat3 rotZ = mat3(cos(rz), -sin(rz), 0.,\n                     sin(rz), cos(rz), 0,\n                     0., 0., 1.);\n    \n    const int maxSteps = 60;\n    \n    vec3 ro = eye;\n    float focal = 2.;\n    vec3 rd = normalize(forward * focal + right*uv.x + up*uv.y);\n    rd = rotX * rd;\n    \n    float t = 0.;\n    vec3 color = vec3(0.);\n    float epsilon = 0.05;\n    float beat = mod( iTime*0.4, 1.6)*9.;\n    for(int i = 0; i < maxSteps; i++)\n    {\n     \tvec3 p = ro + t*rd;\n        float dSphere = repSphere(p-vec3(0.,.0,iTime), vec3(5., 5., 5.), 0.5);\n        float dSphere2 = repSphere(p-vec3(sin(iTime*0.2)*10.,0.,20.), vec3(5., 5., 5.), 0.5+beat);\n        \n        float dBox = repBox(p, vec3(7., 7, 5.), vec3(.5, .5, 0.1));\n        \n        dBox = un(dBox, dSphere);\n        //float minsum = smin(dSphere, dSphere2, 0.1);\n         \n        // this might be abit epileptic now ;)\n        if(t>.2) \n        {\n            if(dBox < epsilon)\n            {\n                //Coder colors ftw :) swapping to distance based gradient.\n                \n                //Let's make the colors be a distance based plasma instead of sine.\n/*                float r1 = sin(0.13*t*(iTime*.03));\n                float r2 = cos(0.15*t+iTime*.5);//*(p.y+p.y+iTime*.02));\n                float g1 = sin(0.11*t + iTime);//*(p.y+p.y+iTime*.03));\n                float g2 = cos(0.5*t);//*(p.x-iTime*.07));\n                \n                float b1 = sin(0.01/t+iTime);//*(p.y+p.y+iTime*.3));\n                float b2 = cos(0.05/t+iTime);//*(p.x-iTime*.7));\n                \n                float r = min(1., max(r1*r2,.0));\n                float g = min(1.,max(g1*g2, 0.));\n                float b = min(1.,max(b1*b2,0.));\n  */              \n            \t//color = vec3(r,g,b) + vec3(.3, .3, .3); \n                vec3 pal = palette((t+p.x)/20., vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30));\n                color = pal*0.2+ vec3(1.-t/50.);\n            }\n            if(dSphere < epsilon)\n            {\n                vec3 pal = 0.3* palette((t+p.x)/20., vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30));\n                color =pal* vec3(max(0.,1.- .5*sin(t*73.)));\n            }\n            if(dSphere2 <  epsilon)\n            {\n             //   color -= vec3(max(0.,1.-t/80.));   \n            }\n        }\n        float min = min(dSphere, dBox);//, dBox);\n        t+=min;\n    }\n    color = max(vec3(0., 0., 0.), color);\n    //Fog!\n    color +=palette(uv.y/1.+uv.x*.3, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30))*min(t,140.)/140.;\n    \n    color += beat <0.4 ? 0.2*beat : 0.;\n     \n\tfragColor =vec4( color,1.);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2Sz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 72, 72, 115], [117, 125, 155, 155, 182], [184, 196, 227, 227, 254], [256, 256, 287, 287, 314], [316, 330, 357, 357, 398], [400, 493, 532, 532, 614], [616, 616, 658, 658, 712], [714, 714, 752, 752, 803], [806, 859, 916, 916, 4228]], "test": "valid"}
{"id": "4l2Szm", "name": "Droplet", "author": "dr2", "description": "Probably liquid mercury (change viewpoint using the mouse).", "tags": ["raymarching", "reflection", "liquid"], "likes": 11, "viewed": 2621, "published": "Public API", "date": "1442523196", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Droplet\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat Length4 (vec2 p)\n{\n  p *= p;\n  p *= p;\n  return pow (p.x + p.y, 1. / 4.);\n}\n\nfloat Length6 (vec2 p)\n{\n  p *= p * p;\n  p *= p;\n  return pow (p.x + p.y, 1. / 6.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrTorus4Df (vec3 p, float ri, float rc)\n{\n  return Length4 (vec2 (length (p.xz) - rc, p.y)) - ri;\n}\n\nvec3 sunDir;\nfloat tCur;\nint idObj;\nconst float dstFar = 100.;\nconst int idRing = 1, idWat = 2;\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  if (rd.y > 0.) {\n    col = vec3 (0.1, 0.2, 0.4) + 0.2 * pow (1. - max (rd.y, 0.), 8.);\n    sd = max (dot (rd, sunDir), 0.);\n    ro.xz += 2. * tCur;\n    f = Fbm2 (0.1 * (rd.xz * (50. - ro.y) / rd.y + ro.xz));\n    col += 0.35 * pow (sd, 6.) + 0.65 * min (pow (sd, 256.), 0.3);\n    col = mix (col, vec3 (1.), clamp (0.8 * f * rd.y + 0.1, 0., 1.));\n  } else {\n    f = Fbm2 (0.4 * (ro.xz - ro.y * rd.xz / rd.y));\n    col = mix ((1. + min (f, 1.)) * vec3 (0.05, 0.1, 0.05),\n       vec3 (0.1, 0.15, 0.25), pow (1. + rd.y, 5.));\n  }\n  return col;\n}\n\nfloat StoneRingDf (vec3 p, float r, float w, float n)\n{\n  return Length6 (vec2 (length (p.xz) - r, p.y)) -\n     w * (0.2 * pow (abs (sin (atan (p.x, p.z) * n)), 0.25) + 0.8);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, db, r, s, t;\n  bool up;\n  dMin = dstFar;\n  t = mod (tCur, 10.);\n  r = abs (sin (2. * pi * 0.1 * t));\n  q = p;\n  up = (t < 5.);\n  q.y -= up ? 2.5 : 0.55;\n  d = PrTorus4Df (q, 1., r);\n  q.y -= up ? -0.5 : 0.5;\n  d = max (PrCylDf (q.xzy, r, 0.5), - d);\n  if (up) d = max (d, q.y);\n  q.y -= up ? -0.75 : 0.2;\n  s = length (q.xz);\n  q.y -= 0.02 * cos (15. * s - 7. * tCur) * clamp (1. - s / 2.5, 0., 1.) *\n     clamp (s, 0., 1.);\n  db = PrCylDf (q.xzy, 2.5, 0.25);\n  d = up ? min (db, d) : max (db, - d);\n  if (d < dMin) { dMin = d;  idObj = idWat; }\n  q = p;\n  s = 1. - sqrt (max (1. - r * r, 0.));\n  q.y -= 1.2 + (up ? s : - s);\n  d = PrSphDf (q, 0.3);\n  d = max (d, 1. - p.y);\n  if (d < dMin) { dMin = d;  idObj = idWat; }\n  q = p;\n  q.y -= 1.3;\n  d = StoneRingDf (q, 2.8, 0.3, 16.);\n  if (d < dMin) { dMin = d;  idObj = idRing; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 objCol, col, vn;\n  float dstHit, dif, bk;\n  int idObjT;\n  const int nRefl = 3;\n  for (int k = 0; k < nRefl; k ++) {\n    idObj = -1;\n    dstHit = ObjRay (ro, rd);\n    if (dstHit < dstFar && idObj == idWat) {\n      ro += rd * dstHit;\n      rd = reflect (rd, VaryNf (ro, ObjNf (ro), 0.1));\n      ro += 0.02 * rd;\n    } else break;\n  }\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj == idRing) {\n      objCol = vec3 (0.8, 0.6, 0.2);\n      vn = VaryNf (40. * ro, vn, 2.);\n    }\n    bk = max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.);\n    dif = max (dot (vn, sunDir), 0.);\n    col = objCol * (0.1 + 0.1 * bk + 0.8 * dif +\n       0.3 * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.));\n  } else col = BgCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 canvas = iResolution.xy;\n  vec2 uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  sunDir = normalize (vec3 (1., 1., 1.));\n  float el = 0.6;\n  if (mPtr.z > 0.) el = clamp (el - mPtr.y, 0.25, 0.8);\n  float cEl = cos (el);\n  float sEl = sin (el);\n  mat3 vuMat = mat3 (1., 0., 0., 0., cEl, - sEl, 0., sEl, cEl);\n  vec3 rd = normalize (vec3 (uv, 4.)) * vuMat;\n  vec3 ro = vec3 (0., 0.7, -10.) * vuMat;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2Szm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[262, 262, 286, 286, 333], [335, 335, 360, 360, 539], [541, 541, 562, 562, 701], [703, 703, 732, 732, 944], [946, 946, 985, 985, 1202], [1204, 1204, 1228, 1228, 1285], [1287, 1287, 1311, 1311, 1372], [1374, 1374, 1407, 1407, 1434], [1436, 1436, 1478, 1478, 1529], [1531, 1531, 1578, 1578, 1636], [1735, 1735, 1766, 1766, 2336], [2338, 2338, 2393, 2393, 2514], [2516, 2516, 2538, 2538, 3411], [3413, 3413, 3446, 3446, 3622], [3624, 3624, 3645, 3645, 3858], [3860, 3860, 3895, 3895, 4727], [4729, 4729, 4785, 4785, 5331]], "test": "valid"}
{"id": "4l2XD1", "name": "Flashing Lights", "author": "sciencesnerd", "description": "Playing around and keeping it simple.", "tags": ["colors"], "likes": 4, "viewed": 869, "published": "Public", "date": "1443378426", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float speed=5.;\n\nfloat blob(float x,float y,float fx,float fy){\n   float xx = x+sin(iTime*fx/speed)*.9;\n   float yy = y+cos(iTime*fy/speed)*99.9;\n\n   return 25.0/sqrt(xx*xx+yy*yy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   vec2 position = ( fragCoord.xy / iResolution.xy )-0.5;\n\n   float x = position.x*2.0;\n   float y = position.y*2.0;\n\n   float a = blob(x,y,3.3,3.2) + blob(x,y,3.9,3.0);\n   float b = blob(x,y,3.2,2.9) + blob(x,y,2.7,2.7);\n   float c = blob(x,y,2.4,3.3) + blob(x,y,2.8,2.3);\n   \n   vec3 d = vec3(a,b,c)/50.0;\n   \n   fragColor = vec4(d.x,d.y,d.z,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2XD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 63, 63, 182], [184, 184, 241, 241, 593]], "test": "valid"}
{"id": "4l2XzW", "name": "TheThirdLaw", "author": "dila", "description": "Rotozoom of some type. Probably way too much code for what you get.", "tags": ["rotozoom"], "likes": 12, "viewed": 221, "published": "Public", "date": "1442073231", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.14159;\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat box(vec3 p, vec3 s)\n{\n    vec3 q = clamp(p, -s, s);\n    return length(p - q);\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n}\n\nvec2 map(vec3 p)\n{\n    vec3 q = p;\n    \n    float sc = 1.0;\n    \n    q = (fract(q * sc) * 2.0 - 1.0) * sc;\n    \n    vec3 spc = fract(p + 0.5) * 2.0 - 1.0;\n    \n    float md = 1000.0;\n    float it = 0.0;\n    \n    const int iters = 5;\n    \n    for (int i = 0; i < iters; ++i) {\n        \n        float n = float(i) / float(iters-1);\n        \n        vec3 s = sign(q);\n        \n        vec3 w = normalize(q);\n        \n        float sm = abs(p.x) + abs(p.y) + abs(p.z) * 1.0;\n        \n        float mx = mix(1.0, 2.1, 0.5+0.5*sin(sm+iTime));\n        \n        q = mix(q, s*w*w, mx);\n        \n        float d = box(q, w*w*yrot(n*pi*2.0));\n        \n        float r = mix(1.0, 1.8, 0.5+0.5*sin(p.z*n+iTime));\n        \n        float sp = length(spc.xy) - r;\n        \n        d = max(d, -sp);\n        \n        if (d < md) {\n        \tmd = d;\n            it = n;\n        }\n        \n        md = min(md, d);\n    }\n    \n    return vec2(md, it);\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n \tfloat t = 0.0;\n    for (int i = 0; i < 16; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p).x;\n        t += d * 0.3;\n    }\n    return t;\n}\n\nvec3 pal(float idx)\n{\n    vec3 gt = vec3(1.2,0.5,0.8) * iTime;\n    mat3 c = xrot(gt.x) * yrot(gt.y) * zrot(gt.z);\n    vec3 p = mix(c[0], c[1], idx);\n    vec3 q = mix(c[1], c[2], idx);\n    vec3 m = abs(mix(p, q, idx));\n    return 0.5 + m * 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    vec2 uvo = uv;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 o = vec3(0.0, 0.0, 0.0);\n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv,uv)));\n    \n    float rt = floor(iTime) + smoothstep(0.0, 1.0, fract(iTime));\n    \n    r *= zrot(rt);\n    o.z += iTime * 4.0;\n    \n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec2 fd = map(w);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.1 + fd.x * 100.0);\n\n    vec3 fc = pal(fd.y) * fog;\n    \n    fc = 1.0 - sqrt(fc);\n    \n    float edge = max(abs(uvo.x), abs(uvo.y));\n    \n    fc *= 1.0 - pow(edge,8.0);\n\n\tfragColor = vec4(fc, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2XzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 47, 47, 156], [158, 158, 178, 178, 287], [289, 289, 309, 309, 418], [420, 420, 447, 447, 505], [507, 507, 543, 543, 614], [616, 616, 634, 634, 1547], [1549, 1549, 1578, 1578, 1730], [1732, 1732, 1753, 1753, 1977], [1979, 1979, 2036, 2036, 2696]], "test": "valid"}
{"id": "4lBSDD", "name": "FireFlicker", "author": "jherico", "description": "testing a flickering light algorithm. ", "tags": ["2d"], "likes": 4, "viewed": 1276, "published": "Public API", "date": "1443569051", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float UPDATE_INTERVAL = 1.0 / 30.0; // 30fps\nconst float MINIMUM_LIGHT_INTENSITY = 0.75;\nconst float MAXIMUM_LIGHT_INTENSITY = 2.75;\nconst float LIGHT_INTENSITY_RANDOMNESS = 0.3;\nconst float MAXIMUM_LIGHT = MINIMUM_LIGHT_INTENSITY + 2.0 * MAXIMUM_LIGHT_INTENSITY + LIGHT_INTENSITY_RANDOMNESS;\nconst vec3 color = vec3(255, 100, 28) / 255.0;\nconst float UPDATE_RATE = 30.0;\n\n// *** Use these for integer ranges, ie Value-Noise/Perlin functions.\n//#define MOD3 vec3(.0631,.07369,.08787)\n//#define MOD4 vec4(.0631,.07369,.08787, .09987)\n\n// This set suits the coords of of 0-1.0 ranges..\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\n#define MOD4 vec4(443.8975,397.2973, 491.1871, 470.7827)\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(p3.x * p3.y * p3.z);\n}\n\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    t *= UPDATE_RATE;\n    t -= fract(t);\n    t /= UPDATE_RATE;\n    float intensity = (MINIMUM_LIGHT_INTENSITY + (MAXIMUM_LIGHT_INTENSITY + (sin(t) * MAXIMUM_LIGHT_INTENSITY)));\n    intensity += LIGHT_INTENSITY_RANDOMNESS + (hash11(t) * 2.0) - 1.0;\n    intensity /= MAXIMUM_LIGHT;\n\tfragColor = vec4( color* intensity,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBSDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[696, 806, 829, 829, 939], [947, 947, 1004, 1004, 1349]], "test": "valid"}
{"id": "4lBSDR", "name": "Kissing-schottky Limit set", "author": "soma_arc", "description": "We use a new distance estimation(DE) to render the limit set of kissing-Schottky groups.\nThis &quot;kissing-Schottky DE&quot; algorithm is devised by Kazushi Ahara, Meiji university.", "tags": ["fractal", "kleiniangroups"], "likes": 3, "viewed": 446, "published": "Public", "date": "1442638944", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nCreated by soma_arc, Kazushi Ahara - 2015\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nfloat LINE_THRESHOLD = 0.0001;\nvec3 getLine(vec2 p1, vec2 p2){\n  float xDiff = p2.x - p1.x;\n  float yDiff = p2.y - p1.y;\n  if(abs(xDiff) < LINE_THRESHOLD){\n    //x = c\n    return vec3(1, 0, p1.x);\n  }else if(abs(yDiff) < LINE_THRESHOLD){\n    //y = c\n    return vec3(0, 1, p1.y);\n  }else{\n    //y = ax + b\n    return vec3(yDiff / xDiff, p1.y - p1.x * (yDiff / xDiff), 0);\n  }\n}\n\nfloat calcX(vec3 line, float y){\n  if(line.z == 0.){\n    return (y - line.y) / line.x;\n  }else{\n    return line.z;\n  }\n}\n\nfloat calcY(vec3 line, float x){\n  if(line.z == 0.){\n    return line.x * x + line.y;\n  }else{\n    return line.z;\n  }\n}\n\nvec2 calcIntersection(vec3 line1, vec3 line2){\n  if(line1.z == 0. && line2.z == 0.){\n    float x1 = 1.;\n    float x2 = 5.;\n    float y1 = calcY(line1, x1);\n    float y2 = calcY(line1, x2);\n\n    float x3 = 4.;\n    float x4 = 8.;\n    float y3 = calcY(line2, x3);\n    float y4 = calcY(line2, x4);\n\n    float ksi   = ( y4-y3 )*( x4-x1 ) - ( x4-x3 )*( y4-y1 );\n    float eta   = ( x2-x1 )*( y4-y1 ) - ( y2-y1 )*( x4-x1 );\n    float delta = ( x2-x1 )*( y4-y3 ) - ( y2-y1 )*( x4-x3 );\n\n    float lambda = ksi / delta;\n    float mu    = eta / delta;\n    return vec2(x1 + lambda*( x2-x1 ), y1 + lambda*( y2-y1 ));\n  }else{\n    if(line1.x == 1.){\n      return vec2(line1.z, calcY(line2, line1.z));\n    }else if(line1.y == 1.){\n      return vec2(calcX(line2, line1.z), line1.z);\n    }else if(line2.x == 1.){\n      return vec2(line2.z, calcY(line1, line2.z));\n    }\n    return vec2(calcX(line1, line2.z), line2.z);\n  }\n}\n\nconst vec2 commonCirclePos = vec2(0, 0);\nconst float commonCircleR = 100.;\nconst vec2 p = commonCirclePos + vec2(0, commonCircleR);\nconst vec2 q = commonCirclePos + vec2(-commonCircleR, 0);\nconst vec2 r = commonCirclePos + vec2(0, -commonCircleR);\nconst vec2 s = commonCirclePos + vec2(commonCircleR, 0);\n\nvec2 c1Pos, c2Pos, c3Pos, c4Pos;\nfloat c1R, c2R, c3R, c4R;\n\nvoid calcContactCircles(vec2 commonCirclePos, float commonCircleR){\n  vec2 pqMid = (p + q)/2.;\n  vec2 u = (pqMid - commonCirclePos)/distance(commonCirclePos, pqMid);\n  vec2 a = u * commonCircleR * (sin(iTime) * 6. + 6.72) + commonCirclePos;\n  c1Pos = a;\n  c1R = distance(a, p);\n\n  vec3 aq = getLine(a, q);\n  vec3 qrMidPer = getLine(commonCirclePos, (q + r) / 2.);\n  vec2 b = calcIntersection(aq, qrMidPer);\n  c2Pos = b;\n  c2R = distance(b, q);\n\n  vec3 br = getLine(b, r);\n  vec3 rsMidPer = getLine(commonCirclePos, (r + s) / 2.);\n  vec2 c = calcIntersection(br, rsMidPer);\n  c3Pos = c;\n  c3R = distance(c, r);\n\n  vec3 cs = getLine(c, s);\n  vec3 spMidPer = getLine(commonCirclePos, (s + p) / 2.);\n  vec2 d = calcIntersection(cs, spMidPer);\n  c4Pos = d;\n  c4R = distance(d, s);\n}\n\nvec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){\n\treturn ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;\n}\n\nconst int ITERATIONS = 30;\nfloat loopNum = 0.;\nfloat DE(vec2 pos){\n    loopNum = 0.;\n\tbool cont = false;\n\tfor(int i = 0 ; i < ITERATIONS ; i++){\n\t\tcont = false;\n\t\tif(length(pos - c1Pos) < c1R){\n\t\t\tpos = circleInverse(pos, c1Pos, c1R);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(length(pos - c2Pos) < c2R){\n\t\t\tpos = circleInverse(pos, c2Pos, c2R);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(length(pos - c3Pos) < c3R){\n\t\t\tpos = circleInverse(pos, c3Pos, c3R);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(length(pos - c4Pos) < c4R){\n\t\t\tpos = circleInverse(pos, c4Pos, c4R);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}\n\t\tif(cont == false) break;\n\t}\n\n\treturn length(pos) - commonCircleR;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float SAMPLE_NUM = 20.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 sum = vec3(0);\n\tfloat ratio = iResolution.x / iResolution.y / 2.0;\n    calcContactCircles(commonCirclePos, commonCircleR);\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 position = ( (fragCoord.xy + rand2n(fragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);\n\t\tposition = position * 600.;\n\n        float d = DE(position);\n\n        if(d < 0.){\n            sum += hsv2rgb(vec3(0.04 * loopNum,1.0,1.0));\n        }else{\n            sum += vec3(0.,0.,0.);\n        }\n    }\n    fragColor = vec4(sum/SAMPLE_NUM, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBSDR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[146, 235, 276, 276, 565], [598, 598, 629, 629, 943], [945, 945, 977, 977, 1065], [1067, 1067, 1099, 1099, 1185], [1187, 1187, 1233, 1233, 2095], [2463, 2463, 2530, 2530, 3240], [3242, 3242, 3302, 3302, 3418], [3467, 3467, 3486, 3486, 4124], [4126, 4126, 4148, 4148, 4317], [4349, 4349, 4405, 4405, 4941]], "test": "valid"}
{"id": "4lBSzR", "name": "Realistic Sky", "author": "jackdavenport", "description": "A shader which emulates the transitions between day and night. Change the length of each day by changing line 2.", "tags": ["sky", "night", "blend", "day", "realistic"], "likes": 4, "viewed": 494, "published": "Public", "date": "1441167220", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The length of a day, in seconds\n#define dayLength 12.\n\n// START NOISE\n// SOURCE: http://pixelshaders.com/examples/noise.html\nfloat random(float p) {\n  return fract(sin(p)*10000.);\n}\n\nfloat noise(vec2 p) {\n  return random(p.x + p.y*10000.);\n}\n// END NOISE\n\nvec3 rgb(float r, float g, float b) {\n \n    return vec3(r / 255., g / 255., b / 255.);\n    \n}\n\nfloat sqr(float x) {\n \n    return x * x;\n    \n}\n\nfloat dist(vec2 a, vec2 b) {\n \n    float x = sqr(a.x - b.x);\n    float y = sqr(a.y - b.y);\n    return sqrt(x + y);\n    \n}\n\nvec3 duskColor(vec2 uv, float y) {\n \n\tvec3 skyBase = rgb(255., 153., 51.);\n    vec3 skyTop = rgb(153., 204., 255.);\n    \n    return mix(skyBase, skyTop, pow(y, .5));\n    \n}\n\nvec3 dawnColor(vec2 uv, float y) {\n \n    vec3 skyBase = rgb(255., 102., 0.);\n    vec3 skyTop = rgb(255., 204., 153.);\n    \n    return mix(skyBase, skyTop, pow(y, .5));\n    \n}\n\nvec3 dayColor(vec2 uv, float y) {\n \n    vec3 skyBase = rgb(153., 204., 255.);\n    vec3 skyTop = rgb(0., 102., 255.);\n    \n    return mix(skyBase, skyTop, pow(y, .5));\n    \n}\n\nvec3 nightColor(vec2 uv, float y) {\n \n    float offset = iTime / 100000.;\n    float n = noise(uv - vec2(0.,offset));\n    \n    return n > .999 ? vec3(random(n)) : vec3(0.);\n    \n}\n\nvec3 sun(vec2 uv, float time) {\n    \n    float y = uv.y;\n    float sunY = 2.;\n    sunY -= 5. * (time / 4.);\n    \n    vec2 sunPos = vec2(.2, sunY);\n    float flareSize = .2;\n    float sunFlare = max(1. - (length(sunPos - uv) / flareSize), 0.);\n    \n    float distToSun = dist(sunPos, uv);\n    float anaSize = uv.x > .3 || uv.x < .3 ? 3. : 3. * (1. - distToSun * 4.);\n    float anaFlare = distToSun > .2 ? 1. - (distToSun + .15) : 1.;\n    float anaLens = sunY > y - (flareSize / anaSize) && sunY < y + (flareSize / anaSize) ? anaFlare : 0.;\n    \n    vec3 s = vec3(1., .7, 0.) * sunFlare;\n    s += vec3(.0, .0, .4) * anaLens;\n    \n    return s;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float y = uv.y;\n    \n    float time = 4. * mod(iTime, dayLength) / dayLength;\n    float det = fract(time);\n    \n    vec3 dusk = duskColor(uv, y);\n    vec3 dawn = dawnColor(uv, y);\n    vec3 day = dayColor(uv, y);\n    vec3 night = nightColor(uv, y);\n    \n    if(iMouse.z > 0.) {\n        \n        time = 4. * iMouse.x / iResolution.x;\n        \n    }\n    \n    vec3 final = time < 1. ? mix(day, dusk, det)\n        \t   : time < 2. ? mix(dusk, night, det)\n               : time < 3. ? mix(night, dawn, det)\n               : \t\t\t mix(dawn, day, det);\n   \n   \tfinal += sun(uv, time); \n    fragColor = vec4(final, 1.);\n    \n}", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBSzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 128, 151, 151, 184], [186, 186, 207, 207, 244], [259, 259, 296, 296, 352], [354, 354, 374, 374, 401], [403, 403, 431, 431, 524], [526, 526, 560, 560, 698], [700, 700, 734, 734, 874], [876, 876, 909, 909, 1049], [1051, 1051, 1086, 1086, 1229], [1231, 1231, 1262, 1262, 1879], [1881, 1881, 1938, 1938, 2602]], "test": "valid"}
{"id": "4lBSzW", "name": "3-Tap 2D Voronoi", "author": "Shane", "description": "3-tap 2D Voronoi with cheap highlights.", "tags": ["voronoi", "triangle", "simplex", "bump", "3tap"], "likes": 44, "viewed": 4122, "published": "Public API", "date": "1441889734", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t3-Tap 2D Voronoi\n\t----------------\n\n\tI saw member BH's hexagonal Voronoi example, which reminded me that I had a 3-tap simplex\n\tversion gathering pixel dust on my harddrive, so here it is.\n\n\tI hastily added some coloring and very cheap highlights, just to break the visual monotony, \n\tbut you can safely ignore most of the code and head straight to the \"Voronoi3Tap\" function. \n\tThat's the main point. Like BH's example, this one is branchless. In fact, there's\n\tvirtually no code at all.\n\n\tAs mentioned below, 3-tap Voronoi is just a novelty, bordering on pointless, but I thought \n\tit might provide a basis for anyone wishing to build a 3D simplex version. I also have a \n\t4-tap Voronoi function that involves even less computation.\n\n\tBy the way, the pattern is supposed to be concave. The reason I mention that is, if I stare \n\tat a highlighted Voronoi pattern for too long, it sometimes looks inverted. Usually, I have \n\tto close my eyes and reopen them to reinvert it. I've often wondered whether that happens to \n\teveryone, or whether I'm just getting old. :)\n\n\t// Other Shadertoy examples:\n\n\t// Hexagonal Voronoi - By \"BH.\"\n    // By the way, his version has artifacts, but Dr2 and myself have some hexagonal Voronoi \n    // examples on here that are more robust.\n\thttps://www.shadertoy.com/view/ltjXz1 - I'm looking forward to the finished version. :)\n\n\t// Voronoi fast, a 2x2 grid, 4tap version - By \"davidbargo\":\n\thttps://www.shadertoy.com/view/4tsXRH\n\n*/\n\n\n\n// Standard 2x2 hash algorithm.\nvec2 hash22(vec2 p) { \n\n    // Faster, but probably doesn't disperse things as nicely as other ways.\n    float n = sin(dot(p,vec2(1, 113))); \n    p = fract(vec2(8.*n, n)*262144.);\n    return sin(p*6.2831853 + iTime*2.);\n    \n/* \n\treturn fract(sin(p)*43758.5453)*2. - 1.;\n    \n    //p = fract(sin(p)*43758.5453);\n\t//p = sin(p*6.2831853 + iTime);\n    //return sign(p)*.25 + .75*p;\n    \n    //p = fract(sin(p)*43758.5453)*2. - 1.;\n    //return (sign(p)*.25 + p*.75);    \n */   \n    \n}\n\n// 3-tap Voronoi... kind of. I'm pretty sure I'm not the only one who's thought to try this.\n//\n// Due to the simplex grid setup, it's probably slightly more expensive than the 4-tap, square \n// grid version, but I believe the staggered cells make the patterns look a little nicer. I'd \n// imagine it's faster than the unrolled 9-tap version, but I couldn't say for sure. Anyway, \n// it's just a novelty, bordering on pointless, but I thought it might interest someone.\n\n// I'm not perfectly happy with the random offset figure of \".125\" or the normalization figure \n// of \".425.\" They might be right, but I'll determine those for sure later. They seem to work.\n//\n// Credits: Ken Perlin, Brian Sharpe, IQ, various Shadertoy people, etc.\n//\nfloat Voronoi3Tap(vec2 p){\n    \n\t// Simplex grid stuff.\n    //\n    vec2 s = floor(p + (p.x + p.y)*.3660254); // Skew the current point.\n    p -= s - (s.x + s.y)*.2113249; // Use it to attain the vector to the base vertice (from p).\n\n    // Determine which triangle we're in -- Much easier to visualize than the 3D version. :)\n    // The following is equivalent to \"float i = step(p.y, p.x),\" but slightly faster, I hear.\n    float i = p.x<p.y? 0. : 1.;\n    \n    \n    // Vectors to the other two triangle vertices.\n    vec2 p1 = p - vec2(i, 1. - i) + .2113249, p2 = p - .5773502; \n\n    // Add some random gradient offsets to the three vectors above.\n    p += hash22(s)*.125;\n    p1 += hash22(s +  vec2(i, 1. - i))*.125;\n    p2 += hash22(s + 1.)*.125;\n    \n    // Determine the minimum Euclidean distance. You could try other distance metrics, \n    // if you wanted.\n    float d = min(min(dot(p, p), dot(p1, p1)), dot(p2, p2))/.425;\n   \n    // That's all there is to it.\n    return sqrt(d); // Take the square root, if you want, but it's not mandatory.\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Prerotation to align the grid to the horizontal, but I'm leaving it on a\n    // slant for... stylistic purposes. :)\n    //const float a = 3.14159/12.;\n    //uv *= mat2(cos(a), sin(a), -sin(a), cos(a));\n    \n    // Take two 3-tap Voronoi samples near one another.\n    float c = Voronoi3Tap(uv*5.);\n    float c2 = Voronoi3Tap(uv*5. - 9./iResolution.y);\n    \n    // Coloring the cell.\n    //\n    // Use the Voronoi value, \"c,\" above to produce a couple of different colors.\n    // Mix those colors according to some kind of moving geometric patten.\n    // Setting \"pattern\" to zero or one displays just one of the colors.\n    float pattern = cos(uv.x*.75*3.14159 - .9)*cos(uv.y*1.5*3.14159 - .75)*.5 + .5;\n    \n    // Just to confuse things a little more, two different color schemes are faded in out.\n    //\n    // Color scheme one - Mixing a firey red with some bio green in a sinusoidal kind of pattern.\n    vec3 col = mix(vec3(c*1.3, c*c, pow(c, 10.)), vec3(c*c*.8, c, c*c*.35), pattern );\n    // Color scheme two - Farbrausch fr-025 neon, for that disco feel. :)\n    vec3 col2 = mix(vec3(c*1.2, pow(c, 8.), c*c), vec3(c*1.3, c*c, pow(c, 10.)), pattern );\n    // Alternating between the two color schemes.\n    col = mix(col, col2, smoothstep(.4, .6, sin(iTime*.25)*.5 + .5)); // \n\n    //col = mix(col.zxy, col, cos(uv.x*2.*3.14159)*cos(uv.y*5.*3.141595)*.25 + .75 );\n    \n    // Hilighting.\n    //\n    // Use a combination of the sample difference to add some really cheap, blueish highlighting.\n    // It's a directional-derviative based lighting trick. Interesting, but no substitute for point-lit\n    // bump mapping. Comment the following line out to see the regular, flat pattern.\n    col += vec3(.5, .8, 1)*(c2*c2*c2 - c*c*c)*5.;\n       \n    // Speckles.\n    //\n    // Adding subtle speckling to break things up and give it a less plastic feel.\n    col += (length(hash22(uv + iTime))*.06 - .03)*vec3(1, .5, 0);\n    \n\n    // Vignette.\n    //\n    uv = fragCoord/iResolution.xy;\n    //col *= (1.15 - dot(uv - .5, uv - .5)*.5); // *vec3(1, .97, .92); // Roundish.\n    // Rectangular.\n    col *= smoothstep(0., .5, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y), .25))*vec3(1.1, 1.07, 1.01);\n    \n    \n    // Even more color schemes.\n    //col = col.xzy; // col.yzx, col.zyx, etc.\n    \n    // Approximate gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBSzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1473, 1505, 1526, 1605, 1986], [2459, 2729, 2755, 2791, 3782], [3784, 3784, 3841, 3868, 6304]], "test": "valid"}
{"id": "4lBXDD", "name": "Polkadot flag", "author": "meshocky", "description": "Experiments with sin", "tags": ["flag", "polkadot"], "likes": 2, "viewed": 154, "published": "Public", "date": "1443580811", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 dots(vec2 coords) {\n\treturn abs(vec3(sin(coords.x) * cos(coords.y), cos(coords.x) * sin(coords.y), 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    float scale = 50.0;\n    float offset = -iMouse.x / (iResolution.x * 0.5) + iTime;\n    vec3 col = dots(uv * scale + (iTime + sin(offset + uv.x *  10.0))) * min(sin(offset + uv.x *  10.0) + 1.5, 1.0);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBXDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 112], [114, 114, 171, 171, 489]], "test": "valid"}
{"id": "4lBXRR", "name": "Moon Phases", "author": "clayjohn", "description": "Basic moon and stars learning about noise functions. Also moon phases for fun!", "tags": ["stars", "moon", "nightsky", "phases"], "likes": 17, "viewed": 2537, "published": "Public API", "date": "1441268481", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//inspiration and a few lines of code from IQ's Pirates https://www.shadertoy.com/view/ldXXDj\n\n\nfloat hash(vec2 p) {\n  return fract(sin(dot(p.xy, vec2(5.34, 7.13)))*5865.273458);   \n}\n\nvec2 hash2(vec2 p ) {\n   return fract(sin(vec2(dot(p, vec2(123.4, 748.6)), dot(p, vec2(547.3, 659.3))))*5232.85324);   \n}\n\nfloat noise(vec2 p) {\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    f = f * f * f * (3.0 - 2.0 * f);\n    vec2 add = vec2(1.0, 0.0);\n    float h = mix( mix(hash(n+add.yy), hash(n+add.xy), f.x), \n                   mix(hash(n+add.yx), hash(n+add.xx), f.x), f.y);\n        \n    return h;\n}\n\nfloat fbm(vec2 p) {\n  float h = 0.0;\n  float a = 0.5;\n    for (int i = 0;i<4;i++) {\n      //h+=noise(p)*a;\n        h+= texture(iChannel0, p).x*a; \n      p*=2.0;\n      a*=0.5;\n    }\n  return h;\n}\nvec3 project(vec2 p) {\n return vec3(p.x, p.y, sqrt(-(p.x*p.x+p.y*p.y-0.24)));   \n}\n\nfloat voronoi(vec2 p) {\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float md = 5.0;\n    vec2 m = vec2(0.0);\n    for (int i = -1;i<=1;i++) {\n        for (int j = -1;j<=1;j++) {\n            vec2 g = vec2(i, j);\n            vec2 o = hash2(n+g);\n            o = 0.5+0.5*sin(iTime+5.038*o);\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n            if (d<md) {\n              md = d;\n              m = n+g+o;\n            }\n        }\n    }\n    return 1.0-md;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set uv coordinates\n\tvec2 uv = (-iResolution.xy+2.0*fragCoord.xy) / iResolution.y;\n    //project regular coordinates onto curved surface\n    vec3 n = project(uv);\n    //compute shading for curved moon\n    vec3 sun = vec3(sin(iTime*0.5)*2.0, 0.0, cos(iTime*0.5)*2.0);\n    vec3 I = sun-n;\n    I = normalize(I);\n    float s = dot(n, I);\n    s = clamp(s*1.9, 0.0, 1.0);\n    //make stars\n    vec3 col = vec3(smoothstep(0.995, 1.0, hash(uv)));\n    //moon\n    float dist = length(uv);\n    vec3 moon = vec3(0.99, 0.99, 0.9);\n    moon = moon*(1.0-0.2*smoothstep(0.4, 0.44, dist));\n    float tex = fbm((uv+vec2(5.0))*0.03);\n    vec3 vtex = vec3(0.9+0.1*voronoi(uv*10.0));\n    //brightness lines\n    float sun_str = sqrt(1.0-0.25*length(vec3(0.0, 0.0, 2.0)-sun));\n    sun_str = clamp(sun_str, 0.01, 1.0);\n    col+= vec3(4.0*exp(-7.0*dist))*moon*sun_str;\n    col+= vec3(0.8*exp(-1.5*dist))*moon*sun_str;\n    col *= 1.2;\n    col = pow(col, vec3(1.0, 1.0, 1.1));\n   \n\tfragColor = vec4(mix(mix(moon*(0.6+0.4*tex), vtex, fbm(uv*0.02))*s, col, smoothstep(0.4, 0.44, dist)), 1.0);\n    \n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBXRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 116, 116, 183], [185, 185, 206, 206, 306], [308, 308, 329, 329, 597], [599, 599, 618, 618, 793], [794, 794, 816, 816, 876], [878, 878, 901, 901, 1356], [1358, 1358, 1415, 1440, 2490]], "test": "error"}
{"id": "4lBXWW", "name": "Procedural SkyBox", "author": "Passion", "description": "A procedurally generated skybox with a bumpy raymarched sphere.\nShaders used at top of code.", "tags": ["noise", "raymarch", "fbm"], "likes": 5, "viewed": 1424, "published": "Public", "date": "1443499119", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* ------- Shaders Used ---------\n\t\n\tfbm noise and hash functions\n\tfrom 'Apple' by iq\n\thttps://www.shadertoy.com/view/XdfGRn\n\n\tblending of the fbm and saturate function \n    from '2D Fast Clouds' by Sinuousity \n\thttps://www.shadertoy.com/view/XsjSRt\n\n   ------------------------------\n*/\n\n//2d Fast Clouds const\n//SETTINGS//\nconst float timeScale = 20.;\nconst float softness = 0.28;\nconst float brightness = 1.0;    \nconst float cover = 0.55;\n//SETTINGS//\n\nconst float eps = 0.001;\n#define time iTime\n\nmat2 rot(float deg){    \n    return mat2(cos(deg),-sin(deg),\n                sin(deg), cos(deg));\n        \n}\n\nfloat distanceFunction(vec3 pos){\n    \n    float disp = sin(pos.x*9.)*sin(pos.y*9.)*sin(pos.z*9.);\n    disp*=.05;\n    \n    //pos.y+=sin(time);\n    float sph = (length(pos) - 2.2);\n   \n    return sph+disp;\n}\n \nvec3 getNormal(vec3 p){\n    const float d = eps;\n    return normalize(vec3(distanceFunction(p+vec3(d,0.0,0.0))-distanceFunction(p+vec3(-d,0.0,0.0)),\n                          distanceFunction(p+vec3(0.0,d,0.0))-distanceFunction(p+vec3(0.0,-d,0.0)),\n                          distanceFunction(p+vec3(0.0,0.0,d))-distanceFunction(p+vec3(0.0,0.0,-d))));\n}\n\nfloat saturate(float num)\n{\n    return clamp(num,0.0,1.0);\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 pos = (fragCoord.xy*2.0 -iResolution.xy) / iResolution.y;\n    vec3 camPos = vec3(0.0, 0.0, -4.8);\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\t//float time = iTime;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    //Fisheye lens effect from 'Cypher'\n\t//https://www.shadertoy.com/view/MlsGRS - dila\n    vec3 rayDir = normalize(vec3(uv, 1.0 - dot(uv,uv) * 0.3)); \n    \n    camPos.xz*=rot(time*.6); \n    camPos.zy*=rot(time*.4);\n    rayDir.xz*=rot(time*.6); \n    rayDir.zy*=rot(time*.4);\n    \n    float t = 0.0, d;\n    vec3 posOnRay = camPos;\n    float dense = 16.0;\n    //light*=ry*rx;\n    //sun-sunIntensity from 'Kepler 256o'\n    //https://www.shadertoy.com/view/XsjGRd - otaviogood\n    vec3 localRay = normalize(rayDir);\n    vec3 light = normalize(vec3(1.2,.8,.1));\n    float sunIntensity = 1.0 - (dot(localRay, light) * 0.5 + 0.5);\n    sunIntensity = 0.2 / sunIntensity;\n    sunIntensity = min(sunIntensity, 40000.0);\n    sunIntensity = max(0.0, sunIntensity - 3.0);\n    //////////////////////////////////////////////////\n    \n    for(int i=0; i<32; ++i){\n        d = distanceFunction(posOnRay);\n        t += d;\n        posOnRay = camPos + t*rayDir;\n        //if(d < eps){ break; }\n    }\n    \n  \n    vec3 normal = getNormal(posOnRay);\n\t\n    float bright = brightness*(1.8-cover);\n    \n    //cloud coverage from '2d Fast Clouds' \n    //https://www.shadertoy.com/view/XsjSRt - Sinuousity\n    float color1 = fbm((rayDir*3.5)-0.5+iTime*0.02*timeScale);  //xz\n    float color2 = fbm((rayDir*7.2)-10.5+iTime*0.01*timeScale); //yz\n    \n    float clouds1 = smoothstep(1.0-cover,min((1.0-cover)+softness*2.0,1.0),color1);\n    float clouds2 = smoothstep(1.0-cover,min((1.0-cover)+softness,1.0),color2);\n    \n    float cloudsFormComb = saturate(clouds1+clouds2);\n    vec3 sunCol = vec3(258.0, 208.0, 100.0) / 15.0;\n\n    vec4 skyCol = vec4(0.6,0.8,1.0,1.0);\n    float cloudCol = saturate(saturate(1.0-pow(color1,1.0)*0.2)*bright);\n    vec4 clouds1Color = vec4(cloudCol,cloudCol,cloudCol,1.0);\n    vec4 clouds2Color = mix(clouds1Color,skyCol,0.25);\n    vec4 cloudColComb = mix(clouds1Color,clouds2Color,saturate(clouds2-clouds1));\n    vec4 clouds = vec4(0.0);\n\tclouds = mix(skyCol,cloudColComb,cloudsFormComb);\n    \n    fragColor=vec4(0.0);\n    \n    float c1 = fbm(posOnRay*1.5);\n    float c2 = fbm(posOnRay*2.0);\n    float c3 = fbm(posOnRay);\n    \n    vec3 noiseCol = sqrt((vec3(cos(c1*c1)/c1, cos(c2*c2)/c2,cos(c3*c3*c3)/c3))*.25);\n    \n    if(abs(d) < eps){\n        float diffuse = clamp( dot(normal, light), 0.15, 1.);\n        //Blinn-Phong half vector\n        vec3 h = normalize(-rayDir + light);\n        //Specular\n        float spe1 = pow(clamp(dot(h, normal), 0.0, 1.0), 33.0*4.);\n        vec3 brdf = 1.5*vec3(.10, .11, .11);\n        float fre = 0.1*pow(clamp(1. + dot(normal, rayDir), 0., 1.), 2.);\n        brdf += 1.30*diffuse*vec3(1., .9, .75);\n        vec3 spe = vec3(skyCol.rgb)*spe1;\n        fragColor = vec4(vec3(noiseCol)*diffuse+spe+brdf*fre, 1.0);  \n    } else {\n        fragColor = vec4(0.0);\n        fragColor.rgb+=clouds.rgb;           //; //.4\n        fragColor.rgb += sunCol*(sunIntensity*.00075);        \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBXWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[502, 502, 522, 522, 610], [612, 612, 645, 645, 818], [821, 821, 844, 844, 1173], [1175, 1175, 1202, 1202, 1235], [1237, 1237, 1260, 1260, 1299], [1408, 1408, 1434, 1434, 1839], [1841, 1841, 1862, 1862, 2060], [2063, 2063, 2120, 2120, 5283]], "test": "valid"}
{"id": "4ljSzD", "name": "Mandelbrot scratch", "author": "spluko", "description": "My first foray into fractals", "tags": ["fractal"], "likes": 1, "viewed": 250, "published": "Public", "date": "1442096501", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 multComplex(vec2 a, vec2 b) {\n    return mat2(a, vec2(-a.y, a.x)) * b;\n}\n\nvoid mainImage(out vec4 color, in vec2 p) {\n    const float pi = 3.1415926;\n    const float limit = 150.0;\n    const float threshold = 16.0;\n\n    float zoom = pow(1.5, iTime);\n    vec2 centre = vec2(-0.21501, 0.695 / zoom - 0.695);\n    float height = 2.5 / zoom;\n    \n    vec2 uv = (p.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec2 c = uv * height + centre;\n    \n    vec2 z = vec2(0.0);\n    float v = 1.0;\n    for(float i = 0.0; i < 1.0; i += 1.0 / limit) {\n        z = multComplex(z, z) + c;\n        if (dot(z, z) < threshold) v = i;\n    }\n    \n    //v = uv.y + 0.5;\n    color = vec4(sin(pi * v * vec3(-1.4, 1.7, 1.3) + vec3(-1.4, -1.2, 0.4)), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljSzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 77], [79, 79, 122, 122, 737]], "test": "valid"}
{"id": "4ljSzm", "name": "7 Sensatron Countdown Sequence", "author": "evilzug", "description": "a sequence that plays when sensatron is about to head out - colors change from blue, to red, to yellow, to green, to flashing green and white", "tags": ["sensatron", "sensatom", "countdown"], "likes": 0, "viewed": 104, "published": "Public", "date": "1442521877", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv2rgb_smooth( in vec3 c ) { vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 ); rgb = rgb*rgb*(3.0-2.0*rgb); return c.z * mix( vec3(1.0), rgb, c.y); }\nvec3 outputColor(float aFinalHue, float aFinalSaturation, float aFinalValue) { return hsv2rgb_smooth(vec3(aFinalHue, aFinalSaturation, aFinalValue)); }\nfloat rand(vec2 co) { return fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453); }\nfloat convertHue(float aHue) { return aHue/360.0; }\n\nconst float PURPLE = 304.0;\nconst float BLUE = 239.0;\nconst float CYAN = 183.0;\nconst float GREEN = 131.0;\nconst float YELLOW = 62.0;\nconst float ORANGE = 42.0;\nconst float RED = 0.0;\n\nfloat ROWS = 12.0;\n\nfloat evaluateColor(in vec2 fragCoord, in float aCycle, in float aCycleDelay) {\n//float evaluateColor(in float aRow, in vec2 fragCoord, in float aCycle) {\n    float tFinalHue = 0.0;\n    float iCurrentTime = iTime - aCycleDelay;\n    //float iCurrentTime = iTime - (aCycle * aRow);\n    float tPercentTimeUntilAllRed = iCurrentTime/aCycle;\n    if (tPercentTimeUntilAllRed > (fragCoord.x/iResolution.x)) {\n        tFinalHue = convertHue(RED);\n        if (tPercentTimeUntilAllRed > 1.0) {\n            float tPercentTimeUntilAllYellow = (iCurrentTime-aCycle*12.0)/aCycle;\n            if (tPercentTimeUntilAllYellow > (fragCoord.x/iResolution.x)) {\n                tFinalHue = convertHue(YELLOW);\n                float tPercentageTimeUntilAllGreen = (iCurrentTime-aCycle*2.0*12.0)/aCycle;\n                if (tPercentageTimeUntilAllGreen > (fragCoord.x/iResolution.x)) { \n                    tFinalHue = convertHue(GREEN);\n                }\n            }\n        }\n    } else {\n        tFinalHue = convertHue(BLUE);\n    }\n    return tFinalHue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float tCountdownTimeInMinutes = 10.0;\n    float tSecondsInAMinute = 60.0;\n    float tTotalTimeInSeconds = tCountdownTimeInMinutes * tSecondsInAMinute;\n    float tColors = 3.0;\n    float tCycle = (tTotalTimeInSeconds/tColors)/ROWS;\n    float tFinalHue = 0.0;\n    float tFinalSaturation = 1.0;\n    if (fragCoord.y > (iResolution.y * (11.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*0.0);\n    } else if (fragCoord.y > (iResolution.y * (10.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*1.0);\n    } else if (fragCoord.y > (iResolution.y * (9.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*2.0);\n    } else if (fragCoord.y > (iResolution.y * (8.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*3.0);\n    } else if (fragCoord.y > (iResolution.y * (7.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*4.0);\n    } else if (fragCoord.y > (iResolution.y * (6.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*5.0);\n    } else if (fragCoord.y > (iResolution.y * (5.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*6.0);\n    } else if (fragCoord.y > (iResolution.y * (4.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*7.0);\n    } else if (fragCoord.y > (iResolution.y * (3.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*8.0);\n    } else if (fragCoord.y > (iResolution.y * (2.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*9.0);\n    } else if (fragCoord.y > (iResolution.y * (1.0/ROWS))) {    \n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*10.0);\n    } else {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*11.0);\n    }\n    \n    float tPercentageTimeUntilDone = iTime/(tCycle*3.0*12.0);\n    if (tPercentageTimeUntilDone > 1.0 ) {\n        tFinalSaturation = abs(sin(iTime)) * .5;\n    }\n    \n\tfragColor = vec4(outputColor(tFinalHue, tFinalSaturation, 1.0), 1.0);\n}\n\n/*\nfor (float i = 0.0; i < 12.0; i++) {\n        if (fragCoord.y > (iResolution.y * (11.0/ROWS)) && \n            fragCoord.y < (iResolution.y * (12.0/ROWS))) { //trying to figure out how to mod with 'i'\n            tFinalHue = evaluateColor(i, fragCoord, tCycle); //???\n            break;\n        }\n    }\n*/\n\n/* previous non-for-looped code\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljSzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 184], [185, 185, 263, 263, 336], [337, 337, 358, 358, 428], [429, 429, 459, 459, 480], [687, 687, 766, 841, 1725], [1727, 1727, 1784, 1784, 3806]], "test": "valid"}
{"id": "4ljXRh", "name": "Sphere Tracing 102", "author": "fab", "description": "Example sphere tracer, from the following blog post: http://fabricecastel.github.io/blog/06-09-2015/main.html", "tags": ["example", "simple", "sphere", "tracer"], "likes": 9, "viewed": 2414, "published": "Public", "date": "1441570813", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// camera attributes\n// cameraDirection and cameraUp MUST be normalized\n// (ie. their length must be equal to 1)\nconst vec3 cameraPosition = vec3(0.0, 0.0, 10.0);\nconst vec3 cameraDirection = vec3(0.0, 0.0, -1.0);\nconst vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n\n// ray computation vars\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\n\n// epsilon-type values\nconst float S = 0.1;\nconst float EPSILON = 0.01;\n\n// const delta vectors for normal calculation\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\nfloat distanceToNearestSurface(vec3 p){\n    return length(p) - 1.0;\n}\n\n\n// better normal implementation with half the sample points\n// used in the blog post method\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n        distanceToNearestSurface(p+deltax)-d,\n        distanceToNearestSurface(p+deltay)-d,\n        distanceToNearestSurface(p+deltaz)-d\n    ));\n}\n\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l){\n    return vec3(dot(normalize(l-p), n));\n}\n\nvec3 intersectWithWorld(vec3 p, vec3 dir){\n    float dist = 0.0;\n    float nearest = 0.0;\n    vec3 result = vec3(0.0);\n    for(int i = 0; i < 20; i++){\n        nearest = distanceToNearestSurface(p + dir*dist);\n        if(nearest < EPSILON){\n            vec3 hit = p+dir*dist;\n            vec3 light = vec3(100.0*sin(iTime), 30.0*cos(iTime), 50.0*cos(iTime));\n            result = computeLambert(hit, computeSurfaceNormal(hit), light);\n            break;\n        }\n        dist += nearest;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n  \n    // generate the ray for this pixel\n    const float fovx = PI * fov / 360.0;\n    float fovy = fovx * iResolution.y/iResolution.x;\n    float ulen = tan(fovx);\n    float vlen = tan(fovy); \n   \n    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n    vec3 nright = normalize(cross(cameraUp, cameraDirection));\n    vec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n    vec3 rayDirection = normalize(pixel - cameraPosition);\n    \n    vec3 pixelColour = intersectWithWorld(cameraPosition, rayDirection);\n    fragColor = vec4(pixelColour, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljXRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[564, 564, 603, 603, 633], [636, 728, 762, 762, 979], [982, 982, 1026, 1026, 1069], [1071, 1071, 1113, 1113, 1586], [1588, 1588, 1645, 1645, 2263]], "test": "valid"}
{"id": "4ljXWh", "name": "Beneath the Sea", "author": "zel", "description": "Sprites float in their underwater home.", "tags": ["ray", "terrain", "rays", "water", "circle", "marching", "caustic", "god"], "likes": 111, "viewed": 8150, "published": "Public", "date": "1443295458", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// partially derived from the following\n// https://www.shadertoy.com/view/MlB3zh - terrain base\n// https://www.shadertoy.com/view/MdlXz8 - caustic tile\n\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\n\nfloat speck(vec2 pos, vec2 uv, float radius)\n{\n    pos.y += 0.05;\n    float color = distance(pos, uv);\n    vec3 tex = texture(iChannel0, sin(vec2(uv)*10.1)).xyz;\n    vec3 tex2 = texture(iChannel0, sin(vec2(pos)*10.1)).xyz;\n    color = clamp((1.0 - pow(color * (5.0 / radius), pow(radius,0.9))), 0.0, 1.0);\n    color *= clamp(mix(sin(tex.y)+0.1,cos(tex.x),0.5)*sin(tex2.x)+0.2,0.0,1.0);\n    return color;\n}\n\n\nvec3 caustic(vec2 uv)\n{\n    vec2 p = mod(uv*TAU, TAU)-250.0;\n    float time = iTime * .5+23.0;\n\n\tvec2 i = vec2(p);\n\tfloat c = 1.0;\n\tfloat inten = .005;\n\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n    \n\tc /= float(MAX_ITER);\n\tc = 1.17-pow(c, 1.4);\n\tvec3 color = vec3(pow(abs(c), 8.0));\n    color = clamp(color + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\n    color = mix(color, vec3(1.0,1.0,1.0),0.3);\n    \n    return color;\n}\n\n\n// perf increase for god ray, eliminates Y\nfloat causticX(float x, float power, float gtime)\n{\n    float p = mod(x*TAU, TAU)-250.0;\n    float time = gtime * .5+23.0;\n\n\tfloat i = p;;\n\tfloat c = 1.0;\n\tfloat inten = .005;\n\n\tfor (int n = 0; n < MAX_ITER/2; n++) \n\t{\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\n\t\ti = p + cos(t - i) + sin(t + i);\n\t\tc += 1.0/length(p / (sin(i+t)/inten));\n\t}\n\tc /= float(MAX_ITER);\n\tc = 1.17-pow(c, power);\n    \n    return c;\n}\n\n\nfloat GodRays(vec2 uv)\n{\n    float light = 0.0;\n\n    light += pow(causticX((uv.x+0.08*uv.y)/1.7+0.5, 1.8, iTime*0.65),10.0)*0.05;\n    light-=pow((1.0-uv.y)*0.3,2.0)*0.2;\n    light += pow(causticX(sin(uv.x), 0.3,iTime*0.7),9.0)*0.4; \n    light += pow(causticX(cos(uv.x*2.3), 0.3,iTime*1.3),4.0)*0.1;  \n        \n    light-=pow((1.0-uv.y)*0.3,3.0);\n    light=clamp(light,0.0,1.0);\n    \n    return light;\n}\n\n\nfloat noise(in vec2 p)\n{\n   \n    float height = mix(texture(iChannel0, p / 80.0, -100.0).x,1.0,0.85);\n    float height2 = mix(texture(iChannel1, p / 700.0, -200.0).x,0.0,-3.5);\n    \n    return height2-height-0.179;\n}\n\n\nfloat fBm(in vec2 p) \n{\n    float sum = 0.0;\n    float amp = 1.0;\n    \n    for(int i = 0; i < 4; i++)\n    {\n        sum += amp * noise(p);\n        amp *= 0.5;\n        p *= 2.5;\n    }\n    return sum * 0.5 + 0.15;\n}\n\n\nvec3 raymarchTerrain(in vec3 ro, in vec3 rd, in float tmin, in float tmax)\n{\n    float t = tmin;\n    vec3 res = vec3(-1.0);\n    \n    for (int i = 0; i < 110; i++) \n    {\n        vec3 p = ro + rd * t;\n        \n        res = vec3(vec2(0.0, p.y - fBm(p.xz)), t);\n        \n        float d = res.y;\n        \n        if (d < (0.001 * t) || t > tmax)\n        {\n            break;\n        }\n        \n        t += 0.5 * d;\n    }\n    \n    return res;\n}\n\n\nvec3 getTerrainNormal(in vec3 p) \n{\n    float eps = 0.025;\n    return normalize(vec3(fBm(vec2(p.x - eps, p.z)) - fBm(vec2(p.x + eps, p.z)),\n                          2.0 * eps,\n                          fBm(vec2(p.x, p.z - eps)) - fBm(vec2(p.x, p.z + eps))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 skyColor = vec3(0.3, 1.0, 1.0);\n\n    vec3 sunLightColor = vec3(1.7, 0.65, 0.65);\n    vec3 skyLightColor = vec3(0.8, 0.35, 0.15);\n    vec3 indLightColor = vec3(0.4, 0.3, 0.2);\n    vec3 horizonColor = vec3(0.0, 0.05, 0.2);\n    vec3 sunDirection = normalize(vec3(0.8, 0.8, 0.6));\n    \n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n\n    vec3 eye = vec3(0.0, 1.25, 1.5);\n    vec2 rot = 6.2831 * (vec2(-0.05 + iTime * 0.01, 0.0 - sin(iTime * 0.5) * 0.01) + vec2(1.0, 0.0) * (iMouse.xy - iResolution.xy * 0.25) / iResolution.x);\n    eye.yz = cos(rot.y) * eye.yz + sin(rot.y) * eye.zy * vec2(-1.0, 1.0);\n    eye.xz = cos(rot.x) * eye.xz + sin(rot.x) * eye.zx * vec2(1.0, -1.0);\n\n    vec3 ro = eye;\n    vec3 ta = vec3(0.5, 1.0, 0.0);\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(vec3(0.0, 1.0, 0.0), cw));\n    vec3 cv = normalize(cross(cw, cu));\n    mat3 cam = mat3(cu, cv, cw);\n\n    vec3 rd = cam * normalize(vec3(p.xy, 1.0));\n\n    // background\n    vec3 color = skyColor;\n    float sky = 0.0;\n\n    // terrain marching\n    float tmin = 0.1;\n    float tmax = 20.0;\n    vec3 res = raymarchTerrain(ro, rd, tmin, tmax);\n    \n    vec3 colorBubble = vec3(0.0);\n    float bubble = 0.0;\n    bubble +=  speck(vec2(sin(iTime*0.32),cos(iTime)*0.2+0.1),rd.xy,-0.08*rd.z);\n\tbubble +=  speck(vec2(sin(1.0-iTime*0.39)+0.5,cos(1.0-iTime*0.69)*0.2+0.15),rd.xy,0.07*rd.z);   \n\tbubble +=  speck(vec2(cos(1.0-iTime*0.5)-0.5,sin(1.0-iTime*0.36)*0.2+0.1),rd.xy,0.12*rd.z);   \n \tbubble +=  speck(vec2(sin(iTime*0.44)-1.0,cos(1.0-iTime*0.32)*0.2+0.15),rd.xy,-0.09*rd.z);   \n \tbubble +=  speck(vec2(1.0-sin(1.0-iTime*0.6)-1.3,sin(1.0-iTime*0.82)*0.2+0.1),rd.xy,0.15*rd.z);\n\n    colorBubble = bubble*vec3(0.2,0.7,1.0);\n    if(rd.z < 0.1)\n    {\n        float y = 0.00;\n        for(float x = 0.39; x < 6.28; x += 0.39)\n        {\n            vec3 height = texture(iChannel0, vec2(x)).xyz;\n            y+= 0.03*height.x;\n\t\t\tbubble = speck(vec2(sin(iTime+x)*0.5+0.2,cos(iTime*height.z*2.1+height.x*1.7)*0.2+0.2),\n            rd.xy,(cos(iTime+height.y*2.3+rd.z*-1.0)*-0.01+0.25));\n            colorBubble += bubble*vec3(-0.1*rd.z,-0.5*rd.z,1.0);\n        }\n    }    \n         \n    float t = res.z;\n    \n    if (t < tmax) \n    {\n        vec3 pos = ro + rd * t;\n        vec3 nor;\n        \n        // add bumps\n        nor = getTerrainNormal(pos);\n        nor = normalize(nor + 0.5 * getTerrainNormal(pos * 8.0));\n \n        float sun = clamp(dot(sunDirection, nor), 0.0, 1.0);\n        sky = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n        vec3 diffuse=mix(texture(iChannel2, vec2(pos.x*pow(pos.y,0.01),pos.z*pow(pos.y,0.01))).xyz,vec3(1.0,1.0,1.0),clamp(1.1-pos.y,0.0,1.0));\n\n        diffuse *= caustic(vec2(mix(pos.x,pos.y,0.2),mix(pos.z,pos.y,0.2))*1.1);\n        vec3 lightColor = 1.0 * sun * sunLightColor;\n\n        lightColor += 0.7 * sky * skyLightColor;\n\n        color *= 0.8 * diffuse*lightColor;\n\n        // fog\n        color = mix(color, horizonColor, 1.0 - exp(-0.3 *pow(t,1.0) ));\n    }\n    else \n    {\n        sky = clamp(0.8 * (1.0 - 0.8 * rd.y), 0.0, 1.0);\n        color = sky * skyColor;\n        color += ((0.3*caustic(vec2(p.x,p.y*1.0)))+(0.3*caustic(vec2(p.x,p.y*2.7))))*pow(p.y,4.0);\n\n        // horizon\n        color = mix(color, horizonColor, pow(1.0 - pow(rd.y,4.0), 20.0));       \n    }\n    \n    // special effects\n    color += colorBubble;\n    color += GodRays(p)*mix(float(skyColor),1.0,p.y*p.y)*vec3(0.7,1.0,1.0);\n    \n    // gamma correction\n    vec3 gamma = vec3(0.46);\n    fragColor = vec4(pow(color, gamma), 1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljXWh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[288, 288, 334, 334, 693], [696, 696, 719, 719, 1308], [1311, 1354, 1405, 1405, 1767], [1770, 1770, 1794, 1794, 2172], [2175, 2175, 2199, 2199, 2391], [2394, 2394, 2417, 2417, 2607], [2610, 2610, 2686, 2686, 3052], [3055, 3055, 3090, 3090, 3316], [3319, 3319, 3376, 3376, 6925]], "test": "error"}
{"id": "4ljXWR", "name": "Repeat by Cos and Sin", "author": "aiekick", "description": "A simple sphere with the shane func \"voronesque\" as displaced.\nThe sphere is repeated with some deformation due to the use of cos and sin instead of mod.\nclick on cell to see it fullscreen", "tags": ["3d", "raymarching", "sin", "cos", "mod", "repeat", "voronesque"], "likes": 53, "viewed": 2823, "published": "Public API", "date": "1442869135", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/*\nA simple sphere with the shane func \"voronesque\" as displaced.\nThe sphere is repeated with some deformation due to the use of cos and sin instead of mod.\nclick on cell to see it fullscreen\n*/\n\nconst vec2 gridSize = vec2(5.,4.);//grid size (columns, rows)\nconst vec3 lightDir = vec3(0.,1., 0.5);\nconst float mPi = 3.14159;\nconst float m2Pi = 6.28318;\n\nfloat cellID = 0.;//global var for pilot hex func\nfloat t = 0.;\n\nvec3 OrenNayarLightModel(vec3 rd, vec3 ld, vec3 n)\n{\n\tvec3 col = vec3(0.);\n\tfloat RDdotN = dot(-rd, n);\n\tfloat NdotLD = dot(n, ld);\n    float aRDN = acos(RDdotN);\n\tfloat aNLD = acos(NdotLD);\n\tfloat mu = .33;\n\tfloat A = 1.-.5*mu*mu/(mu*mu+0.57);\n    float B = .45*mu*mu/(mu*mu+0.09);\n\tfloat alpha = max(aRDN, aNLD);\n\tfloat beta = min(aRDN, aNLD);\n\tfloat albedo = 1.1;\n\tfloat e0 = 3.1;\n\tcol = vec3(albedo / mPi) * cos(aNLD) * (A + ( B * max(0.,cos(aRDN - aNLD)) * sin(alpha) * tan(beta)))*e0;\n\treturn col;\n}\n\n// from shane sahder : https://www.shadertoy.com/view/4lSXzh\nfloat Voronesque( in vec3 p )\n{\n    vec3 i  = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec3 rnd = vec3(7, 157, 113); \n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    d = fract(sin(d)*262144.)*v*2.; \n    v.x = max(d.x, d.y), v.y = max(d.z, d.w); \n    return max(v.x, v.y); \n}\n\nvec2 df(vec3 p)\n{\n\tvec2 res = vec2(1000.);\n\t\n\t// mat 1\n\tfloat plane = p.y + 1.;\n\tif (plane < res.x)\n\t\tres = vec2(plane, 1.);\n\t\t\n\t// mat 2\n\tvec3 q = p; // repeat by cos, sin instead of mod\n\tif (cellID == 0.) q = vec3(cos(p.x), p.y, p.z + sin(p.x));\n\tif (cellID == 1.) q = vec3(cos(p.x), p.y * 3., cos(p.z));\n\tif (cellID == 2.) q = vec3(cos(p.x - sin(p.y - t)), p.y, cos(p.z));\n\tif (cellID == 3.) q = vec3(cos(p.x + p.z), p.y, cos(p.z));\n\tif (cellID == 4.) q = vec3(cos(p.x + sin(p.z + t)), p.y * 3., cos(p.z));\n\tif (cellID == 5.) q = vec3(cos(p.x + sin(p.z + t)), p.y, cos(p.z * 3.));\n\tif (cellID == 6.) q = vec3(cos(p.x + sin(p.z)), p.y, cos(p.z) + sin(p.y + t));\n\tif (cellID == 7.) q = vec3(cos(p.x + cos(p.z)), p.y, cos(p.z) + sin(p.y + t));\n\tif (cellID == 8.) q = vec3(cos(p.x + cos(p.z)), p.y, cos(p.z + sin(p.x)) + sin(p.y + t));\n\tif (cellID == 9.) q = vec3(cos(p.x + sin(p.z)), p.y, cos(p.z + sin(p.z)));\n\tif (cellID == 10.) q = vec3(cos(p.x / 2. + sin(p.z)), p.y + cos(p.x) + sin(p.y), cos(p.z / 2. + sin(p.z / 2.)));\n\tif (cellID == 11.) q = vec3(cos(p.x / 2. + sin(p.z)), p.y + cos(p.x) + sin(p.y), cos(p.z / 2. + sin(p.z + p.x + t)));\n\tif (cellID == 12.) q = vec3(cos(p.x / 2. + sin(p.z + t)), p.y + cos(p.x) * sin(p.y + t), cos(p.z / 2. + sin(p.z / 2.)));\n\tif (cellID == 13.) q = vec3(cos(p.x), p.y + sin(p.x + t) + cos(p.z + t), cos(p.z));\n\tif (cellID == 14.) q = vec3(cos(p.x - t), p.y + cos(p.x), cos(p.z));\n\tif (cellID == 15.) q = vec3(cos(p.x - t), p.y + cos(p.x), cos(p.z + sin(p.z + t)));\n    if (cellID == 16.) q = vec3(cos(p.x), p.y, cos(log(abs(p.z))+t));\n    if (cellID == 17.) q = vec3(cos(p.x), p.y, cos(log2(abs(p.z))+t + sin(p.x)));\n  \tif (cellID == 18.) q = vec3(cos(log(abs(p.x))), p.y, cos(log2(abs(p.z))+t + sin(p.x)));\n   \tif (cellID == 19.) q = vec3(log(cos(abs(p.x))), p.y, log(cos(abs(p.z))));\n   \n\tfloat voro = Voronesque(q);\n\tfloat sphere = length(q) - 1. + voro * (sin(-t * .05)*1.2-.6);\n\tif (sphere < res.x)\n\t\tres = vec2(sphere, 2.);\n\t\n\treturn res;\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// from iq code\nvec3 lighting(vec3 col, vec3 p, vec3 n, vec3 rd, vec3 ref, float t)    \n{\n\tfloat occ = calcAO( p, n );\n\tfloat amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n\tfloat dif = clamp( dot( n, lightDir ), 0.0, 1.0 );\n\tfloat bac = clamp( dot( n, normalize(vec3(-lightDir.x,0.0,-lightDir.z))), 0.0, 1.0 )*clamp( 1.0-p.y,0.0,1.0);\n\tfloat dom = smoothstep( -0.1, 0.1, ref.y );\n\tfloat fre = pow( clamp(1.0+dot(n,rd),0.0,1.0), 2.0 );\n\tfloat spe = pow(clamp( dot( ref, lightDir ), 0.0, 1.0 ),16.0);\n        \n\tdif *= softshadow( p, lightDir, 0.02, 2.5 );\n\tdom *= softshadow( p, ref, 0.02, 2.5 );\n\n\tvec3 brdf = vec3(0.0);\n\tbrdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n\tbrdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n\tbrdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n\tbrdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n\tbrdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\tbrdf += 0.02;\n\tcol = col * brdf;\n\n\tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n\t\n\treturn col;\n}\n\n// encode id from coord // s:screenSize / h:pixelCoord / sz=gridSize\nfloat EncID(vec2 s, vec2 h, vec2 sz) \n{\n    float cx = floor(h.x/(s.x/sz.x));\n    float cy = floor(h.y/(s.y/sz.y));\n    return cy*sz.x+cx;\n}\n\n// return id / uv // s:screenSize / h:pixelCoord / sz=gridSize\nvec3 getcell(vec2 s, vec2 h, vec2 sz) \n{\n    float cx = floor(h.x/(s.x/sz.x));\n    float cy = floor(h.y/(s.y/sz.y));\n    \n    float id = cy*sz.x+cx;\n    \n    vec2 size = s/sz;\n    float ratio = size.x/size.y;\n    vec2 uv = (2.*(h)-size)/size.y - vec2(cx*ratio,cy)*2.;\n    uv*=1.5;\n    \n    return vec3(id, uv);\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\t\n\tvec2 si = iResolution.xy;\n\tvec2 mo = iMouse.xy;\n    \n\tvec2 uv = (2.*g-si)/min(si.x, si.y);\n\t\n\tvec3 cell = getcell(si,g,gridSize);\n    if(iMouse.z>0.) \n    {\n        cell.x = EncID(si,mo,gridSize);\n        cell.yz = uv;\n    }\n    \n\tt = iTime - 10.;\n    \n    cellID = cell.x; // global var : current cell used by mouse\n\t\n\tvec3 rayOrg = vec3(t,5,0);\n\tvec3 camUp = vec3(0,1,0);\n\tvec3 camOrg = rayOrg + vec3(1,-1,0); // translate the cam along the x axis\n\t\n\tfloat fov = .5;// fov seen in code from shane\n\tvec3 axisZ = normalize(camOrg - rayOrg);\n\tvec3 axisX = normalize(cross(camUp, axisZ));\n\tvec3 axisY = normalize(cross(axisZ, axisX));\n\tvec3 rayDir = normalize(axisZ + fov * cell.y * axisX + fov * cell.z * axisY);\n\t\n    float dMax = 20.;\n\tfloat sMin = 0.01;\n\t\n\tvec2 s = vec2(sMin);\n\tfloat d = 0.;\n    \n\tvec3 p = rayOrg + rayDir * d;\n\t\n\tfor (int i=0; i<150; i++)\n\t{\n\t\tif (abs(s.x)<d*d*1e-5 || d>dMax) break;\n\t\ts = df(p);\n\t\td += s.x * 0.2;\n\t\tp = rayOrg + rayDir * d;\t\n\t}\n\t\n\tif (d<dMax)\n\t{\n\t\tvec3 p = rayOrg + rayDir * d;\n\t\tvec3 n = nor(p, 0.001);\n\t\t\n\t\tif (s.y < 1.5) // mat 1 : plane\n\t\t{\n\t\t\t// \tiq primitive shader : https://www.shadertoy.com/view/Xds3zN\n\t\t\tfloat r = mod( floor(5.0*p.z) + floor(5.0*p.x), 2.0);\n            f.rgb = 0.4 + 0.1*r*vec3(1.0);\n\t\t}\t\n\t\telse if (s.y < 2.5) // mat 2 : sphere\n\t\t{\t\n\t\t\tf.rgb = OrenNayarLightModel(n, lightDir, vec3(.33));\t\t\t\n\t\t}\t\n\n\t\tf.rgb = lighting(f.rgb, p, n, rayDir, rayDir, d); // lighting    \n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljXWR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[557, 557, 609, 609, 1062], [1064, 1125, 1156, 1156, 1722], [1724, 1724, 1741, 1741, 3711], [3713, 3713, 3745, 3745, 3923], [3926, 3942, 4016, 4016, 4275], [4277, 4293, 4335, 4335, 4633], [4635, 4651, 4724, 4724, 5620], [5622, 5691, 5730, 5730, 5831], [5833, 5896, 5936, 5936, 6208], [6210, 6210, 6251, 6251, 7692]], "test": "valid"}
{"id": "4lsSDl", "name": "Duckling", "author": "jimmi", "description": "Just a duckling.", "tags": ["duck"], "likes": 14, "viewed": 211, "published": "Public", "date": "1442020404", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphere(vec3 p, float s)\n{\n    float k = length(p)-s;\n    return k < 0.0 ? 0.0 : k;\n}\n\nfloat duckBody(vec3 p) {\n    float k = 6.0;\n    float a = 0.;\n    \n    a += exp(-k * sphere(p + vec3(0.11, 0, 0.1), 0.06));\n    a += exp(-k * sphere(p + vec3(-0.11, 0, 0.1), 0.06));\n    a += exp(-k * sphere(p + vec3(0.2, 0, 0.3), 0.1));\n    a += exp(-k * sphere(p + vec3(-0.2, 0, 0.3), 0.1));\n    a += exp(-k * sphere(p + vec3(0.2, 0, 0.55), 0.07));\n    a += exp(-k * sphere(p + vec3(-0.2, 0, 0.55), 0.07));\n    a += exp(-k * sphere(p + vec3(-0.00, 0, 0.72), 0.1));\n    \n    a += exp(-k * sphere(p + vec3(0, -0.39, 0.8), 0.01));\n\n    a += exp(-k * sphere(p + vec3(0, -0.7, 0.1), 0.15));\n    a += exp(-k * sphere(p + vec3(0, -0.65, -0.05), 0.07));\n\n    return -log(a) / k;\n}\n\nfloat beak(vec3 p, float s)\n{\n    float k = max(length(p)-s, -(length(p+vec3(-0.15,-0.2,-0.1))-0.25));\n    k = max(k, -(length(p+vec3(0.12,-0.2,-0.1))-0.25));\n    return k < 0.0 ? 0.0 : k;\n}\n\nfloat duckBeak(vec3 p) {\n    float k = 12.0;\n    float a = 0.;\n    \n    a += exp(-k * beak(p + vec3(0, -0.55, -0.1), 0.15));\n\n    return -log(a) / k;\n}\n\nvec4 nearest(vec4 d1, vec4 d2)\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 rotate(vec3 p, float angle)\n{\n    float  c = cos(angle);\n    float  s = sin(angle);\n    return vec3(c*p.x-s*p.z, p.y, s*p.x+c*p.z);\n}\n\nvec4 map(vec3 pos)\n{\n    vec3 offset = vec3(0, 0.4, -0.3);\n    vec4 res = vec4(duckBody(pos-vec3(-0.0, 0.25, 0.0)+offset), vec3(1, 1, 0));\n    res = nearest(res, vec4(duckBeak(pos-vec3(-0.0, 0.25, 0.0)+offset), vec3(1, 0, 0)));\n    res = nearest(res, vec4(sphere(pos-vec3(0.09, 0.87, 0.14)+offset, 0.06), vec3(0.0, 0, 0.3)));\n    res = nearest(res, vec4(sphere(pos-vec3(-0.09, 0.87, 0.14)+offset, 0.06), vec3(0.0, 0, 0.3)));\n \n    return res;\n}\n\nvec4 castRay(in vec3 ro, in vec3 rd)\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n    float precis = 0.002;\n    float t = tmin;\n    vec3 color = vec3(1, 0, 1);\n    for(int i=0; i<50; i++)\n    {\n        vec4 res = map(ro+rd*t);\n        if(res.x<precis || t>tmax) break;\n        t += res.x;\n        color = res.yzw;\n    }\n\n    if(t>tmax) t=-1.0;\n    return vec4(t, color);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x);\n    return normalize(nor);\n}\n\nvec4 render(in vec3 ro, in vec3 rd, float angle)\n{ \n    vec4 res = castRay(ro,rd);\n\n    float t = res.x;\n    vec3 col = res.yzw;\n    if(t>-0.5)\n    {\n        // Light calculations by iq\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd, nor);\n        \n        vec3  lig = normalize(vec3(0.6*cos(angle), 0.3, -0.6*sin(angle)));\n        float amb = clamp(0.5+0.5*nor.y, 0.0, 1.0);\n        float dif = clamp(dot(nor, lig), 0.0, 1.0);\n        float bac = clamp(dot(nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0)*clamp(1.0-pos.y,0.0,1.0);\n        float dom = smoothstep(-0.1, 0.1, ref.y);\n        float fre = pow(clamp(1.0+dot(nor,rd),0.0,1.0), 2.0);\n        float spe = pow(clamp(dot(ref, lig), 0.0, 1.0),6.0);\n\n        vec3 brdf = vec3(0.0);\n        brdf += 0.50*dif*vec3(1.00,0.90,0.60);\n        brdf += 0.30*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.70*amb*vec3(0.50,0.70,1.00);\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00);\n        brdf += 0.02;\n        col = col*brdf;\n\n        return vec4(clamp(col, 0.0, 1.0), 1.0);\n    }\n   return vec4(0, 0, 0, 0);\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize(cross(cw,cp));\n    vec3 cv = normalize(cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\nvec4 mixc(vec4 c1, vec4 c2) {\n  float newa = mix(c2.a, c2.a, c1.a);\n  return vec4(mix(c1.rgb, c2.rgb, newa), 1.0-(1.0-c1.a)*(1.0-c2.a));\n}\n\nvec4 background(vec2 p, float time)\n{\n  float rat = 1.0 + 0.4 * sin(time*0.744);\n  vec3 C1 = vec3(0.7, 0.7, 0.5);\n  vec3 C2 = vec3(0.7, 0.7, 0.4);\n  vec3 C3 = vec3(sin(time)*0.4+0.5, 0.22, 0.712);\n    \n  float dist = length(p);\n  float angle = atan(p.x, p.y);\n  vec4 color = vec4(C3.x, C3.y, C3.z, clamp(1.0 - dist*0.4, 0.0, 1.0)*rat);  \n\n  float ray1 = clamp((sin(angle*6.0 - dist*sin(time)*5.0 + time*2.0) + 0.0) * 2.0, 0.0, 0.7) - dist*0.3;\n  color = mixc(color, vec4(C1.x, C1.y, C1.z, ray1*rat));\n\n  float ray2 = clamp((sin(angle*17.0 -dist * 8.0 + time*3.43) + 0.0) * 2.0, 0.0, 0.4) - dist*0.1;\n  color = mixc(color, vec4(C2.x, C2.y, C2.z, ray2*rat));\n\n  float circ = clamp((2.25-dist*2.0)*0.47, 0.0, 1.0);\n  color = mixc(color, vec4(1, 1, 1, circ*rat));\n    \n  color *= clamp(1.0-pow(p.x*p.x+p.y*p.y, 0.95)*0.2, 0.0, 1.0);\n\n  return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n    float time = iTime;\n    float Dist = 3.0;\n\n    // camera\t\n    float angle = 1.0*time + 6.0*mo.x;\n    vec3 ro = vec3(Dist*cos(angle), 0.0 , Dist*sin(angle));\n    vec3 ta = vec3(-0.0, 0.0, 0.0);\n    mat3 ca = setCamera(ro, ta, 0.0);\n    vec3 rd = ca * normalize(vec3(p.xy,2.5));\n\n    vec4 duckColor = render(ro, rd, -0.8-angle);\n    vec4 backgroundColor = background(p, time);\n    fragColor = mix(backgroundColor, duckColor, duckColor.a);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsSDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 90], [92, 92, 116, 116, 765], [767, 767, 796, 796, 957], [959, 959, 983, 983, 1110], [1112, 1112, 1144, 1144, 1180], [1182, 1182, 1216, 1216, 1320], [1322, 1322, 1342, 1342, 1766], [1768, 1768, 1806, 1806, 2147], [2149, 2149, 2179, 2179, 2415], [2417, 2417, 2467, 2467, 3529], [3531, 3531, 3581, 3581, 3764], [3766, 3766, 3795, 3795, 3904], [3906, 3906, 3943, 3943, 4753], [4755, 4755, 4812, 4812, 5400]], "test": "valid"}
{"id": "4lSSDz", "name": "Water Effect - 12345", "author": "chipbell4", "description": "Emulating the PBSKids Water Shader", "tags": ["2d", "water"], "likes": 3, "viewed": 509, "published": "Public", "date": "1442858881", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float xDisplacement = 0.003 * sin(uv.x * 10.0 + iTime * 2.);\n    vec2 warpedUV = vec2( uv.x + xDisplacement * sin(uv.y * 10.), uv.y);\n    \n    vec4 waterColor = vec4(1., 1., 1., 1.);\n    float waterBrightness = (1. + sin(uv.x * 20. + iTime * 4.)) / 16.;\n    \n    \n\tfragColor = (waterBrightness * waterColor) + texture(iChannel0, warpedUV);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSSDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 450]], "test": "error"}
{"id": "4lSSW1", "name": "Fan 2D #2 - pii", "author": "public_int_i", "description": "2D fan thing", "tags": ["2d", "fan"], "likes": 2, "viewed": 132, "published": "Public", "date": "1443106588", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n    \n    float ang = atan(uv.y,uv.x);\n    vec2 auv = vec2(0.,\n                    length(uv)-.5);\n    \n    float d = 999.;\n    for (int i = 0; i < 4; i++) {\n        \n        auv.x = mod(ang*float(i+1)+iTime*float(i),1.)-.5;\n        \n        float h = cos(iTime*2.+floor(ang) + cos(floor(ang*4.)+iTime)*.5 )*.1;\n        d = min(d,\n                length(max(abs(auv-vec2(0.,-.2+h))-vec2(.03,.1), 0.)));\n    \n    }\n    \n    d = max(0.,1.-d*100.);\n    fragColor = vec4(d,d,d,1.);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSSW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 590]], "test": "valid"}
{"id": "4t2SDh", "name": "A faster triangle noise", "author": "TomF", "description": "A modification of https://www.shadertoy.com/view/4ssXRX, adding a second way to do triangle noise that only does a single RNG call. Whether it's actually *faster* depends on your chosen RNG function.", "tags": ["noise", "random", "rnd", "distribution", "trianglenoise"], "likes": 108, "viewed": 8885, "published": "Public", "date": "1443313143", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Modification of https://www.shadertoy.com/view/4ssXRX\n// Added a second way to do triangle noise without doing\n// a second random sample.\n\nconst int NUM_BUCKETS = 32;\nconst int ITER_PER_BUCKET = 1024;\nconst float HIST_SCALE = 8.0;\n\nconst float NUM_BUCKETS_F = float(NUM_BUCKETS);\nconst float ITER_PER_BUCKET_F = float(ITER_PER_BUCKET);\n\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n//note: remaps v to [0;1] in interval [a;b]\nfloat remap( float a, float b, float v )\n{\n\treturn clamp( (v-a) / (b-a), 0.0, 1.0 );\n}\n//note: quantizes in l levels\nfloat truncate( float a, float l )\n{\n\treturn floor(a*l)/l;\n}\n\nfloat n1rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\treturn nrnd0;\n}\nfloat n2rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\treturn (nrnd0+nrnd1) / 2.0;\n}\n\nfloat n2rand_faster( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\n    // Convert uniform distribution into triangle-shaped distribution.\n    float orig = nrnd0*2.0-1.0;\n    nrnd0 = orig*inversesqrt(abs(orig));\n    nrnd0 = max(-1.0,nrnd0); // Nerf the NaN generated by 0*rsqrt(0). Thanks @FioraAeterna!\n    nrnd0 = nrnd0-sign(orig)+0.5;\n    \n    // Result is range [-0.5,1.5] which is\n    // useful for actual dithering.\n    // convert to [0,1] for histogram.\n    return (nrnd0+0.5) * 0.5;\n}\nfloat n3rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\treturn (nrnd0+nrnd1+nrnd2) / 3.0;\n}\nfloat n4rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n\treturn (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;\n}\nfloat n4rand_inv( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n    float nrnd4 = nrand( n + 0.19*t );\n\tfloat v1 = (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;\n    float v2 = 0.5 * remap( 0.0, 0.5, v1 ) + 0.5;\n    float v3 = 0.5 * remap( 0.5, 1.0, v1 );\n    return (nrnd4<0.5) ? v2 : v3;\n}\n\n/*\n//alternate Gaussian,\n//thanks to @self_shadow\nfloat n4rand( vec2 n )\n{\n\tfloat nrnd0 = nrand( n + 0.07*fract( iTime ) );\n\tfloat nrnd1 = nrand( n + 0.11*fract( iTime + 0.573953 ) );\t\n\treturn 0.23*sqrt(-log(nrnd0+0.00001))*cos(2.0*3.141592*nrnd1)+0.5;\n}\n*/\n/*\n//Mouse Y give you a curve distribution of ^1 to ^8\n//thanks to Trisomie21\nfloat n4rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\t\n\tfloat p = 1. / (1. + iMouse.y * 8. / iResolution.y);\n\tnrnd0 -= .5;\n\tnrnd0 *= 2.;\n\tif(nrnd0<0.)\n\t\tnrnd0 = pow(1.+nrnd0, p)*.5;\n\telse\n\t\tnrnd0 = 1.-pow(nrnd0, p)*.5;\n\treturn nrnd0; \n}\n*/\n\nfloat histogram( int iter, vec2 uv, vec2 interval, float height, float scale )\n{\n\tfloat t = remap( interval.x, interval.y, uv.x );\n\tvec2 bucket = vec2( truncate(t,NUM_BUCKETS_F), truncate(t,NUM_BUCKETS_F)+1.0/NUM_BUCKETS_F);\n\tfloat bucketval = 0.0;\n\tfor ( int i=0;i<ITER_PER_BUCKET;++i)\n\t{\n\t\tfloat seed = float(i)/ITER_PER_BUCKET_F;\n\t\t\n\t\tfloat r;\n\t\tif ( iter < 2 )\n\t\t\tr = n1rand( vec2(uv.x,0.5) + seed );\n\t\telse if ( iter<3 )\n\t\t\tr = n2rand( vec2(uv.x,0.5) + seed );\n\t\telse if ( iter<4 )\n\t\t\tr = n2rand_faster( vec2(uv.x,0.5) + seed );\n\t\telse if ( iter<5 )\n\t\t\tr = n3rand( vec2(uv.x,0.5) + seed );\n\t\telse\n\t\t\tr = n4rand( vec2(uv.x,0.5) + seed );\n\t\t\n\t\tbucketval += step(bucket.x,r) * step(r,bucket.y);\n\t}\n\tbucketval /= ITER_PER_BUCKET_F;\n\tbucketval *= scale;\n    \n    float v0 = step( uv.y / height, bucketval );\n    float v1 = step( (uv.y-1.0/iResolution.y) / height, bucketval );\n    float v2 = step( (uv.y+1.0/iResolution.y) / height, bucketval );\n\treturn 0.5 * v0 + v1-v2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfloat o;\n    int idx;\n    vec2 uvrange;\n\tif ( uv.x < 1.0/5.0 )\n\t{\n\t\to = n1rand( uv );\n        idx = 1;\n        uvrange = vec2( 0.0/5.0, 1.0/5.0 );\n\t}\n\telse if ( uv.x < 2.0 / 5.0 )\n\t{\n\t\to = n2rand( uv );\n        idx = 2;\n        uvrange = vec2( 1.0/5.0, 2.0/5.0 );\n\t}\n\telse if ( uv.x < 3.0 / 5.0 )\n\t{\n\t\to = n2rand_faster( uv );\n        idx = 3;\n        uvrange = vec2( 2.0/5.0, 3.0/5.0 );\n\t}\n\telse if ( uv.x < 4.0 / 5.0 )\n\t{\n\t\to = n3rand( uv );\n        idx = 4;\n        uvrange = vec2( 3.0/5.0, 4.0/5.0 );\n\t}\n\telse\n\t{\n\t\to = n4rand( uv );\n        idx = 5;\n        uvrange = vec2( 4.0/5.0, 5.0/5.0 );\n\t}\n\n    //display histogram\n    if ( uv.y < 1.0 / 4.0 )\n\t\to = 0.125 + histogram( idx, uv, uvrange, 1.0/4.0, HIST_SCALE );\n    \n\t//display lines\n\tif ( abs(uv.x - 1.0/5.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.x - 2.0/5.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.x - 3.0/5.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.x - 4.0/5.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.y - 1.0/4.0) < 0.002 ) o = 0.0;\n\n\t\n\tfragColor = vec4( vec3(o), 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2SDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[341, 395, 418, 418, 486], [487, 531, 573, 573, 617], [618, 648, 684, 684, 708], [710, 710, 734, 734, 814], [815, 815, 839, 839, 969], [971, 971, 1002, 1002, 1491], [1492, 1492, 1516, 1516, 1688], [1689, 1689, 1713, 1713, 1928], [1929, 1929, 1957, 1957, 2343], [2957, 2957, 3037, 3037, 3930], [3932, 3932, 3989, 3989, 5041]], "test": "valid"}
{"id": "4t2SRh", "name": "Umbrellar", "author": "candycat", "description": "Draw a umbrellar", "tags": ["distancefield"], "likes": 185, "viewed": 87063, "published": "Public", "date": "1441550472", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdfCircle(vec2 center, float radius, vec2 coord )\n{\n    vec2 offset = coord - center;\n    \n    return sqrt((offset.x * offset.x) + (offset.y * offset.y)) - radius;\n}\n\nfloat sdfEllipse(vec2 center, float a, float b, vec2 coord)\n{\n    float a2 = a * a;\n    float b2 = b * b;\n    return (b2 * (coord.x - center.x) * (coord.x - center.x) + \n        a2 * (coord.y - center.y) * (coord.y - center.y) - a2 * b2)/(a2 * b2);\n}\n\nfloat sdfLine(vec2 p0, vec2 p1, float width, vec2 coord)\n{\n    vec2 dir0 = p1 - p0;\n\tvec2 dir1 = coord - p0;\n\tfloat h = clamp(dot(dir0, dir1)/dot(dir0, dir0), 0.0, 1.0);\n\treturn (length(dir1 - dir0 * h) - width * 0.5);\n}\n\nfloat sdfUnion( const float a, const float b )\n{\n    return min(a, b);\n}\n\nfloat sdfDifference( const float a, const float b)\n{\n    return max(a, -b);\n}\n\nfloat sdfIntersection( const float a, const float b )\n{\n    return max(a, b);\n}\n\nvec4 render(float d, vec3 color, float stroke)\n{\n    //stroke = fwidth(d) * 2.0;\n    float anti = fwidth(d) * 1.0;\n    vec4 strokeLayer = vec4(vec3(0.05), 1.0-smoothstep(-anti, anti, d - stroke));\n    vec4 colorLayer = vec4(color, 1.0-smoothstep(-anti, anti, d));\n\n    if (stroke < 0.000001) {\n    \treturn colorLayer;\n    }\n    return vec4(mix(strokeLayer.rgb, colorLayer.rgb, colorLayer.a), strokeLayer.a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat size = min(iResolution.x, iResolution.y);\n    float pixSize = 1.0 / size;\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    float stroke = pixSize * 1.5;\n    vec2 center = vec2(0.5, 0.5 * iResolution.y/iResolution.x);\n    \n    float a = sdfEllipse(vec2(0.5, center.y*2.0-0.34), 0.25, 0.25, uv);\n    float b = sdfEllipse(vec2(0.5, center.y*2.0+0.03), 0.8, 0.35, uv);\n    b = sdfIntersection(a, b);\n    vec4 layer1 = render(b, vec3(0.32, 0.56, 0.53), fwidth(b) * 2.0);\n    \n    // Draw strips\n    vec4 layer2 = layer1;\n    float t, r0, r1, r2, e, f;\n    vec2 sinuv = vec2(uv.x, (sin(uv.x*40.0)*0.02 + 1.0)*uv.y);\n    for (float i = 0.0; i < 10.0; i++) {\n    \tt = mod(iTime + 0.3 * i, 3.0) * 0.2;\n    \tr0 = (t - 0.15) / 0.2 * 0.9 + 0.1;\n    \tr1 = (t - 0.15) / 0.2 * 0.1 + 0.9;\n        r2 = (t - 0.15) / 0.2 * 0.15 + 0.85;\n        e = sdfEllipse(vec2(0.5, center.y*2.0+0.37-t*r2), 0.7*r0, 0.35*r1, sinuv);\n    \tf = sdfEllipse(vec2(0.5, center.y*2.0+0.41-t), 0.7*r0, 0.35*r1, sinuv);\n    \tf = sdfDifference(e, f);\n    \tf = sdfIntersection(f, b);\n    \tvec4 layer = render(f, vec3(1.0, 0.81, 0.27), 0.0);\n        layer2 = mix(layer2, layer, layer.a);\n    }\n    \n    \n    // Draw the handle\n    float bottom = 0.08;\n    float handleWidth = 0.01;\n    float handleRadius = 0.04;\n    float d = sdfCircle(vec2(0.5-handleRadius+0.5*handleWidth, bottom), handleRadius, uv);\n    float c = sdfCircle(vec2(0.5-handleRadius+0.5*handleWidth, bottom), handleRadius-handleWidth, uv);\n    d = sdfDifference(d, c);\n    c = uv.y - bottom;\n    d = sdfIntersection(d, c);\n    c = sdfLine(vec2(0.5, center.y*2.0-0.05), vec2(0.5, bottom), handleWidth, uv);\n    d = sdfUnion(d, c);\n    c = sdfCircle(vec2(0.5, center.y*2.0-0.05), 0.01, uv);\n    d = sdfUnion(c, d);\n    c = sdfCircle(vec2(0.5-handleRadius*2.0+handleWidth, bottom), handleWidth*0.5, uv);\n    d = sdfUnion(c, d);\n    vec4 layer0 = render(d, vec3(0.404, 0.298, 0.278), stroke);\n    \n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n    vec3 bcol = vec3(1.0,0.8,0.7-0.07*p.y)*(1.0-0.25*length(p));\n    fragColor = vec4(bcol, 1.0);  \n    fragColor.rgb = mix(fragColor.rgb, layer0.rgb, layer0.a);\n    fragColor.rgb = mix(fragColor.rgb, layer1.rgb, layer1.a);\n    fragColor.rgb = mix(fragColor.rgb, layer2.rgb, layer2.a);\n    \n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2SRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 171], [173, 173, 234, 234, 423], [425, 425, 483, 483, 645], [647, 647, 695, 695, 719], [721, 721, 773, 773, 798], [800, 800, 855, 855, 879], [881, 881, 929, 961, 1290], [1292, 1292, 1349, 1349, 3697]], "test": "valid"}
{"id": "4t2SRz", "name": "Smoke Screen", "author": "jackdavenport", "description": "A smoke screen overlay effect", "tags": ["perlin", "effect", "smoke", "overlay"], "likes": 12, "viewed": 722, "published": "Public", "date": "1441078548", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random(float x) {\n \n    return fract(sin(x) * 10000.);\n    \n}\n\nfloat noise(vec2 p) {\n    \n \treturn random(p.x + p.y * 10000.);\n    \n}\n\nvec2 sw(vec2 p) { return vec2(floor(p.x), floor(p.y)); }\nvec2 se(vec2 p) { return vec2(ceil(p.x), floor(p.y)); }\nvec2 nw(vec2 p) { return vec2(floor(p.x), ceil(p.y)); }\nvec2 ne(vec2 p) { return vec2(ceil(p.x), ceil(p.y)); }\n\nfloat smoothNoise(vec2 p) {\n \n    vec2 interp = smoothstep(0., 1., fract(p));\n    float s = mix(noise(sw(p)), noise(se(p)), interp.x);\n    float n = mix(noise(nw(p)), noise(ne(p)), interp.x);\n    return mix(s, n, interp.y);\n    \n}\n\nfloat fractalNoise(vec2 p) {\n \n    float n = 0.;\n    n += smoothNoise(p);\n    n += smoothNoise(p * 2.) / 2.;\n    n += smoothNoise(p * 4.) / 4.;\n    n += smoothNoise(p * 8.) / 8.;\n    n += smoothNoise(p * 16.) / 16.;\n    n /= 1. + 1./2. + 1./4. + 1./8. + 1./16.;\n    return n;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 nuv = vec2(uv.x - iTime / 6., uv.y);\n    uv *= vec2(1., -1.);\n    \n\tfloat x = fractalNoise(nuv * 6.);\n    vec3 final = mix(vec3(x), texture(iChannel0, uv).xyz, pow(abs(uv.y), .9));\n    \n    fragColor = vec4(final, 1.);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2SRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 67], [69, 69, 90, 90, 139], [141, 141, 158, 158, 197], [198, 198, 215, 215, 253], [254, 254, 271, 271, 309], [310, 310, 327, 327, 364], [366, 366, 393, 393, 596], [598, 598, 626, 626, 880], [882, 882, 939, 939, 1211]], "test": "error"}
{"id": "4t2XzD", "name": "GGX Orbit?", "author": "mjolnir", "description": "My first shadertoy shader... where I meant to do something else entirely, but alas, GGX rainbows orbiting a flat, flat sphere. \nAlso, no perspective, which makes it a little hard to see what's really going on :)", "tags": ["ggx"], "likes": 33, "viewed": 2138, "published": "Public", "date": "1442133035", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define PI2 (PI/2.)\n\n// tuneables\n#define SCALE 15.0\n#define ROUGH 0.25\n#define REFL 0.02\n#define LIGHTWRAP sin(iTime/2.0)*5.0 // was 5.0, this is clearly more fun\n#define NUM_LIGHTS 64\n#define SPHERE_RAD 4.5\n#define ORBIT_DIST 4.0\n#define ALBEDO vec3(0.25)\n#define HUE_SHIFT_RATE 0.25\n#define HUE_BAND_SCALE 0.25\n#define VERTICAL_ACCUM_SIN_SCALE 0.5\n#define LIGHT_INTENSITY 0.5\n\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n// GGX code borrowed from John Hable: https://gist.github.com/Kuranes/3065139b10f2d85074da\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0)\n{\n    float alpha = roughness*roughness;\n\n    vec3 H = normalize(V+L);\n\n    float dotNL = saturate(dot(N,L));\n\n    float dotLH = saturate(dot(L,H));\n    float dotNH = saturate(dot(N,H));\n\n    float F, D, vis;\n\n    // D\n    float alphaSqr = alpha*alpha;\n    float denom = dotNH * dotNH *(alphaSqr-1.0) + 1.0;\n    D = alphaSqr/(PI * denom * denom);\n\n    // F\n    float dotLH5 = pow(1.0-dotLH,5.);\n    F = F0 + (1.-F0)*(dotLH5);\n\n    // V\n    float k = alpha/2.;\n    float k2 = k*k;\n    float invK2 = 1.-k2;\n    vis = 1./(dotLH*dotLH*invK2 + k2);\n\n    float specular = dotNL * D * F * vis;\n    return specular;\n}\n\n// blatantly stolen from https://gist.github.com/eieio/4109795 (because rainbows)\nvec3 hsv_to_rgb(float h, float s, float v)\n{\n\tfloat c = v * s;\n\th = mod((h * 6.0), 6.0);\n\tfloat x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n\tvec3 color;\n\n\tif (0.0 <= h && h < 1.0) {\n\t\tcolor = vec3(c, x, 0.0);\n\t} else if (1.0 <= h && h < 2.0) {\n\t\tcolor = vec3(x, c, 0.0);\n\t} else if (2.0 <= h && h < 3.0) {\n\t\tcolor = vec3(0.0, c, x);\n\t} else if (3.0 <= h && h < 4.0) {\n\t\tcolor = vec3(0.0, x, c);\n\t} else if (4.0 <= h && h < 5.0) {\n\t\tcolor = vec3(x, 0.0, c);\n\t} else if (5.0 <= h && h < 6.0) {\n\t\tcolor = vec3(c, 0.0, x);\n\t} else {\n\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t}\n\n\tcolor.rgb += v - c;\n\n\treturn color;\n}\n\nstruct PointLight\n{\n    vec3 pos;\n    vec3 color;\n};\n\nvec3 sphereNorm(vec2 ws, vec3 c, float r)\n{\n    vec3 pt = vec3((ws-c.xy)/r, 0);\n    pt.z = -cos(length(pt.xy)*PI2);\n    return normalize(pt);\n}\n\nbool sphereTest(vec2 ws, vec3 c, float r)\n{\n    vec3 pt = vec3(ws-c.xy, c.z);\n    return (dot(pt.xy, pt.xy) < r*r);\n}\n\nvec3 spherePos(vec2 ws, vec3 c, float r)\n{\n    vec3 pt = vec3(ws, c.z);\n    pt.z -= cos(length((ws-c.xy)/r)*PI2)*r;\n    return pt;\n}\n\n\nvec4 sphere(vec3 pt, vec3 N, PointLight pl, float rough, float refl)\n{   \n    vec3 V = vec3(0, 0, -1);\n    vec3 pToL = pl.pos - pt;\n    vec3 L = normalize(pToL);\n    \n    float decay = length(pToL);\n    decay = 1./decay*decay;\n    \n    float diffuse = dot(N,L) / PI;\n    float spec = GGX(N, V, L, rough, refl);\n            \n    if (dot(N,L) >= 0.)\n    {\n    \treturn vec4(decay * pl.color * (spec + diffuse * ALBEDO), pt.z);\n    }\n    else\n    {\n        return vec4(0, 0, 0, pt.z);\n    } \n}\n\nstruct LightAnim\n{\n    vec3 period;\n    vec3 shift;\n    vec3 orbit;\n    vec3 offset;\n};\n\n\nPointLight getLight(vec3 color, LightAnim anim)\n{\n    vec3 pos = sin(iTime * anim.period + anim.shift) * anim.orbit + anim.offset;\n    PointLight mypt = PointLight(pos, color);\n    return mypt;\n}\n\n\nvec4 renderLight(vec2 cs, PointLight pt)\n{\n    return vec4(pt.color * saturate(.1 - abs(length(cs-pt.pos.xy)))*100., pt.pos.z);\n}\n\nvoid drawWriteZ(vec4 result, inout vec4 fragColor)\n{\n    fragColor.xyz += result.xyz;\n    fragColor.w = result.w;\n}\n\nvoid drawTestZ(vec4 result, inout vec4 fragColor)\n{\n\tif (result.w <= fragColor.w || fragColor.w < 0.)\n    {\n        fragColor.xyz += result.xyz;\n    }\n}\n\nvoid planet(vec2 csUv, inout vec4 fragColor, LightAnim anim, bool isGeo, vec3 norm, vec3 pos, vec3 color)\n{\n    PointLight ptL = getLight(color, anim);\n    \n    if (isGeo)\n    {\n    \tdrawWriteZ(sphere(pos, norm, ptL, ROUGH, REFL), fragColor);\n    }\n    drawTestZ(renderLight(csUv, ptL), fragColor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;       \n    vec4 csUv = vec4(uv-vec2(0.5, 0.5), iMouse.xy/iResolution.xy);\n    csUv.x *= aspect;\n    csUv.xy *= SCALE;   \n    \n    float sphereRad = SPHERE_RAD;\n    float orbitDelta = ORBIT_DIST;\n    float orbit = sphereRad+orbitDelta;\n    \n    // period, shift, orbit, offset\n    LightAnim anim = LightAnim(vec3(1, 0, 1), vec3(0, PI2, PI2), vec3(orbit, 0, -orbit), vec3(0, 0, 10));\n    \n    vec3 sphereCenter = vec3(0, 0, 10);\n    \n    vec3 sPos = spherePos(csUv.xy, sphereCenter, sphereRad);\n    vec3 sNorm = sphereNorm(csUv.xy, sphereCenter, sphereRad);\n    bool isSphere = sphereTest(csUv.xy, sphereCenter, sphereRad);\n    \n    fragColor.xyzw = vec4(0, 0, 0, -1); // lazy \"depth\" value\n    \n    const int totalPlanets=NUM_LIGHTS;\n    \n    for (int i = 0; i < totalPlanets; ++i)\n    {\n        float rat = 1.-float(i)/float(totalPlanets);\n        \n        float hue = mod(HUE_SHIFT_RATE*-iTime+rat*HUE_BAND_SCALE,1.);\n        \n        vec3 color = hsv_to_rgb(hue, 1., LIGHT_INTENSITY*rat);\n        \n    \tplanet(csUv.xy, fragColor, anim, isSphere, sNorm, sPos, color);\n        \n        anim.orbit.y += sin(iTime)*VERTICAL_ACCUM_SIN_SCALE; // making things more interesting...\n        \n        anim.shift += LIGHTWRAP*2.*PI/float(totalPlanets);\n    \t   \n    }\n    \n    fragColor.xyz = pow(fragColor.xyz, 1./vec3(2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2XzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[446, 537, 599, 599, 1207], [1209, 1291, 1335, 1335, 1889], [1945, 1945, 1988, 1988, 2088], [2090, 2090, 2133, 2133, 2207], [2209, 2209, 2251, 2251, 2341], [2344, 2344, 2414, 2414, 2833], [2925, 2925, 2974, 2974, 3120], [3123, 3123, 3165, 3165, 3252], [3254, 3254, 3306, 3306, 3369], [3371, 3371, 3422, 3422, 3523], [3525, 3525, 3632, 3632, 3825], [3827, 3827, 3884, 3884, 5296]], "test": "valid"}
{"id": "4t2XzW", "name": "warm colors", "author": "xkpe", "description": "Generated object abstratac", "tags": ["abstract"], "likes": 12, "viewed": 208, "published": "Public", "date": "1442018649", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by Francisco Santos 2015\n\n// camera\nvec3 CAM = vec3(0., 0., -100.);\nfloat NP = 1.;\nfloat ANG = 3.14159 / 8.;\n\n// sphere\nvec3 SPH = vec3(0.);\nfloat RADIUS = 50.;\n\n// others\nvec2 RES = iResolution.xy;\n\n// calculate initial direction direction\nvoid calcVd(in vec2 c, out vec3 vo, out vec3 vd)\n{\n    vec2 co = (2.*c - RES)/RES.x;\n\n    vo = CAM + NP * vec3( co, 1.);\n    vd = normalize(vo - CAM);\n}\n\nvec3 objCol( in vec3 vo, in vec3 vd, in float time )\n{\n    vec3 col = vec3(0);\n\n    float za = sin(time*.13);\n    \n    float ani = 0.01 * (1.5-.5*sin(time*0.2));\n    \n    vec3 p = vo;\n    for(float n = 0.; n<200.; n+=1.)\n    {\n        vec2 tc = vd.yx*za;\n        \n        vec3 offset = ani * (texture(iChannel0, tc).rgb-0.5)*0.5;\n        \n        vd += offset;\n        \n        vec3 d = p-SPH;\n        if( length(d) < RADIUS) {\n            col += vd.bgr;\n            col += .1*normalize(d);\n        }\n        p += vd;\n    }\n    \n    return abs(col*.01);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 c = (fragCoord - iResolution.xy*.5)/iResolution.x ;\n    float t = iTime * .2;\n    mat2 r = mat2(cos(t),sin(t),-sin(t),cos(t));\n\n    c = iResolution.xy*.5 + iResolution.x*(r * c);\n    \n    vec3 vo;\n    vec3 vd;\n    calcVd(c, vo, vd);\n    vec3 col = objCol( vo, vd, iTime );\n    \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2XzW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[298, 339, 389, 389, 491], [493, 493, 547, 547, 1048], [1050, 1050, 1107, 1107, 1430]], "test": "error"}
{"id": "4tBSzm", "name": "Simple tracing", "author": "Neper", "description": "This is a simple ray tracer. The scene has a sphere and a plane. In addition, there is a sky dome and some fog. The reflection model is also kept simple Lambert law plus Phong for specular reflection. The code is written for clarity, not for speed.", "tags": ["raytracing"], "likes": 5, "viewed": 390, "published": "Public", "date": "1442811226", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A simple ray tracer.\n\n// Sun\nconst vec3 SunDir \t\t= vec3(0.577, 0.577, -0.577);\nconst vec3 SunColor \t= 10.0 * vec3(1.0, 1.0, 0.8);\n\n// Sphere\nconst vec4 Sphere \t\t= vec4(0.0, 0.0, 5.0, 1.0);\nconst vec3 SphereColor \t= vec3(0.9, 0.2, 0.1);\n\n// Plane\nconst vec4 Plane \t\t= vec4(0.0, 1.0, 0.0, -1.0);\nconst vec3 PlaneColor \t= vec3(0.0, 0.0, 0.0);\n\n// Sky\nconst vec4 SkyDome \t\t= vec4(0.0, 0.0, 0.0, 1.0e5);\nconst vec3 SkyColor \t= vec3(0.05, 0.05, 0.95);\n\n// Fog in the horixon\nconst vec3 HorizonColor = vec3(0.7, 0.7, 0.9);\n\n// Ray tracing constants\nconst float VeryFar \t= 1.0e6;\nconst float VeryNear \t= 1.0e-3;\nconst int MaxBounces \t= 10;\n\n// Material - Approximates glass\nconst float R0 \t\t\t= 0.2 * 0.2;\n\n// Animation\nconst float CamR \t\t= 2.0;\n\n// Luminance factor for tone mapping\nconst vec3 Luminance \t= vec3(0.2126, 0.7152, 0.0722);\n\n// Intersection functions\nfloat plane_intersect(vec3 pos, vec3 dir, vec4 plane)\n{\n    return (plane.w - dot(pos, plane.xyz)) / dot(dir, plane.xyz);\n}\n\nfloat sphere_intersect(vec3 pos, vec3 dir, vec4 sphere)\n{\n    vec3 s \t= sphere.xyz - pos;\n    float b = dot(dir, s);\n    float D = b * b - dot(s, s) + sphere.w * sphere.w;\n    if (D < 0.0) return -1.0;\n    float t = b - sqrt(D);\n    return (t > 0.0) ? t : b + sqrt(D);\n}\n\n// Shadow ray intersection - return true or false\nbool shadow_intersect(vec3 pos, vec3 dir)\n{\n    if (sphere_intersect(pos, dir, Sphere) > 0.0) return true;\n    if (plane_intersect(pos, dir, Plane) > 0.0) return true;\n    return false;\n}\n\n// Other ray intersections - returns true or false, and in addition \n// hit position, normal, color, and whether the object is should be shaded or not\nbool any_intersect(vec3 pos, vec3 dir, \n                   out vec3 hit_pos, out vec3 hit_normal,\n                   out vec3 hit_color, out bool shaded)\n{\n    float t, t_min = VeryFar;\n    \n    for (int z = -10; z <= 10; z += 5)\n    {\n        for (int x = -10; x <= 10; x += 5)\n        {        \n            vec3 pos_s = pos + vec3(x, -1.0 + sin(float(x + z) + iTime), z);\n            t = sphere_intersect(pos_s, dir, Sphere);\n            if ((t > 0.0) && (t < t_min))\n            {\n                hit_pos \t= pos_s + t * dir;\n                hit_normal \t= normalize(hit_pos - Sphere.xyz);\n                hit_color \t= SphereColor;\n                shaded\t\t= true;\n                t_min \t\t= t;\n            }\n    \t}\n    }\n    \n    t = plane_intersect(pos, dir, Plane);\n    if ((t > 0.0) && (t < t_min))\n    {\n       \thit_pos \t= pos + t * dir;\n    \thit_normal \t= Plane.xyz;\n    \thit_color \t= PlaneColor;\n        shaded\t\t= true;\n        t_min \t\t= t;\n   \t}\n    \n            \n    t = sphere_intersect(pos, dir, SkyDome);\n    if ((t > 0.0) && (t < t_min))\n    {\n        hit_pos \t= pos + t * dir;\n        hit_normal \t= normalize(hit_pos - Sphere.xyz);\n        float f \t= hit_pos.y / SkyDome.w;\n        hit_color \t= f * SkyColor + (1.0 - f) * HorizonColor;\n        shaded \t\t= false;\t// Special handling for sky\n        t_min \t\t= t;\n    }\n    \n    \n    // TODO: Add other objects here if you want a more complicated scene\n    \n    if (t_min < VeryFar) return true;\n    \n    return false;\n}\n\n// Shading models\nfloat shadeLambert(vec3 normal, vec3 light)\n{\n    return clamp(dot(normal, light), 0.0, 1.0);\n}\n\nfloat shadePhong(vec3 normal, vec3 light, vec3 view)\n{\n    return pow(clamp(dot(reflect(view, normal), light), 0.0, 1.0), 80.0);\n}\n\nfloat shadeFog(vec3 pos)\n{\n    return clamp(0.1 * log2(length(pos)), 0.0, 1.0);\n}\n\n// Main ray tracing code\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Calculate ray direction based on the screen coordinate\n    vec2 uv\t\t\t\t= -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    vec2 aspect_ratio\t= vec2(1.0, iResolution.y / iResolution.x);    \n    vec3 dir \t\t\t= normalize(vec3(uv * aspect_ratio, 1.0));       \n    \n    // Animate camera position - the position goes in a circle, but the direction stays the same\n    vec3 pos \t\t\t= vec3(CamR * cos(iTime), 0.5, CamR * sin(iTime));\n    \n    // Initialize color and ray contribution factor\n    vec3 color \t\t\t= vec3(0.0, 0.0, 0.0);\n    float factor \t\t= 1.0;\n    \n    // Initialize hit properties\n    vec3 hit_pos \t\t= vec3(0.0, 0.0, 0.0);\n    vec3 hit_normal \t= vec3(0.0, 0.0, 0.0);\n    vec3 hit_color \t\t= vec3(0.0, 0.0, 0.0);\n    bool shaded \t\t= false;\n    \n    // Bounce the ray\n    for (int k = 0; k < MaxBounces; k++)\n    {\n        // Check any intersections\n    \tif (any_intersect(pos, dir, hit_pos, hit_normal, hit_color, shaded))\n    \t{\n            // For intersection, calculate shading factors, if the object must be shaded\n            float diffuse_factor \t= shaded ? shadeLambert(hit_normal, SunDir) \t: 1.0;\n            float specular_factor \t= shaded ? shadePhong(hit_normal, SunDir, dir) \t: 0.0;\n       \t\tfloat fog_factor \t\t= shaded ? shadeFog(hit_pos) \t\t\t\t\t: 0.0;\n        \n            // To get the next ray start position, add a small offset to the hit position\n            // along the surface normal to avoid hitting the same surface again due to\n            // numerical inaccuracy\n        \tpos = hit_pos + VeryNear * hit_normal;\n        \n            // Cast a shadow ray\n       \t\tif (shaded && shadow_intersect(pos, SunDir))\n        \t{\n                // In shadow, specular reflection is zero, but use a small factor for\n                // diffuse reflection to approximate indirect (ambient) lighting\n            \tdiffuse_factor *= 0.2;\n                specular_factor = 0.0;\n        \t}\n              \n            // Calculate color based on this ray only\n            vec3 lit_color = hit_color * diffuse_factor + SunColor * specular_factor;\n        \tvec3 this_color = (1.0 - fog_factor) * lit_color + fog_factor * HorizonColor;\n        \n            // If no further rays are required, update color and exit\n            if (!shaded)\n            {\n                color += this_color * factor;\n                break;\n            }\n            \n            // Schlick's approximation to Fresnel equations\n            float R = R0 + (1.0 - R0) * pow(1.0 - clamp(dot(hit_normal, -dir), 0.0, 1.0), 5.0);\n            \n            // Add contribution of this ray to color weighted with the reflection factor\n        \tcolor += (1.0 - R) * this_color * factor;\n        \tfactor *= R;\n            \n            // Get the direction of the next ray\n        \tdir = reflect(dir, hit_normal);\n            \n            // TODO: Refracted ray - requires rearranging the tracing code\n            /*\n            vec3 pos2 = hit_pos - VeryNear * hit_normal;\n            vec3 dir2 = refract(dir, hit_normal, 1.5);\n            float T = 1.0 - R;\n            if (any_intersect(pos2, dir2, hit_pos, hit_normal, hit_color, shaded))\n            {\n                \n            }\n\t\t\t*/\n    \t}\n        else\n        {\n            // No hit - exit\n            break;\n        }\n    }\n    \n    // Simple Reinhard tonemapping and transformation to linear color space\n    vec3 tone_mapped = pow(color * 1.0 / (1.0 + dot(color, Luminance)), vec3(1.0 / 2.2));\n    \n\tfragColor = vec4(tone_mapped, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBSzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[833, 859, 914, 914, 982], [984, 984, 1041, 1041, 1254], [1256, 1306, 1349, 1349, 1493], [1495, 1646, 1801, 1801, 3126], [3128, 3146, 3191, 3191, 3241], [3243, 3243, 3297, 3297, 3373], [3375, 3375, 3401, 3401, 3456], [3458, 3483, 3540, 3605, 7023]], "test": "valid"}
{"id": "4tBXR1", "name": "Mushroom", "author": "iq", "description": "A simple mushroom looking thing all alone in the middle of nowhere.", "tags": ["procedural", "3d", "raymarching", "distancefield"], "likes": 86, "viewed": 8497, "published": "Public API", "date": "1441399240", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright Inigo Quilez, 2015 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// make higher for higher quality\n#if HW_PERFORMANCE==0\n#define VIS_SAMPLES 1\n#else\n#define VIS_SAMPLES 2\n#endif\n\nvec3 hash3( vec3 n )\n{\n    return fract(sin(n)*vec3(158.5453123,278.1459123,341.3490423));\n}\n\nvec2 hash2( vec2 n )\n{\n    return fract(sin(n)*vec2(158.5453123,278.1459123));\n}\n\nvec2 sdSegment( in vec3 p, vec3 a, vec3 b )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat sdSphere( in vec3 p, in vec4 s )\n{\n    return length(p-s.xyz) - s.w;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n    return (length( (p-c)/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 smin( vec2 a, vec2 b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b.x-a.x)/k, 0.0, 1.0 );\n\treturn vec2( mix( b.x, a.x, h ) - k*h*(1.0-h), mix( b.y, a.y, h ) );\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n// http://www.iquilezles.org/www/articles/texture/texture.htm\nvec4 textureImproved( const sampler2D tex, in vec2 uv, in vec2 g1, in vec2 g2 )\n{\n    vec2 res = vec2( textureSize( tex, 0 ) );\n\tuv = uv*res + 0.5;\n\tvec2 iuv = floor( uv );\n\t//vec2 fuv = fract( uv );\n    vec2 fuv = uv - iuv;\n\t//uv = iuv + fuv*fuv*(3.0-2.0*fuv);\n    \n    fuv = fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);\n    \n    uv = iuv + fuv;\n    \n\tuv = (uv - 0.5)/res;\n\treturn textureGrad( tex, uv, g1, g2 );\n}\n\n//---------------------------------------------------------------------------\nvec3 drddx;\nvec3 drddy;\n\nfloat head( in vec3 p )\n{\n    // top\n    float d3 = sdEllipsoid( p, vec3(0.0,-0.1,0.0),vec3(0.35,0.2,0.35) );\n    d3 -= 0.03*(0.5+0.5*sin(11.0*p.z)*cos(9.0*p.x));\n    //d3 -= 0.05*exp(-128.0*dot(p.xz,p.xz));\n    \n    // interior\n    float d4 = sdSphere( p, vec4(0.0,-0.45,0.0,0.45) );\n\td4 += 0.005*sin( 20.0*atan(p.x,p.z) );\n\n    // substract\n    return smax( d3, -d4, 0.02 );\n}\n\nfloat head2( in vec3 p )\n{\n    // top\n    float d3 = sdEllipsoid( p, vec3(0.0,-0.1,0.0),vec3(0.35,0.2,0.35) );\n    d3 -= 0.03*(0.5+0.5*sin(11.0*p.z)*cos(9.0*p.x));\n    //d3 -= 0.1*exp(-64.0*dot(p.xz,p.xz));\n    \n    // interior\n    float d4 = sdSphere( p, vec4(0.0,-0.45,0.0,0.48) );\n\n    // substract\n    return smax( d3, -d4, 0.02 );\n}\n\n\nvec2 map( vec3 p, float t )\n{\n\n    // ground\n    vec3 s = p;\n    s.y -= 0.1*sin( 0.25*p.z + 0.5*sin(0.25*p.x) );    \n    s.y += 0.1*cos( 0.25*p.z + 0.5*cos(0.25*p.x) );        \n    \n    vec3 dpdx = t*drddx;\n    vec3 dpdy = t*drddy;\n    \n\n    vec3 dsdx = dpdx - 0.1*cos( 0.25*p.z + 0.5*sin(0.25*p.x) )*(0.25*dpdx.z + 0.5*cos(0.25*p.x)*dpdx.x );\n    vec3 dsdy = dpdy + 0.1*sin( 0.25*p.z + 0.5*cos(0.25*p.x) )*(0.25*dpdx.z - 0.5*sin(0.25*p.x)*dpdx.x );\n\n    float d2 = s.y - 0.17;\n    if( d2<2.0 )\n    {\n    d2 += 0.06*textureGrad( iChannel2, 0.15*s.xz, 0.15*dsdx.xz, 0.15*dsdy.xz ).x;\n        \n    d2 -= 1.5*pow(textureGrad( iChannel3, 0.01*s.xz,  0.01*dsdx.xz/256.0, 0.01*dsdy.xz/256.0 ).x,0.35) - 0.8;\n    //d2 -= 1.5*pow(textureImproved( iChannel3, 0.01*s.xz,  0.01*dsdx.xz/256.0, 0.01*dsdy.xz/256.0 ).x,0.35) - 0.8;\n            \n    }\n    d2 *= 0.8;\n    vec2 res = vec2(d2,1.0);\n    \n    \n    // mushroom\n    vec3 d = vec3(0.0,0.95,0.0);\n    vec3 q = p - d;\n   \n    float bb = length(q+vec3(0.0,0.3,0.0))-0.8;\n    if( bb<0.0 )\n    {\n        // animate\n        //float an = 0.5 + 0.5*cos(2.0*iTime + 9.0* p.y);\n        //q.xz *= 1.1 - an*0.2*(1.0-smoothstep( 0.0, 0.6, abs(q.y+0.1) ));\n\n        // stem\n        float h = clamp(q.y+1.0,0.0,1.0);\n        vec3 o = 0.12 * sin( h*3.0 + vec3(0.0,2.0,4.0) );\n        o = o*4.0*h*(1.0-h) * h;\n        float d1 = sdSegment( q + vec3(0.0,1.0,0.0) - o*vec3(1.0,0.0,1.0), vec3(0.0,0.0,0.0), vec3(0.0,1.0,0.0) ).x;\n        d1 -= 0.04;\n        d1 -= 0.1*exp(-16.0*h);\n\n        float d3 = head( q );\n\n        // mix head and stem\n        d1 = smin( d1, d3, 0.2 );\n        d1 *= 0.75;\n        vec2 res2 = vec2(d1,0.0);\n\n\n        // balls\n        float ff = 10.0;\n        vec3 id = floor(q*ff);\n        vec3 wr = (id*2.0 + 1.0)/(2.0*ff);\n        //wr += (-1.0+2.0*hash3(id)) * 0.2/ff;\n        if( head2( wr )<0.0 )\n        {\n        vec3 r = (fract(q*ff) - 0.5)/ff;\n        //r += (-1.0+2.0*hash3(id)) * 0.2/ff;\n        float d5 = (length(r)-0.03);\n        //vec3 n = abs(normalize(wr));\n        //float d5 = sdEllipsoid( r, vec3(0.0), vec3(0.03) );\n        if( d5<res2.x ) res2 = vec2(d5,2.0);\n        }\n        res = smin( res, res2, 0.1 );\n    }\n    else\n    {\n       res = min(res,vec2( bb+0.1, 2.0 ));\n    }\n    \n#if 1\n    vec2 pid = floor( (p.xz+2.0)/4.0 );\n    p.xz = mod(p.xz+2.0,4.0)-2.0;\n    if( dot(pid,pid)>0.5 )\n    {\n        p.xz += 1.0*(-1.0+2.0*hash2( vec2(313.1*pid.x + 171.4*pid.y,331.8*pid.x + 153.4*pid.y) ));\n        float d3 = sdSphere(p,vec4(0.0,0.0,0.0,0.8));\n        for( int i=0; i<6; i++ )\n        {\n            vec3 sc = -1.0+2.0*hash3( pid.x + pid.y*13.1 + float(i) + vec3(0.0,2.0,4.0) );\n            sc.y = sqrt(abs(sc.y));\n            sc = normalize(sc);\n            float ss = 0.7 - 0.1*sin(pid.y + float(i)*13.1);\n            vec4 pp = vec4(-sc,ss);\n            d3 = smax( d3, -dot(vec4(p,1.0),pp), 0.02 );\n        }\n        d3 -= 0.1*sqrt(textureGrad( iChannel2, 0.1*s.zy, 0.1*dsdx.zy, 0.1*dsdy.zy ).x);\n        if( d3<res.x  ) res = vec2(d3,3.0);\n    }    \n#endif\n    \n    return res;\n}\n\nvec3 calcNormal( in vec3 pos, in float eps, float t )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps*t;\n    return normalize( e.xyy*map( pos + e.xyy, t ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, t ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, t ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, t ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, float t )\n{\n\tfloat occ = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        float h = 0.005 + 0.25*float(i)/7.0;\n        vec3 dir = normalize( sin( float(i)*73.4 + vec3(0.0,2.1,4.2) ));//+ gl_FragCoord.x*17.0 + gl_FragCoord.y*13.0 ) );\n        dir = normalize( nor + dir );\n        occ += (h-map( pos + h*dir, t ).x);\n    }\n    return clamp( 1.0 - 9.0*occ/8.0, 0.0, 1.0 );    \n}\n\nfloat calcSSS( in vec3 pos, in vec3 nor, in float t )\n{\n\tfloat occ = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        float h = 0.002 + 0.1*float(i)/7.0;\n        vec3 dir = normalize( sin( float(i)*13.0 + vec3(0.0,2.1,4.2) ) );\n        dir *= sign(dot(dir,nor));\n        \n        occ += (h-map( pos - h*dir, t).x);\n    }\n    occ = clamp( 11.0*occ/8.0, 0.0, 1.0 );    \n    return occ*occ;\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = map(pos, length(pos) ).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n        t += clamp( h, 0.04, 0.1 );\n\t\tif( res<0.01 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n, in float k, in vec3 gx, in vec3 gy )\n{\n    vec3 m = pow( abs( n ), vec3(k) );\n\tvec4 x = textureGrad( sam, p.yz, gx.yz, gy.yz );\n\tvec4 y = textureGrad( sam, p.zx, gx.yz, gy.zx );\n\tvec4 z = textureGrad( sam, p.xy, gx.yz, gy.xy );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\nvec3 sunDir = normalize( vec3(-0.5,0.3,0.4) );\n\nvec3 shade( in vec3 ro, in vec3 rd, in float t, in float m )\n{\n    float eps = 0.0015;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos, eps, t );\n    float kk;\n\n    vec3 mateD = vec3(0.2,0.16,0.11);\n    vec3 mateS = vec3(0.2,0.12,0.07);\n    float mateK = 0.0;\n\n\n    vec3 dpdx = t*drddx;\n    vec3 dpdy = t*drddy;\n    \n    if( m<0.5 )\n    {\n        vec3 onor = nor;\n        vec3 d = pos - vec3(0.0,1.0,0.0);\n        \n        mateD = vec3(0.15,0.15,0.15)*1.1;\n        mateK = 0.2;\n        \n        mateS = vec3(0.4,0.1,0.1)*1.0;\n        mateD *= 0.05 + 2.0*pow(1.0-texcube( iChannel3, pos*0.25, nor, 1.0, dpdx*0.25, dpdy*0.25 ).xyz, vec3(6.0));\n\n        float h = clamp( pos.y, 0.0, 1.0 );\n        vec3 o = 0.12 * sin( h*3.0 + vec3(0.0,2.0,4.0) );\n        o = o*4.0*h*(1.0-h) * h;\n        d = pos - o*vec3(1.0,0.0,1.0);\n        float an = atan(d.x,d.z);\n        vec2 uv1 = vec2( an*8.0, length(d.xz)*2.0  );\n        vec2 uv2 = vec2( an*1.0, d.y*1.0  );\n  \n        // bump\n        float bt = smoothstep( 0.7, 0.9, pos.y );\n        vec3 bn1 = 0.1*(-1.0+2.0*texture( iChannel1, 0.05*uv1 ).xyz);\n        vec3 bn2 = 0.4*(-1.0+2.0*texture( iChannel1, 0.05*uv2 ).xyz);\n        vec3 onn = 0.1*(-1.0+2.0*texcube( iChannel1, pos, nor, 1.0, dpdx, dpdy ).xyz );\n        nor = normalize( nor + mix(bn2,bn1,bt) + onn );\n\n            \n        float isd = smoothstep( 0.5, 0.6, -onor.y );\n        mateD = mix( mateD, vec3(0.25,0.16,0.11), isd );\n\n        mateD = mix( mateD, vec3(0.08,0.08,0.05)*0.2, 0.92*(1.0-smoothstep(0.1,0.5,pos.y)) );\n    }\n\telse if( m<1.5 )\n    {\n        mateD = vec3(0.08,0.08,0.06)*0.55;\n        mateS = vec3(0.0);\n        mateK = 1.0;\n        \n        mateD *= 0.7 + 2.0*texture( iChannel2, pos.xz*0.008, -8.0 ).xyz;\n\n        float ll = smoothstep( 0.2, 0.3, textureGrad(iChannel3,pos.xz*.1, dpdx.xz*0.1, dpdy.xz*0.1).x );\n        ll *= smoothstep(0.5,1.0,nor.y);\n        mateD = mix( mateD, vec3(0.4,0.15,0.15)*0.07, ll);\n    }\n\telse if( m<2.5 )\n    {\n        mateK = 1.0;\n        mateD = vec3(0.11,0.11,0.11);\n        mateS = vec3(0.7,0.3,0.1)*2.0;\n    }\n\telse //if( m<3.5 )\n    {\n        mateS = vec3(0.0,0.0,0.0);\n        mateK = 0.2;\n        \n        mateD = vec3(0.65,0.6,0.45);\n        mateD *= 0.2 + 0.8*texcube( iChannel2, pos*0.07, nor, 1.0, dpdx*0.7, dpdy*0.7 ).x;\n        mateD *= .14;\n    }\n    \n    \n    vec3 hal = normalize( sunDir-rd );\n    float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n    float occ = calcAO( pos, nor, t );\n    float sss = calcSSS( pos, nor, t );\n\n    \n        \n    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );\n    float sha = softshadow( pos, sunDir, 32.0 ); \n    dif1 *= sha;\n    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );\n\n    float bou = clamp( 0.5-0.5*nor.y, 0.0, 1.0 );\n\n    vec3 col = 6.0*vec3(1.6,1.0,0.5)*dif1;//*(0.5+0.5*occ);\n    col += 6.0*pow( spe1, 16.0 )*dif1*mateK;\n    col += 2.0*fre*(0.1+0.9*dif1);//*occ;\n    col += sss*mateS*4.0;\n    col += 4.0*vec3(0.2,0.6,1.3)*occ*(0.5+0.5*nor.y);\n    col += 3.0*vec3(0.2,0.6,1.3)*occ*smoothstep( 0.0, 0.5, reflect( rd, nor ).y )*occ;\n    col += 1.0*vec3(0.2,0.2,0.2)*bou*(0.5+0.5*occ);\n    \n    col *= mateD;\n    \n    t *= 0.5;\n    col = mix( col, vec3(0.3,0.3,.3)*0.4, 1.0-exp( -0.1*t ) );\n    col = mix( col, vec3(0.4,0.5,.6)*0.4, 1.0-exp( -0.001*t*t ) );\n\n    col *= 0.9;\n\n    return col;        \n}\n\nvec2 intersect( in vec3 ro, in vec3 rd, const float maxdist )\n{\n    vec2 res = vec2(-1.0);\n    vec3 resP = vec3(0.0);\n    float t = 0.1;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = map( p, t );\n        res = vec2(t,h.y);\n\n        if( abs(h.x)<(0.001*t) ||  t>maxdist ) break;\n        \n        t += h.x;\n    }\n\treturn res;\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = clamp(vec3(0.2,0.4,0.5) - 0.5*rd.y,0.0,1.0);\n    col *= 0.6;\n    col = mix( col, vec3(0.30,0.25,0.20), pow(1.0-rd.y,16.0) );\n    \n    float maxdist = 32.0;\n    float tp = (1.25-ro.y)/rd.y; if( tp>0.0 ) maxdist = min( maxdist, tp );\n    \n    vec2 tm = intersect( ro, rd, maxdist );\n    if( tm.y>-0.5 && tm.x < maxdist )\n    {\n        col = shade( ro, rd, tm.x, tm.y );\n    }\n\n    //col = clamp( col, 0.0, 1.0 );\n    return pow( col, vec3(0.45) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    vec3 tot = vec3(0.0);\n    #if VIS_SAMPLES<2\n\tint a = 0;\n\t{\n        vec4 rr = vec4(0.0);\n\n        vec2 p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    \tfloat an = 10.0 + 0.2*sin(6.0+0.2*iTime);\n\n        vec3 ro = vec3(0.0,0.5,0.5) + 2.1*vec3(cos(an),0.0,sin(an));\n        vec3 ta = vec3(0.7,0.5,0.0);\n        mat3 ca = setCamera( ro, ta, 0.4 );\n        vec3 rd = normalize( ca * vec3(p,-2.8) );\n        \n    // ray differentials\n    vec2 px = (-iResolution.xy+2.0*(fragCoord.xy+vec2(1.0,0.0)))/iResolution.y;\n    vec2 py = (-iResolution.xy+2.0*(fragCoord.xy+vec2(0.0,1.0)))/iResolution.y;\n    vec3 rdx = normalize( ca * vec3(px,-2.8) );\n    vec3 rdy = normalize( ca * vec3(py,-2.8) );\n    drddx = rdx - rd;\n    drddy = rdy - rd;\n        \n    #else\n\tfor( int a=0; a<VIS_SAMPLES; a++ )\n\t{\n        vec4 rr = textureLod( iChannel1, (iTime*231.73 + fragCoord + 0.5+113.3137*float(a))/iChannelResolution[1].xy, 0.0  ).xzyw;\n\n    \tvec2 p = (-iResolution.xy+2.0*(fragCoord.xy+rr.zw-0.5))/iResolution.y;\n    \tfloat an = 10.0 + 0.2*sin(6.0+0.2*iTime);\n\n        vec3 ro = vec3(0.0,0.5,0.5) + 2.1*vec3(cos(an),0.0,sin(an));\n        vec3 ta = vec3(0.7,0.5,0.0);\n        mat3 ca = setCamera( ro, ta, 0.4 );\n        vec3 rd = normalize( ca * vec3(p,-2.8) );\n\n        // dof\n        vec3 fp = ro + rd * 1.7;\n        ro += (ca[0].xyz*(-1.0+2.0*rr.x) + ca[1].xyz*(-1.0+2.0*rr.w))*0.012;\n        rd = normalize( fp - ro );\n    #endif\n\n        vec3 col = render( ro, rd );\n\n        float sun = clamp( 0.5 + 0.5*dot(rd,sunDir), 0.0, 1.0 );\n        sun = sun*sun;\n        col += vec3(0.5,0.4,0.3)*4.0*sun*sun;\n\n        col = vec3(1.4,1.37,1.35)*col*1.3 - vec3(0.1,0.1,0.06)*2.4;\n\t\ttot += col;\n    }    \n    #if VIS_SAMPLES>1\n\ttot /= float(VIS_SAMPLES);\n    #endif\n        \n    vec2 q = fragCoord.xy/iResolution.xy;\n    tot *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n\n    fragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBXR1.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[756, 756, 778, 778, 848], [850, 850, 872, 872, 930], [932, 932, 977, 977, 1102], [1104, 1104, 1144, 1144, 1180], [1182, 1182, 1236, 1236, 1300], [1302, 1302, 1343, 1343, 1432], [1434, 1434, 1472, 1472, 1597], [1599, 1599, 1640, 1640, 1729], [1731, 1793, 1874, 1874, 2202], [2307, 2307, 2332, 2343, 2685], [2687, 2687, 2713, 2724, 3024], [3027, 3027, 3056, 3071, 6083], [6085, 6085, 6140, 6140, 6359], [6361, 6361, 6412, 6412, 6776], [6778, 6778, 6833, 6833, 7166], [7169, 7169, 7222, 7222, 7525], [7527, 7527, 7616, 7616, 7860], [7910, 7910, 7972, 7972, 11233], [11235, 11235, 11298, 11298, 11596], [11598, 11598, 11637, 11637, 12100], [12102, 12102, 12157, 12157, 12335]], "test": "error"}
{"id": "4tBXzm", "name": "raytracing test0001", "author": "fscur", "description": "raytracing", "tags": ["raytracing"], "likes": 0, "viewed": 87, "published": "Public", "date": "1442350377", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\nstruct Pixel\n{\n    vec3 position;\n    vec3 normal;\n    vec4 color;\n    float reflectivity;\n};\n\nstruct Ray \n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    vec4 color;\n    float reflectivity;\n};\n\nstruct Triangle\n{\n\tvec3 A;\n    vec3 B;\n    vec3 C;\n    vec4 color;\n    float reflectivity;\n};\n    \nstruct Plane\n{\n    vec3 position;\n    vec3 normal;\n};\n    \nstruct DirLight\n{\n    vec3 position;\n    vec3 direction;\n    float intensity;\n    vec4 color;\n};\n    \nstruct PointLight\n{\n    vec3 position;\n    vec4 color;\n    float intensity;\n    float range;\n};\n       \n//ray \n// p = ro + t * rd\n    \n//plane \n// (p . n) - (a . n) = 0\n    \n//sphere\n// (p - c) . (p - c) - r^2 = 0\n\nbool RayPlaneIntersection(in Ray r, in Plane pl, out float t, out vec3 n)\n{\n    float intersect = dot(r.direction, pl.normal);\n    \n    if (intersect == 0.0)\n        return false;\n    \n    t = (dot(pl.position, pl.normal) - dot(r.origin, pl.normal))/intersect;\n    \n    if (t < 0.0)\n        return false;\n    \n    n = pl.normal;\n    \n    return true;\n}   \n    \n    \nbool RayTriangleIntersection(in Ray r, in Triangle tri, out float t, out vec3 n)\n{\n    vec3 normal = normalize(cross(tri.C - tri.A, tri.B - tri.A));\n    \n    float intersect = dot(r.direction, normal);\n    \n    if (intersect == 0.0)\n    \treturn false;\n    \n    t = (dot(tri.A, normal) - dot(r.origin, normal))/intersect;\n    \n    if (t < 0.0)\n        return false;\n    \n    n = normal;\n    \n    vec3 p = r.origin + r.direction * t;\n    \n    float a = p.x - tri.A.x;\n    float b = tri.B.x - tri.A.x;\n    float c = tri.C.x - tri.A.x;\n    \n    float d = p.y - tri.A.y;\n    float e = tri.B.y - tri.A.y;\n    float f = tri.C.y - tri.A.y;\n    \n    float u = ((b * f) - (e * c));\n    \n    if (u == 0.0)\n    {\n    \ta = p.x - tri.A.x;\n        b = tri.B.x - tri.A.x;\n        c = tri.C.x - tri.A.x;\n\n        d = p.z - tri.A.z;\n        e = tri.B.z - tri.A.z;\n        f = tri.C.z - tri.A.z;\n        \n        u = ((b * f) - (e * c));\n    }\n    \n    float beta = ((a * f) - (d * c)) / u;\n    float gamma;\n    \n    if (f == 0.0)\n        gamma = (a - (beta * b)) / c;\n    else\n        gamma = (d - (beta * e)) / f;\n    \n    float alpha = 1.0 - beta - gamma;\n    \n    if (alpha >= 0.0 && alpha <= 1.0 &&\n        beta >= 0.0 && beta <= 1.0 &&\n    \tgamma >= 0.0 && gamma <= 1.0)\n        return true;\n    \n    return false;\n}   \n   \nbool RaySphereIntersection(in Ray r, in Sphere s, out float t, out vec3 n)\n{ \n    //t^2 ( P1 . P1) + 2t (P1 . (P0-C)) + ((P0 - c) . (P0 - c)) - r^2 = 0\n    // -b +- sqrt(b^2-4.a.c) / 2.a\n    \n    vec3 p0 = r.origin;\n    vec3 p1 = r.direction;\n    vec3 p2 = p0 - s.center;\n    float r2 = s.radius * s.radius;\n    \n    float a = dot(p1, p1);\n    float b = 2.0 * dot(p1, p2);\n    float c = dot(p2, p2) - r2;\n    \n    float delta = pow(b, 2.0) - 4.0 * a * c;\n    \n    if (delta < 0.0)\n        return false;\n    \n    float deltaSqr = sqrt(delta); \n    \n    float t0 = (-b + deltaSqr) / (2.0 * a);\n    float t1 = (-b - deltaSqr) / (2.0 * a);\n    \n    if (t1 > t0)\n        t = t0;\n    else\n        t = t1;\n    \n    if (t < 0.0)\n        return false;\n    \n    vec3 p = p0 + p1 * t;\n    n = normalize(p - s.center);\n    \n    return true;\n}\n\nvec4 CalcDirLight(DirLight light, Pixel pixel)\n{\n    float diffuse = clamp(dot(-light.direction, pixel.normal), 0.0, 1.0) * light.intensity;\n    return light.color * pixel.color * diffuse;\n}\n\nvec4 CalcPointLight(PointLight light, Pixel pixel)\n{\n    float oneOverRangeSqr = 1.0 / pow(light.range, 2.0);\n    vec3 lightDir = pixel.position - light.position;\n    float distanceToPoint = length(lightDir);\n    float attenuation = 1.0 - pow(distanceToPoint, 2.0) * oneOverRangeSqr;\n    \n    lightDir = normalize(lightDir);\n    \n    float diffuse = clamp(dot(-lightDir, pixel.normal), 0.0, 1.0) * light.intensity;\n    return light.color * pixel.color * diffuse * clamp(attenuation, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect; \n    \n    float near = 2.0;\n    float far = 5.0;\n    vec3 camRight = vec3(1.0, 0.0, 0.0);\n    vec3 camUp    = vec3(0.0, 1.0, 0.0);\n    vec3 camDir   = vec3(0.0, 0.0, 1.0);\n    vec3 camPos   = vec3(0.0, 4.0, 15.5);\n    \n    camPos = vec3(sin(time) * 20.0, 5.0, cos(time) * 20.0); \n     \n    vec3 eye = camPos;\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    \n    camDir = normalize(target - eye);\n    camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camDir));\n    camUp = normalize(cross(camDir, camRight));\n    camRight = normalize(cross(camUp, camDir));\n    \n    mat4 rotationMatrix = mat4\n        (camRight.x, camRight.y, camRight.z, 0.0,\n         camUp.x, camUp.y, camUp.z, 0.0,\n         camDir.x, camDir.y, camDir.z, 0.0,\n         0.0, 0.0, 0.0, 1.0); \n    \n    mat4 translationMatrix = mat4\n        (1.0, 0.0, 0.0, -camPos.x,\n         0.0, 1.0, 0.0, -camPos.y,\n         0.0, 0.0, 1.0, -camPos.z,\n         0.0, 0.0, 0.0, 1.0); \n    \n    mat4 viewMatrix = rotationMatrix * translationMatrix;\n    \n    vec4 rayEnd = viewMatrix * vec4(uv, near, 1.0);\n    \n    Ray r;\n    r.origin = camPos.xyz;\n    r.direction = rayEnd.xyz;\n    \n    \n    Plane pl;\n    pl.position = vec3(0.0);\n    pl.normal = vec3(0.0, 1.0, 0.0);\n    \n    Sphere spheres[2];\n    \n    spheres[0].center = vec3(-1.5, 1.0, 0.0);\n    spheres[0].radius = 1.0;\n    spheres[0].color = vec4(0.1, 0.1, 0.1, 1.0);\n    spheres[0].reflectivity = 0.0;\n    \n    spheres[1].center = vec3(1.5, 1.0, 0.0);\n    spheres[1].radius = 1.0;\n    spheres[1].color = vec4(1.0, 0.0, 0.0, 1.0);\n    spheres[1].reflectivity = 0.0;\n    \n    vec4 color = vec4(0.0);\n    \n    DirLight dirLight;\n    dirLight.position = vec3(1.0, 1.0, -1.0);\n    dirLight.direction = -normalize(dirLight.position);\n    dirLight.color = vec4(1.0);\n    dirLight.intensity = 1.0;\n    \n    PointLight pointLight;\n    pointLight.position = vec3(sin(time) * 3.0, 3.0, cos(time) * 3.0);\n    //pointLight.position = vec3(3.0, 3.0, 0.0);\n    \n    pointLight.color = vec4(1.0);\n    pointLight.intensity = 1.0;\n    pointLight.range = 5.0;\n    \n    float t = 10000.0;\n    float t1 = 10000.0;\n    float ref = 0.0;\n    vec3 n1;\n    vec3 n;\n    \n    Triangle triangles[4];\n    triangles[0].A = vec3(-5.0, 0.0, -5.0);\n    triangles[0].B = vec3(5.0, 0.0, -5.0);\n    triangles[0].C = vec3(5.0, 0.0, 5.0);\n    triangles[0].color = vec4(0.0, 1.0, 1.0, 1.0);\n    triangles[0].reflectivity = 0.0;\n    \n    triangles[1].A = vec3(5.0, 0.0, 5.0);\n    triangles[1].B = vec3(-5.0, 0.0, 5.0);\n    triangles[1].C = vec3(-5.0, 0.0, -5.0);\n    triangles[1].color = vec4(1.0, 1.0, 0.0, 1.0);\n    triangles[1].reflectivity = 0.0;\n    \n    triangles[2].A = vec3(-5.0, 0.0, 5.0);\n    triangles[2].B = vec3(5.0, 0.0, 5.0);\n    triangles[2].C = vec3(5.0, 5.0, 5.0);\n    triangles[2].color = vec4(1.0, 1.0, 1.0, 1.0);\n    triangles[2].reflectivity = 1.0;\n    \n    triangles[3].A = vec3(5.0, 5.0, 5.0);\n    triangles[3].B = vec3(-5.0, 5.0, 5.0);\n    triangles[3].C = vec3(-5.0, 0.0, 5.0);\n    triangles[3].color = vec4(1.0, 1.0, 1.0, 1.0);\n    triangles[3].reflectivity = 1.0;\n    \n    for(int i = 0; i < 4; i++)\n    {\n        Triangle tri = triangles[i];\n        float st = 1000.0;\n        vec3 sn;\n        \n        if (RayTriangleIntersection(r, tri, st, sn))\n        {\n            if (st < t)\n            {\n                t = st;\n                n = sn;\n                color = tri.color;\n                ref = tri.reflectivity;\n            }\n        }\n    }\n    \n    /*\n    if (RayPlaneIntersection(r, pl, t1, n1))\n    {\n        if (t1 < t)\n        {\n            t = t1;\n            n = n1;\n            color = vec4(0.0, 1.0, 0.0, 1.0);\n        }\n    }\n    */\n    \n    for(int i = 0; i < 2; i++)\n    {\n        Sphere s = spheres[i];\n        float st = 1000.0;\n        vec3 sn;\n        \n        if (RaySphereIntersection(r, s, st, sn))\n        {\n            if (st < t)\n            {\n                t = st;\n                n = sn;\n                color = s.color;\n                ref = s.reflectivity;\n            }\n        }\n    }\n    \n    Pixel pixel;\n    pixel.position = r.origin + t * r.direction;\n    pixel.normal = n;\n    pixel.reflectivity = ref;\n    \n    float shadowFactor = 1.0;\n    \n    \n    \n    \n    if (t < 10000.0);\n    {\n        t = 10000.0;\n        n = vec3(0.0);\n        \n        vec3 lightPixel = pointLight.position - pixel.position;\n        float lightPixelDist = length(lightPixel);\n        Ray r2;\n        r2.origin = pixel.position;\n        r2.direction = normalize(lightPixel);\n        r2.origin += r2.direction * 0.001;\n            \n        for(int i = 0; i < 4; i++)\n        {\n            Triangle tri = triangles[i];\n            float st = 1000.0;\n            vec3 sn;\n\n            if (RayTriangleIntersection(r2, tri, st, sn))\n            {\n                if (st < t)\n                {\n                    shadowFactor = 0.0;\n                }\n            }\n        }\n        \n        /*\n        if (RayPlaneIntersection(r, pl, t1, n1))\n        {\n            if (t1 < t)\n            {\n                shadowFactor = 0.0;\n            }\n        }\n*/\n        for(int i = 0; i < 2; i++)\n        {\n            Sphere s = spheres[i];\n            float st = 1000.0;\n            vec3 sn;\n\n            if (RaySphereIntersection(r2, s, st, sn))\n            {\n                if (st < t)\n                {\n                    shadowFactor = 0.0;\n                }\n            }\n        }\n        \n        if (pixel.reflectivity > 0.0)\n        {\n            Ray r3;\n            r3.origin = pixel.position;\n            r3.direction = reflect(r.direction, pixel.normal);\n            r3.origin += r3.direction * 0.001;\n\n            for(int i = 0; i < 4; i++)\n            {\n                Triangle tri = triangles[i];\n                float st = 1000.0;\n                vec3 sn;\n\n                if (RayTriangleIntersection(r3, tri, st, sn))\n                {\n                    if (st < t)\n                    {\n                        t = st;\n                        n = sn;\n                        color = tri.color * pixel.reflectivity;\n                    }\n                }\n            }\n\n            /*\n            if (RayPlaneIntersection(r, pl, t1, n1))\n            {\n                if (t1 < t)\n                {\n                    shadowFactor = 0.0;\n                }\n            }\n    */\n            for(int i = 0; i < 2; i++)\n            {\n                Sphere s = spheres[i];\n                float st = 1000.0;\n                vec3 sn;\n\n                if (RaySphereIntersection(r3, s, st, sn))\n                {\n                    if (st < t)\n                    {\n                        t = st;\n                        n = sn;\n                        color = mix(color, s.color, pixel.reflectivity);\n                    }\n                }\n            }\n            \n            //pixel.position = r.origin + t * r.direction;\n    \t\t//pixel.normal = n;\n    \t\t//pixel.reflectivity = ref;\n        }\n    }\n    \n    \n    pixel.color = color;\n    vec4 ambientLightTerm = color * 0.2;\n    vec4 dirLightTerm = CalcDirLight(dirLight, pixel);\n    vec4 pointLightTerm = CalcPointLight(pointLight, pixel);\n    fragColor = ambientLightTerm + (dirLightTerm + pointLightTerm) * shadowFactor;\n    \n    //fragColor = dirLightTerm;\n    //fragColor = pointLightTerm;\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBXzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[740, 740, 815, 815, 1092], [1106, 1106, 1188, 1188, 2409], [2417, 2417, 2493, 2603, 3247], [3249, 3249, 3297, 3297, 3439], [3441, 3441, 3493, 3493, 3936], [3938, 3938, 3995, 3995, 11389]], "test": "valid"}
{"id": "4tjSDR", "name": "Black & white noise", "author": "davidm", "description": "3D perlin noise", "tags": ["noise"], "likes": 2, "viewed": 296, "published": "Public API", "date": "1442871772", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 rand(vec2 co){\n    return texture(iChannel0, co).rg;\n    float x=fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    float y=fract(sin(dot(co.xy+vec2(3223.21323,-3323.312323) ,vec2(12.9898,78.233))) * 43758.5453);\n    return vec2(x,y);\n}\n\nvec3 hash( vec3 p ){\n\tp = vec3( dot(p,vec3(127.1,311.7, 234.6)),\n\t\t\t  dot(p,vec3(269.5,183.3,198.3)),\n              dot(p,vec3(169.5,283.3,156.9)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat blend(float x){\n\tfloat x2=x*x;\n\tfloat x3=x*x2;\n\treturn 6.*x3*x2-15.*x2*x2+10.*x3;\n}\n\nfloat fnoisePerlin(float amp, float freq, float x, float y, float z){\n\tx=x*freq;\n\ty=y*freq;\n\tfloat fx=floor(x);\n\tfloat fy=floor(y);\n\tfloat fz=floor(z);\n\tfloat cx=ceil(x);\n\tfloat cy=ceil(y);\n\tfloat cz=ceil(z);\n    \n\tvec3 v000=hash(vec3(fx, fy, fz));\n\tvec3 v100=hash(vec3(cx, fy, fz));\n\tvec3 v010=hash(vec3(fx, cy, fz));\n\tvec3 v110=hash(vec3(cx, cy, fz));\n\tvec3 v001=hash(vec3(fx, fy, cz));\n\tvec3 v101=hash(vec3(cx, fy, cz));\n\tvec3 v011=hash(vec3(fx, cy, cz));\n\tvec3 v111=hash(vec3(cx, cy, cz));\n\n    \n\tfloat a000=dot(v000, vec3(x-fx,y-fy, z-fz));\n\tfloat a100=dot(v100, vec3(x-cx,y-fy, z-fz));\n\tfloat a010=dot(v010, vec3(x-fx,y-cy, z-fz));\n\tfloat a110=dot(v110, vec3(x-cx,y-cy, z-fz));\n\t\n    float a001=dot(v001, vec3(x-fx,y-fy, z-cz));\n\tfloat a101=dot(v101, vec3(x-cx,y-fy, z-cz));\n\tfloat a011=dot(v011, vec3(x-fx,y-cy, z-cz));\n\tfloat a111=dot(v111, vec3(x-cx,y-cy, z-cz));\n    \n    \n    float mx=blend(x-fx);\n    float my=blend(y-fy);\n    float mz=blend(z-fz);\n    \n    \n    float ix00=mix(a000, a100, mx);\n    float ix10=mix(a010, a110, mx);\n    float ix01=mix(a001, a101, mx);\n    float ix11=mix(a011, a111, mx);\n    \n    float iy0=mix(ix00,ix10, my);\n    float iy1=mix(ix01,ix11, my);\n    \n    float iz=mix(iy0, iy1, mz);\n    \n    \n    /*\n\tfloat sx=blend(x-fx);\n\tfloat a=s+sx*(t-s);\n\tfloat b=u+sx*(v-u);\n\n\tfloat sy=blend(y-fy);\n\n\tfloat r=a+sy*(b-a);*/\n    \n\treturn (amp*iz);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    float f=0.5;\n    float freq=0.027;\n    float amp=0.5;\n    for (float i=0.; i<14.; i+=1.0){\n    \tf+=(fnoisePerlin(amp, freq, uv.x,uv.y, iTime));\n        amp*=0.5;\n        freq*=2.0;\n    }\n    vec2 p=vec2(gl_FragCoord.xy-iResolution.xy*0.5)/iResolution.x*2.0;\n    float l=length(p);\n    f=clamp(f, 0.,1.);\n    f=mix(f,0., blend(clamp(l*5.-0.15,0.,1000000000.)));\n    f=mix(0., f, blend(clamp(l*5.-0.15, 0., 1.)));\n    if (l<0.15){\n       // f=1.;\n    }\n    f=pow(f*4.3, 2.);\n\tfragColor = vec4(vec3(f),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjSDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 20, 20, 254], [256, 256, 276, 276, 455], [457, 457, 478, 478, 546], [548, 548, 617, 617, 1927], [1929, 1929, 1986, 1986, 2522]], "test": "error"}
{"id": "4tjSR1", "name": "Google' New Logo", "author": "tatsunoru", "description": "Google' New Logo", "tags": ["googlelogo"], "likes": 8, "viewed": 308, "published": "Public", "date": "1441627534", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 pixpos;\nvec4 background;\n\nvec2 rotate(vec2 v, float degree){\n    float c = cos(degree/180.0*3.415);\n    float s = sin(degree/180.0*3.415);\n\treturn vec2(v.x*c - v.y*s, v.x*s + v.y*c);\n}\n\nfloat box(vec2 pos, vec2 size){\n    size -= vec2(0.01);\n    vec2 q = abs(pos - pixpos);\n    return length(max(q - size, 0.0)) - 0.01;\n}\n\nfloat boxrot(vec2 pos, vec2 size, float r){\n    size -= vec2(0.01);\n    vec2 q = abs(rotate(pos - pixpos, r));\n    return length(max(q - size, 0.0)) - 0.01;\n}\n\n\nfloat sphere(vec2 pos, float radius){\n    return length(pos - pixpos) - radius;\n}\n\nfloat add(float a, float b){\n    return min(a, b);\n}\n\nfloat subtract(float a, float b){\n    return max(a, -b);\n}\n\nvec4 select(float a, vec4 inner, vec4 outer){\n    //return a > 0.0 ? outer : inner;\n    return mix(inner, outer, smoothstep(0.0, 0.01, a));\n}\n    \nvec4 select(float a, vec4 inner){\n    return select(a, inner, vec4(0, 0, 0, 0));\n}\n\nvec2 supershapes(vec4 n, float phi){\n\tfloat m = n.x * phi * 0.25;\n\tfloat t1 = pow(abs(cos(m)), n.z);\n\tfloat t2 = pow(abs(sin(m)), n.w);\n\tfloat radius = 1.0 / pow(t1 + t2, 1.0 / n.y);\n\treturn vec2(cos(phi), sin(phi)) * radius;\n}\n\nvec2 gbase;\n\nvec4 G(){\n    vec2 base = vec2(0.1, 0.5) + gbase;\n    \n    float gcircle = sphere(base, 0.5);\n    float ginnercircle = sphere(base, 0.4);\n    float gbox = box(base+vec2(0.25, 0.0), vec2(0.24, 0.05));\n    float grotbox = boxrot(base+vec2(0.37, 0.2), vec2(0.2, 0.2), -40.0);\n\n    float g = gcircle;\n    g = subtract(g, ginnercircle);\n    g = subtract(g, grotbox);\n    g = add(g, gbox);\n\treturn select(g, vec4(0.3, 0.5, 1, 1));\t\n}\n\nvec4 o(){\n    vec2 base = vec2(1.0, 0.3) + gbase;\n    \n    float circle = sphere(base, 0.3);\n    float innercircle = sphere(base, 0.2);\n \n    float g = circle;\n    g = subtract(g, innercircle);\n\treturn select(g, vec4(1, 0.2, 0.0, 1));\t\n}\n\nvec4 o2(){\n    vec2 base = vec2(1.7, 0.3) + gbase;\n    \n    float circle = sphere(base, 0.3);\n    float innercircle = sphere(base, 0.2);\n \n    float g = circle;\n    g = subtract(g, innercircle);\n\treturn select(g, vec4(0.9, 1.0, 0.0, 1));\t\n}\n\nvec4 g(){\n    vec2 base = vec2(2.4, 0.3) + gbase;\n    \n    float circle = sphere(base, 0.3);\n    float innercircle = sphere(base, 0.2);\n    float rbox = box(base+vec2(0.25, 0.0), vec2(0.05, 0.3));\n    \n    float circle2 = sphere(base+vec2(0, -0.3), 0.3);\n    float innercircle2 = sphere(base+vec2(0, -0.3), 0.2);\n    \n    float vbox = boxrot(base+vec2(-0.2, -0.2), vec2(0.2, 0.6), 60.0);\n \n    float g = circle;\n    g = subtract(g, innercircle);\n    g = add(g, rbox);\n    g = add(g, subtract(subtract(circle2, innercircle2), vbox));\n\treturn select(g, vec4(0.3, 0.5, 1, 1));\t\n}\n\nvec4 l(){\n    vec2 base = vec2(2.9, 0.45) + gbase;\n    \n    float lbox = box(base, vec2(0.05, 0.4));\n\n    float g = lbox;\n\treturn select(g, vec4(0.4, 1.0, 0.0, 1));\t\n}\n\nvec4 e(){\n    vec2 base = vec2(3.4, 0.3) + gbase;\n    \n    float circle = sphere(base, 0.3);\n    float innercircle = sphere(base, 0.2);\n    \n    float nbox = boxrot(base+vec2(0.012, 0.0), vec2(0.287, 0.05), -15.0);\n    float sbox = boxrot(base+vec2(0.29, -0.07), vec2(0.15, 0.13), 30.0);\n \n    float g = circle;\n    g = subtract(g, innercircle);\n    g = subtract(g, sbox);    \n    g = add(g, nbox);\n\treturn select(g, vec4(1, 0.2, 0.0, 1));\t\n}\n\nvec4 bg(vec2 fragCoord )\n{\n    gbase = vec2(1, 0);\n    pixpos = fragCoord.xy / iResolution.yy;\n    pixpos -= vec2(1.0, 0.2);\n    pixpos = supershapes(vec4(length(pixpos)*10.0, 1, 1, 1), atan(pixpos.y, pixpos.x)) + (fragCoord.xy / iResolution.yy) * 1.0;\n    pixpos = pixpos * (9.0 + sin(iTime)*4.0) - vec2(0.5, 0.5);\n    pixpos = mod(pixpos, vec2(5.0, 2.0));\n\treturn G() + o() + o2() + g() + l() + e();\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gbase = vec2(1, 0);\n    pixpos = (fragCoord.xy / iResolution.yy) * 1.5 + vec2(0.0, -0.3);\n    pixpos -= vec2(sin(iTime*0.5)*3.0, 0.0);\n\tfragColor = G() + o() + o2() + g() + l() + e() + bg(fragCoord);\n}\n\n    \n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjSR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 66, 66, 190], [192, 192, 223, 223, 327], [329, 329, 372, 372, 487], [490, 490, 527, 527, 571], [573, 573, 601, 601, 625], [627, 627, 660, 660, 685], [687, 687, 732, 770, 828], [834, 834, 867, 867, 916], [918, 918, 954, 954, 1145], [1160, 1160, 1169, 1169, 1587], [1589, 1589, 1598, 1598, 1826], [1828, 1828, 1838, 1838, 2068], [2070, 2070, 2079, 2079, 2646], [2648, 2648, 2657, 2657, 2815], [2817, 2817, 2826, 2826, 3259], [3261, 3261, 3287, 3287, 3664], [3666, 3666, 3723, 3723, 3929]], "test": "valid"}
{"id": "4tjSWh", "name": "Basic Radial Gradient", "author": "capitanNeptune", "description": "basic radial gradient with motion", "tags": ["radial", "gradient"], "likes": 16, "viewed": 3948, "published": "Public API", "date": "1443285049", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dist(vec2 p0, vec2 pf){return sqrt((pf.x-p0.x)*(pf.x-p0.x)+(pf.y-p0.y)*(pf.y-p0.y));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //mouse controlled version\n    //float d = dist(iResolution.xy*0.5,fragCoord.xy)*(iMouse.x/iResolution.x+0.1)*0.01;\n    \n    //automatic version\n    float d = dist(iResolution.xy*0.5,fragCoord.xy)*(sin(iTime)+1.5)*0.003;\n\tfragColor = mix(vec4(1.0, 1.0, 1.0, 1.0), vec4(0.0, 0.0, 0.0, 1.0), d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjSWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 91], [93, 93, 150, 299, 450]], "test": "valid"}
{"id": "4tjSzw", "name": "Zooming Mandelbrot", "author": "roombarampage", "description": "Sucks not having modulus...", "tags": ["fractal", "mandelbrot", "ramp", "zooming"], "likes": 4, "viewed": 173, "published": "Public", "date": "1442471068", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n  programmer: jonathan potter\n  github: https://github.com/jonathan-potter\n  repo: https://github.com/jonathan-potter/shadertoy-fractal\n*/\n\nconst int MAX_ITERATIONS = 512;\nconst float pi = 3.14159;\n\nstruct complex { \n  float real;\n  float imaginary;\n};\n    \nfloat modulus(float number, float divisor) {\n  float integerQuotient = floor(number / divisor);\n    \n  return number - (integerQuotient * divisor);\n}\n\nfloat rampFunction(float t) {\n  float animationPeriod = 5.0;\n    \n  return modulus(t, animationPeriod);\n}\n\nint fractal(complex c, complex z) {\n  for (int iteration = 0; iteration < MAX_ITERATIONS; iteration++) {\n\n    // z <- z^2 + c\n    float real = z.real * z.real - z.imaginary * z.imaginary + c.real;\n    float imaginary = 2.0 * z.real * z.imaginary + c.imaginary;\n\n    z.real = real;\n    z.imaginary = imaginary;\n\n    if (z.real * z.real + z.imaginary * z.imaginary > 4.0) {\n      return iteration;\n    }\n  }\n\n  return 0;\n}\n\nint mandelbrot(vec2 coordinate) {\n  complex c = complex(coordinate.x, coordinate.y);\n  complex z = complex(0.0, 0.0);\n\n  return fractal(c, z);\n}\n\nvec2 fragCoordToXY(vec2 fragCoord) {\n  vec2 relativePosition = fragCoord.xy / iResolution.xy;\n  float aspectRatio = iResolution.x / iResolution.y;\n\n  vec2 cartesianPosition = (relativePosition - 0.5) * 10.0;\n  cartesianPosition.x *= aspectRatio;\n    \n  float zoomLevel = pow(1.3, 10.0 * rampFunction(iTime));\n  cartesianPosition.x /= zoomLevel;\n  cartesianPosition.y /= zoomLevel;\n    \n  cartesianPosition.x += -0.22614245999608962;\n  cartesianPosition.y += 0.8115717941462461;\n\n  return cartesianPosition;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 coordinate = fragCoordToXY(fragCoord);\n\n  int crossoverIteration = mandelbrot(coordinate);\n    \n  float color = 1.0 * float(crossoverIteration) / float(MAX_ITERATIONS);\n\n  fragColor = vec4(color, color, color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjSzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 261, 305, 305, 410], [412, 412, 441, 441, 517], [519, 519, 554, 554, 939], [941, 941, 974, 974, 1085], [1087, 1087, 1123, 1123, 1595], [1597, 1597, 1654, 1654, 1879]], "test": "valid"}
{"id": "4tjXRW", "name": "Ribbon thing", "author": "lycium", "description": "Random radial symmetry thing", "tags": ["radial", "symmetry"], "likes": 3, "viewed": 181, "published": "Public", "date": "1441989767", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 ribbonthing(vec2 p)\n{\n\tfloat radius = length(p);\n\tfloat angle  = atan(p.y, p.x);\n\n\tfloat lobe_scale = sin(angle * 4.0) * 0.5 + 1.0;\n\n\tfloat lobes = 7.0;\n\tfloat a_k  = angle * lobes;\n\tfloat k    = sin(a_k + iTime) * lobe_scale * 0.1 + 0.2;\n\tfloat dkda = cos(a_k + iTime) * lobe_scale * 0.1 * lobes;\n\n    float s0 = 1.0 + dkda * dkda;\n\tfloat s  = s0 * s0 * s0;\n    float t0 = 0.01  * s;\n    float t1 = 0.007 * s;\n\n    vec3 f  = vec3(0.6,  0.9,   0.4);\n    vec3 b0 = vec3(0.7,  0.035, 0.3) * 1.1;\n    vec3 b1 = vec3(0.65, 0.05, 0.01) * 1.8;\n    vec3 b  = b0 * (1.0 - p.y) + b1 * p.y;\n    \n    float falloff = -1024.0;\n    float d = (radius - k) / (radius + 0.25);\n    float g = exp(d * d * falloff) * 0.5 + 1.0;\n    \n    return\t (radius > k - t0 && radius < k + t0) ?\n\t\t\t((radius > k - t1 && radius < k + t1) ? f * g : vec3(0.0)) : b * g;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat aspect = iResolution.y / iResolution.x;\n\tvec2 pixel_scale = vec2(1.0 / iResolution.x, aspect / iResolution.y) * 1.35;\n\n   \tvec3 s = vec3(0.0);\n    const float samples = 21.0;\n    const float norm = 1.0 / samples;\n\tfor (float z = 0.0; z < samples; z += 1.0)\n    {\n\t\tfloat a = z * norm * 13.0 * 6.283185307179586476925286766559;\n        float r = sqrt(z * norm) * 1.125;\n        vec2 aa = vec2(cos(a), sin(a)) * r;\n\n\t\ts += ribbonthing((fragCoord - iResolution.xy * 0.5 + aa) * pixel_scale);\n    }\n    s *= norm;\n\n    float r = pow(s.r, 1.0 / 2.2);\n\tfloat g = pow(s.g, 1.0 / 2.2);\n\tfloat b = pow(s.b, 1.0 / 2.2);\n    fragColor = vec4(r, g, b, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjXRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 842], [845, 845, 900, 900, 1555]], "test": "valid"}
{"id": "4tjXzh", "name": "MyFristShader", "author": "xdlmost", "description": "It is a Demo for beginner in shader like me .", "tags": ["beginner"], "likes": 1, "viewed": 124, "published": "Public", "date": "1441609355", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float sx=iResolution.x/iResolution.y;\n    vec2 s;\n    \n    uv.y=uv.y/sx;\n    \n    \n    //follow the mouse\n    //s=iMouse.xy/iResolution.xy;\n    \n    //animation\n    //s.x=abs(sin(iTime));\n    //s.y=abs(sin(iTime));\n    \n    //fixed position\n    s.x=0.5;\n    s.y=0.3;\n    \n    if(length(uv-s)<0.2){\n        fragColor = vec4(uv,abs(sin(iTime)),1.0);\n    }else if(length(uv-s)<0.25){\n        fragColor = vec4(1.0-uv.x,1.0-uv.y,abs(sin(iTime)),1.0);\n    }else{\n        fragColor = vec4(0,0,0,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjXzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 605]], "test": "valid"}
{"id": "4tjXzW", "name": "OffTheGrid", "author": "Passion", "description": "Using the '2d Fast Clouds' from Sinuousity again for a skybox. And the sun from 'Kepler 256o' from otaviogood.", "tags": ["raymarch", "fbm", "walkingsim"], "likes": 11, "viewed": 484, "published": "Public", "date": "1442011122", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float EPS = 0.001;\n\nconst float pi = 3.14159265359;\n\n//2d Fast Clouds const\n//SETTINGS//\nconst float timeScale = 10.0;\nconst float cloudScale = 0.5;\nconst float skyCover = 0.6; //overwritten by mouse x drag\nconst float softness = 0.2;\nconst float brightness = 1.0;\nconst int noiseOctaves = 8;\nconst float curlStrain = 3.0;\n//SETTINGS//\n\nmat3 ry (float radian){ \n    return mat3(cos(radian), 0.0,-sin(radian),\n\t\t\t   0.0, 1.0, 0.0, \n\t\t\t   sin(radian), 0.0, cos(radian)  );\n        }\n       \nmat3 rx (float radian){\n    return mat3(1.0, 0.0, 0.0,\n\t\t\t   0.0, cos(radian), sin(radian), \n\t\t\t   0.0,-sin(radian), cos(radian) );\n\t\t}\n//Random function\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n//Noise function\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n//Fbm function\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 1.0;\n\tfor (int i = 0; i < 8; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn += n;\n\t\tamplitude *= 0.5;\n\t}\n\treturn total;\n}\n\n\nfloat distanceFunction(vec3 p){\n    vec4 n = vec4(0.0,1.0,0.0,1.0); \n    float disp;\n    disp = .3*sin(1.4*p.x+cos(p.z*1.3))-(1.0-abs(sin(p.x+cos(p.z+fbm(p.zx)))))*.4;\n    float plane = dot(p,n.xyz) + n.w;\n \n    return (plane+disp);\n}\n\nvec3 getNormal(vec3 p){\n    const float d = EPS;\n    return\n    normalize\n    (\n      vec3\n      (\n        distanceFunction(p+vec3(d,0.0,0.0))-distanceFunction(p+vec3(-d,0.0,0.0)),\n        distanceFunction(p+vec3(0.0,d,0.0))-distanceFunction(p+vec3(0.0,-d,0.0)),\n        distanceFunction(p+vec3(0.0,0.0,d))-distanceFunction(p+vec3(0.0,0.0,-d))\n      )\n    );\n}\n \nfloat saturate(float num)\n{\n    return clamp(num,0.0,1.0);\n}\n\nfloat noised(vec2 uv)\n{\n    return texture(iChannel2,uv).r;\n}\n\nvec2 rotate(vec2 uv)\n{\n    uv = uv + noised(uv*0.2)*0.005;\n    float rot = curlStrain;\n    float sinRot=sin(rot);\n    float cosRot=cos(rot);\n    mat2 rotMat = mat2(cosRot,-sinRot,sinRot,cosRot);\n    return uv * rotMat;\n}\n\nfloat fbm2 (vec2 uv)\n{\n    float rot = 1.57;\n    float sinRot=sin(rot);\n    float cosRot=cos(rot);\n    float f = 0.0;\n    float total = 0.0;\n    float mul = 0.5;\n    mat2 rotMat = mat2(cosRot,-sinRot,sinRot,cosRot);\n    \n    for(int i = 0;i < noiseOctaves;i++)\n    {\n        f += noised(uv+iTime*0.00015*timeScale*(1.0-mul))*mul;\n        total += mul;\n        uv *= 3.0;\n        uv=rotate(uv);\n        mul *= 0.5;\n    }\n    return f/total;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 pos = (fragCoord.xy*2.0 -iResolution.xy) / iResolution.y;\n    vec3 bg = vec3(0.0);//mix(vec3(0.24,0.24,.9),vec3(1.5),.3);  \n\n    float time = iTime*.3;\n    vec3 camPos = vec3(0.0, -.25, 11.0)*ry(time*.15);\n    camPos.y=-distanceFunction(camPos);\n    //Camera set-up\n    vec3 camDir = vec3(.3, 0.05, -1.0);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    vec3 camSide = cross(camDir, camUp);\n    float focus = 1.8;\n    vec3 col = vec3(0.0);\n    vec3 rayDir = normalize(camSide*pos.x + camUp*pos.y + camDir*focus)*ry(iMouse.x/51.)*ry(time*.15-1.25);\n\n    float t = 0.0, d;\n    vec3 posOnRay = camPos;\n \t//Raymarching\n    for(int i=0; i<48; ++i){\n        d = distanceFunction(posOnRay);\n        t += d;\n        posOnRay = camPos + t*rayDir;\n        if(d < EPS) break;\n    }\n    \n    vec4 tex = texture(iChannel0,posOnRay.xz*.25);\n    vec3 l = normalize(vec3(0.0,10.,-20.)*ry(time));\n    vec3 normal = getNormal(posOnRay);\n    \n    //sun-sunIntensity from 'Kepler 256o'\n    //https://www.shadertoy.com/view/XsjGRd - otaviogood\n    vec3 localRay = normalize(rayDir);\n    float sunIntensity = 1.0 - (dot(localRay, l) * 0.5 + 0.5);\n    //sunIntensity = (float)Math.Pow(sunIntensity, 14.0);\n    sunIntensity = 0.2 / sunIntensity;\n    sunIntensity = min(sunIntensity, 40000.0);\n    sunIntensity = max(0.0, sunIntensity - 3.0);\n    //////////////////////////////////////////////////\n    vec2 screenUv = fragCoord.xy/iResolution.xy;\n    vec2 uv2 = fragCoord.xy/(40000.0*cloudScale);\n    \n    float mouseXAffect = (iMouse.x/iResolution.x);\n    float weatherVariation = clamp(sin(time)*.5,-0.5,-0.05);\n    float cover = 0.5-weatherVariation;\n    \n    float bright = brightness*(1.8-cover);\n    //cloud coverage from '2d Fast Clouds' \n    //https://www.shadertoy.com/view/XsjSRt - Sinuousity\n    \n    //perspective correction from Dave Hoskins 'Mountains' GetColor function\n    ////////////////\n    vec3 rd = rayDir; rd.y = max(rd.y, 0.0001);\n\tfloat v = (7.5-camPos.y)/rd.y; \n\trd.xz *= v;\n\trd.xz += camPos.xz;\n\trd.xz *= .010;\n    ////////////////\n    \n    //float color1 = fbm2((rayDir.yz*.05)-0.5+iTime*0.00004*timeScale);  //xz\n    //float color2 = fbm2((rayDir.zy*.05)-10.5+iTime*0.00002*timeScale); //yz\n    float color1 = fbm2((rd.xz*.05)-0.5+iTime*0.00004*timeScale);  //xz\n    float color2 = fbm2((rd.zx*.05)-10.5+iTime*0.00002*timeScale); //yz\n    \n    float clouds1 = smoothstep(1.0-cover,min((1.0-cover)+softness*2.0,1.0),color1);\n    float clouds2 = smoothstep(1.0-cover,min((1.0-cover)+softness,1.0),color2);\n    \n    float cloudsFormComb = saturate(clouds1+clouds2);\n    \n    vec4 skyCol = vec4(0.6,0.8,1.0,1.0);\n    float cloudCol = saturate(saturate(1.0-pow(color1,1.0)*0.2)*bright);\n    vec4 clouds1Color = vec4(cloudCol,cloudCol,cloudCol,1.0);\n    vec4 clouds2Color = mix(clouds1Color,skyCol,0.25);\n    vec4 cloudColComb = mix(clouds1Color,clouds2Color,saturate(clouds2-clouds1));\n    vec4 clouds = vec4(0.0);\n\tclouds = mix(skyCol,cloudColComb,cloudsFormComb);\n    vec3 sunCol = vec3(258.0, 208.0, 100.0) / 15.0;\n    //bg;  //dot(l,rayDir)*.5+.2;\n    bg=clouds.rgb;\n    if(abs(d) < 0.5){\n        //Diffuse\n        float diff = clamp(dot(normal,(l)),0.0,1.0);\n        vec3 brdf = 1.5*vec3(.10, .11, .11);\n        float fre = .2*pow(clamp(1. + dot(normal, rayDir), 0., 1.), 2.);\n        brdf += 1.30*diff*vec3(1., .9, .75);      \n\t\t//Blinn-Phong half vector\n        vec3 h = normalize(-rayDir + l);\n        //Specular\n        float spe = pow(clamp(dot(h, normal), 0.0, 1.0), 15.0*4.);\n        //Textured specular\n        vec4 spec = texture(iChannel1,posOnRay.xz)*spe;\n\t\t//Adding diffuse and specular\n        col=diff*tex.rgb + spec.rgb+fre*brdf;\n        //Fog\n        fragColor = vec4(mix(col,bg,smoothstep(.01,.2,t*.015)),1.0);\n    } else {\n        //Sky\n        fragColor = vec4(bg+sunCol*(sunIntensity*.0015),1.0);\n    }\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjXzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[343, 343, 366, 366, 486], [495, 495, 518, 518, 630], [631, 649, 669, 669, 736], [737, 754, 775, 775, 972], [973, 988, 1007, 1007, 1158], [1161, 1161, 1192, 1192, 1395], [1397, 1397, 1420, 1420, 1757], [1760, 1760, 1787, 1787, 1820], [1822, 1822, 1845, 1845, 1883], [1885, 1885, 1907, 1907, 2105], [2107, 2107, 2129, 2129, 2548], [2549, 2549, 2606, 2606, 6437]], "test": "error"}
{"id": "4tSSDD", "name": "Enigma raytracing part", "author": "Optimus", "description": "Raytracing part from the Amiga demo Enigma by Phenomena.\nAdded defines for Amiga resolution, palette (not sure I am doing this correctly) and bouncing animation.\nMaybe a tune next?", "tags": ["raytracing", "mandelbrot", "amiga", "enigma"], "likes": 10, "viewed": 372, "published": "Public", "date": "1443563612", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AMIGA_RES\n#define AMIGA_PAL\n#define BOUNCING\n\nfloat time;\nvec2 resolution;\n\nconst int numBalls = 24;\nconst float radius = 0.25;\n\nconst vec3 lightPos = vec3(4.0, 4.0, 0.0);\nvec3 sphereCenter;\n\nbool hasHitSphere = false;\nvec3 floorHitPoint;\n\nconst float bounceOutTimeStart = 24.0;\nconst float bounceDuration = 4.0;\n\nvec2 amigaRes = vec2(320.0, 256.0);\n\nvec4 getColor(vec3 normal)\n{\n\tvec3 lightBack = normalize(lightPos - sphereCenter);\n\tfloat diffuse = dot(normal, lightBack);\n\tif (diffuse < 0.0) diffuse = 0.0;\n\tfloat specular = pow(diffuse, 64.0);\n\tvec4 color = vec4(vec3(0.25 + 1.0*diffuse + 4.0*specular) * vec3(0.25,1.0,0.25), 1.0);\n\treturn color;\n}\n\n\nfloat z_fractal = 1.0;\n\nconst float xpos = -0.99424;\nconst float ypos = 0.2975;\n\nconst float iter = 16.0;\nconst float iter2 = iter / 4.0;\n\nvec4 getFractalColor(vec2 tc)\n{\n\tfloat x0 = mod(0.1*tc.x + 0.9, 2.0);\n\tfloat y0 = mod(0.025*(1.0 - tc.y) + 0.7, 1.0);\n\n\tfloat z0_r = 0.0;\n\tfloat z0_i = 0.0;\n\tfloat z1_r = 0.0;\n\tfloat z1_i = 0.0;\n\tfloat p_r = (x0 + xpos * z_fractal) / z_fractal;\n\tfloat p_i = (y0 + ypos * z_fractal) / z_fractal;\n\tfloat d = 0.0;\n\n\tfloat nn = 0.0;\n\tfor (float n=0.0; n<iter; n++)\n\t{\n\t\tz1_r = z0_r * z0_r - z0_i * z0_i + p_r;\n\t\tz1_i = 2.0 * z0_r * z0_i + p_i;\n\t\td = sqrt(z1_i * z1_i + z1_r * z1_r);\n\t\tz0_r = z1_r;\n\t\tz0_i = z1_i;\n\t\tif (d > iter2) break;\n\t\tnn++;\n\t}\n\n\tfloat c = (1.0*nn) / iter;\n\tif (c==1.0) c = 0.0;\n\tc *= 4.0;\n\tvec4 color = vec4(1.0*c, 1.0*c, 4.0*c, 0.0);\n\treturn color;\n}\n\nvec4 getSphereColor(vec3 pos, vec3 dir, float index)\n{\n\tvec4 color = vec4(0.0);\n\t\n\tfloat yy = -0.4 + sin(index * 0.5);\n\t\n\tvec3 startCenter = vec3(-2.0, yy, 4.0);\n\tvec3 endCenter = vec3(4.0, yy, 32.0);\n\tsphereCenter = startCenter + (endCenter - startCenter) * (index / float(numBalls));\n\t\n\thasHitSphere = false;\n\n\tpos -= sphereCenter;\n\n\tfloat b = 2.0 * dot(pos,dir);\n\tfloat c = dot(pos,pos) - radius;\n\n\tfloat discr = b*b - 4.0*c;\n\tif (discr >= 0.0)\n\t{\n\t\tvec2 t = vec2(-b+discr, -b-discr) / 2.0;\n\t\tvec3 p = pos + min(t.x,t.y) * dir;\n\t\tfloorHitPoint = p;\n\t\thasHitSphere = (p.y > -0.7-yy);\n\t\tif (hasHitSphere)\n\t\t{\n\t\t\tcolor = getColor(normalize(p));\n\t\t\thasHitSphere = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloorHitPoint = p;\n\t\t}\n\t}\n\treturn color;\n}\n\nvec4 getBackgroundColor(vec2 pix)\n{\n\tif (pix.y < 0.0)\n\t{\n\t\tpix.y = -pix.y;\n\t\tfloat v = 1.0 / pix.y;\n\t\tfloat u = pix.x * v;\n\t\tvec4 fractalColor = getFractalColor(vec2(u,v));\n\t\tvec3 aview = vec3(0.0, -1.0, 0.0);\n\t\tvec3 apos = vec3(u, 0.4, v);\n\t\tvec3 adir = normalize(aview - apos);\n\n\t\tvec4 reflectionColor = vec4(0.0);\n\t\tfor (int i=0; i<numBalls; i++)\n\t\t{\n\t\t\treflectionColor += getSphereColor(apos, adir, float(i) - mod(4.0*time, 1.0));\n\t\t\tif (hasHitSphere) break;\n\t\t}\n\n\t\treturn (fractalColor + 2.0 * reflectionColor) * (pix.y + 0.025);\n\t}\n\telse\n\t{\n\t\treturn vec4(0.3 - pix.y, 0.0, 1.0 * pix.y, 0.0) * 2.0;\n\t}\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iTime;\n\tresolution = iResolution.xy;\n    \n    float aspect = resolution.y / resolution.x;\n\n    float bouncing = 0.0;\n\t#ifdef BOUNCING\n        float t = mod(time, 32.0);\n        if (t >= bounceOutTimeStart && t < bounceOutTimeStart + bounceDuration) t = bounceOutTimeStart + bounceDuration - t;\n        float height = (2.0 - 0.5*t) * aspect;\n\n        if (height < 0.0) height = 0.0;\n        bouncing = -abs(cos(3.5*t) * 0.5 * height);\n\n        if (t >= bounceOutTimeStart + bounceDuration) bouncing = -1.0;\n\t#endif\n\n\tvec2 pix = (fragCoord.xy / resolution - vec2(0.5)) * vec2(1.0, aspect) + vec2(0.0, bouncing);\n\n    #ifdef AMIGA_RES\n    \tpix = floor(pix * amigaRes) / amigaRes;\n    #endif\n\n    vec4 col = vec4(0.0);\n    if (pix.y >= -0.5 * aspect)\n    {\n\t\tvec3 pos = vec3(pix,-1.0);\n\t\tvec3 dir = normalize(vec3(pix.x, pix.y, 1.0));\n\n        for (int i=0; i<numBalls; i++)\n        {\n            col += getSphereColor(pos, dir, float(i) - mod(4.0*time, 2.0));\n            if (hasHitSphere) break;\n        }\n        if (!hasHitSphere)\n        {\n            col = getBackgroundColor(pix);\n        }\n    }\n\n\tconst vec3 rgbBands = vec3(32.0, 24.0, 32.0);\n    #ifdef AMIGA_PAL\n    \tcol.rgb = floor(col.rgb * rgbBands) / rgbBands;\n    #endif\n\n\tfragColor = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSSDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[359, 359, 387, 387, 660], [802, 802, 833, 833, 1470], [1472, 1472, 1526, 1526, 2201], [2203, 2203, 2238, 2238, 2811], [2814, 2814, 2871, 2871, 4133]], "test": "valid"}
{"id": "4tSSRh", "name": "Metaeaux - Marball blobs", "author": "metaeaux", "description": "Learning to do textures, shadows and deformations", "tags": ["raymarchingbasics"], "likes": 5, "viewed": 1627, "published": "Public API", "date": "1441505713", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dancingSphere(vec3 p, float rad) {\n    float undulate = 5. * sin(iTime * 0.2);\n    float radius = rad + 0.1 * (sin(p.x * undulate ) + sin(p.y * undulate +  2.*iTime));\n    return length(p) - radius;\n}\n\nvec4 sphereColor( in vec3 pos, in vec3 nor, in sampler2D iChannel)\n{\n\tvec2 uv = vec2( atan( nor.x, nor.z ), acos(nor.y) );\n    vec3 col = (texture( iChannel, uv ).xyz);\n    float ao = clamp( 0.75 + 0.25*nor.y, 0.0, 1.0 );\n    return vec4( col, ao );\n}\n\nvec4 floorColor( in vec3 pos, in vec3 nor )\n{\n    vec3 col = texture( iChannel1, 0.5*pos.xz ).xyz;\n\t\n    // fake ao\n    float f = smoothstep( 0.1, 1.75, length(pos.xz) );\n\n\treturn vec4(col, 0.5*f+0.5*f*f);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  float undulate = 5. * cos(iTime * 0.2);\n  float radius = r + 0.1 * (sin(p.x * undulate ) + sin(p.y * undulate +  2.*iTime));\n  return length(max(abs(p)-b,0.0))-r*radius;\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n// subtraction\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\n// union\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn d1.x < d2.x ? d1 : d2;\n}\n\n// intersection\nvec2 opI( vec2 d1, vec2 d2 )\n{\n    return d1.x > d2.x ? d1 : d2;\n}\n\nvec2 map(vec3 p) {\n    \n    vec2 d = opU(vec2(dancingSphere(p - vec3(1.5, 0., 0.), 1.), 1.), vec2(p.y + 2., 2.));\n    \n    d = opU(d, vec2(udRoundBox(p - vec3(-1.5, 0., 0.), vec3(.0, 0., 0.), 1.), 3.));\n    \n    return d;\n}\n\nvec3 normal(vec3 pos) {\n    vec3 e = vec3(0.00001, 0., 0.);\n    vec3 nor = normalize( vec3(map(pos+e.xyy).x - map(pos-e.xyy).x,\n                               map(pos+e.yxy).x - map(pos-e.yxy).x,\n                               map(pos+e.yyx).x - map(pos-e.yyx).x));\n    return nor;\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, in float maxt)\n{\n\tfloat res = 1.0;\n    float dt = 0.04;\n    float t = .02;\n    for( int i=0; i < 20; i++ )\n    {       \n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, maxt*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 raymarch(in vec3 ro, in vec3 rd, in float tmax)\n{\n\tvec2 h = vec2(0.);\n    float t = 0.;\n    \n    for(int i = 0; i < 64; i++)\n    {\n     \th = map(ro + t * rd);\n        t += h.x;\n        if( h.x < 0.001) break;\n        if(t > tmax) return vec3(t, h.x, -1.);\n    }\n    \n    return vec3(t, h);\n    \n}\n\nvec4 selectColour(in float index, in vec3 pos, in vec3 nor) {\n    vec4 ambient = 1.5 * vec4(0.1, 0.15, 0.2, 1.);\n    vec4 planeColour = vec4(1.);\n    vec4 blobColour = vec4(0.6, 0.8, 1., 1.);\n    \n    if (index == 1.) return sphereColor(pos, nor, iChannel3); //blobColour;\n    else if(index == 2.) return planeColour;\n    else if(index == 3.) return sphereColor(pos, nor, iChannel2);\n    else return ambient; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float grid = 4.;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv * grid - grid/2.;\n    \n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 eye = vec3(0., 0., 0.);\n    vec3 up = normalize(vec3(0., 1., 0.5));\n    vec3 right = vec3(1., 0., 0.);\n    vec3 forward = normalize(vec3(0., 2., -4.));\n    float focalLength = 2.;\n\n    vec3 ro = forward*focalLength + right * p.x + up * p.y;\n    vec3 rd = normalize(cross(right, up));    \n    vec4 col = vec4(0.);\n    vec3 lig = vec3(0.9*cos(iTime), 0.9, 0.9*sin(iTime));\n    vec4 ambient = 1.5 * vec4(0.1, 0.15, 0.2, 1.);\n    vec3 planeColour = vec3(1.);\n    vec3 blobColour = vec3(0.6, 0.8, 1.);\n    float tmax = 20.0;\n    \n    // lets raymarch!\n    vec3 march = raymarch(ro, rd, tmax);\n    vec2 h = march.yz;\n    float t = march.x;\n    \n    // did we intersect the primitive?\n    if(t < tmax) {\n    \tvec3 pos = ro + t * rd;\n        vec3 e = vec3(0.0001, 0., 0.);\n        vec3 nor = normal(pos);\n        \n        col = selectColour(h.y, pos, nor);\n        \n        float lambert = clamp(dot(normalize(nor), normalize(lig)), 0., 1.);\n        float phong = pow(lambert,128.);\n        \n        // lambert shading and ambient colour\n        col = clamp(col*lambert + ambient * (1.0 - lambert) + phong, 0., 1.);  \n        \n        // shadow and ambient colour\n        float sh = shadow( pos, lig, 1.0);\n\t\tcol *= sh  + ambient * (1.0 - sh);\n        \n    }\n    \n    \n\tfragColor = col;\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSSRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 206], [208, 208, 276, 276, 459], [461, 461, 506, 506, 668], [670, 670, 712, 712, 811], [813, 813, 858, 858, 1032], [1034, 1034, 1065, 1065, 1096], [1098, 1113, 1146, 1146, 1172], [1174, 1183, 1213, 1213, 1246], [1248, 1264, 1294, 1294, 1330], [1332, 1332, 1350, 1350, 1555], [1557, 1557, 1580, 1580, 1840], [1842, 1842, 1896, 1896, 2157], [2159, 2159, 2213, 2213, 2460], [2462, 2462, 2523, 2523, 2873], [2875, 2875, 2932, 2932, 4369]], "test": "error"}
{"id": "4tSXRm", "name": "Jagged Plain", "author": "Shane", "description": "Using relatively cheap functions to produce a sharp, jagged, surface with a fake glow.", "tags": ["noise", "terrain", "triangle", "glow", "rocks", "jagged"], "likes": 84, "viewed": 6391, "published": "Public API", "date": "1442419753", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Jagged Plain\n    ------------\n\n\tI've always found jagged, rocky surfaces difficult to raymarch at acceptable framerates. I wrote a \n\trelatively cheap, fake Voronoi function a while back in an attempt rectify that, but had mixed success. \n\tShadertoy user \"Aiekick\" has made some pretty cool examples with it, so I was glad someone got some\n\tuse out it. :)\n    \n\tAnyway, it can produce some pretty cheap, and reasonably decent looking, rocky surfaces. Unfortunately, \n\tit still isn't fast enough. Thankfully, Shadertoy user Nimitz came up with the idea to use variations \n\ton a triangle function, which does the job nicely. This is an example displaying that.\n\n\tI gave the rocks a bit of fake luminescent glow. It'd look a bit better if the surface had more detail.\n\tEither way, the glow code is very loosely based on something I found in a couple of TekF's examples. \n\tThe inspiration came from IQ's mushroom example.\n\n\tLoosely related examples:\n\n\tRay Marching Experiment n34 - Aiekick    \n\thttps://www.shadertoy.com/view/XtBXRm\n\n\tSubo Glacius - Aiekick\n\thttps://www.shadertoy.com/view/Ml2XRW\n\n    Another ray marched, perturbed planar surface example that I like.\n    Moon Surface - 4rknova\n    https://www.shadertoy.com/view/4slGRf\n\n*/\n\n#define PI 3.14159265358979\n\n// Grey scale.\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\n// 2x2 matrix rotation.\nmat2 rot2( float a ){ float c = cos(a), s = sin(a);\treturn mat2( c, -s,\ts, c ); }\n\n// Cheapish vec3-to-vec3 hash function.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\nvec3 tri(in vec3 x){return abs(x-floor(x)-.5);} // Triangle function.\nvec3 triSmooth(in vec3 x){return cos(x*6.2831853)*0.25+0.25;} // Smooth version. Not used here.\n\n\n// This is a cheap...ish routine - based on the triangle function - that produces a pronounced jagged \n// looking surface. It's not particularly sophisticated, but it does a surprizingly good job at laying \n// the foundations for a sharp rock face. Obviously, more layers would be more convincing. In fact, \n// I'm disappointed that there weren't enough cycles for one more layer. Unfortunately, this is a \n// GPU-draining distance function. The really fine details have been bump mapped.\nfloat surfFunc(in vec3 p){\n    \n    // This is just one variation on a common technique: Take a cheap function, then\n    // layer it by applying mutations, rotations, frequency and amplitude changes,\n    // etc. Feeding the function into itself, folding it, and so forth can also \n    // produce interesting surfaces, patterns, etc.\n    //\n    // Good examples of the technique include IQ's spiral noise and Nimitz's triangle\n    // noise, each of which can be found on Shadertoy. \n    //\n    float n = dot(tri(p*0.15 + tri(p.yzx*0.075)), vec3(0.444));\n    p = p*1.5773;// - n; // The \"n\" mixes things up more.\n    p.yz = vec2(p.y + p.z, p.z - p.y) * 0.866;\n    p.xz = vec2(p.x + p.z, p.z - p.x) * 0.866;\n    n += dot(tri(p*0.225 + tri(p.yzx*0.1125)), vec3(0.222)); \n    \n    return abs(n-0.5)*1.9 + (1.-abs(sin(n*9.)))*0.05; // Range [0, 1]\n    \n/*    \n    // Different setup, using sinusoids, which tends to be quicker on my GPU\n    // than \"fract,\" \"floor,\" etc. Strange, but I'll assume a sinusoid signal\n    // is easier to produce on a GPU than a flooring mechanism. It's all\n    // Voodoo to me. :)\n\t//\n    float n = sin(p.x+sin(p.y+sin(p.z)))*0.57;\n    p *= 1.5773;\n    //p.yz = vec2(p.y + p.z, p.z - p.y) * 1.7321*0.5;\n    p.xz = vec2(p.x + p.z, p.z - p.x) * 1.7321*0.5;\n    n += sin(p.x+sin(p.y+sin(p.z)))*0.28;\n    p *= 1.5773;\n    //p.yz = vec2(p.y + p.z, p.z - p.y) * 1.7321*0.5;\n    p.xz = vec2(p.x + p.z, p.z - p.x) * 1.7321*0.5;\n    n += sin(p.x+sin(p.y+sin(p.z)))*0.15;\n    \n    return n*0.475+0.475+ ((sin(sin(n*3.)*6.)*0.5+0.5))*0.05;\n\t\n*/    \n\n}\n\n\n// Simple sinusoidal path, based on the z-distance.\nvec2 path(in float z){ float s = sin(z/36.)*cos(z/18.); return vec2(s*16., 0.); }\n\n// Standard setup for a plane at zero level with a perturbed surface on it.\nfloat map(vec3 p){\n \n     return p.y - surfFunc(p)*1.5;\n \n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = 0.001;\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor)));\n    \n    grad = (grad - getGrey(tex3D(tex,  p , nor)))/eps; \n            \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Tetrahedral normal: I remember a similar version on \"Pouet.net\" years ago, but this one is courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    vec2 e = vec2(0.5773,-0.5773)*0.001;\n    return normalize( e.xyy*map(p+e.xyy ) + e.yyx*map(p+e.yyx ) + e.yxy*map(p+e.yxy ) + e.xxx*map(p+e.xxx ));\n}\n\n// Based on original by IQ.\nfloat calculateAO(vec3 p, vec3 n){\n\n    const float AO_SAMPLES = 5.0;\n    float r = 0.0, w = 1.0, d;\n    \n    for (float i=1.0; i<AO_SAMPLES+1.1; i++){\n        d = i/AO_SAMPLES;\n        r += w*(d - map(p + n*d));\n        w *= 0.5;\n    }\n    \n    return 1.0-clamp(r,0.0,1.0);\n}\n\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// I think it's based on a discrete finite difference approximation to the continuous\n// Laplace differential operator? Either way, it gives you the curvature of a surface, \n// which is pretty handy. I used it to do a bit of fake shadowing.\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-1., 1.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 0.125/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\n\n// Blackbody color palette. Handy for all kinds of things.\nvec3 blackbodyPalette(float t){\n\n    // t = tLow + (tHigh - tLow)*t;\n    t *= 3200.; // Temperature range. Hardcoded from 0K to 4000K, in this case.    \n    \n    // Planckian locus or black body locus approximated in CIE color space.\n    float cx = (0.860117757 + 1.54118254e-4*t + 1.28641212e-7*t*t)/(1.0 + 8.42420235e-4*t + 7.08145163e-7*t*t);\n    float cy = (0.317398726 + 4.22806245e-5*t + 4.20481691e-8*t*t)/(1.0 - 2.89741816e-5*t + 1.61456053e-7*t*t);\n    \n    // Converting the chromacity coordinates to XYZ tristimulus color space.\n    float d = (2.*cx - 8.*cy + 4.);\n    vec3 XYZ = vec3(3.*cx/d, 2.*cy/d, 1. - (3.*cx + 2.*cy)/d);\n    \n    // Converting XYZ color space to RGB: http://www.cs.rit.edu/~ncs/color/t_spectr.html\n    vec3 RGB = mat3(3.240479, -0.969256, 0.055648, -1.537150, 1.875992, -0.204043, \n                    -0.498535, 0.041556, 1.057311) * vec3(1./XYZ.y*XYZ.x, 1., 1./XYZ.y*XYZ.z);\n\n    // Apply StefanBoltzmann's law to the RGB color\n    return max(RGB, 0.)*pow(t*0.0004, 4.); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lookAt = vec3(0.0, 2.25, iTime*5.);  // \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 0.2, -0.5); // Camera position, doubling as the ray origin.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = camPos + vec3(0.0, 0.5, 2.0);// Put it a bit in front of the camera.\n\tvec3 lp2 = camPos + vec3(0.0, 0.5, 9.0);// Put it a bit in front of the camera.\n\t\n\t// Sending the camera, \"look at,\" and two light vectors across the plain. The \"path\" function is \n\t// synchronized with the distance function.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlp.xy += path(lp.z);\n\tlp2.xy += path(lp2.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalizaztion is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(forward, right); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy *= rot2( path(lookAt.z).x/32. );\n\t\t\n    // Standard ray marching routine. I find that some system setups don't like anything other than\n    // a \"break\" statement (by itself) to exit.\n    //\n    // Note the \"abs\" addition. I don't always use it, but with some distance field setups, it can \n    // reduce popping and increase performance. Although, if not careful, holes can appear. Take out \n    // the \"abs\" call, to see what I'm talking about.\n\tfloat t = 0.0, dt;\n\tfor(int i=0; i<128; i++){\n\t\tdt = map(camPos + rd*t);\n\t\tif(abs(dt)<0.001*(1. + t*0.125) || t>40.0) break; \n\t\tt += dt*0.7; // Without the \"abs\" call, you would need \"t += dt*0.5;,\" or thereabouts.\n\t}\n    \n    t = min(t, 40.0);\n\t\n    // Initiate the scene color to black.\n\tvec3 sceneCol = vec3(0.0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<40.0001){\n\n    \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = camPos + rd*t;\n\t    vec3 sn = getNormal(sp);\n        \n        // Texture scale factor.\n        const float tSize0 = 1./3.;\n        // Texture-based bump mapping. Comment this line out to \n        // spoil the illusion.\n\t    sn = doBumpMap(iChannel0, sp*tSize0, sn, 0.04);\n        \n        // Obtaining the texel color. \n\t    vec3 texCol = tex3D(iChannel0, sp*tSize0, sn);\n\n\t    // Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);\n    \t\n    \t// Light direction vectors.\n\t    vec3 ld = lp-sp;\n\t    vec3 ld2 = lp2-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n\t    float lDist2 = max(length(ld2), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDist;\n\t    ld2 /= lDist2;\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*lDist*0.075);\n\t    float atten2 = 1./(1. + lDist2*lDist2*0.075);\n    \t\n    \t// Ambient light.\n\t    float ambience = 0.05;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n\t    float diff2 = max( dot(sn, ld2), 0.0);\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.);\n\t    float spec2 = pow(max( dot( reflect(-ld2, sn), -rd ), 0.0 ), 8.);\n    \t\n    \t// Curvature.\n\t    float crv = clamp(curve(sp, 0.125)*0.5 + 0.5, .0, 1.);\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        //float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n\t    \n       \n        // Shadertoy doesn't appear to have anisotropic filtering turned on... although,\n        // I could be wrong. Texture-bumped objects don't appear to look as crisp. Anyway, \n        // this is just a very lame, and not particularly well though out, way to sparkle \n        // up the blurry bits. It's not really that necessary.\n        //vec3 aniso = (0.5-hash33(sp))*0.2;\n\t    //texCol = clamp(texCol + aniso, 0., 1.);\n    \t\n    \t// Darkening the crevices. Otherse known as cheap, scientifically-incorrect shadowing.\t\n\t    float shading =  crv*0.75 + 0.25; //surfFunc(sp)*0.5+0.5;//\n        \n        \n        // A bit of fake glow. I was undecided between using normal wrapping, proper subsurface\n        // scattering, or this. It's based on something I saw in a couple of examples by \n        // Shadertoy user \"TekF,\" who has a whole bunch of interesting shaders.\n        //\n        // Basically, you burrow a little below the surface, via the normal, then take a couple \n        // of steps in a direction between the ray and the light. My version is pseudosciencey, and \n        // I'm undecided on it's effectiveness, but it gives the subtle glow I want for this \n        // particular example. It works better with more detailed surfaces.\n\t    float rnd = fract(sin(dot(sp, vec3(7, 157, 113)))*43758.4543);\n        float tRange = 0.25;\n        float nDepth = 0.03;\n        vec3 hf = normalize(rd+ld);\n\t    float ss = tRange*0.5-map( sp-sn*(nDepth+rnd*0.005) + hf*tRange*0.5 ) + (tRange-map( sp-sn*(nDepth*2.+rnd*0.01) + hf*tRange ))*0.5;\n\t    hf = normalize(rd+ld2);\n        float ss2 = tRange*0.5-map( sp-sn*(nDepth+rnd*0.005) + hf*tRange*0.5 ) + (tRange-map( sp-sn*(nDepth*2.+rnd*0.01) + hf*tRange ))*0.5;\n\t    \n\t    ss = max(ss, 0.);\n\t    ss2 = max(ss2, 0.);\n        \n    \t\n    \t// Combing the above terms to produce the surface color.\n        vec3 rCol = getGrey(texCol)*0.5 + texCol*0.5;\n        vec3 sCol = texCol*0.5 + 0.5;\n        sceneCol += (rCol*(diff + ambience) + blackbodyPalette(ss*.6)*sCol*12.0 + spec*texCol*2.)*atten;\n        sceneCol += (rCol*(diff2 + ambience) + blackbodyPalette(ss2*.6)*sCol*12.0 + spec2*texCol*2.)*atten2;\n      \n\t    \n        // Shading.\n        sceneCol *= shading*ao;\n\t\n\t}\n\t\n    // Loose gamma correction.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSXRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1278, 1293, 1315, 1315, 1359], [1361, 1385, 1406, 1406, 1466], [1468, 1508, 1528, 1528, 1637], [1640, 1706, 1756, 1756, 1963], [1966, 2164, 2184, 2184, 2211], [2212, 2234, 2260, 2260, 2295], [2332, 2821, 2847, 3309, 4386], [4389, 4441, 4463, 4463, 4522], [4524, 4600, 4618, 4618, 4659], [4661, 4743, 4816, 4816, 5259], [5261, 5371, 5399, 5399, 5553], [5555, 5583, 5617, 5617, 5859], [5861, 6312, 6347, 6347, 6551], [6554, 6613, 6644, 6681, 7631], [7633, 7633, 7689, 7715, 14000]], "test": "error"}
{"id": "ll2SRz", "name": "Wobbly Blob", "author": "dr2", "description": "The ancient Temple of the Wobbly Blob; use the mouse for a closer look.", "tags": ["raymarching", "reflection", "distortion"], "likes": 12, "viewed": 1015, "published": "Public API", "date": "1441200977", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Wobbly Blob\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3a (vec3 p)\n{\n  vec3 i, f;\n  i = floor (p);  f = fract (p);\n  f *= f * (3. - 2. * f);\n  vec4 t1 = Hashv4v3 (i);\n  vec4 t2 = Hashv4v3 (i + vec3 (0., 0., 1.));\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n              mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  const mat3 mr = mat3 (0., 0.8, 0.6, -0.8, 0.36, -0.48, -0.6, -0.48, 0.64);\n  float f, a, am, ap;\n  f = 0.;  a = 0.5;\n  am = 0.5;  ap = 4.;\n  p *= 0.5;\n  for (int i = 0; i < 6; i ++) {\n    f += a * Noisefv3a (p);\n    p *= mr * ap;  a *= am;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 qHit, sunDir;\nfloat tCur;\nint idObj;\nconst float dstFar = 100.;\nconst int idBase = 1, idCol = 2, idColEnd = 3, idTop = 4, idReflObj = 5;\n\nvec3 SkyBg (vec3 rd)\n{\n  return mix (vec3 (0.1, 0.1, 0.5), vec3 (0.2, 0.2, 0.5),\n     1. - max (rd.y, 0.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 p, q, cSun, clCol, col;\n  float fCloud, cloudLo, cloudRngI, atFac, colSum, attSum, s,\n     att, a, dDotS, ds;\n  const int nLay = 60;\n  cloudLo = 300.;  cloudRngI = 1./200.;  atFac = 0.035;\n  fCloud = 0.45;\n  if (rd.y > 0.) {\n    fCloud = clamp (fCloud, 0., 1.);\n    dDotS = max (dot (rd, sunDir), 0.);\n    ro.xz += 2. * tCur;\n    p = ro;\n    p.xz += (cloudLo - p.y) * rd.xz / rd.y;\n    p.y = cloudLo;\n    ds = 1. / (cloudRngI * rd.y * (2. - rd.y) * float (nLay));\n    colSum = 0.;  attSum = 0.;\n    s = 0.;  att = 0.;\n    for (int j = 0; j < nLay; j ++) {\n      q = p + rd * s;\n      att += atFac * max (fCloud - Fbm3 (0.007 * q), 0.);\n      a = (1. - attSum) * att;\n      colSum += a * (q.y - cloudLo) * cloudRngI;\n      attSum += a;  s += ds;\n      if (attSum >= 1.) break;\n    }\n    colSum += 0.5 * min ((1. - attSum) * pow (dDotS, 3.), 1.);\n    clCol = vec3 (1.) * 2.8 * (colSum + 0.05);\n    cSun = vec3 (1.) * clamp ((min (pow (dDotS, 1500.) * 2., 1.) +\n       min (pow (dDotS, 10.) * 0.75, 1.)), 0., 1.);\n    col = clamp (mix (SkyBg (rd) + cSun, clCol, attSum), 0., 1.);\n    col = mix (col, SkyBg (rd), pow (1. - rd.y, 16.));\n  } else col = SkyBg (rd);\n  return col;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  vec2 p;\n  float w, f;\n  if (rd.y > 0.) col = SkyCol (ro, rd);\n  else {\n    p = ro.xz - ro.y * rd.xz / rd.y;\n    w = 1.;\n    f = 0.;\n    for (int j = 0; j < 3; j ++) {\n      f += w * Noisefv2 (0.1 * p);  w *= 0.5;  p *= 2.;\n    }\n    col = mix ((1. + min (f, 1.)) * 0.5 * vec3 (0.2, 0.15, 0.1),\n       0.4 * vec3 (0.3, 0.4, 0.6), pow (1. + rd.y, 5.));\n  }\n  return col;\n}\n\nvec3 SMap (vec3 p, float t)\n{\n  float f;\n  f = 2.;\n  for (int k = 0; k < 5; k ++) {\n    p += 0.4 * sin (1.7 * p.yzx / f + f * t);\n    f *= 0.8;\n  }\n  return p;\n}\n\nfloat BlobDf (vec3 p)\n{\n  float d;\n  p.xz = Rot2D (p.xz, 0.2 * tCur);\n  d = 0.2 * SmoothMin (PrSphDf (SMap (p - vec3 (0.7, 0., 0.), tCur + 2.),\n     1.1 + 0.31 * sin (tCur)),\n     PrSphDf (SMap (p + vec3 (0.7, 0., 0.), 1.3 * tCur),\n     1. + 0.41 * sin (1.7 * tCur)), 0.5);\n  return max (d, - p.y - 2.3);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, da, db, wr;\n  dMin = dstFar;\n  q = p;\n  d = PrBoxDf (q, vec3 (6.8, 0.101, 8.8));\n  q.y -= 0.15;\n  d = min (d, PrBoxDf (q, vec3 (6.5, 0.101, 8.5)));\n  q.y -= 0.15;\n  d = min (d, PrBoxDf (q, vec3 (6.2, 0.101, 8.2)));\n  d = max (d, - PrCylDf (q.xzy, 3.5, 0.5));\n  if (d < dMin) { dMin = d;  idObj = idBase;  qHit = q; }\n  q.y -= 5.52;\n  d = max (PrBoxDf (q, vec3 (5.8, 0.05, 7.8)),\n     - PrBoxDf (q, vec3 (4.2, 0.4, 6.2)));\n  if (d < dMin) { dMin = d;  idObj = idTop;  qHit = q; }\n  q = p;  q.y -= 3.1;\n  db = max (PrBoxDf (q, vec3 (6., 5., 8.)),\n     - PrBoxDf (q, vec3 (4., 5., 6.)));\n  q = p;  q.xz = mod (q.xz, 2.) - 1.;  q.y -= 3.1;\n  wr = q.y / 2.5;\n  d = max (PrCylDf (q.xzy, 0.27 * (1.05 - 0.05 * wr * wr), 2.55), db);\n  if (d < dMin) { dMin = d;  idObj = idCol;  qHit = q; }\n  q = p;  q.xz = mod (q.xz, 2.) - 1.;  q.y = abs (q.y - 3.1) - 2.5;\n  d = PrCylDf (q.xzy, 0.4, 0.07);\n  q.y -= 0.14;\n  d = max (min (d, PrBoxDf (q, vec3 (0.5, 0.07, 0.5))), db);\n  if (d < dMin) { dMin = d;  idObj = idColEnd;  qHit = q; }\n  q = p;  q.y -= 2.2;  \n  d = BlobDf (q);\n  if (d < dMin) { dMin = d;  idObj = idReflObj;  qHit = q; }\n  q.y -= -1.9;\n  d = PrCylDf (q.xzy, 3.5, 0.02);\n  if (d < dMin) { dMin = d;  idObj = idReflObj;  qHit = q; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\n#define SHADOW 1\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n#if SHADOW\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int i = 0; i < 50; i ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, 30. * h / d);\n    d += 0.1 + 0.011 * d;\n    if (h < 0.001) break;\n  }\n  return max (sh, 0.);\n#else\n  return 1.;\n#endif\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 objCol, col, rdd, vn, vnw;\n  vec2 vnC;\n  float dstHit, refl, dif, bk, sh, a, t1, t2;\n  int idObjT, showBg;\n  const int nRefl = 3;\n  refl = 1.;\n  showBg = 0;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (dstHit < dstFar && idObj == idReflObj) {\n    for (int k = 0; k < nRefl; k ++) {\n      ro += rd * dstHit;\n      rd = reflect (rd, ObjNf (ro));\n      ro += 0.01 * rd;\n      refl *= 0.8;\n      idObj = -1;\n      dstHit = ObjRay (ro, rd);\n      if (dstHit >= dstFar || idObj != idReflObj) break;\n    }\n    if (dstHit >= dstFar) showBg = 1;\n  } else if (dstHit >= dstFar) showBg = 1;\n  if (showBg > 0) col = refl * BgCol (ro, rd);\n  else {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj == idCol || idObj == idColEnd) {\n      a = 0.5 - mod (20. * (atan (qHit.x, qHit.z) / (2. * pi) + 0.5), 1.);\n      vn.xz = Rot2D (vn.xz, -0.15 * pi * sin (pi * a));\n    }\n    if (idObj == idBase) {\n      objCol = vec3 (0.3, 0.3, 0.25);\n      vnC = vec2 (10., 3.);\n    } else if (idObj == idTop) {\n      objCol = vec3 (0.8, 0.6, 0.2);\n      vnC = vec2 (40., 0.5);\n    } else if (idObj == idCol || idObj == idColEnd) {\n      objCol = vec3 (0.4, 0.35, 0.3);\n      vnC = vec2 (20., 1.);\n    } else {\n      objCol = vec3 (0.7);\n      vnC = vec2 (0.);\n    }\n    if (vnC.x != 0.) vn = VaryNf (vnC.x * qHit, vn, vnC.y);\n    sh = ObjSShadow (ro, sunDir);\n    bk = max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.);\n    dif = max (dot (vn, sunDir), 0.);\n    col = refl * objCol * (0.2 * (1. + bk) +  dif * (0.2 + 0.8 * sh) +\n       0.3 * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.));\n  }\n  return sqrt (clamp (col, 0., 1.));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 canvas = iResolution.xy;\n  vec2 uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  mat3 vuMat;\n  vec3 ro, rd, vd, u;\n  float dist, az, f, t;\n  t = 0.02 * tCur + 0.3 * pi;\n  sunDir = normalize (vec3 (sin (t), 1.5, cos (t)));\n  if (mPtr.z <= 0.) {\n    dist = 30.;\n    az = 0.75 * pi - 0.05 * tCur;\n  } else {\n    dist = max (3.5, 30. - 60. * mPtr.y);\n    az =  0.75 * pi + 2.5 * pi * mPtr.x;\n  }\n  ro = dist * vec3 (sin (az), 0., cos (az));\n  ro.y = 5.;\n  vd = normalize (vec3 (0., 3., 0.) - ro);\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  rd = vuMat * normalize (vec3 (uv, 5.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2SRz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[266, 266, 290, 290, 337], [339, 339, 363, 363, 602], [604, 604, 629, 629, 808], [810, 810, 836, 836, 1130], [1132, 1132, 1153, 1153, 1413], [1415, 1415, 1444, 1444, 1656], [1658, 1658, 1697, 1697, 1914], [1916, 1916, 1948, 1948, 2043], [2045, 2045, 2078, 2078, 2105], [2107, 2107, 2149, 2149, 2200], [2202, 2202, 2247, 2247, 2345], [2347, 2347, 2377, 2377, 2451], [2596, 2596, 2618, 2618, 2705], [2707, 2707, 2739, 2739, 3921], [3923, 3923, 3954, 3954, 4339], [4341, 4341, 4370, 4370, 4502], [4504, 4504, 4527, 4527, 4810], [4812, 4812, 4834, 4834, 6111], [6113, 6113, 6146, 6146, 6322], [6324, 6324, 6345, 6345, 6558], [6578, 6578, 6615, 6615, 6869], [6871, 6871, 6906, 6906, 8588], [8590, 8590, 8646, 8646, 9467]], "test": "valid"}
{"id": "ll2Szm", "name": "cravo-Trails", "author": "cravo", "description": "Trying out trails", "tags": ["2d", "trails"], "likes": 1, "viewed": 350, "published": "Public", "date": "1442855539", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 centre, float radius, vec2 fragCoord)\n{\n    vec2 delta = fragCoord - centre;\n    float dist = length(delta);\n    if ( dist < radius )\n    {\n        return 1.0 - (dist/radius);\n    }\n    else\n    {\n        return -1.0;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 centre = iResolution.xy * 0.5;\n    float speed = 2.0;\n    centre += centre * 0.8 * vec2(sin(iTime * 0.3 * speed) * cos(iTime * 0.7 * speed),\n                                  sin(iTime * 1.3 * speed) * cos(iTime * 1.9 * speed));\n    \n    float radius = 15.0 + 10.0 * sin(iTime * 3.0) * cos(iTime * 7.0);\n    \n    float circ = circle(centre, radius, fragCoord);\n    if ( circ >= 0.0 )\n    {\n        float scale = 0.1;\n        \n        float r = ((sin(iTime * 3.0 * scale) * cos(iTime * 7.0 * scale)) + 1.0) - 0.5;\n        float g = ((sin(iTime * 13.0 * scale) * cos(iTime * 17.0 * scale)) + 1.0) - 0.5;\n        float b = ((sin(iTime * 19.0 * scale) * cos(iTime * 3.0 * scale)) + 1.0) - 0.5;\n\n        fragColor = vec4(((circ * 0.25) + 0.75)*vec3(r,g,b),1.0);\n    }\n    else\n    {\n        discard;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2Szm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 243], [245, 245, 302, 302, 1114]], "test": "valid"}
{"id": "ll2XR1", "name": "ray trace test", "author": "CaiusTSM", "description": "blah", "tags": ["raytrace"], "likes": 3, "viewed": 1301, "published": "Public API", "date": "1441743491", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphere(vec3 rayOrigin, vec3 rayDirection, vec3 sphereCenter, float sphereRadius)\n{\n    vec3 rc = rayOrigin - sphereCenter; // create arrow pointing from sphereCenter to ray origin\n    \n    float c = dot(rc, rc) - (sphereRadius * sphereRadius); // magnitude of rc minus sphere radius squared\n    \n    float b = dot(rayDirection, rc); // dot product between ray direction and rc which gives a unit vector along rc's axis\n    \n    float d = b * b - c; // b squared minus c (gives distance squared)\n    \n    float t = -b - sqrt(abs(d)); // sqrt to get distance d; -b minus distance d\n    \n    float st = step(0.0, min(t, d)); // step from 0 the min of distance d or t\n    \n    return mix(-1.0, t, st); // return the interpolation between t and stepped t (st)\n}\n\nvec3 background(float t, vec3 rd)\n{\n    vec3 light = normalize(vec3(sin(t), 0.6, cos(t)));\n    \n    float sun = max(0.0, dot(rd, light));\n    \n    float sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n    \n    float ground = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n    \n    return (pow(sun, 256.0) + 0.2 * pow(sun, 2.0)) * vec3(2.0, 1.6, 1.0) + pow(ground, 0.5) * vec3(0.4, 0.3, 0.2) + pow(sky, 1.0) * vec3(0.5, 0.6, 0.7);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * vec2(iResolution.x/iResolution.y, 1.0);\n    \n    vec3 ro = vec3(0.0, 0.0, -3.0); // ray origin\n    \n    vec3 rd = normalize(vec3(uv, 1.0)); // ray direction.\n    \n    vec3 p = vec3(0.0, 0.0, 0.0); // sphere center\n    \n    float t = sphere(ro, rd, p, 1.0); // ray trace sphere (get the current float represtenting current distance to sphere surface)\n    \n    vec3 nml = normalize(p - (ro + rd * t)); // normalize(center - ((ray origin + ray direction) * distance)) \n    \n    vec3 bgCol = background(iTime, rd); // get the bg color\n    \n    rd = reflect(rd, nml); // relect off of the normal nml (from the sphere)\n    \n    vec3 col = background(iTime, rd) * vec3(0.9, 0.8, 1.0); // bg color times the color we want the bg to be (so its not just black and white and grey)\n    \n    fragColor = vec4( mix(bgCol, col, step(0.0, t)), 1.0 ); // interpolate the background color and the relected color\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2XR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 88, 88, 762], [764, 764, 799, 799, 1187], [1189, 1189, 1244, 1244, 2199]], "test": "valid"}
{"id": "llBSDW", "name": "Phong Lumire mouvante", "author": "Lihouf", "description": "Phong Lumire mouvante", "tags": ["phong"], "likes": 1, "viewed": 102, "published": "Public", "date": "1443615992", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n    uv.x=uv.x*(16.0/9.0);\n    /////////////////////////////////////\n    //DECLARATION\n    /////////////////////////////////////\n    //position de la pamra\n\tvec3 camera = vec3(0.0, 0.0, -2.0);\n    \n\tvec3 direction = normalize(vec3(uv, 1.0));\n    \n    //Point actuel \n    vec3 point=camera;\n    \n    //Position de la lumire\n    vec3 lumiere=vec3(5.0*sin(iTime),1.0,-2.0);\n    \n    //Intensit et couleur de la lumire ambiante Compris entre 0 et 1\n    vec3 ambiant=vec3(0.01,0.01,0.2);\n    \n    //Position de la sphre\n    vec3 centreSphere=vec3(1.0,1.0,1.0);\n    \n    //Couleur de fond\n    fragColor = vec4(1.0,1.0,1.0,1.0);\n    \n    //Raymarching\n    for(int i=1;i<512;i++)\n    {\n        //Dcalage raymarching\n        point=point+direction*0.01;\n        \n        //Si l'on se situe\n        if(distance(point,centreSphere)<=1.0){\n            //Normal de la surface N\n          \tvec3 normalSurface = normalize(point-vec3(1.0,1.0,1.0));\n            //Normal de la lumire L\n            vec3 normLumiere = normalize(lumiere-point);\n            //Normal de la camra V\n            vec3 normVue = normalize(camera-point);\n            \n            //Rflection R\n         \tvec3 R = 2.0*max(dot(normalSurface,normLumiere),0.0)*normalSurface-normLumiere;\n\t\t\t\n            //Intensit de la lumire diffuse\n            float diffuse=max(dot(normalSurface,normLumiere),0.0);\n            \n            //Intensit de la lumire spculaire\n            float speculaire=pow(max(dot(R,normVue),0.0),64.0);\n\t\t\t\n            \n            float res=diffuse+iMouse.x*(speculaire/iResolution.x);\n            \n            //Couleur de la shpre\n            \n            fragColor = vec4(ambiant.x+res,ambiant.y+res,ambiant.z+res,1.0);\n            break;\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBSDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1898]], "test": "valid"}
{"id": "llBSDz", "name": "Bobsled", "author": "dr2", "description": "Downhill fast...", "tags": ["raymarching", "snow", "sledding"], "likes": 37, "viewed": 3579, "published": "Public API", "date": "1442846386", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Bobsled\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  vec2 ff = f * f;\n  vec2 u = ff * (3. - 2. * f);\n  vec2 uu = 30. * ff * (ff - 2. * f + 1.);\n  vec4 h = Hashv4f (dot (i, cHashA3.xy));\n  return vec3 (h.x + (h.y - h.x) * u.x + (h.z - h.x) * u.y +\n     (h.x - h.y - h.z + h.w) * u.x * u.y, uu * (vec2 (h.y - h.x, h.z - h.x) +\n     (h.x - h.y - h.z + h.w) * u.yx));\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nint idObj;\nmat3 oMat, objMat[2];\nvec3 oPos, objPos[2], qHit, sunDir;\nfloat tCur;\nconst float dstFar = 200.;\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  vec2 p;\n  float cloudFac, w, f, s;\n  if (rd.y > 0.) {\n    ro.x += 2. * tCur;\n    p = 0.02 * (rd.xz * (100. - ro.y) / rd.y + ro.xz);\n    w = 0.8;\n    f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);\n      w *= 0.5;\n      p *= 2.;\n    }\n    cloudFac = clamp (3. * f * rd.y - 0.1, 0., 1.);\n  } else cloudFac = 0.;\n  s = max (dot (rd, sunDir), 0.);\n  col = vec3 (0.1, 0.2, 0.5) + 0.25 * pow (1. - max (rd.y, 0.), 8.) +\n     (0.35 * pow (s, 6.) + 0.65 * min (pow (s, 256.), 0.3));\n  return mix (col, vec3 (1.), cloudFac);\n}\n\nvec3 TrackPath (float z)\n{\n  return vec3 (11. * cos (0.045 * z) * cos (0.032 * z) * cos (0.015 * z),\n     0.5 * cos (0.017 * z) * cos (0.03 * z), z);\n}\n\nfloat GrndDf (vec3 p)\n{\n  vec2 q;\n  float h, a, w;\n  q = 0.05 * p.xz;\n  a = 2.;\n  h = 0.;\n  for (int j = 0; j < 3; j ++) {\n    h += a * Noisefv2 (q);\n    a *= 1.2;\n    q *= 2.;\n  }\n  w = p.x - TrackPath (p.z).x;\n  h = SmoothMin (h, 0.1 * w * w - 0.5, 0.5);\n  q = 0.1 * p.xz;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    h += a * Noisefv2 (q);\n    a *= 0.5;\n    q *= 2.;\n  }\n  return p.y - h;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 200; j ++) {\n    p = ro + s * rd;\n    h = GrndDf (p);\n    if (h < 0.) break;\n    sLo = s;\n    s += 0.2 * h + 0.007 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 6; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., GrndDf (p));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  vec2 e;\n  float h;\n  h = GrndDf (p);\n  e = vec2 (max (0.01, 0.00001 * d * d), 0.);\n  return normalize (vec3 (GrndDf (p + e.xyy) - h, GrndDf (p + e.yxy) - h,\n     GrndDf (p + e.yyx) - h));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d, dMin;\n  dMin = dstFar;\n  for (int j = 0; j < 2; j ++) {\n    q = objMat[j] * (p - objPos[j]);\n    d = max (PrCapsDf (q, 1.1, 2.),\n       - PrCapsDf (q + vec3 (0., -0.2, 0.), 1., 1.9));\n    if (d < dMin) { dMin = d;  idObj = j + 1;  qHit = p; }\n  }\n  q = p;\n  q.x -= TrackPath (p.z).x;\n  q.y -= 2.;\n  q.z = mod (q.z + 20., 40.) - 20.;\n  d = PrTorusDf (q, 0.4, 7.);\n  if (d < dMin) { dMin = d;  idObj = 3;  qHit = p; }\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.4;\n  for (int j = 0; j < 20; j ++) {\n    h = GrndDf (ro + rd * d);\n    sh = min (sh, 30. * h / d);\n    d += 0.4;\n    if (h < 0.001) break;\n  }\n  return max (sh, 0.);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 80; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, 30. * h / d);\n    d += 0.01 + 0.07 * d;\n    if (h < 0.001) break;\n  }\n  return max (sh, 0.);\n}\n\nvec4 ObjCol (vec3 n)\n{\n  vec4 col4;\n  if (idObj == 1) col4 = vec4 (1., 0.3, 0., 0.5);\n  else if (idObj == 2) col4 = vec4 (0.3, 0.3, 1., 0.5);\n  else if (idObj == 3) col4 = vec4 (0.3, 0.7, 0.4, 0.3);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, vns;\n  float dstGrnd, dstObj, gg, dx, dk, bk, dif, sh, spec;\n  int idObjT;\n  dstGrnd = GrndRay (ro, rd);\n  idObj = -1;\n  dstObj = ObjRay (ro, rd);\n  if (idObj < 0) dstObj = dstFar;\n  if (dstObj < dstGrnd) {\n    ro += dstObj * rd;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    col4 = ObjCol (vn);\n    sh = ObjSShadow (ro, sunDir);\n    bk = max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.);\n    col = col4.rgb * (0.2 + 0.1 * bk  + sh * max (dot (vn, sunDir), 0.)) +\n       sh * col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 128.);\n  } else if (dstGrnd < dstFar) {\n    ro += dstGrnd * rd;\n    vn = GrndNf (ro, dstGrnd);\n    gg = smoothstep (0.5, 0.9, vn.y);\n    vn = VaryNf (5. * ro, vn, 0.5);\n    vns = normalize (Noisev3v2 (50. * ro.xz) - 0.5);\n    vns.y = abs (vns.y);\n    spec = 0.8 * gg * pow (max (dot (sunDir, reflect (rd, vns)), 0.), 8.);\n    col = vec3 (1.) * mix (1.2, 1., gg);\n    dx = abs (ro.x - TrackPath (ro.z).x);\n    dk = smoothstep (0., 3., dx);\n    col *= 0.7 + 0.3 * (dk + (1. - dk) * Noisefv2 (vec2 (20. * dx, 0.5 * ro.z)));\n    dif = max (dot (vn, sunDir), 0.);\n    bk = max (0.3 + 0.7 * dot (vn, normalize (vec3 (- sunDir.x, 0.,\n       - sunDir.z))), 0.);\n    sh = min (GrndSShadow (ro, sunDir), ObjSShadow (ro, sunDir));\n    col = col * (0.5 * bk + (0.3 + 0.7 * sh) * dif) + sh * spec * dif;\n  } else col = SkyCol (ro, rd);\n  return pow (clamp (col, 0., 1.), vec3 (0.7));\n}\n\nvoid ObjPM (float t)\n{\n  vec3 vuF, vuB, vel, acc, va, ort, cr, sr;\n  float dt;\n  dt = 1.;\n  oPos = TrackPath (t);\n  vuF = TrackPath (t + dt);\n  vuB = TrackPath (t - dt);\n  vel = (vuF - vuB) / (2. * dt);\n  vel.y = 0.;\n  acc = (vuF - 2. * oPos + vuB) / (dt * dt);\n  acc.y = 0.;\n  oPos.x -= 50. * acc.x;\n  va = cross (acc, vel) / length (vel);\n  ort = vec3 (0., atan (vel.z, vel.x) - 0.5 * pi,\n     10. * length (va) * sign (va.y));\n  cr = cos (ort);\n  sr = sin (ort);\n  oMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\nvec3 GlareCol (vec3 rd, vec3 sd, vec2 uv)\n{\n  vec3 col;\n  if (sd.z > 0.) {\n    vec3 e = vec3 (1., 0., 0.);\n    col = 0.2 * pow (sd.z, 8.) *\n       (1.5 * e.xyy * max (dot (normalize (rd + vec3 (0., 0.3, 0.)), sunDir), 0.) +\n        e.xxy * SmoothBump (0.04, 0.07, 0.07, length (uv - sd.xy)) +\n        e.xyx * SmoothBump (0.15, 0.2, 0.07, length (uv - 0.5 * sd.xy)) +\n        e.yxx * SmoothBump (1., 1.2, 0.07, length (uv + sd.xy)));\n  } else col = vec3 (0.);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 canvas = iResolution.xy;\n  vec2 uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mat3 vuMat;\n  vec3 rd, ro, col;\n  float objSpd, a;\n  a = pi * (0.5 + 0.3 * sin (0.1 * tCur));\n  sunDir = normalize (vec3 (cos (a), 0.5, sin (a)));\n  objSpd = 20.;\n  ObjPM (objSpd * tCur);\n  vuMat = oMat;\n  rd = normalize (vec3 (uv, 2.6)) * vuMat;\n  ro = oPos;\n  ro.y += 4.;\n  ObjPM (objSpd * (tCur + 1.));\n  oPos.y -= GrndDf (oPos) - 1.;\n  objPos[0] = oPos;  objMat[0] = oMat;\n  ObjPM (objSpd * (tCur + 2.));\n  oPos.y -= GrndDf (oPos) - 1.;\n  objPos[1] = oPos;  objMat[1] = oMat;\n  col = ShowScene (ro, rd) + GlareCol (rd, vuMat * sunDir, 0.5 * uv);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBSDz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[262, 262, 286, 286, 333], [335, 335, 360, 360, 539], [541, 541, 566, 566, 925], [927, 927, 956, 956, 1168], [1170, 1170, 1209, 1209, 1426], [1428, 1428, 1473, 1473, 1571], [1573, 1573, 1630, 1630, 1713], [1715, 1715, 1758, 1758, 1831], [1833, 1833, 1879, 1879, 1936], [2047, 2047, 2079, 2079, 2635], [2637, 2637, 2663, 2663, 2788], [2790, 2790, 2813, 2813, 3185], [3187, 3187, 3221, 3221, 3728], [3730, 3730, 3761, 3761, 3953], [3955, 3955, 3977, 3977, 4437], [4439, 4439, 4472, 4472, 4648], [4650, 4650, 4671, 4671, 4894], [4896, 4896, 4934, 4934, 5139], [5141, 5141, 5178, 5178, 5395], [5397, 5397, 5419, 5419, 5612], [5614, 5614, 5649, 5649, 7117], [7119, 7119, 7141, 7141, 7766], [7768, 7768, 7811, 7811, 8242], [8244, 8244, 8300, 8300, 9008]], "test": "error"}
{"id": "llBSWh", "name": "The descent", "author": "rez", "description": "A kind of descent into the center of an unknown planet :)\nThis scene looks intricate and \"fractal\" but in reality it's just simple boolean operations on a bunch of repeated spheres. I spent 99.9% of the time to tweak the last two lines! \\:D/", "tags": ["raymarching"], "likes": 34, "viewed": 1420, "published": "Public", "date": "1443138966", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI=3.14159265358979323846;\n\n#define speed (iTime*0.5)\n#define value (0.4+0.25*cos(PI*speed*0.125))\n\nvec2 rotate(vec2 k,float t)\n\t{\n\treturn vec2(cos(t)*k.x-sin(t)*k.y,sin(t)*k.x+cos(t)*k.y);\n\t}\n\nfloat scene1(vec3 p)\n\t{\n\tfloat dot_p=0.125;\n\tfloat dot_w=dot_p*0.625;\n\tfloat dot=length(mod(p.xyz,dot_p)-dot_p*0.5)-dot_w;\n\tfloat ball_p=1.0;\n\tfloat ball_w=ball_p*(0.6625-0.075*(1.0-value));\n\tfloat ball=length(mod(p.xyz,ball_p)-ball_p*0.5)-ball_w;\n\tfloat hole_w=ball_p*(0.625+0.0125*value);\n\tfloat hole=length(mod(p.xyz,ball_p)-ball_p*0.5)-hole_w;\n\tfloat hole2_p=0.125;\n\tfloat hole2_w=hole2_p*0.375;\n\tfloat hole2=length(mod(p.xyz,hole2_p)-hole2_p*0.5)-hole2_w;\n\treturn max(max(dot,-mix(hole,hole2,0.5)),ball);\n\t}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n\t{\n\tvec2 position=(fragCoord.xy/iResolution.xy);\n\tvec2 p=-1.0+2.0*position;\n\tvec3 vp=normalize(vec3(p*vec2(1.77,1.0),0.75)); // screen ratio (x,y) fov (z)\n\t//vp.yz=rotate(vp.yz,PI*0.125*sin(speed*0.5));\t// rotation x\n\t//vp.zx=rotate(vp.zx,PI*0.125*sin(speed*0.5));\t// rotation y\n\tvp.xy=rotate(vp.xy,speed*0.25);\t\t\t\t\t// rotation z\n\tfloat ground_x=0.0;//1.0+0.05*cos(PI*speed*0.25);\n\tfloat ground_y=0.0;//1.0+0.05*sin(PI*speed*0.25);\n\tfloat ground_z=speed*(0.125+0.375);\n\tvec3 ray=vec3(ground_x,ground_y,ground_z);\n\tfloat t=0.0;\n\tconst int ray_n=96;\n\tfor(int i=0;i<ray_n;i++)\n\t\t{\n\t\tfloat k=scene1(ray+vp*t);\n        if(abs(k)<0.002) break;\n\t\tt+=k*0.7;\n\t\t}\n\tvec3 hit=ray+vp*t;\n\tvec2 h=vec2(-0.1,0.1); // light\n\tvec3 n=normalize(vec3(scene1(hit+h.xyy),scene1(hit+h.yxx),scene1(hit+h.yyx)));\n\tfloat c=(n.x+n.y+n.z)*0.08+t*0.16;\n\tfloat color=-0.25*cos(PI*position.x*2.0)+0.25*sin(PI*position.y);\n\tfragColor=vec4(vec3((c*t+t)*0.5*value+color,c*1.5-t*0.025,c*1.25-t*0.0125*value-color)*c,1.0);\n\t}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBSWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 142, 142, 204], [206, 206, 229, 229, 718], [720, 720, 775, 775, 1761]], "test": "valid"}
{"id": "llBXDW", "name": "Noise Tp1", "author": "clem19s", "description": "Noise", "tags": ["noise"], "likes": 1, "viewed": 95, "published": "Public", "date": "1443618843", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 mod289(vec3 x) {\nreturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x) {\nreturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x) {\nreturn mod289(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\nreturn 1.79284291400159 - 0.85373472095314 * r;\n}\nfloat noise(vec3 v)\n{\nv=0.1*v;\nconst vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\nconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n// First corner\nvec3 i = floor(v + dot(v, C.yyy) );\nvec3 x0 = v - i + dot(i, C.xxx) ;\n// Other corners\nvec3 g = step(x0.yzx, x0.xyz);\nvec3 l = 1.0 - g;\nvec3 i1 = min( g.xyz, l.zxy );\nvec3 i2 = max( g.xyz, l.zxy );\n// x0 = x0 - 0.0 + 0.0 * C.xxx;\n// x1 = x0 - i1 + 1.0 * C.xxx;\n// x2 = x0 - i2 + 2.0 * C.xxx;\n// x3 = x0 - 1.0 + 3.0 * C.xxx;\nvec3 x1 = x0 - i1 + C.xxx;\nvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\nvec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n// Permutations\ni = mod289(i);\nvec4 p = permute( permute( permute(\ni.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\nfloat n_ = 0.142857142857; // 1.0/7.0\nvec3 ns = n_ * D.wyz - D.xzx;\nvec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\nvec4 x_ = floor(j * ns.z);\nvec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\nvec4 x = x_ *ns.x + ns.yyyy;\nvec4 y = y_ *ns.x + ns.yyyy;\nvec4 h = 1.0 - abs(x) - abs(y);\nvec4 b0 = vec4( x.xy, y.xy );\nvec4 b1 = vec4( x.zw, y.zw );\n//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\nvec4 s0 = floor(b0)*2.0 + 1.0;\nvec4 s1 = floor(b1)*2.0 + 1.0;\nvec4 sh = -step(h, vec4(0.0));\nvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\nvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\nvec3 p0 = vec3(a0.xy,h.x);\nvec3 p1 = vec3(a0.zw,h.y);\nvec3 p2 = vec3(a1.xy,h.z);\nvec3 p3 = vec3(a1.zw,h.w);\n//Normalise gradients\nvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\np0 *= norm.x;\np1 *= norm.y;\np2 *= norm.z;\np3 *= norm.w;\n// Mix final noise value\nvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\nm = m * m;\nreturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\ndot(p2,x2), dot(p3,x3) ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n   \tuv.x *= 16.0/9.0; \n\tvec3 origine = vec3(iTime, 0.0, -2.0);\n\tvec3 direction = normalize(vec3(uv, 1.0));\n    \n    vec3 point = origine;\n    \n    vec3 centreLumiere = vec3(1.0,1.0,-1.0);\n\n    \n\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    \n    vec3 dx = vec3(0.1,0.0,0.0);\n    vec3 dy = vec3(0.0,0.1,0.0);\n    vec3 dz = vec3(0.0,0.0,0.1);\n    \n    for(int i = 0; i < 512; i++){\n   \n    \tpoint = point + direction * 0.05;\n        \n    \tif(noise(point) > 0.7){\n            \n     \t\t\n            \n\t\t\tvec3 N = vec3(\n                noise(point-dx)-noise(point+dx),\n                noise(point-dy)-noise(point+dy),\n                noise(point-dz)-noise(point+dz));\n            N = normalize(N);\n            \n            vec3 L = normalize(centreLumiere - point);\n            vec3 R = normalize(2.0*max(dot(N,L),0.0)*N-L);\n            vec3 V = normalize(origine - point);\n           \n            float diffuse = max(dot(L,N), 0.0);\n            float specular = max(pow(dot(R,V), 64.0),0.0);\n                                \n            float intensite = diffuse + specular;\n            \n       \t\tfragColor = vec4(intensite*(vec3(1.0,1.0,1.0)-N),1.0);\n            \n            break;\n        }\n      \n            \n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBXDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 68], [69, 69, 90, 90, 137], [138, 138, 160, 160, 195], [196, 196, 224, 224, 274], [275, 275, 296, 296, 2245], [2248, 2248, 2305, 2305, 3563]], "test": "valid"}
{"id": "llBXDz", "name": "cravo-CheckerGrid", "author": "cravo", "description": "More mind-boggling", "tags": ["2d", "checker"], "likes": 7, "viewed": 131, "published": "Public", "date": "1442855166", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = 64.0;\n    float halfSize = size * 0.5;\n    int ix = int((fragCoord.x + halfSize) / size);\n    int iy = int((fragCoord.y + halfSize) / size);\n    \n    size = size + halfSize * (0.3 * sin(float(ix) + iTime) + 0.7 * cos(float(iy) + iTime));\n    \n\tfloat x = mod(fragCoord.x, size);\n    float y = mod(fragCoord.y, size);\n    \n    if ( (x < halfSize && y < halfSize) || (x > halfSize && y > halfSize) )\n    {\n        fragColor = vec4(1.0,1.0,1.0,1.0);\n    }\n    else\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 595]], "test": "valid"}
{"id": "llBXRD", "name": "Mandelball", "author": "dr2", "description": "Testing the buoyancy of a fractal.", "tags": ["fractal", "raymarch", "water"], "likes": 13, "viewed": 1133, "published": "Public API", "date": "1441962940", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Mandelball\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nmat3 ballMat;\nvec3 ballPos, sunDir, cloudDisp, waterDisp;\nfloat tCur, qStep;\nconst float dstFar = 100.;\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  vec2 p;\n  float sd, w, f;\n  col = vec3 (0.15, 0.25, 0.5) + 0.2 * pow (1. - max (rd.y, 0.), 8.);\n  sd = max (dot (rd, sunDir), 0.);\n  rd.y = abs (rd.y);\n  ro += cloudDisp;\n  p = 0.2 * (rd.xz * (20. - ro.y) / rd.y + ro.xz);\n  w = 1.;\n  f = 0.;\n  for (int j = 0; j < 4; j ++) {\n    f += w * Noisefv2 (p);\n    w *= 0.5;\n    p *= 2.;\n  }\n  col += 0.35 * pow (sd, 6.) + 0.65 * min (pow (sd, 256.), 0.3);\n  return mix (col, vec3 (1.), clamp (0.8 * f * rd.y + 0.1, 0., 1.));\n}\n\nfloat WaveHt (vec3 p)\n{\n  const mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec4 t4, ta4, v4;\n  vec2 q2, t2, v2;\n  float wFreq, wAmp, pRough, ht;\n  wFreq = 0.3;  wAmp = 0.3;  pRough = 5.;\n  q2 = p.xz + waterDisp.xz;\n  ht = 0.;\n  for (int j = 0; j < 4; j ++) {\n    t2 = tCur * vec2 (1., -1.);\n    t4 = vec4 (q2 + t2.xx, q2 + t2.yy) * wFreq;\n    t2 = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * vec4 (t2.xx, t2.yy) - 1.;\n    ta4 = abs (sin (t4));\n    v4 = (1. - ta4) * (ta4 + abs (cos (t4)));\n    v2 = pow (1. - sqrt (v4.xz * v4.yw), vec2 (pRough));\n    ht += (v2.x + v2.y) * wAmp;\n    q2 *= qRot;  wFreq *= 2.;  wAmp *= 0.25;\n    pRough = 0.8 * pRough + 0.2;\n  }\n  return ht;\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  dHit = dstFar;\n  if (rd.y < 0.) {\n    s = 0.;\n    sLo = 0.;\n    for (int j = 0; j < 80; j ++) {\n      p = ro + s * rd;\n      h = p.y - WaveHt (p);\n      if (h < 0.) break;\n      sLo = s;\n      s += max (0.3, h) + 0.005 * s;\n      if (s > dstFar) break;\n    }\n    if (h < 0.) {\n      sHi = s;\n      for (int j = 0; j < 4; j ++) {\n        s = 0.5 * (sLo + sHi);\n        p = ro + s * rd;\n        h = step (0., p.y - WaveHt (p));\n        sLo += h * (s - sLo);\n        sHi += (1. - h) * (s - sHi);\n      }\n      dHit = sHi;\n    }\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e = vec2 (max (0.1, 0.01 * d), 0.);\n  float h = WaveHt (p);\n  return normalize (vec3 (h - WaveHt (p + e.xyy), e.x, h - WaveHt (p + e.yyx)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  float mScale = 2.;\n  vec4 q, q0;\n  const int nIter = 12;\n  p *= ballMat;\n  p -= ballPos;\n  q0 = vec4 (p, 1.);\n  q = q0;\n  for (int n = 0; n < nIter; n ++) {\n    q.xyz = clamp (q.xyz, -1., 1.) * 2. - q.xyz;\n    q = q * mScale / clamp (dot (q.xyz, q.xyz), 0.5, 1.) + q0;\n  }\n  return max (length (q.xyz) / abs (q.w), length (p) - 6.);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const int nStep = 100;\n  float dHit, h, s;\n  dHit = 0.;\n  s = 0.;\n  for (int j = 0; j < nStep; j ++) {\n    h = ObjDf (ro + dHit * rd);\n    dHit += h;\n    ++ s;\n    if (h < 0.001 || dHit > dstFar) break;\n  }\n  if (h >= 0.001) dHit = dstFar;\n  qStep = s / float (nStep);\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.01, -0.01, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 c1 = vec3 (1.5, 0.2, 0.), c2 = vec3 (0.1, 0.55, 0.5);\n  vec3 col, vn;\n  float dstObj, dstWat;\n  col = vec3 (1.);\n  dstObj = ObjRay (ro, rd);\n  dstWat = WaveRay (ro, rd);\n  if (dstObj < min (dstWat, dstFar)) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    rd = reflect (rd, vn);\n    col = mix (c1, col, max (0., 1. - 1.3 * qStep));\n    dstWat = WaveRay (ro, rd);\n    if (dstWat < dstFar) {\n      ro += rd * dstWat;\n      vn = WaveNf (ro, dstWat);\n      rd = reflect (rd, vn);\n      col = mix (c2, col, pow (1. - abs (dot (rd, vn)), 5.));\n    }\n  } else if (dstWat < min (dstObj, dstFar)) {\n    ro += rd * dstWat;\n    vn = WaveNf (ro, dstWat);\n    rd = reflect (rd, vn);\n    col = mix (c2, col, pow (1. - abs (dot (rd, vn)), 5.));\n    dstObj = ObjRay (ro, rd);\n    if (dstObj < dstFar) {\n      ro += rd * dstObj;\n      vn = ObjNf (ro);\n      rd = reflect (rd, vn);\n      col = mix (c1, col, max (0., 1. - 1.3 * qStep));\n    }\n  }\n  col *= SkyCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid BallPM ()\n{\n  const vec3 e = vec3 (4., 0., 0.);\n  float h[5], b, a, c, s;\n  ballPos = vec3 (0.);\n  h[0] = WaveHt (ballPos);\n  h[1] = WaveHt (ballPos + e.yyx);  h[2] = WaveHt (ballPos - e.yyx);\n  h[3] = WaveHt (ballPos + e);  h[4] = WaveHt (ballPos - e);\n  ballPos.y = 0.5 + (2. * h[0] + h[1] + h[2] + h[3] + h[4]) / 6.;\n  b = (h[1] - h[2]) / (2. * e.x);\n  ballMat[2] = normalize (vec3 (0., b, 0.5));\n  b = (h[3] - h[4]) / (2. * e.x);\n  ballMat[1] = normalize (cross (ballMat[2], vec3 (0.5, b, 0.)));\n  ballMat[0] = cross (ballMat[1], ballMat[2]);\n  a = 0.4 * sin (0.03 * tCur);\n  c = cos (a);\n  s = sin (a);\n  ballMat *= mat3 (c, 0., s, 0., 1., 0., - s, 0., c);\n  ballPos.y += 4. * sin (0.1 * tCur) - 1.;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  vec3 ro, rd;\n  sunDir = normalize (vec3 (1., 1., -1.));\n  cloudDisp = tCur * vec3 (0., 0., 1.);\n  waterDisp = 0.2 * tCur * vec3 (-1., 0., 1.);\n  rd = normalize (vec3 (uv, 2.));\n  ro = vec3 (0., 3., -20.);\n  rd.xz = Rot2D (rd.xz, - pi / 4.);\n  ro.xz = Rot2D (ro.xz, - pi / 4.);\n  BallPM ();\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBXRD.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[265, 265, 289, 289, 336], [338, 338, 363, 363, 542], [544, 544, 574, 574, 648], [755, 755, 787, 787, 1270], [1272, 1272, 1295, 1295, 1960], [1962, 1962, 1996, 1996, 2584], [2586, 2586, 2617, 2617, 2767], [2769, 2769, 2791, 2791, 3128], [3130, 3130, 3163, 3163, 3451], [3453, 3453, 3474, 3474, 3680], [3682, 3682, 3717, 3717, 4712], [4714, 4714, 4730, 4730, 5425], [5427, 5427, 5483, 5483, 5932]], "test": "error"}
{"id": "llBXW1", "name": "Wobbly Experiment", "author": "Kosmokleaner", "description": "normally you would write a loop to get many xy position from the input function   but here I tried the inverse", "tags": ["sin"], "likes": 5, "viewed": 137, "published": "Public", "date": "1443225347", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 func(float t)\n{\n    float w = t * 3.14159265 *2.0; \n    \n    vec2 main = vec2(sin(w + iTime*0.8),cos(w*3.0));\n    vec2 sec = vec2(sin(w *4.0),cos(w *4.0 + iTime*9.2)) * 0.2;\n        \n    return main+sec;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 pos = uv * 3.0 - 1.5;\n\n    const int count = 150;\n    \n    float g = 0.0;\n    \n    float rnd = rand(uv);\n\n    for(int i = 0 ; i < count; ++i)\n    {\n        float f = float(i) / float(count) + rnd + iTime * 0.01;\n        \n        vec2 p = func(f);\n\n        float dist = length((pos-p)*vec2(1.6,0.9)) * 20.0;\n\n        float w = max(0.0, exp(-dist*dist)-0.01);\n        \n        g+=w;\n    }\n    \n    \n    \n  \tfragColor = vec4(0,g,0,0);\n        \n//\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBXW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 210], [212, 212, 232, 232, 304], [307, 307, 364, 364, 911]], "test": "valid"}
{"id": "llBXzW", "name": "Intergalactic", "author": "Passion", "description": "A mash up of several shaders here. Shaders used are at the top of the source code.", "tags": ["raymarch", "scattering", "atmospheric"], "likes": 12, "viewed": 388, "published": "Public", "date": "1441926003", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* -------------------------------\n  \n  Shaders used\n  'Atmospheric Scattering Sample' from \n  https://www.shadertoy.com/view/lslXDr - gltracy\n\n  cloud coverage from '2d Fast Clouds' \n  https://www.shadertoy.com/view/XsjSRt - Sinuousity\n\n  smooth and cheap 3d starfield from 'Fancy ties' \n  https://www.shadertoy.com/view/ltfGDs - nimitz\n\n  Fisheye lens effect from 'Cypher'\n  https://www.shadertoy.com/view/MlsGRS - dila\n\n  sun-sunIntensity from 'Kepler 256o'\n  https://www.shadertoy.com/view/XsjGRd - otaviogood\n\n  --------------------------------- */\n\nconst float fov = 1.5;\n//Global material id (keeps code cleaner)\nfloat matid = 0.;\n\n// math const\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\nconst float MAX = 10000.0;\n\nvec3 sunCol = vec3(258.0, 208.0, 100.0) / 15.0;\n\n\n// scatter const\nconst float K_R = 0.166;\nconst float K_M = 0.0025;\nconst float E = 14.3; \t\t\t\t\t\t// light intensity\nconst vec3  C_R = vec3( 0.3, 0.7, 1.0 ); \t// 1 / wavelength ^ 4\nconst float G_M = -0.85;\t\t\t\t\t// Mie g\n\nconst float R = 2.0;\nconst float R_INNER = 1.8;\nconst float SCALE_H = 4.0 / ( R - R_INNER );\nconst float SCALE_L = 1.0 / ( R - R_INNER );\n\nconst int NUM_OUT_SCATTER = 10;\nconst float FNUM_OUT_SCATTER = 10.0;\n\nconst int NUM_IN_SCATTER = 10;\nconst float FNUM_IN_SCATTER = 10.0;\nfloat time = iTime*1.3;\nconst float eps = 0.001;\n\n//2d Fast Clouds const\n//SETTINGS//\nconst float timeScale = 30.0;\nconst float cloudScale = 0.5;\nconst float skyCover = 0.6; //overwritten by mouse x drag\nconst float softness = 0.2;\nconst float brightness = 1.0;\nconst int noiseOctaves = 8;\nconst float curlStrain = 3.0;\n//SETTINGS//\n\nvec3 light = normalize(vec3(-.5, 0.2, -0.2));\n\nfloat pi = 3.14159265359;\n\nfloat radian = (time*pi)/180.0; \nfloat mx = iMouse.x/55.;\nfloat my = iMouse.y/55.;\n\nmat3 ry = mat3(cos(radian*32.-mx), 0.0,-sin(radian*32.-mx),\n\t\t\t   0.0, 1.0, 0.0, \n\t\t\t   sin(radian*32.-mx), 0.0, cos(radian*32.-mx)  );\n     \nmat3 rx = mat3(1.0, 0.0, 0.0,\n\t\t\t   0.0, cos(radian*13.-my), sin(radian*13.-my), \n\t\t\t   0.0,-sin(radian*13.-my), cos(radian*13.-my) );\n// ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// ray intersects sphere\n// e = -b +/- sqrt( b^2 - c )\nvec2 ray_vs_sphere( vec3 p, vec3 dir, float r ) {\n\tfloat b = dot( p, dir );\n\tfloat c = dot( p, p ) - r * r;\n\t\n\tfloat d = b * b - c;\n\tif ( d < 0.0 ) {\n\t\treturn vec2( MAX, -MAX );\n\t}\n\td = sqrt( d );\n\t\n\treturn vec2( -b - d, -b + d );\n}\n\n// Mie\n// g : ( -0.75, -0.999 )\n//      3 * ( 1 - g^2 )               1 + c^2\n// F = ----------------- * -------------------------------\n//      2 * ( 2 + g^2 )     ( 1 + g^2 - 2 * g * c )^(3/2)\nfloat phase_mie( float g, float c, float cc ) {\n\tfloat gg = g * g;\n\t\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\n\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n\tb *= sqrt( b );\n\tb *= 2.0 + gg;\t\n\t\n\treturn 1.5 * a / b;\n}\n\n// Reyleigh\n// g : 0\n// F = 3/4 * ( 1 + c^2 )\nfloat phase_reyleigh( float cc ) {\n\treturn 0.75 * ( 1.0 + cc );\n}\n\nfloat density( vec3 p ){\n\treturn exp( -( length( p ) - R_INNER ) * SCALE_H );\n}\n\nfloat optic( vec3 p, vec3 q ) {\n\tvec3 step = ( q - p ) / FNUM_OUT_SCATTER;\n\tvec3 v = p + step * 0.5;\n\t\n\tfloat sum = 0.0;\n\tfor ( int i = 0; i < NUM_OUT_SCATTER; i++ ) {\n\t\tsum += density( v );\n\t\tv += step;\n\t}\n\tsum *= length( step ) * SCALE_L;\n\t\n\treturn sum;\n}\n//from 'Atmospheric Scattering Sample'\n//https://www.shadertoy.com/view/lslXDr - gltracy\nvec3 in_scatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {\n\tfloat len = ( e.y - e.x ) / FNUM_IN_SCATTER;\n\tvec3 step = dir * len;\n\tvec3 p = o + dir * e.x;\n\tvec3 v = p + dir * ( len * 0.5 );\n\n\tvec3 sum = vec3( 0.0 );\n\tfor ( int i = 0; i < NUM_IN_SCATTER; i++ ) {\n\t\tvec2 f = ray_vs_sphere( v, l, R );\n\t\tvec3 u = v + l * f.y;\n\t\t\n\t\tfloat n = ( optic( p, v ) + optic( v, u ) ) * ( PI * 4.0 );\n\t\t\n\t\tsum += density( v ) * exp( -n * ( K_R * C_R + K_M ) );\n\n\t\tv += step;\n\t}\n\tsum *= len * SCALE_L;\n\t\n\tfloat c  = dot( dir, -l );\n\tfloat cc = c * c;\n\t\n\treturn sum * ( K_R * C_R * phase_reyleigh( cc ) + K_M * phase_mie( G_M, c, cc ) ) * E;\n}\n//Random function\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n//Noise function\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n//From Dave_Hoskins\nvec2 hash22(vec2 p){\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec3 hash33(vec3 p){\n\tp  = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p += dot(p.yzx, p.xyz  + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p.x * p.z * 95.4337, p.x * p.y * 97.597, p.y * p.z * 93.8365));\n}\n//--------------------Utility, Domain folding and Primitives---------------------\nfloat tri(in float x){return abs(fract(x)-.5);}\n//smooth and cheap 3d starfield\n//from 'Fancy ties'\n//https://www.shadertoy.com/view/ltfGDs - nimitz\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*.85*fov;\n    \n    //Triangular deformation (used to break sphere intersection pattterns)\n    p.x += (tri(p.z*50.)+tri(p.y*50.))*0.006;\n    p.y += (tri(p.z*50.)+tri(p.x*50.))*0.006;\n    p.z += (tri(p.x*50.)+tri(p.y*50.))*0.006;\n\tfor (float i=0.;i<3.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        float rn = hash33(id).z;\n        float c2 = 1.-smoothstep(-0.2,.4,length(q));\n        c2 *= step(rn,0.005+i*0.014);\n        c += c2*(mix(vec3(1.0,0.75,0.5),vec3(0.85,0.9,1.),3.*rn*30.)*0.5 + 0.5);\n        p *= 1.15;\n    }\n    \n    return c*c*1.5*6.;\n}\n\nfloat distanceFunction(vec3 pos){\n    return length(pos) - R_INNER;\n}\n \nvec3 getNormal(vec3 p)\n{\n    const float d = eps;\n    return\n        normalize\n        (\n            vec3\n            (\n                distanceFunction(p+vec3(d,0.0,0.0))-distanceFunction(p+vec3(-d,0.0,0.0)),\n                distanceFunction(p+vec3(0.0,d,0.0))-distanceFunction(p+vec3(0.0,-d,0.0)),\n                distanceFunction(p+vec3(0.0,0.0,d))-distanceFunction(p+vec3(0.0,0.0,-d))\n            )\n        );\n}\n \n\n\nfloat saturate(float num)\n{\n    return clamp(num,0.0,1.0);\n}\n\nfloat noised(vec2 uv)\n{\n    return texture(iChannel0,uv).r;\n}\n\nvec2 rotate(vec2 uv)\n{\n    uv = uv + noised(uv*0.2)*0.005;\n    float rot = curlStrain;\n    float sinRot=sin(rot);\n    float cosRot=cos(rot);\n    mat2 rotMat = mat2(cosRot,-sinRot,sinRot,cosRot);\n    return uv * rotMat;\n}\n\nfloat fbm (vec2 uv)\n{\n    float rot = 1.57;\n    float sinRot=sin(rot);\n    float cosRot=cos(rot);\n    float f = 0.0;\n    float total = 0.0;\n    float mul = 0.5;\n    mat2 rotMat = mat2(cosRot,-sinRot,sinRot,cosRot);\n    \n    for(int i = 0;i < noiseOctaves;i++)\n    {\n        f += noised(uv+iTime*0.00015*timeScale*(1.0-mul))*mul;\n        total += mul;\n        uv *= 3.0;\n        uv=rotate(uv);\n        mul *= 0.5;\n    }\n    return f/total;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 pos = (fragCoord.xy*2.0 -iResolution.xy) / iResolution.y;\n    vec3 camPos = vec3(0.0, 0.0, -3.0-sin(time*.5)*.5) * rx*ry;\n    vec3 camDir = vec3(0.0, 0.0, -1.0);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Fisheye lens effect from 'Cypher'\n\t//https://www.shadertoy.com/view/MlsGRS - dila\n    vec3 eye = normalize(vec3(uv, 1.0 - dot(uv,uv) * 0.33)); \n    //camDir *= rx*ry;//*ry;//*rx;\n    //camUp  *= rx*ry;//*ry;//*rx;\n\n    vec3 camSide = cross(camDir, camUp);\n    float focus = 1.5;\n\n    vec3 rayDir;// =  normalize(camSide*pos.x + camUp*pos.y + camDir*focus)*rx*ry;  \n    eye*=rx*ry;\n    float t = 0.0, d;\n    rayDir=eye;\n    vec3 posOnRay = camPos;\n    float dense = 16.0;\n    \n    //sun-sunIntensity from 'Kepler 256o'\n    //https://www.shadertoy.com/view/XsjGRd - otaviogood\n    vec3 localRay = normalize(rayDir);\n    float sunIntensity = 1.0 - (dot(localRay, light) * 0.5 + 0.5);\n    //sunIntensity = (float)Math.Pow(sunIntensity, 14.0);\n    sunIntensity = 0.2 / sunIntensity;\n    sunIntensity = min(sunIntensity, 40000.0);\n    sunIntensity = max(0.0, sunIntensity - 3.0);\n    //////////////////////////////////////////////////\n    \n    for(int i=0; i<32; ++i){\n        d = distanceFunction(posOnRay);\n        t += d;\n        posOnRay = camPos + t*rayDir;\n        if(d < eps){ break; }\n    }\n    \n  \n    vec3 normal = getNormal(posOnRay);\n    vec2 e = ray_vs_sphere( camPos, rayDir, R );\n\t\n\tvec2 f = ray_vs_sphere( camPos, rayDir, R_INNER );\n\te.y = min( e.y, f.x );\n    //////////////////////\n    vec2 screenUv = fragCoord.xy/iResolution.xy;\n    vec2 uv2 = fragCoord.xy/(40000.0*cloudScale);\n    \n    float mouseXAffect = (iMouse.x/iResolution.x);\n    \n    float cover = 0.55;\n    \n    float bright = brightness*(1.8-cover);\n    \n    //cloud coverage from '2d Fast Clouds' \n    //https://www.shadertoy.com/view/XsjSRt - Sinuousity\n    float color1 = fbm((posOnRay.yz*.015)-0.5+iTime*0.00004*timeScale);  //xz\n    float color2 = fbm((posOnRay.zy*.015)-10.5+iTime*0.00002*timeScale); //yz\n    \n    float clouds1 = smoothstep(1.0-cover,min((1.0-cover)+softness*2.0,1.0),color1);\n    float clouds2 = smoothstep(1.0-cover,min((1.0-cover)+softness,1.0),color2);\n    \n    float cloudsFormComb = saturate(clouds1+clouds2);\n    \n    vec4 skyCol = vec4(0.6,0.8,1.0,1.0);\n    float cloudCol = saturate(saturate(1.0-pow(color1,1.0)*0.2)*bright);\n    vec4 clouds1Color = vec4(cloudCol,cloudCol,cloudCol,1.0);\n    vec4 clouds2Color = mix(clouds1Color,skyCol,0.25);\n    vec4 cloudColComb = mix(clouds1Color,clouds2Color,saturate(clouds2-clouds1));\n    vec4 clouds = vec4(0.0);\n\tclouds = mix(skyCol,cloudColComb,cloudsFormComb);\n\tvec3 I = in_scatter( camPos, rayDir, e, light );\n    \n    if(abs(d) < eps){\n        float diffuse = clamp( dot(normal, light), 0.015, 1.);\n        float specular = 1.5*pow(clamp(dot(reflect(rayDir, normal), light), 0., 1.), 30.);\n        vec3 brdf = 1.5*vec3(.10, .11, .11);\n        float fre = 0.1*pow(clamp(1. + dot(normal, rayDir), 0., 1.), 2.);\n        brdf += 1.30*diffuse*vec3(1., .9, .75);\n        vec3 spe = vec3(1.0,0.8,0.7)*specular;\n        fragColor = vec4((I*.025)+clouds.rgb*diffuse+spe+brdf*fre, 1.0);  //+specular2+fre+brdf\n    } else {\n        fragColor = vec4(0.0);\n        fragColor.rgb+=stars(rayDir*.35); //.4\n        fragColor.rgb+=I;\n        fragColor.rgb += sunCol*(sunIntensity*.0025);\n    }\n} \n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBXzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2063, 2080, 2128, 2128, 2304], [2306, 2361, 2410, 2410, 2593], [2595, 2790, 2837, 2837, 2993], [2995, 3041, 3075, 3075, 3106], [3108, 3108, 3132, 3132, 3187], [3189, 3189, 3220, 3220, 3446], [3447, 3536, 3589, 3589, 4158], [4159, 4177, 4197, 4197, 4264], [4265, 4282, 4303, 4303, 4500], [4501, 4521, 4541, 4541, 4696], [4698, 4698, 4718, 4718, 4913], [4914, 4996, 5018, 5018, 5043], [5044, 5145, 5168, 5168, 5820], [5822, 5822, 5855, 5855, 5891], [5894, 5894, 5918, 5918, 6309], [6314, 6314, 6341, 6341, 6374], [6376, 6376, 6399, 6399, 6437], [6439, 6439, 6461, 6461, 6659], [6661, 6661, 6682, 6682, 7101], [7104, 7104, 7161, 7161, 10629]], "test": "error"}
{"id": "lljSRw", "name": "Progressive Mandelbrot", "author": "roombarampage", "description": "progressively renders the mandelbrot set with increasing detail as the max iterations increases with time.", "tags": ["fractal", "mandelbrot", "progressive"], "likes": 1, "viewed": 147, "published": "Public", "date": "1442553807", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n  programmer: jonathan potter\n  github: https://github.com/jonathan-potter\n  repo: https://github.com/jonathan-potter/shadertoy-fractal\n*/\n\nconst int MAX_ITERATIONS = 64;\nconst float ITERATIONS_PER_SECOND = 32.0;\nconst float pi = 3.14159;\n    \nfloat modulus(float number, float divisor) {\n  float integerQuotient = floor(number / divisor);\n    \n  return number - (integerQuotient * divisor);\n}\n\nfloat rampFunction(float t) {\n  float animationPeriod = float(MAX_ITERATIONS);\n    \n  return modulus(t, animationPeriod);\n}\n\nstruct complex { \n  float real;\n  float imaginary;\n};\n\nint fractal(complex c, complex z, int iterations) {\n  for (int iteration = 0; iteration < MAX_ITERATIONS; iteration++) {\n    if (iteration >= iterations) {return 0;}\n\n    // z <- z^2 + c\n    float real = z.real * z.real - z.imaginary * z.imaginary + c.real;\n    float imaginary = 2.0 * z.real * z.imaginary + c.imaginary;\n\n    z.real = real;\n    z.imaginary = imaginary;\n\n    if (z.real * z.real + z.imaginary * z.imaginary > 4.0) {\n      return iteration;\n    }\n  }\n\n  return 0;\n}\n\nint mandelbrot(vec2 coordinate, int iterations) {\n  complex c = complex(coordinate.x, coordinate.y);\n  complex z = complex(0.0, 0.0);\n\n  return fractal(c, z, iterations);\n}\n\nvec2 fragCoordToXY(vec2 fragCoord) {\n  vec2 relativePosition = fragCoord.xy / iResolution.xy;\n  float aspectRatio = iResolution.x / iResolution.y;\n\n  vec2 cartesianPosition = (relativePosition - 0.5) * 3.0;\n  cartesianPosition.x *= aspectRatio;\n\n  return cartesianPosition;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  int iterations = int(floor(rampFunction((ITERATIONS_PER_SECOND + iTime * ITERATIONS_PER_SECOND))));\n    \n  vec2 coordinate = fragCoordToXY(fragCoord);\n\n  int crossoverIteration = mandelbrot(coordinate, iterations);\n    \n  float color = 1.0 * float(crossoverIteration) / float(iterations);\n\n  fragColor = vec4(color, color, color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljSRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 291, 291, 396], [398, 398, 427, 427, 521], [578, 578, 629, 629, 1059], [1061, 1061, 1110, 1110, 1233], [1235, 1235, 1271, 1271, 1510], [1512, 1512, 1569, 1569, 1909]], "test": "valid"}
{"id": "lljSzR", "name": "Hex + Creation by Silexars", "author": "Mx7f", "description": "Lightweight mashup of the amazing \"Creation by Silexars\" (https://www.shadertoy.com/view/XsXXDn) and simple hexagonal distance function. Wanted a cool demo of the hex distance shader modification hack, and Creation was the obvious choice.", "tags": ["distance", "hex", "creation"], "likes": 21, "viewed": 638, "published": "Public", "date": "1441150771", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hexLength(vec2 v) {\n\tvec2 a = abs(v);\n\treturn max((2.0/sqrt(3.0))*a.x, (1.0/sqrt(3.0))*a.x + a.y);\n}\n\n#define length hexLength\n\n// Below is *identical* to Creation by Silexars (https://www.shadertoy.com/view/XsXXDn)\n// http://www.pouet.net/prod.php?which=57245\n\n#define t iTime\n#define r iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 c;\n\tfloat l,z=t;\n\tfor(int i=0;i<3;i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p;\n\t\tp-=.5;\n\t\tp.x*=r.x/r.y;\n\t\tz+=.07;\n\t\tl=length(p);\n\t\tuv+=p/l*(sin(z)+1.)*abs(sin(l*9.-z*2.));\n\t\tc[i]=.01/length(abs(mod(uv,1.)-.5));\n\t}\n\tfragColor=vec4(c/l,t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljSzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 106], [310, 310, 366, 366, 610]], "test": "valid"}
{"id": "lljXRR", "name": "HAPPY BIRTHDAY LUKE", "author": "cabbibo", "description": "Taking IQ's Cloud shader: https://www.shadertoy.com/view/XslGRr#\n\nAnd making it as weird as possible!", "tags": ["volumetric", "raytrace", "smoothmin"], "likes": 3, "viewed": 208, "published": "Public", "date": "1441132638", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Everything cool comes from: https://www.shadertoy.com/view/XslGRr#\n\n\nconst float MAX_TRACE_DISTANCE = 6.0;             // max trace distance\nconst float INTERSECTION_PRECISION = 0.01;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\nconst int FOG_STEPS = 40;\nconst float PI = 3.14159;\n\nvec3 sundir = normalize( vec3(-1.0,0.0,-1.0) );\n\nmat3 zrotate(float t) {\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\n\nmat4 translate(vec3 t)\n{\n\treturn mat4(1.0, 0.0, 0.0, -t.x, 0.0, 1.0, 0.0, -t.y, 0.0, 0.0, 1.0, -t.z, 0.0, 0.0, 0.0, 1.0);\n}\n\nfloat box(vec3 p, vec3 s)\n{ \n    vec3 w = abs(p) - s/2.0;\n    return min(max(w.x,max(w.y,w.z)),0.0) + length(max(w,0.0));   \n}\n\n\nfloat sdCap( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat luke( vec3 inP ){\n    \n    float smoothAmount = .1 + sin( iTime  * .3 ) * .05;\n    \n    \n    vec3 p = inP + vec3( \n          sin( length(inP.xy) * 10. + iTime ) * .1 \n        , sin( length(inP.yz) * 10. + iTime ) * .1  \n        , sin( length(inP.xyz) * 10. + iTime ) * .1 \n    );\n    \n    \n    \n    p = inP + vec3( \n          sin( length(inP.xzy * sin( p.x * 1. )) * 3. + iTime ) * .1 \n        , sin( length(inP.yz) * 1. + iTime ) * .3  \n        , sin( length(inP.xyz) * 4. + iTime ) * .3 \n    ); \n    \n    ///p = inP;\n    \n    \n    \n    vec3 startPos = vec3( -.25 , -0.2 , -0.5 );\n    \n    \n    \n    \n    //--------------------------------\n\t// L\n\t//--------------------------------\n    vec3 pos =  startPos - vec3(1.5 , 0. , 0. );\n    \n    \n    float l = smin( \n        \n        sdCap( p , pos + vec3( .0 ,-.5 , 0. ) , pos + vec3( .0 , 0.5 , 0. ), .1 ),\n        sdCap( p , pos + vec3( 0. , -.5 , 0. ), pos + vec3( .5 , -0.5 , 0. ), .1 ),\n        smoothAmount\n        /*box( p + pos , vec3(.1 , 1. , .1 )),\n        box( p + pos + vec3(-.2 , .5 , 0. ) , vec3(.5 , .1 , .1 ))*/\n    );\n    \n    \n    \n    //--------------------------------\n\t// U\n\t//--------------------------------\n    pos =  startPos - vec3(.5 , 0. , 0. );\n    \n    \n    float u =smin( \n        \n        sdCap( p , pos + vec3(.0 ,-.5 , 0. ) , pos + vec3( .0 , 0.5 , 0. ), .1 ),\n        sdCap( p , pos + vec3( 0. , -.5 , 0. ), pos + vec3( .5 , -0.5 , 0. ),.1 ),\n         smoothAmount\n    );\n    \n    u = smin( u ,sdCap( p , pos + vec3( 0.5 , -.5 , 0. ), pos + vec3( .5 , .5 , 0. ),.1 ) , smoothAmount);\n            \n    \n    \n        \n    //--------------------------------\n\t// k\n\t//--------------------------------\n    pos =  startPos - vec3(-.5 , 0. , 0. );\n    \n    \n    float k =smin( \n        \n        sdCap( p , pos + vec3(.0 ,-.5 , 0. ) , pos + vec3( .0 , 0.5 , 0. ), .1 ),\n        sdCap( p , pos + vec3( 0. , 0. , 0. ), pos + vec3( .6 , 0.5 , 0. ),.1 ),\n         smoothAmount\n    );\n    \n    k = smin( k ,sdCap( p , pos + vec3( 0. , 0. , 0. ), pos + vec3( .6 , -.5 , 0. ),.1 ) , smoothAmount );\n            \n    \n            \n           \n    //--------------------------------\n\t// k\n\t//--------------------------------\n    pos =  startPos - vec3(-1.5 , 0. , 0. );\n    \n    \n    float e =smin( \n        \n        sdCap( p , pos + vec3(.0 ,-.5 , 0. ) , pos + vec3( .0 , 0.5 , 0. ), .1 ),\n        sdCap( p , pos + vec3( 0. , 0.5 , 0. ), pos + vec3( .5 , 0.5 , 0. ),.1 ),\n         smoothAmount\n    );\n    \n    e = smin( e ,sdCap( p , pos + vec3( 0. , 0. , 0. ), pos + vec3( 0.5 , .0 , 0. ),.1 ) , smoothAmount);\n    e = smin( e ,sdCap( p , pos + vec3( 0. , -0.5 , 0. ), pos + vec3( 0.5 , -0.5, 0. ),.1 ) , smoothAmount );\n        \n    \n            \n    \n\n    \n    return min(min(min(l,u),k),e);\n    \n    \n    \n}\n\nfloat tree( vec3 inP ){\n    \n    vec3 p = inP + vec3( \n          sin( length(inP.xy) * 10. + iTime ) * .1 \n        , sin( length(inP.yz) * 10. + iTime ) * .1  \n        , sin( length(inP.xyz) * 10. + iTime ) * .1 \n    );\n    \n    \n    \n    p = inP + vec3( \n          sin( length(inP.xzy * sin( p.x * 1. )) * 3. + iTime ) * .1 \n        , sin( length(inP.yz) * 1. + iTime ) * .3  \n        , sin( length(inP.xyz) * 4. + iTime ) * .3 \n    );\n    \n    // p = inP;\n    \n    \n    vec3 startPos = vec3( .25 , 0.2 , 0.5 );\n    \n    \n    \n    \n    //--------------------------------\n\t// T\n\t//--------------------------------\n    vec3 pos =  startPos + vec3(1.5 , 0. , 0. );\n    \n    \n    \n    \n  \tfloat t = min( \n        box( p + pos , vec3(.1 , 1. , .1 )),\n        box( p + pos + vec3(0. , -.5 , 0. ) , vec3(1. , .1 , .1 ))\n    );\n    \n    \n\n    \n    //--------------------------------\n\t// R\n\t//--------------------------------\n    pos = startPos +  vec3(.5 , 0. , 0. );\n   \n\n  /*  p = inP + vec3( \n          sin( length(inP.xzy * sin( p.x * 1. )) * 3. + iTime ) * .1 \n        , sin( length(inP.yz) * 1. + iTime ) * .3  \n        , sin( length(inP.xyz) * 4. + iTime ) * .3 \n    );*/\n    \n    \n    float r = min(\n        box( p + pos , vec3(.1 , 1. , .1 )),\n        box( p + pos + vec3(-.2 , -.5 , 0. ) , vec3(.5 , .1 , .1 ))\n    );\n    \n    r = min( r , box( p + pos + vec3(-.4 , -.25 , 0. ) , vec3(.1 , .5 , .1 )));\n    r = min( r , box( p + pos + vec3(-.2 , 0. , 0. ) , vec3(.5 , .1 , .1 )));\n    \n    mat3 rot = zrotate( -.9 );\n    \n    r = min( r , box( rot * ( p + pos + vec3(-.23 , 0.23 , 0. )) , vec3(.65 , .1 , .1 )));\n    \n    \n    //--------------------------------\n\t// E\n\t//--------------------------------\n    \n    pos = startPos + vec3( -.5 , 0. , 0. );\n    \n    /*p = inP + vec3( \n          sin( length(inP.xy) * 13. + iTime ) * .1 \n        , sin( length(inP.yz) * 15. + iTime ) * .1  \n        , sin( length(inP.xyz) * 41. + iTime ) * .05 \n    );*/\n    \n    \n    float e1 = min( \n        box( p + pos , vec3(.1 , 1. , .1 )), \n        box( p + pos + vec3(-.2 , -.5 , 0. ) , vec3(.5 , .1 , .1 ))\n    );\n    e1 = min( e1 , box( p + pos + vec3(-.2 , 0. , 0. ) , vec3(.5 , .1 , .1 )));\n    e1 = min( e1 , box( p + pos + vec3(-.2 , 0.5 , 0. ) , vec3(.5 , .1 , .1 )));\n\n    \n    //--------------------------------\n\t// E\n\t//--------------------------------\n    pos = startPos + vec3( -1.5 , 0. , 0. );\n      \n    /*p = inP + vec3( \n          sin( length(inP.xy) * 43. + iTime ) * .03\n        , sin( length(inP.yz) * 15. + iTime ) * .1  \n        , sin( length(inP.xyz) * 11. + iTime ) * .1 \n    );*/\n    \n    \n    float e2 = min( \n        box( p + pos , vec3(.1 , 1. , .1 )), \n        box( p + pos + vec3(-.2 , -.5 , 0. ) , vec3(.5 , .1 , .1 ))\n    );\n    \n    e2 = min( e2 , box( p + pos + vec3(-.2 , 0. , 0. ) , vec3(.5 , .1 , .1 )));\n    e2 = min( e2 , box( p + pos + vec3(-.2 , 0.5 , 0. ) , vec3(.5 , .1 , .1 )));\n            \n    return min(min( min( t,r), e1),e2);\n          \n    \n}\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\n\n\nvec3 hsv(float h, float s, float v)\n{\n    \n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n   \t//vec2 res = vec2( (abs(sin( pos.x * pos.y * pos.z  * 10.)) * 1.9 ) + length( pos ) - 1., 0.0 );\n  \n \n    \n    vec2 res = vec2( luke( pos ) , 1. );\n    \n \n    \n    /*\n    for( int i = 0; i < lightNum; i++ ){\n    \n        float d = length( pos - lightPos[i] );\n        vec2 res2 =vec2( d - (pow(((sin(float( i) + 4.*sin( iTime ))) / float(lightNum)) , 2.) * 8.5 + .1) , 1. ); \n        res = opU( res ,  res2 );\n        \n    }*/\n    \n   \treturn res;\n    \n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 1.0*mouseX;\n\t//camPos = vec3(3.5*sin(an),cos( time * .1 ),3.5*cos(an));\n    camPos = vec3( 3.5*sin(mouseX * .4) , 0.6 , 3.5*cos(mouseX * .4));\n    camTar = vec3(0. ,0.0,0.0);\n}\n\n\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n   \n}\n\nvec3 doBackground( vec3 rd , vec3 ogRD ){\n \n    vec3 col = vec3(0.);\n    col = hsv( abs(sin(pow(  dot( ogRD , rd ) , 1.) * 10.)), 1.,1.);//* vec3( 1. , .6 , .2 );; \n    //col +=hsv(pow( max( 0. , dot( vec3( 0. , 0. , 1. ) , rd )) , 10.),1.,1.);//* vec3( 1. , .5 , .2 );\n    //col +=hsv(pow( max( 0. , dot( normalize(vec3( 1. , 1. , -1. )) , rd )) , 10.),1.,1.);//* vec3( 1. , .5 , .2 );   \n    \n    return col;\n}\n\n\n\nfloat densityFunction( vec3 p ){\n    return triNoise3D( p * .05 , 0. ) * max( 0. , -p.y + .1 );\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nfloat map5( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0);//*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nfloat map4( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0);//*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map3( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0);//*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map2( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0);//*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q );;\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\n\n\nvec4 integrate( in vec4 sum, in float dif, in float den, in vec3 bgcol, in float t )\n{\n    // lighting\n    vec3 lin = vec3(0.65,0.68,0.7)*1.3 + 0.5*vec3(0.7, 0.5, 0.3)*dif;        \n    vec4 col = vec4( hsv( den , 1. , 1. ) , den );//vec4( mix( 1.15*vec3(1.0,0.95,0.8), vec3(0.65), den ), den );\n    col.xyz *= hsv( length( lin ) , 1. , 1.);\n    col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.003*t*t) );\n    // front to back blending    \n    col.a *= 0.4;\n    col.rgb *= col.a;\n    return sum + col*(1.0-sum.a);\n}\n\n#define MARCH(STEPS,MAPLOD) for(int i=0; i<STEPS; i++) { vec3  pos = ro + t*rd; vec2 res =map( pos ); if( pos.y<-3.0 || pos.y>2.0 || sum.a > 0.99 || res.x < .05 ) break; float den = MAPLOD( pos ); if( den>0.01 ) { float dif =  clamp((den - MAPLOD(pos+0.3*sundir))/0.6, 0.0, 1.0 ); sum = integrate( sum, dif, den, bgcol, t ); } t += max(0.1,0.02*t); }\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol )\n{\n\tvec4 sum = vec4(0.0);\n\n\tfloat t = 0.0;\n\n    MARCH(30,map5);\n    MARCH(30,map4);\n    MARCH(30,map3);\n    MARCH(30,map2);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\n/*\nvec4 doFog( vec3 ro , vec3 rd ){\n \n   \tvec3 col = vec3( 0. );\n    float lum = 0.;\n    \n    for( int i = 0; i < FOG_STEPS; i++ ){\n        \n        vec3 p = ro * ( 1. )  + rd  * ( MAX_TRACE_DISTANCE / float( FOG_STEPS))  * float( i );\n        \n        vec2 m  = map( p );\n\n        if( m.x < 0.0 ){ return vec4( col , lum ) / float( FOG_STEPS ); }\n        \n        \n        \n      \n        vec3 lightDir = normalize( p - lightPos );\n        float d = densityFunction( p );\n        float dif = clamp( (densityFunction( p + .01 * lightDir ) - d )/.01 , 0. , 1. ); \n\n        col += vec3( dif );//hsv( pow(dif, 10. ) ,1.,1.) * dif ;\n        lum = float(i);\n\n        \n    }\n    \n    col /= float( FOG_STEPS );\n    \n    return vec4( col , lum );\n    \n}*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m.x = sin( iTime * .1 );\n    \n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime,m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    vec3 ogRD = normalize( camMat * vec3(0. , 0.,2.0) );\n    \n        \n    vec2 res = calcIntersection( ro , rd  );\n    \n    vec3 col = doBackground(rd , sundir );  \n    //col = vec3(;\n    \n    \n            // If we have hit something lets get real!\n    if( res.y > -.5 ){\n        \n\n          \n        vec3 pos = ro + rd * res.x;\n        vec3 nor = calcNormal( pos );\n        \n\n        \n        vec3 refl = reflect( sundir , nor );\n        \n        float lamb = max( 0. , dot( sundir,  nor ) );\n        float spec = max( 0. , dot( refl , rd ) );\n        \n        float AO = calcAO ( pos , nor );\n        col = lamb *  vec3(AO); \n        col += vec3( pow( spec, 10. ));\n        col += vec3( .1 );\n        \n        col = hsv(lamb, 1. , 1.);\n        \n       // col = vec3( 0. );\n       // col = vec3( 1. , 0. , 0. ) * lamb + vec3( 0. , 0. , 1. ) * pow( spec, 20. );\n        \n        \n     \n        //col = nor * .5 + .5;\n    }\n    \n   // clouds    \n    vec4 resCloud = raymarch( ro, rd, col );\n    col = col*(1.0-resCloud.w) + resCloud.xyz;\n    \n    \n    // apply gamma correction\n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col , 1. );\n    \n            \n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljXRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[365, 365, 388, 388, 497], [500, 500, 524, 524, 623], [625, 625, 652, 652, 751], [754, 754, 802, 802, 929], [931, 967, 1008, 1008, 1101], [1103, 1103, 1126, 1126, 3887], [3889, 3889, 3912, 3912, 6871], [6873, 6925, 6947, 6947, 6972], [6973, 6973, 6994, 6994, 7074], [7110, 7162, 7205, 7205, 7508], [7512, 7512, 7549, 7549, 7686], [7690, 7774, 7795, 7903, 8261], [8264, 8295, 8359, 8359, 8537], [8539, 8539, 8622, 8622, 8820], [8825, 8938, 8969, 8969, 9194], [9196, 9196, 9238, 9238, 9537], [9540, 9540, 9588, 9588, 10059], [10061, 10061, 10102, 10102, 10473], [10477, 10477, 10509, 10509, 10574], [10577, 10577, 10603, 10603, 10821], [10823, 10823, 10848, 10848, 11148], [11150, 11150, 11175, 11175, 11434], [11435, 11435, 11460, 11460, 11678], [11679, 11679, 11704, 11704, 11882], [11886, 11886, 11972, 11988, 12394], [12748, 12748, 12804, 12804, 12963], [13715, 13715, 13772, 13772, 15491]], "test": "error"}
{"id": "llSSDR", "name": "Preetham Sky", "author": "Althar", "description": "A simple/basic implementation of the day-light sky model : http://www.cs.utah.edu/~shirley/papers/sunsky/sunsky.pdf", "tags": ["skypreetham"], "likes": 20, "viewed": 1596, "published": "Public", "date": "1442743532", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nfloat saturatedDot( in vec3 a, in vec3 b )\n{\n\treturn max( dot( a, b ), 0.0 );   \n}\n\nvec3 YxyToXYZ( in vec3 Yxy )\n{\n\tfloat Y = Yxy.r;\n\tfloat x = Yxy.g;\n\tfloat y = Yxy.b;\n\n\tfloat X = x * ( Y / y );\n\tfloat Z = ( 1.0 - x - y ) * ( Y / y );\n\n\treturn vec3(X,Y,Z);\n}\n\nvec3 XYZToRGB( in vec3 XYZ )\n{\n\t// CIE/E\n\tmat3 M = mat3\n\t(\n\t\t 2.3706743, -0.9000405, -0.4706338,\n\t\t-0.5138850,  1.4253036,  0.0885814,\n \t\t 0.0052982, -0.0146949,  1.0093968\n\t);\n\n\treturn XYZ * M;\n}\n\n\nvec3 YxyToRGB( in vec3 Yxy )\n{\n\tvec3 XYZ = YxyToXYZ( Yxy );\n\tvec3 RGB = XYZToRGB( XYZ );\n\treturn RGB;\n}\n\nvoid calculatePerezDistribution( in float t, out vec3 A, out vec3 B, out vec3 C, out vec3 D, out vec3 E )\n{\n\tA = vec3(  0.1787 * t - 1.4630, -0.0193 * t - 0.2592, -0.0167 * t - 0.2608 );\n\tB = vec3( -0.3554 * t + 0.4275, -0.0665 * t + 0.0008, -0.0950 * t + 0.0092 );\n\tC = vec3( -0.0227 * t + 5.3251, -0.0004 * t + 0.2125, -0.0079 * t + 0.2102 );\n\tD = vec3(  0.1206 * t - 2.5771, -0.0641 * t - 0.8989, -0.0441 * t - 1.6537 );\n\tE = vec3( -0.0670 * t + 0.3703, -0.0033 * t + 0.0452, -0.0109 * t + 0.0529 );\n}\n\nvec3 calculateZenithLuminanceYxy( in float t, in float thetaS )\n{\n\tfloat chi  \t \t= ( 4.0 / 9.0 - t / 120.0 ) * ( PI - 2.0 * thetaS );\n\tfloat Yz   \t \t= ( 4.0453 * t - 4.9710 ) * tan( chi ) - 0.2155 * t + 2.4192;\n\n\tfloat theta2 \t= thetaS * thetaS;\n    float theta3 \t= theta2 * thetaS;\n    float T \t \t= t;\n    float T2 \t \t= t * t;\n\n\tfloat xz =\n      ( 0.00165 * theta3 - 0.00375 * theta2 + 0.00209 * thetaS + 0.0)     * T2 +\n      (-0.02903 * theta3 + 0.06377 * theta2 - 0.03202 * thetaS + 0.00394) * T +\n      ( 0.11693 * theta3 - 0.21196 * theta2 + 0.06052 * thetaS + 0.25886);\n\n    float yz =\n      ( 0.00275 * theta3 - 0.00610 * theta2 + 0.00317 * thetaS + 0.0)     * T2 +\n      (-0.04214 * theta3 + 0.08970 * theta2 - 0.04153 * thetaS + 0.00516) * T +\n      ( 0.15346 * theta3 - 0.26756 * theta2 + 0.06670 * thetaS + 0.26688);\n\n\treturn vec3( Yz, xz, yz );\n}\n\nvec3 calculatePerezLuminanceYxy( in float theta, in float gamma, in vec3 A, in vec3 B, in vec3 C, in vec3 D, in vec3 E )\n{\n\treturn ( 1.0 + A * exp( B / cos( theta ) ) ) * ( 1.0 + C * exp( D * gamma ) + E * cos( gamma ) * cos( gamma ) );\n}\n\nvec3 calculateSkyLuminanceRGB( in vec3 s, in vec3 e, in float t )\n{\n\tvec3 A, B, C, D, E;\n\tcalculatePerezDistribution( t, A, B, C, D, E );\n\n\tfloat thetaS = acos( saturatedDot( s, vec3(0,1,0) ) );\n\tfloat thetaE = acos( saturatedDot( e, vec3(0,1,0) ) );\n\tfloat gammaE = acos( saturatedDot( s, e )\t\t   );\n\n\tvec3 Yz = calculateZenithLuminanceYxy( t, thetaS );\n\n\tvec3 fThetaGamma = calculatePerezLuminanceYxy( thetaE, gammaE, A, B, C, D, E );\n\tvec3 fZeroThetaS = calculatePerezLuminanceYxy( 0.0,    thetaS, A, B, C, D, E );\n\n\tvec3 Yp = Yz * ( fThetaGamma / fZeroThetaS );\n\n\treturn YxyToRGB( Yp );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float turbidity     = 2.0;\n    float azimuth       = iMouse.z > 0.0 ? iMouse.x / iResolution.x * PI       : iTime * 0.125;\n    float inclination   = iMouse.z > 0.0 ? iMouse.y / iResolution.y * PI * 0.5 : iTime * 0.25;\n    vec3 sunDir     \t= normalize( vec3( sin(inclination) * cos(azimuth), cos(inclination), sin(inclination) * sin(azimuth) ) );\n    vec3 viewDir  \t\t= normalize( vec3( (uv * 2.0) - 1.0 , 1.0 ) );\n    vec3 skyLuminance \t= calculateSkyLuminanceRGB( sunDir, viewDir, turbidity );\n    \n    fragColor \t\t\t= vec4( skyLuminance * 0.05, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSSDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 70, 70, 108], [110, 110, 140, 140, 285], [287, 287, 317, 327, 483], [486, 486, 516, 516, 589], [591, 591, 698, 698, 1095], [1097, 1097, 1162, 1162, 1956], [1958, 1958, 2080, 2080, 2196], [2198, 2198, 2265, 2265, 2790], [2792, 2792, 2849, 2849, 3457]], "test": "valid"}
{"id": "llSSWW", "name": "Cosmic Marble", "author": "eddietree", "description": "Marble-inspired refraction", "tags": ["procedural", "raymarching", "refraction"], "likes": 107, "viewed": 3268, "published": "Public", "date": "1443595402", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// a study on raymarching, soft-shadows, ao, etc\n// borrowed heavy from others, esp @cabbibo and @iquilezles and more\n// by @eddietree\n\nconst float MAX_TRACE_DISTANCE = 10.0;\nconst float INTERSECTION_PRECISION = 0.001;\nconst int NUM_OF_TRACE_STEPS = 50;\n\nfloat distSphere(vec3 p, float radius) \n{\n    return length(p) - radius;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    float radius = 4.0;\n    float theta = 0.3 + 5.0*mouse.x - iTime*0.5;\n    float phi = 3.14159*0.4;//5.0*mouse.y;\n    \n    float pos_x = radius * cos(theta) * sin(phi);\n    float pos_z = radius * sin(theta) * sin(phi);\n    float pos_y = radius * cos(phi);\n    \n    camPos = vec3(pos_x, pos_y, pos_z);\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\n// noise func\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n\treturn (d1.x<d2.x) ? d1 : d2; \n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n   \n    float sphere = distSphere(pos, 1.75) + noise(pos * 1.0 + iTime*0.75);   \n    float t1 = sphere;\n    \n    t1 = smin( t1, distSphere( pos + vec3(1.8,0.0,0.0), 0.2 ), 2.0 );\n    t1 = smin( t1, distSphere( pos + vec3(-1.8,0.0,-1.0), 0.2 ), 2.0 );\n   \n   \treturn vec2( t1, 1.0 );\n    \n}\n\nvec2 map2( vec3 pos ){  \n   \n    //float sphere = distSphere(pos, 1.0) + noise(pos * 1.2 + vec3(-0.3) + iTime*0.2);\n    float sphere = distSphere(pos, 0.45);\n    \n    sphere = smin( sphere, distSphere( pos + vec3(-0.4,0.0,-1.0), 0.04 ), 5.0 );\n    sphere = smin( sphere, distSphere( pos + vec3(-0.5,-0.75,0.0), 0.05 ), 50.0 );\n    sphere = smin( sphere, distSphere( pos + vec3(0.5,0.7,0.5), 0.1 ), 5.0 );\n\n   \treturn vec2( sphere, 1.0 );\n}\n\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    const float k = 2.0;\n    \n    const int maxSteps = 10;\n    float t = 0.0;\n    float res = 1.0;\n    \n    for(int i = 0; i < maxSteps; ++i) {\n        \n        float d = map(ro + rd*t).x;\n            \n        if(d < INTERSECTION_PRECISION) {\n            \n            return 0.0;\n        }\n        \n        res = min( res, k*d/t );\n        t += d;\n    }\n    \n    return res;\n}\n\n\nfloat ambientOcclusion( in vec3 ro, in vec3 rd )\n{\n    const int maxSteps = 7;\n    const float stepSize = 0.05;\n    \n    float t = 0.0;\n    float res = 0.0;\n    \n    // starting d\n    float d0 = map(ro).x;\n    \n    for(int i = 0; i < maxSteps; ++i) {\n        \n        float d = map(ro + rd*t).x;\n\t\tfloat diff = max(d-d0, 0.0);\n        \n        res += diff;\n        \n        t += stepSize;\n    }\n    \n    return res;\n}\n\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nvec3 calcNormal2( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map2(pos+eps.xyy).x - map2(pos-eps.xyy).x,\n\t    map2(pos+eps.yxy).x - map2(pos-eps.yxy).x,\n\t    map2(pos+eps.yyx).x - map2(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvoid renderColor2( vec3 ro , vec3 rd, inout vec3 color, vec3 currPos )\n{\n    //vec3 lightDir = normalize(vec3(1.0,0.4,0.0));\n    vec3 normal = calcNormal2( currPos );\n    vec3 normal_distorted = calcNormal2( currPos +  rd*noise(currPos*2.5 + iTime*2.0)*0.75 );\n\n    float ndotl = abs(dot( -rd, normal ));\n    float ndotl_distorted = (dot( -rd, normal_distorted ))*0.5+0.5;\n    float rim = pow(1.0-ndotl, 3.0);\n    float rim_distorted = pow(1.0-ndotl_distorted, 6.0);\n\n    //color = mix( color, normal*0.5+vec3(0.5), rim_distorted+0.15 );\n    //color = mix( vec3(0.0,0.1,0.6), color, rim*1.5 );\n    color = mix( refract(normal, rd, 0.5)*0.5+vec3(0.5), color, rim );\n    //color = mix( vec3(0.1), color, rim );\n    color += rim*0.6;\n}\n\n// for inside ball\nbool renderRayMarch2(vec3 ro, vec3 rd, inout vec3 color ) {\n    \n    float t = 0.0;\n    float d = 0.0;\n    \n    for(int i = 0; i < NUM_OF_TRACE_STEPS; ++i) \n    {\n        vec3 currPos = ro + rd*t;\n        d = map2(currPos).x;\n        if(d < INTERSECTION_PRECISION) \n        {\n            renderColor2( ro, rd, color, currPos );\n            return true;\n        }\n        \n        t += d;\n    }\n    \n    if(d < INTERSECTION_PRECISION) \n    {\n        vec3 currPos = ro + rd*t;\n        renderColor2( ro, rd, color, currPos );\n        return true;\n    }\n\n    return false;\n}\n\nvoid renderColor( vec3 ro , vec3 rd, inout vec3 color, vec3 currPos )\n{\n    vec3 lightDir = normalize(vec3(1.0,0.4,0.0));\n    vec3 normal = calcNormal( currPos );\n    vec3 normal_distorted = calcNormal( currPos +  noise(currPos*1.5 + vec3(0.0,0.0,sin(iTime*0.75))) );\n    float shadowVal = shadow( currPos - rd* 0.01, lightDir  );\n    float ao = ambientOcclusion( currPos - normal*0.01, normal );\n\n    float ndotl = abs(dot( -rd, normal ));\n    float ndotl_distorted = abs(dot( -rd, normal_distorted ));\n    float rim = pow(1.0-ndotl, 6.0);\n    float rim_distorted = pow(1.0-ndotl_distorted, 6.0);\n\n\n    color = mix( color, normal*0.5+vec3(0.5), rim_distorted+0.1 );\n    color += rim;\n    //color = normal;\n\n    // refracted ray-march into the inside area\n    vec3 color2 = vec3(0.5);\n    renderRayMarch2( currPos, refract(rd, normal, 0.85), color );\n    //renderRayMarch2( currPos, rayDirection, color2 );\n\n    //color = color2;\n    //color = normal;\n    //color *= vec3(mix(0.25,1.0,shadowVal));\n\n    color *= vec3(mix(0.8,1.0,ao));\n}\n\nvec3 rayPlaneIntersection( vec3 ro, vec3 rd, vec4 plane )\n{\n\tfloat t = -( dot(ro, plane.xyz) + plane.w) / dot( rd, plane.xyz );\n\treturn ro + t * rd;\n}\n\nbool renderRayMarch(vec3 ro, vec3 rd, inout vec3 color ) \n{\n    const int maxSteps = NUM_OF_TRACE_STEPS;\n        \n    float t = 0.0;\n    float d = 0.0;\n    \n    for(int i = 0; i < maxSteps; ++i) \n    {\n        vec3 currPos = ro + rd * t;\n        d = map(currPos).x;\n        if(d < INTERSECTION_PRECISION) \n        {\n            break;\n        }\n        \n        t += d;\n    }\n    \n    if(d < INTERSECTION_PRECISION) \n    {\n        vec3 currPos = ro + rd * t;\n        renderColor( ro, rd, color, currPos );\n        return true;\n    }\n    \n    vec3 planePoint = rayPlaneIntersection(ro, rd, vec4(0.0, 1.0, 0.0, 1.0));\n\tfloat shadowFloor = shadow( planePoint, vec3(0.0,1.0,0.0));\n\tcolor = color * mix( 0.8, 1.0, shadowFloor );\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    // calc color\n    vec3 col = vec3(0.9);\n    renderRayMarch( ro, rd, col );\n    \n    // vignette, OF COURSE\n    float vignette = 1.0-smoothstep(1.0,2.5, length(p));\n    col.xyz *= mix( 0.7, 1.0, vignette);\n        \n    fragColor = vec4( col , 1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSSWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[255, 255, 296, 296, 329], [331, 331, 395, 395, 573], [575, 575, 656, 656, 993], [995, 995, 1036, 1036, 1107], [1109, 1109, 1142, 1142, 1168], [1170, 1170, 1203, 1203, 1228], [1230, 1244, 1267, 1267, 1303], [1304, 1304, 1330, 1330, 1699], [1701, 1795, 1824, 1824, 1858], [1860, 1860, 1893, 1893, 1918], [1920, 2004, 2025, 2025, 2317], [2319, 2319, 2341, 2434, 2758], [2760, 2760, 2800, 2800, 3177], [3180, 3180, 3230, 3230, 3597], [3599, 3599, 3630, 3630, 3856], [3859, 3859, 3891, 3891, 4123], [4125, 4125, 4197, 4249, 4857], [4859, 4878, 4937, 4937, 5448], [5450, 5450, 5521, 5521, 6486], [6488, 6488, 6547, 6547, 6638], [6640, 6640, 6699, 6699, 7388], [7390, 7390, 7447, 7447, 8086]], "test": "valid"}
{"id": "llSSz1", "name": "Spirally Thingy", "author": "GentleBoop", "description": "Ooooooh, spinny!", "tags": ["i", "something", "found", "online"], "likes": 1, "viewed": 117, "published": "Public", "date": "1441494304", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//code released into the public domain via CC0\nfloat spiral1(vec2 m) {\n\tfloat r = length(m);\n\tfloat a = atan(m.y, m.x);\n\tfloat v = sin(1000000.*abs(sin(iTime/10.))*(sqrt(r)-0.02*a-.3));\n\treturn clamp(v,0.,1.);\n\n}\n\nvec3 spiral2(vec2 m) {\n\tfloat r = length(m);\n\tfloat a = atan(m.y, m.x);\n    vec3 v;\n\tv.r = abs(sin(200.*(sqrt(r * .01)-0.02*a - .3 * iTime)));\n\tv.g = abs(sin(100.*(sqrt(r * .0105)-0.02*a - .31 * iTime)));\n\tv.b = abs(sin(50.*(sqrt(r * .011)-0.02*a - .32 * iTime)));\n\treturn v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    float screenSizeY = iResolution.y;\n\tvec2 uv = fragCoord.xy / screenSizeY;\n    uv -= 0.5 * vec2(1.0);\n    uv *= 5.0 + 0.2 * sin(t);\n    uv += vec2(sin(t), t);\n    uv = mod(uv + 0.25, 0.5) - 0.25;\n    float r = uv.x * uv.x + uv.y * uv.y;\n    float gray = mod(100.0 * pow(r, 3.0), 1.0) > 0.5 * sin(t*t) + 0.5 ? 1.0 : 0.0;\n    gray = clamp(gray, 0.3, 1.);\n   \n    //spiral\n    vec2 idk = fragCoord.xy / iResolution.y;\n\tvec2 m = iMouse.xy/ iResolution.y * 0.01;\n\tm = vec2(.9,.5) ;\n\tfloat v1 = spiral1(m-idk);\n    vec3 v2 = spiral2(m-idk);\n\n    fragColor = vec4((gray * v1 * v2.r)/2.0 + v2.r * abs(sin(t/ 4.123123)), \n                     (gray * v1 * v2.g)/2.0 + v2.g * abs(sin(t / 12.234235)),\n                     (gray * v1 * v2.b)/2.0 + v2.b * abs(sin(t / 20.0989834)),\n                     1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSSz1.jpg", "access": "shaders20k", "license": "public-domain", "functions": [[0, 47, 70, 70, 212], [214, 214, 236, 236, 491], [493, 493, 550, 550, 1373]], "test": "valid"}
{"id": "llSXW1", "name": "n00bes voladoras", "author": "noidexe", "description": "testing2", "tags": ["n00b"], "likes": 2, "viewed": 121, "published": "Public", "date": "1443217251", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool isPoint(vec2 uv, float t) {\n    vec2 deRotated;\n    vec2 center = vec2(0.5,0.5);\n    deRotated.x = (uv.x-center.x) * cos(t) - uv.y * sin(t);\n    deRotated.y = uv.x * sin(t) + (uv.y-center.y) * cos(t);\n    deRotated = deRotated *sin(t);\n    //return (mod(uv.x*10.0, 10.0) + mod(uv.y*10.0, 10.0)) == 0.0 ;\n    return mod(deRotated.x*100.0, 10.0) < 5.0 ^^ mod(deRotated.y*100.0, 10.0) < 5.0;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;  \n    vec4 point;\n    vec4 finalPoint;\n    float t = iTime;\n    if(isPoint(uv, t)) {\n        point = vec4(1.0,0.0,0.0,1.0);\n    } else {\n        point = vec4(0.0,0.0,0.0,1.0);\n        \n    }\n    \n    finalPoint = point;\n    finalPoint.y = (sin(t)/2.0)+1.0 * point.y;\n    fragColor = finalPoint;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSXW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[402, 402, 459, 459, 801]], "test": "valid"}
{"id": "llSXz1", "name": "Resilar tehotippa", "author": "luutifa", "description": "Just goofing around with a friend of mine.", "tags": ["tunnel", "psychedelic"], "likes": 8, "viewed": 215, "published": "Public", "date": "1441507246", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float t=iTime;\n\nvec3 psychTexture(vec2 uv) {\n    return vec3(sin(uv.x*2.0+uv.y*8.0*3.0)+0.2, sin(uv.x*2.0+0.666+uv.y*4.0*3.0-t*7.0)+0.3, sin(uv.x*2.0+0.999+uv.y*2.0*3.0)+0.1);\n}\n\nvec3 renderPsych(vec2 screenPos) {\n    vec2 trPos = vec2(atan(screenPos.y, screenPos.x), length(screenPos));\n    trPos.y += abs(sin(trPos.x*8.0+t*6.0))*0.2*((sin(t)+1.0)*0.4+0.4);\n    return psychTexture(vec2(trPos.x+t, trPos.y+sin(t*1.2)*0.6+t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 pos = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    fragColor = vec4(renderPsych(pos)*clamp(pow(length(pos),.5), 0.0, 1.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 44, 44, 177], [179, 179, 213, 213, 428], [430, 430, 487, 487, 637]], "test": "valid"}
{"id": "lt2SR1", "name": "Fake sky", "author": "XT95", "description": "Just try to make a \"good\" fake sky\nIf you have any suggestion to get it better ..!", "tags": ["fake", "sky", "checker", "scattering"], "likes": 36, "viewed": 3627, "published": "Public API", "date": "1441749822", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by anatole duprat - XT95/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n//Just try to make a sky similar to http://www.scratchapixel.com/old/assets/Uploads/Atmospheric%20Scattering/as-aerial2.png in few lines\n//Real sky here : http://www.scratchapixel.com/old/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\n\n\n\nvec3 skyColor( in vec3 rd )\n{\n    vec3 sundir = normalize( vec3(.0, .1, 1.) );\n    \n    float yd = min(rd.y, 0.);\n    rd.y = max(rd.y, 0.);\n    \n    vec3 col = vec3(0.);\n    \n    col += vec3(.4, .4 - exp( -rd.y*20. )*.15, .0) * exp(-rd.y*9.); // Red / Green \n    col += vec3(.3, .5, .6) * (1. - exp(-rd.y*8.) ) * exp(-rd.y*.9) ; // Blue\n    \n    col = mix(col*1.2, vec3(.3),  1.-exp(yd*100.)); // Fog\n    \n    col += vec3(1.0, .8, .55) * pow( max(dot(rd,sundir),0.), 15. ) * .6; // Sun\n    col += pow(max(dot(rd, sundir),0.), 150.0) *.15;\n    \n    return col;\n}\n\n\nfloat checker( vec2 p )\n{\n    p = mod(floor(p),2.0);\n    return mod(p.x + p.y, 2.0) < 1.0 ? .25 : 0.1;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //screen coords\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 v = -1.0+2.0*q;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\t//camera ray\n\tvec3 dir = normalize( vec3(v.x, v.y+.5, 1.5) );\n\t\n    //Scene\n    vec3 col = vec3( checker(dir.xz/dir.y*.5+vec2(0.,-iTime*2.)) ) + skyColor(reflect(dir,vec3(0.,1.,0.)))*.3;\n    col = mix(col, skyColor(dir), exp(-max(-v.y*9.-4.8,0.)) );\n\n    //Vignetting\n\tcol *= .7 + .3*pow(q.x*q.y*(1.-q.x)*(1.-q.y)*16., .1);\n        \n\tfragColor = vec4( col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2SR1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[406, 406, 435, 435, 967], [970, 970, 995, 995, 1074], [1077, 1077, 1134, 1154, 1619]], "test": "valid"}
{"id": "lt2SRw", "name": "Pulsing Mandelbrot", "author": "roombarampage", "description": "applied a sine wave to the max iterations for rendering the mandelbrot set", "tags": ["fractal", "mandelbrotpulsing"], "likes": 3, "viewed": 114, "published": "Public", "date": "1442556012", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n  programmer: jonathan potter\n  github: https://github.com/jonathan-potter\n  repo: https://github.com/jonathan-potter/shadertoy-fractal\n*/\n\nconst int MAX_ITERATIONS = 32;\nconst float ITERATIONS_PER_SECOND = 12.0;\nconst float pi = 3.14159;\n\nstruct complex { \n  float real;\n  float imaginary;\n};\n\nint fractal(complex c, complex z, int iterations) {\n  for (int iteration = 0; iteration < MAX_ITERATIONS; iteration++) {\n    if (iteration >= iterations) {return 0;}\n\n    // z <- z^2 + c\n    float real = z.real * z.real - z.imaginary * z.imaginary + c.real;\n    float imaginary = 2.0 * z.real * z.imaginary + c.imaginary;\n\n    z.real = real;\n    z.imaginary = imaginary;\n\n    if (z.real * z.real + z.imaginary * z.imaginary > 4.0) {\n      return iteration;\n    }\n  }\n\n  return 0;\n}\n\nint mandelbrot(vec2 coordinate, int iterations) {\n  complex c = complex(coordinate.x, coordinate.y);\n  complex z = complex(0.0, 0.0);\n\n  return fractal(c, z, iterations);\n}\n\nvec2 fragCoordToXY(vec2 fragCoord) {\n  vec2 relativePosition = fragCoord.xy / iResolution.xy;\n  float aspectRatio = iResolution.x / iResolution.y;\n\n  vec2 cartesianPosition = (relativePosition - 0.5) * 3.0;\n  cartesianPosition.x *= aspectRatio;\n\n  return cartesianPosition;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float pulse = sin(float(MAX_ITERATIONS) + (iTime * 2.0 * pi * ITERATIONS_PER_SECOND / float(MAX_ITERATIONS)));\n  int iterations = int(floor(float(MAX_ITERATIONS) * (1.05 + pulse)));\n    \n  vec2 coordinate = fragCoordToXY(fragCoord);\n\n  int crossoverIteration = mandelbrot(coordinate, iterations);\n    \n  float color = 1.0 * float(crossoverIteration) / float(iterations);\n\n  fragColor = vec4(color, color, color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2SRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[298, 298, 349, 349, 779], [781, 781, 830, 830, 953], [955, 955, 991, 991, 1230], [1232, 1232, 1289, 1289, 1711]], "test": "valid"}
{"id": "lt2Xzm", "name": "box slug background work", "author": "cabbibo", "description": "working more on background", "tags": ["proceduralfractal"], "likes": 7, "viewed": 193, "published": "Public", "date": "1442601163", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Branch Code stolen from : https://www.shadertoy.com/view/ltlSRl\n\nconst float MAX_TRACE_DISTANCE = 5.0;             // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float PI  = 3.14159;\n\nmat4 paletteVal;\n\nvec3 light1;\nvec3 light2;\n\nmat4 rotateX(float angle){\n    \n\t//angle = -angle/180.0*3.1415926536;\n    float c = cos(angle);\n    float s = sin(angle);\n\treturn mat4(1.0, 0.0, 0.0, 0.0, 0.0, c, -s, 0.0, 0.0, s, c, 0.0, 0.0, 0.0, 0.0, 1.0);\n    \n}\n\nmat4 rotateY(float angle){\n    \n\t//angle = -angle/180.0*3.1415926536;\n    float c = cos(angle);\n    float s = sin(angle);\n\treturn mat4(c, 0.0, s, 0.0, 0.0, 1.0, 0.0, 0.0, -s, 0.0, c, 0.0, 0.0, 0.0, 0.0, 1.0);\n    \n}\n\nmat4 rotateZ(float angle){\n    \n\t//angle = -angle/180.0*3.1415926536;\n    float c = cos(angle);\n    float s = sin(angle);\n\treturn mat4(c, -s, 0.0, 0.0, s, c, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n    \n}\nmat4 translate(vec3 t){\n    \n\treturn mat4(1.0, 0.0, 0.0, -t.x, 0.0, 1.0, 0.0, -t.y, 0.0, 0.0, 1.0, -t.z, 0.0, 0.0, 0.0, 1.0);\n    \n}\n\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdSphere( vec3 p, float r )\n{\n  return length( p ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\nvec2 smoothU( vec2 d1, vec2 d2, float k)\n{\n    float a = d1.x;\n    float b = d2.x;\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return vec2( mix(b, a, h) - k*h*(1.0-h), mix(d2.y, d1.y, pow(h, 2.0)));\n}\n\nvec2 opU( vec2 d1, vec2 d2 ){\n return d1.x < d2.x ? d1 : d2;   \n}\n\n\n\n\nconst int numSteps =3;\n//-------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n    \n    float branchSize = .3;\n    float reductionFactor = .5;// +  .03 * sin( iTime * 1.73 );\n    float trunkSize = .2 +  .01 * sin( iTime * 3.27 );\n    float bs = branchSize;\n    float rot = 40. + 20. * sin( iTime * .4 );\n    \n    //pos += vec3( 0. , branchSize , 0. );\n\n   \n    vec4 p = vec4( pos , 1. );\n    mat4 m;\n    \n   \t//vec2 res = vec2( (abs(sin( pos.x * pos.y * pos.z  * 10.)) * 1.9 ) + length( pos ) - 1., 0.0 );\n  \n    vec2 res = vec2( 10000. ,1.);\n    \n    vec3 t = vec3( sin( iTime * .1 ) ,sin( iTime * .4 ) ,sin( iTime * .27 ) );\n    for( int i = 0; i <numSteps; i ++ ){\n        bs *= reductionFactor;\n        \n        float id =  float(i)/float(numSteps);\n\n\n        m = translate( abs(t) * bs * 4.) * rotateY(sin( iTime * .13 ) * PI * ( id + .3)  ) * rotateX(sin( iTime * .37 ) *PI * ( id + .3) ) * rotateZ(sin( iTime * .073 ) * PI* ( id + .3) );    \n        p.x = abs(p.x); // - bs / 2.;\n        p.z = abs(p.z); // - bs / 2.; \n        p.y = abs(p.y); // - bs / 2.;  \n\n        p = p * m; \n\n        //res = smoothU( res , vec2( sdCappedCylinder( p.xyz , vec2( trunkSize * bs , bs )),1.) , .1);\n        float smoothA = .2 - .1 * id; //float(i)/float(numSteps);\n        \n        float radius =  bs * ( 1. + .4 * sin( iTime * float( i )/ 10.));\n       // res = smoothU( res , vec2( sdSphere( p.xyz ,  radius ),id) ,smoothA );\n        \n        res = smoothU( res , vec2( sdBox( p.xyz , vec3( radius  ) ),id) ,smoothA );\n\n       // res = opU( res , vec2( sdSphere( p.xyz , trunkSize * bs * 10. ),1. ));\n\n\n\n\n    }\n\n   \treturn res;\n    \n}\n\n\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    float an = 0.3 + 3.0*mouse.x;\n   \tfloat an2 = 0.3 + 3.0*mouse.y;\n\n\tcamPos = vec3(3.5*sin(an),3. * cos( an2),3.5*cos(an));\n    camTar = vec3(0. ,0.0,0.0);\n}\n\n\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n  float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n     \n}\n\n// From Inigos Simple Color palettes\n//http://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 doPalette( in float val , in mat4 pType ){\n  return palette( val ,  pType[0].xyz , pType[1].xyz , pType[2].xyz , pType[3].xyz );\n}\n\n\nvec3 bgCol( in vec3 p ){\n vec3 l1 = normalize( light1 -p );\n vec3 l2 = normalize( light2 - p );\n \n\n    \n   \n vec3 disPos = vec3( p +  sin( p.x * 10. ) + sin( p.y  * 10. ) + sin( p.z * 10.));\n vec3 n = normalize( disPos );\n    \n float lamb1 = max( 0. , dot( n , l1 ));\n float lamb2 = max( 0. , dot( n , l2 ));\n\n vec3 col1 = doPalette( .3 + .3 * lamb1, paletteVal ) * lamb1;\n vec3 col2 = doPalette( .6 + .3 * lamb2, paletteVal ) * lamb2;\n vec3 baseCol = vec3( .3 , .3 , .3 );\n    \n return col1 + col2; //vec3( lamb1 , lamb2 , 0. );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n   \n    paletteVal = mat4( .5 , .5 , .5 , 0. \n                 , .5 , .5 , .5 , 0.\n                 , 2. , 1. , 0. , 0.\n                 , .5 , .2 , .25 , 0.\n                 );\n\n\n    light1 = vec3( 5. * sin( iTime ) , 6. * sin( iTime * .1 ) ,  6. * sin( iTime * .4 + 2. ) );\n    light2 = vec3( 5. * sin( iTime * .3 + 1.3) , 6. * sin( iTime * .3 + 2.7 ) ,  6. * sin( iTime * .4 + 2. ) );\n\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    vec3 camPos = camMat * vec3(0.,0.,2.0);\n\n    vec2 res = calcIntersection( ro , rd  );\n    \n    vec3 col = vec3( 0. ); \n    \n        // If we have hit something lets get real!\n    if( res.y > -.5 ){\n   \n        vec3 pos = ro + rd * res.x;\n        vec3 nor = calcNormal( pos );\n        float AO = calcAO( pos , nor );\n        \n        vec3 refr = refract( rd , nor , 1. / 1.2 );\n        vec3 refl1 = reflect(pos- light1 , nor );\n        refl1 = normalize(-refl1 );\n        \n        vec3 refl2 = reflect(pos- light2 , nor );\n        refl2 = normalize(-refl2 );\n        \n     \n        \n        float reflVal1 = pow( max( 0. , dot( refl1 , rd ) ),1. + res.y * 30. );\n        float reflVal2 = pow( max( 0. , dot( refl2 , rd ) ),1. + res.y * 30. );\n\n        \n        vec3 palCol = doPalette( res.y / ( 1.4 + sin(iTime * .2)) , paletteVal );\n        \n        \n        vec3 reflCol1= doPalette( .3 + .3 * reflVal1, paletteVal ) * reflVal1;\n        vec3 reflCol2= doPalette( .6 + .3 * reflVal2, paletteVal ) * reflVal2;\n\n        \n\n\n        \n       // vec3 aoCol =  doPalette( sin( AO * 20. ) , paletteVal ) * pow((1. - AO), 5. );\n\n        vec3 refrCol = bgCol( camPos + refr * ( MAX_TRACE_DISTANCE - res.x ) + pos );\n        col = reflCol1 + reflCol2 +  refrCol;\n        \n       // col = refrCol;\n       \t//col=   refCol +  palCol *refrCol; //refCol +  (palCol  * refrCol);//refrCol * doPalette( res.y / ( 1.4 + sin(iTime * .2)) , paletteVal ); //(refrCol * .6 + reflCol * .8 ) * AO;// * vec3( AO * AO * AO ) * vec3(1.- pow(  dot(nor , rd), 2.) ); // AO * ( nor * .5 + .5);\n\t\n        //col *= pow( (5. - res.x)/5., 2.) * 4.;\n        //col *=;\n        //col = vec3( reflectVal );\n    }else{\n        col = bgCol( camPos + ro + rd * MAX_TRACE_DISTANCE );//texture( iChannel0, rd ).xyz;\n    }\n    \n    // apply gamma correction\n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col , 1. );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2Xzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[334, 334, 360, 403, 549], [551, 551, 577, 620, 766], [768, 768, 794, 837, 983], [984, 984, 1007, 1007, 1116], [1119, 1119, 1161, 1161, 1260], [1263, 1263, 1298, 1298, 1326], [1328, 1328, 1359, 1359, 1455], [1458, 1458, 1500, 1500, 1666], [1668, 1668, 1697, 1697, 1733], [1761, 1844, 1865, 1865, 3422], [3427, 3458, 3522, 3522, 3700], [3702, 3702, 3783, 3783, 3943], [3948, 4061, 4092, 4092, 4317], [4319, 4319, 4361, 4361, 4661], [4666, 4666, 4714, 4714, 5182], [5184, 5284, 5356, 5356, 5399], [5401, 5401, 5448, 5448, 5536], [5539, 5539, 5563, 5563, 6070], [6071, 6071, 6127, 6127, 8792]], "test": "valid"}
{"id": "ltBXDW", "name": "Psych", "author": "Gilmour", "description": "Des blops psych", "tags": ["blop"], "likes": 0, "viewed": 95, "published": "Public", "date": "1443618240", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 mod289(vec3 x) {\nreturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x) {\nreturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x) {\nreturn mod289(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\nreturn 1.79284291400159 - 0.85373472095314 * r;\n}\nfloat noise(vec3 v)\n{\nv=0.1*v;\nconst vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\nconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n// First corner\nvec3 i = floor(v + dot(v, C.yyy) );\nvec3 x0 = v - i + dot(i, C.xxx) ;\n// Other corners\nvec3 g = step(x0.yzx, x0.xyz);\nvec3 l = 1.0 - g;\nvec3 i1 = min( g.xyz, l.zxy );\nvec3 i2 = max( g.xyz, l.zxy );\n// x0 = x0 - 0.0 + 0.0 * C.xxx;\n// x1 = x0 - i1 + 1.0 * C.xxx;\n// x2 = x0 - i2 + 2.0 * C.xxx;\n// x3 = x0 - 1.0 + 3.0 * C.xxx;\nvec3 x1 = x0 - i1 + C.xxx;\nvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\nvec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n// Permutations\ni = mod289(i);\nvec4 p = permute( permute( permute(\ni.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\nfloat n_ = 0.142857142857; // 1.0/7.0\nvec3 ns = n_ * D.wyz - D.xzx;\nvec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\nvec4 x_ = floor(j * ns.z);\nvec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\nvec4 x = x_ *ns.x + ns.yyyy;\nvec4 y = y_ *ns.x + ns.yyyy;\nvec4 h = 1.0 - abs(x) - abs(y);\nvec4 b0 = vec4( x.xy, y.xy );\nvec4 b1 = vec4( x.zw, y.zw );\n//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\nvec4 s0 = floor(b0)*2.0 + 1.0;\nvec4 s1 = floor(b1)*2.0 + 1.0;\nvec4 sh = -step(h, vec4(0.0));\nvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\nvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\nvec3 p0 = vec3(a0.xy,h.x);\nvec3 p1 = vec3(a0.zw,h.y);\nvec3 p2 = vec3(a1.xy,h.z);\nvec3 p3 = vec3(a1.zw,h.w);\n//Normalise gradients\nvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\np0 *= norm.x;\np1 *= norm.y;\np2 *= norm.z;\np3 *= norm.w;\n// Mix final noise value\nvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\nm = m * m;\nreturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\ndot(p2,x2), dot(p3,x3) ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n   \tuv.x *= 16.0/9.0; \n\tvec3 origine = vec3(iTime, 0.0, -2.0);\n\tvec3 direction = normalize(vec3(uv, 1.0));\n    \n    vec3 point = origine;\n    \n    //vec3 centreLumiere = vec3(3.0,3.0*sin(iTime),3.0*cos(iTime));\n    \n\n    fragColor = vec4(cos(iTime),cos(uv.x)*sin(uv.y),(sin(iTime)),1.0);\n    \n    vec3 dx = vec3(0.1,0.0,0.0);\n    vec3 dy = vec3(0.0,0.1,0.0);\n    vec3 dz = vec3(0.0,0.0,0.1);\n    \n    for(int i = 0; i < 512; i++){\n   \n    \tpoint = point + direction * 0.05;\n        \n    \tif(noise(point) > 0.7){\n            \n     \n            \n\t\t\tvec3 N = vec3(\n                noise(point-dx)-noise(point+dx),\n                noise(point-dy)-noise(point+dy),\n                noise(point-dz)-noise(point+dz));\n            N = normalize(N);\n           \n            \n       \t\tfragColor = vec4(N+0.1,1.0);\n            \n            break;\n        }\n      \n            \n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltBXDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 68], [69, 69, 90, 90, 137], [138, 138, 160, 160, 195], [196, 196, 224, 224, 274], [275, 275, 296, 296, 2245], [2248, 2248, 2305, 2305, 3223]], "test": "valid"}
{"id": "ltBXW1", "name": "Snowmen", "author": "buksy", "description": "Just learning :), this is my very first shader :) ... I guess my code is way toooo long for such an easy animation, so any tips, recommendations, etc will be highly appreciated ;)", "tags": ["2d", "snow", "winter"], "likes": 3, "viewed": 195, "published": "Public", "date": "1443448565", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 circle(in vec2 r, in vec2 center, in float radius)\n{\n    float ret; // how much is it circle? (1.0 absolutely, 0.0 it is not)\n    \n    float a = smoothstep(0.0, 0.01, length(r-center)-radius);\n    ret = smoothstep(1.0, 0.0, a);\n    return vec3(ret);\n}\n\n\nvec3 rectangle(vec2 r, vec2 topLeft, vec2 bottomRight, in float angle) {\n    float ret;\n\tmat2 rotationMatrix = mat2(cos(angle), -sin(angle),\n                               sin(angle),  cos(angle));\n    // Shift to normalize coordinates\n    vec2 shift;\n    shift.x = (abs(topLeft.x)<abs(bottomRight.x)?topLeft.x:bottomRight.x) + (abs(topLeft.x)<abs(bottomRight.x)?bottomRight.x-topLeft.x:topLeft.x-bottomRight.x)*0.5;\n    shift.y = (abs(topLeft.y)<abs(bottomRight.y)?topLeft.y:bottomRight.y) + (abs(topLeft.y)<abs(bottomRight.y)?bottomRight.y-topLeft.y:topLeft.y-bottomRight.y)*0.5;\n\n    // all shifted coordinates\n    vec2 q = rotationMatrix * (r-shift);\n    vec2 shifted_tl = topLeft - shift;\n    vec2 shifted_br = bottomRight - shift;\n\t\n\tfloat d = 0.005;\n\tret = smoothstep(shifted_tl.x-d, shifted_tl.x+d, q.x);\n\tret *= smoothstep(shifted_tl.y-d, shifted_tl.y+d, q.y);\n\tret *= 1.0 - smoothstep(shifted_br.y-d, shifted_br.y+d, q.y);\n\tret *= 1.0 - smoothstep(shifted_br.x-d, shifted_br.x+d, q.x);\n\treturn vec3(ret);\n}\n\n\nvec3 mouth(in vec2 r, in vec2 center, in float radius, in float weight)\n{\n    float ret = smoothstep(0.0, 0.01, float(abs(length(r-center)-radius)<weight && r.y<center.y) );\n    return vec3(ret);\n}\n\nfloat sign(vec2 p1, vec2 p2, vec2 p3)\n{\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\nvec3 triangle(in vec2 r, in vec2 p1, in vec2 p2, in vec2 p3)\n{\n    // http://stackoverflow.com/questions/2049582/how-to-determine-a-point-in-a-triangle\n    bool b1, b2, b3;\n    \n    b1 = sign(r, p1, p2) < 0.0;\n    b2 = sign(r, p2, p3) < 0.0;\n    b3 = sign(r, p3, p1) < 0.0;\n    \n    // TODO: Add antialiasing\n    float a = float((b1==b2)&&(b2==b3));\n    return vec3(a);\n    //return vec3(smoothstep(0.0, 1.0, a));\n}\n\n// Snowman\n// Takes in:\n// ret - current pixel color so far\n// r - current pixel position from [-1, -1] to [1, 1]\n// center - center position of snowman\n// scale - scale factor\nvoid snowman2(inout vec3 ret, in vec2 r, in vec2 center, in float scale)\n{\n    vec3 membership;\n    \n    \n    // circles (body)\n    membership = circle(r, vec2(center.x, center.y+0.16*scale), 0.08*scale);\n    membership+= circle(r, center, 0.12*scale);\n    membership+= circle(r, vec2(center.x, center.y-0.25*scale), 0.2*scale);\n    ret = mix(ret, vec3(1.0), membership);\n    \n    // Dots in center\n    membership = circle(r, vec2(center.x, center.y+0.05*scale), 0.002*scale);\n    membership+= circle(r, center, 0.002*scale);\n    membership+= circle(r, vec2(center.x, center.y-0.05*scale), 0.002*scale);\n    ret = mix(ret, vec3(0.0), membership);\n    \n    // Eyes\n    membership+= circle(r, vec2(center.x+0.03, center.y+0.17*scale), 0.004*scale);\n    membership+= circle(r, vec2(center.x-0.03, center.y+0.17*scale), 0.004*scale);\n    ret = mix(ret, vec3(0.0), membership);\n    \n    // Carrot\n    membership = triangle(r, \n                          vec2(center.x, center.y+0.16*scale), \n                          vec2(center.x, center.y+0.14*scale), \n                          vec2(center.x+0.04, center.y+0.145*scale));\n    ret = mix(ret, vec3(0.7, 0.0, 0.0), membership);\n    \n    // Mouth\n    membership = mouth(r, vec2(center.x, center.y+0.136*scale), 0.02, 0.002);\n    ret = mix(ret, vec3(0.0, 0.0, 0.0), membership);\n    \n    \n    // Hands\n    membership = rectangle(r, vec2(center.x+0.15*scale, center.y-0.05*scale), vec2(center.x+0.16*scale, center.y+0.15*scale), -0.9);\n    membership+= rectangle(r, vec2(center.x-0.16*scale, center.y-0.05*scale), vec2(center.x-0.15*scale, center.y+0.15*scale), 0.9);\n    ret = mix(ret, vec3(0.0, 0.0, 0.0), membership);\n\n    \n    // Hat\n    membership = rectangle(r, vec2(center.x-0.085*scale, center.y+0.20*scale), vec2(center.x+0.085*scale, center.y+0.25*scale), 0.03);\n    ret = mix(ret, vec3(0.4, 0.0, 0.7), membership);\n}\n\n\n\nvoid snow(inout vec3 ret, in vec2 r, in float time)\n{\n    vec3 membership;\n    \n    membership = vec3(0.0);\n    float x;\n    for(float j=0.0; j < 1.0; j+=0.3)\n    {\n        for(float i=0.0; i < 1.0; i+=0.1)\n        {   \n            float y;\n            //y = iTime * 0.3;\n            y = (j*1.2) + iTime * 0.2 + 0.06*sin(i*25.0);\n            x = (0.01*j*iTime) + i*1.8 + 0.01*cos(iTime*i*5.0);\n            \n            membership+= circle(r, vec2(0.895 - mod(x, 1.8), 0.5 - mod(y, 1.0)), 0.001*j*i);\n            ret = mix(ret, vec3(0.9, 0.9, 1.0), membership);\n        }\n    }\n}\n\n\n// Draw hill\n// Hill is actually half of circle and most of the circle is moved out of the screen\nvoid hill(inout vec3 ret, in vec2 r, in vec2 center, in float scale)\n{\n    vec2 p = r;\n    vec3 membership;\n    float min_y = float(r.y > center.y);\n    \n    // Border\n    membership = circle(r, center, scale+0.005);\n    ret = mix(ret, vec3(0.8, 0.8, 1.0), membership * min_y);\n    \n    // Hill gradient\n    membership = circle(r, center, scale);    \n    ret = mix(ret, \n              mix(vec3(0.97), vec3(0.85), smoothstep(center.y+scale, -0.5, r.y)),\n              membership * min_y);\n}\n\n\n\nvoid nightsky(inout vec3 ret, in vec2 r, in float time)\n{\n    vec3 membership;\n    \n    membership = vec3(0.0);\n    float x;\n    for(float j=0.0; j < 1.0; j+=0.4)\n    {\n        for(float i=-1.0; i < 1.0; i+=0.4)\n        {   \n            float y;\n            //y = iTime * 0.3;\n            y = -0.2 + i + j + 0.05*sin(i*7.0);\n            x = i + j*0.1;\n            \n            membership+= circle(r, vec2(0.895 - mod(x, 1.8), 0.5 - mod(y, 1.0)), 0.005*sin(mod(iTime*0.4, 3.14)-0.0));\n            ret = mix(ret, vec3(1.0, 1.0, 0.0), membership);\n        }\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // to [-1, -1] x [1, 1] - not really :)\n    vec2 r = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y ;\n    // output color rgb\n    vec3 ret;\n    // Background gradient\n    ret = vec3(0.0, 1.0 - (r.y+1.4)*0.5, 1.0 - (r.y+0.9)*0.5);\n    \n    nightsky(ret, r, iTime);\n    \n    hill(ret, r, vec2(0.5, -1.2), 1.0);\n    hill(ret, r, vec2(-0.3, -1.1), 1.0);\n    \n    snowman2(ret, r, vec2(-0.5,0.1), 0.8);\n    snowman2(ret, r, vec2(-0.1, 0.04), 0.65);\n\n    snow(ret, r, iTime);\n    //ret = mix(ret, vec3(0.9, 0.1, 0.0), circle(r, vec2(0.0, -0.5), 0.01));\n    //ret = mix(ret, vec3(0.9, 0.1, 0.0), circle(r, vec2(0.0, 0.5), 0.01));\n    \n    fragColor = vec4(ret.x, ret.y, ret.z, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltBXW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 256], [259, 259, 331, 331, 1275], [1278, 1278, 1351, 1351, 1475], [1477, 1477, 1516, 1516, 1592], [1593, 1593, 1655, 1744, 2008], [2010, 2187, 2261, 2261, 4056], [4060, 4060, 4113, 4113, 4638], [4641, 4739, 4809, 4809, 5228], [5232, 5232, 5289, 5289, 5794], [5797, 5797, 5854, 5898, 6542]], "test": "valid"}
{"id": "ltjSRD", "name": "Ray Marched Mesh Terrain", "author": "Flyguy", "description": "An edit of a shader I posted here a few months ago with some fixes and better shading.", "tags": ["raymarching", "distancefield", "triangle", "heightmap", "mesh"], "likes": 92, "viewed": 5540, "published": "Public API", "date": "1442177752", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Raymarch settings\n\n#define MIN_DIST 0.001\n#define MAX_DIST 12.0\n#define MAX_STEPS 96\n#define STEP_MULT 0.5\n#define NORMAL_OFFS 0.002\n\n//Scene settings\n\n#define QUADS_PER_UNIT 8.0\n#define HAZE_COLOR vec3(0.15, 0.00, 0.10)\n#define GRID_LINE_RADIUS 2.0\n//#define SHOW_RAY_COST\n\n//Derived settings\n#define QUAD_SIZE (1.0/QUADS_PER_UNIT)\n\nfloat pi = atan(1.0) * 4.0;\nfloat tau = atan(1.0) * 8.0;\n\nstruct MarchResult\n{\n    vec3 position;\n    vec3 normal;\n    float dist;\n    float steps;\n};\n\n//Returns the height at a given position.\nfloat Height(vec2 p)\n{\n    p *= QUAD_SIZE;\n    \n    float h = textureLod(iChannel0, p * 0.1 + iTime * 0.01, 0.0).x * 0.5;\n    \n    h += sin(length(p) * 2.0 + iTime) * 0.25;\n    \n\treturn h;\n}\n\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}\n\n//==== Distance field operators/functions by iq. ====\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1, d2);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p) - s;\n}\n\n//Modified to create a plane from 3 points.\nfloat sdPlane( vec3 p, vec3 p0, vec3 p1, vec3 p2 )\n{\n  return dot(p - p0, normalize(cross(p0 - p1, p0 - p2)));\n}\n//===================================================\n\n/*\nDistance to a vertical quad comprised of two triangles.\n\n1-----2\n| 0  /|\n|  /  |\n|/  1 |\n0-----3\n*/\nfloat sdVQuad( vec3 p, float h0, float h1, float h2, float h3)\n{\n    float s = QUAD_SIZE;\n       \n    float diag = sdPlane(p, vec3(0, 0, 0),vec3(s, s, 0),vec3(0, 0, s));\n    \n    float tri0 = sdPlane(p, vec3(0, 0,-h0),vec3(0, s,-h1),vec3(s, s,-h2)); //Triangle 0 (0,1,2)\n    tri0 = opS(-diag, tri0);\n    \n    float tri1 = sdPlane(p, vec3(0, 0,-h0),vec3(s, s,-h2),vec3(s, 0,-h3)); //Triangle 1 (0,2,3)\n    tri1 = opS(diag, tri1);\n    \n    float d = min(tri0,tri1);\n    \n    return d;\n}\n\n//Distance to the scene\nfloat Scene(vec3 p)\n{\n    float d = MAX_DIST;\n    \n    vec3 pm = vec3(mod(p.xy, vec2(QUAD_SIZE)), p.z);\n    \n    vec2 uv = floor(p.xy / QUAD_SIZE);\n    \n    float v0 = Height(uv + vec2(0, 0));\n    float v1 = Height(uv + vec2(0, 1));\n    float v2 = Height(uv + vec2(1, 1));\n    float v3 = Height(uv + vec2(1, 0));\n    \n    d = sdVQuad(pm - vec3(0.0 ,0.0, 0.0), v0, v1, v2, v3);\n    \n    d = opU(d, -sdSphere(p, MAX_DIST - 1.0));\n    \n\treturn d;\n}\n\n//Surface normal at the current position\nvec3 Normal(vec3 p)\n{\n    vec3 off = vec3(NORMAL_OFFS, 0, 0);\n    return normalize\n    ( \n        vec3\n        (\n            Scene(p + off.xyz) - Scene(p - off.xyz),\n            Scene(p + off.zxy) - Scene(p - off.zxy),\n            Scene(p + off.yzx) - Scene(p - off.yzx)\n        )\n    );\n}\n\n//Raymarch the scene with the given ray\nMarchResult MarchRay(vec3 orig,vec3 dir)\n{\n    float steps = 0.0;\n    float dist = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        float sceneDist = Scene(orig + dir * dist);\n        \n        dist += sceneDist * STEP_MULT;\n        \n        steps++;\n        \n        if(abs(sceneDist) < MIN_DIST)\n        {\n            break;\n        }\n    }\n    \n    MarchResult result;\n    \n    result.position = orig + dir * dist;\n    result.normal = Normal(result.position);\n    result.dist = dist;\n    result.steps = steps;\n    \n    return result;\n}\n\n//Scene texturing/shading\nvec3 Shade(MarchResult hit, vec3 direction, vec3 camera)\n{\n    vec3 color = vec3(1.0);\n    \n    //Triangle grid pattern\n    vec2 gridRep = mod(hit.position.xy, vec2(QUAD_SIZE)) / float(QUAD_SIZE) - 0.5;\n    \n    float grid = 0.5 - max(abs(gridRep.x), abs(gridRep.y));\n    grid = min(grid, abs(dot(gridRep.xy, normalize(vec2(-1, 1)))));\n    \n    float lineSize = GRID_LINE_RADIUS * hit.dist / iResolution.y / float(QUAD_SIZE);\n    \n    color *= 1.0-smoothstep(lineSize, lineSize * 0.25, grid);\n    color = color * 0.75 + 0.25;\n    \n    //Lighting\n    float ambient = 0.1;\n    float diffuse = 0.5 * -dot(hit.normal, direction);\n    float specular = 1.1 * max(0.0, -dot(direction, reflect(direction, hit.normal)));\n    \n    color *= vec3(ambient + diffuse + pow(specular, 5.0));\n\t\n    //Fog / haze\n    float sky = smoothstep(MAX_DIST - 1.0, 0.0, length(hit.position));\n    float haze = 1.0 - (hit.steps / float(MAX_STEPS));\n    \n    vec3 skycol = mix(HAZE_COLOR, vec3(0), clamp(-hit.position.z * 0.2, 0.0, 1.0));\n    \n    color = mix(skycol, color, sky * haze);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    //Camera stuff   \n    vec3 angles = vec3(0);\n    \n    if(iMouse.xy == vec2(0,0))\n    {\n        angles.y = tau * (1.5 / 8.0);\n        angles.x = iTime * 0.1;\n    }\n    else\n    {    \n    \tangles = vec3((iMouse.xy / iResolution.xy) * pi, 0);\n        angles.xy *= vec2(2.0, 1.0);\n    }\n    \n    angles.y = clamp(angles.y, 0.0, tau / 4.0);\n    \n    mat3 rotate = Rotate(angles.yzx);\n    \n    vec3 orig = vec3(0, 0,-2) * rotate;\n    orig -= vec3(0, 0, 1);\n    \n    vec3 dir = normalize(vec3(uv - res / 2.0, 0.5)) * rotate;\n    \n    //Ray marching\n    MarchResult hit = MarchRay(orig, dir);\n    \n    //Shading\n    vec3 color = Shade(hit, dir, orig);\n    \n    #ifdef SHOW_RAY_COST\n    color = mix(vec3(0,1,0), vec3(1,0,0), hit.steps / float(MAX_STEPS));\n    #endif\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjSRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[488, 530, 552, 552, 720], [722, 794, 820, 820, 1109], [1111, 1165, 1198, 1198, 1223], [1225, 1225, 1258, 1258, 1285], [1287, 1287, 1322, 1322, 1348], [1350, 1394, 1446, 1446, 1506], [1562, 1665, 1729, 1729, 2149], [2151, 2175, 2196, 2196, 2620], [2622, 2663, 2684, 2684, 2952], [2954, 2994, 3036, 3036, 3543], [3545, 3571, 3629, 3629, 4654], [4656, 4656, 4713, 4713, 5606]], "test": "error"}
{"id": "ltjSRw", "name": "boule", "author": "Dermenslof", "description": "boule", "tags": ["boule"], "likes": 6, "viewed": 163, "published": "Public", "date": "1442550550", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 wave(in vec2 uv, int p, float f, float a, float o)\n{\n    if (a < 0.001)\n        a = 0.00000001;\n    a = 1.0 / a;\n    uv.x = mod((uv.x * float(p) + iTime * f) * 360.0,360.0);\n\tuv.y = ((uv.y - o) * 2.0 * a - a);\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n\tvec2 xy = uv;\n    float s = sin(iTime * 50.0 + uv.x + (-sin((uv.y + 1.0) * 90.0 * 3.14 / 180.0) + 1.0) / 2.0);\n    vec3 col = vec3(0);\n    //col = vec3(0, 0, s);\n    col = clamp(col, 0.0, 1.0);\n    if (uv.x < 0.0)\n        uv.x = uv.x * cos((uv.y + iTime / 10000.0) * 2.0 * 5000.0);\n    uv.y += cos(iTime) * 0.5;\n    float l = length(uv);\n    if (l <= 0.5)\n    {\n        s = (sin((l + 0.5) * 720.0 * 3.14 / 180.0) + 1.0) / 2.0;\n        float c = (cos(l * 360.0 * 3.14 / 180.0) + 1.0) / 2.0;\n        col = vec3(1.0 * s, s * (cos(uv.y * 2.0) + cos(uv.x * 2.0) / 2.0 - 1.0), c);\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjSRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 231], [233, 233, 290, 290, 1008]], "test": "valid"}
{"id": "ltjSzR", "name": "Magic Box Movement", "author": "Mx7f", "description": "Magic box (https://www.shadertoy.com/view/4ljGDd) with varying parameters", "tags": ["fractal", "magicbox"], "likes": 21, "viewed": 556, "published": "Public", "date": "1441142128", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// from \"Magic Fractal\" by dgreensp\n// https://www.shadertoy.com/view/4ljGDd\n// Modified to have varying parameters\n\nconst int MAGIC_BOX_ITERS = 13;\n\n#define PI 3.14159265\nfloat magicBox(vec3 p, float magic) {\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - magic;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n\nmat3 xRot(float a)\n{\n \treturn mat3(1, \t\t0, \t\t0,\n               0, \t\tcos(a), -sin(a),\n               0,\t\tsin(a),\tcos(a));\n}\n\nmat3 yRot(float a)\n{\n \treturn mat3(cos(a), \t\t0, \t\t-sin(a),\n               0, \t\t\t1, \t\t0,\n               sin(a),\t\t0,\t\tcos(a));\n}\n\nmat3 zRot(float a)\n{\n \treturn mat3(cos(a), -sin(a),\t\t0,\n               sin(a),\tcos(a),\t\t0,\n              \t0,\t\t0,\t\t\t1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv are screen coordinates, uniformly scaled to go from 0..1 vertically\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    \n    float t = (iTime+25.0)*0.02;\n    \n    // scroll a certain number of screenfuls/second\n    uv.x += t*5.0;\n\n    \n    float alpha = (sin(t)+1.0 * PI);\n    float beta = (sin(t)+1.0 * PI);\n    float gamma = (sin(t)+1.0 * PI);\n    \n    // A varying 3x3 unitary matrix, used to avoid artifacts from slicing the\n\t// volume along the same axes as the fractal's bounding box. \n    mat3 M = xRot(alpha) * yRot(beta) * zRot(gamma);\n    float MAGIC_BOX_MAGIC = sin(t*10.0)*0.2 + 0.5;\n    \n    // Rotate uv onto the random axes given by M, and scale\n    // it down a bit so we aren't looking at the entire\n    // 1x1x1 fractal volume.  Making the coefficient smaller\n    // \"zooms in\", which may reduce large-scale repetition\n    // but requires more fractal iterations to get the same\n    // level of detail.\n    vec3 p = 0.5*M*vec3(uv, 0.0);\n    \n    float result1 = magicBox(p, MAGIC_BOX_MAGIC);\n    \n    mat3 M2 = xRot(alpha+0.1) * yRot(beta+0.1) * zRot(gamma+0.1);\n    mat3 M3 = xRot(alpha+0.2) * yRot(beta+0.4) * zRot(gamma+0.5);\n    \n    vec3 p2 = 0.5*M2*vec3(uv, 0.0);\n    vec3 p3 = 0.5*M3*vec3(uv, 0.0);\n    \n    float result2 = magicBox(p2, MAGIC_BOX_MAGIC);\n    float result3 = magicBox(p3, MAGIC_BOX_MAGIC);\n    \n    vec3 result = vec3(result1, result2, result3) * 0.03;\n    \n\tfragColor = vec4(result,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjSzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 209, 384, 956], [959, 959, 979, 979, 1081], [1083, 1083, 1103, 1103, 1209], [1211, 1211, 1231, 1231, 1331], [1333, 1333, 1390, 1468, 2826]], "test": "valid"}
{"id": "ltSXz1", "name": "Color Correcter", "author": "vincentpoc", "description": "Advanced Color correct function", "tags": ["colorcorrectcolorbalancehistogram"], "likes": 8, "viewed": 333, "published": "Public", "date": "1441503045", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n   float SpeedA = (1.0+sin(iTime*0.25))*0.5; // 0.0 >> 1.0\n   float SpeedB = sin(iTime); // -1.0 >> 1.0\n   \n   //INPUT\n   vec2 uv = fragCoord.xy / iResolution.xy;\n   vec4 diff = texture(iChannel0, vec2(1.0)-uv);\n   float Lum = diff.r*0.299 + diff.g*0.587 +diff.b*0.114;\n    \n   // PARAMETERS //\n   vec4 GrayAmount = vec4((1.0+sin(iTime*0.13))*0.5);\n   vec4 VShadows = vec4(0.0,cos(iTime*0.12)*0.25,sin(iTime*0.3),SpeedA*0.25);\n   vec4 Vmid = vec4(sin(iTime*0.05),sin(iTime*0.6),0.0,0.0);\n   vec4 Vhigh = vec4(sin(iTime*0.9)*0.5,0.0,0.0,-0.25+cos(iTime*0.25)*0.25);\n   vec4 Gain = vec4(1.0,1.0+cos(iTime*0.12)*0.12,1.0+cos(iTime*0.1)*0.25,0.0);\n    \n    //Histogram split\n    vec4 FShadows = (0.5 + (cos(3.14159 * min(Lum,0.5) * 2.0)) * 0.5) * VShadows;\n\tvec4 FMid = (0.5 - (cos(3.14159 * Lum * 2.0)) * 0.5) * Vmid;\n\tvec4 FHigh = (0.5 + (cos(3.14159 * max(Lum,0.5) * 2.0)) * 0.5) * Vhigh; \n    \n    //Color Correct\n    diff = mix(diff, vec4(Lum), (GrayAmount)); //Desaturation\n    diff = diff + (FShadows * FShadows.a) + (FMid * FMid.a) + (FHigh * FHigh.a); //Color Balance\n    diff = diff * ( vec4(1.0)+FShadows ) * ( vec4(1.0)+FMid ) * ( vec4(1.0)+FHigh ); //Color lift\n    fragColor = diff * Gain; //ColorGain\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltSXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1273]], "test": "error"}
{"id": "Ml2XRD", "name": "Raymarching Basic", "author": "gyabo", "description": "basic", "tags": ["raymarching", "cineshader"], "likes": 47, "viewed": 92003, "published": "Public API", "date": "1442240312", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat map(vec3 p) {\n\tvec3 n = vec3(0, 1, 0);\n\tfloat k1 = 1.9;\n\tfloat k2 = (sin(p.x * k1) + sin(p.z * k1)) * 0.8;\n\tfloat k3 = (sin(p.y * k1) + sin(p.z * k1)) * 0.8;\n\tfloat w1 = 4.0 - dot(abs(p), normalize(n)) + k2;\n\tfloat w2 = 4.0 - dot(abs(p), normalize(n.yzx)) + k3;\n\tfloat s1 = length(mod(p.xy + vec2(sin((p.z + p.x) * 2.0) * 0.3, cos((p.z + p.x) * 1.0) * 0.5), 2.0) - 1.0) - 0.2;\n\tfloat s2 = length(mod(0.5+p.yz + vec2(sin((p.z + p.x) * 2.0) * 0.3, cos((p.z + p.x) * 1.0) * 0.3), 2.0) - 1.0) - 0.2;\n\treturn min(w1, min(w2, min(s1, s2)));\n}\n\nvec2 rot(vec2 p, float a) {\n\treturn vec2(\n\t\tp.x * cos(a) - p.y * sin(a),\n\t\tp.x * sin(a) + p.y * cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime;\n\tvec2 uv = ( fragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n\tuv.x *= iResolution.x /  iResolution.y;\n\tvec3 dir = normalize(vec3(uv, 1.0));\n\tdir.xz = rot(dir.xz, time * 0.23);dir = dir.yzx;\n\tdir.xz = rot(dir.xz, time * 0.2);dir = dir.yzx;\n\tvec3 pos = vec3(0, 0, time);\n\tvec3 col = vec3(0.0);\n\tfloat t = 0.0;\n    float tt = 0.0;\n\tfor(int i = 0 ; i < 100; i++) {\n\t\ttt = map(pos + dir * t);\n\t\tif(tt < 0.001) break;\n\t\tt += tt * 0.45;\n\t}\n\tvec3 ip = pos + dir * t;\n\tcol = vec3(t * 0.1);\n\tcol = sqrt(col);\n\tfragColor = vec4(0.05*t+abs(dir) * col + max(0.0, map(ip - 0.1) - tt), 1.0); //Thanks! Shane!\n    fragColor.a = 1.0 / (t * t * t * t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2XRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 21, 21, 544], [546, 546, 573, 573, 652], [654, 654, 711, 711, 1369]], "test": "valid"}
{"id": "MlBSDW", "name": "Entangled Vines", "author": "Shane", "description": "Flying through an entangled vine structure at dusk.", "tags": ["raymarching", "bisection", "lattice", "log", "vine"], "likes": 143, "viewed": 4718, "published": "Public API", "date": "1443623372", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Entangled Vines\n    ---------------\n    \n    Entangled vine fly-through, which is nothing more than a mutated lattice traversal in disguise.\n    \n    I wrote this on a pretty slow computer, so had to do everything on the cheap, which gave me a\n    good excuse to use Nimitz's Log-Bisection method. I swear I'm not stalking his code, but it seems \n    every time I need a solution to something, one of his examples magically provides the answer. :)\n\n    The rest was written off the top of my head, but is an amalgamation of a whole bunch of things \n    I've encountered on Shadertoy at one time or another. The simple scene itself was constructed \n\twith Gyabo's \"Raymarching Basic\" in mind. Although I've used different methods, I'm pretty sure \n\tDave Hoskins's \"Skin Peeler\" (based on Xyptonjtroz) influenced the coloring style. The misty \n\toverlay is loosely infuenced from the same example.\n    \n    Related examples:\n    \n    Log-Bisection Tracing - Nimitz\n    https://www.shadertoy.com/view/4sSXzD\n    \n    Skin Peeler - Dave Hoskins\n    https://www.shadertoy.com/view/XtfSWX\n    Based on Xyptonjtroz: Nimitz\n    https://www.shadertoy.com/view/4ts3z2\n    \n    Raymarching Basic - Gyabo\n    https://www.shadertoy.com/view/Ml2XRD    \n\n*/\n\n#define FAR 30.\n#define PI 3.14159265\n\n// Grey scale.\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\n// 2x2 rotation matrix.\nmat2 rot(float th) {\n    float cs = cos(th), sn = sin(th); return mat2(cs, -sn, sn, cs);\n}\n\nvec3 firePalette(float i){\n\n    float T = 1400. + 1300.*i; // Temperature range (in Kelvin).\n    vec3 L = vec3(7.4, 5.6, 4.4); // Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    return 1.0-exp(-5e8/L); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    //n = abs(n)/1.732051;\n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    //n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n\n// Hash to return a scalar value from a 3D vector.\nfloat hash31(vec3 p){ return fract(sin(dot(p, vec3(127.1,311.7, 74.7)))*43758.5453); }\n\n// Standard hash algorithm that you'll see all over the place.\nvec3 hash33(vec3 p) { \n\n    // Faster, but doesn't disperse things quite as nicely as the block below it. However, when framerate\n    // is an issue, and it often is, this is the one to use. Basically, it's a tweaked amalgamation I put\n    // together, based on a couple of other random algorithms I've seen around... so use it with caution,\n    // because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec3(7, 157, 113)));\n    return fract(vec3(2097152, 262144, 32768)*n)*2.-1.;  \n    //p = fract(vec3(2097152, 262144, 32768)*n); \n    //return sin(p*TAU + time); // Cheap...ish animation.\n\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = 0.001;\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor)));\n    \n    grad = (grad - getGrey(tex3D(tex,  p , nor)))/eps; \n            \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Smooth minimum function. Hardcoded with the smoothing value \"0.25.\"\nfloat sminP(in float a, in float b ){\n    \n    float h = clamp(2.*(b - a) + 0.5, 0.0, 1.0);\n    return (b - 0.25*h)*(1. - h) + a*h;\n    \n}\n\n// The vine structure.\n// \n// I had Shadertoy user Gyabo's \"Raymarching Basic\" in mind when putting this together:\n// https://www.shadertoy.com/view/Ml2XRD\n// His example Cune is also worth looking at: https://www.shadertoy.com/view/ls2GDR\nfloat map(vec3 p) {\n    \n    // Basic idea: Create a bunch of repeated warped cylinders aligned along the X, Y \n    // and Z directions whilst offsetting their positions. Find their minimum, then \n    // add some bumps.\n    //\n    // \n    // \"length(p.xy) - r\" is a standard way to create a cylinder in the Z-direction.\n    // Performing \"mod(p.xy, a) - a/2.\" will create multiple cylinders.\n    // Perturb the XY-plane to make it windy, and add an offset, while your at it.\n    // Do the same in the X and Y directions.\n    vec2 perturb = vec2(sin((p.z * 2.15 + p.x * 2.35)), cos((p.z * 1.15 + p.x * 1.25)));\n    vec2 perturb2 = vec2(cos((p.z * 1.65 + p.y * 1.75)), sin((p.z * 1.4 + p.y * 1.6)));\n\tvec2 q1 = mod(p.xy + vec2(0.25, -0.5), 2.) - 1.0 + perturb*vec2(0.25, 0.5);\n\tvec2 q2 = mod(p.yz + vec2(0.25, 0.25), 2.) - 1.0 - perturb*vec2(0.25, 0.3);\n\tvec2 q3 = mod(p.xz + vec2(-0.25, -0.5), 2.) - 1.0 - perturb2*vec2(0.25, 0.4);\n\t\n\t// Used to add some bumps on the overall structure. See \"p.x*p.y*p.z.. etc\" below.\n\tp = sin(p*8. + cos(p.yzx*8.));\n\t\n\t// The cylinders.\n\tfloat s1 = length( q1 ) - 0.24; // max(abs(q1.x), abs(q1.y)) - 0.2; // etc.\n\tfloat s2 = length( q2 ) - 0.24;\n\tfloat s3 = length( q3 ) - 0.24;\n\t\n\t/*\n\t// These are cheaper. Unfortunately, the raymarching function takes longer to find the\n\t// hit point, so that can be problematic.\n\tfloat s1 = dot( q1, q1 ) - 0.06; \n\tfloat s2 = dot( q2, q2 ) - 0.06;\n\tfloat s3 = dot( q3, q3 ) - 0.06;\n\t*/\n\t\n\t// Retrieve the minimum of s1, s2 and s3, then add the bumps.\n\t// In this case, a smooth minimum is used, because it looks a little more organic.\n\treturn sminP(sminP(s1, s3), s2) - p.x*p.y*p.z*0.05;\n    \n}\n\n// The iterations should be higher for proper accuracy, but in this case, the shadows are a subtle background feature, so\n// hopefully, it's not too noticeable.\nfloat softShadow(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 12; // 24 or 32 would be better. Even 16 would be good, but my computer says, \"No.\" :)\n\n    // The \"start\" value, or minimum, should be set to something more than the stop-threshold, so as to avoid a collision with \n    // the surface the ray is setting out from. It doesn't matter how many times I write shadow code, I always seem to forget this.\n    // If adding shadows seems to make everything look dark, that tends to be the problem.\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n        // End, or maximum, should be set to the distance from the light to surface point. If you go beyond that\n        // you may hit a surface not between the surface and the light.\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n        \n        // What h combination you add to the distance depends on speed, accuracy, etc. To be honest, I find it impossible to find \n        // the perfect balance. Faster GPUs give you more options, because more shadow iterations always produce better results.\n        // Anyway, here's some posibilities. Which one you use, depends on the situation:\n        // +=max(h, 0.001), +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\n        \n        // In this particular instance the light source is a long way away. However, we're only taking a few small steps\n        // toward the light and checking whether anything \"locally\" gets in the way. If a part of the vine a long distance away\n        // is between our hit point and the light source, it won't be accounted for. Technically that's not correct, but the local\n        // shadows give that illusion... kind of.\n        dist += clamp(h, 0.0001, .2);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (abs(h)<0.001 || dist > end) break; \n    }\n\n    // I usually add a bit to the final shade value, which lightens the shadow a bit. It's a preference thing. Really dark shadows \n    // look too brutal to me.\n    return min(max(shade, 0.) + 0.4, 1.0); \n}\n\n// Standard ambient occlusion. Based on the original by IQ.\nfloat calculateAO(vec3 p, vec3 n){\n\n    const float AO_SAMPLES = 5.0;\n    float r = 0.0, w = 1.0, d;\n    \n    for (float i=1.0; i<AO_SAMPLES+1.1; i++){\n        d = i/AO_SAMPLES;\n        r += w*(d - map(p + n*d));\n        w *= 0.5;\n    }\n    \n    return 1.0-clamp(r,0.0,1.0);\n}\n\n// Tetrahedral normal: I remember a similar version on \"Pouet.net\" years ago, but this one is courtesy of IQ.\n// I'm using it, because I'm trying to make as few surface function calls (4 versus 6) as possible.\nvec3 getNormal( in vec3 p ){\n\n    vec2 e = vec2(0.5773,-0.5773)*0.001;\n    return normalize( e.xyy*map(p+e.xyy ) + e.yyx*map(p+e.yyx ) + e.yxy*map(p+e.yxy ) + e.xxx*map(p+e.xxx ));\n}\n\n\n\n// Log-Bisection Tracing\n// https://www.shadertoy.com/view/4sSXzD\n\n// Log-Bisection Tracing by nimitz (twitter: @stormoid)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Contact: nmz@Stormoid.com\n\n// Notes: I've made some minor changes to Nitmitz's original to suit this particular example. It \n// seems to work, but if you're interested in the function itself, I'd probably bypass this example, \n// and refer to the original function in the link above. There, you'll find a good explanation as to \n// how it works too.\n\n// In essence, the first loop manages to hone in on the hit point pretty quickly, mainly due to the\n// line involving the logarithm (clever). However, it has a tendency to overshoot. If that happens, \n// points from either side of the hit point are fed into the second loop, which employs a bisection \n// method that eventually gets you there. There's a bunch of stuff that I'm skipping over, and you \n// can read about it in the original. The function doesn't work for all setups, but in cases such as \n// this, you can get a pretty decent performance boost.\n\n#define PRECISION 0.001\n\nfloat logBisectTrace( in vec3 ro, in vec3 rd){\n\n\n    float t = 0., told = 0., mid, dn;\n    float d = map(rd*t + ro);\n    float sgn = sign(d);\n\n    for (int i=0; i<80; i++){\n\n        // If the threshold is crossed with no detection, use the bisection method.\n        // Also, break for the usual reasons. Note that there's only one \"break\"\n        // statement in the loop. I heard GPUs like that... but who knows?\n        if (sign(d) != sgn || d < PRECISION || t > FAR) break;\n \n        told = t;\n        \n        // If the distance from the root is high enough, use standard raymarching,\n        // instead of the log bisect method.\n        //if (d > 1.) t += d*.75;\n        // \"0.75\" determines how fast the root finder moves in. Needs to be lowered when dealing \n        // with thin slices. The potential problem is the intersector crossing the function twice \n        // in one step.\n        //else t += log(abs(d) + 1.1)*.75; // //To cross faster, a minimum step size.\n        \n        // Branchless version of the above.        \n        t += step(-1., -d)*(log(abs(d) + 1.1)*.7 - d*.7) + d*.7;\n        \n        d = map(rd*t + ro);\n    }\n    \n    // If a threshold was crossed without a solution, use the bisection method.\n    if (sign(d) != sgn){\n    \n        // Based on suggestions from CeeJayDK, with some minor changes.\n\n        dn = sign(map(rd*told + ro));\n        \n        vec2 iv = vec2(told, t); // Near, Far\n\n        // 6 iterations seems to be more than enough, for most cases...\n        // but there's an early exit, so I've added a couple more.\n        for (int ii=0; ii<8; ii++){ \n            //Evaluate midpoint\n            mid = dot(iv, vec2(.5));\n            float d = map(rd*mid + ro);\n            if (abs(d) < PRECISION)break;\n            // Suggestion from movAX13h - Shadertoy is one of those rare\n            // sites with helpful commenters. :)\n            // Set mid to near or far, depending on which side we're on.\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\n        }\n\n        t = mid; \n        \n    }\n    \n    //if (abs(d) < PRECISION) t += d;\n\n    return t;\n}\n\n\n\n/////\n// Code block to produce four layers of fine mist. Not sophisticated at all.\n// If you'd like to see a much more sophisticated version, refer to Nitmitz's\n// Xyptonjtroz example. Incidently, I wrote this off the top of my head, but\n// I did have that example in mind when writing this.\nfloat trig3(in vec3 p){\n    p = cos(p*2. + (cos(p.yzx) + 1. + iTime*4.)*1.57);\n    return dot(p, vec3(0.1666)) + 0.5;\n}\n\n// Basic low quality noise consisting of three layers of rotated, mutated \n// trigonometric functions. Needs work, but it's OK for this example.\nfloat trigNoise3D(in vec3 p){\n\n    // 3D transformation matrix.\n    const mat3 m3RotTheta = mat3(0.25, -0.866, 0.433, 0.9665, 0.25, -0.2455127, -0.058, 0.433, 0.899519 )*1.5;\n  \n\tfloat res = 0.;\n\n    float t = trig3(p*PI);\n\tp += (t - iTime*0.25);\n    p = m3RotTheta*p;\n    //p = (p+0.7071)*1.5;\n    res += t;\n    \n    t = trig3(p*PI); \n\tp += (t - iTime*0.25)*0.7071;\n    p = m3RotTheta*p;\n     //p = (p+0.7071)*1.5;\n    res += t*0.7071;\n\n    t = trig3(p*PI);\n\tres += t*0.5;\n\t \n\treturn res/2.2071;\n}\n\n// Four layers of cheap trigonometric noise to produce some subtle mist.\n// Start at the ray origin, then take four samples of noise between it\n// and the surface point. Apply some very simplistic lighting along the \n// way. It's not particularly well thought out, but it doesn't have to be.\nfloat getMist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist = 0.;\n    ro += rd*t/8.; // Edge the ray a little forward to begin.\n    \n    for (int i = 0; i<4; i++){\n        // Lighting. Technically, a lot of these points would be\n        // shadowed, but we're ignoring that.\n        float sDi = length(lp-ro)/FAR; \n\t    float sAtt = min(1./(1. + sDi*0.25 + sDi*sDi*0.05), 1.);\n\t    // Noise layer.\n        mist += trigNoise3D(ro*2.)*sAtt;\n        // Advance the starting point towards the hit point.\n        ro += rd*t/4.;\n    }\n    \n    // Add a little noise, then clamp, and we're done.\n    return clamp(mist/2. + hash31(ro)*0.1-0.05, 0., 1.);\n\n}\n\n/////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*0.5)/iResolution.y;\n\n    // Ray origin. Traversing with time along the Z-axis.\n    vec3 ro = vec3(0., 0., iTime*2.);\n    \n    // Lazy way to construct a unit direction ray.\n    vec3 rd = normalize(vec3(uv, 0.5));\n    \n    // Equally lazy way to look around the scene by rotating the unit direction vector. \n    mat2 m2 = rot(iTime * 0.25);\n    rd.xz *= m2;\n    rd.xy *= m2;\n    rd.yz *= m2;\n    \n\n    // The light position. In this case, it's the quasi-distant sun position, which is situated about 30 units in front\n    // of the viewing position, \"ro.\" I've arranged for it to rotate about its postion just a little.\n    // \"rd*10.\" is not realistic. No distant light source rotates around like that, but it makes the shadows move a little.\n    // Obviously, a real sun would be much, much further away, but by keeping it within a workable distance, you can\n    // get a bit of a point light effect.\n    vec3 lp = vec3(0., 0., FAR) + ro + rd*10.;\n    \n    // Standard way to put a light in the sky. Dot the unit direction vector with the unit light direction vector.\n    // Normalize the result, then ramp up the power. In this case, I want to spread the brightness out, so a lower figure \n    // of about \"4\" is being chosen. For a more contrasty sky with intense sun, larger values are used. \n    float bgShade = pow(max(dot(rd, normalize(lp - ro)), 0.)*0.5+0.5, 4.);\n    // Background (or sky) color. Blend the shade between two colors. These two aren't very inspiring, but the coloring\n    // is being done post process, so it's essentially dark to bright for now.\n    vec3 bc = mix(vec3(.0, .0,.05), vec3(1.), bgShade);\n    \n    // Initiate the scene color to the background (sky) color.\n    vec3 sc = bc;\n    \n    // Use Nimitz's really fancy raymarching algorithm. :)\n    float t = logBisectTrace(ro, rd);\n\n    \n    if(t<FAR){\n        \n        // Surface position.\n        vec3 sp = ro + rd*t;\n        \n        // Normal.\n        vec3 sn = getNormal(sp);\n        \n        // Texture bump the normal.\n        const float texSize0 = 1./2.;\n        sn = doBumpMap(iChannel0, sp*texSize0, sn, 0.025);\n        \n        // Obtain the texel color at the surface position.\n        vec3 objCol = tex3D( iChannel0, sp*texSize0, sn );//vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 10.));\n        \n        // Light direction vector. From the sun to the surface point.\n        vec3 ld = lp-sp;\n        \n        // Distance from the surface postion to the light source (sun position).\n        float lDist = max(length(ld), 0.001);\n        \n        ld /= lDist; // Normalize the light direct vector.\n\t    \n\t    // Attenuation, based on the distance of the light (sun) to the surface point.\n\t    lDist /= FAR; // Bringing the light distance down to the zero to one range, which is more workable.\n        float sAtten = min(1./(1. + lDist*0.125 + lDist*lDist*0.05), 1.);\n        \n \t    \n        // Shadowing and occlusion. \n        float shad = softShadow(sp, ld, 0.05, FAR, 8.);\n        float ao = calculateAO(sp, sn);\n    \t\n    \t// Standard diffuse and specular calculations.\n        float diff = max(dot(sn, ld), 0.);\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.);\n       \n        // Combining the properties above to produce the lit color.\n        sc = (objCol*(diff + 0.5) + spec)*sAtten;\n       \n        // Applying the shadows and occlusion.\n        sc = min(sc, 1.)*shad*ao;\n        \n    \n    }\n    \n    \n    // Fog.\n    //\n    // Fog - Based on distance from the viewing position. Not to be confused with the misty haze.\n    // Mix the background color (sky color above) and the object color according to a falloff value,\n    // which is analogous to fog, so we call it that. Pretty standard.\n    float fog = min(1.0 / (1. + t*0.25 + t*t*0.025), 1.);\n    sc = mix(bc, sc, fog);\n    //sc = mix(sc, bc, smoothstep(0.0, FAR-20., t)); // Another way to mix things, but using a quick transition.\n    \n    \n    // Color post processing. Fading from orange to the original color... for no particular reason.\n    // Comment the following block out to see the original effect minus the orange.\n    vec3  sc2 = firePalette(getGrey(sc));\n    float fadeFactor = min(1.0 / (1. + t), 1.); // Color fade factor. Made up to suit the conditions.\n    sc = mix(sc, sc2, fadeFactor*0.34+0.66);\n    \n    \n    // Fake misty overlay.  \n    //\n    // Adding the misty haze... otherwise known as the lamest volumetric effect ever. :)\n    // Start at the ray origin, then accumulate four layers between it and the hit position.\n    float mist = getMist(ro, rd, lp, t);\n    \n    // Combining the mist value, sky color (bgShade, etc) and fog to give a fog color.\n    // Part science, part made up.\n    vec3 fogCol = mix(vec3(bgShade*0.8+0.2)*vec3(1., 0.85, 0.6), sc, mist*fog);\n    // Toning down the fog color. Totally made up. :)\n    sc = sc*0.65 + fogCol*0.35;\n     \n    \n    // Done.\n\tfragColor = vec4(clamp(sc, 0., 1.), 1.0);\n\t\n}\n", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBSDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1288, 1303, 1325, 1325, 1369], [1371, 1395, 1415, 1415, 1485], [1487, 1487, 1513, 1513, 1837], [1840, 1994, 2044, 2075, 2302], [2305, 2356, 2377, 2377, 2442], [2444, 2507, 2528, 2894, 3109], [3111, 3193, 3266, 3266, 3709], [3711, 3782, 3819, 3819, 3920], [3922, 4162, 4181, 4682, 5827], [5829, 5990, 6073, 6073, 8520], [8522, 8582, 8616, 8616, 8858], [8860, 9070, 9098, 9098, 9252], [10406, 10406, 10452, 10452, 12530], [12534, 12826, 12849, 12849, 12945], [12947, 13092, 13121, 13155, 13590], [13592, 13884, 13946, 13946, 14551], [14560, 14560, 14617, 14650, 19621]], "test": "error"}
{"id": "MlBSzm", "name": "Math 1.1.2", "author": "ichko", "description": "First shader", "tags": ["umbrella"], "likes": 3, "viewed": 147, "published": "Public", "date": "1442435644", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 col = mix(vec3(1.0,0.2,0.5), vec3(1.0,0.2,0.0), sqrt(p.y));\n    \n    vec2 q = p - vec2(0.8, 0.5);\n    q *= 1. + 0.2*tan(atan(q.y, q.x)*10.+iTime*5.)/5. + q.x*q.y*2.;\n    \n    col *= smoothstep(0.2, 0.5, length(q));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBSzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 399]], "test": "valid"}
{"id": "MlBXDz", "name": "Alien homeworld", "author": "AdamAlexander", "description": "An alien planet.\n\nUncomment ENABLE_DETAILS to add details to the planet and clouds.", "tags": ["raymarching", "planet", "alien", "atmosphericscattering"], "likes": 21, "viewed": 652, "published": "Public", "date": "1443509754", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ENABLE_DETAILS\n#define ENABLE_CLOUDS\n\nconst float PI = 3.14159265359;\nconst float ROTATE_PERIOD = 240.0;\nconst float precis = .02;\nconst int IN_STEPS = 10;\nconst float FIN_STEPS = 10.0;\nconst int OUT_STEPS = 5;\nconst float FOUT_STEPS = 5.0;\n\n// Scale constants\nconst float SCALE = 100.0;\nconst float MAX = SCALE*100.0;\nconst float OCEAN_FLOOR = 0.98;\nconst float OCEAN = 0.99;\nconst float SEA_LEVEL= OCEAN*SCALE;\nconst float ATMOSPHERE = 1.05;\nconst float ATMOSPHERE_LOWER = SCALE;\nconst float ATMOSPHERE_UPPER = ATMOSPHERE*SCALE;\nconst float ATMOSPHERE_HEIGHT = ATMOSPHERE_UPPER - ATMOSPHERE_LOWER;\n\nconst float H0 = 4.0 / ATMOSPHERE_HEIGHT;\n\n// Scatter constants\nconst float K_R = 0.05;\nconst float K_M = 0.0025;\nconst float K_C = 6.0;\nconst float E = 14.3; \t\t\t\t\t\t// light intensity\nconst vec3 C_R = vec3(0.21, 0.66, 1.0);\t\t// 1 / wavelength ^ 4\nconst vec3 C_C = vec3(1.0);\nconst float G_M = -0.81;\t\t\t\t\t// Mie g\nconst float G_C = 0.10;\n\nmat3 rotX(float a) { return mat3(1.0, 0.0, 0.0, 0.0, cos(a), sin(a), 0.0, -sin(a), cos(a)); }\nmat3 rotY(float a) { return mat3(cos(a), 0.0, sin(a), 0.0, 1.0, 0.0, -sin(a), 0.0, cos(a)); }\nmat3 rotZ(float a) { return mat3(cos(a), sin(a), 0.0, -sin(a), cos(a), 0.0, 0.0, 0.0, 1.0); }\n\nmat3 planetSpin() { return rotY(-iTime*PI/ROTATE_PERIOD); }\n\nfloat time() {\n\tvec2 mo = iMouse.xy/iResolution.xy;\n    return iTime + mo.x*64.0;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n/* Noises ************************************************************************/\n\n/* From iq elevated shader: https://www.shadertoy.com/view/MdX3Rr */\nfloat noise3( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\n/* From Ashima webgl noise library: https://github.com/ashima/webgl-noise/wiki */\nvec4 permute(vec4 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec2 cellular2x2x2(vec3 P) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 1/2-K/2\n#define K2 0.020408163265306 // 1/(7*7)\n#define Kz 0.166666666667 // 1/6\n#define Kzo 0.416666666667 // 1/2-1/6*2\n#define jitter 0.8 // smaller jitter gives less errors in F2\n\tvec3 Pi = mod(floor(P), 289.0);\n \tvec3 Pf = fract(P);\n\tvec4 Pfx = Pf.x + vec4(0.0, -1.0, 0.0, -1.0);\n\tvec4 Pfy = Pf.y + vec4(0.0, 0.0, -1.0, -1.0);\n\tvec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n\tp = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n\tvec4 p1 = permute(p + Pi.z); // z+0\n\tvec4 p2 = permute(p + Pi.z + vec4(1.0)); // z+1\n\tvec4 ox1 = fract(p1*K) - Ko;\n\tvec4 oy1 = mod(floor(p1*K), 7.0)*K - Ko;\n\tvec4 oz1 = floor(p1*K2)*Kz - Kzo; // p1 < 289 guaranteed\n\tvec4 ox2 = fract(p2*K) - Ko;\n\tvec4 oy2 = mod(floor(p2*K), 7.0)*K - Ko;\n\tvec4 oz2 = floor(p2*K2)*Kz - Kzo;\n\tvec4 dx1 = Pfx + jitter*ox1;\n\tvec4 dy1 = Pfy + jitter*oy1;\n\tvec4 dz1 = Pf.z + jitter*oz1;\n\tvec4 dx2 = Pfx + jitter*ox2;\n\tvec4 dy2 = Pfy + jitter*oy2;\n\tvec4 dz2 = Pf.z - 1.0 + jitter*oz2;\n\tvec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1; // z+0\n\tvec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2; // z+1\n\n\tvec4 d = min(d1,d2); // F1 is now in d\n\td2 = max(d1,d2); // Make sure we keep all candidates for F2\n\td.xy = (d.x < d.y) ? d.xy : d.yx; // Swap smallest to d.x\n\td.xz = (d.x < d.z) ? d.xz : d.zx;\n\td.xw = (d.x < d.w) ? d.xw : d.wx; // F1 is now in d.x\n\td.yzw = min(d.yzw, d2.yzw); // F2 now not in d2.yzw\n\td.y = min(d.y, d.z); // nor in d.z\n\td.y = min(d.y, d.w); // nor in d.w\n\td.y = min(d.y, d2.x); // F2 is now in d.y\n\treturn sqrt(d.xy); // F1 and F2\n}\n/* End Noises *********************************************************************/\n\nvec2 planetMap(in vec3 p) \n{\n    p = planetSpin()*p;\n    \n    // Noises\n    float pn1 = noise3(p/32.0);\n    float pn2 = noise3(p*(2.1/32.0));\n    float pn3 = noise3(p*(4.2/32.0));\n    \n    // Perlin FBM\n    float pf1 = pn1 + 0.5*pn2 + 0.25*pn3;\n    \n    // Ridged multi fractal\n    float rmf = 0.0;\n    float signal = 0.0;\n    signal = pow(1.0-abs(pn2), 2.0); rmf += signal;\n    signal = pow((1.0-abs(pn3)), 2.0)*clamp(signal*1.5, 0.0, 1.0); rmf += 0.5*signal;\n    \n#ifdef ENABLE_DETAILS\n    float pn4 = noise3(p*(8.82/32.0));\n    float pn5 = noise3(p*(18.522/32.0));\n    float pn6 = noise3(p*(38.8962/32.0));\n    \n    pf1 += 0.125*pn4 + 0.0625*pn5 + 0.03125*pn6;\n    \n    signal = pow((1.0-abs(pn4)), 2.0)*clamp(signal*1.5, 0.0, 1.0); rmf += 0.25*signal;\n    signal = pow((1.0-abs(pn5)), 2.0)*clamp(signal*1.5, 0.0, 1.0); rmf += 0.125*signal;\n    signal = pow((1.0-abs(pn6)), 2.0)*clamp(signal*1.5, 0.0, 1.0); rmf += 0.06125*signal;\n#endif\n    \n    float d = 0.0;\n    float mat = 1.0;\n    d += ATMOSPHERE_HEIGHT/4.0 * pf1;\n    float land = clamp(d/(ATMOSPHERE_HEIGHT/4.0), 0.0, 1.0);\n    \n    // Mountain\n    float mn = 2.5*rmf;\n    float mountainMask = smoothstep(0.55, 1.0, clamp(abs(0.925-pn2), 0.0, 1.0))*land;\n    \n    mat = mix(mat, 2.0, smoothstep(0.0, 0.5, mountainMask));\n    d += mix(0.0, mn, mountainMask);\n    \n    return vec2(sdSphere(p, SEA_LEVEL+d), mat);\n}\n\nfloat waterDepth(vec3 pos, float tol) {\n\tvec3 dir = -normalize(pos);\n    float t = 0.0;\n    for (int i=0; i < 10; i++) {\n    \tvec2 res = planetMap(pos+dir*t);\n        t += res.x*tol;\n    }\n    return t;\n}\n\nvec2 map(in vec3 pos) {\n    vec2 planet = planetMap(pos);\n    vec2 water = vec2(sdSphere(pos, SCALE*OCEAN), 10.0);\n  \n    vec2 res = opU(planet, water);\n    return res;\n}\n\n// From \"Ray Marching - Primitives\" shader: https://www.shadertoy.com/view/Xds3zN\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.25, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 sunDirection() { return normalize( vec3(0.0, 0.0, -1.0) ); }\nvec3 sunColour() { return vec3(1.0, 1.0, 1.0); }\n\nvec2 rayMarch(in vec3 ro, in vec3 rd, float tol, float tmin, float tmax) {\n\tfloat t = tmin;\n\tfloat m = -1.0;\n    \n    for (int i=0; i<60; i++) {\n\t\tvec2 res = map(ro+rd*t);\n        m = res.y;\n\t\tif (res.x < precis || t > tmax)  break;\n\t\tt += res.x*tol;\n\t}\n\n\tif (t > tmax) {\n\t\tm = -1.0;\n\t}\n\treturn vec2(t, m);\n}\n\n/* Atmospheric scattering code from gltracy shader: https://www.shadertoy.com/view/lslXDr\n * with additions for clouds and reflections from the planet surface. */\nvec2 lineIntersectSphere(in vec3 o, in vec3 dir, float r) {\n\tfloat b = dot( o, dir );\n\tfloat c = dot( o, o ) - r * r;\n\t\n\tfloat d = b * b - c;\n\tif ( d < 0.0 ) {\n\t\treturn vec2( MAX, -MAX );\n\t}\n\td = sqrt( d );\n\t\n\treturn vec2( -b - d, -b + d );\n}\n\nfloat phase_mie( float g, float c, float cc ) {\n\tfloat gg = g * g;\n\t\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\n\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n\tb *= sqrt( b );\n\tb *= 2.0 + gg;\t\n\t\n\treturn 1.5 * a / b;\n}\n\nfloat phase_reyleigh( float cc ) {\n\treturn 0.75 * ( 1.0 + cc );\n}\n\nfloat airDensity(vec3 p) {\n    return exp(-(max(length(p), ATMOSPHERE_LOWER) - SCALE) * H0);\n}\n\nfloat aerosolDensity(vec3 p) {\n    return exp(-(max(length(p), ATMOSPHERE_LOWER) - SCALE) * H0);\n}\n\n/* When cloudView is non-zero, clouds are faded out as they approach right angles with this\n * vector. Helps to stop artifacts on the horizon. */\nfloat cloudDensity(vec3 p, vec3 cloudView) {\n    vec3 np = planetSpin()*p;\n    float polarness = abs(dot(normalize(np), vec3(0.0,1.0,0.0)));\n    np *= rotY(0.5*(1.0-polarness*polarness)*sin(2.5*normalize(np).y + iTime/75.0) + 0.25*(1.0-polarness*polarness)*cos(2.5*normalize(np).x + iTime/150.0));\n    \n    // Noises\n\tfloat t = iTime/2.0;\n    vec3 dir = sin(t + PI*(p.x/4.0))*vec3(1.0,0.0,0.0) + cos(t + PI*(p.y/4.0))*vec3(0.0,1.0,0.0) + cos(t + PI*(p.z/4.0))*vec3(0.0,0.0,1.0);\n    float pn1 = (noise3((np + 0.5*dir)/14.0)-0.45)/0.55 + 3.0*pow(polarness, 1.75);\n    float pn2 = noise3((np + 0.5*dir)/7.0);\n    \n    float cn = 0.05*pn1 + 0.025*pn2;\n    \n#ifdef ENABLE_DETAILS\n    float pn3 = noise3((np + 0.5*dir)/3.5);\n    cn += 0.0125*pn3;\n#endif\n    \n    float edgeness = (1.0-length(cloudView))+abs(dot(normalize(p), cloudView));\n    edgeness = pow(edgeness, 1.5);\n    cn *= edgeness;\n    \n    float hs = clamp((length(p)-SCALE)/ATMOSPHERE_HEIGHT, 0.0, 1.0);\n    return exp(-pow(hs -.35, 2.0)/0.02)*clamp(cn, 0.0, 1.0)*2.0;\n}\n\nvec3 density(vec3 p, vec3 cloudView) {\n#ifdef ENABLE_CLOUDS\t\n    return vec3(airDensity(p), aerosolDensity(p), cloudDensity(p, cloudView));\n#else\n    return vec3(airDensity(p), aerosolDensity(p), 0.0);\n#endif    \n}\n\nvec3 optic(vec3 pa, vec3 pb, vec3 cloudView)\n{\n\tvec3 step = (pb - pa)/FOUT_STEPS;\n    vec3 pn = pa + step*0.5;\n    \n    vec3 sum = vec3(0.0);\n    for (int i = 0; i < OUT_STEPS; i++)\n    {\n        sum += density(pn, cloudView);\n    \tpn += step;\n    }\n    sum *= length(step)/ATMOSPHERE_HEIGHT;\n    \n    return sum;\n}\n\nvec3 attenuate(vec3 pa, vec3 pb, vec3 cloudView)\n{\n\tvec3 o = optic(pa, pb, cloudView) * (PI * 4.0);\n    return exp(-o.x*K_R*C_R -o.y*K_M - o.z*K_C*C_C);\n}\n\nvec3 in_scatter(vec3 o, vec3 dir, vec2 P)\n{\n\tvec3 sun = sunDirection();\n    float stepLength = (P.y-P.x)/FIN_STEPS;\n    vec3 step = dir*stepLength;\n    vec3 pa = o+dir*P.x;\n    vec3 pn = pa+step*0.5;\n    \n    vec3 air = vec3(0.0);\n    vec3 aerosols = vec3(0.0);\n    vec3 clouds = vec3(0.0);\n    for (int i = 0; i < IN_STEPS; i++)\n    {\n        vec2 c = lineIntersectSphere(pn, sun, ATMOSPHERE_UPPER);\n        vec3 ppc = pn + sun*c.y;\n        \n        vec3 d = density(pn, dir);\n        vec3 atn = attenuate(pa, pn, dir)*attenuate(pn, ppc, dir);\n        air += d.x*atn;\n        aerosols += d.y*atn;\n        clouds += d.z*atn;\n        \n        pn += step;\n    }\n    air *= stepLength/ATMOSPHERE_HEIGHT;\n    aerosols *= stepLength/ATMOSPHERE_HEIGHT;\n    clouds *= stepLength/ATMOSPHERE_HEIGHT;\n    \n    float c = dot(dir, -sun);\n    float cc = c*c;\n    \n    vec3 I = vec3(0.0);\n    I += K_R * C_R * phase_reyleigh(cc) * air;\n    I += K_M * phase_mie(G_M, c, cc) * aerosols;\n    I += K_C * C_C * phase_mie(G_C, c, cc) * clouds;\n    return I * E;\n}\n\nvoid planetColour(in vec3 pos, in float mat, out vec3 refl, out vec3 emitted) {\n    vec3 oldPos = pos;\n    pos = planetSpin()*pos;\n    float land = clamp((length(pos)-SEA_LEVEL)/(ATMOSPHERE_HEIGHT), 0.0, 1.0);\n    vec3 n = calcNormal(pos);\n    vec3 up = normalize(pos);\n    float updotn = dot(n, up);\n    float ydotn = dot(n, vec3(0.0, 1.0, 0.0));\n    float sundotn = dot(normalize(oldPos), sunDirection());\n    float h = waterDepth(oldPos, 0.5);\n    vec3 col = vec3(0.0);\n    emitted = vec3(0.0);\n    \n    // Detail noises\n    float pnb = noise3((pos+59.0)/16.0);\n    float pn1 = noise3(pos/2.0);\n    float pn2 = noise3((pos+59.0));\n    float pn3 = noise3((pos+129.0)*2.0);\n    \n    vec2 cn1 = cellular2x2x2(pos);\n    \n    float pf = pn1 + .5*pn2 + .25*pn3;\n    \n#ifdef ENABLE_DETAILS\n    float pn4 = noise3((pos+129.0)*4.0);\n    float pn5 = noise3((pos+129.0)*8.0);\n    float pn6 = noise3((pos+129.0)*16.0);\n    \n    pf += .125*pn4 + 0.0625*pn5 + 0.03125*pn6;\n#endif\n    \n    // Land\n    const vec3 cShore1 = vec3(0.62, 0.31, 0.4);\n    const vec3 cShore2 = vec3(1.2, 0.1, 0.1);\n    const vec3 cShore3 = vec3(1.2, 1.0, 1.0);\n    const vec3 cShore4 = vec3(1.0, 1.0, 1.0);\n    \n    vec3 cShoreMix1 = mix(cShore1, cShore2, (1.0+pf)/2.)*(0.25 + 0.75*smoothstep(0.0, 0.1, land));\n    vec3 cShoreMix2 = mix(cShore3, cShore4, (1.0+pf)/2.)*(0.25 + 0.75*smoothstep(0.0, 0.1, land));\n    vec3 shoreCol = mix(cShoreMix1, cShoreMix2, (1.+pnb)/2.);\n    float coastMask = smoothstep(0.04, 0.15, land+(0.04*pf));\n\n    // Land is divided into grass and dessert - yum\n    const vec3 cGrass1 = vec3(0.6, 0.9, 0.4)*0.65;\n    const vec3 cGrass2 = vec3(0.8, 0.8, 0.2)*0.75;\n    const vec3 cDesert = vec3(1.42, 0.8, 0.4);\n    vec3 cGrassMix = mix(cGrass1, cGrass2, pf);\n    float desertMask = smoothstep(0.1, 0.30, pnb+0.15*pf);\n    vec3 biomeCol = mix(cGrassMix, cDesert, desertMask);\n    \n    vec3 landCol = mix(shoreCol, biomeCol, clamp(coastMask+0.5*desertMask, 0.0, 1.0));\n    col += mix(vec3(0.0), landCol, clamp(1.0-abs(mat - 1.), 0.0, 1.0));\n    \n    // Cities in the desert - they turn their lights on at night, off during the day\n    float cityMask = (1.0-smoothstep(0.25, 0.26, sundotn))*(cn1.y - cn1.x)*desertMask;\n    vec3 cityLights = mix(vec3(0.0), vec3(2.0,0.5,1.5)*clamp(cityMask*pf, 0.0, 1.0), clamp(1.0-abs(mat - 1.), 0.0, 1.0));\n    \n    // Mountain\n    const vec3 cMountainTopLow = vec3(0.6, 0.55, 0.65)*0.75;\n    const vec3 cMountainTopHigh = vec3(1.2,1.2,1.2);\n    const vec3 cMountain = vec3(0.6,0.55,0.55);\n    vec3 mountainTopCol = mix(cMountainTopLow, cMountainTopHigh, smoothstep(0.7, 0.8, land));\n    vec3 mountainCol = mix(cMountain, mountainTopCol, clamp(pow(updotn, 12.0), 0.0, 1.0));\n    col += mix(vec3(0.0), mountainCol, clamp(1.0-abs(mat - 2.), 0.0, 1.0));\n    \n    // Sea\n    const vec3 oceanColour = vec3(0.1, 0.0, 0.4);\n    const vec3 shoreColour = vec3(.4, .5, .99)*1.0;\n    vec3 cSeaMix = mix(oceanColour, shoreColour, smoothstep(0.35, 0.0, h+0.05*pf));\n    col += mix(vec3(0.0), cSeaMix, float(mat==10.));\n\n    refl = col;\n    emitted = cityLights;\n}\n\nvec3 renderPlanet(in vec3 ro, in vec3 rd, vec2 map)\n{\n    float tMax = SCALE*25.0;\n    \n    float t = map.x;\n\tfloat m = map.y;\n\tvec3 pos = ro + t*rd;\n    \n    // Calculate sunlight after passing through atmosphere\n    vec3 sun = sunDirection();\n    vec3 cLow = pos * (ATMOSPHERE_LOWER/length(pos));\n    vec2 c = lineIntersectSphere(cLow, sun, ATMOSPHERE_UPPER);\n    vec3 ppc = pos + sun*c.y;\n    vec3 sunColour = attenuate(pos, ppc, vec3(0.0));\n    \n    // Fake a bit of skylight, depending on angle to the sun.\n    float sunAngle = dot(normalize(pos), sun);\n    sunColour += vec3(0.0, 0.235, 0.275) * sunAngle;\n    \n\tvec3 nor = calcNormal(pos);\n    vec3 ref = reflect( rd, nor );\n\n    float dif = clamp( dot( nor, sun ), 0.0, 1.0 );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    float spe;\n    \n    vec3 col, em;\n    planetColour(pos, m, col, em);\n    vec3 brdf = vec3(0.0);\n    \n\t// Land\n    float isLand = mix(0.0, 1.0, float(m < 10.));\n    spe = pow(clamp( dot( ref, sun ), 0.0, 1.0 ),12.0);\n    brdf += 0.1*col * isLand;\n    brdf += 0.9*dif*col * isLand;\n    brdf += 0.01*spe*vec3(1.0, 1.0, 1.0)*dif * isLand;\n    \n    // Ocean\n    float isOcean = mix(0.0, 1.0, float(m == 10.));\n    spe = pow(clamp( dot( ref, sun ), 0.0, 1.0 ),16.0);\n    brdf += 0.4*col * isOcean;\n    brdf += 0.2*spe*vec3(1.0) * isOcean;\n    \n\treturn brdf*sunColour + em;\n}\n\nvec3 renderSpace(in vec3 rd)\n{\n    vec3 col = vec3(0.0);\n    \n    // Noises\n    float pn1 = noise3(rd*2.0+iTime/400.0);\n    vec2 cellular = cellular2x2x2(rd*78.0*(1.+0.25*pn1));\n    \n    // Sun mixin factors\n    vec3 sun = sunDirection();\n    float f = clamp(dot(rd, sun), 0.0, 1.0);\n    f = pow(f, 30.0);\n    \n    // Mix in galaxy\n    vec3 gc = smoothstep(0.75+0.05*pn1, 1.0, (1.0 - cellular.x))*texture(iChannel1, rd.xy).xyz*2.5*(1.0-f);\n    gc *= (vec3(1.0) + vec3(0.0,0.0,1.5)*abs(pn1));\n    col += gc;\n    \n\t// Mix in sun\n    vec3 sunCol = vec3(0.85, 0.85, 1.0);\n    col += f*2.0*sunCol;\n    return col;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n\tvec2 atmosIntersect = lineIntersectSphere(ro, rd, ATMOSPHERE_UPPER);\n     \n    vec2 planetIntersectSphere = lineIntersectSphere(ro, rd, SCALE);\n    vec2 planetIntersect = rayMarch(ro, rd, 0.75, 1.0, MAX);\n    \n    vec2 P = vec2(atmosIntersect.x, min(atmosIntersect.y, planetIntersect.x));\n    \n    vec3 col = vec3(0.0);\n    if (atmosIntersect.x < MAX)\n    {\n        col += in_scatter(ro, rd, P);\n    }\n\n    if (planetIntersect.x < atmosIntersect.y)\n    {\n        vec3 pa = ro + rd*P.x;\n        vec3 pb = ro + rd*P.y;\n        col += renderPlanet(ro, rd, planetIntersect) * attenuate(pa, pb, vec3(0.0));\n    } else\n    {\n        col += renderSpace(rd);\n    }\n    \n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    // Camera origin\n    vec3 ro = vec3(sin(time()/8.0)*SCALE*2.0635, 0.0, cos(time()/8.0)*SCALE*2.0635);\n\n\t// Camera look-at pos\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    \n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.x/1.0, p.y, 2.0) );\n    \n\tvec3 col = render(ro, rd);\n    //col = pow( col, vec3(0.4545) );\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[947, 947, 967, 967, 1040], [1041, 1041, 1061, 1061, 1134], [1135, 1135, 1155, 1155, 1228], [1230, 1230, 1249, 1249, 1289], [1291, 1291, 1305, 1305, 1374], [1376, 1376, 1411, 1411, 1437], [1439, 1439, 1469, 1469, 1502], [1589, 1658, 1685, 1685, 1903], [1905, 1987, 2009, 2009, 2054], [2055, 2055, 2077, 2077, 2122], [2124, 2124, 2152, 2152, 3718], [3805, 3805, 3833, 3833, 5178], [5180, 5180, 5219, 5219, 5384], [5386, 5386, 5409, 5409, 5556], [5558, 5640, 5672, 5672, 5892], [5894, 5894, 5915, 5915, 5959], [5960, 5960, 5978, 5978, 6008], [6010, 6010, 6084, 6084, 6318], [6320, 6483, 6542, 6542, 6725], [6727, 6727, 6774, 6774, 6930], [6932, 6932, 6966, 6966, 6997], [6999, 6999, 7025, 7025, 7093], [7095, 7095, 7125, 7125, 7193], [7195, 7341, 7385, 7385, 8370], [8372, 8372, 8410, 8410, 8586], [8588, 8588, 8634, 8634, 8903], [8905, 8905, 8955, 8955, 9059], [9061, 9061, 9104, 9104, 10104], [10106, 10106, 10185, 10185, 13177], [13179, 13179, 13232, 13232, 14545], [14547, 14547, 14577, 14577, 15157], [15159, 15159, 15196, 15196, 15877], [15879, 15879, 15931, 15931, 16108], [16110, 16110, 16167, 16167, 16739]], "test": "error"}
{"id": "MlBXWh", "name": "Wassup, El Worldo!", "author": "noidexe", "description": "testing", "tags": ["n00b"], "likes": 0, "viewed": 112, "published": "Public", "date": "1443205366", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 f, in vec2 pos )\n{\n\tfloat o = iTime;\n    vec2 uv = pos.xy / iResolution.xy;\n    f =  vec4(\n        (sin(iTime*10.0)+1.0)/2.0,\n        sin(uv.x * uv.y * iTime*10000.0 ),\n        (cos(iTime*10.0)+1.0)/2.0,\n        1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBXWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 242]], "test": "valid"}
{"id": "MlBXzm", "name": "sphere stuff", "author": "tly", "description": "idea from http://www.josleys.com/article_show.php?id=83, linked by BeyondTheStatic :)", "tags": ["sphere", "reflections"], "likes": 8, "viewed": 1653, "published": "Public API", "date": "1442440664", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Ray{\n\tvec3 p,v;\n};\n\t\nstruct Sphere{\n\tvec3 o;\n\tfloat r;\n};\n\t\nstruct Hit{\n\tvec3 p;\n\tvec3 n;\n\tfloat l;\n};\n\nvec3 color(int index){\n\tif(index == 0) return vec3(0,0,1);\n    if(index == 1) return vec3(0,1,1);\n    if(index == 2) return vec3(1,0,0);\n    if(index == 3) return vec3(1,1,0);\n    if(index == 4) return vec3(0,1,0);\n    if(index == 5) return vec3(1,0,1);\n    else return vec3(0);\n}\nconst float infinity = 100000000000.0;\n\t\nHit hit(Ray ray,Sphere sphere){\n\tvec3 o = sphere.o - ray.p;\n\t\n\tfloat p = dot(ray.v,o);\n\tfloat q = dot(o,o) - sphere.r * sphere.r;\n\t\n\tvec2 d = p + vec2(1,-1) * sqrt(p*p - q);\n\tvec3 p0 = ray.p + ray.v * min(d.x,d.y);\n\treturn Hit(\n        p0, //hitpoint\n        (p0 - sphere.o)/sphere.r, //avoiding \"normalize\"\n        (d.x > 0.0 && d.y > 0.0) ? min(d.x,d.y) : infinity //throw away if hitpoints are behind the rayposition\n\t);\t\n}\n\nvec3 rotateY(in vec3 v, in float a) {\n\treturn vec3(cos(a)*v.x + sin(a)*v.z, v.y,-sin(a)*v.x + cos(a)*v.z);\n}\n\nvec3 rotateX(in vec3 v, in float a) {\n\treturn vec3(v.x,cos(a)*v.y + sin(a)*v.z,-sin(a)*v.y + cos(a)*v.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = (fragCoord.xy - iResolution.xy*0.5 )/iResolution.y;\n\t\n\tRay ray = Ray(vec3(0),normalize(vec3(uv.x,uv.y,0.75)));\n\tray.v = rotateY(ray.v,-0.1 * iTime);\n    ray.v = rotateX(ray.v,-0.13 * iTime);\n\t\n\tfloat r = mix(0.6,sqrt(3.0) * 0.5,min(1.0,1.5 * pow(sin(iTime) * 0.5 + 0.5,0.3)));\n\tSphere spheres[6];\n    spheres[0] = Sphere(vec3(0,0,+1),r);\n\tspheres[1] = Sphere(vec3(0,0,-1),r);\n\tspheres[2] = Sphere(vec3(0,+1,0),r);\n\tspheres[3] = Sphere(vec3(0,-1,0),r);\n\tspheres[4] = Sphere(vec3(+1,0,0),r);\n\tspheres[5] = Sphere(vec3(-1,0,0),r);\n\t\n    float factor = 0.7;\n    float lightStrength = 1.0;\n    fragColor = vec4(0,0,0,1);\n\t\n\tconst int REFLECTIONS = 9;\n\tfor(int i = 0; i < REFLECTIONS; i++){\n        Hit h = Hit(vec3(0),vec3(0),infinity);\n        int found = -1;\n\t\tfor(int j = 0; j < 6; j++){\n\t\t\tHit x = hit(ray,spheres[j]);\n            if(x.l < h.l){\n                h = x;\n                found = j;\n           \t}\n\t\t}\n\t\tif(found != -1){\n\t\t\tray.p = h.p;\n\t\t\tray.v = reflect(ray.v,h.n);\n            \n            vec3 lightVec = -normalize(h.p);\n            float diffuse = dot(h.n,lightVec);\n            float specular = pow(abs(dot(reflect(-lightVec,h.n),lightVec)),20.0);\n\t\t\tfragColor.xyz += lightStrength * (diffuse * color(found) + specular);\n        }\n        lightStrength *= factor;\n\t}\n\tfragColor.xyz *= 1.3 * (1.0 - factor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBXzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 133, 133, 391], [433, 433, 464, 464, 859], [861, 861, 898, 898, 969], [971, 971, 1008, 1008, 1078], [1080, 1080, 1136, 1136, 2474]], "test": "valid"}
{"id": "MljSRD", "name": "Ray Marching Experiment n33bis", "author": "aiekick", "description": "Another arrangement", "tags": ["ray", "experiment", "marching", "33", "bis"], "likes": 89, "viewed": 6150, "published": "Public API", "date": "1442189575", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/*\nSpace Body \nmy goal was to introduce some sub-surface scattering with hot color but the result is not as expected\nnormaly less thikness is more cold than big thickness. here this is the inverse ^^ its not wanted\n*/\n\n#define BLOB\n\n#define shape(p) length(p)-2.8\n\nfloat dstepf = 0.0;\n    \nconst vec2 RMPrec = vec2(.3, 0.01); \nconst vec3 DPrec = vec3(1e-5, 12., 1e-6); \n\n// by shane : https://www.shadertoy.com/view/4lSXzh\nfloat Voronesque( in vec3 p )\n{\n    vec3 i  = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec3 rnd = vec3(7, 157, 113); // I use this combination to pay homage to Shadertoy.com. :)\n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    d = fract(sin(d)*262144.)*v*2.; \n    v.x = max(d.x, d.y), v.y = max(d.z, d.w), v.z = max(min(d.x, d.y), min(d.z, d.w)), v.w = min(v.x, v.y); \n#ifdef BLOB\n    return  max(v.x, v.y) - max(v.z, v.w); // Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n#else\n    return max(v.x, v.y); // Maximum, or regular value for the regular Voronoi aesthetic.  Range [0, 1].\n#endif\n}\n\n///////////////////////////////////\nvec2 map(vec3 p)\n{\n    dstepf += 0.003;\n\n    vec2 res = vec2(0.);\n\t\n\tfloat voro = Voronesque(p);\n\t\n \tfloat sp = shape(p);\n    float spo = sp - voro;\n    float spi = sp + voro * .5;\n    \n\tfloat e = sin(iTime*.5)*.4 +.35;\n\t\n   \tfloat dist = max(-spi, spo + e);\n               \n\tres = vec2(dist, 1.);\n\t\n\tfloat kernel = sp + 1.;\n\tif (kernel < res.x ) \n\t\tres = vec2(kernel, 2.);\n\t\n\treturn res;\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n    map(pos+e.xyy).x - map(pos-e.xyy).x,\n    map(pos+e.yxy).x - map(pos-e.yxy).x,\n    map(pos+e.yyx).x - map(pos-e.yyx).x );\n    return normalize(n);\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv)\n{\n\tvec3 rov = normalize(cv-ro);\n    vec3 u =  normalize(cross(cu, rov));\n    vec3 v =  normalize(cross(rov, u));\n    vec3 rd = normalize(rov + u*uv.x + v*uv.y);\n    return rd;\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 561e5 * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 352e5 * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\nconst vec3 RockColor = vec3(.2,.4,.58);\nconst vec3 DeepSpaceColor = vec3(0,.02,.15);\n        \nvoid mainImage( out vec4 f, in vec2 g )\n{\n    vec2 si = iResolution.xy;\n\tfloat t = iTime;\n    \n    float ca = t*.2; // angle z\n    float ce = 2.; // elevation\n    float cd = 4.; // distance to origin axis\n   \t\n    vec3 cu=vec3(0,1,0);//Change camere up vector here\n    vec3 cv=vec3(0,0,0); //Change camere view here\n    vec2 uv = (g+g-si)/min(si.x, si.y);\n    vec3 ro = vec3(sin(ca)*cd, ce+1., cos(ca)*cd); //\n    vec3 rd = cam(uv, ro, cu, cv);\n\n    vec3 d = vec3(0.);\n    vec3 p = ro+rd*d.x;\n\tvec2 s = vec2(DPrec.y, 0.);\n    for(int i=0;i<200;i++)\n    {      \n\t\tif(s.x<DPrec.x||s.x>DPrec.y) break;\n        s = map(p);\n\t\ts.x *= (s.x>DPrec.x?RMPrec.x:RMPrec.y);\n\t\td.x += s.x;\n        p = ro+rd*d.x;\n   \t}\n\n\tif (d.x<DPrec.y)\n    {\n\t\tvec3 n = nor(p, .1);\n\t\tif ( s.y < 1.5) // icy color\n        {\n\t\t\trd = reflect(rd, n);\n\t\t\tp += rd*d.x;\t\t\n\t\t\td.x += map(p).x * .001;\n\t\t\tf.rgb = exp(-d.x / RockColor / 15.);\n\t\t}\n\t\telse if( s.y < 2.5) // kernel\n\t\t{\n\t\t\tfloat b = dot(n,normalize(ro-p))*0.9;\n            f = (b*vec4(blackbody(2000.),0.9)+pow(b,0.2))*(1.0-d.x*.01);\n\t\t}\t\n   \t}\n    \n    f = mix( f, vec4(DeepSpaceColor, 1.), 1.0 - exp( -d.x*dstepf) ); \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljSRD.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[509, 561, 592, 592, 1502], [1504, 1540, 1558, 1558, 1930], [1932, 1932, 1966, 1966, 2168], [2170, 2170, 2216, 2216, 2392], [2394, 2615, 2643, 2643, 2960], [3056, 3056, 3097, 3097, 4199]], "test": "valid"}
{"id": "MljSzW", "name": "myfluid", "author": "vortex", "description": "Some circles", "tags": ["circles"], "likes": 15, "viewed": 575, "published": "Public", "date": "1442191299", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stefan Draganov - vortex/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define TILE 1\n\nconst float s= 8.0;\n\nvec3 n(vec2 x,float t)\n{\n    vec3 v=floor(vec3(x,t));\n#if TILE==1\n    vec3 u=vec3(mod(v.xy,s),v.z);//this should make it tile across the edges :)\n#else\n    vec3 u=v;\n#endif\n    vec3 c=fract(\n        u.xyz*(vec3(0.16462,0.84787,0.98273)+\n         u.xyz*vec3(0.24808,0.75905,0.13898)+\n         u.yzx*vec3(0.31517,0.62703,0.26063)+\n         u.zxy*vec3(0.47127,0.58568,0.37244))+\n        \n        u.yzx*(vec3(0.35425,0.65187,0.12423)+\n         u.yzx*vec3(0.95238,0.93187,0.95213)+\n         u.zxy*vec3(0.31526,0.62512,0.71837))+\n        \n        u.zxy*(vec3(0.95213,0.13841,0.16479)+\n         u.zxy*vec3(0.47626,0.69257,0.19738))\n    );//*vec3(0.5,0.5,1.0)+vec3(0.25,0.25,0.0);//*vec3(1.0,1.0,0.5)+vec3(0.0,0.0,0.25);\n    \n    return v+c;\n}\n\nvec3 col(vec2 x,float t)\n{\n    return vec3(0.5)+0.5*cos(fract(vec3(x,t))*371.0241);\n}\n\nvec2 idx(vec2 x)\n{\n    return \n        //clamp(floor(3.0*normalize(vec2(x.y,-x.x))),vec2(-1.0),vec2(1.0));\n                       floor(fract(x*29.0)*3.0)-vec2(1.0);\n}\n\nfloat circle(vec2 x,vec2 c,float r)\n{\n    return max(0.0,1.0-dot(x-c,x-c)/(r*r));//<r*r?1.0:0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 x = s*(fragCoord.xy-1.0*iMouse.xy)/iResolution.xy;\n    \n    float t=iTime*0.1;\n    \n    vec4 c=vec4(vec3(0.0),0.1);\n    \n    for (int N=0;   N<3; N++)\n    for (int k=-1; k<=0; k++)\n    for (int i=-1; i<=1; i++)\n    for (int j=-1; j<=1; j++)\n    {\n        vec2  X=x+vec2(j,i);\n        float t=t+float(N)*38.0;\n        float T=t+float(k);\n        vec3 a=n(X,T);\n        \n        vec2 o=idx(a.xy);\n        vec3 b=\n            //a+vec3(o,1.0);\n          n(X+o,T+1.0);//*/\n        vec2 m=mix(a.xy,b.xy,(t-a.z)/(b.z-a.z));\n        \n        float r=0.4*sin(3.1415927*clamp((t-a.z)/(b.z-a.z),0.0,1.0));\n        \n        if (length(a.xy-b.xy)/(b.z-a.z)>2.0) r=0.0;\n        \n        c+=vec4(col(a.xy,a.z),\n                1.0)*circle(x,m,r);\n    }\n    //c+=dot(x,x)<5.0*5.0?vec3(1.0,0.0,0.0):vec3(0.0);\n\tfragColor = vec4(c.rgb/max(1e-5,c.w)+vec3(0.0,0.0,0.5),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljSzW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[169, 169, 193, 193, 904], [906, 906, 932, 932, 991], [993, 993, 1011, 1011, 1160], [1162, 1162, 1199, 1199, 1260], [1262, 1262, 1319, 1319, 2182]], "test": "valid"}
{"id": "MljXW1", "name": "electric gel", "author": "sechristo", "description": "a sketch I've been poking at for the last few days", "tags": ["2d", "colorful", "sketch"], "likes": 4, "viewed": 255, "published": "Public", "date": "1443585489", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//shoutout to iq for the getNormal function\n\n#define EPS 0.01\n#define TAU 2.0*3.14159265359\n\n\nfloat map (float r, float angle) {\n\treturn (tan(angle*3.0+iTime*0.1)*0.5)+0.5 + sin(r*30.0)*0.1;\n}\n\nvec3 getNormal(float r, float angle) {\n    vec3 n = vec3( map(r-EPS,angle) - map(r+EPS,angle),map(r,angle-EPS) - map(r,angle+EPS),5.0*EPS);\n    return normalize( n );\n}\n\nfloat map1(float x, float y) {\n    vec2 uv = vec2(x,y);\n    float r = sqrt(pow(uv.x,2.0)+pow(uv.y,2.0));\n    float angle = atan(uv.y,uv.x);\n    \n    vec3 light = normalize(vec3(sin(1.0),cos(1.0),sin(iTime*0.1)));\n    return pow(dot(light,getNormal(r,angle)),2.0);\n}\n\nfloat map1(float x, float y, float offset) {\n    vec2 uv = vec2(x,y);\n    float r = sqrt(pow(uv.x,2.0)+pow(uv.y,2.0));\n    float angle = atan(uv.y,uv.x);\n    \n    vec3 light = normalize(vec3(sin(1.0),cos(1.0),sin(iTime*0.1)));\n    return pow(dot(light,getNormal(r,angle+offset)),2.0);\n}\n\nvec3 getXYNormal(float x, float y) {\n        vec3 n = vec3( map1(x-EPS,y) - map1(x+EPS,y),map1(x,y-EPS) - map1(x,y+EPS),150.0*EPS);\n    return normalize( n );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    float c = 0.5;\n    \n    uv.x -= 0.5;\n    uv.y -= 0.5;\n    mouse.x -= 0.5;\n    mouse.y -= 0.5;\n    \n    uv.y *= iResolution.y/iResolution.x;\n    mouse.y *= iResolution.y/iResolution.x;\n    \n    float r = sqrt(pow(uv.x,2.0)+pow(uv.y,2.0));\n    float angle = atan(uv.y,uv.x);\n    \n    r += sin(angle*6.0+iTime)*0.0333;\n    \n    float ch = 5000.0;\n    float cr = sin(map1(uv.x,uv.y,0.0)*sin(map1(uv.x,uv.y,0.0)));\n    float cg = sin(map1(uv.x,uv.y,1.0*ch)*sin(map1(uv.x,uv.y,1.0*ch)));\n    float cb = sin(map1(uv.x,uv.y,2.0*ch)*sin(map1(uv.x,uv.y,2.0*ch)));\n    cr = map1(cr,cg);\n    cg = map1(cg,cb);\n    cb = map1(cr,cb);\n    vec3 tint = vec3(0.2,0.1,0.3);\n    vec3 col = normalize(vec3(cr,cg,cb)+tint)*10.0;\n    vec3 mLoc = vec3(sin(-iTime)*0.333,cos(-iTime)*0.333,-2.0);\n    vec3 light = vec3(uv.x,uv.y,map1(uv.x,uv.y))-mLoc;\n    vec3 lDir = normalize(light);\n    vec3 normal = getXYNormal(map1(uv.x,uv.y),map1(uv.y,uv.x));\n    col += pow(clamp(dot(lDir,normal),0.0,1.0),200.0)*6.0;\n    col += pow(clamp(dot(lDir,normal),0.0,1.0),50.0)*1.0;\n    col += tint;\n    col*=0.1;\n    \n\tfragColor = vec4(col,1.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljXW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 128, 128, 192], [194, 194, 232, 232, 362], [364, 364, 394, 394, 629], [631, 631, 675, 675, 917], [919, 919, 955, 955, 1079], [1083, 1083, 1140, 1140, 2353]], "test": "valid"}
{"id": "MljXzw", "name": "liquid cubes", "author": "titoasty", "description": "WIP : attempting smooth blending cubes\nlines appear with high blend factor\nrotation is clearly broken, I still can't rotate correctly each cubes separately without distortion..\nlines 77 & 78 : comment/uncomment for only 9 cubes\nline 89 : blend factor", "tags": ["cube", "blend", "liquid"], "likes": 29, "viewed": 952, "published": "Public", "date": "1442574664", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opRepXZ( vec3 p, vec3 c )\n{\n    return vec3(mod(p.x,c.x)-0.5*c.x, p.y, mod(p.z,c.z)-0.5*c.z);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// exponential smooth min (k = 32);\nfloat smin2( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec3 rX(in vec3 p, float a) {\n\tfloat c,s;vec3 q=p;\n\tc = cos(a); s = sin(a);\n\treturn vec3(p.x, c * q.y - s * q.z, s * q.y + c * q.z);\n}\n\nvec3 rY(in vec3 p, float a) {\n\tfloat c,s;vec3 q=p;\n\tc = cos(a); s = sin(a);\n\treturn vec3(c * q.x + s * q.z, p.y, -s * q.x + c * q.z);\n}\n\n//----------------------------------------------------------------------\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 map(in vec3 pos) {\n    vec2 res = vec2(sdPlane(pos), 1.0);\n    \n    // bledng cubes by groups of 9\n    float gap = 1.2;\n\t\n    vec3 cubeSize = vec3(0.5);\n    for(float i=-1.; i<=1.; i+=1.) {\n        for(float j=-1.; j<=1.; j+=1.) {\n            vec3 p = opRepXZ(pos, vec3(gap, 0., gap))+vec3(i*gap, 0., j*gap);\n//            vec3 p = pos+vec3(i*gap, 0., j*gap);\n            float rotX = iTime+pos.x*0.3;\n\t        float rotY = iTime+pos.z*0.3;\n            vec3 p2 = rY(rX(p, rotX), rotY);\n            \n            float dst = sdBox(p2, cubeSize);\n            \n            // smooth min\n            float a = res.x;\n            float b = dst;\n            // blending power : 0. to 1.\n            float k = .5;\n            float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n            \n\t\t    res = vec2(mix( b, a, h ) - k*h*(1.0-h), 3.0);\n        }\n    }\n\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.8, 0.9, 1.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n//        dif *= softshadow( pos, lig, 0.02, 2.5 );\n//        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\t\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tbrdf += 0.02;\n\t\tcol = col*brdf;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n//\tvec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ro = vec3( 0., 8.0, 0.5 + 3.5);\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n    \n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljXzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 40], [42, 42, 73, 73, 160], [236, 236, 269, 269, 295], [297, 297, 327, 327, 360], [362, 362, 392, 392, 421], [423, 423, 455, 455, 523], [525, 561, 602, 602, 695], [697, 733, 775, 775, 846], [848, 848, 872, 872, 1004], [1006, 1006, 1035, 1035, 1140], [1142, 1142, 1171, 1171, 1277], [1353, 1353, 1373, 1373, 1445], [1447, 1447, 1470, 1470, 2316], [2318, 2318, 2358, 2358, 2948], [2951, 2951, 3025, 3025, 3286], [3288, 3288, 3320, 3320, 3541], [3543, 3543, 3585, 3585, 3884], [3889, 3889, 3928, 3928, 5518], [5520, 5520, 5572, 5572, 5749], [5751, 5751, 5808, 5808, 6445]], "test": "valid"}
{"id": "MlSSDR", "name": "Fishbowl", "author": "dr2", "description": "Lots of optical effects - refraction, total internal reflection and Fresnel\nreflection (proof of correctness left as exercise for reader); use mouse to explore.", "tags": ["reflection", "refraction", "water", "fish", "optics"], "likes": 9, "viewed": 1066, "published": "Public API", "date": "1442743422", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Fishbowl\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec3 i = floor (p);\n  vec3 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  float q = dot (i, cHashA3);\n  vec4 t1 = Hashv4f (q);\n  vec4 t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n     mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float s = 0.;\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return s;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  float s = length (max (d, 0.));\n  d = min (d, 0.);\n  return max (d.x, max (d.y, d.z)) + s;\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat Length4 (vec2 p)\n{\n  p *= p;\n  p *= p;\n  return pow (p.x + p.y, 1. / 4.);\n}\n\nint idObj;\nmat3 fishMat, vuMat;\nvec3 fishPos, qHit, sunDir, waterDisp, cloudDisp;\nfloat tCur, bowlRad, bowlHt, fishLen, angTail, angFin, posMth;\nbool inBowl, chkBowl;\nconst float dstFar = 100.;\nconst int idBrWall = 1, idTbl = 2, idBowl = 3,\n   idFBdy = 11, idTail = 12, idFin = 13, idEye = 14;\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  vec2 p;\n  float cloudFac, w, f;\n  if (rd.y > 0.) {\n    ro.xz += cloudDisp.xz;\n    p = 0.05 * (rd.xz * (70. - ro.y) / rd.y + ro.xz);\n    w = 0.8;  f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);  w *= 0.5;  p *= 2.;\n    }\n    cloudFac = clamp (3. * f * rd.y - 0.3, 0., 1.);\n    f = max (dot (rd, sunDir), 0.);\n    col =  mix (vec3 (0.2, 0.3, 0.55) + 0.2 * pow (1. - rd.y, 5.) +\n       (0.35 * pow (f, 6.) + 0.65 * min (pow (f, 256.), 0.3)),\n       vec3 (0.85), cloudFac);\n  } else {\n    p = -0.05 * (rd.xz * ro.y / rd.y + ro.xz);\n    w = 1.;  f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);  w *= 0.5;  p *= 2.;\n    }\n    col = mix ((1. + min (f, 1.)) * vec3 (0.15, 0.2, 0.15),\n       vec3 (0.2, 0.3, 0.55) + 0.2, pow (1. + rd.y, 5.));\n  }\n  return col;\n}\n\nvec3 BrickSurfCol (vec2 p) {\n  vec2 q = p * vec2 (1./40., 1./20.);\n  vec2 i = floor (q);\n  if (2. * floor (i.y / 2.) != i.y) {\n    q.x += 0.5;\n    i = floor (q);\n  }\n  q = smoothstep (0.02, 0.04, abs (fract (q + 0.5) - 0.5));\n  return (1. + Noisefv2 (5. * p)) * (0.2 + 0.8 * q.x * q.y) *\n     vec3 (0.7, 0.4, 0.3);\n}\n\nvec3 BrickCol (vec3 p, vec3 n)\n{\n  n = abs (n);\n  p *= 150.;\n  return BrickSurfCol (p.zy) * n.x + BrickSurfCol (p.xz) * n.y +\n     BrickSurfCol (p.xy) * n.z;\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  p *= 4.;\n  float f = dot (vec3 (Fbm2 (p.yz * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.yx * vec2 (1., 0.1))), abs (n));\n  return mix (vec3 (0.8, 0.4, 0.2), vec3 (0.45, 0.25, 0.1), f);\n}\n\nfloat WaterHt (vec3 p)\n{\n  float ht, w;\n  const float wb = 1.414;\n  p *= 0.05;\n  ht = 0.;\n  w = wb;\n  for (int j = 0; j < 4; j ++) {\n    w *= 0.5;\n    p = wb * vec3 (p.y + p.z, p.z - p.y, 2. * p.x);\n    p += waterDisp;\n    ht += w * abs (Noisefv3 (p) - 0.5);\n  }\n  return 0.1 * ht;\n}\n\nvec3 WaterNf (vec3 p)\n{\n  float h = WaterHt (p);\n  vec2 e = vec2 (0.001, 0.);\n  return normalize (vec3 (h - WaterHt (p + e.xyy), e.x, h - WaterHt (p + e.yyx)));\n}\n\nfloat TableDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, d1, d2, br, bl, sFac;\n  sFac = 2.5;  br = 1.6 * sFac;  bl = 1.1 * sFac;\n  p -= vec3 (0., - 2.2 * sFac - 0.01 * br, 0.);\n  q = p;\n  q.y -= - 0.55 * br;\n  d = PrCylDf (q.xzy, 0.5 * br, 0.03 * br);\n  p.xz += 0.05 * br * vec2 (1., 1.5);\n  q = p;  q.y -= - 1.4 * bl;\n  d1 = PrCylDf (q.xzy, 0.07 * br, 0.6 * bl);\n  q = p;  q.y -= - 2. * bl;\n  d2 = max (PrCylDf (q.xzy, 0.5 * br, 0.15 * br * (1. -\n     0.7 * smoothstep (0.2 * br, 0.35 * br, length (p.xz)))), -0.05 * br - q.y);\n  d = min (d, min (d1, d2));\n  if (d < dMin) { dMin = d;  idObj = idTbl;  qHit = q; }\n  return dMin;\n}\n\nfloat BowlWlDf (vec3 p, float dMin)\n{\n  float d, db;\n  db = Length4 (vec2 (length (p.xz), p.y));\n  d = inBowl ? max (max (db - 1.03 * bowlRad, p.y - bowlHt),\n     - max (db - bowlRad, p.y - bowlHt)) : max (db - bowlRad, p.y - bowlHt);\n  if (d < dMin) { dMin = d;  qHit = p;  idObj = idBowl; }\n  return dMin;\n}\n\nfloat FishDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, wr, tr, u;\n  q = p;  q.x = abs (q.x);  q -= fishLen * vec3 (0.12, 0.1, 0.9);\n  d = PrSphDf (q, 0.05 * fishLen);\n  if (d < dMin) { dMin = d;  idObj = idEye;  qHit = q; }\n  q = p;\n  wr = q.z / fishLen;\n  if (wr > 0.5) {\n    u = (wr - 0.5) / 0.5;  tr = 0.17 - 0.11 * u * u;\n  } else {\n    u = clamp ((wr - 0.5) / 1.5, -1., 1.);  u *= u;  tr = 0.17 - u * (0.33 - 0.13 * u); \n  }\n  q.y *= 0.5;\n  d = PrCapsDf (q, 1.1 * tr * fishLen, fishLen);\n  q.y *= 2.;  q.z -= posMth * fishLen;\n  d = max (d, - PrCylDf (q.yzx, 0.03 * fishLen, 0.1 * fishLen));\n  if (d < dMin + 0.01 * fishLen) {\n    dMin = SmoothMin (dMin, d, 0.01 * fishLen);  idObj = idFBdy;  qHit = q;\n  }\n  q = p;  q.z -= -0.9 * fishLen;  q.y *= 0.1;\n  wr = q.z / (0.4 * fishLen);\n  if (wr > 0.5) {\n    u = (wr - 0.5) / 0.5;  tr = 0.17 - 0.05 * u * u;\n  } else {\n    u = clamp ((wr - 0.5) / 1.5, -1., 1.);  u *= u;  tr = 0.17 - u * 0.34; \n  }\n  float dTail = PrCylDf (q, 0.13 * tr * fishLen, 0.6 * fishLen);\n  d = max (dTail, 0.15 * fishLen - q.z);\n  if (d < dMin + 0.01 * fishLen) {\n    dMin = SmoothMin (dMin, d, 0.01 * fishLen);  idObj = idTail;  qHit = q;\n  }\n  q.z -= 0.15 * fishLen;\n  q.xz = Rot2D (q.xz, angTail);\n  d = max (PrCylDf (q, 0.13 * tr * fishLen, 0.6 * fishLen), q.z);\n  if (d < dMin) { dMin = d;  idObj = idTail;  qHit = q; }\n  q = p;  q.y *= 0.5;  q.z -= -0.75 * fishLen;\n  q = q.xzy;\n  d = max (PrCylDf (q, 0.022 * fishLen, 0.11 * fishLen), dTail);\n  if (d < dMin) { dMin = d;  idObj = idTail;  qHit = 0.2 * q.xzy; }\n  q = p;  q.x = abs (q.x) - 0.18 * fishLen;  q.y *= 0.1;  q.z -= 0.4 * fishLen;\n  q.xz = Rot2D (q.xz, angFin);\n  wr = q.z / (0.2 * fishLen);\n  if (wr > 0.5) {\n    u = (wr - 0.5) / 0.5;  tr = 0.17 - 0.01 * u * u;\n  } else {\n    u = clamp ((wr - 0.5) / 1.5, -1., 1.);  u *= u;  tr = 0.17 - u * 0.34; \n  }\n  q.z -= 0.3 * fishLen;\n  d = PrCylDf (q, 0.12 * tr * fishLen, 0.5 * fishLen);\n  if (d < dMin + 0.005 * fishLen) {\n    dMin = SmoothMin (dMin, d, 0.005 * fishLen);  idObj = idFin;  qHit = q;\n  }\n  return 0.75 * dMin;\n}\n\nfloat BowlExtDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;  q.y -= -2.72 * bowlRad + 11.;  q.z -= 1.2 * bowlRad;\n  d = PrBoxDf (q, vec3 (2.38, 1.33, 0.05) * bowlRad);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idBrWall; }\n  q = p;  q -= vec3 (0., -2. * bowlRad + 1., 1.2 * bowlRad);\n  d = max (PrCylDf (q.xzy, 2.38 * bowlRad, 0.05 * bowlRad), q.z);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idBrWall; }\n  q = p;  q.y -= - bowlHt + 5.1;\n  dMin = TableDf (q, dMin);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin = dstFar;\n  if (chkBowl) dMin = BowlWlDf (p, dMin);\n  else if (inBowl) dMin = FishDf (fishMat * (p - fishPos), dMin);\n  else dMin = BowlExtDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 60; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h / d);\n    d += 0.2;\n    if (h < 0.001) break;\n  }\n  return clamp (0.5 + 0.5 * sh, 0., 1.);\n}\n\nvec3 FishCol (vec3 n)\n{\n  vec3 col;\n  const vec3 col1 = vec3 (1., 1., 0.1), col2 = vec3 (0.1, 0.1, 1.);\n  qHit *= 20. / fishLen;\n  if (idObj == idEye) {\n    col = vec3 (0.1, 1., 0.1);\n    if (qHit.z > 0.5) col = vec3 (0.5, 0., 0.);\n  } else if (idObj == idFBdy) {\n    col = mix (col2, col1, 0.5 * (1. + sin (4. * qHit.y)));\n    vec3 nn = fishMat * n;\n    col = mix (col1,  mix (col, col2, smoothstep (0.7, 1., nn.y)),\n       smoothstep (-1., -0.7, nn.y)) *\n       (1. - 0.2 * SmoothBump (-0.2, 0.2, 0.1, qHit.x));\n  } else if (idObj == idTail) {\n    col = mix (col2, col1, 0.5 * (1. + sin (40. * qHit.y)));\n  } else if (idObj == idFin) {\n    col = mix (col2, col1, 0.5 * (1. + sin (40. * qHit.y)));\n  }\n  return col;\n}\n\nvec4 ObjCol (vec3 n)\n{\n  vec4 col;\n  if (idObj == idBrWall) col = vec4 (BrickCol (0.1 * qHit, n), 0.);\n  else if (idObj == idTbl) col = vec4 (WoodCol (qHit, n), 0.2);\n  else col = vec4 (FishCol (n), 1.);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 roW, rdW, rdd, vn, vnW, colD, colR, qHitBowl, reflCol;\n  float dstHit, dstBowl, dstBowlW, yLim, dif, sh, frnlFac;\n  int idObjT, hitBowl;\n  bool bWallHit;\n  const float eta = 1.33;\n  yLim = 0.999 * bowlHt;\n  idObj = -1;\n  inBowl = false;\n  chkBowl = true;\n  dstBowl = ObjRay (ro, rd);\n  if (idObj < 0) dstBowl = dstFar;\n  hitBowl = -1;\n  if (dstBowl < dstFar) {\n    hitBowl = idObj;\n    qHitBowl = qHit;\n  }\n  idObj = -1;\n  chkBowl = false;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  idObjT = idObj;\n  roW = ro;  rdW = rd;\n  dstBowlW = dstBowl;\n  reflCol = vec3 (1.);\n  frnlFac = 0.;\n  bWallHit = (dstBowl < dstHit && hitBowl > 0);\n  if (bWallHit) {\n    ro += dstBowl * rd;\n    chkBowl = true;\n    vn = (qHitBowl.y < yLim) ? ObjNf (ro) : WaterNf (qHitBowl);\n    vnW = vn;\n    frnlFac = (qHitBowl.y > - yLim) ? abs (dot (rd, vn)) : 0.;\n    rd = refract (rd, vn, 1. / eta);\n    ro += 0.01 * rd;\n    idObj = -1;\n    inBowl = true;\n    dstBowl = ObjRay (ro, rd);\n    if (idObj < 0) dstBowl = dstFar;\n    hitBowl = -1;\n    if (dstBowl < dstFar) {\n      hitBowl = idObj;\n      qHitBowl = qHit;\n    }\n    idObj = -1;\n    chkBowl = false;\n    dstHit = ObjRay (ro, rd);\n    if (idObj < 0) dstHit = dstFar;\n    idObjT = idObj;\n    if (dstBowl < dstHit && hitBowl > 0) {\n      ro += dstBowl * rd;\n      chkBowl = true;\n      vn = (qHitBowl.y < yLim) ? ObjNf (ro) : - WaterNf (qHitBowl);\n      rdd = refract (rd, vn, eta);\n      if (length (rdd) > 0.) {\n        rd = rdd;\n        reflCol *= vec3 (0.9, 1., 0.9);\n        inBowl = false;\n      } else rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      idObj = -1;\n      chkBowl = false;\n      dstHit = ObjRay (ro, rd);\n      if (idObj < 0) dstHit = dstFar;\n      idObjT = idObj;\n    }\n  }\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    chkBowl = false;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = ObjCol (vn);\n    dif = max (dot (vn, sunDir), 0.);\n    sh = (idObjT < idFBdy) ? ObjSShadow (ro, sunDir) : 1.;\n    colD = reflCol * (objCol.rgb * (0.2 + 0.8 * dif * sh +\n       objCol.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.)));\n    idObj = idObjT;\n  } else colD = reflCol * BgCol (ro, rd);\n  colR = vec3 (0.);\n  reflCol = vec3 (1.);\n  if (bWallHit) {\n    ro = roW + dstBowlW * rdW;\n    rd = (frnlFac > 0.) ? reflect (rdW, vnW) : rdW;\n    ro += 0.01 * rd;\n    inBowl = false;\n    idObj = -1;\n    chkBowl = false;\n    dstHit = ObjRay (ro, rd);\n    if (idObj < 0) dstHit = dstFar;\n    idObjT = idObj;\n    if (dstHit < dstFar) {\n      ro += rd * dstHit;\n      vn = ObjNf (ro);\n      idObj = idObjT;\n      objCol = ObjCol (vn);\n      dif = max (dot (vn, sunDir), 0.);\n      sh = ObjSShadow (ro, sunDir);\n      colR = reflCol * (objCol.rgb * (0.2 + 0.8 * dif * sh +\n         objCol.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.)));\n    } else colR = reflCol * BgCol (ro, rd);\n  }\n  frnlFac = (eta != 1. && frnlFac > 0.) ? 1. - pow (frnlFac, 4.) : 0.;\n  return clamp (mix (colD, colR, smoothstep (0.98, 1., frnlFac)), 0., 1.);\n}\n\nvec3 FishTrack (float t)\n{\n  return 0.6 * bowlRad * vec3 (cos (0.5 * t),\n     0., - sin (0.5 * t)) + bowlHt * vec3 (0., -0.2 + 0.8 * sin (0.077 * t), 0.);\n}\n\nvoid FishPM (float t)\n{\n  float dt = 1.;\n  fishPos = FishTrack (t);\n  vec3 vel = (FishTrack (t + dt) - FishTrack (t - dt)) / (2. * dt);\n  float a = atan (vel.z, vel.x) - 0.5 * pi;\n  float ca = cos (a);\n  float sa = sin (a);\n  fishMat = mat3 (ca, 0., - sa, 0., 1., 0., sa, 0., ca);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 canvas = iResolution.xy;\n  vec2 uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  mPtr.y *= -1.;  // local only\n  vec3 ro, rd;\n  float el, az, zmFac;\n  bowlRad = 5.;\n  bowlHt = 2.5;\n  FishPM (tCur);\n  fishLen = 0.25 * bowlRad;\n  angTail = 0.1 * pi * sin (5. * tCur);\n  angFin = pi * (0.8 + 0.1 * sin (2.5 * tCur));\n  posMth = 1.04 + 0.01 * sin (5. * tCur);\n  waterDisp = 0.1 * tCur * vec3 (1., 0., 1.);\n  cloudDisp = 4. * tCur * vec3 (1., 0., 1.);\n  el = 0.;\n  az = 0.;\n  zmFac = 5.;\n  if (mPtr.z > 0.) {\n    el = clamp (el + 3. * mPtr.y, -1.1, 1.4);\n    az = clamp (az - 3. * mPtr.x, -1.5, 1.5);\n  } else {\n    zmFac = clamp (zmFac - 2. + 0.4 * tCur, 3., 7.);\n    el += pi * (-0.3 + 0.75 * SmoothBump (0.25, 0.75, 0.25,\n       mod (0.071 * tCur + 0.4 * pi, 2. * pi) / (2. * pi)));\n    az += 0.6 * pi * (1. - 0.5 * abs (el)) * sin (0.21 * tCur);\n  }\n  vec2 vf = vec2 (el, az);\n  vec2 cf = cos (vf);\n  vec2 sf = sin (vf);\n  vuMat = mat3 (1., 0., 0., 0., cf.x, - sf.x, 0., sf.x, cf.x) *\n     mat3 (cf.y, 0., sf.y, 0., 1., 0., - sf.y, 0., cf.y);\n  rd = normalize (vec3 (uv, zmFac)) * vuMat;\n  ro = vec3 (0., 0., -40.) * vuMat;\n  sunDir = normalize (vec3 (-0.2, 0.2, -1.)) * vuMat;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSSDR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[263, 263, 287, 287, 334], [336, 336, 361, 361, 540], [542, 542, 567, 567, 873], [875, 875, 896, 896, 1033], [1035, 1035, 1080, 1080, 1178], [1180, 1180, 1237, 1237, 1320], [1322, 1322, 1352, 1352, 1426], [1428, 1428, 1460, 1460, 1579], [1581, 1581, 1614, 1614, 1641], [1643, 1643, 1685, 1685, 1736], [1738, 1738, 1781, 1781, 1854], [1856, 1856, 1880, 1880, 1937], [2234, 2234, 2265, 2265, 3082], [3084, 3084, 3112, 3112, 3400], [3402, 3402, 3434, 3434, 3561], [3563, 3563, 3594, 3594, 3800], [3802, 3802, 3826, 3826, 4085], [4087, 4087, 4110, 4110, 4249], [4251, 4251, 4287, 4287, 4883], [4885, 4885, 4922, 4922, 5194], [5196, 5196, 5231, 5231, 7264], [7266, 7266, 7304, 7304, 7767], [7769, 7769, 7791, 7791, 7974], [7976, 7976, 8009, 8009, 8185], [8187, 8187, 8208, 8208, 8416], [8418, 8418, 8455, 8455, 8677], [8679, 8679, 8702, 8702, 9397], [9399, 9399, 9421, 9421, 9618], [9620, 9620, 9655, 9655, 12691], [12693, 12693, 12719, 12719, 12849], [12851, 12851, 12874, 12874, 13133], [13135, 13135, 13191, 13191, 14518]], "test": "valid"}
{"id": "MlSSWW", "name": "sechristo electric gel (mod)", "author": "rcread", "description": "a variant of sechristo's very cool https://www.shadertoy.com/view/MljXW1", "tags": ["2d"], "likes": 1, "viewed": 229, "published": "Public", "date": "1443594396", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by randy read - rcread/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//\ta variant of sechristo's very cool https://www.shadertoy.com/view/MljXW1\n\n//shoutout to iq for the getNormal function\n\n#define EPS 0.01\n#define TAU 2.0*3.14159265359\n\n\nfloat map (float r, float angle) {\n\treturn (tan(angle*3.0+iTime*0.1)*0.5)+0.5 + sin(r*30.0)*0.1;\n}\n\nvec3 getNormal(float r, float angle) {\n    vec3 n = vec3( map(r-EPS,angle) - map(r+EPS,angle),map(r,angle-EPS) - map(r,angle+EPS),5.0*EPS);\n    return normalize( n );\n}\n\nfloat map1(float x, float y) {\n    vec2 uv = vec2(x,y);\n    float r = sqrt(pow(uv.x,2.0)+pow(uv.y,2.0));\n    float angle = atan(uv.y,uv.x);\n    \n    vec3 light = normalize(vec3(sin(1.0),cos(1.0),sin(iTime*0.1)));\n    return pow(dot(light,getNormal(r,angle)),2.0);\n}\n\nfloat map1(float x, float y, float offset) {\n    vec2 uv = vec2(x,y);\n    float r = sqrt(pow(uv.x,2.0)+pow(uv.y,2.0));\n    float angle = atan(uv.y,uv.x);\n    \n    vec3 light = normalize(vec3(sin(1.0),cos(1.0),sin(iTime*0.1)));\n    return pow(dot(light,getNormal(r,angle+offset)),2.0);\n}\n\nvec3 getXYNormal(float x, float y) {\n        vec3 n = vec3( map1(x-EPS,y) - map1(x+EPS,y),map1(x,y-EPS) - map1(x,y+EPS),150.0*EPS);\n    return normalize( n );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    float c = 0.5;\n    \n    uv.x -= 0.5;\n    uv.y -= 0.5;\n    mouse.x -= 0.5;\n    mouse.y -= 0.5;\n    \n    uv.y *= iResolution.y/iResolution.x;\n    mouse.y *= iResolution.y/iResolution.x;\n    \n    float ch = 50.0;\n    float cr = sin(map1(uv.x,uv.y,0.0)*sin(map1(uv.x,uv.y,0.0)));\n    float cg = sin(map1(uv.x,uv.y,1.0*ch)*sin(map1(uv.x,uv.y,1.0*ch)));\n    float cb = sin(map1(uv.x,uv.y,2.0*ch)*sin(map1(uv.x,uv.y,2.0*ch)));\n    cr = map1(cr,cg);\n    cg = map1(cg,cb);\n    cb = map1(cr,cb);\n    vec3 tint = vec3(0.2,0.1,0.3);\n    vec3 col = vec3( cr,cg,cb) + tint;\n    float w = 6. * sin( iTime * 7. / 11. );\n    col = ( w * normalize( col ) + -w * col / max(cr,max(cg,cb) ) ) / 2.;\n    //col = col / max(cr,max(cg,cb)) - normalize( col );\n    \n    vec3 mLoc = vec3(sin(-iTime)*0.333,cos(-iTime)*0.333,-2.0);\n    vec3 light = vec3(uv.x,uv.y,map1(uv.x,uv.y))-mLoc;\n    vec3 lDir = normalize(light);\n    vec3 normal = getXYNormal(map1(uv.x,uv.y),map1(uv.y,uv.x));\n    col += pow(clamp(dot(lDir,normal),0.,1.),200.0)*6.0;\n    col += pow(clamp(dot(lDir,normal),0.,1.),50.0)*1.0;\n    col += tint;\n    col*=0.1;\n    \n\tfragColor = vec4(col,1.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSSWW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[298, 298, 332, 332, 396], [398, 398, 436, 436, 566], [568, 568, 598, 598, 833], [835, 835, 879, 879, 1121], [1123, 1123, 1159, 1159, 1283], [1287, 1287, 1344, 1344, 2586]], "test": "valid"}
{"id": "MlSXR1", "name": "Molecule?", "author": "Alexey", "description": "Some molecule", "tags": ["2d", "molecule"], "likes": 6, "viewed": 189, "published": "Public", "date": "1441482086", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\nfloat ball(vec2 p, float fx, float fy, float ax, float ay) {\n    vec2 r = vec2(p.x + cos(iTime * fx) * ax, p.y + sin(iTime * fy) * ay);\t\n    return 0.09 / length(r);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\t\n    p.x\t*= iResolution.x / iResolution.y;\n\n    float col = 0.0;\n    col += ball(p, 1.0, 2.0, 0.1, 0.2);\n    col += ball(p, 1.5, 2.5, 0.2, 0.3);\n    col += ball(p, 2.0, 3.0, 0.3, 0.4);\n    col += ball(p, 2.5, 3.5, 0.4, 0.5);\n    col += ball(p, 3.0, 4.0, 0.5, 0.6);\t\n    col += ball(p, 1.5, 0.5, 0.6, 0.7);\n\t\n    fragColor = vec4(col, col * 0.3, col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSXR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 84, 84, 191], [193, 193, 248, 248, 679]], "test": "valid"}
{"id": "Mt2SR1", "name": "Radial Fire Isolated", "author": "leftium", "description": "Radial Fire Isolated", "tags": ["radialfireisolated"], "likes": 3, "viewed": 238, "published": "Public API", "date": "1441733283", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision mediump float;\nvec3 calc_pal(float x);\n\nfloat snoise(in vec2 v);\nfloat snoise(in vec3 v);\nfloat pnoise(in vec3 v, vec3 rep);\nfloat fbm(in vec2 v, int octaves);\nfloat fbm_abs(in vec2 v, int octaves);\nfloat fbm(in vec3 v, int octaves);\nfloat fbm_abs(in vec3 v, int octaves);\n\n#define M_PI\t3.14159\n#define M_2PI\t6.28318\n#define REP     8.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime * 0.2;\n\tvec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = (uv * 2.0 - 1.0) * aspect;\n\t\n\tvec2 polar = vec2(atan(p.x, p.y), length(p) * 1.0);\n\n\t\n\tfloat dist = polar.y;\n\tvec2 dom = vec2(polar.x, polar.y - t) * 2.0;\n    \n    dom.x = dom.x * REP / M_2PI / 2.0;\n    \n\tfloat turb = dist + 0.67 + fbm_abs(vec3(dom, t), 6) * 0.25;\n\tvec3 color = calc_pal(turb * 0.95);\n\t\n\tfragColor.xyz = color;\n\tfragColor.w = 1.0;\n}\n\nvec3 calc_pal(float x)\n{\n\tvec3 col = mix(vec3(1.0, 0.9, 0.2), vec3(0.8, 0.2, 0.1), smoothstep(1.2, 1.6, x));\n\tcol = mix(col, vec3(0.0, 0.0, 0.0), smoothstep(1.5, 1.8, x));\n\treturn col;\n}\n\nfloat fbm(in vec2 v, int octaves)\n{\n\tfloat res = 0.0;\n\tfloat scale = 1.0;\n\tfor(int i=0; i<8; i++) {\n\t\tif(i >= octaves) break;\n\t\tres += snoise(v) * scale;\n\t\tv *= vec2(2.0, 2.0);\n\t\tscale *= 0.5;\n\t}\n\treturn res;\n}\n\nfloat fbm(in vec3 v, int octaves)\n{\n\tfloat res = 0.0;\n\tfloat scale = 1.0;\n\tfor(int i=0; i<8; i++) {\n\t\tif(i >= octaves) break;\n\t\tres += snoise(v) * scale;\n\t\tv *= vec3(2.0, 2.0, 2.0);\n\t\tscale *= 0.5;\n\t}\n\treturn res;\n}\n\n\nfloat fbm_abs(in vec2 v, int octaves)\n{\n\tfloat res = 0.0;\n\tfloat scale = 1.0;\n\tfor(int i=0; i<8; i++) {\n\t\tif(i >= octaves) break;\n\t\tres += abs(snoise(v)) * scale;\n\t\tv *= vec2(2.0, 2.0);\n\t\tscale *= 0.5;\n\t}\n\treturn res;\n}\n\nfloat fbm_abs(in vec3 v, int octaves)\n{\n\tfloat res = 0.0;\n\tfloat scale = 1.0;\n\tfor(int i=0; i<8; i++) {\n\t\tif(i >= octaves) break;\n\t\t// res += abs(snoise(v)) * scale;\n        res += abs(pnoise(v, REP*vec3(1.,1.,1.))) * scale;\n\t\tv *= vec3(2.0, 2.0, 2.0);\n\t\tscale *= 0.5;\n\t}\n\treturn res;\n}\n\n// -------------------------------------------------------------------\n// Description : Array and textureless GLSL 2D simplex noise function.\n// Author : Ian McEwan, Ashima Arts.\n// Maintainer : ijm\n// Lastmod : 20110822 (ijm)\n// License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n// Distributed under the MIT License. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(in vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(in vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(in vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(in vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626, // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i = floor(v + dot(v, C.yy) );\n  vec2 x0 = v - i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x = a0.x * x0.x + h.x * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n// noise functions.\n// Author : Ian McEwan, Ashima Arts.\n// Maintainer : ijm\n// Lastmod : 20110822 (ijm)\n// License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n// Distributed under the MIT License. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\n\nvec4 mod289(in vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(in vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(in vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(in vec3 v)\n{\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i = floor(v + dot(v, C.yyy) );\n  vec3 x0 = v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  // x0 = x0 - 0.0 + 0.0 * C.xxx;\n  // x1 = x0 - i1 + 1.0 * C.xxx;\n  // x2 = x0 - i2 + 2.0 * C.xxx;\n  // x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );    \n}\n\n\n\n\n///////////////////////////////////////////////////////////////////////////////////////////\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2SR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[348, 348, 405, 405, 887], [889, 889, 913, 913, 1075], [1077, 1077, 1112, 1112, 1287], [1289, 1289, 1324, 1324, 1504], [1507, 1507, 1546, 1546, 1726], [1728, 1728, 1767, 1767, 2014], [2411, 2411, 2435, 2435, 2484], [2486, 2486, 2510, 2510, 2559], [2561, 2561, 2586, 2586, 2623], [2625, 2625, 2652, 2652, 4146], [4485, 4485, 4509, 4509, 4558], [4560, 4560, 4585, 4585, 4625], [4627, 4627, 4658, 4658, 4710], [4712, 4712, 4737, 4737, 6854], [6952, 6952, 6971, 6971, 7011], [7013, 7055, 7087, 7087, 9417]], "test": "error"}
{"id": "Mt2SzR", "name": "Perlin Water Noise", "author": "jackdavenport", "description": "I was trying to write the Pixelshader's noise functions from memory and I created this REALLY cool water effect accidentally! I would love to see someone use this in a shader and make something totally awesome :D", "tags": ["noise", "perlin", "water", "mask"], "likes": 43, "viewed": 4417, "published": "Public API", "date": "1441164166", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random(float x) {\n \n    return fract(sin(x) * 10000.);\n          \n}\n\nfloat noise(vec2 p) {\n\n    return random(p.x + p.y * 10000.);\n            \n}\n\nvec2 sw(vec2 p) { return vec2(floor(p.x), floor(p.y)); }\nvec2 se(vec2 p) { return vec2(ceil(p.x), floor(p.y)); }\nvec2 nw(vec2 p) { return vec2(floor(p.x), ceil(p.y)); }\nvec2 ne(vec2 p) { return vec2(ceil(p.x), ceil(p.y)); }\n\nfloat smoothNoise(vec2 p) {\n\n    vec2 interp = smoothstep(0., 1., fract(p));\n    float s = mix(noise(sw(p)), noise(se(p)), interp.x);\n    float n = mix(noise(nw(p)), noise(ne(p)), interp.x);\n    return mix(s, n, interp.y);\n        \n}\n\nfloat fractalNoise(vec2 p) {\n\n    float x = 0.;\n    x += smoothNoise(p      );\n    x += smoothNoise(p * 2. ) / 2.;\n    x += smoothNoise(p * 4. ) / 4.;\n    x += smoothNoise(p * 8. ) / 8.;\n    x += smoothNoise(p * 16.) / 16.;\n    x /= 1. + 1./2. + 1./4. + 1./8. + 1./16.;\n    return x;\n            \n}\n\nfloat movingNoise(vec2 p) {\n \n    float x = fractalNoise(p + iTime);\n    float y = fractalNoise(p - iTime);\n    return fractalNoise(p + vec2(x, y));   \n    \n}\n\n// call this for water noise function\nfloat nestedNoise(vec2 p) {\n    \n    float x = movingNoise(p);\n    float y = movingNoise(p + 100.);\n    return movingNoise(p + vec2(x, y));\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float n = nestedNoise(uv * 6.);\n    \n\tfragColor = vec4(mix(vec3(.4, .6, 1.), vec3(.1, .2, 1.), n), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2SzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 73], [75, 75, 96, 96, 151], [153, 153, 170, 170, 209], [210, 210, 227, 227, 265], [266, 266, 283, 283, 321], [322, 322, 339, 339, 376], [378, 378, 405, 405, 611], [613, 613, 641, 641, 911], [913, 913, 940, 940, 1071], [1073, 1111, 1138, 1138, 1257], [1258, 1258, 1315, 1315, 1467]], "test": "valid"}
{"id": "Mt2SzW", "name": "hypnotize", "author": "d1kkop", "description": "hypnotize", "tags": ["procedural", "2d"], "likes": 4, "viewed": 1259, "published": "Public API", "date": "1442163872", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float c_ringSize = 0.05;\n\nbool isEven(int val)\n{\n    return val - (val/2)*2 == 0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 c = vec2(0.5);\n    float dist = distance(uv, c);\n    dist += iTime / 10.0;\n    if (isEven(int(dist / c_ringSize)))\n        fragColor = vec4(1, 1,1,1);\n    else\n        fragColor = vec4(0, 0, 0,1);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2SzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 54, 54, 89], [91, 91, 148, 148, 398]], "test": "valid"}
{"id": "MtBSDW", "name": "Enigma raytracing Update", "author": "chrisjhebert1973", "description": "This shader was created by Optimus. \nI have just hacked in some shadows and ray traced reflections during my tea break.\n", "tags": ["raytracing", "mandelbrot", "amiga", "enigma"], "likes": 1, "viewed": 213, "published": "Public", "date": "1443615132", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float time;\nvec2 resolution;\n\nconst int numBalls = 24;\nconst float radius = 0.25;\n\nconst vec3 lightPos = vec3(4.0, 4.0, 0.0);\nvec3 sphereCenter;\n\nbool hasHitSphere = false;\nvec3 floorHitPoint;\n\nvec4 getColor(vec3 normal)\n{\n\tvec3 lightBack = normalize(lightPos - sphereCenter);\n\tfloat diffuse = dot(normal, lightBack);\n\tif (diffuse < 0.0) diffuse = 0.0;\n\tfloat specular = pow(diffuse, 64.0);\n\tvec4 color = vec4(vec3(0.25 + 1.0*diffuse + 4.0*specular) * vec3(0.25,1.0,0.25), 1.0);\n\treturn color;\n}\n\n\nfloat z_fractal = 1.0;\n\nconst float xpos = -0.99424;\nconst float ypos = 0.2975;\n\nconst float iter = 16.0;\nconst float iter2 = iter / 4.0;\n\nvec4 getFractalColor(vec2 tc)\n{\n\tfloat x0 = mod(0.1*tc.x + 0.9, 2.0);\n\tfloat y0 = mod(0.025*(1.0 - tc.y) + 0.7, 1.0);\n\n\tfloat z0_r = 0.0;\n\tfloat z0_i = 0.0;\n\tfloat z1_r = 0.0;\n\tfloat z1_i = 0.0;\n\tfloat p_r = (x0 + xpos * z_fractal) / z_fractal;\n\tfloat p_i = (y0 + ypos * z_fractal) / z_fractal;\n\tfloat d = 0.0;\n\n\tfloat nn = 0.0;\n\tfor (float n=0.0; n<iter; n++)\n\t{\n\t\tz1_r = z0_r * z0_r - z0_i * z0_i + p_r;\n\t\tz1_i = 2.0 * z0_r * z0_i + p_i;\n\t\td = sqrt(z1_i * z1_i + z1_r * z1_r);\n\t\tz0_r = z1_r;\n\t\tz0_i = z1_i;\n\t\tif (d > iter2) break;\n\t\tnn++;\n\t}\n\n\tfloat c = (1.0*nn) / iter;\n\tif (c==1.0) c = 0.0;\n\tc *= 4.0;\n\tvec4 color = vec4(1.0*c, 1.0*c, 4.0*c, 0.0);\n\treturn color;\n}\n\nvec4 getSphereColor(vec3 pos, vec3 dir, float index)\n{\n\tvec4 color = vec4(0.0);\n\t\n\tfloat yy = -0.4 + sin(index * 0.5);\n\t\n\tvec3 startCenter = vec3(-2.0, yy, 4.0);\n\tvec3 endCenter = vec3(4.0, yy, 32.0);\n\tsphereCenter = startCenter + (endCenter - startCenter) * (index / float(numBalls));\n\t\n\thasHitSphere = false;\n\n\tpos -= sphereCenter;\n\n\tfloat b = 2.0 * dot(pos,dir);\n\tfloat c = dot(pos,pos) - radius;\n\n\tfloat discr = b*b - 4.0*c;\n\tif (discr >= 0.0)\n\t{\n\t\tvec2 t = vec2(-b+discr, -b-discr) / 2.0;\n\t\tvec3 p = pos + min(t.x,t.y) * dir;\n\t\tfloorHitPoint = p;\n\t\thasHitSphere = (p.y > -0.7-yy);\n\t\tif (hasHitSphere)\n\t\t{\n\t\t\tcolor = getColor(normalize(p));\n\t\t\thasHitSphere = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloorHitPoint = p;\n\t\t}\n\t}\n\treturn color;\n}\n\nvec4 getBackgroundColor(vec2 pix)\n{\n\tif (pix.y < 0.0)\n\t{\n\t\tpix.y = -pix.y;\n\t\tfloat v = 1.0 / pix.y;\n\t\tfloat u = pix.x * v;\n\t\tvec4 fractalColor = getFractalColor(vec2(u,v));\n\t\tvec3 aview = vec3(0.0, 1.0, 0.0);\n\t\tvec3 apos = vec3(u, 0.0, v);\n        vec3 apos2 = vec3(u+2.0,0.0,v);\n\t\tvec3 adir = normalize(aview - apos);\n        vec3 nml = vec3(0.0,1.0,0.0);\n        \n        vec3 rdir = 2.0 * dot(nml,adir)*nml-adir;\n\n\t\tvec4 reflectionColor = vec4(0.0);\n\t\tfor (int i=0; i<numBalls; i++)\n\t\t{\n\t\t\treflectionColor += getSphereColor(apos, rdir, float(i) - mod(4.0*time, 1.0));\n\t\t\tif (hasHitSphere) break;\n\t\t}\n        \n        vec3 lray = normalize(lightPos-apos);\n        float  shadowDelta = 1.0;\n        for(int i=0;i<numBalls;++i){\n            getSphereColor(apos2,lray,float(i) - mod(4.0*time,1.0));\n            if(hasHitSphere) shadowDelta = 0.45;\n        }\n\t\t\n\t\treturn (fractalColor + 2.0 * reflectionColor) * pix.y * shadowDelta;\n\t}\n\telse\n\t{\n\t\treturn vec4(0.3 - pix.y, 0.0, 1.0 * pix.y, 0.0) * 2.0;\n\t}\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iTime;\n\tresolution = iResolution.xy;\n    \n\tvec2 pix = (fragCoord.xy / resolution - vec2(0.5)) * vec2(1.0, resolution.y / resolution.x);\n\tvec3 pos = vec3(pix,-1.0);\n\tvec3 dir = normalize(vec3(pix.x, pix.y, 1.0));\n\n\tvec4 col = vec4(0.0);\n\tfor (int i=0; i<numBalls; i++)\n\t{\n\t\tcol += getSphereColor(pos, dir, float(i) - mod(4.0*time, 2.0));\n\t\tif (hasHitSphere) break;\n\t}\n\tif (!hasHitSphere)\n\t{\n\t\tcol = getBackgroundColor(pix);\n\t}\n\n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBSDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 194, 222, 222, 495], [637, 637, 668, 668, 1305], [1307, 1307, 1361, 1361, 2036], [2038, 2038, 2073, 2073, 3042], [3045, 3045, 3102, 3102, 3557]], "test": "valid"}
{"id": "MtBSW1", "name": "Yet another raymarching", "author": "hexjayi", "description": "Yet another raymarching experiment based on Inigo Quilez's code.", "tags": ["3d", "noise", "raymarch", "iq", "lava"], "likes": 3, "viewed": 246, "published": "Public", "date": "1443201656", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n\tYet another raymarching experiment based on IQ and @paulofalcao's code.\n*/\n\nconst int ITER = 20;\nconst float PI = 3.14159265;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.9 );\n\n\nvec2 r2(vec2 v, float a) \n{\n\tmat2 m = mat2 (\n\t\tcos(a), -sin(a),\n\t\tsin(a), cos(a)\n\t\t);\n\treturn m*v;\n}\n\nfloat ss(float mi,float ma,float a)\n{ // sineSignal (min,max,alpha)\n\treturn (sin(a)+1.)*(ma-mi)*0.5+mi;\n}\n\n\n//   /\n//---  Noise\n//   \\\n\n\nfloat noise( in vec2 x )\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture( iChannel0, (uv+118.4)/256.0, -100.0 ).x;\n}\n\nfloat noise( in vec3 x )\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm( vec2 p )\n{\n\tp*=3.;\n\tfloat f = 0.0;\n    f += 0.25000*noise( p ); p = m2*p*0.02;\n    f += 0.12500*noise( p ); p = m2*p*0.13;\n    f += 0.06250*noise( p ); p = m2*p*0.01;\n    f += 0.03125*noise( p ); p = m2*p*0.04;\n    f += 0.01500*noise( p );\n    return f/0.38375;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\n//    /\n// ---  Field\n//    \\\n\nfloat distanceField(in vec3 p) \n{\n  \tfloat s = 8.; // spacing\n  \tfloat d = cos(p.x*0.05);\n  \tfloat rs = 0.25 * iTime+ d; // rotating speed\n  \tvec2 pos; // yz\n  \n  \tfloat a = rs+d;  \n  \tpos = s*vec2( sin(a) , cos(a));\n\n  \tfloat r = 2.5;\n  \tfloat res;\n\t\n  \t// a simple cylinder would go like this :  length(p.yz+pos)-r  \n  \t// here is 4 cylinders with displacements :\n\n  \tfloat ssf =  ss(0.,1.,p.y*2.) * sin(p.x+iTime);\n  \tfloat w = fbm(p)*2.;\n\n  \tres = \n\t\t( length(p.yz+pos+w*0.3*abs(p.x/10.)+sin(p.x/2.+iTime))-r ) - ssf;\n\n  \ta = rs+PI*1.0+d;\n  \tpos = s*vec2(sin(a),cos(a));\n  \tfloat res2 =\n\t  \t( length(p.yz+pos+w*0.3*abs(p.x/10.)+sin(p.x/2.+iTime))-r ) - ssf;\n\t\n\ta = rs+PI*0.50+d;\n  \tpos = s*vec2(sin(a),cos(a));\n  \tfloat res3 =\n\t\t( length(p.yz+pos+w*0.3*abs(p.x/10.)+sin(p.x/2.+iTime))-r ) - ssf;\n\t\n  \ta = rs+PI*1.50+d;\n  \tpos = s*vec2(sin(a),cos(a));\n  \tfloat res4 =\n\t\t( length(p.yz+pos+w*0.3*abs(p.x/10.)+sin(p.x/2.+iTime))-r ) - ssf;\n\n  \tres = min(res,res4);\n  \tres = min(res,res3);\n  \tres = min(res,res2);\n  \treturn res;\n}\n\nvec3 getColor(in vec3 p)\n{\n\tvec3 res = vec3(1.,0.2,0.) * 2.;\n  \tfloat m = mod(sin(p.x),2.);\n  \tfloat n = fbm(p);\n  \tfloat g = fbm(vec3(p.x*iTime*2000.,1.,1.))*2.;\n  \tres = res*n*m*(g*2.+1.);\n  \treturn res;\n}\n\n//    /\n// ---  Main\n//\t  \\\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  \tvec3 bgColor = vec3 (0.1,0.0,0.0);\n\n  \tvec2 vPos=-1.0+2.0*fragCoord.xy/iResolution.xy;\n  \tvec3 finalColor = vec3 (0.0);  \n  \n  \t//Camera animation\n  \tvec3 vuv=vec3(0,1,0);//Change camere up vector here\n  \tfloat s0 = ss(-15.,+15.,iTime*0.1);\n\t\n  \tvec3 prp=vec3(s0,0.,ss(3.,13.,iTime*0.13)); //Change camera path position here\n  \tvec3 vrp=vec3(sin(iTime*0.002)*2.,cos(iTime)*2.,0); //Change camere view here\n\n  \t//Camera setup\n  \tvec3 vpn=normalize(vrp-prp);\n  \tvec3 u=normalize(cross(vuv,vpn));\n  \tvec3 v=cross(vpn,u);\n  \tvec3 vcv=(prp+vpn);\n  \tvec3 scrCoord=vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  \tvec3 scp=normalize(scrCoord-prp);\n\n  \t//Raymarching\n  \tconst vec3 e=vec3(0.1,0,0);\n  \tconst float maxd=30.0; //Max depth\n\n  \tfloat s= 0.1;\n  \tvec3 c,p,n;\n\n  \tfloat f=1.0;\n  \tfor(int i=0;i<  ITER ; i++)\n    {\n    \tif (abs(s)<.01||f>maxd) break;\n    \tf+=s;\n    \tp=prp+scp*f;\n    \ts=distanceField(p);\n  \t}\n\n  \tif (f<maxd)\n    {\n    \tc=getColor(p);\t// cylinder color\n    \tn=normalize(\n      \tvec3(s-distanceField(p-e.xyy),\n        \ts-distanceField(p-e.yxy),\n        \ts-distanceField(p-e.yyx)));\n    \tfloat b=dot(n,normalize(prp-p));\n\n    \tvec3 finalColor = vec3( b*c+pow(b,8.0))*(1.0-f*.02) ;  //simple phong LightPosition=CameraPosition\n\n\t\tfinalColor*=0.44;\n    \tfragColor = vec4( finalColor, 1.);\n  \t} else \n    { // background color\n    \tbgColor = \n\t  \tvec3(0.7,0.2,0.1);\n\t  \tfloat n = fbm(p);\n      \tbgColor = vec3(n)*bgColor*f/60.;\n\t  \tfragColor=vec4(bgColor,1.);\n  \t}\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBSW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[286, 286, 313, 313, 386], [388, 388, 425, 455, 493], [525, 525, 551, 551, 695], [697, 697, 723, 723, 928], [930, 930, 951, 951, 1204], [1206, 1206, 1227, 1227, 1409], [1411, 1442, 1475, 1475, 2471], [2473, 2473, 2499, 2499, 2680], [2682, 2711, 2766, 2766, 4253]], "test": "error"}
{"id": "MtBSWR", "name": "Art : Squigly", "author": "Gijs", "description": "http://i.imgur.com/3zGRyZD.gif", "tags": ["waves", "circle", "minimalistic"], "likes": 44, "viewed": 1134, "published": "Public", "date": "1442704412", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//const numbers\nconst float Pi = 3.1415;\nconst float Tau = 2.*Pi;\n\n//Colors\nconst vec3  Color_BackGround = vec3( 34,  30,  38)/256.;\nconst vec3  Color_Ring1      = vec3( 10, 205, 203)/256.;\nconst vec3  Color_Ring2      = vec3( 46,  72,  82)/256.;\nconst vec3  Color_Ring3      = vec3( 54, 147, 147)/256.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //Scaling\n\tvec2 Scaled = (fragCoord*2.-iResolution.xy)/iResolution.y*.6;\n    float t = 2./iResolution.y;\n    \n    //Info\n    float Length = length(Scaled);\n    float Angle  = atan(Scaled.y,Scaled.x)+Pi;//[-Pi,Pi]->[0,2Pi]\n    float Wave = mod(iTime*2.,Tau);//[0,2Pi]\n    \n    //Background\n\tvec3 Color = Color_BackGround;  \n    \n    //Calculating\n    float AngleDifference = abs(Wave-Angle);\n    float DistanceToWave  = min(AngleDifference,Tau-AngleDifference);\n    float FinalMultiplier = pow(max(1.,DistanceToWave),-4.);\n    \n    float Ring1 = .50  + 0.03*cos(Angle*7.       )*FinalMultiplier;\n    float Ring2 = .485 + 0.03*cos(Angle*7.+Tau/3.)*FinalMultiplier;\n    float Ring3 = .47  + 0.03*cos(Angle*7.-Tau/3.)*FinalMultiplier;\n    \n    //Drawing\n    \n    Color = mix(Color,Color_Ring1,smoothstep(0.01+t,0.01,abs(Ring1-Length)));\n    Color = mix(Color,Color_Ring2,smoothstep(0.01+t,0.01,abs(Ring2-Length)));\n    Color = mix(Color,Color_Ring3,smoothstep(0.01+t,0.01,abs(Ring3-Length)));\n\n    //Final\n\tfragColor = vec4(Color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBSWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[305, 305, 361, 375, 1399]], "test": "valid"}
{"id": "MtBXDW", "name": "Bloop coulor", "author": "Reanar", "description": "dd", "tags": ["dd"], "likes": 0, "viewed": 99, "published": "Public", "date": "1443618253", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 mod289(vec3 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n\treturn mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r){\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\t\n\nfloat noise(vec3 v){\n    v=0.1*v;\n    const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n    // First corner\n    vec3 i = floor(v + dot(v, C.yyy) );\n    vec3 x0 = v - i + dot(i, C.xxx) ;\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n    // x0 = x0 - 0.0 + 0.0 * C.xxx;\n    // x1 = x0 - i1 + 1.0 * C.xxx;\n    // x2 = x0 - i2 + 2.0 * C.xxx;\n    // x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3 ns = n_ * D.wyz - D.xzx;\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x=uv.x*1.6;\n    uv.y=uv.y*0.9;\n    \n    vec3 camera = vec3(iTime,0.0, -2.0);\n    vec3 direction = normalize(vec3(uv,1.0));\n    vec3 lumiere = vec3(0.0,0.0,-2.0);\n    \n    vec3 dx = vec3(0.1,0.0,0.0);\n    vec3 dy = vec3(0.0,0.1,0.0);\n    vec3 dz = vec3(0.0,0.0,0.1);\n    \n    vec3 vecteurDirecteur=camera;\n    for(int i=0;i<500;i++){\n        vecteurDirecteur=vecteurDirecteur+direction*0.10;\n        if(noise(vecteurDirecteur)>0.7){\n            vec3 N = vec3(\n                noise(vecteurDirecteur-dx)-noise(vecteurDirecteur+dx),\n                noise(vecteurDirecteur-dy)-noise(vecteurDirecteur+dy),\n                noise(vecteurDirecteur-dz)-noise(vecteurDirecteur+dz));\n            N = normalize(N);\n            vec3 L = normalize(lumiere-vecteurDirecteur);\n            vec3 V = normalize(camera-vecteurDirecteur);\n            vec3 R = 2.0*clamp(dot(N,L),0.0,1.0)*N-L;\n            \n            float lumDiffuse = clamp(dot(N,L),0.0,1.0);\n            float lumSpeculaire = clamp(pow(dot(R,V),64.0),0.0,1.0);\n            float lumTotale=lumDiffuse+lumSpeculaire;\n            \n       \t\tfragColor = vec4(N.x+lumTotale,N.y+lumTotale,N.z+lumTotale,1.0);                         \n            break;\n        }\n    \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBXDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 69], [71, 71, 92, 92, 140], [142, 142, 164, 164, 200], [202, 202, 229, 229, 280], [283, 283, 303, 303, 2479], [2482, 2482, 2539, 2539, 3806]], "test": "valid"}
{"id": "MtBXW1", "name": "Jazz Design", "author": "mhnewman", "description": "Dream of the 90s", "tags": ["design", "solo", "jazz", "cups"], "likes": 22, "viewed": 374, "published": "Public", "date": "1443239914", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\tConstants\nconst float brushSharpness = 30.0;\n\n//\tBig Stroke\nconst vec3 bigColor = vec3(0.0, 0.7, 0.7);\nconst float bigSpeed = 0.3;\nconst float bigConnection = 0.9;\nconst int bigCount = 6;\nconst float bigPitch = 0.5;\nconst vec2 bigTop = vec2(-0.4, 0.85);\nconst vec2 bigBottom = vec2(0.4, 0.15);\nconst vec2 bigBrush = vec2(-0.17, -0.01);\n\n// Small Stroke\nconst vec3 smallColor = vec3(0.8, 0.0, 0.8);\nconst float smallSpeed = 0.35;\nconst float smallConnection = 0.8;\nconst int smallCount = 8;\nconst float smallPitch = 0.3;\nconst vec2 smallTop = vec2(-0.25, 0.65);\nconst vec2 smallBottom = vec2(0.25, 0.35);\nconst vec2 smallBrush = vec2(-0.02, -0.05);\n\n\n//\tHash function adapted from David Hoskins:\n//\thttps://www.shadertoy.com/view/4djSRW\n\n\nconst mat2 m = mat2(1.616, 1.212, -1.212, 1.616);\nconst float bs1 = brushSharpness + 1.0;\nconst vec3 bigC = vec3(1.0) - bigColor;\nconst vec3 smallC = vec3(1.0) - smallColor;\n\nfloat hash11(float p) {\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy +  vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nvec2 hash21(float p) {\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));\n}\n\nfloat hash12(vec2 p) {\n\tp = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4337);\n}\n\nfloat noise12(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash12(i + vec2(0.0, 0.0)), \n                   hash12(i + vec2(1.0, 0.0)), u.x),\n               mix(hash12(i + vec2(0.0, 1.0)), \n                   hash12(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm12(vec2 p) {\n    float f = noise12(p); p = m * p;\n    f += 0.5 * noise12(p); p = m * p;\n    f += 0.25 * noise12(p); p = m * p;\n    f += 0.125 * noise12(p);\n    return f / 1.875;\n}\n\nfloat addStroke(vec2 pos, vec2 a, vec2 b, vec2 brush, float edge, float falloff) {\n    vec2 dir = b - a;\n    vec2 p = pos - a;\n    float d = (dir.y * p.x - dir.x * p.y) / (dir.y * brush.x - dir.x * brush.y);\n    d = clamp(d, 0.0, 1.0);\n    p = pos - d * brush;\n    float e = (distance(p, a) + distance(p, b) - length(dir)) / edge;\n    return (1.0 - falloff * d) * max(1.0 - e, 0.0);\n}\n\nfloat brush(vec2 pos, float stroke) {\n    float p = brushSharpness * fbm12(70.0 * pos);\n    float s = 0.75 * stroke;\n    return 1.0 / (pow(1.0 / (1.0 - s), p) * pow(1.0 / s, p - bs1) / (s - 1.0) - 1.0) + 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color = vec3(1.0);\n\n    vec2 pos = fragCoord.xy / iResolution.y + vec2(bigSpeed * iTime, 0.0);\n    float idOffset = floor(bigSpeed * iTime / bigPitch);\n    float stroke = 0.0;\n    vec2 last = vec2(-0.5, 0.5);\n    for (int i = 0; i < bigCount; ++i) {\n        float id = float(i) + idOffset;\n\n        vec2 offset = vec2(id * bigPitch, 0.0);\n        vec2 top = offset + bigTop + 0.1 - 0.2 * hash21(id);\n        vec2 bottom = offset + bigBottom + 0.1 - 0.2 * hash21(id + 0.1);\n\n        if (hash11(id + 0.2) < bigConnection)\n            stroke = max(stroke, addStroke(pos, last, top, bigBrush, 0.02, 0.6));\n        stroke = max(stroke, addStroke(pos, top, bottom, bigBrush, 0.02, 0.6));\n\n        last = bottom;\n    }\n    color *= vec3(1.0) - brush(pos, stroke) * bigC;\n    \n    pos = fragCoord.xy / iResolution.y + vec2(smallSpeed * iTime, 0.0);\n    idOffset = floor(smallSpeed * iTime / smallPitch);\n    stroke = 0.0;\n    last = vec2(-0.5, 0.5);\n    for (int i = 0; i < smallCount; ++i) {\n        float id = float(i) + idOffset;\n\n        vec2 offset = vec2(id * smallPitch, 0.0);\n        vec2 top = offset + smallTop + 0.05 - 0.1 * hash21(id + 0.3);\n        vec2 bottom = offset + smallBottom + 0.05 - 0.1 * hash21(id + 0.4);\n\n        if (hash11(id + 0.5) < smallConnection)\n            stroke = max(stroke, addStroke(pos, last, top, smallBrush, 0.01, 0.6));\n        stroke = max(stroke, addStroke(pos, top, bottom, smallBrush, 0.01, 0.6));\n\n        last = bottom;\n    }\n    color *= vec3(1.0) - brush(pos, stroke) * smallC;\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBXW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[916, 916, 939, 939, 1078], [1080, 1080, 1102, 1102, 1269], [1271, 1271, 1293, 1293, 1420], [1422, 1422, 1445, 1445, 1736], [1738, 1738, 1759, 1759, 1926], [1928, 1928, 2010, 2010, 2312], [2314, 2314, 2351, 2351, 2524], [2526, 2526, 2581, 2581, 4149]], "test": "valid"}
{"id": "MtjXDh", "name": "3D kissing-Schottky Orbit-sphere", "author": "soma_arc", "description": "We use a new distance estimation(DE) to render the orbit-spheres of a kissing-Schottky group.\nThis \"kissing-Schottky DE\" algorithm is devised by Kazushi Ahara, Meiji university.", "tags": ["fractal", "kleiniangroups"], "likes": 10, "viewed": 828, "published": "Public", "date": "1443424164", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nCreated by soma_arc, Kazushi Ahara - 2015\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\nconst float PI = 3.14159265;\nconst float angle = 60.0;\nconst float fov = angle * 0.5 * PI / 180.0;\nconst vec3  cPos = vec3(0.0, 0.0, 500.0);\nconst vec3 lightDir = vec3(-0.577, 0.577, 0.577);\n\nconst vec3 spherePos1 = vec3(300, 300, 0);\nconst vec3 spherePos2 = vec3(300, -300, 0);\nconst vec3 spherePos3 = vec3(-300, 300, 0);\nconst vec3 spherePos4 = vec3(-300, -300, 0);\nconst vec3 spherePos5 = vec3(0, 0, 424.26);\nconst vec3 spherePos6 = vec3(0, 0, -424.26);\nconst float sphereR = 300.;\n\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n  vec3 a = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float r = 1.0 - c;\n  mat3 m = mat3(\n      a.x * a.x * r + c,\n      a.y * a.x * r + a.z * s,\n      a.z * a.x * r - a.y * s,\n      a.x * a.y * r - a.z * s,\n      a.y * a.y * r + c,\n      a.z * a.y * r + a.x * s,\n      a.x * a.z * r + a.y * s,\n      a.y * a.z * r - a.x * s,\n      a.z * a.z * r + c\n  );\n  return m * p;\n}\n\nvec3 sphereInverse(vec3 pos, vec3 circlePos, float circleR){\n  return ((pos - circlePos) * circleR * circleR)/(distance(pos, circlePos) * distance(pos, circlePos) ) + circlePos;\n}\n\nconst int ITERATIONS = 30;\nfloat loopNum = 0.;\nconst vec3 ROTATION = vec3(1.0, 0.5, 0.5);\nconst float r2 = sphereR * sphereR;\nfloat DE(vec3 pos){\n  pos = rotate(pos, radians(iTime * 10.0), ROTATION);\n  float dr = 1.;\n  bool cont = false;\n  for(int i = 0 ; i < ITERATIONS ; i++){\n    cont = false;\n    if(distance(pos, spherePos1) < sphereR){\n      vec3 diff = (pos - spherePos1);\n      dr *= r2 / dot(diff, diff);\n      pos = sphereInverse(pos, spherePos1, sphereR);\n      cont = true;\n      loopNum++;\n    }else if(distance(pos, spherePos2) < sphereR){\n        vec3 diff = (pos- spherePos2);\n         dr *= r2 / dot(diff, diff);\n      pos = sphereInverse(pos, spherePos2, sphereR);\n      cont = true;\n      loopNum++;\n    }else if(distance(pos, spherePos3) < sphereR){\n        vec3 diff = (pos- spherePos3);\n         dr *= r2 / dot(diff, diff);\n      pos = sphereInverse(pos, spherePos3, sphereR);\n      cont = true;\n      loopNum++;\n    }else if(distance(pos, spherePos4) < sphereR){\n        vec3 diff = (pos- spherePos4);\n         dr *= r2 / dot(diff, diff);\n      pos = sphereInverse(pos, spherePos4, sphereR);\n      cont = true;\n      loopNum++;\n    }else if(distance(pos, spherePos5) < sphereR){\n        vec3 diff = (pos- spherePos5);\n         dr *= r2 / dot(diff, diff);\n      pos = sphereInverse(pos, spherePos5, sphereR);\n      cont = true;\n      loopNum++;\n    }else if(distance(pos, spherePos6) < sphereR){\n        vec3 diff = (pos- spherePos6);\n         dr *= r2 / dot(diff, diff);\n      pos = sphereInverse(pos, spherePos6, sphereR);\n      cont = true;\n      loopNum++;\n    }\n    if(cont == false) break;\n  }\n//return (length(pos) - 300.) / abs(dr) * 0.08;\n    return (length(pos) - 125.) / abs(dr) * 0.08;\n}\n\nvec3 getNormal(vec3 p){\n  float d = 0.01;\n  return normalize(vec3(\n      DE(p + vec3(  d, 0.0, 0.0)) - DE(p + vec3( -d, 0.0, 0.0)),\n      DE(p + vec3(0.0,   d, 0.0)) - DE(p + vec3(0.0,  -d, 0.0)),\n      DE(p + vec3(0.0, 0.0,   d)) - DE(p + vec3(0.0, 0.0,  -d))\n  ));\n}\n\nconst int MARCHING_LOOP = 800;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 ray = normalize(vec3(sin(fov) * p.x, sin(fov) * p.y, -cos(fov)));\n\n  float dist;\n  float rLen = 0.0;\n  vec3  rPos = cPos;\n\n  float numMarch = 0.;\n  for(int i = 0; i < MARCHING_LOOP; i++){\n    dist = DE(rPos);\n    rLen += dist;\n    rPos = cPos + ray * rLen;\n    numMarch++;\n    if(dist < 0.01) break;\n  }\n\n  if(dist < 0.01){\n    vec3 normal = getNormal(rPos);\n    float diff = clamp(dot(lightDir, normal), 0.1, 1.0);        \n    fragColor = vec4(vec3(diff), 1.0);\n  }else{\n    fragColor = vec4(0.,0.,0.,1.);\n  }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjXDh.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[633, 633, 677, 677, 1074], [1076, 1076, 1136, 1136, 1255], [1383, 1383, 1402, 1402, 2978], [2980, 2980, 3003, 3003, 3248], [3281, 3281, 3338, 3338, 3944]], "test": "valid"}
{"id": "MtSXRm", "name": "Luminescent Tiles", "author": "Shane", "description": "Using my custom \"Box Divide\" formula to tile a square tunnel. Normal wrapping is used to give the tiles a cheap, fake, subsurface luminescent glow. As a minor point of interest, the tunnel is rendered using a cheap raytracing trick.", "tags": ["tunnel", "normal", "wrap", "luminescence"], "likes": 20, "viewed": 3860, "published": "Public API", "date": "1442421176", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tUsing my custom \"Box Divide\" formula to tile a square tunnel. Normal wrapping is \n\tused to give the tiles a cheap, fake, subsurface, luminescent glow. As a minor point of \n\tinterest, the tunnel is rendered using a cheap raytracing trick. There's no raymarching\n\tinvolved.\n\n\tFor anyone interested, the \"texCol\" function contains some cylindrical mapping examples.\n\n\tThere looks like there's more code here than there is. Most of it is optional 2D functions.\n\tIf you keep only the stuff you want, there's not much code at all.\n\n\tBox Divide ID - Shane\n\thttps://www.shadertoy.com/view/WlsSRs\n\n*/\n\n\n\n// 2D rotation. Always handy.\nmat2 rot(float th){ float cs = cos(th), si = sin(th); return mat2(cs, -si, si, cs); }\n\n\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(41, 289)))* 43758.5453);}\n\n/*\n// Box Divide\n// 2015 BeyondTheStatic\n// Original function: https://www.shadertoy.com/view/Xl2XRh\n// Function with changes applied: https://www.shadertoy.com/view/4l2XR1\nvec3 boxDivide(in vec2 p) {\n    \n    vec2 ip = floor(p);\n    \n    p -= ip;\n    \n    vec2 l = vec2(1);\n\n    bool flip=false;\n    \n    for(int i=0; i<8; i++) {\n \n        float r = hash21(l + ip)*0.5 + 0.25;\n        \n        if(l.x>l.y) { p=p.yx; l=l.yx; flip=true; }\n        \n        if(p.x<r) { l.x /= r; p.x /= r; }\n        else { l.x /= (1.-r); p.x = (p.x-r)/(1.-r); }\n        \n        if(flip){ p=p.yx; l=l.yx; flip=false; }\n        \n    }\n    \n    p = clamp(p, 0., 1.);\n    \n    // Making a basic rounded box.\n    //float f = max(1.- dot(pow(abs(p - .5), vec2(6)), vec2(64)), 0.);\n   \n    float f = pow(16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.5);\n    \n    //float f = pow(abs(sin(p.x*3.14159)*sin(p.y*3.14159)), 0.3);\n    \n    //return vec3(min(p*f*1.5, 1.), f);\n    return vec3(f);\n}\n*/\n\n// IQ's signed box formula.\nfloat sBox(vec2 p, vec2 b, float r){\n  \n  // Just outside lines.\n  //p = max(abs(p) - b + r, 0.);\n  //return length(p) - r;\n\n  // Inside and outside lines.\n  vec2 d = abs(p) - b + r;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;\n}\n\n\n#define VERT_OFFSET\n//#define SHOW_GRID\n\nvec3 boxDivide(in vec2 p) {\n    \n    \n    // Scaling factor. If changing this, you may need to change a few settings\n    // here and there to suit your needs.\n    const vec2 sc = vec2(1, 1)/3.; // See square tube scale.\n    \n   \n    p *= sc;\n   \n    p.xy += .5;\n    \n    // Basid grid tile ID. This will be further split into subtiles, which will\n    // each have their own ID based on postion.\n    vec2 ip = floor(p); \n   \n    // If using the vertical offset option, update the position and ID accordingly.\n    #ifdef VERT_OFFSET\n    if(mod(ip.x, 2.)>.5){\n        p.y -= 1./2.;\n        ip = floor(p);\n    }\n    #endif\n   \n    p -= ip + .5; // The original grid tile's base local coordinates.\n    \n    \n    #ifdef SHOW_GRID\n    float grid = abs(max(abs(p.x), abs(p.y)) - .5) - .005;\n    #endif\n    \n    // Block dimension. Every time there's a random split, it'll be factored down\n    // according to the random split factor.\n    vec2 l = vec2(1, 1);  \n    \n    // The starting point, which represents the bottom left corner (or is it the top left corner?)\n    // of the grid cell. With every split, it will be moved to the new split position.\n    vec2 s = vec2(-.5);    \n    \n    // Split number.\n    const int iNum = 6;\n\n    \n    //float r = hash21(ip);\n    //float r2 = hash21(ip + .35);\n    \n    float count = 0.;\n    \n    \n    // Create a box, divide it randomly, then do the same with the \n    // divided portions. Ad infinitum...\n    for(int i=0; i<iNum; i++) {\n \n        float r = hash21(ip + l + float(i)/float(iNum))*.3 + (1.-.3)/2.;\n        // Forcing a vertical to horizontal split (and vice versa) every\n        // iteration. It's not necessary, but I think it looks nicer.\n        float r2 = mod(float(i), 2.)>.5? 0. : 1.;\n        \n        // Alternate, more randomized sequence.\n        //float r2 = hash21(ip + 113.5 + l.yx + float(i)/float(iNum));\n        // Alternate heuristic, for aesthetics purposes, to ensure at least one split.\n        //if(i==iNum-1 && count<1.5) r2 = 1.;\n\t\t//if(i==iNum-1 && count>float(iNum) - 2.5) r2 = 0.;\n \n        \n        // Alternate way to randomize things. How this is achieved is up to the user.\n        //r = hash21(l + r + float(i)/float(iNum))*.3 + (1.-.3)/2.;\n        //r2 = hash21(l.yx + r + r2 + float(i)/float(iNum));\n        \n         \n        //r2 = mod(float(i), 2.)>.5? 0. : 1.;\n        //if(r2<.5) { p = p.yx; l = l.yx; s = s.yx; }\n        \n        // If the second random number is above a certain threshold, split \n        // vertically. Otherwise, split horizontally.\n        if(r2>.5){ \n            \n            // Counter for heuristics above. Uncomment if using them.\n            // count++;\n            \n            // This line splits the current cell down the middle, in accordance with\n            // the random factor, \"r,\" and the cell width \"l.x.\" \n            if(p.x>s.x + l.x*r) {\n\n                s.x += l.x*r; // Advance the position to the right of the split.\n                l.x *= (1. - r); // Reduce the width by a factor of \"1 - r.\"\n            }\n            else l.x *= r; // No need to advance position, but we need to reduce the width.\n        \n        }\n        else {\n            \n              // This line splits the current cell horizontally, in accordance with\n             // the random factor, \"r,\" and the cell height \"l.y.\" \n             if(p.y>s.y + l.y*r) {\n\n                s.y += l.y*r; // Advance the position above (or below?) the split.\n                l.y *= (1. - r); // Reduce the height by a factor of \"1 - r.\"\n\n             }\n             else l.y *= r; // No need to advance position, but we need to reduce the height.\n            \n        }\n\n    }\n    \n    \n    // Constructing the box itself: Actually, once you have the box coordinates, you can \n    // do whatever you want with them.\n    //\n    // Rounding factor: This depends on the look you're after. It could be a constant, \n    // or you could choose to have no rounding at all. After experimentingn, I decided \n    // to make the roundedness of the tile dependent on the minimum side length.\n    float rf = min(l.x, l.y); \n    float d = sBox(p - s - l/2., l/2., .08*sqrt(rf));\n    \n   \n    \n    // Smoothing factor.\n    float sf = 8./iResolution.y*sc.x;\n    \n    // Individual, position-based tile ID. Note that it'll read into the texture\n    // at the correct position.\n    vec2 id = ip + s + l/2.;\n    \n    // If using the vertical offset, the ID needs to follow suit.\n    #ifdef VERT_OFFSET\n    if(mod(ip.x, 2.)>.5){\n        id.y += .5;\n    }\n    #endif\n    \n    \n    \n    // Using the ID to color the individual tile.\n    \n    \n    // Textured version. Note that this is not an overlay -- Each tile has \n    // a uniform color.\n    vec3 tx = texture(iChannel0, id/sc/1.5).xyz; tx *= tx;\n    vec3 pCol = 1. - tx;\n    \n    // Original random colored version.\n    //vec3 pCol = vec3(1, hash21(id), hash21(id*57. + .5));\n    \n    // 2D noise, etc.\n    //float c =  n2D(id*2. + iTime);\n    //vec3 pCol = min(vec3(c*.1 + .9, c + .05, c*c*.7), 1.); \n\n    \n   \n    \n    vec3 col = vec3(.5);\n    float sh = clamp(.5 - d*5./length(l), 0., 1.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d)); // Rounded pavers.\n    col = mix(col, pCol*sh, 1. - smoothstep(0., sf, d + .02*sc.x)); \n    //col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(d + .03*sc.x) - .001*sc.x)); \n    // More decoration, if so desired.\n    //col = mix(col, mix(pCol*1.5, vec3(1), .35), 1. - smoothstep(0., sf, d + .02*sc.x)); \n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, d + .034*sc.x))*.9); \n    //col = mix(col, pCol*sh, 1. - smoothstep(0., sf, d + .042*sc.x)); \n \n    \n    // Center, space preserving dots.\n    \n    // Just the center dot.\n    //float d2 = length(p - s - l/2.) - .015/sc;\n    \n    /*\n    // Splitting space to produce four rivot-looking dots.\n    p = abs(p - s - l/2.) - l/2. + .0225;\n    float d2 = length(p) - .002/sc.x;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d2)); // Rounded pavers.\n    col = mix(col, vec3(2), 1. - smoothstep(0., sf, d2 + .007)); // Rounded pavers.\n    */\n    \n    #ifdef SHOW_GRID\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*2., grid - .005)); \n    col = mix(col, vec3(1, .8, .2), 1. - smoothstep(0., sf, grid)); \n    #endif\n \n \n    \n    return col;\n    \n}\n\nfloat tiles(in vec2 p){\n\n    float c = abs(sin(p.x*3.14159) * cos(p.y*3.14159));\n    \n    return pow(c*0.5, 0.125)*clamp( 1. + hash21(floor(p*16.))*0.05-0.025, 0., 1.);\n\n}\n\nfloat tiles2(vec2 p){\n\t\n\n    p = fract(p);\n    \n    //p*=p;\n    \n    float s = pow( 16.*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.25);\n    float s2 = (sin(p.x*3.14159)*sin(p.y*3.14159)*0.5+0.5);\n    \n    s = (s - s2*0.5)*2.;\n    \n    return clamp(s, 0., 1.);//*c;\n\n}\n\nvec3 texCol( in vec3 p, in vec3 n){\n    \n    // Cylindrical mapping. Note the divide by 8. It's an arbitrary value,\n    // and controls the stretch in the z-direction.\n    //vec2 uv = vec2(atan(p.y, p.x)/6.2832, p.z/8.);\n    \n    // Using box mapping (I made that up) for this particular example.\n    vec2 uv = (p.xz*n.y + p.yz*n.x);\n    \n    vec3 col = boxDivide(uv);\n    vec3 tex = 1.-texture(iChannel0, uv/2.).zyx;\n    return tex*tex*col;\n    \n    //float c = tiles2(uv*10.); \n    //return (texture(iChannel0, uv*2.).xyz*0.5+0.5)*c;    \n    \n    // Cylindrical texture mapping.\n    //return texture(iChannel0, uv*3.).xyz;\n    \n    //float c = tiles2(uv*24.); \n    //return texture(iChannel0, uv*4.).xyz*c; \n    \n    // etc.\n}\n\nfloat texShade(vec3 p, in vec3 n){\n    \n    vec3 col = texCol(p, n);\n    return dot(col, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 blackbodyPalette(float t){\n\n    t = t*2200.; // Temperature. Hardcoded to 4000, in this case.\n    \n\n    float cx = (0.860117757 + 1.54118254e-4*t + 1.28641212e-7*t*t)/(1.0 + 8.42420235e-4*t + 7.08145163e-7*t*t);\n    float cy = (0.317398726 + 4.22806245e-5*t + 4.20481691e-8*t*t)/(1.0 - 2.89741816e-5*t + 1.61456053e-7*t*t);\n    \n    // Converting the chromacity coordinates to XYZ tristimulus color space.\n    float d = (2.*cx - 8.*cy + 4.);\n    vec3 XYZ = vec3(3.*cx/d, 2.*cy/d, 1. - (3.*cx + 2.*cy)/d);\n    \n    vec3 RGB = mat3(3.240479, -0.969256, 0.055648, \n                    -1.537150, 1.875992, -0.204043, \n                    -0.498535, 0.041556, 1.057311) * vec3(1./XYZ.y*XYZ.x, 1., 1./XYZ.y*XYZ.z);\n\n    return max(RGB, 0.)*pow(t*0.0004, 4.); \n}\n\nvec3 firePalette(float i){\n\n    float T = 1400. + 1300.*i; // Temperature range (in Kelvin).\n    vec3 L = vec3(7.4, 5.6, 4.4); // Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    L = (1.0-exp(-5e8/L)); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n    \n    return (L.xyy + L.xzz)*0.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates, plus some movement about the center.\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y + vec2(0.5*cos(iTime*0.5), 0.25*sin(iTime*0.5));\n    \n    // Camera turbulence.\n    //uv.x += smoothstep(0.4, 0.7, sin(iTime*2.)*0.5+0.5)*cos(iTime*48.)*.003;\n    //uv.y += smoothstep(0.4, 0.7, cos(iTime*2.)*0.5+0.5)*sin(iTime*64.)*.003;\n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1.));\n    //rd.xy *= rot(sin(iTime*0.25)*0.5); // Very subtle look around, just to show it's a 3D effect.\n    //rd.xz *= rot(sin(iTime*0.25)*0.5);\n    \n \n    rd.xy *= rot(smoothstep(0.0, 1., sin(iTime*0.5)*0.5+0.5)*3.14159); // Look around, just to show it's a 3D effect.\n    rd.xz *= rot(smoothstep(0.2, 0.8, sin(iTime*0.25)*0.5+0.5)*3.14159);    \n    \n    \n    // Screen color. Initialized to black.\n    vec3 col = vec3(0);\n    \n    /*\n    // Ray intersection of a cylinder (radius one) - centered at the origin - from a ray-origin that has XY coordinates \n    // also centered at the origin.    \n    float sDist = max(dot(rd.xy, rd.xy), 1e-16); // Analogous to the surface function.\n    sDist = 1.4142/sqrt(sDist); // Ray origin to surface distance.\n\t*/\n    \n    /*\n    // Same as above, but using a Minkowski distance and scaling factor.\n    vec2 scale = vec2(1., 1.);\n    float power = 6.;\n    float sDist = max(dot( pow(abs(rd.xy)*scale, vec2(power)), vec2(1.) ), 1e-16); // Analogous to the surface function.\n    sDist = 1./pow( sDist, 1./power ); // Ray origin to surface distance.\n\t*/\n    \n    \n    // Square tube.\n    vec2 scale = vec2(0.75, 1.);\n    float sDist = max(max(abs(rd.x)*scale.x, abs(rd.y)*scale.y), 1e-16); // Analogous to the surface function.\n    sDist = 1./(sDist); // Ray origin to surface distance.\n\t\n    \n    //if(sDist>1e-8){\n        \n        // Surface position.\n        vec3 sp = vec3(0.0, 0.0, iTime*4.) + rd*sDist;\n \n        // Surface normal.\n        //vec3 sn = normalize(vec3(-sp.xy, 0.)); // Cylinder normal.\n        //vec3 sn = normalize(-sign(sp)*vec3(pow(abs(sp.xy)*scale, vec2(power-1.)), 0.)); // Minkowski normal.\n    \tvec3 sn =  normalize(-sign(sp)*vec3(abs(rd.x*scale.x)>abs(rd.y*scale.y) ? vec2(1., 0.) : vec2(0., 1.), 0.)); // Square normal.\n    \t\n    \n        // Coloring the surface.\n        vec3 objCol = texCol(sp, sn);\n        \n        // Bump mapping.\n        \n        const vec2 eps = vec2(0.015, 0.);\n        float c = dot(objCol, vec3(0.299, 0.587, 0.114)); // Base value. Saving an extra lookup.\n        //float c = texShade(sp); // Base value. Used below to color the surface.\n        // 3D gradient vector... of sorts. Based on the bump function. In this case, Voronoi.                \n        vec3 gr = (vec3(texShade(sp-eps.xyy, sn), texShade(sp-eps.yxy, sn), texShade(sp-eps.yyx, sn))-c)/eps.x;\n        gr -= sn*dot(sn, gr); // There's a reason for this... but I need more room. :)\n        sn = normalize(sn + gr*0.15); // Combining the bump gradient vector with the object surface normal.\n\n    \n    \tfloat wrap = 0.2;\n        float scatWidth = 0.35;\n        // Lighting.\n        //\n    \t// Light 1\n        //\n        // The light is hovering just in front of the viewer.\n        vec3 lp = vec3(0.0, 0.0, iTime*4. + 2.5);\n        vec3 ld = lp - sp; // Light direction.\n        float dist = max(length(ld), 0.001); // Distance from light to the surface.\n        ld /= dist; // Use the distance to normalize \"ld.\"\n\n        // Light attenuation, based on the distance above.\n        float atten = min(1.0/max(0.75 + dist*.5 + dist*dist*0.2, 0.001), 1.0);\n        \n       \n        float diff = max((dot(sn, ld) + wrap)/((1.+wrap)), 0.); // Diffuse light value.\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 16.); // Specular highlighting.\n    \n    \tfloat scatter = smoothstep(0.0, scatWidth, diff) * smoothstep(scatWidth * 2.0, scatWidth, diff);\n        scatter = pow(scatter, 1.);\n\n    \t// Light 2\n        //        \n        // The light is hovering just beind the viewer.\n        vec3 lp2 = vec3(0.0, 0.0, iTime*4. - 2.5);\n        vec3 ld2 = lp2 - sp; // Light direction.\n        float dist2 = max(length(ld2), 0.001); // Distance from light to the surface.\n        ld2 /= dist2; // Use the distance to normalize \"ld.\"\n\n        // Light attenuation, based on the distance above.\n        float atten2 = min(1.0/max(0.75 + dist2*.5 + dist2*dist2*0.2, 0.001), 1.0);\n        \n       \n        float diff2 = max((dot(sn, ld2) + wrap)/((1.+wrap)), 0.); // Diffuse light value.\n        float spec2 = pow(max(dot(reflect(-ld2, sn), -rd), 0.), 16.); // Specular highlighting.\n    \n    \tfloat scatter2 = smoothstep(0.0, scatWidth, diff2) * smoothstep(scatWidth * 2.0, scatWidth, diff2);\n    \tscatter2 = pow(scatter2, 1.);\n    \n\n\n        // Using the values above to produce the final color.\n    \tcol += (objCol*(diff*0.5 + 0.05 + firePalette(scatter/1.5)*1.5) + spec*vec3(0.5, 0.85, 1.))*atten;\n   \t    col += (objCol*(diff2*0.5 + 0.05 + firePalette(scatter2/1.5)*1.5) + spec2*vec3(0.5, 0.85, 1.))*atten2;\n        \n        \n    //}\n    \n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n}\n\n    ", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtSXRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[600, 630, 649, 649, 715], [718, 718, 739, 739, 794], [1757, 1785, 1821, 1940, 2027], [2071, 2071, 2098, 2229, 8350], [8352, 8352, 8375, 8375, 8523], [8525, 8525, 8546, 8546, 8780], [8782, 8782, 8817, 9078, 9510], [9512, 9512, 9546, 9546, 9630], [9632, 9632, 9663, 9663, 10393], [10395, 10395, 10421, 10421, 10781], [10784, 10784, 10840, 10909, 15930]], "test": "error"}
{"id": "Xl2SRR", "name": "Firework Show", "author": "yibojiang", "description": "Experiment particle system and some effects.", "tags": ["firework", "particlesystem"], "likes": 49, "viewed": 7071, "published": "Public API", "date": "1441277044", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//yibojiang\n/*\nI made serveral explosion pattern.\n0 is normal explosion,\n1 is circle,\n2 is flower,\n3 is star,\n4 is heart\n\nYou can uncommet the playLevel to play a firework sequence I've made,\nBut it may crash your browsers on Windows, I'm not sure about the cause\n(may be too many loops) since I havn't a pc to debug, what I do is add\nthe marco to toggle the play, which cuts lots of loops.\n*/\n//#define playLevel  //Define whether to play a firework sequence.\n#define pi 3.1415926\n\n#define til 10  // the trail length of firework \n#define etil 3  // the trail length of explosion particle, reduce this to 1 can improve performance\n#define numParticle 30  // explode particle number\n\n#define grivity .1\n#define explodePow .25 // explosion force\n#define lengthStep .5\n#define explodeStep .5\n#define grassCount 100\n#define normalflickerPow .005 //flicker intensity of explosion effect\n#define circleflickerPow .02\n#define drawGrass // whether to draw the grass\n#define dd1 4.\n#define dd2 5.\n#define tt1 2.\n\nvec2 hash2( vec2 p )                       // rand in [-1,1]\n{\n  p = vec2( dot(p, vec2(127.1, 311.7)),\n            dot(p, vec2(269.5, 183.3)) );\n  return -1. + 2.*fract(sin(p) * 53758.5453123);\n}\n\n/*\nvec2 noise(vec2 tc){\n    return hash2(tc);\n}\n*/\n\n\nvec2 noise(vec2 tc) {\n  return (2.*texture(iChannel0, tc.xy ).xy - 1.).xy;\n}\n\n\nfloat rand(vec2 c) {\n  return fract(sin(dot(c.xy , vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat randDir(float val, float seed) {\n  return cos(val * sin(val * seed) * seed);\n}\n\nfloat hash(in float n ) {\n  return fract(sin(n) * 43758.5453123);\n}\n\nfloat powFunc(in float v) {\n\n  const float a = 0.004;\n  const float t = pi * 2.;\n\n  return mix(a * pow(0.2, mod(v  , t) - 2.*pi ) ,\n             a * pow(5.0, mod(v  , t) ) ,\n             mod( floor(v / (0.5 * t) ) , 2.0) );\n\n}\n\nvec2 getPos(in vec2 o, in float t, in vec2 d) {\n  return vec2(o.x + d.x * t, o.y + d.y * t - grivity * t * t);\n}\n\n//no grivity\nvec2 getPos2(in vec2 o, in float t, in vec2 d) {\n  return vec2(o.x + d.x * t, o.y + d.y * t);\n}\n\nfloat drawPoint(in float r, in float size, in vec2 p) {\n  return smoothstep(r, r + size, length(p) );\n}\n\nvec3 drawParticle(in vec2 p, in float size, in vec3 col) {\n  return mix( col, vec3(0.0)  , smoothstep(0., size, dot(p, p) * 90.0 ) );\n}\n\nvec3 drawFlyHeart(in vec2 uv, in vec2 o, in float off, in vec3 color, in vec2 initDir, float rt ) {\n  float t = iTime + off;\n  vec3 col = vec3(0.0);\n#ifdef playLevel\n  if (t < 0. || t > dd2) {\n    return col;\n  }\n#else\n  if (t < 0. || t < dd2) {\n    return col;\n  }\n\n#endif\n\n\n\n  float nt = floor(t / dd2) + off + o.x + o.y;\n  t = mod (t, dd2 );\n\n  if (t < tt1) {\n    for (int i = 0; i < til; i++) {\n      float id = float(i) / float(til);\n      vec2 q = uv - getPos(o, t - lengthStep * id, initDir) + noise( vec2((id + hash(nt) + t ) * .65) ) * 0.005;\n      col += drawParticle(q, mix(0.02, 0.012, id) , mix(color, vec3(0.), id ));\n\n    }\n    //flare\n    vec2 flarePos = uv - getPos(o, t, initDir );\n    //col+=mix( color*mix( 1.0,0.0, length(flarePos)*20. ), vec3(0.) , drawPoint( (0.0003*abs(.1+ sin(t*.9+pi*.3) ) )*powFunc( atan( flarePos.y, flarePos.x )*4. ) ,.01,flarePos) );\n    col += mix( color * mix( 1.0, 0.0, dot(flarePos, flarePos) * 800. ),\n                vec3(0.) , drawPoint( (0.0003 * abs(.1 + sin(t * .9 + pi * .3) ) ) * powFunc( atan( flarePos.y, flarePos.x ) * 4. ) , .01, flarePos) );\n  }\n  else {\n    float t2 = t - tt1;\n    vec2 ep = getPos(o, tt1, initDir);\n    float lerp = t2 / (dd2 - tt1);\n\n    for (int j = 0; j < 100; j++) {\n      vec2 rawdir = normalize(noise( vec2( float(j) / 100. , hash(float(j) + nt ) * .5 )) );\n\n      float v = atan(rawdir.y, rawdir.x) + rt * t;\n      float r = 0.1 * (2. - 2.*sin(v) + sin(v) * sqrt( abs(cos(v) ) ) / (sin(v) + 1.4) );\n      vec2 q = uv - getPos2(ep, t2 - 0.2 * explodeStep, explodePow * r * rawdir );\n      float flicker = circleflickerPow * hash(float(j) + lerp);\n      col += drawParticle(q,\n                          (0.01 + flicker) * abs(cos(lerp * .5 * pi) ),\n                          color );\n    }\n\n    //boom light\n    col += mix( mix(color, vec3(0.), clamp(3.*lerp , 0., 1.)  ) ,\n                vec3(0.) ,\n                drawPoint(0.0, .7, uv - ep) );\n  }\n\n  return col;\n}\n\nvec3 drawFlyStar(in vec2 uv, in vec2 o, in float off, in vec3 color, in vec2 initDir ) {\n  float t = iTime + off;\n  vec3 col = vec3(0.);\n#ifdef playLevel\n  if (t < 0. || t > dd1) {\n    return col;\n  }\n#else\n  if (t < 0. || t < dd1) {\n    return col;\n  }\n\n#endif\n  float nt = floor(t / dd1) + off + o.x + o.y;\n  t = mod (t, dd1 );\n\n\n  if (t < tt1) {\n    for (int i = 0; i < til; i++) {\n      float id = float(i) / float(til);\n      vec2 q = uv - getPos(o, t - lengthStep * id, initDir) + noise( vec2((id + hash(nt) + t ) * .65) ) * 0.005;\n      col += drawParticle(q, mix(0.02, 0.012, id) ,\n                          mix(color, vec3(0.), id ));\n\n    }\n    //flare\n    vec2 flarePos = uv - getPos(o, t, initDir );\n    col += mix( color * mix( 1.0, 0.0, dot(flarePos, flarePos) * 800. ),\n                vec3(0.) , drawPoint( (0.0003 * abs(.1 + sin(t * .9 + pi * .3) ) ) * powFunc( atan( flarePos.y, flarePos.x ) * 4. ) , .01, flarePos) );\n\n  }\n  else {\n    float t2 = t - tt1;\n    vec2 ep = getPos(o, tt1, initDir);\n    float lerp = t2 / (dd1 - tt1);\n\n    for (int j = 0; j < 150; j++) {\n      vec2 rawdir = normalize(noise( vec2( float(j) / 150. , hash(float(j) + nt ) * .5 )) );\n\n      float v = atan(rawdir.y, rawdir.x) + 1.*t;\n      float r = 0.1 + 0.0015 * ( powFunc(atan(rawdir.y, rawdir.x) * 5. + t * 10.*(hash(nt) - .5) ) );\n      vec2 q = uv - getPos2(ep, t2 - 0.2 * explodeStep, explodePow * r * rawdir );\n      float flicker = circleflickerPow * hash(float(j) + lerp);\n      col += drawParticle(q, (0.01 + flicker) * abs(cos(lerp * .5 * pi) ), color );\n    }\n\n    //boom light\n    col += mix( mix(color, vec3(0.), clamp(3.*lerp , 0., 1.)  ) , vec3(0.) , drawPoint(0.0, .7, uv - ep) );\n  }\n  return col;\n}\n\nvec3 drawFlyFlower(in vec2 uv, in vec2 o, in float off, in vec3 color, in vec2 initDir, int num ) {\n  float t = iTime + off;\n  vec3 col = vec3(0.);\n#ifdef playLevel\n  if (t < 0. || t > dd2) {\n    return col;\n  }\n#else\n  if (t < 0. || t < dd2) {\n    return col;\n  }\n\n#endif\n  float nt = floor(t / dd2) + off + o.x + o.y;\n  t = mod (t, dd2 );\n\n\n  if (t < tt1) {\n    for (int i = 0; i < til; i++) {\n      float id = float(i) / float(til);\n      vec2 q = uv - getPos(o, t - lengthStep * id, initDir) + noise( vec2((id + hash(nt) + t ) * .65) ) * 0.005;\n      col += drawParticle(q, mix(0.02, 0.012, id) , mix(color, vec3(0.), id ));\n\n    }\n    //flare\n    vec2 flarePos = uv - getPos(o, t, initDir );\n    col += mix( color * mix( 1.0, 0.0, dot(flarePos, flarePos) * 800. ),\n                vec3(0.) , drawPoint( (0.0003 * abs(.1 + sin(t * .9 + pi * .3) ) ) * powFunc( atan( flarePos.y, flarePos.x ) * 4. ) , .01, flarePos) );\n    //col+=mix( color*mix( 1.0,0.0, length(flarePos)*20. ), vec3(0.) , drawPoint( (0.0003*abs(.1+ sin(t*.9+pi*.3) ) )*powFunc( atan( flarePos.y, flarePos.x )*4. ) ,.01,flarePos) );\n  }\n  else {\n    float t2 = t - tt1;\n    vec2 ep = getPos(o, tt1, initDir);\n    float lerp = t2 / (dd2 - tt1);\n    for (int j = 0; j < 100; j++) {\n      vec2 rawdir = normalize(noise( vec2( float(j) / 100. , hash(float(j) + nt ) * .5 )) );\n\n      float v = atan(rawdir.y, rawdir.x) + t * 10.*(hash(nt) - .5);\n      float r = 0.05 * sin(atan(rawdir.y, rawdir.x) * float(num) + t * 10.*(hash(nt) - .5) ) ;\n      vec2 q = uv - getPos2(ep, t2 - 0.2 * explodeStep, r * rawdir );\n      float flicker = circleflickerPow * hash(float(j) + lerp);\n      col += drawParticle(q, (0.01 + flicker) * abs(cos(lerp * .5 * pi) ), color );\n    }\n\n    //boom light\n    col += mix( mix(color, vec3(0.), clamp(3.*lerp , 0., 1.)  ) , vec3(0.) , drawPoint(0.0, .7, uv - ep) );\n  }\n  return col;\n}\n\nvec3 drawFlyCircle(in vec2 uv, in vec2 o, in float off, in vec3 color, in vec2 initDir, float r ) {\n  float t = iTime + off;\n  vec3 col = vec3(0.);\n#ifdef playLevel\n  if (t < 0. || t > dd2) {\n    return col;\n  }\n#else\n  if (t < 0. || t < dd2) {\n    return col;\n  }\n\n#endif\n\n  float nt = floor(t / dd2) + off + o.x + o.y;\n  t = mod (t, dd2 );\n\n\n  if (t < tt1) {\n    for (int i = 0; i < til; i++) {\n      float id = float(i) / float(til);\n      vec2 q = uv - getPos(o, t - lengthStep * id, initDir) + noise( vec2((id + hash(nt) + t ) * .65) ) * 0.005;\n      col += drawParticle(q, mix(0.02, 0.012, id) , mix(color, vec3(0.), id ));\n\n    }\n    //flare\n    vec2 flarePos = uv - getPos(o, t, initDir );\n    col += mix( color * mix( 1.0, 0.0, dot(flarePos, flarePos) * 800. ),\n                vec3(0.) , drawPoint( (0.0003 * abs(.1 + sin(t * .9 + pi * .3) ) ) * powFunc( atan( flarePos.y, flarePos.x ) * 4. ) , .01, flarePos) );\n  }\n  else {\n    float t2 = t - tt1;\n    vec2 ep = getPos(o, tt1, initDir);\n    float lerp = t2 / (dd2 - tt1);\n    for (int j = 0; j < 50; j++) {\n      vec2 rawdir = normalize(noise( vec2( float(j) / 50. , hash(float(j) + nt ) * .5 )) );\n      vec2 q = uv - getPos2(ep, t2, r * rawdir );\n\n      float flicker = circleflickerPow * hash(float(j) + lerp);\n      col += drawParticle(q, (0.01 + flicker) * abs(cos(lerp * .5 * pi) ), color );\n    }\n\n    //boom light\n    col += mix( mix(color, vec3(0.), clamp(3.*lerp , 0., 1.)  ) , vec3(0.) , drawPoint(0.0, .7, uv - ep) );\n  }\n  return col;\n}\n\n\n\nvec3 drawFly(in vec2 uv, in vec2 o, in float off, in vec3 color, in vec2 initDir ) {\n  float t = iTime + off;\n  vec3 col = vec3(0.);\n\n\n#ifdef playLevel\n  if (t < 0. || t > dd1) {\n    return col;\n  }\n#else\n  if (t < 0. || t < dd1) {\n    return col;\n  }\n\n#endif\n\n  float nt = floor(t / dd1) + off + o.x + o.y;\n  t = mod (t, dd1 );\n\n\n  if (t < tt1) {\n    for (int i = 0; i < til; i++) {\n      float id = float(i) / float(til);\n      vec2 q = uv - getPos(o, t - lengthStep * id, initDir) + noise( vec2((id + hash(nt) + t ) * .65) ) * 0.005;\n      col += drawParticle(q, mix(0.02, 0.012, id),\n                          mix(color, vec3(0.), id ));\n\n    }\n    //flare\n    vec2 flarePos = uv - getPos(o, t, initDir );\n    col += mix( color * mix( 1.0, 0.0, dot(flarePos, flarePos) * 800. ),\n                vec3(0.) , drawPoint( (0.0003 * abs(.1 + sin(t * .9 + pi * .3) ) ) * powFunc( atan( flarePos.y, flarePos.x ) * 4. ) , .01, flarePos) );\n  }\n  else {\n    float t2 = t - tt1;\n    vec2 ep = getPos(o, tt1, initDir);\n    float lerp = t2 / (dd1 - tt1);\n    for (int i = 0; i < etil; i++) {\n      float id = float(i) / float(etil);\n      for (int j = 0; j < numParticle; j++) {\n        vec2 dir = noise( vec2( float(j) / float(numParticle) ,\n                                hash(float(j) + nt ) * .5 ) ) * explodePow;\n\n        vec2 q = uv - getPos(ep, t2 - 0.2 * explodeStep * id, dir );\n        float flicker = normalflickerPow * hash(float(j) + lerp);\n        col += drawParticle(q, (0.01 + flicker) * abs(cos(lerp * .5 * pi) ), color * mix(1., 0., id ) );\n      }\n    }\n\n    //boom light\n    col += mix( mix(color, vec3(0.), clamp(3.*lerp , 0., 1.)  ) , vec3(0.) , drawPoint(0.0, .7, uv - ep) );\n\n  }\n  //return mix(fcol,ecol, 0.5*sign(t-tt1)+0.5 );\n  return col;\n}\n\nfloat drawMoon(in vec2 p) {\n  const float r = .18;\n  float moon = smoothstep(r, r + 0.01 , dot(p, p) * 4.4 ) ;\n  vec2 lp = p - vec2(-0.05, 0.01);\n  float lightMoon = 1. - ( smoothstep(r - 0.01, r + 0.03 , dot(lp, lp) * 5.1 ) - moon );\n  return clamp(lightMoon, 0.0, 1.0);\n}\n\nvec3 randomFire(vec2 p, vec2 uv, float time, vec2 os) {\n  vec3 col = vec3(0.);\n  vec2 rnd = vec2(0.3, 0.7);\n  for (int i = 0; i < 10; i++) {\n    rnd.x = 2.* ( hash( float(i) * 0.3 + time) - 0.5 );\n    rnd.y = hash( float(i * 10) * .3 + 2. + time) ;\n    vec3 color = vec3 ( hash( float(i) ), hash( float(i) + 1. ), hash( float(i) + 2. ) );\n\n    col += drawFly(uv, p, time - float(i) * 0.25, color, vec2( rnd.x * 0.1 + os.x , os.y + rnd.y * 0.05 ) );\n  }\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\n  vec2 p = fragCoord.xy / iResolution.xy;\n  float ratio = iResolution.y / iResolution.x;\n  vec2 uv = p;\n  uv.y *= ratio;\n\n  //bg sky\n  float lerp = smoothstep(.0, 1. , uv.y );\n  vec3 col = mix(vec3(.1, .2, .3), vec3(.1, .1, .1) , sqrt(uv.y)  );\n\n  vec2 moonPos = uv - vec2(.568, .29);\n  //bg stars\n  col.xyz += mix(vec3(0.) , sign ( vec3( clamp(rand(uv) - 0.9985, 0., 1. ) ) ) ,   clamp (sign (dot(moonPos, moonPos) - 0.05), 0., 1. ) );\n\n  vec3 moonCol = vec3(0.45, 0.3, 0.3);\n  col = mix (moonCol, col, drawMoon(moonPos ) );\n\n\n  //firework level sequence\n#ifdef playLevel\n\n  float stage = 0.;\n  col += drawFly( uv, vec2(0.65, 0.0), 0., vec3(.9, .6, .0), vec2(-0.1, .4) );\n  col += drawFly( uv, vec2(0.45, 0.0), -4.0, vec3(.3, .5, .9), vec2(.1, 0.35) );\n\n  col += drawFly( uv, vec2(0.65, 0.0), -8.5, vec3(.9, .1, .0), vec2(-0.1, .4) );\n  col += drawFly( uv, vec2(0.45, 0.0), -8.5, vec3(.3, .2, .9), vec2(0.1, 0.35) );\n\n  col += drawFly( uv, vec2(0.65, 0.0), -12.5, vec3(.6, .9, .0), vec2(-0.15, .35) );\n  col += drawFly( uv, vec2(0.5, 0.0), -12.5, vec3(.9, .9, .9), vec2(0.0, .4) );\n  col += drawFly( uv, vec2(0.45, 0.0), -12.5, vec3(.9, .5, .1), vec2(.15, 0.35) );\n\n\n  stage -= 16.;\n  for (int ii = 0; ii < 5; ii++) {\n    float i = float(ii);\n    col += drawFly( uv, vec2(0.3 + 0.1 * i, 0.0), stage - 0.5 * i, vec3(.6, .4, .0), vec2(0.0, .4) );\n  }\n  /*\n      stage-=5.0;\n      for (float i=0.;i<5.;i++){\n          col+=drawFly( uv,vec2(0.7-0.1*i,0.0),stage-i*0.5,vec3(.6,.4,.0), vec2(0.0,.4) );\n      }\n\n\n      stage-=5.;\n\n\n      col+=drawFly( uv,vec2(0.4,0.0),stage,vec3(.6,.3,.5), vec2(0,0.3) );\n      col+=drawFly( uv,vec2(0.6,0.0),stage,vec3(.6,.3,.5), vec2(0,0.3) );\n\n\n      stage-=2.;\n      col+=drawFly( uv,vec2(0.4,0.0),stage,vec3(.3,.5,.0), vec2(0,0.35) );\n      col+=drawFly( uv,vec2(0.6,0.0),stage,vec3(.3,.5,.0), vec2(0,0.35) );\n\n      stage-=2.;\n      col+=drawFly( uv,vec2(0.4,0.0),stage,vec3(.1,.4,.4), vec2(0,0.4) );\n      col+=drawFly( uv,vec2(0.6,0.0),stage,vec3(.1,.4,.4), vec2(0,0.4) );\n  */\n  stage -= 4.;\n  col += randomFire(vec2(0.5, 0.0), uv, stage, vec2(0., 0.35) );\n\n  stage -= 5.;\n  for (int ii = 0; ii < 5; ii++) {\n    float i = float(ii);\n    col += drawFly( uv, vec2(0.7 - i * 0.1, 0.0), stage - i * 0.5, vec3(.1, .4, .6), vec2(0.1, .4) );\n  }\n\n  stage -= 4.;\n  for (int ii = 0; ii < 5; ii++) {\n    float i = float(ii);\n    col += drawFly( uv, vec2(0.7 - i * 0.1, 0.0), stage - i * 0.5, vec3(.6, .2, .6), vec2(-0.1, .4) );\n  }\n\n  stage -= 4.;\n  for (int ii = 0; ii < 5; ii++) {\n    float i = float(ii);\n    col += drawFly( uv, vec2(0.7 - i * 0.1, 0.0), stage - i * 0.5, vec3(.1, .4, .6), vec2(0.1, .4) );\n    col += drawFly( uv, vec2(0.7 - i * 0.1, 0.0), stage - 2.0 + i * 0.5, vec3(.6, .2, .6), vec2(-0.1, 0.4) );\n  }\n\n  stage -= 4.;\n  for (int ii = 0; ii < 5; ii++) {\n    float i = float(ii);\n    col += drawFly( uv, vec2(0.7 - i * 0.1, 0.0), stage - 2.0 + i * 0.5, vec3(.2, .4, .4), vec2(0.1, .4) );\n    col += drawFly( uv, vec2(0.7 - i * 0.1, 0.0), stage - i * 0.5, vec3(.6, .2, .2), vec2(-0.1, 0.4) );\n  }\n  /*\n   stage-=4.;\n   for (float i=0.;i<5.;i++){\n       col+=drawFly( uv,vec2(0.7-i*0.1,0.0),stage-i*0.5,vec3(.6,.4,.0), vec2(0.1,.4) );\n       col+=drawFly( uv,vec2(0.7-i*0.1,0.0),stage-2.0+i*0.5,vec3(.6,.4,.0), vec2(-0.1,0.4) );\n   }\n\n   for (float i=0.;i<5.;i++){\n       col+=drawFly( uv,vec2(0.7-i*0.1,0.0),stage-2.0+i*0.5,vec3(.6,.4,.0), vec2(0.1,.4) );\n       col+=drawFly( uv,vec2(0.7-i*0.1,0.0),stage-i*0.5,vec3(.6,.4,.0), vec2(-0.1,0.4) );\n   }\n  */\n  stage -= 4.;\n\n  col += drawFlyHeart( uv, vec2(0.5, 0.0), stage, vec3(.7, .4, .6), vec2(0.0, 0.4) , 0.01);\n\n  stage -= 6.;\n  col += drawFlyCircle( uv, vec2(0.3, 0.0), stage, vec3(.1, .4, .6), vec2(0.0, 0.35) , 0.06);\n  col += drawFlyCircle( uv, vec2(0.7, 0.0), stage, vec3(.1, .4, .6), vec2(0.0, 0.35) , 0.06);\n\n  stage -= 2.;\n  col += drawFlyFlower( uv, vec2(0.4, 0.0), stage, vec3(.7, .4, .1), vec2(0.0, 0.4) , 5);\n  col += drawFlyFlower( uv, vec2(0.6, 0.0), stage, vec3(.7, .4, .1), vec2(0.0, 0.4) , 5);\n\n  stage -= 2.;\n  col += drawFlyCircle( uv, vec2(0.3, 0.0), stage, vec3(.6, .5, .6), vec2(0.0, 0.35) , 0.06);\n  col += drawFlyCircle( uv, vec2(0.7, 0.0), stage, vec3(.6, .5, .6), vec2(0.0, 0.35) , 0.06);\n\n  stage -= 2.;\n  col += drawFlyFlower( uv, vec2(0.4, 0.0), stage, vec3(.1, .4, .7), vec2(0.0, 0.4) , 5);\n  col += drawFlyFlower( uv, vec2(0.6, 0.0), stage, vec3(.1, .4, .7), vec2(0.0, 0.4) , 5);\n\n  stage -= 4.;\n  for (int ii = 0; ii < 4; ii++) {\n    float i = float(ii);\n    col += drawFlyCircle( uv, vec2(0.2 + i * 0.2, 0.0), stage - i, vec3(.6, .2, .0), vec2(0.0, .4), 0.06 );\n  }\n\n  stage -= .5;\n  for (int ii = 0; ii < 3; ii++) {\n    float i = float(ii);\n    col += drawFlyCircle( uv, vec2(0.3 + i * 0.2, 0.0), stage - i, vec3(.2, .4, .6), vec2(0.0, 0.35), 0.06 );\n  }\n\n  stage -= 5.;\n  for (int ii = 0; ii < 4; ii++) {\n    float i = float(ii);\n    col += drawFlyCircle( uv, vec2(0.2 + i * 0.2, 0.0), stage, vec3(.6, .1, .0), vec2(0.0, .4), 0.06 );\n  }\n\n  for (int ii = 0; ii < 3; ii++) {\n    float i = float(ii);\n    col += drawFlyCircle( uv, vec2(0.3 + i * 0.2, 0.0), stage, vec3(.2, .4, .6), vec2(0.0, 0.35), 0.06 );\n  }\n\n  //stage-=4.;\n  //col+=randomFire(vec2(0.5,0.0),uv,stage,vec2(0.0,0.36) );\n\n  stage -= 2.;\n  col += drawFlyFlower( uv, vec2(0.2, 0.0), stage, vec3(.7, .4, .1), vec2(0.0, 0.35) , 4);\n  col += drawFlyFlower( uv, vec2(0.8, 0.0), stage, vec3(.7, .4, .1), vec2(0.0, 0.35) , 4);\n\n\n  stage -= 4.;\n  /*\n  for (float i=0.;i<5.;i++){\n  col+=drawFlyHeart( uv,vec2(0.3,0.0),stage-i*5.0,vec3(.7,.4,.6), vec2(-0.05,0.38) ,-0.1);\n  col+=drawFlyHeart( uv,vec2(0.7,0.0),stage-i*5.0,vec3(.7,.4,.6), vec2(0.05,0.38) ,0.1);\n  }\n    */\n\n  for (int ii = 0; ii < 5; ii++) {\n    float i = float(ii);\n    col += drawFly( uv, vec2(0.6, 0.0), stage - i * 10.5, vec3(.7, .3, .0), vec2(0.07, 0.36) );\n    col += drawFlyCircle(uv, vec2(0.6, 0.0), stage - i * 10.5 - 1.0, vec3(.6, .4, .0), vec2(-0.1, .3), 0.05 );\n    col += drawFlyStar(uv, vec2(0.4, 0.0), stage - i * 10.5 - 2.5, vec3(.0, .4, .6), vec2(0.1, 0.4) );\n    col += drawFlyFlower( uv, vec2(0.5, 0.0), stage - i * 10.5 - 4.5, vec3(.2, .6, .1), vec2(-.13, 0.28) , 5);\n    col += drawFlyHeart( uv, vec2(0.5, 0.0), stage - i * 10.5 - 5.5, vec3(.7, .4, .6), vec2(0.0, 0.45) , -0.05);\n  }\n\n#else\n\n\n  //col+=randomFire(vec2(0.5,0.0),uv,0.,vec2(0.0,0.36) );\n\n\n  /*\n    for (float i=0.0;i<10.;i++){\n      col+=drawFly( uv,vec2(0.6,0.0),-i*10.5,vec3(.7,.3,.0), vec2(0.07,0.36) );\n        col+=drawFlyCircle(uv,vec2(0.6,0.0),-i*10.5-1.0,vec3(.6,.4,.0), vec2(-0.1,.3), 0.05 );\n        col+=drawFlyStar(uv,vec2(0.4,0.0),-i*10.5-2.5,vec3(.0,.4,.6), vec2(0.1,0.4) );\n    col+=drawFlyFlower( uv,vec2(0.5,0.0),-i*10.5-4.5,vec3(.2,.6,.1), vec2(0.0,0.35) , 5);\n      col+=drawFlyHeart( uv,vec2(0.5,0.0),-i*10.5-5.5,vec3(.7,.4,.6), vec2(-0.13,0.38) , -0.1);\n    }\n  */\n  col += drawFly( uv, vec2(0.6, 0.0), 0.0, vec3(.7, .3, .0), vec2(0.07, 0.36) );\n  col += drawFlyCircle(uv, vec2(0.6, 0.0), -1.0, vec3(.6, .4, .0), vec2(-0.1, .3), 0.05 );\n  col += drawFlyStar(uv, vec2(0.4, 0.0), -2.5, vec3(.0, .4, .6), vec2(0.1, 0.4) );\n  col += drawFlyFlower( uv, vec2(0.5, 0.0), -4.5, vec3(.2, .6, .1), vec2(0.0, 0.35) , 5);\n  col += drawFlyHeart( uv, vec2(0.5, 0.0), -5.5, vec3(.7, .4, .6), vec2(-0.13, 0.38) , -0.1);\n\n\n#endif\n\n  //ground\n  vec3 earthCol = vec3(0.1, 0.1, 0.1);\n  float g = 0.02 * exp( (uv.x ) * 1.2);\n  col = mix (earthCol, col, smoothstep(g, g + 0.015 , abs(uv.y + 0.02) )  );\n\n  //grass\n\n  //vec3 grassCol=vec3(.5,.7,.4);\n#ifdef drawGrass\n  float it = 0.;\n  for (int i = 0; i < grassCount; i++) {\n    it += 1.;\n    float h = .04 + it * hash(it) * 0.0008;\n    vec2 gp = uv - vec2(it * 1. / float(grassCount) + hash(it) * 0.02 + mix(0., 0.15, uv.y) * cos(iTime * (1. + 0.5 * sin(it) ) + it) , h + 0.0005 * it);\n    float w = mix(.0015, 0., (uv.y + gp.y) / h );\n    col = mix(earthCol, col, 1. - (1. - smoothstep(h, h + 0.001, abs(gp.y ) )  ) * (1. - smoothstep(w, w + 0.001, abs(gp.x - 0.04 * cos(12.*gp.y + it / 100.*pi) ) )  ) );\n  }\n#endif\n\n  //float ll=0.1*hash(uv.x*1.);\n  ////ll=1.0*noise( uv*40. ).x;\n  //col=mix(vec3(1.),col,smoothstep(ll,ll+0.01, p.y) );\n  fragColor = vec4(col, 0.  );\n\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}, {"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2SRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1005, 1005, 1067, 1067, 1200], [1255, 1255, 1276, 1276, 1331], [1334, 1334, 1354, 1354, 1425], [1427, 1427, 1465, 1465, 1511], [1513, 1513, 1538, 1538, 1580], [1582, 1582, 1609, 1609, 1808], [1810, 1810, 1857, 1857, 1922], [1924, 1937, 1985, 1985, 2032], [2034, 2034, 2089, 2089, 2137], [2139, 2139, 2197, 2197, 2274], [2276, 2276, 2375, 2375, 4232], [4234, 4234, 4322, 4322, 5947], [5949, 5949, 6048, 6048, 7825], [7827, 7827, 7926, 7926, 9338], [9342, 9342, 9426, 9426, 11102], [11104, 11104, 11131, 11131, 11377], [11379, 11379, 11434, 11434, 11847], [11849, 11849, 11906, 11906, 20069]], "test": "error"}
{"id": "Xl2XRW", "name": "Where the River Goes", "author": "P_Malin", "description": "What started as a hacked flow and advection experiment turned into something nice.\n\nIf you have a (very) fast GPU, try uncommenting #define ENABLE_ULTRA_QUALITY", "tags": ["water", "flow", "advection"], "likes": 347, "viewed": 45995, "published": "Public API", "date": "1442094288", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Where the River Goes\n// @P_Malin\n\n// What started as a hacked flow and advection experiment turned into something nice.\n\n// Placeholder audio https://www.youtube.com/watch?v=gmar4gh5nIw suggested by @qthund on twitter\n\n//#define ENABLE_ULTRA_QUALITY\n\n#define ENABLE_WATER\n#define ENABLE_FOAM\n#define ENABLE_WATER_RECEIVE_SHADOW\n#define ENABLE_CONE_STEPPING\n\n\n// Textureless version\n//#define ENABLE_NIMITZ_TRIANGLE_NOISE\n\n//#define ENABLE_LANDSCAPE_RECEIVE_SHADOW\n\n//#define ENABLE_SCREENSHOT_MODE\nconst float k_screenshotTime = 13.0;\n\n#if defined(ENABLE_SCREENSHOT_MODE) || defined(ENABLE_ULTRA_QUALITY)\n#define ENABLE_SUPERSAMPLE_MODE\n#endif\n\n#ifndef ENABLE_SCREENSHOT_MODE\n#ifdef ENABLE_ULTRA_QUALITY\nconst int k_raymarchSteps = 96;\nconst int k_fmbSteps = 6;\nconst int k_superSampleCount = 6;\n#else\nconst int k_raymarchSteps = 64;\nconst int k_fmbSteps = 3;\n#endif\n#else\nconst int k_raymarchSteps = 96;\nconst int k_fmbSteps = 5;\nconst int k_superSampleCount = 10;\n#endif\n\nconst int k_fmbWaterSteps = 4;\n\n#define OBJ_ID_SKY 0.0\n#define OBJ_ID_GROUND 1.0\n\nfloat g_fTime;\n\nconst vec3 g_vSunDir = vec3( -1.0, 0.7, 0.25 );\nvec3 GetSunDir() { return normalize( g_vSunDir ); }\n\nconst vec3 g_sunColour = vec3( 1.0, 0.85, 0.5 ) * 5.0;\nconst vec3 g_skyColour = vec3( 0.1, 0.5, 1.0 ) * 1.0;\n\nconst vec3 k_bgSkyColourUp = g_skyColour * 4.0;\nconst vec3 k_bgSkyColourDown = g_skyColour * 6.0;\n\nconst vec3 k_envFloorColor = vec3(0.3, 0.2, 0.2);\n\nconst vec3 k_vFogExt = vec3(0.01, 0.015, 0.015) * 3.0;\nconst vec3 k_vFogIn = vec3(1.0, 0.9, 0.8) * 0.015;\n\n\nconst float k_fFarClip = 20.0;\n\n#define MOD2 vec2(4.438975,3.972973)\n\nfloat Hash( float p ) \n{\n    // https://www.shadertoy.com/view/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n\t//return fract(sin(n)*43758.5453);\n}\n\nvec2 Hash2( float p ) \n{\n    // https://www.shadertoy.com/view/4djSRW - Dave Hoskins\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\nfloat FBM( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<k_fmbSteps; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\nfloat FBM_Simple( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<3; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\nvec3 SmoothNoise_DXY(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\tvec2 dt = 6.0 * f - 6.0 * f2;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\tfloat du = dt.x;\t\n\tfloat dv = dt.y;\t\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n\tfloat dx = (b-a)*du + (a-b+d-c)*du*v;\n\tfloat dy = (c-a)*dv + (a-b+d-c)*u*dv;    \n    \n    return vec3(dx, dy, res);\n}\n\nvec3 FBM_DXY( vec2 p, vec2 flow, float ps, float df ) {\n\tvec3 f = vec3(0.0);\n    float tot = 0.0;\n    float a = 1.0;\n    //flow *= 0.6;\n    for( int i=0; i<k_fmbWaterSteps; i++)\n    {\n        p += flow;\n        flow *= -0.75; // modify flow for each octave - negating this is fun\n        vec3 v = SmoothNoise_DXY( p );\n        f += v * a;\n        p += v.xy * df;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\nfloat GetRiverMeander( const float x )\n{\n    return sin(x * 0.3) * 1.5;\n}\n\nfloat GetRiverMeanderDx( const float x )\n{\n    return cos(x * 0.3) * 1.5 * 0.3;\n}\n\nfloat GetRiverBedOffset( const vec3 vPos )\n{\n    float fRiverBedDepth = 0.3 + (0.5 + 0.5 * sin( vPos.x * 0.001 + 3.0)) * 0.4;\n    float fRiverBedWidth = 2.0 + cos( vPos.x * 0.1 ) * 1.0;;\n    \n    float fRiverBedAmount = smoothstep( fRiverBedWidth, fRiverBedWidth * 0.5, abs(vPos.z - GetRiverMeander(vPos.x)) );\n        \n    return fRiverBedAmount * fRiverBedDepth;    \n}\n\nfloat GetTerrainHeight( const vec3 vPos )\n{    \n    float fbm = FBM( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm;\n    \n    fTerrainHeight -= GetRiverBedOffset(vPos);\n        \n    return fTerrainHeight;\n}\n\nfloat GetTerrainHeightSimple( const vec3 vPos )\n{    \n    float fbm = FBM_Simple( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm;\n    \n    fTerrainHeight -= GetRiverBedOffset(vPos);\n        \n    return fTerrainHeight;\n}\n\n\nfloat GetSceneDistance( const vec3 vPos )\n{\n    return vPos.y - GetTerrainHeight( vPos );\n}\n\nfloat GetFlowDistance( const vec2 vPos )\n{\n    return -GetTerrainHeightSimple( vec3( vPos.x, 0.0, vPos.y ) );\n}\n\nvec2 GetBaseFlow( const vec2 vPos )\n{\n    return vec2( 1.0, GetRiverMeanderDx(vPos.x) );\n}\n\nvec2 GetGradient( const vec2 vPos )\n{\n    vec2 vDelta = vec2(0.01, 0.00);\n    float dx = GetFlowDistance( vPos + vDelta.xy ) - GetFlowDistance( vPos - vDelta.xy );\n    float dy = GetFlowDistance( vPos + vDelta.yx ) - GetFlowDistance( vPos - vDelta.yx );\n    return vec2( dx, dy );\n}\n\nvec3 GetFlowRate( const vec2 vPos )\n{\n    vec2 vBaseFlow = GetBaseFlow( vPos );\n\n    vec2 vFlow = vBaseFlow;\n    \n    float fFoam = 0.0;\n\n\tfloat fDepth = -GetTerrainHeightSimple( vec3(vPos.x, 0.0, vPos.y) );\n    float fDist = GetFlowDistance( vPos );\n    vec2 vGradient = GetGradient( vPos );\n    \n    vFlow += -vGradient * 40.0 / (1.0 + fDist * 1.5);\n    vFlow *= 1.0 / (1.0 + fDist * 0.5);\n\n#if 1\n    float fBehindObstacle = 0.5 - dot( normalize(vGradient), -normalize(vFlow)) * 0.5;\n    float fSlowDist = clamp( fDepth * 5.0, 0.0, 1.0);\n    fSlowDist = mix(fSlowDist * 0.9 + 0.1, 1.0, fBehindObstacle * 0.9);\n    //vFlow += vGradient * 10.0 * (1.0 - fSlowDist);\n    fSlowDist = 0.5 + fSlowDist * 0.5;\n    vFlow *= fSlowDist;\n#endif    \n    \n    float fFoamScale1 =0.5;\n    float fFoamCutoff = 0.4;\n    float fFoamScale2 = 0.35;\n    \n    fFoam = abs(length( vFlow )) * fFoamScale1;// - length( vBaseFlow ));\n\tfFoam += clamp( fFoam - fFoamCutoff, 0.0, 1.0 );\n    //fFoam = fFoam* fFoam;\n    fFoam = 1.0 - pow( fDist, fFoam * fFoamScale2 );\n    //fFoam = fFoam / fDist;\n    return vec3( vFlow * 0.6, fFoam  );\n}\n\nvec4 SampleWaterNormal( vec2 vUV, vec2 vFlowOffset, float fMag, float fFoam )\n{    \n    vec2 vFilterWidth = max(abs(dFdx(vUV)), abs(dFdy(vUV)));\n  \tfloat fFilterWidth= max(vFilterWidth.x, vFilterWidth.y);\n    \n    float fScale = (1.0 / (1.0 + fFilterWidth * fFilterWidth * 2000.0));\n    float fGradientAscent = 0.25 + (fFoam * -1.5);\n    vec3 dxy = FBM_DXY(vUV * 20.0, vFlowOffset * 20.0, 0.75 + fFoam * 0.25, fGradientAscent);\n    fScale *= max(0.25, 1.0 - fFoam * 5.0); // flatten normal in foam\n    vec3 vBlended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, fMag, dxy.y) ), fScale );\n    return vec4( normalize( vBlended ), dxy.z * fScale );\n}\n\nfloat SampleWaterFoam( vec2 vUV, vec2 vFlowOffset, float fFoam )\n{\n    float f =  FBM_DXY(vUV * 30.0, vFlowOffset * 50.0, 0.8, -0.5 ).z;\n    float fAmount = 0.2;\n    f = max( 0.0, (f - fAmount) / fAmount );\n    return pow( 0.5, f );\n}\n    \n\nvec4 SampleFlowingNormal( const vec2 vUV, const vec2 vFlowRate, const float fFoam, const float time, out float fOutFoamTex )\n{\n    float fMag = 2.5 / (1.0 + dot( vFlowRate, vFlowRate ) * 5.0);\n    float t0 = fract( time );\n    float t1 = fract( time + 0.5 );\n    \n    float i0 = floor( time );\n    float i1 = floor( time + 0.5 );\n    \n    float o0 = t0 - 0.5;\n    float o1 = t1 - 0.5;\n    \n    vec2 vUV0 = vUV + Hash2(i0);\n    vec2 vUV1 = vUV + Hash2(i1);\n    \n    vec4 sample0 = SampleWaterNormal( vUV0, vFlowRate * o0, fMag, fFoam );\n    vec4 sample1 = SampleWaterNormal( vUV1, vFlowRate * o1, fMag, fFoam );\n\n    float weight = abs( t0 - 0.5 ) * 2.0;\n    //weight = smoothstep( 0.0, 1.0, weight );\n\n    float foam0 = SampleWaterFoam( vUV0, vFlowRate * o0 * 0.25, fFoam );\n    float foam1 = SampleWaterFoam( vUV1, vFlowRate * o1 * 0.25, fFoam );\n    \n    vec4 result=  mix( sample0, sample1, weight );\n    result.xyz = normalize(result.xyz);\n\n    fOutFoamTex = mix( foam0, foam1, weight );\n\n    return result;\n}\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 2.0);\n\n\treturn vDir;\n}\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.8;\n\t\n\tfloat fShade = mix( 1.0, 1.0 - kStrength, fDist );\t\n\n\treturn vInput * fShade;\n}\n\nvec3 Tonemap( vec3 x )\n{\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );\n}\n\nstruct Intersection\n{\n    float m_dist;\n    float m_objId;\n    vec3 m_pos;\n};\n    \nvoid RaymarchScene( vec3 vRayOrigin, vec3 vRayDir, out Intersection intersection )\n{\n    float stepScale = 1.0;\n#ifdef ENABLE_CONE_STEPPING\n    vec2 vRayProfile = vec2( sqrt(dot(vRayDir.xz, vRayDir.xz) ), vRayDir.y );\n    vec2 vGradVec = normalize( vec2( 1.0, 2.0 ) ); // represents the biggest gradient in our heightfield\n    vec2 vGradPerp = vec2( vGradVec.y, -vGradVec.x );\n\n    float fRdotG = dot( vRayProfile, vGradPerp );\n    float fOdotG = dot( vec2(0.0, 1.0), vGradPerp );\n\n    stepScale = -fOdotG / fRdotG;\n\n    if ( stepScale < 0.0 )\n    {\n        intersection.m_objId = OBJ_ID_SKY;\n        intersection.m_dist = k_fFarClip;\n        return;\n    }\n#endif\n    \n    intersection.m_dist = 0.01;\n    intersection.m_objId = OBJ_ID_SKY;\n    \n    float fSceneDist = 0.0;\n    \n    float oldT = 0.01;\n    for( int iter = 0; iter < k_raymarchSteps; iter++ )\n    {\n        vec3 vPos = vRayOrigin + vRayDir * intersection.m_dist;\n      \n        // into sky - early out\n        if ( vRayDir.y > 0.0 )\n        {\n            if( vPos.y > 1.0 )\n            {\n                intersection.m_objId = OBJ_ID_SKY;\n                intersection.m_dist = k_fFarClip;\n                break;\n            }\n        }\n\n      \n        fSceneDist = GetSceneDistance( vPos );\n\n        oldT = intersection.m_dist;\n        intersection.m_dist += fSceneDist * stepScale;\n                \n        intersection.m_objId = OBJ_ID_GROUND;\n        if ( fSceneDist <= 0.01 )\n        {\n            break;\n        }\n\n        if ( intersection.m_dist > k_fFarClip )\n        {\n            intersection.m_objId = OBJ_ID_SKY;\n            intersection.m_dist = k_fFarClip;\n            break;\n        }        \n\n        \n    }    \n    \n    intersection.m_pos = vRayOrigin + vRayDir * intersection.m_dist;\n}\n\nvec3 GetSceneNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.001;\n\n    vec3 vDir1 = vec3( 1.0, 0.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, 0.0,  1.0);\n    vec3 vDir3 = vec3(-1.0, 0.0, -1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n\n    vec3 vPos1 = vPos + vOffset1;\n    vec3 vPos2 = vPos + vOffset2;\n    vec3 vPos3 = vPos + vOffset3;\n \n    float f1 = GetSceneDistance( vPos1 );\n    float f2 = GetSceneDistance( vPos2 );\n    float f3 = GetSceneDistance( vPos3 );\n    \n    vPos1.y -= f1;\n    vPos2.y -= f2;\n    vPos3.y -= f3;\n    \n    vec3 vNormal = cross( vPos1 - vPos2, vPos3 - vPos2 );\n    \n    return normalize( vNormal );\n}\n\n\nvoid TraceWater( vec3 vRayOrigin, vec3 vRayDir, out Intersection intersection )\n{\n \tintersection.m_dist = k_fFarClip;\n    \n    float t = -vRayOrigin.y / vRayDir.y;\n    if ( t > 0.0 )\n    {\n        intersection.m_dist = t;\n    }\n    \n    intersection.m_pos = vRayOrigin + vRayDir * intersection.m_dist;\n}\n\nstruct Surface\n{\n    vec3 m_pos;\n    vec3 m_normal;\n    vec3 m_albedo;\n    vec3 m_specR0;\n    float m_gloss;\n    float m_specScale;\n};\n    \n#ifdef ENABLE_NIMITZ_TRIANGLE_NOISE\n// https://www.shadertoy.com/view/4ts3z2\n\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y)), tri(p.z+tri(p.x)), tri(p.y+tri(p.x)));}\n\nfloat triNoise(in vec3 p)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=4.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += dg;\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n           \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}    \n#endif\n    \nvoid GetSurfaceInfo( Intersection intersection, out Surface surface )\n{\n    surface.m_pos = intersection.m_pos;\n    surface.m_normal = GetSceneNormal(intersection.m_pos);\n\n#ifdef ENABLE_NIMITZ_TRIANGLE_NOISE\n    vec3 vNoisePos = surface.m_pos * vec3(0.4, 0.3, 1.0);\n\tsurface.m_normal = normalize(surface.m_normal +triNoise(vNoisePos));\n    float fNoise = triNoise(vNoisePos);\n    fNoise = pow( fNoise, 0.15);\n    surface.m_albedo = mix(vec3(.7,.8,.95), vec3(.1, .1,.05), fNoise );    \n#else\n    #if 0\n    surface.m_albedo = texture( iChannel0, intersection.m_pos.xz ).rgb;\n    surface.m_albedo = surface.m_albedo * surface.m_albedo;\n    #else\n    vec3 vWeights = surface.m_normal * surface.m_normal;\n    vec3 col = vec3(0.0);\n    vec3 _sample;\n    _sample = texture( iChannel0, intersection.m_pos.xz ).rgb;\n    col += _sample * _sample * vWeights.y;\n    _sample = texture( iChannel0, intersection.m_pos.xy ).rgb;\n    col += _sample * _sample * vWeights.z;\n    _sample = texture( iChannel0, intersection.m_pos.yz ).rgb;\n    col += _sample * _sample * vWeights.x;\n    col /= vWeights.x + vWeights.y + vWeights.z;\n    surface.m_albedo = col;\n    #endif\n#endif    \n    \n    surface.m_specR0 = vec3(0.001);\n    surface.m_gloss = 0.0;\n    surface.m_specScale = 1.0;\n}\n   \nfloat GIV( float dotNV, float k)\n{\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nfloat GetSunShadow( const vec3 vPos )\n{\n    vec3 vSunDir = GetSunDir();\n\n    Intersection shadowInt;\n    float k_fShadowDist = 2.0;\n    RaymarchScene( vPos + vSunDir * k_fShadowDist, -vSunDir, shadowInt );\n    \n    float fShadowFactor = 1.0;\n    if( shadowInt.m_dist < (k_fShadowDist - 0.1) )\n    {\n        fShadowFactor = 0.0;\n    }\n\n    return fShadowFactor;\n}\n\nvoid AddSunLight( Surface surf, const vec3 vViewDir, const float fShadowFactor, inout vec3 vDiffuse, inout vec3 vSpecular )\n{\n    vec3 vSunDir = GetSunDir();\n\n\tvec3 vH = normalize( vViewDir + vSunDir );\n\tfloat fNdotL = clamp(dot(GetSunDir(), surf.m_normal), 0.0, 1.0);\n\tfloat fNdotV = clamp(dot(vViewDir, surf.m_normal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surf.m_normal, vH), 0.0, 1.0);\n    \n    float diffuseIntensity = fNdotL;\n    \n    vDiffuse += g_sunColour * diffuseIntensity * fShadowFactor;\n\t//vDiffuse = fShadowFactor * vec3(100.0);\n\t\n\tfloat alpha = 1.0 - surf.m_gloss;\n\t// D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr / (pi * denom * denom);\n\n\tfloat k = alpha / 2.0;\n\tfloat vis = GIV(fNdotL, k) * GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNdotL;\n\tvSpecular += g_sunColour * fSpecularIntensity * fShadowFactor;\n}\n    \nvoid AddSkyLight( Surface surf, inout vec3 vDiffuse, inout vec3 vSpecular )\n{\n    float skyIntensity = max( 0.0, surf.m_normal.y * 0.3 + 0.7 );\n    vDiffuse += g_skyColour * skyIntensity;       \n}\n\nvec3 GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvec3 GetWaterExtinction( float dist )\n{\n    float fOpticalDepth = dist * 6.0;\n\n    vec3 vExtinctCol = 1.0 - vec3(0.5, 0.4, 0.1);           \n    vec3 vExtinction = exp2( -fOpticalDepth * vExtinctCol );\n    \n    return vExtinction;\n}\n\nvec3 GetSkyColour( vec3 vRayDir )\n{    \n\tvec3 vSkyColour = mix( k_bgSkyColourDown, k_bgSkyColourUp, clamp( vRayDir.y, 0.0, 1.0 ) );\n    float fSunDotV = dot(GetSunDir(), vRayDir);    \n    float fDirDot = clamp(fSunDotV * 0.5 + 0.5, 0.0, 1.0);\n    vSkyColour += g_sunColour * (1.0 - exp2(fDirDot * -0.5)) * 2.0;\n    \n    return vSkyColour;\n}\n\nvec3 GetEnvColour( vec3 vRayDir, float fGloss )\n{\n\treturn mix( k_envFloorColor, k_bgSkyColourUp, clamp( vRayDir.y * (1.0 - fGloss * 0.5) * 0.5 + 0.5, 0.0, 1.0 ) );\n}\n\n\nvec3 GetRayColour( const in vec3 vRayOrigin, const in vec3 vRayDir, out Intersection intersection )\n{\n    RaymarchScene( vRayOrigin, vRayDir, intersection );        \n\n    if ( intersection.m_objId == OBJ_ID_SKY )\n    {\n        return GetSkyColour( vRayDir );\n    }\n    \n    Surface surface;\n    GetSurfaceInfo( intersection, surface );\n\n    vec3 vIgnore = vec3(0.0);\n    vec3 vResult = vec3(0.0);\n    float fSunShadow = 1.0;\n    AddSunLight( surface, -vRayDir, fSunShadow, vResult, vIgnore );\n    AddSkyLight( surface, vResult, vIgnore);\n    return vResult * surface.m_albedo;\n}\n\nvec3 GetRayColour( const in vec3 vRayOrigin, const in vec3 vRayDir )\n{\n\tIntersection intersection;\n    return GetRayColour( vRayOrigin, vRayDir, intersection );\n}\n\nvec3 GetSceneColour( const in vec3 vRayOrigin,  const in vec3 vRayDir )\n{\n\tIntersection primaryInt;\n    RaymarchScene( vRayOrigin, vRayDir, primaryInt );\n\n     float fFogDistance = 0.0;\n    vec3 vResult = vec3( 0.0 );\n    \n    float fSunDotV = dot(GetSunDir(), vRayDir);    \n\n    if ( primaryInt.m_objId == OBJ_ID_SKY )\n    {\n        vResult = GetSkyColour( vRayDir );\n        fFogDistance = k_fFarClip;\n    }\n    else\n    {\n        Intersection waterInt;\n        TraceWater( vRayOrigin, vRayDir, waterInt );\n\n        vec3 vReflectRayOrigin;\n        vec3 vSpecNormal;\n        vec3 vTransmitLight;\n\n        Surface specSurface;\n        vec3 vSpecularLight = vec3(0.0);\n\n    #ifdef ENABLE_WATER\n        vec3 vFlowRateAndFoam = GetFlowRate( waterInt.m_pos.xz );\n        vec2 vFlowRate = vFlowRateAndFoam.xy;\n        #ifdef ENABLE_FOAM\n        float fFoam = vFlowRateAndFoam.z;\n        float fFoamScale = 1.5;\n        float fFoamOffset = 0.2;\n        fFoam = clamp( (fFoam - fFoamOffset) * fFoamScale, 0.0, 1.0 );\n        fFoam = fFoam * fFoam * 0.5;\n        #else\n        float fFoam = 0.0;\n        #endif            \n\n        float fWaterFoamTex = 1.0;\n        vec4 vWaterNormalAndHeight = SampleFlowingNormal( waterInt.m_pos.xz, vFlowRate, fFoam, g_fTime, fWaterFoamTex );\n        \n        if( vRayDir.y < -0.01 )\n        {\n            // lie about the water intersection depth\n            waterInt.m_dist -= (0.04 * (1.0 - vWaterNormalAndHeight.w) / vRayDir.y);\n        }\n        \n        if( waterInt.m_dist < primaryInt.m_dist )\n        {\n            fFogDistance = waterInt.m_dist;\n            vec3 vWaterNormal = vWaterNormalAndHeight.xyz;\n\n            vReflectRayOrigin = waterInt.m_pos;\n            vSpecNormal = vWaterNormal;\n\n            vec3 vRefractRayOrigin = waterInt.m_pos;\n            vec3 vRefractRayDir = refract( vRayDir, vWaterNormal, 1.0 / 1.3333 );\n\n            Intersection refractInt;\n            vec3 vRefractLight = GetRayColour( vRefractRayOrigin, vRefractRayDir, refractInt ); // note : dont need sky\n\n            float fEdgeAlpha = clamp( (1.0 + vWaterNormalAndHeight.w * 0.25) - refractInt.m_dist * 10.0, 0.0, 1.0 );\n            fFoam *= 1.0 - fEdgeAlpha;\n            \n            // add extra extinction for the light travelling to the point underwater\n            vec3 vExtinction = GetWaterExtinction( refractInt.m_dist + abs( refractInt.m_pos.y ) );\n\n            specSurface.m_pos = waterInt.m_pos;\n            specSurface.m_normal = normalize( vWaterNormal + GetSunDir() * fFoam ); // would rather have SSS for foam\n            specSurface.m_albedo = vec3(1.0);\n            specSurface.m_specR0 = vec3( 0.01, 0.01, 0.01 );\n\n            vec2 vFilterWidth = max(abs(dFdx(waterInt.m_pos.xz)), abs(dFdy(waterInt.m_pos.xz)));\n  \t\t\tfloat fFilterWidth= max(vFilterWidth.x, vFilterWidth.y);\n            float fGlossFactor = exp2( -fFilterWidth * 0.3 );\n            specSurface.m_gloss = 0.99 * fGlossFactor;            \n            specSurface.m_specScale = 1.0;\n            \n            vec3 vSurfaceDiffuse = vec3(0.0);\n\n            float fSunShadow = 1.0;\n        #ifdef ENABLE_WATER_RECEIVE_SHADOW\n            fSunShadow = GetSunShadow( waterInt.m_pos );\n        #endif\n            AddSunLight( specSurface, -vRayDir, fSunShadow, vSurfaceDiffuse, vSpecularLight);\n            AddSkyLight( specSurface, vSurfaceDiffuse, vSpecularLight);\n\n            vec3 vInscatter = vSurfaceDiffuse * (1.0 - exp( -refractInt.m_dist * 0.1 )) * (1.0 + fSunDotV);\n            vTransmitLight = vRefractLight.rgb;\n            vTransmitLight += vInscatter;\n            vTransmitLight *= vExtinction;   \n\n\n    #ifdef ENABLE_FOAM\n            float fFoamBlend = 1.0 - pow( fWaterFoamTex, fFoam * 5.0);// * (1.0 - fWaterFoamTex));\n            vTransmitLight = mix(vTransmitLight, vSurfaceDiffuse * 0.8, fFoamBlend );\n            specSurface.m_specScale = clamp(1.0 - fFoamBlend * 4.0, 0.0, 1.0);\n    #endif\n        }\n        else\n    #endif // #ifdef ENABLE_WATER\n        {\n            fFogDistance = primaryInt.m_dist;\n\n            Surface primarySurface;\n            GetSurfaceInfo( primaryInt, primarySurface );\n\n            vSpecNormal = primarySurface.m_normal;\n            vReflectRayOrigin = primaryInt.m_pos;\n            \n            float fWetness = 1.0 - clamp( (vReflectRayOrigin.y + 0.025) * 5.0, 0.0, 1.0);\n            primarySurface.m_gloss = mix( primarySurface.m_albedo.r, 1.0, fWetness );\n            primarySurface.m_albedo = mix( primarySurface.m_albedo, primarySurface.m_albedo * 0.8, fWetness );\n\n            vTransmitLight = vec3(0.0);\n            float fSunShadow = 1.0;\n       #ifdef ENABLE_LANDSCAPE_RECEIVE_SHADOW\n            fSunShadow = GetSunShadow( primaryInt.m_pos );\n       #endif\n            AddSunLight( primarySurface, -vRayDir, fSunShadow, vTransmitLight, vSpecularLight);\n            AddSkyLight( primarySurface, vTransmitLight, vSpecularLight);\n            vTransmitLight *= primarySurface.m_albedo;\n            specSurface = primarySurface;\n        }\n\n        vec3 vReflectRayDir = reflect( vRayDir, vSpecNormal );\n        vec3 vReflectLight = GetRayColour( vReflectRayOrigin, vReflectRayDir );\n\n        vReflectLight = mix( GetEnvColour(vReflectRayDir, specSurface.m_gloss), vReflectLight, pow( specSurface.m_gloss, 40.0) );\n        \n        vec3 vFresnel = GetFresnel( -vRayDir, vSpecNormal, specSurface.m_specR0, specSurface.m_gloss );\n\n        vSpecularLight += vReflectLight;\n        vResult = mix(vTransmitLight, vSpecularLight, vFresnel * specSurface.m_specScale );\n    }\n    \n    \n    if ( fFogDistance >= k_fFarClip )\n    {\n        fFogDistance = 100.0;\n        vResult = smoothstep( 0.9995, 0.9999, fSunDotV ) * g_sunColour * 200.0;\n    }    \n    \n    vec3 vFogColour = GetSkyColour(vRayDir);\n    \n    vec3 vFogExtCol = exp2( k_vFogExt * -fFogDistance );\n    vec3 vFogInCol = exp2( k_vFogIn * -fFogDistance );\n    vResult = vResult*(vFogExtCol) + vFogColour*(1.0-vFogInCol);\n    \n    return vResult;\n}\n\n// Code from https://www.shadertoy.com/view/ltlSWf \nvoid BlockRender(in vec2 fragCoord)\n{\n    const float blockRate = 15.0;\n    const float blockSize = 64.0;\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\n    // Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    g_fTime = iTime;\n\n#ifdef ENABLE_SCREENSHOT_MODE\n    BlockRender( fragCoord.xy );\n    float fBaseTime = k_screenshotTime;\n#else\n    float fBaseTime = iTime;\n#endif\n    g_fTime = fBaseTime;\n    \n    float fCameraTime = g_fTime;\n    \n\t// Static camera locations\n    //fCameraTime = 146.0; // some rocks\n    \n    vec2 vUV = fragCoord.xy / iResolution.xy;\n\n\tvec3 vCameraTarget = vec3(0.0, -0.5, 0.0);\n\n    vCameraTarget.x -= fCameraTime * 0.5;\n    \n    vec3 vCameraPos = vCameraTarget + vec3(0.0, 0.0, 0.0);\n    \n    float fHeading = fCameraTime * 0.1;\n    float fDist = 1.5 - cos(fCameraTime * 0.1 + 2.0) * 0.8;\n    \n    if( iMouse.z > 0.0 )\n    {\n        fHeading = iMouse.x * 10.0 / iResolution.x;\n        fDist = 5.0 - iMouse.y * 5.0 / iResolution.y;\n    }\n    \n    vCameraPos.y += 1.0 + fDist * fDist * 0.01;\n        \n    vCameraPos.x += sin( fHeading ) * fDist;\n    vCameraPos.z += cos( fHeading ) * fDist;\n    \n    vCameraTarget.z += GetRiverMeander( vCameraTarget.x );\n    vCameraPos.z += GetRiverMeander( vCameraPos.x );\n\n    vCameraPos.y = max( vCameraPos.y, GetTerrainHeightSimple( vCameraPos ) + 0.2 );\n    \n    vec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n#ifndef ENABLE_SUPERSAMPLE_MODE\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir);\n#else\n\tvec3 vResult = vec3(0.0);\n    float fTot = 0.0;\n    for(int i=0; i<k_superSampleCount; i++)\n    {\n        g_fTime = fBaseTime + (fTot / 10.0) / 30.0;\n        vec3 vCurrRayDir = vRayDir;\n        vec3 vRandom = vec3( SmoothNoise( fragCoord.xy + fTot ), \n                        SmoothNoise( fragCoord.yx + fTot + 42.0 ),\n                        SmoothNoise( fragCoord.xx + fragCoord.yy + fTot + 42.0 ) ) * 2.0 - 1.0;\n        vRandom = normalize( vRandom );\n        vCurrRayDir += vRandom * 0.001;\n        vCurrRayDir = normalize(vCurrRayDir);\n    \tvResult += GetSceneColour(vRayOrigin, vCurrRayDir);\n        fTot += 1.0;\n    }\n    vResult /= fTot;\n#endif    \n    \n\tvResult = ApplyVignetting( vUV, vResult );\t\n\t\n\tvec3 vFinal = Tonemap(vResult * 3.0);\n\t\n    vFinal = vFinal * 1.1 - 0.1;\n    \n\tfragColor = vec4(vFinal, 1.0);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    g_fTime = iTime;\n    \n    fragRayOri = fragRayOri.zyx;\n    fragRayDir = fragRayDir.zyx;\n    \n    fragRayOri.z *= -1.0;\n    fragRayDir.z *= -1.0;\n    \n    fragRayOri *= 0.1;\n    \n    fragRayOri.y += 0.2;\n    \n    fragRayOri.x -= g_fTime * 0.1;\n    fragRayOri.z += GetRiverMeander( fragRayOri.x );\n    \n    \n    vec3 vResult = GetSceneColour(fragRayOri, fragRayDir);\n    \n\tvec3 vFinal = Tonemap(vResult * 3.0);\n\t\n    vFinal = vFinal * 1.1 - 0.1;\n    \n\tfragColor = vec4(vFinal, 1.0);    \n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2XRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1123, 1123, 1141, 1141, 1174], [1614, 1614, 1638, 1698, 1837], [1839, 1839, 1863, 1923, 2051], [2053, 2053, 2084, 2084, 2440], [2442, 2442, 2473, 2473, 2688], [2690, 2690, 2728, 2728, 2934], [2936, 2936, 2970, 2970, 3496], [3498, 3498, 3553, 3553, 3941], [3943, 3943, 3983, 3983, 4016], [4018, 4018, 4060, 4060, 4099], [4101, 4101, 4145, 4145, 4471], [4473, 4473, 4516, 4516, 4702], [4704, 4704, 4753, 4753, 4946], [4949, 4949, 4992, 4992, 5040], [5042, 5042, 5084, 5084, 5153], [5155, 5155, 5192, 5192, 5245], [5247, 5247, 5284, 5284, 5529], [5531, 5531, 5568, 5568, 6642], [6644, 6644, 6723, 6723, 7296], [7298, 7298, 7364, 7364, 7532], [7539, 7539, 7665, 7665, 8552], [9338, 9338, 9362, 9362, 9532], [9617, 9617, 9701, 9701, 11384], [12089, 12089, 12170, 12170, 12392], [13068, 13068, 13139, 13139, 14329], [14334, 14334, 14368, 14368, 14418], [14420, 14420, 14459, 14459, 14782], [14784, 14784, 14909, 14909, 15709], [15715, 15715, 15792, 15792, 15911], [15913, 15913, 15982, 15982, 16122], [16124, 16124, 16163, 16163, 16355], [16357, 16357, 16392, 16392, 16697], [16699, 16699, 16748, 16748, 16864], [23566, 23618, 23655, 23655, 24296], [24298, 24298, 24355, 24355, 26507], [26509, 26509, 26603, 26603, 27094]], "test": "error"}
{"id": "Xl2XW1", "name": "Raytracer PBR study", "author": "valentingalea", "description": "yet another raytracer", "tags": ["raytrace", "pbr"], "likes": 6, "viewed": 563, "published": "Public", "date": "1443356952", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ----------------------------------------------------------------------------\n// https://github.com/valentingalea/shaderbox\n// ----------------------------------------------------------------------------\n\n// GLSL/C++ compatibility layer\n#ifdef __cplusplus\n#define _in(T) const T &\n#define _inout(T) T &\n#define _out(T) T &\n#define _begin {\n#define _end }\n#else\n#define _in(T) const in T\n#define _inout(T) inout T\n#define _out(T) out T\n#define _begin (\n#define _end )\n#endif\n\n#define PI 3.14159265359\n\n// Shadertoy specific uniforms\n#define u_res iResolution\n#define u_time iTime\n#define u_mouse iMouse\n\nstruct ray_t {\n\tvec3 origin;\n\tvec3 direction;\n};\n#define BIAS 1e-4 // small offset to avoid self-intersections\n\nstruct hit_t {\n\tfloat t;\n\tint material_id;\n\tfloat material_param;\n\tvec3 normal;\n\tvec3 origin;\n};\n#define max_dist 1e8 // TODO: precision issues\nhit_t no_hit = hit_t _begin\n\t(max_dist + 1e1), -1, 1., vec3(0), vec3(0)\n_end;\n\n// camera system\nvec3 eye, look_at;\n\n// ----------------------------------------------------------------------------\n// Various 3D utilities functions\n// ----------------------------------------------------------------------------\n\nmat3 rotate_around_z(_in(float) angle_degrees)\n{\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, -_sin, 0, _sin, _cos, 0, 0, 0, 1);\n}\n\nmat3 rotate_around_y(_in(float) angle_degrees)\n{\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, 0, _sin, 0, 1, 0, -_sin, 0, _cos);\n}\n\nmat3 rotate_around_x(_in(float) angle_degrees)\n{\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(1, 0, 0, 0, _cos, -_sin, 0, _sin, _cos);\n}\n\nvec3 corect_gamma(_in(vec3) color, _in(float) gamma)\n{\n\tfloat p = 1.0 / gamma;\n\treturn vec3(pow(color.r, p), pow(color.g, p), pow(color.b, p));\n}\n\n// ----------------------------------------------------------------------------\n// Optics related utility functions\n// ----------------------------------------------------------------------------\n\nfloat fresnel_factor( // using Schlicks approximation\n\t_in(float) n1,\n\t_in(float) n2,\n\t_in(float) VdotH // angle between View and half-dir between Light and View\n){  \n\tfloat Rn = (n1 - n2) / (n1 + n2);\n\tfloat R0 = Rn * Rn; // reflection coeff. for light incoming parallel to the normal\n\tfloat F = 1. - VdotH;\n\treturn R0 + (1. - R0) * (F * F * F * F * F);\n}\n\n// ----------------------------------------------------------------------------\n// Materials system definitions\n// ----------------------------------------------------------------------------\n\nstruct material_t {\n\tvec3 base_color;\n\tfloat metallic;\n\tfloat roughness;\n\tfloat ior; // index of refraction\n\tfloat reflectivity;\n\tfloat translucency;\n};\n\n#define num_materials 8\n#define mat_invalid -1\n#define mat_debug 0\nmaterial_t materials[num_materials];\n\nmaterial_t get_material(\n\t_in(int) index\n){\n\tmaterial_t mat;\n\n\tfor (int i = 0; i < num_materials; ++i) {\n\t\tif (i == index) {\n\t\t\tmat = materials[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn mat;\n}\n\n// ----------------------------------------------------------------------------\n// Lighting models\n// ----------------------------------------------------------------------------\n\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nstruct light_t {\n\tint type;\n\tvec3 L; // origin for point lights, direction otherwise\n\tvec3 color;\n};\n\nlight_t lights[8];\n\nvec3 ambient_light = vec3(.01, .01, .01);\n\nvec3 get_light_direction(\n\t_in(light_t) light,\n\t_in(hit_t) point\n){\n\tif (light.type == LIGHT_DIR) {\n\t\treturn light.L;\n\t} else {\n\t\treturn normalize(light.L - point.origin);\n\t}\n}\n\n//     R       V    N    H      L         L dir to light       \n//      ^      ^    ^    ^     ^          V dir to eye\n//        .     \\   |   /    .            N normal\n//          .    \\  |  /   .              H half between L and V\n//            .   \\ | /  .                R reflected\n//  n1          .  \\|/ .                  O hit point             \n// -----------------O----------------     T refracted\n//  n2             .                      n1 index of refraction of outgoing medium\n//                .                       n2 index of refraction of incoming medium\n//               .\n//              .\n//             .\n//           \\/_ T\n//\n\nvec3 illum_blinn_phong(\n\t_in(vec3) V,\n\t_in(vec3) L,\n\t_in(hit_t) hit,\n\t_in(material_t) mat\n){\n\tvec3 diffuse = max(0., dot(L, hit.normal)) * (mat.base_color * hit.material_param);\n\n\tfloat spec_factor = 50.;\n#if 0 // Blinn specular\n\tvec3 H = normalize(L + V);\n\tvec3 specular = pow(max(0., dot(H, hit.normal)), spec_factor); // * light.color * specular color\n#else // Phong specular\n\tvec3 R = reflect(-L, hit.normal);\n\tvec3 specular = pow(max(0., dot(R, V)), spec_factor) * vec3(1); // * light.color * specular color\n#endif\n\n\treturn diffuse + specular;\n}\n\nvec3 illum_cook_torrance(\n\t_in(vec3) V,\n\t_in(vec3) L,\n\t_in(hit_t) hit,\n\t_in(material_t) mat\n){\n\tvec3 H = normalize(L + V);\n\tfloat NdotL = dot(hit.normal, L);\n\tfloat NdotH = dot(hit.normal, H);\n\tfloat NdotV = dot(hit.normal, V);\n\tfloat VdotH = dot(V, H);\n\n\t// geometric term\n\tfloat geo_a = (2. * NdotH * NdotV) / VdotH;\n\tfloat geo_b = (2. * NdotH * NdotL) / VdotH;\n\tfloat geo_term = min(1., min(geo_a, geo_b));\n\n\t// roughness term -using Beckmann Distribution\n\tfloat rough_sq = mat.roughness * mat.roughness;\n\tfloat rough_a = 1. / (rough_sq * NdotH * NdotH * NdotH * NdotH);\n\tfloat rough_exp = (NdotH * NdotH - 1.) / (rough_sq * NdotH * NdotH);\n\tfloat rough_term = rough_a * exp(rough_exp);\n\n\t// Fresnel term\n\tfloat fresnel_term = fresnel_factor(1., mat.ior, VdotH);\n\n\tfloat specular = (geo_term * rough_term * fresnel_term) / (PI * NdotV * NdotL);\n\treturn max(0., NdotL) * (specular + (mat.base_color * hit.material_param));\n}\n\n// ----------------------------------------------------------------------------\n// Analytical surface-ray intersection routines\n// ----------------------------------------------------------------------------\n\nstruct sphere_t {\n\tvec3 origin;\n\tfloat radius;\n\tint material;\n};\n\nstruct plane_t {\n\tvec3 direction;\n\tfloat distance;\n\tint material;\n};\n\nvoid intersect_sphere(\n\t_in(ray_t) ray,\n\t_in(sphere_t) sphere,\n\t_inout(hit_t) hit\n){\n\t// geometrical solution\n\t// info: http://www.scratchapixel.com/old/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/\n\tvec3 rc = sphere.origin - ray.origin;\n\tfloat radius2 = sphere.radius * sphere.radius;\n\tfloat tca = dot(rc, ray.direction);\n\tif (tca < 0.) return;\n\tfloat d2 = dot(rc, rc) - tca * tca;\n\tfloat thc = sqrt(radius2 - d2);\n\tfloat t0 = tca - thc;\n\tfloat t1 = tca + thc;\n\n\tif (t0 < hit.t) {\n\t\tvec3 impact = ray.origin + ray.direction * t0;\n\n\t\thit.t = t0;\n\t\thit.material_id = sphere.material;\n\t\thit.material_param = 1.;\n\t\thit.origin = impact;\n\t\thit.normal = (impact - sphere.origin) / sphere.radius;\n\t}\n}\n\n// Plane is define by normal N and distance to origin P0 (which is on the plane itself)\n// a plane eq is: (P - P0) dot N = 0\n// which means that any line on the plane is perpendicular to the plane normal\n// a ray eq: P = O + t*D\n// substitution and solving for t gives:\n// t = ((P0 - O) dot N) / (N dot D)\nvoid intersect_plane(\n\t_in(ray_t) ray,\n\t_in(plane_t) p,\n\t_inout(hit_t) hit\n){\n\tfloat denom = dot(p.direction, ray.direction);\n\tif (denom > 1e-6)\n\t{\n\t\tfloat t = dot(vec3(p.distance) - ray.origin, p.direction) / denom;\n\t\tif (t >= 0.0 && t < hit.t)\n\t\t{\n\t\t\tvec3 impact = ray.origin + ray.direction * t;\n\n\t\t\t// checkboard pattern\t\t\t\n\t\t\t//vec2 pattern = floor (impact.xz * 0.5);\n\t\t\t//float cb = mod (pattern.x + pattern.y, 2.0);\n\n\t\t\thit.t = t;\n\t\t\thit.material_id = p.material;\n\t\t\thit.material_param = 1.; // cb; // Disabled for now\n\t\t\thit.origin = impact;\n\t\t\thit.normal = faceforward(p.direction, ray.direction, p.direction);\n\t\t}\n\t}\n}\n\n// ----------------------------------------------------------------------------\n// Raytracer\n// ----------------------------------------------------------------------------\n\n#define num_planes 6\nplane_t planes[num_planes];\n\n#define num_spheres 3\nsphere_t spheres[num_spheres];\n\nvec3 background(_in(ray_t) ray)\n{\n\treturn vec3(0);\n}\n\n// ----------------------------------------------------------------------------\n// Cornell Box definition\n// http://www.graphics.cornell.edu/online/box/\n// ----------------------------------------------------------------------------\n\nvoid setup_cornell_box()\n{\n#define cb_mat_white 1\n#define cb_mat_red 2\n#define cb_mat_blue 3\n#define cb_mat_reflect 4\n#define cb_mat_refract 5\n#define cb_mat_green 6\n\tmaterials[cb_mat_white] = material_t _begin\n\t\tvec3(0.7913), .0, .5, 1., 0., 0.\n\t_end;\n\tmaterials[cb_mat_red] = material_t _begin\n\t\tvec3(0.6795, 0.0612, 0.0529),\n\t\t0., .5, 1., 0., 0.\n\t_end;\n\tmaterials[cb_mat_blue] = material_t _begin\n\t\tvec3(0.1878, 0.1274, 0.4287),\n\t\t0., .5, 1., 0., 0.\n\t_end;\n\tmaterials[cb_mat_reflect] = material_t _begin\n\t\tvec3(0.95, 0.64, 0.54),\n\t\t1., .1, 1.0, 1., 0.\n\t_end;\n\tmaterials[cb_mat_refract] = material_t _begin\n\t\tvec3(1., 0.77, 0.345),\n\t\t1., .05, 1.333, 1., 1.\n\t_end;\n\n#define cb_plane_ground 0\n#define cb_plane_behind 1\n#define cb_plane_front 2\n#define cb_plane_ceiling 3\n#define cb_plane_left 4\n#define cb_plane_right 5\n#define cb_plane_dist 2.\n\tplanes[cb_plane_ground] = plane_t _begin vec3(0, -1, 0), 0., cb_mat_white _end;\n\tplanes[cb_plane_ceiling] = plane_t _begin vec3(0, 1, 0), 2. * cb_plane_dist, cb_mat_white _end;\n\tplanes[cb_plane_behind] = plane_t _begin vec3(0, 0, -1), -cb_plane_dist, cb_mat_white _end;\n\tplanes[cb_plane_front] = plane_t _begin vec3(0, 0, 1), cb_plane_dist, cb_mat_white _end;\n\tplanes[cb_plane_left] = plane_t _begin vec3(1, 0, 0), cb_plane_dist, cb_mat_red _end;\n\tplanes[cb_plane_right] = plane_t _begin vec3(-1, 0, 0), -cb_plane_dist, cb_mat_blue _end;\n\n#define cb_sphere_light 0\n#define cb_sphere_left 1\n#define cb_sphere_right 2\n\tspheres[cb_sphere_light] = sphere_t _begin vec3(0, 2.5 * cb_plane_dist + 0.4, 0), 1.5, mat_debug _end;\n\tspheres[cb_sphere_left] = sphere_t _begin vec3(0.75, 1, -0.75), 0.75, cb_mat_reflect _end;\n\tspheres[cb_sphere_right] = sphere_t _begin vec3(-0.75, 0.75, 0.75), 0.75, cb_mat_refract _end;\n\n\tlights[0] = light_t _begin\n\t\tLIGHT_POINT,\n\t\tvec3(0, 2. * cb_plane_dist - 0.2, 0),\n\t\tvec3(1., 1., 1.)\n\t_end;\n}\n\nvoid setup_scene()\n{\n\tmaterials[mat_debug] = material_t _begin vec3(1., 1., 1.), 0., 0., 1., 0., 0. _end;\n\n\tsetup_cornell_box();\n\n#if 1\n\tfloat _sin = sin(u_time);\n\tfloat _cos = cos(u_time);\n\tspheres[cb_sphere_left].origin += vec3(0, abs(_sin), _cos + 1.);\n\tspheres[cb_sphere_right].origin.z = 0.;// += vec3(0, abs(_cos), _cos);\n\tlights[0].L.z = 1.5;\n#endif\n}\n\nvoid setup_camera(_inout(vec3) eye, _inout(vec3) look_at)\n{\n\tvec2 mouse = u_mouse.x < BIAS ? vec2(0) : 2. * (u_res.xy / u_mouse.xy) - 1.;\n\tmat3 rot_y = rotate_around_y(mouse.x * 30.);\n\teye = rot_y * vec3(0, cb_plane_dist, 2.333 * cb_plane_dist);\n\tlook_at = vec3(0, cb_plane_dist, 0);\n}\n\nvec3 illuminate(_in(hit_t) hit) // TODO: find a way to account for more light types\n{\n\tmaterial_t mat = get_material(hit.material_id);\n\n\t// special case for debug stuff - just solid paint it\n\tif (hit.material_id == mat_debug) {\n\t\treturn materials[mat_debug].base_color;\n\t}\n\n\tvec3 accum = ambient_light; // really cheap equivalent for indirect light\n\n\tvec3 V = normalize(eye - hit.origin); // view direction\n\tvec3 L = get_light_direction(lights[0], hit);\n\n\t// TODO: more lights\n#if 0\n\t\taccum += illum_blinn_phong(V, L, hit, mat);\n#else\n\t\taccum += illum_cook_torrance(V, L, hit, mat);\n#endif\n\n\treturn accum;\n}\n\nhit_t raytrace_iteration(_in(ray_t) ray, _in(int) mat_to_ignore)\n{\n\thit_t hit = no_hit;\n\n\tfor (int i = 0; i < num_planes; ++i) {\n\t\tintersect_plane(ray, planes[i], hit);\n\t}\n\n\tfor (int i = 0; i < num_spheres; ++i) {\n\t\tif (spheres[i].material != mat_to_ignore) {\n\t\t\tintersect_sphere(ray, spheres[i], hit);\n\t\t}\n\t}\n\n\treturn hit;\n}\n\nvec3 render(_in(ray_t) primary_ray)\n{\n\tvec3 color = vec3(0);\n\tvec3 accum = vec3(1);\n\tray_t ray = primary_ray;\n\n\tfor (int i = 0; i < 2; i++) {\n\t\thit_t hit = raytrace_iteration(ray, mat_invalid);\n\n\t\tif (hit.t >= max_dist) {\n\t\t\tcolor += accum * background(ray);\n\t\t\tbreak;\n\t\t}\n\n\t\tfloat f = fresnel_factor(1., 1., dot(hit.normal, -ray.direction));\n\t\tcolor += (1. - f) * accum * illuminate(hit);\n\n#if 1 // shadow ray\n\t\tif (i == 0) {\n\t\t\tvec3 shadow_line = lights[0].L - hit.origin; // TODO: more light types\n\t\t\tvec3 shadow_dir = normalize(shadow_line);\n\n\t\t\tray_t shadow_trace = ray_t _begin\n\t\t\t\thit.origin + shadow_dir * BIAS,\n\t\t\t\tshadow_dir\n\t\t\t\t_end;\n\t\t\thit_t shadow_hit = raytrace_iteration(shadow_trace, mat_debug);\n\n\t\t\tif (shadow_hit.t < length(shadow_line)) {\n\t\t\t\tcolor *= 0.1;\n\t\t\t}\n\t\t}\n#endif\n\n\t\tmaterial_t mat = get_material(hit.material_id);\n\t\tif (mat.reflectivity > 0.) {\n\t\t\taccum *= f;\n\t\t\tvec3 reflect_dir = normalize(reflect(hit.normal, ray.direction));\n\t\t\tray = ray_t _begin\n\t\t\t\thit.origin + reflect_dir * BIAS,\n\t\t\t\treflect_dir\n\t\t\t_end;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn color;\n}\n\n// ----------------------------------------------------------------------------\n// Main Rendering function\n// ----------------------------------------------------------------------------\n\nray_t get_primary_ray(\n\t_in(vec3) cam_local_point,\n\t_inout(vec3) cam_origin,\n\t_inout(vec3) cam_look_at\n){\n\tvec3 fwd = normalize(cam_look_at - cam_origin);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 right = cross(up, fwd);\n\tup = cross(fwd, right);\n\n\treturn ray_t _begin\n\t\tcam_origin,\n\t\tnormalize(fwd + up * cam_local_point.y + right * cam_local_point.x)\n\t_end;\n}\n\nvoid mainImage(\n\t_out(vec4) fragColor,\n\tvec2 fragCoord)\n{\n\t// The pipeline transform\n\t//\n\t// 1. fragCoord is in raster space [0..resolution]\n\t// 2. convert to NDC [0..1] by dividing to the resolution\n\t// 3. convert to camera space:\n\t//  a. xy gets [-1, +1] by 2 * NDC - 1; z fixed at -1\n\t//  c. apply aspect & fov\n\t//  d. apply the look-at algoritm which will\n\t//     produce the 3 camera axis:\n\t//\n\t//      R   ^ +Y                  ^ +Y             E eye/ray origin\n\t//       .  |\\                    |     . R        R primary ray\n\t//         .| \\                   |   .            @ fov angle\n\t//   -Z     | .\\   +Z             | .\n\t//    ------0---E--->   +X -------0-------> -X\n\t//          | @/                  |\n\t//          | /                   |\n\t//          |/                    | -Y\n\t//           -Y\n\t//\n\t// NOTE: everything is expressed in this space, NOT world\n\n\t// assuming screen width is larger than height \n\tvec2 aspect_ratio = vec2(u_res.x / u_res.y, 1);\n\t// field of view\n\tfloat fov = tan(radians(30.0));\n\n\t// antialising\n#if 0\n#define MSAA_PASSES 4\n\tfloat offset = 0.25;\n\tfloat ofst_x = offset * aspect_ratio.x;\n\tfloat ofst_y = offset;\n\tvec2 msaa[MSAA_PASSES];\n\tmsaa[0] = vec2(-ofst_x, -ofst_y);\n\tmsaa[1] = vec2(-ofst_x, +ofst_y);\n\tmsaa[2] = vec2(+ofst_x, -ofst_y);\n\tmsaa[3] = vec2(+ofst_x, +ofst_y);\n#else\n#define MSAA_PASSES 1\n\tvec2 msaa[MSAA_PASSES];\n\tmsaa[0] = vec2(0.5);\n#endif\n\n\tvec3 color = vec3(0);\n\n\tsetup_camera(eye, look_at);\n\n\tsetup_scene();\n\n\tfor (int i = 0; i < MSAA_PASSES; i++) {\n\t\tvec2 point_ndc = (fragCoord.xy + msaa[i]) / u_res.xy;\n\t\tvec3 point_cam = vec3(\n\t\t\t(2.0 * point_ndc - 1.0) * aspect_ratio * fov,\n\t\t\t-1.0);\n\n\t\tray_t ray = get_primary_ray(point_cam, eye, look_at);\n\n\t\tcolor += render(ray) / float(MSAA_PASSES);\n\t}\n\n\tfragColor = vec4(corect_gamma(color, 2.25), 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2XW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1172, 1172, 1220, 1220, 1367], [1369, 1369, 1417, 1417, 1564], [1566, 1566, 1614, 1614, 1761], [1763, 1763, 1817, 1817, 1908], [2107, 2107, 2279, 2279, 2471], [2925, 2925, 2968, 2968, 3105], [3495, 3495, 3562, 3562, 3671], [4328, 4328, 4420, 4420, 4878], [4880, 4880, 4974, 4974, 5806], [6153, 6153, 6237, 6391, 6887], [6889, 7195, 7272, 7272, 7823], [8103, 8103, 8136, 8136, 8155], [10618, 10618, 10677, 10677, 10903], [10905, 10905, 10990, 10990, 11512], [11514, 11514, 11580, 11580, 11839], [13470, 13470, 13527, 14398, 15288]], "test": "error"}
{"id": "XlBSWR", "name": "CheapOcclusionAndNormals", "author": "FatumR", "description": "The reworked version of this shader: https://www.shadertoy.com/view/MsBXWy\nThe main idea is to use derivative of noise function.\nRun in Fullscreen to avoid sepia blinking.", "tags": ["procedural", "3d", "raymarching", "fractal", "terrain", "fullscreen", "derivative"], "likes": 8, "viewed": 1103, "published": "Public", "date": "1442948600", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define OCTAVES  8\n\n#define MAX_STEPS  32\n#define THRESHOLD .01\n\nconst float fogDensity = 0.25;\n\nfloat rand(vec2 co){\n   return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand2(vec2 co){\n   return fract(cos(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat interFunc1(float t) {\n   return t * t * (3. - 2. * t);\n}\n\nfloat interFunc2(float t) {\n    return (6.* t * t - 15. * t + 10.) * t * t * t;\n}\n\n\nfloat valueNoiseSimple(vec2 vl, out vec4 der) {\n   const vec2 minStep = vec2(1., 0. );\n\n   vec2 grid = floor(vl);\n\n    float s = rand2(grid);\n    float t = rand2(grid + minStep);\n    float u = rand2(grid + minStep.yx);\n    float v = rand2(grid + minStep.xx);\n    \n    float fractX = fract(vl.x);\n    float x1 = interFunc2(fractX);\n    \n    float fractY = fract(vl.y);\n    float y = interFunc2(fractY);\n    \n    float k3 = s - t - u + v;\n    float k2 = t - s;\n    float k1 = u - s;\n    \n    float interpY = s + k2 * x1  + k1 * y + k3 * x1 * y;\n    \n    /* Inspired by https://www.iquilezles.org/www/articles/morenoise/morenoise.htm */\n    \n    der.z = (k2 + k3 * y) * (120.0 * fractX * fractX - 180.0 * fractX + 60.) * fractX;\n    der.w = (k1 + k3 * x1) * (120.0 * fractY * fractY - 180.0 * fractY + 60.) * fractY;\n    \n    der.x = (k2 + k3 * y) * (30.0 * fractX * fractX - 60.0 * fractX + 30.) * fractX * fractX;\n    der.y = (k1 + k3 * x1) * (30.0 * fractY * fractY - 60.0 * fractY + 30.) * fractY * fractY;\n    \n    return interpY;//s + k2 * x1  + k1 * y + k3 * x1 * y;\n}\n\nfloat fractalNoise(vec2 vl, out vec4 der) {\n    float persistance = 2.;\n    float amplitude = 1.2;\n    float rez = 0.0;\n    vec2 p = vl;\n    vec4 temp;\n    float norm = 0.;\n    der = vec4(0.);\n    for (int i = 0; i < OCTAVES + 2; i++) {\n        norm += amplitude;\n        rez += amplitude * valueNoiseSimple(p, temp);\n        // to use as normals, we need to take into account whole length,\n        // we can either normalize vector here or don't apply the amplitude\n        der += temp;\n        amplitude /= persistance;\n        p *= persistance;\n    }\n    return rez / norm;\n}\n\nfloat scene(vec3 a, out vec4 der) {\n   float zVal = fractalNoise(vec2(a.x- 5., a.z ), der);\n   \n   der.zw = -sin(zVal) * der.zw / 4.;\n   der.xy = cos(zVal) * der.xy / 2.;\n   \n   return a.y + 0.2 + sin(zVal * 1.5);\n}\n\nfloat valueNoiseSimpleLow(vec2 vl) {\n\n   const vec2 helper = vec2(0., 1.);\n    vec2 interp = smoothstep(vec2(0.), vec2(1.), fract(vl));\n    vec2 grid = floor(vl);\n\n    return mix(mix(rand2(grid + helper.xx),\n                   rand2(grid + helper.yx),\n                   interp.x),\n               mix(rand2(grid + helper.xy),\n                   rand2(grid + helper.yy),\n                   interp.x),\n               interp.y);\n}\n\nfloat fractalNoiseLow(vec2 vl) {\n    float persistance = 2.;\n    float amplitude = 1.2;\n    float rez = 0.0;\n    vec2 p = vl;\n    float norm = 0.0;\n    for (int i = 0; i < OCTAVES - 3; i++) {\n        norm += amplitude;\n        rez += amplitude * valueNoiseSimpleLow(p);\n        amplitude /= persistance;\n        p *= persistance;\n    }\n    return rez / norm;\n}\n\nfloat sceneLow(vec3 a) {\n   float zVal = fractalNoiseLow(vec2(a.x- 5., a.z ));  \n   return a.y + 0.2 + sin(zVal * 1.5);\n}\n\n\nfloat trace(vec3 O, vec3 D, out float hill) {\n    float L = 0.;\n    float d = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        d = sceneLow(O + D*L);\n        L += d * clamp(L * .6, 0.45, .8);\n        \n        if (d < THRESHOLD*L)\n            break;\n    }\n    \n    hill = d;\n    return L;\n}\n\n/* Based on http://iquilezles.org/www/articles/rmshadows/rmshadows.htm */\nfloat shadow(vec3 O, vec3 D) {\n    float shaded = 1.;\n    \n    float L = 0.;\n    float d = 0.;\n    \n    for (int i = 1; i < MAX_STEPS / 3; ++i) {\n        d = sceneLow(O + D*L);\n        L += d * clamp(L * .6, 0.45, .8);\n        \n        if (d < THRESHOLD*L)\n            return 0.;\n        \n        shaded = min(shaded, 2. * d / L);\n    }\n    \n    return shaded;\n}\n\n// Cheap occlusion, based on second derivative\nfloat occlusion2(vec4 der) {\n    return pow(clamp(-(der.w + der.z)*0.5, -.5, .5) + .5, 2.);\n}\n\nvec3 enlight(vec3 p, vec3 normal, vec3 eye, vec3 lightPos, vec4 der) {\n    vec3 dir = lightPos - p;\n    vec3 eyeDir = eye - p;\n    vec3 I = normalize(dir);\n    vec3 color = texture(iChannel0, p.xz *.5 + .5).rgb;\n    \n    vec3 ambient = color * 0.75;\n    vec3 diffuse = max(dot(normal, I), 0.) * color.rgb;\n\n    diffuse = clamp(diffuse, 0., 1.) * 0.75;\n\n    vec3 refl = normalize(-reflect(I, normal));\n    float spec = max(dot(refl, normalize(eyeDir)), 0.);\n    \n    spec = pow(spec, .3 * 60.);\n    spec = clamp(spec, 0., 1.);\n    \n    vec3 Ispec = spec * vec3(1.0, 1.0, .9);\n    \n    float shade = 1.0;//shadow(p + vec3(0., 0.008, 0.), lightPos);\n    \n    return (Ispec + diffuse) * shade + ambient * occlusion2(der);\n    //return vec3(occlusion2(der));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 temp;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 centered_uv = uv * 2. - 1.;\n    centered_uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 sunPos = vec2(.845 * iResolution.x / iResolution.y, .2);\n\n    float timeOffset = iTime / 5.;\n    \n    vec3 O = vec3(0., 0.1, 1. - timeOffset);\n    float h = scene(O, temp) * 0.65;\n    O.y -= h;\n    \n    vec3 D = normalize(vec3(centered_uv, -1.0)); //fov\n\n    float hill;\n    float path = trace(O, D, hill);\n    vec3 coord = O + path * D;\n\n    vec3 resColor;\n    vec3 skyBlueColor = vec3(0.529411765, 0.807843137, 0.980392157); \n    vec3 sunColor = vec3(1.0, 1.0, .975);\n    vec3 sunGalo = vec3(.7, .7, .5);\n\n    // Background color\n    vec3 bgColor = mix(vec3(1.), skyBlueColor, clamp(centered_uv.y, 0., 1.));\n    float sunDst = length(centered_uv - sunPos) ;\n    float sunFluctuation = valueNoiseSimple(centered_uv - sunPos + timeOffset, temp);\n    sunFluctuation = clamp(sunFluctuation * .25, 0.1, .2);\n    \n    float galoVal= exp(-pow(sunDst * 0.35, 1.15));\n    float val  = clamp(1. / (sunDst *110.5), 0., 1.);\n    \n    bgColor = mix(bgColor, sunColor*val + (galoVal + sunFluctuation) * sunGalo, galoVal + .5);\n    \n    if (hill >= 0.5) {\n        float cloudCeil = centered_uv.y * .5 - .085;\n        vec2 cloudCoord = centered_uv / cloudCeil;\n        cloudCoord.y += timeOffset / 4.;\n        cloudCoord.x /= pow(iResolution.x / iResolution.y, 3.5);\n        float cloudNoise = 1. * fractalNoiseLow(cloudCoord + 3.5);\n        resColor = (bgColor + clamp(cloudNoise, 0., 1.) );\n        resColor = mix(bgColor, resColor, clamp(cloudCeil, 0., 1.));\n    } else {\n        vec3 lightPos = vec3(5., 3. -h, -2. - timeOffset);\n        vec4 der;\n        scene(coord, der);\n        // Cheap normal, based on first derivative\n        vec3 normal = normalize(vec3(der.x, 1., der.y ));\n        \n        resColor = enlight(coord, normal, O, lightPos, der);\n    \n\n    \tfloat fogFactor = exp(-pow(abs(fogDensity * (coord.z - 1.75 + timeOffset)), 3.0));\n    \tfogFactor = clamp(fogFactor, 0.0, 1.0);\n    \tresColor = mix(bgColor, resColor, fogFactor);\n    }\n\n    fragColor = vec4(resColor, 1.);\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBSWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 117, 117, 188], [190, 190, 211, 211, 282], [284, 284, 311, 311, 346], [348, 348, 375, 375, 429], [432, 432, 479, 479, 1504], [1506, 1506, 1549, 1549, 2084], [2086, 2086, 2121, 2121, 2301], [2303, 2303, 2339, 2339, 2730], [2732, 2732, 2764, 2764, 3092], [3094, 3094, 3118, 3118, 3215], [3218, 3218, 3263, 3263, 3517], [3519, 3593, 3623, 3623, 3955], [3957, 4004, 4032, 4032, 4097], [4099, 4099, 4169, 4169, 4854], [4856, 4856, 4913, 4913, 7055]], "test": "error"}
{"id": "XlBSzm", "name": "Voidless", "author": "shezard", "description": "A simple test on pseudo kaleidoscopic scene", "tags": ["2d", "fbm"], "likes": 7, "viewed": 244, "published": "Public", "date": "1442345113", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nmat2 rotate(in float theta) {\n    return mat2(\n    \tcos(theta), -sin(theta), sin(theta), cos(theta)\n    );\n}\n\nfloat noise(in vec2 uv) {\n\treturn sin(1.5*uv.x)*sin(1.5*uv.y);\n}\n\nfloat fbm(vec2 uv) {\n    float f = 0.0;\n    f += 0.5000*noise(uv); uv = m*uv*2.02;\n    f += 0.2500*noise(uv); uv = m*uv*2.03;\n    f += 0.1250*noise(uv); uv = m*uv*2.01;\n    f += 0.0625*noise(uv);\n    return f/0.9375;\n}\n\nfloat fbm2(in vec2 uv) {\n   vec2 p = vec2(fbm(uv + vec2(0.0,0.0)),\n                 fbm(uv + vec2(5.2,1.3)));\n\n   return fbm(uv + 4.0*p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = -1.0 + 2.*uv;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    float h = length((.5 + .5*cos(uv+vec2(\n        iTime, .0\n    ))));\n    \n    vec3 m = vec3(\n        .75 + .25 * sin(iTime),\n        1.0 + uv.y * (.75 + .25 * cos(iTime)),\n        1.0 * noise(uv + vec2(.0, iTime * 2.0))\n    );\n    \n    float theta = iTime * .8;\n    \n    vec2 p = uv * rotate(theta);\n    \n    p = abs(p);\n    vec3 c = h * m * (fbm2(\n        p + iTime * .6\n    ) + fbm2(\n        2.0 * p + iTime * .3\n    ));\n    \n    c = clamp(c, 0.0, 1.0);\n    \n\tfragColor = vec4(c*c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBSzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 81, 81, 160], [162, 162, 187, 187, 226], [228, 228, 248, 248, 446], [448, 448, 472, 472, 587], [589, 589, 646, 646, 1266]], "test": "valid"}
{"id": "XlBXDh", "name": "Fans 2D - pii", "author": "public_int_i", "description": "fans 2d", "tags": ["2d", "fans"], "likes": 0, "viewed": 116, "published": "Public", "date": "1443104266", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst int iterations = 4;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n\t\n\tfloat d = 0.;\n    for (int i = 0; i < iterations; i++) {\n        float wdth = float(i)*.5+1.;\n        d += (\n                (mod(abs(atan(uv.y,uv.x))*6.+iTime*wdth,wdth)-wdth/2.)/(1.+length(uv)));\n    }\n    \n    d = abs(d)/float(iterations);\n    fragColor = vec4(d,d,d,1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBXDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 85, 85, 417]], "test": "valid"}
{"id": "XljGzV", "name": "HSL to RGB to HSL", "author": "anastadunbar", "description": "HSL GLSL function. Functions not made by me, but are useful.", "tags": ["test", "rainbow", "function", "hsl"], "likes": 15, "viewed": 4892, "published": "Public", "date": "1442603733", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 HueShift (in vec3 Color, in float Shift)\n{\n    vec3 P = vec3(0.55735)*dot(vec3(0.55735),Color);\n    \n    vec3 U = Color-P;\n    \n    vec3 V = cross(vec3(0.55735),U);    \n\n    Color = U*cos(Shift*6.2832) + V*sin(Shift*6.2832) + P;\n    \n    return vec3(Color);\n}\n\nvec3 rgb2hsl( in vec3 c ){\n  float h = 0.0;\n\tfloat s = 0.0;\n\tfloat l = 0.0;\n\tfloat r = c.r;\n\tfloat g = c.g;\n\tfloat b = c.b;\n\tfloat cMin = min( r, min( g, b ) );\n\tfloat cMax = max( r, max( g, b ) );\n\n\tl = ( cMax + cMin ) / 2.0;\n\tif ( cMax > cMin ) {\n\t\tfloat cDelta = cMax - cMin;\n        \n        //s = l < .05 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) ); Original\n\t\ts = l < .0 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) );\n        \n\t\tif ( r == cMax ) {\n\t\t\th = ( g - b ) / cDelta;\n\t\t} else if ( g == cMax ) {\n\t\t\th = 2.0 + ( b - r ) / cDelta;\n\t\t} else {\n\t\t\th = 4.0 + ( r - g ) / cDelta;\n\t\t}\n\n\t\tif ( h < 0.0) {\n\t\t\th += 6.0;\n\t\t}\n\t\th = h / 6.0;\n\t}\n\treturn vec3( h, s, l );\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float sintime = (sin(time)/2.)+0.5;\n    vec3 rainbow = hsl2rgb( vec3(uv.x+time,sintime,uv.y) );\n    rainbow = rgb2hsl(rainbow);\n    rainbow = hsl2rgb(rainbow);\n\tfragColor = vec4(rainbow,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljGzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 170], [172, 172, 219, 219, 436], [438, 438, 464, 464, 1146], [1148, 1148, 1170, 1170, 1501], [1503, 1503, 1525, 1525, 1694], [1696, 1696, 1753, 1753, 2017]], "test": "valid"}
{"id": "XljSRz", "name": "Red Cogs", "author": "twernmilt", "description": "Inspired by https://www.shadertoy.com/view/4t23RR", "tags": ["2d"], "likes": 3, "viewed": 116, "published": "Public", "date": "1441072658", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float inCog(vec2 uv, float boxSize, float time) {\n  float inBoxX = step(0.2, mod(uv.x + time, boxSize));\n  float inBoxY1 = 1.0 - step(boxSize, uv.y);\n  float inBoxY2 = 1.0 - step(boxSize - 0.1, uv.y);\n  return (inBoxX * inBoxY1) + ((1.0 - inBoxX) * inBoxY2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv          = fragCoord.xy / iResolution.xy;\n    vec3  boxColor   = vec3(0.0, 0.15, 0.15);\n    float time       = iTime / 4.0;\n    vec3  finalColor = vec3(1.0, 1.0, 1.0);\n    \n    for(int i = 0; i < 6; i++) {\n      float direction = ((step(1.0, mod(float(i), 2.0)) - 1.0) + 0.5) * 2.0;\n      finalColor -= (boxColor * inCog(uv, 0.25 + (float(i) * 0.15), (time * direction) / float(i)));\n    }\n    \n\tfragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljSRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 260]], "test": "valid"}
{"id": "XljSzm", "name": "8 Sensatron Countdown Sequence", "author": "evilzug", "description": "a sequence that plays when sensatron is about to head out - colors change from blue, to red, to yellow, to green, to flashing green and white", "tags": ["sensatron", "sensatom", "countdown"], "likes": 0, "viewed": 123, "published": "Public", "date": "1442521880", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv2rgb_smooth( in vec3 c ) { vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 ); rgb = rgb*rgb*(3.0-2.0*rgb); return c.z * mix( vec3(1.0), rgb, c.y); }\nvec3 outputColor(float aFinalHue, float aFinalSaturation, float aFinalValue) { return hsv2rgb_smooth(vec3(aFinalHue, aFinalSaturation, aFinalValue)); }\nfloat rand(vec2 co) { return fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453); }\nfloat convertHue(float aHue) { return aHue/360.0; }\n\nconst float PURPLE = 304.0;\nconst float BLUE = 239.0;\nconst float CYAN = 183.0;\nconst float GREEN = 131.0;\nconst float YELLOW = 62.0;\nconst float ORANGE = 42.0;\nconst float RED = 0.0;\n\nfloat ROWS = 12.0;\n\nfloat evaluateColor(in vec2 fragCoord, in float aCycle, in float aCycleDelay) {\n//float evaluateColor(in float aRow, in vec2 fragCoord, in float aCycle) {\n    float tFinalHue = 0.0;\n    float iCurrentTime = iTime - aCycleDelay;\n    //float iCurrentTime = iTime - (aCycle * aRow);\n    float tPercentTimeUntilAllRed = iCurrentTime/aCycle;\n    if (tPercentTimeUntilAllRed > (fragCoord.x/iResolution.x)) {\n        tFinalHue = convertHue(RED) + sin(iTime*1.1)*.075;\n        if (tPercentTimeUntilAllRed > 1.0) {\n            float tPercentTimeUntilAllYellow = (iCurrentTime-aCycle*12.0)/aCycle;\n            if (tPercentTimeUntilAllYellow > (fragCoord.x/iResolution.x)) {\n                tFinalHue = convertHue(YELLOW) + abs(sin(iTime*0.9)*.05)*-1.0;\n                float tPercentageTimeUntilAllGreen = (iCurrentTime-aCycle*2.0*12.0)/aCycle;\n                if (tPercentageTimeUntilAllGreen > (fragCoord.x/iResolution.x)) { \n                    tFinalHue = convertHue(GREEN);\n                }\n            }\n        }\n    } else {\n        tFinalHue = convertHue(BLUE) + abs(sin(iTime * .6)*.075);\n    }\n    return tFinalHue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float tCountdownTimeInMinutes = 10.0;\n    float tSecondsInAMinute = 60.0;\n    float tTotalTimeInSeconds = tCountdownTimeInMinutes * tSecondsInAMinute;\n    float tColors = 3.0;\n    float tCycle = (tTotalTimeInSeconds/tColors)/ROWS;\n    float tFinalHue = 0.0;\n    float tFinalSaturation = 1.0;\n    if (fragCoord.y > (iResolution.y * (11.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*0.0);\n    } else if (fragCoord.y > (iResolution.y * (10.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*1.0);\n    } else if (fragCoord.y > (iResolution.y * (9.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*2.0);\n    } else if (fragCoord.y > (iResolution.y * (8.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*3.0);\n    } else if (fragCoord.y > (iResolution.y * (7.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*4.0);\n    } else if (fragCoord.y > (iResolution.y * (6.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*5.0);\n    } else if (fragCoord.y > (iResolution.y * (5.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*6.0);\n    } else if (fragCoord.y > (iResolution.y * (4.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*7.0);\n    } else if (fragCoord.y > (iResolution.y * (3.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*8.0);\n    } else if (fragCoord.y > (iResolution.y * (2.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*9.0);\n    } else if (fragCoord.y > (iResolution.y * (1.0/ROWS))) {    \n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*10.0);\n    } else {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*11.0);\n    }\n    \n    float tPercentageTimeUntilDone = iTime/(tCycle*3.0*12.0);\n    if (tPercentageTimeUntilDone > 1.0 ) {\n        tFinalSaturation = abs(sin(iTime)) * .5;\n    }\n    \n\tfragColor = vec4(outputColor(tFinalHue, tFinalSaturation, 1.0), 1.0);\n}\n\n/*\nfor (float i = 0.0; i < 12.0; i++) {\n        if (fragCoord.y > (iResolution.y * (11.0/ROWS)) && \n            fragCoord.y < (iResolution.y * (12.0/ROWS))) { //trying to figure out how to mod with 'i'\n            tFinalHue = evaluateColor(i, fragCoord, tCycle); //???\n            break;\n        }\n    }\n*/\n\n/* previous non-for-looped code\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljSzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 184], [185, 185, 263, 263, 336], [337, 337, 358, 358, 428], [429, 429, 459, 459, 480], [687, 687, 766, 841, 1806], [1808, 1808, 1865, 1865, 3887]], "test": "valid"}
{"id": "XljSzw", "name": "Cartoon Nightscape", "author": "clayjohn", "description": "Made a quick landscape based on the art style of bojack horseman. It's strange.", "tags": ["noise", "clouds", "cartoon", "stars", "moon", "bojack"], "likes": 14, "viewed": 412, "published": "Public", "date": "1442474594", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 hash2(vec2 p ) {\n   return fract(sin(vec2(dot(p, vec2(123.4, 748.6)), dot(p, vec2(547.3, 659.3))))*5232.85324);   \n}\n\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(43.232, 75.876)))*4526.3257);   \n}\n\n\nfloat f(vec2 p) {\n  float h = 0.0;\n  float a = 0.5;\n    for (int i = 0;i<3;i++) {\n      h+= texture(iChannel0, p).x*a; \n      p*=2.0;\n      a*=0.5;\n    }\n  return sqrt(h);\n}\n\nvec3 stars(vec2 p) {\n    vec2 n = floor(p);\n    vec3 c = vec3(0.0);\n    for (int i = -1;i<=1;i++) {\n        for (int j = -1;j<=1;j++) {\n            vec2 g = vec2(i, j);\n            g += hash2(n+g)*0.5;\n            c= mix(vec3(hash(n+g)),  c, smoothstep(0.039, 0.04, length(p-n+g)));\n            \n        }\n    }\n    return c;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.3;\n\tvec2 uv = fragCoord.xy / iResolution.yy*2.0;\n    uv.y -= 1.0;\n    uv.x -=1.6;\n    uv.x/= iResolution.x/iResolution.y;\n    vec3 col;\n    float h = f(vec2(uv.x*0.01, 0.1+time*0.001));\n    col = mix(vec3(0.0), vec3(1.0, 0.0, 1.0), smoothstep(0.018, 0.03, h-uv.y-1.0));\n    float nh = mix(0.0, f(vec2(uv.x*0.02, time*0.001)*0.95+0.05*f(vec2(uv.x*0.001, 0.5))), (uv.x+1.0)*0.5);\n    col = mix(col, mix(vec3(0.0), vec3(0.5, 0.0, 1.0), smoothstep(0.018, 0.03, nh-uv.y-1.0)), smoothstep(uv.y-0.01, uv.y, nh-1.));\n    //sky\n    vec3 sky = vec3(0.01, 0.01, 0.1);\n    vec2 moon = vec2(sin(time)*1.2, cos(time)*1.5-1.0);//vec2(-0.5, 0.1)\n    float l = length(uv*vec2(iResolution.x/iResolution.y, 1.0)-moon);\n    //stars\n    sky = mix(sky, vec3(1.0, 1.0, 0.0), smoothstep(0.5, 1.0, stars((uv+vec2(time*0.1, time*0.3))*8.0)));\n    //moon\n    sky = mix(vec3(0.8+0.2*smoothstep(0.58, 0.61, f((uv-moon)*0.05))+smoothstep(0.15, 0.25, l)*0.2), sky, smoothstep(0.24, 0.25, l));\n    //clouds\n    sky = mix(sky, vec3(0.35, 0.0, 0.7), smoothstep(0.74+cos(time*0.2)*0.1, 0.75+cos(time*0.2)*0.1, f((uv+vec2(time*0.1, time*0.01))*0.03*vec2(0.4, 1.0))));\n\n    col = mix(sky, col, smoothstep(uv.y-1.01, uv.y-1.0, max(h, nh)-2.0));\n    col = pow(col, vec3(0.45));\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljSzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 121], [123, 123, 143, 143, 209], [212, 212, 229, 229, 385], [387, 387, 407, 407, 714], [718, 718, 775, 775, 2069]], "test": "error"}
{"id": "XljXz1", "name": "Weird Waves", "author": "aiekick", "description": "Weird Waves", "tags": ["waves", "weird"], "likes": 3, "viewed": 1403, "published": "Public API", "date": "1441660383", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst vec4 uSlider = vec4(.15, .75, 1.2, -.14);\nconst float uSlider1 = 1.6;\nconst vec3 uColor = vec3(0,.57,1);\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n    float uTime = iTime;\n    vec2 uScreenSize = iResolution.xy;\n\n\tvec2 s = uScreenSize;\n\t\n\tfloat r =  g.y/(s.x*2. - g.x);\n\t\n\tvec2 uv = 15.*(2.*g - s)/max(s.x,s.y);\n\t\n\tvec3 col = vec3(0.);\n\t\n\tuv.y += uSlider.y * sin(uv.x / uSlider.x * r + uTime );\n\t\n\tfloat rep = uSlider.z;\n\tuv = mod(uv, vec2(rep)) - vec2(rep)/uSlider1;\n\t\n\tcol += uColor * (uSlider.w / uv.y);\n\n\tf = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 154, 154, 537]], "test": "valid"}
{"id": "XljXzh", "name": "Truchetic Epilator", "author": "Kuukunen", "description": "Messing around with two of WAHa_06x36's shaders, for something even worse.", "tags": ["distancefield", "music", "epilepsy", "pain"], "likes": 4, "viewed": 1486, "published": "Public API", "date": "1441613220", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// if you have problems running this, you can try to adjust the iterations\n#define Iterations 35\n#define Thickness 0.1\n#define SuperQuadPower 8.0\n#define Fisheye 1.2\n\nfloat rand(vec3 r) { return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453); }\n\nfloat phase1;\nfloat phase2;\nfloat phase3;\nfloat phase4;\nfloat phase5;\nvec3 phase;\n\n\nfloat truchetarc(vec3 pos)\n{\n\tfloat r=length(pos.xy);\n//\treturn max(abs(r-0.5),abs(pos.z-0.5))-Thickness;\n//\treturn length(vec2(r-0.5,pos.z-0.5))-Thickness;\n\treturn pow(pow(abs(r-0.5),SuperQuadPower)+pow(abs(pos.z-0.5),SuperQuadPower),1.0/SuperQuadPower)-Thickness;\n}\n\nfloat truchetcell(vec3 pos)\n{\n\treturn min(min(\n\ttruchetarc(pos),\n\ttruchetarc(vec3(pos.z,1.0-pos.x,pos.y))),\n\ttruchetarc(vec3(1.0-pos.y,1.0-pos.z,pos.x)));\n}\n\nvec3 texat(vec3 pos)\n{\n\tpos = pos*0.6;\n\t/*\n\tvec3 uv=vec3(sin(pos.x),sin(pos.y),sin(pos.z));\n\tfloat s1=texture(iChannel0,vec2(uv.x,1.0)).x;\n\tfloat s2=texture(iChannel0,vec2(uv.y,1.0)).x;\n\tfloat s3=texture(iChannel0,vec2(uv.z,1.0)).x;\n\tvec3 col=vec3(\n\t(texture(iChannel0,vec2(0.0,0.1)).x-0.5)*2.0,\n\t(texture(iChannel0,vec2(0.4,0.4)).x-0.5)*2.0,\n\t(texture(iChannel0,vec2(0.5,0.6)).x-0.5)*2.0);\n\t//if(abs(s1-s2)<0.1)\n\t\treturn vec3(vec3(1.0-abs(s1-s2+s3)/0.5)*col);\n\t//else return vec3(vec3(0.0));\n\t*/\n\t//pos = pos*1.0;\n\tvec3 uv=vec3(sin(pos.x)/2.0+0.5,sin(pos.y)/2.0+0.5,sin(pos.z)/2.0+0.5);\n\t//vec3 uv=pos;\n\tfloat s1=texture(iChannel0,vec2(uv.x,1.0)).x;\n\tfloat s2=texture(iChannel0,vec2(uv.y,1.0)).x;\n\tfloat s3=texture(iChannel0,vec2(uv.z,1.0)).x;\n\tvec3 col=vec3(\n\t(phase1-0.5)*2.0,\n\t(phase2-0.5)*2.0,\n\t(phase4-0.5)*2.0);\n\t//if(abs(s1-s2)<0.1)\n\t\treturn vec3(vec3(1.0-abs(s1-s2+s3)/0.4)*col);\n\t//else return vec3(vec3(0.0));\n/*\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tfloat s1=texture(iChannel0,vec2(uv.x,1.0)).x;\n\tfloat s2=texture(iChannel0,vec2(uv.y,1.0)).x;\n\tvec3 col=vec3(\n\t(texture(iChannel0,vec2(0.0,0.1)).x-0.5)*2.0,\n\t(texture(iChannel0,vec2(0.0,0.2)).x-0.5)*2.0,\n\t1.0);\n\tif(abs(s1-s2)<0.1) fragColor=vec4(vec3(1.0-abs(s1-s2)/0.1)*col,1.0);\n\telse fragColor=vec4(vec3(0.0),1.0);\n*/\n}\n\nfloat distfunc(vec3 pos)\n{\n\tpos = vec3(pos.x+sin(pos.y/2.0)+0.6*sin(pos.y/2.3*sin(iTime/5.0)*4.0)+0.6*sin(pos.y/2.1*sin(iTime/5.0)*8.0),\n\t\t\t   pos.y+sin(pos.z/2.0)+0.6*sin(pos.y/2.2*sin(iTime/4.0)*3.0)+0.6*sin(pos.y/2.2*sin(iTime/7.0)*8.2),\n\t\t\t   pos.z+sin(pos.x/2.0)+0.6*sin(pos.y/2.1*sin(iTime/5.3)*5.5)+0.6*sin(pos.y/2.3*sin(iTime/8.0)*8.1));\n\tvec3 cellpos=fract(pos);\n\tvec3 gridpos=floor(pos);\n\n\tfloat rnd=rand(gridpos);\n\n\tif(rnd<1.0/8.0) return truchetcell(vec3(cellpos.x,cellpos.y,cellpos.z));\n\telse if(rnd<2.0/8.0) return truchetcell(vec3(cellpos.x,1.0-cellpos.y,cellpos.z));\n\telse if(rnd<3.0/8.0) return truchetcell(vec3(1.0-cellpos.x,cellpos.y,cellpos.z));\n\telse if(rnd<4.0/8.0) return truchetcell(vec3(1.0-cellpos.x,1.0-cellpos.y,cellpos.z));\n\telse if(rnd<5.0/8.0) return truchetcell(vec3(cellpos.y,cellpos.x,cellpos.z));\n\telse if(rnd<6.0/8.0) return truchetcell(vec3(cellpos.y,1.0-cellpos.x,cellpos.z));\n\telse if(rnd<7.0/8.0) return truchetcell(vec3(1.0-cellpos.y,cellpos.x,cellpos.z));\n\telse  return truchetcell(vec3(1.0-cellpos.y,1.0-cellpos.x,cellpos.z));\n}\n\nvec3 gradient(vec3 pos)\n{\n\tconst float eps=0.0001;\n\tfloat mid=distfunc(pos);\n\treturn vec3(\n\tdistfunc(pos+vec3(eps,0.0,0.0))-mid,\n\tdistfunc(pos+vec3(0.0,eps,0.0))-mid,\n\tdistfunc(pos+vec3(0.0,0.0,eps))-mid);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst float pi=3.141592;\n\n\tvec2 coords=(2.0*fragCoord.xy-iResolution.xy)/length(iResolution.xy);\n\n\tphase1 = texture(iChannel0,vec2(0.0,0.0)).x;\n\tphase2 = texture(iChannel0,vec2(0.5,0.0)).x;\n\tphase3 = texture(iChannel0,vec2(1.0,0.0)).x;\n\tphase4 = texture(iChannel0,vec2(0.6,0.0)).x;\n\tphase5 = texture(iChannel0,vec2(0.2,0.0)).x;\n\tphase=vec3(phase1, phase2, phase3);\n\n    float a=iTime/5.0;\n\tmat3 m=mat3(\n\t0.0,1.0,0.0,\n\t-sin(a),0.0,cos(a),\n\tcos(a),0.0,sin(a));\n\tm*=m;\n\tm*=m;\n\t\n\n\tvec3 dir = normalize(vec3(1.4*coords,-1.0+Fisheye*(coords.x*coords.x+coords.y*coords.y)));\n\tvec3 ray_dir=m*dir;\n\tvec3 pv = m*normalize(vec3(dir.z, dir.z, -dir.x-dir.y));\n\tmat3 ll = mat3(\n\t\t0.0, ray_dir.z, -ray_dir.y,\n\t\t-ray_dir.z, 0.0, ray_dir.x,\n\t\tray_dir.y, -ray_dir.x, 0.0);\n\t//float rot = sqrt(phase5)-sqrt(phase2)*1.5-sqrt(phase3)*1.5;\n\t//if(rot < 0.0) rot = 0.0;\n\t//pv = normalize(pv*(mat3(1.0) + sin(a*3.0)*ll + ((1.0 - cos(a*3.0))*(ll*ll))));\n\n\tfloat t=iTime/5.0;\n\tvec3 ray_pos=vec3(\n    2.0*(sin(t+sin(2.0*t)/2.0)/2.0+0.5),\n    2.0*(sin(t-sin(2.0*t)/2.0-pi/2.0)/2.0+0.5),\n    2.0*((-2.0*(t-sin(4.0*t)/4.0)/pi)+0.5+0.5));\n\tvec3 shads = vec3(0.0);\n\tfloat dist2 = 0.0;\n\n\tfloat i=float(Iterations);\n\tfor(int j=0;j<Iterations;j++)\n\t{\n\t\tfloat dist=distfunc(ray_pos)+0.1;\n\t\tdist2 += dist;\n\t\tray_pos+=dist*ray_dir;\n\t\t//ray_pos += rot*pv*dist*0.5;\n\n\t\tif(abs(dist)<0.101) { shads += texat(ray_pos)*0.2; }\n\t}\n\n\tfloat vignette=pow(1.0-length(coords),0.3);\n\tfloat light=vignette;\n\n\tfloat z=ray_pos.z/2.0;\n//\tvec3 col=(sin(vec3(z,z+pi/3.0,z+pi*2.0/3.0))+2.0)/3.0;\n//\tvec3 col=(cos(ray_pos/2.0)+2.0)/3.0;\n\tvec3 col=vec3(\n\t\t(cos(ray_pos/2.0+phase1*10.0+iTime*1.0)+2.0).x,\n\t\t(cos(ray_pos/2.0+phase2*10.0+iTime*1.5)+2.0).x,\n\t\t(cos(ray_pos/2.0+phase3*10.0+iTime*2.0)+2.0).x\n\t\t)/3.0;\n\tcol += shads;\n\tcol = col*light;\n\tfloat collen = length(col);\n\tvec3 unsat = vec3(collen);\n\tfloat base = phase1*1.5;\n\tif(base > 1.0) base = 1.0;\n\tfragColor=vec4((1.0-base)*unsat*0.8+base*col,1.0);\n\t//fragColor=vec4(sqrt(phase5)-sqrt(phase2)*1.5-sqrt(phase3)*1.5);\n/*\n\tfragColor=vec4(\n\t(texture(iChannel0,fragCoord.xy/iResolution.xy)).x,\n\t0.0,//(texture(iChannel0,coords+vec2(0.5,0.5)*1.0)).x,\n\t0.0,//(texture(iChannel0,coords+vec2(0.5,0.5)*1.0)).x,\n\t1.0);*/\n\t/*\n\tvec2 p = fragCoord.xy/iResolution.xy;\n\tif(p.x < 0.5 && p.y < 0.5) fragColor=vec4(texat(vec3(p.x*pi*2.0, p.y*pi*2.0, 0.0)),1.0)*2.0;\n\telse if(p.x >= 0.5 && p.y < 0.5) fragColor=vec4(texat(vec3(p.x*pi*2.0, p.y*pi*2.0, pi*0.33)),1.0)*2.0;\n\telse if(p.x >= 0.5 && p.y >= 0.5) fragColor=vec4(texat(vec3(p.x*pi*2.0, p.y*pi*2.0, pi*0.66)),1.0)*2.0;\n\telse fragColor=vec4(texat(vec3(p.x*pi*2.0, p.y*pi*2.0, pi)),1.0)*2.0;\n*/\n}\n", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljXzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 167, 187, 187, 271], [357, 357, 385, 385, 624], [626, 626, 655, 655, 782], [784, 784, 806, 806, 2068], [2070, 2070, 2096, 2096, 3141], [3143, 3143, 3168, 3168, 3350], [3352, 3352, 3409, 3409, 6039]], "test": "error"}
{"id": "XljXzz", "name": "first_circle", "author": "wangyue66", "description": "just a circle", "tags": ["circle"], "likes": 5, "viewed": 2144, "published": "Public API", "date": "1441116473", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float l = length(uv);\n    float thi = atan(uv.y,uv.x);\n    \n    float r = 0.5 + 0.05 * sin(20.0 *thi)*pow(sin(iTime * 5.0),3.0);\n    l = step(l,r);\n    vec3 col = vec3(0.0,0.5,0.8);\n\tfragColor = vec4(col*l,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljXzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 390]], "test": "valid"}
{"id": "XllSD8", "name": "Home_", "author": "shezard", "description": "Keeping in shape", "tags": ["fbm"], "likes": 2, "viewed": 147, "published": "Public", "date": "1441134811", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14\n#define TAU 6.28318530718\n\nconst float MAT0 = 0.0;\nconst float MAT1 = 1.0;\nconst float MAT2 = 2.0;\nconst float MAT3 = 3.0;\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat noise(in vec2 uv) {\n\treturn sin(1.5*uv.x)*sin(1.5*uv.y);\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm(vec2 uv) {\n    float f = 0.0;\n    f += 0.5000*noise(uv); uv = m*uv*2.02;\n    f += 0.2500*noise(uv); uv = m*uv*2.03;\n    f += 0.1250*noise(uv); uv = m*uv*2.01;\n    f += 0.0625*noise(uv);\n    return f/0.9375;\n}\n\nfloat fbm2(in vec2 uv) {\n   vec2 p = vec2(fbm(uv + vec2(0.0,0.0)),\n                 fbm(uv + vec2(5.2,1.3)));\n\n   return fbm(uv + 4.0*p);\n}\n\nfloat rand(in vec2 uv) {\n    return fract(sin(dot(uv.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat voronoi(vec2 coord) {\n    vec2 coordInt = floor(coord);\n    vec2 coordFraction = fract(coord);\n    \n\tfloat result = 8.0;\n    for (int i = -1; i <= 1; i++)\n    \tfor (int j = -1; j <= 1; j++)\n        {\n         \tvec2 cellPoint = vec2(float(i), float(j));\n            \n            float offset = rand(coordInt + cellPoint);\n            offset = 0.5 + 0.5*sin( iTime + 6.2831*offset );\n            \n            vec2 randomPoint = cellPoint + offset - coordFraction;\n            float d = dot(randomPoint, randomPoint);\n            \n            result = min(result, d);\n            \n        } \n    return (sqrt(result));\n}\n\nvec2 add(in vec2 a, in vec2 b) {\n \n    float mat;\n    if(a.x < b.x) {\n      mat = a.y;\n    } else {\n      mat = b.y;\n    }\n    \n    return vec2(min(a.x,b.x), mat);\n}\n\nvec2 sub(in vec2 a, in vec2 b) {\n    \n    float mat;\n    if(a.x < b.x) {\n      mat = b.y;\n    } else {\n      mat = a.y;\n    }\n    \n    return vec2(max(a.x, b.x), mat);\n}\n\nvec3 rep(in vec3 p, in vec3 c) {\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nvec2 rotate(in vec2 p, in float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec2 torus(in vec3 p, in vec2 t, in float mat) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return vec2(length(q)-t.y, mat);\n}\n\nvec2 sphere(in vec3 p, in float r, in float mat) {\n    return vec2(length(p) - r, mat);\n}\n\nvec2 plane(in vec3 p, in vec4 n, in float mat) {\n  return vec2(dot(p,n.xyz) + n.w, mat);\n}\n\nvec2 cylinder(in vec3 p, in vec3 c, in float mat) {\n  return vec2(length(p.xz-c.xy)-c.z, mat);\n}\n\nvec2 box(in vec3 p, in vec3 b, in float mat) {\n  return vec2(length(max(abs(p)-b,0.0)), mat);\n}\n\nfloat map(in vec3 p, inout float mat) {\n  \n   // Get proper mod\n   float fft  = 1.0 - texture( iChannel0, vec2(abs(.0005*p.x*p.y*p.z), .25)).x; \n    \n   p.xy = rotate(p.xy, -.3);\n   p.xz = rotate(p.xz, iTime);\n   vec2 scene = vec2(999.0, MAT0);\n    \n   float h = 3.0;\n    \t h += 2. * pow(.5 + .5*sin(\n             10.*fft\n         ),5.);\n    \n         h += .05 * cos(p.y*25.0) + fbm2(p.xz*10.) * .2; \n    \n    \n   float m = 2.0;\n    \n   vec2 s1 = sphere(p, h, m);\n    \n   scene = add(scene, s1);\n\n   mat = scene.y;\n    \n   return scene.x;\n}\n\nmat3 setLookAt(in vec3 ro, in vec3 ta,in float cr) {\n\tvec3  cw = normalize(ta-ro);\n\tvec3  cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3  cu = normalize( cross(cw,cp) );\n\tvec3  cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n\tfloat res = 1.0;\n    float t = mint;\n    \n    float mat = MAT3;\n    for( int i = 0; i < 16; i++ ) {\n\t\tfloat h = map(ro + rd*t, mat);\n        res = min( res, 4.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    // camera\t\n    vec3 ro = vec3(\n        8.0,\n        0.0,\n        8.0\n   \t);\n    vec3 ta = vec3(0.0,0.0,0.0);\n    float roll = 0.0;\n\n    // camera tx\n    mat3 ca = setLookAt( ro, ta, roll );\n    vec3 rd = normalize( ca * vec3(p.xy,1.75) );\n\n    float t = 0.1;      // Near\n    float tmax = 120.0; // Far\n   \t\n    float h = 0.001;\n    float hmax = 0.001;\n    \n    float mat = MAT0;\n    \n    vec3 c = vec3(0.0);\n    vec3 ao = vec3(0.0);\n    \n    const int steps = 100;\n    for(int i = 0 ; i < steps ; i++) {\n        \n        if(h < hmax || t > tmax ) {\n        \tao = vec3(1.0) - float(i)/float(steps);\n            break;\n        }\n        \n        h = map(ro + t *rd, mat);\n        t += h;\n    }\n    \n    if(t < tmax) {\n        vec3 pos = ro+rd*t;\n        \n        vec2 r = vec2(0.001,0.0);\n        vec3 nor = normalize(vec3(map(pos+r.xyy, mat)-map(pos-r.xyy, mat),\n                                  map(pos+r.yxy, mat)-map(pos-r.yxy, mat),\n                                  map(pos+r.yyx, mat)-map(pos-r.yyx, mat)));\n      \tvec3 ref = reflect(rd,nor);\n        \n       \tc = vec3(.9,.5,.3);\n        \n        vec3 lig = vec3(0.5773);\n        c *= .3 + clamp(dot(nor,lig), 0.0, 1.0);\n        \n        // Fixme\n        float power = 25.0;\n        ao = 1.0 - vec3(pow(ao.x,power),pow(ao.y,power),pow(ao.z,power));\n        c *= 1.0 - exp(1.0 / log(ao));\n        \n        c *= 1.0 - smoothstep(0.1, 1.0, t / tmax);\n        \n        c += -1.0/mat + (noise(p.xx) + noise(p.yy));\n        \n    } else {\n        c = vec3(.8,.4,.2);\n        c *= fbm2(8.0*p.xy*fbm2(\n            \t14.0*(abs(p)+iTime*.25\n          \t )));\n        float f = fbm(p*3.+iTime*.1) * cos(p.x) * cos(p.y) * 3.0 * cos(iTime*5.0);\n        c += vec3(.5,.3,.1) * f;\n        \n    }\n    \n    \n   \n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [{"id": "4df3RH", "previewfilepath": "https://soundcloud.com/takkuu/apparatique-medium-love-original-mix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/takkuu/apparatique-medium-love-original-mix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XllSD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 162, 162, 493], [495, 495, 517, 517, 686], [688, 688, 713, 713, 752], [805, 805, 825, 825, 1023], [1025, 1025, 1049, 1049, 1164], [1166, 1166, 1190, 1190, 1262], [1264, 1264, 1291, 1291, 1887], [1889, 1889, 1921, 1921, 2054], [2056, 2056, 2088, 2088, 2225], [2227, 2227, 2259, 2259, 2304], [2306, 2306, 2344, 2344, 2431], [2433, 2433, 2481, 2481, 2557], [2559, 2559, 2609, 2609, 2648], [2650, 2650, 2698, 2698, 2740], [2742, 2742, 2793, 2793, 2838], [2840, 2840, 2886, 2886, 2935], [2937, 2937, 2976, 3000, 3477], [3479, 3479, 3531, 3531, 3712], [3714, 3714, 3786, 3786, 4074], [4076, 4076, 4133, 4133, 6030]], "test": "error"}
{"id": "XlSSRh", "name": "Tree attempt 1", "author": "cabbibo", "description": " Super into : https://www.shadertoy.com/view/ltlSRl\n\nAnd wanted to understand the space folding techniqures", "tags": ["raytrace", "recursive"], "likes": 25, "viewed": 408, "published": "Public", "date": "1441236042", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Branch Code stolen from : https://www.shadertoy.com/view/ltlSRl\n\nconst float MAX_TRACE_DISTANCE = 10.0;             // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float PI = 3.14159;\n\nmat4 rotateX(float angle){\n    \n\tangle = -angle/180.0*3.1415926536;\n    float c = cos(angle);\n    float s = sin(angle);\n\treturn mat4(1.0, 0.0, 0.0, 0.0, 0.0, c, -s, 0.0, 0.0, s, c, 0.0, 0.0, 0.0, 0.0, 1.0);\n    \n}\n\nmat4 rotateY(float angle){\n    \n\tangle = -angle/180.0*3.1415926536;\n    float c = cos(angle);\n    float s = sin(angle);\n\treturn mat4(c, 0.0, s, 0.0, 0.0, 1.0, 0.0, 0.0, -s, 0.0, c, 0.0, 0.0, 0.0, 0.0, 1.0);\n    \n}\n\nmat4 rotateZ(float angle){\n    \n\tangle = -angle/180.0*3.1415926536;\n    float c = cos(angle);\n    float s = sin(angle);\n\treturn mat4(c, -s, 0.0, 0.0, s, c, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n    \n}\nmat4 translate(vec3 t){\n    \n\treturn mat4(1.0, 0.0, 0.0, -t.x, 0.0, 1.0, 0.0, -t.y, 0.0, 0.0, 1.0, -t.z, 0.0, 0.0, 0.0, 1.0);\n    \n}\n\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nvec2 smoothU( vec2 d1, vec2 d2, float k)\n{\n    float a = d1.x;\n    float b = d2.x;\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return vec2( mix(b, a, h) - k*h*(1.0-h), mix(d2.y, d1.y, pow(h, 2.0)));\n}\n\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n    \n    float branchSize = .3;\n    float reductionFactor = .6 +  .2 * sin( iTime * 1.73 );\n    float trunkSize = .2 +  .1 * sin( iTime * 3.27 );\n    float bs = branchSize;\n    float rot = 40. + 10. * sin( iTime * 4. );\n    \n    pos += vec3( 0. , branchSize , 0. );\n\n   \n    vec4 p = vec4( pos , 1. );\n    mat4 m;\n    \n   \t//vec2 res = vec2( (abs(sin( pos.x * pos.y * pos.z  * 10.)) * 1.9 ) + length( pos ) - 1., 0.0 );\n  \n    vec2 res = vec2( sdCappedCylinder( p.xyz , vec2( trunkSize * bs , bs )),1.);\n    \n    for( int i = 0; i < 4; i ++ ){\n        bs *= reductionFactor;\n\n        m = translate(vec3(0.0, bs*2. , 0.0)) * rotateY(rot) * rotateX(rot);    \n        p.x = abs(p.x) - bs / 2.;\n        p.z = abs(p.z) - bs / 2.;   \n        p = p * m; \n\n        res = smoothU( res , vec2( sdCappedCylinder( p.xyz , vec2( trunkSize * bs , bs )),1.) , .1);\n    }\n\n   \treturn res;\n    \n}\n\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    float an = 0.3 + 3.0*mouse.x;\n   \tfloat an2 = 0.3 + 3.0*mouse.y;\n\n\tcamPos = vec3(3.5*sin(an),3. * cos( an2),3.5*cos(an));\n    camTar = vec3(0. ,0.0,0.0);\n}\n\n\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n     \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n   \n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    vec2 res = calcIntersection( ro , rd  );\n    \n    vec3 col = vec3( 0. , 0. , 0. ); \n    \n        // If we have hit something lets get real!\n    if( res.y > -.5 ){\n   \n        vec3 pos = ro + rd * res.x;\n        vec3 nor = calcNormal( pos );\n       \tcol = nor * .5 + .5;\n\n    }\n    \n    // apply gamma correction\n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col , 1. );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlSSRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[289, 289, 315, 315, 502], [504, 504, 530, 530, 717], [719, 719, 745, 745, 932], [933, 933, 956, 956, 1065], [1068, 1068, 1110, 1110, 1209], [1212, 1212, 1254, 1254, 1420], [1424, 1508, 1529, 1529, 2416], [2420, 2451, 2515, 2515, 2693], [2695, 2695, 2776, 2776, 2936], [2941, 3054, 3085, 3085, 3310], [3315, 3315, 3363, 3363, 3831], [3835, 3835, 3891, 3891, 4670]], "test": "valid"}
{"id": "XlSSzw", "name": "fluidthing", "author": "vortex", "description": "Giving it a try at a procedural fluid", "tags": ["fluid"], "likes": 14, "viewed": 436, "published": "Public", "date": "1442267946", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stefan Draganov - vortex/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst float s2=30.0;\nconst float s =40.0/s2;\n\nvec3 n(vec2 x,float t)\n{\n    vec3 u=floor(vec3(x,t));\n    \n    vec3 c=fract(\n        u.xyz*(vec3(0.16462,0.84787,0.98273)+\n         u.xyz*vec3(0.24808,0.75905,0.13898)+\n         u.yzx*vec3(0.31517,0.62703,0.26063)+\n         u.zxy*vec3(0.47127,0.58568,0.37244))+\n        \n        u.yzx*(vec3(0.35425,0.65187,0.12423)+\n         u.yzx*vec3(0.95238,0.93187,0.95213)+\n         u.zxy*vec3(0.31526,0.62512,0.71837))+\n        \n        u.zxy*(vec3(0.95213,0.13841,0.16479)+\n         u.zxy*vec3(0.47626,0.69257,0.19738))\n    );//*vec3(0.5,0.5,1.0)+vec3(0.25,0.25,0.0);//*vec3(1.0,1.0,0.5)+vec3(0.0,0.0,0.25);\n    \n    return u+c;\n}\n\nfloat arrow(vec2 x,vec2 d)\n{\n    \n    float l=min(length(d),1.0);\n    \n    x=mat2(normalize(d)/l,normalize(vec2(d.y,-d.x))/l)*(x-vec2(0.5));\n    \n    return min(max(floor(abs(x.y)-0.05)+1.0,x.x>0.0&&x.x<0.25?0.0:1.0 ),\n               x.x-0.25>0.0 && x.x-0.25+abs(x.y)<0.25 ? 0.0 : 1.0 );\n}\n\nvec3 col(vec2 x,float t)\n{\n    return vec3(0.5)+0.5*cos(fract(vec3(x,t))*371.0241);\n}\n\nvec2 idx(vec2 x)\n{\n    return \n        //clamp(floor(3.0*normalize(vec2(x.y,-x.x))),vec2(-1.0),vec2(1.0));\n                       floor(fract(x*29.0)*3.0)-vec2(1.0);\n}\n\nfloat circle(vec2 x,vec2 c,float r)\n{\n    return max(0.0,1.0-dot(x-c,x-c)/(r*r));//<r*r?1.0:0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 x = s*(fragCoord.xy-1.0*iMouse.xy)/iResolution.x;\n    \n    vec2 u = floor(x*s2)+vec2(0.5);\n    \n    float t=iTime*0.1;\n    \n    vec2 v=vec2(0.0);\n    \n    vec4 c=vec4(vec3(0.0),0.1);\n    \n    for (int N=0;   N<10; N++)\n    for (int k=-1; k<=0; k++)\n    for (int i=-1; i<=1; i++)\n    for (int j=-1; j<=1; j++)\n    {\n        vec2 X=x+vec2(j,i);\n        float t=t+float(N)*38.0;\n        float T=t+float(k);\n        vec3 a=n(X,T);\n        \n        vec2 o=idx(a.xy);\n        vec3 b=n(X+o,T+1.0);\n        vec2 m=mix(a.xy,b.xy,(t-a.z)/(b.z-a.z));\n        \n        float strength=clamp(sin(3.1415927*(t-a.z)/(b.z-a.z)),0.0,1.0)\n            *(mix(col(a.xy,a.z).r,col(b.xy,a.z).r,(t-a.z)/(b.z-a.z))-0.5);\n        \n        float r=60.0*(strength);\n        \n        if (length(a.xy-b.xy)/(b.z-a.z)>2.0) r=0.0;\n        \n        v+=r*exp(-dot(u/s2-m,u/s2-m)/(0.025))*vec2((u/s2-m).y,-(u/s2-m).x);\n     //   c+=vec4(circle(x,m,0.25)*col(a.xy,a.z),0.0);\n    }\n    \n    c=vec4(mix(vec3(0.0),vec3(1.0),arrow(s2*(x-(u-vec2(0.5))/s2),v)),1.0);\n\tfragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlSSzw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[178, 178, 202, 202, 799], [801, 801, 829, 829, 1090], [1092, 1092, 1118, 1118, 1177], [1179, 1179, 1197, 1197, 1346], [1348, 1348, 1385, 1385, 1446], [1448, 1448, 1505, 1505, 2553]], "test": "valid"}
{"id": "XlSXW1", "name": "Teleport (nv)", "author": "navrocky", "description": "Teleporting portal", "tags": ["procedural", "2d", "game"], "likes": 5, "viewed": 197, "published": "Public", "date": "1443110323", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.1415926535897;\n\nfloat radius = 1.0;\nfloat width = 0.3;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scaleX = 1.0/1.0;\n    float scaleY = 1.0/1.0;\n    \n    vec2 center = vec2(0.5, 0.5);\n    vec2 pt = vec2(fragCoord.x / iResolution.x / scaleX, fragCoord.y / iResolution.y / scaleY);\n    float angle = atan((pt.y - center.y) / (pt.x - center.x));\n    float l = distance(center, pt);\n    \n    float _radius = radius * 0.26 + cos(angle * 20.0 + iTime * 3.0 + l * 100.0) * 0.01;\n    float _width = clamp(radius, 0.0, 1.0) * width + cos(angle * 14.0 + iTime * 10.0 + l * 100.0) * 0.03;\n    if (_width < 0.0)\n        _width = 0.0;\n    \n    _radius = _radius + cos(iTime * 3.0) * 0.02;\n    if (_radius < 0.0)\n        _radius = 0.0;\n    \n\tfloat w2 = _width / 2.0;\n    float v = cos(clamp(l - _radius, -w2, w2) / w2 * PI / 2.0);\n    \n    float light = clamp(v, 0.0, 1.0);\n    \n    fragColor = vec4(light*0.0, light, light*1.5, light);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlSXW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 126, 126, 962]], "test": "valid"}
{"id": "XlX3Rf", "name": "Swirly Sampler", "author": "ddoodm", "description": "Just a test of swirly texture sampling!", "tags": ["swirl", "texture", "trigonometric"], "likes": 11, "viewed": 1323, "published": "Public API", "date": "1443582010", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TILES 2.0\n#define FREQU 2.0\n#define SPEED 4.0\n#define AMPLI 0.2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * TILES;\n    uv.x *= iResolution.x/iResolution.y;\n        \n   \tfloat t = iTime * SPEED;\n    \n    uv += vec2(\n        AMPLI * sin(t/2.0) * cos(t + uv.y*FREQU),\n        AMPLI * cos(t/2.0) * sin(t + uv.x*FREQU) );\n    uv += vec2(t*0.1);\n    \n    // Sample at wavy coordinates, and colour correct!\n    vec3 c = texture(iChannel0, uv).xyz;\n    vec3 dc = vec3(0.57, 0.4, 1.0);\n    c = dc * dot(c, vec3(0.9, 0.1, 0.0));\n    c = pow(c, vec3(0.9));\n    c *= 1.75;\n    \n    // Specular highlight\n    uv *= vec2(4.0);\n    c += 0.2 * cos(t + uv.y + uv.x);\n    \n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlX3Rf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 130, 130, 749]], "test": "error"}
{"id": "Xt2Szm", "name": "6 Sensatron Countdown Sequence", "author": "evilzug", "description": "a sequence that plays when sensatron is about to head out - colors change from blue, to red, to yellow, to green, to flashing green and white", "tags": ["sensatron", "sensatom", "countdown"], "likes": 0, "viewed": 112, "published": "Public", "date": "1442521874", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv2rgb_smooth( in vec3 c ) { vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 ); rgb = rgb*rgb*(3.0-2.0*rgb); return c.z * mix( vec3(1.0), rgb, c.y); }\nvec3 outputColor(float aFinalHue, float aFinalSaturation, float aFinalValue) { return hsv2rgb_smooth(vec3(aFinalHue, aFinalSaturation, aFinalValue)); }\nfloat rand(vec2 co) { return fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453); }\nfloat convertHue(float aHue) { return aHue/360.0; }\n\nconst float PURPLE = 304.0;\nconst float BLUE = 239.0;\nconst float CYAN = 183.0;\nconst float GREEN = 131.0;\nconst float YELLOW = 62.0;\nconst float ORANGE = 42.0;\nconst float RED = 0.0;\n\nfloat ROWS = 12.0;\n\nfloat evaluateColor(in vec2 fragCoord, in float aCycle, in float aCycleDelay) {\n//float evaluateColor(in float aRow, in vec2 fragCoord, in float aCycle) {\n    float tFinalHue = 0.0;\n    float iCurrentTime = iTime - aCycleDelay;\n    //float iCurrentTime = iTime - (aCycle * aRow);\n    float tPercentTimeUntilAllRed = iCurrentTime/aCycle;\n    if (tPercentTimeUntilAllRed > (fragCoord.x/iResolution.x)) {\n        tFinalHue = convertHue(RED);\n        if (tPercentTimeUntilAllRed > 1.0) {\n            float tPercentTimeUntilAllYellow = (iCurrentTime-aCycle*12.0)/aCycle;\n            if (tPercentTimeUntilAllYellow > (fragCoord.x/iResolution.x)) {\n                tFinalHue = convertHue(YELLOW);\n                float tPercentageTimeUntilAllGreen = (iCurrentTime-aCycle*2.0*12.0)/aCycle;\n                if (tPercentageTimeUntilAllGreen > (fragCoord.x/iResolution.x)) { \n                    tFinalHue = convertHue(GREEN);\n                }\n            }\n        }\n    } else {\n        tFinalHue = convertHue(BLUE);\n    }\n    return tFinalHue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float tCountdownTimeInMinutes = 10.0;\n    float tSecondsInAMinute = 60.0;\n    float tTotalTimeInSeconds = tCountdownTimeInMinutes * tSecondsInAMinute;\n    float tColors = 3.0;\n    float tCycle = (tTotalTimeInSeconds/tColors)/ROWS;\n    float tFinalHue = 0.0;\n    float tFinalSaturation = 1.0;\n    tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*0.0);\n    \n\tfragColor = vec4(outputColor(tFinalHue, tFinalSaturation, 1.0), 1.0);\n}\n\n/*\nfor (float i = 0.0; i < 12.0; i++) {\n        if (fragCoord.y > (iResolution.y * (11.0/ROWS)) && \n            fragCoord.y < (iResolution.y * (12.0/ROWS))) { //trying to figure out how to mod with 'i'\n            tFinalHue = evaluateColor(i, fragCoord, tCycle); //???\n            break;\n        }\n    }\n*/\n\n/* previous non-for-looped code\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2Szm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 184], [185, 185, 263, 263, 336], [337, 337, 358, 358, 428], [429, 429, 459, 459, 480], [687, 687, 766, 841, 1725], [1727, 1727, 1784, 1784, 2220]], "test": "valid"}
{"id": "Xt2XDh", "name": "Mechanical Brain", "author": "Flyguy", "description": " Testing a grid of meshing gears.", "tags": ["raymarch", "gears", "gear"], "likes": 39, "viewed": 1992, "published": "Public API", "date": "1443331488", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Raymarch settings\n\n#define MIN_DIST 0.004\n#define MAX_DIST 16.0\n#define MAX_STEPS 48\n#define STEP_MULT 1.0\n#define NORMAL_OFFS 0.02\n\n//Scene settings\n#define HAZE_COLOR vec3(0.0, 0.1, 0.2)\n\n//Show the number of steps taken by each ray, (green ~= 0, red ~= MAXSTEPS)\n//#define SHOW_RAY_COST\n\n//if the current distance is far from an object, use an approximate distance.\n//Boosts the framerate from ~30fps to 60fps in fullscreen on my machine.\n#define APPROX_FAR_DIST\n\nfloat pi = atan(1.0) * 4.0;\nfloat tau = atan(1.0) * 8.0;\n\nstruct MarchResult\n{\n    vec3 position;\n    vec3 normal;\n    float dist;\n    float steps;\n};\n\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}\n\n//==== Distance field operators/functions by iq. ====\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1, d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n//polynomial smooth minimum\nfloat opSU( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p) - s;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p, normalize(n.xyz)) + n.w;\n}\n\nfloat sdCylinder( vec3 p, vec2 s)\n{\n    return max(abs(p.z) - s.y / 2.0,length(p.xy) - s.x);\n}\n\nfloat sdPole( vec3 p, float s)\n{\n    return length(p.xy) - s;\n}\n\nfloat sdBox( vec3 p, vec3 s )\n{\n    p = abs(p) - s / 2.0;\n    return max(max(p.x,p.y),p.z);\n}\n//===================================================\n\n//16 tooth gear\nfloat dfGear16(vec3 p)\n{\n    float gear = sdCylinder(p , vec2(1.0,0.35));\n    \n    //Teeth\n    vec3 rep = opAngRep(p, tau / 16.0);\n    \n    float tooth = opI(sdCylinder(rep - vec3(1.0,0.4,0), vec2(0.5,0.25)), sdCylinder(rep - vec3(1.0,-0.4,0), vec2(0.5,0.25)));\n    tooth = opS(-sdCylinder(p,vec2(1.2,2.0)), tooth);\n    \n    gear = opU(gear, tooth);\n    \n    //Inner ring\n    gear = opS(sdCylinder(p , vec2(0.8,0.5)), gear);\n    \n    gear = opU(gear, sdCylinder(p , vec2(0.3,0.35)));\n    \n    //Spokes\n    vec3 rep2 = opAngRep(p, tau / 6.0);\n    \n    gear = opSU(gear, sdBox(rep2, vec3(1.5,0.2,0.1)),0.1);\n    \n    return gear;\n}\n\n//simplified 16 tooth gear (for border area)\nfloat dfGear16s(vec3 p)\n{  \n    vec3 rep = opAngRep(p, tau / 16.0);\n    \n    float tooth = opI(sdCylinder(rep - vec3(1.0,0.4,0), vec2(0.5,0.25)), sdCylinder(rep - vec3(1.0,-0.4,0), vec2(0.5,0.25)));\n    tooth = opS(-sdCylinder(p,vec2(1.2,2.0)), tooth);\n    \n    return tooth;\n}\n\nmat3 rot1 = mat3(0);\nmat3 rot2 = mat3(0);\n\n//Distance to the scene\nfloat Scene(vec3 p)\n{\n    float d = -sdSphere(p, MAX_DIST);\n    \n    d = opU(d, sdPlane(p , vec4(0,0,-1,2)));\n    \n    vec3 pr = mod(p + 1.1, vec3(2.2)) - 1.1;\n    \n    //Checkerboard based gear rotation direction\n    float di = step(0.0,cos(pi*p.x/2.2) * cos(pi*p.y/2.2));\n    \n    mat3 r1;\n    mat3 r2;\n    \n    if(di > 0.0)\n    {\n    \tr1 = rot1;\n        r2 = rot2;\n    }\n    else\n    {\n    \tr1 = rot2;\n        r2 = rot1;\n    }\n    \n    #ifdef APPROX_FAR_DIST\n    if(sdCylinder(pr , vec2(1.5,0.45)) < 0.0)\n    {\n        //Center gear\n        d = opU(d, dfGear16((pr - vec3( 0.0, 0.0, 0.0)) * r1));\n\n        //Border gears\n        d = opU(d, dfGear16s((pr - vec3(-2.2, 0.0, 0.0)) * r2));\n        d = opU(d, dfGear16s((pr - vec3( 2.2, 0.0, 0.0)) * r2));\n        d = opU(d, dfGear16s((pr - vec3( 0.0,-2.2, 0.0)) * r2));\n        d = opU(d, dfGear16s((pr - vec3( 0.0, 2.2, 0.0)) * r2));\n    }\n    else\n    {\n    \td = opU(d, sdCylinder(pr , vec2(1.25,0.35)));\n    }\n    \n    #else   \n    //Center gear\n    d = opU(d, dfGear16((pr - vec3( 0.0, 0.0, 0.0)) * r1));\n\n    //Border gears\n    d = opU(d, dfGear16s((pr - vec3(-2.2, 0.0, 0.0)) * r2));\n    d = opU(d, dfGear16s((pr - vec3( 2.2, 0.0, 0.0)) * r2));\n    d = opU(d, dfGear16s((pr - vec3( 0.0,-2.2, 0.0)) * r2));\n    d = opU(d, dfGear16s((pr - vec3( 0.0, 2.2, 0.0)) * r2));   \n    #endif\n    \n    \n        //Shafts and supports\n    d = opU(d, sdPole(pr, 0.15));\n    d = opU(d, sdPole(pr.zxy - vec3(0.5,0.0,0.0), 0.15));\n    d = opU(d, sdPole(pr.zyx - vec3(0.5,0.0,0.0), 0.15));\n    d = opU(d, sdCylinder(pr - vec3(0,0,0.5), vec2(0.25,0.4)));\n    \n\treturn d;\n}\n\n\n//Surface normal at the current position\nvec3 Normal(vec3 p)\n{\n    vec3 off = vec3(NORMAL_OFFS, 0, 0);\n    return normalize\n    ( \n        vec3\n        (\n            Scene(p + off.xyz) - Scene(p - off.xyz),\n            Scene(p + off.zxy) - Scene(p - off.zxy),\n            Scene(p + off.yzx) - Scene(p - off.yzx)\n        )\n    );\n}\n\n//Raymarch the scene with the given ray\nMarchResult MarchRay(vec3 orig,vec3 dir)\n{\n    float steps = 0.0;\n    float dist = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        float sceneDist = Scene(orig + dir * dist);\n        \n        dist += sceneDist * STEP_MULT;\n        \n        steps++;\n        \n        if(abs(sceneDist) < MIN_DIST)\n        {\n            break;\n        }\n    }\n    \n    MarchResult result;\n    \n    result.position = orig + dir * dist;\n    result.normal = Normal(result.position);\n    result.dist = dist;\n    result.steps = steps;\n    \n    return result;\n}\n\n//Scene texturing/shading\nvec3 Shade(MarchResult hit, vec3 direction, vec3 camera)\n{\n    vec3 color = vec3(0.7);\n    \n    //Lighting\n    float ambient = 0.1;\n    float diffuse = 0.4 * -dot(hit.normal, direction);\n    float specular = 1.0 * max(0.0, -dot(direction, reflect(direction, hit.normal)));\n    \n    color *= vec3(ambient + diffuse + pow(specular, 8.0));\n\t\n    //Fog / haze\n    float sky = smoothstep(MAX_DIST - 1.0, 0.0, length(hit.position));\n    float haze = 1.0 - (hit.steps / float(MAX_STEPS));\n    \n    vec3 skycol = mix(HAZE_COLOR, vec3(0), clamp(-hit.position.z * 0.2, 0.0, 1.0));\n    \n    color = mix(skycol, color, sky * haze);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    rot1 = Rotate(vec3(0,0,iTime));\n    rot2 = Rotate(vec3(0,0,-iTime - tau/32.0));\n    \n    //Camera stuff   \n    vec3 angles = vec3(0);\n    \n    if(iMouse.xy == vec2(0,0))\n    {\n        angles.y = tau * (1.5 / 8.0);\n        angles.x = iTime *-0.2;\n    }\n    else\n    {    \n    \tangles = vec3((iMouse.xy / iResolution.xy) * pi, 0);\n        angles.xy *= vec2(2.0, 1.0);\n    }\n    \n    angles.y = clamp(angles.y, 0.0, tau / 4.0);\n    \n    mat3 rotate = Rotate(angles.yzx);\n    \n    vec3 orig = vec3(0, 0,-3) * rotate;\n    orig -= vec3(0, 0, 0);\n    \n    vec3 dir = normalize(vec3(uv - res / 2.0, 0.5)) * rotate;\n    \n    //Ray marching\n    MarchResult hit = MarchRay(orig, dir);\n    \n    //Shading\n    vec3 color = Shade(hit, dir, orig);\n    \n    #ifdef SHOW_RAY_COST\n    color = mix(vec3(0,1,0), vec3(1,0,0), hit.steps / float(MAX_STEPS));\n    #endif\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2XDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[621, 693, 719, 719, 1008], [1010, 1064, 1097, 1097, 1122], [1124, 1124, 1157, 1157, 1184], [1186, 1186, 1219, 1219, 1244], [1246, 1274, 1315, 1315, 1408], [1410, 1410, 1444, 1444, 1617], [1619, 1619, 1654, 1654, 1680], [1682, 1682, 1715, 1715, 1758], [1760, 1760, 1795, 1795, 1854], [1856, 1856, 1888, 1888, 1919], [1921, 1921, 1952, 1952, 2014], [2070, 2086, 2110, 2110, 2715], [2717, 2762, 2787, 2787, 3039], [3084, 3108, 3129, 3129, 4715], [4718, 4759, 4780, 4780, 5048], [5050, 5090, 5132, 5132, 5639], [5641, 5667, 5725, 5725, 6311], [6313, 6313, 6370, 6370, 7352]], "test": "valid"}
{"id": "XtBSWz", "name": "Sprite Fonts", "author": "4rknova", "description": "Font rendering.\nBased on [url=https://www.shadertoy.com/view/llSGRm]FlyGuy's shader[/url]", "tags": ["fonts"], "likes": 20, "viewed": 1167, "published": "Public API", "date": "1442668645", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// by Nikos Papadopoulos, 4rknova / 2015\n// WTFPL\n\n// Based on FlyGuy's shader: https://www.shadertoy.com/view/llSGRm\n#define FONTSC_SZ vec2(2.5, 5)     // Font size\n#define SCREEN_SZ vec2(800, 600) // Screen size\n#define CHR       vec4(6,7,6.*FONTSC_SZ.x,9.*FONTSC_SZ.y)  // Character size (xy), spacing(zw)\n#define STR_SZ(c) vec2(c*CHR.zw) // String size\n#define DWN_SC    2.             // Downscale\n\n#define C vec2\nC c_spc = C(      0,      0), c_exc = C( 276705,  32776), c_quo = C(1797408,      0)\n, c_hsh = C(  10738,1134484), c_dol = C( 538883,  19976), c_pct = C(1664033,  68006)\n, c_amp = C( 545090, 174362), c_apo = C( 798848,      0), c_lbr = C( 270466,  66568)\n, c_rbr = C( 528449,  33296), c_ast = C(  10471,1688832), c_crs = C(   4167,1606144)\n, c_per = C(      0,   1560), c_dsh = C(      7,1572864), c_com = C(      0,   1544)\n, c_lsl = C(   1057,  67584), c_0   = C( 935221, 731292), c_1   = C( 274497,  33308)\n, c_2   = C( 934929,1116222), c_3   = C( 934931,1058972), c_4   = C( 137380,1302788)\n, c_5   = C(2048263,1058972), c_6   = C( 401671,1190044), c_7   = C(2032673,  66576)\n, c_8   = C( 935187,1190044), c_9   = C( 935187,1581336), c_col = C(    195,   1560)\n, c_scl = C(    195,   1544), c_les = C( 135300,  66052), c_equ = C(    496,   3968)\n, c_grt = C( 528416, 541200), c_que = C( 934929,1081352), c_ats = C( 935285, 714780)\n, c_A   = C( 935188, 780450), c_B   = C(1983767,1190076), c_C   = C( 935172, 133276)\n, c_D   = C(1983764, 665788), c_E   = C(2048263,1181758), c_F   = C(2048263,1181728)\n, c_G   = C( 935173,1714334), c_H   = C(1131799,1714338), c_I   = C( 921665,  33308)\n, c_J   = C(  66576, 665756), c_K   = C(1132870, 166178), c_L   = C(1065220, 133182)\n, c_M   = C(1142100, 665762), c_N   = C(1140052,1714338), c_O   = C( 935188, 665756)\n, c_P   = C(1983767,1181728), c_Q   = C( 935188, 698650), c_R   = C(1983767,1198242)\n, c_S   = C( 935171,1058972), c_T   = C(2035777,  33288), c_U   = C(1131796, 665756)\n, c_V   = C(1131796, 664840), c_W   = C(1131861, 699028), c_X   = C(1131681,  84130)\n, c_Y   = C(1131794,1081864), c_Z   = C(1968194, 133180), c_lsb = C( 925826,  66588)\n, c_rsl = C(  16513,  16512), c_rsb = C( 919584,1065244), c_pow = C( 272656,      0)\n, c_usc = C(      0,     62), c_a   = C(    224, 649374), c_b   = C(1065444, 665788)\n, c_c   = C(    228, 657564), c_d   = C(  66804, 665758), c_e   = C(    228, 772124)\n, c_f   = C( 401543,1115152), c_g   = C(    244, 665474), c_h   = C(1065444, 665762)\n, c_i   = C( 262209,  33292), c_j   = C( 131168,1066252), c_k   = C(1065253, 199204)\n, c_l   = C( 266305,  33292), c_m   = C(    421, 698530), c_n   = C(    452,1198372)\n, c_o   = C(    228, 665756), c_p   = C(    484, 667424), c_q   = C(    244, 665474)\n, c_r   = C(    354, 590904), c_s   = C(    228, 114844), c_t   = C(   8674,  66824)\n, c_u   = C(    292,1198868), c_v   = C(    276, 664840), c_w   = C(    276, 700308)\n, c_x   = C(    292,1149220), c_y   = C(    292,1163824), c_z   = C(    480,1148988)\n, c_lpa = C( 401542,  66572), c_bar = C( 266304,  33288), c_rpa = C( 788512,1589528)\n, c_tid = C( 675840,      0), c_lar = C(   8387,1147904);\n\nvec2 carret = vec2(0);\n\n// Returns the digit sprite for the given number.\nvec2 digit(float d) {    \n    vec3 r = vec3(0, 0, floor(d));\n         if (r.z == 0.) r.xy = c_0; else if (r.z == 1.) r.xy = c_1;\n    else if (r.z == 2.) r.xy = c_2; else if (r.z == 3.) r.xy = c_3;\n    else if (r.z == 4.) r.xy = c_4; else if (r.z == 5.) r.xy = c_5;\n    else if (r.z == 6.) r.xy = c_6; else if (r.z == 7.) r.xy = c_7;\n    else if (r.z == 8.) r.xy = c_8; else if (r.z == 9.) r.xy = c_9;\n    return r.xy;\n}\n// Extracts bit\nfloat bit(float n, float b) {\n    b = clamp(b,-1.,22.);\n    return floor(mod(floor(n / pow(2.,floor(b))),2.));\n}\n// Returns the pixel at uv in the given bit-packed sprite.\nfloat spr(vec2 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv/ FONTSC_SZ);\n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float b = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    \n    return bounds ? bit(spr.x, b - 21.0) + bit(spr.y, b) : 0.0;\n}\n// Prints a character and moves the carret forward by 1 character width.\nfloat print_char(vec2 ch, vec2 uv) { \n    float px = spr(ch, CHR.xy, uv - carret);\n    carret.x += CHR.z;\n    return px;\n}\n// Prints out the given number starting at pos.\nfloat print_number(float number,vec2 pos, vec2 uv)\n{\n\tvec2 dec_pos = pos;\n    float result = 0.;\n    \n\tfor(int i = 3; i >= -2; --i) {\n        //Clip off leading zeros.\n        float clip = float(abs(number) > pow(10.0, float(i)) || i == 0);        \n        float d = mod(number / pow(10., float(i)),10.);\n        \n        if(i == -1) {\n            result += spr(c_per,CHR.xy, uv - dec_pos) * clip;\n            dec_pos.x += CHR.z * clip;\n        }\n        \n        result += spr(digit(d),CHR.xy, uv - dec_pos) * clip;\n        dec_pos.x += CHR.z * clip;\n    }\n    \n    return result;\n}\n\n#define T(x) print_char(x,uv)\nfloat Text(vec2 uv)\n{    \n    vec2 res = iResolution.xy / DWN_SC,\n         pos = vec2(150,350.5-2.*CHR.y);\n    \n    carret = pos;\n    \n\tfloat r = 0.;\n    r += T(c_A) + T(c_B) + T(c_C) + T(c_D) + T(c_E) + T(c_F)\n       + T(c_G) + T(c_H) + T(c_I) + T(c_J) + T(c_K) + T(c_L)\n       + T(c_M) + T(c_N) + T(c_O) + T(c_P) + T(c_Q) + T(c_R)\n       + T(c_S) + T(c_T) + T(c_U) + T(c_V) + T(c_W) + T(c_X)\n       + T(c_Y) + T(c_Z);\n    \n    carret = pos + vec2(0, -40.);\n    \n    r += T(c_a) + T(c_b) + T(c_c) + T(c_d) + T(c_e) + T(c_f)\n       + T(c_g) + T(c_h) + T(c_i) + T(c_j) + T(c_k) + T(c_l)\n       + T(c_m) + T(c_n) + T(c_o) + T(c_p) + T(c_q) + T(c_r)\n       + T(c_s) + T(c_t) + T(c_u) + T(c_v) + T(c_w) + T(c_x)\n       + T(c_y) + T(c_z);\n    \n    \n    carret = pos + vec2(0, -80.);\n    r += T(c_0) + T(c_1) + T(c_2) + T(c_3) + T(c_4) + T(c_5)\n       + T(c_6) + T(c_7) + T(c_8) + T(c_9);\n    \n    carret = pos + vec2(0, -120.);\n    r += T(c_exc) + T(c_quo) + T(c_hsh) + T(c_dol) + T(c_pct)\n       + T(c_amp) + T(c_apo) + T(c_lbr) + T(c_rbr) + T(c_ast)\n       + T(c_crs) + T(c_per) + T(c_dsh) + T(c_com) + T(c_lsl)\n       + T(c_col) + T(c_scl) + T(c_les) + T(c_equ) + T(c_grt)\n       + T(c_que) + T(c_ats) + T(c_lsb) + T(c_rsl) + T(c_rsb)\n       + T(c_pow) + T(c_quo) + T(c_usc) + T(c_lpa) + T(c_bar)\n       + T(c_rpa) + T(c_tid) + T(c_lar) + T(c_spc);\n        \n\tr += print_number(iTime, pos + vec2(1,50), uv);\n    \n    return r;\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec2 uv = p.xy / iResolution.xy * SCREEN_SZ;\n\tc = vec4(vec3(1,0,0) * Text(uv),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBSWz.jpg", "access": "shaders20k", "license": "wtfpl-2.0", "functions": [[3137, 3187, 3208, 3208, 3606], [3607, 3623, 3652, 3652, 3735], [3736, 3795, 3836, 3836, 4235], [4236, 4309, 4345, 4345, 4431], [4432, 4480, 4532, 4532, 5063], [5095, 5095, 5116, 5116, 6520], [6522, 6522, 6558, 6558, 6646]], "test": "valid"}
{"id": "XtBXDD", "name": "3D Flower", "author": "vox", "description": "flower", "tags": ["flower"], "likes": 11, "viewed": 1250, "published": "Public API", "date": "1443570311", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Spiral Fractal (?)\n// (c) ivan weston 2015\n\n#define PI 3.14159265359\n#define E 2.7182818284\n//#define iTime 2.0*tan(1.0*iTime)\n\nfloat height(vec2 uv)\n{\n    float r = length(uv);\n    \n    if(r > 1.0) return 10.0;\n    \n    float sum = 0.0;\n    \n    \n    \n    for(int i = 0 ; i < 12; i++)\n    {\n        \n        //if(i < 64+int(sin(iTime)*64.0))\n        {\n            \n            //float theta1 = (7.0*atan(uv.y, uv.x)-r*PI*4.0*cos(float(i)+iTime))+ cos(iTime);\n\n            float awesome = pow(clamp(1.0-acos(cos((7.0*atan(uv.y, uv.x)-r*PI*4.0*cos(float(i)+iTime))+ cos(iTime))), 0.0, 1.0), PI);\n\n            sum = (sum+awesome);\n        }\n    \n    }\n    return -sum;\n}\n\nvec2 flower(vec3 p, vec3 d)\n{\n    \n    float zoom = 1.0;\n        \n    vec2 uv = p.xz*zoom/2.0;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv = vec2(uv.x*cos(iTime)-uv.y*sin(iTime),\n                 uv.x*sin(iTime)+uv.y*cos(iTime));\n    \n    //fragColor = 1.0-vec4(1.0-pow(1.0/E,2.0*PI*clamp(length(uv), 0.0, 1.0)));\n    \n    vec2 uv2 = uv + vec2(.01/iResolution.x,  0.0);\n    vec2 uv3 = uv + vec2(0.0,  .01/iResolution.y);\n    \n    vec3 p1 = vec3(uv, height(uv)).xzy;\n    vec3 p2 = vec3(uv2, height(uv2)).xzy;\n    vec3 p3 = vec3(uv3, height(uv3)).xzy;\n    \n    vec3 n = normalize(cross(p3-p1, p2-p1));\n    \n    return vec2(dot(p-p1, n), p1.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy*2.0-1.0;\n    \n    \n    vec3 origin = vec3(0.0, 1.0, 0.0);\n    vec3 rayOrigin = vec3(0.0, 1.5, .25);\n    vec3 rayPos = rayOrigin.xyz;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 mainDir = normalize(origin-rayPos);\n    vec3 right = normalize(cross(up, mainDir));\n    up = normalize(cross(right, mainDir));\n    vec3 rayDir = normalize(mainDir-up*uv.y+right*uv.x);\n\n    \n    for(float t = 0.0; t < 100.0; t += 2.5)\n    {\n        vec2 dist = flower(rayPos, rayDir);\n        rayPos += .1*rayDir;\n        if( rayPos.y - dist.y < 0.0)\n            break;\n        else if(length(rayPos-rayOrigin) >= 10.0 )\n        {\n            fragColor = vec4(1.0);\n            return;\n        }\n    }\n    \n    \n    vec2 sum = flower(rayPos, rayDir);\n    \n    fragColor.r = 1.0-pow(cos(rayPos.y*1.0+cos(iTime*1.0)), 2.0);\n    fragColor.g = 1.0-pow(cos(rayPos.y*1.0+cos(iTime*2.0)), 2.0);\n    fragColor.b = 1.0-pow(cos(rayPos.y*1.0+cos(iTime*3.0)), 2.0);\n    //fragColor.rgb *= sum.y-;\n    \n//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBXDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 154, 154, 671], [673, 673, 702, 702, 1330], [1332, 1332, 1389, 1389, 2450]], "test": "valid"}
{"id": "XtBXRm", "name": "Solar Flower", "author": "aiekick", "description": "Solar Flower", "tags": ["sss", "ray", "fake", "flower", "solar"], "likes": 47, "viewed": 3768, "published": "Public API", "date": "1442333192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define shape(p) length(p)-2.8\n    \nconst vec2 RMPrec = vec2(.2, 0.001); \nconst vec3 DPrec = vec3(0.005, 12., 1e-6); \n    \n// by shane\nfloat Voronesque( in vec3 p )\n{\n    vec3 i  = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec3 rnd = vec3(7, 157, 113); // I use this combination to pay homage to Shadertoy.com. :)\n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    d = fract(sin(d)*262144.)*v*2.; \n    v.x = max(d.x, d.y), v.y = max(d.z, d.w), v.z = max(min(d.x, d.y), min(d.z, d.w)), v.w = min(v.x, v.y); \n    return  max(v.x, v.y) - max(v.z, v.w); // Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n}\n\nvec2 map(vec3 p)\n{\n\tvec2 res = vec2(0.);\n\n\tfloat voro = Voronesque(p);\n\t\n   \tvec3 col = vec3(voro)*.5;\n\t\n\tfloat sphere = shape(p);\n    float sphereOut = sphere - voro;\n    float sphereIn = sphere + voro * .5;\n    \n   \tfloat dist = max(-sphereIn, sphereOut + .29);\n               \n\tres = vec2(dist, 1.);\n\t\n\tfloat kernel = sphere + 2.2;\n    \n\tif (kernel < res.x ) \n\t\tres = vec2(kernel, 2.);\n\t\n\treturn res;\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n        map(pos+e.xyy).x - map(pos-e.xyy).x,\n        map(pos+e.yxy).x - map(pos-e.yxy).x,\n        map(pos+e.yyx).x - map(pos-e.yyx).x );\n    return normalize(n);\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv)\n{\n\tvec3 rov = normalize(cv-ro);\n    vec3 u =  normalize(cross(cu, rov));\n    vec3 v =  normalize(cross(rov, u));\n    vec3 rd = normalize(rov + u*uv.x + v*uv.y);\n    return rd;\n}\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// light\nconst vec3 LPos = vec3(-0.6, 0.7, -0.5);\nconst vec3 LAmb = vec3( 0. );\nconst vec3 LDif = vec3( 1. , 0.5, 0. );\nconst vec3 LSpe = vec3( 0.8 );\n\n// material\nconst vec3 MAmb = vec3( 0. );\nconst vec3 MDif = vec3( 1. , 0.5, 0. );\nconst vec3 MSpe = vec3( 0.6, 0.6, 0.6 );\nconst float MShi =30.;\n\nvec3 ads( vec3 p, vec3 n )\n{\n    vec3 ldif = normalize( LPos - p);\n    vec3 vv = normalize( vec3(0.) - p );\n    vec3 refl = reflect( vec3(0.) - ldif, n );\n    \n    vec3 amb = MAmb*LAmb+ blackbody(2000.);\n    vec3 dif = max(0., dot(ldif, n.xyz)) * MDif * LDif;\n    vec3 spe = vec3( 0. );\n    if( dot(ldif, vv) > 0.)\n        spe = pow(max(0., dot(vv,refl)),MShi)*MSpe*LSpe;\n    \n    return amb*1.2 + dif*1.5 + spe*0.8;\n}\n\nvec3 nrand3( vec2 co )\n{\n\tvec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\n\tvec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\n\tvec3 c = mix(a, b, 0.5);\n\treturn c;\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n    vec2 si = iResolution.xy;\n\tfloat t = iTime;\n    \n    float ca = t*.14; // angle z\n    float ce = 1.; // elevation\n    float cd = 1.; // distance to origin axis\n   \t\n    vec3 cu=vec3(0,1,0);//Change camere up vector here\n    vec3 cv=vec3(0,0,0); //Change camere view here\n    vec2 uv = (g+g-si)/min(si.x, si.y);\n    vec3 ro = vec3(sin(ca)*cd, ce+1., cos(ca)*cd); //\n    vec3 rd = cam(uv, ro, cu, cv);\n    \n    vec3 d = vec3(0.);\n    vec3 p = ro+rd*d.x;\n    vec2 s = vec2(DPrec.y);\n    \n    for(int i=0;i<200;i++)\n    {      \n\t\tif(s.x<DPrec.x||s.x>DPrec.y) break;\n        s = map(p);\n\t\ts.x *= (s.x>DPrec.x?RMPrec.x:RMPrec.y);\n        d.x += s.x;\n        p = ro+rd*d.x;\n   \t}\n\t\n\tif (d.x<DPrec.y)\n    {\n\t\tfloat nPrec = 0.1;\n\t\tvec3 n = nor(p, nPrec);\n\t\t\n    \tif ( s.y < 1.5) // rock\n        {\n\t\t\tvec3 SSS = ads(n,n) - ads(p, rd);\n\t\t\tSSS += blackbody(1500. * (d.x - 3.));\n\t\t\tf.rgb = SSS;\n        }\n\t\telse if( s.y < 2.5) // kernel\n\t\t{\n\t\t\tfloat b = dot(n,normalize(ro-p))*0.9;\n            f = (b*vec4(blackbody(2000.),0.8)+pow(b,0.2))*(1.0-d.x*.01);\n\t\t}\t\n   \t}\n    else\n    {\n\t\tvec3 rnd = nrand3( floor(uv * 2.0 * iResolution.x) );\n\t\tf = vec4(pow(rnd.y,10.0));\n\t}\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBXRm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[261, 273, 304, 304, 1084], [1086, 1086, 1104, 1104, 1491], [1493, 1493, 1527, 1527, 1741], [1743, 1743, 1789, 1789, 1965], [1967, 1967, 1995, 1995, 2320], [2621, 2621, 2649, 2649, 3039], [3041, 3041, 3065, 3065, 3248], [3250, 3250, 3291, 3291, 4453]], "test": "valid"}
{"id": "XtjSRm", "name": "Weird Canyon", "author": "aiekick", "description": "it was an attempt in my terrain experiment study to do an antelope canyon\nbut failed to sculpt it realistic, and failed to do a good lighting.\nthe sand is weird also ^^\nI must deepen the learning of light technics:)", "tags": ["weird", "canyon"], "likes": 36, "viewed": 4229, "published": "Public API", "date": "1442495185", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n/* Weird Canyon\nit was an attempt in my terrain experiment study to do an antelope canyon\nbut failed to sculpt it realistic, and failed to do a good lighting.\nthe sand is weird also ^^\nI must deepen the learning of light technics:)\nthe screenshot is at 44.93s\nthe mouse axis y control the vertical angle of the cam\n*/ \n\n#define mPi 3.14159\n#define m2Pi 6.28318\n\nfloat dstepf = 0.0;\n\nconst vec2 NoiseVar = vec2(950.,200.);\n    \nconst vec2 RMPrec = vec2(.3, 0.0001); \nconst vec2 DPrec = vec2(0.001, 40.); \n\nfloat random(float p) {return fract(sin(p)*NoiseVar.x);}\nfloat mynoise(vec2 p) {return random(p.x + p.y*NoiseVar.y);}\nvec2 sw(vec2 p) {return vec2( floor(p.x) , floor(p.y) );}\nvec2 se(vec2 p) {return vec2( ceil(p.x)  , floor(p.y) );}\nvec2 nw(vec2 p) {return vec2( floor(p.x) , ceil(p.y)  );}\nvec2 ne(vec2 p) {return vec2( ceil(p.x)  , ceil(p.y)  );}\nfloat snoise(vec2 p) {\n  \tvec2 inter = smoothstep(0., 1., fract(p));\n  \tfloat s = mix(mynoise(sw(p)), mynoise(se(p)), inter.x);\n  \tfloat n = mix(mynoise(nw(p)), mynoise(ne(p)), inter.x);\n  \treturn mix(s, n, inter.y);\n}\n\n//https://www.shadertoy.com/view/llsXzB\n//https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model\nvec3 OrenNayarLightModel(vec3 rd, vec3 ld, vec3 n, float albedo)\n{\n\tvec3 col = vec3(0.);\n\tfloat RDdotN = dot(-rd, n);\n\tfloat NdotLD = dot(n, ld);\n    float aRDN = acos(RDdotN);\n\tfloat aNLD = acos(NdotLD);\n\tfloat mu = 5.; // roughness\n\tfloat A = 1.-.5*mu*mu/(mu*mu+0.57);\n    float B = .45*mu*mu/(mu*mu+0.09);\n\tfloat alpha = max(aRDN, aNLD);\n\tfloat beta = min(aRDN, aNLD);\n\tfloat e0 = 4.8;\n\tcol = vec3(albedo / mPi) * cos(aNLD) * (A + ( B * max(0.,cos(aRDN - aNLD)) * sin(alpha) * tan(beta)))*e0;\n\treturn col;\n}\n\n//https://www.shadertoy.com/view/Xl23Rc\nvec3 strate(vec2 uv)\n{\n    vec3 col1 = vec3(.94,.7,.25);\n    vec3 col2 = vec3(.91,.67,.11);\n    float y = uv.y+.85*sin(-uv.x);\n    y/=.85;\n    float r = sin(25.*y)+cos(16.*y)+cos(19.*y);\n    vec3 col = mix(col1, col2, r);\n    return col;\n}\n\n// shane code\nfloat Voronesque( in vec3 p )\n{\n    vec3 i  = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec3 rnd = vec3(7, 157, 113); \n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    d = fract(sin(d)*262144.)*v*2.; \n    v.x = max(d.x, d.y), v.y = max(d.z, d.w); \n    return max(v.x, v.y); \n}\n\n// used to compute campath and plane deformation along z\nfloat sinPath(vec3 p, float dec){return 6.4 * sin(p.z * .33 + dec);}\n\nvec2 map(vec3 p)\n{\n    vec2 res = vec2(0.);\n\n\tdstepf += .0007;\n\t\n\tfloat pathLeft = sinPath(p, 0.);\n\tfloat pathRight = sinPath(p, 19.5);\n\t\n\tfloat voro = Voronesque(p/12.) * 7.6;\n\tfloat strateDisp = dot(strate(p.zy), vec3(.043));\n\tfloat strateNoise = snoise(p.zy/.5) *.2;\n    float microNoise = snoise(p.zy/.01) *.02;\n\t\n    float disp =  voro - strateDisp - strateNoise + microNoise;\n    \n\tfloat bottom = p.y + 2. - snoise(p.xz) * .38- snoise(p.xz/.039) * .05;\n\tres = vec2(bottom, 1.);\n\t\n\tfloat left = p.x + pathLeft + 2. + disp;\n\tif (left < res.x)\n\t\tres = vec2(left, 2.);\n\t\n\tfloat right = 2. - p.x - pathRight + disp;\n\tif (right < res.x)\n\t\tres = vec2(right, 3.);\n\t\n\treturn res;\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tmap(pos+e.xyy).x - map(pos-e.xyy).x,\n\t\tmap(pos+e.yxy).x - map(pos-e.yxy).x,\n\t\tmap(pos+e.yyx).x - map(pos-e.yyx).x );\n    return normalize(n);\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv)\n{\n\tvec3 rov = normalize(cv-ro);\n    vec3 u =  normalize(cross(cu, rov));\n    vec3 v =  normalize(cross(rov, u));\n    vec3 rd = normalize(rov + u*uv.x + v*uv.y);\n    return rd;\n}\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n// from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 lighting(vec3 col, vec3 p, vec3 n, vec3 rd, vec3 ref, float t) // lighting    \n{\n\t// from iq code\n\tfloat occ = calcAO( p, n );\n\tvec3  lig = normalize( vec3(0., 1., 0.) );\n\tfloat amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n\tfloat dif = clamp( dot( n, lig ), 0.0, 1.0 );\n\tfloat bac = clamp( dot( n, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-p.y,0.0,1.0);\n\tfloat dom = smoothstep( -0.1, 0.1, ref.y );\n\tfloat fre = pow( clamp(1.0+dot(n,rd),0.0,1.0), 2.0 );\n\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n\tdif *= softshadow( p, lig, 0.02, 2.5 );\n\tdom *= softshadow( p, ref, 0.02, 2.5 );\n\n\tvec3 brdf = vec3(0.0);\n\tbrdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n\tbrdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n\tbrdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n\tbrdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n\tbrdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\tbrdf += 0.02;\n\tcol = col*brdf;\n\n\tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n    vec2 si = iResolution.xy;\n\tvec2 uv = (g+g-si)/min(si.x, si.y);\n\tvec2 q = g/si;\n    \n    float t = iTime*3.;\n\t\n\tvec4 gp = vec4(0.); //uGamePad360;\n\t\n    vec3 cu = vec3(0,1,0);\n    vec3 ro = vec3(0., gp.y + 1., t);\n\tvec3 cv = vec3(gp.zw,.08); \n    if (iMouse.z>0.) \n    {\n        cv.y = iMouse.y/iResolution.y*.8 - .5;\n        cv.x = iMouse.x/iResolution.x*.8 - .5;\n    }\n    float cx = (sinPath(ro + cv, 0.) + sinPath(ro + cv, 19.5))/2.;\n\tro.x -= cx;\n\tvec3 rd = cam(uv, ro, cu, ro + cv);\n\t\n    vec3 d = vec3(0.);\n    vec3 p = ro+rd*d.x;\n    vec2 s = vec2(DPrec.y,0.);\n\t\n    for(int i=0;i<200;i++)\n\t{      \n\t\tif(s.x<DPrec.x||s.x>DPrec.y) break;\n        s = map(p);\n\t\ts.x *= (s.x>DPrec.x?RMPrec.x:RMPrec.y);;\n\t\td.x += s.x;\n        p = ro+rd*d.x;\n   \t}\n\t\n\tif (d.x<DPrec.y)\n\t{\n\t\tvec3 n = nor(p, .05);\n        if(s.y < 3.5)\n\t\t{\n\t\t\tf.rgb = OrenNayarLightModel(rd, rd, n, 0.3);\t\n\t\t\tf.rgb += vec3(.94, .71, .53);\t\t\n\t\t}\n\t\tif (s.y < 1.5) // bottom\n        {\n\t\t\tf.rgb = OrenNayarLightModel(reflect(rd,n), rd, n, .75);\t\n\t\t\tf.rgb += vec3(.98,.76,.24);\n\t\t}\n\t\t\n\t\t\n\t\tf.rgb = lighting(f.rgb, p, n, rd, rd, d.x); // lighting    \n   \t}\n    else\n    {\n        //https://www.shadertoy.com/view/4ssXW2\n        vec3 sun = vec3(1.0, .88, .75);;\n        float v = pow(1.0-max(rd.y,0.0),10.);\n\t\tf.rgb = vec3(v*sun.x*0.42+.04, v*sun.y*0.4+0.09, v*sun.z*0.4+.17);\n    }\n\n\t// vigneting  https://www.shadertoy.com/view/MsXGWr\n    f.rgb *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 );\t   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjSRm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[700, 700, 723, 723, 756], [757, 757, 780, 780, 817], [818, 818, 835, 835, 875], [876, 876, 893, 893, 933], [934, 934, 951, 951, 991], [992, 992, 1009, 1009, 1049], [1050, 1050, 1072, 1072, 1268], [1270, 1379, 1445, 1445, 1889], [1891, 1931, 1953, 1953, 2170], [2172, 2186, 2217, 2217, 2783], [2785, 2842, 2875, 2875, 2910], [2912, 2912, 2930, 2930, 3590], [3592, 3592, 3626, 3626, 3822], [3824, 3824, 3870, 3870, 4046], [4048, 4064, 4138, 4138, 4399], [4401, 4417, 4459, 4459, 4758], [4760, 4760, 4845, 4862, 5775], [5777, 5777, 5818, 5818, 7293]], "test": "valid"}
{"id": "XtjSzw", "name": "Waving circles", "author": "vamoss", "description": "Studying shaders, trying to achieve this image:\nhttp://beesandbombs.tumblr.com/image/121790476454", "tags": ["circles", "waving"], "likes": 11, "viewed": 422, "published": "Public", "date": "1442470167", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Shader by Vamoss\n// 17/09/2015\n// Reference image\n// http://beesandbombs.tumblr.com/image/121790476454\n\n#define TWO_PI 6.28318530718\n\n//  Function from Iigo Quiles \n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0, \n                     0.0, \n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 getColor(in float angle){\n \t// Map the angle (-PI to PI) to the Hue (from 0 to 1)\n    return hsb2rgb(vec3(angle,1.0,1.0));   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n    \n    float radius = 0.3;\n    \n    //tile\n    vec2 frequency = vec2(22.0, 12.0);\n    vec2 index = floor(frequency * st)/frequency;\n    float centerDist = 1.0-length(index-0.5);\n    vec2 nearest = 2.0 * fract(frequency * st) - 1.0;\n    \n    //movement\n    float velocity = 5.0;\n    nearest.x += cos(iTime * velocity + centerDist * TWO_PI)*(1.0-radius);\n    nearest.y += sin(iTime * velocity + centerDist * TWO_PI)*(1.0-radius);\n    \n    //circle\n    float dist = length(nearest);\n    float circle = step(radius, dist);\n    \n    //colors\n    vec3 bgColor = vec3(0.0, 0.0, 0.0);\n    \n    float colorAngle = iTime + centerDist * 2.0;\n    vec3 circleColor = getColor(colorAngle);\n    \n    vec3 color = mix(circleColor, bgColor, circle);\n    \n    fragColor = vec4(color, 1.0);\n    //fragColor = vec4(vec3(centerDist), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjSzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 214, 240, 240, 475], [477, 477, 507, 563, 609], [612, 612, 669, 669, 1532]], "test": "valid"}
{"id": "XtjXR1", "name": "Circle Graph", "author": "ridhojeftha", "description": "A circle graph that has segments that increase in size according to its percentage", "tags": ["circlegraph"], "likes": 2, "viewed": 224, "published": "Public", "date": "1441631860", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//inverse of Pi to use for angle formula conversion\nconst float inversePi = 1.0 / 3.141592;\n\n//start - where the segment should start - normalised to (0, 1)\n//segLength - the length of the segment\n//distance = the distance from the pixel to the origin\n//radius - the inner radius\n//angle - the angle of the pixel around the circle\nfloat getCircleSegment(float start, float segLength, float distanceO, float radius, float angle)\n{\n  float circle;\n    \n  //the amount of blur to add for anti-aliasing\n  float blur = 0.005;\n    \n  float width = radius + segLength*0.5; //segment length determines the width\n \n  //add a circle\n  circle = smoothstep( width + blur, width - blur, distanceO); \n        \n  //subtract the hole from the centre\n  circle -= smoothstep(radius + blur, radius - blur, distanceO);\n    \n  //add the segment\n  float segment = smoothstep(start + segLength + blur*0.5, start + segLength - blur*0.5, angle);\n  segment -= smoothstep(start + blur*0.5,  start - blur*0.5, angle ); \n    \n    \n  circle *= mix( segment, 1.0, step( 1.0, segLength ) );\n    \n  return circle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float timeScale = 0.5;\n    \n    float p1 = 0.1 + 0.30 * abs (sin (iTime * timeScale)); //yellow\n\t\n    float p2 = 0.1 + 0.30 * abs (cos (iTime * timeScale)); //red\n    \n\tfloat p3 = 0.05 + 0.1 * abs (sin (iTime * timeScale)); //green\n    \n\tfloat p4 = 1.0 - (p1 + p2 + p3); //blue\n    \n    float radius = 0.35; //Range (0f, 1f]\n\tvec2 uv = fragCoord.xy / iResolution.xy; // calculate the texture coords\n    \n    // Convert from range [0,1] to [-1,1]\n    uv = 2.0 * uv - 1.0;\n    \n    // this line adjusts for the aspect ratio\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    // distance to the Origin\n    float distanceO = length( uv );\n    \n    //calculate the angle for the segments uding formula\n\tfloat angle = atan( uv.x, uv. y ) * inversePi * 0.5;\n    \n     //can add ofsett here to rotate the circle\n    float offset = 0.0;//0.1 * iTime; //using time to make it rotate for demo purposes\n\tangle = fract( angle + offset );\n    \n    vec3 rgb;  \n    \n    //draw the four segments in different colours\n     rgb = vec3( 1.0, 1.0, 0.0) * getCircleSegment(0.0, p1, distanceO, radius, angle);        \n\t rgb += vec3( 1.0, 0.0, 0.0 ) * getCircleSegment(p1, p2, distanceO, radius, angle); \n \t rgb += vec3( 0.0, 1.4, 0.0 ) * getCircleSegment(p1+p2, p3, distanceO, radius, angle);  \n     rgb += vec3( 0.0, 0.0, 1.0 ) *  getCircleSegment(p1+p2+p3, p4, distanceO, radius, angle); \n  \n    fragColor = vec4( rgb, 1);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjXR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 331, 429, 429, 1082], [1084, 1084, 1141, 1141, 2561]], "test": "valid"}
{"id": "XtSSWW", "name": "Bitwise stuff", "author": "qwert33", "description": "Implementing per-bit integer operations as they are not implemented by default.\nAnd then applying a nonlinear transformation on top of it", "tags": ["bit"], "likes": 8, "viewed": 377, "published": "Public", "date": "1443482263", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nbool XOR(bool a, bool b) {\n    return (a && !b) || (b && !a);\n}\n\nbool AND(bool a, bool b) {\n    return a && b;\n}\n\nint bitwiseOperation(int x, int y) {\n    int outval = 0;\n    ivec2 xy = ivec2(x,y);\n    for (int i=0; i<30; ++i) {\n        ivec2 shift = xy / 2;\n        \n        ivec2 lowestBit = xy - shift * 2;\n        \n        //outval *= 2;  // if this is disabled, we count the bits rather than interpret the number\n        if (XOR(lowestBit.x != 0, lowestBit.y != 0)) {\n           outval += 1;\n        }\n        \n        xy = shift;\n    }\n    return outval;\n}\n\n// makes a rotation matrix\nmat2 rotate(float theta) {\n    float s = sin(theta);\n    float c = cos(theta);\n    return mat2(\n        c, -s,\n        s,  c\n    );\n}\nconst float pi = 3.14159265359;\n\nvec2 swirl(vec2 toSwirl, vec2 center, float amonut) {\n    float rotateRadius = 1.04;\n    vec2 p = toSwirl; // out\n    p -= center;\n    p *= rotate((rotateRadius / -length(p)) * amonut);\n    p += center;\n\treturn p;\n}\n\n// makes a function looking like a staircase\nfloat stairs(float x, float stepSize) {\n    float y = (floor(x / stepSize) + 0.5);\n    y *= 2.0 * stepSize;\n    y += stepSize * y/abs(y);\n    y *= 0.5;\n    return y;\n}\n\nvec2 doubleSwirl(vec2 toSwirl, float theta) {\n    vec2 p = toSwirl; // out\n    float y = 0.5 * p.x*p.x / p.y  +  0.5 * p.y;\n    y = stairs(y, 30.0);\n    \n    // why this is necessary?\n    \n    \n    vec2 center = vec2(0.0, y);\n    p -= center;\n    //if (abs(p.y) < 2.1) return vec2(0.0);\n    p *= rotate(theta / (2.0 * pi * center.y));\n    p += center;\n    return p;\n\n}\n\nvec4 main2(in vec2 fragCoord) {\n    \n    const float timeScale = 5.0;\n    const float repeatPeriod = 10.0;\n    float time = iTime * timeScale;\n    time = mod(time, repeatPeriod * timeScale);\n    fragCoord -= iResolution.xy / 2.0;\n    vec2 p = fragCoord;\n    \n    // do some non-linear transformations\n    p = doubleSwirl(p, time*100.0);\n    /*\n    vec2 translate = vec2(0.0, -100.0);\n    p = swirl(p, translate, time * 5.0);\n    p = swirl(\n        p, \n        swirl(-translate, translate, time * 5.0),\n        time * -5.0\n    );\n    */\n    \n    /*\n\n    p -= translate;\n    p *= rotate((rotateRadius / -length(p)) * -time*10.0);\n    p += translate;\n*/\n\n    /*\n\tfragCoord *= mat2(\n        0.5 * sin(time * 0.5),\n        0.5 * sin(time * 0.78),\n        0.5 * sin(time * 0.85),\n        0.5 * sin(time * 0.7)\n    );\n\t*/\n    int x = int(p.x);\n    int y = int(p.y);\n\tvec2 uv = p.xy / iResolution.xy;\n    int bit = bitwiseOperation(x, y);\n    float val = float(bit);\n    float exposure = 0.1;//iMouse.x / 3000.0;\n    val = 1.0 - exp(-val * exposure);\n    \n    return vec4(val);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = main2(fragCoord);\n    \n    if (true) {  // antialiasing\n        float AAradius = 0.5;\n        fragColor += main2(fragCoord + AAradius * vec2( 1.0,  0.0));\n        fragColor += main2(fragCoord + AAradius * vec2(-1.0,  0.0));\n        fragColor += main2(fragCoord + AAradius * vec2( 0.0,  1.0));\n        fragColor += main2(fragCoord + AAradius * vec2( 0.0, -1.0));\n        fragColor /= 5.0;\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSSWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 27, 27, 64], [66, 66, 92, 92, 113], [115, 115, 151, 151, 563], [565, 592, 618, 618, 725], [759, 759, 812, 812, 974], [976, 1021, 1060, 1060, 1188], [1190, 1190, 1235, 1235, 1558], [1560, 1560, 1591, 1591, 2631], [2633, 2633, 2690, 2690, 3107]], "test": "valid"}
{"id": "XtSXzw", "name": "something noise", "author": "nide", "description": "Playing with noise and color palettes", "tags": ["2d", "noise"], "likes": 7, "viewed": 329, "published": "Public", "date": "1442282287", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Simplex 2D noise\n// Unknown author\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    \n    float sinTime = sin(iTime*0.1);\n\n    float fc = iTime/50.0;\n    float fc2 = sin(iTime/2.0);\n    float sinTime2 = sin(iTime*0.04*6.28318);\n    float sinTime3 = sin(iTime*0.01*6.28318);\n    vec3 a = vec3(0.76,0.72,0.782);\n    vec3 b = vec3(0.25,0.35, 0.4);\n    vec3 c = vec3(0.8);\n    vec3 d = vec3(0);\n    p*=214.0+sinTime3*10.0;\n    float sd=0.3+0.8*fc;\n    float s4 = snoise(p+iTime*0.141);\n    p+=vec2(sin(fc*3.14), cos(fc*3.14))*122.0;\n    p*=0.015;\n    float s0 = snoise(p);\n    float s1 = snoise(p+vec2(0,1)*sd);\n    float s2 = snoise(p+vec2(1,0)*sd);\n    float s6 = snoise(p+vec2(s1,s2)-vec2(0.5));\n    float s = (s0+s1+s2)/1.4;\n    vec3 col = pal( s*7.0*sinTime*sinTime*sinTime*sinTime3+s*fc2, a, b, c,d );\n    vec3 col2 = pal( col.g*s6+fc2, vec3(1.14)*min(0.5,dot(col,vec3(0.333))), b*2.2, col,d );\n     col *= col2;\n   col = pow(col, vec3(4));\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSXzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 39, 61, 61, 100], [102, 102, 123, 123, 943], [944, 944, 1012, 1012, 1055], [1057, 1057, 1114, 1114, 2050]], "test": "valid"}
