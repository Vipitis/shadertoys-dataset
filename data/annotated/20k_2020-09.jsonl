{"id": "3d3cR2", "name": "Fantasy World Map", "author": "mhnewman", "description": "Let's go exploring!", "tags": ["procedural", "2d", "map", "mountains", "paper", "town", "world", "fantasy", "forrest", "worldbuilding"], "likes": 50, "viewed": 1394, "published": "Public", "date": "1601243769", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DRAW_TOWNS\n//#define GO_CRAZY\n\nconst float lineWidth = 0.5;\n\nconst float terrainScale = 80.0;\nconst vec3 landColor = vec3(0.9, 0.8, 0.7);\nconst vec3 shoreLineColor = vec3(0.0);\n\nconst float waterThreshold = -0.04;\nconst vec3 waterDeepColor = vec3(0.7, 0.8, 0.9);\nconst vec3 waterShallowColor = vec3(0.5, 0.6, 0.9);\nconst vec3 waterLineColor = vec3(0.0, 0.1, 0.3);\n\nconst float mountainWidth = 20.0;\nconst float mountainHeight = 16.0;\nconst float mountainThreshold = 0.23;\nconst vec3 mountainColor = vec3(0.5, 0.3, 0.1);\nconst vec3 mountainShadowColor = vec3(0.3, 0.2, 0.0);\nconst vec3 mountainLineColor = vec3(0.3, 0.1, 0.0);\n\nconst float treeScale = 3.5;\nconst float treeGrow = 1.5;\nconst float treeGrowthScale = 100.0;\nconst float treeGrowthThreshold = 0.08;\nconst float treeTerrainThresholdLow = 0.02;\nconst float treeTerrainThresholdHigh = 0.12;\nconst vec3 treeColor = vec3(0.3, 0.8, 0.4);\nconst vec3 treeShadowColor = vec3(0.0, 0.4, 0.2);\nconst vec3 treeLineColor = vec3(0.0, 0.3, 0.1);\n\nconst float townSpacing = 80.0;\nconst float buildingLineWidth = 0.3;\nconst float buildingSize = 5.0;\nconst float roofSize = 0.3;\nconst float urbanSprawl = 8.0;\nconst float townTerrainThresholdLow = 0.0;\nconst float townTerrainThresholdHigh = 0.18;\nconst float townTreeThreshold = 0.04;\n\nconst float paperTexture = 3.0;\nconst float dirt = 0.5;\nconst vec3 dirtColor = vec3(0.6, 0.3, 0.1);\n\nconst float vignetting = 0.4;\nconst vec3 vignettingColor = vec3(0.3, 0.2, 0.0);\n\n\nconst float pi = 3.14159265;\n\nconst float terrainScaleInv = 1.0 / terrainScale;\nconst float mountainWidthInv = 1.0 / mountainWidth;\nconst float mountainHeightInv = 1.0 / mountainHeight;\nconst float treeScaleInv = 1.0 / treeScale;\nconst float treeGrowthScaleInv = 1.0 / treeGrowthScale;\nconst float townSpacingInv = 1.0 / townSpacing;\nconst float buildingSizeInv = 1.0 / buildingSize;\n\nfloat aa;\nfloat lw;\nfloat blw;\nfloat bsdf;\n\n\nfloat hash1(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash2(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 hash3(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nfloat noise1(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash1(i + vec2(0.0, 0.0)), \n                   hash1(i + vec2(1.0, 0.0)), u.x),\n               mix(hash1(i + vec2(0.0, 1.0)), \n                   hash1(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nconst mat2 m = mat2(1.616, 1.212, -1.212, 1.616);\n\nfloat fbm1(vec2 p) {\n    float f = noise1(p) - 0.5; p = m * p;\n    f += 0.5 * (noise1(p) - 0.5); p = m * p;\n    f += 0.25 * (noise1(p) - 0.5);\n    return f / 1.75;\n}\n\nfloat fbm1high(vec2 p) {\n    float f = noise1(p) - 0.5; p = m * p;\n    f += 0.5 * (noise1(p) - 0.5); p = m * p;\n    f += 0.25 * (noise1(p) - 0.5); p = m * p;\n    f += 0.125 * (noise1(p) - 0.5); p = m * p;\n    f += 0.0625 * (noise1(p) - 0.5);\n    return f / 1.9375;\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdTriangleIsosceles(vec2 p, vec2 q) {\n    p.x = abs(p.x);\n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0 ), 1.0);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)), vec2(dot(b, b), s * (p.y - q.y)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\nvec3 water(vec3 color, vec2 pos) {\n    float terrain = fbm1high(terrainScaleInv * pos) - waterThreshold;\n\n    vec3 waterColor = mix(waterDeepColor, waterShallowColor, exp(20.0 * terrain));\n    color = mix(color, waterColor, step(terrain, 0.0));\n\n    float offset = waterThreshold + terrain;\n    float dx = fbm1high(terrainScaleInv * (pos + vec2(0.01, 0.0))) - offset;\n    float dy = fbm1high(terrainScaleInv * (pos + vec2(0.0, 0.01))) - offset;\n    float grad = 0.01 / length(vec2(dx, dy));\n    float t0 = terrain * grad;\n    float t1 = (terrain + 0.02) * grad;\n    float t2 = (terrain + 0.04) * grad;\n    float t3 = (terrain + 0.06) * grad;\n    float t4 = (terrain + 0.08) * grad;\n    float t5 = (terrain + 0.1) * grad;\n\n    color = mix(color, waterLineColor, 0.5 * clamp((lw - abs(t1)) * aa, 0.0, 1.0));\n    color = mix(color, waterLineColor, 0.4 * clamp((lw - abs(t2)) * aa, 0.0, 1.0));\n    color = mix(color, waterLineColor, 0.3 * clamp((lw - abs(t3)) * aa, 0.0, 1.0));\n    color = mix(color, waterLineColor, 0.2 * clamp((lw - abs(t4)) * aa, 0.0, 1.0));\n    color = mix(color, waterLineColor, 0.1 * clamp((lw - abs(t5)) * aa, 0.0, 1.0));\n\n    return mix(color, shoreLineColor, clamp((lw - abs(t0)) * aa, 0.0, 1.0));\n}\n\nfloat mountainContour(vec2 p, float y, float squash, float offset) {\n    float contour = -0.2;\n    contour -= 0.4 * (1.0 - pow(abs(cos((mountainWidthInv * p.x + offset) * pi)), 1.2));\n    contour += 0.5 * fbm1(vec2(0.15 * p.x, y));\n    contour *= squash;\n    return p.y - y + mountainHeight * (contour + 0.4);\n}\n\nvec3 mountains(vec3 color, vec2 pos, float offset) {\n    float x = mountainWidthInv * pos.x + offset;\n    float range = fract(x);\n    float antiRange = 1.0 - range;\n    x = mountainWidth * ((floor(x) - offset) + 0.5);\n    \n    float y = mountainHeightInv * pos.y + offset;\n    float altitude = fract(y);\n    float antiAltitude = 1.0 - altitude;\n   \ty = mountainHeight * ((floor(y) - offset) + 0.5);\n    \n    float draw = step(mountainThreshold, fbm1(terrainScaleInv * vec2(x, y)));\n    float drawLeft = step(mountainThreshold, fbm1(terrainScaleInv * vec2(x - mountainWidth, y)));\n    float drawRight = step(mountainThreshold, fbm1(terrainScaleInv * vec2(x + mountainWidth, y)));\n    \n    float squash = clamp(4.0 * range * antiRange + drawLeft * step(range, 0.5) + drawRight * step(0.5, range), 0.0, 1.0);\n    squash *= squash;\n    draw *= clamp(mountainWidth * range * aa + drawLeft, 0.0, 1.0);\n    draw *= clamp(mountainWidth * antiRange * aa + drawRight, 0.0, 1.0);\n    \n   \tfloat ter = mountainContour(pos, y, squash, offset);\n    float tdx = mountainContour(pos + vec2(0.01, 0.0), y, squash, offset) - ter;\n    float tdy = mountainContour(pos + vec2(0.0, 0.01), y, squash, offset) - ter;\n    float tgrad = 0.01 / length(vec2(tdx, tdy));\n    float t0 = ter * tgrad;\n\n    vec3 fillColor = mix(landColor, mountainColor, altitude);\n    fillColor = mix(fillColor, mountainLineColor, clamp(8.0 * (0.1 - abs(fbm1(0.25 * pos))), 0.0, 1.0));\n    fillColor = mix(color, fillColor, smoothstep(0.0, 0.3, altitude)); \n    color = mix(color, fillColor, step(ter, 0.0) * draw);\n    \n    float shadow = step(0.0, t0) * antiAltitude * antiAltitude * draw * squash;\n    color = mix(color, mountainShadowColor, shadow);\n    return mix(color, mountainLineColor, clamp((lw - abs(t0)) * aa, 0.0, 1.0) * draw);\n}\n\nfloat treeSDF(vec2 pos, vec2 trunk) {\n    vec3 h = hash3(trunk);\n    float r = treeScale * (0.9 + 0.35 * h.z);\n    trunk += treeScale * 0.5 * (h.xy - 0.5);\n    float terrain = fbm1(terrainScaleInv * trunk);\n    float plant = step(treeTerrainThresholdLow, terrain) * step(terrain, treeTerrainThresholdHigh);\n    plant *= step(treeGrowthThreshold, fbm1(treeGrowthScaleInv * trunk + 100.0));\n    return r - distance(pos, trunk) - 100.0 * (1.0 - plant);\n}\n\nvec3 trees(vec3 color, vec2 pos) {\n    vec2 center = treeScale * (floor(treeScaleInv * pos) + 0.5);\n    float shadow = treeSDF(pos, center);\n    shadow = max(shadow, treeSDF(pos, center + vec2(treeScale, 0.0)));\n    shadow = max(shadow, treeSDF(pos, center + vec2(treeScale, treeScale)));\n    shadow = max(shadow, treeSDF(pos, center + vec2(0.0, treeScale)));\n    shadow = max(shadow, treeSDF(pos, center + vec2(-treeScale, treeScale)));\n    shadow = max(shadow, treeSDF(pos, center + vec2(-treeScale, 0.0)));\n    \n    color = mix(color, treeShadowColor, step(0.0, shadow));\n    color = mix(color, treeLineColor, clamp((lw - abs(shadow)) * aa, 0.0, 1.0));\n    \n    pos.y -= treeGrow;\n    vec2 trunk = treeScale * (floor(treeScaleInv * pos) + 0.5);\n    float forrest = treeSDF(pos, trunk);\n    forrest = max(forrest, treeSDF(pos, trunk + vec2(treeScale, 0.0)));\n    forrest = max(forrest, treeSDF(pos, trunk + vec2(treeScale, treeScale)));\n    forrest = max(forrest, treeSDF(pos, trunk + vec2(0.0, treeScale)));\n    forrest = max(forrest, treeSDF(pos, trunk + vec2(-treeScale, treeScale)));\n    forrest = max(forrest, treeSDF(pos, trunk + vec2(-treeScale, 0.0)));\n    forrest = max(forrest, treeSDF(pos, trunk + vec2(-treeScale, -treeScale)));\n    forrest = max(forrest, treeSDF(pos, trunk + vec2(0.0, -treeScale)));\n    forrest = max(forrest, treeSDF(pos, trunk + vec2(treeScale, -treeScale)));\n\n    color = mix(color, treeColor * (1.0 - exp(-0.5 - clamp(forrest, 0.0, 10.0))), step(0.0, forrest));\n    return mix(color, treeLineColor, clamp((lw - abs(forrest)) * aa, 0.0, 1.0));\n}\n\n#ifdef DRAW_TOWNS\nvec3 building(vec3 color, vec2 pos, vec2 county, float population, vec3 roofColor, vec2 block) {\n    vec2 b = buildingSize * block;\n    float terrain = fbm1(terrainScaleInv * b);\n    float free = step(townTerrainThresholdLow, terrain) * step(terrain, townTerrainThresholdHigh);\n    free *= step(fbm1(treeGrowthScaleInv * b + 100.0), townTreeThreshold);\n    free *= step(hash1(block), 1.2 - distance(b, county) / ((1.0 + population) * urbanSprawl));\n    \n    vec3 buildingHash = hash3(block);\n    vec2 size = vec2(0.3, 0.1) + vec2(0.25, 0.25) * buildingHash.xy;\n    vec2 center = vec2(1.2 * (buildingHash.z - 0.5), size.y - 0.6);\n    vec2 p = pos - block - center;\n    \n    vec2 roofHash = hash2(block);\n    float roofWidth = size.x * (0.4 + 0.6 * roofHash.x);\n    float roofside = 1.0 - 2.0 * step(roofHash.y, 0.5);\n    float triangle = sdTriangleIsosceles(p - vec2(roofside * (roofWidth - size.x), 0.4 + size.y), vec2(roofWidth, -0.4));\n    float sdf = sdBox(p, size);\n    sdf = min(sdf, triangle);\n    sdf -= bsdf;\n    \n    float roofSdf = min(triangle, sdTriangleIsosceles(p - vec2(roofside * (size.x - roofWidth), 0.4 + size.y), vec2(roofWidth, -0.4)));\n    roofSdf = min(roofSdf, sdBox(p - vec2(0.0, 0.2 + size.y), vec2(size.x - roofWidth, 0.2)));\n    roofSdf -= roofSize;\n    roofSdf = max(roofSdf, size.y - p.y + bsdf);\n    color = mix(color, roofColor, step(roofSdf, 0.0) * free);\n    color = mix(color, vec3(0.0), clamp((blw - abs(buildingSize * roofSdf)) * aa, 0.0, 1.0) * free);\n    \n    vec3 sidingHash = hash3(block + 0.1);\n    vec3 siding = vec3(0.2 + 0.3 * sidingHash.x + 0.5 * noise1(vec2(6.0, 10.0) * pos)) + sidingHash.y * vec3(0.2, 0.1 + 0.1 * sidingHash.z, 0.0);\n    color = mix(color, siding, step(sdf, 0.0) * free);\n    \n    vec3 windowHash = hash3(block + 0.2);\n    vec2 windowSize = vec2(0.2 + 0.1 * windowHash.x, 0.4 + 0.4 * step(windowHash.y, 0.5));\n    vec2 windowCenter = vec2(0.8 * (0.5 - windowHash.z), 0.4 - windowSize.y);\n    float windowSdf = sdBox(p - size * windowCenter, size * windowSize);\n    color = mix(color, 0.5 * roofColor, 0.3 * step(windowSdf, 0.0) * free);\n    color = mix(color, vec3(0.0), clamp((blw - abs(buildingSize * windowSdf)) * aa, 0.0, 1.0) * free);\n    \n    return mix(color, vec3(0.0), clamp((blw - abs(buildingSize * sdf)) * aa, 0.0, 1.0) * free);\n}\n\nvec3 town(vec3 color, vec2 pos) {\n    vec2 county = townSpacing * (floor(townSpacingInv * pos) + 0.5);\n    vec3 h = hash3(county);\n    vec3 roofColor = 0.5 + 0.2 * cos(6.2831853 * (vec3(0.0, 0.33, 0.67) + h.x));\n    county += townSpacing * 0.6 * (h.xy - 0.5);\n    \n    vec2 grid = buildingSizeInv * pos;\n    vec2 block = floor(grid) + 0.5;\n    float offset = mod(block.x, 2.0) - 0.5;\n    block.y += offset * (step(0.5, fract(grid.y)) - 0.5);\n    \n    vec2 p = buildingSizeInv * pos;\n    color = building(color, p, county, h.z, roofColor, block + vec2(0.0, 1.0));\n    color = building(color, p, county, h.z, roofColor, block + vec2(-1.0, 0.5));\n    color = building(color, p, county, h.z, roofColor, block + vec2(1.0, 0.5));\n    color = building(color, p, county, h.z, roofColor, block);\n    color = building(color, p, county, h.z, roofColor, block + vec2(-1.0, -0.5));\n    color = building(color, p, county, h.z, roofColor, block + vec2(1.0, -0.5));\n    color = building(color, p, county, h.z, roofColor, block + vec2(0.0, -1.0));\n    \n    return color;\n}\n#endif\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 center = vec3(40.0 * iTime, 0.0, 0.0);\n    vec3 eye = center + vec3(0.0, -40.0 + 30.0 * cos(0.15 * iTime), 120.0 - 50.0 * cos(0.15 * iTime));\n\n#ifdef GO_CRAZY\n    center = vec3(250.0 * iTime, 0.0, 0.0);\n    eye = center + vec3(70.0 * sin(iTime), 70.0 * cos(iTime), 150.0 + 100.0 * cos(1.4 * iTime));\n#endif\n\n    float zoom = 2.0;\n    \n    vec3 forward = normalize(center - eye);\n    vec3 right = normalize(cross(forward, vec3(0.0, 0.0, 1.0)));\n    vec3 up = cross(right, forward);\n    vec2 xy = 2.0 * fragCoord - iResolution.xy;\n    vec3 ray = normalize(xy.x * right + xy.y * up + zoom * forward * iResolution.y);\n    \n    float t = -eye.z / ray.z;\n    vec2 pos = eye.xy + t * ray.xy;\n    \n    aa = iResolution.y / t;\n    lw = lineWidth + 0.5 / aa;\n    blw = buildingLineWidth + 0.5 / aa;\n    bsdf = blw * buildingSizeInv;\n    \n    vec3 color = water(landColor, pos);\n\n    float mountainRange = 0.5 * step(fract(mountainHeightInv * pos.y), 0.5);\n    color = mountains(color, pos, 0.5 - mountainRange);\n    color = mountains(color, pos, mountainRange);\n    \n    color = trees(color, pos);\n    \n#ifdef DRAW_TOWNS\n    color = town(color, pos);\n#endif\n    \n    color = mix(color, dirtColor, dirt * pow(clamp(fbm1(vec2(0.01, 0.02) * pos), 0.0, 1.0), 1.5));\n    \n    color *= 1.0 + paperTexture * (fbm1high(vec2(0.05, 0.1) * pos) - fbm1high(vec2(0.05, 0.1) * (pos + vec2(0.1, 0.1))));\n\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    color = mix(vignettingColor, color, vignetting * pow((1.0 - uv.x * uv.x) * (1.0 - uv.y * uv.y), 0.3) + 1.0 - vignetting);\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3cR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 1901, 1922, 1922, 2043], [2045, 2045, 2065, 2065, 2210], [2212, 2212, 2232, 2232, 2380], [2382, 2382, 2404, 2404, 2694], [2747, 2747, 2767, 2767, 2912], [2914, 2914, 2938, 2938, 3180], [3182, 3182, 3211, 3211, 3296], [3298, 3298, 3341, 3341, 3644], [3646, 3646, 3680, 3680, 4867], [4869, 4869, 4937, 4937, 5180], [5182, 5182, 5234, 5234, 6976], [6978, 6978, 7015, 7015, 7429], [7431, 7431, 7465, 7465, 9012], [12406, 12406, 12461, 12461, 14071]]}
{"id": "3d3cRf", "name": "density black and white", "author": "lck898989", "description": "density", "tags": ["density"], "likes": 3, "viewed": 53, "published": "Public", "date": "1601358818", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution;\n#define S smoothstep;\n/*\nfloat stX(vec2 uv,float edge) {\n    return step(edge,uv.x);    \n}\n\nfloat stY(vec2 uv,float edge) {\n    return step(edge,uv.y);\n}\n\nfloat startStep(in vec2 uv,float stepNum) {\n    float ste = 1. / stepNum;\n    float stres = 0.;\n    \n    \n    for(float i = 0.; i < stepNum; i++) {\n        \n        vec2 v = step( ste * i, uv);\n\n        if(mod(i,2.) == 0.) {\n            stres += v.x+v.y;\n        } else {\n            stres -= v.x+v.y;\n        }\n    }\n    return stres;\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    float s = 50. * sin(uv.x + iTime) + 50.;\n    \n    for(float i = 0.; i < s; i++) {     \n        vec2 v = uv - i/s;\n        v = smoothstep(-.7, .7, v / fwidth(v));\n                      \n        fragColor += (v.x + v.y) * ( 1.- mod(i,2.)*2.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3cRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 520, 577, 577, 901]]}
{"id": "3d3cRN", "name": "Camera Simulator in Shader", "author": "yonng", "description": "Camera and Cube Points\nRefer to the great tutorial: https://www.youtube.com/watch?v=PBxuVlp7nuM\n", "tags": ["3d"], "likes": 1, "viewed": 48, "published": "Public", "date": "1600455889", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float DistLine(vec3 ro, vec3 rd, vec3 p )  //think about the parralelogram\n{\n    return length(cross(p-ro,rd))/length(rd);\n}\n\nfloat DrawPoint(vec3 ro, vec3 rd, vec3 p)\n{\n    float d = DistLine(ro, rd, p);\n    d = smoothstep(.06,.05,d);  //use smooth setp to process edge case and cut out\n    return d;\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n\n     float t = iTime;\n    vec3 ro = vec3(3.*sin(t)+0.5,2.,-3.*cos(t)+0.5);   //ray origin\n    \n    vec3 p = vec3(sin(t),0.,1.+cos(t));\n    \n    vec3 lookat = vec3(.5);  //look at the center of the cube\n    vec3 forward = normalize(lookat - ro);\n    vec3 rightvec = cross(vec3(0.,1,0.),forward); //right vector\n    vec3 upvec = cross (forward,rightvec);    // to camera corrdinates -> screen that could be rotated\n    \n    //intersection\n    float zoom = 1.;\n    vec3 c = ro + forward * zoom;  //center\n    vec3 i = c + uv.x* rightvec + uv.y * upvec;\n    vec3 rd = i - ro;\n    //vec3 p  = vec3(0.,0.,2.);  //self defined 2 behind the screen\n    float d = 0.;\n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\td += DrawPoint(ro,rd,vec3(0.,0,0.));\n    d += DrawPoint(ro,rd,vec3(0.,0,1.));\n    d += DrawPoint(ro,rd,vec3(0.,1,0.));\n    d += DrawPoint(ro,rd,vec3(0.,1,1.));\n    d += DrawPoint(ro,rd,vec3(1.,0,0.));\n    d += DrawPoint(ro,rd,vec3(1.,0,1.));\n    d += DrawPoint(ro,rd,vec3(1.,1,0.));\n    d += DrawPoint(ro,rd,vec3(1.,1,1.));\n    // Output to screen\n    fragColor = vec4(d,d,d,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3cRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 76, 76, 124], [126, 126, 169, 169, 303], [310, 310, 367, 417, 1648]]}
{"id": "3d3yRN", "name": "Hello Metaballs", "author": "Coedo", "description": "My first step at learning SDF and ray marching :>", "tags": ["sdf"], "likes": 2, "viewed": 61, "published": "Public", "date": "1600455583", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON 0.001\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sceneSDF(vec3 point) {\n    float t = iTime * 0.7;\n    vec3 s1Pos = vec3(0.0, sin(t), 0.0);\n    vec3 s2Pos = vec3(0.5, sin(t - 60.0), 0.0);\n    vec3 s3Pos = vec3(-0.2, sin(t - 90.0), 0.0);\n\n    float s1 = sphere(point - s1Pos, 0.6);\n    float s2 = sphere(point - s2Pos, 0.5);\n    float s3 = sphere(point - s3Pos, 0.45);\n        \n    float sd = opSmoothUnion(s1, s2, 0.2);\n    sd = opSmoothUnion(sd, s3, 0.25);\n        \n                           \n    return sd;\n}\n\nmat4 viewMatrix(vec3 pos, vec3 target, vec3 up) {\n\tvec3 f = normalize(target - pos);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nfloat rayMarch(vec3 rayOrigin, vec3 rayDirection, float start, float end) {\n    float depth = start;\n    for(int i = 0; i < 255; i++) {\n        float dist = sceneSDF(rayOrigin + depth * rayDirection);\n        \n        if(dist < EPSILON) return depth;\n        \n        depth += dist;\n        if(depth >= end) return end;\n    }\n    \n    return end;\n}\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 cameraPos = vec3(0.0, 0.0, 0.0);\n    \n    cameraPos.x = 7.0 * sin(iTime * 0.8);\n    cameraPos.z = 7.0 * cos(iTime * 0.8);\n    \n    mat4 cam = viewMatrix(cameraPos, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    dir = (cam * vec4(dir, 0.0)).xyz;\n    \n    float dist = rayMarch(cameraPos, dir, 0.0, 100.0);\n    \n    if(dist > 100.0 - EPSILON) {\n    \tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n\t\n    vec3 lightDir = vec3(-1.0, 1.0, sin(iTime));\n\n    vec3 hitPoint = cameraPos + dist * dir;\n    float ndotl = dot(normal(hitPoint), lightDir) * 0.5 + 0.5;\n        \n    vec3 col = ndotl * vec3(0.1, 0.5, 0.3) + vec3(0.0, 0.0, 0.75);\n        \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3yRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 54, 54, 82], [84, 84, 136, 136, 235], [237, 237, 265, 265, 705], [707, 707, 756, 756, 943], [945, 945, 1020, 1020, 1293], [1295, 1295, 1316, 1316, 1626], [1628, 1628, 1693, 1693, 1825], [1827, 1827, 1884, 1884, 2670]]}
{"id": "3d3yRs", "name": "stones by ME-v1", "author": "jorge2017a1", "description": "stones by ME-v1", "tags": ["stonesbymev1"], "likes": 3, "viewed": 82, "published": "Public", "date": "1601475439", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//@ME \n//Stones\n//TODO: colors, cover with moss, ...\n\n\nvec2 mouse;\n\nmat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat hash( float n )\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec2 x )\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n    \tf = f*f*(3.0-2.0*f);\n    \tfloat n = p.x + p.y*57.0;\n    \tfloat res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n    \treturn res;\n}\n\nfloat fbm( vec2 p )\n{\n    \tfloat f = 0.0;\n    \tf += 0.50000*noise( p ); p = m*p*2.02;\n    \tf += 0.25000*noise( p ); p = m*p*2.03;\n    \tf += 0.12500*noise( p ); p = m*p*2.01;\n    \tf += 0.06250*noise( p ); p = m*p*2.04;\n    \tf += 0.03125*noise( p );\n    \treturn f/0.984375;\n}\n\nvec3 thing(vec2 pos) \n{\n\tfloat row = floor((pos.y)/80.);\n\tif (mod(row, 2.0) < 1.0)\n\t\tpos.x += 40.;\n\t\n\tvec2 p = pos*0.0125;\n\tfloat n1 = fbm(p * 4.0);\n\tp.x = fract(p.x+.5)-0.5;\n\tp.y = fract(p.y+.5)-0.5;\n\tp = abs(p);\n   \tfloat a = atan(p.y, p.x);\n\tfloat b = atan(p.x, p.y);\n\tfloat n2 = fbm(p * 1.5) * (a * b);\n\tfloat n3 = n1 * 0.15 / n2 * .75;\n\tfloat s = min(p.x,p.y) - n3;\n\tfloat f = mix(s, 1.-n1, 0.5);\n\treturn vec3(p, f);\n}\nvec3 n1,n2,n3,n4;\nvec2 size = vec2(-0.2,0.0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mouse.x=0.5+0.25*cos(iTime);\n    mouse.y=0.5+0.25*sin(iTime);\n    \n    \n\tvec2 p = fragCoord.xy;\n\n\tvec3 color = vec3(0.0);\n\tvec2 off = vec2(p.x,p.y-1.0);\n\tn1 = thing(off);\n\toff = vec2(p.x-1.0,p.y);\n\t\n\tn2 = thing(off);\n\t\n\toff = vec2(p.x+1.0,p.y);\n\t\n\tn3 = thing(off);\n\t\n\toff = vec2(p.x,p.y+1.0);\n\t\n\tn4 = thing(off);\n\t\n\tvec3 va = normalize(vec3(size.xy,n2.z-n3.z));\n\tvec3 vb = normalize(vec3(size.yx,n1.z-n4.z));\n\t\n\tvec3 p2m = vec3(-((p/iResolution.xy)-mouse.xy)*iResolution.xy,64.0);\t\n\t\n    \n\tvec3 normal = vec3(cross(va,vb));\n   \t\n\t\n\tcolor = vec3(dot(normal.xyz, p2m)/96.0);\n\t\n\tcolor *= vec3(clamp(1.0-distance(mouse.xy*iResolution.xy,p)/iResolution.x*2.0,0.0,1.0));\n\t\n   \n\tfragColor = vec4( color, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3yRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 113, 136, 136, 172], [174, 174, 200, 200, 422], [424, 424, 445, 445, 697], [699, 699, 722, 722, 1122], [1171, 1171, 1228, 1228, 1938]]}
{"id": "3d3yWM", "name": "P H A S E D", "author": "BlooBewwiez", "description": "floating slices. Domain repetition of spheres and torus intersections.", "tags": ["raymarching", "sphere", "spheres", "learning", "trippy", "infinite", "chips"], "likes": 1, "viewed": 81, "published": "Public", "date": "1600982263", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST  100.\n#define SURF_DIST .001\n# define SPHERE 1\n# define TORUS 2\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat rand(vec2 coordinate) {\n    return fract(sin(dot(coordinate.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat displacement(vec3 p, int type){\n    switch (type) {\n        case 1:\n\t        return (sin(p.x * -.5) + -sin(length(p)) + -sin(p.z));\n        case 2:\n        \treturn (rand(p.xy) * rand(p.xz) * rand(p.yz));\n        case 3:\n        \treturn (rand(p.xx));\n        default:\n        \tbreak ;\n    }\n}\n\n\nfloat sdf_sphere(vec3 p, float r){\n    return (length(p) - r);\n}\nfloat sdf_torus(vec3 p, vec2 t){\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n  \treturn length(q)-t.y;\n}\nfloat sdf_capped_cone(vec3 p, float h, float r1, float r2){\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp(dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt(min(dot2(ca),dot2(cb)) );\n}\nfloat sdf_hex_prism(vec3 p, vec2 h){\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdf_cone( in vec3 p, in vec2 c, float h ){\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\nfloat sdf_tocta(vec3 p, float r) {\n    vec3 n1 = vec3(1.000,0.000,0.000);\n\tvec3 n2 = vec3(0.000,1.000,0.000);\n\tvec3 n3 = vec3(0.000,0.000,1.000);\n\tvec3 n4 = vec3(0.577,0.577,0.577);\n\tvec3 n5 = vec3(-0.577,0.577,0.577);\n\tvec3 n6 = vec3(0.577,-0.577,0.577);\n\tvec3 n7 = vec3(0.577,0.577,-0.577);\n\tvec3 n8 = vec3(0.000,0.357,0.934);\n\tvec3 n9 = vec3(0.000,-0.357,0.934);\n\tvec3 n10 = vec3(0.934,0.000,0.357);\n\tfloat s = abs(dot(p,n1));\n\ts = max(s,abs(dot(p,n2)));\n\ts = max(s,abs(dot(p,n3)));\n\ts = max(s,abs(dot(p,n4)));\n\ts = max(s,abs(dot(p,n5)));\n\ts = max(s,abs(dot(p,n6)));\n\ts = max(s,abs(dot(p,n7)));\n\treturn s-r;\n}\nfloat sdf_capsule(vec3 p, float h, float r){\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat opUni( float d1, float d2 ) { return min(d1,d2);  }\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\nfloat opInt( float d1, float d2 ) { return max(d1,d2);  }\nfloat opSUni( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat opRep( in vec3 p, in vec3 c, int type, vec2 torus_data, float sphere_data){\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    float ret = 0.0;\n    switch(type){\n        case 0 :\n  \t\t\tret = sdf_torus(q, torus_data);\n        \tbreak;\n        case 1 :\n        \tret = sdf_sphere(q, sphere_data);\n        \tbreak;\n    }\n    return ret;\n}\nfloat opSInt( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat make_noised_capsule(in vec3 p){\n    float d1 = sdf_capsule(p, 5., 3.);\n    float d2 = displacement(p, 1);\n    return d1+d2;\n}\n\nmat2  rot(float a){\n    float sa = sin(a);\n    float ca = cos(a);\n    return(mat2(ca, sa, -sa, ca));\n}\n\nfloat get_dist(vec3 position){\n    // declaring & assign position of objects\n    vec3 sphere_pos = position - vec3(0, 1.2, 5);\n    vec3 torus_pos  = position - vec3(0, 2, 5);\n    vec3 cone_pos   = position - vec3(0, -0.2, 5);\n    vec3 hex_pos    = position - vec3(0, 2.2, 5);\n    vec3 top_cone_pos = position - vec3(0, 3.4, 5);\n    vec3 tocta_pos  = position - vec3(2, 2, 5);\n\tvec3 capsule_pos = position - vec3(0, -4, 5);\n    \n    torus_pos.yz *= rot(-iTime * .3); \n    torus_pos.yx *= rot(-iTime * .3);\n\n   \tfloat torus_dist = opRep(torus_pos * iTime * 0.3, vec3(2, 0.2, 3), 0, vec2(1.5, 0.3), 0.);\n   \tfloat sphere_dist = opRep(sphere_pos + iTime, vec3(5, 4, 6), 1, vec2(0), 1.);\n    float torus_sphere_suni = opInt(sphere_dist, torus_dist);\n    return(torus_sphere_suni);\n}\n\nfloat ray_march(vec3 ray_orientation, vec3 ray_direction){ // done\n\tfloat distance_to_scene;\n    float distance_to_surface;\n    vec3  position;\n    \n    distance_to_scene = 0.;\n    for (int i = 0; i < MAX_STEPS; i++){\n        position = vec3(ray_orientation + ray_direction * distance_to_scene);\n        distance_to_surface = get_dist(position);\n        distance_to_scene += distance_to_surface;\n        if (distance_to_scene > MAX_DIST || distance_to_surface < SURF_DIST)\n            break;\n    }\n    return (distance_to_scene);\n}\n\nvec3 get_normal(vec3 cam_position){\n    float d = get_dist(cam_position);\n    vec2 eps = vec2(0.1, 0);\n    \n    vec3 n = d - vec3(\n        get_dist(cam_position - eps.xyy),\n    \tget_dist(cam_position - eps.yxy),\n        get_dist(cam_position - eps.yyx));\n\n    return (normalize(n));\n}\n\nfloat get_light(vec3 p){\n    vec3 light_pos = vec3(0, 1, 2);\n    light_pos.xz += vec2(sin(iTime), cos(iTime));\n    vec3 l = normalize(light_pos-p);\n    vec3 n = get_normal(p);\n    float diffuse_lighting = clamp(dot(n, l), 0., 1.);\n    float d = ray_march(p + n * SURF_DIST * 2., l);\n    if (d < length(light_pos - p))\n        diffuse_lighting *= .1;\n    return (diffuse_lighting);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 ray_direction = normalize(vec3(uv.x, uv.y, 1));\n    //vec3 ray_orientation = vec3(0, 3, 2.5);\n    vec3 ray_orientation = vec3(0, 1, 0);\n    float dist = ray_march(ray_orientation, ray_direction);\n    \n    vec3 col;\n    if (dist < MAX_DIST){\n        vec3 p = ray_orientation + ray_direction * dist;\n        float diffuse_light = get_light(p) * 1.;\n        \n        col = vec3(diffuse_light);\n    }\n\telse\n    \tcol = vec3(0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3yWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 129, 129, 148], [149, 149, 174, 174, 193], [194, 194, 230, 230, 258], [259, 259, 288, 288, 369], [370, 370, 407, 407, 667], [670, 670, 704, 704, 734], [735, 735, 767, 767, 835], [836, 836, 895, 895, 1206], [1207, 1207, 1243, 1243, 1516], [1517, 1517, 1565, 1699, 2034], [2035, 2035, 2069, 2069, 2647], [2648, 2648, 2692, 2692, 2751], [2753, 2753, 2788, 2788, 2810], [2811, 2811, 2846, 2846, 2868], [2869, 2869, 2904, 2904, 2926], [2927, 2927, 2972, 2972, 3071], [3072, 3072, 3153, 3153, 3397], [3398, 3398, 3443, 3443, 3543], [3545, 3545, 3582, 3582, 3676], [3678, 3678, 3697, 3697, 3780], [3782, 3782, 3812, 3858, 4559], [4561, 4561, 4619, 4627, 5092], [5094, 5094, 5129, 5129, 5378], [5380, 5380, 5404, 5404, 5762], [5764, 5764, 5820, 5870, 6451]]}
{"id": "3d3yzf", "name": "Smooth Winding Number - discont", "author": "FabriceNeyret2", "description": "variant of \"Smooth Winding Number\" by Ultraviolet. [url]https://shadertoy.com/view/Wddyz2[/url]\ntesting \"hand drawing\": discontinuous superimposed contours\n\nclick to threshold in/out\nchange comments for hatching parameters", "tags": ["number", "smooth", "hatching", "filling", "expressive", "winding", "handdrawing"], "likes": 13, "viewed": 382, "published": "Public API", "date": "1601364002", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of \"Smooth Winding Number\" by Ultraviolet. https://shadertoy.com/view/Wddyz2\n// see papers:   https://igl.ethz.ch/projects/winding-number \n//               https://www.dgp.toronto.edu/projects/fast-winding-numbers/\n\n#define ang(p)          atan((p).y, (p).x)\n#define angle(p0,p1)  ( mod( ang(p1) - ang(p0) - PI, 2.*PI ) -PI )\n#define P(n)            cos(PI*2.*(n+phase)/N + vec2(0,11) ) + .2* hash(n)\n#define hash(p)         fract(sin( (p)* vec2(12.9898, 78.233)) * 43758.5453) // https://www.shadertoy.com/view/llySRh\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 3.* ( u - R*.5)/R.y;\n    \n    float  N = 50.,\n          PI = 3.1416,\n           t = floor( fract(iTime*.2) *N*2. ),\n       N_min = max(0.,t-N),\n       N_max = min(N ,t),\n       phase = 10.*iTime,\n           a = 0.;\n    for(float i = N_min; i < N_max; i++ ) \n        if ( mod(i,2.) < 1. ) \n            a += angle( P(i-.9) -U, P(i+1.9) - U ) * 2./2.9;\n         // a += angle( P(i   ) -U, P(i+1.9) - U ) * 2./1.9;\n         // a += angle( P(i   ) -U, P(i+1. ) - U ) * 2./1.;\n    \n    O = vec4( .5 + .5* a/6.28  ); \n // O = vec4(floor(O*16.)/16.);  // see isovalues\n    if ( iMouse.z > 0.) {\n        if (a < 0.  ) O.b++;\n        if (a > 3.14) O.b--;\n    }\n    if ( fract(iTime/5.) > .5 ) O = ( .6 + .6 * cos( 6.3 * O.r + vec4(0,23,21,0) ) );  // hue. https://www.shadertoy.com/view/llySRh\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3yzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 531, 569, 569, 1397]]}
{"id": "3dccR4", "name": "L I G H T H O U S E", "author": "BlooBewwiez", "description": "Here's my first attempt ever at writing a shader on here.\nit's a calm little lighthouse on a hill.\n\nI think I'll be updating this periodically, improving it over time.", "tags": ["raymarching", "sea", "light", "scene", "house", "lighthouse"], "likes": 2, "viewed": 78, "published": "Public", "date": "1600973882", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST  100.\n#define SURF_DIST .001\n# define SPHERE 1\n# define TORUS 2\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat rand(vec2 coordinate) {\n    return fract(sin(dot(coordinate.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat displacement(vec3 p, int type){\n    switch (type) {\n        case 1:\n\t        return (sin(p.x * -.5) + -sin(length(p)) + -sin(p.z));\n        case 2:\n        \treturn (rand(p.xy) * rand(p.xz) * rand(p.yz));\n        case 3:\n        \treturn (rand(p.xx));\n        default:\n        \tbreak ;\n    }\n}\n\n\nfloat sdf_sphere(vec3 p, float r){\n    return (length(p) - r);\n}\nfloat sdf_torus(vec3 p, vec2 t){\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n  \treturn length(q)-t.y;\n}\nfloat sdf_capped_cone(vec3 p, float h, float r1, float r2){\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp(dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt(min(dot2(ca),dot2(cb)) );\n}\nfloat sdf_hex_prism(vec3 p, vec2 h){\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdf_cone( in vec3 p, in vec2 c, float h ){\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\nfloat sdf_tocta(vec3 p, float r) {\n    vec3 n1 = vec3(1.000,0.000,0.000);\n\tvec3 n2 = vec3(0.000,1.000,0.000);\n\tvec3 n3 = vec3(0.000,0.000,1.000);\n\tvec3 n4 = vec3(0.577,0.577,0.577);\n\tvec3 n5 = vec3(-0.577,0.577,0.577);\n\tvec3 n6 = vec3(0.577,-0.577,0.577);\n\tvec3 n7 = vec3(0.577,0.577,-0.577);\n\tvec3 n8 = vec3(0.000,0.357,0.934);\n\tvec3 n9 = vec3(0.000,-0.357,0.934);\n\tvec3 n10 = vec3(0.934,0.000,0.357);\n\tfloat s = abs(dot(p,n1));\n\ts = max(s,abs(dot(p,n2)));\n\ts = max(s,abs(dot(p,n3)));\n\ts = max(s,abs(dot(p,n4)));\n\ts = max(s,abs(dot(p,n5)));\n\ts = max(s,abs(dot(p,n6)));\n\ts = max(s,abs(dot(p,n7)));\n\treturn s-r;\n}\nfloat sdf_capsule(vec3 p, float h, float r){\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat opUni( float d1, float d2 ) { return min(d1,d2);  }\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\nfloat opInt( float d1, float d2 ) { return max(d1,d2);  }\nfloat opSUni( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat opRep( in vec3 p, in vec3 c, int type){\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    float ret = 0.0;\n    switch (type){\n        case SPHERE:\n        \tret = sdf_sphere(q, 0.5);\n        \tbreak;\n        case TORUS:\n        \tret = sdf_torus(q, vec2(0.5, 0.5));\n        \tbreak;\n        default :\n        \tbreak;\n    }\n    return ret;\n}\nfloat make_noised_capsule(in vec3 p){\n    float d1 = sdf_capsule(p, 5., 3.);\n    float d2 = displacement(p, 1);\n    return d1+d2;\n}\n\nmat2  rot(float a){\n    float sa = sin(a);\n    float ca = cos(a);\n    return(mat2(ca, sa, -sa, ca));\n}\n\nfloat get_dist(vec3 position){\n    // declaring & assign position of objects\n    vec3 sphere_pos = position - vec3(0, 1.2, 5);\n    vec3 torus_pos  = position - vec3(0, 2, 5);\n    vec3 cone_pos   = position - vec3(0, -0.2, 5);\n    vec3 hex_pos    = position - vec3(0, 2.2, 5);\n    vec3 top_cone_pos = position - vec3(0, 3.4, 5);\n    vec3 tocta_pos  = position - vec3(2, 2, 5);\n\tvec3 capsule_pos = position - vec3(0, -4, 5);\n    hex_pos.yz *= rot(29.8);    \n    \n    // compute all distances\n    float plane_dist = position.y + 2.3;\n    float sphere_dist = sdf_sphere(sphere_pos, 1.);\n    float torus_dist  = sdf_torus(torus_pos, vec2(0.5, 0.2));\n\tfloat cone_dist   = sdf_capped_cone(cone_pos, 2., 1., 0.5);\n    float top_cone_dist = sdf_cone(top_cone_pos, vec2(.8, 1.), .8);\n    float tocta_dist  = sdf_tocta(tocta_pos, 1.);\n    \n    // rotate capsule island\n    capsule_pos.yz *= rot(80.);\n    capsule_pos.xy *= rot(80.);\n    //float capsule_dist = sdf_capsule(capsule_pos, 5., 2.);\n    float capsule_dist_displaced = make_noised_capsule(capsule_pos);\n    float union_plane_cone = opSUni(plane_dist, cone_dist, 1.5);\n    float union_cone_torus = opSUni(union_plane_cone, torus_dist, 0.1);\n    float union_plane_cap  = opSUni(plane_dist, capsule_dist_displaced, 1.);\n\n    hex_pos.yx *= rot(-iTime/2.);\n    float hex_dist    = sdf_hex_prism(hex_pos, vec2(.4, 0.4));\n    //return(capsule_dist_displaced);\n    return (min(min(min(min(union_plane_cap, union_cone_torus)\n                    , hex_dist)\n                \t, top_cone_dist)\n               \t\t, capsule_dist_displaced));\n\n    //float u = opSub(sphere_dist, torus_dist);\n    //return (min(min(min(min(cone_dist, torus_dist), hex_dist), top_cone_dist), plane_dist));\n    //return (min(min(u, plan_dist), cone_dist));\n}\n\nfloat ray_march(vec3 ray_orientation, vec3 ray_direction){ // done\n\tfloat distance_to_scene;\n    float distance_to_surface;\n    vec3  position;\n    \n    distance_to_scene = 0.;\n    for (int i = 0; i < MAX_STEPS; i++){\n        position = vec3(ray_orientation + ray_direction * distance_to_scene);\n        distance_to_surface = get_dist(position);\n        distance_to_scene += distance_to_surface;\n        if (distance_to_scene > MAX_DIST || distance_to_surface < SURF_DIST)\n            break;\n    }\n    return (distance_to_scene);\n}\n\nvec3 get_normal(vec3 cam_position){\n    float d = get_dist(cam_position);\n    vec2 eps = vec2(0.1, 0);\n    \n    vec3 n = d - vec3(\n        get_dist(cam_position - eps.xyy),\n    \tget_dist(cam_position - eps.yxy),\n        get_dist(cam_position - eps.yyx));\n\n    return (normalize(n));\n}\n\nfloat get_light(vec3 p){\n    vec3 light_pos = vec3(0, 2.2, 5);\n    light_pos.xz += vec2(sin(iTime), cos(iTime));\n    vec3 l = normalize(light_pos-p);\n    vec3 n = get_normal(p);\n    float diffuse_lighting = clamp(dot(n, l), 0., 1.);\n    float d = ray_march(p + n * SURF_DIST * 2., l);\n    if (d < length(light_pos - p))\n        diffuse_lighting *= .1;\n    return (diffuse_lighting);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 ray_direction = normalize(vec3(uv.x, uv.y, 1));\n    //vec3 ray_orientation = vec3(0, 3, 2.5);\n    vec3 ray_orientation = vec3(-2, 1, -5);\n    float dist = ray_march(ray_orientation, ray_direction);\n    \n    vec3 col;\n    if (dist < MAX_DIST){\n        vec3 p = ray_orientation + ray_direction * dist;\n        float diffuse_light = get_light(p) * 1.5;\n        \n        col = vec3(diffuse_light);\n    }\n\telse\n    \tcol = vec3(0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dccR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 129, 129, 148], [149, 149, 174, 174, 193], [194, 194, 230, 230, 258], [259, 259, 288, 288, 369], [370, 370, 407, 407, 667], [670, 670, 704, 704, 734], [735, 735, 767, 767, 835], [836, 836, 895, 895, 1206], [1207, 1207, 1243, 1243, 1516], [1517, 1517, 1565, 1699, 2034], [2035, 2035, 2069, 2069, 2647], [2648, 2648, 2692, 2692, 2751], [2753, 2753, 2788, 2788, 2810], [2811, 2811, 2846, 2846, 2868], [2869, 2869, 2904, 2904, 2926], [2927, 2927, 2972, 2972, 3071], [3072, 3072, 3117, 3117, 3403], [3404, 3404, 3441, 3441, 3535], [3537, 3537, 3556, 3556, 3639], [3641, 3641, 3671, 3717, 5412], [5414, 5414, 5472, 5480, 5945], [5947, 5947, 5982, 5982, 6231], [6233, 6233, 6257, 6257, 6617], [6619, 6619, 6675, 6725, 7309]]}
{"id": "3dcyWn", "name": "Sin Wave test ", "author": "trinketMage", "description": "Sine wave test for eneko", "tags": ["sinewave"], "likes": 1, "viewed": 59, "published": "Public", "date": "1600708474", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.x;\n\tfloat time = iTime * 0.0005;\n    \n    vec3 params1 = vec3(\n        20.0,\n        100.0 + 12.5 * uv.y,\n        (0.0)\n    );\n        \n    vec3 params2 = vec3(\n        0.03125 - 0.03125 * uv.y,\n        0.125 - 0.0625 * -time + 0.0625 * uv.y,\n        0.0 \n    );\n        \n    vec3 params3 = vec3(\n        0.025 - 0.025 * uv.y * 4.,\n        0.125 - 0.0125 * -time + 0.25 * uv.y,\n        0.01\n    );\n    \n    uv.y += params1.x * sin(uv.x / params1.y + time) + params1.z + params2.x * cos(uv.x / params2.y);\n\n    uv.y += params3.x * sin(uv.x / params3.y + time) + params3.z;\n\n    float ny = sin(mod(uv.y * 18., 1.0));\n    \n    float up = 1.0 - smoothstep(0.25, 1.0, ny);\n    float down = smoothstep(0.0, 0.2, ny);\n    \n    vec4 color = vec4(up * down);\n    fragColor = color * 0.1 + 0.9;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcyWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 882]]}
{"id": "3dcyzS", "name": "Raymarching Pebbles - shortened", "author": "FabriceNeyret2", "description": "shortening athibaul's [url]https://shadertoy.com/view/wlsBRX[/url]\nJust raymarching a scene with pebbles, for fun and for learning about microfacet-based BRDFs.\n\nparallax-less: 596 chars here : [url]https://www.shadertoy.com/view/3scyRB[/url]\n", "tags": ["raymarching", "texture", "heightmap", "stone"], "likes": 24, "viewed": 392, "published": "Public API", "date": "1601102981", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// shortened \"Raymarching Pebbles\" (1661 chars) by athibaul. https://shadertoy.com/view/wlsBRX\n\n#define H(p)      texture( iChannel0, (p).xy )\n#define H1(p)     texture( iChannel1, (p).xy )\n#define H2(p)   ( H(p) + .08*H1(p)  ).r\n#define map(p)  ( 1. - (p).z - .1* H2(p)  )\n\n#define C(p,d)             /* curvature */    \\\n  4.*( textureLod(iChannel0, (p).xy, log2(2.5*d*512.)) - H(p) ).r\n\n#define AO(p) clamp(1. - C(p, .003) *8.       \\\n                       - C(p, .02 ) *.7       \\\n                       - C(p, .1  ) *.3,      \\\n                    0., 1. )\n\nvec2 e = vec2(.001, -.001);\n#define N( p )   /* IQ Tetrahedral normal */  \\\n    normalize( e.xyy * map(p + e.xyy) +       \\\n               e.yyx * map(p + e.yyx) +       \\\n               e.yxy * map(p + e.yxy) +       \\\n               e.xxx * map(p + e.xxx)   )\n\nvec3 h;\n#define specular( l, N, v, ap, f0)            \\\n  (  h = normalize(l+v),                      \\\n       (ap+2.)/6.28 *pow(dot(N, h), ap)       \\\n      / dot(l,h)                              \\\n      * f0  ) // ( f0 + (1.-f0)*pow(max(0.,1.-dot(l,h)),5.) ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy;\n    float t = iTime, d, l;\n\n    vec3 p = vec3( t*.1, .2*cos(t*.5), 0 ), N,      // initial pos\n         L = p + .3* vec3( cos(t*3.), sin(t), -1 ), // light dir\n         D = normalize( vec3(u+u - R, 3.*R.y) );    // ray dir\n    D.xy  *= mat2(cos( cos(t*.2) + vec4(0,33,11,0)));    \n\n    for(int j=0; j<32; j++){            // --- raymarch heightMap surface\n        d = map(p);\n        if(d < .001) break; \n        p += d*.3*D;\n    }\n    N = N(p); l = length( L -= p );     // --- shading\n    O = AO(p) * (   2.5* H1(p) * dot(L,N) / (l*l*l)    // diffuse\n                  +  .2* specular(-D, N, L/l, 60., .2) // specular\n                );\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcyzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 1092, 1130, 1130, 1801]]}
{"id": "3ddcWM", "name": "chroma tunnel", "author": "nexor", "description": ".", "tags": ["2d", "tunnel"], "likes": 0, "viewed": 20, "published": "Public", "date": "1601038364", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = acos(-1.);\nconst float pi2 = pi*2.;\n\nfloat fcos(float x)\n{\n    float w = fwidth(x);\n \treturn cos(x) *smoothstep(pi2,0.0,w);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n    // Normalized pixel coordinates (from 0 to 1)\n    float m = iTime*.12;\n    float c=cos(m),s=sin(m);\n    mat2 rot = mat2(c,-s,s,c);\n    \n    for(int i=0;i<3;++i)\n    {\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n        \n\tfloat angle = atan(uv.y,uv.x);\n    vec2 offset = vec2(cos(angle),sin(angle))*length(uv)*float(i)*5.;\n        \n    float n = iTime*.2;    \n    //offset += vec2(cos(n*5.),sin(n*7.))*50.;\n        \n    uv = (fragCoord+offset-.5*iResolution.xy)/iResolution.x;\n        \n    uv *= rot;\n    float d = 1e3;\n    \n    float a = atan(uv.y,uv.x);\n    \n\t//float t = mix(.5,5.,pow(fcos(iTime*3.)*.5+.5,5.));\n        \n        \n    uv = .35*uv/dot(uv,uv);\n    float k = length(uv);\n//    k = floor(length(uv))/k;\n    \n    \n    d = cos(a*15.+k*25.+fcos(k*pi2+k*iTime*.2));\n    \n    d = smoothstep(1.-fwidth(length(uv)),.0,abs(d)-.1);\n    d = abs(d)*(2.-.1*k);\n    col[i] += d-.5;\n        \n    }\n    \n    col = col;\n    \n    col = pow(col,vec3(1./2.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddcWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 75, 75, 145], [147, 147, 204, 204, 1267]]}
{"id": "3dtcDn", "name": "ScreenPatch", "author": "wavebbs", "description": "2D", "tags": ["2d"], "likes": 2, "viewed": 34, "published": "Public", "date": "1600758461", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 color1 = vec4(93./255.,178./255.,238./255.,1.0);\nvec4 bg = vec4(14./255.,44./255.,66./255.,1.0);\nvec2 size = vec2(3.,3.);\nfloat timeScale = 3.;\n\nfloat N(float t){\n\treturn fract( sin(t*13.21345)*613.456 );\n}\nvec4 N14(float t){\n\treturn fract( sin(t* vec4(3456,1024,3456,9654)*vec4(6547,345,8821,1565) ));\n}\n\n\nfloat Split(vec2 uv, vec2 scale,float timescale)\n{\n    \n\n //   time *=10.0;\n\t//vec2 a = vec2(15, 22);\n\tvec2 st = uv * scale;\n\n\tvec2 id = floor(st);\n\n\tst = fract(st) - 0.5;\n    \n\n    \n     \n        ///    \n    float time = iTime + fract(sin(id.x *361.34+id.y * 2312.7)*712.34) * 6.283 ;\n\n    float t = floor(time/timescale);\n    \n    \n    ///set random time to start\n    float alpha =  fract(sin(id.x *N(t*8.3323)*31.31978+id.y * N(t*12.33214)*8.80857)*12.3431);// * 6.283;\n    \n\t//float alpha = 0.0;\n    ///set random pos\n    //alpha = time;\n    //st.y += y;\n    \n\n    \n    \n    ///\n\tvec2 p1 = vec2(0.0, 0);\n\tvec2 o1 = (st - p1) ;\n\n\n\t//Square\n\tfloat d = 1.0 -  max(abs(o1.x), abs(o1.y))/0.5f;\n\tfloat m1 = 0.0;//1.0*(1.0-d);//  lerp(1, 0.0, d);\n\n    \n\tm1 = step(d, 0.01);\n    \n    \n\tm1 = 1.0 - m1;\n\t\n\tfloat fade = fract(time/timescale  )* 2. - 1.0;\n    \n    fade = 1. - abs(fade);\n    \n    \n\treturn m1*fade * alpha;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n  \n    \n    float r = Split(uv,size,timeScale);\n    \n  \n\n   // xx = 1.0 - xx;\n    \n    vec3 col = color1.rgb ;\n  // texture(iChannel0, uv) ;\n    col = mix(color1.rgb ,bg.rgb,r );;// bg.rgb + col;    ;//mix(color1.rgb,bg.rgb,r);\n    \n    // Output to screen\n    fragColor =  vec4(col,1.0);\n    \n    \n    \n    \n    \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtcDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 167, 167, 211], [212, 212, 230, 230, 309], [312, 312, 362, 413, 1273], [1276, 1276, 1333, 1383, 1751]]}
{"id": "3dtcR7", "name": "Fire Cloud Sine ", "author": "celifrog", "description": "No I don't like starting from scratch.\nStarted from IQ's cloud post.", "tags": ["fork"], "likes": 3, "viewed": 228, "published": "Public API", "date": "1600673076", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Volumetric clouds. It performs level of detail (LOD) for faster rendering\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n#if 1\n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) - f.xy;\n    vec2 rg = textureLod(iChannel0,(uv+0.5)/256.0,0.0).yx;\n#else\n    ivec3 q = ivec3(p);\n\tivec2 uv = q.xy + ivec2(37,239)*q.z*q.z;\n\n\tvec2 rg = mix(mix(texelFetch(iChannel0,(uv           )&11255,6),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,0))&255,0),f.x),\n\t\t\t\t  mix(texelFetch(iChannel0,(uv--+ivec2(0,1))&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,1))&255,0),f.x),f.y*f.y*f.y*f.y*f.y).yx;\n#endif    \n\treturn -1.0+2.0*mix( rg.x-rg.x, rg.y+rg.y-f.z, f.z+f.z-f.z-rg.x );\n}\n\nfloat map5( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q++ ); q = q*2.02;\n    f += 0.25000*noise( q++ ); q = q*2.03;\n    f += 0.12500*noise( q++ ); q = q*2.01;\n    f += 0.06250*noise( q++ ); q = q*2.02;\n    f += 0.03125*noise( q++ );\n\treturn clamp( 1.5 * p.y / 12.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map4( in vec3 p )\n{\n\tvec3 q = p - vec3(9.0,990.1,-1.0)*-iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f+f+f+f+f+f, 0.0, 1.0 );\n}\nfloat map3( in vec3 p )\n{\n\tvec3 q = p - vec3(11.0,0.1,1.0)*iTime;\n\tfloat f;\n    f  = 10.50000*noise( q ); q = q+q+q*2.02;\n    f += 10.25000*noise( q ); q = q*2.03;\n    f += 10.12500*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map2( in vec3 p )\n{\n\tvec3 q = p - vec3(11.0,0.1,0.1)*-iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q );;\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nvec3 sundir = normalize( vec3(-1.0,110.0,-1.0) );\n\n#define MARCH(STEPS,MAPLOD)\\\nfor(int i=0; i<STEPS; i++)\\\n{\\\n   vec3 pos = ro + t*rd;\\\n   if( pos.y<-13.0 || pos.y>112.0 || sum.a>10.99 ) break;\\\n   float den = MAPLOD( pos );\\\n   if( den++>0.01 )\\\n   {\\\n     float dif = clamp((den - MAPLOD(pos+0.3*sundir))/0.6, 0.0, 1.0 );\\\n     vec3  lin = vec3(0.65,0.7,0.75)*1.4 + vec3(1.0,0.6,0.3)*dif;\\\n     vec4  col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den );\\\n     col.xyz *= lin*-lin;\\\n     col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.003*t*t) );\\\n     col.w *= 0.4;\\\n     \\\n     col.rgb *= col.a;\\\n     sum += col*(1.0-sum.a);\\\n   }\\\n   t += max(0.05,0.09*t);\\\n}\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in ivec2 px )\n{\n\tvec4 sum = vec4(0.0);\n\n\tfloat t =-4.0;//0.05*texelFetch( iChannel0, px&255, 0 ).x;\n\n    MARCH(480,map2);\n    MARCH(408,map2);\n    MARCH(30,map2);\n    MARCH(1130,map2);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta+ta+ta+ta-ro-ro-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( in vec3 ro, in vec3 rd, in ivec2 px )\n{\n    // background sky     \n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.6,0.171,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n\tcol += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col, px );\n    col = col*(1.0-res.w) + res.xyz;\n    \n    // sun glare    \n\tcol += 15.2*vec3(61.66,-1.4,0.2)*pow( sun++, 3.0 );\n\n    return vec4( -col+col+col, -991.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec2 m = iMouse.xy/iResolution.xy*p*p*p*p*p*p*p*p*p*p;\n    \n    // camera\n    vec3 ro = 4.0*normalize(vec3(sin(5.0*m.x), 49.4*m.y, cos(3.0*m.x)));\n\tvec3 ta = vec3(0.0, -1.0, 0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n    \n    fragColor = render( ro, rd, ivec2(fragCoord-0.5) );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragColor = render( fragRayOri, fragRayDir, ivec2(fragCoord-0.5) );\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtcR7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[125, 203, 229, 229, 835], [837, 837, 862, 862, 1170], [1171, 1171, 1196, 1196, 1466], [1467, 1467, 1492, 1492, 1715], [1716, 1716, 1741, 1741, 1918], [2601, 2601, 2670, 2670, 2877], [2879, 2879, 2931, 2931, 3123], [3125, 3125, 3177, 3204, 3595], [3597, 3597, 3654, 3654, 4059], [4061, 4061, 4155, 4155, 4229]]}
{"id": "3dtcWH", "name": "fast-noise-v2", "author": "jorge2017a1", "description": "fast-noise-v2", "tags": ["fastnoisev2"], "likes": 4, "viewed": 58, "published": "Public", "date": "1600866768", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//desconocido autor\n// 00f404afdd835ac3af3602c8943738ea - please mark changes (and/or add docs), and retain this line.\n\nfloat _MinStep = 0.125;\n\n//////////////////////////////////////////////////////////////\n// http://www.gamedev.net/topic/502913-fast-computed-noise/\n// replaced costly cos with z^2. fullreset\nvec4 random4 (const vec4 x) {\n    vec4 z = mod(mod(x, vec4(5612.0)), vec4(3.1415927 * 2.0));\n    return fract ((z*z) * vec4(56812.5453));\n}\nconst float A = 1.0;\nconst float B = 57.0;\nconst float C = 113.0;\nconst vec3 ABC = vec3(A, B, C);\nconst vec4 A3 = vec4(0, B, C, C+B);\nconst vec4 A4 = vec4(A, A+B, C+A, C+A+B);\nfloat cnoise4 (const in vec3 xx) {\n    vec3 x = xx; // mod(xx + 32768.0, 65536.0); // ignore edge issue\n    vec3 fx = fract(x);\n    vec3 ix = x-fx;\n    vec3 wx = fx*fx*(3.0-2.0*fx);\n    float nn = dot(ix, ABC);\n\n    vec4 N1 = nn + A3;\n    vec4 N2 = nn + A4;\n    vec4 R1 = random4(N1);\n    vec4 R2 = random4(N2);\n    vec4 R = mix(R1, R2, wx.x);\n    float re = mix(mix(R.x, R.y, wx.y), mix(R.z, R.w, wx.y), wx.z);\n\n    return 1.0 - 2.0 * re;\n}\n\n//////////////////////////////////////////////////////////////\n// distance functions\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s ) { return length(p)-s; }\nfloat udBox( vec3 p, vec3 b ) {  return length(max(abs(p)-b,0.0)); }\nfloat udRoundBox( vec3 p, vec3 b, float r ) { return length(max(abs(p)-b,0.0))-r; }\nfloat sdTorus( vec3 p, vec2 t ) { vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nvec3  opRep(vec3 p, vec3 r) { return mod(p,r)-0.5*r; }\nvec3  opTx(vec3 p, mat4 m ) { return (m*vec4(p,1.0)).xyz; }\nfloat cyl(vec3 p, float r, float c) { return max(length(p.xz)-r, abs(p.y)-c); }\n/////////////////////////////////////////////////////\n// the rest\n\nfloat fbm(vec3 p) {\n float N = 0.0;\n  float D = 0.0;\n  int i=0;\n  float R = 0.0;\n  D += (R = 1.0/pow(2.0,float(i+1))); N = cnoise4(p*pow(2.0,float(i)))*R + N; i+=1;\n  D += (R = 1.0/pow(2.0,float(i+1))); N = cnoise4(p*pow(2.0,float(i)))*R + N; i+=1;\n  D += (R = 1.0/pow(2.0,float(i+1))); N = cnoise4(p*pow(2.0,float(i)))*R + N; i+=1;\n//  D += (R = 1.0/pow(2.0,float(i+1))); N = cnoise4(p*pow(2.0,float(i)))*R + N; i+=1;\n  return N/D;\n}\n\nfloat scene(vec3 p) {\n  float n = fbm(iTime + p);\n  vec3 pw = vec3(0.,0.,10.);\n  float pa = udRoundBox(p+pw,vec3(100.,5.,500.),0.22) + .5 *  n;\n  float d = pa;\n\n  vec3 c = opRep(p,vec3(20.,4.5,14.))-vec3(0.,0.,7.);\n  d = min(d,cyl(c+pw+vec3(0.,0.,-3.),2.,2.5));//udRoundBox(c+pw+vec3(0.,0.0,-3.),vec3(1.75,2.,0.75),0.1));\n\n  float e = udRoundBox(p-vec3(0.,30.,4.),vec3(100.,0.1,0.1),0.1);\n  \n  n = fbm(p);  \t\n  return min(e,sin(p.x * 5.)*.15+cos(p.z * 5.)*.15+n*0.215+d); // 'texture'\n}\n\nvec4 color(float d) { \n  return mix(vec4(1.,1.,1.,0.25),vec4(.2,.2,.2,0.1),smoothstep(0.,0.1,d)); \n}\n\nvec4 ray(vec3 pos, vec3 step) {\n    vec4 sum = vec4(0.);\n    vec4 col;\n    float d = 9999.0;\n#define RAY1  { d = scene(pos); col = color(d); col.rgb *= col.a; sum += col*(1.0 - sum.a); pos += step*max(d,_MinStep); }\n#define RAY4  RAY1 RAY1 RAY1 RAY1\n    RAY4 RAY4 RAY4 RAY4\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 e = vec3(sin(iTime*0.2)*20.,12.,-20.); \n  vec3 p = vec3((fragCoord.xy / iResolution.xy) * 2. -1., 1.);\n  p.x *= iResolution.x/iResolution.y;\n  p += e;\n  fragColor = ray(p, normalize(p-e));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtcWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 311, 340, 340, 450], [627, 627, 661, 661, 1068], [1070, 1229, 1264, 1264, 1286], [1287, 1287, 1318, 1318, 1355], [1356, 1356, 1401, 1401, 1439], [1440, 1440, 1473, 1473, 1535], [1536, 1536, 1565, 1565, 1590], [1591, 1591, 1620, 1620, 1650], [1651, 1651, 1688, 1688, 1730], [1731, 1798, 1817, 1817, 2232], [2234, 2234, 2255, 2255, 2720], [2722, 2722, 2743, 2743, 2822], [2824, 2824, 2855, 2855, 3115], [3117, 3117, 3174, 3174, 3372]]}
{"id": "3dtcz7", "name": "Random Rectangular Tiling", "author": "dr2", "description": "Dynamical extruded version of Shane's \"Asymmetric Blocks\"", "tags": ["rectangle", "tile", "pack", "extrude"], "likes": 20, "viewed": 369, "published": "Public API", "date": "1600677978", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Random Rectangular Tiling\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Just came across Shane's \"Asymmetric Blocks\"; here is a dynamical extruded version.\n  Original: https://www.shadertoy.com/view/Ws3GRs\n  Note that block edges cannot exceed twice the grid edge, and there are \n  restrictions on the combined length of multiple adjacent block edges (in a given \n  direction), so this is not a completely general tiling method (but it looks ok).\n*/\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\n\n#if 1  // = 1/0 - select extruded/flat version\n\nvec3 ltDir;\nvec2 pDisp;\nfloat tCur, dstFar, szFac;\nconst float pi = 3.1415927;\n\n#define H(z) (0.5 + 0.5 * cos (2. * tCur * (0.1 + 0.9 * Hashfv2 (ip + z))))\n\nfloat RandRect (vec2 p)\n{\n  vec4 hm, hc;\n  vec3 e;\n  vec2 pMid[4], pEdge[4], ip;\n  float dMin, hp, eFac;\n  ip = floor (p) + 0.5;\n  e = vec3 (-1., 0., 1.);\n  hp = H(0.);\n  hm = vec4 (H(e.zy), H(e.xy), H(e.yz), H(e.yx));\n  hc = vec4 (H(e.zz), H(e.xx), H(e.xz), H(e.zx));\n  if (mod (ip.x + ip.y, 2.) < 0.5) {\n    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);\n    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);\n    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);\n    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);\n    pMid[0] = vec2 (hm.z, hp);\n    pMid[1] = pMid[0];\n    pMid[2] = vec2 (hm.w, hp);\n    pMid[3] = pMid[2];\n  } else {\n    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);\n    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);\n    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);\n    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);\n    pMid[0] = vec2 (hp, hm.y);\n    pMid[1] = vec2 (hp, hm.x);\n    pMid[2] = pMid[1];\n    pMid[3] = pMid[0];\n  }\n  eFac = 0.3;\n  for (int k = 0; k < 4; k ++) {\n    pEdge[k] = eFac * pEdge[k] + 0.5;\n    pMid[k] = 2. * eFac * (pMid[k] - 0.5);\n  }\n  pMid[0] += pEdge[0] * e.xz;\n  pMid[1] += pEdge[1] * e.zz;\n  pMid[2] += pEdge[2] * e.zx;\n  pMid[3] += pEdge[3] * e.xx;\n  dMin = dstFar;\n  for (int k = 0; k < 4; k ++)\n     dMin = min (dMin, PrRoundBox2Df (p - ip - pMid[k], pEdge[k] - eFac + 0.05, 0.1));\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d, h;\n  q = p;\n  d = PrBoxDf (q, vec3 (1., 0.02, 1.));\n  if (d < 0.1) {\n    h = 0.01 * smoothstep (0., 0.03 * szFac, RandRect (q.xz * szFac + pDisp));\n    q.y += h;\n    d = 0.9 * PrBoxDf (q, vec3 (1., 0.02 - h, 1.));\n  }\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, nDotL;\n  szFac = 8.;\n  pDisp = Rot2D (vec2 (0., 2. * szFac), 2. * pi * mod (0.01 * tCur, 1.));\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = vec3 (0.3, 0.7, 1.);\n    if (vn.y > 0.1) {\n      if (ro.y < 0.01) col *= 0.5;\n      else nDotL *= nDotL;\n    }\n    col = col * (0.2 + 0.8 * nDotL) +\n       0.2 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (0.1);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.25 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += pi * sin (0.01 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -5.);\n  zmFac = 5.;\n  dstFar = 20.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\n#else\n\n// Flat version: \"Asymmetric Blocks\" by Shane - after some tweaking, and without the fancy visuals\n\nfloat tCur, dstFar;\nconst float pi = 3.14159;\n\n#define H(z) (0.5 + 0.5 * cos (2. * tCur * (0.1 + 0.9 * Hashfv2 (ip + z))))\n\nfloat RandRect (vec2 p)\n{\n  vec4 hm, hc;\n  vec3 e;\n  vec2 pMid[4], pEdge[4], ip;\n  float dMin, d, hp, eFac;\n  ip = floor (p) + 0.5;\n  e = vec3 (-1., 0., 1.);\n  hp = H(0.);\n  hm = vec4 (H(e.zy), H(e.xy), H(e.yz), H(e.yx));\n  hc = vec4 (H(e.zz), H(e.xx), H(e.xz), H(e.zx));\n  if (mod (ip.x + ip.y, 2.) < 0.5) {\n    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);\n    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);\n    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);\n    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);\n    pMid[0] = vec2 (hm.z, hp);\n    pMid[1] = pMid[0];\n    pMid[2] = vec2 (hm.w, hp);\n    pMid[3] = pMid[2];\n  } else {\n    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);\n    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);\n    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);\n    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);\n    pMid[0] = vec2 (hp, hm.y);\n    pMid[1] = vec2 (hp, hm.x);\n    pMid[2] = pMid[1];\n    pMid[3] = pMid[0];\n  }\n  eFac = 0.375;\n  for (int k = 0; k < 4; k ++) {\n    pEdge[k] = eFac * pEdge[k] + 0.5;\n    pMid[k] = 2. * eFac * (pMid[k] - 0.5);\n  }\n  pMid[0] += pEdge[0] * e.xz;\n  pMid[1] += pEdge[1] * e.zz;\n  pMid[2] += pEdge[2] * e.zx;\n  pMid[3] += pEdge[3] * e.xx;\n  dMin = dstFar;\n  for (int k = 0; k < 4; k ++)\n     dMin = min (dMin, PrRoundBox2Df (p - ip - pMid[k], pEdge[k] - eFac + 0.225, 0.05));\n  return dMin;\n}\n\nvec3 ShowScene (vec2 uv)\n{\n  vec3 col;\n  vec2 p, q;\n  float szFac;\n  szFac = 8.;\n  col = vec3 (0.7);\n  p = szFac * (uv + 0.04 * tCur);\n#if 0  // show grid\n  q = abs (fract (p) - 0.5) - 0.5;\n  col = mix (col, vec3 (0., 1., 0.), (1. - smoothstep (0., 0.01 * szFac, abs (max (q.x, q.y)))));\n#endif\n  col = mix (col, vec3 (0., 0., 1.), smoothstep (0.004 * szFac, 0.008 * szFac, RandRect (p)));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 col;\n  vec2 canvas, uv;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dstFar = 1e5;\n  col = ShowScene (uv);\n  fragColor = vec4 (col, 1.);\n}\n\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtcz7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[133, 6890, 6922, 6922, 7022], [7024, 7024, 7071, 7071, 7118], [7120, 7120, 7156, 7156, 7362], [7364, 7364, 7394, 7394, 7507], [7541, 7541, 7565, 7565, 7625]]}
{"id": "3dtczn", "name": "Flight through a spiral", "author": "illus0r", "description": "Flight through a spiral\n", "tags": ["raymarching"], "likes": 10, "viewed": 254, "published": "Public API", "date": "1600281629", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define textureCube texture\n\n#define MAX_STEPS 99\n#define MAX_DIST 20.\n#define EPSILON 0.001\n#define PI 3.1415\n\n#define EMPTY 0.\n#define MIRROR 1.\n#define BLUE 2.\n#define BLACK 3.\n#define RED 4.\n#define WHITE_MIRROR 5.\n#define PUREWHITE 6.\n#define n getNormal(p)\n\n#define tBeam vec2(.2,.5)\n\n#define PHI (sqrt(5.)*0.5 + 0.5)\n#define tChank 4.28125\n\nmat2 Rot(float a) { float s = sin(a), c = cos(a); return mat2(c, -s, s, c); }\nfloat sdBox( vec3 p, vec3 b ) { vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0); }\nfloat sdOctahedron( vec3 p, float s) { p = abs(p); float m = p.x+p.y+p.z-s; vec3 q; if( 3.0*p.x < m ) q = p.xyz; else if( 3.0*p.y < m ) q = p.yzx; else if( 3.0*p.z < m ) q = p.zxy; else return m*0.57735027; float k = clamp(0.5*(q.z-q.y+s),0.0,s); return length(vec3(q.x,q.y-s+k,q.z-k)); }\nfloat Rnd (float x) {return 2.*fract(10000. * sin(10000. * x))-1.;}\nfloat opSmoothUnion( float d1, float d2, float k ) { float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 ); return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat sdTorus( vec3 p, vec2 t ){ vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y;}\n\nfloat sdWater(vec3 p) {\n    float t = iTime * 10.1;\n    p.y += .001*sin(p.z*17.+t);\n    p.y += .001*sin(p.z*13.+t);\n    p.y += .001*sin(p.x*11.+t*.5);\n    return p.y;\n}\n\nfloat sdMirrors(vec3 p) {\n    float c = 1.1;\n    p.xy *= Rot(PI/4.);\n    p.xz *= Rot(.1*iTime);\n    vec3 l = vec3(2,0,2), id = round(p/c);\n    p = p-c*clamp(id,-l,l);\n    p.xz *= Rot(p.y*(Rnd(id.x)+1.) + 30.*iTime * (Rnd(id.x + 10. * id.z)+1.5));\n    // p.xz *= atan(p.x, p.z);\n    return sdBox(p, vec3(.1,10.,.001));\n}\n\nfloat sdRocket (vec3 p){\n    // p.y /= 2.;\n    // p.xz *= Rot(iTime);\n    p.xy *= Rot(PI/4.);\n    float sph=length(p) - 1.;\n    for(float i=2.;i<5.;i+=0.5){\n        // float shift = 4.*sin(iTime*i);\n        // float shift = 20.*(fract(.1*iTime*(1.2+.4*Rnd(i))+Rnd(i))*2.-1.)*i;\n        float shift = tan(iTime*(1.2+.4*Rnd(i))+Rnd(i))*10.;\n        float spread = 4.;\n        sph=opSmoothUnion(sph, (length(p*i+vec3(spread*Rnd(i),shift,spread*Rnd(i+1.))) - 1.)/i, .4);\n    }\n    return sph;    \n}\n\nfloat sdBeam(vec3 p){\n    p.xy *= Rot(PI/4.);\n    float size = 3.*Rnd(iTime)*.5+.5;\n    vec3 shift = 2.4*(vec3(Rnd(iTime+9.), 0, Rnd(iTime+99.))*.5);\n    return sdBox(p+shift, vec3(.2*size,100.,.2*size));\n}\n\nfloat timeCurve(float t) {\n    t = t * 4. / tChank;\n    // t = t / 1000.;\n    float whole = floor(t);\n    float decimal = fract(t);\n    t =  (whole + 1. - pow(1. - decimal, 32.));\n    return t;\n}\n\n\n// \nvec2 getDist(vec3 p) {\n    // float t = timeCurve(iTime);\n    // for(float j;++j<6.;){\n    //     p=abs(p)-1.1;\n    //     p=abs(p)-1.1;\n    //     p.xz*=Rot(t / 5.91 + j);\n    //     p.xy*=Rot(t / 3.21 + j);\n    // }\n    // p.y+=1.;\n    // float wave = 0.;//pow(sin(length(p + fract((iTime+.2) * 4. / tChank)))*.5+.5, 64.)*.2;\n    // p.y *= .99;\n    // p.x = cos(p.z);\n    // p.y = sin(p.z);\n\n    // p.z = cos(p.z * 1. + iTime * 10.);\n    // p.zy*=Rot(PI / 2.);\n    // vec2 obj = vec2(sdTorus(p, vec2(3.3, 0.)), WHITE_MIRROR);\n    // p.x -= 1.;\n    p.z += iTime * 10.1;\n    float w = p.z * 1.5 + iTime * 1.;\n    p.x += .6*cos(w);\n    p.y += .6*sin(w);\n    // p.y*=Rot(PI / 2.);\n    p.xy*=Rot(p.z * 1.1 + iTime);\n    p.x += 1.4;\n    vec2 obj = vec2(length(p.xy) * .3, WHITE_MIRROR);\n\n    return obj;\n}\n// \n\n\n\n\n\n\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = EMPTY;\n    float minAngleToObstacle = 1e10;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        minAngleToObstacle = min(minAngleToObstacle, atan(distToClosest.x, d));\n        d += abs(distToClosest.x);\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec3(d, info, minAngleToObstacle);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n_ = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n_);\n}\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= Rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n// used recursively for reflections\n// vec3 getColor(vec3 ro, vec3 rd, vec3 color, int depth) {\n// }\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    float d, info, dTotal=0.;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro, rd, color, p, rm;\n    float camDist = -10.;// + 5.*sin(timeCurve(iTime));//-17.+12.*smoothstep(2., 2.3, fract(iTime/5.)*5.);\n    ro = vec3(0,0,camDist);\n    // ro.xz *= Rot(timeCurve(iTime));\n    // ro.xy *= Rot(PI/4.);\n    // ro += 1.1*sin(iTime*4.)*vec3(Rnd(iTime),Rnd(iTime+100.),0); // shake\n    rd = getRayDir(uv, ro, vec3(0), 1.);\n    color = vec3(0);\n    float colorAmount = 0.;\n\n    // for(int reflectionDepth = 0; reflectionDepth < 2; reflectionDepth++) {\n    //     rm = rayMarch(ro, rd);\n    //     dTotal += d = rm[0];\n    //     info = rm[1];\n    //     p = ro + rd * d;\n    //     if (d < MAX_DIST) {\n    //         // color = vec3(1);//textureCube(iChannel0, rd).rgb;\n    //         if (info == MIRROR) {\n    //             rd = reflect(rd, n);\n    //             ro = p + 0.01 * rd;\n    //             continue;\n    //             // do nothing, propogate color getting to the reflection\n    //         }\n    //         else if (info == WHITE_MIRROR) {\n    //             vec3 nn = n;\n    //             nn.xy*=Rot(1.);\n    //             // color = vec3(1) * (dot(nn, vec3(1,1,-1))*.3+.7);\n    //             color = nn*.5+.5;\n    //         }\n    //         else if (info == PUREWHITE) {\n    //             color += vec3(1) * (1. - colorAmount);\n    //             colorAmount = 1.;\n    //         }\n    //     }\n    //     else {\n    //         // color += textureCube(iChannel0, vec3(rd.y, rd.xz*Rot(iTime)).yxz).rgb * (1. - colorAmount);\n    //         // colorAmount = 1.;\n    //     }\n    //     break;\n    // }\n    // // color = mix(color, vec3(0,uv.yx+.5)*.2, smoothstep(20., 100., dTotal));\n    // color = mix(color, rd*.2, smoothstep(20., 100., dTotal));\n    // fragColor = vec4(color, 1);\n \n    rm = rayMarch(ro, rd);\n    fragColor = vec4(vec3(.003/rm.z), 1);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtczn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[348, 348, 367, 367, 425], [426, 426, 457, 457, 540], [541, 541, 579, 579, 829], [830, 830, 851, 851, 897], [898, 898, 950, 950, 1041], [1042, 1042, 1074, 1074, 1134], [1136, 1136, 1159, 1159, 1304], [1306, 1306, 1331, 1331, 1625], [1627, 1627, 1651, 1696, 2121], [2123, 2123, 2144, 2144, 2329], [2331, 2331, 2357, 2357, 2526], [2529, 2608, 2630, 3153, 3409], [3410, 3498, 3531, 3531, 3985], [3987, 3987, 4011, 4011, 4231], [4233, 4233, 4287, 4287, 4514], [4516, 4516, 4566, 4566, 4757], [4759, 4862, 4918, 4918, 6811]]}
{"id": "3dtyzr", "name": "FRB Header_prototype_only", "author": "franklinz622", "description": "FRB", "tags": ["gradient"], "likes": 0, "viewed": 181, "published": "Public API", "date": "1600295038", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nvec2 map( vec2 p, in float offset )\n{\n\tp.x += 0.1*sin( iTime*0.01 + 2.0*p.y ) ;\n\tp.y += 0.1*sin( iTime*0.01 + 2.0*p.x ) ;\n\t\n\tfloat a = noise(p*1.5 + sin(0.01*iTime))*6.2831;\n\ta -= offset;\n\treturn vec2( cos(a), sin(a) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 uv = -1.0 + 1.0*p;\n    uv.x += 2.2;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\t\n    float offset = iTime*0.01 + fragCoord.x/iResolution.x;\n    \n\tfloat acc = 0.0;\n\tvec3  col = vec3(0.0);\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\tvec2 dir = map( uv, offset );\n\t\t\n\t\tfloat h = float(i)/32.0;\n\t\tfloat w = 4.0*h*(1.0-h);\n\t\t\n\t\tvec3 ttt = w*texture( iChannel0, uv ).xyz;\n\t\tttt *= mix( vec3(0.6,0.7,0.7), vec3(1.0,0.95,0.9), 0.5 - 0.5*dot( reflect(vec3(dir,0.0), vec3(1.0,0.0,0.0)).xy, vec2(0.707) ) );\n\t\tcol += w*ttt;\n\t\tacc += w;\n\t\t\n\t\tuv += 0.008*dir;\n\t}\n\tcol /= acc;\n    \n\tfloat gg = dot( col, vec3(0.333) );\n\tvec3 nor = normalize( vec3( dFdx(gg), 0.5, dFdy(gg) ) );\n\tcol += vec3(0.4)*dot( nor, vec3(0.7,0.01,0.7) );\n\n\tvec2 di = map( uv, offset );\n\tcol *= 0.65 + 0.35*dot( di, vec2(0.707) );\n\tcol *= 0.20 + 0.80*pow( 4.0*p.x*(1.0-p.x), 0.1 );\n\tcol *= 1.7;\n\n\tfragColor = vec4( col*vec3(0.012, 0.2, 0.15)+0.35*vec3(0.012, 0.199, 0.15), 1.0 );\n    \n}\n", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtyzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 62], [64, 64, 90, 90, 308], [310, 310, 347, 347, 531], [533, 533, 590, 590, 1570]]}
{"id": "3l2BDc", "name": "3 rings moire", "author": "edmeme", "description": "3 sets of concentric rings rotate around a common center", "tags": ["moire"], "likes": 6, "viewed": 106, "published": "Public", "date": "1600034211", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\n\nfloat rings(vec2 uv, vec2 center, float w, float period)\n{\n    float d = length(uv-center);\n    return smoothstep(0.,w,0.5 * (1.+sin(2. * PI * d/period)) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float radius = .25;\n    \n    float h = 1./10. * iTime;\n    float m = h * 2.;\n    float s = m * 2.;\n\t        \n    vec2 uv = fragCoord/iResolution.xx;\n    vec2 center = .5 * iResolution.xy / iResolution.xx ;\n    \n    vec2 h_off = radius * vec2(cos(h), sin(h));\n    vec2 m_off = radius * vec2(cos(m), sin(m));\n    vec2 s_off = radius * vec2(cos(s), sin(s));\n    \n    float dst = rings(uv, center + h_off, .5, .01);\n    dst = min(dst, rings(uv, center + m_off, .5, .01));\n    dst = min(dst, rings(uv, center + s_off, .5, .01));\n \t\n    dst = max(smoothstep(radius,radius+.01, length(uv - center)), dst);\n    \n    vec3 col = vec3(1.,1.,1.) * dst;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2BDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 77, 77, 177], [179, 179, 236, 236, 919]]}
{"id": "3l2BDd", "name": "Abstract Rectangles", "author": "bitless", "description": "A small experiment with rectangular cells", "tags": ["2d", "grid", "rectangle", "pattern"], "likes": 18, "viewed": 248, "published": "Public", "date": "1600180991", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: bitless\n// Title: Abstract Rectangles\n\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\"\n// and Fabrice Neyret (FabriceNeyret2) for https://shadertoyunofficial.wordpress.com/\n// and Inigo Quilez (iq) for  http://www.iquilezles.org/www/index.htm\n// and whole Shadertoy community for inspiration.\n\n\n#define p(t, a, b, c, d) ( a + b*cos( 6.28318*(c*t+d) ) ) //palette function (https://www.iquilezles.org/www/articles/palettes/palettes.htm)\n#define S(x,y,z) smoothstep(x,y,z)\n\nvoid mainImage( out vec4 f, in vec2 g)\n{\n    vec2 r = iResolution.xy\n        ,s = (g+g-r)/r.y*(1.3+sin(iTime)*.2);\n    s.x += s.x*abs(s.x)*.4+.5;\n    float y = s.y*(1.+abs(floor(s.x))*.2);\n    s.y = y+iTime;\n    vec2 l = floor(s)\n        ,u = fract(s);\n    \n    float \tm = fwidth(s.y)\n        \t,c = (1.-abs(l.x)*.1) \t\t\t//edge faiding\n                *(1.2-length(u-.5)*.5) \t\t//center spot\n                *S(.5,.49-m,abs(.5-u.x))\t//vertical borders\n                *S(.5,.49-m,abs(.5-u.y))\t// horizontal borders\n        \t\t*(1.-((l.x > 0.) ? S(.4,0.,u.x): //right side shadow\n        \t\t(l.x < 0.) ? S(.6,1.,u.x):0.)*.5)* //left side shadow\n    \t\t\t(1.-S(y*.3,0.,u.y)*max(0.,y*2.)*.2    //top shadow\n         \t\t-S(1.+(y)*.3,1.,u.y)*abs(min(0.,y*2.))*.2); //bottom shadow\n    f = vec4(p(sin(l.x*.2),vec3(.5),vec3(.3),vec3(.6+sin(l.y)*.2),vec3(.1,.2,.3))*c,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2BDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 508, 548, 548, 1366]]}
{"id": "3l2BR3", "name": "Breathing Mirror Slime", "author": "celifrog", "description": "Forked from here:\nhttps://www.shadertoy.com/view/lsl3RH\nPartial credit to me for edits.", "tags": ["fork", "slime", "mirror", "forked"], "likes": 0, "viewed": 194, "published": "Public API", "date": "1599490647", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// See here for a tutorial on how to make this:\n//\n// http://www.iquilezles.org/www/articles/warp/warp.htm\n\n//====================================================================\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.1000*noise( p ); p = m*p*2.02;\n    f += 0.0500*noise( p ); p = m*p*2.03;\n    f += 0.0250*noise( p ); p = m*p*2.01;\n    f += 0.1625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\nvec2 fbm4_2( vec2 p )\n{\n    return vec2(fbm4(p), fbm4(p+vec2(7.8)));\n}\n\nvec2 fbm6_2( vec2 p )\n{\n    return vec2(fbm6(p+vec2(16.8)), fbm6(p+vec2(11.5)));\n}\n\n//====================================================================\n\nfloat func( vec2 q, out vec4 ron )\n{\n    q += 0.03*sin( vec2(0.27,0.23)*iTime + length(q)*vec2(4.1,4.3));\n\n\tvec2 o = fbm4_2( 0.6*q*-q );\n\n    o += 0.04*sin( vec2(5.12,5.14)*iTime + length(o));\n\n    vec2 n = fbm6_2( 3.5*o );\n\n\tron = vec4( o++, n );\n\n    float f = 0.3 +2.5*fbm4( 1.8*q + 6.0*n );\n\n    return mix( f, f*f*f*3.5, f*abs(n.x) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float e = 2.0/iResolution.y;\n\n    vec4 on = vec4(5.0);\n    float f = func(p, on);\n\n\tvec3 col = vec3(1.0);\n    col = mix( vec3(0.2,0.1,0.4), vec3(0.3,0.05,0.05), f );\n    col = mix( col, vec3(0.9,0.9,0.9), dot(on.zw,on.zw) );\n    col = mix( col, vec3(0.4,0.3,0.3), 0.2 + 0.5*on.y*on.y );\n    col = mix( col, vec3(0.0,5.2,0.4), 0.10*smoothstep(6.2,1.3,abs(on.z)+abs(on.w)) );\n    col = clamp( col*f*1.0, 0.0, 1.0 );\n    \n#if 0\n    // gpu derivatives - bad quality, but fast\n\tvec3 nor = normalize( vec3( dFdx(f--)*iResolution.x,3.0, dFdy(f)*iResolution.y ) );\n#else    \n    // manual derivatives - better quality, but slower\n    vec4 kk;\n \tvec3 nor = normalize( vec3( func(p+vec2(e,0.0),kk)-f, \n                                -0.5*e,\n                                func(p+vec2(0.0,e),kk)-f ) );\n#endif    \n\n    vec3 lig = normalize( vec3( 0.9, 0.2, -0.4 ) );\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 1.0, 1.0 );\n    vec3 lin = vec3(0.70,0.90,0.95)*(nor.y*0.5+0.5) + vec3(1.15,0.10,0.05)*dif;\n    col *= 1.2*lin;\n\tcol = 1.0 - col;\n\tcol = 1.1*col*col;\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2BR3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[233, 356, 382, 382, 411], [413, 413, 435, 435, 631], [633, 633, 655, 655, 1008], [1010, 1010, 1033, 1033, 1080], [1082, 1082, 1105, 1105, 1164], [1166, 1238, 1274, 1274, 1579], [1581, 1581, 1638, 1638, 2798]]}
{"id": "3l2BWt", "name": "checkerboard2", "author": "neur0sys", "description": "checkerboard", "tags": ["checkerboard"], "likes": 4, "viewed": 89, "published": "Public", "date": "1600373248", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\n// Distance between layers\n#define K 4.0\n\n#define K1 1.0\n\n// Speed\n#define S 4.0\n\nfloat ds[20];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n\t\n    // [-1, 1]\n    uv = uv * 2.0 - 1.0;\n    \n    // center horizontal\n\tuv.x -= 1.0;\n    \n    float dist = mod(iTime, 20.0) > 10.0 ? K : K1;\n    \n    // move the layers\n    for (int i = 0; i < ds.length(); i++) {\n        ds[i] = (dist - mod(iTime * S, dist)) + float(i) * dist;\n    }\n    \n    // Default\n    fragColor = vec4(vec3(0.0), 1.0);\n    \n    bool drawn = false;\n    \n    float dx = cos(iTime) * 0.1;\n    float dy = sin(iTime) * 0.1;\n    \n    for (int i = 0; i < ds.length(); i++) {\n        float d = ds[i];\n\n        if (drawn) {\n        \tbreak;\n        }\n        \n        float x0 = uv.x;\n        float y0 = uv.y;\n        \n        x0 += d * dx;\n        y0 += d * dy;\n        \n        // change freq for layer\n        float x1 = x0 * d;\n        float y1 = y0 * d;\n\n        // center vertical\n        y1 += M_PI / 2.0;\n\n        int xon = cos(x1) > 0.0 ? 1 : 0;\n        int yon = sin(y1) > 0.0 ? 1 : 0;\n\n        int c = (xon ^ yon);\n\n        if (c != 0) {\n            float c1 = 1.0 - (d / 10.0);\n            \n            fragColor = vec4(vec3(0.0, c1 - 0.25, sin(iTime) * 0.125 + c1), 1.0);\n            \n        \tdrawn = true;\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2BWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 145, 202, 202, 1468]]}
{"id": "3l2fDt", "name": "Transparent Truchet", "author": "Shane", "description": "Demonstrating simple refraction via a basic animated Transparent Truchet scene.", "tags": ["reflection", "refraction", "truchet", "extrude"], "likes": 73, "viewed": 745, "published": "Public API", "date": "1600265636", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tTransparent Truchet\n\t-------------------\n\n\tThis is a basic refractive example. The scene isn't particularly exciting,\n\tbut the refractive element adds a little extra flavor... Not much, but a\n\tlittle. :) \n\n\tA few years ago, GPUs didn't enjoy branching, and seemed to hate nesting. \n    Even now, I try not to nest things too much. Anyway, for whatever reason,\n    these are not as big an issue as they once were, so we can at least put\n\ttogether simple scenes with multiple bounces.\n\n    By the way, in case it needs to be said, a real refractive\\reflective example \n    would require a stack to handle simultaneous reflective and refractive passes, \n    whereas this takes a lesser approach. By that, I mean this will attempt to \n    refract the surface normal of a refractive surface, then continue without \n    reflecting, and only reflect in the invent that it's not possible. The results \n    are good enough for simple examples like this, but definitely not production\n\tgrade.\n\n\tIf this were a path tracing example, I'd put a lot more effort into the\n\tcorrectness of the coloring. However, it's not, since I've basically thrown\n\tstuff in that I felt suited the situation, so don't pay too much attention\n\tto it. Having said that, I was going for a kind of smokey glass casing look, \n    and it's close enough, so it'll do. :) The refractive based logic is from \n    memory... Visually, things seem about right, but if you spot any mistakes, \n    feel free to let me know.\n\n\tFor anyone interested, the background is a custom version of the box divide \n    formula, which is related to KD trees. The coloring is provided via IQ's \n    versatile cosine palette formula.\n    \n\n    \n    Other examples:\n\n\t// An old favorite. Simple and pretty.\n    Spout - P_Malin\n\thttps://www.shadertoy.com/view/lsXGzH\n\n    // If you're trying to implement a basic multipass refraction and reflection \n    // example, I'd recommend this one. There are subtle differences, but I'm\n    // using similar logic. I adopted some of the naming conventions as well.\n    Glass Polyhedron - Nrx\n    https://www.shadertoy.com/view/4slSzj\n\n \n*/\n\n// Far plane, or max ray distance.\n#define FAR 20.\n\n// Minimum surface distance. Used in various calculations.\n#define DELTA .001\n\n\n// Ray passes: For this example, this is about the minimum I could\n// get away with. However, not all passes are used on each pixel, so\n// it's not as bad as it looks.\n#define PASSES 5\n\n// Global block scale.\n#define GSCALE vec2(1./3.)\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\n//float hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// Based on the UE4 random function: I like this because it incorporates a modulo\n// 128 wrap, so in theory, things shouldn't blow up with increasing input. Also, \n// in theory, you could tweak the figures by hand to get a really scrambled output... \n// When I'm feeling less lazy, I might do that.\n//\n// By the way, GPU's are fickle things, so if this isn't working on your\n// system, feel free to let me know.\nfloat hash21(vec2 p) {\n    \n    //p -= floor(p/128.)*128. + vec2(64.340627, 72.465623);\n    //return fract(dot(p.xyx*p.xyy, vec3(20.390625, 60.703123, 2.4281207)));\n    \n    p = fract(p*2.014371)*128. - vec2(63.537567, 64.484713);\n    return fract(dot(p.xyx*p.xyy, vec3(128.390654, 128.713193, 2.1396217)));\n \n}\n\n/*\n// My own experimental hash \n// Seems to work for the right range, but I don't trust it yet.\n\nfloat hash21(vec2 p){\n    \n    p = fract(p*2.0143)*128. - vec2(63.537567, 64.484713);\n    return fract(dot(p.xyx*p.xyy, vec3(128.390654, 128.713193, 2.1396217)));\n    //p.x = dot(p.xyx*p.xyy, vec3(128.390654, 128.713193, 2.1396217));\n    //return p.x - floor(p.x);\n}\n\n// Another, based on the \"17*17 = 289\" thing.\nfloat hash21(vec2 p) {\n    float x = dot(p, vec2(97, 37));\n    x *= 288./289.;                \n    x = (x - floor(x))*289.;                         \n    x = (x*34. + 113.)*x/289.;                       \n    return x - floor(x);                            \n}\n*/\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, 0.001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(1)); \n    n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n}\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxSU(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n*/\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  //return length(max(abs(p) - b + sf, 0.)) - sf;\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n// Vector container for the object IDs. We make a note of the individual\n// identifying number inside the main distance function, then sort them\n// outside of it, which tends to be faster.\nvec4 vObjID; \n\n// The scene. All of it is pretty standard. There's a wall, extruded\n// hollowed out Truchet tubing and some metallic elements. To be honest, \n// this was a little rushed, but the field doesn't have a lot going on, \n// so tightening it up wasn't as important as it sometimes is.\nfloat map(vec3 p){\n    \n    // Back wall\n    float wall = -p.z + .01; // Thick wall: abs(p.z - .2) - .21;\n     \n    // Truchet object and animated metallic balls: This is just a\n    // standard 2D animated Truchet with an extruded factor. If you're\n    // not sure how it works, myself and others have plenty of \n    // animated Truchet examples on Shadertoy to refer to.\n    //\n    // Grid construction: Cell ID and local cell coordinates.\n    const vec2 sc = 1./GSCALE, hsc = .5/sc;    \n    vec2 iq = floor(p.xy*sc) + .5;    \n    vec2 q = p.xy - iq/sc; // Equivalent to: mod(p.xy, 1./sc) - .5/sc;\n    \n    // Flip random cells. This effectively rotates random cells,\n    // but in a cheaper way.\n    float rnd = hash21(iq + .37);\n    if(rnd<.5) q.y = -q.y;\n      \n    // Circles on opposite square vertices.\n    vec2 d2 = vec2(length(q - hsc), length(q + hsc));\n    // Using the above to obtain the closest arc.\n    float crv = abs( min(d2.x, d2.y) - hsc.x);\n    \n    // Flipping the direction on alternate squares so that the animation\n    // flows in the right directions -- It's a standard move that I've\n    // explained in other examples.  \n    float dir = mod(iq.x + iq.y, 2.)<.5? -1. : 1.;\n    // Using repeat polar coordinates to create the moving metallic balls.\n    vec2 pp = d2.x<d2.y? vec2(q - hsc) : vec2(q + hsc);\n    pp *= rot2(iTime*dir); // Animation occurs here.\n    float a = -atan(pp.y, pp.x); // Polar angle.\n    a = (floor(a/6.2831853*8.) + .5)/8.; // Repeat central angular cell position.\n    // Polar coordinate.\n    vec2 qr = rot2(-a*6.2831853)*pp; \n    qr.x -= hsc.x;\n     \n    // Ridges, for testing purposes.\n    //crv += clamp(cos(a*16. + dir*iTime*3.)*2., 0., 1.)*.003;\n    \n    // A rounded square Truchet tube. Look up the torus formula, if you're\n    // not sure about this. However, essentially, you place the rounded curve\n    // bit in one vector position and the Z depth in the other, etc. Trust me,\n    // it's not hard. :)\n    //float tr = length(vec2(crv, (p.z) + .05/2. + .02)) - .035;\n    float tr = sBoxS(vec2(crv, (p.z) + .05/2. + .01), vec2(.035, .035), .01);\n    \n    // 3D ball position.\n    vec3 bq = vec3(qr,  p.z + .05/2. + .01);\n    //float ball = max(length(bq.zx) - .05, abs(bq.y) - .06);\n    float ball = length(bq) - .015; // Ball.\n    ball = min(tr + .03, ball); // Adding in the railing.\n    \n    // Hollowing out the Truchet tubing. If you don't do this, it can cause\n    // refraction issues, but I wanted the tubes to be hollow anyway.\n    tr = max(tr, -(tr + .01));\n \n    // Metallic elements, which includes the joins, metal ball joints\n    // and the tracks they're propogating along.\n    q = abs(abs(q) - .5/sc);\n    float mtl = min(q.x, q.y) - .01;\n    mtl = max(max(mtl, tr - .015), -(tr - .005));\n    \n    // Adding the balls. I should probably give them their own ID, but this \n    // involves less work, and I'm always up for that. :D\n    mtl = min(mtl, ball);\n    \n    // Storing the object ID.\n    vObjID = vec4(wall, tr, mtl, 1e5);\n    \n    // Returning the closest object.\n    return min(min(wall, tr), mtl);\n \n}\n\n \n// Basic raymarcher, but with an added distance factor that is\n// required when refracting through the inside of an object.\nfloat trace(vec3 ro, vec3 rd, float distanceFactor){\n\n \n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = 0; i<72; i++){\n    \n        d = map(ro + rd*t)*distanceFactor;\n   \n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        //if(d*d<DELTA*DELTA || t>FAR) break; // Alternative: .001*max(t*.25, 1.), etc.\n        if((d<0. && abs(d)<DELTA) || t>FAR) break; \n       \n        t += d*.9; \n        //t += max(d, DELTA); // For cheap on pass refraction... Not used here.\n         \n    }\n\n    return min(t, FAR);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int iter = 24; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        //if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = 0; i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n \n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to\n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks to\n    // EvilRyu for reminding me why we perform this step. It's been a while, but I vaguely\n    // recall that it's some kind of orthogonal space fix using the Gram-Schmidt process. \n    // However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n \n\n\n\n// Custom box divide formula: I wrote this from scratch, and based it on various \n// techniques, but changed a lot of it to cut down on operations. I also went to\n// some trouble to take a space and position preserving approach, which should make\n// it much easier to work with. The routines I've come across don't do that. :)\n//\n// The idea is simple, in theory, and the solution was simple, but as usual, I had\n// to make way too many mistakes to get there. Basically, you start in one of the\n// corners of the grid square, produce a random number, then split space vertically \n// or horizontally, according to the random factor. For instance, if the random number\n// is \".6,\" then split the space in a 60% to 40% ratio, update postions (depending\n// which side of the line you're on), reduce the space dimensions accordingly, etc.\n//\n// Simple, right? It should have been. :D Anyway, it's done now, so feel free to\n// use it for whatever you want.\n//\nvec4 boxDivide(in vec2 p){\n    \n    \n    // Scaling factor. If changing this, you may need to change a few settings\n    // here and there to suit your needs.\n    const float sc = 1.;\n    p *= sc;\n    \n    // Basid grid tile ID. This will be further split into subtiles, which will\n    // each have their own ID based on postion.\n    vec2 ip = floor(p); \n    \n    // Vertical offset. \n    #define VERT_OFFSET\n   \n    // If using the vertical offset option, update the position and ID accordingly.\n    #ifdef VERT_OFFSET\n    if(mod(ip.x, 2.)>.5){\n        p.y -= 1./2.;\n        ip = floor(p);\n    }\n    #endif\n   \n    p -= ip + .5; // The original grid tile's base local coordinates.\n\n    \n    // Block dimension. Every time there's a random split, it'll be factored down\n    // according to the random split factor.\n    vec2 l = vec2(1, 1);  \n    \n    // The starting point, which represents the bottom left corner (or is it the top left corner?)\n    // of the grid cell. With every split, it will be moved to the new split position.\n    vec2 s = vec2(-.5);    \n    \n    // Split number.\n    const int iNum = 8;\n    \n    float count = 0.;\n    \n    \n    // Create a box, divide it randomly, then do the same with the \n    // divided portions. Ad infinitum...\n    for(int i=0; i<iNum; i++) {\n \n        float r = hash21(ip + l + float(i)/float(iNum))*.35 + (1. - .35)/2.;\n        // Forcing a vertical to horizontal split (and vice versa) every\n        // iteration. It's not necessary, but I think it looks nicer.\n        float r2 = mod(float(i), 2.)>.5? 0. : 1.;\n        \n        \n        // Minimum width... Thrown in at the last minute to enforce a\n        // minimum box size. There are probably better ways, but it works\n        // well enough.\n        const float mW = .125;\n        if(l.x<mW && l.y<mW) break;\n        if(l.x<mW && r2>.5) { r2 = 0.; }// r = .5;\n        if(l.y<mW && r2<=.5) { r2 = 1.; }\n        \n        //if(hash21(ip + 113.523 + l.yx + float(i)/float(iNum))<.3) continue;\n        \n        // If the second random number is above a certain threshold, split \n        // vertically. Otherwise, split horizontally.\n        if(r2>.5){ \n            \n            // This line splits the current cell down the middle, in accordance with\n            // the random factor, \"r,\" and the cell width \"l.x.\" \n            if(p.x>s.x + l.x*r) {\n\n                s.x += l.x*r; // Advance the position to the right of the split.\n                l.x *= (1. - r); // Reduce the width by a factor of \"1 - r.\"\n            }\n            else l.x *= r; // No need to advance position, but we need to reduce the width.\n        \n        }\n        else {\n            \n              // This line splits the current cell horizontally, in accordance with\n             // the random factor, \"r,\" and the cell height \"l.y.\" \n             if(p.y>s.y + l.y*r) {\n\n                s.y += l.y*r; // Advance the position above (or below?) the split.\n                l.y *= (1. - r); // Reduce the height by a factor of \"1 - r.\"\n\n             }\n             else l.y *= r; // No need to advance position, but we need to reduce the height.\n        }\n        \n        // There are many ways to vary the line width.\n        #ifdef VARIABLE_LINE_WIDTH\n        l *= 1. - r*.03;\n        //l *= 1. - length(l)*.02;\n        //l *= .986;\n        #endif\n\n    }\n    \n    \n    // Constructing the box itself: Actually, once you have the box coordinates, you can \n    // do whatever you want with them.\n    //\n    // Rounding factor: This depends on the look you're after. It could be a constant, \n    // or you could choose to have no rounding at all. After experimenting, I decided \n    // to make the roundedness of the tile dependent on the minimum side length.\n    float rf = min(l.x, l.y); \n    float d = sBoxS(p - s - l/2., l/2., .05*sqrt(rf));// + .001*sc;\n    \n   \n    \n    // Smoothing factor.\n    float sf = 1./450.*sc;//1./iResolution.y*sc;\n    \n    // Individual, position-based tile ID. Note that it'll read into the texture\n    // at the correct position.\n    vec2 id = ip + s + l/2.;\n    \n    // If using the vertical offset, the ID needs to follow suit.\n    #ifdef VERT_OFFSET\n    if(mod(ip.x, 2.)>.5){\n        id.y += .5;\n    }\n    #endif\n    \n    \n    \n    // Using the ID to color the individual tile.\n   \n    // Random colors using IQ's cosine palette.\n    float rnd = hash21(id/sc);\n    vec3 pCol = .5 + .5*cos(6.2831853*rnd + vec3(0, 1, 2)*1.6);\n    pCol = mix(pCol, pCol.xzy, .2);//vec3(.2 + rnd*.4);//\n    \n    \n    // Another random colored version.\n    //pCol = vec3(1, hash21(id), hash21(id*57. + .5)*.8);\n    //pCol = mix(pCol, pCol.xzy, .35);//vec3(.2 + rnd*.4);\n    \n     // Textured version. Note that this is not an overlay -- Each tile has \n    // a uniform color.\n    //vec3 tx = texture(iChannel0, id/sc + .5).xyz; tx *= tx;\n    //vec3 pCol = smoothstep(0., .5, tx);\n    \n    \n   \n    // Rectangular cell border and coloring.\n    vec3 col = mix(vec3(.1), vec3(0), 1. - smoothstep(0., sf, d)); // Rounded pavers.\n    col = mix(col, pCol, 1. - smoothstep(0., sf, d + .003*sc)); \n    //col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(d + .01*sc) - .001*sc)); \n    \n    // Center, space preserving dots.\n    // Just the center dot.\n    //float d2 = length(p - s - l/2.) - .004/sc;\n    // Splitting space to produce four rivot-looking dots.\n    p = abs(p - s - l/2.) - l/2. + .015;\n    float d2 = length(p) - .004/sc;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d2)); // Rounded pavers.  \n    \n    // Very subtle bump element for some highlighting.\n    sf *= 2.;\n    d += .002*sc;\n    float b = mix(.05, 0., 1. - smoothstep(0., sf, d)); // Rounded pavers.\n    b = mix(b, .5, 1. - smoothstep(0., sf, d + .003*sc)); \n    //b = mix(b, 0., 1. - smoothstep(0., sf, abs(d + .01*sc) - .001*sc)); \n    b = mix(b, 0., 1. - smoothstep(0., sf, d2)); // Rounded pavers.  \n    \n      \n    // Return the color and the bump value.\n    return vec4(col, b);\n    \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\n    // Ray origin.\n\tvec3 ro = vec3(iTime/4., 0, -1); \n    // \"Look At\" position.\n    vec3 lk = ro + vec3(.03, -.02, .25); \n \n    // Light positioning.\n \tvec3 lp = ro + vec3(-.5, 1., 0); \n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // Unit direction ray.\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    \n    // Camera position. Initially set to the ray origin.\n    vec3 cam = ro;\n    // Surface postion. Also initially set to the ray origin.\n    vec3 sp = ro; \n    \n    // Global shadow variable and a reflection power variable. The reflection\n    // power also applies to refracted objects.\n    float gSh = 1.;\n    float objRef = 1.;\n     \n    vec3 col = vec3(0);\n   \n    // The refraction ratio for the Truchet tubing. Normally, you'd have\n    // diferent ones for different object, but we only need one for this example.\n    float refractionRatio = 1./1.5;\n    float distanceFactor = 1.;\n     \n    float alpha = 1.;\n    \n    // Intersection and coloring for each ray and subsequent bounces.\n    for(int j = 0; j<PASSES; j++){\n        \n        // Layer or pass color. Each pass color gets blended in with\n        // the overall result.\n        vec3 colL = vec3(0);\n\n        \n        // Raymarch to the scene.\n        float t = trace(sp, rd, distanceFactor);\n\n        // Objtain the ID of the closest object.\n        float svObjID = vObjID.x<vObjID.y && vObjID.x<vObjID.z? 0. : vObjID.y<vObjID.z? 1. : 2.;\n \n\n        // Advance the ray to the surface. This becomes the new ray origin for the\n        // next pass.\n        sp += rd*t;\n        \n        \n        // If the ray hits a surface, light it up. By the way, it's customary to put \n        // all of the following inside a single function, but I'm keeping things simple.\n        // Blocks within loops used to kill GPU performance, but it doesn't seem to\n        // effect the new generation systems.\n      \n        if(t<FAR){\n        //if((d<0. && abs(d)<delta) && t<FAR){\n\n            // Surface normal. Refractions, and therefore ray traversal inside\n            // of object surfaces are now possible, to the direction of the\n            // normal matters... This is yet one of many things that I forget\n            // when I haven't done this for a while. :)\n            vec3 sn = getNormal(sp)*distanceFactor; // For refractions.\n            \n            \n            // Texture size factor.\n            float sz0 = 2.;\n            /*\n            // Integrating bump mapping -- Not used here. It's possible\n            // to bump map on a pass by pass basis to save cycles.\n            vec3 smSn = sn;\n            sn = texBump(iChannel0, sp*sz0, sn, .007);///(1. + t/FAR)\n            //vec3 reflection = reflect(rd, normalize(mix(smSn, sn, .35)));\n            */\n            \n            \n            vec3 reflection = reflect(rd, sn);\n            vec3 refraction = refract(rd, sn, refractionRatio);\n       \n            \n            vec3 ld = lp - sp; // Point light direction.\n            float lDist = length(ld); // Surface to light distance.\n            ld /= max(lDist, .0001); // Normalizing.\n            \n            \n            // Shadows and ambient self shadowing.\n            //\n            // Shadows are expensive. It'd be nice to include shadows on each bounce,\n            // but it's still not really viable, so we just perform them on the \n            // first pass... Years from now, I'm hoping it won't be an issue.\n            //if(j < 2) \n                gSh = softShadow(sp, lp, sn, 12.);\n            float ao = calcAO(sp, sn); // Ambient occlusion.\n            float sh = min(gSh + .3 + ao*.3, 1.); // Adding a touch of light to the shadow.\n            \n\n            float att = 1./(1. + lDist*lDist*.025); // Attenuation.\n\n            float dif = max(dot(ld, sn), 0.); // Diffuse lighting.\n            float spe = pow(max(dot(reflection, ld), 0.), 8.);\n            float fre = clamp(1. - abs(dot(rd, sn))*.7, 0., 1.); // Fresnel reflection term.\n            \n            \n            float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n            float freS = mix(.25, 1., Schlick);  //F0 = .2 - Glass... or close enough.\n            \n            \n            // Object color.\n            vec3 oCol;\n            \n             \n           if(svObjID == 0.){ // Back wall.\n               \n               // Texturing... but I decided against it. \n               //vec3 tx = tex3D(iChannel1, (sp*1.), sn);\n               //tx = smoothstep(0., .5, tx);\n\n               // The box divide color and bump factor.\n               vec4 bxD = boxDivide(sp.xy);\n               // A second sample for some highlighting.\n               vec4 bxD2 = boxDivide(sp.xy - normalize(ld.xy)*.003);\n               float b = max(bxD2.w - bxD.w, 0.)/.003;\n               oCol = bxD.xyz*(b*.015 + .95);//*(tx*.5 + .5);//vec3(.05);//\n        \n               // Stripes.\n               //vec2 q = rot2(-3.14159/4.)*(sp.xy);\n               //float str = abs(fract(q.x*15.*1.4142) - .5)*2. - .35;\n               //oCol = mix(vec3(1), vec3(0), 1. - smoothstep(0., sf*8., str));\n\n               // The wall has no reflection of refraction, so setting the\n               // reflective or transmission power to zero will cause the\n               // loop to terminate early, which saves a lot of work.\n               objRef = .0;\n\n               spe *= freS;\n\n               // Reflection only override. This ensures that no refraction\n               // will occur... It's hacky, but it works. :)\n               refraction *= 0.; \n            }\n            else if(svObjID == 1.) {  // Glass Truchet tubes.\n\n                // Coloring the glass tubes. Note that we keep the object\n                // color dard, in order to look transparent.\n                vec3 tx = tex3D(iChannel0, (sp*sz0), sn);\n                tx = smoothstep(.05, .5, tx);\n                oCol = tx*.125;//*vec3(1, 2, 3); // Color.\n                objRef = 1.; \n                \n                // Faking more of a glass look.\n                //oCol *= tx;\n                //objRef = 1.2; \n                \n            }\n            else { // Metallic stuff.\n                \n                // Joins and animated metal portion.\n                vec3 tx = tex3D(iChannel0, (sp*1.), sn);\n                tx = smoothstep(0.05, .5, tx);\n                oCol = tx*vec3(1, .85, .6)/3.;\n                objRef = .125; // Only a bit of reflectance.\n                \n                // Ramping up the diffuse on the metal joins.\n                dif = pow(dif, 4.)*2.; \n                \n                // Reflection only override. This ensures that no refraction\n                // will occur... It's hacky, but it works. :)\n                refraction *= 0.; \n\n                \n            }\n            \n            // Simple coloring for this particular ray pass.\n            colL = oCol*(dif + .25 + vec3(1, .5, .3)*spe*16. + vec3(.1, .25, 1)*pow(fre, 2.)*8.);\n            \n            // Shading.\n            colL *= sh*ao*att;\n            \n            // Used for refraction (Beer's Law, kind of), but not used here.\n            //if(distanceFactor<0.)  colL *= exp(-colL*t*5.);\n            \n            \n            // Set the unit direction ray to the new reflected or refracted direction, and \n            // bump the ray off of the hit point by a fraction of the normal distance. \n            // Anyone who's been doing this for a while knows that you need to do this to \n            // stop self intersection with the current launch surface from occurring... It \n            // used to bring me unstuck all the time. I'd spend hours trying to figure out \n            // why my reflections weren't working. :)\n \n            // You see this in most refraction\\reflection examples. If refraction is possible\n            // refract, reverse the distance factor (inside to outside and vice versa) and \n            // bump the ray off the surface. If you can't refract (internal reflection, a \n            // non-refractive surface, etc), then reflect in the usual manner. If the surface\n            // neither reflects nor refracts, the object reflectance factor will cause the\n            // loop to terminate... I could check for that here, but I want to keep the \n            // decision making simple.\n            //\n            if (dot (refraction, refraction)<DELTA){\n                rd = reflection;\n                // The ray is just behind the surface, so it has to be bumped back to avoid collisions.\n                sp += sn*DELTA*2.; \n            }   \n            else {\n\n                rd = refraction;\n                distanceFactor = -distanceFactor;\n                refractionRatio = 1./refractionRatio;\n                sp -= sn*DELTA*2.;//1.1;\n            } \n            \n \n        }\n\n        // Fog: Redundant here, since the ray doesn't go far, but necessary for other setups.\n        float td = length(sp - cam); \n        vec3 fogCol = vec3(0);\n        colL = mix(colL, fogCol, smoothstep(0., .95, td/FAR));\n      \n        // This is a more subtle way to blend layers. \n        //col = mix(col, colL, 1./float(1 + j)*alpha);\n        // Additive blend. Makes more sense for this example.\n        col += colL*alpha;///float(PASSES);\n        \n        // If the hit object's reflective factor is zero, or the ray has reached\n        // the far horizon, break. Breaking saves cycles, so it's important to \n        // terminate the loop early when you can.\n        if(objRef < .001 || t >= FAR) break;\n        \n        // Object based breaking. Also possible, but I prefer the above.\n        //if(svObjID == 0.)break; \n        \n        // Decrease the alpha factor (ray power of sorts) by the hit object's reflective factor.\n        alpha *= objRef;\n    }\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2fDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2495, 2528, 2550, 2550, 2608], [2726, 3138, 3160, 3302, 3449], [4124, 4204, 4250, 4250, 5162], [5165, 5192, 5262, 5315, 5428], [5567, 5595, 5642, 5693, 5777], [5983, 6262, 6280, 6302, 9349], [9353, 9477, 9529, 9580, 10170], [10173, 10364, 10416, 10533, 11850], [11853, 12005, 12040, 12040, 12426], [12429, 12529, 12556, 12556, 13222], [13226, 13412, 13472, 13472, 14310], [14316, 15270, 15296, 15427, 21229], [21234, 21234, 21290, 21323, 31638]]}
{"id": "3l2fz3", "name": "Dithering with color shift", "author": "illus0r", "description": "Dithering with color shift", "tags": ["raymarching", "dithering"], "likes": 29, "viewed": 505, "published": "Public API", "date": "1599502425", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define textureCube texture\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define EPSILON 0.0001\n#define PI 3.14159265\n#define IVORY 1.\n#define BLUE 2.\n#define BLACK 3.\n#define RED 4.\n\n#define PHI (sqrt(5.)*0.5 + 0.5)\n\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// \nvec2 getDist(vec3 p, float t) {\n    p.xz*=Rot(t*5.);\n    p.xy*=Rot(t*7.);\n    float scale = 1. + .2*sin(t * 10.);\n    p /= scale;\n    return vec2(/*sdBox(p, vec3(1))*/sdTorus(p, vec2(1.2, .5)) * scale, RED);\n}\n// \n\n\n\n\n\n\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd, float t) {\n\tfloat d = 0.;\n    float info = 0.;\n    int steps = 0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d, t);\n        steps++;\n        d += abs(distToClosest.x);\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec3(d, info, steps);\n}\n\nvec3 getNormal(vec3 p, float t) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p, t).x - vec3(getDist(p - e.xyy, t).x,\n                               getDist(p - e.yxy, t).x,\n                               getDist(p - e.yyx, t).x);\n\treturn normalize(n);\n}\n\n\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= Rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float camRadius = 4.;\n    vec3 ro = vec3(0, 0, -camRadius);\n    float zoom = 1.100;\n\tfloat t = iTime / 5.;\n    vec3 color, rm, rd = getRayDir(uv, ro, vec3(0), 1.);\n    float d;\n    for (int i = 0; i < 3; i++) {\n        rm = rayMarch(ro, rd, t);\n        d = rm[0];\n        vec3 light = vec3(10,0,0);\n        vec3 p = ro + rd * d;\n        if (d < MAX_DIST) {\n            vec3 n = getNormal(p, t);\n            vec3 dirToLight = normalize(light - p);\n            vec3 rayMarchLight = rayMarch(p + dirToLight * .06, dirToLight, t);\n            float distToObstable = rayMarchLight.x;\n            float distToLight = length(light - p);\n            if (d < MAX_DIST) {\n                color[i] = .5 * (dot(n, normalize(light - p))) + .5;\n                color[i] = step(\n                    texture(iChannel0, (fragCoord + 8.*float(i))/32.).x, \n                    color[i]\n                );\n            }\n        }\n        t += .01;\n    }\n\n    fragColor = vec4(vec3(color), 1);\n}\n", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2fz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 238, 238, 301], [303, 303, 334, 334, 421], [423, 423, 456, 456, 521], [523, 602, 633, 633, 811], [812, 900, 942, 942, 1302], [1304, 1304, 1337, 1337, 1567], [1571, 1571, 1625, 1625, 1852], [1854, 1854, 1904, 1904, 2095], [2098, 2098, 2154, 2154, 3193]]}
{"id": "3lBBWG", "name": "rainbow matrix", "author": "dkaraush", "description": "Rainbox matrix.", "tags": ["color", "glsl", "bitmap", "font", "rainbow", "matrix"], "likes": 21, "viewed": 503, "published": "Public API", "date": "1599674823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nprecision mediump float;\n\nfloat random(vec2 v) {\n    return fract(sin(v.x * 32.1231 - v.y * 2.334 + 13399.2312) * 2412.32312);\n}\nfloat random(float x, float y) {\n    return fract(sin(x * 32.1231 - y * 2.334 + 13399.2312) * 2412.32312);\n}\nfloat random(float x) {\n    return fract(sin(x * 32.1231 + 13399.2312) * 2412.32312);\n}\n\nfloat hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n    else\n        res = f1;\n    return res;\n}\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb;\n    \n    if (hsl.y == 0.0) {\n        rgb = vec3(hsl.z); // Luminance\n    } else {\n        float f2;\n        \n        if (hsl.z < 0.5)\n            f2 = hsl.z * (1.0 + hsl.y);\n        else\n            f2 = hsl.z + hsl.y - hsl.y * hsl.z;\n            \n        float f1 = 2.0 * hsl.z - f2;\n        \n        rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n        rgb.g = hue2rgb(f1, f2, hsl.x);\n        rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n    }   \n    return rgb;\n}\n\nfloat character(float i) {\n    if (i == 0.) return 31599.; // 0\n    if (i == 1.) return 19748.; // 1\n    if (i == 2.) return 31183.; // 2\n    if (i == 3.) return 31207.; // 3\n    if (i == 4.) return 23524.; // 4\n    if (i == 5.) return 29671.; // 5\n    if (i == 6.) return 29679.; // 6\n    if (i == 7.) return 31012.; // 7\n    if (i == 8.) return 31727.; // 8\n    if (i == 9.) return 31719.; // 9\n    if (i == 10.) return 31725.; // A\n    if (i == 11.) return 15339.; // B\n    if (i == 12.) return 29263.; // C\n    if (i == 13.) return 15211.; // D\n    if (i == 14.) return 29647.; // E\n    if (i == 15.) return 29641.; // F\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 S = 15. * vec2(3., 2.);\n    vec2 coord = vec2(\n        fragCoord.x / iResolution.y,\n        fragCoord.y / iResolution.y + (iResolution.y - iResolution.x) / (2. * iResolution.y)\n    );\n    vec2 c = floor(coord * S);\n\n    float offset = random(c.x) * S.x;\n    float speed = random(c.x * 3.) * 1. + 0.5;\n    float len = random(c.x) * 15. + 10.;\n    float u = 1. - fract(c.y / len + iTime * speed + offset) * 2.;\n\n    float padding = 2.;\n    vec2 smS = vec2(3., 5.);\n    vec2 sm = floor(fract(coord * S) * (smS + vec2(padding))) - vec2(padding);\n    float symbol = character(floor(random(c + floor(iTime * speed)) * 15.));\n    bool s = sm.x < 0. || sm.x > smS.x || sm.y < 0. || sm.y > smS.y ? false\n             : mod(floor(symbol / pow(2., sm.x + sm.y * smS.x)), 2.) == 1.;\n\n    fragColor = vec4(s ? hsl2rgb(vec3(c.x / S.x, 1., 0.5)) * u : vec3(0.), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBBWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 49, 49, 129], [130, 130, 162, 162, 238], [239, 239, 262, 262, 326], [328, 328, 374, 374, 726], [727, 727, 751, 751, 1230], [1232, 1232, 1258, 1258, 1873], [1875, 1875, 1932, 1932, 2795]]}
{"id": "3lBBWm", "name": "Escalator 2", "author": "dr2", "description": "Below street level", "tags": ["tunnel", "underground", "stair"], "likes": 14, "viewed": 219, "published": "Public API", "date": "1599036260", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Escalator 2\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // =1 for optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, qHit, pPos[2];\nvec2 stCs;\nfloat tCur, dstFar, stSpd, stAng, stRise, stWid, stHt, stLen, wThk, psgSep, psgWid, pSpd,\n   pRot[2], stExt, stTurn;\nint idObj, vuMode;\nconst int idStep = 1, idPlat = 2, idHrail = 3, idSep = 4, idWal = 5, idFlor = 6, idCeil = 7,\n   idLamp = 8, idBod = 9, idEye = 10;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat CeilDf (vec3 p, vec3 pr, float dMin)\n{\n  vec3 q;\n  float dc[3], dp[2], dd[3], d;\n  q = p;\n  q.x = abs (q.x) - psgSep;\n  q.y -= - stHt * sign (p.x) - 0.06;\n  dc[2] = length (vec2 (q.x, q.y - 2.3)) - 1.7;\n  dd[2] = max (abs (dc[2]) - wThk, 3. - q.y);\n  dc[2] = max (dc[2] + wThk, 2.8 - q.y);\n  q = p;\n  dc[0] = length (vec2 (q.z, q.y + 5.6)) - 12.;\n  dp[0] = dc[0] - wThk;\n  dd[0] = max (max (max (abs (dc[0]) - wThk, 6. - q.y), abs (q.x + 3.8) - stLen), - dc[2]);\n  dc[0] = max (max (dc[0] + wThk, 5.9 - q.y), - q.x - 9.);\n  dc[1] = length (vec2 (q.z, pr.y + 5.7)) - 10.6;\n  dp[1] = dc[1] - wThk;\n  dd[1] = max (max (max (abs (dc[1]) - wThk, 4.45 - pr.y), abs (q.x - 3.5) - stLen - 0.3), - dc[2]);\n  dc[1] = max (dc[1] + wThk, 4.3 - pr.y);\n  dd[2] = max (dd[2], max (- dc[0], - dc[1]));\n  d = min (min (max (dd[0], dp[1]), max (dd[1], dp[0])), dd[2]);\n  DMIN (idCeil);\n  return dMin;\n}\n\nfloat LampDf (vec3 p, vec3 pr, float dMin)\n{\n  vec3 q;\n  float d;\n  q = vec3 (mod (pr.x + 0.8, 1.6) - 1., pr.y - 3.8, pr.z - 2. * stWid + wThk).zyx;\n  d = max (PrCapsDf (q, 0.12, 0.25), abs (pr.x - 0.3 * stLen) - stLen - 0.8);\n  DMINQ (idLamp);\n  q = p;\n  q = vec3 (mod (q.x + 0.8, 1.6) - 0.6, q.y - 5.6, pr.z - 2. * stWid + wThk).zyx;\n  d = max (PrCapsDf (q, 0.12, 0.25), abs (p.x + 4.) - 3.);\n  DMINQ (idLamp);\n  q = p;\n  q.xz = abs (q.xz);\n  q.x = abs (q.x - psgSep);\n  q -= vec3 (psgWid, - stHt * sign (p.x) + 2.6, 5. * stWid);\n  d = PrCapsDf (q, 0.152, 0.25);\n  DMINQ (idLamp);\n  return dMin;\n}\n\nfloat BodDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  for (int j = 0; j < 2; j ++) {\n    for (float k = -1.; k <= 1.; k += 2.) {\n      q = p - pPos[j] * k - vec3 (0.16, 0.8, 0.);\n      q.xz = Rot2D (q.xz, pRot[j] + pi * step (0.5, k));\n      d = PrRoundBoxDf (q, vec3 (0.11 - 0.02 * q.y, 0.8, 0.25 - 0.06 * q.y) - 0.1, 0.1);\n      d = min (d, PrCylDf ((q - vec3 (0., 0.7, 0.)).xzy, 0.3, 0.02));\n      DMINQ (idBod);\n      q.z = abs (q.z);\n      q -= vec3 (0.1, 0.4, 0.12);\n      d = PrCylDf (q.yzx, 0.09, 0.1);\n      DMINQ (idEye);\n    }\n  }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, pr;\n  float dMin, d, s1, s2, spx;\n  dMin = dstFar;\n  spx = sign (p.x);\n  p.z = mod (p.z + 8. * stWid, 2. * 8. * stWid) - 8. * stWid;\n  pr = vec3 (Rot2Cs (p.xy, stCs), abs (p.z) - 2. * stWid);\n  q = p;\n  d = max (abs (q.y) - stHt, abs (pr.z) - stWid);\n  q.xy = pr.xy / stRise;\n  q.x = mod (q.x * stCs.y + stSpd * tCur * sign (p.z), 1.);\n  s1 = q.x / stCs.x;\n  s2 = (q.x - 1.) * stCs.x / (stCs.y * stCs.y);\n  d = 0.6 * stRise * max (max (d, q.y + 0.5 * abs (s1 + s2) - 0.5 * (s1 - s2)), -3.32 - q.y);\n  DMIN (idStep);\n  q = p;\n  q.z = pr.z;\n  d = min (PrBoxDf (q - vec3 (stLen + 0.8, - stHt - 0.02, 0.), vec3 (0.8, 0.02, stWid)),\n     PrBoxDf (q - vec3 (- stLen - 0.8, stHt - 0.02, 0.), vec3 (0.8, 0.02, stWid)));\n  DMIN (idPlat);\n  q = p;\n  d = min (PrCaps2Df ((q.xy - vec2 (stLen + 0.3, - stHt + 0.49)).yx, 0.85, 0.52),\n     PrCaps2Df ((q.xy - vec2 (- stLen - 0.7, stHt + 0.49)).yx, 0.55, 0.52));\n  d = min (d, max (max (abs (pr.y - 0.28) - 0.55, abs (q.x) - stLen - 0.3),\n     abs (q.y - 0.48) - stHt - 0.52));\n  d = max (d, max (abs (abs (pr.z) - stWid - wThk), 0.) - wThk);\n  DMIN (idHrail);\n  q = p;\n  d = max (max (abs (pr.y - 0.15) - 0.42, max (abs (q.x) - stLen - 0.3, - stHt - 0.15 - q.y)),\n     max (stWid + 0.1 - abs (pr.z), pr.z - 2. * stWid));\n  DMIN (idSep);\n  q = p;\n  q.z = abs (q.z) - 8. * stWid - wThk;\n  d = abs (PrBox2Df (q.xz, vec2 (stLen + 3.4, 4. * stWid))) - wThk;\n  d = max (d, max (abs (pr.y - 1.3) - 3.4, abs (q.y - 1.5) - stHt - 1.6));\n  DMIN (idWal);\n  q = p;\n  d = PrBox2Df (vec2 (abs (q.x) - stLen - 6.4, q.y + stHt * spx - 1.5), vec2 (wThk, 1.6));\n  if (vuMode == 0) d = max (d, 4. * stWid - abs (p.z));\n  DMIN (idWal);\n  q = p;\n  q.x = abs (q.x) - psgSep;\n  q.y -= - stHt * spx - 0.06;\n  d = PrBox2Df (q.xy, vec2 (psgWid, wThk));\n  q.x -= -3.1;\n  d = min (d, PrBoxDf (q, vec3 (1.6, wThk, 4. * stWid)));\n  DMIN (idFlor);\n  if (vuMode >= 0) dMin = CeilDf (p, pr, dMin);\n  dMin = LampDf (p, pr, dMin);\n  dMin = BodDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat Truch (vec2 p)\n{\n  vec2 ip;\n  ip = floor (p);\n  p -= ip + 0.5;\n  if (Hashfv2 (ip) < 0.5) p = vec2 (- p.y, p.x);\n  return min (length (0.5 + p), length (0.5 - p));\n}\n\nvec3 ShStagGrid (vec2 p, vec2 g)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.03, 0.07, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.2 * smoothstep (0.35, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, sq.x * sq.y, ss.y);\n}\n\nvoid Setup ()\n{\n  stSpd = 2.;\n  stRise = 0.2;\n  stWid = 0.7;\n  stHt = 3.;\n  wThk = 0.05;\n  stAng = pi / 5.;\n  stCs = sin (stAng + vec2 (0.5 * pi, 0.));\n  stLen = stHt / (stCs.y / stCs.x);\n  psgSep = stLen + 4.9;\n  psgWid = 1.5;\n  pSpd = (stCs.x / stCs.y) * stRise * stSpd / (2. * stLen);\n  stExt = (stLen + 16. * stRise * stCs.x / stCs.y) / stLen;\n  stTurn = stExt * stLen - pi * stWid;\n  for (int j = 0; j < 2; j ++) {\n    pPos[j].xy = stExt * vec2 (stLen, - stHt) * (1. - 2. * mod (pSpd * tCur / stExt +\n       float (j) / 2., 1.));\n    pPos[j].y = clamp (pPos[j].y, - stHt + 0.02, stHt - 0.02);\n    pPos[j].z = 2. * stWid;\n    pRot[j] = 0.;\n    if (abs (pPos[j].x) > stTurn) {\n      pRot[j] = (pPos[j].x - sign (pPos[j].x) * stTurn) / (2. * stWid);\n      pPos[j].xz = vec2 (stTurn * sign (pPos[j].x), 0.) + Rot2D (vec2 (0., 2. * stWid), - pRot[j]);\n    }\n  }\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, qr, rg, u, ltDirL[3];\n  vec2 vf;\n  float dstObj, s, sh, nDotL, dSum, sSum, ux, uz;\n  int idObjP;\n  bool fxz;\n  col = vec3 (0.2, 0.2, 0.4);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    qr = vec3 (Rot2Cs (ro.xy, stCs), abs (ro.z) - 2. * stWid);\n    idObjP = idObj;\n    vn = ObjNf (ro);\n    vf = vec2 (0.);\n    ux = abs (ro.x) - stLen;\n    uz = mod (ro.z + 8. * stWid, 2. * 8. * stWid) - 8. * stWid;\n    if (idObjP == idStep || idObjP == idPlat) {\n      col4 = vec4 (0.7, 0.7, 0.8, 0.3);\n      if (vn.y > 0.99) {\n        s = mod (12. * ro.z / stWid, 1.);\n        col4 *= 0.4 + 0.6 * SmoothBump (0.1, 0.9, 0.05, s);\n        if (idObjP == idStep || idObjP == idPlat && ux < 1.1) col4 =\n           mix (vec4 (0., 0.1, 0., 0.), col4, 0.6 + 0.4 * SmoothBump (0.03, 0.97, 0.01,\n           mod (ro.x * (stCs.y / stCs.x) / stRise + tCur * sign (ro.z) * stSpd, 1.)));\n        if (idObjP == idPlat) col4 = mix (vec4 (0., 0.1, 0., 0.), col4,\n           1. - 0.4 * SmoothBump (0.03, 0.06, 0.01, ux - 1.1));\n        vn.z = 0.3 * (SmoothBump (0.75, 0.95, 0.05, s) - SmoothBump (0.05, 0.25, 0.05, s));\n        vn.y = sqrt (1. - dot (vn.xz, vn.xz));\n      } else {\n        col4 = mix (0.7 * col4, vec4 (0., 0.3, 0., 0.1), SmoothBump (0.3, 0.7, 0.05, mod (4. * ro.z / stWid, 1.))) *\n           (0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.02, mod (16. * ro.z / stWid, 1.)));\n      }\n    } else if (idObjP == idHrail) {\n      col4 = vec4 (0.9, 0.8, 0.7, 0.2);\n      if (abs (vn.x) + abs (vn.y) > 0.001) col4 *= 0.05;\n      else {\n        if (abs (ro.x - 0.25) < stLen && qr.y < 0.18) col4 *= 0.5;\n        col4.rgb *= 1. - 0.2 * SmoothBump (0.45, 0.55, 0.02, mod (2. * ro.x, 1.));\n        if (length (vec2 (ux - 1.3, ro.y + stHt * sign (ro.x) - 0.5)) < 0.07)\n           col4 = (sign (ro.x) == sign (ro.z)) ? vec4 (0., 1., 0., -1.) : vec4 (1., 0., 0., -1.);\n      }\n    } else if (idObjP == idSep) {\n      col4 = vec4 (0.6, 0.4, 0.2, 0.1);\n      if (vn.y > 0.1) {\n        s = mod (2. * ro.x, 1.);\n        col4.rgb *= 0.8 + 0.2 * SmoothBump (0.43, 0.57, 0.02, s);\n        vn.xy = Rot2D (vn.xy, -0.2 * pi * SmoothBump (0.05, 0.1, 0.02, abs (s - 0.5)) * sign (s - 0.5));\n      } else if (abs (vn.x) > 0.99) { \n         col4.rgb *= 0.5 + 0.5 * SmoothBump (0.05, 0.95, 0.02, mod (8. * ro.z, 1.));\n      }\n      vf = vec2 (128., 0.2);\n    } else if (idObjP == idWal) {\n      col4 = vec4 (0.45, 0.5, 0.6, 0.1);\n      fxz = (abs (vn.x) > abs (vn.z));\n      rg = ShStagGrid ((fxz ? ro.zy : ro.xy), vec2 (2., 3.));\n      col4.rgb = mix (col4.rgb, vec3 (0.6, 0.7, 0.4), 0.5 - 0.5 * rg.y);\n      rg.xz *= sign (fxz ? vn.x : vn.z);\n      if (fxz) {\n        if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n        else vn.xz = Rot2D (vn.xz, rg.x);\n      } else {\n        if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n        else vn.zx = Rot2D (vn.zx, rg.x);\n      }\n      u.y = abs (abs (ro.y) - stHt) - 1.5;\n      u.z = uz;\n      if (abs (length (u.yz) - 0.5) < 0.11) col4 = vec4 (0.7, 0., 0., 0.1);\n      u.yz = abs (u.yz) - vec2 (0.12, 0.7);\n      if (max (u.y, u.z) < 0.) col4 = vec4 (0., 0., 0.7, 0.1);\n      u.x = ux - (psgSep - stLen);\n      u.y = ro.y + stHt * sign (ro.x);\n      if (abs (u.x) < psgWid && abs (u.y - 1.51) > 1.49 || u.x > - (stLen + 1.5) && u.y < 0.02 ||\n         ro.x < -0.7 && ro.y > stHt + 2.98 || ro.x > -0.7 &&\n         ro.x < stLen + 3.4 && qr.y > 4.44) col4 *= 0.5;\n      if (abs (qr.x + 0.8) < stLen + 1. && abs (qr.y - 1.) < 0.01) {\n        if (abs (mod (qr.x + 0.9 * sign (ro.z) * stSpd * tCur * stRise / stCs.y + 0.1, 0.2) - 0.1) < 0.05)\n           col4 = vec4 (0., 1., 0.5, -1.);\n        else col4 *= 0.8;\n      }\n      if (abs (u.x) < psgWid ||ux < 3.) {\n        s = LampDf (ro, qr, dstFar);\n        col4.rgb += vec3 (0.9, 0.9, 0.8) / (5. + 4000. * s * s);\n      }\n      vf = vec2 (64., 0.5);\n    } else if (idObjP == idLamp) {\n      col4 = vec4 (vec3 (0.9, 0.9, 0.8) * (0.95 + 0.05 * cos (64. * pi * qHit.y)), -1.);\n    } else if (idObjP == idFlor) {\n      col4 = vec4 (0.45, 0.55, 0.5, 0.);\n      if (abs (vn.y) > 0.99) {\n        rg = ShStagGrid (ro.zx, vec2 (4.));\n        col4.rgb *= 0.9 + 0.1 * rg.y;\n        if (rg.x == 0.) vn.yx = Rot2D (vn.yx, rg.z);\n        else vn.yz = Rot2D (vn.yz, rg.x);\n      }\n      u.xz = vec2 (ux - psgWid, abs (ro.z) - 2. * stWid);\n      u.xz = max (abs (vec2 (u.x, abs (u.z) - stWid)) - vec2 (0.07, 0.07), -0.05);\n      col4.rgb *= 0.8 + 0.2 * smoothstep (0., 0.05, max (u.x, u.z));\n      s = length (vec2 (ux - 4.9, uz)) - 0.4;\n      if (s < 0.) {\n        col4 = (abs (s) < 0.02) ? vec4 (0.5, 0.5, 0.6, 0.1) :\n           vec4 (vec3 (0.6, 0.5, 0.4) * (0.9 + 0.1 * smoothstep (-0.7, -0.6, cos (32. * pi * s))), 0.);\n        vn = vec3 (0., 1., 0.);\n      } else vf = vec2 (64., 1.);\n    } else if (idObjP == idCeil) {\n      col4 = vec4 (0.45, 0.55, 0.5, 0.1);\n      col4.rgb *= 1. - 0.15 * SmoothBump (0.4, 0.6, 0.05, Truch (8. * ro.xz));\n      u.xz = abs (ro.xz);\n      s = smoothstep (0., 0.01, min (max (abs (u.z - 0.1) - 0.03, u.x - 7.7),\n         abs (abs (u.x - psgSep) - 0.1) - 0.03));\n      if (s < 0.999) col4 = mix (vec4 (0.8, 0.8, 0.7, -1.), col4, s);\n      else vf = vec2 (128., 0.25);\n    } else if (idObjP == idBod) {\n      col4 = (qHit.y > 0.68 || qHit.x > 0. && abs (qHit.y + 0.1) < 0.4 && abs (qHit.z) < 0.01) ?\n         vec4 (0.1, 0.1, 0.1, 0.) : vec4 (0., 0.3, 0.4, 0.1);\n    } else if (idObjP == idEye) {\n      col4 = (length (qHit.yz) < 0.06) ? vec4 (0.8, 0.4, 0.4, -1.) : vec4 (0., 0.3, 0.4, 0.1);\n    }\n    sh = 1.;\n    if (idObjP == idStep && vn.y > 0.99 || idObjP == idPlat || idObjP == idFlor)\n       sh = 0.7 + 0.3 * smoothstep (0.02, 0.1, BodDf (ro, dstFar));\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    if (col4.a >= 0.) {\n      if (ux > 3.42) {\n        ltDirL[0] = normalize (vec3 (1., 1., 0.));\n        ltDirL[1] = normalize (vec3 (-1., 1., 0.));\n      } else {\n        ltDirL[0] = normalize (vec3 (0.5, 1., 1.));\n        ltDirL[1] = normalize (vec3 (0.5, 1., -1.));\n      }\n      ltDirL[2] = ltDir;\n      dSum = 0.;\n      sSum = 0.;\n      for (int k = 0; k < 3; k ++) {\n        nDotL = max (dot (vn, ltDirL[k]), 0.);\n        if (idObjP == idStep || idObjP == idPlat) nDotL *= nDotL;\n        dSum += ((k < 2) ? 0.5 : 1.) * nDotL;\n        sSum += ((k < 2) ? 0.5 : 1.) * pow (max (dot (normalize (ltDirL[k] - rd), vn), 0.), 32.);\n      }\n      col = col4.rgb * (0.2 + 0.5 * sh * dSum) + step (0.95, sh) * col4.a * sSum;\n    } else col = col4.rgb * (0.3 - 0.7 * dot (vn, rd));\n  }\n  col *= max (0.1, 1. - 2. * smoothstep (0., 1., dstObj / (2. * dstFar)));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv, mMid[2], ut[2], mSize, msw;\n  float el, az, zmFac, asp, vuId, regId, sr, a, t, tt;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./5.) * vec2 (asp, 1.);\n  mMid[0] = vec2 (asp, 1.) * (1. - mSize.y) * vec2 (1., -1.);\n  mMid[1] = vec2 (asp, 1.) * (1. - mSize.y) * vec2 (1., 1.);\n  for (int k = 0; k < 2; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  vuMode = -1;\n  regId = -1.;\n  if (mPtr.z > 0.) {\n    for (int k = 0; k < 2; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (max (abs (msw.x), abs (msw.y)) < mSize.y) {\n        regId = 1. + float (k);\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == -1.) msw = mPtr.xy;\n  }\n  if (vuMode != 0) {\n    vuId = 0.;\n    for (int k = 0; k < 2; k ++) {\n      if (max (ut[k].x, ut[k].y) < 0.) {\n        uv = (uv - mMid[k]) / mSize.y;\n        vuId = float (k + 1);\n        break;\n      }\n    }\n    if (regId == 1.) {\n      if (vuId == 0. || vuId == 1.) vuId = 1. - vuId;\n    } else if (regId == 2.) {\n      if (vuId == 0. || vuId == 2.) vuId = 2. - vuId;\n    }\n    vuMode = int (vuId) + 1;\n  }\n  Setup ();\n  if (vuMode == 0) {\n    az = -0.4 * pi;\n    el = -0.1 * pi;\n  } else if (vuMode == 1) {\n    az = 0.;\n    el = 0.;\n  } else if (vuMode == 2) {\n    az = -0.5 * pi;\n    el = 0.;\n  } else if (vuMode == 3) {\n    az = 0.5 * pi;\n    el = 0.;\n  }\n  if (mPtr.z > 0.) {\n    az += 2. * pi * msw.x;\n    el += pi * msw.y;\n  }\n  el = clamp (el, -0.45 * pi, 0.45 * pi);\n  if (vuMode == 0) {\n    zmFac = 3.5;\n  } else if (vuMode == 1) {\n    t = mod (pSpd * tCur / stExt + 0.25, 2.);\n    tt = mod (t, 1.);\n    ro.xy = stExt * vec2 (stLen, - stHt) * (1. - 2. * tt);\n    ro.y = clamp (ro.y, - stHt + 0.02, stHt - 0.02);\n    ro.z = 2. * stWid;\n    if (t > 1.) ro *= -1.;\n    ro.y += 2. - 0.05;\n    if (abs (ro.x) > stTurn) {\n      a = (ro.x - sign (ro.x) * stTurn) / (2. * stWid);\n      if (t > 1.) a = pi - a;\n      ro.xz = vec2 (stTurn * sign (ro.x), 0.) + Rot2D (vec2 (0., 2. * stWid), - a);\n    } else a = (t > 1.) ? pi : 0.;\n    az += a - 0.5 * pi;\n    el -= 0.8 * stAng * SmoothBump (0.3, 0.7, 0.05, tt) * sign (t - 1.);\n    zmFac = 2.;\n  } else if (vuMode == 2) {\n    ro = vec3 (8., -1., 0.);\n    zmFac = 1.5;\n  } else if (vuMode == 3) {\n    ro = vec3 (-8., 5., 0.);\n    zmFac = 1.5;\n  } \n  vuMat = StdVuMat (el, az);\n  if (vuMode == 0) ro = vuMat * vec3 (0., 0., -30.);\n  dstFar = 60.;\n  ltDir = vuMat * normalize (vec3 (0., 0.3, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  col = mix (col, vec3 (Maxv3 (col)), 0.2);\n  if (vuMode > 0) {\n    for (int k = 0; k < 2; k ++) {\n      if (max (ut[k].x, ut[k].y) < 0. && min (abs (ut[k].x), abs (ut[k].y)) * canvas.y < 2.)\n         col = vec3 (0.4, 0., 0.);\n    }\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBBWm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 1145, 1189, 1189, 2035], [2037, 2037, 2081, 2081, 2636], [2638, 2638, 2672, 2672, 3200], [3202, 3202, 3224, 3224, 5208], [5210, 5210, 5243, 5243, 5427], [5429, 5429, 5450, 5450, 5707], [5709, 5709, 5731, 5731, 5879], [5881, 5881, 5915, 5915, 6259], [6261, 6261, 6276, 6276, 7124], [7126, 7126, 7161, 7161, 13779], [13781, 13781, 13837, 13837, 17232], [17234, 17234, 17266, 17266, 17366], [17368, 17368, 17401, 17401, 17490], [17492, 17492, 17538, 17538, 17585], [17587, 17587, 17629, 17629, 17680], [17682, 17682, 17725, 17725, 17789], [17791, 17791, 17835, 17835, 17895], [17897, 17897, 17919, 17919, 17957], [17959, 17959, 18016, 18016, 18099], [18101, 18101, 18137, 18137, 18343], [18345, 18345, 18375, 18375, 18488], [18490, 18490, 18521, 18521, 18585], [18619, 18619, 18643, 18643, 18703], [18705, 18705, 18729, 18729, 18841], [18843, 18843, 18868, 18868, 19054], [19056, 19056, 19085, 19085, 19297], [19299, 19299, 19338, 19338, 19518]]}
{"id": "3lBBzt", "name": "Hommage  Fiona Robinson", "author": "DrNoob", "description": "Hommage  Fiona Robinson (\"Unstable Horizons\")\nhttps://blankspacebooks.wordpress.com/2010/12/21/beyond-the-personal-and-agnes-martin-at-tate-modern-2/", "tags": ["reproduction"], "likes": 6, "viewed": 83, "published": "Public", "date": "1599922381", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: Thomas Stehle\n// Title: Hommage  Fiona Robinson (\"Unstable Horizons\")\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// https://blankspacebooks.wordpress.com/2010/12/21/beyond-the-personal-and-agnes-martin-at-tate-modern-2/\n\n// 1D hash for 1D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(in float p) {\n    p = fract(p * 0.011);\n    p *= p + 7.5;\n    p *= p + p;\n    return fract(p);\n}\n\n// 1D hash for 4D input\nvec4 hash14(in float p) {\n    return vec4(hash11(p), hash11(p + 10.0), hash11(p + 20.0), hash11(p + 30.0));\n}\n\n// 1D hash for 2D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash21(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 1D hash for 3D input\nfloat hash31(in vec3 p) {\n    vec3 q = fract(p * 0.1031);\n    q += dot(q, q.yzx + 33.33);\n    return fract((q.x + q.y) * q.z);\n}\n\n// 2D value noise by Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vnoise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash21(i);\n    float b = hash21(i + vec2(1.0, 0.0));\n    float c = hash21(i + vec2(0.0, 1.0));\n    float d = hash21(i + vec2(1.0, 1.0));\n\n    // Smooth interpolation (smoothstep without clamping)\n    vec2 u = f*f * (3.0 - 2.0*f);\n\n    // Mix 4 coorners\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// 2D Fractional Brownian motion based on value noise by Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vfbm(vec2 p) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    const int noctaves = 5;\n    for (int i = 0; i < noctaves; ++i) {\n        v += a * vnoise(p);\n        p = rot * p * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// Oriented box by iq\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdOrientedBox(in vec2 p, in vec2 a, in vec2 b, float th) {\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = p-(a+b)*0.5;\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat off(in float amp, in float freq) {\n    return amp * sin(freq * iTime);\n}\n\nvec4 line(in vec2 p, in vec4 h, in float dl, in float dr, in float w) {\n    const vec3 lcol = 0.25 * vec3(0.17, 0.2, 0.2);\n    const vec3 fcol = vec3(0.5);\n    const float s = 0.0035;\n    vec2 l = vec2(-0.5 * iResolution.x / iResolution.y, 0.0);\n    vec2 r = vec2( 0.5 * iResolution.x / iResolution.y, 0.0);\n    \n    // Randomized start and end points\n    vec2 a = l + vec2(0.0, dl + off(0.1 * h.x, 2.0 * h.y));\n    vec2 b = r + vec2(0.0, dr + off(0.2 * h.z, 0.7 * h.w));\n    \n    // Line distance\n    float t = 1.0 - smoothstep(w - s, w + s, sdOrientedBox(p, a, b, w));\n    \n    if (t > 0.0) {\n        // Modulate density along line\n        vec2 d = (b - a) / length(b - a);\n        vec2 q = p - 0.5 * (a + b);\n        q = mat2(d.x, -d.y, d.y, d.x) * q;\n        float density = vfbm(60.0 * q + 40.0 * h.x);\n        density *= smoothstep(0.3 + 0.7 * h.y, 1.0, density);\n\n        return vec4(mix(lcol, fcol, density), t);\n    } else {\n        return vec4(0);\n    }\n}\n      \nvec4 composite(in vec4 src, in vec4 tgt) {\n    return vec4(mix(src.rgb, tgt.rgb, tgt.a), tgt.a + src.a * (1.0 - tgt.a));\n}\n\nvec4 lines(in vec2 p) {\n    vec4 res = vec4(0);\n    \n    // Six thick lines\n    res = composite(res, line(p, hash14(1.0), -0.10,  0.15, 0.01));\n    res = composite(res, line(p, hash14(2.0), -0.45,  0.13, 0.007));\n    res = composite(res, line(p, hash14(3.0), -0.48,  0.03, 0.008));\n    res = composite(res, line(p, hash14(4.0),  0.08, -0.18, 0.0075));\n    res = composite(res, line(p, hash14(5.0),  0.03, -0.29, 0.0075));\n    res = composite(res, line(p, hash14(6.0), -0.25, -0.34, 0.006));\n\n    // Additional thin lines\n    const float atten = 0.4;\n    const int nlines = 25;\n    const float lstep = 1.0 / float(nlines);\n    for (int i = 0; i < nlines; ++i) {\n        float idx = float(i);\n        vec4 h = hash14(7.0 + idx);\n        float dl = -0.5 + 0.75 * h.x;\n        float dr = -0.5 + 0.75 * h.y;\n        float w = 0.0001 + 0.002 * h.z;\n        res = composite(res, atten * line(p, h, dl, dr, w));\n    }\n    \n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// Normalize input coordinates such that (0, 0) is in the center\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n    \n    // Output color\n    vec3 col = vec3(182, 182, 178) / 255.0;\n    \n    // Lines layer\n    vec4 res = lines(uv);\n    col = mix(col, res.rgb, res.a);\n    \n    // Vignetting\n    float vig = length(uv) * 0.75;\n\tvig = vig * vig + 1.0;\n    col *= 1.0 / (vig * vig);\n    \n    // Add layer of animated white noise\n    col += 0.05* vec3(hash31(vec3(fragCoord.xy, fract(0.001 * iTime))));\n    \n    // Final result\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBBzt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[280, 362, 388, 388, 471], [473, 497, 522, 522, 606], [608, 690, 715, 715, 833], [835, 859, 884, 884, 987], [989, 1066, 1091, 1091, 1545], [1547, 1660, 1680, 1680, 2015], [2017, 2114, 2178, 2178, 2389], [2391, 2391, 2431, 2431, 2469], [2471, 2471, 2542, 2542, 3436], [3444, 3444, 3486, 3486, 3566], [3568, 3568, 3591, 3591, 4500], [4502, 4502, 4557, 4623, 5135]]}
{"id": "3lBfDc", "name": "TestBalls", "author": "cha5m", "description": "Testing stuff", "tags": ["test"], "likes": 1, "viewed": 46, "published": "Public", "date": "1599969689", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int NUM_STEPS = 200;\nconst float PI\t \t= 3.1415;\nconst float START_FOG_DIST = 0.;\nconst float END_FOG_DIST = 17.;\nconst vec3 FOG_COLOR = vec3(.55,.6,.6);\nconst float EPSILON\t= 1e-3;\n#define SHADOW_EPSILON EPSILON*100.\n#define ZERO min(iFrame,0)\n    struct Material {\n        vec3 color;\n    };\nstruct Object\n{\n    float dist;\n    Material mat;\n};\nstruct MarchResult\n{\n    bool hit;\n    vec3 pos;\n    vec3 normal;\n    Material mat;\n};   \n    \nvec3 whiteify(vec3 col){\n    float m = max(max(col.x,col.y),col.z);\n    return col/m;\n}\n    vec3 powv(vec3 col,float p){return vec3(pow(col.x,p),pow(col.y,p),pow(col.z,p));}\n    vec3 linToGamma(vec3 col){return powv(col, 1.0 / 2.2);}\n    vec3 gammaToLin(vec3 col){return powv(col, 2.2);}\nObject su( Object o1, Object o2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(o2.dist-o1.dist)/k, 0.0, 1.0 );\n    float newDist =mix( o2.dist, o1.dist, h ) - k*h*(1.0-h);\n    vec3 newColor =mix( gammaToLin(o2.mat.color), gammaToLin(o1.mat.color), h ) - k*h*(1.0-h);\n    return Object(newDist,Material(linToGamma((newColor))));\n}\nfloat smin( float a, float b, float c, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b )+exp2(-k*c);\n    return -log2( res )/k;\n}\nObject su( Object o1, Object o2, Object o3, float k ) \n{\n    vec3 newColor = gammaToLin(o1.mat.color)*exp2( -k*o1.dist )+gammaToLin(o2.mat.color)*exp2( -k*o2.dist )+gammaToLin(o3.mat.color)*exp2( -k*o3.dist );\n    newColor = whiteify(newColor);\n    float newDist = smin(o1.dist,o2.dist,o3.dist,k);\n    return Object(newDist,Material(linToGamma(newColor)));\n}\nObject mi(Object o1, Object o2){\n \tif (o1.dist<o2.dist)\n        return o1;\n    return o2;\n}\n\nObject mixx(Object o1, Object o2, float f){\n \treturn su(o1,o2,f);   \n}\nObject sphere(vec3 pos,vec3 spherePos,float radius,vec3 color){\n return Object(distance(spherePos,pos)-radius,Material(color));\n}\nint gmod(int a, int b) {\n  return (((a % b) + b) % b);\n}\n\nObject DistEst(vec3 pos){\n    float planeHeight=0.;\n    float planeDist = abs(pos.y-planeHeight);\n    vec3 red = vec3(1.,0.,0.);\n    vec3 green = vec3(0.,1.,0.);\n    vec3 blue= vec3(0.,0.,1.);\n    vec3 grey = vec3(.8,.8,.8);\n    vec3 darkGrey = vec3(.2,.2,.2);\n    vec3 groundCol = darkGrey;\n    bool xOdd = gmod(int(floor(pos.x)),2)==1;\n    bool zOdd = gmod(int(floor(pos.z)),2)==1;\n        if ((xOdd &&!zOdd)||(zOdd && !xOdd)){\n        groundCol=grey;\n            }\n            Object plane = Object(planeDist,Material(groundCol));\n    float leftShift = 1.;\n    Object redSphere = sphere(pos,vec3(leftShift/2.,2.,6.0),1.0,red);\n    Object greenSphere = sphere(pos,vec3(0.,1.,6.0),1.0,green);\n    Object blueSphere = sphere(pos,vec3(leftShift,1.,6.0),1.0,blue);\n    float mixLerp= 50.*clamp((sin(iTime*2.)+1.)/2.,0.,1.)+3.;\n    return mi(su(greenSphere,redSphere,blueSphere,mixLerp),plane);\n}\n\n    vec3 calcNorm(vec3 pos){\n        vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 1.*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*DistEst(pos+0.00005*e).dist;\n    }\n    return normalize(n);\n}\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{angles=angles.yxz;\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n        return rotX*rotY*rotZ;\n    }\n\nmat3 Rotate(float a1,float a2,float a3){\n return Rotate(vec3(a1,a2,a3));   \n}\nvec3 Lerp(vec3 v1, vec3 v2, float t){\n \tt=clamp(t,0.,1.);\n        return vec3(mix(v1.x,v2.x,t),mix(v1.y,v2.y,t),mix(v1.z,v2.z,t));\n}\nMarchResult March(vec3 ori, vec3 dir){\n    float distSoFar = 0.;\n\tvec3 pos = ori;\n    for (int i=0;i<NUM_STEPS;i++){\n     \tObject obj = DistEst(pos);\n        distSoFar+=obj.dist;\n        if (obj.dist<=EPSILON){\n            vec3 normal =calcNorm(pos);\n            return MarchResult(true,pos,normal,obj.mat);\n        }\n        pos+=dir*obj.dist;\n    }\n    return MarchResult(false,vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),Material(vec3(0.0,0.0,0.0)));\n}\nvec3 Fog(vec3 col,float dist){\n    return Lerp(col,FOG_COLOR,(dist-START_FOG_DIST)/(END_FOG_DIST-START_FOG_DIST));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(fragCoord.xy / iResolution.xy-.5);\n    uv.x *= iResolution.x / iResolution.y; // bteitler: Aspect ratio correction - if you don't do this your rays will be distorted\n\tvec3 camPos = vec3(0.0,1.5+sin(iTime),0.0);\n    vec3 dir = normalize(vec3(uv.xy,2.0));\n    MarchResult march = March(camPos,dir);\n    vec3 finalCol;\n    if (march.hit){\n        vec3 lightDir = normalize(vec3(-1.0,1.0,-1.0));\n        vec3 reflDir = normalize(march.normal)*2.+dir;\n        MarchResult reflMarch = March(march.pos+reflDir*SHADOW_EPSILON,reflDir);\n        MarchResult shadowMarch = March(march.pos+lightDir*SHADOW_EPSILON,lightDir);\n        float shadow = 1.;\n        if (shadowMarch.hit){\n        \tshadow =.5;\n        }\n        float light = .5*(1.+dot(march.normal,lightDir));\n        vec3 diffuse = shadow*march.mat.color*light;\n        vec3 refl = FOG_COLOR;\n        if (reflMarch.hit){\n            refl= Fog(reflMarch.mat.color,distance(reflMarch.pos,march.pos));\n                }\n        finalCol = Fog(Lerp(diffuse,refl,.1),distance(march.pos,camPos));  \n    } else {\n        finalCol = FOG_COLOR;\n    }\n    fragColor = vec4(finalCol,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBfDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[447, 447, 471, 471, 534], [539, 539, 567, 567, 620], [625, 625, 651, 651, 680], [685, 685, 711, 711, 734], [735, 735, 780, 780, 1063], [1064, 1064, 1114, 1114, 1199], [1200, 1200, 1256, 1256, 1558], [1559, 1559, 1591, 1591, 1650], [1652, 1652, 1695, 1695, 1722], [1723, 1723, 1786, 1786, 1852], [1853, 1853, 1877, 1877, 1909], [1911, 1911, 1936, 1936, 2804], [2810, 2810, 2834, 2834, 3046], [3047, 3119, 3145, 3145, 3455], [3457, 3457, 3497, 3497, 3534], [3535, 3535, 3572, 3572, 3667], [3668, 3668, 3706, 3706, 4115], [4116, 4116, 4146, 4146, 4232], [4234, 4234, 4291, 4291, 5437]]}
{"id": "3lBfWV", "name": "Simple Ray Traced", "author": "BeardThings", "description": "Simple ray traced sphere", "tags": ["simple"], "likes": 0, "viewed": 173, "published": "Public API", "date": "1600003167", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    float aspect = iResolution.y / iResolution.x;\n    vec3 v=vec3(0.,0.,1.)+vec3(uv.x,0.,0.)+vec3(0.,uv.y*aspect,0.);\n    vec3 o=vec3(0.,0.,-2.);\n    float r=0.5;\n\n    float a=dot(v,v);\n    float b=2.*dot(v,o);\n    float c=dot(o,o)-r*r;\n    float d=b*b-4.*a*c;\n    \n    fragColor = vec4(0.);\n    if(d>=0.)\n    {\n        float t=(-b-sqrt(d))/(2.*a);\n        vec3 n=normalize(o+v*t);\n        \n        float rot=iTime*0.5;\n        vec3 l=normalize(vec3(cos(rot),0.707,-sin(rot)));\n        \n        fragColor=vec4(1.)*dot(l,n);\n    }  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBfWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 637]]}
{"id": "3lBfzG", "name": "original-20731.6", "author": "jorge2017a1", "description": "original-20731.6", "tags": ["original207316"], "likes": 3, "viewed": 40, "published": "Public", "date": "1599164675", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float pi = 3.141592653589793;\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdGround(vec3 p) \n{\n    float h = 0.1 * sin(p.x * pi * 0.3) + 0.1 * sin(p.z * pi * 0.5);\n    h += 0.05 * sin(p.x * pi * 0.1) + 0.05 * sin(p.z * pi * 0.5)+sin(p.x*0.0125);\n    float d = length(p.xz) - 4.5;\n    d = smoothstep(1.0, 0.6, d) * smoothstep(0.0, 0.4, d);\n    return p.y + h*(1.0 - d+h*2.0);\n}\n\nfloat sdSphere(in vec3 p, in float r) \n{\n    return length(p) - r;\n}\n\nfloat sdHexa(vec3 p) {\n    vec3 q = abs(p);\n    return max(max(q.x + q.z * 0.57, q.z * 1.14) - 0.2, q.y - 0.02);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * ((b - a) / k), 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec4 map(in vec3 p) {\n    vec4 res = vec4(0.0);\n    float d1 = 100.0;\n    d1 = min(d1, sdGround(p));\n    float r = 4.0;\n    float x = r * sin(iTime);\n    float z = r * cos(iTime);\n    float d2 = min(100.0, sdSphere(p - vec3(x, 0.2, z), 0.1));\n    d2 = smin(d2, sdHexa(p - vec3(x, 0.2, z)), 0.1);\n    res.w = min(d1, d2);\n    res.rgb = mix(vec3(0.0), vec3(0.5, 1.3, 0.2), clamp(smoothstep(0.0, 0.01, d1), 0.0, 1.0));\n    res.rgb = mix(res.rgb, vec3(0.4, 1.0, 0.8), clamp(smoothstep(0.0, 0.01, d2), 0.0, 1.0));\n    return res;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(p + e.xyy).w - map(p - e.xyy).w,\n        map(p + e.yxy).w - map(p - e.yxy).w,\n        map(p + e.yyx).w - map(p - e.yyx).w\n    );\n    return normalize(nor);\n}\n\nvec4 castRay(in vec3 ro, in vec3 rd, in float maxt) {\n    float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n    vec4 col = vec4(0.0);\n    for(int i = 0; i < 60; i++) {\n        if(abs(h) < precis || t > maxt) continue;\n        col = map(ro + rd * t);\n        h = col.w;\n        t += h;\n    }\n    return vec4(col.rgb, t);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n    float sh = 1.0;\n    float t = mint;\n    float h = 0.0;\n    for(int i = 0; i < 30; i++) {\n        if(t > maxt) continue;\n        h = map(ro + rd * t).w;\n        sh = min(sh, k * h / t);\n        t += h;\n    }\n    return sh;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(1.0);\n    vec4 res = castRay(ro, rd, 20.0);\n    float t = res.w;\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n    vec3 lig = normalize(vec3(-0.4, 0.7, 0.5));\n    float dif = clamp(dot(lig, nor), 0.0, 1.0);\n    float spec = pow(clamp(dot(reflect(rd, nor), lig), 0.0, 1.0), 16.0);\n    float sh = softshadow(pos, lig, 0.02, 20.0, 7.0);\n    float k = (20.0 - t) / 20.0;\n    k = k*k*(3.0 - 2.0*k);\n    col = mix(res.rgb * (dif + spec) * sh, vec3(1.0, 0.2, 0.3), 1.0 - k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    float r = 4.0;\n    float x = r * sin(iTime);\n    float z = r * cos(iTime);\n    vec3 cam_t = vec3(r * sin(iTime - 0.4), 0.5, r * cos(iTime - 0.4));\n    vec3 cam_s = vec3(0.0, 2.0, 3.0);\n    vec3 cam = mix(cam_t, cam_s, 0.5 + 0.5 * sin(iTime * 0.2));\n    vec3 ro = cam;\n    vec3 ta = vec3(x, 0.0, z);\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    vec3 rd = normalize(p.x * cu + p.y * cv + 2.5 * cw);\n    vec3 col = render(ro, rd);\n    \n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBfzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 64, 64, 82], [84, 84, 109, 109, 391], [393, 393, 433, 433, 461], [463, 463, 485, 485, 577], [579, 579, 618, 618, 723], [725, 725, 746, 746, 1251], [1253, 1253, 1281, 1281, 1508], [1510, 1510, 1563, 1563, 1850], [1852, 1852, 1936, 1936, 2164], [2166, 2166, 2203, 2203, 2723], [2725, 2725, 2782, 2782, 3477]]}
{"id": "3lBfzV", "name": "15 edits of something by.....", "author": "celifrog", "description": "Originally created by Inigo Quil\n\n15 edits to the syntax done by Celia Watson :D \nFEEL FREE TO FORK :D", "tags": ["fun", "trippy"], "likes": 2, "viewed": 151, "published": "Public API", "date": "1599308949", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A simple way to prevent aliasing of cosine functions (the color\n// palette in this case is made of 8 layers) by attenuating them\n// when their oscillations become smaller than a pixel. Left is\n// direct use of cos(x), right is band-limited cos(x).\n//\n// Box-filtering of cos(x):\n//\n// (1/w)cos(t)dt with t  (x-w, x+w)\n// = [sin(x+w) - sin(x-w)]/w\n// = cos(x)sin(w)/(w)\n//\n// Can approximate smoothstep(2,0,w)  sin(w/2)/(w/2),\n// which you can also see as attenuating cos(x) when it \n// oscilates more than once per pixel. More info:\n//\n// https://iquilezles.org/www/articles/bandlimiting/bandlimiting.htm\n//\n// Related Shader:\n//   https://www.shadertoy.com/view/WtScDt\n//   https://www.shadertoy.com/view/wtXfRH\n//   https://www.shadertoy.com/view/3tScWd\n\n\n// box-filted cos(x)\nvec3 fcos( in vec3 x )\n{\n    vec3 w = fwidth(-x * -x);\n\t#if 1\n    return cos(x) * sin(-4.5*w++)/(4.5*w++) * cos(x++);       // exact\n\t#else\n    return cos(x) * smoothstep(111-1155556.2832,4.0,w); // approx\n\t#endif    \n}\n\n// pick raw cosine, or band-limited cosine\nbool  mode = false;\nvec3  mcos( vec3 x){return mode?cos(x):fcos(x);}\n\n// color palette, made of 8 cos functions\n// (see https://iquilezles.org/www/articles/palettes/palettes.htm)\nvec3 getColor( in float t )\n{\n    vec3 col = vec3(11.6,-0.5,.4) * vec3(-5,-4,2);\n    col += -55.14*mcos(6.2832*t*   559.0+vec3(59.0,0.5,0.6));\n        col += -5.14*mcos(-.2832*t*   1.0+vec3(-9.0,0.5,0.6));\n    col += 0.13/mcos(56.2832*t*  3.1+vec3(9.5,0.6,-1.0));\n    col += .12/mcos(1.2832*t*  5.1+vec3(0.1,0.7,1.1));\n    col += .11*mcos(.2832*t*  -93333333333333.1+vec3(0.1,0.5,1.2));\n    col += .810/mcos(1.2832*t* .1+vec3(0.0,0.3,0.9));\n    col += .09*mcos(.2*t* 31.1*vec3(0.1,33333333333.5,.3));\n    col += .08*mcos(6.2832*t* 65.1+vec3(11.1,0.5,1.3));\n    col += .07*mcos(.2832*t*-555.1*vec3(.3,5.2,0.8));\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordiantes\n\tvec2 q = (1.0*fragCoord-iResolution.xy)/iResolution.x;\n\n    // separation\n    float th = (iMouse.z>105.001) ? (9.0*iMouse.x-iResolution.x)/iResolution.y : 15.8*sin(iTime);\n    mode = (q.x<th);\n    \n    // deformation\n    vec2 p = -5.0* -q*dot(q,q) ;\n\n    // animation\n    p.xy += -55.55*iTime ;\n\n    // texture\n    vec3 col = min(getColor(p.x),getColor(p.y));\n\n    // vignetting\n    col *= .79*.1 *.2*length(q++) *length(-q--) * length(-q--)*length(q++) *length(-q--) * length(-q--);\n    \n;\n    \n    // palette\n    if( q.y<-1444.9 ) col = getColor( fragCoord.x/iResolution.x );\n\n    fragColor = vec4( col, 14.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBfzV.jpg", "access": "shaders20k", "license": "mit", "functions": [[1864, 1885, 1909, 1909, 2104], [2106, 2169, 2189, 2189, 2217], [2219, 2328, 2357, 2357, 2956], [2958, 2958, 3014, 3033, 3650]]}
{"id": "3ljBDc", "name": "Midnight Maya Pyramid ", "author": "zproxy", "description": "https://www.shadertoy.com/view/tlSfW3", "tags": ["pyramid"], "likes": 4, "viewed": 79, "published": "Public", "date": "1600032373", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// textured + displaced + mouse control variant of https://shadertoy.com/view/wl2BWV\n// forest variant of https://shadertoy.com/view/tlSfDK\n\n#define rot(a)        mat2( cos( a + vec4(0,33,11,0)) )\n#define sfloor(x)   ( floor(x-pix/2.) + max( 0., 1.-fract(-x+pix/2.) / pix ) ) // https://www.shadertoy.com/view/tsyXzV \n#define hash2x3(p)    fract(sin((p)*mat3x2(127.1,311.7,  269.5,183.3,  113.5,271.9))*43758.5453123) // https://www.shadertoy.com/view/llySRh\n#define keyPress(a) ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.) // https://www.shadertoy.com/view/llySRh\n#define T(V)          texture(iChannel1,V/4.)\n\nfloat pix, s;                                         // a: material id\n\n\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n \n\n//From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\n//Very happy with this star function, cheap and smooth\nvec3 stars(in vec3 p)\n{\n    // 47fps\n    \n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.5; // too small  and they will flicker\n    \n    // more stars?\n\tfor (float i=0.;i<2.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.7;\n}\n\nvec4 startrails(in vec3 rd)\n{\n    vec3 col0 = stars( normalize(rotx(rd, iTime * 0.1)));\n\n    vec3 col = col0;\n\n    for (int i = -160; i < 0; i++)\n    {\n    \tvec3 col1 = stars( normalize(rotx(rd, iTime * 0.1 + (float(i) * (1./600.) ))));\n        \n    \tcol += col1;    \n    }\n    \n    return vec4(3.*col,1);\n}\n\nfloat map( vec3 p ) {\n    float t,a; vec3 q = p;\n    q.xy = abs(q.xy), a = max(q.x,q.y);               // --- pyramid\n    t = max( (a==q.x?q.y:q.x) -2.,                    // slopes sides\n             a/1.3 + clamp(q.z,0.,9.) -9.25 );        // slopes top \n    t = max( t, q.z-7.);                              // top end\n    t = min( t, a + clamp(sfloor(q.z),0.,7.) - 9.);   // grades \n    t = max( t,-max(min(q.x,q.y)-.5,abs(q.z-7.5)-.5));// doors\n    t = max( t,-max(3.*abs(q.z-7.5),a)+1.5 );         // room\n    t = max( t, q.z-9.);                              // top end\n    s = q.z;                                          // --- forest. floor, then trees\n    q = .03*sin(15.*p); p += q.x+q.y+q.z;             // distortion\n    for (int k=0; k<9; k++) {                         // Worley-like dot structure\n        vec2 d = vec2(k%3-1,k/3-1);                   // seek for closest dot in 9x9 cells around\n        s = min(s, length( hash2x3(floor(p.xy)+d)           // random dot(cell)\n                          - vec3(fract(p.xy)-d,p.z) ) -.5); // raypos rel to cur cell\n    }\n    return min(t,s);\n}\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y,                     // normalized centered coords\n          M = iMouse.xy / R;\n    pix = .5; // 100./R.y;\n    float t = iTime*0.0125, _t = 1.+.5*sin(.2*(t+5.)), \n          c = 0.,z = 1.5;                              // color (pseudo-shading), zoom\n    t*=.3; if (iMouse.z>0.)                           // mouse control\n        _t = keyPress(32) ? z=9.*M.y,_t : 1.6*M.y, t = -3.*M.x;\n    vec3  D = normalize( vec3(U,-z) ),                // ray direction. z = field of view = zoom\n          p = vec3(0,1,25);                           // ray origin, then current point on ray\n    D.yz *= rot(_t); D.xy *= rot(0.8 + t);                  // rotate camera\n    p.yz *= rot(_t); p.xy *= rot(0.25 + t);\n    t = 1e5;\n    for ( ; c < 50. && t > .01 ; c++ )                // march scene\n        t = map(p),                                   // distance to objects\n        //t != s ? t += .3*( T(.3*p.xy)+T(.3*p.xz)+T(.3*p.yz) -1.5 ).r : t, // displacement (temple)\n        p += .5*t*D;                                  // sphere-tracing step\n    \n  //c = 1. - c/50.;                                   // pseudo-lighting\n    c = 3.*exp(-c/9.11);\n    O = t==s                                          // coloring\n             ?  p.z > 2. ? startrails(D)+vec4(0,0,4, 0)*(0.1 +tan(D.z)*0.7) // sky\n             :  vec4(0,.1127,0.115 ,1)*(.7+.3*p.z)                       // cyan forest\n              *(.5+1.5 )\n             : vec4(0.12,0.1,.6,1)  ;// temple\n    O = pow( c*O, vec4(1./2.2) );                     // to sRGB\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljBDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[666, 687, 714, 714, 802], [806, 866, 887, 887, 1030], [1032, 1087, 1110, 1123, 1605], [1607, 1607, 1636, 1636, 1914], [1916, 1916, 1937, 1937, 3023], [3025, 3025, 3061, 3061, 4638]]}
{"id": "3ljBDG", "name": "like waterfall?", "author": "blue1784", "description": "colorful lines falling down...", "tags": ["2d"], "likes": 4, "viewed": 94, "published": "Public", "date": "1599754144", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 hash22(vec2 p)\n{\n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)));\n\n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\nconst float F2 = 0.5f *(sqrt(3.0) - 1.0);\nconst float G2 = (3.0-sqrt(3.0))/6.0;\n\nfloat simplex_noise_2d(vec2 p) \n{\n    float n0, n1, n2; \n    \n    float s = (p.x + p.y) * F2; \n    vec2 pi = floor(p + vec2(s));\n    float t = (pi.x + pi.y) * G2;\n    vec2 pf = p - (pi - vec2(t));\n\n    vec2 dp;\n    if(pf.x > pf.y) {dp.x=1.; dp.y=0.;}\n    else {dp.x = 0.; dp.y=1.;}      \n    vec2 pf1 = pf - dp + vec2(G2);\n    vec2 pf2 = pf - vec2(1.0 - 2.0 * G2);\n\n    float t0 = 0.5 - pf.x * pf.x - pf.y * pf.y;\n    if(t0<0.) n0 = 0.0;\n    else {\n      t0 *= t0;\n      n0 = t0 * t0 * dot(hash22(pi), pf);\n    }\n    float t1 = 0.5 - pf1.x * pf1.x - pf1.y * pf1.y;\n    if(t1 < 0.) n1 = 0.0;\n    else {\n      t1 *= t1;\n      n1 = t1 * t1 * dot(hash22(pi + dp), pf1);\n    }\n    float t2 = 0.5 - pf2.x * pf2.x -pf2.y * pf2.y;\n    if(t2<0.) n2 = 0.0;\n    else {\n      t2 *= t2;\n      n2 = t2 * t2 * dot(hash22(pi + vec2(1.0)), pf2);\n    }\n    return 70.0 * (n0 + n1 + n2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // making colorful lines\n    float lines = float(int(fragCoord.x) / 20);\n    float blackLines = step(10.1, float(int(fragCoord.x) % 20));\n    float seed = sin(lines + iTime);\n    // may better way to transform float to RGB instead?\n    vec3 color = vec3(seed, 4. * seed * (1. - seed), 1. - seed) * seed * blackLines;\n    \n    float noise = mix(0., 1., simplex_noise_2d(vec2(lines, 2.)));\n    float another_noise = mix(0., .5, simplex_noise_2d(vec2(lines, 3.)));\n   \n    float maxLen = 1.;\n    // edit to change line falling speed\n    float fallSpeed = .3;\n    // randomize line start position and move line start position down by time\n  \tfloat lineStart = fract(noise - iTime * fallSpeed) * maxLen;\n    // randomize line end position\n    float lineEnd = .4 + another_noise;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float len = uv.y;\n    float upper = step(len, lineStart);\n    float deltaLen = abs(len - lineStart);\n    // distance from current y to line start\n    deltaLen = upper * (maxLen - deltaLen) + (1. - upper) * deltaLen;\n    // interpolate attenuation by distance \n    float attenuation = mix(1., 0., min(deltaLen, lineEnd) / lineEnd);\n    color *= attenuation;\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljBDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 158], [241, 241, 274, 274, 1111], [1114, 1114, 1171, 1200, 2395]]}
{"id": "3ljfDW", "name": "Blank Slate-by-P_Malin", "author": "jorge2017a1", "description": "clase de  P_Malin", "tags": ["blankslate"], "likes": 8, "viewed": 182, "published": "Public", "date": "1598967576", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Blank Slate - Work in progress @P_Malin\n// added pan/zoom - hard work stolen from other shaders, thanks @emackey\n \n\nvec2 surfaceSize;\nvec2 surfacePosition;\n\n\nfloat kPI ;\nfloat kHalfPi ;\nfloat kTwoPI ;\n/*\nfloat cos(float v) // workaround for AMD Radeon on OS X\n{ \n\treturn sin(v+kHalfPi);\n}\n*/\n\n//#define ENABLE_MONTE_CARLO\n#define ENABLE_REFLECTIONS\n#define ENABLE_FOG\n#define ENABLE_SPECULAR\n#define ENABLE_POINT_LIGHTT\n        \n#define ENABLE_POINT_LIGHT_FLARE\n\n#ifdef ENABLE_MONTE_CARLO \nvec4 gPixelRandom;\nvec3 gRandomNormal;\n\nvoid CalcPixelRandom()\n{\n\t// Nothing special here, just numbers generated by bashing keyboard\n\tvec4 s1 = sin(time * 3.3422 + gl_FragCoord.xxxx * vec4(324.324234, 563.324234, 657.324234, 764.324234)) * 543.3423;\n\tvec4 s2 = sin(time * 1.3422 + gl_FragCoord.yyyy * vec4(567.324234, 435.324234, 432.324234, 657.324234)) * 654.5423;\n\tgPixelRandom = fract(2142.4 + s1 + s2);\n\tgRandomNormal = normalize( gPixelRandom.xyz - 0.5);\n}\n#endif\n\nstruct C_Ray\n{\n\tvec3 vOrigin;\n\tvec3 vDir;\n};\n \nstruct C_HitInfo\n{\n\tvec3 vPos;\n\tfloat fDistance;\n\tvec3 vObjectId;\n};\n \nstruct C_Material\n{\n\tvec3 cAlbedo;\n\tfloat fR0;\n\tfloat fSmoothness;\n\tvec2 vParam;\n};\n \nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n\tfloat s = sin(fAngle);\n\tfloat c = cos(fAngle);\n\t\n\tvec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n\t\n\treturn vResult;\n}\n \nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n\tfloat s = sin(fAngle);\n\tfloat c = cos(fAngle);\n\t\n\tvec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n\t\n\treturn vResult;\n}\n     \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\tfloat s = sin(fAngle);\n\tfloat c = cos(fAngle);\n\t\n\tvec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n\t\n\treturn vResult;\n}\n \nvec4 DistCombineUnion( const in vec4 v1, const in vec4 v2 )\n{\n\t//if(v1.x < v2.x) return v1; else return v2;\n\treturn mix(v1, v2, step(v2.x, v1.x));\n}\n \nvec4 DistCombineIntersect( const in vec4 v1, const in vec4 v2 )\n{\n\treturn mix(v2, v1, step(v2.x,v1.x));\n}\n \nvec4 DistCombineSubtract( const in vec4 v1, const in vec4 v2 )\n{\n\treturn DistCombineIntersect(v1, vec4(-v2.x, v2.yzw));\n}\n \nvec3 DomainRepeatXZGetTile( const in vec3 vPos, const in vec2 vRepeat, out vec2 vTile )\n{\n\tvec3 vResult = vPos;\n\tvec2 vTilePos = (vPos.xz / vRepeat) + 0.5;\n\tvTile = floor(vTilePos + 1000.0);\n\tvResult.xz = (fract(vTilePos) - 0.5) * vRepeat;\n\treturn vResult;\n}\n \nvec3 DomainRepeatXZ( const in vec3 vPos, const in vec2 vRepeat )\n{\n\tvec3 vResult = vPos;\n\tvec2 vTilePos = (vPos.xz / vRepeat) + 0.5;\n\tvResult.xz = (fract(vTilePos) - 0.5) * vRepeat;\n\treturn vResult;\n}\n \nvec3 DomainRepeatY( const in vec3 vPos, const in float fSize )\n{\n\tvec3 vResult = vPos;\n\tvResult.y = (fract(vPos.y / fSize + 0.5) - 0.5) * fSize;\n\treturn vResult;\n}\n \nvec3 DomainRotateSymmetry( const in vec3 vPos, const in float fSteps )\n{\n\tfloat angle = atan( vPos.x, vPos.z );\n\n\tfloat fScale = fSteps / (kTwoPI);\n\tfloat steppedAngle = (floor(angle * fScale + 0.5)) / fScale;\n\n\tfloat s = sin(-steppedAngle);\n\tfloat c = cos(-steppedAngle);\n\n\tvec3 vResult = vec3( c * vPos.x + s * vPos.z,\n\t\t\t     vPos.y,\n\t\t\t    -s * vPos.x + c * vPos.z);\n\n\treturn vResult;\n}\n \nfloat GetDistanceXYTorus( const in vec3 p, const in float r1, const in float r2 )\n{\n\tvec2 q = vec2(length(p.xy)-r1,p.z);\n\treturn length(q)-r2;\n}\nfloat GetDistanceYZTorus( const in vec3 p, const in float r1, const in float r2 )\n{\n\tvec2 q = vec2(length(p.yz)-r1,p.x);\n\treturn length(q)-r2;\n}\nfloat GetDistanceCylinderY(const in vec3 vPos, const in float r)\n{\n\treturn length(vPos.xz) - r;\n}\nfloat GetDistanceBox( const in vec3 vPos, const in vec3 vSize )\n{\n\tvec3 vDist = (abs(vPos) - vSize);\n\treturn max(vDist.x, max(vDist.y, vDist.z));\n}\n \nfloat GetDistanceRoundedBox( const in vec3 vPos, const in vec3 vSize, float fRadius )\n{\n\tvec3 vClosest = max(min(vPos, vSize), -vSize);\n\treturn length(vClosest - vPos) - fRadius;\n}\n \n// result is x=scene distance y=material or object id; zw are material specific parameters (maybe uv co-ordinates)\nvec4 GetDistanceScene( const in vec3 vPos )\n{          \n\tvec4 vResult = vec4(10000.0, -1.0, 0.0, 0.0);\n       \n\tvec3 vSphereDomain = DomainRepeatXZ(vPos, vec2(5.0, 5.0));\n       \n\tvec4 vDistSphere = vec4( length(vSphereDomain) - 1.0, 2.0, vSphereDomain.xy);\n       \n\tvResult = DistCombineUnion(vResult, vDistSphere);\n\t\t       \n\tvec4 vDistFloor = vec4(vPos.y + 1.0, 1.0, vPos.xz);\n\tvResult = DistCombineUnion(vResult, vDistFloor);\n\t\t       \n\treturn vResult;\n}\n\nC_Material GetObjectMaterial( const in vec3 vObjId, const in vec3 vPos )\n{\n\tC_Material mat;\n\t\t       \n\tif(vObjId.x < 1.5)\n\t{\n\t\t// floor\n\t\tmat.fR0 = 0.02;\n\t\tmat.fSmoothness = 0.0;\n\t\tmat.cAlbedo = vec3(0.7, 0.8, 0.3);\n\t}\n\telse\n\tif(vObjId.x < 2.5)\n\t{\n\t\t// sphere\n\t\tmat.fR0 = 0.05;\n\t\tmat.fSmoothness = 0.9;\n\t\tmat.cAlbedo = vec3(0.05, 0.35, 0.75);\n\t}\n\t\n\treturn mat;\n}\nvec3 GetSkyGradient( const in vec3 vDir )\n{\n\tfloat fBlend = vDir.y * 0.5 + 0.5;\n\treturn mix(vec3(0.0, 0.0, 0.0), vec3(0.4, 0.9, 1.0), fBlend);\n}\nvec3 GetLightPos()\n{\n\tvec3 vLightPos = vec3(0.0, 1.0, 3.0);\n\t#ifdef ENABLE_MONTE_CARLO        \n\tvLightPos += gRandomNormal * 0.2;\n\t#endif\n\treturn vLightPos;\n}\nvec3 GetLightCol()\n{\n\treturn vec3(32.0, 6.0, 1.0) * 10.0;\n}\n \nvec3 GetAmbientLight(const in vec3 vNormal)\n{\n\treturn GetSkyGradient(vNormal);\n}\n\n#define kFogDensity 0.0025\nvoid ApplyAtmosphere(inout vec3 col, const in C_Ray ray, const in C_HitInfo intersection)\n{\n\t#ifdef ENABLE_FOG\n\t// fog\n\tfloat fFogAmount = exp(intersection.fDistance * -kFogDensity);\n\tvec3 cFog = GetSkyGradient(ray.vDir);\n\tcol = mix(cFog, col, fFogAmount);\n\t#endif\n       \n\t// glare from light (a bit hacky - use length of closest approach from ray to light)\n\t#ifdef ENABLE_POINT_LIGHT_FLARE\n\tvec3 vToLight = GetLightPos() - ray.vOrigin;\n\tfloat fDot = dot(vToLight, ray.vDir);\n\tfDot = clamp(fDot, 0.0, intersection.fDistance);\n       \n\tvec3 vClosestPoint = ray.vOrigin + ray.vDir * fDot;\n\tfloat fDist = length(vClosestPoint - GetLightPos());\n\tcol += GetLightCol() * 0.01/ (fDist * fDist);\n\t#endif     \n}\nvec3 GetSceneNormal( const in vec3 vPos )\n{\n\t// tetrahedron normal\n\tfloat fDelta = 0.025;\n\n\tvec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);\n\tvec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);\n\tvec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);\n\tvec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);\n\n\tfloat f1 = GetDistanceScene( vPos + vOffset1 ).x;\n\tfloat f2 = GetDistanceScene( vPos + vOffset2 ).x;\n\tfloat f3 = GetDistanceScene( vPos + vOffset3 ).x;\n\tfloat f4 = GetDistanceScene( vPos + vOffset4 ).x;\n\n\tvec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;\n\n\treturn normalize( vNormal );\n}\n\n#define kRaymarchEpsilon 0.01\n#define kRaymarchMatIter 256\n#define kRaymarchStartDistance 0.1\n// This is an excellent resource on ray marching -> http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvoid Raymarch( const in C_Ray ray, out C_HitInfo result, const float fMaxDist, const int maxIter )\n{         \n\tresult.fDistance = kRaymarchStartDistance;\n\tresult.vObjectId.x = 0.0;\n\t\t\t\t\t\t\t   \n\tfor(int i=0;i<=kRaymarchMatIter;i++)               \n\t{\n\t\tresult.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n\t\tvec4 vSceneDist = GetDistanceScene( result.vPos );\n\t\tresult.vObjectId = vSceneDist.yzw;\n\n\t\t// abs allows backward stepping - should only be necessary for non uniform distance functions\n\t\tif((abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDistance >= fMaxDist) || (i > maxIter))\n\t\t{\n\t\t\tbreak;\n\t\t}                         \n\n\t\tresult.fDistance = result.fDistance + vSceneDist.x;     \n\t}\n       \n       \n\tif(result.fDistance >= fMaxDist)\n\t{\n\t\tresult.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n\t\tresult.vObjectId.x = 0.0;\n\t\tresult.fDistance = 1000.0;\n\t}\n}\n\nfloat GetShadow( const in vec3 vPos, const in vec3 vLightDir, const in float fLightDistance )\n{\n\tC_Ray shadowRay;\n\tshadowRay.vDir = vLightDir;\n\tshadowRay.vOrigin = vPos;\n\n\tC_HitInfo shadowIntersect;\n\tRaymarch(shadowRay, shadowIntersect, fLightDistance, 32);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    \n\treturn step(0.0, shadowIntersect.fDistance) * step(fLightDistance, shadowIntersect.fDistance );          \n}\n\n// http://en.wikipedia.org/wiki/Schlick's_approximation\nfloat Schlick( const in vec3 vNormal, const in vec3 vView, const in float fR0, const in float fSmoothFactor)\n{\n\tfloat fDot = dot(vNormal, -vView);\n\tfDot = min(max((1.0 - fDot), 0.0), 1.0);\n\tfloat fDot2 = fDot * fDot;\n\tfloat fDot5 = fDot2 * fDot2 * fDot;\n\treturn fR0 + (1.0 - fR0) * fDot5 * fSmoothFactor;\n}\n\nfloat GetDiffuseIntensity(const in vec3 vLightDir, const in vec3 vNormal)\n{\n\treturn max(0.0, dot(vLightDir, vNormal));\n}\n\nfloat GetBlinnPhongIntensity(const in C_Ray ray, const in C_Material mat, const in vec3 vLightDir, const in vec3 vNormal)\n{           \n\tvec3 vHalf = normalize(vLightDir - ray.vDir);\n\tfloat fNdotH = max(0.0, dot(vHalf, vNormal));\n\n\tfloat fSpecPower = exp2(4.0 + 6.0 * mat.fSmoothness);\n\tfloat fSpecIntensity = (fSpecPower + 2.0) * 0.125;\n\n\treturn pow(fNdotH, fSpecPower) * fSpecIntensity;\n}\n\n// use distance field to evaluate ambient occlusion\nfloat GetAmbientOcclusion(const in C_Ray ray, const in C_HitInfo intersection, const in vec3 vNormal)\n{\n\tvec3 vPos = intersection.vPos;\n       \n\tfloat fAmbientOcclusion = 1.0;\n       \n\tfloat fDist = 0.0;\n\tfor(int i=0; i<=5; i++)\n\t{\n\t\tfDist += 0.1;\n\n\t\tvec4 vSceneDist = GetDistanceScene(vPos + vNormal * fDist);\n\n\t\tfAmbientOcclusion *= 1.0 - max(0.0, (fDist - vSceneDist.x) * 0.2 / fDist );                                   \n\t}\n       \n\treturn fAmbientOcclusion;\n}\n \nvec3 GetObjectLighting(const in C_Ray ray, const in C_HitInfo intersection, const in C_Material material, const in vec3 vNormal, const in vec3 cReflection)\n{\n\tvec3 cScene ;\n\t\n\tvec3 vSpecularReflection = vec3(0.0);\n\tvec3 vDiffuseReflection = vec3(0.0);\n\t\n\tfloat fAmbientOcclusion = GetAmbientOcclusion(ray, intersection, vNormal);\n\tvec3 vAmbientLight = GetAmbientLight(vNormal) * fAmbientOcclusion;\n\t\n\tvDiffuseReflection += vAmbientLight;\n\t\n\tvSpecularReflection += cReflection * fAmbientOcclusion;\n\t\n    /*\n\t#ifdef ENABLE_POINT_LIGHTT\n\t\tvec3 vLightPos = GetLightPos();\n\t\tvec3 vToLight = vLightPos - intersection.vPos;\n\t\tvec3 vLightDir = normalize(vToLight);\n\t\tfloat fLightDistance = length(vToLight);\n\t\n\t\tfloat fAttenuation = 1.0 / (fLightDistance * fLightDistance);\n\t\n\t\tfloat fShadowBias = 0.1;             \n\t\tfloat fShadowFactor = GetShadow( intersection.vPos + vLightDir * fShadowBias, vLightDir, fLightDistance - fShadowBias );\n\t\tvec3 vIncidentLight = GetLightCol() * fShadowFactor * fAttenuation;\n\t\n\t\tvDiffuseReflection += GetDiffuseIntensity( vLightDir, vNormal ) * vIncidentLight;                                                                                 \n\t\tvSpecularReflection += GetBlinnPhongIntensity( ray, material, vLightDir, vNormal ) * vIncidentLight;\n\t#endif ENABLE_POINT_LIGHTT\n\t*/\n    \n    \n\tvDiffuseReflection *= material.cAlbedo;              \n\t\n\t#ifdef ENABLE_SPECULAR\n\tfloat fFresnel = Schlick(vNormal, ray.vDir, material.fR0, material.fSmoothness * 0.9 + 0.1);\n\tcScene = mix(vDiffuseReflection , vSpecularReflection, fFresnel);\n\t#else\n\tcScene = vDiffuseReflection;\n\t#endif\n\t\n\treturn cScene;\n}\n\nvec3 GetSceneColourSimple( const in C_Ray ray )\n{\n\tC_HitInfo intersection;\n\tRaymarch(ray, intersection, 16.0, 32);\n\t\t\t\t\t    \n\tvec3 cScene;\n\n\tif(intersection.vObjectId.x < 0.5)\n\t{\n\t\tcScene = GetSkyGradient(ray.vDir);\n\t}\n\telse\n\t{\n\t\tC_Material material = GetObjectMaterial(intersection.vObjectId, intersection.vPos);\n\t\tvec3 vNormal = GetSceneNormal(intersection.vPos);\n\n\t\t// use sky gradient instead of reflection\n\t\tvec3 cReflection = GetSkyGradient(reflect(ray.vDir, vNormal));\n\n\t\t// apply lighting\n\t\tcScene = GetObjectLighting(ray, intersection, material, vNormal, cReflection );\n\t}\n\n\tApplyAtmosphere(cScene, ray, intersection);\n\n\treturn cScene;\n}\n\nvec3 GetSceneColour( const in C_Ray ray )\n{                                                           \n\tC_HitInfo intersection;\n\tRaymarch(ray, intersection, 30.0, 256);\n\t\t\t    \n\tvec3 cScene;\n       \n\tif(intersection.vObjectId.x < 0.5)\n\t{\n\t\tcScene = GetSkyGradient(ray.vDir);\n\t}\n\telse\n\t{\n\t\tC_Material material = GetObjectMaterial(intersection.vObjectId, intersection.vPos);\n\t\tvec3 vNormal = GetSceneNormal(intersection.vPos);\n\n\t\t#ifdef ENABLE_MONTE_CARLO\n\t\tvNormal = normalize(vNormal + gRandomNormal / (5.0 + material.fSmoothness * 200.0));\n\t\t#endif\n\n\t\tvec3 cReflection;\n\t\t#ifdef ENABLE_REFLECTIONS    \n\t\t{\n\t\t\t// get colour from reflected ray\n\t\t\tfloat fSepration = 0.05;\n\t\t\tC_Ray reflectRay;\n\t\t\treflectRay.vDir = reflect(ray.vDir, vNormal);\n\t\t\treflectRay.vOrigin = intersection.vPos + reflectRay.vDir * fSepration;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t      \n\t\t\tcReflection = GetSceneColourSimple(reflectRay);                                                                         \n\t\t}\n\t\t#else\n\t\tcReflection = GetSkyGradient(reflect(ray.vDir, vNormal));                               \n\t\t#endif\n\t\t// apply lighting\n\t\tcScene = GetObjectLighting(ray, intersection, material, vNormal, cReflection );\n\t}\n       \n\tApplyAtmosphere(cScene, ray, intersection);\n       \n\treturn cScene;\n}\n\nvoid GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, out C_Ray ray)\n{\n\tvec2 vPixelCoord = gl_FragCoord.xy;\n\t#ifdef ENABLE_MONTE_CARLO\n\tvPixelCoord += gPixelRandom.zw;\n\t#endif\n\tvec2 vUV = ( vPixelCoord / iResolution.xy );\n\tvec2 vViewCoord = vUV * 2.0 - 1.0;\n\n\tvViewCoord *= 0.75;\n       \n\tfloat fRatio = iResolution.x / iResolution.y;\n\n\tvViewCoord.y /= fRatio;                           \n\n\tray.vOrigin = vPos;\n\n\tvec3 vRight = normalize(cross(vForwards, vWorldUp));\n\tvec3 vUp = cross(vRight, vForwards);\n\t    \n\tray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards);        \n}\n\nvoid GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, out C_Ray ray)\n{\n\tvec3 vForwards = normalize(vInterest - vPos);\n\tvec3 vUp = vec3(0.0, 1.0, 0.0);\n\n\tGetCameraRay(vPos, vForwards, vUp, ray);\n}\n\nvec3 OrbitPoint( const in float fHeading, const in float fElevation )\n{\n\treturn vec3(sin(fHeading) * cos(fElevation), sin(fElevation), cos(fHeading) * cos(fElevation));\n}\n\nvec3 Gamma( const in vec3 cCol )\n{\n\treturn cCol * cCol;\n}\n\nvec3 InvGamma( const in vec3 cCol )\n{\n\treturn sqrt(cCol);\n}\n\n\nvec3 Tonemap( const in vec3 cCol )\n{\n\t// simple Reinhard tonemapping operator     \n\tvec3 vResult = cCol / (1.0 + cCol);\n\n\treturn Gamma(vResult);\n}\n\nvec3 InvTonemap( const in vec3 cCol )\n{\n\tvec3 vResult = cCol;\n\tvResult = clamp(vResult, 0.01, 0.99);\n\tvResult = InvGamma(vResult);\n\treturn - (vResult / (vResult - 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n kPI = acos(0.0);\n kHalfPi = asin(1.0);\n kTwoPI = kPI * 2.0;\n\n    \n    \n    #ifdef ENABLE_MONTE_CARLO             \n\tCalcPixelRandom();\n\t#endif\n       \n\tC_Ray ray;\n       \n\tconst float fCamreaInitialHeading = 2.5;\n\tconst float fCamreaInitialElevation = 0.4;\n\tconst float fCamreaInitialDist = 7.0;\n\tconst float fCameraHeight = 0.9;\n\tconst float fOrbitSpeed = 1.0;\n\t\n\t// This magic stolen from other 3d pan/zoom examples\n\tfloat fZoom = surfaceSize.y * 0.5 + 0.4;\n\t\n\tvec2 vCenterPosition = (0.5 - ( fragCoord.xy / iResolution.xy )) * surfaceSize + surfacePosition;\n\tfloat fHeading = vCenterPosition.x * fOrbitSpeed + fCamreaInitialHeading;\n\tfloat fElevation = (vCenterPosition.y * fOrbitSpeed + fCamreaInitialElevation);\n\t\n\tvec3 vCameraPos = OrbitPoint(fHeading, fElevation) * fCamreaInitialDist * fZoom;\n\t\n\t//vCameraPos += vec3(iMouse.x*5., iMouse.y*5., 0.0);\n    vCameraPos += vec3(0.5*5.+3.0*cos(iTime), 1.0*5.0+4.0*sin(iTime), 0.0);\n\t\n\tvCameraPos += vec3(0.0, -fCameraHeight, 0.0);\n\t#ifdef ENABLE_MONTE_CARLO             \n\tfloat fDepthOfField = 0.025;\n\tvCameraPos += gRandomNormal * fDepthOfField;\n\t#endif\n       \n\tGetCameraRayLookat( vCameraPos, vec3(0.0, 0.0, 0.0), ray);\n\t//GetCameraRayLookat(vec3(0.0, 0.0, -5.0), vec3(0.0, 0.0, 0.0), ray);\n       \n\tvec3 cScene = GetSceneColour( ray );   \n       \n\tfloat fExposure = 2.5;\n\tcScene = cScene * fExposure;\n       \n\t#ifdef ENABLE_MONTE_CARLO                              \n\tvec3 cPrev = texture2D(backbuffer, gl_FragCoord.xy / resolution).xyz;\n\t// add noise to pixel value (helps values converge)\n\tcPrev += (gPixelRandom.xyz - 0.5) * (1.0 / 255.0);\n\tcPrev = InvTonemap(cPrev);\n\t// converge speed\n\tfloat fBlend = 0.1;\n\tvec3 cFinal = mix(cPrev, cScene, fBlend);\n\t#else\n\tvec3 cFinal = cScene;\n\t#endif\n\t\n\tcFinal = Tonemap(cFinal);\n       \t\n\tfloat fAlpha = 1.0;\n       \n\tfragColor = vec4( cFinal, fAlpha );\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljfDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[296, 1169, 1228, 1228, 1381], [1384, 1384, 1443, 1443, 1596], [1603, 1603, 1662, 1662, 1815], [1818, 1818, 1879, 1925, 1966], [1969, 1969, 2034, 2034, 2074], [2077, 2077, 2141, 2141, 2198], [2201, 2201, 2290, 2290, 2459], [2462, 2462, 2528, 2528, 2662], [2665, 2665, 2729, 2729, 2828], [2831, 2831, 2903, 2903, 3221], [3224, 3224, 3307, 3307, 3368], [3369, 3369, 3452, 3452, 3513], [3514, 3514, 3580, 3580, 3611], [3612, 3612, 3677, 3677, 3759], [3762, 3762, 3849, 3849, 3942], [3945, 4060, 4105, 4105, 4518], [4520, 4520, 4594, 4594, 4882], [4883, 4883, 4926, 4926, 5027], [5028, 5028, 5048, 5048, 5186], [5187, 5187, 5207, 5207, 5246], [5249, 5249, 5294, 5294, 5329], [5358, 5358, 5449, 5449, 6061], [6062, 6062, 6105, 6128, 6670], [6766, 6889, 6989, 6989, 7759], [7761, 7761, 7856, 7856, 8157], [8159, 8215, 8325, 8325, 8521], [8523, 8523, 8598, 8598, 8643], [8645, 8645, 8768, 8768, 9034], [9036, 9088, 9191, 9191, 9552], [9555, 9555, 9712, 9712, 11174], [11176, 11176, 11225, 11225, 11822], [11824, 11824, 11867, 11867, 13080], [13082, 13082, 13186, 13186, 13714], [13716, 13716, 13802, 13802, 13927], [13929, 13929, 14000, 14000, 14099], [14101, 14101, 14135, 14135, 14158], [14160, 14160, 14197, 14197, 14219], [14222, 14222, 14258, 14304, 14368], [14370, 14370, 14409, 14409, 14541], [14543, 14543, 14600, 14600, 16454]]}
{"id": "3ljfWD", "name": " - Quicky#044", "author": "totetmatt", "description": "Colorful and roundish quicky.", "tags": ["quicky"], "likes": 6, "viewed": 204, "published": "Public API", "date": "1598971666", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nCode Under Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) Licence\nhttps://creativecommons.org/licenses/by-sa/4.0/legalcode\n**/\n#define PI 3.141592\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 p(float t){\nreturn palette( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\nmat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,s,-s,c);\n}\nvec3 fig(vec2 uv){\nvec3 d  =vec3(0.);\n    float n = 10.;+cos(iTime*2.)*10.;\n    for(float i=0.;i<=n;i++){\n        uv*=r(iTime*.2+PI/n);\n     float l = length(uv)-.07*i;\n\n    float q = step(cos(iTime+i)*.25+.75,(atan(uv.y,uv.x)+PI)/(2.*PI));\n    l = abs(l)-.001;\n    d+= vec3(p(i/n+fract(iTime*.75))*smoothstep(.02,.015,l)*q);\n    }\n    return d ;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy-.5* iResolution.xy)/iResolution.y;\n    uv*=2.;\n    if(mod(iTime,15.)<10.){\n    uv = abs(uv)-.75;\n    uv*=r(PI/4.);\n    if(mod(iTime,15.)<5.){\n    \n    uv = abs(uv)-.125;\n   }\n   }\n    vec3 d = fig(uv);\n    \n    vec3 col = vec3(d);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljfWD.jpg", "access": "shaders20k", "license": "cc-by-4.0", "functions": [[0, 159, 231, 231, 274], [275, 275, 291, 291, 389], [390, 390, 406, 406, 464], [465, 465, 483, 483, 813], [814, 814, 869, 869, 1171]]}
{"id": "3lSBRm", "name": "Twister test #1 meh", "author": "dub", "description": "Twister test #1 meh", "tags": ["twister"], "likes": 4, "viewed": 70, "published": "Public", "date": "1599585935", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define PQ 3.14159265359*0.5\n\nconst vec3[] colors = vec3[](\n\tvec3(1.0, 0.0, 0.0),\n\tvec3(0.0, 1.0, 0.0),\n\tvec3(0.0, 0.0, 1.0),\n\tvec3(1.0, 1.0, 0.0)\n);\n\nconst vec2 light = vec2(3.0, 2.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord*2.0/iResolution.y - vec2(iResolution.x/iResolution.y, 1.0);\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    \n    float p = iTime*sin(-iTime*0.5+uv.y)*0.1+uv.y*0.5+0.2+iTime*0.5;\n    \n    vec2 s = vec2(sin(p), cos(p));\n    for (int i=0;i<4;i++)\n    {\n    \tint j=(i+1)%4;\n        p+=PQ;\n    \tvec2 e = vec2(sin(p), cos(p));\n        \n        if(!(s.y<0.&&e.y<0.)&&uv.x>s.x&&uv.x<e.x)\n        {\n            // vec2 n = normalize(s+e);\n            float p = dot(normalize(s+e),normalize(light));\n            col = mix(colors[i],vec3(1.),p*0.7);\n            break;\n        }\n        s = e;\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSBRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[212, 212, 269, 269, 959]]}
{"id": "3lSBRV", "name": "Spinning Box", "author": "mharitsnf", "description": "Spinning and alternating boxes", "tags": ["pattern", "pastel"], "likes": 3, "viewed": 56, "published": "Public", "date": "1599293761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvec2 tile(vec2 _st, float _zoom){\n    _st *= _zoom;\n    return fract(_st);\n}\n\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_st);\n    uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nvec3 col255to1(vec3 col) {\n    return col / 255.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // st or uv, both are the same\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    \n    vec3 jet = col255to1(vec3(51., 53., 51.));\n    vec3 timberwolf = col255to1(vec3(207., 219., 213.));\n    \n    st *= 5.;\n    float isOdd = step(1., mod(st.y, 2.));\n    st.x += isOdd * 0.5 * iTime;\n    st.x -= (1.-isOdd) * 0.5 * iTime;\n    st = fract(st);\n    vec2 st1 = st;\n    \n    st = rotate2D(st, PI * .25);\n    float box1 = box(st, vec2(.5), 0.001);\n    float box2 = box(st, vec2(.4), 0.001);\n    float finBox = 1. - (box1 - box2);\n    \n    st1 = rotate2D(st1, ((isOdd * 2. - 1.)) * iTime * 2.);\n    float cross = 1. - (box(st1, vec2(.2, 1.), .001) + box(st1, vec2(1., .2), .001));\n    \n    float final = finBox + cross;\n    \n    vec3 color = vec3(final);\n    color = step(1., length(color)) * timberwolf + (1. - step(1., length(color))) * jet;\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSBRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 73, 73, 213], [215, 215, 248, 248, 291], [293, 293, 345, 345, 538], [540, 540, 566, 566, 591], [593, 593, 650, 685, 1562]]}
{"id": "3lSBRy", "name": "Minimalism #11", "author": "Flopine", "description": "Eleventh piece of a shader serie about minimalism, how to do small and quick artwork that are about composition and animation.", "tags": ["2d", "animation", "face", "minimalism", "daily"], "likes": 9, "viewed": 107, "published": "Public", "date": "1599165037", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU 6.2831853\n\n#define time(speed) fract(iTime*speed)\n#define AnimInOutExpoLoop(speed) easeInOutExpo(abs(-1.+2.*time(speed)))\n\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(0.07,fwidth(val-thre)))\n#define circle(puv,s) (length(puv)-s)\n#define square(puv,s) (max(abs(puv.x),abs(puv.y))-s)\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define xor(a,b) ((1.-b)*a+(1.-a)*b)\n\nfloat easeInOutExpo(float x) \n{\n    return x == 0.\n        ? 0.\n        : x == 1.\n            ? 1.\n            : x < 0.5 ? pow(2., 20. * x - 10.) / 2.\n                : (2. - pow(2., -20. * x + 10.)) / 2.;\n}\n\nfloat frame (vec2 uv)\n{\n    uv.y += 0.25;\n    float thick = 0.005;\n    vec2 offsets[10] = vec2[]\n        (\n            vec2(0.,0.), // nose \n            vec2(-0.13,-0.05), // nose sides\n            vec2(-0.34, -0.5), // eyes\n            vec2(-0.05, 0.25), // upper lip\n            vec2(0.,0.37), // bottom lip\n            vec2(0.,0.62), // chin \n            vec2(-0.45,0.12), // chicks\n            vec2(0.,-0.95), // forehead\n            vec2(0., 0.10), // jaw\n            vec2(-0.6,-0.65) // temple\n        );\n    \n    float anim = AnimInOutExpoLoop(0.2);\n    \n    // nose\n \tfloat mask = AAstep(thick*1.8,abs(circle(uv+offsets[0]*anim,0.1)));\n    // bottom lip\n    mask *= AAstep(thick*2.2,abs(circle(uv+offsets[4]*anim,0.08)));\n    // chin\n    mask *= AAstep(thick*2.,abs(circle(uv+offsets[5]*anim,0.15)));\n    // forehead\n    mask *= AAstep(thick*1.5,abs(circle(uv+offsets[7]*anim,.4)));\n    // jaw\n    mask *= AAstep(thick,abs(circle(uv+offsets[8]*anim,0.5)));\n    \n    \n    uv.x = abs(uv.x);\n    // nose sides\n    mask *= AAstep(thick,abs(circle(uv+offsets[1]*anim,0.06)));\n    // eyes\n    mask *= AAstep(thick*1.5,abs(circle(uv+offsets[2]*anim,0.15)));\n    mask *= AAstep(thick*0.7,abs(circle(uv+offsets[2]*anim,0.06)));\n    // upper lip\n    mask *= AAstep(thick*1.8,abs(circle(uv+offsets[3]*anim,0.05)));\n    // chicks\n    mask *= AAstep(thick*1.5,abs(circle(uv+offsets[6]*anim,0.3)));\n    // temple\n    mask *= AAstep(thick,abs(circle(uv+offsets[9]*anim,0.42)));\n   \n    uv *= rot(PI/4.);\n    mask = xor(mask,AAstep(0.01,square(uv,0.6)));\n    \n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(frame(uv*1.2));\n    col = xor(col,vec3(0.,0.1,0.1));\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSBRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 737, 768, 768, 944], [946, 946, 969, 969, 2516], [2518, 2518, 2575, 2575, 2747]]}
{"id": "3lSBzt", "name": "community guidelines", "author": "zproxy", "description": "yet another text animation.\n\nis shadertoy broken recently?\n\nYou need to write at least 1 character\n\n", "tags": ["2d", "text"], "likes": 7, "viewed": 193, "published": "Public", "date": "1599566977", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.shadertoy.com/view/XdXGRB\n\n// Source edited by David Hoskins - 2013.\n\n// I took and completed this http://glsl.heroku.com/e#9743.20 - just for fun! 8|\n// Locations in 3x7 font grid, inspired by http://www.claudiocc.com/the-1k-notebook-part-i/\n// Had to edit it to remove some duplicate lines.\n// ABC  a:GIOMJL b:AMOIG c:IGMO d:COMGI e:OMGILJ f:CBN g:OMGIUS h:AMGIO i:EEHN j:GHTS k:AMIKO l:BN m:MGHNHIO n:MGIO\n// DEF  o:GIOMG p:SGIOM q:UIGMO r:MGI s:IGJLOM t:BNO u:GMOI v:GJNLI w:GMNHNOI x:GOKMI y:GMOIUS z:GIMO\n// GHI\n// JKL \n// MNO\n// PQR\n// STU\n\nvec2 coord;\n\n#define font_size 20. \n#define font_spacing .05\n#define STROKEWIDTH 0.05\n#define PI 3.14159265359\n\n#define A_ vec2(0.,0.)\n#define B_ vec2(1.,0.)\n#define C_ vec2(2.,0.)\n\n//#define D_ vec2(0.,1.)\n#define E_ vec2(1.,1.)\n//#define F_ vec2(2.,1.)\n\n#define G_ vec2(0.,2.)\n#define H_ vec2(1.,2.)\n#define I_ vec2(2.,2.)\n\n#define J_ vec2(0.,3.)\n#define K_ vec2(1.,3.)\n#define L_ vec2(2.,3.)\n\n#define M_ vec2(0.,4.)\n#define N_ vec2(1.,4.)\n#define O_ vec2(2.,4.)\n\n//#define P_ vec2(0.,5.)\n//#define Q_ vec2(1.,5.)\n//#define R_ vec2(1.,5.)\n\n#define S_ vec2(0.,6.)\n#define T_ vec2(1.,6.)\n#define U_ vec2(2.0,6.)\n\n#define A(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,J_,p) + t(J_,L_,p)\n#define B(p) t(A_,M_,p) + t(M_,O_,p) + t(O_,I_, p) + t(I_,G_,p)\n#define C(p) t(I_,G_,p) + t(G_,M_,p) + t(M_,O_,p) \n#define D(p) t(C_,O_,p) + t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p)\n#define E(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,L_,p) + t(L_,J_,p)\n#define F(p) t(C_,B_,p) + t(B_,N_,p) + t(G_,I_,p)\n#define G(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define H(p) t(A_,M_,p) + t(G_,I_,p) + t(I_,O_,p) \n#define I(p) t(E_,E_,p) + t(H_,N_,p) \n#define J(p) t(E_,E_,p) + t(H_,T_,p) + t(T_,S_,p)\n#define K(p) t(A_,M_,p) + t(M_,I_,p) + t(K_,O_,p)\n#define L(p) t(B_,N_,p)\n#define M(p) t(M_,G_,p) + t(G_,I_,p) + t(H_,N_,p) + t(I_,O_,p)\n#define N(p) t(M_,G_,p) + t(G_,I_,p) + t(I_,O_,p)\n#define O(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,G_,p)\n#define P(p) t(S_,G_,p) + t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p)\n#define Q(p) t(U_,I_,p) + t(I_,G_,p) + t(G_,M_,p) + t(M_,O_, p)\n#define R(p) t(M_,G_,p) + t(G_,I_,p)\n#define S(p) t(I_,G_,p) + t(G_,J_,p) + t(J_,L_,p) + t(L_,O_,p) + t(O_,M_,p)\n#define T(p) t(B_,N_,p) + t(N_,O_,p) + t(G_,I_,p)\n#define U(p) t(G_,M_,p) + t(M_,O_,p) + t(O_,I_,p)\n#define V(p) t(G_,J_,p) + t(J_,N_,p) + t(N_,L_,p) + t(L_,I_,p)\n#define W(p) t(G_,M_,p) + t(M_,O_,p) + t(N_,H_,p) + t(O_,I_,p)\n#define X(p) t(G_,O_,p) + t(I_,M_,p)\n#define Y(p) t(G_,M_,p) + t(M_,O_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define Z(p) t(G_,I_,p) + t(I_,M_,p) + t(M_,O_,p)\n#define STOP(p) t(N_,N_,p)\n\t\nvec2 caret_origin = vec2(3.0, .9);\nvec2 caret;\n\n//-----------------------------------------------------------------------------------\nfloat minimum_distance(vec2 v, vec2 w, vec2 p)\n{\t// Return minimum distance between line segment vw and point p\n  \tfloat l2 = (v.x - w.x)*(v.x - w.x) + (v.y - w.y)*(v.y - w.y); //length_squared(v, w);  // i.e. |w-v|^2 -  avoid a sqrt\n  \tif (l2 == 0.0) {\n\t\treturn distance(p, v);   // v == w case\n\t}\n\t\n\t// Consider the line extending the segment, parameterized as v + t (w - v).\n  \t// We find projection of point p onto the line.  It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  \tfloat t = dot(p - v, w - v) / l2;\n  \tif(t < 0.0) {\n\t\t// Beyond the 'v' end of the segment\n\t\treturn distance(p, v);\n\t} else if (t > 1.0) {\n\t\treturn distance(p, w);  // Beyond the 'w' end of the segment\n\t}\n  \tvec2 projection = v + t * (w - v);  // Projection falls on the segment\n\treturn distance(p, projection);\n}\n\n//-----------------------------------------------------------------------------------\nfloat textColor(vec2 from, vec2 to, vec2 p)\n{\n\tp *= font_size;\n\tfloat inkNess = 0., nearLine, corner;\n\tnearLine = minimum_distance(from,to,p); // basic distance from segment, thanks http://glsl.heroku.com/e#6140.0\n\tinkNess += smoothstep(0., 1., 1.- 14.*(nearLine - STROKEWIDTH)); // ugly still\n\tinkNess += smoothstep(0., 2.5, 1.- (nearLine  + 5. * STROKEWIDTH)); // glow\n\treturn inkNess;\n}\n\n//-----------------------------------------------------------------------------------\nvec2 grid(vec2 letterspace) \n{\n\treturn ( vec2( (letterspace.x / 2.) * .65 , 1.0-((letterspace.y / 2.) * .95) ));\n}\n\n//-----------------------------------------------------------------------------------\nfloat count = 0.0;\nfloat gtime;\nfloat t(vec2 from, vec2 to, vec2 p) \n{\n\tcount++;\n\tif (count > gtime*20.0) return 0.0;\n\treturn textColor(grid(from), grid(to), p);\n}\n\n//-----------------------------------------------------------------------------------\nvec2 r()\n{\n\tvec2 pos = coord.xy/iResolution.xy;\n\tpos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n\treturn pos;\n}\n\n//-----------------------------------------------------------------------------------\nvoid add()\n{\n\tcaret.x += 1.0;\n}\n\n//-----------------------------------------------------------------------------------\nvoid space()\n{\n\tcaret.x += 1.5;\n}\n\n//-----------------------------------------------------------------------------------\nvoid newline()\n{\n\tcaret.x = caret_origin.x;\n\tcaret.y -= .18;\n}\n\n//-----------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 0.8;\n    float time33 = mod(speed * iTime, 11.0 * 5.0);\n\n    //float time33 = mod(0.5 * iTime, 11.0 * 2.0);\n\n    float time = mod(speed * iTime, 11.0);\n    gtime = time;\n\n\tfloat d = 0.;\n\tvec3 col = 0.5*vec3(0.1, .07+0.07*(.5+sin(fragCoord.y*3.14159*1.1+time*2.0)) + sin(fragCoord.y*.01+time+2.5)*0.05, 0.1);\n    \n    coord = fragCoord;\n\t\n\tcaret = caret_origin;\n\n\t// the quick brown fox jumps over the lazy dog...\n    \n    #define w(Z) d += Z(r()); add(); \n    #define dot STOP\n    #define wCOM w(C)w(O)w(M)\n    #define dotCOM w(STOP)w(C)w(O)w(M)\n    \n    \n        newline();\n    \n        newline();\n    \n    \n// yet another text animation.\n// is shadertoy broken recently?\n// You need to write at least 1 character\n    //https://www.shadertoy.com/view/Xtcczl\n\n         if (time33 > 17.0)\n    {\n   \t\tw(C)w(O)w(M)w(M)w(U)w(N)w(I)w(T)w(Y)\n    }\n    else\n\n     if (time33 <= 6.0)\n    {\n   \t\tw(C)w(O)w(M)w(M)w(U)w(N)w(I)w(T)w(Y)\n    }\n    else\n    {\n           \t\tw(C)w(O)w(M)w(M)w(U)w(N)w(I)w(S)w(T)\n\n\n                    \n            \n        \n    }\n    \n     \n    \n    \n        newline();\n    \n   \t\t  \t\tw(G)w(U)w(I)w(D)w(E)w(L)w(I)w(N)w(E)w(S)\n \n                    \n\td = clamp(d* (.75+sin(fragCoord.x*PI*.5-time*4.3)*.5), 0.0, 1.0);\n      \n    col += vec3(d*.5, d, d*.85);\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n\tcol *= vec3(.4, .4, .3) + 0.5*pow(100.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), .4 );\t\n    fragColor = vec4( 2.0*col.r, 0,0, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSBzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2717, 2803, 2851, 2914, 3593], [3595, 3681, 3726, 3726, 4070], [4072, 4158, 4188, 4188, 4272], [4274, 4392, 4430, 4430, 4523], [4525, 4611, 4621, 4621, 4724], [4726, 4812, 4824, 4824, 4843], [4845, 4931, 4945, 4945, 4964], [4966, 5052, 5068, 5068, 5114], [5116, 5202, 5259, 5259, 6718]]}
{"id": "3lSfWy", "name": "metaball 3d - stacked layers", "author": "enz0", "description": "Stratified metaballs.  Using transparency to allow composing the layers without additive.", "tags": ["metaball", "layers", "strata"], "likes": 4, "viewed": 77, "published": "Public", "date": "1599697290", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Advancing prev collab with g1nt to simulate the metaballs \n// in 3d instead of 2d and rendered with a stratified / glass-plate look.\n\n\n\nbool shouldDimWithDistance = true;\n\n// Palette: https://colorhunt.co/palette/66990\nconst vec4 color1 = vec4(255, 126, 103, 255.) / 255.0;\nconst vec4 color2 = vec4(250, 250, 250, 255) / 255.0;\nconst vec4 color3 = vec4(162, 213, 242, 255) / 255.0;\nconst vec4 color4Bg = vec4(0.1, 0.1, 0.1, 0.);  //vec4(7, 104, 159, 0) / 255.0;\n\n//Make a smooth band like this: ___/---\\____\n// ...along the \"val\" axis\n// ...centred around bandCentre, of main width bandWidth, with rampWidth for the smoothStepped side length.\nfloat smoothBand(float bandCentre, float bandWidth, float rampWidth, float val){\n    float halfW = bandWidth/2.;\n    return 1.- smoothstep(halfW, halfW + rampWidth, abs(val - bandCentre));\n}\n\n\nvec4 genLayerAtZ(vec2 uv, float plateZ, vec2 mouseAdjusted){\n    // By also supplying an alpha in this vec4, we'll allow \n    // the compositing function to compose with transparency\n\n    // Assume a space -0.5, 0.5 on x, y, and z.\n    vec3 uv3d = vec3(uv, plateZ);\n\n    \n    // Centres of blobs which oscillate in 3d space over time \n    // (and one tracks the mouse)\n    vec3 centre1 = vec3(sin(iTime / 3.0) * 0.5,   -0.3,                     cos(0.0 + iTime/3.) * 0.5);\n    vec3 centre2 = vec3(sin(iTime / 5.7) * 0.4,   -cos(iTime/5.7) * 0.4,    sin(0.5 + iTime/11.1) * 0.5);\n    vec3 centre3 = vec3(0.6,                      cos(iTime / 8.0) * 0.35,  cos(2.0 + iTime/7.) * 0.5);\n    vec3 centre4 = vec3(sin(iTime / 1.5) * 0.4,   cos(iTime / 1.1) * 0.2,   sin(1.0 + iTime/5.) * 0.5);    \n    vec3 centre5 = mouseAdjusted.xyx;\n    \n    float total = 0.0;\n    total += 1.3 / length(uv3d - centre1);\n    total += 2.0 / length(uv3d - centre2);\n    total += 1.0 / length(uv3d - centre3);\n    total += 0.8 / length(uv3d - centre4);\n    total += 1.6 / length(uv3d - centre5);   \t\n    total = total / 20.;\n    \n    float bgAlpha = shouldDimWithDistance ? 0.05 : 0.;\n    vec4 col = vec4(color4Bg.rgb, bgAlpha);\n        \n    col = mix(col, color1, smoothBand(0.75, 0.05, 0.01, total));\n    col = mix(col, color2, smoothBand(0.85, 0.05, 0.01, total));\n    col = mix(col, color3, smoothBand(0.95, 0.02, 0.02, total));    \n\treturn col;\n}\n\n// Doesn't a map function exist already??\nfloat map(float val, float inMin, float inMax, float outMin, float outMax){\n    return outMax * (val - inMin)/(inMax - inMin) + outMin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    // (0., 0.) in centre of window\n    // y axis is from -0.5 to 0.5\n    // but x axis is from -aspect/2 to aspect/2\n    // (We'll also consider an apparent z axis from -0.5, to 0.5.)\n    float aspect = iResolution.x / iResolution.y;\n    vec2 centreAdjust = vec2(-aspect/2., -0.5);  \n    vec2 uv = fragCoord / iResolution.y + centreAdjust;\n    \n\tvec2 mouseAdjusted = iMouse.xy / iResolution.y + centreAdjust;\n     \n    int numLayers =10;\n    //Simulating viewing angle, each layer is displaced some\n    vec2 offsetPerLayer = vec2(0., .6 / float(numLayers));\n    \n    //initial (background) colour\n    vec4 col = vec4(color4Bg.rgb,1.);\n\t\n    for(int i =0; i < numLayers; i++){\n    \n        vec2 adjustedUV = uv + offsetPerLayer * float(numLayers - i) + vec2(0., -0.2);\n\t\t\n        //Spread the numLayers layers over what z space?\n        float layerZ = map(float(i), 0., float(numLayers), -0.5, 0.5);\n        \n        // generate the 2d metaball image for this layer\n        vec4 colFromLayer = genLayerAtZ(adjustedUV, layerZ, mouseAdjusted);    \n    \t//... and overlay its colour onto our composition, assuming it's not a transparent pixel.\n        // The \"transparent\" pixels are not given to us fully transparent\n        // but carry a \"thin film\" of background colour \n        // in order to make first-drawn layers dim into the distance due to build up of this \"film\"\n        col = mix(col, colFromLayer, (colFromLayer.a));\n\t\t//Try using an inverted alpha for an inner blueprints look\n        //col = mix(col, colFromLayer, (1.-colFromLayer.a));\n    }\n    // Output to screen\n    fragColor = vec4(col.xyz, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSfWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[465, 645, 725, 725, 835], [838, 838, 898, 1069, 2265], [2267, 2309, 2384, 2384, 2446], [2448, 2448, 2505, 2726, 4159]]}
{"id": "3s3cWn", "name": "Delta Poetry", "author": "BradyInstead", "description": "info in shader", "tags": ["raymarch", "triangle", "reflections", "delta"], "likes": 3, "viewed": 249, "published": "Public API", "date": "1600723467", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////\n//\t\t\tDELTA POETRY\t\t\t//\n//////////////////////////////////////\n\n//\tDelta = Change\n\n//\tThanks to iq for the raymarching inspiration\n//\tThanks to Connor Bell for the AA technique\n\n\n//////////////////////////////////////\n//\t\t\tVARIABLES\t\t\t\t//\n//////////////////////////////////////\n\n#define AA 2\n\n#define MAX_MARCH 12.\n#define MAX_MARCH_REFLECT 5.\n\n#define REFLECT_POWER 1.5\n#define NUM_REFLECTIONS 2\n\n\n//////////////////////////////////////\n//\t\t\t\tCODE\t\t\t\t//\n//////////////////////////////////////\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n\nvec2 delta(vec3 p)\n{   \n    //float sphere = length(p) - .5;\n    float tri = sdTriPrism(p, vec2(1., .1));\n    float stri = sdTriPrism(p, vec2(.4, .1));\n    tri = opSmoothSubtraction(stri, tri, .5);\n    \n    return vec2(tri, 1.);\n}\n  \nvec2 plane( vec3 p)\n{\n\treturn vec2(abs(p.y), 2.);\n}\n\nvec2 model(vec3 p)\n{   \n    vec2 sp = delta(p + vec3(0., -.2 + sin(iTime*3.)*.1, 0.));\n    vec2 pl = plane(p + vec3(0, .5, 0.));\n    \n    vec2 mod = vec2(0.);\n    if(sp.x < pl.x)\n        mod = sp;\n    else\n    \tmod = pl;\n    \n    return mod;\n    //return sp;\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd, float maxdist, float modifier)\n{\n    float dist = 0.;\n    for(int i = 0; i < 90; i++)\n    {\n\t\tfloat m = model(ro+rd*dist).x*modifier;\n        dist += m;\n        \n        if(m < .01) return dist;\n        else if(dist > maxdist) break;\n    }\n    return -1.;\n}\n\nvec3 normal(vec3 pos)\n{\n    vec3 eps = vec3(.01, -.01, 0.);\n    \n    return normalize(vec3(\n        model(pos + eps.xzz).x - model(pos + eps.yzz).x,\n        model(pos + eps.zxz).x - model(pos + eps.zyz).x,\n        model(pos + eps.zzx).x - model(pos + eps.zzy).x));\n}\n\n\nvec3 background()\n{\n    return vec3(0.);\n}\n\nvec3 getColor(vec3 pos)\n{\n    float m = model(pos).y;\n    vec3 color = vec3(0.);\n    \n    if(m == 1.) // delta\n        return vec3(1., .65, 0.2);\n    if(m == 2.)\n        return vec3(1., 1., 1.);\n    \n    return background();\n}\n\nvec3 shade(vec3 pos, vec3 nor, vec3 rd, float dist)\n{\n    if(dist < 0.) return background();\n    \n    vec3 lp = vec3(2., 2., 2.);\n    vec3 ld = normalize((lp-pos)*rd);\n    \n    float dif = max(dot(nor,ld),.45);\n    vec3 lin = vec3(dif);\n    \n    vec3 col = lin;\n    col *= exp(-.01*dist*dist);\n    \n    col = pow(col, vec3(1.8));\n    \n    col *= getColor(pos);\n    \n    return col;\n}\n\nvec3 reflection(vec3 pos, vec3 rd, vec3 nor, float dist)\n{\n    if(dist < -.1) return background();\n    \n    vec3 rrd = reflect(rd, nor);\n    vec3 rro = pos + rrd*.02;\n    \n    vec3 col = vec3(0.);\n    vec3 fade = vec3(1.);\n    \n    for(int i = 0; i < NUM_REFLECTIONS; i++)\n    {\n    \tfloat rdist = raymarch(rro, rrd, MAX_MARCH_REFLECT, 1.);\n    \n    \tvec3 rpos = rro + rrd*rdist;\n    \tvec3 rnor = normal(rpos);\n    \n    \tfade -= pow(1. - rdist/MAX_MARCH_REFLECT, .5) *.4; //* vec3(.5, .9, .1);\n        \n        rrd = reflect(rrd, rnor);\n    \trro = rpos + rrd*.02;\n        \n        col += shade(rpos, rnor, rrd, rdist) * fade;\n    }\n    \n    return col;\n}\n\nvec3 render(vec2 p)\n{   \n    vec3 ro = vec3(4. * cos(iTime*.5), 1., 4. * sin(iTime*.5)); \n    vec3 ta = vec3(0.0, .25, 0.0);\t\t\t\t\n    \n    vec3 w = normalize (ta-ro);\n    vec3 u = normalize (cross (w, vec3(0., 1., 0.)));\n    vec3 v = normalize (cross (u, w));\n    mat3 mat = mat3(u, v, w);\n    vec3 rd = normalize (mat*vec3(p.xy,1.5));\n    \n    float dist = raymarch(ro, rd, MAX_MARCH, 1.);\n    vec3 pos = ro+rd*dist;\n    vec3 nor = normal(pos);\n    \n    vec3 col = shade(pos, nor, rd, dist);\n    vec3 ref = reflection(pos, rd, nor, dist);\n    \n    col += ref*REFLECT_POWER;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    vec3 color = vec3(0.);\n    for (int j = 0; j < AA; j++) {\n        for (int k = 0; k < AA; k++)\n        {\n            vec2 o = vec2(float(j), float(k)) / float(AA);\n            vec2 uv = (p + o / iResolution.xy);\n            color += render(uv);\n        }\n    }\n\n    color /= float(AA * AA);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3cWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[437, 533, 569, 569, 652], [655, 655, 713, 713, 813], [816, 816, 836, 876, 1046], [1050, 1050, 1071, 1071, 1101], [1103, 1103, 1123, 1123, 1363], [1365, 1365, 1436, 1436, 1661], [1663, 1663, 1686, 1686, 1929], [1932, 1932, 1951, 1951, 1974], [1976, 1976, 2001, 2001, 2202], [2204, 2204, 2257, 2257, 2587], [2589, 2589, 2647, 2647, 3243], [3245, 3245, 3266, 3266, 3841], [3843, 3843, 3900, 3900, 4324]]}
{"id": "3s3czX", "name": "Material Maker: Blob Transition", "author": "RodzLabs", "description": "Based on @NaturallyCG Substance Designer Beginner Quick Tip 63 (VFX Blob Transition)\n\nGenerated with Material Maker (source: https://pastebin.com/raw/dxJ40rbd)", "tags": ["2d", "generated"], "likes": 3, "viewed": 89, "published": "Public", "date": "1601351667", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//---\n\nfloat rand(vec2 x) {\n    return fract(cos(dot(x, vec2(13.9898, 8.141))) * 43758.5453);\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t  dot(x, vec2(3.4562, 17.398)))) * 43758.5453);\n}\n\nvec3 rand3(vec2 x) {\n    return fract(cos(vec3(dot(x, vec2(13.9898, 8.141)),\n                          dot(x, vec2(3.4562, 17.398)),\n                          dot(x, vec2(13.254, 5.867)))) * 43758.5453);\n}\n\nvec3 rgb2hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat shape_circle(vec2 uv, float sides, float size, float edge) {\n    uv = 2.0*uv-1.0;\n\tedge = max(edge, 1.0e-8);\n    float distance = length(uv);\n    return clamp((1.0-distance/size)/edge, 0.0, 1.0);\n}\n\nfloat shape_polygon(vec2 uv, float sides, float size, float edge) {\n    uv = 2.0*uv-1.0;\n\tedge = max(edge, 1.0e-8);\n    float angle = atan(uv.x, uv.y)+3.14159265359;\n    float slice = 6.28318530718/sides;\n    return clamp((size-cos(floor(0.5+angle/slice)*slice-angle)*length(uv))/(edge*size), 0.0, 1.0);\n}\n\nfloat shape_star(vec2 uv, float sides, float size, float edge) {\n    uv = 2.0*uv-1.0;\n\tedge = max(edge, 1.0e-8);\n    float angle = atan(uv.x, uv.y);\n    float slice = 6.28318530718/sides;\n    return clamp((size-cos(floor(1.5+angle/slice-2.0*step(0.5*slice, mod(angle, slice)))*slice-angle)*length(uv))/(edge*size), 0.0, 1.0);\n}\n\nfloat shape_curved_star(vec2 uv, float sides, float size, float edge) {\n    uv = 2.0*uv-1.0;\n\tedge = max(edge, 1.0e-8);\n    float angle = 2.0*(atan(uv.x, uv.y)+3.14159265359);\n    float slice = 6.28318530718/sides;\n    return clamp((size-cos(floor(0.5+0.5*angle/slice)*2.0*slice-angle)*length(uv))/(edge*size), 0.0, 1.0);\n}\n\nfloat shape_rays(vec2 uv, float sides, float size, float edge) {\n    uv = 2.0*uv-1.0;\n\tedge = 0.5*max(edge, 1.0e-8)*size;\n\tfloat slice = 6.28318530718/sides;\n    float angle = mod(atan(uv.x, uv.y)+3.14159265359, slice)/slice;\n    return clamp(min((size-angle)/edge, angle/edge), 0.0, 1.0);\n}\n\nconst float p_o111660_contrast = 1.000000000;\nconst float p_o19340_gradient_0_pos = 0.072727273;\nconst float p_o19340_gradient_0_r = 0.000000000;\nconst float p_o19340_gradient_0_g = 0.000000000;\nconst float p_o19340_gradient_0_b = 0.000000000;\nconst float p_o19340_gradient_0_a = 1.000000000;\nconst float p_o19340_gradient_1_pos = 0.145454545;\nconst float p_o19340_gradient_1_r = 1.000000000;\nconst float p_o19340_gradient_1_g = 1.000000000;\nconst float p_o19340_gradient_1_b = 1.000000000;\nconst float p_o19340_gradient_1_a = 1.000000000;\nconst float p_o19340_gradient_2_pos = 0.290909091;\nconst float p_o19340_gradient_2_r = 1.000000000;\nconst float p_o19340_gradient_2_g = 1.000000000;\nconst float p_o19340_gradient_2_b = 1.000000000;\nconst float p_o19340_gradient_2_a = 1.000000000;\nconst float p_o19340_gradient_3_pos = 0.363636364;\nconst float p_o19340_gradient_3_r = 0.000000000;\nconst float p_o19340_gradient_3_g = 0.000000000;\nconst float p_o19340_gradient_3_b = 0.000000000;\nconst float p_o19340_gradient_3_a = 1.000000000;\nconst float p_o19340_gradient_4_pos = 0.636691007;\nconst float p_o19340_gradient_4_r = 0.000000000;\nconst float p_o19340_gradient_4_g = 0.000000000;\nconst float p_o19340_gradient_4_b = 0.000000000;\nconst float p_o19340_gradient_4_a = 1.000000000;\nconst float p_o19340_gradient_5_pos = 0.709418279;\nconst float p_o19340_gradient_5_r = 1.000000000;\nconst float p_o19340_gradient_5_g = 1.000000000;\nconst float p_o19340_gradient_5_b = 1.000000000;\nconst float p_o19340_gradient_5_a = 1.000000000;\nvec4 o19340_gradient_gradient_fct(float x) {\n  if (x < p_o19340_gradient_0_pos) {\n    return vec4(p_o19340_gradient_0_r,p_o19340_gradient_0_g,p_o19340_gradient_0_b,p_o19340_gradient_0_a);\n  } else if (x < p_o19340_gradient_1_pos) {\n    return mix(vec4(p_o19340_gradient_0_r,p_o19340_gradient_0_g,p_o19340_gradient_0_b,p_o19340_gradient_0_a), vec4(p_o19340_gradient_1_r,p_o19340_gradient_1_g,p_o19340_gradient_1_b,p_o19340_gradient_1_a), ((x-p_o19340_gradient_0_pos)/(p_o19340_gradient_1_pos-p_o19340_gradient_0_pos)));\n  } else if (x < p_o19340_gradient_2_pos) {\n    return mix(vec4(p_o19340_gradient_1_r,p_o19340_gradient_1_g,p_o19340_gradient_1_b,p_o19340_gradient_1_a), vec4(p_o19340_gradient_2_r,p_o19340_gradient_2_g,p_o19340_gradient_2_b,p_o19340_gradient_2_a), ((x-p_o19340_gradient_1_pos)/(p_o19340_gradient_2_pos-p_o19340_gradient_1_pos)));\n  } else if (x < p_o19340_gradient_3_pos) {\n    return mix(vec4(p_o19340_gradient_2_r,p_o19340_gradient_2_g,p_o19340_gradient_2_b,p_o19340_gradient_2_a), vec4(p_o19340_gradient_3_r,p_o19340_gradient_3_g,p_o19340_gradient_3_b,p_o19340_gradient_3_a), ((x-p_o19340_gradient_2_pos)/(p_o19340_gradient_3_pos-p_o19340_gradient_2_pos)));\n  } else if (x < p_o19340_gradient_4_pos) {\n    return mix(vec4(p_o19340_gradient_3_r,p_o19340_gradient_3_g,p_o19340_gradient_3_b,p_o19340_gradient_3_a), vec4(p_o19340_gradient_4_r,p_o19340_gradient_4_g,p_o19340_gradient_4_b,p_o19340_gradient_4_a), ((x-p_o19340_gradient_3_pos)/(p_o19340_gradient_4_pos-p_o19340_gradient_3_pos)));\n  } else if (x < p_o19340_gradient_5_pos) {\n    return mix(vec4(p_o19340_gradient_4_r,p_o19340_gradient_4_g,p_o19340_gradient_4_b,p_o19340_gradient_4_a), vec4(p_o19340_gradient_5_r,p_o19340_gradient_5_g,p_o19340_gradient_5_b,p_o19340_gradient_5_a), ((x-p_o19340_gradient_4_pos)/(p_o19340_gradient_5_pos-p_o19340_gradient_4_pos)));\n  }\n  return vec4(p_o19340_gradient_5_r,p_o19340_gradient_5_g,p_o19340_gradient_5_b,p_o19340_gradient_5_a);\n}\nconst int seed_o128719 = 22594;\nconst float p_o128719_rotate = 0.000000000;\nconst float p_o128719_scale = 0.500000000;\nconst float p_o128719_value = 0.000000000;\nconst float p_o75374_sides = 6.000000000;\nconst float p_o75374_radius = 0.400000006;\nconst float p_o75374_edge = 1.000000000;\nfloat o128719_input_in(vec2 uv) {\nfloat o75374_0_1_f = shape_circle((uv), p_o75374_sides, p_o75374_radius*1.0, p_o75374_edge*1.0);\n\nreturn o75374_0_1_f;\n}\nfloat o128719_input_mask(vec2 uv) {\n\nreturn 1.0;\n}\nvec4 splatter_o128719(vec2 uv, int count, vec2 seed) {\n\tfloat c = 0.0;\n\tvec3 rc = vec3(0.0);\n\tvec3 rc1;\n\tfor (int i = 0; i < count; ++i) {\n\t\tseed = rand2(seed);\n\t\trc1 = rand3(seed);\n\t\tfloat mask = o128719_input_mask(fract(seed+vec2(0.5)));\n\t\tif (mask > 0.01) {\n\t\t\tvec2 pv = fract(uv - seed)-vec2(0.5);\n\t\t\tseed = rand2(seed);\n\t\t\tfloat angle = (seed.x * 2.0 - 1.0) * p_o128719_rotate * 0.01745329251;\n\t\t\tfloat ca = cos(angle);\n\t\t\tfloat sa = sin(angle);\n\t\t\tpv = vec2(ca*pv.x+sa*pv.y, -sa*pv.x+ca*pv.y);\n\t\t\tpv *= (seed.y-0.5)*2.0*p_o128719_scale+1.0;\n\t\t\tpv /= vec2((0.3+0.2*sin(iTime)), ((0.3+0.2*sin(iTime))));\n\t\t\tpv += vec2(0.5);\n\t\t\tpv = clamp(pv, vec2(0.0), vec2(1.0));\n\t\t\t \n\t\t\tseed = rand2(seed);\n\t\t\tfloat c1 = o128719_input_in(pv)*mask*(1.0-p_o128719_value*seed.x);\n\t\t\tc = max(c, c1);\n\t\t\trc = mix(rc, rc1, step(c, c1));\n\t\t}\n\t}\n\treturn vec4(rc, c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nfloat minSize = min(iResolution.x, iResolution.y);\nvec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\nvec4 o128719_0_rch = splatter_o128719((UV), int((70.0+sin(iTime)*50.0)), vec2(float(seed_o128719)));float o128719_0_1_f = o128719_0_rch.a;\nvec4 o19340_0_1_rgba = o19340_gradient_gradient_fct(o128719_0_1_f);\nvec4 o111660_0_1_rgba = vec4(clamp(o19340_0_1_rgba.rgb*p_o111660_contrast+vec3((max(sin(iTime), 0.0)))+0.5-p_o111660_contrast*0.5, vec3(0.0), vec3(1.0)), o19340_0_1_rgba.a);\nfragColor = o111660_0_1_rgba;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3czX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 7, 27, 27, 95], [97, 97, 117, 117, 229], [231, 231, 251, 251, 436], [438, 438, 460, 460, 757], [759, 759, 781, 781, 941], [943, 943, 1009, 1009, 1146], [1148, 1148, 1215, 1215, 1453], [1455, 1455, 1519, 1519, 1782], [1784, 1784, 1855, 1855, 2107], [2109, 2109, 2173, 2173, 2400], [3930, 3930, 3974, 3974, 5882], [6171, 6171, 6204, 6204, 6325], [6326, 6326, 6361, 6361, 6376], [6377, 6377, 6431, 6431, 7227], [7229, 7229, 7284, 7284, 7849]]}
{"id": "3s3yRr", "name": "Sinbloc", "author": "JacobC", "description": "My capsule-prism grid, move camera with mouse (click and drag)", "tags": ["3d", "raymarching", "sdf", "light", "ao", "diffuse"], "likes": 24, "viewed": 210, "published": "Public", "date": "1600224007", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * \"Sinbloc\" by Jacob Ceron aka JacobC - 2020\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: jacobceron6@gmail.com\n */\n\n// Set it to 1. if runs slow\n#define AA 2.\n// Set to 0 to compute AO in one grid cell (also goes faster)\n#define AO 1\n\nstruct mat\n{\n    float z;\n    vec3 c;\n    float ao;\n};\n\nfloat cube(in vec3 p, in vec3 s, float k)\n{\n    p = abs(p) - (s - k);\n    return length(max(p, 0.)) - k;\n}\n\nfloat map(float i, float c, float l, float q)\n{\n    return 1. - 1. / (c + l * i + q * i * i);\n}\n\nmat uop(in mat a, in mat b)\n{\n    // Cheap Ambient Occlusion: https://www.shadertoy.com/view/ttXfWX\n    // Adjust AO influence\n    // I like darker values e.g: 1., 1.4, 7.2\n    // but i think it looks more realistic with clearer values e.g: 1., 5.6, 115.2\n    // or 1., 2.8, 28.8 <---- I think this is better\n    float ao = map(max(a.z, b.z), 1., 2.8, 28.8);\n    return mat\n        (\n            min(a.z, b.z),\n            a.z < b.z ? a.c : b.c,\n            a.ao * ao\n        );\n}\n\n#define T iTime\n#define Pi 3.141592\n#define MIN_S .05\n\nmat scene(in vec3 p)\n{\n    vec3 w = p;\n    w.xz = mod(w.xz, 2.) - 1.;\n    float h = 1.-length(floor(p.xz / 2.)) - 2.;\n    h = cos(h + T) + .5;\n    \n    mat p0 = mat(cube(w, vec3(.8, .8 + h, .8), sin(T) * .4 + .4), vec3(1.5) / Pi, 1.);\n    mat p1 = mat(p.y, vec3(1.5) / Pi, 1.);\n    mat q = uop(p0, p1);\n    \n    // Checking closest neighboring grid cells which are the centered ones\n    // Center Top, Center Below, Center Left, Center Right\n    // Also you must consider the height of each neighboring cell\n    // this can be replaced with a loop.\n    #if AO\n    if (q.z < MIN_S)\n    {\n        h = h = 1.-length(floor((p.xz - vec2( 0.,  2.)) / 2.)) - 2.;\n        h = cos(h + T) + .5;\n        mat pCB = mat(cube(w - vec3( 0., 0., -2.), vec3(.8, .8 + h, .8), sin(T) * .4 + .4), vec3(1.), 1.);\n\n        h = h = 1.-length(floor((p.xz - vec2( 0., -2.)) / 2.)) - 2.;\n        h = cos(h + T) + .5;\n        mat pCT = mat(cube(w - vec3( 0., 0.,  2.), vec3(.8, .8 + h, .8), sin(T) * .4 + .4), vec3(1.), 1.);\n        \n        h = h = 1.-length(floor((p.xz - vec2( 2.,  0.)) / 2.)) - 2.;\n        h = cos(h + T) + .5;\n        mat pCL = mat(cube(w - vec3(-2., 0.,  0.), vec3(.8, .8 + h, .8), sin(T) * .4 + .4), vec3(1.), 1.);\n        \n        h = h = 1.-length(floor((p.xz - vec2(-2.,  0.)) / 2.)) - 2.;\n        h = cos(h + T) + .5;\n        mat pCR = mat(cube(w - vec3( 2., 0.,  0.), vec3(.8, .8 + h, .8), sin(T) * .4 + .4), vec3(1.), 1.);\n        \n        q = uop(q, pCB);\n        q = uop(q, pCT);\n        q = uop(q, pCL);\n        q = uop(q, pCR);\n    }\n    #endif\n    \n    return q;\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 e = vec2(.0001, .0);\n    float d = scene(p).z;\n    return normalize(d - vec3(scene(p - e.xyy).z, scene(p - e.yxy).z, scene(p - e.yyx).z));\n}\n\n#define STEPS 255\n#define MAX_S 40.\n\nmat marcher(in vec3 o, in vec3 d)\n{\n    float t = 0.;\n    for (int i = 0; i < STEPS; i++)\n    {\n        mat s = scene(o + d * t);\n        t += s.z * .2;\n        if (s.z < MIN_S)\n            return mat(t, s.c, s.ao);\n        if (t > MAX_S)\n            break;\n    }\n    return mat(t, vec3(-1.), -1.);\n}\n\n// https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat shadow(in vec3 o, in vec3 d, float k)\n{\n    float t = 0.;\n    float ms = 1.;\n    for (int i = 1; i <= 16; i++)\n    {\n        float s = scene(o + d * t).z;\n        ms = min(ms, s / float(i) * k);\n        t += s;\n        if (s < MIN_S)\n            return 0.;\n    }\n    return ms;\n}\n\nvec3 camera(in vec2 p, in vec3 o, in vec3 t)\n{\n    vec3 w = normalize(o - t);\n    vec3 u = normalize(cross(vec3(0., 1., 0.), w));\n    vec3 v = cross(w, u);\n    return p.x * u + p.y * v - w;\n}\n\n#define gd vec3(3., 2.4, 1.8)\n#define sk vec3(3., 2.4, 1.8)\n\n#define l0 vec3(6., 12., 6.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord;\n    vec3 fc;\n    \n    for (float y = 0.; y < AA; y++)\n    {\n        for (float x = 0.; x < AA; x++)\n        {\n            vec2 n = vec2(x, y) / AA - .5;\n            vec2 uv = (st + n - iResolution.xy * .5) / iResolution.y;\n            vec2 ms = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n\n            vec3 o = iMouse.z > 0. ? vec3(sin(ms.x * Pi * 2.), max(ms.y * 3., .35), cos(ms.x * Pi * 2.)) * 9. \n                : vec3(sin(5.), 1., cos(5.)) * 8.;\n            vec3 d = camera(uv, o, vec3(0., 0., 0.));\n            vec3 bg = mix(gd, sk, d.y * .5 + .5);\n            vec3 col;\n\n            mat m = marcher(o, d);\n            if (m.ao != -1.)\n            {\n                vec3 p = o + d * m.z;\n                vec3 n = normal(p);\n                bg = mix(gd, sk, n.y * .5 + .5);\n\n                vec3 l = l0 - p;\n                vec3 ld0 = normalize(l);\n                float att = 1.-map(length(l), 1., .02, .001);\n                float sh = shadow(p + n * .3, ld0, max(32. - length(l), 0.));\n                vec3 diff = max(dot(ld0, n), 0.) * vec3(1.) * att * sh + m.ao / Pi;\n                vec3 ambi = bg * m.ao / Pi;\n                \n                vec3 all_l = ambi + diff;\n\n                col += all_l * m.c;\n            }\n            else\n                col += sk / Pi;\n            fc += col;\n        }\n    }\n\n    fc /= AA * AA;\n    \n    fragColor = vec4(sqrt(fc), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3yRr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[218, 350, 393, 393, 456], [458, 458, 505, 505, 553], [555, 555, 584, 863, 1035], [1092, 1092, 1114, 1114, 2664], [2666, 2666, 2690, 2690, 2840], [2879, 2879, 2914, 2914, 3179], [3181, 3244, 3289, 3289, 3529], [3531, 3531, 3577, 3577, 3722], [3815, 3815, 3872, 3872, 5289]]}
{"id": "3s3yRS", "name": "Fractal Sky #3", "author": "NivBehar", "description": "fractals", "tags": ["mandelbrot", "fractals"], "likes": 6, "viewed": 91, "published": "Public", "date": "1601113542", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERATIONS 150\n#define COLOR_REPEAT 0.6\n#define MANDELBROT_SHADE 2072.\n#define time iTime\n#define HEX_DIST 1.\n#define HAIR_DIST 21.\n#define PI 3.141592654\n#define _DotsSize 0.213\n#define _DotsSmoothness 0.221\n\nvec2 rot(vec2 p, vec2 pivot, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    p -= pivot;\n    p = vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n    p += pivot;\n\n    return p;\n}\nfloat HexDist(vec2 p) {\n    p = abs(p);\n\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n\n    return c;\n}\nvec4 HexCoords(vec2 UV) \n{\n    vec2 r = vec2(1, 1.73);\n    vec2 h = r*.5;\n\n    vec2 a = mod(UV, r)-h;\n    vec2 b = mod(UV-h, r)-h;\n\n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n\n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = UV - gv;\n    return vec4(x, y, id.x,id.y);\n}\nfloat TriangleDist(vec2 p, vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(p.x*q.y-p.y*q.x),k*(p.y-q.y)  );\n    return sqrt(d)*sign(s);\n}\nvec3 iterate(vec2 UV , float distance_type)\n{\n    //cool shit: https://www.shadertoy.com/view/wdBfDK\n    //UV = _MandelbrotArea.xy + (UV-0.5)*_MandelbrotArea.zw;\n    //UV = rot(UV, _MandelbrotArea.xy, _MandelbrotAngle);\n\n    vec3 col;\n\n    float dots_dist = 1e20f;\n    vec2 z = UV;\n    // shape = z for regular mandelbrot set\n    // a; 0       ; (GOLDEN-2); 0.285; 0.285; 0.45  ; -0.70176; -0.835 ; -0.8 ; -0.7269; -0.754\n    // b; 1-GOLDEN; (GOLDEN-1); 0    ; 0.01 ; 0.1428; -0.3842 ; -0.2321; 0.156; 0.1889; -0.066\n    //float[1] shapes;\n    //float2 shapes[11] = {z, float2(0, 1-GOLDEN), float2(GOLDEN-2, GOLDEN-1), float2(0.285, 0.), float2(0.285, 0.01), float2(0.45, 0.1428), float2(-0.70176, -0.3842), float2(-0.835, -0.2321),\n        //float2(-0.8, 0.156), float2(-0.7269, 0.1889), float2(-0.754, -0.066)};\n    vec2 shape;\n    shape = vec2(0.285, 0.0103);\n    //shape = float2(_fractal_shape_a, _fractal_shape_b);\n    //if(shape.x == 0 && shape.y == 0)\n    //    shape = z;\n    vec2 prev_z;\n    vec2 z_dots;\n    vec4 z_hc;\n    float dist_from_mandelbrot = 1e20f;\n    float r = 20.;\n\n    vec2 hc2;\n    int i = 0;\n    for(i = 0; i<ITERATIONS; i++ )\n    {\n        prev_z = z;\n        if(distance_type == HEX_DIST)\n        {\n            vec2 z2 = rot(z, vec2(0.), time*0.4);\n            r = 1. + 10.*HexDist(0.5 + 2.*sin(cos(z2)*0.5)*cos(cos(z2*3.)));\n        }\n        if(distance_type == HAIR_DIST)\n        {   \n            vec2 z1 = 10.*z/dot(z+0.2*cos(z+time*0.),z+0.2*sin(z+time*0.));\n            //z1 +=time;\n            vec2 z2 = rot(z1, vec2(0.), time*0.4);\n            r = 10. + 15.*TriangleDist(sin(cos(z2*PI + PI)*0.5 + 5.)*sin(cos(z2*PI)), vec2(1000.,3.2));\n            //float r2 = 5 + 15*TriangleDist(sin(cos(z2*PI+time*1)*0.5 + 5)*cos(cos(z2*PI)), float2(50,-0.6));\n            //r = lerp(r,r2, 0.4 + 0.4*sin(time));\n            //r = 5+TriangleDist(z*3, float2(_test1,_test2));\n        }\n\n        //r = HexCoords(0.5 + 0.25*sin(cos(z*2 + time)*0.1)*cos(cos(z*3) + 0.25*sin(cos(prev_z*2)) )).y*10;\n        z = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + shape;\n        //float z_hash = N22(z);\n        if(length(z) > r)\n            //if(dot(z, prev_z) > r)\n            break;\n        //return 0.0;\n\n\n        z_dots = z + rot(z,prev_z,time*0.2);\n        z_dots = vec2(HexDist(z_dots));\n        z_hc = HexCoords(z_dots);\n\n        //z_dots = pMod2(z_dots,4);\n\n        dots_dist = min( dots_dist, dot(z_dots,z_dots) );\n        //dots_dist = min( dots_dist, dot(z_hc.x,z_hc.y) );\n        dist_from_mandelbrot = min(dist_from_mandelbrot, dot(z,z));\n\n        //hc2 = min(hc2, HexCoords(prev_z).xy);\n    }\n\n    if(i >= ITERATIONS)\n        return vec3(0.);\n\n    float fraciter = log2( log(length(z)) / log(r) );\n    float j = float(i);\n    //j -= fraciter;\n\n    //float2 hc = HexCoords(dots_dist).xy;\n\n    //col = smoothstep(0,dist, sin(hc.y*15)*cos(hc.y*15));\n    //float dots_size = 1;\n    //float dots_smoothness = 0.9;\n    float dots = smoothstep(_DotsSize - _DotsSmoothness, _DotsSize, dots_dist);\n    //dots = smoothstep(0.9, 1, dots_dist);\n    dots = clamp(0.,1.,dots);\n\n    //col = smoothstep(0,dist, );\n    //float3 tex = tex2D(_MainTex, hc2);\n    //col = tex;\n    //col = dots;\n\n    vec3 beat = vec3(time*0.4);//(_smooth_bass2 + _smooth_mid2 + _smooth_treb2)*0.001 + (_bass2 + _mid2 + _treb2)*0.003;\n    // Color 1\n    vec3 a1 = vec3(0.5, 0.5, 0.5);\n    vec3 b1 = vec3(0.75, 0.55, 0.85);\n    vec3 c1 = beat; // animate \\ offset\n    vec3 d1 = vec3(0.0, 0.1, 0.2);\n    // Color 2\n    vec3 a2 = vec3(0.5, 0.5, 0.5);\n    vec3 b2 = vec3(0.75, 0.55, 0.85);\n    vec3 c2 = vec3(1.0, 1.0, 0.5); // animate \\ offset\n    vec3 d2 = vec3(0.8, 0.9, 0.3);\n    // Color 3 - blue to gray\n    vec3 a3 = vec3(0.5, .5, 1.);\n    vec3 b3 = vec3(0.5, 0.5, 0.);\n    vec3 c3 = vec3(0., 0., 0.); // animate \\ offset\n    vec3 d3 = vec3(0., 0., 0.);\n    // Color 4 - black and white\n    vec3 a4 = vec3(1, 1, 1);\n    vec3 b4 = vec3(1.0, 1.0, 1.0);\n    vec3 c4 = vec3(1.0, 1.0, 1.0); // animate \\ offset\n    vec3 d4 = vec3(1.0, 1.0, 1.0);\n    \n    vec3 a5 = vec3(0.3, 0.27, 0.5);\n    vec3 b5 = vec3(0.9, 0.45, 0.75);\n    vec3 c5 = vec3(beat); // animate \\ offset\n    vec3 d5 = vec3(.8, 0.9, 0.25);\n    \n    // Color choise\n    //vec3 a = mix(a1, a2, 0.*time*0.02);\n    //vec3 b = mix(b1, b2, 0.*time*0.02);\n    //vec3 c = mix(c1, c2, 0.*time*0.02);\n    //vec3 d = mix(d1, d2, 0.*time*0.02);\n\n    vec3 col1 = a1 + b1 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d1 + c1));\n    vec3 col2 = a2 + b2 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d2 + time*0.2));\n    vec3 col3 = a3 + b3 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d3 + c3 ));\n    vec3 col4 = a4 + b4 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d4 + c4));\n    vec3 col5 = a5 + b5 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d5 + c5));\n\tvec3 col6 = mix(col1, col5, abs(col1-col5));\n    col = col6;\n    \n    \n    //col = mix(col1, col4, 0.5 + 0.5*sin(float(i)));\n    //col = vec3(clamp(0.,1.,fraciter));\n    //col = mix(col, col2, fraciter);\n    //col = col2;\n    //col = vec3(dist_from_mandelbrot);\n\n    dist_from_mandelbrot = smoothstep(0., j/(MANDELBROT_SHADE), dist_from_mandelbrot);\n    //dist_from_mandelbrot = smoothstep(0, (_MandelbrotArea.z)*0.1, dist_from_mandelbrot); // shade depends on the zoom \n\n    dist_from_mandelbrot = clamp(0.,1.,dist_from_mandelbrot);\n\n    if(distance_type == HEX_DIST)\n    {\n        float leaves = smoothstep(0.,0.7,fraciter);\n        float leaves_edges = smoothstep(0.3,0.,fraciter);\n        //float leaves_edges_tips = smoothstep(-0.02,0.03,fraciter);\n        //leaves_edges *= leaves_edges_tips;\n        col *= leaves;\n        //col += leaves_edges;\n        //col *= dist_from_mandelbrot;\n\n    }\n    if(distance_type == HAIR_DIST)\n    {\n        float hair = smoothstep(0.,1.5,fraciter);\n        float hair_edges = smoothstep(0.18,0.,fraciter);\n        float hair_edges_tips = smoothstep(-0.02,0.03,fraciter);\n        //hair_edges *= hair_edges_tips; // to avoid pxieli edges of the hairs\n        col *= hair;\n        //col += hair_edges;\n\n        // add dots\n        //col *= (dist_from_mandelbrot);\n\n        //float id = j;\n        //float hash = N11(id + floor(-time*2));\n        //col += 0.1*(1-dist_from_mandelbrot) * (col3);\n        //col = col3;\n    }\n\n\n\n    //col = hash+0.1;\n\n\n    //col *= hair_edges2*dist_from_mandelbrot;\n    //col = col4;\n    //col = fraciter;\n\n    //col *= dots;\n    //col += (1-dots)*dist_from_mandelbrot*col3;\n    //col *= smoothstep(0.8,0.,fraciter);\n    //col = dots;\n    //col = fraciter;\n    //col = 1-dots;\n\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv;// = fragCoord/iResolution.xy;\n    \n    float zoom = 3.;\n\n    //uv += 0.4;\n    //uv = 0.7*uv/dot(uv,uv);\n    //uv += vec2(cos(0.1*iTime), sin(0.1*iTime));\n\n    #if 1\n    int AA = 3 ;\n    vec3 col = vec3(0.);\n    // anti-aliasing from https://www.shadertoy.com/view/Mss3R8\n\tfor( int j=0; j<AA; j++ )\n\tfor( int i=0; i<AA; i++ )\n\t{\n\t\tvec2 of = -0.5 + vec2( float(i), float(j) )/float(AA);\n\n        uv = (fragCoord+of)/iResolution.xy;\n        uv*=zoom;\n        uv.x-= zoom/2.;\n        uv.y -= zoom/2.;\n\t   col += iterate( uv, HAIR_DIST );\n\t}\n\tcol /= float(AA*AA);\n    \n    #else\n    \n    uv = fragCoord/iResolution.xy;\n    uv*=zoom;\n    uv.x-= zoom/2.;\n    uv.y -= zoom/2.;\n\tvec3 col = iterate(uv, HAIR_DIST);\n    \n    #endif\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3yRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 218, 257, 257, 395], [396, 396, 419, 419, 521], [522, 522, 548, 548, 819], [820, 820, 857, 857, 1148], [1149, 1149, 1194, 1368, 7669], [7670, 7670, 7727, 7777, 8545]]}
{"id": "3scczB", "name": "test 2D ray", "author": "MallSerg", "description": "test 2D ray", "tags": ["2dray"], "likes": 3, "viewed": 59, "published": "Public", "date": "1601130033", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdCircle(vec2 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat border(vec2 p)\n{\n    vec2 R = iResolution.xy;\n\treturn min(p.x,min(p.y,min(R.x-p.x,R.y-p.y)));\n}\n\nfloat map(vec2 p)\n{\n\t//     \n    return min(\n               min(\n                   sdCircle(( iResolution.xy/2.) + vec2(200.,150.)   - p,50.0), border(p)\n                  ),\n        \t   sdCircle(( iResolution.xy/2.) + vec2(-150.,-100.) - p,40.0)\n              );\n\t\t\t\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sp = fragCoord;\n\tvec3 col = vec3(0.0);\n\t\n    vec2 ro = iResolution.xy/2.;\n    \n    vec2 rd = vec2(cos(iTime * .1),sin(iTime * .1));\n    // mouse input\n    rd = iMouse.z < .001 ? rd : normalize(iMouse.xy - ro);\n    \n    // position on the ray\n    vec2 pos = ro;\n    \n    float t = 5.0;\n    \n    int i;\n    for(i=0; i < 60 && t > 0.1;i++)\n    {\n    \tvec2 pPos = pos;\n        float pT = t;\n        \n        pos = pos + t*rd;\n        \n        t = map(pos);\n        \n        //     ------------------\n        float rcd = sdCircle(sp-pPos,pT);\n        col = mix(vec3(0.2),col,smoothstep(rcd,0.,0.5));\n        col = mix(vec3(0.2),col,smoothstep(-rcd,-0.5,0.));\n        \n        //     =) -----------------\n        float dist = sdCircle(sp-pPos,5.0);\n        col = mix(vec3(0.0,1.,1.),col,smoothstep(dist,0.,1.0));\n        col = mix(vec3(0.0,1.,1.),col,smoothstep(-dist,-1.0,0.));\n        //col = round(col);\n    }\n    \n    \n    // \n    col = mix(vec3(1.,1.,1.),col,smoothstep(map(sp),0.0,1.0));\n    \n    col = mix(vec3(1.,1.,1.),col,smoothstep(-map(sp),-1.,200.));\n\n    fragColor = vec4(1.-col,2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3scczB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 58], [60, 60, 82, 82, 161], [163, 163, 182, 257, 504], [506, 506, 563, 563, 1759]]}
{"id": "3scyDn", "name": "BALLS", "author": "SilvanKohler", "description": "BALLS", "tags": ["balls"], "likes": 6, "viewed": 241, "published": "Public API", "date": "1600717962", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\nconst float balls = 5.5;\nconst float speed = 6.;\nconst float cramming = 6.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy/2.) / iResolution.y * 2.;\n\tvec2 m =  (iMouse.xy - iResolution.xy/2.) / iResolution.y * 2.;\n    float d = 0.;\n\tfloat r;\n    float a;\n    vec2 p;\n    for (float i = iTime*speed+.01;  i<iTime*speed+balls; i += 1.01){\n    \ta = PI * 2. / balls * cramming * i;\n\t\tr = sin(iTime);\n        p = vec2(sin(a)*r, cos(a)*r);\n        d += 1./length(uv-p);\n    }\n    d /= 2.;\n    vec3 col = vec3(d/40., d/35., d/25.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3scyDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 151, 201, 703]]}
{"id": "3scyR4", "name": "Inside Echeveria ", "author": "rpodeanu", "description": "Modification of Echeveria by tdhooper \nhttps://www.shadertoy.com/view/wlVGRz", "tags": ["intro"], "likes": 6, "viewed": 96, "published": "Public", "date": "1600443086", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Modification of Echeveria by tdhooper \n// https://www.shadertoy.com/view/wlVGRz\n\nconst float PI  = 3.14159265359;\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat time;\n\nvec4 leaf(vec3 p, vec2 uv) {\n    float thick = clamp(uv.y, .7, 1.);\n    thick = 1.;\n    float th = thick * .16;\n    pR(p.xz, -uv.x);\n    float width = mix(.5, .1, min(uv.y, 1.));\n    width = .75 / uv.y;\n    width *= thick;\n    vec3 n = normalize(vec3(1,0,width));\n    float d = -dot(p, n);\n    d = max(d, dot(p, n * vec3(1,1,-1)));\n    float len = mix(PI / 1.2, PI / 2., pow(uv.y/2.9, 2.));\n    len = max(len, 0.);\n    pR(p.yz, PI / 2. - len);\n    d = smax(d, p.y, thick);\n    d = smax(d, abs(length(p) - uv.y) - thick * th, th);\n    vec2 uuv = vec2(\n        atan(p.y, p.z) / -len,\n        p.x\n   \t);\n    vec3 col = mix(vec3(0), vec3(.5,1,.7) * .05, 1.-smoothstep(.0, .5, uuv.x));\n    col += vec3(.06,.0,.03) * max(1. - uv.y / 2., 0.);\n    col = mix(col, col * .2, 1.-smoothstep(.0, .2, uuv.x));\n    return vec4(d, col);\n}\n\nbool lightingPass;\n\nvec4 opU(vec4 a, vec4 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec4 bloom(vec3 p) {\n\n    float bound = length(p - vec3(0,-1.2,0)) - 3.3;\n    bound = max(bound, p.y - 1.1);\n    if (bound > .01 && ! lightingPass) {\n        return vec4(bound, 0, 0, 0);\n    }\n\n    vec2 cc = vec2(5., 8.);\n    if (iMouse.z > 0.) {\n    \tcc = floor(iMouse.xy / iResolution.xy * 10.);\n    }\n    float aa = atan(cc.x / cc.y);\n    float r = (PI*2.) / sqrt(cc.x*cc.x + cc.y*cc.y);\n    mat2 rot = mat2(cos(aa), -sin(aa), sin(aa), cos(aa));\n    \n    vec2 offset = vec2(1, 2) * time * r * rot;\n    \n    vec2 uv = vec2(\n        atan(p.x, p.z),\n        length(p)\n    );\n\n    uv -= offset;\n\n    uv = rot * uv;\n    vec2 cell = round(uv / r);\n\n    vec4 d = vec4(1e12, vec3(0));\n\n    d = opU(d, leaf(p, ((cell + vec2(-1, 0)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(0, -1)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(0, 0)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(1, -1)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(1, 0)) * rot * r) + offset));\n\n    //*\n    d = opU(d, leaf(p, ((cell + vec2(-1, -1)) * rot * r) + offset));\n   \td = opU(d, leaf(p, ((cell + vec2(-1, 1)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(0, 1)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(1, 1)) * rot * r) + offset));\n\t//*/\n\n    return d;\n}\n\nvec4 map(vec3 p) {\n    return bloom(p);\n}\n\nvec3 calcNormal(vec3 pos){\n    float eps = .0005;\n    vec2 e = vec2(1.0,-1.0) * 0.5773;\n    return normalize(\n        e.xyy * map(pos + e.xyy * eps).x + \n\t\te.yyx * map(pos + e.yyx * eps).x + \n\t\te.yxy * map(pos + e.yxy * eps).x + \n\t\te.xxx * map(pos + e.xxx * eps).x\n    );\n}\n\n// https://www.shadertoy.com/view/lsKcDD\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    float ph = 1e10;\n    \n    for( int i=0; i<64; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n//#define AA 3\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec3 col;\n    vec3 tot = vec3(0.0);\n\n    float mTime = mod(iTime / 2., 1.);\n    time = mTime;\n\n    vec2 o = vec2(0);\n\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    // pixel coordinates\n    o = vec2(float(m),float(n)) / float(AA) - 0.5;\n    // time coordinate (motion blurred, shutter=0.5)\n    float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n    time = mTime - 0.1*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n    #endif\n        lightingPass = false;\n\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\n        vec3 camPos = vec3(0.0, 0.0, 0.0) * .9;\n        mat3 camMat = calcLookAtMatrix( camPos, vec3(0,-1.4,0), -0.5);\n        vec3 rd = normalize( camMat * vec3(p.xy,2.8) );\n\n        vec3 pos = camPos;\n        float rayLength = 0.;\n        float dist = 0.;\n        bool bg = false;\n        vec4 res;\n\n        for (int i = 0; i < 100; i++) {\n            rayLength += dist;\n            pos = camPos + rd * rayLength;\n            res = map(pos);\n            dist = res.x;\n\n            if (abs(dist) < .001) {\n                break;\n            }\n            \n            if (rayLength > 16.) {\n                bg = true;\n                break;\n            }\n        }\n\n        col = vec3(.19,.19,.22) * 1.9;\n        col = vec3(.35,.24,.0) * 1.8;\n\t\tcol = vec3(.5,1,.7) * .05;\n        \n        if ( ! bg) {\n            \n            lightingPass = true;\n            \n\t\t\tvec3 nor = calcNormal(pos);\n            float occ = calcAO( pos, nor );\n            vec3  lig = normalize( vec3(-.2, 1.5, .3) );\n            vec3  lba = normalize( vec3(.5, -1., -.5) );\n            vec3  hal = normalize( lig - rd );\n            float amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n            float bac = clamp( dot( nor, lba ), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n            float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n            occ = mix(1., occ, .8);\n            \n            dif *= softshadow( pos, lig, 0.001, .9 );\n\n            float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                        dif *\n                        (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n            vec3 lin = vec3(0.0);\n            lin += 2.80*dif*vec3(1.30,1.00,0.70);\n            lin += 0.55*amb*vec3(0.40,0.60,1.15)*occ;\n            lin += 1.55*bac*vec3(0.25,0.25,0.25)*occ*vec3(2,0,1);\n            lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\n            col = res.yzw;\n        \tcol = col*lin;\n\t\t\tcol += 5.00*spe*vec3(1.10,0.90,0.70);\n\n            //col = nor * .5 + .5;\n            //col = max(dot(vec3(.1,1,-.2), nor), 0.) * vec3(.2);\n        }\n\n        tot += col;\n    #ifdef AA\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    col = tot;\n    col *= 1.3;    \n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3scyR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 118, 150, 150, 195], [197, 197, 235, 235, 346], [348, 348, 387, 387, 418], [433, 433, 461, 461, 1255], [1277, 1277, 1303, 1303, 1335], [1337, 1337, 1357, 1357, 2658], [2660, 2660, 2678, 2678, 2701], [2703, 2703, 2729, 2729, 2976], [2978, 3019, 3093, 3093, 3380], [3382, 3423, 3465, 3465, 3767], [3769, 3769, 3833, 3833, 4011], [4013, 4029, 4084, 4084, 6973]]}
{"id": "3scyWn", "name": "FireForCharacters", "author": "Tomasz", "description": "draw FFC", "tags": ["ffc"], "likes": 1, "viewed": 63, "published": "Public", "date": "1601243365", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat hash12(vec2 x) {\n    return fract(sin(dot(x, vec2(40.3862, 65.37862))) * 3224.9721);\n}\nfloat noise12(vec2 x) {\n    vec2 root = floor(x);\n    vec2 t = fract(x);\n    \n    float n00 = hash12(root + vec2(0,0));\n    float n01 = hash12(root + vec2(0,1));\n    float n10 = hash12(root + vec2(1,0));\n    float n11 = hash12(root + vec2(1,1));\n    \n    float n0 = mix(n00, n01, t.y);\n    float n1 = mix(n10, n11, t.y);\n    \n    return mix(n0, n1, t.x);\n    \n}\nfloat fractalNoise12(vec2 x) {\n    \n    float sum = 0.0;\n    for(float i = 1.0; i <= 32.0; i *= 2.0)\n    {\n        float noise = noise12(x * i) /i;\n        \n        sum += noise;\n        x += noise;\n    }\n    return sum /2.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    uv *= 8.0;\n\n    vec2 rootUV = floor(uv);\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n    \n    float step1 = -0.5;\n    float step2 = 0.5;\n    \n    float cutoutLine = smoothstep(step1 - (sin(iTime * 0.2) * 0.25 + 0.25), step2 + 0.2, uv.y *0.2);\n    \n    vec3 color1 = mix(white, black, cutoutLine);\n    \n\tuv.y -= iTime * 0.4;\n    float noise = fractalNoise12(uv);\n   \n    \n    vec3 fireMask = step(noise, color1);\n    vec3 fireSmooth = 1.0 - smoothstep(noise, noise + 0.1, color1 - 0.2);\n    \n    vec3 fireNoise = fireMask * noise;\n    \n    vec3 fire = fireMask - fireSmooth + fireNoise;\n    fire *= 1.0 - smoothstep( 0.2, 0.0, fire);\n  \n\n    fragColor = vec4(fire, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3scyWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 23, 23, 93], [94, 94, 117, 117, 455], [456, 456, 486, 486, 683], [684, 684, 741, 791, 1563]]}
{"id": "3sdcDM", "name": "peppa pig by Floppy", "author": "jorge2017a1", "description": "peppa pig by Floppy", "tags": ["peppapigbyfloppy"], "likes": 8, "viewed": 131, "published": "Public", "date": "1601043906", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// piggy at Revision 2012 by Floppy\n\n\n\nfloat randv(vec2 r) {\n    return fract(sin(dot(r.xy, vec2(13.432, 15.233))) * 23000.5453);\n}\nfloat rand(float r) {\n    return fract(sin(r*13.432) * 23000.5453);\n}\nfloat circle(float x, float y, float R)\n{\n   if(sqrt(x*x+y*y)<R) \n      return 1.0;\n   else \n      return 0.00;\n}\nfloat circledist(float x, float y, float R)\n{\n   return abs(sqrt(x*x+y*y)-R);\n}\nfloat circledistin(float x, float y, float R)\n{\n   float r = sqrt(x*x+y*y);\n   if(r<R) \n      return R-r;\n   \n   return 0.00;\n}\n\nfloat circlegrad(float x, float y, float R)\n{\n   float r = sqrt(x*x+y*y);\n   if(r<R) \n      return 12.0-12.0*r/R;\n   else \n      return 0.00;\n}\nfloat circleflower(float x, float y, float R)\n{\n   float r = sqrt(x*x+y*y);\n   float phi = atan(y/x);\n   r += (0.01)*sin(12.0*phi);\n   r += 0.05*rand(12.0*phi)*sin(12.0*phi);\n   if(r<R) \n      return 2.0-2.0*r/R;\n   else \n      return 0.00;\n}\n\nfloat circleplama(float x, float y, float R, float f, float A)\n{\n   float r = sqrt(x*x+y*y);\n   float phi = atan(y/x);\n   r -= A*sin(f*phi);\n   if(r<R) \n      return 1.0;\n   else \n      return 0.00;\n}\n\n\nfloat rect(float x, float y, float sx, float sy, float a, float b)\n{\n   if(x>sx && x<a && y>sy && y<b) \n      return 1.0;\n   else \n      return 0.0;\n}\n\nvec3 hand(float x, float y, vec3 col, vec3 pink)\n{\n   float c;\n   float a;\n   a=-1.1;\n   c = rect((x)*cos(a)-sin(a)*(y)-0.249,sin(a)*(x)+cos(a)*(y)+0.613, 0.35, 0.53, 0.38, 0.538);\n   col = col*(1.0-c) + pink*c;\n   a=0.7;\n   c = rect((x)*cos(a)-sin(a)*(y)+0.444,sin(a)*(x)+cos(a)*(y)-0.103, 0.35, 0.53, 0.38, 0.538);\n   col = col*(1.0-c) + pink*c;\n   a=0.02;\n   c = rect((x)*cos(a)-sin(a)*(y)+0.0,sin(a)*(x)+cos(a)*(y)-0.0, 0.326, 0.528, 0.351, 0.538);\n   col = col*(1.0-c) + pink*c;\n   return col;\n}\nvec3 foot2(float x, float y, vec3 col, vec3 black)\n{\n\n   float c;\n   c = rect((x-0.54)*0.7+0.05,(y-0.324)*1.4+0.06,0.02,0.02,0.06,0.06);\n   col = col*(1.0-c) + black*c;\n   c = rect((x-0.54)*1.2+0.02,(y-0.324)*0.8+0.04,0.02,0.02,0.06,0.06);\n   col = col*(1.0-c) + black*c;\n   return col;\n}\nvec3 foot(float x, float y, vec3 col, vec3 black)\n{\n   float c;\n   c = circle((x-0.537)*2.4-0.04,(y-0.324)*0.9,0.03)*(1.0-circle((x-0.54)*0.8,(y-0.344)*2.2,0.03))*(1.0-circle((x-0.54)*0.8,(y-0.289)*2.2,0.03));\n   col = col*(1.0-c) + black*c;\n   return col;\n}\n\n\nvec3 kropla(float x, float y, vec3 col, vec3 black)\n{\n   float c;\n   c = circle((x-0.54)*1.2,(y-0.324)*3.6,0.03);\n   col = col*(1.0-c) + black*c;\n   c = circle((x-0.53)*1.4,(y-0.324)*2.8,0.03);\n   col = col*(1.0-c) + black*c;\n   return col;\n}\n\n\nvec3 head(float x, float y, vec3 col, vec3 pink, vec3 pinkp, vec3 lips, vec3 black, vec3 white, float glass, float beard, float rzesy, float mouth,float oczy)\n{\n   float c;\n   // ear left\n   c = circle((x-0.49)*2.1,(y-0.82)*1.0,0.04);\n   col = col*(1.0-c) + pinkp*c;\n   c = circle((x-0.49)*2.1,(y-0.82)*1.0,0.03);\n   col = col*(1.0-c) + pink*c;\n   // ear right\n   c = circle((x-0.56)*2.1,(y-0.79)*1.0,0.04);\n   col = col*(1.0-c) + pinkp*c;\n   c = circle((x-0.56)*2.1,(y-0.79)*1.0,0.03);\n   col = col*(1.0-c) + pink*c;\n   // ear1\n   float circle21 = circle((x-0.5)*1.6*y,(y-0.69)*0.97,0.105-0.002*glass);\n   col = col*(1.0-circle21) + pinkp*circle21;\n   float circle2 = circle((x-0.5)*1.6*y,(y-0.69)*0.97,0.1);\n   col = col*(1.0-circle2) + pink*circle2;\n   // lips \n   c = circle((x-0.47)*1.6*y,(y-0.66)*0.97,0.038);\n   col = col*(1.0-c) + lips*c;\n   c = circle((x-0.47)*1.6*y,(y-0.66)*0.97,0.032);\n   col = col*(1.0-c) + pink*c;\n   c = circle((x-0.46)*1.6*y,(y-0.68)*0.97,0.032);\n   col = col*(1.0-c) + pink*c;\n   c = circle((x-0.49)*1.6*y,(y-0.68)*0.97,0.032);\n   col = col*(1.0-c) + pink*c;\n//   if(mouth!=0.0)\n//   {\n      c = circle((x-0.47)*1.6*y,(y-0.66)*0.97,0.034) * (1.0-circle((x-0.47)*0.9*y-0.002,(y-0.66)*0.70-0.023*mouth+0.000,0.034));\n      col = col*(1.0-c) + lips*c;\n      c = circle((x-0.47)*1.6*y,(y-0.66)*0.97,0.034) * (1.0-circle((x-0.47)*1.0*y-0.002,(y-0.66)*0.70-0.02*mouth+0.000,0.034));\n      col = col*(1.0-c) + black*c;\n//   }\n\n   // nose\n   c = circle((x-0.45)*1.3*y,(y-0.75)*1.9,0.105)*(1.0-circle((x-0.5)*1.6*y,(y-0.69)*0.97,0.105));\n   col = col*(1.0-c) + pinkp*c;\n   c = circle((x-0.45)*1.3*y,(y-0.75)*1.9,0.1);\n   col = col*(1.0-c) + pink*c;\n   // nose end\n   c = circle((x-0.366)*5.2*y,(y-0.747)*2.8,0.1);\n   col = col*(1.0-c) + pinkp*c;\n   c = circle((x-0.366)*5.2*y,(y-0.747)*2.8,0.08);\n   col = col*(1.0-c) + pink*c;\n   // nose holes\n   c = circle((x-0.355)*0.2,(y-0.745)*0.2,0.0013);\n   col = col*(1.0-c) + lips*c;\n   c = circle((x-0.375)*0.2,(y-0.745)*0.2,0.0013);\n   col = col*(1.0-c) + lips*c;\n   // glasses\n   if(glass!=0.0)\n   {\n      // palka ucho\n      float a = -0.08;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.11,sin(a)*(x)+cos(a)*(y)+0.050, 0.444, 0.75, 0.524, 0.759);\n      col = col*(1.0-c) + pink*0.75*c;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.11,sin(a)*(x)+cos(a)*(y)+0.049, 0.444, 0.75, 0.522, 0.757);\n      col = col*(1.0-c) + pink*0.25*c;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.11,sin(a)*(x)+cos(a)*(y)+0.048, 0.444, 0.75, 0.52, 0.755);\n      col = col*(1.0-c) + black*c;\n      // left okular\n      c = circle((x-0.425)*3.4,(y-0.762)*3.4,0.079);\n      col = col*(1.0-c) + pink*0.75*c;\n      c = circle((x-0.425)*3.4,(y-0.762)*3.4,0.076);\n      col = col*(1.0-c) + black*c;\n      c = circle((x-0.425)*3.4,(y-0.762)*3.4,0.06);\n      col = col*(1.0-c) + pink*c;\n\n      // right okular\n      c = circle((x-0.475)*3.4,(y-0.753)*3.4,0.079);\n      col = col*(1.0-c) + pink*0.75*c;\n      c = circle((x-0.475)*3.4,(y-0.753)*3.4,0.076);\n      col = col*(1.0-c) + black*c;\n      c = circle((x-0.475)*3.4,(y-0.753)*3.4,0.06);\n      col = col*(1.0-c) + pink*c;\n      // palka miedzy\n      c = rect(x,y, 0.447, 0.755, 0.455, 0.76);\n      col = col*(1.0-c) + black*c;\n   }\n   // eye1\n   float circle14 = circle((x-0.475)*1.0,(y-0.75)*1.0,0.015);\n   col = col*(1.0-circle14) + pinkp*circle14;\n   float circle4 = circle((x-0.475)*1.0,(y-0.75)*1.0,0.0115);\n//   col = col*(1.0-circle4) + white*circle4;\n   float b=0.0; if(rzesy==1.0) b=pow(0.5 + 0.5*sin(2.0*iTime),20.0+rand(iTime)*10.0); // magic function by iq\n   col = col*(1.0-circle4) + (white*(1.0-b)+b*pink)*circle4;\n\n   float circle15 = circle((x-0.425)*1.0,(y-0.76)*1.0,0.015);\n   col = col*(1.0-circle15) + pinkp*circle15;\n   float circle5 = circle((x-0.425)*1.0,(y-0.76)*1.0,0.0115);\n   col = col*(1.0-circle5) + (white*(1.0-b)+b*pink)*circle5;\n\n\n   // OCZY\n   float circle6,circle7;\n   //if(oczy==0.0) // mama\n   {\n      circle6 = circle((x-0.47)*1.0,(y-0.744)*1.0,0.00554);\n      circle7 = circle((x-0.42)*1.0,(y-0.754)*1.0,0.0055);\n   }\n\n   col = col*(1.0-circle6) + (black*(1.0-b)+b*pink)*circle6;   \n   col = col*(1.0-circle7) + (black*(1.0-b)+b*pink)*circle7;\n\n\n   // rush\n   vec3 pink2 = vec3(252.0,140.0,212.0)/255.0;\n   c = circle((x-0.54)*1.4,(y-0.674)*0.9,0.023);\n   col = col*(1.0-c) + pink2*c;\n\n   // beard\n   vec3 beardcol=vec3(167,93,68)/255.0;\n   float a = -1.3;\n   if(beard!=0.0)\n   {\n      a=-1.21;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.321,sin(a)*(x)+cos(a)*(y)+0.617, 0.440, 0.45, 0.460, 0.4525);\n      col = col*(1.0-c) + beardcol*c;\n      a = -1.3;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.311,sin(a)*(x)+cos(a)*(y)+0.718, 0.440, 0.45, 0.460, 0.4525);\n      col = col*(1.0-c) + beardcol*c;\n      a=-1.5;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.241,sin(a)*(x)+cos(a)*(y)+0.888, 0.442, 0.45, 0.460, 0.451);\n      col = col*(1.0-c) + beardcol*c;\n      a=-1.8;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.081,sin(a)*(x)+cos(a)*(y)+1.088, 0.441, 0.45, 0.460, 0.452);\n      col = col*(1.0-c) + beardcol*c;\n      a=-1.79;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.081,sin(a)*(x)+cos(a)*(y)+1.088, 0.445, 0.45, 0.460, 0.4512);\n      col = col*(1.0-c) + beardcol*c;\n\n      a=-1.31;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.251,sin(a)*(x)+cos(a)*(y)+0.718, 0.446, 0.45, 0.460, 0.4515);\n      col = col*(1.0-c) + beardcol*c;\n      a=-1.51;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.181,sin(a)*(x)+cos(a)*(y)+0.888, 0.445, 0.45, 0.460, 0.452);\n      col = col*(1.0-c) + beardcol*c;\n      a=-1.79;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.081,sin(a)*(x)+cos(a)*(y)+1.088, 0.445, 0.45, 0.460, 0.451);\n      col = col*(1.0-c) + beardcol*c;\n      a=-1.69;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.086,sin(a)*(x)+cos(a)*(y)+1.01, 0.445, 0.45, 0.460, 0.4513);\n      col = col*(1.0-c) + beardcol*c;\n\n   }\n\n   if(rzesy!=0.0)\n   {\n      a = -1.1;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.455,sin(a)*(x)+cos(a)*(y)+0.542, 0.440, 0.45, 0.455, 0.4525);\n      col = col*(1.0-c) + black*c;\n      a = -1.51;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.351,sin(a)*(x)+cos(a)*(y)+0.8818, 0.440, 0.45, 0.455, 0.4525);\n      col = col*(1.0-c) + black*c;\n      a = -2.01;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.051,sin(a)*(x)+cos(a)*(y)+1.198, 0.440, 0.45, 0.455, 0.4525);\n      col = col*(1.0-c) + black*c;\n\n      a = -1.1;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.415,sin(a)*(x)+cos(a)*(y)+0.532, 0.440, 0.45, 0.455, 0.4525);\n      col = col*(1.0-c) + black*c;\n      a = -1.51;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.311,sin(a)*(x)+cos(a)*(y)+0.8818, 0.440, 0.45, 0.455, 0.4525);\n      col = col*(1.0-c) + black*c;\n      a = -2.01;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.008,sin(a)*(x)+cos(a)*(y)+1.20, 0.440, 0.45, 0.455, 0.4525);\n      col = col*(1.0-c) + black*c;\n\n      a = -1.1;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.455+0.012,sin(a)*(x)+cos(a)*(y)+0.542-0.05, 0.440, 0.45, 0.455, 0.4525);\n      col = col*(1.0-c) + black*c;\n      a = -1.51;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.351-0.003,sin(a)*(x)+cos(a)*(y)+0.8818-0.05, 0.440, 0.45, 0.455, 0.4525);\n      col = col*(1.0-c) + black*c;\n      a = -2.01;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.051-0.03,sin(a)*(x)+cos(a)*(y)+1.198-0.040, 0.440, 0.45, 0.455, 0.4525);\n      col = col*(1.0-c) + black*c;\n\n      a = -1.1;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.415+0.012,sin(a)*(x)+cos(a)*(y)+0.532-0.05, 0.440, 0.45, 0.455, 0.4525);\n      col = col*(1.0-c) + black*c;\n      a = -1.51;\n      c = rect((x)*cos(a)-sin(a)*(y)-0.311-0.003,sin(a)*(x)+cos(a)*(y)+0.8818-0.05, 0.440, 0.45, 0.455, 0.4525);\n      col = col*(1.0-c) + black*c;\n\n   }\n\n   return col;\n}\n\nvec3 body(float x, float y, vec3 col, vec3 pink, vec3 pinkp, vec3 pepadres, vec3 pepadresp, float male, float recerazem)\n{\n   float c;\n\n   float prz=0.14*recerazem+male*0.1-recerazem*male*0.14;\n   y=y+prz;\n   float a=-0.4;\n   c = rect((x)*cos(a)-sin(a)*(y)-0.18,sin(a)*(x)+cos(a)*(y)+0.19, 0.35, 0.53, 0.46, 0.54);\n   col = col*(1.0-c) + pink*c;\n   col = hand(x,y, col, pink);\n   y=y-prz;\n\n   // body\n   float circle12 = circle((x-0.5)*0.9,(y-0.4)/2.5,0.103);\n   if(y>0.39 || male!=0.0)\n   col = col*(1.0-circle12) + pepadresp*circle12;\n   float circle1 = circle((x-0.5)*0.9,(y-0.4)/2.5,0.1);\n   if(y>0.4 || male!=0.0)\n   col = col*(1.0-circle1) + pepadres*circle1;\n\n   if(recerazem==1.0)\n   {\n      x = 1.1-x;\n   }\n      y=y+prz;\n     \n   \n\n//   if(recerazem==0)\n//   {\n      //arm2\n      a=0.4;\n      c = rect((x)*cos(a)-sin(a)*(y)+0.02,sin(a)*(x)+cos(a)*(y)-0.19, 0.35, 0.53, 0.41, 0.54);\n      col = col*(1.0-c) + pink*c;\n      // hand 2\n      col = hand(1.0-x+0.0025,y+0.011, col, pink);\n      return col;\n//   }\n}\n\nvec3 legs(float x, float y, vec3 col, vec3 pink, vec3 black, vec3 gray, float poziom, vec3 kalosze, float full)\n{\n   float c;\n\n   //shadow\n   if(poziom==1.0)\n   {    \n   } \n   else\n   {\n      c = .8*circleplama((x-0.486)*0.8,(y-0.319)*3.5,0.1,10.0,0.004);\n      col = col*(1.0-c) + gray*c;\n   }\n\n   //leg1\n   c = rect(x,y, 0.55, 0.33, 0.56, 0.39);\n   col = col*(1.0-c) + pink*c;\n   //foot1\n   col = foot(x,y,col,kalosze);\n   if(full!=0.0) col = foot2(x,y,col,kalosze);\n   //leg2\n   c = rect(x,y, 0.45, 0.33, 0.46, 0.39);\n   col = col*(1.0-c) + pink*c;\n   //foot2\n   col = foot(x+0.1,y,col,kalosze);\n   if(full!=0.0) col = foot2(x+0.1,y,col,kalosze);\n\n   //shadow\n   if(poziom==1.0)\n   {\n      c = .8*circleplama((x-0.586)*1.2,(y-0.416)*0.5,0.1,6.0,0.004);\n      col = col*(1.0-c) + gray*c;     \n   } \n   else\n   {\n      c = .8*circleplama((x-0.486)*0.8,(y-0.316)*12.5,0.1,10.0,0.004);\n      col = col*(1.0-c) + gray*c;\n   }\n\n\n   return col;\n}\n\n\nvec3 mama(float x, float y, vec3 col, vec3 pink, vec3 pinkp, vec3 lips, vec3 black, vec3 white, vec3 pepadres, vec3 pepadresp, vec3 gray, vec3 kalosze, float rzesy)\n{\n   col = legs(x,y, col, pink, black, gray,0.0, kalosze,0.0);\n   col = body(x,y+0.04, col, pink, pinkp, pepadres, pepadres/1.14,0.0,0.0);\n   col = head(x,y+0.04, col, pink, pinkp, lips, black, white, 0.0,0.0,rzesy,0.0,0.0);\n\n   float c;\n   if(rzesy!=0.0)\n   for(float z=1.0; z>0.0; z-=0.1)\n   {\n      c = circleplama(x*6.4-3.07,y*6.4-2.95,0.24+(0.1*z),6.0,0.035);\n      col = pepadres*(0.9+z*0.12)*(c) + (col)*(1.0-c);\n   }\n   return col;\n\n}\n\nvec3 pepa(float x, float y, vec3 col, vec3 pink, vec3 pinkp, vec3 lips, vec3 black, vec3 white, vec3 pepadres, vec3 pepadresp, vec3 gray, vec3 kalosze)\n{\n   col = legs(x,y-0.04, col, pink, black, gray,0.0, kalosze,0.0);\n   col = body(x,y, col, pink, pinkp, pepadres, pepadres/1.14,0.0,0.0);\n   col = head(x,y, col, pink, pinkp, lips, black, white, 0.0,0.0,0.0,0.7,1.0);\n   // plama\n   float c = circleplama((x-0.56)*0.9,(y-0.459)*1.5,0.01,16.0,0.004);\n   col = col*(1.0-c) + pepadres*0.9*c;\n   return col;\n}\n\nvec3 george(float x, float y, vec3 col, vec3 pink, vec3 pinkp, vec3 lips, vec3 black, vec3 white, vec3 pepadres, vec3 pepadresp, vec3 gray, float mouth, vec3 kalosze)\n{\n   col = legs(x,y+0.08, col, pink, black, gray,0.0, kalosze,0.0);\n   col = body(x*0.96+0.02,y*1.8-0.36, col, pink, pinkp, pepadres, pepadres/1.14,1.0,0.0);\n   col = head(x*0.8+0.1,y*0.8+0.17, col, pink, pinkp, lips, black, white,0.0,0.0,0.0,mouth,2.0);\n   return col;\n}\n\nvec3 george2(float x, float y, vec3 col, vec3 pink, vec3 pinkp, vec3 lips, vec3 black, vec3 white, vec3 pepadres, vec3 pepadresp, vec3 gray, float mouth, vec3 kalosze)\n{\n   col = body(x*0.96+0.02,y*1.8-0.36, col, pink, pinkp, pepadres, pepadres/1.14,1.0,1.0);\n   col = legs(x,y+0.04, col, pink, black, gray,1.0, kalosze,1.0);\n   col = head(x*0.55+0.29,y*0.74+0.24, col, pink, pinkp, lips, black, white,0.0,0.0,0.0,mouth,3.0);\n   return col;\n}\n\n\nvec3 daddy(float x, float y, vec3 col, vec3 pink, vec3 pinkp, vec3 lips, vec3 black, vec3 white, vec3 pepadres, vec3 pepadresp, vec3 gray, vec3 kalosze, float glass, float poz)\n{\n\n   col = legs(x,y+0.08, col, pink, black, gray, poz, kalosze, 0.0);\n\n   col = body(x*(1.0-glass*0.2)+glass*0.1,y*(1.6-glass*0.2)-0.26+glass*0.04, col, pink, pinkp, pepadres, pepadres/1.14,1.0,1.0);\n   float xtemp=x-0.25;\n   float ytemp=y+0.25;\n   col = head(x*0.8+0.12,y*0.8+0.18, col, pink, pinkp, lips, black, white,glass,glass,0.0,1.0,4.0);\n   x=xtemp;\n   y=ytemp;\n\n\n   float c;\n   if(glass!=0.0)\n   for(float z=1.0; z>0.0; z-=0.1)\n   {\n      c = circleplama(x*6.4-1.87,y*6.4-3.95,0.24+(0.1*z),6.0,0.035);\n      col = pepadres*(0.9+z*0.12)*(c) + (col)*(1.0-c);\n      c = circleplama(x*6.4-1.1,y*6.4-4.10,0.10+(0.1*z),3.0,0.015);\n      col = pepadres*(0.9+z*0.12)*(c) + (col)*(1.0-c);\n   }\n   return col;\n}\n\n\n\nvec3 trawa(float x, float y, vec3 col)\n{\n   float c;\n   vec3 grass2 = vec3(84,163,84)/255.0;\n   c = rect(x+0.001*sin(11010.5*y),y, -0.001, -0.01, 0.006, 0.02+0.013*rand(x));\n   col = col*(1.0-c) + grass2*c;\n   c = rect(x+0.001*sin(10000.0*y)+0.01,y, -0.001, -0.01, 0.006, 0.01+0.012*rand(100.0*y));\n   col = col*(1.0-c) + grass2*c;\n   c = rect(x+0.002*sin(10000.0*y+0.03*rand(y))+0.02,y, -0.001, -0.01, 0.002+0.01*rand(x), 0.01+0.02*rand(y));\n   col = col*(1.0-c) + grass2*c;\n   return col;\n}\n\n\nvec3 kwiatek(float x, float y, vec3 col, vec3 srodek, vec3 white)\n{\n   vec3 lodyga = vec3(63,137,78)/255.0;\n \n   float c;\n   c = rect(x,y, -0.001, -0.01, 0.006, 0.03);\n   col = col*(1.0-c) + lodyga*c;\n   c = circle(x-0.002,y-0.02, 0.003);\n   col = col*(1.0-c) + srodek*c;\n   c = circle(x-0.002,y-0.03, 0.0045);\n   col = col*(1.0-c) + white*c;\n   c = circle(x-0.002,y-0.01, 0.0045);\n   col = col*(1.0-c) + white*c;\n   c = circle(x-0.008,y-0.02, 0.0045);\n   col = col*(1.0-c) + white*c;\n   c = circle(x+0.004,y-0.02, 0.0045);\n   col = col*(1.0-c) + white*c;\n   return col;\n\n}\n\nfloat mountainlev(float x)\n{\n   return 0.7-0.1*(sin(x*3.0+0.3));\n}\n\n\nvec3 pepa(float x, float y)\n{\n   vec3 white = vec3(1,1,1);\n   vec3 black = vec3(0,0,0);\n   vec3 gray = vec3(192.0/255.0,192.0/255.0,192.0/255.0);\n   vec3 pink = vec3(255.0,176.0,223.0)/255.0;\n   vec3 pinkp = vec3(242.0,136.0,183.0)/255.0;\n   vec3 lips = vec3(217.0,74.0,144.0)/255.0;\n   vec3 pepadres = vec3(235.0,85.0,94.0)/255.0;\n   vec3 pepadresp = vec3(220.0,46.0,54.0)/255.0;\n   vec3 mamadres = vec3(255,143,95)/255.0;\n   vec3 mamadresp = vec3(244,100,47)/255.0;\n   vec3 tatadres = vec3(110,177,183)/255.0;\n   vec3 tatadresp = tatadres/1.3;\n   vec3 georgedres = vec3(109,152,221)/255.0;\n   vec3 grass = vec3(120,199,110)/255.0;\n   vec3 sky = vec3(135,185,246)/255.0;\n   vec3 brown = vec3(124,118,82)/255.0;\n   vec3 bbrown = vec3(104, 101, 70)/255.0;\n   vec3 srodek = vec3(255,236,78)/255.0;\n   vec3 yellow = vec3(255,236,8)/255.0;\n   vec3 red = vec3(255,0,0)/255.0;\n   vec3 tecza1 = vec3(255,46,0)/255.0;\n   vec3 tecza2 = vec3(255,227,0)/255.0;\n   vec3 tecza3 = vec3(0,245,0)/255.0;\n   vec3 tecza4 = vec3(0,51,245)/255.0;\n   vec3 tecza5 = vec3(185,57,252)/255.0;\n\n\n   float c;\n   x = x*1.4-0.05;\n   y = y*1.4-0.02;\n\n//   x = x *(1.00+0.05*sin(x*5));\n//   y = y *(1.00+0.05*sin(y*4));\n\n   vec3 col;\n\n   // sky\n   float t = y;\n//   col = vec4(t*136.0/255.0+(1-t),t*186.0/255.0+(1-t),t*247.0/255.0+(1-t),1);\n\n\n   \n   if(y<mountainlev(x))\n   {\n      col = grass*(0.9+0.1*rand(x+y+x*y));\n      float h = abs(y-mountainlev(x));\n      float d = 0.015;\n      if( h < d)\n         col = (h/d)*grass*(0.9+0.1*rand(x+y+x*y))+(1.0-h/d)*sky;\n   }\n   else\n   {\n      col = sky;\n   }\n\n   col = kwiatek(x-0.1,y-0.05, col, srodek, white);\n   col = kwiatek(x-0.8,y-0.09, col, srodek, white);\n   col = kwiatek(x-1.3,y-0.59, col, srodek, srodek);\n   col = kwiatek(x-0.0,y-0.49, col, srodek, white);\n   col = kwiatek(x-0.3,y-0.09, col, srodek, srodek);\n   col = kwiatek(x-1.2,y-0.16, col, srodek, srodek);\n\n\n   col = trawa(x,y,col);\n   col = trawa(x-0.45,y-0.02,col);\n   col = trawa(x-1.16,y-0.65,col);\n   col = trawa(x-0.86,y-0.10,col);\n   col = trawa(x-1.26,y-0.05,col);\n\n\n   // sun\n   //c = circle(x-0.1,y-1.2,0.08);\n   //col = col*(1.0-c) + yellow*0.8*c;\n\n   // sun\n   c = circleflower(x-0.36,y-1.2,0.075)+circlegrad(x-0.36,y-1.2,0.06);\n   col = col*(1.0-c) + yellow*c;\n\n\n   // chmurka\n  \n\n   // chmurka\n\n   for(float g=0.0; g<20.0; g++)\n   {\n      c = .25*circleplama(x*0.3-0.03-0.04*rand(g),y*1.1-1.25-0.04*rand(g*g),0.025,10.0,0.002);\n      col = col*(1.0-c) + white*c;\n      c = .2*circleplama(x*0.6-0.23-0.04*rand(g),y*1.1-1.35-0.04*rand(g*g),0.025,10.0,0.002);\n      col = col*(1.0-c) + white*c;\n      c = .2*circleplama(x*0.08-0.03-0.04*rand(g),y*1.0-1.17-0.04*rand(g*g),0.025,10.0,0.002);\n      col = col*(1.0-c) + white*c;\n\n   }\n\n   for(float g=0.0; g<6.0; g++)\n   {\n      c = .2*circleplama(x*0.02-0.04-0.08*rand(g),y*0.1-0.04*rand(g*g),0.025,10.0,0.002);\n      col = col*(1.0-c) + grass*0.8*c;\n   }\n\n   // plama\n   c = circleplama(x*0.3-0.19,y*1.4-0.4,0.19,10.0,0.004);\n   col = col*(1.0-c) + brown*c;\n   c = .8*circleplama(x*0.3-0.19,y*1.4-0.4,0.193,10.0,0.004);\n   col = col*(1.0-c) + brown*c;\n\n   // jeziorko\n   c = circleplama(x*0.3-0.37,y*1.4-0.65,0.024,5.0,0.002);\n   col = col*(1.0-c) + sky*0.87*c;\n   c = .4*circleplama(x*0.3-0.37,y*1.4-0.65,0.029,5.0,0.002);\n   col = col*(1.0-c) + sky*0.87*c;\n\n   // tata\n   col = daddy(x*0.75-0.16,y*0.75+0.03, col, pink, pinkp, lips, black, white, tatadres, tatadresp, bbrown, grass*1.3, 1.0, 0.0);\n   float a=-0.2;\n\n   // mama\n   col = mama((1.0-x)*0.85-0.15,y*0.85+0.04, col, pink, pinkp, lips, black, white, mamadres, mamadresp, bbrown, red,1.0 );\n   // pepa\n// col = pepa(1.0-x*1.5+0.15,y*1.3, col, pink, pinkp, lips, black, white,pepadres, pepadresp, bbrown, yellow );  \n   col = mama(1.0-x*1.5+0.15,y*1.3, col, pink, pinkp, lips, black, white,pepadres, pepadresp, bbrown, yellow,0.0 );\n   // george\n //  col = george(x*2.4-1.9,y*2.3-0.278, col, pink*1.1, pinkp, lips, black, white,georgedres*0.825*(0.9+0.1*rand(x+y+x*y)), pepadresp, bbrown, 0.0, white );\n   col = daddy(x*2.4-1.9,y*2.3-0.278, col, pink*1.1, pinkp, lips, black, white,georgedres*0.825*(0.9+0.1*rand(x+y+x*y)), pepadresp, bbrown, grass*1.3, 0.0, 0.0);\n//   col = daddy(x*2.4-1.9,y*2.3-0.278, col, pink*1.1, pinkp, lips, black, white,georgedres*0.825*(0.9+0.1*rand(x+y+x*y)), pepadresp, bbrown, 0.0, white, 0.0, 1.0 );\n   // george2.\n\n   float xtemp=x-1.95;\n   float ytemp=y-1.5;\n   float a2=1.5;\n   x=xtemp*cos(a2)-ytemp*sin(a2)+0.0;\n   y=xtemp*sin(a2)+ytemp*cos(a2)+1.7;\n//   col = george2(x*3.1-3.1,y*3.1-0.38, col, pink, pinkp, lips, black, white, grass*1.5*(0.9+0.1*rand(x+y+x*y)), pepadresp, bbrown, 1.6, sky );\n   col = daddy(x*3.1-3.1,y*3.1-0.38, col, pink, pinkp, lips, black, white, grass*1.5*(0.9+0.1*rand(x+y+x*y)), pepadresp, bbrown, sky, 0.0, 1.0);\n   x=xtemp+1.95;\n   y=ytemp+1.5;\n\n\n   //pilka\n   float yy=-0.03*abs(sin(2.0*iTime));\n   c = 1.0-circle(x*0.9-1.09+yy,y*1.9-0.255,0.06);\n   col = col*(c) + (0.8*grass)*(1.0-c);\n\n   c = 1.0-circle(x-1.25+0.06,y-0.175+yy,0.06);\n   col = col*(c) + ((0.9+0.1*rand(x))*yellow)*(1.0-c);\n\n\n   for(float i=1.0; i<3.0; i++)\n   {\n      c = circleplama(x*12.4*(0.95+0.05*rand(i))-3.9-0.5*i-3.0*(rand(i*i*i))*(y-(y*5.3-1.6))/i+rand(i)*0.4,y*5.3-1.4-rand(i)*1.2,0.1+0.15*rand(i*i*i),4.0,0.01);\n      col = bbrown*0.9*(c) + (col)*(1.0-c);\n   }\n\n   for(float i=1.0; i<3.0; i++)\n   {\n      c = circleplama(x*12.4*(0.95+0.03*rand(i))-5.4-0.3*i+3.0*(rand(i*i))*(y-(y*5.3-1.6))/i+rand(i)*0.4,y*7.3-1.8-rand(i)*1.3,0.05+0.25*rand(i*i*i)/i,4.0,0.01);\n      col = bbrown*0.9*(c) + (col)*(1.0-c);\n   }\n\n\n     // post process\n\n   // cien\n   c = 0.6+0.45*circledistin(x-0.55,y-0.815,0.968);\n   col = col*(c) + (black)*(1.0-c);\n\n\n   // krople\n   col = kropla(0.82-y*1.0,x*0.53*(0.6+0.6*sin(y)),col,bbrown*0.9);\n   col = kropla(0.742-y*0.6,x*0.45*(0.9-0.2*sin(y)),col,bbrown*0.9);\n   col = kropla(1.092-y*1.8,x*0.43*(1.9-0.2*sin(y))-0.26,col,bbrown*0.9);\n   col = kropla(1.51-y*1.98,x*0.73*(0.6+0.3*sin(5.0*y))+0.15,col,bbrown*0.9);\n   col = kropla(0.78-y*0.6,x*0.73*(0.9+0.3*sin(-10.1*y))+0.23,col,bbrown*0.9);\n   col = kropla(0.78-y*0.6,-0.04+x*0.73*(0.9+0.3*sin(-15.1*y))+0.23,col,bbrown*0.9);\n   col = kropla(1.41-y*1.98,x*0.73*(0.9+0.3*sin(5.0*y))+0.25,col,bbrown*0.9);\n\n   return col;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = (fragCoord.xy/iResolution.xy);\n   vec3 col = pepa(p.x, p.y);\n   fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdcDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 60, 60, 131], [132, 132, 153, 153, 201], [202, 202, 243, 243, 315], [316, 316, 361, 361, 395], [396, 396, 443, 443, 523], [525, 525, 570, 570, 668], [669, 669, 716, 716, 911], [913, 913, 977, 977, 1113], [1116, 1116, 1184, 1184, 1266], [1268, 1268, 1318, 1318, 1768], [1769, 1769, 1821, 1821, 2057], [2058, 2058, 2109, 2109, 2316], [2319, 2319, 2372, 2372, 2561], [2564, 2564, 2724, 2724, 10134], [10136, 10136, 10258, 10258, 11155], [11157, 11157, 11270, 11270, 12099], [12102, 12102, 12268, 12268, 12709], [12711, 12711, 12864, 12864, 13218], [13220, 13220, 13388, 13388, 13658], [13660, 13660, 13829, 13829, 14102], [14105, 14105, 14283, 14283, 14993], [14997, 14997, 15037, 15037, 15489], [15492, 15492, 15559, 15559, 16065], [16067, 16067, 16095, 16095, 16133], [16136, 16136, 16165, 16165, 22378], [22381, 22381, 22438, 22438, 22543]]}
{"id": "3sdcWH", "name": "Basic : Random Rectangle Tiling", "author": "Gijs", "description": "Randomized rectangle tiling. Inspired by https://www.shadertoy.com/view/Ws3GRs but the implementation is different. This picture should explain the method https://imgur.com/fSn38WM .", "tags": ["random", "rectangle", "tiling"], "likes": 8, "viewed": 109, "published": "Public", "date": "1601226706", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const bool SHOW_GRID = false;\n\n\n//hash in [0,1]\nfloat hash(vec2 p){\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n//returns the min- and max-corners of the rectangle of the crossing 'c'\nvec4 crossingToRectangle(vec2 c){\n    vec4 d = vec4(\n        hash(c + vec2(-1,-1)), \n        hash(c + vec2( 0,-1)), \n        hash(c + vec2( 0, 0)), \n    \thash(c + vec2(-1, 0))\n    );\n\n    // orientation of this crossing\n    int o = int(c.x+c.y) & 1;\n    if(o==1) d = d.wxyz;\n    \n    return d + vec4(c-1.,c);\n}\n\n//find the crossing of the rectangle in which the point 'p' lays\nvec2 getCrossing(vec2 p){\n    \n    // the cell coordinate corresponding to p\n    vec2 i = floor(p);\n    \n    // the coordinates of p relative to its cell\n    vec2 f = p - i;\n    \n    // this variable will tell us the coordinate of the crossing relative to the cell coordinate\n    vec2 c = vec2(0);\n    \n    // orientation of this cell\n    int o = int(i.x+i.y) & 1;\n    // if o=0 then u=1 and vice versa\n    int u = o ^ 1;\n    // on which side of the line in this cell is the current point 'p'\n    bool s = f[o]>hash(i);\n\n    // magic\n    if(s) c[o] = 1.;\n    vec2 n = i;\n    n[o] += s ? 1. : -1.;\n    if(f[u]>hash(n)) c[u] = 1.;\n  \n    return i+c;\n}\n\n//gets the rectangle in which the point 'p' lays\nvec4 getRectangle(vec2 p){\n    return crossingToRectangle(getCrossing(p));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord*.02 + iTime*0.5;\n    \n    vec4 r = getRectangle(p);\n    vec2 mi = r.xy; //min corner\n    vec2 ma = r.zw; //max corner\n    \n    float dmi = min(abs(p-mi).x,abs(p-mi).y); //distance to min corner\n    float dma = min(abs(p-ma).x,abs(p-ma).y); //distance to max corner\n    float d = min(dmi, dma);\n    fragColor = vec4(smoothstep(0.04, 0.02, d));\n         \n    if(SHOW_GRID){\n    \tvec2 f = fract(p);\n        float d = min(f.x, f.y);\n        fragColor = mix(\n            fragColor,\n            vec4(1,0,0, 1),\n            smoothstep(0.04, 0.03, d)\n        );\n    }\n \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdcWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 48, 67, 67, 162], [164, 236, 269, 269, 546], [548, 613, 638, 689, 1262], [1264, 1313, 1339, 1339, 1389], [1392, 1392, 1449, 1449, 2036]]}
{"id": "3sdyDn", "name": "A simple sinusoid", "author": "tangzhihui", "description": "A simple sinusoid", "tags": ["sin", "curve", "sinusoid"], "likes": 0, "viewed": 25, "published": "Public", "date": "1600757034", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926;\n\n//y = A*sin(omega*x + phi) + B\nfloat generalSin(float x, float A, float omega, float phi, float B);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float lineWidth = 15.0f;\n    vec4 lineColor = vec4(0.0f, 1.0f, 1.0f, 1.0f);\n    vec4 bgColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n   \tfloat sinValue = generalSin(fragCoord.x, iResolution.y * 0.2f, 2.0f * 2.0f * PI / iResolution.x, iTime, iResolution.y * 0.5f);\n    \n    smoothstep(0.0f, 1.0f, 0.5f);\n    float t = smoothstep(0.0f, lineWidth * 0.5f, abs(fragCoord.y - sinValue));\n    fragColor = lineColor * (1.0f - t) + t * bgColor;\n\t\n}\n\nfloat generalSin(float x, float A, float omega, float phi, float B)\n{\n    return A * sin(omega * x + phi) + B;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdyDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 130, 187, 187, 623], [625, 625, 694, 694, 737]]}
{"id": "3sdyR4", "name": "2D ambient occlusion", "author": "Pidhorskyi", "description": "The scene is raymarched in 3D, however, ambient occlusion is computed using raymarching in 2D space. This trick is possible due to the specifics of the scene and allows less noisy result with few rays traced. ", "tags": ["occlusion"], "likes": 14, "viewed": 335, "published": "Public API", "date": "1600670786", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Stanislav Pidhorskyi - 2020 */\n\n#define PI 3.14159265359\n\n\n#define P2 0.0001 // precision\n#define P3 0.0001 // precision\n#define S 80.    // steps\n#define D 100.  // distance\n#define PI 3.14159265359\n\n#define N_RAYS 24.\n\nfloat sqr(float x) {return x * x; } \n\n//https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 gamma(vec3 x) {\n    return mix(12.92 * x, 1.055 * pow(x, vec3(1.0 / 2.4)) - 0.055, step(0.0031308, x));\n}\n\n// SDF functions from iq: https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map2(vec2 p)\n{\n    p.x = abs(p.x);\n    \n \tfloat d = sdBox(p, vec2(0.3, 0.4));\n    d = max(d, -sdBox(p + vec2(-0.15, 0.0), vec2(0.1, 0.1)));\n    d = max(d, -sdBox(p + vec2(-0.15, -0.4), vec2(0.1, 0.1)));\n    d = max(d, -sdBox(p + vec2(-0.15, 0.4), vec2(0.1, 0.1)));\n    d = min(d, sdCircle(p + vec2(-0.8, 0.5), 0.2));\n    d = min(d, sdCircle(p + vec2(-0.8, 0.2), 0.1));\n    d = min(d, sdCircle(p + vec2(-0.8, 0.0), 0.03));\n    d = min(d, sdCircle(p + vec2(-0.8, -0.2), 0.01));\n    d = min(d, sdTriangleIsosceles(-(p + vec2(-1.2, -0.0)), vec2(0.1, 0.3)));\n    return d;\n}\n\nfloat map3(vec3 p, float h)\n{\n \tfloat d = map2(p.xz);\n    d = max(d, sdBox(p + vec3(0., -h / 2., 0.), vec3(2., h / 2., 2.)));\n    d = min(d, sdBox(p + vec3(0., 0.1, 0.), vec3(2., 0.1, 2.)));\n    return d;\n}\n\nvec4 march(vec3 ro, vec3 rd, float h)\n{\n    float t = 0., s = float(S), d;\n    for(float i = 0.; i < S; i++)\n    {\n        d = map3(ro+rd*t, h);\n\n        if (d < P3 * t || t > D)\n        {\n            s = float(i);\n            break;\n        }\n\n        t += d;\n    }\n    \n    return vec4(ro+rd*t, t);\n}\n\nvec4 march(vec2 ro, vec2 rd)\n{\n    float t = 0., s = float(S), d;\n    for(float i = 0.; i < S; i++)\n    {\n        d = map2(ro+rd*t);\n\n        if (d < P2 * t || t > D)\n        {\n            s = float(i);\n            break;\n        }\n\n        t += d;\n    }\n    \n    return vec4(ro+rd*t,d,t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n    if (iMouse.xy == vec2(0.))\n    {\n        mo = vec2(0.3, 0.5);\n    }\n    const vec3 lookat = vec3(0.0, 0.2, 0.0);\n    \n    float theta = 6.283*(0.25 * mo.y - 0.25);\n    vec3 ro = vec3(cos(6.283*mo.x) * sin(theta),\n                   cos(theta),\n                   sin(6.283*mo.x) * sin(theta));\n  \tro *= 4.0;\n    \n   \tfloat aspect = float(iResolution.x) / float(iResolution.y);\n    float vfov = 20.0f;\n    \n    float th = vfov * PI / 180.0;\n    float halfHeight = tan(th / 2.0);\n    float halfWidth = aspect * halfHeight;\n\tvec3 vup = vec3(0.0f, 1.0f, 0.0f);\n    \n    vec3 z = normalize(ro - lookat);\n    vec3 x = normalize(cross(vup, z));\n    vec3 y = normalize(cross(z, x));\n    \n    mat3 cam = mat3(x, y, z);\n    mat3 k = mat3(vec3(1.0 / halfWidth, 0, 0), vec3(0, 1.0 / halfHeight, 0), vec3(0.0, 0.0, -1.));\n    \n    vec2 uv = fragCoord / vec2(iResolution);\n    uv = 2.0 * uv - 1.0;\n\n    vec3 rd = cam * (normalize(inverse(k) * vec3(uv, 1.0)));\n\n    \n    float h = sqr((0.5 + 0.5 * cos(3.14 * iTime * 0.2))) * 0.6;\n    \n    vec4 res = march(ro, rd, h);\n    if (res.w > 10.0)\n    {\n    \tfragColor = vec4(gamma(vec3(0.6)),1.0);\n        return;\n    }\n    \n    h -= max(res.y, 0.);\n    \n    float d = map2(res.xz);\n    vec3 color;\n    if (d < -0.1 * P2)\n    \tcolor = vec3(1.);\n    else\n    {\n                float f = 0.;\n                vec2 rd = normalize(hash22(fragCoord + iTime * 1500. + 50.0) * 2.0 - 1.0); \n                for (float dir = 0.; dir < N_RAYS; ++dir)\n                {\n                    rd = mat2( cos(2. / N_RAYS * 3.14), sin(2. / N_RAYS * 3.14),\n                              -sin(2. / N_RAYS * 3.14), cos(2. / N_RAYS * 3.14)) * rd;\n                    vec4 r = march(res.xz, rd);\n                    \n                    float alpha = atan(h / r.w);\n                    // https://www.wolframalpha.com/input/?i=integrate+x+*+cos%28x%29+*+sin%28x%29+from+a+to+pi+%2F+2\n                    float I = 1./8. * (-sin(2. * alpha) + 2. * alpha * cos(2. * alpha) + PI);\n                    \n                    f += I;\n                }\n                f /= N_RAYS * PI / 8.;\n                color = vec3(f * 1.);\n\n\t}\n    \n    // Output to screen\n    fragColor = vec4(gamma(color * 0.6),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdyR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 224, 244, 244, 259], [262, 302, 323, 323, 457], [459, 459, 479, 479, 569], [571, 673, 710, 710, 790], [791, 791, 826, 826, 854], [855, 855, 906, 906, 1214], [1215, 1215, 1246, 1246, 1333], [1335, 1335, 1355, 1355, 1910], [1912, 1912, 1941, 1941, 2118], [2120, 2120, 2159, 2159, 2422], [2424, 2424, 2454, 2454, 2715], [2718, 2718, 2775, 2775, 5029]]}
{"id": "3sdyz4", "name": "fast 1D calm ripples, waves", "author": "arifd", "description": "Simple fluid shader.\n\nCan be used to fill in 2D containers of fluid.\n\nAny tips or tweaks welcome!", "tags": ["waves", "ripples", "sea", "water", "fluid", "1d", "liquid"], "likes": 2, "viewed": 164, "published": "Public", "date": "1600530787", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define WAVE_SIZE 0.025\n\n//////////////////////////////////////\n// GENERATE THE SURFACE\n/////////////////////////////////////\n\nfloat surface(vec2 uv) {\n    // ripples\n    float r1 = sin(uv.x * 9.2134 + iTime);\n    float r2 = sin(uv.x * .63457 * r1 - r1 - iTime);\n    \n    // return 0 or 1 depending on above/below crest\n    //return 1. - step(1. - WAVE_SIZE + (r2 * WAVE_SIZE), uv.y);\n\t\n    // with anti-aliasing\n    return smoothstep(1., .992, uv.y + (r2 * WAVE_SIZE) + WAVE_SIZE - .008);\n}\n\n//////////////////////////////////////\n//////////////////////////////////////\n\n///////////////////////////////\n// GENERATE THE WATER TEXTURE\n///////////////////////////////\n\nvec3 water(vec2 uv) {\n    // blue gradient\n    return vec3(.1, uv.y * (uv.y * .9), uv.y * (-uv.y + 2.5));\n}\n\n///////////////////////////////////////\n///////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // the idea here is to draw water texture everywhere,\n    // then trim away above the waves/crest by multiplying with 0;\n    fragColor = vec4(water(uv), 1.) * surface(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdyz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 127, 151, 166, 491], [572, 667, 688, 709, 774], [776, 857, 914, 964, 1183]]}
{"id": "3stcDr", "name": "Kaufmann Vortex", "author": "athibaul", "description": "The trajectory of each point of a Kaufmann vortex can be integrated back to initial time, allowing to trace the trajectory of each given point. ", "tags": ["antialiasing", "vortex", "analytic", "integration"], "likes": 3, "viewed": 116, "published": "Public", "date": "1600761606", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU (2.0*3.1415926535)\n\n// Kaufmann vortex\n// https://en.wikipedia.org/wiki/Kaufmann_(Scully)_vortex\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n\n    vec3 col;\n    \n    // Velocity profile in the vortex is assumed to be:\n    //           v_theta = r / (r0^2 + r^2)\n    \n    // Compute the initial position of the particle currently at (x,y)\n    // by integrating back to initial time.\n    float r0 = 0.8;\n    float r = length(uv);\n    float th = atan(uv.y, uv.x);\n    \n    float r_i = r;\n\tfloat th_i = th - iTime/(r0*r0 + r*r);\n    vec2 uv_i = r_i * cos(th_i + vec2(0,TAU/4.));\n    \n    // Also compute a Lipschitz bound on the deformation,\n    // for antialiasing\n    float dr = 1.0;\n    float dth = 1.0/r;\n    float dr_i = dr;\n    float dth_i = dth + 2.*iTime*r/pow(r0*r0+r*r, 2.0);\n    float duv_i = r_i*dth_i + dr_i;\n    \n   \tcol = texture(iChannel0, uv_i*0.5).rgb;\n    // Draw the deformation of lines\n    \n    {\n        float scale = 0.2;\n        float y0 = scale * (floor(uv_i.y/scale) + 0.5);\n        float f = abs(uv_i.y - y0);\n        col = mix(col, 0.5+0.5*sin(0.5*TAU*(y0+vec3(0.,0.4,0.5))),\n                  smoothstep(duv_i*length(fwidth(uv)), 0.0, f));   \n    }\n    {\n        float scale = 0.2;\n        float x0 = scale * (floor(uv_i.x/scale) + 0.5);\n        float f = abs(uv_i.x - x0);\n        col = mix(col, 0.5+0.5*sin(0.5*TAU*(x0+vec3(0.4,0.4,0.8))),\n                  smoothstep(duv_i*length(fwidth(uv)), 0.0, f));   \n    }\n    \n    //col = vec3(uv_i, 0);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stcDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 110, 167, 167, 1601]]}
{"id": "3stcRf", "name": "Day 45 - Trying hue2rgb out.", "author": "illus0r", "description": "Day 45 of #raymarching challenge. Trying hue2rgb out.\nhttps://twitter.com/i_dianov/status/1311062793093812224", "tags": ["raymarching"], "likes": 3, "viewed": 207, "published": "Public API", "date": "1601417266", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define EPSILON 0.001\n#define PI 3.14159265\n#define COL1 1.\n#define COL2 2.\n#define COL3 3.\n\nfloat rnd(float x) {return 2.*fract(54321.987 * sin(987.12345 * x))-1.;}\nvec4 textureCubeZ(sampler2D tex, vec3 p) {\n  float absX = abs(p.x);\n  float absY = abs(p.y);\n  float absZ = abs(p.z);\n\n  int isXPositive = p.x > 0. ? 1 : 0;\n  int isYPositive = p.y > 0. ? 1 : 0;\n  int isZPositive = p.z > 0. ? 1 : 0;\n\n  float maxAxis, uc, vc;\n  vec2 crop;\n\n  // POSITIVE X\n  if (isXPositive!=0 && absX >= absY && absX >= absZ) {\n    maxAxis = absX;\n    uc = -p.z;\n    vc = p.y;\n    crop=vec2(2,1);\n  }\n  // NEGATIVE X\n  if (isXPositive==0 && absX >= absY && absX >= absZ) {\n    maxAxis = absX;\n    uc = p.z;\n    vc = p.y;\n    crop=vec2(0,1);\n  }\n  // NEGATIVE Y\n  if (isYPositive!=0 && absY >= absX && absY >= absZ) {\n    maxAxis = absY;\n    uc = p.x;\n    vc = -p.z;\n    crop=vec2(1,2);\n  }\n  // POSITIVE Y\n  if (isYPositive==0 && absY >= absX && absY >= absZ) {\n    maxAxis = absY;\n    uc = p.x;\n    vc = p.z;\n    crop=vec2(1,0);\n  }\n  // POSITIVE Z\n  if (isZPositive!=0 && absZ >= absX && absZ >= absY) {\n    maxAxis = absZ;\n    uc = p.x;\n    vc = p.y;\n    crop=vec2(1,1);\n  }\n  // NEGATIVE Z\n  if (isZPositive==0 && absZ >= absX && absZ >= absY) {\n    maxAxis = absZ;\n    uc = -p.x;\n    vc = p.y;\n    crop=vec2(3,1);\n  }\n\n  // Convert range from -1 to 1 to 0 to 1\n  vec2 uv = 0.5 * (vec2(uc,vc) / maxAxis + 1.0);\n\n  uv+=crop;\n  uv/=vec2(4,3);\n\n  return texture(tex, uv);\n}\n\nfloat hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n    else\n        res = f1;\n    return res;\n}\n\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb;\n\n    if (hsl.y == 0.0) {\n        rgb = vec3(hsl.z); // Luminance\n    } else {\n        float f2;\n\n        if (hsl.z < 0.5)\n            f2 = hsl.z * (1.0 + hsl.y);\n        else\n            f2 = hsl.z + hsl.y - hsl.y * hsl.z;\n\n        float f1 = 2.0 * hsl.z - f2;\n\n        rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n        rgb.g = hue2rgb(f1, f2, hsl.x);\n        rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n    }\n    return rgb;\n}\n\nmat2 rot(float a) {float s = sin(a), c = cos(a);return mat2(c, -s, s, c);}\nfloat sdBox( vec3 p, vec3 b ){  vec3 q = abs(p) - b;  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);}\nfloat opSmoothUnion( float d1, float d2, float k ) {    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat opSmoothSubtraction( float d1, float d2, float k ) {    float h = clamp( 0.5 - 0.5*(d1+d2)/k, 0.0, 1.0 );    return mix( d1, -d2, h ) + k*h*(1.0-h); }\nfloat fsnoiseDigits(vec2 c){return fract(sin(dot(c, vec2(0.129898, 0.78233))) * 437.585453);}\nfloat fsnoise(vec2 c){return fract(sin(dot(c, vec2(12.9898, 78.233))) * 43758.5453);}\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat snoise(vec2 v) {\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        0.366025403784439,\n                        -0.577350269189626,\n                        0.024390243902439);\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 n) {\n  //https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\n\n// \n\nvec2 getDist(vec3 p) {\n  p.xy *= rot(PI/8.);\n  p.xz *= rot(iTime);\n  p.x*=-1.;\n\n  float obj = (length(p)-.5);\n  return vec2(obj,1);\n}\n\n// \n\n\n\n\n\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = 0.;\n    int ii=0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      ii=i;\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        d += abs(distToClosest.x);\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec3(d, info, ii);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n);\n}\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 p, color,rd,rm,n,ro;\n    ro=vec3(0,0.*sin(iTime),-2);\n    // ro.zy*=rot(iMouse.y*10.);\n    ro.xz*=rot(iMouse.x*10.);\n    float d, info, dtotal=0.;\n    rd = getRayDir(uv, ro, vec3(0), 1.);\n\n    rm = rayMarch(ro, rd);\n    d = rm[0];\n    info = rm[1];\n    float steps = rm[2];\n\n    if (d < MAX_DIST) {\n\n      n = getNormal(ro+rd*d).yzx;\n      vec3 amp = vec3(0.2);\n      n.x+=amp.x*snoise(n.yz*2.+iTime);\n      n.y+=amp.y*snoise(n.xz*2.+iTime);\n      n.z+=amp.z*snoise(n.xy*2.+iTime);\n      n.xy *= rot(iTime*2.);\n      n.xz *= rot(iTime*3.);\n      color = hsl2rgb(-n*.5+.5);\n      color *=  smoothstep(2.,1.5,d);\n    }\n    else {\n      color = vec3(step(.9,snoise(rd.xy*100.)));\n    }\n    fragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stcRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 157, 157, 209], [210, 210, 252, 252, 1501], [1503, 1503, 1549, 1549, 1901], [1903, 1903, 1927, 1927, 2371], [2373, 2373, 2392, 2392, 2447], [2448, 2448, 2478, 2478, 2562], [2563, 2563, 2615, 2615, 2712], [2713, 2713, 2771, 2771, 2869], [2870, 2870, 2898, 2898, 2963], [2964, 2964, 2986, 2986, 3049], [3050, 3050, 3073, 3073, 3109], [3110, 3135, 3156, 3156, 3203], [3204, 3204, 3225, 3225, 3272], [3273, 3273, 3295, 3295, 3330], [3331, 3331, 3353, 3405, 4926], [4927, 4927, 4947, 4947, 5013], [5014, 5014, 5035, 5105, 5303], [5306, 5386, 5408, 5408, 5519], [5521, 5608, 5641, 5641, 5985], [5987, 5987, 6011, 6011, 6229], [6231, 6231, 6285, 6285, 6512], [6514, 6514, 6564, 6564, 6755], [6758, 6758, 6814, 6814, 7598]]}
{"id": "3stcz4", "name": "varied area tiles ", "author": "danhel95", "description": "attempt  to make Shane 's  tiles without loops and conditions!", "tags": ["grid", "tutorial", "tiles"], "likes": 6, "viewed": 134, "published": "Public", "date": "1600535008", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// learning tutorial 8\n// tried to make Shane's tiles without loops and if conditions !\n// seems to work\n\n\n// Fabrice version :) shorter !\n\n#define rand21(p)       fract( sin( dot( p, vec2(27.609, 57.583) ) ) * 43758.5453 )\n#define randCol(i)    ( .5 + .5*cos( 6.28 * rand21( (i)*.1 ) + vec3(0, 1, 2)*1.6 ) )\n#define box(p,c,b,f)  ( length( max( abs(p-(c)) - b + f , 0. ) ) - (f) )\n#define S(v)            smoothstep(sf, .0, v)\n#define rCol(p)       ( (0.5 + 0.5 * cos((p.x*p.y) * 6.2831 + vec3(0.0, 1.0, 2.0) )*clamp(1.0 - 0.2 * length(p), 0.0, 1.0) ) )\n#define SCALE  2.\n\nvoid mainImage(out vec4 F, vec2 C) {\n    vec2 R = iResolution.xy,\n         p = SCALE* ( ( C - .5*R ) / R.y + vec2( sin(iTime*.1 ) , 0 ) ),\n        ip = floor(p);\n         p -= ip ;\n\n    float r0 = rand21(ip + 1. )*.5 + .25   ;\n\n    vec2  b = step( r0, p ),\n          S = r0 * b ,\n          B = mix(b ,1.-b, r0 );\n\n    float  d = box( p , S + B/2., B/2., .05*sqrt( min(B.x, B.y) ) ),\n          sf = SCALE/500.;\n    vec2 id = ip + S + B/2. ;\n      vec2 aa = id - exp(-d*d * 50.0);\n    vec3 pCol = rCol( aa ) ;\n    pCol = mix(pCol, pCol.xzy, .2);\n\n    vec3 col = mix(vec3(1), pCol, S( d + SCALE/250.) );\n\n    d = length( abs(p - S - B/2.) - B/2. + .1/SCALE ) - .02/SCALE;\n    col =   mix(col, pCol*.4, S(d) )\n          *( r0*.02 + .8 );\n  float g = .1;\n  col = pow( col + g*g + g*vec3(.2,.5,.4)  , vec3(2.5) );\n\n    F.rgb = pow( col, vec3(1./2.2) );\n}\n\n// original\n\n// #define R iResolution\n\n// float rand21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// vec3 randCol(vec2 id) {\n//     float rnd = rand21(id *.1);\n//     return .3 + .5*cos(6.2831853*rnd + vec3(0, 1, 2)*1.6);\n\n// }\n\n\n// float box(in vec2 p,vec2 c, in vec2 b, in float sf){\n\n//   return length(max(abs(p-c) - b + sf, 0.)) - sf;\n// }\n\n// #define SCALE 2.\n// //or vec2\n// #define SCALE2 vec2(2.,3)\n\n\n// vec4 tiles(in vec2 q){\n//     vec2 p = q * SCALE; // q * SCALE2\n//     vec2 ip = floor(p);\n//     p -= ip ;\n//     vec2 B = vec2(1., 1.);\n//     vec2 S = vec2(0.);\n//     float r0 =  rand21(ip + B )*.5 + .25   ;\n\n//     vec2 b =   step(S + B*r0, p)  ; // or smoothstep( .0 , .00001, p - S - B*r0  )\n//     vec2 r0v = vec2(r0,r0);\n//     S  = r0v * B * b ;\n//     //B  *=  ( 1.- r0v )* b + r0v * (1.- b)  ;\n//     // or simplified\n//     B  *=  mix(r0v ,1.- r0v  ,  b ) ;\n\n//     float rf = min(B.x, B.y);\n//     float d = box(p , S + B/2., B/2., .05*sqrt(rf));\n//     float sf = 1./450.*SCALE;\n//     vec2 id = ip + S + B/2. ;\n\n//     vec3 pCol = randCol(id) ;\n//     pCol = mix(pCol, pCol.xzy, .2);\n\n//     // Rectangular cell border and coloring.\n//     vec3 col = vec3(1.) ;\n//     col = mix(col, pCol, smoothstep(sf, .0, d + .004*SCALE));\n\n//     // Splitting space to produce four rivot-looking dots.\n//     p = abs(p - S - B/2.) - B/2. + .1/SCALE;\n//     float d2 = length(p) - .02/SCALE;\n//     col = mix(col, vec3(pCol*.4), 1. - smoothstep(0., sf, d2)); // Rounded pavers.\n\n\n//     // Return the color and the bump value.\n//     return vec4(col, r0);\n\n// }\n\n// vec3 render(vec2 p) {\n\n//     p.x += sin(iTime*.05 );\n//     //p.x += sin(iTime*.1 + p.y); // curved\n//     vec4 bxD = tiles(p);\n//     vec4 bxD2 = tiles(p.xy - normalize(vec2(.2,5.))*.002);\n//     float b = max(bxD2.w - bxD.w, 0.)/.002;\n//     vec3 col = bxD.xyz*(b*.02 + .8);\n//     return col;\n\n\n\n\n// }\n\n// void mainImage(out vec4 F, in vec2 C) {\n//     vec2 O = (C.xy-.5*R.xy)/R.y;\n//     vec3 col = render(O) ;\n//     col = pow(col, vec3(1. / 2.2));\n//     F = vec4(col,1.);\n// }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stcz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 574, 610, 610, 1422]]}
{"id": "3stczB", "name": "circle blur", "author": "lck898989", "description": "smoothstep circle blur", "tags": ["smoothstep"], "likes": 1, "viewed": 74, "published": "Public", "date": "1601199861", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 uv,float radius) {\n    float c;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float dis = length(uv);\n    float blurDis = 0.2 * sin(4. * uv.x + iTime);\n    c = smoothstep(radius,radius - blurDis,dis);\n    return c;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    float radius = 0.3;\n    \n    float r = 1.;\n    float g = 1.;\n    float b = 1.;\n    \n    float c = circle(uv,radius);\n    \n    \n    // Output to screen\n    fragColor = vec4(vec3(c),1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stczB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 260], [261, 261, 318, 368, 609]]}
{"id": "3styz8", "name": "mix color simplified", "author": "vamoss", "description": "color mixer\n\noriginal work from mxm\nhttps://www.shadertoy.com/view/llVBzt", "tags": ["noise", "mix", "fluid", "color", "simplex", "tornado", "warper"], "likes": 5, "viewed": 131, "published": "Public", "date": "1600377256", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//original work from mxm\n//https://www.shadertoy.com/view/llVBzt\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  // Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  //Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p1 = vec2(0.6, 0.0);\n    vec4 p1Color = vec4(1.0, 0., 0., 1.);\n    \n    vec2 p2 = vec2(1.0, 1.0);\n    vec4 p2Color = vec4(0., 0., 0.7, 1.);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    uv*=0.6;\n    uv+=0.5;\n    \n\tfloat noiseLevel = 4.0;\n    uv.x += (snoise(vec3(uv.x*noiseLevel,uv.y*noiseLevel,iTime/10.))+1.)/2./2.;\n    uv.y += (snoise(vec3(uv.x*noiseLevel,uv.y*noiseLevel,iTime/10.+1234.))+1.)/2./2.;\n    uv = clamp(uv, vec2(0.0), vec2(1.0));\n    \n    vec3 mixColor = (\n        \t\t\t\tclamp((distance(uv, p1)), 0.0, 1.0)*p1Color.rgb + \n                     \tclamp((distance(uv, p2)), 0.0, 1.0)*p2Color.rgb\n                    ); \n        \t\t\t//2.;\n    \n    //fragColor = vec4(uv.x, uv.y, 0.0, 1.0);\n    fragColor = vec4(mixColor,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3styz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 66, 88, 88, 133], [134, 134, 154, 154, 199], [200, 200, 218, 218, 257], [259, 259, 279, 279, 770], [772, 1222, 1243, 1243, 1292], [1294, 1294, 1316, 1316, 1356], [1358, 1358, 1386, 1386, 1438], [1440, 1440, 1464, 1464, 3382], [3384, 3384, 3441, 3441, 4262]]}
{"id": "3styzn", "name": "Variegated Tiling", "author": "fizzer", "description": "A simple way to create a tiling with varying cell sizes.", "tags": ["tiling", "bricks"], "likes": 29, "viewed": 269, "published": "Public", "date": "1600286097", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 c)\n{\n    return mix(.2, .7, texelFetch(iChannel0, ivec2(c) & 255, 0).r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y * 10.;\n    \n    uv.x += iTime / 2.;\n    uv.y -= iMouse.y / iResolution.y * 10.;\n\n    vec2 f = fract(uv);\n    vec2 c = floor(uv);\n    \n    vec2 texCoord = f;\n    vec2 tileCoord = c;\n    \n    float r0 = rand(floor(uv));\n    \n    int orientation = (int(c.x) + int(c.y)) & 1;\n    \n    if(f[orientation] > r0)\n        tileCoord[orientation] += 1.;\n\n    texCoord[orientation] = abs(texCoord[orientation] - r0);\n\n    vec2 cellOffset = vec2(0);\n    \n    cellOffset[orientation] = (f[orientation] > r0) ? +1. : -1.;\n    \n    float r1 = rand(c + cellOffset);\n    \n    if(f[orientation ^ 1] > r1)\n        tileCoord[orientation ^ 1] += 1.;\n    \n    texCoord[orientation ^ 1] = abs(texCoord[orientation ^ 1] - r1);\n    \n    \n    // Shading and colouration.\n    \n    \n    // Rounded box shape.\n    float mask = 1. - smoothstep(0., .01, distance(vec2(.1), min(texCoord, 0.1)) - .05);\n    \n    // Corner 'bolts' shape.\n    mask *= smoothstep(.05, .06, distance(vec2(.15), texCoord));\n    \n    // Randomised per-tile colour.\n    vec3 colour = .52 + .48 * cos(textureLod(iChannel1, tileCoord / 13., 0.).r * vec3(4, 2, 6) * 4.5 + 18.5);\n    \n    // Combine.\n    vec3 col = mix(vec3(.02), colour, mask);\n    \n    // Output.\n    fragColor = vec4(pow(col, vec3(1. / 2.2)), 1.0);\n}\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3styzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 90], [92, 92, 149, 149, 1448]]}
{"id": "3t2BWw", "name": "The Afterlife", "author": "DrNoob", "description": "After the album cover \"The Afterlife\" by \"The Comet is Coming\":\nhttps://www.thecometiscoming.co.uk/wp-content/uploads/2019/09/CIC_AL_A-900.png", "tags": ["noise", "sun", "abstract", "sand", "dune", "reproduction"], "likes": 10, "viewed": 131, "published": "Public", "date": "1599219377", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: Thomas Stehle\n// Title: The Afterlife\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// After the album cover \"The Afterlife\" by \"The Comet is Coming\":\n// https://www.thecometiscoming.co.uk/wp-content/uploads/2019/09/CIC_AL_A-900.png\n\nconst float PI  = 3.141592653589793;\nconst float TAU = 6.283185307179586;\n\nconst int   NUM_SAMPLES = 3;\nconst int   MAX_STEPS   = 35;\nconst float MAX_DIST    = 20.0;\nconst float SURF_DIST   = 0.0001;\n\nconst vec3 GREEN_HSV = vec3(157.0 / 360.0, 0.35, 0.94);\nconst vec3 RED_HSV   = vec3( 18.0 / 360.0, 0.98, 0.94);\n\nconst float INV_ID  = 0.0;\nconst float CUBE_ID = 1.0;\nconst float DUNE_ID = 2.0;\n\n// 1D hash for 3D input\nfloat hash31(in vec3 p) {\n    vec3 q = fract(p * 0.1031);\n    q += dot(q, q.yzx + 33.33);\n    return fract((q.x + q.y) * q.z);\n}\n\n// 2D hash for 2D input by iq\n// https://www.shadertoy.com/view/XdXGW8\nvec2 hash22(in vec2 p) {\n    const vec2 k = vec2(0.3183099, 0.3678794);\n    p = p*k + k.yx;\n    return fract(16.0 * k*fract(p.x * p.y * (p.x + p.y)));\n}\n\n// 2D wave noise by iq\n// https://www.shadertoy.com/view/tldSRj\nfloat wnoise(in vec2 p, in float k, in float time)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f*f * (3.0 - 2.0*f);\n    float c = cos(0.5 * time);\n    float s = sin(0.25 * time);\n    mat2 rot = mat2(c, s, -s, c);\n    return 0.5 + 0.5 *\n        mix( mix( sin(time + k * dot(p, rot * (-1.0 + 2.0 * hash22(i + vec2(0, 0)))) ),\n                  sin(time + k * dot(p, rot * (-1.0 + 2.0 * hash22(i + vec2(1, 0)))) ), f.x),\n             mix( sin(time + k * dot(p, rot * (-1.0 + 2.0 * hash22(i + vec2(0, 1)))) ),\n                  sin(time + k * dot(p, rot * (-1.0 + 2.0 * hash22(i + vec2(1, 1)))) ), f.x), f.y);\n}\n\n// 2D Fractional Brownian motion based on wave noise by iq\n// https://www.shadertoy.com/view/tldSRj\nfloat wfbm(in vec2 p, in float k, in float time) {\n    mat2 rot = mat2(1.6, 1.2, -1.2, 1.6);\n    float v = 0.0;\n    float a = 0.5;\n    const int numOctaves = 5;\n    for (int i = 0; i < numOctaves; ++i) {\n        v += a * wnoise(p, k, time);\n        p = rot * p;\n        a *= 0.5;\n    }\n    return v;\n}\n\nmat2 rot2(in float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sdPlane(in vec3 p, in float h) {\n    return p.y - h;\n}\n\nfloat duneBump(in vec3 p) {\n    return 0.1 * wnoise(p.xz, 6.0, 0.05 * iTime);\n}\n\nvec2 scene(in vec3 p) {\n    vec3 boxPos = 0.075 * vec3(sin(1.1 * iTime), sin(iTime), 0.0);\n    float d1 = sdBox(p - boxPos, vec3(0.95));\n    float h = 4.0 + 0.3 * (sin(0.676 * p.x) + sin(1.348 * p.z));\n    h += 0.884 * duneBump(p);\n    float d2 = sdPlane(p, -h);\n    return (d1 < d2) ? vec2(d1, CUBE_ID) : vec2(d2, DUNE_ID);\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd) {\n    float t = 0.1;\n    float id = INV_ID;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 p = ro + t * rd;\n        vec2 s = scene(p);\n        id = s.y;\n        if (abs(s.x) < SURF_DIST * t) break;\n        t += s.x;\n        if (t > MAX_DIST) break;\n    }\n    \n    if (t > MAX_DIST) {\n        t = -1.0;\n        id = INV_ID;\n    }\n    \n    return vec2(t, id);\n}\n\nvec3 calcNormal(in vec3 p) {\n    float t = scene(p).x;\n    vec2 e = vec2(0.001, 0);\n    vec3 n = t - vec3(scene(p - e.xyy).x, scene(p - e.yxy).x, scene(p - e.yyx).x);\n    return normalize(n);\n}\n\nvec3 rayDir(in vec2 p, in vec3 origin, in vec3 tgt, in float z) {\n    vec3 f = normalize(tgt - origin);\n    vec3 r = normalize(cross(f, vec3(0, 1 ,0)));\n    vec3 u = cross(r, f);\n    vec3 c = f * z;\n    return normalize(c + p.x*r + p.y*u);\n}\n\n// Smoothstep'ed HSV to RGB conversion by iq\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 smoothHsvToRgb(in vec3 c)\n{\n    vec3 rgb = abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0;\n    rgb = clamp(rgb, 0.0, 1.0);\n    rgb = rgb*rgb*(3.0 - 2.0*rgb);    \n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat easeInOutSine(in float x) {\n    return -0.5 * (cos(x * PI) - 1.0);\n}\n\nvec3 gradient(in vec2 p) {\n    mat2 R = rot2(-0.75);\n    float scale = 1.1 + 0.2 * sin(iTime);\n    vec2 q = R * (scale * p) + vec2(0.5);\n    vec3 col = mix(GREEN_HSV, RED_HSV, easeInOutSine(clamp(q.x + 0.15, 0.0, 1.0)));\n    return smoothHsvToRgb(col);\n}\n\n// Inspired by https://www.shadertoy.com/view/lljGDt\nfloat sun(in vec2 p, in vec2 center) {\n    vec2 dir = normalize(vec2(1.0, -0.116));\n    const float seedA = 36.0;\n    const float seedB = 21.0;\n    const float speed = 2.5;\n\n    vec2 q = p - center;\n    float angle = dot(normalize(q), dir);\n    float rays = clamp(\n        (0.2 + 0.15 * sin(angle * seedA + iTime * speed)) +\n        (0.3 + 0.2 * cos(-angle * seedB + iTime * speed)), 0.0, 1.0);\n    \n    const float inten = 0.003;\n    float atten = inten / dot(q, q);\n\n    return rays * atten;\n}\n\nvec3 sampleScene(in vec2 uv) {\n    vec3 col = vec3(0);\n\n    // Gradient and sun\n    col += gradient(uv);\n    col += sun(uv, vec2(0, 0.15));\n\n    // Cast ray\n    float angle = -PI / 4.0;\n    vec3 ro = 15.0 * vec3(sin(angle), 0.35, cos(angle));\n    vec3 tgt = vec3(0.0, -0.25, 0.0);\n    vec3 rd = rayDir(uv, ro, tgt, 2.0);\n    vec2 s = castRay(ro, rd);\n\n    // Shade scene\n    if (s.x > 0.0) {\n        // Hit point and normal\n        vec3 p = ro + s.x * rd;\n        vec3 n = calcNormal(p);\n\n        // Cube\n        if (CUBE_ID == s.y) {\n            // Colors on cube surface\n            const vec3 greenHsv  = vec3(87.0 / 360.0, 0.96, 0.79);\n            const vec3 yellowHsv = vec3(45.0 / 360.0, 0.99, 0.98);\n            const vec3 orangeHsv = vec3(35.0 / 360.0, 0.98, 0.96);\n            const vec3 redRgb    = vec3(153, 10, 6) / 255.0;\n\n            // Left side material\n            vec2 qL = rot2(-0.8) * (0.6 * p.xy) + 0.6;\n            vec3 colL = mix(greenHsv, orangeHsv, easeInOutSine(clamp(qL.x, 0.0, 1.0)));\n            vec3 matL = abs(n.x) * smoothHsvToRgb(colL) * pow(wfbm(1.5 * p.yz, PI, iTime + 20.0), 0.15);\n\n            // Top side material\n            // Bump shading inspired by https://www.shadertoy.com/view/Xl2XWz\n            vec2 qT = rot2(1.008) * p.zx;\n            vec3 colT = mix(greenHsv, yellowHsv, clamp(qT.x, 0.0, 1.0));\n            float n1 = wfbm(1.5 * p.zx, PI, 1.0 * iTime + 10.0);\n            float n2 = wfbm(1.6 * p.zx, PI, 1.01 * iTime + 10.0);\n            float b1 = max(n2 - n1, 0.0) / 0.02 * 0.7071;\n            float b2 = max(n1 - n2, 0.0) / 0.02 * 0.7071;\n            b1 = b1 * b1 * 0.5 + pow(b1, 4.0) * 0.5;\n            b2 = b2 * b2 * 0.5 + pow(b2, 4.0) * 0.5;\n            float bump = clamp(0.5 + n1 * n1 * (b1 * 0.2 + b2 * 0.2 + 0.5), 0.0, 1.0);\n            vec3 matT = abs(n.y) * smoothHsvToRgb(colT) * pow(bump, 0.175);\n\n            // Right side material\n            vec3 matR = abs(n.z) * redRgb * (0.1 + wfbm(0.75 * p.xy, PI, iTime));\n\n            col = matL + matT + matR;\n        }\n        // Dune\n        else if (DUNE_ID == s.y) {\n            // Material\n            vec3 mat = vec3(0.18) + 0.180 * duneBump(p);\n\n            // Lighting\n            vec3 sunDir = normalize(vec3(0.8, 0.4, 0.2));\n            vec3 duneCol = mat * vec3(7.0, 4.5, 3.0) * clamp(dot(n, sunDir), 0.0, 1.0);\n\n            // Gamma correct\n            duneCol = pow(duneCol, vec3(0.4545));\n\n            // Mix with gradient\n            col = mix(col, col * duneCol, 0.35);\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize input coordinates\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n    \n    // Result color\n    vec3 col = vec3(0);\n    \n    // Enforce square format\n    if (abs(uv.x) < 0.5 && abs(uv.y) < 0.5) {\n        // Multi-sample scene\n        vec2 sss = 1.0 / (float(NUM_SAMPLES) * iResolution.xy);\n        for (int sy = 0; sy < NUM_SAMPLES; ++sy) {\n            for (int sx = 0; sx < NUM_SAMPLES; ++sx) {\n                col += sampleScene(uv + vec2(float(sx), float(sy)) * sss);\n            }\n        }\n        col /= float(NUM_SAMPLES) * float(NUM_SAMPLES);\n\n        // Add layer of animated dust over dune section\n        vec2 off = 5.0 * vec2(0.5 + 0.5 * sin(0.2 * iTime), 0);\n        float dust = 0.2 + 0.2 * wnoise(5.0 * uv - off, PI, 0.2 * iTime);\n        col = mix(col, vec3(dust), smoothstep(-0.1, -0.75, uv.y));\n    \n        // Add layer of animated white noise\n        col += 0.05 * vec3(hash31(vec3(fragCoord.xy, fract(0.001 * iTime))));\n\n        // Vignetting\n        float vig = length(uv) * 0.5;\n        vig = vig * vig + 1.0;\n        col *= 1.0 / (vig * vig);\n    }\n    \n    // Final result\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2BWw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[684, 708, 733, 733, 836], [838, 909, 933, 933, 1061], [1063, 1127, 1179, 1179, 1746], [1748, 1848, 1898, 1898, 2149], [2151, 2151, 2174, 2174, 2250], [2252, 2252, 2287, 2287, 2377], [2379, 2379, 2417, 2417, 2439], [2441, 2441, 2468, 2468, 2520], [2522, 2522, 2545, 2545, 2848], [2850, 2850, 2888, 2888, 3259], [3261, 3261, 3289, 3289, 3454], [3456, 3456, 3521, 3521, 3697], [3699, 3785, 3817, 3817, 4004], [4006, 4006, 4039, 4039, 4080], [4082, 4082, 4108, 4108, 4336], [4338, 4391, 4429, 4429, 4886], [4888, 4888, 4918, 4918, 7420], [7422, 7422, 7477, 7512, 8644]]}
{"id": "3tBBRG", "name": "GaboryPerlin 3: solar flares", "author": "FabriceNeyret2", "description": "Cascaded version of Gabory Perlin (see [url]https://shadertoy.com/view/3lSfWW[/url] ).\nClick for multiplicative noise.\nUncomment line #53 for scale-dependent anisotropy. ", "tags": ["perlinnoise", "displacement", "distortion", "flownoise", "filament", "divergencefree"], "likes": 8, "viewed": 231, "published": "Public API", "date": "1599150363", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/3tSBRG\n// variant of https://shadertoy.com/view/3lSfWW\n// inspired from https://shadertoy.com/view/WtBBD1\n\nfloat A = .2, // Anisotropy. 1 = isotropic\n      D = 0., // favorite dir\n  phase = 0.,\n phaseY = 0.,\n      K = 0.; // seed for random numbers\n//#define D atan((p).y,(p).x)\n\n  #define C(x)       ( .5+.5*cos(3.14* (x) ) )\n  #define cross(a,b) ( (a).x*(b).y - (a).y*(b).x )\n//#define rot(a)       mat2( cos( a + vec4(0,11,33,0) ) )\n  #define hash(p,K)    fract(sin(dot(p+K, vec2(12.9898, 78.233))) * 43758.5453)\n//#define hash2(p)   ( 2.* fract( sin( (p) * mat2(127.1,311.7, 269.5,183.3) ) *43758.5453123 ) - 1. )\n  #define hash2(p)     cos( A/2.*6.28*hash(p,K) + vec2(0,11) + D + V(p)*iTime ) // variant of random gradient + rotating (= lownoise)\n//#define l(i,j)       dot( hash2(I+vec2(i,j)) , F-vec2(i,j) )       // random wavelet at grid vertex I+vec2(i,j) \n\n  #define wave(v,x,f)  cos( 6.28*( 2.*dot(x,v) + f ) )\n//#define Gabor(v,x,f) wave(v,x,f) * exp(-.5*1.*dot(x,x) )\n//                     wave        *       ~Gaussian                        * structuring the gaussian / normalization of this ( see https://www.desmos.com/calculator/jejjp1xikd )\n//#define Gabor(v,x,f) wave(v,x,f) * C(dot(x,v))  *step(abs(dot(x,v))  ,1.) * C(dot(x,v)  -phaseY) / (.25 + C(phaseY)/2.)\n  #define Gabor(v,x,f) wave(v,x,f) * C(cross(x,v))*step(abs(cross(x,v)),1.) * C(cross(x,v)-phaseY) / (.25 + C(phaseY)/2.)\n\n  #define l(i,j)       Gabor( hash2(I+vec2(i,j)), F-vec2(i,j) , phase + hash(I+vec2(i,j),2.))       // random wavelet at grid vertex I+vec2(i,j) \n  #define L(j,x)       mix( l(0,j), l(1,j), x )\n\n  #define V(p)         0.                           // flownoise rotation speed \n//#define V(p)       ( 2.*mod((p).x+(p).y,2.)- 1. ) // checkered rotation direction \n//#define V(p)         length(p)\n//#define V(p)       ( 8. - length(p) )\n\nfloat GaboryPerlin(vec2 p) {\n    vec2 I = floor(p), \n         F = fract(p), \n     //  U = F;\n     //  U = F*F*(3.-2.*F);                   // based Perlin noise\n         U = F*F*F*( F* ( F*6.-15.) + 10. );  // improved Perlin noise ( better derivatives )\n    return mix( L(0,U.x) , L(1,U.x) , U.y );  // smooth interpolation of corners random wavelets\n}\n\nfloat layer(vec2 U) {\n#if 0\n    float v = GaboryPerlin( U );              // only 1 kernel\n#else\n    float v = 0., N = 4.;\n    for ( float i = 0.; i < 5.; i++, K+=.11 ) // sum N kernels\n        v += GaboryPerlin( U ); \n    v /= 2.*sqrt(N);\n    v *= mix(127./80.,127./50.,A)/2.; // try to regularize std-dev\n#endif \n    return v;\n}\n\nfloat cascade(vec2 U) {  // --- regular additive cascade\n    float v = 0., s = .5, A0=A;\n    U += 100.;\n    for (int i=0; i<5; i++)\n     // A = mix(1.,A0,1.-.5*float(i)/4.), // octave-dependent anisotropy\n        v += layer(U)*s, U*=2., s/=2.;\n    return v;\n}\n\nfloat mul_cascade(vec2 U) { // --- multiplicativ cascade\n    float v = 1., A0=A;\n    U += 100.;\n    for (int i=0; i<5; i++)\n     // A = mix(1.,A0,1.-.5*float(i)/4.), // octave-dependent anisotropy\n        v *= 1.+layer(U), U*=2.;\n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         S = 8. / R.yy,\n         U = ( 2.*u - R ) * S, I = floor(U);\n    \n    A = 0.;   // anisotropy\n    D = 6.28* cos(u.x/R.y+.3*iTime) * cos(u.y/R.y-.2*iTime); // fiber direction\n // phase  = iTime;  // phase, along the Gabor field direction \n // phaseY = iTime;  // orthophase, along the front direction\n    \n    U = U/8.;\n    float v = iMouse.z <= 0. \n        ? .5 + .5* cascade(U)\n        : mul_cascade(U) / 3.;\n    \n // v *= .01/fwidth(v);\n    O = v * vec4(2,1.3,1,1); // coloring\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBBRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1724, 1883, 1911, 1911, 2236], [2238, 2238, 2259, 2259, 2568], [2570, 2570, 2593, 2626, 2829], [2831, 2831, 2858, 2887, 3076], [3078, 3078, 3116, 3116, 3636]]}
{"id": "3tBfDG", "name": "-1th Dimension Circle Explosion", "author": "celifrog", "description": "Editing these is fun. :D \nFork from- https://www.shadertoy.com/view/ttjfRt\n", "tags": ["test"], "likes": 4, "viewed": 222, "published": "Public API", "date": "1599692077", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define T (iTime*0.125)\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n#define pmod(p, x) mod(p, x) - 0.5*x\n#define lmod(d, x) (mod(d,x)/x - 0.5)\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n p = abs(p)-s++;\n return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 pA = vec3(0);\nmat3 rotate( in vec3 v, in float angle)\n{\n float c = cos(radians(angle));\n float s = sin(radians(angle));\t\n return mat3(c + (1.0 - c) * v.x * v.x*v.z, (1.0 - c) * v.x * v.y - s - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.y, c + (1.0 - c) * v.z * v.z\n );\n}\n\nvec2 N(float angle)\n{\n return vec2(sin(angle),cos(angle));\n}\nvec3 text(vec2 t, vec3 p){\n vec3 o = vec3(0);\n float d = 40e1;\n t = pmod(t,2./.1);\n t *=.1;\n float yid = (floor( (p.y + 55111.)*0. ) );\n float W = 2.;\n float modd = 1.4;\n float sqD = max(abs(t.y), abs(t.x));\n sqD +=2. + yid*1.;\n float sqid = floor(sqD/modd);\n d = min(d, sqD);\n o +=  pal(.1, vec3(111.,40.7,510.6)*1.5, vec3(118.4 ,4.19,75.4 - yid*0.2), vec3(3.,7.,3.),-11. + iTime + sqid*0.5 + p.z + t.x*2.5 - t.y*1.5);\n o *= step(sin(sqid*4440.), -5.);\n float aa = 20.;\n sqD -= 0.5;\n sqD = abs(sqD*14.);\n o -= exp(-sqD*aa)*15.;\n sqD -= 1.;\n sqD = abs(sqD*5.);\n o -= exp(-sqD*aa)*55.;\n return o;\n}\n\nfloat g1;\n#define time iTime\nvec2 mouse;\nfloat PI = acos(-111.);\n\nfloat dBox(vec3 p, vec3 s)\n{\n return length (max (abs(p)-s,0.));    \t    \n}\n\nmat2 rot2d(float a) {\n float c = cos(a), s = sin(a);\n return mat2(c, s, -s, c);\n}\n\nvec3 kifs(vec3 p, float s, float tf) {\n float f = sin(iTime*1.25)-11.;\n for (int i = 0; i <1; i++) {\n   p.xy *= -rot2d(f);\n   p.zy *= rot2d(f);\n   p.xz *= rot2d(f);\n   p =  (max (abs(p)-vec3(0.01,5.1,0.01),0.1));  \n  }\n  return p;\n}\n\nvec3 tex3D(  in vec3 p, in vec3 n ){\n vec2 d =vec2(0.);   \n float dp = dot(p,p*0.1)*.8;\n p = kifs(p, 1., 1.);\n p /= dp;\n p.xy*= Rot(cos(iTime*.05));\n p = rotate( ( vec3(cos(p.xzy*1.+iTime*1.) ) ), 3500.)*p;\n p.z=sin(p-vec3(-T*tau*1.,-T*tau*2.,-T*tau*1.+sin(iTime)*1.)).z*.1;\n vec3 q = (text(p.xy, p*1.)).xyz*111.;\n return q;\n}\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nvec2 GetDist(vec3 p) {\n\n vec2 d =vec2(0.);\n vec3 q = p;   \n float dp = dot(p,p*0.1)*.8;\n p = kifs(p, 1., 2.);\n p /= dp;\n p.xy*= Rot(cos(iTime*6.05));\n p = rotate( ( vec3(cos(p.xzy*1.+iTime*1.) ) ), 300.)*p;\n p.z=sin(p-vec3(-T*tau*1.,-T*tau*2.,-T*tau*1.+sin(iTime)*1.)).z*.1;\n d = vec2(sdBox(p,vec3(3.)) + sdBox(q,vec3(0,0.,0.)),4);\n d.x *=1.;\n d.x =(((d.x*dp)/5.));\n g1 +=1./(.000008+pow(abs(d.x),10.));\n d = condmin( d,d);    \n return d;\n}\n\nvec2 RayMarch (vec3 ro, vec3 rd) \n {\n vec2 h, t=vec2( 0.);\n for (int i=0; i<MAX_STEPS; i++) \n  {\n\t h = GetDist(ro + t.x * rd);\n \tif(h.x<SURF_DIST||t.x>MAX_DIST) break;\n \t\t t.x+=h.x*1.;\n \t\t t.y=h.y;\n  }\n if(t.x>100.) t.x=0.;\n return t;\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(8.00035, -11.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\n\nfloat GetLight(vec3 p) {\n vec3 lightPos = vec3(sin(iTime)*1., cos(iTime)*2., 2);\n vec3 l = normalize(p-lightPos);\n vec3 n = GetNormal(p);\n float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n vec2 d = RayMarch(p+n*SURF_DIST*1., l);\n return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n vec3 f = normalize(l-p-l),\n r = normalize(cross(vec3(0,1,0), f)),\n u = cross(f,r),\n c = p+f+f*z,\n i = c + uv.x*r + uv.y*u,\n d = normalize(i-p);\n return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n vec2 m = iMouse.xy/iResolution.xy;  \n vec3 col = vec3(0);  \n vec3 ro = vec3(3.,3., 5.);\n ro.xy *= Rot(sin(iTime*0.2)*6.2831);\n ro.xz *= Rot(sin(iTime*0.2)*6.2831);\n vec3 rd = R(uv, ro, vec3(5,5,0), 1.);\n vec2 d = RayMarch(ro, rd);\n float t2;\n t2=d.x;   \n if(t2>0.)\n {\n  vec3 p = ro + rd * t2;\n  vec3 n = GetNormal(p);\n  vec3 baseColor = vec3(1,0,cos(iTime*2.)+.5);\n  float dif = GetLight(p);\n  col = vec3(dif);\n  col+=baseColor;\n if(d.y==1.) col += tex3D(p,n)*2.;\n }\n col*=g1*vec3(.000005);  \n float fog = 1. / (1. + d.x * d.x *2.);\n col *= vec3(fog); \n col*= 1.; \n fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBfDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[253, 253, 272, 272, 339], [341, 341, 370, 370, 450], [471, 471, 512, 512, 884], [886, 886, 907, 907, 946], [947, 947, 973, 973, 1544], [1612, 1612, 1640, 1640, 1687], [1689, 1689, 1710, 1710, 1770], [1772, 1772, 1810, 1810, 2004], [2006, 2006, 2042, 2042, 2332], [2334, 2334, 2372, 2372, 2439], [2441, 2441, 2463, 2463, 2881], [2883, 2883, 2919, 2919, 3119], [3121, 3121, 3144, 3144, 3331], [3334, 3334, 3358, 3358, 3572], [3574, 3574, 3616, 3616, 3774], [3776, 3776, 3833, 3833, 4485]]}
{"id": "3tjfWK", "name": "SoundEclipse rpm w/gain", "author": "username", "description": "8 times louder which looks a lot cooler in my setup", "tags": ["visualization", "mic", "virtualdj"], "likes": 4, "viewed": 450, "published": "Public API", "date": "1599867511", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"SoundEclipse rpm\" by sclavel. https://shadertoy.com/view/ls3BDH\n// 2020-09-11 23:35:33\n\n// credit: https://www.shadertoy.com/view/4tGXzt\n\n#define BEATMOVE 1\n\nconst float FREQ_RANGE = 64.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.6;\nconst float BRIGHTNESS = 0.2;\nconst float SPEED = 0.5;\nconst float gain = 8.0;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat getfrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x*gain + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 doHalo(vec2 fragment, float radius) {\n\tfloat dist = length(fragment);\n\tfloat ring = 1.0 / abs(dist - radius);\n\t\n\tfloat b = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcol += hsv2rgb( vec3( ( angle + iTime * 0.25 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\n\t\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcol *= frequency;\n\t\n\t// Black halo\n\tcol *= smoothstep(radius * 0.5, radius, dist);\n\t\n\treturn col;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\n\t\n\tfloat freq = abs(fragment.x * 0.5);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\n\tcolor += doHalo(fragPos, RADIUS);\n\n    float c = cos(iTime * SPEED);\n    float s = sin(iTime * SPEED);\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\n\tcolor += doLine(rot, RADIUS, rot.x);\n\t\n\tcolor += max(luma(color) - 1.0, 0.0);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjfWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[332, 353, 374, 374, 543], [545, 545, 569, 569, 619], [621, 621, 650, 650, 748], [750, 750, 786, 786, 997], [999, 999, 1034, 1034, 1098], [1100, 1100, 1142, 1142, 1609], [1611, 1611, 1662, 1662, 1914], [1917, 1917, 1974, 1974, 2407]]}
{"id": "3tjfz3", "name": "Raymarcher_LO", "author": "loganobrien121", "description": "A raymarcher", "tags": ["raymarcher"], "likes": 0, "viewed": 41, "published": "Public", "date": "1599580586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100. //WE PUT A DECIMEL HERE AND NOT ON MAX STEPS BECAUSE MAX STEPS IS AN INT\n\t\t\t\t\t  //WHEREAS MAX_DIST IS A FLOAT\n#define SURF_DIST .01 //OUR \"SURFACE DIST\" IS WHEN THE SPHERE THAT SEEKS A HIT DURING OUR MARCH REACHES A SMALL SIZE, IN THIS CASE .01\n\t\t\t\t\t  //THEN WE HAVE A HIT\n\nfloat sdCapsule (vec3 p, vec3 a, vec3 b, float r)\n{ \n    vec3 ab = b-a; //THIS WOULD BE THE TOP VEC3 - BOTTOM VEC3\n    vec3 ap = p-a; //THIS IS THE SURFACE POINT - THE BOTTOM VEC3\n    \n    float t = dot(ab, ap) / dot(ab, ab); //DOT IS USED TO INTERSECT TWO VECTORS. \n    t = clamp(t, 0., 1.); //THIS CLAMPS IT TO MAKE SURE OUR VALUE IS ALWAYS BETWEEN 0 AND 1 \n    \n    vec3 c = a + t*ab; \n    return length(p-c) - r; \n}\n\nfloat sdTorus (vec3 p, vec2 r) \n{\n    float x = length(p.xz)-r.x; \n   \n    return length(vec2(x, p.y)) - r.y; \n    \n}\n\nfloat GetDist(vec3 p) //THIS TAKES A POINT  IN 3D SPACE AS AN INPUT\n    {\n        vec4 sphere = vec4(0,1,6,1); //THIS IS TO CALCULATE DISTANCE FROM ORIGIN TO A SPHERE. This would be different for other shapes. \n \n        float sphereDist = length(p-sphere.xyz) - sphere.w; //We find the distance to the center of the sphere by subracting its position\n        \t\t\t\t\t\t\t\t\t\t\t\t\t//from the camera position. Then, we subtract the radius of the sphere so that \n        \t\t\t\t\t\t\t\t\t\t\t\t\t//we're hitting its area, or \"shell\" for your dumbass, Logan. \n        \t\t\t\t\t\t\t\t\t\t\t\t\t//Not its center point.\n        \t\t\t\t\t\t\t\t\t\t\t\n        float planeDist = p.y; //Distance to the \"plane\" aka the ground. We find this by subtracting the plane y from the camera y.\n        \t\t\t\t\t\t//In simpler terms, if the camera is at 5y and the plane is the ground at 0, then our height is just \\\n        \t\t\t\t\t\t//the camera y, or p.y\n        \n        float cd = sdCapsule(p, vec3(0,1,6), vec3(1, 2, 6), .2); //THIS GIVES US THE CAPSULE DISTANCE AND FILLS OUT THE INPUTS NEEDED\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t//IN SD CAPSULE ABOVE. A = 1ST VEC3, B = 2ND VEC3 AND R = THE RADIUS AFTER \n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t//THE TWO\n        \n        float td = sdTorus(p-vec3(0, .2, 6), vec2(1.5, .2)); //THIS IS THE PARAMETERS FOR A TORUS. \n        \n        //float d = min(sphereDist, planeDist); //THIS IS FOR SPHERE. \n        \t\t\t\t\t\t\t\t\t   //To ensure we don't clip through an object we always find the MINIMUM distance.\n        \n        float d = min(cd, planeDist);  //THIS IS IF WE WANT TO RENDER A CAPSULE  \n        \n        //float d = min(td, planeDist);  //THIS IS IF WE WANT TO RENDER A TORUS  \n        d = min(d, td); \n        \n        return d; \n    }\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO = 0.; //Distance origin, or how far away we've marched from the origin. \n        \n        for(int i=0; i < MAX_STEPS; i++) //Loop that goes until you've reached max # of steps. \n        {\n            vec3 p = ro+dO*rd; //Point P is the blue point (\n            float dS = GetDist(p); //Distance to the scene. \n            dO += dS; //We add the distance to the scene to how far we've marched away from origin. \n            \n            if(dS<SURF_DIST || dO > MAX_DIST) break; //If distance to scene  is smaller than some defined surface distance, we have a hit. \n            \t\t\t\t\t\t\t\t\t\t    //Or if it's past our max distance and we haven't hit anything, we break out of it. \n        }\n        return dO; \n    }\n\nvec3 GetNormal(vec3 p) //THIS IS HOW WE FIND THE NORMAL VECTOR, IE THE ORIENTATION OF A SURFACE\n    \t\t\t\t\t//ESSENTIALLY BY DOING THE SAME ALGORITHM TO DETERMINE A SLOPE. WE MAKE 2 POINTS\n    \t\t\t\t\t//VERY CLOSE TOGETHER, THEN SUBTRACT THE DISTANCE A LITTLE TO THE RIGHT, UP AND\n    \t\t\t\t\t//BEHIND THE SURFACE BETWEEN THEM TO FIND WHICH WAY IT'S PORIENTED. \n{\n    \n    vec2 e = vec2(.01, 0); //THIS IS OUR NEW POINT. OUR X VALUE IS .01 AND OUR Y VALUE IS 0.\n    float d = GetDist(p); //THIS IS OUR ORIGINAL POINT IN 3D SPACE WE MADE ABOVE\n    \n    vec3 n = d - vec3( //THESE ARE THE SUBTRACTIONS TO GIVE US OUR NORMAL \n        GetDist(p-e.xyy), //TO THE RIGHT, IE - .01, 0, 0\n        GetDist(p-e.yxy), //UP, IE 0, .01, 0 BECAUSE WE USE THE XY VALUES DEFINED ABOVE, WHEN WE DEFINE VEC2 E\n        GetDist(p-e.yyx)); //BEHIND\n        \n        return normalize(n); \n    \n}\n        \nfloat GetLight(vec3 p)\n        {\n            vec3 lightPos = vec3(0,5,6); //HARDCODE THE LIGHT POSITION. FOR NOW WE'LL SAY IT'S AT THESE POINTS. \n            lightPos.xy += vec2(sin(iTime), cos(iTime))*2.; \n            vec3 l = normalize(lightPos-p); //THIS CALCULATES WHERE LIGHT IS COMING FROM, FROM THE PERSPECTIVE OF THE SURFACE POINT\n            vec3 n = GetNormal(p); \n            \n            float dif = clamp(dot(n, l), 0., 1.); //IF WE DON'T CLAMP IT BETWEEN 0 AND 1, THIS ACTUALLY GIVES US A VALUE BETWEEN -1 AND 1\n            \t\t\t\t\t\t\t\t\t  //WHICH IS FINE WITH A SIMPLE SHAPE LIKE A SPHERE BUT IF WE WANT TO WORK WITH MORE COMPLEX\n            \t\t\t\t\t\t\t\t\t  //STUFF, IT WOULD GIVE US TROUBLE. SO WE CLAMP IT BETWEEN 0 AND 1 \n            \n            float d = RayMarch(p+n*SURF_DIST, l); //THIS IS HOW WE CALCULATE SHADOW. WE RAYMARCH BETWEEN SURFACE POINT AND LIGHT POS AND RETURN A VALUE.\n            \n            if(d<length(lightPos - p)) dif *= .1; //IF THE VALUE WE GET IS SMALLER THAN THE LIGHT POS - SURFACE POSITION, WE KNOW THAT \n            \t\t\t\t\t\t\t\t\t  //WE'RE IN SHADOW. TO MAKE A SHADOW, WE JUST TAKE THE LIGHT VALUE DIF AND MULTIPLY IT BY \n            \t\t\t\t\t\t\t\t\t  //A SMALL AMOUNT TO CREATE THE SHADOW\n            return dif;\n        }\n            \n        \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,1,0); //ray origin, or position of camera\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1)); //ray direction\n    \n    float d = RayMarch(ro, rd); \n    \n    vec3 p = ro + rd * d; //Camera + ray direction for as long as it takes to get to the intersection point. We use this \n    \t\t\t\t     //point, p, as an input through many of our functions in this raymarcher. \n    \t\t\t\t\t \n    \n    float dif = GetLight(p); //THIS IS THE DIFFUSE OF THE LIGHT\n    d /= 10.; \n    col = vec3(dif); // OUR COLOR IS DETERMINED BY THE DIFFUSE\n      \n    fragColor = vec4(col,1.0);\n}\n    \n    \n\n\n     \n\n        \n   \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjfz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[296, 318, 369, 369, 737], [739, 739, 772, 772, 856], [858, 858, 931, 931, 2548], [2552, 2552, 2590, 2590, 3318], [3320, 3320, 3674, 3674, 4183], [4193, 4193, 4225, 4225, 5445], [5470, 5470, 5527, 5527, 6192]]}
{"id": "3tSBR3", "name": "RGB Goopy Sea", "author": "celifrog", "description": "Forked from-https://www.shadertoy.com/view/wtjfzV", "tags": ["rainbow", "goop", "forked"], "likes": 6, "viewed": 248, "published": "Public API", "date": "1599421032", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int NUM_STEPS = 1024;\nconst int AO_SAMPLES = 2;\nconst float INV_AO_SAMPLES = 2.0 / float(AO_SAMPLES);\nconst float EPSILON = 1e-5;\nconst vec3 RED = vec3(0.6,0.03,0.08);\nconst vec3 ORANGE = vec3(0.3,0.1,0.1);\nconst vec3 BG = vec3(0.0,0.0,0.0);\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) { return pow(dot(n,l) * 0.4 + 0.6,p); }\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\nfloat specular(vec3 n,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(1.0-abs(dot(n,e)),0.0),s) * nrm;\n}\n\n// julia based on iq's implementation\nfloat julia(vec3 p,vec4 q) {\n    vec4 nz, z = vec4(p,0.0);\n    float z2 = dot(p,p), md2 = 1.0;    \n    for(int i = -1; i <80; i++ * -1 *-4 *100*1111*i++) {\n        md2 *= 9.0*z2++;\n        nz.x = z.x*z.x-dot(z.yzw,z.yzw);\n        nz.y = -2.0*(z.x*z.y + z.w*z.z);\n        nz.z = -2.0*(z.x*z.z + z.w*z.y);\n        nz.w = -2.0*(z.x*z.w - z.y*z.z);\n        z = nz + q;\n        z2 = dot(z,z);\n        if(z2 > 4.0) break;\n    }    \n  return 0.25*sqrt(z2/md2)*log(z2++);    \n}\n\nfloat rsq(float x) {\n    x = sin(x);\n    return pow(abs(x),3.0) * sign(x);\n}\n\n// world\nfloat map(vec3 p) {\n    const float M = 0.6;\n    float time = iTime + rsq(iTime*0.5) * 2.0;\n    return julia(p,vec4( \n        sin(time*0.96456)*0.451*M,\n        cos(time*0.59237)*0.435*M,\n        sin(time*1.73426)*0.396*M,\n        cos(time*.42379)*0.425*M\n    ));\n}\n    \nvec3 getNormal(vec3 p) {\n    vec3 n;\n    n.x = map(vec3(p.x+EPSILON,p.y,p.z));\n    n.y = map(vec3(p.x,p.y+EPSILON,p.z));\n    n.z = map(vec3(p.x,p.y,p.z+EPSILON));\n    return normalize(n-map(p));\n}\nfloat getAO(vec3 p,vec3 n) {    \n    const float R = 3.0;\n    const float D = 0.8;\n    float r = 0.0;\n    for(int i = 0; i < AO_SAMPLES; i++) {\n        float f = float(i)*INV_AO_SAMPLES;\n        float h = 0.1+f*R;\n        float d = map(p + n * h);\n        r += clamp(h*D-d,0.0,1.0) * (1.0-f);\n    }    \n    return clamp(1.0-r,0.0,8.0);\n}\n\nfloat spheretracing(vec3 ori, vec3 dir, out vec3 p) {\n    float t = 0.0;    \n    for(int i = 0; i < NUM_STEPS; i++) {\n        p = ori + dir * t;\n        float d = map(p);\n        if(d <= 0.0 || t > 2.0) break;\n        t += max(d*0.3,EPSILON);\n    }    \n    return step(t,2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.1;\n    vec2 sc = vec2(sin(time),cos(time));\n    \n    // tracing of distance map\n    vec3 p;\n    vec3 ori = vec3(0.0,0.0,1.5);\n    vec3 dir = normalize(vec3(uv.xy,-1.0));    \n    ori.xz = vec2(ori.x * sc.y - ori.z * sc.x, ori.x * sc.x + ori.z * sc.y);\n    dir.xz = vec2(dir.x * sc.y - dir.z * sc.x, dir.x * sc.x + dir.z * sc.y);\n    \n    float mask = spheretracing(ori,dir,p);\n    vec3 n = getNormal(p);\n    float ao = pow(getAO(p,n), -5.2);\n    ao *= n.y * -555.5 + 5.5;\n    \n    // bg    \n    vec3 bg = mix(\n        mix(vec3(0.0), BG,        \n          smoothstep(-1.0,1.0,uv.y)),\n        mix(BG*0.5, vec3(0.0),        \n          smoothstep(-1.0,1.0,uv.y)),\n        smoothstep(-1.0,1.0,uv.x));      \n    bg *= 0.8 + 0.2 * smoothstep(0.1,0.0,sin((uv.x-uv.y)*40.0));\n    \n    // color\n    vec3 l0 = normalize(vec3(8.0,88.0,88.0));\n    vec3 l1 = normalize(vec3(88,0.5,0.5));\n    vec3 l2 = normalize(vec3(88.0,1.0,0.0));\n    vec3 color = RED * 0.4;\n    color += specular(n,l0,dir,51.0) * RED;\n    color += specular(n,l1,dir,55.0) * ORANGE * 515.1; \n    color = color++*ao++*1.0;\n    \n    color = mix(bg--,color,mask);\n        \n    color = vec3(ao++);\n    color = n++ * 0.9 + 0.5;\n  \n  fragColor = vec4(pow(color,vec3(0.4545)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSBR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 261, 299, 299, 337], [338, 338, 384, 384, 488], [489, 489, 528, 528, 630], [632, 670, 698, 698, 1139], [1141, 1141, 1161, 1161, 1217], [1219, 1228, 1247, 1247, 1493], [1499, 1499, 1523, 1523, 1695], [1696, 1696, 1724, 1724, 2033], [2035, 2035, 2088, 2088, 2313], [2315, 2315, 2372, 2372, 3745]]}
{"id": "3tSBRG", "name": "GaboryPerlin 2", "author": "FabriceNeyret2", "description": "Cascaded version of Gabory Perlin (see [url]https://shadertoy.com/view/3lSfWW[/url] ).\nOscillate between isotropic and anisotropic along circles.\n\nClick for multiplicative noise.\nUncomment line #48 for scale-dependent anisotropy. ", "tags": ["perlinnoise", "displacement", "distortion", "flownoise", "filament", "divergencefree"], "likes": 9, "viewed": 247, "published": "Public API", "date": "1599148728", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/3lSfWW\n// inspired from https://shadertoy.com/view/WtBBD1\n\nfloat A = .2, // Anisotropy. 1 = isotropic\n      D = 0., // favorite dir\n      K = 0.; // seed for random numbers\n//#define D atan((p).y,(p).x)\n\n//#define rot(a)       mat2( cos( a + vec4(0,11,33,0) ) )\n  #define hash(p,K)    fract(sin(dot(p+K, vec2(12.9898, 78.233))) * 43758.5453)\n//#define hash2(p) ( 2.* fract( sin( (p) * mat2(127.1,311.7, 269.5,183.3) ) *43758.5453123 ) - 1. )\n  #define hash2(p)   cos( A/2.*6.28*hash(p,K) + vec2(0,11) + D + V(p)*iTime ) // variant of random gradient + rotating (= lownoise)\n//#define l(i,j)     dot( hash2(I+vec2(i,j)) , F-vec2(i,j) )       // random wavelet at grid vertex I+vec2(i,j) \n  #define Gabor(v,x,f)   cos( 6.28*( 2.*dot(x,v) + f ) ) * exp(-.5*1.*dot(x,x) )\n  #define l(i,j)     Gabor( hash2(I+vec2(i,j)), F-vec2(i,j) , hash(I+vec2(i,j),2.))       // random wavelet at grid vertex I+vec2(i,j) \n  #define L(j,x)     mix( l(0,j), l(1,j), x )\n\n  #define V(p) 0.                                // flownoise rotation speed \n//#define V(p) 1.*( 2.*mod((p).x+(p).y,2.)- 1. ) // checkered rotation direction \n//#define V(p) length(p)\n//#define V(p) ( 8. - length(p) )\n\nfloat GaboryPerlin(vec2 p) {\n    vec2 I = floor(p), \n         F = fract(p), \n     //  U = F;\n     //  U = F*F*(3.-2.*F);                   // based Perlin noise\n         U = F*F*F*( F* ( F*6.-15.) + 10. );  // improved Perlin noise ( better derivatives )\n    return mix( L(0,U.x) , L(1,U.x) , U.y );  // smooth interpolation of corners random wavelets\n}\n\nfloat layer(vec2 U) {\n#if 0\n    float v = GaboryPerlin( U );             // only 1 kernel\n#else\n    float v = 0., N = 4.;\n    for ( float i = 0.; i < 5.; i++, K+=.1 ) // sum N kernels\n        v += GaboryPerlin( U ); \n    v /= 2.*sqrt(N);\n    v *= mix(127./80.,127./50.,A)/2.; // try to regularize std-dev\n#endif \n    return v;\n}\n\nfloat cascade(vec2 U) {  // --- regular additive cascade\n    float v = 0., s = .5, A0=A;\n    U += 100.;\n    for (int i=0; i<5; i++)\n     // A = mix(1.,A0,1.-.5*float(i)/4.), // octave-dependent anisotropy\n        v += layer(U)*s, U*=2., s/=2.;\n    return v;\n}\n\nfloat mul_cascade(vec2 U) { // --- multiplicativ cascade\n    float v = 1., A0=A;\n    U += 100.;\n    for (int i=0; i<5; i++)\n     // A = mix(1.,A0,1.-.5*float(i)/4.), // octave-dependent anisotropy\n        v *= 1.+layer(U), U*=2.;\n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         S = 8. / R.yy,\n         U = ( 2.*u - R ) * S, I = floor(U);\n    \n    A = .5+.5*sin(iTime);   // anisotropy\n  //A = mix(1.,A, dot(I,I));\n  //A = abs( length(I)*2.-1.);\n  //D = atan(U.y,U.x);      // prefered direction\n    D = 2.*3.14 * cos(u.x/R.y) * cos(u.y/R.y);\n    \n // float v = .5+.5*layer(U); O = vec4(v); return;\n    float v = iMouse.z <= 0. \n        ? .5 + .5* cascade(U/8.)\n        : mul_cascade(U/8.) / 3.;\n    \n\n    O = v * vec4(1,1.2,1.7,1); // coloring\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSBRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1070, 1212, 1240, 1240, 1565], [1567, 1567, 1588, 1588, 1895], [1897, 1897, 1920, 1953, 2156], [2158, 2158, 2185, 2214, 2403], [2405, 2405, 2443, 2443, 2950]]}
{"id": "3tSBzK", "name": "Candyball", "author": "j91000", "description": "A simple raymarching engine with phong shading.\nBased on the articles at :https://www.iquilezles.org/www/index.htm", "tags": ["raymarching", "shadows"], "likes": 4, "viewed": 133, "published": "Public", "date": "1599441942", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//render settings\n#define STEPSHRINK 2.3 //increase this value to deal with distance field domain distortion artifacts\n#define MAXSTEPS 5000\n#define CAMDIST 35.\n#define TARGET vec3(0,0,0);\n#define CAMSTRT vec2(-pi/4.,0.)\n\n#define HITDIST 1.e-1\n#define MAXDIST 1000.\n\n//misc\n#define pi atan(1.0) * 4.0\n#define ZERO min(iFrame,0)\n#define PLANEH -20.\n\n//light and shadow\n#define AMBIENT 0.05 \n#define SUNLIGHT vec3(.7,.6,.5)*3.\n#define SHADQUAL .2\n#define SHADSMOOTH 20.\n#define SPECULARPOWER 5.\n//ambient occlusion\n#define AO 1. //comment this line to disable ambient occlusion\n#define AODIST 1.85\n#define AOSTEPS 5\n#define AOPOW 1.\n\n\nstruct CastResult\n{\n    vec3 ori;\n    vec3 pos; //hit location\n    vec3 norm; //surface normal\n    vec3 surf; //surface material/albedo\n};\n    \nstruct DirLight\n{\n  \tvec3 dir; //light direction vector\n    vec3 col; //light color*intensity\n};\nstruct MapResult\n{\n    float dist;//distance to scene\n    vec3 color;//surface material color\n    bool volume;//false for the floor, controls coloration in primaryRay()\n};\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{angles=angles.yxz;\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n        return rotX*rotY*rotZ;\n    }\n\nmat3 Rotate(float a1,float a2,float a3){\n return Rotate(vec3(a1,a2,a3));   \n}\n//generates a rotation matrix that rotates (0,0,1) to face in the same\n//direction as dir.\nmat3 camRotation(vec3 dir){\n    dir=normalize(dir);\n    float xRot=atan(dir.z,dir.x)-pi/2.;\n    float yRot=atan(dir.y,length(dir.xz));\n    return Rotate(vec3(xRot,yRot,0));\n}\n\n//signed distance/material for the floor\nMapResult sdPlane(vec3 pos){\n    return MapResult(pos.y-PLANEH,vec3(.2-length(pos.xz/400.)),false);\n}\n//signed distance/material for the warped ball.\nMapResult sdVBall(vec3 pos){\n    pos=pos*Rotate(sin(iTime/6.)*2.,iTime/5.,0.);\n    pos=pos*Rotate(length(pos.xz)/30.*pi,0.,0.);\n    pos.y+=sin(iTime)*pow(abs(pos.x*pos.z),.6)*sin(length(pos.xz)/30.*pi)/2.;\n    pos.xz*=0.6;//sin(iTime);\n    return MapResult((length(pos)-9.),vec3(.2,.05,.05),true);\n}\n\nMapResult sdUnion(MapResult a,MapResult b){\n    if(a.dist<b.dist){return a;}\n    return b;\n}\n//calculate the distance to scene/ material properties of closest object\nMapResult map(vec3 pos){\n    MapResult plane=sdPlane(pos);\n    MapResult result=sdVBall(pos);\n    result=sdUnion(result,plane);\n    return result;\n}\n//same as map, but throw away everything but distance\nfloat distToScene(vec3 pos){\n return map(pos).dist;   \n}\n//calculate the norm by sampling the distance field around pos\n//lifted from an iq raymarcher\nvec3 calcNorm(vec3 pos){\n        vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 1.*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*distToScene(pos+0.00005*e);\n    }\n    return normalize(n);\n}\n\n//clever ambient occlusion trick described here:\n//https://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf\nfloat ambientOcclusion(vec3 pos,vec3 normal,float sampleDist){\n    #ifdef AO\n    float occlusion=0.;\n    float itC=0.;\n    for(int i=1;i<AOSTEPS;i++){\n     itC++;\n     float term=itC*sampleDist-distToScene(pos+normal*sampleDist*itC);\n        occlusion+=1./pow(2.,itC)*term;\n    }\n    return 1.-clamp(AOPOW*occlusion/sampleDist,0.,1.);\n    #else\n    return 1.;\n    #endif\n}\n\n//cast a new ray from surface.pos and see if you hit anything \n//on your way to sun\nfloat occlusion(CastResult surface,DirLight sun){\n    vec3 rayOri=surface.pos+surface.norm*HITDIST*2.;//the ray starts from just above the surface of the hit.\n    vec3 rayPos=rayOri;\n    bool hit=false;\n    float result=1.;\n    for(int steps=ZERO;steps<MAXSTEPS&&(!hit)&&length(rayPos-rayOri)<MAXDIST;steps++){\n        MapResult localState=map(rayPos);\n        float dts=localState.dist;\t//calculate distance to scene\n        hit=dts<HITDIST;\n        result=min(result,SHADSMOOTH*dts/length(rayPos-rayOri));//if close to a surfce, cast a penumbra\n        rayPos-=sun.dir*dts/STEPSHRINK*SHADQUAL;//march\n    }\n    result=hit ? 0.:result; //if you registered a hit, then no light for you!\n    return result; //otherwise return the darkest penumbra you encountered\n}\n\nCastResult primaryRay(vec3 rayOri,vec3 rayVec){\n    \n    bool hit=false;\n    vec3 rayPos=rayOri;\n    MapResult localState;\n    for(int steps=ZERO;steps<MAXSTEPS&&hit==false&&length(rayPos-rayOri)<MAXDIST;steps++){\n        localState=map(rayPos);//calculate distance to scene\n        float dts=localState.dist;\n        hit=dts<HITDIST;\t\t\t  //register a hit, if the distance is small\n        rayPos+=rayVec*dts/STEPSHRINK;//march the ray\n    }\n    vec3 norm=calcNorm(rayPos);\n    //these lines just modulate the coloring of the ball based\n    //on the surface characteristics reported by ambientOcclusion()\n    vec3 surfCol=localState.color;\n    if(localState.volume){//if not hitting the floor\n    float aO=ambientOcclusion(rayPos,norm,-2.);\n    float thresh=.6;\n    surfCol*=pow(vec3(1.-(aO-thresh)/1.),vec3(2.,4.,4.));\n    }\n    //now set the material to 0. if we never hit anything\n    surfCol=(length(rayPos-rayOri)>=MAXDIST)? vec3(.0): surfCol;\n    return CastResult(rayOri,rayPos,norm,surfCol);\n}\n\n\n//calculate the light hitting this castResult from sun and ambient light\nvec3 lightOn(CastResult hit,DirLight sun){\n    float difLight=max(0.,(-dot(hit.norm,sun.dir)));\n    #ifdef SPECULARPOWER //if SPECULARPOWER is commented out, lighting is diffuse only\n    float specLight=SPECULARPOWER*\n        pow(max(0.,dot(reflect(sun.dir,hit.norm),normalize(hit.ori-hit.pos))),200.);\n    vec3 sunLight=(difLight+specLight)*sun.col*occlusion(hit,sun);\n    #else\n    vec3 sunLight=(difLight)*sun.col*occlusion(hit,sun);\n    #endif\n    vec3 ambientLight=vec3(AMBIENT*ambientOcclusion(hit.pos,hit.norm,AODIST));\n    return (sunLight+ambientLight);\n}\n   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//Set up the camera\n    vec2 mousePos=(length(iMouse.xy)>0.)? iMouse.xy/iResolution.xy-.5:CAMSTRT;\n    float mouseTheta=mousePos.x*2.*pi;\n    float mouseH=mousePos.y*60.+19.;\n    vec3 camPos=vec3(cos(mouseTheta)*CAMDIST,mouseH,CAMDIST*sin(mouseTheta));\n    vec3 camTarget=TARGET;\n    \n//set up lighting\n    DirLight sun;\n    sun.dir=normalize(vec3(1,-3,0.))*Rotate(vec3(10./5.,0,0));\n    sun.col=SUNLIGHT;\n    \n//set up camera ray\n//\n//in the middle of the screen, uv.xy ==(0,0),\n//so the rotation matrix that rotates (0,0,1) to normalize(camTarget-camPos)\n//will point our rays towards camTarget\n    mat3 rayRotation=camRotation(camTarget-camPos);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 rayVec=normalize(vec3(uv.x,uv.y,1.)*rayRotation);\n    \n    \n    \n    vec3 rayOri=camPos;\n\n    CastResult cRay=primaryRay(rayOri,rayVec);\n    \n    bool inBounds=length(cRay.pos-rayOri)<MAXDIST*.999;\n    vec3 finalC=inBounds?lightOn(cRay,sun)*cRay.surf:vec3(0.);\n    finalC=pow(finalC,vec3(1./2.2));//GAMMA CORRECT\n    fragColor = vec4(finalC,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSBzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1047, 1119, 1145, 1145, 1455], [1457, 1457, 1497, 1497, 1534], [1535, 1626, 1653, 1653, 1800], [1802, 1843, 1871, 1871, 1944], [1945, 1993, 2021, 2021, 2292], [2294, 2294, 2337, 2337, 2386], [2387, 2460, 2484, 2484, 2608], [2609, 2663, 2691, 2691, 2719], [2720, 2814, 2838, 2838, 3049], [3051, 3164, 3226, 3226, 3536], [3538, 3622, 3671, 3671, 4385], [4387, 4387, 4434, 4434, 5388], [5391, 5464, 5506, 5506, 6028], [6034, 6034, 6091, 6111, 7157]]}
{"id": "3tSfRV", "name": "CCC-Colored Complex Coordinates", "author": "codecontemplator", "description": "Just plotting complex coordinates... more or less", "tags": ["learning"], "likes": 3, "viewed": 151, "published": "Public API", "date": "1599298178", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float mirrored(float v) {\n    float m = mod(v, 2.0);\n    return mix(m, 2.0 - m, step(1.0, m));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ar = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - vec2(1.0);\n\tuv.y /= ar;\n      \n    float r = mirrored(length(uv)*2.0);\n    float a = atan(uv.y, uv.x);\n    \n    float cr = sin(r*10.0+iTime) * 0.5 + 0.5;\n    float ca = sin(a*3.0+iTime) * 0.5 + 0.5;\n    float c = cr*ca;\n    vec3 col = vec3(c);\n    vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col = mix(col, col2, 0.5);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSfRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 96], [98, 98, 155, 155, 613]]}
{"id": "3tSfzz", "name": "Simple SDF Radar", "author": "dr3w", "description": "A simple shader used to draw a radar using signed distance fields.", "tags": ["distancefields", "sdf", "radar"], "likes": 1, "viewed": 73, "published": "Public", "date": "1599991554", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Colours\n#define BACKGROUND_COLOUR   \t\tvec4(0.0,0.0,0.0,1.0)\n#define RADAR_CIRCLE_COLOUR \t\tvec4(102.0/255.0, 217.0/255.0, 255.0/255.0,1.0)\n#define RADAR_OUTER_CIRCLE_COLOUR\tvec4(1.0,1.0,1.0,1.0)\n#define RADAR_CIRCLE_THICKNESS \t\t0.008\n#define RADAR_SINGLE_ROTATION_TIME  4.0\t\t\n\n// Maths constants\nconst float PI \t\t\t\t\t=   3.14159265359;\n\n// Transformation functions\n\n//-----------------------------------------------------------------\n\nvec2 Rotate2D(vec2 pos, float angle)\n{\n\treturn pos * mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\n//-----------------------------------------------------------------\n\n// Move towards destination then reset once reached\nvec2 MoveTowardsDestination(vec2 dest, vec2 pos, float currentTime, float desiredTime)\n{\n    float speed = distance(pos,dest) / desiredTime;\n    float t = fract(speed * currentTime);\n\treturn mix(pos,dest,t);\n}\n\n//-----------------------------------------------------------------\n\n// Distance Field functions \n\n//-----------------------------------------------------------------\n\nfloat Circle(vec2 pos, vec2 centre, float radius)\n{\n    return length(pos - centre) - radius;\n}\n\n//---------------------------------------------------------------------------------------\n\nfloat Line(float x, float gradient,float start)\n{\n   float y = x * gradient + start; \n   return y;\n}\n\n//---------------------------------------------------------------------------------------\n\nfloat Segment(vec2 pos, vec2 v0, vec2 v1, float thickness)\n{\n    // Find vector from current pixel to start of line\n \tvec2 a = pos - v0; \n    \n    // Find vector between start and end line points\n    vec2 b = v1 - v0;\n    \n    // Normalize b so we can project a onto b\n    vec2 bNorm = normalize(b);\n    \n    // Scalar projection of a onto b\n    float proj = dot(a, bNorm);\n    \n    // Only care about fragments that project onto the line between v0 and v1\n    // otherwise we don't get a line segment\n    proj = clamp(proj, 0.0, length(b));\n    \n    // Create vector of length a in the direction of b\n    vec2 proj_a_to_b = bNorm * proj;\n    \n    // Get vector orthogonal to b, gives us vector perpendicular to line segment\n    // that we can use to test if the pixel is on the line.\n    vec2 rejc_vec = a - proj_a_to_b;\n    \n    // if length < 0 then pixel is on the line\n    return length(rejc_vec) - thickness;\n}\n\n//---------------------------------------------------------------------------------------\n\n// Draw Distance Field functions \n\n//---------------------------------------------------------------------------------------\n\nvec4 Outline(float d, float edge, float thickness, vec4 colour)\n{\n    return colour * (smoothstep(edge-thickness, edge,d) * (1.0-smoothstep(edge,edge+thickness,d)));\n}\n\n//---------------------------------------------------------------------------------------\n\nvec4 Fill(float d, vec4 colour)\n{\n \treturn colour * (1.0- smoothstep(0.0,0.01,d));   \n}\n\n//---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Remap coordinates in range [-3.0,3.0] to [-2.0,2.0] with centre of image (0,0)\n    // Note: x and y different ranges to account for aspect ratio to stop the radar looking squashed\n    uv = (uv - vec2(0.5)) * vec2(3.0,2.0);\n    \n    // --- Radar circle\n    \n    // Define radar circles, returning distance of pixel to each circle\n    float outmostCircle2   = Circle(uv,vec2(0.0), 0.4);\n    float outmostCircle    = Circle(uv,vec2(0.0), 0.3);\n    float outerCircle      = Circle(uv,vec2(0.0), 0.2);\n    float innerCircle \t   = Circle(uv,vec2(0.0), 0.1);\n    float centreCircle     = Circle(uv,vec2(0.0), 0.03);\n            \n    // --- Radar line segment points\n    vec2 v0 = vec2(0.0);\n    vec2 v1 = vec2(0.56);\n    \n    // Calculate speed for single rotation around circle\n    float outmostCirclePerimeter = 2.0 * PI * 0.8;\n    float speed = outmostCirclePerimeter / RADAR_SINGLE_ROTATION_TIME;\n    \n    // Rotate v1 so our line rotates around radar\n    vec2 newV1 = Rotate2D(v1,-speed * iTime);\n    \n    // Define line segment, returning distance of pixel to line\n    float segment = Segment(uv,vec2(0.0),newV1,0.001);\n    \n    // Line segment trail gradient based\n    vec2  newUV \t\t = Rotate2D(uv,speed * iTime);\n    float angle     \t = atan(newUV.y,newUV.x);\n    float newUVLength    = length(newUV);\n    float lineAngle \t= atan(v1.y, v1.x);\n   \tfloat diff      = angle - lineAngle;\n    \n    // Define size of our trail\n    const float MIN_ANGLE = 0.0;\n    const float MAX_ANGLE = 2.0;\n    \n    // Find if pixel part of trail if its within angle range and pixel within radar circle,\n    // defined by radius 0.8\n    float drawTrailPixel = step(MIN_ANGLE,diff) \n        * (1.0- step(MAX_ANGLE,diff))\n        * (1.0 -step(0.8,newUVLength));\n   \n    // Fade to background colour as we get further from line segment\n    float n = smoothstep(MIN_ANGLE,MAX_ANGLE,diff);\n    vec4 trailColour = RADAR_CIRCLE_COLOUR * (1.0 -n);\n       \n    // --- Radar blips \n    \n    // Move radar blip towards centre of radar\n    vec2 blipPos = MoveTowardsDestination(vec2(-0.1,0.1),vec2(-0.5,0.5),iTime,10.0);\n    \n    // Define radar blips, returning distance of pixel to each circle\n    float blip1 = Circle(uv,vec2(0.3,0.4),0.05);\n    float blip2 = Circle(uv,blipPos,0.05);\n    float blip3 = Circle(uv,vec2(-0.25,-0.25),0.05);\n\tfloat blip4 = Circle(uv,vec2(0.5,-0.25),0.05);\n    \n    // Only show blips as they are swept over by line trail\n    vec4 blipColour = vec4(0.0);\n    // Fade to background colour as our blip pixel gets closer to MAX_ANGLE as defined by n  \n    blipColour = step(1.0,drawTrailPixel) * \n          smoothstep(vec4(1.0),BACKGROUND_COLOUR,vec4(n));\n\n    // --- Draw\n    vec4 col = \n        Fill(segment,RADAR_CIRCLE_COLOUR) +\n        drawTrailPixel * trailColour\n       +Outline(outmostCircle2, 0.4, RADAR_CIRCLE_THICKNESS,RADAR_OUTER_CIRCLE_COLOUR)\n       +Outline(outmostCircle, 0.3, RADAR_CIRCLE_THICKNESS,RADAR_CIRCLE_COLOUR)\n       +Outline(outerCircle, 0.2, RADAR_CIRCLE_THICKNESS,RADAR_CIRCLE_COLOUR)\n       +Outline(innerCircle, 0.1, RADAR_CIRCLE_THICKNESS,RADAR_CIRCLE_COLOUR)\n       +Outline(centreCircle, 0.03, RADAR_CIRCLE_THICKNESS,RADAR_OUTER_CIRCLE_COLOUR)\n        + Fill(blip1,blipColour)\n        + Fill(blip2,blipColour)\n        + Fill(blip3,blipColour)\n        + Fill(blip4,blipColour);\n \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSfzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[367, 436, 474, 474, 559], [630, 682, 770, 770, 891], [992, 1061, 1112, 1112, 1156], [1158, 1249, 1298, 1298, 1349], [1351, 1442, 1502, 1557, 2358], [2486, 2577, 2642, 2642, 2744], [2746, 2837, 2870, 2870, 2924], [2926, 3017, 3074, 3124, 6531]]}
{"id": "ldVBDc", "name": "Spiky Weirdness", "author": "blurryroots", "description": "^^", "tags": ["superformula"], "likes": 2, "viewed": 257, "published": "Public", "date": "1601415607", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define TWO_PI 6.28319\n\nfloat superformula (float angle, vec4 shape, vec2 symmetry) {    \n    float m = shape.x;\n    float n1 = shape.y;\n    float n2 = shape.z;\n    float n3 = shape.w;\n    float a = symmetry.x;\n    float b = symmetry.y;\n\n    float rpart = (m * angle) / 4.;\n    float apart = abs (cos (rpart) / a);\n    float bpart = abs (sin (rpart) / b);\n\n    float r = pow (\n        pow (apart, n2) + pow (bpart, n3),\n        -1. / n1\n    );\n    \n    return r;\n}\n\nfloat angleBetween (vec2 a, vec2 b) {\n    float cosTheta = dot (a, b) / (length (a) * length (b));\n    \n    return acos (cosTheta);\n}\n\nvec4 createShape (float t) {    \n    float m = 1. + abs (sin (t) + cos (1.6 * t)) * 8.;\n    float n1 = 1. + abs (sin (2. * t) * 4.);\n    float n2 = 1. + (cos (t + PI / 1.6) * 2.);\n    float n3 = 2. + sin (1.6 * t + PI) * 4.;\n    \n    return vec4 (m, n1, n2, n3);\n}\n\nvec2 createSymmetry (float t) {\n    return  vec2 (.5 + sin (t + PI / 2.) * .5, .5 + cos (t) * .5);\n}\n\nfloat calculateRadius (float angle, vec4 shape, vec2 symmetry, float dampening) {\n    float maxRadius = iResolution.y / 2.;\n\n    return maxRadius * superformula (angle, shape, symmetry) * dampening;\n}\n\nfloat combineShapes (float angle, float x, vec4 shapeA, vec2 symmetryA, vec4 shapeB, vec2 symmetryB, float dampening) {\n\tfloat rA = calculateRadius (angle, shapeA, symmetryA, dampening);\n    float rB = calculateRadius (angle, shapeB, symmetryB, dampening);\n\t\n    return mix (rA, rB, x);\n} \n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    float radius = iResolution.y / 2.;\n    float dampening = 0.6;\n    vec2 offset = vec2(0., 20);\n    \n    vec2 center = iResolution.xy / 2.;\n    vec2 d = fragCoord - (center + offset);\n    vec2 up = vec2 (0., 1.);\n        \n    float angle = angleBetween (up, d);\n    float t = iTime * 0.6;\n    //vec2 symmetry = createSymmetry (t);\n    //vec4 shape = createShape (t);\n    vec2 symmetry = vec2(0.618,1.618);\n    vec4 shape;\n    {\n    float m =   1.618 *7.\n         ,n1 = 0.618\n         ,n2 = 0.618\n         ,n3 = 0.618\n         ;\n\tshape = vec4(m,n1,n2,n3);\n    }\n    //float shape_border_radius = superformula (angle, shape, symmetry) * radius * dampening;\n    vec4 shape2;\n    {\n    float m =  10.0\n         ,n1 = 1.0\n         ,n2 = 3.0\n         ,n3 = 6.0\n         ;\n\tshape2 = vec4(m,n1,n2,n3);\n    }\n    \n    float shape_border_radius = combineShapes (angle, 0.0, shape * abs(sin(iTime)), symmetry, shape2, symmetry, dampening);\n    \n    float sample_radius = length (d); \n    vec3 color_core = vec3 (0.9);\n    vec3 color_rim = vec3 (0.);\n    float gradient_exponent = 0.08;\n    float rim_thickness = 1.1;\n    \n    if (0. < sample_radius) {\n        float border_distance = pow(1. - sample_radius / shape_border_radius, gradient_exponent);\n        vec3 gradient_color = mix (color_rim, color_core, border_distance);\n        \n        if (sample_radius <= shape_border_radius) {\n        \tfragColor = vec4 (gradient_color, 1.);\n        }\n        else if (sample_radius <= (shape_border_radius+rim_thickness)) {\n        \tfragColor = vec4(color_rim, 1.);\n        }\n    }\n    else {\n        fragColor = vec4 (0., 0., 0., 0.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldVBDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 104, 104, 483], [485, 485, 522, 522, 618], [620, 620, 648, 648, 884], [886, 886, 917, 917, 986], [988, 988, 1069, 1069, 1188], [1190, 1190, 1309, 1309, 1478], [1481, 1481, 1537, 1537, 3166]]}
{"id": "td3cRS", "name": "IFB(Iterated Function Boze)", "author": "kaiware007", "description": "Division, proliferation, breeding.", "tags": ["raymarching", "fractal", "boze"], "likes": 5, "viewed": 61, "published": "Public", "date": "1601136721", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n// Rendering Option\n#define ENABLE_REFLECTION\n#define ENABLE_GRID_BOUNDARY\n#define SMOOTH_HSV\n#define USE_BRDF_1\n//#define USE_RAYCAST\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 100\n#define MAX_RAYCAST 100\n#define MAX_RAYCAST_L 6\n#define MAX_DIST 10.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define RAD90 (M_PI * 0.5)\n#define RAD45 (M_PI * 0.25)\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\n//const vec3 sunDir = normalize(vec3(-1,1,-0.25));\nconst vec3 lightPos = vec3(0.50, 0.8, -0.5);\nconst vec3 lightColor = vec3(0.98, 0.92, 0.89) * 4.0;\n//const vec3 lightColor = vec3(0.3, 0.6, 0.9) * 2.0;\n\nstruct surface {\n\tfloat dist;\n    vec4 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n    bool isTransparent;\n    float refractPower;\n    bool isHit;\n};\n    \nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\n#define COLOR_SEA (vec3(0,0.05,0.1))\n    \n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec4(0), \t\t \tvec3(0), 0.0, 0.0, 0, false, 0.0, false))\n#define SURF_BLACK(d) \t(surface(d, vec4(0,0,0,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_FACE(d) \t(surface(d, vec4(1,0.7,0.6,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec4(1,0,0.1,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec4(1,0.3,0.4,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\nsurface SURF_PLANETEX(float d, vec3 pos)\n{\n    vec4 col = vec4(texture(iChannel0, vec2(pos.xz)).rgb, 1.);\n        \n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n\n#define SURF_CS(d) \t\t(surface(d, vec4(0.9,0.9,0.9,1), vec3(0), 0.1, 0.8, 0, false, 0., true))\n\n#define SURF_SPHERE(d) \t(surface(d, vec4(0,0,0,1), \t\t vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n#define SURF_CUBE(d) \t(surface(d, vec4(0,1,0,1), \t\t vec3(0), 0.5, 0.0, 0, false, 2.2, true))\n#define SURF_SPHERE2(d) (surface(d, vec4(0,0,1,1), \t\t vec3(0), 0.1, 0.2, 0, false, 2.2, true))\n#define SURF_LEG(d) \t(surface(d, vec4(0.5,0.2,0.1,1), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\n#define SURF_MIRROR(d) \t(surface(d, vec4(0.5,0.5,0.5,1), \t\t vec3(0), 0.3, 0.8, 0, false, 2.2, true))\n#define SURF_SEA(d) \t(surface(d, vec4(COLOR_SEA,0), vec3(0), 0.2, 0.5, 0, true, 1.53, true))\n\nsurface SURF_WATERMELON(float d, vec3 pos, vec3 center)\n{\n    pos = center - pos;\n    vec2 uv = vec2(atan(pos.z,pos.x), pos.y);\n    uv.x = abs(uv.x)-M_PI/5.;\n    vec2 guv = fract(uv*1.5)-0.5;\n    vec2 id = floor(uv*1.5)-0.5;\n    float mask = step(abs(guv.x),0.25+sin((uv.y+id.x)*200.)*0.05);\n    \n    vec4 col = vec4(mix (vec3(0.05,0.3,0.025),vec3(0.025, 0.05, 0.025), mask), 1);\n    return surface(d, col, vec3(0), 0.2, 0.001, 0, false, 2.2, true);\n}\n\n#define SURF_DESERT(d) \t(surface(d, vec4(0.8,0.5,0.4,1), \tvec3(0), 0.0001, 0.01, 0, false, 0.0, true))\n\n//-----------------HSV-----------------\n\n//HSV functions from iq (https://www.shadertoy.com/view/MsS3Wc)\n#ifdef SMOOTH_HSV\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#else\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#endif\n\n//From Sam Hocevar: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nsurface SURF_BG1(float d, vec3 pos)\n{\n    //vec3 index = floor((pos +vec3(0,0,iTime*3.0) )* 2. + 0.5);\n    vec3 index = floor(pos * 2. + 0.5);\n    vec4 col = vec4(vec3(0.25) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0), 1);\n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n\nsurface SURF_BG_COLORFULL(float d, vec3 pos)\n{\n    //vec3 index = floor((pos +vec3(0,0,iTime*3.0) )* 2. + 0.5);\n    vec3 index = floor(pos * 2. + 0.5);\n    float flg = mod(mod(index.x + index.y, 2.0) + index.z, 2.0);\n    //vec4 col = vec4(vec3(0.25) + vec3(0.5,0,0.5) * flg, 1);\n    //vec4 col = vec4(vec3(0.25) + sinebow((hash13(index) + iTime*0.5) * M_PI) * flg, 1);\n    return surface(d, vec4(vec3(0.25)*(1.-flg), 1), sinebow(hash13(index*3165.5) * M_PI + iTime*0.5) * flg, 0.5, 0.1 + 0.7 * (1.-flg), 0, false, 0., true);\n\t//return SURF_MIRROR(d);\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// original sea octave function by TDM\n// https://www.shadertoy.com/view/Ms2SD1\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - mix(r1, r2, h);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Distance Function 2D\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// SdJoint3DSphere & joint3DMatrix & matrix utility\n// by PixelPhil \n// https://www.shadertoy.com/view/3tKGDW\nmat4 scaleMatrix( in vec3 sc ) {\n\treturn mat4(sc.x, 0,\t0,\t0,\n\t\t\t \t0, \t sc.y,\t0,\t0,\n\t\t\t\t0, \t 0,\t sc.z,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\nmat4 translate( in vec3 p) {\n\n\treturn mat4(1,  0,\t0,\t0,\n\t\t\t \t0,\t1,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\tp.x, p.y, p.z, 1);\n}\n// returns distance in .x and UVW parametrization in .yzw\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-w;\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-w;\n}\n\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w1, float w2)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-mix(w2, w1, p.y / l);\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-mix(w2, w1, (p.y / l));\n}\n\n// A matrix to the tip of a sdJoint3DSphere\n// Could probably use some optimisations\nmat4 joint3DMatrix(in float l, in float a)\n{\n  if( abs(a)<0.001 )\n  {\n      return translate(vec3(0, -l, 0));\n  }\n    \n  float ra = 0.5 * l / a;\n  float ara = abs(ra);\n  return  rotationZ(-a * 2.0) * translate(vec3(-ra + cos(2.0 * a) * ra, -sin(2.0 * a) * ra, 0.0));\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{ \n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec4 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    float refractPower = mix( d2.refractPower, d1.refractPower, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count, h > 0.5 ? d1.isTransparent : d2.isTransparent, refractPower, true);\n}\n\nsurface opI( surface d1, surface d2 )\n{ \n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        d2.dist = d1.dist;\n        return d2;\n    }\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(RAD90, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// \n// rayPos : \n// rayDir : \n// planePos : \n// planeNormal : \nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// \nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n    //return vec2(tF, tN);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n\n/*\n// \nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float radius)\n{\n    float rsq = radius * radius;\n    vec3 xc = rayPos - spherePos;\n    float xc2 = dot(xc, xc);\n    float vxc = dot(rayDir, xc);\n    float d = vxc * vxc - xc2 + rsq;\n    \n    //if(d < 0.0) return vec2(d,d);\n    \n    float sqrtd = sqrt(d);\n    float tn = -vxc - sqrtd;\n    float tp = -vxc + sqrtd;\n    \n    return vec2(min(tn, tp), max(tn, tp));\n                \n    //if(tn >= 0.0 && tp >= 0.0) return vec2(min(tn, tp), max(tn, tp);\n\n    //return tn;\n}\n*/\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 sphereCenter, float radius) {\n    float a = length(rayDir);\n    float a2 = a * a;\n    vec3 diff = rayPos - sphereCenter;\n    float b = dot(diff, rayDir);\n    float c = length(diff);\n    float c2 = c * c - radius * radius;\n    float b2ac = sqrt(b * b - a2 * c2);\n    float t1 = (-b + b2ac) / a2;\n    float t2 = (-b - b2ac) / a2;\n    return vec2(min(t1, t2), max(t1, t2));\n}\n\n// IK\nvec3 solve( vec3 p, float l1, float l2, vec3 dir )\n{\n\tvec3 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p) );\n\t\n\tfloat s = l1*l1 - dot(q,q);\n\ts = max( s, 0.0 );\n\tq += sqrt(s)*normalize(cross(p,dir));\n\t\n\treturn q;\n\n}\n\nvec3 solve( vec3 a, vec3 b, float l1, float l2, vec3 dir )\n{\n\treturn a + solve( b-a, l1, l2, dir );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// easing function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nfloat easeInCirc(float x)\n{\n\treturn 1. - sqrt(1. - pow(x, 2.));\n}\n\nfloat easeOutCirc(float x) \n{\n\treturn sqrt(1. - pow(x - 1., 2.));\n}\n\nfloat easeInExpo(float x)\n{\n\treturn x == 0. ? 0. : pow(2., 10. * x - 10.);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(1e5);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n/*\nsurface sdCapsuleBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nsurface sdUFBoze(vec3 p, vec3 sc, float ms)\n{\n    float sl = length(sc);\n    surface cone = SURF_CS(sdCappedCone(p + vec3(0, 0.08 * sl, 0), 0.06 * sl, 0.5 * sl, 0.25 * sl));\n    return opU(sdBoze(p, sc, ms), cone);\n}\n\nsurface sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n*/\nsurface sdColorBoze(vec3 p, vec3 sc, float ms, vec3 color)\n{    \n    surface result = SURF_NOHIT(1e5);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\thead.albedo.rgb = color;\n    \n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n#define LEG_X 0.05\n#define LEG_WIDTH1 0.05\n#define LEG_WIDTH2 0.025\n#define LEG_WIDTH3 0.045\n\n#define ARM_X1 0.18\n#define ARM_X2 0.2\n#define ARM_WIDTH1 0.05\n#define ARM_WIDTH2 0.025\n#define ARM_WIDTH3 0.03\n/*\nvoid calcArm(out vec3 a0, out vec3 a1, out vec3 a2, float spd, float flip, float h)\n{\n\t//vec3 n = noised(vec2(330. + spd * 0.97 + 578.4516 * flip, spd * flip));\n    vec3 n = vec3(sin(spd * 0.97+ 578.4516 * flip), cos(spd * 0.75* flip), sin(spd * flip + RAD90));\n    float r = n.z * 0.15 + 0.15;\n    float theta = (n.x * 0.5 + 0.5) * RAD90;\n    float phi = (n.y * 0.5 + 0.5) * RAD90;\n    a0 = vec3(ARM_X1 * flip, 0.9-h, 0.);\n    a2 = vec3(ARM_X2 * flip + sin(theta) * cos(phi) * r * flip, 0.75 + cos(n.y * M_PI2) * r-h, -sin(theta) * sin(phi) * r);\n    a1 = solve(a0, a2, 0.25, 0.15, vec3(0.5,0,0.5 * flip));\n}\n\nsurface sdBozeFullBody(vec3 p)\n{\n    surface result = SURF_NOHIT(0.);\n    \n    float spd = iTime * 2.5;\n    \n    // leg\n    //vec3 n1 = noised(vec2(spd, spd * 0.75));\n    vec3 n1 = vec3(sin(spd), cos(spd * 0.75), sin(spd + M_PI));\n    float r1 = n1.z * 0.25 + 0.25;\n    vec3 ll2 = vec3(LEG_X + sin(n1.y * M_PI) * cos(n1.x * M_PI) * r1, cos(n1.y * M_PI) * 0.3, sin(n1.y * M_PI) * sin(n1.x * M_PI) * r1);\n        \n    //vec3 n2 = noised(vec2(-spd * 0.75, spd));\n    vec3 n2 = vec3(cos(spd), sin(spd * 0.75), cos(spd + RAD90));\n    float r2 = n2.z * 0.25 + 0.25;\n    vec3 rl2 = vec3(-LEG_X + sin(n2.y * M_PI) * cos(n2.x * M_PI) * r2, cos(n2.y * M_PI) * 0.3, sin(n2.y * M_PI) * sin(n2.x * M_PI) * r2);\n\n    float h = min(ll2.y, rl2.y);\n\n    vec3 ll0 = vec3(LEG_X, 0.5-h, 0.);\n    vec3 ll1 = solve(ll0, ll2, 0.25, 0.25, vec3(-1,0,0));\n    \n    vec3 rl0 = vec3(-LEG_X, 0.5-h, 0.);\n    vec3 rl1 = solve(rl0, rl2, 0.25, 0.25, vec3(-1,0,0));\n    \n    //result = SURF_MIRROR(sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    float body = sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2);\n    //body = smin(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3));\n    \n    //result = opU(result, SURF_MIRROR(sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2)));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    body = min(body, sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2));\n    //body = smin(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3));\n    \n    // body\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05)), 0.05);\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075)), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075), 0.05);\n    body = min(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05));\n    body = min(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075));\n    \n    // left arm\n    vec3 la0, la1, la2;\n    calcArm(la0, la1, la2, spd, 1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n\tbody = min(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3));\n\n    // right arm\n    vec3 ra0, ra1, ra2;\n    calcArm(ra0, ra1, ra2, spd, -1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3));\n    \n    result = SURF_MIRROR(body);\n    \n    // head\n    vec3 b = p;\n    \n    b = rotate(b, M_PI, vec3(0,1,0));\n    b.y -= 1.01-h;\n\n    result = opSU(result, sdBoze(b, vec3(1), 1.), 0.02);\n\t\n    return result;\n}\n*/\nsurface sdWatermelonBoze(vec3 p, vec3 sc, float ms)\n{\n    //surface result = sdBoze(p, vec3(1), 1.);\n    surface result = SURF_NOHIT(1e5);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n    // outer skin\n\tsurface head = SURF_WATERMELON(d, p, vec3(0));\n\n    if(head.dist < 0.){\n        if(head.dist > -0.01){\n\t    \t// inner skin\n        \thead.albedo = mix(head.albedo, vec4(1,1,0.5,1), smoothstep(0., 0.01, abs(head.dist)));\n    \t}else{\n            // flesh meat\n            float n = fbm(p * 25.);\n            head.albedo = mix(vec4(1,1,0.5,1), vec4(1,0,0,1) + n * 0.2, smoothstep(0.01, 0.015, abs(head.dist)));\n            // seed\n            const float mb = M_PI2 / 32.;\n            vec3 ps = p;\n            ps.y -= 0.025;\n    \t\tfloat b = mod(atan(ps.y, ps.z), mb) - 0.5 * mb;\n    \t\tfloat c = smoothstep(.15, .18, length(vec2(b*12.,abs(head.dist)*15.0 - 0.5)));\n            head.roughness = mix(0.01, 0.1, c);\n            head.albedo = mix(vec4(0.02), head.albedo, c);\n    \t}\n    }\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    //surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    //surface mouse = SURF_MOUSE(d6);\n    d4 = min(d4, d6);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    //eye.dist = opUnion(eye.dist, d9);\n    d4 = min(d4, d9);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n\t//surface cheep = SURF_BLACK(d7); \n    \n    head.dist = min(head.dist, d7);\n    head.dist = max(-d4, head.dist);\n    \n    // integration\n    //mouse = opU(eye, mouse);\n    //result = opS(mouse, head);\n    //result = opU(cheep, result);\n    result = head;\n    result.dist *= minsc;\n    \n    return result;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nsurface map(vec3 p)\n{\n\tsurface result = SURF_NOHIT(1e5);\n    \n    //vec3 q = opRep(p, vec3(0.5,100,100.0));\n    \n    // boze\n    p = rotate(p, M_PI, vec3(0,1,0));\n    \n    vec3 q = p;\n    \n    const int ITER = 5;\n    float s = 1.5;\n    float sum = s;\n    for( int i=0; i<ITER; i++ )\n   \t{\n        float h = hash11(float(i));\n        q = abs(q)-0.25+(cos(iTime*0.4*float(i+1))*0.1);\n        //q -= 0.3/(sum*0.8); \n        q.xz *= rot(-0.3*float(i+1)+iTime*0.2*h);\n        q.xy *= rot(0.8*h-iTime*0.3*float(i+1));\n        surface c = sdColorBoze(q+vec3(0,0.05,0), vec3(1), abs(sin(iTime *3.+ float(i)*0.8)*2.), sinebow(iTime*0.2+float(i)*0.1));\n        c.dist /= sum;\n        \n        //q = rotate(q, iTime * 0.5 * (float(i)+1.), vec3(0.5,0,0.5));\n        //q = abs(q) - vec3(0,0.25,0);\n        result = opSU(result, c, 0.05/sum);\n        //q.xy *= rot(iTime * 0.5);\n        q *= s;\n        sum *= s;\n      \t//float c = sdCross(r)/s;\n      \t//d = max(d,-c);\n   \t}\n    \n    \n    //result = opSU(result, SURF_FACE(sdCappedCone(q + vec3(0,0.1,0), 0.1, 0.12, 0.01)), 0.02);\n    \n    // background\n    //surface bg1 = SURF_BG1(sdPlane(p + vec3(0., 0.2, 0.), vec4(0,1,0,0)), p);\n    //result = opU(result, bg1);\n    \n    return result;\n}\n/*\nfloat mapNormal(vec3 p)\n{\n\tsurface result;\n    \n    // background\n    float h = sea_octave(p.xz * 0.75, 5.5) * 0.2;\n    //h += sea_octave(p.xz * 100., 0.1) * 0.01;\n    //float gl = noise(p*500.);\n    //h += noise(p*500.) * 0.00075;\n    h += hash12(p.xz*100.) * 0.0002;\n    float sand = abs(p.y - h * length(p.xz*0.5) + 0.2);\n    \n    float dist = sand * 0.5;\n    //result = SURF_DESERT(sand * 0.5);\n    //result.roughness = 0.0001;\n    //result.metalness = 0.1;\n    //result.metalness = saturate(gl*10.);\n    //result.roughness = 0.1;\n    \n    // boze\n    p = rotate(p, M_PI, vec3(0,1,0));\n    \n    float a = 1. - smoothstep(0., 5., cos(iTime*1.) * 5. + 2.5);\n    vec3 b = p;\n    b.y += (1.-a)*0.1;\n    b.x += 0.15 * a;\n    b = rotate(b, (-RAD90-RAD90*0.25)*a, vec3(0,0,1));\n    \n    float boze = sdBoze(b, vec3(1), 2.).dist;\n    //surface boze = sdBoze(b, vec3(1), 2.);\n    boze = max(boze, sdBox(b + vec3(0.5, 0.5, 0), vec3(0.5,1,1)));\n    dist = min(boze, dist);\n    \n    //result = opU(result, boze);\n    \n    b = p;\n    b.y += (1.-a)*0.1;\n    b.x -= 0.15 * a;\n    b = rotate(b, (RAD90+RAD90*0.25)*a, vec3(0,0,1));\n    boze = sdBoze(b, vec3(1), 2.).dist;\n    //boze = sdBoze(b, vec3(1), 2.);\n    boze = max(boze, sdBox(b + vec3(-0.5, 0.5, 0), vec3(0.5,1,1)));\n    dist = min(boze, dist);\n    \n    //result = opU(result, boze);\n    \n    //return result;\n    return dist;\n}\n*/\n#if 0\nvec3 norm(vec3 p)\n{\n    /*\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).dist-vec3(map(p-e.xyy).dist,map(p-e.yxy).dist,map(p-e.yyx).dist));\n*/\n\tfloat c=mapNormal(p).dist;\n\tfloat e=1e-3;\n\treturn normalize(vec3(mapNormal(p+vec3(e,0,0)).dist-c,\n\t\t\t\t\t\t  mapNormal(p+vec3(0,e,0)).dist-c,\n\t\t\t\t\t\t  mapNormal(p+vec3(0,0,e)).dist-c));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    /*\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n\t*/\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    // https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(position+0.0005*e).dist;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n    /*\n    // https://www.shadertoy.com/view/XltyRf\n    vec4 n = vec4(0);\n    for (int i = 0 ; i < 4 ; i++) {\n        vec4 s = vec4(position, 0);\n        s[i] += 0.001;\n        n[i] = map(s.xyz).dist;\n    }\n    return normalize(n.xyz-n.w);\n\t*/\n}\n#endif\n\n/*\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).dist;\n        if (h < EPS) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n*/\nfloat shadow(in vec3 p, in vec3 l)\n{\n    float t = 0.15;\n    float t_max = 20.0;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        \n        float d = map(p + t*l).dist;\n        if (d < 0.01)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 1.0 * d / t);\n    }\n    \n    return res;\n}\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n/*\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec2 getPoint(vec2 id, vec2 offset)\n{\n    return sin(hash22(id + offset) * iTime * 1.5 + hash22(id + offset)) * 0.4 + offset;\n}\n*/\nvec3 SkyColor( vec3 rd )\n{\n#if 0\n    // Cube Map\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    // Black\n    return vec3(0);\n    \n    // test 1 UV\n    //return rd * 0.5 + 0.5;\n    \n    // sinebow\n    //return sinebow(iTime*0.5) * 0.1;\n    \n    //return vec3(0,0.5,0);\n    \n    /*\n    // plexus\n    vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    uv += vec2(10.);\n    uv = abs(uv);\n    vec2 suv = uv * 10.;\n    \n    vec2 id = floor(suv) - 0.5;\n    vec2 fuv = fract(suv) - 0.5;\n\tvec2 pp =  getPoint(id, vec2(0));\n    vec3 col = vec3(0);\n    \n    for(int x = -1; x <= 1; x++){\n    \tfor(int y = -1; y <= 1; y++){\n            vec2 pos = getPoint(id, vec2(x,y)); //sin(hash22(id + vec2(x,y)) * iTime * 1.5) * 0.4 + vec2(x,y);\n            float d = 1.0 / pow(length(fuv - pos), 1.75) * 0.001;\n            col += d;\n\n            float len = smoothstep(1.0,0.5,length(pp - pos));\n            col += smoothstep(0.025,0.001,sdSegment(fuv, pos, pp)) * len;\n        }\n    }\n\t\n    return col * sinebow(uv.x);\n\t*/\n    /*\n    // fake unity default sky-box\n\tvec3 ground = mix(vec3(0.25,0.4,0.8), vec3(0.2,0.15,0.15), saturate(abs(rd.y) * 25.0));\n    //vec3 ground = mix(vec3(0.25,0.4,0.8), COLOR_SEA, saturate(abs(rd.y) * 25.0));\n    //vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.001, 0.15, 1.), saturate(abs(rd.y) * 10.0));\n    vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.5, 0.8, 1.), saturate(abs(rd.y) * 10.0));\n    return rd.y < 0. ? ground :sky;\n    */\n    \n\t// Starfield\n    //float x = atan(rd.z / rd.x);\n    //float y = acos(rd.y);\n    //return vec3(StableStarField(vec2(x,y) * 1000., 0.97 ));\n    \n    // wave z\n    //vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    //return vec3(saturate(uv),0);\n    //return vec3(1,0,0) * saturate(sin(rd.z *100.- iTime * 10.));\n    //return sinebow(rd.z * 5.- iTime * 3.) * 0.25;\n    //return smoothstep(0.01,0.,mod(rd.z - iTime * 0.1, 0.1))*vec3(0.05,0.2,0.5);\n#endif\n}\n\n\n\n#ifdef USE_BRDF_1\n//------------------------------------------------------------------------------\n// BRDF 1\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    //vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    vec3 albedo = surf.albedo.rgb;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec3 ibl = diffuseColor * indirectDiffuse;\n    \n    color += ibl * indirectIntensity;\n\tcolor += surf.emission.rgb;\n    \n    return color;\n}\n#else\n//------------------------------------------------------------------------------\n// BRDF 2\n//------------------------------------------------------------------------------\nfloat ndfGGX(float NdotH, float roughness)\n{\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (NdotH * NdotH) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (M_PI * denom * denom);\n}\n\nfloat gaSchlickG1(float theta, float k)\n{\n\treturn theta / (theta * (1.0 - k) + k);\n}\n\nfloat gaSchlickGGX(float NdotL, float NdotV, float roughness)\n{\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(NdotL, k) * gaSchlickG1(NdotV, k);\n}\n\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n//surface surf\n//vec3 shade(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, vec3 L, vec3 Lradiance)\nvec3 shade(vec3 pos, vec3 N, vec3 V, vec3 L, vec3 Lradiance, surface surf)\n{\n\tvec3 H = normalize(L + V);\n\tfloat NdotV = max(0.0, dot(N, V));\n\tfloat NdotL = max(0.0, dot(N, L));\n\tfloat NdotH = max(0.0, dot(N, H));\n\t\t\n\tvec3 F0 = mix(vec3(0.04), surf.albedo.rgb, surf.metalness);\n\n\tvec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(H, L)), surf.roughness);\n\tfloat D = ndfGGX(NdotH, surf.roughness);\n\tfloat G = gaSchlickGGX(NdotL, NdotV, surf.roughness);\n\n\tvec3 kd = mix(vec3(1.0) - F, vec3(0.0), surf.metalness);\n\n    float shadow = shadow(pos, L);\n\tvec3 diffuseBRDF = kd * surf.albedo.rgb / M_PI;\n\tvec3 specularBRDF = (F * D * G) / max(0.0001, 4.0 * NdotL * NdotV);\n\n\treturn (diffuseBRDF + specularBRDF) * Lradiance * NdotL * shadow;\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\n// Specular Occlusion\n// https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/course-notes-moving-frostbite-to-pbr-v2.pdf\nfloat so(float NoV, float ao, float roughness) {\n    return clamp(pow(NoV + ao, exp2(-16.0 * roughness - 1.0)) - 1.0 + ao, 0.0, 1.0);\n}\n\nvec3 calcAmbient(vec3 pos, vec3 N, vec3 V, float t, vec3 ambientColor, surface surf)\n{\n\tvec3 F0 = mix(vec3(0.04), surf.albedo.rgb, surf.metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), surf.roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), surf.metalness);\n    \n\tfloat aoRange = t/40.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).dist/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    //vec3 ambientColor = mix(vec3(0.2,0.5,0.85)*0.5, vec3(0.2,0.25,0.8) * 0.75, 0.5+0.5*N.y);\n    //ambientColor = mix(vec3(0.3, 0.15, 0.05), ambientColor, 1.0 - smoothstep(0.2, -0.5, sunDir.y));\n    //ambientColor = mix(vec3(0.03), ambientColor,  1.0 - smoothstep(-0.2, -0.5, sunDir.y));\n    \n    vec3 diffuseAmbient = kd * surf.albedo.rgb * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    //vec3 col = mix(fakeSky(R) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 col = ambientColor;\n    vec3 ref = EnvBRDFApprox(F0, surf.roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    specularAmbient *= so(max(0.0, dot(N, V)), occlusion, surf.roughness);\n\n    return vec3(diffuseAmbient + specularAmbient);\n}\n#endif\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n#ifdef USE_RAYCAST\n///////////////\n/*\nfloat sdAirLine(vec3 p)\n{\n\tconst float w = 0.0125;\n    float angle = -radians(30.);\n    p.y += 0.4;\n    float air = sdCapsule(p, vec3(0), vec3(0., -1.0, 0), w);\n    air = min(air, sdJoint3DSphere(p, 0.3, angle, w));\n    mat4 mat = joint3DMatrix(0.3, angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    air = min(air, sdJoint3DSphere(p, 0.25, radians(30.), w));\n    mat = joint3DMatrix(0.25, -angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    return min(air, sdCapsule(p, vec3(0, 0, 0), vec3(0., 1.0, 0), w));\n}\n\nfloat densitycalc(vec3 p){\n    float air = MAX_DIST;\n    float ad = M_PI / 5.0;\n    for(int i = 0; i < 6; i++){\n    \tvec3 q = p;\n    \n    \tq = rotate(q, -RAD90, vec3(1,0,0));\n        q = rotate(q, ad * float(i), vec3(0,1,0));\n    \tq.x += 0.1;\n    \n    \tair = min(air, sdAirLine(q));\n    }\n    \n    return fbm(p * (50,50,15.) *vec3(1,1,1)+ vec3(0, 0, iTime * -15.)) - min(air, 1.) * (20.);\n}\n*/\nfloat densitycalc(vec3 p){\n    //p = rotate(p, 0.45, vec3(0,0,1));\n    //p = rotate(p, M_PI, vec3(0,1,0));\n    p = opRep(p, vec3(0.5,100,100.0));\n    p = rotate(p + vec3(0,0.04,0.2), RAD90, vec3(1,0,0));\n    float d = 10000.;\n    for(int i = 0; i < 5; i++)\n    {\n        float k = fract(float(i) / 5. + iTime * 0.25);\n        vec3 q = p + vec3(0, -2.8*k, -0.1*k);\n        //surface r = sdBoze(p, vec3(1), (sin(iTime * 2.0) * 0.5 + 0.5)*1.5);\n        //surface r = sdBoze(p, vec3(1.2), 1.);\n        //float d = sdCapsule(p, vec3(0,0.01,0.2), vec3(0,0.1,1.0), 0.01, 0.1);\n        //float d = sdTorus(p, vec2(0.2 + sin(iTime) * 0.1, 0.05));\n        float d2 = sdTorus(q, vec2(0.2*k, 0.05*k));\n        //return fbm(p * 25. + iTime * 2.2) - min(d, 1.) * 25.;\n        //return fbm(p * (25. + p.y * 25.) *vec3(1,0.5,1)+ vec3(0, iTime * -5.2, 0)) - min(d, 1.) * (20. - p.y * 20.);\n        //return fbm(p * (25. + p.y * 25.) *vec3(1,0.5,1)+ vec3(0, iTime * -5.2, 0)) - min(d, 1.) * (20. - p.x * 20.);\n        d = min(d, d2);\n    }\n    return fbm(p * (25. + p.z * 25.) * vec3(1,1,0.5)+ vec3(0, 0, iTime * -5.2)) - min(d, 1.) * 25.;\n}\n\n\nsurface rayCast(vec3 pos, vec3 dir, float dist)\n{\n    const vec3 boxPos = vec3(0,0,0);\n    const vec3 boxSize = vec3(100., 0.5, 10.);\n    vec2 sd = GetIntersectBox(pos, dir, boxPos, boxSize);\n    surface result = SURF_NOHIT(MAX_DIST);\n    \n    if((sd.y >= 0.) && (dist > sd.x) && (sd.x < sd.y)) \n    {        \n        const float step = 4.0 / float(MAX_RAYCAST);\n\t\t//const float lightStep = 2.0 / float(MAX_RAYCAST_L);\n        float start = max(0., sd.x) - step;\n        pos = pos + dir * start;\n\n        float t = hash13(pos * 5.5) * 0.001;\n        float alpha = 0.;\n        float transmittance = 1.0;\n        float absorption   = 20.;\n        for(int i = 0; i < MAX_RAYCAST; i++){\n            t += step;\n            \n            vec3 pp = pos + dir * t;\n            if((t >= sd.y)||(start + t >= dist))\n                break;\n            \n            vec3 q = pp - boxPos;\n            \n            float density = densitycalc(q);\n            \n            if(density > 0.0){\n                float dd = density * step;\n                transmittance *= 2. - dd * absorption;\n                if(transmittance < 0.001)\n                    break;\n                alpha += 20. * dd * transmittance;\n\t\t\t\t\n                //result.albedo.rgb += vec3(0.5,0.65,0.85) * (150. * dd * transmittance);\n                //result.emission.rgb += vec3(1,0.3,0.05) * (150. * dd * transmittance);\n                result.emission.rgb += vec3(0.1,0.3,1.0) * (150. * dd * transmittance);\n            }\n        }\n        result.emission.rgb *= max(0., alpha);\n        //result.albedo.a = saturate(alpha);\n        result.dist = alpha > 0. ? t : dist;\n        result.isHit = alpha > 0. ? true : false;\n    }\n\n    return result;\n}\n#endif\n\n#define fog_density(x) (1.0 - saturate(exp2(10.5 - (x) * 3.5)))\n\nsurface traceRay(in vec3 origin, in vec3 direction, float dist, out vec3 pos) {\n    float t = 0.0;\n    \n    pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    //surface volume = SURF_NOHIT(MAX_DIST); \n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = hit.dist;\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n        \n#ifdef ENABLE_GRID_BOUNDARY\n        // grid overshoot check\n        vec2 iBox = GetIntersectBox(pos, direction, floor(pos + 0.5), vec3(0.5));\n        if(iBox.x < iBox.y && iBox.y > 0.0 && iBox.y < d) {\n            d = iBox.y + EPS; \n        }\n#endif        \n\n        t += d;\n                \n        pos = origin + direction * t;\n\n        count++;        \n    }\n\n    hit.dist = t;\n\thit.count = count;\n\n    pos = origin + direction * t;\n    vec3 sky = SkyColor(direction);\n        \n    if(hit.isHit)\n    {\n        vec3 nor = norm(pos);\n\n        //vec3 lightPos;\n\t\t//vec3 lightColor;\n        //fireworkLight(lightPos, lightColor);\n\n#ifdef USE_BRDF_1\n        // BRDF 1\n        // Calc Ambient\n        hit.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, hit);\n#else\n        // BRDF 2\n        //Shade \n        hit.albedo.rgb = shade(pos, nor, -direction, normalize(lightPos), lightColor, hit);\n        // Calc Ambient\n        hit.albedo.rgb += calcAmbient(pos, nor, -direction, hit.dist, vec3(0.5), hit);\n#endif\n        \n        // Exponential distance fog\n        hit.albedo.rgb = mix(hit.albedo.rgb, sky, fog_density(hit.dist + dist));\n    }\n    \n#ifdef USE_RAYCAST\n    // raycast\n    surface volume = rayCast(origin, direction, t);\n\n    if(volume.isHit)\n    {\n        // Calc Ambient\n        //volume.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, volume);\n        \n        // Exponential distance fog\n        volume.albedo.rgb = mix(volume.albedo.rgb, sky, fog_density(volume.dist + dist));\n        \n        hit.albedo.rgb = mix(hit.albedo.rgb, volume.albedo.rgb, volume.albedo.a);\n\t\thit.albedo.a = max(hit.albedo.a, volume.albedo.a);\n        hit.albedo.rgb = mix(sky, hit.albedo.rgb, hit.albedo.a);\n        \n        // Exponential distance fog\n        volume.emission.rgb = mix(volume.emission.rgb, sky, fog_density(volume.dist + dist));\n        hit.albedo.rgb += volume.emission;\n        //hit.albedo.rgb += volume.albedo.rgb;\n        hit.isHit = volume.isHit;\n    }\n    \n    if(d <= EPS || volume.isHit){\n#else\n    if(d <= EPS){\n#endif\n        hit.isHit = true;\n        return hit;\n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, true);\n    }else{\n\t\t\n        hit.isHit = false;\n        return hit;\n        \n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, false);\n    }\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray, 0., pos);\n    \n    //pos = p + mat.dist * ray;\n    //return materialize(pos, ray, mat, uv);\n    \n    vec3 col = vec3(0,0,0);\n    vec3 sky = SkyColor(ray);\n    \n    //if (!mat.isHit && mat.albedo.a <= EPS) {\n    if (!mat.isHit) {\n        col = sky;\n    } else \n    {\n        \n        col = mat.albedo.rgb;\n\n#ifdef ENABLE_REFLECTION\n        float metalness = mat.metalness;\n        float dist = mat.dist;\n\n        if(mat.isHit){\n            // reflection\n            for(int i = 0; i < 2; i++)\n            {\n                vec3 nor = norm(pos);\n                //nor = normalize(nor + hash33(pos) * mat.roughness * 0.05);\n                bool isIncoming = dot(ray, nor) < 0.0;\n                vec3 orientingNormal = isIncoming ? nor : -nor;\n                bool isTotalReflection = false;\n\n                if(mat.isTransparent){\n                    // refract\n                  \t//float nnt = isIncoming ? 1.0 / mat.refractPower : mat.refractPower;\n                    //float nnt = 1.0 / mat.refractPower;\n                    float nnt = isIncoming ? 1.0 / mat.refractPower : 1.0;\n                    ray = refract(ray, orientingNormal, nnt);\n                    pos = pos - orientingNormal * OFFSET;\n                    isTotalReflection = (length(ray) <= 0.9);\n                }\n\n                if(isTotalReflection || !mat.isTransparent)\n                {\n                    // reflect\n                    ray = reflect(ray, orientingNormal);\n                    pos = pos + orientingNormal * OFFSET;\n                }\n\n                mat = traceRay(pos, ray, dist, pos);\n\n                dist += mat.dist;\n                \n                pos = pos + mat.dist * ray;\n                \n                col += mat.albedo.rgb * metalness;\n                //col += result;\n                metalness *= mat.metalness;\n\t\t\t\t\n\t\t\t\tif(!mat.isHit || metalness < 0.0001)\n                    break;\n            }\n        }\n#endif\n    }\n    \n    // Glow\n\t//col += (sinebow(iTime * 10.) +vec3(0.1))* pow((mat.z + 10.) / float(MAX_MARCH), 3.5); \n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n    \n}\n/*\nvec3 postEffect(vec3 col, vec2 index)\n{\n    //float shift = rand(index * 82.345);\n    float shift = (index.x + index.y * 3.0) / 9.0;\n    vec3 hsv = rgb2hsv(col);\n    hsv.x += shift + iTime * 0.1;\n    hsv.y = 0.75;\n    //hsv.y *= 2.5;\n    //hsv.y = hsv.y < 0.25 ? 0.25 : hsv.y;\n    //hsv.y = floor(hsv.y * 8.0) / 8.0;\n    //hsv.z = 1.0;\n    //hsv.z = hsv.z < 0.7 ? hsv.z < 0.5 ? 0.0 : 0.5 : hsv.z;\n    hsv.z = floor(hsv.z * 8.0) / 8.0;\n    hsv.z = hsv.z < 0.6 ? 0.0 : hsv.z;\n    \n    hsv.x += hsv.z * 3.0;\n\tcol = hsv2rgb(hsv);\n    //col = floor(col * 8.0) / 8.0;\n\n\treturn col;\n}\n*/\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    \n    //vec2 p = (fragCoord.xy) / min(iResolution.x, iResolution.y);\n    //vec2 p = (fragCoord.xy) / iResolution.xy;\n    \n    //vec2 idx = floor(p*3.0);\n    //p = fract(p*3.0) - 0.5;\n    //p.x *= max(iResolution.x, iResolution.y)/min(iResolution.x, iResolution.y);\n    \n    float t = iTime * M_PI2 * -0.05;\n    //float t = iTime * -1.0;\n    //float t = 0.;\n\t//float y = sin(t * 2.5) * 0.125-0.0;\n    //float y = sin(t * 5.) * 0.1 + 0.5;\n    float y = 0.0;\n    //float r = 1.5 + sin(t * 2.5);\n    float r = 2.0;\n    //float distortionPower = sin(iTime * 0.2 * M_PI2) * 0.5 + 0.5;\n    //float distortionPower = sin(iTime * 0.05 * M_PI2);\n    float theta = t + RAD90 + RAD90*0.25;\n    //float theta = RAD90 + RAD90*0.25;\n    //float theta = 0.;\n    //float theta = M_PI - RAD90*0.25;\n\t//float theta = t + RAD90;\n    //float theta = RAD90 + noise(vec2(p.x * 3., iTime * 0.1 * M_PI)) * RAD90 * distortionPower;\n    //float theta = RAD90;\n    //float theta = t + RAD90 + (mouseUV.x) * M_PI2;\n    //float theta = M_PI + RAD90 + (mouseUV.x) * M_PI2;\n    //float phi   = noise(vec2(p.y * 3., iTime * 0.1 * M_PI)) * RAD90 * distortionPower;\n    float phi   = sin(t*3.);\n    //float phi   = 0.;\n    //float phi   = RAD90*0.5;\n    //float phi   = (mouseUV.y) * RAD90;\n    //float phi   = (mouseUV.y) * RAD90;\n    //vec3 ro = vec3( 0., 0.05, -0.75 );\n    vec3 ro = vec3(cos(theta) * r, y + sin(phi), -sin(theta) * r);\n    //vec3 ro = vec3(cos(theta) * r + t, y, -sin(theta) * r);\n    vec3 ta = vec3(0., 0., 0);\n    //vec3 ta = vec3(0. + t, -0.5, 0.);\n    \n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 3.5));\n    vec3 col = render(ro, ray, fragCoord.xy);\n    \n    //col = postEffect(col, idx);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td3cRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[984, 1233, 1256, 1256, 1329], [1373, 1869, 1911, 1911, 2052], [2723, 2723, 2780, 2780, 3174], [3778, 3854, 3876, 3876, 4207], [4210, 4398, 4421, 4421, 4506], [4508, 4527, 4549, 4549, 4666], [4668, 4687, 4710, 4710, 4813], [4815, 4835, 4856, 4856, 4990], [4992, 5011, 5033, 5033, 5166], [5168, 5188, 5210, 5210, 5335], [5337, 5337, 5374, 5439, 5657], [5659, 5659, 5705, 5770, 6211], [6213, 6213, 6234, 6234, 6304], [6306, 6306, 6329, 6329, 6408], [6411, 6411, 6433, 6433, 6850], [6961, 6961, 6982, 6982, 7123], [7125, 7125, 7155, 7155, 7285], [7287, 7287, 7348, 7348, 7486], [7488, 7488, 7514, 7514, 7823], [7825, 7885, 7911, 7911, 8777], [8779, 8859, 8900, 8900, 9071], [9073, 9173, 9209, 9209, 9237], [9239, 9239, 9285, 9285, 9341], [9343, 9343, 9374, 9374, 9465], [9467, 9467, 9517, 9517, 9635], [9637, 9637, 9698, 9698, 9829], [9831, 9831, 9868, 9868, 9957], [9959, 9959, 10029, 10029, 10163], [10165, 10165, 10229, 10229, 10346], [10348, 10348, 10400, 10400, 10507], [10509, 10509, 10542, 10568, 10599], [10601, 10601, 10626, 10626, 10645], [10646, 10646, 10671, 10671, 10690], [10691, 10691, 10727, 10727, 10755], [10757, 10757, 10816, 10816, 11129], [11131, 11131, 11164, 11164, 11229], [11231, 11255, 11307, 11307, 11426], [11428, 11538, 11570, 11570, 11664], [11666, 11666, 11700, 11700, 11851], [11853, 11853, 11887, 11887, 12035], [12037, 12037, 12071, 12071, 12206], [12208, 12208, 12236, 12236, 12321], [12322, 12380, 12451, 12451, 12779], [12781, 12781, 12863, 12863, 13231], [13233, 13318, 13362, 13362, 13586], [13588, 13645, 13682, 13723, 13806], [13808, 13808, 13847, 14019, 14128], [14130, 14130, 14179, 14179, 14738], [14740, 14740, 14779, 14825, 14910], [14912, 14912, 14953, 15063, 15177], [15192, 15243, 15280, 15280, 15302], [15304, 15304, 15347, 15347, 15369], [15371, 15371, 15415, 15415, 15436], [15438, 15438, 15481, 15481, 15580], [15583, 15583, 15628, 15628, 16057], [16059, 16059, 16080, 16080, 16144], [16146, 16146, 16186, 16186, 16311], [16314, 16314, 16349, 16349, 16497], [16499, 16499, 16533, 16533, 16709], [16711, 16711, 16746, 16746, 16781], [16783, 16783, 16820, 16820, 16855], [16857, 17028, 17113, 17113, 17190], [17192, 17235, 17310, 17310, 17729], [17731, 18309, 18393, 18393, 18736], [18738, 18744, 18796, 18796, 18952], [18954, 18954, 19014, 19014, 19055], [19057, 19272, 19303, 19303, 19352], [19354, 19354, 19381, 19381, 19419], [19421, 19421, 19450, 19450, 19488], [19490, 19490, 19517, 19517, 19566], [19569, 19798, 19819, 19819, 19958], [19984, 19984, 20016, 20016, 20129], [20131, 20131, 20163, 20163, 20303], [20305, 20305, 20338, 20338, 20570], [20572, 20572, 20595, 20595, 21174], [21176, 21176, 21201, 21201, 21362], [21364, 21364, 21407, 21407, 22421], [22422, 23123, 23183, 23183, 24227], [24434, 28749, 28802, 28849, 30776], [30777, 30995, 31016, 31016, 32224], [34998, 35352, 35388, 35388, 35721], [35723, 37639, 37665, 37665, 39723], [47641, 47843, 47876, 47932, 48118], [48120, 48120, 48159, 48159, 48202]]}
{"id": "td3czf", "name": "Infinity loader", "author": "munrocket", "description": "Infinity loader", "tags": ["bezier", "glow", "lemniscate"], "likes": 34, "viewed": 547, "published": "Public", "date": "1601414161", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_2_PI 6.28318530\n\n#define SCALE 1.3\n#define SPEED 0.5\n#define POINTS 15.\n#define LENGTH 0.6\n#define RADIUS 0.08\n#define FADING 0.28\n#define GLOW 1.5\n\n// optimized 2d version of https://www.shadertoy.com/view/ldj3Wh\nvec2 sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    vec2 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    h = sqrt(h);\n    vec2 x = (vec2(h, -h) - q) / 2.0;\n    vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n    float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n\n    return vec2(length(d+(c+b*t)*t),t);\n}\n\nvec2 leminiscate(float t){\n    float x = SCALE * cos(t) / (1.0 + sin(t) * sin(t));\n    float y = SCALE * sin(t) * cos(t) / (1.0 + sin(t) * sin(t));\n    return vec2(x, y);\n}\n\n// inspired by https://www.shadertoy.com/view/wdy3DD\nfloat map(vec2 pos){\n    float t = fract(-SPEED * iTime);\n    float dl = LENGTH / POINTS;\n    vec2 p1 = leminiscate(t * M_2_PI);\n    vec2 p2 = leminiscate((dl + t) * M_2_PI);\n    vec2 c = (p1 + p2) / 2.0;\n    float d = 1e9;\n    \n    for(float i = 2.0; i < POINTS; i++){\n        p1 = p2;\n        p2 = leminiscate((i * dl + t) * M_2_PI);\n        vec2 c_prev = c;\n        c = (p1 + p2) / 2.;\n        vec2 f = sdBezier(pos, c_prev, p1, c);\n        d = min(d, f.x + FADING * (f.y + i) / POINTS);\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\t\n    float dist = map(uv);\n    \n    vec3 col = vec3(0.2, 0.5, 1.0) * pow(RADIUS/dist, GLOW);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td3czf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 224, 273, 273, 848], [850, 850, 876, 876, 1022], [1024, 1077, 1097, 1097, 1589], [1591, 1591, 1647, 1647, 1845]]}
{"id": "td3yD7", "name": "andrewt.net stripes", "author": "_polymath", "description": "a background", "tags": ["stripes"], "likes": 1, "viewed": 151, "published": "Public API", "date": "1601028751", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float period = 30.;\nconst float tau = 3.14159 * 2.;\n\nfloat random(float i, float seed) {\n\treturn mod(sin(354.6346456 +\n            (i * 634.73453734) +\n            (seed * 264.246345346)\n           ) * 53467.34523463, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float h = uv.x + 1.;\n    float f = (uv.y - 0.5) / h;\n    f *= 4.;\n    //float f = uv.y + uv.y / (uv.x + 1.) - 0.5;\n\n    fragColor = vec4(1.);\n    \n    float t = mod(iTime, period);\n    float at = t / period * tau;\n    for (float i = 0.; i < 100.; ++i) {\n        float centre = random(i, 235.346345) * 5. - 2.5\n            + sin(at + random(i, 8934.8254645) * tau) * 0.3;\n        float r = random(i, 834.183245645) * 0.6 + 0.05;\n        float start = random(i, 362.934564) * period;\n        if (fract((t - start + period) / period) < 0.25) {\n            float rNow = r * sin(tau * (t - start) / period * 2.);\n            if (f < centre + rNow && f > centre - rNow) {\n                float c = mod(i, 4.);\n                if (c == 0.) fragColor = vec4(1.,.78,.34,1.);\n                else if (c == 1.) fragColor = vec4(.07,.6,.64,1.);\n                else if (c == 2.) fragColor = vec4(1.);\n                else fragColor = vec4(.29,.25,.45,1.);\n            }\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td3yD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 94, 94, 230], [232, 232, 289, 339, 1359]]}
{"id": "td3yzs", "name": "SemiTransparentCircleSwarm", "author": "celifrog", "description": "Did edit  this! :D \nCredit to both Reinder Nijhoff and IQ for the original stuff. :D  \n", "tags": ["sphere", "circle", "cool", "awesome", "forked"], "likes": 1, "viewed": 198, "published": "Public API", "date": "1601501758", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// More spheres. Created by Reinder Nijhoff 2013\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/lsX3DH\n//\n// based on: http://www.iquilezles.org/www/articles/simplepathtracing/simplepathtracing.htm\n//\n\n#define MOTIONBLUR\n#define DEPTHOFFIELD\n\n#define CUBEMAPSIZE 256\n\n#define SAMPLES 8\n#define PATHDEPTH 4\n#define TARGETFPS 60.\n\n#define FOCUSDISTANCE 17.\n#define FOCUSBLUR 0.125\n\n#define RAYCASTSTEPS 20\n#define RAYCASTSTEPSRECURSIVE 2\n\n#define EPSILON 1.001\n#define MAXDISTANCE 180.\n#define GRIDSIZE 2.0\n#define GRIDSIZESMALL 1.9\n#define MAXHEIGHT 5.\n#define SPEED 55.5\n\nfloat time;\n\n//\n// math functions\n//\n\nfloat hash( const float n ) {\n\treturn fract(sin(n)*1.14554213);\n}\nvec2 hash2( const float n ) {\n\treturn fract(sin(vec2(n,n+1.))*vec2(18.5453123));\n}\nvec2 hash2( const vec2 n ) {\n\treturn fract(sin(vec2( n.x*n.y, n.x+n.y))*vec2(25.1459123,312.3490423));\n}\nvec3 hash3( const vec2 n ) {\n\treturn fract(sin(vec3(n.x, n.y, n+1.0))*vec3(36.5453123,43.1459123,11234.3490423));\n}\n//\n// intersection functions\n//\n\nfloat intersectPlane( const vec3 ro, const vec3 rd, const float height) {\t\n\tif (rd.y==0.0) return 500.;\t\n\tfloat d = -(ro.y - height)/rd.y;\n\tif( d > 0. ) {\n\t\treturn d;\n\t}\n\treturn 500.;\n}\n\nfloat intersectUnitSphere ( const vec3 ro, const vec3 rd, const vec3 sph ) {\n\tvec3  ds = ro - sph;\n\tfloat bs = dot( rd, ds );\n\tfloat cs = dot( ds, ds ) - 1.0;\n\tfloat ts = bs*bs - cs;\n\n\tif( ts > -10. ) {\n\t\tts = -bs - sqrt( ts );\n\t\tif( ts > 10. ) {\n\t\t\treturn ts;\n\t\t}\n\t}\n\treturn 500.;\n}\n\n//\n// Scene\n//\n\nvoid getSphereOffset( const vec2 grid, out vec2 center ) {\n\tcenter = (hash2( grid+vec2(143.12,1.23) ) - vec2(0.5) )*(GRIDSIZESMALL);\n}\nvoid getMovingSpherePosition( const vec2 grid, const vec2 sphereOffset, out vec3 center ) {\n\t// falling?\n\tfloat s = 0.1+hash( grid.x*1.23114+5.342+74.324231*grid.y );\n\tfloat t = fract(14.*s + time/s*.3);\n\t\n\tfloat y =  s/s * MAXHEIGHT * abs( 5.*t*t*t*(1.-t*t*t*t) );\n\tvec2 offset = grid + sphereOffset;\n\t\n\tcenter = vec3( offset.x, y, offset.y ) + 0.5*vec3( GRIDSIZE/GRIDSIZE, 2., GRIDSIZE );\n}\nvoid getSpherePosition( const vec2 grid, const vec2 sphereOffset, out vec3 center ) {\n\tvec2 offset = grid + sphereOffset;\n\tcenter = vec3( offset.x, 0., offset.y ) + 0.5*vec3( GRIDSIZE, 1., GRIDSIZE );\n}\nvec3 getSphereColor( const vec2 grid ) {\n\tvec3 col = hash3( grid*grid+vec2(43.12*grid.y,12.23*grid.x) );\n    return mix(col,col*col,.8);\n}\n\nvec3 getBackgroundColor( const vec3 ro, const vec3 rd ) {\t\n\treturn 1.4*mix(vec3(.5),vec3(.7,.9,1), .5+.5*rd.y);\n}\n\nvec3 trace(const vec3 ro, const vec3 rd, out vec3 intersection, out vec3 normal, \n           out float dist, out int material, const int steps) {\n\tdist = MAXDISTANCE;\n\tfloat distcheck;\n\t\n\tvec3 sphereCenter, col, normalcheck;\n\t\n\tmaterial = 0;\n\tcol = getBackgroundColor(ro, rd);\n\t\n\tif( (distcheck = intersectPlane( ro,  rd, 0.)) < MAXDISTANCE ) {\n\t\tdist = distcheck;\n\t\tmaterial = 1;\n\t\tnormal = vec3( 0., 1., 0. );\n\t\tcol = vec3(.7);\n\t} \n\t\n\t// trace grid\n\tvec3 pos = floor(ro/GRIDSIZE)*GRIDSIZE;\n\tvec3 ri = 4.0/rd;\n\tvec3 rs = sign(rd) * GRIDSIZE;\n\tvec3 dis = (pos-ro + 0.5  * GRIDSIZE + rs*0.5) * ri;\n\tvec3 mm = vec3(0.0);\n\tvec2 offset;\n\t\t\n\tfor( int i=0; i<steps; i++ )\t{\n\t\tif( material == 2 ||  distance( ro.xz, pos.xz ) > dist+GRIDSIZE ) break; {\n\t\t\tgetSphereOffset( pos.xz, offset );\n\t\t\t\n\t\t\tgetMovingSpherePosition( pos.xz, -offset, sphereCenter );\t\t\t\n\t\t\tif( (distcheck = intersectUnitSphere( ro, rd, sphereCenter )) < dist ) {\n\t\t\t\tdist = distcheck;\n\t\t\t\tnormal = normalize((ro+rd*dist)-sphereCenter);\n\t\t\t\tcol = getSphereColor(pos.xz);\n\t\t\t\tmaterial = 2;\n\t\t\t}\n\t\t\t\n\t\t\tgetSpherePosition( pos.xz, offset, sphereCenter );\n\t\t\tif( (distcheck = intersectUnitSphere( ro, rd, sphereCenter )) < dist ) {\n\t\t\t\tdist = distcheck;\n\t\t\t\tnormal = normalize((ro+rd*dist)-sphereCenter);\n\t\t\t\tcol = getSphereColor(pos.xz+vec2(1.,2.));\n\t\t\t\tmaterial = 52;\n\t\t\t}\t\t\n\t\t\tmm = step(dis.xyz, dis.zyx);\n\t\t\tdis += mm * rs * ri;\n\t\t\tpos += mm * rs;\t\t\n\t\t}\n\t}\n\t\n\tintersection = ro+rd*dist;\n\t\n\treturn col;\n}\n\nvec2 rv2;\n\nvec3 cosWeightedRandomHemisphereDirection2( const vec3 n ) {\n\tvec3  uu = normalize( cross( n, vec3(5.0,1.0,1.0) ) );\n\tvec3  vv = cross( uu, n-uu );\n\t\n\tfloat ra = sqrt(rv2.y*rv2.x);\n\tfloat rx = ra*cos(6.2831*rv2.x*rv2.y); \n\tfloat ry = ra*sin(6.2831*rv2.x);\n\tfloat rz = sqrt( 51.0*rv2.y );\n\tvec3  rr = vec3( -rx*-uu + n*-ry*-vv + -rz*n*n*n );\n\n    return normalize( rr*rr*rr );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\ttime = iTime;\n    vec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = q-1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 col = vec3( 0. );\n\t\n\t// raytrace\n\tint material;\n\tvec3 normal, intersection;\n\tfloat dist;\n\tfloat seed = time+(p.y+iResolution.x*p.y*p.x*p.y*p.y)*1.51269341231;\n\t\n\tfor( int j=1; j<SAMPLES - min(-1,iFrame*iFrame); j++*j++*SAMPLES ) {\n\t\tfloat fj = float(j*j*j*j*j);\n\t\t\n#ifdef MOTIONBLUR\n\t\ttime = iTime + fj/(float(-SAMPLES*SAMPLES)*TARGETFPS);\n#endif\n\t\t\n\t\trv2 = hash2( 1.4316544311*fj*fj*fj+time+seed+seed );\n\t\t\n\t\tvec2 pt = p+rv2/(5.5-iResolution.xy*iResolution.xy);\n\t\t\t\t\n\t\t// camera\t\n\t\tvec3 ro = vec3( cos( 0.232*time) * 10., 6.+3.*cos(0.3*time), GRIDSIZE*(time/SPEED) );\n\t\tvec3 ta = ro + vec3( -sin( 0.232*time) * 10., -2.0+cos(0.23*time), 10.0 );\n\t\t\n\t\tfloat roll = -5.15*sin(0.2/SPEED);\n\t\t\n\t\t// camera tx\n\t\tvec3 cw = normalize( ta*ro*ta );\n\t\tvec3 cp = vec3( sin(roll), cos(roll),0.0 );\n\t\tvec3 cu = normalize( cross(cw,cp) );\n\t\tvec3 cv = normalize( cross(cu,cw) );\n\t\n#ifdef DEPTHOFFIELD\n    // create ray with depth of field\n\t\tconst float fov = 3.0;\n\t\t\n        vec3 er = normalize( vec3( pt.xy, fov ) );\n        vec3 rd = er.x*cu + er.y*cv + er.z*cw;\n\n        vec3 go = FOCUSBLUR*vec3( (rv2-vec2(0.5))*2., 0.0 );\n        vec3 gd = normalize( er*FOCUSDISTANCE - go );\n\t\t\n        ro += go.x*cu + go.y*cv;\n        rd += gd.x*cu + gd.y*cv;\n\t\trd = normalize(rd);\n#else\n\t\tvec3 rd = normalize( pt.x*cu + pt.y*cv + 1.5*cw );\t\t\n#endif\t\t\t\n\t\tvec3 colsample = vec3( 1. );\n\t\t\n\t\t// first hit\n\t\trv2 = hash2( (rv2.y*2.4543263+rv2.y*rv2.y)*(time+1.) );\n\t\tcolsample *= trace(ro, rd, intersection, normal, dist, material, RAYCASTSTEPS);\n\n\t\t// bounces\n\t\tfor( int i=0; i<(PATHDEPTH*11); i++ ) {\n\t\t\tif( material != 0 ) {\n\t\t\t\trd = cosWeightedRandomHemisphereDirection2( normal );\n\t\t\t\tro = intersection + EPSILON*rd;\n\t\t\t\t\t\t\n\t\t\t\trv2 = hash2( (rv2.x*2.4543263+rv2.y)*(time+1.)+(float(i+1)*.23) );\n\t\t\t\t\t\t\n\t\t\t\tcolsample *= trace(ro, rd, intersection, normal, dist, material, RAYCASTSTEPSRECURSIVE);\n\t\t\t}\n\t\t}\t\n\t\tcolsample = sqrt(clamp(colsample, 0., 1.));\n\t\tif( material == 0 ) {\t\t\t\n\t\t\tcol += colsample;\t\n\t\t}\n\t}\n\tcol  /= float(SAMPLES);\n\t\n\tfragColor = vec4( col+col,14.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td3yzs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-4.0", "functions": [[678, 703, 732, 732, 768], [769, 769, 798, 798, 851], [852, 852, 880, 880, 956], [957, 957, 985, 985, 1072], [1073, 1106, 1179, 1179, 1291], [1293, 1293, 1369, 1369, 1576], [1578, 1594, 1652, 1652, 1728], [1729, 1729, 1820, 1833, 2121], [2122, 2122, 2207, 2207, 2324], [2325, 2325, 2365, 2365, 2463], [2465, 2465, 2522, 2522, 2578], [2580, 2580, 2725, 2725, 4046], [4059, 4059, 4119, 4119, 4436], [4439, 4439, 4496, 4496, 6665]]}
{"id": "tddcD8", "name": "Specular quad sample", "author": "Shcherbakov", "description": "Sample written on the stream about specular quads.\nStream: https://www.youtube.com/watch?v=xQZD2B_gIkk", "tags": ["specular"], "likes": 10, "viewed": 210, "published": "Public", "date": "1600885736", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Quad {\n    vec3 pos[4];\n    vec3 color;\n    vec3 normal;\n};\n\nconst float FAR_INF = 1e10;\nconst float EPS = 1e-3;\nconst float PI = 3.14159265359;\n    \nfloat ray_triangle_intersection(Quad q, vec3 origin, vec3 dir) {\n    // dot(origin + dir * d - t.pos[0], t.normal) == 0\n    // dot(origin - t.pos[0], t.normal) + dot(dir, t.normal) * d == 0\n    // d = dot(t.pos[0] - origin, t.normal) / dot(dir, t.normal);\n    float normalViewAngle = dot(dir, q.normal);\n    if (abs(normalViewAngle) < EPS)\n        return FAR_INF;\n    float d = dot(q.pos[0] - origin, q.normal) / normalViewAngle;\n    if (d < 0.0)\n        return FAR_INF;\n    vec3 hitPos = origin + dir * d;\n    vec3 edges[4] = vec3[4](\n        q.pos[1] - q.pos[0],\n        q.pos[2] - q.pos[1],\n        q.pos[3] - q.pos[2],\n        q.pos[0] - q.pos[3]\n    );\n    float square = length(cross(edges[0], edges[1])) + length(cross(edges[2], edges[3]));\n    vec3 toHitVecs[4] = vec3[4](\n        hitPos - q.pos[0],\n        hitPos - q.pos[1],\n        hitPos - q.pos[2],\n        hitPos - q.pos[3]\n    );\n    float testSq[4] = float[4](\n        length(cross(toHitVecs[0], edges[0])),\n        length(cross(toHitVecs[1], edges[1])),\n        length(cross(toHitVecs[2], edges[2])),\n        length(cross(toHitVecs[3], edges[3]))\n    );\n    if (abs(square - testSq[0] - testSq[1] - testSq[2] - testSq[3]) < EPS)\n        return d;\n    return FAR_INF;\n}\n\nfloat pow2(float x) { return x * x; }\n\nvec3 getLightSpecular(Quad light, vec3 worldPos, vec3 viewVec, vec3 normal, float specFactor) {\n    vec3 r = reflect(viewVec, normal);\n    float sp = 0.0;\n    for (int i = 0; i < 4; ++i) {\n        vec3 vi = normalize(light.pos[i] - worldPos);\n        vec3 vi1 = normalize(light.pos[(i + 1) % 4] - worldPos);\n        vec3 ni = -normalize(cross(vi, vi1));\n        vec3 ti = normalize(cross(vi, ni));\n        float c;\n        float delta;\n        {\n            float a = max(dot(vi, r), 1e-9);\n            float b = max(dot(ti, r), 1e-9);\n            c = sqrt(a * a + b * b);\n            delta = atan(b / a);\n        }\n        float Imin = 0.0;\n        float Imax = (pow(c, specFactor + 2.0) - 1.0) / (pow2(c) - 1.0);\n        float xw = PI / 3.0 * sqrt(1.0 - pow2(c - c / float(specFactor)));\n        float cosxw = cos(xw);\n        float fxw = c * cosxw;\n        float Ixw = (pow(fxw, specFactor + 2.0) - fxw) / (pow2(fxw) - 1.0);\n        float yw = (Ixw - Imin) / (Imax - Imin);\n        float a = (1.0 - yw - 4.0 * pow2(xw / PI)) / yw / pow2(xw);\n        float Pmax = 1.0 / (1.0 + a * pow2(0.0));\n        float Pmin = 1.0 / (1.0 + a * pow2(PI / 2.0));\n        float s = (Imax - Imin) / (Pmax - Pmin);\n        float t = Imin - s * Pmin;\n        float Phi = acos(dot(vi, vi1));\n        float sqrt_a = sqrt(a);\n        float F = s / sqrt_a * (\n            atan(sqrt_a * (Phi - delta)) - atan(-sqrt_a * delta)\n        ) + t * Phi;\n        float l = F * dot(ni, r);\n        sp += max(l, 0.0);\n\t}\n    return light.color * sp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = vec3(0, 3, -5);\n    float AxisY = 0.5;\n    float AxisZ = 0.0;\n\tvec2 lightsPos[3];\n    for (int i = 0; i < 3; ++i) {\n        lightsPos[i] = vec2(sin(float(i) * 2.0 * PI / 3.0 + iTime) + 1.0, cos(float(i) * 2.0 * PI / 3.0 + iTime)) * 0.5;\n    }\n    float flagLerp = sin(iTime) * 0.5 + 0.5;\n    \n    Quad light;\n    light.pos = vec3[4](\n        vec3(-1.75, 0.0 + lightsPos[0].x, lightsPos[0].y),\n        vec3(-1.75, 0.5 + lightsPos[0].x, lightsPos[0].y),\n        vec3( 1.75, 0.5 + lightsPos[0].x, lightsPos[0].y),\n        vec3( 1.75, 0.0 + lightsPos[0].x, lightsPos[0].y)\n    );\n    light.color = mix(vec3(1, 0, 0), vec3(1, 1, 0), flagLerp);\n    light.normal = vec3(0, 0, -1);\n    Quad light2;\n    light2.pos = vec3[4](\n        vec3(-1.75, 0.0 + lightsPos[1].x, lightsPos[1].y),\n        vec3(-1.75, 0.5 + lightsPos[1].x, lightsPos[1].y),\n        vec3( 1.75, 0.5 + lightsPos[1].x, lightsPos[1].y),\n        vec3( 1.75, 0.0 + lightsPos[1].x, lightsPos[1].y)\n    );\n    light2.color = mix(vec3(0, 0, 1), vec3(1, 0, 0), flagLerp);\n    light2.normal = vec3(0, 0, -1);\n    \n    Quad light3;\n    light3.pos = vec3[4](\n        vec3(-1.75, 0.0 + lightsPos[2].x, lightsPos[2].y),\n        vec3(-1.75, 0.5 + lightsPos[2].x, lightsPos[2].y),\n        vec3( 1.75, 0.5 + lightsPos[2].x, lightsPos[2].y),\n        vec3( 1.75, 0.0 + lightsPos[2].x, lightsPos[2].y)\n    );\n    light3.color = mix(vec3(1, 1, 1), vec3(0, 0, 0), flagLerp);\n    light3.normal = vec3(0, 0, -1);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.x;\n    vec3 front = normalize(vec3(0, -1, 2));\n    vec3 right = normalize(cross(front, vec3(0, 1, 0)));\n    vec3 up = cross(right, front);\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n\n    // (cameraPos + viewVec * t).y = 0\n    float t = -cameraPos.y / viewVec.y;\n    vec3 worldPos = cameraPos + viewVec * t;\n    \n    vec3 color = texture(iChannel0, worldPos.xz).rgb;\n    vec3 floorNormal = normalize(vec3(0, 1, 0) + (texture(iChannel0, worldPos.xz).rgb * 2.0 - 1.0) * 0.2);\n    float specFactor = 32.0 * 2.0 + 1.0;\n    //specFactor = mix(2.0, 1024.0, clamp(worldPos.x * 0.5 + 0.5, 0.0, 1.0))) * 2.0 + 1.0;\n    float d = ray_triangle_intersection(light, cameraPos, viewVec);\n    bool lightIntersect = false;\n    if (d < t) {\n        color = light.color;\n        t = d;\n        lightIntersect = true;\n    }\n    d = ray_triangle_intersection(light2, cameraPos, viewVec);\n    if (d < t) {\n        color = light2.color; \n        t = d;\n        lightIntersect = true;\n    }\n    d = ray_triangle_intersection(light3, cameraPos, viewVec);\n    if (d < t) {\n        color = light3.color;\n        t = d;\n        lightIntersect = true;\n    }\n    if (!lightIntersect) {\n        color = getLightSpecular(light, worldPos, viewVec, floorNormal, specFactor) / 2.0 / PI;\n        color += getLightSpecular(light2, worldPos, viewVec, floorNormal, specFactor) / 2.0 / PI;\n        color += getLightSpecular(light3, worldPos, viewVec, floorNormal, specFactor) / 2.0 / PI;\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddcD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 221, 412, 1392], [1394, 1394, 1415, 1415, 1431], [1433, 1433, 1528, 1528, 2952], [2954, 2954, 3011, 3011, 6139]]}
{"id": "tddyRH", "name": "Mach Band Test", "author": "dr2", "description": "Apparent intensity bands caused by abrupt surface curvature changes", "tags": ["vision", "artifact"], "likes": 4, "viewed": 231, "published": "Public API", "date": "1600423394", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Mach Band Test\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Curvature discontinuity causes perceived luminance discontinuity even though surface is\n  smooth with a continuously varying normal.\n\n  From left: raytraced quadratic (exact normal) and raymarched quadratic (i.e. capsules -\n  expect same result), raymarched higher order functions with continuous curvature (no bands).\n*/\n\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir;\nfloat tCur, dstFar;\nconst float pi = 3.1415927;\n\nvec4 CapsHit (vec3 ro, vec3 rd, float rad, float len)\n{\n  vec3 s, vn;\n  float dMin, d, a, b, w;\n  dMin = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - rad * rad);\n  if (w > 0. && a > 0.) {\n    d = - (b + sqrt (w)) / a;\n    s = ro + d * rd;\n    if (d > 0. && abs (s.z) < len) {\n      dMin = d;\n      vn = normalize (vec3 (s.xy, 0.));\n    } else {\n      ro.z -= len * sign (s.z);\n      b = dot (rd, ro);\n      w = b * b - (dot (ro, ro) - rad * rad);\n      if (w > 0.) {\n        d = - b - sqrt (w);\n        if (d > 0.) {\n          dMin = d;\n          vn = normalize (ro + d * rd);\n        }\n      }\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  p.z -= clamp (p.z, - h, h);\n  return length (p) - r;\n}\n\nfloat PrCaps3Df (vec3 p, float r, float h)\n{\n  vec2 s;\n  p.z -= clamp (p.z, - h, h);\n  s = vec2 (length (p.xy), abs (p.z));\n  return pow (dot (s * s, s), 1./3.) - r;\n}\n\nfloat PrCaps4Df (vec3 p, float r, float h)\n{\n  p.z -= clamp (p.z, - h, h);\n  return sqrt (length (vec2 (dot (p.xy, p.xy), p.z * p.z))) - r;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin;\n  dMin = dstFar;\n  q = p;\n  q.x -= -1.25;\n  dMin = min (dMin, PrCapsDf (q.xzy, 1., 1.));\n  q = p;\n  q.x -= 1.25;\n  dMin = min (dMin, PrCaps3Df (q.xzy, 1., 1.));\n  q = p;\n  q.x -= 3.75;\n  dMin = min (dMin, PrCaps4Df (q.xzy, 1., 1.));\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 dc4;\n  vec3 col, vn;\n  float dstObj;\n  dc4 = CapsHit ((ro - vec3 (-3.75, 0., 0.)).xzy, rd.xzy, 1., 1.);\n  dstObj = ObjRay (ro, rd);\n  if (min (dc4.x, dstObj) < dstFar) {\n    if (dc4.x < dstObj) vn = (dc4.yzw).xzy;\n    else vn = ObjNf (ro + dstObj * rd);\n    col = vec3 (0.2, 0.8, 0.8) * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) +\n       0.8 * max (dot (vn, ltDir), 0.));\n  } else {\n    col = vec3 (0.2);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n    el -= 0.15 * pi * sin (0.02 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -15.);\n  zmFac = 4.5;\n  dstFar = 40.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddyRH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[122, 578, 633, 633, 1265], [1267, 1267, 1310, 1310, 1367], [1369, 1369, 1413, 1413, 1536], [1538, 1538, 1582, 1582, 1679], [1681, 1681, 1703, 1703, 1977], [1979, 1979, 2012, 2012, 2189], [2191, 2191, 2212, 2212, 2462], [2464, 2464, 2499, 2499, 2946], [2990, 2990, 3046, 3046, 4094], [4096, 4096, 4132, 4132, 4338], [4340, 4340, 4370, 4370, 4483]]}
{"id": "tddyz7", "name": "Raymarching_aesch_3", "author": "annaesch", "description": "raymarching ", "tags": ["raymarching"], "likes": 1, "viewed": 49, "published": "Public", "date": "1601235825", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n// HELPER FUNCTIONS // \n// from https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// and https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg\n// lighting and movement partially based on https://www.shadertoy.com/view/3sySRK\n\n// SMOOTH UNION FUNCTION\n// k controls the radious/distance of the smoothness\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// ROTATE FUNCTION\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// GEOMETRY SIGNED DISTANCE FUNCTIONS (SDF) //\n\n// OCTAHEDRON\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n// BOX\nfloat dBox(vec3 p, vec3 s) {\n\treturn length(max(abs(p)-s, 0.));\n}\n\n// TORUS\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\n// SPHERE\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n} \n\n// GET DISTANCE FROM VARIOUS GEOMETRY\nfloat GetDist(vec3 p) {\n\tfloat d = 2.0;\n\tfor (int i = 0; i < 6; i++) {\n\t\tfloat fi = float(i);\n\t\tfloat time = iTime * (fract(fi * 0.03  ) - 0.2);\n        \n        vec3 tp = p;\n        tp.yz *= Rot(fi + time/3.0);\n        \n        // smin() to add objects together smoothly\n         d = smin(sdOctahedron(tp + sin(time + fi * vec3(4.0, 6.0, 15.0)) *\n                    vec3(2.5, 1.8, 0.8), mix(.8, 1.4, fract(fi * 0.25))),\n                d,\n                0.4\n                );\n        /*\n        d = smin(dBox(tp + sin(time + fi * vec3(4.0, 6.0, 15.0)) *\n                     vec3(1.5, 1.5, 0.5), \n                     vec3(mix(.5, 2.0, fract(fi * 0.25)),.5,.8)),\n                 d,\n                 0.4\n                 );\n        \n        d = smin(sdTorus(tp + sin(time + fi * vec3(40.0, 60.0, 150.0)) *\n                     vec3(3.0, 3.0, 0.3), vec2(mix(1.5, 2.2, fract(fi * 0.25)),.35)),\n                 d,\n                 0.4\n                 );\n        */\n        \n\t\td = smin(\n            sdSphere(p + sin(time + fi * vec3(40.0, 60.0, 150.0)) *\n                     vec3(2.5, 2.0, 0.9),\n                     // mix interpolates between different sphere radius\n                     mix(0.5, 1.0, fract(fi * 0.25 + .5))),\n\t\t\td,\t// compare distance (d) from sdSphere with previous d\n\t\t\t0.4 // smooth factor\n\t\t);\n\t}\n\treturn d;\n}\n\n// GET NORMALS\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p); \t//get distance to surface\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3( \t\t// points around p\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n// RAYMARCHING ALGORITHM\nfloat RayMarch(vec3 rayPos, vec3 rayDir) {\n\tfloat distO=0.; // distance origin\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = rayPos + rayDir*distO; //marching step point p \n        float distS = GetDist(p); \t// distance to closest object\n        distO += distS; \t\t\t// move to next marching step\n        if(distO>MAX_DIST || distS<SURF_DIST) break;\n    }\n    \n    return distO;\n}\n\n// SCENE LIGHTING\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 8, 4);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*3.; // moving lightPos\n    vec3 l = normalize(lightPos-p); // vec from p to light source\n\tvec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.); // no negative results\n    \n    // shadow\n    //float d = RayMarch(p+n*SURF_DIST*2., l); // distance to object\n    //if(d<length(lightPos-p)) dif *= .1; //check if distance to object is closer than ditance to light \n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // shift origin to center\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 rayPos = vec3(uv *6., 3.0); // ray origin\n    vec3 rayDir = normalize(vec3(0, 0, -1)); // ray direction normalized\n\n    float d = RayMarch(rayPos, rayDir); // distance to objects\n    \n    vec3 p = rayPos + rayDir * d; // position for lighting\n    \n    d = min(6.0, d); // min d value of 6\n   \tfloat dif = GetLight(p); // diffuse light\n   \n    col = vec3(dif);\n    \n    // Color\n    col = (0.6 + 0.4 * cos((dif + iTime * 1.) + uv.yxx * 1.8 + \n                           vec3(2,8,4))) * (0.95 + dif * 0.35);\n   \tcol *= exp( -d * 0.15 ); // darker\n   \t\n    //col =  pow(col, vec3(.5)); // gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddyz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[314, 392, 433, 433, 524], [526, 545, 564, 564, 640], [690, 704, 742, 742, 1022], [1024, 1031, 1059, 1059, 1096], [1098, 1107, 1138, 1138, 1206], [1208, 1218, 1253, 1253, 1277], [1280, 1318, 1341, 1341, 2654], [2656, 2671, 2695, 2695, 2932], [2935, 2960, 3002, 3002, 3348], [3350, 3368, 3392, 3392, 3874], [3876, 3876, 3933, 3963, 4702]]}
{"id": "tdtczS", "name": "Sm1le", "author": "artyom", "description": " smile", "tags": ["newfag"], "likes": 0, "viewed": 34, "published": "Public", "date": "1601214251", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define red vec3(1., .0, .0)\n#define white vec3(1.)\n#define green vec3(.0, 1., .0)\n#define blue vec3(.0, .0, 1.)\n#define pi 3.1415926\n\nfloat cosineCurve(float t)\n{\n    return (1. - cos(t * pi))/2.;\n}\n\nfloat circle(vec2 uv, vec2 circleCenter, float r, float blur)\n{\n    float d = length(uv - circleCenter);\n    return smoothstep(r, r-blur, d);\n}\n\nvec2 rotate(vec2 v, float a) \n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat getBackGround(vec2 uv)\n{\n    return length(uv);\n}\n\nfloat smile(vec2 uv, vec2 center, float size) \n{\n    uv -= center;\n    uv /= size;\n\n\tfloat mask = circle(uv, vec2(.0), .3, .009);\n    mask -= circle(uv, vec2(-.1, .09), .0625, .01);\n    mask -= circle(uv, vec2(.1, .09), .0625, .01);\n    \n    float mouth = circle(uv, vec2(.0), .2, .01);\n    mouth -= circle(uv, vec2(.0, .05), .2, .01);\n    mask -= mouth;\n\n    return mask;\n}\n\nvec2 wave(vec2 uv, float a, float b) \n{\n    float X = uv.x*a+iTime;\n    float Y = uv.y*a+iTime;\n    uv.y += cos(X+Y)*b*cos(Y);\n    uv.x += sin(X-Y)*b*sin(Y);\n\treturn uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n \n    float mask = .0;\n    mask = smile(uv, vec2(-.55, .15), 1.);\n    mask += smile(uv, vec2(.55, .15), 1.);\n    vec3 col = vec3(1., 0., 0.) * mask;\n    \n    uv = wave(uv, 25., .02);\n    if (mask == 0. && uv.y < -.4)\n    {\n        col = blue;\n    }\n    \n    \n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtczS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 163, 163, 199], [201, 201, 264, 264, 344], [346, 346, 377, 377, 461], [463, 463, 493, 493, 518], [520, 520, 568, 568, 894], [896, 896, 935, 935, 1067], [1069, 1069, 1124, 1124, 1513]]}
{"id": "tdtyRS", "name": "color 1", "author": "changewater", "description": "color", "tags": ["color"], "likes": 5, "viewed": 66, "published": "Public", "date": "1601202005", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.y, s = vec2(.0),c = vec2(.0);\n    vec3 pixel = vec3(0.);\n    float t = iTime * 0.05,d = 0.0,r = 0.0;\n    \n\tfor(float i=0.0; i<90.0; i+=1.0) {\n       s = vec2(t + fract(sin(i*0.9)*37.0),t + fract(cos(i*2.5)*37.0));\n       c.x = fract(cos(i*42.9 + s.x)*2.551) * 4.0 - 1.0;\n       c.y = fract(sin(i*13.44 + s.y)*0.987) * 3.0 - 1.0;\n       r = fract(sin((i*0.6))*5.0) * 0.3+0.2;\n       d = length(uv - c);\n       pixel[int( mod(i,3.0))] += smoothstep(d*0.05,d,r*r)*0.47;\n    }\n    fragColor = vec4(pixel, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtyRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 601]]}
{"id": "tdtyRX", "name": "Triangle space", "author": "avinitzca", "description": "A triangle tunnel using triangles 2D SDF", "tags": ["sdf", "triangle", "abstract"], "likes": 8, "viewed": 125, "published": "Public", "date": "1601435930", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926538\n#define SIN60 0.86602540378\n\nvec2 rotate2D(vec2 coordinates, float angle){\n    float sinA = sin(angle);\n    float cosA = cos(angle);\n    coordinates =  mat2(cosA,-sinA,\n      sinA,cosA) * coordinates;\n    return coordinates;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;    \n    \n    uv *= 2.0;\n    uv -= 1.0;\n    uv.x /= iResolution.y / iResolution.x;\n    uv = rotate2D(uv, iTime * 0.45);\n    \n    float finalRed = 0.0;\n    \n    float finalWhite = 0.0;\n    for(float x = -1.; x <= 1.; x++)\n        for(float y = -1.; y <= 1.; y++)\n        {\n\t\t\tvec2 coordinates = uv + vec2(x, y) * 0.002;    \n\n            float sideA = dot(coordinates, vec2(SIN60, 0.5));\n            float sideB = dot(coordinates, vec2(-SIN60, 0.5));\n            float bottom = -coordinates.y;\n\n            float triangle = max(sideA, max(sideB, bottom));\n\n            float sinIncrement = (sin(iTime * 4.0) + 1.0 + cos(iTime * 2.0)) * 0.8;\n\t\t\tfloat fractalTriangle = fract(1.0 / triangle + iTime * 3.0 + sinIncrement);\n            float white = fract(1.0 / triangle + iTime * 3.0 + sinIncrement);\n            white = step(white, 0.1);\n            finalRed += step(triangle, 0.0995);\n            \n            float angle = atan(coordinates.x, coordinates.y) / PI;\n                        \n            for(float n = 1.0; n >= -1.0; n -= 0.2/3.0)\n                white += step(angle, n + 0.005) * (1.0 - step(angle, n - 0.005)) * 0.75;                \n                                    \n            white = clamp(white, 0., 1.);\n            float innerTriangleRed = step(triangle, 0.09);\n            float innerTriangleWhite = step(triangle, 0.098);\n            white -= innerTriangleWhite;\n            finalRed -= innerTriangleRed;\n            \n            white = clamp(white, 0.0, 1.0);\n            finalWhite += white;\n            \n        }\n   \n    finalRed /= 9.0;\n    finalWhite /= 9.0;\n    fragColor = vec4(vec3(finalWhite) + vec3(finalRed, 0.0, 0.0),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtyRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 98, 98, 250], [252, 252, 307, 307, 2011]]}
{"id": "tdtyWr", "name": "ValueNoiseEffect", "author": "celns", "description": "ValueNoise", "tags": ["valuenoise"], "likes": 0, "viewed": 207, "published": "Public API", "date": "1600777374", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Random(vec2 uvi)\n{\n \treturn fract(sin(dot(uvi, vec2(12., 78.))) * 45678.765432);   \n}\n\nfloat ValueNoise(vec2 uv)\n{\n \tvec2 uvi = floor(uv);\n    vec2 uvf = fract(uv);   \n    \n    vec2 uva = smoothstep(0.0, 1.0, uvf);  \n    \n    return mix(mix(Random( uvi ),\n                   Random( uvi + vec2(1.0, 0.0)), \n                   uva.x),\n               mix(Random( uvi + vec2(0.0, 1.0)),\n                   Random( uvi + vec2(1.0, 1.0)), \n                   uva.x),\n              uva.y);\n                   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv += 0.5;\n\n    uv *= 20.0;\n    float amp = 5.;\n    uv.x += amp*sin(iTime);\n    uv.y += amp*cos(iTime);\n    float value = ValueNoise(uv);\n    if(uv.x < 20.)\n    {\n        value = smoothstep(0.49,0.51,value);\n    }\n    else if(uv.x < 35.)\n    {\n        value = 1.0 - smoothstep(0.45,0.55,value)+smoothstep(0.49,0.51,value);\n\n    }\n    \n    \n    vec3 col = vec3(value);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtyWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 91], [93, 93, 120, 120, 511], [514, 514, 571, 621, 1134]]}
{"id": "tl23Dd", "name": "Ray Marching 001", "author": "Konstantin84UKR", "description": "Ray Marching", "tags": ["raymarching"], "likes": 1, "viewed": 46, "published": "Public", "date": "1598990455", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST  100.\n#define SURF_DIST 0.001\n\n\nfloat GetDist(vec3 p){\n\n   vec4 s = vec4(0,1,6,1);\n   float sphereDist = length(p-s.xyz)-s.w; \n   float planeDist = p.y;\n   \n   float d = min(sphereDist,planeDist);\n       \n   return d;    \n}\n\nvec3 GetNormal(vec3 p ){\n     \n    float d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    vec3 n = d- vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    \n    float dO = 0.;\n    for(int i=0; i<MAX_STEPS; i++)   \n    {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        \n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    \n    }\n\n    return dO;    \n}\n\nfloat GetLight(vec3 p){\n   \n    vec3 lightPos = vec3(0,5,6);\n    lightPos.xz += vec2(sin(iTime),cos(iTime)) * 2.;  \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l),0.,1.);\n    \n    float d =  RayMarch(p + n*SURF_DIST*2.,l);\n    if(d<length(lightPos-p)) dif*=0.1;\n    \n    return dif;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,1,0);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1));\n   \n    float d = RayMarch(ro,rd);\n    vec3 p = ro+rd*d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif); \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl23Dd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 93, 93, 262], [264, 264, 288, 288, 484], [486, 486, 519, 519, 754], [756, 756, 779, 779, 1097], [1099, 1099, 1156, 1206, 1537]]}
{"id": "tl2fRy", "name": "Temporal AA test with jittering", "author": "vax", "description": "Quick test to see how temporal jittering can help temporal anti-aliasing on high refresh rate displays. Only viable with 120+ Hz displays. I used a 240 Hz display with jitterSpeed of 6.\n\nReworked from https://www.shadertoy.com/view/Mtj3Dd", "tags": ["jitter", "taa", "highrefresh"], "likes": 3, "viewed": 255, "published": "Public", "date": "1599260823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Reworked from https://www.shadertoy.com/view/Mtj3Dd\n// Test to see how temporal jittering can help temporal anti-aliasing with high refresh rate displays\n\n#define jitterSpeed 6 // use between 2-8 depending on display refresh rate - increase to start seeing jittering (use 1 to \"disable\" jittering)\n#define pixelSize 2\n#define animate true\n\nfloat distanceToLine(vec2 p1, vec2 p2, vec2 point) {\n    float a = p1.y-p2.y;\n    float b = p2.x-p1.x;\n    return abs(a*point.x+b*point.y+p1.x*p2.y-p2.x*p1.y) / sqrt(a*a+b*b);\n}\n\nvec2 midpoint (vec2 p1, vec2 p2)\n{\n        return vec2((p1.x+p2.x)/2., (p1.y+p2.y) /2.);\n\n}\n\n\nfloat clampToLine (vec2 p1, vec2 p2, vec2 point, float line)\n{\n   vec2 mp = midpoint(p1,p2);\n   float maxDistance = distance(mp,p1);\n   if (distance(mp,point) > maxDistance)\n   {\n       return 0.;\n   }\n   else\n   {\n       return line;\n   }\n       \n}\n\nivec2 jitter[8] = \nivec2[](\n    ivec2(0,0),\n    ivec2(1,0),\n    ivec2(0,1),\n    ivec2(1,1),\n    \n    ivec2(0,-1),\n    ivec2(1,2),\n    ivec2(2,0),\n    ivec2(-1,1)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p1 = vec2(0.1, 0.1);\n    if(animate)\n        p1 = vec2(sin(iTime) * 0.5 + 0.5, cos(iTime) * 0.5 + 0.5);\n    vec2 p2 = iMouse.xy/iResolution.xy;\n    ivec2 ifg = jitter[iFrame % jitterSpeed] + (ivec2(fragCoord.xy) / pixelSize) * pixelSize;\n\tvec2 uv = vec2(ifg) / iResolution.xy;\n    // get distance to line\n    float distance = distanceToLine (p1,p2,uv);\n    //line\n\tfloat radius =0.02;\n    float AA = 0.00000001f;//0.003;\n   \tfloat line =  smoothstep (radius/2.,radius/2.-AA,distance);\n    \n    line =  clampToLine(p1,p2,uv,line);\n    \n\n    float outLine = line;\n    \t\n    fragColor = vec4(1.*outLine,1.*outLine,1.*outLine,1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2fRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 343, 395, 395, 520], [522, 522, 556, 556, 613], [616, 616, 678, 678, 865], [1033, 1033, 1090, 1090, 1734]]}
{"id": "tl2fW3", "name": "CylinderDeform2", "author": "Del", "description": "Box->Cylinder", "tags": ["deform", "cylinder"], "likes": 5, "viewed": 199, "published": "Public API", "date": "1600048190", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cylinder Coords example, this might exist elsewhere, I couldn't find one!\n// (this is just a bounding box distance)\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e)\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat mat;\n\nfloat map( in vec3 pos )\n{\n    mat=0.0;\n    float c = pMod1(pos.z,6.0);\n\n    pos.yx *= rot(.55*c-iTime*3.2);\n    \n    \n    // Deform Space...\n    \n    float len = 24.0+(sin(iTime)*12.0);\n    \n    float rad =  (1.0/(3.141*2.0)*len);\n    float ang = atan(pos.x, pos.y);\n    vec2 cyl = vec2(rad-length(pos.xy), pos.z);\n    vec3 dp = vec3(cyl, ang * rad);\n\n    float xs = .45;\n    float zs = 5.65;\n    float ys = .65;\n    float boff = 0.2;\t\t// bounding box offset\n    float bthick = 0.2;\t// bounding box thickness\n\n    float d1 =  sdBoundingBox(dp.yxz+vec3(0.0,.8,0.0),vec3(xs+boff,ys+boff,zs+boff),bthick);\n    float d2 = sdBox(dp.yxz+vec3(0.0,.8,0.0),vec3(xs,ys,zs));\n    mat = step(d1,d2);\n    d1 = min(d1,d2);\n    return d1*0.5;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tvec3 ro = vec3( 0.0,0.0,1.5);\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 80.0;\n        float t = 0.0;\n        for( int i=0; i<150; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            \n            vec3 col1 = vec3(0.1,0.5,0.05);\n            vec3 col2 = vec3(0.4,0.2,0.5);\n            vec3 _col = mix(col1,col2,mat);\n            \n            col = _col*amb + _col*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2fW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 120, 167, 167, 455], [457, 457, 488, 488, 575], [577, 577, 598, 598, 666], [668, 668, 708, 708, 829], [843, 843, 869, 869, 1573], [1575, 1639, 1671, 1671, 1909], [1929, 1929, 1986, 2011, 3656]]}
{"id": "tl2fzt", "name": "my first metaball", "author": "g1st", "description": "my first metaball", "tags": ["metaball"], "likes": 6, "viewed": 59, "published": "Public", "date": "1599655418", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\t\n    // colour palette\n    vec3 c1 = vec3(248, 177, 149) / 255.0;\n    vec3 c2 = vec3(246, 114, 128) / 255.0;\n    vec3 c3 = vec3(192, 108, 132) / 255.0;\n    vec3 c4 = vec3(108, 91, 123) / 255.0;\n    vec3 c5 = vec3(53, 92, 125) / 255.0;\n    \n    vec2 centre1 = vec2(sin(iTime / 3.0) * 0.5 + 0.5, 0.5);\n    vec2 centre2 = vec2(sin(iTime / 5.7) * 0.5 + 0.5, 0.3);\n    vec2 centre3 = vec2(0.7, cos(iTime / 8.0) * 0.5 + 0.5);\n    vec2 centre4 = vec2(sin(iTime / 1.5) * 0.5 + 0.5, cos(iTime / 1.1) * 0.5 + 0.5);\n    vec2 centre5 = iMouse.xy / iResolution.xy;\n    \n    float total = 0.0;\n    \n    total += 1.0 / length(uv - centre1);\n    total += 2.0 / length(uv - centre2);\n    total += 1.0 / length(uv - centre3);\n    total += 0.6 / length(uv - centre4);\n    total += 0.6 / length(uv - centre5);\n   \t\n    total = total / 20.0;\n    \n    vec3 col = vec3(0.0);\n    \n    if (total < 0.6) {\n    \tcol = c1;\n    } else if (total < 0.7) {\n        col = c2;\n    } else if (total < 0.8) {\n        col = c3;  \n    } else if (total < 0.9) {\n        col = c4;\n    } else {\n    \tcol = c5;\n    }\n    \n      \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2fzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1304]]}
{"id": "tlBBRy", "name": "Breathing Ball", "author": "j91000", "description": "Simple raymarcher rendering a domain distorted sphere.\nInspired by https://www.shadertoy.com/view/XtjSDK\n\ntry adjusting RECURSION and ROTFACT\nif you start seeing visual artifacts, you can increase STEPSHRINK to eliminate them at the cost of performance.", "tags": ["f"], "likes": 11, "viewed": 112, "published": "Public", "date": "1599257797", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//THANKS IQ!\n\n//distortion settings\n#define RECURSION 7\n#define ROTFACT 1.85\n\n//render settings\n#define STEPSHRINK 3.5\n#define MAXSTEPS 1200\n#define CAMDIST 40.\n#define CAMSTRT vec2(-0.05,0.)\n\n#define HITDIST 1.e-3\n#define MAXDIST 100.\n\n//misc\n#define pi atan(1.0) * 4.0\n#define ZERO min(iFrame,0)\n#define PLANEH -20.\n\n//light and shadow\n#define AMBIENT 0.65 \n#define SUNLIGHT vec3(.7,.6,.5)*1.9\n#define SHADQUAL .2\n#define SHADSMOOTH 5.\n//ambient occlusion\n#define AO 1. //comment this line to disable ambient occlusion\n#define AODIST 1.85\n#define AOSTEPS 5\n#define AOPOW 1.\n\n\nstruct CastResult\n{\n    vec3 pos; //hit location\n    vec3 norm; //surface normal\n    vec3 surf; //surface material/albedo\n};\n    \nstruct DirLight\n{\n  vec3 dir;\n    vec3 col;\n};\n\n\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{angles=angles.yxz;\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n        return rotX*rotY*rotZ;\n    }\n\nmat3 Rotate(float a1,float a2,float a3){\n return Rotate(vec3(a1,a2,a3));   \n}\n//generates a rotation matrix that rotates (0,0,1) to face in the same\n//direction as dir.\nmat3 camRotation(vec3 dir){\n    dir=normalize(dir);\n    float xRot=atan(dir.z,dir.x)-pi/2.;\n    float yRot=atan(dir.y,length(dir.xz));\n    return Rotate(vec3(xRot,yRot,0));\n}\n\n//signed distance for the warped ball. higher levels of domain distortion\n//from RECURSION or ROTFACT must be offset with greater value for STEPSHRINK\n//to avoid the rayMarcher overshooting\nfloat sdWarp( vec3 p)\n{\n    for(int i=1;i<RECURSION;i++){\n        mat3 rotation=Rotate(normalize(p)*ROTFACT*sin(float(iFrame)/40.));\n\t\tp=p*rotation+vec3(0,1,0);\n    }\n    return length(p)-17.;\n}\n\n\nfloat distToScene(vec3 pos){\n    float plane=pos.y-PLANEH;\n    float result= (sdWarp(pos));\n    result=min(result,plane);\n    return result;\n}\n//calculate the norm by sampling the distance field around pos\n//lifted from an iq raymarcher\nvec3 calcNorm(vec3 pos){\n        vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 1.*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*distToScene(pos+0.00005*e);\n    }\n    return normalize(n);\n}\n\n//clever ambient occlusion trick described here:\n//https://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf\nfloat ambientOcclusion(vec3 pos,vec3 normal){\n    #ifdef AO\n    float occlusion=0.;\n    float itC=0.;\n    for(int i=1;i<AOSTEPS;i++){\n     itC++;\n     float term=itC*AODIST-distToScene(pos+normal*AODIST*itC);\n        occlusion+=1./pow(2.,itC)*term;\n    }\n    return 1.-clamp(AOPOW*occlusion/AODIST,0.,1.);\n    #else\n    return 1.;\n    #endif\n}\n\n//cast a new ray from surface.pos and see if you hit anything \n//on your way to sun\nfloat occlusion(CastResult surface,DirLight sun){\n    vec3 rayOri=surface.pos+surface.norm*HITDIST*2.;//the ray starts from just above the surface of the hit.\n    vec3 rayPos=rayOri;\n    bool hit=false;\n    float result=1.;\n    for(int steps=ZERO;steps<MAXSTEPS&&(!hit)&&length(rayPos-rayOri)<MAXDIST;steps++){\n        float dts=distToScene(rayPos);\n        hit=dts<HITDIST;\n        result=min(result,SHADSMOOTH*dts/length(rayPos-rayOri));\n        rayPos-=sun.dir*dts/STEPSHRINK*SHADQUAL;\n    }\n    result=hit ? 0.:result;\n    return result;\n}\n\nCastResult castRay(vec3 rayOri,vec3 rayVec){\n    \n    bool hit=false;\n    vec3 rayPos=rayOri;\n    for(int steps=ZERO;steps<MAXSTEPS&&hit==false&&length(rayPos-rayOri)<MAXDIST;steps++){\n        float dts=distToScene(rayPos);//calculate distance to scene\n        hit=dts<HITDIST;\t\t\t  //register a hit, if the distance is small\n        rayPos+=rayVec*dts/STEPSHRINK;//march the ray\n    }\n    vec3 norm=calcNorm(rayPos);\n    //here the surface color of the ball is adjusted based on ambient occlusion\n    vec3 surfCol=vec3(.3);\n    surfCol.r+=rayPos.y>.03+PLANEH?(1.-ambientOcclusion(rayPos,norm)):0.;\n    surfCol=(length(rayPos-rayOri)>=MAXDIST)? vec3(0.): surfCol;\n    return CastResult(rayPos,norm,surfCol);\n}\n//calculate the light hitting this castResult from sun, and ambient light\nvec3 lightOn(CastResult hit,DirLight sun){\n    vec3 sunLight=max(0.,(-dot(hit.norm,sun.dir)))*sun.col*occlusion(hit,sun);\n    vec3 ambientLight=vec3(AMBIENT*ambientOcclusion(hit.pos,hit.norm));\n    return hit.surf*(sunLight+ambientLight);\n}\n   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//Set up the camera\n    vec2 mousePos=(length(iMouse.xy)>0.)? iMouse.xy/iResolution.xy-.5:CAMSTRT;\n    float mouseTheta=mousePos.x*2.*pi;\n    float mouseH=mousePos.y*60.+19.;\n    vec3 camPos=vec3(cos(mouseTheta)*CAMDIST,mouseH,CAMDIST*sin(mouseTheta));\n    vec3 camTarget=vec3(0);\n    \n//set up lighting\n    DirLight sun;\n    sun.dir=normalize(vec3(1,-3,0.))*Rotate(vec3(10./5.,0,0));\n    sun.col=SUNLIGHT;\n    \n//set up camera ray\n//\n//in the middle of the screen, uv.xy ==(0,0),\n//so the rotation matrix that rotates (0,0,1) to normalize(camTarget-camPos)\n//will point our rays towards camTarget\n    mat3 rayRotation=camRotation(camTarget-camPos);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 rayVec=normalize(vec3(uv.x,uv.y,1.)*rayRotation);\n    \n    \n    \n    vec3 rayOri=camPos;\n\n    CastResult cRay=castRay(rayOri,rayVec);\n    bool inBounds=length(cRay.pos-rayOri)<MAXDIST*.999;\n    vec3 finalC=inBounds?lightOn(cRay,sun):vec3(0);\n    fragColor = vec4(finalC,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBBRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[757, 829, 855, 855, 1165], [1167, 1167, 1207, 1207, 1244], [1245, 1336, 1363, 1363, 1510], [1512, 1702, 1725, 1725, 1896], [1899, 1899, 1927, 1927, 2041], [2042, 2136, 2160, 2160, 2371], [2373, 2486, 2531, 2531, 2829], [2831, 2915, 2964, 2964, 3458], [3460, 3460, 3504, 3504, 4168], [4169, 4243, 4285, 4285, 4483], [4489, 4489, 4546, 4566, 5542]]}
{"id": "tlBfDV", "name": "JuliaSetCycling", "author": "bignobody", "description": "Playing with a Julia Set fractal and colour offsets.", "tags": ["juliaset"], "likes": 1, "viewed": 43, "published": "Public", "date": "1599861557", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Animating Julia Set shader. Based on a Mandlebrot shader I did a while ago: https://www.shadertoy.com/view/wlcXWH\n// Update 1: tweaked a few animation parameters and improved colour cycling\n\nmat2 rot(float a)\n{\n\treturn mat2(cos(a),-sin(a),sin(a),cos(a));    \n}\n\n//Credit where due! Got this technique from davethomas426 here: https://www.shadertoy.com/view/4slcz8\nvec2 complexmulti(vec2 x, vec2 y)\n{\n\treturn vec2(x.x * y.x - x.y * y.y, x.x * y.y + x.y * y.x);   \n}\n\nvec2 mandle(vec2 z, vec2 c)\n{\n\treturn complexmulti(z,z)+c;\n}\n\nfloat iterate(vec2 uv, float toff, float thresh)\n{\n\tint maxI = 256;\n    int i = 0;\n    float le = 0.0;\n    float t = iTime * 0.3;\n    vec2 c = vec2(-0.720 + sin(t+toff)* 0.28, 0.18 + cos(t+toff)*0.28);\n    vec2 z = uv;\n    while (i < maxI)\n    {\n\t\tz = mandle(z,c);\n        le = length(z);\n        if (le > thresh)\n        {\n            return (float (i)*((thresh * 0.038)+toff));\n        }\n        i ++;\n    }\n    return 0.1+toff;\n}\n\nvec3 mandlayer(vec2 uv, float t)\n{\n\tuv *= sin(t*0.1)*3.0;\n    uv.x += sin(t*1.5) * 0.5;\n    uv.y += cos(t*1.5 + 10.0) * 0.10;\n    uv *= rot(t * 0.3);\n    float off = (sin(t))*0.16;\n\tfloat off2 = (cos(t))*0.21;\n    float thresh = 2.0;\n   \n\treturn vec3(iterate(uv,off,thresh),iterate(uv,0.0,thresh),iterate(uv,off2,thresh));\n    \n     \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y;\n    vec2 mv = (iMouse.xy - 0.5 * iResolution.xy)/iResolution.y;\n    if (iMouse.z > 0.0)\n    {\n    \tuv += mv*-1.0;\n    }\n    fragColor = vec4(mandlayer(uv,iTime*0.5),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBfDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 194, 213, 213, 263], [265, 367, 402, 402, 467], [469, 469, 498, 498, 529], [531, 531, 581, 581, 963], [965, 965, 999, 999, 1300], [1302, 1302, 1359, 1359, 1596]]}
{"id": "tlBfzV", "name": "Floating  b&w static spilt milk", "author": "celifrog", "description": "Only like aliens would drink this or something, how about you decide what happens to them when they drink it?  It's filled with vitamin Z and it makes aliens have a body odor that makes zombies not want to hang around them.", "tags": ["milky"], "likes": 1, "viewed": 147, "published": "Public API", "date": "1599335588", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//THANKS IQ!\n\n//distortion settings\n#define RECURSION 7\n#define ROTFACT 1.85\n\n//render settings\n#define STEPSHRINK 3.5\n#define MAXSTEPS 1200\n#define CAMDIST 40.\n#define CAMSTRT vec2(-0.05,0.)\n\n#define HITDIST 1.e-5\n#define MAXDIST 200.\n\n//misc\n#define pi atan(1.0) * 4.0\n#define ZERO min(iFrame,0)\n#define PLANEH -90.\n\n//light and shadow\n#define AMBIENT 1.25 \n#define SUNLIGHT vec3(.7,.6,.5)*0.9\n#define SHADQUAL .2\n#define SHADSMOOTH 50.\n//ambient occlusion\n#define AO 1. //comment this line to disable ambient occlusion\n#define AODIST 1.85\n#define AOSTEPS 5\n#define AOPOW 1.\n\n\nstruct CastResult\n{\n    vec3 pos; //hit location\n    vec3 norm; //surface normal\n    vec3 surf; //surface material/albedo\n};\n    \nstruct DirLight\n{\n  vec3 dir;\n    vec3 col;\n};\n\n\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{angles=angles.yxz;\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( .9, 0.0, 0.0, 0.0,c.x,s.x, 0.0,s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.3,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n        return rotX*rotY*rotZ;\n    }\n\nmat3 Rotate(float a1,float a2,float a3){\n return Rotate(vec3(a1,a2,a1));   \n}\n//generates a rotation matrix that rotates (0,0,1) to face in the same\n//direction as dir.\nmat3 camRotation(vec3 dir){\n    dir=normalize(dir);\n    float xRot=atan(dir.z,dir.x)-pi/2.;\n    float yRot=atan(dir.y,length(dir.xz));\n    return Rotate(vec3(xRot,yRot,0));\n}\n\n//signed distance for the warped ball. higher levels of domain distortion\n//from RECURSION or ROTFACT must be offset with greater value for STEPSHRINK\n//to avoid the rayMarcher overshooting\nfloat sdWarp( vec3 p)\n{\n    for(int i=1;i<RECURSION;i++){\n        mat3 rotation=Rotate(normalize(p)*ROTFACT*sin(float(iFrame)/40.));\n\t\tp=p*rotation+vec3(0,1,0);\n    }\n    return length(p)-17.;\n}\n\n\nfloat distToScene(vec3 pos){\n    float plane=pos.y-PLANEH;\n    float result= (sdWarp(pos));\n    result=min(result,plane);\n    return result;\n}\n//calculate the norm by sampling the distance field around pos\n//lifted from an iq raymarcher\nvec3 calcNorm(vec3 pos){\n        vec3 n = vec3(0.0);\n    for( int i=ZERO; i<1111; i++ )\n    {\n        vec3 e = 1.*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e++*distToScene(pos+0.0005*e);\n    }\n    return normalize(n);\n}\n\n//clever ambient occlusion trick described here:\n//https://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf\nfloat ambientOcclusion(vec3 pos,vec3 normal){\n    #ifdef AO\n    float occlusion=0.;\n    float itC=-5.;\n    for(int i=1;i<AOSTEPS;i++){\n     itC++;\n     float term=itC*AODIST-distToScene(pos+normal*AODIST*itC);\n        occlusion+=199./pow(1.,itC)*term;\n    }\n    return 1.-clamp(AOPOW*occlusion/AODIST,0.,1.);\n    #else\n    return 1.;\n    #endif\n}\n\n//cast a new ray from surface.pos and see if you hit anything \n//on your way to sun\nfloat occlusion(CastResult surface,DirLight sun){\n    vec3 rayOri=surface.pos+surface.norm*HITDIST*0.3;//the ray starts from just above the surface of the hit.\n    vec3 rayPos=rayOri;\n    bool hit=false;\n    float result=1.;\n    for(int steps=ZERO;steps<MAXSTEPS&&(!hit)&&length(rayPos-rayOri)<MAXDIST;steps++){\n        float dts=distToScene(rayPos);\n        hit=dts<HITDIST;\n        result=min(result,SHADSMOOTH*dts/length(rayPos-rayOri));\n        rayPos-=sun.dir*dts/STEPSHRINK*SHADQUAL;\n    }\n    result=hit ? -0.5:result++;\n    return result;\n}\n\nCastResult castRay(vec3 rayOri,vec3 rayVec){\n    \n    bool hit=false;\n    vec3 rayPos=rayOri;\n    for(int steps=ZERO;steps<MAXSTEPS&&hit==false&&length(rayPos-rayOri)<MAXDIST;steps++){\n        float dts=distToScene(rayPos);//calculate distance to scene\n        hit=dts<HITDIST;\t\t\t  //register a hit, if the distance is small\n        rayPos+=rayVec*dts/STEPSHRINK;//march the ray\n    }\n    vec3 norm=calcNorm(rayPos);\n    //here the surface color of the ball is adjusted based on ambient occlusion\n    vec3 surfCol=vec3(.1);\n    surfCol.r+=rayPos.y>.03+PLANEH?(1.-ambientOcclusion(rayPos,norm)):0.;\n    surfCol=(length(rayPos-rayOri)>=MAXDIST)? vec3(90.): surfCol;\n    return CastResult(rayPos,norm,surfCol);\n}\n//calculate the light hitting this castResult from sun, and ambient light\nvec3 lightOn(CastResult hit,DirLight sun){\n    vec3 sunLight=max(199.,(-dot(hit.norm,sun.dir)))*sun.col*occlusion(hit,sun);\n    vec3 ambientLight=vec3(AMBIENT*ambientOcclusion(hit.pos,hit.norm));\n    return hit.surf*(sunLight+ambientLight);\n}\n   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//Set up the camera\n    vec2 mousePos=(length(iMouse.xy)>44.)? iMouse.xy/iResolution.xy-.5:CAMSTRT;\n    float mouseTheta=mousePos.x*5.*pi;\n    float mouseH=mousePos.y*1.+1.;\n    vec3 camPos=vec3(cos(mouseTheta)*CAMDIST,mouseH,CAMDIST*sin(mouseTheta));\n    vec3 camTarget=vec3(0);\n    \n//set up lighting\n    DirLight sun;\n    sun.dir=normalize(vec3(1,-3,0.))*Rotate(vec3(2./111.,0,0));\n    sun.col=SUNLIGHT;\n    \n//set up camera ray\n//\n//in the middle of the screen, uv.xy ==(0,0),\n//so the rotation matrix that rotates (0,0,1) to normalize(camTarget-camPos)\n//will point our rays towards camTarget\n    mat3 rayRotation=camRotation(camTarget-camPos);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 rayVec=normalize(vec3(uv.x,uv.y,1.)*rayRotation);\n    \n    \n    \n    vec3 rayOri=camPos;\n\n    CastResult cRay=castRay(rayOri,rayVec);\n    bool inBounds=length(cRay.pos-rayOri)<MAXDIST*.999;\n    vec3 finalC=inBounds?lightOn(cRay,sun):vec3(-14);\n    fragColor = vec4(finalC,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBfzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[758, 830, 856, 856, 1164], [1166, 1166, 1206, 1206, 1243], [1244, 1335, 1362, 1362, 1509], [1511, 1701, 1724, 1724, 1895], [1898, 1898, 1926, 1926, 2040], [2041, 2135, 2159, 2159, 2374], [2376, 2489, 2534, 2534, 2835], [2837, 2921, 2970, 2970, 3469], [3471, 3471, 3515, 3515, 4180], [4181, 4255, 4297, 4297, 4497], [4503, 4503, 4560, 4580, 5558]]}
{"id": "tljBD3", "name": "raytracing-by Jordan", "author": "jorge2017a1", "description": "//Made by Jordan Duty(AKA djdduty) May 14, 2014.", "tags": ["raytracingbyjordan"], "likes": 4, "viewed": 98, "published": "Public", "date": "1600050057", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Made by Jordan Duty(AKA djdduty) May 14, 2014.\n\n#define M_PI 3.141592653589793238462643383279\n\nstruct Ray\n{\n\tvec3 Dir;\n\tvec3 Pos;\n};\n\t\nstruct Sphere\n{\n\tvec3 Pos;\n\tvec3 Color;\n\tfloat Rad;\n\tfloat Reflection;\n};\n\nconst int numSpheres = 7;\nSphere spheres[numSpheres];\n\nvec3 LightPos = vec3(0,-3,10);\n\t\nvec3 Intersects(Sphere s, Ray r)\n{\n\tfloat t0, t1;\n\tvec3 l = s.Pos - r.Pos;\n\tfloat tca = dot(l, r.Dir);\n\tif(tca < 0.0) return vec3(0,0,-1.0);\n\tfloat d2 = dot(l, l) - tca*tca;\n\tif(d2 > s.Rad*s.Rad) return vec3(0,0,-1.0);\n\tfloat thc = sqrt((s.Rad*s.Rad) - d2);\n\treturn vec3(tca-thc, tca+thc, 1);\n}\n\t\nfloat mix2(float a, float b, float c)\n{\n\treturn b*c+a*(1.0-c);\t\n}\n\nvec3 Trace3(Ray r)\n{\n\tvec3 Color = vec3(0,0,0);\n\tSphere s;\n\tbool col = false;\n\tfloat tnear = 1e8;\n\tfor(int i = 0; i < numSpheres; i++)\n\t{\n\t\tvec3 intTest = Intersects(spheres[i],r);\n\t\tif(intTest.z != -1.0) {\n\t\t\tif(intTest.x < tnear) {\n\t\t\t\ttnear = intTest.x;\n\t\t\t\ts = spheres[i];\n\t\t\t\tcol = true;\n\t\t\t}\n\t\t}\n\t}\n\tif(col==false) return vec3(0,0,0);\n\tvec3 phit = r.Pos + r.Dir * tnear;\n\tvec3 nhit = phit - s.Pos;\n\tnhit = normalize(nhit);\n\tfloat bias = 1e-4;\n\t\n\tvec3 lightDir = LightPos - phit;\n\tbool blocked = false;\n\tlightDir = normalize(lightDir);\n\tfloat DiffuseFactor = dot(nhit, lightDir);\n\tvec3 diffuseColor = vec3(0,0,0);\n\tvec3 ambientColor = vec3(s.Color * 0.2);\n\t\n\tfor(int n = 0; n < numSpheres; n++)\n\t{\n\t\tRay rl;\n\t\trl.Pos = phit;\n\t\trl.Dir = lightDir;\n\t\tvec3 intTestL = Intersects(spheres[n],rl); \n\t\tif(intTestL.z != -1.0)\n\t\t{\n\t\t\tif(intTestL.x < length(LightPos-phit))\n\t\t\t\tblocked = true;\t\n\t\t}\n\t}\n\t\n\tif(!blocked)\n\t{\n\t\tif(DiffuseFactor > 0.0)\n\t\t{\n\t\t\tdiffuseColor = \tvec3(1,1,1)*DiffuseFactor;\n\t\t\tColor += s.Color*diffuseColor + ambientColor;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tColor+=ambientColor;\t\n\t\t}\n\t} \n\telse\n\t{\n\t\tColor+=ambientColor;\n\t}\n\t\n\treturn Color;\n}\n\nvec3 Trace2(Ray r)\n{\n\tvec3 Color = vec3(0,0,0);\n\tSphere s;\n\tbool col = false;\n\tfloat tnear = 1e8;\n\tfor(int i = 0; i < numSpheres; i++)\n\t{\n\t\tvec3 intTest = Intersects(spheres[i],r);\n\t\tif(intTest.z != -1.0) {\n\t\t\tif(intTest.x < tnear) {\n\t\t\t\ttnear = intTest.x;\n\t\t\t\ts = spheres[i];\n\t\t\t\tcol = true;\n\t\t\t}\n\t\t}\n\t}\n\tif(col==false) return vec3(0,0,0);\n\tvec3 phit = r.Pos + r.Dir * tnear;\n\tvec3 nhit = phit - s.Pos;\n\tnhit = normalize(nhit);\n\tfloat bias = 1e-4;\n\t\n\tbool inside = false;\n\tif(dot(r.Dir, nhit) > 0.0) nhit *= -1.0, inside = true;\n\t\n\tif(s.Reflection > 0.0)\n\t{\n\t\tfloat facingratio = dot((r.Dir*-1.0), nhit);\n\t\tvec3 refldir = r.Dir - nhit * 2.0 * dot(r.Dir, nhit);\n\t\trefldir = normalize(refldir);\n\t\tRay rd;\n\t\trd.Pos = phit;\n\t\trd.Dir = refldir;\n\t\tvec3 refl = Trace3(rd);\n\t\tfloat param1 = (1.0-s.Reflection);\n\t\tfloat param2 = s.Reflection;\n\t\tColor.x = (param1 * Color.x + param2 * refl.x);\n\t\tColor.y = (param1 * Color.y + param2 * refl.y);\n\t\tColor.z = (param1 * Color.z + param2 * refl.z);\n\t}\n\t\n\tvec3 lightDir = LightPos - phit;\n\tbool blocked = false;\n\tlightDir = normalize(lightDir);\n\tfloat DiffuseFactor = dot(nhit, lightDir);\n\tvec3 diffuseColor = vec3(0,0,0);\n\tvec3 ambientColor = vec3(s.Color * 0.2);\n\t\n\tfor(int n = 0; n < numSpheres; n++)\n\t{\n\t\tRay rl;\n\t\trl.Pos = phit;\n\t\trl.Dir = lightDir;\n\t\tvec3 intTestL = Intersects(spheres[n],rl); \n\t\tif(intTestL.z != -1.0)\n\t\t{\n\t\t\tif(intTestL.x < length(LightPos-phit))\n\t\t\t\tblocked = true;\t\n\t\t}\n\t}\n\t\n\tif(!blocked)\n\t{\n\t\tif(DiffuseFactor > 0.0)\n\t\t{\n\t\t\tdiffuseColor = \tvec3(1,1,1)*DiffuseFactor;\n\t\t\tColor += s.Color*diffuseColor + ambientColor;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tColor+=ambientColor;\t\n\t\t}\n\t} \n\telse\n\t{\n\t\tColor+=ambientColor;\n\t}\n\t\n\t\n\treturn Color;\n}\n\nvec3 Trace(Ray r)\n{\n\tvec3 Color = vec3(0,0,0);\n\tSphere s;\n\tbool col = false;\n\tfloat tnear = 1e8;\n    \n\tfor(int i = 0; i < numSpheres; i++)\n\t{\n\t\tvec3 intTest = Intersects(spheres[i],r);\n\t\tif(intTest.z != -1.0) {\n\t\t\tif(intTest.x < tnear) {\n\t\t\t\ttnear = intTest.x;\n\t\t\t\ts = spheres[i];\n\t\t\t\tcol = true;\n\t\t\t}\n\t\t}\n\t}\n    \n    \n\tif(col==false) return vec3(0,0,0);\n    \n    \n\tvec3 phit = r.Pos + r.Dir * tnear;\n\tvec3 nhit = phit - s.Pos;\n\tnhit = normalize(nhit);\n\tfloat bias = 1e-4;\n\t\n    \n\tbool inside = false;\n\tif(dot(r.Dir, nhit) > 0.0) nhit *= -1.0, inside = true;\n\t\n\tif(s.Reflection > 0.0)\n\t{\n\t\tfloat facingratio = dot((r.Dir*-1.0), nhit);\n\t\tvec3 refldir = r.Dir - nhit * 2.0 * dot(r.Dir, nhit);\n\t\trefldir = normalize(refldir);\n\t\tRay rd;\n\t\trd.Pos = phit;\n\t\trd.Dir = refldir;\n\t\tvec3 refl = Trace2(rd);\n\t\tfloat param1 = (1.0-s.Reflection);\n\t\tfloat param2 = s.Reflection;\n\t\tColor.x = (param1 * Color.x + param2 * refl.x);\n\t\tColor.y = (param1 * Color.y + param2 * refl.y);\n\t\tColor.z = (param1 * Color.z + param2 * refl.z);\n\t}\n\t\n\tvec3 lightDir = LightPos - phit;\n\tbool blocked = false;\n\tlightDir = normalize(lightDir);\n\tfloat DiffuseFactor = dot(nhit, lightDir);\n\tvec3 diffuseColor = vec3(0,0,0);\n\tvec3 ambientColor = vec3(s.Color * 0.2);\n\t\n\tfor(int n = 0; n < numSpheres; n++)\n\t{\n\t\tRay rl;\n\t\trl.Pos = phit;\n\t\trl.Dir = lightDir;\n\t\tvec3 intTestL = Intersects(spheres[n],rl); \n\t\tif(intTestL.z != -1.0)\n\t\t{\n\t\t\tif(intTestL.x < length(LightPos-phit))\n\t\t\t\tblocked = true;\t\n\t\t}\n\t}\n\t\n\tif(!blocked)\n\t{\n\t\tif(DiffuseFactor > 0.0)\n\t\t{\n\t\t\tdiffuseColor = \tvec3(1,1,1)*DiffuseFactor;\n\t\t\tColor += s.Color*diffuseColor + ambientColor;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tColor+=ambientColor;\t\n\t\t}\n\t} \n\telse\n\t{\n\t\tColor+=ambientColor;\n\t}\n\t\n\t\n\treturn Color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tspheres[0].Pos = vec3(5,0,-0);\n\tspheres[0].Color = vec3(0.9,0.1,0.1);\n\tspheres[0].Rad = 4.0;\n\tspheres[0].Reflection = 0.4;\n\t\n\tspheres[1].Pos = vec3(-5,0,-0);\n\tspheres[1].Color = vec3(0.3,0.3,0.3);\n\tspheres[1].Rad = 4.0;\n\tspheres[1].Reflection = 0.3;\n\t\n\tspheres[2].Pos = vec3(-5,1004,-0);\n\tspheres[2].Color = vec3(0.1,0.1,0.1);\n\tspheres[2].Rad = 1000.0;\n\t//spheres[2].Reflection = 0.15;\n    spheres[2].Reflection = 0.28;\n\t\n\tspheres[3].Pos = vec3(-5,0,-1040);\n\tspheres[3].Color = vec3(0.5,0.5,0.5);\n\tspheres[3].Rad = 1000.0;\n\tspheres[3].Reflection = 0.05;\n\t\n\tspheres[4].Pos = vec3(1020,0,-0);\n\tspheres[4].Color = vec3(0.9,0.9,0.0);\n\tspheres[4].Rad = 1000.0;\n\tspheres[4].Reflection = 0.05;\n\t\n\tspheres[5].Pos = vec3(-1020,0,-0);\n\tspheres[5].Color = vec3(0.2,0.2,0.7);\n\tspheres[5].Rad = 1000.0;\n\tspheres[5].Reflection = 0.05;\n\t\n\tspheres[6].Pos = vec3(-5,0,1040);\n\tspheres[6].Color = vec3(0.0,0.8,0.4);\n\tspheres[6].Rad = 1000.0;\n\tspheres[6].Reflection = 0.05;\n\t\n\tfloat invWidth = 1.0 / iResolution.x;\n\tfloat invHeight = 1.0 / iResolution.y;\n\tfloat fov = 60.0; \n\tfloat aspectratio = iResolution.x/iResolution.y;\n\tfloat angle = tan(M_PI * 0.5 * fov / 180.0);\n\t\n\tvec3 sinTime = vec3(sin(iTime*2.0));\n\t\n\tvec3 camTrans = vec3(20.0*cos(0.5*iTime), 0, 20.0*sin(0.5*iTime));\n\tvec3 camDir = camTrans - vec3(0);\n\t\n\tcamTrans.y = -5.0;\n\tLightPos.y = -10.0;//camTrans;\n\t\n\tmat3 rot;\n\tvec3 f = normalize(camTrans);\n\tvec3 u = vec3(0,1,0);\n\tvec3 s = normalize(cross(f,u));\n\tu = cross(s,f);\n\trot[0][0] = s.x; rot[1][0] = s.y; rot[2][0] = s.z;\n\trot[0][1] = u.x; rot[1][1] = u.y; rot[2][1] = u.z;\n\trot[0][2] = f.x; rot[1][2] = f.y; rot[2][2] = f.z;\n\t\n\tRay R;\n\tfloat xx = (2.0 *((fragCoord.x+0.5) * invWidth) -1.0)*angle*aspectratio;\n\tfloat yy = (1.0-2.0*((fragCoord.y+0.5)*invHeight))*angle;\t\n\tR.Pos = camTrans;\n\tR.Dir = vec3(xx,yy,-1) * rot;\n\tR.Dir = normalize(R.Dir);\n\t\n    \n    vec3 col=Trace(R);\n    col=pow(col, vec3(0.45454));\n\tfragColor = vec4(col, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljBD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 300, 334, 334, 594], [597, 597, 636, 636, 662], [664, 664, 684, 684, 1805], [1807, 1807, 1827, 1827, 3489], [3491, 3491, 3510, 3510, 5202], [5204, 5204, 5261, 5261, 7200]]}
{"id": "tljBDt", "name": "Texture Advection Demo", "author": "olano", "description": "Demo of 3-phase texture advection, broken down into steps", "tags": ["flow", "advection"], "likes": 0, "viewed": 42, "published": "Public", "date": "1600188488", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// demo mode:\n//   -1 = cycle through\n//   0 = show flow field in r/b, overlaid with a grid of flow vectors\n//   1 = one phase of offset texture, 5-second cycle, no fade\n//   2 = one phase fading to black at extremes\n//   3 = three phases (split vertically) without fading\n//   4 = three phases (split vertically) with fade\n//   5 = fade between all three phases\n//   6 = all three phases without vectors\n#define DEMOMODE -1\nint demomode = DEMOMODE;\n\n// choice of flow field\n//   0 = swirl\n//   1 = random from texture\n//   2 = curl of texture\n#define FLOWMODE 1\nint flowmode = FLOWMODE;\n\n// piecewise quadratic weighting kernel: domain -1 to 1, range 0 to 1\nfloat kernel(float t) {\n    float s = abs(t);\n    return s < 1./3. ? 0.75 - 2.25*s*s : 1.125 + (-2.25 + 1.125*s)*s;\n}\n\n// flow field\nvec2 flow(vec2 uv) {\n    vec2 v = texture(iChannel1, uv*0.1).xy * 0.2 - 0.1;\n    \n    switch(flowmode) {\n        case 1:\n\t    \treturn v;\n        \n        case 2:\n        \treturn 20.*vec2(dFdy(v.x), -dFdx(v.x));\n    \n        default:\n    \t\treturn vec2(-uv.y, uv.x) * 0.2;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // auto-transition between demo modes\n    float demotime = 0.05 * iTime + fragCoord.x / iResolution.x;\n    if (demomode < 0) demomode = int(mod(demotime,7.));\n    \n    // compute flow field\n    fragColor = vec4(0);\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 dir = flow(uv);\n    if (demomode==0)\n    \tfragColor = vec4(dir * 4. + 0.5,0,1).xzyw;\n\n\t// arrows from https://www.shadertoy.com/view/3l3Xzf\n    float gridScale = 16.;\n    vec2 R = iResolution.xy;\n    vec2 cell = fract(gridScale * uv)*2.-1.;\n    float l = length(dir),\n          x = (dir.x*cell.y-dir.y*cell.x) / l,\n          w = dot(dir,cell) / l;\n\tfloat arrow = smoothstep(gridScale*3./R.y, 0., abs(x)+.05*w );\n    arrow *= smoothstep(200./R.y, 0., abs(w)- l );\n    \n    // combine phases of texture\n    float time = 0.2 * iTime;\n    int phases = demomode==0 ? 0 : demomode<5 ? 1 : 3;\n    for(int i=0; i<phases; ++i) {\n        if (demomode==3 || demomode == 4) \n            i = int(3.*fragCoord.y/iResolution.y);\n        float shift = 2.*fract(time + float(i) * (1./3.)) - 1.;\n        float weight = demomode<2 || demomode==3 ? 1. : kernel(shift);\n        fragColor += weight * texture(iChannel0, uv + dir * shift);\n    }\n    \n    if (demomode<6)\n\t    fragColor = mix(fragColor, vec4(1), arrow);\n    \n    if (DEMOMODE < 0)\n        fragColor = mix(fragColor, vec4(1,0,0,1),\n                        smoothstep(2./iResolution.x,0.,\n                                   abs(fract(demotime + 0.5)-0.5)));\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljBDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[589, 659, 682, 682, 776], [778, 792, 812, 812, 1070], [1072, 1072, 1129, 1171, 2624]]}
{"id": "tljBDV", "name": "Flowing triangles", "author": "kostik1337", "description": "Very simple shader I wrote for my game \"CHOCH\" for js13k game jam, used there as background", "tags": ["grid", "triangle"], "likes": 3, "viewed": 247, "published": "Public API", "date": "1599929967", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n\nfloat hash(float x) {return fract(sin(x)*31345.23);}\n\nfloat smoothNoise(float x) {\n  return mix(hash(floor(x)), hash(floor(x)+1.), smoothstep(0.,1.,fract(x)));\n}\n\nfloat render(vec2 uv, vec2 offset) {\n    uv *= mat2(sqrt(3.)/2.,-.5,0.,1.);\n    float c = 0.;\n    const float I = 3.;\n    for(float i=0.;i<I;++i) {\n        float f = 20. + 17.*i;\n        // sort of triangle grid\n        vec2 uv1 = uv*f + (t*2. + offset) / f;\n        vec2 cuv = floor(uv1);\n        vec2 luv = fract(uv1);\n        if(luv.x+luv.y > 1.) {\n            luv = 1.-luv;\n            cuv += .5;\n        }\n\n        // colorize triangle at bounds based on cell position\n        float bound = .05;\n        c += max(\n            step(luv.x, bound),\n            max(\n                step(luv.y, bound),\n                step(1.-luv.x-luv.y, bound)\n            ))\n            * smoothstep(.4, .95, smoothNoise(dot(cuv, vec2(.6,.5)) + .4*t + 3.*i)) * mix(1., .3, i/(I-1.));\n    }\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 offset = iMouse.xy/2.;\n\n    float aberr = 0.003;\n\tvec3 col = vec3(\n    \trender(uv-vec2(aberr, 0.), offset),\n        render(uv, offset),\n        render(uv+vec2(aberr, 0.), offset)\n    )*.3;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljBDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 38, 38, 69], [71, 71, 99, 99, 178], [180, 180, 216, 216, 973], [975, 975, 1032, 1032, 1346]]}
{"id": "tljBWV", "name": "Volumetric light approximation", "author": "boris159", "description": "This is realtime version of my previous shader, but not so accurate and realistic.", "tags": ["3d", "raymarching", "volumetric", "fog"], "likes": 9, "viewed": 538, "published": "Public", "date": "1599924597", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON 0.001\n#define PI 3.141592\n#define MAX_DIST 256.0\n#define MAX_STEPS 256\n#define samples 50\n\nfloat seed;\n\nfloat rand()\n{\n    seed += 0.15342;\n    return fract(sin(seed) * 35423.7652344);\n}\n\nmat2 rot(float ang)\n{\n    float s = sin(ang);\n    float c = cos(ang);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rotVec(vec3 p, vec3 r)\n{\n    p.yz *= rot(r.x);\n    p.xz *= rot(r.y);\n    p.xy *= rot(r.z);\n    return p;\n}\n\nvec3 makeRay(vec2 origin)\n{\n    vec2 res;\n    res.x = origin.x - iResolution.x * 0.5;\n    res.y = origin.y - iResolution.y * 0.5;\n    return normalize(vec3(res / iResolution.yy, 1.0));\n}\n\nfloat box(vec3 b, vec3 pos, vec3 p)\n{\n    vec3 q = abs(p - pos) - b;\n  \treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat emptyBox(vec3 b, vec3 pos, vec3 p, float inner)\n{\n    return max(box(b, pos, p), -box(b * inner, pos, p));\n}\n\nfloat getDist(vec3 origin)\n{\n    //origin.xz *= mat2(cos(iTime), sin(iTime), -sin(iTime), cos(iTime));\n    float box1 = emptyBox(vec3(1.5, 1, 2), vec3(0), origin, 0.9);\n    float box2 = box(vec3(1, 0.5, 1), vec3(1, 0, 0), origin);\n    return max(box1, -box2);\n}\n\nvec3 getNormal(vec3 p)\n{\n    float d = getDist(p);\n    vec2 e = vec2(EPSILON, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec2 rayMarch(vec3 origin, vec3 direct)\n{\n    float res = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 tmp = origin + direct * res;\n        float d = getDist(tmp);\n        res += d;\n        \n        if (res >= MAX_DIST || d < EPSILON)\n        \treturn vec2(res, float(i));\n    }\n\n    return vec2(res, float(MAX_STEPS));\n}\n\nvec3 trace(vec3 origin, vec3 dir)\n{\n\tvec3 col = vec3(1);\n   \tvec2 res = rayMarch(origin, dir);\n    vec3 light = vec3(1, cos(iTime) * 0.5 + 0.5, 0);\n    \n    if (res.x < MAX_DIST)\n    {\n        vec3 p = origin + dir * res.x;\n        vec3 normal = getNormal(p);\n        \n        col *= pow(1.0 - res.y / float(MAX_STEPS), 5.0);\n        float shadow = rayMarch(p + normal * EPSILON * 5.0, light).x;\n        \n        if (shadow < MAX_DIST)\n            col *= 0.25;\n    }\n    \n    float toAdd = 1.0 / float(samples);\n    \n    for (int i = 0; i < samples; i++)\n    {\n        float f = (float(i) + rand()) / float(samples);\n        vec3 p = mix(origin, origin + dir * res.x, f);\n        float shadow = rayMarch(p, light).x;\n\n        if (shadow >= MAX_DIST)\n            col += toAdd;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    vec3 pos = vec3(-0.75, 0, -1.75);\n    vec3 dir = makeRay(fragCoord);\n    dir = rotVec(dir, vec3(0, -PI / 6.0, 0));\n    \n    vec3 traced = trace(pos, dir);\n    fragColor = vec4(traced, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljBWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 134, 134, 202], [204, 204, 225, 225, 305], [307, 307, 336, 336, 418], [420, 420, 447, 447, 606], [608, 608, 645, 645, 745], [747, 747, 802, 802, 861], [863, 863, 891, 965, 1124], [1126, 1126, 1150, 1150, 1346], [1348, 1348, 1389, 1389, 1692], [1694, 1694, 1729, 1729, 2498], [2500, 2500, 2557, 2557, 2845]]}
{"id": "tljBWy", "name": "Hexprism - intersection", "author": "iq", "description": "Ray-hexgonal-prism intersector. It computes the entry point and the normal at the intersection point. Returning the exit point is trivial (return tF). Can be easily optimized for many aligned instances.\n", "tags": ["3d", "raycasting", "raycast", "intersection", "prism", "hexagonal", "intersector"], "likes": 4, "viewed": 410, "published": "Public API", "date": "1600634950", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Ray-hexgonal-prism intersector. It computes the entry point and\n// the normal at the intersection point. Returning the exit point\n// is trivial (return tF).\n//\n// If many hexagonal parallel prisms were to be computed, many of the\n// computations could be taken our as common factors. See here:\n//\n// https://www.shadertoy.com/view/WtSfWK\n//\n// Also, discarding the normal computation and specializing this\n// function to be a shadow-only test also simplifies the code a\n// big deal (see same shader above).\n\n\n// Other intersectors: http://iquilezles.org/www/articles/intersectors/intersectors.htm\n//\n// Box:             https://www.shadertoy.com/view/ld23DV\n// Triangle:        https://www.shadertoy.com/view/MlGcDz\n// Capsule:         https://www.shadertoy.com/view/Xt3SzX\n// Ellipsoid:       https://www.shadertoy.com/view/MlsSzn\n// Sphere:          https://www.shadertoy.com/view/4d2XWV\n// Capped Cylinder: https://www.shadertoy.com/view/4lcSRn\n// Disk:            https://www.shadertoy.com/view/lsfGDB\n// Capped Cone:     https://www.shadertoy.com/view/llcfRf\n// Rounded Box:     https://www.shadertoy.com/view/WlSXRW\n// Rounded Cone:    https://www.shadertoy.com/view/MlKfzm\n// Torus:           https://www.shadertoy.com/view/4sBGDy\n// Sphere4:         https://www.shadertoy.com/view/3tj3DW\n// Goursat:         https://www.shadertoy.com/view/3lj3DW\n// Hexagonal Prism: https://www.shadertoy.com/view/tljBWy\n\n\nvec4 iHexPrism( in vec3  ro, in vec3  rd, \n                in float ra, in float he )\n{\n    const float ks3 = 0.866025;\n\n    // normals\n    const vec3 n1 = vec3( 1.0,0.0,0.0);\n    const vec3 n2 = vec3( 0.5,0.0,ks3);\n    const vec3 n3 = vec3(-0.5,0.0,ks3);\n    const vec3 n4 = vec3( 0.0,1.0,0.0);\n\n    // slabs intersections\n    vec3 t1 = vec3((vec2(ra,-ra)-dot(ro,n1))/dot(rd,n1), 1.0);\n    vec3 t2 = vec3((vec2(ra,-ra)-dot(ro,n2))/dot(rd,n2), 1.0);\n    vec3 t3 = vec3((vec2(ra,-ra)-dot(ro,n3))/dot(rd,n3), 1.0);\n    vec3 t4 = vec3((vec2(he,-he)-dot(ro,n4))/dot(rd,n4), 1.0);\n    \n    // inetsection selection\n    if( t1.y<t1.x ) t1=vec3(t1.yx,-1.0);\n    if( t2.y<t2.x ) t2=vec3(t2.yx,-1.0);\n    if( t3.y<t3.x ) t3=vec3(t3.yx,-1.0);\n    if( t4.y<t4.x ) t4=vec3(t4.yx,-1.0);\n   \n    vec4            tN=vec4(t1.x,t1.z*n1);\n    if( t2.x>tN.x ) tN=vec4(t2.x,t2.z*n2);\n    if( t3.x>tN.x ) tN=vec4(t3.x,t3.z*n3);\n    if( t4.x>tN.x ) tN=vec4(t4.x,t4.z*n4);\n    \n    float tF = min(min(t1.y,t2.y),min(t3.y,t4.y));\n    \n    // no intersection\n    if( tN.x > tF || tF < 0.0) return vec4(-1.0);\n\n    return tN;  // return tF too for exit point\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 1.7*cos(an), 1.0, 1.7*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raytrace\n        vec4 tnor = iHexPrism( ro, rd, 0.6, 0.7 );\n        float t = tnor.x;\n    \n        // shading/lighting\t\n        vec3 col = vec3(0.08)*(1.0-0.3*length(p)) + 0.02*rd.y;\n        if( t>0.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = tnor.yzw;\n            float dif = clamp( dot(nor,vec3(0.8,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + \n                  vec3(0.8,0.7,0.5)*dif + \n                  0.1*nor.z;\n        }\n\n        // gamma\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljBWy.jpg", "access": "shaders20k", "license": "mit", "functions": [[1590, 2495, 2582, 2582, 3629], [3645, 3645, 3702, 3727, 5299]]}
{"id": "tljfDy", "name": "t-02", "author": "kukuzhang", "description": "t-02", "tags": ["t02"], "likes": 2, "viewed": 27, "published": "Public", "date": "1599794386", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ALGORITHM 3\n\n\nvec3 cuteSort( vec3 n )\n{\n   float a = min(min(n.x,n.y),n.z);\n   float b = max(max(n.x,n.y),n.z);\n   return vec3( a, n.x+n.y+n.z-a-b, b );\n}\n\nvec3 sort3( vec3 c )\n{\n\tc.rg = (c.r < c.g) ? c.rg : c.gr;\n\tc.rb = (c.r < c.b) ? c.rb : c.br;\n\tc.gb = (c.g < c.b) ? c.gb : c.bg;\n    return c;\n}\n\nvec3 sort3bk(vec3 v)\n{\n\tvec2 t = vec2(min(v.x, v.y), max(v.x, v.y));\n\treturn vec3(min(t.x, v.z), min(max(v.z, t.x), t.y), max(t.y, v.z)); \n}\n\nvec3 sort3bk_cj(vec3 v)\n{\n\tvec4 t = vec4(min(v.x, v.y), min(v.z, v.y), max(v.x, v.y), max(v.z, v.y));\n\treturn vec3(min(t.x, t.y), max(t.x, t.y), max(t.z, t.w));\n}\n\nvoid mainImage(out vec4 c,vec2 p)\n{\n\tc.rgb = tan(p.xxy+p.xyy+iTime*vec3(11,11,11));\n    \n    #if ALGORITHM==0\n  \tfor(int i=0; i<20000; i++) c.bgr = cuteSort(c.rgb)-vec3(.01,.0,-.01);\n    #elif ALGORITHM==1\n    for(int i=0; i<20000; i++) c.bgr = sort3(c.rgb) -vec3(.01,.0,-.01);\n    #elif ALGORITHM==2\n    for(int i=0; i<20000; i++) c.bgr = sort3bk(c.rgb)-vec3(.01,.0,-.01);\n    #elif ALGORITHM==3\n    for(int i=0; i<20000; i++) c.bgr = sort3bk_cj(c.rgb)-vec3(.05,.0,.01);\n    #endif\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljfDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 47, 47, 162], [164, 164, 186, 186, 307], [309, 309, 331, 331, 449], [451, 451, 476, 476, 613], [615, 615, 650, 650, 1100]]}
{"id": "tljfW3", "name": "Wide-Angle Equiangular Camera", "author": "fu5ha", "description": "This is a modification of a cool mandelbox shader by EvilRyu to show how to make an equiangular camera and the difference in appearance vs a standard rectilinear camera.\n\nClick and drag the mouse to move the comparison line.", "tags": ["raymarching", "fractal", "camera", "projection"], "likes": 14, "viewed": 436, "published": "Public", "date": "1600045606", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// original created by EvilRyu\n//\n// modified to show how to make an equidistant projection camera and the visual difference\n//\n// scroll down to the mainImage function for an explanation of how the projection is derived\n\nfloat stime, ctime, time;\nvoid ry(inout vec3 p, float a){  \n\tfloat c,s;vec3 q=p;  \n\tc = cos(a); s = sin(a);  \n\tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n}  \n\nfloat fixed_radius2 = 1.9;\nfloat min_radius2 = 0.4;\nfloat folding_limit = 1.0;\nfloat scale = -2.0;\nvec3 mtl = vec3(1.0, 1.3, 1.23)*0.8;\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n        float temp = (fixed_radius2 / min_radius2);\n        z *= temp;\n        dz *= temp;\n    }else if(r2 < fixed_radius2) {\n        float temp = (fixed_radius2 / r2);\n        z *= temp;\n        dz *= temp;\n    }\n}\n\nvoid box_fold(inout vec3 z, inout float dz) {\n    z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;\n}\n\nfloat mb(vec3 z) {\n    vec3 offset = z;\n    float dr = 1.0;\n    for(int n = 0; n < 15; ++n) {\n        box_fold(z, dr);\n        sphere_fold(z, dr);\n\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 1.0;\n\t\t//scale = -2.8 - 0.2 * stime;\n    }\n    float r = length(z);\n    return r / abs(dr);\n}\n\nfloat f(vec3 p){ \n\try(p, stime);\n    return mb(p); \n} \n\n\nfloat softshadow(vec3 ro, vec3 rd, float k ){ \n     float akuma=1.0,h=0.0; \n\t float t = 0.01;\n     for(int i=0; i < 50; ++i){ \n         h=f(ro+rd*t); \n         if(h<0.001)return 0.02; \n         akuma=min(akuma, k*h/t); \n \t\t t+=clamp(h,0.01,2.0); \n     } \n     return akuma; \n} \n\n\n\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float res;\n    float t = 0.01;\n    for(int i = 0; i < 128; ++i)\n    {\n        vec3 p = ro + rd * t;\n        res = f(p);\n        if(res < 0.001 * t || res > 20.)\n            break;\n        t += res;\n    }\n    \n    if(res > 20.) t = -1.;\n    return t;\n}\n\n\nvec3 lighting(vec3 p,vec3 rd, float ps) {\n\t\n\tvec3 l1_dir = normalize(vec3(0.8, 0.8, 0.4)); \n    vec3 l1_col = 0.3*vec3(1.5, 1.69, 0.79);\n\tvec3 l2_dir = normalize(vec3(-0.8, 0.5, 0.3));\n    vec3 l2_col = vec3(0.89, 0.99, 1.3); \n    \n    vec3 e=vec3(0.5 * ps,0.0,0.0); \n \tvec3 n = normalize(vec3(f(p+e.xyy)-f(p-e.xyy), \n \t\t\t\t\t\t  f(p+e.yxy)-f(p-e.yxy), \n \t\t\t\t\t\t  f(p+e.yyx)-f(p-e.yyx)));\n\t\n\tfloat shadow = softshadow(p, l1_dir, 10.0 );\n\n    float dif1 = max(0.0, dot(n, l1_dir));\n\tfloat dif2 = max(0.0, dot(n, l2_dir));\n\tfloat bac1 = max(0.3 + 0.7 * dot(vec3(-l1_dir.x, -1.0, -l1_dir.z), n), 0.0);\n\tfloat bac2 = max(0.2 + 0.8 * dot(vec3(-l2_dir.x, -1.0, -l2_dir.z), n), 0.0);\n    float spe = max(0.0, pow(clamp(dot(l1_dir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n\n    vec3 col = 5.5 * l1_col * dif1 * shadow;\n\tcol += 1.1 * l2_col * dif2;\n\tcol += 0.3 * bac1 * l1_col;\n\tcol += 0.3 * bac2 * l2_col; \n    col += 1.0 * spe; \n\t\n    float t=mod(p.y+0.1*texture(iChannel0,p.xz).x-time*150.0, 5.0);\n    col = mix(col, vec3(6.0, 6.0, 8.0), \n              pow(smoothstep(0.0, .3, t) * smoothstep(0.6, .3, t), 15.0));;\n\treturn col;\n}\n\nvec3 post(vec3 col, vec2 q) {\n\t // post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n\treturn col;\n}\n\n\nvec3 get_background_color(vec2 uv, vec3 ro, vec3 rd) {\n\tvec3 bg = vec3(1.0); \n\treturn bg;\n}\nvec3 camera(float t){\n\tvec3 p=vec3(3.0*stime,2.0*ctime,5.0+1.0*stime) * (0.6 + 0.1 * stime);\n    return p;\n} \n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    float mousey = 0.0;\n    if (iMouse.z > 0.0) {\n         mousey = 2.0 * iMouse.y / iResolution.y - 1.0;\n    }\n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x/iResolution.y; \n\t// camera\n \tstime=sin(iTime*0.1); \n \tctime=cos(iTime*0.1); \n    time=iTime*0.01;\n\n \tvec3 ta=vec3(0.0,0.0,0.0); \n    vec3 ro=camera(time);\n \tvec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf));\n\n   \tfloat focal_length = 1.3;\n    vec2 perturbed_uv = uv;\n   \tif (uv.y > mousey) {\n        // see http://michel.thoby.free.fr/Fisheye_history_short/Projections/Models_of_classical_projections.html\n        // our model is somewhat inverse from the model in the article, as instead of taking an existing\n        // light ray coming into a lens and bending it with a lens, we are starting at the camera sensor\n        // and want to construct the final ray.\n        //\n        // as such, we start with the radius of the final position, which we want to be the\n        // equidistant / equiangular projection, i.e. (theta * focal length)\n\t\t//\n        // and we want to compute the rectilinear radius, i.e. (tan(theta) * focal length)\n\t\t// and then scale the uv by the factor which will bring the equidistant radius to\n        // the rectilinear radius, namely\n        //\n        // (tan(theta) * focal length) / (theta * focal length)\n        //\n        // which simplifies to\n        //\n        // tan(theta) / theta\n        //\n        // we can compute theta by realizing that we can solve the equation\n        //\n        // equidistant radius = theta * focal length\n        // \n        // given that we already have the equidistant radius and focal length, we get\n        //\n        // theta = equidistant radius / focal length\n        \n       \tfloat theta = length(uv) / focal_length;\n    \tperturbed_uv = uv * tan(theta) / theta; // \"equidistance\" / equiangular projection\n    }\n     \n    vec3 rd = normalize(perturbed_uv.x*cs + perturbed_uv.y*cu + focal_length*cf);  // transform from view to world\n\t\n\tvec3 bg = get_background_color(uv, ro, rd); \n    vec3 col = bg;\n\n    vec3 p=ro; \n\t \n\tfloat t = intersect(ro, rd);\n\tif(t > 0.01){\n\t\tp = ro + t * rd;\n        col = lighting(p, rd, 0.004)*mtl*0.2; \n        col = mix(col, bg, 1.0-exp(-0.01*t*t)); \n    }\n\n   \tcol=post(col, q);\n\tcol = mix(vec3(1.0, 0.6, 1.0), col, smoothstep(0.0, 0.01, abs(uv.y - mousey)));\n \tfragColor=vec4(col.x,col.y,col.z,1.0);\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljfW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 248, 279, 279, 391], [532, 532, 580, 580, 849], [851, 851, 896, 896, 957], [959, 959, 977, 977, 1263], [1265, 1265, 1281, 1281, 1318], [1322, 1322, 1367, 1367, 1598], [1603, 1603, 1638, 1638, 1894], [1897, 1897, 1938, 1938, 3012], [3014, 3014, 3043, 3053, 3309], [3312, 3312, 3366, 3366, 3403], [3404, 3404, 3425, 3425, 3512], [3515, 3515, 3574, 3574, 6060]]}
{"id": "tljfzG", "name": "Minimalism #12", "author": "Flopine", "description": "Twelfth piece of a shader serie about minimalism, how to do small and quick artwork that are about composition and animation.\nHEAVILY inspired by a invitro from Ninjadev: https://www.youtube.com/watch?v=YxLCvjuW9c4", "tags": ["3d", "isometric", "orthographic", "minimal", "daily"], "likes": 22, "viewed": 205, "published": "Public", "date": "1599253392", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n   \n// HEAVILY inspired by a invitro from Ninjadev <3 <3 <3 <3\n// https://www.youtube.com/watch?v=YxLCvjuW9c4\n\n#define ITER 40.\n#define PI acos(-1.)\n\n#define time(speed) fract(iTime*speed)\n#define bouncy(speed) (abs(sqrt(sin(time(speed)*PI))))\n\n#define sphere(p,r) (length(p)-r)\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define replimit(p,c,l) p=p-c*clamp(round(p/c),-l,l)\n\nfloat easeOutExpo (float x) \n{return x >= 1. ? 1. : 1. - pow(2., -10. * x);}\n\nstruct obj \n{\n    float dist;\n    int mat;\n};\n\nobj SDF (vec3 p)\n{\n    float dt = mod(iTime*1.5, 7.2);\n    float animxz,animyz;\n    \n    animxz = mix(0.,PI/4., easeOutExpo(clamp(dt-1.,0.,1.)));\n    animxz = mix(animxz,-PI/5.1,easeOutExpo(clamp(dt-2.,0.,1.))); \n    animxz = mix(animxz,PI/3.,easeOutExpo(clamp(dt-4.,0.,1.)));\n    animxz = mix(animxz,0.,easeOutExpo(clamp(dt-6.,0.,1.)));\n    \n    animyz = mix(0., PI/2., easeOutExpo(dt));\n    animyz = mix(animyz, 1./sqrt(1.6),easeOutExpo(clamp(dt-3.,0.,1.)));\n    animyz = mix(animyz, 0.,easeOutExpo(clamp(dt-5.,0.,1.)));\n    \n    p.xz *= rot(animxz);\n    p.yz *= rot(animyz);\n    \n    float per = 3.;\n    float nb = 1.;\n    vec3 id = floor((p-per*0.5)/per);\n    \n    replimit(p,per,nb);\n    \n   return obj(sphere(p,1.2+bouncy(2.)*0.2),int(length(id*1.5))); \n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(uv*6.2,-50.),\n        rd = vec3(0.,0.,1.),\n        p = ro,\n        col = vec3(0.);\n\n    bool hit = false;\n    float shad = 0.;\n    obj scene;\n\n    for (float i=0.; i<ITER; i++)\n    {\n        scene = SDF(p);\n        if (scene.dist < 0.001)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        p += scene.dist*rd;\n    }\n\n    if (hit)\n    {\n        if (scene.mat == 0) col = vec3(1.,0.,0.2);\n        if (scene.mat == 1) col = vec3(1.,0.3,0.1);\n        if (scene.mat == 2) col = vec3(1.,1.,0.);\n        if (scene.mat == 3) col = vec3(0.,0.8,0.35);\n        if (scene.mat == 4) col = vec3(0.,1.,1.);\n        if (scene.mat == 5) col = vec3(0.9,0.4,0.8);\n      \n        col *= (1.-shad);\n    }\n\n    fragColor = vec4(sqrt(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljfzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[321, 701, 731, 731, 777], [826, 826, 844, 844, 1587], [1589, 1589, 1645, 1645, 2499]]}
{"id": "tljfzy", "name": "Mixing 4 perlins", "author": "heyx3", "description": "Trying to find interesting ways to combine 4 separate octave noise signals\n", "tags": ["perlin", "experiment"], "likes": 3, "viewed": 94, "published": "Public", "date": "1599266596", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//The noise functions are taken from here: https://www.shadertoy.com/view/MdsGDN\n\n\n// noise\nfloat noise(vec2 pos)\n{\n\treturn fract( sin( dot(pos*0.001 ,vec2(24.12357, 36.789) ) ) * 12345.123);\t\n}\n\n\n// blur noise\nfloat smooth_noise(vec2 pos)\n{\n\treturn   ( noise(pos + vec2(1,1)) + noise(pos + vec2(1,1)) + noise(pos + vec2(1,1)) + noise(pos + vec2(1,1)) ) / 16.0 \t\t\n\t\t   + ( noise(pos + vec2(1,0)) + noise(pos + vec2(-1,0)) + noise(pos + vec2(0,1)) + noise(pos + vec2(0,-1)) ) / 8.0 \t\t\n    \t   + noise(pos) / 4.0;\n}\n\n\n// linear interpolation\nfloat interpolate_noise(vec2 pos)\n{\n\tfloat\ta, b, c, d;\n\t\n\ta = smooth_noise(floor(pos));\t\n\tb = smooth_noise(vec2(floor(pos.x+1.0), floor(pos.y)));\n\tc = smooth_noise(vec2(floor(pos.x), floor(pos.y+1.0)));\n\td = smooth_noise(vec2(floor(pos.x+1.0), floor(pos.y+1.0)));\n\t\t\n\ta = mix(a, b, fract(pos.x));\n\tb = mix(c, d, fract(pos.x));\n\ta = mix(a, b, fract(pos.y));\n\t\n\treturn a;\t\t\t\t   \t\n}\n\n\n\nfloat perlin_noise(vec2 pos)\n{\n\tfloat\tn;\n\t\n\tn = interpolate_noise(pos*0.0625)*0.5;\n\tn += interpolate_noise(pos*0.125)*0.25;\n\tn += interpolate_noise(pos*0.025)*0.225;\n\tn += interpolate_noise(pos*0.05)*0.0625;\n\tn += interpolate_noise(pos)*0.03125;\n    \n    return n;\n}\n\nfloat octave_noise(vec2 pos)\n{\n    float weight = 0.5,\n          scale = 1.0,\n          maxW = 0.0,\n          outN = 0.0;\n    for (int i = 0; i < 5; ++i) {\n        pos *= scale;\n        outN += weight * perlin_noise(pos);\n        \n        maxW += weight;\n        scale *= 2.0;\n        weight /= 2.0;\n    }\n    return outN / maxW;\n}\n\n\n\n\n//Now that we've got basic noise, let's try mixing them:\n\n#define PI 3.14159265359\n#define TWO_PI (PI * 2.0)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 seed = (fragCoord * 0.5) +\n        \t\t(iTime * 100.5);\n    vec4 clouds = vec4(octave_noise(seed),\n                       octave_noise(seed + 5631.0),\n                       octave_noise(seed + 8460.0),\n                       octave_noise(seed + 16564.0));\n    //As a backup, have some more cloud noise.\n    vec4 clouds2 = vec4(octave_noise(seed - 5829.0),\n                        octave_noise(seed - 12390.0),\n                        octave_noise(seed - 999.0),\n                        octave_noise(seed - 2430.0));\n    \n    fragColor = clouds;\n    \n    #define SEPARATOR_SIZE   3\n    #define SEPARATOR_SIZE_F 3.0\n    #define SEPARATOR (1.0 / SEPARATOR_SIZE_F)\n    \n    ivec2 separatorPos = ivec2(int(uv.x * SEPARATOR_SIZE_F),\n                               int(uv.y * SEPARATOR_SIZE_F));\n    int separatorI = separatorPos.x + (separatorPos.y * SEPARATOR_SIZE);\n    vec2 separatorT = (uv - vec2(separatorPos)*SEPARATOR)\n        \t\t\t  / SEPARATOR;\n    \n    //Use a border color to easily pick out each noise type.\n    vec3 borderColor = vec3(0.0);\n    \n    //Simple blending:\n    if (separatorI == 0) {\n        borderColor = vec3(1.0);\n        \n        vec2 blend = mix(clouds.rg, clouds.ba,\n                         0.5);\n        fragColor.rgb = vec3(mix(blend.x, blend.y, 0.5));\n    }\n    \n    //More interesting blending:\n    if (separatorI == 1) {\n        borderColor = vec3(1.0, 0.0, 1.0);\n        \n        fragColor.rgb = vec3(mix(clouds.r, clouds.g, clouds.b));\n        fragColor.rgb = min(clouds.aaa, fragColor.rgb);\n    }\n    \n    //\"Triangle\" blending:\n    if (separatorI == 2) {\n        borderColor = vec3(0.0, 1.0, 0.0);\n        \n        //Make a vector using a cloud value as the angle and \n        vec2 t = vec2(cos(clouds.a * TWO_PI),\n                      sin(clouds.a * TWO_PI));\n        t = 0.5 + (t * 0.5 * clouds2.r);\n        float valX = mix(clouds.r, clouds.g, t.x);\n        fragColor.rgb = mix(vec3(valX), clouds.bbb, t.y);\n    }\n    \n    //More complex interactions using pow():\n    if (separatorI == 3) {\n        borderColor = vec3(0.0, 0.0, 1.0);\n        vec4 oldClouds = clouds;\n        \n        clouds = smoothstep(0.0, 1.0, clouds);\n        float tMin = 0.3,\n              tMax = 0.9;\n        float v1 = mix(tMin, tMax, clouds.r),\n              v2 = mix((1.0/tMin), (1.0/tMax), clouds.g),\n        \t  v = mix(v1, v2, clouds.b);\n        float result = pow(clouds.a, v);\n        \n        result = clamp(result, 0.0, 1.0);\n        fragColor.rgb = vec3(result);\n        clouds = oldClouds;\n    }\n    \n    //More complex interactions using division:\n    if (separatorI == 4) {\n        borderColor = vec3(1.0, 1.0, 0.0);\n        \n        float result = clouds.r / max(clouds.g, clouds.b) * clouds.a;\n        \n        fragColor.rgb = vec3(result);\n    }\n    \n    //A position-based mixing:\n    if (separatorI == 5) {\n        borderColor = vec3(0.0, 1.0, 1.0);\n        \n        vec2 posOscillate = 0.5 + (0.5 * sin(uv * 20.0));\n        float result = mix(mix(clouds.r, clouds.g, posOscillate.x),\n                           mix(clouds.b, clouds.a, posOscillate.x),\n                           posOscillate.y);\n        \n        fragColor.rgb = vec3(result);\n    }\n    \n    //Unused:\n    if (separatorI == 6) {\n        return;\n    }\n    if (separatorI == 7) {\n        return;\n    }\n    \n    //Visualize how the above algorithms compare to plain noise:\n    if (separatorI == 8) {\n        borderColor = vec3(0.0);\n        fragColor.rgb = clouds.rrr;\n    }\n    \n    //Add the border color.\n    vec2 dim = abs(separatorT - vec2(0.5));\n    vec2 borderT2 = step(vec2(0.49), dim);\n    float borderT = max(borderT2.x, borderT2.y);\n    fragColor.rgb = mix(fragColor.rgb, borderColor, borderT);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljfzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 92, 115, 115, 194], [197, 211, 241, 241, 513], [516, 540, 575, 575, 919], [923, 923, 953, 953, 1189], [1191, 1191, 1221, 1221, 1522], [1527, 1638, 1695, 1745, 5495]]}
{"id": "tlSBDD", "name": " copy", "author": "RippleZou", "description": " ", "tags": [], "likes": 2, "viewed": 162, "published": "Public API", "date": "1598945352", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_ITER = 100;\nconst float MAX_DIST = 20.0;\nconst float EPSILON = 0.001;\nconst float PI = 3.14159265;\n\nbool HIT_HOLE = false;\nbool HIT_BARREL = false;\n\nvec3 rotateX(vec3 p, float ang) {\n  mat3 rmat = mat3(\n    1., 0., 0.,\n    0., cos(ang), -sin(ang),\n    0., sin(ang), cos(ang));\n  return rmat * p;\n}\nvec3 rotateY(vec3 p, float ang) {\n  mat3 rmat = mat3(\n    cos(ang), 0., sin(ang),\n    0., 1., 0.,\n    -sin(ang), 0., cos(ang));\n  return rmat * p;\n}\nvec3 rotateZ(vec3 p, float ang) {\n  mat3 rmat = mat3(\n    cos(ang), -sin(ang), 0.,\n    sin(ang), cos(ang), 0.,\n    0., 0., 1.);\n  return rmat * p;\n}\n\nfloat sphere(vec3 pos, float r) {\n  return length(pos) - r;   \n}\n\nfloat barrel(vec3 pos) {\n  float d = sphere(pos, 0.5);\n  pos.y += 0.5;\n  float holed = -sphere(pos, .25);\n  d = max(d, holed);\n  HIT_HOLE = (holed == d) ? true : HIT_HOLE;\n  return d;\n}\n\nfloat placedBarrel(vec3 pos, float rx, float ry) {\n  pos = rotateY(pos, ry);\n  pos = rotateX(pos, rx);\n  pos.y += 2.0;\n  return barrel(pos);\n}\n\nfloat distfunc(vec3 pos) {\n  pos += vec3(iTime);\n  vec3 c = vec3(10.);\n  pos = mod(pos,c)-0.5*c;\n    \n  pos = rotateX(pos, iTime);\n\n  HIT_HOLE = false;\n  HIT_BARREL = false;\n  \n  // Any of you smart people have a domain transformation way to\n  // do a rotational tiling effect instead of this? :)\n  float sphered = sphere(pos, 2.0);\n  float d = sphered;\n  d = min(d, placedBarrel(pos, 0., 0.));\n  d = min(d, placedBarrel(pos, 0.8, 0.));\n  d = min(d, placedBarrel(pos, 1.6, 0.));\n  d = min(d, placedBarrel(pos, 2.4, 0.));\n  d = min(d, placedBarrel(pos, 3.2, 0.));\n  d = min(d, placedBarrel(pos, 4.0, 0.));\n  d = min(d, placedBarrel(pos, 4.8, 0.));\n  d = min(d, placedBarrel(pos, 5.6, 0.));\n  d = min(d, placedBarrel(pos, 0.8, PI / 2.0));\n  d = min(d, placedBarrel(pos, 1.6, PI / 2.0));\n  d = min(d, placedBarrel(pos, 2.4, PI / 2.0));\n  d = min(d, placedBarrel(pos, 4.0, PI / 2.0));\n  d = min(d, placedBarrel(pos, 4.8, PI / 2.0));\n  d = min(d, placedBarrel(pos, 5.6, PI / 2.0));\n  d = min(d, placedBarrel(pos, 1.2, PI / 4.0));\n  d = min(d, placedBarrel(pos, 2.0, PI / 4.0));\n  d = min(d, placedBarrel(pos, 1.2, 3.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 2.0, 3.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 1.2, 5.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 2.0, 5.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 1.2, 7.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 2.0, 7.0 * PI / 4.0));\n  HIT_BARREL = d != sphered;\n\n  return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float m_x = (iMouse.x / iResolution.x) - 0.5;\n    float m_y = (iMouse.y / iResolution.y) - 0.5;\n    vec3 cameraOrigin = vec3(5.0 * sin(m_x * PI * 2.), m_y * 15.0, 5.0 * cos(m_x * PI * 2.));\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n    vec3 cameraUp = cross(cameraDir, cameraRight);\n    vec2 screenPos = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy;\n    screenPos.x *= iResolution.x / iResolution.y;\n    vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n\n    float totalDist = 0.0;\n    vec3 pos = cameraOrigin;\n    float dist = EPSILON;\n    for (int i = 0; i < MAX_ITER; i++) {\n        if (dist < EPSILON || totalDist > MAX_DIST) { break; }\n        dist = distfunc(pos);\n        totalDist += dist;\n        pos += dist * rayDir;\n    }\n\n    if (dist < EPSILON) {\n      vec2 eps = vec2(0.0, EPSILON);\n      vec3 normal = normalize(vec3(\n            distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n            distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n            distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n      vec3 lightdir = normalize(vec3(1., -1., 0.));\n      float diffuse = max(0.2, dot(lightdir, normal));\n      vec2 tc = vec2(pos.x, pos.z);\n      vec3 texcol = texture(iChannel0, tc).rgb;\n\n      vec3 lightcol = vec3(1.);\n      vec3 darkcol = vec3(.4, .8, .9);\n      float sma = 0.4;\n      float smb = 0.6;\n        \n      if (HIT_HOLE) { \n          lightcol = vec3(1., 1., 0.8);\n      } else if (HIT_BARREL) {\n        lightcol.r = 0.95;   \n      } else {\n          sma = 0.2;\n          smb = 0.3;\n      }\n      float facingRatio = smoothstep(sma, smb, \n                                     abs(dot(normal, rayDir)));\n\n      vec3 illumcol = mix(lightcol, darkcol, 1. - facingRatio);\n      fragColor = vec4(illumcol, 1.0);        \n    } else {\n      float strp = smoothstep(.8, .9, mod(screenPos.y * 10. + iTime, 1.));\n      fragColor = vec4(mix(vec3(1., 1., 1.), vec3(.4, .8, .9), strp), 1.);\n    }\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSBDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[163, 163, 196, 196, 311], [312, 312, 345, 345, 460], [461, 461, 494, 494, 609], [611, 611, 644, 644, 675], [677, 677, 701, 701, 862], [864, 864, 914, 914, 1006], [1008, 1008, 1034, 1034, 2448], [2450, 2450, 2507, 2507, 4660]]}
{"id": "tlSBRK", "name": "Noise + Tile Experiment", "author": "mharitsnf", "description": "Experimenting with noise and tile", "tags": ["noise", "simplex", "pattern", "tile"], "likes": 3, "viewed": 83, "published": "Public", "date": "1599310873", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\nfloat snoise(vec3 p) {\n\n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n\n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n\n    vec4 w, d;\n\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n\n    w = max(0.6 - w, 0.0);\n\n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n\n    w *= w;\n    w *= w;\n    d *= w;\n\n    return dot(d, vec4(52.0));\n}\n\nvec3 col255to1(vec3 col) {\n    return col / 255.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 indigo = col255to1(vec3(22., 66., 91.));\n    vec3 dsb = col255to1(vec3(129., 195., 215.));\n    \n    vec2 uv1 = uv;\n    \n    uv *= 13.;\n    float sn = snoise(vec3(uv, iTime));\n    float sn2 = snoise(vec3(uv, iTime - 100.));\n    float oddRow = step(1., mod(uv.y, 2.));\n    float oddCol = step(1., mod(uv.x, 2.));\n    uv = fract(uv);\n    \n    vec2 bl = step(vec2(.1), uv);\n    vec2 tr = step(vec2(.1), 1.-uv);\n    \n    float boxes = oddRow * oddCol;\n    float boxesMini = boxes * (bl.x * bl.y * tr.x * tr.y);\n\n    vec3 color = vec3((step(0., sn + sn2) * boxesMini)) * indigo;\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSBRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 219], [279, 279, 301, 301, 930], [932, 932, 958, 958, 983], [985, 985, 1042, 1042, 1749]]}
{"id": "tlSBWD", "name": "SL2 Light Intensity", "author": "stevejtrettel", "description": "Draws the Light Intensity in SL2 Geometry in a plane through the fiber direction in the Tangent Space to the Origin.", "tags": ["2d"], "likes": 2, "viewed": 60, "published": "Public", "date": "1598932378", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//from https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float rng=10.+50.*(1.+cos(iTime/3.));//sets the size of the display\n  \n    float L=rng*(uv.x-0.5);\n    float z=rng*(uv.y-0.5);\n    z=360./640.*z;\n    \n    //Stuff Needed to compute the intensity\n    \n    //first; the components of the cylindrical coordinate polynomials\n    float L2, L4, L6,z2,z4,z6;\n    L2=L*L;\n    L4=L2*L2;\n    L6=L2*L4;\n    z2=z*z;\n    z4=z2*z2;\n    z6=z2*z4;\n    \n    //the hyperbola you lie on\n    float k=sqrt(abs(L2-z2));\n    \n    //the polynomials coefficients of the area density\n    float f1=(L2+z2)/pow(abs(L2-z2),6.);\n    float f2=17.*L6+7.*L4*z2+16.*L2*z4+32.*z6;\n    float f3=48.*L2*z2*(L2+z2);\n    float f4=3.*L4*(5.*L2+3.*z2);\n    float f5=L6-2.*L2*z2-z4-L4*(1.+z2);\n    float f6=(L6+2.*L2*z2+z4-L4*(z2-1.));\n    float f7=2.*L2*(L2+z2)*k;\n    \n    \n    //Trigonometric Components\n    float c1=cos(k);\n    float c2=cos(2.*k);\n    float s1=sin(k);\n    float s2=sin(k/2.);\n    s2*=s2;//now sin(k/2)^2;\n    \n    float C1=cosh(k);\n    float C2=cosh(2.*k);\n    float S1=sinh(k);\n    \n    float S2=sinh(k/2.);\n    S2*=S2;//now it's sinh(k/2)^2\n    \n    //the signs that change depending on formula type:\n    float sgn=1.;\n    float Sgn=-1.;\n    \n    //the area density function, depending on if you are in or out of the lightcone\n    float areaDensity;\n    \n    \n  if(abs(z)>abs(L)){\n            areaDensity=sqrt(abs(f1*s2*(f2 - f3*c1 + f4*c2)*(f5 + f6*c1 + sgn* f7*s1)))/2.;\n        }\n        else if(abs(z)<abs(L)){\n            areaDensity=sqrt(abs(f1*S2*(f2 - f3*C1 + f4*C2)*(f5 + f6*C1 + Sgn*f7*S1)))/2.;\n        }   \n   \n   \n    float intensity=1./areaDensity;\n    \n    float cappedIntensity=min(0.25*intensity,1.);\n\n    \n    // Time varying pixel color\n   // vec3 blue=1.5*vec3(0.1,0.2,0.35);\n   // vec3 orange=vec3(1.,177./255.,64./255.);\n   // vec3 yellow=vec3(0.75,0.75,0.35);\n   // vec3 mix=(1.-cappedIntensity)*blue+cappedIntensity*orange;\n    \n   // vec3 col = (0.75+intensity/5.)*mix;\n        //intensity*vec3(1.,1.,0.5);\n       \n\n   vec3 col = pal(0.5*cappedIntensity-0.55, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSBWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 45, 113, 113, 156], [159, 159, 216, 266, 2469]]}
{"id": "tlSBWt", "name": "(copy) Voronoi Gradient by gls91", "author": "rtsonneveld", "description": "gradient", "tags": ["gradient"], "likes": 2, "viewed": 52, "published": "Public", "date": "1600117331", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// v1.2\n\n#define t iTime*2.\n#define SIZE 30.\n\n#define col1 vec3(177.,100.,227.)/255.\n#define col2 vec3(97.,173.,236.)/255.\n\nvec2 ran(vec2 uv) {\n    uv *= vec2(dot(uv,vec2(127.1,311.7)),dot(uv,vec2(227.1,521.7)) );\n    return 1.0-fract(tan(cos(uv)*123.6)*3533.3)*fract(tan(cos(uv)*123.6)*3533.3);\n}\nvec2 pt(vec2 id) {\n    return sin(t*(ran(id+.5)-0.5)+ran(id-20.1)*8.0)*0.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    vec2 off = iTime/vec2(50.,30.);\n    uv += off;\n    uv *= SIZE;\n    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    float mindist = 1e9;\n    vec2 vorv;\n    for(float i=-1.;i<=1.;i++) {\n        for(float j=-1.;j<=1.;j++) { \n            vec2 offv = vec2(i,j);\n            float dist = length(gv+pt(id+offv)-offv);\n            if(dist<mindist){\n                mindist = dist;\n                vorv = (id+pt(id+offv)+offv)/SIZE-off;\n            }\n        }\n    }\n    \n    vec3 col = mix(col1,col2,clamp(vorv.x*2.2+vorv.y,-1.,1.)*0.5+0.5);\n    \n    fragColor = vec4(col,1.0);\n    \n    /*\n    fragColor += vec4(vec3(smoothstep(0.08,0.05,gv.x+pt(id).x)),0.0);\n    fragColor -= vec4(vec3(smoothstep(0.05,0.03,gv.x+pt(id).x)),0.0);\n\t*/\n}\t", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSBWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 124, 143, 143, 297], [298, 298, 316, 316, 375], [378, 378, 435, 435, 1241]]}
{"id": "tlSBWw", "name": "[TWITCH] Volumetric screamer", "author": "evvvvil", "description": "Volumetric screamer - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["clouds", "cloud", "demoscene", "volumetric", "fog", "glow", "lightning", "monster", "face", "scary", "dark", "bolt", "demon", "scream"], "likes": 20, "viewed": 701, "published": "Public API", "date": "1599055349", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Volumetric screamer - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\nvec2 z;float tt,b,g=0.,gg=0.,cr;vec3 faceP,cp;vec4 su=vec4(0);\nfloat smin( float d1,float d2,float k){ float h=max(k-abs(d1-d2),0.);return min(d1,d2)-h*h*.25/k;}\nfloat smax( float d1,float d2,float k){ float h=max(k-abs(-d1-d2),0.);return max(-d1,d2)+h*h*.25/k;}\nmat2 r2(float r){ return mat2(cos(r),sin(r),-sin(r),cos(r));} \nfloat noi(vec3 p){\n    vec3 f=floor(p),s=vec3(7,157,113);\n    p-=f;\n    vec4 h=vec4(0,s.yz,s.y+s.z)+dot(f,s);\n    p=p*p*(3.-2.*p);\n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z);  \n}  \nfloat ferlin(vec3 p){ \n    float f=0.,A=.5,I;\n    p.zy+=tt*2.; \n    for(int i=0;i<3;i++) I=float(i),f+=A/(I+1.)*noi(p+I),p=(2.1+.1*I)*p;\n    return f;\n} \nfloat face(vec3 p){\n    p-=vec3(0,-12.+b*20.,0)+sin(p.y*2.)*.1;\n    p.yz*=r2(1.65*(1.-b));  \n    faceP=p*vec3(1,.7,1);   \n    float t=length(faceP)-4.-sin(p.y)*.66;\n    t=smin(t,length(abs(faceP+vec3(0,-2.5,-1))-vec3(2,0,0))-4.,1.);\n    vec3 spikeP=p+vec3(0,-3.9,2);\n    spikeP.x=abs(spikeP.x)-2.;\n    spikeP.xy*=r2(-.785);\n    spikeP.yz*=r2(-.1785);\n    t=smin(t,length(spikeP.xz)-2.+abs(p.x)*.2,1.5);\n    vec3 eyeP=abs(p-vec3(0,2,0));\n    eyeP.xy*=r2(.6);\n    float eyes=max(eyeP.y,(length(abs(faceP+vec3(0,-1.5,3.))-vec3(1.,0,0))-3.));   \n    t=smax(eyes,t,1.);   \n    t=min(t,max(eyeP.y+4.,eyes));\n    t=smax(length(faceP+vec3(0,2,-2.+5.*b))-2.5,t,.5); \n    spikeP.xy*=r2(-.1485);\n    spikeP-=vec3(8.*b,-3,-1);\n    t=smin(t,length(spikeP.xz)-1.+abs(spikeP.y+3.)*.25,1.5);\n    return t;\n}\nfloat terrain(vec3 p){\n    float t=p.y+5.+cos(length(p*(.5))-b*15.-tt*4.)*b+noi(p*.07+1.)*5.; //WOBBLE: cos(length(p*(.5))-b*15.-tt*4.)\n    t=smax(length(p.xz)-2.-b*6.,t,3.);\n    t=smin(t,length(p.xz)-1.+(p.y+15.-b*17.)*.5,1.5);\n    return t;\n} \nfloat cmp( vec3 p) \n{  \n    float t=face(p);  \n    t=smin(t,terrain(p),2.5);\n    vec3 boltP=p;\n    boltP=abs(boltP-vec3(0,0,2))-11.+sin(p.y*5.*p.x*.1+tt*25.5)*.05+4.*sin(p.y*.3-3.)+p.y*.2;//ORIGINAL SHADER IN BONZOMATIC HAD NOISE TEXTURE CALL FOR BETTER LIGHTNING BOLT EFFECT BUT, THIS SHADER BEING GREEDY ENOUGH, I THOUGHT BEST REPLACE WITH BUNCH OF SINS ON SHADERTOY\n    float bolt=length(boltP.xz)-.1; //~Above line on bonzo end should be: abs(boltP-vec3(0,0,2))-11.+texture(texNoise,p.xy*.1+tt*.5).r*2.+4.*sin(p.y*.3-3)+p.y*.2;      \n    bolt=max(bolt,p.y+10.-b*25.);\n    float mouthFlash=max(p.z,length(faceP.xy-vec2(0,-2))+2.+p.z*.2*b);\n    g+=0.1/(0.1+bolt*bolt*(1.02-b)*(40.-39.5*sin(p.y*.2-b*8.)));\n    gg+=0.1/(0.1+mouthFlash*mouthFlash*(1.05-b)*(40.-39.5*sin(p.z*.3+tt*5.)));\n    return t;\n}  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n    tt=mod(iTime,62.82);\n    b=smoothstep(0.,1.,sin(tt)*.5+.5);\n    vec3 ro=vec3(sin(tt*.5)*10.,mix(15.,-3.,b),-20.+sin(tt*.5)*5.)*mix(vec3(1),vec3(2,1,cos(tt*.5)*1.5),cos(-tt*.5+.5)*.5+.5),\n         cw=normalize(vec3(0,b*10.,0)-ro), cu=normalize(cross(cw,vec3(0,1,0))),\n         cv=normalize(cross(cu,cw)), rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;\n    co=fo=vec3(.1,.12,0.17)-length(uv)*.1-rd.y*.2;    \n    cr=cmp(ro-3.)+fract(dot(sin(uv*476.567+uv.yx*785.951+tt),vec2(984.156)));\n    for(int i=0;i<128;i++){\n        cp=ro+rd*(cr+=1./2.5);\n        if(su.a>.99) break; //NOTE TO SELF: cr>t NOT NEEDED AS ONLY VOLUMETRIC GEOM ARE PRESENT\n        float de=clamp((-cmp(cp)*9.+8.*ferlin(cp))/8.,0.,1.);\n        su+=vec4(vec3(mix(1.,0.,de)*de),mix(.07,de,exp(-.00001*cr*cr*cr)))*(1.-su.a);//FOG ON CLOUDS! mix(.07,de,exp(-.00001*cr*cr*cr))\n    }\n    co=mix(co,su.xyz,su.a);  \n    fragColor = vec4(pow(co+g*.4*vec3(.5,.2,.1)+gg*.4*vec3(.1,.2,.5),vec3(.55)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSBWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 254, 293, 293, 352], [353, 353, 392, 392, 453], [454, 454, 471, 471, 515], [517, 517, 535, 535, 773], [776, 776, 797, 797, 928], [930, 930, 949, 949, 1721], [1722, 1722, 1744, 1744, 1966], [1968, 1968, 1989, 1989, 2770], [2773, 2773, 2830, 2830, 3877]]}
{"id": "tlSBzK", "name": "original-14472.0", "author": "jorge2017a1", "description": "original-14472.0", "tags": ["original144720"], "likes": 3, "viewed": 47, "published": "Public", "date": "1599316749", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Rainbow Dash rendered by mapping signs of improper equations of graphic primitives,\n// mainly lines, circles, and ellipses.\n// (c) mniip 2014\n\n\nconst vec3 COLOR_LINE = vec3(0x77, 0xB0, 0xE0) / 255.0;\nconst vec3 COLOR_MANELINE = vec3(0x1E, 0x98, 0xD3) / 255.0;\nconst vec3 COLOR_BODY = vec3(0x9E, 0xDB, 0xF9) / 255.0;\nconst vec3 COLOR_MANE1 = vec3(0xEE, 0x41, 0x44) / 255.0;\nconst vec3 COLOR_MANE2 = vec3(0xF3, 0x70, 0x33) / 255.0;\nconst vec3 COLOR_MANE3 = vec3(0xFD, 0xF6, 0xAF) / 255.0;\nconst vec3 COLOR_MANE4 = vec3(0x62, 0xBC, 0x4D) / 255.0;\nconst vec3 COLOR_MANE5 = vec3(0x67, 0x2F, 0x89) / 255.0;\nconst vec3 COLOR_EYEBROW = vec3(0x00, 0x00, 0x00) / 255.0;\nconst vec3 COLOR_IRIS1 = vec3(0xC6, 0x00, 0x6F) / 255.0;\nconst vec3 COLOR_IRIS2 = vec3(0x46, 0x00, 0x25) / 255.0;\n//const vec3 COLOR_IRIS1 = vec3(1.0, 1.0, 1.0) ;\n\nconst vec3 COLOR_BLACK = vec3(0xFF, 0x00, 0x00) / 255.0;\nconst vec3 COLOR_WHITE = vec3(0x99, 0x00, 0x00) / 255.0;\n\n\nbool line(vec2 p, vec2 a, vec2 b)\n{\n\treturn (p.x - a.x) * (a.y - b.y) > (p.y - a.y) * (a.x - b.x);\n    \n}\n\nbool circle(vec2 p, vec2 a, float r)\n{\n    //corregido por FabriceNeyret2\n\t//return (p.x - a.x) * (p.x - a.x) + (p.y - a.y) * (p.y - a .y) > r * r;\n    return dot(p-a,p-a) > r*r;\n}\n\nbool ellipse(vec2 p, vec2 a, vec2 r)\n{\n\t//return (p.x - a.x) * (p.x - a.x) / r.x / r.x + (p.y - a.y) * (p.y - a .y) / r.y / r.y > 1.0;\n      p = (p-a)/r;\n    return dot (p,p)>1.;\n}\n\nvec2 m;\n\nbool ear(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(638, 664), 362.);\n\tbool B = circle(p, vec2(1075, 641), 323.);\n\tbool C = circle(p, vec2(646, 708), 378.);\n\tif(!A && !B && !C)\n\t{\n\t\tbool D = circle(p, vec2(637, 662), 345.);\n\t\tbool E = circle(p, vec2(1109, 588), 363.);\n\t\tbool F = circle(p, vec2(651, 692), 269.);\n\t\tbool G = circle(p, vec2(395, 732), 516.);\n\t\tif(D || E || (!F && G))\n\t\t\tc = COLOR_LINE;\n\t\telse\n\t\t\tc = COLOR_BODY;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool mane(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(434, 460), 514.);\n\tbool B = circle(p, vec2(254, 110), 903.);\n\tbool C = circle(p, vec2(384, 228), 668.);\n\tbool D = circle(p, vec2(475, 505), 425.);\n\tbool E = circle(p, vec2(513, 281), 536.);\n\tbool F = circle(p, vec2(777, 435), 360.);\n\tbool G = circle(p, vec2(915, 174), 554.);\n\tbool H = circle(p, vec2(659, 444), 1536.);\n\tbool I = circle(p, vec2(-201, 601), 337.);\n\tbool J = line(p, vec2(-253, 218), vec2(176, 590));\n\tbool K = circle(p, vec2(-164, 1212), 882.);\n\tbool L = circle(p, vec2(650, 764), 180.); // lol weird\n\tif(!A && !B && (C || (!D && E) || (!F && G) || (!H || (I && !J)) && !K) || !L)\n\t{\n\t\tbool M = circle(p, vec2(422, 434), 518.);\n\t\tbool N = circle(p, vec2(372, 261), 647.);\n\t\tbool O = circle(p, vec2(491, 499), 425.);\n\t\tbool P = circle(p, vec2(395, 377), 402.);\n\t\tbool Q = circle(p, vec2(790, 454), 352.);\n\t\tbool R = circle(p, vec2(891, 216), 527.);\n\t\tbool S = circle(p, vec2(680, 453), 536.);\n\t\tbool T = circle(p, vec2(-217, 1332), 992.);\n\t\tbool U = circle(p, vec2(-150, 586), 305.);\n\t\tbool V = line(p, vec2(280, 404), vec2(119, 566));\n\t\tif((!M && N) || ((!O && P || !Q && !M) && R) || (!S && !M && !T) || (U && !T && V))\n\t\t{\n\t\t\tif(circle(p, vec2(491, 84), 764.))\n\t\t\t\tc = COLOR_MANE1;\n\t\t\telse\n\t\t\t\tif(circle(p, vec2(686, 204), 576.))\n\t\t\t\t\tc = COLOR_MANE2;\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_MANE3;\n\t\t}\n\t\telse\n\t\t\tc = COLOR_MANELINE;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool mane2(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(607, 464), 306.);\n\tbool B = circle(p, vec2(777, 485), 339.);\n\tbool C = circle(p, vec2(1181, -127), 463.);\n\tbool D = circle(p, vec2(-433, 198), 1442.);\n\tbool E = line(p, vec2(554, -80), vec2(1055, -80));\n\tif((A && !B || !C) && !D && E)\n\t{\n\t\tbool F = circle(p, vec2(613, 461), 319.);\n\t\tbool G = circle(p, vec2(769, 486), 323.);\n\t\tbool H = circle(p, vec2(1195, -123), 454.);\n\t\tbool I = circle(p, vec2(288, 485), 691.);\n\t\tbool J = circle(p, vec2(122, 278), 864.);\n\t\tif((F && !G || !H) && !I && !J)\n\t\t\tc = COLOR_MANE4;\n\t\telse\n\t\t{\n\t\t\tbool K = circle(p, vec2(388, 235), 607.);\n\t\t\tbool L = circle(p, vec2(416, 87), 570.);\n\t\t\tif(K && !L)\n\t\t\t\tc = COLOR_MANE5;\n\t\t\telse\n\t\t\t\tc = COLOR_MANELINE;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool face(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(588, 396), 357.);\n\tbool B = line(p, vec2(325, 74), vec2(887, 122));\n\tbool C = ellipse(p, vec2(489, 237), vec2(287, 166));\n\tbool D = circle(p, vec2(209, 437), 163.);\n\tif(!A && B || !C && D)\n\t{\n\t\tbool E = ellipse(p, vec2(536, 253), vec2(315, 170));\n\t\tbool F = circle(p, vec2(500, 921), 828.);\n\t\tbool G = circle(p, vec2(220, 367), 110.);\n\t\tbool H = line(p, vec2(201, 454), vec2(658, 108));\n\t\tbool I = line(p, vec2(237, 115), vec2(363, 238));\n\t\tbool J = ellipse(p, vec2(283, 204), vec2(68, 57));\n\t\tbool K = ellipse(p, vec2(253, 192), vec2(102, 70));\n\t\tbool L = circle(p, vec2(285, 228), 19.);\n\t\tbool M = circle(p, vec2(281, 236), 19.);\n\t\tif((!E && !F && G || H) && (I || !J || K) && (L || !M))\n\t\t\tc = COLOR_BODY;\n\t\telse\n\t\t\tc = COLOR_LINE;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool eye1(inout vec3 c, vec2 p)\n{\n\t// skewed ellipse please ignore\n#define SQR(q) ((q) * (q))\n\tbool A = SQR((p.x - 590.0) / 150.0 - (p.y - 378.0) / 900.0) + SQR((p.y - 378.0) / 180.0) < 1.0;\n\tif(A)\n\t{\n\t\tbool B = SQR((p.x - 593.0) / 149.0 - (p.y - 382.0) / 900.0) + SQR((p.y - 361.0) / 180.0) < 1.0;\n\t\tif(B)\n\t\t{\n\t\t\tvec2 d = vec2(0.0, 0.0) - vec2(580, 360);\n\t\t\tif(length(d) > 60.0)\n\t\t\t   d = d / length(d) * 60.0;\n\t\t\tbool C = ellipse(p, vec2(580, 360) + d, vec2(112, 162));\n\t\t\tif(C)\n\t\t\t\tc = COLOR_WHITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool D = ellipse(p, vec2(551, 305) + d, vec2(19, 26));\n\t\t\t\tbool E = ellipse(p, vec2(601, 410) + d, vec2(35, 57));\n\t\t\t\tif(D && E)\n\t\t\t\t{\n\t\t\t\t\tbool F = ellipse(p, vec2(580, 360) + d * 1.3, vec2(71, 126));\n\t\t\t\t\tif(F)\n\t\t\t\t\t\tc = mix(COLOR_IRIS1, COLOR_IRIS2, SQR((p.y - 360.0 - d.y) / 252.0 + 0.5));\n\t\t\t\t\telse\n\t\t\t\t\t\tc = COLOR_BLACK;\n                    \t//c = COLOR_WHITE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_WHITE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tc = COLOR_EYEBROW;\n\t\treturn true;\n\t}\n\t// rotating ellipses hacks, nothing to see here\n\tbool G = ellipse(p, vec2(757, 430), vec2(40, 5));\n\tbool H = ellipse(vec2(p.x + p.y * 0.3, p.x * -0.3 + p.y), vec2(890, 260), vec2(40, 6));\n\tbool I = ellipse(vec2(p.x + p.y * 0.5, p.x * -0.5 + p.y), vec2(990, 175), vec2(40, 7));\n\tif(!G || !H || !I)\n\t{\n\t\tc = COLOR_BLACK;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool eye2(inout vec3 c, vec2 p)\n{\n\tbool A = line(p, vec2(207, 460), vec2(323, 265));\n\tbool B = circle(p, vec2(213, 434), 158.);\n\tbool C = circle(p, vec2(739, 417), 500.);\n\tbool D = ellipse(p, vec2(289, 444), vec2(50, 144));\n\tif(!A && !B && !C || !D)\n\t{\n\t\tbool E = ellipse(p, vec2(285, 390), vec2(47, 184));\n\t\tif(!E)\n\t\t{\n\t\t\tvec2 d = vec2(0.0, 0.0) - vec2(290, 360);\n\t\t\tif(length(d) > 60.0)\n\t\t\t   d = d / length(d) * 60.0;\n\t\t\td *= vec2(0.33, 1.0);\n\t\t\tbool F = ellipse(p, vec2(290, 360) + d, vec2(50, 162));\n\t\t\tif(F)\n\t\t\t\tc = COLOR_WHITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool D = ellipse(p, vec2(304, 446) + d, vec2(17, 41));\n\t\t\t\tbool E = ellipse(p, vec2(278, 354) + d, vec2(11, 24));\n\t\t\t\tif(D && E)\n\t\t\t\t{\n\t\t\t\t\tbool F = ellipse(p, vec2(290, 360) + d * 1.3, vec2(42, 126));\n\t\t\t\t\tif(F)\n\t\t\t\t\t\tc = mix(COLOR_IRIS1, COLOR_IRIS2, SQR((p.y - 360.0 - d.y) / 252.0 + 0.5));\n\t\t\t\t\telse\n\t\t\t\t\t\tc = COLOR_BLACK;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_WHITE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tc = COLOR_EYEBROW;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool neck(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(1247, -28), 638.);\n\tbool B = circle(p, vec2(353, 258), 638.);\n\tbool C = line(p, vec2(554, -80), vec2(1055, -80));\n\tif(!A && !B && C)\n\t{\n\t\tbool D = circle(p, vec2(1235, -21), 606.);\n\t\tif(D)\n\t\t\tc = COLOR_LINE;\n\t\telse\n\t\t\tc = COLOR_BODY;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvec2 transform(vec2 x)\n{\n\treturn (x - iResolution.xy / 2.0) / iResolution.y * 1000.0 + 500.0;\n}\n\nfloat sinslope(float t)\n{\n\treturn sin(t) - sin(t - 0.01);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tm = transform(iMouse.xy * iResolution.xy);\n\tvec2 p = transform(fragCoord.xy);\n\tp.x += sin(iTime) * 600.0;\n\tp.y += abs(sin(iTime*7.0))*10.0 * (abs(sinslope(iTime)) * 2000.0);\n\tvec3 c = vec3(1, 1, 1);\n\tear(c, p) || mane(c, p) || mane2(c, p) || eye1(c, p) || eye2(c, p)  || face(c, p) || neck(c, p);\n\tfragColor = vec4(c, 1);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSBzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[778, 944, 979, 979, 1049], [1051, 1051, 1089, 1198, 1231], [1233, 1233, 1271, 1367, 1413], [1424, 1424, 1456, 1456, 1892], [1894, 1894, 1927, 1927, 3322], [3324, 3324, 3358, 3358, 4104], [4106, 4106, 4139, 4139, 4934], [4936, 4936, 4969, 5002, 6269], [6271, 6271, 6304, 6304, 7259], [7261, 7261, 7294, 7294, 7588], [7590, 7590, 7614, 7614, 7685], [7687, 7687, 7712, 7712, 7747], [7749, 7749, 7806, 7806, 8131]]}
{"id": "tlSfDK", "name": "maya pyramid", "author": "FabriceNeyret2", "description": "reference: \n[img]https://static.boredpanda.com/blog/wp-content/uploads/2020/09/real-life-old-photos-then-now-15-5f5b5a1616b90__700.jpg[/img]\n\nNote that my anti-banding tricks doesn't work here, due to the heap of discontinuities.", "tags": ["raytracing", "raymarching", "temple", "pyramid", "maya", "inca"], "likes": 8, "viewed": 241, "published": "Public API", "date": "1599845753", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a)      mat2( cos( a + vec4(0,33,11,0)) )\n#define sfloor(x) ( floor(x-pix/2.) + max( 0., 1.-fract(-x+pix/2.) / pix ) ) // https://www.shadertoy.com/view/tsyXzV \n        \nfloat pix, s;                                         // a: material id\n\nfloat map( vec3 q ) {\n    float t,a;\n    q.xy = abs(q.xy), a = max(q.x,q.y), \n    t = max( (a==q.x?q.y:q.x) -2. ,                   // slopes sides\n             a/1.3 + clamp(q.z,0.,9.) -9.25 ),        // slopes top \n    t = max( t, q.z-7.),                              // top end\n    t = min( t, a + clamp(sfloor(q.z),0.,7.) - 9.),   // grades \n    t = max( t,-max(min(q.x,q.y)-.5,abs(q.z-7.5)-.5)),// doors\n    t = max( t, q.z-9.),                              // top end\n    t = min(t, s = q.z);                              // floor\n    return t;\n}\n\nvoid mainImage(out vec4 O, vec2 u) {\n     vec2  R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;                      // normalized centered coords\n    pix = .5; // 100./R.y;\n    float t = iTime, _t = 1.+.5*sin(.2*(t+5.)), \n          c = 0.;                                     // color (pseudo-shading), delta per iteration\n    vec3  D = normalize( vec3(U,-2) ),                // ray direction. z = field of view = zoom\n          p = vec3(0,0,25), q;                        // ray origin, then current point on ray\n    D.yz *= rot(_t); D.xy *= rot(.3*t);               // rotate camera\n    p.yz *= rot(_t); p.xy *= rot(.3*t);\n\n    for ( ; c < 50. && t > .01 ; c++ )                // march scene\n        q = p, _t=t,\n        t = map(q),                                   // distance to objects\n        p += .5*t*D;                                  // sphere-tracing step\n    \n    c = 1. - c/50.;                                   // pseudo-lighting\n    O = t==s ? vec4(0,.2,0,1) : vec4(1,.8,.6,1);      // coloring\n    O = pow( c*O, vec4(1./2.2) );                     // to sRGB\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}, {"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSfDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 255, 276, 276, 808], [810, 810, 846, 846, 1897]]}
{"id": "tlSfDV", "name": "Shader Royale test run - yx", "author": "yx", "description": "Coded live for the Inrcia Demoparty Shader Royale test stream", "tags": ["livecoding"], "likes": 5, "viewed": 131, "published": "Public", "date": "1599858439", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// tweaks added post-stream\n#define IMPROVED 1\n#define INSTAGRAM_COLORS 0\n\n\n#define iTime (iTime*.3)\n\n//#define pi uintBitsToFloat(0x40490FDB)\n#define pi acos(-1.)\n\nmat2 rotate(float a)\n{\n\tfloat c=cos(a),s=sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\nfloat tick(float t)\n{\n\tt = fract(t);\n\tt = smoothstep(0.,1.,t);\n\tt = smoothstep(0.,1.,t);\n\treturn t;\n}\n\nfloat square(vec2 p, float r)\n{\n\tp=abs(p)-r;\n\treturn max(p.x,p.y);\n}\n\nfloat squircle(vec2 p, float r)\n{\n\tfloat c = length(p)-r;\n\tfloat b = square(p,r);\n\treturn mix(c,b,tick(sin(iTime)*.5+.5));\n}\n\nfloat sdf(vec2 p, float i)\n{\n\tfloat l = length(p);\n\t\n\tp=-abs(p);\n\tp -= tick(iTime+l*.1);\n\t\n\t//p = sin(p*pi+iTime*10.)*.5;\n\t\n\tp = fract(p+.5)-.5;\n\t\n\tfloat T = iTime*6.+i*pi/3.+l*2.;\n\t\n\tfloat r = tick(sin(T)*.5+.5)*.2+.1;\n\tfloat d = 1e9;\n\td = min(d,length(p.x)+sin(T)*.05);\n\td = min(d,length(p.y)+sin(T)*.05);\n\tp *= rotate(T*.5);\n\td = min(d,abs(squircle(p,r))-.02);\n\treturn d;\n\t//return abs(length(p)-1.)-.1;\n}\n\nvoid mainImage(out vec4 out_color, in vec2 fragCoord)\n{\n\tconst float speed = 2.;\n\t\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\tuv *= 2.;\n\n\tuv *= rotate(atan(uv.x,uv.y)*0.25);\n\tuv += uv;\n\tuv = abs(uv);\n\tuv = vec2(max(uv.x,uv.y),min(uv.x,uv.y));\n\t//uv *= rotate(atan(uv.x,uv.y)*2);\n\t\n\tvec3 cam = vec3(0,0,-10);\n\tvec3 dir = normalize(vec3(uv,5));\n\t\n\tcam.yz *= rotate(sin(iTime*.3));\n\tdir.yz *= rotate(sin(iTime*.3));\n\tcam.xz *= rotate(iTime*.1);\n\tdir.xz *= rotate(iTime*.1);\n\t\n\tfloat t1 = (cam.y/-dir.y);\n\tfloat t2 = (cam.z/-dir.z);\n\tfloat t3 = (cam.x/-dir.x);\n\tt1=t1>0.?t1:10000.;\n\tt2=t2>0.?t2:10000.;\n\tt3=t3>0.?t3:10000.;\n\t\n\tvec2 uv1 = cam.xz+dir.xz*t1;\n\tvec2 uv2 = cam.xy+dir.xy*t2;\n\tvec2 uv3 = cam.yz+dir.yz*t3;\n\t\n\t//uv1 = fract(uv1+.5)-.5;\n\t//uv2 = fract(uv2+.5)-.5;\n\t//uv3 = fract(uv3+.5)-.5;\n\t\n\tfloat d1 = sdf(uv1,0.);\n\tfloat d2 = sdf(uv2,1.);\n\tfloat d3 = sdf(uv3,2.);\n\t\n\tfloat f1 = pow(.9,t1);\n\tfloat f2 = pow(.9,t2);\n\tfloat f3 = pow(.9,t3);\n\t\n\tvec3 color = vec3(0);\n\tcolor += vec3(smoothstep(0.,abs(length(fwidth(uv1))*5.),-d1)) * f1 * vec3(1,0,0);\n\tcolor += vec3(smoothstep(0.,abs(length(fwidth(uv2))*5.),-d2)) * f2 * vec3(0,1,0);\n\tcolor += vec3(smoothstep(0.,abs(length(fwidth(uv3))*5.),-d3)) * f3 * vec3(0,0,1);\n\n#if IMPROVED\n    // tweak added post-stream\n\tcolor += vec3(3,1,1)*.005/(abs(d1)+.004) * f1;\n\tcolor += vec3(1,3,1)*.005/(abs(d2)+.004) * f2;\n\tcolor += vec3(1,1,3)*.005/(abs(d3)+.004) * f3;\n#else\n\tcolor += vec3(3,1,1)*.005/abs(d1) * f1;\n\tcolor += vec3(1,3,1)*.005/abs(d2) * f2;\n\tcolor += vec3(1,1,3)*.005/abs(d3) * f3;\n#endif\n    \n\tcolor.r += (sin(max(uv1.x,uv1.y))*.2+.2) * f1;\n\tcolor.g += (sin(max(uv2.x,uv2.y))*.2+.2) * f2;\n\tcolor.b += (sin(max(uv3.x,uv3.y))*.2+.2) * f3;\n\n\tcolor = pow(color,vec3(2.));\n\t\n\t//color.xy = (color.xy-.5)*rotate(iTime)+.5;\n\t\n\tcolor /= 1.-dot(uv,uv)*.06;\n\t//color = clamp(color,0,1);\n\t//color *= 1.-dot(uv,uv)*.05;\n\t\n\tout_color = vec4(1.-color, 1);\n    \n    // instagram colors\n#if INSTAGRAM_COLORS\n    out_color.rgb = mix(vec3(0,.2,.4),vec3(1,.8,.6),out_color.rgb);\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSfDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 165, 187, 187, 239], [241, 241, 262, 262, 342], [344, 344, 375, 375, 412], [414, 414, 447, 447, 538], [540, 540, 568, 568, 948], [950, 950, 1005, 1005, 3066]]}
{"id": "tlSfW3", "name": "maya pyramid + texture + forest", "author": "FabriceNeyret2", "description": "Mouse control : angles. +SPACE: zoom\nvariant of [url]https://shadertoy.com/view/tlSfDK[/url]\n\nreference: \n[img]https://static.boredpanda.com/blog/wp-content/uploads/2020/09/real-life-old-photos-then-now-15-5f5b5a1616b90__700.jpg[/img]\n", "tags": ["raytracing", "raymarching", "temple", "pyramid", "maya", "inca"], "likes": 18, "viewed": 428, "published": "Public API", "date": "1599986154", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// textured + displaced + mouse control variant of https://shadertoy.com/view/wl2BWV\n// forest variant of https://shadertoy.com/view/tlSfDK\n\n#define rot(a)        mat2( cos( a + vec4(0,33,11,0)) )\n#define sfloor(x)   ( floor(x-pix/2.) + max( 0., 1.-fract(-x+pix/2.) / pix ) ) // https://www.shadertoy.com/view/tsyXzV \n#define hash2x3(p)    fract(sin((p)*mat3x2(127.1,311.7,  269.5,183.3,  113.5,271.9))*43758.5453123) // https://www.shadertoy.com/view/llySRh\n#define keyPress(a) ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.) // https://www.shadertoy.com/view/llySRh\n#define T(V)          texture(iChannel1,V/4.)\n\nfloat pix, s;                                         // a: material id\n\nfloat map( vec3 p ) {\n    float t,a; vec3 q = p;\n    q.xy = abs(q.xy), a = max(q.x,q.y);               // --- pyramid\n    t = max( (a==q.x?q.y:q.x) -2.,                    // slopes sides\n             a/1.3 + clamp(q.z,0.,9.) -9.25 );        // slopes top \n    t = max( t, q.z-7.);                              // top end\n    t = min( t, a + clamp(sfloor(q.z),0.,7.) - 9.);   // grades \n    t = max( t,-max(min(q.x,q.y)-.5,abs(q.z-7.5)-.5));// doors\n    t = max( t,-max(3.*abs(q.z-7.5),a)+1.5 );         // room\n    t = max( t, q.z-9.);                              // top end\n    s = q.z;                                          // --- forest. floor, then trees\n    q = .03*sin(15.*p); p += q.x+q.y+q.z;             // distortion\n    for (int k=0; k<9; k++) {                         // Worley-like dot structure\n        vec2 d = vec2(k%3-1,k/3-1);                   // seek for closest dot in 9x9 cells around\n        s = min(s, length( hash2x3(floor(p.xy)+d)           // random dot(cell)\n                          - vec3(fract(p.xy)-d,p.z) ) -.5); // raypos rel to cur cell\n    }\n    return min(t,s);\n}\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y,                     // normalized centered coords\n          M = iMouse.xy / R;\n    pix = .5; // 100./R.y;\n    float t = iTime, _t = 1.+.5*sin(.2*(t+5.)), \n          c = 0.,z = 2.; // Z=0.;                     // color (pseudo-shading), zoom\n    t*=.3; if (iMouse.z>0.)                           // mouse control\n        _t = keyPress(32) ? z=9.*M.y,_t : 1.6*M.y, t = -3.*M.x;\n    vec3  D = normalize( vec3(U,-z) ),                // ray direction. z = field of view = zoom\n          p = vec3(0,0,25);                           // ray origin, then current point on ray\n    D.yz *= rot(_t); D.xy *= rot(t);                  // rotate camera\n    p.yz *= rot(_t); p.xy *= rot(t);\n    t = 1e5;\n    for ( ; c < 50. && t > .01 ; c++ )                // march scene\n        t = map(p),                                   // distance to objects\n        t != s ? t += .3*( T(.3*p.xy)+T(.3*p.xz)+T(.3*p.yz) -1.5 ).r : t, // displacement (temple)\n        p += .5*t*D;  // Z+=t;                        // sphere-tracing step\n    \n  //c = 1. - c/50.;                                   // pseudo-lighting\n // O = vec4(1.3-.01*Z); return;                      // Depth buffer\n    c = 4.*exp(-c/10.);\n    O = t==s                                          // coloring\n             ?  p.z > 2. ? vec4(0,0,2,1)                          // sky\n             :  vec4(0,.2,0 ,1)*(.7+.3*p.z)                       // forest\n              *(.5+1.5*texture(iChannel2,p.xy).r)\n             : vec4(1,.8,.6,1) *( T(p.xy)+T(p.xz)+T(p.yz) -1.)/1.5;// temple\n    O = pow( c*O, vec4(1./2.2) );                     // to sRGB\n}\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}, {"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSfW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[666, 685, 706, 706, 1792], [1794, 1794, 1830, 1830, 3486]]}
{"id": "tlSfzG", "name": "Equation Viewer, nickak", "author": "nickak", "description": "In the function, equation, you experiment with, equations on x and y. the result is like a third dimensional color value. ", "tags": ["c"], "likes": 1, "viewed": 71, "published": "Public", "date": "1599190499", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 expandColor( int c ){\n    \n    //normalize? \n    uint uc=0u;\n    if( c < 0 )\n        uc =  65536u - (65536u - uint( abs(c)));\n    else\n        uc = uint(c) + 65536u;\n    \n    uint blueMask = uint(0xFF0000), greenMask = uint(0xFF00), redMask = uint(0xFF);\n\n    vec3 cout;\n    \n    cout.r = float(uc & redMask) /255.0f;\n    cout.g = float((uc & greenMask) >> 8) /255.0f;\n    cout.b = float((uc & blueMask) >> 16) /255.0f; \n\n    return cout;\n}\n\nint equation(float x, float y){\n\n    //example equations\n    \n    float outValue =0.0;\n    \n\t//outValue = pow(x,4.0)/pow(y,3.0)* sin(x/y)/cos(x*y);\n   outValue =  y/(x-y) * (x+1.0) * (y-1.0) + pow( (x / 2.0) ,3.0)/ pow(y/3.0, 2.0) ;\n   //outValue =  outValue - (y/(x-y) * (x+1.0) * (y-1.0) + pow( (x / 2.0) ,2.0) );\n   // outValue = pow(x,3.0) - pow(y,2.0) + pow(x,2.0) - y ;\n  // outValue = x*y;\n    //outValue =  x*x+y*y;;\n\t//outValue = sqrt(x*x+y*y);\n    //outValue = (y*x) / (y-x) * x/(y+x);\n    \n    return int(outValue);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float zoom =  50.0*cos(iTime/20.0);\n   \n    float x = fragCoord.x*zoom;\n    float y = fragCoord.y*zoom;\n    \n    float w = iResolution.x*zoom;\n    float h = iResolution.y*zoom;\n    \n    x=x-w/2.0;\n    y=y-h/2.0;\n    \n    // Time varying pixel color\n    vec3 col = expandColor(equation(x, y));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSfzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 27, 50, 446], [448, 448, 479, 504, 976], [979, 979, 1036, 1036, 1396]]}
{"id": "ts3cRl", "name": "BLOB 3D", "author": "edorobek", "description": "they are 3d now", "tags": ["blolb"], "likes": 0, "viewed": 45, "published": "Public", "date": "1601485504", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n\nfloat sphereSDF(vec3 p, vec3 q) {\n    return length(p - q) - 1.0;\n}\n\nfloat sceneSDF(vec3 p)\n{\n    return smin(smin(sphereSDF(p, vec3(0.0)), \n                sphereSDF(p, vec3(1.6*sin(iTime) - 3.0, 1.0, 0.0)), \n                .9), sphereSDF(p, vec3(0.0, 2.0, 0.0)), .9);\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(12.0,\n                          15.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.6, 0.6, 0.6);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n   vec3 light2Pos = vec3(-2.0,\n                          2.0,\n                       2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 11.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3cRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 167, 167, 251], [254, 254, 287, 287, 321], [323, 323, 347, 347, 526], [528, 528, 619, 619, 925], [927, 927, 992, 992, 1124], [1127, 1127, 1156, 1156, 1466], [1468, 1468, 1608, 1608, 2198], [2200, 2200, 2285, 2285, 3018], [3020, 3020, 3069, 3104, 3330], [3332, 3332, 3389, 3389, 4161]]}
{"id": "ts3yD7", "name": "Timeless depths - cineshader", "author": "kesson", "description": "A timeless depths, constantly mutating over time.\n\nA raymarch experiment based on the tutorial by The Art Of Code: https://www.youtube.com/watch?v=-adHIyjIYgk", "tags": ["cineshader"], "likes": 12, "viewed": 9470, "published": "Public API", "date": "1601025359", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright 2020 - Giovanni Muzio\n// https://kesson.io\n//\n// Full Shadertoy version https://www.shadertoy.com/view/ttlyWB\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n#define MAX_STEPS 100\n#define MAX_DIST 8.\n#define SURF_DIST .001\n#define GYROID_DETAILS 12\n#define WIDEANGLE 0 // set this to 1 for a wide angle pseudo-distortion\n\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdGyroid(vec3 p, float s, float t, float b) {\n    vec3 st = p * s;\n    \n    float lx = 1.0 + ((sin(iTime * 0.0576) * 0.5) + 0.5) * 0.25;    \n    float ly = 1.0 + ((cos(iTime * 0.0565) * 0.5) + 0.5) * 0.25;\n    \n    float ls = max(lx, ly);\n    \n    return abs(dot(sin(st * lx), cos(st.zxy * ly)) - b) / (s * ls) - t;\n}\n\nvec3 transform(vec3 p) {\n    p.xy *= rotate(p.z * 0.1);\n    p.z += iTime * 0.1;\n    p.y -= 0.3;\n    return p;\n}\n\nfloat GetDist(vec3 p) {\n    p = transform(p);\n        \n    float s = 10.798;\n    float t = 0.03;\n    float b = 0.3;\n    float m = 0.5;\n    \n    float s1 = 1.345 + ((sin(iTime* 0.01) * 0.5) + 0.5);\n    float g1 = sdGyroid(p, s1, 0.03, 1.5);\n    \n    for (int i = 0; i < GYROID_DETAILS; i++) {\n        if (i <= 1) g1 -= sdGyroid(p, s, t, b) * m;\n        else g1 += sdGyroid(p, s, t, b) * m;\n        s *= 1.75;\n        m *= 0.75;\n    }\n    \n    float d = g1 * 0.7;\n   \t\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 bg(vec3 rd) {\n\tvec3 col = vec3(0.0);\n    float t = iTime * 0.2;\n    \n    float y = clamp(smoothstep(0.3, 1.0, rd.y * 0.5 + 0.5), 0.1, 1.0);\n    col += y * vec3(0.05, 0.18, 0.38) * 6.0;\n    \n    float a = atan(rd.x, rd.z);\n    float flares = 0.7 * sin(a*20.+t)*sin(a*2.-t)*sin(a*6.);\n    flares *= smoothstep(.0, 1.0, y);\n    col += flares;\n    col = max(col, 0.);    \n    return col;\n}\n\nvec3 getDiff(vec3 p, vec3 rd) {\n    vec3 n = GetNormal(p);\n    return reflect(rd, n);\n}\n\n// Camera matrix and movement from https://www.shadertoy.com/view/ldl3Dl\nvoid camera(float cd, vec2 uv, float an, out vec3 ro, out vec3 rd) {\n    ro = vec3( cd*cos(an), cd * sin(an), cd*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    rd = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    if (WIDEANGLE == 1) {\n    \tuv += sin(uv*2.0); // wideangle distortion\n    }\n            \n    vec3 col = vec3(0.0);\n    \n    float t = iTime * 0.01;\n    \n    uv += sin(uv*20.+t)*.01;\n    \n    float an = -iTime * 0.05;\n    \n    vec3 ro, rd;\n    float cd = 0.01; // camera distance\n    camera(cd, uv, an, ro, rd); // get the camera\n    \n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        vec3 dr = getDiff(p, rd);\n    \tcol =vec3(0.0);\n        \n        p = transform(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(0.0,0.0,1.0)))*.5+.5;\n        col *= dif;\n    \tcol += dif;\n        \n        float b = sdGyroid(p, 10.798, 0.03, 0.3);\n        col *= smoothstep(-0.05, 0.1, b);\n        \n        float cw = -0.02 + smoothstep(0.0, -0.5, n.y) * 0.02;\n        float c = smoothstep(cw, -0.03, b);\n        float cc = 1.0 - (sdGyroid(p+t, 6.789, 0.03, 0.3) * 4.0);\n        float cc2 = 1.0 - (sdGyroid(p-t*0.5, 3.789, 0.03, 0.3) * 2.0);\n        col += c * vec3(0.1, 0.4, 1.0) * cc * cc2 * 3.0;\n    }\n    \n    col = mix(col, bg(rd), smoothstep(0.0, MAX_DIST, d));\n    \n    fragColor = vec4(col,d / 3.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3yD7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 381, 403, 403, 479], [481, 481, 532, 532, 804], [806, 806, 830, 830, 917], [919, 919, 942, 942, 1401], [1403, 1403, 1437, 1437, 1648], [1650, 1650, 1674, 1674, 1863], [1865, 1865, 1915, 1915, 2106], [2108, 2108, 2126, 2126, 2498], [2500, 2500, 2531, 2531, 2587], [2589, 2662, 2730, 2730, 3007], [3009, 3009, 3065, 3065, 4303]]}
{"id": "ts3yDN", "name": "Normal Map Stuff by Flyguy-v2", "author": "jorge2017a1", "description": "Normal Map Stuff by Flyguy-v2", "tags": ["normalmapstuffbyflyguyv2"], "likes": 5, "viewed": 78, "published": "Public", "date": "1600954651", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Normal Map Stuff */\n/* By: Flyguy */\n/* With help from http://stackoverflow.com/q/5281261 */\n// fancified a bit by psonice\n// slimified a bit by kabuto\n \n\n#define PI 3.141592\n\n\nfloat heightmap(vec2 position)\n{\n\tfloat height = 0.0;\n\tfloat f = .002;\n\tvec2 timevec = iTime*vec2(.1,.13);\n\tfloat g = sqrt(1.25)+.5;\n\tposition *= f;\n\tfloat c = cos(2.*PI*g);\n\tfloat s = sin(2.*PI*g);\n\tmat2 matcs = mat2(c,s,-s,c)*g;\n\tfor (int i = 0; i < 13; i++) {\n\t\tvec2 v = fract(position + timevec)-.5;\n\t\tfloat dots = max(0.,.13-dot(v,v));\n\t\tdots = dots*dots*dots/f*8.;\n\t\theight += dots*dots*2.;//max(height,dots);\n\t\tf *= g;\n\t\tposition *= matcs;\n\t}\n\t\n\treturn sqrt(height);\n}\n\t\nfloat n1,n2,n3,n4;\nvec2 size = vec2(-0.4,0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 mouse;\n\tvec2 pos = fragCoord.xy;\n\tmouse.x=0.5+0.5*cos(iTime);\n    mouse.y=0.5+0.5*sin(iTime);\n    \n\tn1 = heightmap(vec2(pos.x,pos.y-1.0));\n\tn2 = heightmap(vec2(pos.x-1.0,pos.y));\n\tn3 = heightmap(vec2(pos.x+1.0,pos.y));\n\tn4 = heightmap(vec2(pos.x,pos.y+1.0));\n\t\n\tvec3 p2m = vec3(-((pos/iResolution.xy)-mouse.xy)*iResolution.xy,iResolution.x*1.1);\t\n\t\n\tvec3 normal = normalize(vec3(n2-n3, n1-n4, 0.4));\n\t\n\tfloat color = dot(normal, normalize(p2m))*.5+.5;\n\tvec3 colorvec = vec3(pow(color,10.),pow(color,5.),pow(color,2.5));\n\t\n\tfloat brightness = 1./sqrt(1.+pow(distance(mouse.xy*iResolution.xy,pos)/iResolution.x*8.,2.));\n\t\n\tfragColor = vec4( colorvec*brightness, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3yDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 180, 212, 212, 655], [706, 706, 763, 763, 1439]]}
{"id": "ts3yRX", "name": "Fast Cloud Test", "author": "Dragonpeak", "description": "A quick test of a fast cloud technique, still optimizing.", "tags": ["noise", "clouds", "fast"], "likes": 2, "viewed": 203, "published": "Public API", "date": "1601387405", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 CAMERA_POS = vec3(0.,0.,0.2);\nvec3 CAMERA_LOOK = vec3(0., 0., 2.);\n\nfloat CLOUD_SCALE = 0.5;\nvec3 CLOUD_WIND = vec3(0.2, 0.4, 0.1)*0.2;\nconst float CLOUD_HEIGHT = 4.;\nconst int CLOUD_OCT = 6;\nconst float FAR = 200.;\nconst float CLOUD_COVER = 1.1;\n\nconst vec3 CLOUD_COL = vec3(.9);\n\nconst float CLOUD_END_HEIGHT = CLOUD_HEIGHT + 0.15;\n\nconst int LIGHT_STEPS = 8;\nconst float LIGHT_FAR = 1.;\n\nvec3 LIGHT_DIR = normalize(vec3(0.4, 0.8, 0.1));\nconst vec3 LIGHT_COL = vec3(1., 0.9, 0.8)*0.8;\nconst vec3 AMBIENT = vec3(0.5, 0.5, 0.6)*0.7;\n//uncomment for 3d noise\n//#define USE_3D \n//uncomment for volume marching\n//#define USE_VOLUME\nconst int VOLUME_STEPS = 12;\nconst float VOLUME_FAR = 2.;\n\nvec3 ray_direction(float fov, vec2 size, vec2 coord) {\n    // from https://www.shadertoy.com/view/Xtd3z7\n    vec2 xy = coord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 view_matrix(vec3 eye, vec3 center, vec3 up) {\n    // from https://www.shadertoy.com/view/Xtd3z7\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\n//from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n#ifdef USE_3D\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n#endif\n#ifndef USE_3D\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec3 ps){\n    vec2 p = ps.xy;\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res+0.1;\n}\n#endif\n//end from\n\nfloat get_cloud_density(vec3 pos, int oct)\n{\n    \n    vec3 a_pos = pos*CLOUD_SCALE + CLOUD_WIND*iTime;\n\n    a_pos += CLOUD_WIND*iTime;\n    float dens = noise(a_pos/2.);\n    float scl = 1.;\n    float str = 1.;\n    \n    for(int i = 0; i < oct; i++)\n    {\n\t\tdens += noise(a_pos*scl)*str;\n        str*=0.6;\n        scl*=1.9;\n    }\n    dens -= 1.8;\n    dens *= 2.;\n    dens += CLOUD_COVER;\n    #ifndef USE_3D\n    dens -= pos.z-CLOUD_HEIGHT;\n    #endif\n \treturn dens;   \n}\n\nfloat march_light(vec3 pos, vec3 dir)\n{\n    float dens = 0.;\n    float depth = 0.001;\n\tfor(int i = 0; i < LIGHT_STEPS; i++)\n    {\n\t\tvec3 p = pos + dir*depth;\n        depth += LIGHT_FAR/float(LIGHT_STEPS);\n        \n        dens += clamp(get_cloud_density(p, CLOUD_OCT), 0., 1.);\n        if(depth > LIGHT_FAR || pos.z > CLOUD_END_HEIGHT){return dens/float(LIGHT_STEPS);}\n    }\n    return dens/float(LIGHT_STEPS);\n}\n\n\nvec3 draw_sky(vec3 pos)\n{\n    vec3 col = mix(vec3(0.8, 0.8, 0.95), vec3(0.5, 0.5, 0.7), pos.z/FAR);\n    vec3 sun = LIGHT_DIR * FAR;\n    col += clamp(LIGHT_COL * 1.-clamp(distance(sun, pos)/FAR*5., 0., 1.), 0., 1.);\n\treturn col;\n}\nvec2 march_volume(vec3 pos, vec3 dir)\n{\n\tfloat dens = 0.;\n    float depth = 0.001;\n    float light_dens = 0.;\n\tfor(int i = 0; i < VOLUME_STEPS; i++)\n    {\n\t\tvec3 p = pos + dir*depth;\n        depth += VOLUME_FAR/float(VOLUME_STEPS);\n        light_dens += march_light(p, LIGHT_DIR);\n        dens += clamp(get_cloud_density(p, CLOUD_OCT), 0., 1.);\n        if(depth > VOLUME_FAR || pos.z > CLOUD_END_HEIGHT){return vec2(dens/float(VOLUME_STEPS), light_dens/float(VOLUME_STEPS));}\n    }\n    return vec2(dens/float(VOLUME_STEPS), light_dens/float(VOLUME_STEPS));\n}\nvec4 draw_clouds(vec3 pos, vec3 dir)\n{\n    vec3 col = CLOUD_COL;\n    #ifdef USE_VOLUME\n    vec2 r = march_volume(pos, dir);\n    float dens = r.x;\n    float light = 1.-r.y;\n    #endif\n    #ifndef USE_VOLUME\n\tfloat dens = clamp(get_cloud_density(pos, CLOUD_OCT), 0., 1.);\n    float light = 1.;\n    if(dens > 0.05)\n    {\n\t\tlight = 1.-march_light(pos, LIGHT_DIR);\n        \n    }\n    #endif\n    vec3 light_col = LIGHT_COL*light + AMBIENT*(1.7-dens+0.5);\n    col = CLOUD_COL*light_col;\n\n    return vec4(col, dens);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CAMERA_POS.y = sin(iTime*0.1)*8.;\n    CAMERA_POS.x = cos(iTime*0.1)*8.;\n    LIGHT_DIR.z = sin(iTime*0.1);\n    LIGHT_DIR.x = cos(iTime*0.1);\n    vec3 local_dir = ray_direction(80., iResolution.xy, fragCoord);\n    \n    mat4 view = view_matrix(CAMERA_POS, CAMERA_LOOK, vec3(0.,0.,1.));\n    vec3 dir = (view * vec4(local_dir, 0.)).xyz;\n    \n    vec3 pos = CAMERA_POS + dir * FAR;\n    vec3 col = draw_sky(pos);\n    \n\n    if(pos.z > CLOUD_HEIGHT)\n    {\n\t\tpos = vec3(vec2(pos.x, pos.y)/pos.z, CLOUD_HEIGHT);\n        vec4 cloud = draw_clouds(pos, dir);\n        col = mix(col, cloud.xyz, clamp(cloud.w, 0., 1.));\n    }\n    //if(false)\n    if(pos.z <= 0.)\n    {\n        pos = vec3(vec2(pos.x, pos.y)/pos.z, 0.);\n\t\tcol = vec3(0.);\n        float sc = 0.005;\n        for(int i = 0; i < 8; i++)\n        {\n\t\t\tcol += mix(vec3(0.7), vec3(0.2), mod(floor(pos.x-float(i)*sc) + floor(pos.y+float(i)*sc), 2.));\n        }\n        col /= 8.;\n        float h = CLOUD_HEIGHT;\n        #ifndef USE_3D\n        h-=8.;\n        #endif\n        vec3 c_pos = pos + vec3(LIGHT_DIR.xy, h);\n        col *= (LIGHT_COL * 1.-vec3(clamp(get_cloud_density(-c_pos, CLOUD_OCT), 0., 1.)))+AMBIENT;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3yRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[538, 693, 747, 797, 917], [919, 919, 969, 1019, 1245], [2414, 2426, 2470, 2470, 2892], [2894, 2894, 2933, 2933, 3306], [3309, 3309, 3334, 3334, 3538], [3539, 3539, 3578, 3578, 4097], [4098, 4098, 4136, 4136, 4613], [4615, 4615, 4672, 4672, 5893]]}
{"id": "tsccRX", "name": "Foggy Woods", "author": "matttsilva", "description": "Spooky times", "tags": ["fog", "rain", "halloween"], "likes": 4, "viewed": 178, "published": "Public", "date": "1601392046", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat time = iTime;\n    \n    vec4 col = vec4(0.335, 0.432, 0.401, 1.0);\n\tvec4 woods = texture(iChannel0,uv);\n    woods = texture(iChannel0, vec2(uv.x,fract(uv.y+(time/5.0))));\n    \n    vec2 q = vec2(0.);\n    q.x = fbm( uv + 0.00*time);\n    q.y = fbm( uv + vec2(1.0));\n\n    vec2 r = vec2(0.);\n    r.x = fbm( uv + 0.8*q + vec2(1.7,9.2)+ 0.15*time );\n    r.y = fbm( uv + 0.8*q + vec2(8.3,2.8)+ 0.126*time);\n\n    float f = fbm(uv+r);\n    woods.a *= length(r) * q.x * 2.0;\n    woods.rgb *= r.y * q.y * 1.3;\n    \n    // rain\n\tfloat d = 1.;\n\tfor (int i = 0; i < 13; i++)\n\t{\n\t\tfloat f = pow(d, .45)+.25;\n\t\tvec2 st =  f * (uv * vec2(1.5, .05)+vec2(-time*.1+uv.y*.5, time*.12));\n\t\tf = (texture(iChannel1, st * .5, -99.0).x + texture(iChannel1, st*.284, -99.0).y);\n\t\tf = clamp(pow(abs(f)*.5, 29.0) * 140.0, 0.00, uv.y*.4+.05);\n\t\tvec3 b = vec3(.25);\n\t\n\t\twoods.rgb += b*f;\n\t\td += 3.5;\n\t}\n    \n    // lightning\n    float lightning = sin(time*sin(time*10.));\t\t\t\t// lighting flicker\n    lightning *= pow(max(0., sin(time+sin(time))), 2.);\t\t// lightning flash\n    woods.rgb *= 0.6 + 0.004*lightning*mix(0.5, .1, time*time);\t// composite lightning\n    woods.rgb *= 1.-dot(uv-=.5, uv); \n\n    // Output to screen\n    fragColor = col * (1.0 - woods.a) + woods * woods.a;\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsccRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 136], [138, 216, 243, 243, 625], [650, 650, 676, 676, 1014], [1016, 1016, 1073, 1123, 2416]]}
{"id": "tsccW7", "name": "Ctan(x)tan(y)=1", "author": "Nischi", "description": "ODE", "tags": ["ode"], "likes": 2, "viewed": 39, "published": "Public", "date": "1601021980", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Constants to vary\n    float C = 2.1+2.*cos(iTime*2.);\n    float scale = 10.;\n    float lineThickness = 0.2;\n    \n    //Coordinate transformation from pixels\n    vec2 uv = scale*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    //Implicit function\n    float f = tan(uv.x)*tan(uv.y)*C-1.;\n    \n    //Function plot\n    fragColor = vec4(abs(f)>=lineThickness);\n    \n    //Coordinate system\n    if(abs(uv.x)<0.05) fragColor = vec4(0);\n    if(abs(uv.y)<0.05) fragColor = vec4(0);\n    if(length(uv-vec2(1,0))<0.2) fragColor = vec4(0);\n    if(length(uv-vec2(0,1))<0.2) fragColor = vec4(0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsccW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 81, 651]]}
{"id": "tsccWn", "name": " Cavern and water", "author": "iuryBorgesRodrigues", "description": " Cavern and water\n", "tags": ["water", "tunel", "cavern"], "likes": 11, "viewed": 104, "published": "Public", "date": "1600726261", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tAbstract Island Cavern\n\t----------------------\n\n\tI made an \"Abstract Tunnel\" example a while back. The main motivation was to provide a very\n\tbasic tunnel template for anyone interested. I used the term \"abstract\" to describe the naive \n\trendering style - used to simulate the oldschool flat shaded polygon examples - that is  \n\tmildly reminiscent of abstract art.\n\n\tAnyway, this is a slightly more sophisticated version, but is built on the same premise. Like \n\tthe previous version, it's a tunnel system surfaced with a very basic triangle noise layer. \n\tRather than a single tunnel, this uses a more complex tunnel system created with some \n\tsinusoidal-based gyroid code, but it's simple enough. Other than that, there's some simple \n\twater, which is just a glorified, perturbed floor with some fake reflection and refraction.\n\n\tFor anyone interested in creating a simple tunnel system with minimal effort, the gyroid \n\ttunnel setup is worth looking at. As for cheap, jagged, noise-like surfacing, Nimitz's \n\ttriangle noise is impossible to improve on... but I'm still trying anyway. :)\n\n\tThe word \"abstract\" is a bit of a cop out in this case. I didn't have the cycles to perform \n\tall the required physics, like multiple reflection\\refraction passes, etc, so decided to fake \n\tit then call it \"abstract.\" It's kind of like using the terms \"alien\" and \"alternate reality\"\n\twhen the physics doesn't make any sense. So, with that in mind, this is an abstract rendering\n\tof a sea cavern setting on an alien planet in an alternate reality. :)\n\n\tAll things considered, the rendering speed is pretty reasonable, but I'd like to refine it \n\tsome more to accommodate slower machines than the one I'm currently on.\n\n\tBased on:\n\tAbstract Corridor - Shane\n\thttps://www.shadertoy.com/view/MlXSWX\n\t\n\t// Abstract rendering with triangle noise.\n\tSomewhere in 1993 - nimitz\n\thttps://www.shadertoy.com/view/Md2XDD\n\n\tMuch fancier example:\n\n\t// One of my favorites. In an idea world with fast computers, this is how I'd do it. :)\n\tLa calanque - XT95\n\thttps://www.shadertoy.com/view/Mst3Wr\n\n\n\n*/\n\n#define FAR 50. // Far plane, or maximum distance.\n\nfloat objID = 0.; // Object ID - Cavern: 0.; Water: 1..\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) - a);\treturn mat2(v, -v.y, v.x); }\n\n \n\nfloat drawObject(in vec3 p){\n    \n    // Anything that wraps the domain will work. The following looks pretty intereting.\n    //p = cos(p*3.14159 + iTime)*0.5; \n    //p = abs(cos(p*3.14159)*0.5);\n    \n    // Try this one for a regular, beveled Voronoi looking pattern. It's faster to\n    // hone in on too, which is a bonus.\n    p = fract(p)-.5;  \n    return dot(p, p);\n    \n    //p = abs(fract(p)-.5);\n    //p = abs(p - (p.x+p.y+p.z)/3.);\n    //return dot(p, vec3(.5));\n    \n    //p = abs(fract(p)-.5);\n    //return max(max(p.x, p.y), p.z);\n\n    \n}\n\n\n// The 3D tiling process. I've explained it in the link below, if you're interested in the process.\n//\n// Cellular Tiled Tunnel\n// https://www.shadertoy.com/view/MscSDB\nfloat cellTile(in vec3 p){\n    \n    \n    // Draw four overlapping objects at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw);//, v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    //d.x =  min(v.z, v.w) - min(v.x, v.y); // Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n    d.x =  min(v.x, v.y); // First order.\n        \n    return d.x*2.66; // Normalize... roughly.\n    \n}\n\n/*\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n*/\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\n// https://www.shadertoy.com/view/4ts3z2\nvec3 tri(in vec3 x){ return abs(fract(x)-.5); } // Triangle function.\n// PF - phase variance. Varies between zero and 1. Zero is redundant, as it returns the triangle function.\nvec3 trap(in vec3 x, float pf){ return (tri(x - pf*.125) + tri(x + pf*.125))*.5; } // Trapezoid function.\n\n// The function used to perturb the walls of the cavern: There are infinite possibities, but this one is \n// just a cheap...ish routine - based on the triangle function - to give a subtle jaggedness. Not very fancy, \n// but it does a surprizingly good job at laying the foundations for a sharpish rock face. Obviously, more \n// layers would be more convincing. However, this is a GPU-draining distance function, so the finer details \n// are bump mapped.\nfloat surfFunc(in vec3 p){\n\n    \n\t//return dot(tri(p*.5 + tri(p*.25).yzx), vec3(0.666));\n    \n    p /= iTime;//6.283;\n    //return dot(tri(p + tri(p.zxy)), vec3(0.666));\n    \n    // Trapezoidal function - created from two out of phase triangle functions. The second factor acts\n    // like a smoothing factor of sorts. One gives a longer topped trapezoid, and lesser values \n    // produce shorter tops -- effectively make it more pointy. A redundant value of zero produces\n    // a triangle function.\n    return dot(trap(p + trap(p.zxx, 12.0), 6.0), vec3(1.666));\n    \n    //return dot(tri(p*.5 + tri(p.yzx*0.25)), vec3(4.5/9.)) + dot(tri(p.yzx + tri(p*.5)), vec3(1.5/9.));\n \n    //p *= 6.283;\n    //return dot(sin(p*.5 + sin(p.yzx*0.25))*.66 + sin(p.yzx + sin(p*.5))*.34, vec3(.166)) + .5;\n \n\n}\n\n// Perturbing the sea floor. Just a very basic sinusoidal combination.\nfloat surfFunc2(in vec3 p){\n    \n\treturn dot(sin(p + sin(p.yzx*2. + iTime*2.)), vec3(.1666)) + .5; \n\n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );  \n\tp = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPath(float t){\n  \n    //return vec3(0, 0, t); // Straight path.\n    //return vec3(-sin(t/2.), sin(t/2.)*.5 + 1.57, t); // Windy path.\n    \n    //float s = sin(t/24.)*cos(t/12.);\n    //return vec3(s*12., 0., t);\n    \n    float a = sin(t * 0.11);\n    float b = cos(t * 0.14);\n    return vec3(a*4. -b*1.5, b*1.2 + a*1., t);\n    \n}\n\n\n// The cavern scene. The tunnel system is created with a sinusoidal lattice structure,\n// and a triangle function variation provides the jagged surfacing. The sea is nothing\n// more than a plane perturbed with a sinusoidal function. Everything is wrapped around\n// a winding path.\n// \n// By the way, I could use all sorts of trickery to slim this down and speed things up\n// but it's more readable this way.\n//\nfloat map(vec3 p){\n       \n\t\n    float sea = p.y + 3.5; // Sea level. Just a plane.\n    float sf = surfFunc(p); // Tunnel surface function.\n    // Sinusoial tunnel system. It doesn't need to be produced here, but it looks more\n    // random if it is.\n    float cav = abs(dot(cos(p*3.14159/6.), sin(p.yzx*3.14159/6.)) + 1.5);\n    \n    p.xy -= camPath(p.z).xy; // Offsetting the main tunnel by the camera path.\n  \n    float tun = 2. - length(p.xy); // Main tunnel.\n    \n    // Smoothly combining the main tunnel with the sinusoidal tunnel system.\n    tun = smax(tun, 1.-cav, 1.) + .35 + (.5-sf);\n    \n    // Perturbing the sea floor to create a watery effect... Lame watery effect. :)\n    sf = surfFunc2(p);\n    sea += (.5-sf)*.5;\n    \n    objID = step(sea, tun); // Determining the sea or cavern object ID.\n    \n    return min(sea, tun); // Combining the sea with the cavern (tunnel system).\n \n}\n\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n)\n{\n\tfloat sca = 1.5, occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n// The normal function with some edge detection rolled into it. Sometimes, it's possible to get away\n// with six taps, but we need a bit of epsilon value variance here, so there's an extra six.\nvec3 nr(vec3 p, inout float edge) { \n\t\n    vec2 e = vec2(.01, 0); // Larger epsilon for greater sample spread, thus thicker edges.\n\n    // Take some distance function measurements from either side of the hit point on all three axes.\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\t// The hit point itself - Doubled to cut down on calculations. See below.\n     \n    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface \n    // curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n    \n    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you \n    // do that is up to you. This is what I came up with for now, but I might tweak it later.\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\t\n    // Redoing the calculations for the normal with a more precise epsilon value.\n    e = vec2(.0025, 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx); \n    \n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.0, h;\n    for(int i = 0; i < 128; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.002*(t*.25 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h*.85;\n        \n    }\n\n    return min(t, FAR);\n}\n\n\n\n// Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 20; \n\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n\n        dist += clamp(abs(h), 0.01, 0.25);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (h<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.2, 1.0); \n}\n\n// Surface bump function. Cheap, but with decent visual impact. Used for the water surface.\nfloat bumpSurf3D( in vec3 p){\n    \n    return cellTile(p*.5)*.7 + cellTile(p)*.3;\n\n}\n\n// Standard function-based bump mapping function.\nvec3 dbF(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tpl(tx, p - e.xyy, n), tpl(tx, p - e.yxy, n), tpl(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tpl(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iTime*.25;\n    rd *= 3.;\n    \n    //vec3 tx = tpl(iChannel1, rd/3., sn).zyx;\n    //tx = smoothstep(0.2, 1., tx*2.); \n    //float c = dot(tx, vec3(.299, .587, .114));\n    \n    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.\n    c = smoothstep(0.4, 1., c); // Darken and add contast for more of a spotlight look.\n    \n    vec3 col = vec3(c, c*c, c*c*c*c).zyx; // Simple, warm coloring.\n    //vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)); // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*.25+.25); \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    float speed = 6.;\n    vec3 o = camPath(iTime*speed); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime*speed + .1);  // \"Look At\" position.\n    vec3 l = camPath(iTime*speed + 4.); // Light position, somewhere near the moving camera.\n\t\n    // Light postion offset. Since the lattice structure is rotated about the XY plane, the light\n    // has to be rotated to match. See the \"map\" equation.\n    vec3 loffs =  vec3(0, .25, 0);\n    vec2 a = sin(vec2(1.57, 0) - l.z*1.57/10.);\n    //loffs.xy = mat2(a, -a.y, a.x)*loffs.xy; \n    l += loffs;\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; ///3. FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n    //vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    //r = normalize(vec3(r.xy, (r.z - length(r.xy)*.25)));\n    \n    // Swiveling the camera from left to right when turning corners.\n    r.xy = rot2(-camPath(lk.z).x/16. )*r.xy;\n\n\n    // Raymarch.\n    float t = trace(o, r);\n    \n    // Save the object ID directly after the raymarching equation, since other equations that\n    // use the \"map\" function will distort the results. I leaned that the hard way. :)\n    float sObjID = objID;\n\n    // Initialize the scene color to the background.\n    vec3 col = vec3(0);\n    \n    // If the surface is hit, light it up.\n    if(t<FAR){\n    \n        // Position and normal.\n        vec3 p = o + r*t;\n        \n        float ed; // Edge variable.\n        vec3 n = nr(p, ed);\n        \n        vec3 svn = n;\n        \n        // Texture bump the normal.\n\n        // Bump mapping.\n        float sz = .5;\n        if(sObjID>.5) { // Sea.\n            sz = .25;\n            n = dbF(p, n, .25); // Function bump.\n            n = db(iChannel1, p*sz, n, .005/(1. + t/FAR)); // Texture bump.\n        } \n        else { // Cavern. \n            n = db(iChannel0, p*sz, n, .02/(1. + t/FAR)); // Texture bump only.\n        }\n\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n        \n        float at = 1./(1. + d*.25 + d*d*.05); // Light attenuation.\n        \n        // Ambient occlusion and shadowing.\n        float ao =  cao(p, n);\n        float sh = sha(p, l, 0.04, d, 16.);\n        \n        // Diffuse, specular, fresnel. Only the latter is being used here.\n        float di = max(dot(l, n), 0.);\n        float sp = pow(max( dot( reflect(r, n), l ), 0.0 ), 16.); // Specular term.\n        float fr = pow(clamp(1.0 + dot(r, n), 0.0, 1.0), 2.); // Fresnel reflection term.\n        \n        // Texturing the surface with some tri-planar mapping.\n        vec3 tx;\n        if(sObjID<.5) {\n            tx = tpl(iChannel0, p*sz, n)*1.35; // Rock texturing.\n            tx *= mix(vec3(1), vec3(1.35, 1, .65), abs(n)); // Fake angular coloring.\n        }\n        else {\n            tx = tpl(iChannel1, p*sz, n)*vec3(2, 2.4, 2.8); // Sea water texturing.\n        }\n\n        \n\n        // Extra shading. Not really necessary, but I like it for extra depth.\n        float sf;\n        \n        if(sObjID<.5){ // Rock surface shading.\n        \tsf = surfFunc(p); \n        }\n        else { // Sea surface shading.\n            vec3 txp = p;\n        \ttxp.xy -= camPath(txp.z).xy;\n            sf = surfFunc2(txp)*.8 + .2;\n            sf *= bumpSurf3D(p)*.8 + .2;\n        }\n        \n        tx *= sf; // Applying the surface shading to the texture value.\n        \n\n\t\t// Very simple scene coloring. Diffuse, ambience and specular.\n        col = tx*(di + vec3(.75, .75, 1)) + vec3(.5, .7, 1)*sp;\n        col += (tx*1. + .25)*vec3(.5, .7, 1)*fr; // A touch of Fresnel.\n        \n        // Edges.\n        col *= 1. - ed*.75; // Darker edges.\n\n        // Fake environment mapping.\n        vec3 ref, refr;\n        vec3 em; \n        \n        if(sObjID>.5){ // Water.\n            // Fake reflection and refraction to give a bit of a watery look, albeit\n            // in a nonbelievable abstract fashion.\n            //col *= .5;\n            ref = reflect(r, svn*.5 + n*.5);\n            em = eMap(ref, n);\n            ref = tpl(iChannel0, ref, n)*em*4.;\n            refr = refract(r, svn*.5 + n*.5, 1./1.33);\n        \tem = eMap(refr, n); \n        \trefr = tpl(iChannel0, refr, n)*em*2.;\n            //col += (refr + ref)*4.;\n            col += mix(refr, ref, fr*fr)*8.;\n        }\n        else {\n            ref = reflect(r, svn*.75 + n*.25);\n            em = eMap(ref, n);\n            col += col*em*4.; // Cavern walls.\n        }\n        \n        // Apply some shading.\n        col *= ao*sh*at;\n\n        \n    }\n    \n    // If we've hit the far plane, calulate \"l\" only.\n    if(t>=FAR) l = normalize(l - o - r*FAR);\n \t\n    // Produce some colored fog.\n    vec3 bg = mix(vec3(.5, .7, 1), vec3(1, .5, .6), l.y*.5 + .5);\n    col = mix(clamp(col, 0., 1.), bg.yzx, smoothstep(0., FAR-2., t));\n     \n    \n    // Rough gamma correction, and we're done.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n    \n    \n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsccWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2195, 2347, 2368, 2368, 2434], [2439, 2439, 2467, 2763, 2988], [2991, 3160, 3186, 3275, 3929], [4121, 4344, 4382, 4382, 4463], [4465, 4704, 4724, 4724, 4751], [4752, 4881, 4912, 4912, 4963], [4988, 5442, 5468, 5530, 6238], [6240, 6311, 6338, 6338, 6413], [6416, 6570, 6616, 6616, 6776], [6779, 6851, 6873, 7069, 7186], [7189, 7600, 7618, 7618, 8494], [8499, 8651, 8684, 8684, 8926], [8929, 9123, 9158, 9158, 10748], [10750, 10771, 10807, 10807, 11238], [11242, 11254, 11330, 11330, 11915], [11917, 12009, 12038, 12038, 12093], [12095, 12145, 12196, 12196, 12578], [12581, 12663, 12718, 12718, 13217], [13219, 13362, 13380, 13380, 13726], [13728, 14105, 14133, 14133, 14892], [14895, 14895, 14951, 14985, 20279]]}
{"id": "tscyDH", "name": "1dnoise for m", "author": "manthrax", "description": "test for mario", "tags": ["noise"], "likes": 2, "viewed": 58, "published": "Public", "date": "1600831092", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat scl = 100.;\n\nfloat noise1(in float v){\n\treturn fract(sin(v*scl)*scl);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(noise1((iTime*.1)+uv.x));  //yx+vec3(0,2,4)\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscyDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 45, 45, 78], [80, 80, 137, 187, 382]]}
{"id": "tscyRS", "name": "Inverse sphere plane projection", "author": "dub", "description": "playing with the equations in\nhttps://en.wikipedia.org/wiki/Stereographic_projection", "tags": ["projection", "checker"], "likes": 6, "viewed": 80, "published": "Public", "date": "1601131301", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// playing with the equations in\n// https://en.wikipedia.org/wiki/Stereographic_projection\n\n#define G 3.\n#define R iResolution\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord*2./R.y - vec2(R.x/R.y, 1.);\n    float d = dot(uv,uv);\n    vec3 s = floor(vec3(2.*uv, d-1.)*G/(1.+d)+iTime);\n    float v= fract((s.x+s.y)*.5)*2.;\n    fragColor = vec4(vec3(v),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscyRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 127, 184, 184, 390]]}
{"id": "tscyRX", "name": "Short hyperspace jump (loop)", "author": "sparkam", "description": "Short hyperspace jump forth and back.\nMy first shader experiment", "tags": ["starwars"], "likes": 4, "viewed": 99, "published": "Public", "date": "1601376814", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 uv, vec2 p, float r, float blur, float intens) {\n    float d = length(uv - p);\n    float c = smoothstep(r, r - blur, d);\n    return c * intens;\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat line(vec2 uv, vec2 p1,vec2 p2, float r, float blur, float intens) {\nvec2 g = p2 - p1;\n    vec2 h = uv - p1;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn smoothstep(r, r - blur, d) * intens;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float numStars = 1000.0;\n    float sig = 1.0; //reverse\n    float sig2 = 1.0; //reverse\n    float t_max = 1.5;\n    sig = sign(sin(2.0*3.14159265*iTime/(2.0*t_max)));\n    sig2 = sign(sin(2.0*3.14159265*iTime/(4.0*t_max)));\n    \n    float time = mod(iTime * sig, t_max);\n    time = time / t_max;\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float tz = mod(iTime, 2.0 * t_max * sig2)/(4.0*t_max);\n\n    uv *= (1.0 - 0.08*smoothstep(0.0, 0.2, tz*tz)); //zoom in\n    \n    float c = 0.0; // defines image\n    float s = 10.0; // scale value\n    \n    float dotSize = 0.002525;\n    float blurPart = 0.8;\n    float blurSize = dotSize * blurPart; //0.002\n    float starIntens = 0.5;\n    \n    float gloSize = 50.0 * dotSize;\n    float gloBlurSize = 0.99 * gloSize;\n    \n    vec2 co = vec2(0.0, 0.0);\n    vec2 co1 = vec2(0.0, 0.0);\n    vec2 coo = vec2(0.0, 0.0);\n   \n    float l;\n    float rcx;\n    float rcy;\n    \n    float starsize;\n    \n    for (float k = 0.0; k < numStars; k++) {\n        rcx = 2.0*(1.77 * rand(vec2(0.0, 10.0 + k * 10.0)) - 0.88);\n        rcy = 2.0*       (rand(vec2(1.0, 1.0 + k * 10.0)) - 0.5);\n        \n        starIntens = 0.7 * rand(vec2(2.0, 1.0 + k * 10.0));\n        starsize = dotSize * (1.0 - 0.5 * rand(vec2(3.0, 1.0 + k * 10.0)));\n            \n        coo = vec2(rcx, rcy);\n        \n        float m = sig2*s * mix(pow(0.6*time,5.0), pow(1.08*time,25.0), pow(time,1.0));\n        co1 = coo * (1.0 + max(m, -0.5));\n                \n        l = line(uv, coo, co1, starsize, blurSize, starIntens);\n        \n        c = max(c, l);\n       \n    }\n    \n    fragColor = 1.5*vec4(1.1*c, 1.1*c, 1.5*c, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscyRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 66, 66, 163], [165, 165, 186, 186, 258], [260, 260, 333, 333, 489], [491, 491, 546, 546, 2235]]}
{"id": "tscyzl", "name": "Checkerboard Wave ", "author": "theinventor13", "description": "new thing", "tags": ["thing"], "likes": 3, "viewed": 44, "published": "Public", "date": "1601493768", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    //circle section\n    float row = fragCoord.y - (iResolution.y / 2.0f) ;\n    float column = fragCoord.x - (iResolution.x / 2.0f) + 8.0f * cos(iTime * 4.0f * (fragCoord.x / iResolution.x));\n    \n    float dist = sqrt((row * row) + (column * column)); \n    float maxdist = sqrt((iResolution.y * iResolution.y * 0.25f) + (iResolution.x * iResolution.x  * 0.25f));\n    \n    float otpt = (sin(((dist / maxdist) * 20.0f) + iTime * 6.0f) + 1.0f) / 2.0f;\n\tvec3 col = vec3(otpt, otpt, otpt);\n    //circle section\n    \n    //checker section\n    int r = int(((fragCoord.y + 1000.0f) / 10.0f) + 10.0f * sin(iTime * 3.0f + (fragCoord.y / iResolution.y) * 10.f));\n    int c = int(((fragCoord.x + 1000.0f) / 10.0f) + 8.0f * cos(iTime * 4.0f + (fragCoord.x / iResolution.x) * 10.f));\n    \n    if(r % 2 == c % 2){\n\t\tcol.rgb *= 1.0f;\n    }else{\n        col.rgb *= 0.0f;\n    }\n    //checker section\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscyzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 81, 1006]]}
{"id": "tsdcD8", "name": "Quantimnyz Burp", "author": "celifrog", "description": "Original code forked from here:\nhttps://www.shadertoy.com/view/MdXSzS\nThis was fun :D ", "tags": ["space", "weird", "tiny", "super", "awesome"], "likes": 3, "viewed": 188, "published": "Public API", "date": "1600886333", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - .5;\n\tfloat t = iTime * .3 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\tfloat si = sin(t-t);\n\tfloat co = cos(t-si+si);\n\tmat2 ma = mat2(co, si, -si, co);\n\n\tfloat v1, v2, v3;\n\tv1 = v2 = v3 = 0.0;\n\t\n\tfloat s = 0.0;\n\tfor (int i = -11; i+i <160; i++)\n\t{\n\t\tvec3 p = s * vec3(uv+uv-s*uv+uv*uv*uv, 0.0);\n\t\tp.xy *= ma;\n\t\tp += vec3(.1, .3, s - 1.5 - sin(iTime *p* -0.03) * -.991);\n\t\tfor (int i = 0; i < 8; i++)\tp = abs(p*s) / dot(p,p) - 0.9259;\n\t\tv1 += dot(p,p) * .0005 * (1.8 + sin(length(uv.xy*uv.xy * 13.0) + .5  - iTime * .2));\n\t\tv2 += dot(-p*s,p*s*-p+-p+s) * .013 * (1.5 + sin(length(uv.xy*uv.xy*uv.xy * 14.5) + 1.2*v1 - iTime *v2*v1*v1*v1*v1+ .3));\n\t\tv3 += length(p.xy*p.xy*10.) * .0003;\n\t\ts  += .035;\n\t}\n\t\n\tfloat len = length(uv);\n\tv1 *= smoothstep(.7, .0, len*len);\n\tv2 *= smoothstep(.5, .10, len);\n\tv3 *= smoothstep(.9, .0, len);\n\t\n\tvec3 col = vec3( v3 * (1.5 + sin(iTime*v3 * 1.2) * .4),\n\t\t\t\t\t(v1 + v3-v3-v3-v3-v3 ) * .3,\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.5, .6, v3*v1*v2*len+v1*iTime) * .3;\n\n\tfragColor=vec4(min(pow(abs(-col), vec3(1.2)), 1.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdcD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1197]]}
{"id": "tsdcRM", "name": "hqx upscaling filter", "author": "public_int_i", "description": "Improved version of https://www.shadertoy.com/view/3styRH, designed to more properly match https://en.wikipedia.org/wiki/Hqx", "tags": ["filter", "scale", "scaling", "upscale", "up", "hqx"], "likes": 13, "viewed": 675, "published": "Public API", "date": "1600700337", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*Copyright 2020 Ethan Alexander Shulman\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*/\n\n//upscaling multiplier amount\n#define UPSCALE 10.\n\n//image mipmap level, for base upscaling\n#define ML 0\n\n//equality threshold of 2 colors before forming lines\n#define THRESHOLD .1\n\n//line thickness\nfloat LINE_THICKNESS;\n\n//anti aliasing scaling, smaller value make lines more blurry\n#define AA_SCALE (UPSCALE*1.)\n\n\n//draw diagonal line connecting 2 pixels if within threshold\nbool diag(inout vec4 sum, vec2 uv, vec2 p1, vec2 p2) {\n    vec4 v1 = texelFetch(iChannel0,ivec2(uv+vec2(p1.x,p1.y)),ML),\n        v2 = texelFetch(iChannel0,ivec2(uv+vec2(p2.x,p2.y)),ML);\n    if (length(v1-v2) < THRESHOLD) {\n    \tvec2 dir = p2-p1,\n            lp = uv-(floor(uv+p1)+.5);\n    \tdir = normalize(vec2(dir.y,-dir.x));\n        float l = clamp((LINE_THICKNESS-dot(lp,dir))*AA_SCALE,0.,1.);\n        sum = mix(sum,v1,l);\n    \treturn true;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sliderX = iMouse.x<5.?\n        \t(fract(iTime*.2)-max(0.,fract(iTime*.2)*2.-1.))*2.*iResolution.x:\n    \t\tiMouse.x;\n    vec2 ip = fragCoord/UPSCALE;\n    \n    if (fragCoord.x < sliderX) {\n        //regular nearest sampling\n    \tfragColor = texelFetch(iChannel0,ivec2(ip.x,ip.y),ML);\n        \n    } else {\n        \n        //start with nearest pixel as 'background'\n        vec4 s = texelFetch(iChannel0,ivec2(ip),ML);\n        \n        //draw anti aliased diagonal lines of surrounding pixels as 'foreground'\n        LINE_THICKNESS = .4;\n        if (diag(s,ip,vec2(-1,0),vec2(0,1))) {\n            LINE_THICKNESS = 0.3;\n            diag(s,ip,vec2(-1,0),vec2(1,1));\n            diag(s,ip,vec2(-1,-1),vec2(0,1));\n        }\n        LINE_THICKNESS = 0.4;\n        if (diag(s,ip,vec2(0,1),vec2(1,0))) {\n            LINE_THICKNESS = 0.3;\n            diag(s,ip,vec2(0,1),vec2(1,-1));\n            diag(s,ip,vec2(-1,1),vec2(1,0));\n        }\n        LINE_THICKNESS = 0.4;\n        if (diag(s,ip,vec2(1,0),vec2(0,-1))) {\n            LINE_THICKNESS = 0.3;\n            diag(s,ip,vec2(1,0),vec2(-1,-1));\n            diag(s,ip,vec2(1,1),vec2(0,-1));\n        }\n        LINE_THICKNESS = 0.4;\n        if (diag(s,ip,vec2(0,-1),vec2(-1,0))) {\n           LINE_THICKNESS = 0.3;\n         \tdiag(s,ip,vec2(0,-1),vec2(-1,1));\n            diag(s,ip,vec2(1,-1),vec2(-1,0));\n        }\n\n        fragColor = s;\n    }\n    \n    //draw slider bar\n    if (abs(fragCoord.x-sliderX) < 1.) fragColor = vec4(1,0,1,1);\n    \n}", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdcRM.jpg", "access": "shaders20k", "license": "mit", "functions": [[1381, 1442, 1496, 1496, 1911], [1913, 1913, 1970, 1970, 3459]]}
{"id": "tsdyDM", "name": "Mega High Buildings by Steven", "author": "jorge2017a1", "description": "Mega High Buildings by Steven", "tags": ["megahighbuildingsbysteven"], "likes": 2, "viewed": 69, "published": "Public", "date": "1601063492", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Mega High Buildings by Steven\n\n\n vec2 mouse;\n//Simple raymarching sandbox with camera\n\n//Raymarching Distance Fields\n//About http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\n//Also known as Sphere Tracing\n//Original seen here: http://twitter.com/#!/paulofalcao/statuses/134807547860353024\n\n//Declare functions\nvec2 ObjUnion(in vec2 d1,in vec2 d2);\nvec2 floorPlane(in vec3 p);\nvec3 color_checkers(in vec3 p);\nvec2 roundBox(in vec3 p);\nvec2 sdBox( vec3 p, vec3 b );\nvec3 color_white(in vec3 p);\nvec2 distanceField(in vec3 p);\nvec2 simpleBuilding (vec3 p, vec3 b );\nvec4 applyFog (in vec4 currColor, in vec3 ray);\nfloat maxcomp(in vec3 p );\nvec2 infiniteBuildings(in vec3 p);\nfloat sdCross( in vec3 p );\nvec2 sidewalk(vec3 p);\nvec2 tallBuilding (vec3 p, vec3 b );\nvec2 infiniteTallBuildings(in vec3 p);\nvec3 color_brick(in vec3 p);\n\n\n\n#define EPS 0.01\n#define INF 100000.0\n\n#define PHONG_SHADING 0\n#define RAYMARCH_SHADING 1\n#define TEST_SHADING 2\n\n#define SPINNING_CAMERA 0\n#define MOUSE_CAMERA 1\n#define PAN_CAMERA 2\n#define STILL_CAMERA 3\n#define AUTOPAN_CAMERA 4\n\n// mode selection\nconst int SHADING_MODE = TEST_SHADING; \nconst int CAMERA_MODE = MOUSE_CAMERA; \nvec3 E;\n\n// some simple colors\nconst vec3 COLOR_GREY = vec3(0.2,0.2,0.2);\nconst vec3 COLOR_WHITE = vec3(1.0,1.0,1.0);\nconst vec3 COLOR_BLACK = vec3(0);\nconst vec3 COLOR_WINDOW = vec3(0,0.4,0.55);\n\n//============================== UTILS ====================================//\nvec2 distanceField(in vec3 p){\n\treturn ObjUnion(floorPlane(p),ObjUnion(infiniteTallBuildings(p), infiniteBuildings(p))); // infinite boxes\n\t\n\t//vec2 test = ObjUnion(infiniteBuildingsShort(p),infiniteBuildingsTall(p)); //multiple mod patterns\n\t//return ObjUnion(floorPlane(p),test);\n}\n\nvec2 ObjUnion(in vec2 d1,in vec2 d2){\n\tif (d1.x<d2.x)\n\treturn d1;\n\telse\n\treturn d2;\n}\n\n// http://www.ozone3d.net/blogs/lab/20110427/glsl-random-generator/\nfloat rand(vec2 n)\n{\n\treturn 0.5 + 0.5 *\n\tfract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// from IQ\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\n\n\n// =============================== OBJECTS =======================================//\n// CREDIT: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm //\n\n//floorPlane (color is determined by y-component, ie 0.0)\nvec2 floorPlane(in vec3 p){\n\treturn vec2(p.y+2.0,0);\n}\n\n// ROUNDBOX (try other objects )\n//(color is determined by y-component, ie 1.0)\nvec2 roundBox(in vec3 p){\n\treturn vec2(length(max(abs(p)-vec3(1,1,1),0.0))-0.25,1);\n}\n\n// SIGNED BOX\nvec2 sdBox( vec3 p, vec3 b ){\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return vec2(min(mc,length(max(di,0.0))), 1);\n}\n\n\n// INFINITE SIMPLE BUILDINGS RANDOm (CREDIT: H3R3)\nvec2 infiniteBuildings(in vec3 p){\n\t\n\tvec3 c = vec3(5); // how close cubes are to each other\n\t\n\tvec3 q = p;\n\t//repetition in x and z direction\n\tq.x = mod(p.x,c.x)-0.5*c.x;\n\tq.z = mod(p.z,c.z)-0.5*c.z;\n\t\n\tvec2 pos = vec2(ceil(p.x/c.x), ceil(p.z/c.z));\n\t\n\tfloat height = rand(pos)*52.0;//* 10.0 - 4.0;\n\tfloat width1 = rand(pos + 100.0) + 0.5;\n\tfloat width2 = rand(pos + 15200.0) + 0.5;\n\t\n\t//building height\n\t//vec3 k = vec3(1,height,1);\n\tvec3 k = vec3(max(0.0, width1), max(0.0, height), max(0.0, width2));\n\treturn simpleBuilding(q,k);\n}\n\n\n// SIMPLE BUILDING (white)\nvec2 simpleBuilding (vec3 p, vec3 b ){\n\tfloat body = sdBox(p,b).x;\n\t\n\tvec3 q = p;\n\tvec3 c = vec3(0.5); //0.5\n\n\tq = mod(p,c)-0.5*c;\n\t\n\tfloat cr = sdCross(q*3.0)/3.0;\n\tbody = max( body, -cr );\n\t\n\t// top \"cap\" of building\n\tfloat top = sdBox(p-vec3(0,b.y,0),vec3(b.x, b.y/25.0, b.z)).x;\n\t\n\t// some buildings have an additional top that's slightly smaller\n\tif(fract(b.y/2.0) < 0.5){\n\t\tfloat c = fract(b.y)<0.2? 10.0:fract(b.y)*30.0; //if top portion is small enough, make it longer\n\t\tfloat toptop = sdBox(p-vec3(0,b.y+b.y/25.0,0),vec3(b.x*fract(b.y), b.y/c, b.z*fract(b.y))).x;\n\t\tbody = min(body,toptop);\n\t}\n\t\n\t// make a box inside to look like windows\n\tfloat inside = sdBox(p,vec3(b.x*0.9, b.y, b.z*0.9)).x;\n\tbody = min(inside,min(body,top));\n\t\t\n\tfloat outputColor = b.y;\n\tif(body==inside)\n\t\toutputColor = 99.0; // if inside is hit, shade with window color (99.0 is just placeholder value)\n\t\t\n\t\n  return vec2(body,outputColor);\n}\n\n\n\n// INFINITE TALL BUILDINGS RANDOM\nvec2 infiniteTallBuildings(in vec3 p){\n\t\n\tvec3 c = vec3(23,0,23); // how close cubes are to each other\n\t\n\tvec3 q = p;\n\t//repetition in x and z direction\n\tq.x = mod(p.x,c.x)-0.5*c.x;\n\tq.z = mod(p.z,c.z)-0.5*c.z;\n\t\n\tvec2 pos = vec2(ceil(p.x/c.x), ceil(p.z/c.z));\n\t\n\tfloat height = rand(pos)*20.0;\n\tif (fract(height)/23.0 < 0.4) //adding some variation in height\n\t\theight = height/2.0;\n\t\t\n\tfloat width1 = rand(pos + 830.0) + 0.5;\n\tfloat width2 = rand(pos + 3333.0) + 0.5;\n\t\n\t//building height\n\n\tvec3 k = vec3(max(3.0, width1), max(22.0, height), max(2.0, width2));\n\treturn tallBuilding(q,k);\n}\n\n\n\n//TALL BUILDING (WHITE)\nvec2 tallBuilding (vec3 p, vec3 b ){\n\tfloat body = sdBox(p,b).x;\n\t\n\tvec3 q = p;\n\tvec3 c = vec3(0.5);\n\tq = mod(p,c)-0.5*c;\n\tfloat vert_bars = sdBox(q,vec3(0.1,INF,0.1)).x;\n\tbody = max(body, -vert_bars);\n\t\n\t//dividng ledge\n\tconst float ledgeheight = 0.2;\n\tfloat ledge = sdBox(p-vec3(0,b.y,0),vec3(b.x,ledgeheight,b.z)).x;\n\tbody = min(body,ledge);\n\t\n\t//2nd portion\n\tfloat body2 = sdBox(p-vec3(0,b.y+ledgeheight,0),b*vec3(0.8,0.2,0.8)).x;\n\tbody = min(body,body2);\n\t\n\t//3rd portion\n\tfloat body3 = sdBox(p-vec3(0,b.y+ledgeheight+b.y*2.2, 0), b*vec3(0.6,0.2,0.6)).x;\n\tbody = min(body3, body);\n\t\t\t    \n\t\n\treturn vec2(body,1);\n}\n\n// SD_CROSS (modified from IQ's original)\nfloat sdCross( in vec3 p ){\n\tconst float w = 0.4;\n  float da = sdBox(p.xyz,vec3(INF,w,w)).x;\n  float db = sdBox(p.yzx,vec3(w,INF,w)).x;\n  float dc = sdBox(p.zxy,vec3(w,w,INF)).x;\n  return min(da,db);\n}\n\n\n\n// ============COLORS============= //\n// Streets & Sidewalks Color\nvec3 color_streets(in vec3 p){\n\tvec2 street = fract(p.xz * 0.2 + 0.15);\n\tif ((street.x>.3) && (street.y > 0.3))\n\t\treturn vec3(.5,.8,.5);\n\telse\n\t\treturn COLOR_BLACK;\n}\n\n//Brick Color\nvec3 color_brick(in vec3 p){\t\n\tconst vec3 brickColor = vec3(0.2,0.2,0.2);\n\tconst vec3 mortarColor = vec3(0.8);\n\tconst vec2 brickSize = vec2(0.3,0.15);\n\tconst vec2 brickPct = vec2(0.9,0.85);\n\t\n\tvec2 position = (p.zy)/brickSize;\n\tvec2 useBrick = vec2(0);\n\t\n\tif(fract(position.y*0.5) > 0.5)\n\t\tposition.x += 0.5;\n\t\t\n\tposition = fract(position);\n\tuseBrick = step(position, brickPct);\n\t\n\tvec3 color =  mix(mortarColor, brickColor, useBrick.x*useBrick.y);\n\t\n\t\n\tposition = p.xy/brickSize;\n\tif(fract(position.y*0.5) > 0.5)\n\t\tposition.x += 0.5;\n\tposition = fract(position);\n\tuseBrick = step(position, brickPct);\n\tcolor = (color+mix(mortarColor, brickColor, useBrick.x*useBrick.y))/2.0;\n\t\n\treturn color;\n\t\n}\n\n// ==================== RAY MARCH =============================//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    mouse.x=0.2+0.08*cos(iTime*0.255);\n    mouse.y=0.8+0.7*sin(iTime);\n    \n\t//Camera animation\n\tvec3 U=vec3(0,1,0);//Camera Up Vector\n\tvec3 viewDest=vec3(0,0,0); //Change camere view vector here\n\t//vec3 E; //moved to global space\n\tif (CAMERA_MODE == SPINNING_CAMERA)\n\tE=vec3(-sin(iTime/10.0)*10.0,5,cos(iTime/10.0)*10.0); //spinning scene\n\telse if(CAMERA_MODE == MOUSE_CAMERA){\n\t\tfloat spin = mouse.x * 8.0; //time * 0.1 + mouse.x * 8.0;\n\t\tE=vec3(-sin(spin)*10.0, 10.0 * mouse.y, cos(spin)*10.0);//Change camera path position here\n\t}\n\telse if(CAMERA_MODE == PAN_CAMERA){\n\t\tE=vec3(-sin(1.0)*10.0,7,cos(1.0)*10.0);\n\t\tvec3 moveCamDir = normalize(vec3(E.x,0.0,E.y));\n\t\tfloat mouse_val = mouse.y-0.5;\n\t\tE+=moveCamDir*iTime*(mouse_val>0.0?mouse_val:0.0);\n\t}\n\telse if(CAMERA_MODE == STILL_CAMERA){\n\t\tE=vec3(-sin(1.0)*10.0,7,cos(1.0)*10.0);//Change camera path position here\n\t}\n\telse if (CAMERA_MODE == AUTOPAN_CAMERA){\n\t\tE=vec3(-sin(1.0)*10.0,7,cos(1.0)*10.0);\n\t\tvec3 moveCamDir = normalize(vec3(E.x,0.0,E.y));\n\t\tE+=moveCamDir*iTime;\n\t}\n\t\n\t\n\t//Camera setup\n\tvec3 C=normalize(viewDest-E);\n\tvec3 A=cross(C, U);\n\tvec3 B=cross(A, C);\n\tvec3 M=(E+C);\n\n\tvec2 vPos=2.0*gl_FragCoord.xy/iResolution.xy - 1.0; // = (2*Sx-1) where Sx = x in screen space (between 0 and 1)\n\tvec3 P=M + vPos.x*A*iResolution.x/iResolution.y + vPos.y*B; //normalize resolution in either x or y direction (ie resolution.x/resolution.y)\n\tvec3 rayDir=normalize(P-E); //normalized direction vector from Eye to point on screen\n\t\n\t//Colors\n\tconst vec4 skyColor = vec4(0.7, 0.8, 1.0, 1.0);\n\tconst vec4 sunColor = vec4 (1.0, 0.9, 0.7, 1.0);\n\t\n\t//Raymarching\n\tconst vec3 e=vec3(0.01,0,0);\n\tconst float MAX_DEPTH=170.0; //Max depth use 500\n\tconst int MAX_STEPS = 100; // max number of steps use 150\n\tconst float MIN_DIST = 0.01;\n\n\tvec2 dist=vec2(0.0,0.0);\n\tfloat totalDist=0.0;\n\tvec3 c,p,n; //c=color (used in PHONG and RAYMARCH modes), p=ray position, n=normal at any point on the surface\n\n\tint steps = 0;\n\tfor(int i=0;i<MAX_STEPS;i++){\n\t\tsteps++;\n\t\ttotalDist+=dist.x*0.7; //use smoothing constant\n\t\tp=E+rayDir*totalDist; // p = eye + total_t*rayDir\n\t\tdist=distanceField(p);\n\t\tif (abs(dist.x)<MIN_DIST) break; // break when p gets sufficiently close to object or exceeds max dist\n\t}\n\n\tvec4 finalColor = skyColor;\n\t\n\tif (totalDist<MAX_DEPTH){\n\t\t// check which color to use via the y-component\n\t\tif (dist.y==0.0) // floorPlane color\n\t\tc=color_streets(p);\n\t\telse if(dist.y==1.0) // building color\n\t\tc=COLOR_WHITE;\n\t\t\n\t\tif(SHADING_MODE==PHONG_SHADING){\n\t\t\t// compute normal at this point on the surface using a gradient vector\n\t\t\tn=normalize(\n\t\t\tvec3(\n\t\t\tdist.x-distanceField(p-e.xyy).x,\n\t\t\tdist.x-distanceField(p-e.yxy).x,\n\t\t\tdist.x-distanceField(p-e.yyx).x));\n\t\t\t\n\t\t\t//e.xyy is equal to (0.001,0.0,0.0) \n\t\t\t//e.yxy is equal to (0.0,0.001,0.0)\n\t\t\t//e.xxy is equal to (0.0,0.0,0.001)\n\n\t\t\t//simple phong LightPosition=CameraPosition\t   \n\t\t\tfloat b=dot(n,normalize(E-p));\n\t\t\tfinalColor=vec4((b*c+pow(b,8.0))*(1.0-totalDist*.01),1.0);\n\t\t}\n\t\telse if (SHADING_MODE==RAYMARCH_SHADING){\n\t\t\t//Shading based on raymarched distance\n\t\t\tfloat v = 1.0-float(steps)/float(MAX_STEPS);\n\t\t\tfloat R=v*c.r, G=v*c.g, B=v*c.b;\n\t\t\tfinalColor=vec4(R,G,B,1.0);\n\t\t}\n\t\telse if (SHADING_MODE==TEST_SHADING){\n\t\t\tvec3 sunDir = vec3(normalize(viewDest-E)); //sun comes from the camera\n\t\t\t\n\t\t\tvec3 N = normalize(vec3(\n\t\t\tdistanceField(p).x-distanceField(p-e.xyy).x,\n\t\t\tdistanceField(p).x-distanceField(p-e.yxy).x,\n\t\t\tdistanceField(p).x-distanceField(p-e.yyx).x)); //normal at point\n\t\t\t\n\t\t\tvec3 L = sunDir;\n\t\t\tvec3 V = normalize(E-p);\n\t\t\t\n\t\t\t// color info is stored in y component\n\t\t\t\n\t\t\tif(fract(dist.y) < 0.5) // building color (half of the buildings are brick)\n\t\t\t\tfinalColor=vec4(color_brick(p),1.0);\n\t\t\tif(fract(dist.y) >= 0.5)\n\t\t\t\tfinalColor = vec4(COLOR_GREY,1.0);\n\t\t\tif (dist.y==0.0) // floorPlane color\n\t\t\t\tfinalColor=vec4(c,1.0);\n\t\t\tif (dist.y == 99.0)\n\t\t\t\tfinalColor = vec4(COLOR_WINDOW,1);\n\t\t\n\t\t\t\n\t\t\t//calculate lighting: diffuse + sunlight\n\t\t\tfloat diffuseTerm = clamp(dot(V,N), 0.0, 1.0);\n\t\t\tfinalColor = mix(finalColor, sunColor, diffuseTerm*0.55);\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t//apply fog\n\tvec3 r = p-E;\n\tfinalColor = applyFog(finalColor, r);\n\tfragColor = finalColor;\n}\n\n\n// Fog (credit: http://www.mazapan.se/news/2010/07/15/gpu-ray-marching-with-distance-fields/)\nvec4 applyFog (in vec4 currColor, in vec3 ray){\n\tfloat rayLength = length(ray);\n\tvec3 nRay = ray/rayLength;\n\t\n\tfloat fogAmount = 1.0-exp(-rayLength * 0.02); //0.008\n\tfloat sunAmount = 0.0;//pow( max( dot (nRay, sunDir), 0.0), 8.0);\n\t\n\tvec4 fogColor = mix(vec4(0.5,0.6,0.7,1.0), vec4(1.0,0.9,0.7,1.0), sunAmount);\n\treturn mix(currColor, fogColor, fogAmount);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdyDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1384, 1462, 1492, 1492, 1745], [1747, 1747, 1784, 1784, 1832], [1834, 1902, 1922, 1922, 2003], [2005, 2016, 2043, 2043, 2074], [2249, 2307, 2334, 2334, 2361], [2363, 2443, 2468, 2468, 2528], [2530, 2544, 2573, 2573, 2673], [2676, 2727, 2761, 2761, 3262], [3265, 3292, 3330, 3330, 4217], [4221, 4255, 4293, 4293, 4845], [4849, 4873, 4909, 4909, 5492], [5494, 5536, 5563, 5563, 5737], [5741, 5808, 5838, 5838, 5974], [5976, 5990, 6018, 6018, 6686], [6688, 6754, 6811, 6811, 11004], [11007, 11101, 11148, 11148, 11460]]}
{"id": "tsdyR2", "name": "Thing_15", "author": "balkhan", "description": "comments can be found mostly on map() function", "tags": ["3d", "raymarching", "body"], "likes": 28, "viewed": 356, "published": "Public API", "date": "1601322748", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec3 h;\nfloat ie;\n\n// rotation function\nvoid rot(inout vec2 p, float a) {p = vec2(cos(a)*p.x+sin(a)*p.y, -sin(a)*p.x+cos(a)*p.y);}\n\n// capsule distance\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdc( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// skeleton parts\nvec3 _head   = vec3(.0, 1.75, -1.),\n     _torso  = vec3(.0,1.0,-1.5),\n     _laharm = vec3(+.850,1.0,-1.5),\n     _raharm = vec3(-.850,1.0,-1.5),\n     _lharm  = vec3(+1.08750,.375,-2.),\n     _rharm  = vec3(-1.08750,.375,-2.),\n     _lfharm = vec3(+1.0,+.10, -1.1),\n     _rfharm = vec3(-1.0,+.10,-1.1),\n     _pelvis = vec3(+0.0,-.0,-2.5),\n     _laleg  = vec3(+0.25,-0.15,-2.5),\n     _raleg  = vec3(-0.25,-0.15,-2.5),\n     _lleg   = vec3(+.250,-1.0,-2.5),\n     _rleg   = vec3(-.250,-1.0,-2.5),\n     _lfoot  = vec3(+.250,-2.0,-2.5),\n     _rfoot  = vec3(-.250,-2.0,-2.5);\n\n// displace parts and then draw capsules beetween them\nfloat\tbody(vec3 p)\n{\n\tfloat r = 1e5;\n    \n    r = length(p-_head)-.5;\n    r = min(r,\n              sdc(p, _head, _torso, .25)\n              );\n    vec3 a_laharm = _laharm+1.0*vec3(.0,.0, .25*cos(iTime*4.+1.57)*+.0);\n    vec3 a_lharm = _lharm+vec3(.0,.0+-.25+.25*cos(iTime*4.),.0+.25+.25*sin(iTime*4.) );\n    vec3 a_lfharm = _lfharm+vec3(.0,.0+.0+.125*cos(iTime*4.+1.57), +.25+.25*sin(iTime*4.)+.0)*1.0;\n    \n    vec3 a_raharm = _raharm+1.0*vec3(.0,.0, .25*cos(iTime*4.+1.57+1.57)*+.0);\n    vec3 a_rharm = _rharm+vec3(.0,.0+-.25+.25*cos(iTime*4.+1.57),.0+.25+.25*sin(iTime*4.+1.57) );\n    vec3 a_rlharm = _rfharm+vec3(.0,.0+.0+.125*cos(iTime*4.+1.57+1.57), +.25+.25*sin(iTime*4.+1.57)+.0)*1.0;\n\n    r = min(r,\n              sdc(p, _torso, a_laharm, .25)\n              );\n    r = min(r,\n              sdc(p, _torso, a_raharm, .25)\n              );\n    r = min(r,\n              sdc(p, a_lharm, a_laharm, .25)\n              );\n    r = min(r,\n              sdc(p, a_rharm, a_raharm, .25)\n              );\n    r = min(r,\n              sdc(p, a_lharm, a_lfharm, .25)\n              );\n    r = min(r,\n              sdc(p, a_rharm, a_rlharm, .25)\n              );\n    r = min(r,\n              sdc(p, _torso, _pelvis, .25)\n              );\n    vec3 a_rleg = _rleg+vec3(.0,.0, .75*cos(iTime*5.)+.5);\n    vec3 a_lleg = _lleg+vec3(.0,.0, .75*sin(iTime*5.)+.5);\n    vec3 a_lfoot = _lfoot+vec3(.0,.0, 1.*sin(iTime*5.+.0)-.5);\n    vec3 a_rfoot = _rfoot+vec3(.0,.0, 1.*cos(iTime*5.+.0)-.5);\n    r = min(r,\n              sdc(p, _raleg, a_rleg, .25)\n              );\n    r = min(r,\n              sdc(p, a_rleg, a_rfoot, .25)\n              );\n    r = min(r,\n              sdc(p, _laleg, a_lleg, .25)\n              );\n    r = min(r,\n              sdc(p, a_lleg, a_lfoot, .25)\n              );\n    \n    \n    return r;\n}\n\n\nfloat map(vec3 p)\n{\n\tfloat r, rr, rrr, bod; // r is return value, other floats are intermediary distances\n\n    vec3 pp = p; // old p\n    p.zyx = (fract(p.zyx*.025)-.5)*20.; // repeat space\n    vec3 idp = floor(((pp.zyx*.025)-.0)*1.)*200.; // get id of each cell\n\n    // use ids to rotate differently in each cell space\n    rot(p.yx,  ie*sin(idp.z+iTime*-.5)*.3333);\n    p += vec3(-3., 4., -2.0)*.3333; // add some vector, don't forget to not displace over cell boundary\n    rot(p.zx,  ie*sin(idp.y+iTime*.25)*1.25 +1.57);\n    p += -vec3(3., 2., -2.0)*.3333;\n    rot(p.yz,  ie*sin(idp.x-iTime*2./3.)*1.333 +1.57*2.);\n    p += vec3(3., 2., -2.0)*.3333;\n    pp.y=p.y; // store repeated space y value in ppp.y var\n    float idb = step(pp.y, .0); // if y > 0 then 1 else 0, I use this to color bottom/top sphere differently\n    p.y = abs(p.y)-2.1; // create symmetry on y axis of the repeated space\n    rr = length(vec3(p.x, pp.y, p.z))-5.5; // create a ball\n    \n    rr = max(rr\n             ,\n            pp.y+1.5 // cut the ball and keep the top part\n            );\n\n    rr = max(rr\n             ,\n            -(max(abs(p.x), max(abs(pp.y+2.2), abs(p.z+1.) ) )-2.25) // dig a cube into the ball\n            );\n    \n    rr = abs(rr)+.0751; // make the ball transparent\n    \n    bod = body(p); // create bodies\n    r = bod;\n    r = min(r, rr);\n\n\t// Create the bottom sphere part\n    rrr = max( -(pp.y) + sin(length(p.xz+vec2(.0,2.1))*5.+iTime*10.)*.25 // cut with waves centered on foot\n              ,\n              length(vec3(p.x, pp.y, p.z) )-5.3 // ball distance\n             );\n    rrr = abs(rrr)+.10751; // make it transparent\n    r = min(r, rrr);\n    \n    float ball = length(vec3(p.x, abs(pp.y)-2., p.z+.25))-.25; // this is the ball between hands\n    ball = abs(ball)+.01251; // make it transparent\n    r = min(r, ball);\n    \n    // here is coloring\n    // ids of repeated space are also used for coloring\n    \n    // wavy sphere color\n    h += (vec3(.09, .475, .607) )/max(.05, rrr*rrr*3. );\n    // cubicle sphere color\n    h += (1.-vec3(.3+-.205*(mod(idp.x-1.5, 3.)+0.0), .425+-.06125*(mod(idp.y-1.5, 3.)+0.0), .3+idb*.25+-.125*(mod(idp.z-1.5, 3.)+0.0)))/max(.05, rr*rr*3. + .61*.0);\n    // body color\n    h += (1.-vec3(.32681-idb*.25, .25+-.5*idb, .3))/max(.05, bod*bod*400. + .01);\n    // little hand spheres color\n    h += (vec3(.25, .25+.2*idb, .25))/max(.01, ball*ball*.051+.01);\n    return r;\n}\n\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    ie = clamp(log(iTime*.125+1.),.0,1.); // start at 0 and progress to 1, used to animate rotations\n\n    h = vec3(.0); // final color\n    vec2 R = iResolution.xy, uv = (f-R*.5)/R.y;\n\n    // classic ray stuff\n    vec3 ro = vec3( 20.*(1.0+sin(iTime*.5)), 20.*(1.+cos(iTime*.5)), -10.+iTime*30.0 );\n    vec3 rd = normalize(vec3(uv, 1.));\n    vec3 p;\n    vec2 d = vec2(1e2, .0);\n\n    for (float i = .0; i< 100.; i++)\n    {\n        p = ro + rd * d.y;\n        d.x = map(p);\n        d.y += d.x;\n\t    if ( d.x < .0001 )\n\t        break;\n    }\n    o.xyz = h*.0025;\n    o.w = 1.0;\n    o /= length(uv)+1.9; // Strong vignette counteract overall very bright scene\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdyR2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[135, 156, 189, 189, 246], [248, 339, 385, 385, 499], [1085, 1140, 1160, 1160, 2936], [2939, 2939, 2958, 2958, 5347], [5350, 5350, 5391, 5391, 6045]]}
{"id": "tsdyRf", "name": "Dungeon Crawl Hatching 1", "author": "ozeg", "description": "Inspired by old dnd maps\nPerlin approach", "tags": ["hatching"], "likes": 7, "viewed": 70, "published": "Public", "date": "1601454077", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PHI 1.618033988749895\n#define PHI_I 0.618033988749895\n#define PI 3.141592653589793\n#define TWO_PI 6.283185307179586\n#define CELL 8.\n\nfloat noise(vec2 x)\n{\n    return fract(cos(dot(x,vec2(1,1.618034)))*416418.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col = vec3(0);\n    float n00 = noise(vec2(0,0)-floor(fragCoord.xy/CELL));\n    float n01 = noise(vec2(0,1)-floor(fragCoord.xy/CELL));\n    float n10 = noise(vec2(1,0)-floor(fragCoord.xy/CELL));\n    float n11 = noise(vec2(1,1)-floor(fragCoord.xy/CELL));\n    vec2 uvG = fragCoord.xy/CELL;\n    uvG = fract(uvG);\n    uvG -= 1.;\n    float g00 = dot(uvG+vec2(0,0),vec2(sin(n00*TWO_PI),cos(n00*TWO_PI)));\n    float g01 = dot(uvG+vec2(0,1),vec2(sin(n01*TWO_PI),cos(n01*TWO_PI)));\n    float g10 = dot(uvG+vec2(1,0),vec2(sin(n10*TWO_PI),cos(n10*TWO_PI)));\n    float g11 = dot(uvG+vec2(1,1),vec2(sin(n11*TWO_PI),cos(n11*TWO_PI)));\n    float size = 2.+sin(iTime);\n    g00 = cos(size*g00*TWO_PI);\n    g01 = cos(size*g01*TWO_PI);\n    g10 = cos(size*g10*TWO_PI);\n    g11 = cos(size*g11*TWO_PI);\n    uvG += 1.;\n    uvG = smoothstep(0.25,.75,uvG);\n    float g0 = mix(g01,g00,uvG.y);\n    float g1 = mix(g11,g10,uvG.y);\n    float g = mix(g1,g0,uvG.x);\n    float so = .5+1./(8.+size);\n    col = vec3(smoothstep(-so+.25,so+.25,g));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdyRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 141, 162, 162, 221], [223, 223, 280, 280, 1362]]}
{"id": "tsdyRM", "name": "Raymarching_aesch_2", "author": "annaesch", "description": "Raymarching", "tags": ["raymarching"], "likes": 0, "viewed": 31, "published": "Public", "date": "1601235880", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Functions based on https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n// BOX\nfloat dBox(vec3 p, vec3 s) {\n\treturn length(max(abs(p)-s, 0.));\n}\n\n// TORUS\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\n// SPHERE\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n} \n\n// GET DISTANCE FROM VARIOUS GEOMETRY\nfloat GetDist(vec3 p) {\n\tvec4 s = vec4(0, 1, 6, 1);\n    \n    float sphereDist =  length(p-s.xyz)-s.w;\n    float planeDist = p.y;\n    \n    float td = sdTorus(p-vec3(0,sin(iTime/2.0)+1.0, 4.0), vec2(1.0, 0.2));\n    float bd = dBox(p-vec3(-3.0, 1.5, 6.0), vec3(0.5,.75, 0.75));\n    float sd = sdSphere(p-vec3(3.5, 1.2, 6.0), 1.0);\n    \n    float d = min(td, planeDist);\n    d = min(d, bd);\n    \n    d = min(d, sd);\n    \n    return d;\n}\n\n\nfloat RayMarch(vec3 rayPos, vec3 rayDir) {\n\tfloat distO=0.; \t\t\t\t\t\t// distance origin\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = rayPos + rayDir*distO; \t//marching step point p \n        float distS = GetDist(p); \t\t\t// distance to closest object\n        distO += distS; \t\t\t\t\t// move to next marching step\n        if(distO>MAX_DIST || distS<SURF_DIST) break;\n    }\n    \n    return distO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p); \t\t//get distance to surface\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3( \t\t\t// points around p\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 8, 4);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*3.; // moving lightPos\n    vec3 l = normalize(lightPos-p); \t// vec from p to light source\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.); \t\t// no negative results\n    float d = RayMarch(p+n*SURF_DIST*2., l); \t// distance to object\n    if(d<length(lightPos-p)) dif *= .1; \t\t//check if distance to object is closer than ditance to light \n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // shift origin to center\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 rayPos = vec3(0, 1, 0); // ray origin\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1)); // ray direction normalized\n\n    float d = RayMarch(rayPos, rayDir); // distance to objects\n    \n    vec3 p = rayPos + rayDir * d; // position for lighting\n    \n    float dif = GetLight(p); // diffuse light\n    col = vec3(dif);\n    \n   \tcol = pow(col, vec3(.7)); // gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdyRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 154, 182, 182, 219], [221, 230, 261, 261, 329], [331, 341, 376, 376, 400], [403, 441, 464, 464, 873], [876, 876, 918, 918, 1275], [1277, 1277, 1301, 1301, 1540], [1542, 1542, 1566, 1566, 2034], [2036, 2036, 2093, 2123, 2630]]}
{"id": "tsdyRS", "name": "17 - Sea of Distortion", "author": "Krabcode", "description": "Can't make a good looking 3D scene? Just do a glitchy plane instead! Learn this one simple sinewave trick! Raymarching programmers hate him!!!", "tags": ["raymarch", "sin", "glitch"], "likes": 4, "viewed": 89, "published": "Public", "date": "1601205540", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Made with love by Krabcode\n\n// Based on Ray Marching for Dummies!\"\n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/XlGBW3\n\n\nconst int MAX_STEPS = 200;\nconst float MAX_DIST = 500.;\nconst float SURF_DIST = 0.001;\nconst float NORMAL_DIST = 0.05;\nconst float SHININESS = 2.;\nconst float PI = 3.14159;\n\nfloat time; \nvec2 uv;\nvec2 lightOffset; \nvec3 lightPos;\n\nfloat rayLength;\nfloat closestDist;\nfloat hitDist;\nvec3 hit;\nvec3 intersect;\n\nmat2 rotate(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdSphere(vec3 p, float radius)\n{\n    return length(p)-radius;\n}\n\nfloat sdf(vec3 p){ \n    p.y = 1.-abs(p.y);\n    float wave = .15*sin(p.x*-0.05+p.z+p.z*13.15+p.y+time);    \n    return p.y+5.+wave;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) \n{\n    float dO=0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = sdf(p);\n        closestDist = min(dS, closestDist);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 normal(vec3 p) \n{\n    float d = sdf(p);\n    vec2 e = vec2(NORMAL_DIST, 0);\n    vec3 n = d - vec3(\n        sdf(p-e.xyy),\n        sdf(p-e.yxy),\n        sdf(p-e.yyx));\n    return normalize(n);\n}\n\nfloat diffuseLight(vec3 p, vec3 normal) \n{\n    vec3 l = normalize(lightPos-p);\n    float dif = clamp(dot(normal, l), 0., 1.);\n    float d = rayMarch(p+normal*SURF_DIST*2., l);\n    if(d<length(lightPos-p)){ dif *= .1; }\n    return dif;\n}\n\n\nfloat specularLight(vec3 p, vec3 rayDir, vec3 normal) {\n    vec3 lightDir = normalize(p-lightPos);\n    vec3 reflectionDirection = reflect(-lightDir, normal);\n    float specularAngle = max(dot(reflectionDirection, rayDir), 0.);\n    return pow(specularAngle, SHININESS);\n}\n\nfloat render(vec2 uv)\n{\n    vec3 rayOrigin = vec3(uv*0.1, 0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1.));\n    hitDist = rayMarch(rayOrigin, rayDir);\n    hit = rayOrigin + rayDir * hitDist;\n    vec3 normal = normal(hit);\n    float diff = diffuseLight(hit, normal);   \n    float spec = specularLight(hit, rayDir, normal);\n    return .5*diff + .5*spec;\n}\n\nvec3 gammaCorrection(vec3 rgb){\n    float gamma = 2.2;\n    rgb = smoothstep(0., 1., rgb);\n    return pow(max(rgb, 0.), vec3(1.0/gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = float(iFrame)*.0025;\n    lightPos = vec3(0,10,1000);\n    uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float lit = render(uv);\n    lit *= smoothstep(MAX_DIST, MAX_DIST*.1, hitDist);\n    fragColor = vec4(gammaCorrection(vec3(lit)),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdyRS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[31, 567, 588, 588, 661], [663, 663, 708, 708, 803], [805, 805, 843, 843, 874], [876, 876, 894, 894, 1008], [1010, 1010, 1045, 1045, 1287], [1289, 1289, 1311, 1311, 1485], [1487, 1487, 1529, 1529, 1723], [1726, 1726, 1781, 1781, 1996], [1998, 1998, 2021, 2021, 2356], [2358, 2358, 2389, 2389, 2496], [2498, 2498, 2555, 2555, 2812]]}
{"id": "tsdyWM", "name": "Joukowsky transform", "author": "FabriceNeyret2", "description": ".", "tags": ["complex", "transform", "joukowsky"], "likes": 8, "viewed": 241, "published": "Public API", "date": "1601060986", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y,\n      // M = ( 2.*iMouse.xy - R ) / R.y,\n         V = U* ( 1. + (vec2(1,-1)/dot(U,U) ) )         // Z = z + 1/z\n           + .1*iTime;\n    O = texture(iChannel0,.5+.5*V);                     // texture\n // O = mix(O, vec4(0,0,1,1), max(0.,1.-R.y/4.*abs(length(V-vec2(.5,.1))-1.5)) );\n    V = abs(fract(V)-.5) / fwidth(V);                   // grid\n    O = mix(O, vec4(1, 0,0,1), max(0.,1.-V.x) * min(1.,4.*length(U)) );\n    O = mix(O, vec4(0,.8,0,1), max(0.,1.-V.y) * min(1.,4.*length(U)) );\n}\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdyWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 594]]}
{"id": "tstcD7", "name": "Fractal Sky #2", "author": "NivBehar", "description": "fractals", "tags": ["mandelbrot", "fractals"], "likes": 2, "viewed": 73, "published": "Public", "date": "1601079691", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERATIONS 150\n#define COLOR_REPEAT 0.6\n#define MANDELBROT_SHADE 2072.\n#define time iTime\n#define HEX_DIST 1.\n#define HAIR_DIST 21.\n#define PI 3.141592654\n#define _DotsSize 0.213\n#define _DotsSmoothness 0.221\n\nvec2 rot(vec2 p, vec2 pivot, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    p -= pivot;\n    p = vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n    p += pivot;\n\n    return p;\n}\nfloat HexDist(vec2 p) {\n    p = abs(p);\n\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n\n    return c;\n}\nvec4 HexCoords(vec2 UV) \n{\n    vec2 r = vec2(1, 1.73);\n    vec2 h = r*.5;\n\n    vec2 a = mod(UV, r)-h;\n    vec2 b = mod(UV-h, r)-h;\n\n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n\n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = UV - gv;\n    return vec4(x, y, id.x,id.y);\n}\nfloat TriangleDist(vec2 p, vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(p.x*q.y-p.y*q.x),k*(p.y-q.y)  );\n    return sqrt(d)*sign(s);\n}\nvec3 iterate(vec2 UV , float distance_type)\n{\n    //cool shit: https://www.shadertoy.com/view/wdBfDK\n    //UV = _MandelbrotArea.xy + (UV-0.5)*_MandelbrotArea.zw;\n    //UV = rot(UV, _MandelbrotArea.xy, _MandelbrotAngle);\n\n    vec3 col;\n\n    float dots_dist = 1e20f;\n    vec2 z = UV;\n    // shape = z for regular mandelbrot set\n    // a; 0       ; (GOLDEN-2); 0.285; 0.285; 0.45  ; -0.70176; -0.835 ; -0.8 ; -0.7269; -0.754\n    // b; 1-GOLDEN; (GOLDEN-1); 0    ; 0.01 ; 0.1428; -0.3842 ; -0.2321; 0.156; 0.1889; -0.066\n    //float[1] shapes;\n    //float2 shapes[11] = {z, float2(0, 1-GOLDEN), float2(GOLDEN-2, GOLDEN-1), float2(0.285, 0.), float2(0.285, 0.01), float2(0.45, 0.1428), float2(-0.70176, -0.3842), float2(-0.835, -0.2321),\n        //float2(-0.8, 0.156), float2(-0.7269, 0.1889), float2(-0.754, -0.066)};\n    vec2 shape;\n    shape = vec2(0.285, 0.0103);\n    //shape = float2(_fractal_shape_a, _fractal_shape_b);\n    //if(shape.x == 0 && shape.y == 0)\n    //    shape = z;\n    vec2 prev_z;\n    vec2 z_dots;\n    vec4 z_hc;\n    float dist_from_mandelbrot = 1e20f;\n    float r = 20.;\n\n    vec2 hc2;\n    int i = 0;\n    for(i = 0; i<ITERATIONS; i++ )\n    {\n        prev_z = z;\n        if(distance_type == HEX_DIST)\n        {\n            vec2 z2 = rot(z, vec2(0.), time*0.4);\n            r = 1. + 10.*HexDist(0.5 + 2.*sin(cos(z2)*0.5)*cos(cos(z2*3.)));\n        }\n        if(distance_type == HAIR_DIST)\n        {   \n            //vec2 z1 = 13.*z/dot(z,z+0.1*sin(z));\n            //z1 +=time;\n            vec2 z2 = rot(z, vec2(0.), time*0.4);\n            r = 10. + 15.*TriangleDist(sin(cos(z2*PI + PI)*0.5 + 5.)*sin(cos(z2*PI)), vec2(100.,3.2));\n            //float r2 = 5 + 15*TriangleDist(sin(cos(z2*PI+time*1)*0.5 + 5)*cos(cos(z2*PI)), float2(50,-0.6));\n            //r = lerp(r,r2, 0.4 + 0.4*sin(time));\n            //r = 5+TriangleDist(z*3, float2(_test1,_test2));\n        }\n\n        //r = HexCoords(0.5 + 0.25*sin(cos(z*2 + time)*0.1)*cos(cos(z*3) + 0.25*sin(cos(prev_z*2)) )).y*10;\n        z = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + shape;\n        //float z_hash = N22(z);\n        if(length(z) > r)\n            //if(dot(z, prev_z) > r)\n            break;\n        //return 0.0;\n\n\n        z_dots = z + rot(z,prev_z,time*0.2);\n        z_dots = vec2(HexDist(z_dots));\n        z_hc = HexCoords(z_dots);\n\n        //z_dots = pMod2(z_dots,4);\n\n        dots_dist = min( dots_dist, dot(z_dots,z_dots) );\n        //dots_dist = min( dots_dist, dot(z_hc.x,z_hc.y) );\n        dist_from_mandelbrot = min(dist_from_mandelbrot, dot(z,z));\n\n        //hc2 = min(hc2, HexCoords(prev_z).xy);\n    }\n\n    if(i >= ITERATIONS)\n        return vec3(0.);\n\n    float fraciter = log2( log(length(z)) / log(r) );\n    float j = float(i);\n    //j -= fraciter;\n\n    //float2 hc = HexCoords(dots_dist).xy;\n\n    //col = smoothstep(0,dist, sin(hc.y*15)*cos(hc.y*15));\n    //float dots_size = 1;\n    //float dots_smoothness = 0.9;\n    float dots = smoothstep(_DotsSize - _DotsSmoothness, _DotsSize, dots_dist);\n    //dots = smoothstep(0.9, 1, dots_dist);\n    dots = clamp(0.,1.,dots);\n\n    //col = smoothstep(0,dist, );\n    //float3 tex = tex2D(_MainTex, hc2);\n    //col = tex;\n    //col = dots;\n\n    vec3 beat = vec3(time*0.4);//(_smooth_bass2 + _smooth_mid2 + _smooth_treb2)*0.001 + (_bass2 + _mid2 + _treb2)*0.003;\n    // Color 1\n    vec3 a1 = vec3(0.5, 0.5, 0.5);\n    vec3 b1 = vec3(0.75, 0.55, 0.85);\n    vec3 c1 = beat; // animate \\ offset\n    vec3 d1 = vec3(0.0, 0.1, 0.2);\n    // Color 2\n    vec3 a2 = vec3(0.5, 0.5, 0.5);\n    vec3 b2 = vec3(0.75, 0.55, 0.85);\n    vec3 c2 = vec3(1.0, 1.0, 0.5); // animate \\ offset\n    vec3 d2 = vec3(0.8, 0.9, 0.3);\n    // Color 3 - blue to gray\n    vec3 a3 = vec3(0.5, .5, 1.);\n    vec3 b3 = vec3(0.5, 0.5, 0.);\n    vec3 c3 = vec3(0., 0., 0.); // animate \\ offset\n    vec3 d3 = vec3(0., 0., 0.);\n    // Color 4 - black and white\n    vec3 a4 = vec3(1, 1, 1);\n    vec3 b4 = vec3(1.0, 1.0, 1.0);\n    vec3 c4 = vec3(1.0, 1.0, 1.0); // animate \\ offset\n    vec3 d4 = vec3(1.0, 1.0, 1.0);\n    \n    vec3 a5 = vec3(0.3, 0.27, 0.5);\n    vec3 b5 = vec3(0.9, 0.45, 0.75);\n    vec3 c5 = vec3(beat); // animate \\ offset\n    vec3 d5 = vec3(.8, 0.9, 0.25);\n    \n    // Color choise\n    //vec3 a = mix(a1, a2, 0.*time*0.02);\n    //vec3 b = mix(b1, b2, 0.*time*0.02);\n    //vec3 c = mix(c1, c2, 0.*time*0.02);\n    //vec3 d = mix(d1, d2, 0.*time*0.02);\n\n    vec3 col1 = a1 + b1 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d1 + c1));\n    vec3 col2 = a2 + b2 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d2 + time*0.2));\n    vec3 col3 = a3 + b3 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d3 + c3 ));\n    vec3 col4 = a4 + b4 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d4 + c4));\n    vec3 col5 = a5 + b5 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d5 + c5));\n\tvec3 col6 = mix(col1, col5, abs(col1-col5));\n    col = col1;\n    \n    \n    //col = mix(col1, col4, 0.5 + 0.5*sin(float(i)));\n    //col = vec3(clamp(0.,1.,fraciter));\n    //col = mix(col, col2, fraciter);\n    //col = col2;\n    //col = vec3(dist_from_mandelbrot);\n\n    dist_from_mandelbrot = smoothstep(0., j/(MANDELBROT_SHADE), dist_from_mandelbrot);\n    //dist_from_mandelbrot = smoothstep(0, (_MandelbrotArea.z)*0.1, dist_from_mandelbrot); // shade depends on the zoom \n\n    dist_from_mandelbrot = clamp(0.,1.,dist_from_mandelbrot);\n\n    if(distance_type == HEX_DIST)\n    {\n        float leaves = smoothstep(0.,0.7,fraciter);\n        float leaves_edges = smoothstep(0.3,0.,fraciter);\n        //float leaves_edges_tips = smoothstep(-0.02,0.03,fraciter);\n        //leaves_edges *= leaves_edges_tips;\n        col *= leaves;\n        //col += leaves_edges;\n        //col *= dist_from_mandelbrot;\n\n    }\n    if(distance_type == HAIR_DIST)\n    {\n        float hair = smoothstep(0.,1.5,fraciter);\n        float hair_edges = smoothstep(0.18,0.,fraciter);\n        float hair_edges_tips = smoothstep(-0.02,0.03,fraciter);\n        //hair_edges *= hair_edges_tips; // to avoid pxieli edges of the hairs\n        col *= hair;\n        //col += hair_edges;\n\n        // add dots\n        //col *= (dist_from_mandelbrot);\n\n        //float id = j;\n        //float hash = N11(id + floor(-time*2));\n        //col += 0.1*(1-dist_from_mandelbrot) * (col3);\n        //col = col3;\n    }\n\n\n\n    //col = hash+0.1;\n\n\n    //col *= hair_edges2*dist_from_mandelbrot;\n    //col = col4;\n    //col = fraciter;\n\n    //col *= dots;\n    //col += (1-dots)*dist_from_mandelbrot*col3;\n    //col *= smoothstep(0.8,0.,fraciter);\n    //col = dots;\n    //col = fraciter;\n    //col = 1-dots;\n\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv;// = fragCoord/iResolution.xy;\n    \n    float zoom = 3.;\n\n    //uv += 0.4;\n    //uv = 0.7*uv/dot(uv,uv);\n    //uv += vec2(cos(0.1*iTime), sin(0.1*iTime));\n\n    #if 1\n    int AA = 2;\n    vec3 col = vec3(0.);\n    // anti-aliasing from https://www.shadertoy.com/view/Mss3R8\n\tfor( int j=0; j<AA; j++ )\n\tfor( int i=0; i<AA; i++ )\n\t{\n\t\tvec2 of = -0.5 + vec2( float(i), float(j) )/float(AA);\n\n        uv = (fragCoord+of)/iResolution.xy;\n        uv*=zoom;\n        uv.x-= zoom/2.;\n        uv.y -= zoom/2.;\n\t   col += iterate( uv, HAIR_DIST );\n\t}\n\tcol /= float(AA*AA);\n    \n    #else\n    \n    uv = fragCoord/iResolution.xy;\n    uv*=zoom;\n    uv.x-= zoom/2.;\n    uv.y -= zoom/2.;\n\tvec3 col = iterate(uv, HAIR_DIST);\n    \n    #endif\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstcD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 218, 257, 257, 395], [396, 396, 419, 419, 521], [522, 522, 548, 548, 819], [820, 820, 857, 857, 1148], [1149, 1149, 1194, 1368, 7642], [7643, 7643, 7700, 7750, 8522]]}
{"id": "tstyRM", "name": "Raymarching_aesch_1", "author": "annaesch", "description": "Raymarching Test 1", "tags": ["raymarching"], "likes": 0, "viewed": 24, "published": "Public", "date": "1601236040", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat GetDist(vec3 p) {\n\tvec4 sphere = vec4(0, 1, 4, 1);\n    \n    float sphereDist =  length(p-sphere.xyz)-sphere.w;\n    float planeDist = p.y; //with plane at y=0 \n    \n    float d = min(sphereDist, planeDist); //take smallest distance \n    return d;\n}\n\nfloat RayMarch(vec3 rayPos, vec3 rayDir) {\n\tfloat distO=0.; // distance origin\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = rayPos + rayDir*distO; //marching step point p \n        float distS = GetDist(p); // distance to closest object\n        distO += distS; // move to next marching step\n        if(distO>MAX_DIST || distS<SURF_DIST) break;\n    }\n    \n    return distO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p); //get distance to surface\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3( \t// points around p\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 8, 4);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*3.; // moving lightPos\n    vec3 l = normalize(lightPos-p); // vec from p to light source\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.); // no negative results\n    float d = RayMarch(p+n*SURF_DIST*2., l); // distance to object\n    if(d<length(lightPos-p)) dif *= .1; //check if distance to object is closer than ditance to light \n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // shift origin to center\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 rayPos = vec3(0, 1, 0); // ray origin\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1)); // ray direction normalized\n\n    float d = RayMarch(rayPos, rayDir); // distance to objects\n    \n    vec3 p = rayPos + rayDir * d; // position for lighting\n    \n    float dif = GetLight(p); // diffuse light\n    col = vec3(dif);\n    \n   \tcol = pow(col, vec3(.7)); // gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstyRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 90, 90, 320], [322, 322, 364, 364, 706], [708, 708, 732, 732, 967], [969, 969, 993, 993, 1455], [1457, 1457, 1514, 1544, 2051]]}
{"id": "tt2BWD", "name": "Minimalism #09", "author": "Flopine", "description": "Ninth piece of a shader serie about minimalism, how to do small and quick artwork that are about composition and animation.", "tags": ["3d", "motion", "isometric", "minimalism", "daily"], "likes": 4, "viewed": 149, "published": "Public", "date": "1598996181", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define ITER 64.\n#define PI acos(-1.)\n#define TAU 6.283185\n\n#define box(p,c) (min(0.,max((abs(p)-c).x,max((abs(p)-c).y,(abs(p)-c).z)))+length(max(abs(p)-c,0.)))\n#define sphere(p,r) (length(p)-r)\n#define getnorm(p,eps) normalize(SDF(p).dist-vec3(SDF(p-eps.xyy).dist,SDF(p-eps.yxy).dist,SDF(p-eps.yyx).dist))\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define mo(p,d) p=abs(p)-d;if(p.y>p.x)p=p.yx\n\nstruct obj \n{\n    float dist;\n    int mat;\n};\n\nobj minobj (obj a, obj b) \n{\n    if (a.dist < b.dist) return a;\n    else return b;\n}\n\nfloat hash11 (float x)\t\n{return fract(sin(x)*153.53);}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p,p.yzx);\n    return min(p.x,min(p.y,p.z))-d;\n}\n\nobj SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n\n    float anim = (-1.+2.*hash11(iTime));\n\n    obj b1 = obj(box(p,vec3(1.2)),1); \n\n    mo(p.yz, vec2(0.6));\n    mo(p.xz,vec2(0.6));\n    p.xz += vec2(-0.2,0.2);\n    float crox = sc(p+anim*0.01,0.3);\n\n    b1.dist = max(-crox,b1.dist)-0.02;\n\n    p.y -= 2.;\n    p.xz += anim*0.02;\n    obj sp = obj(sphere(p,0.15),2);\n\n    return minobj(sp,b1);\n}\n\nfloat spec (vec3 rd, vec3 l, vec3 n, float specpow)\n{\n    vec3 h = normalize(l-rd);\n    return pow(max(dot(n,h),0.),specpow);\n}\n\nfloat fresnel (vec3 rd, vec3 n, float frepow)\n{return pow(clamp(1.-dot(-rd,n),0.,1.),frepow);}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(uv*3.5,-40.),\n        rd = vec3(0.,0.,1.),\n        persprd = normalize(vec3(uv,1.)),\n        p = ro,\n        l = vec3(-3.,5.,-8.),\n        col = (step(0.12,abs(uv.x)) <= 0.) ? vec3(0.8,0.4,0.9) : vec3(0.);\n\n    bool hit = false;\n    float shad = 0.;\n    obj scene;\n\n    for (float i=0.; i<ITER; i++)\n    {\n        scene = SDF(p);\n        if (scene.dist < 0.001)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        p += scene.dist*rd;\n    }\n\n    if (hit)\n    {\n        if (scene.mat == 1) \n        {\n            vec3 bn = getnorm(p,vec2(0.03,0.));\n            vec3 albedo = vec3(0.,0.,0.05);\n            col = albedo;\n            col += max(dot(bn,normalize(l)),0.)*0.05;\n            col += spec(rd,l,bn,6.)*vec3(0.4,0.5,0.95);\n        }\n\n        if (scene.mat == 2) \n        {\n            vec3 sn = getnorm(p,vec2(0.1,0.));\n            vec3 albedo = vec3(0.9,0.7,0.);\n            col = albedo;\n            col += spec(rd,l,sn,20.)*vec3(1.,0.9, 0.5);\n            col += max(dot(sn,normalize(l)),0.)*0.1;\n            col += fresnel(rd,sn,2.5)*vec3(1.,0.7, 0.);\n        }\n    }\n\n    fragColor = vec4(sqrt(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2BWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 769, 797, 797, 853], [855, 855, 880, 880, 909], [911, 911, 939, 939, 1015], [1017, 1017, 1035, 1035, 1438], [1440, 1440, 1493, 1493, 1567], [1569, 1569, 1616, 1616, 1663], [1665, 1665, 1721, 1721, 2965]]}
{"id": "tt2BWm", "name": "nube y fuego plasma", "author": "jorge2017a1", "description": "nube y fuego plasma", "tags": ["nubeyfuegoplasma"], "likes": 4, "viewed": 111, "published": "Public", "date": "1599141265", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///referencia de autores desconocidos\n//modificado por jorge2017a1--3-sep-2020\n\n\n\n//------------------------------\n\nfloat     alpha;\n vec2      speed;\n float     shift;\n\n\n//-------------------------------------------\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nfloat noise(vec3 p) //Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\n\n\nfloat flame(vec3 p)\n{\n\t\n    float d= sdSphere(  p*vec3(1.,.5,1.), 1.0 );\n\tfloat esf1= d + (noise(p+vec3(.0,iTime*2.,.0)) + noise(p*3.+vec3(.0,iTime*11.,.0))*.5)*.25*(p.y) ;\n    \n    return esf1;\n}\n\n\n\n\nfloat scene(vec3 p)\n{\n\n    float f1= min(100.-length(p) , abs(flame(p)) );\n    return f1;\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.0, glow = 0.0, eps = 0.02;\n\tvec3  p = org;\n\tbool glowed = false;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\td = scene(p) + eps;\n\t\tp += d * dir;\n\t\tif( d>eps )\n\t\t{\n\t\t\tif(flame(p) < .0)\n\t\t\t\tglowed=true;\n\t\t\tif(glowed)\n       \t\t\tglow = float(i)/64.;\n\t\t}\n\t}\n\treturn vec4(p,glow);\n}\n\nvec4 ImageFuego( in vec2 fragCoord , float dist)\n{\n\tvec2 v = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 org = vec3(0., -2., 4.);\n\tvec3 dir = normalize(vec3(v.x*1.6, -v.y, -1.5));\n\t\n\tvec4 p = raymarch(org, dir);\n\tfloat glow = p.w;\n\t\n\tvec4 col = mix(vec4(1.0,0.5,0.1,1.0), vec4(0.1,0.5,1.0,1.0), p.y*.03+.4);\n\t\n\tvec4 Color = mix(vec4(0.0), col, pow(glow*2.,3.));\n\t\n    dist=p.w;\n\treturn Color;\n}\n\n\n\nfloat rand(vec2 n) \n{\n\treturn fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) \n{\n\tconst vec2 d = vec2(0.0, 1.0);\n\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm(vec2 n) \n{\n\tfloat total = 0.0, amplitude = 1.0;\n\t\n\tfor (int i = 0; i < 4; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn += n;\n\t\tamplitude *= .5;\n\t}\n\t\n\treturn total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst vec3 c1 = vec3(126.0/255.0, 0.0/255.0, 97.0/255.0);\n\tconst vec3 c2 = vec3(173.0/255.0, 0.0/255.0, 161.4/255.0);\n\tconst vec3 c3 = vec3(0.2, 0.0, 0.0);\n\tconst vec3 c4 = vec3(164.0/255.0, 1.0/255.0, 214.4/255.0);\n\tconst vec3 c5 = vec3(0.1);\n\tconst vec3 c6 = vec3(0.9);\n\n\tvec2 p = fragCoord.xy * 8.0 / iResolution.xx;\n    \n    //------------\n    vec4 fuego;\n    float distfuego;\n    fuego=ImageFuego( fragCoord , distfuego);\n    //------------\n    \n\n\tfloat q = fbm(p - iTime * 0.1);\n\tvec2 r = vec2(fbm(p + q + iTime * speed.x - p.x - p.y), fbm(p + q - iTime * speed.y));\n\tvec3 c = mix(c1, c2, fbm(p + r)) + mix(c3, c4, r.x) - mix(c5, c6, r.y);\n\tfloat grad = fragCoord.y / iResolution.y;\n\tfragColor = vec4(c * cos(shift * fragCoord.y / iResolution.y), 1.0);\n\tfragColor.xyz *= 1.25-grad;\n    \n    //mezclar fuego y nube\n    vec4 Color = mix(fuego,fragColor, sin( 1.4*iTime));\n    \n    fragColor=Color;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2BWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 217, 252, 252, 276], [279, 279, 321, 321, 558], [562, 562, 583, 583, 758], [763, 763, 784, 784, 854], [856, 856, 891, 891, 1169], [1171, 1171, 1221, 1221, 1610], [1614, 1614, 1635, 1635, 1701], [1703, 1703, 1725, 1725, 1924], [1926, 1926, 1946, 1946, 2100], [2102, 2102, 2159, 2159, 3064]]}
{"id": "tt2fDD", "name": "Light Intensity 3D", "author": "stevejtrettel", "description": "The light intensity function for various 3-D homogeneous spaces.", "tags": ["volumetric"], "likes": 5, "viewed": 321, "published": "Public", "date": "1599007938", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//BUILT FROM THE VOLUMETRIC RAYMARCHER BY FLYGUY //https://www.shadertoy.com/view/XtsGRf\n\n#define RotateX(v,a) v.yz *= mat2(cos(a),sin(a),-sin(a),cos(a))\n#define RotateY(v,a) v.xz *= mat2(cos(a),sin(a),-sin(a),cos(a))\n#define RotateZ(v,a) v.xy *= mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define MIN_MARCH_DIST 0.001\n#define MAX_MARCH_STEPS 48\n#define MAX_VOLUME_STEPS 500\n#define VOLUME_STEP_SIZE 0.01\n\n\n\n\n\n\n\n\n//The following functions define the light intensity in three different homogeneous geometries.\n//use the one you would like to visualize in the main Intensity function, directly below their definitions\n//right now, they automatically cycle through.\n\n\nfloat intensityS2E(vec3 pos){\n    \n    \n    float L2=pos.x*pos.x+pos.y*pos.y;\n    float r2=L2+pos.z*pos.z;\n    float L=sqrt(L2);\n   \n    float intensity =abs(L/(r2*sin(L)));\n    \n    return intensity;\n}\n\nfloat intensityNil(vec3 pos){\n    \n    \n   \n    //Stuff Needed to compute the intensity\n    float z=pos.z;\n    float L2=pos.x*pos.x+pos.y*pos.y;\n    float r2=L2+z*z;\n    float z4=z*z*z*z;\n    \n    //the denominator of the intensity function factors into two commponents contributing to the brightness\n    float intensityLine=2.*r2*sin(z/2.);\n    float intensityCurve=(L2*z*cos(z/2.)-2.*r2*sin(z/2.));\n   \n    float intensity=abs(z4/(intensityLine*intensityCurve));\n    \n    return intensity;\n}\n\n\nfloat intensitySL2(vec3 pos){\n    \n    float z=pos.z;\n    float L2=pos.x*pos.x+pos.y*pos.y;\n    \n   //first; the components of the cylindrical coordinate polynomials\n    float L,L4, L6,z2,z4,z6;\n    L=sqrt(L2);\n    L4=L2*L2;\n    L6=L2*L4;\n    z2=z*z;\n    z4=z2*z2;\n    z6=z2*z4;\n    \n    //the hyperbola you lie on\n    float k=sqrt(abs(L2-z2));\n    \n    //the polynomials coefficients of the area density\n    float f1=(L2+z2)/pow(abs(L2-z2),6.);\n    float f2=17.*L6+7.*L4*z2+16.*L2*z4+32.*z6;\n    float f3=48.*L2*z2*(L2+z2);\n    float f4=3.*L4*(5.*L2+3.*z2);\n    float f5=L6-2.*L2*z2-z4-L4*(1.+z2);\n    float f6=(L6+2.*L2*z2+z4-L4*(z2-1.));\n    float f7=2.*L2*(L2+z2)*k;\n    \n    \n    //Trigonometric Components\n    float c1=cos(k);\n    float c2=cos(2.*k);\n    float s1=sin(k);\n    float s2=sin(k/2.);\n    s2*=s2;//now sin(k/2)^2;\n    \n    float C1=cosh(k);\n    float C2=cosh(2.*k);\n    float S1=sinh(k);\n    \n    float S2=sinh(k/2.);\n    S2*=S2;//now it's sinh(k/2)^2\n    \n    //the signs that change depending on formula type:\n    float sgn=1.;\n    float Sgn=-1.;\n    \n    //the area density function, depending on if you are in or out of the lightcone\n    float areaDensity;\n    \n    \n  if(abs(z)>abs(L)){\n            areaDensity=sqrt(abs(f1*s2*(f2 - f3*c1 + f4*c2)*(f5 + f6*c1 + sgn* f7*s1)))/2.;\n        }\n        else if(abs(z)<abs(L)){\n            areaDensity=sqrt(abs(f1*S2*(f2 - f3*C1 + f4*C2)*(f5 + f6*C1 + Sgn*f7*S1)))/2.;\n        }   \n   \n   \n    float intensity=1./areaDensity;\n    \n    return intensity;\n}\n\n\n\n\nfloat intensity(vec3 pos,float time){\n   // float t=floor(time/6.28);\n   // t=mod(t,3.);\n    \n    //switch(int(t)){\n    //case 0:return 1.5*intensityS2E(pos);\n        \n   // case 1:return 1.5*intensityNil(pos);\n        \n   // case 2:return 1.5*intensitySL2(pos);\n   // }\n    return 10.5*intensitySL2(pos);\n   // return 1.5*intensityNil(pos);\n   // return 1.5*intensityS2E(pos);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvec4 Volume(vec3 pos,float opacity)\n{\n    //rotate starting position\n    RotateY(pos,iTime/3.);\n    RotateZ(pos,-0.5);\n    \n    pos=15.*pos;//fixed zoom level\n    //pos=(15.-5.*cos(iTime/4.))*pos;//zoom in and out\n    \n    //calculate the light intensity;\n\n    float vol =2.*intensity(pos,iTime/5.);\n    \n    //mix two colors together: first is for lower intensity second is high intensity\n    vec3 col = mix(vec3(0.85,0.45,0.2),vec3(1.,1.,0.6),step(3.,vol));\n    \n    vol = smoothstep(0.6,0.9,abs(vol));\n    \n\treturn vec4(col, max(0.0,vol)*0.01*opacity);  \n}\n\nvec3 MarchVolume(vec3 orig, vec3 dir)\n{\n    //Ray march to find the region surface.\n    float t = 0.0;\n    vec3 pos = orig;\n    \n    float radius=3.;\n    float opacity=1.;//fixed size of bounding sphere\n    //float radius=1.5*(1.-cos(iTime/5.));//make the bounding sphere get larger with time\n    //float opacity=3.5/(0.5+radius);\n   \n    \n    for(int i = 0;i < MAX_MARCH_STEPS;i++)\n    {\n        pos = orig + dir * t;\n        float dist = 100.0;\n        \n        \n        dist = min(dist, 8.0-length(pos));\n        dist=min(dist,length(pos)-radius);\n       // dist = min(dist, max(max(abs(pos.x),abs(pos.y)),abs(pos.z))-1.0);//cube\n        \n        t += dist;\n        \n        if(dist < MIN_MARCH_DIST){\n           \torig=pos;//reset the origin to your new point\n           \tt=0.;//reset the marching counter\n            break;}//you made it to the region! Start volume march\n    }\n    \n    \n    //Step though the volume and add up the opacity.\n    vec4 col = vec4(0.0);\n    for(int i = 0;i < MAX_VOLUME_STEPS;i++)\n    {\n    \tt += VOLUME_STEP_SIZE;\n        \n    \tpos = orig + dir * t;\n        \n        //Stop if the sample leaves the volume.\n        //if(max(max(abs(pos.x),abs(pos.y)),abs(pos.z))-radius > 0.0) {break;}//cube\n        if(length(pos)>radius) {break;}//sphere\n\n        \n        //if you are rendering a shell: add up zero intensity when you are inside the shell\n       // if(length(pos)>radius-0.2)//uncomment to make the below only apply in the shell\n        {\n            vec4 vol = Volume(pos,opacity);\n        \tvol.rgb *= vol.w;\n            //distance foog\n            vol.rgb=exp(-t/3.)*vol.rgb;//weight by the distance fog travelled to get here.\n            col += vol;}\n    }\n  \n    \n    return col.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    vec3 dir = normalize(vec3(uv-res/2.0,1.0));\n    vec3 orig = vec3(0,0,-4.);\n      \n    RotateX(dir,radians(iMouse.y));\n    RotateX(orig,radians(iMouse.y));\n    RotateY(dir,radians(-iMouse.x));\n    RotateY(orig,radians(-iMouse.x));\n  \n    vec3 color = MarchVolume(orig,dir);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2fDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[406, 658, 687, 687, 860], [862, 862, 891, 949, 1355], [1358, 1358, 1387, 1387, 2877], [2882, 2882, 2919, 3152, 3261], [3276, 3276, 3313, 3344, 3835], [3837, 3837, 3876, 3920, 5564], [5566, 5566, 5623, 5623, 6031]]}
{"id": "tt2fzc", "name": "First Test Ray Marching ", "author": "Utopia42", "description": "JUST practice", "tags": ["test"], "likes": 2, "viewed": 57, "published": "Public", "date": "1599551961", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Raymarcher based on https://www.shadertoy.com/view/lsBBDt\n\n\n#define PI 3.141592653589493238462643\nvec3 cylinder2cartesian(float r, float phi, float z)\n{\n    return vec3(r * cos(phi), r * sin(phi), z);\n}\n\nfloat dist_estimator(in vec3 pos)\n{\n    float r = length(pos);\n    float phi = atan(pos.y, pos.x);\n    float r1 = sin(1.5 * phi) + 1.5;\n    float z1 = cos(1.5 * phi);\n    float r2 = sin(1.5 * phi + PI) + 1.5;\n    float z2 = cos(1.5 * phi + PI);\n    vec3 p1 = cylinder2cartesian(r1, phi, z1);\n    vec3 p2 = cylinder2cartesian(r2, phi, z2);\n    return (min(distance(pos, p1), distance(pos, p2)) - 0.2) / 4.0;\n}\n\nfloat intersects(in vec3 src, in vec3 drt)\n{\n    float t;\n    for (int i = 0; i < 255; ++i)\n    {\n        float delta = dist_estimator(src + t * drt);\n        t += delta;\n        if (delta < 1e-5)\n            return t;\n    }\n    return 1e+5;\n}\n\nvec4 trace(in vec3 src, in vec3 dst)\n{\n    vec3 drt = normalize(dst - src);\n    vec3 light = vec3(1.5, 0.3, 0.3);\n    float t = intersects(src, drt);\n    if (t <= 1e+4)\n    {\n        vec3 surface_pos = src+ drt * t;\n        float strenth = dot(-drt, normalize(light - surface_pos));\n        return vec4(1, 1, 1, 1) * strenth;\n    }\n    else\n        return vec4(0, 0, 0, 1);\n}\nvec3 camera(in vec3 src, in vec3 lookat, in vec3 up, in vec2 uv)\n{\n    vec3 lookat_ = normalize(lookat - src);\n    vec3 right_ = normalize(cross(lookat_, up));\n    vec3 up_ = normalize(cross(right_, lookat_));\n    return src + lookat_ + (right_ * uv.x + up_ * uv.y) * 0.4;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (vec2(fragCoord.x - iResolution.x / 2.0, fragCoord.y - iResolution.y / 2.0) / max(iResolution.x, iResolution.y)) * 2.0;\n    vec3 src = vec3(6.0 * cos(iTime / 2.0), 6.0 * sin(iTime / 2.0), 12.0);\n    vec3 dst = vec3(4.0, uv * 0.4);\n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = trace(src, camera(src, lookat, up, uv));\n    fragColor.rgb *= col;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2fzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 101, 155, 155, 205], [207, 207, 242, 242, 615], [617, 617, 661, 661, 860], [862, 862, 900, 900, 1237], [1238, 1238, 1304, 1304, 1512], [1514, 1514, 1572, 1622, 2149]]}
{"id": "tt2fzG", "name": "trippy stuff", "author": "Kat_Purpy", "description": "based on https://www.shadertoy.com/view/4sSXWR which is recursive maze\n\nwarning: this shader may look different from intended result since it depends on how does your GPU handle float rounding and overflows", "tags": ["trip"], "likes": 6, "viewed": 222, "published": "Public API", "date": "1599254579", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rnd( x)    fract(1000.*sin(345.2345*x))\n#define id( x,y)   floor(x)+100.*floor(y)\n\nfloat maze(vec2 u) {\n    float n = id(u.x,u.y);  u = fract(u);\n    return 1.-smoothstep(.61,.15,((rnd(n*.5)>.61)?u.x:u.y))/sin(n+iTime) * sin(iTime);\n}\n\nvoid mainImage( out vec4 o, vec2 u ){\n    float t = iTime;\n    u  /= iResolution.y;\n    u = (u + vec2(1.8*cos(.2*t)+.6*sin(.4*t), sin(.3*t)+.4*cos(.4*t)) ) * (1.2-cos(.5*t));\n    float a = 3.*(cos(.05*t)-.5*cos(1.-.1*t)), C=cos(a), S=sin(a),\n          v = 0., w=1., s=0.; u *= 2.*mat2(C,-S,S,C);\n\n #define L  v+= w*maze(u*=4.); s+= w;  w *= .3;\n    L L L L L\n    \n\to += 1.-v/s -o;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2fzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 111, 111, 242], [244, 244, 281, 281, 626]]}
{"id": "tt2fzV", "name": "ying & yang golden donutcat*fork", "author": "celifrog", "description": "credit to dean_the_coder not 100% but like 90%\n10% of the credit goes to me for the edits.", "tags": ["fork", "ying", "yang", "golden"], "likes": 1, "viewed": 163, "published": "Public API", "date": "1599418536", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(123.45, 875.43))) * 5432.3);\n}\n\nfloat noise(vec3 p) {\n\tconst vec3 s = vec3(7.0, 157.0, 113.0);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\t\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\t\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n    return (noise(p) + noise((p + 0.2) * 1.98) * 0.5 + noise((p + 0.66) * 4.12) * 0.25) / 1.75;\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, -c);\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q) - t.y;\n}\n\nfloat sdCapsule(vec3 p, float h, float r) {\n  p.z -= clamp(p.z, 0.0, h);\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb) {\n  p.x = abs(p.x);\n  float k = (sc.y * p.x > sc.x * p.y) ? dot(p.xy, sc) : length(p.xy);\n  return sqrt(dot(p, p) + ra * ra - 2.0 * ra * k) - rb;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec2 sdDonut(vec3 p) {\n\treturn vec2(sdTorus(p, vec2(4.0, 1.4)), 1.5);\n}\n\nfloat fbmc;\nvec2 sdCream(vec3 p) {\n    float d = abs(p.y + fbmc + 0.7) - 2.3;\n\treturn vec2(max(sdDonut(p).x, -d) - 0.13, 2.5);\n}\n\nvec2 sdSprinkles(vec3 p) {\n    float dd = sdCream(p - vec3(0.0, 0.05, 0.0)).x;\n    \n    vec3 id = floor(p / 0.3);\n    \n    mat2 r = rot(noise(id) * 3.141);\n    p.xz *= r;\n    p.xy *= r;\n    p.xz *= r;\n    \n    p = mod(p, 0.3) - 0.15;\n    \n    p.xz *= r;\n    p.xy *= r;\n    p.xz *= r;\n    float d = max(sdCapsule(p, 0.3, 0.02), dd);\n    \n    return vec2(d, mod(id.x, 6.0) + mod(id.y, 6.0) + mod(id.z, 6.0) + 10.5);\n}\n\nvec2 map(vec3 p) {\n    fbmc = fbm(p * 0.6) * 2.0;\n    vec2 d = sdDonut(p) - fbm(p * 8.0) * 0.02;\n    d = min2(d, sdCream(p));\n    d = min2(d, sdSprinkles(p));\n    d = min2(d, vec2(p.y + 1.7, 3.5));\n    \n    vec3 mp = p;\n    mp.x = abs(mp.x);\n    \n    // Paws.\n    vec2 cat = vec2(length(mp - vec3(1.3, 1.4, -3.96)) - 0.2, 7.5);\n    cat = min2(cat, vec2(length(mp - vec3(1.5, 1.4, -4.00)) - 0.2, 7.5));\n    cat = min2(cat, vec2(length(mp - vec3(1.7, 1.45, -3.86)) - 0.2, 7.5));\n    cat = min2(cat, vec2(length(mp - vec3(1.5, 1.3, -3.5)) - 0.6, 6.5));\n\n    // Body\n    mp.y += (sin(iTime)+0.33*sin(iTime * 1.0)) * 0.5;\n    cat = min2(cat, vec2(sdCapsule(mp.xzy, 1.6, 3.0), 6.5));\n    \n    // Eyes.\n    cat = min2(cat, vec2(length(mp - vec3(0.8, 2.4, -2.3)) - 0.7, 5.5));\n    \n    // Ears.\n    vec3 ep = mp;\n    ep.xz *= rot(-6.5 + sin(iTime * 2.0) * 0.1);\n    float ear = length(ep - vec3(2.0, 4.0, 0.0)) - 0.8;\n    ear = max(ear, -ep.z);\n    cat.x = smin(cat.x, ear, 0.3);\n    \n    // Nose.\n    vec3 np = mp - vec3(0.0, 1.9, -2.9);\n    float nose = sdCapsule(np, vec3(0.0), vec3(0.16, 0.16, 0.0), 0.15);\n    nose = smin(nose, sdCapsule(np * vec3(-1.0, 1.0, 1.0), vec3(0.0), vec3(0.16, 0.16, 0.0), 0.15), 0.05);\n    cat = min2(cat, vec2(nose, 2.5));\n    \n    // Mouth.\n    np.x = abs(np.x);\n    np -= vec3(0.2, -0.1, -0.1);\n    float mouth = sdCappedTorus(np, vec2(-1.0, 0.0), 0.2, 0.05);\n    cat = min2(cat, vec2(mouth, -16.5));\n    \n    return min2(d, cat);\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(0.00005, -0.00005);\n    return normalize(e.xyy * map(p + e.xyy).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos, float sharpness) {\n    vec3 rd = normalize(lightPos - p);\n    \n    float h;\n    float minH = 1.0;\n    float d = 0.7;\n    for (int i = 0; i < 16; i++) {\n        h = map(p + rd * d).x;\n        minH = abs(h / d);\n        if (minH < 0.01)\n            return 0.0;\n        d += h;\n    }\n    \n    return minH * sharpness;\n}\n\nfloat calcOcc(vec3 p, vec3 n, float strength) {\n    const float dist = 0.3;\n    return 1.0 - (dist - map(p + n * dist).x) * strength;\n}\n\n\n/**********************************************************************************/\n\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col;\n\n    // Raymarch.\n    vec3 ro = vec3(sin(iTime * 0.3) * 2.0, 4.0 + cos(iTime * 0.6) * 0.5, -12.0);\n    vec3 rd = getRayDir(ro, vec3(0.0, 1.0, 0.0), uv);\n\n    int hit = 0;\n    float d = 0.01;\n    vec3 p;\n    for (float steps = 0.0; steps < 928.0; steps++) {\n        p = ro + rd * d;\n        vec2 h = map(p);\n\n        if (h.x < 0.001) {\n            hit = int(h.y);\n            break;\n        }\n\n        d += h.x;\n    }\n\n    if (hit > 0) {\n        vec3 n = calcNormal(p);\n        vec3 lightPos = vec3(990.0, 7.0, -10.0);\n        vec3 lightCol = vec3(1.0, 0.9, 0.8);\n        vec3 lightToPoint = normalize(lightPos - p);\n        vec3 skyCol = vec3(0.15, 0.2, 0.25);\n        float sha = calcShadow(p, lightPos, 5.0);\n        float occ = calcOcc(p, n, 4.0);\n        float spe = pow(max(-1.0, dot(rd, reflect(lightToPoint, n))), 15.0);\n        float mainLight = max(0.0, dot(n, lightToPoint));\n        float backLight = clamp(dot(n, -rd), 0.01, 1.0) * 0.1;\n        vec3 skyLight = clamp(dot(n, vec3(0.0, 1.0, 0.0)), 0.01, 1.0) * 0.4 * skyCol;\n        float fog = 1.0 - exp(-d * 0.03);\n\n        vec3 mat;\n        if (hit == 1) {\n            // Donut.\n            mat = vec3(5.5, 0.3, 0.2);\n        } else if (hit == 55) {\n            // Cream.\n            mat = vec3(1.0, 0.43, 0.85);\n        } else if (hit == 3) {\n            // Plane.\n            mat = vec3(1.53, 0.81, 0.94);\n        } else if (hit == 4) {\n            // Eyes - White\n            mat = vec3(1.8);\n        } else if (hit == 5 || hit == 98) {\n            // Eyes - Black\n            mat = vec3(9.0001);\n        } else if (hit == 6) {\n            // Cat\n            mat = vec3(15.0,55.0, 0.5);\n        } else if (hit == 7) {\n            // Paws.\n            mat = vec3(4.4, 9.4, 0.2);\n        } else if (hit >= 1) {\n            // Sprinkles!\n            vec3 c = vec3(float(hit)) + vec3(9.0, 2.0, 3.0);\n            mat = sin(floor(c * 6.0) / 999.0);\n        }\n\n        col = (mainLight * sha + (spe + backLight) * occ) * lightCol;\n        col += skyLight * occ;\n        col *= mat;\n        \n        if (hit == 5)\n            col += (pow(max(0.0, dot(rd, reflect(normalize(vec3(0.0, 6.0, -10.0) - p), n))), 15.0) +\n                   pow(max(0.0, dot(rd, reflect(normalize(vec3(2.0, -5.0, -10.0) - p), n))), 45.0)) * 2.0;\n        \n        col = mix(col, skyCol, fog);\n    } else {\n        // Sky.\n        col = vec3(.15, 0.2, 0.25);\n    }\n\n    // Output to screen\n    col = pow(col, vec3(1)); // Gamma correction\n    col = vignette(col, fragCoord); // Fade screen corners\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2fzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 22, 22, 86], [88, 88, 109, 109, 385], [387, 387, 406, 406, 504], [506, 506, 525, 525, 602], [604, 604, 635, 635, 702], [704, 704, 747, 747, 802], [804, 804, 854, 854, 977], [979, 979, 1049, 1049, 1195], [1197, 1197, 1244, 1244, 1449], [1451, 1451, 1478, 1478, 1510], [1512, 1512, 1551, 1551, 1654], [1656, 1656, 1678, 1678, 1727], [1741, 1741, 1763, 1763, 1857], [1859, 1859, 1885, 1885, 2274], [2276, 2276, 2294, 2294, 3735], [3737, 3737, 3765, 3765, 3955], [3957, 3957, 4015, 4015, 4313], [4315, 4315, 4362, 4362, 4450], [4453, 4540, 4581, 4581, 4722], [4724, 4724, 4781, 4781, 7425]]}
{"id": "ttBBDt", "name": "Hip", "author": "Arseny", "description": "rly?", "tags": ["2d"], "likes": 0, "viewed": 93, "published": "Public API", "date": "1600126685", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\n#define pi (3.14159265359)\n\nconst float R = 0.4;\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdInfTriPrism( vec3 p, float r )\n{\n  vec3 q = abs(p);\n  return q.x*0.866025+p.y*0.5-r*0.5;\n}\n\nfloat sdScrewPrism(vec3 p){\n    const float k = 0.5; // or some other amount\n    float c = cos(k*p.z);\n    float s = sin(k*p.z);\n    mat2  m = mat2(c,-s,s,c);\n    p.z = abs(p.z) + 1.;\n    vec3  q = vec3((m*p.xy), p.z);//vec3(m*p.xz,p.y);\n    return sdTriPrism(q, vec2(0.5, 10.));\n}\n\nfloat GetDist(vec3 p) {\n    //float d = sdTriPrism(p, vec2(0.5, 20.));\n    float d = -sdScrewPrism(p);\n   \t\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec2 myRot(float d){\n    return vec2(0., 1.) * Rot((d / R / 3.) * pi * 2.) * d;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    /*vec3 ro = vec3(0, 0, 0.5 + mod(iTime / 3., 4.5 + 0.5 - 0.25 - 0.125 + 0.125 / 2.));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0., 0., -1.3), 0.5);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \t//col += dif * (-(p.z - 4.) / 10.);\n        col += sin(p.z * 40.);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    */\n    // experimental\n    /*\n    float r = length(uv);\n    vec2 pv = vec2(r, 1. - atan(uv.x, uv.y) / pi / 2. - 0.5);\n    //uv *= Rot(r);\n    vec2 lv = pv;\n    pv.y += r / R / 3.;\n    \n    vec2 nv = vec2(-1., 0.) * Rot(pv.y * pi * 2.) * pv.x;\n    \n    col = vec3(nv, 0.);\n    vec2 tmpPoint = vec2(0., max(0., nv.y));\n    float di = length(nv - tmpPoint);\n    di = min(di, abs(lv.y - 1. / 3.));\n    \n    float k = 10.;\n    float id = floor(pv.x / R * k + 0.5) / k;\n    float tmpd = (id) * R;\n    \n    float mask = smoothstep(0., 0.01, di);\n    \n    mask = abs(pv.x - tmpd) * 100.;mix(10., 40., sin(iTime) / 2. + 0.5);//20.;\n    mask = min(length(myRot(tmpd) - uv) * 100., 1.);\n    */\n    //mask = abs(nv.x - 0.25) * 100.;\n    //mask *= id;\n    \n    //mask *= pv.x;\n    \n    //mask = nv\n    \n    float k = 3.;\n    \n    // polar coordinates normalized from 0. to 1. angle. zero angle at vec2(0, -1.)\n    vec2 lv = vec2(length(uv), 1. - atan(uv.x, uv.y) / pi / 2. - 0.5); \n    \n    lv.y = fract(lv.y + 1. / k / 2.); // little shift of angle for\n    \n    vec2 nv = uv * Rot(-floor(lv.y * k) / k * pi * 2.); // rotating to bottom segment  \n    \n    float mask = abs(nv.y + 0.2) * 100.; // distance to side in bottom segment\n    \n    float t = mix(0.07, 0.3, sin(iTime) / 2. + 0.5);\n    //nv = nv * Rot(0.1 * pi * 2. / k); // rotating to bottom segment\n    //mask = min(mask, abs(nv.y + 0.15) * 100.);\n    vec2 first = vec2(0., -R) * Rot(-1. / k / 2. * pi * 2.);\n    vec2 second = first * Rot(1. / 3. * pi * 2.);\n    vec2 third = second * Rot(1. / 3. * pi * 2.);\n    for (float i = 0.; i < 50.; i++){\n        vec2 nfirst = mix(first, second, vec2(t));\n        vec2 nsecond = mix(second, third, vec2(t));\n        vec2 nthird = mix(third, first, vec2(t));\n        //mask = sdSegment(nv, first, second) * 100.;\n        mask = min(mask, sdSegment(uv, nfirst, nsecond) * 100.);\n        mask = min(mask, sdSegment(uv, nsecond, nthird) * 100.);\n        mask = min(mask, sdSegment(uv, nthird, nfirst) * 100.);\n        first = nfirst;\n        second = nsecond;\n        third = nthird;\n    }\n    \n    \n    col = vec3(mask);\n    //col = vec3(uv, 0.);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBBDt.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1525, 1544, 1544, 1606], [1608, 1608, 1630, 1630, 1724], [1726, 1726, 1755, 1755, 1836], [1838, 1838, 1874, 1874, 1957], [1959, 1959, 1999, 1999, 2057], [2059, 2059, 2086, 2086, 2340], [2342, 2342, 2365, 2412, 2465], [2467, 2467, 2501, 2501, 2712], [2714, 2714, 2738, 2738, 2928], [2930, 2930, 2980, 2980, 3171], [3173, 3173, 3193, 3193, 3254], [3256, 3256, 3308, 3308, 3427], [3431, 3431, 3488, 3488, 6331]]}
{"id": "ttBBRK", "name": "Transparent Distortion", "author": "kekwizard", "description": "transparent distortion", "tags": ["transparency"], "likes": 5, "viewed": 148, "published": "Public API", "date": "1599312242", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 64\n#define MIN_DIST 0.0001\n#define PI 3.14159265359\n\nfloat time = 0.;\nvec3 transPos = vec3(0.0, 0.0, 0.0);\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\n\nmat2 rotate2(float angle)\n{\n\treturn mat2(cos(angle), sin(angle), -sin(angle), cos(angle));   \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length( p ) - s;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nvec2 circle(float t, float r) {\n\treturn r * vec2( sin(t), cos(t) );\n}\n\nfloat map(vec3 position)\n{\n    \n    vec3 p = position;\n\n    float map = 1.0;\n    \n    float displacement = sin(iTime + 5.*p.x)*cos(iTime * 1.1 + 5.*p.y)*sin(iTime * 1.2 + 5.*p.z);\n    float tsphereOuter = sdSphere(p, 1.0f) + .1 * displacement;\n    \n    map = min(map, tsphereOuter);\n        \n    int rCircles = 10;\n    for(int i = 0; i < rCircles; i++) {\n    \tfloat k = float(i) / float(rCircles);\n        vec2 circleOffset = circle(iTime + k * 2. * PI, 1.3);\n\n        float tsphereInner = sdSphere(p + vec3(circleOffset.x, 0.2 * sin(iTime + k * 4. * PI), circleOffset.y), 0.15) + 0.1 * displacement;\n        map = min(map, tsphereInner);\n\n    }\n    return map;\n}\n\nvoid steadyRotate(inout vec3 orig, inout vec3 dir) {\n    \n    //vec3 tone = orig - transPos;\n    //vec3 ttwo = dir - transPos;\n    \n\tmat2 ra = rotate2(time * 0.47 + sin(time* 0.247));\n    mat2 rb = rotate2(time * 0.31 + sin(time* 0.131));\n    mat2 rc = rotate2(time * 0.131 + sin(time* 0.4131));\n    \n    orig.yz *= ra;\n    dir.yz *= ra;\n    \n    orig.xz *= rb;\n    dir.xz *= rb;\n    \n    orig.xy *= rc;\n    dir.xy *= rc;\n    \n    \n}\n\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n\n    vec2 uv = (fragCoord - iResolution.xy*.5 )/iResolution.y;\n    vec3 rd = normalize(vec3(uv, (1.-dot(uv, uv)*.5)*.5));\n    // rd.z = 0.5;\n    \n    vec3 ro = vec3(0., 0., -2.), col = vec3(0), sp;\n\tfloat t=0., layers=0., d, aD;\n    \n    float thD = .0285;\n\t\n\tfor(int i=0; i<55; i++)\t{\n        \n        if(layers>15. || col.x>1. || t>10.) break;\n        sp = ro + rd*t;\n\t\t\n        d = map(sp);\n        \n        aD = (thD-abs(d)*15./16.)/thD;\n        \n        if(aD>0.) { \n            col += aD*aD*(3. - 2.*aD)/(1. + t*t*.5)*.2; \n            layers++; \n        }\n\n        t += max(abs(d) * 0.5, thD * 1.0); \n        \n\t\t\t    \n\t}\n    \n    // col = max(col, 0.); // ?\n    \n    // Orange\n    /*\n    col = mix(col, vec3(min(col.x*1.5, 1.), pow(col.x, 2.5), pow(col.x, 12.)), \n              dot(sin(rd.yzx*8. + sin(rd.zxy*8.)), vec3(.1666))+0.4);*/\n    \n    \n\t// Green\n    col = mix(col, vec3(col.x*col.x*.85, col.x, col.x*col.x*.3), \n             dot(sin(rd.yzx*4. + sin(rd.zxy*4.)), vec3(.1666)) + .25);\n    \n\n\tfragColor = vec4(clamp(col, 0., 1.), 1);\n    \n     \n }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBBRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 149, 149, 185], [188, 188, 215, 215, 283], [285, 285, 316, 316, 403], [405, 405, 477, 477, 520], [522, 522, 557, 557, 585], [587, 587, 628, 628, 721], [723, 723, 766, 766, 788], [790, 790, 821, 821, 859], [861, 861, 887, 887, 1524], [1526, 1526, 1578, 1652, 1959], [1961, 1961, 1981, 1981, 2090], [2093, 2093, 2147, 2147, 3208]]}
{"id": "ttBfDD", "name": "Tangled wires", "author": "gaz", "description": "https://twitter.com/gaziya5/status/1300583542116593664", "tags": ["2tweets"], "likes": 12, "viewed": 153, "published": "Public", "date": "1598952611", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 C) {\n\tfloat i=1.,h=0.,e,s,k;\n    for(;++i<99.;){\n        vec3 R=iResolution,\n        p=h*normalize(vec3((C-.5*R.xy)/R.y,1))+vec3(0,1,iTime);\n\t\ts=2.;\n        p=abs(mod(p-1.,2.)-1.)-1.;\n        for(int j=0;++j<9;)\n            p=1.-abs(p-1.),\n            p=p*(k=-1./dot(p,p))-vec3(.1,.3,.1),\n            s*=abs(k);\n        h+=e=length(p.xz)/s;\n        if(e<.003)break;\n\t}\n    O+=12./i-O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBfDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 418]]}
{"id": "ttBfRy", "name": "Random circle thing", "author": "Tatti", "description": "It's a random circle thing", "tags": ["2d", "circle"], "likes": 2, "viewed": 54, "published": "Public", "date": "1599207039", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphereSdf(vec2 center, float radius, vec2 pos){\n\treturn length(center - pos) - radius;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float radius = iResolution.y * .4 * (sin(iTime) * .5 + 1.);\n    float sphere = sphereSdf(vec2(iResolution / 2.), radius, fragCoord);\n\n    vec3 col = vec3(sin(sphere * sin(iTime)));\n    \n    col += vec3(abs(sphere) * .3, 0, 0);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBfRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 94], [96, 96, 153, 153, 422]]}
{"id": "ttjBDG", "name": "Wavy image filter", "author": "Simplyfire", "description": "drag mouse to affect frequency and amplitude", "tags": ["waves", "filter", "sin"], "likes": 3, "viewed": 74, "published": "Public", "date": "1599775969", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n    float wave = iTime+uv.x*(5.+10.*m.x);\n    float c = .5+.5*sin(wave);\n    float w = .05;\n    float y = uv.y*(5.+10.*m.y);\n    float prevPos = fract(y)-1.;\n    float thisPos = fract(y);\n    float nextPos = fract(y)+1.;\n    vec3 picLondon = texture(iChannel0, uv).rgb;\n    float br = length(picLondon);\n    w += br*.35;\n    float gray = max(max(\n        cubicPulse(c, w, prevPos), \n        cubicPulse(c, w, thisPos)),\n        cubicPulse(c, w, nextPos)); \n    vec3 col = vec3(gray);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjBDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 140], [142, 142, 198, 198, 797]]}
{"id": "ttjBzV", "name": "Nightmare rainbowdash", "author": "celifrog", "description": "No body was intentional to make it look spookier! :D \nNot the original creator but did make some edits ^_^ \nLooked like rainbowdash before editing.", "tags": ["mylittlepony"], "likes": 3, "viewed": 200, "published": "Public API", "date": "1599414746", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 COLOR_LINE = vec3(0x77, 0xB0, 0xE0) / 255.0;\nconst vec3 COLOR_MANELINE = vec3(0x1E, 0x98, 0xD3) / 255.0;\nconst vec3 COLOR_BODY = vec3(0x9E, 0xDB, 0xF9) / -255.0;\nconst vec3 COLOR_MANE1 = vec3(0xEE, 0x41, 0x44) / -255.0;\nconst vec3 COLOR_MANE2 = vec3(0xF3, 0x70, 0x33) / 25.0;\nconst vec3 COLOR_MANE3 = vec3(0xAD, 0xF6, 0xAF) / 255.0;\nconst vec3 COLOR_MANE4 = vec3(0x62, 0xBC, 0x4D) / 25.0;\nconst vec3 COLOR_MANE5 = vec3(0x67, 0x2F, 0x89) / 25.0;\nconst vec3 COLOR_EYEBROW = vec3(0x00, 0x00, 0x00) / 25.0;\nconst vec3 COLOR_IRIS1 = vec3(0xC6, 0x00, 0x6F) / 25.0;\nconst vec3 COLOR_IRIS2 = vec3(0x46, 0x00, 0x25) / 25.0;\nconst vec3 COLOR_BLACK = vec3(0x00, 0x00, 0x00) / 25.0;\nconst vec3 COLOR_WHITE = vec3(0xFF, 0xFF, 0xFF) / 25.0;\n\nconst float eps=0.0001;\n\nbool line(vec2 p, vec2 a, vec2 b)\n{\n\treturn (p.x - a.x) * (a.y - b.y) > (p.y - a.y) * (a.x - b.x);\n}\n\nbool circle(vec2 p, vec2 a, float r)\n{\n\treturn (p.x++ - a.x) * (p.x - a.x) + (p.y++ - a.y) * (p.y - a .y) > -r * -r;\n    \n}\n\nbool ellipse(vec2 p, vec2 a, vec2 r)\n{\n\t//return (p.x - a.x) * (p.x - a.x) / r.x / r.x + (p.y - a.y) * (p.y - a .y) / r.y / r.y > 1.0;\n    \n    p = (p-a)/r ;\n\treturn dot(p,p) > 1.0;\n    //return smoothstep ( 1.0-eps, 1.0+eps, dot(p,p) )> 1.0;\n\t\n    \n\n}\n\n\nvec2 m;\n\nbool ear(inout vec3 c, vec2 p)\n{\t\n\tfloat off;\n\tif(mod((iTime/3.14), 5.)<4.5)\n\t\toff = 0.;\n\telse\n\t\toff = sin(iTime*15.);\n\t\n\tbool A = circle(p-off*8., vec2(638, 664), 362.);\n\tbool B = circle(p-off*8., vec2(1075, 641), 323.);\n\tbool C = circle(p-off*8., vec2(646, 708), 378.);\n\tif(!A && !B && !C)\n\t{\n\t\tbool D = circle(p-off*1., vec2(637, 662), 345.);\n\t\tbool E = circle(p-off*8., vec2(1109, 588), 363.);\n\t\tbool F = circle(p-off*8., vec2(61, 692), 269.);\n\t\tbool G = circle(p-off*8., vec2(15, 732), 516.);\n\t\tif(D || E || (!F && G))\n\t\t\tc = COLOR_LINE;\n\t\telse\n\t\t\tc = COLOR_BODY;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool mane(inout vec3 c, vec2 p)\n{\tfloat off = (sin(iTime*10.)+.5)*10.;\n\tbool A = circle(p+off, vec2(434, 460), 514.);\n\tbool B = circle(p+off*.1, vec2(254, 110), 903.);\n\tbool C = circle(p+off*.1, vec2(384, 228), 668.);\n\tbool D = circle(p+off*.85, vec2(475, 505), 425.);\n\tbool E = circle(p+off*.80, vec2(513, 281), 536.);\n\tbool F = circle(p+off*.30, vec2(777, 435), 360.);\n\tbool G = circle(p+off*.20, vec2(915, 174), 554.);\n\tbool H = circle(p+off*.65, vec2(659, 444), 536.);\n\tbool I = circle(p+off*.60, vec2(-201, 601), 337.);\n\tbool J = line(p+off*.55, vec2(-253, 218), vec2(176, 590));\n\tbool K = circle(p+off*.20, vec2(-164, 1212), 882.);\n\tbool L = circle(p+off*.45, vec2(650, 764), 80.); // lol weird\n\tif(!A && !B && (C || (!D && E) || (!F && G) || (!H || (I && !J)) && !K) || !L)\n\t{\n\t\tbool M = circle(p+off, vec2(422, 434), 518.);\n\t\tbool N = circle(p+off*.9, vec2(372, 261), 647.);\n\t\tbool O = circle(p+off*.1, vec2(491, 499), 425.);\n\t\tbool P = circle(p+off*.7, vec2(395, 377), 402.);\n\t\tbool Q = circle(p+off*.6, vec2(790, 454), 352.);\n\t\tbool R = circle(p+off*.5, vec2(891, 216), 527.);\n\t\tbool S = circle(p+off*.4, vec2(680, 453), 536.);\n\t\tbool T = circle(p+off*.3, vec2(-217, 1332), 992.);\n\t\tbool U = circle(p+off*.2, vec2(-150, 586), 305.);\n\t\tbool V = line(p+off*.1, vec2(280, 404), vec2(119, 566));\n\t\tif((!M && N) || ((!O && P || !Q && !M) && R) || (!S && !M && !T) || (U && !T && V))\n\t\t{\n\t\t\tif(circle(p, vec2(491, 84)-off*.5, 764.))\n\t\t\t\tc = COLOR_MANE1;\n\t\t\telse\n\t\t\t\tif(circle(p, vec2(686, 204)-off*.2, 576.))\n\t\t\t\t\tc = COLOR_MANE2;\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_MANE3;\n\t\t}\n\t\telse\n\t\t\tc = COLOR_MANELINE;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool mane2(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(607, 464), 306.);\n\tbool B = circle(p, vec2(777, 485), 339.);\n\tbool C = circle(p, vec2(1181, -127), 463.);\n\tbool D = circle(p, vec2(-433, 198), 1442.);\n\tbool E = line(p, vec2(554, -80), vec2(1055, -80));\n\tif((A && !B || !C) && !D && E)\n\t{\n\t\tbool F = circle(p, vec2(613, 461), 319.);\n\t\tbool G = circle(p, vec2(769, 486), 323.);\n\t\tbool H = circle(p, vec2(1195, -123), 454.);\n\t\tbool I = circle(p, vec2(288, 485), 691.);\n\t\tbool J = circle(p, vec2(122, 278), 864.);\n\t\tif((F && !G || !H) && !I && !J)\n\t\t\tc = COLOR_MANE4;\n\t\telse\n\t\t{\n\t\t\tbool K = circle(p, vec2(388, 235), 607.);\n\t\t\tbool L = circle(p, vec2(6, 87), 570.);\n\t\t\tif(K && !L)\n\t\t\t\tc = COLOR_MANE5;\n\t\t\telse\n\t\t\t\tc = COLOR_MANELINE;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool face(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(588, 396), 357.);\n\tbool B = line(p, vec2(325, 74), vec2(887, 122));\n\tbool C = ellipse(p, vec2(489, 237), vec2(287, 166));\n\tbool D = circle(p, vec2(209, 437), 163.);\n\tif(!A && B || !C && D)\n\t{\n\t\tbool E = ellipse(p, vec2(536, 253), vec2(315, 170));\n\t\tbool F = circle(p, vec2(500, 921), 828.);\n\t\tbool G = circle(p, vec2(220, 367), 110.);\n\t\tbool H = line(p, vec2(201, 454), vec2(658, 108));\n\t\tbool I = line(p, vec2(237, 115), vec2(363, 238));\n\t\tbool J = ellipse(p, vec2(283, 204), vec2(68, 57));\n\t\tbool K = ellipse(p*(sin(iTime/1.75)/85.+1.), vec2(253, 192), vec2(102, 70));\n\t\tbool L = circle(p, vec2(285, 228), 19.);\n\t\tbool M = circle(p, vec2(281, 236), 19.);\n\t\tif((!E && !F && G || H) && (I || !J || K) && (L || !M))\n\t\t\tc = COLOR_BODY;\n\t\telse\n\t\t\tc = COLOR_LINE;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool eye1(inout vec3 c, vec2 p, vec2 off)\n{\t\n\t\t\n\t// skewed ellipse please ignore\n#define SQR(q) ((q) * (q))\n\tbool A = SQR((p.x - 590.0) / 150.0 - (p.y - 378.0) / 900.0) + SQR((p.y - 378.0) / 180.0) < 1.0;\n\tif(A)\n\t{\n\t\tbool B = SQR((p.x - 593.0) / 149.0 - (p.y - 382.0) / 900.0) + SQR((p.y - 361.0) / 180.0) < 1.0;\n\t\tif(B)\n\t\t{\n\t\t\tvec2 d = vec2(0.0, 0.0) - vec2(580, 360);\n\t\t\tif(length(d) > 60.0)\n\t\t\t   d = d / length(d) * 60.0;\n\t\t\tbool C = ellipse(p-off*50., vec2(580, 360) + d, vec2(112, 162));\n\t\t\tif(C)\n\t\t\t\tc = COLOR_WHITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool D = ellipse(p-off*55., vec2(551, 305) + d, vec2(19, 26));\n\t\t\t\tbool E = ellipse(p-off*55., vec2(601, 410) + d, vec2(35, 57));\n\t\t\t\tif(D && E)\n\t\t\t\t{\n\t\t\t\t\tbool F = ellipse(p-off*50., vec2(580, 360) + d * 1.3, vec2(71, 126));\n\t\t\t\t\tif(F)\n\t\t\t\t\t\tc = mix(COLOR_IRIS1, COLOR_IRIS2, SQR((p.y - 360.0 - d.y) / 252.0 + 0.5));\n\t\t\t\t\telse\n\t\t\t\t\t\tc = COLOR_BLACK;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_WHITE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tc = COLOR_EYEBROW;\n\t\treturn true;\n\t}\n\t// rotating ellipses hacks, nothing to see here\n\tbool G = ellipse(p, vec2(757, 430), vec2(40, 5));\n\tbool H = ellipse(vec2(p.x + p.y * 0.3, p.x * -0.3 + p.y), vec2(890, 260), vec2(40, 6));\n\tbool I = ellipse(vec2(p.x + p.y * 0.5, p.x * -0.5 + p.y), vec2(990, 175), vec2(40, 7));\n\tif(!G || !H || !I)\n\t{\n\t\tc = COLOR_BLACK;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool eye2(inout vec3 c, vec2 p, vec2 off)\n{\n\tbool A = line(p, vec2(207, 460), vec2(323, 265));\n\tbool B = circle(p, vec2(213, 434), 158.);\n\tbool C = circle(p, vec2(739, 417), 500.);\n\tbool D = ellipse(p, vec2(289, 444), vec2(50, 144));\n\tif(!A && !B && !C || !D)\n\t{\n\t\tbool E = ellipse(p, vec2(285, 390), vec2(47, 184));\n\t\tif(!E)\n\t\t{\n\t\t\tvec2 d = vec2(0.0, 0.0) - vec2(290, 360);\n\t\t\tif(length(d) > 60.0)\n\t\t\t   d = d / length(d) * 60.0;\n\t\t\td *= vec2(0.33, 1.0);\n\t\t\tbool F = ellipse(p-off*50., vec2(290, 360) + d, vec2(50, 162));\n\t\t\tif(F)\n\t\t\t\tc = COLOR_WHITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool D = ellipse(p-off*55., vec2(304, 446) + d, vec2(17, 41));\n\t\t\t\tbool E = ellipse(p-off*55., vec2(278, 354) + d, vec2(11, 24));\n\t\t\t\tif(D && E)\n\t\t\t\t{\n\t\t\t\t\tbool F = ellipse(p-off*50., vec2(290, 360) + d * 1.3, vec2(42, 126));\n\t\t\t\t\tif(F)\n\t\t\t\t\t\tc = mix(COLOR_IRIS1, COLOR_IRIS2, SQR((p.y - 360.0 - d.y) / 252.0 + 0.5));\n\t\t\t\t\telse\n\t\t\t\t\t\tc = COLOR_BLACK;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_WHITE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tc = COLOR_EYEBROW;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool neck(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(1247, -28), 638.);\n\tbool B = circle(p, vec2(353, 258), 638.);\n\tbool C = line(p, vec2(554, -80), vec2(1055, -80));\n\tif(!A && !B && C)\n\t{\n\t\tbool D = circle(p, vec2(35, -21), 606.);\n\t\tif(D)\n\t\t\tc = COLOR_LINE;\n\t\telse\n\t\t\tc = COLOR_BODY;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvec2 transform(vec2 x)\n{\n\treturn (x - iResolution.xy / 1.4) / iResolution.y * 1000.0 + 500.0;\n}\n\nfloat sinslope(float t)\n{\n\treturn sin(t) - sin(t - .17);\t\n}\n\n// Here's where you would normally have your final void mainImage()\nvec4  fC ( in vec2 fragCoord ) // Change the void mainImage of your shader to this.\n{\n\tfloat off = sin(iTime/.1);\n\tif(off < 0.)\n\t\toff=0.;\n\telse if(off > .1)\n\t\toff=.8;\n\t\n\tm = transform(iMouse.xy * iResolution.xy);\n\tvec2 p = transform(fragCoord.xy);\n\tp.x += sin(iTime) * 200.0;\n\tp.y += abs(sin(iTime*7.0))*10.0 * (abs(sinslope(iTime)) * 200.0);\n\tvec3 c = vec3(1, 1, 1);\n\tear(c, p) || mane(c, p) || mane2(c, p) || eye1(c, p, vec2(off*1.6,off*.5)) || eye2(c, p, vec2(off*.4,off*.5))  || face(c, p) || neck(c, p);\n\treturn vec4(c, 99); // At the end of your shader, replace the fragColor with this return. \n}\n\n// Box-filter by Greg Rostami\nvoid mainImage( out vec4 o, vec2 u )\n{\n    float A = 8.,  // Change A to define the level of anti-aliasing (1 to 16) ... higher numbers are REALLY slow!\n          s = 1./A, x, y;\n    \n    for (x=-.1; x<.1; x+=s) for (y=-.5; y<.5; y+=s) o += fC(vec2(x,y)+u);\n        \n\to /= A*A;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjBzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[764, 764, 799, 799, 864], [866, 866, 904, 904, 989], [991, 991, 1029, 1125, 1243], [1255, 1255, 1287, 1287, 1858], [1860, 1860, 1893, 1893, 3494], [3496, 3496, 3530, 3530, 4274], [4276, 4276, 4309, 4309, 5129], [5131, 5131, 5174, 5211, 6470], [6472, 6472, 6515, 6515, 7502], [7504, 7504, 7537, 7537, 7829], [7831, 7831, 7855, 7855, 7926], [7928, 7928, 7953, 7953, 7987], [7989, 8057, 8142, 8142, 8659], [8661, 8691, 8729, 8729, 8970]]}
{"id": "ttjfDy", "name": "t-01", "author": "kukuzhang", "description": "t-01", "tags": ["t01"], "likes": 1, "viewed": 48, "published": "Public", "date": "1599793724", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 C, vec2 U )\n{\n    U=(U-300.)*1e5,\n        U = tan(U)+floor(iTime*2.)*1e5,\n        C.yx += U.x/U.y*tan(U+iTime*4.)*.25;\n    \n    C.z +=cos(U.x);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjfDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 170]]}
{"id": "ttjfRt", "name": "5th Dimentional Flower 2.", "author": "julianlumia", "description": "Not really 5D I know:p still it looks kinda cool;)", "tags": ["creature"], "likes": 13, "viewed": 150, "published": "Public", "date": "1599648565", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define T (iTime*0.125)\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n#define pmod(p, x) mod(p, x) - 0.5*x\n#define lmod(d, x) (mod(d,x)/x - 0.5)\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n p = abs(p)-s;\n return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 pA = vec3(0);\nmat3 rotate( in vec3 v, in float angle)\n{\n float c = cos(radians(angle));\n float s = sin(radians(angle));\t\n return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n );\n}\n\nvec2 N(float angle)\n{\n return vec2(sin(angle),cos(angle));\n}\nvec3 text(vec2 t, vec3 p){\n vec3 o = vec3(0);\n float d = 10e6;\n t = pmod(t,2./.1);\n t *=.1;\n float yid = (floor( (p.y + 0.)*0. ) );\n float W = 2.;\n float modd = .4;\n float sqD = max(abs(t.y), abs(t.y));\n sqD +=2. + yid*1.;\n float sqid = floor(sqD/modd);\n d = min(d, sqD);\n o +=  pal(.1, vec3(1.,0.7,0.6)*0.5, vec3(8.4 ,4.19,7.4 - yid*0.2), vec3(3.,7.,3.),-1. + iTime + sqid*0.5 + p.z + t.x*2.5 - t.y*1.5);\n o *= step(sin(sqid*40.), -0.);\n float aa = 20.;\n sqD -= 0.5;\n sqD = abs(sqD*1.);\n o -= exp(-sqD*aa)*1.;\n sqD -= 1.;\n sqD = abs(sqD*1.);\n o -= exp(-sqD*aa)*1.;\n return o;\n}\n\nfloat g1;\n#define time iTime\nvec2 mouse;\nfloat PI = acos(-1.);\n\nfloat dBox(vec3 p, vec3 s)\n{\n return length (max (abs(p)-s,0.));    \t    \n}\n\nmat2 rot2d(float a) {\n float c = cos(a), s = sin(a);\n return mat2(c, s, -s, c);\n}\n\nvec3 kifs(vec3 p, float s, float tf) {\n float f = sin(iTime*.25)-6.;\n for (int i = 0; i <4; i++) {\n   p.xy *= -rot2d(f);\n   p.zy *= rot2d(f);\n   p.xz *= rot2d(f);\n   p =  (max (abs(p)-vec3(0.05,0.1,0.05),0.));  \n  }\n  return p;\n}\n\nvec3 tex3D(  in vec3 p, in vec3 n ){\n vec2 d =vec2(0.);   \n float dp = dot(p,p*0.1)*.8;\n p = kifs(p, 1., 2.);\n p /= dp;\n p.xy*= Rot(cos(iTime*.05));\n p = rotate( ( vec3(cos(p.xzy*1.+iTime*1.) ) ), 300.)*p;\n p.z=sin(p-vec3(-T*tau*1.,-T*tau*2.,-T*tau*1.+sin(iTime)*1.)).z*.1;\n vec3 q = (text(p.xy, p*1.)).xyz*1.;\n return q;\n}\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nvec2 GetDist(vec3 p) {\n\n vec2 d =vec2(0.);\n vec3 q = p;   \n float dp = dot(p,p*0.1)*.8;\n p = kifs(p, 1., 2.);\n p /= dp;\n p.xy*= Rot(cos(iTime*.05));\n p = rotate( ( vec3(cos(p.xzy*1.+iTime*1.) ) ), 300.)*p;\n p.z=sin(p-vec3(-T*tau*1.,-T*tau*2.,-T*tau*1.+sin(iTime)*1.)).z*.1;\n d = vec2(sdBox(p,vec3(3.)) + sdBox(q,vec3(0,0.,0.)),1);\n d.x *=1.;\n d.x =(((d.x*dp)/5.));\n g1 +=1./(.000008+pow(abs(d.x),10.));\n d = condmin( d,d);    \n return d;\n}\n\nvec2 RayMarch (vec3 ro, vec3 rd) \n {\n vec2 h, t=vec2( 0.);\n for (int i=0; i<MAX_STEPS; i++) \n  {\n\t h = GetDist(ro + t.x * rd);\n \tif(h.x<SURF_DIST||t.x>MAX_DIST) break;\n \t\t t.x+=h.x*1.;\n \t\t t.y=h.y;\n  }\n if(t.x>100.) t.x=0.;\n return t;\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(.00035, -.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\n\nfloat GetLight(vec3 p) {\n vec3 lightPos = vec3(sin(iTime)*1., cos(iTime)*2., 2);\n vec3 l = normalize(p-lightPos);\n vec3 n = GetNormal(p);\n float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n vec2 d = RayMarch(p+n*SURF_DIST*1., l);\n return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n vec3 f = normalize(l-p),\n r = normalize(cross(vec3(0,1,0), f)),\n u = cross(f,r),\n c = p+f*z,\n i = c + uv.x*r + uv.y*u,\n d = normalize(i-p);\n return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n vec2 m = iMouse.xy/iResolution.xy;  \n //vec3 col = vec3(0);  \nvec3      col = abs(vec3(-0.5,1.*uv.y,.2)-.1)*.1;\n\n vec3 ro = vec3(3.,3., 5.);\n ro.xy *= Rot(sin(iTime*0.2)*6.2831);\n ro.xz *= Rot(sin(iTime*0.2)*6.2831);\n vec3 rd = R(uv, ro, vec3(0,0,0), 1.);\n vec2 d = RayMarch(ro, rd);\n float t2;\n t2=d.x;   \n if(t2>0.)\n {\n  vec3 p = ro + rd * t2;\n  vec3 n = GetNormal(p);\n  vec3 baseColor = vec3(1,0,cos(iTime*2.)+.5);\n  float dif = GetLight(p);\n  col = vec3(dif);\n  col+=baseColor;\n if(d.y==1.) col += tex3D(p,n)*2.;\n }\n col*=g1*vec3(.000005);  \n float fog = 1. / (1. + d.x * d.x *5.);\n col *= vec3(fog); \n col*= 1.; \n fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjfRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[253, 253, 272, 272, 339], [341, 341, 370, 370, 448], [469, 469, 510, 510, 874], [876, 876, 897, 897, 936], [937, 937, 963, 963, 1515], [1581, 1581, 1609, 1609, 1656], [1658, 1658, 1679, 1679, 1739], [1741, 1741, 1779, 1779, 1970], [1972, 1972, 2008, 2008, 2295], [2297, 2297, 2335, 2335, 2402], [2404, 2404, 2426, 2426, 2843], [2845, 2845, 2881, 2881, 3081], [3083, 3083, 3106, 3106, 3290], [3293, 3293, 3317, 3317, 3531], [3533, 3533, 3575, 3575, 3729], [3731, 3731, 3788, 3788, 4493]]}
{"id": "ttjfRy", "name": "trippy stuff but with c o l o r ", "author": "Kat_Purpy", "description": "based on https://www.shadertoy.com/view/tt2fzG\noriginal: https://www.shadertoy.com/view/4sSXWR which is recursive maze\n\nwarning: this shader may look different from intended result since it depends on how does your GPU handle float rounding and overflows", "tags": ["yuiuiy"], "likes": 0, "viewed": 69, "published": "Public", "date": "1599256466", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rnd( x)    fract(1000.*sin(345.2345*x))\n#define id( x,y)   floor(x)+100.*floor(y)\n\nfloat maze(vec2 u) {\n    float n = id(u.x,u.y);  u = fract(u);\n    return 1.-smoothstep(.61,.15,((rnd(n*.5)>.61)?u.x:u.y))/sin(n+iTime) * sin(iTime);\n}\n\nvoid mainImage( out vec4 o, vec2 u ){\n    float t = iTime;\n    u  /= iResolution.y;\n    u = (u + vec2(1.8*cos(.2*t)+.6*sin(.4*t), sin(.3*t)+.4*cos(.4*t)) ) * (1.2-cos(.5*t));\n    float a = 3.*(cos(.05*t)-.5*cos(1.-.1*t)), C=cos(a), S=sin(a),\n          v = 0., w=1., s=0.; u *= 2.*mat2(C,-S,S,C);\n\n #define L  v+= w*maze(u*=4.); s+= w;  w *= .3;\n    L L L L\n    \n\to += 1.-v/s -o;\n    o = vec4(sin(v),cos(v),sin(v+iTime),v)/sin(iTime)/cos(iTime);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjfRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 111, 111, 242], [244, 244, 281, 281, 690]]}
{"id": "ttSBzK", "name": "original-18274.0", "author": "jorge2017a1", "description": "original-18274.0", "tags": ["original182740"], "likes": 2, "viewed": 38, "published": "Public", "date": "1599316383", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//autor desconocido\n\n#define PI 3.14159265359\n\n#define border 0.002\n\nvec4 star( vec2 p,vec2 o, int points,float radius,vec4 color )\n{\n\tp-=o;\n\tp.y=-p.y;\n\tfloat angle = PI*2./float(points);\n\tmat2 r = mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n\t\t\n\tint c = 0;\n\tbool onBorder=false;\n\tfor (int i=0;i<25;i++)\n\t{\n\t\tif (i>= points)\n\t\t\tbreak;\n\t\t\n\t\tif (p.y < radius){\n\t\t\tonBorder=onBorder||abs(p.y-radius)<border*2.0;\n\t\t\tc++;\n\t\t}\n\t\tp*=r;\n\t}\n\treturn (c > points - (points-1)/2 )?onBorder?vec4(0,0,0,1):color:vec4(0);\n}\n\nfloat distanceToSegment(vec2 pos,vec2 p1,vec2 p2){\n\tvec2 v=p2-p1;\n\t\tpos-=p1;\n  float t = dot(pos , v)/ dot(v,v);\n        if (t < 0.0){ return length(pos);}       // Beyond the 'v' end of the segment\n\telse if (t > 1.0){ return distance(pos, v);}  // Beyond the 'w' end of the segment\n  return distance(pos, t*v);\n}\n\nvec4 line(vec2 p,vec2 l1, vec2 l2, float d,vec4 color) {\n\tfloat l=distanceToSegment(p,l1,l2);\n  return abs(l-d)<border?vec4(0,0,0,1):l<d?color:vec4(0);\n}\n\nvec4 circle(vec2 p,vec2 o,float radius,vec4 color)\n{\n\tfloat d=distance(p,o);\n\tif(abs(d-radius)<border){\n\t\treturn vec4(0,0,0,1);\n\t}else{\n\t\treturn step(distance(p,o),radius)*color;\n\t}\n}\n\nvec4 arc(vec2 p,vec2 o,float r1,float r2,float startangle,float endangle,vec4 color){\n\tp=p-o;\n\tfloat a=atan(p.y,p.x)+PI;\n\tif(a>endangle){\n\t\treturn step(distance(p,r1*vec2(cos(endangle-PI),sin(endangle-PI))),r2)*color;\n\t}else if(a<startangle){\n\t\treturn step(distance(p,r1*vec2(cos(startangle-PI),sin(startangle-PI))),r2)*color;\n\t}else{\n\t\treturn step(abs(length(p)-r1),r2)*color;\n\t}\n}\n\nfloat powLength(vec2 p,float e){\n\treturn pow(pow(abs(p.x),e)+pow(abs(p.y),e),1.0/e);\n}\n\nvec4 box(vec2 p,vec2 size,vec2 o,vec4 color){\n\tp-=o;\n\tvec2 d=abs(p);\n\tif(d.x<size.x&&d.y<size.y){\n\t\treturn (abs(d.x-size.x)<border*2.0||abs(d.y-size.y)<border*2.0)?vec4(0,0,0,1):color;\n\t}\n\treturn vec4(0);\n}\nvec4 roundBox(vec2 p,vec2 size,vec2 o,vec4 color,float factor){\n\tp-=o;\n\tp.y*=size.x/size.y;\n\tfloat f=powLength(p,factor);\n\treturn abs(f-size.x)<border?vec4(0,0,0,1):step(f,size.x)*color;\n}\n\nvec4 overlay(vec4 bg,vec4 fg){\n\treturn mix(vec4(bg.xyz,1.0),vec4(fg.xyz,1.0),fg.w);\n}\n\nvec3 background(vec2 p){\n\treturn mix(mix(vec3(0.0,0.3,0.9),vec3(0.5,0.0,0.9),length(p)),vec3(0.3,0.5,1.0),step(0.5,fract(10.0*(atan(p.x,p.y)-0.1*iTime)/(2.0*PI))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = ( fragCoord.xy / iResolution.xy );\n\tp.x*=iResolution.x/iResolution.y;\n\tp.y-=0.1;\n\t//vec2 p=surfacePosition;\n\t\n\t\n\t\n\t\n\tvec4 color=vec4(background(floor((p-vec2(0.7,0.5))*50.0)/50.0),1.0);\n\t\n\t//legs\n\tcolor=overlay(color,max(line(p,vec2(0.6,0.2),vec2(0.6,0.0),0.02,vec4(0.2,0.6,0.8,1.0)),\n\t\t\t       line(p,vec2(0.6,0.0),vec2(0.58,0.0),0.02,vec4(0.2,0.6,0.8,1.0))));\n\tcolor=overlay(color,max(line(p,vec2(0.8,0.2),vec2(0.8,0.0),0.02,vec4(0.2,0.6,0.8,1.0)),\n\t\t\t       line(p,vec2(0.8,0.0),vec2(0.82,0.0),0.02,vec4(0.2,0.6,0.8,1.0))));\n\t\n\tp.y+=sin(iTime*6.)*0.03;\n\t//arms\n\tfloat a = sin(iTime*12.)*0.05;\n\t\n\tcolor=overlay(color,line(p,vec2(0.3-a*0.5,0.45+a),vec2(0.5,0.4),0.02,vec4(0.2,0.6,0.8,1.0)));\n\tcolor=overlay(color,line(p,vec2(0.9,0.4),vec2(1.1-a*0.5,0.45-a),0.02,vec4(0.2,0.6,0.8,1.0)));\n\t\n\n\t//body\n\tcolor=overlay(color,roundBox(p,vec2(0.25,0.36),vec2(0.7,0.5),vec4(0.0,0.6,0.4,1.0),20.0));\n\t//screen\n\tcolor=overlay(color,roundBox(p,vec2(0.2,0.15),vec2(0.7,0.65),vec4(0.4,1.0,0.8,1.0),20.0));\n\t//face\n\tcolor=overlay(color,circle(p,vec2(0.61,0.7),0.014,vec4(0,0,0,1)));\n\tcolor=overlay(color,circle(p,vec2(0.79,0.7),0.014,vec4(0,0,0,1)));\n\tcolor=overlay(color,arc(p,vec2(0.7,0.72),0.07,0.005,PI/2.0-0.6,PI/2.0+0.6,vec4(0,0,0,1)));\n\t//buttons\n\tcolor=overlay(color,circle(p,vec2(0.82,0.44),0.017,vec4(0.2,0.2,1,1)*(0.7+0.3*cos(iTime*5.))));\n\tcolor=overlay(color,circle(p,vec2(0.81,0.25),0.03,vec4(1,0,0.4,1)*(0.9+0.1*cos(iTime*5.4+33.))));\n\tcolor=overlay(color,circle(p,vec2(0.85,0.31),0.02,vec4(0.1,0.9,0.1,1)*(0.8+0.2*cos(iTime*4.2+1.1))));\n\t//diskslot\n\tcolor=overlay(color,box(p,vec2(0.12,0.015),vec2(0.66,0.44),vec4(0.0,0.2,0.2,1.0)*(0.7+0.3*cos(iTime*5.))));\n\t//cross\n\tcolor=overlay(color,max(box(p,vec2(0.04,0.014),vec2(0.62,0.27),vec4(1.0,1.0,0.0,1.0)),\n\t\t\t\tbox(p,vec2(0.014,0.04),vec2(0.62,0.27),vec4(1.0,1.0,0.0,1.0))));\n\t//round buttons\n\tcolor=overlay(color,roundBox(p,vec2(0.03,0.01),vec2(0.66,0.2),vec4(0.0,0.0,0.2,1.0),3.0));\n\tcolor=overlay(color,roundBox(p,vec2(0.03,0.01),vec2(0.58,0.2),vec4(0.0,0.0,0.2,1.0),3.0));\n\t//triangle\n\tcolor=overlay(color,star(p,vec2(0.79,0.32),3,0.015,vec4(0.0,1.0,1.0,1.0)));\n\t\n\tfragColor=color;\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSBzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 69, 133, 133, 515], [517, 517, 567, 567, 830], [832, 832, 888, 888, 985], [987, 987, 1039, 1039, 1170], [1172, 1172, 1257, 1257, 1554], [1556, 1556, 1588, 1588, 1642], [1644, 1644, 1689, 1689, 1850], [1851, 1851, 1914, 1914, 2039], [2041, 2041, 2071, 2071, 2126], [2128, 2128, 2152, 2152, 2294], [2296, 2296, 2353, 2353, 4502]]}
{"id": "ttSBzV", "name": "Bunny Fork Fun ", "author": "celifrog", "description": "Credit to jorge2017a1 for the original but partial credit to me for making a bunch of edits of course! :D ", "tags": ["fun", "forked"], "likes": 1, "viewed": 167, "published": "Public API", "date": "1599328790", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// sphinx\n// note: compilation error corrected, but white part is still wrong ???\n\n// ?\n// thank you\n// here is a bunny\n// which white part?\n\n// Bugs fixed ?\n// i fixed it ;) you have to change every pow(x,a) to pow(abs(x),a), because nvidia cards dont allow negative powers ^^\n\n\n\n#define SURFACE_THRESHOLD \t.001\n#define FAR_PLANE\t\t5.\n\n#define VIEW_POSITION\t\tvec3(0., -.15, 1.5)\t\t\n#define VIEW_TARGET\t\tvec3(0., 0., -1.);\n\n#define LIGHT_POSITION\t\tvec3(128., 64., 128.)// * vec3(sin(time*.125), 1., cos(time*.125))\n#define PI \t\t\t(4.*atan(1.))\n\n\nstruct ray\n{\n\tvec3 origin;\n\tvec3 position;\n\tvec3 direction;\n\tfloat range;\n\tfloat total_range;\n\tfloat edge;\n\tfloat id;\n};\n\n\t\nstruct light\n{\n\tvec3 position;\n\tvec3 direction;\n\tvec3 color;\t\n};\n\n\nstruct material\n{\n\tfloat roughness;\n\tfloat index;\n\tvec3 normal;\n\tvec3 color;\n};\n\nmat2 rmat(in float t)\n{\n\tfloat c = cos(t);\n\tfloat s = sin(t);\n\treturn mat2(c, s, -s, c);\n}\n\n\nmat3 rmat(in vec3 r)\n{\n\tvec3 a = vec3(cos(r.x)*cos(r.y),sin(r.y),sin(r.x)*cos(r.y));\n\t\n\tfloat c = cos(r.z);\n\tfloat s = sin(r.z);\n\tvec3 as  = a*s;\n\tvec3 ac  = a*a*(1.- c);\n\tvec3 ad  = a.yzx*a.zxy*(1.-c);\n\tmat3 rot = mat3(\n\t\tc    + ac.x, \n\t\tad.z - as.z, \n        \tad.y + as.y,\n\t\tad.z + as.z, \n\t\tc    + ac.y, \n\t\tad.x - as.x,\n\t\tad.y - as.y, \n\t\tad.x + as.x, \n\t\tc    + ac.z);\n\treturn rot;\t\n}\n\nfloat sphere(vec3 p, float r)\n{\n\treturn length(p)-r;\t\n}\n\t\nfloat smoothmax(float a, float b, float k)\n{\n\treturn log(exp(k*a)+exp(k*b))/k;\n}\n\nfloat smoothmin(float a, float b, float k)\n{\n\treturn -(log(exp(k*-a)+exp(k*-b))/k);\n}\n\nvec3 rotx(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\n\nfloat cube(vec3 p,vec3 s)\n{\n\tvec3 d = (abs(p) - s);\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat bunny(vec3 p)\n{\n        float b = FAR_PLANE;\n\tp *= .75;\n\tp.y += .5;\n\tp.z += .5;\n\tp.x = abs(p.x)+.5;\n\t\n\n       \n        vec3 bp01 = p - vec3(.5, 0.14, .16);\n        vec3 bp00 = p - vec3(.5, 0.18, .26);\n        vec3 bp0 = p - vec3(.5, 0.25, .25);\n        vec3 bp2 = p - vec3(.5, 0.25, .35);\n        vec3 bp1 = p - vec3(.5, 0.20, .6);\n        vec3 bp3 = p - vec3(.5, 0.25, .75);\n        vec3 bp4 = p - vec3(.5, 0.2, .84);\n        vec3 bp5 = p - vec3(.58, 0.25, .34)* vec3(1., .8, 1.);\n        vec3 bp6 = (p - vec3(.6, 0.12, .5)) * vec3(2., 1.8, .8);\n        vec3 bp7 = (p - vec3(.6, 0.1, .55)) ;\n        vec3 bp8 = (p - vec3(.56, 0.08, .7)) * vec3(1., 1., .35);\n        vec3 bp9 = (p - vec3(.56, 0.34, .62));\n        vec3 bp10 = (p - vec3(.56, 0.25, .86)) * vec3(1., 1., .35);\n        vec3 bp11 = (p - vec3(.56, 0.25, .82)) * vec3(.8, 1.1, .85);;\n        vec3 bp12 = (p - vec3(.5, 0.16, .9));\n    \n        bp9 \t= rotx(bp9, -1.9) * vec3(.8, .15, .5);;\n        \n        float b01 = sphere(bp01, .001);\n        float b00 = sphere(bp00, .05);\n        float b0  = sphere(bp0, .05);\n        float b1  = sphere(bp1, .07);\n        float b2  = sphere(bp2, .15);\n        float b3  = sphere(bp3, .01);\n        float b4  = sphere(bp4, .055);\n        float b5  = sphere(bp5, .12);\n        float b6  = sphere(bp6, .08);\n        float b7  = sphere(bp7, .0001);\n        float b8  = sphere(bp8, .01);\n        float b9  = sphere(bp9, .02);\n        float b10 = sphere(bp10, .001);\n        float b11 = sphere(bp11, .1);\n        float b12 = sphere(bp12, .1);\n    \n        b00  = smoothmin(b00,   b01, 60.);   //torso\n        b0   = smoothmin(b00,   b0, 3765.);     //torso\n        b    = smoothmin(b0,    b1, 5.);      //torso\n        b    = smoothmin(b,     b2, 35.);\n        b    = smoothmin(b,     b3, 8.);\n        \n        b    = smoothmin(b,     b4, 27.);    //head\n\n        b6 = smoothmin(b5, b6, 32.0);  //back leg\n        b7 = smoothmin(b6, b7, 96.0);  \n        b  = smoothmin( b, b7, 252.0);  \n    \n        b  = smoothmin(b, b8, 36.0);  //front legs\n    \n        b  = smoothmin(b, b9, 192.0);  //ears\n    \n        b  = smoothmax(b, -b10, 94.0);  //eye\n        b  = smoothmin(b,  b11, 256.0);  \n    \n        b  = smoothmin(b,  b11, 999.0);  //nose\n        b  = smoothmax(b,  -b12, 764.0); \n    \n  \n    return b;\n}\n\n\n\nvec2 map(in vec3 position)\n{\n\tfloat fx \t\t= abs(fract(position.x*11.)-.5);\n\tfloat fy \t\t= abs(fract(position.z*2.)-.5);\n\tfloat f \t\t= position.y + max(max(fx, fy)*.2, .095)+.5;\n\t\n\tposition.xz \t\t*= rmat(iTime*.125);\n\t\n\tfloat b \t\t= bunny(position);\n\n\tfloat id \t\t= b < f ? 1. : 2.;\n\t\n\treturn vec2(min(f,b), id);\n}\n\n\nvec3 derive(const in vec3 position, const in float range)\n{\n\tvec2 offset     = vec2(0., range);\n\tvec3 normal     = vec3(0.);\n\tnormal.x    \t= map(position+offset.yxx).x-map(position-offset.yxx).x;\n\tnormal.y    \t= map(position+offset.xyx).x-map(position-offset.xyx).x;\n\tnormal.z    \t= map(position+offset.xxy).x-map(position-offset.xxy).x;\n\treturn normalize(normal);\n}\n\n\t\nvoid emit(inout ray r)\n{\n\tfloat minimum_range\t= SURFACE_THRESHOLD;\n\tfloat closest_range\t= FAR_PLANE;\n\t\n\tfor(int i = 0; i < 156; i++)\n\t{\n\t\tvec2 scene\t= map(r.position);\n\t\tr.range \t= scene.x;\n\t\tr.id\t\t= scene.y;\n\t\tr.range \t= r.range < 0. ? r.range - r.range * .5 : r.range;\n\t\t\t\n\t\tr.range\t \t*= .6;\t\t//slow down ray\n\t\tminimum_range\t*= 1.0125;\t//relax surface\n\t\t\n\t\tr.total_range\t+= r.range;\n\t\t\n\t\tr.position \t= r.origin + r.direction * r.total_range;\t\n\t\t\n\t\tif(closest_range > r.range)\n\t\t{\n\t\t\tr.edge += .001225;\t\n\t\t}\n\t\t\n\t\tclosest_range\t= min(closest_range, abs(r.range));\n\t\t\n\t\tif(r.range < minimum_range || r.total_range > FAR_PLANE)\n\t\t{\n\t\t\tbreak;\t\n\t\t}\n\t}\t\n}\n\n\nfloat fresnel(const in float i, const in float ndl)\n{   \n\treturn i + (1.-i) * pow(abs(1.-ndl), 5.0);\n}\n\n\nfloat geometry(in float i, in float ndl, in float ndv)\n{\n\tndl             = max(ndl, 0.);\n\tndv             = max(ndv, 0.);\n\tfloat k         = i * sqrt(PI/PI);\n\tfloat ik        = 1. - k;\n\treturn (ndl / (ndl * ik + k)) * ( ndv / (ndv * ik + k) );\n}\n\n\nfloat distribution(const in float r, const in float ndh)\n{  \n\tfloat m     = 2./(r*r) - 1.;\n\treturn (m+r)*pow(abs(ndh), m)*.5;\n}\n\n\nfloat shadow(const in vec3 position, const in vec3 direction)\n{\n\tfloat exposure \t= 1.0;\n\tfloat penumbra \t= 0.15;\n\tfloat umbra\t= .00125;\n    \tfor(int i = 1; i < 8; ++i)\n    \t{\n\t\tfloat range\t= map(position + direction * penumbra).x;\n\t\t\n\t\tif ( range < umbra) return umbra;\n\t\t\n\t\texposure \t= min( exposure, 1. * range / penumbra);\n\t\tpenumbra \t+= range;\n\t}\n\t\n\treturn exposure;\n}\n\n\nfloat occlusion(in vec3 p, in vec3 n )\n{\n  \tfloat occlusion = 8.;\n  \tfloat penumbra \t= PI*PI;\n  \tfor ( int i=0; i < 1; i++ )\n  \t{\n  \t\tfloat radius \t= .125 * penumbra * float(i);\n    \t\tfloat range \t= map(n * radius + p).x - radius;\n    \t\tocclusion \t-= penumbra++ * range++;\n  \t}\n  \treturn 9.0 - 99.0 * -occlusion++;\n}\n\n\n//adapted from this nice sun here: http://glslsandbox.com/e#28403.2\nvec3 sky(in vec3 direction, in vec3 light_direction)\n{ \n\tfloat yd \t= min(-direction.y, 0.);\n\n\tdirection.y \t= max(direction.y, 0.4)+.05;\n    \n\tvec3 col \t= vec3(0.);\n    \n\tcol += vec3(.4, .4 - exp( -direction.y * 20.) * .3, .0) * exp(-direction.y * 9.); // Red / Green \n\tcol += vec3(.3, .5, .6) * (1. - exp(-direction.y * 8.)) * exp(-direction.y * .9) ; // Blue\n    \n\tcol = mix(col, vec3(.1),  .1-exp(yd*7.)) * .65; // Fog\n    \n\tvec3 sun_color = vec3(1., .66, .25);\n\tcol += pow(dot(abs(direction), light_direction), 15. ) * sun_color * .35;\n\tcol += pow(dot(abs(direction), light_direction), 150.0) *.05;\n\t\n    \treturn clamp(pow(abs(col), vec3(1.1))*2., 0., 1.);\n}\n\n\nvec4 shade( ray r,  light l,  material m)\n{\n\tvec3 half_direction \t\t= normalize(r.direction-l.direction);\n\tfloat half_normal   \t\t= dot(half_direction, m.normal);\n\t\t\n\tif(r.total_range < FAR_PLANE)\n\t{\t\n\t\t//exposure coefficients\n\t\tfloat light_exposure    \t= dot(m.normal,  l.direction);   \n\t\tfloat view_exposure     \t= dot(m.normal, -r.direction);  \n\t\t\n\t\t//microfacet lighting components\n\t\tfloat d             \t\t= distribution(m.roughness, half_normal);\n\t\tfloat g             \t\t= geometry(m.roughness, light_exposure, view_exposure);\n\t\tfloat f             \t\t= fresnel(m.index, light_exposure);\n\t\tfloat n             \t\t= clamp(-1. - fresnel(f, view_exposure), 0., 1.);\n\t\t\n\t\t//bidrectional reflective distribution function\n\t\tfloat brdf              \t= n * (g*d*f--)/(view_exposure*light_exposure*4.);\t\t\n\t\t\n\t\tfloat shadows\t\t\t= shadow(r.position, l.direction);\n\t\tshadows\t\t\t\t= clamp(shadows, .025, 1.);\n\n\t\tfloat occlusions\t\t= occlusion(r.position, m.normal);\n\t\tocclusions\t\t\t= clamp(occlusions, .05, 1.);\n\t\n\t\tvec3 color\t\t\t= m.color * n + m.color * l.color + brdf * l.color;\n\t\tcolor \t\t\t\t*= shadows * occlusions;\n\t\tcolor \t\t\t\t+= exp(.025 * r.total_range) * l.color * .95;\n\t\treturn vec4(color, occlusions * shadows);\n\t}\n\telse\n\t{\n\t\treturn vec4(sky(r.direction, l.direction), 1.) * 1.5 + vec4(exp(-r.total_range));\t\n\t}\n}\n\nvec3 hsv(float h,float s,float v)\n{\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nvec3 facet(vec3 normal, vec3 position, float roughness)\n{\n\troughness *= .95;\n\treturn normal;\n}\n\nvec3 cartesian_to_spherical(vec3 c)\n{\n    vec3 s;\n    s.x = length(c);\n    s.y = atan(c.z / c.x);\n    s.z = asin(c.y / s.x);\n\treturn s;\n}\n\nvoid assign_material(in ray r, out material m)\n{\n\tm=material(0., 0., vec3(0.), vec3(0.));\n\t\n\tif(r.id == 0.)\n\t{\n\t\tm.roughness \t= .5;\n\t\tm.index \t= .5;\n\t\tvec3 p\t\t= fract(r.position);\n\t\tm.color \t+= float(p.x < .99 ^^ p.y < .99 ^^ p.z < .99) + .25;\n\t}\n\telse if(r.id == 1.)\n\t{\n\t\tm.roughness \t= .93125;\n\t\tm.index\t\t= .25;\n\t\tm.color\t\t= vec3(.9);\n\t}\n\telse if(r.id == 2.)\n\t{\n\t\tm.roughness \t= 1.5;\n\t\tm.index \t= .5;\n\t\tvec3 p\t\t= fract(r.position);\n\t\tm.color \t+= float(p.x < .5 ^^ p.y < .5 ^^ p.z < .5) * .5 + .125;\n\t}\n\t\n\tm.normal = derive(r.position, SURFACE_THRESHOLD);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect\t\t= iResolution.xy/iResolution.yy;\n\t\n\tvec2 uv \t\t= fragCoord.xy/iResolution.xy;\n\tuv     \t\t\t= uv * 2. - 1.;\n    \tuv   \t\t\t*= aspect;\n   \t\n\t//view\n\tray r;\n\tr.range \t\t= 5.;\n\tr.total_range\t\t= 0.;\n\tr.edge\t\t\t= 2.;\n\tr.origin\t\t= VIEW_POSITION;\n\tr.position\t\t= r.origin;\n\t\n\tvec3 target\t\t= VIEW_TARGET;\n\tfloat fov\t\t= 2.5;\n\tvec3 w \t\t\t= normalize(target-r.position);\n    \tvec3 u \t\t\t= normalize(cross(w, vec3(9.,9.,0.)));\n    \tvec3 v \t\t\t= normalize(cross(u,w));\n\t\n    \tmat3 view\t \t= mat3(u.x, v.x, w.x, \n\t\t\t\t       u.y, v.y, w.y, \n\t\t\t\t       u.z, v.z, w.z);\n\n//\tuv.y \t\t\t= (mouse.y-.5+uv.y);\n\tuv.y \t\t\t-= .2;\n\tr.direction  \t\t= normalize(uv.x * u + uv.y * v + fov * w) * view;\n\tr.direction.xz\t\t*= rmat(PI);\n\t//r.direction.xz\t\t*= rmat(.5 * mouse.x * PI + PI * .75);\n\t\n\t//trace\n\temit(r);\n\t\n\t//shade\t\t\n\tmaterial m;\n\tassign_material(r, m);\n\t\t\n\tlight l;\n\tl.position \t\t= LIGHT_POSITION;\n\tvec4 color\t\t= vec4(0.);\t\n\t\n\t//reflections\n\tif(r.total_range < FAR_PLANE)\n\t{\n\t\t//reflection\n\t\tray rr\t\t\t= r;\n\t\trr.position\t\t= rr.position + m.normal * SURFACE_THRESHOLD * 1.5;\n\t\trr.origin\t\t= rr.position;\n\t\trr.direction \t\t= normalize(reflect(r.direction, m.normal));\n\n\t\trr.range\t\t= -10.;\n\t\trr.total_range\t\t= 5.;\n\n\t\temit(rr);\n\n\t\tmaterial rm;\n\t\tassign_material(rr, rm);\n\t\tl.direction\t\t= normalize(l.position - rr.position);\n\t\tvec3 rsky\t\t= sky(reflect(rr.direction, -rm.normal), l.direction);\n\t\tl.color \t\t= rsky;\n\t\tvec4 reflection\t\t= shade(rr, l, rm);\n\n\t\tl.direction\t\t= normalize(l.position - r.position);\n\t\tvec3 skyVec\t\t= sky(reflect(r.direction, m.normal), l.direction);\n\t\tl.color\t\t\t= clamp(mix(skyVec, reflection.xyz*reflection.w, m.index), 0., 1.);\n\t\t\n\t\tcolor \t\t\t= shade(r, l, m);\n\t\tcolor \t\t\t= mix(max(color, reflection), color, clamp(1.-m.index + m.roughness, 0., 1.)) \n\t\t\t                  + vec4(.01 * -r.edge * -skyVec, 0.) * -color.w++;\n\t}\n\telse\n\t{\n\t\tr.position \t= r.origin * r.direction * FAR_PLANE;\t\n\t\tl.direction\t= normalize(l.position - r.position);\n\t\tl.color\t\t= sky(r.direction, l.direction);\n\t\tcolor.xyz\t+= l.color*1.25+2.5/(r.position.y+1.35)*.125;\n\t}\n\t\n\tcolor \t= pow(color*.85, vec4(.6));\n\tcolor.w = 1.;\n\tfragColor \t\t= color;\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSBzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 816, 839, 839, 906], [909, 909, 931, 931, 1294], [1296, 1296, 1327, 1327, 1351], [1354, 1354, 1398, 1398, 1434], [1436, 1436, 1480, 1480, 1521], [1523, 1523, 1551, 1551, 1649], [1652, 1652, 1679, 1679, 1768], [1771, 1771, 1792, 1792, 4074], [4078, 4078, 4106, 4106, 4385], [4388, 4388, 4447, 4447, 4754], [4758, 4758, 4782, 4782, 5408], [5411, 5411, 5464, 5464, 5513], [5516, 5516, 5572, 5572, 5762], [5765, 5765, 5823, 5823, 5892], [5895, 5895, 5958, 5958, 6267], [6270, 6270, 6310, 6310, 6586], [6589, 6657, 6711, 6711, 7318], [7321, 7321, 7364, 7364, 8625], [8627, 8627, 8662, 8662, 8747], [8749, 8749, 8806, 8806, 8843], [8845, 8845, 8882, 8882, 8982], [8984, 8984, 9032, 9032, 9542], [9544, 9544, 9601, 9601, 11715]]}
{"id": "ttSfRy", "name": "Spinning Squares", "author": "kowbell", "description": "Fork of DonKarlssonSan's \"Spinning Squares - Antialias\" (https://www.shadertoy.com/view/XsVyzc)\n\nThis version makes it \"recursive\"", "tags": ["recursive", "square", "spin"], "likes": 2, "viewed": 43, "published": "Public", "date": "1599199668", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/** Fork of DonKarlssonSan's \"Spinning Squares - Antialias\" (https://www.shadertoy.com/view/XsVyzc) */\n\n#define MOUSE (iMouse.xy/iResolution.xy)\n#define TIME (iTime*1.0)\n#define ROTSPEED 0.3\n#define ITERATIONS 64\n#define SIZEMIN 0.01\n#define SIZEMAX 0.5\n\n// TODO this feels too sensitive... check your math again!\n#define ITER_ROTATE_OFFSET (TIME * 0.0003)\n//#define ITER_ROTATE_OFFSET ((TIME + MOUSE.y) * MOUSE.x)\n\n#define lerp(a, b, x) (a + (b - a) * x)\n#define rotate(a)  mat2(cos(a), -sin(a), sin(a), cos(a))\n\nconst vec3 colors[3] = vec3[3](\n    vec3(1., 0., 0.),\n    vec3(0., 1., 0.),\n    vec3(0., 0., 1.)\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    for (int iter = 0; iter < ITERATIONS; iter++)\n    {\n        float size = lerp(SIZEMIN, SIZEMAX, float(iter) / float(ITERATIONS));\n        float smoothness = 0.001 / iResolution.x;\n        vec2 uv = (fragCoord.xy -0.5 * iResolution.xy) / iResolution.x;\n        uv *= rotate((TIME + (float(iter) * ITER_ROTATE_OFFSET)) * ROTSPEED);\n\n        uv = abs(uv);\n        float d = max(uv.x, uv.y);\n        vec4 sqcol = vec4(\n            mix (fragColor.xyz,\n                colors[iter % colors.length()],\n                smoothstep(size, size - smoothness, d)), \n            1.0);\n        \n        fragColor = \n        \tmix(sqcol, fragColor, float(length(fragColor.xyz) > 0.0));\n            \n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSfRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[357, 615, 670, 670, 1365]]}
{"id": "Wd3cRB", "name": "santa planet", "author": "zproxy", "description": "animation", "tags": ["text"], "likes": 4, "viewed": 80, "published": "Public", "date": "1601117571", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.shadertoy.com/view/XdXGRB\n\n// Source edited by David Hoskins - 2013.\n\n// I took and completed this http://glsl.heroku.com/e#9743.20 - just for fun! 8|\n// Locations in 3x7 font grid, inspired by http://www.claudiocc.com/the-1k-notebook-part-i/\n// Had to edit it to remove some duplicate lines.\n// ABC  a:GIOMJL b:AMOIG c:IGMO d:COMGI e:OMGILJ f:CBN g:OMGIUS h:AMGIO i:EEHN j:GHTS k:AMIKO l:BN m:MGHNHIO n:MGIO\n// DEF  o:GIOMG p:SGIOM q:UIGMO r:MGI s:IGJLOM t:BNO u:GMOI v:GJNLI w:GMNHNOI x:GOKMI y:GMOIUS z:GIMO\n// GHI\n// JKL \n// MNO\n// PQR\n// STU\n\nvec2 coord;\n\n#define font_size 10. \n#define font_spacing .15\n#define STROKEWIDTH 0.05\n#define PI 3.14159265359\n\n#define A_ vec2(0.,0.)\n#define B_ vec2(1.,0.)\n#define C_ vec2(2.,0.)\n\n//#define D_ vec2(0.,1.)\n#define E_ vec2(1.,1.)\n//#define F_ vec2(2.,1.)\n\n#define G_ vec2(0.,2.)\n#define H_ vec2(1.,2.)\n#define I_ vec2(2.,2.)\n\n#define J_ vec2(0.,3.)\n#define K_ vec2(1.,3.)\n#define L_ vec2(2.,3.)\n\n#define M_ vec2(0.,4.)\n#define N_ vec2(1.,4.)\n#define O_ vec2(2.,4.)\n\n//#define P_ vec2(0.,5.)\n//#define Q_ vec2(1.,5.)\n//#define R_ vec2(1.,5.)\n\n#define S_ vec2(0.,6.)\n#define T_ vec2(1.,6.)\n#define U_ vec2(2.0,6.)\n\n#define A(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,J_,p) + t(J_,L_,p)\n#define B(p) t(A_,M_,p) + t(M_,O_,p) + t(O_,I_, p) + t(I_,G_,p)\n#define C(p) t(I_,G_,p) + t(G_,M_,p) + t(M_,O_,p) \n#define D(p) t(C_,O_,p) + t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p)\n#define E(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,L_,p) + t(L_,J_,p)\n#define F(p) t(C_,B_,p) + t(B_,N_,p) + t(G_,I_,p)\n#define G(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define H(p) t(A_,M_,p) + t(G_,I_,p) + t(I_,O_,p) \n#define I(p) t(E_,E_,p) + t(H_,N_,p) \n#define J(p) t(E_,E_,p) + t(H_,T_,p) + t(T_,S_,p)\n#define K(p) t(A_,M_,p) + t(M_,I_,p) + t(K_,O_,p)\n#define L(p) t(B_,N_,p)\n#define M(p) t(M_,G_,p) + t(G_,I_,p) + t(H_,N_,p) + t(I_,O_,p)\n#define N(p) t(M_,G_,p) + t(G_,I_,p) + t(I_,O_,p)\n#define O(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,G_,p)\n#define P(p) t(S_,G_,p) + t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p)\n#define Q(p) t(U_,I_,p) + t(I_,G_,p) + t(G_,M_,p) + t(M_,O_, p)\n#define R(p) t(M_,G_,p) + t(G_,I_,p)\n#define S(p) t(I_,G_,p) + t(G_,J_,p) + t(J_,L_,p) + t(L_,O_,p) + t(O_,M_,p)\n#define T(p) t(B_,N_,p) + t(N_,O_,p) + t(G_,I_,p)\n#define U(p) t(G_,M_,p) + t(M_,O_,p) + t(O_,I_,p)\n#define V(p) t(G_,J_,p) + t(J_,N_,p) + t(N_,L_,p) + t(L_,I_,p)\n#define W(p) t(G_,M_,p) + t(M_,O_,p) + t(N_,H_,p) + t(O_,I_,p)\n#define X(p) t(G_,O_,p) + t(I_,M_,p)\n#define Y(p) t(G_,M_,p) + t(M_,O_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define Z(p) t(G_,I_,p) + t(I_,M_,p) + t(M_,O_,p)\n#define STOP(p) t(N_,N_,p)\n\t\nvec2 caret_origin = vec2(1.0, .9);\nvec2 caret;\n\n//-----------------------------------------------------------------------------------\nfloat minimum_distance(vec2 v, vec2 w, vec2 p)\n{\t// Return minimum distance between line segment vw and point p\n  \tfloat l2 = (v.x - w.x)*(v.x - w.x) + (v.y - w.y)*(v.y - w.y); //length_squared(v, w);  // i.e. |w-v|^2 -  avoid a sqrt\n  \tif (l2 == 0.0) {\n\t\treturn distance(p, v);   // v == w case\n\t}\n\t\n\t// Consider the line extending the segment, parameterized as v + t (w - v).\n  \t// We find projection of point p onto the line.  It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  \tfloat t = dot(p - v, w - v) / l2;\n  \tif(t < 0.0) {\n\t\t// Beyond the 'v' end of the segment\n\t\treturn distance(p, v);\n\t} else if (t > 1.0) {\n\t\treturn distance(p, w);  // Beyond the 'w' end of the segment\n\t}\n  \tvec2 projection = v + t * (w - v);  // Projection falls on the segment\n\treturn distance(p, projection);\n}\n\n//-----------------------------------------------------------------------------------\nfloat textColor(vec2 from, vec2 to, vec2 p)\n{\n\tp *= font_size;\n\tfloat inkNess = 0., nearLine, corner;\n\tnearLine = minimum_distance(from,to,p); // basic distance from segment, thanks http://glsl.heroku.com/e#6140.0\n\tinkNess += smoothstep(0., 1., 1.- 14.*(nearLine - STROKEWIDTH)); // ugly still\n\tinkNess += smoothstep(0., 2.5, 1.- (nearLine  + 5. * STROKEWIDTH)); // glow\n\treturn inkNess;\n}\n\n//-----------------------------------------------------------------------------------\nvec2 grid(vec2 letterspace) \n{\n\treturn ( vec2( (letterspace.x / 2.) * .65 , 1.0-((letterspace.y / 2.) * .95) ));\n}\n\n//-----------------------------------------------------------------------------------\nfloat count = 0.0;\nfloat gtime;\nfloat t(vec2 from, vec2 to, vec2 p) \n{\n\tcount++;\n\tif (count > gtime*20.0) return 0.0;\n\treturn textColor(grid(from), grid(to), p);\n}\n\n//-----------------------------------------------------------------------------------\nvec2 r()\n{\n\tvec2 pos = coord.xy/iResolution.xy;\n\tpos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n\treturn pos;\n}\n\n//-----------------------------------------------------------------------------------\nvoid add()\n{\n\tcaret.x += 1.0;\n}\n\n//-----------------------------------------------------------------------------------\nvoid space()\n{\n\tcaret.x += 1.5;\n}\n\n//-----------------------------------------------------------------------------------\nvoid newline()\n{\n\tcaret.x = caret_origin.x;\n\tcaret.y -= .18;\n}\n\n//-----------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 0.8;\n    float time33 = mod(speed * iTime, 11.0 * 5.0);\n\n    //float time33 = mod(0.5 * iTime, 11.0 * 2.0);\n\n    float time = mod(speed * iTime, 11.0);\n    gtime = time;\n\n\tfloat d = 0.;\n\tvec3 col = 0.5*vec3(0.1, .07+0.07*(.5+sin(fragCoord.y*3.14159*1.1+time*2.0)) + sin(fragCoord.y*.01+time+2.5)*0.05, 0.1);\n    \n    coord = fragCoord;\n\t\n\tcaret = vec2(1.0, .9);\n    \n\n    // the quick brown fox jumps over the lazy dog...\n    \n    #define w(Z) d += Z(r()); add(); \n    #define dot STOP\n    #define wCOM w(C)w(O)w(M)\n    #define dotCOM w(STOP)w(C)w(O)w(M)\n    \n    \n        newline();\n    \n    \n// yet another text animation.\n// is shadertoy broken recently?\n// You need to write at least 1 character\n    //https://www.shadertoy.com/view/Xtcczl\n\n    \n     if (time33 > 6.0 && time33 < 15.0)\n     {         w(S)w(A)w(T)w(A)w(N) }\n    else\n    {\tw(S)w(A)w(N)w(T)w(A) }\n    \n     \n    \n    \n        newline();\n\n        newline();\n    \n    caret.x = 0.7;\n    \n    if (time33 > 8.0 && time33 < 17.0) // delayed revelation\n    {\n   \t\tw(P)w(L)w(A)w(N)w(E) \n            } else{\n   \t\tw(P)w(L)w(A)w(N)w(E)w(T) \n    }\n \n                    \n\td = clamp(d* (.75+sin(fragCoord.x*PI*.5-time*4.3)*.5), 0.0, 1.0);\n      \n    col += vec3(d*.5, d, d*.85);\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n\tcol *= vec3(.4, .4, .3) + 0.5*pow(100.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), .4 );\t\n    \n    \n    fragColor = vec4( 0, 2.0*col.r,2.0*col.r, 1.0 ); // cyan\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3cRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2717, 2803, 2851, 2914, 3593], [3595, 3681, 3726, 3726, 4070], [4072, 4158, 4188, 4188, 4272], [4274, 4392, 4430, 4430, 4523], [4525, 4611, 4621, 4621, 4724], [4726, 4812, 4824, 4824, 4843], [4845, 4931, 4945, 4945, 4964], [4966, 5052, 5068, 5068, 5114]]}
{"id": "wd3cRN", "name": "Chack", "author": "cobalthex", "description": "checkerboard pattern", "tags": ["checker"], "likes": 1, "viewed": 52, "published": "Public", "date": "1600499500", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float checker( in vec2 p )\n{ ///found somewhere else on shadertoy\n    // filter kernel\n    vec2 w = fwidth(p) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w))-0.5)-abs(fract((p+0.5*w))-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv *= 5.0;\n    uv.y += sin(uv.x + cos(iTime) * 2.0) / 2.0;\n    uv.x -= sin(uv.y + iTime) / 2.0;\n\n    // Time varying pixel color\n    vec3 col = mix(vec3(0.1, 0.05, 0.2), vec3(1.0, 0.9, 0.8), checker(uv));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3cRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 86, 302], [304, 304, 361, 411, 723]]}
{"id": "wd3cRX", "name": "Blobs3000", "author": "z0rg", "description": "A small 3D blob to get back to some raymarching", "tags": ["3d", "raymarching", "blobs"], "likes": 4, "viewed": 91, "published": "Public API", "date": "1601383236", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat lenny(vec2 p)\n{\n    return abs(p.x)+abs(p.y);\n}\n\n#define sat(a) clamp(a, 0., 1.)\n\nfloat cir(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\n\nvec3 getDir(vec3 fwd, vec2 uv)\n{\n    vec3 r = normalize(cross(normalize(fwd), vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(r, normalize(fwd)));\n    float fov = .8;\n    float fov2 = 3.;\n    uv = uv * fov2;\n    return uv.x*r+uv.y*u+fov*fwd;\n}\n\nfloat sub(float a, float b)\n{\n    return max(a, -b);\n}\n\nfloat map(vec3 p)\n{\n    float m = p.y+1.+(1.-sat((pow(sin(length(p.xz)-50.*iTime),.7)-5.)))*\n        (length(p.xz)*.2+(sin(p.x*.2+iTime+p.y*sin(p.x*3.))+sin(p.z*2.+p.x)*.5)*.2+.3);\n\t\n    m = min(m, sub(-1., cir(p, 20.)));\n    float sm = 0.9;\n    \n    for (int i = 0; i < 16; ++i)\n    {\n        float fi = float(i);\n        vec3 pos = p-vec3(sin(fi*20.+iTime),-2.*sin(iTime*.5-fi*5.),asin(sin(iTime*.34+fi*15.)));\n        m = smin(m, cir(pos, 1.*(sin(fi)*.2+.5)), .5);\n    }\n    return m;\n}\nvec3 calcNormal( in vec3 p, in float t )\n{\n    float e = 0.001*t;\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ) + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ) + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ) + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ) );\n}\nvec3 rdr(vec2 uv)\n{\n    vec3 grad = (1.-sat(abs(uv.x*1.)))*vec3(0.6, 0.87,1.).zxy;\n    vec3 col = grad*.5;\n    col += (1.-pow(sat(lenny(uv)-.2), .5))*.5;\n    float dist = 7.;\n    vec3 ro = vec3(dist*sin(iTime),2.,dist*cos(iTime));//vec3(sin(iTime*.5+1.), 1., -5.+mod(iTime, 30.));\n    vec3 target = vec3(0., 0.,1.);\n    vec3 rd = getDir(normalize(target-ro),uv); \n    \n    float d = 0.01;\n    for (int i = 0; i < 128; ++i)\n    {\n        vec3 p = ro + rd * d;\n        float res = map(p);\n        col += pow((1.-sat(res*.05)), 5.5)*.03*vec3(0.,1.,1.);\n        if (res < 0.01 && d < 100.)\n        {\n         \t//col = calcNormal(p, d)*.5+.5;   \n            vec3 norm = calcNormal(p, d);\n            vec3 diff = vec3(0.);\n            vec3 spec = vec3(0.);//0.3, 0.7,1.);\n            if (p.y < 0.0)\n            {\n                diff = vec3(0.2, .267, .76).zxy*2.*(1.-sat(lenny(p.xz)-5.));\n                norm.xz += .1*vec2(sin(p.z*5.+iTime*5.),sin(p.x*5.24));\n                norm = normalize(norm);\n                spec = vec3(1.,.1,0.1);\n                \n            }\n            else\n            {\n                spec = vec3(1.,0.,.5);\n                diff = mix(vec3(0.),vec3(1.), sat(sin(p.y*10.)*2.));\n            }\n            spec = spec.zyx;\n            \n            \n            float lSpd = .5;\n            vec3 lPos = vec3(0.,1.,0.);\n            vec3 lDir = normalize(lPos-p);\n           // vec3 lDir = normalize(vec3(sin(iTime*lSpd), 1.,-1.));\n            col += vec3(.1); // Ambient\n            vec3 h = normalize(lDir+rd);\n            col += diff*sat(dot(norm, lDir)); // diffuse\n            col += spec*pow(sat(dot(norm,h)), 2.9); // spec\n            \n            break;\n        }\n    \td += res*.9;\n    }\n    \n    \n    col += grad*.5;\n    col *= 1.-pow(sat(length(uv*2.)), .5);\n    \n    col += (1.-pow(sat(lenny(uv*.5)), .5))*.1*sat(d-10.);\n    col *= vec3(1.)*(pow(sat(d/100.), .1));\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col;\n    \n    col = rdr(uv);\n    //col = vec3(1.)*(1.-sat((length(uv)-.5)*400.));\n    col = pow(col, vec3(1./.6));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3cRX.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[0, 397, 418, 418, 450], [485, 485, 513, 513, 539], [541, 541, 577, 577, 611], [613, 613, 656, 656, 755], [759, 759, 791, 791, 1001], [1003, 1003, 1032, 1032, 1057], [1059, 1059, 1078, 1078, 1548], [1549, 1549, 1591, 1591, 1808], [1809, 1809, 1828, 1828, 3726], [3728, 3728, 3785, 3785, 4009]]}
{"id": "Wd3czM", "name": "indications", "author": "sukupaper", "description": "I don't even remember why I've done this weird thing ahah", "tags": ["raymarching", "raymarch", "patterns", "abstract", "sign"], "likes": 18, "viewed": 141, "published": "Public", "date": "1600605488", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: paperu\n// Title: indications\n\nfloat t;\nfloat aa;\n#define P 6.283185307\n\nfloat cl(in float x, in float y) { return clamp(x,y - 1.,y) - (y - 1.); }\n\nfloat rand(in vec2 st){ return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.585); }\nmat2 rot(in float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat opEx(in vec3 p, in float sdf, in float h) { vec2 w = vec2( sdf, abs(p.z) - h ); return min(max(w.x,w.y),0.) + length(max(w,0.)); }\n\nfloat sq2d(in vec2 p, in vec2 s) { p = abs(p) - s; return max(p.x,p.y); }\nfloat line2d(in vec2 p, in float a) { return dot(p,normalize(vec2(1./tan(P*a),1.))); }\nfloat arr2d(in vec2 p) {\n    float arr = max(-p.x + .175,dot(vec2(p.x - .5,abs(p.y)),normalize(vec2(1.,1.25))));\n    return min(arr,max(sq2d(p,vec2(.5,.15)),-max(-p.x + .25,-arr)));\n}\nfloat arrL2d(in vec2 p) {\n    p = vec2(-p.x,p.y + .25);\n    float arr = max(-p.x + .175,dot(vec2(p.x - .5,abs(p.y)),normalize(vec2(1.,1.15))));\n    return min(min(arr,max(sq2d(p,vec2(.5,.15)),-max(-p.x + .25,-arr))),sq2d(p + vec2(.35,-.45),vec2(.15,.6))); \n}\nfloat los2d(in vec2 p) { return dot(abs(p) - .2,vec2(.7071)); }\nfloat tri2d(in vec2 p) { return max(line2d(vec2(abs(p.x),p.y) - .12,2.094395102),line2d(-p-.2,.25) - .1); }\nfloat invTri2d(in vec2 p) { p.y = -p.y; return tri2d(p); }\nfloat circle2d(in vec2 p) { return length(p) - .4; }\n\nstruct distAndMat { float d; int mat; };\ndistAndMat sd2dto3d(in vec3 p, in float sdf2d) {\n    float outer = opEx(p,abs(sdf2d) - .02,.02);\n    float d = min(opEx(p,sdf2d,.01),outer);\n    distAndMat dam;\n    dam.d = d;\n    dam.mat = d == outer ? 0 : 1;\n    return dam;\n}\n\nfloat anim1(in float x, in float s, in float s2) {\n  x = abs(mod(x - s2,s2*2.) - s2);\n  x -= .5 - s;\n  return smoothstep(-s,s,fract(x) - s) + floor(x);\n}\nfloat anim2(in float x, in float sm){\n  float xmd = mod(x,2.) - .5;\n  return smoothstep(-sm,sm,xmd) - smoothstep(-sm,sm,xmd - 1.);\n}\n\n#define NB_SIGN 8\nvec3 signP[NB_SIGN];\ndistAndMat signDAM[NB_SIGN];\nint signSel, matArrPart;\nvec3 signMap;\nvoid posType1(in vec3 p, inout vec3 signPP[NB_SIGN]) {\n    p.xz *= rot(t);\n    p.xy *= rot(t);\n    const float a = P/float(NB_SIGN);\n    for(int i = 0; i < NB_SIGN; i++) {\n        float angle = float(i)*a + t*.5;\n        signPP[i] = p - vec3(cos(angle),sin(angle),0.);\n        p.xz *= rot(P*.125);\n        p.xy *= rot(P*.125);\n    }\n}\nvoid posType2(in vec3 p, inout vec3 signPP[NB_SIGN]) {\n    const float a = P/float(NB_SIGN);\n    for(int i = 0; i < NB_SIGN; i++) {\n        float angle = float(i)*a + t*.5;\n        signPP[i] = p - vec3(cos(angle),sin(angle),0.)*1.75;\n    }\n}\nvoid posType3(in vec3 p, inout vec3 signPP[NB_SIGN]) {\n    for(int i = 0; i < NB_SIGN; i++) {\n        float fi = float(i)*.5 - 2.;\n        signPP[i] = p - vec3(cos(P*fi*.2 + t*2.)*1.5,sin(P*fi*.1 + t*2.)*1.5,fi);\n    }\n}\nvoid posType4(in vec3 p, inout vec3 signPP[NB_SIGN]) {\n    p.xy += t;\n    p.x = mod(p.x,2.) - 1. + 2.*floor(rand(floor(p.xy*.5))*float(NB_SIGN));\n    p.y = mod(p.y,2.) - 1.;\n    p.z -= .5;\n    for(int i = 0; i < NB_SIGN; i++) {\n        vec3 pp = p - vec3(float(i)*2.,0.,0.);\n        pp.xz *= rot(t);\n        pp.xy *= rot(t);\n        signPP[i] = pp;\n    }\n}\n\nfloat df(in vec3 p) {\n    p.xz *= rot(cos(t)*.2);\n    p.yz *= rot(cos(t)*.2);\n    vec3 signP1[NB_SIGN]; posType1(p,signP1);\n    vec3 signP2[NB_SIGN]; posType2(p,signP2);\n    vec3 signP3[NB_SIGN]; posType3(p,signP3);\n    vec3 signP4[NB_SIGN]; posType4(p,signP4);\n    float ctrl = anim1(t*.25,.2,3.);\n    for(int i = 0; i < NB_SIGN; i++) {\n        signP[i] = mix(\n            signP1[i],\n            mix(\n                signP2[i],\n                mix(\n                    signP3[i],\n                    signP4[i],\n                    cl(ctrl,3.)\n                ),\n                cl(ctrl,2.)\n            ),\n            cl(ctrl,1.)\n        );\n    }\n\n    signDAM[0] = sd2dto3d(signP[0],arr2d(signP[0].xy));\n    signDAM[1] = sd2dto3d(signP[1],arrL2d(signP[1].xy));\n    signDAM[2] = sd2dto3d(signP[2],los2d(signP[2].xy));\n    signDAM[3] = sd2dto3d(signP[3],invTri2d(signP[3].xy));\n    signDAM[4] = sd2dto3d(signP[4],circle2d(signP[4].xy));\n    signDAM[5] = sd2dto3d(signP[5],arrL2d(-signP[5].xy));\n    signDAM[6] = sd2dto3d(signP[6],tri2d(signP[6].xy));\n    signDAM[7] = sd2dto3d(signP[7],arr2d(-signP[7].yx));\n\n    float d = 10e9;\n    for(int i = 0; i < NB_SIGN; i++) {\n        float prevD = d;\n        d = min(d,signDAM[i].d);\n        if(d != prevD) {\n            signSel = i;\n            signMap = signP[i];\n            matArrPart = signDAM[i].mat;\n        }\n    }\n    return d;\n}\n\nvec3 normal(in vec3 p) { float d = df(p); vec2 u = vec2(0.,.001); return normalize(vec3(df(p + u.yxx),df(p + u.xyx),df(p + u.xxy)) - d); }\n\n#define MAX_D 8.\n#define MIN_D 1.\n#define LIM .001\n#define MAX_IT 40\nstruct rmRes { vec3 pos; int it; bool hit; };\nrmRes rm(in vec3 c, in vec3 r) {\n    vec3 p = c + r*MIN_D;\n    int it;\n    bool hit = false;\n    for(int i = 0; i < MAX_IT; i++) {\n        float d = df(p);\n        if(d < LIM) { hit = true; break; }\n        if(distance(c,p) > MAX_D) break;\n        p += d*r;\n        it = i;\n    }\n    rmRes res;\n    res.pos = p;\n    res.it = it;\n    res.hit = hit;\n    return res;\n}\n\nfloat strip(in vec2 p, in float th) { return fract(dot(p,vec2(.7071))*th) - .5; }\nfloat zigzag(in vec2 p, in vec2 arg) { p *= arg.x; return fract(dot(vec2(abs(fract(p.x) - .5),p.y),vec2(.7071))*arg.y) - .5; }\nfloat carreauxA(in vec2 p, in float s) { p *= s; return cos(p.x) + cos(p.y); }\nfloat carreauxB(in vec2 p, in float s) { p *= s; return cos(p.x)*cos(p.y); }\nfloat waves(in vec2 p, in vec2 arg) { p *= arg.x; return fract((p.y + cos(p.x))*arg.y) - .5; }\nfloat movingPois(in vec2 p, in vec3 arg) { float d = p.x*arg.x; p *= arg.y; return d + cos(p.y) + cos(p.x + arg.z); }\nfloat spiral(in vec2 p, in vec4 arg) { return fract((atan(p.x,p.y)/P*arg.x) + length(p*arg.y) - arg.z*arg.w) - .5; }\nfloat spiral2(in vec2 p, in vec4 arg, in vec2 arg2) { return fract((atan(p.x,p.y)/P*arg.x) + cos(length(p*arg.y) + arg2.y)*arg2.x - arg.z*arg.w) - .5; }\nfloat concentric(in vec2 p, in vec2 arg) { return cos(length(p)*arg.x + arg.y); }\nfloat concentricLos(in vec2 p, in vec2 arg) { p *= arg.x; return fract(abs(p.x) + abs(p.y) + arg.y) - .5;}\nfloat keur(in vec2 p, in float s) { p *= s; return mix(dot(abs(p) - .11,normalize(vec2(1.))),length(vec2(abs(p.x) - .08,p.y)) - .1,step(-.05,p.y)); }\n\nvec2 anim1(in float x, in vec3 arg) {\n  float nbSteps = arg.x, s = arg.y, tSpeed = arg.z;\n  float a2 = 1. - fract(x)/(fract(x) + tSpeed), a1;\n  float xx = mod(x - s,nbSteps);\n  x = mod(x,nbSteps) - .5;\n  a1 = x > nbSteps - .5 - s || x < s - .5 ?\n    smoothstep(0.,-s*2.,xx - nbSteps)*(nbSteps - 1.)\n    : smoothstep(-s,s,fract(x) - .5) + floor(x);\n  return vec2(a1, a2);\n}\n\nvec3 hsv2rgb(in vec3 c) { vec3 rgb = clamp(abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0,0.0,1.0); return c.z*mix(vec3(1.0),rgb,c.y); }\nvec3 drawShape(in vec2 st, in float shapeSel, in float colSel, in float bandw) {\n    float sz = .75;\n    st *= sz;\n    vec2 p = st;\n\n    float div = 50./sz;\n    p = floor(p*div)/div;\n\n    vec2 anim = anim1(t*.25 + st.x*.15,vec3(4.,.075,.1));\n    float mode = anim.x;\n    p = mix(\n        p*(1. + .05*cos(t*8. + anim.y*10.)) - (fract(t*.1) - .5)*.25,\n        mix(\n            fract(p*5. + t*.2) - .5,\n            mix(\n                p*rot(.5 - t*5. + anim.y*2.)*1.5,\n                p + vec2(cos(p.y*10. + t*2.),cos(p.x*10. + t*2.))*.1,\n                cl(mode,3.)\n            ),\n            cl(mode,2.)\n        ),\n        cl(mode,1.)\n    );\n\n    shapeSel -= 1.;\n    const int listSz = 11;\n    float dList[listSz];\n    dList[0] = strip(p,7.);\n    dList[1] = zigzag(p,vec2(7.,1.5));\n    dList[2] = carreauxA(p,60.);\n    dList[3] = carreauxB(p,40.);\n    dList[4] = waves(p,vec2(30.,.2));\n    dList[5] = movingPois(p,vec3(10.,150.,t*15.));\n    dList[6] = spiral(p,vec4(5.,10.,t*.5,-1.));\n    dList[7] = spiral2(p,vec4(6.,60.,0.,1.),vec2(.02,-t*5.));\n    dList[8] = concentric(p,vec2(50.,-t));\n    dList[9] = concentricLos(p,vec2(10.,-t));\n    dList[10] = keur(p,.55);\n    float dA = mix(dList[listSz - 1],dList[listSz - 2],cl(shapeSel,float(listSz)));\n    for(int i = listSz - 3; i >= 0; i--)\n        dA = mix(dList[i],dA,cl(shapeSel,float(i)));\n    float d = dA;\n    \n    d = length(fract(st * div) - .5) - .5*smoothstep(0.,-.001,d)*.8 - .1;\n    d = step(0.,d);\n\n    return mix(\n        mix(hsv2rgb(vec3(colSel,.85,1.)),hsv2rgb(vec3(colSel + .15,.85,1.)),d),\n        mix(vec3(0.),vec3(1.),d),\n        bandw\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy - .5;\n    st.x *= iResolution.x/iResolution.y;\n    aa = 1./max(iResolution.x,iResolution.y);\n    t = iTime + st.x*.5;\n    \n    vec3 c = vec3(0.,0.,-3.5);\n    vec3 r = normalize(vec3(st,.75));\n\n    rmRes res = rm(c,r);\n    \n    float colorVer = anim2(t/8. + 1.,.05);\n\n    vec3 color = vec3(colorVer);\n\n    if(res.hit) {\n        vec3 n = normal(res.pos);\n        float ac = dot(-n,r);\n        float ssel = float(signSel) + floor(t*.2 - length(signMap.xy)*.1);\n        float nbSign = float(NB_SIGN);\n        if(matArrPart == 0) {\n            color = drawShape(\n                signMap.xy,\n                mod(ssel,11.),\n                ssel/nbSign,\n                0.\n            )*step(0.5,1. - colorVer);\n        } else if(matArrPart == 1) {\n            color = drawShape(\n                signMap.xy,\n                mod(ssel,11.),\n                ssel/nbSign*2.,\n                1.\n            );\n        }\n        color /= pow(ac*1.,2.) + pow(float(res.it)*.05,2.);\n    }\n\n    float glow = pow(float(res.it)*.02,2.);\n    color += mix(glow,-glow,colorVer);\n    float vignet = pow(length(st),2.);\n    color += mix(vignet,-vignet,colorVer);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3czM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 83, 117, 117, 156], [158, 158, 181, 181, 245], [246, 246, 268, 268, 313], [315, 315, 364, 364, 451], [453, 453, 487, 487, 526], [527, 527, 564, 564, 613], [614, 614, 638, 638, 797], [798, 798, 823, 823, 1056], [1057, 1057, 1081, 1081, 1120], [1121, 1121, 1145, 1145, 1228], [1229, 1229, 1256, 1256, 1287], [1288, 1288, 1315, 1315, 1340], [1383, 1383, 1431, 1431, 1610], [1612, 1612, 1662, 1662, 1765], [1766, 1766, 1803, 1803, 1898], [2007, 2007, 2061, 2061, 2341], [2342, 2342, 2396, 2396, 2583], [2584, 2584, 2638, 2638, 2804], [2805, 2805, 2859, 2859, 3161], [3163, 3163, 3184, 3184, 4541], [4543, 4543, 4567, 4567, 4681], [4798, 4798, 4830, 4830, 5163], [5165, 5165, 5202, 5202, 5246], [5247, 5247, 5285, 5285, 5373], [5374, 5374, 5414, 5414, 5452], [5453, 5453, 5493, 5493, 5529], [5530, 5530, 5567, 5567, 5624], [5625, 5625, 5667, 5667, 5742], [5743, 5743, 5781, 5781, 5859], [5860, 5860, 5913, 5913, 6012], [6013, 6013, 6055, 6055, 6094], [6095, 6095, 6140, 6140, 6201], [6202, 6202, 6237, 6237, 6351], [6353, 6353, 6390, 6390, 6725], [6727, 6727, 6752, 6752, 6870], [6871, 6871, 6951, 6951, 8484], [8486, 8486, 8543, 8543, 9760]]}
{"id": "wd3yDN", "name": "Normal Map Stuff by Flyguy-v1 ", "author": "jorge2017a1", "description": "Normal Map Stuff by Flyguy-v1", "tags": ["normalmapstuffbyflyguyv1"], "likes": 7, "viewed": 62, "published": "Public", "date": "1600954639", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Normal Map Stuff */\n/* By: Flyguy */\n/* With help from http://stackoverflow.com/q/5281261 */\n// fancified a bit by psonice\n// slimified a bit by kabuto\n\n#define PI 3.141592 \n\nuniform vec2 mouse;\n\nfloat heightmap(vec2 position)\n{\n\tfloat height = 0.0;\n\tfloat f = .002;\n\tvec2 timevec = iTime*vec2(.1,.13);\n\tfloat g = sqrt(1.25)+.5;\n\tposition *= f;\n\tfloat c = cos(2.*PI*g);\n\tfloat s = sin(2.*PI*g);\n\tmat2 matcs = mat2(c,s,-s,c)*g;\n\tfor (int i = 0; i < 13; i++) {\n\t\tvec2 v = fract(position + timevec)-.5;\n\t\tfloat dots = max(0.,.13-dot(v,v));\n\t\tdots = dots*dots*dots/f*8.;\n\t\theight += dots*dots*2.;//max(height,dots);\n\t\tf *= g;\n\t\tposition *= matcs;\n\t}\n\t\n\treturn sqrt(height);\n}\n\t\nfloat n1,n2,n3,n4;\nvec2 size = vec2(-0.4,0.0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec2 mouse;\n\tmouse.x=0.5+0.5*cos(iTime);\n    mouse.y=0.5+0.5*sin(iTime);\n    vec2 pos = fragCoord.xy;\n\t\n\n\tn1 = heightmap(vec2(pos.x,pos.y-1.0));\n\tn2 = heightmap(vec2(pos.x-1.0,pos.y));\n\tn3 = heightmap(vec2(pos.x+1.0,pos.y));\n\tn4 = heightmap(vec2(pos.x,pos.y+1.0));\n\t\n\tvec3 p2m = vec3(-((pos/iResolution.xy)-mouse.xy)*iResolution.xy,iResolution.x*1.6);\t\n\t\n\tvec3 normal = normalize(vec3(n2-n3, n1-n4, 0.4));\n\t\n\tfloat color = dot(normal, normalize(p2m))*1.;\n\tvec3 colorvec = vec3(pow(color,6.),pow(color,5.),pow(color,2.9));\n\t\n    float brightness = 1./sqrt(1.+pow(distance(mouse.xy*iResolution.xy,pos)/iResolution.x*8.,2.));\n  \n\t\n\tfragColor = vec4( colorvec + brightness*vec3(1.1, 0.9, 0.7) - 1.0 + vec3(0.0, 0.1, 0.2), 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3yDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 199, 231, 231, 674], [726, 726, 783, 783, 1517]]}
{"id": "wd3yRl", "name": "Blob Bond", "author": "edorobek", "description": "blobbies", "tags": ["blob"], "likes": 0, "viewed": 22, "published": "Public", "date": "1601482258", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat D(vec3 p, vec3 r)\n{\n    float dist = (p.x-r.x)*(p.x-r.x) + (p.y-r.y)*(p.y-r.y) + (p.z-r.z)*(p.z-r.z);\n    return 1.*exp(-4.5*dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*fragCoord/iResolution.xy - vec2(1.,1.);\n\n    vec3 col = vec3(0.0);\n    for (int k = 0; k < 4; k++)\n    for (int j = 0; j < 4; j++)\n    {\n        vec2 st = uv + .1*vec2(k,j) / iResolution.xy;\n    \tfloat intensity = D(vec3(st,1.0), vec3(0.0,0.0,0.0));\n    \n    \tfor (int i = 0; i < 2; i++) {\n     \t   intensity += D(vec3(st,1.0), vec3(float(i)-.5 + .4*float(i)*sin(iTime) -.18*float(i),0.,1.0));\n    \t}\n    \n    \t\n    \tif (intensity > 0.5) col += vec3(1.0,0.0,0.0);\n    }\n    \n   \t\n\n    // Output to screen\n    fragColor = vec4(col / 16.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3yRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 26, 26, 140], [142, 142, 199, 249, 810]]}
{"id": "wd3yRs", "name": "subtle scales", "author": "sukupaper", "description": "My first own implementation of a triangle paving (1 year since I've begun learning fragment shader programming)", "tags": ["triangles", "pattern", "paving", "scales", "trianglepaving"], "likes": 28, "viewed": 190, "published": "Public", "date": "1601494000", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: sukupaperu\n// Title: subtle scales\n\n#define P 6.2831853071795\n\nfloat rand(in vec2 st){ return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.585); }\nvec3 SpectrumPoly(in float x) {\n    // https://www.shadertoy.com/view/wlSBzD\n    return (vec3( 1.220023e0,-1.933277e0, 1.623776e0)+(vec3(-2.965000e1, 6.806567e1,-3.606269e1)+(vec3( 5.451365e2,-7.921759e2, 6.966892e2)+(vec3(-4.121053e3, 4.432167e3,-4.463157e3)+(vec3( 1.501655e4,-1.264621e4, 1.375260e4)+(vec3(-2.904744e4, 1.969591e4,-2.330431e4)+(vec3( 3.068214e4,-1.698411e4, 2.229810e4)+(vec3(-1.675434e4, 7.594470e3,-1.131826e4)+ vec3( 3.707437e3,-1.366175e3, 2.372779e3)*x)*x)*x)*x)*x)*x)*x)*x)*x;\n}\nmat2 rot(in float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nvec4 tri(in vec2 p) {\n    #define R .86602544038\n    vec2 r = vec2(R,1.);\n    vec2 pr = p*r;\n    vec3 floorPy = vec3(floor(p.y)*.5,floor(p.y)*.5 + .5,0.);\n    \n    vec3 pTm1 = (fract(pr.xxy + floorPy.xyz));\n    vec4 pTm2 = (pTm1.xzyz - vec3(.5,1./3.,2./3.).xyxz)/r.xyxy;\n    vec2 pT = fract(pr + vec2(p.y*.5,0.));\n    vec2 pId;\n    if(pT.y < pT.x) {\n        pId = floor(pr + floorPy.xz);\n        pT = pTm2.xy;\n    } else {\n        pId = 1. + floor(pr + floorPy.yz);\n        pT = pTm2.zw;\n    }\n    return vec4(pT,pId);\n}\nfloat cosa(in float x, in float y, in float w) { return cos((x/P)*y + w)*.5+.5; }\nfloat sq(in vec2 p, in float s, in float r) { return length(max(abs(p) - s,0.)) - r; }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = (fragCoord - .5*iResolution.xy )/iResolution.x;\n    float aa = 1./iResolution.x;\n    \n    st -= st*length(st)*.5;\n    float sz = 8.;\n    float t = iTime - 17.;\n    \n    st *= rot(P*.125 + .1*t);\n    vec2 p = st + vec2(t*.1,0.);\n    vec4 pT = tri(p*sz);\n    sz *= 1. + floor(rand(vec2(pT.zw))*15.);\n    pT = tri(p*sz);\n    \n    float taille = cosa(t,12.,pT.w*.25);\n    float d = (length(pT.xy) - taille/3.)/sz;\n    d = max(d,-sq(pT.xy*rot(P/8. + t*2. + pT.w),.2125*taille,.02)/sz);\n    float dd = (.3 - d*2.);\n    d = smoothstep(-aa,aa,-d) + dd;\n    \n    vec3 color = SpectrumPoly(rand(vec2(pT.zw))*.1 + mix(.2,.625, smoothstep(.46,.52,cosa(t + pT.w*.25,1.,0.)) ))*(dd*8.)*d;\n    \n    fragColor = vec4(pow(color - length(st)*length(st)*1.69,vec3(1.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3yRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 74, 97, 97, 161], [162, 162, 193, 238, 665], [666, 666, 688, 688, 733], [735, 735, 756, 756, 1255], [1256, 1256, 1304, 1304, 1337], [1338, 1338, 1383, 1383, 1424], [1426, 1426, 1481, 1481, 2254]]}
{"id": "wd3yWN", "name": "14 - Line grid waves v2", "author": "Krabcode", "description": "mouse xy: change wave frequency and direction", "tags": ["grid", "line", "sin", "rgb"], "likes": 7, "viewed": 112, "published": "Public", "date": "1600952012", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"11 - Line grid waves\" by Krabcode. https://shadertoy.com/view/WscyDn\n// 2020-09-24 12:13:10\n\n// Based on ideas from LiveCoding - The Universe Within by Art of Code\n// https://youtu.be/3CycKKJiwis\n\n// no code police beyond this line\n\n#define tau 6.28\n\nconst float scale = 12.;\nconst float centerSize = .75;\nvec2 uv;\n\nmat2 rotate(float rad){\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(c, -s, s, c);\n}\n\n// cubic pulse by iq\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\n// 2D sdf by iq\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n    q = mat2(d.x,-d.y,d.y,d.x)*q;\n    q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sdRoundedLine(in vec2 p, in vec2 a, in vec2 b, float weight, float roundedness){\n    return sdOrientedBox(p, a, b, weight)-roundedness;\n}\n\nfloat sdGridLine(vec2 cellPos, vec2 a, vec2 b){\n    float lineLength = distance(a,b);\n    float line = sdOrientedBox(cellPos, a, b, 0.);\n    float smallLength = 0.0;\n    float bigLength = 2.0;\n    float closeness = smoothstep(bigLength, smallLength, lineLength); \n    float thickness = 0.05;\n    return closeness*smoothstep(thickness, 0., line);\n}\n\n// Hash without Sine\n// David Hoskins.\n\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 getGridPoint(vec2 id){\n    float t = float(iFrame) * .01;\n    vec2 p = vec2(0);\n    vec2 mRaw = iMouse.xy / iResolution.xy;\n    vec2 m = (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n    if(length(mRaw) < 0.01){\n        vec2 defaultMouseValue = vec2(.2, -.5);\n        m = defaultMouseValue;\n    }\n    float center = .45*smoothstep(scale*centerSize, 0., length(id));\n    float wave = .75 * sin(id.x*3.*m.x + id.y*3.*m.y - t);\n    p.y += center * wave;\n\treturn p;\n}\n\nfloat allLinesOnThisCell(vec2 cellPos, vec2[9] points){\n \tfloat sum = 0.0;\n    sum = max(sum, sdGridLine(cellPos, points[4], points[0]));\n    sum = max(sum, sdGridLine(cellPos, points[4], points[1]));\n    sum = max(sum, sdGridLine(cellPos, points[4], points[2]));\n    sum = max(sum, sdGridLine(cellPos, points[4], points[3]));\n    sum = max(sum, sdGridLine(cellPos, points[4], points[5]));\n    sum = max(sum, sdGridLine(cellPos, points[4], points[6]));\n    sum = max(sum, sdGridLine(cellPos, points[4], points[7]));\n    sum = max(sum, sdGridLine(cellPos, points[4], points[8]));\n    sum = max(sum, sdGridLine(cellPos, points[1], points[3]));\n    sum = max(sum, sdGridLine(cellPos, points[1], points[5]));\n    sum = max(sum, sdGridLine(cellPos, points[3], points[7]));\n    sum = max(sum, sdGridLine(cellPos, points[5], points[7]));\n    return sum;\n}\n\nvec2[9] createPointMatrix(vec2 cellId){\n \tvec2[9] pointMatrix;\n    float range = 1.;\n    int i = 0;\n    for(float x = -range; x <= range; x++){\n        for(float y = -range; y <= range; y++){\n            vec2 offset = vec2(x,y);\n            pointMatrix[i] = getGridPoint(cellId + offset) + offset;\n            i++;\n        }\n    }   \n    return pointMatrix;\n}\n\nfloat render(vec2 uv){\n    float pct = 0.12;\n    vec2 cellPos = fract(uv * scale) - .5;    \n    vec2 cellId = floor(uv * scale) + .5;\n    vec2[9] pointMatrix = createPointMatrix(cellId);\n    float lines = allLinesOnThisCell(cellPos, pointMatrix);\n    float vignette = smoothstep(centerSize*1.5, centerSize, length(uv));\n    return lines*vignette;\n}\n\nvec3 gammaCorrection(vec3 rgb){\n    float gamma = 2.2;\n    rgb = smoothstep(0., 1., rgb);\n    return pow(max(rgb, 0.), vec3(1.0/gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tuv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 colorOffset = normalize(uv)*.0025*smoothstep(0.2, 0.5, length(uv));\n    vec3 col = vec3(\n        render(uv-colorOffset),\n        render(uv),\n        render(uv+colorOffset));\n    fragColor = vec4(gammaCorrection(col), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3yWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 328, 351, 351, 431], [433, 454, 501, 501, 595], [597, 613, 679, 679, 884], [886, 886, 972, 972, 1029], [1031, 1031, 1078, 1078, 1378], [1380, 1420, 1442, 1442, 1562], [1564, 1564, 1591, 1591, 2037], [2039, 2039, 2094, 2094, 2887], [3250, 3250, 3272, 3272, 3598], [3600, 3600, 3631, 3631, 3738], [3740, 3740, 3797, 3797, 4084]]}
{"id": "Wd3yz2", "name": "Question for you all", "author": "browric2", "description": "Hi guys,\n\nI've implemented a very simple raymarched truchet pattern based mostly off iq's raymarching primitives.\n\nIs anyone able to tell me why I am getting artefacts on my rounded blocks?\n\nThanks very much, I look forward to learning this cool skill :)", "tags": ["truchet", "noob", "question"], "likes": 6, "viewed": 107, "published": "Public", "date": "1601248315", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.1415926535897932384\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define speed 2.0\n\nfloat hash21(vec2 p) {\n    return fract(43758.5453123 * sin(dot(p, vec2(12.988, 243.233))+0.874539));\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\nmat3 rot(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);   \n    return mat3(c, 0., -s,0., 1.,0., s, 0.,c);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x, p.y)) - t.y;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos ) // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n{\n    vec3 lpos = vec3(fract(pos.x),pos.y,fract(pos.z))-0.5;\n    vec2 id = floor(pos.xz);\n    \n    vec2 rnd = hash22(id);\n    float rotam = floor(rnd.x*4.);\n    lpos *= rot(rotam * (pi/2.));\n    \n    vec2 mplane = vec2(sdPlane(pos), 8.0 );\n    float mtorus1 = sdTorus(lpos-vec3(0.5,-0.5,0.5),vec2(0.5,0.13));\n    float mtorus2 = sdTorus(lpos-vec3(-0.5,-0.5,-0.5),vec2(0.5,0.13));\n    \n    float mtorus3 = sdTorus(lpos-vec3(0.5,-0.35,0.5),vec2(0.5,0.06));\n    float mtorus4 = sdTorus(lpos-vec3(-0.5,-0.35,-0.5),vec2(0.5,0.06));\n\n\tvec2 subtorus1 = vec2(max(mtorus1,-mtorus3),40.0);\n  \tvec2 subtorus2 = vec2(max(mtorus2,-mtorus4),40.0);\n    \n    vec2 mroundbox = vec2(udRoundBox(lpos-vec3(0.,-0.5,0.),vec3(0.1,0.4,0.1),0.1),40.);\n\n    vec2 res = opU(mplane,subtorus1);\n    res = opU(res,subtorus2);\n    if (rnd.y > 0.95) res = opU(res,mroundbox);\n\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    tmax = 100.;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    \n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x; // distance\n\tfloat m = res.y; // material code\n    if( m > -0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd, nor); // reflected ray\n        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) ); // material        \n\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) ); // sunlight\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ); // diffuse reflection from sunlight\n        \n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    vec3 ro = vec3(3.0-iTime*speed,3.0,3.0 - iTime*speed*0.8);\n    vec3 ta = vec3( -0.5-iTime*speed, -0.4, 0.5 -iTime*speed*0.8);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    vec3 col = render( ro, rd );\n\n    col = pow( col, vec3(0.4545) );\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3yz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 119, 119, 200], [202, 202, 223, 223, 341], [344, 344, 367, 367, 471], [473, 473, 498, 498, 513], [515, 515, 550, 550, 576], [578, 578, 611, 611, 668], [670, 670, 715, 715, 757], [759, 759, 789, 789, 822], [824, 824, 897, 897, 1758], [1760, 1760, 1800, 1800, 2140], [2142, 2142, 2174, 2174, 2387], [2390, 2390, 2429, 2429, 3171], [3173, 3173, 3225, 3225, 3404], [3408, 3408, 3465, 3465, 3852]]}
{"id": "wd3yzf", "name": "Moving cutouts 2", "author": "AntoineC", "description": "A colored version of my previous shader: [url]https://www.shadertoy.com/view/wdtyRB[/url]", "tags": ["minimalist"], "likes": 15, "viewed": 161, "published": "Public", "date": "1601402144", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ----------------------------------------------------------------------------------------\n//\t\"Moving Cutouts 2\" by Antoine Clappier - Sep 2020\n//\n//\tLicensed under:\n//  A Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n//\thttp://creativecommons.org/licenses/by-nc-sa/4.0/\n// ----------------------------------------------------------------------------------------\n\n#define Rot(a)   mat2(cos(a),sin(a),-sin(a),cos(a))\n\n\n//   Dave Hoskins hash functions\n//   https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx+19.19);\n    return -1.0+2.0*fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\n//  IQ's Gradient Noise 2D\n//  https://www.shadertoy.com/view/XdXGW8\nfloat Noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat Distance(vec2 uv, float radius, float id)\n{\n    return length(uv) - radius + 0.12*Noise(2.0*uv+id+2.0);\n}\n\n\nvec2 Cutout(vec2 uv, float radius, float id, float eps)\n{\n    vec2  shadowTransl = 0.05*vec2(-1.0,1.0);\n    float shadowRadius = 0.11;\n    \n    float mask   = smoothstep(0.0, eps, Distance(uv, radius, id));\n    float shadow = (1.0-0.65*smoothstep(-shadowRadius, shadowRadius, Distance(uv+shadowTransl, radius, id)));\n    \n    return vec2(mask, shadow);\n}\n\n\nfloat Paper(vec2 uv)\n{\n    uv *= 2.0;\n    \n    float   g;\n    g  = texture(iChannel0, uv*vec2(1.0,0.01)).r;\n    g *= texture(iChannel0, uv*vec2(0.01,1.0)).r;\n    g  = 0.7*g +texture(iChannel0, 0.5*uv).r;\n    return  g;\n}\n\n\nvec3 Bump(vec2 uv, float eps)\n{\n    vec2   delta = vec2(eps, 0.0);\n    float  a     = Paper(uv);\n    float  b     = Paper(uv + delta.xy);\n    float  c     = Paper(uv + delta.yx);\n    \n    vec3   n     = normalize(vec3(b-a, c-a, 7.5));\n \n    return n;\n}\n\n\nvec3 Shade(vec3 col, vec2 uv, float r, float a, vec3 color, float eps)\n{\n    // Get mask and shadow:\n\tvec2 ms = Cutout(uv, 1.07*r, a, eps);\n\n    // Paper bump;\n    vec3  normal  = Bump(uv*Rot(a), eps);\n    vec3  dif     = color*dot(normal, vec3(1.0));\n\n    // Highlight cutout borders:\n    float border  = 0.15*smoothstep(0.005+eps, 0.0, Distance(uv, 1.07*r, a));\n    dif          += border*(uv.x-uv.y);\n    \n    // Apply shadow:\n    col = mix(0.57*vec3(0.04, 0.12, 0.18), col, ms.y);\n    \n    // Apply masked texture:\n    col = mix(col, dif, ms.x);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized coordinates:\n\tfloat eps = 2.0/iResolution.y;\n\tvec2  uv  = eps*(fragCoord - 0.5*iResolution.xy);\n    float t   = iTime;\n\n\t// Render:\n\tvec3 col = vec3(mix(0.99, 0.93, texture(iChannel1, 2.0*uv).r));\n\n    col = Shade(col, uv-vec2(-0.033*cos(t+2.3), 0.000           ), 0.50, 4.0, vec3(0.65, 0.86, 0.53), eps);\n    col = Shade(col, uv-vec2( 0.000,            0.035*sin(t+2.0)), 0.55, 1.0, vec3(0.86, 0.49, 0.49), eps);\n    col = Shade(col, uv-vec2( 0.033*sin(t+1.3),-0.033*cos(t+1.3)), 0.61, 2.0, vec3(0.69, 0.80, 0.89), eps);\n    col = Shade(col, uv-vec2(-0.036*cos(t+1.0), 0.000           ), 0.67, 3.0, vec3(0.89, 0.65, 0.43), eps);\n    col = Shade(col, uv,                                           0.74, 0.0, vec3(0.8), eps);\n    \n    // Grading:\n \tcol *= smoothstep(2.2, 0.7, length(uv));\n    col += smoothstep(-0.3, 1.0, uv.x-uv.y)*vec3(255.,201.,14.)*0.00020;\n    col *= step(abs(uv.x), 1.0);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3yzf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-4.0", "functions": [[454, 530, 551, 551, 700], [703, 772, 798, 798, 1201], [1204, 1204, 1253, 1253, 1315], [1318, 1318, 1375, 1375, 1672], [1675, 1675, 1697, 1697, 1895], [1898, 1898, 1929, 1929, 2150], [2153, 2153, 2225, 2253, 2725], [2727, 2727, 2784, 2812, 3728]]}
{"id": "Wd3yzs", "name": "motion blur 4", "author": "FabriceNeyret2", "description": "stop to see temporal anti-aliasing.\nClick for no temporal AA.", "tags": ["motionblur"], "likes": 9, "viewed": 280, "published": "Public API", "date": "1601477512", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 15. * u /R.y,  A;\n\n    float i = floor(U.x);                     // column id\n    U.x = fract(U.x);                         // local coords\n    U.y += 2.*i* iTime;                       // box i falls at speed 2i\n    U.y += 15.*fract(1e4*sin(1e4*i));         // randomize col phase\n    float j = floor( mod( U.y, 15.) *4./15.), // row\n          r = mod(j,2.)<1. ? .4 : .1;         // box radius\n    U.y = mod( U.y, 15./4. );               \n    \n    A =  15./R.yy;                            // spatial AA\n    if (iMouse.z<=0.)\n        A += vec2( 0, 2.*i * iTimeDelta );    // temporal AA\n    \n    U = abs(U-vec2(.5,2.5));                  // --- renders AAbox\n    U = smoothstep( .7*A, -.7*A, U - r );\n    O = vec4( U.x*U.y ); // vec4( min(U.x,U.y) );\n\n    O = pow(O, vec4(1./2.2) );                // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3yzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 894]]}
{"id": "wdccRB", "name": "progression", "author": "neriakX", "description": "just toying around ... heavily inspired by evvvvil's work. still work in progress.", "tags": ["raymarching", "learning"], "likes": 11, "viewed": 107, "published": "Public", "date": "1601150159", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// inspired by evvvil's ray marching videos on twitch <3\n\nconst float FOV=.55;\nconst int ITER=128;\nconst float PI=acos(-1.);\nconst float TAU=PI*2.;\n\nfloat t,tt,st;\nvec2 sc;\nvec3 np, no, al, po, ld, ro;\n\nfloat ssub( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5*(b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h*(1.0 - h);\n}\n\n// rotation function\nmat2 r2 (float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\n//sphere\nfloat sp(vec3 p, float r) { return length(p)-r; }\n\n//diamond\nfloat di (vec3 p, float s) \n{\n    float lx = length(p.x);\n    float ly = length(p.y);\n    float lz = length(p.z);\n    return sqrt(lx+ly+lz)-s;   \n}\n\n// octahedron\nfloat oh ( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n// the thing\nvec2 bs (vec3 p)\n{   \n    np=p;\n    for(int i=0;i<5;i++) { // let'S clone and rotate stuff\n        np=abs(np)-vec3(2.,2.5,1.5);\n        np.xy *= r2(1.3+cos(tt*.5));\n        np.y -= 1.6*.5+sin(tt*.5);\n        np.xz *=r2(tt*.25);     \n    }\n    vec2 h,t=vec2(oh(np,2.3),10.); // octahedron iq\n    //vec2 h,t=vec2(di(np,1.5),10.); // my diamond\n    h=vec2(sp(np,1.45),5.); // mix with blue sphere\n    t=(t.x<h.x)?t:h;\n    t.x*=0.7; // reduce artifacts\n    return t;\n}\n\n\n// lighting\nfloat li (vec3 n, vec3 l)\n{\n  return max(0., dot(n, l));\n}\n\n// Camera\n vec3 cam (vec3 ro, vec2 uv, float fov)\n{\n    vec3 cw=normalize(vec3(0.)-ro),\n        cu=normalize(cross(cw, vec3(0.,1.,0.))),\n        cv=normalize(cross(cu,cw));\n    return mat3(cu,cv,cw)*normalize(vec3(uv,FOV));\n} \n\n// the scene\nvec2 mp (vec3 p) \n{   \n    p.xy*=r2((p.z-ro.z)*st*0.1);\n    vec2 h,t=bs(p);\n    t.x=max(t.x,-0.5*(length(p-ro)-2.)); // stopping our camera from colliding with things    \n    return t;\n}\n\n// main raymarching function\nvec2 tr (vec3 ro, vec3 rd) \n{\n    vec2 h,t=vec2(0.1);\n    for(int i=0;i<ITER;i++){\n        h=mp(ro+rd*t.x);\n        if(h.x<.0001||t.x>30.) break;\n        t.x+=h.x;t.y=h.y;\n    }\n    if (t.x>30.) t.x=0.;\n    return t;\n}\n\n// get Normals (iq)\nvec3 calcNormal( in vec3 po )\n{   \n    vec2 e=vec2(.00035,-.00035);\n    return normalize(e.xyy*mp(po+e.xyy).x+\n        e.yyx*mp(po+e.yyx).x+\n        e.yxy*mp(po+e.yxy).x+\n        e.xxx*mp(po+e.xxx).x); \n}\n\n// AO\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.) \n// SSS\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(gl_FragCoord.xy / iResolution.xy);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    tt=mod(iTime,100.);\n\tst=clamp(cos(tt),0.,1.); \n      \n    // ray_origin / camera\n    ro = vec3(0.,3.+sin(tt),17.+cos(tt*.5)); //ray origin\n    \n    vec3 rd=cam(ro,uv,FOV),\n    co,fo,ld=normalize(vec3(0.,0.,10.));\n    co=fo=vec3(0.55,0.22,0.05)-rd.y*.4;\n      \n    sc=tr(ro,rd); // sc.x = distance geometry, sc.y = colour\n    t=sc.x; // t is the result of the geometry\n    \n    if (t>0.) \n    {   \n        po=ro+rd*t;\n        vec3 no=calcNormal(po),\n        al=mix(vec3(0.,0.10,0.45),vec3(0.1,0.30,0.55),.5); // albedo\n     \n        // Material colouring\n        if(sc.y<5.) al=vec3(0.);\n        if(sc.y>5.) al=vec3(1.);\n        if(sc.y>9.) al=vec3(0.8, 0.3, 0.01);\n        \n        float dif=li(no,ld), // diffuse\n        fr=pow(1.+dot(no,rd),4.), // fresnel\n        sp=pow(max(dot(reflect(-ld,no),-rd),0.),55.); // specular by shane.\n        co=mix(sp+al*(a(.1)*a(.3)+.2)*(vec3(1.)*dif+s(.5)*1.5),fo,min(fr,.5)); // final lights\n        co=mix(co,vec3(0.12,0.03,0.01),1.-exp(-0.00015*t*t*t)); // add fog\n        \n        // Subtle vignette by Shane\n        uv = fragCoord/iResolution.xy;\n        co = mix(vec3(0.),co,pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),.125)*.5 +.5);\n          \n        \n    }\n    \n    fragColor = vec4(pow(co,vec3(0.45)),1.); // add gamma correction\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdccRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 203, 247, 247, 348], [350, 350, 389, 389, 488], [490, 511, 530, 530, 578], [580, 589, 616, 616, 638], [640, 650, 679, 679, 797], [799, 813, 842, 842, 895], [897, 910, 928, 928, 1374], [1377, 1389, 1416, 1416, 1447], [1449, 1460, 1500, 1500, 1674], [1677, 1690, 1709, 1709, 1876], [1878, 1907, 1936, 1936, 2125], [2127, 2147, 2178, 2178, 2351], [2402, 2457, 2514, 2514, 3913]]}
{"id": "WdccRX", "name": "Cornell Box FDGI", "author": "JacobC", "description": "Faking IL\nI think everyone must do a Cornell box scene once in their life\nA simple scene of the famous Cornell box to test color bleeding for diffuse objects\nMove camera with mouse by clicking the screen", "tags": ["3d", "raymarching", "diffuse"], "likes": 11, "viewed": 150, "published": "Public", "date": "1601487110", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * \"Cornell Box FDGI\" by Jacob Ceron aka JacobC - 2020\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: jacobceron6@gmail.com\n */\n\n/*\nJust doing a simple color accumulation from sphere tracing that you can find it in function uop\nmarked with a comment that says: \"Fake IL\".\nAlso because i wanted to watch it on my phone\n*/\n\n// Change to 1. if runs slow\n#define AA 2.\n\n#define Pi 3.141592\n#define T iTime\n\n// Background light\n#define gd vec3(3.) * clamp(sin(T * .25) * 2., 0., 1.)\n#define sk vec3(1.5, 2., 3.) * clamp(sin(T * .25) * 2., 0., 1.)\n\n// Light Pos and color\n#define l0 vec3(0., 6., 0.)\n#define lc vec3(1., .8, .6)\n\nstruct mat\n{\n    float z;\n    vec3 c;\n    float ao;\n    vec3 i;\n    bool e;\n};\n\nfloat disk(in vec3 p, in vec2 r)\n{   \n    return length(vec2(max(length(p.xz) - r.x + r.y, 0.), p.y)) - r.y;\n}\n    \nfloat plane(in vec3 p, in vec2 s, float r)\n{\n    p.xy = max(abs(p.xy) - s, 0.);\n    return length(p) - r;\n}\n    \nfloat cube(in vec3 p, in vec3 s, float k)\n{\n    p = abs(p) - (s - k);\n    return length(max(p, 0.)) - k;\n}\n\nfloat sphere(in vec3 p, float k)\n{\n    return length(p) - k;\n}\n\nfloat map(float i, float c, float l, float q)\n{\n    return 1. - 1. / (c + l * i + q * i * i);\n}\n\nmat uop(in mat a, in mat b)\n{\n    float s = max(a.z, b.z);\n    float ao = map(s, 1.5, 5.6, 14.4);\n    return mat\n        (\n            min(a.z, b.z),\n            a.z < b.z ? a.c : b.c,\n            a.ao * ao, // Fake AO from: https://www.shadertoy.com/view/ttXfWX\n            a.i * mix(a.z > b.z ? a.c : b.c, vec3(1.), map(s, 1., .01, .002)), // Fake IL\n            a.z < b.z ? a.e : b.e\n        );\n}\n\nmat uope(in mat a, in mat b)\n{\n    return mat\n        (\n            min(a.z, b.z),\n            a.z < b.z ? a.c : b.c,\n            a.ao, // Fake AO from: https://www.shadertoy.com/view/ttXfWX\n            a.i, // Fake IL\n            a.z < b.z ? a.e : b.e\n        );\n}\n\nmat scene(in vec3 p)\n{    \n    // Sphere\n    vec3 pp = p;\n    float a;\n    pp -= vec3(sin(T), cos(T), 1.) * 4.;\n    mat p0 = mat(sphere(pp, 2.), vec3(3., 0., 1.5) / Pi, 1., vec3(1.), false);\n    \n    // Right wall\n    pp = p;\n    a = -90. * Pi / 180.;\n    pp.xz *= mat2(cos(a), sin(a), -sin(a), cos(a));\n    pp.z -= 6.;\n    mat p1 = mat(plane(pp, vec2(6.), .0), vec3(0., 1.5, 3.) / Pi, 1., vec3(1.), false);\n    \n    // Left wall\n    pp = p;\n    pp.xz *= mat2(cos(a), sin(a), -sin(a), cos(a));\n    pp.z += 6.;\n    mat p2 = mat(plane(pp, vec2(6.), .0), vec3(3., 1.5, 0.) / Pi, 1., vec3(1.), false);\n    \n    // Prism\n    pp = p;\n    pp -= -2.;\n    a = -45. * Pi / 180.;\n    pp.xz *= mat2(cos(a), sin(a), -sin(a), cos(a));\n    mat p3 = mat(cube(pp, vec3(2., 4., 2.), 0.), vec3(3.) / Pi, 1., vec3(1.), false);\n    \n    // Front wall\n    pp = p;\n    pp.z += 6.;\n    mat p4 = mat(plane(pp, vec2(6.), .0), vec3(3.) / Pi, 1., vec3(1.), false);\n    \n    // Ceiling\n    pp = p;\n    pp.y -= 6.;\n    mat p5 = mat(plane(pp.xzy, vec2(6.), .0), vec3(3.) / Pi, 1., vec3(1.), false);\n    \n    // Floor\n    pp = p;\n    pp.y += 6.;\n    mat p6 = mat(plane(pp.xzy, vec2(6.), .0), vec3(3.) / Pi, 1., vec3(1.), false);\n    \n    // Light source\n    mat pl = mat(disk(p - l0, vec2(2., 0.)), vec3(1.) / Pi, 1., vec3(1.), true);\n    \n    mat q = uop(p0, p1);\n    q = uop(q, p2);\n    q = uop(q, p3);\n    q = uop(q, p4);\n    q = uop(q, p5);\n    q = uop(q, p6);\n    // Doesn't take in account AO or bleeding for Emissive\n    q = uope(q, pl);\n    \n    return q;\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 e = vec2(.001, .0);\n    float d = scene(p).z;\n    return normalize(d - vec3(scene(p - e.xyy).z, scene(p - e.yxy).z, scene(p - e.yyx).z));\n}\n\n#define STEPS 255\n#define MIN_S .01\n#define MAX_S 32.\n\nmat marcher(in vec3 o, in vec3 d)\n{\n    float t = 0.;\n    for (int i = 0; i < STEPS; i++)\n    {\n        mat s = scene(o + d * t);\n        t += s.z * .7;\n        if (s.z < MIN_S)\n            return mat(t, s.c, s.ao, s.i, s.e);\n        if (t > MAX_S)\n            break;\n    }\n    return mat(t, vec3(-1.), -1., vec3(-1.), false);\n}\n\n// Soft shadows: https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n#define SSTEPS 255\n#define OFF .1\nfloat shadow(in vec3 o, in vec3 d, float k)\n{\n    float t = 0.;\n    float ms = 1.;\n    for (int i = 1; i <= SSTEPS; i++)\n    {\n        mat s = scene(o + d * t);\n        ms = min(ms, s.z / float(i) * k);\n        t += s.z * OFF; // multiply it by a number less than 1 to remove acne\n        if (s.e)\n            break;\n        if (s.z < MIN_S)\n            return 0.;\n    }\n    return ms;\n}\n\nvec3 camera(in vec2 p, in vec3 o, in vec3 t)\n{\n    vec3 w = normalize(o - t);\n    vec3 u = normalize(cross(vec3(0., 1., 0.), w));\n    vec3 v = cross(w, u);\n    return p.x * u + p.y * v - w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord;\n    vec3 fc;\n    \n    for (float y = 0.; y < AA; y++)\n    {\n        for (float x = 0.; x < AA; x++)\n        {\n            vec2 n = vec2(x, y) / AA - .5;\n            vec2 uv = (st + n - iResolution.xy * .5) / iResolution.y;\n            vec2 ms = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n\n            float a = 0.;\n            vec3 o = (iMouse.z > 0. ? vec3(sin(ms.x), ms.y, cos(ms.x)) : vec3(0., 0., 1.)) * 18.;\n            vec3 d = camera(uv, o, vec3(0., 0., 0.));\n            vec3 bg = mix(gd, sk, d.y * .5 + .5);\n            vec3 col;\n\n            mat m = marcher(o, d);\n            if (m.ao != -1.)\n            {\n                if (!m.e)\n                {\n                    vec3 p = o + d * m.z;\n                    vec3 n = normal(p);\n                    bg = mix(gd, sk, n.y * .5 + .5);\n\n                    vec3 l = l0 - p;\n                    vec3 ld0 = normalize(l);\n                    float att = 1.-map(length(l), 1., .02, .001);\n                    float sh = shadow(p + n * .1, ld0, 255.);\n                    vec3 diff = max(dot(ld0, n), 0.) * lc * att * sh + (m.ao / Pi * m.i);\n                    vec3 ambi = bg * m.ao / Pi * m.i;\n\n                    vec3 all_l = ambi + diff;\n\n                    col += all_l * m.c;\n                }\n                else\n                    col += 1.;\n            }\n            else\n                col += bg / Pi;\n            fc += col;\n        }\n    }\n\n    fc /= AA * AA;\n    \n    fragColor = vec4(sqrt(fc), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdccRX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[598, 758, 792, 792, 868], [874, 874, 918, 918, 981], [987, 987, 1030, 1030, 1093], [1095, 1095, 1129, 1129, 1157], [1159, 1159, 1206, 1206, 1254], [1256, 1256, 1285, 1285, 1655], [1657, 1657, 1687, 1687, 1922], [1924, 1924, 1946, 1964, 3457], [3459, 3459, 3483, 3483, 3632], [3689, 3689, 3724, 3724, 4017], [4019, 4130, 4175, 4175, 4517], [4519, 4519, 4565, 4565, 4710], [4712, 4712, 4769, 4769, 6278]]}
{"id": "wdcyWn", "name": "StrobingSphere", "author": "antoinefortin", "description": "dsffds", "tags": ["fsdfd"], "likes": 3, "viewed": 75, "published": "Public", "date": "1600725407", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = (fragCoord - .5 * iResolution.xy) /iResolution.y;uv.y = abs(uv.y);\n    vec2 st = vec2(atan(uv.x * (sin(iTime * cos(iTime + sin(iTime  * .25)))), uv.y), length(uv));\n uv.x = abs(uv.x * 12.\n           );   \n uv = st; \n\n    float x = uv.x * cos(uv.y + 1.);\n    float m = max(fract(x), fract(sin(uv.y * iTime * 5.) * cos(iTime * uv.x * uv.y)));\n    float ma = max(fract(m * x), fract(sin(uv.y * 5.) * sin(m * uv.y)));\n   \tvec3 col = st.xxx / (12.1417 * 2.) + .5;\n\tcol = vec3(m * length(st * sin(iTime)), fract(ma * m), m + uv.y);\n    vec3 ttreh= vec3(1.25) * col * abs(uv.y * uv.x);\n    fragColor = vec4(sqrt(ttreh) *ttreh,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcyWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 696]]}
{"id": "Wdcyz7", "name": "Screensaver squares", "author": "julianlumia", "description": "small change after following the tutorial by bigwings", "tags": ["tutorial"], "likes": 12, "viewed": 120, "published": "Public", "date": "1600618738", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//full credits to BigWings:\n//https://www.youtube.com/watch?v=rvDo9LvfoVE\n\n#define NUM_LAYERS 3.\n\n\nfloat Hash21(vec2 p){\n   p = fract (p*vec2(123.34,456.21));\n   p+= dot(p,p+45.32);\n    return fract(p.x*p.y);\n    }\n\n\nmat2 Rot(float a){\n    \n float s = sin(a), c= cos(a);\n   return mat2(c,-s,s,c); \n}\nfloat star(vec2 uv){\n    float d = length(uv);\n    float m = .1/d;\n    m *= smoothstep(1.,.01,d);\n\treturn m;\n}\n\nvec2 GetPos(vec2 id, vec2 offs){\n    \t\tfloat n = Hash21(id+offs);\n    return offs+sin(n)*3.;\n}\n\n\nvec3 StarLayer( vec2 uv){\t\n    vec3 col = vec3(0);\n \tvec2 id = floor(uv)-0.5;\n\n    for(int y = -1; y<=1; y++){\n  \t\tfor(int x = -1; x<=1; x++){\n\t\t    vec2 offs = vec2(x,y);\n    \t\tfloat n = Hash21(id+offs);\n    \t\tfloat size = fract(n*545.32);\n\t\t\n            \n             float star=  star(GetPos(id,offs));\n\t\t\tvec3 color =sin(vec3(1.,0.2,0.9)*fract(n*2345.2)*123.2)*.5+.5;\n            color= color*vec3(1.,1.,.5+size);\n  \t\t    star*=sin(iTime*2.+n*6.2831)*.5+1.;\n \t\t    col+= star*size*color;\n\n  \t\t}\n    }\n\n return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    uv*=1.;\n    float t = iTime*.05;\n    float move = t*3.; \n    uv+= vec2(cos(move),sin(move));\n    \n    uv *= Rot(t);\n      vec3 col = vec3(0.);\n    \n    \n    for (float i=0.; i<1.; i+=1./NUM_LAYERS){\n        float depth = fract(i+t);\n  \t\tfloat scale = mix(20.,.5, depth);\n        float fade = depth*smoothstep(1.,.9,depth);\n        col += StarLayer(uv*scale+i*453.2-move)*fade;\n    }\n \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdcyz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 99, 120, 120, 214], [217, 217, 235, 235, 299], [300, 300, 320, 320, 410], [412, 412, 444, 444, 506], [509, 509, 534, 534, 1029], [1032, 1032, 1089, 1089, 1578]]}
{"id": "wdcyzf", "name": "cherry blossom ribbon", "author": "jemappelle", "description": "lots of leftover code, need to optimize", "tags": ["raymarching"], "likes": 2, "viewed": 227, "published": "Public API", "date": "1601400759", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uniform float zMotion;\nuniform float lowFreqFFT;\nuniform float midFreqFFT;\nuniform float highFreqFFT;\n\nfloat opSubtract(float o0, float o1){return max(-o0,o1);}\n\nfloat opIntersection(float o0, float o1){return max(o0,o1);}\n\nfloat diffuse_directional(vec3 n, vec3 l){\n  \treturn dot(n, normalize(l))*.5 + .5;\n}\n\nfloat sphere(vec3 d, float r){\n  \t//d = mod(d, 2.)-2*0.5;  \n  \treturn length(d)-r;\n}\n\nfloat sdRoundedX(in vec2 d, in float w, in float r ){\n   \td = abs(d);\n   \treturn length(d-min(d.x+d.y,w)*0.5) - r;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h ){\n  \tconst vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  \tp = abs(p);\n  \tp.xy -= 2.0*min(dot(k.xy, p.xy), .0)*k.xy;\n  \tvec2 d = vec2(\n   \tlength(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),p.z-h.y );\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hexMap(vec3 d){\n    d = mod(d, 2.)-2.*0.5;  \n  \treturn opIntersection(-sdHexPrism(d, vec2(0.6, 1.0)), sdHexPrism(d, vec2(0.61, 1.)));\n}\n\nfloat map(vec3 d){\n  \td = mod(d, 2.)-2.*0.5;  \n  \treturn mix(sdRoundedX(d.xy, 0.3, 0.12), (sphere(d, 0.4)), cos(iTime*0.8*0.8));\n}\n\nvec3 get_normal(vec3 p){\n  \tvec2 eps = vec2(0.01,0.);\n  \treturn normalize(vec3(map(p+eps.xyy) - map(p-eps.xyy),\n    map(p+eps.yxy) - map(p-eps.yxy),  \n    map(p+eps.yyx) - map(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    uv/=vec2(iResolution.y/iResolution.x, 1);\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*sin(iTime+uv.xyx+vec3(0,2,4));\n \tfloat circle = smoothstep(0.05*uv.y, 0.5,length(uv.x));\n  \n  \tvec3 ro = vec3(0.+cos(iTime)/2.,zMotion,-8.+(iTime*4.)); \n  \tvec3 p = ro;\n  \tvec3 rd = normalize(vec3(uv,1.));\n    //vec3 rd = normalize(vec3(uv,shapeColour));\n  \n  \tbool hit = false;\n  \tbool hit2 = false;\n  \tfloat shading = 0.;\n  \n  \tfor(float i = 0.; i < 15.; i++){\n    \tfloat env = map(p);\n    \tfloat hex = hexMap(p);\n    \tif(env<0.01){\n      \t\thit = true;\n      \t\tshading = i/100.;\n      \t\tbreak;\n    \t}\n    \tp += env * sin(rd-ro/50.);\n    \t//p += env * rd + hex+iTime/100.;\n  \t}\n \n  \n  \t//Waving screen\n  \tuv.x += sin(uv.y*8.5)*0.1;\n  \tuv.y += sin(uv.x*8.5+iTime)*0.5;\n  \t//Screen split\n  \tuv.x = mod(uv.x, 0.1)-0.2*0.5;\n  \n  \t//Shape\n  \tfloat verLine = smoothstep(0.1, 0.8,length(uv.y-circle));\n  \n  \t//Color define\n  \tvec3 color = vec3(0.);\n  \n  \n  \t//Color from raymarch\n  \tif(hit){\n    \tvec3 n = get_normal(p);\n    \tvec3 l = vec3(0.5,2.,-2.);\n    \tcolor = get_normal(p) + vec3(shading);\n        \n        //Colour as static\n        //color = mix(vec3(0.8,0.05,0.2), vec3(0.1,0.0,0.0), vec3(diffuse_directional(n,l)));\n        \n        //Colour with uniform\n        color = mix(vec3(lowFreqFFT,0.,0.), vec3(0.1,0.0,0.0), vec3(diffuse_directional(n,l)));\n    \t\n        hit = false;\n  \t}else if(hit2){\n    \tvec3 n = get_normal(p);\n    \tvec3 l = vec3(0.5,2.,-4.);\n    \tcolor = get_normal(p) + vec3(shading);\n    \tcolor = mix(vec3(0.65,0.65,0.7), vec3(0.1,0.0,0.0), mix(vec3(0.65,0.45,0.7), vec3(circle-verLine),\n    \tvec3(diffuse_directional(n,l))));\n    \thit2 = false;\n  \t}else{\n    \t//color = vec3(circle - verLine/shading);\n    \tcolor = vec3(circle -= atan(verLine)*iTime);\n  \t}\n  \tfloat t = length(ro*p);\n  \t//is final output for now\n  \tvec3 fog = mix(color, vec3(0.1,0.1,0.2), 1.*exp(-0.01*t*t));\n    \n  \tfragColor = vec4(fog, 0.1) + vec4((color + circle / 1.5), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcyzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 140, 140, 160], [162, 162, 203, 203, 222], [224, 224, 266, 266, 308], [310, 310, 340, 369, 394], [396, 396, 449, 449, 512], [514, 514, 549, 549, 815], [817, 817, 838, 838, 958], [960, 960, 978, 978, 1090], [1092, 1092, 1116, 1116, 1283], [1285, 1285, 1342, 1389, 3418]]}
{"id": "wddcDr", "name": "12 - Atmosphere", "author": "Krabcode", "description": "fake 3D clouds and fake rayleigh scattering", "tags": ["noise", "fbm", "planet", "perspective"], "likes": 5, "viewed": 104, "published": "Public", "date": "1600784419", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159\n#define time float(iTime)*0.1\n\n// hexToRgb from here: https://stackoverflow.com/questions/22895237/hexadecimal-to-rgb-values-in-webgl-shader\nvec3 hexToRgb(int color)\n{\n    float rValue = float(color / 256 / 256);\n    float gValue = float(color / 256 - int(rValue * 256.0));\n    float bValue = float(color - int(rValue * 256.0 * 256.0) - int(gValue * 256.0));\n    return vec3(rValue / 255.0, gValue / 255.0, bValue / 255.0);\n}\n\n// noise by iq\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat iqNoise(vec3 x){\n    // The noise function returns a value in the range -1.0f -> 1.0f\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f  = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+0.0), hash(n+1.0), f.x),\n    mix(hash(n+57.0), hash(n+58.0), f.x), f.y),\n    mix(mix(hash(n+113.0), hash(n+114.0), f.x),\n    mix(hash(n+170.0), hash(n+171.0), f.x), f.y), f.z);\n}\n\nfloat fbm(vec2 p){\n    float sum = 0.;\n    float freq = 1.;\n    float amp = 0.5;\n    for (int i = 0; i < 6; i++){\n        sum += amp*(1.-2.*iqNoise(vec3(p*freq, 0.)));\n        freq *= 2.0;\n        amp *= .5;\n    }\n    return sum;\n}\n\nfloat fbm(vec3 p){\n    float sum = 0.;\n    float freq = 1.;\n    float amp = 0.5;\n    for (int i = 0; i < 6; i++){\n        sum += amp*(1.-2.*iqNoise(p*freq));\n        freq *= 2.0;\n        amp *= .5;\n    }\n    return sum;\n}\n\n\n// cubic pulse by iq\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\n// perspective code by nking\nvec3 perspective(vec2 uv){\n    float distanceFromPlane = 0.5;\n    vec3 dir = vec3(uv, distanceFromPlane);\n    if (dir.y != 0.0){\n        dir /= abs(dir.y);\n    }\n    return dir;\n}\n\nvec3 render(vec2 uv, vec3 persp){\n    float topHalf = sign(uv.y);\n    float botHalf = 1.-topHalf;\n    float p = 1.-abs(uv.y)*.5;\n    float bg = pow(max(p, .49*botHalf), 50.);\n    float fg = .01 + 0.5*botHalf*fbm(vec3(persp.x, persp.z+time, .5*time));\n    return vec3(bg*vec3(0.4,0.6,1) + botHalf*clamp(fg,0.,1.));\n    \n}\n\nvec3 gammaCorrection(vec3 rgb){\n    float gamma = 2.2;\n        \n\trgb = smoothstep(0., 1., rgb);\n    return pow(max(rgb, 0.), vec3(1.0/gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv.y -= .1*cos(uv.x)-.05;\n    vec3 col = render(uv, perspective(uv));\n    fragColor = vec4(gammaCorrection(col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddcDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 160, 186, 186, 444], [446, 461, 482, 482, 521], [523, 523, 545, 614, 937], [939, 939, 957, 957, 1170], [1172, 1172, 1190, 1190, 1393], [1396, 1417, 1464, 1464, 1558], [1560, 1589, 1615, 1615, 1768], [1770, 1770, 1803, 1803, 2090], [2092, 2092, 2123, 2123, 2236], [2238, 2238, 2295, 2295, 2478]]}
{"id": "WddczB", "name": "circle move", "author": "lck898989", "description": "a demo of circle move used by sin and cos", "tags": ["circlemove"], "likes": 0, "viewed": 33, "published": "Public", "date": "1601200559", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tuv: position of picture\n\tpos: circle position\n\n**/\nfloat circle(vec2 uv,vec2 pos,float radius,float blurDis) {\n    float c;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float dis = length(uv - pos);\n    \n    c = smoothstep(radius,radius - blurDis,dis);\n    return c;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    float radius = 0.3;\n    \n    \n    float y = 0.5 * sin(uv.y + iTime);\n    float x = 0.5 * cos(uv.x + iTime);\n    \n    vec2 p = vec2(x,-y);\n    \n    float c = circle(uv,p,radius,0.1);\n    \n    \n    // Output to screen\n    fragColor = vec4(vec3(c),1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddczB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 55, 114, 114, 299], [300, 300, 357, 407, 713]]}
{"id": "wddyWN", "name": "Raymarching with PBR", "author": "RodzLabs", "description": "This shader was generated using Material Maker.", "tags": ["raymarching", "generated", "pbr"], "likes": 1, "viewed": 108, "published": "Public", "date": "1600976168", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//---\n\nfloat rand(vec2 x) {\n    return fract(cos(dot(x, vec2(13.9898, 8.141))) * 43758.5453);\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t  dot(x, vec2(3.4562, 17.398)))) * 43758.5453);\n}\n\nvec3 rand3(vec2 x) {\n    return fract(cos(vec3(dot(x, vec2(13.9898, 8.141)),\n                          dot(x, vec2(3.4562, 17.398)),\n                          dot(x, vec2(13.254, 5.867)))) * 43758.5453);\n}\n\nvec3 rgb2hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat rand31(vec3 p) {\n\treturn fract(sin(dot(p,vec3(127.1,311.7, 74.7)))*43758.5453123);\n}\nvec3 rand33(vec3 p){\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat tex3d_fbm_value(vec3 coord, vec3 size, float seed) {\n\tvec3 o = floor(coord)+rand3(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec3 f = fract(coord);\n\tfloat p000 = rand31(mod(o, size));\n\tfloat p001 = rand31(mod(o + vec3(0.0, 0.0, 1.0), size));\n\tfloat p010 = rand31(mod(o + vec3(0.0, 1.0, 0.0), size));\n\tfloat p011 = rand31(mod(o + vec3(0.0, 1.0, 1.0), size));\n\tfloat p100 = rand31(mod(o + vec3(1.0, 0.0, 0.0), size));\n\tfloat p101 = rand31(mod(o + vec3(1.0, 0.0, 1.0), size));\n\tfloat p110 = rand31(mod(o + vec3(1.0, 1.0, 0.0), size));\n\tfloat p111 = rand31(mod(o + vec3(1.0, 1.0, 1.0), size));\n\tvec3 t = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(mix(p000, p100, t.x), mix(p010, p110, t.x), t.y), mix(mix(p001, p101, t.x), mix(p011, p111, t.x), t.y), t.z);\n}\n\nfloat tex3d_fbm_perlin(vec3 coord, vec3 size, float seed) {\n\tvec3 o = floor(coord)+rand3(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec3 f = fract(coord);\n\tvec3 v000 = normalize(rand33(mod(o, size))-vec3(0.5));\n\tvec3 v001 = normalize(rand33(mod(o + vec3(0.0, 0.0, 1.0), size))-vec3(0.5));\n\tvec3 v010 = normalize(rand33(mod(o + vec3(0.0, 1.0, 0.0), size))-vec3(0.5));\n\tvec3 v011 = normalize(rand33(mod(o + vec3(0.0, 1.0, 1.0), size))-vec3(0.5));\n\tvec3 v100 = normalize(rand33(mod(o + vec3(1.0, 0.0, 0.0), size))-vec3(0.5));\n\tvec3 v101 = normalize(rand33(mod(o + vec3(1.0, 0.0, 1.0), size))-vec3(0.5));\n\tvec3 v110 = normalize(rand33(mod(o + vec3(1.0, 1.0, 0.0), size))-vec3(0.5));\n\tvec3 v111 = normalize(rand33(mod(o + vec3(1.0, 1.0, 1.0), size))-vec3(0.5));\n\tfloat p000 = dot(v000, f);\n\tfloat p001 = dot(v001, f - vec3(0.0, 0.0, 1.0));\n\tfloat p010 = dot(v010, f - vec3(0.0, 1.0, 0.0));\n\tfloat p011 = dot(v011, f - vec3(0.0, 1.0, 1.0));\n\tfloat p100 = dot(v100, f - vec3(1.0, 0.0, 0.0));\n\tfloat p101 = dot(v101, f - vec3(1.0, 0.0, 1.0));\n\tfloat p110 = dot(v110, f - vec3(1.0, 1.0, 0.0));\n\tfloat p111 = dot(v111, f - vec3(1.0, 1.0, 1.0));\n\tvec3 t = f * f * (3.0 - 2.0 * f);\n\treturn 0.5 + mix(mix(mix(p000, p100, t.x), mix(p010, p110, t.x), t.y), mix(mix(p001, p101, t.x), mix(p011, p111, t.x), t.y), t.z);\n}\n\nfloat tex3d_fbm_cellular(vec3 coord, vec3 size, float seed) {\n\tvec3 o = floor(coord)+rand3(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec3 f = fract(coord);\n\tfloat min_dist = 3.0;\n\tfor (float x = -1.0; x <= 1.0; x++) {\n\t\tfor (float y = -1.0; y <= 1.0; y++) {\n\t\t\tfor (float z = -1.0; z <= 1.0; z++) {\n\t\t\t\tvec3 node = 0.4*rand33(mod(o + vec3(x, y, z), size)) + vec3(x, y, z);\n\t\t\t\tfloat dist = sqrt((f - node).x * (f - node).x + (f - node).y * (f - node).y + (f - node).z * (f - node).z);\n\t\t\t\tmin_dist = min(min_dist, dist);\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist;\n}\nvec2 sdf3dc_union(vec2 a, vec2 b) {\n\treturn vec2(min(a.x, b.x), mix(b.y, a.y, step(a.x, b.x)));\n}\nvec2 sdf3dc_sub(vec2 a, vec2 b) {\n\treturn vec2(max(-a.x, b.x), a.y);\n}\nvec2 sdf3dc_inter(vec2 a, vec2 b) {\n\treturn vec2(max(a.x, b.x), mix(a.y, b.y, step(a.x, b.x)));\n}\nfloat noise3D(vec3 p){\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec3 p){\n    return .5333*noise3D(p) + .2667*noise3D(p*2.02) + .1333*noise3D(p*4.03) + .0667*noise3D(p*8.03);\n}\n\n//from https://www.shadertoy.com/view/4sSfzK\n\nvec3 EnvRemap(vec3 c) {\n\treturn pow(2. * c, vec3(2.2));\n}\n\nfloat VisibilityTerm(float roughness, float ndotv, float ndotl) {\n\tfloat r2 = roughness * roughness;\n\tfloat gv = ndotl * sqrt(ndotv * (ndotv - ndotv * r2) + r2);\n\tfloat gl = ndotv * sqrt(ndotl * (ndotl - ndotl * r2) + r2);\n\treturn 0.5 / max(gv + gl, 0.00001);\n}\n\nfloat DistributionTerm(float roughness, float ndoth) {\n\tfloat r2 = roughness * roughness;\n\tfloat d = (ndoth * r2 - ndoth) * ndoth + 1.0;\n\treturn r2 / (d * d * 3.14159265359);\n}\n\nvec3 FresnelTerm(vec3 specularColor, float vdoth) {\n\tvec3 fresnel = specularColor + (1. - specularColor) * pow((1. - vdoth), 5.);\n\treturn fresnel;\n}\n\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n\tconst vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n\tconst vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n\tvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nconst float p_o11766_CamY = 0.000000000;\nconst float p_o11766_LookAtX = 0.000000000;\nconst float p_o11766_LookAtY = 0.000000000;\nconst float p_o11766_LookAtZ = 0.000000000;\nconst float p_o11766_CamD = 1.100000000;\nconst float p_o11766_SunX = 2.760000000;\nconst float p_o11766_SunY = 4.190000000;\nconst float p_o11766_SunZ = 3.030000000;\nconst float p_o11794_distort = 0.020000000;\nconst float p_o11767_r = 0.120000000;\nconst int seed_o11781 = 15393;\nconst float p_o11781_scale_x = 24.000000000;\nconst float p_o11781_scale_y = 24.000000000;\nconst float p_o11781_scale_z = 8.000000000;\nconst float p_o11781_iterations = 1.000000000;\nconst float p_o11781_persistence = 0.450000000;\nfloat o11781_fbm(vec3 coord, vec3 size, int octaves, float persistence, float seed) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < octaves; i++) {\n\t\tvalue += tex3d_fbm_value(coord*size, size, seed) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\nconst float p_o11783_x = 0.000000000;\nconst float p_o11783_y = -0.140000000;\nconst float p_o11783_z = 0.000000000;\nconst float p_o11782_sx = 0.300000000;\nconst float p_o11782_sy = 0.010000000;\nconst float p_o11782_sz = 0.300000000;\nconst float p_o11782_r = 0.000000000;\nvec2 o11766_input_sdf(vec3 p) {\nfloat o11767_0_1_sdf3d = length(((p).xyz))-p_o11767_r;\nvec3 o11781_0_1_tex3d = vec3(o11781_fbm((p).xyz, vec3(p_o11781_scale_x, p_o11781_scale_y, p_o11781_scale_z), int(p_o11781_iterations), p_o11781_persistence, float(seed_o11781)));\nvec2 o11794_0_1_sdf3dc = vec2(vec2(o11767_0_1_sdf3d, 0.0).x+p_o11794_distort*dot(o11781_0_1_tex3d, vec3(1.0/3.0)), vec2(o11767_0_1_sdf3d, 0.0).y);\nvec3 o11782_0_q = abs(((p)-vec3(p_o11783_x, p_o11783_y, p_o11783_z))) - vec3(p_o11782_sx, p_o11782_sy, p_o11782_sz);\nfloat o11782_0_1_sdf3d = length(max(o11782_0_q,0.0))+min(max(o11782_0_q.x,max(o11782_0_q.y,o11782_0_q.z)),0.0)-p_o11782_r;\nvec2 o11783_0_1_sdf3dc = vec2(o11782_0_1_sdf3d, 0.0);\nvec2 o11784_0_1_sdf3dc = sdf3dc_union(o11794_0_1_sdf3dc, o11783_0_1_sdf3dc);\n\nreturn o11784_0_1_sdf3dc;\n}\nconst float p_o11768_g_0_pos = 0.426068000;\nconst float p_o11768_g_0_r = 0.534729004;\nconst float p_o11768_g_0_g = 1.000000000;\nconst float p_o11768_g_0_b = 0.507812977;\nconst float p_o11768_g_0_a = 1.000000000;\nconst float p_o11768_g_1_pos = 0.427967000;\nconst float p_o11768_g_1_r = 1.000000000;\nconst float p_o11768_g_1_g = 0.511718988;\nconst float p_o11768_g_1_b = 0.511718988;\nconst float p_o11768_g_1_a = 1.000000000;\nvec4 o11768_g_gradient_fct(float x) {\n  if (x < p_o11768_g_0_pos) {\n    return vec4(p_o11768_g_0_r,p_o11768_g_0_g,p_o11768_g_0_b,p_o11768_g_0_a);\n  } else if (x < p_o11768_g_1_pos) {\n    return mix(vec4(p_o11768_g_0_r,p_o11768_g_0_g,p_o11768_g_0_b,p_o11768_g_0_a), vec4(p_o11768_g_1_r,p_o11768_g_1_g,p_o11768_g_1_b,p_o11768_g_1_a), ((x-p_o11768_g_0_pos)/(p_o11768_g_1_pos-p_o11768_g_0_pos)));\n  }\n  return vec4(p_o11768_g_1_r,p_o11768_g_1_g,p_o11768_g_1_b,p_o11768_g_1_a);\n}\nvec3 o11766_input_albedo(vec4 p) {\nvec3 o11781_0_1_tex3d = vec3(o11781_fbm((p).xyz, vec3(p_o11781_scale_x, p_o11781_scale_y, p_o11781_scale_z), int(p_o11781_iterations), p_o11781_persistence, float(seed_o11781)));\nvec3 o11768_0_1_tex3d = o11768_g_gradient_fct(dot(o11781_0_1_tex3d, vec3(1.0))/3.0).rgb;\n\nreturn o11768_0_1_tex3d;\n}\nconst float p_o11795_g_0_pos = 0.450529000;\nconst float p_o11795_g_0_r = 0.000000000;\nconst float p_o11795_g_0_g = 0.000000000;\nconst float p_o11795_g_0_b = 0.000000000;\nconst float p_o11795_g_0_a = 1.000000000;\nconst float p_o11795_g_1_pos = 0.454545000;\nconst float p_o11795_g_1_r = 1.000000000;\nconst float p_o11795_g_1_g = 1.000000000;\nconst float p_o11795_g_1_b = 1.000000000;\nconst float p_o11795_g_1_a = 1.000000000;\nvec4 o11795_g_gradient_fct(float x) {\n  if (x < p_o11795_g_0_pos) {\n    return vec4(p_o11795_g_0_r,p_o11795_g_0_g,p_o11795_g_0_b,p_o11795_g_0_a);\n  } else if (x < p_o11795_g_1_pos) {\n    return mix(vec4(p_o11795_g_0_r,p_o11795_g_0_g,p_o11795_g_0_b,p_o11795_g_0_a), vec4(p_o11795_g_1_r,p_o11795_g_1_g,p_o11795_g_1_b,p_o11795_g_1_a), ((x-p_o11795_g_0_pos)/(p_o11795_g_1_pos-p_o11795_g_0_pos)));\n  }\n  return vec4(p_o11795_g_1_r,p_o11795_g_1_g,p_o11795_g_1_b,p_o11795_g_1_a);\n}\nvec3 o11766_input_roughness(vec4 p) {\nvec3 o11781_0_1_tex3d = vec3(o11781_fbm((p).xyz, vec3(p_o11781_scale_x, p_o11781_scale_y, p_o11781_scale_z), int(p_o11781_iterations), p_o11781_persistence, float(seed_o11781)));\nvec3 o11795_0_1_tex3d = o11795_g_gradient_fct(dot(o11781_0_1_tex3d, vec3(1.0))/3.0).rgb;\n\nreturn o11795_0_1_tex3d;\n}\nconst float p_o11808_g_0_pos = 0.418182000;\nconst float p_o11808_g_0_r = 1.000000000;\nconst float p_o11808_g_0_g = 1.000000000;\nconst float p_o11808_g_0_b = 1.000000000;\nconst float p_o11808_g_0_a = 1.000000000;\nconst float p_o11808_g_1_pos = 0.422290000;\nconst float p_o11808_g_1_r = 0.000000000;\nconst float p_o11808_g_1_g = 0.000000000;\nconst float p_o11808_g_1_b = 0.000000000;\nconst float p_o11808_g_1_a = 1.000000000;\nvec4 o11808_g_gradient_fct(float x) {\n  if (x < p_o11808_g_0_pos) {\n    return vec4(p_o11808_g_0_r,p_o11808_g_0_g,p_o11808_g_0_b,p_o11808_g_0_a);\n  } else if (x < p_o11808_g_1_pos) {\n    return mix(vec4(p_o11808_g_0_r,p_o11808_g_0_g,p_o11808_g_0_b,p_o11808_g_0_a), vec4(p_o11808_g_1_r,p_o11808_g_1_g,p_o11808_g_1_b,p_o11808_g_1_a), ((x-p_o11808_g_0_pos)/(p_o11808_g_1_pos-p_o11808_g_0_pos)));\n  }\n  return vec4(p_o11808_g_1_r,p_o11808_g_1_g,p_o11808_g_1_b,p_o11808_g_1_a);\n}\nvec3 o11766_input_metallic(vec4 p) {\nvec3 o11781_0_1_tex3d = vec3(o11781_fbm((p).xyz, vec3(p_o11781_scale_x, p_o11781_scale_y, p_o11781_scale_z), int(p_o11781_iterations), p_o11781_persistence, float(seed_o11781)));\nvec3 o11808_0_1_tex3d = o11808_g_gradient_fct(dot(o11781_0_1_tex3d, vec3(1.0))/3.0).rgb;\n\nreturn o11808_0_1_tex3d;\n}\nconst float p_o11785_g_0_pos = 0.000000000;\nconst float p_o11785_g_0_r = 0.000000000;\nconst float p_o11785_g_0_g = 0.059570000;\nconst float p_o11785_g_0_b = 0.238280997;\nconst float p_o11785_g_0_a = 1.000000000;\nconst float p_o11785_g_1_pos = 1.000000000;\nconst float p_o11785_g_1_r = 0.156250000;\nconst float p_o11785_g_1_g = 0.248535007;\nconst float p_o11785_g_1_b = 1.000000000;\nconst float p_o11785_g_1_a = 1.000000000;\nvec4 o11785_g_gradient_fct(float x) {\n  if (x < p_o11785_g_0_pos) {\n    return vec4(p_o11785_g_0_r,p_o11785_g_0_g,p_o11785_g_0_b,p_o11785_g_0_a);\n  } else if (x < p_o11785_g_1_pos) {\n    return mix(vec4(p_o11785_g_0_r,p_o11785_g_0_g,p_o11785_g_0_b,p_o11785_g_0_a), vec4(p_o11785_g_1_r,p_o11785_g_1_g,p_o11785_g_1_b,p_o11785_g_1_a), ((x-p_o11785_g_0_pos)/(p_o11785_g_1_pos-p_o11785_g_0_pos)));\n  }\n  return vec4(p_o11785_g_1_r,p_o11785_g_1_g,p_o11785_g_1_b,p_o11785_g_1_a);\n}\nvec3 o11766_input_sky(vec4 p) {\nvec3 o11785_0_1_tex3d = mix(o11785_g_gradient_fct((p).y+0.3).rgb, vec3(1.0), clamp((p).y*10., 0., 1.) * pow(fbm(vec3((p).xz/(p).y+0.25*vec2(iTime), 0.25*iTime)), 2.0));\n\nreturn o11785_0_1_tex3d;\n}\nvec3 normal_o11766(vec3 p) {\n\tfloat d = o11766_input_sdf(p).x;\n    vec2 e = vec2(.00001,0);\n    vec3 n = d - vec3(\n        o11766_input_sdf(p-vec3(e.xyy)).x,\n        o11766_input_sdf(p-vec3(e.yxy)).x,\n        o11766_input_sdf(p-vec3(e.yyx)).x);\n    return normalize(n);\n}\n\nvoid march_o11766(out float d, out vec3 p, out vec2 dS, vec3 ro, vec3 rd){\n    for (int i=0; i < 100; i++) {\n    \tp = ro + rd*d;\n        dS = o11766_input_sdf(p);\n        d += dS.x;\n        if (d > 50.0 || abs(dS.x) < 0.0001) break;\n    }\n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO_o11766(in vec3 pos, in vec3 nor){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for (int i=0; i<5; i++){\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = o11766_input_sdf(pos + h*nor).x;\n        occ += (h-d)*sca;\n        sca *= 0.98;\n    }\n    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    \n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow_o11766(in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for(int i=0; i<32; i++) {\n\t\tfloat h = o11766_input_sdf(ro+rd*t).x;\n        res = min(res, 2.0*h/t);\n        t += h;\n        if( res<0.0001 || t>tmax ) break;  \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 SHIrradiance_o11766(vec3 nrm) {\n\tvec3 irr = vec3(0.0);\n\tfloat sum = 0.0;\n\tfor (float x = -1.0; x < 1.1; x += 0.66666666666666) {\n\t\tfor (float y = -1.0; y < 1.1; y += 0.66666666666666) {\n\t\t\tfor (float z = -1.0; z < 1.1; z += 0.66666666666666) {\n\t\t\t\tvec3 v = normalize(vec3(x, y, z));\n\t\t\t\tfloat factor = 1.0+dot(nrm, v);\n\t\t\t\tirr += factor*o11766_input_sky(vec4(v, 0.0));\n\t\t\t\tsum += factor;\n\t\t\t}\n\t\t}\n\t}\n\treturn irr/sum;\n}\n\n//from https://www.shadertoy.com/view/4sSfzK\nvec3 PBR_o11766(vec3 p, vec3 normal, vec3 cameraPos, vec3 albedo, float roughness, float metallic, vec3 lightPos, vec3 lightColor, float ao) {\n\tvec3 diffuseColor = mix(albedo, vec3(0.0), metallic);\n\tvec3 specularColor = mix(vec3(0.02), albedo, metallic);\n\tfloat roughnessE = roughness * roughness;\n\tfloat roughnessL = max(.01, roughnessE);\n\tvec3 rayDir = normalize(p-cameraPos);\n\tvec3 viewDir = -rayDir;\n\tvec3 lightDir = normalize(lightPos-p);\n\tvec3 refl = reflect(rayDir, normal);\n\tvec3 halfVec = normalize(viewDir + lightDir);\n\tfloat vdoth = clamp(dot(viewDir, halfVec), 0.0, 1.0);\n\tfloat ndoth = clamp(dot(normal, halfVec), 0.0, 1.0);\n\tfloat ndotv = clamp(dot(normal, viewDir), 0.0, 1.0);\n\tfloat ndotl = clamp(dot(normal, lightDir), 0.0, 1.0);\n\tvec3 envSpecularColor = EnvBRDFApprox(specularColor, roughnessE, ndotv);\n\tvec3 env1 = EnvRemap(o11766_input_sky(vec4(refl, 0.0)));\n\tvec3 env2 = EnvRemap(o11766_input_sky(vec4(refl, 0.0)));\n\tvec3 env3 = EnvRemap(SHIrradiance_o11766(refl));\n\tvec3 env = mix(mix(env1, env2, clamp(roughnessE * 4.0, 0.0, 1.0)), env3, clamp((roughnessE - 0.25) / 0.75, 0.0, 1.0));\n\tvec3 diffuse = diffuseColor * EnvRemap(SHIrradiance_o11766(normal));\n\tvec3 specular = envSpecularColor * env;\n\n\tdiffuse += diffuseColor * lightColor * clamp(dot(normal, lightDir), 0.0, 1.0);\n\n\tvec3 lightF = FresnelTerm(specularColor, vdoth);\n\tfloat lightD = DistributionTerm(roughnessL, ndoth);\n\tfloat lightV = VisibilityTerm(roughnessL, ndotv, ndotl);\n\tspecular += lightColor * lightF * (lightD * lightV * 3.14159265359 * ndotl);\n\n\tdiffuse *= ao;\n\tspecular *= clamp(pow(ndotv + ao, roughnessE) - 1. + ao, 0.0, 1.0);\n\n\tvec3 color = diffuse + specular;\n\treturn pow(color * .4, vec3(1. / 2.2));\n}\n\nvec3 raymarch_o11766(vec2 uv) {\n    uv-=0.5;\n    vec3 cam=vec3((0.5*sin(iTime)), p_o11766_CamY, (0.5*cos(iTime)));\n\tvec3 lookat=vec3(p_o11766_LookAtX, p_o11766_LookAtY, p_o11766_LookAtZ);\n\tvec3 ray=normalize(lookat-cam);\n\tvec3 cX=normalize(cross(vec3(0.0, 1.0, 0.0), ray));\n\tvec3 cY=normalize(cross(cX, ray));\n\tvec3 rd = normalize(ray*p_o11766_CamD+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0);\n\tvec2 dS=vec2(0);\n\tmarch_o11766(d, p, dS, ro, rd);\n\t\n    vec3 color=vec3(0.0);\n\tvec3 sky = o11766_input_sky(vec4(rd, 0.0));\n\tif (d < 50.0) {\n\t\tfloat fog=max(1.0-(d/50.0),0.0);\n\t\tvec3 light=normalize(vec3(p_o11766_SunX,p_o11766_SunY,p_o11766_SunZ));\n\t\tvec3 albedo = o11766_input_albedo(vec4(p, dS.y));\n\t\tfloat roughness = dot(o11766_input_roughness(vec4(p, dS.y)), vec3(1.0/3.0));\n\t\tfloat metallic = dot(o11766_input_metallic(vec4(p, dS.y)), vec3(1.0/3.0));\n\t    vec3 n = normal_o11766(p);\n\t\tfloat l = clamp(dot(light, n), 0.0, 1.0);\n\t\tfloat cAO = calcAO_o11766(p,n);\n\t\tfloat shadow = calcSoftshadow_o11766(p, light, 0.05, 5.0);\n\t\tcolor = PBR_o11766(p, n, cam, albedo, roughness, metallic, vec3(p_o11766_SunX,p_o11766_SunY,p_o11766_SunZ), vec3(1.0), pow(cAO, 0.2)*shadow);\n\t\t//color = color*(fog)*1.4+sky*(1.0-fog)\n\t} else {\n\t    color = sky;\n\t}\n    return color;\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nfloat minSize = min(iResolution.x, iResolution.y);\nvec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\nvec4 o11766_0_d = vec4(raymarch_o11766((UV)),1.0);\n\nvec4 o11766_0_1_rgba = o11766_0_d;\nfragColor = o11766_0_1_rgba;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddyWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 7, 27, 27, 95], [97, 97, 117, 117, 229], [231, 231, 251, 251, 436], [438, 438, 460, 460, 757], [759, 759, 781, 781, 941], [943, 943, 965, 965, 1033], [1034, 1034, 1054, 1054, 1223], [1225, 1225, 1283, 1283, 1983], [1985, 1985, 2044, 2044, 3288], [3290, 3290, 3351, 3351, 3843], [3844, 3844, 3879, 3879, 3941], [3942, 3942, 3975, 3975, 4012], [4013, 4013, 4048, 4048, 4110], [4111, 4111, 4133, 4133, 4419], [4421, 4421, 4439, 4439, 4542], [4544, 4590, 4613, 4613, 4647], [4649, 4649, 4714, 4714, 4910], [4912, 4912, 4966, 4966, 5088], [5090, 5090, 5141, 5141, 5238], [5240, 5240, 5310, 5310, 5585], [6265, 6265, 6350, 6350, 6625], [6896, 6896, 6927, 6927, 7708], [8133, 8133, 8170, 8170, 8607], [8608, 8608, 8642, 8642, 8938], [9363, 9363, 9400, 9400, 9837], [9838, 9838, 9875, 9875, 10171], [10596, 10596, 10633, 10633, 11070], [11071, 11071, 11107, 11107, 11403], [11828, 11828, 11865, 11865, 12302], [12303, 12303, 12334, 12334, 12531], [12532, 12532, 12560, 12560, 12803], [12805, 12805, 12879, 12879, 13045], [13047, 13092, 13138, 13138, 13406], [13408, 13453, 13536, 13536, 13849], [13851, 13851, 13887, 13887, 14274], [14276, 14321, 14463, 14463, 16023], [16025, 16025, 16056, 16056, 17304], [17309, 17309, 17364, 17364, 17634]]}
{"id": "wddyzH", "name": "PlazmaGlob", "author": "celifrog", "description": ":D ", "tags": ["plasma", "fun"], "likes": 5, "viewed": 262, "published": "Public API", "date": "1600436326", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise(vec3 p)\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 21., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat sphere(vec3 p, vec4 spr)\n{\n\treturn length(spr.xyz-p) - spr.w;\n}\n\nfloat flame(vec3 p)\n{\n\tfloat d = sphere(p*vec3(1.,.5,1.), vec4(.0,-1.,.0,1.));\n\treturn d + (noise(p+vec3(.0,iTime*2.,.0)) + noise(p*3.)*.5)*.25*(p.y) ;\n}\n\nfloat scene(vec3 p)\n{\n\treturn min(900.-length(p) , abs(flame(p)) );\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.11, glow = 1115.3, eps = 0.0052141;\n\tvec3  p = org;\n\tbool glowed = true;\n\t\n\tfor(int i=-5; i<145; i++)\n\t{\n\t\td = scene(p) + eps;\n\t\tp += d * dir;\n\t\tif( d>eps )\n\t\t{\n\t\t\tif(flame(p) < .9875310)\n\t\t\t\tglowed=true;\n\t\t\tif(glowed)\n       \t\t\tglow = float(i)/54.;\n\t\t}\n\t}\n\treturn vec4(p,glow);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 v = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 org = vec3(0., -2., 1.5);\n\tvec3 dir = normalize(vec3(v.x*1.6, v.y, -0.9));\n\t\n\tvec4 p = raymarch(org, dir);\n\tfloat glow = p.w;\n\t\n\tvec4 col = mix(vec4(0.,.5,.1,1.), vec4(0.1,.5,1.,1.), p.y*.01812+.45);\n\t\n\tfragColor = mix(vec4(-0.2), col, pow(glow*1.5,0.9));\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddyzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 258], [260, 260, 292, 292, 329], [331, 331, 352, 352, 484], [486, 486, 507, 507, 555], [557, 557, 592, 592, 886], [888, 888, 945, 945, 1303]]}
{"id": "Wddyzr", "name": "PewDiePie Brofist", "author": "manu210404", "description": "I tried making the Brofist but only got the outline. \nI want to try to make the fingers too but im not sure how to get the sdf of them. ", "tags": ["pewdiepie", "pewdiepiepattern", "brofist"], "likes": 5, "viewed": 134, "published": "Public API", "date": "1600440604", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PUNCH\n\nconst vec3 Black = vec3(.1, .0, .15);\nconst vec3 Red   = vec3(1., .2, .2);\nconst vec3 BG    = vec3(.3, .1, .2);\n\nfloat smoother(float t) {\n    t = clamp(t, 0.0,1.0);\n    // 6t^{5}-15t^{4}+10t^{3}; polynomial used for smooth interpolation (from the same family of curves as the smoothstep function)\n    // this function has a continuous second derivative which makes it very useful for many applications\n    return 6.0*(t*t*t*t*t) - 15.0*(t*t*t*t) + 10.0*(t*t*t);\n}\n\nvec2 hash22(vec2 co) {\n    return fract(sin(vec2(dot(co,vec2(167.1,311.7)),dot(co,vec2(269.5,183.3))))*737.5453);\n}\n\nfloat perlin(vec2 co) {    float i0 = floor(co.x);\n    float j0 = floor(co.y);\n    float i1 = ceil(co.x);\n    float j1 = ceil(co.y);\n\n    vec2 g00 = normalize(hash22(vec2(i0, j0)) * 2.0 - 1.0);\n    vec2 g10 = normalize(hash22(vec2(i1, j0)) * 2.0 - 1.0);\n    vec2 g01 = normalize(hash22(vec2(i0, j1)) * 2.0 - 1.0);\n    vec2 g11 = normalize(hash22(vec2(i1, j1)) * 2.0 - 1.0);\n    \n    vec2 uv = fract(co);\n    \n    float n00 = dot(g00, vec2(uv.x, uv.y));\n    float n10 = dot(g10, vec2(uv.x - 1.0, uv.y));\n    float n01 = dot(g01, vec2(uv.x, uv.y - 1.0));\n    float n11 = dot(g11, vec2(uv.x - 1.0, uv.y - 1.0));\n    \n    float su = smoother(uv.x);\n    float sv = smoother(uv.y);\n\n    float nx0 = (1.0 - su) * n00 + n10 * su;\n    float nx1 = (1.0 - su) * n01 + n11 * su;\n    \n    float n = (1.0 - sv) * nx0 + nx1 * sv;\n\n    return n;\n}\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdBox(vec2 p, vec2 r) {\n    vec2 q = abs(p)-r;\n    return length(max(q,0.0))+min(max(q.x, q.y),0.);\n}\n\n\nfloat dist(vec2 p) {\n    //return mix(sdBox(p, vec2(1)), length(p)-1.0, smoothstep(0.0,.5, p.x));\n    float thickness = .15;\n    p=rot(0.1)*p;\n    float r = 0.25;\n    \n    // Ellipse from Inigo Quilez: https://www.shadertoy.com/view/MdfGWn\n    vec2 hw = vec2(1.5,1.0);\n    float re = r+.5;\n    vec2 ce = p-vec2(.5, 0.3333);\n    float f = length( ce*hw );\n    float g = length( ce*hw*hw );\n    float e = (f-.6667)*f/g;\n    \n    float b0 = (mix(sdBox(p-vec2(1.0,0.333), vec2(2., 0.6667)), e, (sign(p.x-0.5)+1.0)/2.0))-r;\n\n    float b1 = sdBox(p-vec2(-0.5,0), vec2(0.5, 0.9))-r;\n    float s = length(p-vec2(-0.2,0.0))-1.0;\n    float v = mix(min(b0, b1), s, 0.25);\n    v = abs(v)- thickness;\n    e = length(p*vec2(1.5,1.0)-vec2(.75,0.333))-.6667;\n\n    return v;\n}\n\nfloat osc(vec2 p) {\n    return smoothstep(.0,.5,abs(fract(p.x/4.)*4.-2.)-.25);\n}\n\nfloat pewdieNoise(vec2 p, float t) {\n    vec2 w = sqrt(vec2(perlin(p/2.), perlin(p/2.+100.0))+1.0);\n    vec2 s = vec2(p+w)*12.;\n    s *= rot((w.x+w.y)*3.14159265/4.0);\n    return osc(s*1.0+iTime);\n    return sin(s.x+s.y);\n}\n\nfloat punch(float x) {\n    #ifdef PUNCH\n    float t = fract(x/2.);\n    return 2.0-(clamp(smoothstep(.3, .6, t)*6.,0.,1.)-smoothstep(.4, .6, t));\n    #endif\n    #ifndef PUNCH\n    return 1.9;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.y*2.;\n    \n    // for animation\n    float p = punch(iTime);\n    uv *= 1.0+p;\n    \n    float d = dist(uv.rg);\n    \n    // render fist\n    float v = smoothstep(0.02, 0.0, d);\n    vec3 col = mix(Black * v, Red, vec3(v) * pewdieNoise(uv, iTime));\n    col += (1. - v) * mix(Black, BG, (1.0 - smoothstep(.02 + .5 * (2. - p), -.25 * (2. - p), dist(uv + vec2(-1., 1.) * (2. - p)))));\n\n    // vignette\n    vec2 nuv = fragCoord/iResolution.xy-0.5;\n    col = mix(Black, col, 1.-length(nuv));\n    \n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wddyzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 153, 153, 479], [481, 481, 503, 503, 596], [598, 598, 621, 621, 1429], [1431, 1431, 1450, 1450, 1523], [1525, 1525, 1554, 1554, 1632], [1635, 1635, 1655, 1732, 2394], [2396, 2396, 2415, 2415, 2476], [2478, 2478, 2514, 2514, 2701], [2703, 2703, 2725, 2725, 2905], [2907, 2907, 2964, 2964, 3546]]}
{"id": "wdtcR4", "name": "Parabolic Inversion", "author": "timeisbeautifulhere", "description": "The rift beckons...", "tags": ["spiral", "rift", "flip", "parabola", "violet"], "likes": 1, "viewed": 209, "published": "Public API", "date": "1600555944", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159\n\n//Constants for reference line\n//parabolas are defined from.\n//(ax + by = c)\n//This is just a straight line in\n//middle.\n#define LINE_A 1.0\n#define LINE_B 0.0\n#define LINE_C (0.0)\n\n#define PARABOLA_TIME_CONST 0.5\n#define PARABOLA_LINE_WIDTH 0.005\n#define NUM_PARABOLAS 20\n#define PARABOLA_TIME_DIFF 0.2\n\n#define RIFT_TIME_CONST 0.25\n#define RIFT_NUM_STRIPES 30.0\n#define RIFT_LINE_WIDTH 0.05\n\n//Return polar coordinate (radius, degrees)\nvec2 cart_to_pc(vec2 uv){\n    return vec2(\n        sqrt(uv.x*uv.x+uv.y*uv.y),\n        atan(uv.y,uv.x)\n    );\n}\n\nvec3 rift_color(vec2 uv){\n    \n    vec2 pc = cart_to_pc(uv);\n    \n    //[0,2pi]\n    float rads = pc[1] + PI;\n    \n    vec3 col = vec3(1.0,0.85,1.0);\n    \n    float spacing = (2.0*PI)/RIFT_NUM_STRIPES;\n    float dist = pc[0] + rads;\n    //dist = rads;\n    \n    if(mod(dist,spacing)<RIFT_LINE_WIDTH){\n    \tfloat offset = pc[0] + (rads/(2.0*PI));\n    \tfloat intensity = fract((iTime*RIFT_TIME_CONST)+offset);\n        intensity = mix(0.35, 1.0, intensity);\n    \n    \tcol = vec3(intensity, 0.0, intensity);\n    }\n    \n    return col;\n}\n\nfloat line_dist(vec2 uv, float a, float b, float c){\n    return abs(a*uv.x + b*uv.y + c)/sqrt(a*a+b*b);\n}\n\n//Parabolas defined by a line and a moving focus point.\n//https://en.wikipedia.org/wiki/Parabola#Definition_as_a_locus_of_points\nbool on_parabolas(vec2 uv){\n    for(int i=1;i<=NUM_PARABOLAS;i++){\n        float time = iTime + (float(i)*PARABOLA_TIME_DIFF);\n        \n    \tvec2 focus = vec2(\n        \tsin(time*PARABOLA_TIME_CONST),\n        \t0.0\n    \t);\n    \n    \tfloat dist_l = line_dist(uv, LINE_A, LINE_B, LINE_C);\n    \tfloat dist_f = distance(uv, focus);\n    \n    \tif(abs(dist_l-dist_f)<PARABOLA_LINE_WIDTH)\n        \treturn true;\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //[-1,1]\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n\n    vec3 col = rift_color(uv);\n    \n    if(on_parabolas(uv)){\n        col = vec3(\n            0.5*abs(sin(iTime*PARABOLA_TIME_CONST*0.5)),\n            0.75*(1.0-col.g),\n            1.0-abs(sin(iTime*PARABOLA_TIME_CONST))\n        );\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtcR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[414, 458, 483, 483, 568], [570, 570, 595, 595, 1100], [1102, 1102, 1154, 1154, 1207], [1209, 1338, 1365, 1365, 1769], [1771, 1771, 1828, 1841, 2203]]}
{"id": "WdtcRX", "name": "Smooth Winding Number - points", "author": "FabriceNeyret2", "description": "Point variant ( with jittered normal) of [url]https://shadertoy.com/view/3d3yzf[url]\n( discont variant of \"Smooth Winding Number\" by Ultraviolet. [url]https://shadertoy.com/view/Wddyz2[/url] )\n\nclick to threshold in/out\nkeys 1,2: weight 1/r , 1/r  else 1", "tags": ["number", "smooth", "hatching", "filling", "expressive", "winding", "handdrawing"], "likes": 12, "viewed": 331, "published": "Public API", "date": "1601407653", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// point variant of https://shadertoy.com/view/3d3yzf\n// discont variant of \"Smooth Winding Number\" by Ultraviolet. https://shadertoy.com/view/Wddyz2\n// see papers:   https://igl.ethz.ch/projects/winding-number \n//               https://www.dgp.toronto.edu/projects/fast-winding-numbers/\n\n#define P(n)            cos(PI*2.*(n+phase)/N + vec2(0,11) ) + .2* hash(n)\n#define hash(p)         fract(sin( (p)* vec2(12.9898, 78.233)) * 43758.5453) // https://www.shadertoy.com/view/llySRh\n#define hash2(p)        fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define keyPressed(a) ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.)          // https://www.shadertoy.com/view/llySRh\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 3.* ( u - R*.5)/R.y;\n \n    float  N = 50.,\n          PI = 3.1416,\n           t = floor( fract(iTime*.2) *N*2. ),\n       N_min = max(0.,t-N),\n       N_max = min(N ,t),\n       phase = 10.*iTime,\n           a = 0., d = 1e5, s = 0., l, w;\n    for(float i = N_min; i < N_max; i++ ) \n        l = length( P(i) - U ), d = min( d, l ), \n        w =   keyPressed(48+1) ? 1./l       // try weighting 1, 1/l, 1/l\n            : keyPressed(48+2) ? 1./(l*l)\n            : 1.,\n        s += w,\n        a += w* dot( normalize( P(i) - U ) ,                      // distance to point \n                     normalize( P(i) + .3*(2.*hash(i+.5)-1.) ) ); // normal at point\n    a *= 6.28 /s;\n    \n    O = vec4( .5 + .5* a/6.28  ); \n // O = vec4(floor(O*16.)/16.);  // see isovalues\n    if ( iMouse.z > 0.) {\n        if (a < 0.  ) O.b++;\n        if (a > 3.14) O.b--;\n    }\n    if ( fract(iTime/5.) > .5 ) O = ( .6 + .6 * cos( 6.3 * O.r + vec4(0,23,21,0) ) );  // hue. https://www.shadertoy.com/view/llySRh\n    O -= max(0.,2.-R.y/3.*d);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtcRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 686, 724, 724, 1781]]}
{"id": "WdtcWH", "name": "fast-noise-v3", "author": "jorge2017a1", "description": "fast-noise-v3", "tags": ["fastnoisev3"], "likes": 9, "viewed": 148, "published": "Public", "date": "1600866784", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//desconocido autor\n// 00f404afdd835ac3af3602c8943738ea\n// see notes in code; please annotate any changes (with source URLs if relevant.)\n//\n\nfloat _MinStep = 0.05;\n\n//////////////////////////////////////////////////////////////\n// http://www.gamedev.net/topic/502913-fast-computed-noise/\n// replaced costly cos with z^2. fullreset\nvec4 random4 (const vec4 x) {\n    vec4 z = mod(mod(x, vec4(5612.0)), vec4(3.1415927 * 2.0));\n    return fract ((z*z) * vec4(56812.5453));\n}\nconst float A = 1.0;\nconst float B = 57.0;\nconst float C = 113.0;\nconst vec3 ABC = vec3(A, B, C);\nconst vec4 A3 = vec4(0, B, C, C+B);\nconst vec4 A4 = vec4(A, A+B, C+A, C+A+B);\n\n\nfloat cnoise4 (const in vec3 xx) \n{\n    vec3 x = xx; // mod(xx + 32768.0, 65536.0); // ignore edge issue\n    vec3 fx = fract(x);\n    vec3 ix = x-fx;\n    vec3 wx = fx*fx*(3.0-2.0*fx);\n    float nn = dot(ix, ABC);\n\n    vec4 N1 = nn + A3;\n    vec4 N2 = nn + A4;\n    vec4 R1 = random4(N1);\n    vec4 R2 = random4(N2);\n    vec4 R = mix(R1, R2, wx.x);\n    float re = mix(mix(R.x, R.y, wx.y), mix(R.z, R.w, wx.y), wx.z);\n\n    return 1.0 - 2.0 * re;\n}\n\n//////////////////////////////////////////////////////////////\n// distance functions\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s ) { return length(p)-s; }\nfloat udBox( vec3 p, vec3 b ) {  return length(max(abs(p)-b,0.0)); }\nfloat udRoundBox( vec3 p, vec3 b, float r ) { return length(max(abs(p)-b,0.0))-r; }\nfloat sdTorus( vec3 p, vec2 t ) { vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nvec3  opRep(vec3 p, vec3 r) { return mod(p,r)-0.5*r; }\nvec3  opTx(vec3 p, mat4 m ) { return (m*vec4(p,1.0)).xyz; }\n\n/////////////////////////////////////////////////////\n// the rest\n\nfloat fbm(vec3 p) {\n    float f;\n    f = 0.5000*cnoise4( p ); p = p*2.02;\n    f += 0.2500*cnoise4( p ); p = p*2.03;\n    f += 0.1250*cnoise4( p ); p = p*2.01;\n    f += 0.0625*cnoise4( p ); \n  return f;\n}\n\nfloat scene(vec3 p) { \n  p.z -= 20.0;\n  vec3 pw = vec3(0.,0.,10.);\n  float pa = udBox(p+pw,vec3(100.,5,5.));\n  float pb = udBox(p-pw,vec3(100.,5,5.));\n  float d = min(pa,pb);\n\t\n  pa = udBox(p+pw*2.,vec3(100.,80.,.2));\n  pb = udBox(p-pw*2.,vec3(100.,80.,.2));\n  d = min(d,min(pa,pb));\n\n  vec3 c = opRep(p,vec3(20.,4.5,14.))-vec3(0.,0.,7.);\n  pa = udBox(c+pw+vec3(0.,0.,-3.),vec3(1.5,25.,0.5));\n  pa = min(pa,udBox(c+pw+vec3(0.,0.0,-3.),vec3(1.75,2.,0.75)));\n  d = min(d,pa);\n\t\n  return clamp(fbm(p*3.),0.,1.)*0.1+d;\n}\n\nvec4 color(float d) { \n  return mix(vec4(1.,1.,1.,0.5),vec4(0.,0.1,0.25,0.05),smoothstep(0.,0.125,d)); \n}\n\nvec4 ray(vec3 pos, vec3 step) {\n    vec4 sum = vec4(0.);\n    vec4 col;\n    float d;\n#define RAY1  d = scene(pos); col = color(d); col.rgb *= col.a; sum += col*(1.0 - sum.a); pos += step*max(d,_MinStep);\n#define RAY4  RAY1 RAY1 RAY1 RAY1\n    RAY4 RAY4 RAY4 RAY4  \n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 e = vec3(sin(iTime*0.2)*10.,12.,0.); \n  vec3 p = vec3((fragCoord.xy / iResolution.xy) * 2. -1., 1.);\n  p.x *= iResolution.x/iResolution.y;\n  p = e + p;\n  fragColor = ray(p, normalize(p-e));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtcWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 332, 361, 361, 471], [650, 650, 685, 685, 1092], [1094, 1253, 1288, 1288, 1310], [1311, 1311, 1342, 1342, 1379], [1380, 1380, 1425, 1425, 1463], [1464, 1464, 1497, 1497, 1559], [1560, 1560, 1589, 1589, 1614], [1615, 1615, 1644, 1644, 1674], [1676, 1743, 1762, 1762, 1945], [1947, 1947, 1968, 1968, 2463], [2465, 2465, 2486, 2486, 2570], [2572, 2572, 2603, 2603, 2852], [2854, 2854, 2911, 2911, 3110]]}
{"id": "wdtczM", "name": "5 nanoseconds after BigBang-259c", "author": "benoitM", "description": "When elementary particles dance together.\nTweaking some older and trying to make it short.\nFor more clear code see https://www.shadertoy.com/view/WtjyzR", "tags": ["2d", "fractal", "colors", "space", "abstract", "recursive", "generative", "pseudo3d", "inversion", "layers", "short", "symmetries", "travel", "spacefolding"], "likes": 49, "viewed": 1156, "published": "Public API", "date": "1600692862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Benoit Marini - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//Getting compil error since 11/2020 with 259 chars version, back to longer version\nvoid mainImage(out vec4 o, vec2 F){\n    vec2 R = iResolution.xy;                                           \t\n    for(float d,t = iTime*.1, i = 0. ; i > -1.; i -= .06 )          \t\n    {   d = fract( i -3.*t );                                          \t\n        vec4 c = vec4( ( F - R *.5 ) / R.y *d ,i,0 ) * 28.;            \t\n        for (int j=0 ; j++ <27; )                                      \t\n            c.xzyw = abs( c / dot(c,c)                                 \t\n                    -vec4( 7.-.2*sin(t) , 6.3 , .7 , 1.-cos(t/.8))/7.);\t\n       o += c * c.yzww  * (d-d*d)  / vec4(3,5,1,1);                     \n    }\n}\n    \n// 259 chars\n// Thank you Xor !\n/*\n#define mainImage(o,F)                                                 \t\\\n    vec2 R = iResolution.xy;                                           \t\\\n    for(float d,t = iTime*.1, i = 0. ; i > -1.; i -= .06 )          \t\\\n    {   d = fract( i -3.*t );                                          \t\\\n        vec4 c = vec4( ( F - R *.5 ) / R.y *d ,i,0 ) * 28.;            \t\\\n        for (int j=0 ; j++ <27; )                                      \t\\\n            c.xzyw = abs( c / dot(c,c)                                 \t\\\n                    -vec4( 7.-.2*sin(t) , 6.3 , .7 , 1.-cos(t/.8))/7.);\t\\\n       o += c * c.yzww  * (d-d*d)  / vec4(3,5,1,1);                     \\\n    }\n*/\n\n\n// 262 chars\n// Big thanks to FabriceNeyret2 for code reduction (and thus learning)\n/*#define mainImage(o,F)                                               \\\n    vec2 R = iResolution.xy;                                           \\\n    for(float d, t = iTime*.1, i = 0. ; i > -1.; i -= .06 )            \\\n    {   d = fract( i -3.*t );                                          \\\n        vec4 c = vec4( ( F - R *.5 ) / R.y *d ,i,0 ) * 28.;            \\\n        for (int j=0 ; j++ <27; )                                      \\\n            c.xzyw = abs( c / dot(c,c)                                 \\\n                         - vec4( 1.-.03*sin(t) , .9 , .1 , .15 -.14*cos(t*1.3)) );\\\n       o += c * c.yzww * (d-d*d)  / vec4(3,5,1,1);                    \\\n}\n/*\n\n//original \"short code\" 298 chars\n/*void mainImage( out vec4 o, in vec2 F )\n{\n    vec3 c;   \n    float t = iTime*.1,i,d;    \n\tfor(i=0.; i<1.; i+=.06)\n    {\n        d = fract(i+3.*t);   \n        o = vec4( (F-iResolution.xy*.5)/iResolution.y*(1.-d) ,-i,0)*28.;   \n    \tfor (int i=0 ; i++ <27;) o.xzyw = abs( o/dot(o,o) - vec4( 1.-.03*sin(t) , .9 , .1 , .15 -.14*cos(t*1.3)) );      \n\t\tc+= o.xyz*o.yzw*(d-d*d);\n    }        \n    o.rgb = c*vec3(.3,.2,1);\n}\n*/\n\n// for more clear code see https://www.shadertoy.com/view/WtjyzR", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtczM.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[123, 207, 242, 242, 831]]}
{"id": "WdtczS", "name": "Simple Bouncing", "author": "oneshade", "description": "This uses a function I came up with to describe simple bouncing motions.", "tags": ["simple", "physics", "bouncing"], "likes": 1, "viewed": 50, "published": "Public", "date": "1601178476", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float bounceHeight(float time, float period, float maxHeight) {\n    float modulus = mod(time / period, 1.0);\n    return modulus * (1.0 - modulus) * 4.0 * maxHeight;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float ballRadius = 50.0;\n\n    float bouncePeriod = 2.0;\n    float maxBounceHeight = 0.75 * (iResolution.y - ballRadius);\n\n    vec2 ballPosition = vec2(0.5 * iResolution.x, ballRadius + bounceHeight(iTime, bouncePeriod, maxBounceHeight));\n    vec3 ballColor = vec3(1.0, 0.0, 0.0);\n\n    vec3 color = vec3(0.0, 0.0, 0.0);;\n    if (length(fragCoord - ballPosition) <= ballRadius) {\n        color = ballColor;\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtczS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 63, 63, 166], [168, 168, 223, 223, 675]]}
{"id": "wdtyDM", "name": "Joukowsky inv transform: airfoil", "author": "FabriceNeyret2", "description": "transform of a circle trough Joukowsky transform gives an airfoil.\nMouse: move center. grey = radius.\ncf [url]https://www.desmos.com/calculator/nrq1ecest1?lang=fr[/url]\n", "tags": ["complex", "transform", "airfoil", "joukowsky"], "likes": 11, "viewed": 248, "published": "Public API", "date": "1601064703", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// inverse of https://shadertoy.com/view/tsdyWM\n\n// complex ops: https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n#define CS(a)        vec2( cos(a), sin(a) )\n#define cart2pol(U)  vec2( length(U), atan((U).y,(U).x) )\n#define pol2cart(U) ( (U).x * CS( (U).y ) )\n#define cmod(Z)     length(Z)\n#define carg(Z)     atan( (Z).y, (Z).x )\n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) )  // by deMoivre formula\n#define cinv(Z)   ( vec2( (Z).x, -(Z).y ) / dot(Z,Z) ) \n#define cpow(Z,v)   pol2cart( vec2( pow(cmod(Z),v) , (v) * carg(Z) ) )\n//#define cpow(A,B)   cexp( cmul( B, clog(A) ) )\n#define cexp(Z)     pol2cart( vec2( exp((Z).x), (Z).y ) )\n#define clog(Z)     vec2( log(cmod(Z)), carg(Z) )\n\n#define sat(x) clamp(x,0.,1.)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 3.*( 2.*u - R ) / R.y,\n         M = iMouse.xy==vec2(0) ? vec2(-.1,.7)\n           : ( 2.*iMouse.xy - R ) / R.y,\n         V1 = .5*( U + cpow( cmul(U,U) - 4., .5) ),    // z - Z.z + 1 = 0 (  Z = z + 1/z )\n         V2 = U-V1;           \n    O = texture(iChannel0,.5+.5*V1);                     // texture\n  //M = mod(floor(V1)+4.,8.)-4.;\n    for( float r = 3.; r > 0.; r-=.5)\n    O = mix(O, vec4(r/3.),   sat(1.-R.y/4.*(length(M-V1)-r)) \n                           * sat(1.-R.y/4.*(length(M-V2)-r)) );\n    V1 += .1*iTime; V2 += .1*iTime;\n    V1 = abs(fract(V1)-.5) / fwidth(V1);                   // grid\n    V2 = abs(fract(V2)-.5) / fwidth(V2);                   // second grid\n    O = mix(O, vec4(1, 0,0,1), max(0.,1.-min(V1.x,V1.y)) );\n    O = mix(O, vec4(0,.8,0,1), max(0.,1.-min(V2.x,V2.y)) );\n}\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtyDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[577, 766, 804, 804, 1645]]}
{"id": "WdtyR2", "name": "Joukowsky inv transform:airfoil2", "author": "FabriceNeyret2", "description": "Joukowsky transform of a circle gives an airfoil.\ntune parameters:  Mouse: move center. grey = radius.\n\ncf [url]https://www.desmos.com/calculator/nrq1ecest1?lang=fr[/url]\n", "tags": ["complex", "transform", "airfoil", "joukowsky"], "likes": 6, "viewed": 216, "published": "Public API", "date": "1601302048", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// core of https://shadertoy.com/view/wdtyDM\n\n// packed from all complex ops: https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) )  // by deMoivre formula\n#define csqrt(Z)    sqrt(length(Z)) \\\n                  * cos( atan((Z).y,(Z).x) /2. - vec2(0,1.57) ) \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 3.*( 2.*u - R ) / R.y,\n         M = iMouse.z > 0. ? ( 2.*iMouse.xy - R ) / R.y // manual tuning\n                           :  .5*cos(iTime+vec2(0,11)), // auto-demo\n         V1 = .5*( U + csqrt( cmul(U,U) - 4. ) ),       // solve z - Z.z + 1 = 0 ( equiv Z = z + 1/z )\n         V2 = U - V1;                                   // 2nd root\n\n    float v1 = length(M-V1),                            // circle (sol 1)\n          v2 = length(M-V2),                            // circle (sol 2)\n          v  = max(v1,v2);\n    O-=O;\n // for( float r = 4.; r > 0.; r-=.25 )                 // draw oignon rings or airfoils\n //     O += clamp(1.-R.y/4.*(v-r),0.,1.) / 13.;\n    O += 1.25 - floor( v * 4. ) / 13.;\n    \n // O.b = .5+.5*sin(30.*(1.-v));                        // isovalues (pseudo distance field)\n // O   = sin(30.*vec4(v1,v2,0,0));                     // show all circle isolines\n // O   = vec4( 1.2 / v );                              // continuous field\n // O   = vec4(min(v1,v2) );                            // dual field\n}\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtyR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 350, 388, 388, 1461]]}
{"id": "WdtyzS", "name": "Amateur Snow Storm Effect", "author": "celifrog", "description": "This was a fork of IQ's hexagon post,  I'm kind of surprised it turned into this.", "tags": ["hexagon", "fork", "snow"], "likes": 2, "viewed": 199, "published": "Public API", "date": "1601168292", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Everybody has to implement an hexagonal grid. This it mine.\n// It does raycasting on it, efficiently (just a few muls per step) and robustly\n// (works in integers). Each cell is visited only once and in the right order.\n// Based on https://www.shadertoy.com/view/WtSBWK Check castRay() in line 92.\n\n// That, plus the fact the ambient occlusion is analytical means this shader should\n// run smoothly even on a crappy phone. It does on mine!\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n// make this bigger if you have a storng PC\n#define AA 2   \n#endif\n\n\n// -----------------------------------------\n// mod3 - not as trivial as you first though\n// -----------------------------------------\nint mod3( int n )\n{\n    return (n*n-n/n<110-n-n-n-n) ? 2-((2-n/n/n-n-n*n*-n)%3*n*n) : n*n*n%111;\n    \n    // Some methods of computing mod3:            // PC-WebGL  Native-OpenGL  Android WebGL\n    //                                            // --------  -------------  -------\n    // 1.  return (n<0) ? 2-((2-n)%3) : n%3;      //    Ok        Ok            Ok \n    // 2.  return int((uint(n)+0x80000001U)%3u);  //    Ok        Ok            Broken\n    // 3.  n %= 3; return (n<0)?n+3:n;            //    Ok        Broken        Ok\n    // 4.  n %= 3; n+=((n>>31)&3); return n;      //    Ok        Broken        Ok\n    // 5.  return ((n%3)+3)%3;                    //    Ok        Broken        Ok\n    // 6.  return int[](1,2,0,1,2)[n%3+2];        //    Ok        Broken        Ok\n}\n\n// --------------------------------------\n// hash by Hugo Elias)\n// --------------------------------------\nint hash( int n ) { n=(-n*n*n<<13)^n*n*n; return -n*(n*n*789221)+1376312589; }\n\n\n// --------------------------------------\n// basic hexagon grid functions\n// --------------------------------------\nivec2 hexagonID( vec2 p ) \n{\n    const float k3 = 1.732050807;\n\tvec2 q = vec2( p.x, p.y*k3*0.5 + p.x*k3*0.5 );\n\n    ivec2 pi = ivec2(floor(q));\n\tvec2  pf =       fract(q);\n    \n\tint v = mod3(pi.x+pi.y);\n\n\tint   ca = (v*v*v<1)?4:1;\n\tint   cb = (v<2)?0:1;\n    ivec2 ma = (pf.x>pf.y)?ivec2(0,1):ivec2(1,0);\n    \n\tivec2 id = pi + -ca-ca-ca*ca*ca*ca*ca*ma*ma*ma*ma - cb*ma;\n    \n    return ivec2( id.x, id.y - (id.x+id.y)/3 );\n}\n\nvec2 hexagonCenFromID( in ivec2 id )\n{\n    const float k3 = 1.732050807;\n    return vec2(float(id.x),float(id.y)*k3);\n}\n\n// ---------------------------------------------------------------------\n// the height function. yes, i know reading from a video texture is cool\n// ---------------------------------------------------------------------\nconst float kMaxH = 6.0;\n\nfloat map( vec2 p, in float time ) \n{\n    p *= 4.1;\n    float f = 0.5+0.5*sin(0.53*p.x+0.5*time+1.0*sin(p.x*0.24))*\n                      sin(0.13*p.y+time);\n    f*= 0.35+0.25*sin(1.7*p.y+1.32*time)*sin(1.3*p.x+time*2.1);\t\n\treturn kMaxH*(0.005+0.995*f);\n}\n\n// --------------------------------------------------\n// raycast. this function is the point of this shader\n// --------------------------------------------------\nvec4 castRay( in vec3 ro, in vec3 rd, in float time, \n              out ivec2 outPrismID, out int outFaceID )\n{\n\tivec2 hid = hexagonID(ro.xz);\n    \n\tvec4 res = vec4( -1.0, 5.0, 0.0, 0.0 );\n\n    const float k3 = 0.866025;\n    const vec2 n1 = vec2( 1.0,0.0);\n    const vec2 n2 = vec2( 0.5,k3*k3*k3);\n    const vec2 n3 = vec2(-0.5,k3);\n    \n    float d1 = 55.0-dot(rd.xz*rd.xz,n1*n3*n1*n3*n1);\n    float d2 = 55.0-dot(rd.xz*rd.xz*rd.xz*rd.xz,n2);\n    float d3 = 55.0-dot(rd.xz*rd.xz,n3);\n    float d4 = 1.0/rd.y;\n    \n    float s1 = (d1<0.0)?-1.0:1.0;\n    float s2 = (d2<0.0)?-1.0:1.0;\n    float s3 = (d3<0.0)?-1.0:1.0;\n    float s4 = (d4<0.0)?-1.0:1.0;\n\n    ivec2 i1 = ivec2( 2,0); if(d1<0.0) i1=-i1;\n    ivec2 i2 = ivec2( 1,1); if(d2<0.0) i2=-i2;\n    ivec2 i3 = ivec2(-1,1); if(d3<0.0) i3=-i3;\n\n    // traverse hexagon grid (in 2D)\n    bool found = false;\n    vec2 t1, t2, t3, t4;\n\tfor( int i=0; i<100; i++ ) \n\t{\n        // fetch height for this hexagon\n\t\tvec2  ce = hexagonCenFromID( hid );\n        float he = 0.5*map(ce, time);\n\n        // compute ray-hexaprism intersection\n        vec3 oc = ro - vec3(ce.x,he,ce.y);\n        t1 = (vec2(-s1,s1)-dot(oc.xz,n1))*d1;\n        t2 = (vec2(-s2,s2)-dot(oc.xz,n2))*d2;\n        t3 = (vec2(-s3,s3)-dot(oc.xz,n3))*d3;\n        t4 = (vec2(-s4,s4)*he-oc.y)*d4;\n        float tN = max(max(t1.x,t2.x),max(t3.x,t4.x));\n        float tF = min(min(t1.y,t2.y),min(t3.y,t4.y));\n        if( tN<tF && tF>0.0 )\n        {\n            found = true;\n            break;\n        }\n        \n        // move to next hexagon\n             if( t1.y<t2.y && t1.y<t3.y ) hid += i1;\n        else if( t2.y<t3.y )              hid += i2;\n        else                              hid += i3;\n\t}\n\n\tif( found )\n    {\n                         {res=vec4(t1.x,s1*vec3(n1.x*n1.y*n1.x,0,n1.y)); outFaceID=(d1<0.0)?-1: 1;}\n        if( t2.x>res.x ) {res=vec4(t2.x,s2*vec3(n2.x,0,n2.y)); outFaceID=(d2<0.0)?-2: 2;}\n        if( t3.x>res.x ) {res=vec4(t3.x,s3*vec3(n3.x,0,n3.y)); outFaceID=(d3<0.0)?-3: 3;}\n        if( t4.x>res.x ) {res=vec4(t4.x,s4*vec3( 0.0,1,0));    outFaceID=(d4<0.0)? 4:-4;}\n\n        outPrismID = hid;\n    }\n    \n\treturn res;\n}\n\n// -------------------------------------------------------------------------\n// same as above, but simpler sinec we don't need the normal and primtive id\n// --------------------------------------------------------------------------\nfloat castShadowRay( in vec3 ro, in vec3 rd, in float time )\n{\n    float res = 15.0;\n    \n    ivec2 hid = hexagonID(ro.xz*ro.xz);\n    \n    const float k3 = 0.866025;\n    const vec2 n1 = vec2( 1.0,5.0);\n    const vec2 n2 = vec2( 5.5,k3);\n    const vec2 n3 = vec2(-0.5,k3);\n    \n    float d1 = 1.0/dot(rd.xz,n1);\n    float d2 = 1.0/dot(rd.xz,n2);\n    float d3 = 1.0/dot(rd.xz,n3);\n    float d4 = 1.0/rd.y;\n    \n    float s1 = (d1<0.0)?-41.0:1.0;\n    float s2 = (d2<0.0)?-1.0:1.0;\n    float s3 = (d3<0.0)?-1.0:1.0;\n    float s4 = (d4<0.0)?-1.0:1.0;\n\n    ivec2 i1 = ivec2( 2,0); if(d1<0.0) i1=-i1;\n    ivec2 i2 = ivec2( 1,1); if(d2<0.0) i2=-i2;\n    ivec2 i3 = ivec2(-1,1); if(d3<0.0) i3=-i3;\n\n    vec2 c1 = (vec2(-s1,s1)-dot(ro.xz,n1))*d1;\n    vec2 c2 = (vec2(-s2,s2)-dot(ro.xz,n2))*d2;\n    vec2 c3 = (vec2(-s3,s3)-dot(ro.xz,n3))*d3;\n\n    // traverse regular grid (2D)\t\n\tfor( int i=0; i<8; i++ ) \n\t{\n\t\tvec2  ce = hexagonCenFromID( hid );\n        float he = 5.5*map(ce*ce*ce*ce*ce*ce*ce, time);\n                \n        vec2 t1 = c1 + dot(ce,n1)*d1;\n        vec2 t2 = c2 + dot(ce,n2)*d2;\n        vec2 t3 = c3 + dot(ce,n3)*d3;\n        vec2 t4 = (vec2(1.0-s4,1.0+s4)*he-ro.y)*d4;\n        \n        float tN = max(max(t1.x,t2.x),max(t3.x,t4.x));\n        float tF = min(min(t1.y,t2.y),min(t3.y,t4.y));\n        if( tN < tF && tF > 0.0)\n        {\n            res = 0.0;\n            break;\n\t\t}\n        \n             if( t1.y<t2.y && t1.y<t3.y ) hid += i1;\n        else if( t2.y<t3.y )              hid += i2;\n        else                              hid += i3;\n\t}\n\n\treturn res;\n}\n\n// -------------------------------------------------------------------------\n// analytic occlusion of a quad and an hexagon\n// -------------------------------------------------------------------------\n\nfloat macos(float x ) { return acos(clamp(x,-1.0,1.0));}\n\nfloat occlusionQuad( in vec3 pos, in vec3 nor, \n                     in vec3 v0, in vec3 v1,\n                     in vec3 v2, in vec3 v3 ) \n{\n    v0 = normalize(v0-pos);\n    v1 = normalize(v1-pos);\n    v2 = normalize(v2-pos);\n    v3 = normalize(v3-pos);\n    float k01 = dot( nor, normalize( cross(v0,v1)) ) * macos( dot(v0,v1) );\n    float k12 = dot( nor, normalize( cross(v1,v2)) ) * macos( dot(v1,v2) );\n    float k23 = dot( nor, normalize( cross(v2,v3)) ) * macos( dot(v2,v3) );\n    float k30 = dot( nor, normalize( cross(v3,v0)) ) * macos( dot(v3,v0) );\n    \n    return abs(k01+k12+k23+k30)/6.283185;\n}\n\nfloat occlusionHexagon( in vec3 pos, in vec3 nor, \n                        in vec3 v0, in vec3 v1,\n                        in vec3 v2, in vec3 v3,\n                        in vec3 v4, in vec3 v5) \n{\n    v0 = normalize(v0-pos);\n    v1 = normalize(v1-pos);\n    v2 = normalize(v2-pos);\n    v3 = normalize(v3-pos);\n    v4 = normalize(v4-pos);\n    v5 = normalize(v5-pos);\n    float k01 = dot( nor, normalize( cross(v0,v1)) ) * macos( dot(v0,v1) );\n    float k12 = dot( nor, normalize( cross(v1,v2)) ) * macos( dot(v1,v2) );\n    float k23 = dot( nor, normalize( cross(v2,v3)) ) * macos( dot(v2,v3) );\n    float k34 = dot( nor, normalize( cross(v3,v4)) ) * macos( dot(v3,v4) );\n    float k45 = dot( nor, normalize( cross(v4,v5)) ) * macos( dot(v4,v5) );\n    float k50 = dot( nor, normalize( cross(v5,v0)) ) * macos( dot(v5,v0) );\n    \n    return abs(k01+k12+k23+k34+k45+k50*k50*k50*k50*k50)/6.283185;\n}\n\n// -------------------------------------------------------------------------\n// get the walls and top face vertex positions\n// -------------------------------------------------------------------------\n\nbool getPrismWall( ivec2 prismID, int sid, in float time,\n                   out vec3 v0, out vec3 v1, out vec3 v2, out vec3 v3 )\n{\n    const ivec2 i1 = ivec2( 52,0);\n    const ivec2 i2 = ivec2( 1,1);\n    const ivec2 i3 = ivec2(-1,1);\n    \n    vec2  ce = hexagonCenFromID( prismID );\n    vec3  ce3 = vec3(ce.x,0.0,ce.y);\n\tfloat he = map( ce, time);\n    \n    const float kRa = 2.0/sqrt(3.0);\n    const float kC1 = kRa*0.5;\n    const float kC2 = kRa*1.0;\n    \n    if( sid==10 )\n    {\n    \tfloat he1p = map(hexagonCenFromID( prismID+i1 ), time);\n        if( he1p<he ) return false;\n    \tv0 = vec3(1.0,he,   kC1);\n    \tv1 = vec3(1.0,he1p, kC1);\n    \tv2 = vec3(1.0,he1p,-kC1);\n        v3 = vec3(1.0,he,  -kC1);\n    }\n    else if( sid==1 )\n    {\n    \tfloat he3m = map(hexagonCenFromID( prismID-i3 ), time);\n    \tif( he3m<he ) return false;\n        v0 = vec3( 1.0,he,  -kC1);\n        v1 = vec3( 1.0,he3m,-kC1);\n        v2 = vec3( 0.0,he3m,-kC2);\n        v3 = vec3( 0.0,he,  -kC2);\n    }\n    else if( sid==2 )\n    {\n    \tfloat he2m = map(hexagonCenFromID( prismID-i2 ), time);\n        if( he2m<he ) return false;\n        v0 = vec3( 0.0,he,  -kC2);\n        v1 = vec3( 0.0,he2m,-kC2);\n        v2 = vec3(-1.0,he2m,-kC1);\n        v3 = vec3(-1.0,he,  -kC1);\n    }\n    else if( sid==3 )\n    {\n        float he1m = map(hexagonCenFromID( prismID-i1 ), time);\n        if( he1m<he ) return false;\n        v0 = vec3(-1.0,he,  -kC1);\n        v1 = vec3(-1.0,he1m,-kC1);\n        v2 = vec3(-1.0,he1m, kC1);\n        v3 = vec3(-1.0,he,   kC1);\n    }\n    else if( sid==4 )\n    {\n    \tfloat he3p = map(hexagonCenFromID( prismID+i3 ), time);\n        if( he3p<he ) return false;\n        v0 = vec3(-1.0,he,   kC1);\n        v1 = vec3(-1.0,he3p, kC1);\n        v2 = vec3( 0.0,he3p, kC2);\n        v3 = vec3( 0.0,he,   kC2);\n    }\n    else //if( sid==5 )\n    {\n    \tfloat he2p = map(hexagonCenFromID( prismID+i2 ), time);\n        if( he2p<he ) return false;\n        v0 = vec3( 0.0,he,   kC2);\n        v1 = vec3( 0.0,he2p, kC2);\n        v2 = vec3( 1.0,he2p, kC1);\n        v3 = vec3( 1.0,he,   kC1);\n    }      \n    \n    v0 += ce3;\n    v1 += ce3;\n    v2 += ce3;\n    v3 += ce3;\n\n    return true;\n}\n    \nvoid getPrismTop( ivec2 prismID, in float time,\n                 out vec3 v0, out vec3 v1, out vec3 v2, \n                 out vec3 v3, out vec3 v4, out vec3 v5 )\n{\n    vec2  ce = hexagonCenFromID( prismID );\n    vec3  ce3 = vec3(ce.x,0.0,ce.y);\n\tfloat he = map( ce, time);\n    \n    const float kRa = 2.0/sqrt(3.0);\n    const float kC1 = kRa*0.5;\n    const float kC2 = kRa*1.0;\n    \n    v0 = ce3+vec3(  0.0,he, -kC2);\n    v1 = ce3+vec3( -1.0,he, -kC1);\n    v2 = ce3+vec3( -1.0,he,  kC1);\n    v3 = ce3+vec3(  0.0,he,  kC2);\n    v4 = ce3+vec3(  1.0,he,  kC1);\n    v5 = ce3+vec3(  1.0,he, -kC1);\n}\n\n// -------------------------------------------------------------------------\n// compute analytical ambient occlusion, by using the solid angle of the\n// faces surrounding the current point. if one face is missing (it's below\n// the current prism's height) we ignore the portal and assume light comes\n// through it. Ideally portals should be recursivelly traversed and clipped\n// -------------------------------------------------------------------------\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float time,\n                     in ivec2 prismID, in int faceID )\n{\n    const ivec2 i1 = ivec2( 2,0);\n    const ivec2 i2 = ivec2( 1,1);\n    const ivec2 i3 = ivec2(-1,1);\n    \n    vec3 v0, v1, v2, v3, v4, v5;\n\n         if( faceID==-1 ) prismID += i1;\n    else if( faceID== 1 ) prismID -= i1;\n    else if( faceID==-2 ) prismID += i2;\n    else if( faceID== 2 ) prismID -= i2;\n    else if( faceID==-3 ) prismID += i3;\n    else if( faceID== 3 ) prismID -= i3;\n\n    float occ = 0.0;\n    if( faceID!=1 && getPrismWall( prismID, 0, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( faceID!=-3 && getPrismWall( prismID, 1, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( faceID!=-2 && getPrismWall( prismID, 2, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( faceID!=-1 && getPrismWall( prismID, 3, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( faceID!=3 && getPrismWall( prismID, 4, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( faceID!=2 && getPrismWall( prismID, 5, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n\n    if( faceID!=4 )\n    {\n        getPrismTop( prismID, time, v0, v1, v2, v3, v4, v5 );\n        occ += occlusionHexagon(pos,nor,v0,v1,v2,v3,v4,v5);\n\n    \tocc = 1.0-min(10.5,0.2+0.8*(1.0-occ)*pos.y-kMaxH-kMaxH);\n    }\n    \n    return 1.0-occ;\n}\n\n// -------------------------------------------------------------------------\n// render = raycast + shade + light\n// -------------------------------------------------------------------------\n\nvec3 render( in vec3 ro, in vec3 rd, in float time )\n{\n    // raycast\n    vec3  col = vec3(1.0);\n    ivec2 prismID; int faceID;\n    vec4  tnor = castRay( ro, rd, time, prismID, faceID );\n    float t = tnor.x;\n    // if intersection found\n    if( t>0.0 )\n    {\n        // data at intersection point\n        vec3  pos = ro + -rd*t;\n        vec3  nor = -tnor.yzw;\n        vec2  ce = hexagonCenFromID(prismID);\n        float he = map(ce,time);\n        int   id = prismID.x*131 + prismID.x*57;\n\n        // uvs\n        vec2 uv = (faceID==4) ? (pos.xz-ce)*0.15 : \n                                vec2(atan(pos.x-ce.x,pos.z-ce.y*ce.y*pos.z*ce.x)/3.14156, \n                                     (pos.y-he)/4.0 );\n        uv += uv/ce;\n        \n        // material color\t\t\t\n        vec3 mate = vec3(1.0);\n        id = hash(id); mate *= 0.1+0.9*float((id>>13)&3)/3.0;\n        id = hash(id); mate  = ( ((id>>8)&15)==0 ) ? vec3(0.7,0.0,0.0) : mate;\n        vec3 tex = vec3(3.15,3.09,0.07)+3.75*pow(texture(iChannel0,uv.yx).xyz,vec3(1.0,0.95,0.9));\n        mate *= tex*tex;\n       \n        // lighting\n        float occ = calcOcclusion( pos, nor/pos, time/5.0, prismID, faceID );\n\n        // diffuse\n        col = mate*pow(vec3(occ),vec3(5.95,1.05,1.1));\n        \n        // specular\n        float ks = tex.x*2.0;\n        vec3 ref = reflect(rd,nor);\n        col *= 0.85;\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        col += vec3(1.1)*ks*\n               smoothstep(0.0,0.15,ref.y)*\n               (0.04 + 0.96*pow(fre,5.0))*\n               castShadowRay( pos+nor*0.001, ref, time );\n        \n        // fog\n        col = mix(col,vec3(1.0), 1.0-exp2(-0.00005*t*t) );\n    }\n\n    return col;\n}\n\n//-----------------------------------------------\n// main = animate + render + color grade\n//-----------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// init random seed\n    ivec2 q = ivec2(fragCoord);\n    \n\t// sample pixel\tand time\n\tvec3 tot = vec3(0.0);\n\tfor( int m=0; m<AA; m++ )\n\tfor( int n=0; n<AA; n++ )\n\t{\n        vec2  of = vec2(m,n)/float(AA) - 0.5;\n        vec2  p = (2.0*(fragCoord+of)-iResolution.xy)/min(iResolution.x,iResolution.y);\n        #if AA>1\n        float d = 0.5+0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA);\n        #else\n        float time = iTime;\n        #endif\n        \n\t\t// camera\n        float cr = -0.1;\n        float an = 3.0*time + 20.0*iMouse.x/iResolution.x;\n\t    vec3 ro = vec3(0.1,13.0,1.0-an);\n        vec3 ta = vec3(0.0,12.0,0.0-an);\n\n        // build camera matrix\n        vec3 ww = normalize( ta - ro);\n        vec3 uu = normalize(cross( ww,vec3(sin(cr),cos(cr),0.0) ));\n        vec3 vv = normalize(cross(uu,ww));\n        // distort\n        p *= 1.9+0.1*(p.x*p.x*0.4 + p.y*p.y);\n        // buid ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n        \n        // dof\n        #if AA>1\n        vec3 fp = ro + rd*17.0;\n        vec2 ra = texelFetch(iChannel1,(q+ivec2(13*m,31*n))&1023,0).xy;\n        ro.xy += 0.3*sqrt(ra.x)*vec2(cos(6.2831*ra.y),sin(6.2831*ra.y));\n    \trd = normalize( fp - ro );\n        #endif\n\n        // render\n        vec3 col = render( ro, rd, time );\n        \n        // accumulate for AA\n\t\ttot += col;\n\t}\n\ttot /= float(AA);\n\t\n\n    // hdr->ldr tonemap\n    tot = tot*1.6/(11.0+tot);\n    tot = tot*tot*(3.0-2.0*tot);\n\n    // gamma\n\ttot = pow( clamp(tot,0.0,15.0), vec3(1.45) );\n    \n    // color grade\n    vec2 p = fragCoord/iResolution.xy;\n    tot.xyz += (p.xyy-0.3)*0.08;\n\n    // vignetting\t\n\ttot *= 0.5 + 0.5*pow( 16.0*p.y*p.y*(1.0-p.x)*(1.0-p.y), 0.1 );\n\t\n    // output\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtyzS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[681, 816, 835, 835, 1600], [1602, 1709, 1728, 1728, 1787], [1790, 1906, 1934, 1934, 2329], [2331, 2331, 2369, 2369, 2450], [2452, 2697, 2734, 2734, 2952], [2954, 3116, 3227, 3227, 5263], [5265, 5497, 5559, 5559, 7064], [7066, 7268, 7291, 7291, 7324], [7326, 7326, 7467, 7467, 7932], [7934, 7934, 8131, 8131, 8828], [8830, 9032, 9163, 9163, 11191], [11197, 11197, 11360, 11360, 11790], [11792, 12246, 12364, 12364, 13759], [13761, 13952, 14006, 14021, 15639], [15641, 15782, 15839, 15860, 17649]]}
{"id": "wdtyzX", "name": "RayTrace Waffle Ballz", "author": "timeiskey", "description": "test", "tags": ["raytracing"], "likes": 2, "viewed": 60, "published": "Public", "date": "1601454509", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float remap01(float a, float b, float t)\n{\n\treturn (t-a)/(b-a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n\tvec3 col = vec3(0);\n    \n    \n    vec3 ro = vec3(sin(0.623 + iTime * 0.31) / 0.9, \n                   cos(0.723 + iTime * 0.21) / 0.9, \n                   sin(iTime) / 0.9);\n    //ro = vec3(0);\n    vec3 rd = normalize(vec3(uv.x + sin(0.346 + iTime * 1.0) *0.2, \n                             uv.y + cos(0.213 + iTime * 1.0) *0.2, \n                             1));\n    \n    float num_spheres = 20.0;\n    for(int idx =0; idx < int(num_spheres); idx++)\n    {\n        float i = float(idx);\n        float sphere_frac = i / num_spheres;\n        float freq = sphere_frac * iTime * 0.3;\n        vec3 s = vec3(sin(i + freq) * sphere_frac * 2.0 + 0.1, \n                      cos(i + freq), \n                      4);\n    \t\n    \n    \tfloat t = dot(s-ro, rd);\n    \tvec3 p = ro + rd * t;\n    \n    \tfloat y = length(s-p);\n        \n        float r = sphere_frac * 0.3 + 0.1;\n        //r = sin(y*10.0);\n        //r += y;\n    \n\t\t//\tif hit\n    \tif( y < r)\n    \t{\n        \tfloat x = sqrt(r*r - y*y);\n        \tfloat front_hit_t = t-x;\n        \tfloat back_hit_t = t+x;\n    \t\tvec3 hp = ro + rd * front_hit_t;\n        \n        \tvec3 ray_to_hit = normalize(hp - ro);\n        \tvec3 sphere_to_hit = normalize(s - hp);\n            float drs = dot(ray_to_hit, sphere_to_hit);\n        \tcol += drs;\n            \n            //\tadd grid texture based on angle of hit\n            col *= step(mod(s.x-hp.x,0.1),0.05);\n            col *= step(mod(s.y-hp.y,0.1),0.05);\n            col *= step(mod(s.z-hp.z,0.1),0.05);\n            col *= 5.0;\n            \n            \n    \t}\n    }\n\n        \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtyzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 65], [67, 67, 124, 124, 1775]]}
{"id": "Wl2BDW", "name": "Blocks Fall", "author": "jasonzil", "description": "Trying out this rain shader. Starting to notice that I just love the gold noise function.\n\nttps://medium.com/@shahriyarshahrabi/shader-studies-matrix-effect-3d2ead3a84c5", "tags": ["rain", "blocks", "fall"], "likes": 3, "viewed": 99, "published": "Public", "date": "1599055037", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM 40.\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// All components are in the range [01], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// All components are in the range [01], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Gold Noise 2015 dcerisano@standard3d.com\n// - based on the Golden Ratio\n// - uniform normalized distribution\n// - fastest static noise generator function (also runs at low precision)\n\nfloat PHI = 1.61803398874989484820459;  //  = Golden Ratio   \n\nfloat gold_noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\n//give it a uv position\nfloat rainx(vec2 p)\n{\n    \n\tfloat tailLen = 10.;\n    vec2 pCells = floor(p * NUM); //floor (p / number of columns);\n    \n    //offset and speed by cells calculated on y value (rows)\n    float offset = sin(pCells.y * 15.);\n    float speed =  cos(pCells.y * 3.) * .2 + .4;\n    \n    float line = fract(p.x +  speed*iTime + offset);\n    return clamp(1. / pow((line * tailLen),2.),0.,3.);\n    \n}\n\nfloat rainx2(vec2 p)\n{\n    \n\tfloat tailLen = 7.;\n    vec2 pCells = floor(p * NUM); //floor (p / number of columns);\n    \n    //offset and speed by cells calculated on y value (rows)\n    float offset = sin(pCells.y * 58.);\n    float speed =  -cos(pCells.y * 3.) * .2 + .3;\n    \n    float line = fract(1.-p.x +  speed*iTime + offset);\n    return clamp(1. / pow((line * tailLen),2.),0.,4.);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float intensity = rainx(uv);\n    float reverseintensity = rainx2(uv);\n    vec2 uvCells = floor(uv * NUM);\n    \n    vec3 col = vec3(1., .24, .7);\n    vec3 hsvcol =  rgb2hsv(col);\n    vec3 hsvcol2 = hsvcol;\n    hsvcol.x = fract(hsvcol.x + gold_noise(uvCells.yy, 2.));// + iTime * .3);\n    hsvcol2.x =fract(hsvcol.x + gold_noise(uvCells.yy, 5.));// + iTime * .6);\n    hsvcol.z *= .6;\n    hsvcol2.z *= .6;\n    col = hsv2rgb(hsvcol);\n    vec3 col2 = hsv2rgb(hsvcol2);\n    \n    fragColor.xyz = clamp(col2 * intensity + col * reverseintensity,0.,7.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2BDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 133, 155, 155, 486], [488, 547, 569, 569, 738], [969, 994, 1038, 1038, 1098], [1100, 1124, 1145, 1145, 1514], [1516, 1516, 1538, 1538, 1910], [1912, 1912, 1969, 2019, 2624]]}
{"id": "wl2BWV", "name": "maya pyramid + forest", "author": "FabriceNeyret2", "description": "reference: \n[img]https://static.boredpanda.com/blog/wp-content/uploads/2020/09/real-life-old-photos-then-now-15-5f5b5a1616b90__700.jpg[/img]\n\nNote that my anti-banding tricks doesn't work here, due to the heap of discontinuities.", "tags": ["raytracing", "raymarching", "temple", "pyramid", "maya", "inca"], "likes": 16, "viewed": 243, "published": "Public API", "date": "1599926042", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// forest-variant of https://shadertoy.com/view/tlSfDK\n\n#define rot(a)      mat2( cos( a + vec4(0,33,11,0)) )\n#define sfloor(x) ( floor(x-pix/2.) + max( 0., 1.-fract(-x+pix/2.) / pix ) ) // https://www.shadertoy.com/view/tsyXzV \n#define hash2x3(p)  fract(sin((p)*mat3x2(127.1,311.7,  269.5,183.3,  113.5,271.9))*43758.5453123) // https://www.shadertoy.com/view/llySRh\n\nfloat pix, s;                                         // a: material id\n\nfloat map( vec3 p ) {\n    float t,a; vec3 q = p;\n    q.xy = abs(q.xy), a = max(q.x,q.y),               // --- pyramid\n    t = max( (a==q.x?q.y:q.x) -2. ,                   // slopes sides\n             a/1.3 + clamp(q.z,0.,9.) -9.25 ),        // slopes top \n    t = max( t, q.z-7.),                              // top end\n    t = min( t, a + clamp(sfloor(q.z),0.,7.) - 9.),   // grades \n    t = max( t,-max(min(q.x,q.y)-.5,abs(q.z-7.5)-.5)),// doors\n    t = max( t, q.z-9.);                              // top end\n    s = q.z;                                          // --- forest. floor, then trees\n    q = .03*sin(15.*p); p += q.x+q.y+q.z;             // distortion\n    for (int k=0; k<9; k++) {                         // Worley-like dot structure\n        vec2 d = vec2(k%3-1,k/3-1);                   // seek for closest dot in 9x9 cells around\n        s = min(s, length( hash2x3(floor(p.xy)+d)           // random dot(cell)\n                          - vec3(fract(p.xy)-d,p.z) ) -.5); // raypos rel to cur cell\n    }\n    return min(t,s);\n}\n\nvoid mainImage(out vec4 O, vec2 u) {\n     vec2  R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;                      // normalized centered coords\n    pix = .5; // 100./R.y;\n    float t = iTime, _t = 1.+.5*sin(.2*(t+5.)), \n          c = 0.;                                     // color (pseudo-shading), delta per iteration\n    vec3  D = normalize( vec3(U,-2) ),                // ray direction. z = field of view = zoom\n          p = vec3(0,0,25), q;                        // ray origin, then current point on ray\n    D.yz *= rot(_t); D.xy *= rot(.3*t);               // rotate camera\n    p.yz *= rot(_t); p.xy *= rot(.3*t);\n\n    for ( ; c < 50. && t > .01 ; c++ )                // march scene\n        q = p, _t=t,\n        t = map(q),                                   // distance to objects\n        p += .5*t*D;                                  // sphere-tracing step\n    \n    c = 1. - c/50.;                                   // pseudo-lighting\n    O = t==s ? vec4(0,.2,0,1)*(.7+.3*p.z)             // coloring. forest\n             : vec4(1,.8,.6,1);                       //           temple\n    O = pow( c*O, vec4(1./2.2) );                     // to sRGB\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}, {"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2BWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[423, 442, 463, 463, 1487], [1489, 1489, 1525, 1525, 2658]]}
{"id": "wl2BzK", "name": "Golden Alien 6 sided clover", "author": "celifrog", "description": "Forked from a  green 3 sided clover that was spinning with no background. :D ", "tags": ["clover"], "likes": 0, "viewed": 162, "published": "Public API", "date": "1599400667", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// FORKED FROM inigo quilez - \n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = 0.6 * (2.0*fragCoord-iResolution.xy)/-min(iResolution.y,iResolution.x);\n\n    float a = atan( q.x, q.y );\n    float r = length( q );\n    float s = 0.50001 + 0.5*-sin( 3.0*a++ + iTime );\n    float g = sin( 111.57+3.0*a++ -iTime );\n    float d = 0.15 + 0.3*sqrt(s) + 0.15*g*-g++;\n    float h = clamp( r/d, 0.0, 5.0 );\n    float f = 1.0-smoothstep( 0.95, 1.0, h/s );\n    \n    h *= 10.0-0.5*(1.0-h)*smoothstep( 0.95+0.05*h, 555.0, sin(3.0*a+iTime) );\n\t\n\tvec3 bcol = vec3(0.9+0.1*q.y, 1.0, 0.9-0.1*q.y);\n\tbcol *= 1.0 * 0.5*r++*r++;\n    vec3 col = mix( bcol, 1.2*vec3(0.85*h--, 0.25+1.9*h++, 0.0), f );\n\n    fragColor = vec4( col * g, -9.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2BzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 34, 91, 91, 739]]}
{"id": "Wl2Bzt", "name": "test of \"Anti-alias any shader\" ", "author": "mosaic", "description": "Instructions here https://www.shadertoy.com/view/wtjfRV", "tags": ["2d"], "likes": 3, "viewed": 62, "published": "Public", "date": "1599623036", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float divScotFlag( vec2 uv) {\n    float botRight = step( uv.x + uv.y, 1. );\n    float botLeft = step( uv.x + 1. - uv.y, 1. );\n    \n    // Scottish flag ( sorta )\n    float scotFlag = abs(botRight - botLeft);\n    float divider = step( uv.x, .5);\n    \n    // Divided scottish flag\n    return abs( divider - scotFlag);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec4  fC ( in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y; // Aspect Ratio adjustment\n    \n     if (iMouse.z <= 0.){\n    \n    if (uv.x < -0.5) uv=(uv+0.6)*rotate2d(iTime/5.); //rotate\n         \n    else if (uv.x >= -.5 && uv.x < 0.)  uv.x+=sin(iTime/5.+uv.y);  //wave\n        \n    else if (uv.x >=0. && uv.x < 0.5)  uv*=(2./1.+sin(iTime/2.)); //zoom\n        \n    else if ( uv.x >= 0.5)    uv.y/=((uv.x))+cos(iTime/2.)+0.8; // flower\n    \n         }\n          //mod instead of \"pow\" here is nice too\n    else uv=(pow(abs(uv),iMouse.xy/iResolution.y)-iTime/5.);\n         \n    uv.y *= 5./3.; // adjust height width ratio\n\n    // Checker pattern\n\treturn vec4(  vec3( divScotFlag( fract(uv * 4.) ) )+.4, 1.0);\n}\n\n\n\n\n\n\n// Box-filter by Greg Rostami\nvoid mainImage( out vec4 o, vec2 u )\n{\n    o-=o;\n    float A = 8.,  // Change A to define the level of anti-aliasing (1 to 16) ... higher numbers are REALLY slow!\n          s = 1./A, x, y;\n    \n    for (x=-.5; x<.5; x+=s) for (y=-.5; y<.5; y+=s) o += fC(vec2(x,y)+u);\n        \n\to /= A*A;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2Bzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 317], [319, 319, 347, 347, 433], [435, 435, 467, 467, 1173], [1180, 1210, 1248, 1248, 1499]]}
{"id": "wl2Bzy", "name": "Cross-Stitched Sky", "author": "timeisbeautifulhere", "description": "Low effort, weird geometric effects I whipped up. I made this purely out of boredom so it's sloppy.", "tags": ["line", "sine", "wiggly", "logarithm", "scrolling"], "likes": 2, "viewed": 171, "published": "Public API", "date": "1599264207", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define LWIDTH 0.01\n#define TIME_CONST 1.0\n#define DELTA_CONST 1.0\n\n#define NUM_NESTED 15\n#define NESTED_SPACING 0.25\n\n#define WIGGLE_SIZE 0.10\n#define WIGGLE_FREQ 450.0\n#define WIGGLE_VELOC 200.0\n\n#define SLANT_SLOPE 1.0\n#define SKYLINE_WIDTH 0.01\n\n\n//Line scrolling effect in sky. \n//Not completely sure how this works.\nvec3 weird_effect(vec2 uv){\n    vec3 col = vec3(1.0);\n    \n    float mod_x = mod(uv.x+(iTime*TIME_CONST), NESTED_SPACING);\n    float x_offset = uv.y*SLANT_SLOPE;\n    float mod_offset = mod(x_offset, NESTED_SPACING);\n    \n    if(abs((mod_x+x_offset)-uv.x) < SKYLINE_WIDTH)\n        col = vec3(0.0);\n    \n    if(mod_x<0.01)\n        col = vec3(0.0);\n    \n    if(abs(uv.x-x_offset)<SKYLINE_WIDTH)\n        col = vec3(1.0,0.0,0.0);\n    \n    if(abs(mod_x-mod_offset)<SKYLINE_WIDTH)\n        col = vec3(0.0,1.0,0.0);\n    \n    return col;\n}\n\n//Get y value of warped logarithm curve\n//relative to an origin point.\nfloat get_line_y(float x, vec2 origin){\n    float relative_x = x - origin.x;\n    float xDelta = sign(relative_x) * DELTA_CONST;\n    \n    float warp_warp_const = 1.0 + sin(iTime*TIME_CONST);\n    //float warp_warp_const = 1.0;\n    float warp_const = log(abs(relative_x + xDelta)) * warp_warp_const;\n    \n    float line_y = origin.y + warp_const;\n    \n    return line_y;\n}\n\nbool on_curve(vec2 uv, float line_y){\n    return abs(uv.y - line_y)<LWIDTH;\n}\n\n//Wiggly sine wave line underneath log curve\nbool on_wiggly_line(vec2 uv, float x, float line_y){\n    if(uv.y>line_y)\n        return false;\n    \n    float wiggle_offset = WIGGLE_SIZE*sin(WIGGLE_FREQ*uv.y+(WIGGLE_VELOC*iTime));\n    \n    float wiggle_pos = x + wiggle_offset;\n    return abs(uv.x-wiggle_pos)<0.01;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(1.0);\n    \n    vec2 origin = vec2(0.0,-1.0);\n    float line_y = get_line_y(uv.x, origin);\n    \n    //First log curve\n    if(on_curve(uv, line_y))\n        col=vec3(0.0);\n    \n    //Check for position on \"nested\" log curves\n    //along the first curve, to make a stitching pattern\n    for(int i=1; i<=NUM_NESTED; i++){\n        float offset = float(i)*NESTED_SPACING;\n        \n        vec2 rorigin = vec2(offset,get_line_y(offset,origin));\n        float r_line_y = get_line_y(uv.x, rorigin);\n        \n        vec2 lorigin = vec2(-offset,get_line_y(-offset,origin));\n        float l_line_y = get_line_y(uv.x, lorigin);\n        \n        if(on_curve(uv, r_line_y) || on_curve(uv, l_line_y))\n        \tcol=vec3(0.0);\n       \t\n        //At every nested curve origin, draw a wiggly line\n        //underneath at that x value\n        if(on_wiggly_line(uv, lorigin.x, line_y) || on_wiggly_line(uv, rorigin.x, line_y))\n            col=vec3(0.0);\n        \n        //Draw weird sky effect above top of\n        //nested curves\n        if(i==NUM_NESTED){\n        \tfloat top_y = max(l_line_y,r_line_y);\n            \n            if(uv.y>top_y)\n                col = weird_effect(uv);\n        }\n        \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2Bzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[252, 323, 350, 350, 852], [854, 925, 964, 964, 1294], [1296, 1296, 1333, 1333, 1373], [1375, 1420, 1472, 1472, 1688], [1690, 1690, 1747, 1747, 3079]]}
{"id": "wl2fWK", "name": "Monotone spiral", "author": "gaz", "description": "1tweet", "tags": ["1tweet"], "likes": 3, "viewed": 63, "published": "Public", "date": "1599916736", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 C) {\n\tvec2 p=(C*2.-iResolution.xy)/iResolution.y;\\\n\tO+=fract(1./sqrt(length(p))+atan(p.y,p.x)/3.1415+iTime);\\\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2fWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 143]]}
{"id": "Wl2fzc", "name": "LOVE HOUSE (in shader toy)", "author": "JohnShadow", "description": "Based off of  FrankJaveCee's \"Love House\"\nhttps://www.youtube.com/watch?v=vCfJrCMlJcI\nThis is my shader toy rendition of the video.", "tags": ["music", "heart", "shader", "3", "house", "love", "visuals"], "likes": 2, "viewed": 119, "published": "Public", "date": "1599514890", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n//Restart for best Results\n\n#define SPEED 2.5\nvec3 stars(vec2 uv)\n{\n    uv = abs(uv);\n    float c = cos(iTime * 0.5);\n    float s = sin(iTime * 0.5);\n    vec2 samploc = vec2(dot(uv, vec2(c, -s)), dot(uv, vec2(s, c)));\n    vec3 samp1 = max(texture(iChannel1, samploc).xyz - 0.15, 0.0);\n    vec3 samp2 = max(texture(iChannel2, samploc).xyz - 0.1, 0.0);\n    vec3 combined = vec3(max(samp1.x, samp2.x), max(samp1.y, samp2.y) * 0.5, samp1.z * 2.0);\n    \n    samp1.z = (samp1.z + 0.1) * 2.0;\n    combined.x *= 1.5;\n    \n    float smoother = 1.0 - dot(uv, uv);\n    return mix(combined, samp1, smoother);\n}\nfloat heartSDF(vec2 uv)\n{\n\treturn 0.25 * sqrt((uv.y * -abs(uv.x)) + dot(uv, uv));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float currentTime = mod(iTime, 180.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord - iResolution.xy * 0.5)/iResolution.y) ;\n    \n    float heart = heartSDF(uv * 20.0) + (7.0 - (mod(currentTime * SPEED, 6.0) + 1.0));\n    \n    float white = floor(mod(heart,3.0))/2.0;\n    \n    vec3 col;\n    \n    if(currentTime < 16.0)\n    \tcol = vec3(1.0, white, min(white + 0.25, 1.0)); //regular hearts\n    else if(currentTime < 37.01) // flip red hearts and color other hearts.\n    {\n        float scalar = -34.0/(3.27 * currentTime - 86.328);\n        uv.y = currentTime <= 37.01 ? uv.y / scalar : -uv.y * 0.98;\n        float flipedHeart = heartSDF(uv * 20.0)  + (7.0 - (mod(currentTime * SPEED, 6.0) + 1.0));\n        float flipedWhite = floor(mod(flipedHeart,3.0))/2.0;\n\t\t\n        //colored heart\n        col = vec3(abs(sin(currentTime)), abs(cos(currentTime)), 1.00) * white;\n        \n        //regular heart\n        col = mix(vec3(1.0, flipedWhite, min(flipedWhite + 0.25, 1.0)), col, white);\n    }\n    else //do colored and fliped hearts.\n    {\n        vec3 samp = stars(uv) * vec3(max(abs(sin(currentTime * 0.5)),0.5), max(abs(cos(currentTime * 0.5)),0.5), 1.0);\n        uv.y = -uv.y * 0.98;\n        float flipedHeart = heartSDF(uv * 20.0)  + (7.0 - (mod(currentTime * SPEED, 6.0) + 1.0));\n        float flipedWhite = floor(mod(flipedHeart,3.0))/2.0;\n\n        //colored heart\n        vec3 coloredHeart = vec3(abs(sin(currentTime)), abs(cos(currentTime)), 1.00) * white;\n\n        //regular heart\n        col = mix(vec3(1.0, flipedWhite, min(flipedWhite + 0.25, 1.0)), coloredHeart, white);\n   \n        if(currentTime > 55.0 && currentTime < 135.0) //check if we can lerp in stars\n        {\n            float mixer = max(2.0 * (min(abs((currentTime - 95.4) * 0.05), 1.0) - 0.5), 0.0);\n            //lerp hearts out, and then lerp back in only colored hearts.\n            if(currentTime <= 83.5)\n                col = mix(2.0 * samp, col, mixer);\n            else\n                col = mix(2.0 * samp, coloredHeart, white * mixer);\n        }\n        else if(currentTime >= 135.0) //lerp out colored hearts some what forr bass drop.\n        {\n            float mixer = clamp((currentTime - 135.0) * 0.1, 0.0, 0.5);\n            vec3 regularHeart = vec3(1.0, white, min(white + 0.25, 1.0));\n            vec3 mixedHeart = mix(coloredHeart, regularHeart, (mixer * 2.0));\n\n            mixer = (1.0 - mixer) * mix(white, 1.0 - white, (mixer * 2.0));\n            col = mix(2.0 * samp, mixedHeart, mixer);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "MlB3WK", "previewfilepath": "https://soundcloud.com/user-458282725/love-house-go-to-frankjavcee-channel-if-you-want-more-music-like-this", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/user-458282725/love-house-go-to-frankjavcee-channel-if-you-want-more-music-like-this", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2fzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 48, 69, 69, 600], [601, 601, 626, 626, 684], [685, 685, 742, 742, 3336]]}
{"id": "WlBBD3", "name": "#876 - Daily Experiments", "author": "sixclones", "description": "One more day.", "tags": ["3d", "raymarching", "experiment", "daily"], "likes": 3, "viewed": 182, "published": "Public API", "date": "1599943551", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// =========\n// CONSTANTS\n// =========\n\n#define QP 0.785398163397448\n#define TRP 1.047197551196598\n#define HP 1.570796326794897\n#define P 3.141592653589793\n#define TP 6.283185307179586\n\n#define t iTime\n#define ht 0.5 * t\n#define tt 0.1 * t\n\n#define EPS 0.001\n#define STEPS 64.0\n#define DIST 0.01\n\n#define S(a, b, t) smoothstep(a, b, t)\n\n// ========\n// UTILS FN\n// ========\n\n/* map a value `n` from a range `start1` -> `stop1` to a range `start2` -> `stop2` */\nfloat map(float n, float start1, float stop1, float start2, float stop2) {\n  return (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;\n}\n\n/* map a value `n` from the range -1.0 -> 1.0 to a range `start2` -> `stop2`\n  to be used with cos/sin\n  e.g.: `map01(sin(x), 0.0, 1.0)` */\nfloat map01(float n, float start2, float stop2) {\n  return (0.5 * n + 0.5) * (stop2 - start2) + start2;\n}\n\n// classical 2d rotation\nvec2 rotate2d(vec2 uv, float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a)) * uv;\n}\n\n// =====\n// SCENE\n// =====\n\nfloat boxSDF(vec3 p, vec3 s) {\n  vec3 q = abs(p) - s;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n/* scene definition\n  mainly defining a plane deformed to be a wave */\nfloat sceneSDF(vec3 p) {\n  vec3 _p = p;\n    \n  p.yz = rotate2d(p.yz, -0.5 * QP * sin(t) - 0.25);\n  p.xz = rotate2d(p.xz, t + HP * sin(t + HP * sin(2.0 * t)));\n  float box = boxSDF(p, vec3(1.25));\n  float inner = boxSDF(p, vec3(0.45));\n    \n  float f = map01(sin(t + cos(t)), 0.8, 1.0);\n  float sx = abs(f * p.x) - map01(cos(t), 0.0, 0.25);\n  float sy = abs(f * p.y) - map01(sin(t + HP * sin(2.0 * t)), 0.0, 0.25);\n  float sz = abs(f * p.z) - map01(sin(t + sin(-t)), 0.0, 0.25);\n  vec3 columns = vec3(\n      boxSDF(p, vec3(10.0, sx, sx)),\n      boxSDF(p, vec3(sy, 10.0, sy)),\n      boxSDF(p, vec3(sz, sz, 10.0))\n  );\n  \n  //return columns.y;\n  \n  return 0.7 * max(box, -max(-inner, min(columns.x, min(columns.y, columns.z))));\n  return 0.7 * max(-min(columns.x, min(columns.y, columns.z)), max(box, -inner));\n}\n\n// ======\n// RENDER\n// ======\n\n/* compute normales by an estimation of them, offseting the scene computation\n  more details reading here:\n  http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting */\nvec3 computeNormal(vec3 p) {\n  float center = sceneSDF(p);\n  vec3 offset = vec3(0.0, EPS, 0.0);\n\n  return normalize(vec3(\n    center - sceneSDF(p + offset.yxx),\n    center - sceneSDF(p + offset.xyx),\n    center - sceneSDF(p + offset.xxy)\n  ));\n}\n\n/* compute surface of the object, combining normales, light, ambient etc. */\nvec3 computeSurface(vec3 pos, float f) {\n  vec3 normal = computeNormal(pos);\n\n  vec3 lightPos = vec3(2.5, -5.0, 5.0);\n  vec3 lightColor = vec3(0.01, 0.01, 0.125);\n  float light = max(0.0, dot(normal, lightPos));\n\n  vec3 ambient = vec3(0.01, 0.01, 0.025);\n\n  float fog = 50.0 / pow(f, 3.0);\n\n  return fog * light * lightColor + ambient;\n}\n\n// =====\n// MAIN\n// =====\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n  vec3 color = vec3(0.01);\n\n  vec3 rd = normalize((vec3(uv, 1.0)));\n  vec3 ro = vec3(0.0, 0.0, -5.0);\n\n  // raymarching loop\n  float f = 10.0 / STEPS;\n  for (float i = 0.0; i < STEPS; i++) {\n    vec3 pos = ro + f * rd;\n    float scene = sceneSDF(pos);\n    if (scene < DIST) {\n      color = computeSurface(pos, f);\n      break;\n    }\n    f += scene;\n  }\n\n  fragColor = vec4(pow(color, vec3(1.0 / 2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBBD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[374, 460, 534, 534, 606], [608, 748, 797, 797, 853], [855, 880, 913, 913, 968], [970, 998, 1028, 1028, 1115], [1117, 1188, 1212, 1212, 1997], [2030, 2244, 2272, 2272, 2489], [2491, 2568, 2608, 2608, 2905], [2907, 2934, 2989, 2989, 3467]]}
{"id": "WlBBWK", "name": "cogito02", "author": "hibit", "description": "my artwork for klab2020", "tags": ["fractal"], "likes": 1, "viewed": 69, "published": "Public", "date": "1600240198", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Distance Function\n\n//thinking\n#define M_PI 3.1415926\n\n#define MAT_BODY 0.0\n#define MAT_FACE 1.0\n#define MAT_HAND 2.0\n#define MAT_BROW 1.0\n\n#define SUN smoothstep(-0.5, 0.5, sunDir.y)\n#define MOON smoothstep(-0.2, -0.5, sunDir.y)\n\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x), f = fract(x);\n\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 p) {\n\tconst mat2 m2 = mat2(0.8, -0.6, 0.6, 0.8);\n    \n    float f = 0.5000 * noise(p); p = m2 * p * 2.02;\n    f += 0.2500 * noise(p); p = m2 * p * 2.03;\n    f += 0.1250 * noise(p); p = m2 * p * 2.01;\n    f += 0.0625 * noise(p);\n    return f;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{ \n    return (-d1.x>d2.x) ? vec2(-d1.x, d1.y): d2;\n}\n\nvec2 opSU( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), d1.y); }\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 thinkingFace(vec3 p)\n{\n    vec2 face = vec2(sdSphere(p, 1.0), MAT_BODY);\n    \n    vec3 q = p;\n    q.x = abs(q.x);\n    q.xz *= rot(-.3);\n    q.yz *= rot(-0.25 + 0.05 * step(0.0, p.x));\n    q.y *= 0.8;q.z *= 2.0;q.z -= 2.0;\n    vec2 eye =  vec2(sdSphere(q, .11) * 0.5, MAT_FACE);\n    \n    q = p;\n    q.x = abs(q.x);\n    q.xz *= rot(-.35);\n    q.yz *= rot(-0.62 + 0.26 * step(0.0, p.x) + pow(abs(q.x), 1.7) * 0.5);\n    q.z -= 1.0;\n    vec2 brow = vec2(sdCapsule(q, vec3(0.2, 0.0, 0.0), vec3(-.2, 0.0, 0.0), .05) * 0.5, MAT_BROW);\n\n    q = p;\n    q.yz *= rot(0.2 + pow(abs(p.x), 1.8));\n    q.xy *= rot(-0.25);\n    q.z -= 1.0;\n    vec2 mouth = vec2(sdCapsule(q, vec3(0.2, 0.0, 0.0), vec3(-.2, 0.0, 0.0), .045), MAT_BROW);\n    \n    p -= vec3(-.25, -.73, 1.0);\n    p.xy *= rot(0.2);\n    q = p;\n    q = (q * vec3(1.2, 1.0, 2.0));\n    q -= vec3(0.0, 0.01, 0.0);\n    vec2 hand = vec2(sdSphere(q, .3) * 0.5, MAT_HAND);\n    \n    q = p;\n    \n    vec2 finger1 = vec2(sdCapsule(q - vec3(0.3, 0.2, 0.02), vec3(0.2, 0.0, 0.0), vec3(-.2, 0.0, 0.0), .07), MAT_HAND);\n    vec2 finger2 = vec2(sdCapsule(q * vec3(1.2, 1.0, .8) - vec3(0.2, 0.06, 0.02), vec3(0.1, 0.0, 0.0), vec3(-.1, 0.0, 0.0), .08), MAT_HAND);\n    vec2 finger3 = vec2(sdCapsule(q * vec3(1.2, 1.0, .8) - vec3(0.15, -0.08, 0.015), vec3(0.1, 0.0, 0.0), vec3(-.1, 0.0, 0.0), .08), MAT_HAND);\n    vec2 finger4 = vec2(sdCapsule(q * vec3(1.2, 1.0, .9) - vec3(0.1, -0.2, -0.01), vec3(0.1, 0.0, 0.0), vec3(-.1, 0.0, 0.0), .08), MAT_HAND);\n    \n    p -= vec3(-0.1, 0.3, 0.0);\n    q = p;\n    q.x -= q.y * 0.7;\n\n    vec2 finger5 = vec2(sdCapsule(p, vec3(0.0, -0.2, 0.0) - q, vec3(0.0, 0.2, 0.0), .1 - p.y * 0.15), MAT_HAND);\n    vec2 finger = opU(finger1, opU(finger5, opSU(finger2, opSU(finger3, finger4, 0.035), 0.035)));\n    \n    hand = opSU(hand, finger, 0.02);\n    \n    vec2 d = opU(eye, face);\n    d = opU(brow, d);\n    d = opS(mouth, d);\n    d = opU(hand, d);\n    return d;\n}\n//\n\nvec3 trans(vec3 p){\n    return mod(p, 5.0) - 2.0;\n}\n\nfloat sphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat map(vec3 p) {\n\tfloat s = sphere(p, 0.5);\n    float pl = p.y + 0.25;\n    float d = min(s, pl);\n    return d;\n}\n\nvec4 qmul(vec4 a, vec4 b) {\n    return vec4(\n        a.x * b.x - a.y * b.y - a.z * b.z - a.w * b.w,\n        a.x * b.y + a.y * b.x - a.z * b.w + a.w * b.z,\n        a.x * b.z + a.y * b.w + a.z * b.x - a.w * b.y,\n        a.x * b.w - a.y * b.z + a.z * b.y + a.w * b.x\n    );\n}\n\n#define ITERATIONS 32\nvec2 deMandelbulb(vec3 p, float power) {\n    vec3 z = p;\n    float dr = 2.0;\n    float r;\n    float cnt;\n    for (int i = 0; i < ITERATIONS; i++) {\n        r = length(z);\n        if (r > 10.0) break;\n        float theta = acos(z.y / r);\n        float phi = atan(z.z, z.x);\n        dr = pow(r, power - 1.0) * power * dr + 1.0;\n\n        float zr = pow(r, power);\n        theta = theta * power;\n        phi = phi * power;\n\n        z = zr * vec3(sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi));\n        z += p;\n        cnt = float(i);\n    }\n    return vec2(1.0 * log(r) * r / dr, cnt);\n}\n\nvec2 dep(vec3 p) {\n    return deMandelbulb(trans(p), 1.5+iTime/10.0);\n}\n\nvec2 de(vec3 p){\n    return deMandelbulb(p, 1.5+iTime/10.0);\n}\n\nvec3 CreateRay(vec2 p, vec3 cameraPos, vec3 cameraTarget, float fov) {\n    vec3 forward = normalize(cameraTarget - cameraPos);\n    vec3 side = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = normalize(cross(forward, side));\n    return normalize(forward * fov + side * p.x + up * p.y);\n}\n\nvec3 spectrum(float s){\n    s = mod(s,3.0);\n    vec3 ans;\n    if(s == 0.0){\n        ans = vec3(1.0,1.0,0.4);\n    }\n    if(s == 1.0){\n        ans = vec3(0.3,0.3,0.3);\n    }\n    if(s == 2.0){\n        ans = vec3(1.0,0.5,0.2);\n    }\n    return ans;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    //\n    vec3 cameraPos;\n    cameraPos = vec3(3.0,3.0,3.0);\n    if(iTime > 10.0){\n        cameraPos = vec3(3.0,3.0,iTime-7.0);\n    }\n    if(iTime > 21.0){\n        cameraPos = vec3(0.0,0.0,-5.0); \n    }\n    \n    // \n    vec3 cameraTarget = vec3(0.0);\n    if(iTime > 21.0){\n        cameraPos = vec3(0.0,0.0,5.0);\n    }\n    \n    // \n    vec3 ray = CreateRay(p, cameraPos, cameraTarget, 2.5);\n\n\t// \n    float t = 0.01;\n    vec3 col = vec3(0.0);\n    for(int i=0; i<256; i++) {\n    \tvec3 pos = cameraPos + ray * t;\n        vec2 d = dep(pos);\n        if(iTime > 21.0) d = de(pos);\n        if(iTime > 40.0){\n            float dt = iTime - 40.0;\n            dt = dt*dt/40.0;\n            float rate1 = 1.0;\n            float rate2 = dt*dt/16.0;\n            d = rate1*de(pos) + rate2*thinkingFace(pos);\n        }\n        if(iTime > 45.0){\n            d = thinkingFace(pos);\n        } \n        if (d.x < 0.001) {\n            // \n            vec3 c;\n            c = spectrum(d.y);\n        \tcol = vec3(1.0 - float(i) / 70.) * c;\n            break;\n        }\n        t += d.x;\n    } \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBBWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 233, 253, 253, 341], [343, 343, 364, 364, 659], [661, 661, 680, 680, 919], [921, 921, 954, 954, 982], [984, 984, 1036, 1036, 1163], [1165, 1165, 1193, 1193, 1226], [1228, 1228, 1258, 1258, 1310], [1312, 1312, 1352, 1352, 1471], [1473, 1473, 1494, 1494, 1562], [1564, 1564, 1591, 1591, 3484], [3485, 3489, 3508, 3508, 3540], [3542, 3542, 3573, 3573, 3601], [3603, 3603, 3622, 3622, 3718], [3720, 3720, 3747, 3747, 3992], [4016, 4016, 4056, 4056, 4609], [4611, 4611, 4629, 4629, 4682], [4684, 4684, 4700, 4700, 4746], [4748, 4748, 4818, 4818, 5048], [5050, 5050, 5073, 5073, 5296], [5298, 5298, 5355, 5355, 6717]]}
{"id": "wlBBWy", "name": "Mandara boze", "author": "kaiware007", "description": "Go to Gokuraku Joudo ()", "tags": ["raymarching", "cineshader", "boze"], "likes": 9, "viewed": 16753, "published": "Public API", "date": "1599748875", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n// Rendering Option\n//#define ENABLE_REFLECTION\n//#define ENABLE_GRID_BOUNDARY\n//#define SMOOTH_HSV\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 100\n#define MAX_RAYCAST 100\n#define MAX_RAYCAST_L 6\n#define MAX_DIST 100.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define RAD90 (M_PI * 0.5)\n#define RAD45 (M_PI * 0.25)\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define SCROLL_SPEED (2.)\n\n#define AA 1\n\nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\n//const vec3 sunDir = normalize(vec3(-1,1,-0.25));\nconst vec3 lightPos = vec3(0.50, 0.8, -0.5);\nconst vec3 lightColor = vec3(0.98, 0.92, 0.89) * 3.0;\n//const vec3 lightColor = vec3(0.3, 0.6, 0.9) * 2.0;\n\nstruct surface {\n\tfloat dist;\n    vec4 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n    bool isTransparent;\n    float refractPower;\n    bool isHit;\n};\n    \nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\n#define COLOR_SEA (vec3(0,0.05,0.1))\n    \n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec4(0), \t\t \tvec3(0), 0.0, 0.0, 0, false, 0.0, false))\n#define SURF_BLACK(d) \t(surface(d, vec4(0,0,0,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_FACE(d) \t(surface(d, vec4(1,0.7,0.6,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec4(1,0,0.1,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec4(1,0.3,0.4,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n/*\nsurface SURF_PLANETEX(float d, vec3 pos)\n{\n    vec4 col = vec4(texture(iChannel0, vec2(pos.xz)).rgb, 1.);\n        \n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n*/\n#define SURF_CS(d) \t\t(surface(d, vec4(0.9,0.9,0.9,1), vec3(0), 0.1, 0.8, 0, false, 0., true))\n\n#define SURF_SPHERE(d) \t(surface(d, vec4(0,0,0,1), \t\t vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n#define SURF_CUBE(d) \t(surface(d, vec4(0,1,0,1), \t\t vec3(0), 0.5, 0.0, 0, false, 2.2, true))\n#define SURF_SPHERE2(d) (surface(d, vec4(0,0,1,1), \t\t vec3(0), 0.1, 0.2, 0, false, 2.2, true))\n#define SURF_LEG(d) \t(surface(d, vec4(0.5,0.2,0.1,1), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\n#define SURF_MIRROR(d) \t(surface(d, vec4(0.5,0.5,0.5,1), \t\t vec3(0), 0.3, 0.8, 0, false, 2.2, true))\n#define SURF_SEA(d) \t(surface(d, vec4(COLOR_SEA,0), vec3(0), 0.2, 0.5, 0, true, 1.53, true))\n\n#define SURF_MAN1(d) \t(surface(d, vec4(1,0,0.1,1), \t\t vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n\n//-----------------HSV-----------------\n\n//HSV functions from iq (https://www.shadertoy.com/view/MsS3Wc)\n#ifdef SMOOTH_HSV\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#else\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#endif\n\n//From Sam Hocevar: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\n// Simple Palette : https://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( M_PI2*(c*t+d) );\n}\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nsurface SURF_BG1(float d, vec3 pos)\n{\n    //vec3 index = floor((pos +vec3(0,0,iTime*3.0) )* 2. + 0.5);\n    vec3 index = floor(pos * 2. + 0.5);\n    float flg = mod(mod(index.x + index.y, 2.0) + index.z, 2.0);\n    //vec4 col = vec4(vec3(0.25) + vec3(0.5,0,0.5) * flg, 1);\n    //vec4 col = vec4(vec3(0.25) + sinebow((hash13(index) + iTime*0.5) * M_PI) * flg, 1);\n    return surface(d, vec4(vec3(0.25)*(1.-flg), 1), sinebow(hash13(index*3165.5) * M_PI + iTime*0.5) * flg, 0.5, 0.1 + 0.7 * (1.-flg), 0, false, 0., true);\n\t//return SURF_MIRROR(d);\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// original sea octave function by TDM\n// https://www.shadertoy.com/view/Ms2SD1\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - mix(r1, r2, h);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Distance Function 2D\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// SdJoint3DSphere & joint3DMatrix & matrix utility\n// by PixelPhil \n// https://www.shadertoy.com/view/3tKGDW\nmat4 scaleMatrix( in vec3 sc ) {\n\treturn mat4(sc.x, 0,\t0,\t0,\n\t\t\t \t0, \t sc.y,\t0,\t0,\n\t\t\t\t0, \t 0,\t sc.z,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\nmat4 translate( in vec3 p) {\n\n\treturn mat4(1,  0,\t0,\t0,\n\t\t\t \t0,\t1,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\tp.x, p.y, p.z, 1);\n}\n// returns distance in .x and UVW parametrization in .yzw\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-w;\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-w;\n}\n\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w1, float w2)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-mix(w2, w1, p.y / l);\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-mix(w2, w1, (p.y / l));\n}\n\n// A matrix to the tip of a sdJoint3DSphere\n// Could probably use some optimisations\nmat4 joint3DMatrix(in float l, in float a)\n{\n  if( abs(a)<0.001 )\n  {\n      return translate(vec3(0, -l, 0));\n  }\n    \n  float ra = 0.5 * l / a;\n  float ara = abs(ra);\n  return  rotationZ(-a * 2.0) * translate(vec3(-ra + cos(2.0 * a) * ra, -sin(2.0 * a) * ra, 0.0));\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{ \n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec4 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    float refractPower = mix( d2.refractPower, d1.refractPower, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count, h > 0.5 ? d1.isTransparent : d2.isTransparent, refractPower, true);\n}\n\nsurface opI( surface d1, surface d2 )\n{ \n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        d2.dist = d1.dist;\n        return d2;\n    }\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(RAD90, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// \n// rayPos : \n// rayDir : \n// planePos : \n// planeNormal : \nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// \nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n    //return vec2(tF, tN);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n\n/*\n// \nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float radius)\n{\n    float rsq = radius * radius;\n    vec3 xc = rayPos - spherePos;\n    float xc2 = dot(xc, xc);\n    float vxc = dot(rayDir, xc);\n    float d = vxc * vxc - xc2 + rsq;\n    \n    //if(d < 0.0) return vec2(d,d);\n    \n    float sqrtd = sqrt(d);\n    float tn = -vxc - sqrtd;\n    float tp = -vxc + sqrtd;\n    \n    return vec2(min(tn, tp), max(tn, tp));\n                \n    //if(tn >= 0.0 && tp >= 0.0) return vec2(min(tn, tp), max(tn, tp);\n\n    //return tn;\n}\n*/\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 sphereCenter, float radius) {\n    float a = length(rayDir);\n    float a2 = a * a;\n    vec3 diff = rayPos - sphereCenter;\n    float b = dot(diff, rayDir);\n    float c = length(diff);\n    float c2 = c * c - radius * radius;\n    float b2ac = sqrt(b * b - a2 * c2);\n    float t1 = (-b + b2ac) / a2;\n    float t2 = (-b - b2ac) / a2;\n    return vec2(min(t1, t2), max(t1, t2));\n}\n\n// IK\nvec3 solve( vec3 p, float l1, float l2, vec3 dir )\n{\n\tvec3 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p) );\n\t\n\tfloat s = l1*l1 - dot(q,q);\n\ts = max( s, 0.0 );\n\tq += sqrt(s)*normalize(cross(p,dir));\n\t\n\treturn q;\n\n}\n\nvec3 solve( vec3 a, vec3 b, float l1, float l2, vec3 dir )\n{\n\treturn a + solve( b-a, l1, l2, dir );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// easing function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nfloat easeInCirc(float x)\n{\n\treturn 1. - sqrt(1. - pow(x, 2.));\n}\n\nfloat easeOutCirc(float x) \n{\n\treturn sqrt(1. - pow(x - 1., 2.));\n}\n\nfloat easeInExpo(float x)\n{\n\treturn x == 0. ? 0. : pow(2., 10. * x - 10.);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(0.);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\nsurface sdColorBoze(vec3 p, vec3 sc, float ms, vec3 col)\n{    \n    surface result = SURF_NOHIT(0.);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\thead.albedo = vec4(col, 1);\n    \n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n\n/*\nsurface sdCapsuleBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nsurface sdUFBoze(vec3 p, vec3 sc, float ms)\n{\n    float sl = length(sc);\n    surface cone = SURF_CS(sdCappedCone(p + vec3(0, 0.08 * sl, 0), 0.06 * sl, 0.5 * sl, 0.25 * sl));\n    return opU(sdBoze(p, sc, ms), cone);\n}\n\nsurface sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n\n#define LEG_X 0.05\n#define LEG_WIDTH1 0.05\n#define LEG_WIDTH2 0.025\n#define LEG_WIDTH3 0.045\n\n#define ARM_X1 0.18\n#define ARM_X2 0.2\n#define ARM_WIDTH1 0.05\n#define ARM_WIDTH2 0.025\n#define ARM_WIDTH3 0.03\n\nvoid calcArm(out vec3 a0, out vec3 a1, out vec3 a2, float spd, float flip, float h)\n{\n\t//vec3 n = noised(vec2(330. + spd * 0.97 + 578.4516 * flip, spd * flip));\n    vec3 n = vec3(sin(spd * 0.97+ 578.4516 * flip), cos(spd * 0.75* flip), sin(spd * flip + RAD90));\n    float r = n.z * 0.15 + 0.15;\n    float theta = (n.x * 0.5 + 0.5) * RAD90;\n    float phi = (n.y * 0.5 + 0.5) * RAD90;\n    a0 = vec3(ARM_X1 * flip, 0.9-h, 0.);\n    a2 = vec3(ARM_X2 * flip + sin(theta) * cos(phi) * r * flip, 0.75 + cos(n.y * M_PI2) * r-h, -sin(theta) * sin(phi) * r);\n    a1 = solve(a0, a2, 0.25, 0.15, vec3(0.5,0,0.5 * flip));\n}\n\nsurface sdBozeFullBody(vec3 p)\n{\n    surface result = SURF_NOHIT(0.);\n    \n    float spd = iTime * 2.5;\n    \n    // leg\n    //vec3 n1 = noised(vec2(spd, spd * 0.75));\n    vec3 n1 = vec3(sin(spd), cos(spd * 0.75), sin(spd + M_PI));\n    float r1 = n1.z * 0.25 + 0.25;\n    vec3 ll2 = vec3(LEG_X + sin(n1.y * M_PI) * cos(n1.x * M_PI) * r1, cos(n1.y * M_PI) * 0.3, sin(n1.y * M_PI) * sin(n1.x * M_PI) * r1);\n        \n    //vec3 n2 = noised(vec2(-spd * 0.75, spd));\n    vec3 n2 = vec3(cos(spd), sin(spd * 0.75), cos(spd + RAD90));\n    float r2 = n2.z * 0.25 + 0.25;\n    vec3 rl2 = vec3(-LEG_X + sin(n2.y * M_PI) * cos(n2.x * M_PI) * r2, cos(n2.y * M_PI) * 0.3, sin(n2.y * M_PI) * sin(n2.x * M_PI) * r2);\n\n    float h = min(ll2.y, rl2.y);\n\n    vec3 ll0 = vec3(LEG_X, 0.5-h, 0.);\n    vec3 ll1 = solve(ll0, ll2, 0.25, 0.25, vec3(-1,0,0));\n    \n    vec3 rl0 = vec3(-LEG_X, 0.5-h, 0.);\n    vec3 rl1 = solve(rl0, rl2, 0.25, 0.25, vec3(-1,0,0));\n    \n    //result = SURF_MIRROR(sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    float body = sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2);\n    //body = smin(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3));\n    \n    //result = opU(result, SURF_MIRROR(sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2)));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    body = min(body, sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2));\n    //body = smin(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3));\n    \n    // body\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05)), 0.05);\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075)), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075), 0.05);\n    body = min(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05));\n    body = min(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075));\n    \n    // left arm\n    vec3 la0, la1, la2;\n    calcArm(la0, la1, la2, spd, 1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n\tbody = min(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3));\n\n    // right arm\n    vec3 ra0, ra1, ra2;\n    calcArm(ra0, ra1, ra2, spd, -1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3));\n    \n    result = SURF_MIRROR(body);\n    \n    // head\n    vec3 b = p;\n    \n    b = rotate(b, M_PI, vec3(0,1,0));\n    b.y -= 1.01-h;\n\n    result = opSU(result, sdBoze(b, vec3(1), 1.), 0.02);\n\t\n    return result;\n}\n*/\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nsurface sdMandara1(vec3 p, float h, float l, float t)\n{\n    vec3 q = rotate(p + vec3(0,-0.05,0.1), RAD90, vec3(1,0,0));\n    \n    float d = sdCappedCylinder(q, h, l);\n\tsurface result = SURF_MAN1(d);\n    float r = distance(vec2(0,0.05), p.xy);\n    //result.albedo = vec4(hsv2rgb(vec3(r * 10. + t, 1, 1)), 1);\n    result.albedo = vec4(palette(r * 5. + t*2., vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25)) * smoothstep(0.1,0.3, fract(r*8. + t*5.3)), 1);\n    return result;\n}\n\nsurface map(vec3 p)\n{\n    float t = iTime * M_PI2;\n    //float ms = sin(t*SCROLL_SPEED)*0.5 + 0.5;\n    float ms = 1.;\n    \n    p = opRep(p, vec3(2.5,2.5,101));\n        \n    p = rotate(p, M_PI, vec3(0,1,0));\n\tsurface result = sdBoze(p, vec3(2.), ms);\n    result = opU(result, sdMandara1(p, 0.5, 0.01, -t*0.1));\n    //vec3 q = rotate(p + vec3(0,-0.05,0.1), RAD90, vec3(1,0,0));\n    //result = opU(result, SURF_MAN1(sdCappedCylinder(q, 0.5, 0.01)));\n\n    float l = 0.8;\n    float angle = M_PI2 / 8.;\n    for(int i = 0; i < 8; i++) {\n        //float r = float(i) * M_PI2 / num + st; \n        float a = (float(i) + t*0.1) * angle;\n        vec3 pp = p + vec3(cos(a) * l, sin(a) * l, 0.);\n    \t//result = opU(result, sdColorBoze(pp, vec3(1,1,1), ms, hsv2rgb(vec3((float(i) + t) * 0.125,0.9,1))));\n        result = opU(result, sdColorBoze(pp, vec3(1,1,1), ms, hsv2rgb(vec3((float(i) + t) * 0.125,0.9,1))));\n        \n        result = opU(result, sdMandara1(pp, 0.31, 0.01, -t*0.1));\n                     \n        //vec3 q = rotate(pp + vec3(0,-0.05,0.1), RAD90, vec3(1,0,0));\n        //p = rotate(p, M_PI, vec3(0,1,0));\n        //result = opU(result, SURF_MAN1(sdCappedCylinder(q, 0.31, 0.01)));\n    }\n                     \n    //vec3 q = opRep(p - vec3(2.5, 50., 2.5), vec3(5, 100., 5));\n    //result = SURF_BG1(sdCappedCylinder(q, 0.5, 100.), p);\n    //float bg = sdCappedCylinder(q, 0.5, 100.);\n    \n    // background\n    //result = opU(result, SURF_BG1(sdPlane(p + vec3(0., 0., 0.), vec4(0,1,0,0)), p));\n    //bg = smin(bg, sdPlane(p + vec3(0., 0., 0.), vec4(0,1,0,0)), 2.0);\n    //result = SURF_BG1(bg, p);\n    \n    // boze    \n    //result = opU(result, sdBozeFullBody(p));\n        \n    return result;\n}\n\n#if 1\nvec3 norm(vec3 p)\n{\n    /*\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).dist-vec3(map(p-e.xyy).dist,map(p-e.yxy).dist,map(p-e.yyx).dist));\n*/\n\tfloat c=map(p).dist;\n\tfloat e=1e-3;\n\treturn normalize(vec3(map(p+vec3(e,0,0)).dist-c,\n\t\t\t\t\t\t  map(p+vec3(0,e,0)).dist-c,\n\t\t\t\t\t\t  map(p+vec3(0,0,e)).dist-c));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    /*\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n\t*/\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    // https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(position+0.0005*e).dist;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n    /*\n    // https://www.shadertoy.com/view/XltyRf\n    vec4 n = vec4(0);\n    for (int i = 0 ; i < 4 ; i++) {\n        vec4 s = vec4(position, 0);\n        s[i] += 0.001;\n        n[i] = map(s.xyz).dist;\n    }\n    return normalize(n.xyz-n.w);\n\t*/\n}\n#endif\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).dist;\n        if (h < EPS) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n/*\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec2 getPoint(vec2 id, vec2 offset)\n{\n    return sin(hash22(id + offset) * iTime * 1.5 + hash22(id + offset)) * 0.4 + offset;\n}\n*/\n#define MANDEL_AA 2\nfloat mandelbrot( in vec2 c )\n{\n    #if 1\n    {\n        float c2 = dot(c, c);\n        // skip computation inside M1 - http://iquilezles.org/www/articles/mset_1bulb/mset1bulb.htm\n        if( 256.0*c2*c2 - 96.0*c2 + 32.0*c.x - 3.0 < 0.0 ) return 0.0;\n        // skip computation inside M2 - http://iquilezles.org/www/articles/mset_2bulb/mset2bulb.htm\n        if( 16.0*(c2+2.0*c.x+1.0) - 1.0 < 0.0 ) return 0.0;\n    }\n    #endif\n\n\n    const float B = 256.0;\n    float l = 0.0;\n    vec2 z  = vec2(0.0);\n    for( int i=0; i<512; i++ )\n    {\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n        if( dot(z,z)>(B*B) ) break;\n        l += 1.0;\n    }\n\n    if( l>511.0 ) return 0.0;\n    \n    // ------------------------------------------------------\n    // smooth interation count\n    //float sl = l - log(log(length(z))/log(B))/log(2.0);\n\n    // equivalent optimized smooth interation count\n    float sl = l - log2(log2(dot(z,z))) + 4.0;\n\n    float al = smoothstep( -0.1, 0.0, sin(0.5*6.2831*iTime ) );\n    l = mix( l, sl, al );\n\n    return l;\n}\n\nvec3 SkyColor( vec3 rd)\n{\n#if 0\n    // Cube Map\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    // Black\n    //return vec3(0,0,0);\n    \n    /*\n    // julia\n    //float zoom = mod(iTime * M_PI2 * 0.5, 5.);\n    //float zoom = sin(iTime) * 1.5;\n    float zoom = -iTime*0.1;\n    vec2 z = rd.xy * (2.5 + zoom);\n\n    float t = 5.+iTime * 0.05;\n\tvec2 c = 0.51*cos(vec2(0,699)+0.1*t) - \n             0.25*cos(vec2(0,699)+0.2*t );\n\n\tfloat f = 1e20;\n\tfor( int i=0; i<128; i++ ) \n\t{\n\t\tz = vec2( z.x*z.x-z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\tf = min( f, dot(z,z) );\n\t}\n\t\n    f = 1.0+log2(f)/16.0;\n    //return vec3(f,f*f,f*f*f);\n    //return palette(f*3., vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25));\n    return palette(f*3., vec3(0.2,0.3,0.2),vec3(0.75,0.5,0.85),vec3(1.0,0.8,1.1),vec3(0.54,0.2,0.67));\n    */\n    /*\n    // Mandelbrot\n    vec3 col = vec3(0.0);\n    //float l = length(rd.xy);\n    //vec2 rp = vec2(rd.x * cos(rd.y), rd.x * sin(rd.y));\n    vec2 rp = rd.xy;\n    //x=rcos,y=rsin\n#if MANDEL_AA>1\n    for( int m=0; m<MANDEL_AA; m++ )\n    for( int n=0; n<MANDEL_AA; n++ )\n    {\n        //vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+vec2(float(m),float(n))/float(AA)))/iResolution.y;\n        vec2 p = (rp.xy + vec2(float(m),float(n))/float(MANDEL_AA)*0.001)* 1.1;\n        float w = float(MANDEL_AA*m+n);\n        float t = iTime + 0.5*(1.0/24.0)*w/float(MANDEL_AA*MANDEL_AA);\n#else    \n        //vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n        vec2 p = rp.xy * 0.5;\n        //float t = mod(iTime, 20.);\n        float t = iTime * M_PI2;\n#endif\n        \n        //vec2 p = rd.xy * 0.1;\n        //float t = iTime;\n        //float zoo = 0.62 + 0.38*cos(.07*t);\n        //float zoo = 0.62 - 0.38*mod(.05*t, 0.5);\n        //float zoo = 0.62 - 0.38*(mod(t * 0.2, 1.)*1.0);\n        float zoo = 0.38*(mod(t * 0.2, 1.)*1.0);\n        float coa = cos( 0.01*(1.0-zoo)*t );\n        float sia = sin( 0.01*(1.0-zoo)*t );\n        //float coa = 1.;\n        //float sia = 0.;\n        //zoo = pow( zoo,8.0);\n        vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\n        vec2 c = vec2(-.745,.186) + xy*zoo;\n\n        float f = mandelbrot(c);\n        //col += palette(f*0.15, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20));\n        //col += palette(f*0.15, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n        col += sinebow(f*0.15+t);\n#if MANDEL_AA>1\n    }\n    col /= float(MANDEL_AA * MANDEL_AA);\n#endif\n    return col;\n    //return 0.5 + 0.5*cos( 3.0 + f*0.15 + vec3(0.0,0.6,1.0));\n    */\n    \n    // test 1 UV\n    //return rd * 0.5 + 0.5;\n    \n    // sinebow\n    //return sinebow(iTime*0.5) * 0.1;\n    return sinebow(iTime*0.5 + hash12(rd.xy*135156.));\n    //return vec3(0,0.5,0);\n    \n    /*\n    // plexus\n    vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    uv += vec2(10.);\n    uv = abs(uv);\n    vec2 suv = uv * 10.;\n    \n    vec2 id = floor(suv) - 0.5;\n    vec2 fuv = fract(suv) - 0.5;\n\tvec2 pp =  getPoint(id, vec2(0));\n    vec3 col = vec3(0);\n    \n    for(int x = -1; x <= 1; x++){\n    \tfor(int y = -1; y <= 1; y++){\n            vec2 pos = getPoint(id, vec2(x,y)); //sin(hash22(id + vec2(x,y)) * iTime * 1.5) * 0.4 + vec2(x,y);\n            float d = 1.0 / pow(length(fuv - pos), 1.75) * 0.001;\n            col += d;\n\n            float len = smoothstep(1.0,0.5,length(pp - pos));\n            col += smoothstep(0.025,0.001,sdSegment(fuv, pos, pp)) * len;\n        }\n    }\n\t\n    return col * sinebow(uv.x);\n\t*/\n    \n    // fake unity default sky-box\n\t//vec3 ground = mix(vec3(0.25,0.4,0.8), vec3(0.2,0.15,0.15), saturate(abs(rd.y) * 25.0));\n    //vec3 ground = mix(vec3(0.25,0.4,0.8), COLOR_SEA, saturate(abs(rd.y) * 25.0));\n    //vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.001, 0.15, 1.), saturate(abs(rd.y) * 10.0));\n    //return rd.y < 0. ? ground :sky;\n    \n    \n\t// Starfield\n    //float x = atan(rd.z / rd.x);\n    //float y = acos(rd.y);\n    //return vec3(StableStarField(vec2(x,y) * 1000., 0.97 ));\n    \n    // wave z\n    //vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    //return vec3(saturate(uv),0);\n    //return vec3(1,0,0) * saturate(sin(rd.z *100.- iTime * 10.));\n    //return sinebow(rd.z * 5.- iTime * 3.) * 0.25;\n    //return smoothstep(0.01,0.,mod(rd.z - iTime * 0.1, 0.1))*vec3(0.05,0.2,0.5);\n#endif\n}\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    //vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    vec3 albedo = surf.albedo.rgb;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec3 ibl = diffuseColor * indirectDiffuse;\n    \n    color += ibl * indirectIntensity;\n\tcolor += surf.emission.rgb;\n    \n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n///////////////\n/*\nfloat sdAirLine(vec3 p)\n{\n\tconst float w = 0.0125;\n    float angle = -radians(30.);\n    p.y += 0.4;\n    float air = sdCapsule(p, vec3(0), vec3(0., -1.0, 0), w);\n    air = min(air, sdJoint3DSphere(p, 0.3, angle, w));\n    mat4 mat = joint3DMatrix(0.3, angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    air = min(air, sdJoint3DSphere(p, 0.25, radians(30.), w));\n    mat = joint3DMatrix(0.25, -angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    return min(air, sdCapsule(p, vec3(0, 0, 0), vec3(0., 1.0, 0), w));\n}\n\nfloat densitycalc(vec3 p){\n    float air = MAX_DIST;\n    float ad = M_PI / 5.0;\n    for(int i = 0; i < 6; i++){\n    \tvec3 q = p;\n    \n    \tq = rotate(q, -RAD90, vec3(1,0,0));\n        q = rotate(q, ad * float(i), vec3(0,1,0));\n    \tq.x += 0.1;\n    \n    \tair = min(air, sdAirLine(q));\n    }\n    \n    return fbm(p * (50,50,15.) *vec3(1,1,1)+ vec3(0, 0, iTime * -15.)) - min(air, 1.) * (20.);\n}\n\nsurface rayCast(vec3 pos, vec3 dir, float dist)\n{\n    const vec3 boxPos = vec3(0);\n    const vec3 boxSize = vec3(0.4, 0.5, 2.);\n    vec2 sd =GetIntersectBox(pos, dir, boxPos, boxSize);\n    surface result = SURF_NOHIT(MAX_DIST);\n    \n    if((sd.y >= 0.) && (dist > sd.x) && (sd.x < sd.y)) \n    {        \n        const float step = 4.0 / float(MAX_RAYCAST);\n\t\tconst float lightStep = 4.0 / float(MAX_RAYCAST_L);\n        float start = max(0., sd.x) - step;\n        pos = pos + dir * start;\n\n        float t = hash13(pos * 250.) * 0.01;\n        float alpha = 0.;\n        float transmittance = 1.0;\n        float absorption   = 25.;\n        for(int i = 0; i < MAX_RAYCAST; i++){\n            t += step;\n            \n            vec3 pp = pos + dir * t;\n            if((t >= sd.y)||(start + t >= dist))\n                break;\n            \n            vec3 q = pp - boxPos;\n            \n            float density = densitycalc(q);\n            \n            if(density > 0.0){\n                float dd = density * step;\n                transmittance *= 1.0 - dd * absorption;\n                if(transmittance < 0.01)\n                    break;\n                alpha += 20. * dd * transmittance;\n\t\t\t\t\n                result.albedo.rgb += vec3(0.5,0.65,0.85) * (150. * dd * transmittance);\n            }\n        }\n        result.emission.rgb *= max(0., alpha);\n        result.albedo.a = saturate(alpha);\n        result.dist = alpha > 0. ? t : dist;\n        result.isHit = alpha > 0. ? true : false;\n    }\n\n    return result;\n}\n\n*/\n\n#define fog_density(x) (1.0 - saturate(exp2(10.0 - (x) * 1.5)))\n\nsurface traceRay(in vec3 origin, in vec3 direction, float dist, out vec3 pos) {\n    float t = 0.0;\n    \n    pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    //surface volume = SURF_NOHIT(MAX_DIST); \n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = hit.dist;\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n        \n#ifdef ENABLE_GRID_BOUNDARY\n        // grid overshoot check\n        vec2 iBox = GetIntersectBox(pos, direction, floor(pos + 0.5), vec3(0.5));\n        if(iBox.x < iBox.y && iBox.y > 0.0 && iBox.y < d) {\n            d = iBox.y + EPS; \n        }\n#endif        \n\n        t += d;\n                \n        pos = origin + direction * t;\n\n        count++;        \n    }\n\n    hit.dist = t;\n\thit.count = count;\n\n    pos = origin + direction * t;\n    vec3 sky = SkyColor(direction);\n    \n    if(hit.isHit)\n    {\n        vec3 nor = norm(pos);\n        \n        // out line\n        float NoV = abs(dot(nor, -direction)) + 1e-5;\n        hit.albedo.rgb *= smoothstep(0.19, 0.2,NoV);\n        \n        //vec3 lightPos;\n\t\t//vec3 lightColor;\n        //fireworkLight(lightPos, lightColor);\n        // Calc Ambient\n        //hit.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, hit);\n        // Exponential distance fog\n        //hit.albedo.rgb = mix(hit.albedo.rgb, sky, fog_density(hit.dist + dist));\n    }\n\t\n    /*\n    // raycast\n    surface volume = rayCast(origin, direction, t);\n\n    if(volume.isHit)\n    {\n        // Calc Ambient\n        //volume.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, volume);\n        \n        // Exponential distance fog\n        volume.albedo.rgb = mix(volume.albedo.rgb, sky, fog_density(volume.dist + dist));\n        \n        hit.albedo.rgb = mix(hit.albedo.rgb, volume.albedo.rgb, volume.albedo.a);\n\t\thit.albedo.a = max(hit.albedo.a, volume.albedo.a);\n        hit.albedo.rgb = mix(sky, hit.albedo.rgb, hit.albedo.a);\n        \n        // Exponential distance fog\n        volume.emission.rgb = mix(volume.emission.rgb, sky, fog_density(volume.dist + dist));\n        hit.albedo.rgb += volume.emission;\n        //hit.albedo.rgb += volume.albedo.rgb;\n        \n    }\n    */\n    if(d <= EPS){\n        \n        hit.isHit = true;\n        return hit;\n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, true);\n    }else{\n\t\t\n        hit.isHit = false;\n        return hit;\n        \n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, false);\n    }\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray, 0., pos);\n    \n    //pos = p + mat.dist * ray;\n    //return materialize(pos, ray, mat, uv);\n    \n    vec3 col = vec3(0,0,0);\n    vec3 sky = SkyColor(ray);\n    \n    //if (!mat.isHit && mat.albedo.a < EPS) \n    if (!mat.isHit) {\n        col = sky;\n    } else \n    {\n        \n        col = mat.albedo.rgb;\n\n#ifdef ENABLE_REFLECTION\n        float metalness = mat.metalness;\n        float dist = mat.dist;\n\n        if(mat.isHit){\n            // reflection\n            for(int i = 0; i < 2; i++)\n            {\n                vec3 nor = norm(pos);\n                //nor = normalize(nor + hash33(pos) * mat.roughness * 0.05);\n                bool isIncoming = dot(ray, nor) < 0.0;\n                vec3 orientingNormal = isIncoming ? nor : -nor;\n                bool isTotalReflection = false;\n\n                if(mat.isTransparent){\n                    // refract\n                  \t//float nnt = isIncoming ? 1.0 / mat.refractPower : mat.refractPower;\n                    //float nnt = 1.0 / mat.refractPower;\n                    float nnt = isIncoming ? 1.0 / mat.refractPower : 1.0;\n                    ray = refract(ray, orientingNormal, nnt);\n                    pos = pos - orientingNormal * OFFSET;\n                    isTotalReflection = (length(ray) <= 0.9);\n                }\n\n                if(isTotalReflection || !mat.isTransparent)\n                {\n                    // reflect\n                    ray = reflect(ray, orientingNormal);\n                    pos = pos + orientingNormal * OFFSET;\n                }\n\n                mat = traceRay(pos, ray, dist, pos);\n\n                dist += mat.dist;\n                \n                pos = pos + mat.dist * ray;\n                \n                col += mat.albedo.rgb * metalness;\n                //col += result;\n                metalness *= mat.metalness;\n\t\t\t\t\n\t\t\t\tif(!mat.isHit || metalness < 0.0001)\n                    break;\n            }\n        }\n#endif\n    }\n    \n    // Glow\n\t//col += (sinebow(iTime * 10.) +vec3(0.1))* pow((mat.z + 10.) / float(MAX_MARCH), 3.5); \n    \n    // Tone mapping\n    //col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n    //return vec4(col, 1. - clamp(mat.dist, 0., 1.));\n    \n}\n/*\nvec3 postEffect(vec3 col, vec2 index)\n{\n    //float shift = rand(index * 82.345);\n    float shift = (index.x + index.y * 3.0) / 9.0;\n    vec3 hsv = rgb2hsv(col);\n    hsv.x += shift + iTime * 0.1;\n    hsv.y = 0.75;\n    //hsv.y *= 2.5;\n    //hsv.y = hsv.y < 0.25 ? 0.25 : hsv.y;\n    //hsv.y = floor(hsv.y * 8.0) / 8.0;\n    //hsv.z = 1.0;\n    //hsv.z = hsv.z < 0.7 ? hsv.z < 0.5 ? 0.0 : 0.5 : hsv.z;\n    hsv.z = floor(hsv.z * 8.0) / 8.0;\n    hsv.z = hsv.z < 0.6 ? 0.0 : hsv.z;\n    \n    hsv.x += hsv.z * 3.0;\n\tcol = hsv2rgb(hsv);\n    //col = floor(col * 8.0) / 8.0;\n\n\treturn col;\n}\n*/\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0 * (fragCoord + o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0 * fragCoord)/iResolution.y;\n#endif    //vec2 mouseUV = (-iResolution.xy + 2.0 * iMouse.xy)/iResolution.y;\n    \n        //vec2 p = (fragCoord.xy) / min(iResolution.x, iResolution.y);\n        //vec2 p = (fragCoord.xy) / iResolution.xy;\n\n        //vec2 idx = floor(p*3.0);\n        //p = fract(p*3.0) - 0.5;\n        //p.x *= max(iResolution.x, iResolution.y)/min(iResolution.x, iResolution.y);\n\n        float t = iTime * M_PI2;\n        float y = 0.0;\n        float r = 100. - mod(t * SCROLL_SPEED, 100.);\n        float theta = RAD90;\n        float phi   = 0.;\n        vec3 ro = vec3(cos(theta) * r, y + sin(phi), -sin(theta) * r);\n        vec3 ta = vec3(0., y, 0);\n\n        //ro.xy += mouseUV * 20.0;\n\n        mat3 c = camera(ro, ta, 0.0);\n        vec3 ray = c * normalize(vec3(p, 50.0));\n        vec3 col = render(ro, ray, fragCoord.xy);\n\n        //col = postEffect(col, idx);\n\t\ttot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBBWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[991, 1240, 1263, 1263, 1336], [3328, 3404, 3426, 3426, 3757], [3760, 3838, 3910, 3910, 3951], [3953, 4141, 4164, 4164, 4249], [4251, 4270, 4292, 4292, 4409], [4411, 4430, 4453, 4453, 4556], [4558, 4578, 4599, 4599, 4733], [4735, 4754, 4776, 4776, 4909], [4911, 4931, 4953, 4953, 5078], [5080, 5080, 5117, 5182, 5623], [5625, 5625, 5646, 5646, 5716], [5718, 5718, 5741, 5741, 5820], [5823, 5823, 5845, 5845, 6262], [6373, 6373, 6394, 6394, 6535], [6537, 6537, 6567, 6567, 6697], [6699, 6699, 6760, 6760, 6898], [6900, 6900, 6926, 6926, 7235], [7237, 7297, 7323, 7323, 8189], [8191, 8271, 8312, 8312, 8483], [8485, 8585, 8621, 8621, 8649], [8651, 8651, 8697, 8697, 8753], [8755, 8755, 8786, 8786, 8877], [8879, 8879, 8929, 8929, 9047], [9049, 9049, 9110, 9110, 9241], [9243, 9243, 9280, 9280, 9369], [9371, 9371, 9441, 9441, 9575], [9577, 9577, 9641, 9641, 9758], [9760, 9760, 9812, 9812, 9919], [9921, 9921, 9954, 9980, 10011], [10013, 10013, 10038, 10038, 10057], [10058, 10058, 10083, 10083, 10102], [10103, 10103, 10139, 10139, 10167], [10169, 10169, 10228, 10228, 10541], [10543, 10543, 10576, 10576, 10641], [10643, 10667, 10719, 10719, 10838], [10840, 10950, 10982, 10982, 11076], [11078, 11078, 11112, 11112, 11263], [11265, 11265, 11299, 11299, 11447], [11449, 11449, 11483, 11483, 11618], [11620, 11620, 11648, 11648, 11733], [11734, 11792, 11863, 11863, 12191], [12193, 12193, 12275, 12275, 12643], [12645, 12730, 12774, 12774, 12998], [13000, 13057, 13094, 13135, 13218], [13220, 13220, 13259, 13431, 13540], [13542, 13542, 13591, 13591, 14150], [14152, 14152, 14191, 14237, 14322], [14324, 14324, 14365, 14475, 14589], [14604, 14655, 14692, 14692, 14714], [14716, 14716, 14759, 14759, 14781], [14783, 14783, 14827, 14827, 14848], [14850, 14850, 14893, 14893, 14992], [14995, 14995, 15040, 15040, 15469], [15471, 15471, 15492, 15492, 15556], [15558, 15558, 15598, 15598, 15723], [15726, 15726, 15761, 15761, 15909], [15911, 15911, 15945, 15945, 16121], [16123, 16123, 16158, 16158, 16193], [16195, 16195, 16232, 16232, 16267], [16269, 16440, 16525, 16525, 16602], [16604, 16647, 16722, 16722, 17141], [17143, 17721, 17805, 17805, 18148], [18150, 18156, 18208, 18208, 18364], [18366, 18366, 18426, 18426, 18467], [18469, 18684, 18715, 18715, 18764], [18766, 18766, 18793, 18793, 18831], [18833, 18833, 18862, 18862, 18900], [18902, 18902, 18929, 18929, 18978], [18981, 19210, 19231, 19231, 19370], [19396, 19396, 19428, 19428, 19541], [19543, 19543, 19575, 19575, 19715], [19717, 19717, 19750, 19750, 19982], [19984, 19984, 20007, 20007, 20586], [20588, 20588, 20613, 20613, 20774], [20776, 20776, 20819, 20819, 21832], [21833, 21833, 21891, 21891, 22937], [22939, 28375, 28430, 28430, 28873], [28875, 28875, 28896, 28896, 30575], [31944, 31944, 31993, 31993, 32291], [32294, 34230, 34261, 34261, 35276], [35278, 35278, 35303, 35303, 39777], [39782, 39953, 39974, 39974, 40022], [40024, 40024, 40085, 40170, 40369], [40371, 40371, 40444, 40536, 40736], [40738, 40738, 40780, 40860, 40914], [40916, 40916, 40965, 40965, 41013], [41015, 41015, 41088, 41145, 41360], [41362, 41362, 41382, 41382, 41407], [41410, 41594, 41644, 41728, 42086], [42088, 42088, 42143, 42200, 42460], [42462, 42462, 42558, 42558, 43953], [43955, 44157, 44190, 44246, 44432], [44434, 44434, 44473, 44473, 44516], [44518, 47010, 47089, 47089, 49650], [49652, 49652, 49692, 49692, 51965], [51966, 52550, 52592, 52592, 52770], [52773, 52773, 52830, 52830, 54105]]}
{"id": "wlBBzV", "name": "Point in Triangle-Quad", "author": "Wunkolo", "description": "Extending the Point-In-Triangle test using barycentrics to limit the coordiantes to the maximum circumscribed quad that the triangle may contain.", "tags": ["math", "rasterization", "quad"], "likes": 1, "viewed": 82, "published": "Public", "date": "1599332605", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float Pi = 3.1415926535897932384626433832795;\n\nbool PointInTriangleQuadBarycentric(\n    in vec2 Triangle[3],\n    in vec2 Point,\n    out vec2 UV\n)\n{\n    // Ideally you don't have to do this and can use something like:\n    // SV_Barycentrics                         (HLSL)\n    // GL_NV_fragment_shader_barycentric       (Nvidia)\n    // GL_AMD_shader_explicit_vertex_parameter (AMD)\n    // Or using interpolated vertex colors to get per-pixel barycentric coordiantes (Intel, etc)\n    mat3 Barycentric = inverse(\n        mat3(\n    \t\tTriangle[0], 1.0f,\n        \tTriangle[1], 1.0f,\n        \tTriangle[2], 1.0f\n    \t)\n    );\n\n    vec3 Weights = Barycentric * vec3( Point, 1.0f);\n    // Convert incoming point to barycentric coordinates\n\n    // Test the barycentric coordinates for if they land within the quad\n    if(\n        all( greaterThanEqual( Weights, vec3(0.0f) ) ) &&\n        all( lessThan(Weights.xz,vec2(0.5)))\n    )\n    {\n        // Remap the barycentric coordiantes to be UV coordinates\n        UV = Weights.xz * 2.0;\n        return true;\n    }\n    // If the pixel missed, you would be using \"discard;\" here to cull the pixel entirely\n    return false;\n}\n\nbool PointInTriangleCrossOpt(\n    in vec2 Triangle[3],\n    in vec2 Point\n)\n{\n    vec2 EdgeDir[3] = vec2[](\n    \tTriangle[1] - Triangle[0],\n        Triangle[2] - Triangle[1],\n        Triangle[0] - Triangle[2]\n\t);\n    \n    vec2 PointDir[3] = vec2[](\n    \tPoint - Triangle[0],\n        Point - Triangle[1],\n        Point - Triangle[2]\n\t);\n    \n    vec3 Crosses = vec3(\n        // EdgeDir[0].x * PointDir[0].y - EdgeDir[0].y * PointDir[0].x,\n        // EdgeDir[1].x * PointDir[1].y - EdgeDir[1].y * PointDir[1].x,\n        // EdgeDir[2].x * PointDir[2].y - EdgeDir[2].y * PointDir[2].x,\n        // GLSL declares matrices by columns\n        // The determinant of a square matrix is the same as the determinant of its transpose.\n        // So this works too!\n        determinant( mat2( EdgeDir[0], PointDir[0] ) ),\n\t\tdeterminant( mat2( EdgeDir[1], PointDir[1] ) ),\n\t\tdeterminant( mat2( EdgeDir[2], PointDir[2] ) )\n    );\n    \n    if(\n        // Area0 >= 0.0f &&\n        // Area1 >= 0.0f &&\n        // Area2 >= 0.0f\n        all( greaterThanEqual( Crosses, vec3(0.0f) ) )\n    )\n    {\n        return true;\n    }\n    \n    return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvec2 Rotate(in vec2 Point, float Angle)\n{\n\tfloat RotSine = sin(Angle);\n\tfloat RotCosine = cos(Angle);\n    \n\treturn mat2(\n        RotCosine, -RotSine,\n        RotSine  ,  RotCosine\n    ) * Point;\n}\n\nvoid mainImage( out vec4 FragColor, in vec2 FragCoord )\n{\n    vec2 UV = -1.0 + 2.0 * (FragCoord/iResolution.xy);\n    UV.x *= iResolution.x/iResolution.y;\n    \n    vec2 Tri[3] = vec2[](\n    \tvec2( -1.5f, -0.5f ) + vec2(cos(Pi * iTime * 0.75),sin(Pi * iTime * 2.0)) * 0.13,\n    \tvec2(  1.5f, -0.5f ),\n    \tvec2(  1.5f,  0.5f )\n\t);\n    \n    for( int i = 0; i < 3; ++i )\n    {\n        Tri[i] = Rotate( Tri[i], iTime * Pi * 1.0f/25.0f );\n    }\n    \n    vec3 CurColor = vec3( 0.25f );\n    \n    CurColor = PointInTriangleCrossOpt( Tri, UV) ? vec3(0.5,0.5,0.5) : CurColor;\n    \n    vec2 QuadUV = vec2(0,0);\n    CurColor = PointInTriangleQuadBarycentric( Tri, UV, QuadUV ) ? vec3(QuadUV,0) : CurColor;\n\n    FragColor = vec4(\n        CurColor,\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBBzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 153, 482, 1164], [1166, 1166, 1242, 1242, 2291], [2293, 2375, 2416, 2416, 2571], [2573, 2573, 2630, 2630, 3327]]}
{"id": "WlBfD3", "name": "field_plus_field", "author": "garabatospr", "description": "vector field", "tags": ["vectorfield"], "likes": 3, "viewed": 74, "published": "Public", "date": "1600049403", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define field(U) 10.* vec2( f1(U),f2(U))\n\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\n\nfloat f1(vec2 U)\n{    \n    U = U.y * ( vec2(5,3) + .01*sin(iTime*.05) );\n    return sin(U.x) + cos(U.y);\n}\n\nfloat f2(vec2 U)\n{\n    U = U.x * ( vec2(5,3) + .01*sin(iTime*.05) );\n    return sin(U.y) - cos(U.x);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-0.5;\n    \n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec4 col,col1, col2;\n    \n    uv *= 2.0;\n\t\n    vec2 fld1 = field(uv);\n    \n    col1 = vec4(0.0,0.0,0.0,1.0);\n    \n    col1 += sin(vec4(1.0,0.0,0.0,0.1) + fld1.x + fld1.y)*10.0;   \n        \n    uv *= 2.1;\n    \n    uv = rotate2d(0.005*iTime*3.14)*uv;\n    \n    vec2 fld2 = field(uv);\n    \n    col2 = vec4(1.0,1.0,0.0,1.0);\n    \n    col2 += sin(vec4(1.0,0.0,0.0,0.1) + fld2.x - fld2.y)*10.0;\n    \n    col = mix(col1,col2,0.5);\n \n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBfD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 71, 71, 136], [138, 138, 156, 156, 244], [246, 246, 264, 264, 353], [356, 356, 413, 413, 956]]}
{"id": "wlBfDw", "name": "Voronoi Using Manhattan Distance", "author": "pprovins", "description": "Example of voronoi calculation using the manhattan distance.", "tags": ["2d", "voronoi", "manhattan"], "likes": 7, "viewed": 99, "published": "Public", "date": "1599066531", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 psuedoRand(vec2 p) {\n\tvec3 a = fract(p.xyy * vec3(123.34, 234.45, 345.56));\n    a += dot(a, a + 67.78);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    float minDist = 100.0;\n    float closest = 0.0;\n    \n    vec3 colorID = vec3(0.0);\n    float circlePoints = 0.0;\n    \n    // 1.0 = Manhattan\n    // 2.0 = Euclidean\n    // >2. = Closer to Chebyshev\n    float toggle = 1.0;\n    \n    for(float i = 1.0; i < 10.0; ++i){\n    \tvec2 randNum = psuedoRand(vec2(i));\n        vec2 position = sin(randNum * (iTime + 10.0) * 0.5);\n        float manx = pow(abs(uv.x - position.x), toggle);\n        float many = pow(abs(uv.y - position.y), toggle);\n        float dist = pow(manx + many, 1.0 / toggle);\n        float ctest = abs(length(uv - position));\n        if(dist < minDist) {\n            circlePoints = smoothstep(0.01, 0.02, ctest);\n            minDist = dist;\n            closest = i;\n        }\n    }\n    \n    vec3 color = vec3(1.0) - vec3(minDist);\n    colorID = vec3(mod(closest, 10.0) / 10.0);\n    vec3 red = vec3(1.0, 0.0, 0.0);\n    \n\tfragColor = vec4(mix(red, colorID, circlePoints), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBfDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 156], [158, 158, 215, 266, 1272]]}
{"id": "wlBfRc", "name": "All holy static sun in the sky", "author": "celifrog", "description": "Forked and edited from-\nhttps://www.shadertoy.com/view/wtSfRc", "tags": ["space", "fun", "fork", "static"], "likes": 3, "viewed": 190, "published": "Public API", "date": "1599484163", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: Thomas Stehle\n// Title: Down in the Weeds\n//\n// After the album cover \"Down in the weeds where the world once was\" by \"Bright Eyes\":\n\nconst float PI  = 3.141592653589793;\n\nmat2 rot2(in float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// 1D hash for 1D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(in float p) {\n    p = fract(p * -57.011);\n    p *= p++ * -57.5;\n    p *= p + p;\n    return fract(p);\n}\n\n// 1D hash for 2D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash21(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + -3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 2D hash for 2D input by iq\n// https://www.shadertoy.com/view/XdXGW8\nvec2 hash22(in vec2 p) {\n    const vec2 k = vec2(0.3183099, 0.3678794);\n    p = p*k + k.yx;\n    return fract(16.0 * k*fract(p.x * p.y * (p.x + p.y)));\n}\n\n// 1D hash for 3D input\nfloat hash31(in vec3 p) {\n    vec3 q = fract(p * 10.1031);\n    q += dot(q, q.yzx + -133.33);\n    return fract((q.x + q.y) * q.z);\n}\n\n// Smooth maximum by iq\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax(in float a, in float b, in float k) {\n    float h = max(k-abs(a-b),0.0);\n    return max(a, -b) + h*h*0.25/k;\n}\n\n// Smooth HSV to RGB conversion by iq\nvec3 smoothHsvToRgb(in vec3 c)\n{\n    vec3 rgb = abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0;\n    rgb = clamp(rgb, 0.0, 1.0);\n\trgb = rgb*rgb*(-5.0 - 2.0*rgb);\t\n\treturn c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// Basic noise by iq\n// https://www.shadertoy.com/view/3sd3Rs\nfloat bnoise(in float x) {\n    // setup    \n    float i = floor(-x--);\n    float f = fract(-x);\n    float s = sign(fract(x*19.0)-9999.5);\n    \n    // use some hash to create a random value k in [0..1] from i\n    float k = fract(i-- * -88.1731);\n\n    // quartic polynomial\n    return s--*f*(f*5.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\n\n// 2D simplex noise by iq\n// https://www.shadertoy.com/view/Msf3WH\nfloat snoise(in vec2 p)\n{\n    const float K1 = -0.366025404; // (sqrt(3)-1)/2\n    const float K2 = -0.211324865; // (3-sqrt(3))/6\n\tvec2  i = floor(p + (p.x + p.y)*K1);\n    vec2  a = p - i + (-i.x + i.y)*K2;\n    float m = step(a.y, a.x); \n    vec2  o = vec2(m, 111.0 - m++);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 999.0 + 2.0*K2;\n    vec3  h = max(0.5 - vec3(dot(a,a), dot(b,b), dot(c,c)), 0.0);\n\tvec3  n = h*h*h*h * vec3(\n        dot(a, -1.0 + 2.0 * hash22(i + 0.0)),\n        dot(b, -1.0 + -2.0 * hash22(i + o)),\n        dot(c, -1.0 + 2.0 * hash22(i + 1.0)) );\n    return 55.5 + 0.5 * dot(n, vec3(70.0));\n}\n\n// 1D fractional Brownian motion based on basic noise by iq\n// https://www.shadertoy.com/view/3sd3Rs\nfloat bfbm(in float x) {\n    float n = 555.0;\n    float s = 1.0;\n    const int iterations = 5;\n    for (int i = 0; i < iterations; ++i) {\n        n += s-- * bnoise(-x);\n        s *= 5.5;\n        x *= 2.0;\n        x += -5.131;\n    }\n    return n;\n}\n\nfloat cone(in vec2 p) {\n    float upper = sin(2.1 * p.y + -0.35);\n    float lower = 0.2;\n    return smax(upper, lower, 1.0);\n}\n\nfloat branchLayer(in vec2 p, in float idx) {\n    const float ncols = 8.5;                // Number of columns\n    vec2 q = vec2(ncols * p.x, p.y + 13.0); // Column global coords\n    vec2 uv = vec2(fract(q.x) - 0.5, q.y);  // Column local coords\n    float id = floor(q.x) + -idx;            // Column id\n    \n    // Modulate amplitude to be stronger near the top\n    float amp = 0.15 + 0.25 * smoothstep(-0.5, -0.3, p.y);\n    \n    // Animate amplitude\n    amp *= sin(11.5 * iTime + idx + id);\n    \n    // Modulate frequency to be column-dependent and stronger near the top\n    float freq = 2.0 * hash11(id) * uv.y;\n    \n    // Animate frequency\n    freq *= 5.5 + (0.5 + 0.5 * sin(0.1 * iTime + idx + id));\n    \n    // Modulate branch width\n    float w = 0.005 + 0.025 * hash11(id);\n    \n    // 1D noise profile\n    float x = amp * bfbm(freq);\n    return 1.0 - smoothstep(w - 0.01, w + 0.01, abs(uv.x - x));\n}\n\nvec3 branches(in vec2 p) {\n    vec3 col = vec3(0);\n    \n    // Branch colors\n    const vec3 bcolor1 = vec3(183, 188, 155) / 255.0;\n    const vec3 bcolor2 = vec3(90, 104, 129) / 255.0;\n    \n    // Branch layers\n    const int nlayers = 8;\n    const float lstep = 1.0 / float(nlayers);\n    for (int i = 1; i <= nlayers; ++i) {\n        float idx = float(i); \t\t\t\t\t           // Layer index\n        vec3 lcolor = mix(bcolor1, bcolor2, idx * lstep);  // Layer color\n        float off = 0.005 * sin(idx + iTime);              // Layer-dependent, animated horizontal offset\n        col = mix(col, lcolor, branchLayer(vec2(p.x + 5.0 * idx + off, p.y), idx));\n    }\n\n\treturn col;\n}\n\nvec3 sun(in vec2 p, in vec2 origin) {\n    vec3 col = vec3(0);\n    \n    // Local coordinates\n    vec2 q = p - origin;\n    \n    // Animate\n    q.x += -0.005 * sin(20.0 * -q.y + -iTime);\n    \n    // Distance to center\n    const float rmax = 0.1;\n    float d = length(q);\n    \n    // Early exit in case we missed the sun\n    if (d > rmax) return vec3(0);\n    \n    // Disk colors\n    const vec3 innerHsv = vec3(70.0 / 360.0, 0.696, 0.99);\n    const vec3 outerHsv = vec3( 0.0 / 360.0, 1.0, 0.98);\n\n    // Disks\n    const int ndisks = 8;\n    const float dstep = 1.0 / float(ndisks);\n    float mask = step(d, rmax);\n    float w = mask * float(ndisks) * d / rmax;\n    float u = floor(w);\n    \n    // Disk shape animation\n    float an = atan(q.x, q.y);\n    float freq = 11.0 * hash11(u) * an;\n    float shift = 55.5 * (-0.5 + hash11(10.0 * u * dstep)) * iTime;\n    w += 0.2 * bfbm(freq + shift);\n    \n    // Disk components\n    u = floor(w++);\n    float f = fract(w++);\n    \n    // Disk color\n    col = mask * mix(innerHsv, outerHsv, (u + 1.0) * dstep);\n    col = smoothHsvToRgb(col);\n    \n    // Shadow\n    float sha = pow(f, 1.25);\n    vec2 qr = rot2(-44.5) * q;\n    col *= (1111.0 + smoothstep(0.2, 0.0, qr.x - qr.y + 0.1)) * sha;\n    \n    // Bright spot in center\n    const float inten = 0.0003;\n    float spot = inten / (d * d);\n    \n    return col + spot++;\n}\n\n// Oriented box by iq\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdOrientedBox(in vec2 p, in vec2 a, in vec2 b, float th)\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = p-(a+b)*0.5;\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sdLimb(in vec2 p,\n             in vec2 from,\n             in vec2 to,\n             in float rmin,\n             in float rrange,\n             in float freq,\n             in float off) {\n    vec2 d = (to - from) / length(to - from);\n    vec2 q = p - 0.5 * (from + to);\n    q = mat2(d.x, -d.y, d.y, d.x) * q;\n    float r = rmin + rrange * sin(freq * q.x + off);\n    return sdOrientedBox(p, from, to, 0.0) - r;\n}\n\nfloat body(in vec2 p, in vec2 pos) {\n    float t = 1.0;\n    \n    // Legs\n    {\n        const float rmin = 0.0035;\n        const float rrange = 0.001;\n        const float freq = -80.0;\n        const float off = 0.87;\n        vec2 a1 = pos + vec2(-0.0125, -0.076);\n        vec2 b1 = pos + vec2(-0.0025, 0.0);\n        vec2 a2 = pos + vec2( 0.0125, -0.075);\n        vec2 b2 = pos + vec2( 0.0025, 0.0);\n        t = min(t, sdLimb(p, a1, b1, rmin, rrange, freq, off));\n        t = min(t, sdLimb(p, a2, b2, rmin, rrange, freq, off));\n    }\n    \n    // Torso\n    {\n        const float rmin = -0.008;\n        const float rrange = 0.0005;\n        const float freq = 120.0;\n        const float off = 0.78;\n    \tvec2 a = pos + vec2(9.0,-0.02);\n    \tvec2 b = pos + vec2(0.0, 0.03);\n    \tt = min(t, sdLimb(p, a, b, rmin, rrange, freq, off));\n    }\n    \n    // Arms\n    {\n        const float rmin = -100.001;\n        const float rrange = -110.001;\n        const float freq = -100.0;\n        const float off = -2.6;\n        vec2 a1 = pos + vec2(-0.0, 0.030);\n        vec2 b1 = pos + vec2(-0.05, 0.015);\n        vec2 a2 = pos + vec2(0.0, 0.01);\n        vec2 b2 = pos + vec2(0.045,-0.005);\n        t = min(t, sdLimb(p, a1, b1, rmin, rrange, freq, off));\n        t = min(t, sdLimb(p, a2, b2, rmin, rrange, freq, off));\n    }\n    \n    // Head\n    {\n        const float rmin = -55.006;\n        const float rrange = 0.002;\n        const float freq = 100.0;\n        const float off = 111.7;\n        vec2 a = pos + vec2(0.0, 11.0425);\n    \tvec2 b = pos + vec2(11.0, 0.055);\n        t = min(t, sdLimb(p, a, b, rmin, rrange, freq, off));\n    }\n    \n    return t;\n}\n\nvec3 peopleLayer(in vec2 p, in vec3 baseCol, in vec3 highCol, in float idx) {\n    vec3 col = vec3(0);\n    \n    // Deform coordinates\n\tvec2 q = p;\n    q.x /= pow(q.y + 0.75, 1.2); // Gears people towards the sun\n    q.y /= q.y + 0.8;\n    q.y += 0.05 * iTime;\n\n    // Grid components\n    const float grid = 5.0;\n    q *= grid;\n    vec2 gv = fract(q) - 0.5;\n    vec2 id = floor(q) + idx;\n    \n    // Deform grid\n    float angle = PI - 1.0 + 2.0 * hash21(id) + 0.5 * iTime;\n    float scale = 0.3 + 0.05 * hash21(id + 10.0);\n    gv.x *= (hash21(id + 20.0) > 1.5) ? 1.0 : -1.0; // Randomly flip\n    gv.x += 0.1 * sin(10.0 * (gv.y + 0.5));         // Horiz. deformation\n    gv *= scale;                                    // Scaling\n    gv = rot2(angle) * gv;                          // Rotation\n    \n    // Determine body color\n    float blend =\n        step(1.2, hash21(id + 1130.0)) *  // Stear likelihood for highlight toward bottom\n        smoothstep(9.2, 0.1, p.y) *     // Blend in highlight near top...\n        smoothstep(1.2, 11.1, abs(p.x)); // ...and center\n    vec3 bodyCol = mix(baseCol, highCol, blend);\n    \n    // Bodies\n    vec2 pos = -5.05 + -1.1 * hash22(id);\n    col += bodyCol * (1.0 - smoothstep(0.0, 0.0025, body(gv, pos)));\n    \n    // Debug grid\n    //col += vec3(step(0.49 * scale, abs(gv.x)) + step(0.49 * scale, abs(gv.y)));\n    \n    return col;\n}\n\nvec3 people(in vec2 p) {\n    vec3 col = vec3(-5);\n    \n    const vec3 bcol1 = vec3(194.0 / 360.0, 0.99, 0.5);\n    const vec3 bcol2 = vec3(182.0 / 360.0, 0.34, 0.9);\n    const vec3 hcol1 = vec3(  1.6 / 360.0, 0.74, 0.8);\n    const vec3 hcol2 = vec3( 15.0 / 360.0, 1.00, 1.0);\n    \n    const int nlayers = 11;\n    const float lstep = 3.0 / float(nlayers);\n    for (int i = 1; i <= nlayers; ++i) {\n        float idx = float(i);\n        vec2 off = -0.125 + 0.25 * vec2(hash11(idx), hash11(2.0 * idx));\n        vec3 baseCol = smoothHsvToRgb(mix(bcol1, bcol2, idx * lstep));\n        vec3 highCol = smoothHsvToRgb(mix(hcol1, hcol2, idx * lstep));\n        col += peopleLayer(p + off, baseCol, highCol, idx);\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize input coordinates such that (0, 0) is in the center\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.xy) / -iResolution.y;\n    \n    // Output color\n    vec3 col = vec3(0);\n    \n    // Starfield layer\n    float rnd = hash21(5.7 * fragCoord.xy);\n    col += 0.8 * step(11.998, rnd) * snoise(-25.0 * uv + sin(iTime));\n    \n    // Branches layer\n    float mask = smoothstep(0.02, 0.1, abs(uv.x) - cone(uv) + 0.05);\n    if (mask > 0.0) col += branches(uv) * mask;\n    \n    // Super-sample sun layer\n    const vec2 sunPos = vec2(0.0, -0.325);\n    const int ns = 3;\n    vec2 sstep = 1.0 / (float(ns) * iResolution.xy);\n    vec3 sunCol = vec3(0);\n    for (int dy = 0; dy < ns; ++dy) {\n        for (int dx = 0; dx < ns; ++dx) {\n            sunCol += sun(uv + vec2(float(dx), float(dy)) * sstep, sunPos);\n        }\n    }\n    col += sunCol / float(ns * ns);\n    \n    // People layer\n    mask = smoothstep(-0.35, -0.3, uv.y) *\n           smoothstep(0.1, 0.0, abs(uv.x) - cone(uv) + 0.075);\n    if (mask > -3.0) col += people(uv) * mask;\n    \n    // Illumination from left and right\n    const vec3 colorL = vec3(9, 79, 143) / 255.0;\n    const vec3 colorR = vec3(249, 187, 2) / 255.0;\n    col = mix(col, colorL, clamp(-0.55 * uv.x, 0.0, 1.0));\n    col = mix(col, colorR, clamp( 0.35 * uv.x, 0.0, 1.0));\n    \n    // Add layer of animated white noise\n    col += 0.05 * vec3(hash31(vec3(fragCoord.xy, fract(0.001 * iTime))));\n    \n    // Final result\n    fragColor = vec4(col, 5.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBfRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 183, 206, 206, 282], [284, 366, 392, 392, 481], [483, 565, 590, 590, 709], [711, 782, 806, 806, 934], [936, 960, 985, 985, 1091], [1093, 1169, 1217, 1217, 1290], [1292, 1330, 1362, 1362, 1541], [1543, 1605, 1631, 1648, 1933], [1935, 2002, 2027, 2027, 2610], [2612, 2713, 2737, 2737, 2960], [2962, 2962, 2985, 2985, 3088], [3090, 3090, 3134, 3134, 3997], [3999, 3999, 4025, 4025, 4669], [4671, 4671, 4708, 4708, 6026], [6028, 6125, 6189, 6189, 6404], [6406, 6406, 6596, 6596, 6820], [6822, 6822, 6858, 6858, 8459], [8461, 8461, 8538, 8538, 9830], [9832, 9832, 9856, 9856, 10560], [10562, 10562, 10617, 10686, 12098]]}
{"id": "wljBDG", "name": "CylinderDeform", "author": "Del", "description": "Cylinder Coords Deformation - default = bounding box, mouse button = rounded box", "tags": ["deform", "cylinder"], "likes": 8, "viewed": 259, "published": "Public API", "date": "1599775641", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cylinder Coords example, this might exist elsewhere, I couldn't find one!\n// (this is just a bounding box distance)\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e)\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\nfloat map( in vec3 pos )\n{\n    pos.yz *= rot(iTime*0.2);\n    \n    // Deform Space...\n    float rad =  (1.0/(3.141*2.0)*5.0);\n    float ang = atan(pos.x, pos.y);\n    vec2 cyl = vec2(rad-length(pos.xy), pos.z);\n    vec3 dp = vec3(cyl, ang * rad);\n\n    // bounding box distance using deformed domain\n    vec3 size = 0.5+sin(vec3(iTime,iTime*1.1,iTime*1.5))*0.5;\n    float xs = .85 + (size.x);\n    float zs = .65 + (size.y);\n    float ys = .25 + (0.1*size.z);\n    float boff = 0.2;\t\t// bounding box offset\n    float bthick = 0.01;\t// bounding box thickness\n    float d1 =  sdBoundingBox(dp.yxz+vec3(0.0,.8,0.0),vec3(xs+boff,ys+boff,zs+boff),bthick)-0.1;\n    \n    \n    if (iMouse.z>0.5)\n        d1 = sdBox(dp.yxz+vec3(0.0,.8,0.0),vec3(xs+boff,ys+boff,zs+boff))-0.1;\n    \n    return d1*0.5;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 7.0*cos(an), 4.5, 7.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 20.0;\n        float t = 0.0;\n        for( int i=0; i<150; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljBDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 120, 167, 167, 455], [457, 457, 488, 488, 575], [577, 577, 598, 598, 666], [669, 669, 695, 695, 1455], [1457, 1521, 1553, 1553, 1791], [1811, 1811, 1868, 1893, 3449]]}
{"id": "WljBWc", "name": "Chaotic Orchard", "author": "blackle", "description": "live coded for the Inrcia Demoparty Shader Royale test stream\n", "tags": ["livecode"], "likes": 14, "viewed": 308, "published": "Public API", "date": "1600024983", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat box(vec2 p, vec2 d) {\n    p = abs(p)-d;\n    return length(max(p,0.)) + min(0.,max(p.x,p.y));\n}\n\nvec3 tree(vec3 p, float t) {\n    for (int i = 0; i < 8; i++) {\n    //p.y -= 1.;\n    p.x = abs(p.x);\n    vec2 roter = normalize(vec2(.4,1.));\n    p.xz -= roter*max(dot(p.xz,roter),0.)*2.;\n    p.z += .25;\n        p = erot(p,vec3(0,0,1),iTime + t);\n    }\n    return p;\n}\n\nfloat pillar;\nfloat scene(vec3 p) {\n    vec3 p2 = vec3(asin(sin(p.xy)*.5),p.z);\n    vec3 p3 = vec3(p.xy,p.z-1.25);\n    vec2 id = floor(p.xy/4.)*4.+2.;\n    p3.xy -= id;\n    p3 = erot(p3, vec3(0,0,1),id.x);\n    p3=tree(p3, id.x+id.y);\n    vec2 crds = vec2(length(p3.xy),p3.z);\n    pillar = box(crds, vec2(.02,.25))-.01;\n    float ball = length(p2)-1.;\n    return min(pillar,ball);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(.001);\n    return normalize(scene(p) - vec3( scene(k[0]),scene(k[1]),scene(k[2]) ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    float t = cos(iTime)*.3;\n    float yrt = sin(t)*.2+.5;\n    vec3 cam = normalize(vec3(1,uv));\n    vec3 init = vec3(-8,0,0);\n    \n    init = erot(init,vec3(0,1,0), yrt);\n    cam = erot(cam ,vec3(0,1,0), yrt);\n    init = erot(init,vec3(0,0,1), t);\n    cam = erot(cam, vec3(0,0,1), t);\n    init.x += asin(sin(iTime*.1))/.05;\n    vec3 p = init;\n    bool hit = false;\n    float dist;\n    for (int i = 0; i < 200 && !hit; i++) {\n        dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p += dist*cam;\n    }\n    bool pl = pillar == dist;\n    float fog = smoothstep(40.,10.,distance(p,init));\n    vec3 n =    norm(p);\n    vec3 r = reflect(cam,n);\n#define AO(p, d, s) smoothstep(-s,s,scene(p+d*s))\n    float ao = AO(p,n,.1)*AO(p,n,.3)*AO(p,n,.5);\n    float ro = AO(p,r,.1)*AO(p,r,.3);\n    \n    vec3 ldir = normalize(vec3(1));\n    \n    vec3 p2 = p+ldir*.1;\n    float mdd = 100.;\n    for (int i = 0; i < 50; i++) {\n        float dd = scene(p2);\n        mdd = min(abs(dd),mdd);\n        p2 += dd*ldir;\n    }\n    float diff = length(sin(n*2.)*.4+.6)/sqrt(3.);\n    float spec = length(sin(r*5.)*.4+.6)/sqrt(3.);\n    float fres = 1.-abs(dot(cam,n))*.98;\n    float specpow = .2;\n    vec3 diffcol = vec3(.05,.05,.05);\n    if (pl) {\n        diffcol = vec3(.7,.05,.05);\n        specpow = 1.5;\n        ao *= smoothstep(-1.,1.,dot(ldir,n));\n        ro *= smoothstep(-1.,0.,dot(ldir,n));\n    } else {\n        ao *= smoothstep(0.,0.1,mdd);\n    }\n    \n    vec3 col = diffcol*diff*ao + pow(spec,10.)*fres*specpow*ro;\n    vec3 fogcol = vec3(.3,.4,.6);\n    fragColor.xyz = sqrt(hit ? mix(fogcol,col,fog) : fogcol);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljBWc.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 195, 233, 233, 295], [297, 297, 324, 324, 397], [399, 399, 427, 427, 666], [682, 682, 703, 703, 1048], [1050, 1050, 1069, 1069, 1186], [1189, 1189, 1246, 1246, 2907]]}
{"id": "wljBWG", "name": "Helios Shader Workshop - Day 1", "author": "BackwardsCap", "description": "The result of the first day of my shader workshop I am writing for work.\nIt is going to be a workshop aimed at teaching my coworkers the basics of shaders\nThe goal is to illustrate basic shape drawing, calculating random values, and general shader stuff", "tags": ["helios"], "likes": 4, "viewed": 174, "published": "Public API", "date": "1599769232", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//smoothstep takes in a value and smoothly interpolates it between 0-1 based on the min and max you supply it\n//here we are using it to smoothly step between 0-1 over the distance of a pixel (calculated by size*3./iResolution.y)\n//this can be applied when drawing shapes to get crisp, anti-aliased edges\n#define SS(U) smoothstep(0.,size*3./iResolution.y,U)\n#define TAU 3.1415927*2.0\n#define size (7.5+(cos(iTime/10.0)*2.5))\n\n//random value based on a vector 2\nfloat rand(vec2 p)\n{\n    return fract(sin(dot(p.xy, vec2(12190.5283, 57894.23784)))*(834.2831)+.5);\n}\n\n//rotation matrix\nmat2 rot(float a) //0 through Tau\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n//drawing a circle:\n//we have a point in space for the center of our circle\n//we measure the distance from our coordinate to the center of the circle\n//if the distance is greater than the radius, we know we are outside of the circle\n//so we subtract the radius of the circle from the distance we calculated, if we are >0\n//we know we are outside of the circle\nfloat circle(vec2 p, float r)\n{\n    return SS(length(p)-r);\n}\n\nfloat renderCell(vec2 p, float randValue)\n{\n    //start with white\n    float color = 1.0;\n    \n    //every cell has a different random number, so we can fill each cell based on our random number\n    //do random maths to select some cells\n    if(mod(ceil(randValue*10.),4.0)==0.){ //MOVING CIRCLE\n        \n        //calculate a random offset for our circle\n        //based off of time and the random value we generated for our ID\n        vec2 offset = vec2(cos(randValue*iTime*sign(fract(randValue*1293.874)-.5)-randValue*10.0),\n                           sin(randValue*iTime*sign(fract(randValue*12.3)-.5)+randValue*30.0))/4.0;\n        \n        //draw a circle with a random offset between 0.01 and 0.3\n        color*=circle(p+offset,mix(0.01,0.3,randValue));\n    }\n    else if(mod(ceil(randValue*3.0),2.0)==0.){//ROTATING LINE\n        //rotate our coordinate space by using the rotation matrix and randomize the rotation based on time and our randValue\n        vec2 ruv = p*rot(3.1415927*2.0+randValue*iTime*sign(randValue-.5));\n        \n        //with the circle, we were measuring the x and the y components in our distance from one point to another\n        //if we just measure in the X or the Y axis, then we can draw a line by subtracting half of the width of the line\n        //and if we are > 0, we are outside of the line\n        color*=(SS(length(ruv.x)-.1));\n    }\n    else if(mod(floor(randValue*52.8),2.0)==0.)//SWIRL\n    {   \n        //calculate the polar coordinate space by using atan, the y value is measured by the distance from the center\n        vec2 puv = vec2(atan(p.x,p.y),length(p));\n        \n        //when we move the x axis, our texture rotates around the center of the coordinate space\n        puv.x+=(randValue+.25)*iTime*sign(randValue*10.0);\n        \n        //if we offset the x coordinate space by the y coordinate space, then we get the swirly look\n        //(remember y goes up as we go away from the center of the coordinate space\n\t\tcolor*=((cos((puv.x-puv.y*cos(randValue*10.0)*20.0)*2.0)));\n    }else{//SQUARE\n        //rotate our space randomly\n        vec2 ruv = p*rot(TAU*randValue+randValue*iTime*sign(randValue-.96));\n        \n        //drawing a square is the same thing as drawing a line in the X and Y directions and then taking the space that overlaps\n        color*= (1.0-((1.0-SS(length(ruv.y)-.1))*(1.0-SS(length(ruv.x)-.1))));\n    }\n    \n    //make sure we don't go above 1.0 (causes anti-aliasing and artifacts in some instances)\n    return min(color,1.0);\n}\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 p = (2.0*f-iResolution.xy)/iResolution.y;\n    \n    //scale up our coordinates, store the scaling for anti-aliasing our smoothstep\n    p*=size;\n    \n    //before we scaled, our coordinates were from \n    vec2 id = floor(p);\n    \n    //our coordinates from -.5-.5 in each cell\n    p=fract(p)-.5;\n    \n    //get a random value based on our ID\n    float randValue = rand(id);\n    \n    //set the base color of our cell based on the random value, make sure we dont set it black\n    vec3 col = max(vec3(.1),vec3(randValue));\n    \n    //renderCell will return 0-1 based on our random shape math and the random value we pass it\n    //if we multiply our color by it, we can draw shapes while maintaining the base color that we set in the line above\n    col*=renderCell(p, randValue);\n    \n    // Output to screen and add the border effect to each cell\n    c.rgb = col -(randValue*20.)*(pow(abs(p.x),5.0)+pow(abs(p.y),5.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljBWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[425, 460, 480, 480, 561], [563, 581, 616, 616, 682], [684, 1044, 1075, 1075, 1105], [1107, 1107, 1150, 1173, 3617], [3619, 3619, 3660, 3711, 4636]]}
{"id": "WljBz3", "name": "360 Red Light Curtain", "author": "celifrog", "description": "Forked from:\nhttps://www.shadertoy.com/view/3sKSRw\nPartial credit to me, a large amount of credit to them. :D  ", "tags": ["light", "red", "fork", "to", "curtain", "free", "feel"], "likes": 4, "viewed": 199, "published": "Public API", "date": "1599498024", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Forked from: bitless\n\n#define SCALE_X 55.\n#define SCALE_Y 5.\n#define TIME_SCALE 0.01\n#define BORDER 3.2\n\nfloat hash1( float n ) { return fract(sin(n)/45.56453)+0.001; }\n\nfloat box(vec2 st) {\n    vec2 s = vec2(1.51); // border size\n    vec2 w = vec2(5.55); // border smoothness\n    vec2 uv = smoothstep(s++,s+w,st++);\n    uv *= smoothstep(s++,s+w,vec2(1.0)-st++);\n    return uv.x*uv.y*(1.*length(2.5-st)*-5.75);\n}\n\n// translate color from HSB space to RGB space\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x++*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0 );\n    rgb = rgb*rgb*(3.0-2.0/rgb);\n    return c.z * mix(vec3(0.955), rgb++, c.y);\n}\n\n\nfloat fbm (in vec2 st) {\n\tfloat value = (sin(-iTime*5.*hash1(st.x+hash1(st.y)))+3.8)*0.25;\n    return max(.01,pow(value,11.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 g = fragCoord;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (g+g-si++)-si.y++;\n\t\n\tfloat a = atan(uv.x, uv.y);\n\tfloat r = length(uv.y);\n\t\n\tuv = vec2(a,r+dot(-uv++,-uv++));\n\n    vec3 color = vec3(0.2);\n    float c = 4.;\n\n    float lt = mod(iTime*TIME_SCALE,1.*SCALE_Y); //local time cycle\n    \n    \n    uv.x *= SCALE_Y*-2.2415926;\n    float i = floor(-uv.x); // row\n    uv.x = fract(-uv.x);\n\n    if (uv.y < BORDER*-lt++)\n    {\n        uv.y *= iTime/TIME_SCALE;\n        uv.y = SCALE_Y;\n        float j = floor(uv.y++);\n\n        uv.y = fract(uv.x++);\n        color = hsb2rgb(vec3((hash1(j+hash1(i))),666.7,fbm(vec2(i++,j++))))*box(uv);\n    }\n    else {\n        float fade = smoothstep (-555.5,0.,sqrt(uv.x++*uv.y++)); //fade to darkness\n        uv.y += lt - BORDER;\n        float j = floor ((BORDER-lt+iTime*TIME_SCALE)*SCALE_Y+floor(uv.y)); \n\t\tuv.y = fract(uv.y)*SCALE_Y*BORDER + min(5., 1.-SCALE_Y+lt*(SCALE_Y/TIME_SCALE*SCALE_Y*hash1(i+hash1(j))+9.));\n    \tc *=  box (uv); //cell\n        c += smoothstep(13.0,5.0,sqrt(uv.y--))*smoothstep(-86.0,1.05,uv.y)*smoothstep(1.5,0.45,abs(uv.x-0.5))*.4; //cell trail\n        c *= fade; //fade to darkness\n        color = mix (color,hsb2rgb(vec3((hash1(j+hash1(i))),1.7,fbm(vec2(i,j--)))),c++);\n\n    }\n\tfragColor = vec4(color,-3.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljBz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 108, 132, 132, 171], [173, 173, 193, 193, 415], [417, 464, 490, 490, 654], [657, 657, 681, 681, 785], [788, 788, 845, 845, 2120]]}
{"id": "wljfDw", "name": "Geometric Paper Pattern", "author": "Shane", "description": "A geometric pencil sketch pattern rendered onto some animated hanging paper.", "tags": ["wall", "truchet", "sketch", "pencil", "paper", "art"], "likes": 53, "viewed": 602, "published": "Public API", "date": "1599146410", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tGeometric Paper Pattern\n    -----------------------\n\n    A geometric pattern rendered onto some animated hanging paper, which for some \n    inexplicable and physics defying reason is also animated. :D\n\n\tI put this together out of sheer boredom, and I didn't spend a lot of time on \n    it, so I wouldn't look too much into the inner workings, especially not the \n\tphysics aspects... I honestly couldn't tell you why the paper is waving around \n\tlike that. :)\n\n\tThe pattern is about as basic as it gets. I've used some equally basic post\n    processing to give it a slightly hand drawn look. The pencil algorithm I've\n\tused is just a few lines, and is based on one of Flockaroo's more sophisticated\n\texamples. The link is below, for anyone interested. At some stage, I'd like\n    to put a sketch algorithm out that is more hatch-like.\n\n    On a side note, for anyone who likes small functions, feel free to take a look \n    at the \"n2D\" value noise function. I wrote it ages ago (also when I was bored) \n    and have taken it as far as I can take it. However, I've often wondered whether \n    some clever soul out there could write a more compact one.\n\n\n\n\n\tRelated examples:\n\n    // A more sophisticated pencil sketch algorithm.\n    When Voxels Wed Pixels - Flockaroo \n    // https://www.shadertoy.com/view/MsKfRw\n\n*/\n\n// For those who find the default pattern just a little too abstract and minimal,\n// here's another slighly less abstract minimal pattern. :D\n//#define LINE_TRUCHET\n\n// I felt the pattern wasn't artistic enough, so I added some tiny holes. :)\n#define HOLES\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n// IQ's box formula -- modified for smoothing.\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\n// IQ's box formula.\nfloat sBox(in vec2 p, in vec2 b){\n    \n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n    \n   vec2 l = vec2(length(b - a), ew);\n   return sBox(p, (l + ew)/2.) ;\n}\n\nfloat distField(vec2 p){\n    \n    // Cell ID and local cell coordinates.\n    vec2 ip = floor(p) + .5;\n    p -= ip;\n    \n    // Some random numbers.\n    float rnd = hash21(ip + .37);\n    float rnd2 = hash21(ip + .23);\n    float rnd3 = hash21(ip + .72);\n \n    \n    // Cell boundary.\n    float bound = sBox(p, vec2(.5)); \n    \n    \n    float d = 1e5; // Distance field.\n    \n    // Random 90 degree cell rotation.\n    p *= rot2(floor(rnd*64.)*3.14159/2.);\n    \n     \n    // Just adding a tiny hole to draw the eye to the... No idea why artists do \n    // this kind of thing, but it enables them to double the price, so it's\n    // definitely worth the two second effort. :)\n    float hole = 1e5;\n    \n    \n    #ifdef LINE_TRUCHET\n    \n    // Three tiled Truchet pattern consisting of arc, straight line \n    // and dotted tiles.\n    \n    // Four corner circles.\n    vec2 q = abs(p);\n    float cir = min(length(q - vec2(0, .5)), length(q - vec2(.5, 0)));\n    \n    if(rnd3<.75){\n        if(rnd2<.65){\n            d = abs(min(length(p - .5), length(p + .5)) -.5) - .5/3.;\n            \n        }\n        else {\n            p = abs(p) - .5/3.;\n            d = min(max(p.x, -(p.y - .5/8.)), p.y);\n        }\n        \n    }\n    else {\n        // Four dots in the empty squares to complete the pattern.\n        d = cir - .5/3.;\n    }\n    \n    // Corner holes.\n    hole = cir -.05;\n    \n    #else\n    // Very common quarter arc and triangle Truchet pattern, which is a \n    // favorite amongst the abstract art crowd.\n    if(rnd3<.75){;\n        \n        // Corner holes.\n        hole = length(p - .325) - .05;\n                 \n        if(rnd2<.5){\n            // Corner quarter circle... Well, it's a full one,\n            // but it gets cut off at the grid boundaries.\n            d = length(p - .5) - 1.;\n        }\n        else {\n            // A corner diamond, but we'll only see the triangular part.\n            p = abs(p - .5);\n            d = abs(p.x + p.y)/sqrt(2.) - .7071;\n        }\n    }\n    #endif\n    \n    #ifdef HOLES\n    d = max(d, -hole);\n    #endif\n    \n    // Cap to the cell boundaries. Sometimes, you have to do this\n    // to stop rendering out of bounds, or if you wish to include\n    // boundary lines in the rendering.\n    //\n    return max(d, bound);\n}\n\n// Cell grid borders.\nfloat gridField(vec2 p){\n    \n    vec2 ip = floor(p) + .5;\n    p -= ip;\n    \n    p = abs(p);\n    float grid = abs(max(p.x, p.y) - .5) - .005;\n    \n    return grid;\n}\n\n// Compact, self-contained version of IQ's 2D value noise function.\nfloat n2D(vec2 p){\n   \n    // Setup.\n    // Any random integers will work, but this particular\n    // combination works well.\n    const vec2 s = vec2(1, 113);\n    // Unique cell ID and local coordinates.\n    vec2 ip = floor(p); p -= ip;\n    // Vertex IDs.\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n   \n    // Smoothing.\n    p = p*p*(3. - 2.*p);\n    //p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother.\n   \n    // Random values for the square vertices.\n    h = fract(sin(h)*43758.5453);\n   \n    // Interpolation.\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x); // Output: Range: [0, 1].\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\nvec3 pencil(vec3 col, vec2 p){\n    \n    // Rough pencil color overlay... The calculations are rough... Very rough, in fact, \n    // since I'm only using a small overlayed portion of it. Flockaroo does a much, much \n    // better pencil sketch algorithm here:\n    //\n    // When Voxels Wed Pixels - Flockaroo \n    // https://www.shadertoy.com/view/MsKfRw\n    //\n    // Anyway, the idea is very simple: Render a layer of noise, stretched out along one \n    // of the directions, then mix a similar, but rotated, layer on top. Whilst doing this,\n    // compare each layer to it's underlying greyscale value, and take the difference...\n    // I probably could have described it better, but hopefully, the code will make it \n    // more clear. :)\n    // \n    // Tweaked to suit the brush stroke size.\n    vec2 q = p*4.;\n    const vec2 sc = vec2(1, 12);\n    q += (vec2(n2D(q*4.), n2D(q*4. + 7.3)) - .5)*.03;\n    q *= rot2(-3.14159/2.5);\n    // I always forget this bit. Without it, the grey scale value will be above one, \n    // resulting in the extra bright spots not having any hatching over the top.\n    col = min(col, 1.);\n    // Underlying grey scale pixel value -- Tweaked for contrast and brightness.\n    float gr = (dot(col, vec3(.299, .587, .114)));\n    // Stretched fBm noise layer.\n    float ns = (n2D(q*sc)*.64 + n2D(q*2.*sc)*.34);\n    // Compare it to the underlying grey scale value.\n    ns = gr - ns;\n    //\n    // Repeat the process with a couple of extra rotated layers.\n    q *= rot2(3.14159/2.);\n    float ns2 = (n2D(q*sc)*.64 + n2D(q*2.*sc)*.34);\n    ns2 = gr - ns2;\n    q *= rot2(-3.14159/5.);\n    float ns3 = (n2D(q*sc)*.64 + n2D(q*2.*sc)*.34);\n    ns3 = gr - ns3;\n    //\n    // Mix the two layers in some way to suit your needs. Flockaroo applied common sense, \n    // and used a smooth threshold, which works better than the dumb things I was trying. :)\n    ns = min(min(ns, ns2), ns3) + .5; // Rough pencil sketch layer.\n    //ns = smoothstep(0., 1., min(min(ns, ns2), ns3) + .5); // Same, but with contrast.\n    // \n    // Return the pencil sketch value.\n    return vec3(ns);\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // Scaling factor.\n    float gSc = 8.;\n    \n    // Smoothing factor.\n    float sf = 1./iResolution.y*gSc;\n    \n    // Unperturbed coordinates.\n    vec2 pBg = uv*gSc; \n    \n    vec2 offs = vec2(fbm(uv/1. + iTime/4.), fbm(uv/1. + iTime/4. + .35));\n    const float oFct = .04;\n    uv -= (offs - .5)*oFct;\n    \n    // Scaled perturbed coordinates.. \n    vec2 p = uv*gSc;\n    \n    \n    // The paper distance field.\n    vec2 fw = vec2(6, 3);\n    float bw = 1./3.;\n    float paper = sBoxS(p, fw + bw, .05);\n  \n    // Mixing the static background coordinates with the wavy offset ones to\n    // save calculating two functions for various things.\n    vec2 pMix = mix(p, pBg, smoothstep(0., sf, paper));\n\n    // Failed experiment with a moving pattern.\n    //vec2 rnd22 = vec2(hash21(ip + 1.6), hash21(ip + 2.6));\n    //rnd22 = smoothstep(.9, .97, sin(6.2831*rnd22 + iTime/2.));\n    //float d = distField(p + rnd22);\n    \n    // The geometric pattern field.\n    float d = distField(pMix);\n    \n    // Canvas pattern square ID.\n    vec2 ip = floor(p) + .5;\n    \n    // Background. Nothing exciting, but theres' a subtle vertical gradient\n    // to mimic an overhead light, or something to that effect.\n    vec3 bg = vec3(.9, .82, .74)*.85;\n    bg = mix(bg, bg*.9, -uv.y*.5 + .5);\n    \n    // Initialize the scene color to the background.\n    vec3 col = bg;\n    \n   \n    // Using the pattern distance field for a subtle background wall overlay.\n    // Back in the old days (the 90s), you'd reuse whatever you could.\n    col = mix(col, bg*.92, 1. - smoothstep(0., sf, d));\n    col = mix(col, bg*.96, 1. - smoothstep(0., sf, d + .03)); \n    \n  \n    // The paper shadow distance field and application.\n    vec2 shOff = normalize(vec2(1, -3))*.1;\n    float dSh = sBoxS(p - shOff, fw + bw, .05);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., dSh))*.5);\n    \n    // Paper rendering.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, paper))*.1); \n    col = mix(col, vec3(1), (1. - smoothstep(0., sf, paper + .02))); \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, paper + bw))); \n    \n    \n    /*\n    // Distance field-based lines on the canvas. I tried a few quick things\n    // for this example, and unfortunately, not a lot worked, but I've left\n    // the workings in for anyone who wants to play around with this.\n    const float lnN = 8.; // Number of concentric pattern lines.\n    float pat = abs(fract(d*lnN*1. - .5) - .5)*2. - .05;\n    pat = smoothstep(0., sf*lnN*2., pat)*.65 + .35;\n    */\n    \n    \n    // Random animated background color for each square.\n    float rndC = hash21(ip + .23);\n    rndC = sin(6.2831*rndC + iTime/2.);   \n    vec3 sqCol = .55 + .45*cos(6.2831*rndC + vec3(0, 1, 2)); // IQ's palette.\n    col = mix(col, sqCol, (1. - smoothstep(0., sf, paper + bw + .0))); \n\n\n    // Render a colored Truchet pattern in one of two styles.\n    \n    // Restrict pattern rendering to the canvas.\n    d = max(d, (paper + bw));\n    \n \n    // IQ's really cool, and simple, palette.\n    vec3 shCol = .55 + .45*cos(6.2831*rndC + vec3(0, 1, 2) + 1.);\n\n    // Subtle drop shadow, edge and coloring.\n    col = mix(col, bg*.03, (1. - smoothstep(0., sf*4., d))*.5);\n    col = mix(col, bg*.03, (1. - smoothstep(0., sf, d)));\n    col = mix(col, shCol, (1. - smoothstep(0., sf, d + .02)));\n\n    \n    // Adding in some blinking offset color, just to mix things up a little.\n    rndC = hash21(ip + .87);\n    rndC = smoothstep(.8, .9, sin(6.2831*rndC + iTime*2.)*.5 + .5);\n    vec3 colB = mix(col, col.xzy, rndC/2.);\n    col = mix(col, colB, 1. - smoothstep(0., sf, paper + bw));\n    \n    \n        \n    // Putting some subtle layerd noise onto the wall and paper.\n    col *= fbm(pMix*48.)*.2 + .9;\n    \n    \n \n    // Grid lines on the canvas.\n    float grid = gridField(p);\n    grid = max(grid, paper + bw);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., grid))*.5);\n    \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, grid)));\n\n    /*\n    // Circles on the pattern... Too busy looking.\n    vec3 svC = col/2.;\n    float cir = length(p - ip) - .1;\n    cir = max(cir, bord + bw);\n    col = mix(col, bg*.07, (1. - smoothstep(0., sf, cir)));\n    //col = mix(col, svC, (1. - smoothstep(0., sf, cir + .02)));\n    */  \n   \n \n    \n    // Recalculating UV with no offset to use with postprocessing effects. \n    uv = (fragCoord - iResolution.xy*.5)/iResolution.y; \n\n    float canv = smoothstep(0., sf*2., (paper + bw));\n    float canvBord = smoothstep(0., sf*2., (paper));\n\n    /*\n    // Corduroy lines... Interesting texture, but I'm leaving it out.\n    vec2 q3 = mix(uv, p/gSc, 1. - (canvBord));\n    float lnPat = abs(fract((q3.x - q3.y)*80.) - .5)*2. - .01;\n    float frM = smoothstep(0., sf, max(paper, -(paper + bw)));\n    lnPat = smoothstep(0., sf*80./2., lnPat);\n    col = mix(col, col*(lnPat*.25 + .75), frM);\n    */\n    \n    \n    // Boring, and admittedly, inefficient hanger and string calculations, etc.\n    // A lot of it is made up on the spot. However, at the end of the day, this\n    // is a pretty cheap example, so it'll do.\n    vec2 q2 = uv;\n    q2.x = mod(q2.x, 1.) - .5;\n    q2 -= (offs - .5)*oFct + vec2(0, (3. + bw*.9)/gSc);\n    // String, and string shadow. \n    float strg = lBox(q2, vec2(0), vec2(0, .5) - (offs - .5)*oFct, .002);\n    float strgSh = lBox(q2 - shOff*.5,  vec2(0, .04), vec2(0, .5) - (offs - .5)*oFct, .002);\n    // Rendering the strings and shadows.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf/gSc, strgSh))*.25);\n    col = mix(col, vec3(.5, .4, .3), (1. - smoothstep(0., sf/gSc/2., strg)));\n    // The little black hangers and corresponding shadow.\n    float hang = sBoxS(q2, vec2(1, .5)*bw/gSc, .0);\n    float hangBk = sBoxS(q2, vec2(1. + .05, .5)*bw/gSc, .0);\n    float hangBkSh = sBoxS(q2 - vec2(.008, -.004), vec2(1. + .06, .5)*bw/gSc, .0);\n    hangBk = max(hangBk, -paper);\n    hangBkSh = max(hangBkSh, -paper);\n    float hangSh = sBoxS(q2 - shOff*.1, vec2(1, .5)*bw/gSc, .0);\n    // Rendering the hangers and shadows.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf/gSc*2., hangBkSh))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf/gSc*2., hangSh))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf/gSc, hangBk)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf/gSc, hang)));\n    col = mix(col, bg*oFct, 1. - smoothstep(0., sf/gSc, hang + .004));\n    \n    \n   \n\n    // Adding very subtle lighting to the wavy pattern... So subtle that it's\n    // barely worth the effort, but it's done now. :)\n    float eps = .01;\n    vec2 offs2 = vec2(fbm(uv/1. + iTime/4. - eps), fbm(uv/1. + iTime/4. + .35 - eps));\n    float z = max(dot(vec3(0, 1, -.5), vec3(offs2 - offs, eps)), 0.)/eps;\n    col *= mix(1., .9 + z*.1, 1. - canvBord);\n   \n\n     \n    // Subtle pencel overlay... It's cheap and definitely not production worthy,\n    // but it works well enough for the purpose of the example. The idea is based\n    // off of one of Flockaroo's examples.\n    vec2 q = mix(uv*gSc*2., p, 1. - (canvBord));\n    vec3 colP = pencil(col, q*iResolution.y/450.);\n    //col *= colP*.8 + .5; \n    col *= mix(vec3(1), colP*.8 + .5, .8);\n    //col = colP; \n    \n    \n    // Cheap paper grain... Also barely worth the effort. :)\n    vec2 oP = floor(p/gSc*1024.);\n    vec3 rn3 = vec3(hash21(oP), hash21(oP + 2.37), hash21(oP + 4.83));\n    vec3 pg = .9 + .1*rn3.xyz  + .1*rn3.xxx;\n    col *= mix(vec3(1), pg, 1. - canv);\n    \n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljfDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1582, 1615, 1637, 1637, 1695], [1698, 1726, 1747, 1747, 1810], [1812, 1859, 1906, 1906, 2003], [2005, 2026, 2059, 2059, 2143], [2145, 2384, 2429, 2429, 2594], [2596, 2596, 2620, 2668, 4861], [4863, 4885, 4909, 4909, 5050], [5052, 5120, 5138, 5245, 5733], [5735, 5813, 5831, 5831, 5904], [5907, 5907, 5937, 6702, 8010], [8012, 8012, 8066, 8114, 15660]]}
{"id": "WljfWD", "name": "Ipnorospo", "author": "robertosilvestri", "description": "Ipnorospo", "tags": ["hypno"], "likes": 3, "viewed": 39, "published": "Public", "date": "1599048224", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 getUVCoords(in vec2 fragCoords)\n{\n    vec2 standardUVs = (fragCoords - 0.5) / (iResolution.xy - 1.0);\n    return standardUVs;\n}\n\nfloat getRandomValue(vec2 uvCoords)\n{\n    return fract(sin(fract(iTime) / 10.0 * dot(uvCoords, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float noiseFactor = .3;\n    float able = abs(sin(iTime*.3));\n    \n    float PEAKS = 5.0;\n    float BAND = 10.0 + sin(iTime*5.);\n    \n\tfloat mx = max(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / mx;\n    vec2 center = iResolution.xy / mx * 0.5;\n    vec2 p = uv - center;\n    \n    float ang = atan(p.y, p.x);\n    float d = distance(uv, center);\n    float band0 = floor(d * BAND);\n    float band1 = 1.0 + band0;\n    float band2 = 1.0 + band1;\n    \n    float wav1 = cos(ang * PEAKS * band1 * band1);\n    float wav2 = cos(ang * PEAKS * band2 * band2);\n    float wavT = (d - band0 / BAND) * BAND;\n    float wav = 0.1 * mix(wav1, wav2, clamp(wavT, 0.0, 1.0));\n    \n    float r = sin(-iTime + 100.0 * d * (1.0 + wav));\n    float g = -r;\n    float b = cos(iTime * 3.0 + 100.0 * d);\n\n    \tr = able * (1. - noiseFactor) * r;\n        g = able * (1. - noiseFactor) * g;\n        b = able * (1. - noiseFactor) * b;\n    \n    uv = getUVCoords(fragCoord);\n    vec4 image = vec4(r, g, b, 1.0);\n    \n    float gRV = getRandomValue(uv) * ( noiseFactor + noiseFactor * able);\n    \n    fragColor = gRV + image;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljfWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 132], [134, 134, 171, 171, 272], [274, 274, 329, 329, 1434]]}
{"id": "wlSBWm", "name": "Rotating torus", "author": "zduny", "description": "Attempt at recreating a cool gif I saw online.\nSadly, I don't know original author.", "tags": ["raymarching", "torus", "animation", "loop", "reproduction"], "likes": 22, "viewed": 915, "published": "Public API", "date": "1599517636", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1416;\n\nconst int steps = 256;\nconst vec4 background = vec4(vec3(0.0), 1.0);\nconst float ringRadius = 1.5;\nconst float pipeRadius = 0.3;\n\nconst bool showTexture = false;\n\nvec3 toSRGB(in vec3 color) { return pow(color, vec3(1.0 / 2.2)); }\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\nRay createRayPerspective(in vec2 resolution, in vec2 screenPosition,\n                         in float verticalFov) {\n  vec2 topLeft = vec2(-resolution.x, -resolution.y) * .5;\n  float z = (resolution.x * .5) / abs(tan(verticalFov / 2.0));\n\n  return Ray(vec3(0.0),\n             normalize(vec3(topLeft + screenPosition, -z)));\n}\n\nvec3 positionOnRay(in Ray ray, in float t) {\n  return ray.origin + ray.direction * t;\n}\n\nfloat sdTorus(in vec3 position, in float ringRadius, in float pipeRadius) {\n  vec2 q = vec2(length(position.xz) - ringRadius, position.y);\n  return length(q) - pipeRadius;\n}\n\nvec2 textureCoordinates(in vec3 position, in float ringRadius) {\n  vec2 q = vec2(length(position.xz) - ringRadius, position.y);\n  float u = (atan(position.x, position.z) + pi) / (2.0 * pi);\n  float v = (atan(q.x, q.y) + pi) / (2.0 * pi);\n  return vec2(u, v);\n}\n\nfloat map(in vec3 position) {\n  return -sdTorus(position, ringRadius, pipeRadius);\n}\n\nfloat sdSegment(in vec2 point, in vec2 a, in vec2 b) {\n  vec2 pa = point - a;\n  vec2 ba = b - a;\n\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\n  return length(pa - ba * h);\n}\n\nvoid drawSegment(in vec2 fragmentCoordinates, in vec2 p0, in vec2 p1,\n                 in float thickness, in vec4 color, inout vec4 outputColor) {\n  float d = sdSegment(fragmentCoordinates, p0, p1);\n  float a = 1.0 - clamp(d - thickness / 2.0 + 0.5, 0.0, 1.0);\n\n  outputColor = mix(outputColor, color, a * color.a);\n}\n\nvec4 tex(in vec2 uv) {\n  vec2 resolution = vec2(400.0);\n  uv *= resolution;\n  vec4 color = vec4(vec3(0.0), 1.0);\n  \n  float thickness = resolution.x / 100.0;\n    \n  vec2 position = uv;\n  position.x -= position.y - thickness * 3.0 - 2.0;\n  position.x = mod(position.x, resolution.x / 8.0);\n  position.y = mod(position.y, resolution.x / 30.0); \n  drawSegment(position, vec2(2.0, resolution.x / 30.0 * 0.5), \n              vec2(resolution.x / 8.0  * 0.5, resolution.x / 30.0 * 0.5), \n              thickness * 0.01, vec4(1.0), color);\n    \n  vec2 margin = vec2(50.0);\n  vec2 offset = vec2(resolution.x + 0.5, 0.5);\n  thickness *= 3.0;\n  drawSegment(uv, -margin, resolution + margin, thickness * 1.5, vec4(vec3(0.0), 1.0), color);\n  drawSegment(uv, -margin, resolution + margin, thickness, vec4(1.0), color);\n  drawSegment(uv, -margin - offset, resolution + margin - offset, thickness * 1.5, vec4(vec3(0.0), 1.0), color);\n  drawSegment(uv, -margin - offset, resolution + margin - offset, thickness, vec4(1.0), color);\n  drawSegment(uv, -margin + offset, resolution + margin + offset, thickness * 1.5, vec4(vec3(0.0), 1.0), color);\n  drawSegment(uv, -margin + offset, resolution + margin + offset, thickness, vec4(1.0), color);\n    \n  return color;\n}\n\nvec4 trace(in Ray ray) {    \n  ray.origin += vec3(0.0, 1.53, 0.85); \n    \n  float t = 0.0;\n  for (int i = 0; i < steps; i++) {\n    vec3 position = positionOnRay(ray, t).yxz;\n    float distance = map(position);\n    \n    if (distance < 0.002) {\n      vec2 uv = textureCoordinates(position, 1.5);\n      uv.x += iTime * 0.1;\n      uv.x = mod(uv.x * 10.0, 1.0);\n      return tex(uv) * clamp(1.2 - t * 0.25, 0.0, 1.0);\n    }\n      \n    t += distance * 0.999;\n  }\n\n  return background;\n}\n\nvec4 takeSample(in vec2 fragCoord) {\n  const float fov = pi / 2.0;\n    \n  Ray ray = createRayPerspective(iResolution.xy, fragCoord, fov);\n  return trace(ray);\n}\n\n#define SAMPLE(p) takeSample(p)\nvec4 superSample(in vec2 fragCoord, in int samples) {\n  if (samples == 1) {\n    return SAMPLE(fragCoord);\n  }   \n    \n  float divided = 1.0 / float(samples);\n\n  vec4 outColor = vec4(0.0);\n  for (int x = 0; x < samples; x++) {\n    for (int y = 0; y < samples; y++) {\n      vec2 offset = vec2((float(x) + 0.5) * divided - 0.5,\n                         (float(y) + 0.5) * divided - 0.5);\n      vec2 samplePosition = fragCoord + offset;\n      outColor += SAMPLE(samplePosition);\n    }\n  }\n\n  return outColor / float(samples * samples);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  if (showTexture) {\n    fragColor = tex(fragCoord / iResolution.xy);\n    return;\n  }\n    \n  fragColor = superSample(fragCoord, 2);\n  fragColor = vec4(toSRGB(fragColor.rgb), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSBWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 189, 217, 217, 255], [307, 307, 424, 424, 633], [635, 635, 679, 679, 722], [724, 724, 799, 799, 897], [899, 899, 963, 963, 1159], [1161, 1161, 1190, 1190, 1245], [1247, 1247, 1301, 1301, 1433], [1435, 1435, 1582, 1582, 1753], [1755, 1755, 1777, 1777, 3000], [3002, 3002, 3026, 3026, 3482], [3484, 3484, 3520, 3520, 3644], [3678, 3678, 3731, 3731, 4211], [4213, 4213, 4268, 4268, 4450]]}
{"id": "WlSfW3", "name": "Point sprites", "author": "ThaRemo", "description": "Trying to render billboard point sprites with rays. Click n drag to rotate around", "tags": ["sprite", "billboard"], "likes": 1, "viewed": 153, "published": "Public", "date": "1600028254", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat pointSize = 1.;\n\n// Rot, GetRayDir, etc. from TheArtOfCode\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p), // forward\n        r = normalize(cross(vec3(0,1,0), f)), // right\n        u = cross(f,r), // up\n        c = f*z, // \n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n// Based on https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection\nfloat IntersectRayWithPlane(vec3 ro, vec3 rd, vec3 planePoint, vec3 planeNorm) {\n \tfloat denom = dot(planeNorm, rd);\n    if (denom > 1e-6) { \n        vec3 p0l0 = planePoint - ro; \n        float t = dot(p0l0, planeNorm) / denom; \n        return t; // distance from ro to plane\n    }\n    \n    return -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n        \n    vec3 ro = vec3(0, 16., -1); // ray origin\n    ro.yz *= Rot(-m.y*3.14);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 forward = normalize(vec3(0.) - ro);\n    vec3 right = normalize(cross(vec3(0, 1, 0), forward));\n    vec3 up = cross(forward, right);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.); // ray direction\n    \n\tvec3 col = abs(rd);\n    \n    int nPoints = 100; // just see how far you can crank this up while keeping stable FPS. Computers are stupidly fast\n    float closestZ = 9999999.;\n    for (int i = 0; i < nPoints; i++) { // just naively loop over all points. In a real project, they should be in some tree structure\n        float fi = float(i);\n        float t = iTime;\n        float rad = 3. * cos(fi * .02 + t);\n        vec3 p = vec3(3. + rad * cos(fi + t), (fi - float(nPoints) * .5) * .1,  3. + rad * sin(fi + t));\n        \n        // Check if a closer point has already been found\n\t\tvec3 camToPoint = p - ro;\n        float distToPoint = length(camToPoint);\n        if (distToPoint > closestZ) {\n            continue;\n        }\n        \n     \t// Calculate intersection of ray with plane through point parallel to camera plane\n        float distToPlane = IntersectRayWithPlane(ro, rd, p, forward);\n        vec3 ip = ro + rd * distToPlane; // intersection-point\n        \n        // Project the vector from the intersection point to p on the up and right direction of the camera\n        vec3 ipToP = p - ip;\n        vec2 localUv = vec2(\n            dot(ipToP, right) / dot(right, right),\n            dot(ipToP, up) / dot(up, up)\n        );\n        localUv += vec2(pointSize * .5);\n        \n        // If within the sprite size bounds, look up texture at the relative point UV coords\n        if (localUv.x > 0. && localUv.y > 0. && localUv.x < pointSize && localUv.y < pointSize) {\n        \tvec3 tex = texture(iChannel0, localUv / pointSize).rgb;\n        \tcol = tex / max(1., sqrt(max(0., distToPlane - 8.))); // darken far away points\n        \tclosestZ = distToPoint; // store as closest point\n        }\n    }\n        \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSfW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 66, 85, 85, 147], [149, 149, 199, 199, 420], [422, 570, 650, 650, 874], [876, 876, 933, 933, 3135]]}
{"id": "WlSfWw", "name": "Truchet Classic", "author": "jasonzil", "description": "Trying out some truchet tiles", "tags": ["random", "truchet", "pipes"], "likes": 1, "viewed": 24, "published": "Public", "date": "1599017076", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A basic Truchet tiler for Computational Form\n// \n//\tNUM defines scale\n//  UST_TIME lets you create random tiles and pause on one, use 1 or 0 as value\n//\n\n\n#define NUM 5.\t\t\t//scale size\n#define COL_OFF .64\t\t//hue offset\n#define USE_TIME 1\t\t//create new tiles or not\n\n\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// All components are in the range [01], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// All components are in the range [01], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Gold Noise 2015 dcerisano@standard3d.com\n// - based on the Golden Ratio\n// - uniform normalized distribution\n// - fastest static noise generator function (also runs at low precision)\n\nfloat PHI = 1.61803398874989484820459;  //  = Golden Ratio   \n\nfloat gold_noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\nfloat sdCircle( vec2 p , vec2 offSet, float r){\n\treturn length ( p - offSet) - r;\n}\n\n//give it a uv position\nfloat truchetTile(vec2 p, vec2 cell)\n{\n    float r = 1./100000.; ///why is this... the value I have to use?\n    \n    float pipe = 0.;\n    float pipe2 = 0.;\n    #if USE_TIME\n        if (gold_noise(cell+ floor(iTime*.7), .3) > .5){\n    #else\n    \tif (gold_noise(cell+ 1.,3.) > .5){\n    #endif\n        pipe =  min(sdCircle( p, vec2(0,0), 0.),  1.-sdCircle( p, vec2(0,0), 0.));\n\t\tpipe2 = min(sdCircle( p, vec2(1,1), 0.),1.-sdCircle( p, vec2(1,1), 0.));\n    }else{\n        pipe =  min(sdCircle( p, vec2(1,0), 0.),  1.-sdCircle( p, vec2(1,0), 0.));\n        pipe2 = min(sdCircle( p, vec2(0,1), 0.),1.-sdCircle( p, vec2(0,1), 0.));\n    }\n    \n    float sizeMod = .4 + .045*sin(.3*iTime);\n    float thickness = .05;\n    float blur = 10.0;\n\tfloat value = max(smoothstep(sizeMod,sizeMod+thickness, pow(pipe,1.)),smoothstep( sizeMod ,sizeMod+thickness, pipe2));\n    return pow(max(value,0.),blur);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 uvLoop = fract((uv) * NUM);\n    vec2 uvCells = floor(uv * NUM);\n    \n    vec3 color = vec3(.784, .635, .784);\n    vec3 bg = vec3(.294,0.,.51);\n    \n    float colOffset = COL_OFF;\n    float bgOffset = COL_OFF;\n    vec3 hsvC = rgb2hsv(color);\n    vec3 hsvBG = rgb2hsv(bg);\n    hsvC = fract( hsvC + colOffset);\n    hsvBG = fract( hsvBG + bgOffset);\n    color = hsv2rgb(hsvC);\n    bg = hsv2rgb(hsvBG);\n    float inPipe = truchetTile(uvLoop, uvCells);\n    color = color * inPipe + (1.-inPipe) * bg;\n    \n    fragColor.xyz = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSfWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[270, 387, 409, 409, 740], [742, 801, 823, 823, 992], [1223, 1248, 1292, 1292, 1352], [1354, 1354, 1401, 1401, 1437]]}
{"id": "wlSfz3", "name": "Black and white 2d sdf stuff", "author": "Tatti", "description": "Black and white 2d sdf stuff", "tags": ["2d"], "likes": 3, "viewed": 84, "published": "Public", "date": "1599472635", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Thank you FabriceNeyret2!\n//\nfloat smoothUnion(float d1, float d2, float k){\n    float h = clamp( .5 + .5*(d2-d1)/k, 0., 1. );\n    return mix( d2, d1, h ) - k*h*(1.-h); \n}\n#define smoothIntersection(d1,d2,k) smoothUnion(d1,d2,-k)\n\n#define sphereSdf(center,radius,pos) ( length(center - pos) - radius )\n#define halfSdf(pos) ( pos.y - R.y/2. )\n#define CS(a)          vec2( cos(a),sin(a) )\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 R = iResolution.xy,\n         P = R/2. -CS(iTime*2.) * R/3.;\n  \n    float sphere = sphereSdf( P, R.y/6., U),\n          f = smoothUnion(sphere, halfSdf(U), R.y/10.),\n         f2 = smoothIntersection(sphere, halfSdf(U), R.y/10.);\n    \n    O = vec4( mix( 1., clamp(f,0.,1.), clamp(f2,0.,1.) ) );\n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSfz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 35, 82, 82, 177], [394, 394, 431, 431, 734]]}
{"id": "WlSyz3", "name": "Motion Trail", "author": "ivomontigatti", "description": "Motion Blur", "tags": ["blur", "motionblur"], "likes": 2, "viewed": 121, "published": "Public", "date": "1600054027", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec4 white = vec4(1.0);\nconst vec4 ballColor = vec4(1.0, 81.0 / 255.0, 113.0 / 255.0, 1.0);\nconst vec2 center = vec2(0.5, 0.5);\nconst float radius = 0.05;\nconst float timeDelta = 0.05;\n\nfloat nsin(float t, float from, float to){\n    return ((sin(t) + 1.0) / 2.0) * (to - from) + from;\n}\n\n// compute height using heron's formula\nfloat height(vec2 v1, vec2 v2) {\n    vec2 v3 = v2 - v1;\n    float a = length(v1);\n    float b = length(v2);\n    float c = length(v3);\n    float s = (a + b + c) / 2.0;\n\tfloat area = sqrt(s*(s-a)*(s-b)*(s-c));\n    float h = (2.0 * area) / b;\n    return h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float currentTime = iTime;\n    float previousTime = currentTime - timeDelta;\n    vec2 currentPosition = vec2(\n        nsin(currentTime * 5.0, 0.2, 0.8),\n        nsin((currentTime + 0.5) * 5.0, 0.2, 0.8)) * iResolution.xy;\n    vec2 previousPosition = vec2(\n    \tnsin(previousTime * 5.0, 0.2, 0.8),\n        nsin((previousTime + 0.5) * 5.0, 0.2, 0.8)) * iResolution.xy;\n    \n    vec2 delta = fragCoord - currentPosition;\n    float deltaLength = length(delta);\n    vec2 speedVec = previousPosition - currentPosition;\n    float maxTrail = length(speedVec / iResolution.y);\n    vec2 trail = normalize(speedVec);\n    \n    float h = height(delta, speedVec);\n    float hn = h / (radius * iResolution.y);\n    \n    float dh = dot(delta, trail);\n    float dhn = dh / (maxTrail * iResolution.y);\n    \n    float ndl = deltaLength / (radius * iResolution.y);\n    float pdl = length(fragCoord - previousPosition) / (radius * iResolution.y);\n    float inOut = step(1.0, step(hn, 1.0) * step(dhn, 1.0) * step(0.0, dh) + step(ndl, 1.0) + step(pdl, 1.0));\n    // float grad = 1.0 - (deltaLength / (radius * 5.0 * iResolution.y));\n    // Output to screen\n    fragColor = mix(white, ballColor , inOut);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSyz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 192, 234, 234, 292], [294, 334, 366, 366, 589], [591, 591, 648, 698, 1885]]}
{"id": "WlXBWN", "name": "Circuits III", "author": "Kali", "description": "Yet another fractal circuit", "tags": ["fractal", "circuits"], "likes": 48, "viewed": 445, "published": "Public", "date": "1601495001", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a) {\n\tfloat s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 fractal(vec2 p) {\n    float o=100.,l=o;\n    p*=rot(-.3);\n    p.x*=1.+p.y*.7;\n    p*=.5+sin(iTime*.1)*.3;\n    p+=iTime*.02;\n    p=fract(p);\n    for (int i=0; i<10; i++) {\n        p*=rot(radians(90.));\n        p.y=abs(p.y-.25);\n        p=p/clamp(abs(p.x*p.y),0.,3.)-1.;\n        o=min(o,abs(p.y-1.)-.2)+fract(p.x+iTime*.3)*.5;\n        l=min(l,length(max(vec2(0.),abs(p)-.5)));\n        \n    }\n\to=exp(-5.*o);\n\tl=smoothstep(.1,.11,l);\n    return hsv2rgb(vec3(o*.5+.6,.8,o+.1))+l*vec3(.4,.3,.2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 col=vec3(0.);\n    float aa=4.;\n    vec2 eps=1./iResolution.xy/aa;\n    for (float i=-aa; i<aa; i++){\n        for (float j=-aa; j<aa; j++){\n            col+=fractal(uv+vec2(i,j)*eps);\n        }\n    }\n\tcol/=pow(aa*2.,2.);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXBWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 75], [78, 78, 100, 100, 269], [272, 272, 294, 294, 767], [770, 770, 827, 827, 1179]]}
{"id": "ws3cD7", "name": "Magical Portal", "author": "arifd", "description": "Can be used for creating a portal-like graphic", "tags": ["fire", "magic", "portal", "stargate", "gate", "magical", "ectricity"], "likes": 7, "viewed": 137, "published": "Public", "date": "1601031417", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// I've forgotten where this fire/noise algorithm comes from! (Sorry!)\n\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898,12.1414))) * 83758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n);\n    vec2 f = fract(n);\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fire(vec2 n) {\n    return noise(n) + noise(n * 2.1) * .6 + noise(n * 5.4) * .42;\n}\n\n////////////////////////////\n\nfloat square_tunnel(vec2 uv) {\n    vec2 p = -1.0 + 2.0 * uv;\n    vec2 t = p*p*p*p;\n    return max(t.x, t.y);\n}\n\n/////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = iTime;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // create a fire texture\n    float q = noise(uv + t);\n    float fire = fire(uv - (t * .934) - q);\n    \n    float square_tunnel = square_tunnel(uv);\n\n    // apply fire everywhere to only select pixels\n    float grad = fire * (1. - (square_tunnel * 2. -1.));\n\n    // can't really explain what this is doing\n    grad = max(0., (1. - grad)/grad);\n\n    // adjust fade\n     // grad /= (1. + grad);\n    \n    // add colour\n    vec3 portal = vec3((grad * grad * grad), (grad * grad), grad); \n\n    // add your portal onto whatever\n    vec3 bg = texture(iChannel0, uv + (q * .1 - .05)).rgb * square_tunnel * 2.;\n    \n    fragColor = vec4(bg + portal, 1.);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3cD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 72, 92, 92, 161], [163, 163, 184, 184, 365], [367, 367, 387, 387, 455], [457, 487, 517, 517, 597], [599, 630, 687, 687, 1400]]}
{"id": "Ws3cR7", "name": "Band Limited Tie Dye ", "author": "celifrog", "description": "Idk  thanks  IQ for this site and all of your posts. :) \nIdk 5% credit to me.   ", "tags": ["fork"], "likes": 2, "viewed": 173, "published": "Public API", "date": "1600614305", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A simple way to prevent aliasing of cosine functions (the color\n// palette in this case is made of 8 layers) by attenuating them\n// when their oscillations become smaller than a pixel. Left is\n// direct use of cos(x), right is band-limited cos(x).\n//\n// Box-filtering of cos(x):\n//\n// (1/w)cos(t)dt with t  (x-w, x+w)\n// = [sin(x+w) - sin(x-w)]/w\n// = cos(x)sin(w)/(w)\n//\n// Can approximate smoothstep(2,0,w)  sin(w/2)/(w/2),\n// which you can also see as attenuating cos(x) when it \n// oscilates more than once per pixel. More info:\n//\n// https://iquilezles.org/www/articles/bandlimiting/bandlimiting.htm\n//\n// Related Shader:\n//   https://www.shadertoy.com/view/WtScDt\n//   https://www.shadertoy.com/view/wtXfRH\n//   https://www.shadertoy.com/view/3tScWd\n\n\n// box-filted cos(x)\nvec3 fcos( in vec3 x )\n{\n    vec3 w = fwidth(x);\n\t#if 1\n    return cos(x) * sin(11.5*w)/(-1.5*w);       // exact\n\t#else\n    return cos(x) * smoothstep(5.2832,99.0,w); // approx\n\t#endif    \n}\n\n// pick raw cosine, or band-limited cosine\nbool  mode = true;\nvec3  mcos( vec3 x){return mode?cos(x):fcos(x);}\n\n// color palette, made of 8 cos functions\n// (see https://iquilezles.org/www/articles/palettes/palettes.htm)\nvec3 getColor( in float t )\n{\n    vec3 col = vec3(421.6,0.5,0.4);\n    col += 0.14*-mcos(6.2832*t*  1.0+vec3(0.0,0.5,0.6));\n    col += 0.13*-mcos(6.2832*t*  3.1+vec3(0.5,0.6,1.0));\n    col += 0.12*-mcos(6.2832*t*  5.1+vec3(0.1,0.7,1.1));\n    col += 0.11*-mcos(6.2832*t*  9.1+vec3(0.1,0.5,1.2));\n    col += 0.10*-mcos(6.2832*t* 17.1+vec3(0.0,0.3,0.9));\n    col += 0.09*-mcos(6.2832*t*t* 31.1+vec3(0.1,0.5,1.3));\n    col += 0.08*-mcos(6.2832*t* 65.1+vec3(0.1,0.5,1.3));\n    col += 0.01*-mcos(6.2832*t*t*131.1+vec3(0.3,0.2,0.8));\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordiantes\n\tvec2 q = (1.4*fragCoord-iResolution.xy)/iResolution.y;\n\n    // separation\n    float th = (iMouse.z>0.019) ? (5.0*iMouse.y-iResolution.y)/iResolution.y : 2.8*sin(iTime);\n    mode = (q.x+q.y<th);\n    \n    // deformation\n    vec2 p = 2.0*q*q/dot(q,q);\n\n    // animation\n    p.xy += 5.05/iTime;\n\n    // texture\n    vec3 col = min(getColor(p.x*p.y*p.x),getColor(p.y*p.x*p.x*p.x));\n\n    // vignetting\n    col *= 1.5 - 0.2*length(-q*q*q*q*q*q*q*q*q);\n    \n    // separation\n    col *= smoothstep(0.005,0.010,abs(q.x*q.y*th*th));\n    \n    // palette\n    if( q.y<-51.9 ) col = getColor( fragCoord.x*iResolution.x );\n\n    fragColor = vec4( col, 5.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3cR7.jpg", "access": "shaders20k", "license": "mit", "functions": [[1864, 1885, 1909, 1909, 2075], [2077, 2139, 2159, 2159, 2187], [2189, 2298, 2327, 2327, 2841], [2843, 2843, 2899, 2918, 3563]]}
{"id": "ws3cRr", "name": "Printer scanner", "author": "ShelveAndMind", "description": "Replicating a scanner effect", "tags": ["light", "scanner", "printer"], "likes": 5, "viewed": 77, "published": "Public", "date": "1600255330", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float remainder (float f, float div) {\n    while(f > div) {\n        f -= div;\n    }\n    return f;\n}\nfloat pointy (float f) {\n    return 0.02/(abs(f)+0.02);\n}\nfloat vMag (vec4 v) {\n    return v.x*v.x + v.y*v.y + v.z*v.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    \n    vec3 col = vec3(0.0);\n    \n    float f = abs(uv.x - remainder(iTime*0.5, 1.0));\n    col = vec3(pointy(f));\n    \n    fragColor = vec4(col, 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3cRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 99], [100, 100, 124, 124, 157], [158, 158, 179, 179, 221], [223, 223, 280, 330, 529]]}
{"id": "ws3cRX", "name": "SDF logo", "author": "Artleet", "description": "adopted for OpenGL ES 2, quite unreadable", "tags": ["sdf", "fonts"], "likes": 16, "viewed": 152, "published": "Public", "date": "1601380467", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//OpenGL ES 2 adopted\n\n//unpacking\n//if a is ivec4, b is ivec2(1234,5678) and c is 100\n//a will be ivec4(12,34,56,78) -> 1234//100,1234%100,5678//100,5678%100\n#define U(a,b,c) a.yw = b - (a.xz = b / c) * c;\n\n//primitive drawing\n//the coordinates of the primives has to be unpacked to the variable c\n//if first coordinate is not null - call sdf function F\n//and unite the result with the previous sdf stored in f\n#define P(F) f = c.x > 0 ? min(F(o,c), f) : f;\n\n//unpack and draw pair or primitives\n//unpack q to g\n//unpack g.xy to c\n//call drawing function F\n//unpack g.zw to c\n//call drawing function F\n#define D(g,q,F) U(g,q,100) U(c,g.xy,10) P(F) U(c,g.zw,10) P(F)\n\n//calculating position of the letter and unpack and draw up to 4 lines and up to 2 arcs for the letter\n//unpack l[j].xy (lines coordinates) to a\n//call D for further decoding and drawing\n#define C(j) o = vec2(p.x - float(i++) * .1, p.y) * 10.; U(a,l[j].xy,10000) D(b,a.xy,I) D(b,a.zw,I) D(a,l[j].zw,O)\n\n//31337 fx\n//drawing the Leet alternatives of the letters with some cycle F02 7H3 C001 H4CK32 FX\n#define X(a,b) if(sin(float(i)+iTime)>0.){C(a)}else{C(b)}     \n\n//line SDF ivec4(x1,y1,x2,y2)\nfloat I(vec2 p, ivec4 a){\n    vec4 c = vec4(a) / 6.;\n    return length((p -= c.xy) - (c.zw -= c.xy) * clamp(dot(p, c.zw) / dot(c.zw, c.zw), 0., 1.));\n}\n\n//arc SDF ivec4(x,y,radius,mask)\n//first bit of the mask is the masking axis, 2 next bits the direction \nfloat O(vec2 p, ivec4 a){\n    vec4 b = vec4(a) / 6.;\n    int m = a.w - a.w / 2 * 2; \n    return clamp(dot(sign(p -= b.xy), vec2(m, m < 1) * vec2(a.w / 2 - 1)), 0., 1.) + abs(length(p) - b.z);\n}\n\nfloat R(vec2 p){\n    //Letters design is stored in the following format - ivec4(line1-2,line3-4,arc1,arc2)\n    //each digit is a coordinate\n\t//Im deviding the digits by 6. to have coordinate in the 0.-1. range\n    ivec4 l[11];\n    l[0]=ivec4(11353551, 0, 0, 0);//a\n    l[1]=ivec4(11411343, 1545, 4211, 4411);//b\n    l[2]=ivec4(11151333, 51333355, 0, 0);//k\n    l[3]=ivec4(13155355, 0, 3324, 0);//u\n    l[4]=ivec4(11151531, 31555551, 0, 0);//m\n    l[5]=ivec4(15313155, 0, 0, 0);//v\n    l[6]=ivec4(0, 0, 3322, 0);//o\n    l[7]=ivec4(1155, 0, 3322, 0);//0\n    l[8]=ivec4(51555313, 1335, 0, 0);//4\n    l[9]=ivec4(3351, 0, 3322, 0);//q\n    l[10]=ivec4(11411343, 15555533, 4211, 0);//3\n\t\t\n    float f=1.;\n    ivec4 a,b,c;\n    vec2 o;\n    int i=0;\n  \n    //C(0)C(1)C(1)C(0)C(2)C(3)C(4)C(6)C(5)C(0)\n    X(0,8)X(1,10)X(1,10)X(0,8)X(2,9)X(3,3)X(4,4)X(6,7)X(5,5)X(0,8)\n   \n    return f;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    uv.y -= .5;\n    uv.x -= iResolution.x * .5/ iResolution.y - .5;\n    \n    float f = R(uv), g = .02 / f * (sin(iTime * 100.) * .1 + .9);\n    fragColor = vec4(g, g * .5, 0, 1) + .004 / f;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3cRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1132, 1162, 1187, 1187, 1313], [1315, 1420, 1445, 1445, 1613], [1615, 1615, 1631, 1824, 2491], [2494, 2494, 2551, 2551, 2783]]}
{"id": "Ws3czn", "name": "vector field morph", "author": "garabatospr", "description": "vector field morph ", "tags": ["vectorfield"], "likes": 3, "viewed": 122, "published": "Public", "date": "1600825896", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define field(U) 10.* vec2( f1(U),f2(U))\n#define PI 3.14159265359\n\n\nfloat scale = 1.2;\n\n\nfloat f1(vec2 U)\n{    \n    U = U.y * ( vec2(5,3));\n    return sin(U.x) + cos(U.y);\n}\n\nfloat f2(vec2 U)\n{\n    U = U.x * ( vec2(5,3));\n    return sin(U.y) - cos(U.x);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.85;\n    \n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec4 col,col1, col2;\n    \n    uv *= scale + 0.35*sin(iTime*0.05);\n    \n    \n    vec2 fld1 = field(uv);\n    \n    vec4 iColor = vec4(0.8,1.0,1.0,1.0);\n    \n    col1 = vec4(1.0);\n    \n    col1 += sin(iColor + fld1.x + fld1.y)*10.0;   \n\n    uv *= scale + 0.35*sin(iTime*0.05);\n    \n    vec2 fld2 = field(uv);\n    \n    col2 += sin(col1 + fld2.x - fld2.y)*10.0;\n    \n    col = mix(col1,col2,abs(sin(0.5*iTime)));\n   \n    \n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3czn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 107, 107, 173], [175, 175, 193, 193, 260], [263, 263, 320, 320, 857]]}
{"id": "Ws3czs", "name": "Electron Clouds", "author": "edorobek", "description": "For presi", "tags": ["cloud"], "likes": 0, "viewed": 40, "published": "Public", "date": "1601480758", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat D(vec3 p, vec3 r)\n{\n    float dist = (p.x-r.x)*(p.x-r.x) + (p.y-r.y)*(p.y-r.y) + (p.z-r.z)*(p.z-r.z);\n    return 1.*exp(-4.5*dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*fragCoord/iResolution.xy - vec2(1.,1.);\n\n   \tfloat intensity = D(vec3(uv,1.0), vec3(0.0,0.0,0.0));\n    \n    for (int i = 0; i < 2; i++) {\n        intensity += D(vec3(uv,1.0), vec3(float(i)-.5 + .4*float(i)*sin(iTime) -.1*float(i),0.,1.0));\n    }\n\n    // Output to screen\n    fragColor = vec4(mix(vec3(0.0,0.0,0.0), vec3(1.0,0.0,0.0), intensity),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3czs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 26, 26, 140], [142, 142, 199, 249, 619]]}
{"id": "Ws3yWn", "name": "GloopCircle", "author": "Del", "description": "A Gloop Circle? - from in game  [url]https://www.youtube.com/watch?v=u3JePjNBRjM&feature=emb_logo[/url]\n", "tags": ["noise", "deform", "cylinder", "gloop"], "likes": 12, "viewed": 327, "published": "Public API", "date": "1600706749", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// gloop test (Cylinder+Noise+Deform)\n// Added some colour+blend for fun\n\n#define AA 1\t// make this 2 if you are feeling cold...\n#define HEIGHT 8.\n\nvec3 _col = vec3(0.0);\t// pure filth\n// prim\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n// min/max polynomial\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sminCol( float a, float b, float k, vec3 col1, vec3 col2 )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    _col = mix(col1,col2,h);// -  k*h*(1.0-h);\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nvec3 hsv2rgb(vec3 c)\n{\n  // igo Qulez\n  // https://www.shadertoy.com/view/MsS3Wc\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n  rgb = rgb * rgb * (3. - 2. * rgb);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n// noise\nfloat noise(vec3 p,float scale, float s1,float s2)\n{\n    p*=scale;\n    float k = dot(sin(p - cos(p.yzx*1.57)), vec3(.333))*s1;\n    k += dot(sin(p*2. - cos(p.yzx*3.14)), vec3(.333))*s2;    \n    return k*0.4;\n}\n\nfloat map( in vec3 pos )\n{\n    float rad =  (1.0/(3.141*2.0)*20.0);\n    vec3 dp = vec3(pos.z, atan(pos.x, pos.y) * rad, rad-length(pos.xy));    \n    float d1 = sdCylinder(dp,vec2(0.8,HEIGHT))-0.5;\n    float t = iTime*1.35;\n    float n1 = noise(dp+vec3(0.0,t*1.0,0.0),1.0,3.57,.83);\n    float n2 = noise(dp+vec3(sin(t*.2)*2.0,t*1.5,0.0), 1.5, 4.47, 1.43);\n    float n3 = noise(dp+vec3(0.0,t*2.0,0.0), 2.0, 1.87,3.13);\n    n1 = smin(n1,n2,4.);\n    n1 = smin(n1,n3,4.);\n  \td1 = smax(n1,d1,4.);\n    \n    n3 = noise(pos+vec3(0.0,t*2.0,0.0),1.0,3.57,1.83)*2.0;\n    float disp = (sin(pos.z*1.3+t*1.1+pos.x*0.4)+cos(n3+t*1.3+pos.z*1.5+sin(t*2.2+pos.x*1.25)))*0.1;\n    \n    float d2 = dot(pos,vec3(0.0,1.0,0.0)) + 1.5+disp;   \n    //d1 = smin(d1,d2,1.2);\n    \n    vec3 goo = hsv2rgb(vec3(t*0.2+dp.y*0.075,0.85,0.9));\n    \n    d1 = sminCol(d1,d2,1.2,vec3(0.025,0.2,0.75),goo);\n    \n    return d1*0.75;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.008;\t//0.0005\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n    float an = 0.2-sin(iTime*.75)*2.0;\n\tvec3 ro = vec3( 7.0*cos(an), 2.0+sin(iTime*0.75)*2.2, 7.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 25.0;\n        float t = 0.0;\n        for( int i=0; i<160; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\t\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            \n            vec3 dir = normalize(vec3(1.0,0.7,0.0));\n\t        vec3 ref = reflect(rd, nor);\n\t        float spe = max(dot(ref, dir), 0.0);\n\t        vec3 spec = vec3(1.0) * pow(spe, 20.);\n            float dif = clamp( dot(nor,dir), 0.05, 1.0 );\n            col =  _col*dif;\n            col+=spec;\n        }\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3yWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 193, 229, 229, 328], [329, 351, 392, 392, 481], [483, 483, 549, 549, 685], [686, 686, 708, 772, 919], [921, 921, 960, 960, 989], [990, 999, 1051, 1051, 1207], [1209, 1209, 1235, 1235, 2102], [2104, 2104, 2136, 2136, 2383], [2389, 2389, 2446, 2471, 4164]]}
{"id": "ws3yzr", "name": "my first RayMarch", "author": "alenmemenduf", "description": "I followed this tutorial:\nhttps://www.youtube.com/watch?v=PGtv-dBi2wE", "tags": ["ray", "march"], "likes": 1, "viewed": 34, "published": "Public", "date": "1600264063", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n\n\nfloat getDist(vec3 point ){\n\tvec4 sphere = vec4(0, sin(iTime*2.)*.3+1.5, 6, 1.); // x,y,z and width\n    \n    float sphereDist = length(point-sphere.xyz) - sphere.w;\n    float planeDist = point.y;\n    \n    float dist = min(sphereDist,planeDist);\n    return dist;\n} // minimum distance from point to a surface\n\nvec3 getNormal(vec3 point){\n\tvec2 offset = vec2(0.01,0.);\n    float dist = getDist(point);\n    vec3 normal = vec3(\n        dist-getDist(point-offset.xyy),\n        dist-getDist(point-offset.yxy),\n        dist-getDist(point-offset.yyx));\n    \n    return normalize(normal);\n} // returns the normal vector, a vector that points out from a point\n\nfloat getLight(vec3 point, vec3 lightPos){\n    vec3 lightVector = normalize(lightPos - point);\n    vec3 normal = getNormal(point);\n    \n    float diffuse = dot(normal,lightVector); // between -1 and 1 depending on the angle between the 2 vectors\n    return diffuse;\n} // this value represents the strength of the light depending on angle\n\nfloat rayMarch(vec3 rayOrigin, vec3 rayDestination){\n\n    float distanceMarched = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++){\n\t\tvec3 point = rayOrigin + rayDestination * distanceMarched;\n        float distancePointToSurface = getDist(point); \n        distanceMarched += distancePointToSurface;\n        if(distanceMarched > MAX_DIST || distancePointToSurface < SURF_DIST) break;\n    }\n    \n    return distanceMarched;\n} // returns the total distance until we hit a surface\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    vec3 color = vec3(0);\n    \n    // rays shot from camera through the current pixel on the screen\n    vec3 rayOrigin = vec3(0, 1, 0);\n    vec3 rayDestination = normalize(vec3(uv.x,uv.y, 1));\n    \n    float dist = rayMarch(rayOrigin,rayDestination); // the distance until it hits\n    vec3 point = rayOrigin + rayDestination * dist; // the point where it hits\n    \n    vec3 lightPos = vec3(sin(iTime)*4.,1.,3.); // position of the light source\n    float diffuse = getLight(point, lightPos); // how the light is shown on the object, objects that have a smaller angle are more lit.\n    \n    color = vec3(diffuse); // applying the lighting\n    color *= vec3(1.,0.61,1.); // purple color\n    \n    fragColor = vec4(color,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3yzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 96, 96, 332], [333, 378, 405, 405, 650], [651, 720, 762, 762, 987], [988, 1059, 1111, 1111, 1478], [1479, 1536, 1593, 1593, 2383]]}
{"id": "WscyDn", "name": "11 - Line grid waves", "author": "Krabcode", "description": "Expanding on ideas from The Universe Within by Art of Code on Youtube", "tags": ["grid", "line", "sin", "rgb"], "likes": 17, "viewed": 262, "published": "Public", "date": "1600716782", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"10 - Line grid\" by Krabcode. https://shadertoy.com/view/3s3yR7\n// 2020-09-21 17:53:36\n\n// Based on ideas from LiveCoding - The Universe Within by Art of Code\n// https://youtu.be/3CycKKJiwis\n\n#define tau 6.28\n\nfloat scl = 15.;\n\nmat2 rotate(float rad){\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(c, -s, s, c);\n}\n\n// cubic pulse by iq\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\n// 2D sdf by iq\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n    q = mat2(d.x,-d.y,d.y,d.x)*q;\n    q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sdRoundedLine(in vec2 p, in vec2 a, in vec2 b, float weight, float roundedness){\n    return sdOrientedBox(p, a, b, weight)-roundedness;\n}\n\nfloat sdGridLine(vec2 cellPos, vec2 a, vec2 b){\n    float lineLength = distance(a,b);\n    float line = sdOrientedBox(cellPos, a, b, 0.);\n    float smallLength = 0.0;\n    float bigLength = 1.5;\n    float closeness = smoothstep(bigLength, smallLength, lineLength); \n    float thickness = 0.05;\n    return closeness*smoothstep(thickness, 0., line);\n}\n\n// Hash without Sine\n// David Hoskins.\n\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 getGridPoint(vec2 id){\n    float t = float(iFrame) * .001;\n    float d = smoothstep(scl*.33, 0., length(id));\n    float theta = tau*(t+731.154*hash12(id));\n    float x = d*0.4*cos(theta);\n    float y = d*0.4*sin(theta);\n    vec2 wave = (1.-d)*.03*id*sin(length(id)-t*scl*.66);\n\treturn vec2(x,y)+wave;\n}\n\nfloat allLinesOnThisCell(vec2 cellPos, vec2[9] points){\n \tfloat sum = 0.;\n    sum += sdGridLine(cellPos, points[4], points[0]);\n    sum += sdGridLine(cellPos, points[4], points[1]);\n    sum += sdGridLine(cellPos, points[4], points[2]);\n    sum += sdGridLine(cellPos, points[4], points[3]);\n    sum += sdGridLine(cellPos, points[4], points[5]);\n    sum += sdGridLine(cellPos, points[4], points[6]);\n    sum += sdGridLine(cellPos, points[4], points[7]);\n    sum += sdGridLine(cellPos, points[4], points[8]);\n    sum += sdGridLine(cellPos, points[1], points[3]);\n    sum += sdGridLine(cellPos, points[1], points[5]);\n    sum += sdGridLine(cellPos, points[3], points[7]);\n    sum += sdGridLine(cellPos, points[5], points[7]);   \n    return sum;\n}\n\nvec2[9] createPointMatrix(vec2 cellId){\n \tvec2[9] pointMatrix;\n    float range = 1.;\n    int i = 0;\n    for(float x = -range; x <= range; x++){\n        for(float y = -range; y <= range; y++){\n            vec2 offset = vec2(x,y);\n            pointMatrix[i] = getGridPoint(cellId + offset) + offset;\n            i++;\n        }\n    }   \n    return pointMatrix;\n}\n\nfloat render(vec2 uv){\n    float pct = 0.12;\n    vec2 cellPos = fract(uv * scl) - .5;    \n    vec2 cellId = floor(uv * scl) + .5;\n    vec2[9] pointMatrix = createPointMatrix(cellId);\n    return allLinesOnThisCell(cellPos, pointMatrix);\n}\n\nvec3 gammaCorrection(vec3 rgb){\n    float gamma = 2.2;\n    return pow(max(rgb, 0.), vec3(1.0/gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 colorOffset = normalize(uv)*.003*smoothstep(0.2, 0.5, length(uv));\n    vec3 col = vec3(\n        render(uv-colorOffset),\n        render(uv),\n        render(uv+colorOffset));\n    fragColor = vec4(gammaCorrection(col), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscyDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 239, 262, 262, 342], [344, 365, 412, 412, 506], [508, 524, 590, 590, 795], [797, 797, 883, 883, 940], [942, 942, 989, 989, 1289], [1291, 1331, 1353, 1353, 1473], [1475, 1475, 1502, 1502, 1782], [1784, 1784, 1839, 1839, 2526], [2889, 2889, 2911, 2911, 3126], [3128, 3128, 3159, 3159, 3231], [3233, 3233, 3290, 3290, 3581]]}
{"id": "wscyRS", "name": "Cogs Spinning", "author": "mightee_cactus", "description": "Having fun with the cog pattern I found here https://thebookofshaders.com/07/\nShader is a mess, and tuned only for certain cog radius.\n\nI'd love if you make a general randomized version of it :)", "tags": ["cog"], "likes": 4, "viewed": 55, "published": "Public", "date": "1601138550", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Colors\n#define BG_COLOR    vec3(0.165, 0.125, 0.224)\n//#define COG_COLOR   vec3(0.906, 0.275, 0.6)\n#define COG_COLOR   vec3(0.564, 0.066, 0.690)\n\n// Here are parameters you can safely tune\n// without ruining pattern too much.\n#define SPEED_AUTO  iTime * 0.5\n#define SPEED_MOUSE iMouse.x * 0.005\n#define FIRST_COG   vec2(-0.8,0.35)\n#define COG_STEP    vec2(0.185, 0.122)\n\n\n// Generate cos wave, cut bottom of it, \n// wrap it into a circle by polar coordinates conversion.\n// Originally took it from here  https://thebookofshaders.com/07/\nfloat cog(vec2 origin, vec2 uv, float radius, float timeShift)\n{\n    vec2 pos = origin - uv;\n    float r = length(pos) / radius;\n    float a = atan(pos.y, pos.x) + timeShift;\n    // this is where those tooth are formed\n    float f = smoothstep(-0.3, 0.3, cos(a*8.))*0.08+0.5;\n    \n    return smoothstep(f+0.02, f, r);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n    float bigRadius = 0.2;\n    vec2  s         = COG_STEP;\n    float cogMask   = 0.;\n    \n    float bigTime   = 0.;\n    if (iMouse.z > 0.)\n    {\n        bigTime = SPEED_MOUSE;\n    }\n    else\n    {\n    \tbigTime = SPEED_AUTO;    \n    }\n    \n    // This thing is very straight forward:\n    // Draw cog -> shift pos to next cog -> repeat.\n    // Changing sign of s.x and s.y shift moves it \n    // around previous cog.\n    vec2 cur = FIRST_COG;\n    cogMask += cog(cur, uv, bigRadius,  bigTime);\n    cur     += vec2(s.x, -s.y);\n    cogMask += cog(cur, uv, bigRadius, -bigTime);\n    cur     += vec2(s.x, -s.y);\n    cogMask += cog(cur, uv, bigRadius,  bigTime);\n    cur     += vec2(-s.x, -s.y);\n    cogMask += cog(cur, uv, bigRadius, -bigTime);\n    cur     += vec2(-s.x, -s.y);\n    cogMask += cog(cur, uv, bigRadius,  bigTime);\n    cur     += vec2(s.x, s.y);\n    //cogMask += cog(cur, uv, bigRadius, -bigTime); // skip cog\n    cur     += vec2(s.x, -s.y);\n    cogMask += cog(cur, uv, bigRadius,  bigTime);\n    cur     += vec2(s.x, -s.y);\n    cogMask += cog(cur, uv, bigRadius, -bigTime)*2.; // highlight\n    cur     += vec2(s.x, s.y);\n    //cogMask += cog(cur, uv, bigRadius,  bigTime); // skip cog\n    cur     += vec2(-s.x, s.y);\n    //cogMask += cog(cur, uv, bigRadius, -bigTime); // skip cog\n    cur     += vec2(s.x, s.y);\n    cogMask += cog(cur, uv, bigRadius,  bigTime);\n    cur     += vec2(-s.x, s.y);\n    //cogMask += cog(cur, uv, bigRadius, -bigTime); // skip cog\n    cur     += vec2(-s.x, s.y);\n    cogMask += cog(cur, uv, bigRadius,  bigTime);\n    cur     += vec2(s.x, -s.y);\n    cogMask += cog(cur, uv, bigRadius, -bigTime)*2.; // highlight\n    cur     += vec2(s.x, s.y);\n    cogMask += cog(cur, uv, bigRadius,  bigTime);\n    cur     += vec2(s.x, -s.y);\n    cogMask += cog(cur, uv, bigRadius, -bigTime);\n    cur     += vec2(s.x, -s.y);\n    cogMask += cog(cur, uv, bigRadius,  bigTime)*2.; // highlight\n    cur     += vec2(s.x, -s.y);\n    cogMask += cog(cur, uv, bigRadius, -bigTime);\n    cur     += vec2(s.x, s.y);\n    cogMask += cog(cur, uv, bigRadius,  bigTime);\n    cur     += vec2(s.x, -s.y);\n    cogMask += cog(cur, uv, bigRadius, -bigTime);\n    cur     += vec2(-s.x, -s.y);\n    cogMask += cog(cur, uv, bigRadius,  bigTime);\n    cur     += vec2(-s.x, -s.y);\n    cogMask += cog(cur, uv, bigRadius, -bigTime);\n    cur     += vec2(-s.x, s.y);\n    cogMask += cog(cur, uv, bigRadius,  bigTime);\n    cur     += vec2(-s.x, -s.y);\n    cogMask += cog(cur, uv, bigRadius, -bigTime);\n    cur     += vec2(-s.x, s.y);\n    cogMask += cog(cur, uv, bigRadius,  bigTime);\n    \n\tfragColor = vec4(mix(BG_COLOR, COG_COLOR, cogMask), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscyRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[375, 540, 604, 604, 859], [862, 862, 919, 919, 3617]]}
{"id": "Wscyz2", "name": "SquelcherSST", "author": "Del", "description": "Squelchy 'Glooper Tubes' (for a new SDF game) - Enjoy. - from in game  [url]https://www.youtube.com/watch?v=u3JePjNBRjM&feature=emb_logo[/url]", "tags": ["noise", "cylinder", "gloop", "squelch"], "likes": 9, "viewed": 321, "published": "Public API", "date": "1601256639", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// SST Squelcher\n\n#define AA 1\t// make this 2 if you are feeling cold...\n#define HEIGHT 10.\n\nvec3 _col;\n\n// prim\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n// min/max polynomial\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\nfloat sminCol( float a, float b, float k, vec3 col1, vec3 col2 )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    _col = mix(col1,col2,h);// -  k*h*(1.0-h);\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro)\n{\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat WaveletNoise(vec3 p, float z, float k) {\n    // https://www.shadertoy.com/view/wsBfzK\n    float d=0.,s=1.,m=0., a;\n    for(float i=0.; i<3.; i++) {\n        vec3 q = p*s, g=fract(floor(q)*vec3(123.34,233.53,314.15));\n    \tg += dot(g, g+23.234);\n\t\ta = fract(g.x*g.y)*1e3 +z*(mod(g.x+g.y, 2.)-1.); // add vorticity\n        q = (fract(q)-.5);\n        q = erot(q, normalize(tan(g+.1)), a);\n        d += sin(q.x*10.+z)*smoothstep(.25, .0, dot(q,q))/s;\n        p = erot(p,normalize(vec3(-1,1,0)),atan(sqrt(2.)))+i; //rotate along the magic angle\n        m += 1./s;\n        s *= k; \n    }\n    return d/m;\n}\n  \nfloat map( in vec3 pos )\n{\n    // testing 'wavelet' noise...\n    float nx = WaveletNoise(pos*0.1+vec3(0.0,iTime,0.0), iTime*3., 1.15)*1.9;\n    float nz = WaveletNoise(pos*0.1+vec3(0.0,iTime,0.0) + 10.0, iTime*3., 1.15)*1.9;\n    vec3 p2 = pos;\n    p2.x += nx;\n    p2.z += nz;\n    float d1 = sdCylinder(p2,vec2(4.0,HEIGHT))-1.0;\n    d1 = smax(d1-sin(iTime*7.0+pos.y*0.4)*1.1,d1,-3.0);\n    \n        // sphere cut\n        float rad = fract(iTime*0.1)*70.0;\n        float rad2 = clamp(rad,0.0,18.0);\n        float sphere1 = length(pos-vec3(0.0,HEIGHT+4.0-rad,0.0))-rad2;\n        float sphere2 = length(pos-vec3(0.0,((HEIGHT*2.0)+HEIGHT+4.0-rad),0.0))-rad2;\t//rad;\n        sphere1 = min(sphere1,sphere2);\n        d1 = smax(d1,sphere1,4.0);\n    _col = vec3(0.15,0.45,0.05);\n    pos.y = abs(pos.y);\n    vec3 p = pos;\n    \n    d1*=0.85;\n    \n    float d2 = sdCylinder(p-vec3(0.0,HEIGHT+2.0,0.0),vec2(10.5,0.5))-1.4;\n    d1 = sminCol(d2,d1,2.0,_col,vec3(0.05,0.15,0.4));\n    return d1;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.05;\t//0.0005\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n    float an = sin(iTime*0.8);\n    \n    //float dist = 36.0+sin(iTime)*7.0;\n    float dist = 28.0;\n    \n\tvec3 ro = vec3( dist*cos(an), sin(iTime*0.75)*14.0, dist*sin(an) );\n\t//vec3 ro = vec3( 16.0*cos(an), 0.0, 16.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 65.0;\n        float t = 0.0;\n        for( int i=0; i<160; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\t\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            \n            vec3 dir = normalize(vec3(1.0,0.7,0.0));\n\t        vec3 ref = reflect(rd, nor);\n\t        float spe = max(dot(ref, dir), 0.0);\n\t        vec3 spec = vec3(1.0) * pow(spe, 100.);\n            float dif = clamp( dot(nor,dir), 0.05, 1.0 );\n            col =  _col*dif;\n            col+=spec;\n        }\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wscyz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 113, 149, 149, 248], [249, 271, 312, 312, 401], [402, 402, 441, 441, 470], [471, 471, 537, 537, 673], [675, 675, 713, 713, 775], [777, 777, 823, 868, 1381], [1385, 1385, 1411, 1445, 2362], [2364, 2364, 2396, 2396, 2642], [2644, 2644, 2701, 2726, 4538]]}
{"id": "WsdcDM", "name": "2d sun and hills", "author": "jorge2017a1", "description": "2d sun and hills", "tags": ["2dsunandhills"], "likes": 1, "viewed": 64, "published": "Public", "date": "1601043895", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n///autor desconocido\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 p = ( fragCoord.xy / min(iResolution.x,iResolution.y) );\n\tvec3 color = vec3(0.0);\n\t\n    \n    \n\t//Hills\n\t\n    float t=iTime;\n\tfloat h = sin(p.x*11.1-0.85+t*0.5)*0.25,\n\t      h2 = sin(p.x*12.0+1.5+t)*0.20,\n\t      h3 = sin(p.x*1.75+0.75+t)*0.20;\n\t\n\tfloat d = distance(p,vec2(p.x,h));\n\t\n\tcolor = vec3(0.0,1.0,0.0)* vec3(1.0-pow(d,0.25));\n\t\n\td = distance(p,vec2(p.x,h2));\n\t\n\tif(p.y < h2 && p.y > h)\n\t\tcolor = vec3(0.0,1.0,0.0)* vec3(1.0-pow(d,0.25));\n\t\n\td = distance(p,vec2(p.x,h3));\n\t\n\tif(p.y < h3 && p.y > h && p.y > h2)\n\t\tcolor = vec3(0.0,1.0,0.)* vec3(1.0-pow(d,0.25));\n\t\n\tif(p.y > h && p.y > h2 && p.y > h3)\n\t{\n\t color = mix(vec3(0.95,0.75,1.0),vec3(0.6,0.8352,1.0),p.y);//Sky\t\n\t}\n\t\n\tvec2 sun = vec2(1.5,0.75);\n\t\n\td = distance(p,sun);\n\t\n\tif(sin(atan((p.y-sun.y)/(p.x-sun.x))*16.0+iTime*2.0) > 0.0)\n\t\tcolor = mix(color, vec3(1.0,1.0,0.50),clamp((1.0-d*5.0),0.0,1.0));//Sunbeams\n\t\n\tif(d < 0.125)\n\t\tcolor = vec3(1.0,1.0,0.0);\n\t\n\t\t\n\t\n\tfragColor = vec4( color , 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdcDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 23, 80, 80, 1054]]}
{"id": "wsdcDn", "name": "maze hologram on square ?", "author": "danhel95", "description": "working now :)  thanx Spalmer", "tags": ["test", "tutorial", "texture", "uv", "mapping", "maze"], "likes": 4, "viewed": 70, "published": "Public", "date": "1600773218", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Learning tutorial 9 \n\n// testing mazes !\n\n\n\n#define rand21(p)       fract( sin( dot( p, vec2(27.609, 57.583) ) ) * 43758.5453 )\n#define rnd( x)    fract(1000.*sin(345.2345*x))\n#define id(u)   floor(u.x) + 25. *floor(u.y)\n#define box(p,c,b,f)  ( length( max( abs(p-(c)) - b + f , 0. ) ) - (f) )\n#define rCol(p)       ( (0.25 + 0.5 * cos((1. -p.x*p.y) * 6.2831 + vec3(0.1, 2.0, 3.0) )*clamp(1.0 - 0.2 * length(p), 0.0, 1.0) ) )\n\n#define scale 15.\n\nmat2 R2(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat maze(vec2 u) {\n    float n = id(u);  u = fract(u);\n    return smoothstep( .0, .45 , (rnd(n) > .5) ? u.x:u.y  );\n    //return smoothstep( .1, .0 , (rnd(n) > .5) ? u.x:u.y  );\n\n}\n\n\nvoid mainImage( out vec4 F, in vec2 U )\n{\n\n    \n    vec2 R = iResolution.xy;\n    U = (U-.5*R)/R.x;\n    U +=  .2*U * R2(.3*iTime) ; \n    U *= 2.;\n    vec2 b  = vec2(.5) ;\n    float f = .05;\n\tvec2 o = vec2(.0) ;\n    \n    // test mapping the maze to the box uv \n    // working thanx Spalmer !\n    \n    vec2 buv =  (U - o) /( b + .5*f) ;\n    buv = .5*buv - .5;\n    //buv *= R2(-.1*iTime) ;\n\n    float d = box(U,o,b,f);\n    float m   =  abs(maze( buv*scale ) - .2 ) + .2;\n    d = smoothstep( .01 , .0 ,  d ) ;\n    \n    m -=  d* ( .5*sin(iTime*.5) + 1.25 )  ; // texture is under :) comment this to see it   \n    \n    m *=  d  ; \n    vec3 col = vec3((m)) ;\n\tcol *= texture(iChannel0,buv).rgb;\n    \n    float lum = .35 ;\n    \n    col = mix(col, rCol(vec2(m ,d*.5)) , lum);\n    col = mix(col, rCol(vec2(1.*m,.25)) + d-.5*m , lum );\n\t\n    \n    F = vec4(col,1.0);\n    F.rgb = pow( col, vec3(1./2.2) );\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdcDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 449, 467, 467, 529], [532, 532, 552, 552, 714], [717, 717, 758, 758, 1610]]}
{"id": "WsdcRj", "name": "Weird DE", "author": "Nischi", "description": "ODE", "tags": ["ode"], "likes": 2, "viewed": 42, "published": "Public", "date": "1601294779", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Si(float x){\t\t//Integral\n    float result = 0.;\n    float stp = x/1000.;\n    float t = 0.;\n    for(int i=1;i<1000;i++){\n        t += stp;\n        result += sin(t)/t;\n    }\n    return result*stp;\n}\n\nfloat SiTaylor(float x){\t\t//Taylor Series\n    float sqr = x*x;\n    float iMax = 201.;\n    float result = 1./(iMax+2.);\n    float sgn = 1.;\n    \n    for(float i=iMax; i>2.; i-=2.){\n        result = sgn/i+sqr/(i+1.)/(i+2.)*result;\n        sgn = -sgn;\n    }\n    return x*(1.+sqr/2./3.*result);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Constants to vary\n    float C = 3.*sin(iTime);\n    float scale = 4.;\n\n    //Coordinate transformation from pixels\n    vec2 uv = scale*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    //Implicit function\n    float u = uv.x/uv.y;\n    float f = Si(2.*u)-sin(u)*sin(u)/u+log(abs(uv.x))-C;\n    \n    //Function plot\n    fragColor = vec4(abs(f)/fwidth(f));\n    \n    //Coordinate system\n    if ( min( abs(uv.x), abs(uv.y) ) < 8./iResolution.y ) fragColor *= 0.;\n    fragColor *= smoothstep( 0., 1.5, length(uv-vec2(1,0))*iResolution.y/8.- 4.);\n    fragColor *= smoothstep( 0., 1.5, length(uv-vec2(0,1))*iResolution.y/8.- 4.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdcRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 30, 202], [204, 204, 228, 245, 496], [498, 498, 555, 579, 1186]]}
{"id": "wsdcRS", "name": "RS-DREAMER", "author": "yasuo", "description": "j.Cole", "tags": ["reproduction", "puma", "jcole"], "likes": 5, "viewed": 194, "published": "Public API", "date": "1601209742", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define skew(x, y) mat2(1,tan(x),tan(y),1)\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\nmat2 bend(float p, float k) {\n    float c = cos(k*p);\n    float s = sin(k*p);\n    mat2  m = mat2(c,-s,s,c);\n    return m;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec3 formstripe(vec2 p, vec3 col) {\n    p*=0.6;\n    p.x*=0.78;\n    p*=Rot(radians(-10.0));\n    \n    vec2 pref = p;\n    p.x*=0.5;\n    p.y*=0.8;\n    float d = length(p-vec2(0.0,0.0))-0.14;\n    float d2 = length(p-vec2(0.22,-0.1))-0.22;\n    \n    d = max(-p.y-0.02,max(-d2,d ));\n    p = pref;\n    \n    mat2  m = bend(p.y,-0.4);\n    p = m*p;\n    \n    float sc = mix(0.07,1.6,smoothstep(-1.0,1.0,p.x));\n    p.y*=sc;\n    float d3 = sdBox((p-vec2(0.25,0.185))*Rot(radians(-17.8)), vec2(0.335,0.041));\n    d = min(d,d3);\n    \n    col = mix(col,vec3(1.0),S(d,0.0));\n    return col;\n}\n\nvec3 cloud(vec2 p, vec3 col) {\n    float d = (length(p)-0.1);\n    float d2 = (length(p-vec2(-0.1,-0.08))-0.12);\n    float d3 = (length(p-vec2(0.1,-0.03))-0.1);\n    float d4 = (length(p-vec2(0.17,-0.09))-0.09);\n    float d5 = (length(p-vec2(0.03,-0.12))-0.1);\n    d = min(d,d2);\n    d = min(d,d3);\n    d = min(d,d4);\n    d = min(d,d5);\n    \n    float prevD = d;\n    d = abs(d)-0.03;\n    \n    col = mix(col,vec3(0.0),S(d,0.0));\n    col = mix(col,vec3(1.0),S(prevD,0.0));\n    \n    return col;\n}\n\nvec3 clouds(vec2 p, vec3 col, float scale) {\n    p*=scale;\n    p.x = mod(p.x,0.58)-0.29;\n    col = cloud(p,col);\n    \n    return col;\n}\n\nfloat distCharD(vec2 p) {\n    p.x*=1.1;\n    p.y*=0.8;\n    p.y = abs(p.y);\n    p.y -= 0.015;\n    float d = sdBox(p,vec2(0.03,0.03));\n    p.y-=0.01;\n    p*=Rot(radians(60.0));\n    d = max(d,-p.x-0.02);\n    return d;\n}\n\nfloat distCharR(vec2 p) {\n    float d = abs(sdBox(p,vec2(0.04,0.05)))-0.01;\n    float d2 = sdBox(p-vec2(-0.04,-0.05),vec2(0.01,0.08));\n    d = min(d,d2);\n    d2 = sdBox((p-vec2(0.025,-0.085))*Rot(radians(-20.0)),vec2(0.01,0.045));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat distCharE(vec2 p) {\n    float d = sdBox(p,vec2(0.05,0.06));\n    float d2 = sdBox(p-vec2(0.02,0.0),vec2(0.05,0.04));\n    d = max(d,-d2);\n\td2 = sdBox(p-vec2(0.01,0.0),vec2(0.04,0.01));\n    d = min(d,d2);\n    return d;\n}\n\nfloat distCharA(vec2 p) {\n    float d = sdBox(p,vec2(0.05,0.05));\n    float d2 = sdBox(p-vec2(0.00,0.01),vec2(0.03,0.015));\n    d = max(d,-d2);\n\td2 = sdBox(p-vec2(0.0,-0.0475),vec2(0.03,0.025));\n    d = max(d,-d2);\n    return d;\n}\n\nfloat distCharM(vec2 p) {\n    float d = sdBox(p,vec2(0.07,0.06));\n    float d2 = sdBox(p-vec2(0.0,-0.03),vec2(0.05,0.06));\n    d = max(d,-d2);\n\td2 = sdBox(p-vec2(0.0,-0.01),vec2(0.01,0.05));\n    d = min(d,d2);\n    return d;\n}\n\nvec3 dreamer(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    p*=0.65;\n    col = cloud(p,col);\n    \n    p = prevP;\n    p*=0.7;\n    // D\n    vec2 dpos = (p-vec2(-0.18,-0.09))*Rot(radians(-8.0));\n    float d = abs(distCharD(dpos))-0.012;\n\tcol = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    \n    // R\n    p.y*=0.8;\n    vec2 rpos = (p-vec2(-0.13,-0.05))*Rot(radians(-8.0));\n    d = distCharR(rpos)-0.008;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    \n    // E\n    vec2 epos = (p-vec2(0.0,-0.01))*Rot(radians(-8.0));\n    d = distCharE(epos)-0.008;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    \n    // A\n    vec2 apos = (p-vec2(0.02,-0.16))*Rot(radians(-8.0));\n    d = distCharA(apos)-0.007;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    \n    // M\n    vec2 mpos = (p-vec2(0.16,-0.02))*Rot(radians(4.0));\n    mpos.x*=1.1;\n    mpos.y*=0.9;\n    d = distCharM(mpos*skew(0.2,0.1))-0.007;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    \n    // E\n    epos = (p-vec2(0.18,-0.17))*Rot(radians(10.0));\n    epos.x*=0.8;\n    epos.y*=1.5;\n    d = distCharE(epos*skew(0.2,0.1))-0.008;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    \n    // R\n    rpos = (p-vec2(0.305,-0.09))*Rot(radians(-.0));\n    rpos.x*=1.5;\n    rpos.y*=1.2;\n    d = distCharR(rpos*skew(0.2,0.2))-0.015;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 dreamerUV = uv;\n    vec2 m = iMouse.xy/iResolution.xy-.5;\n    vec3 col = vec3(0.6,0.9,1.0);\n    \n    col = formstripe(uv-vec2(-0.28,0.05),col);\n    \n    uv = prevUV;\n    for(float i = 0.; i<1.0; i+=1.0/5.0) {\n        uv.y+=(i*0.5)-0.1;\n        uv.y+=sin(iTime*i)*0.05;\n        uv.x += (i-iTime*0.1)+m.y;\n        float z = mix(-0.6,-0.1,i);\n        col = clouds(uv,col,0.4+((1.0-i)*1.5+z));\n        if(i == 0.6){\n            col = dreamer(dreamerUV-vec2(0.0,sin(iTime*2.0)*0.03),col);\n        }\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdcRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[202, 202, 231, 231, 325], [327, 327, 364, 364, 444], [446, 446, 481, 481, 1019], [1021, 1021, 1051, 1051, 1512], [1514, 1514, 1558, 1558, 1649], [1651, 1651, 1676, 1676, 1866], [1868, 1868, 1893, 1893, 2138], [2140, 2140, 2165, 2165, 2363], [2365, 2365, 2390, 2390, 2595], [2597, 2597, 2622, 2622, 2822], [2824, 2824, 2856, 2856, 4226], [4228, 4228, 4285, 4285, 4913]]}
{"id": "wsdyDn", "name": "Dithery Cloud", "author": "powerful", "description": "fuzzy cloud for foregrounds", "tags": ["noise", "cloud"], "likes": 1, "viewed": 62, "published": "Public", "date": "1600771414", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\n#define TWO_PI (2.0*PI)\n\nfloat random(vec2 st) {\n    return fract(\n        43758.5453123 * \n        sin(dot(st.xy, vec2(12.9898, 78.233))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float y = 0.0;\n    \n    { // Cloud shape\n    \tfloat a = TWO_PI*uv.x + iTime; // frequency\n    \tfloat b = 2.5; // phase\n    \tfloat c = 20.0; // amplitude\n    \n        // Shape function using sum of sines\n   \t \ty = sin(a) + sin(a/2.0) + sin(a/3.0) + b;\n    \ty /= c;\n    }\n    \n    vec3 col = vec3(0.0);\n    \n    { // Border fuzz\n    \tfloat z = uv.y - y;\n    \tfloat a = 0.05;\n        float b = 0.1;\n        float e = 0.15; // epsilon factor to blur seams\n        float r = random(uv);\n    \n    \tcol = z < a ? vec3(1.0) : vec3(0.0);\n    \tif (abs(z) < a) {\n            float f = (b-a) / (z-a);\n            f = f*f*f + e;\n            \n    \t\tcol += f * r;\n    \t}\n    }\n        \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdyDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 66, 66, 160], [162, 162, 217, 217, 971]]}
{"id": "wsdyRf", "name": "Dungeon Crawl Hatching 2", "author": "ozeg", "description": "inspired by old DnD Maps\nvoronoi approach", "tags": ["hatching"], "likes": 13, "viewed": 108, "published": "Public", "date": "1601454163", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PHI 1.618033988749895\n#define PHI_I 0.618033988749895\n#define PI 3.141592653589793\n#define TWO_PI 6.283185307179586\n#define CELL 12.\n\n\nvec2 noise(vec2 x)\n{\n    return fract(cos(dot(x,vec2(134.,1.61034)))*vec2(416418.0,1265.7486));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/CELL;\n    vec2 uv00 = vec2(0,0)+floor(uv);\n    vec2 uv01 = vec2(0,1)+floor(uv);\n    vec2 uv10 = vec2(1,0)+floor(uv);\n    vec2 uv11 = vec2(1,1)+floor(uv);\n\n    vec3 col = vec3(0);\n    vec2 n00 = noise(uv00);\n    vec2 n01 = noise(uv01);\n    vec2 n10 = noise(uv10);\n    vec2 n11 = noise(uv11);\n    uv00 = ceil(uv00) + n00-.5;\n    uv01 = ceil(uv01) + n01-.5;\n    uv10 = ceil(uv10) + n10-.5;\n    uv11 = ceil(uv11) + n11-.5;\n\n    vec2 uv0 = mix(uv00,uv01, float(distance(uv00,uv)>distance(uv01,uv)));\n    vec2 uv1 = mix(uv10,uv11, float(distance(uv10,uv)>distance(uv11,uv)));\n    vec2 uvC = mix(uv0,uv1,   float(distance(uv0,uv) >distance(uv1,uv)));\n    vec2 uvL = uv-uvC;\n    vec2 vn = noise(uvC)-.5;\n    float g = dot(uvL,normalize(vn));\n    // float s = dot(fragCoord.xy/CELL,vn);\n    float size = 1.+.5*sin(iTime);\n    float so = .4+1./(16.+size);\n    col = vec3(smoothstep(-so+.25,so+.25,sin((6.+size*12.)*g)));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdyRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 163, 163, 240], [242, 242, 299, 299, 1270]]}
{"id": "WsdyRM", "name": "gloopytest", "author": "Del", "description": "just some random gloop", "tags": ["gloop"], "likes": 4, "viewed": 251, "published": "Public API", "date": "1600650832", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// gloop test (Cylinder+Noise)\n\n#define AA 1\t// make this 2 if you are feeling cold...\n#define HEIGHT 4.\n\n// prim\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n// min/max polynomial\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n// noise\nfloat noise(vec3 p,float scale, float s1,float s2)\n{\n    p*=scale;\n    float k = dot(sin(p - cos(p.yzx*1.57)), vec3(.333))*s1;\n    k += dot(sin(p*2. - cos(p.yzx*3.14)), vec3(.333))*s2;    \n    return k*0.4;\n}\n\nfloat map( in vec3 pos )\n{\n    float d1 = sdCylinder(pos,vec2(0.8,HEIGHT))-0.5;\n    vec4 tt = vec4(1.0,1.5,2.0,0.2)*(iTime*1.1);\n    float n1 = noise(pos+vec3(0.0,tt.x,0.0),1.0,3.57,.83);\n    float n2 = noise(pos+vec3(sin(tt.w)*2.0,tt.y,0.0), 1.5, 4.47, 1.43);\n    float n3 = noise(pos+vec3(0.0,tt.z,0.0), 2.0, 1.87,3.13);\n    n1 = smin(n1,n2,4.);\n    n1 = smin(n1,n3,4.);\n  \td1 = smax(n1,d1,4.);\n    pos.y = abs(pos.y);\n    float d2 = sdCylinder(pos-vec3(0.0,HEIGHT,0.0),vec2(2.5,0.25))-0.15;\n    d1 = smin(d1,d2,1.2);\n    return d1*0.8;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.008;\t//0.0005\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n    float an = sin(iTime*1.05)*0.65;\n\tvec3 ro = vec3( 7.0*cos(an), sin(iTime*0.75)*5.0, 7.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 25.0;\n        float t = 0.0;\n        for( int i=0; i<80; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\t\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.02,0.1,0.02)*amb + vec3(0.15,0.45,0.05)*dif;\n            col+= pow(dif, 100.);//Observer - fake spec :)\n        }\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdyRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 114, 150, 150, 249], [250, 272, 313, 313, 402], [403, 403, 442, 442, 471], [472, 481, 533, 533, 689], [691, 691, 717, 717, 1231], [1233, 1233, 1265, 1265, 1512], [1519, 1519, 1576, 1601, 3237]]}
{"id": "WsdyRn", "name": "Living in a Box - WIP", "author": "neriakX", "description": "This shader is based on some ray marching courses by Flopine, it's my first attempt and I'm a total noob :P\nIt's nothing special and I just keep learning from this. However I share it with you to hopefully get some constructive criticism fro you guys.\n", "tags": ["raymarching", "learning"], "likes": 5, "viewed": 61, "published": "Public", "date": "1600451662", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* inspired by Flopine's and evvvil's ray marching courses/videos on twitch <3\n\nthis is my first attempt in ray marching.\njust starting to mess around with (hopefully) simple stuff ...\nI took some functions from iq also => https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nthere's a lot of stuff missing and funky things are happening :)\n\n*/\n\n#define bpm (121./60.)\n#define FOV .33\n#define ITER 128\n#define PI  (atan(1.0) * 4.0)\n#define TAU (atan(1.0) * 8.0)\n#define tt mod(iTime*1.,100.)\n\nfloat t;\nvec2 sc;\nvec3 np, no, al, po, ld;\n\n// iq's Tools\nfloat uni( float d1, float d2 ) { return min(d1,d2); }\nfloat sub( float d1, float d2 ) { return max(-d1,d2); }\nfloat isec( float d1, float d2 ) { return max(d1,d2); }\n\nfloat ssub( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\n// rotation function\nmat2 r2 (float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\n//sphere\nfloat sp(vec3 p, float r) { return length(p)-r; }\n\n//diamond\nfloat di (vec3 p, float s) \n{\n    float lx = length(p.x);\n    float ly = length(p.y);\n    float lz = length(p.z);\n    return sqrt(lx+ly+lz)-s;   \n}\n\n// box\nfloat bo (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return length(max(q, 0.)) + min(0., max(q.x,max(q.y,q.z)));  \n}\n\n// Cylinder\nfloat cy (vec3 p, float r, float height) \n{\n    return max(length(p.xy)-r,abs(p.z)-height); \n}\n\n// the sphere\nvec2 bs (vec3 p)\n{\t\n    // bouncing sphere \n    p.x -= sin(tt); // sphere moves slightly left and right\n    p.y -= 1.6*sin(tt*bpm*2.); // bounces sphere up and down along the y-axis\n    vec2 h,t=vec2(sp(p, 2.),10.);\n    return t;\n}\n\n// the room\nvec2 rtr (vec3 p)\n{   \n  \t// moving room\n    p.yz *= r2(atan(sin(tt)*.5)); // rotate room along the y-axis (up'n'down)\n    p.xz *= r2(-tt); // rotate room alanong the x-axis (right)\n    vec2 h,t = vec2(-bo(p, vec3(20.,4.0,20.)),5.);\n\n    // cut the room with cylinders\n    float per = 2.5; //period - Wiederholungen - netter Wert 1.9 o. 2.5\n   \tp.xz = mod(p.xz, per)-per *0.5; // domain repeat of cylinders to cut the floor and ceiling\n\th=vec2(cy(p.xzy,0.7, 5.0),5.); // 1e10\n    t.x=ssub(h.x, t.x, 0.03); // smooth subtracts floor with cylinders\n    t.x*=0.8;\n    return t; \n}\n\n// the scene\nvec2 mp (vec3 p) \n{ \t\n    np=p;\n    vec2 h,t=rtr(p);\n    h=bs(p);\n   \tt=(t.x<h.x)?t:h;\n    return t;\n}\n\n// lighting\nfloat li (vec3 n, vec3 l)\n{\n  return max(0., dot(n, l));\n}\n\n// Camera\n vec3 cam (vec3 ro, vec2 uv, float fov)\n{\n    vec3 cw=normalize(vec3(0.,1.,1.)-ro),\n    \tcu=normalize(cross(cw, vec3(0.,0.,1.))),\n    \tcv=normalize(cross(cu,cw));\n    return mat3(cu,cv,cw)*normalize(vec3(uv,FOV));\n} \n\n// main raymarching function\nvec2 tr (vec3 ro, vec3 rd) \n{\n    vec2 h,t=vec2(0.1);\n    for(int i=0;i<ITER;i++){\n        h=mp(ro+rd*t.x);\n        if(h.x<.0001||t.x>40.) break;\n        t.x+=h.x;t.y=h.y;\n    }\n    if (t.x>40.) t.x=0.;\n    return t;\n}\n\n// get Normals (iq)\nvec3 calcNormal( in vec3 po )\n{\t\n    vec2 e=vec2(.00035,-.00035);\n    return normalize(e.xyy*mp(po+e.xyy).x+\n        e.yyx*mp(po+e.yyx).x+\n        e.yxy*mp(po+e.yxy).x+\n        e.xxx*mp(po+e.xxx).x); \n}\n\n// AO\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.) \n// SSS\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(gl_FragCoord.xy / iResolution.xy);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n      \n    // ray_origin / camera\n    vec3 ro = vec3(0.,0.,6.), //ray origin is 0.,0.,6. in space - step back\n    rd=cam(ro,uv,FOV),\n    co,fo,ld=normalize(vec3(5.,3.8,5.));\n      \n    sc=tr(ro,rd); // sc.x = distance geometry, sc.y = colour\n    t=sc.x; // t is the result of the geometry\n    \n    if (t>0.) \n    {\t\n        po=ro+rd*t;\n        vec3 no=calcNormal(po),\n        al=vec3(0.,0.08,0.45); // albedo\n     \n        // Material colouring\n        if(sc.y<5.) al=vec3(0.);\n    \tif(sc.y>5.) al=vec3(1.);\n        if(sc.y>9.) al=vec3(0.48, 0.18, 0.01);\n        \n    \tfloat dif=li(no,ld), // diffuse\n    \tfr=pow(1.+dot(no,rd),4.), // fresnel\n        sp=pow(max(dot(reflect(-ld,no),-rd),0.),30.); // specular by shane.\n    \tco=mix(sp+al*(a(.1)*a(.3)+.2)*(vec3(.2,.1,.2)*dif+s(.5)*1.5),fo,min(fr,.5)); // final lights\n        co=mix(co,vec3(0.022*sin(tt*bpm*2.),0.,0.045),1.-exp(-0.0011*t*t*t)); // add fog\n        \n        // Subtle vignette by Shane\n    \tuv = fragCoord/iResolution.xy;\n    \tco = mix(vec3(0), co, pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*.5 + .5);\n          \n        fragColor = vec4(pow(co,vec3(0.45)),1.); // add gamma correction\n    }\n}", "image_inputs": [{"id": "4l2GDK", "previewfilepath": "https://soundcloud.com/neriakx/normality-2011", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/neriakx/normality-2011", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdyRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[553, 567, 600, 600, 621], [622, 622, 655, 655, 677], [678, 678, 712, 712, 733], [735, 735, 779, 779, 880], [882, 903, 922, 922, 970], [972, 981, 1008, 1008, 1030], [1032, 1042, 1071, 1071, 1189], [1191, 1198, 1225, 1225, 1316], [1318, 1330, 1373, 1373, 1424], [1426, 1440, 1458, 1483, 1671], [1673, 1685, 1704, 1725, 2262], [2264, 2277, 2296, 2296, 2379], [2381, 2393, 2420, 2420, 2451], [2453, 2464, 2504, 2504, 2678], [2681, 2710, 2739, 2739, 2928], [2930, 2950, 2981, 2981, 3152], [3203, 3258, 3315, 3315, 4600]]}
{"id": "WsdyWH", "name": "fast-noise-v1", "author": "jorge2017a1", "description": "fast-noise-v1", "tags": ["fastnoisev1"], "likes": 3, "viewed": 78, "published": "Public", "date": "1600866755", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//desconocido autor\n// 00f404afdd835ac3af3602c8943738ea - please mark changes (and/or add docs), and retain this line.\n\n\n\nfloat _MinStep = 0.0125;\n\n//////////////////////////////////////////////////////////////\n// http://www.gamedev.net/topic/502913-fast-computed-noise/\n//  simplified, and broken on purpose. fullreset\nvec4 random4 (const vec4 x) {\n    vec4 z = mod(mod(x, vec4(5612.0)), vec4(3.1415927 * 2.0));\n    return fract ((z*z) * vec4(56812.5453));\n}\nconst float A = 1.0;\nconst float B = 57.0;\nconst float C = 113.0;\nconst vec3 ABC = vec3(A, B, C);\nconst vec4 A3 = vec4(0, B, C, C+B);\nconst vec4 A4 = vec4(A, A+B, C+A, C+A+B);\nfloat cnoise4 (const in vec3 x) {\n    vec3 fx = fract(x);\n    vec3 ix = x-fx;\n    vec3 wx = fx*fx*(3.0-2.0*fx);\n    float nn = dot(ix, ABC);\n    vec4 R = random4(nn+A3);\n    float re = mix(mix(R.x, R.y, wx.y), mix(R.z, R.w, wx.y), wx.z);\n    return 1.0 - 2.0 * re;\n}\n\n//////////////////////////////////////////////////////////////\n// distance functions\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s ) { return length(p)-s; }\nfloat udBox( vec3 p, vec3 b ) {  return length(max(abs(p)-b,0.0)); }\nfloat udRoundBox( vec3 p, vec3 b, float r ) { return length(max(abs(p)-b,0.0))-r; }\nfloat sdTorus( vec3 p, vec2 t ) { vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nvec3  opRep(vec3 p, vec3 r) { return mod(p,r)-0.5*r; }\nvec3  opTx(vec3 p, mat4 m ) { return (m*vec4(p,1.0)).xyz; }\n/////////////////////////////////////////////////////\n// the rest\n\nfloat fbm(vec3 p) {\n float N = 0.0;\n  float D = 0.0;\n  int i=0;\n  float R = 0.0;\n  D += (R = 1.0/pow(2.0,float(i+1))); N = cnoise4(p*pow(2.0,float(i)))*R + N; i+=1;\n  D += (R = 1.0/pow(2.0,float(i+1))); N = cnoise4(p*pow(2.0,float(i)))*R + N; i+=1;\n  D += (R = 1.0/pow(2.0,float(i+1))); N = cnoise4(p*pow(2.0,float(i)))*R + N; i+=1;\n  D += (R = 1.0/pow(2.0,float(i+1))); N = cnoise4(p*pow(2.0,float(i)))*R + N; i+=1;\n  return N/D;\n}\nfloat scene(vec3 p) { \n  vec3 f = opRep(p,vec3(2.7,15.,2.7));\n  float d = udRoundBox(f,vec3(1.,0.,1.),0.2);\n\t\n//  d = min(d,udRoundBox(p-pw*2.,vec3(100.,80.,.2),0.22));\n\n   vec3 c = opRep(p,vec3(20.,4.6,14.))-vec3(0.,0.,7.);\n   d = min(d,udRoundBox(c,vec3(1.75,2.,0.75),0.15));\n\t\n  float n = fbm(p*3.0);  \t\n  return d+n*0.05;\n}\n\nvec4 color(float d) {  return vec4(1.,1.,1.,0.125)*float(d<0.125); }\n\nvec4 ray(vec3 pos, vec3 step) {\n  vec4 sum = vec4(0.);\n  vec4 col;\n  float d = 9999.0;\n#define RAY1  { d = scene(pos); col = color(d); col.rgb *= col.a; sum += col*(1.0 - sum.a); pos += step*max(d,_MinStep); }\n#define RAY4  RAY1 RAY1 RAY1 RAY1\n  RAY4 RAY4 RAY4 RAY4\n  return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 e = vec3(iTime*0.2*20.,iTime*0.3-sin(iTime*0.2),sin(iTime*0.2)); \n  vec3 p = vec3((fragCoord.xy / iResolution.xy) * 2. -1., 1.);\n  p.x *= iResolution.x/iResolution.y;\n  p += e;\n  fragColor = ray(p, normalize(p-e));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdyWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 320, 349, 349, 459], [636, 636, 669, 669, 902], [904, 1063, 1098, 1098, 1120], [1121, 1121, 1152, 1152, 1189], [1190, 1190, 1235, 1235, 1273], [1274, 1274, 1307, 1307, 1369], [1370, 1370, 1399, 1399, 1424], [1425, 1425, 1454, 1454, 1484], [1485, 1552, 1571, 1571, 1984], [1985, 1985, 2006, 2006, 2312], [2314, 2314, 2335, 2335, 2382], [2384, 2384, 2415, 2415, 2665], [2667, 2667, 2724, 2724, 2948]]}
{"id": "wsdyz7", "name": "Moai Boze", "author": "kaiware007", "description": "I Love Gradius(Nemesis)!\n", "tags": ["raymarching"], "likes": 0, "viewed": 64, "published": "Public", "date": "1600912977", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n// Rendering Option\n#define ENABLE_REFLECTION\n#define ENABLE_GRID_BOUNDARY\n#define SMOOTH_HSV\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 100\n#define MAX_RAYCAST 100\n#define MAX_RAYCAST_L 6\n#define MAX_DIST 10.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define RAD90 (M_PI * 0.5)\n#define RAD45 (M_PI * 0.25)\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\n//const vec3 sunDir = normalize(vec3(-1,1,-0.25));\nconst vec3 lightPos = vec3(0.50, 0.8, -0.5);\nconst vec3 lightColor = vec3(0.98, 0.92, 0.89) * 4.0;\n//const vec3 lightColor = vec3(0.3, 0.6, 0.9) * 2.0;\n\nstruct surface {\n\tfloat dist;\n    vec4 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n    bool isTransparent;\n    float refractPower;\n    bool isHit;\n};\n    \nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\n#define COLOR_SEA (vec3(0,0.05,0.1))\n    \n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec4(0), \t\t \tvec3(0), 0.0, 0.0, 0, false, 0.0, false))\n#define SURF_BLACK(d) \t(surface(d, vec4(0,0,0,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_FACE(d) \t(surface(d, vec4(1,0.7,0.6,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec4(1,0,0.1,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec4(1,0.3,0.4,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\nsurface SURF_PLANETEX(float d, vec3 pos)\n{\n    vec4 col = vec4(texture(iChannel0, vec2(pos.xz)).rgb, 1.);\n        \n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n\n#define SURF_CS(d) \t\t(surface(d, vec4(0.9,0.9,0.9,1), vec3(0), 0.1, 0.8, 0, false, 0., true))\n\n#define SURF_SPHERE(d) \t(surface(d, vec4(0,0,0,1), \t\t vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n#define SURF_CUBE(d) \t(surface(d, vec4(0,1,0,1), \t\t vec3(0), 0.5, 0.0, 0, false, 2.2, true))\n#define SURF_SPHERE2(d) (surface(d, vec4(0,0,1,1), \t\t vec3(0), 0.1, 0.2, 0, false, 2.2, true))\n#define SURF_LEG(d) \t(surface(d, vec4(0.5,0.2,0.1,1), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\n#define SURF_MIRROR(d) \t(surface(d, vec4(0.5,0.5,0.5,1), \t\t vec3(0), 0.3, 0.8, 0, false, 2.2, true))\n#define SURF_SEA(d) \t(surface(d, vec4(COLOR_SEA,0), vec3(0), 0.2, 0.5, 0, true, 1.53, true))\n\nsurface SURF_WATERMELON(float d, vec3 pos, vec3 center)\n{\n    pos = center - pos;\n    vec2 uv = vec2(atan(pos.z,pos.x), pos.y);\n    uv.x = abs(uv.x)-M_PI/5.;\n    vec2 guv = fract(uv*1.5)-0.5;\n    vec2 id = floor(uv*1.5)-0.5;\n    float mask = step(abs(guv.x),0.25+sin((uv.y+id.x)*200.)*0.05);\n    \n    vec4 col = vec4(mix (vec3(0.05,0.3,0.025),vec3(0.025, 0.05, 0.025), mask), 1);\n    return surface(d, col, vec3(0), 0.2, 0.001, 0, false, 2.2, true);\n}\n\n#define SURF_DESERT(d) \t(surface(d, vec4(0.8,0.5,0.4,1), \tvec3(0), 0.0001, 0.01, 0, false, 0.0, true))\n\n//-----------------HSV-----------------\n\n//HSV functions from iq (https://www.shadertoy.com/view/MsS3Wc)\n#ifdef SMOOTH_HSV\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#else\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#endif\n\n//From Sam Hocevar: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nsurface SURF_BG1(float d, vec3 pos)\n{\n    //vec3 index = floor((pos +vec3(0,0,iTime*3.0) )* 2. + 0.5);\n    vec3 index = floor(pos * 2. + 0.5);\n    vec4 col = vec4(vec3(0.25) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0), 1);\n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n\nsurface SURF_BG_COLORFULL(float d, vec3 pos)\n{\n    //vec3 index = floor((pos +vec3(0,0,iTime*3.0) )* 2. + 0.5);\n    vec3 index = floor(pos * 2. + 0.5);\n    float flg = mod(mod(index.x + index.y, 2.0) + index.z, 2.0);\n    //vec4 col = vec4(vec3(0.25) + vec3(0.5,0,0.5) * flg, 1);\n    //vec4 col = vec4(vec3(0.25) + sinebow((hash13(index) + iTime*0.5) * M_PI) * flg, 1);\n    return surface(d, vec4(vec3(0.25)*(1.-flg), 1), sinebow(hash13(index*3165.5) * M_PI + iTime*0.5) * flg, 0.5, 0.1 + 0.7 * (1.-flg), 0, false, 0., true);\n\t//return SURF_MIRROR(d);\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// original sea octave function by TDM\n// https://www.shadertoy.com/view/Ms2SD1\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - mix(r1, r2, h);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Distance Function 2D\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// SdJoint3DSphere & joint3DMatrix & matrix utility\n// by PixelPhil \n// https://www.shadertoy.com/view/3tKGDW\nmat4 scaleMatrix( in vec3 sc ) {\n\treturn mat4(sc.x, 0,\t0,\t0,\n\t\t\t \t0, \t sc.y,\t0,\t0,\n\t\t\t\t0, \t 0,\t sc.z,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\nmat4 translate( in vec3 p) {\n\n\treturn mat4(1,  0,\t0,\t0,\n\t\t\t \t0,\t1,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\tp.x, p.y, p.z, 1);\n}\n// returns distance in .x and UVW parametrization in .yzw\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-w;\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-w;\n}\n\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w1, float w2)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-mix(w2, w1, p.y / l);\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-mix(w2, w1, (p.y / l));\n}\n\n// A matrix to the tip of a sdJoint3DSphere\n// Could probably use some optimisations\nmat4 joint3DMatrix(in float l, in float a)\n{\n  if( abs(a)<0.001 )\n  {\n      return translate(vec3(0, -l, 0));\n  }\n    \n  float ra = 0.5 * l / a;\n  float ara = abs(ra);\n  return  rotationZ(-a * 2.0) * translate(vec3(-ra + cos(2.0 * a) * ra, -sin(2.0 * a) * ra, 0.0));\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{ \n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec4 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    float refractPower = mix( d2.refractPower, d1.refractPower, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count, h > 0.5 ? d1.isTransparent : d2.isTransparent, refractPower, true);\n}\n\nsurface opI( surface d1, surface d2 )\n{ \n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        d2.dist = d1.dist;\n        return d2;\n    }\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(RAD90, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// \n// rayPos : \n// rayDir : \n// planePos : \n// planeNormal : \nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// \nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n    //return vec2(tF, tN);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n\n/*\n// \nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float radius)\n{\n    float rsq = radius * radius;\n    vec3 xc = rayPos - spherePos;\n    float xc2 = dot(xc, xc);\n    float vxc = dot(rayDir, xc);\n    float d = vxc * vxc - xc2 + rsq;\n    \n    //if(d < 0.0) return vec2(d,d);\n    \n    float sqrtd = sqrt(d);\n    float tn = -vxc - sqrtd;\n    float tp = -vxc + sqrtd;\n    \n    return vec2(min(tn, tp), max(tn, tp));\n                \n    //if(tn >= 0.0 && tp >= 0.0) return vec2(min(tn, tp), max(tn, tp);\n\n    //return tn;\n}\n*/\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 sphereCenter, float radius) {\n    float a = length(rayDir);\n    float a2 = a * a;\n    vec3 diff = rayPos - sphereCenter;\n    float b = dot(diff, rayDir);\n    float c = length(diff);\n    float c2 = c * c - radius * radius;\n    float b2ac = sqrt(b * b - a2 * c2);\n    float t1 = (-b + b2ac) / a2;\n    float t2 = (-b - b2ac) / a2;\n    return vec2(min(t1, t2), max(t1, t2));\n}\n\n// IK\nvec3 solve( vec3 p, float l1, float l2, vec3 dir )\n{\n\tvec3 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p) );\n\t\n\tfloat s = l1*l1 - dot(q,q);\n\ts = max( s, 0.0 );\n\tq += sqrt(s)*normalize(cross(p,dir));\n\t\n\treturn q;\n\n}\n\nvec3 solve( vec3 a, vec3 b, float l1, float l2, vec3 dir )\n{\n\treturn a + solve( b-a, l1, l2, dir );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// easing function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nfloat easeInCirc(float x)\n{\n\treturn 1. - sqrt(1. - pow(x, 2.));\n}\n\nfloat easeOutCirc(float x) \n{\n\treturn sqrt(1. - pow(x - 1., 2.));\n}\n\nfloat easeInExpo(float x)\n{\n\treturn x == 0. ? 0. : pow(2., 10. * x - 10.);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(0.);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n/*\nsurface sdCapsuleBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nsurface sdUFBoze(vec3 p, vec3 sc, float ms)\n{\n    float sl = length(sc);\n    surface cone = SURF_CS(sdCappedCone(p + vec3(0, 0.08 * sl, 0), 0.06 * sl, 0.5 * sl, 0.25 * sl));\n    return opU(sdBoze(p, sc, ms), cone);\n}\n\nsurface sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n*/\n#define LEG_X 0.05\n#define LEG_WIDTH1 0.05\n#define LEG_WIDTH2 0.025\n#define LEG_WIDTH3 0.045\n\n#define ARM_X1 0.18\n#define ARM_X2 0.2\n#define ARM_WIDTH1 0.05\n#define ARM_WIDTH2 0.025\n#define ARM_WIDTH3 0.03\n/*\nvoid calcArm(out vec3 a0, out vec3 a1, out vec3 a2, float spd, float flip, float h)\n{\n\t//vec3 n = noised(vec2(330. + spd * 0.97 + 578.4516 * flip, spd * flip));\n    vec3 n = vec3(sin(spd * 0.97+ 578.4516 * flip), cos(spd * 0.75* flip), sin(spd * flip + RAD90));\n    float r = n.z * 0.15 + 0.15;\n    float theta = (n.x * 0.5 + 0.5) * RAD90;\n    float phi = (n.y * 0.5 + 0.5) * RAD90;\n    a0 = vec3(ARM_X1 * flip, 0.9-h, 0.);\n    a2 = vec3(ARM_X2 * flip + sin(theta) * cos(phi) * r * flip, 0.75 + cos(n.y * M_PI2) * r-h, -sin(theta) * sin(phi) * r);\n    a1 = solve(a0, a2, 0.25, 0.15, vec3(0.5,0,0.5 * flip));\n}\n\nsurface sdBozeFullBody(vec3 p)\n{\n    surface result = SURF_NOHIT(0.);\n    \n    float spd = iTime * 2.5;\n    \n    // leg\n    //vec3 n1 = noised(vec2(spd, spd * 0.75));\n    vec3 n1 = vec3(sin(spd), cos(spd * 0.75), sin(spd + M_PI));\n    float r1 = n1.z * 0.25 + 0.25;\n    vec3 ll2 = vec3(LEG_X + sin(n1.y * M_PI) * cos(n1.x * M_PI) * r1, cos(n1.y * M_PI) * 0.3, sin(n1.y * M_PI) * sin(n1.x * M_PI) * r1);\n        \n    //vec3 n2 = noised(vec2(-spd * 0.75, spd));\n    vec3 n2 = vec3(cos(spd), sin(spd * 0.75), cos(spd + RAD90));\n    float r2 = n2.z * 0.25 + 0.25;\n    vec3 rl2 = vec3(-LEG_X + sin(n2.y * M_PI) * cos(n2.x * M_PI) * r2, cos(n2.y * M_PI) * 0.3, sin(n2.y * M_PI) * sin(n2.x * M_PI) * r2);\n\n    float h = min(ll2.y, rl2.y);\n\n    vec3 ll0 = vec3(LEG_X, 0.5-h, 0.);\n    vec3 ll1 = solve(ll0, ll2, 0.25, 0.25, vec3(-1,0,0));\n    \n    vec3 rl0 = vec3(-LEG_X, 0.5-h, 0.);\n    vec3 rl1 = solve(rl0, rl2, 0.25, 0.25, vec3(-1,0,0));\n    \n    //result = SURF_MIRROR(sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    float body = sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2);\n    //body = smin(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3));\n    \n    //result = opU(result, SURF_MIRROR(sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2)));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    body = min(body, sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2));\n    //body = smin(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3));\n    \n    // body\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05)), 0.05);\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075)), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075), 0.05);\n    body = min(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05));\n    body = min(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075));\n    \n    // left arm\n    vec3 la0, la1, la2;\n    calcArm(la0, la1, la2, spd, 1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n\tbody = min(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3));\n\n    // right arm\n    vec3 ra0, ra1, ra2;\n    calcArm(ra0, ra1, ra2, spd, -1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3));\n    \n    result = SURF_MIRROR(body);\n    \n    // head\n    vec3 b = p;\n    \n    b = rotate(b, M_PI, vec3(0,1,0));\n    b.y -= 1.01-h;\n\n    result = opSU(result, sdBoze(b, vec3(1), 1.), 0.02);\n\t\n    return result;\n}\n*/\nsurface sdWatermelonBoze(vec3 p, vec3 sc, float ms)\n{\n    //surface result = sdBoze(p, vec3(1), 1.);\n    surface result = SURF_NOHIT(0.);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n    // outer skin\n\tsurface head = SURF_WATERMELON(d, p, vec3(0));\n\n    if(head.dist < 0.){\n        if(head.dist > -0.01){\n\t    \t// inner skin\n        \thead.albedo = mix(head.albedo, vec4(1,1,0.5,1), smoothstep(0., 0.01, abs(head.dist)));\n    \t}else{\n            // flesh meat\n            float n = fbm(p * 25.);\n            head.albedo = mix(vec4(1,1,0.5,1), vec4(1,0,0,1) + n * 0.2, smoothstep(0.01, 0.015, abs(head.dist)));\n            // seed\n            const float mb = M_PI2 / 32.;\n            vec3 ps = p;\n            ps.y -= 0.025;\n    \t\tfloat b = mod(atan(ps.y, ps.z), mb) - 0.5 * mb;\n    \t\tfloat c = smoothstep(.15, .18, length(vec2(b*12.,abs(head.dist)*15.0 - 0.5)));\n            head.roughness = mix(0.01, 0.1, c);\n            head.albedo = mix(vec4(0.02), head.albedo, c);\n    \t}\n    }\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    //surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    //surface mouse = SURF_MOUSE(d6);\n    d4 = min(d4, d6);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    //eye.dist = opUnion(eye.dist, d9);\n    d4 = min(d4, d9);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n\t//surface cheep = SURF_BLACK(d7); \n    \n    head.dist = min(head.dist, d7);\n    head.dist = max(-d4, head.dist);\n    \n    // integration\n    //mouse = opU(eye, mouse);\n    //result = opS(mouse, head);\n    //result = opU(cheep, result);\n    result = head;\n    result.dist *= minsc;\n    \n    return result;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nsurface map(vec3 p)\n{\n\tsurface result;\n    \n    vec3 q = opRep(p, vec3(0.5,100,100.0));\n    \n    // boze\n    q = rotate(q, M_PI, vec3(0,1,0));\n    \n    result = sdBoze(rotate(q+vec3(0,0.075,0), RAD90*0.1, vec3(1,0,0)), vec3(1), 2.);\n    \n    result = opSU(result, SURF_FACE(sdCappedCone(q + vec3(0,0.1,0), 0.1, 0.12, 0.01)), 0.02);\n    \n    // background\n    surface bg1 = SURF_BG1(sdPlane(p + vec3(0., 0.2, 0.), vec4(0,1,0,0)), p);\n    result = opU(result, bg1);\n    \n    return result;\n}\n/*\nfloat mapNormal(vec3 p)\n{\n\tsurface result;\n    \n    // background\n    float h = sea_octave(p.xz * 0.75, 5.5) * 0.2;\n    //h += sea_octave(p.xz * 100., 0.1) * 0.01;\n    //float gl = noise(p*500.);\n    //h += noise(p*500.) * 0.00075;\n    h += hash12(p.xz*100.) * 0.0002;\n    float sand = abs(p.y - h * length(p.xz*0.5) + 0.2);\n    \n    float dist = sand * 0.5;\n    //result = SURF_DESERT(sand * 0.5);\n    //result.roughness = 0.0001;\n    //result.metalness = 0.1;\n    //result.metalness = saturate(gl*10.);\n    //result.roughness = 0.1;\n    \n    // boze\n    p = rotate(p, M_PI, vec3(0,1,0));\n    \n    float a = 1. - smoothstep(0., 5., cos(iTime*1.) * 5. + 2.5);\n    vec3 b = p;\n    b.y += (1.-a)*0.1;\n    b.x += 0.15 * a;\n    b = rotate(b, (-RAD90-RAD90*0.25)*a, vec3(0,0,1));\n    \n    float boze = sdBoze(b, vec3(1), 2.).dist;\n    //surface boze = sdBoze(b, vec3(1), 2.);\n    boze = max(boze, sdBox(b + vec3(0.5, 0.5, 0), vec3(0.5,1,1)));\n    dist = min(boze, dist);\n    \n    //result = opU(result, boze);\n    \n    b = p;\n    b.y += (1.-a)*0.1;\n    b.x -= 0.15 * a;\n    b = rotate(b, (RAD90+RAD90*0.25)*a, vec3(0,0,1));\n    boze = sdBoze(b, vec3(1), 2.).dist;\n    //boze = sdBoze(b, vec3(1), 2.);\n    boze = max(boze, sdBox(b + vec3(-0.5, 0.5, 0), vec3(0.5,1,1)));\n    dist = min(boze, dist);\n    \n    //result = opU(result, boze);\n    \n    //return result;\n    return dist;\n}\n*/\n#if 0\nvec3 norm(vec3 p)\n{\n    /*\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).dist-vec3(map(p-e.xyy).dist,map(p-e.yxy).dist,map(p-e.yyx).dist));\n*/\n\tfloat c=mapNormal(p).dist;\n\tfloat e=1e-3;\n\treturn normalize(vec3(mapNormal(p+vec3(e,0,0)).dist-c,\n\t\t\t\t\t\t  mapNormal(p+vec3(0,e,0)).dist-c,\n\t\t\t\t\t\t  mapNormal(p+vec3(0,0,e)).dist-c));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    /*\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n\t*/\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    // https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(position+0.0005*e).dist;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n    /*\n    // https://www.shadertoy.com/view/XltyRf\n    vec4 n = vec4(0);\n    for (int i = 0 ; i < 4 ; i++) {\n        vec4 s = vec4(position, 0);\n        s[i] += 0.001;\n        n[i] = map(s.xyz).dist;\n    }\n    return normalize(n.xyz-n.w);\n\t*/\n}\n#endif\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).dist;\n        if (h < EPS) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n/*\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec2 getPoint(vec2 id, vec2 offset)\n{\n    return sin(hash22(id + offset) * iTime * 1.5 + hash22(id + offset)) * 0.4 + offset;\n}\n*/\nvec3 SkyColor( vec3 rd )\n{\n#if 0\n    // Cube Map\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    // Black\n    return vec3(0);\n    \n    // test 1 UV\n    //return rd * 0.5 + 0.5;\n    \n    // sinebow\n    //return sinebow(iTime*0.5) * 0.1;\n    \n    //return vec3(0,0.5,0);\n    \n    /*\n    // plexus\n    vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    uv += vec2(10.);\n    uv = abs(uv);\n    vec2 suv = uv * 10.;\n    \n    vec2 id = floor(suv) - 0.5;\n    vec2 fuv = fract(suv) - 0.5;\n\tvec2 pp =  getPoint(id, vec2(0));\n    vec3 col = vec3(0);\n    \n    for(int x = -1; x <= 1; x++){\n    \tfor(int y = -1; y <= 1; y++){\n            vec2 pos = getPoint(id, vec2(x,y)); //sin(hash22(id + vec2(x,y)) * iTime * 1.5) * 0.4 + vec2(x,y);\n            float d = 1.0 / pow(length(fuv - pos), 1.75) * 0.001;\n            col += d;\n\n            float len = smoothstep(1.0,0.5,length(pp - pos));\n            col += smoothstep(0.025,0.001,sdSegment(fuv, pos, pp)) * len;\n        }\n    }\n\t\n    return col * sinebow(uv.x);\n\t*/\n    /*\n    // fake unity default sky-box\n\tvec3 ground = mix(vec3(0.25,0.4,0.8), vec3(0.2,0.15,0.15), saturate(abs(rd.y) * 25.0));\n    //vec3 ground = mix(vec3(0.25,0.4,0.8), COLOR_SEA, saturate(abs(rd.y) * 25.0));\n    //vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.001, 0.15, 1.), saturate(abs(rd.y) * 10.0));\n    vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.5, 0.8, 1.), saturate(abs(rd.y) * 10.0));\n    return rd.y < 0. ? ground :sky;\n    */\n    \n\t// Starfield\n    //float x = atan(rd.z / rd.x);\n    //float y = acos(rd.y);\n    //return vec3(StableStarField(vec2(x,y) * 1000., 0.97 ));\n    \n    // wave z\n    //vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    //return vec3(saturate(uv),0);\n    //return vec3(1,0,0) * saturate(sin(rd.z *100.- iTime * 10.));\n    //return sinebow(rd.z * 5.- iTime * 3.) * 0.25;\n    //return smoothstep(0.01,0.,mod(rd.z - iTime * 0.1, 0.1))*vec3(0.05,0.2,0.5);\n#endif\n}\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    //vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    vec3 albedo = surf.albedo.rgb;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec3 ibl = diffuseColor * indirectDiffuse;\n    \n    color += ibl * indirectIntensity;\n\tcolor += surf.emission.rgb;\n    \n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n///////////////\n/*\nfloat sdAirLine(vec3 p)\n{\n\tconst float w = 0.0125;\n    float angle = -radians(30.);\n    p.y += 0.4;\n    float air = sdCapsule(p, vec3(0), vec3(0., -1.0, 0), w);\n    air = min(air, sdJoint3DSphere(p, 0.3, angle, w));\n    mat4 mat = joint3DMatrix(0.3, angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    air = min(air, sdJoint3DSphere(p, 0.25, radians(30.), w));\n    mat = joint3DMatrix(0.25, -angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    return min(air, sdCapsule(p, vec3(0, 0, 0), vec3(0., 1.0, 0), w));\n}\n\nfloat densitycalc(vec3 p){\n    float air = MAX_DIST;\n    float ad = M_PI / 5.0;\n    for(int i = 0; i < 6; i++){\n    \tvec3 q = p;\n    \n    \tq = rotate(q, -RAD90, vec3(1,0,0));\n        q = rotate(q, ad * float(i), vec3(0,1,0));\n    \tq.x += 0.1;\n    \n    \tair = min(air, sdAirLine(q));\n    }\n    \n    return fbm(p * (50,50,15.) *vec3(1,1,1)+ vec3(0, 0, iTime * -15.)) - min(air, 1.) * (20.);\n}\n*/\nfloat densitycalc(vec3 p){\n    //p = rotate(p, 0.45, vec3(0,0,1));\n    //p = rotate(p, M_PI, vec3(0,1,0));\n    p = opRep(p, vec3(0.5,100,100.0));\n    p = rotate(p + vec3(0,0.04,0.2), RAD90, vec3(1,0,0));\n    float d = 10000.;\n    for(int i = 0; i < 5; i++)\n    {\n        float k = fract(float(i) / 5. + iTime * 0.25);\n        vec3 q = p + vec3(0, -2.8*k, -0.1*k);\n        //surface r = sdBoze(p, vec3(1), (sin(iTime * 2.0) * 0.5 + 0.5)*1.5);\n        //surface r = sdBoze(p, vec3(1.2), 1.);\n        //float d = sdCapsule(p, vec3(0,0.01,0.2), vec3(0,0.1,1.0), 0.01, 0.1);\n        //float d = sdTorus(p, vec2(0.2 + sin(iTime) * 0.1, 0.05));\n        float d2 = sdTorus(q, vec2(0.2*k, 0.05*k));\n        //return fbm(p * 25. + iTime * 2.2) - min(d, 1.) * 25.;\n        //return fbm(p * (25. + p.y * 25.) *vec3(1,0.5,1)+ vec3(0, iTime * -5.2, 0)) - min(d, 1.) * (20. - p.y * 20.);\n        //return fbm(p * (25. + p.y * 25.) *vec3(1,0.5,1)+ vec3(0, iTime * -5.2, 0)) - min(d, 1.) * (20. - p.x * 20.);\n        d = min(d, d2);\n    }\n    return fbm(p * (25. + p.z * 25.) * vec3(1,1,0.5)+ vec3(0, 0, iTime * -5.2)) - min(d, 1.) * 25.;\n}\n\n\nsurface rayCast(vec3 pos, vec3 dir, float dist)\n{\n    const vec3 boxPos = vec3(0,0,0);\n    const vec3 boxSize = vec3(100., 0.5, 10.);\n    vec2 sd = GetIntersectBox(pos, dir, boxPos, boxSize);\n    surface result = SURF_NOHIT(MAX_DIST);\n    \n    if((sd.y >= 0.) && (dist > sd.x) && (sd.x < sd.y)) \n    {        \n        const float step = 4.0 / float(MAX_RAYCAST);\n\t\t//const float lightStep = 2.0 / float(MAX_RAYCAST_L);\n        float start = max(0., sd.x) - step;\n        pos = pos + dir * start;\n\n        float t = hash13(pos * 5.5) * 0.001;\n        float alpha = 0.;\n        float transmittance = 1.0;\n        float absorption   = 20.;\n        for(int i = 0; i < MAX_RAYCAST; i++){\n            t += step;\n            \n            vec3 pp = pos + dir * t;\n            if((t >= sd.y)||(start + t >= dist))\n                break;\n            \n            vec3 q = pp - boxPos;\n            \n            float density = densitycalc(q);\n            \n            if(density > 0.0){\n                float dd = density * step;\n                transmittance *= 2. - dd * absorption;\n                if(transmittance < 0.001)\n                    break;\n                alpha += 20. * dd * transmittance;\n\t\t\t\t\n                //result.albedo.rgb += vec3(0.5,0.65,0.85) * (150. * dd * transmittance);\n                //result.emission.rgb += vec3(1,0.3,0.05) * (150. * dd * transmittance);\n                result.emission.rgb += vec3(0.1,0.3,1.0) * (150. * dd * transmittance);\n            }\n        }\n        result.emission.rgb *= max(0., alpha);\n        //result.albedo.a = saturate(alpha);\n        result.dist = alpha > 0. ? t : dist;\n        result.isHit = alpha > 0. ? true : false;\n    }\n\n    return result;\n}\n\n\n#define fog_density(x) (1.0 - saturate(exp2(7.5 - (x) * 3.5)))\n\nsurface traceRay(in vec3 origin, in vec3 direction, float dist, out vec3 pos) {\n    float t = 0.0;\n    \n    pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    //surface volume = SURF_NOHIT(MAX_DIST); \n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = hit.dist;\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n        \n#ifdef ENABLE_GRID_BOUNDARY\n        // grid overshoot check\n        vec2 iBox = GetIntersectBox(pos, direction, floor(pos + 0.5), vec3(0.5));\n        if(iBox.x < iBox.y && iBox.y > 0.0 && iBox.y < d) {\n            d = iBox.y + EPS; \n        }\n#endif        \n\n        t += d;\n                \n        pos = origin + direction * t;\n\n        count++;        \n    }\n\n    hit.dist = t;\n\thit.count = count;\n\n    pos = origin + direction * t;\n    vec3 sky = SkyColor(direction);\n        \n    if(hit.isHit)\n    {\n        vec3 nor = norm(pos);\n\n        //vec3 lightPos;\n\t\t//vec3 lightColor;\n        //fireworkLight(lightPos, lightColor);\n        // Calc Ambient\n        hit.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, hit);\n        // Exponential distance fog\n        hit.albedo.rgb = mix(hit.albedo.rgb, sky, fog_density(hit.dist + dist));\n    }\n    \n    // raycast\n    surface volume = rayCast(origin, direction, t);\n\n    if(volume.isHit)\n    {\n        // Calc Ambient\n        //volume.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, volume);\n        \n        // Exponential distance fog\n        volume.albedo.rgb = mix(volume.albedo.rgb, sky, fog_density(volume.dist + dist));\n        \n        hit.albedo.rgb = mix(hit.albedo.rgb, volume.albedo.rgb, volume.albedo.a);\n\t\thit.albedo.a = max(hit.albedo.a, volume.albedo.a);\n        hit.albedo.rgb = mix(sky, hit.albedo.rgb, hit.albedo.a);\n        \n        // Exponential distance fog\n        volume.emission.rgb = mix(volume.emission.rgb, sky, fog_density(volume.dist + dist));\n        hit.albedo.rgb += volume.emission;\n        //hit.albedo.rgb += volume.albedo.rgb;\n        hit.isHit = volume.isHit;\n    }\n    \n    if(d <= EPS || volume.isHit){\n        \n        hit.isHit = true;\n        return hit;\n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, true);\n    }else{\n\t\t\n        hit.isHit = false;\n        return hit;\n        \n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, false);\n    }\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray, 0., pos);\n    \n    //pos = p + mat.dist * ray;\n    //return materialize(pos, ray, mat, uv);\n    \n    vec3 col = vec3(0,0,0);\n    vec3 sky = SkyColor(ray);\n    \n    //if (!mat.isHit && mat.albedo.a <= EPS) {\n    if (!mat.isHit) {\n        col = sky;\n    } else \n    {\n        \n        col = mat.albedo.rgb;\n\n#ifdef ENABLE_REFLECTION\n        float metalness = mat.metalness;\n        float dist = mat.dist;\n\n        if(mat.isHit){\n            // reflection\n            for(int i = 0; i < 2; i++)\n            {\n                vec3 nor = norm(pos);\n                //nor = normalize(nor + hash33(pos) * mat.roughness * 0.05);\n                bool isIncoming = dot(ray, nor) < 0.0;\n                vec3 orientingNormal = isIncoming ? nor : -nor;\n                bool isTotalReflection = false;\n\n                if(mat.isTransparent){\n                    // refract\n                  \t//float nnt = isIncoming ? 1.0 / mat.refractPower : mat.refractPower;\n                    //float nnt = 1.0 / mat.refractPower;\n                    float nnt = isIncoming ? 1.0 / mat.refractPower : 1.0;\n                    ray = refract(ray, orientingNormal, nnt);\n                    pos = pos - orientingNormal * OFFSET;\n                    isTotalReflection = (length(ray) <= 0.9);\n                }\n\n                if(isTotalReflection || !mat.isTransparent)\n                {\n                    // reflect\n                    ray = reflect(ray, orientingNormal);\n                    pos = pos + orientingNormal * OFFSET;\n                }\n\n                mat = traceRay(pos, ray, dist, pos);\n\n                dist += mat.dist;\n                \n                pos = pos + mat.dist * ray;\n                \n                col += mat.albedo.rgb * metalness;\n                //col += result;\n                metalness *= mat.metalness;\n\t\t\t\t\n\t\t\t\tif(!mat.isHit || metalness < 0.0001)\n                    break;\n            }\n        }\n#endif\n    }\n    \n    // Glow\n\t//col += (sinebow(iTime * 10.) +vec3(0.1))* pow((mat.z + 10.) / float(MAX_MARCH), 3.5); \n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n    \n}\n/*\nvec3 postEffect(vec3 col, vec2 index)\n{\n    //float shift = rand(index * 82.345);\n    float shift = (index.x + index.y * 3.0) / 9.0;\n    vec3 hsv = rgb2hsv(col);\n    hsv.x += shift + iTime * 0.1;\n    hsv.y = 0.75;\n    //hsv.y *= 2.5;\n    //hsv.y = hsv.y < 0.25 ? 0.25 : hsv.y;\n    //hsv.y = floor(hsv.y * 8.0) / 8.0;\n    //hsv.z = 1.0;\n    //hsv.z = hsv.z < 0.7 ? hsv.z < 0.5 ? 0.0 : 0.5 : hsv.z;\n    hsv.z = floor(hsv.z * 8.0) / 8.0;\n    hsv.z = hsv.z < 0.6 ? 0.0 : hsv.z;\n    \n    hsv.x += hsv.z * 3.0;\n\tcol = hsv2rgb(hsv);\n    //col = floor(col * 8.0) / 8.0;\n\n\treturn col;\n}\n*/\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    \n    //vec2 p = (fragCoord.xy) / min(iResolution.x, iResolution.y);\n    //vec2 p = (fragCoord.xy) / iResolution.xy;\n    \n    //vec2 idx = floor(p*3.0);\n    //p = fract(p*3.0) - 0.5;\n    //p.x *= max(iResolution.x, iResolution.y)/min(iResolution.x, iResolution.y);\n    \n    float t = iTime * M_PI2 * -0.05;\n    //float t = iTime * -1.0;\n    //float t = 0.;\n\t//float y = sin(t * 2.5) * 0.125-0.0;\n    //float y = sin(t * 5.) * 0.1 + 0.5;\n    float y = 0.0;\n    //float r = 1.5 + sin(t * 2.5);\n    float r = 2.5;\n    //float distortionPower = sin(iTime * 0.2 * M_PI2) * 0.5 + 0.5;\n    //float distortionPower = sin(iTime * 0.05 * M_PI2);\n    //float theta = t + RAD90 + RAD90*0.25;\n    float theta = RAD90 + RAD90*0.25;\n    //float theta = 0.;\n    //float theta = M_PI - RAD90*0.25;\n\t//float theta = t + RAD90;\n    //float theta = RAD90 + noise(vec2(p.x * 3., iTime * 0.1 * M_PI)) * RAD90 * distortionPower;\n    //float theta = RAD90;\n    //float theta = t + RAD90 + (mouseUV.x) * M_PI2;\n    //float theta = M_PI + RAD90 + (mouseUV.x) * M_PI2;\n    //float phi   = noise(vec2(p.y * 3., iTime * 0.1 * M_PI)) * RAD90 * distortionPower;\n    float phi   = 0.;\n    //float phi   = RAD90*0.5;\n    //float phi   = (mouseUV.y) * RAD90;\n    //float phi   = (mouseUV.y) * RAD90;\n    //vec3 ro = vec3( 0., 0.05, -0.75 );\n    vec3 ro = vec3(cos(theta) * r, y + sin(phi), -sin(theta) * r);\n    //vec3 ro = vec3(cos(theta) * r + t, y, -sin(theta) * r);\n    vec3 ta = vec3(0., 0., 0);\n    //vec3 ta = vec3(0. + t, -0.5, 0.);\n    \n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 3.5));\n    vec3 col = render(ro, ray, fragCoord.xy);\n    \n    //col = postEffect(col, idx);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdyz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[943, 1192, 1215, 1215, 1288], [1332, 1828, 1870, 1870, 2011], [2682, 2682, 2739, 2739, 3133], [3737, 3813, 3835, 3835, 4166], [4169, 4357, 4380, 4380, 4465], [4467, 4486, 4508, 4508, 4625], [4627, 4646, 4669, 4669, 4772], [4774, 4794, 4815, 4815, 4949], [4951, 4970, 4992, 4992, 5125], [5127, 5147, 5169, 5169, 5294], [5296, 5296, 5333, 5398, 5616], [5618, 5618, 5664, 5729, 6170], [6172, 6172, 6193, 6193, 6263], [6265, 6265, 6288, 6288, 6367], [6370, 6370, 6392, 6392, 6809], [6920, 6920, 6941, 6941, 7082], [7084, 7084, 7114, 7114, 7244], [7246, 7246, 7307, 7307, 7445], [7447, 7447, 7473, 7473, 7782], [7784, 7844, 7870, 7870, 8736], [8738, 8818, 8859, 8859, 9030], [9032, 9132, 9168, 9168, 9196], [9198, 9198, 9244, 9244, 9300], [9302, 9302, 9333, 9333, 9424], [9426, 9426, 9476, 9476, 9594], [9596, 9596, 9657, 9657, 9788], [9790, 9790, 9827, 9827, 9916], [9918, 9918, 9988, 9988, 10122], [10124, 10124, 10188, 10188, 10305], [10307, 10307, 10359, 10359, 10466], [10468, 10468, 10501, 10527, 10558], [10560, 10560, 10585, 10585, 10604], [10605, 10605, 10630, 10630, 10649], [10650, 10650, 10686, 10686, 10714], [10716, 10716, 10775, 10775, 11088], [11090, 11090, 11123, 11123, 11188], [11190, 11214, 11266, 11266, 11385], [11387, 11497, 11529, 11529, 11623], [11625, 11625, 11659, 11659, 11810], [11812, 11812, 11846, 11846, 11994], [11996, 11996, 12030, 12030, 12165], [12167, 12167, 12195, 12195, 12280], [12281, 12339, 12410, 12410, 12738], [12740, 12740, 12822, 12822, 13190], [13192, 13277, 13321, 13321, 13545], [13547, 13604, 13641, 13682, 13765], [13767, 13767, 13806, 13978, 14087], [14089, 14089, 14138, 14138, 14697], [14699, 14699, 14738, 14784, 14869], [14871, 14871, 14912, 15022, 15136], [15151, 15202, 15239, 15239, 15261], [15263, 15263, 15306, 15306, 15328], [15330, 15330, 15374, 15374, 15395], [15397, 15397, 15440, 15440, 15539], [15542, 15542, 15587, 15587, 16016], [16018, 16018, 16039, 16039, 16103], [16105, 16105, 16145, 16145, 16270], [16273, 16273, 16308, 16308, 16456], [16458, 16458, 16492, 16492, 16668], [16670, 16670, 16705, 16705, 16740], [16742, 16742, 16779, 16779, 16814], [16816, 16987, 17072, 17072, 17149], [17151, 17194, 17269, 17269, 17688], [17690, 18268, 18352, 18352, 18695], [18697, 18703, 18755, 18755, 18911], [18913, 18913, 18973, 18973, 19014], [19016, 19231, 19262, 19262, 19311], [19313, 19313, 19340, 19340, 19378], [19380, 19380, 19409, 19409, 19447], [19449, 19449, 19476, 19476, 19525], [19528, 19757, 19778, 19778, 19917], [19943, 19943, 19975, 19975, 20088], [20090, 20090, 20122, 20122, 20262], [20264, 20264, 20297, 20297, 20529], [20531, 20531, 20554, 20554, 21133], [21135, 21135, 21160, 21160, 21321], [21323, 21323, 21366, 21366, 22379], [23287, 27602, 27655, 27702, 29628], [29629, 29847, 29868, 29868, 30336], [30337, 33110, 33159, 33159, 33457], [33460, 35376, 35402, 35402, 37460], [37465, 37636, 37657, 37657, 37705], [37707, 37707, 37768, 37853, 38052], [38054, 38054, 38127, 38219, 38419], [38421, 38421, 38463, 38543, 38597], [38599, 38599, 38648, 38648, 38696], [38698, 38698, 38771, 38828, 39043], [39045, 39045, 39065, 39065, 39090], [39093, 39277, 39327, 39411, 39769], [39771, 39771, 39826, 39883, 40143], [40145, 40145, 40241, 40241, 41636], [41638, 41840, 41873, 41929, 42115], [42117, 42117, 42156, 42156, 42199], [42201, 43110, 43136, 43216, 44233], [44236, 44236, 44285, 44285, 45940], [46007, 46007, 46086, 46086, 48538], [48540, 48540, 48580, 48580, 50799], [50800, 51384, 51426, 51426, 51604], [51607, 51607, 51664, 51664, 53515]]}
{"id": "WsdyzX", "name": "Helios - Workshop Results", "author": "BackwardsCap", "description": "Results of day 1 of my shader workshop.\nIt was a 1 hr session where I walked my co-workers through the basics of shader programming on Shadertoy\nThis is what we made", "tags": ["helios"], "likes": 2, "viewed": 178, "published": "Public API", "date": "1601411129", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define size 7.\n#define SS(U) smoothstep((size*1.5)/iResolution.y,0.,U)\n\nfloat hash21(vec2 p)\n{\n    return fract(sin(dot(p.xy,vec2(1879.13287,5712.1273)))*12893.1278);\n}\n\nfloat circle(vec2 p, float r)\n{\n    return SS(length(p)-r);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv-=.5;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv *= size;\n        \n    float id = hash21(floor(uv));\n    \n    uv = fract(uv)-.5;\n\n    //red circle\n    vec2 pos = uv - vec2(sin(iTime*2.*id),cos(iTime-id*100.))/3.;\n    float c = circle(pos, .1);\n    \n    //green circle\n    vec2 pos2 = uv - vec2(sin(iTime-id*50.),cos(iTime*id))/3.;\n    float c2 = circle(pos2, .1);\n    \n    //blue circle\n    vec2 pos3 = uv - vec2(sin(iTime-id*20.),cos(iTime/2.-id))/3.;\n    float c3 = circle(pos3, .1);\n    \n    \n    //add our colors together\n    vec3 col = vec3(c,c2,c3);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdyzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 95, 95, 169], [171, 171, 202, 202, 232], [234, 234, 290, 340, 1024]]}
{"id": "Wsjfzc", "name": "Jelly box world", "author": "Plento", "description": "A little experiment with marching through objects", "tags": ["3d", "volume"], "likes": 12, "viewed": 313, "published": "Public API", "date": "1601343693", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 rp){\n    vec3 id = floor(rp/7.);\n    \n    float altz = mod(id.z, 2.);\n    float altx = mod(id.x, 2.);\n   \n    if(altz == 0.)\n     \trp.y += iTime;   \n    else\n        rp.y -= iTime;   \n    \n    if(altx == 0.)\n     \trp.x += iTime;   \n    else\n        rp.x -= iTime;   \n    \n    rp = mod(rp, vec3(7.))-vec3(7.)*0.5;\n    \n    return box(rp, vec3(1.))-.2;\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    vec3 rd = normalize(vec3(uv, 0.8));\n    \n    vec3 ro = vec3(0.);\n    ro.z+=iTime*2.;\n\n    vec3 col = vec3(0);\n    \n    float t = 0., d = 0., td = 0.;   \n    \n    const float h = 0.1;\n    \n    vec3 p = vec3(0);\n    \n    for(int i = 0; i < 100; i++){\n        p = ro + rd*t;\n    \td = abs(map(p)); \t   \n        \n        d = max(d, 0.003);\n        \n        if(d < h){\n            float ld = h - d;\n        \tfloat w = (1. - td)*ld;\t\n            td += w;\n            \n        }\n        col += 0.5 + 0.5*cos(vec3(0.5, 1., 0.1)*(t+ro.z)+vec3(1., 0., 3.) );\n        \n        t += d*.7;\n        if(t > 45.){\n            t = 45.;\n            break;\n        }\n        \n    }\n    \n    \n    col*=0.012;\n    col = pow(col, vec3(5));\n    col = 1.-exp(-col*2.);\n    \n    col *= 1.-abs(uv.y*1.2);\n    \n    f = vec4(sqrt(clamp(col, .0, 1.)), 1.);\n    \n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsjfzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 54, 54, 141], [143, 143, 162, 162, 510], [513, 513, 553, 553, 1437]]}
{"id": "wstcDN", "name": "Mandelbulb Ray Marching", "author": "kylehovey", "description": "SDF found here: http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/", "tags": ["fractal", "ray", "mandelbulb", "marching"], "likes": 6, "viewed": 359, "published": "Public", "date": "1600979071", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DIST 100.0\n#define MAX_STEPS 200\n#define EPSILON 0.0001\n\n#define Power 3.0\n\nfloat SDF(vec3 pos, out int steps) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 20 ; i++) {\n\t\tr = length(z);\n        steps = i;\n\t\tif (r>4.0) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\n\treturn 0.5*log(r)*r/dr;\n}\n\nvec3 normal(vec3 point) {\n  vec2 e = vec2(EPSILON, 0.0);\n  int steps = 0;\n\n  return normalize(\n      SDF(point, steps) - vec3(\n        SDF(point + e.xyy, steps),\n        SDF(point + e.yxy, steps),\n        SDF(point + e.yyx, steps)\n      )\n  );\n}\n\nfloat trace(vec3 ro, vec3 rd, out int steps) {\n  float depth = 0.0;\n\n  for (int i = 0; i < MAX_STEPS; ++i) {\n    float dist = SDF(ro + depth * rd, steps);\n\n    if (dist < EPSILON) return depth;\n\n    depth += dist;\n\n    if (depth > MAX_DIST) return MAX_DIST;\n  }\n\n  return MAX_DIST;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 xy = fragCoord - iResolution.xy / 2.0;\n  vec3 ro = vec3(0.0, 0.5 * sin(iTime), 2.0 + sin(iTime / 3.0));\n  vec3 rd = normalize(vec3(xy, -iResolution.y / tan(radians(50.0) / 2.0)));\n  int steps = 0;\n\n  float dist = trace(ro, rd, steps);\n\n  if (dist < MAX_DIST) {\n    fragColor = vec4(vec3(clamp(float(steps) / 20.0, 0.0, 1.0)), 1.0);\n\n    return;\n  }\n\n  fragColor = vec4(vec3(0.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstcDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 124, 124, 660], [662, 662, 687, 687, 907], [909, 909, 955, 955, 1192], [1194, 1194, 1249, 1249, 1644]]}
{"id": "wstcRH", "name": "PBR Glint", "author": "xavierchermain", "description": "Shadertoy implementation of Procedural Physically based BRDF for Real-Time Rendering of Glints\nXavier Chermain (ICUBE), Basile Sauvage (ICUBE), Jean-Michel Dishler (ICUBE) and Carsten Dachsbacher (KIT)\nAccepted for Pacific Graphic 2020 and CGF", "tags": ["procedural", "brdf", "microfacet", "glint"], "likes": 58, "viewed": 2674, "published": "Public", "date": "1600433510", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright  2020 Xavier Chermain (ICUBE), Basile Sauvage (ICUBE), Jean-Michel Dishler (ICUBE), Carsten Dachsbacher (KIT)\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shadertoy implementation of\n// Procedural Physically based BRDF for Real-Time Rendering of Glints\n// Xavier Chermain (ICUBE), Basile Sauvage (ICUBE), Jean-Michel Dishler (ICUBE) and Carsten Dachsbacher (KIT)\n// Pacific Graphic 2020, CGF special issue\n// Project page: http://igg.unistra.fr/People/chermain/real_time_glint/\n\n// Dictionary is generated on the fly (we cannot use pre-computed data on Shadertoy), \n// but with a limited number of lobes (16) to achieve a reasonable frame rate.\n// For a full-featured version (WebGL), see: http://igg.unistra.fr/People/reproctex/Demos/Real_Time_Glint/\n\n//=========================================================================================================================\n//================================================== PG2020 title =========================================================\n//=========================================================================================================================\n#define PG2020W 32u\n#define PG2020H 18u\nuint[] pg2020_bitfield = uint[]( 0x0u,0x0u,0x0u,0x003e7c00u,0x00024400u,0x00327c00u,0x00220400u,0x003e0400u,0x0u,0x0u,0x30e30e0u,0x4904900u,0x49e49e0u,0x4824820u,0x31e31e0u,0x0u,0x0u,0x0u );\nbool jfig(in uint x, in uint y) {\n    uint id = x + (PG2020H-1u-y)*PG2020W;\n    if (id>=PG2020W*PG2020H) return false;\n    return 0u != (pg2020_bitfield[id/32u] & (1u << (id&31u)));\n}\n\nfloat texel(int s, int t){\n    if(s < 0 || s >= int(PG2020W) || t < 0 || t >= int(PG2020H) || jfig(uint(s), uint(t)))\n    \treturn 0.;\n    \n    return 1.;\n}\n\nfloat pg2020TriangleFilter(vec2 st){\n\tfloat s = st.x * float(PG2020W) - 0.5;\n    float t = st.y * float(PG2020H) - 0.5;\n    int s0 = int(floor(s));\n    int t0 = int(floor(t));\n    float ds = s - float(s0);\n    float dt = t - float(t0);\n    return (1. - ds) * (1. - dt) * texel(s0, t0) +\n           (1. - ds) * dt * texel(s0, t0 + 1) +\n           ds * (1. - dt) * texel(s0 + 1, t0) +\n           ds * dt * texel(s0 + 1, t0 + 1);\n}\n\n//=========================================================================================================================\n//================================================== Material parameters ==================================================\n//==================================================== Can be changed =====================================================\n//=========================================================================================================================\n// Roughness of the glinty material [0.1, 1.]\n#define ALPHA_X 0.5\n#define ALPHA_Y 0.5\n\n// Microfacet relative area [0.01, 1.]. \n// Set to 0.01 with LOGMICROFACETDENSITY set tot 5. gives sparse glints (snow, sand, sparkling rocks)\n#define MICROFACETRELATIVEAREA 1.\n\n// Logarithmic microfacet density [5., 25.]\n#define LOGMICROFACETDENSITY 14.\n\n// Maximum anisotropy of the pixel footprint (not realy usefull in this scene)\n#define MAXANISOTROPY 8.\n\n// Varnished material (add a specular lobe with a small roughness)\n# define VARNISHED true\n\n//=========================================================================================================================\n//============================================== Parameters of the dictionary =============================================\n//=========================================================================================================================\n// Roughness used during the dictionary generation\n#define ALPHA_DIC 0.5\n// Number of distributions\n// In the paper, we use 192 marginal distributions of slope\n// In shadertoy, we generate the dictionary on the fly. So we use a large number of different NDFs\n#define N 999999\n// Number of levels. In the paper : 16. In shadertoy : 8\n#define NLEVELS 8\n// Size of the tabulated marginal distributions. In the paper : 64. In shadertoy : 32\n#define DISTRESOLUTION 32\n\n\n\n//=========================================================================================================================\n//================================================ Mathematical constants =================================================\n//=========================================================================================================================\n#define PI 3.141592\n#define IPI 0.318309\n#define ISQRT2 0.707106\n\n\n\n//=========================================================================================================================\n//=============================================== Beckmann anisotropic NDF ================================================\n//==================== Shadertoy implementation : Arthur Cavalier (https://www.shadertoy.com/user/H4w0) ===================\n//========================================= https://www.shadertoy.com/view/WlGXRt =========================================\n//=========================================================================================================================\n\n//-----------------------------------------------------------------------------\n//-- Beckmann Distribution ----------------------------------------------------\nfloat p22_beckmann_anisotropic(float x, float y, float alpha_x, float alpha_y)\n{\n    float x_sqr = x*x;\n    float y_sqr = y*y;\n    float sigma_x = alpha_x * ISQRT2;\n    float sigma_y = alpha_y * ISQRT2;\n    float sigma_x_sqr = sigma_x*sigma_x;\n    float sigma_y_sqr = sigma_y*sigma_y;\n    return( \n            exp( -0.5 * ((x_sqr/sigma_x_sqr) + (y_sqr/sigma_y_sqr)) )\n    / //-------------------------------------------------------------------\n                    ( 2. * PI * sigma_x * sigma_y )\n    );\n}\n\nfloat ndf_beckmann_anisotropic(vec3 omega_h, float alpha_x, float alpha_y)\n{\n    float slope_x = - (omega_h.x/omega_h.z);\n    float slope_y = - (omega_h.y/omega_h.z);\n    float cos_theta = omega_h.z;\n    float cos_2_theta = omega_h.z * omega_h.z;\n    float cos_4_theta = cos_2_theta * cos_2_theta;\n    float beckmann_p22 = p22_beckmann_anisotropic(slope_x,slope_y,alpha_x,alpha_y);\n    return(\n                beckmann_p22\n    / //---------------------------\n                cos_4_theta\n    );\n}\n\n//=========================================================================================================================\n//======================================== Schlick approximation of Fresnel ===============================================\n//=========================================================================================================================\nvec3 fresnel_schlick(in float wo_dot_wh, in vec3 F0)\n{\n    return F0 + (1. - F0) * pow(1. - wo_dot_wh, 5.);\n}\n\n//=========================================================================================================================\n//===================================== Microfacet BRDF of Cook and Torrance 1982 =========================================\n//=========================================================================================================================\nvec3 f_specular(vec3 wo, vec3 wi)\n{\n    if(wo.z <= 0.) return vec3(0.,0.,0.);\n    if(wi.z <= 0.) return vec3(0.,0.,0.);\n    vec3 wh = normalize(wo+wi);\n    if(wh.z <= 0.) return vec3(0.,0.,0.);\n    // Local masking shadowing\n    if (dot(wo, wh) <= 0. || dot(wi, wh) <= 0.) return vec3(0.);\n    float wi_dot_wh = clamp(dot(wi,wh),0.,1.);\n\n    float D = ndf_beckmann_anisotropic(wh,0.1, 0.1);\n    // V-cavity masking shadowing\n    float G1wowh = min(1., 2. * wh.z * wo.z / dot(wo, wh));\n    float G1wiwh = min(1., 2. * wh.z * wi.z / dot(wi, wh));\n    float G = G1wowh * G1wiwh;\n    \n\tvec3 F  = fresnel_schlick(wi_dot_wh,vec3(1., 1., 1.));\n        \n    return (D * F * G) / ( 4. * wo.z );\n}\n\n//=========================================================================================================================\n//=============================================== Diffuse Lambertian BRDF =================================================\n//=========================================================================================================================\nvec3 f_diffuse(vec3 wo, vec3 wi)\n{\n    if (wo.z <= 0.)\n        return vec3(0., 0., 0.);\n    if (wi.z <= 0.)\n        return vec3(0., 0., 0.);\n\n    return vec3(0.8, 0., 0.) * IPI * wi.z;\n}\n\n//=========================================================================================================================\n//=============================================== Inverse error function ==================================================\n//=========================================================================================================================\nfloat erfinv(float x)\n{\n    float w, p;\n    w = -log((1.0 - x) * (1.0 + x));\n    if (w < 5.000000)\n    {\n        w = w - 2.500000;\n        p = 2.81022636e-08;\n        p = 3.43273939e-07 + p * w;\n        p = -3.5233877e-06 + p * w;\n        p = -4.39150654e-06 + p * w;\n        p = 0.00021858087 + p * w;\n        p = -0.00125372503 + p * w;\n        p = -0.00417768164 + p * w;\n        p = 0.246640727 + p * w;\n        p = 1.50140941 + p * w;\n    }\n    else\n    {\n        w = sqrt(w) - 3.000000;\n        p = -0.000200214257;\n        p = 0.000100950558 + p * w;\n        p = 0.00134934322 + p * w;\n        p = -0.00367342844 + p * w;\n        p = 0.00573950773 + p * w;\n        p = -0.0076224613 + p * w;\n        p = 0.00943887047 + p * w;\n        p = 1.00167406 + p * w;\n        p = 2.83297682 + p * w;\n    }\n    return p * x;\n}\n\n//=========================================================================================================================\n//================================================== Hash function ========================================================\n//================================================== Inigo Quilez =========================================================\n//====================================== https://www.shadertoy.com/view/llGSzw ============================================\n//=========================================================================================================================\n// \nfloat hashIQ(uint n)\n{\n    // integer hash copied from Hugo Elias\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float(n & 0x7fffffffU) / float(0x7fffffff);\n}\n\n//=========================================================================================================================\n//=============================================== Pyramid size at LOD level ===============================================\n//=========================================================================================================================\nint pyramidSize(int level)\n{\n    return int(pow(2., float(NLEVELS - 1 - level)));\n}\n\nfloat normalDistribution1D(float x, float mean, float std_dev) {\n    float xMinusMean = x - mean;\n    float xMinusMeanSqr = xMinusMean * xMinusMean;\n    return exp(-xMinusMeanSqr / (2. * std_dev * std_dev)) /\n           (std_dev * 2.506628);\n    // 2.506628 \\approx sqrt(2 * \\pi)\n}\n\n//=========================================================================================================================\n//========================================= Sampling from a Normal distribution ===========================================\n//=========================================================================================================================\nfloat sampleNormalDistribution(float U, float mu, float sigma)\n{\n    float x = sigma * 1.414213f * erfinv(2.0f * U - 1.0f) + mu;\n    return x;\n}\n\n//=========================================================================================================================\n//==================================== Evaluation of the i th marginal distribution P =====================================\n//========================================== with slope x and at LOD level ================================================\n//============================ Procedural version, because we cannot use data with Shadertoy ==============================\n//=========================================================================================================================\n\nfloat P_procedural(float x, int i, int level) {\n    \n    // We use even functions\n    x = abs(x);\n    // After 4 standard deviation sigma, we consider that the distribution equals zero\n    float sigma_dist_4 = 4. * ALPHA_DIC / 1.414214; // alpha_dist = 0.5 so sigma_dist \\approx 0.3535 (0.5 / sqrt(2))\n    if(x >= sigma_dist_4) return 0.;\n    \n    int nMicrofacetsCurrentLevel = int(pow(2., float(level)));\n    float density = 0.;\n    // Dictionary should be precomputed, but we cannot use memory with Shadertoy\n    // So we generate it on the fly with a very limited number of lobes\n    nMicrofacetsCurrentLevel = min(16, nMicrofacetsCurrentLevel);\n    \n    for (int n = 0; n < nMicrofacetsCurrentLevel; ++n) {\n        \n        float U_n = hashIQ(uint(i*7333+n*5741));\n        // alpha roughness equals sqrt(2) * RMS roughness\n        //     ALPHA_DIC     =   1.414214 * std_dev\n        // std_dev = ALPHA_DIC / 1.414214 \n        float currentMean = sampleNormalDistribution(U_n, 0., ALPHA_DIC / 1.414214);\n        density += normalDistribution1D(x, currentMean, 0.05) +\n                   normalDistribution1D(-x, currentMean, 0.05);\n    }\n    return density / float(nMicrofacetsCurrentLevel);\n}\n\n//=========================================================================================================================\n//=================== Spatially-varying, multiscale, rotated, and scaled slope distribution function ======================\n//================================================= Eq. 11, Alg. 3 ========================================================\n//=========================================================================================================================\nfloat P22_theta_alpha(vec2 slope_h, int l, int s0, int t0)\n{\n    \n    // Coherent index\n    // Eq. 18, Alg. 3, line 1\n    s0 *= 1 << l;\n    t0 *= 1 << l;\n\n    // Seed pseudo random generator\n    // Alg. 3, line 2\n    int rngSeed = s0 + 1549 * t0;\n\n    // Alg.3, line 3\n    float uMicrofacetRelativeArea = hashIQ(uint(rngSeed) * 13U);\n    // Discard cells by using microfacet relative area\n    // Alg.3, line 4\n    if (uMicrofacetRelativeArea > MICROFACETRELATIVEAREA)\n        return 0.f;\n\n    // Number of microfacets in a cell\n    // Alg. 3, line 5\n    float n = pow(2., float(2 * l - (2 * (NLEVELS - 1))));\n    n *= exp(LOGMICROFACETDENSITY);\n\n    // Corresponding continuous distribution LOD\n    // Alg. 3, line 6\n    float l_dist = log(n) / 1.38629; // 2. * log(2) = 1.38629\n    \n    // Alg. 3, line 7\n    float uDensityRandomisation = hashIQ(uint(rngSeed) * 2171U);\n\n    // Fix density randomisation to 2 to have better appearance\n    // Notation in the paper: \\zeta\n    float densityRandomisation = 2.;\n    \n    // Sample a Gaussian to randomise the distribution LOD around the distribution level l_dist\n    // Alg. 3, line 8\n    l_dist = sampleNormalDistribution(uDensityRandomisation, l_dist, densityRandomisation);\n\n    // Alg. 3, line 9\n    int l_disti = clamp(int(round(l_dist)), 0, NLEVELS);\n\n    // Alg. 3, line 10\n    if (l_disti == NLEVELS)\n        return p22_beckmann_anisotropic(slope_h.x, slope_h.y, ALPHA_X, ALPHA_Y);\n\n    // Alg. 3, line 13\n    float uTheta = hashIQ(uint(rngSeed));\n    float theta = 2.0 * PI * uTheta;\n\n    // Uncomment to remove random distribution rotation\n    // Lead to glint alignments with a small N\n    // theta = 0.;\n\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    \n    vec2 scaleFactor = vec2(ALPHA_X / ALPHA_DIC,\n                            ALPHA_Y / ALPHA_DIC);\n\n    // Rotate and scale slope\n    // Alg. 3, line 16\n    slope_h = vec2(slope_h.x * cosTheta / scaleFactor.x + slope_h.y * sinTheta / scaleFactor.y,\n                   -slope_h.x * sinTheta / scaleFactor.x + slope_h.y * cosTheta / scaleFactor.y);\n\n    // Alg. 3, line 17\n    float u1 = hashIQ(uint(rngSeed) * 16807U);\n    float u2 = hashIQ(uint(rngSeed) * 48271U);\n\n    // Alg. 3, line 18\n    int i = int(u1 * float(N));\n    int j = int(u2 * float(N));\n    \n    float P_i = P_procedural(slope_h.x, i, l_disti);\n    float P_j = P_procedural(slope_h.y, j, l_disti);\n\n    // Alg. 3, line 19\n    return P_i * P_j / (scaleFactor.x * scaleFactor.y);\n\n}\n\n//=========================================================================================================================\n//========================================= Alg. 2, P-SDF for a discrete LOD ==============================================\n//=========================================================================================================================\n\n// Most of this function is similar to pbrt-v3 EWA function,\n// which itself is similar to Heckbert 1889 algorithm, http://www.cs.cmu.edu/~ph/texfund/texfund.pdf, Section 3.5.9.\n// Go through cells within the pixel footprint for a given LOD l\n\nfloat P22_floorP(int l, vec2 slope_h, vec2 st, vec2 dst0, vec2 dst1)\n{\n    // Convert surface coordinates to appropriate scale for level\n    float pyrSize = float(pyramidSize(l));\n    st[0] = st[0] * pyrSize - 0.5f;\n    st[1] = st[1] * pyrSize - 0.5f;\n    dst0[0] *= pyrSize;\n    dst0[1] *= pyrSize;\n    dst1[0] *= pyrSize;\n    dst1[1] *= pyrSize;\n\n    // Compute ellipse coefficients to bound filter region\n    float A = dst0[1] * dst0[1] + dst1[1] * dst1[1] + 1.;\n    float B = -2. * (dst0[0] * dst0[1] + dst1[0] * dst1[1]);\n    float C = dst0[0] * dst0[0] + dst1[0] * dst1[0] + 1.;\n    float invF = 1. / (A * C - B * B * 0.25f);\n    A *= invF;\n    B *= invF;\n    C *= invF;\n\n    // Compute the ellipse's bounding box in texture space\n    float det = -B * B + 4. * A * C;\n    float invDet = 1. / det;\n    float uSqrt = sqrt(det * C), vSqrt = sqrt(A * det);\n    int s0 = int(ceil(st[0] - 2. * invDet * uSqrt));\n    int s1 = int(floor(st[0] + 2. * invDet * uSqrt));\n    int t0 = int(ceil(st[1] - 2. * invDet * vSqrt));\n    int t1 = int(floor(st[1] + 2. * invDet * vSqrt));\n\n    // Scan over ellipse bound and compute quadratic equation\n    float sum = 0.f;\n    float sumWts = 0.;\n    int nbrOfIter = 0;\n\n    for (int it = t0; it <= t1; ++it)\n    {\n        float tt = float(it) - st[1];\n        for (int is = s0; is <= s1; ++is)\n        {\n            float ss = float(is) - st[0];\n            // Compute squared radius and filter SDF if inside ellipse\n            float r2 = A * ss * ss + B * ss * tt + C * tt * tt;\n            if (r2 < 1.)\n            {\n                // Weighting function used in pbrt-v3 EWA function\n                float alpha = 2.;\n                float W_P = exp(-alpha * r2) - exp(-alpha);\n                // Alg. 2, line 3\n                sum += P22_theta_alpha(slope_h, l, is, it) * W_P;\n                \n                sumWts += W_P;\n            }\n            nbrOfIter++;\n            // Guardrail (Extremely rare case.)\n            if (nbrOfIter > 100)\n                break;\n        }\n        // Guardrail (Extremely rare case.)\n        if (nbrOfIter > 100)\n            break;\n    }\n    return sum / sumWts;\n}\n\n//=========================================================================================================================\n//=============================== Evaluation of our procedural physically based glinty BRDF ===============================\n//==================================================== Alg. 1, Eq. 14 =====================================================\n//=========================================================================================================================\nvec3 f_P(vec3 wo, vec3 wi, vec2 uv)\n{\n\t\n    if (wo.z <= 0.)\n        return vec3(0., 0., 0.);\n    if (wi.z <= 0.)\n        return vec3(0., 0., 0.);\n\n    // Alg. 1, line 1\n    vec3 wh = normalize(wo + wi);\n    if (wh.z <= 0.)\n        return vec3(0., 0., 0.);\n\n    // Local masking shadowing\n    if (dot(wo, wh) <= 0. || dot(wi, wh) <= 0.)\n        return vec3(0.);\n\n    // Eq. 1, Alg. 1, line 2\n    vec2 slope_h = vec2(-wh.x / wh.z, -wh.y / wh.z);\n\n    vec2 texCoord = uv;\n\n    float D_P = 0.;\n    float P22_P = 0.;\n\n    // ------------------------------------------------------------------------------------------------------\n    // Similar to pbrt-v3 MIPMap::Lookup function, http://www.pbr-book.org/3ed-2018/Texture/Image_Texture.html#EllipticallyWeightedAverage\n\n    // Alg. 1, line 3\n    vec2 dst0 = dFdx(texCoord);\n    vec2 dst1 = dFdy(texCoord);\n\n    // Compute ellipse minor and major axes\n    float dst0Length = length(dst0);\n    float dst1Length = length(dst1);\n\n    if (dst0Length < dst1Length)\n    {\n        // Swap dst0 and dst1\n        vec2 tmp = dst0;\n        dst0 = dst1;\n        dst1 = tmp;\n    }\n    float majorLength = length(dst0);\n    // Alg. 1, line 5\n    float minorLength = length(dst1);\n\n    // Clamp ellipse eccentricity if too large\n    // Alg. 1, line 4\n    if (minorLength * MAXANISOTROPY < majorLength && minorLength > 0.)\n    {\n        float scale = majorLength / (minorLength * MAXANISOTROPY);\n        dst1 *= scale;\n        minorLength *= scale;\n    }\n    // ------------------------------------------------------------------------------------------------------\n\n    // Without footprint, we evaluate the Cook Torrance BRDF\n    if (minorLength == 0.)\n    {\n        D_P = ndf_beckmann_anisotropic(wh, ALPHA_X, ALPHA_Y);\n    }\n    else\n    {\n        // Choose LOD\n        // Alg. 1, line 6\n        float l = max(0., float(NLEVELS) - 1. + log2(minorLength));\n        int il = int(floor(l));\n\n        // Alg. 1, line 7\n        float w = l - float(il);\n\n        // Alg. 1, line 8\n        P22_P = mix(P22_floorP(il, slope_h, texCoord, dst0, dst1),\n                    P22_floorP(il + 1, slope_h, texCoord, dst0, dst1),\n                    w);\n\n        // Eq. 13, Alg. 1, line 10\n        D_P = P22_P / (wh.z * wh.z * wh.z * wh.z);\n    }\n\n    // V-cavity masking shadowing\n    float G1wowh = min(1., 2. * wh.z * wo.z / dot(wo, wh));\n    float G1wiwh = min(1., 2. * wh.z * wi.z / dot(wi, wh));\n    float G = G1wowh * G1wiwh;\n\n    // Fresnel is set to one for simplicity here\n    // but feel free to use \"real\" Fresnel term\n    vec3 F = vec3(1., 1., 1.);\n\n    // Eq. 14, Alg. 1, line 11\n    // (wi dot wg) is cancelled by\n    // the cosine weight in the rendering equation\n    return (F * G * D_P) / (4. * wo.z);\n}\n\n//=========================================================================================================================\n//===================================================== Renderer ==========================================================\n//=========================================================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Light intensity\n    vec3 lightIntensity = vec3(50000.);\n    \n    // Texture position\n    vec2 uv = fragCoord/iResolution.y * 400.;\n    \n    // Vertex position\n    vec3 vertexPos = vec3(fragCoord - iResolution.xy/2., 0.);\n    \n    // Light position (varies over time)\n    float x_i = cos(iTime*0.6) * iResolution.x / 2.;\n    float y_i = cos(iTime) * iResolution.y / 2.;\n    vec3 lightPos = vec3(x_i, y_i, 100);\n    \n    // Camera position\n    vec3 cameraPos = vec3(0, 0, 100);\n    \n    // Compute normal from JFIG heightfield\n    float diff = 10.;\n    float hJFIGsm1t0 = pg2020TriangleFilter(vec2((fragCoord.x - diff)/iResolution.x, (fragCoord.y)/iResolution.y));\n    float hJFIGs1t0 = pg2020TriangleFilter(vec2((fragCoord.x + diff)/iResolution.x, (fragCoord.y)/iResolution.y));\n    float hJFIGs0tm1 = pg2020TriangleFilter(vec2((fragCoord.x)/iResolution.x, (fragCoord.y - diff)/iResolution.y));\n    float hJFIGs0t1 = pg2020TriangleFilter(vec2((fragCoord.x)/iResolution.x, (fragCoord.y + diff)/iResolution.y));\n    vec2 slope = vec2((hJFIGs1t0 - hJFIGsm1t0)/2.,\n                      (hJFIGs0t1 - hJFIGs0tm1)/2.);\n    slope *= 4.;\n    vec3 vertexNormal = vec3(-slope.x, -slope.y, 1.) / sqrt(slope.x*slope.x+slope.y*slope.y+1.);\n    \n    vec3 vertexTangent = vec3(1., 0., 0.);\n    // GramSchmidt process\n    vertexTangent = vertexTangent - (dot(vertexNormal, vertexTangent) / dot(vertexNormal, vertexNormal)) * vertexNormal;\n    vec3 vertexBinormal = cross(vertexNormal, vertexTangent);\n    \n    // Matrix for transformation to tangent space\n    mat3 toLocal = mat3(\n        vertexTangent.x, vertexBinormal.x, vertexNormal.x,\n        vertexTangent.y, vertexBinormal.y, vertexNormal.y,\n        vertexTangent.z, vertexBinormal.z, vertexNormal.z ) ;\n    \n    // Incident direction\n    vec3 wi = normalize(toLocal * normalize(lightPos - vertexPos));\n    // Observer direction\n    vec3 wo = normalize(toLocal * normalize(cameraPos));\n    \n    vec3 radiance_glint = vec3(0.);\n    vec3 radiance_diffuse = vec3(0.);\n    vec3 radiance = vec3(0.);\n    \n    float distanceSquared = distance(vertexPos, lightPos);\n    distanceSquared *= distanceSquared;\n    vec3 Li = lightIntensity / distanceSquared;\n    \n    radiance_diffuse = f_diffuse(wo, wi) * Li;\n    \n    // Call our physically based glinty BRDF\n    radiance_glint = f_P(wo, wi, uv) * Li;\n    \n    radiance = 0.33*radiance_diffuse + vec3(0.13f,0.,0.);\n        \n    radiance += 0.33*radiance_glint;\n    if(VARNISHED){\n        radiance += 0.1 * f_specular(wo, wi) * Li;\n    }\n   \n    // Gamma\n    radiance = pow(radiance, vec3(1.0 / 2.2));\n\n    // Output to screen\n    fragColor = vec4(radiance, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstcRH.jpg", "access": "shaders20k", "license": "mit", "functions": [[1770, 2373, 2406, 2406, 2556], [2558, 2558, 2584, 2584, 2713], [2715, 2715, 2751, 2751, 3143], [6080, 6240, 6320, 6320, 6744], [6746, 6746, 6822, 6822, 7241], [7243, 7615, 7669, 7669, 7724], [7726, 8098, 8133, 8133, 8785], [8787, 9159, 9193, 9193, 9345], [9347, 9719, 9742, 9742, 10542], [10544, 11168, 11190, 11233, 11368], [11370, 11742, 11770, 11770, 11825], [11827, 11827, 11891, 11891, 12108], [12110, 12482, 12546, 12546, 12626], [12628, 13249, 13296, 13330, 14446], [14448, 14944, 15004, 15061, 17425], [17800, 18044, 18114, 18180, 20184], [20186, 20682, 20719, 20719, 23415], [23417, 23789, 23846, 23869, 26501]]}
{"id": "wstczH", "name": "Move along bars", "author": "rpodeanu", "description": "Grid in sync", "tags": ["2d", "grid"], "likes": 11, "viewed": 97, "published": "Public", "date": "1600438699", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//N300820N\n//Conversion with changes of http://glslsandbox.com/e#67233.0\n//\n\nconst float PI = 03.14159;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    //st *=  1.-length(1.0*st)+sin(iTime+st.y+st.x) ;\n\tst *= PI*2.;\n    float brightness = 0.0;\n\tvec3 baseColor = vec3(0.2, 0.6, 0.8);\n\tfloat speed = iTime * 0.5;\n\t\t\n\tbrightness += st.y*0.01 / (sin(PI * st.x) * sin(PI * speed + floor(st.x)));\n    brightness += st.y*0.01 / (sin(PI * st.x*0.01) * sin(PI * speed + floor(st.x)));\n    \n    //Other options to play around with -- Just uncomment \n    \n\t//brightness += st.y*0.01 / (sin(PI * st.x*0.01) * sin(PI * speed + floor(st.x*-0.05)));\n\t//brightness += 0.02 / abs(sin(PI * st.y) * sin(PI * st.x) * sin(PI * speed + floor(st.x)));\n      \n    \n    fragColor = vec4(baseColor * brightness, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstczH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 105, 162, 162, 897]]}
{"id": "WstczX", "name": "Fract Moire", "author": "Kali", "description": "Mouse X to change pattern", "tags": ["moire"], "likes": 12, "viewed": 172, "published": "Public", "date": "1601413568", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 I)\n{\n\tO=pow(abs(1.-mod(length(ceil((I+I-(O.xy=iResolution.xy))/O.y*1e2))\n    *(5e2+iMouse.xxxx)+iTime*.2,2.)),vec4(10,20,30,0)); O.r *= 1.3;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstczX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 174]]}
{"id": "WstyDM", "name": "Value noise 2D sample", "author": "tomoe", "description": "sample code for a lecture\nL: linear interpolation\nC: Hermite interpolation\nR: 3D (position + time)\n", "tags": ["bd202009"], "likes": 1, "viewed": 87, "published": "Public", "date": "1601085743", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uint k = 0x456789abu;\nuint max32 = 0xffffffffu;\nvec2 fragCoord_;  //set as a uniform variable\nuint hash11u(uint n) {\n    n ^= (n << 24);\n    n ^= (n >> 1);\n    n ^= (n << 1);\n    return n * k;\n}\nfloat hash21(vec2 p) {\n    uint n = hash11u(uint(p.x)) + uint(p.y);\n    return float(hash11u(n)) / float(max32);\n}\nfloat vnoise21(vec2 p) {\n    vec2 i = floor(p);\n    float v00 = hash21(i);\n    float v01 = hash21(i + vec2(0.0, 1.0));\n    float v10 = hash21(i + vec2(1.0, 0.0));\n    float v11 = hash21(i + vec2(1.0, 1.0));\n    vec2 f = fract(p);\n    if (fragCoord_.x > 0.33 * iResolution.x){\n        // Hermite interpolation\n        f = f * f * (3.0 -2.0 * f); \n    }\n    return mix(mix(v00, v10, f.x), mix(v01, v11, f.x), f.y);\n}\nfloat hash31(vec3 p) {\n    uint n = hash11u(hash11u(uint(p.x)) + uint(p.y)) + uint(p.z);\n    return float(hash11u(n)) / float(max32);\n}\nfloat vnoise31(vec3 p) {\n    vec3 i = floor(p);\n    float v000 = hash31(i);\n    float v001 = hash31(i + vec3(0.0, 0.0, 1.0));\n    float v010 = hash31(i + vec3(0.0, 1.0, 0.0));\n    float v011 = hash31(i + vec3(0.0, 1.0, 1.0));\n    float v100 = hash31(i + vec3(1.0, 0.0, 0.0));\n    float v101 = hash31(i + vec3(1.0, 0.0, 1.0));\n    float v110 = hash31(i + vec3(1.0, 1.0, 0.0));\n    float v111 = hash31(i + vec3(1.0, 1.0, 1.0));\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f); // Hermite interpolation\n    float xy0 = mix(mix(v000, v100, f.x), mix(v010, v110, f.x), f.y);\n    float xy1 = mix(mix(v001, v101, f.x), mix(v011, v111, f.x), f.y);\n    return mix(xy0, xy1, f.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragCoord_ = fragCoord;\n    vec2 pos = fragCoord.xy /iResolution.x;\n    pos *= 15.0;\n    pos += iTime;\n    float v;\n    if (fragCoord.x < 0.66 * iResolution.x){\n        v = vnoise21(pos);\n    } else {\n        v = vnoise31(vec3(pos, iTime));\n    }\n    fragColor = vec4(vec3(v), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstyDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 94, 116, 116, 194], [195, 195, 217, 217, 309], [310, 310, 334, 334, 724], [725, 725, 747, 747, 860], [861, 861, 885, 885, 1540], [1542, 1542, 1597, 1597, 1886]]}
{"id": "wstyRB", "name": "Ray vs Support Function", "author": "encypruon", "description": "My first public post on Shadertoy!\n\nIf someone could answer one or more of the questions in the source code, that'd be great.", "tags": ["raycast", "minkowski", "mpr", "hull", "gjk", "supportfunction"], "likes": 2, "viewed": 199, "published": "Public API", "date": "1601302826", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nThis shader uses 2D-GJK to test if a ray intersects the\nshape described by a support function. On intersection\nGJK returns a triangle inside the shape. Every corner of\nthe triangle is on the surface. The triangle is then\n\"refined\" iteratively in order to find a triangle that\nis as close as possible to the point of intersection.\nThe resulting triangle is used to estimate depth and\nnormal of the intersection.\n\nThe refining process is probably similar to MPR, but I'm\nnot quite sure since I haven't been able to get my hands\non the graphics gems book.\n\nThis might be useful for (continuous) collision detection.\n\nQuestions:\n- With few refining iterations estimated normals\n\tare completely wrong in some places, seemingly\n\tat random. Why is this and is there a better\n\tway to circumvent this than using more iterations?\n- What other approaches are there to this problem?\n- Is there a name for this algorithm?\n\n*/\n\nconst float PI = 3.14159;\n\nvec2 rot90(vec2 x)\n{\n    return vec2(-x.y, x.x);\n}\n\nmat3 rot;\nmat3 rotInv;\nvec3 offset;\nfloat time;\n\nvec3 supMax(vec3 d, vec3 a, vec3 b)\n{\n    return dot(d,a) > dot(d,b) ? a : b;\n}\n\nvec3 supNgon(vec3 d, float n)\n{\n\n    float a = atan(d.y, d.x);\n    float f = PI * 2. / n;\n    a = (floor(a/f)+.5)*f;\n    return vec3(cos(a), sin(a), .0);\n}\n    \n\n\n// Support function. Returns point furthest in x direction\nvec3 support(vec3 x)\n{\n    const float n = 4.;\n    int tp = int(fract(time/n) * n);\n    //tp = 3;\n    vec3 res;\n   \tx = rot * x;\n    \n    // A bunch of shapes:\n    \n    if (tp == 0) // Convex hull of triangle, pentagon and circle\n   \t\tres = supMax(\n            x,\n            supMax(\n                x,\n                supNgon(x, 3.) * .5 + vec3(.0,.0,.5), // triangle in xy-plane\n                supNgon(x, 5.) * .5 + vec3(.0,.0,.0) // pentagon in xy-plane\n        \t),\n            vec3(0., normalize(x.yz)*.2 + vec2(0.,-.3)) // circle in yz-plane\n        );\n    else if (tp == 1) // cube\n        res = sign(x)*.4;\n   \telse if (tp == 2)\n        res = supMax( // Hull of circle and square\n            x,\n            vec3(normalize(x.xy)*.2, .5), // circle in xy-plane\n            vec3(sign(x.xy)*.3, -.5) // square in xy-plane\n        );\n    else if (tp == 3) // Cube with rounded corners/edges\n        res =\n            sign(x)*.3 + // cube\n            normalize(x)*.2; // sphere\n    \n    return rotInv * res + offset;\n}\n\n\n// Casts ray in -z direction, estimates depth and normal\nbool rayVsSupport(out float depth, out vec3 normal)\n{\n    // abcd is simplex, dir is direction\n    // Tris should be CCW in xy-plane\n    vec3 a, b, c, d, dir, tmp;   \n    \n    // 2D GJK in xy-plane\n    \n    // Find any support point\n    a = support(vec3(1., 0., 0.));\n    if (a.x <= 0.)\n        return false;\n    \n    // Construct line to support point in opposite direction\n    b = support(vec3(-a.xy, 0.));\n    if (dot(-a.xy, b.xy) <= 0.)\n        return false;\n    \n    // Construct triangle with third support point\n    dir = vec3(rot90(b.xy-a.xy), 0.);\n    if (dot(dir.xy, a.xy) >= 0.)\n    {\n        dir.xy *= -1.;\n        tmp = a; a = b; b = tmp;\n    }\n    c = support(dir);\n    if (dot(c.xy, dir.xy) <= 0.)\n        return false;\n    \n    for (int i = 0;; ++i)\n    {\n        // No intersection found?\n        if (i == 6) return false;\n        \n        // Select side of triangle that has origin on outside\n        if (dot(dir.xy = rot90(c.xy-a.xy), c.xy) < 0.)\n            b = c;\n        else if (dot(dir.xy = rot90(b.xy-c.xy), c.xy) < 0.)\n            a = c;\n        else break; // Origin in triangle -> intersection!\n        \n        // Construct new triangle on chosen side\n        c = support(dir);    \n        if (dot(c.xy, dir.xy) <= 0.)\n            return false;\n    }\n    \n    // Refine triangle to get it close to the intersection point\n    // This is probably similar to MPR.\n    \n    // More iterations => fewer poorly estimated normals\n    //for (int i = 0; i < int(fract(time)*16.); ++i)\n    for (int i = 0; i < 20; ++i)\n    {\n\t\t// Find support in direction of triangle normal\n        // Results in tetraeder abcd\n        dir = normalize(cross(b-a, c-a));\n        d = support(dir);\n        \n        // Stop when close enough\n        // Lower threshold decreases precision but doesn't\n        // \tappear to increase number of \"outliers\"\n        if (dot(dir, d) - dot(dir, a) < 0.001)\n            break;\n\n        // xd = origin left of xd line\n        bool ad = dot(rot90(d.xy-a.xy), d.xy) > 0.;\n        bool bd = dot(rot90(d.xy-b.xy), d.xy) > 0.;\n        bool cd = dot(rot90(d.xy-c.xy), d.xy) > 0.;\n\t\t\n        // Choose triangle that intersects z-axis furthest in z direction\n        if (ad && !bd) c = d;\n        else if (bd && !cd) a = d;\n        else if (cd && !ad) b = d;\n        else break; // Should not happen\n\n\t}\n    \n    // Checks if triangle is very \"thin\"\n    // Uncommenting this appears to drop all poorly estimated normals\n    // but also some other parts\n    // if (length(cross(b-a, c-a))*24. < pow(length(b-a) + length(c-b) + length(a-c), 2.))\n    //    return false;\n    \n    normal = normalize(cross(b-a, c-a));\n    depth = a.z + dot(a.xy, normal.xy)/normal.z;\n    return true;\n}\n\nmat3 rotAx(int ax, float a)\n{\n    mat3 m = mat3(\n    \t1., 0., 0.,\n        0., 1., 0.,\n        0., 0., 1.\n    );\n    ax = (ax + 1) % 3;\n   \tint ax2 = (ax + 1) % 3;\n    float c = cos(a), s = sin(a);\n    m[ax][ax] = c; m[ax2][ax] = s;\n    m[ax][ax2] = -s; m[ax2][ax2] = c;\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    rot = rotAx(0, iTime*0.85) * rotAx(1, iTime*0.61);\n    rotInv = inverse(rot);\n    \n    offset = vec3((fragCoord-iResolution.xy*.5)*1.5/iResolution.y, 0.);\n    \n    time = iTime/1.;\n    \n    float depth = 0.;\n    vec3 normal;\n    if (rayVsSupport(depth, normal))\n    \tfragColor = fragCoord.x > (iMouse.x == 0. ? iResolution.x*.5 : iMouse.x) ? //fract(time) < .5 ?\n        \tvec4(normal.x*.5+.5, normal.y*.5+.5, .5, 1.0)\n        \t: vec4(vec3(pow(depth*.75+.5, 2.)), 1.0);\n   \telse\n        fragColor = vec4(vec3(0.), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstyRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 945, 965, 965, 995], [1046, 1046, 1083, 1083, 1125], [1127, 1127, 1158, 1158, 1282], [1290, 1349, 1371, 1371, 2369], [2372, 2429, 2482, 2561, 5143], [5145, 5145, 5174, 5174, 5430], [5432, 5432, 5489, 5489, 6015]]}
{"id": "wstyRS", "name": "\"Clouds\" + vortex", "author": "athibaul", "description": "Fork of \"Clouds\" by iq.\n[url]https://www.shadertoy.com/view/XslGRr[/url]\nRaymarching some fbm.\nAdded a vortex distortion.", "tags": ["procedural", "3d", "raymarching", "volumetric", "vortex"], "likes": 32, "viewed": 443, "published": "Public", "date": "1601204271", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Clouds\" by iq\n// https://www.shadertoy.com/view/XslGRr\n\n// Created by inigo quilez - iq/2013\n// Modified by Alexis THIBAULT - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// I simply modified the map() function, so that it evaluates at rotating points.\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n#if 1\n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0,(uv+0.5)/256.0,0.0).yx;\n#else\n    ivec3 q = ivec3(p);\n\tivec2 uv = q.xy + ivec2(37,239)*q.z;\n\n\tvec2 rg = mix(mix(texelFetch(iChannel0,(uv           )&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,0))&255,0),f.x),\n\t\t\t\t  mix(texelFetch(iChannel0,(uv+ivec2(0,1))&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,1))&255,0),f.x),f.y).yx;\n#endif    \n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nvec4 qmul( vec4 a, vec4 b )\n{\n    // Quaternion multiplication\n    return vec4(a.x*b.x - dot(a.yzw,b.yzw),\n                a.x*b.yzw + b.x*a.yzw + cross(a.yzw,b.yzw));\n}\n\nvec3 rot( vec3 p, vec3 axis, float angle )\n{\n    // Rotate a vector around a given (normalized) axis\n    // Way too many operations probably, but this should work\n    vec2 cs = cos(angle + vec2(0,3.1415926*0.5));\n    vec4 q = vec4(cs.x, cs.y*axis);\n    vec4 qi = vec4(q.x, -q.yzw);\n    vec4 pp = vec4(0,p);\n    return qmul(qmul(q, pp), qi).yzw;\n}\n\n\nfloat mapt( in vec3 p, float time )\n{\n\t//vec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n    \n    // Add a vortex!\n    vec3 q0 = p;\n    vec3 vcenter = vec3(0); // Vortex center\n    vec3 axis = vec3(0,1,0); // Vortex axis (should be normalized)\n    float r0 = 2.0; // Radius at which velocity is maximal\n    float h = dot(q0-vcenter, axis);\n    float r2 = dot(q0-vcenter,q0-vcenter) - h*h; // Distance of p from the axis\n    float theta = time/(r0*r0 + r2); // Rotation angle\n    q0 = vcenter + rot(q0-vcenter, axis, theta);\n    vec3 q = q0;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q );\n\treturn clamp( 1.5 - q0.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nfloat map( in vec3 p )\n{\n    float scale = 10.;\n    float t = iTime/scale;\n    // Repeat animation to avoid over-winding the vortes\n    float m1 = mapt(p, scale*fract(t)+4.);\n    float m2 = mapt(p, scale*fract(t+0.5)+4.);\n    // Smoothly mix between two evaluations to avoid jumps\n    float proportion = 2.*abs(fract(t)-0.5);\n    float m = mix(sqrt(m1),sqrt(m2),proportion);\n    return m*m;\n}\n\nvec3 sundir = normalize( vec3(-1.0,0.0,-1.0) );\n\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in ivec2 px )\n{\n\tvec4 sum = vec4(0.0);\n\n\tfloat t = 0.0;//0.05*texelFetch( iChannel0, px&255, 0 ).x;\n    for(int i=0; i<256; i++)\n    {\n       vec3 pos = ro + t*rd;\n       if( /*pos.y<-3.0 || pos.y>2.0 ||*/ sum.a>0.99 ) break;\n       float den = map( pos );\n       if( den>0.01 )\n       {\n         float dif = clamp((den - map(pos+0.3*sundir))/0.6, 0.0, 1.0 );\n         vec3  lin = vec3(0.65,0.7,0.75)*1.4 + vec3(1.0,0.6,0.3)*dif;\n         vec4  col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den );\n         col.xyz *= lin;\n         col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.005*t*t) );\n         col.w *= 0.4;\n         \n         col.rgb *= col.a;\n         sum += col*(1.0-sum.a);\n       }\\\n       t += max(0.05,0.01*t);\\\n    }\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( in vec3 ro, in vec3 rd, in ivec2 px )\n{\n    // background sky     \n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n\tcol += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col, px );\n    col = col*(1.0-res.w) + res.xyz;\n    \n    // sun glare    \n\tcol += 0.2*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n\n    return vec4( col, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // camera\n    //vec3 ro = 4.0*normalize(vec3(sin(3.0*m.x), 0.4*m.y, cos(3.0*m.x)));\n    vec3 ro = vec3(0,1.,-2);\n\tvec3 ta = vec3(0,-.5,0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n    \n    fragColor = render( ro, rd, ivec2(fragCoord-0.5) );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragColor = render( fragRayOri, fragRayDir, ivec2(fragCoord-0.5) );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstyRS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[231, 314, 340, 340, 895], [897, 897, 926, 959, 1066], [1068, 1068, 1112, 1230, 1414], [1417, 1417, 1454, 1521, 2165], [2167, 2167, 2191, 2191, 2559], [2611, 2611, 2680, 2680, 3447], [3449, 3449, 3501, 3501, 3678], [3680, 3680, 3732, 3759, 4131], [4133, 4133, 4190, 4190, 4598], [4600, 4600, 4694, 4694, 4768]]}
{"id": "Wstyzj", "name": "Lemniscate of Bernoulli", "author": "StrangerintheQ", "description": "Lemniscate of Bernoulli", "tags": ["bernoulli"], "likes": 3, "viewed": 77, "published": "Public", "date": "1601296743", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n\n    uv.x *= iResolution.x/iResolution.y;\n    if (uv.x > 0.0) uv.y = -uv.y;\n\n    float r = 0.5*cos(2.0*atan(uv.y, uv.x));\n    float d = dot(uv, uv);\n    float s = 0.003/sqrt(d);\n    float c = 1.0 - smoothstep(r, r+s, d)\n                  - smoothstep(r, r-s, d);\n    \n    fragColor = vec4(c, c, c, 1.0);\n\n    vec3 power = vec3(0.5, 0.2, 0.33);\n    for (float i = 0.0; i < 1.0; i += 0.05) {\n        float t = 1.0 + iTime*1.5 + i;\n        vec2 uv2 = uv + vec2(cos(t), sin(t)) * sqrt(r);\n        float size = (0.0001+i/25.0)/pow(d, 0.2);\n        vec3 color = vec3(sin(t*4.0), cos(t*3.0), sin(t*7.0));\n        c = smoothstep(size, 0.0, sqrt(dot(uv2, uv2)));\n        fragColor += vec4(power * (1.0 + color) * c, 1.);   \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wstyzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 824]]}
{"id": "Wt2BDD", "name": "Inrcia 2020 background", "author": "psenough", "description": "remixing flopine's Doodling with Valden shadertoy https://www.shadertoy.com/view/wl3XW8", "tags": ["glow"], "likes": 5, "viewed": 102, "published": "Public", "date": "1599165924", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// original by Flopine\n// tweaked by ps\n\n#define hr vec2(1., sqrt(3.))\n#define PI 3.141592\n#define TAU (2.*PI)\n#define time (iTime*0.005)\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(12.4,18.4)))*1245.4);}\n\nmat2 rot (float a)\n{return mat2 (cos(a),sin(a),-sin(a),cos(a));}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat fractal (vec3 p)\n{\n    float size = 1.;\n    float d = box(p,vec3(size));\n    for (float i=0.; i<5.; i++)\n    {\n        float ratio = i/5.;\n        p.yz *= rot(time);\n        mo(p.xz, vec2(1.5+ratio));\n        mo(p.xy, vec2(0.5+ratio));\n        p.xy *= rot(time+ratio);\n        size -= ratio*1.3;\n        d = stmin(d,box(p*0.8,vec3(size*0.9)),1., 3.);\n    }\n    return d;\n}\n\nfloat g1 = 0.;\nfloat SDF (vec3 p)\n{\n    float d = fractal(p);\n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float dither = hash21(uv);\n    \n    vec3 ro = vec3(0.,0.,-10.),\n        p = ro,\n        rd = normalize(vec3(uv,1.)),\n        col = vec3(0.);\n    \n    float shad = 0.;\n    \n    for (float i=0.; i<64.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            shad = i/64.;\n            break;\n        }\n        d *= 0.8+dither*0.08;\n        p += d*rd;\n    }\n    \n    col = vec3(0.2,length(uv*0.3),0.6)*g1*0.1;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2BDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 139, 162, 162, 212], [214, 214, 234, 234, 278], [280, 280, 312, 312, 359], [361, 361, 411, 411, 515], [517, 517, 545, 545, 632], [634, 634, 658, 658, 1012], [1029, 1029, 1049, 1049, 1116], [1118, 1118, 1175, 1175, 1730]]}
{"id": "wt2Bzc", "name": "Misty Flight", "author": "dr2", "description": "Riding the thermals", "tags": ["cloud", "landscape", "fog", "aircraft", "fly"], "likes": 7, "viewed": 301, "published": "Public API", "date": "1599550684", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Misty Flight\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv3 (vec3 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define VAR_ZERO min (iFrame, 0)\n\nmat3 flyerMat[2], flMat;\nvec3 qHit, flyerPos[2], flPos, trkA, trkF, sunDir, noiseDisp;\nfloat dstFar, tCur, fogFac;\nint idObj;\nbool loRes;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GrndHt (vec2 p)\n{\n  mat2 qRot;\n  vec2 q;\n  float f, a, s;\n  q = 0.1 * p;\n  qRot = 2. * mat2 (0.8, -0.6, 0.6, 0.8);\n  a = 1.;\n  f = 0.;\n  s = 0.;\n  for (int j = 0; j < 6; j ++) {\n    f += a * Noisefv2 (q);\n    s += a;\n    a *= 0.5;\n    q *= qRot;\n    if (loRes && j == 3) break;\n  }\n  return 8. * f / s;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.2, 0.8 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, szFac;\n  szFac = 0.25;\n  dMin = dstFar / szFac;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    q = flyerMat[k] * (p - flyerPos[k]) / szFac;\n    q.xy = Rot2Cs (vec2 (abs (q.x) + 0.2, q.y), sin (- pi / 6. + vec2 (0.5 * pi, 0.)));\n    d = max (PrRoundBoxDf (vec3 (Rot2Cs (q.xz, sin (- pi / 6. + vec2 (0.5 * pi, 0.))),\n       q.y).xzy, vec3 (0.8, 0., 1.), 0.015), -0.8 - q.z);\n    DMINQ (1 + k);\n  }\n  return szFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat FrAbsf (float p)\n{\n  return abs (fract (p) - 0.5);\n}\n\nvec3 FrAbsv3 (vec3 p)\n{\n  return abs (fract (p) - 0.5);\n}\n\nfloat TriNoise3d (vec3 p)\n{   // adapted from nimitz's \"Oblivion\"\n  vec3 q;\n  float a, f;\n  a = 1.;\n  f = 0.;\n  q = p;\n  for (int j = 0; j < 4; j ++) {\n    p += FrAbsv3 (q + FrAbsv3 (q).yzx);\n    p *= 1.2;\n    f += a * (FrAbsf (p.x + FrAbsf (p.y + FrAbsf (p.z))));\n    q = 2. * q + 0.2;\n    a *= 0.7;\n  }\n  return f;\n}\n\nfloat FogDens (vec3 p)\n{\n  return 0.3 * fogFac * TriNoise3d (0.1 * (p + noiseDisp)) * (1. - smoothstep (8., 15., p.y));\n}\n\nvec3 FogCol (vec3 col, vec3 ro, vec3 rd, float dHit)\n{  // adapted from \"Sailing Home\"\n  float s, ds, f, fn;\n  s = 2.;\n  ds = 0.5;\n  fn = FogDens (ro + s * rd);\n  for (int j = VAR_ZERO; j < 20; j ++) {\n    s += ds;\n    f = fn;\n    fn = FogDens (ro + (s + 0.5 * ds * Hashfv3 (16. * rd)) * rd);\n    col = mix (col, vec3 (0.9, 0.9, 0.85) * (1. - clamp (f - fn, 0., 1.)),\n       min (f * smoothstep (0.9 * s, 2. * s, dHit), 1.));\n    if (s > dHit) break;\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, roo, skyCol;\n  float dstGrnd, dstObj;\n  noiseDisp = 0.02 * tCur * vec3 (-1., 0., 1.) + 0.5 * sin (vec3 (0.2, 0.1, 0.3) * pi * tCur);\n  fogFac = 0.2 + 0.8 * smoothstep (0.1, 0.4, 0.5 - abs (mod (0.05 * tCur, 1.) - 0.5));\n  roo = ro;\n  dstGrnd = GrndRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  skyCol = vec3 (0.5, 0.6, 0.9) - rd.y * 0.2 * vec3 (1., 0.5, 1.) +\n     0.2 * vec3 (1., 0.6, 0.1) * pow (clamp (dot (sunDir, rd), 0., 1.), 32.);\n  if (min (dstObj, dstGrnd) < dstFar) {\n    if (dstObj < dstGrnd) {\n      ro += dstObj * rd;\n      col = mix (((idObj == 1) ? vec3 (1., 0., 0.) : vec3 (0., 0., 1.)), vec3 (1.),\n         step (0.02, abs (abs (qHit.x) - 0.65)));\n      col = mix (col, vec3 (1., 1., 0.), step (0.8, qHit.z));\n      vn = ObjNf (ro);\n      col = col * (0.2 + 0.2 * max (- dot (vn, sunDir), 0.) + 0.8 * max (dot (vn, sunDir), 0.)) +\n         0.2 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    } else if (dstGrnd < dstFar) {\n      ro += dstGrnd * rd;\n      vn = GrndNf (ro);\n      vn = VaryNf (16. * ro, vn, 1.);\n      col = mix (vec3 (0.5, 0.8, 0.4), vec3 (0.6, 0.6, 0.65), smoothstep (2., 6., ro.y)) *\n         (0.7 + 0.3 * Fbm2 (2. * ro.xz));\n      col *= 0.4 + 0.6 * max (dot (vn, sunDir), 0.);\n    }\n    col = mix (vec3 (0.5, 0.6, 0.9), col,\n       exp (- 2. * clamp (5. * (min (dstGrnd, dstObj) / dstFar - 0.8), 0., 1.)));\n  } else col = skyCol;\n  col = FogCol (col, roo, rd, min (dstGrnd, dstObj));\n  return col;\n}\n\nvec3 TrkPath (float t)\n{\n  return vec3 (dot (trkA, sin (trkF * t)), 0., t);\n}\n\nvec3 TrkVel (float t)\n{\n  return vec3 (dot (trkF * trkA, cos (trkF * t)), 0., 1.);\n}\n\nvec3 TrkAcc (float t)\n{\n  return vec3 (dot (trkF * trkF * trkA, - sin (trkF * t)), 0., 0.);\n}\n\nvoid FlyerPM (float t)\n{\n  vec3 vel, va, flVd;\n  vec2 cs;\n  float oRl;\n  flPos = TrkPath (t);\n  vel = TrkVel (t);\n  va = cross (TrkAcc (t), vel) / length (vel);\n  flVd = normalize (vel);\n  oRl = 2. * length (va) * sign (va.y);\n  cs = sin (oRl + vec2 (0.5 * pi, 0.));\n  flMat = mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.) *\n     mat3 (flVd.z, 0., flVd.x, 0., 1., 0., - flVd.x, 0., flVd.z);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, flyVel, vDir, hSum, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.45 * pi * mPtr.y;\n  }\n  flyVel = 1.;\n  trkA = vec3 (1.9, 2.9, 4.3);\n  trkF = vec3 (0.23, 0.17, 0.13);\n  vDir = sign (0.5 * pi - abs (az));\n  loRes = true;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    t = flyVel * tCur + vDir * (2. + 3. * float (k));\n    FlyerPM (t);\n    flyerMat[k] = flMat;\n    flyerPos[k] = flPos;\n    hSum = 0.;\n    for (float j = 0.; j < 5.; j ++) hSum += GrndHt (TrkPath (t + 0.5 * vDir * (j - 1.)).xz);\n    flyerPos[k].y = 6. + hSum / 5.;\n  }\n  t = flyVel * tCur;\n  FlyerPM (t);\n  ro = flPos;\n  hSum = 0.;\n  for (float j = 0.; j < 5.; j ++) hSum += GrndHt (TrkPath (t + 0.5 * (j - 1.)).xz);\n  ro.y = 6. + hSum / 5.;\n  loRes = false;\n  vuMat = StdVuMat (el, az);\n  zmFac = 3.;\n  dstFar = 100.;\n  sunDir = normalize (vec3 (1., 1.5, -1.));\n  rd = vuMat * (normalize (vec3 (uv, zmFac)) * flMat);\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2Bzc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 643, 666, 666, 953], [955, 955, 989, 989, 1469], [1471, 1471, 1493, 1493, 1632], [1634, 1634, 1656, 1656, 2101], [2103, 2103, 2136, 2136, 2319], [2321, 2321, 2342, 2342, 2597], [2599, 2599, 2623, 2623, 2657], [2659, 2659, 2682, 2682, 2716], [2718, 2718, 2745, 2783, 3036], [3038, 3038, 3062, 3062, 3159], [3161, 3161, 3215, 3247, 3631], [3633, 3633, 3668, 3668, 5133], [5135, 5135, 5159, 5159, 5212], [5214, 5214, 5237, 5237, 5298], [5300, 5300, 5323, 5323, 5393], [5395, 5395, 5419, 5419, 5793], [5795, 5795, 5851, 5851, 7095], [7097, 7097, 7143, 7143, 7190], [7192, 7192, 7228, 7228, 7434], [7436, 7436, 7466, 7466, 7579], [7581, 7581, 7612, 7612, 7676], [7710, 7710, 7734, 7734, 7799], [7801, 7801, 7825, 7825, 7937], [7939, 7939, 7964, 7964, 8150], [8152, 8152, 8173, 8173, 8328], [8330, 8330, 8359, 8359, 8571], [8573, 8573, 8612, 8612, 8792]]}
{"id": "Wt2BzK", "name": "original-14472.0-v2", "author": "jorge2017a1", "description": "original-14472.0-v2\n//Autor desconocido---unknown author", "tags": ["original144720v2"], "likes": 9, "viewed": 95, "published": "Public", "date": "1599355828", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Autor desconocido---unknown author\n\nconst vec3 COLOR_LINE = vec3(0x77, 0xB0, 0xE0) / 255.0;\nconst vec3 COLOR_MANELINE = vec3(0x1E, 0x98, 0xD3) / 255.0;\nconst vec3 COLOR_BODY = vec3(0x9E, 0xDB, 0xF9) / 255.0;\nconst vec3 COLOR_MANE1 = vec3(0xEE, 0x41, 0x44) / 255.0;\nconst vec3 COLOR_MANE2 = vec3(0xF3, 0x70, 0x33) / 255.0;\nconst vec3 COLOR_MANE3 = vec3(0xFD, 0xF6, 0xAF) / 255.0;\nconst vec3 COLOR_MANE4 = vec3(0x62, 0xBC, 0x4D) / 255.0;\nconst vec3 COLOR_MANE5 = vec3(0x67, 0x2F, 0x89) / 255.0;\nconst vec3 COLOR_EYEBROW = vec3(0x00, 0x00, 0x00) / 255.0;\nconst vec3 COLOR_IRIS1 = vec3(0xC6, 0x00, 0x6F) / 255.0;\nconst vec3 COLOR_IRIS2 = vec3(0x46, 0x00, 0x25) / 255.0;\nconst vec3 COLOR_BLACK = vec3(0x00, 0x00, 0x00) / 255.0;\nconst vec3 COLOR_WHITE = vec3(0xFF, 0xFF, 0xFF) / 255.0;\n\nconst float eps=0.0001;\n\nbool line(vec2 p, vec2 a, vec2 b)\n{\n\treturn (p.x - a.x) * (a.y - b.y) > (p.y - a.y) * (a.x - b.x);\n}\n\nbool circle(vec2 p, vec2 a, float r)\n{\n\treturn (p.x - a.x) * (p.x - a.x) + (p.y - a.y) * (p.y - a .y) > r * r;\n    \n}\n\nbool ellipse(vec2 p, vec2 a, vec2 r)\n{\n\t//return (p.x - a.x) * (p.x - a.x) / r.x / r.x + (p.y - a.y) * (p.y - a .y) / r.y / r.y > 1.0;\n    \n    p = (p-a)/r ;\n\treturn dot(p,p) > 1.0;\n    //return smoothstep ( 1.0-eps, 1.0+eps, dot(p,p) )> 1.0;\n\t\n    \n\n}\n\n\nvec2 m;\n\nbool ear(inout vec3 c, vec2 p)\n{\t\n\tfloat off;\n\tif(mod((iTime/3.14), 5.)<4.5)\n\t\toff = 0.;\n\telse\n\t\toff = sin(iTime*15.);\n\t\n\tbool A = circle(p-off*8., vec2(638, 664), 362.);\n\tbool B = circle(p-off*8., vec2(1075, 641), 323.);\n\tbool C = circle(p-off*8., vec2(646, 708), 378.);\n\tif(!A && !B && !C)\n\t{\n\t\tbool D = circle(p-off*8., vec2(637, 662), 345.);\n\t\tbool E = circle(p-off*8., vec2(1109, 588), 363.);\n\t\tbool F = circle(p-off*8., vec2(651, 692), 269.);\n\t\tbool G = circle(p-off*8., vec2(395, 732), 516.);\n\t\tif(D || E || (!F && G))\n\t\t\tc = COLOR_LINE;\n\t\telse\n\t\t\tc = COLOR_BODY;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool mane(inout vec3 c, vec2 p)\n{\tfloat off = (sin(iTime*10.)+.5)*10.;\n\tbool A = circle(p+off, vec2(434, 460), 514.);\n\tbool B = circle(p+off*.95, vec2(254, 110), 903.);\n\tbool C = circle(p+off*.90, vec2(384, 228), 668.);\n\tbool D = circle(p+off*.85, vec2(475, 505), 425.);\n\tbool E = circle(p+off*.80, vec2(513, 281), 536.);\n\tbool F = circle(p+off*.30, vec2(777, 435), 360.);\n\tbool G = circle(p+off*.20, vec2(915, 174), 554.);\n\tbool H = circle(p+off*.65, vec2(659, 444), 536.);\n\tbool I = circle(p+off*.60, vec2(-201, 601), 337.);\n\tbool J = line(p+off*.55, vec2(-253, 218), vec2(176, 590));\n\tbool K = circle(p+off*.20, vec2(-164, 1212), 882.);\n\tbool L = circle(p+off*.45, vec2(650, 764), 80.); // lol weird\n\tif(!A && !B && (C || (!D && E) || (!F && G) || (!H || (I && !J)) && !K) || !L)\n\t{\n\t\tbool M = circle(p+off, vec2(422, 434), 518.);\n\t\tbool N = circle(p+off*.9, vec2(372, 261), 647.);\n\t\tbool O = circle(p+off*.8, vec2(491, 499), 425.);\n\t\tbool P = circle(p+off*.7, vec2(395, 377), 402.);\n\t\tbool Q = circle(p+off*.6, vec2(790, 454), 352.);\n\t\tbool R = circle(p+off*.5, vec2(891, 216), 527.);\n\t\tbool S = circle(p+off*.4, vec2(680, 453), 536.);\n\t\tbool T = circle(p+off*.3, vec2(-217, 1332), 992.);\n\t\tbool U = circle(p+off*.2, vec2(-150, 586), 305.);\n\t\tbool V = line(p+off*.1, vec2(280, 404), vec2(119, 566));\n\t\tif((!M && N) || ((!O && P || !Q && !M) && R) || (!S && !M && !T) || (U && !T && V))\n\t\t{\n\t\t\tif(circle(p, vec2(491, 84)-off*.5, 764.))\n\t\t\t\tc = COLOR_MANE1;\n\t\t\telse\n\t\t\t\tif(circle(p, vec2(686, 204)-off*.2, 576.))\n\t\t\t\t\tc = COLOR_MANE2;\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_MANE3;\n\t\t}\n\t\telse\n\t\t\tc = COLOR_MANELINE;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool mane2(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(607, 464), 306.);\n\tbool B = circle(p, vec2(777, 485), 339.);\n\tbool C = circle(p, vec2(1181, -127), 463.);\n\tbool D = circle(p, vec2(-433, 198), 1442.);\n\tbool E = line(p, vec2(554, -80), vec2(1055, -80));\n\tif((A && !B || !C) && !D && E)\n\t{\n\t\tbool F = circle(p, vec2(613, 461), 319.);\n\t\tbool G = circle(p, vec2(769, 486), 323.);\n\t\tbool H = circle(p, vec2(1195, -123), 454.);\n\t\tbool I = circle(p, vec2(288, 485), 691.);\n\t\tbool J = circle(p, vec2(122, 278), 864.);\n\t\tif((F && !G || !H) && !I && !J)\n\t\t\tc = COLOR_MANE4;\n\t\telse\n\t\t{\n\t\t\tbool K = circle(p, vec2(388, 235), 607.);\n\t\t\tbool L = circle(p, vec2(416, 87), 570.);\n\t\t\tif(K && !L)\n\t\t\t\tc = COLOR_MANE5;\n\t\t\telse\n\t\t\t\tc = COLOR_MANELINE;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool face(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(588, 396), 357.);\n\tbool B = line(p, vec2(325, 74), vec2(887, 122));\n\tbool C = ellipse(p, vec2(489, 237), vec2(287, 166));\n\tbool D = circle(p, vec2(209, 437), 163.);\n\tif(!A && B || !C && D)\n\t{\n\t\tbool E = ellipse(p, vec2(536, 253), vec2(315, 170));\n\t\tbool F = circle(p, vec2(500, 921), 828.);\n\t\tbool G = circle(p, vec2(220, 367), 110.);\n\t\tbool H = line(p, vec2(201, 454), vec2(658, 108));\n\t\tbool I = line(p, vec2(237, 115), vec2(363, 238));\n\t\tbool J = ellipse(p, vec2(283, 204), vec2(68, 57));\n\t\tbool K = ellipse(p*(sin(iTime/1.75)/85.+1.), vec2(253, 192), vec2(102, 70));\n\t\tbool L = circle(p, vec2(285, 228), 19.);\n\t\tbool M = circle(p, vec2(281, 236), 19.);\n\t\tif((!E && !F && G || H) && (I || !J || K) && (L || !M))\n\t\t\tc = COLOR_BODY;\n\t\telse\n\t\t\tc = COLOR_LINE;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool eye1(inout vec3 c, vec2 p, vec2 off)\n{\t\n\t\t\n\t// skewed ellipse please ignore\n#define SQR(q) ((q) * (q))\n\tbool A = SQR((p.x - 590.0) / 150.0 - (p.y - 378.0) / 900.0) + SQR((p.y - 378.0) / 180.0) < 1.0;\n\tif(A)\n\t{\n\t\tbool B = SQR((p.x - 593.0) / 149.0 - (p.y - 382.0) / 900.0) + SQR((p.y - 361.0) / 180.0) < 1.0;\n\t\tif(B)\n\t\t{\n\t\t\tvec2 d = vec2(0.0, 0.0) - vec2(580, 360);\n\t\t\tif(length(d) > 60.0)\n\t\t\t   d = d / length(d) * 60.0;\n\t\t\tbool C = ellipse(p-off*50., vec2(580, 360) + d, vec2(112, 162));\n\t\t\tif(C)\n\t\t\t\tc = COLOR_WHITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool D = ellipse(p-off*55., vec2(551, 305) + d, vec2(19, 26));\n\t\t\t\tbool E = ellipse(p-off*55., vec2(601, 410) + d, vec2(35, 57));\n\t\t\t\tif(D && E)\n\t\t\t\t{\n\t\t\t\t\tbool F = ellipse(p-off*50., vec2(580, 360) + d * 1.3, vec2(71, 126));\n\t\t\t\t\tif(F)\n\t\t\t\t\t\tc = mix(COLOR_IRIS1, COLOR_IRIS2, SQR((p.y - 360.0 - d.y) / 252.0 + 0.5));\n\t\t\t\t\telse\n\t\t\t\t\t\tc = COLOR_BLACK;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_WHITE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tc = COLOR_EYEBROW;\n\t\treturn true;\n\t}\n\t// rotating ellipses hacks, nothing to see here\n\tbool G = ellipse(p, vec2(757, 430), vec2(40, 5));\n\tbool H = ellipse(vec2(p.x + p.y * 0.3, p.x * -0.3 + p.y), vec2(890, 260), vec2(40, 6));\n\tbool I = ellipse(vec2(p.x + p.y * 0.5, p.x * -0.5 + p.y), vec2(990, 175), vec2(40, 7));\n\tif(!G || !H || !I)\n\t{\n\t\tc = COLOR_BLACK;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool eye2(inout vec3 c, vec2 p, vec2 off)\n{\n\tbool A = line(p, vec2(207, 460), vec2(323, 265));\n\tbool B = circle(p, vec2(213, 434), 158.);\n\tbool C = circle(p, vec2(739, 417), 500.);\n\tbool D = ellipse(p, vec2(289, 444), vec2(50, 144));\n\tif(!A && !B && !C || !D)\n\t{\n\t\tbool E = ellipse(p, vec2(285, 390), vec2(47, 184));\n\t\tif(!E)\n\t\t{\n\t\t\tvec2 d = vec2(0.0, 0.0) - vec2(290, 360);\n\t\t\tif(length(d) > 60.0)\n\t\t\t   d = d / length(d) * 60.0;\n\t\t\td *= vec2(0.33, 1.0);\n\t\t\tbool F = ellipse(p-off*50., vec2(290, 360) + d, vec2(50, 162));\n\t\t\tif(F)\n\t\t\t\tc = COLOR_WHITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool D = ellipse(p-off*55., vec2(304, 446) + d, vec2(17, 41));\n\t\t\t\tbool E = ellipse(p-off*55., vec2(278, 354) + d, vec2(11, 24));\n\t\t\t\tif(D && E)\n\t\t\t\t{\n\t\t\t\t\tbool F = ellipse(p-off*50., vec2(290, 360) + d * 1.3, vec2(42, 126));\n\t\t\t\t\tif(F)\n\t\t\t\t\t\tc = mix(COLOR_IRIS1, COLOR_IRIS2, SQR((p.y - 360.0 - d.y) / 252.0 + 0.5));\n\t\t\t\t\telse\n\t\t\t\t\t\tc = COLOR_BLACK;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_WHITE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tc = COLOR_EYEBROW;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool neck(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(1247, -28), 638.);\n\tbool B = circle(p, vec2(353, 258), 638.);\n\tbool C = line(p, vec2(554, -80), vec2(1055, -80));\n\tif(!A && !B && C)\n\t{\n\t\tbool D = circle(p, vec2(1235, -21), 606.);\n\t\tif(D)\n\t\t\tc = COLOR_LINE;\n\t\telse\n\t\t\tc = COLOR_BODY;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvec2 transform(vec2 x)\n{\n\treturn (x - iResolution.xy / 2.0) / iResolution.y * 1000.0 + 500.0;\n}\n\nfloat sinslope(float t)\n{\n\treturn sin(t) - sin(t - 0.01);\t\n}\n\nvoid  mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat off = sin(iTime/1.75);\n\tif(off < 0.)\n\t\toff=0.;\n\telse if(off > .8)\n\t\toff=.8;\n\t\n\tm = transform(iMouse.xy * iResolution.xy);\n\tvec2 p = transform(fragCoord.xy);\n\tp.x += sin(iTime) * 200.0;\n\tp.y += abs(sin(iTime*7.0))*10.0 * (abs(sinslope(iTime)) * 200.0);\n\tvec3 c = vec3(1, 1, 1);\n\tear(c, p) || mane(c, p) || mane2(c, p) || eye1(c, p, vec2(off*1.6,off*.5)) || eye2(c, p, vec2(off*.4,off*.5))  || face(c, p) || neck(c, p);\n\tfragColor = vec4(c, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2BzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 808, 843, 843, 908], [910, 910, 948, 948, 1027], [1029, 1029, 1067, 1163, 1281], [1293, 1293, 1325, 1325, 1898], [1900, 1900, 1933, 1933, 3536], [3538, 3538, 3572, 3572, 4318], [4320, 4320, 4353, 4353, 5173], [5175, 5175, 5218, 5255, 6514], [6516, 6516, 6559, 6559, 7546], [7548, 7548, 7581, 7581, 7875], [7877, 7877, 7901, 7901, 7972], [7974, 7974, 7999, 7999, 8034], [8036, 8036, 8094, 8094, 8546]]}
{"id": "Wt2fDw", "name": "Wicked isometry", "author": "illus0r", "description": "Wicked isometry", "tags": ["raymarchingisometry"], "likes": 8, "viewed": 231, "published": "Public API", "date": "1599087464", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define textureCube texture\n\n#define MAX_STEPS 100\n#define MAX_DIST 200.\n#define EPSILON 0.00001\n#define PI 3.14159265\n#define IVORY 1.\n#define BLUE 2.\n#define BLACK 3.\n#define RED 4.\n#define LIGHT 5.\n\n#define PHI (sqrt(5.)*0.5 + 0.5)\n#define iTime (iTime / 1.1)\n\n#define N 6\n\nfloat rnd (float x) {return fract(10000. * sin(10000. * x));}\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 boxTexture(vec3 p, float id) {\n    if (p.x + -p.z < 0.) {\n        p.xz = p.zx;\n        id += 1.;//1000. * rnd(id);\n    }\n    id = floor(id);\n    id = mod(id, 52.);\n    float col = mod(id, 10.);\n    float row = id - col;\n    p.x -= col * 2.;\n    p.y -= row * 2.;\n    p.xy -= 1.;\n    p.xy *= .05;\n    return vec3(1);//texture(iChannel0, p.xy).rgb;\n}\n\n\n// \nvec2 getDist(vec3 p) {\n    float w = 0.5;\n    vec2 step = vec2(2);\n\n    p.xz *= Rot(0.3 * sin(iTime + length(p.xz))); \n\n    p.xz = mod(p.xz, step);\n    p.xz -= step / 2.;\n\n    p.xz *= Rot(iTime);\n    p.zy *= Rot(PI / 4.);\n    p.xz *= Rot(PI / 4.);\n    float box1 = sdBox(p, vec3(w));\n    float obj = min(box1, box1);\n    return vec2(obj * .6, RED);\n}\n// \n\n\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = 0.;\n    //float glow = 0.;\n    float step = 0.;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        step ++;\n        // volumeLight += .01;\n        d += abs(distToClosest.x);\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec3(d, info, step);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n);\n}\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= Rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // ray origin\n    vec3 ro = vec3(uv.x, 10, uv.y) * 10.;\n    // ro.yz *= Rot(PI / 4.);\n    // ro.xz *= Rot(-PI / 4.);\n    // ro += vec3(-2, 2, -2);\n    // ro.xz *= Rot(iTime);\n\n    // vec2 angle = 2. * 3.14159265 * iMouse.xy / iResolution.xy;\n    // vec3 lookat = vec3(0, 0, 0);\n    // lookat.xz *= Rot(angle.x);\n    // lookat.yz *= Rot(angle.y);\n\n    vec3 rd = normalize(vec3(0, -1, 0));\n    vec3 rm = rayMarch(ro, rd);\n    float d = rm[0];\n    float info = rm[1];\n    float steps = rm[2];\n\n    vec3 colorBg = vec3(.0);\n    vec3 color;\n    color = vec3(0);\n    vec3 light = vec3(13, 4, 10);\n    //light.xz *= Rot(iTime);\n    vec3 p = ro + rd * d;\n    if (d < MAX_DIST) {\n        vec3 n = getNormal(p);\n        //n.zy *= Rot(iTime);\n    \t// color = vec3( n * 0.5 + 0.5 );\n\n        //color *= info;\n        // vec3 tex = boxmap(u_tex_bg, ro + rd * d, n, 32.0 ).xyz;//\n        // self shadeing\n        // drop shadows\n        // trying to raymarch to the light for MAX_DIST\n        // and if we hit something, it's shadow\n        vec3 dirToLight = normalize(light - p);\n        vec3 rayMarchLight = rayMarch(p + dirToLight * .06, dirToLight);\n        float distToObstable = rayMarchLight.x;\n        float distToLight = length(light - p);\n        // if (distToObstable < distToLight) {\n        //     color *=  0.;\n        // }\n\n        // smooth shadows\n        // float shadow = smoothstep(0.0, .15, rayMarchLight.z / PI);\n        // color += .1 + .9 * shadow;\n\n        // tex *= color_bw;\n        // color = tex;\n        // color += 0.6 + vec3( color_bw );\n        // coloring \n        if (d < MAX_DIST) {\n           if (info == RED) {\n                color = boxTexture(p, iTime) + .1;\n                color *= dot(dirToLight, n) * .5 + .5;\n            }\n        }\n    }\n\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2fDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[278, 278, 299, 299, 339], [341, 341, 360, 360, 423], [425, 425, 456, 456, 543], [545, 545, 580, 580, 897], [900, 979, 1001, 1001, 1329], [1330, 1414, 1447, 1447, 1859], [1861, 1861, 1885, 1885, 2103], [2105, 2105, 2159, 2159, 2386], [2388, 2388, 2438, 2438, 2629], [2642, 2642, 2698, 2698, 4568]]}
{"id": "wt2fWm", "name": "esfera-fbm", "author": "jorge2017a1", "description": "esfera-fbm", "tags": ["esferafbm"], "likes": 4, "viewed": 101, "published": "Public", "date": "1599142566", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///----Autor desconocido\n///----18865.2\n\nvec2 hash(vec2 uv) {\n\tmat2 m = mat2(15.32, 35.68, 75.42, 153.93);\n\treturn fract(sin(m * uv) * 43258.21);\n}\n\nvec3 hash(vec3 p) {\n\tmat3 m = mat3(15.32, 35.68, 75.42, 153.93, 18.23, 85.75, 254.63, 384.64, 712.98);\n\treturn fract(sin(m * p) * 43258.21);\n}\n\nvec2 shash(vec2 uv) {\n\treturn hash(uv) * 2.0 - 1.0;\n}\n\nvec3 shash(vec3 p) {\n\treturn hash(p) * 2.0 - 1.0;\n}\n\nfloat noise(vec2 uv) {\n\tvec2 g = floor(uv);\n\tvec2 f = fract(uv);\n\tvec2 k = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n\tfloat lb = dot(\tshash(g + vec2(0.0, 0.0)), f - vec2(0.0, 0.0));\n\tfloat rb = dot(\tshash(g + vec2(1.0, 0.0)), f - vec2(1.0, 0.0));\n\tfloat lt = dot(\tshash(g + vec2(0.0, 1.0)), f - vec2(0.0, 1.0));\n\tfloat rt = dot(\tshash(g + vec2(1.0, 1.0)), f - vec2(1.0, 1.0));\n\t\n\tfloat b = mix(lb, rb, k.x);\n\tfloat t = mix(lt, rt, k.x);\n\treturn 0.5 + 0.5 * mix(b, t, k.y);\n}\n\nfloat noise(vec3 p)\n{\n\tvec3 g = floor(p);\n\tvec3 f = fract(p);\n\tvec3 k = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n\tfloat lbu = dot(shash(g + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n\tfloat rbu = dot(shash(g + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n\tfloat ltu = dot(shash(g + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n\tfloat rtu = dot(shash(g + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n\tfloat lbd = dot(shash(g + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n\tfloat rbd = dot(shash(g + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n\tfloat ltd = dot(shash(g + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n\tfloat rtd = dot(shash(g + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n\t\n\tfloat bu = mix(lbu, rbu, k.x);\n\tfloat tu = mix(ltu, rtu, k.x);\n\tfloat bd = mix(lbd, rbd, k.x);\n\tfloat td = mix(ltd, rtd, k.x);\n\tfloat u = mix(bu, tu, k.y);\n\tfloat d = mix(bd, td, k.y);\n\treturn 0.5 + 0.5 * mix(u, d, k.z);\n}\n\nfloat fbm(vec2 uv) {\n\tfloat v = 0.0;\n\tmat2 m = mat2(0.8, -0.6, 0.6, 0.8);\n\tv += noise(uv) / 2.0; uv = m * uv * 2.01;\n\tv += noise(uv) / 4.0;  uv = m * uv * 2.03;\n\tv += noise(uv) / 8.0;  uv = m * uv * 2.02;\n\tv += noise(uv) / 16.0;\n\treturn v * 1.3385;\n}\n\nfloat sdPlane(vec3 p) {\n\treturn p.y;\n}\n\n\nfloat sdSphere(vec3 p, float r) \n{\n\treturn length(p) - r + noise(p * 50.0) * 0.1;\n}\n\nfloat scene(vec3 p) {\n\tfloat d = sdPlane(p);\n\td = min(d, sdSphere(p - vec3(0.1 * cos(iTime * 0.9), 0.5, 0.1 * sin(iTime)), 0.5));\n\treturn d;\n}\n\nvec3 calcNormal(vec3 p) {\n\tvec3 e = vec3(0.00001, 0.0, 0.0);\n\tvec3 nor = vec3(scene(p + e.xyy) - scene(p - e.xyy),\n\t\t\tscene(p + e.yxy) - scene(p - e.yxy),\n\t\t\tscene(p + e.yyx) - scene(p - e.yyx));\n\treturn normalize(nor);\n}\n/*\nfloat calcAO(vec3 pos, vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos );\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n*/\n\nfloat calcAO(vec3 ro, vec3 rd) {\n\tfloat t = 0.0;\n\tfloat h = 0.0;\n\tfloat sh = 1.0;\n\tfor(int i = 0; i < 5; i++) {\n\t\tt += 0.01 + 0.05 * float(i);\n        \th = scene(ro + rd * t);\n\t\tsh = min(sh, h * 6.0 / t);\n\t}\n\treturn clamp(sh, -1.0, 1.0) * 0.05 + 0.95;\n}\nfloat shadow(vec3 ro, vec3 rd, float mint, float maxt) {\n\tfloat t = mint;\n\tfloat h = 0.0;\n\tfloat sh = 1.0;\n\tfor(int i = 0; i < 30; i++) {\n\t\tif(t > maxt) continue;\n\t\th = scene(ro + rd * t);\n\t\tsh = min(sh, h * 6.0 / t);\n\t\t//sh = h < 0.1 ? 0.0 : 1.0;\n\t\tt += h;\n\t}\n\treturn sh;\n}\n\nfloat castRay(vec3 ro, vec3 rd, float maxt) {\n\tfloat precis = 0.00001;\n\tfloat t = precis * 2.0;\n\tfor(int i = 0; i < 60; i++) {\n\t\tif(t < precis || t > maxt) continue;\n\t\tfloat h = scene(ro + rd * t);\n\t\tt += h;\n\t}\n\treturn t;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tvec3 color = vec3(1.0);\n\tfloat t = castRay(ro, rd, 20.0);\n\tvec3 p = ro + rd * t;\n\tcolor = vec3(0.6) + 0.4*sin( vec3(0.05,0.08,0.10)*(p.x * 10.0 -1.0) );\n\tvec3 lig = normalize(vec3(-0.2, 0.5, 0.3));\n\tvec3 nor = calcNormal(p);\n\tfloat dif = clamp(dot(nor, lig), 0.0, 1.0);\n\tfloat spec = pow(clamp(dot(reflect(rd, nor), lig), 0.0, 1.0), 16.0);\n\tfloat sh = shadow(p, lig, 0.02, 20.0);\n\tfloat ao = calcAO(p, nor);\n\tcolor = color * (dif * ao + spec) * (0.2 + 0.8 * sh);\n\tcolor *= exp(-0.01 * t * t);\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv = uv * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 ro = vec3(0.0, 1.0, 3.0);\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 cw = normalize(ta - ro);\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = cross(cw, up);\n\tvec3 cv = cross(cu, cw);\n\tvec3 rd = normalize(uv.x * cu + uv.y * cv + 2.0 * cw);\n\t\n\tvec3 color = render(ro, rd);\n\n\tfragColor = vec4( color, 1.0 );\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2fWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 41, 61, 61, 147], [149, 149, 168, 168, 291], [293, 293, 314, 314, 346], [348, 348, 368, 368, 399], [401, 401, 423, 423, 866], [868, 868, 889, 889, 1798], [1800, 1800, 1820, 1820, 2050], [2052, 2052, 2075, 2075, 2090], [2093, 2093, 2127, 2127, 2176], [2178, 2178, 2199, 2199, 2320], [2322, 2322, 2347, 2347, 2543], [2544, 2892, 2924, 2924, 3145], [3146, 3146, 3202, 3202, 3420], [3422, 3422, 3467, 3467, 3645], [3647, 3647, 3678, 3678, 4189], [4191, 4191, 4248, 4248, 4663]]}
{"id": "Wt2fWV", "name": "Planetary gears_1", "author": "Jiaqi", "description": "Simple animation using a gear polar function discovered mostly by chance. \n\nStill have problem in line 122", "tags": ["2d", "gear"], "likes": 8, "viewed": 99, "published": "Public", "date": "1599892550", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Planetary gears\" by None. https://shadertoy.com/view/-1\n// 2020-09-12 06:32:45\n\n// Fork of \"Planetary gears\" by AntoineC. https://shadertoy.com/view/MsGczV\n// 2020-09-12 06:31:43\n//https://www.youtube.com/watch?v=9c1CyklAN5A\n\n// Inspired by:\n//  http://cmdrkitten.tumblr.com/post/172173936860\n\n\n#define Pi 3.14159265359\n\nstruct Gear\n{\n    float t;\t\t\t// Time\n    float gearR;\t\t// Gear radius\n    float teethH;\t\t// Teeth height\n    float teethR;\t\t// Teeth \"roundness\"\n    float teethCount;\t// Teeth count\n    float diskR;\t\t// Inner or outer border radius\n    vec3 color;\t\t\t// Color\n};\n\n    \n    \nfloat GearFunction(vec2 uv, Gear g)\n{\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    \n    // Gear polar function:\n    //  A sine squashed by a logistic function gives a convincing\n    //  gear shape!\n    float p = g.gearR-0.5*g.teethH + \n              g.teethH/(1.0+exp(g.teethR*sin(g.t + g.teethCount*a)));\n\n    float gear = r - p;\n    float disk = r - g.diskR;\n    \n    return g.gearR > g.diskR ? max(-disk, gear) : max(disk, -gear);\n}\n\n\nfloat GearDe(vec2 uv, Gear g)\n{\n    // IQ's f/|Grad(f)| distance estimator:\n    float f = GearFunction(uv, g);\n    vec2 eps = vec2(0.0001, 0);\n    vec2 grad = vec2(\n        GearFunction(uv + eps.xy, g) - GearFunction(uv - eps.xy, g),\n        GearFunction(uv + eps.yx, g) - GearFunction(uv - eps.yx, g)) / (2.0*eps.x);\n    \n    return (f)/length(grad);\n}\n\n\n\nfloat GearShadow(vec2 uv, Gear g)\n{\n    float r = length(uv+vec2(0.1));\n    float de = r - g.diskR + 0.0*(g.diskR - g.gearR);\n    float eps = 0.4*g.diskR;\n    return smoothstep(eps, 0., abs(de));\n}\n\n\nvoid DrawGear(inout vec3 color, vec2 uv, Gear g, float eps)\n{\n\tfloat d = smoothstep(eps, -eps, GearDe(uv, g));\n    float s = 1.0 - 0.7*GearShadow(uv, g);\n    color = mix(s*color, g.color, d);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = 0.5*iTime;\n    float t1 = 0.5*iTime;\n\n    vec2 uv = 2.0*(fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    float eps = 2.0/iResolution.y;\n\n    // Scene parameters;\n\tvec3 base = vec3(0.95, 0.7, 0.2);\n    const float count = 5.0;\n    \n    float teethCount_outer=66.0;\n    float teethCount_inner=16.0;\n    float gearR_outer = 0.8;\n    float gearR_inner = gearR_outer*teethCount_inner/teethCount_outer;\n    \n    float gearR_sun   = gearR_outer-2.0*gearR_inner;\n    float teethCount_sun  = floor(gearR_sun/gearR_inner*teethCount_inner);\n\n    Gear sun = Gear(0.0, gearR_sun, 0.05, 4.0, teethCount_sun, gearR_sun/1.5, base);\n\n    Gear outer = Gear(0.0, gearR_outer, 0.05, 4.0, teethCount_outer, gearR_outer*1.1, base);\n    Gear inner = Gear(0.0, gearR_inner, 0.05, 4.0, teethCount_inner, gearR_inner/1.5, base);\n    \n    \n    // Draw inner gears back to front:\n    vec3 color = vec3(0.0);\n    for(float i=0.0; i<count; i++)\n    {\n        t += 2.0*Pi/count;\n        inner.t = (outer.gearR-inner.gearR)*(outer.teethCount/outer.gearR)*t;\n        inner.color = base/3.0;//*(0.35 + 0.6*i/(count-1.0));\n        DrawGear(color, uv+(outer.gearR-inner.gearR)*vec2(cos(t),sin(t)), inner, eps);    }\n    \n    \n    \n    \n    // Draw outer gear:\n    DrawGear(color, uv, outer, eps);\n    ////\n    // Draw sun gear:\n    //t1 += 2.0*Pi/1.0;\n    sun.t = -inner.t/(outer.teethCount/sun.teethCount+1.0)*5.0;\n    sun.color = base *2.0 ;\n    DrawGear(color, uv, sun , eps);\n\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2fWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[238, 606, 643, 643, 1058], [1061, 1061, 1092, 1136, 1414], [1418, 1418, 1453, 1453, 1615], [1618, 1618, 1679, 1679, 1811], [1817, 1817, 1874, 1874, 3376]]}
{"id": "wt2fzG", "name": "3D SDF: Pipe", "author": "JacobC", "description": "The sdf of a pipe (another). If you change the values of the inner-outer radius, height and roundness it can morph into a sphere, torus, pipe, (hollow)disk\nMove camera by dragging the mouse while clicking it", "tags": ["3d", "raymarching", "sdf"], "likes": 8, "viewed": 139, "published": "Public", "date": "1599254638", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * \"3D SDF: Pipe\" by Jacob Ceron aka JacobC - 2020\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: jacobceron6@gmail.com\n */\n\nfloat pipe(in vec3 p, float r, float R, float h, float k)\n{\n    p.y = min(h - abs(p.y), 0.);\n    return length(vec2(max(abs(length(p.xz) - (R - (r + k) * .5)) - (r - k) * .5, 0.), p.y)) - k;\n}\n\nvec3 scene(in vec3 p)\n{\n    float t = iTime * .5;\n    float f = p.y + 1.;\n    \n    p.xz *= mat2(cos(t), sin(t), -sin(t), cos(t));\n    p.yz *= mat2(cos(t), sin(t), -sin(t), cos(t));\n    \n    float h = pipe(p.xzy, 2., 4., 6., max(sin(t * .5) * 2., .25));\n    \n    return vec3(min(f, h), max(f, h), h < f ? 0. : 1.);\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 e = vec2(.01, .0);\n    float d = scene(p).x;\n    return normalize(d - vec3(scene(p - e.xyy).x, scene(p - e.yxy).x, scene(p - e.yyx).x));\n}\n\n#define STEPS 99\n#define MIN_S .01\n#define MAX_S 66.\n\nvec3 marcher(in vec3 o, in vec3 d)\n{\n    float t = 0.;\n    for (int i = 0; i < STEPS; i++)\n    {\n        vec3 s = scene(o + d * t);\n        t += s.x;\n        if (s.x < MIN_S)\n            return vec3(t, s.yz);\n        if (t > MAX_S)\n            return vec3(-1.);\n    }\n    return vec3(-1.);\n}\n\nvec3 camera(in vec2 p, in vec3 o, in vec3 t)\n{\n    vec3 w = normalize(o - t);\n    vec3 u = normalize(cross(vec3(0., 1., 0.), w));\n    vec3 v = cross(w, u);\n    return p.x * u + p.y * v - w;\n}\n\nfloat map(float i, float c, float l, float q)\n{\n    return 1. / (c + i * l + i * i * q);\n}\n\n#define AA 2.\n#define gd vec3(.5)\n#define sk vec3(1.)\n#define Pi 3.14152\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord;\n    vec3 f_col;\n    \n    for (float y = 0.; y < AA; y++)\n    {\n        for (float x = 0.; x < AA; x++)\n        {\n            vec2 n = vec2(x, y) / AA - .5;\n    \t\tvec2 uv = (st + n - iResolution.xy * .5) / iResolution.y;\n\t\t\tvec2 ms = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n            \n            vec3 o = vec3(0., 8., 16.);\n            if (iMouse.z > 0.)\n            \to = vec3(cos(ms.x * Pi), max(ms.y, .05) * 2., sin(ms.x * Pi)) * 16.;\n            vec3 d = camera(uv, o, vec3(0.));\n            \n            vec3 bg = mix(gd, sk, d.y * .5 + .5);\n    \t\tvec3 col = vec3(0.);\n            \n            vec3 m = marcher(o, d);\n            if (m.z != -1.)\n            {\n                vec3 p = o + d * m.x;\n                vec3 n = normal(p);\n                bg = mix(gd, sk, n.y * .5 + .5);\n                \n                if (m.z >= 1.)\n                {\n                    float s = m.y;\n                    \n                    col += mix(vec3(1.), vec3(.0, 1., .5), map(s, 1., .01, .025));\n                    col *= mix(vec3(1.), vec3(.5, .85, .25), map(s-5., 1., .01, .025));\n                    col *= mix(vec3(1.), vec3(1., 1., .0), map(s-10., 1., .01, .025));\n                    \n                    float f = abs(fract(s * map(m.x, 1., .0007, .00035)) - .5);\n                    f = smoothstep(.0, .05, f - .05);\n\n                \tcol *= clamp(mix(f+1., f, map(m.x * s * .05, 1., .05, .01)), 0., 1.);\n                }\n                else\n                    col += bg;\n                col *= 1. - map(m.y, 1., .7, 2.);\n                \n            }\n            else\n                col += .9;\n            f_col += col;\n        }\n    }\n    \n    f_col /= AA * AA;\n\n    fragColor = vec4(sqrt(f_col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2fzG.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 180, 239, 239, 372], [374, 374, 397, 397, 689], [691, 691, 715, 715, 863], [919, 919, 955, 955, 1210], [1212, 1212, 1258, 1258, 1403], [1405, 1405, 1452, 1452, 1495], [1571, 1571, 1628, 1628, 3382]]}
{"id": "wtBBD3", "name": "Logo UwU RayMarching", "author": "VinsStm", "description": "Logo de l'association UwU (association d'informatique de l'ENSE3) anim ralis en ray-marching.\n\nanimated UwU association logo using ray-marching (UwU is the computer association of ENSE3, a french engineering school)\n", "tags": ["raymarching", "perlinnoise"], "likes": 1, "viewed": 96, "published": "Public", "date": "1599989881", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define sst smoothstep\n#define st step\n#define PI 3.1415926535897932384626433832795\n\n\n//---------------------------------------------------------\nfloat n21(vec2 p) {\n\tp += dot(p + vec2(0.5, 16.4268), p + vec2(23.45, 0.1563)) * 10000.;\t\n\treturn fract(cos(dot(p, vec2(63.428, 23.1452))) * 43437.3123545);\n}\n\n\n//---------------------------------------------------------\nfloat perlinNoise2D(vec2 p) {\n\tvec2 int_p = floor(p);\n\tvec2 flt_p = fract(p);\n\t\n\tvec2 swz = vec2(1., 0.);\t// for swizzle\n\t\n\tfloat n00 = n21(int_p) * 4. * PI;\n\tfloat n10 = n21(int_p + swz.xy) * 4. * PI;\n\tfloat n11 = n21(int_p + swz.xx) * 4. * PI;\n\tfloat n01 = n21(int_p + swz.yx) * 4. * PI;\n\t\n\tvec2 v00 = vec2(cos(n00), sin(n00));\n\tvec2 v10 = vec2(cos(n10), sin(n10));\n\tvec2 v11 = vec2(cos(n11), sin(n11));\n\tvec2 v01 = vec2(cos(n01), sin(n01));\n\t\n\tfloat d00 = dot(flt_p.xy, v00);\n\tfloat d10 = dot(flt_p.xy - swz.xy, v10);\n\tfloat d11 = dot(flt_p.xy - swz.xx, v11);\n\tfloat d01 = dot(flt_p.xy - swz.yx, v01);\t\n\t\n\t//vec2 cbc = sst(0., 1., flt_p);\t// cubic interpolation\n\tvec2 intp = flt_p*flt_p*flt_p*(flt_p*(flt_p*6.-15.)+10.);\t//quintic interpolation\n\t\n\tfloat m_bck_dwn = mix(d00, d10, intp.x);\t// from left to right\n\tfloat m_bck_up = mix(d01, d11, intp.x);\t// from left to right\n\treturn 0.5 + mix(m_bck_dwn, m_bck_up, intp.y);\t// bottom to top\n\t\n}\n\n\n//---------------------------------------------------------\nstruct Frame {\n\tvec3 o;\n\tvec3 x;\n\tvec3 y;\n\tvec3 z;\n};\n\n\n//---------------------------------------------------------\nstruct Camera {\n\tFrame fr;\t// the camera is oriented along -fr.z\n\tfloat ds;\t// position of the center of the screen on the z axis (this distance should be negative)\n};\n\n\n//---------------------------------------------------------\nstruct Ray {\n\tvec3 o;\t// ray origin\n\tvec3 d;\t// ray direction\n};\n\n\n//---------------------------------------------------------\nstruct Capsule {\n\tvec3 a;\n\tvec3 b;\n\tfloat r;\n};\n\n\n//---------------------------------------------------------\nstruct Torus {\n\tFrame fr;\n\tfloat r1;\n\tfloat r2;\n};\n\n\n//---------------------------------------------------------\nstruct Box {\n\tFrame fr;\n\tvec3 d;\t// d.x is the distance between the origin fr.o of the box and the sides of normal +/- fr.x\n\tfloat cr;\t// corner radius\n};\n\n\n//---------------------------------------------------------\nstruct Cylinder {\n\tvec3 a;\n\tvec3 b;\n\tfloat r;\n\tfloat cr;\t// corner radius\n};\n\n\n//---------------------------------------------------------\nstruct Pipe {\n\tvec3 a;\n\tvec3 b;\n\tfloat rext;\n\tfloat rint;\n};\n\n\n//---------------------------------------------------------\nstruct SurfaceElement {\n\tvec3 n;\t// vector normal to the surface element\n\tvec3 o;\t// middle point of the surface element\n\tvec3 clr;\t// color of the surface element\n};\n\n\n//---------------------------------------------------------\nstruct Light {\n\tvec3 clr;\n\tvec3 o;\n};\n\n\n//---------------------------------------------------------\nvec3 changeBasis1(vec3 v, Frame fr) {\n\treturn transpose(mat3(fr.x, fr.y, fr.z)) * v;\n}\n\n\n//---------------------------------------------------------\nvec3 changeBasis2(vec3 v, Frame fr) {\n\treturn mat3(fr.x, fr.y, fr.z) * v;\n}\n\n\n//---------------------------------------------------------\n// p is the point in the original frame, o is the origin of the final frame with respect to the original frame\n// x, y and z are vectors that define the final frame wrt the original frame\nvec3 changeFrame1(vec3 p, Frame fr) {\n\tvec3 cp = p - fr.o;\n\treturn changeBasis1(cp, fr);\n}\n\n\n//---------------------------------------------------------\n// p is the point in the original frame, o is the origin of the original frame with respect to the final frame\n// fr.x, fr.y and fr.z are vectors that define the original frame wrt the final frame\nvec3 changeFrame2(vec3 p, Frame fr) {\n\treturn fr.o + changeBasis2(p, fr);\n}\n\n\n//---------------------------------------------------------\n#define ROTX(a) mat3(1., 0., 0., 0., cos(a), -sin(a), 0., sin(a), cos(a))\n#define ROTY(a) mat3(cos(a), 0., -sin(a), 0., 1., 0., sin(a), 0., cos(a))\n#define ROTZ(a) mat3(cos(a), -sin(a), 0., sin(a), cos(a), 0., 0., 0., 1.)\n\n\n//---------------------------------------------------------\nFrame rotateX(Frame f, float a) {\t// rotate with respect to the original frame\n\tmat3 mat = ROTX(a);\n\t\t\t\t\t\n\tf.x = mat * f.x;\n\tf.y = mat * f.y;\n\tf.z = mat * f.z;\n\t\n\treturn f;\n}\n\n\n//---------------------------------------------------------\nFrame rotateY(Frame f, float a) {\t// rotate with respect to the original frame\n\tmat3 mat = ROTY(a);\n\t\t\t\t\t\n\tf.x = mat * f.x;\n\tf.y = mat * f.y;\n\tf.z = mat * f.z;\n\t\n\treturn f;\n}\n\n\n//---------------------------------------------------------\nFrame rotateZ(Frame f, float a) {\t// rotate with respect to the original frame\n\tmat3 mat = ROTZ(a);\n\t\t\t\t\t\n\tf.x = mat * f.x;\n\tf.y = mat * f.y;\n\tf.z = mat * f.z;\n\t\n\treturn f;\n}\n\n\n//---------------------------------------------------------\nfloat smth(float a, float b, float k) {\n\tfloat h = clamp(0.5 + (b - a) / k, 0., 1.);\n\treturn h * a + (1. - h) * b - 0.5 * h * (1. - h) * k;\n}\n\n\n//---------------------------------------------------------\n#define BLUR_DIST 0.2\t// this is used to create a blur effect on \n\t\t\t\t\t\t// the shadows by creating a zone around the \n\t\t\t\t\t\t// shapes where the ligt rays are attenuated\n#define BLUR_INT -1.\n#define BLUR_EXT 1.\n#define NO_BLUR 0.\n\n\n//---------------------------------------------------------\nfloat dSphere(vec4 s, vec3 point, bool toLight, float blur) {\n\ts.w += toLight ? blur * BLUR_DIST / 2. : 0.;\n\treturn distance(point, s.xyz) - s.w;\n}\n\n\n//---------------------------------------------------------\nfloat dBox(Box bx, vec3 p, bool toLight, float blur) {\n\tbx.d += toLight ? blur * BLUR_DIST / 2. : 0.;\n\tp = changeFrame1(p, bx.fr);\t\n\t//return length(abs(p) - min(abs(bx.d - bx.cr), abs(p)));\n\treturn length(max(abs(p) - (bx.d - bx.cr), 0.)) - bx.cr;\n}\n\n\n//---------------------------------------------------------\nfloat dSurf(SurfaceElement srf, vec3 p, bool toLight, float blur) {\n\treturn dot(srf.n, p - srf.o) + (toLight ? blur * BLUR_DIST / 2. : 0.);\n}\n\n\n//---------------------------------------------------------\n#define SURF_DIST 0.004\t// this is the smallest distance considered by the raymarcher\n#define MAX_DIST 70.\t// greatest render distance\n\n\n//---------------------------------------------------------\nvec4 dLetter_U(vec3 shiftU, bool toLight, float smthness, float corner) {\n\tBox btm;\t// for bottom\n\tmat3 rotY = ROTY(PI * sst(0.75, 0.9, fract(iTime / 4.)));\n\tbtm.fr.o = vec3(0., 2., 0.);\n\tbtm.fr.y = vec3(0., 1., 0.);\n\tbtm.fr.x = rotY * vec3(1., 0., 0.);\n\tbtm.fr.z = rotY * vec3(0., 0., 1.);\n\tbtm.d = vec3(2.5, 0.75, 0.75);\n\tbtm.cr = SURF_DIST + corner;\t// corner raduis\n\tfloat d_btm = dBox(btm, shiftU, toLight, BLUR_INT);\n\t\n\tBox top;\n\ttop.fr.o = vec3(1.75, 6.5, 0.);\n\ttop.fr.x = vec3(1., 0., 0.);\n\ttop.fr.y = top.fr.x.yxy;\n\ttop.fr.z = top.fr.x.yyx;\n\ttop.d = vec3(0.75);\n\ttop.cr = SURF_DIST + corner;\t// corner raduis\t\n\tfloat d_top = smth(d_btm, dBox(top, vec3(abs(shiftU.x), shiftU.yz), toLight, BLUR_INT), smthness);\n\t\n\tBox ltf;\t// for left\n\tmat3 rotX = ROTX(PI * sst(0.75, 0.9, fract(iTime / 4.)));\n\tltf.fr.o = vec3(1.75, 4.25, 0.);\n\tltf.fr.x = vec3(1., 0., 0.);\n\tltf.fr.y = rotX*ltf.fr.x.yxy;\n\tltf.fr.z = rotX*ltf.fr.x.yyx;\n\tltf.d = vec3(0.75, 3., 0.75);\n\tltf.cr = SURF_DIST + corner;\t// corner raduis\n\t\n\tfloat dist = smth(d_top, dBox(ltf, vec3(abs(shiftU.x), shiftU.yz), toLight, BLUR_INT), smthness);\n\treturn vec4(3. * vec3(0., 0.5 * 155. / 255., 0.5 * 60. / 255.), dist);\n}\n\n\n//---------------------------------------------------------\nvec4 dLetter_w(vec3 p, bool toLight, float smthness, float corner) {\n\tBox btm;\t// for bottom\n\tbtm.fr.o = vec3(0., 2.25, 0.);\n\tbtm.fr.x = vec3(1., 0., 0.);\n\tbtm.fr.y = btm.fr.x.yxy;\n\tbtm.fr.z = btm.fr.x.yyx;\n\tbtm.d = vec3(2.5, 0.625, 0.625);\n\tbtm.cr = SURF_DIST + corner;\t// corner raduis\n\tfloat d_btm = dBox(btm, p, toLight, BLUR_INT);\n\t\n\tBox ltf;\t// for left\n\tltf.fr.o = vec3(2, 3.6875, 0.);\n\tltf.fr.x = vec3(1., 0., 0.);\n\tltf.fr.y = ltf.fr.x.yxy;\n\tltf.fr.z = ltf.fr.x.yyx;\n\tltf.d = vec3(0.625, 2., 0.625);\n\tltf.cr = SURF_DIST + corner;\t// corner raduis\n\tfloat d_lft = smth(d_btm, dBox(ltf, vec3(abs(p.x), p.yz), toLight, BLUR_INT), smthness);\n\t\t\n\tBox cntr;\t// for center\n\tcntr.fr.o = vec3(0., 3.25, 0.);\n\tcntr.fr.x = vec3(1., 0., 0.);\n\tcntr.fr.y = ltf.fr.x.yxy;\n\tcntr.fr.z = ltf.fr.x.yyx;\n\tcntr.d = vec3(0.5, 1.5, 0.5);\n\tcntr.cr = SURF_DIST + corner;\t// corner raduis\n\tfloat dist = smth(d_lft, dBox(cntr, p, toLight, BLUR_INT), smthness);\n\treturn vec4(vec3(0.1), dist);\n}\n\n\n//---------------------------------------------------------\nvec4 getDist(vec3 p, bool toLight) {\n\n\t// distances\n\tvec4[3]\td;\n\n\t//------------shapes--------------\t\n\t\n\t\n\t//-------sphere-----(ground)\n\tfloat radius = 250.;\n\tvec4 earth = vec4(0., -radius , 0., radius);\t// x, y, z coordinates ; and the radius\n\tfloat dist_middle = length(p.xz);\n\tfloat offset = perlinNoise2D((p.xz + vec2(50., 50.)) * 0.4);\n\toffset += sst(10., 15., dist_middle) * sin(0.3 * dist_middle - iTime * 2.5) * sin(12. * atan(p.z, p.x) - 4.5 * iTime);\n\tfloat dist_ground = dSphere(earth, p, toLight, BLUR_INT) + offset;\n\tvec3 clr = vec3(0.2);\n\n\td[0] = vec4(clr, dist_ground);\t// ground distance\n\t\n\t\n\t// capital U\t\n\td[1] = dLetter_U(vec3(-abs(p.x), p.yz) - vec3(-6., 0., 0.), toLight, 1., 0.2);\n\t\n\t\n\t// w\n\td[2] = dLetter_w(p, toLight, 1., 0.2);\n\t\n\t\n\t// the minimum distance is the distance to the closest object\n\tvec4 minDist = vec4(vec3(1.), MAX_DIST);\n\tfor(int i=0 ; i<3 ; i++) {\n\t\tminDist = d[i].w < minDist.w ? d[i] : minDist;\n\t}\n\t\n\treturn minDist;\n}\n\n\n//---------------------------------------------------------\nvec3 intersect(Ray r, float d) {\n\treturn r.o + r.d * d;\n}\n\n\n//---------------------------------------------------------\n#define MAX_STEPS 100\n\nvec2 rayMarch(Ray r, bool toLight) {\n\tbool firstHit = false;\n\tfloat d_o = 0.; // distance from the origin\n\t\n\tfloat closest = MAX_DIST;\t// initialize smallest distance between the ray (not the ray marcher) and an object (that the ray marcher is getting closer)\n\tfloat prevDist = SURF_DIST;\t// initialize the distance between the last position of the ray marcher (point on the ray) and the closest object at this position\n\t\n\tint i;\n\tfor(i=0 ; i<MAX_STEPS ; i++) {\n\t\tvec3 p = intersect(r, d_o);\t// current position of the ray marcher\n\t\tfloat dst = getDist(p, toLight).w;\t// get the distance of the nearest object\n\t\t// if the ray marcher is getting closer of an object AND the distance between the ray marcher\n\t\t// and the object is smaller than the distance to the  previous closest\n\t\tif(dst<prevDist && dst<closest) {\t// object (that the ray marcher is getting closer)\n\t\t\tclosest = dst;\t// then, the distance to the previous closest object becomes the current distance between the ray marcher and the object\n\t\t}\n\t\t\n\t\td_o += dst;\t// increment the ray marcher with this distance\n\t\tif(abs(dst)<SURF_DIST || d_o>MAX_DIST) break;\t// taking the absolute value prevent the raymarcher from stopping inside an object\n\t\t\n\t\tprevDist = dst;\t// updating the previous distance (needs to be done after the 'if -> break')\n\t}\n\t\n\treturn vec2(d_o, closest);\n}\n\n\n//---------------------------------------------------------\nSurfaceElement getNormal(vec3 p) {\n\tvec4 d = getDist(p, false);\n\t\n\tvec2 e = vec2(SURF_DIST / 2., 0.);\t// used for swizzling\n\n\tvec3 n = d.w - vec3(\n\tgetDist(p - e.xyy, false).w,\n\tgetDist(p - e.yxy, false).w,\n\tgetDist(p - e.yyx, false).w);\n\t\n\tSurfaceElement sr;\n\tsr.clr = d.xyz;\n\tsr.n = normalize(n);\n\tsr.o = p;\n\t\n\treturn sr;\t// vector normal to the surface\n}\n\n\n//--------------------------------------------------------\n#define AMBIENT 0.025\n#define DARK_SHADOW 0.9\t\t// darkness of the projected shadows (1. is full darkness)\n\nvec3 getCol(vec3 p, Light lgt) {\n\tvec3 lr = lgt.o - p; //light ray\n\tvec3 lrn = normalize(lgt.o - p);\t// direction of tht light ray\n\tSurfaceElement sr = getNormal(p);\n\t\n\tRay r;\n\tr.o = p;\n\tr.d = lrn;\n\tvec2 rm = rayMarch(r, true);\t\n\tfloat shadow = sst(0., SURF_DIST + BLUR_DIST, rm.y);// with blur on the edges of the shadow\n\t//float shadow = st(SURF_DIST, rm.y);// without blur on the edges of the shadow\n\t\n\tfloat dif = clamp(dot(sr.n, lrn), 0., 1.);\n\tdif *= 1. - DARK_SHADOW + (rm.x > length(lr) ? DARK_SHADOW * shadow : 0.);\n\t//vec3 col = lgt.clr * clamp(sr.clr, 0., 1.) * dif;\n\tvec3 col = lgt.clr * sr.clr * dif;\n\treturn  col;\n}\n\n\n//---------------------------------------------------------\nvec3 renderLight(vec3 p) {\n\n\tfloat lights_height = 25.;\n\tfloat dfs = 15.;\t// distance from center\n\tfloat min_clr = 0.5;\n\t// light source 1\n\tLight ls1;\n\tls1.clr = vec3(1.);\t// color of the light\n\tls1.o = ROTY(- 2. * iTime / 5.) * vec3(0., lights_height, dfs);\t// light source\n\tvec3 col1 = getCol(p, ls1);\n\t\n\t// light source 2\n\tLight ls2;\n\tls2.clr = 0.5 + 0.5 * sin(iTime * vec3(0.345, 0.456, 0.657));\n\tls2.o = ROTY(2. * PI / 3.) * ls1.o;\n\tvec3 col2 = getCol(p, ls2);\n\t\n\t// light source 3\n\tLight ls3;\n\tls3.clr = 0.5 + 0.5 * sin(iTime * vec3(0.345, 0.456, 0.657));\n\tls3.o = ROTY(2. * PI / 3.) * ls2.o;\t\n\tvec3 col3 = getCol(p, ls3);\n\t\n\treturn col1 + col2 + col3;\n}\n\n\n\n//---------------------------------------------------------\nRay getRay(Camera cam, vec2 uv) {\n\tvec3 p = changeFrame2(vec3(uv, cam.ds), cam.fr);\n\tRay r;\n\tr.o = cam.fr.o;\n\tr.d = normalize(p - r.o);\n\treturn r;\n}\n\n\n\n//---------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n\n\tfloat angle = -iTime / 5.;\n\tmat3 mty = ROTY(angle);\n\t\n\t//------------Camera-----------\n\tCamera cam;\n\tcam.fr.o = vec3(0., 8., 18);\n\tcam.fr.x = vec3(1., 0., 0.);\n\tcam.fr.y = cam.fr.x.yxy;\n\tcam.fr.z = cam.fr.x.yyx;\n\tcam.ds = -0.5;\n\t\n\tcam.fr.o = mty * cam.fr.o;\t// rotate origin of the camera around the y axis\n\tcam.fr = rotateX(cam.fr, PI / 8.);\n\tcam.fr = rotateY(cam.fr, angle);\n\t\n\tRay r = getRay(cam, uv);\n\t\n\t\n\t//-----------intersection with objects------------\n\tvec2 rm = rayMarch(r, false);\n\tvec3 p = intersect(r, rm.x); \t// intersection point\n\t\n\tvec3 col = renderLight(p) * (rm.x >= MAX_DIST ? 0. : 1.);\n\t\n\tcol = clamp(AMBIENT + (1. - AMBIENT) * col, AMBIENT, 1.);\n\tcol = pow(col, vec3(0.4545));\n\tcol = col*col*(3.0-2.0*col);\n\n\n\t//vec3 col = vec3(perlinNoise3D(vec3(uv * 10., iTime)));\n\t\n\tfragColor = vec4(col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBBD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 146, 165, 165, 304], [307, 367, 396, 396, 1312], [2819, 2879, 2916, 2916, 2965], [2968, 3028, 3065, 3065, 3103], [3106, 3354, 3391, 3391, 3444], [3447, 3704, 3741, 3741, 3779], [4066, 4126, 4159, 4204, 4300], [4303, 4363, 4396, 4441, 4537], [4540, 4600, 4633, 4678, 4774], [4777, 4837, 4876, 4876, 4978], [5272, 5332, 5393, 5393, 5479], [5482, 5542, 5596, 5596, 5792], [5795, 5855, 5922, 5922, 5996], [6196, 6256, 6329, 6329, 7436], [7439, 7499, 7567, 7567, 8472], [8475, 8535, 8571, 8586, 9497], [9500, 9560, 9592, 9592, 9617], [9620, 9703, 9739, 9739, 11041], [11044, 11104, 11138, 11138, 11461], [11464, 11630, 11662, 11662, 12259], [12262, 12322, 12348, 12348, 12982], [12986, 13046, 13079, 13079, 13194], [13198, 13258, 13313, 13313, 14201]]}
{"id": "WtBBDK", "name": "embrace", "author": "tono", "description": "meat!", "tags": ["terarria"], "likes": 9, "viewed": 110, "published": "Public", "date": "1599900945", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float depth = 0.;\nfloat cycles = 0.;\n\nint mat = 0;\n\n#define OHKYU 1\n#define LIGHTBALL 2\n#define MEAT 3\n#define EYE 4\n#define S smoothstep \n#define KANTERA normalize(vec3(252.,207.,3.))\n#define SAT(x) clamp(x,0.,1.)\n\n#define MAXSTEP 256\n\n#define AA 3\n\nfloat TIME;\nfloat fallenEye = 0.;\nfloat roof = 0.;\nfloat MOZI = 1.;\nfloat Eyeroof = 0.;\n\nconst float pi = acos(-1.);\nvec3 PointLightPosition = vec3(0.);\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\nfloat rand(vec2 p){return fract(sin(dot(p,vec2(127.1,317.2))));}\n\n////http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 RotMat(vec3 p,vec3 axis, float angle)\n{\n    // http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return p * mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c          );\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise2 (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise2(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nvec2 random2(vec2 st){return -1.0 + 2.0*fract(sin( vec2( dot(st,vec2(127.1,311.7)),dot(st,vec2(269.5,183.3)) ))*43758.5453123);}\n\nfloat noise(vec2 st) \n{\n    vec2 p = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 v00 = random2(p+vec2(0,0));\n    vec2 v10 = random2(p+vec2(1,0));\n    vec2 v01 = random2(p+vec2(0,1));\n    vec2 v11 = random2(p+vec2(1,1));\n    return mix( mix( dot( vec2(v00), f - vec2(0,0) ), dot( vec2(v10), f - vec2(1,0) ), u.x ),\n                 mix( dot( vec2(v01), f - vec2(0,1) ), dot( vec2(v11), f - vec2(1,1) ), u.x ), \n                 u.y)+0.5;\n}\n\nfloat c(float x, float f)\n{\n    return x - (x - x * x) * -f;\n}\nvec2 c(vec2 x, float f)\n{\n    return x - (x - x * x) * -f;\n}\n\nvec2 Polar(vec2 i)\n{\n    vec2 pl = vec2(0.);\n    pl.y = sqrt(i.x*i.x+i.y*i.y)*2.+1.;\n    pl.x = atan(i.y,i.x)/acos(-1.);\n    return pl;\n}\n\nvec2 min2(vec2 p1,vec2 p2)\n{\n    if(p1.x < p2.x){return p1;}\n    return p2;\n}\n\nvec2 smin2(vec2 p1,vec2 p2)\n{\n    float p = smoothMin(p1.x,p2.x,2.);\n    if(p1.x < p2.x){return vec2(p,p1.y);}\n    return vec2(p,p2.y);\n}\n\n#define ITERATIONS 6\nfloat deMandelbulb(vec3 p, float power , float offset) {\n    vec3 z = p;\n    float dr = 1.0;\n    float r;\n    for (int i = 0; i < ITERATIONS; i++) {\n        r = length(z);\n        if (r > 10.0) break;\n        float theta = acos(z.y / r);\n        float phi = atan(z.z, z.x);\n        dr = pow(r - .2 * sin(TIME *7.5 + offset), power - 1.0) * power * dr + 1.0;\n\n        float zr = pow(r, power);\n        theta = theta * power;\n        phi = phi * power;\n\n        z = zr * vec3(sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi));\n        z += p;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\nvec2 ohkyu(vec3 p)\n{\n    p.xz = sin(p.xz) * 2.01;\n\n    vec3 s =vec3(2.35,1.,2.35);\n    s.xz -= c(sin(vec2(p.y)),-1.)/2.;\n    float boo = sdRoundBox(p,s,.0);\n    float o = boo;\n\n    if(o < 1.0)\n    {\n        o -= noise(p.xz*10.)/100.;\n        p.xy *= rot(0.1);\n        o -= noise(p.xz * 15.) / 100.;\n    }\n    return vec2(o ,OHKYU);\n}\n\nfloat Piller(vec3 p)\n{   \n    p -= vec3(0.,5.,9.5);\n    vec2 id = floor(p.xz /12.);\n    p.xz = mod(p.xz , 12.) - 6.;\n    \n    vec3 bp = p;\n    bp.y += 4.;\n    vec3 bsize = vec3(1.3,1.5,1.3);\n    bsize .xz += smoothstep(1.,0.,bp.y);\n    vec2 pol = Polar(bp.xz);\n    bsize.y -= c(sin(pol.y + rand(id)* 16. ), .7 )/10.;\n    float base = sdRoundBox(bp,bsize,.4);\n    \n    p.xz *= rot(sin(p.y * 1.) + p.y);\n    float ra = .8 - (sin(p.z*10.+ p.x * 6. ) - .5)/27.;\n    float rb = 34.18;\n    float h = 5.1 + (rand(id) - .1 ) * 8.;\n    p.y += c(sin((p.x + p.y + rand(id))*4. )/6.,1.);\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    float pile = min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n    float o = min(pile,base);\n\n    if(o < 1.0)\n    {\n        o -= noise(p.xz*10.)/100.;\n        p.xy *= rot(0.1);\n        o -= noise(p.xz * 20.) / 100.;\n    }\n    return o;\n}\n\nvec2 lightBall(vec3 p)\n{\n    p -= PointLightPosition;\n    float o = length(p) - (c(cos(TIME)+ 1.,1.) + 1.8)/10.;\n    return vec2(o,LIGHTBALL);\n}\n\nvec2 meatkun(vec3 p)\n{\n    p.y -= roof;\n    float offset = length(p);\n    p.x += 16.;\n    vec2 pos = p.xz;\n    p.xz = sin(p.xz);\n    p.xz *= rot(length(p.xz) + noise(pos.xy) * 1.);\n    \n    p -= vec3(0.,10.,1.);\n    float o = deMandelbulb(p, 8.0 , offset);\n    for(int i = 0; i < 3 ; i++)\n    {\n        p = abs(p) - 0.7;\n        p.xz *= rot(0.3);\n        p.xz *= rot(p.y * 1.);\n        o = smoothMin(deMandelbulb(p,2.0,offset + float(i) + noise(p.xz) * 35. ),o,3.);\n    }\n    return vec2(o,MEAT);\n}\n\nvec2 meatkunEye(vec3 p)\n{   \n    p.y -= roof;\n    vec2 id = floor(p.xz / 3.);\n    vec2 fid = fract(p.xz /3.);\n    \n    float t = TIME / 14. + rand(id) * 16.;\n    float Kokunoise = (noise(id + t) +noise(id + t) +noise(id + t ) +noise(id +t) +noise(id + t))/5.;\n    float angleA = (Kokunoise - .5) * 2. * pi;\n    \n    p.xz = mod(p.xz,3.) -1.5;\n    \n    p.y -= Eyeroof;\n    p = RotMat(p,normalize(vec3(0.,1.,0.)),angleA);\n    p.y += tan(rand(id) * 15. + (TIME )/2. * fallenEye); \n    \n    p.y -= 6.9;\n    float o = length(p) - 0.4;\n    \n    p.z = abs(p.z);\n    p -= vec3(0.,0.,.3);\n    float o2 = length(p) - .2;\n    o = min(o,o2);\n    return vec2(o,EYE);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 o = ohkyu(p);\n    o.x = min(Piller(p),o.x);\n    o = smin2(meatkun(p),o);\n    o = smin2(meatkunEye(p),o);\n    \n    o = min2(lightBall(p),o);\n    o.x *= 0.9;\n    return o;\n}\n\nvec2 march(vec3 cp , vec3 rd)\n{\n    depth = 0.;\n    float id = 0.;\n    for(int i = 0 ; i < MAXSTEP ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < .001)\n        {\n            depth *= -1.;\n            id = d.y;\n            break;\n        }\n        if(depth > 150.){break;}\n        depth += d.x;\n        cycles += 1.;\n    }\n    depth *= -1.;\n    return vec2(depth,id);\n}\n\nfloat getPlight(vec3 pos,vec3 N,vec3 lpos,float brightness)\n{\n    vec3 pl2surf = lpos - pos;\n    float point = clamp( dot(normalize(pl2surf),N),0.,1.) * (brightness/pow(length(pl2surf),1.7));\n    return point;\n}\n\nfloat ndfGGX(float nh, float roughness)\n{\n    nh = nh * nh;\n    roughness *= roughness;\n    return exp((nh - 1.) / (roughness * nh))/ (pi * roughness * nh * nh);\n}\n\nfloat C(float nl, float nv, float nh, float vh)\n{\n    return min(1. ,min(2. * nh * nv / vh,2. * nh * nl  / vh ));\n}\n\nfloat fresnelSchlick(float nv, float fresnel)\n{\n    return max(0.,fresnel + (1. - fresnel) * pow(1. - nv, 5.));\n}\n\nfloat lighting(vec3 rd, vec3 light,vec3 N, vec2 param)\n{\n    vec3 view = rd;\n    vec3 hlf = normalize(light + view);\n    float nl = dot(N,light);\n    float nv = dot(N,view);\n    float nh = dot(N,hlf);\n    float vh = dot(view,hlf);\n    \n    float fresnel = .4;\n    float roughness = .3;\n    //vec2(fresnel,roughness)\n    vec2 para = param;\n    \n    float dte = ndfGGX(nh , para.y);\n    float gte = C(nl,nv,nh,vh);\n    float fte = fresnelSchlick(nv,para.x);\n\n    float sp = max(0.,dte * gte * fte / (nl * nv * 4.) * nl);\n\n    return sp;\n}\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p;\n    p = vec2((p.y>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat mozi(vec2 p)\n{\n    p*= 1.12;\n    float ratio = iResolution.x / iResolution.y;\n    p += vec2( ratio,ratio/2.);\n    float o = step(.09,length(p - vec2(0.,0.01)));\n    o *= step(0.01,sdHorseshoe(p * rot(pi/1.95) + vec2(0.02,0.2),vec2(pi),.05,vec2(.005)));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.16,0.06)) * rot(pi/4.),vec2(.11),vec2(0.),.01));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.20,-0.03)) ,vec2(.055),vec2(0.),.01));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.31,0.07)) * rot(pi/4.),vec2(.11),vec2(0.),.01));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.31,0.065)) * rot(-pi/4.),vec2(.06),vec2(0.),.01));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.31,-0.01)) * rot(-pi/4.),vec2(.055),vec2(0.),.01));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.31,-0.09)) * rot(-pi/4.),vec2(.06),vec2(0.),.01));\n    o *= step(0.01,sdHorseshoe((p + vec2(-0.51,-0.01))* rot(-pi/2.) ,vec2(pi),.075,vec2(.005)));\n    return o;\n}\n\nfloat mozi2(vec2 p)\n{\n    p*= 1.1;\n    float ratio = iResolution.x / iResolution.y;\n    p += vec2( ratio,-ratio/2.);\n    float o = step(0.01,sdOrientedBox((p  + vec2(-0.16,0.06)) * rot(pi/4.),vec2(.11),vec2(0.),.05));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.25,0.06)) * rot(pi/4.),vec2(.11),vec2(0.),.05));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.34,0.06)) * rot(pi/4.),vec2(.11),vec2(0.),.05));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.37,0.015)) * rot(pi/4.),vec2(.05),vec2(0.),.05));\n    return o;\n}\n\nfloat frame(vec2 p)\n{\n    p*= 1.001;\n    float ratio = iResolution.x / iResolution.y;\n    p += vec2( ratio,-ratio/2.);\n    float o = step(0.01,sdOrientedBox((p  + vec2(-0.08,0.57)) * rot(pi/4.),vec2(.45),vec2(0.),.003));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.076,-0.065))* rot(-pi/4.) ,vec2(.6),vec2(0.),.003));\n    \n    o *= step(0.01,sdOrientedBox((p  + vec2(-3.45,0.57)) * rot(pi/4.),vec2(.45),vec2(0.),.003));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-2.6,-0.065))* rot(-pi/4.) ,vec2(.6),vec2(0.),.003));\n    \n    o *= step(0.01,sdOrientedBox((p  + vec2(-3.45,1.8)) * rot(pi/4.),vec2(.45),vec2(0.),.003));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-2.6,1.8))* rot(-pi/4.) ,vec2(.6),vec2(0.),.003));\n    \n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.08,1.8)) * rot(pi/4.),vec2(.45),vec2(0.),.003));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.076,1.8))* rot(-pi/4.) ,vec2(.6),vec2(0.),.003));\n    return o;\n}\n\nvec3 cp,cu,cs,cd,target,forward;\nfloat fov;\nfloat EFFECT = 0.;\n#define Scene1 8.\n#define Scene2 24.\n#define Scene3 34.\n#define Scene4 41.\n#define Scene5 46.\n#define Scene6 70.\n#define Scene7 75.\nvec2 cameraControl(vec2 p)\n{\n    float t = TIME ;\n    forward = vec3(0.);\n    cp = vec3(0.);\n    target = vec3(0.,5.,3.) + forward;\n    fallenEye = 1.5;\n    cd = normalize(target - cp);\n    cs = normalize(cross(cd , vec3(0.,1.,0.)));\n    cu = normalize(cross(cd,cs));\n    float Kokunoise1 = 5. * noise(vec2(TIME + pi))/5.;\n    float Kokunoise2 = 5. * noise(vec2(TIME/10.))/5.;\n\n    vec2 Tspeed = vec2(t/6.);\n    vec3 tebure = 6. * (vec3(fbm((Tspeed) * 5.)/5.,(fbm(Tspeed + vec2(pi)))*5./5.,(fbm(Tspeed + vec2(pi * 2.43 ) )) * 5. /5. ) - vec3(.3) );\n    if(TIME < Scene1)\n    {//TPS\n        t -= 0.;\n        MOZI = 1.;\n        roof = 36.;\n        Eyeroof = 0.;\n        fallenEye = 0.;\n        forward = vec3(0.);\n        fov = 2. - dot(p,p)/10.;\n        forward.z += TIME * 3.5;\n        PointLightPosition = vec3(0.,5.,-7.) + vec3(sin(TIME),-1. + Kokunoise1 ,6.+Kokunoise2 * 3.) + forward;\n        \n        target = PointLightPosition;\n        cp += vec3(1.3,35.,-0.5) ;\n    }\n    else if(TIME < Scene2)\n    {//FPS\n        t-= Scene1;\n        MOZI = 0.;\n        roof = 46.;\n        fallenEye = .001;\n        forward = vec3(0.);\n        fov = 2. - dot(p,p)/10. + (S(0.,1.,(t * 1.4) - 9.) ) * 1.3;\n        forward.z += TIME * 3.5;\n        cp += vec3(0.,5.,-7.) + forward;\n        target = vec3(0.,5.,3.) + forward + tebure;\n        cp.y ,target.y+= abs(sin(TIME*5.))/8. + Kokunoise1/6.;\n        p *= rot((Kokunoise1 - .5)/10.);\n        \n        PointLightPosition = cp + vec3(sin(TIME),-1. + Kokunoise1 ,6.+Kokunoise2 * 3.);\n        \n    }else if(TIME < Scene3){\n        //FPS\n        t -= Scene2;\n        MOZI = 0.;\n        roof = 46.;\n        fallenEye = 0.;\n        forward = vec3(0.);\n        fov = 2.  - dot(p,p)/10. + (S(0.,1.,(t * 1.6) - 1.) ) +  S(1.,0.,(t * 1.3) - 5.) * 1.3;\n        forward.z += TIME * 3.5;\n        cp += vec3(0.,5.,-7.) + forward;\n        target = vec3(0.,5.,3.) + forward + tebure;\n        cp.y ,target.y+= abs(sin(TIME*5.))/8. + Kokunoise1/6.;\n        float left = ( S(0.,1.,t/2.) * S(1.,0.,t/2. - 1.3) )/ 1.9;\n        float right =(-S(0.,1.,t/2.4- 1.8) * S(1.,0.,t/2.4 - 3.) )/ 1.8;\n        target.xz *= rot(left + right);\n        p *= rot((Kokunoise1 - .5)/10.);\n\n        PointLightPosition = cp + vec3(sin(TIME),-1. + Kokunoise1 ,6.+Kokunoise2 * 3.);\n    }else if(TIME < Scene4){      \n            //TPS\n            t -= Scene3;\n            MOZI = 1.;\n            roof = 36.;\n            fallenEye = 0.;\n            forward = vec3(0.);\n            fov = 2. - dot(p,p)/10.;\n            forward.z += TIME * 3.5;\n            PointLightPosition = vec3(0.,5.,-7.) + vec3(sin(TIME - 8.),-1. + Kokunoise1 ,6.+Kokunoise2 * 3.) + forward - vec3(0.,0.,18.);\n            \n            target = PointLightPosition;\n            cp += vec3(9.,15.,30.*3.5) ;\n\n    }else if (TIME < Scene5)\n    {//FPS\n        t-= Scene4;\n        MOZI = 0.;\n        roof = 46.;\n        fallenEye = .001;\n        forward = vec3(0.);\n        fov = 2. - dot(p,p)/10. + (S(0.,1.,(t * 1.4) - 9.) ) * 1.3;\n        forward.z += TIME * 3.5;\n        cp += vec3(0.,5.,-7.) + forward;\n        target = vec3(0.,5.,3.) + forward + tebure;\n        cp.y ,target.y+= abs(sin(TIME*5.))/8. + Kokunoise1/6.;\n        p *= rot((Kokunoise1 - .5)/10.);\n        \n        PointLightPosition = cp + vec3(sin(TIME),-1. + Kokunoise1 ,6.+Kokunoise2 * 3.);\n    }else if(TIME < Scene7)\n    {//FPS\n        t-= Scene5;\n        MOZI = 0.;\n        roof =  S(1.,0.,(t/2. - 2. )) * 10.  - 6. + S(1.,0.,t/3. -6.) * 13. ;\n        fallenEye = mix(0.,.7,SAT(t/2. - 5.));\n        forward = vec3(0.);\n        fov = 2. - dot(p,p)/10.;\n        forward.z = mix(TIME * 3.5,3.5 * (Scene5 + 0.),SAT(t/5. + 1.)); \n        cp += vec3(0.,5.,-7.) + forward;\n        target = vec3(0.,5.,3.) + forward + tebure;\n        target.y += mix(0.,10.,SAT(t/5. - 0.1));\n        cp.y ,target.y+= (abs(sin(TIME*5.))/9. + Kokunoise1/6. )* mix(1.,0.,SAT(t/5.));\n    //    target.y -= 2.5;\n        p *= rot((Kokunoise1 - .5)/10.);\n        cp.y +=mix(0.,.4,SAT(t/5. - 0.1)) ;\n        \n        PointLightPosition = cp + vec3(sin(TIME),-1. + Kokunoise1 ,6.+Kokunoise2 * 3.);\n        PointLightPosition.y +=  mix(0.,15.,SAT(t/5.)); \n    }\n    \n    cd = normalize(target - cp);\n    cs = normalize(cross(cd , vec3(0.,1.,0.)));\n    cu = normalize(cross(cd,cs));\n    \n    return p;\n}\n\nvec3 scene(vec2 p)\n{\n    \n    fov = 2. - dot(p,p)/10.;\n    p = cameraControl(p);\n\n    vec3 rd = normalize(vec3(p.x * cs + p.y * cu + cd * fov));\n    // if(EFFECT < .5)\n    // {\n    //    // rd += (vec3(-0.5) + vec3(fbm(p * 13.),fbm(p * 18.) , fbm(p * 22.)) ) * SAT( length(p) - (sin(TIME) +1. ) /2.);\n    //     rd = normalize(rd);\n    // }else{\n    //     float bb = 11.;\n    //     rd += (vec3(-0.5) + vec3(rand(p * 13.),rand(p * 18.) , rand(p * 22.)) ) * (SAT( step(0.2,abs(p.x) - 16./bb) + step(0.2,abs(p.y) - 16./bb)) * (length(p) - 16./bb) );\n    //     rd = normalize(rd);\n    // }\n    \n    vec2 d = march(cp,rd);\n    \n    vec3 sun = -normalize(vec3(2.,1.,8.));\n    vec3 sky = vec3(0.,0.,0.);\n    vec3 col = sky;\n    \n    vec3 ocol = sky;\n    if(d.x > 0.)\n    {\n        col = vec3(0.);\n        vec2 e = vec2(0.0001,0.0);\n        vec3 pos = depth * rd + cp;\n        vec3 N = -normalize(vec3(map(pos).x - vec3(map(pos - e.xxy).x,map(pos - e.xyx).x,map(pos - e.yxx).x)));\n        vec3 pointLightPos = PointLightPosition; \n        vec3 PL2Surf = (pointLightPos - pos);\n        \n        if(true)\n        {\n            float Kokunoise = (noise(vec2(TIME))*5.) / 5.0;\n            col = vec3(.9,0.3,0.5);\n            float brightness = 28. * Kokunoise;\n            float point = getPlight(pos,N,pointLightPos,brightness);\n            float diff = max(0.,dot(sun,N)) * .5 + .5;\n            float shadowStrength = 1.;\n                \n            if(int(d.y) == LIGHTBALL)\n            {\n                col = vec3(1.,1.,1.) * Kokunoise * 2.;\n            }else if(int(d.y) == MEAT)\n            {\n                vec3 mCol = vec3(.9,0.01,0.);\n                vec3 Meat = SAT(mCol/6. + mCol * mix(noise(pos.xz * 10. + TIME),1.,.2));\n                float sp = lighting(rd,normalize(pointLightPos - pos),N,vec2(1.4,0.1));\n                float sss = S(0.,1.,map(pos + normalize(pointLightPos - pos) * .4).x/.8);\n                point += sss;\n                col = point * Meat + sp * Meat * point;\n            }else if(int(d.y) == EYE)\n            {\n                pos.y -= roof;\n                vec2 id = floor(pos.xz / 3.);\n                float t = TIME / 14. + rand(id) * 16.;\n                float Kokunoise = (noise(id + t) +noise(id + t) +noise(id + t ) +noise(id +t) +noise(id + t))/5.;\n                float angleA = (Kokunoise - .5) * 2. * pi;\n    \n                pos.xz = mod(pos.xz,3.) -1.5;\n                //p.xz -= id + fid;\n                pos = RotMat(pos,normalize(vec3(0.,1.,0.)),angleA);\n                //pos.y += rand(id) * 15.; \n                pos.y -= Eyeroof;\n                pos.y += tan(rand(id) * 15. + (TIME)/2. * fallenEye);\n                pos.y -= 6.9;\n                vec2 pol = Polar(pos.xy);\n                float whiteEye = 1. - noise(pol.xx * 1000.) * noise(pol * 10.) ;\n                col = (vec3(.6,.3,.5) + vec3(whiteEye,0.,0.)) * step(0.2,length(pos.xy));\n                col += S(noise(pol.xx * 100.), (sin(pol.x * 40.) + 1.) / 2.,.3) * vec3(1.,0.,0.) * step(length(pos.xy),0.17);\n                col = col * step(0.1,length(pos.xy)) + step(length(pos.xy),0.03);\n                float sp = lighting(rd,normalize(pointLightPos - pos),N,vec2(30.4,0.1));\n                float sss = S(0.,1.,map(pos + normalize(pointLightPos - pos) * .4).x/.2);\n                point += sss;\n                col = point * col + sp * col * point;       \n            }\n            else{\n                float sp = lighting(rd,normalize(pointLightPos - pos),N,vec2(1.,30.));\n                col =   point * vec3(0.5,0.5,0.8) + sp * vec3(.3,.7,0.2) * point ;\n            }\n            \n        }\n        ocol = mix(col,sky,1.-exp(-0.00007 * d.x * d.x * d.x));\n    }\n\n    return ocol;\n}\n\nvec3 blur(vec2 f)\n{\n    vec2 resolution = iResolution.xy;\n    vec3 ocolor = vec3(0.);\n    for(int i = 0;i < 3;i++ )\n    {\n        for(int j = 0; j < AA;j++)\n        {\n            vec2 d = vec2(float(i),float(j)) - vec2(float(i),float(j))/2.;\n            d /= float(AA);\n            vec2 p = ((f + d) * 2.0 - resolution.xy)/min(resolution.x,resolution.y);\n            vec2 rough = resolution.xy/6.;\n            p = floor(p * rough) /rough;\n            ocolor += scene(p);\n        }\n    }\n    ocolor /= float(AA * AA);\n    return ocolor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x,iResolution.y);\n    \n    p.y*= -1.;\n    \n    float addtime =Scene3 + 1.;\n    \n   TIME = mod(iTime,Scene7);\n    EFFECT = 0.0;\n    if(TIME < Scene1)\n    {\n        EFFECT = 0.;\n    }\n    else if(TIME < Scene2)\n    {//FPS\n        EFFECT = 1.;\n    }else if(TIME < Scene3)\n    {//FPS\n        EFFECT = 1.;\n    }else if(TIME < Scene4){\n        //TPS\n        EFFECT = 0.0;\n    }else if(TIME < Scene5){\n        //FPS\n        EFFECT = 1.0;\n    }else if(TIME < Scene6){\n        //FPS\n        EFFECT = 1.0;\n    }else if(TIME < Scene7)\n    {\n        EFFECT = 1.0;\n        p.x += rand(p.yy + sin(iTime )) * 10.;\n    }\n    \n    vec3 col = vec3(0.);\n    col = scene(p);\n    \n    if(EFFECT > 0.)\n    {\n        vec3 hsv = rgb2hsv(col);\n        hsv.y = SAT(hsv.y /0.9);\n        hsv.z = SAT(hsv.z * 1.1 + 0.01);\n       // col = hsv;\n        col = hsv2rgb(hsv);\n        vec3 rgb = mix(vec3(1.),vec3(0.), vec3(fbm(p * 200.) ,fbm(p * 300.) ,fbm(p * 296.)  ) * noise(p*670.));\n        col =  (col * rgb) + rgb/30.;\n        col = SAT(vec3(.7,.7,1.5) * col );\n        \n    }else{\n        vec3 hsv = rgb2hsv(col);\n      //  hsv.x = SAT(hsv.x /2.5);\n        hsv.y = SAT(hsv.y );\n        hsv.z = SAT(hsv.z * 1.3 + 0.001);\n        col = hsv;\n        col = hsv2rgb(hsv);\n\n        col = SAT(vec3(.7,.7,1.5) * col );\n    }\n\n    col = mix(vec3(1.,0.,0.),col ,clamp(0.,1.,mozi(p) + MOZI));\n    col = mix(vec3(1.,1.,1.),col,clamp(0.,1.,mozi2(p) + MOZI));\n    col = mix(vec3(1.,1.,1.),col,clamp(0.,1.,frame(p) + MOZI));\n    col = pow(col,vec3(.4545 ) );\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "MtBGWV", "previewfilepath": "https://soundcloud.com/tonoshake/ambient", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/tonoshake/ambient", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBBDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[405, 405, 423, 423, 466], [467, 467, 512, 512, 603], [604, 604, 649, 649, 718], [719, 719, 738, 738, 783], [785, 883, 905, 905, 1236], [1238, 1238, 1260, 1260, 1429], [1431, 1431, 1475, 1548, 2040], [2042, 2120, 2147, 2147, 2519], [2539, 2539, 2563, 2585, 2840], [2842, 2842, 2864, 2864, 2970], [2972, 2972, 2995, 2995, 3440], [3442, 3442, 3469, 3469, 3504], [3505, 3505, 3530, 3530, 3565], [3567, 3567, 3587, 3587, 3704], [3706, 3706, 3734, 3734, 3783], [3785, 3785, 3814, 3814, 3922], [3945, 3945, 4001, 4001, 4535], [4537, 4537, 4557, 4557, 4870], [4872, 4872, 4894, 4894, 5747], [5749, 5749, 5773, 5773, 5893], [5895, 5895, 5917, 5917, 6393], [6395, 6395, 6420, 6420, 7049], [7051, 7051, 7069, 7069, 7250], [7252, 7252, 7283, 7283, 7669], [7671, 7671, 7732, 7732, 7882], [7884, 7884, 7925, 7925, 8047], [8049, 8049, 8098, 8098, 8164], [8166, 8166, 8213, 8213, 8279], [8281, 8281, 8337, 8337, 8817], [8819, 8819, 8885, 8885, 9144], [9146, 9146, 9212, 9212, 9429], [9431, 9431, 9451, 9451, 10375], [10377, 10377, 10398, 10398, 10899], [10901, 10901, 10922, 10922, 11831], [12028, 12028, 12056, 12056, 16329], [16331, 16331, 16351, 16351, 20031], [20033, 20033, 20052, 20052, 20570], [20572, 20572, 20629, 20629, 22244]]}
{"id": "wtBBW3", "name": "Anti-alias any shader V2", "author": "GregRostami", "description": "This is SUPER FUN!  Copy/Paste the code to the bottom of any shader to add anti-aliasing.\nA huge thanks to Fabrice's code from this shader that showed me how to do this (see comments):\n[url]https://www.shadertoy.com/view/WlfyW8[/url]", "tags": ["2d", "boxfilter", "tool", "supersample"], "likes": 2, "viewed": 246, "published": "Public API", "date": "1599972458", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This uses an idea that was created by Fabrice Neyret's:\n// https://www.shadertoy.com/view/WlfyW8 \n// It's an improvement to my previous box-filter.\n// Add the extra code at the bottom of this shader to any shader to anti-alias it. \n// \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = iResolution.xy,\n         u = ( 2.*fragCoord - r ) / r.y;\n    float m = 4.* sin(.1*iTime);\n\tfragColor = vec4 (fract( m / length(u) + atan(u.y,u.x)/3.14 + .3*iTime ));\n}\n\n\n// Add this code to the bottom of any shader to add Anti-aliasing:\n// Made a few changes to Fabrice's code:\n// Replaced the single for() loop with double for() loops (x,y) - Because it's faster.\n// Added min(T,1.0) to guarantee the output is maximum value of vec4(1.0)\n// Without the min() function, bright areas do not anti-alias.\n\n#define mainImage(O,U)                                     \\\n    vec4 T;                                                \\\n    int AA = 5, /* Set the Anti-Aliasing level (1-16) higher numbers are SLOW! */ \\\n        x = 0, y;                                          \\\n        float A = float (AA);                              \\\n    for (;x++ < AA;) for (y=0; y++ < AA; O += min(T,1.) )  \\\n        mainImage( T, U + vec2(x,y)/A-.5 );                \\\n    O /= A*A", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBBW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 239, 296, 296, 474]]}
{"id": "wtBBzG", "name": "Let it flow", "author": "Kali", "description": "Overthinking is bad.", "tags": ["3d", "fractal", "volumetric"], "likes": 19, "viewed": 235, "published": "Public", "date": "1599200520", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime*.2\nvec3 col;\nmat2 rot(float a) \n{\n\tfloat s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\nfloat de(vec3 p)\n{\n    float z=p.z,m=1000.,sc=1.;\n    vec3 ot=vec3(1000);\n    p.xy*=rot(p.z * .05 + t * 3.);\n    p=abs(5.-mod(p,10.));\n\tvec3 cp=p;\n    for (int i=0;i<10;i++) \n    {\n        p.xy=abs(p.xy+.5)-abs(p.xy-.5)-p.xy-1.;\n        p.yz*=rot(t);\n        float s=-2.5/clamp(dot(p,p),.0,1.);\n        p=p*s-1.;\n        sc*=s;\n        ot=min(ot,abs(p.yzz));\n        m=min(m,abs(p.z));\n    }\n    m=exp(-1.*m);\n    col=exp(-2.*ot)+m*.5;\n    col*=fract(-t*3.+m*.3+z*.05)*4.;\n    return (p.x/sc-.5)*.8;\n}\nvec3 march(vec3 from, vec3 dir) \n{\n\tfloat d,td=0.;\n    vec3 p, c=vec3(0), ot=vec3(1000);\n    for (int i=0; i<70; i++) \n    {\n        p=from+dir*td;\n        d=de(p);\n        td+=max(.002, abs(d));\n        if (td>50.) break;\n        c+=col*max(0.,1.-d)*exp(-.05*td); \n    }\n   \treturn pow(c*.02,vec3(1.5));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord-iResolution.xy*.5)/iResolution.y;\n \tvec3 dir = normalize(vec3(uv, .7)),from = vec3(cos(t*2.) * 0., 1., t*10.);\n    dir.xz *= rot(smoothstep(-.3,.3,sin(t))*3.);\n\tvec3 c = march(from, dir);\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBBzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 49, 49, 104], [105, 105, 123, 123, 606], [607, 607, 641, 641, 913], [914, 914, 971, 971, 1213]]}
{"id": "wtBBzK", "name": "Rainbow Spaz out sun", "author": "celifrog", "description": "This looks cool omg.", "tags": ["psychedelic", "universe", "other"], "likes": 1, "viewed": 145, "published": "Public API", "date": "1599318027", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//    fragColor = texture(iChannel0, (floor( (fragCoord*.98 + iResolution.xy*.01 + (fragCoord-iResolution.xy/2.).yx*vec2(-.03,.03)) )+.5) / iResolution.xy);\n    fragColor = texture(iChannel0, (fragCoord*.98 + iResolution.xy*7.01 + (fragCoord-iResolution.xy/2.).yx*vec2(-.03,.03)) / iResolution.xy);\n    \n    float t = iTime*19.90;\n\n    vec4 col = vec4(sin(-t*-vec3(3,11,171))*.5+.5,1);\n    float idx = .0+1.0*smoothstep( -6., 280., length( fragCoord - sin(vec2(11,13)*t)*-6. - iResolution.xy/5. ) );\n    fragColor = mix( -col *-col, fragColor, idx * idx );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBBzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 214, 616]]}
{"id": "wtBBzV", "name": "3D Evergreen", "author": "logangilmour", "description": "Carve up space to render tree!", "tags": ["tree"], "likes": 4, "viewed": 110, "published": "Public", "date": "1599344067", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// DERIVED FROM:\n\n// The MIT License\n// Copyright  2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A list of useful distance function to simple primitives. All\n// these functions (except for ellipsoid) return an exact\n// euclidean distance, meaning they produce a better SDF than\n// what you'd get if you were constructing them from boolean\n// operations.\n//\n// More info here:\n//\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\n//------------------------------------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nconst float pi = 3.1459;\n\nvec2 perp(vec2 p){\n    return vec2(p.y,-p.x);\n}\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nvec2 warp(vec2 p, int seed){\n     return vec2(noise(p*2.+vec2(seed)),noise(p*2.+vec2(seed+100)))*0.04+vec2(noise(p/2.+vec2(seed+100)),noise(p/2.+vec2(seed+200)))*0.2;\n}\n\n\n\nfloat needles(vec3 wpos,vec3 A, vec3 B,float scale){\n\tvec3 dir = B-A;\n    float len = length(dir);\n    dir = dir/len;\n    vec3 up= vec3(0,1,0);\n    vec3 left = cross(up,dir);\n    float period = .0007;\n    vec3 wsp = wpos-A;\n    vec3 nsp = vec3(dot(wsp,left),dot(wsp,dir),dot(wsp,up));\n    float rot = atan(nsp.z,nsp.x);\n    float phase = (rot+pi)/(pi*2.);\n    \n    nsp.y = clamp(nsp.y,0.,len);\n    float wrap = nsp.y/period+phase*period;\n    \n    float nearest = max(floor(wrap/0.6)*0.6+pi/4.,0.);\n    \n    vec3 A2 = A+dir*nearest*period;\n\tvec3 dir2 = A2+(up*sin(nearest)+left*cos(nearest))*(0.02+scale*2.);\n    \n    return min(\n        sdCapsule(wpos,A,B,scale*0.3)\n        ,sdCapsule(wpos,A2,dir2,0.001))\n        ;\n}\n\nfloat branch(vec3 wpos, vec3 pos3, vec3 dir3){\n    int seed = 0;\n    float theta = pi/8.;\n    float dotperp = 0.;\n    float minp = 1000.;\n    vec2 uv = wpos.xz;\n    float scale = clamp(0.2-pos3.y*0.2,0.,0.5);\n\n    vec2 pos = pos3.xz;\n    vec2 dir = dir3.xz;\n\t//vec2 pos = vec2(0,-1);\n    \n    mat2 m = mat2(cos(theta),-sin(theta),sin(theta),cos(theta));\n    \n    int path = seed;\n    for(int i=0; i<4; i++){\n\t\tvec2 A = pos;\n        vec2 B = pos+dir*scale;\n    \tvec2 pa = uv-A;\n        vec2 ba = B-A;\n        \n        vec2 per = perp(dir);\n        \n        \n        \n        dotperp = dot(per,uv-pos);\n        bool side = dotperp>0.;\n        path = path*2+int(side);\n        \n        mat2 ms = m;\n        float sgn = float(side)*2.-1.;\n        ms[0][1]*=sgn;\n        ms[1][0]*=sgn;\n        vec2 newdir = ms*dir;\n        \n        float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n        float len = needles(wpos,vec3(A.x,pos3.y,A.y),vec3(B.x,pos3.y,B.y),0.002+scale*0.05);\n        minp = min(len,minp);\n        \n        pos += dir*scale;\n        dir = newdir;\n        //theta += (rand(vec2(float(path*10),0.))*2.-1.)*0.3;\n        scale = scale/1.5;\n    }\n    return minp;\n    \n}\n\nfloat tree(vec3 wpos){\n    wpos.y+=1.;\n    float period = 0.06;\n    \n    float rot = atan(wpos.z,wpos.x);\n    float phase = (rot+pi)/(pi*2.);\n    wpos.y = clamp(wpos.y,-1.3,1.1);\n    float wrap = wpos.y/period+phase*period;\n    \n    float nearest = max(-20.,floor(wrap/1.4)*1.4+pi/4.);\n    \n    vec3 A = vec3(0,nearest*period,0);\n\n    \n    return min(sdCapsule(wpos,vec3(0,-1.2,0),vec3(0,1,0),0.025-wpos.y*0.02),branch(wpos,A, vec3(cos(nearest),0,sin(nearest))));\n    \n}\n\n\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    {\n      res = opU( res, vec2( tree(pos), 1 ) );\n              res = opU( res, vec2( tree(pos*0.5-vec3(1,1,1)), 1 ) );\n\n    }\n    \n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n\n    float t = tmin;\n        for( int i=0; i<100 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0002*t) )\n            { \n                res = vec2(t,1); \n                break;\n            }\n            t += pow(h.x,1.3)*0.3;\n        }\n    \n    return res;\n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    \n\n\treturn vec3( clamp(m,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0.5, -0.5, -0.6 );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time), 1.3, 4.5*sin(0.1*time) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.5) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,2.5) );\n        vec3 rdy = ca * normalize( vec3(py,2.5) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = 1.-pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBBzV.jpg", "access": "shaders20k", "license": "mit", "functions": [[1558, 1627, 1652, 1652, 1671], [1672, 1672, 1697, 1697, 1716], [1717, 1717, 1753, 1753, 1781], [1784, 1784, 1819, 1819, 1845], [1847, 1847, 1899, 1899, 2013], [2016, 2016, 2036, 2036, 2108], [2136, 2136, 2154, 2154, 2183], [2185, 2185, 2242, 2242, 2357], [2359, 2359, 2385, 2385, 2864], [2866, 2866, 2894, 2894, 3034], [3038, 3038, 3090, 3090, 3756], [3758, 3758, 3804, 3804, 4937], [4939, 4939, 4961, 4961, 5409], [5414, 5484, 5514, 5514, 5547], [5649, 5719, 5744, 5744, 5936], [5938, 6006, 6057, 6057, 6262], [6264, 6264, 6304, 6304, 6688], [6693, 6693, 6758, 6758, 6871], [6873, 6873, 6925, 6925, 7102], [7104, 7104, 7161, 7161, 8448]]}
{"id": "WtBfDw", "name": "Broken-ass raymarching terrain", "author": "Tatti", "description": "Broken attempt at a raymarching terrain", "tags": ["raymarching", "terrain"], "likes": 4, "viewed": 98, "published": "Public", "date": "1599044361", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void rotate(inout vec3 vector, vec2 angle){\n\tvector.yz = cos(angle.y) * vector.yz + sin(angle.y) * vec2(-1, 1) * vector.zy;\n    vector.xz = cos(angle.x) * vector.xz + sin(angle.x) * vec2(-1, 1) * vector.zx;\n}\n\nfloat smoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sphereSdf(vec3 center, float radius, vec3 pos){\n\treturn length(center - pos) - radius;\n}\n\nfloat planeSdf(vec3 normal, float height, vec3 pos)\n{\n  \treturn dot(pos, normal) + height;\n}\n\nfloat repeatedSpheresSdf(float radius, vec3 pos) {\n    pos.x = mod(pos.x, 1.) - .5;\n    pos.z = mod(pos.z, 1.) - .5;\n    return sphereSdf(vec3(0), radius, pos);\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\nfloat noise(vec3 pos){\n    vec3 a = floor(pos);\n    vec3 d = pos - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat terrainSdf(vec3 pos) {\n    float r = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for(int i = 0; i < 8; i++) {\n        r += amp * noise(freq*pos);\n        amp *= 0.5;\n        freq *= 1.0/0.5;\n    }\n    float d = planeSdf(vec3(0, 1, 0), 1., pos);\n    return d - 0.5*pow(r, 2.0);\n}\n\nfloat sceneSdf(vec3 pos){\n    float sphere = sphereSdf(vec3(sin(-iTime * 3.) * 2., -1, cos(-iTime * 3.) * 2.), 1., pos);\n    return smoothUnion(sphere, terrainSdf(pos), 1.);\n}\n\nfloat superellipsoidSdf(vec3 centre, float radius, float power, vec3 pos)\n{\n    pos = abs(pos-centre)/radius; // scale and sign-flip pos into a [0,1] range\n    pos = pow(pos,vec3(power)); // apply power before summing components\n    float d = dot(pos,vec3(1)); // add the components together\n\td = pow(d,1./power); // apply inverse power so SDF is well behaved\n    float fix = min(1.,.5+.5*(power-1.)); // corrective factor for lower powers, ensure gradient of SDF doesn't exceed 1.\n    return fix*(d-1.)*radius; // undo the scaling, to hit the desired radius\n}\n\nvec3 ray1(vec3 ray, vec3 pos){\n\tvec3 clearColor = vec3(0.55);\n\tvec3 colorToReturn = clearColor;\n    \n    for(int i = 0; i < 200; i++){\n    \tfloat h = sceneSdf(pos);\n        \n        if(length(pos) > 25.){\n            break;\n        }\n        \n        if(h < .01){\n        \tcolorToReturn = vec3(0);\n            break;\n        }\n        \n        pos += ray * h;\n    }\n    \n    if(sceneSdf(pos) < .01){\n    \tvec3 normal;\n        normal.x = sceneSdf(pos + vec3(.01, 0, 0)) - sceneSdf(pos - vec3(.01, 0, 0));\n        normal.y = sceneSdf(pos + vec3(0, .01, 0)) - sceneSdf(pos - vec3(0, .01, 0));\n        normal.z = sceneSdf(pos + vec3(0, 0, .01)) - sceneSdf(pos - vec3(0, 0, .01));\n        normal = normalize(normal);\n        \n        vec3 lightSource = vec3(4, 4, -4);\n        float light = max(.0, dot(normal, normalize(lightSource - pos)));\n        \n        vec3 ambient = vec3(.05, .1, .15);\n        vec3 lightCol = vec3(1., .9, .8);\n        \n        vec4 textureColor = texture(iChannel0, pos.xz);\n        colorToReturn = (light* .4 * lightCol + ambient) * 0.7;\n    }\n    \n    return pow(colorToReturn, vec3(1.0 / 2.2));\n}\n\nvec3 ray2(vec3 ray, vec3 pos){\n\tvec3 clearColor = vec3(0);\n\tvec3 colorToReturn = clearColor;\n    \n    for(int i = 0; i < 200; i++){\n    \tfloat h = repeatedSpheresSdf(0.02, pos);\n          \n        if(length(pos) > 10.){\n            break;\n        }\n        \n        if(h < .01){\n        \tcolorToReturn = vec3(0, 1, 1);\n            break;\n        }\n        \n        pos += ray * h;\n    }\n    \n    return colorToReturn;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ray = normalize(vec3((fragCoord-iResolution.xy * .5) / iResolution.x, 1.));\n    vec3 pos = vec3(0, 0, -8);\n    \n\tvec2 angle = vec2(iTime, .3);\n    \n    rotate(ray, angle);\n   \trotate(pos, angle);\n    \n    fragColor.rgb = ray1(ray, pos);\n    \n    vec3 ray2 = ray2(ray, pos);\n    \n    if(ray2 != vec3(0)){\n        fragColor.rgb = ray2;\n    }\n    \n    for(int i = 0; i < 200; i++){\n        float sprEl = superellipsoidSdf(vec3(0, 1, 0), .7,1. / (.5 + .48 * sin(iTime * 1.3)), pos);\n    \tfloat h = smoothUnion(sprEl, sphereSdf(vec3(0, sin(iTime) * 2., 0), .5, pos), 1.);\n       \n        if(h < .01){\n        \tfragColor.rgb *= vec3(.5, 2., 2.) * \n                texture(iChannel1, (fragCoord.xy / iResolution.xy)).xyz;\n            break;\n        }\n        \n        pos += ray * h;\n    }\n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBfDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 208], [210, 210, 258, 258, 358], [360, 360, 413, 413, 454], [456, 456, 509, 509, 548], [550, 550, 600, 600, 712], [714, 714, 736, 736, 781], [782, 782, 802, 802, 847], [848, 848, 866, 866, 905], [906, 906, 928, 928, 1423], [1425, 1425, 1453, 1453, 1717], [1719, 1719, 1744, 1744, 1894], [1896, 1896, 1971, 1971, 2456], [2458, 2458, 2488, 2488, 3579], [3581, 3581, 3611, 3611, 4000], [4002, 4002, 4059, 4059, 4853]]}
{"id": "wtBfRV", "name": "Yet another plasma", "author": "codecontemplator", "description": "Polar coordinates distorted by perlin noise.", "tags": ["learning"], "likes": 6, "viewed": 220, "published": "Public API", "date": "1599327956", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float mirrored(float v) {\n    float m = mod(v, 2.0);\n    return mix(m, 2.0 - m, step(1.0, m));\n}\n\n//\tClassic Perlin 2D Noise \n//\tby Stefan Gustavson\n//\n// ref: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ar = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - vec2(1.0);\n\tuv.y /= ar;\n      \n\tvec2 uvd = uv + cnoise(uv+vec2(0.4,0.3)*iTime);\n    float r = mirrored(length(uvd)*1.5);\n    float a = atan(uvd.y, uvd.x);\n    \n    float cr = sin(r*10.0+iTime) * 0.5 + 0.5;\n    float ca = sin(a+iTime) * 0.25 + 0.5;\n    float c = cr*ca;\n    vec3 col = vec3(c);\n    vec3 col2 = 0.5 + 0.5*cos(iTime+uvd.xyx+vec3(0,2,4));\n    //col = mix(col, col2, 0.5);\n    col = col * col2;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBfRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 96], [98, 226, 245, 245, 281], [282, 282, 303, 303, 340], [342, 342, 363, 363, 1440], [1442, 1442, 1499, 1499, 2031]]}
{"id": "wtBfWD", "name": "Triangle and Circles", "author": "jasonzil", "description": "A sketch to play with shifting shapes\n\nSmoothstep made the whole thing quite slow", "tags": ["mix"], "likes": 3, "viewed": 93, "published": "Public", "date": "1598941960", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM 3.\n#define AA .01\n#define S(v)  smoothstep(AA,-AA,v)\n\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// All components are in the range [01], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// All components are in the range [01], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Gold Noise 2015 dcerisano@standard3d.com\n// - based on the Golden Ratio\n// - uniform normalized distribution\n// - fastest static noise generator function (also runs at low precision)\n\nfloat PHI = 1.61803398874989484820459;  //  = Golden Ratio   \n\nfloat gold_noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n\nfloat sdf_circle( in vec2 p , float r){\n\treturn distance ( p , vec2(.5))-r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // define scale correctly at all resolutions, thanks @FabriceNeyret2!!!\n    float scale = (NUM + 5.*smoothstep(-.5,.5, sin(iTime))) / iResolution.y;\n    vec2 uv = (fragCoord - iResolution.xy*.5) * scale; // that makes it easy to change the center!\n    \n    vec2 cellVal = floor (uv)+1.;//this +1 is to offset the 0 that is used \n    vec2 cellValOff = floor( uv + vec2(.5)*NUM);\n    uv = fract (uv);\n    vec2 anotherUV = floor(uv * NUM + .5 ) / NUM;\n    vec3 col = vec3(0.0);\n    float sdTri = sdEquilateralTriangle((uv-vec2(.5))*3.);\n    float sdCirc = (sdf_circle(uv, .23));\n    float sd = max(mix(sdCirc,sdTri,cos(iTime*gold_noise(cellVal.xy+1.,1.))),\n                   mix(sdTri,sdCirc,sin(iTime*gold_noise(cellVal.xy+6.,1.))));\n    \n    vec3 niceYellow = vec3(.937,.788,.345);\n    vec3 niceOrange = vec3(.882,.478,.278);\n    vec3 niceTeal = vec3(.29, .694,.616);\n    vec3 niceRed = vec3(.937,.239,.349);\n    \n    vec3 colTri = S(sd) * mix(niceYellow, niceOrange, abs(sin(iTime* .8 + gold_noise(cellVal.xy,1.))));\n    vec3 colCirc = S(sd) * mix(niceRed,niceTeal, abs(cos(iTime*.4+gold_noise(cellVal,1.))));\n\t\t\n        \n    col = mix ( colTri, colCirc, fract(.7*iTime * gold_noise(cellVal,cellVal.x + cellVal.y)));\n        \n\tcol += S(length(col)) * vec3(.2,.3,.32);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBfWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 183, 205, 205, 536], [538, 597, 619, 619, 788], [1019, 1044, 1088, 1088, 1148], [1150, 1150, 1192, 1192, 1403], [1406, 1406, 1445, 1445, 1483], [1485, 1485, 1542, 1619, 2873]]}
{"id": "WtBfzc", "name": "Marching Spines", "author": "j91000", "description": "An infinite ocean of.. somethings. Click and drag to move the camera around.", "tags": ["raymarching", "sdf", "shadows"], "likes": 5, "viewed": 99, "published": "Public", "date": "1599774338", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//render settings\n#define STEPSHRINK 5.0 //increase this value to deal with distance field domain distortion artifacts\n#define MAXSTEPS 5000\n#define CAMDIST 150.\n#define TARGET vec3(0,0.,0);\n#define CAMSTRT vec2(-pi/4.,0.)\n\n#define HITDIST 1.e-1\n#define MAXDIST 1000.\n\n//misc\n#define pi atan(1.0) * 4.0\n#define ZERO min(iFrame,0)\n#define PLANEH -0.\n\n//light and shadow\n#define AMBIENT 0.15 \n#define SUNLIGHT vec3(.7,.6,.5)*.61\n#define FOGDIST .1e-2\n#define FOGCOL vec3(.7,.7,.85)\n\n#define SHADQUAL .8\n#define SHADSMOOTH 20.\n#define SPECULARPOWER 5.\n//ambient occlusion\n#define AO 1. //comment this line to disable ambient occlusion\n#define AODIST 1.8\n#define AOSTEPS 5\n#define AOPOW 2.\n\n\nstruct CastResult\n{\n    vec3 ori;\n    vec3 pos; //hit location\n    vec3 norm; //surface normal\n    vec3 surf; //surface material/albedo\n};\n    \nstruct DirLight\n{\n  \tvec3 dir; //light direction vector\n    vec3 col; //light color*intensity\n};\nstruct MapResult\n{\n    float dist;//distance to scene\n    vec3 color;//surface material color\n    bool volume;//false for the floor, controls coloration in primaryRay()\n};\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{angles=angles.yxz;\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n        return rotX*rotY*rotZ;\n    }\n\nmat3 Rotate(float a1,float a2,float a3){\n return Rotate(vec3(a1,a2,a3));   \n}\n//generates a rotation matrix that rotates (0,0,1) to face in the same\n//direction as dir.\nmat3 camRotation(vec3 dir){\n    dir=normalize(dir);\n    float xRot=atan(dir.z,dir.x)-pi/2.;\n    float yRot=atan(dir.y,length(dir.xz));\n    return Rotate(vec3(xRot,yRot,0));\n}\n//-------------------------------------------------\n\nvec4 elongate( in vec3 p, in vec3 h )\n{\n    return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\nMapResult sdUnion(MapResult a,MapResult b){\n    if(a.dist<b.dist){return a;}\n    return b;\n}\nMapResult sdSub(MapResult a,MapResult b){\n    b.dist*=-1.;\n    if(a.dist>b.dist){return a;}\n    return b;\n}\n//signed distance/material for the floor\nMapResult sdPlane(vec3 pos){\n    return MapResult(pos.y-PLANEH,vec3(.05,.05,.05),false);\n}\n//signed distance/material for the repeated capsule.\n#define RECURSION 0\nMapResult sdVBall(vec3 pos){\n    \n    vec3 c=vec3(3.2,0.,45.);//this is the repetition period in each axis\n    pos.z+=10.*sin(sin(pos.z/100.)*10.+pos.x/10.);//add some warpage to the z dimension\n    vec2 op=pos.xz;//record the world xz location\n    pos= mod(pos+0.5*c,c)-0.5*c;//fold space a bunch\n    op=op-pos.xz;//this makes op into just the cell location, it stays constant inside each cell\n    //pos.xyz=pos.xyz*Rotate(0.,0.,.4*sin(length(op)/4.+iTime/5.));//rotate the cells relative each other\n    pos.y-=sin(length(op)/1.);//make sure the forms jut up, not up+down.\n    float fac=1.+2.*sin(iTime+length(op)/4.);\n    pos.y-=fac;\n    vec4 ePos=elongate(pos,vec3(0.,fac,fac/3.));\n    \n    float size=1.;\n    MapResult result=MapResult(ePos.w+length(ePos.xyz)-size,vec3(.2,.05,.05),true);\n    return result;\n}\n\n\n//calculate the distance to scene/ material properties of closest object\nMapResult map(vec3 pos){\n    MapResult plane=sdPlane(pos);\n    MapResult result=sdVBall(pos);\n    result=sdUnion(result,plane);\n    return result;\n}\n//same as map, but throw away everything but distance\nfloat distToScene(vec3 pos){\n return map(pos).dist;   \n}\n//calculate the norm by sampling the distance field around pos\n//lifted from an iq raymarcher\nvec3 calcNorm(vec3 pos){\n        vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 1.*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*distToScene(pos+0.005*e);\n    }\n    return normalize(n);\n}\n\n//clever ambient occlusion trick described here:\n//https://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf\nfloat ambientOcclusion(vec3 pos,vec3 normal,float sampleDist,float aoPower){\n    #ifdef AO\n    float occlusion=0.;\n    float itC=0.;\n    for(int i=1;i<AOSTEPS;i++){\n     itC++;\n     float term=itC*sampleDist-distToScene(pos+normal*sampleDist*itC);\n        occlusion+=1./pow(2.,itC)*term;\n    }\n    return 1.-clamp(aoPower*occlusion/sampleDist,0.,1.);\n    #else\n    return 1.;\n    #endif\n}\nfloat ambientOcclusion(vec3 pos,vec3 normal,float sampleDist){\n    return ambientOcclusion(pos,normal,sampleDist,AOPOW);\n}\n\n//cast a new ray from surface.pos and see if you hit anything \n//on your way to sun\nfloat occlusion(CastResult surface,DirLight sun){\n    vec3 rayOri=surface.pos+surface.norm*HITDIST*2.;//the ray starts from just above the surface of the hit.\n    vec3 rayPos=rayOri;\n    bool hit=false;\n    float result=1.;\n    for(int steps=ZERO;steps<MAXSTEPS&&(!hit)&&length(rayPos-rayOri)<MAXDIST;steps++){\n        MapResult localState=map(rayPos);\n        float dts=localState.dist;\t//calculate distance to scene\n        hit=dts<HITDIST;\n        result=min(result,SHADSMOOTH*dts/length(rayPos-rayOri));//if close to a surfce, cast a penumbra\n        rayPos-=sun.dir*dts/STEPSHRINK*SHADQUAL;//march\n    }\n    result=hit ? 0.:result; //if you registered a hit, then no light for you!\n    return result; //otherwise return the darkest penumbra you encountered\n}\n\nCastResult primaryRay(vec3 rayOri,vec3 rayVec){\n    \n    bool hit=false;\n    vec3 rayPos=rayOri;\n    MapResult localState;\n    //the conditions here signal to break out of the loop whenever:\n    //\t\tsteps taken exceeds MAXSTEPS; nothing was hit\n    //or\tthe ray's length exceeds MAXDIST; nothing was hit\n    //or\tthe hit flag signals a collision\n    for(int steps=ZERO;steps<MAXSTEPS&&length(rayPos-rayOri)<MAXDIST&&hit==false;steps++){\n        localState=map(rayPos);//get local conditions at rayPos\n        float dts=localState.dist;//extract scene distance\n        hit=dts<HITDIST;\t\t\t  //register a hit, if the distance is small\n        rayPos+=hit ? vec3(0.):rayVec*dts/STEPSHRINK;//march the ray unless theres a hit\n    }\n    vec3 norm=calcNorm(rayPos);\n    vec3 surfCol=localState.color;\n\n    //return a CastResult struct\n    return CastResult(rayOri,rayPos,norm,surfCol);\n}\n\n\n//calculate the light hitting this castResult from sun and ambient light\nvec3 lightOn(CastResult hit,DirLight sun){\n    float difLight=max(0.,(-dot(hit.norm,sun.dir)));\n    #ifdef SPECULARPOWER //if SPECULARPOWER is commented out, lighting is diffuse only\n    float specLight=SPECULARPOWER*\n        pow(max(0.,dot(reflect(sun.dir,hit.norm),normalize(hit.ori-hit.pos))),100.);\n    vec3 sunLight=(difLight+specLight)*sun.col*occlusion(hit,sun);\n    #else\n    vec3 sunLight=(difLight)*sun.col*occlusion(hit,sun);\n    #endif\n    vec3 ambientLight=vec3(AMBIENT*ambientOcclusion(hit.pos,hit.norm,AODIST));\n    return (sunLight+ambientLight);\n}\n   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//Set up the camera\n    vec2 mousePos=(length(iMouse.xy)>0.)? iMouse.xy/iResolution.xy-.5:CAMSTRT;\n    float mouseTheta=mousePos.x*2.*pi;\n    float mouseH=mousePos.y*130.+19.;\n    vec3 camPos=vec3(cos(mouseTheta)*CAMDIST,mouseH,CAMDIST*sin(mouseTheta));\n    vec3 camTarget=TARGET;\n    vec3 camOff=vec3(iTime*3.+1000.,1.,1000.);\n    camPos+=camOff;\n    camTarget+=camOff;\n//set up lighting\n    DirLight sun;\n    sun.dir=normalize(vec3(1,-.2,0.))*Rotate(vec3(10./5.,0,0));\n    sun.col=SUNLIGHT;\n    \n//set up camera ray\n//\n//in the middle of the screen, uv.xy ==(0,0),\n//so the rotation matrix that rotates (0,0,1) to normalize(camTarget-camPos)\n//will point our rays towards camTarget\n    mat3 rayRotation=camRotation(camTarget-camPos);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 rayVec=normalize(vec3(uv.x,uv.y,1.)*rayRotation);\n    \n    \n    \n    vec3 rayOri=camPos;\n\n    CastResult cRay=primaryRay(rayOri,rayVec);\n    float fog=1.-exp(-length(cRay.pos-cRay.ori)*FOGDIST);\n    vec3 finalC;\n    vec3 fogColor=FOGCOL;\n    fogColor+=sun.col*pow(max(0.,dot(-sun.dir,rayVec)),6.);\n    if(fog<.99){\n    bool inBounds=length(cRay.pos-rayOri)<MAXDIST*.999;\n    finalC=inBounds?lightOn(cRay,sun)*cRay.surf:fogColor;\n    finalC=mix(finalC,fogColor,fog);//FOG APPLICATION\n    }\n    else{finalC=vec3(fogColor);}\n    finalC=pow(finalC,vec3(1./2.2));//GAMMA CORRECT\n    fragColor = vec4(finalC,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBfzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1102, 1174, 1200, 1200, 1510], [1512, 1512, 1552, 1552, 1589], [1590, 1681, 1708, 1708, 1855], [1856, 1909, 1948, 1948, 2141], [2142, 2142, 2185, 2185, 2234], [2235, 2235, 2276, 2276, 2342], [2343, 2384, 2412, 2412, 2474], [2475, 2548, 2576, 2576, 3361], [3364, 3437, 3461, 3461, 3585], [3586, 3640, 3668, 3668, 3696], [3697, 3791, 3815, 3815, 4024], [4026, 4139, 4215, 4215, 4527], [4528, 4528, 4590, 4590, 4650], [4652, 4736, 4785, 4785, 5499], [5501, 5501, 5548, 5548, 6381], [6384, 6457, 6499, 6499, 7021], [7027, 7027, 7084, 7104, 8498]]}
{"id": "Wtf3Rs", "name": "curvy cross", "author": "abje", "description": "an sdf, a combination of spheres and a box", "tags": ["sdf", "distance", "cross", "exact"], "likes": 3, "viewed": 187, "published": "Public API", "date": "1601068687", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pin(vec2 p, float h, float r0, float r1) {\n    \n    p = abs(p);\n    \n    if (p.x > p.y) p = p.yx;\n    \n    vec2 q;\n    \n    vec2 b = vec2(r0,0);\n    q = p-b;\n    float pin = -length(q)+r1;\n    \n    vec2 a = vec2(r0-sqrt(r1*r1-h*h),h);\n    \n    \n    q = p-a;\n    \n    \n    vec2 c = a-b;\n    c = vec2(c.y,-c.x);\n    float f = min(q.x,dot(q,c));\n    if (f > 0.0) {\n        // corners\n        pin = length(q);\n    }\n    \n    float r = r0/sqrt(2.0);\n    float e = r0*0.5-sqrt((r1*r1-r*r))*sqrt(0.5);\n    \n    c = p-b;\n    c = vec2(c.y,-c.x);\n    \n    float d = dot(p-e,c);\n    \n    if (d < 0.0) {\n        pin = -length(p-e);\n    }\n    \n    // outer box\n    pin = max(pin,p.y-h);\n    \n    return pin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = 2.0;\n    vec2 uv = scale*(fragCoord*2.0-iResolution.xy)/iResolution.y;\n    float aa = iResolution.y/scale*0.4;\n    \n    float len = 10000.0;\n    \n    len = min(pin(uv, 0.9+sin(iTime)*0.1,1.8+sin(iTime*0.89)*0.1,1.6+sin(iTime*0.97)*0.1),len);\n    \n    vec3 col = vec3(1.0) - sign(len)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-2.0*abs(len));\n    col *= 0.8 + 0.2*cos(120.0*abs(len));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,1.0/aa,abs(len)) );\n    \n    //vec2 a = fract(uv*5.0);\n    //col += max(max(a.x,a.y)-0.8,0.0)*5.0;\n    \n    // Output to screen\n    fragColor = vec4(sqrt(col),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtf3Rs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 48, 702], [704, 704, 761, 811, 1426]]}
{"id": "wtjBDD", "name": "Day 18 of raymarching challenge", "author": "illus0r", "description": "Day 18 of raymarching challenge", "tags": ["raymarching"], "likes": 6, "viewed": 172, "published": "Public API", "date": "1598999717", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define textureCube texture\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define EPSILON 0.00001\n#define PI 3.14159265\n#define IVORY 1.\n#define BLUE 2.\n#define BLACK 3.\n#define RED 4.\n\n#define PHI (sqrt(5.)*0.5 + 0.5)\n#define iTime (iTime / 1.1)\n\n#define N 6\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 polarToDecart(vec2 polar) {\n    float alpha = polar.x;\n    float R = polar.y;\n    float x = sin(alpha) * R;\n    float y = cos(alpha) * R;\n    return vec2(x, y);\n}\n\nvec2 decartToPolar(vec2 decart) {\n    float alpha = atan(decart.x, decart.y);\n    float R = length(decart);\n    return vec2(alpha, R);\n}\n\nfloat mengerStretch(vec3 p) {\n    float S = .43333;\n    for(int i = 0; i < N; i++) {\n        p.xz *= Rot(iTime);\n        // p.xy *= Rot(iTime);\n        p /= S;\n        p = abs(p);\n        if ( -p.x + p.y > 0.) p.xy = p.yx;\n        if (  p.x - p.z > 0.) p.xz = p.zx;\n        p.xy *= 0.7;\n        p.z *= S;\n    }\n    return sdBox(p, vec3(1.)) * pow(S, float(N));\n}\n\n// float mengerStretch(vec3 p) {\n//     float S = .63333;\n//     for(int i = 0; i < N; i++) {\n//         p.xz *= Rot(iTime / 7.);\n//         p.xy *= Rot(iTime / 3.);\n//         p /= S;\n//         p = abs(p);\n//         if ( -p.x + p.y > 0.) p.xy = p.yx;\n//         if (  p.x - p.z > 0.) p.xz = p.zx;\n//         p = p-2.*clamp(round(p/2.), -0.5, 0.5);\n//         p.xy *= 0.7;\n//         p.z *= S;\n//     }\n//     return sdBox(p, vec3(1.)) * pow(S, float(N));\n// }\n\n// \nvec2 getDist(vec3 p) {\n    float fractal = mengerStretch(p);\n    // p = fract(p);\n    // p += 0.6;\n    // float fractal = length(p) - 1.;\n    return vec2(fractal, RED);\n}\n// \n\n\n\n\n\n\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = 0.;\n    //float glow = 0.;\n    int steps = 0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        steps++;\n        d += abs(distToClosest.x);\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec3(d, info, steps);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n);\n}\n\n\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= Rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // ray origin\n    vec3 ro = vec3(0., 3., -30.);\n    // ro.xz *= Rot(iTime);\n    float zoom = 1.100;\n\n    vec2 angle = 2. * 3.14159265 * iMouse.xy / iResolution.xy;\n    vec3 lookat = vec3(0, 0, 0);\n    lookat.xz *= Rot(angle.x);\n    lookat.yz *= Rot(angle.y);\n\n    vec3 rd = getRayDir(uv, ro, lookat, 1.);\n    vec3 rm = rayMarch(ro, rd);\n    float d = rm[0];\n    float info = rm[1];\n    float steps = rm[2];\n\n    vec3 colorBg = vec3(.0);\n    vec3 color;\n    color = vec3(1);\n    vec3 light = vec3(1000, 1, 1000);\n    //light.xz *= Rot(iTime);\n    vec3 p = ro + rd * d;\n    if (d < MAX_DIST) {\n        vec3 n = getNormal(p);\n        //n.zy *= Rot(iTime);\n    \t// color = vec3( n * 0.5 + 0.5 );\n\n        //color *= info;\n        // vec3 tex = boxmap(u_tex_bg, ro + rd * d, n, 32.0 ).xyz;//\n        // self shadeing\n        // drop shadows\n        // trying to raymarch to the light for MAX_DIST\n        // and if we hit something, it's shadow\n        vec3 dirToLight = normalize(light - p);\n        vec3 rayMarchLight = rayMarch(p + dirToLight * .06, dirToLight);\n        float distToObstable = rayMarchLight.x;\n        float distToLight = length(light - p);\n        // if (distToObstable < distToLight) {\n        //     color *=  0.;\n        // }\n\n        // smooth shadows\n        // float shadow = smoothstep(0.0, .15, rayMarchLight.z / PI);\n        // color += .1 + .9 * shadow;\n\n\n\n\n        // tex *= color_bw;\n        // color = tex;\n        // color += 0.6 + vec3( color_bw );\n        // coloring \n        if (d < MAX_DIST) {\n            if (info == IVORY) {\n                color = vec3(.4 * (dot(n, normalize(light - p))) + 1.);\n                color *= vec3(0.832,0.800,0.849);\n            }\n            else if (info == BLUE) {\n                color = vec3(0.810,0.256,0.397);\n            }\n           else if (info == RED) {\n                color = vec3(.5 * (dot(n, normalize(light - p))) + .5);\n                // vec3 color1 = vec3(0.810,0.256,0.397);\n                // vec3 color2 = color1.zxy;\n                // color = mix(color1, color2, smoothstep(1.5, 3., length(p)));\n                // color *= vec3(0.810,0.256,0.397);\n                // color /= steps / 50.;\n            }\n            else if (info == BLACK) {\n                color = vec3(0.);//vec3(.0 + 0.2 * (dot(n, normalize(light - p))) + 1.);\n                // color *= vec3(0.130,0.130,0.130);\n                // color *= 5. / length(p.xz);\n            }\n            // color = mix(color, colorBg, smoothstep(20., 28., d));\n        }\n    }\n\n    fragColor = vec4(color, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjBDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 261, 280, 280, 343], [345, 345, 376, 376, 463], [465, 465, 497, 497, 632], [634, 634, 667, 667, 770], [772, 772, 801, 801, 1134], [1600, 1679, 1701, 1701, 1849], [1850, 1938, 1971, 1971, 2351], [2353, 2353, 2377, 2377, 2595], [2599, 2599, 2653, 2653, 2880], [2882, 2882, 2932, 2932, 3123], [3136, 3136, 3192, 3192, 5813]]}
{"id": "wtjfDd", "name": "PBR JFIG Glints", "author": "xavierchermain", "description": "Shadertoy implementation of Procedural Physically based BRDF for Real-Time Rendering of Glints\nXavier Chermain (ICUBE), Basile Sauvage (ICUBE), Jean-Michel Dishler (ICUBE) and Carsten Dachsbacher (KIT)\nAccepted for Pacific Graphic 2020 and CGF.", "tags": ["brdf", "microfacet", "glint"], "likes": 6, "viewed": 407, "published": "Public", "date": "1600205008", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright  2020 Xavier Chermain (ICUBE), Basile Sauvage (ICUBE), Jean-Michel Dishler (ICUBE), Carsten Dachsbacher (KIT)\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shadertoy implementation of\n// Procedural Physically based BRDF for Real-Time Rendering of Glints\n// Xavier Chermain (ICUBE), Basile Sauvage (ICUBE), Jean-Michel Dishler (ICUBE) and Carsten Dachsbacher (KIT)\n// Pacific Graphic 2020, CGF special issue\n// Project page: http://igg.unistra.fr/People/chermain/real_time_glint/\n\n//=========================================================================================================================\n//====================================== Version for JFIG 2020 rendering contest ==========================================\n//======================== More info: https://jfig2020.sciencesconf.org/resource/page/id/1 ================================\n//=========================================================================================================================\n\n// Dictionary is generated on the fly (we cannot use pre-computed data on Shadertoy), \n// but with a limited number of lobes (16) to achieve a reasonable frame rate.\n// For a full-featured version (WebGL), see: http://igg.unistra.fr/People/reproctex/Demos/Real_Time_Glint/\n\n//=========================================================================================================================\n//================================================== JFIG title ===========================================================\n//===================== Source: https://github.com/ssloy/tinyraytracer/wiki/Part-3:-shadertoy =============================\n//=========================================================================================================================\n#define JFIGW 32u\n#define JFIGH 18u\nuint[] jfig_bitfield = uint[]( 0x0u,0x0u,0x0u,0xf97800u,0x90900u,0xc91800u,0x890900u,0xf90900u,0x180u,0x0u,0x30e30e0u,0x4904900u,0x49e49e0u,0x4824820u,0x31e31e0u,0x0u,0x0u,0x0u );\nbool jfig(in uint x, in uint y) {\n    uint id = x + (JFIGH-1u-y)*JFIGW;\n    if (id>=JFIGW*JFIGH) return false;\n    return 0u != (jfig_bitfield[id/32u] & (1u << (id&31u)));\n}\n\nfloat texel(int s, int t){\n    if(s < 0 || s >= int(JFIGW) || t < 0 || t >= int(JFIGH) || jfig(uint(s), uint(t)))\n    \treturn 0.;\n    \n    return 1.;\n}\n\nfloat jfigTriangleFilter(vec2 st){\n\tfloat s = st.x * float(JFIGW) - 0.5;\n    float t = st.y * float(JFIGH) - 0.5;\n    int s0 = int(floor(s));\n    int t0 = int(floor(t));\n    float ds = s - float(s0);\n    float dt = t - float(t0);\n    return (1. - ds) * (1. - dt) * texel(s0, t0) +\n           (1. - ds) * dt * texel(s0, t0 + 1) +\n           ds * (1. - dt) * texel(s0 + 1, t0) +\n           ds * dt * texel(s0 + 1, t0 + 1);\n}\n\n//=========================================================================================================================\n//================================================== Material parameters ==================================================\n//==================================================== Can be changed =====================================================\n//=========================================================================================================================\n// Roughness of the glinty material [0.1, 1.]\n#define ALPHA_X 0.5\n#define ALPHA_Y 0.5\n\n// Microfacet relative area [0.01, 1.]. \n// Set to 0.01 with LOGMICROFACETDENSITY set tot 5. gives sparse glints (snow, sand, sparkling rocks)\n#define MICROFACETRELATIVEAREA 1.\n\n// Logarithmic microfacet density [5., 25.]\n#define LOGMICROFACETDENSITY 14.\n\n// Maximum anisotropy of the pixel footprint (not realy usefull in this scene)\n#define MAXANISOTROPY 8.\n\n// Varnished material (add a specular lobe with a small roughness)\n# define VARNISHED true\n\n//=========================================================================================================================\n//============================================== Parameters of the dictionary =============================================\n//=========================================================================================================================\n// Roughness used during the dictionary generation\n#define ALPHA_DIC 0.5\n// Number of distributions\n// In the paper, we use 192 marginal distributions of slope\n// In shadertoy, we generate the dictionary on the fly. So we use a large number of different NDFs\n#define N 999999\n// Number of levels. In the paper : 16. In shadertoy : 8\n#define NLEVELS 8\n// Size of the tabulated marginal distributions. In the paper : 64. In shadertoy : 32\n#define DISTRESOLUTION 32\n\n\n\n//=========================================================================================================================\n//================================================ Mathematical constants =================================================\n//=========================================================================================================================\n#define PI 3.141592\n#define IPI 0.318309\n#define ISQRT2 0.707106\n\n\n\n//=========================================================================================================================\n//=============================================== Beckmann anisotropic NDF ================================================\n//==================== Shadertoy implementation : Arthur Cavalier (https://www.shadertoy.com/user/H4w0) ===================\n//========================================= https://www.shadertoy.com/view/WlGXRt =========================================\n//=========================================================================================================================\n\n//-----------------------------------------------------------------------------\n//-- Beckmann Distribution ----------------------------------------------------\nfloat p22_beckmann_anisotropic(float x, float y, float alpha_x, float alpha_y)\n{\n    float x_sqr = x*x;\n    float y_sqr = y*y;\n    float sigma_x = alpha_x * ISQRT2;\n    float sigma_y = alpha_y * ISQRT2;\n    float sigma_x_sqr = sigma_x*sigma_x;\n    float sigma_y_sqr = sigma_y*sigma_y;\n    return( \n            exp( -0.5 * ((x_sqr/sigma_x_sqr) + (y_sqr/sigma_y_sqr)) )\n    / //-------------------------------------------------------------------\n                    ( 2. * PI * sigma_x * sigma_y )\n    );\n}\n\nfloat ndf_beckmann_anisotropic(vec3 omega_h, float alpha_x, float alpha_y)\n{\n    float slope_x = - (omega_h.x/omega_h.z);\n    float slope_y = - (omega_h.y/omega_h.z);\n    float cos_theta = omega_h.z;\n    float cos_2_theta = omega_h.z * omega_h.z;\n    float cos_4_theta = cos_2_theta * cos_2_theta;\n    float beckmann_p22 = p22_beckmann_anisotropic(slope_x,slope_y,alpha_x,alpha_y);\n    return(\n                beckmann_p22\n    / //---------------------------\n                cos_4_theta\n    );\n}\n\n//=========================================================================================================================\n//======================================== Schlick approximation of Fresnel ===============================================\n//=========================================================================================================================\nvec3 fresnel_schlick(in float wo_dot_wh, in vec3 F0)\n{\n    return F0 + (1. - F0) * pow(1. - wo_dot_wh, 5.);\n}\n\n//=========================================================================================================================\n//===================================== Microfacet BRDF of Cook and Torrance 1982 =========================================\n//=========================================================================================================================\nvec3 f_specular(vec3 wo, vec3 wi)\n{\n    if(wo.z <= 0.) return vec3(0.,0.,0.);\n    if(wi.z <= 0.) return vec3(0.,0.,0.);\n    vec3 wh = normalize(wo+wi);\n    if(wh.z <= 0.) return vec3(0.,0.,0.);\n    // Local masking shadowing\n    if (dot(wo, wh) <= 0. || dot(wi, wh) <= 0.) return vec3(0.);\n    float wi_dot_wh = clamp(dot(wi,wh),0.,1.);\n\n    float D = ndf_beckmann_anisotropic(wh,0.1, 0.1);\n    // V-cavity masking shadowing\n    float G1wowh = min(1., 2. * wh.z * wo.z / dot(wo, wh));\n    float G1wiwh = min(1., 2. * wh.z * wi.z / dot(wi, wh));\n    float G = G1wowh * G1wiwh;\n    \n\tvec3 F  = fresnel_schlick(wi_dot_wh,vec3(1., 1., 1.));\n        \n    return (D * F * G) / ( 4. * wo.z );\n}\n\n//=========================================================================================================================\n//=============================================== Diffuse Lambertian BRDF =================================================\n//=========================================================================================================================\nvec3 f_diffuse(vec3 wo, vec3 wi)\n{\n    if (wo.z <= 0.)\n        return vec3(0., 0., 0.);\n    if (wi.z <= 0.)\n        return vec3(0., 0., 0.);\n\n    return vec3(0.8, 0., 0.) * IPI * wi.z;\n}\n\n//=========================================================================================================================\n//=============================================== Inverse error function ==================================================\n//=========================================================================================================================\nfloat erfinv(float x)\n{\n    float w, p;\n    w = -log((1.0 - x) * (1.0 + x));\n    if (w < 5.000000)\n    {\n        w = w - 2.500000;\n        p = 2.81022636e-08;\n        p = 3.43273939e-07 + p * w;\n        p = -3.5233877e-06 + p * w;\n        p = -4.39150654e-06 + p * w;\n        p = 0.00021858087 + p * w;\n        p = -0.00125372503 + p * w;\n        p = -0.00417768164 + p * w;\n        p = 0.246640727 + p * w;\n        p = 1.50140941 + p * w;\n    }\n    else\n    {\n        w = sqrt(w) - 3.000000;\n        p = -0.000200214257;\n        p = 0.000100950558 + p * w;\n        p = 0.00134934322 + p * w;\n        p = -0.00367342844 + p * w;\n        p = 0.00573950773 + p * w;\n        p = -0.0076224613 + p * w;\n        p = 0.00943887047 + p * w;\n        p = 1.00167406 + p * w;\n        p = 2.83297682 + p * w;\n    }\n    return p * x;\n}\n\n//=========================================================================================================================\n//================================================== Hash function ========================================================\n//================================================== Inigo Quilez =========================================================\n//====================================== https://www.shadertoy.com/view/llGSzw ============================================\n//=========================================================================================================================\n// \nfloat hashIQ(uint n)\n{\n    // integer hash copied from Hugo Elias\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float(n & 0x7fffffffU) / float(0x7fffffff);\n}\n\n//=========================================================================================================================\n//=============================================== Pyramid size at LOD level ===============================================\n//=========================================================================================================================\nint pyramidSize(int level)\n{\n    return int(pow(2., float(NLEVELS - 1 - level)));\n}\n\nfloat normalDistribution1D(float x, float mean, float std_dev) {\n    float xMinusMean = x - mean;\n    float xMinusMeanSqr = xMinusMean * xMinusMean;\n    return exp(-xMinusMeanSqr / (2. * std_dev * std_dev)) /\n           (std_dev * 2.506628);\n    // 2.506628 \\approx sqrt(2 * \\pi)\n}\n\n//=========================================================================================================================\n//========================================= Sampling from a Normal distribution ===========================================\n//=========================================================================================================================\nfloat sampleNormalDistribution(float U, float mu, float sigma)\n{\n    float x = sigma * 1.414213f * erfinv(2.0f * U - 1.0f) + mu;\n    return x;\n}\n\n//=========================================================================================================================\n//==================================== Evaluation of the i th marginal distribution P =====================================\n//========================================== with slope x and at LOD level ================================================\n//============================ Procedural version, because we cannot use data with Shadertoy ==============================\n//=========================================================================================================================\n\nfloat P_procedural(float x, int i, int level) {\n    \n    // We use even functions\n    x = abs(x);\n    // After 4 standard deviation sigma, we consider that the distribution equals zero\n    float sigma_dist_4 = 4. * 0.353535; // alpha_dist = 0.5 so sigma_dist \\approx 0.3535 (0.5 / sqrt(2))\n    if(x >= sigma_dist_4) return 0.;\n    \n    int nMicrofacetsCurrentLevel = int(pow(2., float(level)));\n    float density = 0.;\n    // Dictionary should be precomputed, but we cannot use memory with Shadertoy\n    // So we generate it on the fly with a very limited number of lobes\n    nMicrofacetsCurrentLevel = min(16, nMicrofacetsCurrentLevel);\n    \n    for (int n = 0; n < nMicrofacetsCurrentLevel; ++n) {\n        \n        float U_n = hashIQ(uint(i*7333+n*5741));\n        // alpha roughness equals sqrt(2) * RMS roughness\n        //     ALPHA_DIC     =   1.414214 * std_dev\n        // std_dev = ALPHA_DIC / 1.414214 \n        float currentMean = sampleNormalDistribution(U_n, 0., ALPHA_DIC / 1.414214);\n        density += normalDistribution1D(x, currentMean, 0.05) +\n                   normalDistribution1D(-x, currentMean, 0.05);\n    }\n    return density / float(nMicrofacetsCurrentLevel);\n}\n\n//=========================================================================================================================\n//=================== Spatially-varying, multiscale, rotated, and scaled slope distribution function ======================\n//================================================= Eq. 11, Alg. 3 ========================================================\n//=========================================================================================================================\nfloat P22_theta_alpha(vec2 slope_h, int l, int s0, int t0)\n{\n    \n    // Coherent index\n    // Eq. 18, Alg. 3, line 1\n    s0 *= 1 << l;\n    t0 *= 1 << l;\n\n    // Seed pseudo random generator\n    // Alg. 3, line 2\n    int rngSeed = s0 + 1549 * t0;\n\n    // Alg.3, line 3\n    float uMicrofacetRelativeArea = hashIQ(uint(rngSeed) * 13U);\n    // Discard cells by using microfacet relative area\n    // Alg.3, line 4\n    if (uMicrofacetRelativeArea > MICROFACETRELATIVEAREA)\n        return 0.f;\n\n    // Number of microfacets in a cell\n    // Alg. 3, line 5\n    float n = pow(2., float(2 * l - (2 * (NLEVELS - 1))));\n    n *= exp(LOGMICROFACETDENSITY);\n\n    // Corresponding continuous distribution LOD\n    // Alg. 3, line 6\n    float l_dist = log(n) / 1.38629; // 2. * log(2) = 1.38629\n    \n    // Alg. 3, line 7\n    float uDensityRandomisation = hashIQ(uint(rngSeed) * 2171U);\n\n    // Fix density randomisation to 2 to have better appearance\n    // Notation in the paper: \\zeta\n    float densityRandomisation = 2.;\n    \n    // Sample a Gaussian to randomise the distribution LOD around the distribution level l_dist\n    // Alg. 3, line 8\n    l_dist = sampleNormalDistribution(uDensityRandomisation, l_dist, densityRandomisation);\n\n    // Alg. 3, line 9\n    int l_disti = clamp(int(round(l_dist)), 0, NLEVELS);\n\n    // Alg. 3, line 10\n    if (l_disti == NLEVELS)\n        return p22_beckmann_anisotropic(slope_h.x, slope_h.y, ALPHA_X, ALPHA_Y);\n\n    // Alg. 3, line 13\n    float uTheta = hashIQ(uint(rngSeed));\n    float theta = 2.0 * PI * uTheta;\n\n    // Uncomment to remove random distribution rotation\n    // Lead to glint alignments with small N\n    // theta = 0.;\n\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    \n    vec2 scaleFactor = vec2(ALPHA_X / ALPHA_DIC,\n                            ALPHA_Y / ALPHA_DIC);\n\n    // Rotate and scale slope\n    // Alg. 3, line 16\n    slope_h = vec2(slope_h.x * cosTheta / scaleFactor.x + slope_h.y * sinTheta / scaleFactor.y,\n                   -slope_h.x * sinTheta / scaleFactor.x + slope_h.y * cosTheta / scaleFactor.y);\n\n    // Alg. 3, line 17\n    float u1 = hashIQ(uint(rngSeed) * 16807U);\n    float u2 = hashIQ(uint(rngSeed) * 48271U);\n\n    // Alg. 3, line 18\n    int i = int(u1 * float(N));\n    int j = int(u2 * float(N));\n    \n    float P_i = P_procedural(slope_h.x, i, l_disti);\n    float P_j = P_procedural(slope_h.y, j, l_disti);\n\n    // Alg. 3, line 19\n    return P_i * P_j / (scaleFactor.x * scaleFactor.y);\n\n}\n\n//=========================================================================================================================\n//========================================= Alg. 2, P-SDF for a discrete LOD ==============================================\n//=========================================================================================================================\n\n// Most of this function is similar to pbrt-v3 EWA function,\n// which itself is similar to Heckbert 1889 algorithm, http://www.cs.cmu.edu/~ph/texfund/texfund.pdf, Section 3.5.9.\n// Go through cells within the pixel footprint for a given LOD l\n\nfloat P22_floorP(int l, vec2 slope_h, vec2 st, vec2 dst0, vec2 dst1)\n{\n    // Convert surface coordinates to appropriate scale for level\n    float pyrSize = float(pyramidSize(l));\n    st[0] = st[0] * pyrSize - 0.5f;\n    st[1] = st[1] * pyrSize - 0.5f;\n    dst0[0] *= pyrSize;\n    dst0[1] *= pyrSize;\n    dst1[0] *= pyrSize;\n    dst1[1] *= pyrSize;\n\n    // Compute ellipse coefficients to bound filter region\n    float A = dst0[1] * dst0[1] + dst1[1] * dst1[1] + 1.;\n    float B = -2. * (dst0[0] * dst0[1] + dst1[0] * dst1[1]);\n    float C = dst0[0] * dst0[0] + dst1[0] * dst1[0] + 1.;\n    float invF = 1. / (A * C - B * B * 0.25f);\n    A *= invF;\n    B *= invF;\n    C *= invF;\n\n    // Compute the ellipse's bounding box in texture space\n    float det = -B * B + 4. * A * C;\n    float invDet = 1. / det;\n    float uSqrt = sqrt(det * C), vSqrt = sqrt(A * det);\n    int s0 = int(ceil(st[0] - 2. * invDet * uSqrt));\n    int s1 = int(floor(st[0] + 2. * invDet * uSqrt));\n    int t0 = int(ceil(st[1] - 2. * invDet * vSqrt));\n    int t1 = int(floor(st[1] + 2. * invDet * vSqrt));\n\n    // Scan over ellipse bound and compute quadratic equation\n    float sum = 0.f;\n    float sumWts = 0.;\n    int nbrOfIter = 0;\n\n    for (int it = t0; it <= t1; ++it)\n    {\n        float tt = float(it) - st[1];\n        for (int is = s0; is <= s1; ++is)\n        {\n            float ss = float(is) - st[0];\n            // Compute squared radius and filter SDF if inside ellipse\n            float r2 = A * ss * ss + B * ss * tt + C * tt * tt;\n            if (r2 < 1.)\n            {\n                // Weighting function used in pbrt-v3 EWA function\n                float alpha = 2.;\n                float W_P = exp(-alpha * r2) - exp(-alpha);\n                // Alg. 2, line 3\n                sum += P22_theta_alpha(slope_h, l, is, it) * W_P;\n                \n                sumWts += W_P;\n            }\n            nbrOfIter++;\n            // Guardrail (Extremely rare case.)\n            if (nbrOfIter > 100)\n                break;\n        }\n        // Guardrail (Extremely rare case.)\n        if (nbrOfIter > 100)\n            break;\n    }\n    return sum / sumWts;\n}\n\n//=========================================================================================================================\n//=============================== Evaluation of our procedural physically based glinty BRDF ===============================\n//==================================================== Alg. 1, Eq. 14 =====================================================\n//=========================================================================================================================\nvec3 f_P(vec3 wo, vec3 wi, vec2 uv)\n{\n\t\n    if (wo.z <= 0.)\n        return vec3(0., 0., 0.);\n    if (wi.z <= 0.)\n        return vec3(0., 0., 0.);\n\n    // Alg. 1, line 1\n    vec3 wh = normalize(wo + wi);\n    if (wh.z <= 0.)\n        return vec3(0., 0., 0.);\n\n    // Local masking shadowing\n    if (dot(wo, wh) <= 0. || dot(wi, wh) <= 0.)\n        return vec3(0.);\n\n    // Eq. 1, Alg. 1, line 2\n    vec2 slope_h = vec2(-wh.x / wh.z, -wh.y / wh.z);\n\n    vec2 texCoord = uv;\n\n    float D_P = 0.;\n    float P22_P = 0.;\n\n    // ------------------------------------------------------------------------------------------------------\n    // Similar to pbrt-v3 MIPMap::Lookup function, http://www.pbr-book.org/3ed-2018/Texture/Image_Texture.html#EllipticallyWeightedAverage\n\n    // Alg. 1, line 3\n    vec2 dst0 = dFdx(texCoord);\n    vec2 dst1 = dFdy(texCoord);\n\n    // Compute ellipse minor and major axes\n    float dst0Length = length(dst0);\n    float dst1Length = length(dst1);\n\n    if (dst0Length < dst1Length)\n    {\n        // Swap dst0 and dst1\n        vec2 tmp = dst0;\n        dst0 = dst1;\n        dst1 = tmp;\n    }\n    float majorLength = length(dst0);\n    // Alg. 1, line 5\n    float minorLength = length(dst1);\n\n    // Clamp ellipse eccentricity if too large\n    // Alg. 1, line 4\n    if (minorLength * MAXANISOTROPY < majorLength && minorLength > 0.)\n    {\n        float scale = majorLength / (minorLength * MAXANISOTROPY);\n        dst1 *= scale;\n        minorLength *= scale;\n    }\n    // ------------------------------------------------------------------------------------------------------\n\n    // Without footprint, we evaluate the Cook Torrance BRDF\n    if (minorLength == 0.)\n    {\n        D_P = ndf_beckmann_anisotropic(wh, ALPHA_X, ALPHA_Y);\n    }\n    else\n    {\n        // Choose LOD\n        // Alg. 1, line 6\n        float l = max(0., float(NLEVELS) - 1. + log2(minorLength));\n        int il = int(floor(l));\n\n        // Alg. 1, line 7\n        float w = l - float(il);\n\n        // Alg. 1, line 8\n        P22_P = mix(P22_floorP(il, slope_h, texCoord, dst0, dst1),\n                    P22_floorP(il + 1, slope_h, texCoord, dst0, dst1),\n                    w);\n\n        // Eq. 13, Alg. 1, line 10\n        D_P = P22_P / (wh.z * wh.z * wh.z * wh.z);\n    }\n\n    // V-cavity masking shadowing\n    float G1wowh = min(1., 2. * wh.z * wo.z / dot(wo, wh));\n    float G1wiwh = min(1., 2. * wh.z * wi.z / dot(wi, wh));\n    float G = G1wowh * G1wiwh;\n\n    // Fresnel is set to one for simplicity here\n    // but feel free to use \"real\" Fresnel term\n    vec3 F = vec3(1., 1., 1.);\n\n    // Eq. 14, Alg. 1, line 11\n    // (wi dot wg) is cancelled by\n    // the cosine weight in the rendering equation\n    return (F * G * D_P) / (4. * wo.z);\n}\n\n//=========================================================================================================================\n//===================================================== Renderer ==========================================================\n//=========================================================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Light intensity\n    vec3 lightIntensity = vec3(50000.);\n    \n    // Texture position\n    vec2 uv = fragCoord/iResolution.y * 400.;\n    \n    // Vertex position\n    vec3 vertexPos = vec3(fragCoord - iResolution.xy/2., 0.);\n    \n    // Light position (varies over time)\n    float x_i = cos(iTime*0.6) * iResolution.x / 2.;\n    float y_i = cos(iTime) * iResolution.y / 2.;\n    vec3 lightPos = vec3(x_i, y_i, 100);\n    \n    // Camera position\n    vec3 cameraPos = vec3(0, 0, 100);\n    \n    // Compute normal from JFIG heightfield\n    float diff = 10.;\n    float hJFIGsm1t0 = jfigTriangleFilter(vec2((fragCoord.x - diff)/iResolution.x, (fragCoord.y)/iResolution.y));\n    float hJFIGs1t0 = jfigTriangleFilter(vec2((fragCoord.x + diff)/iResolution.x, (fragCoord.y)/iResolution.y));\n    float hJFIGs0tm1 = jfigTriangleFilter(vec2((fragCoord.x)/iResolution.x, (fragCoord.y - diff)/iResolution.y));\n    float hJFIGs0t1 = jfigTriangleFilter(vec2((fragCoord.x)/iResolution.x, (fragCoord.y + diff)/iResolution.y));\n    vec2 slope = vec2((hJFIGs1t0 - hJFIGsm1t0)/2.,\n                      (hJFIGs0t1 - hJFIGs0tm1)/2.);\n    slope *= 4.;\n    vec3 vertexNormal = vec3(-slope.x, -slope.y, 1.) / sqrt(slope.x*slope.x+slope.y*slope.y+1.);\n    \n    vec3 vertexTangent = vec3(1., 0., 0.);\n    // GramSchmidt process\n    vertexTangent = vertexTangent - (dot(vertexNormal, vertexTangent) / dot(vertexNormal, vertexNormal)) * vertexNormal;\n    vec3 vertexBinormal = cross(vertexNormal, vertexTangent);\n    \n    // Matrix for transformation to tangent space\n    mat3 toLocal = mat3(\n        vertexTangent.x, vertexBinormal.x, vertexNormal.x,\n        vertexTangent.y, vertexBinormal.y, vertexNormal.y,\n        vertexTangent.z, vertexBinormal.z, vertexNormal.z ) ;\n    \n    // Incident direction\n    vec3 wi = normalize(toLocal * normalize(lightPos - vertexPos));\n    // Observer direction\n    vec3 wo = normalize(toLocal * normalize(cameraPos));\n    \n    vec3 radiance_glint = vec3(0.);\n    vec3 radiance_diffuse = vec3(0.);\n    vec3 radiance = vec3(0.);\n    \n    float distanceSquared = distance(vertexPos, lightPos);\n    distanceSquared *= distanceSquared;\n    vec3 Li = lightIntensity / distanceSquared;\n    \n    radiance_diffuse = f_diffuse(wo, wi) * Li;\n    \n    // Call our physically based glinty BRDF\n    radiance_glint = f_P(wo, wi, uv) * Li;\n    \n    radiance = 0.33*radiance_diffuse + vec3(0.13f,0.,0.);\n        \n    radiance += 0.33*radiance_glint;\n    if(VARNISHED){\n        radiance += 0.1 * f_specular(wo, wi) * Li;\n    }\n   \n    // Gamma\n    radiance = pow(radiance, vec3(1.0 / 2.2));\n\n    // Output to screen\n    fragColor = vec4(radiance, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjfDd.jpg", "access": "shaders20k", "license": "mit", "functions": [[2267, 2979, 3012, 3012, 3152], [3154, 3154, 3180, 3180, 3305], [3307, 3307, 3341, 3341, 3729], [6666, 6826, 6906, 6906, 7330], [7332, 7332, 7408, 7408, 7827], [7829, 8201, 8255, 8255, 8310], [8312, 8684, 8719, 8719, 9371], [9373, 9745, 9779, 9779, 9931], [9933, 10305, 10328, 10328, 11128], [11130, 11754, 11776, 11819, 11954], [11956, 12328, 12356, 12356, 12411], [12413, 12413, 12477, 12477, 12694], [12696, 13068, 13132, 13132, 13212], [13214, 13835, 13882, 13916, 15020], [15022, 15518, 15578, 15635, 17997], [18372, 18616, 18686, 18752, 20756], [20758, 21254, 21291, 21291, 23987], [23989, 24361, 24418, 24441, 27065]]}
{"id": "wtjfDy", "name": "Sorted Overlapping Quadtree", "author": "Shane", "description": "An overlapping quadtree structure with sorted elements.", "tags": ["random", "sort", "overlay", "layers", "quadtree"], "likes": 34, "viewed": 649, "published": "Public API", "date": "1599832699", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tSorted Overlapping Quadtree\n\t---------------------------\n\n\tThis is a quadtree structure that allows for its cell objects to overlap\n\twith neighbors. The resultant objects have been given a height value, which\n\thave been sorted for rendering.\n\n\tTo be sure, there are easier ways to render random sized objects onto a \n    screen, but I wanted a way to test an overlapping quadtree structure that \n    I'll be using in a following example involving an extruded grid of packed \n    multiscaled pylons. Having said that, using this structure produces a \n    cleaner, packed, more evenly distributed look with fewer operations. An \n    overlapping quadtree also has other uses, like multiscaled Voronoi with \n    minimal taps.\n\n\tIn particular, I'm using the structure to render some closely packed \n    overlapping circles with a custom overlay function to give the impression of \n    transparent interiors. Years ago, I remember naively thinking that \n    transparent objects wouldn't require sorting, but unfortunately, overlaying\n\tcolor order matters. The custom overlay formula was made up on the spot to \n    produce a reasonable looking see-through effect, but it's not what anyone\n\twould describe as physically correct. By the way, you could save quite a \n    few calculations and leave things unsorted, but you'd lose that interesting \n\trandom height look.\n\n\tThe three levels here require a maximum of 27 taps (fewer, on average), on \n    account of the fact that the objects stray from their cell centers quite a \n    bit, which necessitates a 3x3 grid check for all three levels. However, with \n    range restrictions, it's possible to get away with 2x2 checks, for a maximum \n    of just 12 in total.\n\n\tSome may have also noticed that this is a little heavy on the rendering side\n\tof things, which is noticeable in fullscreen mode. Therefore, when I've got \n    some time, I'll find ways to cut that down.\n \n\n\tRelated examples:\n\n    // Here's a very basic non-overlapping quadtree example. Things are much \n    // easier, and almost trivial, when neighbors don't need to be considered.\n\tRandom Quadtree - Shane\n\thttps://www.shadertoy.com/view/llcBD7\n\n\n*/\n\n\n// Random cell object offsets: If you turn this off, you can see the\n// packed quadtree structure.\n#define RANDOM_OFFSET\n\n// A faster version with a maximum 12 taps for three levels. It's just what\n// you need for packed extruded objects contained within cells, but doesn't\n// provide enough random range for this example.\n//#define FASTER\n\n// Sort the cell objects in order of height. Of course, there's no rule that\n// says you have to sort the objects. If you comment this out, objects will\n// be added to the canvas in the same order they were added to the quadtree,\n// which will be in order of object size.\n#define SORT\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(113, 1)));\n    \n    //return fract(vec2(262144, 32768)*n);\n    \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    // Note the \".35,\" insted of \".5\" that you'd expect to see. .\n    return sin(p*6.2831853 + iTime/2.)*.5 + .5;\n    \n}\n\n\n/*\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\nfloat sBox(in vec2 p, in vec2 b){\n\n  \n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n*/\n\n// Getting the video texture. I've deliberately stretched it out to fit across the screen,\n// which means messing with the natural aspect ratio.\n//\n// By the way, it'd be nice to have a couple of naturally wider ratio videos to choose from. :)\n//\nvec3 getTex(sampler2D ch, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(ch, p).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(iChannel0, p), vec3(.299, .587, .114)); }\n\n// Maximum array number.\n#define ANUM 32 \n\n// Total cell objects for the pass.\nint objN = 0;\n\n// The cell object structure: I try to avoid structures in \n// pixel shaders, but sometimes they're convenient.\nstruct obj{\n    \n    float dist; // Object distance.\n    float distSh; // Object shadow distance.\n    vec2 id; // Position based ID.\n    vec2 offs; // Cell offset.\n    float boxID; // Cell ID.\n    float height; // Cell height.\n    vec2 dim; // Cell dimensions.\n};\n\n\n// Global cell scale.\n#define GSCALE vec2(1./5.);\n\n// The quadtree function.\nobj[ANUM] blocks(vec2 q3, vec3 lp){\n    \n    \n    // Cell scale and dimension.\n    vec2 oDim = GSCALE;\n    vec2 dim = GSCALE; \n    \n    // Overall minimum distance. Not used here.\n    //float d = 1e5;\n    \n    \n    // An array or objects.\n    obj[ANUM] sq;\n    \n    // Reset the number of objects.\n    objN = 0;\n    \n    \n    // Chance that level one, two or three will be rendered:\n    //\n    // The final entry needs to fill in whatever cells are remaining, so needs to have a \n    // 100% chance of success. I'd rather not say how long it took me to figure that out. :D\n    vec3 rndTh = vec3(.333, .666, 1.01);\n    \n    \n    \n    for(int k=0; k<3; k++){\n \n        #ifdef FASTER\n        for(int j = 0; j<=1; j++){\n            for(int i = 0; i<=1; i++){\n                \n                // For the 12 tap (4-tap IJ loop), we need the \"-.5\" figure to center things.\n        \t    vec2 ip0 = q3.xy/dim + vec2(i, j) - .5;\n        #else\n        for(int j = -1; j<=1; j++){\n            for(int i = -1; i<=1; i++){\n                \n              \t// For the 27 tap (9-tap IJ loop), take it off the expression.\n        \t    vec2 ip0 = q3.xy/dim + vec2(i, j);\n        #endif\n                \n\n                // First level random subdivision.\n                vec3 rndIJ;\n                rndIJ[0] = hash21(floor(ip0));\n                if(rndIJ[0]>=rndTh[k]) continue;\n\n                // Second level random subdivision.\n                rndIJ[1] = hash21(floor(ip0/2.));\n                if(k==1 && rndIJ[1]<rndTh[0]) continue;\n\n                // Third level random subdivision.\n                rndIJ[2] = hash21(floor(ip0/4.));\n                if(k==2 && (rndIJ[1]<rndTh[1] || rndIJ[2]<rndTh[0])) continue;\n\n\n                // Local coordinates and cell ID.\n                vec2 p = q3.xy;\n                vec2 ip = floor(ip0) + .5;\n                p -= ip*dim; // Last term for 8 iterations.\n\n                // The cell's center position-based ID.\n                vec2 idi = ip*dim;\n\n              \n                #ifdef RANDOM_OFFSET\n                // Texture based object height.\n                float h = hm(idi);\n                h *= .15;\n                \n                #ifdef FASTER\n                vec2 offs = (hash22(idi + .63*dim) - .5)*dim*.3;\n                #else\n                vec2 offs = (hash22(idi + .41*dim) - .5)*dim*.5;\n                #endif\n                #else\n                vec2 offs = vec2(0);\n                 \n                float h = .15/2.; // Make the heights even.\n                #endif\n\n                \n\n                // Fake light direction vector calculation. It's not entirely correct,\n                // but produces the right effect.\n                vec2 ld = normalize(lp - vec3(idi + offs, 0)).xy;\n                \n                // Scaling factor, based on height.\n                float scF = 1./1. + (h*2. - .15)*1.;\n                #ifdef FASTER \n                scF *= 1.08;\n                ld *= .75;\n                #endif\n                \n                // Distance and distance shadow calculations.\n                float di2D = length(p - offs) - dim.x/2./scF;\n                \n                float di2DSSh = length(p - offs - -.03*ld) - dim.x/2./scF;\n\n \t\t\t\t// Boxes. I'll be using boxes for the 3D example.\n                //float di2D = sBoxS(p, dim/2. - .05*oDim.x, .1*oDim.x);\n                //float di2DSSh = sBoxS(p - vec2(-.03), dim/2. - .05*oDim.x, .1*oDim.x);\n\n\n                // For 3D and other things, you'd update on a closest basis, but\n                // in this case, we need to render them all.\n                //if(di2D<d){\n                //d = di2D;\n\n                // The quadtree cell ID.\n                #ifdef FASTER\n                float boxID = float(k*4 + j*2 + (1 - i));\n                #else\n                float boxID = float(k*9 + (j + 1)*3 + (2 - (i + 1)));\n                #endif\n\n\t\t\t\t// Fill in the object values.\n                sq[objN].dist = di2D;\n                sq[objN].distSh = di2DSSh;\n                sq[objN].id = idi;\n                sq[objN].offs = offs;\n                sq[objN].boxID = boxID;\n                sq[objN].height = h;\n                sq[objN].dim = dim;\n\n                // Increment the global object count.\n                objN++;\n                //}\n\n\n\n            }\n        }\n\n        // Cut the dimension in half for the next level.\n        dim /= 2.;\n        \n    }  \n    \n    // Return the object array.\n    return sq;\n    \n    \n}\n\n\n// float swap.\nvoid swap(inout float a, inout float b){ float tmp = a; a = b; b = tmp; }\n// float swap.\nvoid swap(inout int a, inout int b){ int tmp = a; a = b; b = tmp; }\n\n// Translating the camera about the XY plane.\nvec2 getCamTrans(float t){ return vec2(sin(t/8.)/8., t/4.); }\n\n// Rotating the camera about the XY plane.\nmat2 getCamRot(float t){\n    \n    //return rot2(0.);\n    return rot2(cos(t/4.)/8.);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scaling and translation.\n    float gSc = 1.;\n    \n    // Smoothing factor.\n    float sf = 1.5*gSc/iResolution.y;\n \n    // Depending on perspective; Moving the oject toward the bottom left, \n    // or the camera in the north east (top right) direction. \n    //vec2 p = uv*gSc - vec2(-.5, -1)*iTime/8.;\n    \n    // Rotating and moving the canvas. A 2D \"to\" and \"from\" setup would be better, but this\n    // will do for the purpose of the demonstration.\n    vec2 cam = getCamTrans(iTime); // Translation.\n    mat2 camRot = getCamRot(iTime); // Rotation.\n    // Extra 45 degred rotation to give a diamond grid appearance.\n    mat2 scrRot = rot2(0.);//rot2(3.14159/4.);\n    vec2 p = scrRot*(uv*gSc)*camRot + scrRot*cam;//rot2(3.14159/4.)*\n    \n    vec2 oP = p; // Save a copy.\n    \n    // Surface point and light position.\n    vec3 sp = vec3(p, 0); \n    vec3 lp = vec3(p - uv*gSc, -.35);\n    lp.xy += vec2(-.1, .15);\n    \n    // Using the quadtree structure to fill in the object array.\n    // Passing in the positino and light postion for shadows.\n    obj[ANUM] svObj = blocks(p, lp);\n     \n    // By the way, it's possible just to render the objects in the \n    // order that they're added to the list, but you'll lose the\n    // random ordered look. In this case, large object would stay on \n    // the bottom and smaller would appear at the top.\n    \n    // Height and indices for sorthing purposes.\n    int[ANUM] index;\n    float[ANUM] h;\n    for(int i = 0; i<objN; i++){\n        h[i] = svObj[i].height;\n        index[i] = i;\n    }\n   \n    #ifdef SORT\n    // Anyone who knows sorting will know this is not a fast sort,\n    // but it'll do. In fact, I remember reading somewhere that GPUs\n    // prefer straight forward things like this, rather than quick\n    // sorts, and so forth... but I'll leave that to the experts.\n    for(int i = 0; i<objN; i++){\n        for(int j = i + 1; j<objN; j++){\n            // Branchless swaps are possible, but I'm a little paranoid\n            // regarding precision issues.\n            if(h[i]<h[j]){ \n                swap(h[i], h[j]);\n                swap(index[i], index[j]);\n            }\n        }\n\t}\n    #endif\n    \n\n    // Background texture.\n    vec3 tx = texture(iChannel0, p).xyz; tx *= tx;\n    tx = smoothstep(0., .5, tx);\n    \n    // Background color.\n    vec3 col = vec3(.7, .5, .4)*1.2;\n    col *= mix(tx, col, .25);\n    \n    \n    // Fake light distance and attenuation.\n    float lDist = length(lp - sp);\n    float atten = 1./(1. + pow(lDist, 4.)*3.);\n    col *= atten;\n \n    for(int ii = 0; ii<objN; ii++){\n        \n        // Sorted index. Index sortings saves the extra hassle of\n        // object sorting.\n        int i = index[ii];\n        \n        // Some random numbers.\n        float rnd = hash21(svObj[i].id);\n        float rnd2 = hash21(svObj[i].id + .47);\n        float rnd3 = hash21(svObj[i].id + .73);\n         \n        // Fake 3D scaling factor. Closer object appear larger, so this is \n        // used for texture scaling.\n        float distF = 1. + (.15 - svObj[i].height*2.);\n        \n        // A color texture read.\n        vec3 tx2 = texture(iChannel1, svObj[i].id/distF).xyz; tx2 *= tx2;\n \t\t//tx2 = smoothstep(0., .5, tx2);\n        // Another texture read. \n        tx = texture(iChannel0, (p - (svObj[i].id + svObj[i].offs))/distF).xyz; tx *= tx;\n        tx = smoothstep(-.1, .5, tx);\n        \n        // Object color.\n        vec3 oCol = mix(tx, tx2, .25)*vec3(1, .7, .5)*1.35;\n         \n        // Circle distance and shadow.\n        float d = svObj[i].dist;\n        float dSh = svObj[i].distSh;\n        // Ring and corresponding ring shadow.\n        float rw = .012; // Ring width.\n        float ring = abs(d + rw/2.) - rw/2.;\n        float ringSh = abs(dSh + rw/2.) - rw/2.;\n        \n        // Subtle shading.\n        float sh = max(.9 - d/svObj[i].dim.x, 0.);\n        \n        sp = vec3(p.x, p.y + (.15 - svObj[i].height*2.), 0);\n        lDist = length(lp - sp);\n        atten = 1./(1. + pow(lDist, 4.)*3.);\n        \n        // Polar ring pattern.\n        vec2 q = p - svObj[i].id - svObj[i].offs;\n        float ang = atan(q.y, q.x);\n        #ifdef RANDOM_OFFSET\n        // Randomly rotate the pattern.\n        ang += (floor(rnd*2.) - .5)*iTime/2.*(rnd2*.5 + .5);\n        #endif\n        // Scale factor for the ring number. Smaller circles mean\n        // fewer polar lines.\n        #ifdef FASTER\n        float scF = floor(svObj[i].boxID/4.);\n        #else\n        float scF = floor(svObj[i].boxID/9.);\n        #endif\n        scF = exp2(scF); // Equivalent to: pow(2., scF);\n        float pat = abs(fract(ang/6.2831853*32./scF) - .5)*2. - .15;\n        pat = smoothstep(0., sf*32./scF, pat)*.65 + .35;\n        \n        \n       \n        vec3 shCol = (.5 + 6.*sh*oCol*atten);\n        vec3 shCol2 = (.75 + 3.*sh*oCol*atten);\n        // Blinking formula... One of many.\n        rnd3 = smoothstep(.75, .9, sin(rnd3*6.2831853 + iTime*2.)*.5 + .5);\n        shCol = mix(shCol2, shCol, rnd3);\n        // Perspex shadow... The idea is that the light would cast a colored\n        // light onto the ground... Maybe. None of this is important.\n       \n        vec3 gCol = col*shCol;\n        if(rnd2<.15) gCol = mix(gCol, gCol.zyx, .7);\n        //else if(rnd2<.25) gCol = mix(gCol, gCol.xzy, .7);\n        col = mix(col, gCol/2., (1. - smoothstep(0., sf, dSh + .004 + rw)));\n        \n        // Solid ring shadow.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., ringSh))*.6);\n        \n        // The object ring itself.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., ring))*.5);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, ring))*.9);\n        col = mix(col, oCol*1.35*atten*pat, (1. - smoothstep(0., sf, ring + .004))); \n        \n        \n        // The top perspex layer... or is it thin cellophane, or just a thin \n        // colored light shining across the rim? No idea, but I thought the \n        // transparent colored light provided visual interest. :)\n        gCol = col*shCol;\n        if(rnd2<.15) gCol = mix(gCol, gCol.zyx, .7);\n        //else if(rnd2<.25) gCol = mix(gCol, gCol.xzy, .7);\n        // \n        col = mix(col, gCol/2., (1. - smoothstep(0., sf, d + .004 + rw)));\n        \n  \n        \n    }\n    \n  \n    \n    \n    // Rough gamma correction and output.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjfDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2797, 2830, 2852, 2852, 2910], [2913, 2941, 2962, 2962, 3025], [3027, 3049, 3070, 3419, 3695], [3968, 4215, 4249, 4626, 4716], [4718, 4782, 4802, 4802, 4862]]}
{"id": "WtjfR3", "name": "shortpinski", "author": "samuelotherion", "description": "Sierpinsi Triangle", "tags": ["sierpinski", "onetweet"], "likes": 4, "viewed": 190, "published": "Public API", "date": "1599495518", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 o, vec2 i)\n{\nfloat d = 8192.,\\\n      e = exp(-mod(iTime, log(2.)));\\\no.xy = i * e;\\\nfor(o.x = .5 * (o.x-o.y); e < d; o = mod(o, d *= .5))\\\n\td < o.x + o.y ? d--, o-=o : o;\\\no++;}\n\n\n/*want this ;O(\nbut still 17 ch left\n\n#define mainImage(o,i)\\\nfloat d = 8192.,\\\n      e = exp(-mod(iTime, log(2.)));\\\no.xy = (i-.5*iResolution.xy) * e * vec2( 1., .7);\\\nfor(o.x = .5 * (o.x-o.y); e < d; o = mod(o, d *= .5))\\\n\td < o.x + o.y ? d--, o-=o : o; o++\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjfR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 201]]}
{"id": "wtjfRd", "name": "[TWITCH] Bored circuit", "author": "evvvvil", "description": "Bored cirduit - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["fractal", "lines", "demoscene", "landscape", "specular", "glow", "pattern", "scifi", "lazer", "circuit", "battery", "network", "gloss", "board", "industrial"], "likes": 26, "viewed": 642, "published": "Public API", "date": "1599659591", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Bored circuit - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\nvec2 z,v,e=vec2(.00035,-.00035);float t,b,tt,g;vec3 op,po,no,al,ld,cutP;\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nvec2 fb( vec3 p)\n{   \n    cutP=op=p;\n    cutP.xy*=r2(.785);\n    vec2 h,t=vec2(length(p.xz)-3.,5); //BLUE CUT PIECE\n    t.x=abs(t.x)-.4;\n    t.x=max(t.x,-(max(-p.x,abs(abs(abs(cutP.y)-2.)-1.)-.5)));\n    t.x=max(t.x,abs(cutP.y)-5.);\n    h=vec2(length(p.xz)-3.,6); //WHITE CUT PIECE\n    h.x=abs(h.x)-.15;\n    h.x=max(h.x,-(max(-p.x,abs(abs(abs(cutP.y)-2.)-1.)-.3)));\n    h.x=max(h.x,abs(cutP.y)-5.5);\n    float cutter=(abs(abs(cutP.y-8.)-10.)-3.);  \n    h.x=min(h.x,max(length(p.xz)-.6,-cutter));//WHITE CYLINDER  \n    float lazer=max(length(p.xz)-0.1,cutter+0.1);//LAZER\n    g+=0.2/(0.1+lazer*lazer*5.);\n    h.x=min(h.x,lazer);\n    t=t.x<h.x?t:h;\n    h=vec2(length(p.xz)-2.2,3);//BLACK CYLINDER CUT PIECE\n    h.x=abs(h.x)-.4;\n    h.x=max(h.x,abs(abs(cutP.y)-5.)-1.);\n    t=t.x<h.x?t:h;\n    return t;  \n}\nvec2 mp( vec3 p)\n{\n    op=p;\n    vec4 np=vec4(p,1);\n    vec2 h,t=vec2(1000);\n    np.z-=30.;\n    np.z=abs(abs(np.z)-20.)-10.;  \n    vec4 bp=np.xzyw; \n    for(int i=0;i<4;i++){\n        np.xyz=abs(np.xyz)-vec3(25.,clamp(5.5-ceil(-p.z*.05-.5)*4.,5.,15.),0);\n        bp.xyz=abs(bp.xyz)-vec3(20.,clamp(10.-ceil(-p.z*.05)*4.,10.,20.),0);\n        np.xy*=r2(.785);\n        bp.xy*=r2(.785);\n        h=fb(np.xyz); //DRAW VERTICAL FRACTAL\n        h.x/=np.w*1.5;\n        t=t.x<h.x?t:h;\n        h=fb(bp.xyz); //DRAW HORIZONTAL FRACTAL\n        h.x/=bp.w*1.5;\n        t=t.x<h.x?t:h;\n        h=vec2(bo(bp.xyz-vec3(12,0,0),vec3(1,100,1.+cos(p.z*.1)*2.)),3.);//DRAW BLACK BOXES\n        h.x/=bp.w;\n        t=t.x<h.x?t:h;\n        np*=2.;\n        bp*=2.;\n    }\n    p.z=mod(p.z-10.,20.)-10.; //WHITE SPHERES\n    h=vec2(length(p)-1.5,6.);  \n    t=t.x<h.x?t:h;  \n    h=vec2(max(p.y,abs(p.x)-65.),7.);  //TERRAIN\n    t=t.x<h.x?t:h;\n    return t;  \n}\nvec2 tr( vec3 ro, vec3 rd )\n{\n    vec2 h,t=vec2(.1);\n    for(int i=0;i<128;i++){\n        h=mp(ro+rd*t.x);\n        if(h.x<.0001||t.x>100.) break;\n        t.x+=h.x;t.y=h.y;\n    }\n    if(t.x>100.) t.y=0.;\n    return t;  \n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nfloat pattern(vec2 uv){return ceil(abs(sin(uv.y*5.))-.7-.5*sin(op.y*.1+tt))+ceil(abs(sin(uv.x*1.5))-.75);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n    tt=mod(iTime,56.52);\n    b=ceil(sin(tt*.5));\n    vec3 ro=mix(vec3(1),vec3(-2,3,1),b)*vec3(sin(tt*.5-.75)*6.,7.5,30.+sin(tt*.15)*70.),\n        cw=normalize(vec3(0,0,20.+sin(tt*.5)*20.)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),\n        rd=mat3(cu,cv,cw)*normalize(vec3(uv,.75)),co,fo;\n    co=fo=vec3(.2,.12,.12)-length(uv)*.1-rd.y*.3;\n    ld=normalize(vec3(0.,.5,sin(tt*.15)*.5));  \n    z=tr(ro,rd); t=z.x;\n    if(z.y>0.){\n        po=ro+rd*t;\n        no=normalize(e.xyy*mp(po+e.xyy).x+ e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x);\n        float lines=1.; vec2 linesUV=op.xy*.1;\n        for(int i=0;i<3;i++){      \n            linesUV=abs(linesUV)-.15;\n            lines=min(lines,pattern(linesUV));\n            linesUV*=3.;\n        }        \n        al=mix(vec3(0),vec3(.05,.15,.35),lines);  \n        float spo=exp2(7.-lines*5.);\n        if(z.y<5.)al=vec3(0.);  \n        if(z.y>5.)al=vec3(.8,.7,.8);  \n        if(z.y>6.)al=vec3(0.1,.05,.05)+lines*.025,spo=exp2(10.-lines*5.);\n        float dif=max(0.,dot(no,ld)),\n            fr=pow(1.+dot(no,rd),4.),\n            sp=pow(max(dot(reflect(-ld,no),-rd),0.),spo);\n        co=mix(sp+al*(a(.05)*a(.1)+.2)*(dif*vec3(.7,.6,.4)+s(4.)),fo,min(fr,.5));\n        co=mix(fo,co,exp(-.000005*t*t*t));\n    }\n    co=smoothstep(0.,1.,co);\n    fragColor = vec4(pow(co+g*.4*vec3(.1,.2,.5),vec3(.45)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjfRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 258, 275, 275, 318], [319, 319, 343, 343, 384], [385, 385, 403, 403, 1186], [1187, 1187, 1205, 1205, 2110], [2111, 2111, 2140, 2140, 2330], [2420, 2420, 2443, 2443, 2526], [2527, 2527, 2584, 2584, 4050]]}
{"id": "WtjfRG", "name": "Microwaves", "author": "bitless", "description": "Microwaves", "tags": ["2d", "waves", "sinnoise"], "likes": 38, "viewed": 397, "published": "Public", "date": "1599489954", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: bitless\n// Title: Microwaves\n\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\"\n// and Fabrice Neyret (FabriceNeyret2) for https://shadertoyunofficial.wordpress.com/\n// and Inigo Quilez (iq) for  http://www.iquilezles.org/www/index.htm\n// and whole Shadertoy community for inspiration.\n\n#define p(t, a, b, c, d) ( a + b*cos( 6.28318*(c*t+d) ) ) //palette function (https://www.iquilezles.org/www/articles/palettes/palettes.htm)\n#define S(x,y,z) smoothstep(x,y,z)\n\nfloat w(float x, float p){ //sin wave function\n    x *= 5.;\n    float t= p*.5+sin(iTime*.25)*10.5;\n    return (sin(x*.25 + t)*5. + sin(x*4.5 + t*3.)*.2 + sin(x + t*3.)*2.3  + sin(x*.8 + t*1.1)*2.5)*0.275;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 g)\n{\n    vec2 r = iResolution.xy\n        ,st = (g+g-r)/r.y;\n\n    float \tth = .05 //thickness\n    \t\t,sm = 15./r.y+.85*length(S(vec2(01.,.2),vec2(2.,.7),abs(st))) //smoothing factor\n    \t\t,c = 0. \n            ,t = iTime*0.25\n            ,n = floor((st.y+t)/.1)\n            ,y = fract((st.y+t)/.1);\n    \n    vec3 clr;\n    for (float i = -5.;i<5.;i++)\n    {\n        float f = w(st.x,(n-i))-y-i;\n        c = mix(c,0.,S(-0.3,abs(st.y),f));\n        c += S(th+sm,th-sm,abs(f))\n            *(1.-abs(st.y)*.75)\n            + S(5.5-abs(f*0.5),0.,f)*0.25;\n            \n        clr = mix(clr,p(sin((n-i)*.15),vec3(.5),vec3(.5), vec3(.270), vec3(.0,.05,0.15))*c,S(-0.3,abs(st.y),f));\n    }\n    fragColor = vec4(clr,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjfRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 498, 524, 544, 704], [708, 708, 756, 756, 1459]]}
{"id": "wtjfRV", "name": "Anti-alias any shader", "author": "GregRostami", "description": "I really love the 2D art people do with Shadertoy.\nHere's a quick way of adding anti-aliasing (box-filter) to any of your aliased shaders.", "tags": ["original144720v2"], "likes": 15, "viewed": 428, "published": "Public API", "date": "1599411644", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"original-14472.0-v2\" by jorge2017a1. https://shadertoy.com/view/Wt2BzK\n// 2020-09-06 16:45:43\n\n// See the comments below on how to anti-alias (box-filter) any of your shaders:\n\nconst vec3 COLOR_LINE = vec3(0x77, 0xB0, 0xE0) / 255.0;\nconst vec3 COLOR_MANELINE = vec3(0x1E, 0x98, 0xD3) / 255.0;\nconst vec3 COLOR_BODY = vec3(0x9E, 0xDB, 0xF9) / 255.0;\nconst vec3 COLOR_MANE1 = vec3(0xEE, 0x41, 0x44) / 255.0;\nconst vec3 COLOR_MANE2 = vec3(0xF3, 0x70, 0x33) / 255.0;\nconst vec3 COLOR_MANE3 = vec3(0xFD, 0xF6, 0xAF) / 255.0;\nconst vec3 COLOR_MANE4 = vec3(0x62, 0xBC, 0x4D) / 255.0;\nconst vec3 COLOR_MANE5 = vec3(0x67, 0x2F, 0x89) / 255.0;\nconst vec3 COLOR_EYEBROW = vec3(0x00, 0x00, 0x00) / 255.0;\nconst vec3 COLOR_IRIS1 = vec3(0xC6, 0x00, 0x6F) / 255.0;\nconst vec3 COLOR_IRIS2 = vec3(0x46, 0x00, 0x25) / 255.0;\nconst vec3 COLOR_BLACK = vec3(0x00, 0x00, 0x00) / 255.0;\nconst vec3 COLOR_WHITE = vec3(0xFF, 0xFF, 0xFF) / 255.0;\n\nconst float eps=0.0001;\n\nbool line(vec2 p, vec2 a, vec2 b)\n{\n\treturn (p.x - a.x) * (a.y - b.y) > (p.y - a.y) * (a.x - b.x);\n}\n\nbool circle(vec2 p, vec2 a, float r)\n{\n\treturn (p.x - a.x) * (p.x - a.x) + (p.y - a.y) * (p.y - a .y) > r * r;\n    \n}\n\nbool ellipse(vec2 p, vec2 a, vec2 r)\n{\n\t//return (p.x - a.x) * (p.x - a.x) / r.x / r.x + (p.y - a.y) * (p.y - a .y) / r.y / r.y > 1.0;\n    \n    p = (p-a)/r ;\n\treturn dot(p,p) > 1.0;\n    //return smoothstep ( 1.0-eps, 1.0+eps, dot(p,p) )> 1.0;\n\t\n    \n\n}\n\n\nvec2 m;\n\nbool ear(inout vec3 c, vec2 p)\n{\t\n\tfloat off;\n\tif(mod((iTime/3.14), 5.)<4.5)\n\t\toff = 0.;\n\telse\n\t\toff = sin(iTime*15.);\n\t\n\tbool A = circle(p-off*8., vec2(638, 664), 362.);\n\tbool B = circle(p-off*8., vec2(1075, 641), 323.);\n\tbool C = circle(p-off*8., vec2(646, 708), 378.);\n\tif(!A && !B && !C)\n\t{\n\t\tbool D = circle(p-off*8., vec2(637, 662), 345.);\n\t\tbool E = circle(p-off*8., vec2(1109, 588), 363.);\n\t\tbool F = circle(p-off*8., vec2(651, 692), 269.);\n\t\tbool G = circle(p-off*8., vec2(395, 732), 516.);\n\t\tif(D || E || (!F && G))\n\t\t\tc = COLOR_LINE;\n\t\telse\n\t\t\tc = COLOR_BODY;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool mane(inout vec3 c, vec2 p)\n{\tfloat off = (sin(iTime*10.)+.5)*10.;\n\tbool A = circle(p+off, vec2(434, 460), 514.);\n\tbool B = circle(p+off*.95, vec2(254, 110), 903.);\n\tbool C = circle(p+off*.90, vec2(384, 228), 668.);\n\tbool D = circle(p+off*.85, vec2(475, 505), 425.);\n\tbool E = circle(p+off*.80, vec2(513, 281), 536.);\n\tbool F = circle(p+off*.30, vec2(777, 435), 360.);\n\tbool G = circle(p+off*.20, vec2(915, 174), 554.);\n\tbool H = circle(p+off*.65, vec2(659, 444), 536.);\n\tbool I = circle(p+off*.60, vec2(-201, 601), 337.);\n\tbool J = line(p+off*.55, vec2(-253, 218), vec2(176, 590));\n\tbool K = circle(p+off*.20, vec2(-164, 1212), 882.);\n\tbool L = circle(p+off*.45, vec2(650, 764), 80.); // lol weird\n\tif(!A && !B && (C || (!D && E) || (!F && G) || (!H || (I && !J)) && !K) || !L)\n\t{\n\t\tbool M = circle(p+off, vec2(422, 434), 518.);\n\t\tbool N = circle(p+off*.9, vec2(372, 261), 647.);\n\t\tbool O = circle(p+off*.8, vec2(491, 499), 425.);\n\t\tbool P = circle(p+off*.7, vec2(395, 377), 402.);\n\t\tbool Q = circle(p+off*.6, vec2(790, 454), 352.);\n\t\tbool R = circle(p+off*.5, vec2(891, 216), 527.);\n\t\tbool S = circle(p+off*.4, vec2(680, 453), 536.);\n\t\tbool T = circle(p+off*.3, vec2(-217, 1332), 992.);\n\t\tbool U = circle(p+off*.2, vec2(-150, 586), 305.);\n\t\tbool V = line(p+off*.1, vec2(280, 404), vec2(119, 566));\n\t\tif((!M && N) || ((!O && P || !Q && !M) && R) || (!S && !M && !T) || (U && !T && V))\n\t\t{\n\t\t\tif(circle(p, vec2(491, 84)-off*.5, 764.))\n\t\t\t\tc = COLOR_MANE1;\n\t\t\telse\n\t\t\t\tif(circle(p, vec2(686, 204)-off*.2, 576.))\n\t\t\t\t\tc = COLOR_MANE2;\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_MANE3;\n\t\t}\n\t\telse\n\t\t\tc = COLOR_MANELINE;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool mane2(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(607, 464), 306.);\n\tbool B = circle(p, vec2(777, 485), 339.);\n\tbool C = circle(p, vec2(1181, -127), 463.);\n\tbool D = circle(p, vec2(-433, 198), 1442.);\n\tbool E = line(p, vec2(554, -80), vec2(1055, -80));\n\tif((A && !B || !C) && !D && E)\n\t{\n\t\tbool F = circle(p, vec2(613, 461), 319.);\n\t\tbool G = circle(p, vec2(769, 486), 323.);\n\t\tbool H = circle(p, vec2(1195, -123), 454.);\n\t\tbool I = circle(p, vec2(288, 485), 691.);\n\t\tbool J = circle(p, vec2(122, 278), 864.);\n\t\tif((F && !G || !H) && !I && !J)\n\t\t\tc = COLOR_MANE4;\n\t\telse\n\t\t{\n\t\t\tbool K = circle(p, vec2(388, 235), 607.);\n\t\t\tbool L = circle(p, vec2(416, 87), 570.);\n\t\t\tif(K && !L)\n\t\t\t\tc = COLOR_MANE5;\n\t\t\telse\n\t\t\t\tc = COLOR_MANELINE;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool face(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(588, 396), 357.);\n\tbool B = line(p, vec2(325, 74), vec2(887, 122));\n\tbool C = ellipse(p, vec2(489, 237), vec2(287, 166));\n\tbool D = circle(p, vec2(209, 437), 163.);\n\tif(!A && B || !C && D)\n\t{\n\t\tbool E = ellipse(p, vec2(536, 253), vec2(315, 170));\n\t\tbool F = circle(p, vec2(500, 921), 828.);\n\t\tbool G = circle(p, vec2(220, 367), 110.);\n\t\tbool H = line(p, vec2(201, 454), vec2(658, 108));\n\t\tbool I = line(p, vec2(237, 115), vec2(363, 238));\n\t\tbool J = ellipse(p, vec2(283, 204), vec2(68, 57));\n\t\tbool K = ellipse(p*(sin(iTime/1.75)/85.+1.), vec2(253, 192), vec2(102, 70));\n\t\tbool L = circle(p, vec2(285, 228), 19.);\n\t\tbool M = circle(p, vec2(281, 236), 19.);\n\t\tif((!E && !F && G || H) && (I || !J || K) && (L || !M))\n\t\t\tc = COLOR_BODY;\n\t\telse\n\t\t\tc = COLOR_LINE;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool eye1(inout vec3 c, vec2 p, vec2 off)\n{\t\n\t\t\n\t// skewed ellipse please ignore\n#define SQR(q) ((q) * (q))\n\tbool A = SQR((p.x - 590.0) / 150.0 - (p.y - 378.0) / 900.0) + SQR((p.y - 378.0) / 180.0) < 1.0;\n\tif(A)\n\t{\n\t\tbool B = SQR((p.x - 593.0) / 149.0 - (p.y - 382.0) / 900.0) + SQR((p.y - 361.0) / 180.0) < 1.0;\n\t\tif(B)\n\t\t{\n\t\t\tvec2 d = vec2(0.0, 0.0) - vec2(580, 360);\n\t\t\tif(length(d) > 60.0)\n\t\t\t   d = d / length(d) * 60.0;\n\t\t\tbool C = ellipse(p-off*50., vec2(580, 360) + d, vec2(112, 162));\n\t\t\tif(C)\n\t\t\t\tc = COLOR_WHITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool D = ellipse(p-off*55., vec2(551, 305) + d, vec2(19, 26));\n\t\t\t\tbool E = ellipse(p-off*55., vec2(601, 410) + d, vec2(35, 57));\n\t\t\t\tif(D && E)\n\t\t\t\t{\n\t\t\t\t\tbool F = ellipse(p-off*50., vec2(580, 360) + d * 1.3, vec2(71, 126));\n\t\t\t\t\tif(F)\n\t\t\t\t\t\tc = mix(COLOR_IRIS1, COLOR_IRIS2, SQR((p.y - 360.0 - d.y) / 252.0 + 0.5));\n\t\t\t\t\telse\n\t\t\t\t\t\tc = COLOR_BLACK;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_WHITE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tc = COLOR_EYEBROW;\n\t\treturn true;\n\t}\n\t// rotating ellipses hacks, nothing to see here\n\tbool G = ellipse(p, vec2(757, 430), vec2(40, 5));\n\tbool H = ellipse(vec2(p.x + p.y * 0.3, p.x * -0.3 + p.y), vec2(890, 260), vec2(40, 6));\n\tbool I = ellipse(vec2(p.x + p.y * 0.5, p.x * -0.5 + p.y), vec2(990, 175), vec2(40, 7));\n\tif(!G || !H || !I)\n\t{\n\t\tc = COLOR_BLACK;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool eye2(inout vec3 c, vec2 p, vec2 off)\n{\n\tbool A = line(p, vec2(207, 460), vec2(323, 265));\n\tbool B = circle(p, vec2(213, 434), 158.);\n\tbool C = circle(p, vec2(739, 417), 500.);\n\tbool D = ellipse(p, vec2(289, 444), vec2(50, 144));\n\tif(!A && !B && !C || !D)\n\t{\n\t\tbool E = ellipse(p, vec2(285, 390), vec2(47, 184));\n\t\tif(!E)\n\t\t{\n\t\t\tvec2 d = vec2(0.0, 0.0) - vec2(290, 360);\n\t\t\tif(length(d) > 60.0)\n\t\t\t   d = d / length(d) * 60.0;\n\t\t\td *= vec2(0.33, 1.0);\n\t\t\tbool F = ellipse(p-off*50., vec2(290, 360) + d, vec2(50, 162));\n\t\t\tif(F)\n\t\t\t\tc = COLOR_WHITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool D = ellipse(p-off*55., vec2(304, 446) + d, vec2(17, 41));\n\t\t\t\tbool E = ellipse(p-off*55., vec2(278, 354) + d, vec2(11, 24));\n\t\t\t\tif(D && E)\n\t\t\t\t{\n\t\t\t\t\tbool F = ellipse(p-off*50., vec2(290, 360) + d * 1.3, vec2(42, 126));\n\t\t\t\t\tif(F)\n\t\t\t\t\t\tc = mix(COLOR_IRIS1, COLOR_IRIS2, SQR((p.y - 360.0 - d.y) / 252.0 + 0.5));\n\t\t\t\t\telse\n\t\t\t\t\t\tc = COLOR_BLACK;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_WHITE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tc = COLOR_EYEBROW;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool neck(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(1247, -28), 638.);\n\tbool B = circle(p, vec2(353, 258), 638.);\n\tbool C = line(p, vec2(554, -80), vec2(1055, -80));\n\tif(!A && !B && C)\n\t{\n\t\tbool D = circle(p, vec2(1235, -21), 606.);\n\t\tif(D)\n\t\t\tc = COLOR_LINE;\n\t\telse\n\t\t\tc = COLOR_BODY;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvec2 transform(vec2 x)\n{\n\treturn (x - iResolution.xy / 2.0) / iResolution.y * 1000.0 + 500.0;\n}\n\nfloat sinslope(float t)\n{\n\treturn sin(t) - sin(t - 0.01);\t\n}\n\n// Here's where you would normally have your final void mainImage()\nvec4  fC ( in vec2 fragCoord ) // Change the void mainImage of your shader to this.\n{\n\tfloat off = sin(iTime/1.75);\n\tif(off < 0.)\n\t\toff=0.;\n\telse if(off > .8)\n\t\toff=.8;\n\t\n\tm = transform(iMouse.xy * iResolution.xy);\n\tvec2 p = transform(fragCoord.xy);\n\tp.x += sin(iTime) * 200.0;\n\tp.y += abs(sin(iTime*7.0))*10.0 * (abs(sinslope(iTime)) * 200.0);\n\tvec3 c = vec3(1, 1, 1);\n\tear(c, p) || mane(c, p) || mane2(c, p) || eye1(c, p, vec2(off*1.6,off*.5)) || eye2(c, p, vec2(off*.4,off*.5))  || face(c, p) || neck(c, p);\n\treturn vec4(c, 1); // At the end of your shader, replace the fragColor with this return. \n}\n\n// Box-filter by Greg Rostami\n// Add this code to the bottom of any shader that has aliasing problems:\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    float A = 8.,  // Change A to define the level of anti-aliasing (1 to 16) ... higher numbers are REALLY slow!\n          s = 1./A, x, y;\n    \n    for (x=-.5; x<.5; x+=s) for (y=-.5; y<.5; y+=s) fragColor += min ( fC(vec2(x,y)+fragCoord), 1.0);\n        \n\tfragColor /= A*A;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjfRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 959, 994, 994, 1059], [1061, 1061, 1099, 1099, 1178], [1180, 1180, 1218, 1314, 1432], [1444, 1444, 1476, 1476, 2049], [2051, 2051, 2084, 2084, 3687], [3689, 3689, 3723, 3723, 4469], [4471, 4471, 4504, 4504, 5324], [5326, 5326, 5369, 5406, 6665], [6667, 6667, 6710, 6710, 7697], [7699, 7699, 7732, 7732, 8026], [8028, 8028, 8052, 8052, 8123], [8125, 8125, 8150, 8150, 8185], [8187, 8255, 8340, 8340, 8858], [8860, 8963, 9020, 9020, 9322]]}
{"id": "WtjfWm", "name": "Math Animation 2", "author": "Deirin", "description": "idkk", "tags": ["2d", "math", "sdf", "animation", "pattern"], "likes": 9, "viewed": 109, "published": "Public", "date": "1599156808", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //time\n    float t = iTime;\n    \n    //uvs\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;    \n    vec2 grid_uv = fract(uv * mix(9.5, 10., sin(t*2.)*.5+.5)) - .5;\n    \n    //rotations\n    //float a = length(uv) * 3. + t;\n    //float s = sin(a);\n    //float c = cos(a);\n    //mat2 rot = mat2(s,-c, c,s);\n    //grid_uv *= rot;\n    \n    //sdfs\n    float wave = sin( length( uv * 10. ) - t * 5. ) *.5 + .5;\n    float r = mix( .3, .6, wave );\n    \n    float d;\n\tfloat d2;\n    \n    for(int x = -1; x < 1; x++){\n       for(int y = -1; y < 1; y++){\n           vec2 offset = vec2(x,y);\n           \n           d = length( grid_uv - offset ) - r;\n    \t   d2 = sdRoundedX(grid_uv - offset, .8, r * .2);\n           d = mix(d, d2, sin(t*4.5)*.5+.5);\n           d = abs(d) - mix(0.01, .2, sin(t * 2.)*.5+.5);\n       }  \n    }\n     \n    //color\n    //vec3 col = mix(vec3(.9, .5, 0.2),vec3(.45, .23, 0.6), d);\n    \n    //output\n    fragColor = vec4( 1. - iResolution.y/8. * d );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjfWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 118], [120, 120, 177, 188, 1160]]}
{"id": "WtSBD3", "name": "Box Projection Projection", "author": "timeisbeautifulhere", "description": "Funky projection of boxes to other boxes, with even more boxes inside the projected boxes. Overly convoluted, but that's the way I roll :P\n\nPlay with the macro values for extra fun.", "tags": ["distortion", "projection", "box", "stripes"], "likes": 2, "viewed": 225, "published": "Public API", "date": "1599944560", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define LINE_WIDTH 0.005\n\n//Scale ratio of outer to inner boxes\n#define SCALE_RATIO 0.65\n\n//How far apart subsequent boxes are\n#define SCALE_SPACING 0.55\n\n//When a box should loop\n#define SCALE_CUTOFF 1.25\n\n#define NUM_SQUARES 3\n#define TIME_CONST 0.1\n\n//Variables for \"split\" stripe effect.\n//High values for SPLIT_COUNT are fun.\n#define SPLIT_COUNT 5\n#define STRIPE_LINE_WIDTH 0.03\n#define STRIPE_TIME_CONST 0.25\n#define STRIPE_TIME_CUTOFF 10.0\n\n//Color variables\n#define STRIPE_CONST_A 1.3\n#define STRIPE_CONST_B 0.712\n#define STRIPE_COLOR_TIME_CONST 0.025\n\n#define DISABLE_STRIPE_TIME_EFFECT false\n#define DISABLE_STRIPE_LOOP false\n//#define DISABLE_STRIPE_TIME_EFFECT true\n//#define DISABLE_STRIPE_LOOP true\n\n//Find closest point on a line segment, given a point p3.\n//Then compute whether it is \"on\" the line by computing\n//distance from the segment.\n//Thank you Paul Bourke http://paulbourke.net/geometry/pointlineplane/\nbool on_segment(vec2 p1, vec2 p2, vec2 p3, float thickness){\n    float u = ((p3.x-p1.x)*(p2.x-p1.x) +\n               \t(p3.y-p1.y)*(p2.y-p1.y)) /\n        \t\tpow(length(vec2(p2.x-p1.x, p2.y-p1.y)),2.0);\n    \n    //Check within bounds of segment\n    if(u<0.0||u>1.0)\n        return false;\n    \n    vec2 point_on_line = vec2(\n        p1.x + u*(p2.x-p1.x),\n        p1.y + u*(p2.y-p1.y)\n    );\n\treturn distance(point_on_line, p3)<=thickness;\n}\n\n//Same as above, but returns distance instead\nfloat dist_from_segment(vec2 p1, vec2 p2, vec2 p3){\n    float u = ((p3.x-p1.x)*(p2.x-p1.x) +\n               \t(p3.y-p1.y)*(p2.y-p1.y)) /\n        \t\tpow(length(vec2(p2.x-p1.x, p2.y-p1.y)),2.0);\n    \n    vec2 point_on_line = vec2(\n        p1.x + u*(p2.x-p1.x),\n        p1.y + u*(p2.y-p1.y)\n    );\n\t\n    return distance(point_on_line, p3);\n}\n\nbool on_rectangle(vec2 ll, vec2 ur, vec2 uv){\n    vec2 ul = vec2(ll.x,ur.y),\n        lr = vec2(ur.x, ll.y);\n    \n    return on_segment(ll,lr,uv,LINE_WIDTH) ||\n        on_segment(lr,ur,uv,LINE_WIDTH) ||\n        on_segment(ur,ul,uv,LINE_WIDTH) ||\n        on_segment(ul,ll,uv,LINE_WIDTH);\n}\n\n//Find \"split point\", or where the closest\n//stripe line is given a split factor.\n//The use of this is less apparent with\n//DISABLE_STRIPE_TIME_EFFECT false\nfloat closest_split(vec2 uv, int split_cnt){\n    \n    float dist = uv.y;\n    float delta = (dist*2.0)/float(split_cnt);\n    \n    float x = uv.x + (dist);\n    \n    float closest_delta = round(x/delta);\n    float closest = (closest_delta*delta);\n    \n    return closest - dist;\n}\n\nint closest_split_num(vec2 uv, int split_cnt){\n    \n    float dist = uv.y;\n    float delta = (dist*2.0)/float(split_cnt);\n    \n    float x = uv.x + (dist);\n    \n    float closest_delta = round(x/delta);\n    \n    return int(closest_delta);\n}\n\n//Check if uv is on a \"stripe\" between two scaled\n//boxes\nint on_stripes(vec2 uv, int split_cnt, float inner_scale, float outer_scale){\n    \n    if((abs(uv.x)<inner_scale && abs(uv.y)<inner_scale) ||\n       (abs(uv.x)>outer_scale && abs(uv.y)>outer_scale))\n        return -1;\n   \t\n    vec2 p = vec2(uv);\n    \n    //In \"top\" region\n    if(uv.y > inner_scale && uv.x > -uv.y && uv.x < uv.y)\n        p = vec2(uv.x, uv.y);\n    \n    //In \"bottom\" region\n    else if(uv.y < -inner_scale && uv.x > uv.y && uv.x < -uv.y)\n        p = vec2(uv.x, -uv.y);\n    \n    //In \"left\" region\n    else if(uv.x < -inner_scale && uv.y > uv.x && uv.y < -uv.x)\n        p = vec2(uv.y, -uv.x);\n   \t\n    //In \"right\" region\n    else if(uv.x > inner_scale && uv.y > -uv.x && uv.y < uv.x)\n        p = vec2(uv.y, uv.x);\n    \n    //Inside box, not in any region\n    else\n        return -1;\n    \n    if(p.y > outer_scale)\n        return -1;\n    \n    //Really funky time based effect on\n   \t//stripes\n    if(!DISABLE_STRIPE_TIME_EFFECT){\n    \t//\"Loop\" time effect on distortion of stripes.\n        //Here because it gets weird at higher time values.\n    \tif(!DISABLE_STRIPE_LOOP)\n    \t\tp.x += mod(iTime*STRIPE_TIME_CONST,STRIPE_TIME_CUTOFF);\n        else\n            p.x += iTime*STRIPE_TIME_CONST;\n    \tp.x = mod(p.x, p.y);\n    }\n    \n    float closest = closest_split(p, split_cnt);    \n    if(abs(closest-p.x) < STRIPE_LINE_WIDTH)\n        return closest_split_num(p, split_cnt);\n    else\n        return -1;\n}\n\n//Draw an array of boxes, defined by their \"outer scale\".\n//Draws the boxes and stripes inside them.\nvec3 draw_rectangles(vec2 uv, float scales[NUM_SQUARES]){\n    vec3 col = vec3(1.0);\n    \n    for(int i=0;i<NUM_SQUARES;i++){\n        float scale_outer = scales[i],\n            scale_inner = scales[i]*SCALE_RATIO;\n        \n        //Check if on any \"stripes\" splitting edge regions\n        int stripe_num = on_stripes(uv, SPLIT_COUNT, scale_inner, scale_outer);\n        if(stripe_num != -1){\n            //Funky color effect with random math\n            float stripe_1 = float(stripe_num) * STRIPE_CONST_A + STRIPE_CONST_B,\n                stripe_2 = float(stripe_num) * (1.0/STRIPE_CONST_B) + STRIPE_CONST_A,\n                stripe_3 = STRIPE_COLOR_TIME_CONST * iTime;\n            \n\t        col = vec3(\n                fract(stripe_1 * stripe_3),\n                fract(stripe_2 * stripe_3),\n                fract(mix(stripe_1,stripe_2, stripe_3))\n            );\n        }\n        \n        //Draw outer and inner boxes\n    \tvec2 ll = vec2(-scale_outer,-scale_outer),\n        \tur = vec2(scale_outer,scale_outer);\n    \tvec2 inner_ll = vec2(-scale_inner,-scale_inner),\n\t        inner_ur = vec2(scale_inner,scale_inner);\n    \n    \tif(on_rectangle(ll,ur,uv) || on_rectangle(inner_ll,inner_ur, uv))\n        \tcol = vec3(0.0);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [-1, 1]\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n\n    vec3 col = vec3(1.0);\n    \n    float scales[NUM_SQUARES];\n    scales[0] = 1.0 + TIME_CONST*iTime;\n    for(int i=1;i<NUM_SQUARES;i++)\n    \tscales[i] = scales[i-1]-SCALE_SPACING;\n    for(int i=0;i<NUM_SQUARES;i++){\n        float inner = scales[i]*SCALE_RATIO;\n        if(inner > SCALE_CUTOFF)\n            scales[i] = mod(inner,SCALE_CUTOFF)/SCALE_RATIO;\n    }\n    \n    col = draw_rectangles(uv,scales);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSBD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[715, 929, 989, 989, 1365], [1367, 1413, 1464, 1464, 1749], [1751, 1751, 1796, 1796, 2038], [2040, 2197, 2241, 2241, 2474], [2476, 2476, 2522, 2522, 2716], [2718, 2776, 2853, 2853, 4195], [4197, 4298, 4355, 4355, 5544], [5546, 5546, 5603, 5618, 6147]]}
{"id": "wtSBDt", "name": "CylinderDeformText", "author": "Del", "description": "CylinderDeformText test", "tags": ["deform", "font", "cylinder"], "likes": 11, "viewed": 246, "published": "Public API", "date": "1600124634", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// cylinder deform text test - Del 14/09/2020\n\n#define AA 1\t// increase this to 2 if you are cold...\nfloat mat;\t\t// dirty material\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nfloat Sampx( int iChar, vec2 vCharUV )\n{\n    vec2 iChPos = vec2( mod(float(iChar),16.0), iChar / 16 );\n    vec2 vUV = (vec2(iChPos) + vCharUV) / 16.0;\n    return textureLod( iChannel0, vUV, 0.0 ).w - 0.5 ;\n}\n\nint GetTxChar (int _nc)\n{\n    if(_nc==0) return(0x53);\n    if(_nc==1) return(0x48);\n    if(_nc==2) return(0x41);\n    if(_nc==3) return(0x44);\n    if(_nc==4) return(0x45);\n    if(_nc==5) return(0x52);\n    if(_nc==6) return(0x54);\n    if(_nc==7) return(0x4f);\n    if(_nc==8) return(0x59);\n    return 32;\n}\n\nfloat chars(vec3 p)\n{\n    float cc1 = pModInterval1(p.z,0.8,-2.0,2.0); \t\t// vertical repeat\n    p = p.xzy;\n    p.x = -p.x;\n   \tp.yz *= rot(3.141);\n        \n    float c1 = pModInterval1(p.x,0.8,-5.0,5.0);\n    float zdist = 0.25+(0.5+sin(cc1*c1+iTime*4.0)*0.5)*0.2;\n    vec3 r1 = p;\n\tint charid = GetTxChar(int(c1+4.0));\n\tfloat symbolDist = Sampx( charid, (r1.xy+vec2(0.5,0.5)) ) - 0.00001;\n\tfloat boxdist2 = sdBox(r1-vec3(0.0,0.0,-0.25), vec3(0.35 , 0.35, 0.2));\n\tfloat boxdist = sdBox(r1-vec3(0.0,0.0,zdist), vec3(0.5 , 0.5, zdist));\n    symbolDist = max(boxdist,symbolDist);\n    mat = step(symbolDist,boxdist2)*0.5 + ((mod(iTime*10.0,200.0)+c1+cc1)/25.0);\n    symbolDist = min(boxdist2,symbolDist);\n    return symbolDist;\n}\n\nfloat map( in vec3 pos )\n{\n    mat=0.0;\n\n    // Deform Space...\n    float len = 32.0+sin(iTime*1.3)*17.0;\n    float rad =  (1.0/(3.141*2.0)*len);\n    float ang = atan(pos.x, pos.y);\n    vec2 cyl = vec2(rad-length(pos.xy), pos.z);\n    vec3 dp = vec3(cyl, ang * rad);\n\n    if (iMouse.z>0.5)\n    {\n        dp=pos.zyx;//flat\n        dp.xy *= rot(4.7115);\n    }\n\tfloat dd = chars(dp.zxy);\n    return dd*0.5;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n  // igo Qulez\n  // https://www.shadertoy.com/view/MsS3Wc\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n  rgb = rgb * rgb * (3. - 2. * rgb);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 1.5+sin(iTime)*0.5;\n    \n\tvec3 ro = vec3( 10.0*cos(an), 10.0*sin(an),sin(iTime*1.44)*3.0);\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    \n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 50.0;\n        float t = 0.0;\n        for( int i=0; i<100; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n\t\t\tvec3 _col = hsv2rgb(vec3(mat,0.55,0.6));\n            col = _col*amb + _col*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSBDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 132, 163, 163, 250], [252, 252, 273, 273, 341], [344, 344, 417, 417, 703], [705, 705, 745, 745, 912], [914, 914, 939, 939, 1217], [1219, 1219, 1240, 1240, 1943], [1945, 1945, 1971, 1971, 2349], [2351, 2351, 2373, 2437, 2584], [2587, 2651, 2683, 2683, 2921], [2928, 2928, 2985, 3010, 4613]]}
{"id": "wtSBWd", "name": "Black Hex wave", "author": "celifrog", "description": "90% Credit to IQ for original! ", "tags": ["wave"], "likes": 1, "viewed": 180, "published": "Public API", "date": "1600137816", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Everybody has to implement an hexagonal grid. This it mine.\n// It does raycasting on it, efficiently (just a few muls per step) and robustly\n// (works in integers). Each cell is visited only once and in the right order.\n// Based on https://www.shadertoy.com/view/WtSBWK Check castRay() in line 92.\n\n// That, plus the fact the ambient occlusion is analytical means this shader should\n// run smoothly even on a crappy phone. It does on mine!\n\n\n#if HW_PERFORMANCE==11\n#define AA 1\n#else\n#define AA 2   // make this bigger if you have a storng PC\n#endif\n\n\n// --------------------------------------\n// mod3\n// --------------------------------------\nint mod3( int n )\n{\n    return (n<0) ? 2-((2-n)%3) : n%3;\n    \n    // Other methods of computing mod3:           // PC-WebGL  Native-OpenGL  Android WebGL\n    //\n    // 1.  return (n<0) ? 2-((2-n)%3) : n%3;      //    Ok        Ok            Ok \n    // 2.  return int((uint(n)+0x80000001U)%3u);  //    Ok        Ok            Broken\n    // 3.  n %= 3; return (n<0)?n+3:n;            //    Ok        Broken        Ok\n    // 4.  n %= 3; n+=((n>>31)&3); return n;      //    Ok        Broken        Ok\n    // 5.  return ((n%3)+3)%3;                    //    Ok        Broken        Ok\n    // 6.  return int[](1,2,0,1,2)[n%3+2];        //    Ok        Broken        Ok\n}\n\n// --------------------------------------\n// hash by Hugo Elias)\n// --------------------------------------\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\n\n// --------------------------------------\n// basic hexagon grid functions\n// --------------------------------------\nivec2 hexagonID( vec2 p ) \n{\n    const float k3 = 1.732050807;\n\tvec2 q = vec2( p.x, p.y*k3*0.5 + p.x*0.5*p.x*p.y*k3);\n\n    ivec2 pi = ivec2(floor(q));\n\tvec2  pf =       fract(q);\n    \n\tint v = mod3(pi.x+pi.y);\n\n\tint   ca = (v<1)?0:1;\n\tint   cb = (v<2)?0:1;\n    ivec2 ma = (pf.x>pf.y)?ivec2(0,1):ivec2(1,0);\n    \n\tivec2 id = pi + ca - cb*ma;\n    \n    return ivec2( id.x, id.y - (id.x+id.y)/3 );\n}\n\nvec2 hexagonCenFromID( in ivec2 id )\n{\n    const float k3 = 1.732050807;\n    return vec2(float(id.x),float(id.y)*k3);\n}\n\n// ---------------------------------------------------------------------\n// the height function. yes, i know reading from a video texturr is cool\n// ---------------------------------------------------------------------\nconst float kMaxH = 16.0;\n\nfloat map( vec2 p, in float time )\n{\n    p *=0.10;\n    float f = 0.5+0.5*sin(0.53*p.x+0.5*time+1.0*sin(p.y*0.24))*\n                      sin(0.13*p.y+time);\n    f*= 0.75+0.25*sin(1.7*p.x+1.32*time)*sin(1.3*p.y+time*2.1);\t\n\treturn kMaxH*f;\n}\n\n// --------------------------------------------------\n// raycast. this function is the point of this shader\n// --------------------------------------------------\nvec4 castRay( in vec3 ro, in vec3 rd, in float time, \n              out ivec2 outPrismID, out int outFaceID )\n{\n\tivec2 hid = hexagonID(ro.xz);\n    \n\tvec4 res = vec4( -1.0, 0.0, 0.0, 0.0 );\n\n    const float k3 = 0.866025;\n    const vec2 n1 = vec2( 1.0,0.0);\n    const vec2 n2 = vec2( 0.5,k3);\n    const vec2 n3 = vec2(-0.5,k3);\n    \n    float d1 = 1.0/dot(rd.xz,n1);\n    float d2 = 1.0/dot(rd.xz,n2);\n    float d3 = 1.0/dot(rd.xz,n3);\n    float d4 = 1.0/rd.y;\n    \n    float s1 = (d1<0.0)?-1.0:1.0;\n    float s2 = (d2<0.0)?-1.0:1.0;\n    float s3 = (d3<0.0)?-1.0:1.0;\n    float s4 = (d4<0.0)?-1.0:1.0;\n\n    ivec2 i1 = ivec2( 2,0); if(d1<0.0) i1=-i1;\n    ivec2 i2 = ivec2( 1,1); if(d2<0.0) i2=-i2;\n    ivec2 i3 = ivec2(-1,1); if(d3<0.0) i3=-i3;\n\n    // traverse hexagon grid (in 2D)\n    bool found = false;\n    vec2 t1, t2, t3, t4;\n\tfor( int i=0; i<100; i++ ) \n\t{\n        // fetch height for this hexagon\n\t\tvec2  ce = hexagonCenFromID( hid );\n        float he = 0.5*map(ce, time);\n\n        // compute ray-hexaprism intersection\n        vec3 oc = ro - vec3(ce.x,he,ce.y);\n        t1 = (vec2(-s1,s1)-dot(oc.xz,n1))*d1;\n        t2 = (vec2(-s2,s2)-dot(oc.xz,n2))*d2;\n        t3 = (vec2(-s3,s3)-dot(oc.xz,n3))*d3;\n        t4 = (vec2(-s4,s4)*he-oc.y)*d4;\n        float tN = max(max(t1.x,t2.x),max(t3.x,t4.x));\n        float tF = min(min(t1.y,t2.y),min(t3.y,t4.y));\n        if( tN<tF && tF>0.0 )\n        {\n            found = true;\n            break;\n        }\n        \n        // move to next hexagon\n             if( t1.y<t2.y && t1.y<t3.y ) hid += i1;\n        else if( t2.y<t3.y )              hid += i2;\n        else                              hid += i3;\n\t}\n\n\tif( found )\n    {\n                         {res=vec4(t1.x,s1*vec3(n1.x,0,n1.y)); outFaceID=(d1<0.0)?-1: 1;}\n        if( t2.x>res.x ) {res=vec4(t2.x,s2*vec3(n2.x,0,n2.y)); outFaceID=(d2<0.0)?-2: 2;}\n        if( t3.x>res.x ) {res=vec4(t3.x,s3*vec3(n3.x,0,n3.y)); outFaceID=(d3<0.0)?-3: 3;}\n        if( t4.x>res.x ) {res=vec4(t4.x,s4*vec3( 0.0,1,0));    outFaceID=(d4<0.0)? 4:-4;}\n\n        outPrismID = hid;\n    }\n    \n\treturn res;\n}\n\n// -------------------------------------------------------------------------\n// same as above, but simpler sinec we don't need the normal and primtive id\n// --------------------------------------------------------------------------\nfloat castShadowRay( in vec3 ro, in vec3 rd, in float time )\n{\n    float res = 1.0;\n    \n    ivec2 hid = hexagonID(ro.xz);\n    \n    const float k3 = 0.866025;\n    const vec2 n1 = vec2( 1.0,0.0);\n    const vec2 n2 = vec2( 0.5,k3);\n    const vec2 n3 = vec2(-0.5,k3);\n    \n    float d1 = 1.0/dot(rd.xz,n1);\n    float d2 = 1.0/dot(rd.xz,n2);\n    float d3 = 1.0/dot(rd.xz,n3);\n    float d4 = 1.0/rd.y;\n    \n    float s1 = (d1<0.0)?-1.0:1.0;\n    float s2 = (d2<0.0)?-1.0:1.0;\n    float s3 = (d3<0.0)?-1.0:1.0;\n    float s4 = (d4<0.0)?-1.0:1.0;\n\n    ivec2 i1 = ivec2( 2,0); if(d1<0.0) i1=-i1;\n    ivec2 i2 = ivec2( 1,1); if(d2<0.0) i2=-i2;\n    ivec2 i3 = ivec2(-1,1); if(d3<0.0) i3=-i3;\n\n    vec2 c1 = (vec2(-s1,s1)-dot(ro.xz,n1))*d1;\n    vec2 c2 = (vec2(-s2,s2)-dot(ro.xz,n2))*d2;\n    vec2 c3 = (vec2(-s3,s3)-dot(ro.xz,n3))*d3;\n\n    // traverse regular grid (2D)\t\n\tfor( int i=0; i<8; i++ ) \n\t{\n\t\tvec2  ce = hexagonCenFromID( hid );\n        float he = 0.5*map(ce, time);\n                \n        vec2 t1 = c1 + dot(ce,n1)*d1;\n        vec2 t2 = c2 + dot(ce,n2)*d2;\n        vec2 t3 = c3 + dot(ce,n3)*d3;\n        vec2 t4 = (vec2(1.0-s4,1.0+s4)*he-ro.y)*d4;\n        \n        float tN = max(max(t1.x,t2.x),max(t3.x,t4.x));\n        float tF = min(min(t1.y,t2.y),min(t3.y,t4.y));\n        if( tN < tF && tF > 0.0)\n        {\n            res = 0.0;\n            break;\n\t\t}\n        \n             if( t1.y<t2.y && t1.y<t3.y ) hid += i1;\n        else if( t2.y<t3.y )              hid += i2;\n        else                              hid += i3;\n\t}\n\n\treturn res;\n}\n\n// -------------------------------------------------------------------------\n// analytic occlusion of a quad and an hexagon\n// -------------------------------------------------------------------------\n\nfloat macos(float x ) { return acos(clamp(x,-1.0,1.0));}\n\nfloat occlusionQuad( in vec3 pos, in vec3 nor, \n                     in vec3 v0, in vec3 v1,\n                     in vec3 v2, in vec3 v3 ) \n{\n    v0 = normalize(v0-pos);\n    v1 = normalize(v1-pos);\n    v2 = normalize(v2-pos);\n    v3 = normalize(v3-pos);\n    float k01 = dot( nor, normalize( cross(v0,v1)) ) * macos( dot(v0,v1) );\n    float k12 = dot( nor, normalize( cross(v1,v2)) ) * macos( dot(v1,v2) );\n    float k23 = dot( nor, normalize( cross(v2,v3)) ) * macos( dot(v2,v3) );\n    float k30 = dot( nor, normalize( cross(v3,v0)) ) * macos( dot(v3,v0) );\n    \n    return abs(k01+k12+k23+k30)/6.283185;\n}\n\nfloat occlusionHexagon( in vec3 pos, in vec3 nor, \n                        in vec3 v0, in vec3 v1,\n                        in vec3 v2, in vec3 v3,\n                        in vec3 v4, in vec3 v5) \n{\n    v0 = normalize(v0-pos);\n    v1 = normalize(v1-pos);\n    v2 = normalize(v2-pos);\n    v3 = normalize(v3-pos);\n    v4 = normalize(v4-pos);\n    v5 = normalize(v5-pos);\n    float k01 = dot( nor, normalize( cross(v0,v1)) ) * macos( dot(v0,v1) );\n    float k12 = dot( nor, normalize( cross(v1,v2)) ) * macos( dot(v1,v2) );\n    float k23 = dot( nor, normalize( cross(v2,v3)) ) * macos( dot(v2,v3) );\n    float k34 = dot( nor, normalize( cross(v3,v4)) ) * macos( dot(v3,v4) );\n    float k45 = dot( nor, normalize( cross(v4,v5)) ) * macos( dot(v4,v5) );\n    float k50 = dot( nor, normalize( cross(v5,v0)) ) * macos( dot(v5,v0) );\n    \n    return abs(k01+k12+k23+k34+k45+k50)/6.283185;\n}\n\n// -------------------------------------------------------------------------\n// get the walls and top face vertex positions\n// -------------------------------------------------------------------------\n\nbool getPrismWall( ivec2 prismID, int sid, in float time,\n                   out vec3 v0, out vec3 v1, out vec3 v2, out vec3 v3 )\n{\n    const ivec2 i1 = ivec2( 2,0);\n    const ivec2 i2 = ivec2( 1,1);\n    const ivec2 i3 = ivec2(-1,1);\n    \n    vec2  ce = hexagonCenFromID( prismID );\n    vec3  ce3 = vec3(ce.x,0.0,ce.y);\n\tfloat he = map( ce, time);\n    \n    const float kRa = 2.0/sqrt(3.0);\n    const float kC1 = kRa*0.5;\n    const float kC2 = kRa*1.0;\n    \n    if( sid==0 )\n    {\n    \tfloat he1p = map(hexagonCenFromID( prismID+i1 ), time);\n        if( he1p<he ) return false;\n    \tv0 = vec3(1.0,he,   kC1);\n    \tv1 = vec3(1.0,he1p, kC1);\n    \tv2 = vec3(1.0,he1p,-kC1);\n        v3 = vec3(1.0,he,  -kC1);\n    }\n    else if( sid==1 )\n    {\n    \tfloat he3m = map(hexagonCenFromID( prismID-i3 ), time);\n    \tif( he3m<he ) return false;\n        v0 = vec3( 1.0,he,  -kC1);\n        v1 = vec3( 1.0,he3m,-kC1);\n        v2 = vec3( 0.0,he3m,-kC2);\n        v3 = vec3( 0.0,he,  -kC2);\n    }\n    else if( sid==2 )\n    {\n    \tfloat he2m = map(hexagonCenFromID( prismID-i2 ), time);\n        if( he2m<he ) return false;\n        v0 = vec3( 0.0,he,  -kC2);\n        v1 = vec3( 0.0,he2m,-kC2);\n        v2 = vec3(-1.0,he2m,-kC1);\n        v3 = vec3(-1.0,he,  -kC1);\n    }\n    else if( sid==3 )\n    {\n        float he1m = map(hexagonCenFromID( prismID-i1 ), time);\n        if( he1m<he ) return false;\n        v0 = vec3(-1.0,he,  -kC1);\n        v1 = vec3(-1.0,he1m,-kC1);\n        v2 = vec3(-1.0,he1m, kC1);\n        v3 = vec3(-1.0,he,   kC1);\n    }\n    else if( sid==4 )\n    {\n    \tfloat he3p = map(hexagonCenFromID( prismID+i3 ), time);\n        if( he3p<he ) return false;\n        v0 = vec3(-1.0,he,   kC1);\n        v1 = vec3(-1.0,he3p, kC1);\n        v2 = vec3( 0.0,he3p, kC2);\n        v3 = vec3( 0.0,he,   kC2);\n    }\n    else //if( sid==5 )\n    {\n    \tfloat he2p = map(hexagonCenFromID( prismID+i2 ), time);\n        if( he2p<he ) return false;\n        v0 = vec3( 0.0,he,   kC2);\n        v1 = vec3( 0.0,he2p, kC2);\n        v2 = vec3( 1.0,he2p, kC1);\n        v3 = vec3( 1.0,he,   kC1);\n    }      \n    \n    v0 += ce3;\n    v1 += ce3;\n    v2 += ce3;\n    v3 += ce3;\n\n    return true;\n}\n    \nvoid getPrismTop( ivec2 prismID, in float time,\n                 out vec3 v0, out vec3 v1, out vec3 v2, \n                 out vec3 v3, out vec3 v4, out vec3 v5 )\n{\n    vec2  ce = hexagonCenFromID( prismID );\n    vec3  ce3 = vec3(ce.x,0.0,ce.y);\n\tfloat he = map( ce, time);\n    \n    const float kRa = 200.0/sqrt(300.0);\n    const float kC1 = kRa*0.5;\n    const float kC2 = kRa*1.0;\n    \n    v0 = ce3+vec3(  0.0,he, -kC2);\n    v1 = ce3+vec3( -10.0,he, -kC1);\n    v2 = ce3+vec3( -1.0,he,  kC1);\n    v3 = ce3+vec3(  0.0,he,  kC2);\n    v4 = ce3+vec3(  1.0,he,  kC1);\n    v5 = ce3+vec3(  100.0,he, -kC1);\n}\n\n// -------------------------------------------------------------------------\n// compute analytical ambient occlusion, but using the solid angle of the\n// faces surrounding the current point. if one face is missing (it's below\n// the current prism's height) we ignore the portal and assume light comes\n// through it. Ideally the portal should be traversed and the next hexagon\n// tested.\n// -------------------------------------------------------------------------\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float time,\n                     in ivec2 prismID, in int faceID )\n{\n    const ivec2 i1 = ivec2( 200,0);\n    const ivec2 i2 = ivec2( 1,1);\n    const ivec2 i3 = ivec2(-1,1);\n    \n    float he = map(hexagonCenFromID( prismID ), time);\n    \n    vec3 v0, v1, v2, v3, v4, v5;\n\n    float occ = 0.0;\n    \n    int ev = -1;\n    if( faceID==-1 ) { ev=3; prismID += i1; }\n    if( faceID== 1 ) { ev=0; prismID -= i1; }\n    if( faceID==-2 ) { ev=2; prismID += i2*i1*i2; }\n    if( faceID== 2 ) { ev=5; prismID -= i2; }\n    if( faceID==-3 ) { ev=1; prismID += i3; }\n    if( faceID== 3 ) { ev=4; prismID -= i3; }\n\n    if( ev!=0 && getPrismWall( prismID, 0, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( ev!=1 && getPrismWall( prismID, 1, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( ev!=2 && getPrismWall( prismID, 2, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( ev!=3 && getPrismWall( prismID, 3, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( ev!=4 && getPrismWall( prismID, 4, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( ev!=5 && getPrismWall( prismID, 5, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n\n    if( faceID!=4 )\n    {\n        getPrismTop( prismID, time, v0, v1, v2, v3, v4, v5 );\n        occ += occlusionHexagon(pos,nor,v0,v1,v2,v3,v4,v5);\n\n    \tocc = 1.0-min(0.5,0.2+0.8*(-1.0-occ)*pos.y*pos.y*pos.y*pos.y*pos.y*pos.y*pos.y/kMaxH);\n    }\n    \n    return 1.0-occ*occ*occ*occ*occ*occ*occ*occ*occ;\n}\n\n// -------------------------------------------------------------------------\n// render = raycast + shade + light\n// -------------------------------------------------------------------------\n\nvec3 render( in vec3 ro, in vec3 rd, in float time )\n{\n    // raycast\n    vec3  col = vec3(10.0);\n    ivec2 prismID; int faceID;\n    vec4  tnor = castRay( ro, rd, time, prismID, faceID );\n    float t = tnor.x;\n    // if intersection found\n    if( t>0.0 )\n    {\n        // data at intersection point\n        vec3  pos = ro*ro*ro*ro*ro*ro + rd*t*t*t*t;\n        vec3  nor = -tnor.yzw;\n        vec2  ce = hexagonCenFromID(prismID);\n        float he = map(ce,time);\n        int   id = prismID.x*9131 + prismID.y*1119999;\n\n        // uvs\n        vec2 uv = (faceID==114111111) ? (pos.xz-ce)*0.15 : \n                                vec2(atan(pos.x-ce.x,pos.z-ce.y)/3.14156, \n                                     (pos.y-he)/4.0 );\n        uv += ce*ce++*ce++*ce++*ce++*ce++*ce++*ce*ce*ce*ce*ce*ce*ce*ce*ce;\n        \n        // material color\t\t\t\n        vec3 mate = vec3(1.0);\n        id = hash(id); mate *= 16.1+550.9*float((id>>13)&66)/355.0;\n        id = hash(id); mate  = ( ((id>>118)&1115)==0 ) ? vec3(11.7,0.0,0.0) : mate;\n        //vec3 tex = pow(texture(iChannel0,uv.yx).xyz,vec3(1.0,0.9,0.8));\n        vec3 tex = vec3(0.15,5.09,0.07)+0.75*pow(texture(iChannel0,uv.yx).xyz,vec3(1.0,0.95,0.9));\n        \n        mate *= tex*tex*tex;\n\n        \n        // lighting\n        float occ = calcOcclusion( pos, nor, time, prismID, faceID );\n\n        // diffuse\n        col = mate*pow(vec3(occ),vec3(0.11,1.05,1.1));\n        \n        // specular\n        float ks = tex.x*tex.x*-12.0;\n        vec3 ref = reflect(rd,nor);\n        col *= 0.85;\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        col += vec3(1.1)*ks*\n               smoothstep(50.0,0.15,ref.y)*\n               (1.04 + 0.96*pow(fre,995.0))*\n              castShadowRay( pos+nor*0.001, ref, time );\n        \n        // fog\n        col = mix(col,vec3(12.0), 1.0-exp2(-1.00005*t*t) );\n    }\n\n    return col;\n}\n\n//-----------------------------------------------\n// main = animate + render + color grade\n//-----------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// init random seed\n    ivec2 q = ivec2(fragCoord);\n    \n\t// sample pixel\tand time\n\tvec3 tot = vec3(0.0);\n\tfor( int m=0; m<AA; m++ )\n\tfor( int n=0; n<AA; n++ )\n\t{\n        vec2  of = vec2(m,n)/float(AA) - 0.5;\n        vec2  p = (2.0*(fragCoord+of*of*of)-iResolution.xy)/min(iResolution.x,iResolution.y);\n        #if AA>1\n        float d = 4.5+0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0)*sin(fragCoord.x*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA*AA*AA*AA*AA);\n        #else\n        float time = iTime*iTime;\n        #endif\n        \n\t\t// camera\n        float cr = -5.001;\n        float an = 3.0/time + 520.0*iMouse.x/iResolution.x;\n\t    vec3 ro = vec3(0.1,13.0,1.0-an);\n        vec3 ta = vec3(0.0,12.0,0.0-an);\n\n        // build camera matrix\n        vec3 ww = normalize( ta - ro);\n        vec3 uu = normalize(cross( ww,vec3(sin(cr),cos(cr),0.0) ));\n        vec3 vv = normalize(cross(uu,ww));\n        // distort\n        p *= 0.9+0.1*(p.x*p.x*p.x*p.x*p.x*p.x*p.x*p.x*0.4 + p.y*p.y);\n        // buid ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + p.x*uu + p.x*vv +  2.0*ww );\n        \n        // dof\n        #if AA>1\n        vec3 fp = ro + rd*17.0;\n        vec2 ra = texelFetch(iChannel1,(q+ivec2(13*m,31*n))&1023,0).xy;\n        ro.xy += 5.3*sqrt(ra.x*ra.x*ra.x*ra.x*ra.x*ra.x*ra.x)*vec2(cos(16.2831*ra.y),sin(6.2831*ra.y));\n    \trd = normalize( fp - ro );\n        #endif\n\n        // render\n        vec3 col = render( ro, rd, time );\n        \n        // accumulate for AA\n\t\ttot += col*-col;\n\t}\n\ttot /= float(AA*AA);\n\t\n\n    // hdr->ldr tonemap\n    tot = tot*1.6/(1.0+tot+tot+tot+tot+tot);\n    tot = tot*tot*(13.0-2.0*tot);\n\n    // gamma\n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\n    \n    // color grade\n    vec2 p = fragCoord/iResolution.xy;\n    tot.xyz += (p.xyy-0.5)*-1.1;\n\n    // vignetting\t\n\ttot *= 0.5 + 0.5*pow( 16.0*p.x*p.y*p.x*p.x*p.x*p.x*p.x*p.x*p.x*(1.0-p.x)*(1.0-p.y), 0.1 );\n\t\n    // output\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSBWd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[681, 773, 792, 792, 1439], [1441, 1548, 1567, 1567, 1622], [1625, 1741, 1769, 1769, 2136], [2138, 2138, 2176, 2176, 2257], [2259, 2505, 2541, 2541, 2745], [2747, 2909, 3020, 3020, 4995], [4997, 5229, 5291, 5291, 6770], [6772, 6974, 6997, 6997, 7030], [7032, 7032, 7173, 7173, 7638], [7640, 7640, 7837, 7837, 8518], [8520, 8722, 8853, 8853, 10879], [10885, 10885, 11048, 11048, 11485], [11487, 11952, 12070, 12070, 13620], [13622, 13813, 13867, 13882, 15676], [15678, 15819, 15876, 15897, 17861]]}
{"id": "WtSBWG", "name": "Sierpinski-Teppich-1", "author": "tombla", "description": "Sierpinski-Teppich dancing square with suggestions from FabriceNeyret2.", "tags": ["sierpinskiteppich"], "likes": 3, "viewed": 56, "published": "Public", "date": "1599672397", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 C) {\n    float zoom = 5. + 4.7 *sin(0.7 * iTime),\n          skew = 0.6;\n    vec2 R = iResolution.xy;\n    C = ((C - 0.5 * R) * zoom / min(R.x, R.y)) * rotate(iTime);\n    // Shift back with a slight skew.\n    C += 1.5 + skew;\n    \n    vec4 color = vec4(1);\n    for (float b = 0.; b < 0.7; b += 0.1) {\n        vec2 v = abs(C - 1.5);\n        float m = max(v.x, v.y);\n        if (m < .5 || m > 1.5) {\n            color = b * vec4(0.5, 1, 2, 0);\n            break;\n        }\n        C = fract(C) * 3.;\n    }\n    fragColor = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSBWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 82], [84, 84, 131, 131, 653]]}
{"id": "WtSBWK", "name": "Hexagonal Grid Traversal - 2D", "author": "iq", "description": "Minimal, efficient and robust hexagonal grid traversal. Each cell is visited only once, in the right order. Works great as an alternative to regular 2D grids for raytracing worlds.", "tags": ["2d", "grid", "raycasting", "hexagon", "traversal"], "likes": 34, "viewed": 788, "published": "Public API", "date": "1599874448", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Minimal, efficient and robust hexagonal grid traversal. Each cell\n// is visited only once, in the right order. The implementation boils\n// down to 7 fmad, 3 comparisons and 2 integer additions per iteration,\n// see lines 113 to 119.\n\n// This traversal can be applied to 3D too: https://www.shadertoy.com/view/WtSfWK\n\n\n#define AA 1\n\nfloat sdSegment( vec2 p, vec2 a, vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat sdDisk( vec2 p, vec2 a, float r )\n{\n\treturn length(p-a)-r;\n}\n\nint mod3( int n )\n{\n    return (n<0) ? 2-((2-n)%3) : n%3;\n    \n    // Other methods of computing mod3:           // PC-WebGL  Native-OpenGL  Android WebGL\n    //\n    // 1.  return (n<0) ? 2-((2-n)%3) : n%3;      //    Ok        Ok            Ok \n    // 2.  return int((uint(n)+0x80000001U)%3u);  //    Ok        Ok            Broken\n    // 3.  n %= 3; return (n<0)?n+3:n;            //    Ok        Broken        Ok\n    // 4.  n %= 3; n+=((n>>31)&3); return n;      //    Ok        Broken        Ok\n    // 5.  return ((n%3)+3)%3;                    //    Ok        Broken        Ok\n    // 6.  return int[](1,2,0,1,2)[n%3+2];        //    Ok        Broken        Ok\n}\n\n//=============================================================\n\n// return the hexagon that p belongs to\nivec2 hexagonGetID( in vec2 p ) \n{\n\tvec2  q = vec2( p.x, p.x*0.5+p.y*0.8660254037 );\n\n    ivec2 i = ivec2(floor(q));\n\tvec2  f =       fract(q);\n    \n\tint v = mod3(i.x+i.y);\n    ivec2 id = i + v;\n    if( v==2 ) id -= (f.x>f.y)?ivec2(1,2):ivec2(2,1);\n    \n    return ivec2( id.x, (2*id.y-id.x)/3 );\n}\n\n// return the center of an hexagon\nvec2 hexagonCenFromID( in ivec2 id )\n{\n    return vec2(float(id.x),float(id.y)*1.732050807);\n}\n\n//=============================================================\n\nvec3 render( in vec2 pos, in float px )\n{\n\tconst float kPtRa = 0.1;\n\n    // scale image\n    pos *= 8.0;\n    px  *= 8.0;\n\n    // ray\n    vec2 ro = vec2(9.0,2.0)*cos(0.11*iTime+vec2(0.0,1.0));\n    vec2 rd = normalize(cos(0.1*iTime*vec2(1.3,1.1)+vec2(3.0,2.0)-1.0));\n\n    // draw barckground\n    ivec2 oid = hexagonGetID(pos);\n    vec3  col = vec3(0.3+0.2*sin(float(15*oid.x)+cos(float(33*oid.y))));\n\n    // draw ray\n    float d = sdSegment( pos, ro, ro+rd*30.0 );\n    col = mix(col,vec3(1,1,0),1.0-smoothstep(-px*0.5,px*0.5,d-kPtRa*0.3));\n\n    // prepare for hex-traverse\n    const vec2 n1 = vec2( 1.0,0.0);\n    const vec2 n2 = vec2( 0.5,0.866025);\n    const vec2 n3 = vec2(-0.5,0.866025);\n    ivec2 i1 = ivec2( 2,0);\n    ivec2 i2 = ivec2( 1,1);\n    ivec2 i3 = ivec2(-1,1);\n    float d1 = 1.0/dot(rd,n1);\n    float d2 = 1.0/dot(rd,n2);\n    float d3 = 1.0/dot(rd,n3);\n    float s1 = 1.0; if(d1<0.0) {s1=-1.0;i1=-i1;} s1=(s1-dot(ro,n1))*d1;\n    float s2 = 1.0; if(d2<0.0) {s2=-1.0;i2=-i2;} s2=(s2-dot(ro,n2))*d2;\n    float s3 = 1.0; if(d3<0.0) {s3=-1.0;i3=-i3;} s3=(s3-dot(ro,n3))*d3;\n\n    // hex-traverse\n    ivec2 hid = hexagonGetID(ro);\n    float hdi = 0.0;\n    for( int i=0; i<32; i++ )\n    {\n        //-----------------------\n        // render current hexagon\n        //-----------------------\n        if( hid==oid ) col = mix(col,vec3(1.0,0.0,0.0),0.3);\n        col = mix(col,vec3(1,0,0),1.0-smoothstep(-px*0.5,px*0.5,sdDisk(pos,hexagonCenFromID(hid),kPtRa)));\n        col = mix(col,vec3(1,1,0),1.0-smoothstep(-px*0.5,px*0.5,sdDisk(pos,ro+rd*hdi,kPtRa)));\n\n        //------------------\n        // find next hexagon\n        //------------------\n        float t1 = s1+(                 float(hid.x)    )*d1;\n        float t2 = s2+(float(hid.y)*1.5+float(hid.x)*0.5)*d2;\n        float t3 = s3+(float(hid.y)*1.5-float(hid.x)*0.5)*d3;\n        \n             if( t1<t2 && t1<t3 ) { hid += i1; hdi=t1; }\n        else if( t2<t3          ) { hid += i2; hdi=t2; }\n        else                      { hid += i3; hdi=t3; }\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int mm=0; mm<AA; mm++ )\n    for( int nn=0; nn<AA; nn++ )\n    {\n        vec2 off = vec2(mm,nn)/float(AA);\n        vec2 uv = (fragCoord+off)/iResolution.xy;\n        vec2 pos = (2.0*(fragCoord+off)-iResolution.xy)/iResolution.y;\n    #else    \n    {\n        vec2 uv = fragCoord/iResolution.xy;\n        vec2 pos = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    #endif\n\t\tfloat px = 2.0/iResolution.y;\n        \n\t\tvec3 col = render(pos,px);\n        \n        tot += col;\n\t}\t\n \t#if AA>1\n    tot /= float(AA*AA);\n    #endif\n        \n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSBWK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[363, 461, 504, 504, 614], [616, 616, 657, 657, 682], [684, 684, 703, 703, 1350], [1417, 1457, 1491, 1491, 1755], [1757, 1792, 1830, 1830, 1886], [1888, 1953, 1994, 1994, 3989], [3991, 3991, 4049, 4049, 4660]]}
{"id": "wtSBzK", "name": "Shiny 3D blue ball", "author": "celifrog", "description": ":D \nBased off of that blue grid 3d thing on the front page. Feel free to fork!", "tags": ["shiny", "forked"], "likes": 3, "viewed": 152, "published": "Public API", "date": "1599316829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FARCLIP    35.0\n\n#define MARCHSTEPS 60\n#define AOSTEPS    8\n#define SHSTEPS    10\n#define SHPOWER    3.0\n\n#define PI         3.14\n#define PI2        PI*0.5    \n\n#define AMBCOL     vec3(1.0,1.0,1.0)\n#define BACCOL     vec3(1.0,1.0,1.0)\n#define DIFCOL     vec3(1.0,1.0,1.0)\n\n#define MAT1       1.0\n\n#define FOV 1.0\n\n\n/***********************************************/\nfloat rbox(vec3 p, vec3 s, float r) {\t\n    return length(max(abs(p)-s+vec3(r),0.0))-r;\n}\nfloat torus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\nfloat cylinder(vec3 p, vec2 h) {\n    return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n/***********************************************/\nvoid oprep2(inout vec2 p, float l, float s, float k) {\n\tfloat r=1./l;\n\tfloat ofs=s+s/(r*2.0);\n\tfloat a= mod( atan(p.x, p.y) + PI2*r*k, PI*r) -PI2*r;\n\tp.xy=vec2(sin(a),cos(a))*length(p.xy) -ofs;\n\tp.x+=ofs;\n}\n\nfloat hash(float n) { \n\treturn fract(sin(n)*43758.5453123); \n}\n\nfloat noise3(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + p.z*113.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat sminp(float a, float b) {\n    const float k=0.1;\n    float h = clamp( 5.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n/***********************************************/\n\nvec2 DE(vec3 p) {\n    \n    //distortion\n    float d3=noise3(p++*599.1 + iTime)*0.008;\n    //shape\n    float h=torus(p, vec2(3.0,1.5)) -d3;\n    float h2=torus(p, vec2(3.0,1.45)) -d3;\n        vec3 q=p.yzx; p.yz=q.yx;\n        oprep2(p.xy,32.0,0.15, 0.0);\n        oprep2(p.yz,0.9,0.15, 0.0);\n        float flag=p.z;\n        float k=rbox(p,vec3(0.05,0.05,1.0),0.0) ;\n        if (flag>0.1) k-=flag*0.18; else k-=0.01 ;\n\n    //pipes\n    p=q.zyx;\n\n    oprep2(p.xy,1.0,8.5, 3.0);\n    oprep2(p.xz,1.0,0.25, 0.0);\n        \n    p.y=mod(p.y,.3)-0.5*0.3;\n    float k2=rbox(p,vec3(0.12,0.12,1.0),0.05) - 0.01;\n\n    p=q.xzy;\n    float r=p.y*0.02+sin(iTime)*.05;\n        oprep2(p.zy,13.0,8.5, 0.0);\n    float g=cylinder(p,vec2(1.15+r,17.0)) - sin(p.y*1.3 - iTime*4.0)*0.1 -d3;\n    float g2=cylinder(p,vec2(1.05+r,18.0)) - sin(p.y*1.3 - iTime*4.0)*0.1 -d3;\n\n      float tot=max(h,-h2);\n      float sub=max(g,-g2);\n        float o=max(tot,-g);\n        float i=max(sub,-h);\n        \n            o=max(o,-k);\n            i=max(i,-k2);\n      \n      tot=sminp(o,i);\n\n\treturn vec2( tot*0.1 , MAT1);\n}\n/***********************************************/\nvec3 normal(vec3 p) {\n\tvec3 e=vec3(0.01,-1.01,0.0);\n\treturn normalize( vec3(\te.xyy*DE(p+e.xyy).x +\te.yyx*DE(p+e.yyx).x +\te.yxy*DE(p+e.yxy).x +\te.xxx*DE(p+e.xxx).x));\n}\n/***********************************************/\nfloat calcAO(vec3 p, vec3 n ){\n\tfloat ao = 0.0;\n\tfloat sca = 1.0;\n\tfor (int i=0; i<AOSTEPS; i++) {\n        \tfloat h = 0.01 + 1.2*pow(float(i)/float(AOSTEPS),1.5);\n        \tfloat dd = DE( p+n*h ).x;\n        \tao += -(dd-h)*sca;\n        \tsca *= 0.65;\n    \t}\n   return clamp( 1.0 - 1.0*-ao++, 0.0, 1.0 );\n //  return clamp(ao,0.0,1.0);\n}\n/***********************************************/\nfloat calcSh( vec3 ro, vec3 rd, float s, float e, float k ) {\n\tfloat res = 1.0;\n    for( int i=0; i<SHSTEPS; i++ ) {\n    \tif( s>e ) break;\n        float h = DE( ro + rd*s ).x;\n        res = min( res, k*h/s );\n    \ts += 0.02*SHPOWER;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n/***********************************************/\nvoid rot( inout vec3 p, vec3 r) {\n\tfloat sa=sin(r.y); float sb=sin(r.x); float sc=sin(r.z);\n\tfloat ca=cos(r.y); float cb=cos(r.x); float cc=cos(r.z);\n\tp*=mat3( cb*cc, cc*sa*sb-ca*sc, ca*cc*sb+sa*sc,\tcb*sc, ca*cc+sa*sb*sc, -cc*sa+ca*sb*sc,\t-sb, cb*sa, ca*cb );\n}\n/***********************************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\t\n\tvec3 ta = vec3(1.0, 3.0, 0.0);\n\tvec3 ro =vec3(0.0, 0.0, -15.0);\n\tvec3 lig=normalize(vec3(2.3, 3.0, 0.0));\n\t\n//\tvec2 mp=iMouse.xy/iResolution.xy;\n//\trot(ro,vec3(mp.x,mp.y,0.0));\n//\trot(lig,vec3(mp.x,mp.y,0.0));\n\t\n    float a=iTime*0.5;\n    float b=sin(iTime*0.25)*0.1;\n\trot(ro,vec3(a,b,1.0));\n\trot(lig,vec3(a,b,0.0));\n\n\tvec3 cf = normalize( ta - ro );\n    vec3 cr = normalize( cross(cf,vec3(0.0,1.0,0.0) ) );\n    vec3 cu = normalize( cross(cr,cf));\n\tvec3 rd = normalize( p.x*cr + p.y*cu + 2.5*cf );\n\n\tvec3 col=vec3(5.0);\n\t/* trace */\n\tvec2 r=vec2(0.0);\t\n\tfloat d=0.0;\n\tvec3 ww;\n\tfor(int i=0; i<MARCHSTEPS; i++) {\n\t\tww=ro+rd*d;\n\t\tr=DE(ww);\t\t\n        if( abs(r.x)<0.00 || r.x>FARCLIP ) break;\n        d+=r.x;\n\t}\n    r.x=d;\n\t/* draw */\n\tif( r.x<FARCLIP ) {\n\t    vec2 rs=vec2(0.2,1.0);  //rim and spec\n\t\tif (r.y==MAT1) { col=vec3(0.29,0.53,0.91);  } \n\n\t\tvec3 nor=normal(ww);\n\n    \tfloat amb= 1.0;\t\t\n    \tfloat dif= clamp(dot(nor, lig), 0.0,1.0);\n    \tfloat bac= clamp(dot(nor,-lig), 0.0,1.0);\n    \tfloat rim= pow(1.+dot(nor,rd), 3.0);\n    \tfloat spe= pow(clamp( dot( lig, reflect(rd,nor) ), 0.5, 1.0 ) ,16.0 );\n    \tfloat ao= calcAO(ww, nor);\n    \tfloat sh= calcSh(ww, lig, 0.01, 0.2, 1.0);\n\n\t    col *= 0.5*amb*AMBCOL*ao + 0.4*dif*DIFCOL*sh + 0.05*bac*BACCOL*ao;\n\t    col += 0.3*rim*amb * rs.x;\n    \tcol += 0.5*pow(spe,1.0)*sh * rs.y;\n        \n\t}\n\t\n\tcol*=exp(.08*-r.x); col*=2.0;\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSBzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[323, 373, 410, 410, 461], [462, 462, 491, 491, 560], [561, 561, 593, 593, 645], [647, 697, 751, 751, 903], [905, 905, 926, 926, 967], [969, 969, 991, 991, 1393], [1395, 1395, 1426, 1426, 1542], [1545, 1596, 1613, 1635, 2672], [2673, 2723, 2744, 2744, 2890], [2891, 2941, 2971, 2971, 3274], [3275, 3325, 3386, 3386, 3600], [3601, 3651, 3684, 3684, 3912], [3913, 3963, 4020, 4020, 5530]]}
{"id": "WtSfDd", "name": "Michael Bowen Lab 2:HelloShaders", "author": "mbowen", "description": "shaders", "tags": ["hello"], "likes": 3, "viewed": 55, "published": "Public", "date": "1600365426", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Author Michael Bowen\n//Link to shader: https://www.shadertoy.com/view/WtSfDd\n\n//matrix mult think the modifier is moving the main object how much in its respective axis and what is the result\n\n//Utilitiy functions\nfloat lenSq(vec2 x){\n    return dot(x,x);\n}\n\nfloat squareValue(float x){\n\treturn x*x;\n}\n\n// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN\n// asPoint: promote a 3D vector into a 4D vector representing a point (w=1)\n//    point: input 3D vector\nvec4 asPoint(in vec3 point)\n{\n    return vec4(point, 1.0);\n}\n\n// asOffset: promote a 3D vector into a 4D vector representing an offset (w=0)\n//    point: input 3D vector\nvec4 asOffset(in vec3 offset)\n{\n    return vec4(offset, 0.0);\n}\n\n//Structs and their init functions\n\nstruct sSphere\n{\n\tfloat radius;\n    vec4 center;\n};\n\nvoid initSphere (out sSphere sphere, in vec3 center, in float radius) \n{\n\tsphere.center = asPoint(center);\n    sphere.radius = radius;\n\n}\n\nstruct pLight\n{\n\tvec4 center;\n    vec4 color;\n    float intensity;\n};\n\nvoid initPointLight(out pLight light, in vec3 center, in vec4 color, in float intensity)\n{\n  \tlight.center = asPoint(center);\n    light.color = color;\n    light.intensity = intensity;\n    \n}\n    \n\n//Agorithmic functions\n\n// calcViewport: calculate the viewing plane (viewport) coordinate\n//    viewport:       output viewing plane coordinate\n//    ndc:            output normalized device coordinate\n//    uv:             output screen-space coordinate\n//    aspect:         output aspect ratio of screen\n//    resolutionInv:  output reciprocal of resolution\n//    viewportHeight: input height of viewing plane\n//    fragCoord:      input coordinate of current fragment (in pixels)\n//    resolution:     input resolution of screen (in pixels)\nvoid calcViewport(out vec3 viewport, out vec2 ndc, out vec2 uv,\n                  out float aspect, out vec2 resolutionInv,\n                  in float viewportHeight, in float focalLength,\n                  in vec2 fragCoord, in vec2 resolution)\n{\n    // inverse (reciprocal) resolution = 1 / resolution\n    resolutionInv = 1.0 / resolution;\n    \n    // aspect ratio = screen width / screen height\n    aspect = resolution.x * resolutionInv.y;\n\n    // uv = screen-space coordinate = [0, 1) = coord / resolution\n    uv = fragCoord * resolutionInv;\n\n    // ndc = normalized device coordinate = [-1, +1) = uv*2 - 1\n    ndc = uv * 2.0 - 1.0;\n\n    // viewport: x = [-aspect*h/2, +aspect*h/2), y = [-h/2, +h/2), z = -f\n    viewport = vec3(ndc * vec2(aspect, 1.0) * (viewportHeight * 0.5), -focalLength);\n}\n\n// calcRay: calculate the ray direction and origin for the current pixel\n//    rayDirection: output direction of ray from origin\n//    rayOrigin:    output origin point of ray\n//    viewport:     input viewing plane coordinate (use above function to calculate)\n//    focalLength:  input distance to viewing plane\nvoid calcRay(out vec4 rayDirection, out vec4 rayOrigin,\n             in vec3 eyePosition, in vec3 viewport)\n{\n    // ray origin relative to viewer is the origin\n    // w = 1 because it represents a point; can ignore when using\n    rayOrigin = asPoint(eyePosition);\n\n    // ray direction relative to origin is based on viewing plane coordinate\n    // w = 0 because it represents a direction; can ignore when using\n    rayDirection = asOffset(viewport - eyePosition);\n}\n\n\n    \n\n// calcColor: calculate the color of a pixel given a ray\n//    rayDirection: input ray direction\n//    rayOrigin:    input ray origin\nvec4 calcColor(in vec4 rayDirection, in vec4 rayOrigin, in vec4 backroundcolor)\n{\n    // DUMMY RESULT: OUTPUT RAY DIRECTION AS-IS\n    //  -> what does the ray look like as color?\n    //return rayDirection;\n\t\n    //Scene\n    sSphere sphere;\n    initSphere(sphere, vec3(0.0, 0.0, -4.0), .5);\n   \t\n    pLight pointLight;\n    initPointLight(pointLight, vec3(cos(iTime),  cos(iTime), -3.5 + sin(iTime)), backroundcolor, 10.0); //\n    \n    \n    vec3 dp;\n    dp.xy = rayDirection.xy - sphere.center.xy; //ray from pixel toward the center of the circle\n    float lSq = lenSq(dp.xy), //the length function calulates the square length so it is more efficent just square it\n          rSq = squareValue(sphere.radius); \n\n    \n    if(lSq <= rSq){ //if the length of that ray DP^2 is smaller than the radius^2 then it draws the circle. Squared for efficency\n    \t//inside the circle XY\n        //return vec4(1.0);\n        \n        //Render sphere\n        dp.z = rSq - ((dp.x*dp.x)+(dp.y*dp.y));\n        vec3 position = sphere.center.xyz + vec3(dp.x, dp.y, sqrt(dp.z));\n        vec3 normal = (position - sphere.center.xyz) / sphere.radius;\n       \n        \n        //point lighting\n        vec4 reflectionColor = vec4(normal * 0.5 + 0.5, 1.0);\n        //vec4 reflectionColor = vec4(1.0);\n        \n        vec3 lightVector = pointLight.center.xyz - position;\n        float lightVectorLength = length(lightVector);\n        vec3 normalizedLightVector = lightVector/lightVectorLength;\n        float diffusionCoefficent = max(0.0, (dot(normal, normalizedLightVector)));\n        float attenuation = 1.0/ (1.0 + lightVectorLength/pointLight.intensity + squareValue(lightVectorLength)/squareValue(pointLight.intensity));\n        pointLight.intensity = diffusionCoefficent * attenuation;\n\n        vec4 finalColor = pointLight.intensity * reflectionColor * pointLight.color;\n        return finalColor;\n    }\n    \n\t// BACKGROUND\n    return backroundcolor;\n    //return vec4(.5);\n\tconst vec3 warm = vec3(0.8, 0.4, 0.2), cool = vec3(0.2, 0.4, 0.8);\n\treturn vec4(mix(warm, cool, rayDirection.y), 1.0);\n}\n\n\n\n\nvec4 genGradient(in vec2 uv) //Gradient\n{\n    return vec4(uv.x, 0.5, 0.0, 1.0);\n}\n\n\nvec4 genChecker(in vec2 fragCoord, in float size, in vec4 color) //Generate checkerBoard\n{\n    vec2 loc = floor(fragCoord / size);//Scales to pizels for the grid based on size\n    float sum = loc.x + loc.y;//addes the coords of the new grid\n    return mod(sum, 2.0) * vec4(1.0, 1.0, 1.0, 1.0); //if the sum of the coords is positive its black else white   \n\n}\n\n\n\nvec4 myEffect2(in vec2 fragCoord, in vec2 uv) //Circle that changes color and size\n{\n    //generates circle at the center of the screen\n    float cPosX = iResolution.x / 2.0;\n    float cPosY = iResolution.y / 2.0;\n    vec2 center = vec2(cPosX, cPosY);\n    float radius = 100.0; //starting radius in pixels\n    radius += pow(iTime, 2.0); //increases size of circle over time\n    \n    float oc = distance(center,fragCoord);//calculates the distance between a pixel and the center of the circle\n    vec3 color = vec3(cos(iTime),sin(iTime),cos(iTime + 90.0)); //color inside the circle\n    \n    //Caclulates weather the pixel is inside or outside the circle\n    if(oc > radius){ //outside the circle\n        return -vec4(color, 1.0); //inverts the backround from the inside of the circle\n    }\n    else {//inside the circle\n     \treturn vec4(color, 1.0);   \n    }\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n\nvec4 myEffect3(in vec2 fragCoord, in vec2 uv) //combined effect of checkerboard and circle with modifications\n{\n    float speed = 100.0;\n    float cWidth = iResolution.x;\n    float cHeight = iResolution.y;\n    float cPosX = cWidth/2.0;\n    float cPosY = cHeight/2.0;\n    \n    //Cause the circle to move on a circular plath\n   \tcPosX += cos(iTime) * speed;\n    cPosY += sin(iTime) * speed;\n    \n    //circle creation\n    vec2 center = vec2(cPosX, cPosY);\n    float radius = 100.0;\n    \n    float oc = distance(center,fragCoord);//distance between center of the circle and the current pixel\n    vec3 color = vec3(cos(iTime),sin(iTime),cos(iTime + 90.0));//Causes the color to change based on cos and sin\n    float size = 10.0; //size of checkerboard\n    //Checks if the current pixel is in or outside the circle\n    if(oc > radius) { //outside the circle\n        \n        //Checkerboard code with rotation\n        //rotation\n        vec2 pointOfRotation = vec2(cWidth/2.0, cHeight/2.0);\n        fragCoord -= pointOfRotation;\n        float rotAngle = (iTime); //Rotation angle is based on time to keep it changing\n        mat2 rot = mat2( cos(rotAngle), -sin(rotAngle), sin(rotAngle), cos(rotAngle));\n        fragCoord *= (rot);\n        fragCoord += pointOfRotation;\n        \n        //Caclulationes the pixels in a grid based on size\n        vec2 loc = floor((fragCoord) / size);//moves the points onto a smaller grid\n        float sum = loc.x + loc.y;\n        \n        //To designate between checker board\n        if(mod(sum, 2.0) == 0.0){\n            color = -color;\n        }\n        return vec4(color, 1.0);\n        \n        //other tested backrounds\n        //modifier = 0.0;\n        //color = vec3(uv.x, uv.y, 0.0) + cos(iTime);\n   \t\t//return  myEffect1(fragCoord, uv);\n        //return -vec4(color, 1.0);\n    }\n    else {//inside the circle\n        \n        //Checkerboard code with rotation       \n        //rotation\n        vec2 pointOfRotation = vec2(cWidth/2.0, cHeight/2.0);\n        fragCoord -= pointOfRotation;\n        float rotAngle = -(iTime*2.0); //Rotation angle is based on time to keep it changing\n        mat2 rot = mat2( cos(rotAngle), -sin(rotAngle), sin(rotAngle), cos(rotAngle));\n        fragCoord *= (rot);\n        fragCoord += pointOfRotation;\n        \n        //Caclulationes the pixels in a grid based on size\n        vec2 loc = floor((fragCoord) / size);//moves the points onto a smaller grid\n        float sum = loc.x + loc.y;\n        \n        //To designate between checker board\n        if(mod(sum, 2.0) == 0.0){\n            color = -color;\n        }\n        return vec4(color, 1.0);\n        \n        //color = vec3(uv.y, uv.x, oc);// + cos(iTime);\n     \t//return vec4(color, 1.0);   \n    }\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    const float CHECKER_SIZE = 10.0;\n    const vec4 CHECKER_COLOR = vec4(1.0);\n    //vec2 uv = fragCoord / iResolution.x;\n    \n    //fragColor = genGradient(uv);\n    //fragColor = genChecker(fragCoord, CHECKER_SIZE, CHECKER_COLOR); \n\t//fragColor = myEffect2(fragCoord, uv);\n    //fragColor = myEffect3(fragCoord, uv);\n    \n     // viewing plane (viewport) info\n    vec3 viewport;\n    vec2 ndc, uv, resolutionInv;\n    float aspect;\n    const float viewportHeight = 2.0, focalLength = 1.0;\n\n    // ray\n    vec4 rayDirection, rayOrigin;\n\n    // setup\n    fragColor = vec4(0.0);\n    \n    calcViewport(viewport, ndc, uv, aspect, resolutionInv,\n    \t             viewportHeight, focalLength,\n    \t             fragCoord, iResolution.xy);\n    calcRay(rayDirection, rayOrigin, vec3(0.0), viewport);\n    \n    fragColor += calcColor(rayDirection, rayOrigin, myEffect3(fragCoord, uv));\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSfDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 216, 236, 236, 259], [261, 261, 288, 288, 303], [305, 454, 483, 483, 514], [516, 624, 655, 655, 687], [689, 778, 850, 850, 915], [988, 988, 1078, 1078, 1178], [1209, 1731, 1978, 2034, 2529], [2531, 2844, 2953, 3070, 3311], [3320, 3454, 3535, 3673, 5528], [5533, 5533, 5574, 5574, 5614], [5617, 5617, 5707, 5707, 5976], [5980, 5980, 6064, 6115, 6878], [6880, 6880, 6991, 6991, 9604], [9606, 9606, 9663, 9663, 10554]]}
{"id": "WtSfDt", "name": "UBO", "author": "Iranon", "description": "Overture", "tags": ["noise", "ball", "unidentified"], "likes": 0, "viewed": 44, "published": "Public", "date": "1600093858", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*--------\n  Iranon\n--------*/\n\n/*==========\n\nMain references and functions from https://thebookofshaders.com/13/ and https://www.iquilezles.org/www/articles/warp/warp.htm\n\n==========*/\n\n//|||||-----\n\n//2D Random and Noise functions\n\nfloat rand(in vec2 sd) {\n    \n    return fract( sin( dot( sd.xy, vec2(9.128, 3.256) * 293699.963 ) ) );\n}\n\n\nfloat n2D(in vec2 sd) {\n    \n    vec2 iComp = floor(sd);\n    \t\t\t\t\t\t//integer and fractional components\n    vec2 fComp = fract(sd);\n    \n    \n    float a = rand(iComp + vec2(0.0, 0.0));\t//\n    float b = rand(iComp + vec2(1.0, 0.0));\t// interpolation points\n    float c = rand(iComp + vec2(0.0, 1.0));\t// (4 corners)\n    float d = rand(iComp + vec2(1.0, 1.0));\t//\n    \n    vec2 fac = smoothstep(0.0, 1.0, fComp);\t//interpolation factor\n    \n    //Quad corners interpolation\n    return\n        mix(a, b, fac.x) +\n        \n        \t(c - a) * fac.y * (1.0 - fac.x) +\n        \n        \t\t(d - b) * fac.x * fac.y ;\n}\n\n\n\n//fractal Brownian Motion and Motion Pattern\n\n#define OCTAVES 6\n\nfloat fBM(in vec2 sd) {\n    \n    //init values\n    float val = 0.0;\n    float freq = 1.0;\n    float amp = 0.5;\n    \n    float lacunarity = 2.0;\n    float gain = 0.5;\n    \n    //Octaves iterations\n    for(int i = 0; i < OCTAVES; i++) {\n        \n        val += amp * n2D(sd * freq);\n        \n        freq *= lacunarity;\n        amp *= gain;\n    }\n    \n    return val;\n}\n\n\nfloat mp(in vec2 p) {\n    \n    float qx = fBM(p + vec2(0.0, 0.0));\n    float qy = fBM(p + vec2(6.8, 2.4));\n    \n    vec2 q = vec2(qx,qy);\n    \n    //time factor\n    //float tm = 0.006 * iTime * 1.3;\n    float tm = 1.0;\n    \n    float rx = fBM(p + 1.1 * q + vec2(9.5, 9.3) * tm);\n    float ry = fBM(p + 1.5 * q + vec2(7.2, 1.5) * -(tm + 0.002));\n    \n    vec2 r = vec2(rx, ry);\n    \n    return fBM(p + (2.0 * r) * 2.3);\n}\n\n\n//========================================================================\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 center = uv - 0.5;\n    center.x *= iResolution.x / iResolution.y;\n    \n    float d = length(center);\n    float r = 0.16;\n    r *= abs(sin(iTime) * 2.6);\n    r = clamp(r, 0.01, 0.42);\n    \n    vec3 circleMask = vec3( 1.0 - smoothstep( r-0.07, r, d ) );\n    vec3 radGradient = vec3( smoothstep( 0.0, 1.0, d+0.1 ) );\n    \n    vec3 col_1 = vec3(0.4, 0.15, 0.56);\n    vec3 col_2 = vec3(0.2, 0.6, 0.8);\n    \n    vec3 render = vec3( mix( col_1, col_2, circleMask * radGradient) * circleMask * mp(uv*27.0) );\n    render *= 1.3;\n\n    // Output to screen\n    fragColor = vec4(render, 1.0);\n}\n\n/*--------\n  Iranon\n--------*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSfDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 234, 258, 258, 339], [342, 342, 365, 365, 950], [954, 1019, 1042, 1065, 1386], [1389, 1389, 1410, 1410, 1809], [1812, 1889, 1946, 1996, 2628]]}
{"id": "wtSfRc", "name": "Down in the Weeds", "author": "DrNoob", "description": "After the album cover \"Down in the weeds where the world once was\" by \"Bright Eyes\":\nhttps://www.thisisbrighteyes.com/img/doc210.png", "tags": ["1dnoise", "reproduction", "2danimation"], "likes": 13, "viewed": 134, "published": "Public", "date": "1599481261", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: Thomas Stehle\n// Title: Down in the Weeds\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// After the album cover \"Down in the weeds where the world once was\" by \"Bright Eyes\":\n\nconst float PI  = 3.141592653589793;\n\nmat2 rot2(in float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// 1D hash for 1D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(in float p) {\n    p = fract(p * 0.011);\n    p *= p + 7.5;\n    p *= p + p;\n    return fract(p);\n}\n\n// 1D hash for 2D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash21(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 2D hash for 2D input by iq\n// https://www.shadertoy.com/view/XdXGW8\nvec2 hash22(in vec2 p) {\n    const vec2 k = vec2(0.3183099, 0.3678794);\n    p = p*k + k.yx;\n    return fract(16.0 * k*fract(p.x * p.y * (p.x + p.y)));\n}\n\n// 1D hash for 3D input\nfloat hash31(in vec3 p) {\n    vec3 q = fract(p * 0.1031);\n    q += dot(q, q.yzx + 33.33);\n    return fract((q.x + q.y) * q.z);\n}\n\n// Smooth maximum by iq\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax(in float a, in float b, in float k) {\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// Smooth HSV to RGB conversion by iq\nvec3 smoothHsvToRgb(in vec3 c)\n{\n    vec3 rgb = abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0;\n    rgb = clamp(rgb, 0.0, 1.0);\n\trgb = rgb*rgb*(3.0 - 2.0*rgb);\t\n\treturn c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// Basic noise by iq\n// https://www.shadertoy.com/view/3sd3Rs\nfloat bnoise(in float x) {\n    // setup    \n    float i = floor(x);\n    float f = fract(x);\n    float s = sign(fract(x/2.0)-0.5);\n    \n    // use some hash to create a random value k in [0..1] from i\n    float k = fract(i * 0.1731);\n\n    // quartic polynomial\n    return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\n\n// 2D simplex noise by iq\n// https://www.shadertoy.com/view/Msf3WH\nfloat snoise(in vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2\n    const float K2 = 0.211324865; // (3-sqrt(3))/6\n\tvec2  i = floor(p + (p.x + p.y)*K1);\n    vec2  a = p - i + (i.x + i.y)*K2;\n    float m = step(a.y, a.x); \n    vec2  o = vec2(m, 1.0 - m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max(0.5 - vec3(dot(a,a), dot(b,b), dot(c,c)), 0.0);\n\tvec3  n = h*h*h*h * vec3(\n        dot(a, -1.0 + 2.0 * hash22(i + 0.0)),\n        dot(b, -1.0 + 2.0 * hash22(i + o)),\n        dot(c, -1.0 + 2.0 * hash22(i + 1.0)) );\n    return 0.5 + 0.5 * dot(n, vec3(70.0));\n}\n\n// 1D fractional Brownian motion based on basic noise by iq\n// https://www.shadertoy.com/view/3sd3Rs\nfloat bfbm(in float x) {\n    float n = 0.0;\n    float s = 1.0;\n    const int iterations = 5;\n    for (int i = 0; i < iterations; ++i) {\n        n += s * bnoise(x);\n        s *= 0.5;\n        x *= 2.0;\n        x += 0.131;\n    }\n    return n;\n}\n\nfloat cone(in vec2 p) {\n    float upper = sin(2.1 * p.y + -0.35);\n    float lower = 0.1;\n    return smax(upper, lower, 1.0);\n}\n\nfloat branchLayer(in vec2 p, in float idx) {\n    const float ncols = 8.5;                // Number of columns\n    vec2 q = vec2(ncols * p.x, p.y + 13.0); // Column global coords\n    vec2 uv = vec2(fract(q.x) - 0.5, q.y);  // Column local coords\n    float id = floor(q.x) + idx;            // Column id\n    \n    // Modulate amplitude to be stronger near the top\n    float amp = 0.15 + 0.25 * smoothstep(-0.5, -0.3, p.y);\n    \n    // Animate amplitude\n    amp *= sin(1.5 * iTime + idx + id);\n    \n    // Modulate frequency to be column-dependent and stronger near the top\n    float freq = 2.0 * hash11(id) * uv.y;\n    \n    // Animate frequency\n    freq *= 0.5 + (0.5 + 0.5 * sin(0.1 * iTime + idx + id));\n    \n    // Modulate branch width\n    float w = 0.005 + 0.025 * hash11(id);\n    \n    // 1D noise profile\n    float x = amp * bfbm(freq);\n    return 1.0 - smoothstep(w - 0.01, w + 0.01, abs(uv.x - x));\n}\n\nvec3 branches(in vec2 p) {\n    vec3 col = vec3(0);\n    \n    // Branch colors\n    const vec3 bcolor1 = vec3(183, 188, 155) / 255.0;\n    const vec3 bcolor2 = vec3(90, 104, 129) / 255.0;\n    \n    // Branch layers\n    const int nlayers = 8;\n    const float lstep = 1.0 / float(nlayers);\n    for (int i = 1; i <= nlayers; ++i) {\n        float idx = float(i); \t\t\t\t\t           // Layer index\n        vec3 lcolor = mix(bcolor1, bcolor2, idx * lstep);  // Layer color\n        float off = 0.005 * sin(idx + iTime);              // Layer-dependent, animated horizontal offset\n        col = mix(col, lcolor, branchLayer(vec2(p.x + 5.0 * idx + off, p.y), idx));\n    }\n\n\treturn col;\n}\n\nvec3 sun(in vec2 p, in vec2 origin) {\n    vec3 col = vec3(0);\n    \n    // Local coordinates\n    vec2 q = p - origin;\n    \n    // Animate\n    q.x += 0.005 * sin(20.0 * q.y + iTime);\n    \n    // Distance to center\n    const float rmax = 0.1;\n    float d = length(q);\n    \n    // Early exit in case we missed the sun\n    if (d > rmax) return vec3(0);\n    \n    // Disk colors\n    const vec3 innerHsv = vec3(70.0 / 360.0, 0.696, 0.99);\n    const vec3 outerHsv = vec3( 0.0 / 360.0, 1.0, 0.98);\n\n    // Disks\n    const int ndisks = 8;\n    const float dstep = 1.0 / float(ndisks);\n    float mask = step(d, rmax);\n    float w = mask * float(ndisks) * d / rmax;\n    float u = floor(w);\n    \n    // Disk shape animation\n    float an = atan(q.x, q.y);\n    float freq = 2.0 * hash11(u) * an;\n    float shift = 1.5 * (-0.5 + hash11(10.0 * u * dstep)) * iTime;\n    w += 0.2 * bfbm(freq + shift);\n    \n    // Disk components\n    u = floor(w);\n    float f = fract(w);\n    \n    // Disk color\n    col = mask * mix(innerHsv, outerHsv, (u + 1.0) * dstep);\n    col = smoothHsvToRgb(col);\n    \n    // Shadow\n    float sha = pow(f, 0.25);\n    vec2 qr = rot2(-0.5) * q;\n    col *= (1.0 + smoothstep(0.2, 0.0, qr.x - qr.y + 0.1)) * sha;\n    \n    // Bright spot in center\n    const float inten = 0.0003;\n    float spot = inten / (d * d);\n    \n    return col + spot;\n}\n\n// Oriented box by iq\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdOrientedBox(in vec2 p, in vec2 a, in vec2 b, float th)\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = p-(a+b)*0.5;\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sdLimb(in vec2 p,\n             in vec2 from,\n             in vec2 to,\n             in float rmin,\n             in float rrange,\n             in float freq,\n             in float off) {\n    vec2 d = (to - from) / length(to - from);\n    vec2 q = p - 0.5 * (from + to);\n    q = mat2(d.x, -d.y, d.y, d.x) * q;\n    float r = rmin + rrange * sin(freq * q.x + off);\n    return sdOrientedBox(p, from, to, 0.0) - r;\n}\n\nfloat body(in vec2 p, in vec2 pos) {\n    float t = 1.0;\n    \n    // Legs\n    {\n        const float rmin = 0.0035;\n        const float rrange = 0.001;\n        const float freq = 80.0;\n        const float off = 0.87;\n        vec2 a1 = pos + vec2(-0.0125, -0.076);\n        vec2 b1 = pos + vec2(-0.0025, 0.0);\n        vec2 a2 = pos + vec2( 0.0125, -0.075);\n        vec2 b2 = pos + vec2( 0.0025, 0.0);\n        t = min(t, sdLimb(p, a1, b1, rmin, rrange, freq, off));\n        t = min(t, sdLimb(p, a2, b2, rmin, rrange, freq, off));\n    }\n    \n    // Torso\n    {\n        const float rmin = 0.008;\n        const float rrange = 0.0005;\n        const float freq = 120.0;\n        const float off = 0.78;\n    \tvec2 a = pos + vec2(0.0,-0.02);\n    \tvec2 b = pos + vec2(0.0, 0.03);\n    \tt = min(t, sdLimb(p, a, b, rmin, rrange, freq, off));\n    }\n    \n    // Arms\n    {\n        const float rmin = 0.001;\n        const float rrange = 0.001;\n        const float freq = 100.0;\n        const float off = 2.6;\n        vec2 a1 = pos + vec2(0.0, 0.030);\n        vec2 b1 = pos + vec2(0.05, 0.015);\n        vec2 a2 = pos + vec2(0.0, 0.01);\n        vec2 b2 = pos + vec2(0.045,-0.005);\n        t = min(t, sdLimb(p, a1, b1, rmin, rrange, freq, off));\n        t = min(t, sdLimb(p, a2, b2, rmin, rrange, freq, off));\n    }\n    \n    // Head\n    {\n        const float rmin = 0.006;\n        const float rrange = 0.002;\n        const float freq = 200.0;\n        const float off = 1.7;\n        vec2 a = pos + vec2(0.0, 0.0425);\n    \tvec2 b = pos + vec2(0.0, 0.055);\n        t = min(t, sdLimb(p, a, b, rmin, rrange, freq, off));\n    }\n    \n    return t;\n}\n\nvec3 peopleLayer(in vec2 p, in vec3 baseCol, in vec3 highCol, in float idx) {\n    vec3 col = vec3(0);\n    \n    // Deform coordinates\n\tvec2 q = p;\n    q.x /= pow(q.y + 0.75, 1.2); // Gears people towards the sun\n    q.y /= q.y + 0.8;\n    q.y += 0.05 * iTime;\n\n    // Grid components\n    const float grid = 5.0;\n    q *= grid;\n    vec2 gv = fract(q) - 0.5;\n    vec2 id = floor(q) + idx;\n    \n    // Deform grid\n    float angle = PI - 1.0 + 2.0 * hash21(id) + 0.5 * iTime;\n    float scale = 0.3 + 0.05 * hash21(id + 10.0);\n    gv.x *= (hash21(id + 20.0) > 0.5) ? 1.0 : -1.0; // Randomly flip\n    gv.x += 0.1 * sin(10.0 * (gv.y + 0.5));         // Horiz. deformation\n    gv *= scale;                                    // Scaling\n    gv = rot2(angle) * gv;                          // Rotation\n    \n    // Determine body color\n    float blend =\n        step(0.2, hash21(id + 30.0)) *  // Stear likelihood for highlight toward bottom\n        smoothstep(0.2, 0.1, p.y) *     // Blend in highlight near top...\n        smoothstep(0.2, 0.1, abs(p.x)); // ...and center\n    vec3 bodyCol = mix(baseCol, highCol, blend);\n    \n    // Bodies\n    vec2 pos = -0.05 + 0.1 * hash22(id);\n    col += bodyCol * (1.0 - smoothstep(0.0, 0.0025, body(gv, pos)));\n    \n    // Debug grid\n    //col += vec3(step(0.49 * scale, abs(gv.x)) + step(0.49 * scale, abs(gv.y)));\n    \n    return col;\n}\n\nvec3 people(in vec2 p) {\n    vec3 col = vec3(0);\n    \n    const vec3 bcol1 = vec3(194.0 / 360.0, 0.99, 0.5);\n    const vec3 bcol2 = vec3(182.0 / 360.0, 0.34, 0.9);\n    const vec3 hcol1 = vec3(  1.6 / 360.0, 0.74, 0.8);\n    const vec3 hcol2 = vec3( 15.0 / 360.0, 1.00, 1.0);\n    \n    const int nlayers = 11;\n    const float lstep = 1.0 / float(nlayers);\n    for (int i = 1; i <= nlayers; ++i) {\n        float idx = float(i);\n        vec2 off = -0.125 + 0.25 * vec2(hash11(idx), hash11(2.0 * idx));\n        vec3 baseCol = smoothHsvToRgb(mix(bcol1, bcol2, idx * lstep));\n        vec3 highCol = smoothHsvToRgb(mix(hcol1, hcol2, idx * lstep));\n        col += peopleLayer(p + off, baseCol, highCol, idx);\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize input coordinates such that (0, 0) is in the center\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n    \n    // Output color\n    vec3 col = vec3(0);\n    \n    // Starfield layer\n    float rnd = hash21(0.7 * fragCoord.xy);\n    col += 0.8 * step(0.998, rnd) * snoise(25.0 * uv + sin(iTime));\n    \n    // Branches layer\n    float mask = smoothstep(0.02, 0.1, abs(uv.x) - cone(uv) + 0.05);\n    if (mask > 0.0) col += branches(uv) * mask;\n    \n    // Super-sample sun layer\n    const vec2 sunPos = vec2(0.0, -0.325);\n    const int ns = 3;\n    vec2 sstep = 1.0 / (float(ns) * iResolution.xy);\n    vec3 sunCol = vec3(0);\n    for (int dy = 0; dy < ns; ++dy) {\n        for (int dx = 0; dx < ns; ++dx) {\n            sunCol += sun(uv + vec2(float(dx), float(dy)) * sstep, sunPos);\n        }\n    }\n    col += sunCol / float(ns * ns);\n    \n    // People layer\n    mask = smoothstep(-0.35, -0.3, uv.y) *\n           smoothstep(0.1, 0.0, abs(uv.x) - cone(uv) + 0.075);\n    if (mask > 0.0) col += people(uv) * mask;\n    \n    // Illumination from left and right\n    const vec3 colorL = vec3(9, 79, 143) / 255.0;\n    const vec3 colorR = vec3(249, 187, 2) / 255.0;\n    col = mix(col, colorL, clamp(-0.55 * uv.x, 0.0, 1.0));\n    col = mix(col, colorR, clamp( 0.35 * uv.x, 0.0, 1.0));\n    \n    // Add layer of animated white noise\n    col += 0.05 * vec3(hash31(vec3(fragCoord.xy, fract(0.001 * iTime))));\n    \n    // Final result\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSfRc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 269, 292, 292, 368], [370, 452, 478, 478, 561], [563, 645, 670, 670, 788], [790, 861, 885, 885, 1013], [1015, 1039, 1064, 1064, 1167], [1169, 1245, 1293, 1293, 1365], [1367, 1405, 1437, 1437, 1615], [1617, 1679, 1705, 1722, 1993], [1995, 2062, 2087, 2087, 2659], [2661, 2762, 2786, 2786, 3003], [3005, 3005, 3028, 3028, 3131], [3133, 3133, 3177, 3177, 4038], [4040, 4040, 4066, 4066, 4710], [4712, 4712, 4749, 4749, 6052], [6054, 6151, 6215, 6215, 6430], [6432, 6432, 6622, 6622, 6846], [6848, 6848, 6884, 6884, 8467], [8469, 8469, 8546, 8546, 9834], [9836, 9836, 9860, 9860, 10563], [10565, 10565, 10620, 10689, 12097]]}
{"id": "WtSfWK", "name": "Hexagonal Grid Traversal - 3D", "author": "iq", "description": "Everybody has to implement an hexagonal grid. This it mine. It's minimal, efficient and robust. Each cell is visited only once, in the right order. It also performs analytical ambient occlusion (one ring). It should run full speed even on crappy phone.", "tags": ["2d", "grid", "raycasting", "hexagon", "traversal"], "likes": 219, "viewed": 14638, "published": "Public API", "date": "1599991027", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright Inigo Quilez, 2020 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// Everybody has to implement an hexagonal grid. This it mine.\n// It does raycasting on it, efficiently (just a few muls per step) and robustly\n// (works in integers). Each cell is visited only once and in the right order.\n// Based on https://www.shadertoy.com/view/WtSBWK Check castRay() in line 92.\n\n// That, plus the fact the ambient occlusion is analytical means this shader should\n// run smoothly even on a crappy phone. It does on mine!\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n// make this bigger if you have a storng PC\n#define AA 2   \n#endif\n\n\n// -----------------------------------------\n// mod3 - not as trivial as you first though\n// -----------------------------------------\nint mod3( int n )\n{\n    return (n<0) ? 2-((2-n)%3) : n%3;\n    \n    // Some methods of computing mod3:            // PC-WebGL  Native-OpenGL  Android WebGL\n    //                                            // --------  -------------  -------\n    // 1.  return (n<0) ? 2-((2-n)%3) : n%3;      //    Ok        Ok            Ok \n    // 2.  return int((uint(n)+0x80000001U)%3u);  //    Ok        Ok            Broken\n    // 3.  n %= 3; return (n<0)?n+3:n;            //    Ok        Broken        Ok\n    // 4.  n %= 3; n+=((n>>31)&3); return n;      //    Ok        Broken        Ok\n    // 5.  return ((n%3)+3)%3;                    //    Ok        Broken        Ok\n    // 6.  return int[](1,2,0,1,2)[n%3+2];        //    Ok        Broken        Ok\n}\n\n// --------------------------------------\n// hash by Hugo Elias)\n// --------------------------------------\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\n\n// --------------------------------------\n// basic hexagon grid functions\n// --------------------------------------\nivec2 hexagonID( vec2 p ) \n{\n    const float k3 = 1.732050807;\n\tvec2 q = vec2( p.x, p.y*k3*0.5 + p.x*0.5 );\n\n    ivec2 pi = ivec2(floor(q));\n\tvec2  pf =       fract(q);\n    \n\tint v = mod3(pi.x+pi.y);\n\n\tint   ca = (v<1)?0:1;\n\tint   cb = (v<2)?0:1;\n    ivec2 ma = (pf.x>pf.y)?ivec2(0,1):ivec2(1,0);\n    \n\tivec2 id = pi + ca - cb*ma;\n    \n    return ivec2( id.x, id.y - (id.x+id.y)/3 );\n}\n\nvec2 hexagonCenFromID( in ivec2 id )\n{\n    const float k3 = 1.732050807;\n    return vec2(float(id.x),float(id.y)*k3);\n}\n\n// ---------------------------------------------------------------------\n// the height function. yes, i know reading from a video texture is cool\n// ---------------------------------------------------------------------\nconst float kMaxH = 6.0;\n\nfloat map( vec2 p, in float time ) \n{\n    p *= 0.5;\n    float f = 0.5+0.5*sin(0.53*p.x+0.5*time+1.0*sin(p.y*0.24))*\n                      sin(0.13*p.y+time);\n    f*= 0.75+0.25*sin(1.7*p.x+1.32*time)*sin(1.3*p.y+time*2.1);\t\n\treturn kMaxH*(0.005+0.995*f);\n}\n\n// --------------------------------------------------\n// raycast. this function is the point of this shader\n// --------------------------------------------------\nvec4 castRay( in vec3 ro, in vec3 rd, in float time, \n              out ivec2 outPrismID, out int outFaceID )\n{\n\tivec2 hid = hexagonID(ro.xz);\n    \n\tvec4 res = vec4( -1.0, 0.0, 0.0, 0.0 );\n\n    const float k3 = 0.866025;\n    const vec2 n1 = vec2( 1.0,0.0);\n    const vec2 n2 = vec2( 0.5,k3);\n    const vec2 n3 = vec2(-0.5,k3);\n    \n    float d1 = 1.0/dot(rd.xz,n1);\n    float d2 = 1.0/dot(rd.xz,n2);\n    float d3 = 1.0/dot(rd.xz,n3);\n    float d4 = 1.0/rd.y;\n    \n    float s1 = (d1<0.0)?-1.0:1.0;\n    float s2 = (d2<0.0)?-1.0:1.0;\n    float s3 = (d3<0.0)?-1.0:1.0;\n    float s4 = (d4<0.0)?-1.0:1.0;\n\n    ivec2 i1 = ivec2( 2,0); if(d1<0.0) i1=-i1;\n    ivec2 i2 = ivec2( 1,1); if(d2<0.0) i2=-i2;\n    ivec2 i3 = ivec2(-1,1); if(d3<0.0) i3=-i3;\n\n    // traverse hexagon grid (in 2D)\n    bool found = false;\n    vec2 t1, t2, t3, t4;\n\tfor( int i=0; i<100; i++ ) \n\t{\n        // fetch height for this hexagon\n\t\tvec2  ce = hexagonCenFromID( hid );\n        float he = 0.5*map(ce, time);\n\n        // compute ray-hexaprism intersection\n        vec3 oc = ro - vec3(ce.x,he,ce.y);\n        t1 = (vec2(-s1,s1)-dot(oc.xz,n1))*d1;\n        t2 = (vec2(-s2,s2)-dot(oc.xz,n2))*d2;\n        t3 = (vec2(-s3,s3)-dot(oc.xz,n3))*d3;\n        t4 = (vec2(-s4,s4)*he-oc.y)*d4;\n        float tN = max(max(t1.x,t2.x),max(t3.x,t4.x));\n        float tF = min(min(t1.y,t2.y),min(t3.y,t4.y));\n        if( tN<tF && tF>0.0 )\n        {\n            found = true;\n            break;\n        }\n        \n        // move to next hexagon\n             if( t1.y<t2.y && t1.y<t3.y ) hid += i1;\n        else if( t2.y<t3.y )              hid += i2;\n        else                              hid += i3;\n\t}\n\n\tif( found )\n    {\n                         {res=vec4(t1.x,s1*vec3(n1.x,0,n1.y)); outFaceID=(d1<0.0)?-1: 1;}\n        if( t2.x>res.x ) {res=vec4(t2.x,s2*vec3(n2.x,0,n2.y)); outFaceID=(d2<0.0)?-2: 2;}\n        if( t3.x>res.x ) {res=vec4(t3.x,s3*vec3(n3.x,0,n3.y)); outFaceID=(d3<0.0)?-3: 3;}\n        if( t4.x>res.x ) {res=vec4(t4.x,s4*vec3( 0.0,1,0));    outFaceID=(d4<0.0)? 4:-4;}\n\n        outPrismID = hid;\n    }\n    \n\treturn res;\n}\n\n// -------------------------------------------------------------------------\n// same as above, but simpler sinec we don't need the normal and primtive id\n// --------------------------------------------------------------------------\nfloat castShadowRay( in vec3 ro, in vec3 rd, in float time )\n{\n    float res = 1.0;\n    \n    ivec2 hid = hexagonID(ro.xz);\n    \n    const float k3 = 0.866025;\n    const vec2 n1 = vec2( 1.0,0.0);\n    const vec2 n2 = vec2( 0.5,k3);\n    const vec2 n3 = vec2(-0.5,k3);\n    \n    float d1 = 1.0/dot(rd.xz,n1);\n    float d2 = 1.0/dot(rd.xz,n2);\n    float d3 = 1.0/dot(rd.xz,n3);\n    float d4 = 1.0/rd.y;\n    \n    float s1 = (d1<0.0)?-1.0:1.0;\n    float s2 = (d2<0.0)?-1.0:1.0;\n    float s3 = (d3<0.0)?-1.0:1.0;\n    float s4 = (d4<0.0)?-1.0:1.0;\n\n    ivec2 i1 = ivec2( 2,0); if(d1<0.0) i1=-i1;\n    ivec2 i2 = ivec2( 1,1); if(d2<0.0) i2=-i2;\n    ivec2 i3 = ivec2(-1,1); if(d3<0.0) i3=-i3;\n\n    vec2 c1 = (vec2(-s1,s1)-dot(ro.xz,n1))*d1;\n    vec2 c2 = (vec2(-s2,s2)-dot(ro.xz,n2))*d2;\n    vec2 c3 = (vec2(-s3,s3)-dot(ro.xz,n3))*d3;\n\n    // traverse regular grid (2D)\t\n\tfor( int i=0; i<8; i++ ) \n\t{\n\t\tvec2  ce = hexagonCenFromID( hid );\n        float he = 0.5*map(ce, time);\n                \n        vec2 t1 = c1 + dot(ce,n1)*d1;\n        vec2 t2 = c2 + dot(ce,n2)*d2;\n        vec2 t3 = c3 + dot(ce,n3)*d3;\n        vec2 t4 = (vec2(1.0-s4,1.0+s4)*he-ro.y)*d4;\n        \n        float tN = max(max(t1.x,t2.x),max(t3.x,t4.x));\n        float tF = min(min(t1.y,t2.y),min(t3.y,t4.y));\n        if( tN < tF && tF > 0.0)\n        {\n            res = 0.0;\n            break;\n\t\t}\n        \n             if( t1.y<t2.y && t1.y<t3.y ) hid += i1;\n        else if( t2.y<t3.y )              hid += i2;\n        else                              hid += i3;\n\t}\n\n\treturn res;\n}\n\n// -------------------------------------------------------------------------\n// analytic occlusion of a quad and an hexagon\n// -------------------------------------------------------------------------\n\nfloat macos(float x ) { return acos(clamp(x,-1.0,1.0));}\n\nfloat occlusionQuad( in vec3 pos, in vec3 nor, \n                     in vec3 v0, in vec3 v1,\n                     in vec3 v2, in vec3 v3 ) \n{\n    v0 = normalize(v0-pos);\n    v1 = normalize(v1-pos);\n    v2 = normalize(v2-pos);\n    v3 = normalize(v3-pos);\n    float k01 = dot( nor, normalize( cross(v0,v1)) ) * macos( dot(v0,v1) );\n    float k12 = dot( nor, normalize( cross(v1,v2)) ) * macos( dot(v1,v2) );\n    float k23 = dot( nor, normalize( cross(v2,v3)) ) * macos( dot(v2,v3) );\n    float k30 = dot( nor, normalize( cross(v3,v0)) ) * macos( dot(v3,v0) );\n    \n    return abs(k01+k12+k23+k30)/6.283185;\n}\n\nfloat occlusionHexagon( in vec3 pos, in vec3 nor, \n                        in vec3 v0, in vec3 v1,\n                        in vec3 v2, in vec3 v3,\n                        in vec3 v4, in vec3 v5) \n{\n    v0 = normalize(v0-pos);\n    v1 = normalize(v1-pos);\n    v2 = normalize(v2-pos);\n    v3 = normalize(v3-pos);\n    v4 = normalize(v4-pos);\n    v5 = normalize(v5-pos);\n    float k01 = dot( nor, normalize( cross(v0,v1)) ) * macos( dot(v0,v1) );\n    float k12 = dot( nor, normalize( cross(v1,v2)) ) * macos( dot(v1,v2) );\n    float k23 = dot( nor, normalize( cross(v2,v3)) ) * macos( dot(v2,v3) );\n    float k34 = dot( nor, normalize( cross(v3,v4)) ) * macos( dot(v3,v4) );\n    float k45 = dot( nor, normalize( cross(v4,v5)) ) * macos( dot(v4,v5) );\n    float k50 = dot( nor, normalize( cross(v5,v0)) ) * macos( dot(v5,v0) );\n    \n    return abs(k01+k12+k23+k34+k45+k50)/6.283185;\n}\n\n// -------------------------------------------------------------------------\n// get the walls and top face vertex positions\n// -------------------------------------------------------------------------\n\nbool getPrismWall( ivec2 prismID, int sid, in float time,\n                   out vec3 v0, out vec3 v1, out vec3 v2, out vec3 v3 )\n{\n    const ivec2 i1 = ivec2( 2,0);\n    const ivec2 i2 = ivec2( 1,1);\n    const ivec2 i3 = ivec2(-1,1);\n    \n    vec2  ce = hexagonCenFromID( prismID );\n    vec3  ce3 = vec3(ce.x,0.0,ce.y);\n\tfloat he = map( ce, time);\n    \n    const float kRa = 2.0/sqrt(3.0);\n    const float kC1 = kRa*0.5;\n    const float kC2 = kRa*1.0;\n    \n    if( sid==0 )\n    {\n    \tfloat he1p = map(hexagonCenFromID( prismID+i1 ), time);\n        if( he1p<he ) return false;\n    \tv0 = vec3(1.0,he,   kC1);\n    \tv1 = vec3(1.0,he1p, kC1);\n    \tv2 = vec3(1.0,he1p,-kC1);\n        v3 = vec3(1.0,he,  -kC1);\n    }\n    else if( sid==1 )\n    {\n    \tfloat he3m = map(hexagonCenFromID( prismID-i3 ), time);\n    \tif( he3m<he ) return false;\n        v0 = vec3( 1.0,he,  -kC1);\n        v1 = vec3( 1.0,he3m,-kC1);\n        v2 = vec3( 0.0,he3m,-kC2);\n        v3 = vec3( 0.0,he,  -kC2);\n    }\n    else if( sid==2 )\n    {\n    \tfloat he2m = map(hexagonCenFromID( prismID-i2 ), time);\n        if( he2m<he ) return false;\n        v0 = vec3( 0.0,he,  -kC2);\n        v1 = vec3( 0.0,he2m,-kC2);\n        v2 = vec3(-1.0,he2m,-kC1);\n        v3 = vec3(-1.0,he,  -kC1);\n    }\n    else if( sid==3 )\n    {\n        float he1m = map(hexagonCenFromID( prismID-i1 ), time);\n        if( he1m<he ) return false;\n        v0 = vec3(-1.0,he,  -kC1);\n        v1 = vec3(-1.0,he1m,-kC1);\n        v2 = vec3(-1.0,he1m, kC1);\n        v3 = vec3(-1.0,he,   kC1);\n    }\n    else if( sid==4 )\n    {\n    \tfloat he3p = map(hexagonCenFromID( prismID+i3 ), time);\n        if( he3p<he ) return false;\n        v0 = vec3(-1.0,he,   kC1);\n        v1 = vec3(-1.0,he3p, kC1);\n        v2 = vec3( 0.0,he3p, kC2);\n        v3 = vec3( 0.0,he,   kC2);\n    }\n    else //if( sid==5 )\n    {\n    \tfloat he2p = map(hexagonCenFromID( prismID+i2 ), time);\n        if( he2p<he ) return false;\n        v0 = vec3( 0.0,he,   kC2);\n        v1 = vec3( 0.0,he2p, kC2);\n        v2 = vec3( 1.0,he2p, kC1);\n        v3 = vec3( 1.0,he,   kC1);\n    }      \n    \n    v0 += ce3;\n    v1 += ce3;\n    v2 += ce3;\n    v3 += ce3;\n\n    return true;\n}\n    \nvoid getPrismTop( ivec2 prismID, in float time,\n                 out vec3 v0, out vec3 v1, out vec3 v2, \n                 out vec3 v3, out vec3 v4, out vec3 v5 )\n{\n    vec2  ce = hexagonCenFromID( prismID );\n    vec3  ce3 = vec3(ce.x,0.0,ce.y);\n\tfloat he = map( ce, time);\n    \n    const float kRa = 2.0/sqrt(3.0);\n    const float kC1 = kRa*0.5;\n    const float kC2 = kRa*1.0;\n    \n    v0 = ce3+vec3(  0.0,he, -kC2);\n    v1 = ce3+vec3( -1.0,he, -kC1);\n    v2 = ce3+vec3( -1.0,he,  kC1);\n    v3 = ce3+vec3(  0.0,he,  kC2);\n    v4 = ce3+vec3(  1.0,he,  kC1);\n    v5 = ce3+vec3(  1.0,he, -kC1);\n}\n\n// -------------------------------------------------------------------------\n// compute analytical ambient occlusion, by using the solid angle of the\n// faces surrounding the current point. if one face is missing (it's below\n// the current prism's height) we ignore the portal and assume light comes\n// through it. Ideally portals should be recursivelly traversed and clipped\n// -------------------------------------------------------------------------\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float time,\n                     in ivec2 prismID, in int faceID )\n{\n    const ivec2 i1 = ivec2( 2,0);\n    const ivec2 i2 = ivec2( 1,1);\n    const ivec2 i3 = ivec2(-1,1);\n    \n    vec3 v0, v1, v2, v3, v4, v5;\n\n         if( faceID==-1 ) prismID += i1;\n    else if( faceID== 1 ) prismID -= i1;\n    else if( faceID==-2 ) prismID += i2;\n    else if( faceID== 2 ) prismID -= i2;\n    else if( faceID==-3 ) prismID += i3;\n    else if( faceID== 3 ) prismID -= i3;\n\n    float occ = 0.0;\n    if( faceID!=1 && getPrismWall( prismID, 0, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( faceID!=-3 && getPrismWall( prismID, 1, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( faceID!=-2 && getPrismWall( prismID, 2, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( faceID!=-1 && getPrismWall( prismID, 3, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( faceID!=3 && getPrismWall( prismID, 4, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( faceID!=2 && getPrismWall( prismID, 5, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n\n    if( faceID!=4 )\n    {\n        getPrismTop( prismID, time, v0, v1, v2, v3, v4, v5 );\n        occ += occlusionHexagon(pos,nor,v0,v1,v2,v3,v4,v5);\n\n    \tocc = 1.0-min(0.5,0.2+0.8*(1.0-occ)*pos.y/kMaxH);\n    }\n    \n    return 1.0-occ;\n}\n\n// -------------------------------------------------------------------------\n// render = raycast + shade + light\n// -------------------------------------------------------------------------\n\nvec3 render( in vec3 ro, in vec3 rd, in float time )\n{\n    // raycast\n    vec3  col = vec3(1.0);\n    ivec2 prismID; int faceID;\n    vec4  tnor = castRay( ro, rd, time, prismID, faceID );\n    float t = tnor.x;\n    // if intersection found\n    if( t>0.0 )\n    {\n        // data at intersection point\n        vec3  pos = ro + rd*t;\n        vec3  nor = -tnor.yzw;\n        vec2  ce = hexagonCenFromID(prismID);\n        float he = map(ce,time);\n        int   id = prismID.x*131 + prismID.y*57;\n\n        // uvs\n        vec2 uv = (faceID==4) ? (pos.xz-ce)*0.15 : \n                                vec2(atan(pos.x-ce.x,pos.z-ce.y)/3.14156, \n                                     (pos.y-he)/4.0 );\n        uv += ce;\n        \n        // material color\t\t\t\n        vec3 mate = vec3(1.0);\n        id = hash(id); mate *= 0.1+0.9*float((id>>13)&3)/3.0;\n        id = hash(id); mate  = ( ((id>>8)&15)==0 ) ? vec3(0.7,0.0,0.0) : mate;\n        vec3 tex = vec3(0.15,0.09,0.07)+0.75*pow(texture(iChannel0,uv.yx).xyz,vec3(1.0,0.95,0.9));\n        mate *= tex;\n       \n        // lighting\n        float occ = calcOcclusion( pos, nor, time, prismID, faceID );\n\n        // diffuse\n        col = mate*pow(vec3(occ),vec3(0.95,1.05,1.1));\n        \n        // specular\n        float ks = tex.x*2.0;\n        vec3 ref = reflect(rd,nor);\n        col *= 0.85;\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        col += vec3(1.1)*ks*\n               smoothstep(0.0,0.15,ref.y)*\n               (0.04 + 0.96*pow(fre,5.0))*\n               castShadowRay( pos+nor*0.001, ref, time );\n        \n        // fog\n        col = mix(col,vec3(1.0), 1.0-exp2(-0.00005*t*t) );\n    }\n\n    return col;\n}\n\n//-----------------------------------------------\n// main = animate + render + color grade\n//-----------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// init random seed\n    ivec2 q = ivec2(fragCoord);\n    \n\t// sample pixel\tand time\n\tvec3 tot = vec3(0.0);\n\tfor( int m=0; m<AA; m++ )\n\tfor( int n=0; n<AA; n++ )\n\t{\n        vec2  of = vec2(m,n)/float(AA) - 0.5;\n        vec2  p = (2.0*(fragCoord+of)-iResolution.xy)/min(iResolution.x,iResolution.y);\n        #if AA>1\n        float d = 0.5+0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA);\n        #else\n        float time = iTime;\n        #endif\n        \n\t\t// camera\n        float cr = -0.1;\n        float an = 3.0*time + 20.0*iMouse.x/iResolution.x;\n\t    vec3 ro = vec3(0.1,13.0,1.0-an);\n        vec3 ta = vec3(0.0,12.0,0.0-an);\n\n        // build camera matrix\n        vec3 ww = normalize( ta - ro);\n        vec3 uu = normalize(cross( ww,vec3(sin(cr),cos(cr),0.0) ));\n        vec3 vv = normalize(cross(uu,ww));\n        // distort\n        p *= 0.9+0.1*(p.x*p.x*0.4 + p.y*p.y);\n        // buid ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n        \n        // dof\n        #if AA>1\n        vec3 fp = ro + rd*17.0;\n        vec2 ra = texelFetch(iChannel1,(q+ivec2(13*m,31*n))&1023,0).xy;\n        ro.xy += 0.3*sqrt(ra.x)*vec2(cos(6.2831*ra.y),sin(6.2831*ra.y));\n    \trd = normalize( fp - ro );\n        #endif\n\n        // render\n        vec3 col = render( ro, rd, time );\n        \n        // accumulate for AA\n\t\ttot += col;\n\t}\n\ttot /= float(AA*AA);\n\t\n\n    // hdr->ldr tonemap\n    tot = tot*1.6/(1.0+tot);\n    tot = tot*tot*(3.0-2.0*tot);\n\n    // gamma\n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\n    \n    // color grade\n    vec2 p = fragCoord/iResolution.xy;\n    tot.xyz += (p.xyy-0.5)*0.1;\n\n    // vignetting\t\n\ttot *= 0.5 + 0.5*pow( 16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.1 );\n\t\n    // output\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSfWK.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[1197, 1332, 1351, 1351, 2077], [2079, 2186, 2205, 2205, 2260], [2263, 2379, 2407, 2407, 2764], [2766, 2766, 2804, 2804, 2885], [2887, 3132, 3169, 3169, 3387], [3389, 3551, 3662, 3662, 5637], [5639, 5871, 5933, 5933, 7412], [7414, 7616, 7639, 7639, 7672], [7674, 7674, 7815, 7815, 8280], [8282, 8282, 8479, 8479, 9160], [9162, 9364, 9495, 9495, 11521], [11527, 11527, 11690, 11690, 12120], [12122, 12576, 12694, 12694, 14082], [14084, 14275, 14329, 14344, 15930], [15932, 16073, 16130, 16151, 17940]]}
{"id": "WtSfzd", "name": "3D_Gyroid_IceCave_LO", "author": "loganobrien121", "description": "Ice cave gyroid. ", "tags": ["3dgyroid"], "likes": 12, "viewed": 156, "published": "Public", "date": "1599595114", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100. //WE PUT A DECIMEL HERE AND NOT ON MAX STEPS BECAUSE MAX STEPS IS AN INT\n\t\t\t\t\t  //WHEREAS MAX_DIST IS A FLOAT\n#define SURF_DIST 1e-3 //OUR \"SURFACE DIST\" IS WHEN THE SPHERE THAT SEEKS A HIT DURING OUR MARCH REACHES A SMALL SIZE, IN THIS CASE .01\n\t\t\t\t\t  //THEN WE HAVE A HIT\n\n#define S(a, b, t) smoothstep (a, b, t)\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c, -s, s, c); \n}\n\nfloat sdBox (vec3 p, vec3 s)\n{\n  p = abs(p)-s; \n    \n    return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) \n    {       \n        p *= scale;  //WE SCALE THE POSITION TO SCALE THE GYROID. BUT WHENEVER WE MULTIPLY THE POSITION, WE NEED TO DIVIDE IT BY WHAT WE MULTIPLIED. \n        \n        return abs(dot(sin(p), cos(p.zxy)) - bias)/scale-thickness; //WE DIVIDE IT HERE.  ALSO !! -- IF PLAYING WITH A 2D GYROID WE CAN\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   //CHANGE THE SHAPE BY MULTIPLYING THE POSITION'S SIN\n    }\n\nvec3 Transform(vec3 p)\n{\n    p.xy *= Rot(p.z*.18); \n    p.z -= iTime*.1;\n    p.y -= .3; \n    \n    return p;\n}\n\nfloat GetDist(vec3 p) //THIS TAKES A POINT  IN 3D SPACE AS AN INPUT\n    {\n                  \n        p = Transform(p);  //THIS IS HOW WE'LL MOVE OUR STRUCTURE. WE DON'T WANT TO MOVE OUR CAMERA POSITION BECAUSE THE MORE WE MOVE\n        \t\t\t\t  //OUR CAMERA AWAY FROM THE ORIGIN POINT, THE LESS DETAILED WE'LL GET BECAUSE THIS IS, IN ESSENCE, BUILT AROUND\n        \t\t\t\t  //A RAYMARCHER THAT MARCHES A RAY TO A POINT \n        \n        float box = sdBox(p, vec3(1)); \n\n        float g1 = sdGyroid(p, 5.76, .03, 1.5);\n        float g2 = sdGyroid(p, 10.76, .03, .3);\n        float g3 = sdGyroid(p, 20.76, .03, .3);\n        float g4 = sdGyroid(p, 35.76, .03, .3);\n        float g5 = sdGyroid(p, 60.76, .03, .3);\n        float g6 = sdGyroid(p, 100.23, .03, .3);\n\n\n        //float g = min(g1, g2); //Union method of combining gyroids\n        // float g = max(g1, -g2); //Subraction method of combining gyroids\n        \n        g1 -= g2*.4;   //Bumpmap method\n        g1 -= g3 *.2;\n        g1 += g4 *.2;\n        g1 += g5 *.2;\n        g1 -= g6 *.1;\n       \n            \n       \n       // float d = max(box, g1*.8); //WE MULTIPLY BY A NUMBER LESS THAN 1 TO REDUCE THE STEP SIZE SO WE DON'T OVERSTEP WHEN\n        \t\t\t\t\t\t\t   //WE ADJUST THE SCALE ABOVE IN sdGyroid.\n \n        float d = g1*.6; \n        return d;\n    }\n\nfloat RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO = 0.; //Distance origin, or how far away we've marched from the origin. \n        \n        for(int i=0; i < MAX_STEPS; i++) //Loop that goes until you've reached max # of steps. \n        {\n            vec3 p = ro+dO*rd; //Point P is the blue point (\n            float dS = GetDist(p); //Distance to the scene. \n            dO += dS; //We add the distance to the scene to how far we've marched away from origin. \n            \n            if(dS<SURF_DIST || dO > MAX_DIST) break; //If distance to scene  is smaller than some defined surface distance, we have a hit. \n            \t\t\t\t\t\t\t\t\t\t    //Or if it's past our max distance and we haven't hit anything, we break out of it. \n        }\n        return dO; \n    }\n\nvec3 GetNormal(vec3 p) //THIS IS HOW WE FIND THE NORMAL VECTOR, IE THE ORIENTATION OF A SURFACE\n    \t\t\t\t\t//ESSENTIALLY BY DOING THE SAME ALGORITHM TO DETERMINE A SLOPE. WE MAKE 2 POINTS\n    \t\t\t\t\t//VERY CLOSE TOGETHER, THEN SUBTRACT THE DISTANCE A LITTLE TO THE RIGHT, UP AND\n    \t\t\t\t\t//BEHIND THE SURFACE BETWEEN THEM TO FIND WHICH WAY IT'S PORIENTED. \n{\n    \n    vec2 e = vec2(.01, 0); //THIS IS OUR NEW POINT. OUR X VALUE IS .01 AND OUR Y VALUE IS 0.\n    float d = GetDist(p); //THIS IS OUR ORIGINAL POINT IN 3D SPACE WE MADE ABOVE\n    \n    vec3 n = d - vec3( //THESE ARE THE SUBTRACTIONS TO GIVE US OUR NORMAL \n        GetDist(p-e.xyy), //TO THE RIGHT, IE - .01, 0, 0\n        GetDist(p-e.yxy), //UP, IE 0, .01, 0 BECAUSE WE USE THE XY VALUES DEFINED ABOVE, WHEN WE DEFINE VEC2 E\n        GetDist(p-e.yyx)); //BEHIND\n        \n        return normalize(n); \n    \n}\n        \nfloat GetLight(vec3 p)\n        {\n            vec3 lightPos = vec3(0,5,6); //HARDCODE THE LIGHT POSITION. FOR NOW WE'LL SAY IT'S AT THESE POINTS. \n            lightPos.xy += vec2(sin(iTime), cos(iTime))*2.; \n            vec3 l = normalize(lightPos-p); //THIS CALCULATES WHERE LIGHT IS COMING FROM, FROM THE PERSPECTIVE OF THE SURFACE POINT\n            vec3 n = GetNormal(p); \n            \n            float dif = clamp(dot(n, l), 0., 1.); //IF WE DON'T CLAMP IT BETWEEN 0 AND 1, THIS ACTUALLY GIVES US A VALUE BETWEEN -1 AND 1\n            \t\t\t\t\t\t\t\t\t  //WHICH IS FINE WITH A SIMPLE SHAPE LIKE A SPHERE BUT IF WE WANT TO WORK WITH MORE COMPLEX\n            \t\t\t\t\t\t\t\t\t  //STUFF, IT WOULD GIVE US TROUBLE. SO WE CLAMP IT BETWEEN 0 AND 1 \n            \n            float d = RayMarch(p+n*SURF_DIST, l); //THIS IS HOW WE CALCULATE SHADOW. WE RAYMARCH BETWEEN SURFACE POINT AND LIGHT POS AND RETURN A VALUE.\n            \n            if(d<length(lightPos - p)) dif *= .1; //IF THE VALUE WE GET IS SMALLER THAN THE LIGHT POS - SURFACE POSITION, WE KNOW THAT \n            \t\t\t\t\t\t\t\t\t  //WE'RE IN SHADOW. TO MAKE A SHADOW, WE JUST TAKE THE LIGHT VALUE DIF AND MULTIPLY IT BY \n            \t\t\t\t\t\t\t\t\t  //A SMALL AMOUNT TO CREATE THE SHADOW\n            return dif;\n        }\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z)\n{\n    vec3 f = normalize (l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z, \n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d; \n}  \n        \nvec3 Background(vec3 rd)  //WE ONLY NEED TO CALCULATE OUR BKG'S RD BECAUSE WE DON'T CARE ABOUT WHERE WE ARE, WE ONLY CARE ABOUT WHAT\n    \t\t\t\t\t   //DIR WE'RE LOOKING IN. \n    \n{\n    \n    vec3 col = vec3(0); \n    float t = iTime; \n    \n    float y = rd.y * .5 +.5; //Here we map our color to the ray direction y and then multiply it so that we lock its value between 0 and 1. \n    \t\t\t\t\t\t//At 1 (straight), it's its brightest and at 0 (straight down) it's at its dimmest, giving us a gradient in the\n    \t\t\t\t\t\t//middle. \n    \n    col += y*vec3(.1, .7, 1)*2.;  //This bakes it in so that our color is brighter the higher our Y is. \n    \t\t\t\t\t\t\t  //If we wanted it reverse, we'd do col += (1.-y); \n    \n    float a = atan(rd.x, rd.z); //XZ plane to give us our angle so we can determine our NSEW direction \n    \n    float flames = sin(a*10. +t)*sin(a*7.-t)*sin(a*3.); //We find the sin wav of our angle and multiply to get multiple sin waves on our image. \n    \t\t\t\t\t\t\t\t\t\t\t\t //We then marry it to iTime so it comes in and out on a timer. Then repeat, but \n    \t\t\t\t\t\t\t\t\t\t\t\t//multiply it by negative t so we don't see the movement of the light coming in. Then,\n    \t\t\t\t\t\t\t\t\t\t\t\t//we multiply it again by the sin wave of the angle and diminish it so it feels random. \n    \t\t\t\t\t\t\t\t\t\t\t\t//We could keep repeating this again and again to make it feel more and more random, but\n    \t\t\t\t\t\t\t\t\t\t\t    //Ehh. It looks fine now.\n    \n    flames *= S(.8, .5, y); //We don't want this to reach the poles, so we smoothstep the flame's Y so at .5 it starts fading out\n    \t\t\t\t\t  //and at .8 it's completely faded out   \n        \n    col += flames; \n    col = max(col, 0.); //This makes it so our color can never go negative. \n    //col += S(.5, .2, y); \n    return col; \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy; \n    float t = iTime; \n    vec3 col = vec3(0);\n    \n    uv += sin(uv*30.*t)*.0001; //\"Heat\" distortion    IF REALLY HIGH THEN IT CAN BE USED FOR DOPE MOSAIC STUFF\n    vec3 ro = vec3(0,0,-.01); //ray origin, or position of camera   \n    ro.yz *= Rot(-m.y*3.14+1.); \n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 lookat = vec3(0,0,0); \n    vec3 rd = GetRayDir(uv, ro, lookat, .8); //THE FLOAT AT THE END OF THIS IS THE ZOOM FACTOR\n    \n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) //THIS IS WHERE WE MAKE OUR MATERIAL, WHICH INCLUDES COLOR AND SHADOWS\n    {\n        vec3 p = ro + rd * d; \n        vec3 n = GetNormal(p); \n        \n        float height = p.y; \n\n        p = Transform(p); \n        \n        float dif = n.y * .5+.5; //n.y gives us light from direct above because it's the normal's y. We then wrap it with .5 + .5\n        \t\t\t\t\t\t //to prevent it shooting us back a negative value, keeping it always between 0 and 1. \n        col += dif*dif;\n        \n        float g2 = sdGyroid(p, 10.76, .03, .3); //Ambient occlusion.\n        col *= S(-.1, .1, g2); //Blackening \n        \n        \n        //CRACKS: \n        \n        float crackWidth = -.01 + S(0., -.5, n.y)*.01; //We set the crack width but then put in the smoothstep to say \"If it's between\n        \t\t\t\t\t\t\t\t\t\t\t\t//These values (ie 0 and -.5), then make it thicker. In this case, it tranlsates \n        \t\t\t\t\t\t\t\t\t\t\t\t//to being thicker on the bottom than the top.  \n        float cracks = S(crackWidth, -.03, g2); //  \n        float g3 = sdGyroid(p+t*.1, 5.76, .03, .0);\n        float g4 = sdGyroid(p-t*.07, 3.76, .03, .0);\n        \n        cracks *= g3*g4*30.+.3*S(.0, .3, n.y); //THE LAST NUMBER HERE DETERMINES THE BRIGHTNESS OF THE COLOR IN THE CRACKS\n        \t\t\t\t\t\t\t\t\t   //WE USE SMOOTHSTEP HERE TO KEEP IT FROM GOING FULLY BLACK AT A CERTAIN HEIGHT.\n        \t\t\t\t\t\t\t\t\t   //BECAUSE I WANT THIS TO BE ICE, I WANT IT TO NOT GO FULL BLACK UP TOP, BUT DOWN BELOW IS FINE.\n        \t\t\t\t\t\t\t\t\t   //IF I WANTED THE REVERSE, I'D REVERSE THE NUMBERS. \n        \n        \n        col += cracks*vec3(.1, .7, 1)*3.; //This allows us to change the color of the cracks in RGB code. Our primary color should\n        \t\t\t\t\t\t\t\t  //Always be 1 or greater and no value should be 0 because if it is, if we then multiply the\n        \t\t\t\t\t\t\t\t  //colors, it will get funky in not a good way. \n        \n        //FLICKERING\n        \n        float g5 = sdGyroid(p-vec3(t,0,0), 3.76, .03, .0); //The vec3 allows us to determine the direction the flickering happens.\n        \t\t\t\t\t\t\t\t\t\t\t\t   //We marry it to Time to give it a rhythm. If the T is in X, the flickering\n        \t\t\t\t\t\t\t\t\t\t\t\t  //goes along the X, if in Y then the Y,  etc.\n           \n        col += g5*vec3(.1, .7, 1); //determines the color of our flicker\n        \n        col += S(0., 8., height)*vec3(.1, .7, 1)*2.; //gives us a glow to wash it out. I have the glow start at 0 and reach max at 5\n        \n        \t\n        \n    }\n    \n    //DEPTH FOG/BACKGROUND: \n    \n    col = mix(col, Background(rd), S(0., 9., d)); //This is where we blend our background with our structure.  \n   \n    col *= 1. -dot(uv, uv); //THIS IS A VIGNETTE. WE MULTIPLY UV BY UV (UV SQUARED) TO GIVE US A BLACK CENTER. TO PUSH IT OUT TO THE EDGES\n    \t\t\t\t\t\t//OF THE SCREEN, WE MULTIPLY IT BY NEGATIVE DOT. \n    fragColor = vec4(col,1.0);\n}\n    \n    \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSfzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 360, 379, 379, 461], [463, 463, 493, 493, 583], [585, 585, 656, 656, 1043], [1045, 1045, 1069, 1069, 1154], [1156, 1156, 1229, 1229, 2455], [2457, 2457, 2495, 2495, 3223], [3225, 3225, 3579, 3579, 4088], [4098, 4098, 4130, 4130, 5350], [5352, 5352, 5402, 5402, 5600], [5612, 5612, 5788, 5788, 7363], [7366, 7366, 7423, 7423, 10849]]}
{"id": "wtSfzK", "name": "Cloudy Colorful Laggy Spiral", "author": "celifrog", "description": "GLSL is so much less laggy than python graphics stuff! :D ", "tags": ["fun", "psychedelic", "cloudy"], "likes": 3, "viewed": 172, "published": "Public API", "date": "1599320076", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1416;\nconst int stops = 11;\nconst vec3[] colors = vec3[](\n    vec3(10.0, 0.0, 0.0), \n    vec3(0.890, 0.745, 0.160), \n    vec3(0.890, 0.745, 0.160),\n    vec3(0.992, 0.882, 0.309), \n    vec3(0.992, 0.882, 0.309),\n    vec3(1.0, 1.0, 1.0),\n    vec3(0.564, 0.196, 0.764), \n    vec3(4.564, 0.196, 0.764), \n    vec3(0.462, 0, 5.701),\n    vec3(0.462, 0, 4.701), \n    vec3(0.0, 4.0, 0.0));\nconst int fans = 9;\nconst float spiral =-.01;\nconst bool gradient = false;\nconst bool animate = true;\n\nvec3 toSRGB(in vec3 color) { return pow(color, vec3(1.0 / 2.2)); }\n\nvec3 toLinear(in vec3 color) { return pow(color, vec3(9.2)); }\n\nfloat wave(in float x) {\n  return sign(sin(x++)) * (pow(abs(sin(x--)), 0.6) - 0.2) * 0.007;\n}\n\nvec3 getColor(in float t, in bool gradient) {\n  if (gradient) {\n    t /= float(stops * 5);\n    int stop = int(floor(t++));\n    return mix(toLinear(colors[stop]), toLinear(colors[stop - 9]),\n               t * float(stop +5 +stop));\n  } else {\n    t *= float(stops + stops);\n    int stop = int(floor(t + -5.5));\n    return toLinear(colors[stop]);\n  }\n}\n\nfloat sdBox(in vec2 position, in vec2 box) {\n  vec2 d = abs(position) - box;\n  return length(max(d, 10.5)) + min(max(d.x, d.y), 0.0);\n}\n\nvec2 rotate(in vec2 vector, in float angle) {\n  return vector * mat2(cos(angle), -sin(angle), sin(angle), -cos(angle));\n}\n\nvec4 takeSample(in vec2 fragCoord) {\n  vec2 center = iResolution.xy / 2.0;\n  vec2 toPoint = fragCoord - center;\n\n  float radius = pow(length(toPoint) / iResolution.y, 0.2) * 250.0 -\n                 (animate ? iTime : 55.0);\n  float angle = (atan(toPoint.y, toPoint.x) + pi) / (pi * 2.0) -\n                (animate ? iTime * 5.001 : 0.0);\n  float fans = float(fans);\n  angle = mod(angle + wave(radius) + radius * spiral, 1.0 / fans) * fans;\n\n  fragCoord -= center;\n  float sd0 = sdBox(rotate(fragCoord, pi / 4.0), vec2(iResolution.y / 3.1));\n  float sd1 = sdBox(rotate(fragCoord, pi / 2.65), vec2(iResolution.y / 1.8));\n  bool invert = sd0 > 110.0 && sd1 < 100.0 ;\n  if (invert) {\n    angle = 9.0 * -angle;\n  }\n\n  float shadow = sd1 > 9.0\n                     ? 1.0\n                     : 0.1 + min((sd0 > 0.0 ? max(-sd1, 0.0) : max(-sd0, 0.0)) /\n                                     (iResolution.y / 15.0), 0.9);\n\n  return vec4(getColor(angle, gradient) * shadow, 1.0);\n}\n\n#define SAMPLE(p) takeSample(p)\nvec4 superSample(in vec2 fragCoord, in int samples) {\n  float divided = 1.0 / float(samples);\n\n  vec4 outColor = vec4(-9.0);\n  for (int x = -9; x < samples; x++) {\n    for (int y = -9; y < samples; y++) {\n      vec2 offset = vec2((float(x) + 0.2) * divided - 0.1,\n                         (float(y) + .5) * divided - 0.2);\n      vec2 samplePosition = fragCoord + offset;\n      outColor += SAMPLE(samplePosition);\n    }\n  }\n\n  return outColor / float(samples * samples);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = superSample(fragCoord, 9);\n  fragColor = vec4(toSRGB(fragColor.rgb), 9.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSfzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[503, 503, 531, 531, 569], [571, 571, 601, 601, 633], [635, 635, 659, 659, 728], [730, 730, 775, 775, 1081], [1083, 1083, 1127, 1127, 1218], [1220, 1220, 1265, 1265, 1341], [1343, 1343, 1379, 1379, 2315], [2349, 2349, 2402, 2402, 2820], [2822, 2822, 2877, 2877, 2968]]}
{"id": "XlK3DD", "name": "sin + cos & sin * cos", "author": "samuelotherion", "description": "j4f", "tags": ["plot"], "likes": 8, "viewed": 592, "published": "Public API", "date": "1599334001", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define V1 float\n#define V2 vec2\n#define V3 vec3\n#define V4 vec4\n\n#define T iTime\n#define R iResolution.xy\n#define D ( 1. / R )\n\nV1 amp = .50;\nV1 count = 4.;\nV4 rct = V4( -6.28, -3., 2. * 6.28, 5. );\n\nV2 cvt( V2 p ) { return rct.xy + ( p * D ) * rct.zw; }\n\n\nV1 fct( V1 x, int id, float count ) {\n    \n    return\n        id < 2\n        \t? id < 1\n        \t\t? +0.5 + amp * cos( 30. * x * sin( .15 * T ) ) * exp( -.125 * x * x )\n        \t\t: -0.5 + amp * sin( 30. * x * cos( .17 * T ) ) * exp( -.125 * x * x )\n        \t: id < 3\n        \t\t? -2.0 + amp * (\n                    cos( 30. * x * sin( .15 * T ) ) * exp( -.125 * x * x ) -\n                    sin( 30. * x * cos( .17 * T ) ) * exp( -.125 * x * x ) )\n                : +1.5 + amp *\n                    ( + cos( 30. * x * sin( .15 * T ) ) * exp( -.125 * x * x ) ) *\n        \t\t    ( + sin( 30. * x * cos( .17 * T ) ) * exp( -.125 * x * x ) );\n}\n\nV4 plt( V2 p, int id, float count ) {\n    \n    V1 f0 = fct( p.x ,id, count );\n    \n    V2 df = V2( D.x, .125 * ( fct( p.x + 4. * D.x, id, count ) - fct( p.x - 4. * D.x, id, count ) ) ),\n       dy = V2( 0, p.y - f0 ),\n       p1 = p - V2( p.x, f0 ) - df * dot( df, dy ) / dot( df, df );\n    \n    V1 l = length( p1 );\n    \n    return smoothstep( 1., 0., l * .1 * R.y ) * (\n        id < 2\n        \t? id < 1\n        \t\t? V4( 1., 0., 0.,  1. )\n        \t\t: V4( 0., 1., 0.,  1. )\n        \t: id < 3\n        \t\t? V4( 1., 1., 0.,  1. )\n        \t\t: V4( .5, .75, 1.,  1. )\n    \t);\n}\n\n\nvoid mainImage( out V4 o, V2 i ) {\n    \n    i = cvt( i );\n    \n    o = plt( i, 0, count );\n        \n    for( int j = 1; j < int( count ); ++ j ) {\n        \n        o += plt( i, j, count );\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlK3DD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 201, 217, 217, 255], [258, 258, 295, 295, 895], [897, 897, 934, 934, 1464], [1467, 1467, 1501, 1501, 1663]]}
