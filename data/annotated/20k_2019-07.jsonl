{"id": "3l23Wc", "name": "Hello Camera", "author": "2YY", "description": "I'm studying camera work of ray marching.\n\nAlmost done. But, I'm confused about the \"up vector\".\n\nto rotate by any degrees, I need check camera direction (on world coords) when calculate intended up vector?", "tags": ["camera"], "likes": 2, "viewed": 122, "date": "1562083871", "time_retrieved": "2024-06-20T19:39:20.758187", "image_code": "//////////////////////////////////////////////////\n// CONSTS\n\n/**\n * Every frames that max ray marching steps of every fragments.\n * TODO: いくつにすべき？ (パフォーマンスと画質のバランス的に)\n */\nconst int MAX_MARCHING_STEPS = 255;\n\n/**\n * Value of \"This distance are collisioned?\".\n * TODO: いくつにすべき？ (画質的に)\n */\nconst float EPSILON = .001;\n\n\n\n\n//////////////////////////////////////////////////\n// STRUCTS\n\n/**\n * Struct of camera.\n * This camera has some properties based on physical and you can set any values that same any any real camera device.\n */\nstruct Camera {\n\tfloat focalLength; // mm\n    vec2 sensorSize; // mm\n    vec2 lensShift; // mm\n    vec3 position;\n    vec3 lookAt;\n    float roll; // degree\n};\n\n/**\n * Struct of light.\n */\nstruct Light {\n    vec3 position; // in global coords\n    vec3 direction; // please set normalized vector\n    float strength;\n    vec3 specular;\n    vec3 diffuse;\n};\n\n/**\n * Struct of material.\n */\nstruct Material {\n\tvec3 albedo; // RGB\n    float specular;\n    float diffuse;\n    float ambient;\n    float shininess;\n};\n\n    \n    \n    \n//////////////////////////////////////////////////\n// DISTANCE FUNCTIONS\n\n\n/**\n * Signed function of sphene.\n * @param {float} p point of ray\n * @param {float} s sphere radius\n * @return {float} distance from p to sphere\n */\nfloat sdSphere(vec3 p, float s) {\n\treturn length(p) - s;\n}\n\n/**\n * Signed function of box;\n * @param {vec3} p point of ray\n * @param {vec3} b box size\n */\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n/**\n * Signed function of scene.\n * @param {vec3} p point of ray\n * @return {float} distance from p to scene\n */\nfloat sdScene(vec3 p) {\n    float d = sdBox(p - vec3(0., 0., sin(iTime*2.)*-2.), vec3(1., 1., 1.));\n             d = min(d, sdBox(p - vec3(-3., sin(iTime*2.), 0.), vec3(1., 1., 1.)));\n             d = min(d, sdSphere(p - vec3(3., sin(iTime*4. + 10.), 0.), 1.));\n    return d;\n}\n\n\n\n\n//////////////////////////////////////////////////\n// RAY MARCHING UTILITY FUNCTIONS\n\n/**\n * Get normal vector of surface represented by signed distance function.\n * @param {p} point of marching ray tip\n */\nvec3 getNormal(vec3 p) {\n\treturn normalize(vec3(\n    \tsdScene(p + vec3(EPSILON, 0., 0.)) - sdScene(p + vec3(-EPSILON, 0., 0.)),\n        sdScene(p + vec3(0., EPSILON, 0.)) - sdScene(p + vec3(0., -EPSILON, 0.)),\n        sdScene(p + vec3(0., 0., EPSILON)) - sdScene(p + vec3(0., 0., -EPSILON))\n    ));\n}\n\n/**\n * Get field of view (FOV) with camera settings.\n * @param {vec2} sensorSize vertical and horizontal camera sensor size\n * @param {float} focalLength camera focal length\n * @return {vec2} vertical and horizontal field of view (in degrees)\n */\nvec2 getFieldOfView(vec2 sensorSize, float focalLength) {\n\tfloat verticalFov = degrees(2. * atan(sensorSize.y / 2. / focalLength));\n    float horizontalFov = degrees(2. *atan(sensorSize.y / 2. / focalLength));\n    return vec2(horizontalFov, verticalFov);\n}\n\n/**\n * Get normalized ray direction vec3. (on camera local coordinates)\n * @param {vec2} fov vertical and horizontal field of view\n * @param {float} focalLength camera focal length\n * @param {vec2} uv current UV coords.\n * @return {vec3} normalized ray direction (that correspond to current fragment coords)\n */\nvec3 getRayDirection(vec2 fov, float focalLength, vec2 uv) {\n    float directionX = fov.x / 2. / 90. * uv.x;\n    float directionY = fov.y / 2. / 90. * uv.y;\n    float directionZ = focalLength;\n\treturn normalize(vec3(directionX, directionY, directionZ));\n}\n\n/**\n * Get mat3 that translate to camera coords.\n * @param {vec3} position camera position (on the world coords)\n * @param {vec3} lookAt coords of \"Where to camera looking?\" (on the world coords)\n * @param {vec3} up camera up vector (on the world coords)\n * @return {mat3} viewing transform matrix\n */\nmat3 getViewingTransformMat3(vec3 position, vec3 lookAt, vec3 up) {\n    vec3 z = normalize(lookAt-position);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = normalize(cross(x, z));\n\treturn mat3(\n        vec3(x.x, y.x, z.x),\n        vec3(x.y, y.y, z.y),\n        vec3(x.z, y.z, z.z)\n    );\n}\n\n/**\n * Get camera up vector.\n * @param {float} roll degrees that \"How amount roll the screen camera?\"\n */\nvec3 getUpVector(float roll) {\n\treturn vec3(sin(radians(roll)), cos(radians(roll)), 0.);\n}\n\n\n\n\n//////////////////////////////////////////////////\n// SHADING UTILITY FUNCTIONS\n\n/**\n * Shading with normal vector.\n * @param {vec3} normal vector (please set normalized vector)\n * @return {vec3} result color\n */\nvec3 normalShading(vec3 normal) {\n\treturn normal;\n}\n\n/**\n * Shading with lambert reflection model.\n * @param {vec3} normal normal vector (please set normalized vector)\n * @param {Light} light light information\n * @param {Material} material material information\n * @return {vec3} result color\n */\nvec3 lambertShading(vec3 normal, Light light, Material material) {\n\treturn dot(light.direction, normal) * material.albedo * light.strength;\n}\n\n/**\n * Shading with phong reflection model.\n * @param {vec3} ray marching ray vector\n * @param {vec3} cameraPosition position of camera (in world coords)\n * @param {vec3} normal normal vector (please set normalized vector)\n * @param {Light} light light information\n * @param {float} ambientLightStrength strength of ambient light\n * @param {Material} material material information\n * @return {vec3} result color\n */\nvec3 phongShading(vec3 ray, vec3 cameraPosition, vec3 normal, Light light, float ambientLightStrength, Material material) {\n\tvec3 rayDirection = normalize(ray);\n    vec3 L = normalize(ray - light.position); // vector that \"surface to light\"\n    vec3 V = normalize(ray-cameraPosition); // vector that \"surface to camera\"\n    vec3 R = normalize(cross(cross(rayDirection, normal), rayDirection)); // vector that reflection direction from light to the other side of the surface point\n    return material.ambient * ambientLightStrength + (material.diffuse * dot(L, normal) * light.diffuse + material.specular * pow(dot(R, V), material.shininess) * light.specular);\n}\n\n\n\n\n//////////////////////////////////////////////////\n// MAIN PROCESS\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // UV (-1〜1 | adjusted to canvas aspect ratio)\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n\n    // Camera\n    Camera camera;\n    camera.focalLength = 59.8333;\n    camera.sensorSize = vec2(35.9, 24.);\n    camera.position = vec3(1000., 3000.*sin(iTime*2.), 5000.*sin(iTime));\n    camera.lookAt = vec3(sin(iTime*3.)*1., 0., 0.);\n    camera.roll = sin(iTime) * 360.;\n    \n    // Light\n    Light light1;\n    light1.position = vec3(0., 0., 0.);\n    light1.direction = normalize(vec3(1., 0., -1.));\n    light1.strength = 1.;\n    light1.specular = vec3(.0, .5,  .5);\n    light1.diffuse = vec3(.5, .0, .5);\n    \n    // Material\n    Material material1;\n    material1.albedo = vec3(1.*abs(sin(iTime)), 0., 1.);\n    material1.specular = .5;\n    material1.diffuse = .5;\n    material1.ambient = .5;\n    material1.shininess = 1.;\n\n    // Ray Marching\n    vec3 color = vec3(false);\n    float depth = 1.;\n    \n    // 回転を角度で指定するバージョン (Camera 構造体にそれ用のプロパティも持たせてみている)\n    // vec3 direction = getRayDirection(getFieldOfView(camera.sensorSize, camera.focalLength), camera.focalLength, uv) * getViewingTransformMat3(camera.position, camera.lookAt, getUpVector(camera.roll));\n    \n    // 見た目重視で適当に回転してみるバージョン\n    vec3 direction = getRayDirection(getFieldOfView(camera.sensorSize, camera.focalLength), camera.focalLength, uv) * getViewingTransformMat3(camera.position, camera.lookAt, vec3(.01, cos(iTime), 0.));\n    \n    bool isCollisioned = false;\n    for(int i=0; i<MAX_MARCHING_STEPS; i++) {\n        float distance = sdScene(camera.position + direction * depth);\n        if(distance < EPSILON) {\n\n            // color = normalShading(getNormal(camera.position + direction * depth));\n            color = lambertShading(getNormal(camera.position + direction * depth), light1, material1);\n            \n            break;\n        }\n        depth += distance;\n    }\n\n    // Render\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3l23Wc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lfSD2", "name": "Accounting+ Site Animation", "author": "trianglPixl", "description": "I was looking at the site for Accounting+ (https://accountingpl.us/) and saw this neat animation on their site used to border the screenshots section. I knew I had to recreate it, especially since the animation on the site doesn't loop correctly.", "tags": ["animation"], "likes": 3, "viewed": 95, "date": "1564247073", "time_retrieved": "2024-06-20T19:39:21.200669", "image_code": "const float topCircleCount = 11.0;\nconst vec4 topLayerColor = vec4(0.0, 0.0, 1.0, 1.0);\nconst float topLayerScreenHeight = 0.9;\nconst float topLayerSpeed = 1.0/15.0;\n\nconst float underCircleCount = 9.0;\nconst vec4 underLayerColor = vec4(0.0, 0.0, 0.0, 1.0);\nconst float underLayerScreenHeight = 0.83;\nconst float underLayerSpeed = 1.0/19.0;\n\nconst float checkerLayerCount = 6.0;\nconst vec4 checkerLayerColor1 = vec4(0.8, 0.45, 0.0, 1.0);\nconst vec4 checkerLayerColor2 = vec4(0.55, 0.25, 0.0, 1.0);\nconst vec2 checkerLayerSpeed = vec2(1.0/45.0, 1.0/30.0);\n\nconst float triangleLayerFrequency = 20.0;\nconst vec4 triangleLayerColor = vec4(0.1, 0.1, 0.1, 1.0);\nconst float triangleLayerHeight = 0.1;\nconst float triangleLayerSpeed = 1.0 / 10.0;\n\nvec4 getCurtain(vec2 fragCoord, float circleCount, vec4 color, float screenHeight, float speed)\n{\n    float layerHeight = iResolution.y * screenHeight;\n    if (fragCoord.y > layerHeight)\n    {\n        return color;\n    }\n    else\n    {\n        float layerCycle = -iTime * speed;\n        float circleDiameter = iResolution.x / circleCount;\n        float circleRadius = circleDiameter / 2.0;\n        vec2 circleCoord;\n        circleCoord.x = mod(fragCoord.x + iResolution.x * fract(layerCycle), circleDiameter)\n            - circleRadius;\n        circleCoord.y = fragCoord.y - layerHeight;\n        // I want the circles to be a little taller\n        circleCoord.y *= 0.96;\n\n        float sqrDistance = dot(circleCoord, circleCoord);\n        float sqrRadius = circleRadius * circleRadius;\n        float boundary = circleRadius + 1.0;\n        return vec4(color.rgb, color.a * smoothstep(boundary * boundary, sqrRadius, sqrDistance));\n    }\n}\n\nvec4 getChecker(vec2 fragCoord, float checkerCount, vec4 checkerColor1, vec4 checkerColor2, vec2 checkerSpeed)\n{\n    vec2 checkerCoord = floor((fragCoord / iResolution.x + checkerSpeed * -iTime) * checkerCount);\n    vec4 col = mix(checkerColor1, checkerColor2, mod(checkerCoord.x + checkerCoord.y, 2.0));\n    return col;\n}\n\nfloat sampleTriangleWave(float t, float width)\n{\n    return abs(mod(t, width) - width / 2.0);\n}\n\nvec4 getTriangle(vec2 fragCoord, float frequency, vec4 color, float height, float speed)\n{\n    float width =  iResolution.x / frequency;\n    float t = fragCoord.x - iTime * iResolution.x * speed;\n    \n    float waveHeight = sampleTriangleWave(t, width) + iResolution.y * height;\n    return vec4(color.rgb, color.a * smoothstep(waveHeight + 2.0, waveHeight, fragCoord.y));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    \n    vec4 checker = getChecker(fragCoord, checkerLayerCount, checkerLayerColor1, checkerLayerColor2, checkerLayerSpeed);\n    col = mix(col, checker.rgb, checker.a);\n    \n    vec4 bottomTriangle = getTriangle(fragCoord, triangleLayerFrequency, triangleLayerColor, triangleLayerHeight, triangleLayerSpeed);\n    col = mix(col, bottomTriangle.rgb, bottomTriangle.a);\n    \n    vec4 underLayer = getCurtain(fragCoord, underCircleCount, underLayerColor, underLayerScreenHeight, underLayerSpeed);\n    col = mix(col, underLayer.rgb, underLayer.a);\n    \n    vec4 topLayer = getCurtain(fragCoord, topCircleCount, topLayerColor, topLayerScreenHeight, topLayerSpeed);\n    col = mix(col, topLayer.rgb, topLayer.a);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lfSD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lfSD7", "name": "Interference Circles", "author": "badgerint", "description": "Colourful interference circles.", "tags": ["interference"], "likes": 2, "viewed": 108, "date": "1563133468", "time_retrieved": "2024-06-20T19:39:21.200669", "image_code": "float ring(vec2 pos, float size, float width, vec2 pixel) {\n\tfloat fa = 0.02;\n\treturn smoothstep(width, width * fa, abs(mod(distance(pixel,pos), size)-.5 * size));\t\n}\n\n//hsv2rgb by Sam Hocevar\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    float x1 = cos(iTime) * cos(iTime * 0.5);\n    float y1 = sin(iTime) * sin(iTime * 0.5);\n    \t\n    float x2 = cos(iTime - 1.) * sin(iTime * 0.5);\n    float y2 = sin(iTime - 1.) * cos(iTime * 0.5);\n        \n    col += ring(vec2(x1, y1), 0.15, 0.08, uv);\n    col += ring(vec2(x2, y2), 0.15, 0.08, uv);\n    \n    vec3 mixcolor1 = hsv2rgb(vec3(sin(iTime * 0.06),(uv.x * uv.y) + abs(sin(iTime * 0.1)), 1.0)) * .18;\n\n    vec3 fcol = mix(vec3(0.), col, mixcolor1);\n    fragColor = vec4(fcol * 5., 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lfSD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lfSDf", "name": "Union of Rainbow", "author": "ShaderPrankster", "description": "The conclusion to the dithering saga! (possibly)\n\nThey look like at any moment they'll all combine together and explode into fireworks.", "tags": ["raymarching", "rainbow", "dithering"], "likes": 3, "viewed": 386, "date": "1564436696", "time_retrieved": "2024-06-20T19:39:21.624858", "image_code": "float dither8x8(vec2 position, float brightness) {  \n  float limit = texture(iChannel0, position / iChannelResolution[0].xy).r;\n\n  return brightness < limit ? 0.0 : 1.0;\n}\n\n// SDFs and Smooth Union from http://iquilezles.org/\nfloat sdSphere( vec3 p, float s ){\n  return length(p)-s;\n}\n\nfloat sminCubic( float a, float b, float k ){\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n\nfloat intersect(vec3 point){\n    float fSphere = sdSphere(vec3(cos(iTime), 1.0, 5.0 + sin(iTime)) - point, 1.0);\n    float tSphere = sdSphere(vec3(cos(iTime * 1.2), 2.5, 5.0 + sin(iTime * 1.3)) - point, 0.7);\n    float dSphere = sdSphere(vec3(cos(iTime * 1.7), sin(iTime * 2.3), 5.0 + sin(iTime * 0.5)) - point, 0.3);\n    \n    float sphereRes = sminCubic(sminCubic(fSphere, tSphere, 0.4), dSphere, 0.4);\n\treturn sphereRes;\n}\n\nfloat march(vec3 rayOrigin, vec3 rayDirection){\n\tfloat minimumHit = 0.0;\n    \n    for(int i = 0; i < 100; i++){\n    \tvec3 hit = rayOrigin + rayDirection * minimumHit;\n        float dist = intersect(hit);\n        minimumHit += dist;\n        if(dist > 100.0 || dist < 0.01) break;\n    }\n    return minimumHit;\n}\n\nvec3 getNormal(vec3 point){\n\tfloat distPoint = intersect(point);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 norm = distPoint - vec3(intersect(point - e.xyy), intersect(point - e.yxy), \n                            \t intersect(point - e.yyx));\n    return normalize(norm);\n}\n\nfloat lightCalculate(vec3 lightPos, vec3 point){\n\tvec3 lightDirection = normalize(lightPos - point);\n    vec3 normal = getNormal(point);\n    float brightness = clamp(dot(normal, lightDirection), 0.0, 1.0);\n    \n    float shadowCatch = march(point + normal * 0.11, lightDirection);\n    if(shadowCatch < length(lightPos - point)) brightness *= 0.1;\n      \n    return brightness;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0);\n    \n    vec3 rayOrigin = vec3(sin(iTime), 1.5, -0.5);\n    vec3 rayDirection = normalize(vec3(uv,1));\n    \n    vec3 lightPos = vec3(1, 5, sin(iTime));\n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.0;\n    \n    float hitDist = march(rayOrigin, rayDirection);\n    vec3 hitPoint = rayOrigin + rayDirection * hitDist;\n    \n    vec3 scrollCol = vec3(cos(iTime + uv.y), sin(iTime + uv.y), 1.0);\n    col = scrollCol * dither8x8(fragCoord, lightCalculate(lightPos,hitPoint));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lfSDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lfSR7", "name": "Simple Cartesian Plane", "author": "badjano", "description": "Simple Cartesian Plane", "tags": ["2d", "plane", "function", "cartesian"], "likes": 6, "viewed": 147, "date": "1562356490", "time_retrieved": "2024-06-20T19:39:21.624858", "image_code": "float aafract(float x) {\n    float v = fract(x),\n          w = fwidth(x);\n    return v < 1.-w ? v/(1.-w) : (1.-v)/w;\n}\n\nfloat grid(float a)\n{\n    return aafract(a);\n}\n\nfloat line(float a)\n{\n    return clamp(abs(a)/fwidth(a),0.,1.);\n}\n\nfloat function(float x){\n    // this is where you change the function\n    return pow(x,x); // 0 powered by 0 is 1 :)\n}\n\nfloat draw(vec2 uv){\n    return line((function(uv.x)-uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - (iMouse.w < .5 ? iResolution.xy*.5 : iMouse.xy))/iResolution.y;\n\tuv *= sin(iTime)*10. + 13.; // zoom\n    float b = line(min(grid(uv.x),grid(uv.y)));\n    float c = line(min(abs(uv.x),abs(uv.y)));\n    fragColor = draw(uv) * vec4(c,b*c,1.,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lfSR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lfSz4", "name": "Alien brains", "author": "Artleet", "description": "Perlin noise with gradient defined by one number. Vector calculations variant.", "tags": ["noise", "perlin", "gradient", "vector", "calculations"], "likes": 11, "viewed": 258, "date": "1562169690", "time_retrieved": "2024-06-20T19:39:21.624858", "image_code": "float n(vec2 u){\n    vec4 d=vec4(.106,5.574,7.728,3.994),q=u.xyxy,p=floor(q);\n    ++p.zw;\n    q-=p;\n    p=fract(p*d.xyxy);\n    d=p+d.wzwz;\n\td=p.xxzz*d.ywyw+p.ywyw*d.xxzz;\n    p=fract((p.xxzz+d)*(p.ywyw+d));\n    p=cos(p*=iTime+d)*q.xxzz+sin(p)*q.ywyw;\n    q*=q*(3.-2.*q);\n    p=mix(p,p.zwzw,q.x);\n    return mix(p.x,p.y,q.y);\n}\n\nvoid mainImage(out vec4 o, in vec2 u){\n    u/=iResolution.y;\n\tfloat r=length(vec2(n(u*5.),n(u*7.)));\n\to=vec4(r+.01/r); \n}\n\n/*size hack (doesn't work on Safari and Edge (WebGL2 only))\n#define mainImage(c,p)\\\n\tvec2 u=p/iResolution.y;\\\n\tfloat r=length(vec2(n(u*5.),n(u*7.-2.5)));\\\n\tc=vec4(r+.01/r)\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lfSz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lfSzj", "name": "Triangle Trial", "author": "Nocks_on", "description": "my first shader.\ntriangle + rotate + scale + anti-alias", "tags": ["learning"], "likes": 3, "viewed": 208, "date": "1563476190", "time_retrieved": "2024-06-20T19:39:21.982400", "image_code": "#define PI 3.1415\n\nfloat triangle(vec2 r, vec2 center, float a) {\n    float ret = 1.;\n    float d = 0.005;\n    float x = r.x - center.x;\n    float y = r.y - center.y;\n    \n    float v1 = (sqrt(3.)*x - y + sqrt(3.)*a/3.)/2.;\n    float v2 = (-sqrt(3.)*x - y + sqrt(3.)*a/3.)/2.;\n    float v3 = y + sqrt(3.)*a/6.;\n    \n    ret *= smoothstep(-d, d, v1);\n    ret *= smoothstep(-d, d, v2);\n    ret *= smoothstep(-d, d, v3);\n    \n    return ret;\n}\n\nfloat interval(vec2 r, float T) {\n\tfloat x = mod(r.x, T);\n    float half_T = T/2.;\n    float d = 0.005;\n    float ret = 0.0;\n    if (x < d) {\n       ret = smoothstep(-d, d, x); \n    } else if (d <= x && x <= half_T-d) {\n        ret = 1.0;\n    } else if (half_T-d < x && x < half_T+d) {\n        ret = 1.0 - smoothstep(-d, d, x-half_T);\n    } else if (half_T+d <= x && x <= T-d) {\n        ret = 0.0;\n    } else if (T-d < x) {\n     \tret = smoothstep(-d, d, x-T);\n    }\n    return ret;\n}\n\nmat2 rotate(float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nmat2 scale(float s) {\n\treturn mat2(s, 0.0, 0.0, s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // position\n    vec2 r = (fragCoord.xy - 0.5*iResolution.xy)/ iResolution.y;\n\n    // color\n    float t = iTime;\n    float theta = t;\n    float s = sin(t);\n    vec2 r1 = r;\n    r1 *= scale(s);\n    r1 *= rotate(theta);\n    float val = triangle(r1, vec2(0., 0.), 0.7);\n    vec2 r2 = r;\n    r2 *= rotate(-theta/2.);\n    val *= interval(r2, 0.1); \n    vec3 col = vec3(clamp(val, 0.1, 0.9));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lfSzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lfXRM", "name": "random- ejemplo-v2", "author": "jorge2017a1", "description": "random- ejemplo-v1", "tags": ["random"], "likes": 3, "viewed": 73, "date": "1562334676", "time_retrieved": "2024-06-20T19:39:22.436973", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n/*void main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n\n    // Scale the coordinate system to see\n    // some noise in action\n    vec2 pos = vec2(st*5.0);\n\n    // Use the noise function\n    float n = noise(pos);\n\n    gl_FragColor = vec4(vec3(n), 1.0);\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t\n    vec2 pos = vec2(uv*5.0+iTime/0.50);\n    \n    pos.x = uv.x*5.0+iTime/0.50;\n    pos.y = uv.y+iTime/1.50;\n\n    // Use the noise function\n    float n = noise(pos);\n\n    //gl_FragColor = vec4(vec3(n), 1.0);\n    \n    \n    \n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    //fragColor = vec4(vec3(n)-col,1.0);\n    fragColor = vec4(vec3(n*col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lfXRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lfXW8", "name": "Ghost Chamber #13", "author": "audiopixel", "description": "Whisp forms", "tags": ["3d", "raymarching", "distancefield", "ghost"], "likes": 32, "viewed": 2531, "date": "1562652852", "time_retrieved": "2024-06-20T19:39:22.443061", "image_code": "// Created by Hepp Maccoy 2019, hepp@audiopixel.com | http://audiopixel.com\n// Distance functions by Inigo Quilez, iquilezles.org\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define PI 3.14159265358979323846\n\nvec3 glow;\nfloat d1;\nfloat t1;\nvec3 b_8(vec3 c1, vec3 c2){\n    return (c1 + c2) - (c1 * c2);\n}\n\nvec3 b_6(vec3 c1, vec3 c2){\n    return (c1 + c2) - 1.0;\n}\n\nfloat soc(vec3 p) {\n    vec3 n = normalize(sign(p+1e6));\n    return min(min(dot(p.xy, n.xy), dot(p.yz, n.yz)), dot(p.xz, n.xz));\n}\n\nfloat sinc(float x, float k) {\n    float a = PI * (float(k)*x-1.0);\n    return sin(a)/a;\n}\n\nmat2 r2d(float a) {\n    float sa=sin(a);\n    float ca=cos(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nvec2 mo(inout vec2 p, vec2 d) {\n    vec2 q = p;\n    q.x = abs(q.x) - d.x;\n    q.y = abs(q.y) - d.y;\n    if (q.y > q.x) q = q.yx;\n    return q;\n}\n\nfloat map(vec3 p) {\n    float d = 0.328;\n    float a = abs(p.y);\n    p.yz *= r2d(sign(a) * 5.6);\n    p.xz *= r2d(sign(a) * d1 * 4.2);\n    p.xz = mo(p.xz, vec2((-d1 * 29.8) - 1., -7.3676));\n    p.zx = mo(p.xz, vec2(8.4443, 4.0344));\n    p.xz = mo(p.xz, vec2(-12.9879, -9.1065));\n    p.zx = mo(p.zx, vec2(5.4177, 2.3984));\n    p.xz = max(abs(p.xz) - -8.7279, 10.023);\n    p.xz = mo(p.xz, vec2((d1 * 2.) - 4., -12.7982));\n    p.zx = mo(p.xz, vec2(-16.7502, -8.5611));\n    p.z = mod(p.z, -16.381445)-(-16.381445 *.5);\n    p.x = mod(p.x, 76.08105)-(76.08105 *.5);\n    p.y = mod(p.y + t1 * 21.2, 28.46435) - 5.;\n    p.zy = mo(p.zy, vec2(0.0, (d1 * 2.8)));\n    p.xz = mo(p.xz, vec2(0.0, 14.1212));\n    p.yx = mo(p.yx, vec2(2.3815, 0.5875));\n    d = min(d, soc(max(abs(p) - 1.3103, -0.9418)));\n    glow += vec3(0.8784314,0.8784314,0.8784314) * 0.0471 / (0.0539 + d*d);\n    return (length(p * -0.6424) - -0.7392) * 0.1944 - (d * -1.939);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    t1 = (iTime * .78) + 166.;\n    d1 = sin(t1 * .2);\n    vec2 st = (fragCoord.xy / iResolution.xy) * 2.1 - 1.;\n    st.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(st, 3.0);\n    vec3 rd = normalize(vec3(st + vec2(0.), -0.35938));\n    vec3 mp;\n    mp = ro;\n    float md;\n    for(int i=0; i<50; i++) {\n        md = map(mp);\n        mp += (rd * 0.5921) * md;\n    }\n    float b = length(ro - mp);\n    float dA = 1.6979 - (b * 0.1462) * -0.6102;\n    float dB = 0.9117 - (b * 0.1348) * -1.998;\n    dA = sinc(dA, 0.3252);\n    dB = sinc(dB, 0.2127);\n    float src1 = dA * -0.3094;\n    float src2 = dB * -1.0;\n    float src3 = dB * -1.0;\n    float src4 = dA * 0.4847;\n    vec3 c;\n    src1 *= 2.0;\n    src2 *= 0.9038;\n    c = b_6((mix(vec3(0.,0.5882353,1.0), vec3(0.0), src1) * 1.0),(mix(vec3(0.0), vec3(1.0,0.0,0.9411765), src2) * 1.211));\n    c = c * vec3(src3);\n    c = b_6(c,vec3(src4));\n    vec3 gt = c + (glow * 0.1);\n    c = b_8(c,gt);\n    fragColor = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lfXW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lfXzf", "name": "Elemental Ring slimy remix", "author": "fields37", "description": "This shader was inspired by https://www.shadertoy.com/view/MtBSWR. I wanted to do a 3d version.", "tags": ["raymarch"], "likes": 5, "viewed": 468, "date": "1563683278", "time_retrieved": "2024-06-20T19:39:24.382592", "image_code": "// Fork of \"Elemental Ring\" by otaviogood. https://shadertoy.com/view/MsVXDt\n// 2019-07-21 04:21:41\n\n/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// ---------------- Config ----------------\n// This is an option that lets you render high quality frames for screenshots. It enables\n// stochastic antialiasing and motion blur automatically for any shader.\n//#define NON_REALTIME_HQ_RENDER\nconst float frameToRenderHQ = 11.0; // Time in seconds of frame to render\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\n\n//#define MANUAL_CAMERA\n\n\n// --------------------------------------------------------\n// These variables are for the non-realtime block renderer.\nfloat localTime = 0.0;\nfloat seed = 1.0;\n\n// ---- noise functions ----\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\n\nconst float PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 matMin(vec2 a, vec2 b)\n{\n\tif (a.x < b.x) return a;\n\telse return b;\n}\n\n// ---- shapes defined by distance fields ----\n// See this site for a reference to more distance functions...\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\n// simple cylinder distance field\nfloat cyl(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nconst float TAU = 2.0 * PI;\n\nfloat glow = 0.0;\n// This is the function that makes the geometry.\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material number\nvec2 DistanceToObject(vec3 p)\n{\n    float time = localTime*2.0;\n    float cylRadBig = 1.0;\n    float cylRadSmall = 0.05;\n    float freq = 4.0;\n    float braidRad = 0.15;\n    float angle = atan(p.z, p.x);\n    float cylDist = length(p.xz) - cylRadBig;\n    vec3 cylWarp = vec3(cylDist, p.y, angle);\n    float amp = sin(angle + time) * 0.5 + 0.5;\n\n    float theta = angle*freq;\n    vec2 wave1 = vec2(sin(theta), cos(theta)) * braidRad;\n    wave1 *= amp;\n    //float d = length(cylWarp.xy + wave1) - cylRadSmall;\n    float d = sdBox(vec3(cylWarp.xy + wave1, 0.0), vec3(cylRadSmall));\n    float final = d;\n\n    theta = angle*freq + TAU / 3.0;\n    vec2 wave2 = vec2(sin(theta), cos(theta)) * braidRad;\n    wave2 *= amp;\n    //d = length(cylWarp.xy + wave2) - cylRadSmall;\n    d = sdBox(vec3(cylWarp.xy + wave2, 0.0), vec3(cylRadSmall));\n    final = smin(final, d, 0.1);\n\n    theta = angle*freq - TAU / 3.0;\n    vec2 wave3 = vec2(sin(theta), cos(theta)) * braidRad;\n    wave3 *= amp;\n    //d = length(cylWarp.xy + wave3) - cylRadSmall;\n    d = sdBox(vec3(cylWarp.xy + wave3, 0.0), vec3(cylRadSmall));\n    final = smin(final, d, 0.1);\n\n    vec2 matd = vec2(final, fract((angle+time) / TAU+0.5));\n    float sliver = cyl(cylWarp.xy, 0.03);\n    glow += 1.0 / (sliver * sliver * sliver * sliver + 1.0);\n    //sliver = max(sliver, abs(fract(cylWarp.z*freq-2.0*localTime)-0.5)-0.3);\n    matd = matMin(matd, vec2(sliver, -1.0));\n    return matd;\n}\n\n// Input is UV coordinate of pixel to render.\n// Output is RGB color.\nvec3 RayTrace(in vec2 fragCoord )\n{\n    glow = 0.0;\n\t// -------------------------------- animate ---------------------------------------\n\tvec3 camPos, camUp, camLookat;\n\t// ------------------- Set up the camera rays for ray marching --------------------\n    // Map uv to [-1.0..1.0]\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    float zoom = 2.2;\n    uv /= zoom;\n\n    // Camera up vector.\n\tcamUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0);\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0;\n\tfloat my=-iMouse.y/iResolution.y*10.0;\n#ifndef MANUAL_CAMERA\n    camPos = vec3(0.0);\n    camPos.y = sin(localTime*0.125)*3.0;\n    camPos.z = cos(localTime*0.125)*3.0;\n    camUp.y = camPos.z;\n    camUp.z = -camPos.y;\n    camUp = normalize(camUp);\n#else\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*3.0;\n#endif\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------- Ray march the scene ------------------------------\n\tvec2 distMat = vec2(1.0, 0.0);\n\tfloat t = 0.0 + Hash2d(uv)*1.6;\t// random dither glow by moving march count start position\n\tconst float maxDepth = 6.0; // farthest distance rays will travel\n\tvec3 pos = vec3(0,0,0);\n    const float smallVal = 0.000625;\n    float marchCount = 0.0;\n\t// ray marching time\n    for (int i = 0; i < 80; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        // Step along the ray.\n        pos = camPos + rayVec * t;\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        distMat = DistanceToObject(pos);\n\n        // Move along the ray.\n        // Leave room for error by multiplying in case distance function isn't exact.\n        t += distMat.x * 0.8;\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if ((t > maxDepth) || (abs(distMat.x) < smallVal)) break;\n\n        // Glow if we're close to the part of the ring with the braid.\n        float cyc = (-sin(distMat.y * TAU))*0.5+0.7;\n        // This function is similar to a gaussian fall-off of glow when you're close\n        // to an object.\n        // http://thetamath.com/app/y=(1)/((x*x+1))\n        marchCount += cyc / (distMat.x * distMat.x + 1.0);\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n    // Save off ray-march glows so they don't get messed up when we call the distance\n    // function again to get the normal\n\tfloat glowSave = glow;\n    float marchSave = marchCount;\n    marchCount = 0.0;\n    glow = 0.0;\n\n    // default to blueish background color.\n\tvec3 finalColor = vec3(0.09, 0.15, 0.35);\n\n\t// If a ray actually hit the object, let's light it.\n    if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n        vec3 normalU = vec3(distMat.x - DistanceToObject(pos - smallVec.xyy).x,\n                           distMat.x - DistanceToObject(pos - smallVec.yxy).x,\n                           distMat.x - DistanceToObject(pos - smallVec.yyx).x);\n\n        vec3 texColor = vec3(sin(iTime), 0.5, 0.1);\n        if (distMat.y < 0.0) texColor = vec3(0.6, 0.3, 0.1)*110.0;\n\n        finalColor = texColor;\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n\t}\n    // add the ray marching glows\n    finalColor += vec3(0.3, 0.5, 0.9) * glowSave*0.00625;\n    finalColor += vec3(1.0, 0.5, 0.3) * marchSave*0.05;\n\n    // vignette\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n\n\t// output the final color without gamma correction - will do gamma later.\n\treturn vec3(saturate(finalColor));\n}\n\n#ifdef NON_REALTIME_HQ_RENDER\n// This function breaks the image down into blocks and scans\n// through them, rendering 1 block at a time. It's for non-\n// realtime things that take a long time to render.\n\n// This is the frame rate to render at. Too fast and you will\n// miss some blocks.\nconst float blockRate = 20.0;\nvoid BlockRender(in vec2 fragCoord)\n{\n    // blockSize is how much it will try to render in 1 frame.\n    // adjust this smaller for more complex scenes, bigger for\n    // faster render times.\n    const float blockSize = 64.0;\n    // Make the block repeatedly scan across the image based on time.\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\n    // ugly bug with mod.\n    //float blockX = mod(frame, blockRes.x);\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\n    // Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef NON_REALTIME_HQ_RENDER\n    // Optionally render a non-realtime scene with high quality\n    BlockRender(fragCoord);\n#endif\n\n    // Do a multi-pass render\n    vec3 finalColor = vec3(0.0);\n#ifdef NON_REALTIME_HQ_RENDER\n    for (float i = 0.0; i < antialiasingSamples; i++)\n    {\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\n        // Set this to the time in seconds of the frame to render.\n\t    localTime = frameToRenderHQ;\n        // This line will motion-blur the renders\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\n        vec2 jittered = fragCoord.xy + vec2(\n            Hash21(fragCoord + seed),\n            Hash21(fragCoord*7.234567 + seed)\n            );\n        // don't antialias if only 1 sample.\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\n        // Accumulate one pass of raytracing into our pixel value\n\t    finalColor += RayTrace(jittered);\n        // Change the random seed for each pass.\n\t    seed *= 1.01234567;\n    }\n    // Average all accumulated pixel intensities\n    finalColor /= antialiasingSamples;\n#else\n    // Regular real-time rendering\n    localTime = iTime;\n    finalColor = RayTrace(fragCoord);\n#endif\n\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lfXzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lfXzS", "name": "RayMarchingBand002", "author": "Hirai_worthless", "description": "002", "tags": ["practice"], "likes": 1, "viewed": 56, "date": "1563379012", "time_retrieved": "2024-06-20T19:39:24.382592", "image_code": "float map(vec3 p){\n    p.xz *= mat2(cos(iTime),-sin(iTime)\n             ,sin(iTime),cos(iTime));\n\tfloat center = length(p) -1.0;\n    float left = length(p.yz - vec2(0.5,0)) - 0.5;\n    float right = length(p.yz - vec2(-0.5,0)) - 0.5;\n    float front = length(p.xy - vec2(0.5,0)) - 0.5;\n    float back = length(p.xy - vec2(-0.5,0)) - 0.5;\n    float mask = min(min(left,right),min(front,back));\n    return max(-mask,center);\n\n\n}\n\nfloat trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    for(int i = 0; i < 32; ++i){\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float PI = 3.14159265;\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv,1.0));\n    \n    vec3 o = vec3(0,0,-2.0);\n    float t = trace(o,r);\n    float fog = 1.0 / (1.0 + t * t * 0.2);\n    vec3 fc = vec3(fog);\n\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lfXzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3llSz7", "name": "MeshTube", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 17, "viewed": 238, "date": "1562466104", "time_retrieved": "2024-06-20T19:39:24.382592", "image_code": "#define PI acos(-1.0)\n#define TAU PI*2.0\n#define PITCH 23.0\n\nmat2 rotate(float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec3 rotate(vec3 p,vec3 axis,float theta)\n{\n    vec3 v = cross(axis,p), u = cross(v, axis);\n    return u * cos(theta) + v * sin(theta) + axis * dot(p, axis);   \n}\n\nvec3 hue(float t){\n    return cos((vec3(0,2,-2)/3.+t)*TAU)*.5+.5;\n}\n\nfloat lengthN(vec2 p, float n)\n{\n\tp = pow(abs(p), vec2(n));\n\treturn pow(p.x+p.y, 1.0/n);\n}\n\nfloat hash(float n)\n{\n    return fract(sin(n)*5555.5);\n}\n\nfloat smin(in float a, in float b, in float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k,0.0,1.0);\n    return mix(b,a,h)-k*h*(1.0-h);\n}\n\n// glslsandbox.com/e#37069.3 \nfloat deTetra(vec3 p, float r)\n{\n\tfloat g=0.577,s = 0.0;\n    float e=10.0;\n\ts+=pow(max(0.0,dot(p,vec3(-g,-g,-g))),e);\n\ts+=pow(max(0.0,dot(p,vec3(g,-g,g))),e);\n\ts+=pow(max(0.0,dot(p,vec3(g,g,-g))),e);\n\ts+=pow(max(0.0,dot(p,vec3(-g,g,g))),e);\n\ts=pow(s,1./e);\n\treturn s-r;\n}\n\nfloat deStellate(vec3 p,float r)\n{\n    float c=8.0;\n    p.xy-=0.5*PITCH;\n    vec3 seed = vec3(vec2(floor(p.xy/PITCH)),floor(p.z/c))+0.234;\n    p.z=mod(p.z,c)-0.5*c;\n    p.xy=mod(p.xy,PITCH)-0.5*PITCH;\n    p = rotate(p,\n        normalize(vec3(hash(seed.x),hash(seed.y),hash(seed.z))*2.0-1.0),\n        iTime*(1.3+hash(dot(seed,vec3(1,15,99)))*3.0)\n        );\n    return smin(deTetra(p,r),deTetra(-p,r),.1);\n}\n\nfloat deTube(vec3 p)\n{\n    p.xy-=0.5*PITCH;\n    vec2 seed=floor(p.xy/PITCH);\n    float z = p.z+iTime*5.+hash(dot(seed,vec2(1,50)))*50.0;\n\tp.z -= iTime*5.0;\n    p.y-=sin(z*0.15+0.6*sin(z*.5))*1.2;\n    p.x-=cos(z*0.12+0.5*cos(z*.3))*1.2;  \n    p.xy=mod(p.xy,PITCH)-0.5*PITCH;\n    \n    float de =1e9,num=7.0;\n    for(float i=-1.0;i<2.0;i+=2.0)\n    {\n        vec3 q=p;\n      \tq.xy *= rotate((smoothstep(-1.0,1.0,(mod(q.z,3.0)-1.5))+floor(q.z/3.0))*PI/num*i);\n    \tfloat a = mod(atan(q.x,q.y),TAU/num)-0.5*TAU/num;\n        q.xy = length(q.xy)*vec2(sin(a),cos(a));\n\t  \tq.y -= 3.0;\n    \tde= smin(de,lengthN(q.xy,5.0)-0.15,0.1);\n    }\n    return de*0.8;\n}\n\nvec3 transform(vec3 p)\n{\n    float c= 26.0;\n    float it = floor(iTime/c);\n    float t = mod(iTime, c);\n    t -= clamp(t, 0.0, 5.0);\n    p = rotate(p,normalize(vec3(1,hash(it)*2.0-1.0,1)),t*0.3);\n    return p;\n}\n\nfloat map(vec3 p)\n{\n    p = transform(p);\n    return min(deTube(p),deStellate(p,0.6));  \n }\n\nvec3 calcNormal(vec3 pos){\n  vec2 e = vec2(1,-1) * 0.002;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n\nvec3 doColor(vec3 p){\n    p = transform(p);\n    if (deStellate(p,0.6)<0.001) return hue(0.0);\n    return hue(0.05)*0.5;\n }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 18.0);\n \tvec3 rd = normalize(vec3(uv, -3));\n\tvec3 col = clamp((hue(0.6)+0.2)*0.4*length(uv),0.0,1.0);\n\tfloat t = 0.0, d;\n \tfor(int i = 0; i < 128; i++)\n  \t{\n    \tt += d = min(map(ro + rd * t),1.0);\n    \tif(d < 0.001) break;\n  \t}\n  \tif(d < 0.001)\n  \t{\n\t  \tvec3 p = ro + rd * t;\n\t \tvec3 nor = calcNormal(p);\n    \tvec3 li = normalize(vec3(1));\n        vec3 bg = col;\n        col = doColor(p);\n        col *= clamp(dot(nor, li), 0.3, 1.0);\n        col *= max(0.5 + 0.5 * nor.y, 0.0);\n        col += pow(clamp(dot(reflect(rd, nor), li), 0.0, 1.0), 80.0);\n        col = clamp(col,0.0,1.0);\n        col = mix(bg, col, exp(-t*t*0.0001));\n  \t\tcol = pow(col, vec3(0.9));        \n    }\n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3llSz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3llSz8", "name": "Simple sines", "author": "nkaretnikov", "description": "Simple sines.", "tags": ["2d", "sin", "sine"], "likes": 0, "viewed": 271, "date": "1562505872", "time_retrieved": "2024-06-20T19:39:24.382592", "image_code": "// Public domain.\n\n// Colors.\nconst vec3 black = vec3(0.);\nconst vec3 red   = vec3(1., 0., 0.);\nconst vec3 green = vec3(0., 1., 0.);\nconst vec3 blue  = vec3(0., 0., 1.); \n\n// Smooth sine.\nvec3 sSin(\n    vec3 color,\n    float x, float y, float pos, float width, float blur,\n    float amp, float freq, float speed)\n{   \n    pos = pos - (width / 2.);  // move the center in between two 'sin's\n    float t = x * freq + iTime * speed;\n    float f = amp * sin(t);\n    float inter = y;  // value for interpolation\n    \n    // XXX: Need to find a parallel curve to the sine wave to make it\n    // look good with 'freq' > 1.\n    // https://en.wikipedia.org/wiki/Parallel_curve\n    \n    float res = smoothstep(\n        pos        - f,\n        pos + blur - f,\n        inter);\n    res -= smoothstep(\n        pos + width - blur - f,\n        pos + width        - f,\n        inter);\n\n    return res * color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1).\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Move 0.0 to the center.\n    uv -= .5;\n    \n    // Account for the screen ratio.\n    uv.x *= iResolution.x / iResolution.y;  \n    \n    // Output color.\n    vec3 color = black;\n      \n    color += blue;\n    \n    float pos   = 0.;\n    float width = .1;\n    float blur  = .01;\n    float amp   = .45;\n    float freq  = sin(iTime * .5) * 10.;\n    float speed = 4.;\n    \n    // Horizontal sine.\n    color -= sSin(blue - red,\n                  uv.x, uv.y, pos, width, blur, amp, freq, speed);\n    // Vertical sine.\n    color -= sSin(blue + red - green,\n                  uv.y, uv.x, pos, width, blur, amp, freq, speed);    \n    \n    // Circles:    uv.x * uv.x, uv.y * uv.y\n    // Hyperbolas: uv.x * uv.y, uv.x * uv.y                  \n\n    // Output to screen.\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "public-domain", "thumbnail": "https://www.shadertoy.com/media/shaders/3llSz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3llXDN", "name": "Exploring sets of julia fractals", "author": "Veggiebob", "description": "x and y used to compute a julia set at the seed (sin(iTime), z)\nsee line 44", "tags": ["3d", "fractal", "julia"], "likes": 1, "viewed": 60, "date": "1562998868", "time_retrieved": "2024-06-20T19:39:24.382592", "image_code": "#define MAX_ITERS 10\n#define MAX_STEPS 512\nvec3 sq3 (vec3 v) {\n    return vec3(\n        v.x*v.x-v.y*v.y-v.z*v.z,\n        2.*v.x*v.y,\n        2.*v.x*v.z\n    );\n}\nvec2 sq (vec2 v) {\n    return vec2(\n        2.*v.y*v.x,\n        v.y*v.y-v.x*v.x\n    );\n}\nfloat squishy (float x) {\n    return x*x*x;\n}\nfloat julia (vec3 p, vec3 c) {\n    vec3 k = p;\n    for(int i = 0; i<MAX_ITERS; i++) {\n        k = sq3(k) + c;\n        if(length(k)>10.) return 1.-squishy(float(i)/float(MAX_ITERS));\n    }\n    return -0.01;\n}\nvec2 rotate2D (vec2 p, float angle){\n    return vec2(p.x*cos(angle)-p.y*sin(angle), p.y*cos(angle)+p.x*sin(angle));\\\n}\nfloat mandelbrot (vec2 uv, vec2 c, float iters) {\n    vec2 k = uv;\n    for(float i = 0.; i<iters; i++) {\n        k = sq(k)+c;\n        if(length(k)>10.) return 1.-squishy(float(i)/iters);\n    }\n    return -1.;\n}\nfloat sdf (vec3 p) {\n    /*\n  \tvec3 r = p;\n    r.xz = rotate2D(r.xz, iTime*0.3);\n    r.yz = rotate2D(r.yz, iTime*0.1);\n*/\n    return mandelbrot(p.xy, vec2(sin(iTime)*1., p.z), 16.);\n    /*\n    return julia(p,\n                 \n                 vec3(sin(iTime*0.3)*0.7, cos(iTime*0.4)*0.7, 0.1)\n    );\n*/\n    //return length(p)-1.;\n}\nvec4 trace (vec3 o, vec3 r) {\n    vec3 p = o;\n    float t = 0.;\n    float s;\n    int i;\n    for(i = 0; i<MAX_STEPS; i++) {\n        p = o+r*t;\n        s = sdf(p);\n        t+=s*0.01;\n\t\tif(abs(s)<0.001||t>20.) break;\n    }\n    return vec4(p, float(i));\n}\nconst float E = 0.1;\nvec3 estimateNormal (vec3 p) {\n    return normalize(vec3(\n        sdf(vec3(p.x+E, p.y, p.z))-sdf(vec3(p.x-E, p.y, p.z)),\n        sdf(vec3(p.x, p.y+E, p.z))-sdf(vec3(p.x, p.y-E, p.z)),\n        sdf(vec3(p.x, p.y, p.z+E))-sdf(vec3(p.x, p.y, p.z-E))\n    ));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse-=0.5;\n    float aspect = iResolution.y/iResolution.x;\n    uv.x/=aspect;\n    mouse.x/=aspect;\n    vec3 cam = vec3(0., 0., -3.);\n    vec3 ray = normalize(vec3(uv.xy*1.3, 1.));\n    \n    vec3 rot = vec3(mouse.y*5., -mouse.x*3., 0.);\n    \n    cam.xz = rotate2D(cam.xz, rot.y);\n    ray.xz = rotate2D(ray.xz, rot.y);\n    \n    cam.zy = rotate2D(cam.zy, rot.x);\n    ray.zy = rotate2D(ray.zy, rot.x);\n    \n    \n    vec4 t = trace(cam, ray);\n    vec3 e = t.xyz;\n    vec3 light = vec3(0., 10., -10.);\n    vec3 toLight = normalize(light-e);\n    vec3 norm = estimateNormal(e);\n    float diffuse = max(0.,dot(toLight, norm))*0.8;\n    vec3 refl = reflect(ray, norm);\n    float specular = pow(max(0.0, dot(refl, toLight)), 4.0)*0.5;\n    float d = length(e-cam);\n    float fog = 1.0 / (1.0 + d*d*0.01);\n    \n    vec3 col = vec3(1.);//texture(iChannel0, refl).rgb*1.+0.8;\n    col -= pow(t.w/float(MAX_STEPS), 2.)*0.8;//ao\n    col *= (diffuse+specular)*0.+0.8;//other light\n    col = 0.01+(col-0.01)*3.6;\n    col *= fog;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3llXDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3llXDS", "name": "ParallelHole", "author": "Hirai_worthless", "description": "transporter", "tags": ["raymarching"], "likes": 2, "viewed": 79, "date": "1564111457", "time_retrieved": "2024-06-20T19:39:24.388707", "image_code": "float PI = 3.14159265;\nfloat time(){\n\treturn iTime;\n}\n\nfloat map(vec3 p){\n    p.y = -abs(p.y);\n    p.xz *= mat2(cos(time()),-sin(time())\n         ,sin(time()),cos(time()));\n\tfloat fl = p.y + 0.5;\n    float bigHole = length(p.xz) - 1.0;\n    float holes = 1000000.0;\n    for(float i = 0.0; i < 6.0; i += 1.0){\n    \tholes = min(holes,length(p.xz - vec2(cos(i * PI / 3.0),sin(i * PI / 3.0)) * 1.5) - 0.3);\n    }\n    float h = min(bigHole,holes);\n    return max(fl,sin(time() * 2.0)*h);\n    \n\n\n}\n\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 64; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return vec4(getNormal(p),t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float PI = 3.14159265;\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv,1.2));\n    \n    vec3 o = vec3(0,0,-2.5);\n    vec4 data = trace(o,r);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    vec3 fc = mix(vec3(0.5 - data.x,0.5 -data.y,0.5-data.z),vec3(1.0),1.0 - fog);\n\tfc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3llXDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3llXR4", "name": "Hyperbolic Truchet tiles", "author": "mattz", "description": "{4, 5} Truchet tiling of the hyperbolic plane in the Poincaré disk model. Click left of circle to auto-rotate, inside circle to scroll, right of circle to center. LMB down = B&W coloring", "tags": ["truchet", "hyperbolic"], "likes": 42, "viewed": 957, "date": "1562351779", "time_retrieved": "2024-06-20T19:39:26.673815", "image_code": "// \"Hyperbolic Truchet tiles\" by mattz\n// Licence https://creativecommons.org/licenses/by-nc/3.0/us/\n//\n// Combining my love of Truchet tiling with my newfound \n// interest in hyperbolic geometry.\n\n#define RED vec3(0.8, 0, 0)\n#define BLUE vec3(0, 0, 0.8)\n#define BLACK vec3(0)\n#define WHITE vec3(1)\n#define LIGHTGRAY vec3(.8)\n#define LIGHTRED vec3(0.9, 0.5, 0.5)\n#define LIGHTBLUE vec3(0.5, 0.5, 0.9)\n\n#define PI 3.141592653589793\n\nconst vec4 NO_INTERSECT = vec4(-1e5);\n\nconst float TOL = 1e-5;\nconst float TOL_SQR = TOL*TOL;\n\n//////////////////////////////////////////////////\n// geometric utility functions\n\n// are two points on the same diameter of the unit circle?\nbool alongDiameter(vec2 p, vec2 q) {\n   \n    vec4 pq = abs(vec4(p, q));\n    float m = max(max(pq.x, pq.y), max(pq.z, pq.w));\n    \n    float k = abs(p.x*q.y - p.y*q.x);\n    \n    return k < TOL*m;\n    \n}\n\n// are two points the same length?\nbool sameLength(float pp, float qq) {\n    return abs(pp - qq) < TOL*max(pp, qq);\n}\n\n// rotate by 90 degrees\nvec2 perp(vec2 p) {\n    return vec2(-p.y, p.x);\n}\n\n// circle centered at center containing point p\nvec3 compass2D(vec2 ctr, vec2 p) {\n    vec2 diff = p - ctr;\n    return vec3(ctr, dot(diff, diff));\n}\n\n// Construction 1.2: invert a point through a circle\nvec2 invertPC(vec2 p, vec3 c) {\n    vec2 po = p - c.xy;    \n    return c.xy + po * c.z / dot(po, po);\n}\n\n//////////////////////////////////////////////////\n// hyperbolic geometry functions\n\n// distance from a point to a line or circle\nfloat geodesicDist(vec3 l, vec2 p) {\n\tif (l.z > 0.0) {\n\t\treturn length(p-l.xy) - sqrt(l.z);\n\t} else {\n\t\treturn dot(normalize(l.xy), p);\n\t}\n}\n\n// special case of Construction 1.6 for unit circle\nvec3 geodesicFromPole(vec2 p) {\n    float h2 = dot(p, p);\n    float r2 = (h2 - 1.);\n    return vec3(p, r2);\n}\n\n// Polar of a point p about the unit circle\n// 2D line passing thru the midpoint of p and its inverse, perp. to p.\nvec3 polarFromPoint(vec2 p) {\n    return vec3(p, -0.5*dot(p, p) - 0.5);\n}\n\n// invert point about geodesic (either arc or line)\nvec2 reflectPG(vec2 p, vec3 c) {\n    if (c.z == 0.) {\n        return p - (2.*dot(p, c.xy))*c.xy;\n    } else {\n        return invertPC(p, c);\n    }\n}\n\n// Construction 2.2: geodesic from polars of points\nvec3 geodesicFromPoints(vec2 p, vec2 q) {\n    \n    if (alongDiameter(p, q)) {\n        vec2 n = normalize(perp(p - q));\n        return vec3(n, 0);\n    }\n\n    vec3 ppolar = polarFromPoint(p);\n    vec3 qpolar = polarFromPoint(q);\n    vec3 inter = cross(ppolar, qpolar);\n\n    return compass2D(inter.xy/inter.z, p);\n    \n}\n\n\n// return a geodesic passing thru p perpendicular to the diameter\n// through p - undefined if p == (0, 0)\nvec3 geodesicPerpTo(vec2 p) {\n    \n    float a2 = dot(p, p);\n    float x = a2 + 1.;\n    \n    float h_over_a = x / (2.*a2);\n    float h2 = 0.5*x*h_over_a;\n    \n    vec2 c = p * h_over_a;\n    \n    return vec3(c, (h2 - 1.));\n    \n}\n\n// Construction 2.3: hyperbolic compass. \n// construct hyperbolic circle with center p that passes thru q\nvec3 hyperbolicCompass(vec2 p, vec2 q) {\n    \n    float pp = dot(p, p);\n    float qq = dot(q, q);\n    \n    if (pp < TOL_SQR) {\n        return vec3(p, (qq));\n    } \n    \n    if (alongDiameter(p, q)) {\n        vec3 pperp = geodesicPerpTo(p);\n        vec2 qp = invertPC(q, pperp);\n        vec2 qmid = 0.5*(q + qp);\n        return compass2D(qmid, q);\n    }\n    \n    // get polars of p and q\n    vec3 ppolar = vec3(p, -0.5*pp - 0.5);\n    vec3 qpolar = vec3(q, -0.5*qq - 0.5);\n    \n    // homogeneous coords of pole of geodesic pq\n    vec3 pole = cross(ppolar, qpolar);\n    \n    // this is the direction from point q to the pole\n    vec2 dqpole = pole.xy - pole.z*q; \n    \n    // 2D line tangent to geodesic pq at q\n    vec3 lq = vec3(dqpole, -dot(dqpole, q));\n    \n    // 2D line containing p and the origin\n    vec3 lp = vec3(perp(p), 0);\n    \n    // homogeneous coords of intersection of these lines\n    vec3 rval = cross(lq, lp);\n    \n    // return circle\n    return compass2D(rval.xy/rval.z, q);\n    \n}\n\n\n// Construction 3.1: Perpendicular bisector\nvec3 hyperbolicBisector(vec2 p, vec2 q) {\n\n    float pp = dot(p, p);\n    float qq = dot(q, q);\n    \n    if (pp < TOL_SQR) { \n        \n        // p is at origin\n        float h2 = 1.0/qq;\n        return vec3(q*h2, (h2 - 1.));\n       \n    } else if (qq < TOL_SQR) { \n        \n        // q is at origin                \n        float h2 = 1.0/pp;\n        return vec3(p*h2, (h2 - 1.));\n        \n    } else if (sameLength(pp, qq)) {\n        \n        // p and q are same length, return the diameter\n        return vec3(normalize(p - q), 0);\n        \n    }\n    \n    // this remarkably small piece of code reflects the following algebra:\n    //\n    // let d = q - p be the difference between p & q\n    // let x be the pole of the bisector\n    //\n    // since the pole of the bisector is on the line from p to q, we know\n    //\n    //   x = p + k*d\n    //\n    // for some unknown k with abs(k) > 1 (because the pole isn't between p & q)\n    //\n    // now let's try to solve for k.\n    //\n    // we know that since the pole x is orthogonal to the unit circle, \n    // the radius of the bisector circle is governed by\n    //\n    //   r^2 = ||x||^2 - 1\n    //       = ||p + k*d ||^2 - 1\n    //       = p.p + 2k*p.d + k^2*d.d\n    //\n    // also since p and q are inverted through the bisector circle with radius\n    // r we know\n    //\n    //   r^2 = || x-p || * || x-q || = ||d|| * || k*d - d ||\n    //       = k*(k-1)*d.d \n    //\n    // now we can set the two equations equal and solve for k\n\n    vec2 d = q - p;\n    float k = (1.0 - dot(p,p))/(dot(d,d) + 2.0*dot(p,d));\n    \n    return geodesicFromPole( p + k*d );\n    \n}\n\n// hyperbolic translation to move the origin to point m\nvec2 hyperTranslate(vec2 uv, vec2 m) {\n\n    float mm = dot(m, m);\n    if (mm < TOL_SQR || mm >= 1.) { return uv; }\n\n    vec3 g1 = hyperbolicBisector(vec2(0), m);\n\n    vec2 diff = uv.xy - g1.xy;\n    float k = g1.z / dot(diff, diff);\n    uv.xy = g1.xy + k*diff; \n\n    vec2 n = m / sqrt(mm);\n    uv.xy -= 2.*dot(uv.xy, n)*n;\n    \n    return uv;\n    \n}\n\n// return scalar whose sign indicates side of g that p is on\nfloat sidePG(vec2 p, vec3 g) {\n    if (g.z == 0.) {\n        return dot(p, g.xy);\n    } else {\n        p -= g.xy;\n        return dot(p, p) - g.z;\n    }\n}\n\n// return true if p & q both on the same side of l \nbool sameSide(vec2 p, vec2 q, vec3 l) {\n    return sidePG(p, l) * sidePG(q, l) >= 0.;    \n}\n\n\n\n///////////////////////////////////////////////////\n// utility functions for drawing:\n\n// mix src into dst by smoothstepping k with threshold d\nvoid ink(inout vec3 colorOut, vec3 src, float inkDist) {\n    \n    colorOut = mix(src, colorOut, smoothstep(0.0, 1.0, inkDist));\n    inkDist = 1e5;\n    \n}\n\n// draw either line or circle (using geodesicDist above)\nfloat drawLine(vec3 l, vec2 p, float lineWidth) {\n    return (abs(geodesicDist(l, p.xy))-lineWidth);\n}\n\nfloat drawPoint(vec2 x, vec2 p, float pointSize) {\n    return (length(p - x)-pointSize);\n}\n\n\n// From Dave Hoskins' \"Hash without sine\"\n// https://www.shadertoy.com/view/4djSRW \nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 colorOut = WHITE;\n    \n    const float diam = 2.0;\n        \n    float kAlt = step(0.1, max(iMouse.z, iMouse.w));\n\n    float rmax = max(iResolution.x, iResolution.y);\n    float rmin = min(iResolution.x, iResolution.y);\n\n    float csize = (rmin * 0.98);\n            \n    float px = diam / csize;\n    float invPx = csize / diam;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy) * px;\n    \n    const vec3 unitCircle = vec3(0, 0, 1);\n    \n    if (dot(uv, uv) < 1.) {\n\n        // setup 4, 5, 2 triangle\n\n        vec2 verts[3];\n        vec3 edges[3];\n\n        const float cospi5 = 0.8090169943749475; // cos(pi/5)\n        const float sinpi5 = 0.5877852522924731; // sin(pi/5)\n        const float sqrt22 = 0.7071067811865476; // sqrt(2)/2\n\n        float f = sqrt(2./(cospi5*cospi5 - sinpi5*sinpi5));\n\n        float k = (sqrt22*cospi5 - sqrt22*sinpi5)*f;\n\n        float bsz = (cospi5 - sqrt22)*f;\n\n        verts[0] = vec2(0);\n        verts[1] = vec2(k, 0);\n        verts[2] = vec2(0, k);\n        \n        vec2 mid = bsz*vec2(sqrt22, sqrt22);\n        \n        edges[0] = geodesicFromPoints(verts[1], verts[2]);\n        edges[1] = vec3(1, 0, 0);\n        edges[2] = vec3(0, 1, 0);\n\n        vec2 m = (iMouse.xy - 0.5*iResolution.xy) * px;\n        bool scroll = false;\n\n\n        if (dot(m, m) < 0.95) {\n            scroll = true;\n        } else if (m.x < 0.) {\n            float t = iTime*PI/10.0;\n            float r = 0.5*smoothstep(0.0, 4.0, iTime);\n            m = r*vec2(cos(t), sin(t));\n            scroll = true;\n        } else {\n            m = vec2(0);\n        }\n        \n        if (scroll) {\n            for (int i=0; i<3; ++i) {\n                verts[i] = hyperTranslate(verts[i], -m);\n            }\n            for (int i=0; i<3; ++i) {\n                int j = (i+1)%3;\n                int k = 3-i-j;\n                edges[i] = geodesicFromPoints(verts[j], verts[k]);\n            }\n            mid = hyperTranslate(mid, -m);\n        }\n        \n        bool done = false;\n\n        for (int iter=0; iter<32; ++iter) {\n\n            if (done) { continue; }\n\n            int i = 0;\n\n            if (!sameSide(uv, verts[0], edges[0])) {\n                i = 0;\n            } else if (!sameSide(uv, verts[1], edges[1])) {\n                i = 1;\n            } else if (!sameSide(uv, verts[2], edges[2])) {\n                i = 2;\n            } else {\n                done = true;\n                continue;\n            }\n\n            int j = (i+1)%3;\n            int k = 3-i-j;\n\n            mid = reflectPG(mid, edges[i]);\n            verts[i] = reflectPG(verts[i], edges[i]);\n            edges[j] = geodesicFromPoints(verts[i], verts[k]);\n            edges[k] = geodesicFromPoints(verts[i], verts[j]);\n            \n        }\n        \n        float ds = 1.0 - dot(uv, uv);\n\n        vec2 ctr = hyperTranslate(verts[0], m);\n        vec2 seed = floor(12.*ctr + 0.5) + 19.;\n                \n        float r = hash12(seed);\n        \n        float lw = 0.02*ds;\n        float cw = 0.05*ds;\n        float pw = 0.08*ds;\n        \n        float bdist = drawLine(edges[2], uv, lw);\n        float rdist = drawLine(edges[1], uv, lw);\n        \n        float cdist;\n        \n        vec3 altColor;\n                \n        if (r > 0.5) {\n            \n            vec3 c = hyperbolicCompass(verts[1], mid);\n            \n            float d = geodesicDist(c, uv);\n            \n            altColor = mix(BLACK, WHITE, smoothstep(-0.5*px, 0.5*px, d));\n            \n            \n            cdist = drawLine(c, uv, cw);\n            ink(colorOut, LIGHTBLUE, bdist*invPx);\n            ink(colorOut, LIGHTRED, rdist*invPx);\n            \n            \n        } else {\n            \n                        \n            vec3 c = hyperbolicCompass(verts[2], mid);\n            \n            float d = geodesicDist(c, uv);\n            \n            altColor = mix(WHITE, BLACK, smoothstep(-0.5*px, 0.5*px, d));\n            \n            cdist = drawLine(c, uv, cw);\n            ink(colorOut, LIGHTRED, rdist*invPx);\n            ink(colorOut, LIGHTBLUE, bdist*invPx);\n            \n        }\n        \n        ink(colorOut, BLACK, cdist*invPx);\n        ink(colorOut, BLUE, drawPoint(verts[1], uv, pw)*invPx);\n        ink(colorOut, RED, drawPoint(verts[2], uv, pw)*invPx);\n        \n        colorOut = mix(colorOut, altColor, kAlt);\n\n    }\n    \n    ink(colorOut, BLACK, drawLine(unitCircle, uv, 0.5*px)*invPx);\n    \n    colorOut = sqrt(colorOut);\n    \n    fragColor = vec4(colorOut, 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3llXR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3llXzl", "name": "Sharper Marching", "author": "Taron", "description": "This is finally the test I wanted to do after Flopine's workshop. A sort of dynamic ray marching, which will result in much sharper definition at the same amount of steps. Not ideal and lots to experiment with, but hey... still day 1 for me with all this.", "tags": ["raymarching", "stepsubdivision"], "likes": 1, "viewed": 169, "date": "1563932784", "time_retrieved": "2024-06-20T19:39:26.679893", "image_code": "/*---------------------------------------------------------------\nI dare not comment anything in this one, yet. But in case someone \nbelieves I know what I'm doing and wants to know it, too, \njust let me know!\n---------------------------------------------------------------*/\nconst float radius = 0.3;\nfloat sRadius;\n\nfloat sphere(vec3 p, float radius)\n{\n  return length(p)-radius;\n}\nfloat box(vec3 p, vec3 c)\n{\n  vec3 q = abs(p)-c;\n  return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat map(vec3 p)\n{\n    float pz = p.z+iTime;\n    p.x += sin(pz);\n    p.y += cos(pz);\n    p = mod(p,2.)-1.;\n    return min(max(box(p,vec3(radius)),-sphere(p,sRadius)),sphere(p,sRadius*0.7));\n    //return mix(box(p,vec3(0.25)),sphere(p+vec3(cos(iTime)*.25,0.,sin(iTime)*0.05),.3+.25*sin(iTime*1.5)*0.5),sin(pz*3.33+iTime*.05));\n}\n\nvec3 getNormal(vec3 p)\n{\n  vec2 o = vec2(0.001, 0.);\n  return normalize(vec3(  map(p+o.xyy)-map(p-o.xyy),\n                          map(p+o.yxy)-map(p-o.yxy),\n                          map(p+o.yyx)-map(p-o.yyx)));\n}\n\nvec3 lighting(vec3 n, vec3 light)\n{\n    float lit = dot(n, light);\n    float sub = max(0.,0.5+0.5*lit);\n    vec3 col = vec3(max(0.,lit))+sub*vec3(0.4,0.1,0.1);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tfloat time = iTime;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(sin(time*1.45)*0.1,5.*(cos(time*0.25)),time);\n    vec3 p = ro;\n    vec3 rd = vec3(uv.xy*(0.25+0.75*length(uv.xy)),0.75);\n    rd = normalize(rd);\n\n    vec3 light = normalize(vec3(sin(time), cos(time), sin(time*0.25)));\n    vec3 bgColor = mix(vec3(0.7,0.2,0.6),vec3(0.1,0.05,0.2),length(uv));\n\n    bool hit = false;\n    float shading = 0.;\n    vec3 color = bgColor;\n  \n    sRadius = radius*1.3+sin(iTime)*radius*0.25;\n    \n    rd *= 0.25;\n    int i = 0;\n    p+=vec3(uv.xy,1.);\n    float dd;\n    while(i<100)\n    {\n        float d = map(p);\n        if(d<0.01)\n        {\n            hit = true;\n            \n            if(d<0.001)\n                break;\n            \n            p-=rd*dd;\n            rd *=0.5;\n        }\n        dd = d;\n        p+=rd*d;\n      \ti++;\n     }\n\n    if(hit)\n    {\n        vec3 norm = getNormal(p);\n        float fog = min(1.0, 0.09*length(p-ro));\n        color = mix(lighting(norm, light),bgColor,fog);\n    }\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3llXzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lsSD4", "name": "VoroHearts Slower by MeDope", "author": "dynamitedjs", "description": "VoroHearts Slower by MeDope, I just needed a slower version", "tags": ["bluehearts"], "likes": 2, "viewed": 307, "date": "1562942322", "time_retrieved": "2024-06-20T19:39:26.679893", "image_code": "#define t iTime\n\nvec2 hash22(vec2 p) \n{\n    return fract(sin(vec2(dot(p,vec2(263.135,198.742)),dot(p,vec2(624.235,321.217))))*13.635); \n}\n\nfloat vorohearts( vec2 x)\n{\n    vec2 n = floor(-x);\n    vec2 f = fract(-x);\n    \n\tfloat md = 1.0;\n    \n    for( int j=-1; j<=1; j++ )\n\t{\n    \tfor( int i=-1; i<=1; i++ )\n    \t{\n        \tvec2  g = vec2(float(i), float(j));\n        \tvec2  o = hash22( n + g );\n\t    \tvec2  r = g - f + (.2+.2*sin(t+o*6.28));\n    \t\tr.x *= .8*(1.+sin(.5+sin(6.*t))*.03);\n    \t\tr.y *= .95+sin(1.5+sin(3.*t))*.07;\n    \t\tr.y += .08;\n\t\t\tr.y -= sqrt(abs(r.x))*.52;\n    \t\tfloat d = length(r);\n        \tif( d < md ) {md = d;}\n    \t}\n    }\n    return md;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    //Heart uv\n    uv = uv*3.;\n\tfloat d = vorohearts(uv);\n    d = smoothstep(.58, .25, d);\n    \n    //Heart color\n    vec3 p = vec3(1.6*d*(.6+sin(.5+sin(6.*t))*.1), d*(1.8+sin(.5+sin(6.*t))*.3), 2.1*(1.+sin(.5+sin(6.*t))*.3));\n    vec3 col = vec3(d) * p;\n    \n    //Background\n    col += vorohearts(uv) * .35 * p;\n    \n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lsSD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lsSR7", "name": "Explosive Turbulent Noise", "author": "OctopusX", "description": "Just playing with FBMs", "tags": ["noise", "fbm", "explosion"], "likes": 31, "viewed": 605, "date": "1562463894", "time_retrieved": "2024-06-20T19:39:27.176898", "image_code": "#define UVScale \t\t\t 0.4\n#define Speed\t\t\t\t 0.6\n\n#define FBM_WarpPrimary\t\t-0.24\n#define FBM_WarpSecond\t\t 0.29\n#define FBM_WarpPersist \t 0.78\n#define FBM_EvalPersist \t 0.62\n#define FBM_Persistence \t 0.5\n#define FBM_Lacunarity \t\t 2.2\n#define FBM_Octaves \t\t 5\n\n\n\n//fork from Dave Hoskins\n//https://www.shadertoy.com/view/4djSRW\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx) * vec4(1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n\treturn -1.0 + 2.0 * fract(vec4(\n        (p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y,\n        (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x)\n    );\n}\n\n//offsets for noise\nconst vec3 nbs[] = vec3[8] (\n    vec3(0.0, 0.0, 0.0),vec3(0.0, 1.0, 0.0),vec3(1.0, 0.0, 0.0),vec3(1.0, 1.0, 0.0),\n    vec3(0.0, 0.0, 1.0),vec3(0.0, 1.0, 1.0),vec3(1.0, 0.0, 1.0),vec3(1.0, 1.0, 1.0)\n);\n\n//'Simplex out of value noise', forked from: https://www.shadertoy.com/view/XltXRH\n//not sure about performance, is this faster than classic simplex noise?\nvec4 AchNoise3D(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 fr = smoothstep(0.0, 1.0, fract(x));\n\n    vec4 L1C1 = mix(hash43(p+nbs[0]), hash43(p+nbs[2]), fr.x);\n    vec4 L1C2 = mix(hash43(p+nbs[1]), hash43(p+nbs[3]), fr.x);\n    vec4 L1C3 = mix(hash43(p+nbs[4]), hash43(p+nbs[6]), fr.x);\n    vec4 L1C4 = mix(hash43(p+nbs[5]), hash43(p+nbs[7]), fr.x);\n    vec4 L2C1 = mix(L1C1, L1C2, fr.y);\n    vec4 L2C2 = mix(L1C3, L1C4, fr.y);\n    return mix(L2C1, L2C2, fr.z);\n}\n\nvec4 ValueSimplex3D(vec3 p)\n{\n\tvec4 a = AchNoise3D(p);\n\tvec4 b = AchNoise3D(p + 120.5);\n\treturn (a + b) * 0.5;\n}\n\n//my FBM\nvec4 FBM(vec3 p)\n{\n    vec4 f, s, n = vec4(0.0);\n    float a = 1.0, w = 0.0;\n    for (int i=0; i<FBM_Octaves; i++)\n    {\n        n = ValueSimplex3D(p);\n        f += (abs(n)) * a;\t//billowed-like\n        s += n.zwxy *a;\n        a *= FBM_Persistence;\n        w *= FBM_WarpPersist;\n        p *= FBM_Lacunarity;\n        p += n.xyz * FBM_WarpPrimary *w;\n        p += s.xyz * FBM_WarpSecond;\n        p.z *= FBM_EvalPersist +(f.w *0.5+0.5) *0.015;\n    }\n    return f;\n}\n\nvoid mainImage(out vec4 col, in vec2 uv)\n{\n    float aspect = iResolution.x / iResolution.y;\n    uv /= iResolution.xy / UVScale *0.1; uv.x *= aspect;\n    col = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    vec4 fbm = (FBM(vec3(uv, iTime *Speed +100.0)));\n    float explosionGrad = (dot(fbm.xyzw, fbm.yxwx)) *0.5;\n    explosionGrad = pow(explosionGrad, 1.3);\n    explosionGrad = smoothstep(0.0,1.0,explosionGrad);\n    \n    #define color0 vec3(1.2,0.0,0.0)\n    #define color1 vec3(0.9,0.7,0.3)\n    \n    col.xyz = explosionGrad * mix(color0, color1, explosionGrad) *1.2 +0.05;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lsSR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lsSRj", "name": "Cube Labyrinth v3", "author": "96logda", "description": "An another version of my Cube Labyrinth shader.", "tags": ["cubes", "mengersponge", "labyrinth", "proceduralgenerated"], "likes": 2, "viewed": 170, "date": "1563548493", "time_retrieved": "2024-06-20T19:39:27.176898", "image_code": "//Copyright (c) 2019-07-13 - 2019-07-19 by Angelo Logahd\n//Portfolio: https://angelologahd.wixsite.com/portfolio\n//Based on https://www.iquilezles.org/www/articles/menger/menger.htm\n\n//My other versions\n//Version 1: https://www.shadertoy.com/view/3tXXzB\n//Version 2: https://www.shadertoy.com/view/wlfXzB\n\n#define true\t\t\t\t1\n#define false\t\t\t\t0\n\n#define PI 3.14\n\n#define saturate(x) \t\tclamp(x, 0.0, 1.0)\n\n#define MENGER_ITERATIONS\t2\n#define SOFT_SHADOW_STEPS \t32\n\n#define INTERSECT_STEPS\t\t150\n#define INTERSECT_MIN_DIST\t0.0002\n#define INTERSECT_MAX_DIST\t50.0\n\n#define MOVING_BRICKS\t\tfalse\n\n\nvec2 rotate2D(vec2 p, float angle)\n{\n    float sRot = sin(angle);\n    float cRot = cos(angle);\n    return p * cRot + p.yx * sRot * vec2(-1.0, 1.0);\n}\n\nfloat sdUnitBox(vec3 p)\n{\n    vec3 d = abs(p) - vec3(1.0);\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nvec4 map(in vec3 p)\n{\n    p.xz = mod(p.xz + 5.0, 2.0) - 1.0;\n    p.y  = mod(p.y + 1.0, 2.0) - 1.0;\n    \n    float d = sdUnitBox(p);\n    vec4 res = vec4(d, 1.0, 0.0, 0.0);\n\t\n    float s = 1.5;\n    for(int i = 0; i < MENGER_ITERATIONS; ++i)\n    {\t \n        #if MOVING_BRICKS\n\t\tp.x += iTime * 0.05;\n\t    #endif\n        \n        vec3 a = mod(p * s, 2.0) - 1.0;\n        s *= 11.0;\n        vec3 r = abs(1.0 - 6.0 * abs(a));\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 1.0) / s;\n\n        if(c > d)\n        {\n            d = c;\n            res = vec4(d, min(res.y, 0.2 * da * db * dc), 0.0, 1.0);\n        }\n    }\n    \n    return res;\n}\n\nvec4 intersect(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n    vec4 h = vec4(1.0);\n    for (int i = 0; i < INTERSECT_STEPS; ++i)\n    {\n\t\tif(h.x < INTERSECT_MIN_DIST || t > INTERSECT_MAX_DIST) \n\t\t{\n\t    \tbreak;\n\t\t}\n\t\n        h = map(ro + rd * t);\n        res = vec4(t, h.yzw);\n        t += h.x;\n    }\n\n    if (t > INTERSECT_MAX_DIST) \n    {\n\t\tres = vec4(-1.0);\n    }\n    \n    return res;\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < SOFT_SHADOW_STEPS; ++i)\n    {\n\t\tvec3 pos = ro + rd * t;\n        float h = map(pos).x;\n        res = min(res, float(SOFT_SHADOW_STEPS) * h / t);\n        if(res < 0.101)\n\t\t{\n            break;\n\t\t}\n        t += clamp(h, 0.01, 0.2);\n    }\n    return saturate(res);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 n;\n    n.x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    n.y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    n.z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n    return normalize(n);\n}\n\nvec3 render(in vec3 ro, in vec3 rd, float intensity)\n{\n    vec3 color = vec3(0.5);\n    vec4 res = intersect(ro,rd);\n    if(res.x > 0.0)\n    {\n        const vec3 light1 = vec3(0.5, 0.5, -0.5);\n\t\t\n\t\tvec3 pos = ro + res.x * rd;\n\t\n        vec3 baseColor = vec3(0.0, 0.4, 0.6); //vec3(saturate(sin(iTime * 0.5)), saturate(cos(iTime * 0.3)), saturate(sin(iTime * 0.4)));\n\t\tvec3 ambient = vec3(0.2) * baseColor;\n\t\t\n\t\tvec3 normal = calcNormal(pos);\n\t\tvec3 reflection = reflect(rd, normal);\n\t\n\t\tfloat occ = res.y;\n\t\tfloat shadow1 = softshadow(pos + 0.001 * normal, light1);\n\t\n\t\tvec3 diffuse = baseColor * shadow1 * occ;\n\t\t\n\t\tcolor = diffuse + ambient;\t\t\n\t\tcolor += 0.8 * smoothstep(0.0, 0.1, reflection.y) * softshadow(pos + 0.01 * normal, reflection);\n    }\n\n    return pow(color * intensity, vec3(0.4545));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 p = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\t\n    // camera\n    vec3 ro = vec3(8.75, 0.9, -0.0);\n    #if !MOVING_BRICKS\n    ro.x -= 0.1 * iTime;\n    #endif\n    vec3 ww = normalize(vec3(0.0) - ro);\n    ww.xz = rotate2D(ww.xz, iMouse.x * 2.0 * PI);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n\n    vec3 color = render(ro + vec3(0.0, -1.0, 0.0), rd, 1.0);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lsSRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lsSz2", "name": "ray-marched sphere colors test", "author": "clepirelli", "description": "Testing simple color blending with metaball-y spheres", "tags": ["test", "sdf"], "likes": 3, "viewed": 345, "date": "1563652837", "time_retrieved": "2024-06-20T19:39:27.182967", "image_code": "#define CLOSE_ENOUGH .001\n#define K .6\n#define RED vec3(.9,.1,.1)\n#define GREEN vec3(1.,.9,1.)\n\nstruct sdf_return\n{\n\tfloat sdf;\n    vec3 col;\n};\n\nstruct sphere\n{\n\tvec3 c;\n    float r;\n    vec3 col;\n};\n    \nstruct ray\n{\n\tvec3 o;\n    vec3 d;\n};\n    \nstruct dirLight\n{\n\tvec3 d;\n    float i;\n};\n\nfloat sphDist(vec3 p, sphere s)\n{\n\treturn distance(p, s.c) - s.r;\n}\n\n//from iq : https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat dist_smooth( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sdf(vec3 p, sphere s1, sphere s2)\n{\n    float sdist1 = sphDist(p, s1);\n    float sdist2 = sphDist(p, s2);\n\treturn dist_smooth(sdist1, sdist2, K);\n}\n\nsdf_return scene(vec3 p, sphere s1, sphere s2)\n{\n    \n    float sdist1 = sphDist(p, s1);\n    float sdist2 = sphDist(p, s2);\n    //from iq : https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n    float h = clamp( 0.5 + 0.5*(sdist2-sdist1)/K, 0.0, 1.0 );\n    vec3 col = mix( s2.col, s1.col, h); \n    \n    return sdf_return(dist_smooth(sdist1, sdist2, K), col);\n}\n\n//from iq https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 p, sphere s1, sphere s2 )\n{\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdf( p + k.xyy*CLOSE_ENOUGH,s1,s2 ) + \n                      k.yyx*sdf( p + k.yyx*CLOSE_ENOUGH,s1,s2 ) + \n                      k.yxy*sdf( p + k.yxy*CLOSE_ENOUGH,s1,s2 ) + \n                      k.xxx*sdf( p + k.xxx*CLOSE_ENOUGH,s1,s2 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    sphere s1 = sphere(vec3(cos(iTime),-sin(iTime*1.4),10.0), .2, RED);\n    sphere s2 = sphere(vec3(sin(iTime),sin(iTime),10.0), .6, GREEN);\n    \n    dirLight l = dirLight(normalize(vec3(iTime, iTime, -1000.0)), 1.0);\n\t\n    ray r = ray(vec3(uv.x, uv.y, .0), normalize(vec3(uv.xy, 4.0)));\n    \n    vec3 col = vec3(1.0,1.0,.8);\n    \n    float dist = .0;\n    while(dist < 50.0)\n    {\n        vec3 rp = r.o + r.d *dist;\n        sdf_return r = scene(rp, s1, s2);\n        \n        if(r.sdf < CLOSE_ENOUGH)\n        {\n        \tvec3 n = calcNormal(rp,s1,s2);\n            col = r.col * max(dot(l.d, n), .0) * l.i;\n            break;\n        }\n        dist += r.sdf;\n    }\n\t\n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lsSz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lsSz4", "name": "Parametric circle", "author": "nkaretnikov", "description": "Parametric circle.", "tags": ["2d", "circle", "rotation", "point", "parametric"], "likes": 0, "viewed": 294, "date": "1562500019", "time_retrieved": "2024-06-20T19:39:27.740576", "image_code": "// Public domain.\n\n// Constants.\nconst float pi = 3.1415;   \n\n// Colors.\nconst vec3 black = vec3(0.);\nconst vec3 white = vec3(1.);\nconst vec3 red   = vec3(1., 0., 0.);\nconst vec3 green = vec3(0., 1., 0.);\nconst vec3 blue  = vec3(0., 0., 1.);\n\n// Parametric equation of a circle.\n// https://en.wikipedia.org/wiki/Parametric_equation#Circle\n// 't' from -pi to pi.\nvec2 pCircle(float r, float t)\n{\n    return vec2(r * sin(t), r * cos(t));\n}\n\n// Draw a circle.\nvec3 circle(vec3 color, vec2 uv, float pos, float r, float blur)\n{    \n    vec3 res = white;\n    \n    // Change the bounds of 't' to draw a part of a circle.\n    // (Not parameterized because it requires additional smoothing.)\n    for (float t = 0.; t < 2. * pi; t += .01) {\n        // Bounds.\n        vec2 c1 = pCircle(pos,     t);\n        vec2 c2 = pCircle(pos - r, t);\n        \n        // Find if a point belongs to a section using the triangle\n        // inequality (comparing to 'eps' due to floating-point).\n        float d1 = distance(c2, uv);\n        float d2 = distance(uv, c1);\n        float d3 = distance(c2, c1);\n               \n    \t// Decreasing this value produces an interesting effect.\n    \tfloat eps = .001;\n        \n\t\tif (abs(d1 + d2 - d3) < eps) {\n            // XXX: This blurs inward, reducing the size of the circle.\n            // XXX: When 'blur' == 1, the circle disappears.\n            res = color;\n            res *= smoothstep(d3, d3 * blur, d1);            \n            res *= smoothstep(d3, d3 * blur, d2);\n            break;\n        }\n        else res -= color;\n    }\n    \n    return res;\n}\n\n// Draw a point.\nvec3 point(vec3 color, vec2 uv, float pos, float r, float t, float blur)\n{  \n\t// Bounds.\n    vec2 c1 = pCircle(pos,     t);\n    vec2 c2 = pCircle(pos - r, t);\n\n    // Multiplying one of the arguments by -1 shifts it by pi.\n    float d1 = distance(uv, c1);\n    float d2 = distance(c1, c2);\n    \n    // XXX: Do not invert colors when 'blur' == 1.\n    vec3 res = vec3(smoothstep(d2, d2 * blur, d1));\n    \n    return res * color;\n}\n    \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1).\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Move 0.0 to the center.\n    uv -= .5;\n    \n    // Account for the screen ratio.\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Output color.\n    vec3 color = black;\n    \n    color += red;   \n    color -= circle(red - blue, uv, .5, .1, .9);\n    \n    // Without a loop, the parametric equation gives a point\n    // on a circle, which can be used to create a rotating point.\n\t//\n\t// Multiplying 't' by -1 makes it move counterclockwise.\n\t// Multiplying 'iTime' changes the rotation speed.\n    \n    // float t = pi;  // fixed position\n    float speed = 1.;\n    float t = mod(iTime * speed, 2. * pi);  // rotate\n    color -= point(red + blue - green, uv, .45, .01, t, .9);\n    \n    // Output to screen.\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "public-domain", "thumbnail": "https://www.shadertoy.com/media/shaders/3lsSz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lsSzf", "name": "Happy Jumping", "author": "iq", "description": "A happy and blobby creature jumping. It gets off-model very often, but it looks good enough. Making of and related math/shader/art explanations (6 hours long): [url]https://www.youtube.com/watch?v=Cfe5UQ-1L9Q[/url]. ", "tags": ["procedural", "3d", "raymarching", "sdf", "animation"], "likes": 688, "viewed": 103439, "date": "1564012178", "time_retrieved": "2024-06-20T19:39:30.237699", "image_code": "// Copyright Inigo Quilez, 2019 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n\n// An animation test - a happy and blobby creature\n// jumping and looking around. It gets off-model very\n// often, but it looks good enough I think.\n//\n// Making-of with math/shader/art explanations (6 hours\n// long): https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n//\n// Video capture: https://www.youtube.com/watch?v=s_UOFo2IULQ\n//\n// Buy a metal print here: https://www.redbubble.com/i/metal-print/Happy-Jumping-by-InigoQuilez/43594745.0JXQP\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // Set AA to 1 if your machine is too slow\n#endif\n\n\n//------------------------------------------------------------------\n\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nvec2 sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h)), h );\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nfloat href;\nfloat hsha;\n\nvec4 map( in vec3 pos, float atime )\n{\n    hsha = 1.0;\n    \n    float t1 = fract(atime);\n    float t4 = abs(fract(atime*0.5)-0.5)/0.5;\n\n    float p = 4.0*t1*(1.0-t1);\n    float pp = 4.0*(1.0-2.0*t1); // derivative of p\n\n    vec3 cen = vec3( 0.5*(-1.0 + 2.0*t4),\n                     pow(p,2.0-p) + 0.1,\n                     floor(atime) + pow(t1,0.7) -1.0 );\n\n    // body\n    vec2 uu = normalize(vec2( 1.0, -pp ));\n    vec2 vv = vec2(-uu.y, uu.x);\n    \n    float sy = 0.5 + 0.5*p;\n    float compress = 1.0-smoothstep(0.0,0.4,p);\n    sy = sy*(1.0-compress) + compress;\n    float sz = 1.0/sy;\n\n    vec3 q = pos - cen;\n    float rot = -0.25*(-1.0 + 2.0*t4);\n    float rc = cos(rot);\n    float rs = sin(rot);\n    q.xy = mat2x2(rc,rs,-rs,rc)*q.xy;\n    vec3 r = q;\n\thref = q.y;\n    q.yz = vec2( dot(uu,q.yz), dot(vv,q.yz) );\n    \n    float deli = sdEllipsoid( q, vec3(0.25, 0.25*sy, 0.25*sz) );\n    vec4 res = vec4( deli, 2.0, 0.0, 1.0 );\n\n\n    // ground\n    float fh = -0.1 - 0.05*(sin(pos.x*2.0)+sin(pos.z*2.0));\n    float t5f = fract(atime+0.05);\n    float t5i = floor(atime+0.05); \n    float bt4 = abs(fract(t5i*0.5)-0.5)/0.5;\n    vec2  bcen = vec2( 0.5*(-1.0+2.0*bt4),t5i+pow(t5f,0.7)-1.0 );\n    \n    float k = length(pos.xz-bcen);\n    float tt = t5f*15.0-6.2831 - k*3.0;\n    fh -= 0.1*exp(-k*k)*sin(tt)*exp(-max(tt,0.0)/2.0)*smoothstep(0.0,0.01,t5f);\n    float d = pos.y - fh;\n    \n    // bubbles\n    {\n    vec3 vp = vec3( mod(abs(pos.x),3.0)-1.5,pos.y,mod(pos.z+1.5,3.0)-1.5);\n    vec2 id = vec2( floor(pos.x/3.0), floor((pos.z+1.5)/3.0) );\n    float fid = id.x*11.1 + id.y*31.7;\n    float fy = fract(fid*1.312+atime*0.1);\n    float y = -1.0+4.0*fy;\n    vec3  rad = vec3(0.7,1.0+0.5*sin(fid),0.7);\n    rad -= 0.1*(sin(pos.x*3.0)+sin(pos.y*4.0)+sin(pos.z*5.0));    \n    float siz = 4.0*fy*(1.0-fy);\n    float d2 = sdEllipsoid( vp-vec3(0.5,y,0.0), siz*rad );\n    \n    d2 -= 0.03*smoothstep(-1.0,1.0,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z));\n    d2 *= 0.6;\n    d2 = min(d2,2.0);\n    d = smin( d, d2, 0.32 );\n    if( d<res.x ) { res = vec4(d,1.0,0.0,1.0); hsha=sqrt(siz); }\n    }\n\n    // rest of body\n    if( deli-1.0 < res.x ) // bounding volume\n\t{\n    float t2 = fract(atime+0.8);\n    float p2 = 0.5-0.5*cos(6.2831*t2);\n    r.z += 0.05-0.2*p2;\n    r.y += 0.2*sy-0.2;\n    vec3 sq = vec3( abs(r.x), r.yz );\n\n\t// head\n    vec3 h = r;\n    float hr = sin(0.791*atime);\n    hr = 0.7*sign(hr)*smoothstep(0.5,0.7,abs(hr));\n    h.xz = mat2x2(cos(hr),sin(hr),-sin(hr),cos(hr))*h.xz;\n    vec3 hq = vec3( abs(h.x), h.yz );\n   \tfloat d  = sdEllipsoid( h-vec3(0.0,0.20,0.02), vec3(0.08,0.2,0.15) );\n\tfloat d2 = sdEllipsoid( h-vec3(0.0,0.21,-0.1), vec3(0.20,0.2,0.20) );\n\td = smin( d, d2, 0.1 );\n    res.x = smin( res.x, d, 0.1 );\n    \n    // belly wrinkles\n    {\n    float yy = r.y-0.02-2.5*r.x*r.x;\n    res.x += 0.001*sin(yy*120.0)*(1.0-smoothstep(0.0,0.1,abs(yy)));\n    }\n        \n    // arms\n    {\n    vec2 arms = sdStick( sq, vec3(0.18-0.06*hr*sign(r.x),0.2,-0.05), vec3(0.3+0.1*p2,-0.2+0.3*p2,-0.15), 0.03, 0.06 );\n    res.xz = smin( res.xz, arms, 0.01+0.04*(1.0-arms.y)*(1.0-arms.y)*(1.0-arms.y) );\n    }\n        \n    // ears\n    {\n    float t3 = fract(atime+0.9);\n    float p3 = 4.0*t3*(1.0-t3);\n    vec2 ear = sdStick( hq, vec3(0.15,0.32,-0.05), vec3(0.2+0.05*p3,0.2+0.2*p3,-0.07), 0.01, 0.04 );\n    res.xz = smin( res.xz, ear, 0.01 );\n    }\n    \n    // mouth\n    {\n   \td = sdEllipsoid( h-vec3(0.0,0.15+4.0*hq.x*hq.x,0.15), vec3(0.1,0.04,0.2) );\n    res.w = 0.3+0.7*clamp( d*150.0,0.0,1.0);\n    res.x = smax( res.x, -d, 0.03 );\n    }\n\n\t// legs\n    {\n    float t6 = cos(6.2831*(atime*0.5+0.25));\n    float ccc = cos(1.57*t6*sign(r.x));\n    float sss = sin(1.57*t6*sign(r.x));\n\tvec3 base = vec3(0.12,-0.07,-0.1); base.y -= 0.1/sy;\n    vec2 legs = sdStick( sq, base, base + vec3(0.2,-ccc,sss)*0.2, 0.04, 0.07 );\n    res.xz = smin( res.xz, legs, 0.07 );\n    }\n        \n    // eye\n    {\n    float blink = pow(0.5+0.5*sin(2.1*iTime),20.0);\n    float eyeball = sdSphere(hq-vec3(0.08,0.27,0.06),0.065+0.02*blink);\n    res.x = smin( res.x, eyeball, 0.03 );\n    \n    vec3 cq = hq-vec3(0.1,0.34,0.08);\n    cq.xy = mat2x2(0.8,0.6,-0.6,0.8)*cq.xy;\n    d = sdEllipsoid( cq, vec3(0.06,0.03,0.03) );\n    res.x = smin( res.x, d, 0.03 );\n\n    float eo = 1.0-0.5*smoothstep(0.01,0.04,length((hq.xy-vec2(0.095,0.285))*vec2(1.0,1.1)));\n    res = opU( res, vec4(sdSphere(hq-vec3(0.08,0.28,0.08),0.060),3.0,0.0,eo));\n    res = opU( res, vec4(sdSphere(hq-vec3(0.075,0.28,0.102),0.0395),4.0,0.0,1.0));\n    }\n\t}\n\n\n    // candy\n    if( pos.y-1.0 < res.x ) // bounding volume\n    {\n    float fs = 5.0;\n    vec3 qos = fs*vec3(pos.x, pos.y-fh, pos.z );\n    vec2 id = vec2( floor(qos.x+0.5), floor(qos.z+0.5) );\n    vec3 vp = vec3( fract(qos.x+0.5)-0.5,qos.y,fract(qos.z+0.5)-0.5);\n    vp.xz += 0.1*cos( id.x*130.143 + id.y*120.372 + vec2(0.0,2.0) );\n    float den = sin(id.x*0.1+sin(id.y*0.091))+sin(id.y*0.1);\n    float fid = id.x*0.143 + id.y*0.372;\n    float ra = smoothstep(0.0,0.1,den*0.1+fract(fid)-0.95);\n    d = sdSphere( vp, 0.35*ra )/fs;\n    if( d<res.x ) res = vec4(d,5.0,qos.y,1.0);\n    }\n    \n    return res;\n}\n\nvec4 raycast( in vec3 ro, in vec3 rd, float time )\n{\n    vec4 res = vec4(-1.0,-1.0,0.0,1.0);\n\n    float tmin = 0.5;\n    float tmax = 20.0;\n    \n\t#if 1\n    // raytrace bounding plane\n    float tp = (3.4-ro.y)/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\t#endif    \n    \n    // raymarch scene\n    float t = tmin;\n    for( int i=0; i<256 && t<tmax; i++ )\n    {\n        vec4 h = map( ro+rd*t, time );\n        if( abs(h.x)<(0.0005*t) )\n        { \n            res = vec4(t,h.yzw); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float time )\n{\n    float res = 1.0;\n\n    float tmax = 12.0;\n    #if 1\n    float tp = (3.4-ro.y)/rd.y; // raytrace bounding plane\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\t#endif    \n    \n    float t = 0.02;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, time ).x;\n        res = min( res, mix(1.0,16.0*h/t, hsha) );\n        t += clamp( h, 0.05, 0.40 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, float time )\n{\n    \n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*map( pos + e.xyy, time ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, time ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, time ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, time ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e,time).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float time )\n{ \n    // sky dome\n    vec3 col = vec3(0.5, 0.8, 0.9) - max(rd.y,0.0)*0.5;\n    // sky clouds\n    vec2 uv = 1.5*rd.xz/rd.y;\n    float cl  = 1.0*(sin(uv.x)+sin(uv.y)); uv *= mat2(0.8,0.6,-0.6,0.8)*2.1;\n          cl += 0.5*(sin(uv.x)+sin(uv.y));\n    col += 0.1*(-1.0+2.0*smoothstep(-0.1,0.1,cl-0.4));\n    // sky horizon\n\tcol = mix( col, vec3(0.5, 0.7, .9), exp(-10.0*max(rd.y,0.0)) );    \n    \n\n    // scene geometry\n    vec4 res = raycast(ro,rd, time);\n    if( res.y>-0.5 )\n    {\n        float t = res.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, time );\n        vec3 ref = reflect( rd, nor );\n        float focc = res.w;\n        \n        // material        \n\t\tcol = vec3(0.2);\n        float ks = 1.0;\n\n        if( res.y>4.5 )  // candy\n        { \n             col = vec3(0.14,0.048,0.0); \n             vec2 id = floor(5.0*pos.xz+0.5);\n\t\t     col += 0.036*cos((id.x*11.1+id.y*37.341) + vec3(0.0,1.0,2.0) );\n             col = max(col,0.0);\n             focc = clamp(4.0*res.z,0.0,1.0);\n        }\n        else if( res.y>3.5 ) // eyeball\n        { \n            col = vec3(0.0);\n        } \n        else if( res.y>2.5 ) // iris\n        { \n            col = vec3(0.4);\n        } \n        else if( res.y>1.5 ) // body\n        { \n            col = mix(vec3(0.144,0.09,0.0036),vec3(0.36,0.1,0.04),res.z*res.z);\n            col = mix(col,vec3(0.14,0.09,0.06)*2.0, (1.0-res.z)*smoothstep(-0.15, 0.15, -href));\n        }\n\t\telse // terrain\n        {\n            // base green            \n            col = vec3(0.05,0.09,0.02);\n            float f = 0.2*(-1.0+2.0*smoothstep(-0.2,0.2,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z)));\n            col += f*vec3(0.06,0.06,0.02);\n            ks = 0.5 + pos.y*0.15;\n            \n\t\t\t// footprints            \n            vec2 mp = vec2(pos.x-0.5*(mod(floor(pos.z+0.5),2.0)*2.0-1.0), fract(pos.z+0.5)-0.5 );\n            float mark = 1.0-smoothstep(0.1, 0.5, length(mp));\n            mark *= smoothstep(0.0, 0.1, floor(time) - floor(pos.z+0.5) );\n            col *= mix( vec3(1.0), vec3(0.5,0.5,0.4), mark );\n            ks *= 1.0-0.5*mark;\n        }\n        \n        // lighting (sun, sky, bounce, back, sss)\n        float occ = calcOcclusion( pos, nor, time )*focc;\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        \n        vec3  sun_lig = normalize( vec3(0.6, 0.35, 0.5) );\n        float sun_dif = clamp(dot( nor, sun_lig ), 0.0, 1.0 );\n        vec3  sun_hal = normalize( sun_lig-rd );\n        float sun_sha = calcSoftshadow( pos, sun_lig, time );\n\t\tfloat sun_spe = ks*pow(clamp(dot(nor,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float sky_spe = ks*smoothstep( 0.0, 0.5, ref.y )*(0.04+0.96*pow(fre,4.0));\n        float bou_dif = sqrt(clamp( 0.1-0.9*nor.y, 0.0, 1.0 ))*clamp(1.0-0.1*pos.y,0.0,1.0);\n        float bac_dif = clamp(0.1+0.9*dot( nor, normalize(vec3(-sun_lig.x,0.0,-sun_lig.z))), 0.0, 1.0 );\n        float sss_dif = fre*sky_dif*(0.25+0.75*sun_dif*sun_sha);\n\n\t\tvec3 lin = vec3(0.0);\n        lin += sun_dif*vec3(8.10,6.00,4.20)*vec3(sun_sha,sun_sha*sun_sha*0.5+0.5*sun_sha,sun_sha*sun_sha);\n        lin += sky_dif*vec3(0.50,0.70,1.00)*occ;\n        lin += bou_dif*vec3(0.20,0.70,0.10)*occ;\n        lin += bac_dif*vec3(0.45,0.35,0.25)*occ;\n        lin += sss_dif*vec3(3.25,2.75,2.50)*occ;\n\t\tcol = col*lin;\n\t\tcol += sun_spe*vec3(9.90,8.10,6.30)*sun_sha;\n        col += sky_spe*vec3(0.20,0.30,0.65)*occ*occ;\n      \t\n        col = pow(col,vec3(0.8,0.9,1.0) );\n        \n        // fog\n        col = mix( col, vec3(0.5,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        // time coordinate (motion blurred, shutter=0.5)\n        float d = 0.5+0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA);\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        float time = iTime;\n#endif\n        time += -2.6;\n        time *= 0.9;\n        \n        // camera\t\n        float cl = sin(0.5*time);\n        float an = 1.57 + 0.7*sin(0.15*time);\n        vec3  ta = vec3( 0.0, 0.65, -0.6+time*1.0 - 0.4*cl);\n        vec3  ro = ta + vec3( 1.3*cos(an), -0.250, 1.3*sin(an) );\n        float ti = fract(time-0.15);\n        ti = 4.0*ti*(1.0-ti);        \n        ta.y += 0.15*ti*ti*(3.0-2.0*ti)*smoothstep(0.4,0.9,cl);\n        \n        // camera bounce\n        float t4 = abs(fract(time*0.5)-0.5)/0.5;\n        float bou = -1.0 + 2.0*t4;\n        ro += 0.06*sin(time*12.0+vec3(0.0,2.0,4.0))*smoothstep( 0.85, 1.0, abs(bou) );\n\n        // camera-to-world rotation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,1.8) );\n        \n        // render\t\n        vec3 col = render( ro, rd, time );\n\n        // color grading\n        col = col*vec3(1.11,0.89,0.79);\n\n        // compress        \n        col = 1.35*col/(1.0+col);\n        \n        // gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // s-surve    \n    tot = clamp(tot,0.0,1.0);\n    tot = tot*tot*(3.0-2.0*tot);\n\n    // vignetting        \n    vec2 q = fragCoord/iResolution.xy;\n    tot *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n\n    // output    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lsSzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lsXRs", "name": "x0006 - rasterizer - cube", "author": "xigh", "description": "Duplicated code from my Suzanne experiment, because it crashed on Firefox/Win10 and Chrome/MacOSX.\n\nI guess it crashed because of the size of array. I'll investigate now ...\n\nThis works well on Firefox/Ubuntu, Firefox/Win10 and Chrome/MacOSX", "tags": ["raytracingcuberaytracing"], "likes": 4, "viewed": 139, "date": "1563950088", "time_retrieved": "2024-06-20T19:39:30.922527", "image_code": "const int vCount = 8;\nconst vec3 vertices[] = vec3[](\n vec3(0.80000, -0.80000, -0.80000),\n vec3(0.80000, -0.80000, 0.80000),\n vec3(-0.80000, -0.80000, 0.80000),\n vec3(-0.80000, -0.80000, -0.80000),\n vec3(0.80000, 0.80000, -0.80000),\n vec3(0.80000, 0.80000, 0.80000),\n vec3(-0.80000, 0.80000, 0.80000),\n vec3(-0.80000, 0.80000, -0.80000) \n);\n\nconst int iCount = 12;\n\nconst int indices[] = int[](\n 1026,\n 2051,\n 4201478,\n 4200453,\n 4101,\n 5121,\n 1053702,\n 1054722,\n 2103303,\n 2104323,\n 4194307,\n 4197383 \n);\n\nconst float PI = 3.1415;\nconst float epsilon = 1e-5;\nconst vec3 centerColor = vec3(1.0, 0.5, 0.0);\nconst vec3 mouseColor = vec3(1.0, 0.0, 0.0);\nconst float near = 0.2;\n\nconst vec3 eye = vec3(0.0, 5.0, 35.0);\n\n// https://www.shadertoy.com/view/XdlGzn\nmat4 translate(float x, float y, float z) {\n    return mat4(1.0, 0.0, 0.0, x, 0.0, 1.0, 0.0, y, 0.0, 0.0, 1.0, z, 0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotate(float x, float y, float z) {\n    float a = sin(x);\n    float b = cos(x);\n    float c = sin(y);\n    float d = cos(y);\n    float e = sin(z);\n    float f = cos(z);\n\n    float ac = a * c;\n    float bc = b * c;\n\n    return mat4(d * f, d * e, -c, 0.0, ac * f - b * e, ac * e + b * f, a * d, 0.0,\n                bc * f + a * e, bc * e - a * f, b * d, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\n\n#define CULLING\n\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection\nbool triangleIntersect(in vec3 orig, in vec3 dir, in vec3 v0, in vec3 v1, in vec3 v2,\n                       out vec3 uvt) {\n    vec3 v0v1 = v1 - v0;\n    vec3 v0v2 = v2 - v0;\n    vec3 pvec = cross(dir, v0v2);\n    float det = dot(v0v1, pvec);\n\n#ifdef CULLING\n    if (det <= epsilon) {\n        return false;\n    }\n#else\n    if (abs(det) < epsilon) {\n        return false;\n    }\n#endif\n    float invDet = 1.0 / det;\n\n    vec3 tvec = orig - v0;\n    float u = dot(tvec, pvec) * invDet;\n    if (u < 0.0 || u > 1.0) {\n        return false;\n    }\n\n    vec3 qvec = cross(tvec, v0v1);\n    float v = dot(dir, qvec) * invDet;\n    if (v < 0.0 || u + v > 1.0) {\n        return false;\n    }\n\n    float t = dot(v0v2, qvec) * invDet;\n    uvt = vec3(u, v, t);\n    return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color = vec3(0.1, 0.1, 0.1);\n    // vec3 color = texture(iChannel0, fragCoord / iResolution.xy).xyz;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pt = uv * 2.0 - 1.0;\n\n    // z position of near clipping plane\n    pt.x *= iResolution.x / iResolution.y;\n    vec3 p = vec3(pt, near);\n\n    // calc ray direction\n    vec3 dir = normalize(p - eye);\n\n    // prepare model matrix\n    mat4 model = rotate(iTime, iTime, 0.0);\n    \n    float minZ = 1e9;\n\n    // triangle verts\n    int stride = int(iResolution.x);\n    for (int t = 0; t < iCount; t++) {\n        int z = indices[t];\n        ivec3 idx = ivec3(z / 1024 / 1024, z / 1024 % 1024, z % 1024);\n        \n        \n        vec4 v0 = model * vec4(vertices[idx.x], 1.0);\n        vec4 v1 = model * vec4(vertices[idx.y], 1.0);\n        vec4 v2 = model * vec4(vertices[idx.z], 1.0);\n\n        vec3 uvt = vec3(0.0);\n        if (triangleIntersect(eye, dir, v0.xyz, v1.xyz, v2.xyz, uvt)) {\n            vec3 norm = cross((v0-v1).xyz, (v0-v2).xyz);\n            norm = normalize(norm);\n            color = vec3(uvt.x, uvt.y, 1.0-uvt.x-uvt.y);\n            color = vec3(abs(dot(norm, vec3(0.0, 0.0, -1.0))));\n            break;\n        }\n    }\n\n    // draw center\n    float l2 = length(pt);\n    float x2 = smoothstep(0.01, 0.005, l2);\n    color = clamp(mix(color, centerColor, x2), 0.0, 1.0);\n\n    // draw mouse\n    float l0 = length(fragCoord - iMouse.xy);\n    float x0 = smoothstep(3.0, 2.0, l0);\n    color = clamp(mix(color, mouseColor, x0), 0.0, 1.0);\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lsXRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lsXWB", "name": "distortion practice", "author": "Hirai_worthless", "description": "i know", "tags": ["raymarching"], "likes": 3, "viewed": 69, "date": "1564134810", "time_retrieved": "2024-06-20T19:39:30.928615", "image_code": "vec2 path(float z){\n    float x = sin(z) + 2.0 * cos(z * 0.3) - 1.5 * sin(z * 0.12345);\n    float y = cos(z) + 1.5 * sin(z * 0.3) + 2.0 * cos(z * 0.12345);\n    return vec2(x,y);\n}\n\nfloat map(vec3 p){\n\t//p = fract(p/2.0) * 6.0 - 3.0;\n    vec2 o = path(p.z) / 4.0;\n\tfloat tBase = max(-length(p.xy - o) + 1.0 \n                      //* (1.0 + sin(p.z) * 0.5)\n                      ,length(p.xy - o) - 1.2 \n                      //* (1.0 + sin(p.z) * 0.5)\n                     );\n    float tdonut = max(-length(p.xy - o) + 0.5\n                      ,length(p.xy - o) - 0.6 \n                     );\n    tdonut = max(tdonut,abs(fract(p.z) - 0.5));\n    float tTube1 = length(p.xy - o + vec2(0.3,0.3)) - 0.025;\n    float tTube2 = length(p.xy - o + vec2(0.5,0.2)) - 0.025;\n    float tTube3 = length(p.xy - o + vec2(0.2,0.5)) - 0.025;    \n    float tTube4 = length(p.xy - o + vec2(-0.3,-0.3)) - 0.025;\n    float tTube5 = length(p.xy - o + vec2(-0.5,-0.2)) - 0.025;\n    float tTube6 = length(p.xy - o + vec2(-0.2,-0.5)) - 0.025;\n    float tTube = min(min(tTube1,tTube2),tTube3);\n    tTube = min(min(tTube,tTube4),min(tTube5,tTube6));\n\n    float bound = 2.0;\n    float tSplit = (fract(p.z)-0.5);\n    tSplit = min(tSplit, abs((p.x - o.x))-0.15);\n    tSplit = min(tSplit, abs((p.y - o.y))-0.15);\n\n    return min(min(max(tBase,-tSplit),tdonut),tTube);\n}\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 96; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return vec4(getNormal(p),t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float PI = 3.14159265;\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv.x,uv.y + sin(uv.x + iTime),0.5));\n\n    float z = iTime * 4.0 ;\n    \n    r.xy *= mat2( sin(iTime),cos(iTime),\n    \t\t\t\t-cos(iTime),sin(iTime));\n\tvec2 a = path(z);\n    vec3 o = vec3(a / 4.0,z);\n    vec4 data = trace(o,r);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.3);\n    vec3 fc = mix(vec3(0.5 - data.x,0.5 -data.y,0.5-data.z),vec3(0),1.0 - fog);\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lsXWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lsXz7", "name": "Wavy sand", "author": "ParaBellum", "description": "Testing noise to adding more texture to surfaces.\nMove light with mouse + left click.", "tags": ["2d", "noise", "wave", "light", "sand"], "likes": 5, "viewed": 209, "date": "1562472917", "time_retrieved": "2024-06-20T19:39:31.662079", "image_code": "vec3 brown = vec3(.6, .4992, .3625);\n\n// 2D Random\nfloat r1d(float x) {\n    return fract(sin(dot(vec2(x, x),\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat n1D(float x)\n{\n    float i = floor(x);  // integer\n    float f = fract(x);  // fraction\n    float y = r1d(i); //rand() is described in the previous chapter\n    y = mix(r1d(i), r1d(i + 1.0), f);\n    y = mix(r1d(i), r1d(i + 1.0), smoothstep(0.,1.,f));\n    return y;\n}\n\n// 2D Random\nfloat r2d (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = r2d(i);\n    float b = r2d(i + vec2(1.0, 0.0));\n    float c = r2d(i + vec2(0.0, 1.0));\n    float d = r2d(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define PI 3.141592\n\nfloat waves(vec2 p)\n{\n    float t = iTime;\n    for (int i = 0; i < 10; i++) p.y += n1D(p.x*float(i)/2.+t*.05)*.05;\n    p *= 3.;\n    vec2 i_p = floor(p);\n    if (mod(i_p.y, 2.) != 0.) p.y += n1D(abs(p.y+p.x+.5))*.5;\n    else p.y += n1D(abs(p.y+p.x+.5))*.5;\n    p = fract(p)*2.-1.;\n    return smoothstep(.0, 1., abs(p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 frag = fragCoord.xy;\n    vec2 uv = frag/iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 ms = iMouse.xy / iResolution.xy * 2. - 1.;\n    ms.x *= iResolution.x / iResolution.y;\n    \n    vec2 e = vec2(1., .0);\n    \n    vec2 x_uv = (frag+e.xy)/iResolution.xy * 2. - 1.;\n    x_uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 y_uv = (frag+e.yx)/iResolution.xy * 2. - 1.;\n    y_uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 pos = vec2(uv*5.);\n    vec2 x_pos = vec2(x_uv*5.);\n    vec2 y_pos = vec2(y_uv*5.);\n\n    // Use the noise function\n    float n = noise(pos);\n    n += noise(pos*4.)*.25;\n    n += noise(pos*8.)*.125;\n    n += noise(pos*16.)*.0625;\n    n *= .15;\n    \n    float x_n = noise(x_pos);\n    x_n += noise(x_pos*4.)*.25;\n    x_n += noise(x_pos*8.)*.125;\n    x_n += noise(x_pos*16.)*.0625;\n    x_n *= .15;\n    \n    float y_n = noise(y_pos);\n    y_n += noise(y_pos*4.)*.25;\n    y_n += noise(y_pos*8.)*.125;\n    y_n += noise(y_pos*16.)*.0625;\n    y_n *= .15;\n    \n    float w = waves(uv);\n    float dx = waves(x_uv);\n    float dy = waves(y_uv);\n    \n    float r = r2d(uv);\n    float x_r = r2d(x_uv);\n    float y_r = r2d(y_uv);\n    \n    vec3 fragPos = vec3(uv, w+n);\n    vec3 x_fragPos = vec3(x_uv, dx+x_n);\n    vec3 y_fragPos = vec3(y_uv, dy+y_n);\n    \n    vec3 fragPosR = vec3(uv, r);\n    vec3 x_fragPosR = vec3(x_uv, x_r);\n    vec3 y_fragPosR = vec3(y_uv, y_r);\n    \n    vec3 a = x_fragPos - fragPos;\n    vec3 b = y_fragPos - fragPos;\n    vec3 nor = normalize(cross(a, b));\n    \n    vec3 aR = x_fragPosR - fragPosR;\n    vec3 bR = y_fragPosR - fragPosR;\n    vec3 norR = normalize(cross(aR, bR));\n    \n    vec3 lightPos = vec3(ms, 4.);\n    vec3 lightDir = normalize(lightPos - fragPos);\n    vec3 eye = vec3(0., 0., 6.);\n    vec3 eyeDir = normalize(eye - fragPos);\n    vec3 halfWayDir = normalize(lightDir + eyeDir);\n    \n    float amb = w;\n    float dif = max(dot(nor+norR, lightDir), 0.);\n    float spe = pow(max(dot(halfWayDir,nor+norR), 0.),6.)*r;\n    float light = amb + dif + spe;\n    \n    w = clamp(w, .7, 1.);\n    vec3 col = vec3(0.);\n    col += brown*(light+w)*.5; \n\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lsXz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lsXzf", "name": "Lightning noise!", "author": "toomuchvoltage", "description": "This has behavioral characteristics similar to triangle noise created by Nimitz. Though more expensive it's covered under MIT so it's commercial friendly! The base noise looks like intertwined lightning strikes! :) It's a chain-link fence of sine fBms ;)\n", "tags": ["noise", "triangle", "lightning", "pattern", "auroras"], "likes": 23, "viewed": 871, "date": "1563834280", "time_retrieved": "2024-06-20T19:39:33.146948", "image_code": "#define DISPLAY_SCALE 1.0\n\n/*****************************************************************************\n   We're using 2D Triangle noise as our reference.\n\n\n   Copied from here: https://www.shadertoy.com/view/XtGGRt\n\n   Auroras by nimitz 2017 (twitter: @stormoid)\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n   Contact the author for other licensing options\n\n******************************************************************************/\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\nfloat tri(in float x){return clamp(abs(fract(x)-.5),0.01,0.49);}\nvec2 tri2(in vec2 p){return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));}\n\nfloat triNoise2d(in vec2 p, float spd)\n{\n    float z=1.8;\n    float z2=2.5;\n\tfloat rz = 0.;\n    p *= mm2(p.x*0.06);\n    vec2 bp = p;\n\tfor (float i=0.; i<5.; i++ )\n\t{\n        vec2 dg = tri2(bp*1.85)*.75;\n        dg *= mm2(iTime*spd);\n        p -= dg/z2;\n\n        bp *= 1.3;\n        z2 *= .45;\n        z *= .42;\n\t\tp *= 1.21 + (rz-1.0)*.02;\n        \n        rz += tri(p.x+tri(p.y))*z;\n        p*= -m2;\n\t}\n    return clamp(1./pow(rz*29., 1.0),0.,.55);\n}\n\n/*****************************************************************************\n   And this is my noise... I dub this: 'lightning noise'.\n   The main two things to get right were the motion and the noisy fins!\n\n   Covered under the MIT license:\n\n   Copyright (c) 2019 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n   Hit me up!\n\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n******************************************************************************/\n\nmat2 rotate(in float a)\n{\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat lightningNoise (vec2 forPos)\n{\n    forPos *= 4.0;\n    forPos.y *= 0.85;\n    float wobbleAmount1 = sin(forPos.y) * 0.5 + sin(forPos.y * 2.0) * 0.25 + sin(forPos.y * 4.0) * 0.125 + sin(forPos.y * 8.0) * 0.0625;\n    float wobbleAmount2 = sin(forPos.x) * 0.5 + sin(forPos.x * 2.0) * 0.25 + sin(forPos.x * 4.0) * 0.125 + sin(forPos.x * 8.0) * 0.0625;\n    float horizontalStrike = 1.0 - abs(sin(forPos.x + wobbleAmount1 * 1.1));\n    float verticalStrike = 1.0 - abs(cos(forPos.y + wobbleAmount2 * 1.1));\n    return (horizontalStrike + verticalStrike) * 0.35;\n}\n\nfloat fBm (in vec2 uv)\n{\n    float amp = 0.5;\n    float res = 0.0;\n    for (int i = 0; i < 5; ++i) {\n        res += amp * lightningNoise(uv);\n        uv *= 2.0;\n        amp *= 0.5;\n    }\n    return res;\n}\n\nfloat domainWarp (in vec2 uv)\n{\n    mat2 rotMat = rotate(0.1);\n    float v1 = fBm(rotMat * uv + 0.02 * iTime);\n    uv = rotMat * uv + 1.0;\n    float v2 = fBm(uv - 0.02 * iTime);\n    uv = rotMat * uv + 1.0;\n    float v3 = fBm(uv + 0.02 * iTime);\n    uv = rotMat * uv + 1.0;\n    float v4 = fBm(uv - 0.02 * iTime);\n    float finalRes = fBm (vec2 (fBm(vec2 (v1,v2)), fBm(vec2 (v3,v4))));\n    return clamp (pow (1.0 - finalRes, 10.0) * lightningNoise (rotate (0.02 * iTime) * uv) * 10.0, 0.0, 0.55);\n}\n\n/*****************************************************************************\n   And finally a modified version of Nimitz's Auroras: https://www.shadertoy.com/view/XtGGRt\n   That uses our noise instead! :) ... just to see it in action really...\n\n   Auroras by nimitz 2017 (twitter: @stormoid)\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n   Contact the author for other licensing options\n******************************************************************************/\n\n#define time iTime\n\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nvec4 aurora(vec3 ro, vec3 rd)\n{\n    vec4 col = vec4(0);\n    vec4 avgCol = vec4(0);\n    \n    for(float i=0.;i<50.;i++)\n    {\n        float of = 0.006*hash21(gl_FragCoord.xy)*smoothstep(0.,15., i);\n        float pt = ((.8+pow(i,1.4)*.002)-ro.y)/(rd.y*2.+0.4);\n        pt -= of;\n    \tvec3 bpos = ro + pt*rd;\n        vec2 p = bpos.zx;\n        float rzt = domainWarp(p);\n        vec4 col2 = vec4(0,0,0, rzt);\n        col2.rgb = (sin(1.-vec3(2.15,-.5, 1.2)+i*0.043)*0.5+0.5)*rzt;\n        avgCol =  mix(avgCol, col2, .5);\n        col += avgCol*exp2(-i*0.065 - 2.5)*smoothstep(0.,5., i);\n        \n    }\n    \n    col *= (clamp(rd.y*15.+.4,0.,1.));\n    \n    \n    //return clamp(pow(col,vec4(1.3))*1.5,0.,1.);\n    //return clamp(pow(col,vec4(1.7))*2.,0.,1.);\n    //return clamp(pow(col,vec4(1.5))*2.5,0.,1.);\n    //return clamp(pow(col,vec4(1.8))*1.5,0.,1.);\n    \n    //return smoothstep(0.,1.1,pow(col,vec4(1.))*1.5);\n    return col*1.8;\n    //return pow(col,vec4(1.))*2.\n}\n\n\n//-------------------Background and Stars--------------------\n\nvec3 nmzHash33(vec3 q)\n{\n    uvec3 p = uvec3(ivec3(q));\n    p = p*uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\n    p = p.yzx*(p.zxy^(p >> 3U));\n    return vec3(p^(p >> 16U))*(1.0/vec3(0xffffffffU));\n}\n\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.;\n    \n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = nmzHash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.1+0.9);\n        p *= 1.3;\n    }\n    return c*c*.8;\n}\n\nvec3 bg(in vec3 rd)\n{\n    float sd = dot(normalize(vec3(-0.5, -0.6, 0.9)), rd)*0.5+0.5;\n    sd = pow(sd, 5.);\n    vec3 col = mix(vec3(0.05,0.1,0.2), vec3(0.1,0.05,0.2), sd);\n    return col*.63;\n}\n//-----------------------------------------------------------\n\n\nvoid aurorasWithLightningNoise( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q - 0.5;\n\tp.x*=iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0,0,-6.7);\n    vec3 rd = normalize(vec3(p,1.3));\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.1,0.1):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n    rd.yz *= mm2(mo.y);\n    rd.xz *= mm2(mo.x + sin(time*0.05)*0.2);\n    \n    vec3 col = vec3(0.);\n    vec3 brd = rd;\n    float fade = smoothstep(0.,0.01,abs(brd.y))*0.1+0.9;\n    \n    col = bg(rd)*fade;\n    \n    if (rd.y > 0.){\n        vec4 aur = smoothstep(0.,1.5,aurora(ro,rd))*fade;\n        col += stars(rd);\n        col = col*(1.-aur.a) + aur.rgb;\n    }\n    else //Reflections\n    {\n        rd.y = abs(rd.y);\n        col = bg(rd)*fade*0.6;\n        vec4 aur = smoothstep(0.0,2.5,aurora(ro,rd));\n        col += stars(rd)*0.1;\n        col = col*(1.-aur.a) + aur.rgb;\n        vec3 pos = ro + ((0.5-ro.y)/rd.y)*rd;\n        float nz2 = domainWarp(pos.xz*vec2(.5,.7));\n        col += mix(vec3(0.2,0.25,0.5)*0.08,vec3(0.3,0.3,0.5)*0.7, nz2*0.4);\n    }\n    \n\tfragColor = vec4(col, 1.);\n}\n\n/**************************************************\n    This part is just captain planet\n***************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord/iResolution.xy) * 4.0 - 2.0) * DISPLAY_SCALE;\n    float xOnScreen = fragCoord.x / iResolution.x;\n    float yOnScreen = fragCoord.y / iResolution.y;\n    \n    if (xOnScreen < 0.33333 )\n    {\n        if ( yOnScreen < 0.5 )\n\t\t    fragColor = vec4(vec3 (triNoise2d (uv, 0.4)),1.0);\n        else\n\t\t    fragColor = vec4(vec3 (domainWarp (uv)),1.0);\n    }\n    else\n        aurorasWithLightningNoise (fragColor, fragCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lsXzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lsXzH", "name": "AuroraBorealis vs. solar eclipse", "author": "clintolibre", "description": "Mashup of https://www.shadertoy.com/view/MdBfzR AuroraBorealis  by albertelwin and https://www.shadertoy.com/view/ttlXzn solar eclipse by jn\nClick to move the moon!", "tags": ["mashup"], "likes": 3, "viewed": 94, "date": "1562098172", "time_retrieved": "2024-06-20T19:39:33.146948", "image_code": "vec3 day=vec3(0.2,0.3,0.5);\nvec3 night=vec3(0.0,0.0,0.0);\nvec3 sun=vec3(2.0,2.0,2.0);\n\nvec3 background(vec2 pos,vec2 mouse)\n{\n\n    float m=length(pos);\n    float ml=length(mouse);\n    \n    vec3 bgcol=mix(night,day,ml/0.5);\n    if (ml>.5) {\n    bgcol = day;\n    }\n    float moomcircle=step(0.08,distance(mouse,pos));\n    float suncircle=step(0.09,m);\n    vec3 returncol=mix(sun,bgcol,suncircle);\n\treturncol*=moomcircle;\n    return returncol;\n}\nfloat rand(float x) {\n\tfloat res = 0.0;\n\t\n\tfor (int i = 0; i < 5; i++) {\n\t\tres += 0.240 * float(i) * sin(x * 0.68171 * float(i));\n\t\t\n\t}\n\treturn res;\n\t\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n#define TAU 6.2831853071\n\n\tvec2 uv2 = fragCoord.xy / iResolution.xy;\n    \n    float o = texture(iChannel1, uv2 * 0.25 + vec2(0.0, iTime * 0.025)).r;\n    float d = (texture(iChannel0, uv2 * 0.25 - vec2(0.0, iTime * 0.02 + o * 0.02)).r * 2.0 - 1.0);\n    \n    float v = uv2.y + d * 0.1;\n    v = 1.0 - abs(v * 2.0 - 1.0);\n    v = pow(v, 2.0 + sin((iTime * 0.2 + d * 0.25) * TAU) * 0.5);\n    \n    vec3 color = vec3(0.0);\n    \n    float x = (1.0 - uv2.x * 0.75);\n    float y = 1.0 - abs(uv2.y * 2.0 - 1.0);\n    color += vec3(x * 0.5, y, x) * v;\n    \n    vec2 seed = fragCoord.xy;\n    vec2 r;\n    r.x = fract(sin((seed.x * 12.9898) + (seed.y * 78.2330)) * 43758.5453);\n    r.y = fract(sin((seed.x * 53.7842) + (seed.y * 47.5134)) * 43758.5453);\n\n    float s = mix(r.x, (sin((iTime * 2.5 + 60.0) * r.y) * 0.5 + 0.5) * ((r.y * r.y) * (r.y * r.y)), 0.04); \n    color += pow(s, 70.0) * (1.0 - v);\n    \n    night = color;\n    fragColor.a = 1.0;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n\tuv.x*=iResolution.x/iResolution.y;\n    float floorBounceCount = 0.0;\n    float rk = 0.025;\n    float speed = 5.0;\n    vec2 mouse=iMouse.xy/iResolution.xy-0.5;\n    if (iMouse.z>0.0) {\n    } else {\n    mouse = vec2(abs(mod(iTime/speed, 2.0)-1.0)*(1.0-2.0*rk)+rk, pow(0.5, floorBounceCount)*abs(sin(iTime/speed))*0.45+rk);\n    mouse.x=mouse.x-.5;\n    mouse.y=mouse.y*2.0;\n    mouse.y=mouse.y-.5;\n    \n    }\n    mouse.x*=iResolution.x/iResolution.y;;\n    \n    \n    \n\tvec3 col=background(uv,mouse);\n    \n\t\n    \n    vec3 light=vec3(0.0,0.0,0.0);\n    int iterations=50;\n    vec2 incr=uv/float(iterations);\n    vec2 p=vec2(0.0,0.0)+incr;\n    for(int i=2;i<iterations;i++)\n    {\n        light+=background(p,mouse);\n        p+=incr;\n    }\n    light/= float(iterations)*max(0.001,dot(uv,uv))*80.0;\n    \n    vec2 star = fragCoord.xy;\n    \n    //col+=step(2.1,rand(star.y * star.x))*step(0.7,rand(star.y + star.x))*step(length(mouse),0.15)*mix(vec3(2.0,2.0,2.0),day,length(mouse)/0.5);\n\n    float moomcircle=smoothstep(0.08,0.085,distance(mouse,uv));\n    col*=moomcircle;\n    if (moomcircle <1.) {\n    \tcol += vec3((1.0-moomcircle)*length(mouse)*texture(iChannel2, uv-mouse+.3));\n    }\n    // Output to screen\n    fragColor = vec4(col+light,1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lsXzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lsXzj", "name": "SSS Light Study 9 : Jade ?", "author": "aiekick", "description": "SSS Light Study 9 ", "tags": ["sss", "light", "study", "9", "jade"], "likes": 11, "viewed": 429, "date": "1563560573", "time_retrieved": "2024-06-20T19:39:34.062227", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2019 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via NoodlesPlate (https://github.com/aiekick/NoodlesPlate/releases)\n\nmat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nvec2 path(float t)\n{\n\treturn vec2(cos(t*0.2), sin(t*0.2)) * 2.;\n}\n\nfloat coefFromRGB(vec3 rgb)\n{\n\tvec3 wl = vec3(564.,533.,437.);\n\treturn length(wl * rgb) / length(wl);\n}\n\nfloat df(vec3 p)\n{\n\tp *= RotZ(p.z*0.4);\n\tp += (sin(p.zxy * 0.8) + sin(p.xzy * 0.9)) * 2.5;\n    return length(p)-3.;\n}\n\nvec3 nor( in vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy) - df(pos-eps.xyy),\n\t    df(pos+eps.yxy) - df(pos-eps.yxy),\n\t    df(pos+eps.yyx) - df(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 10;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint);\n\t}\n\t\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s);\t\t\t\t\t\t// ratio between df step and constant step\n}\n\n// from shane sahders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\nvec3 shade(vec3 ro, vec3 rd, float d, vec3 lp, float li)\n{\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tfloat sb = SubDensity(p, 0.01, 0.076);\t\t\t\t\t\t\t// deep subdensity (10 iterations)\n\tvec3 bb = blackbody(100.*sb+100.).brg;\t\t\t\t\t\t\t\t// bb\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, 0.1);\t// normal at surface point\n    \n    // derived from bumpmap func from shane\n    const vec2 e = vec2(0.1, 0);\n    mat3 m = mat3( tex3D(iChannel0, e.xyy, n), tex3D(iChannel0, e.yxy, n), tex3D(iChannel0, e.yyx, n));\n   \tvec3 g = vec3(1) * m * 20.;\n    g -= n * dot(n, g);\n    n =  normalize( n + g );\n    \n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat amb = 0.1242; \t\t\t\t\t\t\t\t\t\t\t\t// ambiance factor\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\t\t// specular\n\tfloat sss = 1. - SubDensity(p, 7.8); \t\t\t\t\t\t\t// one step sub density of df\n\tvec3 col = (diff + fre + bb * sb * 0.608 + sss * 0.352) * amb * li + spe * 0.612;\n\t\n\treturn mix(col, vec3(1), vec3(coefFromRGB(bb*0.8+0.1*diff + 0.1 *spe)));\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cv, float t)\n{\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y= cross(z,x);\n  \treturn normalize(z + uv.x*x + uv.y*y);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    float t = -iTime*2.;\n\n    vec2 si = iResolution.xy;\n    vec2 uv = (2.*fragCoord.xy-si)/si.y;\n    \n    vec3 col = vec3(1);\n    \n\tfloat ca = iTime;\n\tfloat ce = 0.5;\n\tfloat cd = 10.;\n\t\n\tvec3 ro = vec3(cos(ca), sin(ce), sin(ca)) * cd;\n  \tvec3 cv = vec3(0);\n\tvec3 rd = cam(uv, ro, cv, t);\n       \n\tfloat md = 20.;\n    float s = 1.;\n    float d = 1.;\n\tfloat ac = 0.0;\n    \n\tconst float iter = 250.;\n    for(float i=0.;i<iter;i++)\n    {      \n        if (abs(s)<d*d*1e-6||d>md) break;\n        s = df(ro+rd*d);\n        s = max(s, 0.01);\n\t\td += s * 0.1;\n    }\n    \n\tif (d<md)\n\t{\n\t\tvec3 p = ro+rd*d;\n\n\t\tcol = shade(ro, rd, d, ro, 1.0);\n\t}\n\telse\n    {\n        col = vec3(0);\n    }   \n    \n\tcol = mix(col, vec3(0), 1.-exp(-0.005*d*d));\n\t\n\tfragColor.rgb = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lsXzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lXGR7", "name": "My Blobby", "author": "lulle", "description": "My little blobby", "tags": ["raymarching", "blobby"], "likes": 3, "viewed": 143, "date": "1562955541", "time_retrieved": "2024-06-20T19:39:34.062227", "image_code": "const float MAX_STEPS = 32.;\nconst float EPS = .001;\nconst float END = 100.;\nconst float START = .0;\nfloat steps;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 uni(vec2 d1, vec2 d2) { \n  float m = d1.y;\n  if (d1.x>d2.x) m = d2.y;\n  return vec2(min(d1.x, d2.x), m);\n}\n\nvec2 suni(vec2 d1, vec2 d2, float k) { \n  float h = clamp(0.5+0.5*(d2.x-d1.x)/k, 0.0, 1.0);\n  float m = d1.y;\n  if (d1.x>d2.x) m = d2.y;\n  return vec2(mix(d2.x,d1.x,h)-k*h*(1.-h), m);\n}\n\nfloat ssubs(float d1, float d2, float k) {\n  float h = clamp(0.5-0.5*(d2+d1)/k, 0.0, 1.0);\n  return mix(d2, -d1, h)+k*h*(1.0-h);\n}\n\nfloat sintsect(float d1, float d2, float k) { \n  float h = clamp(0.5-0.5*(d2-d1)/k, 0.0, 1.0);\n  return mix(d2, d1, h)+k*h*(1.0-h);\n}\n\nfloat sphere(vec3 p, float s) { \n  return length(p)-s;\n}\n\nfloat box(vec3 p, vec3 b) { \n  vec3 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat elli(in vec3 p, in vec3 r) {\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.)/k1;\n}\n  \nfloat cap(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp(dot(pa,ba)/dot(ba,ba), .0, 1.);\n  return length(pa-ba*h)-r;\n}\n\nfloat diss(vec3 p, float s) {\n    float d1 = sphere(p, s); \n    float d2 = (1.+sin(iTime))/2.*.05*(sin(15.*p.x)*cos(15.*p.y)*sin(15.*p.z));\n    return d1+d2;\n}\n\nvec2 sdf(in vec3 p) {\n    vec3 pos = vec3(.0,sin(iTime)*.5,.0);\n    vec2 r = vec2(diss(p-pos,1.),.0);\n    r = uni(r, vec2(sphere(p-vec3(-.3,.3,1.5)-pos, .15), 1.));\n    r = uni(r, vec2(sphere(p-vec3(.3,.3,1.5)-pos, .15), 1.));\n    r = uni(r, vec2(sphere(p-vec3(-.3,.3,1.7)-pos, .05), 2.));\n    r = uni(r, vec2(sphere(p-vec3(.3,.3,1.7)-pos, .05), 2.));\n    r = uni(r, vec2(torus(p-vec3(.0,-.3,1.3)-pos, vec2(max(.05, (1.+sin(iTime))*.2)/2., .03)), 3.));\n    r = suni(r, vec2(elli(p-vec3(.9*(1.+sin(iTime/30.)/4.),-.9*(1.2-sin(iTime)/6.),0.5)-pos, vec3(.2,.3,.4)), 0.), .7);\n    r = suni(r, vec2(elli(p-vec3(-.9*(1.+sin(iTime/30.)/4.),-.9*(1.2-sin(iTime)/6.),0.5)-pos, vec3(.2,.3,.4)), 0.), .7);\n    r = uni(r, vec2(cap(p-vec3(.1,.5,1.0)-pos, vec3(.1,.1,1.0), vec3(.35,.05,1.0), .03), 2.));\n    r = uni(r, vec2(cap(p-vec3(-.1,.5,1.0)-pos, vec3(-.1,.1,1.0), vec3(-.35,.05,1.0), .03), 2.));\n    return r;\n}\n\nvec2 march(vec3 eye, vec3 dir, float s, float e) {\n    float d = s;\n    for (float i = 0.; i < MAX_STEPS; i++) {\n        vec2 res = sdf(eye + d * dir);\n        steps = i;\n        if (res.x < EPS) return vec2(d, res.y);\n        d += res.x;\n        if (d >= e) return vec2(e, .0);\n    }\n    return vec2(e, .0);\n}\n\nvec3 rayDir(float fov, vec2 uv) {\n    vec2 xy = uv * 2. - 1.;\n    xy.y = xy.y / (16. / 9.);\n    float z = 2. / tan(radians(fov / 2.));\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sdf(vec3(p.x + EPS, p.yz)).x - sdf(vec3(p.x - EPS, p.yz)).x,\n        sdf(vec3(p.x, p.y + EPS, p.z)).x - sdf(vec3(p.x, p.y - EPS, p.z)).x,\n        sdf(vec3(p.xy, p.z + EPS)).x - sdf(vec3(p.xy, p.z - EPS)).x\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    if (dotLN < 0.) return vec3(0., 0., 0.);\n    if (dotRV < 0.) return lightIntensity * (k_d * dotLN);\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 amb = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = amb * k_a;\n    vec3 pos1 = vec3(0.0, 1.0*iTime/10.0, 30.0*iTime/20.0);\n    vec3 ints1 = vec3(0.4, 0.4, 0.4);\n    vec3 phong = phongContribForLight(k_d, k_s, alpha, p, eye, pos1, ints1);\n    color += phong;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    vec3 eye = vec3(.0,.0,10.);\n    vec3 dir = rayDir(60.0, uv);\n    vec2 res = march(eye, dir, START, END);\n    vec3 color = vec3(.0);\n    if (res.x >= END-EPS) {\n        float glow = min(max(0.,(steps-15.)*0.08), 1.);\n        fragColor = vec4(vec3(glow), 1.0);\n        return;\n    }\n    vec3 p = eye + dir * res.x;\n    color = vec3(uv, .5+.5*sin(iTime)); \n    if(res.y == 1.) color = vec3(.9);\n    if(res.y == 2.) color = vec3(.0);\n    if(res.y == 3.) color = vec3(.9,.0,.0);\n    color = phongIllumination(color, color, normalize(vec3(1.0, 1.0, 1.0)), 10.0, p, eye);\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lXGR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lXSRj", "name": "AAAAAAAAAAAAAAAAAAAA", "author": "clepirelli", "description": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAa", "tags": ["sdf", "trippy"], "likes": 0, "viewed": 253, "date": "1563463702", "time_retrieved": "2024-06-20T19:39:34.474335", "image_code": "const float CLOSE_ENOUGH = 0.001;\nconst vec3 COLOR = vec3(1.0,.0,.0);\nconst vec3 BG_COLOR = vec3(.15,.0,.0);\nconst vec3 SHADOW_COLOR = clamp((COLOR+vec3(.0,.1,.1))/4.0, .0, 1.0);\n\nstruct sphere\n{\n\tvec3 c;\n    float r;\n};\n\n\nfloat sphereDist(vec3 p, sphere s)\n{\n\treturn distance(p, s.c) - s.r;\n}\n\n//from iq : https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sdf(vec3 p)\n{\n    float returnVal = .0;\n    vec3 rep = vec3(1.0)*(1. + abs(sin(iTime*.11) * 10.0));\n\tvec3 pr = mod(p, rep) - .5 * rep; \n    \n    sphere s1 = sphere(vec3(.0, .1, .0), .07);\n    sphere s2 = sphere(vec3(sin(iTime) * .1, cos(iTime)*.2, .1), .1);\n    sphere s3 = sphere(vec3(.1,.1,.1), .04);\n    returnVal = opSmoothUnion(sphereDist(pr, s1), sphereDist(pr,s2), .2);\n    returnVal = opSmoothUnion(returnVal, sphereDist(pr, s3), .15);\n\treturn returnVal; \n}\n\n//from iq https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 p )\n{\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdf( p + k.xyy*CLOSE_ENOUGH ) + \n                      k.yyx*sdf( p + k.yyx*CLOSE_ENOUGH ) + \n                      k.yxy*sdf( p + k.yxy*CLOSE_ENOUGH ) + \n                      k.xxx*sdf( p + k.xxx*CLOSE_ENOUGH ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n         uv.x *= iResolution.x / iResolution.y;\n\tvec3 cameraPos = vec3(.0,.0,-4.);\n    \n    // Time varying pixel color\n    vec3 ro = vec3(cameraPos.x + uv.x, cameraPos.y + uv.y, cameraPos.z);\n\tvec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    vec3 col = BG_COLOR;\n    float dist = .0;\n    \n    vec3 lightDir = normalize(vec3(1.0, 0.0, -1.0));\n    float renderDistance = 300.0 + abs(sin(iTime*5.0))*300.0;\n    while(dist < renderDistance)\n    {\n        float d = sdf(ro + rd * dist);\n        if(d < CLOSE_ENOUGH)\n        {\n            col = COLOR;\n            vec3 hit = ro + rd * dist;\n    \t\tcol *= mix(SHADOW_COLOR, col, max(dot(calcNormal(hit), lightDir), .0));\n        \tbreak;\n        }\n       \tdist += d;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lXSRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lXSRl", "name": "Infinite colors", "author": "Andre", "description": "Just toying around, i think the 1st minute is worth watching ;)", "tags": ["something"], "likes": 3, "viewed": 364, "date": "1563828140", "time_retrieved": "2024-06-20T19:39:34.680400", "image_code": "const float e = 2.7182818284590452353602874713527;\nfloat noise(vec2 texCoord)\n{\n    float G = e + (iTime * 0.1);\n    vec2 r = (G * sin(G * texCoord.xy));\n    return fract(r.x * r.y * (1.0 + texCoord.x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv -= 0.5;\n    uv *= 13.0;\n    \n    float t = iTime+55.;\n    uv -= t*vec2(3.1,3.5);\n    // Time varying pixel color\n    vec4 col;\n    for (int i=0; i<7; i++) {\n        t *= 1.13879213724+sin(col.r+col.g+col.b)*0.0052863;\n\t    col.r += sin(uv.x*0.4+t);\n\t    col.g += cos(uv.y*0.4+t*1.1379);\n        col.rgba = col.gbar;\n    }\n\n    col.rgb = clamp(col.rgb/7.0+0.5,0.0,1.0);\n    // Output to screen\n    float n = noise(uv);\n    fragColor = vec4(n>col.a?col.rgb:col.rgb*0.977+0.033*col.brg,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lXSRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lXSRX", "name": "x0004 - raytracing - 001", "author": "xigh", "description": "This is a first attempt at doing raytracing with GLSL.", "tags": ["raytracing", "multiplelights"], "likes": 2, "viewed": 304, "date": "1563630621", "time_retrieved": "2024-06-20T19:39:35.238171", "image_code": "// SDF stands for Signed Distance Function :\n//\n// - if point inside surface, return negative value\n// - if point outside surface, return positive value\n// - if point on the surface, return 0\n\nstruct Sdf {\n\tfloat dist;\n    vec3  norm;\n};\n\nSdf sphereSDF(vec3 point, vec3 pos, float radius)\n{\n    return Sdf(\n        length(point-pos) - radius,\n        normalize(point-pos)\n    );    \n}\n\nvec3  light1Pos      = vec3(-1.0, +1.0, +0.0);\nvec3  light1Color    = vec3(+1.0, +0.5, +0.0);\n\nvec3  light2Pos      = vec3(+1.0, +1.0, +0.0);\nvec3  light2Color    = vec3(+0.0, +0.5, +1.0);\n\nvec3  sphere1Pos     = vec3(+0.0, +0.0, +0.0);\nvec3  sphere1Color   = vec3(+1.0, +1.0, +1.0);\n\nvec3 computeScene(in vec3 eyePos, in vec3 eyeDir, in vec2 uv)\n{\n    float depth = -100.0;\n    for (int i = 0; i < 32; i++)\n    {\n        vec3 pt = eyePos + depth * eyeDir;\n\n        Sdf s1 = sphereSDF(pt, sphere1Pos, 1.0);\n        Sdf s2 = sphereSDF(pt, light1Pos, 0.1);\n        Sdf s3 = sphereSDF(pt, light2Pos, 0.1);\n        \n        float d = min(s1.dist, min(s2.dist, s3.dist));\n        if (d < 0.0001)\n        {\n            if (d == s2.dist)\n        \t{\n            \treturn light1Color;\n        \t}\n        \n        \tif (d == s3.dist)\n        \t{\n            \treturn light2Color;\n        \t}\n        \n            // we have a hit, now compute color\n            vec3 normal = s1.norm;\n            \n            float diffuse1 = clamp(dot(normal, normalize(light1Pos)), 0.0, 1.0);\n            float diffuse2 = clamp(dot(normal, normalize(light2Pos)), 0.0, 1.0);\n            \n            vec3 color1 = diffuse1 * light1Color;\n            vec3 color2 = diffuse2 * light2Color;\n            \n            return mix(color1, color2, 0.5) + sphere1Color * 0.7;\n        }\n        \n        depth += d;\n        if (depth > 100.0)\n            break;\n    }\n\n    return vec3(smoothstep(0.0, 1.0, max(0.0, 0.1-uv.y)));\n}\n\nconst float PI = 3.1415;\n\nvoid moveLights()\n{\n    light1Pos.xz = 2.0 * vec2(sin(iTime), cos(iTime));\n    light1Pos.y = +2.5;\n\n    light2Pos.xz = 2.0 * vec2(sin(iTime+PI), cos(iTime+PI));\n    light2Pos.y = +2.5;\n}\n\nvoid moveSphere()\n{\n    sphere1Pos.xz = vec2(0.0);\n    sphere1Pos.y = -0.5 + sin(iTime*2.1)/2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // prepare coordinate so that :\n    //     -1.0 <= ux.y <= +1.0\n    // and -rat <= ux.x <= +rat\n    vec2 uv = (fragCoord/iResolution.xy)-0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    moveLights();\n    moveSphere();\n\n    // define camera position and direction\n\tvec3 camPos = vec3(0.0, 0.5, 20.0);\n    vec3 camDir = normalize(vec3(uv, -1.0 / tan(PI/10.0)));\n\n    // compute scene\n    vec3 col = computeScene(camPos, camDir, uv);\n    fragColor = vec4(vec3(col),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lXSRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lXXR4", "name": "font test 1", "author": "bernie_freidin", "description": "my version of the text render utility, much easier to use (for me)", "tags": ["font"], "likes": 1, "viewed": 95, "date": "1562164048", "time_retrieved": "2024-06-20T19:39:36.692618", "image_code": "// based on https://www.shadertoy.com/view/MtyXDV\n\n#define FONT_ROWS 20 // determines font size\n#define FONT_SPACE 0.5\n\n#define _BACKSPACE          font_current_textpos.x -= FONT_SPACE;\n#define _SPACE              font_current_textpos.x += FONT_SPACE;\n#define _SPACE_n(n)         font_current_textpos.x += FONT_SPACE*float(n);\n#define _NOTESYMBOL         DrawChar(10);\n#define _STARSYMBOL         DrawChar(28);\n#define _SMILEYSYMBOL       DrawChar(29);\n#define _EXCLAMATION        DrawChar(33);\n#define _DOUBLEQUOTE        DrawChar(34);\n#define _HASH               DrawChar(35);\n#define _DOLLARSIGN         DrawChar(36);\n#define _PERCENTSIGN        DrawChar(37);\n#define _AMPERSAND          DrawChar(38);\n#define _SINGLEQUOTE        DrawChar(39);\n#define _OPENPARENTHESIS    DrawChar(40);\n#define _CLOSEPARENTHESIS   DrawChar(41);\n#define _ASTERISK           DrawChar(42);\n#define _PLUSSIGN           DrawChar(43);\n#define _COMMA              DrawChar(44);\n#define _MINUSSIGN          DrawChar(45);\n#define _PERIOD             DrawChar(46);\n#define _FORWARDSLASH       DrawChar(47);\n\n#define _COLON              DrawChar(58);\n#define _SEMICOLON          DrawChar(59);\n#define _LESSTHANSIGN       DrawChar(60);\n#define _EQUALSIGN          DrawChar(61);\n#define _GREATERTHANSIGN    DrawChar(62);\n#define _QUESTIONMARK       DrawChar(63);\n#define _ATSIGN             DrawChar(64);\n\n#define _OPENSQUAREBRACKET  DrawChar(91);\n#define _BACKSLASH          DrawChar(92);\n#define _CLOSESQUAREBRACKET DrawChar(93);\n#define _CARET              DrawChar(94);\n#define _UNDERSCORE         DrawChar(95);\n#define _GRAVE              DrawChar(96);\n\n#define _OPENCURLYBRACKET   DrawChar(123);\n#define _VERTICALBAR        DrawChar(124);\n#define _CLOSECURLYBRACKET  DrawChar(125);\n#define _TILDE              DrawChar(126);\n\n#define _PARENTHESIS(text) _OPENPARENTHESIS text _CLOSEPARENTHESIS\n#define _SQUAREBRACKET(text) _OPENSQUAREBRACKET text _CLOSESQUAREBRACKET\n#define _CURLYBRACKET(text) _OPENCURLYBRACKET text _CLOSECURLYBRACKET\n\n#ifndef KEY_0\n#define KEY_0 48\n#endif\n\n#define DrawDigit(x) DrawChar(KEY_0 + int(x));\n#define _0 DrawDigit(0);\n#define _1 DrawDigit(1);\n#define _2 DrawDigit(2);\n#define _3 DrawDigit(3);\n#define _4 DrawDigit(4);\n#define _5 DrawDigit(5);\n#define _6 DrawDigit(6);\n#define _7 DrawDigit(7);\n#define _8 DrawDigit(8);\n#define _9 DrawDigit(9);\n\n#define _A DrawChar(65);\n#define _B DrawChar(66);\n#define _C DrawChar(67);\n#define _D DrawChar(68);\n#define _E DrawChar(69);\n#define _F DrawChar(70);\n#define _G DrawChar(71);\n#define _H DrawChar(72);\n#define _I DrawChar(73);\n#define _J DrawChar(74);\n#define _K DrawChar(75);\n#define _L DrawChar(76);\n#define _M DrawChar(77);\n#define _N DrawChar(78);\n#define _O DrawChar(79);\n#define _P DrawChar(80);\n#define _Q DrawChar(81);\n#define _R DrawChar(82);\n#define _S DrawChar(83);\n#define _T DrawChar(84);\n#define _U DrawChar(85);\n#define _V DrawChar(86);\n#define _W DrawChar(87);\n#define _X DrawChar(88);\n#define _Y DrawChar(89);\n#define _Z DrawChar(90);\n\n#define _a DrawChar(97);\n#define _b DrawChar(98);\n#define _c DrawChar(99);\n#define _d DrawChar(100);\n#define _e DrawChar(101);\n#define _f DrawChar(102);\n#define _g DrawChar(103);\n#define _h DrawChar(104);\n#define _i DrawChar(105);\n#define _j DrawChar(106);\n#define _k DrawChar(107);\n#define _l DrawChar(108);\n#define _m DrawChar(109);\n#define _n DrawChar(110);\n#define _o DrawChar(111);\n#define _p DrawChar(112);\n#define _q DrawChar(113);\n#define _r DrawChar(114);\n#define _s DrawChar(115);\n#define _t DrawChar(116);\n#define _u DrawChar(117);\n#define _v DrawChar(118);\n#define _w DrawChar(119);\n#define _x DrawChar(120);\n#define _y DrawChar(121);\n#define _z DrawChar(122);\n\nvec2 font_current_textpos = vec2(0);\nvec2 font_uv = vec2(0); // fragCoord\nvec4 font_current_color = vec4(1);\nvec2 font_deferred_uv = vec2(-1);\nvec4 font_deferred_color = vec4(0);\nfloat font_overdraw = 0.0; // debugging\n\nvoid FontSetPositionf(float col, float row)\n{\n\tfont_current_textpos = -float(FONT_ROWS)*font_uv;\n\tfont_current_textpos.x += col*FONT_SPACE - 0.15;\n\tfont_current_textpos.y -= row - float(FONT_ROWS) + 1.0;\n}\n\nvoid FontSetPosition(int col, int row)\n{\n\tFontSetPositionf(float(col), float(row));\n}\n\nvoid FontSetColor(vec4 color)\n{\n\tfont_current_color = color;\n}\n\nvoid FontInit(vec2 uv)\n{\n\tfont_uv = uv;\n\tFontSetPosition(0, 0);\n}\n\nvoid FontRender(sampler2D fontSampler, inout vec3 background)\n{\n\tvec4 fc = font_deferred_color;\n\tif (fc.a > 0.0) {\n\t\tfc.a *= texture(fontSampler, font_deferred_uv).r;\n\t\tbackground = mix(background, fc.rgb, fc.a);\n\t\tfont_deferred_color = vec4(0);\n\t}\n\tbackground += vec3(font_overdraw*0.2);\n\tfont_overdraw = 0.0;\n}\n\nvoid DrawChar(int ch)\n{\n\tconst vec2 inset = vec2(0.265, 0.05);\n\tvec2 tp = -font_current_textpos;\n\t_SPACE\n\tif (all(greaterThan(vec4(tp, vec2(1) - inset.xy), vec4(inset.xy, tp)))) {\n\t\tfont_deferred_uv = 0.0625*(tp + vec2(ch - (ch/16)*16, 15 - ch/16));\n\t\tfont_deferred_color = font_current_color;\n\t\t//font_overdraw += 1.0;\n\t}\n}\n\nvoid DrawUIntFillZeros(uint x, uint digits)\n{\n\tuint d = 1U;\n\tbool fill_zeros = (digits != 0U);\n\tif (digits == 0U) {\n\t\twhile (d <= x) {\n\t\t\td *= 10U;\n\t\t\tdigits++;\n\t\t}\n\t}\n\tif (fill_zeros) {\n\t\tfor (uint i = 0U; i < digits; i++)\n\t\t\tDrawDigit(0U);\n\t} else\n\t\t_SPACE_n(digits)\n\tfloat x0 = font_current_textpos.x;\n\t_BACKSPACE\n\twhile (x != 0U) {\n\t\tDrawDigit(x%10U);\n\t\t_BACKSPACE\n\t\t_BACKSPACE\n\t\tx /= 10U;\n\t}\n\tfont_current_textpos.x = x0;\n}\n\nvoid DrawUInt(uint x)\n{\n\tif (x == 0U) { DrawDigit(0U); return; }\n\tDrawUIntFillZeros(x, 0U);\n}\n\nvoid DrawInt(int x)\n{\n\tif (x == 0) { DrawDigit(0U); return; }\n\tif (x < 0) { _MINUSSIGN x = -x; }\n\tDrawUIntFillZeros(uint(x), 0U);\n}\n\nvoid DrawFloatDigits(float x, uint digits)\n{\n\tif (x < 0.0) { _MINUSSIGN x = -x; }\n\tfloat d = pow(10.0, float(digits));\n\tx += 0.5/d;\n\tDrawUInt(uint(x));\n\t_PERIOD\n\tDrawUIntFillZeros(uint(fract(x)*d), digits);\n}\n\nvoid DrawFloat(float x)\n{\n\tconst uint defaultDigits = 3U;\n\tDrawFloatDigits(x, defaultDigits);\n}\n\nvoid DrawBool(bool x)\n{\n\tif (x) { _T _R _U _E }\n\telse { _F _A _L _S _E }\n}\n\nvoid DrawIntVec2(ivec2 v) { _OPENPARENTHESIS DrawInt(v.x); _COMMA DrawInt(v.y); _CLOSEPARENTHESIS }\nvoid DrawIntVec3(ivec3 v) { _OPENPARENTHESIS DrawInt(v.x); _COMMA DrawInt(v.y); _COMMA DrawInt(v.z); _CLOSEPARENTHESIS }\nvoid DrawIntVec4(ivec4 v) { _OPENPARENTHESIS DrawInt(v.x); _COMMA DrawInt(v.y); _COMMA DrawInt(v.z); _COMMA DrawInt(v.w); _CLOSEPARENTHESIS }\n\nvoid DrawUIntVec2(uvec2 v) { _OPENPARENTHESIS DrawUInt(v.x); _COMMA DrawUInt(v.y); _CLOSEPARENTHESIS }\nvoid DrawUIntVec3(uvec3 v) { _OPENPARENTHESIS DrawUInt(v.x); _COMMA DrawUInt(v.y); _COMMA DrawUInt(v.z); _CLOSEPARENTHESIS }\nvoid DrawUIntVec4(uvec4 v) { _OPENPARENTHESIS DrawUInt(v.x); _COMMA DrawUInt(v.y); _COMMA DrawUInt(v.z); _COMMA DrawUInt(v.w); _CLOSEPARENTHESIS }\n\nvoid DrawFloatVec2(vec2 v) { _OPENPARENTHESIS DrawFloat(v.x); _COMMA DrawFloat(v.y); _CLOSEPARENTHESIS }\nvoid DrawFloatVec3(vec3 v) { _OPENPARENTHESIS DrawFloat(v.x); _COMMA DrawFloat(v.y); _COMMA DrawFloat(v.z); _CLOSEPARENTHESIS }\nvoid DrawFloatVec4(vec4 v) { _OPENPARENTHESIS DrawFloat(v.x); _COMMA DrawFloat(v.y); _COMMA DrawFloat(v.z); _COMMA DrawFloat(v.w); _CLOSEPARENTHESIS }\n\n// examples\nvoid DrawABC()\n{\n\t_A _B _C\n}\n\nvoid DrawABC_0123()\n{\n\tDrawABC(); _SPACE _0 _1 _2 _3\n}\n\nvoid DrawHelloWorld()\n{\n\t_H _e _l _l _o _SPACE _W _o _r _l _d _STARSYMBOL\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = fragCoord/iResolution.xy;\n\n\t// Time varying pixel color\n\tvec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n\tfragColor = vec4(col,1);\n\n\tFontInit(fragCoord/iResolution.y);\n\n\tfor (int shadow = 1; shadow >= 0; shadow--) {\n\t\tvec4 color = bool(shadow) ? vec4(0,0,0,0.5) : vec4(1);\n\t\tfloat off = bool(shadow) ? 0.1 : 0.0;\n\n\t\tFontSetPositionf(off, off);\n\t\tFontSetColor(color);\n\t\tDrawABC_0123();\n\n\t\tFontSetPositionf(off, 1.0 + off);\n\t\tFontSetColor(color);\n\t\tDrawABC();\n\n\t\tfloat mx = 2000.0*iMouse.x/iResolution.x;\n\t\tfloat my = -1.0 + 2.0*iMouse.y/iResolution.y;\n\t\t_SPACE _x _EQUALSIGN DrawFloatDigits(mx, 5U);\n\t\t_SPACE _y _EQUALSIGN DrawFloat(my);\n\t\t_SPACE _y _PARENTHESIS(_r _o _u _n _d) _EQUALSIGN DrawFloatDigits(my, 1U);\n\n\t\tFontRender(iChannel0, fragColor.rgb);\n\t}\n\n\tFontSetPosition(1, 2);\n\tFontSetColor(vec4(0.5,1,0.5,1));\n\tDrawABC();\n\n\tFontSetPosition(0,FONT_ROWS - 1);\n\tDrawHelloWorld();\n\n\tFontRender(iChannel0, fragColor.rgb);\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lXXR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lXXR8", "name": "sphere vortex", "author": "cmarangu", "description": "Inspired by [url=https://twitter.com/SeanWal49402031/status/1188159030436487168]Sean Walker's gifs[/url]\n\n[b]VARIATIONS:[/b] [url]https://twitter.com/c010011012/status/1275841326408318979[/url]\n\nI only check 9 spheres per pixel >:​)", "tags": ["conformal", "raytacing", "skymap"], "likes": 16, "viewed": 564, "date": "1561959373", "time_retrieved": "2024-06-20T19:39:39.311149", "image_code": "// /*\n// Current code for: \"sphere vortex\"\n// Started: 2020 2/14 (before then)\n// Tags: conformal, raytacing, skymap\n// Description: wip\n// - Updated: 2020 3/21 cleaned up the code by making it\n//   alot longer but more precise, now you can rotate view, started\n//   raymarching solution (slower but more accurate)\n// - Updated: 2020 4/1 worked on the shading, added more features\n// - Updated: 2020 4/8 starting from scratch again to get the shading right\n// - Updated: 2020 5/29 going to store phase level with coords in vec3's\n//   - Trying to clean up code and have necessary features\n//   - Adding a complex_pow function which can raise any vec2 to the power of another\n// - Updated: 2020 5/30 I think I've mostly fixed problems with phase_level by implementing\n//   code which stores the integer representing the actual phase in an array, but the \"array\"\n//   is actually a \"stack\" of integers represented by 1 other integer (its complicated)\n// - Updated: 2020 3/20 replaced this nonsense weave_ints and untwine_int functions\n//   with normal float arrays. Been toying with phase plotters like the davidbau.com one to\n//   find new vortecies (like a triple vortex and others)\n\n// TODO\n// clean up code a bit (i guess)\n// project is mostly finished\n// distribute across time between frames? motion blur/frame blending\n\n\n\n\n#define arg mod(float(iFrame)/30., 1.)\n#define PI 3.141592653589793238462643383279502884197169399375105820974944592307816\n// i know more\n#define TAU (2.*PI)\n\n#define sphere_scaling 1.\n\n\n\n\n// sky map\n#define sund normalize(vec3(2.5, 1.5, -.5))\n\nvec3 sky_map (vec3 d) {\n\tfloat dimness = .5+.5*cos(d.y*PI);\n\tdimness = pow(dimness, 1.);\n\t\n\t// return texture(iChannel1, d).rgb;\n\t\n\tvec2 g = vec2(d.x/d.y, d.z/d.y)*2.*sign(d.y);\n\t\n\t// get ths sky color\n\tfloat cloudamt = 0.;\n\tcloudamt += .7*texture(iChannel1, vec2(g.x+g.y, g.x-g.y)/430.).r;\n\tcloudamt += .3*texture(iChannel1, vec2(g.x+g.y, g.x-g.y)/150.).r;\n\tcloudamt = pow(cloudamt, 2.);\n\t\t// cloudamt *= .4;\n\t\t// cloudamt += .0*texture(iChannel1, vec2(g.x+g.y, g.x-g.y)/90.).r;\n\t\tfloat sunamt = clamp(dot(d, sund), 0., 1.);\n\t\tfloat sunglow = pow(sunamt, 20.);\n\t\t\n\t\tvec3 SKY_COLOR = vec3(.0, .5, 1.);\n\t\tSKY_COLOR += cloudamt;\n\t\t// SKY_COLOR *= 1.-sunhalo;\n\t\t// SKY_COLOR += vec3(1., .9, .6)*sunhalo;\n\t\tSKY_COLOR *= 1.-sunglow;\n\t\tSKY_COLOR += vec3(1., 1., 1.)*sunglow;\n\t\t\n\t\tdimness = mix(dimness, 1., sunglow);\n\t\t// dimness = mix(dimness, 1., sunhalo);//sunamt*sunamt);\n\tif (d.y > .2) {\n\t\treturn SKY_COLOR*pow(dimness, .05)*mix(.7, 1., sunglow);\n\t}\n\telse {\n\t\t// return vec3(1.)*mod(floor(g.x)+floor(g.y), 2.);\n\t\tvec3 GROUND_COLOR = vec3(.3, .5, .3)*(.0+.8*texture(iChannel1, g/10.).r);\n\t\tfloat dirtamt = texture(iChannel1, g/54.).r;\n\t\tGROUND_COLOR *= 1.-dirtamt;\n\t\tGROUND_COLOR += vec3(.5, .3, .0)*dirtamt;\n\t\t\n\t\tGROUND_COLOR = 3.*GROUND_COLOR*GROUND_COLOR-2.*GROUND_COLOR*GROUND_COLOR*GROUND_COLOR;\n\t\tGROUND_COLOR = 3.*GROUND_COLOR*GROUND_COLOR-2.*GROUND_COLOR*GROUND_COLOR*GROUND_COLOR;\n\t\tGROUND_COLOR = 3.*GROUND_COLOR*GROUND_COLOR-2.*GROUND_COLOR*GROUND_COLOR*GROUND_COLOR;\n\t\tGROUND_COLOR *= 17.;\n\t\tGROUND_COLOR = clamp(GROUND_COLOR, 0., 1.);\n\t\t\n\t\tfloat puddleamt = .5+.5*sin(g.x*length(g)*.05);\n\t\tpuddleamt = .5*puddleamt+.5*texture(iChannel1, vec2(g.x, g.y)/20.).r;\n\t\tpuddleamt = pow(puddleamt, .3);\n\t\tdimness = mix(dimness, 1., puddleamt)*.5;\n\t\t\n\t\tif (puddleamt > .8) {\n\t\t\tfloat amt = (puddleamt-.3)/.6;\n\t\t\tamt = clamp(amt, 0., 1.);\n\t\t\tamt = pow(amt, 2.);\n\t\t\tGROUND_COLOR = mix(GROUND_COLOR, SKY_COLOR+vec3(.4), amt);\n\t\t}\n\t\t\n\t\tif (-.2 <= d.y && d.y <= .2) {\n\t\t\tfloat amt = (d.y+.2)/.4;\n\t\t\tdimness = mix(\n\t\t\t\tdimness,\n\t\t\t\tmix(\n\t\t\t\t\tdimness*2.,\n\t\t\t\t\t1.,\n\t\t\t\t\t-puddleamt\n\t\t\t\t),\n\t\t\t\tamt\n\t\t\t);\n\t\t\tamt = 3.*amt*amt-2.*amt*amt*amt;\n\t\t\tamt = 3.*amt*amt-2.*amt*amt*amt;\n\t\t\tamt = 3.*amt*amt-2.*amt*amt*amt;\n\t\t\tGROUND_COLOR = mix(GROUND_COLOR, SKY_COLOR, amt);\n\t\t}\n\t\treturn GROUND_COLOR*dimness*mix(0., 1., clamp(abs(d.y)*12., 0., 1.));\n\t\n\t}\n\t\n}\n\n\n\n\n// conformap transforms\n\n#define complex_exp(z) vec3(exp(z.x)*vec2(cos(z.y), sin(z.y)), floor(z.y/TAU) )\n#define complex_ln(Z) vec3(\\\n\tlog(length(Z.xy)),\\\n\tmod(atan(Z.y, Z.x), TAU)+Z.z*TAU,\\\n\tZ.z\\\n)\n\nvec3 complex_multZK (vec3 z, vec3 k) {\n\tfloat th = mod(atan(z.y, z.x), TAU)+z.z*TAU;\n\tfloat ph = mod(atan(k.y, k.x), TAU)+z.z*TAU;\n\treturn vec3(\n\t\t(length(z.xy)*length(k.xy))*vec2(cos(th+ph), sin(th+ph)),\n\t\tfloor(th/TAU+ph/TAU)\n\t);\n}\n\nvec3 complex_powZK (vec3 z, vec3 k) {\n\tfloat th = mod(atan(z.y, z.x), TAU)+z.z*TAU;\n\treturn vec3(\n\t\tpow(length(z.xy), k.x)*vec2(cos(th*k.x), sin(th*k.x)),\n\t\tfloor(th*k.x/TAU)\n\t);\n}\n\n#define phaselen 3\n\nvec3 f (vec3 z, float[phaselen] phaselvl) {\n\t#define scl 26./TAU\n\t#define zoom 1.3\n\t#define pan vec2(0., 0.)\n\tint lvli = phaselen-1;\n\t\n\tz.x -= arg;\n\t\n\tz.xy /= scl;\n\t\n\t#if 1\n\tz.z = phaselvl[lvli];\n\t--lvli;\n\t//z = complex_multZK(z, vec3(.5, -.5, -1.) );\n\tz.xy = vec2(z.x*.5+z.y*.5, -z.x*.5+z.y*.5);\n\tz = complex_exp(z);\n\t#endif\n\t\n\t#if 0\n\t// complex arctangent\n\t// atan(z) = (1/2i)ln(-z+i/z+i)\n\tz.z = phaselvl[lvli];\n\t--lvli;\n\tz = complex_multZK(\n\t\tvec3(0., 1., 0.)+complex_multZK(z, vec3(-1., 0., 0.) ),\n\t\tcomplex_powZK(\n\t\t\tvec3(0., 1., 0.)+z,\n\t\t\tvec3(-1., 0., 0.)\n\t\t)\n\t);\n\tz.z = phaselvl[lvli];\n\t--lvli;\n\tz = complex_ln(z);\n\tz = complex_multZK(z, vec3(0., -.5, 0.));\n\t#endif\n\t\n\t\n\t// mobius\n\tz.x += .2;\n\tfloat th = mod(atan(z.y, z.x), TAU)+z.z*TAU;\n\tz.xy = vec2(cos(-th), sin(-th))/length(z.xy);\n\tz.x -= 2.;\n\t\n\t//z.xy = vec2(z.x*.5+z.y*.5, -z.x*.5+z.y*.5);\n\t\n\tz.xy *= zoom;\n\tz.xy += pan;\n\treturn z;\n\t\n}\nvec3 inv_f (vec3 z, out float[phaselen] phaselvl) {\n\tint lvli = 0;\n\t\n\tz.xy -= pan;\n\tz.xy /= zoom;\n\t\n\t//z.xy = vec2(z.x-z.y, z.x+z.y);\n\t\n\t// mobius\n\tz.x += 2.;\n\tfloat th = mod(atan(z.y, z.x), TAU)+z.z*TAU;\n\tz.xy = vec2(cos(-th), sin(-th))/length(z.xy);\n\tz.x -= .2;\n\t\n\t#if 0\n\t// complex tangent\n\t// 2i*z then e^z then blah\n\t// tan(z) = blah(  iz-i/-z-1  )\n\tz = complex_multZK(z, vec3(0., 2., 0.));\n\tz = complex_exp(z);\n\tphaselvl[lvli] = z.z;\n\t++lvli;\n\tz = complex_multZK(\n\t\tvec3(0., -1., 0.)+complex_multZK(z, vec3(0., 1., 0.)),\n\t\tcomplex_powZK(\n\t\t\tvec3(-1., 0., 0.)+complex_multZK(z, vec3(-1., 0., 0.)),\n\t\t\tvec3(-1., 0., 0.)\n\t\t)\n\t);\n\tphaselvl[lvli] = z.z;\n\t++lvli;\n\t#endif\n\t\n\t#if 1\n\tz = complex_ln(z);\n\t//z = complex_multZK(z, vec3(1., 1., 0.));\n\tz.xy = vec2(z.x-z.y, z.x+z.y);\n\tphaselvl[lvli] = z.z;\n\t++lvli;\n\t#endif\n\t\n\tz.xy *= scl;\n\t\n\tz.x += arg;\n\t\n\t\n\treturn z;\t\n}\n\n\n\n// related to tracing onto various surfaces\n#define inter_sky vec4(vec3(0.), 1e9)\n\nvec4 inter_sphere (vec3 p, vec3 d, vec3 c, float r, bool insideout) {\n\t// if 1 to use raymarching for slower but more accurate sphere intersections\n\t#if 0\n\t\n\tif (!insideout) {\n\t\tfloat w1 = 1e9;\n\t\tr *= 1.5;\n\t\tfloat bsign = !insideout ? -1. : 1.;\n\t\tvec3 bar = c-p;\n\t\tfloat h = length(bar);\n\t\tfloat a = h*dot(normalize(bar), d);\n\t\tfloat o = sqrt(h*h-a*a);\n\t\tif (o <= r) {\n\t\t\tfloat bevel = sqrt(r*r-o*o);\n\t\t\tvec3 hitp = p+d*(a+bsign*bevel);\n\t\t\tw1 = a+bsign*bevel;\n\t\t\tp += d*w1;\n\t\t}\n\t\tr /= 1.5;\n\t}\n\tvec3 camp = p;\n\tfloat SDFp = length(p-c)-r;\n\tp += d*abs(SDFp)*.2;\n\tint hits = 0;\n\tfor (int mrch=0; mrch<260; ++mrch) {\n\t\tSDFp = length(p-c)-r;\n\t\tif (mrch > 5 && SDFp > 10.) {\n\t\t\tbreak;\n\t\t}\n\t\tif (abs(SDFp) < 1e-3) {\n\t\t\tif (insideout && hits < 1) {\n\t\t\t\thits++;\n\t\t\t\tp += d*SDFp;\n\t\t\t\tp += d*1e-2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn vec4(\n\t\t\t\t\tnormalize(p-c),\n\t\t\t\t\tlength(p-camp)//*sign(length(p-c)-r)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tp += d*abs(SDFp)*.99;\n\t}\n\treturn inter_sky;\n\t#endif\n\tfloat bsign = !insideout ? -1. : 1.;\n\tvec3 bar = c-p;\n\tfloat h = length(bar);\n\tfloat a = h*dot(normalize(bar), d);\n\tfloat o = sqrt(h*h-a*a);\n\tif (o <= r) {\n\t\tfloat bevel = sqrt(r*r-o*o);\n\t\tvec3 hitp = p+d*(a+bsign*bevel);\n\t\treturn vec4(\n\t\t\tnormalize(hitp-c),\n\t\t\ta+bsign*bevel\n\t\t);\n\t}\n\treturn inter_sky;\n}\n\n\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\t///*\n\t#define spp 1\n\tvec3 finalCol = vec3(0.);\n\tvec3 randy; randy = vec3(0.);\n\t#if spp == 1\n\t#define samplei 0.\n\t#else\n\tfor (float samplei=0.; samplei<float(spp); ++samplei) {\n\t#endif\n\t\t\n\t\t#if 0\n\t\trandy = vec3(\n\t\t\tfract(sin(\n\t\t\t\tmod(\n\t\t\t\t\tsamplei*21.463049023049+float(iFrame+int(fragCoord.x) )*0.021415,\n\t\t\t\t\tTAU\n\t\t\t\t)\n\t\t\t)),\n\t\t\tfract(sin(\n\t\t\t\tmod(\n\t\t\t\t\tsamplei*421.83743204984+float(iFrame+int(fragCoord.x) )*8.234203,\n\t\t\t\t\tTAU\n\t\t\t\t)\n\t\t\t)),\n\t\t\tfract(sin(\n\t\t\t\tmod(\n\t\t\t\t\tsamplei*952.13454543556+float(iFrame)*8.234203,\n\t\t\t\t\tTAU\n\t\t\t\t)\n\t\t\t))\n\t\t);\n\t\t#endif\n\t\t\n\t\tvec2 screen = vec2(fragCoord+randy.xy-iResolution.xy/2.)/iResolution.y;\n\t\tvec3 camp = vec3(0., 0., 0.);\n\t\tvec3 camd = normalize(vec3(screen.x, screen.y, 1.));\n\t\t\n\t\t\n\t\tvec4 inter_closest = inter_sky;\n\t\tint closest_id;\n\t\tvec3 closest_center = vec3(0.);\n\t\tfloat closest_r = 0.;\n\t\t\n\t\tvec2 zxy = screen*5.;\n\t\tvec3 z = vec3(zxy, 0.);\n\t\t\n\t\tfloat[phaselen] phaselvl;\n\t\tfloat[phaselen] phaselvl2;\n\t\t\n\t\tvec3 guess2 = inv_f(z, phaselvl);\n\t\tphaselvl2 = phaselvl;\n\t\tguess2.xy = floor(guess2.xy);\n\t\tvec3 guess;\n\t\t\n\t\t\n\t\t\n\t\tfloat lvli;\n\t\tfor (float ox=-1.; ox<=1.; ++ox) {\n\t\tfor (float oy=-1.; oy<=1.; ++oy) {\n\t\t#define phaseoff 0\n\t\t#if phaseoff\n\t\t//for (float oP=0.; oP<pow(3., float(phaselen)); ++oP) {\n\t\tfor (float oP=0.; oP<pow(3., 1.); ++oP) {\n\t\t#else\n\t\t#define oP 0.\n\t\t#endif\n\t\t\tguess = guess2;\n\t\t\tguess.xy = guess.xy+vec2(.5, .5)+vec2(ox, oy);\n\t\t\t//guess.z = guess.z+oP;\n\t\t\t\n\t\t\tphaselvl = phaselvl2;\n\t\t\t#if phaseoff\n\t\t\tphaselvl[0] += mod(oP, 3.)-1.;\n\t\t\t//for (lvli=0.; lvli<phaselen; ++lvli) {\n\t\t\t//  phaselvl[int(lvli)] += mod(floor(oP/pow(3., lvli)), 3.)-1.;\n\t\t\t//}\n\t\t\t#endif\n\t\t\t\n\t\t\t#if 1\n\t\t\t// does not use 3 points method\n\t\t\tvec2 cen = f(guess, phaselvl).xy;\n\t\t\tfloat r = length(f(guess+vec3(.07, 0., 0.), phaselvl).xy-cen.xy)/.07*.5;\n\t\t\tr = min(r, length(f(guess+vec3(0., .07, 0.), phaselvl).xy-cen.xy)/.07*.5);\n\t\t\t#else\n\t\t\t// uses 3 points method\n\t\t\tvec2 a = f(guess+vec3(0., .5, 0.), phaselvl, randy).xy;\n\t\t\tvec2 cen = circle_from3pts(\n\t\t\t\ta,\n\t\t\t\tf(guess+vec3(-.5, 0., 0.), phaselvl).xy,\n\t\t\t\tf(guess+vec3(0., -.5, 0.), phaselvl).xy\n\t\t\t);\n\t\t\tfloat r = length(a.xy-cen.xy);\n\t\t\t#endif\n\t\t\tvec3 sphc = vec3(cen.x, cen.y, 5.);\n\t\t\tr *= sphere_scaling;\n\t\t\tif (r > 10.) { continue; }\n\t\t\tr = min(r, .5);\n\t\t\t//r = max(r, .00001);\n\t\t\t\n\t\t\t// only check blue spheres cos its cooler\n\t\t\t// cover up ugly floating point artifacts/white noise\n\t\t\t// if (max(abs(guess.y), abs(guess.x*.9)) > 3e1) { continue; }\n\t\t\t//if (r < .002) { continue; }\n\t\t\t\n\t\t\tvec4 inter_current = inter_sphere(\n\t\t\t\tcamp, camd, sphc, r, false\n\t\t\t);\n\t\t\t\n\t\t\t\n\t\t\tif (inter_current.w < inter_sky.w) {\n\t\t\t\tif (inter_closest.w >= inter_sky.w) {\n\t\t\t\t\tinter_closest = inter_current;\n\t\t\t\t\tclosest_center = sphc;\n\t\t\t\t\tclosest_r = r;\n\t\t\t\t\tclosest_id = 1+1*int( mod(guess.y, 2.) );\n\t\t\t\t}\n\t\t\t\telse if (inter_current.w < inter_closest.w) {\n\t\t\t\t\tinter_closest = inter_current;\n\t\t\t\t\tclosest_center = sphc;\n\t\t\t\t\tclosest_r = r;\n\t\t\t\t\tclosest_id = 1+1*int( mod(guess.y, 2.) );\n\t\t\t\t}\n\t\t\t}\n\t\t}}\n\t\t#if phaseoff\n\t\t}\n\t\t#endif\n\t\t\n\t\t\n\t\t// rendering lol\n\t\tvec3 retina = vec3(0., 0., 100./255.);\n\t\tif (inter_closest.w < inter_sky.w) {\n\t\t\t// There is a sphere, shade it\n\t\t\tvec3 specular = sky_map(reflect(camd, inter_closest.xyz));\n\t\t\tfloat specularh = length(specular)/sqrt(3.);\n\t\t\t\n\t\t\t\n\t\t\tif (closest_id == 1) {\n\t\t\t\t// pearly white\n\t\t\t\tfloat diffuse = clamp(dot(inter_closest.xyz, sund), 0., 1.);\n\t\t\t\t// specularh = 3.*specularh*specularh-2.*specularh*specularh*specularh;\n\t\t\t\tspecularh = pow(specularh, 4.);\n\t\t\t\tretina = vec3(.53)+vec3(.6)*diffuse+specularh*.7;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// heres for blue bubble\n\t\t\t\tvec4 inter_inside = inter_sphere(camp, camd, closest_center, closest_r, true);\n\t\t\t\tvec2 glob = vec2(\n\t\t\t\t\t.5+.5*dot(inter_inside.xyz, normalize(vec3(0., -1., .5)) ),\n\t\t\t\t\t.5+.5*dot(inter_closest.xyz, normalize(vec3(0., -1., .5)) )\n\t\t\t\t);\n\t\t\t\tfloat glo = length(glob)/sqrt(2.);\n\t\t\t\t\n\t\t\t\tglo = 3.*glo*glo-2.*glo*glo*glo;\n\t\t\t\tglo = pow(glo, 1.7);\n\t\t\t\t\n\t\t\t\tspecularh = 3.*specularh*specularh-2.*specularh*specularh*specularh;\n\t\t\t\tspecularh = pow(specularh, 1.5);\n\t\t\t\t\n\t\t\t\tfloat glo2 = pow(glo, 2.);\n\t\t\t\tretina = vec3(.0, .3, .5) + vec3(.0*glo2, .5*glo2, .5*glo) + vec3(1.)*specularh*.95;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfinalCol += retina;\n\t#if spp != 1\n\t}\n\t#endif\n\tfinalCol /= float(spp);\n\tfragColor = vec4(finalCol, 1.);/*/\n\tfloat phaselvl[phaselen];\n\tvec2 screen = (fragCoord.xy-iResolution.xy/2.)/iResolution.y;\n\tvec3 z = vec3(screen.xy*5., 0.);\n\tz = inv_f(z, phaselvl);\n\tfloat a = mod(z.x, 1.);\n\tfloat b = mod(z.y, 1.);\n\tfragColor = vec4(min(a, b), a, max(a, b), 1.);\n\t/**/\n}\n\n\n\n\n\n\n\n\n\n\n\n// Old code for: \"some circle inversion nonsense\"\n// Created: 2019-07-01\n// Tags: blue, circleinversion, cyan, inversegeometry\n// Description: \"inverting points across a circle whose\n//               center and radius vary by the mouse position\n//               and then finding what their colors are on the\n//               tiling of the plane\"\n// // speeds can be anything from -1 to 1\n// \n// \n// float speedx = 0.25;\n// float speedy = 0.25;\n// \n// vec2 invrted(vec2 p, vec2 cc, float cr) {\n// \tfloat r2 = cr*cr/length(p-cc);\n// \treturn cc+r2*vec2(p-cc)/length(p-cc);\n// }\n// \n// vec3 col(vec2 p) {\n//     p.x = mod(p.x+1000.0+iTime*speedx, 1.0);\n//     p.y = mod(p.y+1000.0+iTime*speedx, 1.0);\n//     float th = sin(atan(p.y-0.5, p.x-0.5)*2.0+iTime*5.0)/2.0+0.5;\n//     float rd = length(vec2(p.x-0.5, p.y-0.5))*sqrt(2.0);\n//     // /*\n//     p.x *= 256.0;\n//     p.y *= 256.0;\n//     th = float(int(p.x)^int(p.y));\n//     rd = mod((p.x+p.y)*2.0, 256.0);\n//     th /= 256.0;\n//     rd /= 256.0;\n// \t/**/\n//     /*\n//     th = p.x;\n//     rd = p.y;\n//     /**/\n//     return vec3(min(th, rd), th, max(th, rd));\n// }\n// \n// void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n//     // Normalized pixel coordinates (from 0 to 1)\n//     vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.x;\n//     \n//     vec2 maus = (iMouse.xy-iResolution.xy/2.0)/iResolution.x;\n//     \n//     vec2 p = invrted(\n//         uv,\n//         maus,\n//         length(maus)*length(maus)*12.0\n//     );\n//     \n//     // Output to screen\n//     fragColor = vec4(col(p),1.0);\n//     \n// \n//}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lXXR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tfSDX", "name": "Sphere in the CGA", "author": "ShaderPrankster", "description": "Dithering, now with spheres! And bad palettes!\n\nUPDATE: Now with (u)necessary complete CGA option.", "tags": ["raymarching", "dithering", "cga"], "likes": 14, "viewed": 797, "date": "1564425089", "time_retrieved": "2024-06-20T19:39:39.862726", "image_code": "//Based off https://www.shadertoy.com/view/MtjGRd by Flyguy\n#define RGB(r,g,b) (vec3(r,g,b) / 255.0)\n\n//Uncomment for unecessary full CGA!!!\n//#define CGACOMPLETE\n#ifdef CGACOMPLETE\n#define PAL_SIZE 16.0\nvec3 CGACompletePal[16] = vec3[](RGB(0, 0, 0),\n                                 RGB(85, 85, 85),\n                                 RGB(0, 0, 170),\n                                 RGB(0, 170, 0),\n                                 RGB(170, 0, 0),\n                                 RGB(170, 85, 0),\n                                 RGB(0, 170, 170),\n                                 RGB(170, 0, 170),\n                                 RGB(170, 170, 170),\n                                 RGB(85, 85, 255),\n                                 RGB(85, 255, 85),\n                                 RGB(255, 85, 85),\n                                 RGB(85,255, 255), \n                                 RGB(255, 85, 255), \n                                 RGB(255, 255, 85),\n                                 RGB(255, 255, 255));\n#else\n#define PAL_SIZE 4.0\nvec3 CGAPal[4] = vec3[](RGB(0, 0, 0), \n                        RGB(255, 85, 255), \n                        RGB(85,255, 255), \n                        RGB(255, 255, 255));\n#endif\n\nvec3 dither8x8(vec2 position, float brightness) {  \n  float idx = clamp(brightness,0.0,1.0)* (PAL_SIZE - 1.0);\n    \n  #ifdef CGACOMPLETE\n  vec3 c1 = CGACompletePal[int(idx)];\n  vec3 c2 = CGACompletePal[int(idx) + 1];\n  #else  \n  vec3 c1 = CGAPal[int(idx)];\n  vec3 c2 = CGAPal[int(idx) + 1];\n  #endif\n    \n  float limit = texture(iChannel0, position / iChannelResolution[0].xy).r;\n  float mixAmt = float(fract(idx) > limit);\n\n  return mix(c1,c2,mixAmt);\n}\n// Sphere SDF from http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s ){\n  return length(p)-s;\n}\n\nfloat intersect(vec3 point){\n\treturn min(sdSphere(vec3(cos(iTime), 1.0, 5.0 + sin(iTime)) - point, 1.0), point.y + 0.1);\n}\n\nfloat march(vec3 rayOrigin, vec3 rayDirection){\n\tfloat minimumHit = 0.0;\n    \n    for(int i = 0; i < 100; i++){\n    \tvec3 hit = rayOrigin + rayDirection * minimumHit;\n        float dist = intersect(hit);\n        minimumHit += dist;\n        if(dist > 100.0 || dist < 0.01) break;\n    }\n    return minimumHit;\n}\n\nvec3 getNormal(vec3 point){\n\tfloat distPoint = intersect(point);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 norm = distPoint - vec3(intersect(point - e.xyy), intersect(point - e.yxy), \n                            \t intersect(point - e.yyx));\n    return normalize(norm);\n}\n\nfloat lightCalculate(vec3 lightPos, vec3 point){\n\tvec3 lightDirection = normalize(lightPos - point);\n    vec3 normal = getNormal(point);\n    float brightness = clamp(dot(normal, lightDirection), 0.0, 1.0);\n    \n    float shadowCatch = march(point + normal * 0.10, lightDirection);\n    if(shadowCatch < length(lightPos - point)) brightness *= 0.1;\n      \n    return brightness;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col;\n    \n    vec3 rayOrigin = vec3(0.0, 1.5, -0.5);\n    vec3 rayDirection = normalize( vec3(uv,1) );\n    \n    vec3 lightPos = vec3(1, 5, 1);\n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.0;\n    \n    float hitDist = march(rayOrigin, rayDirection);\n    vec3 hitPoint = rayOrigin + rayDirection * hitDist;\n    \n    col = dither8x8(fragCoord, lightCalculate(lightPos,hitPoint));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tfSDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tfSR7", "name": "Biquadratic B-Splines", "author": "paniq", "description": "Interpolate the dual spaces between feature vertices with bernstein polynomials of degree 2. The computed surface is equivalent to repeated Catmull-Clark subdivision.", "tags": ["bicubic", "quadratic", "dual", "interpolation"], "likes": 29, "viewed": 999, "date": "1562366830", "time_retrieved": "2024-06-20T19:39:44.232696", "image_code": "// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\nvec3 weight(vec3 p) {\n    return vec3(\n\t\t(p[0]+p[1])*0.5,\n        p[1],\n        (p[1]+p[2])*0.5);\n}\n\nfloat interpolate2d(mat3 p, vec2 o) {\n    vec3 s = vec3(\n    \t(1.0 - o.x)*(1.0 - o.x),\n    \t2.0*(1.0 - o.x)*o.x,\n    \to.x*o.x);\n    vec3 t = vec3(\n        (1.0 - o.y)*(1.0 - o.y),\n    \t2.0*(1.0 - o.y)*o.y,\n    \to.y*o.y);\n    vec3 q = vec3(\n    \tdot(weight(p[0]), s),\n    \tdot(weight(p[1]), s),\n    \tdot(weight(p[2]), s));\n    \n\treturn dot(weight(q), t);\n\n}\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\nfloat AA;\nfloat AAINV;\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n#define save(name) Context name = _save();\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\nvec2 anglevec(float a) {\n    return vec2(cos(a),sin(a));\n}\n\nvec2 transform(vec3 p) {\n    float o = 20.0;\n    vec2 dx = anglevec(radians(o));\n    vec2 dy = anglevec(radians(o+120.0));\n    vec2 dz = vec2(0.0, 0.33);\n    \n    return p.x * dx + p.y * dy + p.z * dz;\n}\n\nvoid paint() {\n    float t = iTime;\n\n    mat3 p;\n    mat2 m;\n    float e[4];\n    \n    p[0] = vec3(cos(t*0.79), sin(t*0.9), cos(t*0.51));\n    p[1] = vec3(sin(t*0.63), cos(t*0.85), sin(t*0.51));\n    p[2] = vec3(cos(t*0.55), sin(t*0.81), cos(t*0.72));\n    \n    for (int y = 0; y < 2; ++y) {\n        for (int x = 0; x < 2; ++x) {\n            float p0 = p[y][x];\n            float p1 = p[y][x+1];\n            float p2 = p[y+1][x];\n            float p3 = p[y+1][x+1];            \n            m[y][x] = (p0 + p1 + p2 + p3) / 4.0;\n        }\n    }\n    \n    // compute one level of catmull-clark for visualization\n    e[0] = p[0][0] + p[0][1] * 6.0 + p[0][2] \n         + p[1][0] + p[1][1] * 6.0 + p[1][2];\n    e[0] /= 16.0;\n    e[1] = p[1][0] + p[1][1] * 6.0 + p[1][2] \n         + p[2][0] + p[2][1] * 6.0 + p[2][2];\n    e[1] /= 16.0;\n    e[2] = p[0][0] + p[1][0] * 6.0 + p[2][0] \n         + p[0][1] + p[1][1] * 6.0 + p[2][1];\n    e[2] /= 16.0;\n    e[3] = p[0][1] + p[1][1] * 6.0 + p[2][1]\n         + p[0][2] + p[1][2] * 6.0 + p[2][2];\n    e[3] /= 16.0;\n    \n    float c = \n          p[0][0]       + p[0][1] *  6.0 + p[0][2]\n        + p[1][0] * 6.0 + p[1][1] * 36.0 + p[1][2] * 6.0\n        + p[2][0]       + p[2][1] *  6.0 + p[2][2];\n    \n    c /= 64.0;\n    \n    scale(0.7);\n    \n    set_line_width_px(1.3);\n    \n    set_source_rgba(0.0,0.0,0.0,0.2);\n    move_to(transform(vec3(-0.5,-0.5,0.0)));\n    line_to(transform(vec3( 0.5,-0.5,0.0)));\n    line_to(transform(vec3( 0.5, 0.5,0.0)));\n    line_to(transform(vec3(-0.5, 0.5,0.0)));\n    close_path();\n    stroke();\n    move_to(transform(vec3(-1.0,-1.0,0.0)));\n    line_to(transform(vec3( 1.0,-1.0,0.0)));\n    line_to(transform(vec3( 1.0, 1.0,0.0)));\n    line_to(transform(vec3(-1.0, 1.0,0.0)));\n    close_path();\n    stroke();\n\n    set_source_rgba(1.0,0.0,0.0,0.5);\n    for (int y = 0; y < 2; ++y) {\n        for (int x = 0; x < 3; x += 2) {\n            vec2 uv1 = vec2(x,y)-1.0;\n            vec2 uv2 = vec2(x,y);\n            move_to(transform(vec3(uv1, p[y][x])));\n            line_to(transform(vec3(uv1.x, uv2.y, p[y+1][x])));\n        }\n    }\n    for (int y = 0; y < 3; y += 2) {\n        for (int x = 0; x < 2; ++x) {\n            vec2 uv1 = vec2(x,y)-1.0;\n            vec2 uv2 = vec2(x,y);\n            move_to(transform(vec3(uv1, p[y][x])));\n            line_to(transform(vec3(uv2.x, uv1.y, p[y][x+1])));\n        }\n    }\n\tstroke();\n    \n    \n    set_source_rgba(0.0,0.0,0.0,0.3);    \n    for (int y = 0; y < 3; ++y) {\n        for (int x = 0; x < 3; ++x) {\n            vec2 uv = vec2(x,y)-1.0;\n            move_to(transform(vec3(uv, 0.0)));\n            line_to(transform(vec3(uv, p[y][x])));\n        }\n    }\n\tstroke();\n\n    set_source_rgba(0.0,0.0,0.0,0.3);\n    for (int y = 0; y < 2; ++y) {\n        for (int x = 0; x < 2; ++x) {\n            vec2 uv = vec2(x,y)-0.5;\n            move_to(transform(vec3(uv, 0.0)));\n            line_to(transform(vec3(uv, m[y][x])));\n        }\n    }\n    stroke();\n    \n    set_source_rgba(0.0,0.0,0.0,0.3);\n    { \tvec2 uv = vec2(0.0,-0.5);\n        move_to(transform(vec3(uv, 0.0)));\n        line_to(transform(vec3(uv, e[0]))); }\n    { \tvec2 uv = vec2(0.0, 0.5);\n        move_to(transform(vec3(uv, 0.0)));\n        line_to(transform(vec3(uv, e[1]))); }\n    { \tvec2 uv = vec2(-0.5,0.0);\n        move_to(transform(vec3(uv, 0.0)));\n        line_to(transform(vec3(uv, e[2]))); }\n    { \tvec2 uv = vec2( 0.5,0.0);\n        move_to(transform(vec3(uv, 0.0)));\n        line_to(transform(vec3(uv, e[3]))); }\n\tstroke();\n    \n\n    set_source_rgba(0.0,0.0,0.0,1.0);    \n    const float r = 0.02;\n    for (int y = 0; y < 3; ++y) {\n        for (int x = 0; x < 3; ++x) {\n            vec2 uv = vec2(x,y)-1.0;\n\t\t    circle(transform(vec3(uv, p[y][x])), r);\n        }\n    }\n\tfill();\n\n    set_source_rgba(0.0,0.0,1.0,0.7);\n    for (int y = 0; y < 2; ++y) {\n        for (int x = 0; x < 2; ++x) {\n            vec2 uv = vec2(x,y)-0.5;\n\t\t    circle(transform(vec3(uv, m[y][x])), r);\n        }\n    }\n\tfill();\n\n    set_source_rgba(0.0,0.5,0.0,0.7);\n    { \tvec2 uv = vec2(0.0,-0.5);\n        circle(transform(vec3(uv, e[0])), r); }\n    { \tvec2 uv = vec2(0.0, 0.5);\n        circle(transform(vec3(uv, e[1])), r); }\n    { \tvec2 uv = vec2(-0.5,0.0);\n        circle(transform(vec3(uv, e[2])), r); }\n    { \tvec2 uv = vec2( 0.5,0.0);\n        circle(transform(vec3(uv, e[3])), r); }\n\tfill();\n\n    set_source_rgba(1.0,0.0,0.0,0.7);\n    { \tvec2 uv = vec2( 0.0,0.0);\n        circle(transform(vec3(uv, c)), r); }\n\tfill();\n    \n#if 1\n    set_source_rgba(0.0,0.0,0.0,1.0);\n    const int N = 10;\n    set_line_width_px(1.0);\n    for (int y = 0; y <= N; ++y) {\n        for (int x = 0; x <= N; ++x) {\n            vec2 uv = vec2(x,y)/float(N);\n            float z = interpolate2d(p, uv);\n            circle(transform(vec3(uv-0.5, z)), r);\n        }\n    }\n\tstroke();\n#endif\n\n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));\n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\n    float m = ab.x*p.x/l;\n\tfloat n = ab.y*p.y/l;\n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\n    float c = (m2 + n2 - 1.0)/3.0;\n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n\n    vec2 r = vec2( ab.x*co, ab.y*si );\n\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(f_x / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tfSR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tfSRf", "name": "RayMarchingBand008", "author": "Hirai_worthless", "description": "huh.", "tags": ["raymarching"], "likes": 5, "viewed": 542, "date": "1563675588", "time_retrieved": "2024-06-20T19:39:44.232696", "image_code": "float PI = 3.14159265;\nfloat temp(){\n    return (floor(iTime) + min(sin(fract(iTime) * PI / 2.0) * 2.0,1.0));\n}\nfloat map(vec3 p){\n    p = mod(abs(p), 1.5) - 0.75;\n\n    float rot = temp() * PI / 2.0;\n    float size = sin(rot * 2.0 + PI / 4.0);\n    p.xz *= mat2(cos(rot),-sin(rot),sin(rot),cos(rot));\n    float sphere = length(p) - 0.5;\n\tfloat cube = max(max(abs(p.x) - 0.5,abs(p.y) - 0.5),abs(p.z) - 0.5);\n    float obj = mix(sphere,cube,0.5 - size * 0.5);\n    float poleY = length(p.xz) - 0.1 * size;\n    float holes = 100000000.0;\n    for(float i = -0.25; i < 0.50; i += 0.25){\n        for(float j = -0.25; j < 0.50; j += 0.25){\n        \tfloat holeZ = length(p.xy - vec2(i,j)) - 0.075 * (1.0 - size);\n    \t\tfloat holeX = length(p.yz - vec2(i,j)) - 0.075 * (1.0 - size);\n    \t\tholes = min(holes,holeX);\n        \tholes = min(holes,holeZ);\n        }\n    }\n\n    return max(min(obj,poleY),-holes);\n\t\n\n}\n\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 32; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return vec4(getNormal(p),t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv,1.0));\n    float rot = temp() * PI / 4.0;\n    r.xy *= mat2(cos(rot),-sin(rot),sin(rot),cos(rot));\n    vec3 o = vec3(0,0,iTime * 4.0);\n    vec4 data = trace(o,r);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.2);\n    vec3 fc = mix(vec3(0.5 - data.x,0.5 -data.y,0.5-data.z),vec3(0),1.0 - fog);\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tfSRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tfSWl", "name": "Deformed_Sphere", "author": "Hirai_worthless", "description": "spin", "tags": ["raymarching"], "likes": 2, "viewed": 73, "date": "1564547332", "time_retrieved": "2024-06-20T19:39:44.232696", "image_code": "float PI = 3.14159265;\nmat2 genRot(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\nfloat map(vec3 p){\n    p.xz *= genRot(iTime);\n\tfloat s = length(p) - 1.0;\n    float p1 = abs(p.y  - p.x * p.z  - smoothstep(0.0,1.0,0.5 * sin(iTime * 1.5 + 2.0 * PI / 3.0) + 0.5)) - 0.1;\n    float p2 = abs(p.x   - p.y * p.z  - smoothstep(0.0,1.0,0.5 * sin(iTime * 1.5+ 4.0 * PI / 3.0) + 0.5)) - 0.1;\n    float p3 = abs(p.z  - (p.x * p.y)  - smoothstep(0.0,1.0,0.5 * sin(iTime * 1.5+ 6.0 * PI / 3.0) + 0.5)) - 0.1;\n    return max(s,-min(min(p1,p2),p3));\n}\n\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 96; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return vec4(getNormal(p),t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 R = iResolution,\n    r = normalize(vec3((2.*U - R.xy )/  R.y,1.2)),\n    o = vec3(0,0,-1.75);\n    vec4 data = trace(o,r);\n    vec3 n = vec3(data.xyz);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.2);\n    vec3 fc = t > 10000.0 ? vec3(0.8) : mix((vec3(data.x,data.y,data.z) + 1.0)/1.5\n                                            ,vec3(0.0), - pow(dot(n,r),1.0));\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tfSWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tfXDN", "name": "[Ese] texture", "author": "Eseris", "description": "raymarching + texture", "tags": ["raymarching", "texture"], "likes": 2, "viewed": 270, "date": "1563487776", "time_retrieved": "2024-06-20T19:39:44.232696", "image_code": "#define pow(a,b) pow(abs(a),(b))\n\nconst int MARCHING_STEPS = 150;\nconst int ALIASING_STEPS = 1;\nconst float MIN_DIST = 0.;\nconst float MAX_DIST = 40.;\nconst float EPSILON = 1e-3;\n\nstruct Light {\n\tvec3 iamb; // ambient intensity\n\tvec3 idiff; // diffuse intensity\n\tvec3 ispec; // specular intensity\n\tvec3 pos;\n\tfloat shininess;\n};\n\nstruct Material {\n\tvec3 amb; // ambient constant\n\tvec3 diff; // diffuse constant\n\tvec3 spec; // specular constant\n};\n\nmat2 rot(float a) {\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat sdSphere(vec3 p, float radius) {\n\treturn length(p) - radius;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n  return dot(p,n.xyz) + n.w;\n}\n\nvec3 repeat(vec3 p, vec3 s) {\n    return mod(p, s) - .5 * s;\n}\n\nfloat map(vec3 p) {\n    float d = 1e10;\n    vec3 q = vec3(mod(p.x, 1.), p.yz);\n    d = min(d, sdPlane(p, vec4(0, 1, 0, 1.)));\n    \n    {\n        vec3 p2 = p  - vec3(-4, 1, 0);\n        p2.zx *= rot(iTime);\n    \td = min(d, sdBox(p2, vec3(1, 2, 1)));\n    }\n    \n    d = min(d, sdSphere(p - vec3(4, 0., 1), 1.3));\n    d = min(d, sdBox(p - vec3(0, 2, - 2), vec3(2, 2, .01)));\n\treturn d;\n}\n\nvec3 mapGradient(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n\t));\n}\n\nfloat rayProcess(vec3 camPos, vec3 rayDir, float start, float end) {\n\tfloat depth = start;\n\tfor(int i = 0; i < MARCHING_STEPS; ++i) {\n\t\tfloat dist = map(camPos + depth * rayDir);\n\t\tif(dist < EPSILON) return depth;\n\t\tdepth += dist;\n\t\tif(dist >= end) return end;\n\t}\n\treturn end;\n}\n\nvec3 rayDirection(float camAngle, vec2 coord) {\n\tvec2 uv = (coord - .5) * iResolution.xy;\n\tfloat focalDist = iResolution.y / 2. / tan(radians(camAngle) / 2.);\n\treturn normalize(vec3(uv, -focalDist));\n}\n\n\nfloat checkerboard(in vec3 p) {\n    vec3 q = floor(p);\n    return mod(q.x + q.y + q.z,2.);              \n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    const float maxHei = 2.;\n    float tp = (maxHei-ro.y)/rd.y; \n    if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=min(0, iFrame); i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 applyLight(Light light, vec3 p, vec3 rd, vec3 nor) {\n    vec3 col = vec3(0.);\n\n    // material        \n    vec3 mate = vec3(.3);\n    if(p.y < -.999) {\n        float f = checkerboard(p);\n        mate = 0.15 + f*vec3(0.05);\n    }\n    else if(abs(p.x) < 2.) {\n        vec2 uv = fract(p.yx * .25 - vec2(0, -.5));\n        mate = texture(iChannel0, uv.yx).rgb;\n        //mate = vec3(uv, 0.) * .3;\n    }\n\n    // key light\n    vec3  lig = normalize(light.pos);\n    vec3  hal = normalize( lig-rd );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),40.0)*\n        dif * (0.04 + 0.99*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 6.0 ));\n    \n    \n    dif *= calcSoftshadow(p, lig, .1, 3.);\n\n    col = mate * 3.3*dif*vec3(.80,0.70,0.6);\n    col +=      7.0*spe*vec3(1.00,0.70,0.5);\n\n    // ambient light\n    float amb = .5;\n    col += mate*amb;\n    \n\treturn col;\n}\n\nvec3 shading(vec3 ro, vec3 rd) {\n\tLight light;\n\tlight.iamb = vec3(.5, .6, .7);\n\tlight.idiff = vec3(.5);\n\tlight.ispec = vec3(.4);\n\tlight.pos = vec3(-8., 8., 5.);\n\tlight.shininess = 6.;\n\n\t//vec3 col = applyLight(mat, light, p, eye);\n    vec3 resCol = vec3(0);\n    vec3 p = ro;\n    float alpha = 1.;\n    for(int i = 0; i < 2; ++i) {\n        float depth = rayProcess(p, rd, MIN_DIST, MAX_DIST);\n    \tp += depth * rd;\n    \tvec3 nor = mapGradient(p);\n        \n    \tvec3 col = applyLight(light, p, rd, nor);\n        col *= pow(smoothstep(MAX_DIST, 10., depth), 2.); // fog\n        \n        resCol += col * alpha;\n        alpha *= .25;\n        \n    \trd = reflect(rd, nor);\n        p += rd * 1e-3; // small incr to avoid null dist\n    }\n    \n    \n\treturn resCol;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 tot = vec3(0.);\n    \n    for(int i = 0; i < ALIASING_STEPS; ++i) {\n        for(int j = 0; j < ALIASING_STEPS; ++j) {\n            vec2 offset = vec2(i, j) / 2. - .5;\n            vec3 camPos = vec3(0., 5., 7.);\n            vec3 dir = rayDirection(60., (fragCoord + offset) / iResolution.xy);\n            \n            //float ang = -.3 + .5*sin(.5 * iTime);\n            float ang = .5 * iTime;\n            camPos.zx *= rot(ang);\n            dir.yz *= rot(.5);\n            dir.zx *= rot(ang);\n\n            vec3 col = vec3(0.);\n            col = shading(camPos, dir);\n            \n            // gamma\n            tot += pow(col, vec3(1. / 1.7));\n        }\n    }\n    \n    tot /= float(ALIASING_STEPS * ALIASING_STEPS);\n\tfragColor = vec4(tot, 1.);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tfXDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tfXRj", "name": "Time-o-matic 5 - 196 chars", "author": "FabriceNeyret2", "description": "shortness challenge against [url]https://www.shadertoy.com/view/MlfXz8[/url]\nImprovement of [url]https://www.shadertoy.com/view/4lXSR4[/url] that was improving previous.", "tags": ["numbers", "font", "2tweets", "digits", "short", "timer", "golf"], "likes": 7, "viewed": 312, "date": "1563471232", "time_retrieved": "2024-06-20T19:39:44.232696", "image_code": "// 196 chars:   +3 for windows that fail on x%4*x*y<1\n\nvoid mainImage(out vec4 o, vec2 i) {\n    int x = 28 - int(i)/12, y = int(i.y)/12;\n    ( ( x*y<1||x%4<1||y>5? 0: y>4? 972980223: y>3? 690407533: y>2? 704642687: y>1? 696556137: 972881535 )\n      >> x%4 +26 -  3*int( iTime * pow(.1,float(x/4-3)) ) % 30\n    ) %2 > 0 ? o++ : o;\n} /*\n\n\n\n\n// 206 chars :\n\n#define mainImage(o,i)                                  \\\n    int x = 28 - int(i)/12, y = int(i.y)/12,            \\\n        c = int( iTime * pow(.1,float(x/4-3)) ) % 10;   \\\n    x -= x/4*4;                                         \\\n    ( ( x<1||y<1||y>5? 0: y>4? 972980223: y>3? 690407533: y>2? 704642687: y>1? 696556137: 972881535 ) \\\n      >> x+26-c*3 ) %2 > 0 ? o++ : o\n\n\n\n// 221 chars :\n\n#define mainImage( o, i)                             \\\n    int x = 28 - int(i.x)/12, y = int(i.y)/12,       \\\n        c = int( iTime / pow(10.,float(x/4-3)) );    \\\n    x -= x/4*4;                                      \\\n    c = ( x<1||y<1||y>5? 0: y>4? 972980223: y>3? 690407533: y>2? 704642687: y>1? 696556137: 972881535 ) \\\n        >> x+26+c/10*30-3*c;                         \\\n    o += vec4( c-c/2*2 )\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tfXRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tfXRM", "name": "Simple night sky", "author": "carolhmj", "description": "Using noise functions to generate stars, clouds and a moon.", "tags": ["procedural", "2d", "noise", "clouds", "stars"], "likes": 11, "viewed": 770, "date": "1562333589", "time_retrieved": "2024-06-20T19:39:45.123770", "image_code": "#define PI 3.1416\n#define SKY_COLOR vec3(0.027, 0.151, 0.354)\n#define LIGHT_SKY vec3(0.45, 0.61, 0.98)\n#define STAR_COLOR vec3(0.92, 0.92, 0.14)\n#define MOON_COLOR vec3(0.81, 0.81, 0.81)\n\n//Noise functions from https://www.youtube.com/watch?v=zXsWftRdsvU\nfloat noise11(float p) {\n\treturn fract(sin(p*633.1847) * 9827.95);\n}\n    \nfloat noise21(vec2 p) {\n\treturn fract(sin(p.x*827.221 + p.y*3228.8275) * 878.121);\n}\n\nvec2 noise22(vec2 p) {\n\treturn fract(vec2(sin(p.x*9378.35), sin(p.y*75.589)) * 556.89);\n}\n\n//From https://codepen.io/Tobsta/post/procedural-generation-part-1-1d-perlin-noise\nfloat cosineInterpolation(float a, float b, float x) {\n    float ft = x * PI;\n    float f = (1. - cos(ft)) * .5;\n    return a * (1. - f) + b * f;\n}\n\nfloat smoothNoise11(float p, float dist) {\n    float prev = noise11(p-dist);\n    float next = noise11(p+dist);\n       \n    return cosineInterpolation(prev, next, .5);\n}\n\nfloat smoothNoise21(vec2 uv, float cells) {\n\tvec2 lv = fract(uv*cells);\n    vec2 id = floor(uv*cells);\n    \n    //smoothstep function: maybe change it later!\n    lv = lv*lv*(3.-2.*lv);\n    \n    float bl = noise21(id);\n    float br = noise21(id+vec2(1.,0.));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = noise21(id+vec2(0.,1.));\n    float tr = noise21(id+vec2(1.,1.));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nvec2 smoothNoise22(vec2 uv, float cells) {\n\tvec2 lv = fract(uv*cells);\n    vec2 id = floor(uv*cells);\n    \n    //smoothstep function: maybe change it later!\n    lv = lv*lv*(3.-2.*lv);\n    \n    vec2 bl = noise22(id);\n    vec2 br = noise22(id+vec2(1.,0.));\n    vec2 b = mix(bl, br, lv.x);\n    \n    vec2 tl = noise22(id+vec2(0.,1.));\n    vec2 tr = noise22(id+vec2(1.,1.));\n    vec2 t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\n\nfloat valueNoise11(float p) {\n\tfloat c = smoothNoise11(p, 0.5);\n    c += smoothNoise11(p, 0.25)*.5;\n    c += smoothNoise11(p, 0.125)*.25;\n    c += smoothNoise11(p, 0.0625)*.125;\n    \n    return c /= .875;\n}\n\nfloat valueNoise21(vec2 uv) {\n\tfloat c = smoothNoise21(uv, 4.);\n    c += smoothNoise21(uv, 8.)*.5;\n    c += smoothNoise21(uv, 16.)*.25;\n    c += smoothNoise21(uv, 32.)*.125;\n    c += smoothNoise21(uv, 64.)*.0625;\n    \n    return c /= .9375;\n}\n\nvec2 valueNoise22(vec2 uv) {\n\tvec2 c = smoothNoise22(uv, 4.);\n    c += smoothNoise22(uv, 8.)*.5;\n    c += smoothNoise22(uv, 16.)*.25;\n    c += smoothNoise22(uv, 32.)*.125;\n    c += smoothNoise22(uv, 64.)*.0625;\n    \n    return c /= .9375;\n}\n\nvec3 point(vec2 p, vec2 uv, vec3 color, float size, float blur) {\n\tfloat dist = distance(p, uv);\n    \n    return color*smoothstep(size, size*(0.999-blur), dist);\n}\n\nfloat mapInterval(float x, float a, float b, float c, float d) {\n\treturn (x-a)/(b-a) * (d-c) + c;\n}\n\nfloat blink(float time, float timeInterval) {\n    float halfInterval = timeInterval / 2.0;\n    //Get relative position in the bucket\n    float p = mod(time, timeInterval);\n    \n    \n    if (p <= timeInterval / 2.) {\n    \treturn smoothstep(0., 1., p/halfInterval);\n    } else {\n        return smoothstep(1., 0., (p-halfInterval)/halfInterval);\n    }\n}\n\nvec3 sampleBumps(vec2 p, vec2 uv, float radius) {\n\tfloat dist = distance(p, uv);\n    \n    if (dist < radius) {\n    \treturn vec3((1.-valueNoise21(uv*10.))*.1);\n    }\n    return vec3(0.); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ouv = uv;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    float time = iTime + mouse.x*10.;\n        \n    //vec3 col = vec3(0.0);\n    //float m = valueNoise21(uv);    \n\tvec3 col = mix(LIGHT_SKY, SKY_COLOR, ouv.y+.6);\n    \n    col *= .65 + (1.-ouv.y);\n    \n    //Add clouds\n    vec2 timeUv = uv;\n    timeUv.x += time*.1;\n    timeUv.y += valueNoise11(timeUv.x+.352)*.01;\n    float cloud = valueNoise21(timeUv);\n    col += cloud*.1;\n    \n    //Add stars in the top part of the scene\n    float timeInterval = 5.;\n    float timeBucket = floor(time / timeInterval);\n    \n    // Moon\n    vec2 moonPosition = vec2(-0.600, 0.25);\n    \n    col += point(moonPosition, uv, MOON_COLOR, 0.15, 0.3);\n    // Moon bumps\n    col += sampleBumps(moonPosition, uv, 0.12);\n    \n    for (float i = 0.; i < 25.; i++) {\n\t    vec2 starPosition = vec2(i/10., i/10.);\n        \n        starPosition.x = mapInterval(valueNoise11(timeBucket + i*827.913)-.4, 0., 1., -0.825, 0.825);\n        starPosition.y = mapInterval(valueNoise11(starPosition.x)-.3, 0., 1., -0.445, 0.445);\n\t    \n        float starIntensity = blink(time, timeInterval);\n        //Hide stars that are behind the moon\n        if (distance(starPosition, moonPosition) > 0.14) {\n        \tcol += point(starPosition, uv, STAR_COLOR, 0.001, 0.0)*clamp(starIntensity-.1, 0.0, 1.0)*10.0;\n        \tcol += point(starPosition, uv, STAR_COLOR, 0.009, 3.5)*starIntensity*3.0;\n        }\n    }\n  //col = vec3(blink(time, timeInterval));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tfXRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tfXWN", "name": "Circle - distance 2D", "author": "jcward", "description": "Inigo Quilez's SD circle example (with minor animation tweak)", "tags": ["2d", "sdf"], "likes": 1, "viewed": 163, "date": "1562859397", "time_retrieved": "2024-06-20T19:39:45.444954", "image_code": "// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance to a 2D circle\n// see: http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n\tfloat d = sdCircle( p, 0.6 );\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d + 9.0*iTime);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/3tfXWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tlSD7", "name": "Sin visualization", "author": "DDave", "description": "A sin visualizer over time.", "tags": ["sin", "shader", "itime"], "likes": 1, "viewed": 208, "date": "1563220685", "time_retrieved": "2024-06-20T19:39:45.614643", "image_code": "//line interpolation functions\nfloat plot(vec2 st, float pct){\n\treturn smoothstep(pct-0.02, pct, st.y) - smoothstep(pct, pct+0.02, st.y); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 st = fragCoord.xy/vec2(iResolution);\n    \n    //Adding time to x value for continuos sin\n    st.x += 1.4*iTime;\n    //Smoothstepping between max sin values, 1 and 0. \n    float y = smoothstep(-1.0, 0.0, sin(st.x)) - smoothstep(0.0, 1.0, sin(st.x));\n    \n    //line drawing to the screen\n    vec3 color = vec3(y);\n    float line = plot(st, y);\n    \n    color = line * vec3(0.0, 1.0, 0.0);\n    fragColor =vec4(color, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tlSD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tlSDN", "name": "Nodes, Lines and Nodes", "author": "Ytomi", "description": "test", "tags": ["raymarching"], "likes": 8, "viewed": 205, "date": "1563203532", "time_retrieved": "2024-06-20T19:39:45.614643", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nvec3 Repeat(vec3 p){\n    return mod(p,4.)-2.;\n}\n\nfloat N31(vec3 p)\n{\n    return fract(sin(dot(p.xyz, vec3(12.9898, 78.233, 56.787))) * 43758.5453);\n}\n\nvec3 N33(vec3 p)\n{\n    float n = N31(p);\n    return vec3(fract(n*cos(p.x)), fract(n*sin(p.y)), fract(n*cos(p.z)));\n}\n\nstruct fracpos{\n    vec3 fp;\n    vec3 id;\n};\n\nfracpos GetFracPos(vec3 p){\n    vec3 fp = mod(p,4.)-2.;\n    vec3 id = floor(p/4.);\n    return fracpos(fp,id);\n}\n\nvec3 SphereCenterLocalPos(vec3 id, vec3 offs){\n    vec3 s = vec3(0.,0.,0.);\n    vec3 n = N33(id+offs);\n    s += vec3(cos(iTime*n.x*2.),sin(iTime*n.y),cos(iTime*n.z))*1.8;\n    return s + offs*4.0;\n}\n\nfloat LineDist(vec3 p, vec3 a, vec3 b, float r){\n    vec3 pa = p-a;\n    vec3 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return length(pa - ba * t)-r;\n}\n\nfloat LineRadius(vec3 p,vec3 q){\n    return 1./(length(p-q)*30.);\n    //return (1.-(smoothstep(0.,4., length(p-q))))*.1;\n}\n\nfloat smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\n\nfloat GetDist(vec3 p){\n    fracpos pos = GetFracPos(p);\n    \n    vec3 q[27];\n    int i = 0;\n    for (int z = -1; z <= 1; z++){\n        for (int y = -1; y <= 1; y++){\n            for (int x = -1; x <= 1; x++){\n                q[i] = SphereCenterLocalPos(pos.id, vec3(x,y,z));\n                i++;\n            }\n\n        }\n    }\n    \n    float sphereDist = length(pos.fp-q[13])-.1;\n    \n    float lineDistMin = 100.;\n    float minLength = 3.;\n    \n\tlineDistMin = length(q[13] - q[4]) < minLength ? min(lineDistMin, LineDist(pos.fp, q[13], q[4], LineRadius(q[13], q[4]))) : lineDistMin;\n\tlineDistMin = length(q[13] - q[22]) < minLength ? min(lineDistMin, LineDist(pos.fp, q[13], q[22], LineRadius(q[13], q[22]))) : lineDistMin;\n\tlineDistMin = length(q[13] - q[12]) < minLength ? min(lineDistMin, LineDist(pos.fp, q[13], q[12], LineRadius(q[13], q[12]))) : lineDistMin;\n\tlineDistMin = length(q[13] - q[14]) < minLength ? min(lineDistMin, LineDist(pos.fp, q[13], q[14], LineRadius(q[13], q[14]))) : lineDistMin;\n\tlineDistMin = length(q[13] - q[10]) < minLength ? min(lineDistMin, LineDist(pos.fp, q[13], q[10], LineRadius(q[13], q[10]))) : lineDistMin;\n\tlineDistMin = length(q[13] - q[16]) < minLength ? min(lineDistMin, LineDist(pos.fp, q[13], q[16], LineRadius(q[13], q[16]))) : lineDistMin;\n    \n                                            \n    float d = smoothMin(sphereDist,lineDistMin,20.);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO=0.;\n    for(int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro + rd*dO;\n        float dS = min(min(min((step(0.0, rd.x) - fract(p.x)) / rd.x, (step(0.0, rd.z) - fract(p.z)) / rd.z), (step(0.0, rd.y) - fract(p.y)) / rd.y) + 0.01, GetDist(p));\n        dO += dS;\n        if(dO>MAX_DIST||dS<SURF_DIST)break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n    vec2 m = vec2(.01,0.);\n    return normalize(vec3(\n        GetDist(p+m.xyy)-GetDist(p-m.xyy),\n        GetDist(p+m.yxy)-GetDist(p-m.yxy),\n        GetDist(p+m.yyx)-GetDist(p-m.yyx)));\n}\n\nfloat GetLight(vec3 p){\n    vec3 LightPos = vec3(0,10,6);\n    LightPos.z += iTime*5.;\n    vec3 l = normalize(LightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l),0.,1.);\n    float d =RayMarch(p + n*SURF_DIST,l);\n    if(d<length(LightPos-p)) dif *= 1.;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0.,0.,iTime*5.);\n    vec3 rd = normalize(vec3(uv.x,uv.y,3.));\n    vec3 col = vec3(0.);\n    \n    float dO = RayMarch(ro,rd);\n    vec3 p = ro + rd*dO;\n    float dS = GetDist(p);\n\t\n    if(dS<.1){\n        col = vec3(GetLight(p));\n    }else{\n        col = vec3(1.);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tlSDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tlSRj", "name": "RayMarchingMarch005", "author": "Hirai_worthless", "description": "psychedelic.", "tags": ["raymarching"], "likes": 3, "viewed": 413, "date": "1563547472", "time_retrieved": "2024-06-20T19:39:45.614643", "image_code": "vec2 path(float z){\n    float x = sin(z) + 2.0 * cos(z * 0.3) - 1.5 * sin(z * 0.12345);\n    float y = cos(z) + 1.5 * sin(z * 0.3) + 2.0 * cos(z * 0.12345);\n    return vec2(x,y);\n}\n\nfloat map(vec3 p){\n\t//p = fract(p/2.0) * 6.0 - 3.0;\n    vec2 o = path(p.z) / 4.0;\n\tfloat tBase = max(-length(p.xy - o) + 1.0 \n                      //* (1.0 + sin(p.z) * 0.5)\n                      ,length(p.xy - o) - 1.2 \n                      //* (1.0 + sin(p.z) * 0.5)\n                     );\n    float tdonut = max(-length(p.xy - o) + 0.5\n                      ,length(p.xy - o) - 0.6 \n                     );\n    tdonut = max(tdonut,abs(fract(p.z) - 0.5));\n    float tTube1 = length(p.xy - o + vec2(0.3,0.3)) - 0.025;\n    float tTube2 = length(p.xy - o + vec2(0.5,0.2)) - 0.025;\n    float tTube3 = length(p.xy - o + vec2(0.2,0.5)) - 0.025;    \n    float tTube4 = length(p.xy - o + vec2(-0.3,-0.3)) - 0.025;\n    float tTube5 = length(p.xy - o + vec2(-0.5,-0.2)) - 0.025;\n    float tTube6 = length(p.xy - o + vec2(-0.2,-0.5)) - 0.025;\n    float tTube = min(min(tTube1,tTube2),tTube3);\n    tTube = min(min(tTube,tTube4),min(tTube5,tTube6));\n\n    float bound = 2.0;\n    float tSplit = (fract(p.z)-0.5);\n    tSplit = min(tSplit, abs((p.x - o.x))-0.15);\n    tSplit = min(tSplit, abs((p.y - o.y))-0.15);\n\n    return min(min(max(tBase,-tSplit),tdonut),tTube);\n}\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 32; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return vec4(getNormal(p),t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float PI = 3.14159265;\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv,0.5));\n\n    float z = iTime * 4.0 ;\n    \n    r.xy *= mat2( sin(iTime),cos(iTime),\n    \t\t\t\t-cos(iTime),sin(iTime));\n\tvec2 a = path(z);\n    vec3 o = vec3(a / 4.0,z);\n    vec4 data = trace(o,r);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.2);\n    vec3 fc = mix(vec3(0.5 - data.x,0.5 -data.y,0.5-data.z),vec3(0),1.0 - fog);\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tlSRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tlSRl", "name": "Menger Sponge World", "author": "96logda", "description": "Experimenting with Menger Sponge.", "tags": ["3d", "raymarching", "softshadows", "mengersponge"], "likes": 5, "viewed": 254, "date": "1563913735", "time_retrieved": "2024-06-20T19:39:45.614643", "image_code": "//Copyright (c) 2019-07-13 - 2019-07-23 by Angelo Logahd\n//Portfolio: https://angelologahd.wixsite.com/portfolio\n//Based on https://www.iquilezles.org/www/articles/menger/menger.htm\n\n#define true\t\t\t\t1\n#define false\t\t\t\t0\n\n#define PI 3.14\n\n#define saturate(x) \t\tclamp(x, 0.0, 1.0)\n\n#define MENGER_ITERATIONS\t2\n#define SOFT_SHADOW_STEPS \t16\n\n#define INTERSECT_STEPS\t\t300\n#define INTERSECT_MIN_DIST\t0.0001\n#define INTERSECT_MAX_DIST\t50.0\n\n\nvec2 rotate2D(vec2 p, float angle)\n{\n    float sRot = sin(angle);\n    float cRot = cos(angle);\n    return p * cRot + p.yx * sRot * vec2(-1.0, 1.0);\n}\n\nfloat cappedCylinder(vec3 p, vec2 h)\n{\n     vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n     return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nvec4 map(in vec3 p)\n{\n    p.xz = mod(p.xz + 5.0, 2.0) - 1.0;\n    p.y  = mod(p.y + 1.0, 2.0) - 1.0;\n    \n    float d = cappedCylinder(p, vec2(0.9, 1.5));\n    vec4 res = vec4(d, 1.0, 0.0, 0.0);\n\t\n    float s = 1.2;\n    for(int i = 0; i < MENGER_ITERATIONS; ++i)\n    {\t        \n        vec3 a = mod(p * s, 2.0) - 1.0;\n        s *= 8.0;\n        vec3 r = abs(1.0 - 5.0 * abs(a));\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 1.0) / s;\n\n        if(c > d)\n        {\n            d = c;\n            res = vec4(d, min(res.y, 0.2 * da * db * dc), 0.0, 1.0);\n        }\n    }\n    \n    return res;\n}\n\nvec4 intersect(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n    vec4 h = vec4(1.0);\n    for (int i = 0; i < INTERSECT_STEPS; ++i)\n    {\n        h = map(ro + rd * t);\n        res = vec4(t, h.yzw);\n        if(h.x < INTERSECT_MIN_DIST || t > INTERSECT_MAX_DIST) \n\t\t{\n\t    \tbreak;\n\t\t}\n        t += h.x;\n    }\n\n    if (t > INTERSECT_MAX_DIST) \n    {\n\t\tres = vec4(-1.0);\n    }\n    \n    return res;\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < SOFT_SHADOW_STEPS; ++i)\n    {\n\t\tvec3 pos = ro + rd * t;\n        float h = map(pos).x;\n        res = min(res, float(SOFT_SHADOW_STEPS) * h / t);\n        if(res < 0.001)\n\t\t{\n            break;\n\t\t}\n        t += clamp(h, 0.01, 0.2);\n    }\n    return saturate(res);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 n;\n    n.x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    n.y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    n.z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n    return normalize(n);\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 color = vec3(0.5);\n    vec4 res = intersect(ro,rd);\n    if(res.x > 0.0)\n    {\n        const vec3 light1 = vec3(0.5, 0.5, -0.5);\n\t\t\n\t\tvec3 pos = ro + res.x * rd;\n\t\n        vec3 baseColor = vec3(0.0, 0.4, 0.6);\n\t\tvec3 ambient = vec3(0.2) * baseColor;\n\t\t\n\t\tvec3 normal = calcNormal(pos);\n\t\tvec3 reflection = reflect(rd, normal);\n\t\n\t\tfloat occ = res.y;\n\t\tfloat shadow1 = softshadow(pos + 0.001 * normal, light1);\n\t\n\t\tvec3 diffuse = baseColor * shadow1 * occ;\n\t\t\n\t\tcolor = diffuse + ambient;\t\t\n\t\tcolor += 0.8 * smoothstep(0.0, 0.1, reflection.y) * softshadow(pos + 0.01 * normal, reflection);\n    }\n\n    return pow(color, vec3(0.4545));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 p = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\t\n    // camera\n    vec3 ro = vec3(8.75, 0.9, -0.0);\n    ro.x -= 0.1 * iTime; //Camera movement\n    \n    vec3 ww = normalize(vec3(0.0) - ro);\n    ww.xz = rotate2D(ww.xz, iMouse.x * 2.0 * PI);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n\n    vec3 color = render(ro + vec3(0.0, -1.0, 0.0), rd);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tlSRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tlSRN", "name": "Mike Warped", "author": "1j01", "description": "Mike Wazowski of Monsters, Inc. by iq, timewarped based on pixel position - a very simple modification which you could apply to other things.\nShadow disabled to make it look more like it's the model being warped. You could probably warp SDF easily too idk", "tags": ["3d", "timewarp"], "likes": 1, "viewed": 344, "date": "1562267445", "time_retrieved": "2024-06-20T19:39:47.917900", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Made with love after a famous movie character. Modeling is pretty arbitrary and was \n// done by visual inspiration from the first picture you get in google images when you \n// type \"mike wazowski\".\n\n// Uncomment the following define in order to see Mike in 3D!\n//#define STEREO \n\n\n// Mike Warped-Out,-See?\nfloat timeWarp(vec2 pos) {\n\t// mess around here 🙂\n    //return iTime * sin(iTime / 5.0 * pos.x);\n    //return iTime * sin(iTime / 5.0 + pos.y);\n    return iTime * sin(pow(iTime / 15.0 * pos.x + pos.y, 0.5));\n}\n\n\nfloat hash( float n )\n{\n    return fract(sin(n)*158.5453123);\n}\n\nfloat noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    return mix( hash(p+0.0), hash(p+1.0),f);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\nvec3 texturize( sampler2D sa, vec3 p, vec3 n )\n{\n\tvec3 x = texture( sa, p.yz ).xyz;\n\tvec3 y = texture( sa, p.zx ).xyz;\n\tvec3 z = texture( sa, p.xy ).xyz;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n//----------------------------------------------------------------\n\nvec2 sdSegment( vec3 a, vec3 b, vec3 p )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// trick by klems\n#define ZERO (min(iFrame,0))\n\n//----------------------------------------------------------------\n\nvec2 map( vec3 p )\n{\n\tp.y -= 1.8;\n    \n\tp.x = abs(p.x);\n\n\tvec3 q = p;\n\tq.y -= 0.3*pow(1.0-length(p.xz),1.0)*smoothstep(0.0, 0.2, p.y);\n\tq.y *= 1.05;\n\tq.z *= 1.0 + 0.1*smoothstep( 0.0, 0.5, q.z )*smoothstep( -0.5, 0.5, p.y );\n    float dd = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.75,1.0) );\n\tfloat am = clamp( 4.0*abs(p.y-0.45), 0.0, 1.0 );\n\tfloat fo = -0.03*(1.0-smoothstep( 0.0, 0.04*am, abs(dd-0.42) ))*am;\n    float dd2 = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.25,1.0) );\n\tfloat am2 = clamp( 1.5*(p.y-0.45), 0.0, 1.0 );\n\tfloat fo2 = -0.085*(1.0-smoothstep( 0.0, 0.08*am2, abs(dd2-0.42) ))*am2;\n    q.y += -0.05+0.05*length(q.x);\n\t\n\tfloat d1 = length( q ) - 0.9 + fo + fo2;\n    vec2 res = vec2( d1, 1.0 );\n\n\t// arms\n\tvec2 h = sdSegment( vec3(.83,0.15,0.0), vec3(1.02,-0.6,-.1), p );\n\tfloat d2 = h.x - 0.07;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( vec3(1.02,-0.6,-.1), vec3(0.95,-1.2,0.1), p );\n\td2 = h.x - 0.07 + h.y*0.02;\n\tres.x = smin( res.x, d2, 0.06 );\n\t\n\t// hands\n\tif( p.y<-1.0 )\n\t{\n    float fa = sin(3.0*iTime);\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.97,-1.5,0.0), p );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.01 );\n\th = sdSegment( vec3(0.97,-1.5,0.0), vec3(0.95,-1.7,0.0)-0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(1.05,-1.5,0.1), p );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( vec3(1.05,-1.5,0.1), vec3(1.0,-1.75,0.1)-0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.98,-1.5,0.2), p );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( vec3(0.98,-1.5,0.2), vec3(0.95,-1.7,0.15)-0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.85,-1.4,0.2), p );\n\td2 = h.x - 0.04 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.05 );\n\th = sdSegment( vec3(0.85,-1.4,0.2), vec3(0.85,-1.63,0.15)+0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.03 );\n\t}\n\t\n\t// legs\n\tif( p.y<0.0 )\n\t{\n\th = sdSegment( vec3(0.5,-0.5,0.0), vec3(0.6,-1.2,0.1), p );\n\td2 = h.x - 0.14 + h.y*0.08;\n\tres.x = smin( res.x, d2, 0.06 );\n\th = sdSegment( vec3(0.6,-1.2,0.1), vec3(0.5,-1.8,0.0), p );\n\td2 = h.x - 0.06;\n\tres.x = smin( res.x, d2, 0.06 );\n\t}\n\n    // feet\n\tif( p.y<-1.5 )\n\t{\n\th = sdSegment( vec3(0.5,-1.8,0.0), vec3(0.6,-1.8,0.4), p );\n\td2 = h.x - 0.09 + 0.02*h.y;\n\tres.x = smin( res.x, d2, 0.06 );\n\th = sdSegment( vec3(0.5,-1.8,0.0), vec3(0.77,-1.8,0.35), p );\n\td2 = h.x - 0.08 + 0.02*h.y;\n\tres.x = smin( res.x, d2, 0.06 );\n\th = sdSegment( vec3(0.5,-1.8,0.0), vec3(0.9,-1.8,0.2), p );\n\td2 = h.x - 0.07 + 0.02*h.y;\n\tres.x = smin( res.x, d2, 0.06 );\n\t}\n\t\n\t// horns\n\tvec3 hp = p - vec3(0.25,0.7,0.0);\n    hp.xy = mat2(0.6,0.8,-0.8,0.6)*hp.xy;\n    hp.x += 0.8*hp.y*hp.y;\n    float d4 = sdEllipsoid( hp, vec3(0.13,0.5,0.16) );\n\t//d4 *= 0.9;\n\tif( d4<res.x ) res = vec2( d4, 3.0 );\n\n    \n\t// eyes\n\tfloat d3 = length( (p - vec3(0.0,0.25,0.35))*vec3(1.0,0.8,1.0) ) - 0.5;\n\tif( d3<res.x ) res = vec2( d3, 2.0 );\n\n\t// mouth\n\tfloat mo = length( (q-vec3(0.0,-0.35,1.0))*vec3(1.0,1.2,0.25)/1.2 ) -0.3/1.2;\n\tfloat of = 0.1*pow(smoothstep( 0.0, 0.2, abs(p.x-0.3) ),0.5);\n\tmo = max( mo, -q.y-0.35-of );\n\n\tfloat li = smoothstep( 0.0, 0.05, mo+0.02 ) - smoothstep( 0.05, 0.10, mo+0.02 );\n\tres.x -= 0.03*li*clamp( (-q.y-0.4)*10.0, 0.0, 1.0 );\n\t\n\tif( -mo > res.x )\n\t\tres = vec2( -mo, 4.0 );\n\n    res.x += 0.01*(smoothstep( 0.0, 0.05, mo+0.062 ) - smoothstep( 0.05, 0.10, mo+0.062 ));\n\n    // teeth\t\n\tif( p.x<0.3 )\n\t{\n    p.x = mod( p.x, 0.16 )-0.08;\t\n    float d5 = length( (p-vec3(0.0,-0.37,0.65))*vec3(1.0,2.0,1.0))-0.08;\n\tif( d5<res.x )\n\t\tres = vec2( d5, 2.0 );\n\t}\n\t\n\treturn vec2(res.x*0.8,res.y);\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0    \n    vec3 eps = vec3(0.002,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.002*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float m = -1.0;\n\tfloat mint = 10.0;\n\n    // plane\t\n\tfloat tf = (0.0-ro.y)/rd.y;\n\tif( tf>0.0 ) { mint = tf; m = 0.0; }\n\t\n\t// mike\n\tfloat maxd = min(5.0,mint);\n\tfloat precis = 0.001;\n    float t = 0.0;\n\tfloat d = 0.0;\n    for( int i=ZERO; i<128; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        float h = res.x;\n\t\td = res.y;\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t<maxd && t<mint )\n\t{\n\t\tmint = t;\n\t\tm = d;\n\t}\n\n    return vec3( mint, m, m );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<50; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n\t\tt += clamp( h, 0.01, 0.25 );\n\t\tif( res<0.005 || t>10.0 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\nvec3 lig = normalize(vec3(1.0,0.7,0.9));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n\t//if( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n    \n\t#ifdef STEREO\n\tfloat eyeID = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n    #endif\n\n\n\t\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\t\n\tfloat an = sin(-0.25 + 0.31416*timeWarp(q)) - 6.2831*(m.x-0.5);\n\n\tvec3 ro = vec3(3.5*sin(an),1.8,3.5*cos(an));\n    vec3 ta = vec3(0.0,1.5,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n\t#ifdef STEREO\n\tvec3 fo = ro + rd*7.0; // put focus plane behind Mike\n\tro -= 0.1*uu*eyeID;    // eye separation\n\trd = normalize(fo-ro);\n    #endif\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = vec3(1.0);\n\n\t// raymarch\n    vec3 tmat = intersect(ro,rd);\n    if( tmat.z>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\n        // materials\n\t\tvec4 mate = vec4(0.0);\n\t\tvec2 mate2 = vec2(1.0,1.0);\n\t\tif( tmat.z<0.5 )\n\t\t{\n\t\t\tnor = vec3(0.0,1.0,0.0);\n\t\t    ref = reflect( rd, nor );\n\t\t\tmate.xyz = vec3(1.0);\n            mate2.y = 1.0 - 0.9*(2.0/(2.0+dot(pos.xz,pos.xz)));\n\t\t}\n\t\telse if( tmat.z<1.5 )\n\t\t{\n            mate2.x = 4.0;\n\t\t\tmate = vec4(0.16,0.32,0.0,0.8);\n\n            float f = texturize( iChannel0, 0.15*pos, nor ).x * texturize( iChannel0, 0.2*0.25*pos, nor ).x;\n\t\t\tmate.xyz = mix( 0.8*mate.xyz, vec3(0.3,0.4,0.0), f );\n\n\t\t\tf = texturize( iChannel0, pos, nor ).x * texturize( iChannel0, 0.25*pos, nor ).x;\n\t\t\tf = f*f;\n\t\t    mate.xyz = mix( mate.xyz, vec3(0.3,0.4,0.0), 0.6*f );\n\n\t\t\tvec3 bnor = -1.0+2.0*texturize( iChannel0, 4.0*pos, nor );\n\t\t\tnor = normalize( nor + 0.15*bnor );\n\t\t\t\n\t\t\tmate.xyz *= 0.7;\n\n\t\t}\n\t\telse if( tmat.z<2.5 )\n\t\t{\n\t\t\tvec3 q = pos-vec3(0.0,1.8,0.0) - vec3(0.0,0.44,0.35);\n\n\t\t\tfloat an2 = an + 0.015*(-1.0+2.0*noise( 6.0*iTime ));\n            vec3 oq = q;\t\t\t\n\t\t\tq.x += -2.0*0.15*clamp(sin(an2),-0.42,0.42);\n\t\t\tfloat f = length( q.xy );\n\t\t\t\n\t\t\tmate2.y = 1.0-smoothstep(0.24,0.35,length( oq.xy-vec2(0.0,0.035) ));\n\t\t\t//mate2.y = 1.0-smoothstep( 0.3, 0.4, f );\n\n\t\t\tmate = vec4(0.5,0.5,0.5,1.0);\n\t\t\tmate.xyz = mix( mate.xyz, vec3(0.6,0.4,0.3), 0.5*smoothstep(0.1,0.4,f) );\n\t\t\t\n            vec3 c1 = vec3(0.0,0.15,0.05)*(1.0-0.85*f/0.19);\n\t\t\tfloat a = atan(q.y,-q.x);\n            float te = fbm( 20.0*vec2(0.3*a,1.0*f) );\n\t\t\tc1 *= 0.3 + 5.0*te;\n            \n            c1 += vec3(0.5,1.0,0.1)*0.35*(0.5+te)*\n                (1.0-smoothstep( 0.3,1.2,abs(a+0.5)))*\n                (1.0-smoothstep( 0.0, 0.06, abs(f-0.125) ));\n            \n            \n\t\t\tmate.xyz = mix( mate.xyz, c1, 1.0-smoothstep( 0.18, 0.19, f ) );\n\n\t\t\toq.x += -2.0*0.19*clamp(sin(an2),-0.42,0.42);\n\t\t\tf = length( oq.xy );\n\t\t\tmate.xyz *= smoothstep( 0.07, 0.10, f );\n            \n            mate.xyz *= 1.0-0.2*vec3(0.5,0.9,1.0)*smoothstep( 0.2, 0.4, f );\n            \n\t\t\tmate.w = 2.0;\n            mate2.x = 64.0;\n\t\t}\n\t\telse if( tmat.z<3.5 )\n\t\t{\n\t\t\tmate = 0.8*vec4(0.85,0.7,0.6,0.0);\n            mate2.x = 0.0;\n\n\t\t\tfloat f = smoothstep( 0.0, 0.1, 0.5*abs(pos.x)+pos.y-3.02 );\n\t\t\tmate.xyz *= 1.0 - 0.8*vec3( f );\n\t\t\t\n\t\t\tmate.xyz *= 0.2 + 0.8*smoothstep( 0.0, 1.0, texturize( iChannel0, 0.1*2.1*pos*vec3(4.0,0.1,4.0), nor ).x );\n\t\t}\n\t\telse if( tmat.z<4.5 )\n\t\t{\n\t\t\tfloat z = smoothstep( 0.0, 2.0, pos.z+0.5 );\n\t\t\tmate = 0.5*vec4(0.5,0.25,0.1,0.0);\n\t\t\tmate.x += 0.1*(1.0-z);\n\t\t\tmate2.y = z;\n\t\t}\n\n\n\t\t// lighting\n\t\tfloat occ = (0.5 + 0.5*nor.y)*mate2.y;\n        float amb = 0.5;\n\t\tfloat bou = clamp(-nor.y,0.0,1.0);\n\t\tfloat dif = max(dot(nor,lig),0.0);\n        float bac = max(0.3 + 0.7*dot(nor,-lig),0.0);\n\t\tfloat sha = 0.9;// if( dif>0.01 ) sha=softshadow( pos+0.01*nor, lig, 0.001, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n        vec3  hal = normalize(lig-rd);\n        float spe = max(pow( clamp( dot(nor,hal), 0.0, 1.0), mate2.x*4.0 ),0.0 );\n\t\t\n\t\t// lights\n\t\tvec3 lin = vec3(0.0);\n        lin += 2.0*dif*vec3(1.00,1.00,1.00)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tlin += 1.0*amb*vec3(0.30,0.30,0.30)*occ;\n\t\tlin += 2.0*bou*vec3(0.40,0.40,0.40)*mate2.y;\n\t\tlin += 4.0*bac*vec3(0.40,0.30,0.25)*occ;\n        lin += 1.0*fre*vec3(1.00,1.00,1.00)*2.0*mate.w*(0.5+0.5*dif*sha)*occ;\n\n\t\tcol = mate.xyz*lin;\n\t\tcol += 4.0*spe*vec3(2.0)*mate.w*dif*sha*(0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n\t}\n\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n\t// vigneting\n    col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 );\n\n    #ifdef STEREO\t\n    col *= vec3( eyeID, 1.0-eyeID, 1.0-eyeID );\t\n\t#endif\n\t   \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tlSRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tlSzH", "name": "Quadratic Bezier SDF", "author": "zlnimda", "description": "View of signed distance function that I previously wrote here: https://www.shadertoy.com/view/Mt33zr", "tags": ["2d", "bezier", "quadratic"], "likes": 3, "viewed": 433, "date": "1562086686", "time_retrieved": "2024-06-20T19:39:48.621113", "image_code": "/* ----------------\n*\tzlnimda wrote this file and is under license CC-BY-SA-4.0 \n* \t( see legal notice: https://creativecommons.org/licenses/by-sa/4.0/legalcode )\n/* ----------------\n* \tBezier algo from my previous shader: https://www.shadertoy.com/view/Mt33zr\n* \tPoints and distance view from iq: https://www.shadertoy.com/view/MlKcDD\n*/\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat weight(float dist)\n{\n    return pow(max(0., 1. - dist), 100.);\n}\n\nvec2 BezierDeg3(vec2 p0, vec2 p1, vec2 p2, float t)\n{\n    // bezier formula following bernstein Bez(t) = E(i->n)Bern(t).Pi with t=[0,1]\n    // Deg3 -> Bez(t) = (1-t)Â²P0 + 2t(1-t)P1 +tÂ²P2\n    return p0*pow(1.-t, 2.) + p1*2.*t*(1.-t) + p2*t*t;\n}\n\n// Cardano's method : https://en.wikipedia.org/wiki/Cubic_function#Cardano's_method\nvec3 Cardan(float p, float q)\n{\n    float p3 = p*p*p;\n    float D = - (4.*p3+27.*q*q);\n    if (D > 0.)\n    {\n        float a = 2.*sqrt(-p/3.);\n        float b = acos(sqrt(27./(-p3))*-q/2.)/3.;\n        return vec3(a*cos(b), a*cos(b+2.*M_PI/3.), a*cos(b+4.*M_PI/3.));\n    }\n    else if (D < 0.)\n    {\n        float coef = 1./3.;\n        float DD = sqrt(-D/27.);\n        float u = (-q+DD)/2.;\n        u = sign(u)*abs(pow(abs(u), 1./3.));\n        float v = (-q-DD)/2.;\n        v = sign(v)*pow(abs(v), 1./3.);\n        return vec3(u + v);\n    }\n    else\n    {\n        if (p == 0. || q == 0.)\n            return vec3(0.);\n        float r = 3.*q/p;\n        float r2 = -3.*q / (2.*p);\n        return vec3(r, r2, r2);\n    }\n}\n\n// Resolve cubic equation\nvec3 resolveEqDeg3(float a, float b, float c, float d)\n{\n    vec3 A = vec3(b, c, d) / a;\n    float p = A.y - A.x*A.x/3.;\n    float q = A.x*(2.*A.x*A.x-9.*A.y)/27.+A.z;\n    return Cardan(p, q) - (b / (3.*a));\n    \n}\n\n// Main element to bezier curve SDF\nfloat dBezier(vec2 pos, vec2 p0, vec2 p1, vec2 p2)\n{\n    // dP/dt(t) = 2(A+Bt)\n    // simplified from \n    // dP/dt(t) = -2(1-t)P0 + 2(1-2t)P1 + 2tP2\n    vec2 A = p1-p0;\n    vec2 B = p2 - p1 - A;\n    \n    // search for equation\n    // MP.dP/dt = 0\n    vec2 M = p0 - pos;\n    vec3 t = resolveEqDeg3(dot(B, B), dot(A, B)*3., dot(A,A)*2.+dot(M,B), dot(M,A));\n    \n    float d = 1000.;\n    \n    if (t.x >= 0. && t.x <= 1.)\n        d = min(d, distance(pos, BezierDeg3(p0, p1, p2, t.x)));\n\tif (t.y >= 0. && t.y <= 1.)\n        d = min(d, distance(pos, BezierDeg3(p0, p1, p2, t.y)));\n    if (t.z >= 0. && t.z <= 1.)\n        d = min(d, distance(pos, BezierDeg3(p0, p1, p2, t.z)));\n    return d;\n}\n\n// signed function to a quadratic bezier curve\nfloat dBezierCorrect(vec2 uv, vec2 p0, vec2 p1, vec2 p2)\n{\n    float d = distance(p0,uv);\n    d = min (d, distance(p2,uv));\n    d = min (d, dBezier(uv, p0, p1, p2));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec2 p0 = vec2(1.3,0.9)*cos(iTime*1.1 + vec2(0.0,5.0) );\n    vec2 p1 = vec2(1.3,0.9)*cos(iTime*1.2 + vec2(3.0,4.0) );\n    vec2 p2 = vec2(1.3,0.9)*cos(iTime*1.3 + vec2(2.0,1.0) );\n    \n    float d = dBezierCorrect(uv, p0, p1, p2);\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tlSzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tlXR4", "name": "Jigsaw Pattern", "author": "fizzer", "description": "I was inspired by [url=https://www.shadertoy.com/view/XdGBDW]this[/url] awesome shader by Shane to try a simpler jigsaw pattern without needing to loop through neighbouring pieces, and which allows fast random sampling. Hold LMB to \"reveal\" the structure.", "tags": ["pattern", "jigsaw"], "likes": 21, "viewed": 481, "date": "1562336274", "time_retrieved": "2024-06-20T19:39:49.281679", "image_code": "#define AA 3\n\n// Constants\nconst float pi = 3.14159265358979323;\nconst float th = pi / 4.;\nconst mat2 m = mat2(cos(th), sin(th), -sin(th), cos(th));\nconst float rs2 = 1. / sqrt(2.);\n\n// polynomial smooth min\n// from iq: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// Jigsaw pattern function, returns random piece colour in RGB and SDF in A.\nvec4 jigsaw(vec2 uv)\n{\n    vec2 uv2 = m * (uv - .5) * rs2 * 2.;\n    \n    vec2 c = floor(uv), f = uv - c - .5;\n    vec2 c2 = floor(uv2), f2 = uv2 - c2;\n    \n    bool flip = texelFetch(iChannel0, ivec2(c2) & 255, 0).r > .5;\n    \n    vec2 mdir = step(abs(f).yx, abs(f)) * sign(f);\n\n    vec2 f2b = m * (f2 - .5);\n    \n    if(mod(c2.x + c2.y, 2.) > .5)\n        f2b = vec2(-f2b.y, f2b.x);\n\n    // SDF\n    float d = smin(flip ? -f2b.y : f2b.y, length(f2b - vec2(0, flip ? -.1 : .1)) - .25, 1. / 32.);\n\n    if(mod(c2.x, 2.) < .5 != flip != mod(c.x + c.y, 2.) > .5)\n        d = -d;\n    \n    if(d < 0.)\n    \tc += mdir;\n    \n    return vec4(texelFetch(iChannel1, ivec2(c) & 255, 0).rgb, abs(d));\n}\n\nfloat hmap(float h)\n{\n    return sqrt(smoothstep(0., .07, h));\n}\n\nvoid render( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    uv *= 3.;\n\n    float th = sin(iTime / 10.);\n    \n    // Animation\n    uv = mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n    uv *= 1. + .1 * sin(iTime);\n    uv.y += cos(iTime / 6.) * 3.;\n    \n    vec2 e = vec2(1e-3, 0);\n    \n    vec4 jig0 = jigsaw(uv);\n    \n    // Extract gradient for shading\n    float h0 = hmap(jigsaw(uv + e.xy).a);\n    float h1 = hmap(jigsaw(uv - e.xy).a);\n    float h2 = hmap(jigsaw(uv + e.yx).a);\n    float h3 = hmap(jigsaw(uv - e.yx).a);\n    \n    vec3 n = normalize(vec3(h0 - h1, e.x * 8., h3 - h2));\n        \n    vec3 col;\n    vec2 tuv = uv;\n    \n    if(jig0.b > .5)\n        tuv = tuv.yx;\n\n    // Shading\n    col = .05 + .95 * textureLod(iChannel2, jig0.rg, 0.).rgb;\n    vec3 w = textureLod(iChannel3, tuv / 2. + jig0.rg, 1.).rrr;\n    col *= smoothstep(-.1, 1., w);\n    \n    // Increase saturation\n    float b = dot(col, vec3(1. / 3.));\n    col = vec3(b) + (col - b) * 2.;\n    \n    fragColor.rgb = col * (.5 + .5 * dot(n, normalize(vec3(1)))) *\n        \t\tmix(.1, 1., smoothstep(0., .04, abs(jig0.a)));\n    \n    fragColor.rgb += pow(w.x, 2.) * pow(clamp(dot(n, normalize(vec3(1))), 0., 1.), 16.) * 1.;    \n    \n    if(iMouse.z > .5)\n    {\n        // Pattern structure visualisation\n        fragColor.rgb /= 2.;\n        float mask0 = step(min(fract(uv.x), fract(uv.y)), .03);\n    \tvec2 uv2 = m * (uv - .5) * rs2 * 2.;\n        float mask1 = step(min(fract(uv2.x), fract(uv2.y)), .03 / rs2);\n        fragColor.rgb = mix(fragColor.rgb, vec3(1, .2, 0), step(jig0.a, .02));\n        fragColor.rgb = mix(fragColor.rgb, vec3(1, 1, 0), mask1);\n        fragColor.rgb = mix(fragColor.rgb, vec3(0, .5, 1), mask0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.a = 1.;\n    fragColor.rgb = vec3(0);\n    \n    // Anti-aliasing loop\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x)\n        {\n            vec4 rc;\n            render(rc, fragCoord + vec2(x, y) / float(AA));\n            fragColor.rgb += clamp(rc.rgb, 0., 1.);\n        }\n    \n    fragColor.rgb /= float(AA * AA);\n\n    fragColor.rgb = fragColor.rgb / (fragColor.rgb + 1.)  * 2.5;\n    \n    fragColor.rgb = pow(clamp(fragColor.rgb, 0., 1.), vec3(1. / 2.2));\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tlXR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tlXWS", "name": "electron beam", "author": "artemis", "description": "electron beam over a funky grid", "tags": ["2d", "retro", "light", "synthwave"], "likes": 17, "viewed": 1279, "date": "1564100967", "time_retrieved": "2024-06-20T19:39:49.281679", "image_code": "#define FALLOFF_START 1.0\n#define DECAY_START 0.1\n#define DECAY 1.0\n\n#define GRIDW 0.02\n\n#define GRID_R 0.672443156957688\n#define GRID_G 0.0103298230296269\n#define GRID_B 0.246201326707835\n#define FALLOFF_GRID 0.75\n\n//#define GRID_R 0.0544802764424424\n//#define GRID_G 0.0\n//#define GRID_B 0.0761853814813079\n\nfloat sRGB(float x) {\n    if (x <= 0.00031308)\n        return 12.92 * x;\n    else\n        return 1.055*pow(x,(1.0 / 2.4) ) - 0.055;\n}\n\nfloat saw(float t) {\n \treturn t - floor(t);   \n}\n\nfloat tri(float t) {\n    return 2.0 * abs(t - floor(t + 0.5));\n}\n\nfloat grid(vec2 pix, float t) {\n    \n    float d = t + (pix.y / 30.0) + sin(pix.x * 500.0);\n    \n    float distortion = (sin(d * 400.0) + (sin(d * 600.0) / 2.0) + (sin(d * 800.0) / 3.0)) / 4.0;\n    \n    //float w = max(0.0, tri((pix.x + distortion) / 8.0) - (1.0 - GRIDW)) / GRIDW;\n    //float h = max(0.0, tri((pix.y + distortion) / 8.0) - (1.0 - GRIDW)) / GRIDW;\n    \n    float w = tri((pix.x + distortion) / 50.0);\n    float h = tri((pix.y + distortion) / 50.0);\n    \n    \n    float power = 1.0 + 0.25 * tri(pix.y / 50.0 + t / 6.0);\n    \n    float falloff = power * FALLOFF_GRID;\n    \n    float dist = min(w, h) * 25.0;\n    \n    \n    \n    //return min(power, max(w, h)\n    return min(power, power * (falloff * falloff) / (dist * dist));\n\n    \n    //return w;\n}\n\nfloat electron_beam(vec2 pix, float t) {\n\n    \n    float beam_x = (cos(t * 1.0) * 250.0 + 1.0) / 2.0;\n    float beam_y = (sin(t * 10.0 / 9.0) * 200.0 + 1.0) / 2.0;\n\n    float dist = distance(pix, vec2(beam_x, beam_y));\n    \n    float power = 1.0 - (min(iTime - t, DECAY) / DECAY);\n    \n    float falloff = power * FALLOFF_START;\n    \n    return min(power, power * (falloff * falloff) / (dist * dist));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    \n    \n    vec2 center = iResolution.xy / 2.0;\n    \n    float scale = 512.0 / iResolution.x;\n    \n    vec2 uv = (fragCoord - center) * scale;\n    \n    \n        \n    float beam = 0.0;\n    \n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        beam += electron_beam(uv, iTime - t);\n        t += 0.01;\n    }\n    \n    vec2 uv_r = uv - vec2(sin(iTime / 5.0 + uv.y / 100.0) * 2.0, sin(uv.x / 75.0 + iTime / 8.0));\n    vec2 uv_g = uv;\n    vec2 uv_b = uv + vec2(sin(iTime / 4.0 + uv.y / 100.0) * 2.0, cos(uv.x / 50.0 + iTime / 4.0));\n    \n    float grid_r = grid(uv_r, iTime) * GRID_R;\n    float grid_g = grid(uv_g, iTime - 0.1) * GRID_G;\n    float grid_b = grid(uv_b, iTime + 0.1) * GRID_B;\n    \n    vec3 grid_col = vec3(sRGB(grid_r), sRGB(grid_g), sRGB(grid_b));\n    vec3 beam_col = vec3(sRGB(beam * 0.25), sRGB(beam), sRGB(beam));\n    \n    fragColor = vec4(grid_col + beam_col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tlXWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tsSDr", "name": "chladni emulator cymatics salt", "author": "henry", "description": "chaldni emulator cymatics waves wave tank. lot of possibilities with this cheap algorythm. see shader code top for details. \n\n\n", "tags": ["symmetry", "chladni", "singularity", "wavecompression", "collapsedbaryoncompression"], "likes": 12, "viewed": 570, "date": "1562594678", "time_retrieved": "2024-06-20T19:39:49.796995", "image_code": "/*five concentric waves additively, \nouter wave origins can move away from center of image for variance. \nThis was imagined to mimic the reverberations of the edges \nof a square plane of metal which is tricky to \nemulate as it uses resoncance feedback.\nThe central concentric wave is the plate shaking up and down, \nand the 4 edge waves are the waves returning from the metal plane sides.\nappears fine with 5 and 9 waves.\n\nit's a wavetank of this symmetry using salt fx. \n\n @\n@@@\n @\n\n*/ \n\n// Noise pixel size\n#define SIZE 1.0\n// Lower - more flowing\n#define FLUENCY 0.85\nfloat rand(vec2 co) { \n    return fract(sin(dot(co.xy , vec2(12.9898, 78.233))) * 43758.5453);\n} \n\nvoid mainImage(out vec4 color, vec2 UVcoords)\n{\n    \n          vec2 id = ceil(UVcoords/SIZE);    \n    vec2 rid = vec2(rand(id), rand(id+iResolution.y));    \n    color = -vec4( 0.1/fract(rid.x + rid.y - iTime * FLUENCY)-0.1)*15.0;//sparke effect\n    \n   float d3 = iResolution.y*.5 ,//number to move pic upwards\n         d4 =  iResolution.x*.5 ,//number to move pic sideways\n         d2 = 8.0 - 2.0 * sin( 5.0+iTime*.07 ) + iMouse.y*0.021, //number to move 5 wave machines outwards\n    \td1 = .5; ;// wave width\n   UVcoords = .5*(UVcoords - vec2(d4,d3)); //move pic around\n    \n    \n\t//function to make color concentric sinewaves like water drop waves radiating from a pt:   \n#define S(X, Y, period)   color += sin(length(UVcoords + vec2(X,Y)*d2)*period)-.2;\n    \n         \n    \n    \n    //if (color.x<0.0)\n  \n    \n    \n    \n    // color += sin(UVcoords.x*100.0*iTime)/6.0;\n    //  color += sin(UVcoords.y*150.0*iTime)/6.0;  \n    // sin(length()*p2)+v2\n\t//see end for full formula including angular coordinates as well as concentric\n\t//Tip: to remix the code, you can try mixing 3/4/8 \n    //wave machines in different symmetries and vary their distance and amplitudes\n  \n\n   \n//make 5 wave machines where the color is added t*d2ogether on coordinates of pentagon:\n    \n    //these dots are arranged in a + arrangement, one origin for on xy axes. \n    //central wave machine on origin\n    S(0.0,0.0,iMouse.x*0.002)\n        \n    //4 other wave machines on axes\n    S(0,1.0*d2,d1)  S(0,-1.0*d2,d1)  S(-1.0*d2,-0.0,d1)  S(1.0*d2,0.0,d1)  \n        \n        \n}\n    \n\n//NOTE: original version had concentric wave forms in this fasion:\n\n//float2 xy2 = IN.uv_MainTex + float2(-0.5, -0.5*d3 ) + float2(k1,j1)*d2; \n//position of the point\n\n//float c2 = length(xy2);//polar coordinates (x axis becomes radial)\n\n//ht+=  (sin(c2 * p2)  *v2) ;//angular coordinates (y becomes angle)\n    \n    \n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tsSDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tsSWN", "name": "3D Julia Set Slow Loader", "author": "Veggiebob", "description": "A slow loader for more detailed 3D Julia set fractals", "tags": ["3d", "fractal", "julia"], "likes": 2, "viewed": 180, "date": "1562959555", "time_retrieved": "2024-06-20T19:39:49.796995", "image_code": "#define MAX_ITERS 18\n#define MAX_STEPS 5000\nvec3 sq3 (vec3 v) {\n    return vec3(\n        v.x*v.x-v.y*v.y-v.z*v.z,\n        2.*v.x*v.y,\n        2.*v.x*v.z\n    );\n}\nfloat squishy (float x) {\n    return x*x*x;\n}\nfloat julia (vec3 p, vec3 c) {\n    vec3 k = p;\n    for(int i = 0; i<MAX_ITERS; i++) {\n        k = sq3(k) + c;\n        if(length(k)>10.) return 1.-squishy(float(i)/float(MAX_ITERS));\n    }\n    return -0.001;\n}\nvec2 rotate2D (vec2 p, float angle){\n    return vec2(p.x*cos(angle)-p.y*sin(angle), p.y*cos(angle)+p.x*sin(angle));\\\n}\nfloat sdf (vec3 p) {\n  \tvec3 r = p;\n    r.xz = rotate2D(r.xz, iTime*0.3);\n    r.yz = rotate2D(r.yz, iTime*0.1);\n    float t = 15.23;\n    return julia(p,\n                 \n                 vec3(sin(t*0.3)*0.7, cos(t*0.4)*0.7, 0.1)\n                     //vec3(sin(iTime*0.3)*0.7, cos(iTime*0.4)*0.7, 0.1)\n    );\n    //return length(p)-1.;\n}\nvec4 trace (vec3 o, vec3 r) {\n    vec3 p = o;\n    float t = 0.;\n    float s;\n    int i;\n    for(i = 0; i<MAX_STEPS; i++) {\n        p = o+r*t;\n        s = sdf(p);\n        t+=s*0.0005;\n\t\tif(t>10.) break;\n    }\n    return vec4(p, float(i));\n}\nconst float E = 0.01;\nvec3 estimateNormal (vec3 p) {\n    return normalize(vec3(\n        sdf(vec3(p.x+E, p.y, p.z))-sdf(vec3(p.x-E, p.y, p.z)),\n        sdf(vec3(p.x, p.y+E, p.z))-sdf(vec3(p.x, p.y-E, p.z)),\n        sdf(vec3(p.x, p.y, p.z+E))-sdf(vec3(p.x, p.y, p.z-E))\n    ));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(abs(mod(float(iFrame)*4., iResolution.y)-fragCoord.y)<6.) {\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = fragCoord/iResolution.xy;\n        uv-=0.5;\n        vec2 mouse = iMouse.xy/iResolution.xy;\n        mouse-=0.5;\n        float aspect = iResolution.y/iResolution.x;\n        uv.x/=aspect;\n        mouse.x/=aspect;\n        vec3 cam = vec3(0., 0., -2.);\n        vec3 ray = normalize(vec3(uv.xy*1.3, 1.));\n\n        vec3 rot = vec3(mouse.y*5., -mouse.x*3., 0.);\n\n        cam.xz = rotate2D(cam.xz, rot.y);\n        ray.xz = rotate2D(ray.xz, rot.y);\n\n        cam.zy = rotate2D(cam.zy, rot.x);\n        ray.zy = rotate2D(ray.zy, rot.x);\n\n\n        vec4 t = trace(cam, ray);\n        vec3 e = t.xyz;\n        vec3 light = vec3(0., 0., -5.);\n        vec3 toLight = normalize(light-e);\n        vec3 norm = estimateNormal(e);\n        float diffuse = max(0.,dot(toLight, norm))*0.8;\n        vec3 refl = reflect(ray, norm);\n        float specular = pow(max(0.0, dot(refl, toLight)), 4.0)*0.5;\n        float d = length(e-cam);\n        float fog = 1.0 / (1.0 + d*d*0.5);\n\n        vec3 col = vec3(1.);//texture(iChannel0, refl).rgb*1.+0.8;\n        //col -= pow(t.w/float(MAX_STEPS), 2.)*0.5;//ao\n        col *= (diffuse+specular)+0.1;//other light\n        col *= fog;\n\n        // Output to screen\n        fragColor = vec4(col,1.0);\n    } else {\n        fragColor = vec2(1.,sin(iTime)).xyyy;\n        discard;\n    }\n}", "image_inputs": [{"id": "4sfGzn", "previewfilepath": "/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tsSWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tsXDB", "name": "Rendering Parametrics", "author": "NinjaKoala", "description": "Rendering parametrics with a special distance estimation where start parameters are distributed evenly and then an iteration is used which minimizes distance of the current point to the curve normal.", "tags": ["2d", "distance", "curve", "graph", "plot", "parametric"], "likes": 12, "viewed": 404, "date": "1564145100", "time_retrieved": "2024-06-20T19:39:53.342539", "image_code": "//#define SHOW_DISTANCE_FIELD\n//#define USE_VARIANT\n//#define SECOND_ORDER\n//#define HYBRID\n//#define SEGMENTS\n\n#define PARAMETRIC 1\n\n/*\nCurves 1,2,3 and 6 by me\nCurves 4 and 5 by iq (see https://www.shadertoy.com/view/Mlf3zl and https://www.shadertoy.com/view/Xlf3zl)\nCurves 7 to 11 by nimitz (see https://www.shadertoy.com/view/XdSSRw)\n\nUses the same technique as in https://www.shadertoy.com/view/3lsSR2\nand https://www.shadertoy.com/view/3lsSzS\n\nI also implemented a variant where only the n nearest points on the curve\nare used as start parameters, this however doesn't work very well generally.\n*/\n\nconst float dot_size = .0025;\nconst float line_size = .001;\n\nconst vec3 bg_col = vec3(1);\nconst vec3 point_col = vec3(1,0,0);\nconst vec3 line_col = vec3(0);\n\nconst float zoom = 1.;\n\nconst float pi = 3.1415926535;\n\nconst int num_segments = 256;\n\nconst float eps = .005;\n\nconst float factor = 1.;\n\nfloat sfloor(in float x, in float w){\n    float fx = floor(x);\n    return fx+smoothstep(fx+w,fx+1.-w,x);\n}\n\n#if PARAMETRIC == 1\n//Random parametric curve 1\nconst int num_iterations = 3;\nconst int num_start_params = 25;\n\nconst int num_iterations2 = 3;\nconst int num_start_params2 = 49;\nconst int num_mins=5;\n\nvec2 parametric(float t){\n\tt *= 2.*pi;\n\tfloat x = (1.5+cos(10.*t))*cos(3.*t);\n\tfloat y = (1.5-cos(10.*t))*sin(3.*t);\n\n\treturn 1./10.*vec2(x,y);\n}\n\nvec2 parametric_diff(float t){\n\tt *= 2.*pi;\n\tfloat x = -10.0*cos(3.0*t)*sin(10.0*t) - 3.0*cos(10.0*t)*sin(3.0*t) - 4.5*sin(3.0*t);\n\tfloat y = -3.0*cos(10.0*t)*cos(3.0*t) + 10.0*sin(10.0*t)*sin(3.0*t) + 4.5*cos(3.0*t);\n\n\treturn 2.*pi*1./10.*vec2(x,y);\n}\n\nvec2 parametric_snd_diff(float t){\n\tt *= 2.*pi;\n\tfloat x = -109.0*cos(10.0*t)*cos(3.0*t) + 60.0*sin(10.0*t)*sin(3.0*t) - 13.5*cos(3.0*t);\n\tfloat y = 60.0*cos(3.0*t)*sin(10.0*t) + 109.0*cos(10.0*t)*sin(3.0*t) - 13.5*sin(3.0*t);\n\n\treturn 4.*pi*pi*1./30.*vec2(x,y);\n}\n#elif PARAMETRIC == 2\n//Random parametric curve 2\nconst int num_iterations = 3;\nconst int num_start_params = 31;\n\nconst int num_iterations2 = 3;\nconst int num_start_params2 = 49;\nconst int num_mins = 5;\n\nvec2 parametric(float t){\n\tt *= 2.*pi;\n\n\tfloat x = 3.*(1.+.75*cos(t*10.))*cos(t);\n\tfloat y = 3.*(1.-.75*cos(t*10.))*sin(t);\n\n\treturn 1./20.*vec2(x,y);\n}\n\nvec2 parametric_diff(float t){\n\tt *= 2.*pi;\n\n\tfloat x = -22.5*cos(t)*sin(10.0*t) - 2.25*cos(10.0*t)*sin(t) - 3.0*sin(t);\n\tfloat y = -2.25*cos(10.0*t)*cos(t) + 22.5*sin(10.0*t)*sin(t) + 3.0*cos(t);\n\n\treturn 1./20.*2.*pi*vec2(x,y);\n}\n\nvec2 parametric_snd_diff(float t){\n\tt *= 2.*pi;\n\n\tfloat x = -227.25*cos(10.0*t)*cos(t) + 45.0*sin(10.0*t)*sin(t) - 3.0*cos(t);\n\tfloat y = 45.0*cos(t)*sin(10.0*t) + 227.25*cos(10.0*t)*sin(t) - 3.0*sin(t);\n\n\treturn 1./20.*4.*pi*pi*vec2(x,y);\n}\n#elif PARAMETRIC == 3\nconst int num_iterations=4;\nconst int num_start_params=45;\n\nconst int num_iterations2=5;\nconst int num_start_params2=255;\nconst int num_mins=6;\n\nvec2 parametric(float t){\n\tt*=2.*pi;\n\n\tfloat x=tan(7.*t)*cos(13.*t);\n\tfloat y=tan(7.*t)*sin(13.*t);\n\n\treturn 1./2.*vec2(x,y);\n}\n\nvec2 parametric_diff(float t){\n\tt*=2.*pi;\n\n\tfloat x=7.*(tan(7.*t)*tan(7.*t)+1.)*cos(13.*t)-tan(7.*t)*sin(13.*t);\n\tfloat y=7.*(tan(7.*t)*tan(7.*t)+1.)*sin(13.*t)+tan(7.*t)*cos(13.*t);\n\n\treturn 1./2.*2.*pi*vec2(x,y);\n}\n\nvec2 parametric_snd_diff(float t){\n\tt*=2.*pi;\n\n\tfloat x=-((13.*cos(7.*t)*cos(7.*t) - 98.)*cos(13.*t)*sin(7.*t) + 98.*cos(7.*t)*sin(13.*t))/(cos(7.*t)*cos(7.*t)*cos(7.*t));\n\tfloat y=-((13.*cos(7.*t)*cos(7.*t) - 98.)*sin(13.*t)*sin(7.*t) - 98.*cos(13.*t)*cos(37.*t))/(cos(7.*t)*cos(7.*t)*cos(7.*t));\n\n\treturn 1./2.*2.*2.*pi*pi*vec2(x,y);\n}\n#elif PARAMETRIC == 4 || PARAMETRIC == 5\n//Parametric curve by iq\nconst int num_iterations = 3;\n\n#if PARAMETRIC == 4\nconst int num_start_params = 19;\n\nconst int num_iterations2 = 3;\nconst int num_start_params2 = 23;\nconst int num_mins = 5;\n#else\nconst int num_start_params = 25;\n\nconst int num_iterations2 = 3;\nconst int num_start_params2 = 60;\nconst int num_mins = 5;\n#endif\nvec2 parametric(float t)\n{\n\t#if PARAMETRIC == 5\n\tfloat a = 0.85 + 0.1*cos(mod(5.0+0.7*iTime,2.*pi));\n    float b = 0.60 + 0.1*cos(mod(4.0+0.5*iTime,2.*pi));\n    float c = 0.40 + 0.1*cos(mod(1.0+0.3*iTime,2.*pi));\n    vec2 m = cos(mod(0.11*iTime + vec2(2.0,0.0),2.*pi));\n    vec2 n = cos(mod(0.17*iTime + vec2(3.0,1.0),2.*pi));\n\t#else\n\tfloat a=.85;\n\tfloat b=.6;\n\tfloat c=.4;\n\tvec2 n=vec2(0,1);\n\tvec2 m=vec2(0,1);\n\t#endif\n\n\tt*=2.*pi;\n\n    return 1./4.*(a*cos(t+m)*(b+c*cos(t*7.0+n)));\n}\n\nvec2 parametric_diff(float t)\n{\n\t#if PARAMETRIC == 5\n\tfloat a = 0.85 + 0.1*cos(mod(5.0+0.7*iTime,2.*pi));\n    float b = 0.60 + 0.1*cos(mod(4.0+0.5*iTime,2.*pi));\n    float c = 0.40 + 0.1*cos(mod(1.0+0.3*iTime,2.*pi));\n    vec2 m = cos(mod(0.11*iTime + vec2(2.0,0.0),2.*pi));\n    vec2 n = cos(mod(0.17*iTime + vec2(3.0,1.0),2.*pi));\n\t#else\n\tfloat a=.85;\n\tfloat b=.6;\n\tfloat c=.4;\n\tvec2 n=vec2(0,1);\n\tvec2 m=vec2(0,1);\n\t#endif\n\n\tt*=2.*pi;\n\n    return 1./4.*2.*pi*(-7.0*a*c*cos(t+m)*sin(7.0*t+n) - a*sin(t+m)*(b+c*cos(7.0*t+n)));\n}\n\nvec2 parametric_snd_diff(float t)\n{\n\t#if PARAMETRIC == 5\n\tfloat a = 0.85 + 0.1*cos(mod(5.0+0.7*iTime,2.*pi));\n    float b = 0.60 + 0.1*cos(mod(4.0+0.5*iTime,2.*pi));\n    float c = 0.40 + 0.1*cos(mod(1.0+0.3*iTime,2.*pi));\n    vec2 m = cos(mod(0.11*iTime + vec2(2.0,0.0),2.*pi));\n    vec2 n = cos(mod(0.17*iTime + vec2(3.0,1.0),2.*pi));\n\t#else\n\tfloat a=.85;\n\tfloat b=.6;\n\tfloat c=.4;\n\tvec2 n=vec2(0,1);\n\tvec2 m=vec2(0,1);\n\t#endif\n\n\tt*=2.*pi;\n\n    return 1./4.*4.*pi*pi*(14.0*a*c*sin(t+m)*sin(7.0*t+n) - a*cos(t+m)*(b+c*cos(7.0*t+n)) - 49.0*a*c*cos(t+m)*cos(7.0*t+n));\n}\n#elif PARAMETRIC == 6\n//Archimedean spiral\nconst int num_iterations=3;\nconst int num_start_params=20;\n\nconst int num_iterations2=2;\nconst int num_start_params2=81;\nconst int num_mins=3;\n\nvec2 parametric(float t){\n\tt*=2.*pi;\n\n\tfloat a=10.;\n\n\tfloat x=t*sin(a*t);\n\tfloat y=t*cos(a*t);\n\n\treturn 1./25.*vec2(x,y);\n}\n\nvec2 parametric_diff(float t){\n\tt*=2.*pi;\n\n\tfloat a=10.;\n\n\tfloat x=a*t*cos(a*t) + sin(a*t);\n\tfloat y=-a*t*sin(a*t) + cos(a*t);\n\n\treturn 1./25.*2.*pi*vec2(x,y);\n}\n\nvec2 parametric_snd_diff(float t){\n\tt*=2.*pi;\n\n\tfloat a=10.;\n\n\tfloat x=-a*a*t*sin(a*t) + 2.*a*cos(a*t);\n\tfloat y=-a*a*t*cos(a*t) - 2.*a*sin(a*t);\n\n\treturn 1./25.*4.*pi*pi*vec2(x,y);\n}\n#elif PARAMETRIC == 7\n//Hypotrochoid\nconst int num_iterations=3;\nconst int num_start_params=18;\n\nconst int num_iterations2=3;\nconst int num_start_params2=60;\nconst int num_mins=5;\n\nvec2 parametric(float t){\n\tt*=2.*pi;\n\n\tfloat cam=mod(sfloor(iTime*0.6,.2)*pi,2.*pi);\n    float R=mod(floor(iTime*0.3),9.)+3.;\n    const float r=1.;\n    //float d = sin(time*1.)*2.+3.5;\n    float d=R;\n    float x = ((R-r)*cos(t-cam)+d*cos((R-r)/r*t))/(R+.5)*3.;\n    float y = ((R-r)*sin(t)-d*sin((R-r)/r*t))/(R+.5)*3.;\n\n\treturn 1./20.*vec2(x,y);\n}\n\nvec2 parametric_diff(float t){\n\tt*=2.*pi;\n\n\tfloat cam=mod(sfloor(iTime*0.6,.2)*pi,2.*pi);\n    float R=mod(floor(iTime*0.3),9.)+3.;\n    const float r=1.;\n    //float d = sin(time*1.)*2.+3.5;\n    float d=R;\n    float x=(-(R-r)*sin(t-cam)-d*(R-r)/r*sin((R-r)/r*t))/(R+.5)*3.;\n    float y=((R-r)*cos(t)-d*(R-r)/r*cos((R-r)/r*t))/(R+.5)*3.;\n\n\treturn 1./20.*2.*pi*vec2(x,y);\n}\n\nvec2 parametric_snd_diff(float t){\n\tt*=2.*pi;\n\n\tfloat cam=sfloor(iTime*0.6,.2)*pi;\n    float R=mod(floor(iTime*0.3),9.)+3.;\n    const float r=1.;\n    //float d = sin(time*1.)*2.+3.5;\n    float d=R;\n    float x=(-(R-r)*cos(t-cam)-d*(R-r)/r*(R-r)/r*cos((R-r)/r*t))/(R+.5)*3.;\n    float y=(-(R-r)*sin(t)+d*(R-r)/r*(R-r)/r*sin((R-r)/r*t))/(R+.5)*3.;\n\n\treturn 1./20.*4.*pi*pi*vec2(x,y);\n}\n#elif PARAMETRIC == 8\n//Epitrochoid\nconst int num_iterations=3;\nconst int num_start_params=18;\n\nconst int num_iterations2=5;\nconst int num_start_params2=60;\nconst int num_mins=5;\n\nvec2 parametric(float t){\n\tt*=2.*pi;\n\n\tfloat cam=mod(sfloor(iTime*0.4,.1)*pi*2.,2.*pi);\n    const float R = 2.8;\n    const float r = .4;\n    float d = sin(mod(iTime*0.21,2.*pi))*2.+2.6;\n\n    float x = (R+r)*cos(t-cam)-d*cos((R+r)/r*t);\n    float y = (R+r)*sin(t)-d*sin((R+r)/r*t);\n\n\treturn 1./30.*vec2(x,y);\n}\n\nvec2 parametric_diff(float t){\n\tt*=2.*pi;\n\n\tfloat cam=mod(sfloor(iTime*0.4,.1)*pi*2.,2.*pi);\n    const float R = 2.8;\n    const float r = .4;\n    float d = sin(mod(iTime*0.21,2.*pi))*2.+2.6;\n\n    float x = -(R+r)*sin(t-cam)+d*(R+r)/r*sin((R+r)/r*t);\n    float y = (R+r)*cos(t)-d*(R+r)/r*cos((R+r)/r*t);\n\n\treturn 1./30.*2.*pi*vec2(x,y);\n}\n\nvec2 parametric_snd_diff(float t){\n\tt*=2.*pi;\n\n\tfloat cam=mod(sfloor(iTime*0.4,.1)*pi*2.,2.*pi);\n    const float R = 2.8;\n    const float r = .4;\n    float d = sin(mod(iTime*0.21,2.*pi))*2.+2.6;\n\n    float x = -(R+r)*cos(t-cam)+d*(R+r)/r*(R+r)/r*cos((R+r)/r*t);\n    float y = -(R+r)*sin(t)+d*(R+r)/r*(R+r)/r*sin((R+r)/r*t);\n\n\treturn 1./30.*4.*pi*pi*vec2(x,y);\n}\n#elif PARAMETRIC == 9\n//Rose Curve\nconst int num_iterations=3;\nconst int num_start_params=16;\n\nconst int num_iterations2=3;\nconst int num_start_params2=70;\nconst int num_mins=6;\n\nvec2 parametric(float t){\n\tt*=2.*pi;\n\n\tfloat cam= mod(sfloor(iTime*0.1,.1)*pi,2.*pi);\n    float k = mod(floor(iTime*0.1),6.)+2.;\n\n    float x = cos(k*t-cam)*cos(t+cam)*5.5;\n    float y = cos(k*t)*sin(t)*5.5;\n\n\treturn 1./30.*vec2(x,y);\n}\n\nvec2 parametric_diff(float t){\n\tt*=2.*pi;\n\n\tfloat cam=mod(sfloor(iTime*0.1,.1)*pi,2.*pi);\n    float k=mod(floor(iTime*0.1),6.)+2.;\n\n\tfloat x=-5.5*k*cos(t+cam)*sin(k*t - cam) - 5.5*cos(k*t - cam)*sin(t+cam);\n\tfloat y=-5.5*k*sin(k*t)*sin(t) + 5.5*cos(k*t)*cos(t);\n\n\treturn 1./30.*2.*pi*vec2(x,y);\n}\n\nvec2 parametric_snd_diff(float t){\n\tt*=2.*pi;\n\n\tfloat cam=mod(sfloor(iTime*0.1,.1)*pi,2.*pi);\n    float k=mod(floor(iTime*0.1),6.)+2.;\n\n\tfloat x=-5.5*k*k*cos(k*t - cam)*cos(cam + t) + 11.*k*sin(k*t - cam)*sin(cam + t) - 5.5*cos(k*t - cam)*cos(cam + t);\n\tfloat y=-11.0*k*cos(t)*sin(k*t) + (-5.5*k*k - 5.5)*cos(k*t)*sin(t);\n\n\treturn 1./30.*4.*pi*pi*vec2(x,y);\n}\n#elif PARAMETRIC == 10\n//Lissajous\nconst int num_iterations=3;\nconst int num_start_params=25;\n\nconst int num_iterations2=3;\nconst int num_start_params2=50;\nconst int num_mins=5;\n\nvec2 parametric(float t){\n\tt*=2.*pi;\n\n\tfloat ft = mod(floor(iTime*.125),3.);\n    float a = 3.+ft;\n    float b = 2.+ft;\n\n    float x = sin(b*t);\n    float y = sin(a*t+pi/2.+mod(iTime*.5,2.*pi));\n\n\treturn 1./7.*vec2(x,y);\n}\n\nvec2 parametric_diff(float t){\n\tt*=2.*pi;\n\n\tfloat ft = mod(floor(iTime*.125),3.);\n    float a = 3.+ft;\n    float b = 2.+ft;\n\n\tfloat x=b*cos(b*t);\n    float y=a*cos(a*t+pi/2.+mod(iTime*.5,2.*pi));\n\n\treturn 1./7.*2.*pi*vec2(x,y);\n}\n\nvec2 parametric_snd_diff(float t){\n\tt*=2.*pi;\n\n\tfloat ft = mod(floor(iTime*.125),3.);\n    float a = 3.+ft;\n    float b = 2.+ft;\n\n\tfloat x=-b*b*sin(b*t);\n    float y=-a*a*sin(a*t+pi/2.+mod(iTime*.5,2.*pi));\n\n\treturn 1./7.*4.*pi*pi*vec2(x,y);\n}\n#elif PARAMETRIC == 11\n//Hypocycloid (just a special case of hypotrochoids)\nconst int num_iterations=4;\nconst int num_start_params=40;\n\nconst int num_iterations2=3;\nconst int num_start_params2=80;\nconst int num_mins=6;\n\nvec2 parametric(float t){\n\tt*=8.*pi;\n\n\tconst float a = 6.;\n    float ft = mod(floor(iTime*0.25),5.)+2.25;\n    float b = 6./ft;\n    float cam= mod(sfloor(iTime*0.5,.2)*pi,2.*pi);\n\n    float x = ((a-b)*cos(t-cam) + b*cos(t*(a/b-1.)));\n    float y = ((a-b)*sin(t) - b*sin(t*(a/b-1.)));\n\n\treturn 1./30.*vec2(x,y);\n}\n\nvec2 parametric_diff(float t){\n\tt*=8.*pi;\n\n\tconst float a = 6.;\n    float ft = mod(floor(iTime*0.25),5.)+2.25;\n    float b = 6./ft;\n    float cam= mod(sfloor(iTime*0.5,.2)*pi,2.*pi);\n\n    float x = ((b-a)*sin(t-cam) + (b-a)*sin(t*(a/b-1.)));\n    float y = ((a-b)*cos(t) - (a-b)*cos(t*(a/b-1.)));\n\n\treturn 1./30.*8.*pi*vec2(x,y);\n}\n\nvec2 parametric_snd_diff(float t){\n\tt*=8.*pi;\n\n\tconst float a = 6.;\n    float ft = mod(floor(iTime*0.25),5.)+2.25;\n    float b = 6./ft;\n    float cam= mod(sfloor(iTime*0.5,.2)*pi,2.*pi);\n\n    float x = ((b-a)*cos(t-cam) + (b-a)*(a/b-1.)*cos(t*(a/b-1.)));\n    float y = ((b-a)*sin(t) + (a-b)*(a/b-1.)*sin(t*(a/b-1.)));\n\n\treturn 1./30.*8.*8.*pi*pi*vec2(x,y);\n}\n#endif\n\nfloat length2( vec2 v ) { return dot(v,v); }\n\nfloat segment_dis_sq( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nfloat segment_param( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn h;\n}\n\nfloat parametric_segments_dis_sq(vec2 uv){\n    float d0 = 1e38;\n    vec2 a = parametric(0.);\n    for( int i=1; i<num_segments; i++ )\n    {\n        float t = float(i)/float(num_segments-1);\n\t\tvec2 b = parametric(t);\n        d0 = min(d0,segment_dis_sq(uv, a, b ));\n        a = b;\n    }\n    \n    return d0;\n}\n\nfloat parametric_segments_dis(vec2 uv){\n\treturn sqrt(parametric_segments_dis_sq(uv));\n}\n\nfloat parametric_normal_iteration(float t, vec2 uv){\n\tvec2 uv_to_p=parametric(t)-uv;\n\tvec2 tang=parametric_diff(t);\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-factor*dot(tang,uv_to_p)/l_tang;\n}\n\nfloat parametric_normal_iteration2(float t, vec2 uv){\n\tvec2 uv_to_p=parametric(t)-uv;\n\tvec2 tang=parametric_diff(t);\n\tvec2 snd_drv=parametric_snd_diff(t);\n\n\tfloat l_tang=dot(tang,tang);\n\n\tfloat fac=dot(tang,snd_drv)/(2.*l_tang);\n\tfloat d=-dot(tang,uv_to_p);\n\n\tfloat t2=d/(l_tang+fac*d);\n\n\treturn t+factor*t2;\n}\n\nfloat parametric_dis_approx_sq(vec2 uv){\n\tfloat d0 = 1e38;\n\n\tfloat t0=0.;\n\tfloat t;\n\n\tfor(int i=0;i<num_start_params;i++){\n\t\tt=t0;\n\t\tfor(int j=0;j<num_iterations;j++){\n\t\t\t#ifdef SECOND_ORDER\n\t\t\tt=parametric_normal_iteration2(t,uv);\n\t\t\t#else\n\t\t\tt=parametric_normal_iteration(t,uv);\n\t\t\t#endif\n\t\t}\n\t\tt=clamp(t,0.,1.);\n\t\tvec2 uv_to_p=parametric(t)-uv;\n\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\n\t\tt0+=1./float(num_start_params-1);\n\t}\n\n\treturn d0;\n}\n\nfloat parametric_dis_approx_sq2(vec2 uv){\n\tfloat d0 = 1e38;\n\tfloat d1 = 1e38;\n\n\tfloat t0=0.;\n\n\tfloat[6] nt;\n\tfloat[6] nd=float[6](1e38,1e38,1e38,1e38,1e38,1e38);\n\n\tfor(int i=0;i<num_start_params2;i++){\n\t\tvec2 uv_to_p=parametric(t0)-uv;\n\t\td1=dot(uv_to_p,uv_to_p);\n\t\t//d1=abs(dot(uv_to_p,parametric_diff(t0)));\n\n\t\tif(d1<nd[2]){\n\t\t\tif(d1<nd[0]){\n\t\t\t\tnd[5]=nd[4];\n\t\t\t\tnt[5]=nt[4];\n\n\t\t\t\tnd[4]=nd[3];\n\t\t\t\tnt[4]=nt[3];\n\n\t\t\t\tnd[3]=nd[2];\n\t\t\t\tnt[3]=nt[2];\n\n\t\t\t\tnd[3]=nd[2];\n\t\t\t\tnt[3]=nt[2];\n\n\t\t\t\tnd[2]=nd[1];\n\t\t\t\tnt[2]=nt[1];\n\n\t\t\t\tnd[1]=nd[0];\n\t\t\t\tnt[1]=nt[0];\n\n\t\t\t\tnd[0]=d1;\n\t\t\t\tnt[0]=t0;\n\t\t\t}\n\t\t\telse if(d1<nd[1]){\n\t\t\t\tnd[5]=nd[4];\n\t\t\t\tnt[5]=nt[4];\n\n\t\t\t\tnd[4]=nd[3];\n\t\t\t\tnt[4]=nt[3];\n\n\t\t\t\tnd[3]=nd[2];\n\t\t\t\tnt[3]=nt[2];\n\n\t\t\t\tnd[2]=nd[1];\n\t\t\t\tnt[2]=nt[1];\n\n\t\t\t\tnd[1]=d1;\n\t\t\t\tnt[1]=t0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnd[5]=nd[4];\n\t\t\t\tnt[5]=nt[4];\n\n\t\t\t\tnd[4]=nd[3];\n\t\t\t\tnt[4]=nt[3];\n\n\t\t\t\tnd[3]=nd[2];\n\t\t\t\tnt[3]=nt[2];\n\n\t\t\t\tnd[2]=d1;\n\t\t\t\tnt[2]=t0;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(d1<nd[3]){\n\t\t\t\tnd[5]=nd[4];\n\t\t\t\tnt[5]=nt[4];\n\n\t\t\t\tnd[4]=nd[3];\n\t\t\t\tnt[4]=nt[3];\n\n\t\t\t\tnd[3]=d1;\n\t\t\t\tnt[3]=t0;\n\t\t\t}\n\t\t\telse if(d1<nd[4]){\n\t\t\t\tnd[5]=nd[4];\n\t\t\t\tnt[5]=nt[4];\n\n\t\t\t\tnd[4]=d1;\n\t\t\t\tnd[4]=t0;\n\t\t\t}\n\t\t\telse if(d1<nd[5]){\n\t\t\t\tnd[5]=d1;\n\t\t\t\tnt[5]=t0;\n\t\t\t}\n\t\t}\n\n\t\tt0+=1./float(num_start_params2-1);\n\t}\n\n\td0=1e38;\n\n\tfor(int i=0;i<num_mins;i++){\n\t\tfor(int j=0;j<num_iterations2;j++){\n\t\t\t#ifdef SECOND_ORDER\n\t\t\tnt[i]=parametric_normal_iteration2(nt[i],uv);\n\t\t\t#else\n\t\t\tnt[i]=parametric_normal_iteration(nt[i],uv);\n\t\t\t#endif\n\t\t}\n\t\tnt[i]=clamp(nt[i],0.,1.);\n\n\t\tvec2 uv_to_p=parametric(nt[i])-uv;\n\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t}\n\n\treturn d0;\n}\n\nfloat parametric_dis_approx(vec2 uv){\n\treturn sqrt(parametric_dis_approx_sq(uv));\n}\n\nfloat parametric_dis_approx2(vec2 uv){\n\treturn sqrt(parametric_dis_approx_sq2(uv));\n}\n\nfloat parametric_dis_approx_hybrid(vec2 uv){\n\tfloat d0=parametric_dis_approx_sq(uv);\n\n\tif(d0>eps){\n\t\td0=min(d0,parametric_segments_dis_sq(uv));\n\t}\n\n\treturn sqrt(d0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border=2./iResolution.x;\n\n\tvec2 uv=gl_FragCoord.xy/iResolution.xy;\n\tuv-=.5;\n    uv.y*=iResolution.y/iResolution.x;\n\n\tvec2 mouse=iMouse.xy/iResolution.xy;\n\tmouse-=.5;\n    mouse.y*=iResolution.y/iResolution.x;\n\n\tborder*=zoom;\n\tuv*=zoom;\n\tmouse*=zoom;\n\n\tvec3 curve_col=vec3(1,1,1);\n\n\t#ifdef HYBRID\n\tfloat dis=parametric_dis_approx_hybrid(uv);\n\t#elifdef SEGMENTS\n\tfloat dis=parametric_segments_dis(uv);\n\t#else\n\t#ifdef USE_VARIANT\n\tfloat dis=parametric_dis_approx2(uv);\n\t#else\n\tfloat dis=parametric_dis_approx(uv);\n\t#endif\n\t#endif\n\n\t#ifdef SHOW_DISTANCE_FIELD\n\tfloat sgn=1.;\n\tdis/=zoom;\n\t//iq's sd color scheme\n\tvec3 color = vec3(1) - sgn*vec3(0.1,0.4,0.7);\n\tcolor *= 1.0 - exp(-8.0*dis);\n\tcolor *= 0.8 + 0.2*cos(480.0*dis*sgn);\n\tcolor = mix( color, curve_col, 1.0-smoothstep(0.0,0.005,dis) );\n\t#else\n\tvec3 color=bg_col;\n\tcolor=mix(line_col,color,smoothstep(0.,border,dis-line_size));\n\t#endif\n\n\tfloat t0=mod(iTime*.05,1.);\n\tvec2 p0=parametric(t0);\n\n\tdis=distance(uv,p0)-dot_size;\n\tcolor=mix(point_col,color,smoothstep(0.,border,dis));\n\n\tfragColor=vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tsXDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tsXRS", "name": "RayMarchingBand003", "author": "Hirai_worthless", "description": "003", "tags": ["practice"], "likes": 2, "viewed": 116, "date": "1563380816", "time_retrieved": "2024-06-20T19:39:53.342539", "image_code": "float map(vec3 p){\n    p = fract(p) * 2.0 - 1.0;\n    p.xz *= mat2(cos(iTime),-sin(iTime)\n             ,sin(iTime),cos(iTime));\n        p.yz *= mat2(cos(1.0),-sin(1.0)\n             ,sin(1.0),cos(1.0));\n    float cil_side = length(p.xz) - abs(sin(iTime))/1.0;\n    float cil_top_bottom = abs(p.y) - abs(cos(iTime)) * 2.0;\n    float cil = max(cil_side,cil_top_bottom);\n    float holes = 10000000.0;\n    float d1 = abs(sin(iTime));\n    float d2 = abs(cos(iTime));\n    for(float xi = -10.0; xi < 10.0; xi++){\n        for(float yi = -10.0; yi < 10.0; yi++){\n        \tfloat h1 = length(p.xy - (xi * 0.4*d1,yi * 0.4*d2)) -0.1 * d1;\n            holes = min(holes,h1);\n        }\n    }\n        p.yz *= mat2(cos(iTime),-sin(iTime)\n             ,sin(iTime),cos(iTime));\n    for(float xi = -10.0; xi < 10.0; xi++){\n        for(float yi = -10.0; yi < 10.0; yi++){\n        \tfloat h1 = length(p.xy - (xi * 0.4*d1,yi * 0.4*d2)) -0.1 * d1;\n            holes = min(holes,h1);\n        }\n    }\n        p.xy *= mat2(cos(iTime),-sin(iTime)\n             ,sin(iTime),cos(iTime));\n    for(float xi = -10.0; xi < 10.0; xi++){\n        for(float yi = -10.0; yi < 10.0; yi++){\n        \tfloat h1 = length(p.xy - (xi * 0.4*d1,yi * 0.4*d2)) -0.1 * d1;\n            holes = min(holes,h1);\n        }\n    }\n    float sph = length(p) - 10.5;\n\treturn max(holes,sph);\n}\n\nfloat trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    for(int i = 0; i < 32; ++i){\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float PI = 3.14159265;\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv,1.0));\n    \n    vec3 o = vec3(0,0,-2.0);\n    float t = trace(o,r);\n    float fog = 1.0 / (1.0 + t * t * 0.2);\n    vec3 fc = vec3(fog);\n\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tsXRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tsXWH", "name": "Light's Night Out[STROBE][MUSIC]", "author": "peet", "description": "Upgraded version of 'Shiny Disco Balls' with sphere surface mask, rotation, pass-through logic and tweaks.\nIf its running slowly for you, reduce g_numspheres, up VOLUME_STEP a little, remove rotation.\nNeeds more optimising, will update :)", "tags": ["raytracing", "music", "lighting", "sphere", "volumetric", "reflections", "plane", "mask", "strobe", "psychadelic", "rave"], "likes": 19, "viewed": 840, "date": "1562776836", "time_retrieved": "2024-06-20T19:39:56.076102", "image_code": "///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n// IF YOU GET A BLACK SCREEN YOU WILL NEED TO DISABLE MUSIC TO SEE ANYTHING ///////\n// THE AUDIO DOESNT SEEM TO LOAD PROPERLY ON SOME MACHINES, DONT KNOW WHY /////////\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n\n#define MUSIC \n\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n// IF YOU GET A BLACK SCREEN YOU WILL NEED TO DISABLE MUSIC TO SEE ANYTHING ///////\n// THE AUDIO DOESNT SEEM TO LOAD PROPERLY ON SOME MACHINES, DONT KNOW WHY /////////\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n\n#define NO_INTERSECTION 100000.0\n//#define AMBIENT 0.05\n#define EPSILON 0.0001\n#define TEXTURESCALE 0.125/4.0\n#define SPECULAR_POWER 25.0\n#define SPECULAR_AMOUNT 1.0\n#define MSAA 1.0\n#define ITERATIONS 3\n#define HURRY_UP 1.5\n#define LIGHT_ZBIAS 0.0\n\n#define VOLUME_STEP 0.1\t//// SET THIS TO 0.3 OR HIGHER FOR BETTER PERFORMANCE /////\n\n///////////////////////////////////////////////////////////////////////////////////\n\n#define DISCO_LIGHTS\n#define LIGHT_COLOUR_CHANGE\n//#define MODULATE_PLANE_REFLECTANCE\n#define VOLUMETRIC_LIGHTING\n#define ROTATION\n//#define CHECKER_PULSE\n#define ALTERNATIVE_MASK\n\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat AMBIENT=0.0;\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere {\n    vec3 origin;\n    float radius;\n    vec3 colour;\n    float reflectiveness;\n    float stripe;\n    mat3 mat;\n};\n\nstruct Plane {\n    vec3 origin;\n    vec3 normal;\n    vec3 binormal;\n    vec3 binormal2;\n    float reflectiveness;\n};\n    \nstruct Light {\n    vec3 pos;\n    vec3 colour;\n};\n    \nstruct Result {\n    vec3 pos;\n    vec3 normal;\n    float t0,t1;\n    vec3 colour;\n    float reflectiveness;\n};\n\n///////////////////////////////////////////////////////////////////////////////////\n\nconst int g_numlights=3;\nLight g_lights[g_numlights];\n\nconst int g_numplanes=1;\nPlane g_planes[g_numplanes];\n\nconst int g_maxspheres=8;\n\nconst int g_numspheres=4;\n\nSphere g_spheres[g_maxspheres];\nvec3 g_sphererotspeeds[g_maxspheres];\n\nbool music=false;\n\n///////////////////////////////////////////////////////////////////////////////////\n    \nfloat blerp(float x, float y0, float y1, float y2, float y3) {\n\tfloat a = y3 - y2 - y0 + y1;\n\tfloat b = y0 - y1 - a;\n\tfloat c = y2 - y0;\n\tfloat d = y1;\n\treturn a * x * x * x + b * x * x + c * x + d;\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat perlin(float x, float h) {\n\tfloat a = floor(x);\n\treturn blerp(mod(x, 1.0),\n\t\trand(vec2(a-1.0, h)), rand(vec2(a-0.0, h)),\n\t\trand(vec2(a+1.0, h)), rand(vec2(a+2.0, h)));\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nmat3 rotationmatrix(vec3 a)\n{\n    float cp=cos(a.x);\n    float sp=sin(a.x);\n    float cy=cos(a.y);\n    float sy=sin(a.y);\n    float cr=cos(a.z);\n    float sr=sin(a.z);\n    mat3 pitch = mat3(1, 0, 0, 0, cp, sp, 0, -sp, cp);\n    mat3 yaw = mat3(cy, 0, -sy, 0, 1, 0, sy, 0, cy);\n\tmat3 roll = mat3(cr, sr, 0, -sr, cr, 0, 0, 0, 1);\n    mat3 rotation = pitch*yaw*roll;    \n    return roll;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// returns intersection points in order of increasing t\n\nResult hit_sphere(Ray ray, Sphere sphere)\n{\n    Result result = Result(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), NO_INTERSECTION, NO_INTERSECTION, sphere.colour, sphere.reflectiveness);\n    vec3 oc = ray.origin - sphere.origin;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(oc, ray.direction);\n    float c = dot(oc,oc) - sphere.radius*sphere.radius;\n    float discriminant = b*b - 4.0*a*c;\n    if(discriminant < 0.0){\n        return result;\n    }\n    else{\n        float sqrtdsc = sqrt(discriminant);\n\t\tfloat t1 = (-b - sqrtdsc) / (2.0 * a);\n\t\tfloat t2 = (-b + sqrtdsc) / (2.0 * a);   \n        // t2 must be greater than t1\n        if (t2 <= 0.0) \n        {\t//neither can be > 0\n            return result;\t\n        }\n        else if (t1>0.0)\n        {\t// both must be > 0\n            result.t0=t1;\n            result.t1=t2;\n        }\n        else\n        {\t// only t2 is > 0\n            result.t0=t2;\n        }\n                    \n        result.pos = ray.origin + (ray.direction*result.t0);\n        result.normal = result.pos - sphere.origin;\n        result.normal = normalize(result.normal);\n        return result;      \n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\n#ifdef ALTERNATIVE_MASK\n    bool classifynormal(vec3 normal, float stripeyness, mat3 rot)\n    {\n    #ifdef ROTATION    \n        normal = rot*normal;\n    #endif //ROTATION    \n        float val = normal.y * (normal.x + normal.z);\n        val = val * stripeyness * 0.5;\n        val -= floor(val);\n\n        if (val>0.5)\n            return true;\n        else\n            return false;\n    }\n#else\n    bool classifynormal(vec3 normal, float stripeyness, mat3 rot)\n    {\n    #ifdef ROTATION    \n        normal = rot*normal;\n    #endif //ROTATION    \n\n        float maxcomponent = max(abs(normal.x), abs(normal.y));\n        maxcomponent = max(maxcomponent, abs(normal.z));\n\n        maxcomponent = maxcomponent * stripeyness;\n        maxcomponent -= floor(maxcomponent);\n\n        if (maxcomponent>0.5)\n            return true;\n        else\n            return false;\n    }\n#endif //ALTERNATIVE_MASK\n\n///////////////////////////////////////////////////////////////////////////////////\n\nResult hit_object(Ray ray, Sphere sphere)\n{\n    Result result = hit_sphere(ray, sphere);\n        \n    if (classifynormal(result.normal, sphere.stripe, sphere.mat))\n    {\n    \treturn result;\n    }\n    else\n    {\n    \tresult.t0 = result.t1;\n        result.pos = ray.origin + ray.direction*result.t0;\n        result.normal = -normalize(result.pos - sphere.origin);\n\t    if (classifynormal(result.normal, sphere.stripe, sphere.mat))\n        {\n        \treturn result;\n        }\n        else\n        {\n            result.t0 = NO_INTERSECTION;\n        \treturn result;\n        }\n    }\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// calcs the intersection with 2 opposite planes in a single test\n\nResult hit_plane(Ray ray, Plane plane) \n{\n    Result result = Result(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), NO_INTERSECTION, NO_INTERSECTION, vec3(1.0, 1.0, 1.0), plane.reflectiveness);\n        \n    if (dot(plane.normal, ray.direction) > 0.0) \n    {\t// no intersection with the regular plane, check the 'flipped' plane instead\n        plane.normal = -plane.normal;\n        plane.origin = -plane.origin;\n    }\n\n    float t = (dot(plane.normal, plane.origin) - dot(plane.normal, ray.origin)) / dot(plane.normal, ray.direction);\n    if (t<0.0)\n    {\n    \treturn result;    \n    }\n    \n    vec3 inter = ray.origin + ray.direction*t;    \n    result.t0 = t;\n    result.t1 = t;\n    result.pos = inter;\n    result.normal = plane.normal;\n    \n    // sample the texture in the returned colour\n    vec2 tex;\n    tex.x = dot((result.pos - plane.origin), plane.binormal)*TEXTURESCALE;\n    tex.y = dot((result.pos - plane.origin), plane.binormal2)*TEXTURESCALE;\n    result.colour = texture(iChannel0, tex).xyz * texture(iChannel0, tex).xyz;\t// make it mor 'gaudy' ;-)\n    \n#ifdef CHECKER_PULSE    \n    tex.x = tex.x-floor(tex.x);\n    tex.y = tex.y-floor(tex.y);\n    tex.x-=0.2;\n    tex.y-=0.2;\n    if ((tex.x*tex.y) >= 0.0)\n        result.reflectiveness*=0.5;\n#endif //CHECKER_PULSE    \n    \n    return result;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// ray-world query, returning intersection point, normal, surface colour\n\nResult raycast(Ray ray)\n{\n    Result bestresult = Result(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), NO_INTERSECTION, NO_INTERSECTION, vec3(1.0, 1.0, 1.0), 0.0);    \n    \n    for (int i=0; i<g_numspheres; i++)\n    {\n        Result res = hit_object(ray, g_spheres[i]);    \n        if (res.t0 < bestresult.t0)\n            bestresult=res;    \n    }\n    for (int i=0; i<g_numplanes; i++)\n    {\n    \tResult res = hit_plane(ray, g_planes[i]);    \n        if (res.t0 < bestresult.t0)\n            bestresult=res;    \n    }\n    return bestresult;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// returns the RGB lighting at a given point\n\nvec3 lighting(Result castresult)\n{\n    // light definition\n    vec3 colour = vec3(0.0, 0.0, 0.0);\n                \n    for (int i=0; i<g_numlights; i++)\n    {\n        // evaluate the point light\n        vec3 lightdir = castresult.pos - g_lights[i].pos;\n        lightdir = normalize(lightdir);\n        float brightness = dot(castresult.normal, -lightdir);\n\n        if (brightness>0.0)\n        {        \n            // cast a ray to the lightsource\n            Ray shadowray;\n            shadowray.origin = castresult.pos + castresult.normal*EPSILON;\n            shadowray.direction = g_lights[i].pos - castresult.pos;\t// no need to normalize this\n            Result shadowresult = raycast(shadowray);\n            if ((shadowresult.t0 == NO_INTERSECTION) || (shadowresult.t0 > 1.0f) || (shadowresult.t0 < 0.0f))\n            {\n                float specular = pow(brightness, SPECULAR_POWER) * SPECULAR_AMOUNT;\n                colour += (brightness*g_lights[i].colour*castresult.colour) + (specular*g_lights[i].colour);\n            }        \n        }\n    }\n    return colour;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// returns the colour at the intersection point, or AMBIENT\n\nvec3 raytrace(Ray inputray)\n{    \n    Ray ray=inputray;\n    vec3 outputcolour = vec3(AMBIENT, AMBIENT, AMBIENT);\n    float rayweight = 1.0;\n    \n    for (int i=0; i<ITERATIONS; i++)\n    {\n        vec3 colour = vec3(0.0, 0.0, 0.0);\n        Result result = raycast(ray);\n\n        if (result.t0 == NO_INTERSECTION)\n        {\n            // no intersection at this stage, return the accumulated colour so far\n            vec3 colour = vec3(AMBIENT, AMBIENT, AMBIENT);\n            outputcolour = (outputcolour*(1.0-rayweight)) + (colour*rayweight);\n            return outputcolour;\n        }\n        else\n        {                        \n            colour=lighting(result);\n            colour.xyz = max(colour, AMBIENT);            \n            outputcolour = (outputcolour*(1.0-rayweight)) + (colour*rayweight);\n\n            if (result.reflectiveness>0.0)\n            {\n                Ray reflectray;\n                reflectray.origin = result.pos + result.normal*EPSILON;\n                reflectray.direction = reflect(ray.direction, result.normal);\n                ray = reflectray;\n                rayweight = rayweight * result.reflectiveness;\n                if (rayweight < 0.1)\n                {\n                    return outputcolour;\n                }\n            }      \n            else\n            {\n            \treturn outputcolour;    \n            }\n        }\n    }\n    \n    outputcolour.xyz = max(outputcolour, AMBIENT);\n    return outputcolour;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// initialise all the primitives\n\nvoid setupscene()\n{\n    float pri=1.0f;\n    float sec=0.4;\n    float ter=0.2;\n\n#ifdef LIGHT_COLOUR_CHANGE    \n    pri=1.0;\n    sec=0.4 + sin(iTime*1.0)*0.4;\n    ter=0.2 + sin(iTime*2.0)*0.2;\n    \n    pri*=2.0f;\n    sec*=2.0f;\n    ter*=2.0f;\n#endif //LIGHT_COLOUR_CHANGE    \n    \n    g_lights[0].colour = vec3(sec, ter, pri);\n    g_lights[1].colour = vec3(ter, pri, sec);\n    g_lights[2].colour = vec3(pri, ter, sec);    \n\n#ifdef DISCO_LIGHTS       \n    if (music)\n    {\n       \tfloat fft  = texelFetch( iChannel1, ivec2(1, 0), 0 ).x; \n    \tfft=fft*fft*fft;\n    \tAMBIENT=fft*0.5;\n        g_lights[0].colour *= fft;\n        g_lights[1].colour *= fft;\n        g_lights[2].colour *= fft;        \n    }\n    else\n    {\n        g_lights[0].colour *= 0.5 + perlin(iTime*8.0, 1.0)*0.6;\n        g_lights[1].colour *= 0.5 + perlin(iTime*7.0, 1.27)*0.6;\n        g_lights[2].colour *= 0.5 + perlin(iTime*5.0, 1.72)*0.6;\n    }\n        \n#endif //DISCO_LIGHTS    \n            \n\tfor (int i=0; i<g_numlights; i++)\n    {\n\t\tfloat h = float(i)*4.0;\n\t\tfloat x = perlin(iTime*0.212, h+1.0)*4.0 - 2.0;\n\t\tfloat y = perlin(iTime*0.341, h+2.0)*4.0 - 2.0;\n\t\tfloat z = 4.0+perlin(iTime*0.193, h+3.0)*4.0;\n\t\tg_lights[i].pos = vec3(x, y, z+LIGHT_ZBIAS);\n\t}   \n    \n    // scene definition\n    g_planes[0] = Plane(vec3(0.0, -5, 0.0), vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), 1.0);    \n//    g_planes[1] = Plane(vec3(0.0, +5, 0.0), vec3(0.0, -1.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), 1.0);    \n\n#ifdef MODULATE_PLANE_REFLECTANCE    \n    // animate the plane reflectiveness - this has a surprising side-effect :)\n    g_planes[0].reflectiveness = 0.5 + 0.5*sin(iTime);\n#endif //MODULATE_PLANE_REFLECTANCE    \n   \n    g_spheres[0] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(1.0, 0.2, 0.2), 0.75, 4.0, mat3(0.0));\n    g_spheres[1] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(0.2, 1.0, 0.2), 0.75, -5.0, mat3(0.0));\n    g_spheres[2] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(0.2, 0.2, 1.0), 0.75, 6.0, mat3(0.0));\n    g_spheres[3] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(1.0, 1.0, 0.2), 0.75, -7.0, mat3(0.0));\n    g_spheres[4] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(0.2, 1.0, 1.0), 0.75, 5.0, mat3(0.0));\n    g_spheres[5] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(1.0, 0.2, 1.0), 0.75, -4.0, mat3(0.0));\n    g_spheres[6] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(1.0, 1.0, 1.0), 0.75, 7.0, mat3(0.0));\n    g_spheres[7] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(0.5, 0.5, 0.5), 0.75, -6.0, mat3(0.0));\n\n    g_sphererotspeeds[0]=vec3(1.0, -0.37, 0.77);\n    g_sphererotspeeds[1]=vec3(1.0, -0.37, -0.77);\n    g_sphererotspeeds[2]=vec3(1.0, 0.37, 0.77);\n    g_sphererotspeeds[3]=vec3(1.0, 0.37, -0.77);\n    g_sphererotspeeds[4]=vec3(-1.0, -0.37, 0.77);\n    g_sphererotspeeds[5]=vec3(-1.0, -0.37, -0.77);\n    g_sphererotspeeds[6]=vec3(-1.0, 0.37, 0.77);\n    g_sphererotspeeds[7]=vec3(-1.0, 0.37, -0.77);    \n    \n\tfor (int i=0; i<g_numspheres; i++)\n    {\n\t\tfloat h = float(i)*4.0;\n\t\tfloat size = \t\tperlin(HURRY_UP*iTime*0.251, h+4.0)*1.0 + 1.5;\n\t\tfloat x    = \t\tperlin(HURRY_UP*iTime*0.212, h+1.0)*20.0-10.0;\n\t\tfloat y    = \t\tperlin(HURRY_UP*iTime*0.341, h+2.0)*20.0-10.0;\n\t\tfloat z    = 35.0 + perlin(HURRY_UP*iTime*0.193, h+3.0)*20.0-10.0;\n\t\tg_spheres[i].origin = vec3(x*0.4, y*0.25, z*0.25-1.0);\n        g_spheres[i].radius=size;\n        g_spheres[i].mat = rotationmatrix(iTime*g_sphererotspeeds[i]);\n\t}    \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// 'volumetric' light rendering\n\nvec3 volumelights( Ray ray )\n{   \n    float castdistance=10.0;\n    float caststep=VOLUME_STEP;\n    float castscale=castdistance/caststep;\n\n    Result occlusionresult = raycast(ray); \n    castdistance = min(occlusionresult.t0, castdistance);\n                \n    vec3 colour = vec3(0.0, 0.0, 0.0);            \n    for (float t=0.0; t<castdistance; t+=caststep)\n    {\n        vec3 pos = ray.origin + ray.direction*t;\n        \n        for (int i=0; i<g_numlights; i++)\n        {\n            vec3 deltapos = g_lights[i].pos-pos;\n            float d2=length(deltapos);\n\n            Ray shadowray;\n            shadowray.origin = pos;\n            shadowray.direction = deltapos;\n            Result shadowresult = raycast(shadowray);\n            if (d2<8.0)\n            {\n                if (shadowresult.t0<0.0 || shadowresult.t0>1.0)            \n                    colour.xyz += g_lights[i].colour/(d2*castscale);\n            }                                \n        }\n    }\n    \n    return colour;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// main loop, iterate over the pixels, doing MSAA\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // is there a better way of determining if the preview screen is active ?\n#ifdef MUSIC\n    if (iResolution.x<640.0)\n        music=false;\n    else \n        music=true;\n#endif //MUSIC\n    \n\tsetupscene();\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    float factor = 1.0/(MSAA*MSAA);\n    \n    for (float x=0.0; x<MSAA; x++)\n    {\n        for (float y=0.0; y<MSAA; y++)\n        {\n            vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n            uv.y *= iResolution.y / iResolution.x;\n\n            uv.x += (1.0/(iResolution.x*MSAA))*x;\n            uv.y += (1.0/(iResolution.y*MSAA))*y;\n            \n            Ray ray;\n            ray.origin = vec3(0.0, 0.0, 0.0);\n            ray.direction = uv.xyx;\n            ray.direction.z = 1.0;\n            ray.direction = normalize(ray.direction);\n\n            fragColor.xyz += raytrace(ray)*factor;\n        }        \n    }\n    \n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    Ray ray;\n    ray.origin = vec3(0.0, 0.0, 0.0);\n    ray.direction = uv.xyx;\n    ray.direction.z = 1.0;\n    ray.direction = normalize(ray.direction);\n    \n#ifdef VOLUMETRIC_LIGHTING    \n    fragColor.xyz += volumelights(ray);\n#endif //VOLUMETRIC_LIGHTING\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tsXWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tsXzB", "name": "Simple 2D Lighting", "author": "mfbaranow", "description": "casting random rays and hitting objects to simulate 2d lighting", "tags": ["sdf"], "likes": 12, "viewed": 1291, "date": "1563411558", "time_retrieved": "2024-06-20T19:39:56.082584", "image_code": "float sphereSDF(vec2 p, float size) {\n\treturn length(p) - size;\n}\n\nfloat boxSDF(vec2 p, vec2 size) {\n\tvec2 r = abs(p) - size;\n    return min(max(r.x, r.y),0.) + length(max(r,vec2(0,0)));\n}\n\nvoid addObj(inout float dist, inout vec3 color, float d, vec3 c) {\n    if (dist > d) {\n        dist = d;\n        color = c;\n    }\n}\n\nvoid scene(in vec2 pos, out vec3 color, out float dist) {\n    dist = 1e9; color = vec3(0,0,0);\n    addObj(dist, color, boxSDF(pos - vec2(-4,1), vec2(1,1)), \tvec3(-.6,.8,1.0));\n    addObj(dist, color, sphereSDF(pos - vec2(4,1), 0.5), \t\tvec3(1, 0.9, 2.8));\n    addObj(dist, color, boxSDF(pos - vec2(0,3.0*sin(iTime)), \tvec2(1.0, 3.5)), vec3(.4,.1,.1));\n}\n\nvoid trace(vec2 p, vec2 dir, out vec3 c) {\n    for (int j = 0; j < 20; j++) {\n        float d;\n        scene(p, c, d);\n        if (d < 1e-3) {\n            //c = vec3(0,.1,0);\n            return;\n        }\n        if (d > 1e1) break;\n        p -= dir * d;\n    }\n    c = vec3(0,0,0);\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n        vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\n#define SAMPLES 128\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv = (gl_FragCoord.xy-(iResolution.xy/2.0))/iResolution.y*10.0;\n    \n    vec3 col = vec3(0,0,0);\n    for (int i = 0; i < SAMPLES; i++) {\n        float t = (float(i) + random(uv+float(i))) / float(SAMPLES) * 2. * 3.1415;\n        vec3 c;\n        trace(uv, vec2(cos(t), sin(t)), c);\n        col += c;\n    }\n    col /= float(SAMPLES);\n\n    // Output to screen\n    fragColor = vec4(col*2.0,3.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tsXzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tsXzM", "name": "RayMarch play", "author": "PsyPhi", "description": "Raymarch tests", "tags": ["raymarch"], "likes": 1, "viewed": 283, "date": "1562454799", "time_retrieved": "2024-06-20T19:39:56.815684", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n\n//Shapes\n\n    float torus( vec3 p, vec2 t )\n\t{\n  \t\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n  \t\treturn length(q)-t.y;\n\t}\n\n\n//Shape unions\n\nfloat opUnion( float d1, float d2 ) //Merges two objects\n{\n    return min(d1,d2);\t\t\t\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )  //smooth merges two objects\n{\n\tfloat h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) - k*h*(1.0-h);\n    \n    \n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n// Distance calculations\n\nfloat GetDist(vec3 p)// function for calculating distance. This is where the atual objects are coded\n{\n    \n    vec3 objP1 = vec3(0, sin(iTime), 6);\n    \n    \n    vec4 s = vec4(objP1, 1); //this genirates a sphere (x,y,z,radius)\n    \n\tfloat t1 = torus(objP1, vec2(0.5,1.));\n    \n    \n    float sphereDist = length(p-s.xyz)-s.w; // length from origin is ray position - the pos of the shpere - the radious of the sphere\n    float planeDist = p.y; // this genirates the floor plane. it is calculated by seeing how high the ray is from the ground.\n\n    \n    \n    float shapeMix = opSmoothUnion(sphereDist, planeDist, 1.0);\n    \n    float shapeMix2 = opSmoothUnion(shapeMix, t1, 1.0);\n    \n\tfloat d = min(t1, planeDist); // which object is the ray closer to? ** you need to add any other objects in the scene to this line **\n       \n    return shapeMix2;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n \tfloat dO=0.0; // dO is the distance to the origin\n    \n    for(int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd*dO; //current ray postion. Move in the direction of the ray (rd), by the distance the object is from the origin (dO or camera)\n        float ds = GetDist(p); //calculates distance the currenmt ray position is from the object\n        dO += ds;\t\t\t//moves the current ray position by the distance it is from the object\n        if(dO>MAX_DIST || ds<SURF_DIST) break; // has the ray position moved past the max distance, or gotten close enough to the object to stop?\n        \n    }\n    \n    return dO;\n        \n}\n\nvec3 GetNormal(vec3 p)\n{\n \tfloat d = GetDist(p);\n    vec2 e = vec2( 0.1,0);\n    \n    vec3 n = d - vec3        //this moves 0.1 in eash direction from the point and takes a distance sample used to calculate the slope of the surface\n        (\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p)\n{\n \tvec3 lightPos = vec3(0.,5,3); //postion of the light source\n    lightPos.xy += vec2(sin(iTime), cos(iTime))*2.;\n \tvec3 l = normalize(lightPos-p); //at direction is the surface from the light source\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l),0.,1.); //diffrence in angle between the normal and light vectors. clamps to 0 and 1 to prevent neg numbers\n    \n    //Shadows\n    float d = RayMarch(p+n*SURF_DIST*2., l);    //raymarch from the point towards the light. the n*SURF_DIST moves it just far enough away from the surface so that it does not stop the march due to already being at a surface.\n    if(d<length(lightPos-p))\t//Does the ray hit an object before hiting the light?\n    \t{\n            dif *= 0.1;\t\t\t//If so make the point 10 times darker.\n        }\n    \n    return dif;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    //Camera\n    vec3 ro = vec3(0,1,0); //Ray origin \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1)); //Ray direction. Normalize function returns the direction with a lenth of 1\n\n    float d = RayMarch(ro,rd);\n    \n    vec3 p = ro + rd * d; //location that the raymarch function determined is the surface\n    \n    float dif = GetLight(p);// dif mean defused light\n    \n//    dif /=6.0;  //brings the distance value into the visable range?? used for testing REMOVE\n\tcol = vec3(dif);\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tsXzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tsXzX", "name": "water12", "author": "colton81", "description": "water", "tags": ["water"], "likes": 6, "viewed": 576, "date": "1563767621", "time_retrieved": "2024-06-20T19:39:56.821797", "image_code": "//afl_ext 2017 \n\n// its from here https://github.com/achlubek/venginenative/blob/master/shaders/include/WaterHeight.glsl \nfloat wave(vec2 uv, vec2 emitter, float speed, float phase){\n\tfloat dst = distance(uv, emitter);\n\treturn pow((0.5 + 0.5 * sin(dst * phase - iTime * speed)), 5.0);\n}\n\n#define GOLDEN_ANGLE_RADIAN 2.39996\nfloat getwaves(vec2 uv){\n\tfloat w = 0.0;\n\tfloat sw = 0.0;\n\tfloat iter = 0.0;\n\tfloat ww = 1.0;\n    uv += iTime * 0.5;\n\t// it seems its absolutely fastest way for water height function that looks real\n\tfor(int i=0;i<6;i++){\n\t\tw += ww * wave(uv * 0.06 , vec2(sin(iter), cos(iter)) * 10.0, 2.0 + iter * 0.08, 2.0 + iter * 3.0);\n\t\tsw += ww;\n\t\tww = mix(ww, 0.0115, 0.4);\n\t\titer += GOLDEN_ANGLE_RADIAN;\n\t}\n\t\n\treturn w / sw;\n}\nfloat getwavesHI(vec2 uv){\n\tfloat w = 0.0;\n\tfloat sw = 0.0;\n\tfloat iter = 0.0;\n\tfloat ww = 1.0;\n    uv += iTime * 0.5;\n\t// it seems its absolutely fastest way for water height function that looks real\n\tfor(int i=0;i<24;i++){\n\t\tw += ww * wave(uv * 0.06 , vec2(sin(iter), cos(iter)) * 10.0, 2.0 + iter * 0.08, 2.0 + iter * 3.0);\n\t\tsw += ww;\n\t\tww = mix(ww, 0.0115, 0.4);\n\t\titer += GOLDEN_ANGLE_RADIAN;\n\t}\n\t\n\treturn w / sw;\n}\n\nfloat H = 0.0;\nvec3 normal(vec2 pos, float e, float depth){\n    vec2 ex = vec2(e, 0);\n    H = getwavesHI(pos.xy) * depth;\n    vec3 a = vec3(pos.x, H, pos.y);\n    return normalize(cross(normalize(a-vec3(pos.x - e, getwavesHI(pos.xy - ex.xy) * depth, pos.y)), \n                           normalize(a-vec3(pos.x, getwavesHI(pos.xy + ex.yx) * depth, pos.y + e))));\n}\nmat3 rotmat(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\t\n\treturn mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n#define mouse (iMouse.xy / iResolution.xy)\nvec3 getRay(vec2 uv){\n    uv = (uv * 2.0 - 1.0)* vec2(iResolution.x / iResolution.y, 1.0);\n\tvec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);\t\n    \n\tvec3 ray = rotmat(vec3(0.0, -1.0, 0.0), mouse.x * 2.0 - 1.0) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (mouse.y * 2.0 - 1.0)) * proj;\n    return ray;\n}\n\nfloat rand2sTimex(vec2 co){\n    return fract(sin(dot(co.xy * iTime,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat raymarchwater(vec3 camera, vec3 start, vec3 end, float depth){\n    vec3 pos = start;\n    float h = 0.0;\n    float hupper = depth;\n    float hlower = 0.0;\n    vec2 zer = vec2(0.0);\n    vec3 dir = normalize(end - start);\n    for(int i=0;i<318;i++){\n        h = getwaves(pos.xz) * depth - depth;\n        if(h + 0.01 > pos.y) {\n            return distance(pos, camera);\n        }\n        pos += dir * (pos.y - h);\n    }\n    return -1.0;\n}\n\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal)\n{ \n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \n}\nvec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir){\n\tsundir.y = max(sundir.y, -0.07);\n\tfloat special_trick = 1.0 / (raydir.y * 1.0 + 0.1);\n\tfloat special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);\n\tfloat raysundt = pow(abs(dot(sundir, raydir)), 2.0);\n\tfloat sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);\n\tfloat mymie = sundt * special_trick * 0.2;\n\tvec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);\n\tvec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 * suncolor;\n\tvec3 bluesky2 = max(vec3(0.0), bluesky - vec3(5.5, 13.0, 22.4) * 0.004 * (special_trick + -6.0 * sundir.y * sundir.y));\n\tbluesky2 *= special_trick * (0.24 + raysundt * 0.24);\n\treturn bluesky2 + mymie * suncolor;\n} \nvec3 getatm(vec3 ray){\n \treturn extra_cheap_atmosphere(ray, normalize(vec3(1.0))) * 0.5;\n    \n}\n\nfloat sun(vec3 ray){\n \tvec3 sd = normalize(vec3(1.0));   \n    return pow(max(0.0, dot(ray, sd)), 528.0) * 110.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n \t\n\tfloat waterdepth = 2.1;\n\tvec3 wfloor = vec3(0.0, -waterdepth, 0.0);\n\tvec3 wceil = vec3(0.0, 0.0, 0.0);\n\tvec3 orig = vec3(0.0, 2.0, 0.0);\n\tvec3 ray = getRay(uv);\n\tfloat hihit = intersectPlane(orig, ray, wceil, vec3(0.0, 1.0, 0.0));\n    if(ray.y >= -0.01){\n        vec3 C = getatm(ray) * 2.0 + sun(ray);\n        //tonemapping\n        C = normalize(C) * sqrt(length(C));\n     \tfragColor = vec4( C,1.0);   \n        return;\n    }\n\tfloat lohit = intersectPlane(orig, ray, wfloor, vec3(0.0, 1.0, 0.0));\n    vec3 hipos = orig + ray * hihit;\n    vec3 lopos = orig + ray * lohit;\n\tfloat dist = raymarchwater(orig, hipos, lopos, waterdepth);\n    vec3 pos = orig + ray * dist;\n\n\tvec3 N = normal(pos.xz, 0.001, waterdepth);\n    vec2 velocity = N.xz * (1.0 - N.y);\n    N = mix(vec3(0.0, 1.0, 0.0), N, 1.0 / (dist * dist * 0.01 + 1.0));\n    vec3 R = reflect(ray, N);\n    float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\n\t\n    vec3 C = fresnel * getatm(R) * 2.0 + fresnel * sun(R);\n    //tonemapping\n    C = normalize(C) * sqrt(length(C));\n    \n\tfragColor = vec4(C,1.0);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tsXzX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tXSD2", "name": "Falling Down Forever", "author": "Hirai_worthless", "description": "falling falling", "tags": ["raymarching"], "likes": 2, "viewed": 83, "date": "1564239681", "time_retrieved": "2024-06-20T19:39:56.821797", "image_code": "float PI = 3.14159265;\n\nfloat time (float multiply){\n\treturn iTime * multiply;\n}\nmat2 genRotMat(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\nfloat wall(float z,vec3 p,float holeHeight){\n\tfloat w = \n        max(\n            max(z - p.z, - max(abs(p.x) - 0.01,abs(p.y) - holeHeight))\n               ,-(z + 0.05 - p.z)\n        );\n    for(float i = 0.0; i < 5.0; i += 1.0){\n    \tw = max(w,-(length(abs(p.xy) - vec2(0.1 * i,i * 0.1)) - 0.05));\n    }\n    return w;\n}\n\nfloat map(vec3 p){\n\tfloat beginZ = floor(time(1.0) * 1.0) - 0.5;\n    p.xy *= genRotMat(floor(time(1.0))* PI /12.0 );\n    float walls = 10000.0;\n    for(float zi = 0.5; zi < 15.0; zi += 0.5){\n        p.xy *= genRotMat(0.5 * PI /12.0 );\n    \twalls = min(walls,\n                    wall(beginZ + zi,p,\n                         pow(0.2/((beginZ + zi - time(1.0)) + 0.3),2.0)\n                        )\n                   );\n    }\n    return walls;\n}\n\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 96; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return vec4(getNormal(p),t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float PI = 3.14159265;\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv,1.2));\n    r.xy *= genRotMat(iTime * PI/12.0);\n    vec3 o = vec3(0,0,time(1.0));\n    vec4 data = trace(o,r);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.2);\n    vec3 fc = mix(vec3(0.5 - data.x,0.5 -data.y,0.5-data.z),vec3(1.0),1.0 - fog);\n\t//fc = vec3(fog);\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tXSD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tXSDX", "name": "Mandelbulb Mint World", "author": "96logda", "description": "An creative version of my Mandelbulb World shader.", "tags": ["3d", "raymarching", "mandlebulb", "ambientocclusion", "world", "softshadow"], "likes": 2, "viewed": 136, "date": "1564423726", "time_retrieved": "2024-06-20T19:39:56.821797", "image_code": "//Copyright (c) 2019-07-22 - 2019-07-31 by Angelo Logahd\n//Portfolio: https://angelologahd.wixsite.com/portfolio\n\n#define PI\t\t\t\t\t3.14\n\n#define saturate(x) \t\tclamp(x, 0.0, 1.0)\n#define dot2(x) \t\t\tdot(x, x)\n\n#define MENGER_ITERATIONS\t2\n#define SOFT_SHADOW_STEPS \t16\n\n#define INTERSECT_STEPS\t\t300\n#define INTERSECT_MIN_DIST\t0.0001\n#define INTERSECT_MAX_DIST\t100.0\n\n\nvec2 rotate2D(vec2 p, float angle)\n{\n    float sRot = sin(angle);\n    float cRot = cos(angle);\n    return p * cRot + p.yx * sRot * vec2(-1.0, 1.0);\n}\n\nfloat sdPlane(vec3 p, float height)\n{\n   \treturn p.y - height;\n}\n\n//https://www.shadertoy.com/view/ltfSWn\nfloat mandelbulb(vec3 p)\n{\n    vec3 w = p;\n    float m = dot2(w);\n    float dz = 1.0;\n    for(int i = 0; i < 3; ++i)\n    {\n\t\tdz = 8.0 * pow(sqrt(m), 7.0) * dz + 1.0;\n        float r = length(w);\n        float b = 8.0 * acos(w.y / r);\n        float a = 8.0 * atan(w.x, w.z);\n        w = p + pow(r, 8.0) * vec3(sin(b) * sin(a), cos(b), sin(b) * cos(a));\n\n        m = dot(w,w);\n\t\tif (m > 255.0)\n\t\t{\n            break;\n\t\t}\n    }\t\n    return 0.15 * log(m) * sqrt(m) / dz;\n}\n\nvec4 opU(vec4 d1, vec4 d2)\n{\n     return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec4 map(in vec3 p)\n{\t\n    float ground = sdPlane(p, 1.8);\n    \n    p.xz = mod(p.xz + 1.0, 2.0) -1.0;\n    p.y  = mod(p.y + 1.0, 2.0) - 1.0;\n\t\n    float d = mandelbulb(p - vec3(0.0, 0.5, 0.0));\n    vec4 res = vec4(d, 1.0, 0.0, 2.0);\n\t\n    //.....................................................................\n    // Based on https://www.iquilezles.org/www/articles/menger/menger.htm\n    //.....................................................................\n    float s = 1.0;\n    for(int i = 0; i < MENGER_ITERATIONS; ++i)\n    { \n        vec3 a = mod(p * s, 2.0) - 1.0;\n        s *= 5.0;\n        vec3 r = abs(1.0 - 3.0 * abs(a));\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 1.3) / s;\n\n        if(c > d)\n        {\n            d = c;\n            res = vec4(d, min(res.y, 0.2 * da * db * dc), 0.0, 3.0);\n        }\n    }\n    //.....................................................................\n    \n    return opU(res, vec4(ground, 1.0, 0.0, 1.0));\n}\n\nvec4 intersect(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n    vec4 h = vec4(1.0);\n    for (int i = 0; i < INTERSECT_STEPS; i++ )\n    {\n\t\tif(h.x < INTERSECT_MIN_DIST || t > INTERSECT_MAX_DIST) \n\t\t{\n\t    \tbreak;\n\t\t}\n\t\n        h = map(ro + rd * t);\n        res = vec4(t, h.yzw);\n        t += h.x;\n    }\n\n    if (t > INTERSECT_MAX_DIST) \n    {\n\t\tres = vec4(-1.0);\n    }\n    \n    return res;\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < SOFT_SHADOW_STEPS; ++i)\n    {\n\t\tvec3 pos = ro + rd * t;\n        float h = map(pos).x;\n        res = min(res, float(SOFT_SHADOW_STEPS) * h / t);\n        if(res < 0.001)\n\t\t{\n\t    \tbreak;\n\t\t}\n        t += clamp(h, 0.01, 0.2);\n    }\n    return saturate(res);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    vec3 n;\n    n.x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    n.y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    n.z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n    return normalize(n);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float k)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < SOFT_SHADOW_STEPS; ++i)\n    {\n\t\tvec3 pos = ro + rd * t;\n        float h = map(pos).y;\n        res = min(res, k * h / t);\n        if(res < 0.001)\n\t\t{\n\t    \tbreak;\n    \t}\n        t += clamp(h, 0.01, 0.2);\n    }\n    return saturate(res);\n}\n\nvec3 GetMaterialColor(in vec3 p, float materialID)\n{\n    if (materialID < 1.5)\n    {\n         float f = mod(floor(50.0 * p.y) + floor(50.0 * p.z), 2.0);\n         return vec3(0.5, 0.1, 1.0) * f + 0.5;\n    }\n    else if (materialID < 2.5)\n    {\n         return vec3(0.0, clamp(0.6 * abs(p.z), 0.6, 1.0), 0.2);\n    }\n    else if (materialID < 3.5)\n    {\n         float f = mod(floor(50.0 * p.y) + floor(50.0 * p.x), 2.0);\n         return vec3(0.0, 0.0, 1.0) * f + 0.5;\n    }\n    return vec3(0.0);\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 color = vec3(0.0);\n    vec4 res = intersect(ro,rd);\n    if(res.x > 0.0)\n    {\n        const vec3 light = vec3(0.0, 0.0, -0.2);\n        \n        vec3 pos = ro + res.x * rd;        \n        vec3 normal = calcNormal(pos);\n        \n        float occ = res.y;\n        float shadow = softshadow(pos + 0.01 * normal, light);\n        \n        vec3 baseColor = GetMaterialColor(pos, res.w);\n        vec3 ambient = vec3(0.2) * baseColor;      \n\n        vec3 diffuse = baseColor * shadow * occ;\n        color = diffuse + (ambient * occ);\n    }\n\n    return pow(color, vec3(0.4545));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 p = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\t\n    vec2 mouseXY = iMouse.xy / iResolution.xy;\n    \n    // camera\n    vec3 ro = vec3(12.25, 2.9, -2.0);\n    vec3 ww = normalize(vec3(0.0, mouseXY.y * 5.0 * PI, 0.0) - ro);\n    ww.xz = rotate2D(ww.xz, -mouseXY.x * 2.0 * PI);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n\n    ro.x -= iTime * 0.1; //Camera movement\n\t\n \tvec3 color = render(ro + vec3(0.0, -1.0, 0.0), rd);\n    color += vec3(0.0, 0.2, 0.1);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tXSDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tXSRS", "name": "Attracting funnel", "author": "TambakoJaguar", "description": "After a long time not being here, I wanted to program something I've seen on an animated GIF here. I could learn and experiment a few things more. What do you think, even nothing is perfect for now..\nUse the mouse to move around.\n", "tags": ["balls", "pattern", "polar", "hole", "hyperbola", "funnel", "attracting", "absorbing"], "likes": 9, "viewed": 241, "date": "1563476846", "time_retrieved": "2024-06-20T19:39:59.312767", "image_code": "/*\n\"Attracting funnel\" by Emmanuel Keller aka Tambako - July 2019\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\n// The defines to switch on and off some features\n#define specular\n#define pattern\n//#define bump\n#define balls\n//#define ball_reflection\n#define shadow\n//#define motion_blur\n//#define test_mode\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n\nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  float objnr;\n};\n    \nLamp lamps[3];\n\n#define HOLE_OBJ      1\n#define BALL_OBJ      2\n\n// Campera options\nvec3 campos = vec3(0.5, -0.4, 10.);\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir;\nfloat fov = 5.8;\nfloat angle;\nfloat angle2;\nfloat time2;\n\nconst float normdelta = 0.0001;\nconst float maxdist = 60.;\n\nconst vec3 ball_color = vec3(1., 0.1, 0.1);\nconst float ballR = 0.3;\n\nconst vec3 ambientColor = vec3(0.3);\nconst float ambientint = 0.12;\nconst vec3 speccolor = vec3(0.95, 0.97, 1.);\n\nconst float specint_hole = 0.047;\nconst float specshin_hole = 23.;\nconst float specint_ball = 0.18;\nconst float specshin_ball = 30.;\n\nconst float shi = 0.84;\nconst float shf = 0.4;\n\nconst float bottom = 7.5;\nconst float txtSpeed = 1.7;\nconst float cdif = 0.012;\nconst float holeWidth = 0.5;\nconst float pati = 0.33;\nconst float bumpHeight = 0.015;\nconst float mbLength = 0.01;\n\nvec3 posr;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\n#ifdef motion_blur\nconst int aasamples = 4;\n#else\nconst int aasamples = 1;\n#endif\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat polarNoise0(vec3 x)\n{   \n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat polarNoise(vec3 pos1)\n{\n    vec3 q = 8.0*pos1;\n    float f = 0.0;\n    f  = 0.5000*polarNoise0(q); q = m*q*2.;\n    f += 0.2500*polarNoise0(q); q = m*q*2.;\n    f += 0.1250*polarNoise0(q); q = m*q*2.;\n    f += 0.0625*polarNoise0(q); q = m*q*2.;\n    \n    return f;\n}\n\nfloat polarNoise2(vec3 pos)\n{\n    float a = 2.*atan(pos.y, pos.x);\n    vec3 pos1 = vec3(pos.z, length(pos.yx) + time2*txtSpeed, a);\n    vec3 pos2 = vec3(pos.z, length(pos.yx) + time2*txtSpeed, a+12.57);    \n    \n    float f1 = polarNoise(pos1);\n    float f2 = polarNoise(pos2);\n    float f = mix(f1, f2, smoothstep(-5., -6.285, a));\n    \n    f = smoothstep(0.01, 0.2, f)-smoothstep(0.2, 0.52, f)+smoothstep(0.45, 0.63, f);\n    f = 0.8-pati+f*pati;\n    \n    return f;\n}\n\nfloat polarNoiseN(vec3 pos1)\n{\n    vec3 q = 8.0*pos1;\n    float f = 0.0;\n    f  = 0.5000*polarNoise0(q); q = m*q*2.;\n    f += 0.2500*polarNoise0(q); q = m*q*2.;\n    \n    return f;\n}\n\nfloat polarNoise2N(vec3 pos)\n{\n    float a = 2.*atan(pos.y, pos.x);\n    vec3 pos1 = vec3(pos.z, length(pos.yx) + iTime*txtSpeed, a);\n    vec3 pos2 = vec3(pos.z, length(pos.yx) + iTime*txtSpeed, a+12.57);    \n    \n    float f1 = polarNoiseN(pos1);\n    float f2 = polarNoiseN(pos2);\n    float f = mix(f1, f2, smoothstep(-5., -6.285, a));\n    \n    //f = smoothstep(0.01, 0.2, f)-smoothstep(0.2, 0.52, f)+smoothstep(0.45, 0.63, f);\n    \n    return f;\n}\n\nfloat map_ball(vec3 pos, vec3 ballPos, float ballR)\n{   \n    float d = length(pos-ballPos) - ballR;\n    \n    return d;\n}\n\nfloat holeFunct(vec2 pos, float holeWidth)\n{\n    float f1 = min(0.6/(max(length(pos)-holeWidth, 0.)), bottom);\n    float f2 = 4.*min(0.6/(max(length(pos)+holeWidth*0.5, 0.)), bottom);\n    \n    //return min(f1, f2);\n    return f1;\n}\n\nfloat map_hole(vec3 pos, bool hasBump)\n{  \n    #ifdef bump\n    if (hasBump)\n    {\n       vec3 pos2 = vec3(pos.yx, 0.);\n       pos.z+= bumpHeight*polarNoise2N(pos2);\n    }\n    #endif     \n    \n    float d = pos.z + holeFunct(pos.yx, holeWidth);\n    #ifdef test_mode\n    d = max(d, -pos.y);\n    #endif\n    \n    return d;\n}\n\nvec3 getBallPos(float offset)\n{  \n    float ii = mod(time2*txtSpeed + offset, 19.8);\n    float ii2 = offset + floor((time2 - offset)/(19.8*txtSpeed));\n    vec3 hv = vec3(15.5*ii2, 22.4*ii2, 71.9*ii2);\n    float ballX = -15. + ii -4.8*smoothstep(13., 20.8, ii);\n    float ballZ = -holeFunct(vec2(ballX, 0.), holeWidth);\n    \n    float hf2 = -holeFunct(vec2(ballX+0.01, 0.), holeWidth);\n    vec2 df = ballR*normalize(vec2(hf2-ballZ, 0.01));\n    ballX-= df.x;\n    ballZ+= df.y;\n    \n    #ifdef test_mode\n    vec3 ballPos = vec3(ballX, 0., ballZ);\n    #else\n    float ballAngle = -pow(abs(0.9/(ballX+0.28)), 2.2) + hash(hv)*2.*pi;\n    vec2 ballPos0 = rotateVec(vec2(ballX, 0), ballAngle);   \n    vec3 ballPos = vec3(ballPos0.x, ballPos0.y, ballZ);\n    #endif\n    \n    return ballPos;\n}\n\nfloat map_balls(vec3 pos)\n{\n    float ball1 = map_ball(pos, getBallPos(0.), ballR);\n    float ball2 = map_ball(pos, getBallPos(3.3), ballR);\n    float ball3 = map_ball(pos, getBallPos(6.6), ballR);\n    float ball4 = map_ball(pos, getBallPos(9.9), ballR);\n    float ball5 = map_ball(pos, getBallPos(13.2), ballR);\n    \n    float b = min(min(min(min(ball1, ball2), ball3), ball4), ball5);\n    \n    #ifdef test_mode\n    b = max(b, -pos.y);\n    #endif\n    \n    return b;\n}\n\nvec2 map(vec3 pos, bool hasBump)\n{\n    vec2 res;\n    \n    float hole = map_hole(pos, hasBump);\n    \n    #ifdef balls\n    float ballss = map_balls(pos);\n    res = opU(vec2(hole, HOLE_OBJ), vec2(ballss, BALL_OBJ));\n    #else\n    res = vec2(hole, HOLE_OBJ);\n    #endif\n    \n    return res;\n}\n\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 1.8;\n    vec3 pos;\n    float dist;\n    float objnr = 0.;\n    \n  \tfor (int i = 0; i < 70; ++i)\n    {\n    \tpos = ray*t + cam;\n    \tvec2 res = map(pos, false);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.0001)\n            break;\n        t+= dist*(0.85-float(i)*0.0122);\n        objnr = abs(res.y);\n  \t}\n        \n  \treturn vec2(t, objnr);\n}\n\nvec3 getNormal(vec3 pos, float e)\n{\n    vec2 q = vec2(0, e);\n    vec3 norm = normalize(vec3(map(pos + q.yxx, true).x - map(pos - q.yxx, true).x,\n                          map(pos + q.xyx, true).x - map(pos - q.xyx, true).x,\n                          map(pos + q.xxy, true).x - map(pos - q.xxy.x, true)));\n    return norm;\n}\n\nvec3 obj_color(vec3 norm, vec3 pos, float objnr)\n{\n    vec3 colo;\n    \n    if (int(objnr)==BALL_OBJ)\n       colo = ball_color;\n    else\n    {\n       #ifdef test_mode\n       colo = vec3(0.7);\n       #else\n       #ifdef pattern\n       vec3 posr = vec3(pos.yx, cdif);\n       vec3 posg = vec3(pos.yx, 0.);\n       vec3 posb = vec3(pos.yx, -cdif);\n       //colo = vec3(polarNoise2(posg));\n       colo = vec3(polarNoise2(posr), polarNoise2(posg), polarNoise2(posb));\n       #else\n       colo = vec3(0.7);\n       #endif\n       #endif\n    }\n    \n    colo*= smoothstep(bottom, bottom*0.25, -pos.z);\n    colo*= smoothstep(maxdist*0.3, maxdist*0.1, length(pos.yx));\n\n    return colo;\n}\n\n// From https://www.shadertoy.com/view/Xds3zN;\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i=0; i<25; i++)\n    {\n    \tfloat h = map(ro + rd*t, false).x;\n        res = min(res, 4.5*h/t);\n        t += clamp(h, 0.01, 0.12);\n        if( h<0.001 || t>tmax ) break;\n    }\n    return smoothstep(0.0, 0.8, res);\n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, float objnr)\n{\n    vec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    vec3 nlcol = normalize(lamp.color);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse shading\n    vec3 col = ocol*nlcol*lamp.intensity*smoothstep(-0.1, 1., dnp);\n    //col+= 0.6*nlcol*lamp.intensity*smoothstep(0.15, 0.9, dnp);\n    \n    // Specular shading\n    #ifdef specular\n    float specint = int(objnr)==HOLE_OBJ?specint_hole:specint_ball;\n    float specshin = int(objnr)==HOLE_OBJ?specshin_hole:specshin_ball;\n    \n    if (dot(norm, lamp.position - pos) > 0.0)\n        col+= speccolor*nlcol*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin)*smoothstep(bottom, 0., -pos.z);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    //if (int(objnr)==HOLE_OBJ)\n       col*= shi*softshadow(pos, normalize(lamp.position - pos), shf, 6.) + 1. - shi;\n    #endif    \n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, float objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = iResolution.xy*vec2(0.52, 0.65);\n   else\n      iMouse2 = iMouse.xy;\n    \n   campos = vec3(3.5 + 10.*cos(1.3 + 1.3*iMouse2.x/iResolution.x)*(1. - 0.0*iMouse2.y/iResolution.y),\n                 -13. + 12.*(iMouse2.y/iResolution.y),\n                 -5.5 + 10.*sin(1.3 + 1.3*iMouse2.x/iResolution.x)*(1. + 0.6*iMouse2.y/iResolution.y));\n   camtarget = vec3(0., -3.2 + 2.8*iMouse2.y/iResolution.y + 0.1, 1.);\n    \n   #ifdef test_mode\n   campos.z-= 1.5;\n   camtarget.z-= 1.5;\n   fov = 4.;\n   #endif\n    \n   camdir = camtarget - campos;   \n}\n\nRenderData trace0(vec3 tpos, vec3 ray)\n{\n  vec2 t = trace(tpos, ray, maxdist);\n  float tx = t.x;\n  vec3 col;\n  float objnr = t.y;\n    \n  vec3 pos = tpos + tx*ray;\n  vec3 norm;\n  if (tx<maxdist*0.65)\n  {\n      norm = getNormal(pos, normdelta);\n\n      // Coloring\n      col = obj_color(norm, pos, objnr);\n      \n      // Shading\n      col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n  }\n  return RenderData(col, pos, norm, objnr);\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(r, 0., 0.8);\n}\n\nvec4 render(vec2 fragCoord)\n{\n  lamps[0] = Lamp(vec3(7., -8., 3.5), vec3(1.0, 1.0, 1.0), 11.2, 0.1);\n  lamps[1] = Lamp(vec3(-14., 2.5, 29.), vec3(0.7, 0.82, 1.0), 7.0, 0.1);\n  lamps[2] = Lamp(vec3(1., 0., 1.2), vec3(1.0, 0.6, 0.4), 0.6, 0.1);\n    \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray);\n  vec3 col = traceinf.col;\n    \n  #ifdef ball_reflection\n  if (int(traceinf.objnr)==BALL_OBJ)\n  {\n     vec3 refray;\n     float rf = 1.;\n     refray = reflect(ray, traceinf.norm);\n\n     RenderData traceinf_ref = trace0(traceinf.pos, refray);\n     rf = 0.75*fresnel(ray, traceinf.norm, 2.5)*smoothstep(bottom, 0., -traceinf.pos.z);\n\n     col = mix(col, traceinf_ref.col, rf);    \n  }\n  #endif\n    \n  return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setCamera();\n    \n    // Antialiasing\n    vec4 orv;\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          #ifdef motion_blur\n          //time2 = iTime + mbLength*hash(vec3(iTime*20.) + vec3(fragCoord*6., (i+aasamples*j)*5));\n          time2 = iTime + mbLength*float(j*aasamples+i)/float(aasamples*aasamples);\n          #else\n          time2 = iTime;\n          #endif\n           \n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vec4 rv = render(fragCoord + vec2(ox, oy));\n          vs+= rv;        \n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tXSRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tXSWr", "name": "lines_siniy_iniy", "author": "foran", "description": "lines", "tags": ["lines"], "likes": 2, "viewed": 80, "date": "1562561273", "time_retrieved": "2024-06-20T19:39:59.318809", "image_code": "\nconst float PI=3.1415926535;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 coord =6.* (gl_FragCoord.xy-.05*iResolution.xy)/min(iResolution.y,iResolution.x);//   6.* - zoom\n/*\n  for (int n = 1; n < 8; n++){\n    float i = float(n);\n    //coord += vec2(0.7 / i * sin(i * coord.y + iTime + 0.3 * i) + 0.8, 0.4 / i * sin(coord.x +iTime + 0.3 * i) + 1.6);\n    coord+=vec2(.7/i*sin(coord.y+.3*i)+.8,.4/i*sin(coord.x+.3*i)+1.6)*7.;//   *7 - blur\n  }\n*/\n  //coord -= vec2(0.7 / sin(coord.y + iTime + 0.3) + 0.8, 0.4 / sin(coord.x + iTime + 0.3) + 1.6);\n  //coord*=vec2(.14/abs(coord.x+iTime+.2),.14/cos(coord.x+iTime+.2)+1.6);\n\n  coord*=vec2(.14/tan(coord.x+iTime+.2),.14/tan(coord.x+iTime+.2)+1.6);\n  //coord*=vec2(coord.x*1.+iTime+1.2*coord.y+iTime);\n    coord-=vec2(coord.x+iTime+sin(2.*PI*coord.y+iTime));\n // coord-=vec2(coord.x+iTime+sin(2.*PI*coord.y+iTime)*2.);\n\n  vec3 color = vec3(0.5 * sin(coord.x) + 0.5, 0.5 * sin(coord.y) + 0.5, sin(coord.x + coord.y));\n\n  //fragColor = vec4(color, 1.0);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tXSWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tXSWX", "name": "weee", "author": "Demuss", "description": "learning", "tags": ["trees"], "likes": 1, "viewed": 90, "date": "1564414894", "time_retrieved": "2024-06-20T19:39:59.682605", "image_code": "void DrawTree( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    \n    vec2 positionInScene = vec2(0.4, 0.6);\n    vec2 basePos = p - positionInScene;\n    \n    float wind = cos(iTime*1.0)*0.064;\n    vec2 windPos = p - vec2(positionInScene.x+wind, positionInScene.y);\n       \n\tvec2 q;\n     \n    float MovedCos = (1.0+(cos(iTime*1.0))/2.0);\n    float r = 0.0;\n    // Time varying pixel color\n    vec3 col = mix( vec3( 1.0, 0.3, 0.0 ), vec3( 1.0, 0.8, 0.3 ), sqrt(p.y+MovedCos*0.1)); \n    \n    //Ground and wood\n    q = basePos;\n    r = 0.015;\n    r += 0.002*cos(120.0*q.y);\n    r += exp(-60.0*p.y);\n    float ErasePoint = 0.00;\n    \n    float qy = (windPos + sqrt(p.y)*(basePos-windPos)).y+0.5;\n    col *= 1.0 - (1.0-smoothstep(r, r+0.0005, abs(q.x-wind*qy*2.0) )) * (1.0-smoothstep(ErasePoint, ErasePoint+0.01, q.y));\n    \n    \n    //leaves \n\tq = windPos;\n    float wings = 10.0;\n    r = 0.2 + 0.1*cos(atan(q.y, q.x)*wings + 16.0 * q.x + (cos(iTime*5.0))/2.0 * 0.5);\n    col *= smoothstep( r, r+MovedCos*0.01+0.00, length(q));\n    \n  \n    \n    \n    \n    basePos = p - vec2(0.8, 0.4); \n    windPos = p - vec2(0.8+wind, 0.4);\n    \n    //Ground and wood\n    q = basePos;\n    r = 0.01;\n    float trunkComplexity = 0.0015;\n    r += trunkComplexity*cos(120.0*q.y);\n    r += exp(-60.0*p.y);\n    ErasePoint = 0.00;\n    \n    qy = (windPos + sqrt(p.y)*(basePos-windPos)).y+0.35;\n    col *= 1.0 - (1.0-smoothstep(r, r+0.0005, abs(q.x-wind*qy*3.0) )) * (1.0-smoothstep(ErasePoint, ErasePoint+0.01, q.y));\n    \n    \n    //leaves \n\tq = windPos;\n    wings = 7.0;\n    r = 0.1 + 0.05*cos(atan(q.y, q.x)*wings + 16.0 * q.x + (cos(iTime*5.0))/2.0 * 0.5);\n    col *= smoothstep( r, r+MovedCos*0.01+0.00, length(q));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tXSWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tXSz7", "name": "[TWITCH] Shader101 - 2D", "author": "Flopine", "description": "This is a shader I made during a live session on Twitch, about teaching people the basics of shadercoding. You can watch them here: https://www.twitch.tv/flopine", "tags": ["2d", "glsl", "repeat"], "likes": 7, "viewed": 274, "date": "1562362688", "time_retrieved": "2024-06-20T19:40:00.124973", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n// This was a Twitch session where I gave people a course about the basics\n// of shadercoding.\n// Sorry Fabrice Neyret for not using smoothstep function for anti-aliasing ^^\"\n\n#define fGlobalTime iTime\n\n// rotation matrice function\nmat2 rot (float a)\n{return mat2 (cos(a), sin(a), -sin(a),cos(a));}\n\n// split the screen in two in the x axis\nfloat banding (vec2 uv)\n{\n    // 3 ways of doing it:\n    // 1.\n    //if(uv.x < 0.) return 0.;\n    //else return 1.;\n\t// 2.\n    //return (uv.x<0.) ? 0.: 1.;\n\t// 3.\n    return smoothstep(0., 0.1,uv.x);\n\n}\n\nfloat triangle (vec2 uv, float size)\n{\n    // symmetry in the y axis\n    uv.x = abs(uv.x);\n    return step(max(-uv.y,dot(uv,vec2(1.,0.6))), size);\n}\n\nfloat square (vec2 uv, float size)\n{\n    uv = abs(uv);\n    return step(max(uv.x, uv.y),size);\n}\n\n\nfloat circle (vec2 uv, float size)\n{return step(length(uv), size);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n    uv.x /= iResolution.y / iResolution.x;\n\t// scale the uv\n    uv *= 5.;\n    // repeating the uv into a grid in 2 ways\n    // 1.\n    //vec2 guv = mod(uv,1)-.5;\n    // 2.\n    vec2 guv = fract(uv)-.5;\n    // id of each cells\n    vec2 id = floor(uv);\n    guv *= rot(fGlobalTime*(length(id)+0.8)*0.3);\n    \n    float b = banding(uv);\n    // clamp the value is a security if you want to use those shapes as \n    // mask for example\n    float t = clamp(triangle(guv,0.15)-triangle(guv,0.05),0.,1.);\n    float s = clamp(square(guv, 0.35) - square(guv, 0.31),0.,1.);\n    float c = clamp(circle(uv,.8) - circle(uv,.7), 0., 1.);\n\t\n    // also necessary here because when the square and triangle intersect\n    // the color value is 2\n    vec3 col = clamp(vec3(s+t),0.,1.); \n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tXSz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tXXDj", "name": "Mothership", "author": "jblanper", "description": "I play with the number of iterations of the loop inside the ray marching algorithm to get this \"fluid\" effect.", "tags": ["3d", "raymarching", "fractal"], "likes": 5, "viewed": 121, "date": "1564221084", "time_retrieved": "2024-06-20T19:40:00.894818", "image_code": "float tt, g;\n\nmat2 rotate(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat smin( float a, float b, float k ) {\n  float h = max( k-abs(a-b), 0.0 )/k;\n  return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat sphereSDF (vec3 p, vec3 c, float r) {\n  return length(c - p) - r;\n}\n\nfloat cubeSDF (vec3 p, vec3 c, vec3 dimensions, float borderRoundness) {\n  vec3 pos = abs(c - p) - dimensions;\n  return length(max(pos, 0.)) - borderRoundness + min(max(pos.x, max(pos.y, pos.z)), 0.);\n}\n\nvec2 map (vec3 p) {\n  //fractal\n    \n  float n = sin(tt * 6.) * .05 + .05;\n  for (int i=0; i<2; i++) {\n    p = abs(p) - vec3(4., 3., 5.);\n    //p = abs(p) - vec3(2., 1., 3.);\n\n    p.xz *= rotate(sin(tt - p.y + p.x) * n + .6);\n    p.yz *= rotate(cos(tt + p.x) * (n * .7) + 5.8);\n    p.xy *= rotate(cos(tt + p.z) * (n * 1.2) + 2.);\n    //p += length(p.yx * sin(tt) * .2 + .4) * .5;\n  }\n\n  p *= .7; // to scale fractal\n\n  // primitives\n  \n  float c1 = cubeSDF(abs(p) - vec3(length(p.yz) + .2, .1, .8), vec3(0.), vec3(.5, .2, .8), .05);\n  c1 += sin(p.x * 4.) * cos(p.y * 6. + sin(tt)) * sin(p.z * 3.) * .3;\n  float c2 = cubeSDF(abs(p) - vec3(.5, .3, 2.), vec3(0.), vec3(.3, .1, .6), .01);\n\n  vec2 t = vec2(smin(c1 * .1, c2 * .05, .5), 2.);\n  \n  p += sin(length(p) * 22. + tt * .2) * .04;\n  float c3 = cubeSDF(abs(p) - vec3(.3, .2, .2), vec3(2.), vec3(.2, .4, .3), .03) * .3;  \n  vec2 h = vec2(smin(c3 * .2, c2 * .3, 1.2), .1);\n  t = (t.x < h.x) ? t : h; // merge materials\n\n  return t / .8;\n}\n\nvec2 trace (vec3 ro, vec3 rd) {\n  const float MAX_DEPTH = 50.;\n  vec2 h, t = vec2(.1);\n\n  for (int i = 0; i < 268; i++) {\n    h = map(ro + rd * t.x);\n    if (h.x < .00001 || t.x > MAX_DEPTH) break;\n    t.x += h.x; t.y = h.y;\n  }\n  if (t.x > MAX_DEPTH) t.x = 0.;\n  return t;\n}\n\nvec3 getNormal (vec3 p) {\n  float d = map(p).x;\n  vec2 e = vec2(.01, 0.);\n\n  return normalize(d - vec3(\n    map(p - e.xyy).x,\n    map(p - e.yxy).x,\n    map(p - e.yyx).x));\n}\n\nstruct Material {\n  float ambient;\n  float diffuse;\n  float specular;\n};\n\nfloat getLight (vec3 lightPos, vec3 p, vec3 rd, float lightOcclusion, Material material) {\n  // https://www.shadertoy.com/view/ll2GW1\n  vec3 light = normalize(lightPos - p);\n  vec3 normal = getNormal(p);\n\n  // phong reflection\n  float ambient = clamp(.5 + .5 * normal.y, 0., 1.);\n  float diffuse = clamp(dot(normal, light), 0., 1.);\n  vec3 half_way = normalize(-rd + light);\n  float specular = pow(clamp(dot(half_way, normal), 0.0, 1.0), 16.);\n\n  return (ambient * material.ambient * lightOcclusion) +\n   (diffuse * material.diffuse * lightOcclusion) +\n   (diffuse * specular * material.specular * lightOcclusion);\n}\n\nvec3 getRayDirection (vec2 uv, vec3 rayOrigin, vec3 lookat, float zoom) {\n  // https://www.youtube.com/watch?v=PBxuVlp7nuM\n  vec3 forward = normalize(lookat - rayOrigin);\n  vec3 right = normalize(cross(vec3(0., 1., 0.), forward));\n  vec3 up = cross(forward, right);\n  vec3 center = rayOrigin + forward * zoom;\n  vec3 intersection = center + uv.x * right + uv.y * up;\n  return normalize(intersection - rayOrigin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n  tt = mod(iTime * .1, 100.);\n\n  // camera\n  vec3 ro = vec3(0., 0., 30. + sin(tt * 1.2) * 10.);\n  //vec3 ro = vec3(0., 0., 35.);\n  ro.xz *= rotate(tt * .25);\n  ro.yz *= rotate(tt * .5);\n  vec3 rd = getRayDirection(uv, ro, vec3(0.), 2.);\n\n  // color, fog and light direction\n  //vec3 ld = normalize(vec3(.5, .8, .5));\n  vec3 ld = vec3(5., 8., 3.);\n  vec3 fogColor = vec3(.1, .4, .5);\n  //vec3 fogColor = vec3(.2, .3, .8) * .1;\n  vec3 fog = fogColor * (.5 + (length(uv) - .3));\n  vec3 color = fog;\n\n  // scene\n  vec2 sc = trace(ro, rd);\n  float t = sc.x;\n\n  if (t > 0.) {\n    vec3 p = ro + rd * t;\n    vec3 normal = getNormal(p);\n    vec3 albido = vec3(.2, .3, .8) * 2.;//base color\n\n    if (sc.y > .9) {\n      albido = vec3(.8, .2, .3) * 2.;\n      color = getLight(ld, p, rd, 1.2, Material(0., .8, 1.)) * vec3(.3, .5, .2) * 2.;\n      color *= albido * 2.;\n    } else {\n      color = getLight(ld, p, rd, .5, Material(.7, .3, 4.5)) * vec3(.3, .5, .2) * 2.;\n      color /= albido * 3.;\n    }\n\n    // lightning\n    ld.xz *= rotate(tt * 10.);\n    color = mix(color, getLight(ro, p, rd, .5, Material(0., .7, 5.2)) * albido, .4);\n\n    color = mix(color, fog, 1. - exp(-.00006*t*t*t)); //gradient\n  } \n\n  fragColor = vec4(pow(color, vec3(.45)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tXXDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tXXDl", "name": "Visualizer__02", "author": "s_das", "description": " ", "tags": ["distancefield", "colorful", "gradient", "abstract", "visualizer", "mirror"], "likes": 4, "viewed": 274, "date": "1564557734", "time_retrieved": "2024-06-20T19:40:00.894818", "image_code": "\n \n\nvoid mainImage(out vec4 FragColor, in vec2 FragCoord){\n    vec2 uv = FragCoord.xy/iResolution.xy;\n    uv = 2.*uv - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\n    float da = iTime/(5.);\n    vec2 pts = vec2(sin(da*2.), cos(da*2.));\n\n    float d = length(cos(  abs((abs(uv)+atan(da))*pts))*sin(atan(abs(uv))));\n\n    d = atan(d) - cos(da+d*d)*sin(da - d*d);\n    d -= atan(cos(da)*abs(  fract(d*d)-da) + 0.5);\n\t\n    d -= sin(d)*abs(uv.x*uv.y);\n    d *= length(d + abs(uv.y));\n    \n    float fill = step(tan(fract(abs(d)-0.5)*da),0.2);\n \t\n \t\n    vec3 col = vec3(fill - sin(d-da ));\n\t\n    \n    \n    col += vec3(0., 0.2, 1.);\n    col *= vec3(1., 0.1, 0.2);\n    FragColor = vec4(col, 1.);\n\t//da += uv.x;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tXXDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tXXRX", "name": "Devil Egg", "author": "104", "description": "Why are eggs in the dairy isle anyway?", "tags": ["sd", "poultry", "dairy", "puns"], "likes": 4, "viewed": 108, "date": "1564504952", "time_retrieved": "2024-06-20T19:40:01.446239", "image_code": "const float bigsize = .8;\nconst float smallsize = .09;\nconst float span = .1;\n\nconst float PI = 3.14159;\nconst float PI2 = PI*2.;\n\nmat2 rot2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\nfloat nsin(float x) {\n    return cos(x)*.5+.5;\n}\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdShape(vec2 p, float r) {\n    return length(p+r*.5)-r;\n}\nvoid egg(inout vec2 sd, vec2 uv, float t, float r, float a) {\n    if (r <= 0.) return;\n    float yolk = sdShape((11./sqrt(2.))*uv*rot2D(a), r);\n    float white = sdShape((5.2/sqrt(2.))*uv*rot2D(a), r);\n    sd = vec2(opUnion(sd.x, white),\n              opUnion(sd.y, yolk));\n}\n\n// invisible dots creating some kind of underlying disturbance\nfloat under(vec2 N, float t) {\n    const float sz = .001;\n    const float range = 1.8;\n    vec2 p1 = vec2(sin(-t*1.6666), cos(t)) * range;\n    vec2 p2 = vec2(sin(t), sin(t*1.3333)) * range;\n    float b = min(length(p1-N)-sz, length(p2-N)-sz);\n    return b;\n}\n\nvoid smallEggField(inout vec2 sd, vec2 uv, vec2 uvbig, float t) {\n    vec2 uvsmall = mod(uv+vec2(t*.3,0),span)-span*.5;// uv within small scroll period\n    vec2 uvsmall_q = (uv-uvsmall);// uv of scrolling small egg field\n    vec2 sdquant = vec2(1e6);\n    // find the dist to the big egg, quantizing big egg's coords to small egg coords\n    egg(sdquant, uvsmall_q, t, bigsize, under(uvsmall_q, t));\n    egg(sd,uvsmall, t, smallsize * smoothstep(0.,.8,sdquant.x - .5), under(uvbig*10., t));\n}\n\nvec3 color(vec2 sd, float fact) {\n    vec3 o;\n    o.rgb = 1.-smoothstep(vec3(0),fact*vec3(.06,.03,.02), vec3(sd.x));\n    o.rgb *= vec3(.9,.7,.7)*.8;\n    o.g += .05;\n    if (sd.x < 0.) o -= sd.x*.6;\n    o = clamp(o,o-o,o-o+1.);\n    \n    vec3 ayolk = 1.-smoothstep(vec3(0),fact*vec3(.2,.1,.2),sd.yyy);\n    o.rgb = mix(o.rgb, vec3(.5,.5,0), ayolk);\n    if (sd.y < 0.) o -= sd.y*.1;\n    o = clamp(o,o-o,o-o+1.);\n    return o;\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    vec2 N = uv;\n    uv.x *= iResolution.x / iResolution.y;\n    float t = iTime;\n    uv.y -= .1;\n    vec2 sd = vec2(1e6);\n\n    vec2 uvbig = uv;// uv of the big egg and disturbance layer both\n\n    // big egg\n    egg(sd, uv, t, bigsize, under(uvbig, t));\n\n    // small eggs\n    vec2 sdsmall = vec2(1e6);\n    smallEggField(sdsmall, uv, uvbig, t);\n    uv -= span * .5;\n    smallEggField(sdsmall, uv, uvbig, t);\n\n    o.rgb = mix(color(sd, 2.), color(sdsmall, .2), vec3(step(.1,sd.x)));\n\n    o = pow(o, o-o+.5);\n    o.rgb += (hash32(fragCoord+iTime)-.5)*.1;\n    o = clamp(o,o-o,o-o+1.);\n    o *= 1.-length(13.*pow(abs(N), vec2(4.)));// vingette\n    o.a = 1.;\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tXXRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tXXzX", "name": "Volumetric Mandelbulb", "author": "loicvdb", "description": "Volumetric rendering for fractals defined by boolean functions, here a Mandelbulb", "tags": ["fractal", "mandelbulb", "volumetric"], "likes": 58, "viewed": 1759, "date": "1563656551", "time_retrieved": "2024-06-20T19:40:01.452492", "image_code": "#define Pi 3.14159265359\n#define ViewStart 1.6\n#define ViewEnd 4.4\n\n\n//#define HQ\n\n\n#ifdef HQ\nint CameraRaySteps = 255;\nint ShadowRaySteps = 64;\nfloat MaxTransparency = .95;\n#else\nint CameraRaySteps = 128;\nint ShadowRaySteps = 16;\nfloat MaxTransparency = .7;\n#endif\n\n\n\nvec3 DirCam = normalize(vec3(-1, 0, 0));\nvec3 PosCam = vec3(3.0, 0, .0);\nfloat FocalLength = 1.0;\n\nvec3 LightColor = vec3(1.5);\nvec3 LightPos;\n\nfloat Density = 25.0;\nfloat Anisotropy = .25;\nvec3 VolumeColor = vec3(.1, .15, .2);\n\nfloat Power;\n\n\n\nvec3 powV(vec3 v, float p){\n    return vec3(pow(v.x, p), pow(v.y, p), pow(v.z, p));\n}\n\nfloat maxV(vec3 v){\n    return max(max(v.x, v.y), v.z);\n}\n\nbool insideShape(vec3 pos) {\n\tvec3 z = pos;\n\tfloat r;\n\tfloat zr;\n    float sinTheta;\n    float phi;\n    float theta;\n\tfor(int i = 0; i < 4; i++) {\n\t\tr = length(z);\n\t\tif(r>1.3) break;\n\t\ttheta = acos(z.z/r)*Power;\n\t\tphi = atan(z.y,z.x)*Power;\n        sinTheta = sin(theta);\n\t\tz = pow(r,Power)*vec3(sinTheta*vec2(cos(phi), sin(phi)), cos(theta)) + pos;\n\t}\n\treturn r < 1.0 && r > .65;\n}\n\nfloat henyeyGreenstein(vec3 pos, vec3 dir){\n\tfloat cosTheta = dot(dir, normalize(LightPos-pos));\n \treturn Pi/4.0 * (1.0-Anisotropy*Anisotropy) / pow(1.0 + Anisotropy*Anisotropy - 2.0*Anisotropy*cosTheta, 3.0/2.0);\n}\n\nvec3 lightReceived(vec3 pos, float headStart){\n    \n    float LightDist = length(LightPos-pos);\n    vec3 LightDir = normalize(LightPos-pos);\n    \n    float stepSize = LightDist / float(ShadowRaySteps);\n    vec3 absorption = vec3(1.0);\n    \n    pos += headStart * LightDir * stepSize;\n    \n    for(int i = 0; i < ShadowRaySteps; i++){\n        if(insideShape(pos)){\n            absorption *= powV(vec3(1)-VolumeColor, stepSize*Density);\n        }\n        pos += LightDir * stepSize;\n    }\n    return absorption*LightColor / (LightDist*LightDist);\n}\n\n\nvec3 rotateZ(vec3 p, float angle){\n    return vec3(cos(angle) * p.x + sin(angle) * p.y,\n                -sin(angle) * p.x + cos(angle) * p.y,\n                p.z);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //quick animation ...\n    DirCam = rotateZ(DirCam, -iTime/3.0);\n    PosCam = rotateZ(PosCam, -iTime/3.0);\n    Power = abs(cos(iTime/5.0)) * 7.0 + 1.0;\n    LightPos = vec3(cos(iTime/2.0), -sin(iTime/2.0), cos(iTime/1.0)) * 1.25;\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy/2.0)/iResolution.y;\n    \n    vec3 camX = vec3(-DirCam.y, DirCam.x, 0);\n\tvec3 camY = cross(camX, DirCam);\n\tvec3 sensorX = camX * (uv.x/length(camX));\n\tvec3 sensorY = camY * (uv.y/length(camY));\n\tvec3 centerSensor = PosCam - DirCam * FocalLength;\n\tvec3 posOnSensor = centerSensor + sensorX + sensorY;\n\tvec3 dir = normalize(PosCam - posOnSensor);\n\t\n    vec3 pos = PosCam + dir*ViewStart;\n    float hg = henyeyGreenstein(pos, dir);\n    vec3 color;\n    \n    float stepSize = (ViewEnd-ViewStart) / float(CameraRaySteps);\n    vec3 absorption = vec3(1.0);\n    \n    float headStart = texture(iChannel0, fragCoord/vec2(1024)).a;\n    \n    pos += headStart * dir * stepSize;\n    \n    for(int i = 0; i < CameraRaySteps; i++){\n        if(length(LightPos-pos) <.05){\n            color += 10.0*absorption*LightColor;\n            break;\n        }\n        if(insideShape(pos)){\n            color += VolumeColor*absorption*lightReceived(pos, headStart)*hg*stepSize*Density;\n            absorption *= powV(vec3(1)-VolumeColor, stepSize*Density);\n        }\n        pos += dir * stepSize;\n        if(maxV(absorption) < 1.0-MaxTransparency) break;\n    }\n    \n\tfragColor = vec4(log(color + vec3(1.0)), 1.0);\t//reduces clipping and desaturates bright colors\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tXXzX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4stBWS", "name": "radarr", "author": "lebek", "description": "....", "tags": ["polarradar"], "likes": 5, "viewed": 110, "date": "1564460342", "time_retrieved": "2024-06-20T19:40:01.452492", "image_code": "#define PI 3.14159265359\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 pos = uv - vec2(0.5, 0.5);\n    \n    float r = length(pos);\n    //float a = (atan(pos.y, pos.x) + PI)/(2.0*PI);\n    \n    float t = atan(pos.y, pos.x) - iTime*2.5;\n    float a = (atan(sin(t), cos(t)) + PI)/(2.0*PI);\n    \n    // Output to screen\n    //a = sin(a*2.0+iTime*3.0)*0.5+0.5;\n    float ta = 0.5;\n    float v = smoothstep(ta-0.05,ta+0.05,a) * smoothstep(ta+0.05,ta-0.05,a);\n    vec3 col = vec3(0, v, 0);\n    float blink = pow(sin(iTime*1.5)*0.5+0.5, 0.8);\n    //col = vec3(0.0, pow(a, 20.0/r)*(0.5+.5*blink), 0.0);\n    col = vec3(0.0, pow(a, 8.0*(.2+blink))*(sin(r*500.0)*.5+.5), 0.0);\n    col = col*pow(r, 0.4);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4stBWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ld3BRM", "name": "Binary Heap GLSL", "author": "nnorm", "description": "A naïve binary heap implementation in GLSL. Probably not very useful but...here you go anyway.\n\nEDIT: This is probably useless af, I'm not sure it's correct either. Use it as you wish. :)", "tags": ["tree", "datastructure", "whywouldyoudothat"], "likes": 1, "viewed": 92, "date": "1563202426", "time_retrieved": "2024-06-20T19:40:02.028171", "image_code": "/* Binary Heap GLSL Implementation */\n/* \n** Since a Binary Heap (either min-heap or max-heap) can be stored in an array I figured I could\n** implement it in a shader. If you change the data type to a struct for exemple you can use that\n** and rank the nodes depending on the criteria you need (depth? thickness? density?)\n** and then use that datastructure to cull stuff maybe? Or maybe you need to have a simple\n** binary tree structure for each pixel. I've set the size of the container to 128 but it can be\n** smaller or bigger.\n**/\n\nstruct BinaryHeap\n{\n    int count_;\n    int data_[128];\n};\n\nBinaryHeap makeBHeap()\n{\n    //-1 here is just an \"impossible id\"\n    //note that in GLSL arrays must be initialized w/ a constant expression\n    //that is why...you know there's the following line\n    BinaryHeap b = BinaryHeap(0,  int[128](-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1));    \n    //this can be solved w/ some preprocessor macro, too lazy for now to write it tho\n    return b;\n}\n\nint getParent(in BinaryHeap b, int i)\n{\n    int index = int(floor((float(i)-1.0)/2.0));\n    return b.data_[index];\n}\n\nint getLeftChild(in BinaryHeap b, int i)\n{\n    return b.data_[i*2+1];\n}\n\nint getRightChild(in BinaryHeap b, int i)\n{\n    return b.data_[i*2+2];\n}\n\nbool insertNodeMin(in BinaryHeap b, int x)\n{\n    if(b.count_ < 128)\n    {\n        int i = b.count_ - 1;\n        b.data_[i] = x;\n        while(b.data_[i] > getParent(b, i))\n        {\n            int pindex = int(floor((float(i)-1.0)/2.0));\n            int tmp = getParent(b, i);\n            b.data_[i-1] = tmp;\n            b.data_[pindex] = x;\n            i = pindex;\n        }\n        b.count_ += 1;\n        return true;\n    }\n\telse\n    \treturn false;\n}\n\nbool insertNodeMax(in BinaryHeap b, int x)\n{\n    if(b.count_ < 128)\n    {\n        int i = b.count_ - 1;\n        b.data_[i] = x;\n        while(b.data_[i] < getParent(b, i))\n        {\n            int pindex = int(floor((float(i)-1.0)/2.0));\n            int tmp = getParent(b, i);\n            b.data_[i-1] = tmp;\n            b.data_[pindex] = x;\n            i = pindex;\n        }\n        b.count_ += 1;\n        return true;\n    }\n\telse\n    \treturn false;\n}\n\nint getRoot(in BinaryHeap b)\n{\n    return b.data_[0]; //either the min or the max of the heap\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld3BRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlBfRV", "name": "Sparse Voxel Octree Raytracing", "author": "warvstar", "description": "Just testing out different forms of volume rendering.\n\nNot as fast as others on here, but pretty simple.", "tags": ["voxels", "octree"], "likes": 11, "viewed": 964, "date": "1564367038", "time_retrieved": "2024-06-20T19:40:02.640289", "image_code": "#define BUNNY\n//#define SPHERE\n\n//bunny 32sq\n#ifdef BUNNY\nint voxels[1840] = int[1840](1,0,0,0,0,0,0,0,8,11,2,44,116,122,154,161,0,0,3,0,63,57,36,47,0,5,0,4,0,6,0,7,0,0,0,0,-1,-1,-1,-1,0,0,0,0,0,0,0,-1,-1,0,-1,-1,-1,0,-1,-1,-1,-1,-1,0,-1,-1,0,0,0,18,0,9,68,21,53,28,0,0,0,0,0,10,0,14,0,0,0,0,0,-1,-1,-1,16,0,12,0,24,50,30,41,0,0,0,0,13,20,15,0,0,0,0,0,-1,-1,-1,-1,0,0,0,0,-1,-1,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,-1,0,0,0,0,-1,0,-1,0,22,23,49,26,70,72,74,75,0,0,0,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,39,40,25,27,73,71,76,77,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,52,29,43,33,80,81,87,88,-1,-1,-1,-1,-1,-1,-1,-1,31,32,34,35,82,83,89,90,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,37,0,38,115,99,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,0,0,0,0,0,0,0,0,-1,-1,0,0,-1,-1,0,0,-1,0,0,0,-1,-1,42,0,56,0,84,113,91,0,-1,0,-1,0,-1,-1,-1,-1,0,-1,0,0,-1,-1,-1,-1,0,0,0,0,60,65,45,0,0,0,46,0,0,0,0,0,-1,0,-1,0,-1,0,0,0,0,67,0,48,100,101,102,103,0,0,0,-1,-1,-1,-1,-1,0,0,0,0,0,-1,0,0,0,0,51,0,104,0,78,106,0,0,0,0,-1,0,-1,0,0,0,0,0,-1,-1,-1,-1,0,54,0,55,107,79,85,86,0,0,0,0,0,-1,-1,-1,0,0,0,0,-1,-1,-1,-1,0,0,0,0,-1,-1,-1,0,58,59,0,0,93,94,110,114,0,0,0,0,-1,-1,-1,-1,0,0,0,0,-1,-1,-1,-1,61,62,0,0,95,96,111,112,0,0,0,0,-1,-1,-1,-1,0,0,0,0,-1,-1,-1,-1,0,64,0,0,108,92,109,98,0,0,0,0,-1,-1,0,0,66,0,0,0,97,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,69,0,105,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,0,-1,0,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,0,-1,-1,0,0,-1,0,0,-1,0,0,0,-1,0,0,-1,0,-1,0,0,0,0,0,0,0,-1,0,0,0,-1,-1,0,-1,0,0,0,-1,0,-1,-1,0,-1,0,-1,0,-1,-1,0,0,0,-1,0,0,0,-1,0,-1,0,-1,0,-1,-1,-1,0,-1,0,-1,-1,-1,0,-1,-1,-1,0,0,-1,-1,-1,0,-1,-1,0,0,-1,-1,0,0,-1,0,0,0,-1,-1,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,-1,0,0,117,119,135,137,0,215,0,223,0,118,0,134,0,178,0,183,0,0,0,-1,0,0,0,-1,120,121,128,129,179,181,184,185,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,123,126,140,143,217,0,220,0,124,125,130,131,182,180,186,187,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,127,0,132,133,0,0,188,0,0,0,-1,-1,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,0,-1,-1,0,0,0,-1,0,0,0,-1,146,136,147,148,195,189,196,197,-1,-1,-1,-1,-1,-1,-1,-1,138,139,149,150,190,191,198,199,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,141,142,151,152,192,193,200,201,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,144,145,153,0,194,0,202,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,0,-1,-1,0,0,0,-1,0,-1,0,0,0,-1,-1,-1,0,-1,0,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,155,158,173,176,228,0,0,0,156,157,167,168,209,203,210,211,0,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,159,160,169,170,204,205,212,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,162,165,0,0,0,0,0,0,163,164,171,172,206,207,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,166,0,0,0,208,0,0,0,-1,-1,-1,0,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,0,-1,0,-1,-1,0,0,0,0,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,174,175,0,0,213,214,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,177,0,0,0,0,0,0,0,-1,0,0,0,-1,0,0,0,0,0,0,-1,0,0,0,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,-1,0,0,0,0,0,0,-1,-1,-1,-1,-1,0,0,0,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,0,0,-1,0,-1,-1,-1,-1,0,0,0,-1,-1,-1,-1,-1,0,0,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,0,0,0,0,-1,0,0,0,0,0,-1,0,-1,0,0,0,0,-1,-1,-1,-1,0,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,0,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,0,0,0,0,-1,-1,-1,-1,0,0,0,0,-1,-1,-1,-1,-1,-1,0,0,-1,-1,-1,-1,-1,0,0,0,-1,0,0,0,0,0,0,0,0,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,216,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,218,219,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,-1,0,0,0,0,0,221,222,226,227,0,0,0,0,-1,-1,-1,-1,0,0,0,0,-1,0,-1,-1,0,0,0,0,0,224,0,225,0,0,0,0,0,-1,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,-1,-1,-1,-1,0,0,0,0,-1,0,0,0,0,0,0,0,0,229,0,0,0,0,0,0,0,0,-1,0,0,0,0,0);\n//small test to understand the layout\n#elif defined(SPHERE)\nint voxels[480] = int[480](3,5,7,1,30,28,37,40,2,10,12,0,21,22,24,25,-1,0,0,0,-1,-1,-1,-1,0,0,0,4,0,13,18,15,0,0,0,0,-1,-1,-1,-1,0,0,6,9,14,26,16,17,0,0,0,0,-1,-1,-1,-1,0,8,0,11,19,20,27,23,0,0,0,0,-1,-1,-1,-1,0,0,0,0,0,0,-1,0,0,0,0,0,-1,0,-1,0,0,0,0,0,0,-1,0,0,0,0,0,0,-1,-1,0,0,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,0,-1,0,-1,0,-1,0,-1,0,-1,0,-1,0,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,0,0,-1,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,-1,0,0,29,32,35,36,48,0,50,51,-1,0,-1,-1,0,0,-1,-1,0,31,33,34,0,47,52,49,0,0,-1,-1,0,0,-1,-1,0,0,-1,0,0,0,-1,0,0,-1,0,-1,0,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,38,39,43,44,53,54,0,57,-1,-1,0,-1,0,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,41,42,45,46,55,56,58,59,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,0,0,0,-1,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,0,0,-1,0,0,0,0,0,0,-1,0,0,0,0,0,0,-1,-1,0,0,0,0,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,-1,0,-1,0,0,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,0,0,0,0,0,-1,-1,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,-1,0,0,0,0,0,0,0);\n#else\nint voxels[48] = int[48](3,0,0,1,-1,-1,-1,-1,\n                         2,-1,0,0,0,0,-1,-1,\n                        5,-1,-1,0,0,0,0,0,\n                         0,4,0,0,0,0,0,0,\n                         0,-1,-1,0,0,0,0,0,\n                        -1,-1,0,0,0,0,0,0);\n#endif\nconst vec3 PPP = vec3(1, 1, 1);\nconst vec3 PNP = vec3(1, -1, 1);\nconst vec3 PNN = vec3(1, -1, -1);\nconst vec3 NPN = vec3(-1, 1, -1);\nconst vec3 NNN = vec3(-1, -1, -1);\nconst vec3 NNP = vec3(-1, -1, 1);\nconst vec3 NPP = vec3(-1, 1, 1);\nconst vec3 PPN = vec3(1, 1, -1);\nconst vec3 POS[8] = vec3[8](PNN, PNP, PPN, PPP, NNN, NNP, NPN, NPP);\nstruct Ray { vec3 o, d, invDir; };\nstruct Hit {\n\tvec3 p;\n\tfloat t;\t// solution to p=o+t*d\n\tfloat tmax;    //distance to exit point?\n\tfloat tmin;    // distance to enter point?\n\tvec3 n;\t\t// normal\n};\nbool BBoxIntersect(const vec3 boxMin, const vec3 boxMax, const Ray r, out Hit hit) {\n\tvec3 tbot = r.invDir * (boxMin - r.o);\n\tvec3 ttop = r.invDir * (boxMax - r.o);\n\tvec3 tmin = min(ttop, tbot);\n\tvec3 tmax = max(ttop, tbot);\n\tvec2 t = max(tmin.xx, tmin.yz);\n\tfloat t0 = max(t.x, t.y);\n\tt = min(tmax.xx, tmax.yz);\n\tfloat t1 = min(t.x, t.y);\n\thit.tmin = t0;\n\thit.tmax = t1;\nreturn t1 > max(t0, 0.0);\n}\nvec4 trace(Ray ray, inout Hit hit) {\n\tvec3 center = vec3(0.0f);\n    float scale = 1.0f;\n\tvec3 minBox = center - scale;\n\tvec3 maxBox = center + scale;\n\tvec4 f = vec4(1.0f);\n    struct Stack {\n\t\tint index;\n\t\tvec3 center;\n\t\tfloat scale;\n\t};\n    Stack stack[10];\n    int stackPos = 1;\n    if (!BBoxIntersect(minBox, maxBox, ray, hit)) return f;\n    int index = 0;\n    scale *= 0.5f;\n    stack[0] = Stack( 0, center, scale   );\n    while(stackPos-- > 0) {\n        f = vec4(0.1f);\n        center = stack[stackPos].center;\n\t\tindex = stack[stackPos].index;\n\t\tscale = stack[stackPos].scale;\n        for (int i = 0; i < 8; ++i) {\n            vec3 new_center = center + scale * POS[i];\n            vec3 minBox = new_center - scale;\n            vec3 maxBox = new_center + scale;\n            if (!BBoxIntersect(minBox, maxBox, ray, hit)) continue;\n            int v = voxels[(index * 8)+i];\n            if (v == 0){\n                continue;\n            } else if (v < 0){\n                return vec4(1.0f,0.0f,0.0f,1.0f);\n            } else {\n            \tstack[stackPos++] = Stack( voxels[(index * 8) + i], new_center, scale*0.5f   );\n            \tf.z += 0.4f;\n                \n            }\n        }\n    }\n\treturn f;\n}\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.8);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n    vec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n\tvec3 rayPos = vec3(0.0, 0.25 * sin(iTime * 2.7), -3.4);\n    rayPos.xz = rotate2d(rayPos.xz, iTime);\n   \trayDir.xz = rotate2d(rayDir.xz, iTime);\n\tRay ray;\n\tHit hit;\n\tray.o = rayPos;\n\tray.d = rayDir;\n\tray.invDir = 1.0f/rayDir;\n\tvec4 color = trace(ray, hit);\n    if (length(color) > 0.5f) {\n     fragColor = color;\n\t}\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlBfRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdfXDr", "name": "RayMarching Cube", "author": "bluedrop", "description": "RayMarching Sphere and do mod operation \n学习后，来个中文的注释把，希望能帮到小伙伴\n写了个三维噪声，可是效率好低😭", "tags": ["3d", "raymarching"], "likes": 1, "viewed": 341, "date": "1564409958", "time_retrieved": "2024-06-20T19:40:02.640289", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n//到表面的阈值\n#define SURF_DIST .01    \n\nfloat N31(vec3 p)\n{\n\tvec3 n = p * vec3(235.24, 525.67, 937.84);\n    n += dot(n, n+ 53.56);\n    return fract(sin(n.x * n.y * n.z )*iTime);\n}\n\n\nfloat noise3(vec3 p)\n{\n    float res = 0.;\n    vec3 gv = fract(p);\n    vec3 id = floor(p);\n    \n    gv = gv * gv * (3.0 - 2.0 * gv);\n    \n    //front\n    float flb = N31(id);\n    float frb = N31(id + vec3(1., 0., 0.));\n    float fb = mix(flb, frb, gv.x);\n    \n    float flt = N31(id + vec3(0., 1., 0.));\n    float frt = N31(id + vec3(1., 1., 0.));\n    float ft = mix(flt, frt, gv.x);\n    \n    float front = mix(fb, ft, gv.y);\n\n    //back\n    float blb = N31(id + vec3(0,0,1));\n    float brb = N31(id + vec3(1., 0., 1.));\n    float bb = mix(blb, brb, gv.x);\n    \n    float blt = N31(id + vec3(0., 1., 1.));\n    float brt = N31(id + vec3(1., 1., 1.));\n    float bt = mix(blt, brt, gv.x);\n    \n    float back = mix(bb, bt, gv.y);\n    \n    res = mix(front, back, gv.z);\n    return res;\n}\n\nfloat dBox(vec3 p, vec3 s){\n\treturn length(max(abs(p)-s, 0.));\n}\n\nfloat GetDist(vec3 p){\n    //p.x = mod(p.x,2.)-1.;\n    //p.z = mod(p.z,10.)-1.;\n    //p.y = mod(p.y,6.)-0.;\n    vec4 sphere = vec4(0, 1.5, 6, .8);     //球体的数据，xyz是位置，w是半径\n    float sphereDist = length(p -sphere.xyz) - noise3(p) * 2.;     //当前步进位置到球表面的距离\n    float planeDist = p.y;                          //相机到平面的距离\n    float d = min(sphereDist, planeDist);      //获取最小的距离（也就是最近的物体）\n    //d = min(d, dBox(p-vec3(1,1.,7.), vec3(.7)));\n    return d;\n}\n\nfloat RayMarching(vec3 ro, vec3 rd){\n    float dod = 0.;\n    for(int i=0; i <MAX_STEPS; ++i){\n        vec3 p = ro + rd*dod;         //当前步进的位置\n        float r = GetDist(p);        //与场景中最近物体的距离\n        dod += r;                    //进行步进\n        if(dod >MAX_DIST || r < SURF_DIST)break;       \n    }\n    return dod;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n\t\tGetDist(p - e.yxy),\n        GetDist(p - e.yyx)\n    );\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3(cos(iTime)*2., 5.+sin(iTime)*2., 6);          //定义光源位置\n    vec3 l = normalize(lightPos - p);      //光到表面的标准向量\n    vec3 n = GetNormal(p);                   //获取表面法向量\n    float dif = clamp(dot(n, l),0.,1.);       //法向量与光向量点乘,背面的阴影会变成负数，要限制\n    float d = RayMarching(p+n*SURF_DIST*10.,l);\n    if(d < length(lightPos - p))dif *=.1;\n    return dif * 1.;\n}\n\n\n    \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord -.5*iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.);\n\n    //设置摄像机\n    vec3 ro = vec3(0., 4., -10.);  \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.)); \n    float d = RayMarching(ro, rd);\n\n    vec3 p = ro + rd * d;\n    float dif = GetLight(p);\n    col = vec3(dif);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdfXDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tl2GWz", "name": "Double Simplex Wang Weave", "author": "Shane", "description": "Applying Wang tile concepts to a double simplex weave.\n", "tags": ["triangle", "simplex", "truchet", "pattern", "tile", "wang", "weave"], "likes": 25, "viewed": 630, "date": "1562938268", "time_retrieved": "2024-06-20T19:40:06.913429", "image_code": "/*\n\n\n\tDouble Simplex Wang Weave\n\t-------------------------\n\n\tI don't know if I'd strictly refer to this as a Wang tile example, rather than \n\tapplying Wang tile concepts to BigWIngs's double simplex weave notion. Either way, \n\tthe resultant pattern is pretty unique.\n\n\tIn an overly general sense, modern Truchet tiling relies on rotational symmetry\n    (the original right triangle pattern did not), and as such require that any edge of \n\tone tile matches or connects with all edges of another. Wang tiles, on the other \n\thand, are edge specific (some edges don't match others), which allows for more \n\tinteresting variations.\n\n\tI'm sure most have heard of Wang tiles before. If not, they're well worth looking \n\tinto, since it's possible to do so many cool things with them. Almost all examples \n\tyou see involve quads rather than triangles. I'm not sure why, but I guess triangles \n\tare a little more difficult to work with, plus there'd be fewer edge combinations.\n\n\tHowever, if you make use of BigWIngs's double edge concept, you can increase the \n\tnumber of triangle edge combinations to create a visually rich weave pattern, but\n\twith haphazard sparse regions that are common to Wang tiling.\n\n\tIf you take a look at a double simplex Truchet weave (uncomment the NO_EDGE_MATCHING\n    define below), you'll see that every triangular tile is filled in and all contain\n\tthe same number of Bezier cords, resulting in a tight, dense pattern. However, when \n\tedge matching is applied, the number of Bezier cords vary from three to zero, thus \n    allowing regions of variable density and gaps to form, which breaks up the space.\n\n\tUltimately, applying the principles in this example to a 3D grid block would create \n\ta pretty crazy structure, and I'd definitly like to try that at some stage, but \n\tthis 2D pattern\twill have to suffice for now.\n\t\n\tAnyway, this is just one of so many different variations. The quad version would be\n\teasier to code up and, in my opinion, would look better -- I only went the simplex \n\troute because I wanted to provide code for a novel example that wouldn't be readily \n\taccessible. I also have some more traditional Wang related patterns that I intend \n\tto post at some stage, which should be much easier to digest.\n\n\n\t\n\tAdapted from:\n\n\tDouble Simplex Truchet Weave\n\thttps://www.shadertoy.com/view/3lB3Rc - Shane\n\n\tWhich was based on the following:\n\n\tDouble Triangle Truchet Doodle - BigWIngs\n\thttps://www.shadertoy.com/view/Ml2yzD\n\n\tLinks:\n\n\t// I searched high and low for a triangle-based Wang tile image, but couldn't find\n    // one, until Fabrice linked to something he did many years ago. Fabrice Neyret's\n    // name often pops up on papers when I'm looking for imagery. :)\n    //\n\t// https://hal.inria.fr/inria-00537511\n\n\n*/\n\n\n// Show the Wang edge connected lines. Not that exciting, but it's does illustrate the\n// most basic simplex Wang pattern.\n#define SHOW_WANG_EDGE_CONNECTIONS\n\n\n// Displaying the two color Wang regions for the simplex grid: Note that triangles on \n// neighboring edges share the same regional edge color. By the way, there are tri color, \n// quad color, etc, versions as well.\n//#define SHOW_WANG_REGIONS\n\n\n// Just the normal Truchet variation. In fact, if you compared it to my previous \n// Truchet version, the pattern should look exactly the same.\n//#define NO_EDGE_MATCHING\n\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Standard vec2 to float hash - Based on IQ's original.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.213, 289.197)))*43758.5453); }\n\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 a, vec2 b){\n     \n\tb = a - b;\n\tfloat h = clamp(dot(a, b)/dot(b, b), 0., 1.);\n    return length(a - b*h);\n}\n\n\n// IQ's signed distance to a 2D triangle.\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p ){\n\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  //p *= p*p*(p*(p*6. - 15.) + 10.);\n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n// Each triangle shares a unique edge midpoint with its neighbor, which means the \n// generated random number will be the same for that edge in either triangle. This\n// is important when connecting edge patterns in Wang tiles, etc.\nvec3 edges(vec2 id0, vec2 id1, vec2 id2){\n\n    // Return a unique random number for the midpoint of each triangle edge.\n    return vec3(hash21(mix(id0, id1, .5)), hash21(mix(id1, id2, .5)), hash21(mix(id2, id0, .5)));\n\n}\n\n// IQ's signed distance to a quadratic Bezier. Like all of IQ's code, it's quick \n// and reliable. :) Having said that, I've cut it down to suit this particular\n// example, so if you need the proper function, you should look at the original.\n//\n// Quadratic Bezier - 2D Distance - IQ\n// https://www.shadertoy.com/view/MlKcDD\n//\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){\n  \n    // p(t)    = (1 - t)^2*p0 + 2(1 - t)t*p1 + t^2*p2\n    // p'(t)   = 2*t*(p0 - 2*p1 + p2) + 2*(p1 - p0)\n    // p'(0)   = 2*(p1 - p0)\n    // p'(1)   = 2*(p2 - p1)\n    // p'(1/2) = 2*(p2 - p0)\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.*B + C;\n    vec2 c = a * 2.;\n    vec2 d = A - pos;\n\n    // If I were to make one change to IQ's function, it'd be to cap off the value \n    // below, since I've noticed that the function will fail with straight lines.\n    float kk = 1./max(dot(b,b), 1e-6); // 1./dot(b,b);\n    float kx = kk*dot(a,b);\n    float ky = kk*(2.*dot(a,a) + dot(d,b))/3.;\n    float kz = kk*dot(d,a);      \n\n    float res = 0.;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.*kx*kx - 3.*ky) + kz;\n    float h = q*q + 4.*p3;\n    \n    h = max(h, 0.);\n\n    //if(h >= 0.0){ \n     \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1./3.));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0., 1.);\n        //tm = t;\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    \n    /*}\n    else {\n    \n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n        \n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n        \n        //tm = res;//min(min(t.x, t.y), t.z);\n\n        res = sqrt( res );\n        \n        tm = res;\n    }\n    */\n    return res;\n}\n\n\n\n// Rendering the smooth Bezier segment. The idea is to calculate the midpoint\n// between \"a.xy\" and \"b.xy,\" then offset it by the average of the combined normals\n// at \"a\" and \"b\" multiplied by a factor based on the length between \"a\" and \"b.\"\n// At that stage, render a Bezier from \"a\" to the midpoint, then from the midpoint\n// to \"b.\" I hacked away to come up with this, which means there'd have to be a more\n// robust method out there, so if anyone is familiar with one, I'd love to know.\nfloat doSeg(vec2 p, vec4 a, vec4 b, float r){\n    \n    // Mid way point.\n    vec2 mid = (a.xy + b.xy)/2.; // mix(a.xy, b.xy, .5);\n    \n    // The length between \"a.xy\" and \"b.xy,\" multiplied by... a number that seemed\n    // to work... Worst coding ever. :D\n    float l = length(b.xy - a.xy)*1.732/6.; // (1.4142 - 1.)/1.4142;\n \n    // Points on the same edge each have the same normal, and segments between them\n    // require a larger arc. There was no science behind the decision. It's just \n    // something I noticed and hacked a solution for. Comment the line out, and you'll \n    // see why it's necessary. By the way, replacing this with a standard semicircular \n    // arc would be even better, but this is easier.\n    if(abs(length(b.zw - a.zw))<.01) l = r; \n  \n    // Offsetting the midpoint between the exit points \"a\" and \"b\"\n    // by the average of their normals and the line length factor.\n    mid += (a.zw + b.zw)/2.*l;\n\n    // Piece together two quadratic Beziers to form the smooth Bezier curve from the\n    // entry and exit points. The only reliable part of this method is the quadratic\n    // Bezier function, since IQ wrote it. :D\n    float b1 = sdBezier(p, a.xy, a.xy + a.zw*l, mid);\n    float b2 = sdBezier(p, mid, b.xy + b.zw*l, b.xy);\n\n    \n    // Return the minimum distance to the smooth Bezier arc.\n    return min(b1, b2);\n}\n\n\n// vec4 swap.\nvoid swap(inout vec4 a, inout vec4 b){ vec4 tmp = a; a = b; b = tmp; }\n\n// A swap without the extra declaration -- It works fine on my machine, but I'm\n// not game  enough to use it, yet. :)\n//void swap(inout vec4 a, inout vec4 b){ a = a + b; b = a - b; a = a - b; }\n\n\n// To be more succinct, it's a double simplex edge-matched weave pattern.\nvec3 pattern(vec2 p){\n    \n    \n    // Scaling constant.\n    const float gSc = 4.;\n    p *= gSc;\n    \n\t// Sampling and mixing one the textures, just for something to do.\n    //\n    // By the way, I wouldn't quote me on this, but I believe textures are stored in sRGB \n    // format -- I've never found this particularly helpful, but it is what it is. Anyway, \n    // this means the texels need to be converted to linear space (squaring the values is a \n    // rough appoximation) before working with them. The original texture values are restored \n    // to sRGB during gamma correction at the end (roughly taking the square root) before \n    // presenting to the screen.\n    //\n    vec3 tx = texture(iChannel0, p/gSc).xyz; tx *= tx;\n    vec3 tx2 = texture(iChannel0, p.yx/gSc*2.).xyz; tx2 *= tx2;\n    tx = mix(tx, tx2, .5);\n    \n    // Resolution based smoothing factor.\n    float sf = 1.5/iResolution.y*gSc;\n    \n    \n    // SIMPLEX GRID SETUP\n    \n    \n    vec2 s = floor(p + (p.x + p.y)*.36602540378); // Skew the current point.\n    \n    p -= s - (s.x + s.y)*.211324865; // Use it to attain the vector to the base vertex (from p).\n    \n    // Determine which triangle we're in. Much easier to visualize than the 3D version.\n    float i = p.x < p.y? 1. : 0.; // Apparently, faster than: i = step(p.y, p.x);\n    vec2 ioffs = vec2(1. - i, i);\n    \n    float dir = i<.5? -1.: 1.;\n    \n    // Vectors to the other two triangle vertices.\n    vec2 ip0 = vec2(0), ip1 = ioffs - .2113248654, ip2 = vec2(.577350269);\n    vec2 id0 = s, id1 = s + ioffs, id2 = s + 1.;\n    \n    // Make the vertices match up.\n    if(i>.5) { \n        vec2 tmp = ip0; ip0 = ip2; ip2 = tmp;\n        tmp = id0; id0 = id2; id2 = tmp;\n    }\n    \n    \n    // Centralize everything, so that vec2(0) is in the center of the triangle.\n    vec2 ctr = (ip0 + ip1 + ip2)/3.; // Centroid.\n    //\n    ip0 -= ctr; ip1 -= ctr; ip2 -= ctr; p -= ctr;\n    \n    \n    \n    \n    // Displaying the 2D simplex grid. Basically, we're rendering lines between\n    // each of the three triangular cell vertices to show the outline of the \n    // cell edges.\n    float tri = min(min(distLine(p - ip0, p - ip1), distLine(p - ip1, p - ip2)), \n                  distLine(p - ip2, p - ip0));\n    \n    /*\n    float div = 1e5;\n    div = min(div, distLine(p, p - mix(ip0, ip1, .5)));\n    div = min(div, distLine(p, p - mix(ip1, ip2, .5)));\n    div = min(div, distLine(p, p - mix(ip2, ip0, .5)));\n    */\n    \n    // The unique cell ID.\n    //vec2 uID = (s*3. + ioffs + 1.)/3.;\n    \n \n    // Obtaining a random number for each cell edge. It's important to to pass the \n    // vertex IDs to the \"edges\" function and not the vertex points like I did. :)\n    vec3 edge = edges(id0, id1, id2);\n    \n  \n     \n    #ifdef NO_EDGE_MATCHING\n    // A negative threshold means all curves and points are rendered.\n    const float tRnd = -1.; \n    #else\n    // This means there's a 30% chance that an edge will be empty, and thus,\n    // not used.\n    const float tRnd = .3;\n    #endif\n    \n    \n    // The cell edges ID.\n    float id = 0.;\n    \n    // This is a standard way to encode binary information into decimal form.\n    // If the random edge value is over a specific threshold, encode the correct\n    // binary digit.\n    if(edge.x>tRnd) id += 1.;\n    if(edge.y>tRnd) id += 2.;\n    if(edge.z>tRnd) id += 4.;\n    \n    // Decode each binary digit.\n    vec3 bits = mod(floor(id/vec3(1, 2, 4)), 2.);\n\n    \n    // Connecting points around the triangles. Two for each side. I should probably\n    // use a bit of trigonometry and hard code these, but I was feeling lazy. :)\n    const float offs = .204124; // Approx: length(ip0 - ip1)/4., or sqrt(1./24.);\n    vec2 m01s = mix(ip0, ip1, .5 + offs);\n    vec2 m01t = mix(ip0, ip1, .5 - offs);\n    vec2 m12s = mix(ip1, ip2, .5 + offs);\n    vec2 m12t = mix(ip1, ip2, .5 - offs);\n    vec2 m20s = mix(ip2, ip0, .5 + offs);\n    vec2 m20t = mix(ip2, ip0, .5 - offs);\n    \n    // The boundary normals for each point. I should probably hardcode these as well.\n    vec2 n01 = -normalize(mix(ip0, ip1, .5));\n    vec2 n12 = -normalize(mix(ip1, ip2, .5));\n    vec2 n20 = -normalize(mix(ip2, ip0, .5));\n\n        \n   \n    // Line variable. One for each edge.\n    vec3 rLn = vec3(1e5);\n  \n    \n    // Array index. It increases by two for every extra Bezier segment and pair of \n    // end points needed. See below.\n    int index = 0;\n    \n    // The actual points: The idea is to only add the necessary points to the array, \n    // depending on how many edges line up, which would be 0, 1, 2, or all 3. \n    // However, just in case my logic isn't up to scratch, I'll zero them all out, \n    // just to be on the safe side.\n    //\n    // Each edge corresponds to two entry and exit points. These have to be shuffled\n    // to produce the random weave you see, so it's necessary to keep track of the\n    // the maximum array count. Variable array counts are possible in WebGL 2.0, but\n    // I'd like to try to keep things backward compatible, etc.\n    vec4[6] pnt = vec4[6](vec4(0), vec4(0), vec4(0), vec4(0), vec4(0), vec4(0));\n    \n    // If the first binary digit is flagged (one, not zero), fill in the point \n    // information for the first two array spots, construct an edge, then increase the \n    // index by two.\n    if(bits.x>.5){\n        \n        // Adding the point and normal information for this particular edge, to be\n        // shuffled first, then passed to the Bezier cord construction formula.\n        pnt[index] = vec4(m01s, n01);\n        pnt[index + 1] = vec4(m01t, n01);\n        index += 2;\n        \n        // If the digit is a one, construct an edge from the cell's center to\n        // the corresponding edge midpoint.\n        rLn.x = min(rLn.x, distLine(p, p - mix(ip0, ip1, .5)));\n        \n    }    \n    \n    // Do the same for the second binary digit.\n    if(bits.y>.5){\n        \n        pnt[index] = vec4(m12s, n12);\n        pnt[index + 1] = vec4(m12t, n12);\n        index += 2;\n        \n        rLn.y = min(rLn.y, distLine(p, p - mix(ip1, ip2, .5)));\n        \n    }\n    \n    // Third binary digit.\n    if(bits.z>.5){\n        \n        pnt[index] = vec4(m20s, n20);\n        pnt[index + 1] = vec4(m20t, n20);\n        index += 2;\n        \n        rLn.z = min(rLn.z, distLine(p, p - mix(ip2, ip0, .5)));\n        \n    }\n    \n    // Combine all edges, and give it a thickness.\n    float ln = min(min(rLn.x, rLn.y), rLn.z) - .02;\n    \n    \n    // If lines need to be rendered, render a circle in the middle of the cell,\n    // for decorative purposes.\n    if(index>0) ln = min(ln, abs(length(p) - .05) - .02);\n    \n    // Shuffling the variable array of points and normals -- Six is the maximum. I think this \n    // is the Fisher–Yates method, but don't quote me on it. It's been a while since I've used \n    // a shuffling algorithm, so if there are inconsistancies, etc, feel free to let me know.\n    //\n    // For various combinatorial reasons, some non overlapping tiles will probably be \n    // rendered more often, but generally speaking, the following should suffice.\n    //\n    for(int i = 5; i>0; i--){\n        \n        // For less than three edges, skip the upper array positions.\n        if(i >= index) continue;\n        \n        // Using the cell ID and shuffle number to generate a unique random number.\n        float fi = float(i);\n        \n        // Random number for each triangle: The figure \"s*3 + ioffs + 1\" is unique for\n        // each triangle... I can't remember why I felt it necessary to divide by 3,\n        // but I'll leave it in there. :)\n        float rs = hash21((s*3. + ioffs + 1.)/3. + fi/float(index));\n        \n        // Other array point we're swapping with.\n        //int j = int(floor(mod(rs*float(index)*1e6, fi + 1.)));\n        // I think this does something similar to the line above, but if not, let us know.\n        int j = int(floor(rs*(fi + .9999)));\n        swap(pnt[i], pnt[j]);\n        \n    } \n    \n    // Constructing the Bezier cords for the cell, and the exit and entry points\n    // for each cord.\n    vec3 d = vec3(1e5), pnts = vec3(1e5);\n    \n    for(int i = 0; i<3; i++){\n        \n        // Skip when the index isn't high enough. In other words, if there are\n        // only two points for the cell (one cord), break after the first \n        // iteration, etc.\n        if(index<(i*2+1)) break;\n        \n        // Marking the exit and entry points with some dots, for illustrative\n        // and decorative purposes.\n        pnts[i] = min(pnts[i], length(p - pnt[i*2].xy));\n        pnts[i] = min(pnts[i], length(p - pnt[i*2 + 1].xy));\n        \n        // Contruct the Bezier segment between the two random edge points.\n        d[i] =  doSeg(p,  pnt[i*2], pnt[i*2 + 1], offs);\n       \n    }\n    \n    // Give the end points and Bezier segments some width.\n    pnts -= .045;\n    d -= .1;\n    \n    \n    \n    // Initiate the scene color to the Shadertoy texture.\n    vec3 col = tx;\n     \n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, tri - .0025)));\n\n    // Concentric triangular pattern, for decorative purposes. \n    // The following are interesting too: min(tri, div), max(tri, div).\n    float pat = sin(tri*6.2831*24. + 3.14159*.75) + .8; \n\n    \n    // Blurred connecting cell lines for fake shadows. Uncomment to see what it does.\n    col *= smoothstep(0., sf*12., ln - .15)*.25 + .75;\n\n    // Using the connecting lines to fade the concentric triangular pattern -- The step is\n    // not important, and just something I made up on the spot. A few days from now, even\n    // I wouldn't know that it does. :D\n    pat = max(pat, smoothstep(0., sf*12., ln - .15)*.75);\n    //\n    // Blending in the pattern. I think it's shorthand for the line below:\n    // col = mix(col, vec3(0), 1. - pat);\n    col *= pat;  \n   \n    \n    \n    // Bezier line color.\n    vec3 lCol = tx*4.;\n    \n    // Bezier stripe color.\n    vec3 stCol = mix(lCol, vec3(1.3, 1, .7), .75);\n\n    // Saving the background color for later usage.\n    vec3 tmp = col;\n    \n    \n\t#ifdef SHOW_WANG_REGIONS\n    \n    d += 1e5; // A hacky way to take away the weave pattern.\n    pnts += 1e5; // Same for the Bezier curve end points.\n    \n    //vec3 eRnd = vec3(hash21(mix(id0, id1, .5)), hash21(mix(id1, id2, .5)), hash21(mix(id2, id0, .5)));\n    //vec3 edgeDot = vec3(length(p - mix(ip0, ip1, .5)), length(p - mix(ip1, ip2, .5)), \n    //                    length(p - mix(ip2, ip0, .5)) );   \n    //edgeDot -= .06;\n\n    \n    // Using IQ's 2D triangle formula to constract the triangular edge region.\n    vec3 wTri = vec3(sdTriangle(vec2(0), ip0, ip1, p), sdTriangle(vec2(0), ip1, ip2, p), \n                       sdTriangle(vec2(0), ip2, ip0, p));   \n    // Shrinking the triangle a bit.\n    wTri += .005;\n    \n     \n    for(int i = 0; i<3; i++){\n        \n        // Random colored dots. Not used here.\n        //vec3 dCol = 1.-vec3(1, 1. - eRnd[i], eRnd[i]*.25).zyx;\n        \n        // Brown regions represent empty regions, and green regions \n        // represent regions where connections are rendered.\n        vec3 fCol = mix(tmp, vec3(1, .8, 0), .75);\n        if(bits[i]>.5) fCol = mix(tmp, vec3(.5, 1, .1), .75);//\n    \n\n        // Render the colored Wang region for this particular edge.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*3., wTri[i] - .02))*.5);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, wTri[i] - .02)));\n        col = mix(col, fCol*fCol*1.8, (1. - smoothstep(0., sf, wTri[i])));\n        \n        /*   \n        // Edge dots: Not used here.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*6., edgeDot[i] - .02))*.5);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, edgeDot[i] - .02)));\n        col = mix(col, fCol, (1. - smoothstep(0., sf, edgeDot[i])));\n        */\n    }\n    \n    \n    \n    // Render the white triangular cell edges.    \n    tri -= .02;\n    \n    float vrts = min(min(length(p - ip0), length(p - ip1)), length(p - ip2)); // Vertices.\n    tri = min(tri, abs(vrts - .06) - .02);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*6., tri - .02))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, tri - .02)));\n    col = mix(col, mix(tmp*2., vec3(1.25), .75), (1. - smoothstep(0., sf, tri + .0025)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, tri + .02)));\n \n    #endif\n    \n   \n    #ifdef SHOW_WANG_EDGE_CONNECTIONS\n    // Lay down the edge connections. I made them blue to contrast with the brown.\n    vec3 cCol = mix(tmp*2., vec3(.3, .8, 1.25), .75);\n    //cCol = cCol.xzy; // Green, etc.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*6., ln - .02))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, ln - .02)));\n    col = mix(col, cCol, (1. - smoothstep(0., sf, ln + .0025)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, ln + .02)));\n    #endif\n    \n    #ifndef SHOW_WANG_REGIONS\n    for(int i = 0; i<3; i++){\n        \n        // Only render as many edge connecting points, Beziers, etc, as needed. It's not\n        // absolutely necessary, but I guess it'd save a few cycles... Although, on GPUs,\n        // it'd difficult to know for sure. :)\n        if(i>=index/2) break;\n        \n        // Save the underlying color.\n        tmp = col;\n      \n        // Shading. Not used.\n        //float sh = max(-(d[i]+.02)*64., 0.);\n        \n        // Render the Bezier shadows, edges, etx.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*6., d[i] - .02))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, d[i]));\n        col = mix(col, lCol, 1. - smoothstep(0., sf, d[i]+.02));\n         \n        // The white stripe down the center.\n        float divLn = d[i] + .06; // max(d[i] - .01, tri - .03);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., divLn))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, divLn));\n        col = mix(col, mix(tmp, stCol*1.5, .75), (1. - smoothstep(0., sf, divLn + .02)));\n        \n        // Render some rivets at the cell boundary end points of the Beziers, for\n        // illustrative and decorative purposes.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., pnts[i] - .01))*.35);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnts[i]));\n        col = mix(col, mix(lCol, vec3(1), .65), 1. - smoothstep(0., sf, pnts[i] + .02));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(pnts[i] + .035) - .005));\n     \n    }\n    #endif\n   \n    \n    // Return the pattern color.\n    return col;\n    \n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates. Setting a minumum resolution on the\n    // fullscreen setting in an attempt to keep things relatively crisp.\n    float res = min(iResolution.y, 700.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/res;\n \n    // Rotation and translation of the scene.\n    vec2 p = rot2(3.14159/12.)*uv + vec2(1, .5)*iTime/10.;\n\n    // The double simplex Wang weave pattern.\n    vec3 col = pattern(p);\n    \n    // A bit of subtle noise-based color to break up the brown a little.\n    col = mix(col, col.xzy, (n2D(p*4.)*.67 + n2D(p*8.)*.33)*.5);\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n    // Colored variation.\n    //col = mix(col.xzyw, col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625));\n\n\n    // Rough gamma correction, then output to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tl2GWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlfSD4", "name": "Radquad", "author": "xor0110", "description": "Each channel is a quadratic of revolution: the sphere and the hyperboloids of 1 and 2 leaves. #revolution", "tags": ["quadrics", "surfaceofrevolution"], "likes": 2, "viewed": 131, "date": "1562882033", "time_retrieved": "2024-06-20T19:40:06.913429", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y - 0.5;\n    uv.x -= 0.4;\n    \n    float col1 = 0.0+0.9*sqrt(1.0 - (sin(1.0+0.8*iTime)*3.0+6.5)*(uv.x*uv.x + uv.y*uv.y)); // sphere\n    float col2 = 2.0-1.0*sqrt(1.0 + (sin(3.0*iTime)+3.0)*(uv.x*uv.x + uv.y*uv.y)); // hyp2\n    float col3 = 0.0+0.3*sqrt(-1.0 + (4.0*cos(iTime)+16.0)*(uv.x*uv.x + uv.y*uv.y)); // hyp1\n\n    // Output to screen\n    fragColor = vec4((0.5+0.5*sin(iTime))*col3,(0.5+0.5*cos(iTime))*col2,col1,1.0);\n}\n\n// Thanks Flopine for the inspiration!", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlfSD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlfSDB", "name": "Mandelbrot Set Zoom Animation", "author": "BigETI", "description": "This shader zooms in and out inside a mandelbrot set.", "tags": ["julia", "mandelbrot", "set"], "likes": 3, "viewed": 362, "date": "1564073508", "time_retrieved": "2024-06-20T19:40:06.913429", "image_code": "vec2 complexMultiplication(in highp vec2 left, in highp vec2 right)\n{\n    return vec2((left.x * right.x) - (left.y * right.y), (left.x * right.y) + (left.y * right.x));\n}\n\nfloat sqrMagnitude(in highp vec2 z)\n{\n    return (z.x * z.x) + (z.y * z.y);\n}\n\nvec2 complexPower(in highp vec2 left, in highp vec2 right)\n{\n    float magnitude_squared = sqrMagnitude(left);\n    float l = pow(magnitude_squared, right.x * 0.5) * exp(-right.y * atan(left.y, left.x));\n    float r = (right.x * atan(left.y, left.x)) + (0.5 * right.y * log(magnitude_squared));\n    return vec2(l * cos(r), l * sin(r));\n}\n\nvec3 julia(in highp vec2 position, highp float power)\n{\n    highp vec2 z = vec2(0.0, 0.0);\n    const vec3 colors[30] = vec3[30]\n    (\n        vec3(0.1, 0.0, 0.9),\n        vec3(0.2, 0.0, 0.8),\n        vec3(0.3, 0.0, 0.7),\n        vec3(0.4, 0.0, 0.6),\n        vec3(0.5, 0.0, 0.5),\n        vec3(0.6, 0.0, 0.4),\n        vec3(0.7, 0.0, 0.3),\n        vec3(0.8, 0.0, 0.2),\n        vec3(0.9, 0.0, 0.1),\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.9, 0.1, 0.0),\n        vec3(0.8, 0.2, 0.0),\n        vec3(0.7, 0.3, 0.0),\n        vec3(0.6, 0.4, 0.0),\n        vec3(0.5, 0.5, 0.0),\n        vec3(0.4, 0.6, 0.0),\n        vec3(0.3, 0.7, 0.0),\n        vec3(0.2, 0.8, 0.0),\n        vec3(0.1, 0.9, 0.0),\n        vec3(0.0, 1.0, 0.0),\n        vec3(0.0, 0.9, 0.1),\n        vec3(0.0, 0.8, 0.2),\n        vec3(0.0, 0.7, 0.3),\n        vec3(0.0, 0.6, 0.4),\n        vec3(0.0, 0.5, 0.5),\n        vec3(0.0, 0.4, 0.6),\n        vec3(0.0, 0.3, 0.7),\n        vec3(0.0, 0.2, 0.8),\n        vec3(0.0, 0.1, 0.9),\n        vec3(0.0, 0.0, 1.0)\n    );\n    for (int i = 0, j; i < 1024; i++)\n    {\n        z = complexPower(z, vec2(power, 0.0)) + position;\n        if (sqrMagnitude(z) > 4.0)\n        {\n            return colors[i % colors.length()];\n        }\n    }\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    bool reverse = false;\n    const float max_zoom = 16.0;\n    while (time >= max_zoom)\n    {\n        time -= max_zoom;\n        reverse = !reverse;\n    }\n    time = (reverse ? (max_zoom - time) : time);\n    float zoom = exp(time) * 0.75;\n    vec2 start_center = vec2(0.0, 0.0);\n    vec2 target_center = vec2(-0.745428, 0.113009);\n    float t = clamp(time, 0.0, 1.0);\n    vec2 center = mix(start_center, target_center, t);\n    float power = 2.0;\n    vec2 position = vec2((((fragCoord.x * 3.0 / iResolution.x) - 2.0) / zoom) + center.x, (((fragCoord.y * 2.0 / iResolution.y) - 1.0) / zoom) + center.y);\n    vec2 position_offset = vec2(((((fragCoord.x + 0.5) * 3.0 / iResolution.x) - 2.0) / zoom) + center.x, ((((fragCoord.y + 0.5) * 2.0 / iResolution.y) - 1.0) / zoom) + center.y) - position;\n    vec3 color = julia(position, power);\n    vec3 sum_sub_colors =\n        julia(vec2(position.x + position_offset.x, position.y), power) +\n        julia(vec2(position.x - position_offset.x, position.y), power) +\n        julia(vec2(position.x, position.y + position_offset.y), power) +\n        julia(vec2(position.x, position.y - position_offset.y), power) +\n        julia(vec2(position.x + position_offset.x, position.y + position_offset.y), power) +\n        julia(vec2(position.x - position_offset.x, position.y + position_offset.y), power) +\n        julia(vec2(position.x + position_offset.x, position.y - position_offset.y), power) +\n        julia(vec2(position.x - position_offset.x, position.y - position_offset.y), power);\n    fragColor = vec4(vec3(sum_sub_colors.x * 0.0625, sum_sub_colors.y * 0.0625, sum_sub_colors.z * 0.0625) + vec3(color.x * 0.5, color.y * 0.5, color.z * 0.5), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlfSDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlfSRs", "name": "task2_test", "author": "Lily068", "description": "an elf which used as a model", "tags": ["raytracing"], "likes": 1, "viewed": 76, "date": "1563897487", "time_retrieved": "2024-06-20T19:40:10.289399", "image_code": "//============================================================================\n// PROJECT ID:\n//\n// GROUP NUMBER:\n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// COMMENTS TO GRADER: \n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at http://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 3;\nconst int NUM_PLANES = 2;\nconst int NUM_SPHERES = 13;\nconst int NUM_CONES = 5;\n\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n // Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0; \n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Cone_t {\n\t// Half angle\n\tfloat cosa;\n\t// Height\n\tfloat h;\n\t// Tip position\n\tvec3 c;\n\t// Axis\n\tvec3 v;\n\tint materialID;\n};\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of \n// Lecture 11 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS { \n//                   I_a * k_a + \n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nCone_t Cone[NUM_CONES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 2.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n\n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 4.5;\n    Plane[1].materialID = 0;\n\n    // HEAD\n    Sphere[0].center = vec3( 0.0, 0.5*abs(sin(2.0 * iTime)) + 2.0, 0.0 );\n    Sphere[0].radius = 0.3;\n    Sphere[0].materialID = 1;\n\n    //BODY\n    Cone[0].cosa=0.95;\n    Cone[0].h=1.0;\n    Cone[0].c=Sphere[0].center - vec3(0.0,Sphere[0].radius,0.0);\n    Cone[0].v=normalize(vec3(0.0,-1.0,0.0));\n    Cone[0].materialID=1;\n    \n    //ARM\n    Cone[1].cosa=0.995;\n    Cone[1].h=Cone[0].h*0.6;\n    Cone[1].c= Cone[0].c-vec3(0.0,0.2,0.0);\n    Cone[1].v=normalize(vec3(1.0,-0.1-abs(sin(2.0 * iTime)),0.0));\n    Cone[1].materialID=1;\n    \n    Cone[2].cosa= Cone[1].cosa;\n    Cone[2].h=Cone[1].h;\n    Cone[2].c=Cone[1].c;\n    Cone[2].v=normalize(vec3(-Cone[1].v.x,Cone[1].v.y,Cone[1].v.z));\n    Cone[2].materialID=Cone[1].materialID;\n    \n    //HAND\n    Sphere[1].center = vec3(Cone[1].h, Cone[0].c.y-0.28, 0.0 );\n    Sphere[1].center = vec3(Cone[1].c.x,Cone[1].c.y,Cone[1].c.z)+Cone[1].h*Cone[1].v;;\n    Sphere[1].radius = 0.07;\n    Sphere[1].materialID = 1;\n    \n    Sphere[2].center = vec3(-Sphere[1].center.x,Sphere[1].center.y,Sphere[1].center.z);\n    Sphere[2].radius = Sphere[1].radius;\n    Sphere[2].materialID = Sphere[1].materialID;\n    \n    //LEG\n    \n    Cone[3].cosa= 0.99;\n    Cone[3].h=Cone[0].h*0.7;\n    Cone[3].c=vec3(0.1,Cone[0].c.y-Cone[0].h,0.0);\n    Cone[3].v=normalize(vec3(0.0+abs(sin(2.0 * iTime)),-1.0,0.0));\n    Cone[3].materialID=Cone[1].materialID;\n    \n    Cone[4].cosa= Cone[3].cosa;\n    Cone[4].h=Cone[3].h;\n    Cone[4].c=vec3(-Cone[3].c.x,Cone[3].c.y,Cone[3].c.z);\n    Cone[4].v= vec3(-Cone[3].v.x,Cone[3].v.y,Cone[3].v.z);\n    Cone[4].materialID=Cone[1].materialID;\n    \n    //FOOT\n    Sphere[3].center = vec3(Cone[3].c.x,Cone[3].c.y,Cone[3].c.z)+Cone[3].h*Cone[3].v; \n    Sphere[3].radius = 0.1;\n    Sphere[3].materialID = 1;\n    \n    Sphere[4].center = vec3(-Sphere[3].center.x,Sphere[3].center.y,Sphere[3].center.z);\n    Sphere[4].radius = Sphere[3].radius;\n    Sphere[4].materialID = 1;\n    \n   \n \n   \n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Gold material.\n    Material[1].k_d = vec3( 0.8, 0.7, 0.1 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n    // Green plastic material.\n    Material[2].k_d = vec3( 0.0, 0.8, 0.0 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n\n    // Light 0.\n    Light[0].position = vec3( 4.0, 8.0, -3.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    // Light 1.\n    Light[1].position = vec3( -4.0, 8.0, 0.0 );\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    // A vector from ray origin  towards sphere center.\n    vec3 OriginToCenter = sph.center - ray.o;\n    // Compute the length of tangent.(square)\n    float SquareT = dot(OriginToCenter, OriginToCenter) - sph.radius * sph.radius;\n    float DdotV = dot(ray.d, OriginToCenter);\n\n    // One side which has the sphere.\n    if (DdotV >= 0.0) {\n        // When the ray shoots towards the sphere\n        float discr = DdotV * DdotV - SquareT;\n        // If it is bigger than the length of tangent, it has intersects.\n        if (discr >= 0.0) \n        {\n            // Smaller intersection point.\n            t = DdotV - sqrt(discr);\n            hitPos = ray.o + t * ray.d;\n            hitNormal = normalize(hitPos - sph.center);\n            return (t >= tmin && t<= tmax);\n        }\n    }\n    return false;\n\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    // A vector from ray origin  towards sphere center.\n    vec3 OriginToCenter = sph.center - ray.o;\n    // Compute the length of tangent.(square)\n    float SquareT = dot(OriginToCenter, OriginToCenter) - sph.radius * sph.radius;\n    float DdotV = dot(ray.d, OriginToCenter);\n\n    // One side which has the sphere.\n    if (DdotV >= 0.0) {\n        // When the ray shoots towards the sphere\n        float discr = DdotV * DdotV - SquareT;\n        // If it is bigger than the length of tangent, it has intersects.\n        if (discr >= 0.0) \n        {\n            // Need to compare both intersection points\n            float t1 = DdotV - sqrt(discr);\n            float t2 = DdotV + sqrt(discr);\n            return ((t1 >= tmin && t1<= tmax) || (t2 >= tmin && t2 <= tmax));\n        }\n    }\n    return false;\n\n}\n\n// Computes intersection between a cone and a ray.\nbool IntersectCone( in Cone_t cone, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 co = ray.o - cone.c;\n\n    float a = dot(ray.d, cone.v)*dot(ray.d, cone.v) - cone.cosa * cone.cosa;\n    float b = 2. * (dot(ray.d, cone.v) * dot(co, cone.v) - dot(ray.d, co) * cone.cosa * cone.cosa);\n    float c = dot(co, cone.v) * dot(co, cone.v) - dot(co, co) * cone.cosa * cone.cosa;\n\n    float det = b * b - 4. * a * c;\n    if (det < 0.) return false;\n\n    det = sqrt(det);\n    float t1 = (-b - det) / (2. * a);\n    float t2 = (-b + det) / (2. * a);\n\n    t = t1;\n    if (t < 0. || t2 > 0. && t2 < t) t = t2;\n    if (t < 0.) return false;\n\n    vec3 cp = ray.o + t * ray.d - cone.c;\n    float h = dot(cp, cone.v);\n    if (h < 0. || h > cone.h) return false;\n\n    hitPos = ray.o + t * ray.d;\n    hitNormal = normalize(cp * dot(cone.v, cp) / dot(cp, cp) - cone.v);\n\n    return (t >= tmin && t<= tmax);\n}\n\n// Computes intersection between a cone and a ray for shadow ray intersection.\nbool IntersectCone( in Cone_t cone, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 co = ray.o - cone.c;\n\n    float a = dot(ray.d, cone.v)*dot(ray.d, cone.v) - cone.cosa * cone.cosa;\n    float b = 2. * (dot(ray.d, cone.v) * dot(co, cone.v) - dot(ray.d, co) * cone.cosa * cone.cosa);\n    float c = dot(co, cone.v) * dot(co, cone.v) - dot(co, co) * cone.cosa * cone.cosa;\n\n    float det = b * b - 4. * a * c;\n    if (det < 0.) return false;\n\n    det = sqrt(det);\n    float t1 = (-b - det) / (2. * a);\n    float t2 = (-b + det) / (2. * a);\n\n    float t = t1;\n    if (t < 0. || t2 > 0. && t2 < t) t = t2;\n    if (t < 0.) return false;\n    vec3 cp = ray.o + t * ray.d - cone.c;\n    float h = dot(cp, cone.v);\n    if (h < 0. || h > cone.h) return false;\n\n    return (t >= tmin && t<= tmax);\n}\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a + \n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray, \n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg ) \n{\n    // Find whether and where the ray hits some object. \n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    for (int curSphere = 0; curSphere < NUM_SPHERES; curSphere++ ) \n    {\n        // Try intersecting input rays with all the spheres.\n        temp_hasHit = IntersectSphere(Sphere[curSphere], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n                      temp_t, temp_hitPos, temp_hitNormal);\n\n        // If intersect with spheres, compare and find the nearest.\n        if (temp_hasHit && temp_t < nearest_t) \n        {\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Sphere[curSphere].materialID;\n        }\n        \n    }\n\n    for (int curPlane = 0; curPlane < NUM_PLANES; curPlane++ ) \n    {\n        // Try intersecting input rays with all the planes..\n        \n        temp_hasHit = IntersectPlane(Plane[curPlane], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n                      temp_t, temp_hitPos, temp_hitNormal);\n\n        // If intersect with planes, compare with the nearest of the sphere and then find the nearest.\n        if (temp_hasHit && temp_t < nearest_t) \n        {\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Plane[curPlane].materialID;\n        }\n        \n    }\n    \n    for (int curCune = 0; curCune < NUM_CONES; curCune++ ) {\n    \t// Try intersect with cones\n    \t// Use nearest_t as input tmax to determine whether the intersection point\n    \t//with planes is the nearest\n    \ttemp_hasHit = IntersectCone(Cone[curCune], ray, DEFAULT_TMIN, nearest_t,\n                      temp_t, temp_hitPos, temp_hitNormal);\n\n    \t// If hit, then now the hit point is nearer than spheres if any\n    \tif (temp_hasHit && temp_t < nearest_t ) {\n    \t\thasHitSomething = true;\n    \t\tnearest_t = temp_t;\n    \t\tnearest_hitPos = temp_hitPos;\n    \t\tnearest_hitNormal = temp_hitNormal;\n    \t\tnearest_hitMatID = Cone[curCune].materialID;\n    \t}\n    \t\n    }\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point. \n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the \n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    // Compute lighting for each lights\n    Ray_t ShadowRay[NUM_LIGHTS];\n    bool inshadow[NUM_LIGHTS];\n    for (int curLight = 0; curLight < NUM_LIGHTS; curLight++ ) \n    {\n        // Make a shadow ray (from surface to light) for each light\n        ShadowRay[curLight].o = nearest_hitPos;\n        ShadowRay[curLight].d = normalize(Light[curLight].position - ShadowRay[curLight].o);\n\n        for (int curSphere = 0; curSphere < NUM_SPHERES; curSphere++ ) \n        {\n            // If already in shadow, inshadow[curLight] becomes inaccessible\n            if(!inshadow[curLight]) \n            {\n                // The point is in shadow if the shadow ray intersects with anything.\n                inshadow[curLight] = IntersectSphere(Sphere[curSphere], ShadowRay[curLight], DEFAULT_TMIN, \n                distance(nearest_hitPos, Light[curLight].position));\n            }\n        }\n        // If not, consider intersection with planes.\n        if (!inshadow[curLight]) \n        {\n            for(int curPlane = 0; curPlane < NUM_PLANES; curPlane++ ) \n            {\n                // If already in shadow, inshadow[curLight] becomes inaccessible.\n                if(!inshadow[curLight]) \n                {\n                    inshadow[curLight] = IntersectPlane(Plane[curPlane], ShadowRay[curLight], DEFAULT_TMIN, \n                    distance(nearest_hitPos, Light[curLight].position));\n                }\n            }\n        }\n        if (!inshadow[curLight]) \n        {\n            for(int curCone = 0; curCone < NUM_PLANES; curCone++ ) \n            {\n                // If already in shadow, inshadow[curLight] becomes inaccessible.\n                if(!inshadow[curLight]) \n                {\n                    inshadow[curLight] = IntersectCone(Cone[curCone], ShadowRay[curLight], DEFAULT_TMIN, \n                    distance(nearest_hitPos, Light[curLight].position));\n                }\n            }\n        }\n\n        // Call PhongLighting() to compute lighting for this light source.\n        I_local += PhongLighting( ShadowRay[curLight].d, nearest_hitNormal, - ray.d, inshadow[curLight], \n            Material[nearest_hitMatID], Light[curLight] );\n    }\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    vec3 cam_pos = vec3( 2.5, 1.0, 2.5 );\n    vec3 cam_lookat = vec3( 0.25, 1.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ ) \n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlfSRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlfSWB", "name": "amiga rubbervector", "author": "cdyk", "description": "'rubber vector' is an old-school amiga demo-effect was produced by using older frames the further down you were on the screen (easy with copper).  Here, I just increment the animation time using y-scanline, but the result is quite similar. ", "tags": ["amiga", "rasterize"], "likes": 5, "viewed": 194, "date": "1564055649", "time_retrieved": "2024-06-20T19:40:11.016788", "image_code": "// 'Rubber vector' is an old-school demo effect, which was produced by\n// keeping a tail of frames and displaying older frames the further down\n// on the screen.\n//\n// While experimenting with implementing triangle rasterization in ShaderToy,\n// I thought about this, and implemented it by adjusting time using the\n// Y-component of the screen space position.\n\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    float x = axis.x;\n    float y = axis.y;\n    float z = axis.z;\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat4(\n        x*x*(1.0-c) +   c, y*x*(1.0-c) + z*s, x*z*(1.0-c) - y*s, 0,\n        x*y*(1.0-c) - z*s, y*y*(1.0-c) +   c, y*z*(1.0-c) + x*s, 0,\n        y*z*(1.0-c) + y*s, y*z*(1.0-c) - x*s, z*z*(1.0-c) +   c, 0,\n        0,                                 0,                 0, 1\n\t);\n}\n\nmat4 translationMatrix(vec3 o)\n{\n    return mat4(\n        1, 0, 0, 0,\n        0, 1, 0, 0, \n        0, 0, 1, 0,\n        o.x, o.y, o.z, 1\n    );\n}\n    \n\nmat4 frustumMatrix(float l, float r, float b, float t, float n, float f)\n{\n    return mat4(\n        2.0*n/(r-l), 0, 0, 0,\n        0, 2.0*n/(t-b), 0, 0,\n        (r+l)/(r-l), (t+b)/(t-b), -(f+n)/(f-n), -1,\n        0, 0, -2.0*f*n/(f-n), 0\n    );\n}\n\n\nfloat cross2(vec2 a, vec2 b)\n{\n\treturn cross(vec3(a, 0), vec3(b, 0)).z;   \n}\n\nvoid rasterizeTriangle(inout float depth,\n                       inout vec3 normal,\n                       in vec4 a, in vec4 b, in vec4 c,\n                       in vec2 p,\n                       in vec3 n)\n{\n    vec2 ab = b.xy - a.xy;\n    vec2 bc = c.xy - b.xy;\n    vec2 ca = a.xy - c.xy;\n    \n    vec2 ap = p - a.xy;\n    vec2 bp = p - b.xy;\n    vec2 cp = p - c.xy;\n    \n    // Back-face culling\n    float area_abc = cross2(ab, bc);\n    if(area_abc <= 0.0) return;\n\n    // Point-in-triangle test\n    float area_abp = cross2(ab, bp);\n    float area_bcp = cross2(bc, cp);\n    float area_cap = cross2(ca, ap);\n    if(area_abc <= 0.0 || area_abp < 0.0 || area_bcp < 0.0 || area_cap < 0.0) return;\n    \n    // shape is convex and backface culled, so we don't need depth beyond flagging\n    // that it is not background.\n    depth = 0.0;\n    normal = n;\n}\n\nvec4 perspectiveDivide(vec4 h)\n{\n    return (1.0/h.w)*vec4(h.xyz, 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*fragCoord/iResolution.xy - vec2(1);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float t = iTime + sin(iTime)*uv.y;\n    \n    mat4 M =\n        rotationMatrix(vec3(0,0,1), 0.3*t) *\n        rotationMatrix(vec3(0,1,0), 0.7*t) *\n        rotationMatrix(vec3(0,0,1), 1.1*t);\n\n    float aspect = iResolution.x/iResolution.y;\n    mat4 P =\n        frustumMatrix(-0.2*aspect, 0.2*aspect,\n                      -0.2,  0.2,\n                       0.2, 30.0) *\n        translationMatrix(vec3(0,0,-2.5));\n        \n    \n    mat4 PM = P * M;\n    \n    vec4 c000 = perspectiveDivide(PM*vec4(-1,-1, -1, 1));\n    vec4 c100 = perspectiveDivide(PM*vec4( 1,-1, -1, 1));\n    vec4 c010 = perspectiveDivide(PM*vec4(-1, 1, -1, 1));\n    vec4 c110 = perspectiveDivide(PM*vec4( 1, 1, -1, 1));\n    vec4 c001 = perspectiveDivide(PM*vec4(-1,-1,  1, 1));\n    vec4 c101 = perspectiveDivide(PM*vec4( 1,-1,  1, 1));\n    vec4 c011 = perspectiveDivide(PM*vec4(-1, 1,  1, 1));\n    vec4 c111 = perspectiveDivide(PM*vec4( 1, 1,  1, 1));\n\n    vec3 n_x = mat3(M)*vec3(1,0,0);\n    vec3 n_y = mat3(M)*vec3(0,1,0);\n    vec3 n_z = mat3(M)*vec3(0,0,1);\n    \n    vec3 normal = vec3(0,0,0);\n\tfloat depth = 200.0;\n    \n    rasterizeTriangle(depth, normal, c100, c000, c110, uv, -n_z);\n    rasterizeTriangle(depth, normal, c110, c000, c010, uv, -n_z);\n    rasterizeTriangle(depth, normal, c001, c101, c111, uv, n_z);\n    rasterizeTriangle(depth, normal, c001, c111, c011, uv, n_z);\n        \n    rasterizeTriangle(depth, normal, c000, c100, c001, uv, -n_y);\n    rasterizeTriangle(depth, normal, c100, c101, c001, uv, -n_y);\n    rasterizeTriangle(depth, normal, c110, c010, c011, uv, n_y);\n    rasterizeTriangle(depth, normal, c111, c110, c011, uv, n_y);\n\n    rasterizeTriangle(depth, normal, c010, c000, c011, uv, -n_x);\n    rasterizeTriangle(depth, normal, c011, c000, c001, uv, -n_x);\n    rasterizeTriangle(depth, normal, c100, c110, c111, uv, n_x);\n    rasterizeTriangle(depth, normal, c100, c111, c101, uv, n_x);\n\n        \n    \n    // Output to screen\n    fragColor = vec4(depth == 0.0 ? normal : vec3(0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlfSWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlfSz7", "name": "mandelbrot test I", "author": "dagbrynildsentholander", "description": "wanted to try fractals. ", "tags": ["mandelbrot"], "likes": 2, "viewed": 210, "date": "1562423665", "time_retrieved": "2024-06-20T19:40:11.216888", "image_code": "float N = 2048.;\nvec2 mouse = vec2(0.);\n\nfloat mandelbrot(vec2 c)\n{\n    vec2 z = vec2(-.3, .0);\n    for(float i = 0.; i < N; i++)\n    {        \n        if(length(z)>2.)\n            return i;\n     \telse \n        \tz = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y)+c;\n    }\n    return N;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord/iResolution.xy)-vec2(.5))*5.;\n    // Time varying pixel color\n    vec3 col = vec3(0);\n\tmouse+=vec2(-1.37, -.01);\n    float value = mandelbrot((uv.xy/(iTime*(iTime*iTime)+1.)+mouse))/N;\n\tcol = vec3( sin(fract(value*value*20.)), sin(fract(value*7.)*5.),  sin(value*value*5.));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlfSz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlfSz8", "name": "Box Loop 3 (colored)", "author": "mlkn", "description": "Colored version of Box Loop 3:\nhttps://www.shadertoy.com/view/tlsSzr", "tags": ["2d", "voronoi", "distance", "manhattan"], "likes": 3, "viewed": 315, "date": "1562014335", "time_retrieved": "2024-06-20T19:40:12.489575", "image_code": "// https://www.shadertoy.com/view/MslGD8 - basic voronoi\n// https://www.shadertoy.com/view/llG3zy - voronoi edge dist\n// https://www.shadertoy.com/view/Mtyczw - manhattan edge dist\n// https://www.shadertoy.com/view/MstGRr - 2d box distance\n\n#define BOX_SIZE 0.4\n#define LOOP_PERIOD 2.7\n\n#define M_PI 3.14159265\n#define EPSILON .00001\n\nfloat invert = 1.0;\nfloat cycle = 0.0;\nfloat edgeCut = 0.03;\nfloat panicTerm = 0.1;\nfloat metricsTerm = 0.0;\nfloat finalSpread = 1.0;\nfloat t = 0.0;\n\nfloat rot = 0.0;\nfloat nextBoxRot = 0.0;\nfloat scale = 1.0;\nfloat nextBoxScale = 1.0;\n\nvec2 hash( vec2 p )\n{\n    p = vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n    vec2 result = fract(sin(p)*18.5453);\n    return 0.5 + panicTerm*sin(t * t * t * 15.0 + cycle + 6.2831*result);\n}\n\nfloat dist_minkowski(vec2 a, vec2 b, float p) {\n    // manhattan: return abs(a.x - b.x) + abs(a.y - b.y);\n    return pow(pow(abs(a.x - b.x),p) + pow(abs(a.y - b.y),p),1.0/p);\n}\n\nvec2 square_test(vec2 a, vec2 b){\n    return sqrt((a - b) * (a - b));\n}\n\nfloat vec_max(vec2 a){\n    return max(abs(a.x), abs(a.y));\n}\n\nfloat edge_dist_manhattan(vec2 center_a, vec2 center_b, vec2 p){\n\t\n    int max_comp, min_comp;\n    vec2 max_base, min_base, split_dir;\n    float dist;\n\n    vec2 center_max = max(center_a, center_b);\n    vec2 center_min = min(center_a, center_b);\n    vec2 square = square_test(center_max, center_min);\n\n    if(vec_max(square) == square.x){\n        max_comp = 0;\n    }else{\n        max_comp = 1;\n    }\n    min_comp = (max_comp + 1) % 2;\n    \n    vec2 split_pos_a, split_pos_b;\n    float u = square[min_comp] / 2.;\n    \n    float mid = (center_max[max_comp] + center_min[max_comp]) / 2.;\n    \n    split_pos_a = center_min;\n    split_pos_a[max_comp] = mid + u;\n\n    split_pos_b = center_max;\n    split_pos_b[max_comp] = mid - u;\n\n    max_base = max(split_pos_a, split_pos_b);\n    min_base = min(split_pos_a, split_pos_b);\n\n    split_dir = split_pos_b - split_pos_a;\n    vec2 split_dir_test = normalize(center_a - center_b);\n    \n    vec2 split_origin = max_base;\n    vec2 split_tip = min_base;\n    if(abs(dot(normalize(split_dir), split_dir_test)) < abs(dot(normalize(min_base - max_base), split_dir_test))){\n        split_dir = min_base - max_base;\n        split_origin = split_pos_a;\n        split_tip = split_pos_b;\n    }\n\n    if(square[min_comp] <= 1e-4){\n        split_dir = vec2(0.);\n        split_dir[max_comp] = 1.;\n    }\n\n    vec2 midp = (min_base + max_base) / 2.;\n    vec2 dir = p - midp;\n    dist = dot(dir, normalize(split_dir));\n\n    vec2 new_pos = p - normalize(split_dir) * dist;\n\n    if(length(midp - new_pos) > length(split_dir) / 2.){\n        vec2 nearest_sample;\n        vec2 split_o_p = new_pos - split_origin;\n        vec2 split_t_p = new_pos - split_tip;\n\n        if(vec_max(split_o_p) < vec_max(split_t_p)){\n            nearest_sample = split_origin;\n        }else{\n            nearest_sample = split_tip;\n        }\n                \n        vec2 n = vec2(0.);\n        n[max_comp] = 1.;\n        \n        vec2 ro = normalize(split_dir);\n        float d = dot(p - nearest_sample, n) / dot(ro, n);\n        dist = d;\n    }\n\n   return abs(dist);\n}\n\nvec4 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    // first pass: regular voronoi\n\tvec2 closestPoint;\n    float id;\n\n    float minDist = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 cell = vec2(float(i),float(j));\n\t\tvec2 point = hash(n + cell);\n        \n        vec2 r = cell - f + point;\n        float dist = dist_minkowski(r,vec2(0,0), metricsTerm + 1.0);\n\n        if( dist < minDist )\n        {\n            minDist = dist;\n            closestPoint = r;\n            id = point.x + point.y;\n        }\n    }\n\n    // second pass: distance to borders\n    minDist = 6.66;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 cell = vec2(float(i),float(j));\n\t\tvec2 point = hash(n + cell);\n\n\t\tvec2 r = cell - f + point;\n\n        if( dot(closestPoint-r,closestPoint-r) > EPSILON ) // skip the same cell\n        {\n            float curDist = mix(\n                edge_dist_manhattan(f - closestPoint, f - r, f),\n                dot(0.5*(closestPoint+r), normalize(r-closestPoint)),\n                step(0.03, metricsTerm));\n            minDist = min( minDist, curDist );\n        }\n    }\n\n    return vec4( minDist, closestPoint, id );\n}\n\nfloat box_dist(vec2 p, vec2 size, float radius) {\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nvec2 rotate_around(vec2 p, vec2 c, float angle) {\n\tvec2 t = p - c;\n    vec2 rot = vec2(\n        cos(angle) * t.x - sin(angle) * t.y,\n        sin(angle) * t.x + cos(angle) * t.y\n    );\n\treturn c + rot;\n}\n\nvec3 findVal(vec2 myFragCoord)\n{\n    vec2 p = myFragCoord / iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    p.x *= aspectRatio;\n    vec2 center = vec2(0.5 * aspectRatio, 0.5);\n    \n    vec2 rotatedP = rotate_around(p, center, rot);\n    vec2 c = (rotatedP - center) * scale;\n    \n    vec2 rotatedP2 = rotate_around(p, center, nextBoxRot);\n    vec2 nextBoxC = (rotatedP2 - center) * nextBoxScale;\n    float nextBoxDist = box_dist(nextBoxC, vec2(BOX_SIZE), 0.0);\n    \n    float d = smoothstep(0.0, 0.002, box_dist(c, vec2(BOX_SIZE), 0.0));\n\n    vec4 voro = voronoi((p - center) * mix(4.0, finalSpread, max(t - 0.5, 0.0)*2.0));\n\n    vec3 col = 0.5 + 0.5*cos(vec3(voro.w, voro.w * 0.5, voro.w*0.3)*6.2831 );\n    \n    col = mix(col, vec3(0.0,0.0,1.0), d);\n    float voronoiEdge = smoothstep(edgeCut-0.01,edgeCut, voro.x);\n    float val = min(voronoiEdge * (1.0 - d)\n                    + smoothstep(0.001, 0.01, nextBoxDist), 1.0);\n    val = val * invert - min(invert, 0.0);\n    if (invert < 0.0)\n    {\n        vec3 startCol = 0.5 + 0.5*cos(vec3(1.0, 0.5, 0.3)*6.2831 );\n        float tt= max((t-0.6)/ 0.4,0.0);\n        col = mix(col, startCol, pow(tt, 0.5) * (1.0 - voronoiEdge));\n    }\n    return vec3(val) * col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{   \n    t = mod(iTime, LOOP_PERIOD) / LOOP_PERIOD;\n    cycle = float(int(iTime / LOOP_PERIOD));\n    if (mod(cycle, 2.0) < 1.0) invert = -1.0;\n\n    panicTerm = min(max(t - 0.1, 0.01) * 0.4, 0.3);\n\tmetricsTerm = smoothstep(0.45, 0.55, 1.0 - t);\n    finalSpread = 15.0 - invert * 7.0;\n\n    edgeCut = min(t * 0.05, 0.05) + 3.3 * pow(max((t - 0.7)/0.7, 0.0), 2.0);\n    \n    rot = max(min((t - 0.5) * 2.05, 1.0), 0.0);\n    nextBoxRot = -pow(rot, 0.3) * M_PI * 0.5 * invert;\n    rot = rot*rot*rot* M_PI / 2.0 * invert;  \n\n    scale = 1.0 + max(t-0.5, 0.0) * 5.0;\n    nextBoxScale = max((t - 0.5), 0.0) / 0.5;\n    \n    fragColor.rgb = findVal(fragCoord.xy);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlfSz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlfSzN", "name": "technology", "author": "butadiene", "description": "gear\nhttps://www.shadertoy.com/view/ttXXzN", "tags": ["raymarching"], "likes": 4, "viewed": 392, "date": "1562245746", "time_retrieved": "2024-06-20T19:40:12.489575", "image_code": "const float PI = 3.1415926;\n\nfloat nPrism(vec3 p, vec2 h,float n,float s){\n    float ang = atan(p.x,p.y);\n    float ln = length(p.xy);\n    float nd = 2.*PI/n;\n    ang = mod(ang,nd)-nd*0.5;\n    vec2 np = ln * vec2(cos(ang),sin(ang));\n    float d = length(vec2(max(np.x-h.x,0.),max(abs(np.y)-s*h.x*tan(nd*0.5),0.0)));\n    d = length(vec2(max(abs(p.z)-h.y,0.0),d));\n    return d;\n}\n\nvec2 rot (vec2 p,float r){\n    \n    mat2 m = mat2(cos(r),sin(r),-sin(r),cos(r));\n    return m*p;\n}\nfloat dist(vec3 p){\n    float k =12.0;\n    p = mod(p,k)-k*0.5;\n    for(int i =0;i<4;i++){\n        p= abs(p)-1.;\n        p.xy = rot(p.xy,1.0);\n        p.zx = rot(p.zx,1.0);\n    }\n   p.xy =rot(p.xy,cos(iTime+PI));\n    float d = nPrism(p,vec2(0.8,0.1),7.0+4.0*sin(iTime),0.55);\n    d = max(d,-(length(p.xy)-0.3));\n    return d;\n}\nvec3 getnormal(vec3 p){\n    vec2 e =vec2(0.001,0.0);\n    return normalize(vec3(\n        dist(p+e.xyy)-dist(p-e.xyy),\n        dist(p+e.yxy)-dist(p-e.yxy),\n        dist(p+e.yyx)-dist(p-e.yyx)\n    ));\n}\nvec4 lighting(vec3 p,vec3 rd){\n    vec3 normal = getnormal(p);\n    vec3 lightdir = normalize(vec3(0.5,0.5,1.0));\n    float NdotL = max(dot(lightdir,normal),0.0);\n    vec3 R = normalize(-lightdir+NdotL*normal*2.);\n    vec3 spec =vec3(pow(max(dot(R,-rd),0.0),10.0));\n    vec3 col = vec3(NdotL)*0.4+spec;\n    return vec4(col,1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.yy;\n    vec3 ro = vec3(5.0,5.0,10.0)+iTime*normalize(vec3(5.0,5.0,10.0));\n    vec3 ta = vec3(0.0,0.0,0.0)+iTime*normalize(vec3(5.0,5.0,10.0));\n    vec3 cdir = normalize(ta-ro);\n    vec3 up = normalize(vec3(0.0,1.0,0.0));\n    vec3 side = cross(cdir,up);\n    up = cross(side,cdir);\n    float fov = 3.0;\n    vec3 rd = normalize(up*p.y+side*p.x+cdir*fov);\n    float t = 0.100001;\n    float d =0.0;\n    for(int i =0;i<99;i++){\n        d = dist(ro+rd*t);\n        t +=d;\n    }\n    vec4 bgcol = vec4(0.8,0.8,0.8,1.0);\n    vec4 col =bgcol;//vec4(0.0,0.0,0.0,1.0);\n    if(d<0.001){\n        col = lighting(ro+rd*t,rd);\n    }\n    float near =3.0;\n    float far =40.0;\n    col = mix(col,bgcol,clamp((t-near)/(far-near),0.0,1.0));\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlfSzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlfSzs", "name": "Magical Christmas ", "author": "SNWK_Group02", "description": "CLUSTER 1-18, GPU 1060 PLUS for better performance", "tags": ["raytracing", "triangle", "sphere", "cuboid", "aabbs"], "likes": 0, "viewed": 143, "date": "1563902725", "time_retrieved": "2024-06-20T19:40:18.877974", "image_code": "\n//============================================================================\n// PROJECT ID: CLUSTER1_18\n//\n// GROUP NUMBER: 02\n//\n// STUDENT NAME: Wang Kai\n// NUS User ID.: t0918150\n//\n// STUDENT NAME: Huang Ziheng\n// NUS User ID.: t0918577\n//\n// STUDENT NAME: Lan Xuan\n// NUS User ID.: t0918598\n//\n// COMMENTS TO GRADER: \n//\n//============================================================================\n\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at http://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\nconst int NUM_LIGHTS = 5;\nconst int NUM_MATERIALS = 6;\nconst int NUM_PLANES = 5;\nconst int NUM_SPHERES = 26;\nconst int NUM_BOXES = 2;\nconst int NUM_Octahedrons = 1;\nconst int NUM_TRIANGLE = 12;\nconst int NUM_FLASHCOLOR = 5;\nconst int NUM_LIGHTCOLOR = 2;\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\nconst bool isSphere = true;\nconst bool isAABB = true;\n // Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0; \n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\nconst float PI = 3.14159265;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n};\n\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n//==========AABB DEFINE\nstruct AABB_t{\n    vec3 A;\n    vec3 B;\n    bool debug;\n};\n//==========AABB DEFINE END\n//==========Cylinder DEFINE\n\n\n//==========Cylinder DEFINE END\n//==========Triangle DEFINE\nstruct Triangle_t{\n    vec3 A;\n    vec3 B;\n    vec3 C;\n    bool debug;\n    int materialID;\n    Material_t material;\n    AABB_t aabb;\n};\n//==========Triangle DEFINE END\n\n//==========bamian DEFINE\nstruct Octahedron_t{\n    bool debug;\n    int materialID;\n    AABB_t aabb;\n};\n//==========bamian DEFINE END\n\n//==========BOX DEFINE\nstruct xy_rect{\n    float x0,y0,x1,y1,k;\n    vec3 normal;\n    float flip;\n    bool debug;\n};\nstruct yz_rect{\n    float z0,y0,z1,y1,k;\n    vec3 normal;\n    float flip;\n    bool debug;\n};\nstruct zx_rect{\n    float x0,z0,x1,z1,k;\n    vec3 normal;\n    float flip;\n    bool debug;\n};\nstruct Box_t {\n    vec3 cornerA;\n    vec3 cornerB;\n    xy_rect xys[2];\n    yz_rect yzs[2];\n    zx_rect zxs[2];\n    int materialID;\n    Material_t material;\n    bool debug;\n    AABB_t aabb;\n};\n//==========END BOX DEFINE\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n    Material_t material;\n    AABB_t aabb;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of \n// Lecture 11 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS { \n//                   I_a * k_a + \n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nBox_t Box[NUM_BOXES];\nTriangle_t Triangle[NUM_TRIANGLE];\nOctahedron_t Octahedron[NUM_Octahedrons];\nvec3 FLASH_COLOR[NUM_FLASHCOLOR];\nvec3 LIGHT_COLOR[NUM_LIGHTCOLOR];\n\nfloat getMin(in float a, in float b, in float c){\n    float min = a;\n    if(b < min)\n        min = b;\n    if(c < min)\n        min = c;\n    return min;\n}\n\nfloat getMax(in float a, in float b, in float c){\n    float max = a;\n    if(b > max)\n        max = b;\n    if(c > max)\n        max = c;\n    return max;\n}\n/////////////////////////////////////////////////////////////////////////////\n// Initializes a Sphere.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitSphere(in int i){\n    //Sphere[i].materialID = i%3;\n    vec3 center = Sphere[i].center;\n    float r = Sphere[i].radius;\n    Sphere[i].aabb.A = center - vec3(r,r,r);\n    Sphere[i].aabb.B = center + vec3(r,r,r);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes a triangle.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitTriangle(in int i){\n    Triangle[i].materialID = -1;\n    Triangle[i].material.k_d = FLASH_COLOR[(int(abs(sin(1.9*iTime))*float(NUM_FLASHCOLOR - 1))+i)%5];//vec3( abs(sin(0.3*iTime+ float(i)*PI/20.0)), 0.1, abs(sin(0.5*iTime+ float(i)*PI/20.0)) );\n    Triangle[i].material.k_a = 0.2 * Triangle[i].material.k_d;\n    Triangle[i].material.k_r = 0.2 * Triangle[i].material.k_d;\n    Triangle[i].material.k_rg = 0.5 * Triangle[i].material.k_r;\n    Triangle[i].material.n = 128.0;\n    vec3 A = Triangle[i].A;\n    vec3 B = Triangle[i].B;\n    vec3 C = Triangle[i].C;\n    Triangle[i].debug = false;\n    Triangle[i].aabb.A = vec3(getMin(A[0],B[0],C[0]),getMin(A[1],B[1],C[1]),getMin(A[2],B[2],C[2]));\n    Triangle[i].aabb.B = vec3(getMax(A[0],B[0],C[0]),getMax(A[1],B[1],C[1]),getMax(A[2],B[2],C[2]));\n}\n/////////////////////////////////////////////////////////////////////////////\n// Initializes a box.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitBox(in int i){\n    Box[i].debug = false;\n    float x0 = min(Box[i].cornerA.x, Box[i].cornerB.x);\n    float x1 = max(Box[i].cornerA.x, Box[i].cornerB.x);\n    float y0 = min(Box[i].cornerA.y, Box[i].cornerB.y);\n    float y1 = max(Box[i].cornerA.y, Box[i].cornerB.y);\n    float z0 = min(Box[i].cornerA.z, Box[i].cornerB.z);\n    float z1 = max(Box[i].cornerA.z, Box[i].cornerB.z);\n    Box[i].aabb.A = vec3(x0,y0,z0);\n    Box[i].aabb.B = vec3(x1,y1,z1);\n    //front\n    Box[i].xys[0].x0 = x0;\n    Box[i].xys[0].x1 = x1;\n    Box[i].xys[0].y0 = y0;\n    Box[i].xys[0].y1 = y1;\n    Box[i].xys[0].k = z1;\n    Box[i].xys[0].flip = 1.0;\n    Box[i].xys[1].debug = false;\n    //behind\n    Box[i].xys[1].x0 = x0;\n    Box[i].xys[1].x1 = x1;\n    Box[i].xys[1].y0 = y0;\n    Box[i].xys[1].y1 = y1;\n    Box[i].xys[1].k = z0;\n    Box[i].xys[1].flip = -1.0;\n    Box[i].xys[1].debug = false;\n    //left\n    Box[i].yzs[0].z0 = z0;\n    Box[i].yzs[0].z1 = z1;\n    Box[i].yzs[0].y0 = y0;\n    Box[i].yzs[0].y1 = y1;\n    Box[i].yzs[0].k = x0;\n    Box[i].yzs[0].flip = -1.0;\n    Box[i].yzs[0].debug = false;\n    //right\n    Box[i].yzs[1].z0 = z0;\n    Box[i].yzs[1].z1 = z1;\n    Box[i].yzs[1].y0 = y0;\n    Box[i].yzs[1].y1 = y1;\n    Box[i].yzs[1].k = x1;\n    Box[i].yzs[1].flip = 1.0;\n    Box[i].yzs[1].debug = false;\n    //top\n    Box[i].zxs[0].z0 = z0;\n    Box[i].zxs[0].z1 = z1;\n    Box[i].zxs[0].x0 = x0;\n    Box[i].zxs[0].x1 = x1;\n    Box[i].zxs[0].k = y1;\n    Box[i].zxs[0].flip = 1.0;\n    Box[i].zxs[0].debug = false;\n    //down\n    Box[i].zxs[1].z0 = z0;\n    Box[i].zxs[1].z1 = z1;\n    Box[i].zxs[1].x0 = x0;\n    Box[i].zxs[1].x1 = x1;\n    Box[i].zxs[1].k = y0;\n    Box[i].zxs[1].flip = -1.0;\n    Box[i].zxs[1].debug = false;\n\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    FLASH_COLOR[0] = vec3(0.8549, 0.8118, 0.2157);\n    FLASH_COLOR[1] = vec3(0.9059, 0.6235, 0.1961);\n    FLASH_COLOR[2] = vec3(0.9412, 0.7176, 0.5137);\n    FLASH_COLOR[3] = vec3(0.9098, 0.498, 0.2588);\n    FLASH_COLOR[4] = vec3(0.902, 0.7137, 0.4392);\n\n    LIGHT_COLOR[0] = vec3(0.9529, 0.4196, 0.2549);\n    LIGHT_COLOR[1] = vec3(0.9529, 0.9176, 0.4471);//vec3(0.965,0.0,0.133);\n    //LIGHT_COLOR[2] = vec3(0.0,0.2,0.9);//vec3(0.9,0.2,1.0);\n\n\n    //Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = -2;\n\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 100.0;\n    Plane[1].materialID = -2;\n\n    Plane[2].A = 1.0;\n    Plane[2].B = 0.0;\n    Plane[2].C = 0.0;\n    Plane[2].D = 100.0;\n    Plane[2].materialID = -2;\n\n    Plane[3].A = 0.0;\n    Plane[3].B = 0.0;\n    Plane[3].C = -1.0;\n    Plane[3].D = 100.0;\n    Plane[3].materialID = -2;\n\n    Plane[4].A = -1.0;\n    Plane[4].B = 0.0;\n    Plane[4].C = 0.0;\n    Plane[4].D = 100.0;\n    Plane[4].materialID = -2;\n\n  \n    Triangle[0].A= vec3 (0.0,12.0,0.0);\n    Triangle[0].B= vec3 (1.0,0.0,1.0);\n    Triangle[0].C= vec3 (-1.0,0.0,1.0);\n\n    Triangle[1].A= vec3 (0.0,12.0,0.0);\n    Triangle[1].B= vec3 (1.0,0.0,-1.0);\n    Triangle[1].C= vec3 (1.0,0.0,1.0);\n\n    Triangle[2].A= vec3 (0.0,12.0,0.0);\n    Triangle[2].B= vec3 (-1.0,0.0,-1.0);\n    Triangle[2].C= vec3 (1.0,0.0,-1.0);\n\n    Triangle[3].A= vec3 (0.0,12.0,0.0);\n    Triangle[3].B= vec3 (-1.0,0.0,1.0);\n    Triangle[3].C= vec3 (-1.0,0.0,-1.0);\n\n    Triangle[4].A= vec3 (0.0,13.0,0.0);\n    Triangle[4].B= vec3 (0.5,12.5,0.5);\n    Triangle[4].C= vec3 (-0.5,12.5,0.5);\n\n    Triangle[5].A= vec3 (0.0,13.0,0.0);\n    Triangle[5].B= vec3 (0.5,12.5,-0.5);\n    Triangle[5].C= vec3 (0.5,12.5,0.5);\n\n    Triangle[6].A= vec3 (0.0,13.0,0.0);\n    Triangle[6].B= vec3 (-0.5,12.5,-0.5);\n    Triangle[6].C= vec3 (0.5,12.5,-0.5);\n\n    Triangle[7].A= vec3 (0.0,13.0,0.0);\n    Triangle[7].B= vec3 (-0.5,12.5,0.5);\n    Triangle[7].C= vec3 (-0.5,12.5,-0.5);\n\n    Triangle[8].A= vec3 (0.0,12.0,0.0);\n    Triangle[8].B= vec3 (-0.5,12.5,0.5);\n    Triangle[8].C= vec3 (0.5,12.5,0.5);\n\n    Triangle[9].A= vec3 (0.0,12.0,0.0);\n    Triangle[9].B= vec3 (0.5,12.5,0.5);\n    Triangle[9].C= vec3 (0.5,12.5,-0.5);\n\n    Triangle[10].A= vec3 (0.0,12.0,0.0);\n    Triangle[10].B= vec3 (0.5,12.5,-0.5);\n    Triangle[10].C= vec3 (-0.5,12.5,-0.5);\n\n    Triangle[11].A= vec3 (0.0,12.0,0.0);\n    Triangle[11].B= vec3 (-0.5,12.5,-0.5);\n    Triangle[11].C= vec3 (-0.5,12.5,0.5);\n\n    Octahedron[0].aabb.A = vec3(-1.0,0.0,-1.0);\n    Octahedron[0].aabb.B = vec3(1.0,13.0,1.0);\n    \n    \n    for(int i = 0; i < NUM_TRIANGLE; i++){\n        InitTriangle(i);\n    }\n    \n    Box[0].cornerA= vec3(4.5,0.0,4.5);\n    Box[0].cornerB= vec3(7.5,2.7,7.5);\n    Box[0].materialID = 5;\n    Box[1].cornerA= vec3(4.3,2.7,4.3);\n    Box[1].cornerB= vec3(7.7,3.5,7.7);\n    Box[1].materialID = 4;\n    for(int i = 0; i < NUM_BOXES; i++){\n        InitBox(i);\n    }\n\n    Sphere[0].center = vec3(1.7320508075688772935274463415058723669428,4.0 + 0.1*sin(iTime + 3.0*PI/6.0),3.0);\n    Sphere[0].radius = 1.4;\n\n    Sphere[1].center = vec3(3.4641016151377545870548926830117447338856,4.0 + 0.1*sin(iTime + 4.0*PI/6.0),0.0);\n    Sphere[1].radius = 1.4;\n\n    Sphere[2].center = vec3(1.7320508075688772935274463415058723669428,4.0 + 0.1*sin(iTime + 5.0*PI/6.0),-3.0);\n    Sphere[2].radius = 1.4;\n\n    Sphere[3].center = vec3(-1.7320508075688772935274463415058723669428,4.0 + 0.1*sin(iTime + 6.0*PI/6.0),-3.0);\n    Sphere[3].radius = 1.4;\n\n    Sphere[4].center = vec3(-3.4641016151377545870548926830117447338856,4.0 + 0.1*sin(iTime + 1.0*PI/6.0),0.0);\n    Sphere[4].radius = 1.4;\n\n    Sphere[5].center = vec3(-1.7320508075688772935274463415058723669428,4.0 + 0.1*sin(iTime + 2.0*PI/6.0),3.0);\n    Sphere[5].radius = 1.4;\n\n    Sphere[6].center = vec3(1.2990381056766579701455847561294042752071,7.0 + 0.3*sin(1.5*iTime + 2.0*PI/6.0),2.25);\n    Sphere[6].radius = 1.0;\n\n    Sphere[7].center = vec3(2.5980762113533159402911695122588085504142,7.0 + 0.3*sin(1.5*iTime + 3.0*PI/6.0),0.0);\n    Sphere[7].radius = 1.0;\n\n    Sphere[8].center = vec3(1.2990381056766579701455847561294042752071,7.0 + 0.3*sin(1.5*iTime + 4.0*PI/6.0),-2.25);\n    Sphere[8].radius = 1.0;\n\n    Sphere[9].center = vec3(-1.2990381056766579701455847561294042752071,7.0 + 0.3*sin(1.5*iTime + 5.0*PI/6.0),-2.25);\n    Sphere[9].radius = 1.0;\n\n    Sphere[10].center = vec3(-2.5980762113533159402911695122588085504142,7.0 + 0.3*sin(1.5*iTime + 6.0*PI/6.0),0.0);\n    Sphere[10].radius = 1.0;\n\n    Sphere[11].center = vec3(-1.2990381056766579701455847561294042752071,7.0 + 0.3*sin(1.5*iTime + 1.0*PI/6.0),2.25);\n    Sphere[11].radius = 1.0;\n\n    Sphere[12].center = vec3(0.8660254037844386467637231707529361834714,10.0 + 0.5*sin(2.0*iTime + PI/6.0),1.5);\n    Sphere[12].radius = 0.6;\n\n    Sphere[13].center = vec3(1.7320508075688772935274463415058723669428,10.0 + 0.5*sin(2.0*iTime + 2.0*PI/6.0),0.0);\n    Sphere[13].radius = 0.6;\n\n    Sphere[14].center = vec3(0.8660254037844386467637231707529361834714,10.0 + 0.5*sin(2.0*iTime + 3.0*PI/6.0),-1.5);\n    Sphere[14].radius = 0.6;\n\n    Sphere[15].center = vec3(-0.8660254037844386467637231707529361834714,10.0 + 0.5*sin(2.0*iTime + 4.0*PI/6.0),-1.5);\n    Sphere[15].radius = 0.6;\n\n    Sphere[16].center = vec3(-1.7320508075688772935274463415058723669428,10.0 + 0.5*sin(2.0*iTime + 5.0*PI/6.0),0.0);\n    Sphere[16].radius = 0.6;\n\n    Sphere[17].center = vec3(-0.8660254037844386467637231707529361834714,10.0 + 0.5*sin(2.0*iTime + 6.0*PI/6.0),1.5);\n    Sphere[17].radius = 0.6;\n\n    for(int i = 0; i < NUM_SPHERES; i++){\n        Sphere[i].materialID = 1;\n    }\n\n    Sphere[18].center = vec3(10.0 * sin(iTime),7.0 + 4.0*sin(iTime),10.0 * cos(iTime));\n    Sphere[18].radius = 0.3;\n    \n    Sphere[19].center = vec3(-10.0 * sin(iTime),7.0 + 4.0*sin(iTime),-10.0 * cos(iTime));\n    Sphere[19].radius = 0.3;\n\n    Sphere[20].center = vec3(20.0 * sin(iTime + 0.5*PI),4.0 + 3.0*sin(iTime),15.0 * cos(iTime+ 0.5*PI));\n    Sphere[20].radius = 0.3;\n    \n    Sphere[21].center = vec3(-15.0 * sin(iTime + 0.5*PI),5.0 + 2.0*sin(iTime),-20.0 * cos(iTime+ 0.5*PI));\n    Sphere[21].radius = 0.3;\n\n    Sphere[22].center = vec3(6.0 * sin(2.0*iTime),10.0 + 2.0*sin(iTime),6.0 * cos(2.0*iTime));\n    Sphere[22].radius = 0.3;\n    \n    Sphere[23].center = vec3(-6.0 * sin(2.0*iTime),10.0 + 2.0*sin(iTime),-6.0 * cos(2.0*iTime));\n    Sphere[23].radius = 0.3;\n\n    Sphere[24].center = vec3(15.0 * sin(iTime + 1.2*PI),7.0 + 7.0*sin(2.0*iTime),15.0 * cos(iTime+ 1.2*PI));\n    Sphere[24].radius = 0.3;\n    \n    Sphere[25].center = vec3(-15.0 * sin(iTime + 1.2*PI),7.0 + 7.0*sin(2.0*iTime),-15.0 * cos(iTime+ 1.2*PI));\n    Sphere[25].radius = 0.3;\n    for(int i = 18; i < NUM_SPHERES; i++){\n        Sphere[i].materialID = 4 + i%2;\n    }\n\n    for(int i = 0; i < NUM_SPHERES; i++){\n        InitSphere(i);\n    }\n    // Silver material.\n    Material[0].k_d = vec3( 0.1, 0.1, 0.1 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n =64.0;\n\n\n    //Spheres.\n    Material[1].k_d = vec3(0.2431, 0.4314, 0.2196);\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n    //Pillar.\n    Material[2].k_d = vec3( 0.5137, 0.6627, 0.8863 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n\n    // Green plastic material.\n    Material[3].k_d = vec3(1.0, 0.0431, 0.0078);//vec3( abs(sin(0.5*iTime)), abs(cos(0.5*iTime)), abs(sin(0.5*iTime)) );\n    Material[3].k_a = 0.2 * Material[3].k_d;\n    Material[3].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[3].k_rg = 0.5 * Material[3].k_r;\n    Material[3].n = 128.0;\n\n     // Gold material.\n    Material[4].k_d = vec3( 0.8, 0.7, 0.1 );\n    Material[4].k_a = 0.5 * Material[4].k_d;\n    Material[4].k_r = 1.0 * Material[4].k_d;\n    Material[4].k_rg = 0.2 * Material[4].k_r;\n    Material[4].n =64.0;\n\n    // REd material.\n    Material[5].k_d = vec3(0.9255, 0.1255, 0.1255);\n    Material[5].k_a = 0.5 * Material[5].k_d;\n    Material[5].k_r = 0.5 * Material[5].k_d;\n    Material[5].k_rg = 0.2 * Material[5].k_r;\n    Material[5].n =64.0;\n\n\n    // Light 0.\n    Light[0].position = vec3( 10.0, 25.0, -10.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = LIGHT_COLOR[0];//LIGHT_COLOR[(int(abs(sin(1.9*iTime))*float(NUM_FLASHCOLOR - 1)))%NUM_LIGHTCOLOR ];//vec3( abs(sin(0.5*iTime)), 0.0, 1.0 );\n\n    // Light 1.\n    Light[1].position = vec3( -10.0, 25.0, 10.0 );\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = LIGHT_COLOR[1];//LIGHT_COLOR[(int(abs(sin(1.9*iTime))*float(NUM_FLASHCOLOR - 1)) + 1)%NUM_LIGHTCOLOR ];//vec3( 1.0, 1.0, 1.0 );\n\n    // Light 2.x\n    Light[2].position = vec3( 10.0*sin(3.0*iTime), 3.0, 10.0*cos(3.0*iTime) );\n    Light[2].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[2].I_source = vec3( 0.5, 0.0, 0.5 );//LIGHT_COLOR[(int(abs(sin(1.9*iTime))*float(NUM_FLASHCOLOR - 1)) + 1)%NUM_LIGHTCOLOR ];//vec3( 1.0, 1.0, 1.0 );\n\n    // Light 2.x\n    Light[3].position = vec3( 6.0, 1.3, 6.0 );\n    Light[3].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[3].I_source = vec3( 0.8, 0.0, 0.0 );//LIGHT_COLOR[(int(abs(sin(1.9*iTime))*float(NUM_FLASHCOLOR - 1)) + 1)%NUM_LIGHTCOLOR ];//vec3( 1.0, 1.0, 1.0 );\n\n    // Light 2.x\n    Light[4].position = vec3( 0.0, 40.0, 0.0 );\n    Light[4].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[4].I_source = vec3( 1.0, 1.0, 1.0 );//LIGHT_COLOR[(int(abs(sin(1.9*iTime))*float(NUM_FLASHCOLOR - 1)) + 1)%NUM_LIGHTCOLOR ];//vec3( 1.0, 1.0, 1.0 );\n\n    \n    // Light[2].position = vec3( 0.0, 15.7320508075688772935274463415058723669428, 0.0 );\n    // Light[2].I_a = vec3( 0.1, 0.1, 0.1 );\n    // Light[2].I_source = vec3( 1.0, 0.0, 0.0 );\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a aabb and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectAABB( in AABB_t obj, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 A = obj.A;\n    vec3 B = obj.B;\n    for (int i = 0; i < 3; i++) {\n        float t0 = min((A[i] - ray.o[i]) / ray.d[i], (B[i] - ray.o[i]) / ray.d[i]);\n        float t1 = max((A[i] - ray.o[i]) / ray.d[i], (B[i] - ray.o[i]) / ray.d[i]);\n        tmin = max(t0, tmin);\n        tmax = min(t1, tmax);\n        if (tmax <= tmin)\n            return false;\n    }\n    return true;\n}\n\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    // solve solution at^2 + bt + c = 0\n    if(isAABB)\n        if(!IntersectAABB(sph.aabb, ray, tmin, tmax))\n            return false;\n    float a = 1.0f; // dot(ray.d,ray.d)\n    float b = 2.0f*dot(ray.o,ray.d) - 2.0f*dot(ray.d,sph.center);\n    float c = dot(ray.o,ray.o) + dot(sph.center,sph.center) - 2.0f*dot(ray.o,sph.center) - sph.radius*sph.radius;\n    float d = b*b - 4.0f*a*c;\n    if (d < 0.0f)\n        return false;\n    else{\n        float t0 = (-b - sqrt(d))/(2.0f*a);\n        //float t1 = (-b + sqrt(d))/(2.0f*a);\n        if( t0 < tmin || t0 > tmax) // out range\n            return false;\n        else{\n            t = t0;\n            hitPos = ray.o + t0*ray.d;\n            hitNormal = normalize(hitPos - sph.center);\n            return true;\n        }\n    }\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    if(isAABB)\n        if(!IntersectAABB(sph.aabb, ray, tmin, tmax))\n            return false;\n    float a = 1.0f; // dot(ray.d,ray.d)\n    float b = 2.0f*dot(ray.o,ray.d) - 2.0f*dot(ray.d,sph.center);\n    float c = dot(ray.o,ray.o) + dot(sph.center,sph.center) - 2.0f*dot(ray.o,sph.center) - sph.radius*sph.radius;\n    float d = b*b - 4.0f*a*c;\n    if (d < 0.0f)\n        return false;\n    else{\n        float t0 = (-b - sqrt(d))/(2.0f*a);\n        //float t1 = (-b + sqrt(d))/(2.0f*a);\n        if( t0 < tmin || t0 > tmax) // out range\n            return false;\n        else{\n            return true;\n        }\n    }\n\n}\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a triangle and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectTriangle( in Triangle_t obj, in Ray_t ray, in float tmin, in float tmax,out float t, out vec3 hitPos, out vec3 hitNormal ) {\n    if(isAABB)\n        if(!IntersectAABB(obj.aabb, ray, tmin, tmax))\n            return false;\n    vec3 E = ray.o;\n    vec3 D = ray.d;\n    vec3 A = obj.A;\n    vec3 B = obj.B;\n    vec3 C = obj.C;\n    if(dot(D,cross(B-A,C-B)) <= 0.0)\n        return false;\n    float a = A[0] - B[0];\n    float b = A[1] - B[1];\n    float c = A[2] - B[2];\n    float d = A[0] - C[0];\n    float e = A[1] - C[1];\n    float f = A[2] - C[2];\n    float g = D[0];\n    float h = D[1];\n    float i = D[2];\n    float j = A[0] - E[0];\n    float k = A[1] - E[1];\n    float l = A[2] - E[2];\n    //Cramer's rule\n    float M = a*(e*i - h*f) + b*(g*f - d*i) + c*(d*h - e*g);\n    float tmpt = -(f*(a*k-j*b) + e*(j*c -a*l) + d*(b*l - k*c))/M;\n    if(tmpt < tmin || tmpt > tmax)\n        return false;\n    float lambda = (i*(a*k -j*b) + h*(j*c - a*l) + g*(b*l - k*c))/M;\n    if(lambda < 0.0 || lambda > 1.0)\n        return false;\n    float beta =( j*(e*i - h*f) + k*(g*f - d*i) + l*(d*h - e*g))/M;\n    if(beta < 0.0 || beta > 1.0 - lambda)\n        return false;\n    t = tmpt;\n    hitPos = ray.o + tmpt*ray.d;\n    hitNormal = normalize(cross(C-B,B-A));\n    return true;\n}\nbool IntersectTriangle( in Triangle_t obj, in Ray_t ray, in float tmin, in float tmax) {\n    if(isAABB)\n        if(!IntersectAABB(obj.aabb, ray, tmin, tmax))\n            return false;\n    vec3 E = ray.o;\n    vec3 D = ray.d;\n    vec3 A = obj.A;\n    vec3 B = obj.B;\n    vec3 C = obj.C;\n    if(dot(D,cross(B-A,C-B)) <= 0.0)\n        return false;\n    float a = A[0] - B[0];\n    float b = A[1] - B[1];\n    float c = A[2] - B[2];\n    float d = A[0] - C[0];\n    float e = A[1] - C[1];\n    float f = A[2] - C[2];\n    float g = D[0];\n    float h = D[1];\n    float i = D[2];\n    float j = A[0] - E[0];\n    float k = A[1] - E[1];\n    float l = A[2] - E[2];\n    //Cramer's rule\n    float M = a*(e*i - h*f) + b*(g*f - d*i) + c*(d*h - e*g);\n    float tmpt = -(f*(a*k-j*b) + e*(j*c -a*l) + d*(b*l - k*c))/M;\n    if(tmpt < tmin || tmpt > tmax)\n        return false;\n    float lambda = (i*(a*k -j*b) + h*(j*c - a*l) + g*(b*l - k*c))/M;\n    if(lambda < 0.0 || lambda > 1.0)\n        return false;\n    float beta =( j*(e*i - h*f) + k*(g*f - d*i) + l*(d*h - e*g))/M;\n    if(beta < 0.0 || beta > 1.0 - lambda)\n        return false;\n    return true;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a box and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectXYRec( in xy_rect obj, in Ray_t ray, in float tmin, in float tmax,out float t, out vec3 hitPos, out vec3 hitNormal ) {\n    float tmpt = (obj.k-ray.o.z) / ray.d.z;\n    if (tmpt < tmin || tmpt > tmax)\n        return false;\n    float x = ray.o.x + tmpt*ray.d.x;\n    float y = ray.o.y + tmpt*ray.d.y;\n    if (x < obj.x0 || x > obj.x1 || y < obj.y0 || y > obj.y1) \n        return false;\n    vec3 tmpnormal = obj.flip*vec3(0.0, 0.0, 1.0);\n    if (dot(ray.d,tmpnormal) > 0.0){\n        return false;\n    }\n    t = tmpt;\n    hitPos = ray.o + tmpt*ray.d;\n    hitNormal = obj.flip*vec3(0.0, 0.0, 1.0);\n    return true;\n}\nbool IntersectXYRec( in xy_rect obj, in Ray_t ray, in float tmin, in float tmax) {\n    float tmpt = (obj.k-ray.o.z) / ray.d.z;\n    if (tmpt < tmin || tmpt > tmax)\n        return false;\n    float x = ray.o.x + tmpt*ray.d.x;\n    float y = ray.o.y + tmpt*ray.d.y;\n    if (x < obj.x0 || x > obj.x1 || y < obj.y0 || y > obj.y1) \n        return false;\n    vec3 tmpnormal = obj.flip*vec3(0.0, 0.0, 1.0);\n    if (dot(ray.d,tmpnormal) > 0.0){\n        return false;\n    }\n    return true;\n}\n\n\nbool IntersectYZRec( in yz_rect obj, in Ray_t ray, in float tmin, in float tmax,out float t, out vec3 hitPos, out vec3 hitNormal ) {\n    float tmpt = (obj.k-ray.o.x) / ray.d.x;\n    if (tmpt < tmin || tmpt > tmax)\n        return false;\n    float z = ray.o.z + tmpt*ray.d.z;\n    float y = ray.o.y + tmpt*ray.d.y;\n    if (z < obj.z0 || z > obj.z1 || y < obj.y0 || y > obj.y1) \n        return false;\n    vec3 tmpnormal = obj.flip*vec3(1.0, 0.0, 0.0);\n    if (dot(ray.d,tmpnormal) > 0.0){\n        return false;\n    }\n    t = tmpt;\n    hitPos = ray.o + tmpt*ray.d;\n    hitNormal = obj.flip*vec3(1.0, 0.0, 0.0);\n    return true;\n}\nbool IntersectYZRec( in yz_rect obj, in Ray_t ray, in float tmin, in float tmax) {\n    float tmpt = (obj.k-ray.o.x) / ray.d.x;\n    if (tmpt < tmin || tmpt > tmax)\n        return false;\n    float z = ray.o.z + tmpt*ray.d.z;\n    float y = ray.o.y + tmpt*ray.d.y;\n    if (z < obj.z0 || z > obj.z1 || y < obj.y0 || y > obj.y1) \n        return false;\n    vec3 tmpnormal = obj.flip*vec3(1.0, 0.0, 0.0);\n    if (dot(ray.d,tmpnormal) > 0.0){\n        return false;\n    }\n    return true;\n}\n\n\nbool IntersectZXRec( in zx_rect obj, in Ray_t ray, in float tmin, in float tmax,out float t, out vec3 hitPos, out vec3 hitNormal ) {\n    float tmpt = (obj.k-ray.o.y) / ray.d.y;\n    if (tmpt < tmin || tmpt > tmax)\n        return false;\n    float z = ray.o.z + tmpt*ray.d.z;\n    float x = ray.o.x + tmpt*ray.d.x;\n    if (z < obj.z0 || z > obj.z1 || x < obj.x0 || x > obj.x1) \n        return false;\n    vec3 tmpnormal = obj.flip*vec3(0.0, 1.0, 0.0);\n    if (dot(ray.d,tmpnormal) > 0.0){\n        return false;\n    }\n    t = tmpt;\n    hitPos = ray.o + tmpt*ray.d;\n    hitNormal = obj.flip*vec3(0.0, 1.0, 0.0);\n    return true;\n}\n\nbool IntersectZXRec( in zx_rect obj, in Ray_t ray, in float tmin, in float tmax) {\n    float tmpt = (obj.k-ray.o.y) / ray.d.y;\n    if (tmpt < tmin || tmpt > tmax)\n        return false;\n    float z = ray.o.z + tmpt*ray.d.z;\n    float x = ray.o.x + tmpt*ray.d.x;\n    if (z < obj.z0 || z > obj.z1 || x < obj.x0 || x > obj.x1) \n        return false;\n    vec3 tmpnormal = obj.flip*vec3(0.0, 1.0, 0.0);\n    if (dot(ray.d,tmpnormal) > 0.0){\n        return false;\n    }\n    return true;\n}\n\n\nbool IntersectBox( in Box_t obj, in Ray_t ray, in float tmin, in float tmax,out float t, out vec3 hitPos, out vec3 hitNormal ) {\n    if(isAABB)\n        if(!IntersectAABB(obj.aabb, ray, tmin, tmax))\n            return false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n    \n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n    for(int i = 0; i < 2; i++){\n        if(IntersectXYRec( obj.xys[i], ray, tmin, tmax, temp_t, temp_hitPos, temp_hitNormal)){\n            temp_hasHit = true;\n            if(temp_t < nearest_t){\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n            }\n        }\n        if(IntersectYZRec( obj.yzs[i], ray, tmin, tmax, temp_t, temp_hitPos, temp_hitNormal)){\n            temp_hasHit = true;\n            if(temp_t < nearest_t){\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n            }\n        } \n        if(IntersectZXRec( obj.zxs[i], ray, tmin, tmax, temp_t, temp_hitPos, temp_hitNormal)){\n            temp_hasHit = true;\n            if(temp_t < nearest_t){\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n            }\n        } \n    }\n    if(temp_hasHit){\n        t = nearest_t;\n        hitPos = nearest_hitPos;\n        hitNormal = nearest_hitNormal;\n        return true;\n    }else{\n        return false;\n    }\n}\nbool IntersectBox( in Box_t obj, in Ray_t ray, in float tmin, in float tmax) {\n    if(isAABB)\n        if(!IntersectAABB(obj.aabb, ray, tmin, tmax))\n            return false;\n    bool temp_hasHit;\n    for(int i = 0; i < 2; i++){\n        if(IntersectXYRec( obj.xys[i], ray, tmin, tmax)){\n            temp_hasHit = true;\n        }\n        if(IntersectYZRec( obj.yzs[i], ray, tmin, tmax)){\n            temp_hasHit = true;\n        } \n        if(IntersectZXRec( obj.zxs[i], ray, tmin, tmax)){\n            temp_hasHit = true;\n        } \n    }\n    if(temp_hasHit){\n        return true;\n    }else{\n        return false;\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a + \n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\nbool checkIntersection (in Ray_t ray){\n    \n    if(isSphere){\n    // check intersection with all spheres\n    for(int i = 0; i < NUM_SPHERES; i ++ ){\n        if(IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX)){\n            return true;\n        }\n    }\n    }\n    // check intersection with all boxes\n    for(int i = 0; i < NUM_BOXES; i ++ ){\n        if(IntersectBox(Box[i], ray, DEFAULT_TMIN, DEFAULT_TMAX)){\n            return true;\n        }\n    }\n    //check intersection with all triangels\n    for(int j = 0; j < NUM_Octahedrons; j ++){\n        if(IntersectAABB(Octahedron[j].aabb,ray,DEFAULT_TMIN, DEFAULT_TMAX)){\n            for(int i = 0; i < NUM_TRIANGLE; i ++ ){\n                if(IntersectTriangle(Triangle[i], ray, DEFAULT_TMIN, DEFAULT_TMAX)){\n                    return true;\n                }\n            }\n        }\n    }\n    // for(int i = 0; i < NUM_TRIANGLE; i ++ ){\n    //     if(IntersectTriangle(Triangle[i], ray, DEFAULT_TMIN, DEFAULT_TMAX)){\n    //         return true;\n    //     }\n    // }\n    return false;\n}\n\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray, \n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg ) \n{\n    // Find whether and where the ray hits some object. \n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n    Material_t nearest_hitMat;\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    //check intersection with all planes\n    int planeDirection; // 0 xz 1 3xy 2 4yz\n    bool isAddLight = false;\n    for(int i = 0; i < NUM_PLANES; i ++ ){\n        if(IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal)){\n            hasHitSomething = true;\n            if (temp_t <= nearest_t){\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Plane[i].materialID;\n                planeDirection = i;\n                isAddLight = false;\n            }\n        }\n    }\n    if(isSphere){\n    // check intersection with all spheres\n    for(int i = 0; i < NUM_SPHERES; i ++ ){\n        if(IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal)){\n            hasHitSomething = true;\n            if (temp_t <= nearest_t){\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Sphere[i].materialID;\n                isAddLight = false;\n                if(i >= 18 && i < NUM_SPHERES )\n                    isAddLight = true;\n                if(nearest_hitMatID == -1){\n                    nearest_hitMat = Sphere[i].material;\n                }\n            }\n        }\n    }\n    }\n    // check intersection with all boxes\n    for(int i = 0; i < NUM_BOXES; i ++ ){\n        if(IntersectBox(Box[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal)){\n            hasHitSomething = true;\n            if (temp_t <= nearest_t){\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Box[i].materialID;\n                isAddLight = false;\n                if(nearest_hitMatID == -1){\n                    nearest_hitMat = Box[i].material;\n                }\n            }\n        }\n    }\n    // check intersection with all triangles\n    for(int j = 0; j < NUM_Octahedrons; j ++){\n        if(IntersectAABB(Octahedron[j].aabb,ray,DEFAULT_TMIN, DEFAULT_TMAX)){\n            for(int i = 0; i < NUM_TRIANGLE; i ++ ){\n                if(IntersectTriangle(Triangle[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal)){\n                    hasHitSomething = true;\n                    if (temp_t <= nearest_t){\n                        nearest_t = temp_t;\n                        nearest_hitPos = temp_hitPos;\n                        nearest_hitNormal = temp_hitNormal;\n                        nearest_hitMatID = Triangle[i].materialID;\n                        // isAddLight = false;\n                        if(i > 8)\n                            isAddLight = false;\n                        else\n                            isAddLight = false;\n                        if(nearest_hitMatID == -1){\n                            nearest_hitMat = Triangle[i].material;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // for(int i = 0; i < NUM_TRIANGLE; i ++ ){\n    //     if(IntersectTriangle(Triangle[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal)){\n    //         hasHitSomething = true;\n    //         if (temp_t <= nearest_t){\n    //             nearest_t = temp_t;\n    //             nearest_hitPos = temp_hitPos;\n    //             nearest_hitNormal = temp_hitNormal;\n    //             nearest_hitMatID = Triangle[i].materialID;\n    //             isAddLight = true;\n    //             if(nearest_hitMatID == -1){\n    //                 nearest_hitMat = Triangle[i].material;\n    //             }\n    //         }\n    //     }\n    // }\n\n\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point. \n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the \n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    for (int i = 0; i < NUM_LIGHTS; i ++){\n        if(i < NUM_LIGHTS - 1 || (i == NUM_LIGHTS - 1 && isAddLight)){\n            vec3 L = normalize(Light[i].position - nearest_hitPos);\n            vec3 N = nearest_hitNormal;\n            vec3 V = -ray.d;\n            Ray_t shadowRay;\n            shadowRay.o = nearest_hitPos;\n            shadowRay.d = L;\n            bool inshadow = checkIntersection (shadowRay);\n            if(nearest_hitMatID == -1){\n                I_local += PhongLighting(L, N, V, inshadow, nearest_hitMat, Light[i]);\n            }else if(nearest_hitMatID == -2){\n                //vec3 tcolor;\n                Material_t textureM;\n                vec3 tcolor = vec3( 0.1, 0.2, 0.4 ) * nearest_hitPos.y / 30.0;\n                    // Note: Choose fThreshhold in the range [0.99, 0.9999].\n                    // Higher values (i.e., closer to one) yield a sparser starfield.\n                float StarFieldThreshhold = 0.97;\n\n                    // Stars with a slow crawl.\n                float xRate = 0.001;\n                float yRate = -0.0006;\n                if(planeDirection == 0){\n                    tcolor = texture(iChannel1,mod(nearest_hitPos.xz/10.0,6.0)).rgb;//texture(iChannel1, fract((nearest_hitPos.xz + vec2(iTime))/ 100.)).xyz;\n                    textureM = Material_t(0.5*tcolor, 1.0*tcolor, 2.0*tcolor, 0.0*tcolor, 64.0);\n                    I_local += PhongLighting(L, N, V, inshadow, textureM, Light[i]);\n                }\n                else if (planeDirection % 2 == 1){\n                    vec2 vSamplePos = nearest_hitPos.xy*10.0 + vec2( xRate * float( iFrame ), yRate * float( iFrame ) );\n                    float StarVal = StableStarField( vSamplePos, StarFieldThreshhold );\n                    tcolor += vec3( StarVal );\n                    textureM = Material_t(1.0*tcolor, 0.5*tcolor, 1.0*tcolor, 0.5*tcolor, 64.0);\n                    I_local += PhongLighting(L, N, V, false, textureM, Light[i]);\n                }\n                else if (planeDirection % 2 == 0){\n                    vec2 vSamplePos = nearest_hitPos.zy*10.0 + vec2( xRate * float( iFrame ), yRate * float( iFrame ) );\n                    float StarVal = StableStarField( vSamplePos, StarFieldThreshhold );\n                    tcolor += vec3( StarVal );\n                    textureM = Material_t(0.0*tcolor, 0.5*tcolor, 1.0*tcolor, 0.5*tcolor, 64.0);                   \n                    I_local += PhongLighting(L, N, V, false, textureM, Light[i]);                \n                }\n            }else\n                I_local += PhongLighting(L, N, V, inshadow, Material[nearest_hitMatID], Light[i]);\n        }\n    }\n\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    vec3 cam_pos = vec3((18.0+(iMouse.y/iResolution.y)*15.0)*sin(0.2*iTime), 2.0 + (iMouse.y/iResolution.y)*15.0, (15.0+(iMouse.y/iResolution.y)*15.0)*cos(0.2*iTime));//vec3( -8, 2, 5 );\n    vec3 cam_lookat = vec3( 0.0, 6.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ ) \n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n    if(Box[0].xys[0].debug)\n        fragColor = vec4( 1.0,0.0,0.0, 1.0 );\n}\n\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlfSzs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlfXRX", "name": "RayMarchingBand011", "author": "Hirai_worthless", "description": "donut rush.", "tags": ["raymarching"], "likes": 4, "viewed": 98, "date": "1563699862", "time_retrieved": "2024-06-20T19:40:18.884051", "image_code": "float PI = 3.14159265;\nfloat map(vec3 p){\n    vec2 t = vec2(0.3, 0.05);\n    vec3 q = p;\n    vec3 r = p;\n    p = fract(p / 2.0) * 2.0 - 0.5;\n    p.yz *= mat2(cos((iTime - 1.0/2.0) * PI),-sin((iTime - 1.0/2.0) * PI)\n                 ,sin((iTime - 1.0/2.0) * PI),cos((iTime - 1.0/2.0) * PI));\n    vec2 r1 = vec2(length(p.xy) - t.x, p.z);\n    float torus1 = length(r1) - t.y;\n    q = fract(q / 2.0) * 2.0 - 1.5;\n    q.yz *= mat2(cos((-iTime - 1.0/2.0) * PI),-sin((-iTime - 1.0/2.0) * PI)\n                 ,sin((-iTime - 1.0/2.0) * PI),cos((-iTime - 1.0/2.0) * PI));\n    vec2 r2 = vec2(length(q.xy) - t.x, q.z);\n    float torus2 = length(r2) - t.y;\n    r = fract(r / 2.0) * 2.0 - 1.0;\n    float tubes = min(length(r.xz -vec2(0.5,0)) - 0.1,length(r.yz -vec2(0.5,0)) - 0.1);\n    \n    return min(min(torus2,torus1),tubes);\n}\n\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 96; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.2;\n    }\n    return vec4(getNormal(p),t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv,1.0));\n    vec3 o = vec3(0.5,0.5,iTime);\n    vec4 data = trace(o,r);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.2);\n    vec3 fc = mix(vec3(0.5 - data.x,0.5 -data.y,0.5-data.z),vec3(0),1.0 - fog);\n    vec3 col1 = vec3(sin(iTime),cos(iTime),1);\n    vec3 col2 = vec3(1);\n\tfc = mix(col1/2.0,col2,fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlfXRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlfXWH", "name": "Varying Mesh", "author": "dr2", "description": "Voronoi based mesh (mouseable)", "tags": ["voronoi", "reflection", "raymarch", "shadow", "mesh"], "likes": 17, "viewed": 433, "date": "1562705553", "time_retrieved": "2024-06-20T19:40:20.551007", "image_code": "// \"Varying Mesh\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\n\nvec3 sunDir;\nvec2 gVec[7], hVec[7];\nfloat tCur, dstFar;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nfloat HexVor (vec2 p)\n{\n  vec4 sd;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.5;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5) * tCur;\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return SmoothMin (sd.y, sd.z, 0.1) - sd.x;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 bSize;\n  float dMin, db;\n  dMin = dstFar;\n  bSize = vec2 (4., 2.);\n  q = p;\n  q.y -= bSize.y + 0.11;\n  db = PrRoundBoxDf (q, vec3 (bSize + 0.1, 0.01), 0.01);\n  if (db < 0.1) {\n    dMin = min (dMin, PrBoxDf (q, vec3 (bSize, 0.01 - 0.05 * smoothstep (0.1, 0.7,\n       HexVor (4. * q.xy)))));\n    dMin = min (dMin, SmoothMax (db, - PrBox2Df (q.xy, bSize - 0.05), 0.01));\n  } else dMin = db;\n  return 0.6 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.01 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.3, 0.35, 0.7), vec3 (0.8, 0.8, 0.8),\n     clamp (2. * (Fbm2 (2. * rd.xz / rd.y + 0.1 * tCur) - 0.1) * rd.y, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, colR, gCol, vn, ror, rdr;\n  vec2 w;\n  float dstObj, dstObjR, dstFlr, nDotL, sh;\n  bool isRefl;\n  HexVorInit ();\n  gCol = vec3 (0.5, 0.2, 0.1);\n  dstFlr = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  dstObj = ObjRay (ro, rd);\n  dstObjR = dstFar;\n  isRefl = false;\n  if (dstFlr < min (dstObj, dstFar)) {\n    ror = ro + dstFlr * rd;\n    rdr = reflect (rd, vec3 (0., 1., 0.));\n    ror += 0.01 * rdr;\n    dstObjR = ObjRay (ror, rdr);\n    isRefl = true;\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    nDotL = max (dot (vn, sunDir), 0.);\n    nDotL *= nDotL;\n    col = gCol * (0.2 + 0.1 * max (vn.y, 0.) + 0.7 * nDotL * nDotL) +\n       0.3 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n  } else if (rd.y < 0.) {\n    ro += dstFlr * rd;\n    vn = vec3 (0., 1., 0.);\n    sh = ObjSShadow (ro, sunDir);\n    nDotL = max (dot (vn, sunDir), 0.);\n    w = floor (mod (ro.xz, 2.));\n    col = vec3 (0.95, 1., 0.95) * ((w.x == w.y) ? vec3 (0.7): vec3 (0.3));\n    col = col * (0.2 + 0.1 * max (vn.y, 0.) + 0.7 * sh * nDotL) +\n       0.2 * step (0.95, sh) * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    col = mix (col, SkyCol (rd), 0.97 * smoothstep (0.5, 1., dstFlr / 100.));\n  } else col = SkyCol (rd);\n  if (isRefl) {\n    rd = rdr;\n    if (dstObjR < dstFar) {\n      ro = ror + dstObjR * rd;\n      vn = ObjNf (ro);\n      nDotL = max (dot (vn, sunDir), 0.);\n      nDotL *= nDotL;\n      colR = gCol * (0.2 + 0.1 * max (vn.y, 0.) + 0.7 * nDotL * nDotL) +\n         0.3 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    } else colR = SkyCol (rd);\n    col = mix (col, colR, 0.4);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.11 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.45 * pi, 0.);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -20.);\n  ro.y += 1.;\n  sunDir = normalize (vec3 (0., 0.5, -1.));\n  sunDir.xz = Rot2D (sunDir.xz, pi * sign (2. * floor (mod (0.03 * tCur, 2.)) - 1.) *\n     SmoothBump (0.3, 0.7, 0.2, mod (0.03 * tCur, 1.)));\n  zmFac = 5.;\n  dstFar = 100.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlfXWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlfXWl", "name": "FractalFrame", "author": "Hirai_worthless", "description": "test.", "tags": ["raymarching"], "likes": 4, "viewed": 84, "date": "1564579492", "time_retrieved": "2024-06-20T19:40:20.551007", "image_code": "mat2 genRot(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\nfloat PI = 3.14159265;\nvec3 path(float t){\n\tfloat x = clamp(sin(t) * pow(2.0,0.5),-1.0,1.0);\n    float y = clamp(cos(t) * pow(2.0,0.5),-1.0,1.0);\n    float z = 0.;\n    return vec3(x,y,z);\n}\nfloat grid(vec3 p, float a){\n    //p.xz *= genRot(iTime);\n    p = fract(p / a) * a;\n    p -= vec3(a / 2.0);\n\tfloat d1 = max(abs(p.x),abs(p.y)) - a/(9.+3.*sin(iTime * 2.0));\n\tfloat d2 = max(abs(p.y),abs(p.z)) - a/(9.+3.*sin(iTime * 2.0));\n\tfloat d3 = max(abs(p.z),abs(p.x)) - a/(9.+3.*sin(iTime * 2.0));\n\treturn (min(min(d1,d2),d3));\n}\nfloat map(vec3 p){\n\tfloat k = grid(p,1.0);\n    for(float i = 2.0; i < 256.0; i *= 2.0 ){\n        k = max(k,-grid(p,1.0/i));\n    }\n    return k;\n}\n\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 128; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return vec4(getNormal(p),t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float PI = 3.14159265;\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv,1.2));\n    r.xz *= genRot(iTime);\n    vec3 o = vec3( sin(iTime * PI / 4.) * 1.2,  0.5 + iTime * 1.0, cos(iTime * PI / 4.) * 1.2);\n    vec4 data = trace(o,r);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.05);\n    vec3 fc = mix(vec3(0.5 - data.x,0.5 -data.y,0.5-data.z),vec3(0.),1.0 - fog);\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlfXWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tllSD4", "name": "Jigoku Temple", "author": "sayachang_bot", "description": "Jigoku Temple", "tags": ["mandelbox"], "likes": 4, "viewed": 162, "date": "1563033651", "time_retrieved": "2024-06-20T19:40:21.023665", "image_code": "//uniform sampler2D backbuffer; \nconst float PI = 3.1415926;\nconst float EPS = .001;\n#define time iTime\nvec2 rot(vec2 p, float a){return vec2(p.x*cos(a)-p.y*sin(a),p.x*sin(a)+p.y*cos(a));}\nvec2 pmod(vec2 p,float m){\n    float a=PI/m-atan(p.y,p.x);\n    float r=2.*PI/m;\n    a=floor(a/r)*r;\n    return rot(p,a);\n}\n// https://docs.google.com/presentation/d/1j4t4mcLw8F1PfqvKP3P8meMJ5dWfDXkfb9lc63qOFVM/edit#slide=id.g238edbc4b4_0_2\nvec4 tglad(vec3 p)\n{\n\tvec3 q=vec3(mod(p,2.))-1.1;\n\tvec3 s=vec3(.01,2.+.3*cos(time),-.8+.35*sin(time));\n\tvec3 s2=vec3(1.2+.01*cos(time),9.+6.*sin(time),1.4*cos(time));\n\tvec3 scale=vec3(-PI);\n\tfor(int i=0;i<3;++i){\n\t\tq=clamp(q, -1., 1.)*1.99-q;\n\t\tq*=scale/clamp(dot(q,q),.33,1.);\n\t\tq+=s*.9;\n\t}\n\treturn vec4((length(max(abs(q)-s2,.0))-.06)/pow(PI,3.+EPS),q);\n}\nvec4 map(vec3 p){\n    vec3 q=p;\n    for(int i=0;i<3;++i){\n        q=abs(q)-1.5;\n        q.xy=pmod(q.xy,1.);\n        q.y-=.1;\n        q.yz=pmod(q.yz,-1.);\n        q*=.7;\n    }\n    vec4 d=tglad(q);\n    return vec4(d.x-.1,d.yzw);\n}\nvec3 norm(vec3 p){vec2 e=vec2(.01,.0);return .000001+map(p).x-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x);}\n// https://www.shadertoy.com/view/3dXSDH\nfloat sss(vec3 p, vec3 r, float d) {return clamp(map(p+r*d).x*3.0,0.0,1.0);}\nfloat rnd(float x){return fract(sin(x+12.345)*98.765);}\nfloat dots(vec3 p, float j) {\n    p*=4.+sin(j);\n    p.x -= rnd(floor(p.y));\n    p*=PI;\n    return clamp(0.1-length(vec2(sin(p.x),cos(p.y))),0.0,1.0)*30.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x,iResolution.y);\n    vec3 col = vec3(0.0);\n    vec3 ro=vec3(-4.3*sin(.1*time),0.,-2.)\n    ,ta=ro-vec3(2.+sin(time),.8+cos(time),1.-sin(time))\n    ,up=vec3(0.,1.,.0);\n    ro.xy=rot(ro.xy,-1.3);\n    ta.yz=rot(ta.yz,-1.3);\n    vec3 fwd=normalize(ta-ro)\n    ,side=normalize(cross(up,fwd));\n    up=normalize(cross(fwd,side));\n    vec3 rd=normalize(p.x*side+p.y*up+fwd*4.2);\n    vec3 ray=ro,N;\n    int j=0;\n    for(int i=0;i<64;++i){\n        float d=map(ray).x;\n        if(d<EPS){N=norm(ray);break;}\n        j=i;\n        ray+=d*rd;\n    }\n    col=(clamp(abs(6.*fract(.06*length(map(ray).xyx)+vec3(.0,.6,.3))-3.),.0,1.)*1.8-1.)*.2;\n    col+=pow(1.-float(j)/32.,2.);\n    col*=pow(1.-dot(N,normalize(ray-ro)),2.);\n    col+=(sss(ray,rd,0.2)+sss(ray,rd,0.5)*0.5+sss(ray,rd,0.5)*0.5)*.2;\n    \n    for(int k=0;k<7;++k){\n        float dos=dots(.9*(ray-20.*rd)*rnd(float(k))*vec3(sin(.1*time),4.*cos(.3*time),-sin(1.3*time)),1.);\n        col+=vec3(.2*dos,.1*dos,.0);\n    }\n    \n    vec3 colb=mix(vec3(.2,.5,.3),vec3(.9,.4,.1),pow(.8+.5*dot(rd,normalize(vec3(-5.*sin(.5*time),5.1*cos(.5*time),-5.1*sin(time)))),3.));\n    col*=colb;\n    /*\n    float tw=fract(sin(.1*time));\n    colb=texture2D(backbuffer,.5*p+vec2(tw,.0)).rgb;\n    vec3 colb2=texture2D(backbuffer,ray.yz-vec2(.0,.5+tw)).rgb;\n    col=(1.2*col+.5*colb+.1*colb2);\n    */\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tllSD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tllSD8", "name": "Reflection party", "author": "butadiene", "description": "Practice reflection ", "tags": ["raymarching", "reflection", "menger"], "likes": 3, "viewed": 351, "date": "1562786282", "time_retrieved": "2024-06-20T19:40:21.023665", "image_code": "float bpm =125.;\nfloat pi =acos(-1.);\nconst int nu =6;\n\nfloat cube(vec3 p,vec3 s){\n\tvec3 q = abs(p);\n\tvec3 kv = max(s-q,0.0);\n\treturn length(max(q-s,0.0))-min(min(kv.x,kv.y),kv.z);\n}\n\nvec2 pmod(vec2 p,float n){\n\tfloat np =2.0*pi/n;\n\tfloat r = atan(p.x,p.y)+0.5*np;\n\tr = mod(r,np)-0.5*np;\n\treturn length(p.xy)*vec2(sin(r),cos(r));\n}\n\nfloat cro(vec3 p,float s){\n\tvec3 q =abs(p);\n\t\n\tvec3 km = max(vec3(s)-q,0.0);\n\treturn min( -min(km.y,km.x),min(-min(km.z,km.y),-min(km.z,km.x)));\n}\n\nfloat nPrism(vec3 p,vec2 h,float n,float s){\n\tfloat np =pi*2.0/n;\n\tfloat r = atan(p.x,p.y);\n\tr = mod(r,np)-0.5*np;\n\tvec2 kp = length(p.xy)*vec2(cos(r),sin(r));\n\tvec3 kv = vec3(abs(kp.x)-h.x,abs(kp.y)-s*h.x*tan(np*0.5),abs(p.z)-h.y);\n\tfloat d = length(vec2(max(kv.x,0.0),max(kv.y,0.0)));\n\treturn length(vec2(d,max(kv.z,0.0)))-min(min(max(-kv.x,0.0),max(-kv.y,0.0)),max(-kv.z,0.0));\n}\n\nvec2 rot (vec2 p,float r){\n\tmat2 m = mat2(cos(r),sin(r),-sin(r),cos(r));\n\treturn m*p;\n}\nvec3 hsv(vec3 c){\n\treturn ((clamp(abs(fract(c.x+vec3(0.,1.,2.)/3.)*6.-3.)-1.,0.0,1.0)-1.)*c.y+1.)*c.z;\n}\nfloat menger (vec3 p){\n\tvec3 pm =p;\n\tp.xz = rot(p.xz,iTime);\n\tp.zy =rot(p.yz,iTime);\n    float bt0 =pow(abs(sin(iTime*(bpm*pi/60.))),10.0);\n\tfloat s =1.+bt0*0.3;\n\tfloat d = cube(p,vec3(s));\n\tfloat k =s*2.0;\n\tfloat d1 ;\n\tfloat d2 =99999.;\n  \n\tfloat bt =  1./6.*(clamp(abs(sin(0.05*iTime*(120.*pi/60.))),0.2,0.8)-0.2);\n\tfor(int i =0;i <4;i++){\n\ts/=3.0;\n\tvec3 sn =sign(p);\n\t//p.xy = rot(p.xy,bt)*sn.xy;\n\t//p.xz = rot(p.xz,bt)*sn.xz;\n\td1 = cro(p,s);\n\tk/=3.0+6.*bt+0.3*bt0;\n\tp =mod(p+0.5*k+sn*bt,k)-0.5*k;\n\td1 = min(d1,d2);\n\td2 =d1;\n\t}\n\tpm.y =-abs(pm.y);\n\tpm.yz = rot(pm.yz,0.5*pi);\n\tpm.z +=13.5; \n\tvec2 kn =1.1*vec2(1.1,1.7);\n\tvec3 pm2 =pm;\n\tvec2 id1  = floor(pm.xy/kn)*kn-kn*0.5;\n\tpm.xy=mod(pm.xy,kn)-kn*0.5;\n\tfloat knt =0.1;\n\tfloat bt2 =  0.2*pow(abs(sin(-0.25*length(id1)+knt+iTime*(bpm*pi/60.))),10.0);\n\tfloat d3 = nPrism(pm,vec2(0.5,10.5-bt2),6.0,1.0-3.5*bt2);\n\tpm2.xy +=kn*0.5;\n\tvec2 id2  = floor(pm2.xy/kn)*kn-kn*0.5;\n\tpm2.xy=mod(pm2.xy,kn)-kn*0.5;\n\tfloat bt3 =  0.2*pow(abs(sin(-0.25*length(id2)+knt+iTime*(bpm*pi/60.))),10.0);\n\td3 = min(d3,nPrism(pm2,vec2(0.5,10.5-bt3),6.0,1.0-3.5*bt3));\n\treturn min(d3,max(d,-d1));\n}\nvec4 spheres(vec3 p,float s){\n\tfloat kt =iTime*2.;\n\tfloat ra =3.0;\n\tfloat ds;\n\tfloat ds2 =999.;\n\t const int kn =nu;\n\tfloat fkn = float(kn);\n  \tvec3 col =vec3(0.0);;\n\tfor(int i=0;i<kn;i++){\n\tfloat fi =float(i);\n\tvec3 ap = vec3(ra*cos(kt+pi*fi*2./fkn),0.,ra*sin(kt+pi*fi*2./fkn));\n\tds = length(p-ap);\n    \tcol +=exp(-6.*ds)*hsv(vec3(0.0+fi*1./3.0,0.8,1.0));\n   \tds = length(p-ap)-s;\n\tds =min(ds,ds2);\n\tds2 =ds;\n\t}\n\tp.xz = pmod(p.xz,20.);\n\tfloat pky =2.2;\n\tp.y = mod(p.y,pky)-0.5*pky;\n\tfloat pkz =12.;\n\tfloat mpz = p.z; \n\tp.z = mod(p.z-iTime*pkz*bpm/60.,pkz)-0.5*pkz;\n\t\t\n\tfloat dcs =length(vec2(length(p.xy),max(abs(p.z)-0.1,0.0)));\n\tvec3 lecol = exp(-26.*dcs)*vec3(1.);\n\tfloat far =30.;\n\tfloat near =3.;\n\t\n\tlecol = mix(vec3(0.),lecol,clamp((far-mpz)/(far-near),0.0,1.0));\n\tcol +=lecol;\n\tds = min(ds,dcs);\n\treturn vec4(col,ds);\n}\nfloat dist (vec3 p){\n\t\n\tfloat d =menger(p);\n\t\n\treturn d;\n}\nvec3 gn(vec3 p){\n    vec4 n = vec4(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += 0.0001;\n        n[i] = dist(s.xyz);\n    }\n    return normalize(n.xyz-n.w);\n}\n\nfloat shadow(vec3 p,vec3 rd,float hn){\n\tfloat d;\n\tfloat t =0.0001;\n\tfloat res =1.0;\n\tfor(int i =0;i<16;i++){\n\t\td = menger(p+rd*t);\n\t\tres = min(res,hn*d/t);\n\t\tt += clamp(d,0.2,1.0);\n\t}\n\treturn res;\n\t\t\n}\n\nvec3 lighting(vec3 p,vec3 rd){\n\tvec3 n = gn(p);\n\tvec3 col =vec3(0.0);\n\tvec3 ld;\n\tfloat kt =iTime*2.;\n\tfloat ra =3.0;\n\tfloat md = menger(p);\n\t\n\tconst int kn =nu;\n\tfloat fkn = float(kn);\n\t\t\n\tif(md<0.01){\n\t\t\n\t\tfor(int i=0;i<kn;i++){\n\t\t\tfloat fi =float(i);\n\t\t\tld = normalize(vec3(ra*cos(kt+pi*fi*2./fkn),0.,ra*sin(kt+pi*fi*2./fkn))-p);\n\t\t\tfloat ndl = max(dot(n,ld),0.0);\n\t\t\tvec3 R = normalize(-ld+2.*n*ndl);\n\t\t\tfloat spec = pow(max(dot(R,-rd),0.0)*sign(ndl),15.);\n\t\t\tvec3 adcol = vec3(ndl*0.4+spec)*hsv(vec3(0.0+fi*1./3.0,1.0,1.0));\n\t\t\tfloat sha = shadow(p+n*0.001,ld,16.);\n\t\t\tcol +=adcol*sha;\n\t\t}\n\t}\n\treturn col;\n}\n\nvec3 draw(vec3 ro,vec3 rd){\n\tfloat t =0.001;\n\tfloat d =0.;\n\tfloat hit =0.001;\n\tvec3 ac =vec3(0.0);\n\tfor(int i =1;i<99;i++){\n\t\td =dist(ro+rd*t);\n        vec4 s4 = spheres(ro +rd*t,0.);\n\t\tt+=min(d,s4.w);\n\t\tac += s4.xyz;\n\t\tif(d<hit||t>1000.)break;\n\t}\n\tvec3 bgcol =vec3(0.,0.,0.);\n\tvec3 col = vec3(0.);\n\tfloat far =30.;\n\tfloat near =3.;\n\tcol = lighting(ro+rd*t,rd);\n\t\n\t\n\t\n\tvec3 pm = ro+rd*t;\n\tvec3 normal = gn(ro+rd*t);\n\tvec3 rerd = normalize(-rd+normal*max(dot(normal,-rd),0.0)*2.);\n\tfloat ret =0.001;\n\tfloat red =0.;\n\tvec3 reac =vec3(0.);\n\tfor(int i =1;i<39;i++){\n\t\td =dist(pm+rerd*ret);\n        \tvec4 s4 = spheres(pm +rerd*ret,0.);\n\t\tret+=min(d,s4.w);\n\t\treac += s4.xyz;\n\t\tif(d<hit||t>1000.)break;\n\t}\n\tvec3 recol =vec3(0.);\n\trecol = lighting(pm+rerd*ret,rerd);\n\trecol +=0.4*reac;\n\tcol =0.6*col+recol ;\n\tcol = mix(bgcol,col,clamp((far-t)/(far-near),0.0,1.0));\n\treturn col+0.4*ac;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = ( fragCoord.xy / iResolution.xy ) -0.5;\n\tp.y *= iResolution.y/iResolution.x;\n\tfloat kt =-iTime*0.8;\n\tfloat ra =10.0+2.0*sin(iTime);\n\tvec3 ro = vec3(ra*cos(kt),0.4,ra*sin(kt));\n\tvec3 ta =vec3(0.,-0.6,0.);\n\tvec3 cdir = normalize(ta-ro);\n\tvec3 up = vec3(0.,1.,0.);\n\tvec3 side = cross(cdir,up);\n\tup = cross(side,cdir);\n\tfloat fov =0.9;\n\tvec3 rd =normalize(up*p.y+side*p.x+cdir*fov);\n\tvec3 col;\n\tcol = draw(ro,rd);\n\tfragColor = vec4(col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tllSD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tllSR7", "name": "whorls", "author": "hodapp", "description": "Some more experimenting with domain transformations, and what is basically a \"hello world\" sort of shader for me since ~2004", "tags": ["ripples", "functional"], "likes": 3, "viewed": 123, "date": "1562512644", "time_retrieved": "2024-06-20T19:40:21.023665", "image_code": "// (c) 2019, Chris Hodapp\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265358979\n\nconst float d = 1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec2 st2 = st - vec2(0.320,0.380);\n\tst -= vec2(0.670,0.620);\n    st.x *= iResolution.x/iResolution.y;\n    st2.x *= iResolution.x/iResolution.y;\n    \n    float r = sqrt(st.x*st.x + st.y*st.y);\n    float th = atan(st.y, st.x);\n    \n    float r2 = sqrt(st2.x*st2.x + st2.y*st2.y);\n    float th2 = atan(st2.y, st2.x);\n  \n    float th_in = th - 2.0 / (r + 0.1) + th2 - 2.0 / (r2 + 0.1) + 0.4*cos(r*100.0 + iTime*4.0) - 0.4*cos(r2*100.0 + iTime*3.0) + iTime*1.2;\n    \n    float g = smoothstep(0.00, d, mod(th_in, PI*2.0)) - smoothstep(d, 2.0*d, mod(th_in, PI*2.0));\n    \n    vec3 color = vec3(g);\n    //color = vec3(st.x,st.y,abs(sin(u_time)));\n\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tllSR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tllSRl", "name": "wq1", "author": "wqwq1985", "description": "wq111", "tags": ["1111"], "likes": 1, "viewed": 47, "date": "1563960659", "time_retrieved": "2024-06-20T19:40:21.023665", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;// 将像素位置映射到0-1\n    fragColor = texture(iChannel0, uv);// 获取纹理在uv出的像素颜色\n    fragColor.r = abs(sin(iTime));// 让红色分量的值随时间改变。\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tllSRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tllSWB", "name": "Not so happy jumping", "author": "hypnoticshark", "description": " just changed some numbers", "tags": ["happyjumping"], "likes": 16, "viewed": 507, "date": "1564174273", "time_retrieved": "2024-06-20T19:40:23.260869", "image_code": "//Modification of https://www.shadertoy.com/view/3lsSzf for fun\n\n#define AA 2\n\n\n//------------------------------------------------------------------\n\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nvec2 sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h)), h );\n}\n\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nfloat href;\n\nvec4 map( in vec3 pos, float atime )\n{\n    float t1 = fract(atime);\n    float t4 = abs(fract(atime*0.5)-0.5)/0.5;\n\n    float p = 4.0*t1*(1.0-t1);\n    float pp = 4.0*(1.0-2.0*t1); // derivative of p\n\n    vec3 cen = vec3( 0.5*(-1.0 + 2.0*t4),\n                     pow( p, 2.0-smoothstep(0.0,0.25,p)) + 0.1,\n                     floor(atime) + pow(t1,0.7) -1.0 );\n\n    // body\n    vec2 uu = normalize(vec2( 1.0, -pp ));\n    vec2 vv = vec2(-uu.y, uu.x);\n    \n    float sy = 0.5 + 0.5*p;\n    float compress = 1.0-smoothstep(0.0,0.4,p);\n    sy = sy*(1.0-compress) + compress;\n    float sz = 1.0/sy;\n\n    vec3 q = pos - cen;\n    float rot = -1.95*(-1.0 + 2.0*t4);\n    float rc = cos(rot);\n    float rs = sin(rot);\n    q.xy = mat2x2(rc,rs,-rs,rc)*q.xy;\n    vec3 r = q;\n\thref = q.y;\n    q.yz = vec2( dot(uu,q.yz), dot(vv,q.yz) );\n    \n    vec4 res = vec4( sdEllipsoid( q, vec3(0.25, 0.25*sy, 0.25*sz) ), 2.0, 0.0, 1.0 );\n\n    if( res.x<1.0 ) // bounding volume\n\t{\n    float t2 = fract(atime+0.8);\n    float p2 = 0.5-0.5*cos(6.2831*t2);\n    r.z += 0.05-0.2*p2;\n    r.y += 0.2*sy-0.2;\n    vec3 sq = vec3( abs(r.x), r.yz );\n\n\t// head\n    vec3 h = r*.5;\n    float hr = sin(0.791*atime);\n    hr = 0.7*sign(hr)*smoothstep(0.5,0.7,abs(hr));\n    h.xz = mat2x2(cos(hr),sin(hr),-sin(hr),cos(hr))*h.xz;\n    vec3 hq = vec3( abs(h.x), h.yz );\n   \tfloat d  = sdEllipsoid( h-vec3(0.0,0.20,0.02), vec3(0.08,0.2,0.15) );\n\tfloat d2 = sdEllipsoid( h-vec3(0.0,0.21,-0.1), vec3(0.20,0.2,0.20) );\n\td = smin( d, d2, 0.1 );\n    res.x = smin( res.x, d, 0.1 );\n    \n    // belly wrinkles\n    {\n    float yy = r.y-0.02-2.5*r.x*r.x;\n    res.x += 0.004*sin(yy*120.0)*(1.0-smoothstep(0.0,0.1,abs(yy)));\n    }\n        \n    // arms\n    {\n    vec2 arms = sdStick( sq, vec3(0.18-0.06*hr*sign(r.x),0.2,-0.05), vec3(0.3+0.1*p2,-0.2+0.3*p2,-0.85), 0.03, 0.06 );\n    res.xz = smin( res.xz, arms, 0.01+0.04*(1.0-arms.y)*(1.0-arms.y)*(1.0-arms.y) );\n    }\n        \n    // ears\n    {\n    float t3 = fract(atime+0.9);\n    float p3 = 4.0*t3*(1.0-t3);\n    vec2 ear = sdStick( hq, vec3(0.15,0.32,-0.05), vec3(0.2+0.05*p3,0.2+0.2*p3,-0.07), 0.01, 0.04 );\n    res.xz = smin( res.xz, ear, 0.01 );\n    }\n    \n    // mouth\n    {\n   \td = sdEllipsoid( h-vec3(0.0,0.15+4.0*hq.x*hq.x,0.15), vec3(0.05,0.1,-0.1) );\n    res.w = 0.3+0.7*clamp( d*150.0,0.0,1.0);\n    res.x = smax( res.x, -d, 0.03 );\n    }\n\n\t// legs\n    {\n    float t6 = cos(6.2831*(atime*0.5+0.25));\n    float ccc = cos(1.57*t6*sign(r.x));\n    float sss = sin(1.57*t6*sign(r.x));\n\tvec3 base = vec3(0.12,-0.07,-0.1); base.y -= 0.1/sy;\n    vec2 legs = sdStick( sq, base, base + vec3(0.2,-ccc,sss)*0.2, 0.04, 0.07 );\n    res.xz = smin( res.xz, legs, 0.07 );\n    }\n        \n    // eye\n    {\n    float blink = pow(0.5+0.5*sin(2.1*iTime),20.0);\n    float eyeball = sdSphere(hq-vec3(0.08,0.27,0.06),0.065+0.02*blink);\n    res.x = smin( res.x, eyeball, 0.03 );\n    \n    vec3 cq = hq-vec3(0.1,0.34,0.08);\n    cq.xy = mat2x2(0.8,0.6,-0.6,0.8)*cq.xy;\n    d = sdEllipsoid( cq, vec3(0.06,0.03,0.03) );\n    res.x = smin( res.x, d, 0.03 );\n\n    float eo = 1.0-0.5*smoothstep(0.01,0.04,length((hq.xy-vec2(0.095,0.285))*vec2(1.0,1.1)));\n    res = opU( res, vec4(sdSphere(hq-vec3(0.08,0.28,0.08),0.060),3.0,0.0,eo));\n    res = opU( res, vec4(sdSphere(hq-vec3(0.075,0.28,0.102),0.0395),4.0,0.0,1.0));\n    }\n\t}\n    \n    // ground\n    float fh = -0.1 - 0.05*(sin(pos.x*2.0)+sin(pos.z*2.0));\n    float t5 = fract(atime+0.05);\n    float k = length(pos.xz-cen.xz);\n    float tt = t5*15.0-6.2831 - k*3.0;\n    fh -= 0.1*exp(-k*k)*sin(tt)*exp(-max(tt,0.0)/2.0)*smoothstep(0.0,0.01,t5);\n    float d = pos.y - fh;\n    \n    // bubbles\n    {\n    vec3 vp = vec3( mod(abs(pos.x),3.0),pos.y,mod(pos.z+1.5,3.0)-1.5);\n    vec2 id = vec2( floor(pos.x/3.0), floor((pos.z+1.5)/3.0) );\n    float fid = id.x*11.1 + id.y*31.7;\n    float fy = fract(fid*1.312+atime*0.1);\n    float y = -1.0+4.0*fy;\n    vec3  rad = vec3(0.7,1.0+0.5*sin(fid),0.7);\n    rad -= 0.1*(sin(pos.x*3.0)+sin(pos.y*4.0)+sin(pos.z*5.0));    \n    float siz = 4.0*fy*(1.0-fy);\n    float d2 = sdEllipsoid( vp-vec3(2.0,y,0.0), siz*rad );\n    d2 -= 0.03*smoothstep(-1.0,1.0,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z));\n    d2 *= 0.6;\n    d2 = min(d2,2.0);\n    d = smin( d, d2, 0.32 );\n    if( d<res.x ) res = vec4(d,1.0,0.0,1.0);\n    }\n\n    // candy\n    {\n    float fs = 5.0;\n    vec3 qos = fs*vec3(pos.x, pos.y-fh, pos.z );\n    vec2 id = vec2( floor(qos.x+0.5), floor(qos.z+0.5) );\n    vec3 vp = vec3( fract(qos.x+0.5)-0.5,qos.y,fract(qos.z+0.5)-0.5);\n    vp.xz += 0.1*cos( id.x*130.143 + id.y*120.372 + vec2(0.0,2.0) );\n    float den = sin(id.x*0.1+sin(id.y*0.091))+sin(id.y*0.1);\n    float fid = id.x*0.143 + id.y*0.372;\n    float ra = smoothstep(0.0,0.1,den*0.1+fract(fid)-0.95);\n    d = sdSphere( vp, 0.35*ra )/fs;\n    if( d<res.x ) res = vec4(d,5.0,qos.y,1.0);\n    }\n    \n\n    return res;\n}\n\n\nvec4 castRay( in vec3 ro, in vec3 rd, float time )\n{\n    vec4 res = vec4(-1.0,-1.0,0.0,1.0);\n\n    float tmin = 0.5;\n    float tmax = 20.0;\n    \n\t#if 1\n    // raytrace bounding plane\n    float tp = (3.5-ro.y)/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\t#endif    \n    \n    float t = tmin;\n    for( int i=0; i<256 && t<tmax; i++ )\n    {\n        vec4 h = map( ro+rd*t, time );\n        if( abs(h.x)<(0.0005*t) )\n        { \n            res = vec4(t,h.yzw); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float time )\n{\n    float res = 1.0;\n\n    float tmax = 12.0;\n    #if 1\n    float tp = (3.5-ro.y)/rd.y; // raytrace bounding plane\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\t#endif    \n    \n    float t = 0.02;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, time ).x;\n        res = min( res, 16.0*h/t );\n        t += clamp( h, 0.05, 0.40 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, float time )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, time ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, time ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, time ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, time ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e,time).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float time )\n{ \n    // sky dome\n    vec3 col = vec3(0.9, 0.4, 0.25) - max(rd.y,0.0)*0.5;\n    // sky clouds\n    vec2 uv = 1.5*rd.xz/rd.y;\n    float cl  = 1.0*(sin(uv.x)+sin(uv.y)); uv *= mat2(0.8,0.6,-0.6,0.8)*2.1;\n          cl += 0.5*(sin(uv.x)+sin(uv.y));\n    col += 0.1*(-1.0+2.0*smoothstep(-0.1,0.1,cl-0.4));\n    // sky horizon\n\tcol = mix( col, vec3(0.9, 0.7, .5), exp(-10.0*max(rd.y,0.0)) );    \n    \n\n    // scene geometry\n    vec4 res = castRay(ro,rd, time);\n\t\n    if( res.y>-0.5 )\n    {\n        float t = res.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, time );\n        vec3 ref = reflect( rd, nor );\n        float focc = res.w;\n        \n        // material        \n\t\tcol = vec3(0.2);\n        float ks = 1.0;\n\n        if( res.y>4.5 )  // candy\n        { \n             col = vec3(0.07,0.024,0.0); \n             vec2 id = floor(5.0*pos.xz+0.5);\n\t\t     col += 0.018*cos((id.x*11.1+id.y*37.341) + vec3(0.0,1.0,2.0) );\n             col = max(col,0.0);\n             focc = clamp(4.0*res.z,0.0,1.0);\n        }\n        else if( res.y>3.5 ) // eyeball\n        { \n            col = vec3(0.0);\n           \n        } \n        else if( res.y>2.5 ) // iris\n        { \n            col = vec3(0.2);\n             col = vec3(sin(iTime)*.5 + .5, 0.0, cos(iTime)*.5 + .5)*.25;\n\n        } \n        else if( res.y>1.5 ) // body\n        { \n            col = mix(vec3(0.08,0.05,0.002)*0.9,vec3(0.18,0.05,0.02),res.z*res.z);\n            col = mix(col,vec3(0.14,0.09,0.06), (1.0-res.z)*smoothstep(-0.15, 0.15, -href));\n            col = vec3(0.0);\n            \n        }\n\t\telse // terrain\n        {\n            // base green            \n            col = vec3(0.023,0.040,0.009)*1.08;\n            float f = 0.2*(-1.0+2.0*smoothstep(-0.2,0.2,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z)));\n            col += f*vec3(0.01,0.1,0.51);\n            ks = 0.5 + pos.y*0.15;\n            \n\t\t\t// footprints            \n            vec2 mp = vec2(pos.x-0.5*(mod(floor(pos.z+0.5),2.0)*2.0-1.0), fract(pos.z+0.5)-0.5 );\n            float mark = 1.0-smoothstep(0.1, 0.5, length(mp));\n            mark *= smoothstep(0.0, 0.1, floor(time) - floor(pos.z+0.5) );\n            col *= mix( vec3(1.0), vec3(0.5,0.5,0.4), mark );\n            ks *= 1.0-0.5*mark;\n        }\n        \n        // lighting (sun, sky, bounce, back, sss)\n        float occ = calcOcclusion( pos, nor, time )*focc;\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        \n        vec3  sun_lig = normalize( vec3(0.6, 0.35, 0.5) );\n        float sun_dif = clamp(dot( nor, sun_lig ), 0.0, 1.0 );\n        vec3  sun_hal = normalize( sun_lig-rd );\n        float sun_sha = calcSoftshadow( pos, sun_lig, time );\n\t\tfloat sun_spe = ks*pow(clamp(dot(nor,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float sky_spe = ks*smoothstep( 0.0, 0.5, ref.y )*(0.04+0.96*pow(fre,4.0));\n        float bou_dif = sqrt(clamp( 0.1-0.9*nor.y, 0.0, 1.0 ))*clamp(1.0-0.1*pos.y,0.0,1.0);\n        float bac_dif = clamp(0.1+0.9*dot( nor, normalize(vec3(-sun_lig.x,0.0,-sun_lig.z))), 0.0, 1.0 );\n        float sss_dif = fre*sky_dif*(0.25+0.75*sun_dif*sun_sha);\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 12.00*sun_dif*vec3(1.35,1.00,0.70)*vec3(sun_sha,sun_sha*sun_sha*0.5+0.5*sun_sha,sun_sha*sun_sha);\n        lin +=  2.00*sky_dif*vec3(0.50,0.70,1.00)*occ;\n        lin +=  2.00*bou_dif*vec3(0.20,0.70,0.10)*occ;\n        lin +=  2.00*bac_dif*vec3(0.45,0.35,0.25)*occ;\n        lin +=  4.50*sss_dif*vec3(1.30,1.10,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol +=  9.00*sun_spe*vec3(1.10,0.90,0.70)*sun_sha;\n        col +=  0.50*sky_spe*vec3(0.40,0.60,1.30)*occ*occ;\n      \t\n        col = pow(col,vec3(0.8,0.9,1.0) );\n        \n        // fog\n        col = mix( col, vec3(0.9,0.7,0.2), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n    return col;//vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        // time coordinate (motion blurred, shutter=0.5)\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        float time = iTime;\n #endif\n        time += -2.6;\n        time *= 0.9;\n        \n        // camera\t\n        float cl = sin(0.5*time);\n        float an = 1.57 + 0.7*sin(0.15*time);\n        vec3  ta = vec3( 0.0, 0.65, -0.6+time*1.0 - 0.4*cl);\n        vec3  ro = ta + vec3( 1.3*cos(an), -0.250, 1.3*sin(an) );\n        float ti = fract(time-0.15);\n        ti = 4.0*ti*(1.0-ti);        \n        ta.y += 0.15*ti*ti*(3.0-2.0*ti)*smoothstep(0.4,0.9,cl);\n        \n        // camera bounce\n        float t4 = abs(fract(time*0.5)-0.5)/0.5;\n        float bou = -1.0 + 2.0*t4;\n        ro += 0.06*sin(time*12.0+vec3(0.0,2.0,4.0))*smoothstep( 0.85, 1.0, abs(bou) );\n\n        // camera-to-world rotation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,1.8) );\n        \n        // render\t\n        vec3 col = render( ro, rd, time );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // color grading\n    tot = tot*vec3(1.05,0.75,0.7) + vec3(0.0,0.0,0.0);\n    tot = clamp(tot,0.0,1.0);\n    tot = tot*0.5 + 0.5*tot*tot*(3.0-2.0*tot);\n\n    // vignetting        \n    vec2 q = fragCoord/iResolution.xy;\n    tot *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n\n    // output    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tllSWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tllSWj", "name": "Simple Smooth Mandelbrot Zoom", "author": "snerp", "description": "Use the mouse to pan around\n\nDoes anyone know how to fix the issues where it runs out of floating point precision and looks all pixelated at the end?", "tags": ["fractal", "mandelbrot", "zoom"], "likes": 9, "viewed": 2087, "date": "1564379346", "time_retrieved": "2024-06-20T19:40:23.260869", "image_code": "// set samples from 1-4 for quality selection\n#define SAMPLES 4\n\nvec2 complexMult(vec2 a, vec2 b) {\n\treturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nfloat testMandelbrot(vec2 coord) {\n    // turn this up to 5000 or so if you have a good gpu\n    // for better details but less vibrant color in extreme zoom\n    const int iterations = 912;\n\tvec2 testPoint = vec2(0,0);\n\tfor (int i = 0; i < iterations; i++){\n\t\ttestPoint = complexMult(testPoint,testPoint) + coord;\n        float ndot = dot(testPoint,testPoint);\n\t\tif (ndot > 45678.0) {\n            float sl = float(i) - log2(log2(ndot))+4.0;\n\t\t\treturn sl/float(iterations);\n\t\t}\n\t}\n\treturn 0.0;\n}\n\nvec4 mapColor(float mcol) {\n    return vec4(0.5 + 0.5*cos(2.7+mcol*30.0 + vec3(0.0,.6,1.0)),1.0);\n}\nconst float offsetsD = .35;\n\nconst vec2 offsets[4] = vec2[](\n    vec2(-offsetsD,-offsetsD),\n    vec2(offsetsD,offsetsD),\n    vec2(-offsetsD,offsetsD),\n    vec2(offsetsD,-offsetsD)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // vec2(-1.1553,0.545105) is good too\n    const vec2 zoomP = vec2(-.7457117,.186142);\n    const float zoomTime = 100.0;\n    float tTime = 9.0 + abs(mod(iTime+zoomTime,zoomTime*2.0)-zoomTime);\n    tTime = (145.5/(.0005*pow(tTime,5.0)));\n    vec2 aspect = vec2(1,iResolution.y/iResolution.x);\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    vec4 outs = vec4(0.0);\n    \n    for(int i = 0; i < SAMPLES; i++) {        \n        vec2 fragment = (fragCoord+offsets[i])/iResolution.xy;    \n        vec2 uv = aspect * (zoomP + tTime * (fragment - mouse));\n        outs += mapColor(testMandelbrot(uv));\n    }\n\tfragColor = outs/float(SAMPLES);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tllSWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tllSWS", "name": "Surreal Cloud Flight", "author": "peet", "description": "My first muck about with volumetric rendering... so much fun! Looking forward to some more experiments ;-)\nUsing IQ's awesome 3D noise function.\nEdit: Tweaked visuals, improved performance", "tags": ["raymarching", "noise", "volume", "cloud", "volumetric", "flight"], "likes": 36, "viewed": 590, "date": "1564172169", "time_retrieved": "2024-06-20T19:40:24.460205", "image_code": "///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n\n#define FLIGHT_SPEED 15.0\n\n///////////////////////////////////////////////////////////////////////////////////\n\nstruct Material {\n    vec3 colour;\n    float diffuse;\n    float specular;\n};\n    \nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n    \nstruct Light {\n    vec3 pos;\n    vec3 colour;\n};\n    \nstruct Result {\n    vec3 pos;\n    vec3 normal;\n    Material mat;\n    vec4 fog;\n};\n\n///////////////////////////////////////////////////////////////////////////////////\n\nMaterial g_NoMaterial = Material(vec3(1.0, 0.0, 1.0), 0.0, 1.0);\n\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat blerp(float x, float y0, float y1, float y2, float y3) {\n\tfloat a = y3 - y2 - y0 + y1;\n\tfloat b = y0 - y1 - a;\n\tfloat c = y2 - y0;\n\tfloat d = y1;\n\treturn a * x * x * x + b * x * x + c * x + d;\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat perlin(float x, float h) {\n\tfloat a = floor(x);\n\treturn blerp(mod(x, 1.0),\n\t\trand(vec2(a-1.0, h)), rand(vec2(a-0.0, h)),\n\t\trand(vec2(a+1.0, h)), rand(vec2(a+2.0, h)));\n}\n\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// IQ's noise functions\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\n#define MARCH_ITERATIONS \t320\n#define MARCH_DELTA\t\t\t0.05\n#define MARCH_DELTA2\t\t1.01\n\nResult g_result;\n\nfloat mist(vec3 p, int LOD)\n{   \n    vec3 p2 = p;\n    p *= 0.2;\n    float weight = 0.25;\n    float totalweight = 0.0;\n    float value = 0.0;\n    for (int i=0; i<LOD; i++)\n    {\n        totalweight += weight;\n        value += noise(p)*weight;    \n        p *= 2.03;\n        weight *= 0.6;\n    }\n            \n    return (value/totalweight + abs(p2.y)*0.1 + abs(p.x)*0.0003 - 0.1);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nResult raymarch_query(Ray ray, int iterations, float delta)\n{\n    Result result = Result(ray.pos+ray.dir*10000.0, vec3(0.0, 0.0, 0.0), g_NoMaterial, vec4(0.0, 0.5, 0.0, 0.0));    \n    float dist = 0.0;\n    float fog=0.0;\n    float dstalpha = 0.0;\n    float srcalpha = 0.0;\n    const float densitythreshold = 0.70;\n    const float densityscale = 100.0/(1.0-densitythreshold);\n    \n    vec3 lighting = vec3(-1.0, -1.0, 1.0);\n    //vec3 lighting2 = vec3(1.0, 0.0, 1.0);\n    lighting = normalize(lighting);\n    \n\tfor (int i=0; i<iterations; i++)\n    {           \n        // the 2 values of the fog at the query position and one shifted slightly toward the light\n\t\tfloat v1 = mist(ray.pos, 6);\n\t\tfloat v2 = mist(ray.pos + lighting*0.3, 5);\n\t\t//float v3 = mist(ray.pos + lighting2*0.3);\n        \n\t\tfloat value=0.0;;\n        float vmax=0.7;\n        float vmin=0.5;\n            \n        if (v1 >= vmax)\n            value = 1.0;\n        else if (v1 <= vmin)\n            value = 0.0;\n        else\n            value = (v1-vmin)/(vmax-vmin);\n            \n        value=value*value;\n                        \n        // density is the value times the step\n       \n        float density = clamp(value*delta*0.7, 0.0, 1.0);\n        density*=clamp(delta*4.0, 0.0, 1.0);\n        // update the alpha\n        srcalpha = density;\n        \n        if (srcalpha>0.01)\n        {\n            // the colour of the fog is dependent on its density, dark grey = high density, white = low\n            vec3 fogcolour = mix(vec3(0.9), vec3(0.0, 0.0, 0.1), value); \n\n            // add light reflected from the sun\n            //fogcolour += clamp((v2-v1)*33.0, 0.0, 1.0)*vec3(1.0, 0.7, 0.3)*1.0;\n            //fogcolour += clamp((v3-v1)*6.0, 0.0, 1.0)*vec3(0.9, 0.0, 0.0)*1.0;\n\n            // some bi-directional lighting - totally unreal but looks really funky mixed with the fog colour\n            if ((v2-v1) >= 0.0)\n            {\n                fogcolour += (v2-v1)*(v2-v1)*250.0*vec3(1.0, 0.3, 0.0)*1.0;\n                fogcolour += pow((v2-v1), 3.0)*1000.0*vec3(1.0, 0.3, 0.0)*1.0;\n            }\n            else\n            {\n                fogcolour += (v1-v2)*(v1-v2)*66.0*vec3(0.0, 0.5, 1.0)*1.0;\n                fogcolour += pow((v1-v2), 3.0)*500.0*vec3(1.0, 1.0, 1.0)*1.0;\n            }\n            \n            \n            if (dstalpha == 0.0)\n            {\t// first sample with some density in it\n                result.fog.xyz = fogcolour;\n                dstalpha = srcalpha;\n            }\n            else\n            {\n                // modify the destingation alpha, based on the current srcalpha\n                float prevdstalpha = dstalpha;\n                dstalpha = dstalpha + srcalpha*(1.0 - dstalpha);\n                result.fog.xyz = mix(fogcolour, result.fog.xyz, prevdstalpha/dstalpha);\n                //result.fog.xyz += fogcolour*density;            \n            }\n        }\n        if (dstalpha>0.9)\n        {\n\t\t   \tresult.fog.w = dstalpha;\n    \t\treturn result;            \n        }\n             \n        ray.pos += ray.dir*delta;\n        delta*=MARCH_DELTA2;\n    }\n            \n   \tresult.fog.w = dstalpha;\n    return result;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nvec3 raymarch(Ray inputray)\n{\n    vec3 colour = vec3(0.0, 0.0, 0.0);\n    Ray ray=inputray;        \n    g_result = raymarch_query(ray, MARCH_ITERATIONS, MARCH_DELTA);\n    \n//    colour = vec3(g_result.fog.w);\t\n//    colour = g_result.fog.xyz;    \n    colour = mix(vec3(0.0, 0.15, 0.3), g_result.fog.xyz, g_result.fog.w);       \n    //colour = mix(vec3(0.0), g_result.fog.xyz, g_result.fog.w);       \n            \n    return colour;    \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// main loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{           \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    Ray ray;\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    float speed = FLIGHT_SPEED;\n    float roll = 0.5;\n    float time = iTime + 4.0;\n    \n    float ft = time-1.0;\n\tvec3 p0 = vec3(12.0 - perlin(ft*0.25, 7.5)*24.0, 3.0 - perlin(ft*0.25, 8.5)*6.0, 0.0);  \n    ft+=0.5;\n\tvec3 p1 = vec3(12.0 - perlin(ft*0.25, 7.5)*24.0, 3.0 - perlin(ft*0.25, 8.5)*6.0, 0.0); \n    vec3 dir = (p1-p0) + vec3(0.0, 0.0, 4.0);\n    dir = normalize(dir);\n    vec3 up = vec3(dir.x*roll, 1.0, 0.0);\n    up = normalize(up);\n    vec3 right = cross(dir, up);\n    right = normalize(right);\n    up = cross(right, dir);\n    up = normalize(up);\n    \n    ray.pos = vec3(0.0, 0.0, time*speed) + p0;\n    ray.dir = dir*1.0 + up*uv.y + right*uv.x;\n    ray.dir = normalize(ray.dir);\n        \n    float dither = 0.0;\n    dither = 0.5*hash1(uint(fragCoord.x+iResolution.x*fragCoord.y)+uint(iResolution.x*iResolution.y)*uint(iFrame));//Updated with iFrame dimension    \n    ray.pos += ray.dir*dither;\n    \n    fragColor.xyz = raymarch(ray);  \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tllSWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tllXDX", "name": "Mandelbulb Hell World", "author": "96logda", "description": "This is based on other Mandelbulb worlds shaders I have made.", "tags": ["procedural", "3d", "fractal", "mandelbulb", "hell", "ambientocclusion", "mengersponge", "world", "softshadow", "labyrinth"], "likes": 4, "viewed": 103, "date": "1564513822", "time_retrieved": "2024-06-20T19:40:24.460205", "image_code": "//Copyright (c) 2019-07-22 - 2019-07-30 by Angelo Logahd\n//Portfolio: https://angelologahd.wixsite.com/portfolio\n//Based on https://www.iquilezles.org/www/articles/menger/menger.htm\n\n#define PI\t\t\t\t\t3.14\n\n#define saturate(x) \t\tclamp(x, 0.0, 1.0)\n#define dot2(x) \t\t\tdot(x, x)\n\n#define MENGER_ITERATIONS\t2\n#define SOFT_SHADOW_STEPS \t16\n\n#define INTERSECT_STEPS\t\t300\n#define INTERSECT_MIN_DIST\t0.0001\n#define INTERSECT_MAX_DIST\t100.0\n\n\nvec2 rotate2D(vec2 p, float angle)\n{\n    float sRot = sin(angle);\n    float cRot = cos(angle);\n    return p * cRot + p.yx * sRot * vec2(-1.0, 1.0);\n}\n\nfloat sdPlane(vec3 p, float height)\n{\n   \treturn p.y - height;\n}\n\n//https://www.shadertoy.com/view/ltfSWn\nfloat mandelbulb(vec3 p)\n{\n    vec3 w = p;\n    float m = dot2(w);\n    float dz = 1.0;\n    for(int i = 0; i < 3; ++i)\n    {\n\t\tdz = 8.0 * pow(sqrt(m), 7.0) * dz + 1.0;\n        float r = length(w);\n        float b = 8.0 * acos(w.y / r);\n        float a = 8.0 * atan(w.x, w.z);\n        w = p + pow(r, 8.0) * vec3(sin(b) * sin(a), cos(b), sin(b) * cos(a));\n\n        m = dot(w,w);\n\t\tif (m > 255.0)\n\t\t{\n            break;\n\t\t}\n    }\t\n    return 0.1 * log(m) * sqrt(m) / dz;\n}\n\nvec4 opU(vec4 d1, vec4 d2)\n{\n     return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec4 map(in vec3 p)\n{\t\n    float ground = sdPlane(p, 1.8);\n    \n    p.xz = mod(p.xz + 5.0, 2.0) -1.0;\n    p.y = mod(p.y + 1.0, 2.0) - 1.0;\n\t\n    float d = mandelbulb(p - vec3(0.0, 0.5, 0.0));\n    vec4 res = vec4(d, 1.0, 0.0, 2.0);\n\t\n    float s = 1.0;\n    for(int i = 0; i < MENGER_ITERATIONS; ++i)\n    { \n        vec3 a = mod(p * s, 2.0) - 1.0;\n        s *= 4.0;\n        vec3 r = abs(1.0 - 3.0 * abs(a));\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 1.1) / s;\n\n        if(c > d)\n        {\n            d = c;\n            res = vec4(d, min(res.y, 0.2 * da * db * dc), 0.0, 3.0);\n        }\n    }\n    \n    return opU(res, vec4(ground, 1.0, 0.0, 1.0));\n}\n\nvec4 intersect(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n    vec4 h = vec4(1.0);\n    for (int i = 0; i < INTERSECT_STEPS; i++ )\n    {\n\t\tif(h.x < INTERSECT_MIN_DIST || t > INTERSECT_MAX_DIST) \n\t\t{\n\t    \tbreak;\n\t\t}\n\t\n        h = map(ro + rd * t);\n        res = vec4(t, h.yzw);\n        t += h.x;\n    }\n\n    if (t > INTERSECT_MAX_DIST) \n    {\n\t\tres = vec4(-1.0);\n    }\n    \n    return res;\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < SOFT_SHADOW_STEPS; ++i)\n    {\n\t\tvec3 pos = ro + rd * t;\n        float h = map(pos).x;\n        res = min(res, float(SOFT_SHADOW_STEPS) * h / t);\n        if(res < 0.001)\n\t\t{\n\t    \tbreak;\n\t\t}\n        t += clamp(h, 0.01, 0.2);\n    }\n    return saturate(res);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    vec3 n;\n    n.x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    n.y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    n.z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n    return normalize(n);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float k)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < SOFT_SHADOW_STEPS; ++i)\n    {\n\t\tvec3 pos = ro + rd * t;\n        float h = map(pos).y;\n        res = min(res, k * h / t);\n        if(res < 0.001)\n\t\t{\n\t    \tbreak;\n    \t}\n        t += clamp(h, 0.01, 0.2);\n    }\n    return saturate(res);\n}\n\nvec3 GetMaterialColor(in vec3 p, float materialID)\n{\n    if (materialID < 1.5)\n    {\n         vec3 texRGB = texture(iChannel0, p.xz * 5.0, 0.0).rgb;\n         return texRGB * 0.25 + vec3(0.1, 0.0, 0.0);\n    }\n    else if (materialID < 2.5)\n    {\n         vec3 texRGB = texture(iChannel1, p.xy, 0.0).rgb;\n         return texRGB * 0.25;\n    }\n    else if (materialID < 3.5)\n    {\n         vec3 texRGB = texture(iChannel2, p.xy * 0.5, 0.0).rgb;\n         return texRGB * 0.5;\n    }\n    return vec3(0.0);\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 color = vec3(0.0);\n    vec4 res = intersect(ro,rd);\n    if(res.x > 0.0)\n    {\n        const vec3 light1 = vec3(0.0, 0.0, -0.2);\n        \n        vec3 pos = ro + res.x * rd;\n        \n        vec3 normal = calcNormal(pos);\n        vec3 reflection = reflect(rd, normal);\n        \n        float occ = res.y;\n        float shadow1 = softshadow(pos + 0.01 * normal, light1);\n        \n        vec3 baseColor = GetMaterialColor(pos, res.w);\n        vec3 ambient = vec3(0.2) * baseColor;      \n\n        vec3 diffuse = baseColor * shadow1 * occ;\n        color = diffuse + (ambient * occ);\n    }\n\n    return pow(color, vec3(0.4545));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 p = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\t\n    vec2 mouseXY = iMouse.xy / iResolution.xy;\n    \n    // camera\n    vec3 ro = vec3(3.5 * 3.5, 2.9, -2.0);\n    vec3 ww = normalize(vec3(0.0, mouseXY.y * 5.0 * PI, 0.0) - ro);\n    ww.xz = rotate2D(ww.xz, -mouseXY.x * 2.0 * PI);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n\n    ro.x -= iTime * 0.1; //Camera movement\n\t\n \tvec3 color = render(ro + vec3(0.0, -1.0, 0.0), rd); \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tllXDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tllXWH", "name": "风扇", "author": "hanyeah", "description": "风扇", "tags": [], "likes": 1, "viewed": 64, "date": "1562808166", "time_retrieved": "2024-06-20T19:40:24.817878", "image_code": "float addAlpha(float a1, float a2){\n\treturn a1 + a2 - a1 * a2;\n}\n\nfloat getColor0(float x0, float t, float omiga){\n\tfloat xt = omiga * t;\n    float xt0 = omiga * (t - 0.1);\n    float pi2 = 3.1415926 * 2.0;\n    float n = floor((xt - x0)/pi2);\n    float factor = 1.0 / (xt - xt0);\n    float xx = n * pi2 + x0;\n    float color = 0.0;\n    float f = 0.0;\n    while(xx > xt0 && xx >= x0){\n    \tf = factor * (xx - xt0);\n        color = addAlpha(color , f * f);\n        if(color >= 1.0){\n            color = 1.0;\n            break;\n        }\n        xx = xx - pi2;\n    }\n    return color;\n}\n\nfloat getColor(float x, float y, float t, float omiga, float m){\n    float PI = 3.1415926;\n\tfloat x0 = atan(y, x) + PI;\n    float step = PI * 2.0 / m;\n    float color = 0.0;\n    for(float i = 0.0; i < m; i = i + 1.0){\n        color = addAlpha(color , getColor0(x0 + i * step, t, omiga));\n        if(color >= 1.0){\n            color = 1.0;\n            break;\n        }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float PI = 3.1415926;\n    float rot = 3.0;\n    float omiga = 2.0 * PI * rot;\n    float t = iTime;\n    float x = uv.x - 0.5;\n    float y = uv.y - 0.5;\n    float r = 0.5;\n    \n    float color = getColor(x, y, t, omiga, 3.0);\n\n    // Output to screen\n    fragColor = vec4(color, 0.0, 0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tllXWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tllXWr", "name": "RTS_LAYOUT1", "author": "gchipunov", "description": " NICE BACKGROUND BASE 1", "tags": ["background", "base", "1"], "likes": 1, "viewed": 55, "date": "1562620373", "time_retrieved": "2024-06-20T19:40:25.157447", "image_code": "//GEORGIY CHIPUNOV, NICE BACKGROUND\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c = fragColor;\n   //   c.w = length(p = p/iResolution.y - .5);\n //\n    \n   // c = texture( iChannel0, vec2(atan(p.y,p.x), .3/c.w)+iTime )*c.w;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,0,1));\n\n    if(fragCoord.x > 0.5 )\n    {\n    col.r = smoothstep(c.w,iTime,iResolution.y);\n    \n    }\n    // Output to screen\n    float fNumPixelsX = iResolution.x ;\n    float fNumPixelsY = iResolution.y ;\n    \n    if(fragCoord.x > 555.0 && fragCoord.y > 200.0 )\n    {\n    col.r = smoothstep(c.w,iTime,iResolution.y);\n    fragColor.b = fragCoord.x;\n      fragColor.g = fragCoord.y;\n    }\n    else if(fragCoord.x > (fNumPixelsX/2.0 )+100.0)\n    {\n    col.r = smoothstep(c.w,iTime,iResolution.y);\n    fragColor.r = fragCoord.x;\n      fragColor.g = fragCoord.y;\n    }\n    // ADD MORE ELSE  IF FOR MORE LAYERS\n    \n    //EXAMPLE 1\n    // else if(fragCoord.x > (fNumPixelsX-500.0) )\n   // {\n  //  col.r = smoothstep(c.w,iTime,iResolution.y);\n   // fragColor.b = fragCoord.x;\n   //   fragColor.g = fragCoord.y;\n   //     fragColor = vec4(col,1.0);\n  //  }\n    //\n    // EXAMPLE 2 _OVERRIDE!\n  //  if(fragCoord.x >  (fNumPixelsX-50.0) )\n  //  {\n  //  col.r = smoothstep(c.w,iTime,iResolution.y);\n  //  fragColor.b = fragCoord.x;\n  //    fragColor.g = fragCoord.y;\n  //    //  fragColor = vec4(col,1.0);\n  //  }\n    \n    \n    \n    else\n    {\n    fragColor = vec4(col,1.0);\n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tllXWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tllXz2", "name": "Fuzzy Voronoi?", "author": "anastadunbar", "description": "I was thinking about smooth color conversion with color palettes.", "tags": ["metaballs", "coloring", "position", "colorpalette", "neighbours"], "likes": 6, "viewed": 187, "date": "1563624164", "time_retrieved": "2024-06-20T19:40:25.157447", "image_code": "float usin(float x){return(sin(x)+1.)/2.;}\n#define time iTime\n#define SIZE 5\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 points[]=vec2[](\n\t\tvec2(.5,-.75),\n\t\tvec2(1.,-1.),\n\t\tvec2(-1.,1.),\n\t\tvec2(sin(time),cos(time)),\n\t\tvec2(-sin(time),cos(time))\n\t);\n\tvec3 colors[]=vec3[](\n\t\tvec3(1.,.2,.2),\n\t\tvec3(1.,.9,.3),\n\t\tvec3(.1,.5,.7),\n\t\tvec3(.1,.7,.2),\n\t\tvec3(1.,1.,1.)\n\t);\n\tvec2 p=floor(fragCoord),\n\t     uv=(p/iResolution.xy)-.5;\n\tuv.x/=iResolution.y/iResolution.x;\n\tuv*=5.;\n\tbool fuzzy=(mod(p.x+p.y,16.)>=1.)&&(mod(p.x-p.y,16.)>=1.);\n\tif(fuzzy){\n\t\tvec3 col=vec3(0.);\n\t\tfloat sum=0.,\n\t\t      gamma=2.2;\n\t\tfor(int i=0;i<SIZE;i++){\n\t\t\tfloat dist=length(uv-points[i]);\n\t\t\tvec3 color=pow(colors[i],vec3(gamma));\n\t\t\tif(dist<1e-6){col=color;sum=1.;break;} //Avoid dividing by zero.\n\t\t\tdist=1./pow(dist,2.+(usin(time)*5.));\n\t\t\tcol+=color*dist;\n\t\t\tsum+=dist;\n\t\t}\n\t\t//float betweens=1./sum;\n\t\tcol/=sum;\n\t\tfragColor=vec4(pow(col,1./vec3(gamma)),1.);\n\t}else{\n\t\tfloat minV=length(uv-points[0]);\n\t\tint minI=0;\n\t\tfor(int i=1;i<SIZE;i++){\n\t\t\tfloat dist=length(uv-points[i]);\n\t\t\tvec3 color=colors[i];\n\t\t\tif(dist<minV){\n\t\t\t\tminI=i;\n\t\t\t\tminV=dist;\n\t\t\t}\n\t\t}\n\t\tfragColor=vec4(colors[minI],1.);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tllXz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tllXzj", "name": "TDM Seascape slimyparty remix", "author": "fields37", "description": "remix of https://www.shadertoy.com/view/Ms2SD1\ndifferent colors", "tags": ["water", "blood", "slimyparty"], "likes": 4, "viewed": 506, "date": "1563604381", "time_retrieved": "2024-06-20T19:40:26.109065", "image_code": "/*\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\nconst int NUM_STEPS = 8;\nconst float PI\t \t= 3.141592;\nconst float EPSILON\t= 1e-3;\n#define EPSILON_NRM (0.1 / iResolution.x)\n\n// sea\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.35,0.19,0.22);\nconst vec3 SEA_WATER_COLOR = vec3(1.,0.1,0.1);\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    return vec3(.3, 1.0-e.y, 0.6+(1.0-e.y)*0.9);\n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n        \n    vec3 reflected = getSkyColor(reflect(eye,n));    \n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    color += vec3(specular(n,l,eye,60.0));\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y = 1.-uv.y;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.3 + iMouse.x*0.01;\n        \n    // ray\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \n    vec3 ori = vec3(0.0,3.5,time*5.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.15;\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // color\n    vec3 color = mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n    \tpow(smoothstep(0.0,-0.05,dir.y),0.3));\n        \n    // post\n\tfragColor = vec4(pow(color,vec3(0.75)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tllXzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlsSR7", "name": "Behind Glass Bricks", "author": "104", "description": "modulation in layers", "tags": ["2d"], "likes": 25, "viewed": 320, "date": "1562515509", "time_retrieved": "2024-06-20T19:40:26.109065", "image_code": "// credits: Dave_Hoskins Hash functions: https://www.shadertoy.com/view/4djSRW\n\nconst float layers = 4.;\nconst float layerDrift = 0.3;\n\nconst float PI = 3.141592654;\n\nmat2 rot2D(float r){\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\nfloat nsin(float x) {return sin(x)*.5+.5; }\nvec2 nsin(vec2 x) {return sin(x)*.5+.5; }\nvec3 hash32(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n// returns { RGB, dist to edge (0 = edge, 1 = center) }\nvec4 disco(vec2 uv) {\n    float v = abs(cos(uv.x * PI * 2.) + cos(uv.y *PI * 2.)) * .5;\n    uv.x -= .5;\n    vec3 cid2 = hash32(vec2(floor(uv.x - uv.y), floor(uv.x + uv.y))); // generate a color\n    return vec4(cid2, v);\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord)\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord / R;\n    uv.x *= R.x / R.y; // aspect correct\n\n    float t = (iTime+200.) * .6; //t = 0.;\n    uv *= 21.;\n    uv *= rot2D(sin(t*2.)*.03);\n    uv.x += t*3.;\n    \n    // start with tile pattern\n    vec2 uv2 = uv;\n    uv2 += t*layerDrift;// sync with below; pattern drift\n    uv2 = sin(uv2-PI*.5)*.5+.5;// sync with below. actually i have no idea why -PI/2\n    o.r = min(uv2.x,uv2.y);// grid pattern\n    o = vec4(pow(o.r, .4));\n    o = clamp(o, 0.,.6)/.6;// plateau\n\n    // layer in bricks\n    for(float i = 0.; i <=layers; ++i) {\n        uv += sin(uv+t*layerDrift)*(1.+sin(t)*.3);\n        vec4 d = disco(uv);\n        d.a = pow(d.a, .2);//sin(t*1.2+i)*.5+.5\n        o *= clamp(d*d.a,.25, 1.);\n    }\n\n    // post\n    o = clamp(o,.0,1.);\n    vec2 N = (fragCoord / R )- .5;// norm coords\n    o = 1.-pow(1.-o, vec4((layers - .5) * 12.));// curve\n    o.rgb += hash32(fragCoord + iTime).r*.07;//noise\n    o *= 1.1-step(.4,abs(N.y));\n    o *= 1.0-dot(N,N*2.);// vingette\n    o.a = 1.;\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlsSR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlsSzj", "name": "rcread  slime puddles (mod) remx", "author": "fields37", "description": "drips\nremix of https://www.shadertoy.com/view/Ml2Xzc\nslower camera movement, faster bubbling", "tags": ["slime", "puddly", "slimyparty"], "likes": 4, "viewed": 739, "date": "1563603401", "time_retrieved": "2024-06-20T19:40:26.109065", "image_code": "// Created by randy read - rcread/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//\tmod of https://www.shadertoy.com/view/MtjXzc\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5 -iTime*.01;\n    vec3 c = cos(vec3(iTime*.06,\n                  iTime*.045,\n                  iTime*.015)*10.)*2.+2.;\n    for (int i = 0; i < 27; i++) {\n        vec3 p = vec3(uv*float(i),float(i));\n//      c += abs( cos( ( c + sin( p )).yzx ) );\n    \tc += abs( vec3( cos(c.y+sin(p.x)),\n                   cos(c.z+sin(p.z)),\n                   -cos(c.x+sin(p.y)) ) );\n    }\n    fragColor = vec4((c*.04-.66)*3.,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlsSzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlsXR8", "name": "dynamic rescaling", "author": "Mishka", "description": "variant of \"double warp\" (line 12 is different)", "tags": ["interactive"], "likes": 2, "viewed": 74, "date": "1562118743", "time_retrieved": "2024-06-20T19:40:26.109065", "image_code": "float fract_sin_dot (vec2 uv) {\n        return fract(sin(dot(\n                         uv.xy,\n                         // vec2(sin(4.*uv.x), sin(10.*uv.y)),\n                         // vec2(sin(4.*uv.x), uv.y),\n                         0.1*iMouse.xy+vec2(1.0,1.0)))*\n        4. + 0.5*iTime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy)*(5.0*(sin(0.25*iTime)+1.0)+1.0);\n\n    vec3 color = vec3(fract_sin_dot( uv ),\n                      fract_sin_dot( vec2(sin(4.*uv.x), sin(10.*uv.y)) ),\n                      fract_sin_dot( vec2(sin(4.*uv.x), uv.y) ));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlsXR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlsXWf", "name": "bonzomatic test run #8", "author": "Exca", "description": "Testing bonzomatic for asm19 shader showdown.", "tags": ["bonzomatic"], "likes": 4, "viewed": 138, "date": "1564524448", "time_retrieved": "2024-06-20T19:40:26.109065", "image_code": "\nvec3 noise(vec2 p, vec3 bcol)\n{\n  \n  float t = iTime*0.2;\n  vec2 off1 = vec2( 0.3, 0.4)*t;\n  vec2 off2 = vec2( 0.2, -0.3)*t;\n  vec2 off3 = vec2( 0.1, 0.2)*t;\n  vec2 off4 = vec2( -0.1, 0.1)*t;\n  \n  \n  float n1 = texture(iChannel0, p+off1).r;\n  float n2 = texture(iChannel0, p+off2).r*0.75;\n  float n3 = texture(iChannel0, p+off3).r*0.5;\n  float n4 = texture(iChannel0, p+off4).r*0.25;\n  \n  float n = smoothstep( 0.15, 0.5, (n1+n2+n3+n4)/5.0);\n  return n * bcol;\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy;\n  vec2 ouv = uv;\n  uv *=2.;\n  uv -=1.;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec3 col = vec3(0.);\n  \n  float b = texture(iChannel1, vec2(0.,0.1)).r*10.;\n  \n  vec3 bcol = mix( vec3(1., 0.6, 0.), vec3(0., 0.6, 1.), abs(sin(cos(iTime)+uv.y* uv.x + iTime+b)));\n  \n  float t = iTime;\n  \n  float n1 = sin(  uv.x +t)*0.5 + cos(uv.x*31.)*texture(iChannel1, ouv/3.+iTime).r*0.02;\n  float n2 = sin(  uv.x*2.0+t*1.0 )*0.4 + cos(uv.x*31.)*texture(iChannel1, ouv/3.+iTime).r*.03;\n  float n3 = sin(  uv.x*3.0+t*1.0 )*0.3 + cos(uv.x*31.)*texture(iChannel1, ouv/3.+iTime).r*.04;\n  float n4 = sin(  uv.x*4.0+t*1.0 )*0.2 + cos(uv.x*31.)*texture(iChannel1, ouv/3.+iTime).r*.05;\n  float n5 = sin(  uv.x*5.+t*1.0 )*0.1 + cos(uv.x*31.)*texture(iChannel1, ouv/3.+iTime).r*.06;\n  \n  n1 = uv.y > n1 ? length(uv.y-n1)*40. : 3.5 *length(uv.y-n1);\n  n2 = uv.y > n2 ? length(uv.y-n2)*60. : 3.5 *length(uv.y-n1);\n  n3 = uv.y > n3 ? length(uv.y-n3)*80. : 3.5 *length(uv.y-n1);\n  n4 = uv.y > n4 ? length(uv.y-n4)*100. : 3.5 *length(uv.y-n1);\n  n5 = uv.y > n5 ? length(uv.y-n5)*120. : 3.5 *length(uv.y-n1);\n  \n  col += bcol*0.5/n1+vec3(1.)*6./n1 * noise(uv*0.05,bcol);\n  col += bcol*0.5/n2+vec3(1.)*6./n2 * noise(uv*0.15,bcol);\n  col += bcol*0.5/n3+vec3(1.)*6./n3 * noise(uv*0.3,bcol);\n  col += bcol*0.5/n4+vec3(1.)*6./n4 * noise(uv*0.5,bcol);\n  col += bcol*0.5/n5+vec3(1.)*6./n5 * noise(uv*0.7,bcol);\n  \n  \n  \n  fragColor = vec4(col, 1.);\n}\n\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlsXWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlsXzf", "name": "Hash noise", "author": "vstelegin", "description": "Trigonometry free noise", "tags": ["noise", "random"], "likes": 2, "viewed": 270, "date": "1563821980", "time_retrieved": "2024-06-20T19:40:26.405881", "image_code": "\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3  inputs = vec3( uv, iTime * 0.000002 ); \n    float randx = random( inputs );  \n    float randy = random( inputs + vec3(1.0));\n    float randz = random( inputs + vec3(2.0));\n    vec3  luma   = vec3( randx,randy,randz); \n\t\n    \n    fragColor = vec4( luma, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlsXzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlsXzM", "name": "Midpoint Triangle (test 2)", "author": "tgsstdio", "description": "Calculating the triangles/quads required to create a circular hole within a triangle ", "tags": ["triangle", "circle"], "likes": 1, "viewed": 113, "date": "1562597130", "time_retrieved": "2024-06-20T19:40:27.321082", "image_code": "// TIME FUNCTIONS see https://www.shadertoy.com/view/MtXyD2\n\n// CONTROLS NO OF QUADS PER TRI\n\n#define SUBDIVISION_LOOP_IN_SECS 7.0\n#define NO_OF_DIVISIONS 7\n\nconst int sections[NO_OF_DIVISIONS] = int[](\n    6,\n    12,\n    24,\n    30,\n    48,\n    60,        \n    96       \n);    \n\n\n// CONTROLS RADIUS OF INNER HOLE\n\n#define MID_POINT 0.3\n#define RANGE_OF_TRIG_FUNC 0.2\n#define TWO_PI 6.283185307179586476925286766559\n// in hertz (per sec)\n#define FREQUENCY 0.5\n\n// RENDER SCALE\n\nconst float UNIT_SCALE = 4.0;\n\n// https://www.shadertoy.com/view/XsXSz4\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvec2 getMidpoint(vec2 a, vec2 b)\n{\n    vec2 dir = b - a;\n    return a + 0.5 * dir;\n}\n\nvec2 getInnerPoint(vec2 p1, vec2 p2, float ratio)\n{\n    vec2 dir = p2 - p1;\n    return p1 + (ratio * dir);\n}\n\nvec2 getRadialPoint(vec2 centre, vec2 outer, float radius)\n{\n    vec2 n = normalize(outer - centre);    \n    return centre + radius * n;\n}\n\nvec4 drawColouredQuad(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    vec4 outColor = vec4(0,0,0,0);\n    // QUAD 2\n    \t// outer [i+1] -> outer[i] \n    \t// inner [i+1] -> inner[i]\n    \t// inner[i+1], inner[i], outer[i+1]\n    if (sdTriangle(a, b, c, uv) <= 0.0) {       \n    \toutColor += vec4(1,0,1,1);       \n    }            \n   \n   \t// inner[i], outer[i], outer[i+1]    \n    if (sdTriangle(a, c, d, uv) <= 0.0) {       \n    \toutColor += vec4(1,1,0,1);       \n    }        \n    return outColor;\n}\n\nvec4 drawArm(vec2 centre, vec2 uv, vec2 left, vec2 right, float radius, int division)\n{\n    vec2 left_i = getRadialPoint(centre, left, radius);\n    \n    vec2 right_i = getRadialPoint(centre, right, radius);\n    \n    vec2 top_0 = left;\n    vec2 inside_0 = left_i;\n    \n    vec4 outColor = vec4(0,0,0,0);\n\n    float offset = 1. / float(division);\n    for (int i = 1; i < division; i += 1)\n    {\n        vec2 top_1 = getInnerPoint(left, right, float(i) * offset);  \n        vec2 inside_1 = getRadialPoint(centre, top_1, radius); \n\t\toutColor += drawColouredQuad(uv, top_0, inside_0, inside_1, top_1);\n        top_0 = top_1;\n        inside_0 = inside_1;\n    } \n\n    \n    outColor += drawColouredQuad(uv, top_0, inside_0, right_i, right);\n    return outColor;\n}\n\nvec4 drawCorner3(vec2 centre, vec2 uv, vec2 right, vec2 mid, vec2 left, float radius, int noOfQuads)\n{ \n    // QUAD 1\n    vec4 outColor = vec4(0,0,0,0);      \n    outColor += drawArm(centre, uv, left, mid, radius, noOfQuads / 2);\n    outColor += drawArm(centre, uv, mid, right, radius, noOfQuads / 2);        \n    return outColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    // SCREEN CORRECTION TO SQUARE\n    float fov = (iResolution.y / iResolution.x);\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    uv -= 0.5;\n    uv.y *= fov;\n    \n    // SCALE \n    uv *= UNIT_SCALE;   \t     \n    \n   \n    float front = 0.4;\n    float radius = 2.0;\n    vec2 scale = vec2(1,1);    \n    vec2 radialDir = vec2(1,-1); // BOTTOM RIGHT    \n         \n    \n    float halfHeight = radius * sqrt(3.)/4.;\n    float halfWidth = radius * .5;    \n    \n    vec2 a =  vec2(0.,  halfHeight); \n    vec2 b = vec2(-halfWidth, -halfHeight);    \n    vec2 c = vec2(halfWidth, -halfHeight);  \n\n    // INTERSECTION OF MIDPOINT\n    // CENTRE CAN BE ANYTHING\n    vec2 centre = vec2(0., c.y + (halfWidth * 1. / sqrt(3.)));  \n    \n    vec2 mid_a_b = getMidpoint(a, b);\n    vec2 mid_b_c = getMidpoint(b, c);\n    vec2 mid_c_a = getMidpoint(c, a);     \n    \n    // TOP: subdividing sections by value within int array           \n    float gapTimeStep = mod(iTime, SUBDIVISION_LOOP_IN_SECS) / SUBDIVISION_LOOP_IN_SECS;         \n\n    int division = sections[int(gapTimeStep * float(NO_OF_DIVISIONS))];  \n    float innerRadius = MID_POINT + RANGE_OF_TRIG_FUNC * sin( FREQUENCY * TWO_PI * iTime);\n    \n    fragColor += drawCorner3(centre, uv, mid_c_a, a, mid_a_b, innerRadius, division / 3);\n    fragColor += drawCorner3(centre, uv, mid_a_b, b, mid_b_c, innerRadius, division / 3);\n    fragColor += drawCorner3(centre, uv, mid_b_c, c, mid_c_a, innerRadius, division / 3);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlsXzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlXSR2", "name": "Tex-Filtering: Higher Order Bias", "author": "hornet", "description": "bicubic on the left, bilinear on the right.\n4 samples instead of 16 using tex-filtering.\ncalculates mipmapping/bias (control with LMB)\nFor more details, See http://vec3.ca/bicubic-filtering-in-fewer-taps/", "tags": ["texture", "sampling", "catmullrom", "catmull", "rom"], "likes": 3, "viewed": 353, "date": "1563567704", "time_retrieved": "2024-06-20T19:40:28.248237", "image_code": "vec4 sampleTex( vec2 uv, float lambda )\n{\n    return textureLod( iChannel0, uv, lambda );\n}\n\n/*\nfloat Gaussian( float x )\n{\n\tconst float alpha = 4.0;\n\tconst float expv = exp(-alpha); //note: radius = 1.0\n    return max(0.0, (exp(-alpha * x * x) - expv));\n    //return max(0.0, (exp(-alpha * x * x) - expv) / (1.0-expv)); //note: normalisation-factor to always get f(0)=1\n}\nfloat calcweight( vec2 p )\n{\n    return Gaussian( length(p) );\n}\n*/\n\n\n//note: see http://vec3.ca/bicubic-filtering-in-fewer-taps/ for more details\n//note: also ://mate.tue.nl/mate/pdfs/10318.pdf\n//note: polynomials converted to hornerform using wolfram-alpha hornerform()\nvec4 SampleTextureCubic( vec2 uv, vec2 texSize, float lambda )\n{\n    vec2 iTc = uv * texSize;\n    vec2 tc = floor(iTc - 0.5) + 0.5;\n\n    vec2 f = iTc - tc;\n    \n    vec2 f2 = vec2( f * f );\n\tvec2 w0 = f * ( f * ( 0.5 - 1.0/6.0 * f ) - 0.5 ) + 1.0/6.0;\n\tvec2 w1 = (0.5 * f - 1.0) * f2 + 2.0/3.0;\n\tvec2 w2 = f * ( f * (0.5 - 0.5 * f) + 0.5) + 1.0/6.0;\n\tvec2 w3 = (1.0/6.0) * f*f2;\n\n   \tvec2 s0 = w0 + w1;\n    vec2 s1 = w2 + w3;\n \n    vec2 f0 = w1 / s0;\n    vec2 f1 = w3 / s1;\n \n    vec2 t0 = tc - 1.0 + f0;\n    vec2 t1 = tc + 1.0 + f1;\n \n    return\n        (sampleTex( vec2( t0.x, t0.y )/texSize, lambda) * s0.x\n      +  sampleTex( vec2( t1.x, t0.y )/texSize, lambda) * s1.x) * s0.y\n      + (sampleTex( vec2( t0.x, t1.y )/texSize, lambda) * s0.x\n      +  sampleTex( vec2( t1.x, t1.y )/texSize, lambda) * s1.x ) * s1.y;\n}\n\n\n// note: entirely stolen from https://gist.github.com/TheRealMJP/c83b8c0f46b63f3a88a5986f4fa982b1\n//\n// Samples a texture with Catmull-Rom filtering, using 9 texture fetches instead of 16.\n// See http://vec3.ca/bicubic-filtering-in-fewer-taps/ for more details\nvec4 SampleTextureCatmullRom( vec2 uv, vec2 texSize, float lambda )\n{\n    // We're going to sample a a 4x4 grid of texels surrounding the target UV coordinate. We'll do this by rounding\n    // down the sample location to get the exact center of our \"starting\" texel. The starting texel will be at\n    // location [1, 1] in the grid, where [0, 0] is the top left corner.\n    vec2 samplePos = uv * texSize;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n    // Compute the fractional offset from our starting texel to our original sample location, which we'll\n    // feed into the Catmull-Rom spline function to get our filter weights.\n    vec2 f = samplePos - texPos1;\n\n    // Compute the Catmull-Rom weights using the fractional offset that we calculated earlier.\n    // These equations are pre-expanded based on our knowledge of where the texels will be located,\n    // which lets us avoid having to evaluate a piece-wise function.\n    vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n    vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n    vec2 w3 = f * f * (-0.5 + 0.5 * f);\n    \n    // Work out weighting factors and sampling offsets that will let us use bilinear filtering to\n    // simultaneously evaluate the middle 2 samples from the 4x4 grid.\n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / w12;\n\n    // Compute the final UV coordinates we'll use for sampling the texture\n    vec2 texPos0 = texPos1 - vec2(1,1);\n    vec2 texPos3 = texPos1 + vec2(2,2);\n    vec2 texPos12 = texPos1 + offset12;\n\n    texPos0 /= texSize;\n    texPos3 /= texSize;\n    texPos12 /= texSize;\n\n    vec4 result = vec4(0,0,0,0);\n    result += sampleTex( vec2(texPos0.x,  texPos0.y), lambda) * w0.x * w0.y;\n    result += sampleTex( vec2(texPos12.x, texPos0.y), lambda) * w12.x * w0.y;\n    result += sampleTex( vec2(texPos3.x,  texPos0.y), lambda) * w3.x * w0.y;\n\n    result += sampleTex( vec2(texPos0.x,  texPos12.y), lambda) * w0.x * w12.y;\n    result += sampleTex( vec2(texPos12.x, texPos12.y), lambda) * w12.x * w12.y;\n    result += sampleTex( vec2(texPos3.x,  texPos12.y), lambda) * w3.x * w12.y;\n\n    result += sampleTex( vec2(texPos0.x,  texPos3.y), lambda) * w0.x * w3.y;\n    result += sampleTex( vec2(texPos12.x, texPos3.y), lambda) * w12.x * w3.y;\n    result += sampleTex( vec2(texPos3.x,  texPos3.y), lambda) * w3.x * w3.y;\n\n    return result;\n}\n\n//TODO: filter-index\nvec4 SampleTexture( vec2 uv, float bias )\n{\n    vec2 texSize = vec2(textureSize(iChannel0,0).xy);\n\n\tfloat rho = max( length(texSize*dFdx(uv.xy)),\n\t                 length(texSize*dFdy(uv.xy)) );\n\tfloat lambda = log2(rho);\n    lambda += bias;\n    lambda = clamp( lambda, 0.0, 16.0 ); //note: assuming max-miplevels\n    \n    float lambda0 = floor(lambda);\n    float lambda1 = ceil(lambda);\n    vec2 texSize0 = texSize / exp2( lambda0 );\n    vec2 texSize1 = texSize / exp2( lambda1 );\n\n    //return texture( iChannel0, uv, bias ); //linear\n    \n    /*\n    vec4 s0 = SampleTextureCatmullRom( uv, texSize0, lambda0 );\n    vec4 s1 = SampleTextureCatmullRom( uv, texSize1, lambda1 );\n    /*/\n    vec4 s0 = SampleTextureCubic( uv, texSize0, lambda0 );\n    vec4 s1 = SampleTextureCubic( uv, texSize1, lambda1 );\n\t/**/\n    \n    float t = fract(lambda);\n    return mix( s0, s1, t );\n    \n\t//return textureLod(iChannel0, uv, lambda );\n}\n\n//note: uniform pdf rand [0;1[\nvec3 hash32n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec3(p.x * p.y * 95.4307, p.x * p.y * 97.5901, p.x * p.y * 93.8369));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 sample_uv = uv;\n    sample_uv.x = mod( sample_uv.x, 0.5 );\n   \tsample_uv += 0.01 * vec2( cos(iTime), sin(iTime) );\n    sample_uv *= 0.06125;\n    //sample_uv *= (iMouse.z>0.0) ? iMouse.x / iResolution.x*2.5 : 1.0;\n    \n    float texbias = (iMouse.z > 0.5 ) ? iMouse.x / iResolution.x * 0.5 : 0.0;\n    texbias *= 25.0;\n    \n    vec4 smpl;\n    if ( uv.x < 0.5 )\n    {\n        smpl = SampleTexture( sample_uv, texbias );\n    }\n    else\n    {\n        smpl = texture( iChannel0, sample_uv, texbias );\n    }\n\n    fragColor = smpl;\n    fragColor -= step(abs(uv.x-0.5), 0.001);\n    fragColor.rgb += (hash32n(uv+fract(iTime))+hash32n(uv+0.1337*fract(iTime))-1.0)/255.0; //dither output\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlXSR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlXSWM", "name": "Signed Distance Helix", "author": "willalexander", "description": "Helix intersection using ray marching", "tags": ["sdf"], "likes": 7, "viewed": 161, "date": "1563142604", "time_retrieved": "2024-06-20T19:40:28.248369", "image_code": "float a = 0.2;\nfloat r = 1.0;\nfloat helixThickRad = 0.3;\nfloat threshold = 0.001;\nfloat zeroThreshold = 0.001;\n\nfloat TWOPI = 6.283;\nfloat PI = 3.14159;\n\nvec3 sphereP = vec3(0.0, 0.0, 0.0);\nfloat sphereRad = 1.0;\n\n\nfloat f(float t, vec3 P)\n{\n   \tfloat a = 0.8 + 0.7 * sin(2.0 * iTime);\n    return r*r + length(P)*length(P) + 2.0*P.x*r*sin(t) - 2.0*P.z*r*cos(t) + a*a*t*t - 2.0*a*t*P.y;\n}\n\nfloat f1(float t, vec3 P)\n{\n    float a = 0.8 + 0.7 * sin(2.0 * iTime);\n    return 2.0*P.x*r*cos(t) + 2.0*P.z*r*sin(t) + 2.0*a*a*t - 2.0*a*P.y;\n}\n\nbool sameSign(float a, float b)\n{\n    if((a >= 0.0)&&(b >= 0.0)) return true;\n    if((a < 0.0)&&(b < 0.0)) return true;\n    return false;\n}\n\n\nfloat findSolution(float t1, float t2, vec3 P)\n{\n   \tif((f1(t1, P) > 0.0)&&(f1(t2, P) < 0.0)) return 1000000.0;\n    \n\tfloat thalf;\n\tfor(int i = 0; i < 10; i++)\n\t{\n\t\tthalf = 0.5 * (t1 + t2);\n\t\tfloat gradHalf = f1(thalf, P);\n\t\tif(abs(gradHalf) < 0.01) break;\n\n\t\tfloat d2_1 = f1(t1, P);\n\t\tfloat d2_half = gradHalf;\n\t\tfloat d2_2 = f1(t2, P);\n        \n\t\tif(sameSign(d2_1, d2_half) == false)\n\t\t{\n\t\t\tt2 = thalf;\n\t\t\tcontinue;\n\t\t}\n\n\t\tt1 = thalf;\n\t}\n\n\treturn thalf;\n}\n\nfloat helixDist(vec3 P, out float tout)\n{\n   \tfloat a = 0.8 + 0.7 * sin(2.0 * iTime);\n    \n\tfloat t0 = P.y / a;\n\t\n\tfloat closest = f(t0, P);\n\tfloat closestT = t0;\n\n    \n    for(float i = 0.0; i < 4.0; i+=1.0)\n    {\n        float tTest = findSolution(t0 + (i - 2.0)*PI, t0 + (i - 1.0)*PI, P);\n        float dTest = f(tTest, P);\n        \n        if(dTest < closest)\n        {\n            closest = dTest;\n\t\t\tclosestT = tTest;\n        }\n    }\n  \n\ttout = closestT;\n\treturn sqrt(closest);\n}\n\nvec3 helixPos(float t)\n{\n    float a = 0.8 + 0.7 * sin(2.0 * iTime);\n    \n    return vec3(-1.0 * r * sin(t), a * t, r * cos(t));\n}\n\nbool rayMarchHelix(vec3 rayPos, vec3 rayDir, out vec3 Pout, out vec3 Nout, out int countout)\n{   \n    vec3 P = rayPos;\n    float t;\n    float dist = helixDist(P, t) - helixThickRad;\n    \n    int count = 0;\n    \n    while(dist > threshold)\n    {\n        P += dist * rayDir;\n        if(P.z > 2.2) return false;\n            \n        dist = helixDist(P, t) - helixThickRad;\n       \n        if(count == 128) return false;\n        \n        count++;\n    }\n    \n    Pout = P + dist * rayDir;\n    Nout = normalize(Pout - helixPos(t));\n    countout = count;\n    \n    return true;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 imgPlane = 5.0 * (2.0 / iResolution.x) * vec2(fragCoord.x - 0.5*iResolution.x, fragCoord.y - 0.5 * iResolution.y);\n   \n    vec3 rayPos = vec3(0.0, 0.0, -5.0);\n    vec3 rayDir = normalize(vec3(imgPlane.x, imgPlane.y, 5.0));\n    \n    vec3 P, N;\n    int count;\n    \n    if(rayMarchHelix(rayPos, rayDir, P, N, count))\n    {\n        float radiance = 0.0;\n        vec3 L;\n        float ldiff, lspec;\n    \t    \n        for(int i = 0; i < 2; i++)\n        {\n            if(i == 0)\n            {\n               L = vec3(3.0, 2.0, -3.0);\n               ldiff = 200.0;\n               lspec = 0.4;\n            }\n            \n            if(i == 1)\n            {\n                L = vec3(-10.0, 2.0, 10.0);\n              \tldiff = 200.0;\n               \tlspec = 0.4;\n            }\n        \n       \t\tvec3 PL = L - P;\n        \n       \t\tfloat diff = (ldiff  / (4.0 * PI * pow(length(PL), 2.0))) * (1.0 / PI) * dot(normalize(PL), N);\n       \t\tif(diff < 0.0) diff = 0.0;\n            \n       \t\tvec3 EP = normalize(P - rayPos);\n       \t\tvec3 specVec = EP - 2.0 * (dot(N, EP) * N);\n       \t\tfloat spec = lspec * pow(dot(specVec, normalize(PL)), 5.0);\n       \t\tif(spec < 0.0) spec = 0.0;\n       \n           \tradiance += (diff + spec);\n       \t}\t\n            \n    \tfragColor = vec4(vec3(radiance), 1.0);\n    }\n    \n    else fragColor = vec4(0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlXSWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlXSzX", "name": "Neon Portal", "author": "104", "description": "It's not dangerous trust me", "tags": ["2d", "doubledare"], "likes": 6, "viewed": 195, "date": "1563734280", "time_retrieved": "2024-06-20T19:40:28.248369", "image_code": "const float PI = 3.14159;\nconst float PI2 = PI*2.;\n\nfloat dtoa(float d, float amount){\n    return 1. / clamp(d*amount, 1., amount);\n}\nfloat nsin(float x) {\n    return cos(x)*.5+.5;\n}\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat check(float a, float r, float t) {\n    if (r < 0.0001) return 0.;\n    float z = 1./r;\n    z-=t;\n    a += sin(z);\n    return min(min(nsin(a*4.),nsin(a*14.)),pow(nsin(z*24.),.4));\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    vec2 N = uv;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float t = -iTime + 2.;\n\n    float sd = 1e6;\n    float a = atan(uv.x,uv.y);\n    \n    float ch = check(a+t*.1, length(uv), t);\n    o.rgb = N.xyy * vec3(ch) * pow(length(uv),2.) * 4.;\n    \n    float sg = 3.;\n    float r = .44;\n    float bh = 1.;\n    for (int i = 0; i < 40; ++ i) {\n        float id = hash11(float(i));\n        sg = -sg;\n        r *= .96;\n        float h = nsin(a += id*PI2)*.05+.01;\n        h *= bh-= .03;\n        float rout = nsin((a)*18.)*pow(nsin(8.*a+t*sg),2.)*h+r;\n        sd = abs(length(uv)-rout);\n        o[i%3] += dtoa(sd, nsin(t)*1000. + 250.);\n    }\n\n    o.g += o.r*.4;\n    o = clamp(o,o-o,o-o+1.);\n    o = pow(o,o-o+.5);\n    o.rgb -= (hash32(fragCoord+iTime))*.1;//noise\n    o *= 1.-length(12.*pow(abs(N), vec2(4.)));// vingette\n    o.a = 1.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlXSzX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlXXDl", "name": "KING SLIME", "author": "yasuo", "description": "dragon quest shit", "tags": ["3d", "raymarching", "game"], "likes": 8, "viewed": 357, "date": "1564592149", "time_retrieved": "2024-06-20T19:40:28.248369", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// Edge detection code from:https://www.shadertoy.com/view/MsSGD1\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define hash(h) fract(sin(h) * 43758.5453123)\n#define EDGE_WIDTH 0.05\n#define PI 3.141592653589793\n#define SLIME_BODY_COLOR vec3(0.1,0.9,1.0)\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) {\n        return val1;\n    }\n    return val2;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec3 crownTex(vec2 uv) {\n    vec3 col = vec3(1.0,0.1,0.9);\n    col = (uv.x>=-0.3 && uv.x< 0.3)? vec3(0.0,1.0,0.0):col;\n    uv *= rot(radians(90.0));\n    col = (uv.x>=-0.3 && uv.x< 0.3)? vec3(0.0,1.0,0.0):col;\n    return col;   \n}\n\nvec4 sdCrown(vec3 p, vec3 crownPos) {\n    int num = 8;\n    float res = 4.0;\n    float prevres = 0.0;\n    float deg = 360.0/float(num);\n    float crownDist = 1.0;\n    \n    for(int i = 0; i<num; i++){\n        float rad = radians(deg*float(i));\n        float x = cos(rad)*crownDist;\n        float z = sin(rad)*crownDist;\n        float sp = length(p+vec3(x,-0.75,z)+crownPos)-0.15;\n        res = min(res,sdRoundCone((p+vec3(x,0.0,z)+crownPos),0.23,0.1,0.5));\n        res = min(res,sp);\n    }\n    \n    float rcd1 = sdRoundedCylinder(p+vec3(0.0,0.2,0.0)+crownPos, 0.58,0.28,0.07);\n    res = min(res,rcd1);\n    \n    float rcd2 = sdRoundedCylinder(p+vec3(0.0,-0.6,0.0)+crownPos, 0.45,0.6,0.02);\n    float rcd3 = sdRoundCone(p+vec3(0.0,-1.2,0.0)+crownPos, 0.23,0.1,0.5);\n    \n    vec4 crownBtm = vec4(vec3(1.1,0.9,0.0),res);\n    vec4 crownMid = vec4(crownTex(p.xz),rcd2);\n    vec4 crownTop = vec4(vec3(1.1,0.9,0.0),rcd3);\n    \n    return combine(combine(crownBtm,crownMid),crownTop);\n}\n\nvec3 slimeFaceTex(vec3 p) {\n    vec2 uv = p.xy;\n    vec2 uvRef = uv;\n    vec3 col = SLIME_BODY_COLOR;\n    \n    uvRef.x = abs(uvRef.x)-0.21;\n    float eyeBg = length(uvRef+vec2(0.0,0.6))-0.15;\n    float eye = length(uvRef+vec2(0.0,0.6))-0.13;\n    float eyeBall = length(uvRef+vec2(0.0,0.6))-0.03;\n    uvRef = uv;\n    \n    float mouth = sdArc( (uvRef+vec2(0.0,0.2))*rot(radians(225.0)), vec2(0.6,0.61), vec2(0.2,0.3), 0.71, 0.085 );\n    float toungue = sdArc( (uvRef+vec2(0.0,0.2))*rot(radians(225.0)), vec2(0.6,0.6), vec2(0.16,0.3), 0.7, 0.05 );\n    \n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.01,0.015,eyeBg) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.015,eye) );\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.01,0.015,eyeBall) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.015,mouth) );\n    col = mix( col, vec3(0.7,0.0,0.0), 1.0-smoothstep(0.01,0.015,toungue) );  \n\n    col = (p.z>0.01)? col:SLIME_BODY_COLOR;\n    \n    return col;\n}\n\nvec4 sdBody(vec3 p) {\n    float anim = sin(iTime*5.0)*0.015;\n    float rcd = sdRoundedCylinder(p+vec3(0.0,1.2,0.0), 1.0+anim,1.1,0.02);\n    vec4 body = vec4(slimeFaceTex(p),rcd);\n    \n    p.x = abs(p.x)-0.55;\n    vec4 cheek = vec4(SLIME_BODY_COLOR,length(p+vec3(0.0,0.9,-1.65))-(0.3+anim*2.0));\n    \n    return combine(body,cheek);\n}\n\nfloat sinOut(float t) {\n  return sin(t * PI*0.5);\n}\n\nfloat elasticOut(float t) {\n  return sin(-13.0 * (t + 1.0) * PI*0.5) * pow(2.0, -10.0 * t) + 1.0;\n}\n\nfloat bounceOut(float t) {\n  const float a = 4.0 / 11.0;\n  const float b = 8.0 / 11.0;\n  const float c = 9.0 / 10.0;\n\n  const float ca = 4356.0 / 361.0;\n  const float cb = 35442.0 / 1805.0;\n  const float cc = 16061.0 / 1805.0;\n\n  float t2 = t * t;\n\n  return t < a\n    ? 7.5625 * t2\n    : t < b\n      ? 9.075 * t2 - 9.9 * t + 3.4\n      : t < c\n        ? ca * t2 - cb * t + cc\n        : 10.8 * t * t - 20.52 * t + 10.72;\n}\n\n// A smart way to control the animation. function is from \"http://qiita.com/gaziya5/items/29a51b066cb7d24983d6\"\nfloat animscene(in float t, float w, float s) {\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nvec4 map(vec3 p){\n    float animTime = mod(iTime,3.5);\n\tfloat jump = 0.0;\n    float jumpDist = 0.5;\n\tjump -= sinOut(animscene(animTime, 0.5, 0.3))*jumpDist;\n\tjump += bounceOut(animscene(animTime, 0.8, 0.6))*jumpDist;\n    \n    float jump2 = 0.0;\n\tjump2 -= sinOut(animscene(animTime, 0.52, 0.3))*jumpDist;\n\tjump2 += bounceOut(animscene(animTime, 0.82, 0.6))*jumpDist;\n    \n    float jump3 = 0.0;\n    float floorHeight = 0.2;\n\tjump3 += sinOut(animscene(animTime, 1.02, 0.3))*floorHeight;\n\tjump3 -= elasticOut(animscene(animTime, 1.22, 2.5))*floorHeight;\n    \n    vec3 crownPos = vec3(0.0,-0.3+jump2,0.0);\n    vec4 crown = sdCrown(p,crownPos); \n    vec4 body = sdBody(p+vec3(0.0,jump,0.0));\n    \n    float height = (sin(p.x*jump3)+sin(p.z*jump3));\n    vec4 f = vec4(vec3(0.0,0.9,0.3),p.y+3.0+height);\n    return  combine(combine(crown,body),f);\n}\n\nvec3 normalMap(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        map(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n        map(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n        map(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n    ));\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = map(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\n// from simon green and others\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.15;\n\n    float a = 0.0;\n    float weight = 4.;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - map(p + n*d).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 uv = p;\n    \n    float time = iTime*2.0;\n    \n    vec3 ro = vec3( 3.5*cos(0.1*time + 6.0), 0.0, -0.5+5.5*sin(0.1*time + 6.0) );\n    vec3 ta = vec3( 0.0, -0.4, -0.7 );\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    float zoom = 1.5;\n    vec3 rd = ca * normalize( vec3(p.xy,zoom) );\n    \n    float t, dist;\n    float lastDistEval = 1e10;\n    float edge = 0.0;\n    t = 0.0;\n    vec3 distPos = ro+rd;\n    vec4 distCl = vec4(0.0);\n    for(int i = 0; i < 64; i++){\n        distCl = map(distPos);\n        dist = distCl.w;\n        t += dist;\n        distPos = ro+rd*t;\n        \n        if (lastDistEval < EDGE_WIDTH && dist > lastDistEval + 0.001) {\n            edge = 1.0;\n        }\n        if (dist < lastDistEval) lastDistEval = dist;\n        if(dist < 0.01 || dist > 30.0) break;\n    }\n\n    vec3 color;\n    float shadow = 1.0;\n    if(dist < 1.0){\n        // lighting\n        vec3 lightDir = vec3(0.0, 1.0, 0.0);\n        vec3 light = normalize(lightDir + vec3(0.5, 0.0, 0.9));\n        vec3 normal = normalMap(distPos);\n\n        // difuse color\n        float diffuse = clamp(dot(light, normal), 0.5, 1.0);\n        float lambert = max(.0, dot( normal, light));\n        \n        // ambient occlusion\n        float ao = ambientOcclusion(distPos,normal);\n        \n        // shadow\n        shadow = shadowMap(distPos + normal * 0.001, light);\n\n        // result\n        color += vec3(lambert);\n        color = ao*diffuse*(distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n        \n    }else{\n        color =.84*max(mix(vec3(0.6,0.9,1.0)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n        \n        uv.x += iTime*0.1;\n        float triangleWave = asin(sin(uv.x*3.2))*0.2;\n        color = mix( color, vec3(0.4,0.2,0.01), 1.0-smoothstep(0.01,0.015,p.y+0.05+triangleWave) );\n        \n        triangleWave = asin(sin(uv.x*3.7))*0.2;\n        color = mix( color, vec3(0.5,0.2,0.01), 1.0-smoothstep(0.01,0.015,p.y-0.05+triangleWave) );\n    \tuv = p;\n    }\n\n    // rendering result\n    float brightness = 1.5;\n    vec3 dst = (color * max(0.8, shadow))*brightness;\n    \n    // add edge detection result\n    dst = mix(dst,vec3(0.1,0.1,0.1),edge);\n    \n    // UI\n    vec3 uicol = vec3(0.0);\n    vec2 dialogPos = vec2(1.05,-0.65);\n    float dialogBg = sdBox(uv+dialogPos, vec2(0.5,0.1));\n    uicol = mix( uicol, vec3(0.9), 1.0-smoothstep(0.1,0.09,dialogBg) );\n    uicol = mix( uicol, vec3(0.1), 1.0-smoothstep(0.12,0.1,dialogBg) );\n    \n    float fakeChar0 = sdBox(uv+ vec2(1.5,dialogPos.y), vec2(0.05,0.05));\n    uicol = mix( uicol, vec3(0.5), 1.0-smoothstep(0.01,0.015,fakeChar0) );\n    float fakeChar1 = length(uv+ vec2(1.35,dialogPos.y))-0.05;\n    uicol = mix( uicol, vec3(0.5), 1.0-smoothstep(0.01,0.015,fakeChar1) );\n    float fakeChar2 = sdBox(uv+ vec2(1.2,dialogPos.y), vec2(0.05,0.05));\n    uicol = mix( uicol, vec3(0.5), 1.0-smoothstep(0.01,0.015,fakeChar2) );\n    float fakeChar3 = length(uv+ vec2(1.05,dialogPos.y))-0.05;\n    uicol = mix( uicol, vec3(0.5), 1.0-smoothstep(0.01,0.015,fakeChar3) );\n    float fakeChar4 = sdBox(uv+ vec2(0.9,dialogPos.y+0.04), vec2(0.05,0.005));\n    uicol = mix( uicol, vec3(0.5+sin(iTime*9.0)*0.5), 1.0-smoothstep(0.01,0.015,fakeChar4) );\n    \n    fragColor = vec4(dst+uicol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlXXDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlXXRN", "name": "Hypnotyze", "author": "Kapsy", "description": "My fu***ng first shader!!!", "tags": ["kapsy"], "likes": 5, "viewed": 306, "date": "1562234800", "time_retrieved": "2024-06-20T19:40:28.248369", "image_code": "//////MY FU***NG FIRST SHADER\n#define time iTime*0.1\n\nmat2 rot(float a){\n  return mat2(cos(a),sin(a),-sin(a),cos(a));\n  }\n  \nfloat smin(float a, float b, float h){\n   float k = clamp((a-b)/h*0.5+0.5,0.0,1.0);\n   return mix(a,b,k)-k*(1.0-k)*h;\n  }\n  \nvec3 smin(vec3 a, vec3 b, float h){\n   vec3 k = clamp((a-b)/h*0.5+0.5,0.0,1.0);\n   return mix(a,b,k)-k*(1.0-k)*h;\n  }\n  float  cyl(vec3 p, float b, float c){\n  return max(length(p.xy)-b, abs(p.z)-c);\n  }\n\n\nfloat box(vec3 p){\n  p = abs(p)-vec3(0.6);\n  return max(p.x,max(p.y,p.z));\n  }\n  \n  float SDF(vec3 p){\n  for(int i=0; i<5; ++i){\n  p-=0.1+0.1*float(i);\n  p.xz*=rot(time+float(i));\n  p.zy*=rot(time-float(i));\n  p = smin(p,-p, -0.4);\n  p-=mix(0.9,1.5,sin(time));\n  }\n  float circle =  length(p)-0.8;\n  return min(circle,box(p));\n   \n  }\n  \nvec3 get_norm(vec3 p){\n  vec2 eps =  vec2(0.001,0);\n  return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n  }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n  vec2 u3 = uv;\n  uv = fract(abs(uv));\n  vec2 u2 = uv;\n  \n  u2.x+=fract(time);\n  u2.y += mix(0.05,0.0,sin(fract(time*6.0)));\n  \n  ///////////////////////////////////////////////////////\n  vec3 ro = vec3(0,0,-10); vec3 p = ro;\n  vec3 ppp = p;\n  vec3 rd = normalize(vec3(-uv,1.));//mix(uv,-uv,sin(fract(time))),1.)); \n  vec3 col = vec3(0);\n  vec3 tex = vec3(texture(iChannel0,u2));\n  col+=tex-0.2;\n  \n  float shad = 0.0;\n  float dd =0.0;\n  for(int i=0; i<100; ++i){\n    float d = SDF(p);\n    if(d<0.001){ \n     shad = float(i)/100.0;      \n    break;\n    }\n    if(dd>100.0) { dd=100.0; break; }\n    p+=d*rd;\n    dd+=d;\n    }\n    vec3 n = get_norm(p);\n    vec3 l = normalize(-vec3(1,3,2));\n    vec3 h = normalize(l-rd);\n   float fog = 1.0-clamp(dd/100.0,0.0,1.0);\n    col+=(dot(n,l)*0.5+0.5)*fog * (vec3(6,0.3,0.2)* + vec3(5,0.7,9)*pow(max(0.0,dot(n,h)),4.0)+4.0*pow(max(0.0,dot(n,h)),50.0));\n    float back = clamp(SDF(p+rd),0.0,1.0);\n    col+=back*vec3(0.0,mix(1.0,2.0,sin(time)),0.0);\n     \n       float dv;\n        u3.y+=0.050;    \n        dv = 10.0;\n       col.gb-=mod(dv,uv.x/uv.y+tan(time))/4.0;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlXXRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlXXRs", "name": "Rotating Tetrahedron ", "author": "96logda", "description": "A rotating tetrahedron.", "tags": ["3d", "tetrahedron", "pyramid", "primitive"], "likes": 1, "viewed": 74, "date": "1563898607", "time_retrieved": "2024-06-20T19:40:28.254538", "image_code": "//Copyright (c) 2019-07-23 by Angelo Logahd\n//Portfolio: https://angelologahd.wixsite.com/portfolio\n//My Original version: http://glslsandbox.com/e#56328.1\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\nmat2 rotate(float angle)\n{\n    return mat2(cos(angle + vec4(0.0, 33.0, 11.0, 0.0)));\n}\n\nvec3 hsv(float hue, float saturation, float value)\n{\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(hue) + t.xyz) * 6.0 - vec3(t.w));\n    return value * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), saturation);\n}\n\nfloat plane(vec3 p, vec3 orgin, vec3 normal) \n{\n\treturn dot(p - orgin, normal);\n}\n\nfloat tetrahedron(vec3 p, float scale) \n{\n    float a = plane(p, vec3( scale,  scale,  scale), vec3(-1.0,  1.0,  1.0));\n\tfloat b = plane(p, vec3( scale, -scale, -scale), vec3( 1.0, -1.0,  1.0));\n\tfloat c = plane(p, vec3(-scale,  scale, -scale), vec3( 1.0,  1.0, -1.0));\n\tfloat d = plane(p, vec3(-scale, -scale,  scale), vec3(-1.0, -1.0, -1.0));\n\treturn max(max(a, b), max(c, d));\n}\n\nfloat map(vec3 p) \n{\n    p.xy *= rotate(iTime * 0.6);\n\tp.xz *= rotate(iTime * 0.6);\n    return tetrahedron(p, 0.5);\t\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\t\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t\n\tvec3 color = vec3(0.0);\n    \n\tvec3 ro = vec3(uv, -1.0);\n\tvec3 rd = vec3(0,0, 0.5);\n\t\n\tfloat t = 0.0;\n\tfor (int i = 0; i < 35; ++i) \n\t{\n\t    vec3 p = ro + rd * t;\n\t    float d = map(p);\n\t    t += d;\n\t    color += 1.0 / t;\n\t    color *= hsv(uv.x * 10.0, 0.5, 1.0);\n\t    color *= hsv(uv.y * 10.0, 0.5, 1.0);\n\t}\n\t\n\tif (uv.y > 0.0)\n\t{\n\t    color *= 0.5;\n\t}\n\telse\n\t{\n\t    color += vec3(0.0, 0.0, 0.1);\n\t}\n    \n\tfragColor = vec4(pow(color, vec3(0.4545)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlXXRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlXXWB", "name": "Blue noise, value vs angle", "author": "ockiller", "description": "On the right is the noise we get when the classic blue noise values are used as angles. It's still blue noise but coarser (lower frequency). When using blue noise for random rotations it should be better to generate a blue noise tex optimized for angles.", "tags": ["bluenoise"], "likes": 5, "viewed": 252, "date": "1564061013", "time_retrieved": "2024-06-20T19:40:28.254538", "image_code": "void mainImage(out vec4 O, in vec2 u) {\n    vec2 R = iResolution.xy / 2.0,\n         U = u / 1024.0;\n\n    float noise = textureLod(iChannel0, U, 0.0).x;\n    if (u.y < R.y) noise = fract(noise + iTime);\n    if (u.x > R.x) noise = abs(2.0 * noise - 1.0);\n    O = vec4(noise);\n                \n    u = abs(u - R);\n    if (u.x < 1.0 || u.y < 1.0)\n        O.rgb = vec3(0.75);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlXXWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlXXWs", "name": "2d  grass texture with a twist", "author": "TLC123", "description": "2d texture from https://www.shadertoy.com/view/WsSGWd \tCreated by BynaryCobweb\n Strand directionality and length is determined by the angle between the ground and ray direction\nSome rotor wash artifacts on closeup and obviously nothing on the ridges. \n\n\n", "tags": ["2d", "texture", "grass"], "likes": 10, "viewed": 544, "date": "1564602936", "time_retrieved": "2024-06-20T19:40:31.363847", "image_code": "// Fork of \"Procedural walk animation\" by None. https://shadertoy.com/view/-1\n// 2019-07-31 19:07:24\n\n \n\n#define AA 1\n# define PI 3.14159265359\n# define PHI 1.618033988749895\n# define TAU 6.283185307179586\n \n# define PLOTPATH 0\n \nvec2 UV;\n//------------------------------------------------------------------\nfloat sdPlane(vec3 p) {\n    return p.y;}\n \n\nfloat pathterrain(float x,float z){\n    // Common height function for path and terrain\n    return (\n        abs(sin(x*.5 )*1.+cos(z*.3 )*0.6)\n        +abs(cos(x*3.+z )*0.1+sin(x-z*.2 )*0.4))*.7\n         ;}\n vec3 timefly(float t) {\n    // main path Called from many places\n    t*=.80;\n\tt += (.125 + sin(t * .125));\n\tvec3 v =\n\tvec3(sin(t / 50.) * 20., 0., cos(t / 25.) * 24.) +\n\t\tvec3(sin(t / 17.1) * 07., 0., cos(t / 17.1) * 05.) +\n\t\tvec3(sin(t / 8.1) * 6., 0., cos(t / 8.1) * 8.) +\n\t\tvec3(cos(t / 3.) * 3.,0., sin(t / 3.) * 2.)\n        +vec3(cos(t  )*2.,0., sin(t  )*2. );\n    v.y=pathterrain(v.x,v.z);\n    return v        ;\n} \n \n\n\nfloat lpnorm(vec3 p, float s) {\n\treturn pow(\n\t\t(\n\t\t\tpow(abs(p.x), s) +\n\t\t\tpow(abs(p.y), s) +\n\t\t\tpow(abs(p.z), s)),\n\t\t1.0 / s);\n}\n\n \n//------------------------------------------------------------------\n \n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r) {\n    return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat TTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\nfloat sdPlane(vec3 p, vec4 n) {\n    // n must be normalized\n    return dot(p, n.xyz) + n.w;\n}\nfloat opSubtraction(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat opOnion( in float sdf, in float thickness) {\n    return abs(sdf) - thickness;\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n//----------------------------------------------------------------------\n\n//----------------------------------------------------------------------\n\n \n        \n\nfloat plant( in vec3 pos, vec4 type) {\n    float l =  length(pos.xz)*max(1.,abs( 4.* pos.y-1.)) ;\n    pos=pos\n        +vec3(l,0,l)*(0.2+sin(pos.x+pos.y+iTime*0.6)*0.2)\n        +vec3(0,l,0)*(0.1+sin(pos.y+iTime*1.6)*0.1)\n                     ;\n    float d, di, plane, lay;\n    d = l;\n    if ((l - type.w) < 0.) {\n\n        for (float i = 0.3; i < 0.28+type.w*0.5; i += +(.101*1./3.)) {\n\n            di = sdTorus(pos + vec3(0, -i * type.z*0.6, 0), vec2(0.18 * type.w + i * type.y, i * 1.5*type.z * type.w));\n\n            di = opOnion(di, type.x * 0.125 * type.w);\n            lay = i * (23.416 * 1.7);\n            plane = sdPlane(vec3(pos.x, pos.y, pos.z), vec4(sin(lay), 0, cos(lay), (-0.5+fract(lay*10.))*0.5*type.x));\n            di = opIntersection(di,\n\n                abs(plane)   -  ( sin(clamp( (min(l,type.w)/type.w )*7.28,.3,6.28) ))*type.x);\n\n            d = min(d, di);\n            if(d<0.01)break;\n\n        }\n        d = opIntersection(d, sdSphere(pos + vec3(0, -type.w * 0.9, 0), type.w));\n\n    }\n\n    return d;\n}\n//-------------------------------------------\nvec2 foliage( in vec3 pos) {\n    \n    pos.y=pos.y-pathterrain(pos.x,pos.z);\n    \n    float Strand, Spread, Lift, Size;\n    float sqr = 1.;\n    float d = length(pos.xz)+1.;\n    vec3 pfract = fract(pos / sqr) * sqr;\n    vec3 pround = round(pos / sqr) * sqr + vec3(sqr * 0.5, 0, sqr * 0.5);\n    vec3 mos = vec3(pfract.x, pos.y, pfract.z);\n\n    float i = (pos - pfract).x;\n    float j = (pos - pfract).z;\n\n    Strand = 0.01 + fract( sin(i * 12. + j*9.9) * 9.219869) * 0.0325;\n    Spread = 0. + fract( sin (i * 12. + j*9.9) * 99.24927) * .3;\n    Lift = .2 + fract(  sin(i * 42. + j*32.9) * 199.210930) * .5;\n    Size = .2 + fract( sin (i * 2. + j) * 99.) * .7;\n\n    d = min(d, plant(mos - vec3(sqr * 0.5, 0., sqr * 0.5), vec4(Strand, Spread * 1.1, Lift, Size)));\n\n      d = max(d, -(length(pfract.xz - vec3(sqr * 0.5, 0., sqr * 0.5).xz) -0.01));\n\n    return vec2(d, 3);\n\n} \n \nvec2 map( in vec3 pos) {\n\tvec2 res = vec2(pos.y-pathterrain(pos.x,pos.z), 1.0);\n\t//vec2 bush =  foliage(pos);\n    //res=res.x<bush.x?res:bush;\n    \n \treturn res;\n}\n\n\n\n\n\n\nvec2 castRay( in vec3 ro, in vec3 rd) {\n\tfloat tmin = .10;\n\tfloat tmax = 50.0;\n\tfloat t = tmin;\n\tfloat m = -1.0;\n\tfor (int i = 0; i < 80; i++) {\n\t\tfloat precis = 0.0001 * t;\n\t\tvec2 res = map(ro + rd * t);\n\t\tif (res.x < precis || t > tmax) break;\n\t\tt += res.x * .7;\n\t\tm = res.y;\n\t}\n\tif (t > tmax) m = -1.0;\n\treturn vec2(t, m);\n}\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor (int i = 0; i < 32; i++) {\n\t\tfloat h = map(ro + rd * t).x;\n\t\tres = min(res, 8.0 * h / t);\n\t\tt += clamp(h, 0.02, 0.10);\n\t\tif (res < 0.005 || t > tmax) break;\n\t}\n\treturn clamp(res, 0.0, 1.0);\n}\nvec3 calcNormal( in vec3 pos) {\n\tvec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n\treturn normalize(e.xyy * map(pos + e.xyy).x +\n\t\te.yyx * map(pos + e.yyx).x +\n\t\te.yxy * map(pos + e.yxy).x +\n\t\te.xxx * map(pos + e.xxx).x);\n}\nfloat calcAO( in vec3 pos, in vec3 nor) {\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n\t\tfloat hr = 0.01 + 0.12 * float(i) / 4.0;\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = map(aopos).x;\n\t\tocc += -(dd - hr) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n \n//------------------------------------------------------------------\n// 2d Grass texture from https://www.shadertoy.com/view/WsSGWd \tCreated by BynaryCobweb\n//------------------------------------------------------------------\n\n\n\n#define BLADES_SPACING 0.003\n#define JITTER_MAX 0.004\n// depends on size of grass blades in pixels\n#define LOOKUP_DIST 5\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\n \n//----------------------------------------------------------------------------------------\n// Hash without Sine  https://www.shadertoy.com/view/4djSRW\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n\n\n\n//----------------------------------------------------------------------------------------\n//// Created by inigo quilez - iq/2014\n//----------------------------------------------------------------------------------------\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat noise13( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( \n        mix(\n                mix( hash13( i + vec3(0.0,0.0,0.0) ), \n                     hash13( i + vec3(1.0,0.0,0.0) ), u.x),\n                mix( hash13( i + vec3(0.0,1.0,0.0) ), \n                     hash13( i + vec3(1.0,1.0,0.0) ), u.x)\n               , u.y),\n              mix(\n                mix( hash13( i + vec3(0.0,0.0,1.0) ), \n                     hash13( i + vec3(1.0,0.0,1.0) ), u.x),\n                mix( hash13( i + vec3(0.0,1.0,1.0) ), \n                     hash13( i + vec3(1.0,1.0,1.0) ), u.x)\n               , u.y)\n        \n         , u.z)\n        ;\n}\n\nvec3 noise33(  vec3 p )\n{\n    p=p+10000.;\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u;\n    u.x = f.x*f.x*(3.0-2.0*f.x);\n    u.y = f.y*f.y*(3.0-2.0*f.y);\n    u.z = f.z*f.z*(3.0-2.0*f.z);\n\n    return mix( \n        mix(\n                mix( hash33( i + vec3(0.0,0.0,0.0) ), \n                     hash33( i + vec3(1.0,0.0,0.0) ), u.x),\n                mix( hash33( i + vec3(0.0,1.0,0.0) ), \n                     hash33( i + vec3(1.0,1.0,0.0) ), u.x)\n               , u.y),\n              mix(\n                mix( hash33( i + vec3(0.0,0.0,1.0) ), \n                     hash33( i + vec3(1.0,0.0,1.0) ), u.x),\n                mix( hash33( i + vec3(0.0,1.0,1.0) ), \n                     hash33( i + vec3(1.0,1.0,1.0) ), u.x)\n               , u.y)\n        \n         , u.z)\n        ;\n}\nvec3 fbm33( vec3 p )\n{\n   \n     mat3 m = mat3(vec3(0.80,  0.60, -0.6).xyz,\n                    vec3(0.80,  0.60, -0.6).yzx,\n                    vec3(0.80,  0.60, -0.6).zxy);\n    vec3 f = vec3(0.0);\n    f += 0.5000*noise33( p ); p = m*p*2.02;\n    f += 0.2500*noise33( p ); p = m*p*2.03;\n    f += 0.1250*noise33( p ); p = m*p*2.01;\n    f += 0.0625*noise33( p );\n    return f/0.9375;\n}\n\nvec3 getGrassColor(float x) {\n     vec3 a = vec3(0.3, 0.3, 0.3);\n    vec3 b = vec3(0.4, 0.5, 0.2);\n    vec3 c = vec3(0.2, 0.4, 0.2);\n    vec3 d = vec3(0.66, 0.77, 0.33);\n    vec3 col = a + b * cos(2. * PI * (c * x + d));\n    return col;\n}\n\nfloat getGrassBlade(in vec2 position, in vec2 grassPos, out vec4 color) {\n    \n       // grassPos+= abs(noise33(vec3(grassPos*.41,0.)*vec3(3,.0,1)).xy-0.5 )*.5;\n\n    \n\t// between {-1, -1, -1} and {1, 1, 1}\n    vec3 grassVector3 = hash32(grassPos * 123512.41) * 2.0 - vec3(1);\n    // keep grass z between 0 and 0.4\n    grassVector3.z = grassVector3.z * 0.2 + 0.2;\n    vec2 grassVector2 = normalize (\n     //vec2(sin( 1.5+iTime*0.1),cos(1.5+iTime*0.1))*2.\n     (UV)  *1.5 \n        \n    +   grassVector3.xy*.6\n    )     ;\n\n    float grassLength = noise13(vec3(grassPos*1.5,10.)) * 0.01 + 0.012*length(UV) ;\n\n    // take coordinates in grass blade frame\n    vec2 gv = position - grassPos;\n    float gx = dot(grassVector2, gv);\n    float gy = dot(vec2(-grassVector2.y, grassVector2.x), gv);\n    float gxn = gx / grassLength;\n\n    // TODO make gy depends to gx\n    if (gxn >= 0.0 && gxn <= 1.0 && abs(gy) <= 0.0015 * (1. - gxn * gxn)) {\n        \n        vec3 thisGrassColor = \n            getGrassColor(hash12(grassPos * 2631.6));\n        color =\n            vec4(thisGrassColor * (0.2 + 0.8 * gxn) \n            + (fbm33(vec3(position*1.1,0.)*vec3(1,3,1))-0.5 )*.2\n            + (fbm33(vec3(position*10.1,0.)*vec3(5,1,1))-0.5 )*.2\n                 , 1.0);\n        \n     \treturn grassVector3.z * gxn;\n    }\n    else {\n        color = vec4(0., 0., 0., 1.);\n        return -1.0;\n    }\n}\n\nfloat getPoint(in vec2 position, out vec4 color) {\n   \tint xcount = int(1. / BLADES_SPACING);\n    int ycount = int(1. / BLADES_SPACING);\n    int ox = int(position.x * float(xcount));\n    int oy = int(position.y * float(ycount));\n\n    float maxz = 0.0;\n            vec4 tempColor =vec4(vec3(0.1,0.35,0)+fbm33(vec3(position*129.,0.)-.5),0.)*.1;\n\n    for (int i = -LOOKUP_DIST; i < LOOKUP_DIST; ++i) {\n        for (int j = -LOOKUP_DIST; j < LOOKUP_DIST; ++j) {\n            vec2 upos = vec2(ox + i, oy + j);\n            vec2 grassPos = (BLADES_SPACING+0.005*BLADES_SPACING*fbm33(vec3(upos*179.,0.)-.5)).x*  (upos \n                             + 4.5* (noise33(vec3(upos*50.,upos.x+upos.y)).xy-.5) );\n \n            float z = getGrassBlade(position, grassPos, tempColor);\n\n            if (z > maxz) {\n                maxz = z;\n                color = mix(color, tempColor,0.85);\n            }\n        }\n    }\n    if (maxz == 0.0) {\n        color = vec4(vec3(0.1,0.35,0)+fbm33(vec3(position*129.,0.)-.5),0.)*.12;;\n    }\n\n    return maxz;\n}\n\n//------------------------------------------------------------------\n// \n//------------------------------------------------------------------\n\n\nvec3 render( in vec3 ro, in vec3 rd) {\n\tvec3 col = vec3(.8, .9, 1.0) + rd.y * 0.8;\n\tvec2 res = castRay(ro, rd);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\tif (m > -0.5) {\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect(rd, nor);\n        \n        vec4 grasscolor;\n        vec4 grasscolor2;\n\t\t// material        \n\t\n        if (m < 1.5) {\n            \tcol = 0.45 + 0.35 * sin(vec3(0.05, 0.08, 0.10) * (m - 1.0));\n\t\t    vec2 position=pos.zx;\n            grasscolor2=  vec4(0.6*getGrassColor(hash13(pos)) * (0.2 + 0.8 * 0.5) \n            + (fbm33(vec3(position*1.1,0.)*vec3(1,3,1))-0.5 )*.2\n            + (fbm33(vec3(position*10.1,0.)*vec3(5,1,1))-0.5 )*.2\n                 , 1.0);if \n                \n            (t<13.){\n\t\t\tfloat f = getPoint( vec2(pos.xz*.1),grasscolor);\n            }\n            else {\n            grasscolor=grasscolor2;\n            }\n            \n            \n            col = mix(grasscolor.rgb,grasscolor2.rgb,smoothstep(10.,13.,t) );\n\t\t}\n\t\tif (m >= 2.0) {\n\t\t\tcol = vec3(0.6);\n\t\t}\n\t\tif (m >= 3.0) {\n\t\t\tcol = vec3(0.07);\n\t\t}\n\t\t// lighting        \n\t\tfloat occ = calcAO(pos, nor);\n\t\tvec3 lig = normalize(vec3(0.2, 0.7, 0.6));\n\t\tvec3 hal = normalize(lig - rd);\n\t\tfloat amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n\t\tfloat dif = clamp(dot(nor, lig), 0.0, 1.0);\n\t\tfloat bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0);\n\t\tfloat dom = smoothstep(-0.1, 0.1, ref.y);\n\t\tfloat fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n\t\tdif *= calcSoftshadow(pos, lig, 0.02, 2.5);\n\t\tdom *= calcSoftshadow(pos, ref, 0.02, 2.5);\n\t\tfloat spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 16.0) *\n\t\t\tdif *\n\t\t\t(0.04 + 0.96 * pow(clamp(1.0 + dot(hal, rd), 0.0, 1.0), 5.0));\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 1.30 * dif * vec3(1.00, 0.80, 0.55);\n\t\tlin += 0.20 * amb * vec3(0.40, 0.60, 1.00) * occ;\n\t\tlin += 0.20 * dom * vec3(0.40, 0.60, 1.00) * occ;\n\t\tlin += 0.30 * bac * vec3(0.25, 0.25, 0.25) * occ;\n\t\t//lin += 0.35 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\t\tcol = col * lin;\n\t\t//col += 10.00 * spe * vec3(1.00, 0.90, 0.70);\n        col=mix(col,vec3((col.x+col.y+col.z)/3.)*vec3(1,1.5,1),0.3);\n\t\tcol = mix(col, vec3(0.8, 0.9, 1.0), 1.0 - exp(-0.00005 * t * t * t  ));\n        \n\t}\n\treturn vec3(clamp(col, 0.0, 1.0));\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\n\n\n\n\nvoid setup() {\n }\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tsetup();\n\tvec2 mo = iMouse.xy / iResolution.xy;\n\tfloat time = .0 + iTime;\n\tvec3 tot = vec3(0.0);\n #\tif AA > 1\n\tfor (int m = 0; m < AA; m++)\n\t\tfor (int n = 0; n < AA; n++) {\n\t\t\t// pixel coordinates\n\t\t\tvec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n\t\t\tvec2 p = (-iResolution.xy + 2.0 * (fragCoord + o)) / iResolution.y;\n # else\n\t\t\t\tvec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n # endif\n\t\t\t// camera\t\n\t\t\tvec3 ta = timefly(time)  ;\n\t\t\tvec3 ro = vec3(0,1,0)+timefly(time-1.) \n                + vec3(-0.5 + 3.5 * cos(  6.0 * mo.x),\n\t\t\t\t1.0 + 2.0 * mo.y,\n\t\t\t\t0.5 + 4.0 * sin( 6.0 * mo.x))*(2.*(sin(iTime*.2)+1.2));\n\t\t\t// camera-to-world transformation\n\t\t\tmat3 ca = setCamera(ro, ta, 0.0);\n\t\t\t// ray direction\n  \n\n\t\t\tvec3 rd = ca * normalize(vec3(p.xy, 2.5));\n            \n                        vec3 centerray=normalize(ca * normalize(vec3(0,0, 2.5)));\n                  float uppness=( abs(dot(mix(rd,centerray,-0.1),vec3(0,1,0))));\n            uppness*=uppness;\n \n            uppness=1.-uppness; \n                UV= centerray.xz*uppness*1.1;\n\t\t\t// render\t\n\t\t\tvec3 col = render(ro, rd);\n\t\t\t// gamma\n\t\t\tcol = pow(col, vec3(0.4545));\n\t\t\ttot += col;\n # if AA > 1\n\t\t}\n\ttot /= float(AA * AA);\n #\tendif\n\tfragColor = vec4(tot, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlXXWs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlXXz2", "name": "Cube Labyrinth modv1", "author": "jorge2017a1", "description": "Cube Labyrinth modv1", "tags": ["cubelabyrinthmodv1"], "likes": 3, "viewed": 165, "date": "1563545409", "time_retrieved": "2024-06-20T19:40:31.363847", "image_code": "//Copyright (c) 2019-07-13 - 2019-07-17 by Angelo Logahd\n//Portfolio: https://angelologahd.wixsite.com/portfolio\n//Based on https://www.iquilezles.org/www/articles/menger/menger.htm\n\n//Copyright (c) 2019-07-13 by Angelo Logahd\n//http://glslsandbox.com/e#56104.0\n\n#define true\t\t\t\t1\n#define false\t\t\t\t0\n\n#define PI 3.14\n\n#define saturate(x) \t\tclamp(x, 0.0, 1.0)\n\n#define MENGER_ITERATIONS\t2\n//#define SOFT_SHADOW_STEPS \t32\n#define SOFT_SHADOW_STEPS \t20\n\n\n\n#define INTERSECT_STEPS\t\t150\n\n//#define INTERSECT_MIN_DIST\t0.002\n#define INTERSECT_MIN_DIST\t0.0025\n\n//#define INTERSECT_MAX_DIST\t20.0\n#define INTERSECT_MAX_DIST\t10.0\n\n#define MOVING_BRICKS\t\tfalse\n\n\nvec2 rotate2D(vec2 p, float angle)\n{\n    float sRot = sin(angle);\n    float cRot = cos(angle);\n    return p * cRot + p.yx * sRot * vec2(-1.0, 1.0);\n}\n\nfloat sdUnitBox(vec3 p)\n{\n    vec3 d = abs(p) - vec3(1.0);\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nvec4 map(in vec3 p)\n{\t\n    p.xz = mod(p.xz + 4.0, 2.0) -1.0;\n    p.y = mod(p.y + 1.0, 2.0) - 1.0;\n\t\n    float d = sdUnitBox(p);\n    vec4 res = vec4(d, 1.0, 0.01, 0.0);\n\t\n    //float s = 1.5;\n    float s = 2.5;\n    \n    for(int i = 0; i < MENGER_ITERATIONS; ++i)\n    {\t \n        #if MOVING_BRICKS\n\t\tp.x += iTime * 0.05;\n\t    #endif\n        \n        vec3 a = mod(p * s, 2.0) - 1.0;\n        s *= 11.0;\n        //vec3 r = abs(1.0 - 4.0 * abs(a));\n        vec3 r = abs(1.0 - 5.0 * abs(a));\n        \n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 0.85) / s;\n        \n\n        if(c > d)\n        {\n            d = c;\n            res = vec4(d, min(res.y, 0.2 * da * db * dc), 0.0, 1.0);\n        }\n    }\n    \n    return res;\n}\n\nvec4 intersect(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n    vec4 h = vec4(1.0);\n    for (int i = 0; i < INTERSECT_STEPS; ++i)\n    {\n\t\tif(h.x < INTERSECT_MIN_DIST || t > INTERSECT_MAX_DIST) \n\t\t{\n\t    \tbreak;\n\t\t}\n\t\n        h = map(ro + rd * t);\n        res = vec4(t, h.yzw);\n        t += h.x;\n    }\n\n    if (t > INTERSECT_MAX_DIST) \n    {\n\t\tres = vec4(-1.0);\n    }\n    \n    return res;\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < SOFT_SHADOW_STEPS; ++i)\n    {\n\t\tvec3 pos = ro + rd * t;\n        float h = map(pos).x;\n        res = min(res, float(SOFT_SHADOW_STEPS) * h / t);\n        if(res < 0.101)\n\t\t{\n            break;\n\t\t}\n        t += clamp(h, 0.01, 0.05);\n    }\n    return saturate(res);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    ;\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    \n    \n    vec3 n;\n    n.x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    n.y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    n.z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n    return normalize(n);\n}\n\nvec3 render(in vec3 ro, in vec3 rd, float intensity)\n{\n    vec3 color = vec3(0.5);\n    vec4 res = intersect(ro,rd);\n    if(res.x > 0.0)\n    {\n        const vec3 light1 = vec3(0.5, 0.8, 0.5);\n\t\t\n\t\tvec3 pos = ro + res.x * rd;\n\t\n        //vec3 baseColor = vec3(saturate(sin(iTime * 0.5)), saturate(cos(iTime * 0.3)), saturate(sin(iTime * 0.4)));\n        \n        vec3 baseColor = vec3( 0.9,  0.3,  0.7);\n        \n        \n\t\tvec3 ambient = vec3(0.3) * baseColor;\n\t\t\n\t\tvec3 normal = calcNormal(pos);\n\t\tvec3 reflection = reflect(rd, normal);\n        \n\t\n\t\tfloat occ = res.y;\n\t\t\n        float shadow1 = softshadow(pos + 0.0005 * normal, light1);\n\t\n\t\tvec3 diffuse = baseColor * shadow1 * occ;\n\t\t\n\t\tcolor = diffuse + ambient;\t\t\n\t\tcolor += 0.8 * smoothstep(0.0, 0.5, reflection.y) * softshadow(pos + 0.01 * normal, reflection);\n    }\n\n    return pow(color * intensity, vec3(0.4545));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 p = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\t\n    // camera\n    vec3 ro = vec3(8.75, 2.9, -0.0);\n    #if !MOVING_BRICKS\n       ro.x -= 0.1 * iTime;\n    #endif\n    vec3 ww = normalize(vec3(0.0) - ro);\n    \n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n\n    \n    vec3 color = render(ro + vec3(0.0, -1.0, 0.0), rd, 0.50);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlXXz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlXXz8", "name": "Relaxing Sine", "author": "clintolibre", "description": "implementation of a popular gif", "tags": ["sine"], "likes": 13, "viewed": 268, "date": "1562023295", "time_retrieved": "2024-06-20T19:40:31.715461", "image_code": "//Thanks for checking out my shader. Have a great day. -Clint\n\nfloat distanceToLine(vec2 p1, vec2 p2, vec2 point) {\n    float a = p1.y-p2.y;\n    float b = p2.x-p1.x;\n    return abs(a*point.x+b*point.y+p1.x*p2.y-p2.x*p1.y) / sqrt(a*a+b*b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Output to screen\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //Pretty colors from default shader\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //flatten out waves\n    uv.x /= 2.0;\n    \n    //how many tiles\n    float frac = iResolution.x/22.0;\n    \n    //value for which row in the tiling the pixel is in\n    float weird = floor(uv.y*frac);\n    \n    //if the pixel is in a odd or even column of the tiling\n    float even = mod(floor(uv.x*frac),2.0);\n    \n    //offset the oscillation of the endpoint on the top of each tile\n    float calc = (sin((iTime*2.0)+(weird/4.0)+(even*3.14))/4.0)+.5;\n    \n    //declare endpoints to for the two lines in each tile\n    vec2 p1 = vec2(calc,floor(uv.y+1.0));\n    vec2 p2 = vec2(0.,0.1);\n    vec2 p3 = vec2(1.0,0.1);\n\t\n    //tile our 2space\n    uv = fract(uv*frac);\n    \n    //thickness of lines\n    float radius =0.005;\n    \n    //aliasing of lines\n    float AA = 0.015;\n    \n    //distances from our pixel to the lines we want to draw\n    float d = min(distanceToLine (p1,p2,uv),distanceToLine (p1,p3,uv));\n\tfloat line = 0.0;\n    //smoothstep for drawing our lines\n    if(d < radius) {\n        line = 1.0;\n\t} else {\n\t  // Anti-alias the edge.\n        line = 1.0 - smoothstep(d, radius, radius+AA);\n\t}\n   \t//float line =  smoothstep (radius/2.,radius/2.-AA,distance);\n    \n    //drawing lines\n    fragColor = vec4(col*line,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlXXz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlXXzM", "name": "Shader Color Test #01", "author": "sillylab", "description": "Shader Color Test #01", "tags": ["color"], "likes": 1, "viewed": 47, "date": "1562388071", "time_retrieved": "2024-06-20T19:40:31.715461", "image_code": "vec3 firstColor = vec3(0.912,0.052,0.328);\nvec3 secondColor = vec3(1.000,0.984,0.009);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec3 mainColor = vec3(0.0);\n    \n    float pct = abs(sin(iTime * 50.0));\n    mainColor = mix(firstColor, secondColor, pct);\n    \n    fragColor = vec4(mainColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlXXzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttfSRl", "name": "BOX CLUB", "author": "SWS3005C125", "description": "This is a box club.The letter you press will be displayed on the stage, and you can press again to cancel it.\ne.g. Press A, then A will be displayed. After that  If you want to press B and show B, you'd better press A again to cancel A first.", "tags": ["raytracing"], "likes": 1, "viewed": 377, "date": "1563895298", "time_retrieved": "2024-06-20T19:40:36.794604", "image_code": "//============================================================================\n// Constants.\n//============================================================================\nconst float PI = 3.14159265358;\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 10;\nconst int NUM_PLANES = 5;\nconst int NUM_SPHERES = 4;\nconst int NUM_BOXS = 29;\n\n// Adjust the bounce frequence to fit the rhythm of backgroundmusic\nconst float time = -0.45;\nconst float freq = 3.45;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n // Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0; \n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Control the Pattern and Color of box\nint modeNum;\n\n// the map of the box pattern\nint map[25];\nint map65[25] = int[](0,1,1,1,0,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  1,1,1,1,1,\n\t\t\t\t\t  1,0,0,0,1); //A\n\nint map66[25] = int[](1,1,1,1,0,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  1,1,1,1,0,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  1,1,1,1,0); //B\n\nint map67[25] = int[](0,1,1,1,0,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  1,0,0,0,0,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  0,1,1,1,0); //C\n\nint map68[25] = int[](1,1,1,1,0,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  1,1,1,1,0); //D\n\nint map69[25] = int[](1,1,1,1,1,\n\t\t\t\t\t  1,0,0,0,0,\n\t\t\t\t\t  1,1,1,1,1,\n\t\t\t\t\t  1,0,0,0,0,\n\t\t\t\t\t  1,1,1,1,1); //E\n\nint map70[25] = int[](1,1,1,1,1,\n\t\t\t\t\t  1,0,0,0,0,\n\t\t\t\t\t  1,1,1,1,1,\n\t\t\t\t\t  1,0,0,0,0,\n\t\t\t\t\t  1,0,0,0,0); //F\n\nint map71[25] = int[](0,1,1,1,1,\n\t\t\t\t\t  1,0,0,0,0,\n\t\t\t\t\t  1,0,1,1,1,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  0,1,1,1,1); //G\n\nint map72[25] = int[](1,0,0,0,1,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  1,1,1,1,1,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  1,0,0,0,1); //H\n\nint map73[25] = int[](1,1,1,1,1,\n\t\t\t\t\t  0,0,1,0,0,\n\t\t\t\t\t  0,0,1,0,0,\n\t\t\t\t\t  0,0,1,0,0,\n\t\t\t\t\t  1,1,1,1,1); //I\n\nint map74[25] = int[](1,1,1,1,1,\n\t\t\t\t\t  0,0,1,0,0,\n\t\t\t\t\t  0,0,1,0,0,\n\t\t\t\t\t  1,0,1,0,0,\n\t\t\t\t\t  1,1,1,0,0); //J\n\nint map75[25] = int[](1,0,0,0,1,\n\t\t\t\t\t  1,0,0,1,0,\n\t\t\t\t\t  1,1,1,0,0,\n\t\t\t\t\t  1,0,0,1,0,\n\t\t\t\t\t  1,0,0,0,1); //K\n\nint map76[25] = int[](0,1,0,0,0,\n\t\t\t\t\t  0,1,0,0,0,\n\t\t\t\t\t  0,1,0,0,0,\n\t\t\t\t\t  0,1,0,0,0,\n\t\t\t\t\t  0,1,1,1,1); //L\n\nint map77[25] = int[](1,0,0,0,1,\n\t\t\t\t\t  1,1,0,1,1,\n\t\t\t\t\t  1,0,1,0,1,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  1,0,0,0,1); //M\n\nint map78[25] = int[](1,0,0,0,1,\n\t\t\t\t\t  1,1,0,0,1,\n\t\t\t\t\t  1,0,1,0,1,\n\t\t\t\t\t  1,0,0,1,1,\n\t\t\t\t\t  1,0,0,0,1); //N\n\nint map79[25] = int[](0,1,1,1,0,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  0,1,1,1,0); //O\n\nint map80[25] = int[](1,1,1,1,0,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  1,1,1,1,0,\n\t\t\t\t\t  1,0,0,0,0,\n\t\t\t\t\t  1,0,0,0,0); //P\n\nint map81[25] = int[](1,1,1,1,0,\n\t\t\t\t\t  1,0,0,1,0,\n\t\t\t\t\t  1,0,0,1,0,\n\t\t\t\t\t  1,1,1,1,0,\n\t\t\t\t\t  0,0,1,1,1); //Q\n\nint map82[25] = int[](1,1,1,1,0,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  1,1,1,1,0,\n\t\t\t\t\t  1,0,0,1,0,\n\t\t\t\t\t  1,0,0,0,1); //R\n\nint map83[25] = int[](1,1,1,1,1,\n\t\t\t\t\t  1,0,0,0,0,\n\t\t\t\t\t  1,1,1,1,1,\n\t\t\t\t\t  0,0,0,0,1,\n\t\t\t\t\t  1,1,1,1,1); //S\n\nint map84[25] = int[](1,1,1,1,1,\n\t\t\t\t\t  0,0,1,0,0,\n\t\t\t\t\t  0,0,1,0,0,\n\t\t\t\t\t  0,0,1,0,0,\n\t\t\t\t\t  0,0,1,0,0); //T\n\nint map85[25] = int[](1,0,0,0,1,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  0,1,1,1,0); //U\n\nint map86[25] = int[](1,0,0,0,1,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  0,1,0,1,0,\n\t\t\t\t\t  0,0,1,0,0); //V\n\nint map87[25] = int[](1,0,0,0,1,\n\t\t\t\t\t  1,0,0,0,1,\n\t\t\t\t\t  1,0,1,0,1,\n\t\t\t\t\t  1,1,0,1,1,\n\t\t\t\t\t  1,0,0,0,1); //W\n\nint map88[25] = int[](1,0,0,0,1,\n\t\t\t\t\t  0,1,0,1,0,\n\t\t\t\t\t  0,0,1,0,0,\n\t\t\t\t\t  0,1,0,1,0,\n\t\t\t\t\t  1,0,0,0,1); //X\n\nint map89[25] = int[](1,0,0,0,1,\n\t\t\t\t\t  0,1,0,1,0,\n\t\t\t\t\t  0,0,1,0,0,\n\t\t\t\t\t  0,0,1,0,0,\n\t\t\t\t\t  0,0,1,0,0); //Y\n\nint map90[25] = int[](1,1,1,1,1,\n\t\t\t\t\t  0,0,0,1,0,\n\t\t\t\t\t  0,0,1,0,0,\n\t\t\t\t\t  0,1,0,0,0,\n\t\t\t\t\t  1,1,1,1,1); //Z\n\nint map10[25] = int[](0,0,0,0,0,\n\t\t\t\t\t  0,1,0,1,0,\n\t\t\t\t\t  1,1,1,1,1,\n\t\t\t\t\t  0,1,1,1,0,\n\t\t\t\t\t  0,0,1,0,0);// Heart\n\nint map11[25] = int[](0,0,1,1,0,\n\t\t\t\t\t  0,0,1,0,1,\n\t\t\t\t\t  0,1,1,0,0,\n\t\t\t\t\t  1,1,1,0,0,\n\t\t\t\t\t  1,1,1,0,0);// Musical Note\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Box_t {\n\tvec3 rad;\n    vec3 center;\n\tint materialID;\n\tmat4 M;   // Transform Matrix\n\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n};\n \nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nBox_t Box[NUM_BOXS];\n\n\n\nvoid UpDate()\n{\n\t// Stage box\n\tfor (int i=0; i < 25; i++)\n\t{\n\t\tif (modeNum != 0)\n\t\t{\n\t\t\tif (map[i]==0) \n\t\t\t\tBox[i].rad = vec3(0.4 + abs(sin(freq * iTime-time))/10.0, 0.4+ abs(sin(freq * iTime-time))/10.0 ,0.4+ abs(sin(freq * iTime-time))/10.0);\n\t\t\telse \t\t\t\n\t\t\t\tBox[i].rad = vec3(0.4+ abs(sin(freq * iTime-time))/10.0, 0.4+ abs(sin(freq * iTime-time)),0.4+ abs(sin(freq * iTime-time))/10.0);\n\n\t\t\tif (Box[i].rad.y > 0.6) \n\t\t\t\tBox[i].materialID = modeNum;\n\t\t\telse \n\t\t\t\tBox[i].materialID = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tBox[i].rad = vec3(0.4+ abs(sin(freq * iTime-time))/10.0, 0.4+ abs(sin(freq * iTime-time+10.0*float(i/5)+ 10.0*float(i-(i/5)*5)))/2.0,0.4+ abs(sin(freq * iTime-time))/10.0);\n\t\t\tif (Box[i].rad.y > 0.6) \n\t\t\t\tBox[i].materialID = i/5+2;\n\t\t\telse \n\t\t\t\tBox[i].materialID = 1;\n\t\t}\n\t}\n\t// four Audio\n\tBox[25].rad = vec3(0.8+ abs(sin(freq * iTime-time))/10.0,1.2+ abs(sin(freq * iTime-time))/10.0,1.0+ abs(sin(freq * iTime-time))/10.0);\n\tSphere[0].radius = 0.8+ abs(sin(freq * iTime-time))/8.0;\n\tBox[26].rad = vec3(0.8+ abs(sin(freq * iTime-time))/10.0,1.2+ abs(sin(freq * iTime-time))/10.0,1.0+ abs(sin(freq * iTime-time))/10.0);\n\tSphere[1].radius = 0.8+ abs(sin(freq * iTime-time))/8.0;\n\tBox[27].rad = vec3(0.8+ abs(sin(freq * iTime-time))/10.0,1.2+ abs(sin(freq * iTime-time))/10.0,1.0+ abs(sin(freq * iTime-time))/10.0);\n\tSphere[2].radius = 0.8+ abs(sin(freq * iTime-time))/8.0;\n\tBox[28].rad = vec3(0.8+ abs(sin(freq * iTime-time))/10.0,1.2+ abs(sin(freq * iTime-time))/10.0,1.0+ abs(sin(freq * iTime-time))/10.0);\n\tSphere[3].radius = 0.8+ abs(sin(freq * iTime-time))/8.0;\n\n}\n\n\n\nvoid CheckKeyboard()\n{\n\t\tif (texelFetch( iChannel0, ivec2(65,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=6;\n\t\t\tmap = map65;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(66,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=2;\n\t\t\tmap = map66;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(67,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=3;\n\t\t\tmap = map67;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(68,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=4;\n\t\t\tmap = map68;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(69,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=5;\n\t\t\tmap = map69;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(70,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=6;\n\t\t\tmap = map70;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(71,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=2;\n\t\t\tmap = map71;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(72,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=3;\n\t\t\tmap = map72;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(73,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=4;\n\t\t\tmap = map73;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(74,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=5;\n\t\t\tmap = map74;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(75,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=6;\n\t\t\tmap = map75;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(76,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=2;\n\t\t\tmap = map76;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(77,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=3;\n\t\t\tmap = map77;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(78,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=4;\n\t\t\tmap = map78;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(79,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=5;\n\t\t\tmap = map79;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(80,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=6;\n\t\t\tmap = map80;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(81,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=2;\n\t\t\tmap = map81;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(82,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=3;\n\t\t\tmap = map82;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(83,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=4;\n\t\t\tmap = map83;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(84,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=5;\n\t\t\tmap = map84;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(85,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=6;\n\t\t\tmap = map85;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(86,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=2;\n\t\t\tmap = map86;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(87,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=3;\n\t\t\tmap = map87;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(88,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=4;\n\t\t\tmap = map88;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(89,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=5;\n\t\t\tmap = map89;\n\t\t\treturn;\n\t\t}\n\t\tif (texelFetch( iChannel0, ivec2(90,2), 0 ).x != 0.0) \n\t\t{\n\t\t\tmodeNum=6;\n\t\t\tmap = map90;\n\t\t\treturn;\n\t\t}\n\n\t\tif (mod(floor(iTime),45.0)<7.0)\n\t\t{\n\t\t\tmodeNum = 6;\n\t\t\tmap = map11;\n\t\t\treturn;\n\t\t}\n\t\tif ((mod(floor(iTime),45.0)>= 7.00)&&(mod(floor(iTime),45.0)<14.5))\n\t\t{\n\t\t\tmodeNum = 4;\n\t\t\tmap = map10;\n\t\t\treturn;\n\t\t}\n\t\tif (mod(floor(iTime),45.0)>=14.5)\n\t\t{\n\t\t\tmodeNum = 0;\n\t\t\treturn;\n\t\t}\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n   // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n\n\t// four walls\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 7.5;\n    Plane[1].materialID = 0;\n    \n    Plane[2].A = 1.0;\n    Plane[2].B = 0.0;\n    Plane[2].C = 0.0;\n    Plane[2].D = 7.5;\n    Plane[2].materialID = 0;\n    \n    Plane[3].A = -1.0;\n    Plane[3].B = 0.0;\n    Plane[3].C = 0.0;\n    Plane[3].D =7.5;\n    Plane[3].materialID = 0;\n    \n    Plane[4].A = 0.0;\n    Plane[4].B = 0.0;\n    Plane[4].C = -1.0;\n    Plane[4].D = 7.5;\n    Plane[4].materialID = 0;\n\n\t// stage box\n\tfor (int i=0; i< 5; i++)\n\t{\n\t\tfor (int j=0;j<5;j++)\n\t\t{\n\t\t\tBox[i*5+j].rad = vec3(0.4, 0.4 ,0.4);\n\t\t\tBox[i*5+j].center = vec3(-2.2 + float(j)* 1.1,0.5,-2.2+1.1 * float(i));\n\t\t\tBox[i*5+j].materialID = 1;\n\t\t\tBox[i*5+j].M =  mat4 (vec4(1,0,0,0),\n\t\t\t\t\tvec4(0,1,0,0),\n\t\t\t\t\tvec4(0,0,1,0),\n\t\t\t\t\tvec4(-Box[i*5+j].center,1));\n\t\t}\n\t}\n\t// four Audio\n\tBox[25].rad = vec3(0.8,1.2,1.0);\n\tBox[25].center = vec3(4.2,1.2,-4.2);\n\tBox[25].materialID = 7;\n\tBox[25].M = mat4 (vec4(cos(45.0 / 180.0 * PI ),0,sin(45.0 / 180.0 * PI ),0),vec4(0,1,0,0),vec4(-sin(45.0 / 180.0 * PI ),0,cos(45.0 / 180.0 * PI ),0),vec4(0,0,0,1))*mat4 (vec4(1,0,0,0),vec4(0,1,0,0),vec4(0,0,1,0),vec4(-Box[25].center,1));\n\n\tSphere[0].center = vec3( 3.9, 1.4, -3.9 );\n    Sphere[0].radius = 0.8;\n    Sphere[0].materialID = 8;\n\n\tBox[26].rad = vec3(0.8,1.2,1.0);\n\tBox[26].center = vec3(4.2,1.2,4.2);\n\tBox[26].materialID = 7;\n\tBox[26].M = mat4 (vec4(cos(135.0 / 180.0 * PI ),0,sin(135.0 / 180.0 * PI ),0),vec4(0,1,0,0),vec4(-sin(135.0 / 180.0 * PI ),0,cos(135.0 / 180.0 * PI ),0),vec4(0,0,0,1))*mat4 (vec4(1,0,0,0),vec4(0,1,0,0),vec4(0,0,1,0),vec4(-Box[26].center,1));\n\n\tSphere[1].center = vec3( 3.9, 1.4, 3.9 );\n    Sphere[1].radius = 0.8;\n    Sphere[1].materialID = 8;\n\n\tBox[27].rad = vec3(0.8,1.2,1.0);\n\tBox[27].center = vec3(-4.2,1.2,4.2);\n\tBox[27].materialID = 7;\n\tBox[27].M = mat4 (vec4(cos(225.0 / 180.0 * PI ),0,sin(225.0 / 180.0 * PI ),0),vec4(0,1,0,0),vec4(-sin(225.0 / 180.0 * PI ),0,cos(225.0 / 180.0 * PI ),0),vec4(0,0,0,1))*mat4 (vec4(1,0,0,0),vec4(0,1,0,0),vec4(0,0,1,0),vec4(-Box[27].center,1));\n\n\tSphere[2].center = vec3( -3.9, 1.4, 3.9 );\n    Sphere[2].radius = 0.8;\n    Sphere[2].materialID = 8;\n\n\tBox[28].rad = vec3(0.8,1.2,1.0);\n\tBox[28].center = vec3(-4.2,1.2,-4.2);\n\tBox[28].materialID = 7;\n\tBox[28].M = mat4 (vec4(cos(315.0 / 180.0 * PI ),0,sin(315.0 / 180.0 * PI ),0),vec4(0,1,0,0),vec4(-sin(315.0 / 180.0 * PI ),0,cos(315.0 / 180.0 * PI ),0),vec4(0,0,0,1))*mat4 (vec4(1,0,0,0),vec4(0,1,0,0),vec4(0,0,1,0),vec4(-Box[28].center,1));\n\n\tSphere[3].center = vec3( -3.9, 1.4, -3.9 );\n    Sphere[3].radius = 0.8;\n    Sphere[3].materialID = 8;\n\n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.9 * Material[0].k_d;\n    Material[0].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[0].k_rg = 0.2 * Material[0].k_r;\n    Material[0].n = 128.0;\n\n    // unlight box.\n    Material[1].k_d = vec3( 0.2, 0.2, 0.2 );\n    Material[1].k_a = 0.9 * Material[1].k_d;\n    Material[1].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[1].k_rg = 0.2 * Material[1].k_r;\n    Material[1].n = 128.0;\n\n    // Green plastic material.\n    Material[2].k_d = vec3( 0.0, 0.8, 0.0 );\n    Material[2].k_a = 0.9 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.2 * Material[2].k_r;\n    Material[2].n = 128.0;\n\n\t// Blue plastic material.\n\tMaterial[3].k_d = vec3( 0.1, 0.3, 0.8 );\n    Material[3].k_a = 0.9 * Material[3].k_d;\n    Material[3].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[3].k_rg = 0.2 * Material[3].k_r;\n    Material[3].n = 128.0;\n\n\t// Red plastic material.\n\tMaterial[4].k_d = vec3( 0.8, 0.2, 0.1 );\n    Material[4].k_a = 0.9 * Material[4].k_d;\n    Material[4].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[4].k_rg = 0.2 * Material[4].k_r;\n    Material[4].n = 128.0;\n\n\t// Pink plastic material.\n    Material[5].k_d = vec3( 0.8, 0.2, 0.8 );\n    Material[5].k_a = 0.9 * Material[5].k_d;\n    Material[5].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[5].k_rg = 0.2 * Material[5].k_r;\n    Material[5].n = 128.0;\n    \n\t// Yellow plastic material.\n    Material[6].k_d = vec3( 0.8, 0.7, 0.1 );\n    Material[6].k_a = 0.9 * Material[6].k_d;\n    Material[6].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[6].k_rg = 0.2 * Material[6].k_r;\n    Material[6].n = 128.0;\n\n\t// Audio box\n\tMaterial[7].k_d = vec3( 0.1, 0.1, 0.1 );\n    Material[7].k_a = 0.9 * Material[6].k_d;\n    Material[7].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[7].k_rg = 0.2 * Material[6].k_r;\n    Material[7].n = 128.0;\n\n\t// Audio ball\n\tMaterial[8].k_d = vec3( 0.75, 0.75, 0.75 );\n    Material[8].k_a = 0.9 * Material[6].k_d;\n    Material[8].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[8].k_rg = 0.2 * Material[6].k_r;\n    Material[8].n = 128.0;\n\n\t// Light 0.\n    Light[0].position = vec3( 4.0, 8.0, -3.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n\n    // Light 1.\n    Light[1].position = vec3( -4.0, 8.0, 0.0 );\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n       \n\t// change the light color by time\n    if(iTime<4.0){\n        Light[0].I_source = vec3( 0.2, 0.2*abs(sin(iTime)), 0.2 );\n        Light[1].I_source = vec3( 0.0, 0.2*abs(sin(iTime)), 0.2 );\n    }\n    if(iTime>=4.0){\n\t\tLight[0].I_source = vec3( 0.8*abs(sin(0.2*iTime)), 0.8*abs(cos(0.2*iTime)), 0.8*abs(sin(1.2*iTime)) );\n        Light[1].I_source = vec3( 0.5*abs(sin(0.4*iTime)), 0.5*abs(cos(0.1*iTime)), 0.5*abs(sin(1.4*iTime)) );\n    }\n \n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\tmat4 M =  mat4 (vec4(1,0,0,0),\n\t\t\t\t\tvec4(0,1,0,0),\n\t\t\t\t\tvec4(0,0,1,0),\n\t\t\t\t\tvec4(-sph.center,1));\n\tvec3 sco = (M * vec4(ray.o,1.0)).xyz;\n\tvec3 scd = normalize((transpose(inverse(M))*vec4(ray.d,1.0)).xyz);\n\tfloat b = dot(scd, sco);\n\tfloat c = dot(sco, sco) - sph.radius * sph.radius;\n\tfloat d = b * b - c;\n\tfloat t0;\n\tif (d >= 0.0) t0 = -b - sqrt(d);\n\n    if ( t0 < tmin || t0 > tmax ) return false;\n\tt = t0;\n\thitPos = (inverse(M) * vec4((sco + t0 * scd),1.0)).xyz;\n\thitNormal = normalize(hitPos - sph.center);\n    return true;\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\t\n\tmat4 M =  mat4 (vec4(1,0,0,0),\n\t\t\t\t\tvec4(0,1,0,0),\n\t\t\t\t\tvec4(0,0,1,0),\n\t\t\t\t\tvec4(-sph.center,1));\n\tvec3 sco = (M * vec4(ray.o,1.0)).xyz;\n\tvec3 scd = normalize((transpose(inverse(M))*vec4(ray.d,1.0)).xyz);\n\tfloat b = dot(scd, sco);\n\tfloat c = dot(sco, sco) - sph.radius * sph.radius;\n\tfloat d = b * b - c;\n\tfloat t0;\n\tif (d >= 0.0) t0 = -b - sqrt(d);\n\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;  \n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a box and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectBox(in Box_t box, in Ray_t ray, in float tmin, in float tmax, out float t, out vec3 hitPos, out vec3 hitNormal)\n{\n\tvec3 sco = (box.M * vec4(ray.o,1.0)).xyz;\n\tvec3 scd = normalize((transpose(inverse(box.M))*vec4(ray.d,1.0)).xyz);\n    vec3 m = 1.0/scd;\n    vec3 n = m * sco;\n    vec3 k = abs(m) * box.rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max( max( t1.y, t1.z ), t1.x );\n    float tF = min( min( t2.y, t2.z ), t2.x );\n\t\n    if( tN>tF || tF<0.0) return false;\n\tif ( tN < tmin || tN > tmax ) return false;\n\tt = tN;\n\thitPos = (inverse(box.M) * vec4((sco + t * scd),1.0)).xyz;\n\thitNormal = (transpose(inverse(box.M)) * vec4((-sign(ray.d)*step(t1.zxy,t1.xyz)*step(t1.yzx,t1.xyz)),1.0)).xyz;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a box and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectBox(in Box_t box, in Ray_t ray, in float tmin, in float tmax )\n{\n\n\tvec3 sco = (box.M * vec4(ray.o,1.0)).xyz;\n\tvec3 scd = normalize((transpose(inverse(box.M))*vec4(ray.d,1.0)).xyz);\n    vec3 m = 1.0/scd;\n    vec3 n = m * sco;\n    vec3 k = abs(m) * box.rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.y, t1.z ), t1.x );\n    float tF = min( min( t2.y, t2.z ), t2.x );\n\t\n    if( tN>tF || tF<0.0) return false;\n\tif ( tN < tmin || tN > tmax ) return false;\n    return true;\n}\n\n\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of \n// Lecture 11 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS { \n//                   I_a * k_a + \n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a + \n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray, \n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg ) \n{\n    // Find whether and where the ray hits some object. \n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // * Try interesecting input ray with all the planes, spheres and box\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n\tfor ( int j = 0; j < NUM_BOXS; j++ )\n\t{\n\t\tif (IntersectBox(Box[j], ray, DEFAULT_TMIN, DEFAULT_TMAX))\n\t\t{\n\t\t\tIntersectBox(Box[j], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n\t\t\tif (temp_t < nearest_t)\n\t\t\t{\n\t\t\t\tnearest_t = temp_t;\n\t\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\t\tnearest_hitNormal = temp_hitNormal;\n\t\t\t\tnearest_hitMatID = Box[j].materialID;\n\t\t\t\thasHitSomething = true;\n\t\t\t}\n\t\t}\n\t}\n    for ( int j = 0; j < NUM_SPHERES; j++ )\n\t{\n\t\tif (IntersectSphere(Sphere[j], ray, DEFAULT_TMIN, DEFAULT_TMAX))\n\t\t{\n\t\t\tIntersectSphere(Sphere[j], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n\t\t\tif (temp_t < nearest_t)\n\t\t\t{\n\t\t\t\tnearest_t = temp_t;\n\t\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\t\tnearest_hitNormal = temp_hitNormal;\n\t\t\t\tnearest_hitMatID = Sphere[j].materialID;\n\t\t\t\thasHitSomething = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor ( int j = 0; j < NUM_PLANES; j++ )\n\t{\n\t\tif (IntersectPlane(Plane[j], ray, DEFAULT_TMIN, DEFAULT_TMAX))\n\t\t{\n\t\t\tIntersectPlane(Plane[j], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n\t\t\tif (temp_t < nearest_t)\n\t\t\t{\n\t\t\t\tnearest_t = temp_t;\n\t\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\t\tnearest_hitNormal = temp_hitNormal;\n\t\t\t\tnearest_hitMatID = Plane[j].materialID;\n\t\t\t\thasHitSomething = true;\n\t\t\t}\n\t\t}\n\t}\n\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // * Accumulate lighting from each light source on the nearest hit point. \n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres and boxes) between the \n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n\tfor ( int j = 0; j < NUM_LIGHTS; j++ )\n\t{\n\t\tvec3 L = normalize(Light[j].position - nearest_hitPos);\n\t\tvec3 N = nearest_hitNormal;\n\t\tvec3 V = -ray.d;\n\t\tbool inShadow = false;\n\n\t\tRay_t ShadowRay;\n\t\tShadowRay.o = nearest_hitPos;\n\t\tShadowRay.d = L;\n\n\t\tfor ( int i = 0; i < NUM_BOXS; i++ )\n\t\t{\n\t\t\tif (IntersectBox(Box[i], ShadowRay,  DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n                if (dot(temp_hitPos-Light[j].position,ShadowRay.d) <=0.0 )\n\t\t\t\t\tinShadow = true;\n\t\t}\n\t\tfor ( int i = 0; i < NUM_PLANES; i++ )\n\t\t{\n\t\t\tif (IntersectPlane(Plane[i], ShadowRay, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n\t\t\t\tif (dot(temp_hitPos-Light[j].position,ShadowRay.d) <=0.0 )\n\t\t\t\t\tinShadow = true;\n\t\t}\n\t\tfor ( int i = 0; i < NUM_SPHERES; i++ )\n\t\t{\n\t\t\tif (IntersectSphere(Sphere[i], ShadowRay, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n\t\t\t\tif (dot(temp_hitPos-Light[j].position,ShadowRay.d) <=0.0 )\n\t\t\t\t\tinShadow = true;\n\t\t}\n\n\t\tI_local += PhongLighting(L, N, V, inShadow, Material[nearest_hitMatID], Light[j]);\n\t}\n\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CheckKeyboard();\n    InitScene();\n\tUpDate();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera/\n    vec3 cam_pos = vec3( 0.0+7.0* sin(iTime/7.0)* cos(iTime/3.0), 6.5+sin(iTime/4.0), 0.0+7.0* cos(iTime/2.0) );\n    vec3 cam_lookat = vec3( 0.0, 1.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ ) \n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}, {"id": "4tl3zf", "previewfilepath": "http://m.soundcloud.com/hinkik/outbreaker", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "http://m.soundcloud.com/hinkik/outbreaker", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttfSRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttfSWj", "name": "SpheresDischarge", "author": "Taron", "description": "Just playing around with 3d spheres, reflections and soft shadows along with some lens distortion. Oddly relaxing to watch, I find. Nothing really special, of course...<shrug>...might try to evolve this a bit more. Sure is a friendly exercise.", "tags": ["spheres", "reflections", "lensdistortion"], "likes": 12, "viewed": 178, "date": "1564356925", "time_retrieved": "2024-06-20T19:40:36.794604", "image_code": "#define sphereNum 10.\n#define sRadius 1.\n\nfloat mt;\n\nvec3 lightPos;\nint numLights = 0;\n \nvec3 spherePos[int(sphereNum)];\nbool blinkID[int(sphereNum)];\nint lightID[int(sphereNum)];\n\n\nvec2 random(vec2 p)\n{\n    vec3 a = fract(p.xyx*vec3(221.37, 143.45, 339.61));\n    a += dot(a, a+37.73);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nfloat shadowSphere(vec3 ro, vec3 rd, vec3 p, float radius)\n{\n    vec3 d = p-ro;\n    float b = dot(d, rd);\n    if(b<0.)\n        return 1.0;\n   \tvec3 c = ro+rd*b;\n    float s = length(c-p)/radius;\n    return max(0.,(min(1.,s)-.7)/.3);\n}\n\nfloat shadow(vec3 ro, vec3 rd, float id)\n{\n    float v = 1.;\n    for(float i=0.; i<sphereNum;i++)\n    {\n        if(blinkID[int(i)])\n            continue;\n        if(i!=id)\n        {    \n            float tt = mt+i*2.;\n            float ds = shadowSphere(ro, rd, spherePos[int(i)], sRadius);\n            v*=ds;\n            if(ds==0.)\n                return 0.;\n        }\n    }\n    return v*v*(3.-2.*v);\n}\nfloat lineDist(vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p-a;\n    vec3 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return length(pa-ba*t);\n}\nfloat line(vec3 p, vec3 a, vec3 b)\n{\n    float d= lineDist(p, a, b);\n    float m = smoothstep(.3, .01, d);\n    return m;\n}\n\nvec3 sphere(vec3 ro, vec3 rd, vec3 p, float radius, float id)\n{\n    \n    vec3 d = ro-p;\n    float a = dot(rd, rd);\n    float b = dot(d, rd);\n    float c = dot(d,d)-radius*radius;\n    \n    float disc = b*b-a*c;\n    if(disc<0.)\n        return vec3(-1.);\n    \n    float sqrtDisc = sqrt(disc);\n    float invA = 1.0/a;\n    \n    vec3 hit = (ro+(rd*(-b-sqrtDisc)*invA));\n    \n    if(blinkID[int(id)])\n        return vec3(1.,length(p+hit-ro),disc);\n    \n    vec3 norm = normalize(hit-p);\n    vec3 ref = reflect(rd,norm);\n\n    float dist = length(hit-ro);\n \n    float litv = 0.;\n    vec3 light = normalize(lightPos-(hit));\n    float lit = 0.;\n    float spec = 0.;\n\n    float shade = shadow(hit, light, id);\n    if(shade>0.)\n    {\n\n\n        lit = max(0.,dot(light, norm))*shade;\n        spec = pow(max(0.,dot(light, ref)),100.);\n        litv+=lit*.5+spec;\n    }\n    for(int i=0; i<numLights; i++)\n    {\n        vec3 light = normalize(spherePos[lightID[int(i)]]-(hit));\n        float lit = 0.;\n        float spec = 0.;\n\n        float shade = shadow(hit, light, id);\n        if(shade>0.)\n        {\n\n\n            lit = max(0.,dot(light, norm))*shade;\n            spec = pow(max(0.,dot(light, ref)),3.);\n            litv+=(lit+spec)*.2;\n        }\n    }\n    ref +=iTime*.2;\n    ref *=3.;\n    float fresnel = (1.-dot(norm,-rd));\n    float wall = fresnel*fresnel*fresnel*smoothstep(.3,0.0,min(4.*length(.5-fract(ref.x)),4.*length(.5-fract(ref.y))));\n    vec3 v = vec3(max(0.,litv+wall));\n    \n\n    return vec3(v.x, length(p+hit-ro), disc);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float lens = .99;\n    uv *=lens+(1.-lens)*pow(dot(uv,uv),2.);\n \n    vec2 suv = 4.*uv;\n    suv +=iTime*.2;\n    float muv = smoothstep(.1,0.0,min(4.*length(.5-fract(suv.x)),4.*length(.5-fract(suv.y))));\n    vec3 col = vec3(.5+.2*muv);\n    \n    vec3 ro = vec3(0.,0.,-10.-(35.*(iMouse.y/iResolution.y)));\n    vec3 rd = normalize(vec3(uv.x,uv.y,3.));\n    \n    lightPos = vec3(3.,10.+sin(iTime*.2)*10.,-5.);\n    \n    mt = iTime*.75+sin(iTime*.5)*.7+2.*iMouse.x/iResolution.x;\n    \n    float dep = 1000.;\n    float halo = 0.;\n    numLights = 0;\n    for(float i=0.; i<sphereNum;i++)\n    {\n        float blink = fract(mt*length(random(vec2(i+1.))))<.1?1.0:0.;\n        float tt = mt+i*2.;\n        vec3 sp = vec3(4.*sin(tt*2.),4.*cos(tt*1.5),4.*cos(tt*2.));\n        spherePos[int(i)] = sp;\n        blinkID[int(i)] = blink>0.;\n        if(blinkID[int(i)])\n        {\n            lightID[numLights]= int(i);\n            numLights++;\n            halo = max(0.,1.0-length(ro+rd*dot(sp-ro,rd)-sp)*.15);\n        }\n        \n    }\n    vec3 a = vec3(-100.);\n    vec3 b = vec3(-100.);\n    float keepHighest = 0.;\n    for(float i=0.; i<sphereNum;i++)\n    {\n        if( blinkID[int(i)])\n        {\n            \n            vec3 sd = ro+rd*dot(spherePos[int(i)] -ro,rd)-spherePos[int(i)];\n            halo = 1./dot(sd,sd)*.5;\n            if(a.x<-99.)\n            \ta = sd;\n            else if(b.x<-99.)\n                b = sd;\n        }\n        if(a.x>-100.&&b.x>-100.)\n            halo+=.15*line(vec3(rd.xy,0.),vec3(a.xy,0.),vec3(b.xy,0.));\n        \n        vec3 d = sphere(ro, rd, spherePos[int(i)] , sRadius, i);\n        keepHighest = max(keepHighest, d.y);\n        if(d.x>-1.)\n            if(d.y<dep)\n            {\n                float edge = min(d.z,.1)/.1;\n                edge *=edge *(3.-2.*edge); \n                dep = d.y;\n                d.y = (d.y-(ro.z+20.))/80.;\n                col =mix(col,mix(vec3(d.x,d.x,d.x),vec3(.5),d.y),edge)+vec3(blinkID[int(i)]?1.:0.);\n            }\n        if(dep>keepHighest&&blinkID[int(i)])\n        {\n            col+=halo;//halo*halo*+(3.-2.*halo)*.1;\n        }\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttfSWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttfSz2", "name": "RayMarchingBand004: TunnelWave.", "author": "Hirai_worthless", "description": "RayMarchingBand004", "tags": ["raymarching"], "likes": 3, "viewed": 286, "date": "1563546988", "time_retrieved": "2024-06-20T19:40:36.794604", "image_code": "vec2 path(float z){\n    float x = sin(z) + 2.0 * cos(z * 0.3) - 1.5 * sin(z * 0.12345);\n    float y = cos(z) + 1.5 * sin(z * 0.3) + 2.0 * cos(z * 0.12345);\n    return vec2(x,y);\n}\n\nfloat map(vec3 p){\n\t//p = fract(p/2.0) * 6.0 - 3.0;\n    vec2 o = path(p.z) / 4.0;\n\tfloat tBase = max(-length(p.xy - o) + 1.0 \n                      //* (1.0 + sin(p.z) * 0.5)\n                      ,length(p.xy - o) - 1.2 \n                      //* (1.0 + sin(p.z) * 0.5)\n                     );\n    float tdonut = max(-length(p.xy - o) + 0.5\n                      ,length(p.xy - o) - 0.6 \n                     );\n    tdonut = max(tdonut,abs(fract(p.z) - 0.5));\n    float tTube1 = length(p.xy - o + vec2(0.3,0.3)) - 0.025;\n    float tTube2 = length(p.xy - o + vec2(0.5,0.2)) - 0.025;\n    float tTube3 = length(p.xy - o + vec2(0.2,0.5)) - 0.025;    \n    float tTube4 = length(p.xy - o + vec2(-0.3,-0.3)) - 0.025;\n    float tTube5 = length(p.xy - o + vec2(-0.5,-0.2)) - 0.025;\n    float tTube6 = length(p.xy - o + vec2(-0.2,-0.5)) - 0.025;\n    float tTube = min(min(tTube1,tTube2),tTube3);\n    tTube = min(min(tTube,tTube4),min(tTube5,tTube6));\n\n    float bound = 2.0;\n    float tSplit = (fract(p.z)-0.5);\n    tSplit = min(tSplit, abs((p.x - o.x))-0.15);\n    tSplit = min(tSplit, abs((p.y - o.y))-0.15);\n\n    return min(min(max(tBase,-tSplit),tdonut),tTube);\n}\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 32; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return vec4(getNormal(p),t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float PI = 3.14159265;\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv,0.5));\n\n    float z = iTime * 4.0 ;\n    \n    r.xy *= mat2( sin(iTime),cos(iTime),\n    \t\t\t\t-cos(iTime),sin(iTime));\n\tvec2 a = path(z);\n    vec3 o = vec3(a / 4.0,z);\n    vec4 data = trace(o,r);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.3);\n    vec3 fc = mix(vec3(0.5 - data.x,0.5 -data.y,0.5-data.z),vec3(0),1.0 - fog);\n\tfc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttfSz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttfXD4", "name": "[TWITCH] Shader101 - Raymarching", "author": "Flopine", "description": "This is a shader I made during a live session on Twitch, about teaching people the basics of raymarching. You can watch them here: https://www.twitch.tv/flopine", "tags": ["3d", "raymarching", "course", "twitch"], "likes": 5, "viewed": 169, "date": "1562886145", "time_retrieved": "2024-06-20T19:40:37.546314", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n// This was a Twitch session where I gave people a course about the basics\n// of raymarching\n\n#define time iTime\nfloat iteration_number = 64.; \n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nfloat hash (vec2 x)\n{return fract(sin(dot(x, vec2(22.45,16.451)))*1257.44);}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n// Just for fun!\n// analitycal description of sphere provided by xor0110\n// played with the sign in the return line to display hyperboloid\nfloat analitycal_sphere (vec3 p, float radius)\n{ \n    float lx = length(p.x);\n    float ly = length(p.y);\n    float lz = length(p.z);\n    return sqrt(lx*lx + ly*ly + lz*lz) - radius;  \n}\n\nfloat sphere (vec3 p, float radius)\n{ return length(p)-radius; }\n\nfloat cylinder (vec3 p, float radius, float height)\n{ return max(length(p.xy)-radius, abs(p.z)-height); }\n\nfloat unsigned_box (vec3 p, vec3 corner)\n{ \n    vec3 q = abs(p)-corner;\n    return length(max(q,0.)); \n}\n\nfloat signed_box (vec3 p, vec3 corner)\n{ \n    vec3 q = abs(p)-corner;\n    return  min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.)); \n}\n\n// Signed Distance Function or map\nfloat SDF (vec3 p)\n{\n    float room = -signed_box(p, vec3(6.,3.,6.));\n\n\t// period for the repetition of the space\n    float per = 2.;\n    // id of each repetition cells in the x and z axis\n    vec2 id_xz = floor(p.xz/per);\n    p.xz = mod(p.xz, per)-per*0.5;\n    // cylinders that cut holes in floor and ceiling\n    float c = cylinder(p.xzy, 0.4, 1e10);\n\n\t// use the texnoise texture (in Bonzomatic) instead of typing a random function\n    p.y += time*texNoise(id_xz*0.1).r;\n    p.y = mod(p.y,per)-per*0.5;\n    // sphere changing to cube\n    float s = mix(sphere(p, 0.3), signed_box(p, vec3(0.25)), sin(time)*0.5+.5);\n\n    p.xz = mod(p.xz, per)-per*0.5;\n    // columns\n    float c1 = cylinder(p.xzy, 0.15, 1e10);\n\n    // room + holes and columns\n    float d = min(c1, max(-c, room));\n    // adding moving spheres\n    d = min(d,s );\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = hash(uv);\n\n    // ro\n    vec3 ray_origin = vec3(1.,0.,-4.); // step back\n    // rd\n    vec3 ray_direction = normalize(vec3(uv,1.)); //look forward\n    // p\n    vec3 position = ray_origin; // start from the origin\n\n    vec3 color = vec3(0.);\n\n    bool hit = false;\n\n    float shad = 0.;\n\n    for(float i=0.; i<iteration_number; ++i)\n    {\n        // d \n        float _distance = SDF(position);\n        \n        if (_distance < 0.01)\n        {\n            // store normaized iterations to colour shapes later\n            shad = i / iteration_number;\n            hit = true;\n            break;\n        }\n        \n        // replace banding by nice noise render\n        _distance *= 0.9 + dither*0.1;\n        \n        position += _distance*ray_direction;\n    }\n\n    if (hit) color = vec3(1.-shad); \n\n    //fragColor = vec4(color.r, color.g, color.b, 1.);\n    fragColor = vec4(color,1.);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttfXD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttlSD4", "name": "旋转的光", "author": "bluedrop", "description": "asin曲线的光挺好看的", "tags": ["2d"], "likes": 1, "viewed": 243, "date": "1563032973", "time_retrieved": "2024-06-20T19:40:37.546314", "image_code": "vec2 rot(vec2 p, float deg)\n{\n    mat2 rt = mat2(cos(deg),-sin(deg),sin(deg),cos(deg));\n    return p*rt;\n}\n\nfloat noise(vec2 p)\n{\n    return fract(sin(p.x*256.34*iTime + p.y*513.54)*792.43);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 col;\n    \n    float ang;\n    for(float i=0.; i<10.; ++i)\n    {\n        float len = length(rot(uv,iTime) + (uv*i)-.5);\n        ang = asin(0.001/len) * 20.;\n\t\tcol += ang * vec3(.5,.5,noise(uv*i))*abs(sin(iTime));\n\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttlSD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttlSR8", "name": "VoxelSphere", "author": "ankd", "description": "this is not good at get normal vector.\nmaybe normal vector become vec3(0.) by floor coordinate in map().", "tags": ["raymarching", "voxel"], "likes": 1, "viewed": 113, "date": "1562099142", "time_retrieved": "2024-06-20T19:40:37.546314", "image_code": "const float PI = acos(-1.0);\nconst float PI2 = PI*2.0;\n\nmat2 rotate(in float r) { \n    float c=cos(r), s=sin(r); \n    return mat2(c, -s, s, c);\n}\n\nfloat sphere(in vec3 p, in float r) {\n\treturn length(p) - r;\n}\nfloat box(in vec3 p, in vec3 b) {\n\tvec3 d = abs(p) - b;\n    return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat map(in vec3 p) {\n    vec3 q = p;\n    float n = 16.;\n    q = floor(q*n)/n;\n    float d = 1e8;\n\tfor(int i=0;i<8;i++) {\n\t    float fi = float(i)+1.0;\n\t\td = min(d, sphere(q-sin(PI*2.0*fi/8. + 0.3*fi*iTime*vec3(.5, .7, .9)), 0.5-0.05*fi));\n\t}\n\treturn d;\n}\n\nvec3 calcNormal(in vec3 p) {\n#if 0\n\tvec2 e = vec2(1., -1.) * 1e-3;\n    return normalize(\n    \te.xyy * map(p+e.xyy) +\n    \te.yxy * map(p+e.yxy) +\n    \te.yyx * map(p+e.yyx) +\n    \te.xxx * map(p+e.xxx)\n    );\n#else\n\tvec2 e = vec2(1., 0.) * 1e-3;\n    return normalize(vec3(\n    \tmap(p+e.xyy) - map(p-e.xyy),\n    \tmap(p+e.yxy) - map(p-e.yxy),\n    \tmap(p+e.yyx) - map(p-e.yyx)\n    ));\n#endif\n}\n\nfloat diffuse(in vec3 n, in vec3 l, in float s) {\n\treturn pow(clamp(dot(l, n), 0.01, 1.), s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord*2.0-iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 ro = vec3(0., 0., 1.5);\n    vec3 rd = normalize(vec3(p, -1.));\n    \n    float d = 0.;\n    for(int i=0;i<100;i++) {\n    \tvec3 pos = ro + rd*d;\n        float tmp = map(pos);\n\t\tif(tmp<1e-5) break;\n        d += tmp * 0.5;\n    }\n    \n    vec3 pos = ro + rd*d;\n    vec3 nor = calcNormal(pos);\n    \n    vec3 col = vec3(exp(-1.0 * d));\n    \n    vec3 ld = normalize(vec3(1.0));\n    \n    col *= diffuse(nor, ld, 2.);\n    \n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttlSR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttlSRH", "name": "polarmmt", "author": "mmtaipov", "description": "polar", "tags": ["polar"], "likes": 2, "viewed": 75, "date": "1562132561", "time_retrieved": "2024-06-20T19:40:37.673637", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y; \n    vec2 st=vec2(atan(uv.x,uv.y),length(uv));\n    uv=vec2(st.x/6.2831+0.5+0.4*iTime+st.y,st.y);\n    float x=uv.x*9.;\n    float m=min(fract(x),fract(1.-x));\n    float c=smoothstep(0.,0.1,m*0.6+0.2-uv.y);\n    \n    // Time varying pixel color\n     \n\n    // Output to screen\n    fragColor = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttlSRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttlSRj", "name": "FractalSmerityCircles", "author": "Smerity", "description": "FractalSmerityCircles with strong inspiration from Otavio Good ^_^\n\nClicking down the mouse activates the hyperbola version ;)", "tags": ["fractalsmeritycircles"], "likes": 2, "viewed": 152, "date": "1563583675", "time_retrieved": "2024-06-20T19:40:38.194779", "image_code": "// https://www.shadertoy.com/view/lds3z7\nfloat hash( float n )\n{\n\treturn fract(sin(n) * 54671.57391);\n}\n\nfloat noise( vec2 p )\n{\n\treturn 2.0 * hash( iTime * p.x + p.y * 57.1235 ) - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.y / iResolution.x;\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y *= ratio;\n    vec2 center = vec2(0.5, 0.5 * ratio);\n    uv -= center;\n    \n    // Anti-aliasing samples\n    float samples = 4.0;\n    \n    float finalCol = 0.0;\n    \n    for (int a = 0; a < int(samples); ++a) {\n        vec2 uv = fragCoord / iResolution.xy;\n       \tfloat noiseScale = 0.25;\n        uv.x += noiseScale * noise(float(a) * uv) / iResolution.x;\n        uv.y += noiseScale * noise(float(a) * uv) / iResolution.y;\n        uv.y *= ratio;\n        vec2 center = vec2(0.5, 0.5 * ratio);\n        uv -= center;\n        \n        vec2 coord = uv;\n\n        for (int i = 0; i < 5; ++i) {\n            // Causes the swipe to the bottom / top left\n            float yfuzz = sin(0.005 * iTime) * 0.001;\n            float xfuzz = cos(0.005 * iTime) * 0.4;\n            xfuzz -= 1.0;\n            yfuzz *= 1.0;\n            // Dictates the mirroring of the coordinates once it passes a threshold\n            // Smaller fstop means brighter image\n            float fstop = 0.38;\n            // If you want a hyperbola version centered around origin \n            fstop /= iMouse.z > 0.0 ? 28.0 * (uv.x * uv.y): 1.0;\n            coord = fract(coord * fstop * sin(0.4 * iTime) * xfuzz + 0.5 + yfuzz) * 2.0 - 1.0;\n            // Mirrored\n            float len = (2.0 - sin(0.3 * iTime)) * dot(coord, coord);\n            // Mirrorlen produces a scanline like effect\n            //float mirrorlen = (2.0 - sin(0.75 * iTime) - cos(uv.x * iTime)) * dot(coord, coord);\n            //coord = coord / len + 0.05 * coord / mirrorlen;\n            coord = coord / len;\n        }\n\n        //float circle = length(coord);\n        // Elongate the circle to form odd distorted smooth boxes\n        // See unit circles in various norms:\n        // https://en.wikipedia.org/wiki/Lp_space#/media/File:Vector-p-Norms_qtl1.svg\n        float circle = length(coord * coord * coord);\n\n        // The radius of the circle we're interested in shifts over time\n        float radius = 1.5 + sin(iTime);\n        // Otavio's neat-o trick for signed distance function\n        float scale = dFdx(uv.x);\n\n        float col = float((circle - radius) / scale > 0.0 ? 1.0 : 0.0);\n        finalCol += col;\n    }\n    \n    finalCol /= samples;\n    \n    // Debug mode makes it easy to see the circle start and end\n    //col = texture(iChannel0, coord).xyz;\n    \n    fragColor = vec4(finalCol, finalCol, finalCol, 1.0);\n\n}", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttlSRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttlSz4", "name": "atan fix v3", "author": "jorge2017a1", "description": "atan fix v3", "tags": ["atanfixv3"], "likes": 7, "viewed": 190, "date": "1562853144", "time_retrieved": "2024-06-20T19:40:38.194779", "image_code": "float hash21(vec2 p) {\n    // mod here\n    p = mod(p, 6.);\n    return fract(43758.5453123 * sin(dot(p, vec2(12.988, 243.233))));\n}\n\nfloat vnoise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3. - 2. * f);\n    return mix(mix(hash21(i), hash21(i + vec2(1, 0)), f.x),\n        mix(hash21(i + vec2(0, 1)), hash21(i + vec2(1, 1)), f.x), f.y);\n}\n\n\nvoid mainImage(out vec4 O, in vec2 I) {\n    \n    vec2 R = iResolution.xy;\n    vec2 uv = (2. * I - R.xy) / R.y;\n    \n    uv *= 50.+iTime;\n    uv = vec2(atan(uv.x, uv.y), length(uv));\n    //uv *= 5.+iTime*2.0;\n    \n    uv =uv+ sin( 5.+iTime*2.0);\n    \n    // scale here\n    float v = vnoise(uv * 6. / 6.283);\n    vec3 col = vec3(v);\n\n    \n    O = vec4(col, 1.);\n\n}\n\n\n//Old discontinous code\n/*\nfloat hash21(vec2 p) {\n    return fract(43758.5453123 * sin(dot(p, vec2(12.988, 243.233))));\n}\n\nfloat vnoise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3. - 2. * f);\n    return mix(mix(hash21(i), hash21(i + vec2(1, 0)), f.x),\n        mix(hash21(i + vec2(0, 1)), hash21(i + vec2(1, 1)), f.x), f.y);\n}\n\n\nvoid mainImage(out vec4 O, in vec2 I) {\n    \n    vec2 R = iResolution.xy;\n    vec2 uv = (2. * I - R.xy) / R.y;\n    \n    uv *= 5.;\n    uv = vec2(atan(uv.x, uv.y), length(uv));\n    \n    \n    float v = vnoise(uv);\n    vec3 col = vec3(v);\n\n    \n    O = vec4(col, 1.);\n\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttlSz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttlXDf", "name": "Broken Clouds", "author": "Chezzik", "description": "It's not doing exactly what I wanted, but it is interesting.  The undulating colors are slight variations based on neighboring cells.", "tags": ["2d", "grid", "subtle"], "likes": 2, "viewed": 83, "date": "1564535163", "time_retrieved": "2024-06-20T19:40:38.194779", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 t = uv;      \n    t.x*=iResolution.x/iResolution.y;\n    vec2 t2=fract(5.*t);\n    \n    \n    vec3 col=vec3(0.,0.,0.);\n    for (float i=-1.5; i<=0.5; i++) {\n        for (float j=-1.5; j<=0.5; j++) {\n            \n            vec2 unit = t2 + vec2(i, j);\n    \t\tvec2 t3=floor(5.* (t + vec2(i,j)));\n            \n            unit.x += 0.2*sin(iTime+t3.y) + 0.1*sin(iTime+t3.x);\n            unit.y += 0.1*sin(iTime+t3.y) + 0.2*sin(iTime+t3.x);\n\n            float d=clamp(length(unit), 0., 1.);\n    \n            vec3 a =  (1.-d) * (0.4 + 0.4*cos(iTime+uv.xxx+vec3(0,2,0)));\n            col += a;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttlXDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttlXzj", "name": "public_int_i slime puddles remix", "author": "fields37", "description": "oily\nremix of https://www.shadertoy.com/view/MtjXzc\nslower camera movement, faster bubbling", "tags": ["slime", "puddles", "gooey", "slimyparty"], "likes": 4, "viewed": 657, "date": "1563603205", "time_retrieved": "2024-06-20T19:40:38.194779", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5 -iTime*.005;\n    vec3 c = cos(vec3(iTime*.006,\n                  iTime*.025,\n                  iTime*.0095)*3.)*2.+2.;\n    for (int i = 0; i < 27; i++) {\n        vec3 p = vec3(uv*float(i),float(i));\n    \tc += vec3( sin(c.y+sin(p.x)),\n                   cos(c.z+sin(p.z)),\n                   -sin(c.x+sin(p.y)) );\n    }\n    fragColor = vec4(c*c*.004,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttlXzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttsSD8", "name": "Ghost Chamber #15", "author": "audiopixel", "description": "Blend between form and light", "tags": ["3d", "raymarching", "distancefield", "ghost"], "likes": 4, "viewed": 591, "date": "1562787759", "time_retrieved": "2024-06-20T19:40:38.201519", "image_code": "// Created by Hepp Maccoy 2019, hepp@audiopixel.com | http://audiopixel.com\n// Distance functions by Inigo Quilez, iquilezles.org\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec3 glow;\nfloat d1;\nfloat t1;\nfloat t2;\nvec3 b_8(vec3 c1, vec3 c2){\n    return (c1 + c2) - (c1 * c2);\n}\n\nvec3 b_6(vec3 c1, vec3 c2){\n    return (c1 + c2) - 1.0;\n}\n\nfloat soc(vec3 p) {\n    vec3 n = normalize(sign(p+1e6));\n    return min(min(dot(p.xy, n.xy), dot(p.yz, n.yz)), dot(p.xz, n.xz));\n}\n\nfloat sinc(float x, float k) {\n    float a = 3.14159265358979323846 * (float(k)*x-1.0);\n    return sin(a)/a;\n}\n\nmat2 r2d(float a) {\n    float sa=sin(a);\n    float ca=cos(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nvec2 mo(inout vec2 p, vec2 d) {\n    vec2 q = p;\n    q.x = abs(q.x) - d.x;\n    q.y = abs(q.y) - d.y;\n    if (q.y > q.x) q = q.yx;\n    return q;\n}\n\nfloat map(vec3 p) {\n    float d = 0.8194;\n    float a = abs(p.y);\n    p.yz *= r2d(sign(a) * -3.759);\n    p.xz *= r2d(sign(a) * sin(t2 * 7.) - 300.);\n    p.xz = mo(p.xz, vec2(-12.9879, -11.1065));\n    p.zx = mo(p.zx, vec2(5.4177, 2.3984));\n    p.xz = max(abs(p.xz) - -3.8964, -11.7321);\n    p.z = mod(p.z, 29.0)-(29.0 *.5);\n    p.x = mod(p.x, 66.4961)-(66.4961 *.5);\n    p.y = mod(p.y + d1, 29.0) - 5.;\n    p.zy = mo(p.zy, vec2(0.0, -9.6678));\n    p.xz = mo(p.xz, vec2(2.0, 11.1212));\n    p.yx = mo(p.yx, vec2(5.3815, 6.15875));\n    d = min(d, soc(max(abs(p) - 1.8368, -1.91 + (sin(d1 * .05) * 1.5))));\n    glow += vec3(0.8784314,0.8784314,0.8784314) * 0.0431 / (0.0539 + d*d);\n    return (length(p * -0.6424) - -0.7392) * 0.1944 - (d * -1.939);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    t1 = (iTime *.8) + 90.;\n    d1 = (-t1 * 11.) + 22.17;\n    t2 = t1 / 29.;\n    vec2 st = (fragCoord.xy / iResolution.xy) * 2.01 - 1.;\n    st.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(st, 97.0);\n    vec3 rd = normalize(vec3(st + vec2(0.), -0.49671));\n    vec3 mp;\n    mp = ro;\n    float md;\n    for(int i=0; i<92; i++) {\n        md = map(mp);\n        mp += (rd * 0.1784) * md;\n    }\n    float b = length(ro - mp);\n    float dA = 1.6979 - (b * 0.1462) * -0.6102;\n    float dB = 0.9117 - (b * 0.1348) * -1.998;\n    dA = sinc(dA, 0.3252);\n    dB = sinc(dB, 0.2127);\n    float src1 = dA * -0.3094;\n    float src2 = dB * -1.0;\n    float src3 = dB * -1.0;\n    float src4 = dA * 0.4847;\n    vec3 c;\n    src1 *= 2.0;\n    src2 *= 0.9038;\n    c = b_6((mix(vec3(0.0,0.5882353,1.0), vec3(0.0), src1) * 1.0),(mix(vec3(0.0), vec3(1.0,0.0,0.9411765), src2) * 1.211));\n    c = c * vec3(src3);\n    c = b_6(c,vec3(src4));\n    vec3 gt = c + (glow * 0.1);\n    c = b_8(c,gt);\n    fragColor = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttsSD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttsSW8", "name": "Flowing trigonometric fractal", "author": "jarble", "description": "Based on this fractal by iq: https://www.shadertoy.com/view/lsX3W4\nThis is another simple fractal, using a tangent function.", "tags": ["fractal"], "likes": 1, "viewed": 96, "date": "1562767579", "time_retrieved": "2024-06-20T19:40:38.201519", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tvec2 c = vec2(-0.05,.6805) + p;\n\n    // iterate\n    float di =  1.0;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<8; i++ )\n    {\n        if( m2>1024.0 ) { di=0.0; break; }\n\t\t// Z' -> 2·Z·Z' + 1\t\t\t\n        // Z -> Z² + c\t\t\t\n        z = vec2( z.x - z.y, z.x ) + c;\n        z /= tan(z.yx+iTime);\n        m2 = dot(z,z);\n    }\n\n    fragColor = vec4(vec3( di ), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttsSW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttsSzj", "name": "Jespertheend slime purple remix", "author": "fields37", "description": "tasty\nremix of https://www.shadertoy.com/view/MtcSWS", "tags": ["delicious", "slimyparty"], "likes": 4, "viewed": 517, "date": "1563603586", "time_retrieved": "2024-06-20T19:40:39.873657", "image_code": "#define AA 1\n#define DROP_COUNT 20\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere(vec3 p, float s){\n    return length(p)-s;\n}\n\nfloat lolRand(float seed){\n    return sin(seed*1000.)*0.5+0.5;\n}\n\n\n\n// ============== noise stuff\n// src: https://www.shadertoy.com/view/Xtl3W2\n\n\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n  }\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i);\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n\n// ======================\n\n\n\nfloat drop(vec3 a, vec3 b, float ra, float rb, float s){\n    vec3 ba = b - a;\n    float h = dot(-a,ba)/dot(ba,ba);\n    float d = (log2(1.44269/s))/s;\n    float start = pow(2.,d*s);\n    float minf = pow(2.,(h+d-start)*s);\n    float maxf = 1.-pow(2.,(-h+1.+d-start)*s);\n    if(h < start){\n        h = minf;\n    }\n    if(h > 1.-start){\n        h = maxf;\n    }\n    h = clamp(h, 0., 1.);\n    return length( -a - ba*h ) - mix(ra, rb, h);\n}\n\nfloat map(vec3 pos){\n    float sphereNoiseAmount = clamp(1.-pos.y,0.,1.)*0.05* 13.;\n    float sphereNoise = snoise(vec4(pos.x, pos.y+iTime*0.5, pos.z, 1.))*sphereNoiseAmount;\n    float sph = sdSphere(pos+sphereNoise, 1.);\n    float floorSph = sdSphere(pos * vec3(0.5, 3., 0.5) + vec3(0., 7.7, 0.), 1.);\n    float res = min(sph, floorSph);\n    \n    //drops\n    for(int i=0; i<DROP_COUNT; i++){\n        float seed = float(i)*10.;\n        float t = iTime+lolRand(seed*3.324)*5.;\n        const float dropDuration = 2.8;\n        seed += floor(t/dropDuration);\n        t= mod(t,dropDuration);\n        t += 1.;\n        float dropRot = lolRand(seed)*6.5;\n        float dropDist = pow(-lolRand(seed*2.34)+1.,1.8) * 0.8;\n        vec3 dropPos = pos + vec3(cos(dropRot)*dropDist, 0., sin(dropRot)*dropDist);\n        float size = 0.8-dropDist*0.5;\n        size = 0.6-dropDist*0.4;\n\n        float y1, y2, s1, s2;\n        //drop pos\n        if(t < 1.756){\n            y1 = 0.;\n        }else if(t < 2.9){\n            y1 = pow(t-1.756,4.);\n        }else{\n            y1 = -pow(100.,-t+2.82)+2.4;\n        }\n        y2 = pow(min(t,2.08)*0.6,4.);\n        y2 += 0.08;\n        \n        //drop size\n        s1 = -pow((t/5.)-0.5,2.)+0.2;\n        s2 = -pow(2.,-t-0.8)+0.6;\n        s1 *= size*0.5;\n        s2 *= size;\n        s1 = max(s1, 0.);\n        s2 = max(s2, 0.);\n        float dropd = drop(dropPos+ vec3(0., y1, 0.), dropPos+ vec3(0., y2, 0.), s1, s2, 5.);\n        res = smin(res, dropd, 0.2);\n    }\n    return res;\n}\n\nconst int MAX_RAY_STEPS = 128;\nconst float HIT_PRECISION = 0.009;\nconst float FAR_CLIPPING = 100.;\n\nfloat castRay(in vec3 ro, in vec3 rd){\n    float h = HIT_PRECISION * 2.;\n    float t = 0.;\n\n    for(int i=0; i<MAX_RAY_STEPS; i++){\n        h = map(ro+rd*t);\n        if(h < HIT_PRECISION || t > FAR_CLIPPING) break;\n        t += h;\n    }\n\n    float res = -1.;\n    if(t<=FAR_CLIPPING) res = t;\n    return res;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 e = vec2(.0001, 0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nconst vec3 BGND = vec3(.9,0.45,1.);\nconst vec3 BGNDIMG = vec3(0.5, .2, .6);\n\nvec4 render( in vec3 ro, in vec3 rd){\n    vec3 light = vec3(7., 1., -1.);\n\n    float z = castRay(ro, rd);\n    //return vec4(matInfo);\n    //return vec4(z/10.);\n    if(z == -1.){ // BG\n        vec3 bgDir = rd;\n        bgDir.y *= -1.;\n        return vec4(BGNDIMG,1.);\n        //return texture(iChannel0, bgDir);\n    }\n    vec3 pos = ro + rd * z;\n    vec3 normal = getNormal(pos);\n    \n    //see through amount\n    float seeThrough = clamp(3.-abs(pos.y*4.2+6.5),0.,1.);\n    //return vec4(seeThrough);\n    \n    //relative normal \n    float relNorm = dot(-rd, normal);\n    \n    //soft reflection / refraction\n    float reflectSoftMid = (snoise(vec4(pos*vec3(30., 1., 30.)+vec3(0.,1.,0.)*iTime, 0.))+0.3)*3.*seeThrough;\n    //float floorReflSoftDist = distance(vec2(0.),pos.xz+0.4*snoise(vec4(pos.xz*7.,0.,0.)));\n    //float floorReflSoft = 0.3*snoise(vec4(floorReflSoftDist*3.-iTime*0.1));\n    float floorReflSoftDisp = 0.3*snoise(vec4(pos.xz*7.,iTime*0.1,0.));\n    float floorReflSoftDisp2 = 1.*snoise(vec4(pos.xz*0.5,1.,0.));\n    float floorReflSoftDist = distance(vec2(0.),pos.xz+floorReflSoftDisp+floorReflSoftDisp2);\n    float floorReflSoft = sin(floorReflSoftDist*10.-iTime)*3.;\n    floorReflSoft *= clamp(-10.3-pos.y*5.,0.,1.);\n    float reflSoftTop = snoise(vec4(pos*10.+iTime*vec3(0.,3.,0.),0.))*10.+0.5;\n    reflSoftTop *= clamp(pos.y*5.+5.,0.,1.);\n    float reflectSoftAmount = clamp(reflSoftTop + reflectSoftMid + floorReflSoft, 0., 1.);\n    //return vec4(floorReflSoft);\n    \n    //refraction\n    vec3 refrDir = normalize(refract(rd, normal, 0.8));\n    //vec3 refrColHard = texture(iChannel0, refrDir).rgb;\n    vec3 refrColHard = BGND;\n    //vec3 refrColSoft = texture(iChannel1, refrDir).rgb;\n    vec3 refrColSoft = BGND;\n    vec3 refrCol = mix(refrColHard, refrColSoft, reflectSoftAmount);\n    \n    //reflection\n    //vec3 reflColHard = texture(iChannel0, normalize(reflect(rd, normal))).rgb;\n    vec3 reflColHard =  refrColHard = BGND;\n    //vec3 reflColSoft = texture(iChannel1, normalize(reflect(rd, normal))).rgb;\n    vec3 reflColSoft = BGND;\n    float reflAmount = pow(1. - relNorm,4.-seeThrough*3.);\n    reflAmount = clamp(reflAmount, 0., 1.);\n    vec3 reflCol = mix(reflColHard, reflColSoft, reflectSoftAmount);\n    //return vec4(reflAmount);\n    //return vec4(reflCol,1.);\n    \n    //color\n    vec3 absorbCol = mix(vec3(0., 1., 0.), vec3(0., 0.2, 0.), relNorm);\n    absorbCol = mix(vec3(1.), absorbCol, min(relNorm*3., 1.));\n    float absorbAmount = min(relNorm*2.5,1.) - seeThrough*0.5;\n    //return vec4(absorbAmount);\n\n    //vec4 col = vec4(normal, 1.);\n    vec3 col = mix(refrCol, absorbCol, absorbAmount);\n    col = mix(col, reflCol, reflAmount);\n    return vec4(col, 1.);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nconst float CAM_DIST = 4.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord2d ){\n    float camRot = iMouse.x*.01;\n    float camHeight = -iMouse.y*.01;\n    if(iMouse.x == 0. && iMouse.y == 0.){\n        camRot = iTime*0.2;\n        camHeight = -1.2;\n    }\n    vec3 camPos = vec3(cos(camRot)*CAM_DIST, camHeight, sin(camRot)*CAM_DIST);\n    vec3 camTarget = vec3(0., -1., 0.);\n    mat3 camMat = setCamera(camPos, camTarget, 0.);\n    #if AA<2\n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord2d.xy ) / iResolution.y;\n    vec3 rayDir = normalize(camMat * vec3(uv.xy,2.));\n    fragColor = render(camPos, rayDir);\n    #else\n    vec4 col = vec4(0.);\n    for(int m=0; m<AA; m++){\n        for(int n=0; n<AA; n++){\n            vec2 rr = vec2( float(m), float(n) ) / float(AA);\n    \t\tvec2 uv = ( -iResolution.xy + 2.0 * fragCoord2d.xy +rr ) / iResolution.y;\n    \t\tvec3 rayDir = normalize(camMat * vec3(uv.xy,2.));\n            col += render(camPos, rayDir);\n        }\n    }\n    col /= float(AA*AA);\n    fragColor = col;\n    #endif\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOrigin, in vec3 rayDir ){\n    fragColor = render(rayOrigin * 8. + vec3(0.,0.,4.), rayDir);\n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}, {"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttsSzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttsXDB", "name": "Slowly Swimming Fractal", "author": "mathmasterzach", "description": "Watch it swim", "tags": ["2d", "fractal", "dynamic", "magnet", "swim"], "likes": 19, "viewed": 375, "date": "1564205333", "time_retrieved": "2024-06-20T19:40:40.261626", "image_code": "//Based on the original formula from http://paulbourke.net/fractals/magnet/\n//Modified with different constants which change based on time and iteration\n\n//Thanks to FabriceNeyret2 for some additional optimizations!\n//Golfed version with 292 chars:\n/*\n#define S x-=1.+.5*sin((iTime+i)//\n#define M mat2( z, -z.y, z )//\n#define mainImage(O,U)                                  \\\n    float N=128., i=0., m=4., l=N;                      \\\n    for( vec2 n = iResolution.xy, z = n-n,              \\\n              u = 2.* ( U+U-n )/n.y;                    \\\n        i<N && l>0.;                                    \\\n         l =  4.-length(z=M*z) )                        \\\n         l < m ? m = l : m,                             \\\n         n = z+z + u,                                   \\\n         z = M*z + u,                                   \\\n         z.S/2.6),                             \\\n         z = M * vec2( n.S/2.)+.5, -n.y ) / dot(n,n),\\\n         O = m * ( cos(vec4(1,2,3,0)-5.*i++/N) + 1. ) / 8.\n*/\n\nfloat MAX_STEPS=128.;\nfloat PI=acos(-1.);\nfloat AA=2.;\n\n#define vecMul(a,b) vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x)\n#define vecDiv(a,b) vec2(a.x*b.x+a.y*b.y,a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)\n\nmat2 matRot(float a){\n\tfloat c=cos(a),\n          s=sin(a);\n    return mat2(c,s,s,-c);\n}\n\nvec3 samplePoint(vec2 c){\n    float i;\n    vec2 z=vec2(0.);\n    float maxl=0.;\n    for(i=0.;i<MAX_STEPS;i++){\n        vec2 numer = vecMul(z,z)+c; numer.x-=1.+.5*sin((iTime+i)/2.6);\n        vec2 denom = 2.*z+c;        denom.x-=1.5+.5*sin((iTime+i)/2.);\n        vec2 div   = vecDiv(numer,denom);\n        z = vecMul(div,div);\n        float d=dot(z,z);\n        if(d>16.){\n            break;\n        }\n        maxl=max(maxl,d);\n    }\n    \n    float ic=(5.*i/MAX_STEPS);\n    return (4.-sqrt(maxl))*(cos(vec3(1,2,3)-ic)+1.)/8.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 c=2.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    float delt=(2./iResolution.y)/AA;\n    vec3 col;\n    for(float y=0.;y<AA;y++){\n    \tfor(float x=0.;x<AA;x++){\n    \t\tcol+=samplePoint(c+vec2(x,y)*delt);\n    \t}\n    }\n    col/=(AA*AA);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttsXDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttsXRl", "name": "Rectangle Select Box", "author": "gcj2450", "description": "Rectangle Select box, like photoshop select rectangle", "tags": ["box", "rectselect"], "likes": 1, "viewed": 75, "date": "1563968652", "time_retrieved": "2024-06-20T19:40:40.261626", "image_code": "\n//draw a box use two corner point\nfloat rect(vec2 uv, vec2 p1, vec2 p2)\n{\n    vec2 edge = abs((p1 + p2)*0.5 - uv);\n    vec2 srect = smoothstep(edge- vec2(0.01), edge+ vec2( 0.01), abs(p1 - p2)*0.5);\n    return srect.x*srect.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    \tfloat rectbox = rect(uv, vec2(cos(5.0*iTime)*0.5+0.5),vec2(sin(iTime)*0.5+0.5));\n    \n\n    // Output to screen\n    fragColor = vec4(rectbox);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttsXRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttsXW7", "name": "Random Pipe System", "author": "Shane", "description": "Using the standard 2-edge Wang tile concept -- along with some basic layering techniques -- to create a system of pipes, rendered in an oldschool faux 3D style.", "tags": ["2d", "effect", "edge", "tile", "wang", "layer", "pipe"], "likes": 43, "viewed": 855, "date": "1563721036", "time_retrieved": "2024-06-20T19:40:43.310446", "image_code": "/*\n\n\n\tRandom Pipe System\n\t------------------\n\n\tUsing the standard 2-edge Wang tile concept -- along with some basic layering \n\ttechniques -- to create a system of pipes, rendered in an oldschool faux 3D \n\tstyle. I'm not sure if this a rendering of wall pipes, or an overhead camera\n\tsweep of floor pipes. :)\n\n\tI put together a simple pipe system based on Truchet concepts a while back,\n\twhich still looks interesting, but it lacks the variable density randomness\n\tthat Wang tile techniques provide.\n\n\tSince this was a effectively an upgrade on an earlier example, I wanted to \n\timprove the visuals. Not always, but that often involves more effort, which\n\ttranslates to more code. Therefore, this is not the most readable example.\n\tHowever, I went to the trouble of providing a very basic version to accompany\n\tthis. I've provided a link below, for anyone who doesn't wish to decode the \n\thaphazard logical mess to follow. :)\n\n\tI intend to produce a 3D single layered version of this, but thought it'd be \n\tfun to put together a fake isometric-looking one first. Believe it or not, the\n\t3D equivalent will be a lot easier to produce, but will probably require some \n\tdistance field tweaking to keep the frame rate up.\n\n\n\n    Simplified pipe version:\n\n\tSimple Wang Tile Example - Shane\n\thttps://www.shadertoy.com/view/ttXSzX\n\n\t\n\tOther examples:\n\n    // Put together ages ago. Demofox was doing it before it was cool. :D\n\tWang Tiling 2D - demofox \n\thttps://www.shadertoy.com/view/MssSWs\n\n\t// Like all his examples, it's concise and stylish. I put together one of these\n\t// and the 2-corner version a while back, which I'll put up at some stage.\n\t2-edge Wang Tiles - srtuss\n\thttps://www.shadertoy.com/view/Wds3z7\n\n    // This one incorporates a few concepts.\n\tDouble Simplex Wang Weave - Shane\n\thttps://www.shadertoy.com/view/tl2GWz\n\n\n\tWang tile resources:\n\n    // Possibly the best Wang tile resource on the net. \n\thttp://www.cr31.co.uk/stagecast/wang/intro.html\n\n\n*/\n\n\n \n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Dave Hoskins's vec2 to float hash.\n// You can find the details here:\n//\n// Hash without Sine - Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash21(vec2 p){ \n    \n    //  2 in, 1 out. \n\tvec3 p3  = fract(vec3(p.xyx)*.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n    \n    // An annoying, but necessary, hack for systems with less sin\n    // function accuracy. If anyone knows a way around it, feel \n    // free to let me know.\n    //p = floor(p*1048576.)/1048576.;\n    //return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); \n}\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.); // p *= p*p*(p*(p*6. - 15.) + 10.); //\n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n\n// Texture function.\nvec3 doTex(vec2 p){\n    \n    vec3 tx = texture(iChannel0, p).xyz; // sRGB texture read.\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n    \n\n// Use the unique edge point IDs to produce a Wang tile ID for the tile.\nfloat edges(vec2 ip, vec2[4] ep, float rnd){\n    \n    // Starting from the left and heading clockwise, generate a unique random number\n    // for each edge, then test it against a threshold. If it is above that threshold,\n    // flag that edge and use some standard bit encoding to produce an ID for that tile.\n    // For a 2-edge system, there will be sixteen combinations in total, each of which\n    // are represented by a four bit binary string encoded into integer form.\n    //\n    // For instance, a tile with an ID of 5 will convert to the binary string \"0101,\"\n    // which will indicate that you need to construct a tile that uses the first (left)\n    // edge midpoint and the third (right) edge midpoint. What is constructed is up to \n    // the individual. Since this is a simple example, we'll simply render a line from \n    // the left edge to the right edge. If it were diagonal edges, we could render a\n    // curved edge, and so forth.\n    //\n    // Since tiles share edges, you're guaranteed that neighboring tiles will connect.\n    //\n    // For a much better explanation that will usually include images, look up two-edge \n    // Wang tiles on the net. There are many references out there, but I prefer the \n    // explanation provided here:\n    //\n    // 2-edge Wang Tiles\n    // http://www.cr31.co.uk/stagecast/wang/2edge.html\n    \n    // Initial ID: Trivial, and converts to a binary string of \"0000,\" which indicates\n    // the cell has no edge points, or an empty tile.\n    float id = 0.;\n    \n    \n    // Note: exp2(i) = pow(2., i).\n    for(int i = 0; i<4; i++) id += hash21(ip + ep[i])>rnd? exp2(float(i)) : 0.;\n    \n    /* \n    // The above line is equivalent to the following:\n    vec4 e;\n    for(int i = 0; i<4; i++) e[i] = hash21(ip + ep[i]);\n    \n    if(e.x>rnd) id += 1.; // Left edge.\n    if(e.y>rnd) id += 2.; // Top edge.\n    if(e.z>rnd) id += 4.; // Right edge.\n    if(e.w>rnd) id += 8.; // Bottom edge.\n\t*/ \n    \n    return id; // Range [0-15] inclusive.\n    \n}\n\n\n// vec4 swap.\n//void swap(inout vec2 a, inout vec2 b){ vec2 tmp = a; a = b; b = tmp; }\n\n // Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 a, vec2 b){\n    \n\tb = a - b;\n\tfloat h = clamp(dot(a, b)/dot(b, b), 0., 1.);\n    return length(a - b*h);\n}\n\n\n// IQ's signed box formula.\nfloat sBox(vec2 p, vec2 b, float r){\n  \n  // Just outside lines.\n  //p = max(abs(p) - b + r, 0.);\n  //return length(p) - r;\n\n  // Inside and outside lines.\n  vec2 d = abs(p) - b + r;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;\n}\n\n\n// A stretched leaf for the grid nodule.\nfloat leaf(vec2 p, float a){\n    \n    p *= rot2(6.2831*a); // Rotate.\n    p.y = max(abs(p.y) - .125, 0.); // Elongate.\n\n    return (length(p) + abs(p.x))/1.4142; // Leaf.\n}\n\n// The grid pattern. Just two overlapping grids of rotated\n// leaves, rendered 90 degrees to one another. \nfloat gridPat(vec2 p, vec2 ip){\n    \n    //if(mod(ip.x + ip.y , 2.)>.5) p.x = -p.x;;\n    \n    // Scale the grid, and offset it by half.\n    p = p*5. - .5;\n    \n    // Leaf one.\n    vec2 q = p, iq = floor(q); q -= iq + .5;\n    float d = leaf(q, 1./8.) - .1;\n    \n    // Leaf two.\n    q = p + vec2(.5, .5), iq = floor(q); q -= iq + .5;\n    float d2 = leaf(q, -1./8.) - .1;\n    \n    /*\n    // Not rendering on the edges.\n    if(iq.x==-3.) d2 = 1e5;\n    if(iq.x==2.) d2 = 1e5;\n    if(iq.y==-3.) d2 = 1e5;\n    if(iq.y==2.) d2 = 1e5;\n    */\n    \n    return min(d, d2); // Combine the leaves.\n    \n}\n\n// Random tap rendering in the three and four end-point cells.\nfloat doTap(int iNum, int bend, vec2 ip){\n   \n    // Checker pattern, so that the taps never sit next\n    // to one another.\n    float ch = mod(dot(ip, vec2(1)), 2.);\n    return (iNum>=3 && bend==0 && hash21(ip + 5.)>.7 && ch>.5)? 1. : 0.;\n    //return (iNum>=3 && bend==0 && ch>.5)? 1. : 0.;\n    \n}\n\n// Random guage rendering in the straight two end-point cells.\nfloat doGuage(int iNum, int bend, vec2 ip){\n   \n    // Checker pattern, so that the guages never sit next\n    // to one another.\n    float ch = mod(dot(ip, vec2(1)), 2.);\n    return (iNum==2 && bend==0 && hash21(ip + 173.)>.5 && ch>.5)? 1. : 0.;\n    \n}\n\n// vec4 swap.\n//void swap(inout vec2 a, inout vec2 b){ vec2 tmp = a; a = b; b = tmp; }\n\n\n// Distance field-related struct: Containers are handy, but I try to avoid them in\n// shaders for readability sake. However, there were too many variables I wanted \n// to return from the function to avoid its usage.\nstruct ds{\n    \n    float grid; // Grid.\n    float pat; // Grid pattern.\n    \n    float ln; // Pipe line.\n    float ep; // End point sleaves.\n    // Three circles: The round central point for the single end-point\n    // cells, the taps, and the guages.\n    vec3 ci; \n    \n    //float id; // Wang tile ID. Not used here.\n    vec2 ip; // Unique grid ID.\n    \n    int iNum; // Tile end-point number. Range: [0-4].\n    int bend; // Pipes can either be straight or curved.\n    \n};\n\nds wang(vec2 p){\n\n    // The stuct to hold the Wang tile information to return for rendering. \n    ds di;\n\n   \n    di.ip = floor(p); // Grid ID.\n    p -= di.ip + .5; // Local coordinates.\n    \n    vec2 q = p; // Local variable holding variable.\n    \n    // Grid pattern. This was calculated here, because I'd originally wanted to \n    // bump map it, but I changed my mind later.\n    di.pat = gridPat(q, di.ip);\n    \n    // The grid squares.\n    q = abs(p);\n    di.grid = abs(max(q.x, q.y) - .5) - .01;\n    \n    \n    // Wang tile construction.\n    \n    // Four edge midpoints: Clockwise from the left.\n    vec2[4] eps = vec2[4](vec2(-.5, 0), vec2(0, .5), vec2(.5, 0), vec2(0, -.5));\n    vec2[4] cp = eps; // Holding points.\n    \n    // Get the Wang tile ID. The random number effects the density of the pipe\n    // distribution.\n    const float rnd = .45;\n    float id = edges(di.ip, eps, rnd);\n    \n    // Decode each binary digit.\n    vec4 bits = mod(floor(id/vec4(1, 2, 4, 8)), 2.);\n    \n    di.iNum = 0; // Edge point index.\n    \n    for(int i = 0; i<4; i++){\n        // If the edge bit is flagged, add an end point to the array, whilst \n        // increasing the array index. By the way, we could combine more of \n        // these steps in the \"edges\" function, but I wanted to show the encode \n        // and decode process.\n        if(bits[i]>.5) cp[di.iNum++] = eps[i]; \n        \n    }\n    \n    \n    di.ep = 1e5; //  Midpoint end-point sleeves.\n    di.ln = 1e5; // The pipes themselves.\n    di.ci = vec3(1e5); // The footers, taps and guages.\n    \n    const float lw = .16; // Pipe line width.\n \n    \n    // Edge point joins and the boxes to represent the pipes.\n    vec2 join = vec2(lw*.6, lw + .025);\n    vec2 boxLine = vec2(.25 + lw, lw);\n    \n\n    \n    q = p; // Set \"q\" to the cell's local coordinates.\n    \n    // Is the tile going to contain a curved pipe?\n    di.bend = 0;\n    if(di.iNum==2 && length(cp[0] - cp[1])<.99) di.bend = 1; // Points on diagonal or vertical.\n    // Four end point tiles can contain a cross pipe, or two curved pipes, which can be\n    // randomly rotated as well.\n    if(di.iNum==4 && hash21(di.ip + 7.)>.5){\n        // Randomly orient some of the pipe pairs the opposite way for more variation.\n        if(hash21(di.ip + 27.)>.5) q.y = -q.y; // swap(cp[1], cp[3]);\n        di.bend = 1;\n    }\n    \n    for(int i = 0; i<4; i++){\n        if(bits[i]>.5){\n            di.ep = min(di.ep, sBox(q - eps[i], join, .035));\n            if(di.bend==0) di.ln = min(di.ln, sBox(q - eps[i]/2., boxLine, lw));\n        }\n        \n        // Because we're heading clockwise, we need to reorient the the joins, etc.\n        join = join.yx;\n        boxLine = boxLine.yx;\n    } \n    \n    // If necessary, construct one curved pipe between two end-points, or two\n    // if there are four end-points.\n    if(di.bend==1){\n        \n        vec2 pnt;\n        float rf = di.iNum==2? .3 : .4; // Sharper bends for just one curved pipe.\n        pnt.x = abs(cp[0].x)>abs(cp[1].x)? cp[0].x : cp[1].x;\n        pnt.y = abs(cp[0].y)>abs(cp[1].y)? cp[0].y : cp[1].y;\n        //ln = min(ln, abs(length(q - pnt) - .5) - lw);\n        di.ln = min(di.ln, abs(sBox(q - pnt, vec2(.5), rf)) - lw);\n        \n        if(di.iNum==4){ // The second curved pipe, if applicable.\n            pnt.x = abs(cp[2].x)>abs(cp[3].x)? cp[2].x : cp[3].x;\n            pnt.y = abs(cp[2].y)>abs(cp[3].y)? cp[2].y : cp[3].y;\n            //ln = min(ln, abs(length(q - pnt) - .5) - lw);\n            di.ln = min(di.ln, abs(sBox(q - pnt, vec2(.5), rf)) - lw);\n        }\n\n    }    \n    \n    // Construct the pipe footers at the center of the single end-point tiles.\n    if(di.iNum==1) di.ci.x = min(di.ci.x, length(q) - lw - .095);\n    \n    // Tap... at some of the junctions? It seems like a pipe system thing to do. :D\n    if(doTap(di.iNum, di.bend, di.ip)>.5){\n       \n        \n        // Randomly oriented, to show they've been turned.\n        q = rot2(3.14159*hash21(di.ip + 9.))*p;\n       \n        // The main body of the tap.\n        di.ci.y = min(di.ci.y, length(q) - .24);\n        \n        // Tap nodules, spread around in a hexagonal fashion.\n        //\n        // Standard repeat polar cells.\n     \tconst float rad = .22;\n    \tconst float aNum = 6.;\n    \tfloat a = atan(q.y, q.x);\n        float ia = floor(a/6.283*aNum) + .5; // .5 to center cell.\n        q = rot2(ia*6.283/aNum)*q;\n        q.x -= rad;\n        \n        float s = sBox(q, vec2(.08, .08), .06);\n        di.ci.y = min(di.ci.y, s);\n  \n    }\n    \n    // Putting a pressure guage, or something like that, on some of the straight pipes.\n    if(doGuage(di.iNum, di.bend, di.ip)>.5){\n        \n        di.ci.z = min(di.ci.z, length(q) - .3);\n \n    }\n    \n    // Return the distance field-related struct.\n    return di;\n    \n}\n\n\n// Shorthand for this particular expression, which gets used a lot.\n#define ss(a, b) 1. - smoothstep(0., a, b)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates. Setting a minumum resolution on the\n    // fullscreen setting in an attempt to keep things relatively crisp.\n    float iRes = min(800., iResolution.y);\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    // Scaling and translation.\n    const float gSc = 6.;\n    vec2 p = uv*gSc - vec2(-iTime, cos(iTime/8.)*2.);\n    \n    // Smoothing factor, based on resolution and scaling factor.\n    float sf = 1./iRes*gSc;\n    \n    // Taking some Wang tile samples, for rendering.\n    vec2 e = vec2(.015, .03);\n    float le = length(e);\n    \n    ds di = wang(p); // Standard sample.\n    ds di2 = wang(p - e); // Near offset for highlight calulations.\n    ds dis = wang(p + 5.333*e); // Opposite, larger offset for shadows.\n    \n    \n    ds diHi; // Holding container for highlight calculations.\n\n    // Background texture.\n    vec3 txPat = doTex(p/gSc + e);\n    // Scene color, pipe color and end-point sleeve color.\n    vec3 col = txPat*2.*vec3(1, .85, .7);\n    vec3 lCol = vec3(1, .7, .4)*mix(vec3(1), txPat*3., .5);\n    vec3 sCol = vec3(1, .6, .3);\n\n    \n    \n    vec3 tCol = col; // Temporary holding color.\n    \n    // Background grid pattern.\n    //col = mix(col, vec3(0), (ss(sf*6.*4.,  max(di.pat - .02*6., -(di.grid - .07))))*.5);\n    //col = mix(col, vec3(0), (ss(sf*6.,  max(di.pat - .02*6., -(di.grid - .07))))*.75);\n    //col = mix(col, tCol*2., (ss(sf*6., max(di.pat, -(di.grid - .07))))*.7);\n    col = mix(col, vec3(0), (ss(sf*6.*4., di.pat - .02*6.))*.5);\n    col = mix(col, vec3(0), (ss(sf*6.,  di.pat - .02*6.))*.75);\n    col = mix(col, tCol*2., (ss(sf*6., di.pat))*.7);\n    \n    // The grid.    \n    diHi.grid = max(smoothstep(0., sf*4., di2.grid - .005) - \n                smoothstep(0., sf*4., di.grid - .005), 0.)/le*.015;\n    col += diHi.grid;\n    col = mix(col, vec3(0), (ss(sf*4., di.grid - .02))*.5);\n    col = mix(col, vec3(0), (ss(sf, di.grid)));\n    //col = mix(col, vec3(0), ss(sf, abs(di.grid - .07) - .01));\n    \n    // The drop shadow consists of all the combined major elements. We\n    // take the minimum of all, then render the blurred silhouette onto\n    // ground layer. Without it, this example would really lack depth.\n    // Comment the shadow layer out, and you'll see what I mean.\n    float shadow = min(min(min(dis.ci.x, dis.ci.y), dis.ci.z), dis.ln);\n    shadow = min(shadow, dis.ep);\n    col = mix(col, vec3(0), (ss(sf*8., shadow - .02))*.6);\n    \n    // Pipe footers, at the center of the single end-point tiles.\n    col = mix(col, vec3(0), (ss(sf*4., di.ci.x - .02))*.5);\n    col = mix(col, vec3(0), ss(sf, di.ci.x));\n    col = mix(col, lCol, ss(sf, di.ci.x + .03));\n    col = mix(col, vec3(0), ss(sf, abs(di.ci.x + .06) - .01));\n    \n    \n    // Pipes with fake AO and highlights.\n    vec3 txLn = doTex(p/gSc);\n    txLn *= vec3(1, .85, .7);\n    float pat2 = clamp(cos(di.ln*6.2831*24.) + .75, 0., 1.)*.2 + .9;\n    float sh = max(.35 - (di.ln + .03)*12., 0.);\n    diHi.ln = max(di.ln - di2.ln, 0.)/le;\n    col = mix(col, vec3(0), (ss(sf*4., di.ln - .04))*.5);\n    col = mix(col, vec3(0), ss(sf, di.ln));\n    col = mix(col, txLn*(diHi.ln + sh*sh*.25 + .25)*pat2, ss(sf, di.ln + .025));\n    col = mix(col, col*2., (ss(sf*4., di2.ln + .125))*.8);\n    //col = mix(col, vec3(0), ss(sf, abs(di.ln + .12) - .01));\n    \n    \n    // Pipe joins, with fake AO and highlights.\n    sh = max(.05 - (di.ln + .02)*12., 0.);\n    //diHi.ep = max(di.ep - di2.ep, 0.)/le;\n    col = mix(col, vec3(0), (ss(sf*4., di.ep - .02))*.5);\n    col = mix(col, vec3(0), ss(sf, di.ep));\n    col = mix(col, sCol*(diHi.ln*diHi.ln + sh*sh*.5 + .25)/2., ss(sf, di.ep + .025));\n    col = mix(col, col*3., (ss(sf*4., max(di.ep, di2.ln + .125)))*.8);\n    //col = mix(col, vec3(0), (ss(sf, abs(di.ep + .04) - .01))*.75);\n    col = mix(col, vec3(0), ss(sf, max(di.ep, di.grid)));\n\n     \n    // Flow tap, or whatever it's called. :)\n    if(doTap(di.iNum, di.bend, di.ip)>.5){\n        \n        vec2 q = fract(p) - .5;\n        \n        // The main tap background.\n        diHi.ci.y = max(di.ci.y - di2.ci.y, 0.)/length(e);\n        sh = max(.75 - - di.ci.y*4., 0.);\n        col = mix(col, vec3(0), (ss(sf*4., di.ci.y - .04))*.5);\n        col = mix(col, vec3(0), ss(sf, di.ci.y));\n        col = mix(col, lCol*(diHi.ci.y + sh*sh*.1 + .5), ss(sf, di.ci.y + .03));\n         \n        // Extra rings.\n        col = mix(col, vec3(1), (ss(sf, abs(length(q) - .12) - .02))*.2);\n        col = mix(col, vec3(0), ss(sf, abs(di.ci.y + .16) - .015));\n        col = mix(col, vec3(0), ss(sf, length(q) - .03));\n\n        // Subtle highlights.\n        col = mix(col, col*2., (ss(sf*4., di.ci.y + .125))*.7);\n        col = mix(col, vec3(0), ss(sf, abs(di.ci.y + .08) - .01));\n        \n        \n    }\n    \n    // Guage, or dial. A lot of it is made up on the spot, with a touch of common sense thrown in. :)\n    // There'd be more efficient ways to get this done, but not too many pixels are effected, plus\n    // this isn't a taxing example to begin with.\n    if(doGuage(di.iNum, di.bend, di.ip)>.5) {\n        \n        // Local coordinates.\n        vec2 q = fract(p) - .5;\n\n        // Backface with a bit of highlighting.\n        diHi.ci.z = max(di.ci.z - di2.ci.z, 0.)/length(e);\n        sh = max(.75 - di.ci.z*4., 0.);\n        col = mix(col, vec3(0), (ss(sf*4., di.ci.z - .04))*.5);\n        col = mix(col, vec3(0), ss(sf, di.ci.z));\n        col = mix(col, lCol*(diHi.ci.z + sh*sh*.1 + .5), ss(sf, di.ci.z + .03));\n        \n        \n        // More rings in the center.\n    \tcol = mix(col, col*1.6, ss(sf*4., di.ci.z + .125));\n    \tcol = mix(col, vec3(0), ss(sf, abs(di.ci.z + .08) - .01));\n       \n        col = mix(col, vec3(0), (ss(sf, length(q) - .08))*.5);\n        col = mix(col, vec3(0), ss(sf, abs(length(q) - .1) - .01));\n        col = mix(col, vec3(0), ss(sf, length(q) - .05));\n        \n        \n        // Constructing the red indicator at a random angle, and providing some animation,\n        q = rot2(6.2831*hash21(di.ip + 31.) + (hash21(di.ip + 19.)*.8 + .2)*sin(iTime))*q;\n        float ind = distLine(q - vec2(0, -.005), q - vec2(0, .16)) - .0025;\n        \n        // Constructing the clock-like markings on the dial using standard repeat polar\n        // coordinates.\n        q = fract(p) - .5;\n    \tconst float rad = .16;\n    \tconst float aNum = 12.;\n        q = rot2(3.14159/aNum)*q;\n    \tfloat a = atan(q.y, q.x);\n        float ia = floor(a/6.283*aNum) + .5; // .5 to center cell.\n        ia = ia*6.283/aNum;\n        q = rot2(ia)*q;\n        q.x -= rad;\n        \n        // Markings.\n        float mark = sBox(q, vec2(.025, .015), 0.);\n        col = mix(col, vec3(.5), ss(sf, mark - .015));\n        col = mix(col, vec3(0), ss(sf, mark));\n        \n        // Indicator.        \n        col = mix(col, vec3(0), ss(sf, ind - .025));\n        col = mix(col, vec3(.5, 0, 0), ss(sf, ind));\n        \n        \n    }\n \n    \n    // Very subtle sepia tone with a sprinkling of noise, just to even things up a bit more.\n    col *= vec3(1.1, 1, .9)*(n2D(p*64.)*.8 + .6);\n  \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./16.)*1.05;\n    \n    // Rough gamma correction before presenting to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttsXW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttsXWr", "name": "[twitch] Hanging Plants", "author": "NuSan", "description": "Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/HangingPlants.glsl", "tags": ["raymarching", "glow", "kifs"], "likes": 18, "viewed": 425, "date": "1562621647", "time_retrieved": "2024-06-20T19:40:43.310446", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/HangingPlants.glsl\n*/\n\nfloat time=0.0;\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*.5+.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat mat=0.0;\nfloat at=0.0;\nfloat map(vec3 p) {\n  \n  vec3 bp2 = p;\n  \n  float tt = time*0.5;\n  p.xz += sin(p.zx*vec2(0.1,0.07)+tt*1.3)*2.0;\n  //p.y += sin(p.x*0.1+tt)*5 + sin(p.y*0.25+tt)*3;\n  \n  p.y+=100.0;\n  float t2=sin(time*0.3 + p.y*0.005)*0.5;\n  p.yz *= rot(t2*0.5);\n  p.xy *= rot(t2);\n  p.y-=100.0;\n  \n  float s=32.0;\n  for(float i=0.0; i<5.0; ++i) {\n    p.xz*=rot(0.3+i);\n    p.xz+=s;\n    p.xz=abs(p.xz);\n    p.xz-=s;\n    s*=0.6;\n  }\n  \n  float zone = 30.0;\n  p.xz = (fract(p.xz/zone-.5)-.5)*zone;\n  \n  vec3 bp=p;\n  \n  float d = 10000.0;\n  float prevd = length(p.xz)-1.0;\n  float off=p.y;\n  \n  float dist=4.0;\n  p.y = (fract(p.y/dist-.5)-.5)*dist;\n  p.y=abs(p.y);\n  p.y=smin(p.y,-p.y,-1.0);\n  p.y=dist*0.5-smin(dist*0.5-p.y,-(dist*0.5-p.y),-1.0);\n  \n  p.y-=dist*0.25;\n  \n  for(float i=0.0; i<7.0; i++) {\n    float t=time*0.2+i + off*0.1+22.7;\n    p.xy *= rot(t);\n    p.yz *= rot(t-1.2);\n    d = smin(d, length(p-vec3(0,1.3,0))-1.0, 0.3);\n  }\n  \n  \n    \n  at += 0.2/(0.2+abs(d));\n  \n  mat=clamp((d-prevd+0.1)/0.3,0.0,1.0);\n  d = smin(d, prevd, 0.3);\n  \n  d = smin(d, bp.y-sin(bp.x*0.02)*10.0-sin(bp.z*0.034)*8.0, -2.0);\n    \n  d *= 0.7;\n    \n  return d;\n}\n\nvoid cam(inout vec3 p) {\n  \n  p.yz *= rot(-0.5);\n  p.xz *= rot(time*0.2);\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  // this fixes glitches when time is too high, but cause a cam cut every two minutes\n  time = mod(iTime, 120.0);\n\n  vec3 s=vec3(5,0,-40);\n  vec3 r=normalize(vec3(-uv, 1.0));\n  \n  cam(s);\n  cam(r);\n  \n  float maxdist = 300.0;\n  \n  vec3 p=s;\n  float dd=0.0;\n  for(int i=0; i<100; ++i) {\n    float d=map(p);\n    if(abs(d)<0.001) {\n      break;\n    }\n    if(dd>maxdist) {dd=maxdist; break;}\n    p+=d*r;\n    dd+=d;\n  }\n  \n  float curmat = mat;\n  float curat = at;\n  \n  vec3 col=vec3(0);\n  \n  vec2 off=vec2(0.05,0);\n  vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  \n  vec3 l= normalize(-vec3(1,3,2));\n  vec3 h=normalize(l-r);\n  float fog = pow(1.0-clamp(dd/maxdist,0.0,1.0), 1.0);\n  float fre=pow(1.0-abs(dot(n,r)),2.0);\n  \n  float sss=smoothstep(0.0,1.0,map(p+l*10.0)/10.0)+smoothstep(0.0,1.0,map(p+l*5.0)/5.0)+smoothstep(0.0,1.0,map(p+l*1.0));\n  float spec = max(0.0, dot(n,h));\n  \n  vec3 sky = mix(vec3(1,0.3,0.2), vec3(1.0,0.6,1.0)*2.0, pow(abs(r.y),2.0) * pow(1.0-fog,1.0));\n  \n  col += (dot(n, l)*0.5+0.5) * fog * (vec3(0.2,0.6,0.3)*0.5) * curmat;\n  col += max(dot(n, l),0.0) * fog * (pow(spec,10.0)*2.0);\n  col += sky*sss*fog * 1.0 * (1.0-curmat) * 0.5;\n  \n  col += pow((1.0-fog)*1.7, 3.0) * sky;\n  col += sky*fre*fog;\n    \n  col += pow(curat * 0.05,0.8) * sky;\n  \n  col *= 1.2-length(uv);\n  \n  col = 1.0-exp(-col*2.0);\n  col = pow(col, vec3(1.5));\n  \n  \n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttsXWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttXSRn", "name": "Retro loading", "author": "z0rg", "description": "A small loading screen for a compo.", "tags": ["loading"], "likes": 3, "viewed": 202, "date": "1561964524", "time_retrieved": "2024-06-20T19:40:44.723051", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nconst float cMin = 0.05;\nconst float cMax = 0.07;\nfloat cthick = cMax - cMin;\n\nfloat sat(float a)\n{\n    return clamp(a, 0.,1.);\n}\n\nbool isIn(float a, float mi, float ma)\n{\n    return a > mi && a < ma;\n}\n\nfloat drawD(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  float val = float(isIn(uv.y, -cMax, cMax) && isIn(uv.x,-cthick*2.0, -cthick));\n  float val2 = float(isIn(length(uv), cMin, cMax) && uv.x > 0.0);\n  return val + val2;\n}\n\nfloat drawY(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  float valA = float(isIn(length(uv+vec2(0.0, -cMax)), cMin, cMax) && uv.y < cMax && !isIn(uv.x, -cthick, cthick));\n  float valB = float(isIn(uv.x, -cthick*0.5,cthick*0.5) && isIn(uv.y, -cMax, 0.0));\n  return valA +valB;\n}\n\nfloat drawL(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  float val = float(isIn(length(uv), cMin, cMax) && uv.y < 0.0 && uv.x < (cMax-cMin)*0.5);\n  float valB = float(isIn(uv.y, 0.,cMax) && (isIn(uv.x, -cMax, -cMin)));\n  return val+valB;\n}\n\nfloat drawN(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  float val = float(isIn(length(uv), cMin, cMax) && uv.y > 0.0);\n  float valB = float(isIn(uv.y, -cMax, 0.0) && (isIn(uv.x, -cMax, -cMin) || isIn(uv.x, cMin, cMax)));\n  return val+valB;\n}\n\nfloat drawI(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  return float(isIn(uv.y, -cMax, cMax) && isIn(uv.x, -cthick*0.5,cthick*0.5));\n}\n\nfloat drawS(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n//  float ref = float(isIn(length(uv), cMin, cMax));\n  float valA = float(isIn(length(uv), cMin, cMax) && !isIn(uv.y, -cthick, cthick));\n  float valB = float(isIn(-uv.y - uv.x*0.4, -cthick*0.5, cthick*0.5) &&\n    length(uv) < cMax);\n  return valA + valB;\n}\n\nfloat drawO(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  bool onCir = isIn(length(uv), cMin, cMax);\n    return float(onCir);\n}\n\nfloat drawC(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  bool onCir = isIn(length(uv), cMin, cMax);\n  float valA = float(onCir && uv.x > 0.0 && !isIn(uv.y, -cthick, cthick) ||\n    uv.x <= 0.0 && onCir);\n\n  return valA;\n}\n\n\nfloat drawP(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  float val = float(isIn(uv.y, -cMax, cMax) && isIn(uv.x,-cthick*2.0, -cthick));\n  float val2 = float(isIn(length(uv+vec2(0.0, -0.02)), cMin - cthick, cMin) && uv.x > 0.0);\n\n  return val + val2;\n}\n\nfloat drawR(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  float val = float(isIn(uv.y, -cMax, cMax) && isIn(uv.x,-cthick*2.0, -cthick));\n  float val2 = float(isIn(length(uv+vec2(0.0, -0.02)), cMin - cthick, cMin) && uv.x > 0.0);\n  uv -= vec2(0.0, -0.02);\n  float  val3 = float(isIn(-uv.y-uv.x, -cthick*0.5,cthick*0.5) &&\n    isIn(uv.y, -0.05, -0.02));\n  return val + val2 + val3;\n}\n\nfloat drawG(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  bool onCir = isIn(length(uv), cMin, cMax);\n  float valA = float(onCir && uv.x > 0.0 && !isIn(uv.y, -cthick, cthick) ||\n    uv.x <= 0.0 && onCir);\n  float valB = float(isIn(uv.y, -cthick*0.5, cthick*0.5) &&\n    isIn(uv.x, -cMin + cthick*2., cMin));\n  float valC = float(isIn(uv.x, -cMin + cthick*2., cthick*.5) &&\n                    isIn(uv.y, -cMin, cthick*.5));\n  return valA+valB+valC;\n}\n\nfloat drawE(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  bool onCir = isIn(length(uv), cMin, cMax);\n  float valA = float(onCir && uv.x > 0.0 && !isIn(uv.y, -cthick, cthick) ||\n    uv.x <= 0.0 && onCir);\n  float valB = float(isIn(uv.y, -cthick*0.5, cthick*0.5) &&\n    isIn(uv.x, -cMin + cthick*0.5, cMin - cthick*0.5));\n  return valA+valB;\n}\n\nfloat drawA(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  bool onCir = isIn(length(uv), cMin, cMax);\n  float valA = float((onCir && uv.x > 0.0 && !isIn(uv.y, -cthick, cthick) ||\n    uv.x <= 0.0 && onCir) && uv.y > 0.0);\n  float valB = float(isIn(uv.y, -cthick*0.5, cthick*0.5) &&\n    isIn(uv.x, -cMin + cthick*0.5, cMin - cthick*0.5));\n  float valC = float(isIn(uv.x, -cMax, -cMin) && isIn(uv.y, -cMax, 0.0));\n  float valD = float(isIn(uv.x, cMin, cMax) && isIn(uv.y, -cMax, -cthick));\n  return valA+valB+valC+valD;\n}\n\nvec3 drawTxt(vec2 uv, vec2 pos)\n{\n  float scale =0.2;\n  float res;\n  float offX = -0.05;\n  float sp =.9;\n\n  uv.y += 0.175;\n  uv.y *= (sin(10.0*uv.x+iTime)+1.5)*0.5;\n\n  res += drawL(uv, pos+vec2(sp*-0.1+offX,0.0), scale);\n  res += drawO(uv, pos+vec2(sp*-0.07+offX,0.0), scale);\n  res += drawA(uv, pos+vec2(sp*-0.03+offX,0.0), scale);\n  res += drawD(uv, pos+vec2(offX,0.0), scale);\n  res += drawI(uv, pos+vec2(sp*0.022+offX,0.0), scale);\n  res += drawN(uv, pos+vec2(sp*0.045+offX,0.0), scale);\n  res += drawG(uv, pos+vec2(sp*0.08+offX,0.0), scale);\n  /*res += drawA(uv, pos+vec2(sp*0.15+offX,0.0), scale);\n  res += drawN(uv, pos+vec2(sp*0.195+offX,0.0), scale);\n  res += drawC(uv, pos+vec2(sp*0.235+offX,0.0), scale);\n  res += drawY(uv, pos+vec2(sp*0.275+offX,0.0), scale);*/\n\n  return vec3(max(1.-clamp(res,0.0,1.0), 0.4));\n}\n\nvec3 drawFlare(vec2 uv, float radius, vec3 rgb)\n{\n    float coef = 1.-sat(length(uv) / radius);\n    vec3 col = vec3(coef);\n    return col * rgb;\n}\n\n\n\nfloat drawGrid(vec2 uv, float sz, float thick)\n{\n    return float(mod((uv.x), sz) < thick) * float(mod((uv.y), sz) < thick);;\n}\n\nfloat drawRect(vec2 uv, float sz, float thick)\n{\n   \tfloat hth = thick * .5;\n    return float((isIn(abs(uv.x) - sz, -hth, hth) && isIn(abs(uv.y), 0., sz + hth)) ||\n                 (isIn(abs(uv.y) - sz, -hth, hth) && isIn(abs(uv.x), 0., sz + hth))\n                );\n}\n\nvec3 drawBubbles(vec2 uv)\n{\n    int bCnt = 27;\n    float fCnt = float(bCnt);\n    float speed = .2;\n    vec3 col = vec3(153., 255., 153.)/255.;\n    vec3 acc;\n\n    \n    for (int i = 0; i < bCnt; ++i)\n    {\n        float fi = float(i);\n        float yPos =mod(speed*iTime+fi*.1015, 2.)-0.5;\n        vec2 pos = vec2(mod(fi/fCnt, 0.12)*4.-0.3+yPos*0.2*sin(iTime*3.14), yPos);\n        \n        float d = distance(uv, pos);\n        if (isIn(d, 0.008, 0.01))\n            acc -= vec3(2.)*sat(uv.y+0.2);\n    }\n    return acc;\n}\n\nvec3 drawJauge(vec2 uv, float level)\n{\n    float waveLvl = 0.05;\n    float sz = 0.21;\n    level += waveLvl*sin(iTime+uv.x*10.) - waveLvl;\n    level = sat(level);\n    \n    bool inWidth = abs(uv.x) < sz;\n    bool inHeight = uv.y > -sz && uv.y < mix(-sz, sz+waveLvl, level) && uv.y < sz;\n    \n\tfloat coef = float(inWidth && inHeight);\n    \n    vec3 col;\n    \n    float cGrad = pow(max(uv.x+uv.y+0.5,0.),.5);\n    \n    float power = 2.2;\n    vec3 light = vec3(204, 255, 204)/255.0;\n    light.x = pow(light.x, power);\n    light.y = pow(light.x, power);\n    light.z = pow(light.x, power);\n    \n    col = mix(vec3(204, 51, 153)/255.0*0.6, light, cGrad) * (2.*uv.y+0.9);\n\n\t//col += mix(vec3(0, 0, 102)/255.0*0.6, light, cGrad);\n    //col += mix(-sz, sz+waveLvl, level) * vec3(255, 102, 255)/255.0 * sat(uv.y);\n    vec3 greenish =vec3(153, 244, 26)/255.;\n    vec3 bluish = vec3(26, 182, 244)/255.;\n    return col+bluish*coef+drawBubbles(uv)*coef;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx;\n    \n    //uv -= vec2(0.5);\n    uv -= vec2(0.5)*(iResolution.xy / iResolution.xx);\n\n    vec3 col;\n    vec3 colFlare = 0.4*drawFlare(uv, 0.5, vec3(0.423,0.13, 0.78));\n    colFlare += 0.4*drawFlare(uv, 0.9, vec3(0.623,0.13, 0.78));\n    \n    colFlare *= 0.0;\n    col += drawJauge(uv, sat(sin(iTime*0.2) *0.5 + 0.5));\n    \n    col += 0.5*vec3(0.523,0.53, 0.88)*drawRect(uv, 0.25,0.0015)*float(!isIn(uv.y, -0.1,0.1));\n    col += 0.2*vec3(0.823,0.43, 0.48)*drawRect(uv, 0.23,0.0013);\n    \n    col += drawGrid(uv, 0.05,0.0015)*vec3(153, 204, 255)/255.0*0.6*sat(1.-(length(uv)/1.));\nfloat offsetPump = +sin(5.*iTime+uv.x*10.)*0.01;\n    col += vec3(204, 51, 153)/255.0*0.6*float(isIn(uv.x, 0.25,1.5) && isIn(uv.y, -0.2+offsetPump,-0.15-offsetPump));\n    col *= drawTxt(uv, vec2(0.42,-0.));\n    col += colFlare;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttXSRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttXSzs", "name": "1233", "author": "Lily068", "description": "123", "tags": ["123"], "likes": 3, "viewed": 63, "date": "1563901613", "time_retrieved": "2024-06-20T19:40:48.092563", "image_code": "//============================================================================\n// PROJECT ID:\n//\n// GROUP NUMBER:\n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// COMMENTS TO GRADER: \n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at http://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 3;\nconst int NUM_PLANES = 2;\nconst int NUM_SPHERES = 13;\nconst int NUM_CONES = 5;\n\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n // Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0; \n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Cone_t {\n\t// Half angle\n\tfloat cosa;\n\t// Height\n\tfloat h;\n\t// Tip position\n\tvec3 c;\n\t// Axis\n\tvec3 v;\n\tint materialID;\n};\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of \n// Lecture 11 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS { \n//                   I_a * k_a + \n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nCone_t Cone[NUM_CONES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 2.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n\n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 4.5;\n    Plane[1].materialID = 0;\n\n    // HEAD\n    Sphere[0].center = vec3( 0.0, 0.5*abs(sin(2.0 * iTime)) + 2.0, 0.0 );\n    Sphere[0].radius = 0.3;\n    Sphere[0].materialID = 1;\n\n    //BODY\n    Cone[0].cosa=0.95;\n    Cone[0].h=1.0;\n    Cone[0].c=Sphere[0].center - vec3(0.0,Sphere[0].radius,0.0);\n    Cone[0].v=normalize(vec3(0.0,-1.0,0.0));\n    Cone[0].materialID=1;\n    \n    //ARM\n    Cone[1].cosa=0.995;\n    Cone[1].h=Cone[0].h*0.6;\n    Cone[1].c= Cone[0].c-vec3(0.0,0.2,0.0);\n    Cone[1].v=normalize(vec3(1.0,-0.1-abs(sin(2.0 * iTime)),0.0));\n    Cone[1].materialID=1;\n    \n    Cone[2].cosa= Cone[1].cosa;\n    Cone[2].h=Cone[1].h;\n    Cone[2].c=Cone[1].c;\n    Cone[2].v=normalize(vec3(-Cone[1].v.x,Cone[1].v.y,Cone[1].v.z));\n    Cone[2].materialID=Cone[1].materialID;\n    \n    //HAND\n    Sphere[1].center = vec3(Cone[1].h, Cone[0].c.y-0.28, 0.0 );\n    Sphere[1].center = vec3(Cone[1].c.x,Cone[1].c.y,Cone[1].c.z)+Cone[1].h*Cone[1].v;;\n    Sphere[1].radius = 0.07;\n    Sphere[1].materialID = 1;\n    \n    Sphere[2].center = vec3(-Sphere[1].center.x,Sphere[1].center.y,Sphere[1].center.z);\n    Sphere[2].radius = Sphere[1].radius;\n    Sphere[2].materialID = Sphere[1].materialID;\n    \n    //LEG\n    \n    Cone[3].cosa= 0.99;\n    Cone[3].h=Cone[0].h*0.7;\n    Cone[3].c=vec3(0.1,Cone[0].c.y-Cone[0].h,0.0);\n    Cone[3].v=normalize(vec3(0.0+abs(sin(2.0 * iTime)),-1.0,0.0));\n    Cone[3].materialID=Cone[1].materialID;\n    \n    Cone[4].cosa= Cone[3].cosa;\n    Cone[4].h=Cone[3].h;\n    Cone[4].c=vec3(-Cone[3].c.x,Cone[3].c.y,Cone[3].c.z);\n    Cone[4].v= vec3(-Cone[3].v.x,Cone[3].v.y,Cone[3].v.z);\n    Cone[4].materialID=Cone[1].materialID;\n    \n    //FOOT\n    Sphere[3].center = vec3(Cone[3].c.x,Cone[3].c.y,Cone[3].c.z)+Cone[3].h*Cone[3].v; \n    Sphere[3].radius = 0.1;\n    Sphere[3].materialID = 1;\n    \n    Sphere[4].center = vec3(-Sphere[3].center.x,Sphere[3].center.y,Sphere[3].center.z);\n    Sphere[4].radius = Sphere[3].radius;\n    Sphere[4].materialID = 1;\n    \n   \n \n   \n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Gold material.\n    Material[1].k_d = vec3( 0.8, 0.7, 0.1 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n    // Green plastic material.\n    Material[2].k_d = vec3( 0.0, 0.8, 0.0 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n\n    // Light 0.\n    Light[0].position = vec3( 4.0, 8.0, -3.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    // Light 1.\n    Light[1].position = vec3( -4.0, 8.0, 0.0 );\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    // A vector from ray origin  towards sphere center.\n    vec3 OriginToCenter = sph.center - ray.o;\n    // Compute the length of tangent.(square)\n    float SquareT = dot(OriginToCenter, OriginToCenter) - sph.radius * sph.radius;\n    float DdotV = dot(ray.d, OriginToCenter);\n\n    // One side which has the sphere.\n    if (DdotV >= 0.0) {\n        // When the ray shoots towards the sphere\n        float discr = DdotV * DdotV - SquareT;\n        // If it is bigger than the length of tangent, it has intersects.\n        if (discr >= 0.0) \n        {\n            // Smaller intersection point.\n            t = DdotV - sqrt(discr);\n            hitPos = ray.o + t * ray.d;\n            hitNormal = normalize(hitPos - sph.center);\n            return (t >= tmin && t<= tmax);\n        }\n    }\n    return false;\n\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    // A vector from ray origin  towards sphere center.\n    vec3 OriginToCenter = sph.center - ray.o;\n    // Compute the length of tangent.(square)\n    float SquareT = dot(OriginToCenter, OriginToCenter) - sph.radius * sph.radius;\n    float DdotV = dot(ray.d, OriginToCenter);\n\n    // One side which has the sphere.\n    if (DdotV >= 0.0) {\n        // When the ray shoots towards the sphere\n        float discr = DdotV * DdotV - SquareT;\n        // If it is bigger than the length of tangent, it has intersects.\n        if (discr >= 0.0) \n        {\n            // Need to compare both intersection points\n            float t1 = DdotV - sqrt(discr);\n            float t2 = DdotV + sqrt(discr);\n            return ((t1 >= tmin && t1<= tmax) || (t2 >= tmin && t2 <= tmax));\n        }\n    }\n    return false;\n\n}\n\n// Computes intersection between a cone and a ray.\nbool IntersectCone( in Cone_t cone, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 co = ray.o - cone.c;\n\n    float a = dot(ray.d, cone.v)*dot(ray.d, cone.v) - cone.cosa * cone.cosa;\n    float b = 2. * (dot(ray.d, cone.v) * dot(co, cone.v) - dot(ray.d, co) * cone.cosa * cone.cosa);\n    float c = dot(co, cone.v) * dot(co, cone.v) - dot(co, co) * cone.cosa * cone.cosa;\n\n    float det = b * b - 4. * a * c;\n    if (det < 0.) return false;\n\n    det = sqrt(det);\n    float t1 = (-b - det) / (2. * a);\n    float t2 = (-b + det) / (2. * a);\n\n    t = t1;\n    if (t < 0. || t2 > 0. && t2 < t) t = t2;\n    if (t < 0.) return false;\n\n    vec3 cp = ray.o + t * ray.d - cone.c;\n    float h = dot(cp, cone.v);\n    if (h < 0. || h > cone.h) return false;\n\n    hitPos = ray.o + t * ray.d;\n    hitNormal = normalize(cp * dot(cone.v, cp) / dot(cp, cp) - cone.v);\n\n    return (t >= tmin && t<= tmax);\n}\n\n// Computes intersection between a cone and a ray for shadow ray intersection.\nbool IntersectCone( in Cone_t cone, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 co = ray.o - cone.c;\n\n    float a = dot(ray.d, cone.v)*dot(ray.d, cone.v) - cone.cosa * cone.cosa;\n    float b = 2. * (dot(ray.d, cone.v) * dot(co, cone.v) - dot(ray.d, co) * cone.cosa * cone.cosa);\n    float c = dot(co, cone.v) * dot(co, cone.v) - dot(co, co) * cone.cosa * cone.cosa;\n\n    float det = b * b - 4. * a * c;\n    if (det < 0.) return false;\n\n    det = sqrt(det);\n    float t1 = (-b - det) / (2. * a);\n    float t2 = (-b + det) / (2. * a);\n\n    float t = t1;\n    if (t < 0. || t2 > 0. && t2 < t) t = t2;\n    if (t < 0.) return false;\n    vec3 cp = ray.o + t * ray.d - cone.c;\n    float h = dot(cp, cone.v);\n    if (h < 0. || h > cone.h) return false;\n\n    return (t >= tmin && t<= tmax);\n}\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a + \n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray, \n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg ) \n{\n    // Find whether and where the ray hits some object. \n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    for (int curSphere = 0; curSphere < NUM_SPHERES; curSphere++ ) \n    {\n        // Try intersecting input rays with all the spheres.\n        temp_hasHit = IntersectSphere(Sphere[curSphere], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n                      temp_t, temp_hitPos, temp_hitNormal);\n\n        // If intersect with spheres, compare and find the nearest.\n        if (temp_hasHit && temp_t < nearest_t) \n        {\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Sphere[curSphere].materialID;\n        }\n        \n    }\n\n    for (int curPlane = 0; curPlane < NUM_PLANES; curPlane++ ) \n    {\n        // Try intersecting input rays with all the planes..\n        \n        temp_hasHit = IntersectPlane(Plane[curPlane], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n                      temp_t, temp_hitPos, temp_hitNormal);\n\n        // If intersect with planes, compare with the nearest of the sphere and then find the nearest.\n        if (temp_hasHit && temp_t < nearest_t) \n        {\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Plane[curPlane].materialID;\n        }\n        \n    }\n    \n    for (int curCune = 0; curCune < NUM_CONES; curCune++ ) {\n    \t// Try intersect with cones\n    \t// Use nearest_t as input tmax to determine whether the intersection point\n    \t//with planes is the nearest\n    \ttemp_hasHit = IntersectCone(Cone[curCune], ray, DEFAULT_TMIN, nearest_t,\n                      temp_t, temp_hitPos, temp_hitNormal);\n\n    \t// If hit, then now the hit point is nearer than spheres if any\n    \tif (temp_hasHit && temp_t < nearest_t ) {\n    \t\thasHitSomething = true;\n    \t\tnearest_t = temp_t;\n    \t\tnearest_hitPos = temp_hitPos;\n    \t\tnearest_hitNormal = temp_hitNormal;\n    \t\tnearest_hitMatID = Cone[curCune].materialID;\n    \t}\n    \t\n    }\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point. \n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the \n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    // Compute lighting for each lights\n    Ray_t ShadowRay[NUM_LIGHTS];\n    bool inshadow[NUM_LIGHTS];\n    for (int curLight = 0; curLight < NUM_LIGHTS; curLight++ ) \n    {\n        // Make a shadow ray (from surface to light) for each light\n        ShadowRay[curLight].o = nearest_hitPos;\n        ShadowRay[curLight].d = normalize(Light[curLight].position - ShadowRay[curLight].o);\n\n        for (int curSphere = 0; curSphere < NUM_SPHERES; curSphere++ ) \n        {\n            // If already in shadow, inshadow[curLight] becomes inaccessible\n            if(!inshadow[curLight]) \n            {\n                // The point is in shadow if the shadow ray intersects with anything.\n                inshadow[curLight] = IntersectSphere(Sphere[curSphere], ShadowRay[curLight], DEFAULT_TMIN, \n                distance(nearest_hitPos, Light[curLight].position));\n            }\n        }\n        // If not, consider intersection with planes.\n        if (!inshadow[curLight]) \n        {\n            for(int curPlane = 0; curPlane < NUM_PLANES; curPlane++ ) \n            {\n                // If already in shadow, inshadow[curLight] becomes inaccessible.\n                if(!inshadow[curLight]) \n                {\n                    inshadow[curLight] = IntersectPlane(Plane[curPlane], ShadowRay[curLight], DEFAULT_TMIN, \n                    distance(nearest_hitPos, Light[curLight].position));\n                }\n            }\n        }\n        if (!inshadow[curLight]) \n        {\n            for(int curCone = 0; curCone < NUM_PLANES; curCone++ ) \n            {\n                // If already in shadow, inshadow[curLight] becomes inaccessible.\n                if(!inshadow[curLight]) \n                {\n                    inshadow[curLight] = IntersectCone(Cone[curCone], ShadowRay[curLight], DEFAULT_TMIN, \n                    distance(nearest_hitPos, Light[curLight].position));\n                }\n            }\n        }\n\n        // Call PhongLighting() to compute lighting for this light source.\n        I_local += PhongLighting( ShadowRay[curLight].d, nearest_hitNormal, - ray.d, inshadow[curLight], \n            Material[nearest_hitMatID], Light[curLight] );\n    }\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    vec3 cam_pos = vec3( 2.5, 1.0, 2.5 );\n    vec3 cam_lookat = vec3( 0.25, 1.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ ) \n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}\n", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttXSzs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttXXD2", "name": "旋转吧！Shader", "author": "bluedrop", "description": "把中心(speed)放大会很神奇,看入迷了😓", "tags": ["2d"], "likes": 4, "viewed": 242, "date": "1564324409", "time_retrieved": "2024-06-20T19:40:48.098654", "image_code": "vec2 rotate(vec2 p, float ang)\n{\n    vec2 r = vec2(cos(ang),sin(ang));\n    return p*mat2(r.x, -r.y, r.y, r.x);\n}\n\nfloat speed = 100.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ms = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord-.5 * iResolution.xy)/ms;\n\t\n    float len = length(uv);\n    float lig = asin(.001/len)*speed*iTime;\n    vec2 ring = rotate(uv,lig+ iTime)/len;\n    \n    vec3 col = lig * vec3(sin(iTime),cos(iTime),0.)/vec3(ring, 1.)/5.;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttXXD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttXXD8", "name": "Chladni Cymatics 9 symmetry salt", "author": "henry", "description": "cool 2d algorythm of 9 concentric waves added together same as wave tank, rendered in salt on reverberating square of metal. 9 concentric wave origins:\n@@@\n@@@\n@@@\nThe central concentric wave has fixed position,the other waves can be moved away", "tags": ["physics", "symmetry", "chladni", "cymatics", "stringtheory", "singularity", "universesynthesizer", "atomiccompression"], "likes": 7, "viewed": 885, "date": "1562687518", "time_retrieved": "2024-06-20T19:40:48.535092", "image_code": "\n\n// Noise pixel size\n#define SIZE 1.0\n// Lower - more flowing\n#define FLUENCY 0.85\nfloat rand(vec2 co) { \n    return fract(sin(dot(co.xy , vec2(12.9898, 78.233))) * 43758.5453);\n} \n\nvoid mainImage(out vec4 color, vec2 UVcoords)\n{\n    \n          vec2 id = ceil(UVcoords/SIZE);    \n    vec2 rid = vec2(rand(id), rand(id+iResolution.y));    \n    color = -vec4( 0.1/fract(rid.x + rid.y - iTime * FLUENCY)-0.1)*15.0;//sparke effect\n    \n   float d3 = iResolution.y*.5 ,//number to move pic upwards\n         d4 =  iResolution.x*.5 ,//number to move pic sideways\n         d2 = 8.0 - 2.0 * sin( 5.0+iTime*.07 ) + iMouse.y*0.021, //number to move 5 wave machines outwards\n    \td1 = .5; ;// wave width\n   UVcoords = .5*(UVcoords - vec2(d4,d3)); //move pic around\n    float zoom = 0.27;\n    \n\t//function to make color concentric sinewaves like water drop waves radiating from a pt:   \n#define S(X, Y,period)   color += sin(length(UVcoords + vec2(X,Y)*d2)*zoom)-.2;\n    \n         \n    \n    \n    //if (color.x<0.0)\n  \n    \n    \n    \n    // color += sin(UVcoords.x*100.0*iTime)/6.0;\n    //  color += sin(UVcoords.y*150.0*iTime)/6.0;  \n    // sin(length()*p2)+v2\n\t//see end for full formula including angular coordinates as well as concentric\n\t//Tip: to remix the code, you can try mixing 3/4/8 \n    //wave machines in different symmetries and vary their distance and amplitudes\n  \n\n   \n//make 5 wave machines where the color is added t*d2ogether on coordinates of pentagon:\n    \n    //these dots are arranged in a + arrangement, one origin for on xy axes. \n    //central wave machine on origin\n    S(0.0,0.0,iMouse.x*0.002)\n        \n    //4 other wave machines on axes\n    S(0,1.0*d2,d1)  S(0,-1.0*d2,d1)  S(-1.0*d2,-0.0,d1)  S(1.0*d2,0.0,d1)  \n        \n    S(2.0*d2,2.0*d2,d1)  S(-2.0*d2,-2.0*d2,d1)  S(2.0*d2,-2.0*d2,d1)  S(-2.0*d2,2.0*d2,d1)      \n}\n    \n\n//NOTE: original version had concentric wave forms in this fasion:\n\n//float2 xy2 = IN.uv_MainTex + float2(-0.5, -0.5*d3 ) + float2(k1,j1)*d2; \n//position of the point\n\n//float c2 = length(xy2);//polar coordinates (x axis becomes radial)\n\n//ht+=  (sin(c2 * p2)  *v2) ;//angular coordinates (y becomes angle)\n    \n    \n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttXXD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttXXDN", "name": "Omphalos", "author": "dr2", "description": "For ancient Greek navel-gazers", "tags": ["rock", "stone", "greek", "sacred", "delphi"], "likes": 14, "viewed": 433, "date": "1562920608", "time_retrieved": "2024-06-20T19:40:48.548889", "image_code": "// \"Omphalos\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, elAx;\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  d = PrEllipsDf (q, elAx + vec3 (0.05, 0., 0.05));\n  q = p;\n  q.xy = Rot2D (q.xy, pi / 5.);\n  d = SmoothMax (d, abs (mod (q.y + 0.1, 0.4) - 0.2) - 0.1, 0.02);\n  q = p;\n  q.xz = Rot2D (q.xz, 2.1 * pi / 3.);\n  q.xy = Rot2D (q.xy, 0.9 * pi / 5.);\n  d = SmoothMax (d, abs (mod (q.y + 0.1, 0.4) - 0.2) - 0.1, 0.02);\n  q = p;\n  q.xz = Rot2D (q.xz, -2.05 * pi / 3.);\n  q.xy = Rot2D (q.xy, 1.1 * pi / 5.);\n  d = SmoothMax (d, abs (mod (q.y + 0.1, 0.4) - 0.2) - 0.1, 0.02);\n  q = p;\n  d = SmoothMin (d, PrEllipsDf (q, elAx), 0.1);\n  d = max (d, - p.y);\n  DMIN (1);\n  q = p;\n  q.y -= -0.05;\n  d = PrBoxDf (q, vec3 (1.3, 0.05, 1.3));\n  DMIN (2);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0002, -0.0002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.01 * d, h));\n    d += 0.02;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, sh, f;\n  elAx = vec3 (1., 3., 1.);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      vn = VaryNf (16. * ro, vn, 4.);\n      f = Fbm3 (32. * ro);\n      col4 = mix (vec4 (0.4, 0.4, 0.45, 0.05), vec4 (0.6, 0.5, 0.5, 0.3) +\n         vec4 (1., 1., 0.5, 0.5) * step (0.8, f),\n         smoothstep (1.005, 1.01, length (ro / elAx))) * (1. - 0.3 * f);\n    } else if (idObj == 2) {\n      col4 = mix (vec4 (0.6, 0.7, 0.6, 0.2), vec4 (0.65, 0.6, 0.6, 0.2),\n         smoothstep (0.4, 0.6, Fbm2 (2. * ro.xz))) * (0.5 +\n         0.5 * smoothstep (1., 1.1, length (ro.xz))) * (0.5 + 0.5 * step (0.99, vn.y));\n    }\n    sh = ObjSShadow (ro, ltDir);\n    col = col4.rgb * (0.2 + 0.1 * max (- dot (vn, ltDir), 0.) +\n       0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 16.);\n  } else {\n    col = vec3 (0.05, 0.05, 0.08);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.03 * pi * tCur;\n    el -= 0.05 * pi * sin (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, 0.01 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 1.2, -13.);\n  zmFac = 6.;\n  dstFar = 40.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttXXDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttXXDX", "name": "simple smooth circle", "author": "gcj2450", "description": "draw a simple circle", "tags": ["circlelenght"], "likes": 2, "viewed": 610, "date": "1564473582", "time_retrieved": "2024-06-20T19:40:48.722862", "image_code": "//uv,circle pos , circle radius,circle edge feather\nfloat circle(vec2 uv,vec2 pos,float radius,float feather)\n{\n    vec2 uvDist=uv-pos;\n    return 1.0-smoothstep(radius-feather,radius+feather, length(uvDist));\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\tcol+=circle(uv,vec2(0.5,0.5),0.2,0.002);\n    \n    col*=vec3(sdCircle( uv-vec2(0.7,0.8), 0.1 ));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttXXDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttXXWN", "name": "Transparent objects", "author": "zxxuan1001", "description": "Another room with transparent objects, adding refraction without recursive tracing. \n\nThe previous room -> https://www.shadertoy.com/view/ttjGWt\n", "tags": ["reflection", "transparency", "refraction"], "likes": 8, "viewed": 481, "date": "1563550721", "time_retrieved": "2024-06-20T19:40:50.310792", "image_code": "#define PI 3.1415926\n#define EPSILON 0.001\n#define DEPTH 2\nconst int MAX_STEPS = 60;\nconst float MAX_DISTANCE = 80.0;\n\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n};\n    \nLight lightInfo = Light(vec3(3.0, 10.0, 0.0), vec3(10.0));\n\nstruct Material {\n    vec3 albedo;\n    float diffuse;\n    float specular;\n    float reflection;\n    float refraction;\n};\n    \nstruct Hit {\n    float dist;\n    int matIndex; //material info at the intersection point\n};\n\nfloat planeSDF(vec3 p) {\n    return p.y;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p, n.xyz) + n.w;\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nHit unionSDF(Hit d1, Hit d2) \n{\n    if (d1.dist < d2.dist) {\n        return d1;\n    } else {\n        return d2;\n    }  \n}\n\nvec3 doTranslate(vec3 p, vec3 offset) \n{\n    return p - offset;\n}\n\nvec3 rotX(vec3 p, float d) \n{\n    mat4 rotM= mat4(1.0, 0.0, 0.0, 0.0, \n                    0.0, cos(d), -sin(d), 0.0, \n                    0.0, sin(d), cos(d), 0.0, \n                    0.0, 0.0, 0.0, 1.0);\n    return vec3(rotM * vec4(p, 1.0));\n}\n\nHit sceneSDF(vec3 p) {\n    Hit rst;\n    vec3 p1 = doTranslate(p, vec3(6.0, 3.1, -3.0));\n    Hit is0 = Hit(sphereSDF(p1, 3.0), 2);\n    p1 = doTranslate(p, vec3(-2.0, 2.1, 8.0));\n    Hit is1 = Hit(sphereSDF(p1, 2.0 ), 2);\n    p1 = doTranslate(p, vec3(3.0, 1.5 + 10.0 * abs(sin(2.0*iTime)), 1.0));\n    Hit is2 = Hit(sphereSDF(p1, 1.5 ), 1);\n    \n   \t/*\n    Hit is3 = Hit(sdPlane(p, vec4(0.0, 1.0, 0.0, 0.0)), 0);\n    Hit is4 = Hit(sdPlane( p, vec4(0.0, 0.0, 1.0, 20.0)), 0);\n    Hit is5 = Hit(sdPlane( p, vec4(1.0, 0.0, 0.0, 20.0)), 0);\n    Hit is6 = Hit(sdPlane( p, vec4(-1.0, 0.0, 0.0, 20.0)), 0);\n    Hit is7 = Hit(sdPlane( p, vec4(0.0, 0.0, -1.0, 20.0)), 0);\n    Hit is8 = Hit(sdPlane( p, vec4(0.0, -1.0, 0.0, 30.0)), 0);\n    */\n    \n    Hit outerBox = Hit(sdBox(p-vec3(0.0,20.0,0.0), vec3(20.0,20.0,20.0)), 0); \n    outerBox.dist = -outerBox.dist;\n    \n    p1 = doTranslate(p, vec3(0.0, 3.5, -1.0));\n    Hit is9 = Hit(sdBox( p1, vec3(1.0, 3.0, 4.0)), 3);\n    \n    rst = unionSDF(is0, is1);\n    rst = unionSDF(rst, is2);\n    rst = unionSDF(rst, outerBox);\n    /*\n    rst = unionSDF(rst, is3);\n    rst = unionSDF(rst, is4);\n    rst = unionSDF(rst, is5);\n    rst = unionSDF(rst, is6);\n    rst = unionSDF(rst, is7);\n    rst = unionSDF(rst, is8);\n\t*/\n    rst = unionSDF(rst, is9);\n    return rst;\n}\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).dist - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).dist,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).dist - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).dist,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)).dist - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).dist\n    ));\n}\n\nHit marching(vec3 ro, vec3 rd, float signInd) \n{\n    float tmax = MAX_DISTANCE;\n    float t = EPSILON;\n    Hit result = Hit(-1.0, -1);\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * t;\n        Hit res = sceneSDF(p); \n        float dist = res.dist * signInd;\n        \n        if (dist < 0.0 )\n        {\n            return result;\n        }\n        else if (t > tmax)\n        {\n            result.matIndex = -1;\n            result.dist = tmax;\n            break;\n        }\n        \n        t += max(dist, EPSILON); //faster than abs()\n        result.dist = t;\n        result.matIndex = res.matIndex;\n    }\n    \n    return result;\n}\n\nvec3 background(vec2 p) \n{\n    return vec3(0.0);//mix(vec3(0.2, 0.5, 0.5), vec3(0.4, 0.3, 0.3), pow(0.8, (p.y + 0.5) * 0.1));\n}\n\nvec3 getColor(vec3 ro, vec3 p, vec3 nor, int matIdx, in Material mat) {\n\tvec3 col = vec3(0.0);\n    vec3 N = nor;\n    vec3 V = normalize(ro - p);\n    vec3 L = normalize(lightInfo.position - p);\n    vec3 R = reflect(-L, N);\n    float spec = pow(max(dot(V, R), 0.0), mat.specular);\n    \n    // floor\n    if (matIdx < 1 && N.y > 0.5) {\n    \tmat.albedo = mix(vec3(0.0), vec3(0.95), mod(floor(p.x * 0.3) + floor(p.z * 0.3), 2.0));\n    } \n    vec3 ambient = vec3(0.1) * mat.albedo;\n    col += ambient;\n    \n    col += float(matIdx) * spec * lightInfo.color; \n    \n    return col;\n}\n\nmat3 getCamera( in vec3 ro, in vec3 ta) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//hacks for non-constant index expression\nMaterial getMaterial(int index) {\n    Material mat[4];\n    mat[0] = Material(vec3(0.6, 0.75, 0.8), 0.5, 16.0, 0.8, 0.0); \n    mat[1] = Material(vec3(1.0, 0.5, 0.5), 0.1, 128.0, 0.4, 0.9); \n    mat[2] = Material(vec3(0.1,0.1,0.2), 0.1, 128.0, 0.4, 0.9); \n    mat[3] = Material(vec3(0.2, 0.6, 0.6), 0.1, 128.0, 0.4, 0.9); \n    if (index == 0) {\n        return mat[0];\n    } else if (index == 1) {\n        return mat[1];\n    } else if (index == 2) {\n        return mat[2];\n    } else if (index == 3) {\n        return mat[3];\n    }\n}\n\nvec3 reflectionRay(in vec3 ori, in vec3 dir, in vec3 backColor, in vec3 pixColor, inout vec3 att) {\n\tfor (int i = 0; i < DEPTH; i++) {\n        Hit icp = marching(ori, dir, 1.0);\n        vec3 interP = ori + icp.dist * dir; \n        vec3 nor = getNormal(interP);\n        Material mat = getMaterial(icp.matIndex);\n        if (icp.matIndex < 0) {\n            pixColor += vec3(0.0);//mix(pixColor, backColor, att);\n        } else {\n            vec3 localColor = getColor(ori, interP, nor, icp.matIndex, mat); \n            pixColor = mix(pixColor, localColor, att);\n            dir = reflect(dir, nor);\n            ori = interP + dir * EPSILON;\n            att *= mat.reflection;\n        }\n    }\n    return pixColor;\n}\nvec3 refractionRay(in vec3 ori, in vec3 dir, in vec3 backColor, in vec3 pixColor, in float refractionRatio, inout float signInd, inout vec3 att) {\n    for (int i = 0; i < 4; i++) {\n        Hit icp = marching(ori, dir, signInd);\n        vec3 interP = ori + icp.dist * dir; \n        vec3 nor = signInd * getNormal(interP);\n        Material mat = getMaterial(icp.matIndex);\n        if (icp.matIndex < 0) {\n            pixColor += vec3(0.0); //mix(pixColor, backColor, att);\n        } else {\n            if (signInd > 0.0) { \n                vec3 localColor = getColor(ori, interP, nor, icp.matIndex, mat); \n                pixColor = mix(pixColor, localColor, att);\n            }\n            \n            vec3 refractDir = refract(dir, nor, refractionRatio);\n            vec3 reflectDir = reflect(dir, nor);\n            \n            if (dot(refractDir, refractDir) < EPSILON ) {\n                //total internal reflection\n                dir = reflectDir;\n                ori = interP + dir * EPSILON;\n                att *= mat.reflection;\n            } else {\n                //flip normal direction and refractionRatio for the next ray\n                dir = refractDir;\n                ori = interP + dir * EPSILON;\n                signInd = -signInd;\n                refractionRatio = 1.0/ refractionRatio;\n                att *= mat.refraction; \n            } \n        }\n    }\n    return pixColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5; \n    uv.x *= iResolution.x/iResolution.y;  \n   \n    vec3 col = vec3(0.0);\n    vec2 mouse = vec2(0.01) + iMouse.xy  / iResolution.xy ;\n    mouse.x -= 0.5;\n    float rot = mouse.x + iTime*0.05;\n    vec3 ro = vec3(-20.0 * cos(rot * 2.0 * PI), 2.0+8.0 * mouse.y, -20.0 * sin(rot * 2.0 * PI));\n    vec3 ta = vec3(0.0, 2.0, -2.0);\n    mat3 cam = getCamera(ro, ta);\n    vec3 rd = normalize(cam * vec3(uv, 1.0));\n    \n    vec3 nor = vec3(0.0);  \n    vec3 ori = ro;\n    vec3 dir = rd;\n    vec3 interP = vec3(0.0);\n    float signInd = 1.0;\n    vec3 reflectDir = vec3(0.0);\n    vec3 refractDir = vec3(0.0);\n    float refractionRatio = 1.0/1.4;\n    vec3 localColor = vec3(0.0);\n    vec3 f0 = vec3(0.03);\n    vec3 refractAtt = vec3(1.0);\n    vec3 reflectAtt = vec3(1.0);\n    vec3 refractCol = vec3(0.0);\n    vec3 reflectCol = vec3(0.0);\n    \n    //initial ray\n    Hit icp = marching(ori, dir, 1.0); //reserved for future use\n    Hit initRay = icp;\n    interP = ori + icp.dist * dir; \n    nor = signInd * getNormal(interP);\n    Material mat = getMaterial(icp.matIndex);\n    vec3 backColor = background((ori + MAX_DISTANCE * dir).xy);\n    if (icp.matIndex < 0) {\n        col += vec3(0.0);\n    } else {\n        col += getColor(ori, interP, nor, icp.matIndex, mat);\n    }\n    \n    refractDir = refract(dir, nor, refractionRatio);\n    reflectDir = reflect(dir, nor);\n    \n    //reflection ray\n    dir = reflectDir;\n    ori = interP + dir * EPSILON;\n    reflectAtt *= mat.reflection;\n    reflectCol = reflectionRay(ori, dir, backColor, col, reflectAtt);\n    \n    //refraction ray\n    if (dot(refractDir, refractDir) < EPSILON ) {\n        //total internal reflection\n        dir = reflectDir;\n        ori = interP + dir * EPSILON;\n    } else {\n        //flip normal direction and refractionRatio for the next ray\n        dir = refractDir;\n        ori = interP + dir * EPSILON;\n        signInd = -signInd;\n        refractionRatio = 1.0/refractionRatio;\n    }\n    refractAtt *= mat.refraction;\n    refractCol = refractionRay(ori, dir, backColor, col, refractionRatio, signInd,refractAtt);\n    \n    col = reflectCol + refractCol;\n    \n\tcol = pow(col, vec3(1.0/2.2)); \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttXXWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttXXzB", "name": " Submarine Binoculars", "author": "96logda", "description": "Converted one of my older version of my water shader with a \"submarine binoculars\" from glslsandbox to shadertoy.", "tags": ["circles", "grid", "sea", "lines", "water", "vignette", "rain", "submarinebinoculars", "binoculars"], "likes": 4, "viewed": 217, "date": "1563368186", "time_retrieved": "2024-06-20T19:40:54.038611", "image_code": "//Copyright (c) 2019-06-23 - 2019-07-17 by Angelo Logahd\n//Portfolio: https://angelologahd.wixsite.com/portfolio\n\n//Copyright (c) 2019-06-23 - 2019-07-04 by Angelo Logahd\n//My orginal version:\n//http://glslsandbox.com/e#55788.7\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst float PI\t \t\t\t\t\t\t= 3.1415;\nfloat EPSILON_NRM\t\t\t\t\t\t= 0.001;\n\nconst vec3 up \t\t\t\t\t\t\t= vec3(0.0, 1.0, 0.0);\n\n#define true  \t\t\t\t\t\t\t1\n#define false \t\t\t\t\t\t\t0\n\n#define saturate(x)\t\t\t\t\t\tclamp(x, 0.0, 1.0)\n#define mul3x(x) \t\t\t\t\t\tx * x * x\n#define dot2(x)\t\t\t\t\t\t\tdot(x, x)\n\n#define SIMULATE \t\t\t\t\t\t0\n#define SIMULATE2x\t\t\t\t\t\t1\n#define SIMULATE3x\t\t\t\t\t\t2\n#define SIMULATE4x\t\t\t\t\t\t3\n#define SIMULATE5x\t\t\t\t\t\t4\n#define PAUSED\t\t\t\t\t\t\t5\n#define SLOW_MOTION\t\t\t\t\t\t6\n\n#define WAVES_WATER\t\t\t\t\t\t0\n#define CALM_WATER\t\t\t\t\t\t1\n\n#define SIMULATE_MODE\t\t\t\t\tSIMULATE\n#define WATER_TYPE\t\t\t\t\t\tCALM_WATER\n#define RAINBOW_WATER\t\t\t\t\tfalse\n#define FANTASY_WATER_PATH\t\t\t\tfalse\n#define FLIP_WATER_AND_SKY\t\t\t\tfalse\n#define DAY_AND_NIGHT\t\t\t\t\tfalse\n#define SUN_LIGHT\t\t\t\t\t\ttrue\n\n//...........................................................\n//\t\t\tWeathers\n//...........................................................\n#define\tRAIN\t\t\t\t\t\t\ttrue\n#define RAINBOW\t\t\t\t\t\t\tfalse\n#define STAR_SKY\t\t\t\t\t\tfalse\n\n#if RAINBOW\n#define RAINBOW_START_Y\t\t\t\t\t0.0\n\nconst float RAINBOW_BRIGHTNESS  \t\t= 1.0;\nconst float RAINBOW_INTENSITY   \t\t= 0.30;\nconst vec3  RAINBOW_COLOR_RANGE \t\t= vec3(50.0, 53.0, 56.0);  // Note: The color range are described in degrees.\nvec3 RAINBOW_POS\t\t\t\t\t\t= vec3(4.5, 0.0, 0.5);\nvec3 RAINBOW_DIR \t\t\t\t\t\t= vec3(-0.2, -0.1, 0.0);\n\t\nvec3 rainbow_pos;\nvec3 rainbow_camera_dir;\nvec3 rainbow_up; \nvec3 rainbow_vertical;\nvec3 rainbow_w;\n#endif\n\n#if STAR_SKY\nconst float STAR_THRESHOLD\t\t\t\t= 0.98;\n#endif\n//...........................................................\n\n//...........................................................\n//\t\t\tPost Processing\n//...........................................................\n#define APPLY_LUMINANCE\t\t\t\t\ttrue\n#define APPLY_TONEMAP\t\t\t\t\ttrue\n#define APPLY_GAMMA_CORRECTION\t\t\ttrue\n\nconst float INTENSITY\t\t\t\t\t= 1.2;\nconst float CONTRAST\t\t\t\t\t= 1.0;\n\n#if APPLY_TONEMAP\n\n#define LINEAR_TONEMAP\t\t\t\t\t0\n#define EXPONENTIAL_TONEMAP\t\t\t\t1\n#define REINHARD_TONEMAP\t\t\t\t2\n#define FILMIC_TONEMAP\t\t\t\t\t3\n\n#define TONEMAP_TYPE\t\t\t\t\tFILMIC_TONEMAP\t\t\n \n#if TONEMAP_TYPE == LINEAR_TONEMAP\nconst float TONEMAP_EXPOSURE\t\t\t= 0.5;\n#endif\n#if TONEMAP_TYPE == EXPONENTIAL_TONEMAP\nconst float TONEMAP_EXPOSURE\t\t\t= 0.5;\n#endif\n#if TONEMAP_TYPE == REINHARD_TONEMAP\nconst float TONEMAP_EXPOSURE\t\t\t= 0.5;\n#endif\n#if TONEMAP_TYPE == FILMIC_TONEMAP\n//https://www.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting\n//http://filmicworlds.com/blog/filmic-tonemapping-operators/\n\n//Uncharted2Tonemap:\n//Orginal Values:\n//A = 0.22\n//B = 0.30\n//C = 0.10\n//D = 0.20\n//E = 0.02\n//F = 0.30\n//W = 11.2\n\nfloat A = 0.15;\nfloat B = 0.50;\nfloat C = 0.10;\nfloat D = 0.20;\nfloat E = 0.02;\nfloat F = 0.30;\nfloat W = 11.2;\n\nconst float TONEMAP_EXPOSURE\t\t\t= 1.5;\nconst float TONEMAP_EXPOSURE_BIAS \t\t= 2.0;\n#endif\n\n#endif\n\n//...........................................................\n//\t\t\tFilters\n//...........................................................\n#define VIGNETTE_FILTER\t\t\t\t\ttrue\n#define SEPIA_FILTER\t\t\t\t\tfalse\n\n#if VIGNETTE_FILTER\nconst vec3  VIGNETTE_COLOR \t\t\t\t= vec3(1.0, 1.3, 0.4);\nconst float VIGNETTE_ZOOM  \t\t\t\t= 1.0; //2.5 -> full image \nconst float VIGNETTE_EXPOSURE \t\t\t= 0.1;\n#endif\n\n#if SEPIA_FILTER\nconst vec3  SEPIA_COLOR \t\t\t\t= vec3(1.9, 0.8, 0.6);\nconst float SEPIA_INTENSITY \t\t\t= 0.2;\n#endif\n//...........................................................\t\n\n#if APPLY_GAMMA_CORRECTION\nconst float GAMMA\t\t\t\t\t\t= 2.2;\n#endif\n//...........................................................\n\n//Day and night properties\n#if DAY_AND_NIGHT\n#define DAY_AND_NIGHT_TIME\t\t\t\t0.1\n#define DAY_AND_NIGHT_MIN_BRIGHTNESS\t0.2\n#define DAY_AND_NIGHT_MAX_BRIGHTNESS\t1.0\n#endif\n\n//Sun light properties\n#if SUN_LIGHT\nvec3  SEA_SUN_DIRECTION\t\t        \t= vec3(0.0, -1.0, -0.5);\nvec3  SEA_SUN_COLOR     \t\t\t\t= vec3(1.0, 1.0, 1.0);\nfloat SEA_SUN_DIFFUSE  \t\t\t\t\t= 0.65; \nvec3  SEA_SUN_SPECULAR      \t\t\t= vec3(0.65);\n#endif\n\n//Geometry / Fragment properties\nconst int SEA_GEOMETRY_ITERATIONS   \t= 8;\nconst int SEA_FRAGMENT_ITERATIONS   \t= 10;\n\n// sea base properties\nconst vec3  SEA_BASE_COLOR \t\t\t\t= vec3(0.15, 0.19, 0.25);\nconst vec3  SEA_WATER_COLOR \t\t\t= vec3(0.1, 0.1, 0.15);\nconst vec3  SEA_ORI\t\t\t\t\t\t= vec3(0.0, 3.5, 0.0);\t\t\nconst float SEA_HEIGHT    \t\t\t\t= 1.0;\nconst float SEA_SPEED     \t\t\t\t= 3.0;\nconst float SEA_FREQ      \t\t\t\t= 0.1;\nconst float SEA_GEOMETRY_FREQ_MUL\t\t= 1.9;\nconst float SEA_GEOMETRY_AMPLITUDE_MUL \t= 0.22;\nconst float SEA_FREQ_MUL  \t\t\t\t= 2.0;\nconst float SEA_AMPLITUDE_MUL \t\t\t= 0.22;\nconst float SEA_REFRACTION_MUL_VALUE\t= 0.12;\nconst float SEA_ATTENUATION             = 0.001;\nconst float SEA_ATTENUATION_MUL_FACTOR  = 0.18;\nconst float SEA_CHOPPY    \t\t\t\t= 5.9;\nconst float SEA_CHOPPY_MIX_VALUE\t\t= 1.0;\nconst float SEA_CHOPPY_MIX_FACTOR\t\t= 0.4;\n\n// sea heightmap\nconst int HEIGHTMAP_NUM_STEPS     \t\t= 20;\n\n// sea direction\nconst float SEA_DIR_Z_SCALE \t\t\t= 0.02;\n\n//.................................................\n// \t\tPBR properties\n//.................................................\n#define FRESNEL_DEFAULT_FORMULA\t\t\t0\n#define FRESNEL_SCHLICK_FORMULA\t\t\t1\n\n#define FRESNEL_FORMULA\t\t\t\t\tFRESNEL_DEFAULT_FORMULA\n\nconst float SEA_SPECULAR_FACTOR\t\t\t= 60.0;\nconst float FRESNEL_POW_FACTOR\t\t\t= 3.0;\nconst float DIFFUSE_POW_FACTOR\t\t\t= 80.0;\n\n//.................................................\n//\t\t\tMaterials\n//.................................................\n\nstruct Material\n{\n    float fR0;\n    float fSmoothFactor;\n};\n\n//.................................................\n//\t\t       Sea Material\n#if FRESNEL_FORMULA == FRESNEL_SCHLICK_FORMULA\nconst float SEA_R0\t\t \t\t\t= 0.01;\nconst float SEA_SMOOTH_FACTOR \t\t= 0.1;\n#elif FRESNEL_FORMULA == FRESNEL_DEFAULT_FORMULA\nconst float SEA_SMOOTH_FACTOR \t\t= 0.65;\n#endif\n//.................................................\n\n//.................................................\n\n//.................................................\n\nconst float SEA_PAUSED_SPEED\t\t\t= 0.0;\nconst float SEA_SLOWMOTION_SPEED        = 0.5;\n\n#if RAINBOW_WATER\nconst float RAINBOW_WATER_SATURATION\t= 0.35;\nconst float RAINBOW_WATER_LIGHTNESS\t\t= 0.1;\nconst float RAINBOW_WATER_SPEED \t\t= 0.1;\n#endif\n\n#if FANTASY_WATER_PATH\nconst float UV_START_X\t\t\t\t\t= -5.0;\nconst float UV_END_X\t\t\t\t\t=  5.0;\n#endif\n\nmat2 octave_matrix \t\t\t\t\t\t= mat2(1.6, 1.2, -1.2, 1.6);\n\nfloat SEA_CURRENT_TIME\t\t\t\t\t= 0.0;\n\n//Color mixing\nconst float SMOOTH_MIX_Y\t\t\t\t= -0.5; \nconst float MIX_SEA_AND_SKY_FACTOR\t\t= 0.11;\nconst vec3  COLOR_GRADING\t\t\t\t= vec3(0.0, 0.0, 0.0);\n\n//..................................................................\n//\t\t\t\tFog\n//..................................................................\n#define ALWAYS_FOG\t\t\t\t\t\t0\n#define NEVER_FOG\t\t\t\t\t\t1\n//#define CAN_BE_FOGGY\n\n#define FOG_MODE\t\t\t\t\t\tNEVER_FOG\nconst vec3  FOG_COLOR  \t\t\t\t\t= vec3(0.15, 0.15, 0.15);\nconst float FOG_START \t\t\t\t\t= 0.04;\nconst float FOG_END \t\t\t\t\t= 500.0;\nconst float FOG_DENSITY \t\t\t\t= 0.2;\n//..................................................................\n\n\nvec3 hsv(float hue, float saturation, float value)\n{\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(hue) + t.xyz) * 6.0 - vec3(t.w));\n    return value * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), saturation);\n}\n\nfloat rand(float n)\n{\n    return fract(sin(n) * 43758.5453123);\n}\n\nfloat hash(vec2 p)\n{\t\n    return rand(dot(p, vec2(12.9898, 78.233)));\n}\n\nvec2 _smoothstep(in vec2 p)\n{\n    vec2 f = fract(p);\n    return f * f * (3.0 - 2.0 * f);\n}\n\nvec3 _smoothstep(in vec3 p)\n{\n     return p * p * 3.0 - 2.0 * mul3x(p);\n}\n\nfloat noise(in vec2 p) \n{\n    vec2 i = floor(p);\t\n    vec2 sp = _smoothstep(p);\n    return -1.0 + 2.0 * mix(mix(hash(i + vec2(0.0, 0.0)), \n                                hash(i + vec2(1.0, 0.0)), sp.x),\n                            mix(hash(i + vec2(0.0, 1.0)), \n                                hash(i + vec2(1.0, 1.0)), sp.x), sp.y);\n}\n\nfloat GetFragLuminance(vec3 fragColor)\n{\n    return dot(fragColor, vec3(0.3, 0.59, 0.11));\n}\n\nfloat d2y(float d)\n{\n    return 1.0 / (0.01 + d);\n}\n\t\nfloat circle(vec2 p, float r, float zoom)\n{\n    float d = distance(r, 0.45 * zoom);\n    return d2y(1000.0 * d);\n}\n\nbool line(vec2 uv, vec2 from, vec2 to)\n{\n    return uv.x >= from.x && uv.x <= to.x && \n\t   uv.y >= from.y && uv.y <= to.y;\n}\n\nfloat grid(vec2 p, float y, const float e)\n{\n    float a = 0.5;\n    float res = 14.98;\n    vec2 f = fract(p * res);\n    f = step(e, f);\t\n    return a * y * f.x * f.y;\n}\n\nvec3 sky(vec3 p) \n{\n    p.y = max(p.y, 0.0);\n    vec3 ret;\n    ret.x = pow(1.0 - p.y, 3.3) * 0.8;\n    ret.y = 1.0 - p.y;\n    ret.z = 1.8;\n    return ret;\n}\n\nfloat sea_octave(vec2 uv, float choppy) \n{\t\n    #if WATER_TYPE == WAVES_WATER \n    uv += noise(uv);\n    vec2 wv = 1.0 - abs(sin(uv));   \n    wv = mix(wv, abs(cos(uv)), wv);\n    return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);\n    #elif WATER_TYPE == CALM_WATER\n    //Author: Angelo Logahd \n    //2019-06-29\n    float noise = noise(uv);\n    float x = cos(noise);\n    float y = sin(noise);\n    return pow(pow(abs(x * y), 0.65), choppy);\n    #endif\n}\n\nfloat sea_geometry_map(vec3 p) \n{\n    #if WATER_TYPE == WAVES_WATER\n    vec2 uv = p.xz * vec2(0.85, 1.0);\n\t\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    \n    float d = 0.0;\n    float h = 0.0;    \n    for (int i = 0; i < SEA_GEOMETRY_ITERATIONS; ++i) \n    {   \n\t\t#if FANTASY_WATER_PATH\n\t   \tif (uv.x > UV_START_X && uv.x < UV_END_X)\n\t   \t{\n\t\t\tcontinue;\n\t   \t}\n\t\t#endif\n\n    \td =  sea_octave((uv + SEA_CURRENT_TIME) * freq, choppy);\n    \td += sea_octave((uv - SEA_CURRENT_TIME) * freq, choppy);\n        h += d * amp; \n\t    \n\t\tfreq *= SEA_GEOMETRY_FREQ_MUL; \n\t\tamp  *= SEA_GEOMETRY_AMPLITUDE_MUL;\n\t    \n        choppy = mix(choppy, SEA_CHOPPY_MIX_VALUE, SEA_CHOPPY_MIX_FACTOR);\n\t    \n\t\tuv *= octave_matrix; \n    }\n    return p.y - h;\n    #else\n    return p.y;\n    #endif\n}\n\nfloat sea_fragment_map(vec3 p) \n{\n    vec2 uv = p.xz * vec2(0.85, 1.0); \n    \n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;  \n    float choppy = SEA_CHOPPY;\n\t\n    float d = 0.0;\n    float h = 0.0;    \n    for(int i = 0; i < SEA_FRAGMENT_ITERATIONS; ++i) \n    {\t    \n    \td =  sea_octave((uv + SEA_CURRENT_TIME) * freq, choppy);\n\t\td += sea_octave((uv - SEA_CURRENT_TIME) * freq, choppy); \n\t\th += d * amp;\n\t\n\t\tfreq *= SEA_FREQ_MUL; \n\t\tamp  *= SEA_AMPLITUDE_MUL;\n\t\n\t\tchoppy = mix(choppy, SEA_CHOPPY_MIX_VALUE, SEA_CHOPPY_MIX_FACTOR);\n\t\n\t\tuv *= octave_matrix;\n    }\n    return p.y - h;\n}\n\nvec3 diffuse(vec3 normal, vec3 light, float powFactor) \n{\n    float diffuse = pow(dot(normal, light) * 0.4 + 0.6, powFactor);\n    return vec3(diffuse);\n}\n\nvec3 normal(vec3 p, vec3 dist) \n{\n    float eps = dot2(dist) * EPSILON_NRM;\n    vec3 n;\n    n.y = sea_fragment_map(p); \n    n = vec3(sea_fragment_map(vec3(p.x + eps, p.y, p.z)) - n.y,\n\t     \t sea_fragment_map(vec3(p.x, p.y, p.z + eps)) - n.y,\n\t     \t eps);\n    return normalize(n);\n}\n\nvec3 specular(vec3 eye, vec3 normal, vec3 light) \n{    \n    float nrm = (SEA_SPECULAR_FACTOR + 8.0) / (PI * 8.0);\n    float specular = pow(max(dot(reflect(eye, normal), light), 0.0), SEA_SPECULAR_FACTOR) * nrm;\n    return vec3(specular);\n}\n\nfloat Schlick(const in vec3 vHalf, const in vec3 eye, const in Material mat)\n{\n    float fDot = dot(vHalf, -eye);\n    fDot = clamp((1.0 - fDot), 0.0, 1.0);\n    float fDotPow = pow(fDot, FRESNEL_POW_FACTOR);\n    return mat.fR0 + (1.0 - mat.fR0) * fDotPow * mat.fSmoothFactor;\n}\n\nfloat fresnel(const in vec3 normal, const in vec3 eye, const in vec3 diffuse, const in vec3 specular, const in Material mat)\n{\n    vec3 vReflect = reflect(eye, normal);\n    vec3 vHalf = normalize(vReflect + -eye);\n    float fFresnel = Schlick(vHalf, eye, mat);\n    return mix(diffuse, specular, fFresnel).x;\n}\n\nfloat fresnel(const in vec3 normal, const in vec3 eye, const in Material mat) \n{  \n    float fresnel = 1.0 - max(dot(normal, -eye), 0.0);\n    fresnel = pow(fresnel, FRESNEL_POW_FACTOR) * mat.fSmoothFactor;\n    return fresnel;\n}\n\nvec3 sea(const in vec3 p, const in vec3 lightDir, const in vec3 eye, Material mat) \n{\n    vec3 dist = p - SEA_ORI;  \n    vec3 normal = normal(p, dist);\n    vec3 diffuse = diffuse(normal, lightDir, DIFFUSE_POW_FACTOR);\n    vec3 specular = specular(normal, lightDir, -eye);\n\t\n    #if FRESNEL_FORMULA == FRESNEL_DEFAULT_FORMULA\n    float fresnel = fresnel(normal, eye, mat);\n    #elif FRESNEL_FORMULA == FRESNEL_SCHLICK_FORMULA\n    float fresnel = fresnel(normal, eye, diffuse, specular, mat);\n    #endif\n    \n    vec3 reflected = sky(reflect(eye, normal));    \n    vec3 refracted = SEA_BASE_COLOR + diffuse * SEA_WATER_COLOR * SEA_REFRACTION_MUL_VALUE; // * -fresnel; \n    \n    vec3 color = mix(refracted, reflected, fresnel);\n    \n    float atten = max(0.0, 1.0 - dot2(dist) * SEA_ATTENUATION) * SEA_ATTENUATION_MUL_FACTOR;\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * atten;\n    \n    color += specular;\n    \n    #if SUN_LIGHT\n    vec3 sunDiffuseColor = max(dot(SEA_SUN_DIRECTION, normal), 0.0) * SEA_SUN_COLOR * SEA_SUN_DIFFUSE;\n    vec3 reflection = normalize(reflect(-SEA_SUN_DIRECTION, normal));\n    float direction = max(0.0, dot(eye, reflection));\n    vec3 sunSpecular = direction * SEA_SUN_COLOR * SEA_SUN_SPECULAR;\n    color = color + sunDiffuseColor + sunSpecular;\n    #endif\n    \n    #if RAINBOW_WATER\n    color += hsv((p.z * 0.3) - time * RAINBOW_WATER_SPEED, RAINBOW_WATER_SATURATION, RAINBOW_WATER_LIGHTNESS);\n    #endif\n    \n    return color;\n}\n\nvec3 seaHeightMap(vec3 dir) \n{\n    vec3 p = vec3(0.0);\n    float x = 1000.0;\n\t\n    if (sea_geometry_map(SEA_ORI + dir * x) > 0.0)\n    {\n\t\treturn p;\n    }\n    \n    float mid = 0.0;\n    float m = 0.0;\n    float heightMiddle = 0.0;\n    for(int i = 0; i < HEIGHTMAP_NUM_STEPS; ++i) \n    {\n\t\tmid = mix(m, x, 0.5); \n        p = SEA_ORI + dir * mid;                   \n    \theightMiddle = sea_geometry_map(p);\n\t\tif (heightMiddle < 0.0) \n\t\t{\n            x = mid;\n        } \n\t\telse \n\t\t{\n            m = mid;\n        }\n    }\n\t\n    return p;\n}\n\nvec3 fog(vec3 sceneColor, float dist)\n{\n    vec3 fragRGB = sceneColor;\n    const float FogEnd   = FOG_END;\n    const float FogStart = FOG_START;\n    float distanceF = (FogEnd - dist) / (FogEnd - FogStart);\n    float fogAmount = saturate(1.0 - exp(-distanceF * FOG_DENSITY));\n    return mix(fragRGB, FOG_COLOR, fogAmount);\n}\n\nfloat rainHash(float p)\n{\n    vec2 p2 = fract(vec2(p) * vec2(0.16632, 0.17369));\n    p2 += dot(p2.xy, p2.yx + 19.19);\n    return fract(p2.x * p2.y);\n}\n\nfloat rainNoise(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = _smoothstep(x);\n    float n = p.x + p.y * 57.0;\n    return mix(mix(rainHash(n +  0.0), rainHash(n +  1.0), f.x),\n               mix(rainHash(n + 57.0), rainHash(n + 58.0), f.x), f.y);\n}\n\nfloat rain(vec2 uv, vec2 xy)\n{\t\n    float travelTime = (iTime * 0.7) + 0.1;\n\t\n    float x1 = (0.5 + xy.x + 1.0) * 0.3;\n    float y1 = 0.01;\n    float x2 = travelTime * 0.5 + xy.x * 0.2;\n    float y2 = travelTime * 0.2;\n\t\n    vec2 st = uv * vec2(x1, y1) + vec2(x2, y2);\n    \n    float rain = 0.1;\n    float f = rainNoise(st * 200.5) * rainNoise(st * 125.5);  \n    f = clamp(pow(abs(f), 20.0) * 1.5 * (rain * rain * 125.0), 0.0, 0.1);\n    return f;\n}\n\n#if RAINBOW\nvec3 rainbowColor(in vec3 ray_dir) \n{ \n    RAINBOW_DIR = normalize(RAINBOW_DIR);   \n\t\t\n    float theta = degrees(acos(dot(RAINBOW_DIR, ray_dir)));\n    vec3 nd = clamp(1.0 - abs((RAINBOW_COLOR_RANGE - theta) * 0.2), 0.0, 1.0);\n    vec3 color = smoothstep(nd) * RAINBOW_INTENSITY;\n    \n    return color * max((RAINBOW_BRIGHTNESS - 0.75) * 1.5, 0.0);\n}\n\nvoid rainbowSetup()\n{\n    rainbow_pos =  RAINBOW_POS;\n    rainbow_w   = -normalize(-rainbow_pos);\n    rainbow_up  =  normalize(cross(rainbow_w, up));\n    rainbow_vertical = normalize(cross(rainbow_up, rainbow_w));\n}\n\nvec3 rainbow()\n{\n     vec2 uv = gl_FragCoord.xy / resolution.xy;\n     vec2 p = (-1.0 + 2.0 * uv) * vec2(resolution.x / resolution.y, 1.0);\n\n     vec3 color = vec3(0.0);\n     if (p.y >= RAINBOW_START_Y)\n     {\n         vec2 uv = gl_FragCoord.xy / resolution.xy;\n\t\n    \t rainbowSetup();\n\n     \t vec3 dir = normalize(vec3(p, 0.0) - vec3(0.0, 0.0, -1.5));\n     \t vec3 wdDir = normalize(dir.x * rainbow_up + dir.y * rainbow_vertical - dir.z * rainbow_w);\n\t     \n         color += rainbowColor(wdDir);\n     }\t\n     return clamp(color, 0.0, 1.0);  \n}\n#endif\n\n//.......................................................................................\n//\t\t\t\t\tNight weathers\n//.......................................................................................\n#if STAR_SKY\nfloat starHash(float n) \n{\n    return fract((1.0 + cos(n)) * 15.92653) * 1.8;\n}\n\nvec3 star(in vec2 uv) \n{\n    vec2 p = uv * 0.02; //To avoid flickering\n    if (p.y > 0.001)\n    {\n\t\tfloat starValue = fract(starHash(p.x * 37.0) + starHash(p.y * 80.0));\n\t\tif (starValue > STAR_THRESHOLD) \n\t\t{\n\t    \tvec3 starColor = vec3(pow((starValue - STAR_THRESHOLD) / 0.02, 25.0));\n\t    \treturn starColor * 0.3; // * (1.0 - brightness);\n\t\t}  \n    }\n    return vec3(0.0);\n}\n#endif\n//.......................................................................................\n\n#if TONEMAP_TYPE == FILMIC_TONEMAP\nvec3 Uncharted2Tonemap(vec3 x)\n{\n   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n#endif\n\nvec3 Tonemap(vec3 color)\n{\n    #if TONEMAP_TYPE == LINEAR_TONEMAP\n    color *= vec3(TONEMAP_EXPOSURE);\n    #endif\n    #if TONEMAP_TYPE == EXPONENTIAL_TONEMAP\n    color = 1.0 - exp2(-color * TONEMAP_EXPOSURE);\n    #endif\n    #if TONEMAP_TYPE == REINHARD_TONEMAP\n    color *= TONEMAP_EXPOSURE;\n    color = color / (1.0 + color);\n    #endif\n    #if TONEMAP_TYPE == FILMIC_TONEMAP    \n    color *= TONEMAP_EXPOSURE;\n    vec3 tonemapedColor = Uncharted2Tonemap(TONEMAP_EXPOSURE_BIAS * color);\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap(vec3(W));\n    color = tonemapedColor * whiteScale;\n    #endif\n   \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\t\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\t\n    float intensity = INTENSITY;\n    #if DAY_AND_NIGHT\n    \tintensity *= clamp(sin(time * DAY_AND_NIGHT_TIME) + DAY_AND_NIGHT_MIN_BRIGHTNESS, \n\t\t\t   DAY_AND_NIGHT_MIN_BRIGHTNESS, \n\t\t\t   DAY_AND_NIGHT_MAX_BRIGHTNESS);\n    #endif\n\t\n    EPSILON_NRM = 0.5 / iResolution.x;\n\t\n    #if SIMULATE_MODE == SIMULATE\n\tSEA_CURRENT_TIME = iTime * SEA_SPEED;\n    #elif SIMULATE_MODE == SIMULATE2x\n\tSEA_CURRENT_TIME = iTime * SEA_SPEED * 2.0;\n    #elif SIMULATE_MODE == SIMULATE3x\n\tSEA_CURRENT_TIME = iTime * SEA_SPEED * 3.0;\n    #elif SIMULATE_MODE == SIMULATE4x\n\tSEA_CURRENT_TIME = iTime * SEA_SPEED * 4.0;\n    #elif SIMULATE_MODE == SIMULATE5x\n\tSEA_CURRENT_TIME = iTime * SEA_SPEED * 4.0;\n    #elif SIMULATE_MODE == PAUSED\n\tSEA_CURRENT_TIME = 0.0;\n    #elif SIMULATE_MODE == SLOW_MOTION\n\tSEA_CURRENT_TIME = iTime * SEA_SLOWMOTION_SPEED;\n    #endif\n \n    #if FLIP_WATER_AND_SKY\n    vec3 dir = normalize(vec3(-uv.xy, -1.0));\n    #else\n    vec3 dir = normalize(vec3(uv.xy, -1.0));\n    #endif\n    dir.z += length(uv) * SEA_DIR_Z_SCALE;\n    dir = normalize(dir);\n    \n    Material mat;\n    #if FRESNEL_FORMULA == FRESNEL_SCHLICK_FORMULA\n    mat.fR0 = SEA_R0;\n    #endif\n    mat.fSmoothFactor = SEA_SMOOTH_FACTOR;\n\t\n    vec3 p = seaHeightMap(dir);\n    vec3 lightDir = vec3(0.0, -1.0, 0.0);\n    \n    float smothMixFactor = pow(smoothstep(0.0, SMOOTH_MIX_Y, dir.y), MIX_SEA_AND_SKY_FACTOR);\n    \n    vec3 sky = sky(dir);\n    vec3 sea = sea(p, lightDir, dir, mat);\n\n    vec3 color = mix(sky, sea, smothMixFactor); \n    \n    #if FOG_MODE != NEVER_FOG\n    color = fog(color, dir.z);\n    #endif\n    \n    #if RAIN\n    vec3 rainColor = vec3(1.0, 1.0, 1.0) * 1.5;\n    float rainFactor = rain(uv, xy);\n    color = mix(color, rainColor, rainFactor);\n    #endif\n    \n    color = color * intensity + COLOR_GRADING;\n\n    #if STAR_SKY\n    color += star(uv);\n    #endif\n    \n    #if RAINBOW\n    color += rainbow();\n    #endif\n\t\n    color = color * CONTRAST + 0.5 - CONTRAST * 0.5;\n\t\n    float dc = length(uv) * 0.5;\n\t\n    vec3 circCol = 1.0 * vec3(0.2, 0.9, 0.7);\n\n    float y = 0.0;\n    y += 0.2;\n    y += circle(uv, dc, 1.0);\n    y += circle(uv, dc, 0.5);\n    y += circle(uv, dc, 0.2);\n    y += grid(uv, y, 0.9);\n    y += grid(uv, y, 0.1);\t\n\t\n    color += circCol * sqrt(pow(y, 1.5));\n\t\n    if (line(uv, vec2(-0.005, -1.0), vec2(0.0015, 1.0)) ||\n        line(uv, vec2(-2.0, -0.005), vec2(2.0, 0.0015)))\n    {\n\t\tcolor = vec3(0.0, 0.2, 0.0);\n    }\n\t\n    #if APPLY_LUMINANCE\n    float luminance = GetFragLuminance(color);\n    luminance = saturate(luminance);\n    vec3 resLuminance = vec3(length(color.r * luminance), \n\t\t\t     length(color.g * luminance), \n\t\t\t     length(color.b * luminance));\n\n    color.rgb = resLuminance;\n    #endif\n\t\n    #if SEPIA_FILTER\n    float greyScale = GetFragLuminance(color);\n    color = greyScale * SEPIA_COLOR * SEPIA_INTENSITY;\n    #endif\n\t\n    #if VIGNETTE_FILTER\n    color *= vec3(VIGNETTE_COLOR) * saturate(1.0 - length(uv / VIGNETTE_ZOOM)) * VIGNETTE_EXPOSURE;\n    #endif\n\t\n    #if APPLY_TONEMAP\n    color = Tonemap(color);\n    #endif\n\t\n    #if APPLY_GAMMA_CORRECTION\n    color = pow(color, vec3(1.0 / GAMMA));\n    #endif\n\t\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttXXzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttXXzN", "name": "nPrism", "author": "butadiene", "description": "nprism", "tags": ["raymarching"], "likes": 3, "viewed": 281, "date": "1562245866", "time_retrieved": "2024-06-20T19:40:54.044543", "image_code": "\n\nconst float PI = 3.1415926;\n\nfloat nPrism(vec3 p,vec2 h,float n,float s){\n  float np = 2.0*PI/n;\n  float r =  atan(p.x,p.y)-0.5*np;\n  r = mod(r,np)-0.5*np;\n  float ln = length(p.xy);\n  vec2 kp = ln*vec2(cos(r),sin(r));\n  vec3 kv = vec3(kp.x-h.x,abs(kp.y)-s*h.x*tan(np*0.5),abs(p.z)-h.y);\n  float d = length(vec2(max(kv.x,0.0),max(kv.y,0.0)));\n  d = length(vec2(max(kv.z,0.0),max(d,0.0)))-min(min(max(-kv.x,0.0),max(-kv.y,0.0)),max(-kv.z,0.0));\n  return d;\n}\nfloat cube(vec3 p,vec3 s){\n  vec3 q =abs(p);\n  return length(max(q-s,0.0));\n}\n\nfloat crsp(vec3 p){\n  float d =1.;\n  return d;\n}\nfloat dist(vec3 p){\n  float d = cube(p,vec3(0.6));\n  float nd = nPrism(p,vec2(0.3,0.7),8.0+4.0*sin(iTime*1.3),0.7+0.3*(sin(iTime)));\n  \n  d = max(d,-nd);\n  if(fract(iTime*0.4)>0.5)d =nd;\n  return d;\n}\nvec3 getnormal(vec3 p){\n  vec2 e = vec2(0.01,0.0);\n  return normalize(vec3(\n  dist(p + e.xyy)-dist(p - e.xyy),\n  dist(p + e.yxy)-dist(p - e.yxy),\n  dist(p + e.yyx)-dist(p - e.yyx)));\n}\nvec3 lighting(vec3 p){\n  vec3 n = getnormal(p);\n  vec3 ld =normalize( vec3(0.5,1,3));\n  float ndl = dot(n,ld);\n  vec3 col = vec3(ndl);\n  return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.yy;\n    vec3 tn = iTime*vec3(0.0,0.0,0.0);\n    float tk = iTime;\n    vec3 ro = vec3(5.*cos(tk),2.0,5.*sin(tk))+tn;\n    vec3 ta = vec3(0.0,0.0,0.0)+tn;\n    vec3 cdir = normalize(ta-ro);\n    vec3 up =vec3(0.,1.,0.);\n    vec3 side = cross(cdir,up);\n    up = cross(side,cdir);\n    float fov = 3.2;\n    vec3 rd = normalize(p.x*side+p.y*up+cdir*fov);\n    float t =0.0001;\n    float d;\n    vec3 ac=vec3(0.0);\n    for(int i =0;i<100;i++){\n      d = dist(ro+rd*t);\n      t += d;\n    }\n\n    vec4 col = vec4(0.,0.,0.,1.);\n    if(d<0.001){\n    col.xyz = lighting(ro+rd*t);\n    }\n    fragColor = col;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttXXzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlfSRs", "name": "Chrono Trigger - Time Gate", "author": "KilledByAPixel", "description": "The time travel effect from Chrono Trigger in HD!\n\nActual video from the snes game: https://www.youtube.com/watch?v=I0lSR0byAOg", "tags": ["retro", "snes"], "likes": 9, "viewed": 1029, "date": "1563909431", "time_retrieved": "2024-06-20T19:40:54.044543", "image_code": "//////////////////////////////////////////////////////////////////////////////////\n// Time Gate - Copyright 2019 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\n#define PI (3.14159265359)\n#define time (PI*iTime) // 4 second loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv between -.5 - .5\n\tvec2 uv = fragCoord/iResolution.xy;\n\tuv -= vec2(.5);\n    \n    // square aspect\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 c1; // blue part\n    float s; // stripes\n    {\n        // angle & distance\n        float a = atan(uv.x,uv.y);\n        float d = length(uv);\n\n        // waves\n        d += 0.1;\n        d += .3*pow(d,2.5)*sin(a*18.);\n        d = pow(d,0.005);\n        d *= 5999.;\n\n        // rings\n        d = .5+.5*sin(d-2.0*8.*time);\n\n        // thicker at center\n        float b = pow(d, 1.0);\n\n        // fade at sides\n        b *= 1.0-length(uv);\n\n        // thin stripes at sides\n        s = 1.0+1.0*length(uv)*sin(a*300.);\n        b *= s;\n        \n        // color\n        c1 = vec3(0,0,b);\n    }\n\t\n\tvec3 c2; // pink/cyan part\n\t{\n\t\tfloat y = uv.y;\n\t\tfloat x = uv.x;\n\t\t\n\t\t// skew\n\t\tx -= sin(y*6.)/9.;\n\n\t\t// perspective\n\t\tx /= pow(y+sign(y),6.0);\n\n\t\t// waves\n\t\tfloat a = pow(abs(y)+.03,0.1)*32.;\n\t\tx += 0.03*sin(a-time);\n\n\t\t// stripes\n\t\tx = sin(x*30.);\n\n\t\t// color - cycle pink and cyan\n\t\tfloat b = pow(abs(x), 20.0);    \n\t\tfloat p = sin(time/2.)*.5+.5;\n\t\tc2 = vec3(b*p,b*(1.-p),b*.9);\n       \t\n\t\t// apply inverse stripes\n\t\tc2 /= s;\n\t}\n\n\tfragColor = vec4(c1+c2*.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlfSRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlfSW8", "name": "donut__________", "author": "shimizu", "description": "a", "tags": ["tag"], "likes": 2, "viewed": 164, "date": "1562717355", "time_retrieved": "2024-06-20T19:40:54.044543", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{      \n    vec2 p=(fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n\tp=p*201.0+1.0;\n\tvec2 i=floor(p*0.5);\n\tvec2 f=mod(p,2.0)-1.0;\n\t\n\tfloat d=length(f);\n\td=1.-smoothstep(0.6,0.85,d);\n\t\n\tfloat c=sin(iTime*5.-length(i)/101.*3.14*2.*1.5)*0.5+0.5;\n    \n\tc*=d;\n\tc*=0.7;\n\t\n\tfragColor=vec4(c,c,c,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlfSW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlfXD8", "name": "Cellularis", "author": "OctopusX", "description": "Just playing with cellular patterns", "tags": ["noise", "cellular", "pattern"], "likes": 12, "viewed": 227, "date": "1562660961", "time_retrieved": "2024-06-20T19:40:54.044543", "image_code": "#define UVScale 1.0\n#define AnimSpeed 2.0\n#define AnimScale sin(iTime) *0.65\n#define m mat2(7, -5, 5, 7)*0.1\n\n//Hash by Dave Hoskins: https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//Forked from: https://www.shadertoy.com/view/MdKXDD\nfloat FastCellular2D(vec2 p, int count, float speed)\n{\n\tfloat o = 1.0;\n\tfor (int i=0; i<count; i++)\n\t{\n\t\tp *= m;\n        float h = hash13(vec3(floor(p),i));\n        float s = sin(iTime*h *AnimSpeed *speed) *AnimScale +0.75;\n\t\to = min(o, length(fract(p) - 0.5)/0.6 + s *0.5);\n\t}\n\treturn o;\n}\n\nvoid mainImage(out vec4 col, in vec2 uv)\n{\n    float aspect = iResolution.x / iResolution.y;\n    uv /= iResolution.xy / UVScale *0.1; uv.x *= aspect;\n    uv.x += iTime *0.35;\n    float ptn0 = FastCellular2D(uv *1.26, 5, 1.0);\n    float ptn1 = FastCellular2D(uv *0.66, 5, 1.5);\n    col = vec4(min(ptn0, ptn1)); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlfXD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlfXDj", "name": "peels_spin", "author": "Hirai_worthless", "description": "aaaaaaaaa", "tags": ["raymarching"], "likes": 3, "viewed": 78, "date": "1564294524", "time_retrieved": "2024-06-20T19:40:54.044543", "image_code": "float map(vec3 p){\n\n        p.xz *= mat2(cos(iTime),-sin(iTime)\n             ,sin(iTime),cos(iTime));\n\tfloat s1 = max(abs(length(p) - 1.8) - 0.05, max(p.x,-p.z));\n        p.yz *= mat2(cos(iTime),-sin(iTime)\n             ,sin(iTime),cos(iTime));\n    float s2 = max(abs(length(p) - 1.5) - 0.05,max(p.y,-p.z));\n        p.xy *= mat2(cos(iTime),-sin(iTime)\n             ,sin(iTime),cos(iTime));\n    float s3 = max(abs(length(p) - 1.2) - 0.05,max(p.x,-p.y));\n            p.xz *= mat2(cos(iTime),-sin(iTime)\n             ,sin(iTime),cos(iTime));\n\tfloat s4 = max(abs(length(p) - 0.9) - 0.05, max(-p.x,p.z));\n            p.yz *= mat2(cos(iTime),-sin(iTime)\n             ,sin(iTime),cos(iTime));\n    float s5 = max(abs(length(p) - 0.6) - 0.05,max(-p.y,p.z));\n            p.xy *= mat2(cos(iTime),-sin(iTime)\n             ,sin(iTime),cos(iTime));\n    float s6 = max(abs(length(p) - 0.3) - 0.05,max(-p.x,p.y));\n    float holes = min((length(p.xy) - 0.2),min((length(p.xz) - 0.2),(length(p.yz) - 0.2)));\n    return max(min(min(s1,min(s2,s3)),min(s4,min(s5,s6))),  -holes);\n}\n\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 96; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return vec4(getNormal(p),t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float PI = 3.14159265;\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv,1.2));\n    \n    vec3 o = vec3(0,0,-2.5);\n    vec4 data = trace(o,r);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    vec3 fc = mix(vec3(0.5 - data.x,0.5 -data.y,0.5-data.z),vec3(1.0),1.0 - fog);\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlfXDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlfXRM", "name": "random- ejemplo-v3", "author": "jorge2017a1", "description": "random- ejemplo-v3", "tags": ["random"], "likes": 2, "viewed": 106, "date": "1562334984", "time_retrieved": "2024-06-20T19:40:54.626366", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n/*void main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n\n    // Scale the coordinate system to see\n    // some noise in action\n    vec2 pos = vec2(st*5.0);\n\n    // Use the noise function\n    float n = noise(pos);\n\n    gl_FragColor = vec4(vec3(n), 1.0);\n}\n*/\n\n\n/*vec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    mat2 rot = rotateMatrix2D(_angle);\n    _st =  rot * _st;\n    _st += 0.5;\n    return _st;\n}\n*/\n\n\nvec2 rotate2d (vec2 _st, float _angle) {\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t\n    vec2 pos = vec2(uv*5.0+iTime/0.50);\n    \n    \n    \n    pos.x = uv.x*5.0+iTime/0.50;\n    pos.y = uv.y+iTime/1.50;\n\n    \n    \n    pos = rotate2d( vec2(noise(pos)),30.0 ) * pos; // rotate the space\n    //pattern = lines(pos,.5); // draw lines\n    \n    \n    \n    // Use the noise function\n    float n = noise(pos);\n\n    //gl_FragColor = vec4(vec3(n), 1.0);\n    \n    \n    \n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    //fragColor = vec4(vec3(n)-col,1.0);\n    fragColor = vec4(vec3(n*col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlfXRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlfXW4", "name": "Cauliflower glow", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 20, "viewed": 248, "date": "1562850836", "time_retrieved": "2024-06-20T19:40:54.626366", "image_code": "#define rotate(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat g = 0.0;\n\nfloat deCauliflower(vec3 p, vec3 s, float r, float t)\n{    \n    for (int i=0;i<6;i++){\n        p = abs(p)-s;\n        mat2 m = rotate(sin(t*0.8+0.3*sin(t))*2.0+0.8);\n        p.xy *= m;\n        p.yz *= m;\n        s *= 0.5;\n    }\n    p = abs(p)-s;\n    if (p.x < p.z) p.xz = p.zx;\n    if (p.y < p.z) p.yz = p.zy;        \n \tp.z = max(0.0,p.z);\n    return length(p)-r;\n }\n\nfloat map(vec3 p)\n{\n    float de = deCauliflower(p,vec3(4.5),0.01,iTime);\n    g += 0.1/(0.3+de*de*10.0); // Distance glow by balkhan\n    return deCauliflower(p,vec3(4.5),0.06,iTime+0.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 25.0+sin(iTime*0.8+sin(iTime*0.5)*0.8)*5.0);\n    ro.xz *= rotate(iTime*0.3);\n    ro.xy *= rotate(iTime*0.5);\n    vec3 w = normalize(-ro);\n    vec3 u = normalize(cross(w,vec3(0,1,0)));\n \tvec3 rd = mat3(u,cross(u,w),w)*normalize(vec3(uv, 3));\n\tvec3 col = vec3(0.05);\n\tfloat t = 0.0, d;\n \tfor(int i = 0; i < 64; i++)\n  \t{\n    \tt += d = map(ro + rd * t);\n    \tif(d < 0.001) break;\n  \t}\n    col += vec3(0.0,0.7,0.3)*g*0.25;\n    col = clamp(col,0.0,1.0);\n    fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlfXW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlfXWM", "name": "colorful city", "author": "ankd", "description": "raymarching billding\ni try to repeat the object and get id for each object. \nid is used to get color and height", "tags": ["raymarching", "vivid"], "likes": 4, "viewed": 217, "date": "1563204031", "time_retrieved": "2024-06-20T19:40:55.462839", "image_code": "#define PI 3.14159265359\n\n#define MARCH_MIN 1e-3\n#define MARCH_MAX 1000.\n#define MARCH_ITR 512\n#define MARCH_THR 1e-5\n\n#define BILL_W 1.0\n#define BILL_H 4.0\n\n// utils function -----------------------------------------------------------------\nvec3 hsv(in float h, in float s, in float v) { return ((clamp(abs(fract(h+vec3(0., 2., 1.)/3.)*6.-3.)-1., 0., 1.)-1.)*s+1.)*v; }\nmat2 rotate(in float r) { float c=cos(r), s=sin(r); return mat2(c, -s, s, c); }\nvec2 rotate(in vec2 p, in float r) { return rotate(r) * p; }\nvec3 rotate(in vec3 p, in vec3 r) {\n  vec3 q = p;\n  q.xy = rotate(q.xy, r.z);\n  q.yz = rotate(q.yz, r.x);\n  q.zx = rotate(q.zx, r.y);\n  return q;\n}\n\nfloat hash(in float x) { return fract(sin(x) * 43237.5324); }\nfloat hash(in vec2 x) { return fract(sin(dot(x, vec2(12.9898, 78.233)))*43237.5324); }\nfloat hash(in vec3 x) { return fract(sin(dot(x, vec3(12.9898, 78.233, 49.256)))*43237.5324); }\nvec3 hash3(in float x) { return vec3(hash(x), hash(x+999.), hash(x+99999.)); }\n\n// distance function ----------------------------------------------------------------------------------------------\nfloat box(in vec3 p, in vec3 b) { vec3 d=abs(p)-b; return length(max(d, 0.))+min(max(d.x, max(d.y, d.z)), 0.); }\nfloat plane(in vec3 p, in vec3 n, in float h) { return dot(p, n) - h; }\n\n// operator ------------------------------------------------------------------------------------------------------\nvec2 opU(in vec2 d1, in vec2 d2) { return d1.x<d2.x ? d1 : d2; }\nfloat smin(in float a, in float b, in float k) {\n\tfloat h = max(k - abs(a-b), 0.);\n    return min(a, b) - h*h/(4.0*k);\n}\nvec4 opRep(in vec3 p, in vec3 c) {\n    vec3 id = floor(p / c) * vec3(\n    \tc.x>0. ? 1. : 0.,\n    \tc.y>0. ? 1. : 0.,\n    \tc.z>0. ? 1. : 0.\n    );\n\treturn vec4(mod(p, c) - 0.5*c, hash(id));\n}\n\n// map ------------------------------------------------------------------------------------------------------------\nfloat tile(in vec3 p, in vec3 n, in vec2 h) {\n    float d = plane(p, n, h.x);\n    vec3 q = p; q.xz = mod(q.xz, 2.0) - 1.0;\n    d = smin(d, box(q, vec3(0.95, h.y, 0.95)), .1);\n    return d;\n}\nfloat boxs(in vec3 p, in vec3 b, in float r) {\n\tvec3 q = p;\n    q.xz = abs(q.xz);\n    q.xz = q.z<q.x ? q.xz : q.zx;\n    float d = box(q-vec3(r, 0., 0.), b);\n    return d;\n}\nfloat bill(in vec3 p, in vec2 b) {\n    float d = box(p, b.xyx);\n    float s = boxs(p, vec3(b.x*0.1, b.y*0.9, b.x*0.8), b.x);\n    d = max(d, -s);\n    //d = s;\n    return d;\n}\n\nvec2 map( in vec3 p ) {\n    vec2 res = vec2(1e8, -1.);\n    res = opU(res, vec2(tile(p, vec3(0., 1., 0.), vec2(0., 0.08)), 0.));\n    \n    vec3 q = p;\n    vec4 qtmp = opRep(q, vec3(BILL_W*7., 0., BILL_W*4.0));\n    float h = BILL_H - qtmp.w*3.0;\n    q.y -= h;\n    q = vec3(qtmp.x, q.y, qtmp.z);\n    q.x -= 1.0*(qtmp.w*2.0-1.0);\n    res = opU(res, vec2(bill(q, vec2(BILL_W, h)), qtmp.w));\n    return res;\n}\n\n// lighting --------------------------------------------------------------------------------------------------\nvec3 calcNormal(in vec3 p) {\n  vec2 e = vec2(1., -1.) * 2e-5;\n  return normalize(\n      e.xyy * map(e.xyy+p).x +\n      e.yxy * map(e.yxy+p).x +\n      e.yyx * map(e.yyx+p).x +\n      e.xxx * map(e.xxx+p).x\n    );\n}\nfloat diffuse(in vec3 n, in vec3 l, in float s) { return pow(clamp(dot(n, l), 0., 1.), s); }\nfloat specular(in vec3 r, in vec3 l, in float s) { return pow(clamp(dot(r, l), 0., 1.), s); }\n\n// ray marching  --------------------------------------------------------------------------------------------------\nvec2 rayMarch(in vec3 ro, in vec3 rd) {\n    float d=MARCH_MIN, m=-1.;\n    for(int i=0;i<MARCH_ITR;i++) {\n    \tvec2 tmp = map(ro + rd*d);\n        if(tmp.x<MARCH_THR || MARCH_MAX<tmp.x) break;\n        d += tmp.x*0.3;\n        m = tmp.y;\n    }\n    if(MARCH_MAX<d) m=-1.;\n    return vec2(d, m);\n}\n\n// color  --------------------------------------------------------------------------------------------------\nvec3 getSkyColor(in vec3 rd) {\n\treturn mix(vec3(1.), vec3(0.4, 0.6, 1.0), exp(rd.y));\n}\n\n// rendering  --------------------------------------------------------------------------------------------------\nvec4 render(vec3 ro, vec3 rd) {\n    vec4 result = vec4(0.);\n\n    vec2 tmp = rayMarch(ro, rd);\n    if(tmp.y<0.) {\n        result = vec4(getSkyColor(rd), 1.);\n    } else {\n        // get surface info\n\t    vec3 surfaceP = ro + rd*tmp.x;\n\t    vec3 surfaceN = calcNormal(surfaceP);\n\t    vec3 surfaceR = reflect(rd, surfaceN);\n        \n        // vec3 lp = vec3(5.);\n        vec3 lp = ro - vec3(0., 0., -15.);\n        vec3 directionalLight = normalize(vec3(1.));\n        vec3 pointLight = normalize(lp - surfaceP);\n\n        result = vec4(hsv(tmp.y, 0.<tmp.y?1.:0., 1.), 1.0);\n        \n        float diff = //diffuse(surfaceN, directionalLight, 1.);\n            \t\t\t+ diffuse(surfaceN, pointLight, 1.);\n        float spec = specular(surfaceR, pointLight, 100.);\n\n        result *= 0.02+0.98*diff;\n        result += spec;\n\t}\n    \n    result += clamp(1.0-exp(-0.01*tmp.x), 0., 1.);\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (gl_FragCoord.xy*2.-iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec3 color = vec3(0.);\n\n    // set camera\n    vec3 ro = vec3(0., .3, -iTime*15.0);\n    vec3 tar = ro + vec3(1., 2.5, -6.);\n    vec3 cz = normalize(tar - ro);\n    float cr = iTime*0.;\n    vec3 cx = normalize(cross(cz, vec3(sin(cr), cos(cr), 0.)));\n    vec3 cy = normalize(cross(cx, cz));\n    vec3 rd = normalize(mat3(cx, cy, cz) * vec3(p, 2.));\n\n    // rendering\n    vec4 col = render(ro, rd);\n    color = col.rgb;\n\n    // screen space post effect\n    color = pow(color, vec3(0.4545));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlfXWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlfXz8", "name": "Somebody's Watching", "author": "mosaic", "description": "Click to view without polar transform", "tags": ["polar"], "likes": 5, "viewed": 293, "date": "1562661907", "time_retrieved": "2024-06-20T19:40:56.050877", "image_code": "//screenshake from https://www.shadertoy.com/view/XljBDc\n#define TileU 1.0\n#define TileV 3.0\n\n#define SpeedU -0.1\n#define SpeedV 0.0\n\n#define M_PI 3.1415926535897932384626433832795\n\n#define PI 3.14159\n#define TAU (PI * 2.)\n#define HPI (PI * .5)\n\n\nfloat HitCurve(float t,float hitFlag, float raiseFlag)\n{\n    t = mod(t,1.);\n    float hit = step(t,hitFlag);\n    float raise = step(raiseFlag,t);\n    float stay = 1. - raise - hit;\n    return 1. - (\n        pow(t / hitFlag,2.) * hit \n        + stay\n        + (cos((t - raiseFlag) * 1. / (1. - raiseFlag) * PI) * .5 + .5) * (raise)\n        );\n}\n\nfloat HitShakeCurve(float t, float hitFlag)\n{\n    t = mod(t, 1.);\n    return  step(hitFlag, t) * max(pow(hitFlag - t + 1., 18.), 0.);\n}\n\n\nfloat NB_SQUARE = 6.;\n\nfloat bpm = 50.;\n\n///============\n\n\nfloat divScotFlag( vec2 uv) {\n    float botRight = step( uv.x + uv.y, 1. );\n    float botLeft = step( uv.x + 1. - uv.y, 1. );\n    \n    // Scottish flag ( sorta )\n    float scotFlag = abs(botRight - botLeft);\n    float divider = step( uv.x, .5);\n    \n    // Divided scottish flag\n    return abs( divider - scotFlag);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\t\n    //vignette\n    float dist = length(uv)/1.6;\n    float col = dist / 1.;\n \n    uv/=1.9;\n    uv.y+=.4;\n    \n    //mirror\n\tuv.x=abs(sin(iTime/2.)-uv.x);\n    \n    //map to polar coordinates\n    vec2 delta = uv - vec2(0.5,0.5);\n\tfloat radius = length(delta);\n\tfloat angle = atan(delta.y, delta.x) / 2. / M_PI;\n    \n    radius *= TileU;\n    radius += SpeedU *iMouse.x/500.;\n        \n    angle *= TileV;\n    angle += SpeedV * iMouse.x/500.;\n    \n    vec2 polarUV = vec2(radius, angle);\n\n    float time = iTime * bpm / 60. ;\n    float hit = .05;\n    float raise = .75;\n    \n    float shakeForce = 0.;\n      \n    for(float i = 0.; i < 6.; ++i)\n    {\n        float decal = (time + i) / NB_SQUARE;\n        shakeForce += HitShakeCurve(decal, hit);\n    }\n    \n    float shakeAmplitude = .025;\n    vec2 shake = vec2(sin(time * 3256.123), sin(time * 4256.365)) * shakeAmplitude * shakeForce;\n    \n    \n    //comment out this line to disable screen shake\n    polarUV += shake;\n    uv  += shake;\n    \n    //                                                                      colour effect\n   \n    \n   vec3 cool =   vec3( divScotFlag( fract(polarUV*4.-(iTime/10.) * 4.) ) )-col-vec3(.1,.9,.9);//+vec3(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)));;\n    \n     vec3 other =   vec3( divScotFlag( fract(uv*4.-(iTime/10.) * 4.) ) )-col-vec3(.1,.9,.9);//+vec3(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)));;\nif (iMouse.z <= 0.){   \nfragColor = vec4( vec3( cool  ),  1.0)+.4;\n       \n} else fragColor = vec4( vec3( other  ),  1.0)+.4;\n}    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlfXz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlfXzH", "name": "Practice - Space Travel", "author": "ReavenTehDerg", "description": "Playing around with a band creating function made by Kyle273's", "tags": ["texture", "vignette", "rotation", "polar"], "likes": 4, "viewed": 137, "date": "1562055411", "time_retrieved": "2024-06-20T19:40:56.056689", "image_code": "float N21(vec2 p)\n{\n    p = fract(p * vec2(8356.655414, 645.8778));\n    p += dot(p, p + 72.724);\n    return fract(p.x * p.y);\n}\nvec2 N22(vec2 p)\n{\n    float x = N21(p);\n    float y = N21(p + x);\n    return vec2(x, y);\n}\nfloat circleMask(vec2 uv, float radius)\n{\n    float vL = length(uv);\n    float circle = smoothstep(radius, radius - 0.04, vL);\n    return circle;\n}\nvec2 GetPos(vec2 id)\n{\n    vec2 n = N22(id) * iTime * 0.6;\n    return sin(n) * .4;\n}\nfloat map(float value, float fromSource, float toSource, float fromTarget, float toTarget)\n{\n    return (value - fromSource) / (toSource - fromSource) * (toTarget - fromTarget) + fromTarget;\n}\nfloat Shines(vec2 uv, float size)\n{\n    uv *= size;\n    uv.y -= iTime * 0.2;\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    float shineRate = map(abs(sin(iTime * N21(id))), -1.0, 1.0, 0.06, 0.2);\n    vec2 p = GetPos(id);\n    float d = length(gv - p);\n    float m = smoothstep(0.1, 0.03, d) * shineRate;\n    return m * 1.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float shine = Shines(uv, 4.0);\n    float posShine = 0.0;\n    for(float i = 0.0; i <= 10.0; i += 0.5, posShine += 2.0)\n    {\n    \tshine += Shines(uv + posShine, i);\n\n    }\n    \n\n    \n   \n    uv *=  1.0 - uv.yx;    \n    float vig = uv.x*uv.y * 15.0;    \n    vig = pow(vig, 0.25);\n    \n\tuv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n\n    float t = iTime * 0.8;\n    \n    float s = sin(t);\n    float c = cos(t);\n    \n    mat2 rotmat = mat2(c, -s, s, c);\n                  \n    uv *= rotmat;\n\n    float angle = atan(uv.y,uv.x);\n    vec4 tex = texture(iChannel0, vec2(angle, dot(uv.x, uv.y) + fract(t * 0.3)));\n    vec4 tex2 = texture(iChannel1, vec2(angle, dot(uv.x, uv.y) - fract(t * 0.1)));\n    \n    vec4 col = vec4(0);\n    \n    //Kyle273's band function\n    float band = pow(sin(angle * 2.0) * 0.5 + 0.5, 5.0) * 3.0;\n    col += tex * band;\n    \n    angle += 1.5;\n    band = pow(sin(angle * 2.0) * 0.5 + 0.5, 1.0);\n    col += tex2 * band;\n    \n\t\n    \n    fragColor = shine + col * vig;\n    \n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlfXzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlfXzj", "name": "Tumbling Squares", "author": "104", "description": "They tumblin'", "tags": ["2d", "aesthetic", "hypnosis", "chill"], "likes": 8, "viewed": 464, "date": "1563550624", "time_retrieved": "2024-06-20T19:40:56.650778", "image_code": "\n// boilerplate ======================\nconst float PI = 3.14159;\nconst float PI2 = PI*2.;\n\nvec3 dtoa(float d, vec3 amount){\n    return vec3(1. / clamp(d*amount, vec3(1), amount));\n}\nmat2 rot2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\nfloat nsin(float x) {\n    return cos(x)*.5+.5;\n}\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\nfloat opXor(float lhs, float rhs) {\n    return opUnion(opIntersection(lhs, -(rhs)), opIntersection(rhs, -(lhs)));\n}\n\nfloat sdSquare(vec2 p, vec2 center, float s) {\n\tvec2 d = abs(p-center) - s;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n// end boilerplate ======================\n\nconst float th = 1./3.;\nfloat hello(float sd, vec2 uv, float off, float a, vec2 sgn) {\n    sd = opXor(sd, sdSquare((uv + sgn*vec2(.5,.5)+vec2(-off,0)) * rot2D(a), vec2(-th*.5), th*.5));\n    sd = opXor(sd, sdSquare((uv + sgn*vec2(-.5,.5)+vec2(0,-off)) * rot2D(a+PI*.5), vec2(-th*.5), th*.5));\n    sd = opXor(sd, sdSquare((uv + sgn*vec2(.5,-.5)+vec2(0,off)) * rot2D(a-PI*.5), vec2(-th*.5), th*.5));\n    sd = opXor(sd, sdSquare((uv + sgn*vec2(-.5,-.5)+vec2(off,0)) * rot2D(a-PI), vec2(-th*.5), th*.5));\n    return sd;\n}\n\nfloat scurve(float x, float p) {\n    x = x / p * PI2;\n    return (x + sin(x+PI)) / PI2;\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv *= 2.8;\n    float tsteady = iTime*.25;\n    float t = scurve(tsteady, th);\n    float sd = 1e6;\n    float sdout = 1e6;\n    \n    uv *= rot2D(-tsteady*PI2*.25);\n    float r = .5+(sqrt(2.)*th);\n    uv -= r;\n    float padding = .1; // kinda important because blurriness doesn't cross cells\n    uv = mod(uv, r+r+padding)-r-padding*.5; // repetition\n\n    float seg = mod(t, 3.);\n    float aout = fract(seg)*PI*.5;\n    float ain = -(aout+PI*.5);\n    float offout = 0.;\n    float offin = th*2.;\n    if (seg >= 2.) {\n\t\taout = (fract(seg)-.5)*PI;\n        ain = PI;\n    } else if (seg >= 1.) {\n        offout = th*2.;\n    } else {\n        offout = th;\n        offin = th;\n    }\n\n    float tsel = mod(t/3., 3.);\n    bool A = false, B = false, C = false, D = false;\n    \n    if (tsel >= 2.) {\n    \t// (none)\n    } else if (tsel >= 1.) {\n    \t// (big plus)\n        A = B = true;\n    } else {\n    \t// (minimal + outline)\n        B = C = D = true;\n    }\n    \n    if (A) sd = sdSquare(uv, vec2(0),.5);\n   \tif (B) sd = opXor(sd, sdSquare(uv, vec2(0),r));\n   \tif (C) sd = opXor(sd, sdSquare(uv, vec2(0),r));\n    if (D) sd = hello(sd, uv, offout, aout, vec2(1));\n    \n    sdout = hello(sdout, uv, offout, aout, vec2(1));\n    sd = hello(sd, uv, offout, aout, vec2(1));\n    sd = hello(sd, uv, offin, ain, vec2(1));\n\n    o.rgb = dtoa(sd, 3.*vec3(50.,100.,200.)) * vec3(.9,.9,.8);\n    o.rgb += dtoa(sdout, 2.*vec3(100.,50.,50.)) * vec3(.1,-.8,.4);\n    \n    vec2 N = fragCoord / iResolution.xy-.5;\n\n    o.rgb += (hash32(fragCoord+t)-.5)*.1;\n    o.rgb += dot(N,N) * vec3(.2,.5,1);\n    o = clamp(o,o-o,o-o+1.);\n    o *= 1.-length(9.*pow(abs(N), vec2(3.)));// vingette\n    o.a = 1.;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlfXzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlfXzS", "name": "sinc magnification filter", "author": "FabriceNeyret2", "description": "How to nicely interpolate grid values to higher resolution using cardinal sinus (sinc).\nMouse = pixel to compute.\nWhite rings : nodes in the radius-s window. inner grey = weight. \nred/green = positive/negative areas.\nResult = sum ( weight * node value )", "tags": ["filter", "magnification", "interpolation", "tuto", "sinc"], "likes": 9, "viewed": 568, "date": "1563294069", "time_retrieved": "2024-06-20T19:40:56.862924", "image_code": "#define SCALE 6.\n#define s 3.      // sinc window size = (2s+1)^2\n#define sinc(x) sin(3.1416*(x)+1e-20) / (3.1416*(x)+1e-20)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         M = iMouse.xy;\n    if (length(M)<10.) M = R/2. + R/6.*cos(iTime+vec2(0,33));\n    M = SCALE* ( 2.*M - R ) / R.y;\n    U = SCALE* ( 2.*U - R ) / R.y;\n    \n    // --- draw continuous sinc function\n    vec2 D = U-M,\n         W = max(abs(D.x),abs(D.y)) <= s ? sinc(D) : vec2(0),\n         F = fract(U+.5) - .5;\n    O  = W.x*W.y * vec4(1,-1,0,0);\n    \n    // --- draw nodes\n    D = round(U)-M;\n    bool w = max(abs(D.x),abs(D.y)) <= s+.5;\n    W =  w ? sinc(D) : vec2(0);\n\n    float l = length(F),\n          p = SCALE * 2./R.y;\n    O = mix( O, vec4(abs(W.x*W.y)), smoothstep(p,0.,l-.2) ); // draw node weight\n    O = mix( O, w?vec4(1):vec4(0,.3,1,0), smoothstep(p,0.,abs(l-.2)) ); // draw node\n\n    // --- to sRGB    \n    O = pow( O, vec4(1./2.2) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlfXzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wllSD8", "name": "Ripples Sooth 2", "author": "skymen", "description": "ripples", "tags": ["ripple"], "likes": 4, "viewed": 225, "date": "1562807301", "time_retrieved": "2024-06-20T19:40:57.178157", "image_code": "#define random(p) fract(sin((p)* vec2(12.9898, 78.233)) * 43758.5453)\n\nfloat diskIn(vec2 r, vec2 center, float radius, float alpha) {\n\treturn alpha * (1.0 - smoothstep( radius - 0.005, radius + 0.005, length(r-center)));\n}\n\nfloat diskOut(vec2 r, vec2 center, float radius, float outline, float alpha) {\n\treturn alpha * \n        ((1.0 - \n          smoothstep(\n              radius + outline - 0.005, \n              radius + outline + 0.005, \n              length(r-center)))\n          -\n         ( 1. -\n          smoothstep( \n              radius - 0.005, \n              radius + 0.005, \n              length(r-center))));\n}\n\nfloat disk(vec2 r, vec2 center, float radius, float alpha, float outline, float outlineAlpha) {\n\treturn diskIn(r, center, radius, alpha) + diskOut(r, center, radius, outline, outlineAlpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(0.);\n    \n    float nbCircles = 2.;\n    float circleLife = 1.;\n    float circleRad = 100.;\n\tvec3 color = vec3(200./255., 50./255., 100./255.);\n    \n\tfor(float i = 0.; i < nbCircles; i++) {\n\t\tfloat timeOffset = i * circleLife/(nbCircles);\n        float uid = floor((iTime - timeOffset)/ circleLife) * nbCircles + i;\n        //uid = 1. + i;\n\t\tfloat modCircle = mod((iTime - timeOffset)*circleRad/circleLife, circleRad);\n        vec2 randPos = random(sqrt(2.)*uid) * (iResolution.xy);\n\t\tcol = mix(col, color,\n                  disk(fragCoord, randPos, modCircle, (1.0 - modCircle/circleRad), mix(5., 0., (modCircle/circleRad)), 1.));\n\t\t\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wllSD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WllSDM", "name": "Neon road", "author": "kaneta", "description": "inspired by https://www.reddit.com/r/IndieDev/comments/9wpia9/speed_boosts_breaking_space_time/", "tags": ["3d", "volume", "raymarch", "glow"], "likes": 63, "viewed": 3025, "date": "1563206417", "time_retrieved": "2024-06-20T19:40:57.184329", "image_code": "#define repid(p, r) (floor((p + r*.5) / r))\n#define rep(p, r) (mod(p - r*.5, r) - r*.5)\n\n// Volumetric pointlight by robobo1221\n// https://www.shadertoy.com/view/lstfR7\nfloat bayer2(vec2 a){\n    a = floor(a);\n    return fract( dot(a, vec2(.5, a.y * .75)) );\n}\n\n#define bayer4(a)   (bayer2( .5*(a))*.25+bayer2(a))\n#define bayer8(a)   (bayer4( .5*(a))*.25+bayer2(a))\n#define bayer16(a)  (bayer8( .5*(a))*.25+bayer2(a))\n\nconst float pi = acos(-1.0);\nconst float pi2 = pi*2.;\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvec2 pmod(vec2 p, float r) {\n\tfloat a = pi/r - atan(p.x, p.y);\n    float n = pi2/r;\n    a = floor(a/n) * n;\n    return p * rot(a);\n}\n\nfloat sdHex(vec3 p, vec2 h, float r)\n{\n    p.zy = p.yz;\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat ost(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\nfloat sdFloor(vec3 p) {\n    vec2  hx = vec2(1.73205081,1)*1.04;\n    vec3  q = p;\n    q.xz = mod(p.xz + hx*0.5, hx)-hx*0.5;\n\tfloat d = sdHex(q, vec2(0.5, 1.0), 0.04);\n    q.xz = mod(p.xz, hx)-hx*0.5;\n    d = min(d, sdHex(q, vec2(0.5, 1.0), 0.04));\n    return d;\n}\n\nfloat sdWall(vec3 p) {\n\tvec3 q = p;\n    \n    // wall\n    float d = -(abs(p.x) - 8.);\n    \n    // square\n    q = p;\n    q.z = rep(q.z, 240.);\n    d = max(d, -sdHex(q, vec2(40., 100.), 0.0));\n    \n    // pillars\n    vec3 pp = p;\n    pp.z = rep(pp.z, 240.);\n    \n    q.x = abs(q.x) - 7.;\n    q.z = rep(q.z, 20.);\n    q = abs(q) - 1.0;\n    // clipping pillars in square\n    d = min(d, max(max(q.x, q.z), -(abs(pp.z) - 40. + 5.0)));\n    \n\treturn d;\n}\n\nfloat sdSquareObjects(vec3 p, float r, out float id) {\n\tvec3 q = p;\n    \n    q.z = rep(q.z, 240.);\n    vec3 pp = q;\n    q.xz *= rot(pi / 6.);\n    q.xz = pmod(q.xz, 6.);\n    q.z -= 15.;\n    \n    id = repid(q.z, 15.);\n    q.z = rep(q.z, 15.);\n    float d = length(q.xz) - r;\n    d = max(d, -length(pp.xz) + 15. - r);\n    return d;\n}\n\nfloat tt;\n\nfloat sdSquareFrame(vec3 p) {\n    float id;\n    float d = sdSquareObjects(p, 1.5 + 1., id);\n    d = max(d, -(abs(p.y - 13.) - (1.0 - exp(sin(tt * 5. - id * 1.25)*5.)/exp(5.)) * 5.));\n    return d;\n}\n\nfloat sdSquareEmission(vec3 p) {\n    float id;\n\tfloat d = sdSquareObjects(p, 1.5, id);\n    d = max(d, (abs(p.y - 13.) - (1.0 - exp(sin(tt * 5. - id * 1.25)*5.)/exp(5.)) * 5.));\n    return d;\n}\n\nfloat sdCeil(vec3 p) {\n\treturn -(p.y - 30.0);\n}\n\nfloat map(vec3 p) {\n    float d = sdFloor(p);\n\n    d = ost(d, sdWall(p), 1.0, 5.0);\n    \n    d = min(d, sdSquareFrame(p));\n    \n    d = min(d, sdCeil(p));\n\n    return d;\n}\n\nvec4 volumeMap0(vec3 p) {\n    vec3 q = p;\n    q.z = rep(q.z, 30.);\n    q.y -= 2.;\n    float d = length(q.zy) - .5;\n    return vec4(vec3(1., 0.001, .1) * .25, d);\n}\n\nvec4 volumeMap1(vec3 p) {\n    vec3 q = p;\n    q.z = rep(q.z, 30.);\n    q.z += 15.;\n    q.y -= 20.;\n    float d = length(q.zy) - .5;\n    return vec4(vec3(.01, 0.01, 1.0) * .4, d);\n}\n\nvec4 volumeMap2(vec3 p) {\n    vec3 q = p;\n    q.z = rep(q.z, 20.);\n    q.y -= 12.;\n    q.x = abs(q.x) - 6.;\n    float d = max(length(q.xy) - .25, abs(q.z) - 3.0);\n    return vec4(vec3(.01, 0.01, 1.0) * .3, d);\n}\n\nvec4 volumeMap3(vec3 p) {\n\tfloat d = sdSquareEmission(p);\n    return vec4(vec3(1., 0.01, 0.001) * .2, d);\n}\n\nvec3 volumetric(vec3 p, vec3 ray, int slice, float depth, float dither) {\n    vec3 ret = vec3(0.);\n    \n    float sd = depth / float(slice);\n    float t = 0.05 + sd * dither;\n    vec4 d;\n    for(int i = 0; i < slice; i++) {\n        vec3 pos = p + ray * t;\n        d = volumeMap0(pos);\n        float dd = max(0.01, d.w);\n        ret += (d.rgb*sd) / (dd * dd);\n        \n        d = volumeMap1(pos);\n        dd = max(0.01, d.w);\n        ret += (d.rgb*sd) / (dd * dd);\n        \n        d = volumeMap2(pos);\n        dd = max(0.01, d.w);\n        ret += (d.rgb*sd) / (dd * dd);\n        \n        d = volumeMap3(pos);\n        dd = max(0.01, d.w);\n        ret += (d.rgb*sd) / (dd * dd);\n        \n        t += sd;\n    }\n    return ret;\n}\n\nvoid trace(vec3 p, vec3 ray, int iter, out vec3 pos, out float t) {\n    t = .1;\n    for(int i=0; i<iter; i++) {\n    \tpos = p + ray * t;\n        float d = map(pos);\n        if (d < 0.0001) {\n            break;\n        }\n        t += d;\n    }\n}\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\nfloat n3(vec3 p) {\n\tvec3 r = vec3(1, 99, 999);\n\tvec4 s = dot(floor(p), r) + vec4(0., r.yz, r.y + r.z);\n\tp = smoothstep(0., 1., fract(p));\n\tvec4 a = mix(fract(sin(s)*5555.), fract(sin(s+1.)*5555.), p.x);\n\tvec2 b = mix(a.xz, a.yw, p.y);\n\treturn mix(b.x, b.y, p.z);\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(1., -1.) * 0.001; // 0.005;\n    return normalize(e.xyy * map(p + e.xyy) + e.yxy * map(p + e.yxy) + e.yyx * map(p + e.yyx) + e.xxx * map(p + e.xxx));\n}\n\nvec3 applyFog(vec3 col, float depth) {\n    float fog = 1.0 - exp(-depth * 0.0003);\n    col = mix(vec3(col), vec3(1.0, 1.05, 1.8) * 10., fog);\n    return col;\n}\n\nvec3 getCol(inout vec3 p, vec3 ray, int titer, int viter, float vd, float dither) {\n    vec3 col, pos;\n    float depth;\n    trace(p, ray, titer, pos, depth);\n    col += volumetric(p, ray, viter, min(depth, vd), dither);\n    p = pos;\n    return applyFog(col, depth);\n}\n\nfloat stepup(float t, float len, float smo)\n{\n    float tt = mod(t += smo, len);\n    float stp = floor(t / len) - 1.0;\n    return smoothstep(0.0, smo, tt) + stp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float nois = (n3(vec3(normalize(p)*20., 1.0)) * 1.0 + n3(vec3(normalize(p)*40., 2.0)) * 1.5  + n3(vec3(normalize(p)*100., 3.0)) * 1.5) / 3.5;\n    nois = pow(nois, 4.0) * 2.0 - 1.0;\n    \n    tt = iTime + (nois * 0.009 + n3(vec3(p*500., 0.0)) * 0.004) * pow(dot(p, p), 0.6) * 1.;\n    \n    float speed = tt * 100.;\n    \n    //speed = stepup(tt, 1.0, 0.5) * 80.;\n\n    vec3 ro = vec3(0., 7., -5. + speed);\n    vec3 ray = normalize(vec3(p, 1.4 + (1.0 - dot(p, p)) * 0.15));\n    //ray.xy *= rot(stepup(tt-0.5, 4.0, 0.1) * pi * 0.5);\n    \n    float dither = bayer16(gl_FragCoord.xy);\n    vec3 col = getCol(ro, ray, 99, 120, 300., dither);\n\n    vec3 n = normal(ro);\n    ray = reflect(ray, n);\n    col += getCol(ro, ray, 60, 70, 100., dither) * 0.2;\n\n    n = normal(ro);\n    ray = reflect(ray, n);\n    col += getCol(ro, ray, 40, 40, 100., dither) * 0.04;\n\n    col = acesFilm(col*0.5);\n    \n    col = pow(col, vec3(1./2.2));\n    \n    p = fragCoord.xy / iResolution.xy;\n    p *=  1.0 - p.yx;\n    float vig = p.x*p.y * 30.0;\n    vig = pow(vig, 0.1);\n\n    fragColor = vec4(col * vig,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WllSDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WllSR7", "name": "Nice Fake Caustics", "author": "OctopusX", "description": "Just playing with FBMs", "tags": ["noise", "fbm", "caustic"], "likes": 13, "viewed": 426, "date": "1562458626", "time_retrieved": "2024-06-20T19:40:57.626677", "image_code": "#define UVScale \t\t\t 1.0\n#define Speed\t\t\t\t 1.5\n\n#define FBM_WarpPrimary\t\t-0.65\n#define FBM_WarpSecond\t\t 0.34\n#define FBM_WarpPersist \t-0.77\n#define FBM_EvalPersist \t 0.24\n#define FBM_Persistence \t 0.77\n#define FBM_Lacunarity \t\t 1.08\n#define FBM_Octaves \t\t 6\n\n\n\n//fork from Dave Hoskins\n//https://www.shadertoy.com/view/4djSRW\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx) * vec4(1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n\treturn -1.0 + 2.0 * fract(vec4(\n        (p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y,\n        (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x)\n    );\n}\n\n//offsets for noise\nconst vec3 nbs[] = vec3[8] (\n    vec3(0.0, 0.0, 0.0),vec3(0.0, 1.0, 0.0),vec3(1.0, 0.0, 0.0),vec3(1.0, 1.0, 0.0),\n    vec3(0.0, 0.0, 1.0),vec3(0.0, 1.0, 1.0),vec3(1.0, 0.0, 1.0),vec3(1.0, 1.0, 1.0)\n);\n\n//'Simplex out of value noise', forked from: https://www.shadertoy.com/view/XltXRH\n//not sure about performance, is this faster than classic simplex noise?\nvec4 AchNoise3D(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 fr = smoothstep(0.0, 1.0, fract(x));\n\n    vec4 L1C1 = mix(hash43(p+nbs[0]), hash43(p+nbs[2]), fr.x);\n    vec4 L1C2 = mix(hash43(p+nbs[1]), hash43(p+nbs[3]), fr.x);\n    vec4 L1C3 = mix(hash43(p+nbs[4]), hash43(p+nbs[6]), fr.x);\n    vec4 L1C4 = mix(hash43(p+nbs[5]), hash43(p+nbs[7]), fr.x);\n    vec4 L2C1 = mix(L1C1, L1C2, fr.y);\n    vec4 L2C2 = mix(L1C3, L1C4, fr.y);\n    return mix(L2C1, L2C2, fr.z);\n}\n\nvec4 ValueSimplex3D(vec3 p)\n{\n\tvec4 a = AchNoise3D(p);\n\tvec4 b = AchNoise3D(p + 120.5);\n\treturn (a + b) * 0.5;\n}\n\n//my FBM\nvec4 FBM(vec3 p)\n{\n    vec4 f, s, n = vec4(0.0);\n    float a = 1.0, w = 0.0;\n    for (int i=0; i<FBM_Octaves; i++)\n    {\n        n = ValueSimplex3D(p);\n        f += (1.0-abs(n)) *a;\t//ridged-like\n        s += n.zwxy *a;\n        a *= FBM_Persistence;\n        w *= FBM_WarpPersist;\n        p *= FBM_Lacunarity;\n        p += n.xyz * FBM_WarpPrimary *w;\n        p += s.xyz * FBM_WarpSecond;\n        p.z *= FBM_EvalPersist +(f.w *0.5+0.5) *0.0003;\n    }\n    return f;\n}\n\nvoid mainImage(out vec4 col, in vec2 uv)\n{\n    col = vec4(0.0, 0.0, 0.0, 1.0);\n    float aspect = iResolution.x / iResolution.y;\n    uv /= iResolution.xy / UVScale *0.1; uv.x *= aspect;\n    \n    vec4 fbm = (FBM(vec3(uv, iTime *Speed +20.0))) *0.3;\n    float causticMask = pow(fbm.x, 10.0);\n    col.xyz += causticMask;\n;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WllSR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WllSRM", "name": "[TWITCH] Sausage powered turbine", "author": "evvvvil", "description": "\"Sausage powered turbine\" - Shader showdown practice session 014.\nLive coded on Twitch with 25 minutes time limit.\nPracticing live on TWITCH every Tuesdays around 21:00 UK time.\nhttps://www.twitch.tv/evvvvil_", "tags": ["time", "demoscene", "abstract", "glow", "mechanic", "limit", "live", "battle", "shadershowdown", "turbine", "gloss", "industrial", "twitch", "sausage"], "likes": 6, "viewed": 531, "date": "1562434247", "time_retrieved": "2024-06-20T19:40:58.493535", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\"Sausage-powered turbine\" - Shader Showdown practice session 014\n\n// The \"Shader Showdown\" is a demoscene live-coding shader battle competition.\n// 2 coders battle for 25 minutes making a shader from memory on stage. \n// The audience votes for the winner by making noise or by voting on their phone.\n// Live coding shader software used is BONZOMATIC https://github.com/Gargaj/Bonzomatic\n\n// Every tuesdays around 21:00 UK time I practise live on TWITCH.\n\n// COME SEE LIVE CODING EVERY TUESDAYS HERE: https://www.twitch.tv/evvvvil_\n\n// evvvvil / DESiRE demogroup\n\n// \"Prodigal? Fuck that, nautical. Teachin' bitches how to swim\" - Death Grips \n\nvec2 s,e=vec2(.00035,-.00035);float t,tt,g1,g2,sig=1.,b;vec3 np,bp,cp,dp;//Some fucking globals, about as exciting as the tory leadership contest\nfloat bo(vec3 p,vec3 r){vec3 q=abs(p)-r;return max(max(q.x,q.y),q.z);}//box function stolen from UNC because UNC knows best how GPU really feel inside\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} //Simple rotate function, small and useful, like a midget in an elevator shaft\nvec2 fb(vec3 p,float s)\t//Fucking bits function which makes the fucking bit/piece it is a base shape which we clone and repeat to create the whole geometry in mp function\n{\n  vec2 h,t=vec2(bo(abs(p)-vec3(0,0,2),vec3(2,0.5,0.5)),6.+s);//Couple of dumb fucking boixes spread out with absolute symetry\n  t.x=max(-bo(abs(p)-vec3(0,0,2),vec3(1.8,0.25,1)),t.x);//Get yer fucking shovels out broskis!\n  t.x=max(-bo(abs(p)-vec3(0,0,2),vec3(1.8,1,0.25)),t.x);//These two lines are just for digging holes... so we can see the yellow bit inside white boxes\n  t.x=min(bo(abs(p)-vec3(2.6,0,0),vec3(0.25,0.25,2)),t.x);//Even dumber white boxes for the other side of piece\n  h=vec2(bo(abs(p)-vec3(2.6,0,2),vec3(0.6)),3.+s);//Now we start a new group of shapes uin the same material id , these are black corner boxes\n  h.x=min(bo(abs(p)-vec3(2.6,0,2),vec3(0.2,8,0.2)),h.x);//And some nice big black poles \n  t=(t.x<h.x)?t:h;//Merge both group of shapes from both material ID into one single geometrical coloured orgy\n  h=vec2(bo(abs(p)-vec3(0,0,2),vec3(2,0.15,0.15)),5.+s);//Bring in the neon fucking  lights, because everybody loves a glow, even your weird and miserable uncle\n  g2+=0.1/(0.1+h.x*h.x*10.);//This is glow trick by Balkhan, pass the distance field of shape into a float variable and add to colour at the end with multiplkier, see last few lines\n  t=(t.x<h.x)?t:h;//Another geometry fucking merger, it's a geomtry orgy I tell you, grab a dildo and go down the red tunnel.\n  return t;\n}\nvec2 mp( vec3 p ) //This is the main MAP function where all geometry is made/defined. It's centre stage broski, bit like a drunken Trappist monk at an AA meeting\n{\n  np=bp=cp=dp=p;//Yeah i know, fucking ludicrous, but hey creating loads of new positions for each different inner an doutter bits\n  np.xz*=r2(-tt*0.2);//They all will rotate alternately in the opposite direction, This is where we rotate one way...\n  bp.xz*=r2(tt*0.2);//...or another. It's like being drunk but while retaining your handsome charm. Well I fucking do anyways, you guys need to either: drink more or be more handsome.\n  for(int i=0;i<5;i++){//Technique is to create more complex positions and pass them to fucking bit function fb, there fore taking imsple piece and making lots of geometry from it\n    np=abs(np)-vec3(2.3+(6.-float(i)*2.4),3,4.2);//So we have a loop and in the loop we push apart positions with abs symstery and rotate a bit, making it more interesting\n    np.xz*=r2(.3925);//a bit of rotate won't hurt you little fucker.\n    bp=abs(bp)-vec3(4,4,3.9);//Bp is for outter bit of scene which rotate the other way\n    bp.xz*=r2(.3925);//Yeah, nah rotate won't hurt you either, bitch.\n  }\n  vec2 h,t=fb(np,0.);//Here passs along to fb the new position np, to create more complex geometry based on simple piece in fb\n  t.x=max(t.x,-(length(vec3(p.x,0,p.z))-0.9));//We're removing the inner bit of central rotating piece so we can put a smaller piece inside\n  bp.yz*=r2(0.785);bp=abs(bp*0.5-1.)-vec3(4.5);//We tweak bp: rotate it all 90 degree to change it look compare to central piece and makie it more interesting and we abs symetry it to push it out\n  h=fb(bp,10.);//Here we pass the next new position bp to the fb function again reusing simple piece but this time looks way different, it's an interesting technique, I'm not just some antagonistic wanker, broh.\n  t=(t.x<h.x)?t:h;//We merge central main piece and outter bits\n  cp.y=mod(cp.y,10.)-5.;//Now we create the central inner bits with simple version of fb but repeated on y axis also twisted and rotated\n  cp.xz*=r2(sin(p.y*0.4)*0.4+tt*2.);//here we twist and rotate the central inner piece  along the Y axis\n  h=fb(cp,20.);h.x*=0.7;//Once again we create now the central inner piece by passing the new position above cp\n  t=(t.x<h.x)?t:h;//Merge the whole scene with the new central inner bits\n  dp.y=0.;dp.xz*=r2(sin(p.y*0.5)*0.5-tt*5.);//Final piece of puzzle is simple pseudo transparent spinning tall white box\n  h=vec2(bo(dp,vec3(0.5)+sin(p.y*0.5+tt*5.)*.2),30);//We create new position dp which simply has twist and rotat eon y axis in similar way we did inner bits but it rotate the other way\n  g1+=0.1/(0.1+h.x*h.x*10.);//We pass the result of tall spinnig white box to a varible to make glow effect later, see last few lines. Distance glow made by Balkhan, thankx to him.\n  t=(t.x<h.x)?t:h;//merge all that shit up again.\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd )\n{\n  vec2 h,t=vec2(0.1);//Near plane because when you're young you're always naive and we ain't got time for that shit here\n  for(int i=0;i<128;i++){//Main loop de loop \n    h=mp(ro+rd*t.x);//Marching forward like any good fascist army: without any care for culture theft\n      if(h.x<.0001*sig||t.x>70.) {\n      if(h.y<30.) break;//Very naive and brutal material based pseudo \"transparency\"\n        t.x+=0.5;//If material id is over 29 then we push ray forward and keep going, wishing for the best \n        continue;//Brutal but only very short amount of code but kinda works. It's good for shadershowdown as very short.\n      }\n      t.x+=h.x;t.y=h.y;//Push forward, remember material id. This is where we pass material ID so we can color it after\n  }  \n  return t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);//boilerplate code to get uvs in BONZOMATIC live coding software i use.\n    \n    tt=mod(iTime,62.83);//Time variable is modulo'ed to avoid ugly artifact. Float precision and all that shit, this should solve that. Not very glamourous but, neither are you.\n    b=sin(tt*0.2-0.5)*39.;//Camera animation variable\n    vec3 ro=vec3(cos(tt*0.1)*b-2.,4.1,sin(tt*0.1)*b+2.),//Ro=ray origin=camera position because everything is relative to a view point, even mothers lying to their sons about being handsome\n    cw=normalize(vec3(0)-ro),\n    cu=normalize(cross(cw,vec3(cos(tt*0.2-0.5),1,0))),//Oh yeah nice little roation along the z axis to giv eit that nice nauseous camera feel \n    cv=normalize(cross(cu,cw)),\n    rd=mat3(cu,cv,cw)*normalize(vec3(uv,0.5)),co,fo,//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n    ld=normalize(vec3(0.3,0.5,-0.5));//ld=light direction\n    co=fo=vec3(0,.1,.2)-rd.y*0.3+vec3(0.5)*(1.-(length(uv)-0.2));//By default the bakcground and fog colour is subtle gradient on y axis and a subtle vignette. Not everything has to be hardcore broh.\n    s=tr(ro,rd);t=s.x;//This is where we shoot the fucking rays to get the fucking scene. Like a 19th century french painter but withouth the absinth addiction and more gpu power\n\n    if(t>0.){//If t>0 then we must have hit some geometry so let's fucking shade it. \n        //We hit some geometry so let's get the current position (po) and build some normals (no). You do the Maths while I reload this vaporizer.\n        vec3 po=ro+rd*t,no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x),\n        \n        //LIGHTING MICRO ENGINE BROSKI \n        al=vec3(1,0.5,0.);//al = Albedo = base colour.        \n        //Change colour depending on material id, it's like art school but with the pretentious post-modern essays justifying the lack of technique\n        if(s.y<5.) al=vec3(0);//albedo is black with material ID less 5\n        if(s.y>5.) al=vec3(1);//albedo becomes white with material Id above 5\n        //Messy i know but i typed that shit fast and i can copy and paste it easy, so yeah, who gives a shit\n        float spo=exp2(10.*texture(iChannel0,vec2(np.x,dot(np.yz,vec2(0.5)))/vec2(6,10)).r);//TRICK nice pseudo triplanar uv mapping in one line by nusan_fx! Thankx NUSAN wicked!\n    \t//More on the above: it creates a nice gloss map as spo is \"specular power\", its not used in albedo or diffuse please note so purely gloss map \n        if(s.y<5.) al=vec3(0);//albedo is black with material ID less 5\n        if(s.y>5.) al=vec3(1);//albedo becomes white with material Id above 5\n    \tif(s.y>10.) spo=exp2(10.*texture(iChannel0,vec2(bp.x,dot(bp.yz,vec2(0.5)))/vec2(6,10)).r);//We have to recalculate the gloss map for outter bits as uv are based on np and outter is based on bp\n    \tif(s.y<15.&&s.y>6.)al=vec3(0);//More from above: Hence why the material ID mess we're in at this point, but remember this is typed in 25 minutes and it can easily be copied and pasted so it is badily designed for that fast typing purpose\n    \tif(s.y>20.) spo=exp2(10.*texture(iChannel0,vec2(cp.x,dot(cp.yz,vec2(0.5)))/vec2(6,10)).r);//Again we have to recalculate the gloss map as it's based on np and the centrall inner bits are made with cp, otherwise texture will slide\n    \tif(s.y<25.&&s.y>16.)al=vec3(0);//I know lame it means i have to redefine black and white material again and again but remember it is fast to copy and paste and type. Stop giving me shit anyways, make your own fucking shader hahaha.\n    \n        float dif=max(0.,dot(no,ld)),//dif=diffuse because i ain't got time to cook torrance\n        fr=pow(1.+dot(no,rd),4.),//Nice fresnel to blend geometry in background with background reflections\n        aor=t/50.,ao=exp2(-2.*pow(max(0.,1.-mp(po+no*aor).x/aor),2.)),//aor=ambient occlusion range, ao = ambient occlusion\n        sss=smoothstep(0.,1.,mp(po+ld*0.4).x/0.4),//sss=subsurface scatterring made by tekf from the wax shader, big up tekf! https://www.shadertoy.com/view/lslXRj\n        sp=.5*pow(max(dot(reflect(-ld,no),-rd),0.),spo);//Sp=specualr, sotlen from Shane.\n        co=mix(sp+al*(.8*ao+0.2)*(dif+sss),fo,min(fr,.5));//Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n        co=mix(co,fo,1.-exp(-.00003*t*t*t));//Fog soften things, but it won't save you against your addictions, \"dishipline\" will.\n    }//We add glow at the end with co+g1*0.07 also a yellow coloured glow with vec3(1,0.5,0)*g2*0.05\n  \tco+=g1*0.07+vec3(1,0.5,0)*g2*0.05;//simple distance based glow where we take the result of any shape and add it to g then at end add to co. Trick is from Balkhan thankx to him again.\n    fragColor = vec4(pow(co+g1*0.03,vec3(0.45)),1);//Cheap tone mapping, even cheaper than your taste in interior design.\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WllSRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WllSz2", "name": "Mod Experiments", "author": "Veggiebob", "description": "experimenting with mod() on sdf", "tags": ["sphere", "mod", "rotation"], "likes": 4, "viewed": 219, "date": "1563575059", "time_retrieved": "2024-06-20T19:40:59.911797", "image_code": "#define MAX_RERAY 5\n#define HIT_THRESHOLD 0.01\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n    float intensity;\n};\nstruct Material {\n    vec3 color;\n    float diffuse;\n    float specular;\n    float reflection;\n    int pi;//portal index\n};\nstruct SDF {\n    Material mat;\n    float d;\n};\nstruct Ray {\n    vec3 end;\n    int steps;\n    float d;\n    SDF sdf;\n};\nstruct Portal {\n\tvec3 start;\n\tvec2 rot;\n    int endPortal;//integer index of the ending portal\n    int filled;//1 if filled, 0 if empty\n    vec3 color;//color tint of portal\n};\n//ree kill the spacing\nconst int numLights = 1;\nconst Light lights[numLights] = Light[](\n    Light(vec3(-1., 1., 1.), vec3(1.), 1.0)\n    //Light(vec3(2., -1., 0.), vec3(1.), 1.0)\n);\n//portal definitions\nconst int numPortals = 2;\nconst Portal portals[numPortals] = Portal[](\n    //vec3 start, vec2 rot, int endPortalIndex, int filled, vec3 color\n\t//Portal(vec3(-1.5, -0.7, 1.), vec2(0., 0.), 1, 1, vec3(0.5, 0.3, 0.)),//orange portal\n    //Portal(vec3(1.5, 1., -1.), vec2(0., 0.), 0, 1, vec3(0., 0.3, 0.5))//blue portal\n    Portal(vec3(-1.5, 0., -1.), vec2(0., 0.), 1, 1, vec3(0.0, 0.8, 0.0)),//green portal\n    Portal(vec3(1.5, 0., -1.), vec2(0., 0.), 0, 1, vec3(0.9, 0.5, 0.5))//pink portal\n);\n//color, diffuse, specular, reflection, portal index\nconst Material def = Material(vec3(1.0, 1.0, 1.0), 0.8, 0.5, 0.0, -1);//default material\nconst Material soft = Material(vec3(1.0), 0.8, 0.0, 0.0, -1);\nconst Material showLight = Material(vec3(0.), 1.0, 1.0, 0.0, -1);//for showing lights\nconst Material object = Material(vec3(1.0, 1.0, 0.5), 0.8, 0.4, 0.0, -1);\nconst Material mirror = Material(vec3(1.0), 0.5, 0.0, 0.5, -1);//mirror\nconst Material portal = Material(vec3(1.), 0.0, 1.5, -1., 0);//portal\n//from https://github.com/hughsk/glsl-hsv2rgb/blob/master/index.glsl\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n//yay (I made this myself)\nvec2 rotate2D (vec2 p, float angle){\n    return vec2(p.x*cos(angle)-p.y*sin(angle), p.y*cos(angle)+p.x*sin(angle));\\\n}\nfloat rand (float r) {\n    return 0.5+0.5*sin(1234.+pow(r, 4.));\n}\nvec3 rand3 (vec3 r) {\n    return vec3(rand(r.x), rand(r.y), rand(r.z));\n}\n//from https://www.shadertoy.com/view/Ml3SR8\nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, .999, 0.0)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    return mat3(r, u, f);\n}\nfloat sq (float x) { return x*x; }\nvec2 sq (vec2 v) { return v*v; }\n//vec2 pow (vec2 v, float p) { return vec2(pow(v.x, p), pow(v.y, p)); }\n//pretty proud of this one\n//maps a 2d texture onto 3d surfaces using the normal and the position of the node\n//not exact but works for all surfaces\nvec2 getTexPos (vec3 p, vec3 n) {\n    //return sqrt(sq(p.xz*n.y) + sq(p.xy*n.z) + sq(p.yz*n.x));\n    return ((p.xz*n.y) + (p.xy*n.z) + (p.yz*n.x));\n}\n//thanks IQ https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat sdSphere (vec3 p, float r) {\n    return length(p)-r;\n}\nSDF portalSDF (vec3 p, int PI) {///// portal sdf\n    vec2 pa = p.xy;\n    p.x = pa.y;\n    p.y = pa.x;\n    float sd = sdSphere(p, 0.4);//sdRoundedCylinder(p, 0.2, 0.05, 0.0);\n    Material pp = portal;\n    pp.pi = PI;\n    return SDF(pp, sd);\n}\nSDF lightSDF (vec3 p, vec3 pp) {\n    return SDF(showLight, length(pp-p)-0.1);\n}\nSDF ground (vec3 p, float h) {\n    return SDF(soft, p.y-h);\n}\nSDF ground (vec3 p, float h, float thickness) {\n    float freq = 3.;\n    float displace = sin(p.x*freq)*sin(p.x*freq)*cos(p.z*freq)*cos(p.z*freq)*0.8;\n    return SDF(soft, abs(p.y-h)-thickness*displace);\n}\nSDF sphere (vec3 p, float r) {\n    return SDF(object, length(p)-r);\n}\n//thanks to IQ for the box sdf function\nSDF box (vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n\treturn SDF(def, length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0));\n}\nSDF room (vec3 p, vec3 b) {\n    return SDF(soft, -box(p, b).d);\n}\nSDF sdfADD (SDF a, SDF b) {\n    if(a.d<b.d) {\n        return a;\n    } else {\n        return b;\n    }\n}\nSDF sdf (vec3 p) {\n    float angle = atan(p.x, p.z);\n    float d = length(p.xz);\n    float sides = 6.;\n    float pi = 3.14159;\n    float slice = 2.*pi/sides;\n    float i = floor(angle/slice);\n    float mangle = mod(angle, slice);\n    float dist = 1.+cos(iTime);\n    float my = mod(p.y+sin(iTime+i*i), 1.0)-0.5;\n    vec3 np = vec3(cos(mangle)*d, my, sin(mangle)*d);\n    \n    SDF s = \n        sphere(np-dist*vec3(cos(slice/2.), 0., sin(slice/2.)), 0.3);\n    s.mat.color = hsv2rgb(vec3(sin(my*2.+angle), 1., 1.));\n    //show the lights (dev)\n    /*\n    for(int i = 0; i<numLights; i++) {\n        s = sdfADD(s, lightSDF(p, lights[i].position));\n    }\n*/\n    return s;\n}\nRay trace (vec3 o, vec3 r, int reray) {\n    vec3 p = vec3(0.0, 0.0, 0.0);\n    SDF s = SDF(def, 10000.);\n    float t = 0.;\n    int steps = 0;\n    for(int i = 0; i<128; i++) {\n        p = o+r*t;\n        s = sdf(p);\n        t+=s.d*0.5;\n        //curve of light around portals\n        if(s.mat.reflection<0.&&s.d>0.&&reray==0) {\n            vec3 ppos = portals[s.mat.pi].start;\n            vec3 bend = normalize(p-ppos);\n            //interpolate\n            float x = length(p-ppos);\n            \n            float bend_amount = sin(pow(0.5, x*10.-1.651)) * (1.-max(0.0,dot(p-o, p-ppos))) * 0.01;\n            r = normalize(mix(r, bend, bend_amount));\n        }\n\t\t\n        if(s.d<HIT_THRESHOLD){\n            steps = i;\n            break;\n        }\n        if(t>10.0) {\n            steps = i;\n            t = 1000.;\n        \tbreak;\n        }\n    }\n    return Ray(p, steps, t, s);\n}\nconst float E = 0.0001;\nvec3 estimateNormal (vec3 p) {\n    return normalize(vec3(\n        sdf(vec3(p.x+E, p.y, p.z)).d-sdf(vec3(p.x-E, p.y, p.z)).d,\n        sdf(vec3(p.x, p.y+E, p.z)).d-sdf(vec3(p.x, p.y-E, p.z)).d,\n        sdf(vec3(p.x, p.y, p.z+E)).d-sdf(vec3(p.x, p.y, p.z-E)).d\n    ));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse-=0.5;\n    uv.x-=iResolution.x/iResolution.y/2.;\n    uv.y-=0.5;\n    uv*=2.0;\n    float perspective = 0.8;\n    float time = iTime*0.5;\n    vec3 cam = vec3(0., 0., -4.);\n    cam.xz*=0.8;\n    vec3 ray = normalize(vec3(uv.x*perspective, uv.y*perspective, 1.0));\n    cam.zy = rotate2D(cam.zy, mouse.y*5.0);\n    ray.zy = rotate2D(ray.zy, mouse.y*5.0);\n    \n    cam.xz = rotate2D(cam.xz, -mouse.x*10.0);\n    ray.xz = rotate2D(ray.xz, -mouse.x*10.0);\n    vec3 col = vec3(0.);\n    \n    float ambient = 0.3;\n    Material m;\n    Material pm;\n    for(int times = 0; times<MAX_RERAY; times++) {//max reflections or teleportations\n        Ray t = trace(cam, ray, times);\n        m = t.sdf.mat;//the material\n        vec3 norm = estimateNormal(t.end);\n        vec3 tcol = m.color*ambient;\n        vec3 refl = reflect(normalize(ray), norm);\n        //calculate light intensity at the point for each light\n        for(int i = 0; i<numLights; i++) {\n            Light l = lights[i];\n            vec3 toLight = normalize(l.position-t.end);\n            float diffuse = max(0.0, dot(toLight, norm)*m.diffuse);\n            float specular = pow(max(0.0, dot(refl, toLight)), 16.0)*m.specular;\n            \n            float lightAmount = diffuse+specular;//intensity of light. Default is (diffuse+specular)\n            tcol += (1.-ambient)*m.color*l.intensity*l.color*lightAmount;// /float(numLights)\n        }\n        tcol -= float(t.steps)*float(t.steps)*0.00004;//ao\n        float fog = 1.0 / (1.0 + t.d*t.d*0.05);\n        tcol*=fog;\n        if(m.reflection>0.0&&times<MAX_RERAY-1) {\n            ray = refl;\n            //ray = normalize(ray + 0.5*ray*texture(iChannel0, t.end).xyz);//add distortion\n            //ray = normalize(ray + 0.5*ray*rand3(t.end*4.));//add distortion\n            cam = t.end + ray*HIT_THRESHOLD;\n            col += tcol*(1.-m.reflection);\n            /*\n            for(int reach = 0; reach<16; reach++) {\n                SDF s = sdf(cam);\n                if(s.d<=HIT_THRESHOLD*20.) {\n                    cam += ray*0.08;//(HIT_THRESHOLD-s.d)*40.;\n                } else {\n                    break;\n                }\n            }\n\t\t\t*/\n        } else if (m.reflection<0.) {//signifies a portal\n            Portal por = portals[m.pi];//in portal\n            Portal OUT = portals[por.endPortal];//out portal\n            col += tcol*0.0 + 0.4*por.color*pow(1.7-dot(normalize(cam-t.end), norm), 8.);//add portal glow\n            vec3 off = t.end-por.start;//offset from the original portal\n            cam = OUT.start+off;//specify the new starting position after portal\n            float sdd = t.sdf.d;\n            ray = normalize(mix(ray, -norm, 0.0));\n            for(int reach = 0; reach<20; reach++) {//leave the portal region sdf\n                SDF s = sdf(cam);\n                if(s.d<=HIT_THRESHOLD) {\n                    cam += ray*0.2;\n                } else {\n                    break;\n                }\n            }\n        } else {\n            //tcol *= texture(iChannel1, getTexPos(t.end, norm)*0.1).r;//texture everything\n            if(pm.reflection>0.0) {\n            \tcol = col*(1.-pm.reflection) + tcol*(pm.reflection);\n            } else {\n                col += tcol;\n            }\n            break;\n        }\n        pm = m;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WllSz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wllSzj", "name": "Into the Spider-verse", "author": "jcward", "description": "Somebody's been watching Into the Spider-verse...", "tags": ["dof", "polkadots"], "likes": 3, "viewed": 209, "date": "1563601642", "time_retrieved": "2024-06-20T19:41:00.226850", "image_code": "mat2 xform(float t)\n{\n    // Some transform stuff from: https://www.shadertoy.com/view/XtXfDS\n    float omega = 0.3 * sin(t * 0.37) * sin(t * 0.3);\n    float coshOmega = cosh(omega), sinhOmega = sinh(omega);\n    return mat2(coshOmega, sinhOmega, sin(t * 0.7)*sinhOmega, (1.0+0.2*cos(t * 0.5))*coshOmega);\n}\n\nfloat dot_at_pos_time(vec2 uv, float t)\n{\n\tuv = xform(t) * uv;\n\n    float at_x = smoothstep(0.0, abs(cos(50.0*uv.x)), 0.57);\n    float at_y = smoothstep(0.0, abs(cos(30.0*uv.y)), 0.57);\n\n    float at_x1 = smoothstep(0.0, abs(sin(50.0*uv.x)), 0.57);\n    float at_y1 = smoothstep(0.0, abs(sin(30.0*uv.y)), 0.57);\n\n\t// Simply Y-axis \"blur\" (simply adjusting the tightness of the smoothstep)\n    float blur = abs((uv.y-0.25)*0.5);\n\n    float col = clamp(smoothstep(0.48-blur, 0.48, at_x*at_y), 0.0 ,1.0);\n    float col1 = clamp(smoothstep(0.48-blur, 0.48, at_x1*at_y1), 0.0 ,1.0);\n\n    // Output to screen\n    float c = 0.95*col*col1;\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.x -= 0.5;\n\tuv.y -= 0.2;\n\n    float omega = 0.3 * sin(iTime * 0.37) * sin(iTime * 0.3);\n    float dx = 0.004*cos(2.0*omega);\n    float dy = 0.004*sin(2.0*omega);\n\n    // Balck, red, and blue dots\n    float blk = 0.4 + 0.6*dot_at_pos_time(uv, 3.0*iTime);\n    float b = dot_at_pos_time(vec2(uv.x-dx, uv.y-dy), 3.0*iTime + 0.04);\n    float r = dot_at_pos_time(vec2(uv.x+dx, uv.y+dy), 3.0*iTime - 0.04);\n\n    r *= 0.7*(uv.x+0.65);\n    b *= 0.7*(uv.y+0.5);\n    \n    fragColor = vec4(b*blk, r*blk*b, r*blk, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wllSzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wllSzN", "name": " GPU hacks #12 - DX11 Pixel Sh.", "author": "PrzemyslawZaworski", "description": "Comment contains DirectX 11 framework for vertex and pixel shaders - with working example, visually equivalent to visible shader.", "tags": ["framework", "lighting", "code", "science", "directx"], "likes": 7, "viewed": 345, "date": "1562320416", "time_retrieved": "2024-06-20T19:41:01.069403", "image_code": "/*\nCode tested with Windows 10 and RTX 2070.\nSave file as lights.c and compile with Visual Studio command line:\ncl.exe lights.c d3d11.lib dxguid.lib user32.lib kernel32.lib gdi32.lib d3dcompiler.lib\n*/\n\n/*\n#include <Windows.h>\n#include <d3d11.h>\n#include <d3dcompiler.h>\n\n#define WIDTH 1280 \n#define HEIGHT 720\n\nconst unsigned char VertexShader[] =\n{\n\t\"static const float3 vertices[6] = {float3(1,-1,0),float3(-1,-1,0),float3(1,1,0), float3(-1,-1,0),float3(-1,1,0),float3(1,1,0)};\"\n\t\"static const float2 uvs[6] = {float2(1,0),float2(0,0),float2(1,1), float2(0,0),float2(0,1),float2(1,1)};\"\n\t\"void VSMain(out float4 vertex:SV_POSITION, out float2 uv:TEXCOORD0, in uint id:SV_VertexID)\"\n\t\"{\"\t\n\t\t\"uv = uvs[id];\"\n\t\t\"vertex = float4(vertices[id], 1);\"\n\t\"}\"\n};\n\nconst unsigned char PixelShader[] =\n{\n\t\"cbuffer Constants : register(b0)\"\n\t\"{\"\n\t\t\"float iTime;\"\n\t\"};\"\n\t\"float3 surface (float2 uv)\"\n\t\"{\"\n\t\t\"float2 k = 0;\"\n\t\t\"for (float i=0.0;i<64.0;i++)\"\n\t\t\"{\"\n\t\t\t\"float2 q = float2(i*127.1+i*311.7,i*269.5+i*183.3);\"\n\t\t\t\"float2 h = frac(sin(q)*43758.5453);\"\n\t\t\t\"float2 p = cos(h*iTime);\"\n\t\t\t\"float d = length(uv-p);\"\n\t\t\t\"k+=(1.0-step(0.06,d))*h;\"\n\t\t\"}\"\n\t\t\"return float3(0.0,k);\"\n\t\"}\"\t\n\t\"float4 PSMain(float4 vertex:SV_POSITION, float2 uv:TEXCOORD0) : SV_TARGET\"\n\t\"{\"\t\n\t\t\"float2 p = float2(2.0*uv-1.0)/(1.0-uv.y);\"\n\t\t\"float3 c = 0;\"\n\t\t\"float2 d = (float2(0.0,-1.0)-p)/float(80);\"\n\t\t\"float w = 1.0;\"\n\t\t\"float2 s = p;\"\n\t\t\"for( int i=0; i<80; i++ )\"\n\t\t\"{\"\n\t\t\t\"float3 res = surface(s);\"\n\t\t\t\"c += w*smoothstep(0.0, 1.0, res);\"\n\t\t\t\"w *= 0.97;\"\n\t\t\t\"s += d;\"\n\t\t\"}\"\n\t\t\"c = c * 8.0 / float(80);\"\n\t\t\"return float4(c, 1.0);\"\n\t\"}\"\n};\n\nstatic LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\n{\n\tif ((uMsg == WM_KEYUP && wParam == VK_ESCAPE) || uMsg==WM_CLOSE || uMsg==WM_DESTROY)\n\t{\n\t\tPostQuitMessage(0); return 0;\n\t}\n\telse\n\t{\n\t\treturn DefWindowProc(hWnd, uMsg, wParam, lParam);\n\t}\n}\n\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)\n{\n\tint exit = 0;\n\tMSG msg;\n\tWNDCLASS win = {CS_OWNDC|CS_HREDRAW|CS_VREDRAW, WindowProc, 0, 0, 0, 0, 0, (HBRUSH)(COLOR_WINDOW+1), 0, \"DirectX 11\"};\n\tRegisterClass(&win);\n\tHWND hwnd = CreateWindowEx(0, win.lpszClassName, \"DirectX 11\", WS_VISIBLE|WS_OVERLAPPEDWINDOW, 0, 0, WIDTH, HEIGHT, 0, 0, 0, 0);\t\n\tID3D11Device *device;\n\tIDXGISwapChain *surface;\n\tID3D11DeviceContext *context;     \n\tID3D11Resource *image;\t\n\tID3D11RenderTargetView *target;\n\tID3D11VertexShader *vs;\n\tID3D11PixelShader *ps;\n\tID3DBlob* VSblob;\n\tID3DBlob* PSblob;\t\n\tID3D11Buffer *buffer; \n\tD3D11_MAPPED_SUBRESOURCE resource;\n\tDXGI_SWAP_CHAIN_DESC sd = {{WIDTH, HEIGHT, 0, 0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, 0 }, {1, 0}, (1L << (1 + 4)) | (1L << (6 + 4)) | (1L << (0 + 4)), 1, hwnd, 1, 1, 0};\n\tD3D11CreateDeviceAndSwapChain(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, 0, 0, D3D11_SDK_VERSION, &sd, &surface, &device, 0, &context); \t\n\tsurface->lpVtbl->GetBuffer(surface, 0, (REFIID) &IID_ID3D11Resource, ( LPVOID* )&image );\n\tD3D11_BUFFER_DESC desc = {16, D3D11_USAGE_DYNAMIC, D3D11_BIND_CONSTANT_BUFFER, D3D11_CPU_ACCESS_WRITE, 0, 0};\t\n\tdevice->lpVtbl->CreateBuffer(device, &desc, 0, &buffer);\n\tdevice->lpVtbl->CreateRenderTargetView(device, image, 0, &target);\n\tcontext->lpVtbl->OMSetRenderTargets(context,1, &target, 0);\n\tD3D11_VIEWPORT vp = {0,0,WIDTH,HEIGHT,0.0f,1.0f};\n\tcontext->lpVtbl->RSSetViewports(context,1, &vp);\n\tD3DCompile(&VertexShader, sizeof VertexShader, 0, 0, 0, \"VSMain\", \"vs_5_0\", 1 << 15, 0, &VSblob, 0);\t\t\n\tdevice->lpVtbl->CreateVertexShader(device, VSblob->lpVtbl->GetBufferPointer(VSblob), VSblob->lpVtbl->GetBufferSize(VSblob), 0, &vs);\n\tD3DCompile(&PixelShader, sizeof PixelShader, 0, 0, 0, \"PSMain\", \"ps_5_0\", 1 << 15, 0, &PSblob, 0);\t\t\n\tdevice->lpVtbl->CreatePixelShader(device, PSblob->lpVtbl->GetBufferPointer(PSblob), PSblob->lpVtbl->GetBufferSize(PSblob), 0, &ps);\t\n\tcontext->lpVtbl->IASetPrimitiveTopology(context,D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);\n\twhile (!exit)\n\t{\n\t\twhile (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))\n\t\t{\n\t\t\tif (msg.message == WM_QUIT) exit = 1;\n\t\t\tTranslateMessage(&msg);\n\t\t\tDispatchMessage(&msg);\n\t\t}\n\t\tcontext->lpVtbl->Map(context,(ID3D11Resource*)buffer, 0, D3D11_MAP_WRITE_DISCARD, 0,  &resource);\n\t\tfloat time[] = {GetTickCount() * 0.001f};\n\t\tmemcpy(resource.pData, time, sizeof(float));\t\t\n\t\tcontext->lpVtbl->Unmap(context, (ID3D11Resource *)buffer, 0);\t\t\t\n\t\tcontext->lpVtbl->VSSetShader(context, vs, 0, 0 );\n\t\tcontext->lpVtbl->PSSetShader(context, ps, 0, 0 );\n\t\tcontext->lpVtbl->PSSetConstantBuffers(context, 0, 1, &buffer );\t\n\t\tcontext->lpVtbl->Draw(context, 6, 0);\t\t\n\t\tsurface->lpVtbl->Present(surface, 0, 0 );\n\t}\n\treturn 0;\n}\n*/\n\nvec3 surface (vec2 uv)\n{\n    vec2 k = vec2(0.0,0.0); \n\tfor (float i=0.0;i<64.0;i++)\n\t{\n\t\tvec2 q = vec2(i*127.1+i*311.7,i*269.5+i*183.3);\n\t\tvec2 h = fract(sin(q)*43758.5453);\n\t\tvec2 p = cos(h*iTime+1.0);\n\t\tfloat d = length(uv-p);\n\t\tk+=(1.0-step(0.06,d))*h;\n\t}\n\treturn vec3(0.0,k.x,k.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.0 * uv-1.0) / (1.0-uv.y) ;  \n    vec3 c = vec3(0.0,0.0,0.0);\n    vec2 d = (vec2(0.0,-1.0)-p)/float(80);\n    float w = 1.0;\n    vec2 s = p;\n    for( int i=0; i<80; i++ )\n    {\n        vec3 res = surface(s);\n        c += w*smoothstep( 0.0, 1.0, res );\n        w *= .97;\n        s += d;\n    }\n    c = c * 0.12;\n\tfragColor = vec4( c,1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wllSzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wllXDM", "name": "foldable cube", "author": "ShnitzelKiller", "description": "Test of using randomly perturbed step length to \"dither\" the iteration fog on a fractal.", "tags": ["fractal", "cube", "fold"], "likes": 20, "viewed": 436, "date": "1563393724", "time_retrieved": "2024-06-20T19:41:01.069403", "image_code": "\n#define ITERS 100\n#define TOL 1e-3\n#define fdist 0.5\n#define maxdist 100.\n#define LEVELS 7\n#define PI 3.1415926\n\nfloat noise(in vec2 uv)\n{\n\treturn fract(sin(dot(vec2(1484191., 189159.), uv))*9991415.);   \n}\n\nvec4 map(in vec3 pos)   \n{\n    float t = (clamp(abs(mod(iTime*0.25, 6.0) - 3.0), 1.0, 2.0)-1.0) * PI * 0.5;\n    if (iMouse.w > 1.0)\n    {\n    \tt = iMouse.y/iResolution.y*PI*0.5;\n    }\n    float c = cos(t);\n    float s = sin(t);\n    mat3 rotZ = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    mat3 rotX = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    float sc = 0.5;\n    for (int i=0; i<LEVELS; i++)\n    {\n        pos = abs(rotX * rotZ * pos) - sc;\n     \tsc *= 0.5;\n    }\n    \n    return vec4(max(pos.x, max(pos.y, pos.z))-sc*2., pos);\n}\n\nvec4 march(in vec3 pos, in vec3 dir, in vec2 seed)\n{\n    float t = 0.;\n    vec4 dist;\n    for (int i=0; i<ITERS; i++)\n    {\n        vec3 currpos = t*dir+pos;\n    \tdist = map(currpos);\n        t += dist.x * (1.+(noise(seed)-0.5)*0.5);\n        seed.x += dist.x;\n        if (abs(dist.x) < TOL)\n        {\n            return vec4(i, dist.yzw);\n        } else if (t > maxdist) {\n            return vec4(i, dist.yzw);\n        }\n    }\n    return vec4(ITERS, dist.yzw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float c = cos(iTime);\n    float s = sin(iTime);\n    mat3 rot = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.x;\n    vec3 ro = rot * vec3(1.,1.,1.) * (2.+s*0.3);\n    vec3 nw = -normalize(ro);\n    vec3 up = vec3(0.,0.,1.);\n    vec3 nu = cross(nw, up);\n    vec3 nv = cross(nu, nw);\n   \tvec3 rd = normalize(nw*fdist + uv.x*nu + uv.y*nv);\n    vec4 d = march(ro, rd, uv);\n    fragColor = vec4(d.x/float(ITERS)*2. * (normalize(d.yzw)+1.)*0.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wllXDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wllXR2", "name": "Moving Tri-Gradient", "author": "ComposingCoder", "description": "3 different gradients that are changing with iTime", "tags": ["gradient", "itime"], "likes": 2, "viewed": 260, "date": "1563612955", "time_retrieved": "2024-06-20T19:41:01.069403", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 texColor = texture(iChannel0, uv);\n    texColor.b = ((texColor.b / 2.0) + (1.0 - ((uv.x + uv.y) /2.0))) * abs(sin(iTime));\n    texColor.r = ((texColor.r / 2.0) + (uv.x + uv.y) /2.0) * abs(cos(iTime));\n    texColor.g = ((texColor.g / 2.0) + ((uv.x - uv.y)* 2.0)) * abs(sin(iTime)) * cos(iTime);\n    \n\n    // Output to screen\n    fragColor = texColor;\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wllXR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WllXzB", "name": "Brady's Volumetric Fire", "author": "BradyInstead", "description": "Raymarched volumetric fire. Rotate the view with mouse.\n", "tags": ["fire", "volumetric", "raymarcher"], "likes": 22, "viewed": 1025, "date": "1563597713", "time_retrieved": "2024-06-20T19:41:01.930246", "image_code": "/////////////////////////////\n// BRADY'S VOLUMETRIC FIRE //\n/////////////////////////////\n\n// CREDITS\n// Thanks to @shnitzelkiller & @iq for inspiration and help\n// noise: https://github.com/BrianSharpe/Wombat/blob/master/Value3D.glsl\n// saturation: https://github.com/AnalyticalGraphicsInc/cesium/blob/master/Source/Shaders/Builtin/Functions/saturation.glsl\n// fnoise: https://www.shadertoy.com/view/Xsd3R2\n\nfloat noise( vec3 P )\n{\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    vec2 hash_mod = vec2( 1.0 / ( 635.298681 + vec2( Pi.z, Pi_inc1.z ) * 48.500388 ) );\n    vec4 hash_lowz = fract( Pt * hash_mod.xxxx );\n    vec4 hash_highz = fract( Pt * hash_mod.yyyy );\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( hash_lowz, hash_highz, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    return dot( res0, blend2.zxzx * blend2.wwyy );\n}\n\nfloat fnoise(vec3 p, float time)\n{\n    float f = 0.0;\n    p = p - vec3(0.0, 1.0, 0.0) * .5 * time;\n    p = p * 3.0;\n    f += 0.50000 * noise(p); p = 2.0 * p;\n\tf += 0.25000 * noise(p); p = 2.0 * p;\n\tf += 0.12500 * noise(p); p = 2.0 * p;\n\tf += 0.06250 * noise(p); p = 2.0 * p;\n    f += 0.03125 * noise(p);\n    return f;\n}\n\nfloat model( in vec3 p )\n{\n    p.y *= .7;\n    float sphere = length(p)-.8;\n    float res = sphere + fnoise(p*1.5, iTime*3.)* .4;\n    return res*.8;\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd)\n{\n    float dist = 0.;\n    for(int i = 0; i < 30; i++)\n    {\n\t\tfloat m = model(ro+rd*dist);\n        dist += m;\n        \n        if(m < .01) return dist;\n        else if(dist > 2.) break;\n    }\n    return -1.;\n}\n\nvec3 hueShift( vec3 color, float hueAdjust ){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    hue += hueAdjust;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n\n}\n\nvec3 saturation(vec3 rgb, float adjustment)\n{\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    vec3 intensity = vec3(dot(rgb, W));\n    return mix(intensity, rgb, adjustment);\n}\n\nvec3 background(in vec2 p)\n{\n\treturn vec3(0.);\n}\n\nvec3 volume(in vec3 p, in vec3 rd, in vec3 ld, in vec2 sp)\n{\n    vec3 op = p;\n    float trans = 1.0;\n    float td = 0.0;\n    float dif = 0.0;\n    float emit = 0.0;\n    float steps = 30.; // increase to smooth\n    \n    // march\n    for(float i = 0.; i < steps; i++)\n    {\n        float m = model(p);\n        p += rd*.03;\n        \n        float dens = 1.-smoothstep(0., .35, -m);\n        td += dens;\n        trans *= dens;\n        \n        if(td > 1.0 && dif <= 0.)\n        {\n            td = 1.;\n        \tdif = clamp(1. - model(p - .1*ld), 0., 1.);\n            emit = pow(smoothstep(-.3, 0., model(p)), 4.);\n        }\n    }\n    \n    trans = (1.-pow(td/steps, 4.5));\n    trans = smoothstep(0., 1., trans);\n    float emitmod = (emit*trans)*.8+.2;\n    \n    // light\n    vec3 lin = vec3(.3, .2, .9);\n    lin = hueShift(lin, 4.2 + -trans*.6 + dif*.5);\n    lin *= emitmod;\n    \n    // bright/sat/contrast\n    lin = saturation(lin, pow(trans, .5)*.4);\n    lin *= 5.;\n    lin -= vec3(.4);\n    \n    return mix(background(sp), lin, pow(trans, 1.25));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    float rs = .5;\n    vec3 ro = vec3(cos(iMouse.x/100.), 1., sin(iMouse.x/100.))*1.35;\n    vec3 ta = vec3(0., 0.1, .0);\t\t\t\t\n    \n    vec3 w = normalize (ta-ro);\n    vec3 u = normalize (cross (w, vec3(0., 1., 0.)));\n    vec3 v = normalize (cross (u, w));\n    mat3 mat = mat3(u, v, w);\n    vec3 rd = normalize (mat*vec3(p.xy,1.));\n    \n    float dist = raymarch(ro, rd);\n    vec3 ld = vec3(-1., 1., 0.);\n    vec3 col = dist > 0. ? volume(ro+rd*dist, rd, ld, p) : background(p);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WllXzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WllXzl", "name": "Blocky tile", "author": "ParaBellum", "description": "Implementing ambient occlusion in 2d", "tags": ["2d", "light", "ambientocclusion", "tile"], "likes": 7, "viewed": 324, "date": "1563933157", "time_retrieved": "2024-06-20T19:41:01.930246", "image_code": "float r2D(vec2 p)\n{\n    return fract(sin(dot(p, vec2(32.91, 54.28)))*96516.4172);\n}\n\nfloat pattern(vec2 p, float s)\n{\n    vec2 i = floor(p*s);\n    return r2D(i);\n}\n\nvec3 normals(vec2 p, float s, float h)\n{\n    float pixel = 1./iResolution.y;\n    vec2 e = vec2(pixel, 0.);\n    return normalize(\n        vec3(\n            (pattern(p-e.xy, s)-h)/e.x,\n            (pattern(p-e.yx, s)-h)/e.x,\n            1.));\n}\n\n#define samples 16\n#define num_steps 6\n#define PI 3.141592\n#define radius 12.\n\nfloat ambient_occlusion(vec2 p, float h, vec3 n, float s)\n{\n    float ao = 0.;\n    float pixel = 1./iResolution.y;\n    vec3 origin = vec3(p, h);\n    for (int i = 0; i < samples; i++)\n    {\n        float angle = float(i)*PI/float(samples);\n        vec2 dir = vec2(cos(angle), sin(angle));\n        for (int j = 1; j <= num_steps; j++)\n        {\n            vec2 point = p+float(j)*pixel*dir*radius;\n            float r = pattern(point, s);\n            vec3 current = vec3(point, r);\n            vec3 dir_curr = current - origin;\n            float dir = dot(normalize(dir_curr), n);\n            if (dir < 0.)\n                break;\n            if (dir > 0.)\n            {\n                ao += length(dir_curr)/float(j);\n                break;\n            }\n        }\n    }\n    ao /= float(samples);\n    return ao;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float s = 6.;\n    float h = pattern(uv, s);\n    vec3 n = normals(uv, s, h);\n    float ao = 1.-ambient_occlusion(uv, h, n, s);\n   \t\n    float t = iTime;\n    vec3 ld = normalize(vec3(cos(t), sin(t), .5)*3.-vec3(uv, h));\n    float diff = max(dot(n, ld), 0.);\n    float l = diff*ao;\n    \n    vec3 col = vec3(0.);\n    col += l*mix(vec3(1.), vec3(0.0, .6, .8), h);\n\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WllXzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wllXzX", "name": "Mandelbulb Labyrinth", "author": "96logda", "description": "I wanted to try to do something different from what I have done before. ", "tags": ["procedural", "3d", "mandelbulb", "snow", "mengersponge"], "likes": 4, "viewed": 264, "date": "1563806077", "time_retrieved": "2024-06-20T19:41:01.936240", "image_code": "//Copyright (c) 2019-07-22 - 2019-07-23 by Angelo Logahd\n//Portfolio: https://angelologahd.wixsite.com/portfolio\n//Based on https://www.iquilezles.org/www/articles/menger/menger.htm\n\n\n#define PI\t\t\t\t\t3.14\n\n#define saturate(x) \t\tclamp(x, 0.0, 1.0)\n#define dot2(x) \t\t\tdot(x, x)\n\n#define MENGER_ITERATIONS\t2\n#define SOFT_SHADOW_STEPS \t16\n\n#define INTERSECT_STEPS\t\t300\n#define INTERSECT_MIN_DIST\t0.0001\n#define INTERSECT_MAX_DIST\t100.0\n\n\nvec2 rotate2D(vec2 p, float angle)\n{\n    float sRot = sin(angle);\n    float cRot = cos(angle);\n    return p * cRot + p.yx * sRot * vec2(-1.0, 1.0);\n}\n\nfloat sdPlane(vec3 p, float height)\n{\n   \treturn p.y - height;\n}\n\n//https://www.shadertoy.com/view/ltfSWn\nfloat mandelbulb(vec3 p)\n{\n    vec3 w = p;\n    float m = dot2(w);\n    float dz = 1.0;\n    for(int i = 0; i < 4; ++i)\n    {\n\t\tdz = 8.0 * pow(sqrt(m), 7.0) * dz + 1.0;\n        float r = length(w);\n        float b = 8.0 * acos(w.y / r);\n        float a = 8.0 * atan(w.x, w.z);\n        w = p + pow(r, 8.0) * vec3(sin(b) * sin(a), cos(b), sin(b) * cos(a));\n\n        m = dot(w,w);\n\t\tif (m > 255.0)\n\t\t{\n            break;\n\t\t}\n    }\t\n    return 0.1 * log(m) * sqrt(m) / dz;\n}\n\nvec4 map(in vec3 p)\n{\t\n    float ground = sdPlane(p, 1.8);\n    \n    p.xz = mod(p.xz + 1.0, 2.0) -1.0;\n    p.y = mod(p.y + 1.0, 2.0) - 1.0;\n\t\n    float d = mandelbulb(p - vec3(0.0, 0.5, 0.0));\n    vec4 res = vec4(d, 2.0, 0.0, 0.0);\n\t\n    float s = 1.0;\n    for(int i = 0; i < MENGER_ITERATIONS; ++i)\n    { \n        vec3 a = mod(p * s, 2.0) - 1.0;\n        s *= 5.0;\n        vec3 r = abs(1.0 - 3.0 * abs(a));\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 1.3) / s;\n\n        if(c > d)\n        {\n            d = c;\n            res = vec4(d, min(res.y, 0.2 * da * db * dc), 0.0, 1.0);\n        }\n    }\n    \n    return min(res, vec4(ground, 1.0, 0.0, 1.0));\n}\n\nvec4 intersect(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n    vec4 h = vec4(1.0);\n    for (int i = 0; i < INTERSECT_STEPS; i++ )\n    {\n\t\tif(h.x < INTERSECT_MIN_DIST || t > INTERSECT_MAX_DIST) \n\t\t{\n\t    \tbreak;\n\t\t}\n\t\n        h = map(ro + rd * t);\n        res = vec4(t, h.yzw);\n        t += h.x;\n    }\n\n    if (t > INTERSECT_MAX_DIST) \n    {\n\t\tres = vec4(-1.0);\n    }\n    \n    return res;\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < SOFT_SHADOW_STEPS; ++i)\n    {\n\t\tvec3 pos = ro + rd * t;\n        float h = map(pos).x;\n        res = min(res, float(SOFT_SHADOW_STEPS) * h / t);\n        if(res < 0.001)\n\t\t{\n\t    \tbreak;\n\t\t}\n        t += clamp(h, 0.01, 0.2);\n    }\n    return saturate(res);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 n;\n    n.x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    n.y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    n.z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n    return normalize(n);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float k)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < SOFT_SHADOW_STEPS; ++i)\n    {\n\t\tvec3 pos = ro + rd * t;\n        float h = map(pos).y;\n        res = min(res, k * h / t);\n        if(res < 0.001)\n\t\t{\n\t    \tbreak;\n    \t}\n        t += clamp(h, 0.01, 0.2);\n    }\n    return saturate(res);\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 color = vec3(0.5);\n    vec4 res = intersect(ro,rd);\n    if(res.x > 0.0)\n    {\n        const vec3 light1 = vec3(0.0, 0.0, -0.5);\n\t\t\n\t\tvec3 pos = ro + res.x * rd;\n\t\n        vec3 baseColor = vec3(1.0, 0.6, 1.0); //vec3(0.0, 0.2, 0.6) <- cyan\n\t\tvec3 ambient = vec3(0.2) * baseColor;\n\t\t\n\t\tvec3 normal = calcNormal(pos);\n\t\tvec3 reflection = reflect(rd, normal);\n\t\n\t\tfloat occ = res.y;\n\t\tfloat shadow1 = softshadow(pos + 0.01 * normal, light1);\n\t\n\t\tvec3 diffuse = baseColor * shadow1 * occ;\n\t\t\n\t\tcolor = diffuse + ambient;\n    }\n\n    return pow(color, vec3(0.4545));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 p = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\t\n    // camera\n    vec3 ro = vec3(3.5 * 3.5, 2.9, -2.0);\n    vec3 ww = normalize(vec3(0.0) - ro);\n    ww.xz = rotate2D(ww.xz, iMouse.x * 2.0 * PI);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n\n    ro.x -= iTime * 0.1; //Camera movement\n\t\n \tvec3 color = render(ro + vec3(0.0, -1.0, 0.0), rd);\n    color += vec3(0.0, 0.2, 0.1);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wllXzX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlsSD2", "name": "triagulated landscape", "author": "run", "description": "A landscape consiting of triangles. Raymarched. Please note that I only wrote the SDF, the raymarcher, shading and texture was grabbed from some other shadertoy implementation.", "tags": ["triangulatedsdf"], "likes": 5, "viewed": 304, "date": "1564410627", "time_retrieved": "2024-06-20T19:41:03.135933", "image_code": "//------------------------------------------------------------------------\n// Here rather hacky and very basic sphere tracer, feel free to replace.\n//------------------------------------------------------------------------\n\n// fField(p) is the final SDF definition, declared at the very bottom\n\n#define PI 3.14159265\n\nconst int iterations = 200;\nconst float dist_eps = .001;\nconst float ray_max = 200.0;\nconst float fog_density = .03;\n\nconst float cam_dist = 5.;\n\nfloat fField(vec3 p);\n\nvec3 dNormal(vec3 p)\n{\n   const vec2 e = vec2(.005,0);\n   return normalize(vec3(\n      fField(p + e.xyy) - fField(p - e.xyy),\n      fField(p + e.yxy) - fField(p - e.yxy),\n      fField(p + e.yyx) - fField(p - e.yyx) ));\n}\n\nvec4 trace(vec3 ray_start, vec3 ray_dir)\n{\n   float ray_len = 0.0;\n   vec3 p = ray_start;\n   for(int i=0; i<iterations; ++i) {\n   \t  float dist = fField(p) / 4.;\n      if (dist < dist_eps) break;\n      if (ray_len > ray_max) return vec4(0.0);\n      p += dist*ray_dir;\n      ray_len += dist;\n   }\n   return vec4(p, 1.0);\n}\n\n// abs(0+0-1)=1\n// abs(1+0-1)=0\n// abs(0+1-1)=0\n// abs(1+1-1)=1\nfloat xnor(float x, in float y) { return abs(x+y-1.0); }\n\nvec4 checker_texture(vec3 pos, float sample_size)\n{\n\n   \n   vec4 path_line_color = vec4(0., 0., 1.0, 1.0); \n   vec4 sep_line_color = vec4(0., 0., 1.0, 1.0);\n   vec4 ground_color = vec4(.1, .1, .1, 1.0);\n    \n   float tile_size = 0.3;\n   float line_width = 0.01;\n   float tpx = mod(pos.x - line_width / 2., tile_size);\n   float tpz = mod(pos.z - line_width / 2., tile_size);\n   if (pos.x > 0. && pos.x < 0.6) {\n      return vec4(1.0);\n   }   \n    if (tpx < line_width) {\n    \treturn sep_line_color;\n    } else if (tpz < line_width) {\n        return sep_line_color;\n    } else if (tpz + tpx > tile_size && tpz + tpx < tile_size + line_width) {\n        return sep_line_color;\n    } else {\n    \treturn ground_color;\n    }\n    \n    \n   pos = pos*8.0 + .5;\n   vec3 cell = step(1.0,mod(pos,2.0));\n   float checker = xnor(xnor(cell.x,cell.y),cell.z);\n   vec4 col = mix(vec4(.4),vec4(.5),checker);\n   float fade = 1.-min(1.,sample_size*24.); // very fake \"AA\"\n   col = mix(vec4(.5),col,fade);\n   pos = abs(fract(pos)-.5);\n   float d = max(max(pos.x,pos.y),pos.z);\n   d = smoothstep(.45,.5,d)*fade;\n   return mix(col,vec4(0.0),d);\n}\n\nvec3 sky_color(vec3 ray_dir, vec3 light_dir)\n{\n   float d = max(0.,dot(ray_dir,light_dir));\n   float d2 = light_dir.y*.7+.3;\n   vec3 base_col;\n   base_col = mix(vec3(.3),vec3((ray_dir.y<0.)?0.:1.),abs(ray_dir.y));\n   return base_col*d2;\n}\n\nvec4 debug_plane(vec3 ray_start, vec3 ray_dir, float cut_plane, inout float ray_len)\n{\n    // Fancy lighty debug plane\n    if (ray_start.y > cut_plane && ray_dir.y < 0.) {\n       float d = (ray_start.y - cut_plane) / -ray_dir.y;\n       if (d < ray_len) {\n           vec3 hit = ray_start + ray_dir*d;\n           float hit_dist = fField(hit);\n           float iso = fract(hit_dist*5.0);\n           vec3 dist_color = mix(vec3(.2,.4,.6),vec3(.2,.2,.4),iso);\n           dist_color *= 1.0/(max(0.0,hit_dist)+.001);\n           ray_len = d;\n           return vec4(dist_color,.1);\n      }\n   }\n   return vec4(0);\n}\n\nvec3 shade(vec3 ray_start, vec3 ray_dir, vec3 light_dir, vec4 hit)\n{\n   vec3 fog_color = sky_color(ray_dir, light_dir);\n   \n   float ray_len;\n   vec3 color;\n   if (hit.w == 0.0) {\n      ray_len = 1e16;\n      color = fog_color;\n   } else {\n      vec3 dir = hit.xyz - ray_start;\n      vec3 norm = dNormal(hit.xyz);\n      float diffuse = max(0.0, dot(norm, light_dir));\n      float spec = max(0.0,dot(reflect(light_dir,norm),normalize(dir)));\n      spec = pow(spec, 16.0)*.5;\n       \n      ray_len = length(dir);\n   \n      vec3 base_color = checker_texture(hit.xyz,ray_len/iResolution.y).xyz;\n      color = mix(vec3(0.,.1,.3),vec3(1.,1.,.9),diffuse)*base_color +\n         spec*vec3(1.,1.,.9);\n\n      float fog_dist = ray_len;\n      float fog = 1.0 - 1.0/exp(fog_dist*fog_density);\n      color = mix(color, fog_color, fog);\n   }\n   \n   \n    \n   float cut_plane0 = sin(iTime)*.15 - .8;\n   for(int k=0; k<4; ++k) {\n      vec4 dpcol = debug_plane(ray_start, ray_dir, cut_plane0+float(k)*.75, ray_len);\n      //if (dpcol.w == 0.) continue;\n      float fog_dist = ray_len;\n      dpcol.w *= 1.0/exp(fog_dist*.05);\n      //color = mix(color,dpcol.xyz,dpcol.w);\n   }\n\n   return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n   vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    \n   vec3 light_dir = normalize(vec3(.5, 1.0, -.25));\n   \n   // Simple model-view matrix:\n   float ang, si, co;\n   ang = iTime*.25;\n   si = sin(ang); co = cos(ang);\n   mat4 cam_mat = mat4(\n      co, 0., si, 0.,\n      0., 1., 0., 0.,\n     -si, 0., co, 0.,\n      0., 0., 0., 1.);\n   ang = iTime*.2;\n   si = sin(ang); co = cos(ang);\n   cam_mat = cam_mat * mat4(\n      1., 0., 0., 0.,\n      0., co, si, 0.,\n      0.,-si, co, 0.,\n      0., 0., 0., 1.);\n\n   vec3 pos = vec3(cam_mat*vec4(0., 0., -cam_dist, 1.0));\n   vec3 dir = normalize(vec3(cam_mat*vec4(uv, 1., 0.)));\n   \n   vec3 color = shade(pos, dir, light_dir, trace(pos, dir));\n   color = pow(color,vec3(.44));\n   fragColor = vec4(color, 1.);\n}\n\n//------------------------------------------------------------------------\n// Your custom SDF\n//------------------------------------------------------------------------\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n\nfloat noise(vec2 p, float unit){\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\t//xy = 3.*xy*xy-2.*xy*xy*xy;\n\txy = .5*(1.-cos(PI*xy));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat bumpy_terrain(vec3 p) {\n \tfloat large_scale_noise = noise(vec2(p.x, p.z), 1.) - noise(vec2(0., p.z), 1.);\n    float small_scale_noise = noise(vec2(p.x, p.z), .2) - noise(vec2(0., p.z), .2);\n    return p.y + 1.0 * cos(p.x) - 0.3 * small_scale_noise - 1.0 * large_scale_noise;   \n}\n\nfloat fField(vec3 p)\n{   \n    //pMod3(p, vec3(1.));\n    float tile_size = 0.3;\n    // Snap point x and y. Snapped to the tile below.\n    float tpx = mod(p.x, tile_size);\n    float tpz = mod(p.z, tile_size);\n    float spx = p.x - tpx;\n    float spz = p.z - tpz;\n    \n    float t00 = bumpy_terrain(vec3(spx, p.y, spz));\n    float d00t01 = bumpy_terrain(vec3(spx, p.y, spz - tile_size)) - t00;\n    float d00t10 = bumpy_terrain(vec3(spx - tile_size, p.y, spz)) - t00;\n    float t11 = bumpy_terrain(vec3(spx - tile_size, p.y, spz - tile_size));\n    float d11t01 = bumpy_terrain(vec3(spx, p.y, spz - tile_size)) - t11;\n    float d11t10 = bumpy_terrain(vec3(spx - tile_size, p.y, spz)) - t11;\n    \n    if (tpx + tpz > tile_size) {\n        return t00 + d00t10 * (1. - tpx / tile_size) + d00t01 * (1. - tpz / tile_size);\n    } else {\n        return t11 + d11t01 * tpx / tile_size + d11t10 * tpz / tile_size;// + d11t01 * (1. - tpz / tile_size);\n    }\n    \n\t\n                              \n    \n    return mod(p.x, tile_size) * bumpy_terrain(vec3(spx, p.y, spz)) + (tile_size - mod(p.x, tile_size)) * bumpy_terrain(vec3(spx - tile_size, p.y, spz));\n    //return bumpy_terrain(p);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlsSD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlsSRH", "name": "Raymarching practice numero uno", "author": "zikbakguru", "description": "wow 3D", "tags": ["sdf"], "likes": 1, "viewed": 280, "date": "1562086049", "time_retrieved": "2024-06-20T19:41:03.136204", "image_code": "/*\n\tZik's horryfiying SDF lab\n\tWarning : contains disgusting unorganized dirty code!\n\n\tMaterial system heavily inspired from\n\thttps://www.shadertoy.com/view/ld3Gz2\n*/\n#define DIST_MAX 999999999.9\n#define MAX_STEPS 128\n#define MIN_MARCH_DIST 0.001\n\n/*\n\tSDF functions\n*/\nfloat sdfSphere (vec3 p, float r)\n{\n    return length(p) - r;\n}\n// TODO : add n-gon prism sdf\n/*===================================================*/\n\n/*\n\tScene functions\n*/\n// determinator\n/*\nvec4 sceneDet (vec4 a, vec4 b)\n{\n    return (a.w < b.w) ? a : b;\n}*/\n\n// Main bouncy sphere\n// returns distance\nfloat mainSphere (vec3 p, out vec3 mat)\n{\n    const float radius = 120.0;\n    float timeFract = mod(iTime * 64.0, 64.0);\n    float timePercent = pow(1.0 - (timeFract / 64.0), 5.0);\n    float squish = sin(timeFract * 0.5) * timePercent * 0.5;\n    \n    vec3 dp = p;\n    dp.x *= 1.0 + squish;\n    dp.y *= 1.0 - squish;\n    \n    mat = vec3(0.95, 0.65, 0.0);\n    \n    /// face???\n    // eye 1\n    vec2 epos = vec2(-64.0, -20.0);\n    float delta = smoothstep(10.0, 9.0, length(epos - p.xy));\n    mat = mix(mat, vec3(0.12, 0.04, 0.02), delta);\n    \n    // eye 2\n    epos = vec2(64.0, 40.0);\n    delta = smoothstep(10.0, 9.0, length(epos - p.xy));\n    mat = mix(mat, vec3(0.12, 0.04, 0.02), delta);\n    \n    // mouth\n    float mouthRad = 60.0;\n    delta = smoothstep(mouthRad, mouthRad - 1.0, length(p.xy + vec2(-10.0, 30.0))) * clamp(-p.y - 15.0, 0.0, 1.0);\n    mat = mix(mat, vec3(0.12, 0.04, 0.02), delta);\n    ///\n    \n    return sdfSphere(dp, radius);\n}\n\n// Filler sphere(s)\n// returns distance\nfloat sphereFiller (vec3 p, out vec3 mat)\n{\n    const float radius = 42.0;\n    \n    mat = vec3(1.0, 1.0, 1.0);\n    float dist1 = sdfSphere(p + vec3(220.0, -42.0 + cos(iTime * 42.0) * 42.0, 50.0), radius);\n    float dist2 = sdfSphere(p + vec3(-220.0, -42.0 + sin(iTime * 42.0) * 42.0, 50.0), radius);\n    return min(dist1, dist2);\n}\n\n// Light debug\n// returns vec4(colour.xyz, distance)\n/*\nvec4 mainLight (vec3 p)\n{\n    vec4 data = vec4(vec3(1.0, 1.0, 1.0), sdfSphere(p, 32.0));\n    return data;\n}\n*/\n\n// returns distance, [out] vec4 mat\nfloat getSceneInfo (vec3 p, out vec3 mat)\n{\n    vec3 tmpMat;\n    mat = vec3(0.5);\n    float dist = DIST_MAX;\n    float tmpDist;\n    \n    // main sphere\n    tmpDist = mainSphere(p, tmpMat);\n    if (tmpDist < dist)\n    {\n        mat = tmpMat;\n        dist = tmpDist;\n    }\n    \n    // filler shhsh\n    tmpDist = sphereFiller(p, tmpMat);\n    if (tmpDist < dist)\n    {\n        mat = tmpMat;\n        dist = tmpDist;\n    }\n    \n    // light\n    //vec3 lightPos = vec3(cos(iTime) * 128.0, sin(iTime * 2.0) * 42.0, sin(iTime) * 128.0);\n    //data = sceneDet(mainSphereData, data);\n    \n    return dist;\n}\n\nfloat getSceneDist (vec3 p)\n{\n    vec3 trash;\n    return getSceneInfo(p, trash);\n}\n\nvec3 getSceneNormal (vec3 p, vec3 lightPos)\n{\n    vec3 md = vec3(MIN_MARCH_DIST * 10.0, 0.0, 0.0);\n    vec3 delta = vec3(\n        getSceneDist(p + md.xyy) - getSceneDist(p - md.xyy), // = getScene(p + vec3(MIN_MARCH_DIST, 0, 0)) - getScene(p - vec3(MIN_MARCH_DIST, 0, 0)\n        getSceneDist(p + md.yxy) - getSceneDist(p - md.yxy),\n        getSceneDist(p + md.yyx) - getSceneDist(p - md.yyx)\n    );\n    \n    vec3 normal = normalize(delta);\n    return normal;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    // c64 stuff\n    vec3 col = fract(vec3(80.0/255.0 + iTime, 69.0/255.0 - iTime * 0.42, 155.0/255.0 + sin(iTime) * 0.2));\n    float jort = fract((uv.y + iTime * 0.5) * 8.0 + uv.x * sin(iTime) * 0.6);\n    vec3 final = mix(col, vec3(1.0), smoothstep(0.49, 0.51, jort));\n\t\n    // World info / camera settings\n    float time = iTime;\n    ivec2 intRes = ivec2(iResolution.xy);\n    vec3 camPos = vec3(0.0, 0.0, -256.0);\n    vec3 lightPos = vec3(cos(time) * DIST_MAX, sin(time * 2.0) * DIST_MAX, sin(time) * DIST_MAX);\n    \n    // We're doing some ortho camera in this shader so\n    // We don't have to worry about spooky projection math\n    vec2 screenPos = uv * iResolution.xy;\n    vec3 rayOrigin = camPos + vec3(screenPos.x - (iResolution.x * 0.5), screenPos.y - (iResolution.y * 0.5), 0.0);\n    vec3 rayPos = rayOrigin;\n    vec3 rayDir = vec3(0.0, 0.0, 1.0);\n\tvec3 mat;\n    \n    for (int rs=0; rs<=MAX_STEPS; rs++)\n    {\n        float dist = getSceneInfo(rayPos, mat);\n\n        if (dist < MIN_MARCH_DIST) // We hit something\n        {\n            vec3 normal = getSceneNormal(rayPos, lightPos);\n            \n            // Diffuse lighting\n            vec3 lightDelta = normalize(rayPos - lightPos);\n            float lightDot = dot(normal, lightDelta);\n            float diffLt = max(lightDot, 0.0) * 0.6 + 0.4;\n            \n            final.xyz = mat.xyz * diffLt;\n        }\n        else // Nope. Keep moving\n        {\n            rayPos += rayDir * dist;\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(final,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlsSRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlsSRj", "name": "RayMarchingBand007", "author": "Hirai_worthless", "description": "Dance.", "tags": ["raymarching"], "likes": 1, "viewed": 508, "date": "1563592319", "time_retrieved": "2024-06-20T19:41:03.136204", "image_code": "float PI = 3.14159265;\nvec2 path(float z){\n    float x = sin(z) + 2.0 * cos(z * 0.3) - 1.5 * sin(z * 0.12345);\n    float y = cos(z) + 1.5 * sin(z * 0.3) + 2.0 * cos(z * 0.12345);\n    return vec2(x,y);\n}\nvec2 cir(float rot){\n    return vec2(cos(rot),sin(rot));\n}\nfloat rate(float t){\n\treturn 1.0 + 0.5*sin(t);\n}\nfloat map(vec3 p){\n\tp.xy = fract(p.xy/5.0) * 8.0 * rate(iTime*2.0) - 4.0*rate(iTime*2.0);\n    vec2 o = vec2(0,0);\n\tfloat tT1 = length(p.xy - (o/4.0) - (vec2(cir(((0.0/3.0) + (p.z/4.0)) * PI)) * 2.0)) - 0.4 *fract(p.z) ;\n    float tT2 = length(p.xy - (o/4.0) - (vec2(cir(((2.0/3.0) + (p.z/4.0)) * PI)) * 2.0)) - 0.4*fract(p.z);\n\tfloat tT3 = length(p.xy - (o/4.0) - (vec2(cir(((4.0/3.0) + (p.z/4.0)) * PI)) * 2.0)) - 0.4*fract(p.z);\n    return min(min(tT1,tT2),tT3);\n\n}\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 64; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return vec4(getNormal(p),t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float PI = 3.14159265;\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv,0.5));\n\tr.xz *= mat2(cos(0.1 * PI),-sin(0.1 * PI),sin(0.1 * PI),cos(0.1 * PI));\n    r.yz *= mat2(cos(0.1 * PI),-sin(0.1 * PI),sin(0.1 * PI),cos(0.1 * PI));\n    r.xy *= mat2(cos(iTime),-sin(iTime),sin(iTime),cos(iTime));\n    float z = iTime * 12.0 ;\n   \n\tvec2 a = path(z);\n    vec3 o = vec3(a /8.0 + vec2(iTime) * 2.0  ,z);\n    vec4 data = trace(o,r);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.01);\n    vec3 fc = mix(vec3(0.5 - data.x,0.5 -data.y,0.5-data.z),vec3(0),1.0 - fog);\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlsSRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlsSW4", "name": "noise vs aliasing", "author": "FabriceNeyret2", "description": "jittering allows to replace aliasing by noise: human visual system sometimes prefer.\nHere, amount of jittering goes from 0 to 100% along the clock.", "tags": ["noise", "aliasing", "tuto", "jittering"], "likes": 2, "viewed": 296, "date": "1563021740", "time_retrieved": "2024-06-20T19:41:03.136204", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         D = texelFetch(iChannel0, ivec2(U)%256, 0).rg - .5,\n         P = ( 2.*U - R ) / R.y;\n\n    float v = fract( atan(P.y,P.x)/6.283 - .1*iTime ); // amount (0..1)\n\n    U +=  v * D;                                       // jittering\n    P = ( 2.*U - R ) / R.y;\n   \n    O = vec4( .5 + .5* sin( R.y * atan(P.y,P.x)) );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlsSW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlsSWS", "name": "Procedural walk animation", "author": "TLC123", "description": "Now I have to catch my bouncy head.\nMy head is like a ball \nand I lost it in a fall.\nIf I only could catch my bouncy head", "tags": ["3d", "animation", "walkcycle", "footsteps"], "likes": 71, "viewed": 1266, "date": "1564116322", "time_retrieved": "2024-06-20T19:41:05.451505", "image_code": "// Fork of \"Football\" by . https://shadertoy.com/view/llKcR3\n// 2019-07-25 21:23:38\n// Modified from https://www.shadertoy.com/view/Xds3zN by iq.\n//\n\n/*\n Some path funtion: timefly(t) returns a 2d pivot\n pasaR(t) and pasaL(t) modifies time to get \n initial foot targets when fead to timefly()\n \n*/\n\n#define AA 1\n# define PI 3.14159265359\n# define PHI 1.618033988749895\n# define TAU 6.283185307179586\nvec3 rightFoot;\nvec3 leftFoot;\nvec3 rightToe;\nvec3 leftToe;\nvec3 rightHand;\nvec3 leftHand;\nvec3 rightFootT;\nvec3 leftFootT;\nvec3 rightHandT;\nvec3 leftHandT;\nvec3 rightToeT;\nvec3 leftToeT;\nvec3 rightE; // Elbow\nvec3 leftE;\nvec3 rightK;//Knee\nvec3 leftK;\nvec3 rightH; //Hip\nvec3 leftH;\nvec3 rightS;// Shoulder\nvec3 leftS;\nvec3 pelvis;\nvec3 torso;\nvec3 head;\nvec3 target;\n\n\tfloat pasa = 1.; // steps overlaping airtime\n\tfloat legmax = .89; // max extention\n\tfloat leg = .89+0.005; // actual max length\n\tfloat armmax = .7;// max extention\n\tfloat arm = .7 +.012;// actual max length\n  \tfloat toemax = 1.1;// max extention toe from hip\n    float footlift=0.19; //lift height later multiplied by speed\n\n\n# define PLOTPATH 0\n \n\n//------------------------------------------------------------------\nfloat sdPlane(vec3 p) {\n\treturn p.y;\n}\nfloat sdSphere(vec3 p, float s) {\n\treturn length(p) - s;\n}\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h) - r;\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat pathterrain(float x,float z){\n    // Common height function for path and terrain\n    return \n        sin(x*.5 )*1.+cos(z*.3 )*0.3\n        +cos(x*3.+z )*0.1+sin(x-z*.2 )*0.2\n        \n        ;}\n vec3 timefly(float t) {\n    // main path Called from many places\n    t*=.80;\n\tt += (.125 + sin(t * .125));\n\tvec3 v =\n\tvec3(sin(t / 50.) * 20., 0., cos(t / 25.) * 24.) +\n\t\tvec3(sin(t / 17.1) * 07., 0., cos(t / 17.1) * 05.) +\n\t\tvec3(sin(t / 8.1) * 6., 0., cos(t / 8.1) * 8.) +\n\t\tvec3(cos(t / 3.) * 3.,0., sin(t / 3.) * 2.)\n        +vec3(cos(t  )*2.,0., sin(t  )*2. );\n    v.y=pathterrain(v.x,v.z);\n    return v        ;\n} \nfloat pasaR(float x){\nreturn max(x + fract(x + 0.25) * pasa - pasa, floor(x + 0.25) - 0.25) + 0.25;\n    //gait function \n}\n    \nfloat pasaL(float x){\nreturn max(x + fract(x - 0.25) * pasa - pasa, floor(x - 0.25) + 0.25) + 0.25;\n   //gait function \n}\n\n\n\nfloat lpnorm(vec3 p, float s) {\n\treturn pow(\n\t\t(\n\t\t\tpow(abs(p.x), s) +\n\t\t\tpow(abs(p.y), s) +\n\t\t\tpow(abs(p.z), s)),\n\t\t1.0 / s);\n}\n\n \n//------------------------------------------------------------------\nvec2 opU(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp(.5 + .5*(a-b)/k, 0., 1.);\n\treturn mix(a, b, h) - k*h*(1.-h);\n}\nvec2 bodyPlan(vec3 pos) {\n\tfloat res;\n\tres =  sdSphere(pos - leftFoot, .07);\n\tres = min(res, sdSphere(pos - leftHand, .06));\n\tres = min(res, sdSphere(pos - leftH, .09));\n\tres = min(res, sdSphere(pos - leftK, .08));\n\tres = min(res, sdSphere(pos - leftE, .08));\n\tres = min(res, sdSphere(pos - leftS, .07));\t\n\n    \n\n    res = min(res, sdSphere(pos - rightFoot, .07));\n\tres = min(res, sdSphere(pos - rightHand, .06));\n\tres = min(res, sdSphere(pos - rightH, .09));\n\tres = min(res, sdSphere(pos - rightS, .07));\n\tres = min(res, sdSphere(pos - rightK, .08));\n\tres = min(res, sdSphere(pos - rightE, .08));\n    \n    \tres = min(res, sdSphere(pos - target, .2));\n\t//res = min(res, sdSphere(pos - head, .16));\n\n \t\n   \n\n    \n\n    \n    res = min(res, sdCapsule(pos ,rightToe,rightFoot, .06));\n    res = smin(res, sdRoundedCylinder(pos - rightToe, .04, .02, .03 ),0.06 );\n\n    res = min(res, sdCapsule(pos ,rightK,rightFoot, .06));\n    res = min(res, sdCapsule(pos ,rightK,rightH, .07));   \n    res = min(res, sdCapsule(pos ,rightE,rightHand, .05));\n    res = min(res, sdCapsule(pos ,rightE,rightS, .06));\n    res = min(res, sdCapsule(pos ,torso,rightS, .08));\n    \n    res = min(res, sdCapsule(pos ,leftToe,leftFoot, .06));\n    res = smin(res, sdRoundedCylinder(pos - leftToe, .04, .02, .03 ),0.06);// todo rotate to grund normal\n\n    res = min(res, sdCapsule(pos ,leftK,leftFoot, .06));\n    res = min(res, sdCapsule(pos ,leftK,leftH, .07));   \n    res = min(res, sdCapsule(pos ,leftE,leftHand, .05));\n    res = min(res, sdCapsule(pos ,leftE,leftS, .06));\n    res = min(res, sdCapsule(pos ,torso,leftS, .08));\n    \n    res = smin(res, sdSphere(pos - torso, .14),0.025);\n    res = smin(res, sdSphere(pos - pelvis, .16),0.025);\n    \n    res = smin(res, sdCapsule(pos ,pelvis,torso, .13),0.025);\n\tres = min(res, sdCapsule(pos ,head,torso, .02)); \n    \n    \n    \n    if(PLOTPATH>0)for(int i=PLOTPATH;i>-PLOTPATH/2;i--)\n\n    {\n        res = min(res, sdSphere(pos- timefly(iTime+float(i)*0.5), .04));\n    \n       \n        \n}  \n  \n        \n \n    \n     //float x=iTime;\n\t // res= min(res, sdCapsule( pos, timefly(x),timefly(x+1.) , .06125));\n\t // res= min(res, sdCapsule( pos, timefly(x)-perpr*-0.25,timefly(x)-perpl*0.25 , .06125));\n\treturn vec2(res, 2.0);\n}\nvec2 map( in vec3 pos) {\n\tvec2 res = vec2(pos.y-pathterrain(pos.x,pos.z), 1.0);\n\tres = opU(res, bodyPlan(pos));\n\treturn res;\n}\nvec2 castRay( in vec3 ro, in vec3 rd) {\n\tfloat tmin = 1.0;\n\tfloat tmax = 30.0;\n\tfloat t = tmin;\n\tfloat m = -1.0;\n\tfor (int i = 0; i < 80; i++) {\n\t\tfloat precis = 0.0001 * t;\n\t\tvec2 res = map(ro + rd * t);\n\t\tif (res.x < precis || t > tmax) break;\n\t\tt += res.x * .7;\n\t\tm = res.y;\n\t}\n\tif (t > tmax) m = -1.0;\n\treturn vec2(t, m);\n}\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor (int i = 0; i < 32; i++) {\n\t\tfloat h = map(ro + rd * t).x;\n\t\tres = min(res, 8.0 * h / t);\n\t\tt += clamp(h, 0.02, 0.10);\n\t\tif (res < 0.005 || t > tmax) break;\n\t}\n\treturn clamp(res, 0.0, 1.0);\n}\nvec3 calcNormal( in vec3 pos) {\n\tvec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n\treturn normalize(e.xyy * map(pos + e.xyy).x +\n\t\te.yyx * map(pos + e.yyx).x +\n\t\te.yxy * map(pos + e.yxy).x +\n\t\te.xxx * map(pos + e.xxx).x);\n}\nfloat calcAO( in vec3 pos, in vec3 nor) {\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n\t\tfloat hr = 0.01 + 0.12 * float(i) / 4.0;\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = map(aopos).x;\n\t\tocc += -(dd - hr) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox2( in vec2 p) {\n\t// filter kernel\n\tvec2 w = fwidth(p) + 0.001;\n\t// analytical integral (box filter)\n\tvec2 i = 2.0 * (abs(fract((p - 0.5 * w) * 0.5) - 0.5) - abs(fract((p + 0.5 * w) * 0.5) - 0.5)) / w;\n\t// xor pattern\n\treturn 0.5 - 0.5 * i.x * i.y;\n}\nfloat checkersGradBox( in vec2 p) {\n \n\treturn  checkersGradBox2(p) -checkersGradBox2(p-0.03 )*0.4 ;\n}\nvec3 render( in vec3 ro, in vec3 rd) {\n\tvec3 col = vec3(0.7, 0.9, 1.0) + rd.y * 0.8;\n\tvec2 res = castRay(ro, rd);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\tif (m > -0.5) {\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect(rd, nor);\n\t\t// material        \n\t\tcol = 0.45 + 0.35 * sin(vec3(0.05, 0.08, 0.10) * (m - 1.0));\n\t\tif (m < 1.5) {\n\t\t\tfloat f = checkersGradBox(1.2 * pos.xz);\n\t\t\tcol = 0.3 + f * vec3(0.3);\n\t\t}\n\t\tif (m >= 2.0) {\n\t\t\tcol = vec3(0.6);\n\t\t}\n\t\tif (m >= 3.0) {\n\t\t\tcol = vec3(0.07);\n\t\t}\n\t\t// lighting        \n\t\tfloat occ = calcAO(pos, nor);\n\t\tvec3 lig = normalize(vec3(0.2, 0.7, 0.6));\n\t\tvec3 hal = normalize(lig - rd);\n\t\tfloat amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n\t\tfloat dif = clamp(dot(nor, lig), 0.0, 1.0);\n\t\tfloat bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0);\n\t\tfloat dom = smoothstep(-0.1, 0.1, ref.y);\n\t\tfloat fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n\t\tdif *= calcSoftshadow(pos, lig, 0.02, 2.5);\n\t\tdom *= calcSoftshadow(pos, ref, 0.02, 2.5);\n\t\tfloat spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 16.0) *\n\t\t\tdif *\n\t\t\t(0.04 + 0.96 * pow(clamp(1.0 + dot(hal, rd), 0.0, 1.0), 5.0));\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 1.30 * dif * vec3(1.00, 0.80, 0.55);\n\t\tlin += 0.20 * amb * vec3(0.40, 0.60, 1.00) * occ;\n\t\tlin += 0.20 * dom * vec3(0.40, 0.60, 1.00) * occ;\n\t\tlin += 0.30 * bac * vec3(0.25, 0.25, 0.25) * occ;\n\t\tlin += 0.35 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\t\tcol = col * lin;\n\t\tcol += 10.00 * spe * vec3(1.00, 0.90, 0.70);\n\t\tcol = mix(col, vec3(0.8, 0.9, 1.0), 1.0 - exp(-0.0002 * t * t * t));\n\t}\n\treturn vec3(clamp(col, 0.0, 1.0));\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\n\n\n\n\nvoid setup() {\n\tfloat x = iTime   ;//Time manipulations moved to timefly\n      \n    \n    // filter gait slightly for less stabby foot placement, too much generates skating\n    float filt=18.;\n\tfloat left = 0.025+ mix(pasaR(floor(x*filt)/filt) ,pasaR(ceil(x*filt)/filt), ( fract(x*filt)));\n\tfloat right =0.025+ mix(pasaL(floor(x*filt)/filt) ,pasaL(ceil(x*filt)/filt), ( fract(x*filt)));\n\t\n    \n    float ahead=1.1;\n    vec3 dif = (timefly(x + ahead) - timefly(x))/ahead; //delta x+1\n\tfloat speed = length(dif); \n     ahead = clamp(0.8,1.1,1.3-speed);\n     dif = (timefly(x + ahead) - timefly(x))/ahead; //delta x+1\n\t speed = length(dif); \n    \n    \n    \n    vec3 nextdif = (timefly(x + ahead+.5) - timefly(x + .5))/ahead; \n\tvec3 lean = (nextdif - dif*2.); // bank into turns\n\n    //\n      ahead=speed;\n      dif = (timefly(x + ahead) - timefly(x))/ahead; //delta x+1\n\t  nextdif = (timefly(x + ahead+.5) - timefly(x + .5))/ahead; \n\t  lean = (nextdif - dif*2.); // bank into turns\n\n     \n    \n\tfloat nextSpeed = length(timefly(x + 1.2) - timefly(x + .2));\n   \n\n\n    vec3 dir = normalize(dif); //Path direction \n    vec3 nextdir = normalize(nextdif); //Path direction \n\tvec3 dirr = normalize(timefly(right + 1.) - timefly(right)); //Path direction Foot specific\n\tvec3 dirl = normalize(timefly(left + 1.) - timefly(left));\n    \n\tvec3 perp = cross(dir,vec3(0,-1,0));// perpendicular to main path\n\tvec3 perpl = cross(dirl,vec3(0,-1,0));// perpendicular to intervalled step path\n\tvec3 perpr = cross(dirr,vec3(0,-1,0));\n    \n    target =(timefly(x+1.5))\n               \n            +(vec3(0,.4,0)+lean*1.6+dir*0.25 )*(.09/clamp(speed , 0.05, 4.5));// rolling head\n\n       \n    target.y=pathterrain(target.x,target.z);// fix for rolling head collision \n    \n    target +=\n        +( vec3(0,0.14+abs(sin(x*7.)*0.3),0)) ;\n  \n      \n    vec3 tfx= timefly(x)  ; // Pelvis   path\n    vec3 tfr= timefly(right) ;//intervalled step path\n    vec3 tfl= timefly(left) ; //intervalled step path\n    \n    // foot lift component\n\tvec3 leftlift = vec3(0, min(0., sin(x * TAU + 1.57) * footlift * clamp(speed, 0.05, 1.5)), 0);\n\tvec3 rightlift = vec3(0, min(0., sin(x * TAU - 1.57) * footlift * clamp(speed, 0.05, 1.5)), 0);\n \n    \n    // setup targets\n\trightFootT = tfr + perpr * -0.16 - rightlift;\n\tleftFootT = tfl + perpl * 0.16 - leftlift;\n    rightToeT = tfr  + perpr * -0.19  +dir*0.172 - rightlift*0.6;\n\tleftToeT = tfl  + perpl * 0.19  +dir*0.172- leftlift*0.7;\n    // ground collision feet and toes\n    rightFootT.y=max(pathterrain(rightFootT.x,rightFootT.z),    rightFootT.y);\n    leftFootT.y=max(pathterrain(leftFootT.x,leftFootT.z),    leftFootT.y);\n    rightToeT.y=max(pathterrain(rightToeT.x,rightToeT.z),    rightToeT.y);\n    leftToeT.y=max(pathterrain(leftToeT.x,leftToeT.z),    leftToeT.y);\n    \n    \n\n    \n    \n\tpelvis = tfx \n        + (lean  ) * clamp(nextSpeed, 0.01, .5) * 0.1 // lean into turn\n        + vec3(0, .9 + cos(x * TAU * 2.) * 0.02 * speed, 0) // bob u/d with step\n\t\t+ dir * 0.1 * (-0.45 + speed) // lean in to run\n\t\t+ perpr * sin(x * TAU) * 0.025 * speed // bob l/R with step\n \t\t+ (vec3(0,-1.,0) )*(.02/clamp(speed , 0.15, 4.5))// bend when head is close\n;\n    // spine component\n\tvec3 spine = normalize(\n\t\t (lean  ) * clamp(nextSpeed, 0.2, .5) * 0.1 // lean into turn\n\t\t+ vec3(0, 0.3 + cos(x * TAU * 2.) * 0.0125 * speed, 0)// bob u/d with step\n\t\t+ dir * 0.05 * (-0.25 + nextSpeed)  // lean in to run\n        +(vec3(0,-1.,0)+dir)*(.05/clamp(speed , 0.15, 4.5))// bend when head is close\n        + perpr * cos(x * TAU) * 0.025 * speed// bob l/R with step\n\t);\n     \n    torso = pelvis + spine * 0.3;\n    \n    \n\n\t// Hips\n    rightH = pelvis + perp * -0.11 - rightlift * 0.1 - spine * 0.08 + dir * -0.025;\n\tleftH = pelvis + perp * 0.11 - leftlift * 0.1 - spine * 0.08 + dir * -0.025;\n    \n    // Feet\n\trightFoot = rightH + normalize(rightFootT - rightH) * min(legmax, length(rightFootT - rightH));\n\tleftFoot = leftH + normalize(leftFootT - leftH) * min(legmax, length(leftFootT - leftH));\n\t\n    rightToe = rightH + normalize(rightToeT - rightH) * min(toemax, length(rightToeT - rightH));\n\tleftToe = leftH + normalize(leftToeT - leftH) * min(toemax, length(leftToeT - leftH));\n    \n    // Shoulder\n\trightS = torso + perp * -0.2   + spine * 0.05;\n\tleftS = torso + perp * 0.2  + spine * 0.05;\n    \n    // Hand Target\n    rightHandT=(rightS +  normalize(\n\t\t\t+perpr * -0.06 \n\t\t\t+vec3(0, -0.4, 0) \n\t\t\t+dir * 0.3 * cos(.25 + x * TAU) * (clamp(speed, 0.0, 2.) * 0.25)\n \t\t\t) \n            * armmax \n\t\t\t+vec3(0, 0.2, 0) * clamp(speed - 0.6, 0., 1.) )// lift alittle with speed\n        \t+( target -rightS)*(1.-smoothstep(0.,1.2,(1.+sin(x*1. ))))*0.3;// reach for head \n    \n     leftHandT= (leftS + normalize(\n\t\t\tperpl * 0.06 +\n\t\t\tvec3(0, -0.4, 0) +\n\t\t\tdir * 0.3 * cos(.25 + PI + x * TAU) * (clamp(speed, 0.0, 2.) * 0.25)\n \t\t) * armmax +\n\t\tvec3(0, 0.2, 0) * clamp(speed - 0.6, 0., 1.))\n       +( target -leftS)*(1.-smoothstep(0.,1.2,(1.+sin(x*1.+PI))))*0.3;\n    \n       rightHand = rightS + normalize(rightHandT - rightS) * min(armmax, length(rightHandT - rightS));\n       leftHand = leftS + normalize(leftHandT - leftS) * min(armmax, length(leftHandT - leftS));\n \t\n     \n        rightHand.y=max(pathterrain(rightHand.x,rightHand.z)+.2,    rightHand.y);\n    leftHand.y=max(pathterrain(leftHand.x,leftHand.z)+.2,    leftHand.y);\n \n    \n    \n\thead = torso +normalize(\n\t\tvec3(0, .27, 0) \n\t\t+ normalize(lean) * clamp(nextSpeed, 0.2, 1.) * 0.05 // lean into torn\n\t\t+dir * 0.1 * (-0.35 + clamp(speed, 0.5, 2.)) // lean into run\n\t\t+perpr * cos(x * TAU) * 0.025 * clamp(speed, 0.5, 2.)\n        +(vec3(0,-1.,0)+dir)*(.07/clamp(speed , 0.05, 4.5))// bend when head is close\n\n       )*0.27;// sway with step\n    \n    // bendy lims IK\n    \n\trightE = mix(rightS, rightHand, 0.5) - cross(rightS - rightHand, -normalize(perp - dir * 0.5)) *\n\t\tsqrt(max(0.0001, arm * arm - length(rightS - rightHand) * length(rightS - rightHand))) * 0.5;\n\tleftE = mix(leftS, leftHand, 0.5) - cross(leftS - leftHand, -normalize(perp + dir * 0.5)) *\n\t\tsqrt(max(0.0001, arm * arm - length(leftS - leftHand) * length(leftS - leftHand))) * 0.5;\n\trightK = mix(rightH, rightFoot, 0.5) - cross(rightH - rightFoot, normalize(perp + dir * 0.25)) *\n\t\tsqrt(max(0.0001, leg * leg - length(rightH - rightFoot) * length(rightH - rightFoot))) * 0.5;\n\tleftK = mix(leftH, leftFoot, 0.5) - cross(leftH - leftFoot, normalize(perp - dir * 0.25)) *\n\t\tsqrt(max(0.0001, leg * leg - length(leftH - leftFoot) * length(leftH - leftFoot))) * 0.5;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tsetup();\n\tvec2 mo = iMouse.xy / iResolution.xy;\n\tfloat time = .0 + iTime;\n\tvec3 tot = vec3(0.0);\n #\tif AA > 1\n\tfor (int m = 0; m < AA; m++)\n\t\tfor (int n = 0; n < AA; n++) {\n\t\t\t// pixel coordinates\n\t\t\tvec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n\t\t\tvec2 p = (-iResolution.xy + 2.0 * (fragCoord + o)) / iResolution.y;\n # else\n\t\t\t\tvec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n # endif\n\t\t\t// camera\t\n\t\t\tvec3 ta = timefly(time) + vec3(0, 0.7, 0);\n\t\t\tvec3 ro = ta + vec3(-0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x),\n\t\t\t\t2.0 + 2.0 * mo.y,\n\t\t\t\t0.5 + 4.0 * sin(0.1 * time + 6.0 * mo.x));\n\t\t\t// camera-to-world transformation\n\t\t\tmat3 ca = setCamera(ro, ta, 0.0);\n\t\t\t// ray direction\n\t\t\tvec3 rd = ca * normalize(vec3(p.xy, 2.5));\n\t\t\t// render\t\n\t\t\tvec3 col = render(ro, rd);\n\t\t\t// gamma\n\t\t\tcol = pow(col, vec3(0.4545));\n\t\t\ttot += col;\n # if AA > 1\n\t\t}\n\ttot /= float(AA * AA);\n #\tendif\n\tfragColor = vec4(tot, 1.0);\n}", "image_inputs": [{"id": "Mll3zX", "previewfilepath": "https://soundcloud.com/clynos2/funny-melody", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/clynos2/funny-melody", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlsSWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlsSzH", "name": "N-gon prism distance field", "author": "zikbakguru", "description": "A super hexagon inspired shader I wrangled up today..\nIt's *HIGHLY* unoptimized, So expect some heavy load on your CPU :/\n", "tags": ["3d"], "likes": 2, "viewed": 373, "date": "1562097581", "time_retrieved": "2024-06-20T19:41:06.445585", "image_code": "/*\n\tZik's horryfiying SDF lab\n\tWarning : contains spaghetti code\n\n\tMaterial system heavily inspired from\n\thttps://www.shadertoy.com/view/ld3Gz2\n\n\t=======================================\n\tMMXIX ZIK\n*/\n#define DIST_MAX 999999999.9\n#define MAX_STEPS 128\n#define MIN_MARCH_DIST 0.001\n\n#define RGB(r,g,b) vec3(float(r)/255.0, float(g)/255.0, float(b)/255.0)\n\nconst vec3[] hexagon = vec3[](\n    \t\t\t\tRGB(176, 21, 34),\n                    RGB(163, 97, 26),\n                    RGB(163, 97, 26),\n    \t\t\t\tRGB(176, 21, 34)\n                   );\n\n/*\n\tHelper\n\thttp://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n*/\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n/*\n\tN-GON PRISM SDF FUNCTION\n\t========================================\n    Original SDF function for reference\n\n    float getPoly (vec2 uv, float gonSide, float gonAngle, float thickness, float percent)\n    {\n        // N-Gon from : https://thndl.com/square-shaped-shaders.html\n        float gonSlice = 6.28319 / gonSide;\n        float gonSize = percent;\n        float gonWidth = thickness;\n\n        vec2 deltaUV = vec2(0.5) - uv;\n        float deltaAngle = atan(deltaUV.x,deltaUV.y) + (gonAngle / PI);\n        float dist = cos(floor(.5 + deltaAngle / gonSlice) * gonSlice - deltaAngle) * length(deltaUV.xy) * 2.0;\n        return min(smoothstep(gonSize - gonWidth - 0.001, gonSize - gonWidth, dist), smoothstep(gonSize + gonWidth, gonSize + gonWidth - 0.001, dist));\n    }\n*/\n\n// Returns signed distance from n-gon prism\n// sdfPolyPrism (vec3 point, float sides, vec2(radius, thickness))\n// Based on iq's sdf functions : https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n#define PI 3.14\nfloat sdfPolyPrism (vec3 p, float sides, vec2 size)\n{\n    // N-Gon from : https://thndl.com/square-shaped-shaders.html\n    float gonSlice = 6.28319 / sides;\n    float deltaAngle = atan(p.x,p.y);\n    float dist = cos(floor(0.5 + deltaAngle / gonSlice) * gonSlice - deltaAngle) * length(p.xy) - size.x;\n    \n    vec2 d = vec2(dist, abs(p.z) - size.y);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// and for fun's sake and some wacky strip effect I've decided to make sdf for \"donut\" of n-gons\nfloat sdfPolyDonut (vec3 p, float sides, vec3 size)\n{\n    return max(-sdfPolyPrism(p, sides, vec2(size.x - size.z, size.y * 2.0)), sdfPolyPrism(p, sides, vec2(size.x + size.z, size.y)));\n}\n\n/*===================================================*/\n\n/*\n\tScene functions\n*/\n// returns distance, [out] vec4 mat\nfloat getSceneInfo (vec3 p, out vec3 mat, float time, float BPS)\n{\n    vec3 tmpMat;\n    float dist = DIST_MAX;\n    float tmpDist;\n    \n    float beatTime = mod(iTime, BPS);\n    float HalfbeatTime = mod(iTime, BPS * 0.5);\n    float FullbeatTime = 1.0 - pow(1.0 - (mod(iTime, BPS * 2.0) / (BPS * 2.0)), 2.0);\n    float beatIncr = floor(iTime / BPS);\n    \n    int colourIdx = int(mod(beatIncr, 2.0)) * 2;\n    vec3 hexColour = clamp(mix(hexagon[colourIdx], hexagon[colourIdx + 1], beatTime / BPS) + 0.6, 0.0, 1.0);\n    mat = vec3(hexColour);\n    \n    // Hexagon\n    float powerBeat = 1.0 - pow(1.0 - beatTime / BPS, 4.0);\n    float deltaHalfBeatTime = HalfbeatTime / (BPS * 0.5);\n    \n    float ang = iTime;\n   \tvec3 dp = (rotationMatrix(vec3(0.0, 0.0, 1.0), ang) * rotationMatrix(vec3(0.5, 0.5, 0.0), PI * 0.1 + sin(iTime * 0.5) * 0.25) * vec4(p.xyz, 0.0)).xyz;\n    \n    float hexSides = 4.0 + mod(floor((iTime * 0.2) / BPS), 3.0);\n    float hexSz = 64.0 + 12.0 * powerBeat;\n    float hexThick = 18.0 + sin(powerBeat * PI) * 16.0;\n    dist = min(dist, sdfPolyDonut(dp, hexSides, vec3(hexSz, hexThick, 2.5)));\n    dist = min(dist, sdfPolyDonut(dp, hexSides, vec3(mix(max(iResolution.x, iResolution.y) * 1.2, hexSz + 10.0, FullbeatTime), hexThick, 10.0)));\n    \n    float tmpdist = sdfPolyPrism(dp, hexSides, vec2(hexSz, 5.0));\n    if (tmpdist < dist)\n    {\n        dist = tmpdist;\n        mat = vec3(hexColour) * 0.2;\n    }\n    \n    return dist;\n}\n\nfloat getSceneDist (vec3 p, float time, float BPS)\n{\n    vec3 trash;\n    return getSceneInfo(p, trash, iTime, BPS);\n}\n\nvec3 getSceneNormal (vec3 p, vec3 lightPos, float time, float BPS)\n{\n    vec3 md = vec3(MIN_MARCH_DIST * 10.0, 0.0, 0.0);\n    vec3 delta = vec3(\n        getSceneDist(p + md.xyy, iTime, BPS) - getSceneDist(p - md.xyy, iTime, BPS), // = getScene(p + vec3(MIN_MARCH_DIST, 0, 0)) - getScene(p - vec3(MIN_MARCH_DIST, 0, 0)\n        getSceneDist(p + md.yxy, iTime, BPS) - getSceneDist(p - md.yxy, iTime, BPS),\n        getSceneDist(p + md.yyx, iTime, BPS) - getSceneDist(p - md.yyx, iTime, BPS)\n    );\n    \n    vec3 normal = normalize(delta);\n    return normal;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    // hexagon style bg flash\n    const float BPM = 130.0;\n    const float BPS = 60.0 / BPM;\n    const float BPS2 = 60.0 / (BPM * 0.5);\n    \n    float beatTime = mod(iTime, BPS);\n    float HalfbeatTime = mod(iTime, BPS * 0.5);\n    float beatIncr = floor(iTime / BPS2);\n    int colourIdx = int(mod(beatIncr, 2.0)) * 2;\n    \n    vec3 final = mix(hexagon[colourIdx], hexagon[colourIdx + 1], mod(iTime, BPS2) / BPS2);\n\t\n    // World info / camera settings\n    float time = iTime;\n    ivec2 intRes = ivec2(iResolution.xy);\n    vec3 camPos = vec3(0.0, 0.0, -256.0);\n    vec3 lightPos = vec3(0.0, 0.0, DIST_MAX);\n    \n    // We're doing some ortho camera in this shader so\n    // We don't have to worry about spooky projection math\n    vec2 screenPos = uv * iResolution.xy;\n    vec3 rayOrigin = camPos + vec3(screenPos.x - (iResolution.x * 0.5), screenPos.y - (iResolution.y * 0.5), 0.0);\n    vec3 rayPos = rayOrigin;\n    vec3 rayDir = vec3(0.0, 0.0, 1.0);\n\tvec3 mat;\n    \n    for (int rs=0; rs<=MAX_STEPS; rs++)\n    {\n        float dist = getSceneInfo(rayPos, mat, iTime, BPS);\n\n        if (dist < MIN_MARCH_DIST) // We hit something\n        {\n            vec3 normal = getSceneNormal(rayPos, lightPos, iTime, BPS);\n            \n            // Diffuse lighting\n            vec3 lightDelta = normalize(rayPos - lightPos);\n            float lightDot = dot(normal, lightDelta);\n            float diffLt = max(lightDot, 0.0) * 0.6 + 0.4;\n            \n            final.xyz = mat.xyz * diffLt;\n        }\n        else // Nope. Keep moving\n        {\n            rayPos += rayDir * dist;\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(final,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlsSzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlsSzM", "name": "Stained Lights", "author": "104", "description": "saturday 2D fun", "tags": ["2d"], "likes": 51, "viewed": 2375, "date": "1562439107", "time_retrieved": "2024-06-20T19:41:06.445585", "image_code": "// credits: Dave_Hoskins Hash functions: https://www.shadertoy.com/view/4djSRW\n\nconst float PI = 3.141592654;\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n// returns { RGB, dist to edge (0 = edge, 1 = center) }\nvec4 disco(vec2 uv) {\n    float v = abs(cos(uv.x * PI * 2.) + cos(uv.y *PI * 2.)) * .5;\n    uv.x -= .5;\n    vec3 cid2 = hash32(vec2(floor(uv.x - uv.y), floor(uv.x + uv.y))); // generate a color\n    return vec4(cid2, v);\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord)\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord / R;\n    uv.x *= R.x / R.y; // aspect correct\n\n    float t = iTime * .6; //t = 0.;\n    uv *= 8.;\n    uv -= vec2(t*.5, -t*.3);\n    \n    o = vec4(1);\n    for(float i = 1.; i <= 4.; ++i) {\n        uv /= i*.9;\n        vec4 d = disco(uv);\n        float curv = pow(d.a, .44-((1./i)*.3));\n        curv = pow(curv, .8+(d.b * 2.));\n        o *= clamp(d * curv,.35, 1.);\n        uv += t*(i+.3);\n    }\n    \n    // post\n    o = clamp(o,.0,1.);\n    vec2 N = (fragCoord / R )- .5;\n    o = 1.-pow(1.-o, vec4(30.));// curve\n    o.rgb += hash32(fragCoord + iTime).r*.07;//noise\n    o *= 1.1-smoothstep(.4,.405,abs(N.y));\n    o *= 1.0-dot(N,N*1.7);// vingette\n    o.a = 1.;\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlsSzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlsXD8", "name": "z^2+ke^(it)", "author": "zzggbb", "description": "coloring: https://www.iquilezles.org/www/articles/mset_smooth/mset_smooth.htm", "tags": ["fractal", "juliaset"], "likes": 2, "viewed": 263, "date": "1562798518", "time_retrieved": "2024-06-20T19:41:06.445585", "image_code": "#define N_ITERS 100.0\n#define PI 3.14159265\n\nvec3 color(float t) {    \n\tvec3 a = vec3(0.5);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(2.0*PI*(c*t + d));\n}\n\nvec2 cmul(vec2 c1, vec2 c2) {\n    return vec2(c1.x*c2.x - c1.y*c2.y, c1.x*c2.y + c1.y*c2.x);\n}\n\nfloat linscale(float x, float x1, float x2, float y1, float y2) {\n\treturn (y2-y1)/(x2-x1) * (x-x1) + y1;\n}\n\nfloat shade(vec2 z, float B) {\n    float t = iTime;\n    float i;\n    float K = linscale(sin(iTime), -1.0, 1.0, 0.1, 1.0);\n    for (i=0.0; i<N_ITERS; i++) {\n        // z[n+1] = z[n]^2 + K*e^(it)\n        z = cmul(z,z) + K*vec2(cos(t),sin(t));\n        if (length(z) > B) break;\n    }\n\tfloat sn = i - log(log(length(z))/log(B))/log(2.0);\n    return sn;\n}\n\nvec2 screen_coord(vec2 xy, vec2 dim) {\n    return (xy - 0.5*dim) / min(dim.x, dim.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = 2.0*screen_coord(fragCoord.xy, iResolution.xy);\n    float B = 256.0;\n    vec3 col = color(shade(uv, B));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlsXD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlsXDf", "name": "GEARBOX-ING", "author": "Hirai_worthless", "description": "tick", "tags": ["raymarching"], "likes": 4, "viewed": 112, "date": "1564496928", "time_retrieved": "2024-06-20T19:41:06.445585", "image_code": "\nmat2 genRotMat(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\nfloat PI = 3.14159265;\nfloat map(vec3 p){\n    p.x = fract(abs(p.x) / 1.5) * 1.5;\n    p.y = fract(abs(p.y) / 1.5) * 1.5;\n    p.z = fract(abs(p.z) / 0.5) * 0.5;\n    p -= vec3(0.75,0.75,0.25);\n\n    p.xy *= genRotMat(iTime * 2.0);\n\tfloat gear_out = max(length(p.xy) - 0.5 + 0.05 * floor(1.0 * sin(12.0 * atan(p.y,p.x)))\n              ,abs(p.z) - 0.05);\n    float gear_in = max(length(p.xy) - 0.2 + 0.05 * floor(1.0 * sin(12.0 * atan(p.y,p.x)))\n              ,abs(p.z) - 0.1);\n    return max(gear_out, -gear_in);\n}\n\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 96; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return vec4(getNormal(p),t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 R = iResolution,\n    r = normalize(vec3((2.*U - R.xy )/  R.y,1.2)),\n    o = vec3(0.75 + 0.75 * sin(iTime),0.75 + 0.75 * cos(iTime),-1.0 + iTime * 1.5);\n    vec4 data = trace(o,r);\n    vec3 n = vec3(data.xyz);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.05);\n    vec3 fc = t > 10000.0 ? vec3(0.8) : mix((vec3(data.x,data.y,data.z) + 1.0)/1.5\n                                            ,vec3(0.0), - pow(dot(n,r),1.0));\n    fc = mix(fc,vec3(1.0),1.0 - fog);\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlsXDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlsXDr", "name": "Symphony Lane", "author": "xorkiwi", "description": "Artsy looking shader with a slight equalizer vibe", "tags": ["wave", "moving", "artsy"], "likes": 1, "viewed": 123, "date": "1562597780", "time_retrieved": "2024-06-20T19:41:06.445585", "image_code": "/* Draws lines*/\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /* Aspect ratio */\n    vec2 uv = 2.0*(fragCoord.xy / iResolution.xy - vec2(0.5))*vec2(iResolution.x/iResolution.y,1);\n    /*  Texture color */\n   \tvec4 pebbles = texture(iChannel0,vec2(uv.x*iTime,uv.y*iTime));\n    \n    /* Line 1 = Static */\n    float line1 = sin(uv.x);\n    /* Line 2 = Moving */\n    float line2 = cos(uv.x*iTime);\n    vec3 colorline1 = vec3(line1);\n    vec3 colorline2 = vec3(line2);\n    \n    float plotline1 = plot(uv,line1);\n    float plotline2 = plot(uv,line2);\n\tcolorline1 = (pebbles.x-plotline1*iTime)*colorline1+plotline1*vec3(0.0,1.0,0.0);\n    colorline1 += (1.-plotline2*iTime)*colorline2+plotline2*vec3(0.0,1.0,0.0);\n\n    /* Draws and colors shader */\n    fragColor = vec4(vec3(.3*colorline1.x,.6*colorline1.y,colorline1.z),1.);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlsXDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlsXR4", "name": "atan fix v2", "author": "jorge2017a1", "description": "atan fix v2", "tags": ["atanfixv2"], "likes": 3, "viewed": 142, "date": "1562853134", "time_retrieved": "2024-06-20T19:41:06.445585", "image_code": "float hash21(vec2 p) {\n    // mod here\n    p = mod(p, 6.);\n    return fract(43758.5453123 * sin(dot(p, vec2(12.988, 243.233))));\n}\n\nfloat vnoise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3. - 2. * f);\n    return mix(mix(hash21(i), hash21(i + vec2(1, 0)), f.x),\n        mix(hash21(i + vec2(0, 1)), hash21(i + vec2(1, 1)), f.x), f.y);\n}\n\n\nvoid mainImage(out vec4 O, in vec2 I) {\n    \n    vec2 R = iResolution.xy;\n    vec2 uv = (2. * I - R.xy) / R.y;\n    \n    //uv *= 50.+iTime;\n    uv = vec2(atan(uv.x, uv.y), length(uv));\n    uv *= 5.+iTime*2.0;\n    \n    // scale here\n    float v = vnoise(uv * 6. / 6.283);\n    vec3 col = vec3(v);\n\n    \n    O = vec4(col, 1.);\n\n}\n\n\n//Old discontinous code\n/*\nfloat hash21(vec2 p) {\n    return fract(43758.5453123 * sin(dot(p, vec2(12.988, 243.233))));\n}\n\nfloat vnoise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3. - 2. * f);\n    return mix(mix(hash21(i), hash21(i + vec2(1, 0)), f.x),\n        mix(hash21(i + vec2(0, 1)), hash21(i + vec2(1, 1)), f.x), f.y);\n}\n\n\nvoid mainImage(out vec4 O, in vec2 I) {\n    \n    vec2 R = iResolution.xy;\n    vec2 uv = (2. * I - R.xy) / R.y;\n    \n    uv *= 5.;\n    uv = vec2(atan(uv.x, uv.y), length(uv));\n    \n    \n    float v = vnoise(uv);\n    vec3 col = vec3(v);\n\n    \n    O = vec4(col, 1.);\n\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlsXR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlsXRj", "name": "Quiet bottom", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 8, "viewed": 159, "date": "1563553268", "time_retrieved": "2024-06-20T19:41:06.451748", "image_code": "#define PI acos(-1.0)\n#define TAU PI*2.0\nvec2 rotate(vec2 p, float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a))*p;\n}\n\nvec3 rotate(vec3 p,vec3 axis,float theta)\n{\n    vec3 v = cross(axis,p), u = cross(v, axis);\n    return u * cos(theta) + v * sin(theta) + axis * dot(p, axis);   \n}\n\nvec2 pmod(vec2 p, float r)\n{\n    float a = mod(atan(p.y, p.x), TAU / r) - 0.5 * TAU / r;\n    return length(p) * vec2(-sin(a), cos(a));\n}\n\nvec3 hue(float t){\n\treturn cos((vec3(0,2,-2)/3.+t)*TAU)*.5+.5;\n}\n\nfloat map(vec3 p)\n{\n    p.xy = rotate(p.xy,iTime*0.05);\n    p.yz = rotate(p.yz,iTime*0.1);\n    for(int i=0;i<5;i++)\n    {\n        p.xy = pmod(p.xy,12.0);\n        p.y-=4.0;\n        p.yz = pmod(p.yz,16.0);\n        p.z-=6.8;\n    }\n    return dot(abs(p),rotate(normalize(vec3(2,1,3)),normalize(vec3(7,1,2)),1.8))-0.3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n \tvec3 ro=vec3(0,0,3.5);\n \tvec3 ta = vec3(1,0,0);\n \tta.xz=rotate(ta.xz,iTime*0.2);\n \t\n \tvec3 w=normalize(ta-ro);\n \tvec3 u=normalize(cross(w,vec3(0,1,0)));\n    vec3 rd=mat3(u,cross(u,w),w)*normalize(vec3(uv,2));\n    vec3 col = vec3(0);\n    float d,t=0.0;\n    for(float i=1.0;i>0.0;i-=1.0/80.0)\n    {\n     \tt+=d=map(ro+t*rd);\n        if(d<0.001)\n        {\n            col+=mix(vec3(1),hue(length(ro+t*rd)*0.1+iTime*0.1),0.6)*i*i;\n            break;\n        }\n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlsXRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlsXWB", "name": "在路上", "author": "bluedrop", "description": "on my way home", "tags": ["2d"], "likes": 2, "viewed": 276, "date": "1564135423", "time_retrieved": "2024-06-20T19:41:06.451748", "image_code": "float speed=.6;\n\nfloat mirrorlig(vec2 p)\n{\n\tp*=10.;\n \tfloat lig;\n \tp.x=abs(p.x);\n \tfloat ligdis=10.;\n \tfloat startoffset=.1;\n \tfor(float i=1.; i<6.; ++i)\n    {\t\n  \t\tfloat k= fract(iTime*speed+i*.2);\n  \t\tvec2 d = p-vec2(1.2,.5)*(k+startoffset)*ligdis;\n  \t\tfloat len= length(d)*10.;\n  \t\tlig+=asin((.05+k*.15)/len)*10.;\n \t}\n \tp*=10.;\n \tfor(float i=1.; i<6.; ++i)\n \t{\n  \t\tfloat k= fract(iTime*speed+i*.2);\n  \t\tvec2 d = p-vec2(1.2,.5)*(k+startoffset)*ligdis;\n  \t\tfloat len= length(d) * 10.;\n  \t\tlig+=asin((.05+k*.15)/len)*10.;\n \t}\n\n \treturn lig;\n}\n\nfloat mirrorligreflect(vec2 p)\n{\n \tp*=10.;\n \tfloat lig;\n \tp.x=abs(p.x);\n \tp.y*=-1.;\n \t//p.y-=1.5;\n \tfloat ligdis=10.;\n \tfloat startoffset=.1;\n \tp.y*=.6;\n \tfor(float i=1.; i<6.; ++i)\n \t{\n  \t\tfloat k= fract(iTime*speed+i*.2);\n  \t\tvec2 d = p-vec2(.6,.5)*(k+startoffset)*ligdis;\n  \t\tfloat len= length(d);\n  \t\tlig+=smoothstep(1.5*k,.0,len)*1.;\n \t}\n\n \treturn lig;\n}\n\n\nfloat side(vec2 p)\n{\n \tp.x=-abs(p.x);\n \tfloat rate = 1.5;\n \tfloat m=step(rate*p.x,p.y)*step(p.y,p.x+.02)*p.y;\n \tp.x*=rate;\n \treturn m;\n}\n\n\nfloat road(vec2 p)\n{\n \tp.y+=.6;\n \tp*=10.;\n \tp.x *= p.y*.5;\n \tfloat rd=.0;\n \tp.x = abs(p.x);\n \tp.y*=smoothstep(6., 5.9, p.y);\n\n \tfloat width=.2;\n \trd = smoothstep(width+.01,width,p.x);\n \trd*=smoothstep(.55,.51,fract(p.y+iTime*speed*5.));\n \tif(p.y<=0.)return 0.;\n \treturn rd;\n}\n\nvec3 sun(vec2 p)\n{\n \tfloat res;\n \tfloat len = length(p);\n \tfloat r = .2;\n \tfloat cir = smoothstep(r+.01,r,len);\n \tvec3 col = vec3(.5,.5,1.)*cir;\n \treturn col;\n}\n\n\nvec3 background(vec2 p)\n{\n \tp.y+=.5;\n\n \tvec3 upcol = vec3(0.,0.,0.1);\n \tvec3 downcol = vec3(.5,.1,0.05);\n \tvec3 col = mix(upcol, downcol, p.y);\n\n \t//sun\n \tp.y-=.5;\n \tfloat len = length(p);\n \tfloat r = .2;\n \tvec3 cir = smoothstep(r+.01,r,len)*vec3(1.,.3,.2);\n\n \tcol=mix(col,cir,p.y+.1);\n \treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n \tfloat lig = mirrorlig(uv);\n \tlig+=mirrorligreflect(uv);\n \tvec3 col = vec3(lig);\n\n \tcol+=road(uv);\n \tcol+=background(uv);\n \tcol+=side(uv);\n\n    fragColor = vec4(col, 1.0);\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlsXWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlsXWf", "name": "Exercise 1 | XOR", "author": "Blambder", "description": "My attempt to understand, how to implement XOR with arithmetic operators.", "tags": ["circle", "animation", "xor"], "likes": 1, "viewed": 270, "date": "1564485152", "time_retrieved": "2024-06-20T19:41:06.451748", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x -= .5;\n    \n    float speed = .043;\n    float waveDiff = .3;\n    \n    vec3 color = vec3(.0);\n    \n    for (float i = .0; i < .8; i+=.1) {\n        float spin = i * 4.;\n        vec2 toCenter = vec2(sin(iTime + spin) * .1 + .5, cos(iTime + spin) * .1 + .5)-uv;\n        float pct = length(toCenter);\n        \n        float waveShift = waveDiff + i * waveDiff;\n        float waveSpeed = iTime * (7. - i * waveDiff) * speed + waveShift;\n        \n        color = abs(\n            color \n            - vec3(\n                1. \n                - step(\n                    abs(\n                        sin(waveSpeed) * .015 + (.03 + i * .5)\n                    ), \n                    pct\n                )\n            )\n        );\n    }\n    \n\n\tfragColor = vec4( color * vec3(1.0, .0, .0), 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlsXWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlsXWH", "name": "Pieuvre stylisée", "author": "104", "description": "A stylized variation of the octopus from sben \"Illustrated Equations\" https://www.shadertoy.com/view/MtBGDW", "tags": ["octopus", "wildlife", "zoo", "cephalopod"], "likes": 6, "viewed": 163, "date": "1564600097", "time_retrieved": "2024-06-20T19:41:06.718270", "image_code": "// A stylized variation of the octopus from\n// sben \"Illustrated Equations\"\n// https://www.shadertoy.com/view/MtBGDW\n\nfloat octopus(vec2 p, float t){\n\tfloat ret = (p.y+length(p*p.x)-cos(t+p.y));\n\tret = (p.y+length(p*ret)-cos(t+p.y));\n\tret = (p.y+length(p*ret)-cos(t+p.y));\n\tret *= ret*.1;\n\treturn ret;\n}\nfloat dtoa(float d, float amount){\n    return 1. / clamp(d*amount, 1., amount);\n}\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 O, in vec2 P )\n{\n    vec2 V = P/iResolution.x-.5;\n    V.y += .1;\n    float t = iTime;\n    float d = octopus(V*15., t);\n    d -= .1;\n    float a = dtoa(d, 6. + rand(V.y)*2. + rand(V.x)*1.2);\n    float a2 = dtoa(-d, 15. + rand(V.y)*8. + rand(V.x)*4.);\n\n    O = mix(vec4(.95,.9,.7,0), vec4(.5,.1,.1,0), vec4(a));\n    O *= a2;\n\n    vec2 N = P/iResolution.xy-.5;\n    O += (rand(N*iTime)-.5)*.05;\n    O *= 1.-smoothstep(0.,.3,abs(N.x));\n    O *= 1.-smoothstep(0.,.7,abs(N.y));\n    O = pow(O,vec4(.7));\n    O.a = 1.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlsXWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlsXzf", "name": "Dolphin Hologram", "author": "96logda", "description": "Procedural generated Menger Sponge world with some dolphins.", "tags": ["procedural", "3d", "raymarching", "water", "underwater", "mengersponge", "dolphin", "hologram", "proceduralworld"], "likes": 2, "viewed": 185, "date": "1563785527", "time_retrieved": "2024-06-20T19:41:08.136713", "image_code": "//Copyright (c) 2019-07-13 - 2019-07-28 by Angelo Logahd\n//Portfolio: https://angelologahd.wixsite.com/portfolio\n//Based on https://www.iquilezles.org/www/articles/menger/menger.htm\n\n//Copyright (c) 2019-07-13 - 2019-07-16 by Angelo Logahd\n//My orginal version:\n//http://glslsandbox.com/e#56191.0\n\n#define PI\t\t\t\t\t3.14\n\n#define saturate(x) \t\tclamp(x, 0.0, 1.0)\n\n#define MENGER_ITERATIONS\t3\n#define SOFT_SHADOW_STEPS \t32\n\n#define INTERSECT_STEPS\t\t200\n#define INTERSECT_MIN_DIST\t0.001\n#define INTERSECT_MAX_DIST\t100.0\n\nconst float DOLPHIN_ROTATION_SPEED = 1.1;\n\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec2 rotate2D(vec2 p, float angle)\n{\n    float sRot = sin(angle);\n    float cRot = cos(angle);\n    return p * cRot + p.yx * sRot * vec2(-1.0, 1.0);\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r)\n{\n    float k0 = length(p / r);\n    return k0 * (k0 - 1.0) / length(p / (r * r));\n}\n\nfloat curDolphinAngle = 0.0;\nfloat deDolphin(vec3 p)\n{\n    vec3 q;\n    float dMin;\n    float dBodyA;\n    float dBodyB;\n    float dMouth;\n    float dFin;\n    float dFinTop;\n    float dHands;\n    float dEye;\n    float d;\n\n    p.x += 8.0;\n    p.z += 1.5;\n\n    curDolphinAngle = 0.08 * sin(PI * iTime * DOLPHIN_ROTATION_SPEED);\n\n    p.xz = rotate2D(p.xz, -1.5);\n    p.x = abs(p.x);  \n    p.z -= 3.0;\n    p.yz = rotate2D(p.yz, curDolphinAngle);\n    q = p - vec3(0.0, 0.0, -0.65);\n    dBodyA = sdEllipsoid(q, vec3 (0.7, 0.8, 2.4));\n\t\n    q = p;\n    q.z -= -1.8;\n    q.yz = rotate2D(q.yz, curDolphinAngle);\n    q.z -= -1.6;\n    dBodyB = sdEllipsoid(q, vec3(0.40, 0.5, 2.5));\n\t\n    q.z -= -2.2;\n    q.xy = rotate2D(q.xy, 2.0 * curDolphinAngle);\n    q.xz -= vec2(0.5, -0.5);\n    q.yz = rotate2D(q.yz, 0.4);\n    dFin = sdEllipsoid(q, vec3(0.7, 0.05, 0.3));\n\t\n    q = p;\n    q.xy = rotate2D(q.xy, 2.0 * curDolphinAngle * 1.25);\n    q.yz -= vec2(-0.3, 0.1);\n    dHands = sdEllipsoid(q, vec3(1.8, 0.07, 0.4));\n\t\n    dFinTop = 1.0;\n    q = p;\n    q.y -= 0.8;\n    q.z -= -1.5;\n    q.yz = rotate2D(q.yz, 0.5);\n    q.xz = rotate2D(q.xz, 1.0);\n    dFinTop = sdEllipsoid(q, vec3(0.2, 0.6, 0.1));\n\t\n    dMin = smin(dBodyA, dBodyB,  0.1);\n    dMin = smin(dMin,   dFin,    0.1);\n    dMin = smin(dMin,   dHands,  0.1);\n    dMin = smin(dMin,   dFinTop, 0.1);\n    return dMin;\n}\n\nvec4 map(in vec3 p)\n{\t\n    p.xz = mod(p.xz + 1.0, 2.0) - 1.0;\n    p.y  = mod(p.y  + 1.0, 2.0) - 1.0;\n\t\n    float d = sdEllipsoid(p, vec3(1.0));\n    vec4 res = vec4(d, 1.0, 0.0, 0.0);\n\t\n    float s = 1.0;\n    for(int i = 0; i < MENGER_ITERATIONS; ++i)\n    { \n        vec3 a = mod(p * s, 2.0) - 1.0;\n        s *= 7.0;\n        vec3 r = abs(1.0 - 3.0 * abs(a));\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 0.5) / s;\n\n        if(c > d)\n        {\n            d = c;\n            res = vec4(d, min(res.y, 0.3 * da * db * dc), 0.0, 1.0);\n        }\n    }\n\n    return res;\n}\n\nvec4 intersect(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n    vec4 h = vec4(1.0);\n    for (int i = 0; i < INTERSECT_STEPS; i++ )\n    {\n\t\tif(h.x < INTERSECT_MIN_DIST || t > INTERSECT_MAX_DIST) \n\t\t{\n\t    \tbreak;\n\t\t}\n\t\n        h = map(ro + rd * t);\n        res = vec4(t, h.yzw);\n        t += h.x;\n    }\n\n    if (t > INTERSECT_MAX_DIST) \n    {\n\t\tres = vec4(-1.0);\n    }\n    \n    return res;\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < SOFT_SHADOW_STEPS; ++i)\n    {\n\t\tvec3 pos = ro + rd * t;\n        float h = map(pos).x;\n        res = min(res, float(SOFT_SHADOW_STEPS) * h / t);\n        if(res < 0.001)\n\t\t{\n\t    \tbreak;\n\t\t}\n        t += clamp(h, 0.01, 0.2);\n    }\n    return saturate(res);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    vec3 n;\n    n.x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    n.y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    n.z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n    return normalize(n);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float k)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < SOFT_SHADOW_STEPS; ++i)\n    {\n\t\tvec3 pos = ro + rd * t;\n        float h = map(pos).y;\n        res = min(res, k * h / t);\n        if(res < 0.001)\n\t\t{\n\t    \tbreak;\n    \t}\n        t += clamp(h, 0.01, 0.2);\n    }\n    return saturate(res);\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd)\n{\n     float tmin = 0.0;\n     float tmax = 40.0;\n\t\n     float precis = 0.001;\n     float t = tmin;\n     float m = -1.0;\n     for (int i = 0; i < 100; ++i)\n     {\n    \t float res = deDolphin(ro + rd * t);\n    \t if (res < precis || t > tmax)\n         {\n             break;\n         }\n   \t \t t += res;\n    \t m = res;\n     }\n\n     if (t > tmax)\n     {\n\t \tm = -1.0;\n     }\n\t\n     return vec2(t, m);\n}\n\nvec3 renderDolphin(in vec3 ro, in vec3 rd)\n{ \n    vec3 color = vec3(0.0);\t\n    vec2 res = castRay(ro, rd);\n    if (res.y > -0.5)\n    {\n\t \tconst vec3 light = vec3(0.5, 0.5, -0.5);\n\t\t\n\t \tvec3 pos = ro + res.x * rd;\n\t\n\t \tfloat red   = clamp(sin(iTime * 0.8), 0.2, 0.8);\n\t \tfloat green = clamp(cos(iTime * 0.4), 0.2, 0.8);\n\t \tfloat blue  = clamp(sin(iTime * 0.2), 0.2, 0.8);\n\t    \n        vec3 baseColor = vec3(red, green, blue);\n\t \tvec3 ambient = vec3(0.5) * baseColor;\n\t \tvec3 normal = calcNormal(pos);\n\t\t\n\t \tfloat shadow = softshadow(pos + 0.001 * normal, light, 32.0);\t\n\t \tvec3 diffuse = baseColor * shadow * vec3(0.2, 0.0, 10.0);\n\t\t\n\t \tcolor = diffuse + ambient;\n    }\t\n    return color;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 color = vec3(0.5);\n    vec4 res = intersect(ro,rd);\n    if(res.x > 0.0)\n    {\n        const vec3 light = vec3(0.0, 0.0, -0.5);\n\t\t\n\t\tvec3 pos = ro + res.x * rd;\n\t\n        vec3 baseColor = vec3(0.0, 0.2, 0.6);\n\t\tvec3 ambient = vec3(0.2) * baseColor;\n\t\t\n\t\tvec3 normal = calcNormal(pos);\n\t\tvec3 reflection = reflect(rd, normal);\n\t\n\t\tfloat occ = res.y;\n\t\tfloat shadow = softshadow(pos + 0.001 * normal, light);\n\t\n\t\tvec3 diffuse = baseColor * shadow * occ;\t\n\t\tcolor = diffuse + ambient;\n    }\n    \n    color += renderDolphin(ro, rd);\n    color += renderDolphin(ro + vec3(10.5, -1.3, 4.5), rd);\n    color += renderDolphin(ro + vec3(15.5, -1.3, -4.5), rd);\n\n    color += vec3(0.0, 0.05, 0.20);\n    return pow(color, vec3(0.4545));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 p = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\t\n    // camera\n    vec3 ro = vec3(12.25, 2.9, -2.0);\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n\n    ro.x -= iTime * 0.1; //Camera / Ray moving\n\t\n \tvec3 color = render(ro + vec3(0.0, -1.0, 0.0), rd);    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlsXzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlsXzM", "name": "Runny Ink", "author": "104", "description": "I just want to touch it.", "tags": ["2d", "plasma", "paint", "ink"], "likes": 6, "viewed": 172, "date": "1564433982", "time_retrieved": "2024-06-20T19:41:08.136713", "image_code": "\nconst float PI = 3.141592654;\n\nvec3 hash32(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec4 disco(vec2 uv) {\n    float v = abs(cos(uv.x * PI * 2.) + cos(uv.y *PI * 2.)) * .5;\n    uv.x -= .5;\n    vec3 cid2 = hash32(vec2(floor(uv.x - uv.y), floor(uv.x + uv.y)));\n    return vec4(cid2, v);\n}\nfloat nsin(float t) {return sin(t)*.5+.5; }\n\nvoid mainImage( out vec4 o, in vec2 fragCoord)\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord / R - .5;\n    uv.x *= R.x / R.y;\n\n    float t = (iTime + 129.) * .6; //t = 0.;\n    uv = uv.yx;\n    uv *= 2.+sin(t)*.2;\n    uv.x += t*.5;\n    \n    o = vec4(1);\n    float sgn = -1.;\n    for(float i = 1.; i <= 5.; ++i) {\n        vec4 d = disco(uv);\n        float curv = pow(d.a, .5-((1./i)*.3));\n        curv = pow(curv, .8+(d.b * 2.));\n        curv = smoothstep(nsin(t)*.3+.2,.8,curv);\n        o += sgn * d * curv;\n        o *= d.a;\n        sgn = -sgn;\n        uv += 100.;// move to a different cell\n        uv += sin(d.ar*7.33+t*1.77)*(nsin(t*.7)*.1+.04);\n    }\n    \n    // post\n   \to.gb *= vec2(1.,.5);//tint\n    vec2 N = (fragCoord / R )- .5;\n    o = clamp(o,.0,1.);\n    o = pow(o, vec4(.2));\n    o.rgb -= hash32(fragCoord + iTime).r*(1./255.);\n    \n    N = pow(abs(N), vec2(2.5));\n    N *= 7.;\n    o *= 1.5-length(N);// ving\n    o = clamp(o,.0,1.);\n    o.a = 1.;\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlsXzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlXSD7", "name": "Link - distance", "author": "iq", "description": "Euclidean distance to chain link. After elongating a torus and simplifying thing, we get a branch free and compact sdLink() with a minimal number of square roots and operations.", "tags": ["3d", "sdf", "distancefunction", "distance", "link"], "likes": 24, "viewed": 1564, "date": "1563181105", "time_retrieved": "2024-06-20T19:41:09.142731", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Euclidean distance to chain link. After elongating a torus with the technique\n// in this article https://www.shadertoy.com/view/Ml3fWj, you can simplify a few\n// things, producing a branch free and compact sdLink() with a minimal number of\n// square roots and operations.\n\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\nfloat sdLink( in vec3 p, in float le, in float r1, in float r2 )\n{\n    vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat map( in vec3 pos )\n{\n    // animate\n    pos.y += 0.5*iTime;\n\n    // paramteres\n    const float le = 0.13, r1 = 0.2, r2 = 0.09;\n    \n    // make a chain out of sdLink's\n    vec3 a = pos; a.y = fract(a.y    )-0.5;\n    vec3 b = pos; b.y = fract(b.y+0.5)-0.5;\n    \n    // evaluate two links\n    return min(sdLink(a.xyz,le,r1,r2),\n               sdLink(b.zyx,le,r1,r2));\n}\n\n/*\n// build the chain directly, it saves one of four square roots\n// over using sdLinks()\nfloat sdChain( in vec3 pos, in float le, in float r1, in float r2 )\n{\n    float ya = max(abs(fract(pos.y    )-0.5)-le,0.0);\n    float yb = max(abs(fract(pos.y+0.5)-0.5)-le,0.0);\n\n    float la = ya*ya - 2.0*r1*sqrt(pos.x*pos.x+ya*ya);\n    float lb = yb*yb - 2.0*r1*sqrt(pos.z*pos.z+yb*yb);\n    \n    return sqrt(dot(pos.xz,pos.xz) + r1*r1 + min(la,lb)) - r2;\n}\n*/\n\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.15*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - occ*1.5, 0.0, 1.0 );\n}\n\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.7*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.2, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 lig = normalize(vec3(0.6,0.2,0.4));\n            vec3 hal = normalize(lig-rd);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            float occ = calcOcclusion( pos, nor );\n            if( dif>0.001 ) dif *= calcSoftshadow( pos, lig, 0.01, 1.0 );\n            float spe = pow(clamp(dot(nor,hal),0.0,1.0),16.0)*dif*(0.04+0.96*pow(clamp(1.0-dot(hal,-rd),0.0,1.0),5.0));\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col =  vec3(0.5,1.0,1.2)*amb*occ;\n            col += vec3(2.8,2.2,1.8)*dif;\n            \n            col *= 0.2;\n            \n            col += vec3(2.8,2.2,1.8)*spe*3.0;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/wlXSD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlXSDB", "name": "GradationPractice001", "author": "Hirai_worthless", "description": "???", "tags": ["gradation"], "likes": 7, "viewed": 92, "date": "1564071570", "time_retrieved": "2024-06-20T19:41:09.269996", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float x = floor(uv.x * 10.0) * 0.1;\n    float y = floor((uv.x * (17.3 / 2.0) + uv.y * 5.0)) * 0.1;\n    float z = floor((-uv.x * (17.3 / 2.0) + uv.y * 5.0)) * 0.1;\n    vec3 col = 0.5 + 0.5*cos(iTime * 2.0 + 2.0 * vec3(x,y,z)+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlXSDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlXSR2", "name": "Toothsome Triangles", "author": "104", "description": "Snack on these they are healthy", "tags": ["2d", "triangle", "treat"], "likes": 9, "viewed": 167, "date": "1563905832", "time_retrieved": "2024-06-20T19:41:09.276054", "image_code": "const float PI = 3.14159;\nconst float PI2 = PI*2.;\n\nvec3 dtoa(float d, vec3 amount){\n    return vec3(1. / clamp(d*amount, vec3(1), amount));\n}\nmat2 rot2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\nfloat nsin(float x) {\n    return sin(x)*.5+.5;\n}\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.y += .133;\n    uv *= 2.;\n    float t = iTime*.5;\n    float centerDist = sqrt(3.)/3.;\n    float sd = 1.;\n    float sgn = 1.;\n    vec2 uv2 = uv;\n    for (float i = 0.; i < 20.; ++ i) {\n        float a = t*(sgn*=-1.);\n        float sd2 = sdEquilateralTriangle(uv2*.9*rot2D(a)+vec2(0,centerDist));\n    \tsd2 = opSubtraction(sd2, sdEquilateralTriangle(uv2+vec2(0,centerDist)));\n        sd = opUnion(sd, sd2);\n        //uv2 *= nsin(t*1.22)*.5+1.5;\n        uv2 *= 1.5;\n    }\n\n    o.rgb = dtoa(sd, vec3(50,400,400)) * vec3(.9,.8,.5);\n    o.rgb += (hash32(fragCoord+t)-.5)*.1;\n\n    vec2 N = fragCoord / iResolution.xy-.5;\n    o.rgb += dot(N,N) * vec3(0,1,1);\n    o.a = 1.;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlXSR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlXSR8", "name": "multibrot", "author": "nicknytko", "description": "multibrot set", "tags": ["mandelbrot"], "likes": 4, "viewed": 122, "date": "1561947468", "time_retrieved": "2024-06-20T19:41:09.276054", "image_code": "const int max_iter = 500;\nconst float min_pow = 0.0;\nconst float max_pow = 10.0;\nconst float mid_pow = (min_pow + max_pow) * 0.5;\n\nvec2 comp_pow(vec2 c, float n) {\n    /*demoivre*/\n    float theta = atan(c.y, c.x);\n    float absv = sqrt((c.x * c.x) + (c.y * c.y));\n    return pow(absv, n) * vec2(cos(theta * n), sin(theta * n));\n}\n\nfloat mandelbrot(vec2 c, float n, int maxIter) {\n    vec2 z = vec2(0.0, 0.0);\n    for (int i = 0; i < maxIter; i++) {\n        vec2 zn = comp_pow(z, n) + c;\n        if (zn.x > 2.0 || zn.y > 2.0) {\n\t        return float(i) / float(maxIter);\n\t    }\n        z = zn;\n    }\n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 coord = ((fragCoord / iResolution.xy) * vec2(3.5, 2.0)) - vec2(2.0, 1);\n    float power = mid_pow - cos(iTime * 0.1) * mid_pow;\n    float val = sqrt(mandelbrot(coord, power, max_iter));\n    fragColor = vec4(val, val, val, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlXSR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlXSW4", "name": "Test3_Cartoonball", "author": "Newyang", "description": "球，卡通风格渲染", "tags": [], "likes": 2, "viewed": 245, "date": "1562834328", "time_retrieved": "2024-06-20T19:41:09.815496", "image_code": "const int MAX_ITER = 100;\nconst float MAX_DIST = 20.0; \nconst float EPSILON = 0.001; \n\nvec3 cameraOrigin = vec3(2.0, 3.0, 2.0);\nvec3 cameraTarget = vec3(0.0, 0.0, 0.0);\nvec3 upDirection = vec3(0.0, 1.0, 0.0);\n\nvec4 shapeColor = vec4(0.99, 0.5, 1.0, 1.0);\nfloat specularPower = 16.0;\n\n// a sphere is defined as the position and a radius \nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat distfunc(vec3 pos)\n{\n    return sphere(pos, 2.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n    vec3 cameraUp = cross(cameraDir, cameraRight);    \n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy; // rescale screenPos to be from -1 to 1\n    \n    screenPos.x *= iResolution.x / iResolution.y; // now scale it by the aspect ratio\n    \n    // ray from camera position to screen pixel\n    vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n    \n    // The raymarching loop\n    float totalDist = 0.0;\n    vec3 pos = cameraOrigin;\n    float dist = EPSILON;\n    \n    // trying to find a point of intersection \n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        // Either we've hit the object or hit nothing at all, either way we should break out of the loop\n        if (dist < EPSILON || totalDist > MAX_DIST)\n        break; // If you use windows and the shader isn't working properly, change this to continue;\n    \n        dist = distfunc(pos); // Evalulate the distance at the current point\n        totalDist += dist;\n        pos += dist * rayDir; // Advance the point forwards in the ray direction by the distance\n    }\n    \n    if(dist < EPSILON) \n    {\n        // calculate lighting\n        \n        // need to find the normal of the surface \n        // using distance, can calculate this by sampling a few points\n        vec2 eps = vec2(0.0, EPSILON);\n        // creating points that are +/- the pos in x/y/z \n        // (since eps.x is 0 and eps.y is actual EPSILON)\n        vec3 normal = normalize(vec3(\n            distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n            distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n            distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)\n        ));\n        \n        \n        vec3 lightPos = vec3(9.0*cos(iTime*3.0),3.0*sin(iTime*3.0),9.0);\n        \n        // the unlit colour\n        vec3 ambientColor = vec3(0.2, 0.0, 0.0);\n        // the lit colour of the shape \n        vec3 diffuseColor = vec3(0.3, 0.3, 0.3);\n        // the reflection highlight\n        vec3 specColor = vec3(1.0, 1.0, 1.0);\n        \n        // light direction is the light position to the vertex position\n        vec3 lightDir = normalize(lightPos - pos);\n        \n        float lambertian = max(dot(lightDir, normal), 0.0);\n        vec3 worldHalfDir = normalize(lightDir + cameraDir);\n        float spec = dot(worldHalfDir,normal);\n        \n        float s = step(0.05,lambertian);\n        float t = step(0.001,0.1*spec);\n        float e = step(0.3,lambertian);\n        float p = step(0.5,lambertian);\n        \n        float specular = 0.3;\n             \n        fragColor = vec4(ambientColor +\n                      s * diffuseColor +\n                      e * vec3(0.1,0.1,0.1) +\n                      p * vec3(0.1,0.1,0.1) +  \n                      p * t * specular * specColor, 1.0);\n    }\n       \n    else \n    {\n        fragColor = vec4(0.3,0.3,0.3,1.0);\n    }\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlXSW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlXSWB", "name": "good for health", "author": "bostelk", "description": "incomplete akira tribute.", "tags": ["junk"], "likes": 0, "viewed": 95, "date": "1564022233", "time_retrieved": "2024-06-20T19:41:11.555224", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives. More info here:\n//\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 2   // make this 2 or 3 for antialiasing\n#define saturate(v) clamp(v, 0., 1.)\n#define rand(v) fract(sin(dot(v ,vec2(12.9898,78.233))) * 43758.5453)\n#define HASHSCALE1 .1031\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat opRep( in float p, in float c)\n{\n    return mod(p,c)+0.5*c;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    pos.z -= 1.5;\n    pos.y -= 1.0;\n    \n    pos.y += 12.0*(iTime*.125); \n    \n    int index = int(ceil(pos.z / 1.2)) + (int(ceil(pos.y / 1.2)));\n    \n    pos.z = mod(pos.z, 1.2)+0.3*1.2;     \n    pos.y = mod(pos.y, 1.2)+0.5*1.2;\n    \n    vec3 axis = vec3(hash12(vec2(42, index)),hash12(vec2(99, index)),hash12(vec2(22, index)));\n    mat4 r = rotationMatrix(axis, 6.28 * fract(iTime * 0.1));\n    vec3 t = (r*vec4(0.0,0.5,0.0,0.)).xyz;\n    \n    vec3 pos0 = pos-vec3( -0.0 ,1.,1.0);\n    float halfsize = 0.35;\n    float halfdistance = distance(pos0, t*halfsize); \n    float d = sdCapsule(   \n        pos0,\n        -t*halfsize,\n        t*halfsize, 0.1  );\n   \n    float m = halfdistance / halfsize;\n    if (index % 2 == 0)\n    {\n        m+= 2.;\n    }\n    res = opU( res, vec2(d , m) );\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n  \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.0,0.0), rd, vec3(100.) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 render(in vec3 bg, in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    vec3 col = bg;  \n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    \n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material\n        vec3 c1 =  vec3(1.,1.,1.);\n        if (m > 2.)\n        {\n           c1 =  vec3(1.,0.,0.);\n           m -=2.;\n        }\n        col = mix(vec3(0.,0.,1.), c1, step(m, 0.5));\n\n        // lighting\n\t\tvec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n       \n\t\tvec3 lin = vec3(0.0);\n        lin += 3.80*dif*vec3(1.30,1.00,0.70);\n        lin += 0.55*amb*vec3(0.40,0.60,1.15);\n        lin += 0.85*dom*vec3(0.40,0.60,1.30);\n        lin += 0.55*bac*vec3(0.25,0.25,0.25);\n        lin += 0.25*fre*vec3(1.00,1.00,1.00);\n\t\tcol = col*lin;\n\t\tcol += 7.00*spe*vec3(1.10,0.90,0.70);\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord -iResolution.xy)/iResolution.xy.y;\n    vec3 bg = vec3(0.7,0.,0.);\n    \n    // camera\t\n    vec3 ro = vec3( 4., 1.2, 0.0);\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.0) );\n\n         // ray differentials\n        vec2 px = (-iResolution.xy+2.0*(fragCoord.xy+vec2(1.0,0.0)))/iResolution.y;\n        vec2 py = (-iResolution.xy+2.0*(fragCoord.xy+vec2(0.0,1.0)))/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,2.0) );\n        vec3 rdy = ca * normalize( vec3(py,2.0) );\n        \n        // render\t\n        vec3 col = render( bg.rgb, ro, rd, rdx, rdy );\n        \n        float fogStart = 0.2;\n        float d1 = max(0., (iResolution.y*0.05-fragCoord.y));\n        float d2 = max(0., (fragCoord.y-iResolution.y*0.95));\n        float fogDistance = d1 + d2;\n        float fogDensity = 0.02;\n        float fogAmount =1.0- exp( -fogDistance*fogDensity );\n        vec3  fogColor = bg.rgb;\n        col = mix( col, fogColor, fogAmount );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n        \n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif   \n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/WlXSWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlXSWn", "name": "Scatterform1B - Unfold ", "author": "audiopixel", "description": "Single shot", "tags": ["3d", "raymarching", "distancefield"], "likes": 6, "viewed": 362, "date": "1562533636", "time_retrieved": "2024-06-20T19:41:11.561276", "image_code": "// Created by Hepp Maccoy 2019, hepp@audiopixel.com\n// Built with Haxademic+Scatterform, github.com/cacheflowe/haxademic\n// Distance functions by Inigo Quilez, iquilezles.org\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PI = 3.14159265358979323846;\nfloat d1;\nfloat t1;\n\nfloat soc(vec3 p) {\n    vec3 n = normalize(sign(p+1e6));\n    return min(min(dot(p.xy, n.xy), dot(p.yz, n.yz)), dot(p.xz, n.xz));\n}\n\nfloat sinc(float x, float k) {\n    float a = PI * (float(k)*x-1.0);\n    return sin(a)/a;\n}\n\nmat2 r2d(float a) {\n    float sa=sin(a);\n    float ca=cos(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nvec2 mo(inout vec2 p, vec2 d) {\n    vec2 q = p;\n    q.x = abs(q.x) - d.x;\n    q.y = abs(q.y) - d.y;\n    if (q.y > q.x) q = q.yx;\n    return q;\n}\n\nvec2 amod(vec2 p, float m) {\n    float a=mod(atan(p.x,p.y), m)-m*.5;\n    return vec2(cos(a), sin(a))*length(p);\n}\n\nfloat map(vec3 p) {\n    float d = 1.0;\n    float a = abs(p.y);\n    p.yz *= r2d(sign(a) * 1.2);\n    p.xz *= r2d(sign(a) * 0.0);\n    p.xz = mo(p.xz, vec2((-d1 * 35.8) - 1., (d1 * 65.8) - 1.));\n    p.zx = mo(p.xz, vec2((d1 * 2.) - 4., 0.0282));\n    p.xz = amod(p.xz, (PI * 1.0) / 2.0);\n    p.xz = max(abs(p.xz) - 2.2569, -1.29);\n    p.x = mod(p.x, 0.3198 + (d1 * .21))-(0.3198 + (d1 * .21) *.5);\n    p.y = mod(p.y + -sin(t1 * .023) * 1.2, 6.752) - 5.;\n    d = min(d, soc(max(abs(p) - 0.172, 0.0096)));\n    return (length(p * 0.0) - 0.0) * 1.0 - (d * -1.0);\n}\n\nvec3 calcNormal(in vec3 p, in int type, in float m1, in float m2, in float m3) {\n    vec2 e = vec2(m2, m3) * m1;\n    return normalize( e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx) );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    t1 = iTime;\n    //t1 = (sin((iTime + 174.) * .1) * 15.) + 21.;\n    d1 = sin(t1 * .013);\n    vec2 st = (fragCoord.xy / iResolution.xy) * 2.05 - 1.;\n    st.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(st, 3.7287);\n    vec3 rd = normalize(vec3(st + vec2(0.), -0.8572));\n    vec3 mp;\n    mp = ro;\n    float md;\n    for(int i=0; i<45; i++) {\n        md = map(mp);\n        mp += (rd * .6 + (-d1 * .1)) * md;\n    }\n    float b = length(ro - mp);\n    float dA = 0.4799 - (b * 0.02) * 0.5232;\n    float dB = 0.479 - (b * 0.03) * 0.523;\n    dA = sinc(dA, 1.0);\n    dB = sinc(dB, 1.0);\n    vec3 p = ro + rd * (mp);\n    vec3 lt = vec3(0.0, 0.0, 0.0);\n    vec3 l;\n    vec3 nm = calcNormal(p, 0, 4.5201, 1.0, -1.0);\n    if (md < 0.015) {\n        float dif = clamp(dot(nm, normalize(lt - p)), 0., 1.);\n        dif *= 5.0 / dot(lt - p, lt - p);\n        l = vec3(pow(dif, 0.1854));\n    }\n    vec3 lt2 = vec3(0.0, 0.0, 13.0);\n    vec3 nm2 = calcNormal(p, 0, 2.8964, -1.0, -1.339);\n    float dif2 = clamp(dot(nm2, normalize(lt2 - p)), 0., 1.);\n    dif2 *= 4.0 / dot(lt2 - p, lt2 - p);\n    vec3 lb = vec3(pow(dif2, 0.4545));\n    float src1 = 1. * 0.0;\n    float src2 = nm.x;\n    float src3 = l.x;\n    float src4 = lb.x * 0.4;\n    vec3 c;\n    c = mix(vec3(0.0), vec3(0.6117647,0.019607844,0.8627451), src1) + mix(vec3(0.0), vec3(1.0,0.0,0.0), src2);\n    c = c + mix(vec3(0.0), vec3(0.31764707,0.5568628,1.0), src3);\n    c = c + mix(vec3(0.0), vec3(0.05490196,0.0,1.0), src4);\n    fragColor = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlXSWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlXSzs", "name": "RayMarching013:Glitch", "author": "Hirai_worthless", "description": "noisy.", "tags": ["raymarching"], "likes": 1, "viewed": 182, "date": "1563901875", "time_retrieved": "2024-06-20T19:41:11.561276", "image_code": "float PI = 3.14159265;\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvec2 path(float z){\n    float x = sin(z) + 2.0 * cos(z * 0.3) - 1.5 * sin(z * 0.12345);\n    float y = cos(z) + 1.5 * sin(z * 0.3) + 2.0 * cos(z * 0.12345);\n    return vec2(x,y);\n}\n\nfloat map1(vec3 p){\n\t//p = fract(p/2.0) * 6.0 - 3.0;\n    vec2 o = path(p.z) / 4.0;\n\tfloat tBase = max(-length(p.xy - o) + 1.0 \n                      //* (1.0 + sin(p.z) * 0.5)\n                      ,length(p.xy - o) - 1.2 \n                      //* (1.0 + sin(p.z) * 0.5)\n                     );\n    float tdonut = max(-length(p.xy - o) + 0.5\n                      ,length(p.xy - o) - 0.6 \n                     );\n    tdonut = max(tdonut,abs(fract(p.z) - 0.5));\n    float tTube1 = length(p.xy - o + vec2(0.3,0.3)) - 0.025;\n    float tTube2 = length(p.xy - o + vec2(0.5,0.2)) - 0.025;\n    float tTube3 = length(p.xy - o + vec2(0.2,0.5)) - 0.025;    \n    float tTube4 = length(p.xy - o + vec2(-0.3,-0.3)) - 0.025;\n    float tTube5 = length(p.xy - o + vec2(-0.5,-0.2)) - 0.025;\n    float tTube6 = length(p.xy - o + vec2(-0.2,-0.5)) - 0.025;\n    float tTube = min(min(tTube1,tTube2),tTube3);\n    tTube = min(min(tTube,tTube4),min(tTube5,tTube6));\n\n    float bound = 2.0;\n    float tSplit = (fract(p.z)-0.5);\n    tSplit = min(tSplit, abs((p.x - o.x))-0.15);\n    tSplit = min(tSplit, abs((p.y - o.y))-0.15);\n\n    return min(min(max(tBase,-tSplit),tdonut),tTube);\n}\nfloat temp(){\n    return (floor(iTime) + min(sin(fract(iTime) * PI / 2.0) * 2.0,1.0));\n}\nfloat map2(vec3 p){\n    p = mod(abs(p), 1.5) - 0.75;\n\n    float rot = temp() * PI / 2.0;\n    float size = sin(rot * 2.0 + PI / 4.0);\n    p.xz *= mat2(cos(rot),-sin(rot),sin(rot),cos(rot));\n    float sphere = length(p) - 0.5;\n\tfloat cube = max(max(abs(p.x) - 0.5,abs(p.y) - 0.5),abs(p.z) - 0.5);\n    float obj = mix(sphere,cube,0.5 - size * 0.5);\n    float poleY = length(p.xz) - 0.1 * size;\n    float holes = 100000000.0;\n    for(float i = -0.25; i < 0.50; i += 0.25){\n        for(float j = -0.25; j < 0.50; j += 0.25){\n        \tfloat holeZ = length(p.xy - vec2(i,j)) - 0.075 * (1.0 - size);\n    \t\tfloat holeX = length(p.yz - vec2(i,j)) - 0.075 * (1.0 - size);\n    \t\tholes = min(holes,holeX);\n        \tholes = min(holes,holeZ);\n        }\n    }\n\n    return max(min(obj,poleY),-holes);\n\t\n\n}\n\nfloat trace1 (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    for(int i = 0; i < 32; ++i){\n        vec3 p = o + r * t;\n        float d = map1(p);\n        t += d * 0.5;\n    }\n    return t;\n}\nfloat trace2 (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    for(int i = 0; i < 32; ++i){\n        vec3 p = o + r * t;\n        float d = map2(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float PI = 3.14159265;\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv,1.0));\n    \n    float z = iTime * 4.0 ;\n\tvec2 a = path(z);\n    vec3 o = vec3(a / 4.0,z);\n    float t1 = trace1(o,r);\n    float t2 = trace2(o,r);\n\n    float fog1 = 1.0 / (1.0 + t1 * t1 * 0.2); \n    float fog2 = 1.0 / (1.0 + t2 * t2 * 0.2);\n\n    vec3 fc = rand(floor(vec2(uv.x +rand(vec2(uv.x,floor(iTime * 5.0)))+ uv.y,uv.y * 10.0)) * floor(iTime * 16.0)) > 0.5 ? vec3(fog1,0,0) : vec3(0,0,fog2);\n\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlXSzs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlXXD4", "name": "Rotations of Mandelbrot", "author": "Veggiebob", "description": "some sort of rotations on some sort of 3d mandelbrot", "tags": ["3d", "fractal", "mandelbrot", "rotation"], "likes": 3, "viewed": 237, "date": "1562885101", "time_retrieved": "2024-06-20T19:41:11.567949", "image_code": "#define MAX_ITERS 10\n#define MAX_MARCH 512\nvec3 sq3 (vec3 v) {\n    return vec3(\n        v.x*v.x-v.y*v.y-v.z*v.z,\n        2.*v.x*v.y,\n        2.*v.x*v.z\n    );\n}\nfloat squishy (float x) {\n    return x*x*x;\n}\nfloat julia (vec3 p, vec3 c) {\n    vec3 k = p;\n    for(int i = 0; i<MAX_ITERS; i++) {\n        k = sq3(k) + c;\n        if(length(k)>2.) return 1.-squishy(float(i)/float(MAX_ITERS));\n    }\n    return -1.;\n}\nvec2 rotate2D (vec2 p, float angle){\n    return vec2(p.x*cos(angle)-p.y*sin(angle), p.y*cos(angle)+p.x*sin(angle));\\\n}\nfloat sdf (vec3 p) {\n  \tvec3 r = p;\n    r.xz = rotate2D(r.xz, iTime*0.3);\n    return julia(p,\n                 r\n                 //vec3(sin(iTime*0.3)*0.7, cos(iTime*0.4)*0.7, p.z));\n    );\n    //return length(p)-1.;\n}\nvec4 trace (vec3 o, vec3 r) {\n    vec3 p = o;\n    float t = 0.;\n    float s;\n    int i;\n    for(i = 0; i<MAX_MARCH; i++) {\n        p = o+r*t;\n        s = sdf(p);\n        t+=s*0.01;\n\t\tif(s<0.001||t>10.) break;\n    }\n    return vec4(p, float(i));\n}\nconst float E = 0.0001;\nvec3 estimateNormal (vec3 p) {\n    return normalize(vec3(\n        sdf(vec3(p.x+E, p.y, p.z))-sdf(vec3(p.x-E, p.y, p.z)),\n        sdf(vec3(p.x, p.y+E, p.z))-sdf(vec3(p.x, p.y-E, p.z)),\n        sdf(vec3(p.x, p.y, p.z+E))-sdf(vec3(p.x, p.y, p.z-E))\n    ));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse-=0.5;\n    float aspect = iResolution.y/iResolution.x;\n    uv.x/=aspect;\n    mouse.x/=aspect;\n    vec3 col = vec3(1.);\n    vec3 cam = vec3(0., 0., -2.);\n    vec3 ray = normalize(vec3(uv.xy*1.3, 1.));\n    \n    vec3 rot = vec3(mouse.y*5., -mouse.x*3., 0.);\n    \n    cam.xz = rotate2D(cam.xz, rot.y);\n    ray.xz = rotate2D(ray.xz, rot.y);\n    \n    cam.zy = rotate2D(cam.zy, rot.x);\n    ray.zy = rotate2D(ray.zy, rot.x);\n    \n    \n    vec4 t = trace(cam, ray);\n    vec3 end = t.xyz;\n    vec3 light = vec3(0., 0., -5.);\n    vec3 toLight = normalize(light-end);\n    vec3 norm = estimateNormal(end);\n    float diffuse = max(0.,dot(toLight, norm))*1.0;\n    vec3 refl = reflect(ray, norm);\n    float specular = pow(max(0.0, dot(refl, toLight)), 16.0)*1.0;\n    float d = length(end-cam);\n    float fog = 1.0 / (1.0 + d*d*0.5);\n    col.gb -= t.w/float(MAX_MARCH);\n    col *= (diffuse+specular) + 1.2;\n    col *= fog;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlXXD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlXXWf", "name": "SVO Rendering (fix 1.0.0)", "author": "Ecter", "description": "Fork of \"Sparse Voxel Octree Raytracing\" by warvstar. https://shadertoy.com/view/MlBfRV.  Replaces wasted space voxels by more compact format resulting in a couple orders of magnitude speed improvement. ", "tags": ["voxels", "octree"], "likes": 12, "viewed": 846, "date": "1564504764", "time_retrieved": "2024-06-20T19:41:12.252300", "image_code": "// Fork of \"Sparse Voxel Octree Raytracing\" by warvstar. https://shadertoy.com/view/MlBfRV\n// 2019-07-29 19:55:54\n// wastes a whole lot less space and is a whole lot more fast!\n\n#define BUNNY\n//#define SPHERE\n\n//bunny 32sq\n#ifdef BUNNY\nuint voxels[230] = uint[230](66046u,196352u,719365u,1111306u,1504267u,1798287u,2010960u,2383776u,2760672u,3081212u,3244159u,3317855u,3448927u,3604224u,4127237u,4521728u,4997311u,5075087u,5308160u,5821483u,6094592u,6583690u,6924885u,7205389u,7533324u,7879365u,8190469u,8581900u,8917486u,9045243u,9153109u,9436928u,9961216u,10485504u,10945277u,11012853u,11206400u,11685298u,11992832u,12474280u,12782835u,12914672u,13238016u,13729664u,14169036u,14418430u,14484221u,14565312u,14946798u,33023u,57599u,12543u,52479u,41727u,51455u,52479u,8447u,65535u,52479u,52479u,65535u,65535u,57599u,61695u,35071u,65535u,43775u,65535u,61695u,65535u,62207u,65535u,65535u,65535u,65535u,65535u,49407u,61695u,20735u,12543u,52479u,50431u,65535u,65535u,52479u,52479u,65535u,65535u,20735u,50431u,65535u,54783u,65535u,65535u,65535u,65535u,65535u,65535u,65535u,65535u,62975u,28927u,65535u,12543u,65535u,33023u,61695u,56831u,14335u,12543u,60159u,65535u,47871u,65535u,61695u,61695u,65535u,65535u,29695u,12543u,65535u,511u,8447u,47103u,49407u,63743u,65535u,19711u,8959u,1535u,61695u,61695u,65535u,65535u,13311u,12799u,4351u,30719u,5631u,35071u,35071u,35071u,767u,52479u,52479u,65535u,65535u,52479u,52479u,8191u,49151u,35583u,65535u,44031u,65535u,2303u,36863u,2815u,45055u,65535u,65535u,65535u,65535u,53247u,61439u,65535u,65535u,3327u,2815u,767u,52479u,52479u,65535u,65535u,52479u,52479u,65535u,65535u,52479u,65535u,56831u,19967u,65535u,65535u,65535u,65535u,65535u,65535u,65535u,65535u,65535u,13311u,65535u,24575u,24575u,3327u,1279u,4095u,3583u,4095u,511u,61183u,65535u,65535u,65535u,61183u,57343u,49151u,32767u,65535u,65535u,22527u,1023u,4095u,4095u,511u,13311u,13311u,767u,1023u,4607u,1279u,65535u,65535u,13311u,13311u,16383u,8191u,30719u,511u);\n\n//small test to understand the layout\n#elif defined(SPHERE)\nuint voxels[60] = uint[60](130816u,649239u,916483u,1309189u,1701640u,2158097u,2547488u,2998080u,3473152u,61695u,52479u,43775u,65535u,61695u,16639u,52479u,16639u,65535u,65023u,61695u,8447u,43775u,65535u,8447u,64511u,61951u,20735u,12543u,65535u,65535u,65535u,4607u,52479u,43775u,65535u,2303u,2303u,61439u,52735u,17663u,65535u,65535u,3327u,65535u,1535u,44031u,65535u,8959u,65535u,2815u,65535u,1023u,65535u,65535u,65535u,4607u,65535u,1535u,1023u,511u);\n\n#else\nuint voxels[6] = uint[6](129526u,197373u,312318u,1791u,329726u,1023u);\n#endif\nconst vec3 PPP = vec3(1, 1, 1);\nconst vec3 PNP = vec3(1, -1, 1);\nconst vec3 PNN = vec3(1, -1, -1);\nconst vec3 NPN = vec3(-1, 1, -1);\nconst vec3 NNN = vec3(-1, -1, -1);\nconst vec3 NNP = vec3(-1, -1, 1);\nconst vec3 NPP = vec3(-1, 1, 1);\nconst vec3 PPN = vec3(1, 1, -1);\nconst vec3 POS[8] = vec3[8](PNN, PNP, PPN, PPP, NNN, NNP, NPN, NPP);\nstruct Ray { vec3 o, d, invDir; };\nstruct Hit {\n\tvec3 p;\n\tfloat t;\t// solution to p=o+t*d\n\tfloat tmax;    //distance to exit point?\n\tfloat tmin;    // distance to enter point?\n\tvec3 n;\t\t// normal\n};\nbool BBoxIntersect(const vec3 boxMin, const vec3 boxMax, const Ray r, out Hit hit) {\n\tvec3 tbot = r.invDir * (boxMin - r.o);\n\tvec3 ttop = r.invDir * (boxMax - r.o);\n\tvec3 tmin = min(ttop, tbot);\n\tvec3 tmax = max(ttop, tbot);\n\tvec2 t = max(tmin.xx, tmin.yz);\n\tfloat t0 = max(t.x, t.y);\n\tt = min(tmax.xx, tmax.yz);\n\tfloat t1 = min(t.x, t.y);\n\thit.tmin = t0;\n\thit.tmax = t1;\nreturn t1 > max(t0, 0.0);\n}\nvec4 trace(Ray ray, inout Hit hit) {\n\tvec3 center = vec3(0.0f);\n    float scale = 1.0f;\n\tvec3 minBox = center - scale;\n\tvec3 maxBox = center + scale;\n\tvec4 f = vec4(1.0f);\n    struct Stack {\n\t\tuint index;\n\t\tvec3 center;\n\t\tfloat scale;\n\t};\n    Stack stack[10];\n    int stackPos = 1;\n    if (!BBoxIntersect(minBox, maxBox, ray, hit)) return f;\n    uint index = 0u;\n    scale *= 0.5f;\n    stack[0] = Stack( 0u, center, scale);\n    while(stackPos-- > 0) {\n        f = vec4(0.1f);\n        center = stack[stackPos].center;\n\t\tindex = stack[stackPos].index;\n\t\tscale = stack[stackPos].scale;\n        uint voxel_node = voxels[index];\n        uint voxel_group_offset = voxel_node >> 16;\n        uint voxel_child_mask = (voxel_node & 0x0000FF00u) >> 8u;\n        uint voxel_leaf_mask = voxel_node & 0x000000FFu;\n        uint accumulated_offset = 0u;\n        for (uint i = 0u; i < 8u; ++i) {\n            bool empty = (voxel_child_mask & (1u << i)) == 0u;\n            bool is_leaf = (voxel_leaf_mask & (1u << i)) != 0u;\n            if (empty){ //empty\n                continue;\n            }\n            \n            vec3 new_center = center + scale * POS[i];\n            vec3 minBox = new_center - scale;\n            vec3 maxBox = new_center + scale;\n            \n\n            if (!BBoxIntersect(minBox, maxBox, ray, hit)){\n                if(!is_leaf){\n                   accumulated_offset +=1u;\n                }\n                continue;\n            }\n            if (is_leaf){ //not empty, but a leaf\n                return vec4(1.0f,0.0f,0.0f,1.0f);\n            } else { //not empty and not a leaf\n            \tstack[stackPos++] = Stack(voxel_group_offset+accumulated_offset, new_center, scale*0.5f   );\n            \tf.z += 0.4f;\n                accumulated_offset+=1u;\n            }\n        }\n    }\n\treturn f;\n}\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.8);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n    vec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n\tvec3 rayPos = vec3(0.0, 0.25 * sin(iTime * 2.7), -3.4);\n    rayPos.xz = rotate2d(rayPos.xz, iTime);\n   \trayDir.xz = rotate2d(rayDir.xz, iTime);\n\tRay ray;\n\tHit hit;\n\tray.o = rayPos;\n\tray.d = rayDir;\n\tray.invDir = 1.0f/rayDir;\n\tvec4 color = trace(ray, hit);\n    if (length(color) > 0.5f) {\n     fragColor = color;\n\t}\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlXXWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlXXWl", "name": "Snake_Sphere", "author": "Hirai_worthless", "description": " i have nothing to say.", "tags": ["raymarching"], "likes": 4, "viewed": 93, "date": "1564549725", "time_retrieved": "2024-06-20T19:41:12.252300", "image_code": "vec3 path(float t){\n\tfloat x = sin(t) + cos(2.0 * t);\n    float y = cos(t) + cos(2.0 * t);\n    float z = cos(t) + sin(2.0 * t);\n    return vec3(x,y,z);\n}\nfloat map(vec3 p){\n\n\tfloat sphere = length(p - path(iTime)) - 0.5;\n    float trail = 100000.0;\n    for(float i = 0.0; i < 5.0; i += 0.1){\n    \ttrail = min(trail,length(p - path(iTime - i)) - 0.1 * (5.0 - i));\n    }\n    return min(sphere,trail);\n}\n\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 96; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return vec4(getNormal(p),t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 R = iResolution,\n    r = normalize(vec3((2.*U - R.xy )/  R.y,1.2)),\n    o = vec3(0,0,-2.0);\n    vec4 data = trace(o,r);\n    vec3 n = vec3(data.xyz);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.2);\n    vec3 fc = t > 10000.0 ? vec3(0.8) : mix((vec3(data.x,data.y,data.z) + 1.0)/1.5\n                                            ,vec3(0.0), - pow(dot(n,r),1.0));\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlXXWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlXXz2", "name": "Magical flower", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 6, "viewed": 185, "date": "1563548892", "time_retrieved": "2024-06-20T19:41:12.252300", "image_code": "#define PI acos(-1.0)\n#define TAU PI*2.0\n\n\nvec2 rotate(vec2 p, float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a))*p;\n}\n\nvec3 rotate(vec3 p,vec3 axis,float theta)\n{\n    vec3 v = cross(axis,p), u = cross(v, axis);\n    return u * cos(theta) + v * sin(theta) + axis * dot(p, axis);   \n}\n\nvec3 hue(float t){\nreturn cos((vec3(0,2,-2)/3.+t)*TAU)*.5+.5;\n}\n\nvec2 pmod(vec2 p, float r)\n{\n    float a = mod(atan(p.y, p.x), TAU / r) - 0.5 * TAU / r;\n    return length(p) * vec2(sin(a), cos(a));\n}\n\nfloat map(vec3 p)\n{\n    p.xy = rotate(p.xy,iTime*0.2);\n    p.yz = rotate(p.yz,iTime*0.1);\n    for(int i=0;i<3;i++)\n    {\n        p.xy = pmod(p.xy,18.0);\n        p.y-=mix(8.5,6.5,step(0.5,fract(iTime*0.2+3.0)));\n        p.yz = pmod(p.yz,16.0);\n        p.z-=mix(6.5,11.0,step(0.5,fract(iTime*0.1)));\n    }\n    return dot(abs(p),\n               rotate(\n                   normalize(vec3(2,1,3)),\n                   normalize(vec3(5,1,2)),\n                   1.4*sin(iTime*0.5))\n              )\n        \t-0.5-sin(iTime*0.8+2.3)*0.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n \tvec3 ro=vec3(0,5,43.0);\n \tvec3 ta = vec3(3.5,0,0);\n \tta.xz=rotate(ta.xz,iTime*0.6);\t\n \tvec3 w=normalize(ta-ro);\n \tvec3 u=normalize(cross(w,vec3(0,1,0)));\n    vec3 rd=mat3(u,cross(u,w),w)*normalize(vec3(uv,2));\n    vec3 col = hue(0.55)*0.25;\n    float d,t=0.0;\n    for(float i=1.0;i>0.0;i-=1.0/80.0)\n    {\n     \tt+=d=map(ro+t*rd);\n        if(d<0.001)\n        {\n            col+=mix(vec3(1),hue(length(ro+t*rd)*0.1+iTime*0.1),0.8)*i*i;\n            break;\n        }\n    }\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlXXz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlXXzf", "name": "Ship in a Bottle", "author": "dr2", "description": "How did it get there?", "tags": ["raymarch", "optics", "ship", "bottle"], "likes": 20, "viewed": 383, "date": "1563723461", "time_retrieved": "2024-06-20T19:41:15.343261", "image_code": "// \"Ship in a Bottle\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEVCapsDf (vec3 p, vec4 u, float r);\nfloat PrEECapsDf (vec3 p, vec3 v1, vec3 v2, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrCaps44Df (vec3 p, float r, float h);\nfloat PrCapsAn44Df (vec3 p, float r, float w, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Length44c (vec3 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec4 vum[4], vur[5];\nvec3 vim[4], vir[5], shipConf, bDeck, qHit, sunDir;\nfloat tCur, dstFar, szFac, rBot;\nint idObj;\nconst int idHull = 1, idRud = 2, idStruc = 3, idMast = 4, idSparT = 5, idSparL = 6, idSailT = 7,\n   idSailA = 8, idSailF = 9, idFlag = 10, idRig = 11, idCork = 21, idCap = 22;\nbool inBot, chkBot;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d, w;\n  dMin = dstFar;\n  w = 0.05;\n  if (chkBot) {\n    if (inBot) dMin = SmoothMin (PrCapsAn44Df (p, rBot + w, w, 0.5 * rBot + w),\n       PrCylAnDf (vec3 (p.xy, p.z - 1.65 * rBot), 0.25 * rBot + w, w, 0.25 * rBot + w), 10. * w);\n    else dMin = SmoothMin (PrCaps44Df (p, rBot, 0.5 * rBot),\n       PrCylDf (vec3 (p.xy, p.z - 1.65 * rBot), 0.25 * rBot, 0.25 * rBot), 10. * w);\n  } else {\n    d = PrCylDf (vec3 (p.xy, p.z - 1.8 * rBot), 0.25 * rBot - 4. * w, 0.25 * rBot);\n    DMIN (idCork);\n    d = PrCylDf (vec3 (p.xy, p.z - 2. * rBot), 0.25 * rBot + 4. * w, 0.1 * rBot);\n    DMIN (idCap);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ShipHullDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, fy, fz, gz;\n  q = p;\n  d = abs (p.z) - 4.5;\n  q.z = mod (q.z + 1.4, 2.8) - 1.4;\n  q.yz -= vec2 (-3.4, -0.4);\n  d = max (d, PrBoxDf (q, vec3 (0.3, 0.1, 0.5)));\n  DMINQ (idStruc);\n  q = p;\n  q.x = abs (q.x);\n  q.yz -= vec2 (-3.8, 0.5);\n  fz = q.z / 5. + 0.3;\n  fz *= fz;\n  fy = 1. - smoothstep (-1.3, -0.1, q.y);\n  gz = smoothstep (2., 5., q.z);\n  bDeck = vec3 ((1. - 0.45 * fz * fz) * (1.1 - 0.5 * fy * fy) *\n     (1. - 0.5 * smoothstep (-5., -2., q.y) * smoothstep (2., 5., q.z)),\n     0.78 - 0.8 * gz * gz - 0.2 * (1. - smoothstep (-5.2, -4., q.z)), 5. * (1. + 0. * 0.02 * q.y));\n  d = min (PrBoxDf (vec3 (q.x, q.y + bDeck.y - 0.6, q.z), bDeck),\n     max (PrBoxDf (q - vec3 (0., 0.72, -4.6), vec3 (bDeck.x, 0.12, 0.4)),\n     - PrBox2Df (vec2 (abs (q.x) - 0.4, q.y - 0.65), vec2 (0.2, 0.08))));\n  d = max (d, - PrBoxDf (vec3 (q.x, q.y - 0.58 - 0.1 * fz, q.z),\n     vec3 (bDeck.x - 0.07, 0.3, bDeck.z - 0.1)));\n  q = p;\n  d = max (d, - max (PrBox2Df (vec2 (q.y + 3.35, mod (q.z + 0.25, 0.5) - 0.25), vec2 (0.08, 0.1)),\n     abs (q.z + 0.5) - 3.75));\n  DMINQ (idHull);\n  q = p;\n  d = PrBoxDf (q + vec3 (0., 4.4, 4.05), vec3 (0.03, 0.35, 0.5));\n  DMINQ (idRud);\n  return dMin;\n}\n\nfloat ShipMastDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  float d, fy, fz, s, rSpar, yLim, zLim;\n  rSpar = 0.05;\n  fy = 1. - 0.07 * p.y;\n  fz = 1. - 0.14 * step (1., abs (p.z));\n  zLim = abs (p.z) - 4.5;\n  q = p;\n  d = zLim;\n  q.z = mod (q.z + 1.4, 2.8) - 1.2;\n  d = max (d, PrCapsDf ((q - vec3 (0., 3.7 * (fz - 1.), 0.)).xzy, 0.1 * fy, 3.7 * fz));\n  DMINQ (idMast);\n  q = p;\n  yLim = abs (q.y - 0.2 * fz) - 3. * fz;\n  qq = q;\n  qq.y = mod (qq.y - 3.3 * (fz - 1.), 2. * fz) - fz;\n  qq.z = mod (qq.z + 1.4, 2.8) - 1.4 + 0.1 * fz;\n  d = max (max (min (d, PrCylDf (vec3 (qq - vec3 (0., 0.05 * fy * fz, 0.1 * fz - 0.23)).xzy,\n     0.15 * fy, 0.11 * fy * fz)), yLim), zLim);\n  DMINQ (idMast);\n  d = max (max (PrCapsDf (qq.yzx, 0.05, 1.23 * fy * fz), yLim), zLim);\n  DMINQ (idSparT);\n  q = p;\n  d = min (d, min (PrEVCapsDf (q - vim[0], vum[0], rSpar), PrEVCapsDf (q - vim[1], vum[1], rSpar)));\n  d = min (d, min (PrEVCapsDf (q - vim[2], vum[2], rSpar), PrEVCapsDf (q - vim[3], vum[3], rSpar)));\n  DMINQ (idSparL);\n  return dMin;\n}\n\nfloat ShipSailDf (vec3 p, float dMin)\n{\n  vec3 q, qq, w;\n  float d, fy, fz;\n  fy = 1. - 0.07 * p.y;\n  fz = 1. - 0.14 * step (1., abs (p.z));\n  q = p;\n  qq = q;\n  qq.y = mod (qq.y - 3.1 * (fz - 1.), 2. * fz) - fz;\n  qq.z = mod (qq.z + 1.4, 2.8) - 1.4 + 0.2 * (fz - abs (qq.y)) * (fz - abs (qq.y)) - 0.1 * fz;\n  d = max (max (max (PrBoxDf (qq, vec3 ((1.2 - 0.07 * q.y) * fz, fz, 0.01)),\n     min (qq.y, 1.5 * fy * fz - length (vec2 (qq.x, qq.y + 0.9 * fy * fz)))),\n     abs (q.y - 3. * (fz - 1.)) - 2.95 * fz), - PrBox2Df (qq.yz, vec2 (0.01 * fz)));\n  d = max (d, abs (p.z) - 4.5);\n  DMINQ (idSailT);\n  q = p;\n  q.z -= -3.8;  q.y -= -1.75 - 0.2 * q.z;\n  d = PrBoxDf (q, vec3 (0.01, 0.9 - 0.2 * q.z, 0.6));\n  DMINQ (idSailA);\n  q = p;\n  q.yz -= vec2 (-1., 4.5);\n  w = vec3 (1., q.yz);\n  d = max (max (max (abs (q.x) - 0.01, - dot (w, vec3 (2.3, 1., -0.35))),\n     - dot (w, vec3 (0.68, -0.74, -1.))), - dot (w, vec3 (0.41, 0.4, 1.)));\n  DMINQ (idSailF);\n  q = p;\n  q.yz -= vec2 (3.4, 0.18);\n  d = PrBoxDf (q, vec3 (0.01, 0.2, 0.3));\n  DMINQ (idFlag);\n  return dMin;\n}\n\nfloat ShipRigDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float rRig, d, fz, gz, s;\n  rRig = 0.02;\n  fz = 1. - 0.14 * step (1., abs (p.z));\n  q = p;\n  d = abs (p.z) - 4.5;\n  gz = (q.z - 0.5) / 5. + 0.3;\n  gz *= gz;\n  gz = 1.05 * (1. - 0.45 * gz * gz);\n  q.x = abs (q.x);\n  q.z = mod (q.z + 1.4, 2.8) - 1.4;\n  d = max (d, min (PrEECapsDf (q, vec3 (1.05 * gz, -3.25, -0.5),\n     vec3 (1.4 * fz, -2.95, -0.05), 0.7 * rRig),\n     PrEECapsDf (vec3 (q.xy, abs (q.z + 0.2) - 0.01 * (0.3 - 2. * q.y)), vec3 (gz, -3.2, 0.),\n     vec3 (0.05, -0.9 + 2. * (fz - 1.), 0.), rRig)));\n  q = p;\n  d = min (d, PrEVCapsDf (q - vir[0], vur[0], 0.8 * rRig));\n  d = min (min (d, min (PrEVCapsDf (q - vir[1], vur[1], rRig),\n     PrEVCapsDf (q - vir[2], vur[2], rRig))), PrEVCapsDf (q - vir[3], vur[3], rRig));\n  q.x = abs (q.x);\n  d = min (d, PrEVCapsDf (q - vir[4], vur[4], rRig));\n  s = step (1.8, q.y) - step (q.y, -0.2);\n  d = min (min (d, min (PrEECapsDf (q, vec3 (0.95, 0.4, 2.7) + vec3 (-0.1, 1.7, 0.) * s,\n     vec3 (0.05, 1.1, -0.15) + vec3 (0., 2., 0.) * s, rRig),\n     PrEECapsDf (q, vec3 (1.05, 1., -0.1) + vec3 (-0.1, 2., 0.) * s,\n     vec3 (0.05, 0.5, -2.95) + vec3 (0., 1.7, 0.) * s, rRig))),\n     PrEECapsDf (q, vec3 (0.95, 0.4, -2.9) + vec3 (-0.1, 1.7, 0.) * s,\n     vec3 (0.05, 0.9, -0.25) + vec3 (0., 2., 0.) * s, rRig));\n  DMINQ (idRig);\n  return dMin;\n}\n\nfloat ShipDf (vec3 p)\n{\n  vec3 q;\n  float dMin;\n  q = p;\n  q -= shipConf;\n  q /= szFac;\n  dMin = dstFar / szFac;\n  dMin = ShipHullDf (q, dMin);\n  dMin = ShipMastDf (q, dMin);\n  dMin = ShipSailDf (q, dMin);\n  dMin = ShipRigDf (q, dMin);\n  return 0.7 * szFac * dMin;\n}\n\nfloat ShipRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ShipDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ShipNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  v = vec4 (- ShipDf (p + e.xxx), ShipDf (p + e.xyy), ShipDf (p + e.yxy), ShipDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvoid EvalShipConf ()\n{\n  vec3 vd;\n  shipConf = vec3 (0., 4.8 * szFac - 0.9 * rBot, -0.5 * szFac);\n  vim[0] = vec3 (0., -3.5, 4.3);   vd = vec3 (0., -2.6, 6.7) - vim[0];   vum[0] = vec4 (normalize (vd), length (vd));\n  vim[1] = vec3 (0., -4., 4.1);    vd = vec3 (0., -2.9, 6.) - vim[1];    vum[1] = vec4 (normalize (vd), length (vd));\n  vim[2] = vec3 (0., -1.2, -3.);   vd = vec3 (0., -0.5, -4.5) - vim[2];  vum[2] = vec4 (normalize (vd), length (vd));\n  vim[3] = vec3 (0., -2.7, -3.);   vd = vec3 (0., -2.7, -4.5) - vim[3];  vum[3] = vec4 (normalize (vd), length (vd));\n  vir[0] = vec3 (0., -3., -4.45);  vd = vec3 (0., -2.7, -4.5) - vir[0];  vur[0] = vec4 (normalize (vd), length (vd));\n  vir[1] = vec3 (0., 2.45, 2.65);  vd = vec3 (0., -2.7, 6.5) - vir[1];   vur[1] = vec4 (normalize (vd), length (vd));\n  vir[2] = vec3 (0., 2.5, 2.65);   vd = vec3 (0., -3.2, 4.9) - vir[2];   vur[2] = vec4 (normalize (vd), length (vd));\n  vir[3] = vec3 (0., 2.6, -3.);    vd = vec3 (0., -0.5, -4.5) - vir[3];  vur[3] = vec4 (normalize (vd), length (vd));\n  vir[4] = vec3 (0.65, -3.5, 3.5); vd = vec3 (0.05, -2.7, 6.4) - vir[4]; vur[4] = vec4 (normalize (vd), length (vd));\n}\n\nfloat ShipSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 30; j ++) {\n    h = ShipDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += clamp (h, 0.02, 0.3);\n    if (sh < 0.05) break;\n  }\n  return 0.5  + 0.5 * sh;\n}\n\nvoid ShipCol (out vec4 col4, out vec2 vf)\n{\n  vec2 cg;\n  vf = vec2 (0.);\n  if (idObj == idHull) {\n    if (abs (qHit.x) < bDeck.x - 0.08 && qHit.y > -3.6 && qHit.z > - bDeck.z + 0.62) {\n      col4 = vec4 (0.5, 0.3, 0., 0.1) * (0.5 +\n         0.5 * SmoothBump (0.05, 0.95, 0.02, mod (8. * qHit.x, 1.)));\n    } else if (qHit.y > -4.) {\n      col4 = vec4 (0.7, 0.5, 0.1, 0.1);\n      if (abs (qHit.z - 4.) < 0.25 && abs (qHit.y + 3.55) < 0.05) col4 *= 1.2;\n      else if (qHit.z < -4. && abs (qHit.x) < 0.84 && abs (qHit.y + 3.62) < 0.125) {\n        cg = step (0.1, abs (fract (vec2 (6. * qHit.x, 8. * (qHit.y + 3.62)) + 0.5) - 0.5));\n        if (cg.x * cg.y == 1.) col4 = vec4 (0.8, 0.8, 0.2, 1.);\n        else col4 *= 0.8;\n      } else {\n        col4 *= 0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.02, mod (8. * qHit.y, 1.));\n        vf = vec2 (64., 0.3);\n      } \n    } else if (qHit.y > -4.05) {\n      col4 = vec4 (0.8, 0.8, 0.8, 0.1);\n    } else if (qHit.y < -4.7) {\n      col4 = vec4 (0.8, 0., 0., 0.1);\n      vf = vec2 (64., 2.);\n    } else {\n      col4 = vec4 (0.3, 0.2, 0.1, 0.);\n      vf = vec2 (64., 2.);\n    }\n  } else if (idObj == idRud) {\n    col4 = vec4 (0.5, 0.3, 0., 0.);\n  } else if (idObj == idStruc) {\n    col4 = vec4 (0.4, 0.3, 0.1, 0.1);\n    if (max (abs (qHit.x), abs (qHit.z + 0.22)) < 0.2) {\n      cg = step (0.1, abs (fract (vec2 (10. * vec2 (qHit.x, qHit.z + 0.22)) + 0.5) - 0.5));\n      if (cg.x * cg.y == 1.) col4 = vec4 (0.8, 0.8, 0.2, 1.);\n    }\n  } else if (idObj == idSailT) {\n    qHit.x *= (1. + 0.07 * qHit.y) * (1. + 0.14 * step (1., abs (qHit.z)));\n    col4 = vec4 (1., 1., 1., 0.) * (0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.02, mod (4. * qHit.x, 1.)));\n    if (abs (qHit.z) < 0.2 && abs (abs (length (qHit.xy - vec2 (0., 0.3)) - 0.35) - 0.15) < 0.07)\n       col4 *= vec4 (0.2, 1., 0.2, 1.);\n  } else if (idObj == idSailA) {\n    col4 = vec4 (1., 1., 1., 0.) * (0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.02, mod (5. * qHit.z, 1.)));\n  } else if (idObj == idSailF) {\n    col4 = vec4 (1., 1., 1., 0.) * (0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.02,\n       mod (2.95 * qHit.y + 4. * qHit.z - 0.5, 1.)));\n  } else if (idObj == idFlag) {\n    col4 = vec4 (1., 1., 0.5, 0.1);\n    if (abs (abs (length (qHit.yz) - 0.1) - 0.04) < 0.02) col4 *= vec4 (0.2, 1., 0.2, 1.);\n  } else if (idObj == idMast) {\n    col4 = vec4 (0.7, 0.4, 0., 0.1);\n    if (length (qHit.xz) < 0.16 * (1. - 0.07 * qHit.y))\n       col4 *= 0.6 + 0.4 * SmoothBump (0.03, 0.97, 0.01, mod (2. * qHit.y /\n       (1. + 0.14 * step (1., abs (qHit.z))), 1.));\n  } else if (idObj == idSparT) {\n    qHit.x *= (1. + 0.07 * qHit.y) * (1. + 0.14 * step (1., abs (qHit.z)));\n    col4 = vec4 (0.7, 0.4, 0., 0.1) *  (0.6 + 0.4 * SmoothBump (0.08, 0.92, 0.01,\n       mod (4. * qHit.x, 1.)));\n  } else if (idObj == idSparL) {\n    col4 = vec4 (0.7, 0.4, 0., 0.1);\n  } else if (idObj == idRig) {\n    col4 = vec4 (0.2, 0.15, 0.1, 0.);\n    vf = vec2 (32., 0.5);\n  }\n}\n\nvec4 ObjCol (vec3 p)\n{\n  vec4 c;\n  if (idObj == idCork) c = vec4 (0.5, 0.4, 0.3, 0.05);\n  else if (idObj == idCap) c = vec4 (0.2, 0.1, 0.1, 0.2) * (0.8 + \n     0.2 * sin (32. * atan (p.y, - p.x) / 2. * pi) * step (1.5, length (p.xy)));\n  return c;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 c, u, uu;\n  vec2 f;\n  float t;\n  col4 = vec4 (0.);\n  uu = normalize (ro + 200. * rd);\n  for (int ky = -1; ky <= 1; ky ++) {\n    for (int kx = -1; kx <= 1; kx ++) {\n      u = uu;\n      f = vec2 (kx, ky);\n      u.yz = Rot2D (u.yz, 0.0025 * f.y);\n      u.xz = Rot2D (u.xz, 0.0025 * f.x);\n      t = max (SmoothBump (0.45, 0.55, 0.02, mod (64. * atan (u.z, - u.x) / pi, 1.)),\n         SmoothBump (0.45, 0.55, 0.02, mod (64. * asin (u.y) / pi, 1.)));\n      c = mix (vec3 (0.2, 0.3, 0.6), vec3 (0.7, 0.7, 0.4), t) * (0.6 + 0.4 * u.y);\n      t = (u.y > 2. * max (abs (u.x), abs (u.z * 0.25))) ? 0.5 * min (2. * u.y, 1.) :\n         0.05 * (1. + dot (u, sunDir));\n      if (u.y > 0.) t += pow (clamp (1.05 - 0.5 *\n         length (max (abs (u.xz / u.y) - 0.4 * vec2 (1., 4.), 0.)), 0., 1.), 8.);\n      c += vec3 (0.5, 0.5, 1.) * t;\n      col4 += vec4 (min (c, 1.), 1.) * (1. - 0.15 * dot (f, f));\n    }\n  }\n  return col4.rgb / col4.w;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 roo, rdo, rdd, vn, vnW, col;\n  vec2 vf;\n  float dstShip, dstObj, dstBot, dstBotW, rdDotN, eta, sh;\n  int idObjS;\n  bool bWallHit;\n  rBot = 6.;\n  szFac = 1.2;\n  EvalShipConf ();\n  eta = 1.001;\n  chkBot = true;\n  inBot = false;\n  dstBot = ObjRay (ro, rd);\n  chkBot = false;\n  dstObj = ObjRay (ro, rd);\n  dstShip = dstFar;\n  bWallHit = (dstBot < min (dstObj, dstFar));\n  if (bWallHit) {\n    dstBotW = dstBot;\n    roo = ro;\n    rdo = rd;\n    ro += dstBot * rd;\n    chkBot = true;\n    vn = ObjNf (ro);\n    vnW = vn;\n    rdDotN = - dot (rd, vn);\n    rd = refract (rd, vn, 1. / eta);\n    ro += 0.1 * rd;\n    inBot = true;\n    dstBot = ObjRay (ro, rd);\n    chkBot = false;\n    dstShip = ShipRay (ro, rd);\n    idObjS = idObj;\n    dstObj = ObjRay (ro, rd);\n    if (dstBot < min (min (dstShip, dstObj), dstFar)) {\n      ro += dstBot * rd;\n      chkBot = true;\n      vn = ObjNf (ro);\n      rdd = refract (rd, vn, eta);\n      if (length (rdd) > 0.) {\n        rd = rdd;\n        ro += 0.01 * rd;\n        chkBot = false;\n        dstObj = ObjRay (ro, rd);\n     } else {\n        rd = reflect (rd, vn);\n        dstObj = dstFar;\n      }\n    }\n  }\n  if (min (dstShip, dstObj) < dstFar) {\n    if (dstShip < dstObj) {\n      dstObj = dstShip;\n      idObj = idObjS;\n    }\n    ro += dstObj * rd;\n    if (idObj >= idHull && idObj <= idRig) {\n      vn = ShipNf (ro);\n      ShipCol (col4, vf);\n      if (vf.x > 0.) vn = VaryNf (vf.x * qHit, vn, vf.y);\n      sh = ShipSShadow (ro, sunDir);\n    } else {\n      chkBot = false;\n      vn = ObjNf (ro);\n      col4 = ObjCol (ro);\n      sh = 1.;\n    }\n    col = col4.rgb * (0.2 + 0.8 * sh * max (dot (sunDir, vn), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n  } else col = BgCol (ro, rd);\n  if (bWallHit) {\n    ro = roo + dstBotW * rdo;\n    rd = reflect (rdo, vnW);\n    col = mix (BgCol (ro, rd), col, 0.1 + 0.9 * smoothstep (0.4, 0.8, rdDotN));\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n    el -= 0.05 * pi * sin (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, 0.05 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0.5, -50.);\n  zmFac = 5.5;\n  dstFar = 100.;\n  sunDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (1.)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrEVCapsDf (vec3 p, vec4 u, float r)\n{\n  return length (p - clamp (dot (p, u.xyz), 0., u.w) * u.xyz) - r;\n}\n\nfloat PrEECapsDf (vec3 p, vec3 v1, vec3 v2, float r)\n{\n  return PrEVCapsDf (p - v1, vec4 (normalize (v2 - v1), length (v2 - v1)), r);\n}\n\nfloat PrCaps44Df (vec3 p, float r, float h)\n{\n  return Length44c (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCapsAn44Df (vec3 p, float r, float w, float h)\n{\n  p.z = abs (p.z);\n  return max (Length44c (p - vec3 (0., 0., min (p.z, h + w))) - r,\n     - Length44c (p - vec3 (0., 0., min (p.z, h - w))) + r) - w;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Length44c (vec3 p)\n{\n  p.xy *= p.xy;\n  return sqrt (length (vec2 (sqrt (dot (p.xy, p.xy)), p.z * p.z)));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlXXzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlXXzM", "name": "circle of circles 2d sdf", "author": "vegardno", "description": "asdf", "tags": ["2d", "sdf", "exact"], "likes": 2, "viewed": 234, "date": "1562340336", "time_retrieved": "2024-06-20T19:41:15.349340", "image_code": "// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfloat sdCircleCircle( in vec2 p, in int n, in float r0, in float r1 )\n{\n    float a0 = float(n) / radians(360.);\n    float a = round(atan(p.x, p.y) * a0) / a0;\n    return length(p - r1 * vec2(sin(a), cos(a))) - r0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    p *= 2.0;\n\n    float r0 = .3 + .2 * sin(3. * iTime);\n    float r1 = 1. + .4 * sin(1. * iTime);\n    \n\tfloat d = sdCircleCircle( p, 3 + int(mod(2. * iTime, 9.)), r0, r1 );\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(80.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/WlXXzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsS3DR", "name": "rockwall", "author": "valerysntx", "description": "forked for `climbing rock-wall effect`", "tags": ["normal", "supersampler"], "likes": 2, "viewed": 162, "date": "1562915437", "time_retrieved": "2024-06-20T19:41:15.349340", "image_code": "const float zNear = 1.0;\nconst float zFar  = 10.0;\nconst int ITERATIONS = 20;\n\n#define SUPERSAMPLING \nfloat map(in vec3 m) {\n    \n\tvec3 sphereCenter = vec3(0.0, 0.0, 3.85);\n    float radius =3.6;\n    \n    float displacementSize = 0.118 + cos(iTime*0.125)* 0.4;\n    float displacement \t\t= sin(displacementSize*m.x)*sin(displacementSize*m.y)*sin(displacementSize*m.z) * 0.05;\n    \n    return length(m - sphereCenter) - radius + displacement; \n}\n\n\n\nvec3 computeNormalMap(in vec2 UV)\n{\n    float scale = 0.1;\n    vec2 eps = vec2(0.21, 0.0);\n    \n    float hx1 = texture(iChannel0, UV + eps.xy).x;\n    float hx2 = texture(iChannel0, UV - eps.xy).x;    \n    float hz1 = texture(iChannel0, UV + eps.yx).x;\n    float hz2 = texture(iChannel0, UV - eps.yx).x;    \n    \n    vec3 i = vec3(eps.x, 0.0, (hx2-hx1)*scale);\n    vec3 j = vec3(0.0, eps.x, (hz2-hz1)*scale);    \n    \n    return normalize(cross(i, j));\n}\n\n\n\nbool rayMarching(in vec3 origin, in vec3 ray, out vec3 m) {\n    \n    float\tmarchingDist = 0.0;\n    float \tnbIter \t\t = 0.0;\n\n    for(int i = 0; i< ITERATIONS; i++) {\n        \n        m = origin + ray * marchingDist;    \n        \n    \tfloat dist = map(m);\n        \n        if(dist < 0.0001) {\n            return true;\n        }\n        else {\n            marchingDist += dist;\n            \n            if(marchingDist >= zFar) {\n                break;\n            }\n        }\n    }\n    \n\treturn false;    \n}\n\n\nvec4 computeColor(in vec3 ray, in vec3 m, in vec3 normal, in vec3 light, in vec3 eye) {\n\n    vec2 UV = ((normal.xy + 1.0) * 0.5) * (20.0 + cos(iTime*0.01)*5.0);\n    \n    vec3 pixel = texture(iChannel0, UV).xyz;\n    \n    vec3 normalMap = computeNormalMap(UV);\n    \n    vec3 k = normal;\n    vec3 i = normalize(vec3(-k.z, 0.0, k.x));\n    vec3 j = cross(k, i);\n    \n    mat3 local = mat3(i, j, k);\n    \n\tnormal = normalMap * local;    \n    \n    \n    vec3 lightRay = normalize(m - light);\n    float diffuse = max(.0, dot(normal, -lightRay));\n    \n    vec3 reflectedLight  = reflect(lightRay, normal);\n    float hilight \t\t = pow(max(dot(reflectedLight, -ray),0.20), 10.0);\n    \n    float ambiant = 1.;       \n    \n    vec3 render = pixel * (diffuse + ambiant) + hilight;\n    return vec4(render, 1.0);\n}\n\n\n// IQ's func <3\nvec3 computeNormal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.5, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy) - map(pos-eps.xyy),\n\t     map(pos+eps.yxy) - map(pos-eps.yxy),\n\t     map(pos+eps.yyx) - map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\n\n\nvec4 run(in vec2 fragCoord )\n{\n    float \tratio \t\t\t= iResolution.x/iResolution.y;\n    vec3 \tviewportCoord \t= vec3(fragCoord.xy/iResolution.y - vec2(ratio/2.0, 0.5), zNear);\n    \n    vec3\teye\t\t\t\t= vec3(0.0, 0.0, 0.0);\n    vec3\tray\t\t\t\t= normalize(viewportCoord-eye);\n    vec3\tlight\t\t\t= vec3(5.0*cos(iTime*0.5), 3.0, -10.0);\n    \n    vec3\tm;\n    \n    if(rayMarching(eye, ray, m)) {\n        vec3 normal = computeNormal(m);\n        return computeColor(ray, m, normal, light, eye);\n    }\n    else {\n        return vec4(0.0, 0, 0, 1.0);        \n    }\n    \n}\n    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    #ifdef SUPERSAMPLING\n    // 5x5 supersampling\n    for(float dx=-0.5; dx<=0.5; dx+=0.25) {\n    \tfor(float dy=-0.5; dy<=0.5; dy+=0.25) {\n            fragColor += run(fragCoord + vec2(-dx, -dy));\n        }\n    }\n    \n    fragColor = fragColor / pow(max(dot(vec2(0.0,0.0), fragColor.xy),40.0), 1.0);\n    \n    #else\n    fragColor = run(fragCoord);\n    #endif\n} \n\n    \n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsS3DR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsXGR7", "name": "nowhere", "author": "zxxuan1001", "description": "Practice based on iq's articles about terrain marching, noise, fogs --> \nThe result is just a place that I wanna go to in my dreams.\n\n", "tags": ["terrain", "fbm", "fog"], "likes": 11, "viewed": 475, "date": "1562390869", "time_retrieved": "2024-06-20T19:41:16.828185", "image_code": "/*\nhttp://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm\nhttp://www.iquilezles.org/www/articles/morenoise/morenoise.htm\n*/\n\nconst vec3 PURPLE = vec3(1.0, 0.9, 1.0);//vec3(141.0, 0.0, 196.0)/255.0;\nconst vec3 PINK = vec3(0.5, 0.4, 0.4);//vec3(255.0,192.0,203.0)/255.0;\nconst vec3 WHITE = vec3(1.0);\nconst vec3 BLACK = vec3(0.0);\nconst vec3 SKY = vec3(0.0);\nconst vec3 MOON = vec3(1.0, 0.6, 0.0);\nconst vec3 BLUE = vec3(0.1,0.2,0.3);\nconst vec3 GREEN = vec3(0.1,0.2,0.3);\nconst vec3 EARTH = vec3(0.1);\nconst float PI = 3.1415926;\nconst float EPSILON = 0.0001;\nconst float SCALE = 0.01;\nconst float HEIGHT = 12.0;\nconst float MAX_DISTANCE = 400.0;\nconst int MAX_STEP = 40;\nconst int ITERATION = 8;\nconst float LUCUNARITY = 1.2;\n#define AA 1\n\nvec3 moonDir = normalize(vec3(7.0, 1.0, -5.0));\n\nfloat hash1(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * 0.013);\n    p3 += dot(p3, p3.yzx + 19.31);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(in vec2 x) {\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    \n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return k0 + k1*u.x + k2*u.y + k4*u.x*u.y;\n}\n\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    \n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec2 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return vec3( -1.0 + 2.0 * (k0 + k1*u.x + k2*u.y + k4*u.x*u.y), \n                      2.0* du * vec2( k1 + k4*u.y,\n                                      k2 + k4*u.x ) );\n}\n\nconst mat2 m2 = mat2(1.2,  0.8, -0.8,  1.2);\nfloat fbm4(vec2 p) {\n    float amp = 1.0;\n    float h = 0.0;\n    for (int i = 0; i < ITERATION; i++) {\n        float n = noise(p);\n        h += amp * n;\n        amp *= 0.5;\n        p = m2 * p ;\n    }\n\treturn  h;\n}\n\n\nconst mat2 m = mat2(1.2, -0.6, 0.6, 1.2);\nvec4 fbmd4(vec2 v) {\n    \n    float amp = 1.0;\n    float f = 1.0 ;\n    float h = 0.0;\n    vec2 d = vec2(0.0);\n    for (int i = 0; i < ITERATION; i++) {\n        vec3 n = 1.0 - abs(noised(v * SCALE * f)); //noised(v * SCALE * f)\n        h += amp * n.x;\n        d += amp * n.yz * f;\n        amp *= 0.5;\n        f *= LUCUNARITY;\n        v = m * v;\n    }\n    h *= HEIGHT  ;\n\td *= HEIGHT * SCALE;\n\treturn vec4( h, normalize( vec3(-d.x,1.0,-d.y) ) );\n}\n\nvec4 terrainMap(vec3 v) {\n    vec4 terrain = fbmd4(v.xz - vec2(100.0, 0.0));\n    terrain.x += .02*noise(v.xz*0.8);\n    return terrain;\n}\n\n    \nvec4 sceneMap(vec3 v) {\n    return terrainMap(v);\n}\n\nvec3 getNormal(vec3 p )\n{\n    vec2 OFFSET = vec2(EPSILON, 0.0);\n    return normalize( vec3( sceneMap(p-OFFSET.xyy).x-sceneMap(p+OFFSET.xyy).x,\n                            1.0*EPSILON,\n                            sceneMap(p-OFFSET.yyx).x-sceneMap(p+OFFSET.yyx).x ) );\n}\nvec3 moon(vec3 ro, vec3 rd) {\n    float n1 = 0.3*noise(rd.xy * 20.0 - iTime);\n    float n2 = 0.3*noise(rd.xy * 10.0 - iTime);\n    float sdot = dot(rd, moonDir)*10.0;\n    float m1 = smoothstep(9.4, 9.75, sdot);\n    float col1 = pow(m1, 128.0);\n    float m2 = smoothstep(9.0+n1, 9.75, sdot);\n    float col2 = pow(m2, 64.0);\n    float m3 = smoothstep(8.2+n2, 9.7, sdot);\n    float col3 = pow(m3, 32.0);\n    float hole1 = (col2 -col1);\n    float hole2 = (col3 -col1);\n    vec3 rst = hole1*MOON*8.0 + hole2*BLUE*2.0;\n    return rst;\n}\n\n\nvec3 stars(vec2 p) {\n    float t = iTime * 0.1;\n    float n1 = hash1(p*0.1) ;\n    n1 *= pow(n1*n1, 680.0) ;\n    n1 *= sin(t*5.0 + p.x + sin(t*2.0 + p.y));\n    n1 = clamp(n1, 0.0, 1.0);\n    return n1 * vec3(1.0);\n}\n\nvec3 sky(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n    vec3 v = ro + rd*MAX_DISTANCE;\n    float n1 = noise(v.xy * 0.001);\n    float n2 = noise(v.yx * 0.001);\n    vec3 skyCol = GREEN * 0.01;\n    col += mix(skyCol, GREEN, exp(-16.0*v.y/MAX_DISTANCE));\n    col += stars(v.xy);\n    col += moon(ro, rd);\n    return col;\n}\n\nvec4 castRay(vec3 ro, vec3 rd) {\n    vec4 re = vec4(-1.0);\n    float t = 0.0;\n    for( int i=0; i<MAX_STEP; i++ ){\n        vec3 p = ro + rd * t;\n        vec4 n = sceneMap(p);\n        float h = p.y - n.x;\n    \tre = vec4(t, n.yzw);\n        t += h*n.z; \n        if ((abs(h) < EPSILON) || t > MAX_DISTANCE) {\n            break;\n        } \n    }\n    \n    if (t > MAX_DISTANCE) {\n        re = vec4(-1.0);\n    }\n    return re;\n}\n\nvec3 getShading(vec3 ro, vec3 rd, vec3 p, vec3 normal, vec3 color) {\n    vec3 col = vec3(0.0);\n    vec3 lightDir = moonDir;\n    float moonAmount = max(dot(rd, lightDir), 0.0);\n    vec3 lightCol = mix( GREEN, MOON, pow(moonAmount, 2.0));\n    \n    vec3 viewDir = normalize(ro - p); \n    vec3 refDir = reflect(-lightDir, normal);\n    \n    vec3 ambCol = lightCol * 0.1;\n    float diff = max(dot(lightDir, normal), 0.0);\n    vec3 diffCol = lightCol * diff;\n    \n    float spec = pow(max(dot(refDir, viewDir), 0.0), 8.0);\n    vec3 speCol = lightCol * spec * 0.7;\n    \n    \n    \n    col = (speCol + diffCol) * color ;\n    return col;\n}\n\nvec3 getMaterial(vec3 ro, vec3 rd, vec3 p, vec3 normal) {\n    //vec3 col = texture(iChannel1, p.xz * 0.0051, - 100.0).xyz * 0.5;\n    vec3 col = vec3(0.3, 0.1, 0.1);\n    vec3 lightDir = moonDir;\n    //a bit of sprinkling\n    if (hash1(p.xz) > 0.995) {\n    \tcol += clamp(sin(iTime + p.x*p.z), 0.5, 1.0) * vec3(1.2);\n  \t}\n    \n    return col;\n}\n\nvec3 terrainColor(vec3 ro, vec3 rd, vec3 p, vec3 nor) {\n    vec3 col = vec3(0.0);\n    col = getMaterial(ro, rd, p, nor);\n    col = getShading(ro, rd, p, nor, col) ;\n    \n    return col;\n}\n\nvec3 fog(vec3 ro, vec3 rd, vec3 p, vec3 pixCol, float dis)\n{\n    vec3 lightDir = moonDir;\n    //base color and moonlight\n    vec3 fogCol = vec3(0.0);\n    float b  = 0.000005;\n    float fogAmount = 1.0 - exp( -dis*dis*b );\n    \n    float moonAmount = max(dot(rd, lightDir), 0.0);\n    vec3 mixFog = mix(GREEN, MOON*0.5, pow(moonAmount, 16.0));\n\tfogCol = mix( pixCol, mixFog, fogAmount );\n   \n    //adding density\n    float c = 0.001;\n    float b1 = 0.15;\n    float t = iTime ;\n    float v = 1.0;\n    vec3  denCol  = GREEN; \n    float density =  c * exp(-ro.y*b1) * (1.0 - exp(-dis*rd.y*b1 ))/(rd.y);\n    \n    float turb = fbm4(vec2(p.x*0.02+t*v, p.z*0.02+t*v));\n    density += 0.05*turb;\n    fogCol += mix( pixCol, denCol, density);\n    return fogCol;\n}\n\nmat3 getCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 render( in vec2 fragCoord)\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy ;\n    //uv -= 0.5; // translate to the center of the screen\n    uv.x *= iResolution.x / iResolution.y; // restore aspect ratio\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse -= 0.5;\n    //define camera\n    vec3 ro = vec3 (cos(mouse.x * 6.28) * 10.0, 0.0, sin(mouse.x * 6.28) * 10.0);\n    vec3 ta = vec3 (0.0, 1.0, -2.0);\n    mat3 cam = getCamera(ro, ta, 0.0);\n\n    vec3 rd = normalize(cam * vec3(uv, 1.0));\n    \n    //draw scene\n   \tvec3 color = vec3(0.0);\n    vec4 hnor = castRay(ro, rd);\n    vec3 p = ro + rd * hnor.x;\n    \n    if (hnor.x > EPSILON) {\n        //vec3 nor = hnor.yzw + 0.01*hash1(p.xz * 5.0);\n        vec3 nor= getNormal(p) ;\n        color += terrainColor(ro, rd, p, nor);  \n        color = fog(ro, rd, p, color, hnor.x);\n    } else {\n        color += sky(ro, rd);\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pixCol = vec3(0.0);\n    vec2 offset = vec2(0.0);\n    \n#if AA>1\n    for (float y = 0.0; y < float(AA); ++y)\n    {\n        for (float x = 0.0; x < float(AA); ++x)\n        {\n            offset = -0.5 + vec2(x, y) / float(AA);\n\n        \tpixCol += render(fragCoord+offset);\n        }\n    }\n    pixCol /= float(AA*AA);\n#else\n    pixCol += render(fragCoord);\n#endif\n        \n    pixCol = pow( pixCol, vec3(1.0/2.2) );\n    \n    // Output to screen\n    fragColor = vec4(pixCol, 1.0);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsXGR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtB3Wt", "name": "4D Rounded Box", "author": "iq", "description": "I raymarched a 3D slice of a 4D box. The 3D slice (plane) that cuts the 4D box is animated over time, and the cube itself is rotating in 4D space. Note this is NOT 4D raymarching, it is 3D raymarching (of a 3D slice of a 4D world).", "tags": ["raymarching", "sdf", "4d", "box"], "likes": 23, "viewed": 2902, "date": "1563518185", "time_retrieved": "2024-06-20T19:41:17.901155", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// I raymarched a 3D slice of a 4D rounded box. The 3D slice (plane) that\n// cuts the 4D box is animated over time, and the cube itself is rotating\n// in 4D space. Note this is NOT 4D raymarching, it is 3D raymarching (of\n// a 3D slice of a 4D world).\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // Set AA to 1 if your machine is too slow\n#endif\n\n\nfloat sdBox( in vec4 p, in vec4 b )\n{\n    vec4 d = abs(p) - b;\n    return min( max(max(d.x,d.y),max(d.z,d.w)),0.0) + length(max(d,0.0));\n}\n\nmat4x4 q2m( in vec4 q )\n{\n    return mat4x4( q.x, -q.y, -q.z, -q.w,\n                   q.y,  q.x, -q.w,  q.z,\n                   q.z,  q.w,  q.x, -q.y,\n                   q.w, -q.z,  q.y, q.x );\n}\n\nfloat map( in vec3 pos, float time )\n{\n    // take a 3D slice\n    vec4 p = vec4(pos,0.5*sin(time*0.513));\n    \n    // rotate 3D point into 4D\n\tvec4 q1 = normalize( cos( 0.2*time*vec4(1.0,1.7,1.1,1.5) + vec4(0.0,1.0,5.0,4.0) ) );\n\tvec4 q2 = normalize( cos( 0.2*time*vec4(1.9,1.7,1.4,1.3) + vec4(3.0,2.0,6.0,5.0) ) );\n    p = q2m(q2)*p*q2m(q1);\n    \n    // 4D box\n    return sdBox( p, vec4(0.8,0.5,0.7,0.2) )- 0.03;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.00025;\n    return normalize( e.xyy*map( pos + e.xyy*eps, time ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, time ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, time ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, time ) );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float time )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<128; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, time );\n        res = min( res, 16.0*h/t );\n        t += clamp( h, 0.01, 0.25 );\n        if( res<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd, in float time )\n{\n    vec2 res = vec2(1e20,-1.0);\n    \n    // plane\n    {\n    float t = (-1.0-ro.y)/rd.y;\n    if( t>0.0 ) res = vec2(t,1.0);\n    }\n\n    {\n    // box\n    float tmax = min(6.0,res.x);\n    float t = 0.4;\n    for( int i=0; i<128; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map(pos, time);\n        if( h<0.001 || t>tmax ) break;\n        t += h;\n    }\n    if( t<tmax && t<res.x ) res = vec2(t,2.0);\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float di = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+di)/float(AA*AA-1);\n        \n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n\n\t    // create view ray\n        vec3 ro = vec3(-0.5,0.0,2.5);\n        vec3 rd = normalize( vec3(p,-1.8) );\n         // ray differentials\n        vec2 px = (-iResolution.xy+2.0*(fragCoord.xy+vec2(1.0,0.0)))/iResolution.y;\n        vec2 py = (-iResolution.xy+2.0*(fragCoord.xy+vec2(0.0,1.0)))/iResolution.y;\n        vec3 rdx = normalize( vec3(px,-1.8) );\n        vec3 rdy = normalize( vec3(py,-1.8) );\n\n        // raymarch\n        vec2 tm = intersect( ro, rd, time );\n        vec3 col = vec3(0.6,0.75,0.85) - 0.97*rd.y;\n        if( tm.y>0.0 )\n        {\n            // shading/lighting\t\n            vec3 pos = ro + tm.x*rd;\n            vec3 nor = (tm.y<1.5)?vec3(0.0,1.0,0.0):calcNormal(pos,time);\n            vec3 lig = normalize(vec3(0.8,0.4,0.6));\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            vec3  hal = normalize(lig-rd);\n            float sha = calcSoftshadow( pos+0.001*nor, lig, 0.001, 4.0, time );\n            float amb = 0.6 + 0.4*nor.y;\n            float bou = clamp(-nor.y,0.0,1.0);\n            float spe = clamp(dot(nor,hal),0.0,1.0);\n            col  = 3.5*vec3(1.00,0.80,0.60)*dif*sha;\n            col += 4.0*vec3(0.12,0.18,0.24)*amb;\n            col += 2.0*vec3(0.30,0.20,0.10)*bou;\n            \n            if( pos.y<-.99 )\n            {\n                // project pixel footprint into the plane\n                vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n                vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n                float f = checkersGradBox( 2.0*pos.xz, 2.0*dpdx.xz, 2.0*dpdy.xz );\n                col *= 0.2 + f*vec3(0.05);\n            }\n            else\n            {\n                col *= 0.25;\n            }\n            \n            col += 0.2*pow(spe,8.0)*dif*sha;\n            \n            col = mix( col, vec3(0.6,0.7,0.8), 1.0-exp(-0.001*tm.x*tm.x) );           \n        }\n\n        // gamma        \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    tot = pow( tot, vec3(0.45) );\n    \n    tot = clamp(tot,0.0,1.0);\n        \n    tot = tot*tot*(3.0-2.0*tot);\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/WtB3Wt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtfSD7", "name": "Endless path", "author": "bkpjjj", "description": "just playing with ray marching", "tags": ["raymarching", "noise", "simplex"], "likes": 6, "viewed": 211, "date": "1563132494", "time_retrieved": "2024-06-20T19:41:17.901155", "image_code": "\nvec3 mod3D289( vec3 x ) { return x - floor( x / 289.0 ) * 289.0; }\nvec4 mod3D289( vec4 x ) { return x - floor( x / 289.0 ) * 289.0; }\nvec4 permute( vec4 x ) { return mod3D289( ( x * 34.0 + 1.0 ) * x ); }\nvec4 taylorInvSqrt( vec4 r ) { return 1.79284291400159 - r * 0.85373472095314; }\n//simplex noise3D\nfloat snoise( vec3 v )\n{\n\tconst vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );\n\tvec3 i = floor( v + dot( v, C.yyy ) );\n\tvec3 x0 = v - i + dot( i, C.xxx );\n\tvec3 g = step( x0.yzx, x0.xyz );\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min( g.xyz, l.zxy );\n\tvec3 i2 = max( g.xyz, l.zxy );\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy;\n\tvec3 x3 = x0 - 0.5;\n\ti = mod3D289( i);\n\tvec4 p = permute( permute( permute( i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) ) + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) ) + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );\n\tvec4 j = p - 49.0 * floor( p / 49.0 );  // mod(p,7*7)\n\tvec4 x_ = floor( j / 7.0 );\n\tvec4 y_ = floor( j - 7.0 * x_ );  // mod(j,N)\n\tvec4 x = ( x_ * 2.0 + 0.5 ) / 7.0 - 1.0;\n\tvec4 y = ( y_ * 2.0 + 0.5 ) / 7.0 - 1.0;\n\tvec4 h = 1.0 - abs( x ) - abs( y );\n\tvec4 b0 = vec4( x.xy, y.xy );\n\tvec4 b1 = vec4( x.zw, y.zw );\n\tvec4 s0 = floor( b0 ) * 2.0 + 1.0;\n\tvec4 s1 = floor( b1 ) * 2.0 + 1.0;\n\tvec4 sh = -step( h, vec4(0.0) );\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\tvec3 g0 = vec3( a0.xy, h.x );\n\tvec3 g1 = vec3( a0.zw, h.y );\n\tvec3 g2 = vec3( a1.xy, h.z );\n\tvec3 g3 = vec3( a1.zw, h.w );\n  \tvec4 norm = taylorInvSqrt( vec4( dot( g0, g0 ), dot( g1, g1 ), dot( g2, g2 ), dot( g3, g3 ) ) );\n\tg0 *= norm.x;\n\tg1 *= norm.y;\n\tg2 *= norm.z;\n\tg3 *= norm.w;\n\tvec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );\n\tm = m* m;\n\tm = m* m;\n\tvec4 px = vec4( dot( x0, g0 ), dot( x1, g1 ), dot( x2, g2 ), dot( x3, g3 ) );\n\treturn 42.0 * dot( m, px);\n}\n\nfloat sdf_Cylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdf_plane(vec3 rp,vec4 p){\n    \n \treturn dot(rp,normalize(p.xyz))+p.w;  \n}\n\nfloat sdf(vec3 rp){\n \t\n    vec3 p = rp;\n    \n    p.y += snoise(rp*0.1)*0.5+0.5;\n    p.y += snoise(rp*0.01)*5.0+5.0;\n    p.y += snoise(rp*0.001)*10.0+5.0;\n    \n    vec3 cp = rp+vec3(6.0,0,0);\n    vec3 cp2 = rp+vec3(6.,3,0);\n \n   cp.xz = mod(cp.xz+6.,12.0)-6.;\n  cp.y = mod(cp.y+1.,2.0)-1.;\n    cp2.xz = mod(cp2.xz+6.,12.0)-6.;\n  cp2.y = mod(cp2.y+1.,2.0)-1.;\n\n    \n    float c = sdf_Cylinder(cp,1.0,0.8);\n    float c2 = sdf_Cylinder(cp2,1.1,0.2);\n    \n    return min(c,min(c2,sdf_plane(p,vec4(0,1,0,1))));\n}\n\n\nfloat RayMarch(vec3 ro , vec3 rd , int MAX_IT , out float steps){\n \tfloat z = 0.;\n    \n    for(int i = 0;i <= MAX_IT;i++){\n        steps = float(i);\n        if(z > 100.){steps=0.;break;}\n        \n        vec3 rp = ro + rd * z;\n        \n        float l = sdf(rp);\n        \n        \n        if(l < 0.001){break;}\n        \n        z += l;\n    }\n  \tsteps /= float(MAX_IT);\n    return z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.,5.,-5);\n    ro.z += iTime*10.0;\n    \n    vec3 mv = ro;\n    \n    ro.y -= snoise(mv*0.1)*0.5+0.5;\n    ro.y -= snoise(mv*0.01)*5.0+5.0;\n    ro.y -= snoise(mv*0.001)*10.0+5.0;\n    \n    vec3 rd = normalize(vec3(uv,1.));\n    \n    float a = sin(iTime*2.0)*0.04;\n    \n    rd.xy *= mat2x2(cos(a),sin(a),-sin(a),cos(a));\n    \n    float steps = 0.;\n    \n    float l = RayMarch(ro , rd ,100,steps);\n\n    vec3 rp = ro + rd * l;\n    \n    float fog = l/100.;\n    \n    vec3 col = vec3(0.8,0.2,0.)+vec3(1,1,0)*vec3(steps);\n    \n    col = mix(col , mix(vec3(0.8,0.5,0.2),vec3(0.2,0.2,1.),clamp(rp.y*0.01,0.,1.)), clamp(fog,0.,1.));\n\t\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtfSD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtfSDj", "name": "Hommage à Le Parc I", "author": "sschmidtix", "description": "Based on Julio Le Parc's painting [url]https://www.artbasel.com/catalog/artwork/45703[/url]\n\nWatch in full screen. Take your time and enjoy.", "tags": ["2d", "flow", "art", "opart", "cineticart"], "likes": 6, "viewed": 478, "date": "1564301861", "time_retrieved": "2024-06-20T19:41:18.361594", "image_code": "// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Copyright © 2019 Stefan Schmidt\n//\n// Hommage à Le Parc I\n// Based on Julio Le Parc's painting https://www.artbasel.com/catalog/artwork/45703\n//\n// Watch in full screen. Take your time and enjoy.\n//\n// Thanks to Fabrice Neyret for helping optimize the code.\n// ---------------------------------------------------------------------\n\n// Parameters\n#define GRID_DIV    13.\n#define ROT_PERIOD  45.\n#define RECT_SIZE   vec2(0.6, 0.06)\n\n// Constants\n#define GRID_DIVN1  (GRID_DIV - 1.)\n#define M_PI        3.1415926535\n#define R           iResolution\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat rect(vec2 p, vec2 c) {\n    vec2 d = abs(p) - c;\n    return smoothstep(1., -1., max(d.x, d.y) * R.y);\n}\n\n#define triWave(n) abs(mod(n + GRID_DIVN1, 2. * GRID_DIVN1) - GRID_DIVN1) / max(GRID_DIV - 1., 1.)\n\nfloat rects(vec2 p, float mode) {\n    p += mode / GRID_DIV / 4.;   \n    vec2 a = abs(p);\n    if (max(a.x, a.y) > .5)\n        return 0.;\n    \n    p *= GRID_DIV;   \n    vec2 pi = round(p + .5 * GRID_DIVN1);\n    \n    float n = mode < 0. ? pi.x + pi.y : pi.x - pi.y;\n    float angle = M_PI * (2. / ROT_PERIOD * iTime + triWave(n));\n    if (mode > 0.)\n        angle -= M_PI / 2.;\n    p = rot(angle) * (fract(p + .5 * mod(GRID_DIV, 2.)) - .5);\n    \n    return rect(p / GRID_DIV, .5 * RECT_SIZE / GRID_DIV);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 pp = 1.1 * vec2(-1., 1.) * (p - .5 * R.xy) / R.y;\n    \n    float val = .008 + rects(pp, 1.) + rects(pp, -1.);\n    \n    val = pow(val, 1. / 2.2);\n    \n    vec2 uv = p.xy / R.xy;\n    val *= 0.5 + 0.5 * pow(16.0 * uv.x * uv.y *\n                           (1.0 - uv.x) * (1.0 - uv.y), 0.2);\n    \n    o = vec4(val, val, val, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtfSDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtfSDl", "name": "共犯退治", "author": "Hirai_worthless", "description": "snake in the mist.", "tags": ["raymarching"], "likes": 7, "viewed": 121, "date": "1564554562", "time_retrieved": "2024-06-20T19:41:18.361858", "image_code": "mat2 genRot(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\nfloat PI = 3.14159265;\nvec3 path(float t){\n\tfloat x = clamp(sin(t) * pow(2.0,0.5),-1.0,1.0) * 0.75;\n    float y = clamp(cos(t) * pow(2.0,0.5),-1.0,1.0) * 0.75;\n    float z = 0.;\n    return vec3(x,y,z);\n}\nfloat map(vec3 p){\n    p.xz *= genRot(PI / 4.);\n    p.yz *= genRot(PI / 4.);\n    p.xy *= genRot(iTime);\n\tp.x = fract(abs(p.x) * 0.5) * 2.0;\n    p.y = fract(abs(p.y) * 0.5) * 2.0;\n    p.z = fract(abs(p.z) * 1.0) * 1.0;\n    p -= vec3(1.0,1.0,0.5);\n    float sphere = length(p - path(iTime)) - 0.25;\n    float trail = 100000.0;\n    for(float i = 0.0; i <4.0; i += 0.25){\n    \ttrail = min(trail,length(p - path(iTime - i)) - 0.1);\n    }\n    return min(sphere,trail);\n}\n\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 96; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return vec4(getNormal(p),t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 R = iResolution,\n    r = normalize(vec3((2.*U - R.xy )/  R.y,1.2)),\n    o = vec3(0,0,-2.5);\n    vec4 data = trace(o,r);\n    vec3 n = vec3(data.xyz);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    vec3 fc = t > 10000.0 ? vec3(0.8) : mix((vec3(data.x,data.y,data.z) + 1.0)/1.5\n                                            ,vec3(0.0), - pow(dot(n,r),1.0));\n\tfc = mix(fc,vec3(1.0),1.0 - fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtfSDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtfSR8", "name": "Coordinate transform variety ", "author": "mosaic", "description": "Variety of transforms on the coordinate system (uv)\nBonus effect: click & drag\n\nOriginal triangle pattern from https://www.shadertoy.com/view/ltjGWt", "tags": ["2d"], "likes": 2, "viewed": 115, "date": "1562016561", "time_retrieved": "2024-06-20T19:41:18.610338", "image_code": "float divScotFlag( vec2 uv) {\n    float botRight = step( uv.x + uv.y, 1. );\n    float botLeft = step( uv.x + 1. - uv.y, 1. );\n    \n    // Scottish flag ( sorta )\n    float scotFlag = abs(botRight - botLeft);\n    float divider = step( uv.x, .5);\n    \n    // Divided scottish flag\n    return abs( divider - scotFlag);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y; // Aspect Ratio adjustment\n    \n     if (iMouse.z <= 0.){\n    \n    if (uv.x < -0.5) uv=(uv+0.6)*rotate2d(iTime/5.); //rotate\n         \n    else if (uv.x >= -.5 && uv.x < 0.)  uv.x+=sin(iTime/5.+uv.y);  //wave\n        \n    else if (uv.x >=0. && uv.x < 0.5)  uv*=(2./1.+sin(iTime/2.)); //zoom\n        \n    else if ( uv.x >= 0.5)    uv.y/=((uv.x))+cos(iTime/2.)+0.8; // flower\n    \n         }\n          //mod instead of \"pow\" here is nice too\n    else uv=(pow(abs(rotate2d(3.14*.25*sin(iTime/5.))*uv),iMouse.xy/iResolution.y)-iTime/20.);\n         \n    uv.y *= 5./3.; // adjust height width ratio\n\n    // Checker pattern\n\tfragColor = vec4(\n        vec3( divScotFlag( fract(uv * 4.) ) )+.4, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtfSR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtfSRl", "name": "Shine a light", "author": "2017301580082", "description": "Let's shake it!\nWith the change of the music frequency,not only the shape of some balls will change,but also the light will vibrate with the music.", "tags": ["3d", "raytracing", "ball", "volumelight"], "likes": 3, "viewed": 248, "date": "1563882249", "time_retrieved": "2024-06-20T19:41:23.434911", "image_code": "//============================================================================\n// Constants.\n//============================================================================\n\n\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.010 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nconst int NUM_LIGHTS = 10;\nconst int NUM_MATERIALS = 6;\nconst int NUM_PLANES = 2;\nconst int NUM_SPHERES = 17;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.0, 0.0, 0.0 );\n\n // Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0; \n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\nconst float EXPOSURE = 12.0;\nconst float OMNI_LIGHT = 0.1;\nconst float FLOOR_REFLECTION = 0.15;\n\n\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float TAU = 2.0 * PI;\nconst float BIG = 1e30;\nconst float EPSILON = 1e-10;\nconst float THETA = (1.0 + 2.2360679775) / 2.0;\nconst float INV_THETA = 1.0 / THETA;\nstruct Intersection\n{\n    float dist;\n    vec3 normal;\n};\n\nstruct Result\n{\n    Intersection start;\n    Intersection end;\n};\n    \nstruct Range\n{\n\tfloat start;\n    float end;\n};\nmat4 rotateX(float v)\n{\n    float c = cos(v);\n    float s = sin(v);\n    \n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0,   c,   s, 0.0,\n        0.0,  -s,   c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateY(float v)\n{\n    float c = cos(v);\n    float s = sin(v);\n    \n    return mat4(\n          c, 0.0,  -s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n          s, 0.0,   c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateZ(float v)\n{\n    float c = cos(v);\n    float s = sin(v);\n    \n    return mat4(\n          c,   s, 0.0, 0.0,\n         -s,   c, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\nfloat tt;\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n    vec3 d;\n    vec3 c;\n    float a;\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of \n// Lecture 11 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS { \n//                   I_a * k_a + \n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene(in vec2 fragCoord)\n{\n    \n    // create pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// first texture row is frequency data\n\tfloat f  = texture( iChannel0, vec2(uv.x,0.25) ).x; \n    float ft  = texture( iChannel0, vec2(0.25,0.25) ).x; \n\n    \n    // Horizontal plane.\n\tPlane[0].A = 0.0;\n\tPlane[0].B = 1.0;\n\tPlane[0].C = 0.0;\n\tPlane[0].D = 0.0;\n\tPlane[0].materialID = 4;\n    \n    //  plane.\n\tPlane[1].A = 1.0;\n\tPlane[1].B = 0.0;\n\tPlane[1].C = 0.0;\n\tPlane[1].D = 8.0;\n\tPlane[1].materialID = 0;\n    \n    \n\n\n\t// Sphere 1\n\tSphere[0].center = vec3(-4.0*sin(1.5*iTime), abs(1.5*sin(iTime))+0.5 , -4.0*cos(1.5*iTime));\n\tSphere[0].radius = 0.2;\n\tSphere[0].materialID = 2;\n\n\t// Sphere 2\n\tSphere[1].center = vec3(2.8, abs(2.0*sin(ft ))-0.35 , 0.0);\n\tSphere[1].radius = 0.35;\n\tSphere[1].materialID = 1;\n\n\t// Sphere 3\n\tSphere[2].center = vec3(-4.0*sin(1.5*iTime + 2.0*3.1415926535 / 8.0), abs(1.5*sin(2.0*iTime + 2.0*3.1415926535 / 8.0)) + 0.5, -4.0*cos(1.5*iTime + 2.0*3.1415926535 / 8.0));\n\tSphere[2].radius = 0.2;\n\tSphere[2].materialID = 2;\n\n\t// Sphere 4.\n\tSphere[3].center = vec3(2.0, abs(2.0*sin( f )) - 0.35, 2.0);\n\tSphere[3].radius = 0.35;\n\tSphere[3].materialID = 1;\n\n\t// Sphere 5\n\tSphere[4].center = vec3(-4.0*sin(1.5*iTime + 4.0*3.1415926535 / 8.0), abs(1.5*sin(2.0*iTime + 4.0*3.1415926535 / 8.0)) + 0.5, -4.0*cos(1.5*iTime + 4.0*3.1415926535 / 8.0));\n\tSphere[4].radius = 0.2;\n\tSphere[4].materialID = 2;\n\n\t// Sphere 6\n\tSphere[5].center = vec3(0.0, abs(2.0*sin(ft)) - 0.35, 2.8);\n\tSphere[5].radius = 0.35;\n\tSphere[5].materialID = 1;\n\n\t// Sphere 7\n\tSphere[6].center = vec3(-4.0*sin(1.5*iTime + 6.0*3.1415926535 / 8.0), abs(1.5*sin(2.0*iTime + 6.0*3.1415926535 / 8.0)) + 0.5, -4.0*cos(1.5*iTime + 6.0*3.1415926535 / 8.0));\n\tSphere[6].radius = 0.2;\n\tSphere[6].materialID = 2;\n\n\t// Sphere 8\n\tSphere[7].center = vec3(-2.0, abs(2.0*sin(f )) - 0.35, 2.0);\n\tSphere[7].radius = 0.35;\n\tSphere[7].materialID = 1;\n\n\t// Sphere 9.\n\tSphere[8].center = vec3(4.0*sin(1.5*iTime), abs(1.5*sin(2.0*iTime)) + 0.5, 4.0*cos(1.5*iTime));\n\tSphere[8].radius = 0.2;\n\tSphere[8].materialID = 2;\n\n\t// Sphere 10\n\tSphere[9].center = vec3(-2.8, abs(2.0*sin(ft )) - 0.35, 0.0);\n\tSphere[9].radius = 0.35;\n\tSphere[9].materialID =1;\n\n\t// Sphere 11\n\tSphere[10].center = vec3(4.0*sin(1.5*iTime + 2.0*3.1415926535 / 8.0), abs(1.5*sin(2.0*iTime + 2.0*3.1415926535 / 8.0)) + 0.5, 4.0*cos(1.5*iTime + 2.0*3.1415926535 / 8.0));\n\tSphere[10].radius = 0.2;\n\tSphere[10].materialID = 2;\n\n\t// Sphere 12\n\tSphere[11].center = vec3(-2.0, abs(2.0*sin(f )) - 0.35, -2.0);\n\tSphere[11].radius = 0.35;\n\tSphere[11].materialID = 1;\n\n\t// Sphere 13\n\tSphere[12].center = vec3(4.0*sin(1.5*iTime + 4.0*3.1415926535 / 8.0), abs(1.5*sin(2.0*iTime + 4.0*3.1415926535 / 8.0)) + 0.5, 4.0*cos(1.5*iTime + 4.0*3.1415926535 / 8.0));\n\tSphere[12].radius = 0.2;\n\tSphere[12].materialID = 2;\n\n\t// Sphere 14\n\tSphere[13].center = vec3(-0.0, abs(2.0*sin(ft )) -0.35, -2.8);\n\tSphere[13].radius = 0.35;\n\tSphere[13].materialID = 1;\n\n\t// Sphere 15\n\tSphere[14].center = vec3(4.0*sin(1.5*iTime + 6.0*3.1415926535 / 8.0), abs(1.5*sin(2.0*iTime + 6.0*3.1415926535 / 8.0)) + 0.5, 4.0*cos(1.5*iTime + 6.0*3.1415926535 / 8.0));\n\tSphere[14].radius = 0.2;\n\tSphere[14].materialID = 2;\n\n\t// Sphere 16\n\tSphere[15].center = vec3(2.0, abs(2.0*sin(f)) -0.35, -2.0);\n\tSphere[15].radius = 0.35;\n\tSphere[15].materialID = 1;\n\n\t// Sphere 17\n\tSphere[16].center = vec3(0.0, abs(1.0*sin(iTime))+1.5, 0.0);\n\tSphere[16].radius = 0.8*sin(f*iTime) + 0.5;\n\tSphere[16].materialID = 3;\n\n\n\n\n\t// Silver material.\n\tMaterial[0].k_d = vec3(0.5, 0.5, 0.5);\n\tMaterial[0].k_a = 0.2 * Material[0].k_d;\n\tMaterial[0].k_r = 2.0 * Material[0].k_d;\n\tMaterial[0].k_rg = 0.5 * Material[0].k_r;\n\tMaterial[0].n = 64.0;\n\n\t// Random material.\n\tMaterial[1].k_d = vec3(0.90,0.83,0.37 );\n\tMaterial[1].k_a = 0.2 * Material[1].k_d;\n\tMaterial[1].k_r = 2.0 * Material[1].k_d;\n\tMaterial[1].k_rg = 0.5 * Material[1].k_r;\n\tMaterial[1].n = 64.0;\n\n\t// Random material.\n\tMaterial[2].k_d = vec3(0.5*abs(sin(0.125*iTime)), abs(sin(0.25*iTime + 1.0)), abs(sin(0.25*iTime + 2.0)));\n\tMaterial[2].k_a = 0.2 * Material[2].k_d;\n\tMaterial[2].k_r = vec3(1.0, 1.0, 1.0);\n\tMaterial[2].k_rg = 0.5 * Material[2].k_r;\n\tMaterial[2].n = 128.0;\n\n\t// Random material.\n\tMaterial[3].k_d = vec3(0.6*abs(sin(0.5*iTime)), abs(sin(0.5*iTime + 3.0)), abs(sin(0.5*iTime + 5.0)));\n\tMaterial[3].k_a = 0.2 * Material[2].k_d;\n\tMaterial[3].k_r = vec3(1.0, 1.0, 1.0);\n\tMaterial[3].k_rg = 0.5 * Material[2].k_r;\n\tMaterial[3].n = 128.0;\n    \n    //  material.\n\tMaterial[4].k_d = vec3(0.5, 0.5, 0.5);\n\tMaterial[4].k_a = 0.2 * Material[0].k_d;\n\tMaterial[4].k_r = 2.0 * Material[0].k_d;\n\tMaterial[4].k_rg = 0.5 * Material[0].k_r;\n\tMaterial[4].n = 64.0;\n  \n\n    // Light 0.\n    Light[0].position = vec3( 2.0*sin(iTime), 15.0, 2.0*cos(iTime)-2.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    \n\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n\tmat4 TT=mat4(\n\t\t1.0,0,0,-sph.center.x,\n\t\t0,1,0,-sph.center.y,\n\t\t0,0,1,-sph.center.z,\n\t\t0,0,0,1);\n\tmat4 T=transpose(TT);\n\n\tray.o=vec3(T*vec4(ray.o,1.0));\n\n\n    float a = dot( ray.d, ray.d );\n    float b = 2.0*dot( ray.d, ray.o );\n    float c = dot( ray.o, ray.o )-sph.radius*sph.radius;\n    float d = b*b-4.0*a*c;\n\n    if ( d<0.0 ) return false;\n    \n    float t1 = (-b+sqrt(d) ) / (2.0*a);\n\tfloat t2 = (-b-sqrt(d) ) / (2.0*a);\n    \n\n\t// We have a hit -- output results.\n\n\tif((t1 >= tmin && t1 <= tmax))\n\t{\n\t   if((t2 >= tmin && t2 <= tmax)) t=min(t1,t2);\n\t   else  t=t1;\n\t}\n\telse  t=t2;\n    \n\t\n    hitPos = ray.o + t * ray.d;\n    hitNormal = normalize( hitPos );\t\n\thitPos=vec3(inverse(T)*vec4(hitPos,1.0));\n\n    if ( (t1 >= tmin && t1 <= tmax) || (t2 >= tmin && t2 <= tmax) ) return true;\n    return false;  \n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n     \n    \n\tmat4 TT=mat4(\n\t\t1.0,0,0,-sph.center.x,\n\t\t0,1,0,-sph.center.y,\n\t\t0,0,1,-sph.center.z,\n\t\t0,0,0,1);\n\n\tmat4 T=transpose(TT);\n    ray.o=vec3(T*vec4(ray.o,1.0));\n\n    float a = dot( ray.d, ray.d );\n    float b = 2.0*dot( ray.d, ray.o );\n    float c = dot( ray.o, ray.o )-sph.radius*sph.radius;\n\tfloat d = b*b-4.0*a*c;\n\n    float t1 = (-b+sqrt(d) ) / (2.0*a);\n\tfloat t2 = (-b-sqrt(d) ) / (2.0*a);\n\n\n    if ( (t1 >= tmin && t1 <= tmax) || (t2 >= tmin && t2 <= tmax) ) return true;\n    return false;  \n\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a + \n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray, \n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg ) \n{\n    // Find whether and where the ray hits some object. \n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    for(int i=0;i<NUM_PLANES;i++)\n    {\n        temp_hasHit=false;\n        temp_hasHit=IntersectPlane(Plane[i],ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if((temp_t<nearest_t) && temp_hasHit)\n        {\n            hasHitSomething = true;\n            nearest_t=temp_t;\n\t\t\ttt=temp_t;\n            nearest_hitNormal=temp_hitNormal;\n            nearest_hitPos=temp_hitPos;\n            nearest_hitMatID=Plane[i].materialID;\n        }\n    }\n    for(int i=0;i<NUM_SPHERES;i++)\n    {\n        temp_hasHit=false;\n\n        temp_hasHit=IntersectSphere(Sphere[i],ray, DEFAULT_TMIN , DEFAULT_TMAX , temp_t , temp_hitPos , temp_hitNormal);\n        if((temp_t<nearest_t) && temp_hasHit)\n        {\n            hasHitSomething = true;\n            nearest_t=temp_t;\n\t\t\ttt=temp_t;\n            nearest_hitNormal=temp_hitNormal;\n            nearest_hitPos=temp_hitPos;\n            nearest_hitMatID=Sphere[i].materialID;\n        }\n\n    }\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point. \n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the \n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\tbool k_shadow=false;\n    Ray_t shadowray;\n\t//vec3 I_local=vec3(0.0);\n    \n\tfor(int j=0;j<NUM_LIGHTS;j++)\n\t{\n        shadowray.o=nearest_hitPos;\n\t\tshadowray.d=normalize((Light[j].position-nearest_hitPos));\n\t\tk_shadow=false;\n        \n        for(int i=0;i<NUM_SPHERES;i++)\n\t\t{\n            if(k_shadow)break;\n\n\t\t\tk_shadow=IntersectSphere(Sphere[i],shadowray, DEFAULT_TMIN , distance(nearest_hitPos, Light[j].position));\n\t\t}\n        if(!k_shadow)\n\t\tfor(int i=0;i<NUM_PLANES;i++)\n\t\t{\n             if(k_shadow)break;\n\n\t\t\tk_shadow=IntersectPlane(Plane[i],shadowray, DEFAULT_TMIN , distance(nearest_hitPos, Light[j].position));\n\t\t}\n\n        vec3 L=shadowray.d;\n\t\tvec3 N=normalize(nearest_hitNormal);\n\t\tvec3 V=nearest_hitPos;\n\t\tI_local+=PhongLighting(  L,  N\t,  -normalize(ray.d), k_shadow, \n        \t\tMaterial[nearest_hitMatID],Light[j] );\n\t\n\t}\n\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nfloat insideCone(vec3 direction, float angle, vec3 o)\n{\n    float oz = dot(o, direction);\n    vec3 oxy = o - direction * oz;\n    float c = dot(oxy, oxy) / (angle * angle) - (oz * oz);\n    return smoothstep(20.0, -50.0, c);\n}\n\nRange cone(vec3 direction, float angle, Ray_t ray)\n{\n    float dz = dot(ray.d, direction);\n    float oz = dot(ray.o, direction);\n    vec3 dxy = ray.d - direction * dz;\n    vec3 oxy = ray.o - direction * oz;\n    \n    float a = dot(dxy, dxy) - (dz * dz * angle * angle);\n    float b = dot(dxy, oxy) - (dz * oz * angle * angle);\n    float c = dot(oxy, oxy) - (oz * oz * angle * angle);\n    \n    float p = 2.0 * b / a;\n    float q = c / a;\n    \n    float r = p * p / 4.0 - q;\n    \n    Range result;\n    result.start = BIG;\n    result.end = -BIG;\n    \n    if (r >= 0.0)\n    {\n        float m = -p / 2.0;\n        float sr = sqrt(r);\n            \n        if (c < 0.0)\n        {\n\t\t\t// Inside\n            if (m + sr < 0.0)\n            {\n                // Both solutions behind us\n                result.start = 0.0;\n                result.end = BIG;\n            }\n            else if (m - sr < 0.0)\n            {\n                // One solution behind us\n                result.start = 0.0;\n                result.end = m + sr;\n            }\n            else\n            {\n                // Both solutions ahead\n                result.start = 0.0;\n            \tresult.end = m - sr;\n            }\n        }\n        else\n        {\n            // Outside\n            if (m + sr < 0.0)\n            {\n                // Both solutions behind us\n                return result;\n            }\n            else if (m - sr < 0.0)\n            {\n                // One solution behind us\n                result.start = m + sr;\n                result.end = BIG;\n            }\n            else\n            {\n                // Both solutions ahead\n                result.start = m - sr;\n            \tresult.end = m + sr;\n            }\n        }\n    }\n    \n    return result;\n}\n\nResult plane(vec3 pos, vec3 normal, Ray_t ray)\n{\n    ray.o -= pos;\n    \n    float rdn = dot(ray.d, normal);\n    float ron = dot(ray.o, normal);\n    \n    Result result;\n    result.start.normal = normal;\n    result.end.normal = normal;\n    \n    if (ron > 0.0)\n    {\n        // Outside\n        result.start.dist = BIG;\n        result.end.dist = -BIG;\n        \n        if (abs(rdn) > EPSILON)\n        {\n            float d = -ron / rdn;\n            \n            if (d > 0.0)\n            {\n                result.start.dist = d;\n                result.end.dist = BIG;\n            }\n            else\n            {\n                result.start.dist = -BIG;\n                result.end.dist = d;\n            }\n        }\n    }\n    else\n    {\n        // Inside\n        result.start.dist = -BIG;\n        result.end.dist = BIG;\n        \n        if (abs(rdn) > EPSILON)\n        {\n            float d = -ron / rdn;\n            \n            if (d > 0.0)\n            {\n                result.start.dist = -BIG;\n                result.end.dist = d;\n            }\n            else\n            {\n                result.start.dist = d;\n                result.end.dist = BIG;\n            }\n        }\n    }\n    return result;\n}\n\nfloat inverseSquare(vec3 p)\n{\n    return 1.0 / dot(p, p);\n}\n\nfloat inverseSquareAntiderivative(Ray_t ray, float t)\n{\n    vec3 o = ray.o;\n    vec3 d = ray.d;\n    \n    // Shoutout to Wolfram Alpha\n    float a = t * dot(d, d) + dot(d, o);\n    float b1 = d.x * d.x * dot(o.yz, o.yz);\n    float b2 = 2.0 * d.x * o.x * dot(o.yz, d.yz);\n    float b3 = o.x * o.x * dot(d.yz, d.yz);\n    float b4 = (o.y * d.z - d.y * o.z) * (o.y * d.z - d.y * o.z);\n    float b = sqrt(b1 - b2 + b3 + b4);\n    return atan(a / b) / b;\n}\n\nfloat inverseSquareIntegral(Ray_t ray, float start, float end)\n{\n    return inverseSquareAntiderivative(ray, end) - inverseSquareAntiderivative(ray, start);\n}\n\nvec3 getLight(vec3 pos)\n{\n    vec3 color = vec3(inverseSquare(pos) * OMNI_LIGHT * 2.0);\n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n        color += Light[i].c * inverseSquare(pos) * insideCone(Light[i].d, Light[i].a, pos);\n    }\n    return color;\n}\n\nvec3 renderVolumetric(Ray_t ray, float maxDist)\n{\n    vec3 color = vec3(inverseSquareIntegral(ray, 0.0, maxDist) * OMNI_LIGHT);\n    \n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n        Range r = cone(Light[i].d, Light[i].a, ray);\n        r.end = min(r.end, maxDist);\n        \n        if (r.end > r.start)\n        {\n            float boost = mix(1.0, 18.0, insideCone(Light[i].d, Light[i].a, ray.o));\n            \n            color += inverseSquareIntegral(ray, r.start, r.end) * Light[i].c * boost;\n        }\n    }\n    \n    return color;\n}\n\nvec3 floorTexture(vec3 pos)\n{\n    pos.z += pos.x * 0.25;\n    return fract(pos.x * 0.1) > fract(pos.z * 0.1) ? vec3(1.0) : vec3(0.7);\n}\n\nfloat floorGloss(vec3 pos)\n{\n    pos.x += pos.z * 2.0;\n    return texture(iChannel1, pos.xz * 0.2).x * 0.5 + 0.75;\n}\n\nvec3 renderScene(Ray_t ray)\n{\n    Result r = plane(vec3(0.0, -18.0, 0.0), vec3(0.0, 1.0, 0.0), ray);\n    \n    if (r.start.dist > 0.0 && r.start.dist < r.end.dist)\n    {\n        vec3 pos = ray.o + ray.d * r.start.dist;\n        \n        Ray_t reflectedRay;\n        reflectedRay.o = pos;\n        reflectedRay.d = ray.d * vec3(1, -1, 1);\n        \n        vec3 volumetric = renderVolumetric(ray, r.start.dist);\n        vec3 reflectedVolumetric = renderVolumetric(reflectedRay, BIG);\n        \n        vec3 color = -normalize(pos).y * getLight(pos) * 30.0 * floorTexture(pos);\n        float gloss = floorGloss(pos);\n        \n        return volumetric + mix(color, reflectedVolumetric, FLOOR_REFLECTION * gloss);\n    }\n    else\n    {\n    \treturn renderVolumetric(ray, BIG);\n    }\n}\n\nvec3 toneMap(vec3 color)\n{\n    return 1.0 - exp(-color * EXPOSURE);\n}\n\nvoid setUpLights()\n{\n    mat4 m = rotateX(TAU * iTime * 0.05) * rotateY(TAU * iTime * 0.09);\n    \n    Light[0].d = normalize(m * vec4(1, 1, 1, 0)).xyz;\n    Light[1].d = normalize(m * m * vec4(1, 1, -1, 0)).xyz;\n    Light[2].d = normalize(m * vec4(1, -1, 1, 0)).xyz;\n    Light[3].d = normalize(m * m * vec4(1, -1, -1, 0)).xyz;\n    Light[4].d = normalize(m * vec4(0, INV_THETA, THETA, 0)).xyz;\n    Light[5].d = normalize(m * m * vec4(0, INV_THETA, -THETA, 0)).xyz;\n    Light[6].d = normalize(m * vec4(INV_THETA, THETA, 0, 0)).xyz;\n    Light[7].d = normalize(m * m * vec4(INV_THETA, -THETA, 0, 0)).xyz;\n    Light[8].d = normalize(m * vec4(THETA, 0, INV_THETA, 0)).xyz;\n    Light[9].d = normalize(m * m * vec4(-THETA, 0, INV_THETA, 0)).xyz;\n    \n    Light[0].c = normalize(vec3(1, 1, 1) * 0.5 + 0.7);\n    Light[1].c = normalize(vec3(1, 1, -1) * 0.5 + 1.0);\n    //Light[2].c = normalize(vec3(1, -1, 1) * 0.5 + 3.0);\n    Light[3].c = normalize(vec3(1, -1, -1) * 0.5 + 3.0);\n    Light[4].c = normalize(vec3(0, INV_THETA, THETA) * 0.5 + 1.0);\n    //Light[5].c = normalize(vec3(0, INV_THETA, THETA) * 0.7 + 0.8);\n    Light[6].c = normalize(vec3(INV_THETA, THETA, 0) * 0.5 + 0.7);\n    //Light[7].c = normalize(vec3(2.0, 1, 0.5) * 0.5 + 0.5);\n    Light[8].c = normalize(vec3(0.3, 0.9, 0.9) * 0.5 + 0.3 );\n    /*Light[9].c = normalize(vec3(-THETA, 0, INV_THETA) * 0.5 + 1.0);*/\n    \n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n       Light[i].a = texture(iChannel0, vec2(float(i) * 0.18, 0.0)).x * 0.3 + 0.05;\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\n\n\t//mouse rotation\n\tfloat a1=.5+iMouse.x/iResolution.x*2.;\n\tfloat a2=.8+iMouse.y/iResolution.y*2.;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(1.,.5,0.5);\n\tfrom+=vec3(time*2.,time,-2.);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n    v=v*0.003;\n    \n    InitScene (fragCoord);\n    \n    Material[4].k_d = v;\n    \n     \n\t//////////////////////////////////////////////////////////////////////\n\tsetUpLights();\n    \n    \n   \n\t//////////////////////////////////////////////////////////////////////\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // Position the camera.\n    vec3 cam_pos = vec3( 7.5*sin(0.25*iTime), 2.0+sin(0.25*iTime),7.5*cos(0.25*iTime)) ;\n    vec3 cam_lookat = vec3( 0.25, 1.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay,Ray;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\tRay.o = vec3(sin(iTime * 0.5) * 5.0, -12.5 + sin(iTime * 0.6) * 2.5, -25.0);\n   \tRay.d = normalize(vec4((fragCoord.xy - iResolution.xy * 0.5) / iResolution.y, 0.7, 0.0)).xyz;\n\t\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ ) \n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\t\t \n        I_result += compounded_k_rg * I_local;\n\t\t\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\tvec3 color = renderScene(Ray);\n    color = toneMap(color);\n\n\tfragColor = vec4(color, 1.0);\n    fragColor += vec4( I_result, 1.0 );\n}\n", "image_inputs": [{"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtfSRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtfSW8", "name": "Donuts can be beautiful too", "author": "104", "description": "How can we make a donut look nice?", "tags": ["2d", "donut"], "likes": 4, "viewed": 117, "date": "1563461276", "time_retrieved": "2024-06-20T19:41:23.434911", "image_code": "const float innerh = .17;\nconst float PI = 3.14159;\n\nvec3 dtoa(vec3  d, float amount){\n    vec3 a = clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\n    return a;\n}\nmat2 rot2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\nfloat nsin(float x) { return sin(x)*.5+.5;}\n\nvoid mainImage( out vec4 O, in vec2 P)\n{\n    float t = iTime + 100.;\n    vec2 R = iResolution.xy;\n    P -= R*.5;// center at origin\n    vec2 uv = P / R.y;// aspect correct uv\n    \n    float ang = atan(uv.x, uv.y);\n    // find a base height around the circle\n    float h = 0.;\n    float f = 1.;\n    for (float i = 0.; i < 5.; ++ i) {\n        h += nsin((ang+f)*i + t*f*.1);\n        f *= -1.37;\n    }\n    h = h*h;\n    \n    // find ind height for 3 separate components\n    vec3 h3 = h + .4*sin(t*vec3(1.,1.44,1.77) + ang*4.);\n    vec3 d3 = length(uv) - innerh - h3*.02; // distance\n    d3 = max(d3, -(length(uv) - innerh - h3 * .011));// donut\n    d3 = min(d3, length(uv) - h3*0.01); // center\n\n    vec2 shuv = uv+.06;\n    vec3 dsh = length(shuv) - innerh - h3*.02; // distance\n    dsh = max(dsh, -(length(shuv) - innerh - h3 * .011));// donut\n    dsh = min(dsh, length(shuv) - h3*0.01); // center\n    vec3 ash = dtoa(dsh, 30.)*.2;\n\n    O = vec4(1);\n    O *= 1.-min(ash.r, min(ash.g, ash.b));\n    vec3 a3 = dtoa(d3, 30.);\n    a3.rg *= rot2D(iTime*.4);\n    a3 = clamp(a3,0.,1.);\n    O.rgb = mix(O.rgb, a3, a3);\n    O.rgb = mix(vec3(O.r+O.g+O.b)/3.,O.rgb,.5);\n    vec2 N = P/R;\n    O = pow(O, vec4(4.));\n    O *= 1.-dot(N,N);\n    O += (fract(sin(dot(R+t,N))*1e5)-.5)*.05;\n    O.a = 1.;\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtfSW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtfSWn", "name": "Scatterform1B - Scroll", "author": "audiopixel", "description": "Having fun with cell morphing technique ", "tags": ["3d", "raymarching", "distancefield"], "likes": 7, "viewed": 427, "date": "1562534590", "time_retrieved": "2024-06-20T19:41:23.440893", "image_code": "// Created by Hepp Maccoy 2019, hepp@audiopixel.com\n// Built with Haxademic+Scatterform, github.com/cacheflowe/haxademic\n// Distance functions by Inigo Quilez, iquilezles.org\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PI = 3.14159265358979323846;\nfloat d1;\nfloat t1;\n\nfloat soc(vec3 p) {\n    vec3 n = normalize(sign(p+1e6));\n    return min(min(dot(p.xy, n.xy), dot(p.yz, n.yz)), dot(p.xz, n.xz));\n}\n\nfloat sinc(float x, float k) {\n    float a = PI * (float(k)*x-1.0);\n    return sin(a)/a;\n}\n\nmat2 r2d(float a) {\n    float sa=sin(a);\n    float ca=cos(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nvec2 mo(inout vec2 p, vec2 d) {\n    vec2 q = p;\n    q.x = abs(q.x) - d.x;\n    q.y = abs(q.y) - d.y;\n    if (q.y > q.x) q = q.yx;\n    return q;\n}\n\nvec2 amod(vec2 p, float m) {\n    float a=mod(atan(p.x,p.y), m)-m*.5;\n    return vec2(cos(a), sin(a))*length(p);\n}\n\nfloat map(vec3 p) {\n    float d = 1.0;\n    float a = abs(p.y);\n    p.yz *= r2d(sign(a) * 1.22);\n    p.xz = mo(p.xz, vec2((-d1 * 35.8) - 1., (d1 * 65.8) - 1.));\n    p.zx = mo(p.xz, vec2((d1 * 2.) - 4., 0.0282));\n    p.xz = amod(p.xz, (PI * 1.0) / 2.0);\n    p.xz = max(abs(p.xz) - 2.2569, -1.29);\n    p.x = mod(p.x, 1.2198)-(1.2198 *.5);\n    p.y = mod(p.y + -t1 * 1.2, 6.752) - 5.;\n    d = min(d, soc(max(abs(p) - 0.172, 0.0096)));\n    return (length(p * 0.0) - 0.0) * 1.0 - (d * -1.0);\n}\n\nvec3 calcNormal(in vec3 p, in int type, in float m1, in float m2, in float m3) {\n    vec2 e = vec2(m2, m3) * m1;\n    return normalize( e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx) );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    t1 = iTime + 4.;\n    d1 = sin(t1 * .013);\n    vec2 st = (fragCoord.xy / iResolution.xy) * 2.05 - 1.;\n    st.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(st, 6.7287);\n    vec3 rd = normalize(vec3(st + vec2(0.), -0.8572));\n    vec3 mp;\n    mp = ro;\n    float md;\n    for(int i=0; i<36; i++) {\n        md = map(mp);\n        mp += (rd * .6 + (-d1 * .1)) * md;\n    }\n    float b = length(ro - mp);\n    float dA = 0.4799 - (b * 0.02) * 0.5232;\n    float dB = 0.479 - (b * 0.03) * 0.523;\n    dA = sinc(dA, 1.0);\n    dB = sinc(dB, 1.0);\n    vec3 p = ro + rd * (mp);\n    vec3 lt = vec3(0.0, 0.0, 0.0);\n    vec3 l;\n    vec3 nm = calcNormal(p, 0, 4.5201, 1.0, -1.0);\n    if (md < 0.015) {\n        float dif = clamp(dot(nm, normalize(lt - p)), 0., 1.);\n        dif *= 5.0 / dot(lt - p, lt - p);\n        l = vec3(pow(dif, 0.1854));\n    }\n    vec3 lt2 = vec3(0.0, 0.0, 13.0);\n    vec3 nm2 = calcNormal(p, 0, 2.8964, -1.0, -1.339);\n    float dif2 = clamp(dot(nm2, normalize(lt2 - p)), 0., 1.);\n    dif2 *= 4.0 / dot(lt2 - p, lt2 - p);\n    vec3 lb = vec3(pow(dif2, 0.4545));\n    float src1 = 1. * 0.0;\n    float src2 = nm.x;\n    float src3 = l.x;\n    float src4 = lb.x * 0.4;\n    vec3 c;\n    c = mix(vec3(0.0), vec3(0.6117647,0.019607844,0.8627451), src1) + mix(vec3(0.0), vec3(1.0,0.0,0.0), src2);\n    c = c + mix(vec3(0.0), vec3(0.31764707,0.5568628,1.0), src3);\n    c = c + mix(vec3(0.0), vec3(0.05490196,0.0,1.0), src4);\n    fragColor = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtfSWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtfSWr", "name": "MuliaJulia... Testing 123...", "author": "Chris_M_Thomasson", "description": "An example of molding an existing shape into a Mandelbrot-like shape. Apply a couple M-set iterations before we do anything...", "tags": ["fractal", "test", "math", "experiment", "tile", "hybrid", "limit"], "likes": 6, "viewed": 103, "date": "1562567920", "time_retrieved": "2024-06-20T19:41:24.816803", "image_code": "/*\nExploding Julia Hyperbolic Vector v:(0.0.0)\n\nby: Chris M. Thomasson\n___________________________________*/\n\n\n// The number of points in the spiral\n#define CT_N 16\n\n// Viewport Axes\nstruct ct_axes\n{\n    float xmin;\n    float xmax;\n    float ymin;\n    float ymax;\n};\n    \n    \nct_axes ct_axes_from_radius(\n    in vec3 vpcircle\n){\n    return ct_axes(\n        vpcircle.x - vpcircle.z,\n        vpcircle.x + vpcircle.z,\n        vpcircle.y - vpcircle.z,\n        vpcircle.y + vpcircle.z\n    );\n}\n\n\n// Simple 2d Plane\nstruct ct_plane2d\n{\n    ct_axes axes;\n    float xstep;\n    float ystep;\n};\n    \n    \nct_plane2d ct_plane2d_create(\n    in ct_axes axes\n){\n    float awidth = axes.xmax - axes.xmin;\n    float aheight = axes.ymax - axes.ymin;\n    \n    float daspect = abs(iResolution.y / iResolution.x);\n    float waspect = abs(aheight / awidth);\n    \n    if (daspect > waspect)\n    {\n        float excess = aheight * (daspect / waspect - 1.0);\n        axes.ymax += excess / 2.0;\n        axes.ymin -= excess / 2.0;\n    }\n    \n    else if (daspect < waspect)\n    {\n        float excess = awidth * (waspect / daspect - 1.0);\n        axes.xmax += excess / 2.0;\n        axes.xmin -= excess / 2.0;\n    }\n    \n    return ct_plane2d(\n        axes,\n        (axes.xmax - axes.xmin) / iResolution.x,\n        (axes.ymax - axes.ymin) / iResolution.y\n    );\n}\n\n\nvec2 ct_plane2d_project(\n\tin ct_plane2d self,\n    in vec2 z\n){\n\treturn vec2(\n        self.axes.xmin + z.x * self.xstep,\n        self.axes.ymin + z.y * self.ystep\n    );\n}\n\n\n// A vector field point\nstruct ct_vfpoint\n{\n    vec2 p;\n    float m;\n};\n\n\n// Our global per-pixel points\nct_vfpoint g_vfp[CT_N + 1];\n\n\n// Gain a normalized vector from p, \n// using a power of npow.\nvec2 ct_vfield_normal(\n    in vec2 p,\n    float npow\n){\n    float eps = 0.00001;\n    vec2 g = vec2(eps, eps);\n    \n    const int imax = CT_N + 1;\n    \n    for (int i = 0; i < imax; ++i)\n    {\n        vec2 dif = g_vfp[i].p - p;\n        float sum = dif[0] * dif[0] + dif[1] * dif[1];\n        float mass = pow(sum, npow);\n        if (mass == 0.0) mass = 0.00001;\n        \n      \tg[0] = g[0] + g_vfp[i].m * dif[0] / mass;\n      \tg[1] = g[1] + g_vfp[i].m * dif[1] / mass;\n    }\n    \n    return normalize(g);\n}\n\n\nfloat ct_normal_pi(\n    in vec2 z,\n    in float sa\n){\n    float a = atan(z[1], z[0]) + sa;\n    if (a < 0.0) a += 6.28318;\n    a /= 6.28318;\n    return a;\n}\n\n\nvec2 ct_cmul(in vec2 p0, in vec2 p1)\n{\n    return vec2(p0.x * p1.x - p0.y * p1.y, p0.x * p1.y + p0.y * p1.x);\n}\n\n\n// Vector Pixel Iteration\nvec4 ct_vpixel(\n    in vec2 z,\n    in vec2 c,\n    in int n,\n    in float npow\n){\n    float s = 1.0;\n \n    vec2 jc = vec2(-1.6 + abs(cos(iTime * .1)), 0.0);\n    vec3 xxxcolor = vec3(0, 0, 0);\n    \n    vec2 zcopy = z;\n    \n    z = ct_cmul(z, z) + zcopy;\n    z = ct_cmul(z, z) + zcopy;\n    \n    z = ct_cmul(z, z) + zcopy;\n\n    \n    // Augment z with some Mandelbrot iterations\n    for (int i = 0; i < 9; ++i)\n    {\n        z = ct_cmul(z, z);\n    \tz = z + jc;\n        \n        if (length(z) > 2.0)\n        {\n            xxxcolor += vec3(float(i) * .07, 0, 0);\n            //z = zcopy;\n            //break;\n            \n            float xmin = .14;\n            float xmax = .16;\n            float xdif = xmax - xmin;\n            \n            z = z * .01;\n        }\n        \n        else\n        {\t\n            xxxcolor += vec3(.01, .01, .01);\n        }\n    }\n\n    \n    vec2 vn = ct_vfield_normal(z, npow);\n    \n    float a = 0.0;\n\n    vec2 rc = vec2(\n        vn[0] * cos(a) - vn[1] * sin(a),\n        vn[0] * sin(a) + vn[1] * cos(a)\n    );\n    \n    float npi = ct_normal_pi(vn, a);\n    \n    float scale = float(CT_N);\n    \n    float color = mod(npi * scale, 1.0);\n    \n    if (color < abs(sin(iTime * .2)) * .05 + .95)\n    //if (color < 1.0)\n    {\n        color = 1.0 - color;\n    }\n    \n    else\n    {\n        color = 0.0;\n    }\n    \n    return vec4(\n        color + (abs(vn.x) * abs(sin(iTime)) * .2),\n        color + (abs(vn.y) * abs(cos(iTime)) * .1),\n        color + (abs(vn.x * vn.y) * .1),\n        1.0\n    );\n\n}\n\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n// High-Level Entry\nvec4 ct_main(\n    in ct_plane2d plane,\n    in vec2 c\n){\n    \n    const int n = CT_N;\n    float scale = 1.0;\n    \n    float my_time = 0.0;\n    \n    float r = 0.0;\n    \n    for (int x = 0; x < n; ++x)\n    {\n        int y = 0;\n        float xr = float(x) / float(n);\n        float angle = xr * 6.28 + abs(cos(my_time * .1)) * 1.0;\n        \n        g_vfp[x] = ct_vfpoint(\n            vec2(cos(angle) * r, sin(angle) * r), \n            -1.0\n        );\n    }\n    \n    if (iMouse.z > 0.0)\n    {\n        vec2 cmx = ct_plane2d_project(plane, vec2(iMouse));\n        vec2 cm = vec2(0.0, sin(iTime * 3.0) * .4);\n        g_vfp[n] = ct_vfpoint(\n            cm, \n            1.5\n        );\n    }\n    \n    \n    vec2 rc = rotate(c, iTime * .5);\n\n    \n    return ct_vpixel(rc, rc, 128, 2.0);\n}\n\n\n// Raw Entry.\nvoid mainImage(\n  \tout vec4 fragColor, \n\tin vec2 fragCoord\n){\n    vec3 vpcircle = vec3(\n        abs(cos(iTime * .5)) * 1., \n        abs(sin(iTime * .25)) * 1., \n        2.0 - abs(sin(iTime * .25)) * 1.5\n    );\n    \n    ct_plane2d plane = ct_plane2d_create(\n        ct_axes_from_radius(vpcircle)\n    );\n    \n    vec2 c = ct_plane2d_project(plane, fragCoord);\n    \n    // Exec...\n    vec4 color = ct_main(plane, c);\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtfSWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtfSWs", "name": "ByteWorkTest", "author": "gcj2450", "description": "just for test", "tags": ["functions", "learn"], "likes": 1, "viewed": 37, "date": "1564561134", "time_retrieved": "2024-06-20T19:41:24.925995", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 bl = step(vec2(0.2),uv);\n    vec2 tr=step(vec2(0.1),1.0-uv);\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\tcol*=bl.x*bl.y*tr.x*tr.y;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtfSWs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtfSzf", "name": "RayMarchingBand012:VoxelPerfect", "author": "Hirai_worthless", "description": "Voxel-Perfect Torus and\nNon-Voxel-Perfect Sphere.", "tags": ["raymarching", "voxel"], "likes": 2, "viewed": 166, "date": "1563719918", "time_retrieved": "2024-06-20T19:41:24.925995", "image_code": "float PI = 3.14159265;\nfloat map(vec3 p){\n    vec3 q = p;\n        vec2 t = vec2(1.25,0.25);\n    q.xz *= mat2(cos(-iTime),-sin(-iTime),sin(-iTime),cos(-iTime));\n\t p = floor(p * 10.0) / 10.0;\n    q = floor(q * 10.0) / 10.0;\n        p.xz *= mat2(cos((iTime - 1.0/2.0) * PI),-sin((iTime - 1.0/2.0) * PI)\n                 ,sin((iTime - 1.0/2.0) * PI),cos((iTime - 1.0/2.0) * PI));\n    vec2 r1 = vec2(length(p.xy) - t.x, p.z);\n    float torus = length(r1) - t.y;\n    return min(torus,length(q) - 0.75);\n\n}\n\nfloat trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    for(int i = 0; i < 96; ++i){\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float PI = 3.14159265;\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv,1.0));\n    \n    vec3 o = vec3(0,0,-2.0);\n    float t = trace(o,r);\n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    vec3 fc = vec3(fog);\n\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtfSzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtfSzj", "name": "Motion Blur Short Exemple", "author": "Klems", "description": "Simple motion blur exemple", "tags": ["motionblur"], "likes": 12, "viewed": 1041, "date": "1563475536", "time_retrieved": "2024-06-20T19:41:24.925995", "image_code": "#define PI 3.14159265359\n#define rot(a) mat2(cos(a + PI*0.5*vec4(0,1,3,0)))\n\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 scene(vec2 fragCoord, float time) {\n    vec2 uv = fragCoord - iResolution.xy*0.5;\n    uv /= iResolution.y;\n    uv *= 3.0;\n    uv *= rot(time*10.0 + (sin(time*2.0)*0.5+0.5)*10.0);\n    uv = abs(uv);\n    float sd = max(uv.x-0.5, uv.y-1.5);\n    return vec3(smoothstep(0.0, 0.04, sd));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 result = vec3(0);\n   \t\n    bool motionBlur = true; // change this\n    if ( motionBlur ) {\n        #define BLUR 30\n        for (int i = 0 ; i < BLUR ; i++) {\n            float rnd = hash13(vec3(fragCoord, iFrame*100+i));\n            float time = iTime + rnd / 60.0;\n            result += scene(fragCoord, time);\n        }\n        result /= float(BLUR);\n    } else {\n        result = scene(fragCoord, iTime);\n    }\n    \n    fragColor.rgb = pow(result, vec3(1.0/2.2));\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtfSzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtfSzS", "name": "A E S T H E T I C raymarcher", "author": "vlams1", "description": "A E S T H E T I C S\n\nMade this to use as a background with Wallpaper Engine.", "tags": ["raymarcher"], "likes": 0, "viewed": 119, "date": "1563285074", "time_retrieved": "2024-06-20T19:41:24.925995", "image_code": "#define IT 64\n#define SD .001\n#define MD 15.\n\nmat2 rotate(float a) {\n    float s = sin(radians(a));\n    float c = cos(radians(a));\n    return mat2(c,-s,s,c);\n}\n\nfloat dist(vec3 p) {\n    vec3 d = abs(p)-2.;\n    float b = length(max(d,0.)) + min(max(d.x,max(d.y,d.z)),0.)-.5;\n    float s = length(p-vec3(sin(iTime*0.5)*2.5,sin(iTime*0.3),cos(iTime)*0.125)) - 3.;\n    return max(b,-s);\n}\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n    vec3 p = ro;\n    float td;\n    for (int i=0; i < IT; i++) {\n        float d = dist(p);\n        td += d;\n        p += rd*d;\n        if (d < SD || td > MD) break;\n    }\n    return p;\n}\n\nvec3 normal(vec3 p) {\n    vec2 o = vec2(SD,0);\n    return normalize(vec3(\n    dist(p+o.xyy)-dist(p-o.xyy),\n    dist(p+o.yxy)-dist(p-o.yxy),\n    dist(p+o.yyx)-dist(p-o.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,3,-8);\n    vec3 rd = normalize(vec3(uv,.9));\n    rd.yz *= rotate(22.);\n    rd.xz *= rotate(iTime*-5.);\n    ro.xz *= rotate(iTime*-5.);\n    vec3 p = raymarch(ro,rd);\n    vec3 c = length(p) < 5. ? normal(p)*.5+.5 : rd*.4+.4;\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtfSzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtfXRj", "name": "Speedpaint_2019_07_18", "author": "Bers", "description": "Anime Speed Trails (30 min speed painting)", "tags": ["speedpaint"], "likes": 12, "viewed": 652, "date": "1563480150", "time_retrieved": "2024-06-20T19:41:25.342008", "image_code": "float hash( vec2 p ) {return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123);} //Pseudo-random\nfloat smoothNoise( in vec2 p) { //Bilinearly interpolated noise (4 samples)\n    vec2 i = floor( p ); vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    float a = hash( i + vec2(0.0,0.0) );\n\tfloat b = hash( i + vec2(1.0,0.0) );\n\tfloat c = hash( i + vec2(0.0,1.0) );\n\tfloat d = hash( i + vec2(1.0,1.0) );\n    return float(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y)/4.;\n}\n//Funciton to make the noise continuous while wrapping around angle \nfloat rotatedMirror(float t, float r){\n    //t : 0->1\n    t = fract(t+r);\n    return 2.*abs(t-0.5);\n}\n//Some continous radial perlin noise\nconst mat2 m2 = mat2(0.90,0.44,-0.44,0.90);\nfloat radialPerlinNoise(float t, float d){\n    const float BUMP_MAP_UV_SCALE = 44.2;\n    d = pow(d,0.01); //Impression of speed : stretch noise as the distance increases.\n    float dOffset = -floor(iTime*10.)*0.1; //Time drift (animation)\n    vec2 p = vec2(rotatedMirror(t,0.1),d+dOffset);\n    float f1 = smoothNoise(p*BUMP_MAP_UV_SCALE);\n    p = 2.1*vec2(rotatedMirror(t,0.4),d+dOffset);\n    float f2 = smoothNoise(p*BUMP_MAP_UV_SCALE);\n    p = 3.7*vec2(rotatedMirror(t,0.8),d+dOffset);\n    float f3 = smoothNoise(p*BUMP_MAP_UV_SCALE);\n    p = 5.8*vec2(rotatedMirror(t,0.0),d+dOffset);\n    float f4 = smoothNoise(p*BUMP_MAP_UV_SCALE);\n    return (f1+0.5*f2+0.25*f3+0.125*f4)*3.;\n}\n//Colorize function (transforms BW Intensity to color)\nvec3 colorize(float f){\n    f = clamp(f*.95,0.0,1.0);\n    vec3 c = mix(vec3(0,0,1.1), vec3(0,1,1), f); //Red-Yellow Gradient\n         c = mix(c, vec3(1,1,1), f*4.-3.0);      //While highlights\n    vec3 cAttenuated = mix(vec3(0), c, f+0.1);       //Intensity ramp\n    return cAttenuated;\n}\n/*vec3 colorize(float f){\n    f = clamp(f,0.0,1.0);\n    vec3 c = mix(vec3(1.1,0,0), vec3(1,1,0), f); //Red-Yellow Gradient\n         c = mix(c, vec3(1,1,1), f*10.-9.);      //While highlights\n    vec3 cAttenuated = mix(vec3(0), c, f);       //Intensity ramp\n    return cAttenuated;\n}*/\n//Main image.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = 2.2*(fragCoord-0.5*vec2(iResolution.xy))/iResolution.xx;\n    float d = dot(uv,uv); //Squared distance\n    float t = 0.5+atan(uv.y,uv.x)/6.28; //Normalized Angle\n    float v = radialPerlinNoise(t,d);\n    //Saturate and offset values\n    v = -2.5+v*4.5;\n    //Intersity ramp from center\n    v = mix(0.,v,.8*smoothstep(0.1,0.65,d));\n    //Colorize (palette remap )\n    fragColor.rgb = colorize(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtfXRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtfXRM", "name": "random- ejemplo-v1", "author": "jorge2017a1", "description": "random- ejemplo-v1", "tags": ["random"], "likes": 2, "viewed": 95, "date": "1562334410", "time_retrieved": "2024-06-20T19:41:25.792687", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n/*void main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n\n    // Scale the coordinate system to see\n    // some noise in action\n    vec2 pos = vec2(st*5.0);\n\n    // Use the noise function\n    float n = noise(pos);\n\n    gl_FragColor = vec4(vec3(n), 1.0);\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t\n    vec2 pos = vec2(uv*5.0+iTime/0.50);\n    \n    //pos.x = uv.x*5.0+iTime/0.50;\n    ///pos.y = uv.y+iTime/1.50;\n\n    // Use the noise function\n    float n = noise(pos);\n\n    //gl_FragColor = vec4(vec3(n), 1.0);\n    \n    \n    \n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    //fragColor = vec4(vec3(n)-col,1.0);\n    fragColor = vec4(vec3(n*col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtfXRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtfXRS", "name": "Flying the Twisted Forest", "author": "dr2", "description": "Drone flight through the twisted forest...", "tags": ["forest", "flight", "drone", "succulent"], "likes": 15, "viewed": 367, "date": "1563281152", "time_retrieved": "2024-06-20T19:41:25.814432", "image_code": "// \"Flying the Twisted Forest\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA    0  // optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 flMat;\nvec3 flPos, sunDir, qHit;\nvec2 gId, obOff, obRand, csProp;\nfloat dstFar, tCur, trSzFac, hgSize, treeHt;\nint idObj;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec3 TrackPos (float t)\n{\n  return vec3 (8. * cos (0.1 * t) + 0.1 * t, 0., t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (-0.1 * 8. * sin (0.1 * t) + 0.1, 0., 1.);\n}\n\nvec3 TrackAcc (float t)\n{\n  return vec3 (-0.1 * 0.01 * 8. * cos (0.1 * t), 0., 0);\n}\n\nfloat ObjCDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r, y;\n  dMin = dstFar;\n  if (trSzFac > 0.) {\n    dMin /= trSzFac;\n    p.xz -= HexToPix (gId * hgSize) + obOff;\n    p /= trSzFac;\n    q = p;\n    q.y -= treeHt;\n    y = 0.5 * (1. + q.y / treeHt);\n    r = 0.35 * (1. - 0.5 * obRand.y) * (1. - 0.9 * y * y);\n    r *= 1. + 0.1 * sin (24. * (1. + obRand.y) * pi * y);\n    r += 0.2 * (1. - smoothstep (0., 0.1, y));\n    q.xz += Rot2D (vec2 (0.2 + 0.2 * obRand.x, 0.),\n       12. * pi * sign (obRand.x - 0.5) * (0.3 + 0.7 * obRand.y) * y + pi * obRand.x);\n    q.x += 0.5 * (0.4 + 0.6 * obRand.y) * y;\n    q.xz = abs (q.xz) - 0.3 * r;\n    d = PrCylDf (q.xzy, r, treeHt);\n    DMINQ (1);\n    q = p;\n    q.y -= 0.05;\n    q.xz += Rot2D (vec2 (0.2 + 0.2 * obRand.x, 0.), pi * obRand.x);\n    q.xz = abs (q.xz) - 0.3 * r - 0.4;\n    d = max (PrSphDf (q, 0.12), - q.y);\n    DMINQ (2);\n    dMin *= 0.6 * trSzFac;\n  }\n  return dMin;\n}\n\nfloat PathDst (vec2 p)\n{\n  float s;\n  s = abs (p.x - TrackPos (p.y).x) - 1.8;\n  return s * step (0., s) * step (0.5, Fbm2 (0.5 * p));\n}\n\nvoid SetObjConf ()\n{\n  float h;\n  obRand = Hashv2v2 (73.3 * gId + 77.);\n  h = PathDst (HexToPix (gId * hgSize));\n  if (h == 0. || obRand.x + obRand.y < 0.6) trSzFac = 0.;\n  else {\n    trSzFac = hgSize * 0.5 * sqrt3 * (0.6 + 0.4 * smoothstep (0., 1., h)) *\n       (0.75 - 0.25 * clamp (3. * (obRand.x - 0.5), -1., 1.));\n    obOff = hgSize * max (0., 0.4 * sqrt3 - trSzFac) * obRand.x *\n       sin (2. * pi * obRand.y + vec2 (0.5 * pi, 0.));\n  }\n}\n\nfloat ObjCRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-99.);\n  dHit = 0.;\n  for (int j = 0; j < 220; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetObjConf ();\n    }\n    d = ObjCDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar || p.y < 0. || p.y > 2. * treeHt) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjCNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (- ObjCDf (p + e.xxx), ObjCDf (p + e.xyy), ObjCDf (p + e.yxy), ObjCDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjCSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  gIdP = vec2 (-99.);\n  for (int j = 0; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetObjConf ();\n    }\n    h = ObjCDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.1, 0.3);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d;\n  const float flSzFac = 0.5;\n  dMin = dstFar;\n  dMin /= flSzFac;\n  qq = flMat * (p - flPos) / flSzFac;\n  qq.xz = vec2 (qq.x - qq.z, qq.z + qq.x) / sqrt (2.);\n  q = qq;\n  q.y -= 0.05;\n  d = PrRoundCylDf (q.xzy, 0.2, 0.03, 0.07);\n  DMIN (3);\n  q -= vec3 (-0.7, -0.05, 0.7);\n  d = PrRoundCylDf (q.xzy, 0.07, 0.04, 0.12);\n  DMIN (4);\n  q = qq;\n  q.xz = abs (q.xz) - 0.7;\n  d = min (PrCylAnDf (q.xzy, 0.5, 0.05, 0.05), PrCylDf (q.xzy, 0.1, 0.03));\n  DMIN (3);\n  q.xz = Rot2Cs (q.xz, csProp);\n  d = PrCylDf (q, 0.02, 0.415);\n  DMIN (6);\n  q = qq;\n  q.xz = abs (q.xz);\n  q -= vec3 (0.3, -0.07, 0.3);\n  d = PrRoundCylDf (q.xzy, 0.05, 0.03, 0.15);\n  DMIN (3);\n  q -= vec3 (-0.3, 0.13, -0.3);\n  q.xz = vec2 (q.x - q.z, q.z + q.x) / sqrt (2.);\n  d = min (PrRoundCylDf (q, 0.05, 0.02, 1.), PrRoundCylDf (q.zyx, 0.05, 0.02, 1.));\n  DMIN (3);\n  q = qq;\n  q.y -= -0.05;\n  d = PrSphDf (q, 0.17);\n  DMIN (5);\n  return flSzFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 30; j ++) {\n    p = ro + d * rd;\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.1, 0.3);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = 0.7 * mix (vec3 (0.4, 0.5, 0.7), vec3 (0.3, 0.45, 0.55),\n       smoothstep (-0.02, 0.01, rd.y));\n  } else if (rd.y > 0.) {\n    q = 0.005 * (ro.xz + tCur * vec2 (0.5, 2.) + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.1, 0.8, ff);\n    fd = smoothstep (0.1, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.8 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix (vec3 (0.8, 0.8, 0.75), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n       0.1 + 0.9 * f * fd);\n  } else {\n    col = vec3 (0.1, 0.2, 0.1);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, roo, vn;\n  vec2 vf;\n  float dstObj, dstObjC, dstObjM, dstGrnd, sh, f, a;\n  int idObjC;\n  bool isSky, isGrnd;\n  isSky = false;\n  isGrnd = false;\n  sh = 1.;\n  csProp = sin (3.3 * 2. * pi * tCur + vec2 (0.5 * pi, 0.));\n  dstObjC = ObjCRay (ro, rd);\n  idObjC = idObj;\n  roo = ro;\n  dstGrnd = dstFar;\n  dstObjM = ObjRay (ro, rd);\n  dstObj = min (dstObjM, dstObjC);\n  vf = vec2 (0.);\n  if (dstObj < dstFar) {\n    if (dstObjM < dstObjC) {\n      ro += dstObjM * rd;\n      vn = ObjNf (ro);\n      if (idObj == 3) col4 = vec4 (1., 0.9, 0.1, 0.5);\n      else if (idObj == 4) col4 = mix (vec4 (0.3, 0.3, 1., 0.2),\n         vec4 (1., 0., 0., 0.2), step (0., sin (10. * tCur)));\n      else if (idObj == 5) col4 = vec4 (0.1, 0.1, 0.1, 1.);\n      else if (idObj == 6) col4 = vec4 (1., 1., 0.5, 0.5);\n    } else {\n      ro += dstObjC * rd;\n      gId = PixToHex (ro.xz / hgSize);\n      vn = ObjCNf (ro);\n      a = atan (qHit.z, - qHit.x) / pi;\n      if (idObjC == 1) {\n        f = smoothstep (-0.9, -0.7, qHit.y / treeHt);\n        col4 = mix ((1. - 0.6 * obRand.x) * vec4 (0.6, 0.4, 0., 0.),\n           vec4 (0., 0.4 + 0.6 * obRand.y, 0.1, 0.05), f) *\n           (0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.05, mod (8. * a, 1.)));\n        vf = vec2 (16., (3. - 2.5 * f) * (1. - smoothstep (0.1, 0.3, dstObjC / dstFar)));\n      } else if (idObjC == 2) {\n        col4 = mix (vec4 (0.8, 0.1, 0., 0.3), vec4 (0.7, 0.7, 0., 0.3), step (0.6, obRand.y)) *\n           (0.5 + 0.5 * SmoothBump (0.1, 0.9, 0.05, mod (4. * a, 1.)));\n        vf = vec2 (32., 1.);\n      }\n    }\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    col4 = mix (vec4 (0.3, 0.1, 0., 0.), vec4 (0.05, 0.3, 0., 0.), Fbm2 (2. * ro.xz));\n    vn = vec3 (0., 1., 0.);\n    vf = vec2 (4., 12. * (1. - smoothstep (0.1, 0.3, dstGrnd / dstFar)));\n    isGrnd = true;\n  } else isSky = true;\n  if (! isSky) {\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    sh = min (ObjCSShadow (ro, sunDir), ObjSShadow (ro, sunDir));\n    col = col4.rgb * (0.2 + 0.1 * max (dot (vn, - sunDir), 0.) +\n       0.8 * sh * max (dot (vn, sunDir), 0.)) + col4.a * smoothstep (0.8, 1., sh) *\n       pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    col = mix (col, BgCol (roo, rd), smoothstep (0.8, 0.95, min (dstGrnd, dstObj) / dstFar));\n  } else col = BgCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid FlyerPM (float t)\n{\n  vec3 vd, cb, sb;\n  float flYaw, flRol;\n  flPos = TrackPos (t);\n  vd = TrackVel (t);\n  flYaw = -0.5 * pi - atan (vd.z, - vd.x);\n  flRol = 60. * TrackAcc (t).x;\n  cb = cos (vec3 (-0.1 * pi, flYaw, flRol));\n  sb = sin (vec3 (-0.1 * pi, flYaw, flRol));\n  flMat = mat3 (1., 0., 0., 0., cb.x, - sb.x, 0., sb.x, cb.x) *\n          mat3 (cb.z, - sb.z, 0., sb.z, cb.z, 0., 0., 0., 1.) *\n          mat3 (cb.y, 0., - sb.y, 0., 1., 0., sb.y , 0., cb.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, uvs, ori, ca, sa, mMid, ut, mSize;\n  float el, az, asp, winHt, vuId, zmFac, sr, spd, s;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uvs = uv;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  winHt = 0.85;\n  mSize = (1./5.) * vec2 (asp, 1.) * winHt;\n  mMid = vec2 (asp * (1. - mSize.y), - winHt + mSize.y);\n  ut = abs (uv - mMid) - mSize;\n  vuId = 0.;\n  if (max (ut.x, ut.y) < 0.) {\n    uv = (uv - mMid) / mSize.y;\n    vuId = 1.;\n  }\n  tCur = mod (tCur, 2400.) + 30. * floor (dateCur.w / 7200.);\n  hgSize = 1.;\n  treeHt = 10.;\n  spd = 5.;\n  ro = TrackPos (spd * tCur);\n  ro.y = 0.3 * treeHt;\n  vd = TrackVel (spd * tCur);\n  el = -0.05 * pi;\n  az = atan (vd.x, vd.z);\n  if (mPtr.z > 0.) {   \n    el += 0.4 * pi * mPtr.y;\n    az += 2.2 * pi * mPtr.x;\n  }\n  if (vuId == 1.) az += pi;\n  s = abs (az) > 0.5 * pi ? -1. : 1.;\n  FlyerPM (spd * tCur + 6. * s);\n  flPos.y = (0.25 + 0.1 * s * sin (0.1 * tCur)) * treeHt;\n  ori = vec2 (clamp (el, -0.5 * pi, 0.45 * pi), az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  dstFar = 100.;\n  sunDir = normalize (vec3 (0., 1., -0.7));\n  sunDir.xz = Rot2D (sunDir.xz, 0.3 * pi * sin (0.1 * tCur));\n  zmFac = 2.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  if (abs (uvs.y) < winHt) {\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = 0.; a < naa; a ++) {\n      rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n         sr * (0.667 * a + 0.5) * pi), zmFac));\n      col += (1. / naa) * ShowScene (ro, rd);\n    }\n  }\n  if (max (ut.x, ut.y) < 0. && min (abs (ut.x), abs (ut.y)) * canvas.y < 2.)\n     col = vec3 (0., 0., 0.4);\n  if (vuId == 0.) col *= 1. - smoothstep (0.99 * winHt, winHt, abs (uvs.y));\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtfXRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtfXW2", "name": "phi radial distribution", "author": "TekF", "description": "Golden-ratio polar-coordinate distribution of points gives really uniform coverage for any number of points. Created this to test if it would make a good sampling pattern.", "tags": ["2d", "voronoi", "distribution"], "likes": 27, "viewed": 806, "date": "1564311339", "time_retrieved": "2024-06-20T19:41:25.815430", "image_code": "const int n = 800;\nconst float rate = 7.;\nconst float lineThickness = 2.2;\nconst float colours = 0.05; // proportion of cells to colour in\nconst bool zoom = true;\n\nconst float phi = 1.6180339887498948;\nconst float tau = 6.2831853071795865;\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    float penOut = lineThickness/iResolution.y;\n    float penIn = (lineThickness-2.8)/iResolution.y;\n\n    float t = iTime*rate;\n    \n    fragColour = vec4(0,0,0,1);\n\n    float scale = sqrt(float(n));\n    if ( zoom ) scale = min( scale, pow((iTime+7.)*rate*.5,.6) ); // keep the edgemost points in shot as we zoom\n    \n    float closest = 1e38;\n    float closest2 = 1e38;\n    for ( int i=0; i < n; i++ )\n    {\n        float f = float(i);\n        f += fract(t);\n        float r = sqrt(f/128.);\n        r *= 13./scale;\n        float a = fract((f-t)*phi)*tau;\n        vec2 pos = r*vec2(sin(a),cos(a));\n        \n        vec3 col = sin(vec3(3,1,6)*(float(i)-floor(t)))*.5+.5;\n        if ( fract(col.y*64.) > colours ) col = vec3(1);\n\n        float l = length(pos-uv);\n\n        // add a ring to help me track size (so it doesn't look like we're zooming out)\n        //col *= smoothstep(penIn,penOut,abs(l/scale-.001)*scale);\n\t\t\n        if ( i == 0 ) l += smoothstep(1.,0.,fract(t))*1.2/scale; // grow the new point\n\t\tif ( l < closest )\n        {\n            if ( closest < closest2 ) closest2 = closest;\n            closest = l;\n\t\t\tfragColour.rgb = col; // *(1.-l*sqrt(float(n)));\n        }\n        else if ( l < closest2 )\n        {\n            closest2 = l;\n        }\n        fragColour.rgb = mix(fragColour.rgb,vec3(0),smoothstep(penOut,penIn,length(pos-uv)));\n    }\n    \n    // cell borders\n    fragColour.rgb *= smoothstep(penIn,penOut,(closest2-closest));//*scale);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtfXW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtfXWl", "name": "Voronoi Experiment 19", "author": "aiekick", "description": "Voronoi Experiment 19", "tags": ["voronoi", "experiment", "19"], "likes": 12, "viewed": 379, "date": "1564579161", "time_retrieved": "2024-06-20T19:41:26.077513", "image_code": "// Commutative smooth minimum function. Provided by Tomkh and \n// taken from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\nvoid mainImage( out vec4 c, vec2 g )\n{\n\tvec2 v = g / iResolution.y;\n    vec2 p = g /= iResolution.y / 3., kp = vec2(0), kid = vec2(0);;\n\t\n\tg += iTime * .25;\n\t\n    float d = 1e5, kd = d, ld = d;\n    \n    for(int x=-3;x<=3;x++)\n    for(int y=-3;y<=3;y++)\n    {\t\n        vec2 p = vec2(x,y);\n        vec2 id = fract(sin((floor(g)+p)*mat2(2,5,5,2)));\n        vec2 an = sin( iTime * 0.5 + 10. * id );\n\t\tp += .5 + .35 * an - fract(g);\n        p *= 10.;\n        \n\t\td = smin(d, dot(p,p), 100.);\n\t\tif (d < 10.)\n\t\t{\n\t\t\td = dot(p,p);\n\t\t\tfloat t = iTime * 5.*0.;\n\t\t\tkd = sin(ld * 0.5 - t) * ld;\n\t\t\tkid = id;\n        }\n\t\tld = d * 2.;\n    }\n\n\tc = kd * vec4(1, floor(kid + 1.5) * 0.05, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtfXWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtfXzf", "name": "Spaghetti Ink", "author": "Kali", "description": "Experimental raymarching of a fractal.", "tags": ["raymarching", "fractal", "experimental"], "likes": 48, "viewed": 873, "date": "1563692105", "time_retrieved": "2024-06-20T19:41:26.077513", "image_code": "#define mouse (iMouse.xy/iResolution.xy-.5)\nconst float det=.003;\nconst float maxdist=30.;\nfloat l=0.;\nmat2 rotm;\nvec3 basecol=vec3(.5,.5,1.);\n\nmat3 lookat(vec3 dir, vec3 up){\n    dir=normalize(dir);vec3 rt=normalize(cross(dir,normalize(up)));\n    return mat3(rt,cross(rt,dir),dir);\n}\n\nmat2 rot2D(float a) {\n    a=radians(a);\n\tfloat s=sin(a);\n    float c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n\nfloat de(vec3 p) {\n    p.xz*=rot2D(mouse.x*360.);\n    p=abs(5.-mod(p+5.,10.));\n    float md=100.;\n    float s=1.25;\n    float sc=1.;\n    vec3 pc;\n\tvec3 mp=vec3(100.);\n    float rot=sin(iTime*.1)*20.;\n    for (int i=0; i<8; i++) {\n        p.xy=abs(p.xy); \n        p=p*s-1./sc;\n        sc*=s;\n        p.xz*=rotm;\n        p.yz*=rot2D(30.+rot);\n        float d=length(p.xz+sin(p.y)*.5)-.2/sc;\n\t\tmp=min(mp,abs(p));\n        if (d<md) {\n        \tmd=d;\n\t\t\tpc=p;\n        }\n    }\n    l=mod(pc.y*.05-iTime*.1,.5)*2.;\n    return md/sc;\n}\n\nvec3 march(vec3 from, vec3 dir) {\n\tvec3 p, col=vec3(0.);\n    float totdist=0., d;\n    for (int i=0; i<100; i++) {\n    \tp=from+totdist*dir;\n        d=de(p);\n    \ttotdist+=max(det,d);\n        if (totdist>maxdist||length(col)>.3) break;\n        col+=max(0.,det-d)*l;\n    }\n\tcol=.96-col*2.5*vec3(3.,2.,1.);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy-.5;\n    uv.x*=iResolution.x/iResolution.y;\n    rotm=rot2D(-90.);\n    vec3 dir=normalize(vec3(uv,.7));\n    vec3 from=vec3(1.,2.,-5.);\n    from.xz*=rot2D(iTime*3.);\n    from.yz*=rot2D(iTime);\n    dir=lookat(-from,vec3(.5,1.,0.))*dir;\n\tvec3 col=march(from, dir);   \n\tcol=mix(vec3(1.),col,min(1.,iTime*.2));\n    col=min(col,1.-smoothstep(.85,1.,abs(1.-mod(uv.y*60.,2.)))*.4);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtfXzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtfXzj", "name": "M E N G E R S P O N G E", "author": "vlams1", "description": "I stole a distance function from fb39ca4, now it's my background.", "tags": ["raymarcher"], "likes": 3, "viewed": 500, "date": "1563481155", "time_retrieved": "2024-06-20T19:41:26.568434", "image_code": "//Rewritten as of 27-09-2019\n\n#define it 1024.\n#define pr .00001\n#define md 200.\n\nmat2 rotate(float a) {\n    float s = sin(radians(a));\n    float c = cos(radians(a));\n    return mat2(c,-s,s,c);\n}\n\n//Menger sponge SDF by fb39ca4\n//https://www.shadertoy.com/user/fb39ca4\n\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\nfloat sdScene(vec3 p) {\n    float s = 1.0;\n\tfloat d = 0.0;\n\tfor (int i = 0; i < 5; i++) {\n\t\td = max(d, -sdCrossRepScale(p, s));\n\t\ts *= 3.0;\n\t}\n\treturn d;\n}\n\nvec4 raymarch(vec3 ro, vec3 rd) {\n    vec3 p = ro;\n    float d;\n    float i;\n    for (i=0.; i < it; i++) {\n        d = sdScene(p);\n        p += rd*d;\n        if (d < pr) break;\n    }\n    return vec4(p,i);\n}\n\nvec3 normals(vec3 p) {\n    vec2 o = vec2(pr,0.0);\n    return normalize(vec3(\n        sdScene(p+o.xyy)-sdScene(p-o.xyy),\n        sdScene(p+o.yxy)-sdScene(p-o.yxy),\n        sdScene(p+o.yyx)-sdScene(p-o.yyx)));\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n, float s, float iterations, float intensity) {\n    float ao = 0.0;\n    for (float i = 1.0; i <= iterations; i++) {\n        float d = s * i;\n        ao += max((d - sdScene(p + n * d)) / d, 0.0);\n    }\n    return 1.0 - ao * intensity;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec4 mouse = vec4(iMouse.xy / iResolution.xy * 2.0 - 1.0,iMouse.zw); //Mouse input\n    \n    vec3 ro = vec3(0.0,0.0,mod(iTime,2.0));\n    vec3 rd = normalize(vec3(uv,0.6));\n    rd.xy *= rotate(iTime*15.);\n        \n    vec3 col = vec3(1.);\n    \n    vec4 rm = raymarch(ro,rd);\n    vec3 p = rm.xyz;\n    vec3 n = normals(p);\n    col = mix(vec3(ambientOcclusion(p, n, 0.4, 5.0, 0.2)), vec3(0.6,0.2,0.8), length(p-ro)/5.0) + rm.w / it;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtfXzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtfXzs", "name": "raytracing with rotate cam", "author": "suraimu752", "description": "raytracing by myself", "tags": ["raytrace"], "likes": 1, "viewed": 73, "date": "1563875672", "time_retrieved": "2024-06-20T19:41:26.574477", "image_code": "struct Sphere{\n    vec3 pos;\n    vec3 col;\n    float radius;\n};\n\nstruct Plane{\n    float height;\n    vec3 col;\n};\n\nstruct Ray{\n    vec3 col;\n    vec3 origin;\n    vec3 direction;\n    vec3 pos;\n};\n\nint nearestSphere(Sphere S, Plane P, Ray R){\n    if(distance(R.pos, S.pos) - S.radius < (R.pos.z < 90. ? abs(R.pos.y - P.height) : 1000.)){\n        return 0;\n    }\n    else{\n        return 1;\n    }\n}\n\nvec3 lightDirection = vec3(1., 1., -1.) * 250.;\n// vec3 lightDirection = vec3(1.) * 2.;\n\nvoid df(Sphere S, Plane P, inout Ray R){\n    float depth = 0.;\n    for(int i = 0; i < 200; i++){\n        R.pos = R.origin + R.direction * depth;\n\n        int index = nearestSphere(S, P, R);\n        // index = -1;\n        // then sphere < plane\n        if(index == 0){\n            float dist = distance(R.pos, S.pos) - S.radius;\n            depth += dist;\n            if(dist < 0.0001){\n                R.col = S.col * clamp(dot(R.pos - S.pos, normalize(lightDirection) * 1.5), .05, 1.);\n                break;\n            }\n        }   // then plane < sphere\n        else{\n            float dist = abs(R.pos.y - P.height);\n            depth += dist;\n            if(dist < 0.0001){\n                R.col = P.col;\n                R.col *= (1. - (mod(floor(R.pos.x * 6.) + floor(R.pos.z * 6.), 2.) * .2));\n                float a = pow(length(R.pos - lightDirection), 2.);\n                float b = 2. * dot(lightDirection - S.pos, R.pos - lightDirection);\n                float c = pow(length(lightDirection - S.pos), 2.) - pow(S.radius, 2.);\n                float d = pow(b, 2.) - 4. * a * c;\n                if(d >= 0.){\n                    // R.col *= .7;\n                    // R.col *= clamp(clamp(1. / (d * d * d), 0., 1.)\n                    //        * pow(distance(R.pos, S.pos), 2.), 0., 1.);\n                    R.col *= clamp(distance(R.pos, S.pos) * .7 - 1., 0.05, 1.);\n                }\n                R.col *= clamp(dot(lightDirection, vec3(0, 1, 0)), 0., 1.) * .9;\n                // if(R.pos.z > 3. && 3.1 > R.pos.z) R.col = vec3(1.);\n            }\n        }\n    }\n}\n\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nmat3 rotateY(float t){\n    return mat3(\n        cos(t), 0, sin(t),\n        0, 1, 0,\n        -sin(t), 0, cos(t)\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (fragCoord * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // float screenZ = sin(iTime) - 1.;\n    float screenZ = -1.;\n    Ray ray;\n    ray.origin = vec3(0, 0, screenZ);\n    ray.direction = normalize(vec3(p, 0) - ray.origin) * rotateY(sin(iTime * .3));\n    ray.pos = ray.origin;\n    ray.col = vec3(0, 0, .05);\n\n    Sphere sphere;\n    sphere.col = vec3(1.);\n    sphere.pos = vec3(1., 0, 2.);\n    sphere.radius = 1.;\n\n    Plane plane;\n    plane.height = -1.;\n    plane.col = vec3(1.);\n\n    // if((rand(p) + rand(p+vec2(1.)) + rand(p+vec2(2.))) * .333 > .95){\n    //     ray.col = vec3(1.);\n    // }\n\n    df(sphere, plane, ray);\n\n    fragColor = vec4(ray.col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtfXzs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtfXzX", "name": "Probability Map Rotated Rect", "author": "paniq", "description": "plotting the probability of point-intersecting an arbitrarily oriented rectangle", "tags": ["map", "square", "probability"], "likes": 1, "viewed": 402, "date": "1563661736", "time_retrieved": "2024-06-20T19:41:26.841178", "image_code": "vec2 rotate(vec2 v, float a) {\n    float s = sin(a); float c = cos(a);\n    return vec2(\n        c * v.x - s * v.y,\n        s * v.x + c * v.y\n\t\t);\n}\n\nfloat rect(vec2 p) {\n#if 1\n    p = abs(p) - vec2(0.7,mix(0.01,0.7,sin(iTime)*0.5+0.5));\n    return step(max(p.x,p.y), 0.0);\n#else\n    // shape that when rotated produces an approximate gaussian\n    // thanks to sean barrett for this\n    float d = length(p);\n    float width = exp(-d*d)*d*2.0;\n    return abs(p.y) < width/2.0 ? 1.0 : 0.0;    \n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv *= 2.0;\n    \n    const int N = 127;\n    float d = 0.0;\n    for (int i = 0; i < N; ++i) {\n        vec2 p = rotate(uv, radians(float(i)*360.0/float(N)));\n        d += rect(p);\n    }\n    d /= float(N);\n    // Output to screen\n    fragColor = vec4(mix(vec3(0.0,0.0,1.0),vec3(1.0,0.0,0.0),d),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtfXzX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wtj3DW", "name": "Beer Loading Bar", "author": "nr4", "description": "Funny Shader for Wednesday afternoon ;)", "tags": ["2d", "beer", "bar"], "likes": 11, "viewed": 209, "date": "1562160967", "time_retrieved": "2024-06-20T19:41:28.144443", "image_code": "/*\n * Beer Loading Bar\n * \n * Copyright (C) 2019  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// Global constants\nconst float pi = acos(-1.);\nconst vec3 c = vec3(1.0, 0.0, -1.0);\nfloat a = 1.0, ry = 1.0;\n\nfloat iProgress;\n\nvoid rand(in vec2 x, out float n)\n{\n    x += 400.;\n    n = fract(sin(dot(sign(x)*abs(x) ,vec2(12.9898,78.233)))*43758.5453);\n}\n\nvoid lfnoise(in vec2 t, out float n)\n{\n    vec2 i = floor(t);\n    t = fract(t);\n    t = smoothstep(c.yy, c.xx, t);\n    vec2 v1, v2;\n    rand(i, v1.x);\n    rand(i+c.xy, v1.y);\n    rand(i+c.yx, v2.x);\n    rand(i+c.xx, v2.y);\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    n = mix(v1.x, v1.y, t.x);\n}\n\nvoid mfnoise(in vec2 x, in float d, in float b, in float e, out float n)\n{\n    n = 0.;\n    float a = 1., nf = 0., buf;\n    for(float f = d; f<b; f *= 2.)\n    {\n        lfnoise(f*x, buf);\n        n += a*buf;\n        a *= e;\n        nf += 1.;\n    }\n    n *= (1.-e)/(1.-pow(e, nf));\n}\n\n//distance to spline with parameter t\nfloat dist2(vec2 p0,vec2 p1,vec2 p2,vec2 x,float t)\n{\n    t = clamp(t, 0., 1.);\n    return length(x-pow(1.-t,2.)*p0-2.*(1.-t)*t*p1-t*t*p2);\n}\n\n//minimum dist3ance to spline\nvoid dspline2(in vec2 x, in vec2 p0, in vec2 p1, in vec2 p2, out float ds)\n{\n    //coefficients for 0 = t^3 + a * t^2 + b * t + c\n    vec2 E = x-p0, F = p2-2.*p1+p0, G = p1-p0;\n    vec3 ai = vec3(3.*dot(G,F), 2.*dot(G,G)-dot(E,F), -dot(E,G))/dot(F,F);\n\n\t//discriminant and helpers\n    float tau = ai.x/3., p = ai.y-tau*ai.x, q = - tau*(tau*tau+p)+ai.z, dis = q*q/4.+p*p*p/27.;\n    \n    //triple real root\n    if(dis > 0.) \n    {\n        vec2 ki = -.5*q*c.xx+sqrt(dis)*c.xz, ui = sign(ki)*pow(abs(ki), c.xx/3.);\n        ds = dist2(p0,p1,p2,x,ui.x+ui.y-tau);\n        return;\n    }\n    \n    //three dist3inct real roots\n    float fac = sqrt(-4./3.*p), arg = acos(-.5*q*sqrt(-27./p/p/p))/3.;\n    vec3 t = c.zxz*fac*cos(arg*c.xxx+c*pi/3.)-tau;\n    ds = min(\n        dist2(p0,p1,p2,x, t.x),\n        min(\n            dist2(p0,p1,p2,x,t.y),\n            dist2(p0,p1,p2,x,t.z)\n        )\n    );\n}\n\nvoid dlinesegment2(in vec2 x, in vec2 p1, in vec2 p2, out float d)\n{\n    vec2 da = p2-p1;\n    d = length(x-mix(p1, p2, clamp(dot(x-p1, da)/dot(da,da),0.,1.)));\n}\n\nvoid dcircle(in vec2 x, in float R, out float d)\n{\n    d = length(x)-R;\n}\n\n// Stroke\nvoid stroke(in float d0, in float s, out float d)\n{\n    d = abs(d0)-s;\n}\n\nvoid smoothmin(in float a, in float b, in float k, out float dst)\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    dst = min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nvoid colorize(in vec2 x, inout vec3 col)\n{\n    vec2 dsx = vec2(x.x, x.y);\n    vec3 bcol = vec3(0.99,0.63,0.11),\n        gray = vec3(0.62,0.59,0.48),\n        lightgray = vec3(0.83,0.82,0.77),\n        beer = mix(vec3(0.99,0.80,0.00), vec3(0.97,0.65,0.09), (.5+.5*x.y)/.8),\n        lightbeer = mix(vec3(1.00,0.87,0.07), vec3(1.00,0.98,0.76), (.5+.5*x.y)/.8);\n    \n    // bubbles\n    float dc = 1.;\n    for(int i=0; i<200; ++i)\n    {\n        float index = float(i);\n        vec2 dx;\n        rand(index*c.xx, dx.x);\n        rand(index*c.xx-1338., dx.y);\n        float dd;\n        dcircle(mod(.5+x-vec2(.2,.5)*mix(-c.xx,c.xx,dx)-1.*iProgress*c.yx,1.)-.5, .03*dx.x, dd);\n        \n        smoothmin(dc, dd, .02, dc);\n    }\n    float ddc;\n    stroke(dc, .002, ddc);\n    beer = mix(beer, vec3(0.73,0.47,0.00), smoothstep(ry, -ry, ddc));\n    beer = mix(beer, vec3(0.98,0.78,0.07), smoothstep(ry, -ry, dc+.005));\n    \n    float d, da, db, dhandle, dbeer;\n    dlinesegment2(vec2(.5,1.)*x, .25*c.yz, .25*c.yx, d);\n    stroke(d, .1, d);\n    dspline2(x, vec2(.2,-.15), vec2(.35,-.1)+.1*c.yz, vec2(.35,.05), da);\n    dspline2(x, vec2(.35,.05), vec2(.35, .15), vec2(.2,.15), db);\n    da = min(da, db);\n    dhandle = da;\n    stroke(da, .04, da);\n  \tsmoothmin(d, da, .05, d);\n    col = mix(col, bcol, smoothstep(ry, -ry, d));\n    stroke(dhandle, .03, da);\n    col = mix(col, gray, smoothstep(ry, -ry, d+.01));\n    stroke(dhandle, .025, da);\n    col = mix(col, lightgray, smoothstep(ry, -ry, da));\n    stroke(dhandle, .005, da);\n    col = mix(col, c.xxx, smoothstep(ry, -ry, da));\n    \n    dspline2(x, vec2(-.15,-.27), vec2(0.,-.36), vec2(.15,-.27), da);\n    \n    dlinesegment2(vec2(.5,1.)*x, .25*c.yz, .25*c.yx, dbeer);\n    stroke(dbeer, .095, dbeer);\n    col = mix(col, beer, smoothstep(ry,-ry,dbeer));\n    \n    // stripes\n    dlinesegment2(vec2(.5,1.)*vec2(abs(x.x-.03)-.1,x.y)-.4*abs(x.x)*c.yx, -.3*c.yx, .25*c.yx, dbeer);\n    stroke(dbeer, .015, dbeer);\n    col = mix(col, lightbeer, smoothstep(ry,-ry,dbeer));\n    \n    stroke(da, .02, db);\n    col = mix(col, lightgray, smoothstep(ry, -ry, db));\n    \n    dlinesegment2(vec2(.5,1.)*x, .2*c.yx-.4*iProgress*c.yx, .25*c.yx, dbeer);\n    stroke(dbeer, .095, dbeer);\n    col = mix(col, vec3(0.78,0.44,0.05), smoothstep(ry,-ry,dbeer));\n    \n    dlinesegment2(vec2(.5,1.)*x, .2*c.yx-.4*iProgress*c.yx, .25*c.yx, dbeer);\n    stroke(dbeer, .092, dbeer);\n    col = mix(col, vec3(0.95,0.94,0.87), smoothstep(ry,-ry,dbeer));\n    \n    // stripes\n    dlinesegment2(vec2(.5,1.)*vec2(abs(x.x-.03)-.1,x.y)-.4*abs(x.x)*c.yx, .12*c.yx-.4*iProgress*c.yx, .25*c.yx, dbeer);\n    stroke(dbeer, .015, dbeer);\n    col = mix(col, vec3(1.00,1.00,1.00), smoothstep(ry,-ry,dbeer));\n    \n    // Foam\n    dlinesegment2(vec2(.5,1.)*x, .3*c.yx, .3*c.yx, dbeer);\n    dlinesegment2(x, vec2(-.2,.3), vec2(-.2,.1), da);\n    stroke(da, .06, da);\n    stroke(dbeer, .095, dbeer);\n    smoothmin(dbeer, da, .05, dbeer);\n    float n;\n    mfnoise(x-.1*iTime,8.,800.,.35,n);\n    dbeer += .03*mix(-1.,1.,n);\n    col = mix(col, vec3(0.78,0.76,0.69), smoothstep(ry,-ry,dbeer));\n    dbeer += .01*x.y;\n    col = mix(col, vec3(0.88,0.88,0.81), smoothstep(ry,-ry,dbeer));\n    dbeer += .05*x.y;\n    col = mix(col, vec3(0.95,0.95,0.89), smoothstep(ry,-ry,dbeer));\n    dbeer += .1*x.y;\n    col = mix(col, vec3(1.00,1.00,0.95), smoothstep(ry,-ry,dbeer));\n    \n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  \ta = iResolution.x/iResolution.y;\n  \try = 1.5/iResolution.y;\n  \tvec2 uv = fragCoord/iResolution.yy-0.5*vec2(a, 1.0);\n  \tvec3 col = c.yyy;\n  \n    iProgress = fract(iTime);\n    \n  \tcolorize(uv,col);\n  \n  \tfragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wtj3DW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtlSDB", "name": "chromatic aberration Practice", "author": "Hirai_worthless", "description": "fun", "tags": ["raymarching"], "likes": 11, "viewed": 220, "date": "1564135864", "time_retrieved": "2024-06-20T19:41:28.144443", "image_code": "vec2 path(float z){\n    float x = sin(z) + 2.0 * cos(z * 0.3) - 1.5 * sin(z * 0.12345);\n    float y = cos(z) + 1.5 * sin(z * 0.3) + 2.0 * cos(z * 0.12345);\n    return vec2(x,y);\n}\n\nfloat map(vec3 p){\n\t//p = fract(p/2.0) * 6.0 - 3.0;\n    vec2 o = path(p.z) / 4.0;\n\tfloat tBase = max(-length(p.xy - o) + 1.0 \n                      //* (1.0 + sin(p.z) * 0.5)\n                      ,length(p.xy - o) - 1.2 \n                      //* (1.0 + sin(p.z) * 0.5)\n                     );\n    float tdonut = max(-length(p.xy - o) + 0.5\n                      ,length(p.xy - o) - 0.6 \n                     );\n    tdonut = max(tdonut,abs(fract(p.z) - 0.5));\n    float tTube1 = length(p.xy - o + vec2(0.3,0.3)) - 0.025;\n    float tTube2 = length(p.xy - o + vec2(0.5,0.2)) - 0.025;\n    float tTube3 = length(p.xy - o + vec2(0.2,0.5)) - 0.025;    \n    float tTube4 = length(p.xy - o + vec2(-0.3,-0.3)) - 0.025;\n    float tTube5 = length(p.xy - o + vec2(-0.5,-0.2)) - 0.025;\n    float tTube6 = length(p.xy - o + vec2(-0.2,-0.5)) - 0.025;\n    float tTube = min(min(tTube1,tTube2),tTube3);\n    tTube = min(min(tTube,tTube4),min(tTube5,tTube6));\n\n    float bound = 2.0;\n    float tSplit = (fract(p.z)-0.5);\n    tSplit = min(tSplit, abs((p.x - o.x))-0.15);\n    tSplit = min(tSplit, abs((p.y - o.y))-0.15);\n\n    return min(min(max(tBase,-tSplit),tdonut),tTube);\n}\nfloat trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 32; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float PI = 3.14159265;\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r1 = normalize(vec3(uv,0.5));\n\tvec3 r2 = normalize(vec3(uv - vec2(0.05 * sin(iTime * 8.0),0.0),0.5));\n\tvec3 r3 = normalize(vec3(uv + vec2(0.05 * sin(iTime * 8.0),0.0),0.5));\n    float z = iTime * 4.0 ;\n    \n    r1.xy *= mat2( sin(iTime),cos(iTime),\n    \t\t\t\t-cos(iTime),sin(iTime));\n    r2.xy *= mat2( sin(iTime),cos(iTime),\n    \t\t\t\t-cos(iTime),sin(iTime));\n    r3.xy *= mat2( sin(iTime),cos(iTime),\n    \t\t\t\t-cos(iTime),sin(iTime));\n\tvec2 a = path(z);\n    vec3 o = vec3(a / 4.0,z);\n    float data1 = trace(o,r1);\n    float data2 = trace(o,r2);\n    float data3 = trace(o,r3);\n\n    float t1 = data1;\n    float t2 = data2;\n    float t3 = data3;\n    float fog1 = 1.0 / (1.0 + t1 * t1 * 0.3);\n    float fog2 = 1.0 / (1.0 + t2 * t2 * 0.3);\n    float fog3 = 1.0 / (1.0 + t3 * t3 * 0.3);\n    vec3 fc = vec3(fog1,fog2,fog3);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtlSDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtlSRj", "name": "RayMarchingBand006", "author": "Hirai_worthless", "description": "Yeah.", "tags": ["raymarching"], "likes": 2, "viewed": 238, "date": "1563547681", "time_retrieved": "2024-06-20T19:41:28.144443", "image_code": "vec2 path(float z){\n    float x = sin(z) + 2.0 * cos(z * 0.3) - 1.5 * sin(z * 0.12345);\n    float y = cos(z) + 1.5 * sin(z * 0.3) + 2.0 * cos(z * 0.12345);\n    return vec2(x,y);\n}\n\nfloat map(vec3 p){\n\tp = fract(p/2.0) * 6.0 - 3.0;\n    vec2 o = path(p.z) / 4.0;\n\tfloat tBase = max(-length(p.xy - o) + 1.0 \n                      //* (1.0 + sin(p.z) * 0.5)\n                      ,length(p.xy - o) - 1.2 \n                      //* (1.0 + sin(p.z) * 0.5)\n                     );\n    float tdonut = max(-length(p.xy - o) + 0.5\n                      ,length(p.xy - o) - 0.6 \n                     );\n    tdonut = max(tdonut,abs(fract(p.z) - 0.5));\n    float tTube1 = length(p.xy - o + vec2(0.3,0.3)) - 0.025;\n    float tTube2 = length(p.xy - o + vec2(0.5,0.2)) - 0.025;\n    float tTube3 = length(p.xy - o + vec2(0.2,0.5)) - 0.025;    \n    float tTube4 = length(p.xy - o + vec2(-0.3,-0.3)) - 0.025;\n    float tTube5 = length(p.xy - o + vec2(-0.5,-0.2)) - 0.025;\n    float tTube6 = length(p.xy - o + vec2(-0.2,-0.5)) - 0.025;\n    float tTube = min(min(tTube1,tTube2),tTube3);\n    tTube = min(min(tTube,tTube4),min(tTube5,tTube6));\n\n    float bound = 2.0;\n    float tSplit = (fract(p.z)-0.5);\n    tSplit = min(tSplit, abs((p.x - o.x))-0.15);\n    tSplit = min(tSplit, abs((p.y - o.y))-0.15);\n\n    return min(min(max(tBase,-tSplit),tdonut),tTube);\n}\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 32; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return vec4(getNormal(p),t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float PI = 3.14159265;\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv,0.5));\n\n    float z = iTime * 4.0 ;\n    \n    r.xy *= mat2( sin(iTime),cos(iTime),\n    \t\t\t\t-cos(iTime),sin(iTime));\n\tvec2 a = path(z);\n    vec3 o = vec3(a / 4.0,z);\n    vec4 data = trace(o,r);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    vec3 fc = mix(vec3(0.5 - data.x,0.5 -data.y,0.5-data.z),vec3(1),1.0 - fog);\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtlSRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtlSWn", "name": "Seascape Tropical", "author": "masterxilo", "description": "fork of https://www.shadertoy.com/view/Ms2SD1", "tags": ["procedural", "noise", "waves", "sea", "water", "subsurface"], "likes": 5, "viewed": 591, "date": "1562600808", "time_retrieved": "2024-06-20T19:41:29.089973", "image_code": "/*\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\nconst int NUM_STEPS = 8;\nconst float PI\t \t= 10.;\nconst float EPSILON\t= 1e-3;\n#define EPSILON_NRM (0.1 / iResolution.x)\n\n// sea\nconst int ITER_GEOMETRY = 5;\nconst int ITER_FRAGMENT = 10;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(.2,0.5,0.55);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4);\n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n        \n    vec3 reflected = getSkyColor(reflect(eye,n));    \n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    color += vec3(specular(n,l,eye,60.0));\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.3 + iMouse.x*0.01;\n        \n    // ray\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \n    vec3 ori = vec3(0.0,3.5,time*5.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.15;\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // color\n    vec3 color = mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n    \tpow(smoothstep(0.0,-0.05,dir.y),0.3));\n        \n    // post\n\tfragColor = vec4(pow(color,vec3(0.75)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtlSWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtlSzf", "name": "Mandelbrot_1", "author": "bosskwei", "description": "The Mandelbrot set is the set of complex numbers {\\displaystyle c} c for which the function {\\displaystyle f_{c}(z)=z^{2}+c} {\\displaystyle f_{c}(z)=z^{2}+c} does not diverge when iterated from {\\displaystyle z=0} z=0, i.e., for which the sequence {\\displ", "tags": ["2d"], "likes": 1, "viewed": 62, "date": "1563779026", "time_retrieved": "2024-06-20T19:41:29.089973", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float scale = 0.0;\n    vec2 width = vec2(4.0, 4.0);\n    if (iResolution.x < iResolution.y) {\n        scale = iResolution.y / iResolution.x;\n        width.y *= scale;\n    } else {\n        scale = iResolution.x / iResolution.y;\n        width.x *= scale;\n    }\n    \n    float x_coord = uv.x * width.x - width.x / 2.0;\n    float y_coord = uv.y * width.y - width.y / 2.0;\n    \n    float c = 0.0;\n    float zx = 0.0, zy = 0.0;\n    for (int i = 0; i < 50; i += 1) {\n        float t = zx * zx - zy * zy + x_coord;\n        zy = 2.0 * zx * zy + y_coord;\n        zx = t;\n        if (sqrt(zx * zx + zy * zy) > 2.0) {\n            break;\n        }\n        c += 0.05;\n    }\n    fragColor = vec4(c, 0.5 + 0.5 * sin(1.2 * iTime), 0.5 + 0.5 * cos(2.0 * iTime), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtlSzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtlSzN", "name": " GPU hacks #11 - DX11 Compute", "author": "PrzemyslawZaworski", "description": "Constant step raymarching and two functions to check whether input point is inside tetrahedron (second version is faster). Comment contains DirectX 11 framework for compute shaders - with working example, visually equivalent to visible shader.", "tags": ["tutorial", "tetrahedron", "science", "directx"], "likes": 6, "viewed": 647, "date": "1562319963", "time_retrieved": "2024-06-20T19:41:30.156577", "image_code": "/*\nCode tested with Windows 10 and RTX 2070.\nSave file as tetrahedron.c and compile with Visual Studio command line:\ncl.exe tetrahedron.c d3d11.lib dxguid.lib user32.lib kernel32.lib gdi32.lib d3dcompiler.lib\n*/\n\n/*\n#include <Windows.h>\n#include <d3d11.h>\n#include <d3dcompiler.h>\n\n#define WIDTH 1280 \n#define HEIGHT 720\n\nconst unsigned char ComputeShader[] =\n{\n\t\"RWTexture2D<float4> image : register (u0);\"\n\n\t\"cbuffer Constants : register(b0)\"\n\t\"{\"\n\t\t\"float iTime;\"\n\t\"};\"\n\n\t\"float3x3 rotationX(float x) \"\n\t\"{\"\n\t\t\"return float3x3(1.0,0.0,0.0,0.0,cos(x),sin(x),0.0,-sin(x),cos(x));\"\n\t\"}\"\n\n\t\"float3x3 rotationY(float y) \"\n\t\"{\"\n\t\t\"return float3x3(cos(y),0.0,-sin(y),0.0,1.0,0.0,sin(y),0.0,cos(y));\"\n\t\"}\"\n\n\t\"bool InsideTetrahedron(float3 a, float3 b, float3 c, float3 d, float3 p, out float3 color)\"\n\t\"{\"\n\t\t\"p=mul(rotationY(iTime),mul(rotationX(iTime),p));\"\n\t\t\"float3 vap = p - a;\"\n\t\t\"float3 vbp = p - b;\"\n\t\t\"float3 vab = b - a;\"\n\t\t\"float3 vac = c - a;\"\n\t\t\"float3 vad = d - a;\"\n\t\t\"float3 vbc = c - b;\"\n\t\t\"float3 vbd = d - b;\"\n\t\t\"float va6 = dot(vbp, cross(vbd, vbc));\"\n\t\t\"float vb6 = dot(vap, cross(vac, vad));\"\n\t\t\"float vc6 = dot(vap, cross(vad, vab));\"\n\t\t\"float vd6 = dot(vap, cross(vab, vac));\"\n\t\t\"float v6 = 1.0 / dot(vab, cross(vac, vad));\"\n\t\t\"float4 k =  float4(va6*v6, vb6*v6, vc6*v6, vd6*v6);\"\n\t\t\"if ((k.x >= 0.0) && (k.x <= 1.0) && (k.y >= 0.0) && (k.y <= 1.0) && (k.z >= 0.0) && (k.z <= 1.0) && (k.w >= 0.0) && (k.w <= 1.0))\"\n\t\t\"{\"\n\t\t\t\"color = k.rgb;\"\n\t\t\t\"return true;\"\n\t\t\"}\"\n\t\t\"else\"\n\t\t\"{\"\n\t\t\t\"color = float3(0.0,0.0,0.0);\"\n\t\t\t\"return false;\"\n\t\t\"}\"          \n\t\"}\"\n\n\t\"float4 raymarch (float3 ro, float3 rd)\"\n\t\"{\"\n\t\t\"float3 color = 0..xxx;\"\n\t\t\"for (int i = 0; i < 512; i++)\"\n\t\t\"{\"\n\t\t\t\"bool hit = InsideTetrahedron(float3(0.943, 0, -0.333 ),float3( -0.471, 0.816, -0.333), float3( -0.471, -0.816, -0.333), float3(0, 0, 1 ),ro,color);\"\n\t\t\t\"if (hit) return float4(color,1.0);\"\n\t\t\t\"ro += rd * 0.01;\"\n\t\t\"}\"\n\t\t\"return float4(0,0,0,1);\"\n\t\"}\"\n\n\t\"[numthreads(8, 8, 1)]\"\n\t\"void main (uint3 id : SV_DispatchThreadID)\"\n\t\"{\"\n\t\t\"float2 uv = (2.*id.xy - float2(1280, 720)) / 720.0;\"\n\t\t\"image[id.xy] = raymarch(float3(0,0.0,-2.5), normalize(float3(uv,2.)));\"\n\t\"}\"\n};\n\nstatic LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\n{\n\tif ((uMsg == WM_KEYUP && wParam == VK_ESCAPE) || uMsg==WM_CLOSE || uMsg==WM_DESTROY)\n\t{\n\t\tPostQuitMessage(0); return 0;\n\t}\n\telse\n\t{\n\t\treturn DefWindowProc(hWnd, uMsg, wParam, lParam);\n\t}\n}\n\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)\n{\n\tint exit = 0;\n\tMSG msg;\n\tWNDCLASS win = {CS_OWNDC|CS_HREDRAW|CS_VREDRAW, WindowProc, 0, 0, 0, 0, 0, (HBRUSH)(COLOR_WINDOW+1), 0, \"DirectX 11\"};\n\tRegisterClass(&win);\n\tHWND hwnd = CreateWindowEx(0, win.lpszClassName, \"DirectX 11\", WS_VISIBLE|WS_OVERLAPPEDWINDOW, 0, 0, WIDTH, HEIGHT, 0, 0, 0, 0);\t\n\tID3D11Device *device;\n\tIDXGISwapChain *surface;\n\tID3D11DeviceContext *context;\n\tID3D11Buffer *buffer;      \n\tID3D11UnorderedAccessView *uav; \n\tID3D11Texture2D *image;\t\n\tID3D11ComputeShader *shader;\n\tD3D11_MAPPED_SUBRESOURCE resource;\t\n\tDXGI_SWAP_CHAIN_DESC sd = {{WIDTH, HEIGHT, 0, 0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, 0 }, {1, 0}, (1L << (1 + 4)) | (1L << (6 + 4)) | (1L << (0 + 4)), 1, hwnd, 1, 1, 0};\n\tD3D11CreateDeviceAndSwapChain(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, 0, 0, D3D11_SDK_VERSION, &sd, &surface, &device, 0, &context);\n\tsurface->lpVtbl->GetDesc(surface, &sd); \t\n\tsurface->lpVtbl->GetBuffer(surface, 0, (REFIID) &IID_ID3D11Texture2D, ( LPVOID* )&image );\n\tD3D11_BUFFER_DESC desc = {16, D3D11_USAGE_DYNAMIC, D3D11_BIND_CONSTANT_BUFFER, D3D11_CPU_ACCESS_WRITE, 0, 0};\t\n\tdevice->lpVtbl->CreateBuffer(device, &desc, NULL, &buffer);\n\tdevice->lpVtbl->CreateUnorderedAccessView(device,(ID3D11Resource*)image, NULL, &uav );\t\n\tID3DBlob* blob;\n\tD3DCompile(&ComputeShader, sizeof ComputeShader, 0, 0, 0, \"main\", \"cs_5_0\", 1 << 15, 0, &blob, 0);\t\t\n\tdevice->lpVtbl->CreateComputeShader(device, blob->lpVtbl->GetBufferPointer(blob), blob->lpVtbl->GetBufferSize(blob), NULL, &shader);\n\twhile (!exit)\n\t{\n\t\twhile (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))\n\t\t{\n\t\t\tif (msg.message == WM_QUIT) exit = 1;\n\t\t\tTranslateMessage(&msg);\n\t\t\tDispatchMessage(&msg);\n\t\t}\t\t\n\t\tcontext->lpVtbl->Map(context,(ID3D11Resource*)buffer, 0, D3D11_MAP_WRITE_DISCARD, 0,  &resource);\n\t\tfloat time[] = {GetTickCount() * 0.001f};\n\t\tmemcpy(resource.pData, time, sizeof(float));\t\t\n\t\tcontext->lpVtbl->Unmap(context, (ID3D11Resource *)buffer, 0);\n\t\tcontext->lpVtbl->CSSetShader(context, shader, NULL, 0 );\n\t\tcontext->lpVtbl->CSSetUnorderedAccessViews(context, 0, 1, &uav, NULL );\n\t\tcontext->lpVtbl->CSSetConstantBuffers(context, 0, 1, &buffer );\t\t\t\n\t\tcontext->lpVtbl->Dispatch(context, WIDTH  / 8, HEIGHT  / 8, 1 );\n\t\tsurface->lpVtbl->Present( surface, 0, 0 );\n\t}\n\tcontext->lpVtbl->ClearState(context);\n\tdevice->lpVtbl->Release(device);\n\tsurface->lpVtbl->Release(surface);\t \n\timage->lpVtbl->Release(image);\t\n\tbuffer->lpVtbl->Release(buffer);\n\tuav->lpVtbl->Release(uav);\n\treturn 0; \n}\n*/\n\nmat3 rotationX( float x) \n{\n\treturn mat3(1.0,0.0,0.0,0.0,cos(x),sin(x),0.0,-sin(x),cos(x));\n}\n\nmat3 rotationY( float y) \n{\n\treturn mat3(cos(y),0.0,-sin(y),0.0,1.0,0.0,sin(y),0.0,cos(y));\n}\n\nbool InsideTetrahedronI(vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 p, out vec3 color)\n{\n    p=rotationY(iTime)*rotationX(iTime)*p;\n\tmat4 D0 = mat4(v1[0],v1[1],v1[2],1.0f,v2[0],v2[1],v2[2],1.0f,v3[0],v3[1],v3[2],1.0f,v4[0],v4[1],v4[2],1.0f);\n\tmat4 D1 = mat4(p[0],p[1],p[2],1.0f,v2[0],v2[1],v2[2],1.0f,v3[0],v3[1],v3[2],1.0f,v4[0],v4[1],v4[2],1.0f);\n\tmat4 D2 = mat4(v1[0],v1[1],v1[2],1.0f,p[0],p[1],p[2],1.0f,v3[0],v3[1],v3[2],1.0f,v4[0],v4[1],v4[2],1.0f);\n\tmat4 D3 = mat4(v1[0],v1[1],v1[2],1.0f,v2[0],v2[1],v2[2],1.0f,p[0],p[1],p[2],1.0f,v4[0],v4[1],v4[2],1.0f);\n\tmat4 D4 = mat4(v1[0],v1[1],v1[2],1.0f,v2[0],v2[1],v2[2],1.0f,v3[0],v3[1],v3[2],1.0f,p[0],p[1],p[2],1.0f);\n\tfloat a = determinant(D0);\n\tfloat b = determinant(D1);\n\tfloat c = determinant(D2);\n\tfloat d = determinant(D3);\n\tfloat e = determinant(D4);\n\tif ( (sign(a)==sign(b)) &&  (sign(a)==sign(c)) && (sign(a)==sign(d)) && (sign(a)==sign(e)) )\n    {\n        color = 0.33-p;\n        return true;\n    }  \n    else\n    {\n        color = vec3(0.0);\n        return false;\n    }    \n}\n\nbool InsideTetrahedronII(vec3 a, vec3 b, vec3 c, vec3 d, vec3 p, out vec3 color)\n{\n    p=rotationY(iTime)*rotationX(iTime)*p;\n    vec3 vap = p - a;\n    vec3 vbp = p - b;\n    vec3 vab = b - a;\n    vec3 vac = c - a;\n    vec3 vad = d - a;\n    vec3 vbc = c - b;\n    vec3 vbd = d - b;\n    float va6 = dot(vbp, cross(vbd, vbc));\n    float vb6 = dot(vap, cross(vac, vad));\n    float vc6 = dot(vap, cross(vad, vab));\n    float vd6 = dot(vap, cross(vab, vac));\n    float v6 = 1.0 / dot(vab, cross(vac, vad));\n    vec4 k =  vec4(va6*v6, vb6*v6, vc6*v6, vd6*v6);\n    if ((k.x >= 0.0) && (k.x <= 1.0) && (k.y >= 0.0) && (k.y <= 1.0) && (k.z >= 0.0) && (k.z <= 1.0) && (k.w >= 0.0) && (k.w <= 1.0))\n    {\n        color = k.rgb;\n        return true;\n    }\n    else\n    {\n        color = vec3(0.0);\n        return false;\n    }         \n}\n\nvec4 raymarch (vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(0.0);\n\tfor (int i = 0; i < 512; i++)\n\t{\n \t\tbool hit = InsideTetrahedronII(vec3(0.943, 0, -0.333 ),vec3( -0.471, 0.816, -0.333), vec3( -0.471, -0.816, -0.333), vec3(0, 0, 1 ),ro,color);\n \t\tif (hit) return vec4(color,1.0); \n    \tro += rd * 0.01;\n     }\n\treturn vec4(0,0,0,1);\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n\tvec2 uv = (2. * f.xy - iResolution.xy) / iResolution.y;\n\to = raymarch(vec3 (0,0.0,-3.),normalize(vec3(uv,2.)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtlSzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtlSzS", "name": "Color Pallet Gallery", "author": "ankd", "description": "fbm color pallets", "tags": ["2d", "fbm"], "likes": 5, "viewed": 244, "date": "1563429105", "time_retrieved": "2024-06-20T19:41:30.653561", "image_code": "/*\n\tColor Pallet Gallery\n\tauthor - ankd\n\tdate - 2019/07/18\n*/\n\n// params\n// MODE : 0,1,2\n#define MODE 1\n#define SLIDE_SPAN 8.0\n#define ITR 8\n#define SCALE 1.2\n#define COLOR_SMOOTH_MIN 0.1\n#define COLOR_SMOOTH_MAX 0.4\n\nconst float PI = acos(-1.);\n\nvec3 hsv(in float h, in float s, in float v) { return ((clamp(abs(fract(h+vec3(0., 2., 1.)/3.0)*6.-3.)-1., 0., 1.)-1.)*s+1.)*v; }\n\nfloat easeIn(in float t) { return pow(t, 8.); }\nfloat easeOut(in float t) { return 1.0-easeIn(1.0-t); }\nfloat easeInOut(in float t) { return t<0.5 ? 0.5*easeIn(t*2.0) : 0.5+0.5*easeOut(t*2.0-1.0); }\n\nmat2 rotate(in float r) { float c=cos(r), s=sin(r); return mat2(c, -s, s, c); }\nvec2 rotate(in vec2 p, in float r) { return rotate(r) * p; }\nvec3 rotate(in vec3 p, in vec3 r) {\n  vec3 q = p;\n  q.xy = rotate(q.xy, r.z);\n  q.yz = rotate(q.yz, r.x);\n  q.zx = rotate(q.zx, r.y);\n  return q;\n}\n\nfloat hash(in float x) { return fract(sin(x) * 43237.5324); }\nfloat hash(in vec2 x) { return fract(sin(dot(x, vec2(12.9898, 78.233)))*43237.5324); }\nvec3 hash3(in float x) { return vec3(hash(x), hash(x+100.), hash(10000.)); }\nfloat noise(in vec2 p) {\n  vec2 f = fract(p);\n  vec2 i = floor(p);\n  vec2 u = f*f*(3.-2.*f);\n  return mix(\n      mix(hash(i+vec2(0., 0.)), hash(i+vec2(1., 0.)), u.x),\n      mix(hash(i+vec2(0., 1.)), hash(i+vec2(1., 1.)), u.x),\n      u.y\n    );\n}\nfloat noise(in vec3 p) {\n  vec3 f = fract(p);\n  vec3 i = floor(p);\n  vec3 u = f*f*(3.-2.*f);\n  float n = i.x + i.y*53.0 + i.z*117.0;\n  return mix(\n      mix(mix(hash(n+0.), hash(n+1.), u.x), mix(hash(n+53.0), hash(n+54.0), u.x), u.y),\n      mix(mix(hash(n+117.), hash(n+118.), u.x), mix(hash(n+170.0), hash(n+171.0), u.x), u.y),\n      u.z\n    );\n}\nfloat fbm(in vec3 p) {\n  float res = 0.;\n  res += 0.5000*noise(p); p = rotate(p*2.02, vec3(PI*0.125));\n  res += 0.2500*noise(p); p = rotate(p*2.03, vec3(PI*0.125));\n  res += 0.1250*noise(p); p = rotate(p*2.01, vec3(PI*0.125));\n  res += 0.0625*noise(p);\n  return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (fragCoord.xy*2.0-iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float t = iTime*(1./SLIDE_SPAN);\n    uv.x += floor(t) + easeInOut(fract(t));\n    vec2 fuv = fract(uv)*2.0-1.0;\n    vec2 iuv = floor(uv);\n\n    // render\n    vec3 col = vec3(1.);\n    vec3 v = vec3(fuv + iuv, 0.);\n    for(int i=0;i<ITR;i++) {\n        float fi = float(i);\n        float f = fbm(v);\n        vec2 vxy = MODE==0 ? v.xy*SCALE : (MODE==1 ? v.xy*SCALE+f : v.xy*SCALE*f);\n    \tv = vec3(vxy, fi+f+iTime*0.1);\n        vec3 c = hsv(iuv.x*0.3+f+0.02*fi, 1.0-f*hash(iuv), 1.);\n        col = mix(c, col, smoothstep(COLOR_SMOOTH_MIN, COLOR_SMOOTH_MAX, f));\n    }\n\n    col = pow(col, vec3(0.4545));\n    \n    // frame\n    uv = abs(fuv*vec2(iResolution.x/iResolution.y, 1.));\n    float r=0.9, w=0.01;\n    vec3 frameCol = vec3(0.98);\n    col = mix(frameCol, col, smoothstep(r, r-w, length(uv)));\n    col = mix(frameCol, col, smoothstep(r, r-w, max(uv.x, uv.y)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtlSzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtlXD2", "name": "Raymarching+RimLight", "author": "Hirai_worthless", "description": "fun.", "tags": ["raymarching"], "likes": 3, "viewed": 140, "date": "1564412422", "time_retrieved": "2024-06-20T19:41:30.653561", "image_code": "float map(vec3 p){\n\n        p.xz *= mat2(cos(iTime),-sin(iTime)\n             ,sin(iTime),cos(iTime));\n    p.xy *= mat2(cos(0.3),-sin(0.3)\n             ,sin(0.3),cos(0.3));\n    p.yz *= mat2(cos(0.3),-sin(0.3)\n             ,sin(0.3),cos(0.3));\n            float edge = p.x;\n    float box1 = length(max(abs(p)-vec3(0.5,0.5,0.5),0.0))-0.1;\n            p.xz *= mat2(cos(iTime),-sin(iTime)\n             ,sin(iTime),cos(iTime));\n        float box2 = length(max(abs(p - vec3(0.5,0.5,0.5))-vec3(0.5,0.5,0.5),0.0))-0.1;\n            p.xz *= mat2(cos(-3.0 * iTime),-sin(-3.0 * iTime)\n             ,sin(-3.0 * iTime),cos(-3.0 * iTime));\n        float box3 = length(max(abs(p - vec3(-0.5,-0.5,-0.5))-vec3(0.5,0.5,0.5),0.0))-0.1;\n\treturn max(length(p) - 1.0,-min(min(box2,box3),length(p) - 0.5));\n}\n\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 96; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return vec4(getNormal(p),t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 R = iResolution,\n    r = normalize(vec3((2.*U - R.xy )/  R.y,1.2)),\n    o = vec3(0,0,-1.5);\n    vec4 data = trace(o,r);\n    vec3 n = vec3(data.xyz);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.2);\n    vec3 fc = t > 10000.0 ? vec3(0.8) : mix((vec3(data.x,data.y,data.z) + 1.0)/1.5\n                                            ,vec3(0.0), - pow(dot(n,r),1.0));\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtlXD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtlXD7", "name": "[twitch] Through the Bars", "author": "NuSan", "description": "Shader coded live on youtube:\nhttps://www.youtube.com/watch?v=zakmqumh8Rc\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/ThroughTheBars.glsl", "tags": ["raymarching", "shadow", "volumetriclighting"], "likes": 16, "viewed": 295, "date": "1563226182", "time_retrieved": "2024-06-20T19:41:31.768956", "image_code": "/*\nShader coded live on youtube:\nhttps://www.youtube.com/watch?v=zakmqumh8Rc\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/ThroughTheBars.glsl\n(yes I still put [twitch] as a generic tag for live streaming ...)\n*/\n\n#define time iTime\n#define rep(p,s) (fract(p/s-0.5)-0.5)*s\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\nfloat donut(vec3 p, float r1, float r2) {\n  \n  return length(vec2(length(p.xy)-r1,p.z))-r2;\n  //return max(abs(length(p.xy)-r1)-r2,abs(p.z)-r2*0.5);\n  \n}\n\nfloat grid(vec3 p) {\n  \n  \n  vec3 p2 = p;\n  p2.y = (fract(p.y)-0.5);\n  float d = box(p2, vec3(10.0,0.2,0.05));\n  \n  p.x = (fract(p.x)-0.5);\n  \n  d = min(d, box(p, vec3(0.2,5,0.05)));\n  \n  return d;\n}\n\nfloat chain(vec3 p) {\n  \n  vec3 p2 = p-vec3(0,1.5,0);\n  p.y = rep(p.y,0.6);\n  p2.y = rep(p2.y,0.6);\n  float d = donut(p, 0.2,0.05);\n  d = min(d, donut(p2.zyx, 0.2,0.05));\n  \n  return d;\n}\n\nfloat map(vec3 p) {\n  \n  float d = 10000.0;//length(p-vec3(0,-1.5,-1.5))-0.8;\n  \n  // floor\n  d = min(d, -box(p-vec3(0,-2.5,0), vec3(10,4,10)));\n  \n  d = min(d, grid(p));\n    \n  // kifs for chains\n  for(int i=0; i<4; ++i) {    \n    float t=0.7 + float(i)*13.742;\n    p.xy *= rot(t);    \n    p.yz *= rot(0.2);\n    p.xy=abs(p.xy);\n    p.x-=1.7;\n  }\n  p.x = rep(p.x, 1.4);\n  \n  //p.z -= 1;\n  \n  d = min(d, chain(p));\n  \n  p.z += 1.0;\n  \n  \n  return d;\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*754.655+uv.yx*942.742),vec2(3847.554)));\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*472.355)*655.644);\n}\n\nfloat curve(float t) {\n  return mix(rnd(floor(t)), rnd(floor(t)+1.0), smoothstep(0.0,1.0,fract(t)));  \n}\n\n// unused in the final shader\nvec3 volumetric(vec3 p) {\n  \n  vec2 uv = p.xz * 0.5;\n  \n  vec3 col = vec3(0);\n  vec2 grid = smoothstep(0.31,0.3,abs(fract(uv)-0.5));\n  vec2 cell = floor(uv);\n  col += min(grid.x, grid.y);\n  col *= vec3(rnd(cell),rnd(cell+72.23),rnd(cell+14.37));\n  \n  col *= curve(time*4.0 + rnd(cell)*98.62);\n  \n  col *= pow(clamp((p.y+1.0)*0.5,0.0,1.0),2.0);\n  \n  return col;\n}\n\nvoid cam(inout vec3 p) {\n  \n  p.yz *= rot(sin(time*0.4)*0.4+0.2);\n  p.xz *= rot(sin(time*0.13)*1.3);\n  \n}\n\nfloat shadow(vec3 p, vec3 l, float maxdist, int stepcount, float limit) {\n  float shad=1.0;\n  float dd=0.0;\n  for(int i=0; i<stepcount; ++i) {\n    float d=min(map(p), maxdist);\n    if(d<limit) {\n      shad=0.0;\n      break;\n    }\n    if(dd>=maxdist) {\n      break;\n    }\n    p += l*d;\n    dd+= d;\n  }\n  return shad;\n}\n\nfloat getao(vec3 p, vec3 n, float d) {\n  return clamp(map(p+n*d)/d,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  float rand=rnd(uv);\n\n  vec3 s=vec3(0,0,-5);\n  vec3 r=normalize(vec3(-uv, 1));\n  \n  cam(s);\n  cam(r);\n  \n  vec3 lightpos = vec3(2,-1.0,0);\n  float t1 = time + curve(time*0.2)*12.7;\n  lightpos.yz *= rot(sin(t1*0.7)*0.7);\n  lightpos.xz *= rot(sin(t1*1.3)*0.7-1.5);  \n  \n  // main raymarch  \n  vec3 p=s;\n  float dd=0.0;\n  const float maxdist = 100.0;\n  for(int i=0; i<100; ++i) {\n    float d=map(p);\n    if(d<0.001) break;\n    if(dd>maxdist) { dd=maxdist; break;}\n    p+=r*d;\n    dd+=d;\n  }\n  \n  // volumetric raymarching\n  const int volsteps=50;\n  float voldist = 15.0;\n  float stepsize = voldist/float(volsteps);\n  vec3 lr=r*stepsize;\n  vec3 lp=s + lr*rand;\n  float stepdist=rand*stepsize;\n  vec3 atcol=vec3(0);\n  for(int i=0; i<volsteps; ++i) {\n    if(stepdist>dd) {\n      break;\n    }\n    vec3 lv = lightpos-lp;\n    float ldistvol = length(lv);\n    lv = normalize(lv);\n    float shadvol = shadow(lp, lv, ldistvol, 20, 0.01);\n    atcol += 0.3/(0.05+(ldistvol*ldistvol)) * shadvol;\n    //atcol += volumetric(lp)*0.1;\n    lp+=lr;\n    stepdist+=stepsize;\n  }\n  \n  float fog = 1.0-clamp(dd/maxdist,0.0,1.0);\n  \n  vec2 off=vec2(0.01,0);\n  vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  \n  vec3 l=normalize(lightpos - p);\n  vec3 h=normalize(l-r);\n  float spec = max(dot(n,h),0.0);\n  float ldist = length(lightpos - p);\n  float fade = 1.0/(ldist*ldist);\n  \n  float shad = shadow(p + n * 0.2, l, ldist, 30, 0.01);\n  \n  vec3 col=vec3(0);\n  col += max(dot(n,l),0.0) * (1.7 + 5.0*pow(spec,5.0) + 10.0 * pow(spec,20.0)) * fog * fade * shad;\n  //col += pow(1-abs(dot(n,r)), 5) * fog * fade * shad;\n  \n  float ao = getao(p,n, 0.1) * getao(p,n, 0.4) * getao(p,n, 1.0) * (0.5 + 0.5 * getao(p,n, 2.0));\n  col += ao * 0.05;\n  \n  //col += volumetric(p);\n  \n  col += atcol;\n  //col += pow(at*0.12,4);\n  \n  //col *= 1.2-length(uv);\n  col = pow(col, vec3(0.4545));\n  col *= 1.2-length(uv);\n  \n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtlXD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtlXRf", "name": "The doppler effect!", "author": "toomuchvoltage", "description": "Hello! This is my first submission! :D\n\nLet me know what you think :)", "tags": ["waves", "circles", "sine", "cocentric"], "likes": 3, "viewed": 309, "date": "1563779698", "time_retrieved": "2024-06-20T19:41:31.774893", "image_code": "/******************************************************************************\nCopyright (c) 2019 TooMuchVoltage Software Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\nHit me up!\n\nTwitter: twitter.com/toomuchvoltage\nFacebook: fb.com/toomuchvoltage\nYouTube: youtube.com/toomuchvoltage\nMastodon: https://mastodon.gamedev.place/@toomuchvoltage\nWebsite: www.toomuchvoltage.com\n\n******************************************************************************/\n\nfloat dopplerEffect (in vec2 uv)\n{\n    float pendulumFactor = 8.0 * sin (iTime);\n    float fringeFactor = 0.5 * sin (iTime);\n    \n    float offset = 0.0;\n    for (int i = 0; i < 3; i++)\n    {\n        // % needs GLSL 3.0\n        float newOffset = fract (float(i)/2.0) == 0.0 ? sin(length(uv + offset * pendulumFactor) + iTime) : cos(length(uv + offset * fringeFactor) + iTime);\n        offset = (newOffset + 1.0) * 0.5;\n    }\n    return offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy) * 80.0 - 40.0;\n    float dopplerEffect = dopplerEffect (uv);\n    fragColor = vec4(vec3 (dopplerEffect), dopplerEffect * 0.1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/WtlXRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtlXzl", "name": "Shitty Cornell", "author": "Caparrini", "description": "Shitty Cornell box", "tags": ["cornell"], "likes": 0, "viewed": 71, "date": "1563931827", "time_retrieved": "2024-06-20T19:41:32.987011", "image_code": "\n// -------------------------------------------------------------------------\n// Struct definitions and scene setup\n// -------------------------------------------------------------------------\n\n// Camera parameters\nvec3 lower_left_corner = vec3(-1.0, -1.0, -1.0);\nvec3 horizontal = vec3(2, 0, 0);\nvec3 vertical = vec3(0, 2, 0);\nvec3 origin = vec3(0, 0, 0);\n\n// Ray struct\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n    float mint;\n    float maxt;\n};\n\n// Scene\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    vec3 color;\n};\n    \nSphere glowSphere = Sphere(vec3(0,0,0), 0.1,vec3(1,1,1));\n    \nconst int NUM_SPHERES = 6;\nconst Sphere spheres[NUM_SPHERES] = Sphere[NUM_SPHERES](  \n    Sphere(vec3(0.0, -10000.5, -1.0), 10000.,vec3(1,1,1)),\n    Sphere(vec3(0.0, 10000.5, -1.0), 10000.,vec3(1,1,1)),\n    Sphere(vec3(-10000.5, 0, -1.0), 10000.,vec3(1,0.2,0.2)),\n    Sphere(vec3(10000.5, 0, -1.0), 10000.,vec3(0.2,1,0.2)),\n    Sphere(vec3(0.0, 0.0, -10001.0), 10000.,vec3(1,1,1)),\n    Sphere(vec3(0, -.35, -.7), 0.15,vec3(.5,.85,1))\n);    \n\nstruct Light\n{\n    vec3 position;\n    vec3 color;\n    float intensity;\n};\n\n\n// Hit record information\nstruct HitRecord\n{\n    float t;\n    vec3 P;\n    vec3 N;\n    vec3 col;\n};\n    \n\n// -------------------------------------------------------------------------\n// Camera code\n// -------------------------------------------------------------------------\n\nRay computeCameraRay(vec2 uv)\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    Ray r;\n    r.origin = origin;\n    r.direction = lower_left_corner * vec3(aspectRatio, 1.0, 1.0) +\n          uv.x * horizontal * aspectRatio +\n          uv.y * vertical;\n    r.mint = 0.0;\n    r.maxt = 1e20;\n    return r;\n}\n\nRay computeLightRay(HitRecord hit)\n{\n    Ray r;\n    r.origin = hit.P;\n    \n    vec3 distToLight = (glowSphere.center - hit.P) - glowSphere.radius * glowSphere.radius;\n        \n    r.direction = normalize(distToLight);\n    r.mint = 0.0;\n    r.maxt = length(distToLight);\n    return r;\n}\n\n// -------------------------------------------------------------------------\n// Animation\n// -------------------------------------------------------------------------\n\nvoid animateSphere(Sphere s)\n{\n    glowSphere.center = vec3(sin(iTime/2.)/3., sin(iTime/3.)*.1+.1,sin(iTime)*.15 -.5);\n}\n\n// -------------------------------------------------------------------------\n// Light\n// -------------------------------------------------------------------------\n\nbool shadowDetect(Ray r, Sphere s)\n{        \n    vec3 oc = r.origin - s.center;\n    float a = dot(r.direction, r.direction);\n    float b = 2.0 * dot(oc, r.direction);\n    float c = dot(oc, oc) - s.radius * s.radius;\n    float det = b*b - 4.0*a*c;\n    if (det < 0.0)\n    \treturn false;\n    \n    \n    float t = (-b - sqrt(det)) / (2.0 * a);\n    if (r.mint <= t && t < r.maxt) \n        return true;\n\n    return false;\n}\n\n\nfloat computeLightInt(HitRecord hit)\n{\n    Ray r = computeLightRay(hit);\n\tvec3 distToLight = (glowSphere.center - hit.P) - glowSphere.radius * glowSphere.radius;\n    float dotL = dot(hit.N, r.direction);\n    \n    float intensity = (1.0/ length(distToLight)) * .3;\n    \n    \n    if(shadowDetect(r,spheres[5]))\n       {\n           intensity *= 0.00;\n       }\n    \n    return intensity * dotL;\n}\n\n\n// -------------------------------------------------------------------------\n// Intersection code\n// -------------------------------------------------------------------------\n\n\n\nbool hitSphere(Ray r, Sphere s, out HitRecord hit)\n{        \n    vec3 oc = r.origin - s.center;\n    float a = dot(r.direction, r.direction);\n    float b = 2.0 * dot(oc, r.direction);\n    float c = dot(oc, oc) - s.radius * s.radius;\n    float det = b*b - 4.0*a*c;\n    if (det < 0.0) {\n        return false;\n    }\n    \n    // first possible intersection\n    float t = (-b - sqrt(det)) / (2.0 * a);\n    if (r.mint <= t && t < r.maxt) { \n        hit.t = t;\n        hit.P = r.origin + t * r.direction;\n        hit.N = normalize(hit.P - s.center);\n        \n        hit.col = s.color * computeLightInt(hit);\n           \n        return true;\n    }\n\n    // second possible intersection\n    t = (-b + sqrt(det)) / (2.0 * a);\n    if (r.mint <= t && t < r.maxt) { \n        hit.t = t;\n        hit.P = r.origin + t * r.direction;\n        hit.N = normalize(hit.P - s.center);\n        return true;\n    }\n\n    return false;\n}\n\n// intersect against all spheres and return the first hit\nbool hitSpheres(Ray r, Sphere spheres[NUM_SPHERES], out HitRecord hit)\n{\n    bool hitSomething = false;\n    for (int i = 0; i < spheres.length(); ++i) {\n        if (hitSphere(r, spheres[i], hit)) {\n            \n            hitSomething = true;\n            // if we hit a sphere we update maxt on the ray to only find\n            // intersections that are even closer\n            r.maxt = hit.t;\n        }\n    }\n    \n    \n    return hitSomething;\n}\n\n\n// -------------------------------------------------------------------------\n// Core integrator\n// -------------------------------------------------------------------------\n    \n\nvec3 traceRay(Ray r)\n{\n    \n    HitRecord hit;\n    \n    if (hitSpheres(r, spheres, hit))\n    {\n        return hit.col;\n        \n    }\n    \n    return vec3(0.0,0.0,0.0);\n}\n\nvec3 traceRayGlow(Ray r)\n{\n    \n    HitRecord hit;\n    \n    if (hitSphere(r, glowSphere, hit))\n    {\n        return vec3(1,1,1);\n        \n    }\n    \n    return vec3(0.0,0.0,0.0);\n}\n\n\n// -------------------------------------------------------------------------\n// Main image computation\n// -------------------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    animateSphere(glowSphere);\n    \n    // Compute ray for pixel\n    Ray r = computeCameraRay(uv);\n\n    // Pixel Color\n    vec3 diffuse = traceRay(r);\n    vec3 emission = traceRayGlow(r);\n    vec3 ambient = vec3(0.01,0.005,0.07);\n    vec3 baseCol = diffuse + emission + ambient;\n    \n    vec3 finalCol = pow(baseCol, vec3(0.8,0.8,0.8) );\n    \n    // Output to screen\n    fragColor = vec4(finalCol,1.0);\n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtlXzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtlXzM", "name": "Patience 2", "author": "Yusef28", "description": "better menger Design\nbump mapping, triplanar, and all the lighting specific stuff comes mostly from user: \"Shane\"...Shane tho!\nMusic is mine tho!\nLet me know if the music is too loud tho!", "tags": ["menger", "red", "pattern", "chess", "shaneinspired"], "likes": 49, "viewed": 5425, "date": "1562631554", "time_retrieved": "2024-06-20T19:41:34.890294", "image_code": "#define PI 3.14159265358979323846\n\n//This first part is all stuff related to creating the checker pattern\n\n\n//basic rotation matrix\nmat2 prot (float a)\n{\n \n    mat2 m = mat2(cos(a), -sin(a), sin(a), cos(a) );\n    return m;\n}\n\n//creaes the golden frame, well just it's shape \nfloat stripes(vec2 p, float s, float e)\n{\n    p = fract(p*s);   \n    return min(smoothstep(0.95, 0.97, p.x)+smoothstep(0.95, 0.97, p.y),1.0);\n\t//return smoothstep(0.92, 0.95, p.x)-step(0.95,p.x)/5.;\n}\n\nfloat chess (vec2 p, float s)\n{\n    vec2 c = floor(p*s);\n    return mod(c.x +c.y, 2.0);    \n}\n\nvec3 pattern3(vec2 uv)\n{\n   // uv*=2.;\n    float wobble = (sin(iTime*4.-0.79)/3.);//fract(-iTime)/400.;//*0.05*sin(20.*iTime);\n    float smoothT = iTime/1. ;//+ sin(iTime)/16.;\n    \n    vec2 st = uv; ;//for vig later\n        uv*=1.25;\n     uv.x+=0.75;\n    uv.y+=0.75;   \n\n    vec2 sv =uv;//prot(PI*floor(uv.x))*uv;\n    \n    //adding teh bumpy pebble texture for the red squares\n    vec3 col = vec3(pow(texture(iChannel2, sv).x, 3.))*1.;\n\t\t\t\t\t\t\t\t\t\t\t //-sin(iTime/1.)/50. //add this to uv/2. of ichannel0 for movement\n    \n    //adding the moldy wood? texture for the black squares\n    col = mix(col, vec3(1.0, 0.0, .0)*texture(iChannel0,sv/2.+vec2(0., smoothT+wobble)).x, vec3(chess(uv, 2.0))  );\n    \n    //adding the frame, this one required a lot of hacking\n    \n    col = mix(col, vec3(texture(iChannel1, uv*0.01+0.75)/1.2+0.1)\n              //the sin portion is for the light movement\n              +abs(sin(uv.x*3.)),  \n              //this calles the stripes function\n              vec3(stripes(uv, 2., 1.)) )\n\n        -step(0.98, fract(2.*uv.x))/3.-step(0.98, fract(2.*uv.y))/3.;\n    \n    \n    //This is for vignetting\n     st *=  1.0 - st.yx;\n    float vig = st.x*st.y*15.;\n    vig = pow(vig, 0.09);\n    \n return clamp(col, 0., 1.);\n    \n}\n\n//and now the other stuff\n\n\n\n\nvec2 rot(vec2 uv,float a){\n\treturn vec2(uv.x*cos(a)-uv.y*sin(a),uv.y*cos(a)+uv.x*sin(a));\n}\n\nmat2 rot(float a)\n{\n    \n float si = sin(a);\n    float cs = cos(a);\n    \n    mat2 mat= mat2(cs, -si, si, cs);\n    return mat;\n}\n\n\nfloat getGrey(vec3 p)\n{\n    return p.x*0.299 + p.y*0.587 + p.z*0.114;\n       }\n\n\nvec3 triPlanar(sampler2D tex, vec3 p, vec3 n)\n{\n    \n    ///old comments\n    //this thing gets the normal, abs because we only need positive values, \n    //negative ones are going into the surface so not needed?\n    //we get max I guess because I guess if the normal is 0 or too small it's not helpful lol\n    //we get the sum and use it to get the percentage each component contributes to the whole.\n vec3 norm = max(abs(n), 0.0001);\t//I'll keep it simple with just this\n float sum = norm.x+norm.y+norm.z;\n norm = norm/sum;//so now the normal is a weighting factor, each component is  weight out of 100 percent\n   // p/=10.;\n    //I kinda get this. it's doing the scaling here, but it's still hard to visualize \n    //that adding texures of the yz, xz, and xy planes would result it a crisp image.\n    //for example, if the texture was a chess board pattern...hmmm maybe.\n    return vec3(pattern3(p.yz*8.)*norm.x + \n                pattern3(p.xz*8.)*norm.y +\n                pattern3(p.xy*8.)*norm.z ) ;\n    \n}\n\n\nvec3 bumpMap(sampler2D tex, in vec3 p, in vec3 n, float bumpfactor)\n{\n    \n   \n    const vec3 eps = vec3(0.001, 0., 0.);//I use swizzling here, x is eps\n    float ref = getGrey(triPlanar(tex, p, n));//reference value \n    \n    vec3 grad = vec3(getGrey(triPlanar(tex, p - eps, n)) - ref,\n                     //eps.yxz means 0.,0.001, 0. \"swizzling\n                     getGrey(triPlanar(tex, p - eps.yxz, n)) - ref,\n                     getGrey(triPlanar(tex, p - eps.yzx, n)) - ref)/eps.xxx;\n    \n    //so grad is the normal...then he does:\n    grad -= n*dot(grad, n);//takes the dot of the surface normal \n\n    return normalize(n + grad*bumpfactor);\n}\n\n\n\nfloat rect(vec3 p, vec3 b)\n{\n    float wobble=sin(12.*iTime+0.7);\n    wobble *= (smoothstep(0.6,0.9,sin(-iTime*4.))/60.);\n    p = abs(p)-b;\n return max(p.x, max(p.y, p.z));\n}\n\nfloat infRect(vec3 p, vec3 b)\n{\n    p = abs(p)-b;\n    float f = max(p.x, p.y);\n return f;   \n}\n\nfloat cylCross(vec3 p, float r)\n{\n p = abs(p);\n    vec3 f = vec3(max(p.x, p.y), max(p.y, p.z), max(p.z,p.x));\n    return min(length(p.xy), min(length(p.yz), length(p.xz)))-r;\n}\n\nfloat rCross(vec3 p)\n{float wobble = (sin(iTime*4.-0.79)/3.);\n    p = abs(p);\n    vec3 f = vec3(max(p.x, p.y), max(p.y, p.z), max(p.z,p.x));\n    float k = min(f.x, min(f.y, f.z) ) - 1./3.;\n    \n return k;   \n}\n\nfloat repCross(vec3 p)\n{\n    \n    vec3 q = mod(p+1., 2.)-1.;\n    float f = rCross(q);\n\n    \nq = abs(q)-0.5;\n\n   q = abs(q)-0.2;q = abs(q)-0.95;q = abs(q)-0.5;q = abs(q)-0.5;\n    q=abs(q)-0.005;\n    f = min(f, cylCross(q,0.101));\n    \n\n return f;   \n}\n\nfloat repCylCross(vec3 p)\n{\n    vec3 q = mod(p+1., 2.)-1.;\n    float f =  cylCross(q, 0.05) ;\n return f;   \n}\n\nfloat rcScale(vec3 p, float s)\n{\n    \n return repCross(p*s)/s;\n}\n\nfloat map(vec3 p)\n   {\n       //p = fract(p);\n     p.y+=sin(p.z*2.+iTime)/200.;\n      p.x+=sin(p.y*2.+iTime)/200.;\n    float re = 0.0;\n       float scale = 1.;\n       \n       for(int i=0; i<2 ;i++)\n       {\n        \n        scale*=3.;\n        re = max(re, -rcScale(p, scale)  );\n\n       }\n        \n    return re;//rect(p, vec3(2.5));\n    }\n\nfloat trace(vec3 ro, vec3 rd)\n{\n    float eps = 0.001;\n    float dist;\n    float t = 0.0;\n    for(int i = 0;i<96;i++)\n    {\n        dist = map(ro+rd*t);\n    if(dist<eps || t > 120.)\n        break;\n    \n    t +=dist*0.95;\n    }\n    \n    return t;\n\t    \n}\n//based on shanes reflection tutorial\nfloat rtrace(vec3 ro, vec3 rd)\n{\n    float eps = 0.0001;\n    float dist;\n   \tfloat t = 0.0;\n    \n    for(int i=0; i<48; i++)\n    {\n     dist = map(ro + rd*t);\n        if(dist<eps || t > 120.)\n            break;\n        \n      t += dist;\n        \n    }\n    \n    \n return t;   \n}\nvec2 path(vec3 p)\n{\n    \n float a = sin(p.z*1.)/3. ;\n     float b = cos(p.z)/3.;\n    return vec2(a, b);\n}\n\n\n\nvec3 normal(vec3 sp)\n{///had to adjust the normal cause I was getting these weird lines on edges.\n    vec3 eps = vec3(.0014, 0.0, 0.0);\n    \n    vec3 normal = normalize (vec3( map(sp+eps) - map(sp-eps)\n                       ,map(sp+eps.yxz) - map(sp-eps.yxz)\n                       ,map(sp+eps.yzx) - map(sp-eps.yzx) ));\n    \n    \n return normal;   \n}\n\n//guess who this is from...shane\n// \"I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\"\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n//based on shanes lighting function but i added reflections using a cubemap\nvec3 lighting(vec3 sp, vec3 sn, vec3 lp, vec3 rd)\n{\nvec3 color;\n    \n\n    sn = bumpMap(iChannel0, sp, sn, 0.0015);\n    vec3 lv = lp - sp;\n    float ldist = max(length(lv), 0.01);\n    vec3 ldir = lv/ldist;\n    \n    float atte = 1.0/(1.0 + 0.002*ldist*ldist );\n    \n    float diff = dot(ldir, sn);\n    float spec = pow(max(dot(reflect(-ldir, sn), -rd), 0.0), 10.);\n    float fres = pow(max(dot(rd, sn) + 1., 0.0), 1.);\n\tfloat ao = calculateAO(sp, sn);\n    \n    vec3 refl = reflect(rd, sn);\n    vec3 refr = refract(rd, sn, 0.7);\n    \n   vec3 color2 = vec3(0.2, 0.5, 0.9);\n    vec3 color3 = vec3(0.0);\n\n    vec3 coolSpec = vec3(.3, 0.5, 0.9);\n    vec3 hotSpec = vec3(0.9,0.5, 0.2);\n   color2 = triPlanar(iChannel0, sp, sn);\n    \n    //apply color options and add refl/refr options\n    color = (diff*color2*8. +  spec*coolSpec*9.  )*atte;\n\t\n    \n    //apply ambient occlusion and return.\n return color*ao;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv=uv*2.0-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    float wobble=sin(12.*iTime+0.7);\n    \n    wobble *= (smoothstep(0.6,0.9,sin(-iTime*4.))/60.);//fract(-iTime)/400.;//*0.05*sin(20.*iTime);\n    float smoothT = iTime/1. ;\n    \n    //(fract(.1*(iTime-1.))>=0.5)?:0.;\n    vec3 lk = vec3(0.,0. +wobble , 0.+iTime/16.);\n    \n    //lk.xy+=vec2(2.34,.34);//path(lk/4.);//lk.xz*=rot(lk.z);//;\n    vec3 ro = lk + vec3(0., 0., -1.0);\n    vec3 lp = ro + vec3(0, 0., 0.);//lp is ro so no area is too dark\n   \tfloat FOV = .57;\n    \n    vec3 fwd = normalize(lk - ro);\n    vec3 up = vec3(0., -1., 0.0);\n    vec3 rr = normalize(cross(up, fwd));\n    vec3 uu = normalize(cross(rr, fwd));\n    \n    vec3 rd = normalize(vec3(rr*FOV*uv.x + uu*FOV*uv.y + fwd));\n    \n   rd.yz*=rot(iTime/5.);\n    //rd.xz*=rot(iTime/10.);\n    rd.xz*=rot(sin(iTime/8.)/1.);\n    float t = trace(ro, rd);\n    \n     vec3 sp = ro + rd*t;\n    vec3 sn = normal(sp);\n   \t\n    float far = smoothstep(0.0, 1.0, t/4.);\n    \n    //get cube color from cubemap again this time to apply to the sky,\n    //really just so that the reflections on the ground make sense\n    \n  //  vec4 cubeColor = texture(iChannel1, rd);\n    vec3 color = lighting(sp, sn, lp, rd);//mix(stripes(ro+rd*t),vec3(t), far);\n     //reflection trace based on shanes reflection tutorial\n    vec3 refRay = reflect(rd, sn);\n    float rt = rtrace(sp+refRay*0.01, refRay);\n    vec3 rsp = sp + refRay*rt;\n    vec3 rsn = normal(rsp);\n\n    color = mix(color, vec3(2., 2.5, 3.) ,far);//\n\n\tfragColor = vec4(color+rsn.x*0.03,1.0);\n\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtlXzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtsSRX", "name": "Three Body", "author": "ChenYixue", "description": "    The three body trilogy tells the story of the rise and fall of the earth civilization in the universe, it is about Ye Wenjie in the \"Cultural Revolution\" who exposed the coordinate of the earth to aliens on three  bodies.\n", "tags": ["3d", "universe", "sciencefiction"], "likes": 4, "viewed": 488, "date": "1563801004", "time_retrieved": "2024-06-20T19:41:37.939161", "image_code": "//============================================================================\n// PROJECT ID:\n//\n// GROUP NUMBER:\n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// COMMENTS TO GRADER: \n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at http://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.010 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 3;\nconst int NUM_PLANES = 2;\nconst int NUM_SPHERES = 3;\nconst float PI = 3.1415926;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n // Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0; \n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of \n// Lecture 11 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS { \n//                   I_a * k_a + \n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    // Horizontal plane.\n    /*Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n\n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 3.5;\n    Plane[1].materialID = 0;*/\n\n    // Center bouncing sphere.\n    Sphere[0].center = vec3( 1.0 * cos(iTime), 1.0 * sin(iTime), 0.0 );\n    Sphere[0].radius = 0.6;\n    Sphere[0].materialID = 1;\n\n    // Circling sphere.\n    Sphere[1].center = vec3( 1.0 * cos(iTime + 2.0 * PI / 3.0), 1.0 * sin(iTime + 2.0 * PI / 3.0), 0.0);\n    Sphere[1].radius = 0.6;\n    Sphere[1].materialID = 2;\n    \n    Sphere[2].center = vec3( 1.0 * cos(iTime - 2.0 * PI / 3.0), 1.0 * sin(iTime - 2.0 * PI / 3.0), 0.0);\n    Sphere[2].radius = 0.6;\n    Sphere[2].materialID = 0;\n\n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // blue metal material.\n    Material[1].k_d = vec3( 0.5, 0.7, 0.9 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n    // Purple plastic material.\n    Material[2].k_d = vec3( 0.3, 0.0, 0.7 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.4 * Material[2].k_r;\n    Material[2].n = 128.0;\n\n    // Light 0.\n    Light[0].position = vec3( 4.0, 8.0, -3.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    // Light 1.\n    Light[1].position = vec3( -4.0, 8.0, 0.0 );\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    vec3 sphere_center = sph.center;\n    vec3 ray_orig = ray.o;\n    vec3 relative_orig = ray_orig - sphere_center;\n    float a = 1.0;\n    float b = dot(ray.d , relative_orig) * 2.0;\n    float c = dot(relative_orig, relative_orig ) -sph.radius * sph.radius;\n    float b2_4ac = b*b - 4.0*a*c;\n    if(b2_4ac<0.0)\n    {\n        return false; \n    }\n    else\n    {\n        float relative_intersect_t1 = (-b + sqrt(b2_4ac))/(2.0*a);\n        float relative_intersect_t2 = (-b - sqrt(b2_4ac))/(2.0*a);\n        float intersect_t;\n        if(relative_intersect_t1>=tmin&&relative_intersect_t1<=tmax)\n        {\n            if(relative_intersect_t2>= tmin&&relative_intersect_t2<=tmax)\n            {\n                intersect_t = min(relative_intersect_t1,relative_intersect_t2);\n            }\n            else\n            {\n                intersect_t = relative_intersect_t1;\n            }\n        }\n        else{\n             if(relative_intersect_t2>= tmin&&relative_intersect_t2<=tmax)\n            {\n                intersect_t = relative_intersect_t2;\n            }\n            else\n            {\n                return false;\n            }\n        }\n        t = intersect_t;\n        hitPos = ray_orig + t* ray.d;\n        hitNormal = hitPos - sphere_center;\n        hitNormal = normalize(hitNormal);\n        return true;\n    }\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    vec3 sphere_center = sph.center;\n    vec3 ray_orig = ray.o;\n    vec3 relative_orig = ray_orig - sphere_center;\n    float a = 1.0;\n    float b = dot(ray.d , relative_orig) * 2.0;\n    float c = dot(relative_orig, relative_orig ) -sph.radius * sph.radius;\n    float b2_4ac = b*b - 4.0*a*c;\n    if(b2_4ac<0.0)\n    {\n        return false; \n    }\n    else\n    {\n        float relative_intersect_t1 = (-b + sqrt(b2_4ac))/(2.0*a);\n        float relative_intersect_t2 = (-b - sqrt(b2_4ac))/(2.0*a);\n        return ((relative_intersect_t1>=tmin&&relative_intersect_t1<=tmax) ||(relative_intersect_t2>=tmin&&relative_intersect_t2<=tmax));\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a + \n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray, \n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg ) \n{\n    // Find whether and where the ray hits some object. \n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. \n    /////////////////////////////////\n    for( int i =0;i<NUM_PLANES;i++)\n    {\n        Plane_t pln = Plane[i];\n        temp_hasHit = IntersectPlane(pln, ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if(temp_hasHit)\n        {\n            hasHitSomething = true;\n            if(temp_t<= nearest_t)\n            {\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = pln.materialID;\n            }\n        } \n    }\n    for( int i =0;i<NUM_SPHERES;i++)\n    {\n        Sphere_t sphere = Sphere[i];\n        temp_hasHit = IntersectSphere(sphere, ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if(temp_hasHit)\n        {\n            if(temp_t<= nearest_t)\n            {\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = sphere.materialID;\n            }\n        }    \n        \n        \n    }\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point. \n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the \n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    for(int i=0;i<NUM_LIGHTS;i++)\n    {\n        Light_t light = Light[i];\n        vec3 shadowRay = light.position - nearest_hitPos ;\n        Ray_t sRay ;\n        sRay.o = nearest_hitPos;\n        sRay.d = normalize(shadowRay);\n        bool hitObject = false;\n        // for( int i =0;i<NUM_PLANES && (!hitObject);i++)\n        // {\n        //     Plane_t pln = Plane[i];\n        //     temp_hasHit = IntersectPlane(pln, sRay, DEFAULT_TMIN, DEFAULT_TMAX);\n        //     if(temp_hasHit)\n        //         hitObject = true;\n        // }\n        for( int i =0;i<NUM_SPHERES && (!hitObject);i++)\n        {\n            Sphere_t sphere = Sphere[i];\n            temp_hasHit = IntersectSphere(sphere, sRay, DEFAULT_TMIN, DEFAULT_TMAX);\n            if(temp_hasHit)\n                hitObject = true;\n        }\n        //vec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                   // in Material_t mat, in Light_t light )\n        I_local += PhongLighting(normalize(shadowRay), normalize(nearest_hitNormal), -ray.d, hitObject, Material[nearest_hitMatID], light);\n        // I_local += PhongLighting(-ray.d, normalize(nearest_hitNormal), normalize(-shadowRay),hitObject, Material[nearest_hitMatID], light);\n    }\n\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n\nfloat sphDistance( in vec3 ro, in vec3 rd, in Sphere_t sph )\n{\n\tvec3 oc = ro - sph.center;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.radius * sph.radius;\n    float h = b*b - c;\n    float d = sqrt( max(0.0, sph.radius * sph.radius - h)) - sph.radius;\n    return d;\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n\tfloat d = min(min(sphDistance( ro, rd, Sphere[0] ), sphDistance( ro, rd, Sphere[1] )), sphDistance( ro, rd, Sphere[2]));//#\n    vec3 glo = vec3(0.0);\n    glo += vec3(0.6,0.7,1.0) * 0.3 * exp(-2.0*abs(d)) * step(0.0,d);\n    glo += 0.6 * vec3(0.6,0.7,1.0) * 0.3 * exp(-8.0 * abs(d));\n    glo += 0.6 * vec3(0.8,0.9,1.0) * 0.4 * exp(-100.0 * abs(d));\n    col += glo * 2.0;              \n    return col;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    vec3 cam_pos = vec3( 5.0 * cos(iTime), 0.0, 5.0 * sin(iTime) + 5.0 );\n    //vec3 cam_pos = vec3( 5.0, 0.0, 10.0 );\n    vec3 cam_lookat = vec3(0.0, 0.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ ) \n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n    \n    \n    //universe\n    //get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\n\n\t//mouse rotation\n\tfloat a1=.5+iMouse.x/iResolution.x*2.;\n\tfloat a2=.8+iMouse.y/iResolution.y*2.;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(1.,.5,0.5);\n\tfrom+=vec3(time*2.,time,-2.);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t//volumetric rendering\n\tfloat s=0.1, fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n    \n    //light circle\n    vec3 col = render( pRay.o, pRay.d );\n\n    fragColor = vec4( I_result + v*.01 + col, 1.0 );\n    //fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtsSRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtsSW4", "name": "Gold Noise 3D", "author": "theGiallo", "description": "To see a XZ slice of the noise put TEMPORAL to 0.\nWith TEMPORAL 1 Z is time mod 1024.", "tags": ["noise", "bluenoise", "goldennoise", "goldnoise"], "likes": 6, "viewed": 626, "date": "1563016554", "time_retrieved": "2024-06-20T19:41:38.375427", "image_code": "#define TEMPORAL 1\n\n#define GOLDEN_X 25\n#define GOLDEN_Y 65535\nfloat  mod1( float x )\n{\n    return x - floor( x );\n}\n\nfloat\ngolden_noise( vec2 f )\n{\n    #define a 0.618034\n    #define l GOLDEN_X\n\n    f.y *= texture(iChannel1,f).r * float(GOLDEN_X);\n    int ll = l * l;\n    float ret = a;\n    int c = ( ll + ( int(f.x) + int(f.y) * GOLDEN_Y ) % ll ) % ll ;\n    for ( int i = 0; i != ll; ++i )\n    {\n        ret = mod1( ret + a );\n        if ( c == i )\n        {\n            break;\n        }\n    }\n    #undef a\n    #undef l\n    \n    return ret;\n}\n\nfloat PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   \nfloat PI  = 3.14159265358979323846264 * 00000.1; // PI\nfloat SQ2 = 1.41421356237309504880169 * 10000.0; // Square Root of Two\nfloat E   = 2.71828182846;\n\n////////////////////////////////////////////////////////////////////////////////\n// https://www.shadertoy.com/view/ltB3zD\nfloat gold_noise(in vec2 coordinate, in float seed){\n    return fract(tan(distance(coordinate*(seed+PHI), vec2(PHI, PI)))*SQ2);\n}\n////////////////////////////////////////////////////////////////////////////////\n\n\nfloat gold_noise3(in vec3 coordinate, in float seed){\n    return fract(tan(distance(coordinate*(seed+PHI), vec3(PHI, PI, E)))*SQ2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float g;\n    \n    if ( uv.x < 0.33 )\n    \tg = golden_noise( fragCoord );\n    else\n    if ( uv.x < 0.66 )\n    \tg = gold_noise( fragCoord, 0.0 );\n    else\n        #if TEMPORAL\n    \tg = gold_noise3( vec3(fragCoord.x,fragCoord.y,mod( floor(iTime*60.),1024. )), 0.0 );\n    \t//g = gold_noise3( vec3(fragCoord.x,fragCoord.y,float( int( floor(iTime*60.) ) % 1024 ) ), 0.0 );\n        #else\n    \tg = gold_noise3( vec3(fragCoord.x,0,fragCoord.y), 0.0 );\n        #endif\n        \n    col = vec3(g,g,g);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtsSW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtsSW8", "name": "Digital Void", "author": "lewdoo", "description": "Just something i made using a shader app on the train this morning and thought i'd share", "tags": ["random", "shapingfunctions"], "likes": 3, "viewed": 148, "date": "1562768486", "time_retrieved": "2024-06-20T19:41:38.375427", "image_code": "\n\nfloat random (vec2 uv){\n\tfloat rand = sin (fract(sin(uv.x * 2.528371\n\t\t + sin (uv.y * 7.72962))) * 83.62847) + sin (uv.x + sin (uv.y)) * 22.;\n\treturn rand;\n\t}\n\n#define PI 3.141592\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 col = vec3 (1., 1., 1.);\n\t// uv.x += iTime;\n\tvec2 outV = uv;\n\tvec2 newV = (uv - 0.5) * 2.;\n\tfloat fade = 1. - abs (uv.x * 2. - 1.);\n\toutV.x = fade * 2.;\n\toutV.y += outV.x * newV.y;\n\n\toutV.x *= 1.5;\n    \n    float spd = abs(random(vec2(floor(outV.y * 10.))) * 0.25 + 10.) * .2;\n    \n\toutV.x += iTime * -0.5 * spd;\n\n\tvec2 fpos = fract (outV * 10.);\n\t//used to add randomness to either side\n\toutV.x += floor (uv.x * 2. - 1.);\n\tvec2 ipos = floor (outV * 10.);\n\tfloat fval = fpos.x * fpos.y;\n\n\tfloat rand = abs (random (ipos)) * 0.05;\n\tfval = floor (sin (fpos.x * PI) + rand * 0.8);\n\tfval *= floor (sin (fpos.y * PI) + 0.3);\n\t//fval = sin (fpos.y * PI) * rand;\n\n    \n\t//col = vec3(abs(random(vec2(ipos.y, ipos.y))) * 0.05);\n    \n  col = vec3(fval);\n  col *= 1. - fade;\n  //col = vec3 (rand);\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtsSW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtsSzj", "name": "Thickness-dependent transparency", "author": "Eseris", "description": "A transparent object where the transparency depends of the traveled distance inside the object.\nYou can move the camera with the mouse.", "tags": ["raymarching", "refraction"], "likes": 3, "viewed": 339, "date": "1563572466", "time_retrieved": "2024-06-20T19:41:38.375427", "image_code": "#define pow(a,b) pow(abs(a),(b))\n\nconst int ALIASING_STEPS = 1;\n\nconst int NB_PASSES = 5;\nconst int MARCHING_STEPS = 150;\nconst float MIN_DIST = 0.;\nconst float MAX_DIST = 40.;\nconst float EPSILON = 1e-3;\n\nmat2 rot(float a) {\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat sdSphere(vec3 p, float radius) {\n\treturn length(p) - radius;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdRoundedCylinder(vec3 p, float ra, float rb, float h) {\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvec2 vUnion(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nvec2 map(vec3 p) {\n    vec2 d = vec2(sdPlane(p, vec4(0, 1, 0, 1.)), .1);\n    \n    //d = vUnion(d, vec2(sdSphere(p - vec3(4, 0., 1), 1.3), 2.27));\n    float dist = sdSphere(p - vec3(-3, 2, 0), 2.);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(3, 2, 0), 2.), 1.);\n    dist = opSmoothUnion(dist, sdCapsule(p, vec3(2, 2, 0), vec3(-2, 2, 0), 1.), 1.);\n    d = vUnion(d, vec2(dist, 2.27));\n    \n    //d = vUnion(d, vec2(sdRoundedCylinder(p - vec3(0, 1.1, 0), 1., .3, 1.7), 2.85));\n\n\treturn d;\n}\n\nvec3 mapGradient(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy).x - map(p - e.xyy).x,\n\t\tmap(p + e.yxy).x - map(p - e.yxy).x,\n        map(p + e.yyx).x - map(p - e.yyx).x\n\t));\n}\n\nvec2 rayProcess(vec3 camPos, vec3 rayDir, float start, float end) {\n\tfloat depth = start;\n   \tvec2 e = vec2(end, 0.);\n\tfor(int i = 0; i < MARCHING_STEPS; ++i) {\n\t\tvec2 dist = map(camPos + depth * rayDir);\n\t\tif(abs(dist.x) < EPSILON) return vec2(depth, dist.y);\n\t\tdepth += abs(dist.x);\n\t\tif(dist.x >= end) return e;\n\t}\n\treturn e;\n}\n\nvec3 rayDirection(float camAngle, vec2 coord) {\n\tvec2 uv = (coord - .5) * iResolution.xy;\n\tfloat focalDist = iResolution.y / 2. / tan(radians(camAngle) / 2.);\n\treturn normalize(vec3(uv, -focalDist));\n}\n\n\nfloat checkerboard(in vec3 p) {\n    vec3 q = floor(p);\n    return mod(q.x + q.z, 2.);              \n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    const float maxHei = 2.;\n    float tp = (maxHei-ro.y)/rd.y; \n    if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=min(0, iFrame); i<30; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res + .4, 0.0, 1.0 );\n}\n\nvec3 palette(float t) {\n\treturn vec3(.6, .5, .5) \n\t\t+ .5 * cos(6.283185 * (-vec3(1., 1., .5) * t + vec3(.2, .15, -.1) - .2));\n}\n\nvec3 applyLight(vec3 p, vec3 rd, vec3 nor, float id) {\n    vec3 col = vec3(0.);\n\n    // material        \n    vec3 mate = .7 * palette(fract(id));\n    if(id < 1.) {\n        float f = checkerboard(p);\n        mate = 0.2 + f*vec3(0.08);\n    }\n\n    // key light\n    vec3  lig = normalize(vec3(-8., 8., 5.));\n    vec3  hal = normalize( lig-rd );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float spe = pow(dot( nor, hal ), 100.0);\n    dif *= calcSoftshadow(p, lig, .1, 3.);\n\n    col = mate * 3.*dif*vec3(.80,0.70,0.6);\n    col +=      .6*spe*vec3(1.00,0.70,0.5);\n\n    // ambient light\n    float amb = .6;\n    col += mate*amb;\n    \n\treturn col;\n}\n\nvec3 refract2(vec3 i, vec3 n, float eta) {\n    if(dot(i, n) < 0.) eta = 1. / eta;\n    else n = -n;\n    return refract(i, n, eta);\n}\n\n\nvec3 shadingReflection(vec3 ro, vec3 rd, int nStep) {\n    vec3 p = ro + rd * 1e-2;\n    float alpha = 1.;\n    vec2 d = rayProcess(p, rd, MIN_DIST, MAX_DIST);\n    p += d.x * rd;\n    vec3 nor = mapGradient(p);\n\n    vec3 col = applyLight(p, rd, nor, d.y);\n    col *= pow(smoothstep(MAX_DIST, 10., d.x), 2.); // fog\n\n    if(d.y < 1.) {\n        float kr = pow(1. - abs(dot(nor,-rd)), 5.) + .03;\n        col = col * alpha * (1. - kr);\n    }\n    \n\treturn col;\n}\n\n\nvec3 shading(vec3 ro, vec3 rd) {\n    vec3 resCol = vec3(0);\n    vec3 p = ro;\n    float alpha = 1.;\n    for(int i = NB_PASSES; i > 0; --i) {\n        vec2 d = rayProcess(p, rd, MIN_DIST, MAX_DIST);\n    \tp += d.x * rd;\n    \tvec3 nor = mapGradient(p);\n        \n    \tvec3 col = applyLight(p, rd, nor, d.y);\n        col *= pow(smoothstep(MAX_DIST, 10., d.x), 2.); // fog\n        \n        if(d.y < 2.) {\n       \t\tfloat kr = pow(1. - abs(dot(nor,-rd)), 5.) + .03;\n        \tresCol += col * alpha * (1. - kr);\n       \t\talpha *= kr;\n            break;\n        }\n        else {\n       \t\tfloat kr = .1 + pow(1. - abs(dot(nor,-rd)), 5.);\n            resCol += shadingReflection(p, reflect(rd, nor), i-1) * alpha * kr;\n            \n            rd = refract2(rd, nor, 1.15);\n        \tp += rd * 1e-2; // small incr to avoid null dist\n            \n            // ############ transparency formula ###############\n            float depth = rayProcess(p, rd, MIN_DIST, MAX_DIST).x;\n            float transparency = 1. - exp(-5e-2 * pow(depth, 2.));\n            resCol += col * alpha * transparency;\n            \n           \talpha *= (1. - kr) * (1. - transparency);\n        }\n        \n    }\n    \n\treturn resCol;\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 tot = vec3(0.);\n    \n    for(int i = 0; i < ALIASING_STEPS; ++i) {\n        for(int j = 0; j < ALIASING_STEPS; ++j) {\n            vec2 offset = vec2(i, j) / 2. - .5;\n            vec3 camPos = vec3(0., 6., 10.);\n            vec3 rd = rayDirection(50., (fragCoord + offset) / iResolution.xy);\n            \n            float yaw = .5 * iTime;\n            float pitch = .2 + .3 *sin(.3 * iTime);\n            \n            if(iMouse.z > 0.) {\n                vec2 ang = iMouse.xy / iResolution.xy;\n                yaw = 7. * ang.x;\n                pitch = 1.5 * ang.y - .5;\n            }\n            \n            \n            camPos.yz *= rot(pitch);\n            camPos.zx *= rot(yaw);\n            rd.yz *= rot(.5 + pitch);\n            rd.zx *= rot(yaw);\n            //rd.yz *= rot(pitch);\n\n            vec3 col = vec3(0.);\n            col = shading(camPos, rd);\n            \n            // gamma\n            tot += pow(col, vec3(1. / 1.7));\n        }\n    }\n    \n    tot /= float(ALIASING_STEPS * ALIASING_STEPS);\n    \n#if 0\n\tvec2 uv = fragCoord/iResolution.yy;\n    float x = fragCoord.x / iResolution.x;\n\ttot = mix(tot, palette(x), step(abs(uv.y - .03), .02));\n#endif\n\tfragColor = vec4(tot, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtsSzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtsXR4", "name": "Shader Test #01", "author": "sillylab", "description": "First ShaderToy Test 07042019", "tags": ["helloworld"], "likes": 1, "viewed": 63, "date": "1562254551", "time_retrieved": "2024-06-20T19:41:38.496696", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    float newTime = iTime*500.0;\n    // Time varying pixel color\n    vec3 col = vec3(abs(sin(newTime)),0.0, 0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtsXR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtsXRs", "name": "swirlyMess001", "author": "Taron", "description": "experimenting with matrix rotations, bending space a little, more ray marching experiments, but nothing revolutionary, well, uhm, except possibly the revolutions? I'll have to rethink a few things, I believe, because I'm not convinced it has to be RM.", "tags": ["raymarching", "swirls"], "likes": 5, "viewed": 220, "date": "1563985080", "time_retrieved": "2024-06-20T19:41:38.496696", "image_code": "/*---------------------------------------------------------------\nI dare not comment anything in this one, yet. But in case someone \nbelieves I know what I'm doing and wants to know it, too, \njust let me know!\n---------------------------------------------------------------*/\nconst float radius = 0.3;\nfloat sRadius;\n\nfloat sphere(vec3 p, float radius)\n{\n  return length(p)-radius;\n}\nfloat box(vec3 p, vec3 c)\n{\n  vec3 q = abs(p)-c;\n  return (min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.)))*0.5;\n}\n\nfloat map(vec3 p)\n{\n    //p = mod(p,2.)-1.;\n    float pz = p.z+iTime;\n    vec3 rotx = vec3(sin(pz), cos(pz),0.);\n    vec3 roty = vec3(-rotx.y, rotx.x,0.);\n    vec3 rotz = normalize(cross(rotx, roty));\n  \tvec3 op = p;\n    p.x = rotx.x*op.x + roty.x*op.y+ rotz.x*op.z;\n    p.y = rotx.y*op.x + roty.y*op.y+ rotz.y*op.z;\n    p.z = rotx.z*op.x + roty.z*op.y+ rotz.z*op.z;\n    p = mod(p,2.)-1.;\n    //return sphere(p,sRadius);\n    return min(max(box(p,vec3(radius)),-sphere(p,sRadius)),sphere(p,sRadius*0.7));\n    //return mix(box(p,vec3(0.25)),sphere(p+vec3(cos(iTime)*.25,0.,sin(iTime)*0.05),.3+.25*sin(iTime*1.5)*0.5),sin(pz*3.33+iTime*.05));\n}\n\nvec3 getNormal(vec3 p)\n{\n  vec2 o = vec2(0.001, 0.);\n  return normalize(vec3(  map(p+o.xyy)-map(p-o.xyy),\n                          map(p+o.yxy)-map(p-o.yxy),\n                          map(p+o.yyx)-map(p-o.yyx)));\n}\n\nvec3 lighting(vec3 n, vec3 light)\n{\n    float lit = dot(n, light);\n    float sub = max(0.,0.5+0.5*lit);\n    vec3 col = vec3(max(0.,lit))+sub*vec3(0.3,0.46,0.5);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tfloat time = iTime;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(sin(time*1.45)*1.,1.*(cos(time*0.25)),5.*time);\n    vec3 p = ro;\n    vec3 rd = vec3(uv.xy*(0.25+0.75*length(uv.xy)),0.5);\n    rd = normalize(rd);\n\n    vec3 light = normalize(vec3(sin(time), cos(time), sin(time*0.25)));\n    vec3 bgColor = mix(vec3(1.7,0.96,0.2),vec3(0.1,0.25,0.4),length(uv));\n\n    bool hit = false;\n    float shading = 0.;\n    vec3 color = bgColor;\n  \n    sRadius = radius*1.3+sin(iTime)*radius*0.25;\n    \n    rd *= 0.5;\n    int i = 0;\n    p+=vec3(uv.xy,1.);\n    float dd;\n    while(i<100)\n    {\n        float d = map(p);\n        if(d<0.01)\n        {\n            hit = true;\n            \n            if(abs(d)<0.0001)\n                break;\n            \n            p-=rd*dd;\n            rd *=0.5;\n        }\n        dd = d;\n        p+=rd*d;\n      \ti++;\n     }\n\n    if(hit)\n    {\n        vec3 norm = getNormal(p);\n        float fog = min(1.0, 0.09*length(p-ro));\n        color = mix(lighting(norm, light),bgColor,fog);\n    }\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtsXRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtsXW4", "name": "Planets vectorial", "author": "z0rg", "description": "Single background I made in a low resolution few years ago that I wanted to an animted high res one.", "tags": ["space", "planets", "vectorial"], "likes": 1, "viewed": 98, "date": "1563033631", "time_retrieved": "2024-06-20T19:41:39.163468", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat sat(float a)\n{\n    return clamp(a, 0.,1.);\n}\n\nfloat rand(vec2 co){\n  return sat(fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453));\n}\n\nfloat drawExcentric(vec2 uv, float aRad, float bRad, vec2 excent)\n{\n    float luv = length(uv);\n    \n  \treturn float(length(uv - excent) > bRad && luv < aRad);\n}\n\nfloat drawCircle(vec2 uv, float rad)\n{\n    return float(length(uv) < rad);\n}\n\nfloat drawLight(vec2 uv, float sz)\n{\n    return float(sat(-(length(uv) - sz)));\n}\n\nvec4 drawPlanet(vec2 uv, float radius, float subRadius, vec2 excentricDir)\n{\n    float isOnPlanet = float(length(uv) < radius);\n    \n    vec3 col = vec3(float(drawExcentric(uv, radius,subRadius,excentricDir * (radius - subRadius)) > 0.5));\n    \n    col = col * (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)));\n    return vec4(col, isOnPlanet);\n}\n\nfloat drawDim(vec2 uv, float sz, float strength)\n{\n    return pow(sat(length(uv/sz)), strength);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col;\n    \n    vec2 bgPos = vec2(0.,0.1);\n    \n    col = vec3(1.)*(max(rand(uv),0.99)-0.99)*100.*0.8* length(uv);\n\n    col += pow(sat(1.-length(uv*.5-bgPos)),5.9)*vec3(129, 116, 242)/255.; // background\n    col *= drawDim(uv*vec2(1.,0.5)-vec2(0.3,-0.1), 0.25, 1.5);\n    \n\n    \n    vec4 planetA = drawPlanet(uv + vec2(-0.21,-0.0), 0.17, 0.16, 0.8*normalize(vec2(1.,-0.2)));\n    float orbitTime = iTime * 0.5;\n    \n    \n    \n    \n    vec2 bPos = vec2(-(sin(orbitTime)*0.5-0.21), 0.);\n    \n    vec2 bDir = bgPos - bPos;\n    \n    float bRad = 0.1*(cos(orbitTime) * 0.3 + 0.7);\n    vec4 planetB = drawPlanet(uv - bPos, bRad, sat(bRad-0.1*bRad), normalize(-bDir));\n    \n    \n    \n    \n    \n    if (planetA.w > 0.)\n        col = planetA.xyz;\n    if (!(bRad < 0.05 && planetA.w > 0.) )\n    \tcol = (planetB.xyz*planetB.w)+col - vec3(0.1)*planetB.w;//mix((planetB.xyz*planetB.w)+col, (planetB.xyz*(1.-planetB.w))*col, 0.5);\n    \n    vec3 colFlare = vec3(89, 202, 247)/255.;\n    col += colFlare*drawLight((uv-bgPos)*vec2(0.5,2.5), 0.5);  \n    col += colFlare*drawLight((uv-bgPos)*vec2(0.9,100.5), 0.5);\n    col += mix(colFlare, vec3(1.),0.9)*drawLight((uv-bgPos)*vec2(0.2,3.5), 0.5);\n    \n    col += mix(colFlare, vec3(1.),0.9)*drawLight((uv-bgPos)*vec2(0.2,3.5), 1.5)*0.1;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx;\n\n    uv -= vec2(0.5) * (iResolution.xy / iResolution.xx);\n    \n    vec3 col;\n\n   \tcol = rdr(uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtsXW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtsXWB", "name": "Cutting rounding onion practice", "author": "Hirai_worthless", "description": "so fun.", "tags": ["raymarching"], "likes": 1, "viewed": 89, "date": "1564133962", "time_retrieved": "2024-06-20T19:41:39.163468", "image_code": "float map(vec3 p){\n\n        p.xz *= mat2(cos(iTime),-sin(iTime)\n             ,sin(iTime),cos(iTime));\n    p.xy *= mat2(cos(0.3),-sin(0.3)\n             ,sin(0.3),cos(0.3));\n    p.yz *= mat2(cos(0.3),-sin(0.3)\n             ,sin(0.3),cos(0.3));\n            float edge = p.x;\n    float box = length(max(abs(p)-vec3(0.5,0.6,0.7),0.0))-0.1;\n\t\n\treturn max(min(abs(box) - 0.01,abs(length(p) - 0.5) - 0.05), - edge);\n}\n\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 96; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return vec4(getNormal(p),t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float PI = 3.14159265;\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv,1.2));\n    \n    vec3 o = vec3(0,0,-2.5);\n    vec4 data = trace(o,r);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    vec3 fc = mix(vec3(0.5 - data.x,0.5 -data.y,0.5-data.z),vec3(1.0),1.0 - fog);\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtsXWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtsXWj", "name": "Weyl sequence", "author": "FabriceNeyret2", "description": "low discrepancy sampling using Weyl sequence.  ( set #def to Uniform for comparison )", "tags": ["sampling", "hash", "bluenoise", "rand", "lowdiscrepancy"], "likes": 10, "viewed": 439, "date": "1564388142", "time_retrieved": "2024-06-20T19:41:39.320974", "image_code": "#define hash Nth_weyl   // Nth_weyl or Uniform\n\nvec2 Nth_weyl(int n) { // borrowed from https://www.shadertoy.com/view/3lsXW2\n    return fract(vec2(n*12664745, n*9560333)/exp2(24.));\n}\n\n#define Uniform(p)  fract(sin(float(p) * vec2(12.9898, 78.233)) * 43758.5453)\n    \nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy, D;\n    U = U/R.y; U.x -= (R.x/R.y-1.)/2.;\n    float t = 50.*iTime, m=1e9, ii;\n    \n    for (int i = int(t); i > 0; i--) {\n        D = hash(i) - U; \n        m = dot(D,D); if(m*R.y*R.y/6.<2.) { ii=float(i);break; }\n     // O += smoothstep(3.5,2.,length(D)*R.y);\n     // O += clamp(2.-dot(D,D)*R.y*R.y/6.,0.,1.) \n     //      * min(float(i)/t * vec4(1.4,1,.8,0),1.);\n    }\n    O = clamp(2.-m*R.y*R.y/6.,0.,1.) \n        * min(float(ii)/t * vec4(1.4,1,.8,0),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtsXWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtsXzH", "name": "Shitty Triangle SDF", "author": "zlnimda", "description": "View of the SDF from previous shader.\nCan rotate, scale and change origin", "tags": ["2d", "triangle", "distance"], "likes": 1, "viewed": 335, "date": "1562155535", "time_retrieved": "2024-06-20T19:41:39.715002", "image_code": "/* ----------------\n*\tzlnimda wrote this file and is under license CC-BY-SA-4.0 \n* \t( see legal notice: https://creativecommons.org/licenses/by-sa/4.0/legalcode )\n/* ----------------\n* \tSDF from previous shader: https://www.shadertoy.com/view/XsyyWm\n*/\n\nprecision highp float;\n\nconst float M_PI = 3.1415926535897932384626433832795;\n\n// normalized angle (a,b) [0,1]\nfloat normAngle(vec2 a, vec2 b)\n{\n    return .5 + .5 * sign(cross(vec3(a,0.), vec3(b,0.)).z) * -acos(dot(normalize(a), normalize(b))) / M_PI;\n}\n\n// shitty signed dist tri\nfloat sdtri(vec2 uv, vec2 o, float s, float a)\n{\n    uv = mat2(1./s,0.,0.,1./s) * (uv - o);\n    \n    vec2 oa = mat2(cos(a), -sin(a), sin(a), cos(a)) * vec2(0., -1.);\n    float ua = normAngle(oa, uv);\n    float ba = floor(ua * 3.);\n    float r = (0.25- ba) * 2.*M_PI/3. - a;\n    vec2 nn = mat2(cos(r), -sin(r), sin(r), cos(r)) * uv;\n    return nn.x - .5*s*.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec2  origin = vec2(cos(iTime) * 0.2, sin(iTime) * 0.2);\n    float scale = 1. + .5 * cos(iTime);\n    float angle = mod(iTime * .5, 2. * M_PI);\n    \n    float d = sdtri(uv, origin, scale, angle);\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-sa-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtsXzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtsXzs", "name": "(S.O.S.)", "author": "Kapsy", "description": "Demo or Die!", "tags": ["kapsy"], "likes": 1, "viewed": 80, "date": "1563989558", "time_retrieved": "2024-06-20T19:41:39.720915", "image_code": "//DEMO OR DIE!. KAPSY - S.O.S. ver1\n#define time fGlobalTime\n    mat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a));}\n  \n  float smin(float a, float b, float h){\n    float k = clamp((a-b)/h*0.5+0.5,0.,1.);\n    return mix(a,b,k)-k*(1.-k)*h;\n    }\n  \nfloat cv1 = 0.;\nfloat sphere(vec3 p){\n   p.xy*=rot(fract(iTime));\n  \n   p = abs(p);\n   p.x-=0.5;\n   p.y-=0.5;\n   float a = length(p)-0.4;\n   cv1 = 0.1/(0.1+a*a);\n   return a;\n  }\n \nfloat cv2 =0.;  \nfloat box(vec3 p, vec3 b){\n  p = abs(p)-b;\n  float f = max(p.x,max(p.y,p.z));\n  cv2 = 0.1/(0.1+f*f);\n  return f;\n  }\n  \n     float cv5 =0.; \n  float mouth(vec3 p){\n    p.y-=2.3;\n    p.z+=0.7;\n    float f = sqrt(length(p.zy)+length(p.yx))-mix(0.4,0.3,sin(iTime*4.));\n    cv5 = 0.1/(0.1+f*f);\n    return f;\n    }\n\n  \n   float cv3 = 0.;\n  float cv4 = 0.;\n  float face(vec3 p){\n     p.xz*=rot(mix(-0.4+0.3,0.4,sin(iTime)));\n     float f = length(p+vec3(0.,-3.,0))-0.8;\n     float e = length(p+vec3(0.2,-2.9,1.))-0.010;\n    float e2 = length(p+vec3(-0.2,-2.9,1))-0.010;\n     float m = mouth(p);    \n     //vec3 x = vec3(m);   \n     e = min(e,e2);\n     cv3 = 0.1/(0.1+f*f);\n     cv4 = 0.1/(0.1+e*e);\n     e = min(e,m);\n     return smin(e+e/2.,f,0.6);   \n    }\n    float uhi(vec3 p,float r){\n      return length(p)-r;\n      }\n    \n    float cv7= 0.;\n  float face2(vec3 p){\n     float f = length(p+vec3(0.,-3.,0))-0.8;\n     float e = length(p+vec3(0.2,-2.9,1.))-0.010;\n    float e2 = length(p+vec3(-0.2,-2.9,1))-0.010;\n     float m = mouth(p);    \n     e = min(e,e2);\n     cv7 = 0.1/(0.1+f*fract(f));\n     cv7 = 0.1/(0.1+e*e);\n     e = min(e,m);\n     float uhi = uhi(p,0.6);\n     float comp = smin(e+e/2.,f,0.6);\n     return min(uhi,comp);    \n    }\n\nfloat SDF3(vec3 p){\n   \n   float b = box(p,vec3(0.4,1,1));\n  float b2 = b-box(p,vec3(0.3,1,1));\n   b = max(b,-b2);\n   float a  = sphere(p);\n      float sc = min(b,a);\n  \n   return sc;\n  }\n  \n  \n  \n  float exit(vec3 p){\n    \n \n    p.x=abs(p.x-sin(mix(0.3-0.210,-0.3,sin(iTime))));\n   \n    float exit = box(p+vec3(0.,-5.25,0),vec3(1.5,1,1));\n     float exit2 = box(p+vec3(0.,-5.25,0),vec3(3,1,0.8));\n     exit = max(-exit,exit2);\n     vec4 fon;\n      if(p.y>9.) {fon  = texture(iChannel1,vec2(p.x/p.y));\n     exit= min(exit,fon.x); }\n     return exit;\n       \n     \n    }\n  float cv8 = 0.;\n  float cry(vec3 po){\n    float cry = uhi(po+vec3(0.45 ,mix(-4.46,-4.6,fract(-iTime/5.)),0.9),0.050);\n    \n    if(iTime >5. && iTime <10.) cry = uhi(po+vec3(0.45 ,mix(-4.46,-4.6,asin(-iTime/5.)),0.9),0.050);\n    if(iTime >15. && iTime<20.) cry = uhi(po+vec3(0.45 ,mix(-4.46,-4.6,asin(-iTime/5.)),0.9),0.050);\n    if(iTime >25. && iTime <30.) cry = uhi(po+vec3(0.45 ,mix(-4.46,-4.6,asin(-iTime/5.)),0.9),0.050);\n    if(iTime >35. && iTime<40.) cry = uhi(po+vec3(0.45 ,mix(-4.46,-4.6,asin(-iTime/5.)),0.9),0.050);\n    if(iTime >45. && iTime <50.) cry = uhi(po+vec3(0.45 ,mix(-4.46,-4.6,asin(-iTime/5.)),0.9),0.050);\n    if(iTime >55. && iTime<60.) cry = uhi(po+vec3(0.45 ,mix(-4.46,-4.6,asin(-iTime/5.)),0.9),0.050);\n    if(iTime >65. && iTime <70.) cry = uhi(po+vec3(0.45 ,mix(-4.46,-4.6,asin(-iTime/5.)),0.9),0.050);\n    if(iTime >75. && iTime<80.) cry = uhi(po+vec3(0.45 ,mix(-4.46,-4.6,asin(-iTime/5.)),0.9),0.050);\n     if(iTime >85.);\n    \n    cv8 = 0.1/(0.1+cry*cry);\n    return cry;\n    }\n  \n  float SDF2(vec3 p,vec3 po){\n     vec3 ppo = po;\n     float sc = SDF3(p);\n     float f = face(po);\n     float e = exit(ppo);\n     float cry = cry(po);\n\n     \n     po.y+=-3.150;\n     float fs = face2(vec3(po.x/2.,po.y*2.,po.z));\n      fs = min(fs,min(e,min(sc,f)));\n      return min(cry,fs);    \n    }\n\nfloat SDF(vec3 p){\n   vec3 pp = p;\n    float t = mod(fract(iTime),600.);\n    pp.z=mod(pp.z+iTime*4.,-3.145926);\n    for(float i=0.; i<6.;i++){\n        \n     pp = abs(pp);\n        \n        pp.y-=i*0.050;\n     // pp.x=fract(pp.x-pp.y);\n        pp.x-=mix(1.3,0.5,sin(iTime));}\n    if(pp.y>0.2) pp.y=mod(pp.y*0.6,0.);\n    if(pp.x>0.2) pp.x=mod(pp.x+pp.y*0.5,3.1)-2.5;\n    return SDF2(pp,p);\n  }\n  \n  \n  \n  \n  \nvec3 cam(vec3 ro, vec3 t, vec2 uv, float a){\n    vec3 f = normalize(t-ro);\n    vec3 l = normalize(cross(vec3(0,1,0),f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f*a+l*uv.x+u*uv.y);\n  }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n   // vec2 uv = fragCoord/iResolution.xy;\n/////////////////////////////////////////////////////////\n    \n\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1.);\n  vec2 uv2 = uv;\n  vec2 tel = -uv;\n  vec4 wat = texture(iChannel0,uv2-iTime);\n uv2+wat.xy;\n  \n  vec3 uv3 = vec3(uv2,0.);\n  \n  uv3.xy*=rot(iTime);\n  vec3 ro = vec3(0.,4.3,-3); vec3 p =ro;\n  \n  vec3 t = vec3(0.,0.5,4.9);\n  vec3 rd = cam(ro,t,uv,0.5);\n  \n  float dd = 0.0;\n  vec3 col = vec3(0.);\n  for(int i=0; i<100; i++){\n     \n     float d = SDF(p);\n     if(d<0.001) {break;}\n     if(dd>100.) {dd=100.; break;}\n     p+=d*rd;\n     dd+=d;\n    }\n  vec4 sh= texture(iChannel0,uv);\n \n\n  vec2 eps = vec2(0.001,0);\n  vec3 n = normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n  vec3 l = normalize(-vec3(0,2,3));\n  float fog = 1.-clamp(dd/100.,0.,1.);\n  vec3 h = normalize(l-rd);\n  col+=dot(n,l)*fog;\n  col+=cv1*vec3(0.,0.8,0.);\n  col+=cv2*vec3(1.,0.,0.);\n  col+=cv3*vec3(0.300, 0.340, 0.450)*sh.xyz;\n  col+=cv4*vec3(10,0.,0.)+pow(max(0.,dot(n,h)),100.);\n  col+=cv5*vec3(0,2,0)*pow(max(0.,dot(n,h)),500.);\n  col+=cv7*vec3(0.,mix(1.,2.,tan(iTime)),0);\n  col+=cv8*vec3(0.,0.,1);\n  col+=vec3(0.,0.,0.1)-0.3;\n   \n  if(uv.y>0.225) col+=smoothstep(0.5,1.,vec3(0.,0.,5.));\n  if(uv.y<0.225) col+=uv3;\n  \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtsXzs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtXSD2", "name": "Shiny textured softshadow donuts", "author": "Soondead", "description": "Added soft shadows to my scene and obviously had to show off by using donuts instead of spheres. It took me a while to figure out what most articles left out about marching from p towards the light, seeing as the nearest point would initially be p...", "tags": ["raymarching", "shadows", "textures", "soft", "polar"], "likes": 1, "viewed": 121, "date": "1564315239", "time_retrieved": "2024-06-20T19:41:41.612174", "image_code": "\nconst int MAX_MARCHING_STEPS = 64;\nconst float MIN_DIST = 0.1;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Based heavily on jlfwong's excellent raymarching tutorials\n * and some very helpful hints from the Shadertoy Community on Facebook,\n * this is my first venture into Shadertoy and raymarching.\n *\n * Please feel free to share your comments, I'm sure I've got the math\n * wrong in a number of places as most of it was figured out simply\n * by changing things until it seemed to work :-P\n *\n * My use of 4x4 matrices to describe transforms are there\n * to get the polar texture coordinates right. This required a lot\n * of rewriting and there's probably a simpler way...\n */\n\nfloat torus( vec4 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sphere(vec4 p, float r) {\n    return length(p.xyz) - r;\n}\n\n\n/** Normalize angles to -PI..PI range\n * WebGL seems to disagree when theta becomes too big or too small?\n */\nconst float PI = 3.1415;\nconst float TWO_PI = PI * 2.0;\n\nfloat n_theta(float theta) {\n\treturn theta - TWO_PI * floor((theta + PI) / TWO_PI);\n}\n\nfloat n_sin(float theta) {\n    return sin(n_theta(theta));\n}\n\nfloat n_cos(float theta) {\n    return cos(n_theta(theta));\n}\n\n\n\n\n/* 4x4 matrix funxtions */\n\nmat4 m_rotateX(float r) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, n_cos(r), n_sin(r)*-1.0, 0.0,\n        0.0, n_sin(r), n_cos(r), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 m_rotateY(float r) {\n    return mat4(\n        n_cos(r), 0.0, n_sin(r), 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        n_sin(r)*-1.0, 0.0, n_cos(r), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 m_rotateZ(float r) {\n    return mat4(\n        n_cos(r), n_sin(r)*-1.0, 0.0, 0.0,\n        n_sin(r), n_cos(r), 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 m_translate(vec3 v) {\n    return mat4(\n        1.0, 0.0, 0.0, v.x,\n        0.0, 1.0, 0.0, v.y,\n        0.0, 0.0, 1.0, v.z,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\n\n/** \n/**\n * SDF scene definition\n */\nfloat scene(vec4 sp, inout mat4 matrix, inout vec4 color, bool showlights) {\n    float dist = MAX_DIST;\n    float d = MAX_DIST;\n    mat4 m = mat4(1.0); // Don't move/rotate camera here, see definition of \"eye\" in main()\n    vec4 c = vec4(0.0, 0.0, 0.0, 0.0); // Will be replaced by object color (or discarded). 4th component = EMISSIVE yes/no, not ALPHA\n\n    // Add a red shape\n    m = m_translate(vec3(2.0, n_sin(iTime*2.0)*0.5, 0.0)) * m_rotateY(n_sin(iTime)*PI);\n    c = vec4(1.0, 0.2, 0.2, 0.0);\n    d = torus(sp*m, vec2(0.7, 0.3));\n    //d = sdSphere(sp*m, 1.0);\n    if (abs(d) < abs(dist)) { dist = d; matrix = m; color = c; }\n\n    // Add a green shape\n    m = m_translate(vec3(0.0, n_cos(iTime*2.0)*0.5, 0.0)) * m_rotateX((iTime+n_sin(iTime))*3.0);\n    c = vec4(0.2, 1.0, 0.2, 0.0);\n    d = torus(sp*m, vec2(0.7, 0.3));\n    //d = sdSphere(sp*m, 1.0);\n    if (abs(d) < abs(dist)) { dist = d; matrix = m; color = c; }\n\n    // Add a blue shape\n    m = m_translate(vec3(-2.2, n_sin(iTime*2.0)*0.5, 0.0)) * m_rotateZ(n_cos(iTime)*PI*-1.0);\n    c = vec4(0.0, 0.2, 1.0, 0.0);\n    d = torus(sp*m, vec2(0.7, 0.3));\n    //d = sdSphere(sp*m, 1.0);\n    if (abs(d) < abs(dist)) { dist = d; matrix = m; color = c; }\n\n    // Visualize light sources as small spheres\n    if (showlights == true) {\n\n        // Light1\n        m = m_translate(vec3(-3.0 * n_sin(iTime), -1.0, -3.0 * n_cos(iTime))); // Matches light1Pos moveent\n        c = vec4(0.6, 0.3, 0.3, 1.0); // alpha 1.0 = emissive\n        d = sphere(sp*m, 0.05);\n        if (abs(d) < abs(dist)) { dist = d; matrix = m; color = c; }\n\n        // Light2\n        m = m_translate(vec3(-2.0 * n_sin(0.37 * iTime),\n                              -2.0 * n_cos(0.37 * iTime),\n                              -2.0)); // Matches light2Pos movement\n        c = vec4(0.3, 0.6, 0.3, 1.0); // alpha 1.0 = emissive\n        d = sphere(sp*m, 0.05);\n        if (abs(d) < abs(dist)) { dist = d; matrix = m; color = c; }\n\n        // Light3\n        m = m_translate(vec3(-2.0 * n_sin(0.17 * iTime),\n                              -2.0 * n_cos(0.43 * iTime),\n                              -2.0)); // Matches light3Pos movement\n        c = vec4(0.3, 0.3, 0.6, 1.0); // alpha 1.0 = emissive\n        d = sphere(sp*m, 0.05);\n        if (abs(d) < abs(dist)) { dist = d; matrix = m; color = c; }\n\n    }\n\n    return dist;\n}\n\n\n\nfloat shortestDistanceToSurface(vec4 eye, vec4 marchingDirection, float start, float end, inout mat4 matrix, inout vec4 color) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = scene(eye + depth * marchingDirection, matrix, color, true);\n        if (dist < EPSILON) {\n\t\t\t      return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n\nvec4 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec4(xy, -z, 1.0));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec4 p) {\n    mat4 m = mat4(1.0); // Returned by scene, unused here\n    vec4 c = vec4(0.0, 0.0, 0.0, 0.0); // Returned by scene, unused here\n    return normalize(vec3(\n        scene(vec4(p.x + EPSILON, p.y, p.z, 1.0), m, c, false) - scene(vec4(p.x - EPSILON, p.y, p.z, 1.0), m, c, false),\n        scene(vec4(p.x, p.y + EPSILON, p.z, 1.0), m, c, false) - scene(vec4(p.x, p.y - EPSILON, p.z, 1.0), m, c, false),\n        scene(vec4(p.x, p.y, p.z  + EPSILON, 1.0), m, c, false) - scene(vec4(p.x, p.y, p.z - EPSILON, 1.0), m, c, false)\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n *\n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec4 eye, vec3 normal,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = normal;\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye.xyz - p);\n    vec3 R = normalize(reflect(-L, N));\n\n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n\n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    }\n\n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Calculate soft shadow by marching from point 'p' towards point 'light'\n * Obviously stolen from iq\n * Various articles fail to mention that scene() obviously starts by\n * returning p as nearest point so we need to ignore that and always move forward.\n * We are not looking for an exact surface hit.\n */\nfloat shadow(vec4 p, vec4 light) {\n    mat4 m = mat4(1.0); // My scene() requires this but we won't use\n    vec4 c = vec4(0.0, 0.0, 0.0, 0.0); // My scene() requires this but we won't use\n    float res = 1.0; // Initially assume no shadow\n    float lightsize = 2.0; // Bigger light = softer shadows\n\n    vec4 direction = light - p;\n    float total = MIN_DIST;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = scene(p + direction * total, m, c, false);\n        res = min(res, lightsize * dist/total);\n        total += clamp(dist, 0.02, 0.10); // Force ray forward from p\n        if (res < EPSILON || total > MAX_DIST) break;\n    }\n    return clamp(res, 0.0, 1.0);\n\n}\n\n/**\n * Lighting via Phong illumination.\n *\n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec4 eye, vec3 normal) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    mat4 m = mat4(1.0); // Return value from shadow SDF\n    vec4 c = vec4(0.0, 0.0, 0.0, 0.0); // Return value from shadow SDF\n\n    vec3 light1Pos = vec3(3.0 * sin(iTime), 1.0, 3.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.6, 0.3, 0.3);\n    float shadow1 = shadow(vec4(p, 1.0), vec4(light1Pos, 1.0));\n    color += shadow1 * phongContribForLight(k_d, k_s, alpha, p, eye, normal, light1Pos, light1Intensity);\n\n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime), 2.0 * cos(0.37 * iTime), 2.0);\n    vec3 light2Intensity = vec3(0.3, 0.6, 0.3);\n    float shadow2 = shadow(vec4(p, 1.0), vec4(light2Pos, 1.0));\n    color += shadow2 * phongContribForLight(k_d, k_s, alpha, p, eye, normal, light2Pos, light2Intensity);\n\n    vec3 light3Pos = vec3(2.0 * sin(0.17 * iTime), 2.0 * cos(0.43 * iTime), 2.0);\n    vec3 light3Intensity = vec3(0.3, 0.3, 0.6);\n    float shadow3 = shadow(vec4(p, 1.0), vec4(light2Pos, 1.0));\n    color += shadow3 * phongContribForLight(k_d, k_s, alpha, p, eye, normal, light3Pos, light3Intensity);\n\n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec4 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye.xyz);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n/**\n * Given a signed float value, wrap it to 0..1 range\n * Useful for out-of-range UV coordinates\n */\nfloat wrap_to_normal(float n) {\n    if (n > 1.0) {\n        return n - floor(n);\n    }\n    if (n < 0.0) {\n        return n + ceil(abs(n));\n    }\n    return n;\n}\n\nvec3 checkerboard(float u, float v) {\n    float r = 8.0; // Repetitions for uv 0..1\n    int ur = int(wrap_to_normal(u) * r);\n    int vr = int(wrap_to_normal(v) * r);\n    if ((ur+vr) % 2 == 1) {\n        return vec3(1.0, 1.0, 1.0);\n    } else {\n        return vec3(0.2, 0.2, 0.2);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 viewDir = rayDirection(45.0, iResolution.xy, fragCoord.xy);\n    vec4 eye = vec4(0.0, 0.0, 12.0, 1.0) * m_rotateX(PI/-6.0) * m_rotateY(PI/6.0 + (iTime*0.3));\n\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    mat4 transform = mat4(1.0);\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0); // Will be replaced by object color. 4th component is EMISSIVE yes/no\n\n    vec4 worldDir = viewToWorld * viewDir;\n\n\n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST, transform, color);\n\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        // Use a simple gradient on the lower half screen for background\n        fragColor = vec4(0.0, 0.0, 1.0-((fragCoord.y/iResolution.y)+0.5), 1.0);\n\t\t    return;\n    }\n\n    // The closest point on the surface to the eyepoint along the view ray\n    vec4 p = eye + dist * worldDir;\n\n\n    vec3 normal = estimateNormal(p);\n\n    // Calculate polar coordinates using a vector from p to center of object\n    // c = 0,0,0 * transform so p * transform should point in the right direction\n    vec4 pc = p * transform;\n    float u = atan(pc.z, pc.x) / PI; // Latitude\n    float v = atan(pc.y, sqrt((pc.x * pc.x) + (pc.z * pc.z))) / PI; // Longitude\n    vec3 texel = checkerboard(u, v);\n\n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = color.rgb;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 20.0;\n    vec3 phong = phongIllumination(K_a, K_d, K_s, shininess, p.xyz, eye, normal);\n\n    fragColor = vec4(phong.rgb * texel, 1.0);\n    if (color.a == 1.0) {\n        fragColor = vec4(fragColor.rgb + color.rgb, 1.0); // color.a is EMISSIVE yes/no\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtXSD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtXSDM", "name": "fbm with dummy light", "author": "takumifukasawa", "description": "fbm with dummy light", "tags": ["noise", "fbm", "random"], "likes": 5, "viewed": 131, "date": "1563171881", "time_retrieved": "2024-06-20T19:41:41.612174", "image_code": "//--------------------------------------------------------------------------\n// refs.\n// https://thebookofshaders.com/13/?lan=jp\n// http://www.iquilezles.org/www/articles/warp/warp.htm\n// http://www.iquilezles.org/www/articles/palettes/palettes.htm\n//--------------------------------------------------------------------------\n\n// t: 0-1, a: contrast, b: brightness, c: times, d: offset\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nconst int[] font = int[](0x75557, 0x22222, 0x74717, 0x74747, 0x11574, 0x71747, 0x71757, 0x74444, 0x75757, 0x75747);\nconst int[] powers = int[](1, 10, 100, 1000, 10000, 100000, 1000000);\n\nint PrintInt(in vec2 uv, in float value, const int maxDigits) {\n    if(abs(uv.y - .5) < .5) {\n        int iu = int(floor(uv.x));\n        if(iu >= 0 && iu < maxDigits) {\n            int n = (int(value) / powers[maxDigits - iu - 1]) % 10;\n            uv.x = fract(uv.x); //(uv.x-float(iu)); \n            ivec2 p = ivec2(floor(uv * vec2(4. ,5.)));\n            return (font[n] >> (p.x + p.y * 4)) & 1;\n        }\n    }\n    return 0;\n}\n\n// Get random value\nfloat random(in vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 4\nfloat fbm(in vec2 st) {\n  \tfloat value = 0.;\n  \tfloat amp = .55;\n  \tfloat freq = 0.;\n\n  \tfor(int i = 0; i < OCTAVES; i++) {\n    \tvalue += amp * noise(st);\n    \tst *= 2.1;\n    \tamp *= .35;\n  \t}\n  \treturn value;\n}\n\nfloat pattern(in vec2 p, float o) {\n  \tfloat f = 0.;\n\n\n  \tvec2 q = vec2(\n    \tfbm(p + o + vec2(0.)),\n    \tfbm(p + o + vec2(2.4, 4.8))\n  \t);\n\n  \tvec2 r = vec2(\n    \tfbm(q + o + 4. * q + vec2(3., 9.)),\n    \tfbm(q + o + 8. * q + vec2(2.4, 8.4))\n  \t);\n  \tf = fbm(p + r * 2. + iTime * .09);\n\treturn f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv *= 4.;\n    float fr = pattern(uv, iTime * 1.);    \n    float fg = fbm(uv + iTime + fr * .20);\n    float fb = fbm(uv + iTime + fg * .30);\n    \n    vec3 lightDir = normalize(vec3(1., 1., 2.));\n    vec3 normal = normalize(vec3(fr, fg, fb));\n    float angle = clamp(dot(lightDir, normal), 0., 1.);\n    vec3 eye = vec3(0., 0., 3.);\n    vec3 halfed = reflect(-eye, normal);\n    float spec = pow(clamp(dot(halfed, lightDir), 0., 1.), 64.);\n    \n    vec3 lightColor = vec3(1.);\n    \n    vec3 objColor = palette(\n    \t(fr + fg + fb) / 3.,\n        vec3(.5),\n        vec3(.5),\n        vec3(4.),\n        vec3(.1, .2, .3)\n    );\n    vec3 specularColor = vec3(objColor * 1.2);\n    \n    vec3 color = vec3(\n        objColor * lightColor * angle +\n        specularColor * lightColor * spec\n    );\n    \n    color = pow(color, vec3(.4545));\n    \n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtXSDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtXSR7", "name": "1D Quadratic Dual Interpolation", "author": "paniq", "description": "Interpolate the dual spaces between feature vertices with bernstein polynomials of degree 2, smoothing discontinuities to achieve C1 continuity.", "tags": ["quadratic", "dual", "interpolation"], "likes": 4, "viewed": 439, "date": "1562351643", "time_retrieved": "2024-06-20T19:41:45.388129", "image_code": "// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\n// uncomment to sacrifice C1 continuity \n// #define EXACT_CONTROL_POINT\n\nfloat p[3];\n\nfloat interpolate(float x) {\n    \n    float q0 = (p[0] + p[1]) * 0.5;\n    float q2 = (p[1] + p[2]) * 0.5;\n#ifdef EXACT_CONTROL_POINT\n    // go through control point, only C0 continuity:\n    float q1 = 2.0*p[1] - (q0 + q2) * 0.5;\n#else\n    // filter control point for C1 continuity:\n    float q1 = p[1];\n#endif\n    \n    x += 0.5; // move x from -0.5..0.5 to 0..1\n    \n    float t0 = (1.0 - x); t0 *= t0;\n    float t1 = 2.0*(1.0 - x)*x;\n    float t2 = x*x;\n    return t0*q0 + t1*q1 + t2*q2;\n}\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\nfloat AA;\nfloat AAINV;\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n#define save(name) Context name = _save();\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\nvoid paint() {\n    float t = iTime;\n    \n    p[0] = cos(t*0.79)*0.8;\n    p[1] = sin(t*0.9)*0.8;\n    p[2] = cos(t*0.49)*0.8;\n    \n    float d0 = (p[1] - p[0]) / 2.0;\n    float d1 = (p[2] - p[1]) / 2.0;\n    \n    set_source_rgb(vec3(1.0));\n    clear();\n    \n    set_line_width_px(1.3);\n    \n    set_source_rgba(0.0,0.0,0.0,1.0);\n    graph1D(interpolate);\n\tstroke();\n    \n    set_source_rgba(1.0,1.0,1.0,0.8);\n    rectangle(-3.0,-1.0,2.5,2.0);\n    rectangle(0.5,-1.0,2.5,2.0);\n\tfill();\n    \n    \n    set_source_rgba(0.0,0.0,0.0,0.5);\n    move_to(-0.5,-1.0);\n\tline_to(-0.5,1.0);\n    move_to(0.5,-1.0);\n\tline_to(0.5,1.0);\n    stroke();\n    \n    set_source_rgba(1.0,0.0,0.0,0.5);\n    move_to(-1.0, p[0]);\n    line_to(0.0, p[1]);\n\tline_to(1.0, p[2]);\n    stroke();\n    \n    set_source_rgba(0.0,0.0,0.0,1.0);\n    circle(-1.0, p[0], 0.02);\n    circle(0.0, p[1], 0.02);\n    circle(1.0, p[2], 0.02);\n\tfill();\n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));\n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\n    float m = ab.x*p.x/l;\n\tfloat n = ab.y*p.y/l;\n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\n    float c = (m2 + n2 - 1.0)/3.0;\n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n\n    vec2 r = vec2( ab.x*co, ab.y*si );\n\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(f_x / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtXSR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtXSRs", "name": "FractalSmeritySpin", "author": "Smerity", "description": "FractalSmeritySpin", "tags": ["fractalsmerityspin"], "likes": 3, "viewed": 158, "date": "1563846553", "time_retrieved": "2024-06-20T19:41:45.945649", "image_code": "// Based upon my earlier fractal:\n// https://www.shadertoy.com/view/ttlSRj\n\n// Hashing from https://www.shadertoy.com/view/lds3z7\nfloat hash( float n )\n{\n\treturn fract(sin(n) * 54671.57391);\n}\n\nfloat noise( vec2 p )\n{\n\treturn 2.0 * hash( iTime * p.x + p.y * 57.1235 ) - 1.0;\n}\n\n// Rotation (thanks for saving me from doing math!) from:\n// https://gist.github.com/yiwenl/3f804e80d0930e34a0b33359259b556c\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.y / iResolution.x;\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y *= ratio;\n    vec2 center = vec2(0.5, 0.5 * ratio);\n    uv -= center;\n    \n    // Anti-aliasing samples\n    float samples = 4.0;\n    \n    float finalCol = 0.0;\n    \n    for (int a = 0; a < int(samples); ++a) {\n        vec2 uv = fragCoord / iResolution.xy;\n       \tfloat noiseScale = 0.25;\n        uv.x += noiseScale * noise(float(a) * uv) / iResolution.x;\n        uv.y += noiseScale * noise(float(a) * uv) / iResolution.y;\n        uv.y *= ratio;\n        vec2 center = vec2(0.5, 0.5 * ratio);\n        uv -= center;\n        \n        vec2 coord = uv;\n\n        for (int i = 0; i < 5; ++i) {\n            // Causes the swipe to the bottom / top left\n            float yfuzz = sin(0.005 * iTime) * 0.001;\n            float xfuzz = cos(0.005 * iTime) * 0.4;\n            xfuzz -= 1.0;\n            yfuzz *= 1.0;\n            // Dictates the mirroring of the coordinates once it passes a threshold\n            // Smaller fstop means brighter image\n            float fstop = 0.38;\n            // If you want a hyperbola version centered around origin \n            fstop /= iMouse.z > 0.0 ? 28.0 * (uv.x * uv.y): 1.0;\n            coord = fract(coord * fstop * sin(0.4 * iTime) * xfuzz + 0.5 + yfuzz) * 2.0 - 1.0;\n            // Mirrored\n            float len = (2.0 - sin(0.3 * iTime)) * dot(coord, coord);\n            // Mirrorlen produces a scanline like effect\n            //float mirrorlen = (2.0 - sin(0.75 * iTime) - cos(uv.x * iTime)) * dot(coord, coord);\n            //coord = coord / len + 0.05 * coord / mirrorlen;\n            coord = coord / len;\n            coord = 0.04 * cos(iTime * 0.7) * coord + sin(0.3 * iTime) * rotate(coord, 100.0 * length(1.0 * uv));\n        }\n\n        //float circle = length(coord);\n        // Elongate the circle to form odd distorted smooth boxes\n        // See unit circles in various norms:\n        // https://en.wikipedia.org/wiki/Lp_space#/media/File:Vector-p-Norms_qtl1.svg\n        float circle = length(coord * coord * coord);\n\n        // The radius of the circle we're interested in shifts over time\n        float radius = 1.5 + sin(iTime);\n        // Otavio's neat-o trick for signed distance function\n        float scale = dFdx(uv.x);\n\n        float col = float((circle - radius) / scale > 0.0 ? 1.0 : 0.0);\n        finalCol += col;\n    }\n    \n    finalCol /= samples;\n    \n    // Debug mode makes it easy to see the circle start and end\n    //col = texture(iChannel0, coord).xyz;\n    \n    fragColor = vec4(finalCol, finalCol, finalCol, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtXSRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtXSWH", "name": "Midpoint polygon", "author": "tgsstdio", "description": "Draws polygon with circular hole with triangles\n", "tags": ["polygon", "hole"], "likes": 2, "viewed": 80, "date": "1562745709", "time_retrieved": "2024-06-20T19:41:47.194398", "image_code": "// CONTROLS NO OF POINTS ON POLYGON\n#define TWO_PI 6.283185307179586476925286766559\n\n#define LOOP_IN_SECS 15.0\n\n#define MIN_N 3\n#define MAX_N 12\n\n// TIME FUNCTIONS see https://www.shadertoy.com/view/MtXyD2\n\n// CONTROLS NO OF QUADS PER TRI\n\n#define SUBDIVISION_LOOP_IN_SECS 0.75\n#define NO_OF_DIVISIONS 4\n\nconst int sections[NO_OF_DIVISIONS] = int[](\n    6,\n    12,\n    24,\n    30  \n);    \n\n\n// CONTROLS RADIUS OF INNER HOLE\n\n#define MID_POINT 0.25\n#define RANGE_OF_TRIG_FUNC 0.24\n#define TWO_PI 6.283185307179586476925286766559\n// in hertz (per sec)\n#define FREQUENCY 0.5\n\n// RENDER SCALE\n\nconst float UNIT_SCALE = 4.0;\n\n// https://www.shadertoy.com/view/XsXSz4\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvec2 getMidpoint(vec2 a, vec2 b)\n{\n    vec2 dir = b - a;\n    return a + 0.5 * dir;\n}\n\nvec2 getInnerPoint(vec2 p1, vec2 p2, float ratio)\n{\n    vec2 dir = p2 - p1;\n    return p1 + (ratio * dir);\n}\n\nvec2 getRadialPoint(vec2 centre, vec2 outer, float radius)\n{\n    vec2 n = normalize(outer - centre);    \n    return centre + radius * n;\n}\n\nvec4 drawColouredQuad(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    vec4 outColor = vec4(0,0,0,0);\n    // QUAD 2\n    \t// outer [i+1] -> outer[i] \n    \t// inner [i+1] -> inner[i]\n    \t// inner[i+1], inner[i], outer[i+1]\n    if (sdTriangle(a, b, c, uv) <= 0.0) {       \n    \toutColor += vec4(1,0,1,1);       \n    }            \n   \n   \t// inner[i], outer[i], outer[i+1]    \n    if (sdTriangle(a, c, d, uv) <= 0.0) {       \n    \toutColor += vec4(1,1,0,1);       \n    }        \n    return outColor;\n}\n\nvec4 drawArm(vec2 centre, vec2 uv, vec2 left, vec2 right, float radius, int division)\n{\n    vec2 left_i = getRadialPoint(centre, left, radius);\n    \n    vec2 right_i = getRadialPoint(centre, right, radius);\n    \n    vec2 top_0 = left;\n    vec2 inside_0 = left_i;\n    \n    vec4 outColor = vec4(0,0,0,0);\n\n    float offset = 1. / float(division);\n    for (int i = 1; i < division; i += 1)\n    {\n        vec2 top_1 = getInnerPoint(left, right, float(i) * offset);  \n        vec2 inside_1 = getRadialPoint(centre, top_1, radius); \n\t\toutColor += drawColouredQuad(uv, top_0, inside_0, inside_1, top_1);\n        top_0 = top_1;\n        inside_0 = inside_1;\n    } \n\n    \n    outColor += drawColouredQuad(uv, top_0, inside_0, right_i, right);\n    return outColor;\n}\n\nvec4 drawCorner3(vec2 centre, vec2 uv, vec2 right, vec2 mid, vec2 left, float radius, int noOfQuads)\n{ \n    // QUAD 1\n    return drawArm(centre, uv, left, mid, radius, noOfQuads / 2)\n   \t + drawArm(centre, uv, mid, right, radius, noOfQuads / 2);        \n   // return outColor;\n}\n\nvec4 drawDot(vec2 pt, vec2 uv)\n{\n    vec2 diff = uv - pt;\n    if (dot(diff, diff) <= 0.005)\n    {\n        return vec4(0,1,0,1);\n    }\n    return vec4(0,0,0,0);\n}\n\nvec4 drawArcOnCorner(vec2 centre, vec2 uv, in vec2[MAX_N] points,\n                     int left, int mid, int right,\n                     float innerRadius, int division)\n{\n    vec2 mid_l = getMidpoint(points[mid], points[left]);\n    vec2 mid_r = getMidpoint(points[mid], points[right]);      \n        \n    return drawCorner3(centre, uv, mid_r, points[mid], mid_l, innerRadius, division);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    // SCREEN CORRECTION TO SQUARE\n    float fov = (iResolution.y / iResolution.x);\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    uv -= 0.5;\n    uv.y *= fov;\n    \n    // SCALE \n    uv *= UNIT_SCALE;  \t     \n    \n    float radius = 2.0;        \n    \n    float halfHeight = radius * sqrt(3.)/4.;\n    float halfWidth = radius * .5;    \n    \n    vec2 a =  vec2(0.,  halfHeight); \n    vec2 b = vec2(-halfWidth, -halfHeight);    \n    vec2 c = vec2(halfWidth, -halfHeight);  \n\n    // INTERSECTION OF MIDPOINT\n    // CENTRE CAN BE ANYTHING\n    vec2 centre = vec2(0.);  \n    \n    vec2 mid_a_b = getMidpoint(a, b);\n    vec2 mid_b_c = getMidpoint(b, c);\n    vec2 mid_c_a = getMidpoint(c, a);     \n    \n    // TOP: subdividing sections by value within int array           \n    float gapTimeStep = mod(iTime, SUBDIVISION_LOOP_IN_SECS) / SUBDIVISION_LOOP_IN_SECS;         \n\n    int division = sections[int(gapTimeStep * float(NO_OF_DIVISIONS))];  \n   // int division = 6;\n    float innerRadius = MID_POINT + RANGE_OF_TRIG_FUNC * sin( FREQUENCY * TWO_PI * iTime);    \n    \n    \n    //fragColor += drawCorner3(centre, uv, mid_c_a, a, mid_a_b, innerRadius, division / 3);\n    //fragColor += drawCorner3(centre, uv, mid_a_b, b, mid_b_c, innerRadius, division / 3);\n    //fragColor += drawCorner3(centre, uv, mid_b_c, c, mid_c_a, innerRadius, division / 3);    \n    \n    // 2ND from top: switching color values within array\n    float timeStep = mod(iTime, LOOP_IN_SECS) / LOOP_IN_SECS;                     \n    \n    int count = MIN_N + int(timeStep * float(MAX_N - MIN_N + 1));\n    //int count = 4;\n    \n    float angleOffset = TWO_PI / float(count);\n    \n    float angle = 0.;  \n\n    if (count % 2 == 0)\n    {\n        // 45 degrees\n        angle += angleOffset / 2.;\n    }\n    \n    fragColor += drawDot(centre, uv);\n    \n    // DRAW CIRCLES ON POLYGON CORNERS\n    vec2 points[MAX_N];\n    for (int i = 0; i < count; i++)\n    {       \n        points[i] = vec2(sin(angle), cos(angle));\n        fragColor += drawDot(points[i], uv);\n        angle += angleOffset;\n    }    \n    \n    // DRAW FACES FOR EACH CORNER\n    int leftIndex = count - 1;\n    int midIndex = 0;\n    int rightIndex = 1;\n    for (int i = 0; i < count - 1; i++)\n    {       \n       // vec2 left = points[leftIndex];\n       // vec2 mid = points[midIndex];\n       // vec2 right = points[rightIndex];\n        \n    \t//vec2 mid_l = getMidpoint(mid, left);\n    \t//vec2 mid_r = getMidpoint(mid, right);      \n        \n        fragColor += drawArcOnCorner(centre, uv, points, leftIndex, midIndex, rightIndex, innerRadius, division);\n        leftIndex = i;\n        midIndex++;\n        rightIndex++;            \n    }        \n\n    rightIndex = 0;\n    fragColor += drawArcOnCorner(centre, uv, points, leftIndex, midIndex, rightIndex, innerRadius, division);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtXSWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtXSWM", "name": "variant", "author": "ahihi", "description": "happy international nonbinary day <3", "tags": ["2d"], "likes": 2, "viewed": 255, "date": "1563141056", "time_retrieved": "2024-06-20T19:41:47.194398", "image_code": "vec3 flag(vec2 uv) {\n    if(uv.y < 0.25) {\n     \treturn vec3(1.0, 0.96, 0.04);\n    } else if(uv.y < 0.5) {\n        return vec3(1.0);\n    } else if(uv.y < 0.75) {\n     \treturn vec3(0.61, 0.35, 0.83);   \n    } else {\n        return vec3(0.0);\n    }\n}\n\nvec2 warp(vec2 uv) {\n    vec2 uv1 = uv + vec2(\n    \tuv.y*0.1,\n        0.0\n    );\n    vec2 d = vec2(\n        0.0,\n        0.23*sin(iTime + round(0.017*(uv1.x * 2.0 - 1.0)*4000.0))\n    );\n\treturn uv + d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.y = 1.0 - uv.y;\n    uv = warp(uv);\n    \n    vec3 c0 = flag(uv);\n    \n    // Output to screen\n    fragColor = vec4(c0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtXSWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtXSzM", "name": "Bicubic B-Spline Approx", "author": "paniq", "description": "Approximating a bicubic B-spline with two quadratic patches and visualizing the error (+- 0.1 for range -1..1)", "tags": ["bicubic", "quadratic", "interpolation"], "likes": 10, "viewed": 553, "date": "1562379672", "time_retrieved": "2024-06-20T19:41:51.891826", "image_code": "// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\n// compute barycentric coordinates from three points and a coordinate\n// this is equivalent to the distance of a point to each of the three planes,\n// normalized by the determinant\nvec3 barycentric(vec2 p[3], vec2 t) {\n    vec2 u = p[1] - p[2];\n    vec2 v = p[2] - p[0];\n    vec2 nu = vec2(-u.y, u.x);\n    vec2 nv = vec2(-v.y, v.x);\n    float det = 1.0 / dot(u, nv);\n    t -= p[2];\n    float w0 = dot(t, nu)*det;\n    float w1 = dot(t, nv)*det;\n    // computing the third coordinate this way adds numerical stability\n    float w2 = 1.0 - w0 - w1;\n    return vec3(w0,w1,w2);\n}\n\nvec2 from_barycentric(vec2 p[3], vec3 w) {\n    return p[0]*w.x + p[1]*w.y + p[2]*w.z;\n}\n\nvec2 normal_from_barycentric(vec2 p[3], vec3 w) {\n    vec2 d = (p[1] - p[2])*w.x + (p[2] - p[0])*w.y;\n    d = vec2(d.y, -d.x);\n    return d;\n}\n\nfloat bary_quadratic(vec3 w, vec3 c, vec3 m) {\n    return w.x*w.x*c.x\n         + w.y*w.y*c.y\n         + w.z*w.z*c.z\n         + 2.0*m.x*w.y*w.z\n         + 2.0*m.y*w.x*w.z\n         + 2.0*m.z*w.x*w.y;\n}\n\nvec3 weight(vec3 p) {\n    return vec3(\n\t\t(p[0]+p[1])*0.5,\n        p[1],\n        (p[1]+p[2])*0.5);\n}\n\nfloat interpolate2d_bicubic(mat3 p, vec2 o) {\n    vec3 s = vec3(\n    \t(1.0 - o.x)*(1.0 - o.x),\n    \t2.0*(1.0 - o.x)*o.x,\n    \to.x*o.x);\n    vec3 t = vec3(\n        (1.0 - o.y)*(1.0 - o.y),\n    \t2.0*(1.0 - o.y)*o.y,\n    \to.y*o.y);\n    vec3 q = vec3(\n    \tdot(weight(p[0]), s),\n    \tdot(weight(p[1]), s),\n    \tdot(weight(p[2]), s));\n    \n\treturn dot(weight(q), t);\n}\n\nfloat interpolate2d(mat3 p, vec2 o) {\n    vec3 bc;\n    bc[0] = (p[0][0]+p[0][1]+p[1][0]+p[1][1])*0.25;\n    bc[2] = (p[1][1]+p[1][2]+p[2][1]+p[2][2])*0.25;\n    vec3 bw = vec3(0.0);\n    float c = \n          p[0][0] * -3.0 + p[0][1] *  2.0 + p[0][2]\n        + p[1][0] *  2.0 + p[1][1] * 28.0 + p[1][2] *  2.0\n        + p[2][0]        + p[2][1] *  2.0 + p[2][2] * -3.0;\n    c /= 32.0;    \n    bw[1] = c;\n    vec2 tri[3];\n    tri[0] = vec2(0,0);\n    tri[2] = vec2(1,1);\n    if (o.x < o.y) {\n\t    tri[1] = vec2(0,1);\n\t    bc[1] = (p[1][0]+p[1][1]+p[2][0]+p[2][1])*0.25;\n        bw[0] = (p[1][1] + p[2][1])*0.5;\n        bw[2] = (p[1][1] + p[1][0])*0.5;\n    } else {\n\t    tri[1] = vec2(1,0);\n\t    bc[1] = (p[0][1]+p[0][2]+p[1][1]+p[1][2])*0.25;\n        bw[0] = (p[1][1] + p[1][2])*0.5;\n        bw[2] = (p[1][1] + p[0][1])*0.5;\n\t}\n    \n    vec3 b = barycentric(tri, o);\n    float q = bary_quadratic(b, bc, bw);\n    \n    return q;\n}\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\nfloat AA;\nfloat AAINV;\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n#define save(name) Context name = _save();\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\nvec2 anglevec(float a) {\n    return vec2(cos(a),sin(a));\n}\n\nvec2 transform(vec3 p) {\n    float o = 20.0;\n    vec2 dx = anglevec(radians(o));\n    vec2 dy = anglevec(radians(o+120.0));\n    vec2 dz = vec2(0.0, 0.33);\n    \n    return p.x * dx + p.y * dy + p.z * dz;\n}\n\nvoid paint() {\n    float t = iTime;\n\n    mat3 p;\n    mat2 m;\n    float e[4];\n    \n    p[0] = vec3(cos(t*0.79), sin(t*0.9), cos(t*0.51));\n    p[1] = vec3(sin(t*0.63), cos(t*0.85), sin(t*0.51));\n    p[2] = vec3(cos(t*0.55), sin(t*0.81), cos(t*0.72));\n    \n    for (int y = 0; y < 2; ++y) {\n        for (int x = 0; x < 2; ++x) {\n            float p0 = p[y][x];\n            float p1 = p[y][x+1];\n            float p2 = p[y+1][x];\n            float p3 = p[y+1][x+1];            \n            m[y][x] = (p0 + p1 + p2 + p3) / 4.0;\n        }\n    }\n    \n    // compute one level of catmull-clark for visualization\n    e[0] = p[0][0] + p[0][1] * 6.0 + p[0][2] \n         + p[1][0] + p[1][1] * 6.0 + p[1][2];\n    e[0] /= 16.0;\n    e[1] = p[1][0] + p[1][1] * 6.0 + p[1][2] \n         + p[2][0] + p[2][1] * 6.0 + p[2][2];\n    e[1] /= 16.0;\n    e[2] = p[0][0] + p[1][0] * 6.0 + p[2][0] \n         + p[0][1] + p[1][1] * 6.0 + p[2][1];\n    e[2] /= 16.0;\n    e[3] = p[0][1] + p[1][1] * 6.0 + p[2][1]\n         + p[0][2] + p[1][2] * 6.0 + p[2][2];\n    e[3] /= 16.0;\n    \n    float c = \n          p[0][0]       + p[0][1] *  6.0 + p[0][2]\n        + p[1][0] * 6.0 + p[1][1] * 36.0 + p[1][2] * 6.0\n        + p[2][0]       + p[2][1] *  6.0 + p[2][2];    \n    c /= 64.0;\n    \n    scale(0.7);\n    \n    set_line_width_px(1.3);\n    \n    set_source_rgba(0.0,0.0,0.0,0.2);\n    move_to(transform(vec3(-0.5,-0.5,0.0)));\n    line_to(transform(vec3( 0.5,-0.5,0.0)));\n    line_to(transform(vec3( 0.5, 0.5,0.0)));\n    line_to(transform(vec3(-0.5, 0.5,0.0)));\n    close_path();\n    stroke();\n    move_to(transform(vec3(-1.0,-1.0,0.0)));\n    line_to(transform(vec3( 1.0,-1.0,0.0)));\n    line_to(transform(vec3( 1.0, 1.0,0.0)));\n    line_to(transform(vec3(-1.0, 1.0,0.0)));\n    close_path();\n    stroke();\n\n    set_source_rgba(1.0,0.0,0.0,0.5);\n    for (int y = 0; y < 2; ++y) {\n        for (int x = 0; x < 3; x += 2) {\n            vec2 uv1 = vec2(x,y)-1.0;\n            vec2 uv2 = vec2(x,y);\n            move_to(transform(vec3(uv1, p[y][x])));\n            line_to(transform(vec3(uv1.x, uv2.y, p[y+1][x])));\n        }\n    }\n    for (int y = 0; y < 3; y += 2) {\n        for (int x = 0; x < 2; ++x) {\n            vec2 uv1 = vec2(x,y)-1.0;\n            vec2 uv2 = vec2(x,y);\n            move_to(transform(vec3(uv1, p[y][x])));\n            line_to(transform(vec3(uv2.x, uv1.y, p[y][x+1])));\n        }\n    }\n\tstroke();\n    \n    \n    set_source_rgba(0.0,0.0,0.0,0.3);    \n    for (int y = 0; y < 3; ++y) {\n        for (int x = 0; x < 3; ++x) {\n            vec2 uv = vec2(x,y)-1.0;\n            move_to(transform(vec3(uv, 0.0)));\n            line_to(transform(vec3(uv, p[y][x])));\n        }\n    }\n\tstroke();\n\n    set_source_rgba(0.0,0.0,0.0,0.3);\n    for (int y = 0; y < 2; ++y) {\n        for (int x = 0; x < 2; ++x) {\n            vec2 uv = vec2(x,y)-0.5;\n            move_to(transform(vec3(uv, 0.0)));\n            line_to(transform(vec3(uv, m[y][x])));\n        }\n    }\n    stroke();\n    \n    set_source_rgba(0.0,0.0,0.0,0.3);\n    { \tvec2 uv = vec2(0.0,-0.5);\n        move_to(transform(vec3(uv, 0.0)));\n        line_to(transform(vec3(uv, e[0]))); }\n    { \tvec2 uv = vec2(0.0, 0.5);\n        move_to(transform(vec3(uv, 0.0)));\n        line_to(transform(vec3(uv, e[1]))); }\n    { \tvec2 uv = vec2(-0.5,0.0);\n        move_to(transform(vec3(uv, 0.0)));\n        line_to(transform(vec3(uv, e[2]))); }\n    { \tvec2 uv = vec2( 0.5,0.0);\n        move_to(transform(vec3(uv, 0.0)));\n        line_to(transform(vec3(uv, e[3]))); }\n\tstroke();\n    \n\n    set_source_rgba(0.0,0.0,0.0,1.0);    \n    const float r = 0.02;\n    for (int y = 0; y < 3; ++y) {\n        for (int x = 0; x < 3; ++x) {\n            vec2 uv = vec2(x,y)-1.0;\n\t\t    circle(transform(vec3(uv, p[y][x])), r);\n        }\n    }\n\tfill();\n\n    set_source_rgba(0.0,0.0,1.0,0.7);\n    for (int y = 0; y < 2; ++y) {\n        for (int x = 0; x < 2; ++x) {\n            vec2 uv = vec2(x,y)-0.5;\n\t\t    circle(transform(vec3(uv, m[y][x])), r);\n        }\n    }\n\tfill();\n\n    set_source_rgba(0.0,0.5,0.0,0.7);\n    { \tvec2 uv = vec2(0.0,-0.5);\n        circle(transform(vec3(uv, e[0])), r); }\n    { \tvec2 uv = vec2(0.0, 0.5);\n        circle(transform(vec3(uv, e[1])), r); }\n    { \tvec2 uv = vec2(-0.5,0.0);\n        circle(transform(vec3(uv, e[2])), r); }\n    { \tvec2 uv = vec2( 0.5,0.0);\n        circle(transform(vec3(uv, e[3])), r); }\n\tfill();\n\n    set_source_rgba(1.0,0.0,0.0,0.7);\n    { \tvec2 uv = vec2( 0.0,0.0);\n        circle(transform(vec3(uv, c)), r); }\n\tfill();\n    \n#if 1\n    const int N = 20;\n    set_line_width_px(1.0);\n    for (int y = 0; y <= N; ++y) {\n        for (int x = 0; x <= N; ++x) {\n            vec2 uv = vec2(x,y)/float(N);\n            float z = interpolate2d(p, uv);\n            float zb = interpolate2d_bicubic(p, uv);\n            float e = abs(z - zb)*(1.0 / 0.1);\n\t    set_source_rgba(e,0.0,0.0,1.0);\n            circle(transform(vec3(uv-0.5, z)), r*1.8);\n            fill();\n        }\n    }\n\t//stroke();\n#endif\n\n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));\n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\n    float m = ab.x*p.x/l;\n\tfloat n = ab.y*p.y/l;\n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\n    float c = (m2 + n2 - 1.0)/3.0;\n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n\n    vec2 r = vec2( ab.x*co, ab.y*si );\n\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(f_x / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtXSzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtXSzX", "name": "Lines Stream", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 7, "viewed": 254, "date": "1563706225", "time_retrieved": "2024-06-20T19:41:51.891826", "image_code": "#define PI acos(-1.0)\n#define TAU PI*2.0\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec3 hue(float h)\n{\n    return cos((vec3(0,2,-2)/3.+h)*TAU)*.5+.5;\n}\n\nvec3 cLine(vec3 ro, vec3 rd, vec3 a, vec3 b)\n{\n    vec3 ab =normalize(b-a),ao = a-ro;\n\tfloat d0 = dot(rd, ab), d1 = dot(rd, ao), d2 = dot(ab, ao);\n\tfloat t = (d0*d1-d2)/(1.0-d0*d0)/length(b-a);\n    t= clamp(t,0.0,1.0);\n    vec3 p = a+(b-a)*t-ro;\n    return vec3(length(cross(p, rd)), dot(p,rd),t);\n}\n\nfloat hash(float n)\n{\n    return fract(sin(n)*5555.0);\n}\n\nvec3 randVec(float n)\n{\n\tvec3 v=vec3(1,0,0);\n    v.xy*=rot(asin(hash(n+=215.3)*2.-1.));\n    v.xz*=rot((hash(n)*2.-1.)*PI);\n\treturn v;\n}\n\nvec3 randCurve(float t,float n)\n{\n    vec3 p = vec3(0);\n    for (int i=0; i<4; i++)\n    {\n        p += randVec(n+=365.)*sin((t*=1.3)+sin(t*0.6)*0.5);\n    }\n    return p;\n}\n\nvec3 func(float t,float n)\n{\n    vec3 p = randCurve(-t*2.+iTime,2576.)*2.;\n    vec3 off = randVec(n)*(t+0.05)*0.6;\n    float time=iTime+hash(n)*8.0;\n    return p+off*sin(time+0.5*sin(0.5*time));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0-iResolution.xy) /iResolution.y;\n\tvec3 ro = vec3(0,0,5);\n    ro.xz*=rot(iTime*0.1);\n    vec3 w=normalize(-ro);\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\n    vec3 rd = mat3(u,cross(u,w),w)*normalize(vec3(uv,3));\n    vec3 col = hue(0.6)*0.2*(1.0-length(uv)*0.5);\n    vec3 de;\n    float ITR=40.;\n    for(float i=0.; i<1.;i+=1.0/8.0)\n    {\n        de = vec3(1e9);\n        float off=hash(i+256.);\n    \tfor(float j=0.0;j<1.0;j+=1.0/ITR)\n    \t{\n            float t=j+off*0.5;\n        \tvec3 c = cLine(ro, rd, func(t,off), func(t+1.0/ITR,off));\n        \tif (de.x*de.x*de.y>c.x*c.x*c.y)\n        \t{\n           \t\tde=c;\n           \t\tde.z = j + c.z/ITR;\n        \t}\n    \t}\n        \n        float s = pow(max(0.0,0.6-de.z),2.0)*0.1;\n        if(de.y>0.)\n            col+=mix(vec3(1),hue(i),0.8)*(1.0-de.z*0.9)*smoothstep(s+0.07,s,de.x)*0.7;\n            //col = mix(mix(vec3(1),hue(i),0.6)*(1.0-de.z*0.9),col,smoothstep(s,s+0.04,de.x)); \n    }\n    fragColor = vec4(min(vec3(1),col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtXSzX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtXXRX", "name": "RayMarchingBand010", "author": "Hirai_worthless", "description": "Streamline", "tags": ["raymarching"], "likes": 1, "viewed": 213, "date": "1563696746", "time_retrieved": "2024-06-20T19:41:51.897921", "image_code": "float PI = 3.14159265;\nmat2 makeRotMat(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\nfloat map(vec3 p){\n    float wall_in = abs(p.x*cos(p.z / 5.0)+p.y*sin(p.z / 5.0)) - 1.0;\n    float wall_out = abs(p.x*cos(p.z / 5.0)+p.y*sin(p.z / 5.0)) - 1.2;\n\tfloat wall = max(wall_out, -wall_in);\n    float poles = length(abs(p.xy * makeRotMat(p.z / 5.0)) - vec2(0.4,0.0)) - 0.15;\n    return min(wall,poles); \n}\n\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 32; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return vec4(getNormal(p),t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv,1.0));\n    vec3 o = vec3(0,0,iTime * 3.0);\n    vec4 data = trace(o,r);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.2);\n    vec3 fc = mix(vec3(0.5 - data.x,0.5 -data.y,0.5-data.z),vec3(1),1.0 - fog);\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtXXRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtXXW2", "name": "大龙猫 - гэр ", "author": "totetmatt", "description": "Fait sous la гэр", "tags": ["pifpafpouf"], "likes": 3, "viewed": 274, "date": "1564304682", "time_retrieved": "2024-06-20T19:41:51.897921", "image_code": "#define time iTime\nvec2 scroll(vec2 uv,vec2 c) {\n    uv.y += sin(c.x+time/6.);\n    uv.x += cos(c.y+time/6.);\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\n   vec2 uv  = ( fragCoord -.5* iResolution.xy ) / iResolution.y;\n\n    vec2 c  = floor(4.*uv);\n    vec2 cell = fract(4.*scroll(uv+vec2(time/5.,0),c))-0.5;\n        cell/=uv.y*2.;\n    float color = length(cell)-.2;\n    float p = .3;\n    color = smoothstep(p,p+.001+abs(c.x/13.),color);\n    vec3 fcolor = mix(vec3(0.1),vec3(0.2,0.5,0.6),color);\n    fcolor.r *= tan(c.x*5.-time*3.)*3.;\n    \n    fragColor = vec4(fcolor,\n        1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtXXW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtXXWj", "name": "My big shiny textured balls", "author": "Soondead", "description": " Based heavily on jlfwong's excellent raymarching tutorials and some very helpful hints from the Shadertoy Community on Facebook, this is my first venture into Shadertoy and raymarching.\n \n Please feel free to share your comments.", "tags": ["raymarching", "phong", "textures", "polar"], "likes": 3, "viewed": 79, "date": "1564211118", "time_retrieved": "2024-06-20T19:41:53.637284", "image_code": "\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Based heavily on jlfwong's excellent raymarching tutorials\n * and some very helpful hints from the Shadertoy Community on Facebook,\n * this is my first venture into Shadertoy and raymarching.\n *\n * Please feel free to share your comments, I'm sure I've got the math\n * wrong in a number of places as most of it was figured out simply\n * by changing things until it seemed to work :-P\n *\n * My use of 4x4 matrices to describe transforms are there\n * to get the polar texture coordinates right. This required a lot\n * of rewriting and there's probably a simpler way...\n */\n\n\nfloat sphere(vec4 p, float r) {\n    return length(p.xyz) - r;\n}\n\n\n/** Normalize angles to -PI..PI range\n * WebGL seems to disagree when theta becomes too big or too small?\n */\nconst float PI = 3.1415;\nconst float TWO_PI = PI * 2.0;\n\nfloat n_theta(float theta) {\n\treturn theta - TWO_PI * floor((theta + PI) / TWO_PI);\n}\n\nfloat n_sin(float theta) {\n    return sin(n_theta(theta));\n}\n\nfloat n_cos(float theta) {\n    return cos(n_theta(theta));\n}\n\n\n\n\n/* 4x4 matrix funxtions */\n\nmat4 m_rotateX(float r) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, n_cos(r), n_sin(r)*-1.0, 0.0,\n        0.0, n_sin(r), n_cos(r), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 m_rotateY(float r) {\n    return mat4(\n        n_cos(r), 0.0, n_sin(r), 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        n_sin(r)*-1.0, 0.0, n_cos(r), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 m_rotateZ(float r) {\n    return mat4(\n        n_cos(r), n_sin(r)*-1.0, 0.0, 0.0,\n        n_sin(r), n_cos(r), 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 m_translate(vec3 v) {\n    return mat4(\n        1.0, 0.0, 0.0, v.x,\n        0.0, 1.0, 0.0, v.y,\n        0.0, 0.0, 1.0, v.z,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\n\n/** \n/**\n * SDF scene definition\n */\nfloat scene(vec4 sp, inout mat4 matrix, inout vec4 color) {\n    float dist = MAX_DIST;\n    float d = MAX_DIST;\n    mat4 m = mat4(1.0); // Don't move/rotate camera here, see definition of \"eye\" in main()\n    vec4 c = vec4(0.0, 0.0, 0.0, 0.0); // Will be replaced by object color (or discarded). 4th component = EMISSIVE yes/no, not ALPHA\n\n    // Add a red shape\n    m = m_translate(vec3(2.0, n_sin(iTime*5.0)*0.5, 0.0)) * m_rotateY(n_sin(iTime)*PI);\n    c = vec4(1.0, 0.2, 0.2, 0.0);\n    d = sphere(sp*m, 1.0);\n    if (abs(d) < abs(dist)) { dist = d; matrix = m; color = c; }\n\n    // Add a green shape\n    m = m_translate(vec3(0.0, n_cos(iTime*5.0)*0.5, 0.0)) * m_rotateX((iTime+n_sin(iTime))*3.0);\n    c = vec4(0.2, 1.0, 0.2, 0.0);\n    d = sphere(sp*m, 1.0);\n    if (abs(d) < abs(dist)) { dist = d; matrix = m; color = c; }\n\n    // Add a blue shape\n    m = m_translate(vec3(-2.0, n_sin(iTime*5.0)*0.5, 0.0)) * m_rotateZ(n_cos(iTime)*PI*-1.0);\n    c = vec4(0.0, 0.2, 1.0, 0.0);\n    d = sphere(sp*m, 1.0);\n    if (abs(d) < abs(dist)) { dist = d; matrix = m; color = c; }\n\n    // Visualize light sources as small spheres\n\n    // Light1\n    m = m_translate(vec3(-3.0 * n_sin(iTime),\n                         -1.0,\n                         -3.0 * n_cos(iTime))); // Matches light1Pos moveent\n    c = vec4(0.6, 0.3, 0.3, 1.0); // alpha 1.0 = emissive\n    d = sphere(sp*m, 0.05);\n    if (abs(d) < abs(dist)) { dist = d; matrix = m; color = c; }\n\n    // Light2\n    m = m_translate(vec3(-2.0 * n_sin(0.37 * iTime),\n                          -2.0 * n_cos(0.37 * iTime),\n                          -2.0)); // Matches light2Pos movement\n    c = vec4(0.3, 0.6, 0.3, 1.0); // alpha 1.0 = emissive\n    d = sphere(sp*m, 0.05);\n    if (abs(d) < abs(dist)) { dist = d; matrix = m; color = c; }\n\n    // Light3\n    m = m_translate(vec3(-2.0 * n_sin(0.17 * iTime),\n                          -2.0 * n_cos(0.43 * iTime),\n                          -2.0)); // Matches light3Pos movement\n    c = vec4(0.3, 0.3, 0.6, 1.0); // alpha 1.0 = emissive\n    d = sphere(sp*m, 0.05);\n    if (abs(d) < abs(dist)) { dist = d; matrix = m; color = c; }\n\n    return dist;\n}\n\n\n\nfloat shortestDistanceToSurface(vec4 eye, vec4 marchingDirection, float start, float end, inout mat4 matrix, inout vec4 color) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = scene(eye + depth * marchingDirection, matrix, color);\n        if (dist < EPSILON) {\n\t\t\t      return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n\nvec4 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec4(xy, -z, 1.0));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec4 p) {\n    mat4 m = mat4(1.0); // Returned by scene, unused here\n    vec4 c = vec4(0.0, 0.0, 0.0, 0.0); // Returned by scene, unused here\n    return normalize(vec3(\n        scene(vec4(p.x + EPSILON, p.y, p.z, 1.0), m, c) - scene(vec4(p.x - EPSILON, p.y, p.z, 1.0), m, c),\n        scene(vec4(p.x, p.y + EPSILON, p.z, 1.0), m, c) - scene(vec4(p.x, p.y - EPSILON, p.z, 1.0), m, c),\n        scene(vec4(p.x, p.y, p.z  + EPSILON, 1.0), m, c) - scene(vec4(p.x, p.y, p.z - EPSILON, 1.0), m, c)\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n *\n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec4 eye, vec3 normal,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = normal;\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye.xyz - p);\n    vec3 R = normalize(reflect(-L, N));\n\n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n\n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    }\n\n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n *\n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec4 eye, vec3 normal) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n\n    vec3 light1Pos = vec3(3.0 * n_sin(iTime),\n                          1.0,\n                          3.0 * n_cos(iTime));\n    vec3 light1Intensity = vec3(0.6, 0.3, 0.3);\n\n    color += phongContribForLight(k_d, k_s, alpha, p, eye, normal,\n                                  light1Pos,\n                                  light1Intensity);\n\n    vec3 light2Pos = vec3(2.0 * n_sin(0.37 * iTime),\n                          2.0 * n_cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.3, 0.6, 0.3);\n\n    color += phongContribForLight(k_d, k_s, alpha, p, eye, normal,\n                                  light2Pos,\n                                  light2Intensity);\n\n    vec3 light3Pos = vec3(2.0 * n_sin(0.17 * iTime),\n                          2.0 * n_cos(0.43 * iTime),\n                          2.0);\n    vec3 light3Intensity = vec3(0.3, 0.3, 0.6);\n\n    color += phongContribForLight(k_d, k_s, alpha, p, eye, normal,\n                                  light3Pos,\n                                  light3Intensity);\n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec4 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye.xyz);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n/**\n * Given a signed float value, wrap it to 0..1 range\n * Useful for out-of-range UV coordinates\n */\nfloat wrap_to_normal(float n) {\n    if (n > 1.0) {\n        return n - floor(n);\n    }\n    if (n < 0.0) {\n        return n + ceil(abs(n));\n    }\n    return n;\n}\n\nvec3 checkerboard(float u, float v) {\n    float r = 8.0; // Repetitions for uv 0..1\n    int ur = int(wrap_to_normal(u) * r);\n    int vr = int(wrap_to_normal(v) * r);\n    if ((ur+vr) % 2 == 1) {\n        return vec3(1.0, 1.0, 1.0);\n    } else {\n        return vec3(0.2, 0.2, 0.2);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 viewDir = rayDirection(45.0, iResolution.xy, fragCoord.xy);\n    vec4 eye = vec4(0.0, 0.0, 12.0, 1.0) * m_rotateX(PI/-6.0) * m_rotateY(PI/6.0 + (iTime*0.3));\n\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    mat4 transform = mat4(1.0);\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0); // Will be replaced by object color. 4th component is EMISSIVE yes/no\n\n    vec4 worldDir = viewToWorld * viewDir;\n\n\n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST, transform, color);\n\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        // Use a simple gradient on the lower half screen for background\n        fragColor = vec4(0.0, 0.0, 1.0-((fragCoord.y/iResolution.y)+0.5), 1.0);\n\t\t    return;\n    }\n\n    // The closest point on the surface to the eyepoint along the view ray\n    vec4 p = eye + dist * worldDir;\n\n\n    vec3 normal = estimateNormal(p);\n\n    // Calculate polar coordinates using a vector from p to center of object\n    // c = 0,0,0 * transform so p * transform should point in the right direction\n    vec4 pc = p * transform;\n    float u = atan(pc.z, pc.x) / PI; // Latitude\n    float v = atan(pc.y, sqrt((pc.x * pc.x) + (pc.z * pc.z))) / PI; // Longitude\n    vec3 texel = checkerboard(u, v);\n\n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = color.rgb;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 20.0;\n    vec3 phong = phongIllumination(K_a, K_d, K_s, shininess, p.xyz, eye, normal);\n\n    fragColor = vec4(phong.rgb * texel, 1.0);\n    if (color.a == 1.0) {\n        fragColor = vec4(fragColor.rgb + color.rgb, 1.0); // color.a is EMISSIVE yes/no\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtXXWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtXXWS", "name": "raySoftShadow", "author": "Taron", "description": "testing soft shadows, anti aliasing and id based shading...\n...so much I still have to learn again. Awesome! ^^\nadded a bit of noise to the tiles...getting slow.", "tags": ["raycast", "shadow"], "likes": 3, "viewed": 173, "date": "1564081902", "time_retrieved": "2024-06-20T19:41:54.510078", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 40.\n#define SURF_DIST .01\n\n#define AA 2\n\nfloat jumpY;\nfloat time; \n\nfloat noise(vec2 nv)\n{\n    vec2 qv = nv.xy*85.;\n    vec2 fv = fract(qv);\n    qv = (qv-fv);\n    float dta = fract(sin(dot(qv.xy \t\t\t  ,vec2(1369.34,3369.19))*2.36) * 43758.5453);\n    float dtb = fract(sin(dot(qv.xy+vec2(1.0,0.0) ,vec2(1369.34,3369.19))*2.36) * 43758.5453);\n    float dtc = fract(sin(dot(qv.xy+vec2(0.0,1.0) ,vec2(1369.34,3369.19))*2.36) * 43758.5453);\n    float dtd = fract(sin(dot(qv.xy+vec2(1.0,1.0) ,vec2(1369.34,3369.19))*2.36) * 43758.5453);\n    float value = mix(mix(dta,dtb,fv.x),mix(dtc,dtd,fv.x),fv.y);\n    return value;\n}\n\nvec2 getDist(vec3 p)\n{\n    vec4 s = vec4(0., jumpY, 6., 1.);\n    float sphereDist = length(p-s.xyz)-s.w;\n    float id = 0.;\n    \n    vec3 rotx = vec3(sin(time), 0., cos(time));\n    vec3 rotz = vec3(-rotx.z, 0., rotx.x);\n    vec3 roty = cross(rotz, rotx);\n    vec3 qr = p-(vec3(0.,s.y,6.));\n    qr = vec3(qr.x*rotx.x + qr.y*roty.x + qr.z*rotz.x,\n              qr.x*rotx.y + qr.y*roty.y + qr.z*rotz.y,\n              qr.x*rotx.z + qr.y*roty.z + qr.z*rotz.z);\n    vec3 bs = vec3(0.6);\n    vec3 q = abs(qr)-bs;\n    float boxDist = min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n    \n    //there has to be a nicer way of making a grid with bevel...(shame!)\n    float planeDist = p.y;\n    float panel = 0.;\n    float fade = 2.-min(length(p),8.)/16.;\n    if(fade>0.)\n    {\t\n        panel = max(0.9,max(abs(-1.+2.*mod(p.x,.5)),abs(-1.+2.*mod(p.z,.5))))-.9;\n    \tpanel = panel*panel+.0025*noise(p.xz);\n     \tplaneDist = mix(p.y,p.y+.95,panel*fade);\n    }\n    \n    float item = mix(sphereDist,boxDist,0.5+.5*sin(time*0.33));\n    float d = min(item, planeDist);\n    if(d<planeDist)\n        id = 1.;\n    return vec2(d, id);\n}\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    float dO =0.;\n    \n    for(int i=0; i<MAX_STEPS; i++)\n    {\n\t\tvec3 p = ro + rd*dO;\n        float dS = getDist(p).x;\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n            break;\n        \n    }\n    return dO;\n}\nfloat shadowMarch(vec3 ro, vec3 rd)\n{\n    float dO =0.;\n    float res = 1.;\n    float dS =0.;\n    for(int i=0; i<MAX_STEPS; i++)\n    {\n        if(dO>MAX_DIST)\n            break;\n\t\tvec3 p = ro + rd*dO;\n        dS = getDist(p).x;\n        dO += dS;\n        if(dS<SURF_DIST) \n            return 0.;\n        res = min(res, 8.*dS/dO);\n    }\n         \n    return res;\n}\nvec4 getNormal(vec3 p)\n{\n    vec2 item= getDist(p);\n    float d = item.x;\n    \n    vec2 e = vec2(.01, 0.);\n    vec3 n = d - vec3(\tgetDist(p-e.xyy).x,\n                 \t\tgetDist(p-e.yxy).x,\n                 \t\tgetDist(p-e.yyx).x);\n    return vec4(normalize(n), item.y);\n}\nvec3 getLight(vec3 lightPos, vec3 p, vec3 rd)\n{\n    lightPos.xz += vec2(sin(time)*2., 1.+cos(time))*4.;\n    vec3 l = normalize(lightPos-p);\n    vec4 item = getNormal(p);\n    vec3 n = item.xyz;\n    \n    float dif = dot(n,l);\n    float sub = max(0.,.5+.5*dif);\n    dif = max(0.,dif);\n    \n    float d = shadowMarch(p+n*SURF_DIST*2., l);\n    d = sqrt(d);\n    dif *=d;\n    vec3 col = vec3(dif)+(vec3(.6,.1,.0)-vec3(dif))*(d*.1);//little attenuation is pretty!\n    if(item.w==1.)\n    {\n        \n        col*=vec3(0.71, 0.9, 0.92);\n        col += pow(sub,2.)*vec3(0.95,0.61,0.38);\n    }\n    else\n    {    \n        vec2 l = mod(p.xz,.5);\n        col*=mix(vec3(0.84, 0.88, 0.89),vec3(0.24, 0.28, 0.19),l.x>.46 || l.y>.46?1.0:0.);\n    }\n    if(dif>0.)\n    {\n        float spec = pow( max(0.,dot(l, reflect(rd, n))), 100.);\n        col +=vec3(.45*spec);\n    }\n    \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    float mTime = iTime+ mouse.x*8.;\n    \n    vec3 all = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        \n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = 0.5*(-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n    \t\n    \tuv *=1.+.2*pow(dot(uv,uv),2.);      \n        float ad = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        time = mTime - 0.5*(1.0/30.0)*(float(m*AA+n)+ad)/float(AA*AA-1);\n#else    \n        vec2 uv = 0.5*(-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n      \tuv *=1.+.2*pow(dot(uv,uv),2.);\n      \ttime = mTime;\n#endif   \n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.,1.+mouse.y*2.7,0.);\n    vec3 rd = normalize(vec3(uv.x, uv.y-.2,1.));\n    jumpY = abs(-1.+fract(time*1.1)*2.);\n    jumpY = 2.5-2.*jumpY*jumpY; \n        \n    float d = rayMarch(ro, rd);\n    vec3 p = ro + rd*d;\n    vec3 dif = getLight(vec3(0., 5., 1.), p, rd);\n    col = mix(dif,vec3(.2,.25,.29),pow(min(1.,d*.025),.5));\n\tall +=col;        \n        \n#if AA>1\n    }\n    all /= float(AA*AA);\n#endif        \n    fragColor = vec4(all,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtXXWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtXXWX", "name": "power alive goldfish kindly flap", "author": "Hirai_worthless", "description": " ", "tags": ["raymarching"], "likes": 4, "viewed": 102, "date": "1564457435", "time_retrieved": "2024-06-20T19:41:54.510078", "image_code": "float XOR (float a,float b){\n\tfloat tmp1 = max(a,b);\n    float tmp2 = min(a,b);\n    return max(tmp2,-tmp1);\n    \n}\nfloat map(vec3 p){\n\tp.xy *= mat2(cos(iTime),-sin(iTime),sin(iTime),cos(iTime));\n\tp = fract(p);\n    float s  = length(p - vec3(0.5)) - 0.25;\n    float po = min(min(length(p.xy - vec2(0.5)) - 0.1,length(p.yz - vec2(0.5)) - 0.1),length(p.xz - vec2(0.5)) - 0.1);\n    return min(s,po);\n}\n\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 96; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return vec4(getNormal(p),t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 R = iResolution,\n    r = normalize(vec3((2.*U - R.xy )/  R.y,1.0)),\n    o = vec3(0,0,-1.5 + iTime * 2.0);\n    vec4 data = trace(o,r);\n    vec3 n = vec3(data.xyz);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.2);\n    vec3 fc = t > 10000.0 ? vec3(0.8) : mix((vec3(data.x,data.y,data.z) + 1.0)/1.5\n                                            ,vec3(0.0), - pow(dot(n,r),1.0));\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtXXWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
