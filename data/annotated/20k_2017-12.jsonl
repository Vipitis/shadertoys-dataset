{"id": "4l2Bzh", "name": "Some simple ray tracing", "author": "alijaya", "description": "Some simple ray tracing template", "tags": ["raytrace"], "likes": 1, "viewed": 475, "published": "Public API", "date": "1514583240", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Ray {\n    vec3 o; // origin\n    vec3 d; // direction, always normalized\n};\n\nstruct Camera {\n\tvec3 pos;\n    vec3 lookAt;\n    float focal;\n    vec2 sensorSize;\n};\n\n// get corresponding ray from uv (0.0 -> 1.0)\nRay getRay( Camera cam, vec2 uv ) {\n    vec3 camDir = normalize(cam.lookAt - cam.pos); // the camera direction\n    vec3 center = cam.pos + cam.focal * camDir; // get the coordinate of the screen center\n    vec2 coord = (uv - 0.5) * cam.sensorSize; // convert from 0.0 -> 1.0 to -sensorSize / 2. -> sensorSize / 2.\n    \n    // axis relative to camera\n    vec3 zpos = -camDir; // k hat, outward the screen\n    vec3 xpos = cross(vec3(0., 1., 0.), zpos); // i hat, cross from ypos global and zpos local\n    vec3 ypos = cross(zpos, xpos); // j hat, cross from zpos local and xpos local\n    \n    // target in screen\n    vec3 target = center + coord.x * xpos + coord.y * ypos; // get pixel target coordinate from the screen\n    \n    Ray ray;\n    ray.o = cam.pos; // the origin of the ray is from the camera duh\n    ray.d = normalize(target - cam.pos); // the direction is from the camera to the target\n    \n    return ray;\n}\n\n// project point to ray\nvec3 projPoint2Ray( vec3 point, Ray ray ) {\n    vec3 rel = point - ray.o; // get relative vector from the point to the ray origin\n    float len = dot(rel, ray.d); // project that vector to vector direction of the ray, we get the length\n    return len * ray.d + ray.o; // multiply the length with unit vector direction and add to ray origin\n}\n\n// get the distance from point to ray (or line)\nfloat distPoint2Ray( vec3 point, Ray ray ) {\n    vec3 proj = projPoint2Ray(point, ray); // project it first to the ray\n    return distance(proj, point); // get the distance from the projected position to the original position\n}\n\n// just linear interpolation, map value v between fromA and fromB to between toA and toB\nfloat lerp( float v, float fromA, float fromB, float toA, float toB ) {\n    return (v - fromA) / (fromB - fromA) * (toB - toA) + toA;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // convert from fragCoord (0.0 -> iResolution.xy) to uv (0.0 -> 1.0)\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 circleMovement = vec3(300. * cos(iTime), 0., 300. * sin(iTime)); // to get circle movement\n    \n    // set camera\n    Camera cam;\n    cam.sensorSize = iResolution.xy; // set sensor size to the screenSize\n    cam.focal = 100.; // set the focal length (distance between sensor (screen) to the aperture\n    cam.lookAt = vec3(0., 0., 0.); // where to look at (this camera use two point system)\n    cam.pos = circleMovement; // the position of the camera\n    \n    // get ray\n    Ray ray = getRay(cam, uv); // get corresponding ray, given the uv\n    \n    // create 8 points of cube\n    vec3 points[8];\n    for (int i=0; i<2; i++) {\n        for (int j=0; j<2; j++) {\n            for (int k=0; k<2; k++) {\n                points[i*4+j*2+k] = vec3(float(i) * 2. - 1., float(j) * 2. - 1., float(k) * 2. - 1.);\n            }\n        }\n    }\n    \n    // render the points\n    fragColor = vec4(0.);\n    float size = 100.;\n    float pointSize = 10.;\n    for (int i=0; i<8; i++) {\n        float value = smoothstep(pointSize * 1.2, pointSize, distPoint2Ray(points[i] * size, ray));\n        fragColor = mix(fragColor, vec4(value), value);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2Bzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 215, 250, 250, 1132], [1134, 1158, 1201, 1201, 1499], [1501, 1549, 1593, 1593, 1776], [1778, 1867, 1938, 1938, 2002], [2004, 2004, 2061, 2134, 3320]], "test": "untested"}
{"id": "4lfBD7", "name": "Star Organic", "author": "uzpei", "description": "Organic star-shaped creature", "tags": ["procedural"], "likes": 1, "viewed": 62, "published": "Public", "date": "1512235752", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision mediump float;\n\n#define feather 0.01\n#define PI 3.14159\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat disk(vec2 p, vec2 c, float r) {\n\treturn 1.0-smoothstep(r*feather, r, dot(p-c,p-c));\n}\n\nfloat spindle(vec2 p, vec2 c, float r, float theta) {\n\tvec2 dir = 0.005*vec2(sin(theta), -cos(theta)); // arm direction\n    const int l = 150; // arm length\n\tfloat dr = 0.975; // arm growth along length\n\n    float accum = 0.0;\n\tfor (int i = 0; i < l; i++) {\n\t\taccum += disk(p, c, r);\n\t\tdir += 0.001*(-0.5+rand(c));\n\t\tc += dir;\n\t\tr = dr*r;\n\t}\n\n\treturn 0.1 * accum;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Center\n\tvec2 p = (fragCoord.xy*2.-iResolution.xy)/iResolution.y + 0.01 * vec2(sin(rand(fragCoord.xy)));\n\n\t// Parameters\n\tvec2 c = vec2(0.,0.); // disk center\n    float ts = 0.2; // time stretch\n\tfloat r = 0.001 + 0.01*abs(sin(iTime * ts)) * abs(sin(1.0 + 2.0 * iTime * ts)) * abs(sin(2.0 + 3.0 * iTime * ts)); // arm radius\n    const int n = 5; // arm count\n\n    // Draw\n\tfloat d = 0.0;\n\tfor (int i = 2; i <= n + 1; i++) {\n\t\td += spindle(p, c, r, 2.0 * PI * float(i)/float(n) + 0.000001 * iTime);\n\t}\n\tfragColor = vec4(vec3(d), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lfBD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 87, 87, 159], [161, 161, 198, 198, 252], [254, 254, 307, 307, 619], [621, 621, 676, 688, 1216]], "test": "untested"}
{"id": "4lfBDs", "name": "Basic_MovingSin", "author": "PaperColor", "description": "sin wave", "tags": ["sinwave"], "likes": 0, "viewed": 391, "published": "Public API", "date": "1513833806", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float count = 10.0;\nfloat pi = 3.141592654;\nfloat tao = 2.0*pi;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t//fragColor = vec4( col, 1.0 );\n\t//float value = sin(uv.x*10.0*);\n\t\n    //fragColor = vec4(value,value,value,1);\n\t//fragColor = texture(iChannel0,uv*10.0);\n\tvec2 scaleduv = uv*count;\n    float verticalValue = sin(uv.x*count*tao+iTime);\n    //float horiaontalValue = sin(scaleduv.y);\n    \n    fragColor = vec4(verticalValue,verticalValue,verticalValue,1.0);\n    //fragColor = vec4(uv.x,uv.x,uv.x,1.0);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lfBDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 122, 122, 570]], "test": "untested"}
{"id": "4lfBRX", "name": "SlimePatternZoom", "author": "Del", "description": "sinmagic", "tags": ["slime"], "likes": 0, "viewed": 71, "published": "Public", "date": "1512584709", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// um, some kind of mystical hole...?\nfloat glint(vec2 p)\n{\n    vec2 uv = p;\n    float speed = 0.68;\n    float linewidth = 1.38;\n    float grad = 3.0;\n    vec2 linepos = uv;\n    linepos.x = linepos.x - mod(iTime*speed,4.0)+2.0;\n    float y = linepos.x*grad;\n\tfloat s = smoothstep( y-linewidth, y, linepos.y) - smoothstep( y, y+linewidth, linepos.y); \n    return s;\n}\n\nfloat _glint(vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float speed = iTime*0.2;\n \tfloat d = 1.0+p.x*0.25;\n    vec2 cst = vec2( cos(d+speed), sin(d+speed) );\n    float zoom = 1.0+(0.5*sin(iTime*0.675));\n    mat2 rot = zoom * mat2(cst.x,-cst.y,cst.y,cst.x);\n    float s = glint(p*rot*0.44);\n    return s;\n}\n\n\nvoid mainImage(out vec4 k, vec2 p)\n{\n    const vec4 col1 = vec4(0.0,.1,.1,1.0);\n    const vec4 col2 = vec4(0.5,0.9,0.3,1.0);\n    vec2 uv = p.xy / iResolution.xy;\n    float gl = _glint(p)*0.5;\n\n    float speed = iTime*0.2;\n \tfloat _fd = 1.0+uv.x*0.55;\n    vec2 cst = vec2( cos(_fd+speed), sin(_fd+speed) );\n    float zoom = 2.0+(0.5*sin(iTime*0.75));\n    mat2 rot = zoom * mat2(cst.x,-cst.y,cst.y,cst.x);\n    uv = rot*uv;\n    \n    \n    float s = sin(iTime*0.1);\n    float s2 = 0.5+sin(iTime*1.8);\n    float s3 = 0.5+sin(iTime*1.2);\n    vec2 d = uv*(9.0-s*0.9);\t\t\t\t\t\t// mod 4.0 for irregularity...\n    \n    d.x -= iTime*0.4-sin(d.y+ iTime*0.7)*0.2;\n    d.y += iTime*0.15+sin(d.x + iTime*0.3)*0.90;\t//-(s*0.5);\n    float v1=length(0.5-fract(d.xy))+0.70;\t\t\t\t// 0.9 =more gooey bits, 1.2 = less gooey bits\n\n    d = uv;\n    float v2=length(0.5-fract(d.xy))-0.075;\t\t// border\n    v1 *= 1.0-v2*v1;\n    v1 = v1*v1*v1;\n    v1 *= 2.9+s2*0.2;\n    k = mix(col2,col1,v1)*(3.2+(s2*0.2));\n    k *= 1.0-(v2);\n    \n    \n    if (k.g<=0.4)\n    {\n        float m = 1.0-clamp(k.g,0.0,0.5);\n\t\tfloat f = mod( floor(12.0*uv.x) + floor(12.0*uv.y), 2.0);\n        float col = 0.3 + 0.2*f*1.0;\n        k.x = k.y = k.z = col*m;\n  \t\tk.rb *= 1.2;\n    }\n    else\n    {\n\t\tfloat f = mod( floor(12.0*uv.x) + floor(12.0*uv.y), 2.0);\n        vec4 _col = 0.2*f*vec4(0.175);\n        k+=_col;\n    }\n    // glint\n    k *=vec4(1.0+gl);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lfBRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 38, 59, 59, 366], [368, 368, 399, 399, 720], [723, 723, 759, 759, 2122]], "test": "untested"}
{"id": "4lfBWB", "name": "Backlit Lighthouse", "author": "dr2", "description": "More scenery with sunbeams (mouseable)", "tags": ["waves", "clouds", "landscape", "sunbeams"], "likes": 39, "viewed": 4798, "published": "Public API", "date": "1513072682", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Backlit Lighthouse\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nfloat Fbm3s (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit, dispCloud;\nfloat dstFar, tCur, tWav, bmAng, bmHt, twBase, twRad;\nint idObj;\nconst int idTwr = 1, idWfrm = 2, idTtop = 3, idFlr = 4, idLmp = 5, idBm = 6, idGrnd = 7;\nconst float pi = 3.14159;\n\n#define TOWER_DIAM  (twRad - (0.05 + 0.25 * (step (q.y, - twBase))) * (q.y + twBase))\n\nfloat ObjDf (vec3 p)\n{\n  vec4 vc;\n  vec3 q;\n  float dMin, d, a, r, h, db, dw, ww;\n  dMin = dstFar;\n  q = p;  q.y -= twBase + 4.;\n  r = TOWER_DIAM;\n  d = PrCylAnDf (q.xzy, r, 0.2, 8.);\n  dw = PrCylAnDf (q.xzy, r + 0.1, 0.3, 8.);\n  db = 6. - abs (q.y - 2.);\n  a = (length (q.xz) > 0.) ? atan (q.z, - q.x) : 0.;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (5. * a / (2. * pi) + 0.5) / 5.));\n  q.y = mod (q.y + 1.2, 3.) - 1.5;\n  ww = 0.5;\n  d = 0.9 * max (d, - max (min (PrBox2Df (q.zy, vec2 (ww)), length (vec2 (q.z, q.y - ww)) - ww), - db));\n  if (d < dMin) { dMin = d;  idObj = idTwr; }\n  dw = 0.9 * max (dw, max (- db, max (min (PrBox2Df (q.zy, vec2 (ww + 0.05)),\n     length (vec2 (q.z, q.y - ww - 0.05)) - ww - 0.05), - min (PrBox2Df (q.zy, vec2 (ww - 0.05)),\n     length (vec2 (q.z, q.y - ww + 0.05)) - ww + 0.05))));\n  if (dw < dMin) { dMin = dw;  idObj = idWfrm; }\n  q.y = mod (p.y - 5.5, 3.) - 1.5;\n  d = max (PrCylDf (q.xzy, twRad - 0.4, 0.05), - db);\n  if (d < dMin) { dMin = d;  idObj = idFlr; }\n  q = p;  q.y -= bmHt;\n  d = PrCylAnDf (q.xzy, twRad - 0.5, 0.2, 1.);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (20. * a / (2. * pi) + 0.5) / 20.));\n  d = max (d, - PrBox2Df (q.zy, vec2 (0.3, 0.75)));\n  q = p;  q.y = abs (q.y - bmHt) - 1.1;\n  d = min (d, PrCylDf (q.xzy, twRad + 0.1, 0.1));\n  if (d < dMin) { dMin = d;  idObj = idTtop; }\n  q = p;  q.y -= bmHt;\n  q.xz = Rot2D (q.xz, bmAng);\n  d = PrCylAnDf (q, 0.8, 0.03, 0.21);\n  if (d < dMin) { dMin = d;  idObj = idLmp; }\n  d = PrCylDf (q, 0.77, 0.2);\n  if (d < dMin) { dMin = d;  idObj = idBm; }\n  if (PrCylDf ((p + vec3 (0., -2., 0.)).xzy, 10., 2.) < dMin) {\n    vc = HexVor (0.5 * p.xz);\n    h = 1.5 * max (SmoothMin (0.6, SmoothMax (0., vc.x, 0.6), 0.3) *\n       (1. + vc.w) * (1. - dot (vc.yz, vc.yz)), 0.) + 3.;\n    d = 0.5 * (p.y - h * (1. - 0.01 * dot (p.xz, p.xz)));\n    if (d < dMin) { dMin = d;  idObj = idGrnd; }\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0005, -0.0005);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat TransObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;  q.y -= 8.;\n  d = PrCylDf (q.xzy, TOWER_DIAM, 8.);\n  q.y -= 9.;\n  d = min (d, PrCylDf (q.xzy, twRad - 0.5, 1.));\n  dMin = min (dMin, d);\n  return dMin;\n}\n\nfloat TransObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 60; j ++) {\n    d = TransObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 TransObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0005, -0.0005);\n  v = vec4 (TransObjDf (p + e.xxx), TransObjDf (p + e.xyy), TransObjDf (p + e.yxy), TransObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  vec4 t4, v4;\n  vec2 q, t, tw;\n  float wFreq, wAmp, h;\n  q = 0.5 * p + vec2 (0., tCur);\n  h = 0.6 * sin (dot (q, vec2 (-0.05, 1.))) + 0.45 * sin (dot (q, vec2 (0.1, 1.2))) +\n     0.3 * sin (dot (q, vec2 (-0.2, 1.4)));\n  q = p;\n  wFreq = 1.;\n  wAmp = 1.;\n  tw = tWav * vec2 (1., -1.);\n  for (int j = 0; j < 3; j ++) {\n    q *= qRot;\n    t4 = q.xyxy * wFreq + tw.xxyy;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    v4 = (1. - abs (sin (t4))) * (abs (sin (t4)) + abs (cos (t4)));\n    t = 1. - sqrt (v4.xz * v4.yw);\n    t *= t;\n    t *= t;\n    h += wAmp * dot (t, t);\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return h;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec3 vn;\n  vec2 e;\n  e = vec2 (max (0.01, 0.005 * d * d), 0.);\n  p *= 0.5;\n  vn.xz = 0.5 * (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy),  WaveHt (p.xz + e.yx)));\n  vn.y = e.x;\n  return normalize (vn);\n}\n\nvec3 CloudCol (vec3 ro, vec3 rd)\n{\n  vec3 p, q, clCol, col, colS;\n  float fCloud, cloudLo, cloudRngI, atFac, colSum, attSum, s, att, a, sd, ds;\n  const int nLay = 60;\n  cloudLo = 300.;  cloudRngI = 1./300.;  atFac = 0.015;\n  fCloud = 0.7;\n  colS = mix (vec3 (0.7, 0.75, 1.), vec3 (0.4, 0.38, 0.38), 1. - max (rd.y, 0.));\n  col = colS;\n  if (rd.y > 0.) {\n    fCloud = clamp (fCloud, 0., 1.);\n    p = ro + dispCloud;\n    p.xz += (cloudLo - p.y) * rd.xz / rd.y;\n    p.y = cloudLo;\n    ds = 1. / (cloudRngI * rd.y * (2. - rd.y) * float (nLay));\n    colSum = 0.;\n    attSum = 0.;\n    s = 0.;  \n    att = 0.;\n    for (int j = 0; j < nLay; j ++) {\n      q = p + s * rd;\n      att += atFac * max (fCloud - Fbm3 (vec3 (3., 4., 3.) * 0.003 * q), 0.);\n      a = (1. - attSum) * att;\n      colSum += a * (q.y - cloudLo) * cloudRngI;\n      attSum += a;\n      s += ds;\n      if (attSum > 0.95) break;\n    }\n    sd = max (dot (rd, sunDir), 0.);\n    colSum += min ((1. - attSum) * pow (sd, 3.), 1.);\n    clCol = vec3 (0.9, 0.9, 1.) * (1.3 * colSum + 0.1);\n    col = clamp (mix (colS + vec3 (0.4) * (pow (sd, 8.) + 0.5 * pow (sd, 512.)), clCol, attSum), 0., 1.);\n    col = mix (col, colS, pow (1. - rd.y, 32.));\n  }\n  return col;\n}\n\nfloat CloudDens (vec3 ro, vec3 rd)\n{\n  vec3 p, q;\n  float fCloud, cloudLo, cloudRngI, atFac,  attSum, s, att, a, ds;\n  const int nLay = 60;\n  cloudLo = 300.;  cloudRngI = 1./300.;  atFac = 0.018;\n  fCloud = 0.7;\n  if (rd.y > 0.) {\n    fCloud = clamp (fCloud, 0., 1.);\n    p = ro + dispCloud;\n    p.xz += (cloudLo - p.y) * rd.xz / rd.y;\n    p.y = cloudLo;\n    ds = 1. / (cloudRngI * rd.y * (2. - rd.y) * float (nLay));\n    attSum = 0.;\n    s = 0.;  \n    att = 0.;\n    for (int j = 0; j < nLay; j += 6) {\n      q = p + s * rd;\n      att += atFac * max (fCloud - Fbm3s (vec3 (3., 4., 3.) * 0.003 * q), 0.);\n      a = (1. - attSum) * att;\n      attSum += a;\n      s += ds;\n      if (attSum > 0.95) break;\n    }\n  } else attSum = 0.;\n  return clamp (1. - attSum, 0., 1.);\n}\n\nfloat GRayDens (vec3 ro, vec3 rd)\n{\n  vec3 p, q;\n  float d, s, ds, sd, gDens;\n  sd = 0.1 * smoothstep (0.6, 0.8, dot (rd, sunDir));\n  gDens = 0.;\n  if (sd > 0.) {\n    p = ro + 100. * rd / max (rd.y, 0.05);\n    ds = 5. / max (rd.y, 0.05);\n    s = 0.;\n    for (int j = 0; j < 16; j ++) {\n      q = p + s * rd;\n      gDens += sd * (1. - gDens) * smoothstep (0.8, 1., CloudDens (q, sunDir));\n      s += ds;\n      if (q.y > 400. || gDens > 0.95) break;\n    }\n  }\n  return gDens;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float a, g;\n  g = 1.2 * GRayDens (ro, rd);\n  a = atan (rd.x, - rd.z);\n  if (rd.y < 0.02 * Fbm1 (32. * a) + 0.005) col = mix (vec3 (0.25, 0.25, 0.27),\n     vec3 (0.3, 0.3, 0.33), 0.5 + 0.5 * dot (normalize (rd.xz), - normalize (sunDir.xz))) *\n     (1. - 0.3 * Fbm2 (128. * vec2 (a, rd.y))) + vec3 (0.3, 0.2, 0.1) * g;\n  else col = CloudCol (ro, rd) + vec3 (1., 0.8, 0.6) * g;\n  return col;\n}\n\nvec3 ShStagGrid (vec2 p, vec2 g)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.3 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vc;\n  vec3 vn, col, roo, rdo, vno, rob, rdb, rg;\n  float dstObj, dstWat, dstTransObj, a;\n  bool watRefl, winRefl, isBm;\n  HexVorInit ();\n  bmHt = 17.;\n  twBase = 4.;\n  twRad = 3.;\n  tWav = 0.2 * tCur;\n  dispCloud = tCur * vec3 (-15., 0., 5.);\n  bmAng = tCur;\n  winRefl = false;\n  watRefl = false;\n  isBm = false;\n  rob = ro;\n  rdb = rd;\n  dstObj = ObjRay (ro, rd);\n  dstWat = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  dstTransObj = TransObjRay (ro, rd);\n  if (dstWat < min (dstObj, dstFar)) {\n    watRefl = true;\n    ro += dstWat * rd;\n    vn = WaveNf (ro, dstWat);\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n  }\n  if (dstTransObj < min (dstFar, dstObj)) {\n    ro += rd * dstTransObj;\n    roo = ro;\n    rdo = rd;\n    vno = TransObjNf (ro);\n    winRefl = true;\n    dstObj = ObjRay (ro, rd);\n  }\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    if (idObj == idTwr) {\n      a = atan (ro.z, - ro.x) / (2. * pi);\n      if (ro.y > twBase) {\n        if (dot (normalize (ro.xz), vn.xz) > 0.9) {\n          col = vec3 (0.9, 0.7, 0.5);\n          col *= 0.5 + 0.5 * Fbm2 (vec2 (32. * a, 4. * ro.y));\n          rg = ShStagGrid (vec2 (a, ro.y + 0.05), vec2 (30., 3.));\n          col *= rg.y;\n          if (rg.x == 0.) {\n            vn.y += rg.z;\n            vn.xz *= sqrt (1. - vn.y * vn.y);\n          } else vn.xz = Rot2D (vn.xz, - rg.x);\n        } else col = vec3 (0.4, 0.3, 0.2);\n        vn = VaryNf (50. * ro, vn, 1.);\n      } else {\n        col = vec3 (1., 0.8, 0.2);\n        col *= 0.7 * (0.5 + 0.5 * Fbm2 (vec2 (64. * a, 4. * ro.y)));\n        vn = VaryNf (10. * ro, vn, 5.);\n      }\n    } else if (idObj == idGrnd) {\n      vc = HexVor (ro.xz);\n      vn = VaryNf (2. * ro, vn, 5.);\n      col = 0.7 * mix (vec3 (1., 0.7, 0.2), vec3 (0.9, 0.8, 0.5),\n         0.5 * Noisefv3 (8. * (1. + vc.w) * ro) + 0.5 * vc.w) * (0.7 + 0.3 * smoothstep (0., 0.4, ro.y));\n    } else if (idObj == idFlr) {\n      col = vec3 (0.5, 0.6, 0.3);\n    } else if (idObj == idWfrm) {\n      col = vec3 (0.6, 0.5, 0.4);\n      vn = VaryNf (50. * ro, vn, 1.);\n    } else if (idObj == idTtop) {\n      col = vec3 (0.8, 0.7, 0.6);\n      vn = VaryNf (50. * ro, vn, 1.);\n    } else if (idObj == idLmp) {\n      col = vec3 (0.5, 0.5, 0.6);\n    } else if (idObj == idBm) {\n      isBm = true;\n      col = 1.2 * vec3 (1., 1., 0.9) * abs (dot (rd, vn));\n    }\n    if (! isBm) {\n      col = col * (0.1 + 0.05 * max (dot (- normalize (sunDir.xz), normalize (vn.xz)), 0.) +\n         0.8 * max (dot (sunDir, vn), 0.)) + 0.05 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n      if (winRefl) col = mix (col, BgCol (roo, reflect (rdo, vno)), smoothstep (0.5, 0.95,\n            1. - pow (abs (dot (- rdo, vno)), 5.)));\n    }\n  } else if (rd.y < 0.) {\n    watRefl = true;\n    dstWat = - ro.y / rd.y;\n    ro += dstWat * rd;\n    col = BgCol (ro, reflect (rd, WaveNf (ro, dstWat)));\n  } else {\n    col = BgCol (ro, rd);\n  }\n  if (watRefl) {\n    col = mix (mix (vec3 (0.01, 0.01, 0.), vec3 (0., 0.05, 0.05),\n       smoothstep (0.4, 0.6, Fbm2 (0.5 * ro.xz))), 0.5 * col, 1. - pow (abs (rd.y), 4.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 100.;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    az = 2. * pi * (2. * mod (floor (0.01 * tCur), 2.) - 1.) *\n       SmoothBump (0.25, 0.75, 0.1, mod (0.01 * tCur, 1.));\n  }\n  el = clamp (el, -0.2 * pi, -0.01 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  zmFac = 4.5 - 0.8 * cos (2. * az);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ro = vuMat * vec3 (0., 8., -70.);\n  sunDir = normalize (vec3 (0.1, 0.5, 1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nvec2 gVec[7], hVec[7];\n#define SQRT3 1.7320508\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3s (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.75);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);  \n  a = 1.;\n  for (int i = 0; i < 4; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;  \n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lfBWB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 995, 1017, 1017, 2890], [2892, 2892, 2925, 2925, 3102], [3104, 3104, 3125, 3125, 3325], [3327, 3327, 3354, 3354, 3561], [3563, 3563, 3601, 3601, 3782], [3784, 3784, 3810, 3810, 4030], [4032, 4032, 4055, 4055, 4751], [4753, 4753, 4784, 4784, 4988], [4990, 4990, 5024, 5024, 6204], [6206, 6206, 6242, 6242, 6974], [6976, 6976, 7011, 7011, 7451], [7453, 7453, 7484, 7484, 7889], [7891, 7891, 7925, 7925, 8279], [8281, 8281, 8316, 8316, 11461], [11463, 11463, 11519, 11519, 12475], [12477, 12477, 12510, 12510, 12599], [12601, 12601, 12643, 12643, 12694], [12696, 12696, 12749, 12749, 12810], [12860, 12860, 12884, 12884, 13114], [13116, 13116, 13140, 13140, 13200], [13202, 13202, 13222, 13222, 13442], [13444, 13444, 13466, 13466, 14062], [14064, 14064, 14109, 14109, 14212], [14214, 14214, 14259, 14259, 14297], [14299, 14299, 14356, 14356, 14439], [14441, 14441, 14471, 14471, 14529], [14563, 14563, 14587, 14587, 14647], [14649, 14649, 14673, 14673, 14726], [14728, 14728, 14752, 14752, 14882], [14884, 14884, 14908, 14908, 15128], [15130, 15130, 15155, 15155, 15301], [15303, 15303, 15328, 15328, 15514], [15516, 15516, 15541, 15541, 15766], [15768, 15768, 15790, 15790, 15944], [15946, 15946, 15967, 15967, 16122], [16124, 16124, 16145, 16145, 16300], [16302, 16302, 16324, 16324, 16477], [16479, 16479, 16508, 16508, 16724], [16726, 16726, 16765, 16765, 16945]], "test": "untested"}
{"id": "4lfBWf", "name": "Wireframe cube", "author": "rkibria", "description": "A wireframe cube modeled as vertices and edges is scaled, rotated and translated in homogeneous 3D coordinates, then a perspective matrix is applied and the 2D lines drawn.", "tags": ["3d", "cube", "wireframe"], "likes": 9, "viewed": 792, "published": "Public", "date": "1513550933", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float segment(vec2 u, vec2 a, vec2 b)  {         \n    b -= a, u -= a;\n    return length( u - b * clamp(dot(b, u) / dot(b, b), 0., 1.));\n}\n\nvoid lineTo(in vec2 uv, inout vec4 fragColor, in vec2 a, in vec2 b, in float w) {\n    float s = segment(uv, a, b);\n    s = 1. - smoothstep(0., 1., s * w);\n    fragColor = max(fragColor, vec4(s));\n}\n\n// unit cube with lower left and front corner at origin\n#define N_VERTICES 8\nconst vec4 vertices[N_VERTICES] = vec4[](\n\tvec4(0., 0., 0., 1.),\n\tvec4(1., 0., 0., 1.),\n\tvec4(1., 1., 0., 1.),\n\tvec4(0., 1., 0., 1.),\n\n\tvec4(0., 0., 1., 1.),\n\tvec4(1., 0., 1., 1.),\n\tvec4(1., 1., 1., 1.),\n\tvec4(0., 1., 1., 1.)\n\t);\n\nconst ivec2 edges[12] = ivec2[](\n    ivec2(0, 1),\n    ivec2(1, 2),\n    ivec2(2, 3),\n    ivec2(3, 0),\n\n    ivec2(4, 5),\n    ivec2(5, 6),\n    ivec2(6, 7),\n    ivec2(7, 4),\n\n    ivec2(0, 4),\n    ivec2(1, 5),\n    ivec2(2, 6),\n    ivec2(3, 7)\n    );\n\n// Each matrix line is a COLUMN not a row\nmat4 scaleMatrix(in vec3 v) {\n\treturn mat4(\n        v.x,          0.0,            0.0,            0.0,\n        0.0,          v.y,            0.0,            0.0,\n        0.0,          0.0,            v.z,            0.0,\n        0.0,          0.0,            0.0,            1.0\n    \t);\n}\n\nmat4 translateMatrix(in vec3 v) {\n\treturn mat4(\n        1.0,          0.0,            0.0,            0.0,\n        0.0,          1.0,            0.0,            0.0,\n        0.0,          0.0,            1.0,            0.0,\n        v.x,          v.y,            v.z,            1.0\n        );\n}\n\nmat4 rotXMatrix(in float phi) {\n    float cos_phi = cos(phi);\n    float sin_phi = sin(phi);\n    return mat4(\n\t    1.0,          0.0,            0.0,            0.0,\n\t    0.0,          cos_phi,        sin_phi,        0.0,\n\t    0.0,          -sin_phi,       cos_phi,        0.0,\n\t    0.0,          0.0,            0.0,            1.0\n    \t);\n}\n\nmat4 rotYMatrix(in float phi) {\n    float cos_phi = cos(phi);\n    float sin_phi = sin(phi);\n    return mat4(\n\t    cos_phi,      0.0,            -sin_phi,       0.0,\n\t    0.0,          1.0,            0.0,            0.0,\n\t    sin_phi,      0.0,            cos_phi,        0.0,\n\t    0.0,          0.0,            0.0,            1.0\n    \t);\n}\n\nmat4 rotZMatrix(in float phi) {\n    float cos_phi = cos(phi);\n    float sin_phi = sin(phi);\n    return mat4(\n\t    cos_phi,      sin_phi,        0.0,            0.0,\n\t    -sin_phi,     cos_phi,        0.0,            0.0,\n\t    0.0,          0.0,            1.0,            0.0,\n\t    0.0,          0.0,            0.0,            1.0\n    \t);\n}\n\nmat4 perspectiveMatrix() {\n    const float S = 1.0;\n    const float f = 1.0;\n    const float n = 0.1;\n    return mat4(\n\t    -S,            0.0,            0.0,            0.0,\n\t    0.0,          -S,              0.0,            0.0,\n\t    0.0,          0.0,            -(f+n)/(f-n),   -1.0,\n\t    0.0,          0.0,            -2.*f*n/(f-n),   0.0\n    \t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(0);\n    \n    vec2 uv = fragCoord.xy / iResolution.x;\n    uv += vec2(-0.5, -iResolution.y / iResolution.x / 2.);\n\n    float t = iTime * 0.5;\n    mat4 mtx = perspectiveMatrix() \n        * translateMatrix(\n            vec3(sin(t+1.)*0.07, \n                sin(t+2.)*0.02, \n                0.2+sin(t+3.)*0.2))\n        * scaleMatrix(vec3(0.05)) \n        * rotZMatrix(t) \n        * rotYMatrix(t) \n        * rotXMatrix(t) \n        * translateMatrix(vec3(-0.5));\n    \n    vec4 transVertices[N_VERTICES];\n    for (int i = 0; i < N_VERTICES; i++) {\n        transVertices[i] = mtx * vertices[i];\n    }\n    \n    for (int i = 0; i < edges.length(); i++) {\n        ivec2 edge = edges[i];\n        vec4 A = transVertices[edge.x];\n        vec4 B = transVertices[edge.y];\n        float Az = A.z;\n        float Bz = B.z;\n        float width = abs(Az+Bz)*200.0;\n        lineTo(uv, \n               fragColor,\n               vec2(A.x/Az, A.y/Az), \n               vec2(B.x/Bz, B.y/Bz),\n               width\n              );\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lfBWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 137], [139, 139, 220, 220, 336], [892, 934, 963, 963, 1222], [1224, 1224, 1257, 1257, 1519], [1521, 1521, 1552, 1552, 1862], [1864, 1864, 1895, 1895, 2205], [2207, 2207, 2238, 2238, 2548], [2550, 2550, 2576, 2576, 2905], [2907, 2907, 2964, 2964, 3991]], "test": "untested"}
{"id": "4lfBzj", "name": "Inversions", "author": "mla", "description": "12 spheres in an icosahedral arrangement, inverted in a sphere.\n\nThe mouse controls the centre of inversion.", "tags": ["spheres", "raytrace", "inversion"], "likes": 5, "viewed": 596, "published": "Public API", "date": "1512425931", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Ray {\n  vec3 q;               // origin\n  vec3 d;               // direction\n};\n\nstruct Hit {\n  float t;      // solution to p=q+t*d\n  vec3 n;       // normal\n  vec3 color;\n};\n\nstruct Sphere {\n  float r2;      // radius squared\n  vec3 p;       // centre\n  vec3 color;\n};\n\nbool invert = true;\n\nSphere invertSphere(Sphere s) {\n  // Use mouse position to determine centre of inversion (for x and y)\n  vec3 icentre = vec3(0.5,0.0,-1.25);\n  // On startup iMouse.x = iMouse.y = 0\n  if (iMouse.x > 0.0) {\n      icentre = vec3(3.0*(iMouse.x-0.5*iResolution.x)/iResolution.x,\n                      3.0*(iMouse.y-0.5*iResolution.y)/iResolution.y,\n                      -1.25);\n    }\n  // Shift origin to sphere centre\n  vec3 p = s.p - icentre;\n  float r2 = s.r2;\n  float c = dot(p,p);\n  // This inverts the sphere (in the origin).\n  float k = 1.0/(c-r2);\n  // Shift back\n  return Sphere(r2*k*k, p*k+icentre, s.color);\n}\n\nbool intersectSphere(Sphere s, Ray ray, out Hit hit) {\n  vec3 p = s.p;\n  float r2 = s.r2;\n  float c2 = dot(p,p);\n  vec3 q = ray.q, d = ray.d;\n  // |q + t*d - p|^2 = r^2\n  float B = dot(q-p,d);\n  float C = dot(q,q)-2.0*dot(q,p)+c2-r2;\n  float D = B*B - C;\n  if (D < 0.0) return false;\n  D = sqrt(D);\n  float t,t1;\n  if (B >= 0.0) {\n    t = -B-D; t1 = C/t;\n  } else {\n    t1 = -B+D; t = C/t1;\n  }\n  if (t < 0.0) t = t1;\n  if (t < 0.0) return false;\n  // Normal is the radial vector of sphere\n  hit = Hit(t, q+t*d-p, s.color);\n  return true;\n}\n\nvec3 vertices[12];\nint colors[12];\nvoid setVertices() {\n  float phi = 0.80902;\n  // Three golden rectangle, oriented to\n  // the three axes. \n  vertices[0] = vec3( 0.5, phi,0); //++0 A\n  vertices[1] = vec3( 0.5,-phi,0); //+-0 B\n  vertices[2] = vec3(-0.5, phi,0); //-+0 C\n  vertices[3] = vec3(-0.5,-phi,0); //--0 D\n\n  vertices[4] = vec3(0, 0.5, phi); //0++ B\n  vertices[5] = vec3(0, 0.5,-phi); //0+- D\n  vertices[6] = vec3(0,-0.5, phi); //0-+ C\n  vertices[7] = vec3(0,-0.5,-phi); //0-- A\n\n  vertices[8]  = vec3( phi,0, 0.5); //+0+ D\n  vertices[9]  = vec3( phi,0,-0.5); //+0- C\n  vertices[10] = vec3(-phi,0, 0.5); //-0+ A\n  vertices[11] = vec3(-phi,0,-0.5); //-0- B\n\n  // A nice 4-coloring of icosahedron vertices\n  colors[0] = colors[7] = colors[10] = 0;\n  colors[1] = colors[4] = colors[11] = 1;\n  colors[2] = colors[6] = colors[9] = 2;\n  colors[3] = colors[5] = colors[8] = 3;\n}\n\nvec3 getColor(int i) {\n  if (i == 0) return vec3(1,0,0);\n  if (i == 1) return vec3(1,1,0);\n  if (i == 2) return vec3(0,1,0);\n  if (i == 3) return vec3(0,0,1);\n  return vec3(1,1,1);\n}\n\nbool intersectScene(Ray r, out Hit hit) {\n  float t = 0.5*iTime;\n  mat3 m = mat3(cos(t),0,sin(t),\n                0,1,0,\n                -sin(t),0,cos(t));\n  setVertices();\n  bool found = false;\n  for (int i = 0; i < 12; i++) {\n    Sphere s = Sphere(0.25, m*vertices[i], getColor(colors[i]));\n    Hit hits;\n    if (invert) s = invertSphere(s);\n    if (intersectSphere(s,r,hits) && (!found || hits.t < hit.t)) {\n      hit = hits;\n      found = true;\n    }\n  }\n  return found;\n}\n\nvec3 light;\nfloat ambient;\nfloat diffuse;\n\nvec4 solve(Ray r) {\n  Hit hit;\n  if (!intersectScene(r,hit)) {\n    return vec4(0,0,0,1);\n  } else {\n    vec3 n = normalize(hit.n);\n    if (dot(r.d,n) > 0.0) n *= -1.0;\n    vec3 baseColor = hit.color;\n    vec3 color = baseColor.xyz*(ambient+diffuse*max(0.0,dot(light,n)));\n    float specular = pow(max(0.0,dot(reflect(light,n),r.d)),5.0);\n    color += 0.5*specular*vec3(1.0,1.0,1.0);\n    color *= clamp(1.0 - (hit.t-3.0)/5.0,0.0,1.0);\n    return vec4(sqrt(color),1.0);\n  }\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord,\n             in vec3 fragRayOrigin, in vec3 fragRayDir) {\n  fragColor = solve(Ray(fragRayOrigin,fragRayDir));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = normalize(vec3(0.5,1.0,-1.0));\n  ambient = 0.5;\n  diffuse = 1.0-ambient;\n  vec2 uv = 2.0*fragCoord.xy/iResolution.xy - 1.0;\n  vec3 p = vec3(0,0,-6.0);\n  // \"screen\" coordinate\n  vec3 s = vec3(iResolution.x/iResolution.y * uv.x, uv.y, 0);\n  vec3 d = normalize(s-p); // Direction from camera to screen point\n  mainVR(fragColor,fragCoord,p,d);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lfBzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[300, 300, 331, 402, 916], [918, 918, 972, 972, 1458], [1495, 1495, 1515, 1515, 2339], [2341, 2341, 2363, 2363, 2523], [2525, 2525, 2566, 2566, 3001], [3046, 3046, 3065, 3065, 3519], [3521, 3521, 3630, 3630, 3684], [3687, 3687, 3744, 3744, 4097]], "test": "untested"}
{"id": "4lfBzX", "name": "Circle_bullshit2", "author": "lookezen", "description": "learning stuff", "tags": ["beginner"], "likes": 0, "viewed": 100, "published": "Public", "date": "1512593282", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool cirOL(vec2 center, float rad)\n{\n    return(length(center) < rad);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 col1 = vec4( 0., 0.4, 1., 1.);\n    vec4 col2 = vec4( 0., 0.2, 1., 1.);\n    vec4 col3 = vec4( 0., 0.,  1., 1.);\n    vec4 col4 = vec4( 0., 0.6, 1., 1.);\n    vec4 col5 = vec4( 0., 0.8, 1., 1.);\n    vec4 col6 = vec4( 0., 0.10, 1., 1.);\n    vec4 col7 = vec4( 0., 0.1, 1., 1.);\n   \n    float f = abs(sin(iTime * 0.02));\n    int counter = 0;\n    \n    vec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    float c2 = 0.;\n    for(float i = -2.; i < 2.; i += 0.05)\n    { \t\n        c2+= 10.;\n        vec2 temp = r;\n        temp.x += i;\n        temp.y += sin(c2 * (iTime /500.));\n        if(cirOL(temp, f)){ counter += 1; }\n    }\n    \n\t\t\n    if(counter == 0)\n    {\n        fragColor = vec4(0., 0., 0., 1.);\n    }\n    \n    else if(counter % 2 == 0)\n    {   \n        fragColor = col3;\n    }\n    \n    else if(counter % 3 == 0)\n    {\n\t\tfragColor = col1;\n    }\n    \n    else if(counter % 7 == 0)\n    {\n        fragColor = col4;\n    }\n    else if(counter % 11 == 0)\n    {\n        fragColor = col5;\n    }\n    \n    else if(counter % 13 == 0)\n    {\n        fragColor = col5;\n    }\n    else if(counter % 17 == 0)\n    {\n        fragColor = col5;\n    }\n    \n    else\n    {\n        fragColor = col2;\n    }\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lfBzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 72], [74, 74, 131, 131, 1345]], "test": "untested"}
{"id": "4lffRj", "name": "Bouncing Objects", "author": "Txoka", "description": "A simple way to make objects moving with different rhymes and directions.", "tags": ["2d", "noise", "random", "bounce", "objects"], "likes": 4, "viewed": 457, "published": "Public API", "date": "1512424955", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define tau 6.28318530717958647692\n\n#define ChangeFactor 40.\n\n#define rot(a) mat2(C=cos(a),S=sin(a),-S,C)\n\n\nhighp float rand(vec2 co) {\n    return fract(sin(mod(dot(co.xy ,vec2(12.9898,78.233)),tau/2.))*43758.5453);\n}\n\nfloat obj(vec2 uv,float x) {\n\tfloat S,C;\n    float r = rand(round(uv/tau+0.8));\n    \n    vec2 gain = round(uv/tau)*tau+1.5;\n    uv-=gain;\n    uv*=rot(tau/pow(2.,ceil(r*2.)));\n    uv+=gain;\n    \n\tfloat f = sin(uv.x)+sin(uv.y);\n\tfloat b = sin(uv.x+uv.y);\n    x+=r*ChangeFactor;\n    \n\tfloat col = f-b/(tan(x)/sin(x));\n\treturn smoothstep(0., 1., col*col*col*col*col);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n\tfragColor = vec4(obj(fragCoord.xy/10.,iTime*10.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lffRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 247, 247, 584], [586, 586, 641, 641, 695]], "test": "untested"}
{"id": "4llBRj", "name": "New Checkerboard Assignment", "author": "LittleBritain97", "description": "Checkerboard assignment ", "tags": ["checkerboard"], "likes": 0, "viewed": 61, "published": "Public", "date": "1512487793", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rows = 150.0;\nfloat cols = 150.0;\nvec4 white = vec4 (1.0, 1.0, 1.0, 1.0);\nvec4 black = vec4 (0.0, 0.0, 0.0, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    vec4 texture1 = texture(iChannel0, uv);\n    vec4 texture2 = texture(iChannel1, uv);\n\n    uv.y *= (iResolution.y / iResolution.x);\n    \n    rows = (0.5 * sin(iTime) + 0.5) * 10.0;\n    cols = (0.5 * cos(iTime) + 0.5) * 10.0;\n    \n    float rowLength = floor(uv.x * rows);\n    float colLength = floor(uv.y * cols);\n    \n   \tfloat sum = rowLength + colLength;\n    \n    if(mod(sum, 2.0) == 0.0)\n    {\n        fragColor = black;\n    }\n    else\n    {\n        fragColor = white;\n    }\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4llBRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 178, 178, 719]], "test": "untested"}
{"id": "4llBRl", "name": "Kelvin waves / ship waves", "author": "FabriceNeyret2", "description": "Semi-analytic Kelvin waves, in deep water conditions ( w=sqrt(gk), group velocity = 1/2 phase velocity ).\n\nMouse.x controls boat size ( in facts, the max of waves emission spectrum ).\nMouse.y controls the width of emission spectrum.\n(0,0) : auto-demo", "tags": ["2d", "waves", "water", "fluid", "physics", "short", "wake"], "likes": 31, "viewed": 2077, "published": "Public API", "date": "1512921903", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n\tvec2 R = iResolution.xy, \n         M = length(iMouse.xy) > 10. ? iMouse.xy / R : vec2(.55,.7);\n    O = vec4(0);\n    U = ( 2.*U - R ) / R.y;  U.x += 1.2;\n \n    float  S = 1.,                                // invariant scaling factor\n           V = 10./sqrt(S),                       // [m/s] boat spead\n           L = 2500./S,                           // [m] screen->world scaling\n          l0 = 2.*L*M.x,                          // boat scale - peak of emission spectrum\n           W =  128./S*exp2(5.*M.y),              // width of spectrum of emission\n           dx = 2./R.y;                           // pixel size. Multiply for more FPS\n    if ( U.x< 0. ) { O += .5; return;}            // 2 optimizations\n    if ( R.y>200. && abs(U.y*R.y)>100.) dx *= 8.*abs(U.y);\n    \n    for (float x = 0.; x<=5.; x += dx ) {         // sum pulse emitted at each past location\n        vec2 P = U  - vec2(x,.2*sin(2.*x-iTime)); // pixel position in past boat frame\n        float l = length(P)*L, \n              k = 6.283/(2.*l),                   // k=2pi/L, energy at l=L/2 since Cg = 1/2 Cphi\n              t = x*L/V,                          // time where boat was at x (approx)\n              a = 3.1416 - sqrt(9.81*k) *t,       // cos(kl-wt), kl=pi, w=sqrt(gk)  \n              v = (l-l0)/W;                       // ( Dispersion relations: https://en.wikipedia.org/wiki/Dispersion_(water_waves)\n        O +=  cos(a) / l  * exp(-.5*v*v);         // spectrum of wave emission by the boat\n    }\n    O = .5 + .5* O*dx *1.7e3/S;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4llBRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 1561]], "test": "untested"}
{"id": "4llfRj", "name": "myRectangle", "author": "steko", "description": "s", "tags": ["a"], "likes": 0, "viewed": 59, "published": "Public", "date": "1512487396", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Band(float valueToProcess, float start, float end, float blur)\n{\n    float fromStart = smoothstep(start - blur, start + blur, valueToProcess);\n    float fromEnd = smoothstep(end + blur, end - blur, valueToProcess);\n    \n    return fromStart * fromEnd;\n}\n\nfloat Rectangle(vec2 pixelCoord, float left, float right, float bot, float top, float blur)\n{\n    float color = Band(pixelCoord.x, left, right, blur);\n    color *= Band(pixelCoord.y, bot, top, blur);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; // 0 <> 1\n    uv = uv * 10. - 5.; // -5.0 <> 5.0\n    uv.x *= iResolution.x / iResolution.y; // aspect ratio\n    \n    float time = iTime;\n    \n    float x = uv.x;\n    float coef = sin(x + time) * 0.5;\n    \n    float y = uv.y + coef;\n    \n    \n    \n    float color;\n    float blur = 0.1;\n    color = Rectangle(vec2(x, y), -3., 3., -.5, .5, blur);\n    \n    fragColor = vec4(vec3(color), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4llfRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 70, 70, 259], [261, 261, 354, 354, 485], [487, 487, 544, 544, 980]], "test": "untested"}
{"id": "4llfWj", "name": "Inefficient Cube", "author": "MetCodeMass", "description": "So, as you can see, I'm a beginner and I tried to make a cube, but it barely runs at 30 fps on my PC. Anyway, enjoy!", "tags": ["cube", "inefficient"], "likes": 3, "viewed": 134, "published": "Public", "date": "1513351677", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926535897932384626433832795;\n\nvec3 lightDirection = vec3(.5, -.25, -1);\nvec3 rotationAxis = vec3(0, 1, .25);\nfloat rotationSpeed = .5;\n\n// front\n\nvec3 p1_1 = vec3(-100, -100, 100);\nvec3 p2_1 = vec3(100, -100, 100);\nvec3 p3_1 = vec3(100, 100, 100);\n\nvec3 p1_2 = vec3(-100, -100, 100);\nvec3 p2_2 = vec3(-100, 100, 100);\nvec3 p3_2 = vec3(100, 100, 100);\n\n// back\n\nvec3 p1_3 = vec3(-100, -100, -100);\nvec3 p2_3 = vec3(100, -100, -100);\nvec3 p3_3 = vec3(100, 100, -100);\n\nvec3 p1_4 = vec3(-100, -100, -100);\nvec3 p2_4 = vec3(-100, 100, -100);\nvec3 p3_4 = vec3(100, 100, -100);\n\n// left\n\nvec3 p1_5 = vec3(-100, -100, 100);\nvec3 p2_5 = vec3(-100, 100, 100);\nvec3 p3_5 = vec3(-100, 100, -100);\n\nvec3 p1_6 = vec3(-100, -100, 100);\nvec3 p2_6 = vec3(-100, -100, -100);\nvec3 p3_6 = vec3(-100, 100, -100);\n\n// right\n\nvec3 p1_7 = vec3(100, -100, 100);\nvec3 p2_7 = vec3(100, 100, 100);\nvec3 p3_7 = vec3(100, 100, -100);\n\nvec3 p1_8 = vec3(100, -100, 100);\nvec3 p2_8 = vec3(100, -100, -100);\nvec3 p3_8 = vec3(100, 100, -100);\n\n// bottom\n\nvec3 p1_9 = vec3(100, -100, 100);\nvec3 p2_9 = vec3(-100, -100, 100);\nvec3 p3_9 = vec3(-100, -100, -100);\n\nvec3 p1_10 = vec3(100, -100, 100);\nvec3 p2_10 = vec3(100, -100, -100);\nvec3 p3_10 = vec3(-100, -100, -100);\n\n// top\n\nvec3 p1_11 = vec3(100, 100, 100);\nvec3 p2_11 = vec3(-100, 100, 100);\nvec3 p3_11 = vec3(-100, 100, -100);\n\nvec3 p1_12 = vec3(100, 100, 100);\nvec3 p2_12 = vec3(100, 100, -100);\nvec3 p3_12 = vec3(-100, 100, -100);\n\nfloat lineSign(vec3 p1, vec3 p2, vec3 p3)\n{\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\n\nbool pointInTriangle(vec3 pt, vec3 v1, vec3 v2, vec3 v3)\n{\n    bool b1, b2, b3;\n\n    b1 = lineSign(pt, v1, v2) < 0.0;\n    b2 = lineSign(pt, v2, v3) < 0.0;\n    b3 = lineSign(pt, v3, v1) < 0.0;\n\n    return ((b1 == b2) && (b2 == b3));\n}\n\nvec4 intersect(vec3 p) {\n    vec3 direction = cross(vec3(p2_1 - p1_1), vec3(p3_1 - p1_1));\n\tvec3 normal = direction / length(direction);\n    \n    float lightIntensity = \tPI - acos(\n        \t\t\t\t\t\tdot(-lightDirection, normal) /\n                            \t(length(-lightDirection) * length(normal)));\n    \n    if (abs(dot(p - p1_1, normal)) < 1.0 && pointInTriangle(p, p1_1, p2_1, p3_1)) {\n        return lightIntensity / PI * vec4(1, 1, 1, 0);\n    }\n    \n    if (abs(dot(p - p1_2, normal)) < 1.0 && pointInTriangle(p, p1_2, p2_2, p3_2)) {\n        return lightIntensity / PI * vec4(1, 1, 1, 0);\n    }\n    \n    \n    direction = -cross(vec3(p2_3 - p1_3), vec3(p3_3 - p1_3));\n\tnormal = direction / length(direction);\n    \n    lightIntensity =\tPI - acos(\n                            dot(-lightDirection, normal) /\n                            (length(-lightDirection) * length(normal)));\n        \n    if (abs(dot(p - p1_3, normal)) < 1.0 && pointInTriangle(p, p1_3, p2_3, p3_3)) {\n        return lightIntensity / PI * vec4(1, 1, 1, 0);\n    }\n        \n    if (abs(dot(p - p1_4, normal)) < 1.0 && pointInTriangle(p, p1_4, p2_4, p3_4)) {\n        return lightIntensity / PI * vec4(1, 1, 1, 0);\n    }\n    \n    \n    direction = cross(vec3(p2_5 - p1_5), vec3(p3_5 - p1_5));\n\tnormal = direction / length(direction);\n    \n    lightIntensity =\tPI - acos(\n                            dot(-lightDirection, normal) /\n                            (length(-lightDirection) * length(normal)));\n        \n    if (abs(dot(p - p1_5, normal)) < 1.0 && pointInTriangle(p, p1_5, p2_5, p3_5)) {\n        return lightIntensity / PI * vec4(1, 1, 1, 0);\n    }\n        \n    if (abs(dot(p - p1_6, normal)) < 1.0 && pointInTriangle(p, p1_6, p2_6, p3_6)) {\n        return lightIntensity / PI * vec4(1, 1, 1, 0);\n    }\n    \n    \n    direction = -cross(vec3(p2_7 - p1_7), vec3(p3_7 - p1_7));\n\tnormal = direction / length(direction);\n    \n    lightIntensity =\tPI - acos(\n                            dot(-lightDirection, normal) /\n                            (length(-lightDirection) * length(normal)));\n        \n    if (abs(dot(p - p1_7, normal)) < 1.0 && pointInTriangle(p, p1_7, p2_7, p3_7)) {\n        return lightIntensity / PI * vec4(1, 1, 1, 0);\n    }\n    \n    if (abs(dot(p - p1_8, normal)) < 1.0 && pointInTriangle(p, p1_8, p2_8, p3_8)) {\n        return lightIntensity / PI * vec4(1, 1, 1, 0);\n    }\n    \n    \n    direction = cross(vec3(p2_9 - p1_9), vec3(p3_9 - p1_9));\n\tnormal = direction / length(direction);\n    \n    lightIntensity =\tPI - acos(\n                            dot(-lightDirection, normal) /\n                            (length(-lightDirection) * length(normal)));\n        \n    if (abs(dot(p - p1_9, normal)) < 1.0 && pointInTriangle(p, p1_9, p2_9, p3_9)) {\n        return lightIntensity / PI * vec4(1, 1, 1, 0);\n    }\n    \n    if (abs(dot(p - p1_10, normal)) < 1.0 && pointInTriangle(p, p1_10, p2_10, p3_10)) {\n        return lightIntensity / PI * vec4(1, 1, 1, 0);\n    }\n    \n    \n    direction = -cross(vec3(p2_11 - p1_11), vec3(p3_11 - p1_11));\n\tnormal = direction / length(direction);\n    \n    lightIntensity =\tPI - acos(\n                            dot(-lightDirection, normal) /\n                            (length(-lightDirection) * length(normal)));\n        \n    if (abs(dot(p - p1_11, normal)) < 1.0 && pointInTriangle(p, p1_11, p2_11, p3_11)) {\n        return lightIntensity / PI * vec4(1, 1, 1, 0);\n    }\n        \n    if (abs(dot(p - p1_12, normal)) < 1.0 && pointInTriangle(p, p1_12, p2_12, p3_12)) {\n        return lightIntensity / PI * vec4(1, 1, 1, 0);\n    }\n    \n    \n    return vec4(0, 0, 0, 0);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid rotate(float angle) {\n\tvec4 p1_1_temp = rotationMatrix(rotationAxis, angle) * vec4(p1_1.x, p1_1.y, p1_1.z, 0);\n    p1_1 = vec3(p1_1_temp.x, p1_1_temp.y, p1_1_temp.z);\n    \n    vec4 p2_1_temp = rotationMatrix(rotationAxis, angle) * vec4(p2_1.x, p2_1.y, p2_1.z, 0);\n    p2_1 = vec3(p2_1_temp.x, p2_1_temp.y, p2_1_temp.z);\n    \n    vec4 p3_1_temp = rotationMatrix(rotationAxis, angle) * vec4(p3_1.x, p3_1.y, p3_1.z, 0);\n    p3_1 = vec3(p3_1_temp.x, p3_1_temp.y, p3_1_temp.z);\n    \n    vec4 p1_2_temp = rotationMatrix(rotationAxis, angle) * vec4(p1_2.x, p1_2.y, p1_2.z, 0);\n    p1_2 = vec3(p1_2_temp.x, p1_2_temp.y, p1_2_temp.z);\n    \n    vec4 p2_2_temp = rotationMatrix(rotationAxis, angle) * vec4(p2_2.x, p2_2.y, p2_2.z, 0);\n    p2_2 = vec3(p2_2_temp.x, p2_2_temp.y, p2_2_temp.z);\n    \n    vec4 p3_2_temp = rotationMatrix(rotationAxis, angle) * vec4(p3_2.x, p3_2.y, p3_2.z, 0);\n    p3_2 = vec3(p3_2_temp.x, p3_2_temp.y, p3_2_temp.z);\n    \n    \n    vec4 p1_3_temp = rotationMatrix(rotationAxis, angle) * vec4(p1_3.x, p1_3.y, p1_3.z, 0);\n    p1_3 = vec3(p1_3_temp.x, p1_3_temp.y, p1_3_temp.z);\n    \n    vec4 p2_3_temp = rotationMatrix(rotationAxis, angle) * vec4(p2_3.x, p2_3.y, p2_3.z, 0);\n    p2_3 = vec3(p2_3_temp.x, p2_3_temp.y, p2_3_temp.z);\n    \n    vec4 p3_3_temp = rotationMatrix(rotationAxis, angle) * vec4(p3_3.x, p3_3.y, p3_3.z, 0);\n    p3_3 = vec3(p3_3_temp.x, p3_3_temp.y, p3_3_temp.z);\n    \n    vec4 p1_4_temp = rotationMatrix(rotationAxis, angle) * vec4(p1_4.x, p1_4.y, p1_4.z, 0);\n    p1_4 = vec3(p1_4_temp.x, p1_4_temp.y, p1_4_temp.z);\n    \n    vec4 p2_4_temp = rotationMatrix(rotationAxis, angle) * vec4(p2_4.x, p2_4.y, p2_4.z, 0);\n    p2_4 = vec3(p2_4_temp.x, p2_4_temp.y, p2_4_temp.z);\n    \n    vec4 p3_4_temp = rotationMatrix(rotationAxis, angle) * vec4(p3_4.x, p3_4.y, p3_4.z, 0);\n    p3_4 = vec3(p3_4_temp.x, p3_4_temp.y, p3_4_temp.z);\n    \n    \n    vec4 p1_5_temp = rotationMatrix(rotationAxis, angle) * vec4(p1_5.x, p1_5.y, p1_5.z, 0);\n    p1_5 = vec3(p1_5_temp.x, p1_5_temp.y, p1_5_temp.z);\n    \n    vec4 p2_5_temp = rotationMatrix(rotationAxis, angle) * vec4(p2_5.x, p2_5.y, p2_5.z, 0);\n    p2_5 = vec3(p2_5_temp.x, p2_5_temp.y, p2_5_temp.z);\n    \n    vec4 p3_5_temp = rotationMatrix(rotationAxis, angle) * vec4(p3_5.x, p3_5.y, p3_5.z, 0);\n    p3_5 = vec3(p3_5_temp.x, p3_5_temp.y, p3_5_temp.z);\n    \n    vec4 p1_6_temp = rotationMatrix(rotationAxis, angle) * vec4(p1_6.x, p1_6.y, p1_6.z, 0);\n    p1_6 = vec3(p1_6_temp.x, p1_6_temp.y, p1_6_temp.z);\n    \n    vec4 p2_6_temp = rotationMatrix(rotationAxis, angle) * vec4(p2_6.x, p2_6.y, p2_6.z, 0);\n    p2_6 = vec3(p2_6_temp.x, p2_6_temp.y, p2_6_temp.z);\n    \n    vec4 p3_6_temp = rotationMatrix(rotationAxis, angle) * vec4(p3_6.x, p3_6.y, p3_6.z, 0);\n    p3_6 = vec3(p3_6_temp.x, p3_6_temp.y, p3_6_temp.z);\n    \n    \n    vec4 p1_7_temp = rotationMatrix(rotationAxis, angle) * vec4(p1_7.x, p1_7.y, p1_7.z, 0);\n    p1_7 = vec3(p1_7_temp.x, p1_7_temp.y, p1_7_temp.z);\n    \n    vec4 p2_7_temp = rotationMatrix(rotationAxis, angle) * vec4(p2_7.x, p2_7.y, p2_7.z, 0);\n    p2_7 = vec3(p2_7_temp.x, p2_7_temp.y, p2_7_temp.z);\n    \n    vec4 p3_7_temp = rotationMatrix(rotationAxis, angle) * vec4(p3_7.x, p3_7.y, p3_7.z, 0);\n    p3_7 = vec3(p3_7_temp.x, p3_7_temp.y, p3_7_temp.z);\n    \n    vec4 p1_8_temp = rotationMatrix(rotationAxis, angle) * vec4(p1_8.x, p1_8.y, p1_8.z, 0);\n    p1_8 = vec3(p1_8_temp.x, p1_8_temp.y, p1_8_temp.z);\n    \n    vec4 p2_8_temp = rotationMatrix(rotationAxis, angle) * vec4(p2_8.x, p2_8.y, p2_8.z, 0);\n    p2_8 = vec3(p2_8_temp.x, p2_8_temp.y, p2_8_temp.z);\n    \n    vec4 p3_8_temp = rotationMatrix(rotationAxis, angle) * vec4(p3_8.x, p3_8.y, p3_8.z, 0);\n    p3_8 = vec3(p3_8_temp.x, p3_8_temp.y, p3_8_temp.z);\n    \n    \n    vec4 p1_9_temp = rotationMatrix(rotationAxis, angle) * vec4(p1_9.x, p1_9.y, p1_9.z, 0);\n    p1_9 = vec3(p1_9_temp.x, p1_9_temp.y, p1_9_temp.z);\n    \n    vec4 p2_9_temp = rotationMatrix(rotationAxis, angle) * vec4(p2_9.x, p2_9.y, p2_9.z, 0);\n    p2_9 = vec3(p2_9_temp.x, p2_9_temp.y, p2_9_temp.z);\n    \n    vec4 p3_9_temp = rotationMatrix(rotationAxis, angle) * vec4(p3_9.x, p3_9.y, p3_9.z, 0);\n    p3_9 = vec3(p3_9_temp.x, p3_9_temp.y, p3_9_temp.z);\n    \n    vec4 p1_10_temp = rotationMatrix(rotationAxis, angle) * vec4(p1_10.x, p1_10.y, p1_10.z, 0);\n    p1_10 = vec3(p1_10_temp.x, p1_10_temp.y, p1_10_temp.z);\n    \n    vec4 p2_10_temp = rotationMatrix(rotationAxis, angle) * vec4(p2_10.x, p2_10.y, p2_10.z, 0);\n    p2_10 = vec3(p2_10_temp.x, p2_10_temp.y, p2_10_temp.z);\n    \n    vec4 p3_10_temp = rotationMatrix(rotationAxis, angle) * vec4(p3_10.x, p3_10.y, p3_10.z, 0);\n    p3_10 = vec3(p3_10_temp.x, p3_10_temp.y, p3_10_temp.z);\n    \n    \n    vec4 p1_11_temp = rotationMatrix(rotationAxis, angle) * vec4(p1_11.x, p1_11.y, p1_11.z, 0);\n    p1_11 = vec3(p1_11_temp.x, p1_11_temp.y, p1_11_temp.z);\n    \n    vec4 p2_11_temp = rotationMatrix(rotationAxis, angle) * vec4(p2_11.x, p2_11.y, p2_11.z, 0);\n    p2_11 = vec3(p2_11_temp.x, p2_11_temp.y, p2_11_temp.z);\n    \n    vec4 p3_11_temp = rotationMatrix(rotationAxis, angle) * vec4(p3_11.x, p3_11.y, p3_11.z, 0);\n    p3_11 = vec3(p3_11_temp.x, p3_11_temp.y, p3_11_temp.z);\n    \n    vec4 p1_12_temp = rotationMatrix(rotationAxis, angle) * vec4(p1_12.x, p1_12.y, p1_12.z, 0);\n    p1_12 = vec3(p1_12_temp.x, p1_12_temp.y, p1_12_temp.z);\n    \n    vec4 p2_12_temp = rotationMatrix(rotationAxis, angle) * vec4(p2_12.x, p2_12.y, p2_12.z, 0);\n    p2_12 = vec3(p2_12_temp.x, p2_12_temp.y, p2_12_temp.z);\n    \n    vec4 p3_12_temp = rotationMatrix(rotationAxis, angle) * vec4(p3_12.x, p3_12.y, p3_12.z, 0);\n    p3_12 = vec3(p3_12_temp.x, p3_12_temp.y, p3_12_temp.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rotate(PI * .75 + sin(rotationSpeed * iTime) * .5);\n    \n    vec3 camPos = vec3(0, 0, 1000);\n\tvec3 screenPos = vec3(fragCoord.x - iResolution.x * .5, fragCoord.y - iResolution.y * .5, 200);\n    vec3 ray = normalize(screenPos - camPos);\n    \n    vec3 p = screenPos;\n    \n    for (int i = 0; i < 300; i++) {\n        vec4 color = intersect(p);\n        \n        if (color != vec4(0, 0, 0, 0)) {\n            fragColor = color * (1.0 - sqrt(distance(p, screenPos)) * .05) * 2.0;\n            return;\n        }\n        \n        p += ray;\n    }\n    \n    fragColor = vec4(0, 0, 0, 0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4llfWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1259, 1479, 1522, 1522, 1598], [1600, 1600, 1658, 1658, 1833], [1835, 1835, 1859, 1859, 5431], [5433, 5433, 5478, 5478, 6106], [6108, 6108, 6134, 6134, 11733], [11735, 11735, 11792, 11792, 12373]], "test": "untested"}
{"id": "4lsBDj", "name": "Circle wavy pattern", "author": "demicuz", "description": "just practicing", "tags": ["waves", "circles", "texture"], "likes": 1, "viewed": 152, "published": "Public", "date": "1514333148", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float zoom = 10.;\n\nvec3 cog (in vec2 uv, in vec2 center, in float radius) {\n    float len = length(center - uv);\n    \n    //return vec3(1. - step(radius, len));\n    return vec3(1. - smoothstep(radius, radius + .04, len));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 aspect = vec2(iResolution.x / iResolution.y, 1.);\n    uv *= aspect * zoom;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy * aspect * zoom;\n    \n    float radius = .4 + cos(iTime * 2. - (uv.x + uv.y) / 2.) / 20.;\n    \n    vec2 center = floor(uv) + vec2(0.5, 0.5);\n    //vec2 center = floor(mouse) + vec2(0.5, 0.5);\n    \n    vec3 cog = cog(uv, center, radius);\n    vec3 background = vec3(uv.x / zoom, uv.y / zoom, .5);\n    \n\tfragColor = vec4(cog * background, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsBDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 81, 81, 234], [236, 236, 293, 293, 812]], "test": "untested"}
{"id": "4lsBR2", "name": "Mystical Hole 2", "author": "Del", "description": "sin magic++\nAdded mouse click for invert", "tags": ["hole"], "likes": 4, "viewed": 101, "published": "Public", "date": "1512515837", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// um, some kind of mystical hole...?\n\nfloat glint(vec2 p)\n{\n    vec2 uv = p;\n    float speed = 0.68;\n    float linewidth = 1.38;\n    float grad = 3.0;\n    vec2 linepos = uv;\n    linepos.x = linepos.x - mod(iTime*speed,4.0)+2.0;\n    float y = linepos.x*grad;\n\tfloat s = smoothstep( y-linewidth, y, linepos.y) - smoothstep( y, y+linewidth, linepos.y); \n    return s;\n}\n\nfloat _glint(vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float speed = iTime*0.2;\n \tfloat d = 1.0+p.x*0.25;\n    vec2 cst = vec2( cos(d+speed), sin(d+speed) );\n    float zoom = 1.0+(0.5*sin(iTime*0.675));\n    mat2 rot = zoom * mat2(cst.x,-cst.y,cst.y,cst.x);\n    float s = glint(p*rot*0.44);\n    return s;\n}\n\n\nvoid mainImage(out vec4 k, vec2 p)\n{\n    const vec4 col1 = vec4(0.27,.1,.1,1.0);\n    const vec4 col2 = vec4(0.9,0.5,0.5,1.0);\n    vec2 uv = p.xy / iResolution.xy;\n    float gl = _glint(p)*0.5;\n\n    float s = sin(iTime*0.1);\n    float s2 = 0.5+sin(iTime*1.8);\n    vec2 d = uv*(4.0+s*.3);\n    \n    d.x += sin(d.y + iTime*0.2)*1.2;\n    d.y += sin(d.x + iTime*0.2)*1.2;\t//-(s*0.5);\n    float v1=length(0.5-fract(d.xy))+0.90;\n\n    d = uv;\n    float v2=length(0.5-fract(d.xy));\n    v1 *= 1.0-v2*v1;\n    v1 = v1*v1*v1;\n    v1 *= 1.9+s2*0.2;\n    k = mix(col2,col1,v1)*(3.4+(s2*0.2));\n    \n    \n    k *= 1.0-(v2);\n    \n    // invert the hole on mouse click\n\tif (iMouse.z > 0.5)\n    {\n        k = clamp(k,vec4(0.0),vec4(1.0));\n        k = 1.0-k;\n        k = mix(col1,col2,k.r+v1*0.2);\n    }\n    \n    if (k.r<=0.5)\n    {\n        float m = 1.0-clamp(k.r,0.0,0.5);\n\t\tfloat f = mod( floor(12.0*uv.x) + floor(12.0*uv.y), 2.0);\n        float col = 0.3 + 0.2*f*1.0;\n        k.x = k.y = k.z = col*m;\n        k.z *= 2.0;\n    }\n    else\n    {\n\t\tfloat f = mod( floor(12.0*uv.x) + floor(12.0*uv.y), 2.0);\n        vec4 _col = 0.2*f*vec4(0.175);\n        k+=_col;\n    }\n    // glint\n    k *=vec4(1.0+gl);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsBR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 60, 60, 367], [369, 369, 400, 400, 721], [724, 724, 760, 760, 1915]], "test": "untested"}
{"id": "4lsBRj", "name": "Eye motion persistence", "author": "Ultraviolet", "description": "Instruction: look at the red dot for 5 seconds, and then look away from your screen.\nInspired by [url]https://i.imgur.com/A2ZoLEF.gifv[/url]\n", "tags": ["illusion", "motion", "persistence"], "likes": 5, "viewed": 176, "published": "Public", "date": "1512487930", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415972\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0*(fragCoord.xy / min(iResolution.x,iResolution.y) - 0.5*iResolution.xy/ min(iResolution.x,iResolution.y));\n\t\n    float theta = atan(uv.y, uv.x);\n    float theta2 = theta;\n    float rho = length(uv);\n    \n    float period = 2.*PI/5.;\n    theta = mod(theta, period);\n    theta = min(theta, period-theta);\n    \n    vec2 p = vec2(cos(theta), sin(theta)) * rho;\n    \n    float speed = 1.0;\n    \n    float alpha = PI*0.3;\n    \n    float x = 2.*sin(alpha)/(sin(period*.5)+2.*sin(alpha+period*.5));\n    float rad = sin(period*.5)/(sin(period*.5)+2.*sin(alpha+period*.5));\n    \n    if(length(p-vec2(1.0-rad, 0.0))<rad || length(p)<1.-rad-rad*cos(alpha) && length(p-x*vec2(cos(.5*period), sin(.5*period)))>rad)\n        speed = -1.0;\n    \n    float val = sin(100.*rho-iTime*50.*speed);\n    val = max(val, sin(100.0 * theta2-iTime*50.*speed)*clamp(rho*10.0 - 2.0, 0.0, 1.0));\n    fragColor = vec4(val);\n    \n    fragColor *= clamp(rho*10.0 - .5, 0.0, 1.0);\n    \n    if(rho < 0.01)\n     fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsBRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 79, 1107]], "test": "untested"}
{"id": "4lsBWX", "name": "SuperF0rmula", "author": "jgkling", "description": "Ellipse superformula using IQ distance estimation. Links:\nhttp://www.iquilezles.org/www/articles/distance/distance.htm\nhttps://en.wikipedia.org/wiki/Superformula", "tags": ["procedural"], "likes": 4, "viewed": 111, "published": "Public", "date": "1513810759", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define OneD // use some 1D function\n#define ROTATE\n\n// Superformula: https://en.wikipedia.org/wiki/Superformula\nfloat Superformula( in vec2 p, in vec4 params ) {\n    vec2 pt = abs(vec2(cos(p.y * params.x * 0.25), sin(p.y * params.x * 0.25)));\n    pt = pow(pt, vec2(params.z, params.w));\n    return pow(pt.x + pt.y, -1.0 / params.y) * 0.5 - p.x; // the * 0.5 is a tweaked trick I stole from here: https://www.shadertoy.com/view/llsyz8\n}\n\nfloat func( in vec2 p ) {\n    #ifdef OneD\n    return cos(p.x * 32.0 + iTime * 0.5) * sin(p.x * 13.0 + iTime * 1.5) * 0.15; // some 1D fxn\n    \n    #else\n    \n    //return p.x - 1.0 + 0.5 * sin(3.0 * p.y + 2.0 * p.x * p.x); // 3-blade fan\n    \n    vec4 shapes [2];\n    \n    shapes[0] = vec4(3, 3, 14, 2);\n    shapes[1] = vec4(7, 3, 6, 6);\n    \n    float animate = sin(iTime) * 0.5 + 0.5;\n    animate = (max(min(animate, 0.75), 0.25) - 0.25) * 2.0;\n    \n    return mix(Superformula(p, shapes[0]), Superformula(p, shapes[1]), animate);\n    \n    #endif\n}\n\nvec2 grad( in vec2 x )\n{\n    vec2 h = vec2(/*1.0 / iResolution.y*/0.1, 0.0);\n    #ifdef OneD\n    vec2 result;\n    result.x = (func(x + h.xy) - func(x - h.xy)) / (2.0 * h.x);\n    result.y = 1.0;\n    return result;\n    #else\n    return vec2(func(x + h.xy) - func(x - h.xy),\n                func(x + h.yx) - func(x - h.yx)) / (2.0 * h.x);\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 scrPt = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    #ifdef ROTATE\n    // Rotate the scrPt for funsies\n    float theta = -iTime * 0.25;\n    mat2 rot;\n    \n    // cache calls to sin/cos\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    \n    rot[0][0] = cosTheta;\n    rot[0][1] = -sinTheta;\n    rot[1][0] = sinTheta;\n    rot[1][1] = cosTheta;\n    \n    scrPt *= rot;\n    #endif\n    \n    vec2 inputVal;\n    #ifdef OneD\n    inputVal = scrPt;\n    #else\n    scrPt *= 2.0;\n    inputVal = vec2(length(scrPt * 1.0), atan(scrPt.y, scrPt.x)); // for 3-blade fan\n    #endif\n    \n    float val = func(inputVal);\n    \n    // Compute numerical gradient\n    vec2 gradient;\n    gradient = grad(inputVal);\n    \n    float gradDenom = length(gradient);\n    \n    float valNum;\n    #ifdef OneD\n    valNum = abs(val - scrPt.y); // only subtract for 1D fxns\n    #else\n    valNum = abs(val);\n    #endif\n    \n    float distEst = valNum / gradDenom; // improve distance estimation\n    \n    #ifdef OneD\n    distEst = smoothstep(0.005, 0.0051, distEst);\n    #else\n    distEst = 1.0 - smoothstep(0.0, 0.009, distEst);\n    #endif\n    \n    vec3 color;\n    color = vec3(distEst);\n    \n    // Compute some outline color\n    vec3 outlineCol;\n    \n    float alternate = sign(sin(inputVal.y * 20.0 + iTime * 8.0));\n    outlineCol = mix(vec3(0.2, 0.3, 0.4), vec3(1.0, 0.3, 0.2), alternate);\n    \n    color = outlineCol * pow(color, vec3(0.175));\n    \n    vec3 bgColor;\n    bgColor = vec3(0.08, 0.25, 0.21);\n    color = mix(bgColor, color, ceil(distEst));\n    \n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsBWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 115, 164, 164, 438], [440, 440, 465, 465, 990], [992, 992, 1016, 1016, 1340], [1342, 1342, 1399, 1399, 2999]], "test": "untested"}
{"id": "4lsfRj", "name": "Mitosis II", "author": "jennyveens", "description": "Just a couple of blobs having a good time.", "tags": ["metaballs"], "likes": 2, "viewed": 92, "published": "Public", "date": "1512490802", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy / iResolution.xy;\n\n    float d = sin(iTime) * 0.2;\n\n    float dist1 = pow(max(1.0 - distance(pos, vec2(0.5 + d, 0.5)) * 3.5, 0.0), 3.0);\n    float dist2 = pow(max(1.0 - distance(pos, vec2(0.5 - d, 0.5)) * 3.5, 0.0), 3.0);\n\n    float c = sin(1.0 - smoothstep(0.3, 0.5, dist1 + dist2) * iTime);\n\n    fragColor = vec4(c, c, c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsfRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 417]], "test": "untested"}
{"id": "4lsfzj", "name": "Clebsch Cubic", "author": "mla", "description": "The cubic surface of Alfred Clebsch, with its 27 lines.\n\nMouse changes R3 orientation.\n", "tags": ["raytrace", "algebraic", "clebsch"], "likes": 10, "viewed": 572, "published": "Public API", "date": "1512512915", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI =  3.141592654;\nconst float TWOPI = 2.0 * PI;\nconst float PHI = 1.618033989;\nconst vec4 I = vec4(1,1,1,1);\nconst vec3 AXIS = vec3(1,1,1); // axis for rotation\nconst int NLINES = 27;\nvec4 lines[NLINES*2];\nint colors[NLINES];\n\n// Lighting params\nvec3 light;\nfloat ambient;\nfloat diffuse;\n\n// Quaternion multiplication as a matrix.\n// w coordinate is real element of quaternion\n// This gives a Clifford translation in R4\nmat4 qmat(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, t = q.w;\n  return mat4( t,-z, y, x, \n               z, t,-x, y,\n              -y, x, t, z,\n              -x,-y,-z, t );\n}\n\nint quadratic(float A, float B, float C, out vec3 x) {\n   float D = B*B - 4.0*A*C;\n   if (D < 0.0) return 0;\n   D = sqrt(D);\n   if (B < 0.0) D = -D;\n   x[0] = (-B-D)/(2.0*A);\n   x[1] = C/(A*x[0]);\n   return 2;\n}\n\n// Numerical Recipes algorithm for solving cubic equation\nint cubic0(float a, float b, float c, float d, out vec3 x) {\n  if (a == 0.0) return quadratic(b,c,d,x);\n  //if (d == 0.0) return quadratic(a,b,c,x); // Need 0 too.\n  float tmp = a; a = b/tmp; b = c/tmp; c = d/tmp;\n  // solve x^3 + ax^2 + bx + c = 0\n  float Q = (a*a-3.0*b)/9.0;\n  float R = (2.0*a*a*a - 9.0*a*b + 27.0*c)/54.0;\n  float R2 = R*R, Q3 = Q*Q*Q;\n  if (R2 < Q3) {\n    float X = clamp(R/sqrt(Q3),-1.0,1.0);\n    float theta = acos(X);\n    float S = sqrt(Q); // Q must be positive since 0 <= R2 < Q3\n    x[0] = -2.0*S*cos(theta/3.0) - a/3.0;\n    x[1] = -2.0*S*cos((theta+2.0*PI)/3.0) - a/3.0;\n    x[2] = -2.0*S*cos((theta+4.0*PI)/3.0) - a/3.0;\n    return 3;\n  } else {\n    float A = -sign(R)*pow(abs(R)+sqrt(R2-Q3),0.3333);\n    float B = A == 0.0 ? 0.0 : Q/A;\n    x[0] = (A+B) - a/3.0;\n    return 1;\n  }\n}\n\nint cubic(float A, float B, float C, float D, out vec3 x) {\n  int nroots;\n  // Some ill-conditioned coeffs can cause problems\n  // The worst is fixed by solving for reciprocal\n  if (abs(A) > abs(D)) {\n    nroots = cubic0(A,B,C,D,x);\n  } else {\n    nroots = cubic0(D,C,B,A,x);\n    for (int i = 0; i < 3; i++) {\n      x[i] = 1.0/x[i];\n    }\n  }\n  return nroots;\n}\n\n// Initialize array of lines & colors\n// I could probably do this procedurally or just use\n// a static array for GLSL 3.0\nvoid initlines() {\n  lines[0] =  vec4(1,-1,0,0); lines[1] =  vec4(0,0,1,0);\n  lines[2] =  vec4(1,-1,0,0); lines[3] =  vec4(0,0,0,1);\n  lines[4] =  vec4(1,0,-1,0); lines[5] =  vec4(0,1,0,0);\n  lines[6] =  vec4(1,0,-1,0); lines[7] =  vec4(0,0,0,1);\n  lines[8] =  vec4(1,0,0,-1); lines[9] =  vec4(0,1,0,0);\n  lines[10] = vec4(1,0,0,-1); lines[11] = vec4(0,0,1,0);\n\n  lines[12] = vec4(0,1,-1,0); lines[13] = vec4(1,0,0,0);\n  lines[14] = vec4(0,1,-1,0); lines[15] = vec4(0,0,0,1);\n  lines[16] = vec4(0,1,0,-1); lines[17] = vec4(1,0,0,0);\n  lines[18] = vec4(0,1,0,-1); lines[19] = vec4(0,0,1,0);\n  lines[20] = vec4(0,0,1,-1); lines[21] = vec4(1,0,0,0);\n  lines[22] = vec4(0,0,1,-1); lines[23] = vec4(0,1,0,0);\n\n  lines[24] = vec4(1,-1,0,0); lines[25] = vec4(0,0,1,-1);\n  lines[26] = vec4(1,0,-1,0); lines[27] = vec4(0,1,0,-1);\n  lines[28] = vec4(1,0,0,-1); lines[29] = vec4(0,1,-1,0);\n\n  lines[30] = vec4(1,PHI,-1,0); lines[31] = vec4(PHI,1,0,-1);\n  lines[32] = vec4(1,PHI,0,-1); lines[33] = vec4(PHI,1,-1,0);\n  lines[34] = vec4(1,0,PHI,-1); lines[35] = vec4(PHI,-1,1,0);\n  lines[36] = vec4(1,-1,PHI,0); lines[37] = vec4(PHI,0,1,-1);\n  lines[38] = vec4(1,-1,0,PHI); lines[39] = vec4(PHI,0,-1,1);\n  lines[40] = vec4(1,0,-1,PHI); lines[41] = vec4(PHI,-1,0,1);\n\n  lines[42] = vec4(-1,1,PHI,0); lines[43] = vec4(0,PHI,1,-1);\n  lines[44] = vec4(0,1,PHI,-1); lines[45] = vec4(-1,PHI,1,0);\n  lines[48] = vec4(-1,1,0,PHI); lines[49] = vec4(0,PHI,-1,1);\n  lines[46] = vec4(0,1,-1,PHI); lines[47] = vec4(-1,PHI,0,1);\n  lines[50] = vec4(-1,0,1,PHI); lines[51] = vec4(0,-1,PHI,1);\n  lines[52] = vec4(0,-1,1,PHI); lines[53] = vec4(-1,0,PHI,1);\n\n  colors[0] = colors[5] = colors[9] = 5;\n  colors[1] = colors[3] = colors[7] = 2;\n  colors[2] = colors[4] = colors[11] = 7;\n  colors[6] = colors[8] = colors[10] = 4;\n  colors[12] = colors[13] = colors[14] = 6;\n  // This colouring shows a \"double six\" for 12 lines.\n  colors[15] = colors[17] = colors[19] = colors[21] = colors[23] = colors[25] = 1;\n  colors[16] = colors[18] = colors[20] = colors[22] = colors[24] = colors[26] = 3;\n}\n\nvec4 getColor(int i) {\n  if (i == 0) return vec4(0.5,0.5,1,1);\n  if (i == 1) return vec4(1,0,0,1);\n  if (i == 2) return vec4(1,1,0,1);\n  if (i == 3) return vec4(0,0,1,1);\n  if (i == 4) return vec4(0,1,0,1);\n  if (i == 5) return vec4(0,1,1,1);\n  if (i == 6) return vec4(1,0,1,1);\n  if (i == 7) return vec4(0.5,0.5,0.1,1);\n  return vec4(0,0,0,1);\n}\n\n// p is in world coordinates\nfloat eval(vec4 p,mat4 m) {\n  p = m*p;\n  float pI = dot(p,I);\n  return dot(p*p,p) - pI*pI*pI;\n}\n\n// Equation is: pp.p - (p.I)^3 = 0\n// A = rr.r - (r.I)^3\n// B = 3(rr.p -(p.I)(r.I)^2)\n// C = 3(pp.r -(p.I)^2(r.I))\n// D = pp.p - (p.I)^3\nfloat surface(vec4 p0, vec4 r0) {\n  vec4 p = p0;\n  vec4 r = r0;\n  float pI = dot(p,I);\n  float rI = dot(r,I);\n\n  // Possibly this is a better way.\n  float A = dot(r*r - rI*rI*I, r);\n  float B = 3.0*dot(r*r - rI*rI*I, p);\n  float C = 3.0*dot(p*p - pI*pI*I, r);\n  float D = dot(p*p - pI*pI*I, p);\n\n  vec3 x;\n  int nroots = cubic(A,B,C,D,x);\n  float t0 = 1e8;\n  for (int i = 0; i < 3; i++) {\n    if (i == nroots) break;\n    if (0.0 < x[i] && x[i] < t0) {\n      t0 = x[i];\n    }\n  }\n  return t0;\n}\n    \n// Find the (squared) distance to the line in R3 but\n// using homogeneous coordinates.\nfloat tryline(vec4 q, vec4 p, vec4 r) {\n  // |r.w| < |p.w| and if both are small we have a\n  // line at infinity so we can ignore it\n  if (abs(p.w) < 1e-2) return 1e8;\n   r = p.w*r - r.w*p; // r.w = 0\n   q = p.w*q-p;\n   float qr = dot(q,r);\n   float d2 = (dot(q,q) - (qr*qr/dot(r,r)))/(p.w*p.w);\n   return d2;\n}\n\nvec4 solve(vec4 p, vec4 r) {\n  vec3 normal = vec3(1,0,0);\n  float theta = iTime*0.1;\n  // M rotates surface in R4\n  vec3 a = normalize(AXIS);\n  mat4 M = qmat(vec4(sin(theta)*a,cos(theta)));\n  mat4 Minv = qmat(vec4(-sin(theta)*a,cos(theta)));\n  initlines();\n\n  const float u = 0.025;\n  const float u2 = u*u;\n  int colorindex = -1; // Selected color\n  float t = surface(M*p,M*r);\n  if (t < 1e8) {\n    // Compute normal by finding gradient\n    vec4 q = p+t*r;\n    float x0 = eval(q,M);\n    vec2 eps = vec2(1e-2,0);\n    normal = vec3 (eval(q+eps.xyyy,M)-x0,\n                   eval(q+eps.yxyy,M)-x0,\n                   eval(q+eps.yyxy,M)-x0);\n    normal = normalize(normal);\n    colorindex = 0;\n\n    // Now find the nearest line\n    float d = u2;\n    for (int i = 0; i < NLINES; i++) {\n      vec4 p4 = Minv*lines[2*i];\n      vec4 r4 = Minv*lines[2*i+1];\n      if (abs(p4.w) < abs(r4.w)) {\n        vec4 t = p4; p4 = r4; r4 = t;\n      }\n      float d0 = tryline(q,p4,r4);\n      if (d0 < d){\n        d = d0;\n        colorindex = colors[i];\n      }\n    }\n  }\n  if (colorindex == -1) return vec4(0,0,0,1);\n  if (dot(r.xyz,normal) > 0.0) {\n    normal = -normal; // Face forwards\n  }\n  vec4 baseColor = getColor(colorindex);\n  vec3 color;\n  color = baseColor.xyz*(ambient+(1.0-ambient)*dot(light,normal));\n  float specular = pow(max(0.0,dot(reflect(light,normal),r.xyz)),4.0);\n  color += 0.7*specular*vec3(1.0,1.0,1.0);\n  return vec4(sqrt(color),1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = normalize(vec3(0.0,1.0,-1.0));\n  ambient = 0.6;\n  diffuse = 1.0-ambient;\n\n  vec2 uv = 2.0*fragCoord.xy/iResolution.xy - 1.0;\n  vec3 p = vec3(0.0, 0.0, 6.0);\n  vec3 r = normalize(vec3(iResolution.x/iResolution.y * uv.x, uv.y, -3.0));\n  // Rotate camera according to mouse position\n  float xrot = 0.0; // About x-axis\n  float yrot = 0.0; // About y-axis\n  if (iMouse.x > 0.0) {\n    yrot = TWOPI*(iMouse.x-0.5*iResolution.x)/iResolution.x;\n    xrot = TWOPI*(iMouse.y-0.5*iResolution.y)/iResolution.y;\n  }\n  mat3 mx = mat3(1,0,0,\n                 0,cos(xrot),-sin(xrot),\n                 0,sin(xrot),cos(xrot));\n  mat3 my = mat3(cos(yrot),0,-sin(yrot),\n                 0,1,0,\n                 sin(yrot),0,cos(yrot));\n  mat3 m = mx*my;\n  light *= m;\n  p *= m;\n  r *= m;\n  fragColor = solve(vec4(p,1),vec4(r,0));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsfzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[302, 433, 452, 452, 609], [611, 611, 665, 665, 822], [824, 882, 942, 942, 1694], [1696, 1696, 1755, 1755, 2057], [2059, 2181, 2199, 2199, 4239], [4241, 4241, 4263, 4263, 4587], [4589, 4618, 4645, 4645, 4713], [4715, 4852, 4885, 4885, 5345], [5351, 5438, 5477, 5570, 5749], [5751, 5751, 5779, 5779, 7193], [7195, 7195, 7252, 7252, 8072]], "test": "untested"}
{"id": "4lXBWj", "name": "Torus_Thingy_5", "author": "balkhan", "description": "torus", "tags": ["raymarch", "torus"], "likes": 15, "viewed": 525, "published": "Public API", "date": "1513225569", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tloop_circle(vec3 p);\nfloat\tcircle(vec3 p, float phase);\nfloat\tsdTorus( vec3 p, vec2 t, float phase );\nfloat\tmylength(vec2 p);\nfloat\tnrand( vec2 n );\n\nfloat \tt;\t\t\t// time\nvec3\tret_col;\t// torus color\nvec3\th; \t\t\t// light amount\n\n#define I_MAX\t\t200.\n#define E\t\t\t0.00001\n#define FAR\t\t\t15.\n#define PI\t\t\t3.14\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 0.0);\n\n    pos.z = 4.5+1.5*sin(t*10.);    \n    h*=0.;\n    vec2\tinter = (march(pos, dir));\n    if (inter.y <= FAR)\n        col.xyz = ret_col*(1.-inter.x*.0025);\n    else\n        col *= 0.;\n    col += h*.005125;\n    c_out =  vec4(col,1.0);\n}\n\nfloat\tscene(vec3 p)\n{  \n    float\tvar;\n    float\tmind = 1e5;\n    p.z += 2.;\n    rotate(p.xz, 1.57-.5*iTime);\n    rotate(p.yz, 1.57-.5*iTime);\n    vec2 q = vec2(mix(mylength(p.xy), length(p.xy), abs(sin(iTime)) )-2.,p.z);\n    var = atan(p.x,p.y);\n    rotate(q, var+iTime*2.);\n    q = abs(q)-.5;\n    rotate(q, var*-3.+iTime*2.);\n    var = cos(floor(var*6.)*.5+iTime*3. );\n    ret_col = 1.-vec3(.5-var*.5, .5, .3+var*.5);\n    mind = mylength(q)-.125-.1*var;\n    h += vec3(.5,.8,.5)*(var!=0.?0.:1.)*vec3(1.)*.0125/(.01+(mind-var*.1)*(mind-var*.1) );\n    h += vec3(.5,.8,.5)*(var!=0.?1.:0.)*vec3(1.)*.0125/(.01+mind*mind);\n    \n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n\t    \tp = pos + dir * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x*.2; // makes artefacts disappear\n\t        if (dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n    \n    p = p*p*p*p;\n    p = p*p;\n    ret = (p.x+p.y);\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,\n           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,\n           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lXBWj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[427, 569, 612, 612, 1020], [1022, 1022, 1043, 1043, 1665], [1667, 1667, 1699, 1699, 2110], [2112, 2112, 2136, 2136, 2254], [2256, 2270, 2310, 2310, 2385], [2387, 2387, 2415, 2415, 2523], [2525, 2525, 2547, 2547, 2753], [2755, 2755, 2805, 2805, 3068]], "test": "untested"}
{"id": "4lXBzj", "name": "nlights", "author": "Del", "description": "northern lights test, based on water caustic shader", "tags": ["lines"], "likes": 5, "viewed": 261, "published": "Public", "date": "1512423351", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// water closeup / sky lines... something... who knows\n\nvoid mainImage(out vec4 k, vec2 p)\n{\n    const vec4 col1 = vec4(0.62,.44,.81,1.0);\n    const vec4 col2 = vec4(0.08,.08,.0,1.0);\n    const mat3 _m = mat3(-2.0,-1.0,2.0, 3.0,-2.0,1.0, 1.0,2.0,2.0);\n    vec2 uv = p.xy / iResolution.xy;\n    \n    vec4 d = vec4(iTime*.04);\n    \n    \n    d.xy = uv;\n    d.y *=0.015;\n    d.x *= 0.725;\n\n    d.xyw *=_m*.5;\n    float v1 = length(.5-fract(d.xyw));\n    d.xyw *=_m*.4;\n    float v2 = length(.5-fract(d.xyw));\n    d.xyw *=_m*.3;\n    float v3 = length(.5-fract(d.xyw));\n    \n    \n    float v = pow(min(min(v1,v2),v3),4.)*13.37+uv.y*1.55;\n    k = mix(col2,col1,v);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lXBzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 56, 92, 92, 657]], "test": "untested"}
{"id": "4lXfDf", "name": "A-Eye", "author": "whitenoise", "description": "Can't really take credit for any of this - noise functions are from the 'Digital Brain' shader and the overall idea is from a Filterforge filter I like.", "tags": ["techeye"], "likes": 4, "viewed": 326, "published": "Public", "date": "1513689815", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// 1D random numbers\nfloat rand(float n)\n{\n    return fract(sin(n) * 43758.5453123);\n}\n\n// 2D random numbers\nvec2 rand2(in vec2 p)\n{\n\treturn fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\n\n// 1D noise\nfloat noise1(float p)\n{\n\tfloat fl = floor(p);\n\tfloat fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n// voronoi distance noise, based on iq's articles\nfloat voronoi(in vec2 x)\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\t\n\tvec2 res = vec2(8.0);\n\tfor(int j = -1; j <= 1; j ++)\n\t{\n\t\tfor(int i = -1; i <= 1; i ++)\n\t\t{\n\t\t\tvec2 b = vec2(i, j);\n\t\t\tvec2 r = vec2(b) - f + rand2(p + b);\n\t\t\t\n\t\t\t// chebyshev distance, one of many ways to do this\n\t\t\tfloat d = max(abs(r.x), abs(r.y));\n\t\t\t\n\t\t\tif(d < res.x)\n\t\t\t{\n\t\t\t\tres.y = res.x;\n\t\t\t\tres.x = d;\n\t\t\t}\n\t\t\telse if(d < res.y)\n\t\t\t{\n\t\t\t\tres.y = d;\n\t\t\t}\n\t\t}\n\t}\n\treturn res.y - res.x;\n}\n\nfloat ring(in vec2 pos, float _min, float _max, float lines, float thick, float rot)\n{\n    float ang = atan(pos.y, pos.x) + rot;\n    float wrapped = fract(mod((ang / 3.14159265359), 1.0) * lines);\n    float v = 4.0*smoothstep(0.0, thick, wrapped) * smoothstep(thick, 0.0, wrapped);\n    \n    float d = length(pos);\n    \n    \n    v = (v * step(_min, d) * (1.0 - step(_max, d)));\n    return pow(v, 0.4);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float flicker = noise1(iTime * 2.0) * 0.8 + 0.4;\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = (uv - 0.5) * 2.0;\n\tvec2 suv = uv;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    float amp1 = 1.0 - voronoi(uv + vec2(iTime*0.1, 0.0));\n    float amp2 = 1.0 - voronoi(uv * 2.5 + vec2(4.5 + - iTime*0.05, 5.5 - iTime*0.1));\n    \n\n    \n    \n    amp1 = 2.0*smoothstep(0.945, 0.99, amp1) * smoothstep(0.99, 0.945, amp1) + 3.0*smoothstep(0.84, 0.86, amp1)*smoothstep(0.86, 0.840, amp1) +\n        + 2.0*smoothstep(0.74, 0.76, amp1)*smoothstep(0.76, 0.740, amp1);\n    amp2 = 0.25*smoothstep(0.95, 1.0, amp2) + 1.5*smoothstep(0.74, 0.76, amp2)*smoothstep(0.76, 0.740, amp2);\n\tamp2 *= 2.0;\n    amp2 += 0.5;\n    \n  \n    // uncomment for weird mode\n    \n    /*\n    uv.x += 0.1*sin(iTime*0.34) * cos(iTime*0.11313);\n\n    uv.y += 0.8 * abs(uv.x) * max(suv.y, 0.0);\n   \tuv.y = uv.y * uv.y * 1.2;\n    */\n    \n    // weird mode option 2\n    //uv.xy *= uv.xy;\n\n    float rings = 0.5 * ring(uv + vec2(sin(iTime*1.3513)*sin(iTime*2.)*0.01, (sin(iTime*1.33)*0.05)), 0.1, 0.35, 5. + floor(15.*rand(floor(sin(15.0 * iTime)))), 0.2, sin(iTime*0.5)  * noise1(10.0 * iTime) ) +\n            ring(uv, 0.5, 0.80, 11.0, 0.17, -iTime * 0.25) +\n        ring(uv, 0.7, 0.95, 3.0, 0.67 * abs(noise1(4.0 * iTime)), sin(iTime * 2.335) * noise1(4.0 * iTime) )\n        ;\n    \n\n        \n        \n    rings *= 2.0;\n    // vignetting\n    vec2 sc = (fragCoord.xy/iResolution.xy)*2.-1.;\n    float vign = (1.1-.5*dot(sc.xy,sc.xy));\n    float midShad = length(uv) * 0.5;\n    midShad *= midShad;\n    vec4 col = vec4(0.0, 0.6, 0.9, 1.0);\n    //col = vec4(1.0, 0.2, 0.2, 1.0);\n    fragColor = col * (18.0*amp1*amp1 * amp2 * midShad + rings) * vign * vign;\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lXfDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 22, 43, 43, 87], [89, 110, 133, 133, 225], [227, 239, 262, 262, 351], [353, 403, 429, 429, 868], [870, 870, 956, 956, 1272], [1275, 1275, 1332, 1332, 3048]], "test": "untested"}
{"id": "4lXfRs", "name": "Rainbow Ripple", "author": "nmacholl", "description": "This is my first shader. Just the default \"new\" shader with a rotating center point that anchors some ripples. The ripples are generated using the tan() function with varying frequencies.", "tags": ["beginner", "colorful"], "likes": 5, "viewed": 475, "published": "Public API", "date": "1512839813", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tJust a colorful shader.\n*/\n\n#define M_PI 3.14159\n\nint numRipples = 12;\n\nvec2 center ()\n{\n    // Center point that orbits the screen center.\n\tvec2 c = vec2(0.5, 0.5);\n    c.x += 0.1 * cos(iTime);\n    c.y += 0.1 * sin(iTime);\n    return c;\n}\n\nbool inRange(float n, float lower, float upper)\n{\n\treturn n > lower && n < upper;    \n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Color w/ White Center\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n\tfragColor = vec4(uv, 0.5 + 0.2*sin(iTime), 1.0);\n    fragColor = fragColor / distance(uv, center());\n    float d = distance(uv, center());\n    \n    // Ripples\n    for (int u = 0; u < numRipples; u++)\n    {    \n        float phi = M_PI/float(u) * iTime;\n        float width = float(u) / float(numRipples);\n        vec2 ripple = vec2(0.1 * float(u) + 0.1*tan(phi), 0.1*float(u) + width + 0.1*tan(phi));\n        if (inRange(d, ripple.x, ripple.y))\n        {\n            fragColor = 0.9*fragColor;   \n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lXfRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 76, 92, 143, 243], [245, 245, 294, 294, 332], [338, 338, 395, 424, 1032]], "test": "untested"}
{"id": "4lXfzS", "name": "Triangle distance in 2D", "author": "madware", "description": "Getting the distance to the triangle in 2D space alongside with its barycentric coords and checking if a point is in triangle or not", "tags": ["sdf", "barycentric"], "likes": 4, "viewed": 214, "published": "Public", "date": "1512196140", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define cross2(v0, v1) v0.x * v1.y - v0.y * v1.x\n#define IsIn(b) all(greaterThan(b, vec3(0.)))\n\nfloat lineDistanceWork(in vec2 p0, in vec2 p0p, in vec2 p1p, in vec2 p0p1, in vec2 p)\n{\n    vec2 p0p1Norm = normalize(p0p1);\n    \n    float t = dot(p0p, p0p1Norm);    \n    float nearestDistance = abs(cross2(p0p, p0p1Norm));\n        \n    return mix(\n        nearestDistance*nearestDistance,\n        min(dot(p0p,p0p), dot(p1p,p1p)),\n        float(t <= 0.0 || t*t >= dot(p0p1,p0p1))\n    );  \n}    \n\nfloat lineDistance(in vec2 p0, in vec2 p1, in vec2 p)\n{\n    vec2 p0p = p - p0;\n    vec2 p1p = p - p1;\n    vec2 p0p1 = p1 - p0;\n    \n    return sqrt(lineDistanceWork(p0, p0p, p1p, p0p1, p));  \n}\n\nfloat triangleDistance(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p, out vec3 barycentric)\n{\n    vec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n    \n    float a = cross2(e0, e1);\n    \n    //Calculate distance to the triangle as a min distance to it's edges\n    float dst = \n        sqrt(min(min\n        (\n            lineDistanceWork(p0, v0, v1, e0, p),\n            lineDistanceWork(p1, v1, v2, e1, p)\n        ),  lineDistanceWork(p2, v2, v0, e2, p)));\n    \n    //Using simplified 2d version of barycentric coords\n    vec2 bar2 = vec2(cross2(v1, v2), cross2(v2, v0)) / a;\n    barycentric = vec3(bar2, 1.0 - bar2.x - bar2.y);\n    \n    bool isInside = IsIn(barycentric);\n    //When we inside a triangle the distance is negative\n    return dst * mix(1.0, -1.0, float(isInside));    \n}\n\nvec2 rotate(vec2 inVec, float a)\n{\n    float cs = cos(a);\n    float sn = sin(a);\n    mat2 m =\n        mat2(  cs, -sn,\n               sn,  cs );\n    return m * inVec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    vec2 cntr = vec2(0.5, 0.5);\n    cntr.x = cntr.x / iResolution.y * iResolution.x;\n    \n    vec2 a = cntr + rotate(vec2(-0.2, -0.125), iTime);\n    vec2 b = cntr + rotate(vec2( 0.2, -0.125), iTime) * 0.7;\n    vec2 c = cntr + rotate(vec2( 0.0, -0.125 + 0.2 * tan(3.1416 / 3.0)), iTime) * 1.3;\n    \n    vec3 baryc;\n    float dst = triangleDistance(a, b, c, uv, baryc) * 5.0;    \n        \n    fragColor = vec4(\n        (0.8 + 0.2*cos(120.0*dst)) * mix(mix(\n            baryc, \n            vec3(0.97, 0.37, 0.0) * (1.0 - dst*.3), \n            float(dst > 0.0)\n        ), vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(dst))), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lXfzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 183, 183, 486], [492, 492, 547, 547, 685], [687, 687, 780, 780, 1542], [1544, 1544, 1578, 1578, 1711], [1713, 1713, 1770, 1770, 2434]], "test": "untested"}
{"id": "4lXfzX", "name": "SlimeHoles", "author": "Del", "description": "sinmagic", "tags": ["slime"], "likes": 2, "viewed": 94, "published": "Public", "date": "1512594514", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// um, some kind of mystical hole...?\n\nfloat glint(vec2 p)\n{\n    vec2 uv = p;\n    float speed = 0.68;\n    float linewidth = 1.38;\n    float grad = 3.0;\n    vec2 linepos = uv;\n    linepos.x = linepos.x - mod(iTime*speed,4.0)+2.0;\n    float y = linepos.x*grad;\n\tfloat s = smoothstep( y-linewidth, y, linepos.y) - smoothstep( y, y+linewidth, linepos.y); \n    return s;\n}\n\nfloat _glint(vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float speed = iTime*0.2;\n \tfloat d = 1.0+p.x*0.25;\n    vec2 cst = vec2( cos(d+speed), sin(d+speed) );\n    float zoom = 1.0+(0.5*sin(iTime*0.675));\n    mat2 rot = zoom * mat2(cst.x,-cst.y,cst.y,cst.x);\n    float s = glint(p*rot*0.44);\n    return s;\n}\n\nvoid mainImage(out vec4 k, vec2 p)\n{\n    const vec4 col1 = vec4(0.0,.1,.1,1.0);\n    const vec4 col2 = vec4(0.5,0.9,0.3,1.0);\n    vec2 uv = p.xy / iResolution.xy;\n\tfloat gl = _glint(p)*0.5;\n    \n    float speed = iTime*0.2;\n \tfloat _fd = 1.0+uv.x*uv.y*0.5;\n    vec2 cst = vec2( cos(_fd+speed), sin(_fd+speed) );\n    float zoom = 3.0+(0.5*sin(iTime*0.55));\n    mat2 rot = zoom * mat2(cst.x,-cst.y,cst.y,cst.x);\n    uv = rot*uv;\n    \n    \n    float s = sin(iTime*0.1);\n    float s2 = 0.5+sin(iTime*1.8);\n    vec2 d = uv*(4.0+s*.3);\t\t\t\t\t\t// mod 4.0 for irregularity...\n    \n    d.x += iTime*0.25+sin(d.x+d.y + iTime*0.3)*0.5;\n    d.y += iTime*0.25+sin(d.x + iTime*0.3)*0.5;\t//-(s*0.5);\n    float v1=length(0.5-fract(d.xy))+0.75;\t\t\t\t// 0.9 =more gooey bits, 1.2 = less gooey bits\n\n    d = 0.15+(uv*0.7);\t\t\t// zoom\n    float v2=length(0.5-fract(d.xy));\n    v1 *= 1.0-v2*v1;\n    v1 = v1*v1*v1;\n    v1 *= 1.9+s2*0.2;\n    k = mix(col2,col1,v1)*(3.4+(s2*0.2));\n    k *= 1.0-(v2);\n    \n    \n    if (k.g<=0.4)\n    {\n        float m = 1.0-clamp(k.g,0.0,0.5);\n\t\tfloat f = mod( floor(12.0*uv.x) + floor(12.0*uv.y), 2.0);\n        float col = 0.3 + 0.5*f*1.0;\n        k.x = k.y = k.z = col*m;\n    }\n    else\n    {\n\t\tfloat f = mod( floor(12.0*uv.x) + floor(12.0*uv.y), 2.0);\n        vec4 _col = 0.2*f*vec4(0.175);\n        k+=_col;\n    }\n    // glint\n    k *=vec4(1.0+gl);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lXfzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 60, 60, 367], [369, 369, 400, 400, 721], [723, 723, 759, 759, 2083]], "test": "untested"}
{"id": "4t2BRz", "name": "The Walking Raymarcher 2", "author": "Yuma_Yanagisawa", "description": "hugely based on https://www.shadertoy.com/view/Mt3XWH. several tweaks and fixes for webgl 2.0", "tags": ["raymarching"], "likes": 7, "viewed": 157, "published": "Public", "date": "1514320514", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// some tweaks for webGl2.0\n\n// Created by XORXOR, 2016\n// Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)\n// https://www.shadertoy.com/view/Mt3XWH\n//\n// Replaying mocap data with hand-tuned shape animation for Codevember 2016.\n// Inspired by Universal Everything's Walking City\n// https://vimeo.com/85596568\n// and makio64's Codevember sketches\n// http://makiopolis.com/codevember/\n\n\n// I don't believe there's no better way to read an array with a non-constant index. Is there?\n#define returnPos() vec3 p0, p1; for(int i=0; i<NUM_FRAMES-1; i++){ if(i==n) { p0=p[i]; p1=p[i+1]; break;}} return mix( p0, p1, f );\n\n#define NUM_FRAMES 21\n\nvec3 getSpine2( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(0.0368,9.18,-0.389); p[1] = vec3(0.036,9.19,-0.386); p[2] = vec3(0.0326,9.19,-0.367); p[3] = vec3(0.0294,9.2,-0.347); p[4] = vec3(0.0272,9.2,-0.33); p[5] = vec3(0.0276,9.2,-0.334); p[6] = vec3(0.029,9.2,-0.345); p[7] = vec3(0.0307,9.19,-0.358); p[8] = vec3(0.0327,9.19,-0.371); p[9] = vec3(0.0346,9.19,-0.383); p[10] = vec3(0.0363,9.18,-0.389); p[11] = vec3(0.0377,9.19,-0.378); p[12] = vec3(0.0388,9.19,-0.357); p[13] = vec3(0.0395,9.2,-0.337); p[14] = vec3(0.0397,9.2,-0.33); p[15] = vec3(0.0396,9.2,-0.336); p[16] = vec3(0.0394,9.2,-0.347); p[17] = vec3(0.0391,9.19,-0.359); p[18] = vec3(0.0387,9.19,-0.371); p[19] = vec3(0.0381,9.19,-0.381); p[20] = vec3(0.0373,9.19,-0.388);\n\treturnPos();\n}\n\nvec3 getLWrist( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(0.829,9.28,2.77); p[1] = vec3(0.817,9.29,2.74); p[2] = vec3(0.809,9.32,2.55); p[3] = vec3(0.972,9.31,2.36); p[4] = vec3(1.27,9.22,2.12); p[5] = vec3(1.62,9.05,1.83); p[6] = vec3(2,8.84,1.38); p[7] = vec3(2.32,8.63,0.77); p[8] = vec3(2.5,8.45,0.0625); p[9] = vec3(2.52,8.33,-0.505); p[10] = vec3(2.54,8.27,-0.816); p[11] = vec3(2.8,8.25,-0.958); p[12] = vec3(3.29,8.36,-0.936); p[13] = vec3(3.8,8.61,-0.774); p[14] = vec3(4.12,8.92,-0.361); p[15] = vec3(4.16,9.19,0.259); p[16] = vec3(3.88,9.24,1.01); p[17] = vec3(3.35,9.25,1.72); p[18] = vec3(2.67,9.28,2.27); p[19] = vec3(1.93,9.33,2.62); p[20] = vec3(1.21,9.33,2.77);\n\treturnPos();\n}\n\nvec3 getHead( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(-0.181,12.1,-0.778); p[1] = vec3(-0.163,12.1,-0.763); p[2] = vec3(-0.0746,12.2,-0.687); p[3] = vec3(0.0121,12.2,-0.6); p[4] = vec3(0.0886,12.2,-0.514); p[5] = vec3(0.138,12.2,-0.444); p[6] = vec3(0.193,12.2,-0.425); p[7] = vec3(0.252,12.2,-0.467); p[8] = vec3(0.303,12.2,-0.564); p[9] = vec3(0.337,12.1,-0.667); p[10] = vec3(0.354,12.1,-0.727); p[11] = vec3(0.349,12.1,-0.647); p[12] = vec3(0.311,12.2,-0.484); p[13] = vec3(0.234,12.2,-0.361); p[14] = vec3(0.141,12.2,-0.317); p[15] = vec3(0.0452,12.2,-0.353); p[16] = vec3(-0.0365,12.2,-0.417); p[17] = vec3(-0.102,12.2,-0.504); p[18] = vec3(-0.149,12.2,-0.603); p[19] = vec3(-0.175,12.2,-0.696); p[20] = vec3(-0.183,12.1,-0.762);\n\treturnPos();\n}\n\nvec3 getSpine1( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(1.75e-08,8.01,-0.0366); p[1] = vec3(1.75e-08,8.01,-0.0366); p[2] = vec3(1.75e-08,8.01,-0.0366); p[3] = vec3(1.75e-08,8.01,-0.0366); p[4] = vec3(1.75e-08,8.01,-0.0366); p[5] = vec3(1.75e-08,8.01,-0.0366); p[6] = vec3(1.75e-08,8.01,-0.0366); p[7] = vec3(1.75e-08,8.01,-0.0366); p[8] = vec3(1.75e-08,8.01,-0.0366); p[9] = vec3(1.75e-08,8.01,-0.0366); p[10] = vec3(1.75e-08,8.01,-0.0366); p[11] = vec3(1.75e-08,8.01,-0.0366); p[12] = vec3(1.75e-08,8.01,-0.0366); p[13] = vec3(1.75e-08,8.01,-0.0366); p[14] = vec3(1.75e-08,8.01,-0.0366); p[15] = vec3(1.75e-08,8.01,-0.0366); p[16] = vec3(1.75e-08,8.01,-0.0366); p[17] = vec3(1.75e-08,8.01,-0.0366); p[18] = vec3(1.75e-08,8.01,-0.0366); p[19] = vec3(1.75e-08,8.01,-0.0366); p[20] = vec3(1.75e-08,8.01,-0.0366);\n\treturnPos();\n}\n\nvec3 getRElbow( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(-1.13,9.51,-3.53); p[1] = vec3(-1.18,9.53,-3.52); p[2] = vec3(-1.46,9.69,-3.48); p[3] = vec3(-1.93,9.89,-3.3); p[4] = vec3(-2.52,10.1,-2.89); p[5] = vec3(-3.04,10.3,-2.25); p[6] = vec3(-3.35,10.3,-1.48); p[7] = vec3(-3.4,10.1,-0.669); p[8] = vec3(-3.14,9.84,0.164); p[9] = vec3(-2.68,9.58,0.756); p[10] = vec3(-2.26,9.38,1.03); p[11] = vec3(-2.09,9.17,1.04); p[12] = vec3(-2.13,8.94,0.857); p[13] = vec3(-2.22,8.71,0.521); p[14] = vec3(-2.31,8.53,0.0537); p[15] = vec3(-2.38,8.43,-0.531); p[16] = vec3(-2.43,8.47,-1.25); p[17] = vec3(-2.35,8.65,-2); p[18] = vec3(-2.12,8.93,-2.67); p[19] = vec3(-1.77,9.21,-3.16); p[20] = vec3(-1.36,9.43,-3.45);\n\treturnPos();\n}\n\nvec3 getLShoulder( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(0.905,10.8,-0.53); p[1] = vec3(0.918,10.8,-0.517); p[2] = vec3(0.977,10.8,-0.456); p[3] = vec3(1.03,10.7,-0.407); p[4] = vec3(1.09,10.7,-0.385); p[5] = vec3(1.12,10.6,-0.407); p[6] = vec3(1.16,10.6,-0.472); p[7] = vec3(1.19,10.6,-0.574); p[8] = vec3(1.21,10.6,-0.698); p[9] = vec3(1.22,10.5,-0.807); p[10] = vec3(1.22,10.5,-0.869); p[11] = vec3(1.21,10.5,-0.83); p[12] = vec3(1.2,10.6,-0.723); p[13] = vec3(1.16,10.6,-0.623); p[14] = vec3(1.12,10.7,-0.557); p[15] = vec3(1.07,10.7,-0.529); p[16] = vec3(1.02,10.8,-0.513); p[17] = vec3(0.983,10.8,-0.508); p[18] = vec3(0.95,10.8,-0.514); p[19] = vec3(0.926,10.8,-0.525); p[20] = vec3(0.91,10.8,-0.532);\n\treturnPos();\n}\n\nvec3 getLKnee( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(0.785,3.85,-0.624); p[1] = vec3(0.943,3.84,-0.57); p[2] = vec3(1.27,3.83,0.0486); p[3] = vec3(1.71,4.02,0.562); p[4] = vec3(2.12,4.33,0.882); p[5] = vec3(2.29,4.51,1.01); p[6] = vec3(2.37,4.79,1.31); p[7] = vec3(2.36,5.21,1.7); p[8] = vec3(2.09,5.31,1.97); p[9] = vec3(1.51,5.01,2.09); p[10] = vec3(0.769,4.38,1.67); p[11] = vec3(0.454,4.24,1.45); p[12] = vec3(0.446,4.23,1.41); p[13] = vec3(0.504,3.96,0.814); p[14] = vec3(0.562,3.87,0.356); p[15] = vec3(0.598,3.87,0.156); p[16] = vec3(0.623,3.87,-0.0922); p[17] = vec3(0.654,3.89,-0.36); p[18] = vec3(0.702,3.91,-0.605); p[19] = vec3(0.767,3.9,-0.661); p[20] = vec3(0.819,3.86,-0.619);\n\treturnPos();\n}\n\nvec3 getLElbow( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(2.32,9.16,1.03); p[1] = vec3(2.32,9.11,1.01); p[2] = vec3(2.33,8.88,0.885); p[3] = vec3(2.36,8.66,0.652); p[4] = vec3(2.42,8.46,0.287); p[5] = vec3(2.5,8.37,-0.181); p[6] = vec3(2.53,8.35,-0.795); p[7] = vec3(2.43,8.41,-1.51); p[8] = vec3(2.13,8.54,-2.2); p[9] = vec3(1.78,8.67,-2.65); p[10] = vec3(1.64,8.78,-2.87); p[11] = vec3(1.87,9,-2.92); p[12] = vec3(2.34,9.33,-2.79); p[13] = vec3(2.73,9.63,-2.53); p[14] = vec3(3.05,9.82,-2.18); p[15] = vec3(3.27,9.84,-1.75); p[16] = vec3(3.38,9.68,-1.18); p[17] = vec3(3.33,9.49,-0.559); p[18] = vec3(3.14,9.35,0.0245); p[19] = vec3(2.85,9.27,0.518); p[20] = vec3(2.52,9.21,0.885);\n\treturnPos();\n}\n\nvec3 getRHip( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(-0.847,6.35,-0.0933); p[1] = vec3(-0.847,6.35,-0.0938); p[2] = vec3(-0.85,6.35,-0.0979); p[3] = vec3(-0.856,6.36,-0.109); p[4] = vec3(-0.863,6.37,-0.127); p[5] = vec3(-0.87,6.38,-0.149); p[6] = vec3(-0.877,6.38,-0.173); p[7] = vec3(-0.882,6.38,-0.198); p[8] = vec3(-0.886,6.38,-0.222); p[9] = vec3(-0.889,6.37,-0.246); p[10] = vec3(-0.89,6.36,-0.266); p[11] = vec3(-0.89,6.35,-0.277); p[12] = vec3(-0.887,6.34,-0.277); p[13] = vec3(-0.882,6.33,-0.262); p[14] = vec3(-0.875,6.31,-0.24); p[15] = vec3(-0.867,6.3,-0.214); p[16] = vec3(-0.858,6.29,-0.185); p[17] = vec3(-0.851,6.29,-0.157); p[18] = vec3(-0.847,6.3,-0.131); p[19] = vec3(-0.845,6.31,-0.11); p[20] = vec3(-0.846,6.33,-0.0968);\n\treturnPos();\n}\n\nvec3 getRShoulder( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(-1.03,10.5,-1.06); p[1] = vec3(-1.02,10.5,-1.05); p[2] = vec3(-0.963,10.6,-1.02); p[3] = vec3(-0.912,10.7,-0.96); p[4] = vec3(-0.873,10.7,-0.88); p[5] = vec3(-0.856,10.8,-0.789); p[6] = vec3(-0.839,10.8,-0.714); p[7] = vec3(-0.818,10.8,-0.668); p[8] = vec3(-0.798,10.8,-0.656); p[9] = vec3(-0.783,10.8,-0.662); p[10] = vec3(-0.775,10.8,-0.666); p[11] = vec3(-0.781,10.8,-0.612); p[12] = vec3(-0.806,10.8,-0.531); p[13] = vec3(-0.852,10.8,-0.485); p[14] = vec3(-0.902,10.7,-0.501); p[15] = vec3(-0.95,10.7,-0.573); p[16] = vec3(-0.988,10.6,-0.664); p[17] = vec3(-1.01,10.6,-0.767); p[18] = vec3(-1.03,10.6,-0.873); p[19] = vec3(-1.04,10.5,-0.967); p[20] = vec3(-1.03,10.5,-1.04);\n\treturnPos();\n}\n\nvec3 getRWrist( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(-1.6,8.04,-1.82); p[1] = vec3(-1.65,8.05,-1.84); p[2] = vec3(-1.99,8.08,-1.94); p[3] = vec3(-2.54,8.13,-1.96); p[4] = vec3(-3.3,8.3,-1.75); p[5] = vec3(-3.96,8.55,-1.12); p[6] = vec3(-4.18,8.71,-0.0801); p[7] = vec3(-3.77,8.73,1.11); p[8] = vec3(-2.76,8.78,2.16); p[9] = vec3(-1.57,8.95,2.67); p[10] = vec3(-0.714,9.18,2.71); p[11] = vec3(-0.359,9.3,2.55); p[12] = vec3(-0.396,9.31,2.32); p[13] = vec3(-0.576,9.29,2.02); p[14] = vec3(-0.845,9.19,1.69); p[15] = vec3(-1.15,9,1.32); p[16] = vec3(-1.47,8.65,0.829); p[17] = vec3(-1.72,8.32,0.182); p[18] = vec3(-1.82,8.12,-0.545); p[19] = vec3(-1.78,8.03,-1.19); p[20] = vec3(-1.66,8.03,-1.65);\n\treturnPos();\n}\n\nvec3 getRAnkle( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(-0.994,1.24,2.41); p[1] = vec3(-0.587,1.02,2.41); p[2] = vec3(-0.478,0.89,1.7); p[3] = vec3(-0.466,0.664,0.998); p[4] = vec3(-0.4,0.473,0.322); p[5] = vec3(-0.354,0.463,-0.229); p[6] = vec3(-0.338,0.502,-0.778); p[7] = vec3(-0.343,0.586,-1.36); p[8] = vec3(-0.374,0.715,-1.93); p[9] = vec3(-0.412,0.938,-2.51); p[10] = vec3(-0.464,1.33,-3.08); p[11] = vec3(-0.46,1.96,-3.65); p[12] = vec3(-0.48,2.61,-3.87); p[13] = vec3(-0.531,2.99,-3.45); p[14] = vec3(-0.503,2.98,-2.8); p[15] = vec3(-0.587,2.74,-2.06); p[16] = vec3(-0.745,2.89,-1.29); p[17] = vec3(-0.861,2.99,-0.664); p[18] = vec3(-0.918,2.69,-0.0864); p[19] = vec3(-0.881,1.83,0.69); p[20] = vec3(-0.72,1.2,1.79);\n\treturnPos();\n}\n\nvec3 getLHip( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(0.892,6.35,-0.129); p[1] = vec3(0.892,6.35,-0.129); p[2] = vec3(0.889,6.34,-0.125); p[3] = vec3(0.883,6.33,-0.114); p[4] = vec3(0.876,6.32,-0.0966); p[5] = vec3(0.867,6.31,-0.0752); p[6] = vec3(0.857,6.31,-0.0521); p[7] = vec3(0.848,6.31,-0.0284); p[8] = vec3(0.839,6.32,-0.00525); p[9] = vec3(0.83,6.32,0.0163); p[10] = vec3(0.823,6.33,0.0347); p[11] = vec3(0.819,6.34,0.0452); p[12] = vec3(0.822,6.35,0.0448); p[13] = vec3(0.832,6.37,0.0323); p[14] = vec3(0.845,6.38,0.0128); p[15] = vec3(0.858,6.39,-0.0113); p[16] = vec3(0.871,6.4,-0.0381); p[17] = vec3(0.882,6.41,-0.0654); p[18] = vec3(0.89,6.4,-0.0911); p[19] = vec3(0.893,6.38,-0.112); p[20] = vec3(0.893,6.36,-0.126);\n\treturnPos();\n}\n\nvec3 getRKnee( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(-1.22,4.58,1.71); p[1] = vec3(-0.858,4.26,1.37); p[2] = vec3(-0.798,4.27,1.37); p[3] = vec3(-0.742,4.07,0.989); p[4] = vec3(-0.691,3.88,0.358); p[5] = vec3(-0.675,3.85,0.0894); p[6] = vec3(-0.676,3.84,-0.139); p[7] = vec3(-0.683,3.85,-0.405); p[8] = vec3(-0.702,3.88,-0.674); p[9] = vec3(-0.736,3.9,-0.837); p[10] = vec3(-0.799,3.89,-0.849); p[11] = vec3(-0.891,3.88,-0.876); p[12] = vec3(-1.11,3.86,-0.778); p[13] = vec3(-1.54,3.87,-0.371); p[14] = vec3(-1.86,3.98,0.0739); p[15] = vec3(-2.03,4.17,0.562); p[16] = vec3(-2.14,4.56,1.18); p[17] = vec3(-2.13,4.98,1.61); p[18] = vec3(-1.97,5.14,1.84); p[19] = vec3(-1.58,4.88,1.86); p[20] = vec3(-1.2,4.57,1.7);\n\treturnPos();\n}\n\nvec3 getLAnkle( int n, float f )\n{\n\tvec3 p[ NUM_FRAMES ];\n\tp[0] = vec3(0.645,1.27,-2.85); p[1] = vec3(0.941,1.62,-3.15); p[2] = vec3(1.01,2.52,-3.04); p[3] = vec3(1.03,3.06,-2.54); p[4] = vec3(1.13,3.11,-2.02); p[5] = vec3(1.25,2.87,-1.66); p[6] = vec3(1.35,2.77,-1.08); p[7] = vec3(1.32,2.86,-0.344); p[8] = vec3(1.02,2.5,0.608); p[9] = vec3(0.784,1.73,1.76); p[10] = vec3(0.342,1.1,2.54); p[11] = vec3(-0.128,0.972,2.24); p[12] = vec3(0.0519,0.846,1.48); p[13] = vec3(0.129,0.568,0.847); p[14] = vec3(0.204,0.475,0.281); p[15] = vec3(0.266,0.485,-0.211); p[16] = vec3(0.301,0.534,-0.758); p[17] = vec3(0.355,0.618,-1.31); p[18] = vec3(0.454,0.738,-1.85); p[19] = vec3(0.602,0.952,-2.39); p[20] = vec3(0.721,1.22,-2.78);\n\treturnPos();\n}\n\nvec3 head, spine1, spine2;\nvec3 lHip, lKnee, lAnkle, lShoulder, lElbow, lWrist;\nvec3 rHip, rKnee, rAnkle, rShoulder, rElbow, rWrist;\n\nfloat smin( float a, float b )\n{\n    const float k = 2.9;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat tRidgeStrength = 0.2;\nfloat tRidgeFreq = 10.0;\nvec3 tLatticeRadii = vec3( 0.0 );\nfloat tR = 1.2;\n\nvec2 map( vec3 p )\n{\n    float plane = abs( p.y + 0.9 );\n\n    vec3 q = mod( p, 1.0 ) - 0.5;\n    float lattice = min( length( q.xy ) - tLatticeRadii.x,\n                    min( length( q.yz ) - tLatticeRadii.y,\n                         length( q.xz ) - tLatticeRadii.z ) );\n    \n    p.y -= tRidgeStrength * ( 2.0 - p.y * 0.1 ) * ( 1.0 +  sin( p.y * tRidgeFreq ) );\n\n    float d = length( p - head ) - tR;\n    d = smin( d, length( p - spine1 ) - tR );\n    d = smin( d, length( p - spine2 ) - tR );\n    d = smin( d, length( p - lHip ) - tR );\n    d = smin( d, length( p - lKnee ) - tR );\n    d = smin( d, length( p - lAnkle ) - 1.5 * tR );\n    d = smin( d, length( p - lShoulder ) - tR );\n    d = smin( d, length( p - lElbow ) - 0.8 * tR );\n    d = smin( d, length( p - lWrist ) - 0.7 * tR );\n    \n    d = smin( d, length( p - rHip ) - tR );\n    d = smin( d, length( p - rKnee ) - tR );\n    d = smin( d, length( p - rAnkle ) - 1.5 * tR );\n    d = smin( d, length( p - rShoulder ) - tR );\n    d = smin( d, length( p - rElbow ) - 0.8 * tR );\n    d = smin( d, length( p - rWrist ) - 0.7 * tR );\n    \n    d = max( d, -lattice );\n    return ( d < plane ) ? vec2( d, 1.0 ) : vec2( plane, 2.0 );\n}\n\nfloat calcShadow( vec3 ro, vec3 rd, float mint, float maxt )\n{\n    float t = mint;\n    float res = 1.0;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float h = map( ro + rd * t ).x;\n        res = min( res, 1.1 * h / t );\n        t += h;\n        if ( ( h < 0.001 ) || ( t > maxt ) )\n        {\n            break;\n        }\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec2 trace( vec3 ro, vec3 rd )\n{\n    const float kTMin = 0.01;\n    const float kTMax = 200.0;\n    const float kEps = 0.001;\n\n    float t = kTMin;\n    vec2 res;\n    for ( int i = 0; i < 80; i++ )\n    {\n        vec3 pos = ro + rd * t;\n        res = map( pos );\n        if ( ( res.x < kEps ) || ( t > kTMax ) )\n        {\n            break;\n        }\n        t += res.x * 0.5;\n    }\n\n    if ( t < kTMax )\n    {\n        return vec2( t, res.y );\n    }\n    else\n    {\n        return vec2( -1.0 );\n    }\n}\n\nvec3 calcNormal( vec3 p )\n{\n    const vec2 e = vec2( 0.005, 0 );\n    float dp = map( p ).x;\n    return normalize( vec3( dp - map( p - e.xyy ).x,\n                            dp - map( p - e.yxy ).x,\n                            dp - map( p - e.yyx ).x ) );\n}\n\nmat3 calcCamera( vec3 eye, vec3 target )\n{\n    vec3 cw = normalize( target - eye );\n    vec3 cu = cross( cw, vec3( 0, 1, 0 ) );\n    vec3 cv = cross( cu, cw );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float walkTime = mod( 10.0 * iTime, float( NUM_FRAMES - 1 ) );\n    int t = int( floor( walkTime ) );\n    float fTime = fract( walkTime );\n    head = getHead( t, fTime );\n    spine1 = getSpine1( t, fTime );\n    spine2 = getSpine2( t, fTime );\n    lHip = getLHip( t, fTime );\n    lKnee = getLKnee( t, fTime );\n    lAnkle = getLAnkle( t, fTime );\n    lShoulder = getLShoulder( t, fTime );\n\tlElbow = getLElbow( t, fTime );\n\tlWrist = getLWrist( t, fTime );\n    rHip = getRHip( t, fTime );\n\trKnee = getRKnee( t, fTime );\n    rAnkle = getRAnkle( t, fTime );\n\trShoulder = getRShoulder( t, fTime );\n\trElbow = getRElbow( t, fTime );\n\trWrist = getRWrist( t, fTime );\n    \n    float trTime = mod( iTime, 20.0 );\n    \n    tRidgeStrength = 0.2;\n\ttRidgeFreq = 0.0;\n    tLatticeRadii = vec3( 0.0 );\n    tR = 1.2;\n    \n    if ( trTime < 5.0 )\n    {\n        tRidgeStrength = 0.2;\n\t\ttRidgeFreq = 0.0;\n\t\ttLatticeRadii = vec3( 0.0 ); \n    }\n    else\n    if ( trTime < 10.0 )\n    {\n        tRidgeFreq = 10.0 * smoothstep( 5.0, 10.0, trTime );  \n    }\n    else\n    if ( trTime < 15.0 )\n    {\n        tRidgeFreq = 10.0;\n    }\n    else \n    if(trTime < 20.0)\n    {\n        tRidgeFreq = 10.0 * smoothstep( 10.0, 5.0, trTime -10.);\n    }\n\n\n    vec2 mo = vec2( 0.95, -0.2 );\n    if ( iMouse.z > 0.5 )\n    {\n        mo = 2.0 * iMouse.xy / iResolution.xy - 1.0;\n        mo *= 3.14159 * vec2( 0.4, 0.1 );\n    }\n    mo += 3.14159 * 0.5;\n\n    vec3 eye = vec3( 40.0 * cos( mo.x ), 30.0 + 20.0 * cos( mo.y ), 40.0 * sin( mo.x ) );\n    vec3 target = vec3( 0.0, 6.0, 0.0 );\n    \n    mat3 cam = calcCamera( eye, target );\n\n \tvec2 uv = ( fragCoord.xy - 0.5 * iResolution.xy ) / iResolution.y;\n    vec3 rd = cam * normalize( vec3( uv, 2.0 ) );\n\n    vec3 col = vec3( 1.0 );\n    \n    vec2 res = trace( eye, rd );\n    if ( res.x > 0.0 )\n    {\n        vec3 pos = eye + rd * res.x;\n        vec3 nor = calcNormal( pos );\n        vec3 ldir = normalize( vec3( -10.5, 20.8, 24.0 ) );\n        \n        if ( res.y < 1.5 )\n        {\n        \tcol = 0.5 + 0.5 * nor;\n            float dif = max( dot( nor, ldir ), 0.0 );\n            vec3 ref = reflect( rd, nor );\n            float spe = pow( clamp( dot( ref, ldir ), 0.0, 1.0 ), 15.0 );\n\n            col *= ( 0.3 + 0.7 * dif );\n            float edge = pow( 1.0 - dot( -rd, nor ), 1.1 );\n        \tcol += 0.8 * edge + spe;\n        }\n      \n        float sh = calcShadow( pos, ldir, 0.1, 30.0 );\n        col *= ( 0.5 + sh );\n    }\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2BRz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-4.0", "functions": [[410, 662, 696, 696, 1428], [1430, 1430, 1464, 1464, 2137], [2139, 2139, 2171, 2171, 2905], [2907, 2907, 2941, 2941, 3748], [3750, 3750, 3784, 3784, 4482], [4484, 4484, 4521, 4521, 5225], [5227, 5227, 5260, 5260, 5951], [5953, 5953, 5987, 5987, 6665], [6667, 6667, 6699, 6699, 7439], [7441, 7441, 7478, 7478, 8209], [8211, 8211, 8245, 8245, 8939], [8941, 8941, 8975, 8975, 9697], [9699, 9699, 9731, 9731, 10460], [10462, 10462, 10495, 10495, 11207], [11209, 11209, 11243, 11243, 11946], [12082, 12082, 12114, 12114, 12232], [12338, 12338, 12358, 12358, 13525], [13527, 13527, 13589, 13589, 13893], [13895, 13895, 13927, 13927, 14392], [14394, 14394, 14421, 14421, 14650], [14652, 14652, 14694, 14694, 14843], [14845, 14845, 14902, 14902, 17370]], "test": "untested"}
{"id": "4t2Bzh", "name": "Enigma", "author": "KK", "description": "A tribute to Phenomena - raytraced scene from 1991 Amiga demo \"Enigma\". Today in real-time inside your browser. Time goes fast.", "tags": ["raymarching", "fractal", "demoscene", "spheres", "amiga", "enigma", "phenomena", "1991", "spheretracing"], "likes": 11, "viewed": 827, "published": "Public API", "date": "1514581297", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat sph(vec3 pos,float y)\n{\n\tpos.y -= y;\n\tpos.z += 3.0*sin((y/1.5+iTime*4.0-1.0)*0.5);\n\treturn length(pos)-1.0;\n}\n\nfloat sphs(vec3 pos)\n{\n\tpos.y -= iTime*(1.5*4.0);\n\tpos.z = abs(pos.z);\n    float s = 0.8;\n\treturn min(\n\t\tmin( sph(pos,floor(pos.y*s    )/s),\n\t\t     sph(pos,floor(pos.y*s+1.0)/s) ),1.0);\n}\n\nfloat FieldFn(vec3 pos)\n{\n\tfloat h = pos.z+0.5;\n\tpos.y -= iTime*6.0;\n\treturn min(\n\t\tmin( sph(pos,floor(pos.y    )),\n\t\t     sph(pos,floor(pos.y+1.0)) ),min(h,1.0));\n}\n\nvec4 fractal(vec2 cx)\n{\n\tcx.x += 0.1;\n\tcx.y += 0.1;\n\tvec2 z = cx;\n\tfloat cc = 1.0;\n\tfor(int i=0;i<22;i++)\n\t{\n\t\tvec2 z1;\n\t\tz1.x = z.x*z.x - z.y*z.y + cx.x;\n\t\tz1.y = 2.0*z.x*z.y + cx.y;\n\t\tz = z1;\n        if(dot(z,z)>4.0)\n        {\n            cc = float(i)/21.0;\n            break;\n        }\n\t\t//cc += clamp((dot(z,z)-4.0)*10.0,0.0,1.0)/21.0;\n\t}\n    if(cc>1.0-0.2) return vec4(0,0,0.1,0);\n    cc *= 2.5;\n    cc += 0.5;\n    cc /= 1.0+length(cx);\n    return vec4(cc,cc,cc*2.0,0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vpos = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tvpos.x *= iResolution.x/iResolution.y;\n\tvpos *= .8;\n\t\n    \n\tvec2 mpos = iMouse.xy / iResolution.xy*2. - 1.;\n\tvec3 front = normalize(vec3(-1.,-mpos.x,mpos.y-.5));\n\tvec3 pos = vec3(0,0,1.2)-front*6.0;\n    \n    \n\tfront = normalize(vec3(-1,-0.7,0));\n\tvec3 up = vec3(0,0,1);\n\tvec3 right = cross(up,front);\n\tpos = vec3(1,-2,1.2)-front*4.0;\n\t\n\tvec3 vdir = normalize(front + vpos.x*right + vpos.y*up);\n\tvec3 tdir = normalize(vdir);\n\tvec3 tpos = pos;\n\tfloat g = 0.0;\n\tvec4 c = vec4(0.0);\n\tfloat d, m=0.0;\n\tvec3 lpos = vec3(10,10,0);\n\n\tfor(int i=0;i<150;i++)\n\t{\n\t\tif(g>=1.0) break;\n\t\td = sphs(tpos);\n\t\tif(d<0.002) break;\n\t\ttpos += d*tdir;\n\t\tg += d*0.02;\n\t}\n\n\tif(d<0.002)\n\t{\n\t\tvec3 normal, ld = normalize(vec3(4,-2,4));\n\t\tnormal.x = sphs(tpos+vec3(0.01,0,0)) - d;\n\t\tnormal.y = sphs(tpos+vec3(0,0.01,0)) - d;\n\t\tnormal.z = sphs(tpos+vec3(0,0,0.01)) - d;\n\t\tnormal = normalize(normal);\n\t\tc = vec4(clamp(dot(normal,ld),0.0,1.0));\n\t\tc *= vec4(0.2,1,0.3,0.0);\n\t\tc += c.y*pow(clamp(dot(ld,reflect(tdir,normal)),0.0,1.0),64.0);\n\t}\n\tfloat a = 0.41*2.0*3.141593;\n\tfloat ss = sin(a);\n\tfloat cc = cos(a);\n\tif(tdir.z<0.0 && (d>=0.002 || tpos.z<0.0))\n\t{\n\t\tfloat t = -pos.z/tdir.z;\n\t\ttpos = pos + tdir*t;\n\t\ttpos.xy *= 0.3;\n\t\t//tpos.x += 6.0;\n\t\t//tpos.y += 13.5;\n\t\ttpos.xy *= 0.5;\n        tpos.x -= 0.3;\n\t\ttpos = vec3(tpos.x*cc-tpos.y*ss,tpos.y*cc+tpos.x*ss,tpos.z);\n\t\ttpos.x -= 0.7+0.65;\n\t\ttpos.y -= 0.27;\n\t\tc *= 0.3;\n\t\tc += fractal(tpos.xy);\n\t\tc += mix(vec4(1,0,0.5,0),vec4(0.0),pow(-tdir.z*2.0,0.1));\n\t}\n\telse if(d>=0.002)\n\t{\n\t\tc = mix(vec4(1,0,0,0),vec4(0,0,0.7,0),sqrt(tdir.z*1.5));\n\t}\n\n\t\n\tfragColor = floor(c*32.0)/32.0;\n}\n", "image_inputs": [{"id": "MsBSzD", "previewfilepath": "https://soundcloud.com/firefox-amigamusician/hyperbased", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/firefox-amigamusician/hyperbased", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2Bzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 30, 30, 116], [118, 118, 140, 140, 305], [307, 307, 332, 332, 472], [474, 474, 497, 497, 951], [954, 954, 1011, 1011, 2669]], "test": "untested"}
{"id": "4t2fR1", "name": "Ray Marching Phong Template", "author": "alijaya", "description": "Some Ray Marching with 2 light", "tags": ["raymarching"], "likes": 2, "viewed": 591, "published": "Public API", "date": "1514592675", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON 0.01\n#define MIN_DISTANCE 0.0\n#define MAX_DISTANCE 2000.0\n#define MAX_MARCHING_STEP 256\n\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction, always normalized\n};\n\nstruct Camera {\n\tvec3 pos;\n    vec3 lookAt;\n    float focal;\n    vec2 sensorSize;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n};\n    \nvec3 xe = vec3(EPSILON, 0., 0.);\nvec3 ye = vec3(0., EPSILON, 0.);\nvec3 ze = vec3(0., 0., EPSILON);\n\n// get corresponding ray from uv (0.0 -> 1.0)\nRay getRay( Camera cam, vec2 uv ) {\n    vec3 camDir = normalize(cam.lookAt - cam.pos); // the camera direction\n    vec3 center = cam.pos + cam.focal * camDir; // get the coordinate of the screen center\n    vec2 coord = (uv - 0.5) * cam.sensorSize; // convert from 0.0 -> 1.0 to -sensorSize / 2. -> sensorSize / 2.\n    \n    // axis relative to camera\n    vec3 zpos = -camDir; // k hat, outward the screen\n    vec3 xpos = cross(vec3(0., 1., 0.), zpos); // i hat, cross from ypos global and zpos local\n    vec3 ypos = cross(zpos, xpos); // j hat, cross from zpos local and xpos local\n    \n    // target in screen\n    vec3 target = center + coord.x * xpos + coord.y * ypos; // get pixel target coordinate from the screen\n    \n    Ray ray;\n    ray.o = cam.pos; // the origin of the ray is from the camera duh\n    ray.d = normalize(target - cam.pos); // the direction is from the camera to the target\n    \n    return ray;\n}\n\n// project point to ray\nvec3 projPoint2Ray( vec3 point, Ray ray ) {\n    vec3 rel = point - ray.o; // get relative vector from the point to the ray origin\n    float len = dot(rel, ray.d); // project that vector to vector direction of the ray, we get the length\n    return len * ray.d + ray.o; // multiply the length with unit vector direction and add to ray origin\n}\n\n// get the distance from point to ray (or line)\nfloat distPoint2Ray( vec3 point, Ray ray ) {\n    vec3 proj = projPoint2Ray(point, ray); // project it first to the ray\n    return distance(proj, point); // get the distance from the projected position to the original position\n}\n\n// just linear interpolation, map value v between fromA and fromB to between toA and toB\nfloat lerp( float v, float fromA, float fromB, float toA, float toB ) {\n    return (v - fromA) / (fromB - fromA) * (toB - toA) + toA;\n}\n\n// sphere function\nfloat sdSphere( vec3 p, float radius ) {\n    return length(p) - radius;\n}\n\n// box function\nfloat sdBox( vec3 p, float width, float height, float depth ) {\n    vec3 d = abs(p) - vec3(width, height, depth);\n    return max(d.x, max(d.y, d.z));\n}\n\n// cylinder function\nfloat sdCylinder( vec3 p, float radius, float height ) {\n    return max(length(p.xz) - radius, abs(p.y) - height);\n}\n\nfloat sdUnion( float sd1, float sd2 ) {\n    return min(sd1, sd2);\n}\n\nfloat sdIntersect( float sd1, float sd2 ) {\n    return max(sd1, sd2);\n}\n\nfloat sdSubstract( float sd1, float sd2 ) {\n    return max(sd1, -sd2);\n}\n\n// change this\nfloat sdScene( vec3 p ) {\n    float sphere = sdSphere( p, 220. );\n    float box = sdBox(p, 200., 50., 200.);\n    float cylinder = sdCylinder(p, 150., 250.);\n    return sdSubstract(sdIntersect(box, sphere), cylinder);\n}\n\n// estimate normal with nudging\nvec3 estimateNormal( vec3 p ) {\n    return normalize(vec3(\n    \tsdScene(p+xe) - sdScene(p-xe),\n        sdScene(p+ye) - sdScene(p-ye),\n        sdScene(p+ze) - sdScene(p-ze)\n    ));\n}\n\n// ray marching algorithm\nfloat getSDF( Ray r ) {\n    float depth = MIN_DISTANCE;\n    for (int i=0; i<MAX_MARCHING_STEP; i++) {\n        float dist = sdScene( r.o + depth * r.d );\n        \n        if (dist < EPSILON) { // inside a scene\n            return depth;\n        }\n        \n        depth += dist; // circle marching!\n        \n        if (depth >= MAX_DISTANCE) {\n            return MAX_DISTANCE;\n        }\n    }\n    \n    return MAX_DISTANCE;\n}\n\nvec3 ambientLight( vec3 ambientColor ) {\n    return ambientColor;\n}\n\nvec3 phongLight( vec3 diffuseColor, vec3 specularColor, float shininess, Ray ray, float dist, Light light ) {\n    vec3 p = ray.o + dist * ray.d;\n    \n    vec3 N = estimateNormal(p); // surface normal\n    vec3 L = normalize(light.pos - p); // surface to light direction\n    vec3 V = -ray.d; // surface to camera direction\n    vec3 R = reflect(-L, N); // mirror of L by the axis N\n    \n    float dotLN = dot(L, N); // project light direction to surface normal\n    float dotRV = dot(R, V); // project light reflection direction to direction to camera\n    \n    vec3 color = vec3(0.);\n    if (dotLN > 0.) { // we can see the diffuse\n        color += diffuseColor * dotLN;\n    }\n    if (dotRV > 0.) { // we can see the specular\n        color += specularColor * pow(dotRV, shininess);\n    }\n    color *= light.color; // influence of color of the light\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // convert from fragCoord (0.0 -> iResolution.xy) to uv (0.0 -> 1.0)\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 circleMovement = vec3(600. * cos(iTime * 2.), 600. * cos(iTime * 2.), 600. * sin(iTime * 2.)); // to get circle movement\n    \n    // set camera\n    Camera cam;\n    cam.sensorSize = iResolution.xy; // set sensor size to the screenSize\n    cam.focal = 200.; // set the focal length (distance between sensor (screen) to the aperture\n    cam.lookAt = vec3(0., 0., 0.); // where to look at (this camera use two point system)\n    cam.pos = circleMovement; // the position of the camera\n    \n    // get ray\n    Ray ray = getRay(cam, uv); // get corresponding ray, given the uv\n    \n    // create 8 points of cube\n    vec3 points[8];\n    for (int i=0; i<2; i++) {\n        for (int j=0; j<2; j++) {\n            for (int k=0; k<2; k++) {\n                points[i*4+j*2+k] = vec3(float(i) * 2. - 1., float(j) * 2. - 1., float(k) * 2. - 1.);\n            }\n        }\n    }\n    \n    // render\n    float dist = getSDF(ray);\n    if (dist > MAX_DISTANCE - EPSILON) { // don't hit anything, set to background\n        fragColor = vec4(0.);\n        return; // or discard?\n    }\n    \n    vec3 ambientColor = vec3(0.1, 0.1, 0.2);\n    vec3 diffuseColor = vec3(0.7, 0.2, 0.2);\n    vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    float shininess = 50.0;\n    \n    Light light1;\n    light1.pos = vec3(500. * sin(iTime), 500. * cos(iTime), 400.);\n    light1.color = vec3(1., 0.5, 0.3);\n    \n    Light light2;\n    light2.pos = vec3(1000. * cos(iTime), 400., 1000. * sin(iTime));\n    light2.color = vec3(1., 0.8, 0.5);\n    \n    vec3 color = vec3(0.);\n    color += ambientLight(ambientColor);\n    color += phongLight(diffuseColor, specularColor, shininess, ray, dist, light1);\n    color += phongLight(diffuseColor, specularColor, shininess, ray, dist, light2);\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2fR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[427, 473, 508, 508, 1390], [1392, 1416, 1459, 1459, 1757], [1759, 1807, 1851, 1851, 2034], [2036, 2125, 2196, 2196, 2260], [2262, 2281, 2321, 2321, 2354], [2356, 2372, 2435, 2435, 2523], [2525, 2546, 2602, 2602, 2662], [2664, 2664, 2703, 2703, 2731], [2733, 2733, 2776, 2776, 2804], [2806, 2806, 2849, 2849, 2878], [2880, 2895, 2920, 2920, 3113], [3115, 3147, 3178, 3178, 3328], [3330, 3356, 3379, 3379, 3780], [3782, 3782, 3822, 3822, 3849], [3851, 3851, 3960, 3960, 4715], [4717, 4717, 4774, 4847, 6666]], "test": "untested"}
{"id": "4t2fRz", "name": "Procedural film grain", "author": "luluco250", "description": "Nice and smooth.\n\n", "tags": ["2d", "noise", "filter", "random", "film", "grain"], "likes": 18, "viewed": 2563, "published": "Public API", "date": "1514325674", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Feel free to steal this :^)\n// Consider it MIT licensed, you can link to this page if you want to.\n\n#define SHOW_NOISE 0\n#define SRGB 0\n// 0: Addition, 1: Screen, 2: Overlay, 3: Soft Light, 4: Lighten-Only\n#define BLEND_MODE 0\n#define SPEED 2.0\n#define INTENSITY 0.075\n// What gray level noise should tend to.\n#define MEAN 0.0\n// Controls the contrast/variance of noise.\n#define VARIANCE 0.5\n\nvec3 channel_mix(vec3 a, vec3 b, vec3 w) {\n    return vec3(mix(a.r, b.r, w.r), mix(a.g, b.g, w.g), mix(a.b, b.b, w.b));\n}\n\nfloat gaussian(float z, float u, float o) {\n    return (1.0 / (o * sqrt(2.0 * 3.1415))) * exp(-(((z - u) * (z - u)) / (2.0 * (o * o))));\n}\n\nvec3 madd(vec3 a, vec3 b, float w) {\n    return a + a * b * w;\n}\n\nvec3 screen(vec3 a, vec3 b, float w) {\n    return mix(a, vec3(1.0) - (vec3(1.0) - a) * (vec3(1.0) - b), w);\n}\n\nvec3 overlay(vec3 a, vec3 b, float w) {\n    return mix(a, channel_mix(\n        2.0 * a * b,\n        vec3(1.0) - 2.0 * (vec3(1.0) - a) * (vec3(1.0) - b),\n        step(vec3(0.5), a)\n    ), w);\n}\n\nvec3 soft_light(vec3 a, vec3 b, float w) {\n    return mix(a, pow(a, pow(vec3(2.0), 2.0 * (vec3(0.5) - b))), w);\n}\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1.0) / iResolution.xy;\n    vec2 uv = coord * ps;\n    color = texture(iChannel0, uv);\n    #if SRGB\n    color = pow(color, vec4(2.2));\n    #endif\n    \n    float t = iTime * float(SPEED);\n    float seed = dot(uv, vec2(12.9898, 78.233));\n    float noise = fract(sin(seed) * 43758.5453 + t);\n    noise = gaussian(noise, float(MEAN), float(VARIANCE) * float(VARIANCE));\n    \n    #if SHOW_NOISE\n    color = vec4(noise);\n    #else    \n    // Ignore these mouse stuff if you're porting this\n    // and just use an arbitrary intensity value.\n    float w = float(INTENSITY);\n    if (iMouse.z > 0.0) {\n        w = iMouse.y * ps.y;\n        w *= step(coord.x, iMouse.x);\n    }\n\t\n    vec3 grain = vec3(noise) * (1.0 - color.rgb);\n    \n    #if BLEND_MODE == 0\n    color.rgb += grain * w;\n    #elif BLEND_MODE == 1\n    color.rgb = screen(color.rgb, grain, w);\n    #elif BLEND_MODE == 2\n    color.rgb = overlay(color.rgb, grain, w);\n    #elif BLEND_MODE == 3\n    color.rgb = soft_light(color.rgb, grain, w);\n    #elif BLEND_MODE == 4\n    color.rgb = max(color.rgb, grain * w);\n    #endif\n        \n    #if SRGB\n    color = pow(color, vec4(1.0 / 2.2));\n    #endif\n    #endif\n}\n", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2fRz.jpg", "access": "shaders20k", "license": "mit", "functions": [[330, 396, 438, 438, 517], [519, 519, 562, 562, 657], [659, 659, 695, 695, 723], [725, 725, 763, 763, 834], [836, 836, 875, 875, 1028], [1030, 1030, 1072, 1072, 1143], [1145, 1145, 1189, 1189, 2365]], "test": "untested"}
{"id": "4tBBRD", "name": "r3dux 3D Starfield Test 2", "author": "r3dux", "description": "31/12/2017 - First attempt at making a 3D starfield - only learnt how to use a little ShaderToy today, so the struggle is definitely real! ", "tags": ["3d", "stars"], "likes": 3, "viewed": 264, "published": "Public", "date": "1514718223", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 red = vec3(1.0, 0.1, 0.1);\nvec3 green = vec3(0.1, 1.0, 0.1);\nvec3 blue = vec3(0.1, 0.1, 1.0);\n\nfloat rand(float t)\n{\n    return fract(sin(t * 123.456) * 768.89);\n}\n\nvec3 rotateX(vec3 v, float angleRads)\n{ \n\tfloat c = cos(angleRads);\n    float s = sin(angleRads);\n  \treturn vec3(v.x, v.y * c - v.z * s, v.y * s + v.z * c);\n}\n\nvec3 rotateY(vec3 v, float angleRads)\n{ \n\tfloat c = cos(angleRads);\n    float s = sin(angleRads);\n  \treturn vec3(v.x * c + v.z * s, v.y, -v.x * s + v.z * c);\n}\n\nvec3 rotateZ(vec3 p, float angleRads) { \n\tfloat c = cos(angleRads);\n    float s = sin(angleRads);\n  \treturn vec3(c*p.x+s*p.y, -s*p.x+c*p.y, p.z);\n}\n\nfloat distanceFromPointToLine(vec3 rayOrigin, vec3 rayDirection, vec3 point)\n{\n\treturn length(cross(point - rayOrigin, rayDirection)) / length(rayDirection);   \n}\n\nvoid drawPoint(vec3 rayOrigin, vec3 rayDirection, vec3 point, float size, float blur, out vec4 fragColor, int starNum, float t)\n{\n    float dist = distanceFromPointToLine(rayOrigin, rayDirection, point);\n    \n    dist = smoothstep(size, size * (1.0 - blur), dist); // 2nd param means blur is always that percentage of point size\n                      \n    vec3 col = vec3(0.0);    \n    if (starNum % 3 == 0) { col = red;   }\n    if (starNum % 3 == 1) { col = green; }\n    if (starNum % 3 == 2) { col = blue;  }\n    \n    fragColor += vec4(vec3(dist * col), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy; // Range is 0 to 1    \n    uv -= vec2(0.5);                         // Adjust range to -0.5 to +0.5 so (0,0) is in centre of screen \n\tuv.x *= iResolution.x / iResolution.y;   // Correct aspect ratio\n    float t = iTime * 0.3;                   // Get the time and slow it down by multiplying by a small value\n    \n\tvec3 rayOrigin = vec3(0.0, 0.0, 0.0); // i.e. Camera origin\n    \n    vec3 lookAt = vec3(0.0, 0.0, 1); // Looking into the screen (negative on the Z-axis points outward from the screen)\n    \n    // Generate ortho camera normal basis using global Y-axis for up when generating right (positive X-axis) vector\n    float zoom = 1.0;\n    vec3 forward = normalize(lookAt - rayOrigin);\n    vec3 right = cross(vec3(0.0, 1.0, 0.0), forward);\n    vec3 up = cross(forward, right);\n    \n    vec3 centreOfScreen = rayOrigin + forward * zoom;     \n    vec3 intersection = centreOfScreen + uv.x * right + uv.y * up;        \n    vec3 rayDirection = intersection - rayOrigin;\n    \n    vec3 point = vec3(0.4, 0.4, 15.0);\n    \n    float pointSize = 0.1;\n    float pointBlur = 0.3;\n    \n    const float numParticles = 20.0;\n    float loopStep = 1.0 / numParticles;\n    int starNum = 0;\n    \n    float oneTenthRads = 6.28 / 10.0;\n    \n    for (int camTwistLoop = 0; camTwistLoop < 10; camTwistLoop++)\n    {\n    \n        for (float loop = 0.0; loop < 1.0; loop += loopStep)\n        {\n            float timeStepped = fract(t + loop);\n\n            drawPoint( rayOrigin, rayDirection, vec3(point.x, point.y, point.z - timeStepped * point.z), pointSize, pointBlur, fragColor, starNum++, t);\n        }\n        \n        point = rotateZ(point, oneTenthRads * t * 2.0);        \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBBRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 121, 121, 168], [170, 170, 209, 209, 328], [330, 330, 369, 369, 489], [491, 491, 530, 530, 638], [640, 640, 718, 718, 802], [804, 804, 933, 933, 1367], [1369, 1369, 1426, 1426, 3146]], "test": "untested"}
{"id": "4tBcDc", "name": "work_2", "author": "Kakaricho", "description": "pad", "tags": ["screensaver", "work"], "likes": 0, "viewed": 85, "published": "Public", "date": "1513573629", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // 画面上の座標を求める.\n    // iTimeは、現在の時間経過に関する値で時間経過で変化するようなアニメーション表現に利用する.\n    // この例では、iTimeをsin関数に与えることで周期的な色の変化を行なっている。\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = vec4(1.0,1.0,0,1);// vec4(uv, 0.5 + 0.5 * sin(iTime), 1.0);\n    \n    //color = vec4(uv, 0.5 + 0.5 * sin(iTime), 1.0);\n    \n    // 画面上の座標値を　[0.0 ~ 1.0]　から [-1.0 ~ 1.0] へ変更\n    // uvは0 ~ 1\n    vec2 pos = uv * 2.0 - 1.0;\n    \n    \n    highp int pos_x_int = int(pos.x * 50.0);\n    highp int pos_y_int = int(pos.y * 30.0);\n    \n    //color *= abs(1.0 / (sin(pos.x + iTime * .7) * 70.0));\n    \n    //color *= abs(1.0 / (sin(pos.x + iTime * .7) * 7.0));\n    color *= abs(1.0 / (sin( float(pos_x_int % 50) + iTime * .7) * 7.0));\n    \n    \n    //color *= abs(sin( float(pos_y_int % 4) * iTime ) );\n    color *= abs(sin( float(pos_y_int % 4 ) * iTime) );\n    \n    //color *= abs(1.0 / (sin(pos.x + cos(pos.y + iTime) * 0.6) * sin(iTime * .3) * 70.0));\n    //color *= abs(1.0 / (sin(pos.y + cos(pos.x + iTime) * 0.2) * sin(iTime * .3) * 70.0));\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBcDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 348, 1303]], "test": "untested"}
{"id": "4tBfRh", "name": "Circular Waves", "author": "aiekick", "description": "Circular Waves", "tags": ["waves", "circular"], "likes": 4, "viewed": 575, "published": "Public API", "date": "1514415609", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// new base code for the quad template of SoShade :)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // central coord\n\tvec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y;\n    \n    // fracted length\n    float d = abs(fract(dot(uv, uv) - iTime * 0.5) - 0.5) + 0.3;\n    \n    // fracted angle\n    float a = abs(fract(atan(uv.x,uv.y) / 6.283 * 5.) - 0.5) + 0.2;\n    \n    //only waves\n    //fragColor = vec4(d * vec3(0.2, 1.0, 0.6), 1.0);\n    \n    //only rays\n    //fragColor = vec4(a * vec3(0.2, 0.8, 0.5), 1.0);\n    \n    // mixed\n    if (a < d) // inverted shape => (a > d)\n\t\tfragColor = vec4(d * vec3(0.2, 1.0, 0.6), 1.0);\n    else\n        fragColor = vec4(a * vec3(0.2, 0.8, 0.5), 1.0);\n    \n    // another interested things\n    //fragColor = vec4(mix(a * vec3(0.2, 0.8, 0.5),d * vec3(0.2, 1.0, 0.6),d/a), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBfRh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[157, 210, 267, 288, 994]], "test": "untested"}
{"id": "4tfBz2", "name": "A Lonely Palm", "author": "revers", "description": "Just an exercise from texture and modeling.  ", "tags": ["3d", "island", "palm"], "likes": 12, "viewed": 536, "published": "Public API", "date": "1513120591", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Created by Kamil Kolaczynski (revers) - 2017\n *\n * Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * \n * Just an exercise from texture and modeling. As always, most of general raymarching\n * ingredients (raymarch loop, geometric primitives, lighting/shadowing, noise)\n * is based on iq's shaders and articles. Thanks for sharing your knowledge, iq!\n *\n * Referenced shaders:\n * - \"Raymarching - Primitives\" by iq [ https://www.shadertoy.com/view/Xds3zN ]\n * - \"Noise - value - 2D\" by iq [ https://www.shadertoy.com/view/lsf3WH ]\n *\n * Referenced articles:\n * - \"modeling with distance functions\" by iq [ http://iquilezles.org/www/articles/distfunctions/distfunctions.htm ]\n * - \"free penumbra shadows for raymarching distance fields\" by iq [ http://iquilezles.org/www/articles/rmshadows/rmshadows.htm ]\n * \n * The shader was created and exported from Synthclipse (http://synthclipse.sourceforge.net/)\n */\n\nconst vec3 LightDir = vec3(0.057800323, -0.5716256, -0.81847644);\nconst float MarchDumping = 0.9;\nconst float Far = 32.0;\nconst int MaxSteps = 156;\nconst float PalmCocoRadius = 0.206;\nconst float PalmLeafLength = 1.4476738;\nconst vec2 PalmLeafHash = vec2(0.494, 0.485);\nconst float PalmParaAmp = 2.005;\nconst float PalmParaShiftX = -0.32558393;\nconst float PalmParaShiftY = -0.34907204;\nconst float PalmSawAngle = 1.270597;\nconst float PalmSawFreq = 0.15;\nconst float PalmSawShift = 3.355552;\nconst mat3 PalmLeavesRot = mat3(0.43584922, 0.08419673, -0.8960726, -0.50385904, 0.8477993, -0.16541581, 0.7457622, 0.52359074, 0.41193599);\nconst float PalmTrunkSkew = 0.008;\nconst float PalmTrunkLength = 5.0;\nconst float TrunkPower = 1.7391294;\nconst float TrunkPowerFactor = 0.009565654;\nconst vec3 CoconutColor = vec3(0.3529412, 0.16862746, 0.05882353);\n\n#define M_NONE     -1.0\n#define M_SAND      1.0\n#define M_TRUNK     2.0\n#define M_LEAF      3.0\n#define M_COCONUTS  4.0\n#define M_WATER     5.0\n\n#define PI      3.141592\n#define TWO_PI  6.2831852\n\n#define INF     1e7\n\n#define POINTS 8\n\nvec2 LeafAngles[POINTS];\n\nvec2 min2(vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;\n//\treturn mix(a, b, step(b.x, a.x));\n}\n\nvec3 min3(vec3 a, vec3 b) {\n\treturn a.x < b.x ? a : b;\n//\treturn mix(a, b, step(b.x, a.x));\n}\n\n/**\n * Hash function by David Hoskins.\n * https://www.shadertoy.com/view/4djSRW\n */\nvec2 hash21(float p) {\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\n\tp2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));\n}\n\n/**\n * hash by iq.\n */\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\n/**\n * hash by iq.\n */\nfloat hash(vec2 n) {\n\treturn fract(sin(dot(n, vec2(1.0, 113.0))) * 43758.5453123);\n}\n\n/**\n * Procedural Value Noise 2D, by iq.\n * https://www.shadertoy.com/view/lsf3WH\n */\nfloat noise(vec2 p) {\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n\tvec2 a = vec2(0.0, 0.0);\n\tvec2 b = vec2(1.0, 0.0);\n\tvec2 c = vec2(0.0, 1.0);\n\tvec2 d = vec2(1.0, 1.0);\n\n\tfloat n0 = hash(i + a);\n\tfloat n1 = hash(i + b);\n\tfloat n2 = hash(i + c);\n\tfloat n3 = hash(i + d);\n\n\tfloat ix0 = mix(n0, n1, u.x);\n\tfloat ix1 = mix(n2, n3, u.x);\n\n\treturn mix(ix0, ix1, u.y);\n}\n\nvec3 rotateX(vec3 p, float a) {\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec3(p.x, ca * p.y + sa * p.z, ca * p.z - sa * p.y);\n}\n\nvec3 rotateY(vec3 p, float a) {\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec3(ca * p.x + sa * p.z, p.y, ca * p.z - sa * p.x);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec3(ca * p.x + sa * p.y, ca * p.y - sa * p.x, p.z);\n}\n\nvec2 rotate(vec2 p, float a) {\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec2(ca * p.x - sa * p.y, sa * p.x + ca * p.y);\n}\n\n/**\n * http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n */\nfloat sdEllipsoid(vec3 p, vec3 r) {\n\treturn (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat leafParabola(float x) {\n\tx = clamp(x * 0.35, 0.0, 1.0);\n\tx -= PalmParaShiftX;\n\n\treturn -PalmParaAmp * x * (x - 1.0) + PalmParaShiftY;\n}\n\nfloat leafSawtooth(vec3 p) {\n\tp.z = -abs(p.z);\n\tvec2 nor = vec2(cos(PalmSawAngle), sin(PalmSawAngle));\n\n\tp.z += PalmSawShift;\n\n\tp.y = mod(p.y, PalmSawFreq) - PalmSawFreq * 0.5;\n\n\tfloat d = nor.x * p.z + nor.y * p.y - 1.0;\n\td = max(d, -p.y);\n\n\treturn d;\n}\n\nfloat sdLeaf(vec3 p) {\n\tvec3 q = p;\n\tp.z = abs(p.z);\n\tp.xz = rotate(p.xz, PI - PI * 0.35);\n\n\tp.z += leafParabola(p.y);\n\tp.y -= PalmLeafLength + 0.05;\n\n\tfloat d = sdEllipsoid(p, vec3(0.25, PalmLeafLength, 0.04));\n\treturn max(d, -leafSawtooth(q));\n}\n\nvoid initLeafAngles() {\n\tfor (int i = 0; i < POINTS; i++) {\n\t\tvec2 rnd = hash21(float(i) * PalmLeafHash.x + PalmLeafHash.y);\n\n\t\tfloat a = float(i) / float(POINTS) * TWO_PI + (rnd.x * 2.0 - 1.0) * 0.2;\n\t\tLeafAngles[i] = vec2(a, -(rnd.y * PI * 0.25 + 1.25));\n\t}\n}\n\nvec3 sdLeaves(vec3 p) {\n\tp *= PalmLeavesRot;\n\tfloat d = INF;\n\tfloat index = 0.0;\n\n\tconst float len = 0.5;\n\tp.y -= len;\n\n\tfor (int i = 0; i < POINTS; i++) {\n\n\t\tvec3 q = p + vec3(0.0, len, 0.0);\n\n\t\tvec2 ang = LeafAngles[i];\n\t\tq = rotateY(q, ang.x);\n\t\tq = rotateZ(q, ang.y);\n\n\t\tfloat d2 = sdLeaf(q);\n\n\t\t// same as:\n\t\t// if (d2 < d) { index = float(i); }\n\t\tindex = mix(index, float(i), step(d2, d));\n\t\td = min(d, d2);\n\t}\n\treturn vec3(d, M_LEAF, index);\n}\n\nvec2 sdTrunk(vec3 p) {\n\tvec3 q = p;\n\tp.x -= 1.0;\n\tp.y += PalmTrunkLength - 0.15;\n\n\tfloat a = 0.05;\n\tfloat x = p.y;\n\n\tp.xy = rotate(p.xy, -x * x * PalmTrunkSkew);\n\n\tfloat f = clamp(p.y / PalmTrunkLength, 0.0, 1.0);\n\n\t// cylinder with distortions\n\tfloat d = length(p.xz) - 0.18 + pow(f, TrunkPower) * TrunkPowerFactor * 10.0;\n\n\td = max(d, -p.y); // trim bottom\n\td = max(d, (p.y - PalmTrunkLength)); // trim top\n\n\treturn vec2(d, M_TRUNK);\n}\n\nvec2 sdCoconuts(vec3 p) {\n\tp *= PalmLeavesRot;\n\tp.y *= 0.9;\n\tp += vec3(0.1, 0.15, 0.0);\n\tfloat d = dot(p, p);\n\n\tp += vec3(-0.3, 0.0, 0.2);\n\td = min(d, dot(p, p));\n\n\tp += vec3(0.0, 0.0, -0.4);\n\td = min(d, dot(p, p));\n\n\td = sqrt(d) - PalmCocoRadius;\n\treturn vec2(d, M_COCONUTS);\n}\n\nvec2 sdPalmTree(vec3 p) {\n\tvec3 q = p;\n\tq.y -= PalmTrunkLength;\n\tvec2 res = sdLeaves(q).xy;\n\n\tres = min2(res, sdTrunk(q));\n\tres = min2(res, sdCoconuts(q));\n\n\treturn res;\n}\n\nvec2 sdIsland(vec3 p) {\n\tp.x = p.x * 0.8 + p.z * 0.2;\n\n\tp.y -= 0.1 * sin(p.x * 2.0) + 0.6 * cos(p.z * 0.5 - 1.6);\n\n\tp += vec3(-0.7, 3.0, 0.7);\n\n\tfloat d = length(p) - 4.0;\n\n\treturn vec2(d, M_SAND);\n}\n\nvec2 sdWater(vec3 p) {\n\tfloat d = p.y - 0.5 * noise(p.xz + iTime) * 0.3;\n\treturn vec2(d, M_WATER);\n}\n\nvec2 smin(vec2 a, vec2 b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b.x - a.x) / k, 0.0, 1.0);\n\treturn vec2(mix(b.x, a.x, h) - k * h * (1.0 - h), mix(b.y, a.y, h));\n}\n\nvec3 map(vec3 p) {\n\tvec3 q = p;\n\tq.y -= PalmTrunkLength;\n\tvec2 res = sdTrunk(q);\n\n\tres = min2(res, sdCoconuts(q));\n\n\tres = smin(res, sdIsland(p), 0.3);\n\tres = min2(res, sdWater(p));\n\n    return min3(sdLeaves(q), vec3(res, 0.0));\n}\n\nvec3 castRay(vec3 ro, vec3 rd) {\n\tfloat tmin = 0.0;\n\tfloat tmax = Far;\n\n\tfloat precis = 0.002;\n\tfloat t = tmin;\n\tfloat m = M_NONE;\n\tfloat s = 0.0;\n\n\tfor (int i = 0; i < MaxSteps; i++) {\n\t\tvec3 res = map(ro + rd * t);\n\n\t\tif (res.x < precis || t > tmax) {\n\t\t\tbreak;\n\t\t}\n\t\tt += res.x * MarchDumping;\n\t\tm = res.y;\n\t\ts = res.z;\n\t}\n\tif (t > tmax) {\n\t\tm = M_NONE;\n\t}\n\treturn vec3(t, m, s);\n}\n\n/**\n * http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n */\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n\tfloat res = 1.0;\n\tfor (float t = mint; t < maxt;) {\n\n\t\tfloat h = map(ro + rd * t).x;\n\n\t\tif (h < 0.001) {\n\t\t\treturn 0.0;\n\t\t}\n\t\tres = min(res, k * h / t);\n\t\tt += h;\n\t}\n\treturn res;\n}\n\nvec3 calcNormal(vec3 pos) {\n\tvec2 eps = vec2(0.001, 0.0);\n\n\tvec3 nor = vec3(\n\t\t\tmap(pos + eps.xyy).x - map(pos - eps.xyy).x,\n\t\t\tmap(pos + eps.yxy).x - map(pos - eps.yxy).x,\n\t\t\tmap(pos + eps.yyx).x - map(pos - eps.yyx).x);\n\treturn normalize(nor);\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\n\tfor (int i = 0; i < 5; i++) {\n\t\tfloat hr = 0.01 + 0.12 * float(i) / 4.0;\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = map(aopos).x;\n\n\t\tocc += -(dd - hr) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat luma(vec3 col) {\n\t// BT.709\n\treturn dot(col, vec3(0.2126, 0.7152, 0.0722));\n}\n\n/**\n *  Three plannar texture mapping by iq.\n */\nvec3 texcube(sampler2D sa, vec3 p, vec3 n) {\n\tvec3 x = texture(sa, p.yz).xyz;\n\tvec3 y = texture(sa, p.zx).xyz;\n\tvec3 z = texture(sa, p.xy).xyz;\n\n\treturn x * abs(n.x) + y * abs(n.y) + z * abs(n.z);\n}\n\nvec3 bumpMap(sampler2D tex, vec3 pos, vec3 nor, float amount) {\n\tfloat e = 0.001;\n\n\tfloat ref = luma(texcube(tex, pos, nor));\n\n\tvec3 gra = -vec3(luma(texcube(tex, vec3(pos.x + e, pos.y, pos.z), nor)) - ref,\n\t\t\t\t\t luma(texcube(tex, vec3(pos.x, pos.y + e, pos.z), nor)) - ref,\n\t\t\t\t\t luma(texcube(tex, vec3(pos.x, pos.y, pos.z + e), nor)) - ref) / e;\n\n\tvec3 tgrad = gra - nor * dot(nor, gra);\n\treturn normalize(nor - amount * tgrad);\n}\n\nvec3 trunkColor(vec3 pos);\n\nvec3 trunkBumpMap(vec3 pos, vec3 nor, float amount) {\n\tfloat e = 0.001;\n\n\tfloat ref = luma(trunkColor(pos));\n\n\tvec3 gra = -vec3(luma(trunkColor(vec3(pos.x + e, pos.y, pos.z))) - ref,\n\t\t\t\t\t luma(trunkColor(vec3(pos.x, pos.y + e, pos.z))) - ref,\n\t\t\t\t\t luma(trunkColor(vec3(pos.x, pos.y, pos.z + e))) - ref) / e;\n\n\tvec3 tgrad = gra - nor * dot(nor, gra);\n\treturn normalize(nor - amount * tgrad);\n}\n\nvec3 trunkColor(vec3 pos) {\n\tpos.y *= 1.2;\n\tvec3 brown = vec3(0.48, 0.29, 0.070) * 0.7;\n\n\tfloat ang = atan(pos.z, pos.x) * 14.0 + pos.y * 12.0;\n\tfloat y = pos.y + cos(ang) * 0.02;\n\n\tfloat x = cos(y * 14.0);\n\tx *= x;\n\tx *= x;\n\n\treturn mix(brown, brown * 0.6, x);\n}\n\nvec3 leafColor(vec3 pos, float index) {\n\n\t{ // Move leaf to its untransformed coordinates.\n\t\tvec2 ang = LeafAngles[int(index)];\n\n\t\tpos.y -= PalmTrunkLength;\n\t\tpos *= PalmLeavesRot;\n\n\t\tpos = rotateY(pos, ang.x);\n\t\tpos = rotateZ(pos, ang.y);\n\t}\n\tvec3 col = vec3(0.13, 0.46, 0.07);\n\n\tfloat x = pos.y * 1.9 - abs(pos.z) * 0.2;\n\tx = x + hash(x * 0.0005) * 0.12;\n\n\tfloat t = sin(x * 10.0);\n\tt *= t;\n\n\treturn mix(col, col * 0.6, t);\n}\n\nvec3 coconutColor(vec3 pos, vec3 nor) {\n\tpos *= PalmLeavesRot;\n\tvec3 col = CoconutColor * (0.2 + 0.8 * texcube(iChannel1, pos * vec3(1.0, 0.2, 0.5), nor));\n\n\treturn col;\n}\n\nfloat clouds(vec3 rd) {\n\tvec2 uv = rd.xz / (rd.y + 0.2);\n\tuv *= 70.0;\n\n\tuv *= vec2(3.0, 3.0) * 0.005;\n\tvec2 st = uv;\n\n\tfloat t = iTime * 0.3;\n\tuv.x += t * 0.2;\n\n\tfloat f = 0.5 * noise(uv);\n\tuv *= 2.04;\n\tf += 0.25 * noise(uv);\n\tuv *= 2.01;\n\tf += 0.125 * noise(uv);\n\tfloat res = f;\n\tres = smoothstep(0.4, 1.0, res);\n\n\tst += vec2(12.0, 34.5);\n\tst.x += t * 0.3;\n\tfloat g = 0.5 * noise(st);\n\tst *= 2.00;\n\tg += 0.25 * noise(st);\n\tst *= 2.03;\n\tg += 0.125 * noise(st);\n\tst *= 2.04;\n\tg += 0.0625 * noise(st);\n\n\tres += 0.5 * smoothstep(0.5, 0.9, g);\n\n\treturn res * 0.8;\n}\n\nvec3 background(vec3 rd, float sun) {\n\tfloat t = abs(rd.y + 0.4) * 0.9;\n\tt = min(t, 0.8);\n\n\t// sky\n\tvec3 col = mix(vec3(0.9132, 1.002, 1.2), vec3(0.0, 0.3, 1.2), t) * 1.2;\n\n\t// sun\n\tcol = mix(col, vec3(1.0, 1.0, 0.549) * 1.2, pow(sun, 512.0));\n\n\t// clouds\n\tfloat clo = clouds(rd);\n\tcol = mix(col, vec3(1.0), clo);\n\n\treturn min(col, 1.0);\n}\n\n#define _dist(v)  ((v).x)  /* distance */\n#define _mate(v)  ((v).y)  /* material */\n#define _styl(v)  ((v).z)  /* style    */\n\nvec3 render(vec3 ro, vec3 rd) {\n\tinitLeafAngles();\n\n\tvec3 lig = normalize(-LightDir);\n\tfloat sun = clamp(dot(lig, rd), 0.0, 1.0);\n\n\tvec3 bg = background(rd, sun);\n\tvec3 col = bg;\n\n\tvec3 res = castRay(ro, rd);\n\n\tif (_mate(res) > M_NONE) {\n\t\tvec3 pos = ro + _dist(res) * rd;\n\t\tvec3 nor = calcNormal(pos);\n\n\t\tbool isWater = false;\n\t\tfloat spe = 0.0;\n\n\t\tif (_mate(res) == M_WATER) {\n\t\t\tisWater = true;\n\n\t\t\tvec3 rrd = reflect(rd, nor);   // reflected ray direction\n\t\t\tvec3 rro = pos + rrd * 0.01;   // reflected ray origin\n\t\t\tvec3 rres = castRay(rro, rrd); // reflected result\n\n\t\t\tif (_mate(rres) == M_NONE || _mate(rres) == M_WATER) {\n\t\t\t\tcol = background(rrd, sun);\n\t\t\t} else {\n\t\t\t\tro = rro;\n\t\t\t\trd = rrd;\n\t\t\t\tres = rres;\n\t\t\t\tpos = ro + _dist(res) * rd;\n\t\t\t\tnor = calcNormal(pos);\n\t\t\t}\n\t\t}\n\t\tif (_mate(res) <= M_SAND + 0.3) {\n\n\t\t\tvec3 p = pos * 0.3 * 0.9;\n\t\t\tcol = vec3(1.0, 0.827, 0.129) * (1.0 - 0.15 * texcube(iChannel0, p, nor));\n\n\t\t\tnor = bumpMap(iChannel0, p, nor, 0.0008);\n\t\t\tvec3 ref = reflect(rd, nor);\n\t\t\tspe = pow(clamp(dot(ref, lig), 0.0, 1.0), 4.0);\n\n\t\t} else if (_mate(res) <= M_TRUNK) {\n\n\t\t\tcol = trunkColor(pos);\n\t\t\tnor = trunkBumpMap(pos, nor, 0.35);\n\n\t\t} else if (_mate(res) <= M_LEAF) {\n\n\t\t\tcol = leafColor(pos, _styl(res));\n\t\t\tvec3 ref = reflect(rd, nor);\n\t\t\tspe = pow(clamp(dot(ref, lig), 0.0, 1.0), 2.0);\n\n\t\t} else if (_mate(res) <= M_COCONUTS) {\n\n\t\t\tcol = coconutColor(pos, nor);\n\t\t}\n\n\t\t// lighting\n\t\tfloat occ = calcAO(pos, nor);\n\n\t\tfloat amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n\t\tfloat dif = clamp(dot(nor, lig), 0.0, 1.0);\n\t\tfloat fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n\n\t\tdif *= softshadow(pos, lig, 0.02, PalmTrunkLength * 2.0, 240.0);\n\n\t\tvec3 brdf = vec3(0.0);\n\n\t\tbrdf += 1.00 * dif * vec3(1.00, 0.90, 0.60);\n\t\tbrdf += 0.40 * spe * vec3(1.00, 0.90, 0.60) * dif;\n\t\tbrdf += 0.50 * amb * vec3(0.50, 0.70, 1.00) * occ;\n\t\tbrdf += 0.40 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\n\t\tcol = col * brdf;\n\n\t\tif (isWater) {\n\t\t\tcol = mix(vec3(0.0, 0.345, 0.612), col, 0.5);\n            //col = mix(vec3(0.157, 0.718, 0.922), col, 0.5);\n\t\t\tfloat t = _dist(res);\n\t\t\tcol = mix(col, bg, 1.0 - exp(-0.00007 * t * t * t));\n\t\t}\n\t}\n\tcol += 0.15 * vec3(1.0, 0.898, 0.0) * pow(sun, 32.0);\n\n\treturn vec3(clamp(col, 0.0, 1.0));\n}\n\nvoid getCamera(vec2 pix, out vec3 ro, out vec3 rd) {\n\tconst float fov = 0.64;\n\n\tvec2 coord = (-iResolution.xy + 2.0 * pix) / iResolution.y;\n\tcoord *= fov;\n\n\tvec2 mo = iMouse.xy / iResolution.xy;\n\tfloat t = iTime * 0.2 + mo.x * 4.0;\n\n\tvec3 target = vec3(0.0, 3.0, 0.0);\n\tro = vec3(0.0, 2.0, 8.0);\n\n\tfloat s = -0.1 + clamp(mo.y, 0.0, 1.0);\n\tro = rotateX(ro, s);\n\tro = rotateY(ro, t);\n\n\tvec3 dir = normalize(target - ro);\n\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\tup = rotateX(up, s);\n\tup = rotateY(up, t);\n\n\tup = normalize(up);\n\n\tvec3 right = normalize(cross(dir, up));\n\n\trd = normalize(dir + coord.x * right + coord.y * up);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ro, rd;\n\tgetCamera(fragCoord, ro, rd);\n\n\tvec3 col = render(ro, rd);\n\n\tcol = pow(col, vec3(0.4545));\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tfBz2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 2071, 2098, 2098, 2164], [2166, 2166, 2193, 2193, 2259], [2261, 2345, 2367, 2367, 2530], [2532, 2555, 2576, 2576, 2617], [2619, 2642, 2662, 2662, 2726], [2728, 2814, 2835, 2835, 3211], [3213, 3213, 3244, 3244, 3347], [3349, 3349, 3380, 3380, 3483], [3485, 3485, 3516, 3516, 3619], [3621, 3621, 3651, 3651, 3749], [3751, 3829, 3864, 3864, 3923], [3925, 3925, 3954, 3954, 4066], [4068, 4068, 4096, 4096, 4322], [4324, 4324, 4346, 4346, 4571], [4573, 4573, 4596, 4596, 4834], [4836, 4836, 4859, 4859, 5286], [5288, 5288, 5310, 5310, 5725], [5727, 5727, 5752, 5752, 6005], [6007, 6007, 6032, 6032, 6178], [6180, 6180, 6203, 6203, 6379], [6381, 6381, 6403, 6403, 6481], [6483, 6483, 6519, 6519, 6648], [6650, 6650, 6668, 6668, 6880], [6882, 6882, 6914, 6914, 7266], [7268, 7338, 7407, 7407, 7589], [7591, 7591, 7618, 7618, 7838], [7840, 7840, 7874, 7874, 8133], [8135, 8135, 8157, 8168, 8218], [8220, 8269, 8313, 8313, 8467], [8469, 8469, 8532, 8532, 8901], [8931, 8931, 8984, 8984, 9325], [9327, 9327, 9354, 9354, 9590], [9592, 9592, 9631, 9631, 10019], [10021, 10021, 10060, 10060, 10192], [10194, 10194, 10217, 10217, 10755], [10757, 10757, 10794, 10794, 11096], [11225, 11225, 11256, 11256, 13466], [13468, 13468, 13520, 13520, 14085], [14087, 14087, 14144, 14144, 14281]], "test": "untested"}
{"id": "4tjBRz", "name": "Shiny spheres", "author": "iq", "description": "Experimenting with this rendering algorithm, in at attempt to get perfectly antialiased pixels without performing any supersampling. The point being, it should look smooth and [b]also[/b] run fast in all machines. I hope!", "tags": ["3d", "antialiasing", "spheres", "filtering", "analytiv"], "likes": 90, "viewed": 5600, "published": "Public API", "date": "1514357920", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Experimenting with this rendering algorithm, in at attempt to get perfectly antialiased\n// pixels without performing any supersampling.\n//\n// Key ingredients are:\n// 1. analytical sphere to pixel overlap\n//    http://iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\n// 2. analytical surface pattern filtering (ray differentials needed)\n//    http://iquilezles.org/www/articles/morecheckerfiltering/morecheckerfiltering.htm\n// 3. approximate soft shadows with a single ray\n//    http://iquilezles.org/www/articles/sphereshadow/sphereshadow.htm\n\n\n// Algorithm (for eaxh pixel):\n//\n// 1. interesect objects, and record pixel coverage into a list\n// 2. sort list front to back\n// 3. while list contains objects:\n// 4.    shade (with ray differentials for AA)\n// 5.    composite (front to back) \n// 6.    early exit if opaque threshold reached\n// 7. composite with background\n\n\n//-------------------------------------------------------------------------------------------\n\nvec3 sphNormal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n            \nvec2 sphDistances( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    float d = sqrt( max(0.0,sph.w*sph.w-h)) - sph.w;\n    return vec2( d, -b-sqrt(max(h,0.0)) );\n}\n\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    float s = 1.0;\n    vec2 r = sphDistances( ro, rd, sph );\n    if( r.y>0.0 )\n        s = max(r.x,0.0)/r.y;\n    return s;\n}    \n            \nfloat sphOcclusion( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3  r = sph.xyz - pos;\n    float l = length(r);\n    float d = dot(nor,r);\n    float res = d;\n\n    if( d<sph.w ) res = pow(clamp((d+sph.w)/(2.0*sph.w),0.0,1.0),1.5)*sph.w;\n    \n    return clamp( res*(sph.w*sph.w)/(l*l*l), 0.0, 1.0 );\n\n}\n\n//-------------------------------------------------------------------------------------------\n#define NUMSPHERES 30\n\nvec4 sphere[NUMSPHERES];\nfloat sphereF[NUMSPHERES];\nfloat vol;\n\n//-------------------------------------------------------------------------------------------\n\nfloat linesTextureGradBox( in float p, in float ddx, in float ddy, int id )\n{\n    float N = float( 2 + 7*((id>>1)&3) );\n\n    float w = max(abs(ddx), abs(ddy)) + 0.01;\n    float a = p + 0.5*w;                        \n    float b = p - 0.5*w;           \n    return 1.0 - (floor(a)+min(fract(a)*N,1.0)-\n                  floor(b)-min(fract(b)*N,1.0))/(N*w);\n}\n\nfloat computeU( in vec3 pos, in vec4 sph, int id )\n{\n    #if 1\n    vec3 q = normalize( pos - sph.xyz );\n    float a = ((id&1)==1) ? acos(q.y) : atan(q.x,q.z);\n    return 6.0*(3.0/3.141593) * a;\n    #else\n    float a = (pos-sph.xyz)[id&1]/sph.w; \n    a += abs(a*a)*sign(a);\n    return 5.0*(3.0/3.141593) * a;\n    #endif\n}\n\nvec4 shade( in vec3 rd, in vec3 pos, in vec3 ddx_pos, in vec3 ddy_pos, \n            in vec3 nor, in int id, in vec4 sph )\n{\n    // compute UVs and filter shape\n    \n\tfloat u     = computeU(     pos, sph, id );\n    float ddx_u = computeU( ddx_pos, sph, id );\n    float ddy_u = computeU( ddy_pos, sph, id );\n\n    // texture\n\tvec3 col = vec3(0.0, 0.2 + 0.4*clamp(1.0-sph.w*2.0,0.0,2.0),0.8);\n    col *= 1.0 - linesTextureGradBox( u, ddx_u-u, ddy_u-u, id );\n\tcol *= sphereF[id];\n    \n    // lighting\n    \n    vec3 ref = reflect(rd,normalize(nor-0.2*rd)); //vec3 ref = reflect(rd,nor);\n\n\t// compute reflection shadow, ambient occlusion and edge proximty\n    float sha = 1.0;\n\tfloat occ = 1.0;\n\tfloat pro = 1e10;\n\tfor( int i=0; i<NUMSPHERES; i++ )\n    {\n        if( i!=id )\n        {\n        sha = min( sha, 10.0*sphSoftShadow(pos+0.005*nor,ref,sphere[i]) );\n        pro = min( pro, abs(length(pos-sphere[i].xyz)-sphere[i].w) );\n      //occ = min( occ, 1.0 - sphOcclusion( pos, nor, sphere[i] ) );\n\t    occ *= 1.0 - sphOcclusion( pos, nor, sphere[i] ); \n        }\n\t}\n\n    float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n    occ = occ*0.5 + 0.5*occ*occ;\n    \n\t// light-surface interaction\n    vec3 lig = vec3(occ)*1.4;\n    lig *= 0.7 + 0.3*nor.y;\n    lig += 0.5*fre*fre*occ;\n    lig *= col;\n    lig += 1.2*smoothstep(-0.1,0.10,ref.y )*occ*sha * (0.03+0.97*pow(fre,4.0));\n\n    // glow\n\tfloat g = clamp(pro/(1.0+15.0*vol),0.0,0.5*sph.w);\n    lig += (0.2+0.8*vol)*vec3(0.5*vol,0.4+0.4*vol,1.0)*exp(-15000.0*g*g*20.0);\n    lig += (0.1+0.9*vol)*vec3(0.0,0.50,1.0)*exp(-2000.0*g*g*20.0);\n\n    return vec4(lig,1.0);\n}    \n\nvec4 render( in vec3 ro, in vec3 rd, in float px,\n             in vec3 ddx_ro, in vec3 ddy_ro, \n             in vec3 ddx_rd, in vec3 ddy_rd)\n{\n    vec3 tao[NUMSPHERES];\n    \n    // intersect spheres\n    int num = 0;\n\tfor( int i=0; i<NUMSPHERES; i++ )\n\t{\n\t\tvec4 sph = sphere[i];\n        vec2 dt = sphDistances( ro, rd, sph );\n        float d = dt.x;\n\t    float t = dt.y;\n        //if( t<0.0 ) continue; // skip stuff behind camera\n        \n        float s = max( 0.0, d/t );\n        if( s < px ) // intersection, or close enough to an intersection\n        {\n            tao[num].x = t;                         // depth\n            tao[num].y = 1.0 - clamp(s/px,0.0,1.0); // pixel coverage\n            tao[num].z = float(i);                  // object id\n            num++;\n        }\n\t}\n    \n    if( num==0 ) return vec4(0.0);\n\n    // (bubble) sort intersections, front to back\n\tfor( int i=0; i<num-1; i++ )\n    for( int j=i+1; j<num; j++ )\n    {\n        if( tao[j].x < tao[i].x )\n        {\n            vec3 tm = tao[i];\n            tao[i] = tao[j];\n            tao[j] = tm;\n        }\n\t}\n    \n    // front to back composite to minimize shading cost\n    vec4 col = vec4(0.0,0.0,0.0,0.0);\n    float ot = tao[0].x;\n\tfor( int i=0; i<num; i++ )\n    {\n        float t   = tao[i].x;\n        float al  = tao[i].y;\n        float fid = tao[i].z;\n        int   iid = int(fid);\n\n        /*\n        if( i+1<num )\n        {\n        \tal *= clamp( 0.5 + 0.5*(tao[i+1].x-t)/(px*2.0*t), 0.0, 1.0 );\n        }\n        */\n        \n        vec4 sph = sphere[iid];\n        vec3 pos = ro + t*rd;\n        vec3 nor = sphNormal( pos, sph );\n\n        // compute ray differentials\n        vec3 ddx_pos = ddx_ro - ddx_rd*dot(ddx_ro-pos,nor)/dot(ddx_rd,nor);\n        vec3 ddy_pos = ddy_ro - ddy_rd*dot(ddy_ro-pos,nor)/dot(ddy_rd,nor);\n\n        // shade\n        vec4 tmpcol = shade( rd, pos, ddx_pos, ddy_pos, nor, iid, sph );\n\n        // multiply transparency by coverage\n        tmpcol.a *= al; \n\t\t\n        // composite\n        col.xyz = (1.0-col.w)*tmpcol.w*tmpcol.xyz + col.xyz;\n\t    col.w   = 1.0 - (1.0-tmpcol.w)*(1.0-col.w);  //col.w = col.w + tmpcol.w - tmpcol.w*col.w;\n\n        // early exit on opaque surfaces\n        if( col.a>0.999 ) break;\n    }\n\n    return col;\n}\n\n\nvoid calcCamera( out vec3 ro, out vec3 ta )\n{\n    float an = 0.05*iTime;\n\n\tro = vec3(2.5*sin(an),1.0*cos(0.5*an),2.5*cos(an));\n    ta = vec3(0.0,0.0,0.0);\n}\n\n\nvoid calcRayForPixel( in vec2 pix, in float fl, out vec3 resRo, out vec3 resRd )\n{\n\tvec2 p = (2.0*pix-iResolution.xy) / iResolution.y;\n\t\n    // camera movement\t\n\tvec3 ro, ta;\n\tcalcCamera( ro, ta );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + fl*ww );\n\t\n\tresRo = ro;\n\tresRd = rd;\n}\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*158.5453123); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //-----------------------------------------------------\n    // animate\n    //-----------------------------------------------------\n    vol = 0.0;\n    for( int i=0; i<16; i++ )\n    {\n        float v = texelFetch( iChannel0, ivec2(i*16,1), 0 ).x-0.5;\n        vol += v*v;\n    }\n    vol/=16.0;\n    vol = vol*8.0;\n    for( int i=0; i<NUMSPHERES; i++ )\n\t{\n\t\tfloat id  = float(i);\n        float ra = pow(id/float(NUMSPHERES-1),8.0);\n\t    vec3  pos = cos( 6.2831*hash3(id*14.0) + 0.5*(1.0-0.7*ra)*hash3(id*7.0)*iTime*0.15 );\n        //vec3  pos = cos( id*11.0 + 7.0*sin(id*17.0+vec3(0,2.0-id,4.0+id)) + iTime*0.05*(1.0-0.7*ra) );\n        \n        pos = normalize(pos) * vec3(1.3,1.0,1.3);\n        pos *= 1.2-0.8*ra;\n        \n        float f = 1.0-ra;//float(i)/float(NUMSPHERES);\n        float a = (0.2+0.8*f)*textureLod( iChannel0, vec2(0.5*f,0.5/2.0), 0.0 ).x;\n\n        sphere[i] = vec4( pos, 1.2*(0.3+0.7*ra) );\n        sphereF[i] = 0.0 + 2.0*a;\n        sphere[i].w *= 0.8 + 0.55*a;\n        sphere[i].xyz *= 1.0 + 0.2*a*(1.0-0.5*ra);\n    }\n\t\t\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    const float fl = 1.8;\n\tvec3 ro, rd, ddx_ro, ddx_rd, ddy_ro, ddy_rd;\n\tcalcRayForPixel( fragCoord + vec2(0.0,0.0), fl, ro, rd );\n\tcalcRayForPixel( fragCoord + vec2(1.0,0.0), fl, ddx_ro, ddx_rd );\n\tcalcRayForPixel( fragCoord + vec2(0.0,1.0), fl, ddy_ro, ddy_rd );\n\n    float px = (2.0/iResolution.y)*(1.0/fl);\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n    // background\n\tvec3 col = vec3(0.02) + 0.02*rd.y + 0.1*smoothstep(-0.1,0.3,rd.y);\n    \n    // spheres\n    vec4 res = render( ro, rd, px, ddx_ro, ddy_ro, ddx_rd, ddy_rd );\n    col = col*(1.0-res.w) + res.xyz;\n\n    //-----------------------------------------------------\n\t// postpro\n    //-----------------------------------------------------\n    // gamma\n    col = pow( col, vec3(0.4545) );\n\n    // vignetting    \n    col *= 0.25 + 0.75*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n\n    // dithering\n    col += (1.0/255.0)*hash3(q.x+13.0*q.y);\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjBRz.jpg", "access": "shaders20k", "license": "mit", "functions": [[1970, 2065, 2109, 2109, 2146], [2160, 2160, 2218, 2218, 2436], [2438, 2438, 2498, 2498, 2623], [2641, 2641, 2702, 2702, 2944], [3127, 3222, 3299, 3299, 3578], [3580, 3580, 3632, 3632, 3900], [3902, 3902, 4025, 4061, 5501], [5507, 5507, 5649, 5649, 7751], [7754, 7754, 7799, 7799, 7910], [7913, 7913, 7995, 7995, 8363], [8365, 8365, 8388, 8388, 8442], [8444, 8444, 8501, 8636, 10809]], "test": "untested"}
{"id": "4tlfRB", "name": "square spiral", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "2tweets", "short"], "likes": 9, "viewed": 563, "published": "Public API", "date": "1512334557", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define r(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n\t     U = r(iTime) * ( u+u - R ) / R.y,\n         S = sign(U) * r(.1);  // wave train direction ( 4 sectors, tilted by .1 or .28 ). \n\n    O = vec4( sin( 8.* log( dot( U, S ) ) + atan(S.y,S.x) -10.*iTime) );\n\tO = smoothstep( .7, .5, abs(O) );                                       // bands\n  //O = smoothstep( 1.,0.,(abs(O)-.6)/fwidth(O) );                          // better antialiasing\n  //O = sqrt(smoothstep( 0., 50./R.y/(abs(U.x) + abs(U.y)), .7 - abs(O) )); // Shane variant\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tlfRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 598]], "test": "untested"}
{"id": "4tlfz2", "name": "Wire", "author": "Xor", "description": "Just playing with fake 3d pixel effects. Inspired by: https://www.shadertoy.com/view/4llfR2.\n12-6-17: Added mini version with FabriceNeyret2's help.", "tags": ["2d", "rgb", "xor", "point"], "likes": 14, "viewed": 199, "published": "Public", "date": "1512522591", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\"Wire\" by Xor - 2017\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float X = fragCoord.x*4./iResolution.y+iTime+.5*cos(iTime);\n\tvec3 Height = vec3(cos(X+cos(fragCoord.x))*.2+.2*sin(fragCoord.x)+.5,\n                       cos(X+cos(fragCoord.x+2.))*.2+.21*sin(fragCoord.x+2.)+.5,\n                       cos(X+cos(fragCoord.x+4.))*.2+.22*sin(fragCoord.x+4.)+.5);\n    vec3 Dist = abs(Height*iResolution.y-fragCoord.y);\n\tfragColor = vec4(step(Dist,vec3(.5))+pow(Dist/iResolution.y*.4,vec3(2)),1);\n}\n\n/*\n//\tMini version (240 chars):\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float h = 4./iResolution.y,\n          X = U.x * h +iTime+.5*cos(iTime);\n    vec3  F = vec3(0,2,4);\n\tvec3 H = cos(X+cos(U.x+F))*.2 + sin(U.x+F)*(.2+.005*F) + .5;\n     \n    vec3 D = abs( H*iResolution.y - U.y );\n\tO = vec4(step(D,vec3(.5)) + pow(D*h*.1, vec3(2) ), 1);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tlfz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 24, 79, 79, 511]], "test": "untested"}
{"id": "4tlfzX", "name": "a beating heart", "author": "ab1093996300", "description": "A simple beating heart animation. ", "tags": ["animation"], "likes": 0, "viewed": 94, "published": "Public", "date": "1512709108", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float impulse(float k, float x) {\n\tfloat h = k * x;\n    return h * exp(1.0 - h);\n}\n\n//made with Inigo Quilez's heart formulanimation tutorial: https://www.youtube.com/watch?v=aNR4n0i2ZlM&list=PL0Epi\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy/iResolution.xy;\n    st.x = (st.x - 0.5) * iResolution.x / iResolution.y + 0.5;\n    \n    st.y -= abs(st.x-0.5) * (5.0 - abs(st.x-0.5)) / 8.0; //aply heart transform\n    st.y = (st.y - 0.5) * 1.15 + 0.5; //shrink heart's height\n    \n    float t = impulse(2.0, 0.1+mod(1.5*iTime, 1.5) + 2.0*(st.y-0.5)/3.0);\n    float radius = 0.5 * t;\n    float smoothing = 0.01;\n    \n    vec3 material = mix(vec3(0.6, 0.0, 0.0), vec3(1.0, 0.0, 0.0), t);\n    vec3 color = material * (1.0 - smoothstep(radius-smoothing, radius+smoothing, \n                              2.0*distance(st, vec2(0.5))));\n\n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tlfzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 82], [84, 199, 256, 256, 895]], "test": "untested"}
{"id": "4tsBD2", "name": "ice cube tray", "author": "mds2", "description": "It's a tray of dancing ice cubes!  It must be party time!  Except I got the refraction backwards, so they're actually dancing air bubbles in a thick refractive medium that the viewer is somehow flying or floating through.  You know, just like real life.", "tags": ["sdf", "refraction", "music"], "likes": 3, "viewed": 535, "published": "Public API", "date": "1513391774", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BLOCKSIZE 1.2\n\n#define EXTENT 15.0\n\n#define MULTI_SAMPLE 2 // do not set higher than 8\n\n#define DO_SUBSURFACE 0\n\nvec3 camera = vec3(25.0, 0.0, 0.0);\nmat3 dir_mat = mat3(1.0, 0.0, 0.0,\n                    0.0, 1.0, 0.0,\n                    0.0, 0.0, 1.0);\n\nconst float error_bound = 1.0e-5;\n\nconst float blocks_max_height = -1.15; // -1.75 + 0.6 + 0.25 * BLOCKSIZE\nconst float waffle_max_height = -1.75; // -2.0 + 0.1 + 0.15\n\nfloat waffle_sdf(in highp vec3 point) {\n\tvec3 local = vec3(abs(abs(mod(point.xz, BLOCKSIZE)) - vec2(0.5 * BLOCKSIZE)), point.y).xzy;\n    vec2 lr_dists = max(abs(local.xz) - 0.25 * BLOCKSIZE, 0.0);\n    float lr_dist = max(0.25 - length(lr_dists), 0.0);\n    float updist = abs(local.y + 2.0);\n    return length(vec3(lr_dist, max(updist - 0.1, 0.0), \n                       max(length(point - camera) - EXTENT, 0.0))) - 0.05;\n}\n\nfloat blocks_sdf(in highp vec3 point) {\n\tvec3 local = vec3(abs(abs(mod(point.xz, BLOCKSIZE)) - vec2(0.5 * BLOCKSIZE)),\n                      abs(point.y + 1.75)).xzy;\n    float samp_loc = mod(dot(point.xz - mod(point.xz, BLOCKSIZE),\n                             vec2(0.17, 0.13)), BLOCKSIZE);\n    float samp = texture(iChannel0, vec2(samp_loc, 0.0)).r;\n\tvec3 to_core = max(vec3(0.0), local - vec3(0.05, 0.1 + 0.5 * samp, 0.05));\n    return max(length(to_core), \n                       max(length(point - camera) - EXTENT, 0.0)) - 0.125 * (1.0 + samp) * BLOCKSIZE;\n}\n\nfloat grid_sdf(in highp vec3 point) {\n    return min(waffle_sdf(point), blocks_sdf(point));\n}\n\nvec3 waffle_grad(in highp vec3 point) {\n    float p = waffle_sdf(point);\n    return normalize(vec3(waffle_sdf(point + vec3(0.01, 0.0, 0.0)) - p,\n                          waffle_sdf(point + vec3(0.0, 0.01, 0.0)) - p,\n                          waffle_sdf(point + vec3(0.0, 0.0, 0.01)) - p));\n}\n\n\nvec3 blocks_grad(in highp vec3 point) {\n    float p = blocks_sdf(point);\n    return normalize(vec3(blocks_sdf(point + vec3(0.01, 0.0, 0.0)) - p,\n                          blocks_sdf(point + vec3(0.0, 0.01, 0.0)) - p,\n                          blocks_sdf(point + vec3(0.0, 0.0, 0.01)) - p));\n}\n\n\nfloat dist_to_grid(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    if (dir.y < -error_bound) {\n\t    float to_max = (point.y - waffle_max_height) / dir.y;\n    \tresult = to_max;\n    } else if (point.y > waffle_max_height + EXTENT * error_bound) {\n        return 2.0 * EXTENT;\n    }\n    p = p + result * dir;\n    for (int i = 0; i < 128; ++i) {\n    \tfloat d = 0.9 * waffle_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound || result > 2.0 * EXTENT) {\n            return result;\n        }\n    }\n    return result;\n}\n\nfloat dist_to_blocks(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    if (dir.y < -error_bound) {\n        float to_max = (point.y - blocks_max_height) / dir.y;\n        result = to_max;\n    } else {\n        return 2.0 * EXTENT;\n    }\n    p = p + result * dir;\n    for (int i = 0; i < 96; ++i) {\n    \tfloat d = 0.8 * blocks_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound || result > 2.0 * EXTENT) {\n            return result;\n        }\n    }\n    return result;\n}\n\nfloat dist_out_of_blocks(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    for (int i = 0; i < 64; ++i) {\n    \tfloat d = -0.9 * blocks_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound) {\n            return result;\n        }\n    }\n    return result;\n}\n\nconst vec3 light1 = vec3(0.36, 0.48, -0.8);\n\nconst vec3 light2 = vec3(-0.48, 0.64, -0.6);\n\nvec4 getSample(in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    vec4 color_mul = vec4(1.0);\n\n    vec3 ray_orig = camera; // vec3(0.0, 0.0, -1.0); // sin(iTime));\n    vec3 ray_dir = normalize(vec3(uv - vec2(0.0, 0.1), -0.2));\n    ray_dir = dir_mat *\n        mat3(1.0, 0.0, 0.0,\n        \t 0.0, 0.8, -0.6,\n             0.0, 0.6, 0.8) * ray_dir;\n    float d1 = dist_to_grid(ray_orig, ray_dir);\n    float d2 = dist_to_blocks(ray_orig, ray_dir);\n    vec3 n = ray_dir;\n    const float eta = 1.85;\n    vec3 subsurface = vec3(0.0);\n    if (d2 < d1 && d2 < 20.0) {\n        ray_orig = ray_orig + ray_dir * (d2 + 0.01);\n    \tn = blocks_grad(ray_orig);\n        vec3 next_ray_dir = refract(ray_dir, n, eta);\n        float l = length(next_ray_dir);\n\n        if (l > 0.1) {\n            ray_dir = next_ray_dir / l;\n        \td2 = dist_out_of_blocks(ray_orig, ray_dir);\n        \tcolor_mul *= mix(vec4(1.0, 0.9, 0.5, 1.0), vec4(1.0),\n                         exp(-2.0 * max(d2, 0.0)));\n        \tray_orig = ray_orig + d2 * ray_dir;\n       \t\tn = blocks_grad(ray_orig);\n        \tnext_ray_dir = refract(ray_dir, -n, 1.0/eta);\n            l = length(next_ray_dir);\n            if (l > 0.1) {\n                ray_dir = next_ray_dir / l;\n            }\n        } else {\n            ray_dir = normalize(reflect(ray_dir, n));\n        }\n        d1 = dist_to_grid(ray_orig, ray_dir);\n        const float subsurface_dist_mul = 150.0;\n#if DO_SUBSURFACE        \n        float d_light_1 = dist_out_of_blocks(ray_orig, light1);\n        float d_light_2 = dist_out_of_blocks(ray_orig, light2);\n#else\n        float d_light_1 = 1000.0 / subsurface_dist_mul;\n        float d_light_2 = d_light_1;\n#endif        \n        subsurface = vec3(1.0 / max(2.0, subsurface_dist_mul * d_light_1),\n                          0.0,\n                          1.0 / max(2.0, subsurface_dist_mul * d_light_2));\n        subsurface.g = 0.5 * (subsurface.b + subsurface.r);\n        \n    }\n    vec3 bounce = ray_dir;\n    if ( d1 < 20.0) {\n        vec3 p = ray_orig + ray_dir * d1;\n        n = waffle_grad(p);\n        bounce = normalize(reflect(ray_dir, n));\n        color_mul *= vec4(vec3(0.6, 0.6, 0.7), 1.0);\n    }\n    \n    float diffuse1 = max(dot(n, light1), 0.0) + 0.1;\n    float diffuse2 = 0.4 * max(dot(n, light2), 0.0) + 0.1;\n    float spec1 = smoothstep(0.9, 1.0, dot(bounce, light1));\n    float spec2 = smoothstep(0.8, 0.9, dot(bounce, light2));\n    return vec4(subsurface, 0.0) +\n        color_mul * vec4(vec3(max(diffuse1, diffuse2)) + 0.5 * vec3(spec1, 0.0, spec2) , 1.0);\n}\n\n\nvec2 offsets[8] = vec2[8](vec2(-0.4, -0.4), \n                         vec2(-0.45, 0.1),\n                         vec2(-0.4, 0.4),\n                         vec2(0.1, 0.45),\n                         vec2(0.4, 0.4),\n                         vec2(0.45, -0.1),\n                         vec2(0.4, -0.4),\n                         vec2(0.0, 0.0));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 result = vec4(0.0);\n    \n    float c_theta = cos(0.05 * iTime);\n    float s_theta = sin(0.05 * iTime);\n\n    camera = mat3(c_theta, 0.0, s_theta,\n                  0.0, 1.0, 0.0,\n                  -s_theta, 0.0, c_theta) * camera;\n    \n    dir_mat = mat3(-c_theta, 0.0, -s_theta,\n                   0.0, 1.0, 0.0,\n                   s_theta, 0.0, -c_theta);\n    \n    float nsamps = 0.0;\n    \n    for (int i = 0; i < 8; i += max(8 / MULTI_SAMPLE, 1)) {\n        result += getSample(fragCoord + offsets[i]);\n    \tnsamps += 1.0;\n    }\n    \n    fragColor = result / nsamps;\n}\n", "image_inputs": [{"id": "lll3Dr", "previewfilepath": "https://soundcloud.com/dog-lick/twenty-jinn-thugson-kian", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/dog-lick/twenty-jinn-thugson-kian", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tsBD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 433, 472, 472, 857], [859, 859, 898, 898, 1424], [1426, 1426, 1463, 1463, 1519], [1521, 1521, 1560, 1560, 1813], [1816, 1816, 1855, 1855, 2108], [2111, 2111, 2171, 2171, 2695], [2697, 2697, 2759, 2759, 3232], [3234, 3234, 3300, 3300, 3556], [3649, 3649, 3685, 3685, 6236], [6580, 6580, 6637, 6637, 7216]], "test": "untested"}
{"id": "4tsBW7", "name": "persTest", "author": "prl", "description": "a", "tags": ["t"], "likes": 0, "viewed": 136, "published": "Public", "date": "1512090449", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = 3.14159265359;\n\n//-----------------------------------------------------------------\n// Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt(const in vec2 uv, const in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0+ceil(log2(value)/log2(10.0));\n\tfloat digitID = floor(uv.x);\n\tif( digitID>0.0 && digitID<maxDigits )\n\t{\n        float digitVa = 10.0; // mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n\t}\n\n\treturn res;\t\n}\n\nvec4 circle(vec2 p, vec2 center, float radius)\n{\n\treturn mix(vec4(1,1,1,0), vec4(1,0,0,1), smoothstep(radius + 0.005, radius - 0.005, length(p - center)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 xy = uv;\n    vec2 dDim = vec2(120,68);  \n//    vec2 PDxy = vec2(20.0,30.0)/dDim;\n    vec2 PDxy = vec2(135.0,20.0)/dDim;\n\n    float m_fps = 2.0;\n    float d0 = round(fract(float(iFrame)/2.0/m_fps)+0.001);\n    float d1 = round(fract(float(iFrame-1)/2.0/m_fps)+0.001);\n    float v = 0.85;  \n    float p = 0.02;  \n    float w = 0.9;\n    float mag = 0.5;\n    vec2 parity = -sign(uv.x-0.5)*vec2(1.0,0.0);\t\n    vec2 dxdy = iMouse.xy/iResolution.xy-0.5;\n    float verg = 0.0;//-0.01+dxdy.x;    \n\n    if(true)\n        uv.x = fract(uv.x*2.0);\t\t\n      \tdDim = dDim*vec2(0.5,1.0);\t\n    \tp *= 2.0;\n    \n    uv.x += parity.x*verg;\n    uv -= 0.5;\n    \n    if(sin(2.0*pi/p*uv.x) > w)\n        fragColor = vec4(1,1,1,1);\n\telse\n\t\tfragColor = vec4(0,0,0,1);\n    \n    float r = 0.1*mag;\n    float s = 1.0;\n    float l = .02;\n    float d = -0.6;\n    float vOffset = -0.15*mag;\n    \n    if(circle(uv,vec2(0.0,-vOffset),r).x>0.5 && circle(uv,vec2(0.0,-vOffset),r).y<0.5){\n        if ( ( (cos(2.0*pi/l*(uv.x )) > d ) ) && ( abs( uv.y + vOffset) < .005) ){       \n            fragColor = 0.8*vec4(1,1,0,1);\n        }else{\n        \tfragColor = vec4(1,0,0,1);\n        }\n    }\n\n    float pos = s*fract(iTime*v/s)-0.5;\n    if(circle(uv,vec2(pos,vOffset),r).x>0.5 && circle(uv,vec2(pos,vOffset),r).y<0.5){\n        if ( ( (cos(2.0*pi/l*(uv.x - pos)) > d ) ) && ( abs( uv.y - vOffset ) < .005) ){       \n            fragColor = 0.8*vec4(1,1,0,1);\n        }else{\n        \tfragColor = vec4(1,0,0,1);\n        }\n    }\n    \n    uv += 0.5;\n    uv.x -= parity.x*verg;\n    //if((1.0-uv.x)<PDxy.x && (uv.x)>0.0 && (uv.y)<PDxy.y && (uv.y)>0.0 && xy.x >0.5){\t\t\n     //   fragColor = vec4(d0,d0,d0,1.0);\n    //}\n   \n    if((1.0-uv.x)<2.0*PDxy.x && (uv.x)>0.0 && (uv.y)<0.3*PDxy.y && (uv.y)>0.0 && xy.x >0.0){\t\t\n        fragColor = vec4(d0,d0,d0,1.0);\n    }\n\n    float col = PrintInt( (uv-vec2(0.01,0.85))*20.0, iFrameRate );\n    fragColor += vec4(col,col,col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tsBW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 173, 229, 229, 1319], [1321, 1321, 1378, 1378, 1699], [1701, 1701, 1749, 1749, 1858], [1860, 1860, 1917, 1917, 3890]], "test": "untested"}
{"id": "4tsBz2", "name": "Banana Tunnel", "author": "Del", "description": "Banana Tunnel...", "tags": ["tunnel", "bananas"], "likes": 5, "viewed": 119, "published": "Public", "date": "1512519222", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// tunnel code borrowed from https://www.shadertoy.com/view/Xslyzf\n// Bananas added by Del.\n\nvec4 Banana(vec2 p)\n{\n    const vec4 col1 = vec4(0.0,.1,.0,1.0);\n    const vec4 col2 = vec4(0.9,0.8,0.5,1.0);\n    vec2 uv = p.xy;\n    vec2 d = uv*(3.0);\n    d.x *= 5.0;\n    d.y *= 1.8;\n    d.x += sin(d.y + iTime*0.2)*1.2;\n    d.y += sin(d.x + iTime*0.2)*1.2;\n    float v1=length(0.5-fract(d.xy))+0.40;\n    return mix(col2,col1,v1*v1*v1*v1)*1.5;\n}\n\n\nvoid mainImage( out vec4 f, vec2 g )\n{\n    f.xyz = iResolution;\n\tg = (g+g-f.xz)/f.y;\n    float t = iTime * .25;\n    g.y -= 0.28;\n    float a = atan(g.x,g.y)/1.27;\n    float d = max(max(abs(g.x),abs(g.y)), min(abs(g.x)+g.y, length(g)));\n    vec2 k = vec2(a,1.5/d + t);\n    f = Banana(k.xy*0.25)*clamp(d,0.0,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tsBz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 93, 114, 114, 439], [442, 442, 480, 480, 755]], "test": "untested"}
{"id": "4tSBzh", "name": "Escher's cubes high FOV failure", "author": "keim", "description": "Escher's cube with high Field of View. It is not impossible but is unreasonable. low FOV > [url]https://www.shadertoy.com/view/ltjBzz[/url]", "tags": ["escher", "illusoin"], "likes": 1, "viewed": 620, "published": "Public API", "date": "1514435369", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n vec2  resolution, mouse;\n float time;\nconst vec3 V  = vec3(0,.001,300);\nconst vec3 BG = vec3(0);\nconst vec3 Amb= vec3(.01);\nconst vec3 PI = vec3(1.5707963,3.1415927,6.2831853);\nconst float BPM = 120.;\nvec2 uv;\nfloat tick;\n\nfloat rnd(vec3 s){s=fract(s*443.8975);s+=dot(s,s.yzx+19.19);return fract(s.x*s.y*s.z);}\nvec4  gamna(vec3 c){return vec4(pow(c,vec3(1./2.2)),1);}\nvec3  hsv(float h,float s,float v){return((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\nmat3  camera(vec3 p, vec3 t, vec3 h){vec3 w=normalize(p-t),u=normalize(cross(w,h));return mat3(u,normalize(cross(u,w)),w);}\nfloat dfPln(vec3 p, vec3 n, float d){return dot(p,n)+d;}\nfloat dfBox(vec3 p, vec3 b, float r){return length(max(abs(p)-b,0.))-r;}\n\nfloat trick(vec3 p) {\n    float d = V.z;\n    for (float i=0.; i<3.; i+=1.) {\n        d = min(d, dfBox(p-vec3(i*1.08,.78-i*.11,0), vec3(.71-i*.11), .09));\n    }\n    return d;\n}\n\nfloat map(vec3 p, bool trick) {\n    float d = dfPln(p, vec3(0,1,0), 0.);\n    for (float i=0.; i<3.; i+=1.) {\n        d = min(d, dfBox(p-vec3(i*1.08,.78-i*.11,0), vec3(.71-i*.11), .09));\n        d = min(d, dfBox(p-vec3(4.,.5,i), vec3(.4), .09));\n        d = min(d, dfBox(p-vec3(4.,i+.5,4.), vec3(.4), .09));\n    }\n    d = min(d, dfBox(p-vec3(3.,.5,0.), vec3(.4), .09));\n    d = min(d, dfBox(p-vec3(4.,.5,3.), vec3(.4), .09));\n    if (trick) {\n        d = min(d, min(dfBox(p-vec3(4.,3.5,4.), vec3(.4), .09),\n                       dfBox(p-vec3(4.,4.5,4.), vec3(.39), .09)));\n    }\n    return d;\n}\n\nvec3 background(vec3 pos, vec3 dir, inout float bld) {\n    bld = 0.;\n    return BG;\n}\n\nvec3 diff(vec3 nml, vec3 lit, vec3 col){return max(dot(nml,lit)*col,0.);}\nfloat shad(vec3 pos, vec3 lit){float s=V.z,t=.05,d;for(int i=20;i!=0;--i){t+=max(d=map(pos+lit*t, true),.05);s=min(s,d/t);if(t>20.)break;}return clamp(s*.2,0.,1.);}\nfloat occl(vec3 pos, vec3 nml){float s=0.;for(float t=.01;t<.8;t+=.05){s+=t-map(pos+nml*t, true);}return clamp(1.-s*.1,0.,1.);}\n\nbool tricktrace(vec3 pos, vec3 dir) {\n    float t = 0., d;\n    for (int i=80; i!=0; --i) {\n        t += (d = trick(pos + dir * t));\n        if (d < V.y) break;\n        if (t > V.z) return true;\n    }\n    return false;\n}\n\nvec3 trace(inout vec3 pos, inout vec3 dir, inout float bld) {\n    float t = 0., d;\n    bool trick = tricktrace(pos, dir);\n    for (int i=80; i!=0; --i) {\n        t += (d = map(pos + dir * t, trick));\n        if (d < V.y) break;\n        if (t > V.z) return bld * background(pos, dir, bld);\n    }\n    vec3 p = pos + dir * t;\n    vec3 n = normalize(vec3(map(p+V.yxx, true),map(p+V.xyx, true),map(p+V.xxy, true))-map(p, true));\n    vec3 c = vec3(1);\n    vec3 ldir = normalize(vec3(sin(tick/4.*PI.z)*5.+16.,10.,-15.) - p);\n    vec3 lcol = diff(n, ldir, vec3(10)) * shad(p, ldir) * occl(p, n) + Amb;\n    vec3 ldir2 = normalize(vec3(-5.,10.,15.) - p);\n    vec3 lcol2 = diff(n, ldir2, vec3(10)) * shad(p, ldir2) * occl(p, n) + Amb;\n    vec3 col = c * (lcol + lcol2);\n    float b=bld*.2;\n    pos = p + n*V.y;\n    dir = reflect(dir, n);\n    bld *= .8;\n    return mix(col, BG, clamp((length(p.xz)-1.)/16.,0.,1.))*b;\n}\n\nvec3 render(in vec3 pos, in vec3 dir) {\n    float b = 1.;\n    vec3 col = trace(pos, dir, b);\n    if (b > V.y) col += trace(pos, dir, b);\n    if (b > V.y) col += trace(pos, dir, b);\n    return col;\n}\n\nvec4 entryPoint(vec2 fragCoord) {\n    uv = (fragCoord * 2.-resolution) / resolution.y;\n    tick = time * BPM / 60.;\n\n    float scan = 1., dist = 0.;\n    vec3 pos = vec3(10.,10.,10.);\n    if (iMouse.z > .5) {\n        scan = (mod(fragCoord.y, 2.)+1.) * (1.-length(uv)*.3);\n        dist += (.0003/(uv.y+fract(tick/16.)*2.-1.));\n        vec2 r = mouse/resolution*2.-1.;\n        pos = vec3(10.+r.x*12.,10.+r.y*4.,10.-r.x*12.);\n    }\n    vec3 dir = camera(pos, vec3(2,0,2), vec3(0,1,0)) * normalize(vec3(uv+vec2(dist,0),-3));\n    return gamna(render(pos, dir)) * scan;\n}\n\nvoid mainImage(out vec4 flagColor,in vec2 flagCoord) {\n    resolution = iResolution.xy;\n    time = iTime;\n    mouse = iMouse.xy;\n    flagColor = entryPoint(flagCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSBzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 265, 265, 334], [335, 335, 355, 355, 391], [392, 392, 427, 427, 499], [500, 500, 537, 537, 623], [624, 624, 661, 661, 680], [681, 681, 718, 718, 753], [755, 755, 776, 776, 930], [932, 932, 963, 963, 1526], [1528, 1528, 1582, 1582, 1613], [1615, 1615, 1655, 1655, 1688], [1689, 1689, 1720, 1720, 1853], [1854, 1854, 1885, 1885, 1981], [1983, 1983, 2020, 2020, 2202], [2204, 2204, 2265, 2265, 3110], [3112, 3112, 3151, 3151, 3310], [3312, 3312, 3345, 3345, 3876], [3878, 3878, 3932, 3932, 4047]], "test": "untested"}
{"id": "4tsfDS", "name": "Palm", "author": "skaplun", "description": "repro of Inigo Quilez's tutorial\nhttps://www.youtube.com/watch?v=0ifChJ0nJfM\n", "tags": ["sunset", "palm"], "likes": 2, "viewed": 90, "published": "Public", "date": "1513167792", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ORANGE vec3(1.0, 0.4, 0.1)\n#define YELLOW vec3(1.0, 0.8, 0.3)\nconst vec2 PALM_CENTER = vec2(.35, .75);\nconst vec2 SUN = vec2(1.4, .05);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 dst = uv - PALM_CENTER;\n    \n    float head_rad = .2;\n    head_rad += .1 * sin(atan(dst.x, dst.y) * 10.0 - 20. * dst.x + sin(iTime));\n    head_rad += .0125 * sin(atan(dst.y, dst.x) * 100.0);\n    float head = smoothstep(head_rad, head_rad + .02, length(dst));\n    \n    float trunk_width = .0125 + cos(dst.y * 250.) * 0.001;\n    trunk_width += exp(-20. * uv.y);\n    float trunk = smoothstep(trunk_width, trunk_width + .005,\n                             abs(dst.x - sin(dst.y * 2.) * .2));\n    trunk = step(0.5, trunk + step(0., dst.y));\n    \n    float lsun = length(uv * vec2(iResolution.x/iResolution.y, 1.) - SUN);\n    \n    float f = 1.0 - smoothstep(.1, .15, lsun);\n    f += 1.0 - pow(lsun, .75);\n    vec3 clr = mix(ORANGE, YELLOW, f) * head * trunk;\n    //clr = pow(clr, vec3(length(uv - vec2(.8, .1))));\n    \n    fragColor = vec4(vec3(clr), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tsfDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 201, 201, 1103]], "test": "untested"}
{"id": "4tSfRz", "name": "CJ - reduced IQ's Ellipse", "author": "chrisjj", "description": "Reduced https://www.shadertoy.com/view/MdfGWn\nSample output: https://i.imgur.com/oYJjvN5.png", "tags": ["math"], "likes": 1, "viewed": 407, "published": "Public", "date": "1514152881", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// CJ reduction of https://www.shadertoy.com/view/MdfGWn\n\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// An example of how to compute a distance estimation for an ellipse (which provides\n// constant thickness to its boundary). This is achieved by dividing the implicit \n// description by the modulo [modulus] of its gradient. The same process can be applied to any\n// shape defined by an implicity formula (ellipses, metaballs, fractals, mandelbulbs).\n//\n// More info here:\n// http://www.iquilezles.org/www/articles/distance/distance.htm\n\nfloat r;\n\nfloat ellipse2(vec2 p,float r) // approx. distance between p and nearest point on ellipse\n{\n    vec2 s = vec2(1.,3.);  // shape of ellipse\n    float f = length(p*s); // definition of ellipse\n    return abs(f-r)*f      // f(x,y)... \n        /length(p*s*s);    // ... divided by analytical gradient\n}\n\nfloat f(vec2 p)\n{\n\tfloat  r = length(p);float a = atan(p.y,p.x);\n    // return r-1.+0.5*sin(3.*a+2.*r*r);   \n    vec2 s = vec2(1.,3.);  // shape of ellipse\n    float f = length(p*s); // definition of ellipse\n    return f;\n}\n\nvec2 grad( in vec2 x )\n{\n    vec2 h = vec2( 0.01, 0.0 );\n    return vec2( f(x+h.xy) - f(x-h.xy),\n                 f(x+h.yx) - f(x-h.yx) )/(2.0*h.x);\n}\n\nfloat color( in vec2 x )\n{\n    float v = f( x );\n    vec2  g = grad( x );\n    float de = abs(v)/length(g);\n    return step( 1.2, de );\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    r = 1.0 + 0.1*sin(3.1415927*iTime);\n   \n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    \t     vec4 c = vec4(0.);\n    c.r = 1.0-step(0.01,ellipse2(uv,r));\n    c.g = 1.0-f(uv*2.);\n    c.b = 1.0-color(uv*2.);\n    //c.g = 1.0-step(0.5,colorO(uv));\n\tfragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSfRz.jpg", "access": "shaders20k", "license": "mit", "functions": [[1136, 1583, 1674, 1674, 1881], [1883, 1883, 1900, 1900, 2106], [2108, 2108, 2132, 2132, 2258], [2260, 2260, 2286, 2286, 2396], [2399, 2399, 2456, 2456, 2740]], "test": "untested"}
{"id": "4tsfW8", "name": "Miami Waves", "author": "alecksia", "description": "Based on the theme \"waves.\" I wanted to focus on sine functions and an interesting color palette.", "tags": ["waves", "sine", "miami"], "likes": 0, "viewed": 80, "published": "Public", "date": "1513495251", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FREQ 40.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec4 pink = vec4(255.0/255.0, 147.0/255.0, 217.0/255.0, 1.0);\n    vec4 green = vec4(90.0/255.0, 150.0/255.0, 98.0/255.0, 1.0);\n    vec4 teal = vec4(118.0/255.0, 252.0/255.0, 252.0/255.0, 1.0);\n\n    vec4 pixel = pink; //main wave color\n    \n    if (mod(fragCoord.y - iTime * 50.0, FREQ) > sin(fragCoord.x * 100.0) + 25.0 || mod(fragCoord.y - iTime * 50.0, FREQ) < sin(fragCoord.x * 100.0) + 5.0 )\n    {\n      pixel = pink;\n    } else {\n      pixel = mix(teal, green, 1.1 - uv.y); //add a gradient for the other waves\n    }\n\n\tfragColor = pixel; //return\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tsfW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 76, 76, 677]], "test": "untested"}
{"id": "4tsfz2", "name": "HSL Torus", "author": "doomtaters", "description": "a hsl colored torus type thing", "tags": ["torus", "ring", "hsl"], "likes": 5, "viewed": 106, "published": "Public", "date": "1512530827", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1415926535897932384626433832795;\nconst float M_120Deg = pi*2.0/3.0;\nconst float M_240Deg = M_120Deg*2.0;\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.) -3. ) -1., 0.,1.);\n    return c.z + c.y * (rgb-.5)*(1.-abs(2.*c.z-1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 translated = 2.0*(fragCoord - iResolution.xy/2.0);\n    translated /= ( iResolution.x<iResolution.y ? iResolution.x : iResolution.y );\n    \n    float dist = length( translated );\n    float innerRadius = sin(iTime)/6.0+0.3;\n    \n    vec3 hsl = vec3( iTime/3.0 + atan( translated.x, translated.y )/(pi*2.0), 1.0, (dist>innerRadius?0.5-(dist-innerRadius)/(2.0*innerRadius):dist/(innerRadius*2.0)));\n    fragColor = vec4( hsl2rgb( hsl ), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tsfz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 151, 151, 278], [280, 280, 337, 337, 785]], "test": "untested"}
{"id": "4tXBWl", "name": "Tunnel Beauty 9", "author": "aiekick", "description": "Tunnel Beauty 9", "tags": ["tunnel", "rainbow", "beauty"], "likes": 4, "viewed": 571, "published": "Public API", "date": "1513768063", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n#define path(t) vec2(cos(t * .2), sin(t * .2)) * 3.\n\nfloat df(vec3 p)\n{\n    p.xy -= path(p.z);\n\treturn 2. - length(p.xy) - cos(p.x) * sin(p.y) * sin(p.z);\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec3 e = vec3( prec, 0, 0);\n    vec3 n = vec3(\n    df(p+e.xyz) - df(p-e.xyz),\n    df(p+e.yxz) - df(p-e.yxz),\n    df(p+e.yzx) - df(p-e.yzx) );\n    return normalize(n);\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv)\n{\n\tvec3 rov = normalize(cv-ro);\n    vec3 u =  normalize(cross(cu, rov));\n    vec3 v =  normalize(cross(rov, u));\n    return normalize(rov + u*uv.x + v*uv.y);\n}\n\n// https://www.shadertoy.com/view/XlsfDf\t\nvec3 GetRainBow(float r)\n{\n    int i = int(3.*fract(r)); \n\tvec4 C = vec4(.25);   \n    C[(i+1)%3] += r = fract(3.*r);\n    C[i]       += 1.-r;\n\treturn C.rgb;\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n    g = (g+g-iResolution.xy)/iResolution.y;\n\tvec3 ro = vec3(path(iTime),iTime);\n    vec3 rd = cam(g, ro, vec3(0,1,0), ro + vec3(0,0,.1));\n\n    float d = 0.;\n    for(int i=0;i<60;i++)  \n\t\td += df(ro+rd*d);\n\n\tvec3 p = ro + rd * d;\n\tvec3 n = nor(p, .01);\n\tfloat ayz = atan(n.y,n.z)/3.14159;\n\tfloat axy = atan(n.x,n.y)/3.14159;\n\tfloat b = dot(n,normalize(ro-p)*1.5)*.8;\n\tvec3 col = mix(GetRainBow(axy),GetRainBow(ayz),n.z); // 1.-n.z is cool also\n    \n\tf = mix( \n        (b*vec4(col,1)+pow(b,0.2))*(1.0-d*.01), \n        vec4(0,0,.1,1), \n        1.0 - exp( -d*0.2) ); \n    \n    /*if (g.x>0.)*/ f = sqrt(f*f*f*1.2);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tXBWl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 267, 285, 285, 370], [372, 372, 404, 404, 577], [579, 579, 625, 625, 783], [785, 827, 853, 853, 984], [986, 986, 1027, 1027, 1639]], "test": "untested"}
{"id": "4tXfDX", "name": "Random Red Green Waves", "author": "nint22", "description": "Waves", "tags": ["waves"], "likes": 0, "viewed": 63, "published": "Public", "date": "1513535752", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 red = vec4( 1.0, 0.0, 0.0, 1.0 );\n    vec4 green = vec4( 0.0, 1.0, 0.0, 1.0 );\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    if( mod( uv.y + iTime * 0.1, 0.2 ) > 0.01 + ( 0.5 * 0.5 + sin( uv.x * 100.0 + iTime * 10.0) ) * 0.01 &&\n        mod( uv.y + iTime * 0.1, 0.2 ) < 0.1 + ( 0.5 * 0.5 + sin( uv.x * 100.0 + -iTime * 10.0) ) * 0.01)\n        fragColor = red;\n    else\n        fragColor = green;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tXfDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 479]], "test": "untested"}
{"id": "4tXfWS", "name": "toon  practice", "author": "Torumu106", "description": "toon practice", "tags": ["toon"], "likes": 0, "viewed": 76, "published": "Public", "date": "1513047881", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsvtorgb(float h, float s, float v){\n\tfloat r = v;\n\tfloat g = v;\n\tfloat b = v;\n\tif (s > 0.0f) {\n\t    h *= 6.0f;\n\t    int i = int(h);\n\t    float f = h - float(i);\n\t    switch (i) {\n\t        default:\n\t        case 0:\n\t            g *= 1.0 - s * (1.0 - f);\n\t            b *= 1.0 - s;\n\t            break;\n\t        case 1:\n\t            r *= 1.0 - s * f;\n\t            b *= 1.0 - s;\n\t            break;\n\t        case 2:\n\t            r *= 1.0 - s;\n\t            b *= 1.0 - s * (1.0 - f);\n\t            break;\n\t        case 3:\n\t            r *= 1.0 - s;\n    \t        g *= 1.0 - s * f;\n\t            break;\n\t        case 4:\n\t            r *= 1.0 - s * (1.0 - f);\n\t            g *= 1.0 - s;\n\t            break;\n\t        case 5:\n\t            g *= 1.0 - s;\n\t            b *= 1.0 - s * f;\n\t            break;\n\t    }\n\t}\n    return vec3(r, g, b);\n}\nvec3 toon(vec3 col){\n    float r = col.x;\n    float g = col.y;\n    float b = col.z;\n    float max = r > g ? r : g;\n\tmax = max > b ? max : b;\n\tfloat min = r < g ? r : g;\n\tmin = min < b ? min : b;\n\tfloat h = max - min;\n\tif (h > 0.0f) {\n\t    if (max == r) {\n\t        h = (g - b) / h;\n\t        if (h < 0.0f) {\n\t            h += 6.0f;\n\t        }\n\t    } else if (max == g) {\n\t        h = 2.0f + (b - r) / h;\n\t    } else {\n\t        h = 4.0f + (r - g) / h;\n\t    }\n\t}\n\th /= 6.0f;\n\tfloat s = (max - min);\n\tif (max != 0.0f)\n\t    s /= max;\n\tfloat v = max;\n    \n    v = floor(v * 4.0) / 4.0;\n    \n    return hsvtorgb(h, s, v);\n}\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\nfloat PI = 3.1415926535;\nvec3 col = vec3(1.0, 1.0, 1.0);\nint stop = 0;\nvec3 stoppos = vec3(0.0);\nfloat map(vec3 p){\n    float d = length(max(abs(p) - vec3(1.0),0.0));\n    vec3 p1 = p;\n    float the = iTime / 2.1;\n    p1.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    d = smin(d, length(p1 - vec3(1.2,1.2,1.2)) - 0.7, 3.0);\n    d = smin(d, length(p1 - vec3(-1.2,1.2,1.2)) - 0.7, 3.0);\n    d = smin(d, length(p1 - vec3(1.2,1.2,-1.2)) - 0.7, 3.0);\n    d = smin(d, length(p1 - vec3(-1.2,1.2,-1.2)) - 0.7, 3.0);\n    if(d < 0.001) col= vec3(0.0, 1.0, 1.0);\n    d = min(d, dot(p,vec3(0.0, 1.0, 0.0)) + 1.0);\n    return d;\n}\nvec3 grad(vec3 p) {\n    vec2 d = vec2(0.0, 0.001);\n\tfloat dFx = map(p + d.yxx) - map(p - d.yxx);\n\tfloat dFy = map(p + d.xyx) - map(p - d.xyx);\n\tfloat dFz = map(p + d.xxy) - map(p - d.xxy);\n\treturn normalize(vec3(dFx, dFy, dFz));\n}\nfloat trace(vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p;\n    for(int i = 0; i < 256; ++i){\n    \tp = o + r * t;\n        float d = map(p);\n        if(d < 0.001){\n            stop = 1;\n        \tbreak;\n        }\n        t += d * 0.9;\n    }\n    stoppos = p;\n    return t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv - vec2(0.0, PI / 3.0), 1.0));\n    \n    float the = iTime;\n    vec3 o = vec3(0.0,10.0, -10.0);\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    o.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    float t = trace(o, r);\n    float light = 0.0;\n    if(stop == 1){\n    \tvec3 nor = grad(stoppos);\n        light = 0.6 * max(dot(nor, vec3(1.0,0.8,0.4)), 0.0) + 0.3;\n        stop = 0;\n        trace(stoppos + nor * 0.002, normalize(vec3(1.0,0.7,0.4)));\n        if(stop == 1) light = 0.1;\n    }\n    \n    vec3 fc = vec3(light) * col;\n    fc = toon(fc);\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tXfWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 834], [835, 835, 855, 855, 1450], [1451, 1451, 1492, 1492, 1563], [1661, 1661, 1679, 1679, 2190], [2191, 2191, 2210, 2210, 2421], [2422, 2422, 2450, 2450, 2690], [2691, 2691, 2748, 2748, 3489]], "test": "untested"}
{"id": "ll2BzR", "name": "Tempting the Mariner", "author": "dr2", "description": "Prequel to the Coleridge poem", "tags": ["reflection", "waves", "sunset", "bird", "ship"], "likes": 62, "viewed": 5401, "published": "Public API", "date": "1514378588", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Tempting the Mariner\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEVCapsDf (vec3 p, vec4 u, float r);\nfloat PrEECapsDf (vec3 p, vec3 v1, vec3 v2, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrSphDf (vec3 p, float r);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\n\nmat3 birdMat[2], bdMat;\nvec4 vum[4], vur[5];\nvec3 vim[4], vir[5];\nvec3 birdPos[2], bdPos, fltBox, shipConf, bDeck, qHit, sunDir, cloudDisp;\nfloat tCur, dstFar, szFac, shipRot, birdVel, birdLen, legAng, htWat;\nint idObj, idObjGrp;\nbool isRefl;\nconst int idHull = 1, idRud = 2, idStruc = 3, idMast = 4, idSparT = 5, idSparL = 6, idSailT = 7,\n   idSailA = 8, idSailF = 9, idFlag = 10, idRig = 11,\n   idWing = 21, idBdy = 22, idEye = 23, idBk = 24, idLeg = 25;\nconst float pi = 3.14159;\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  vec4 t4, v4;\n  vec2 q, t, tw;\n  float wFreq, wAmp, h;\n  q = 0.5 * p + vec2 (0., tCur);\n  h = 0.2 * sin (q.y) + 0.15 * sin (dot (q, vec2 (0.1, 1.2))) +\n     0.1 * sin (dot (q, vec2 (-0.2, 1.4)));\n  h *= 0.3 * (1. - smoothstep (0.8 * dstFar, dstFar, length (p)));\n  q = p;\n  wFreq = 0.5;\n  wAmp = 0.05;\n  tw = 0.5 * tCur * vec2 (1., -1.);\n  for (int j = 0; j < 4; j ++) {\n    q *= qRot;\n    t4 = q.xyxy * wFreq + tw.xxyy;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    v4 = (1. - abs (sin (t4))) * (abs (sin (t4)) + abs (cos (t4)));\n    t = 1. - sqrt (v4.xz * v4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return h;\n}\n\nvec3 WaveNf (vec2 p, float d)\n{\n  vec2 e = vec2 (max (0.01, 0.001 * d * d), 0.);\n  return normalize (vec3 (WaveHt (p) - vec2 (WaveHt (p + e.xy), WaveHt (p + e.yx)), e.x).xzy);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, skyCol, p;\n  float ds, fd, att, attSum, d, sd;\n  p = ro + rd * (200. - ro.y) / rd.y;\n  ds = 0.1 * sqrt (length (ro - p));\n  fd = 0.001 / (smoothstep (0., 10., ds) + 0.1);\n  p.xz *= fd;\n  p.xz -= cloudDisp.xz;\n  p *= 3.;\n  att = Fbm2 (p.xz);\n  attSum = att;\n  fd *= 3.;\n  d = fd;\n  ds *= fd;\n  for (int j = 0; j < 4; j ++) {\n    attSum += Fbm2 (p.xz + d * sunDir.xz);\n    d += ds;\n  }\n  sd = clamp (dot (sunDir, rd), 0., 1.);\n  skyCol = mix (vec3 (0.7, 1., 1.), vec3 (1., 0.4, 0.1), 0.25 + 0.75 * sd);\n  col = mix (vec3 (0.5, 0.75, 1.), skyCol, exp (-2. * (3. - sd) * max (rd.y - 0.1, 0.))) +\n     0.3 * (vec3 (1., 0.4, 0.2) * pow (sd, 256.) + vec3 (1., 0.8, 0.7) * pow (sd, 1024.));\n  attSum = 1. - smoothstep (1., 9., attSum);\n  col = mix (vec3 (0.4, 0., 0.2), mix (col, vec3 (0.2),\n     att * (0.001 + 0.999 * smoothstep (0.001, 0.004, rd.y))), attSum) +\n     vec3 (1., 0.4, 0.) * pow (attSum * att, 4.) * (pow (sd, 8.) + 0.5);\n  return col;\n}\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ShipHullDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, fy, fz, gz;\n  q = p;\n  d = abs (p.z) - 4.5;\n  q.z = mod (q.z + 1.4, 2.8) - 1.4;\n  q.yz -= vec2 (-3.4, -0.4);\n  d = max (d, PrBoxDf (q, vec3 (0.3, 0.1, 0.5)));\n  DMINQ (idStruc);\n  q = p;\n  q.x = abs (q.x);\n  q.yz -= vec2 (-3.8, 0.5);\n  fz = q.z / 5. + 0.3;\n  fz *= fz;\n  fy = 1. - smoothstep (-1.3, -0.1, q.y);\n  gz = smoothstep (2., 5., q.z);\n  bDeck = vec3 ((1. - 0.45 * fz * fz) * (1.1 - 0.5 * fy * fy) *\n     (1. - 0.5 * smoothstep (-5., -2., q.y) * smoothstep (2., 5., q.z)),\n     0.78 - 0.8 * gz * gz - 0.2 * (1. - smoothstep (-5.2, -4., q.z)), 5. * (1. + 0. * 0.02 * q.y));\n  d = min (PrBoxDf (vec3 (q.x, q.y + bDeck.y - 0.6, q.z), bDeck),\n     max (PrBoxDf (q - vec3 (0., 0.72, -4.6), vec3 (bDeck.x, 0.12, 0.4)),\n     - PrBox2Df (vec2 (abs (q.x) - 0.4, q.y - 0.65), vec2 (0.2, 0.08))));\n  d = max (d, - PrBoxDf (vec3 (q.x, q.y - 0.58 - 0.1 * fz, q.z), vec3 (bDeck.x - 0.07, 0.3, bDeck.z - 0.1)));\n  q = p;\n  d = max (d, - max (PrBox2Df (vec2 (q.y + 3.35, mod (q.z + 0.25, 0.5) - 0.25), vec2 (0.08, 0.1)),\n     abs (q.z + 0.5) - 3.75));\n  DMINQ (idHull);\n  q = p;\n  d = PrBoxDf (q + vec3 (0., 4.4, 4.05), vec3 (0.03, 0.35, 0.5));\n  DMINQ (idRud);\n  return dMin;\n}\n\nfloat ShipMastDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  float d, fy, fz, s, rSpar, yLim, zLim;\n  rSpar = 0.05;\n  fy = 1. - 0.07 * p.y;\n  fz = 1. - 0.14 * step (1., abs (p.z));\n  zLim = abs (p.z) - 4.5;\n  q = p;\n  d = zLim;\n  q.z = mod (q.z + 1.4, 2.8) - 1.2;\n  d = max (d, PrCapsDf ((q - vec3 (0., 3.7 * (fz - 1.), 0.)).xzy, 0.1 * fy, 3.7 * fz));\n  DMINQ (idMast);\n  q = p;\n  yLim = abs (q.y - 0.2 * fz) - 3. * fz;\n  qq = q;\n  qq.y = mod (qq.y - 3.3 * (fz - 1.), 2. * fz) - fz;\n  qq.z = mod (qq.z + 1.4, 2.8) - 1.4 + 0.1 * fz;\n  d = max (max (min (d, PrCylDf (vec3 (qq - vec3 (0., 0.05 * fy * fz, 0.1 * fz - 0.23)).xzy,\n     0.15 * fy, 0.11 * fy * fz)), yLim), zLim);\n  DMINQ (idMast);\n  d = max (max (PrCapsDf (qq.yzx, 0.05, 1.23 * fy * fz), yLim), zLim);\n  DMINQ (idSparT);\n  q = p;\n  d = min (d, min (PrEVCapsDf (q - vim[0], vum[0], rSpar), PrEVCapsDf (q - vim[1], vum[1], rSpar)));\n  d = min (d, min (PrEVCapsDf (q - vim[2], vum[2], rSpar), PrEVCapsDf (q - vim[3], vum[3], rSpar)));\n  DMINQ (idSparL);\n  return dMin;\n}\n\nfloat ShipSailDf (vec3 p, float dMin)\n{\n  vec3 q, qq, w;\n  float d, fy, fz;\n  fy = 1. - 0.07 * p.y;\n  fz = 1. - 0.14 * step (1., abs (p.z));\n  q = p;\n  qq = q;\n  qq.y = mod (qq.y - 3.1 * (fz - 1.), 2. * fz) - fz;\n  qq.z = mod (qq.z + 1.4, 2.8) - 1.4 + 0.2 * (fz - abs (qq.y)) * (fz - abs (qq.y)) - 0.1 * fz;\n  d = max (max (max (PrBoxDf (qq, vec3 ((1.2 - 0.07 * q.y) * fz, fz, 0.01)),\n     min (qq.y, 1.5 * fy * fz - length (vec2 (qq.x, qq.y + 0.9 * fy * fz)))),\n     abs (q.y - 3. * (fz - 1.)) - 2.95 * fz), - PrBox2Df (qq.yz, vec2 (0.01 * fz)));\n  d = max (d, abs (p.z) - 4.5);\n  DMINQ (idSailT);\n  q = p;\n  q.z -= -3.8;  q.y -= -1.75 - 0.2 * q.z;\n  d = PrBoxDf (q, vec3 (0.01, 0.9 - 0.2 * q.z, 0.6));\n  DMINQ (idSailA);\n  q = p;\n  q.yz -= vec2 (-1., 4.5);\n  w = vec3 (1., q.yz);\n  d = max (max (max (abs (q.x) - 0.01, - dot (w, vec3 (2.3, 1., -0.35))),\n     - dot (w, vec3 (0.68, -0.74, -1.))), - dot (w, vec3 (0.41, 0.4, 1.)));\n  DMINQ (idSailF);\n  q = p;\n  q.yz -= vec2 (3.4, 0.18);\n  d = PrBoxDf (q, vec3 (0.01, 0.2, 0.3));\n  DMINQ (idFlag);\n  return dMin;\n}\n\nfloat ShipRigDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float rRig, d, fz, gz, s;\n  rRig = 0.02;\n  fz = 1. - 0.14 * step (1., abs (p.z));\n  q = p;\n  d = abs (p.z) - 4.5;\n  gz = (q.z - 0.5) / 5. + 0.3;\n  gz *= gz;\n  gz = 1.05 * (1. - 0.45 * gz * gz);\n  q.x = abs (q.x);\n  q.z = mod (q.z + 1.4, 2.8) - 1.4;\n  d = max (d, min (PrEECapsDf (q, vec3 (1.05 * gz, -3.25, -0.5), vec3 (1.4 * fz, -2.95, -0.05), 0.7 * rRig),\n     PrEECapsDf (vec3 (q.xy, abs (q.z + 0.2) - 0.01 * (0.3 - 2. * q.y)), vec3 (gz, -3.2, 0.),\n     vec3 (0.05, -0.9 + 2. * (fz - 1.), 0.), rRig)));\n  q = p;\n  d = min (d, PrEVCapsDf (q - vir[0], vur[0], 0.8 * rRig));\n  d = min (min (d, min (PrEVCapsDf (q - vir[1], vur[1], rRig),\n     PrEVCapsDf (q - vir[2], vur[2], rRig))), PrEVCapsDf (q - vir[3], vur[3], rRig));\n  q.x = abs (q.x);\n  d = min (d, PrEVCapsDf (q - vir[4], vur[4], rRig));\n  s = step (1.8, q.y) - step (q.y, -0.2);\n  d = min (min (d, min (PrEECapsDf (q, vec3 (0.95, 0.4, 2.7) + vec3 (-0.1, 1.7, 0.) * s,\n     vec3 (0.05, 1.1, -0.15) + vec3 (0., 2., 0.) * s, rRig),\n     PrEECapsDf (q, vec3 (1.05, 1., -0.1) + vec3 (-0.1, 2., 0.) * s,\n     vec3 (0.05, 0.5, -2.95) + vec3 (0., 1.7, 0.) * s, rRig))),\n     PrEECapsDf (q, vec3 (0.95, 0.4, -2.9) + vec3 (-0.1, 1.7, 0.) * s,\n     vec3 (0.05, 0.9, -0.25) + vec3 (0., 2., 0.) * s, rRig));\n  DMINQ (idRig);\n  return dMin;\n}\n\nfloat BdBodyDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float bkLen, d, a, wr, tr, u;\n  bkLen = 0.15 * birdLen;\n  q = p;\n  wr = q.z / birdLen;\n  if (wr > 0.5) {\n    u = (wr - 0.5) / 0.5;\n    tr = 0.17 - 0.11 * u * u;\n  } else {\n    u = clamp ((wr - 0.5) / 1.5, -1., 1.);\n    u *= u;\n    tr = 0.17 - u * (0.34 - 0.18 * u); \n  }\n  d = PrCapsDf (q, tr * birdLen, birdLen);\n  DMINQ (idObjGrp + idBdy);\n  q = p;\n  q.x = abs (q.x);\n  wr = (wr + 1.) * (wr + 1.);\n  q -= birdLen * vec3 (0.3 * wr, 0.1 * wr, -1.2);\n  d = PrCylDf (q, 0.009 * birdLen, 0.2 * birdLen);\n  DMINQ (idObjGrp + idBdy);\n  q = p;\n  q.x = abs (q.x);\n  q -= birdLen * vec3 (0.08, 0.05, 0.9);\n  d = PrSphDf (q, 0.04 * birdLen);\n  DMINQ (idObjGrp + idEye);\n  q = p;  q -= birdLen * vec3 (0., -0.015, 1.15);\n  wr = clamp (0.5 - 0.3 * q.z / bkLen, 0., 1.);\n  d = PrFlatCylDf (q, 0.25 * wr * bkLen, 0.25 * wr * bkLen, bkLen);\n  DMINQ (idObjGrp + idBk);\n  return dMin;\n}\n\nfloat BdWingDf (vec3 p, float dMin)\n{\n  vec3 q, qh;\n  float wngFreq, wSegLen, wChord, wSpar, fTap, tFac, d, dd, a, wr, wf;\n  wngFreq = 6.;\n  wSegLen = 0.15 * birdLen;\n  wChord = 0.3 * birdLen;\n  wSpar = 0.03 * birdLen;\n  fTap = 8.;\n  tFac = (1. - 1. / fTap);\n  q = p - vec3 (0., 0., 0.3 * birdLen);\n  q.x = abs (q.x) - 0.1 * birdLen;\n  wf = 1.;\n  a = -0.1 + 0.2 * sin (wngFreq * tCur);\n  d = dMin;\n  qh = q;\n  for (int k = 0; k < 5; k ++) {\n    q.xy = Rot2D (q.xy, a);\n    q.x -= wSegLen;\n    wr = wf * (1. - 0.5 * q.x / (fTap * wSegLen));\n    dd = PrFlatCylDf (q.zyx, wr * wChord, wr * wSpar, wSegLen);\n    if (k < 4) {\n      q.x -= wSegLen;\n      dd = min (dd, PrCapsDf (q, wr * wSpar, wr * wChord));\n    } else {\n      q.x += wSegLen;\n      dd = max (dd, PrCylDf (q.xzy, wr * wChord, wSpar));\n      dd = min (dd, max (PrTorusDf (q.xzy, 0.98 * wr * wSpar, wr * wChord), - q.x));\n    }\n    if (dd < d) { d = dd;  qh = q; }\n    a *= 1.03;\n    wf *= tFac;\n  }\n  q = qh;\n  DMINQ (idObjGrp + idWing);\n  return dMin;\n}\n\nfloat BdFootDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float lgLen, ftLen, d;\n  lgLen = 0.1 * birdLen;\n  ftLen = 0.5 * lgLen;\n  q = p;\n  q.x = abs (q.x);\n  q -= birdLen * vec3 (0.1, -0.12, 0.6);\n  q.yz = Rot2D (q.yz, legAng);\n  q.xz = Rot2D (q.xz, -0.05 * pi);\n  q.z += lgLen;\n  d = PrCylDf (q, 0.15 * lgLen, lgLen);\n  DMINQ (idObjGrp + idLeg);\n  q.z += lgLen;\n  q.xy = Rot2D (q.xy, 0.5 * pi);\n  q.xy = Rot2D (q.xy, floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) * (2. * pi / 3.));\n  q.xz = Rot2D (q.xz, - pi + 0.4 * legAng);\n  q.z -= ftLen;\n  d = PrCapsDf (q, 0.2 * ftLen, ftLen);\n  DMINQ (idObjGrp + idLeg);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin;\n  dMin = dstFar;\n  q = p;\n  q.xz = Rot2D (q.xz, shipRot);\n  q.y -= shipConf.x + 6.6 * szFac;\n  q /= szFac;\n  dMin = dstFar / szFac;\n  dMin = ShipHullDf (q, dMin);\n  dMin = ShipMastDf (q, dMin);\n  dMin = ShipSailDf (q, dMin);\n  if (! isRefl) dMin = ShipRigDf (q, dMin);\n  dMin *= 0.7 * szFac;\n  dMin = max (dMin, - p.y + htWat);\n  idObjGrp = 1 * 256;\n  q = birdMat[0] * (p - birdPos[0]);\n  dMin /= 0.9;\n  dMin = BdBodyDf (q, dMin);\n  dMin = BdWingDf (q, dMin);\n  dMin = BdFootDf (q, dMin);\n  idObjGrp = 2 * 256;\n  q = birdMat[1] * (p - birdPos[1]);\n  dMin = BdBodyDf (q, dMin);\n  dMin = BdWingDf (q, dMin);\n  dMin = BdFootDf (q, dMin);\n  return 0.9 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0005, -0.0005);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec4 ShipCol ()\n{\n  vec4 col4;\n  vec2 cg;\n  if (idObj == idHull) {\n    if (abs (qHit.x) < bDeck.x - 0.08 && qHit.y > -3.6 && qHit.z > - bDeck.z + 0.62) {\n      col4 = vec4 (0.5, 0.3, 0., 0.1) * (0.5 + 0.5 * SmoothBump (0.05, 0.95, 0.02, mod (8. * qHit.x, 1.)));\n    } else if (qHit.y > -4.) {\n      col4 = vec4 (0.7, 0.5, 0.1, 0.1);\n      if (abs (qHit.z - 4.) < 0.25 && abs (qHit.y + 3.55) < 0.05) col4 *= 1.2;\n      else if (qHit.z < -4. && abs (qHit.x) < 0.84 && abs (qHit.y + 3.62) < 0.125) {\n        cg = step (0.1, abs (fract (vec2 (6. * qHit.x, 8. * (qHit.y + 3.62)) + 0.5) - 0.5));\n        if (cg.x * cg.y == 1.) col4 = vec4 (0.8, 0.8, 0.2, -1.);\n        else col4 *= 0.8;\n      } else {\n        col4 *= 0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.02, mod (8. * qHit.y, 1.));\n      } \n    } else if (qHit.y > -4.05) {\n      col4 = vec4 (0.8, 0.8, 0.8, 0.1);\n    } else {\n      col4 = vec4 (0.3, 0.2, 0.1, 0.);\n    }\n  } else if (idObj == idRud) {\n    col4 = vec4 (0.5, 0.3, 0., 0.);\n  } else if (idObj == idStruc) {\n    col4 = vec4 (0.4, 0.3, 0.1, 0.1);\n    if (max (abs (qHit.x), abs (qHit.z + 0.22)) < 0.2) {\n      cg = step (0.1, abs (fract (vec2 (10. * vec2 (qHit.x, qHit.z + 0.22)) + 0.5) - 0.5));\n      if (cg.x * cg.y == 1.) col4 = vec4 (0.8, 0.8, 0.2, -1.);\n    }\n  } else if (idObj == idSailT) {\n    qHit.x *= (1. + 0.07 * qHit.y) * (1. + 0.14 * step (1., abs (qHit.z)));\n    col4 = vec4 (1., 1., 1., 0.) * (0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.02, mod (4. * qHit.x, 1.)));\n    if (abs (qHit.z) < 0.2 && abs (abs (length (qHit.xy - vec2 (0., 0.3)) - 0.35) - 0.15) < 0.07)\n       col4 *= vec4 (1., 0.2, 0.2, 1.);\n  } else if (idObj == idSailA) {\n    col4 = vec4 (1., 1., 1., 0.) * (0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.02, mod (5. * qHit.z, 1.)));\n  } else if (idObj == idSailF) {\n    col4 = vec4 (1., 1., 1., 0.) * (0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.02,\n       mod (2.95 * qHit.y + 4. * qHit.z - 0.5, 1.)));\n  } else if (idObj == idFlag) {\n    col4 = vec4 (1., 1., 0.5, 0.1);\n    if (abs (abs (length (qHit.yz) - 0.1) - 0.04) < 0.02) col4 *= vec4 (1., 0.2, 0.2, 1.);\n  } else if (idObj == idMast) {\n    col4 = vec4 (0.7, 0.4, 0., 0.1);\n    if (length (qHit.xz) < 0.16 * (1. - 0.07 * qHit.y))\n       col4 *= 0.6 + 0.4 * SmoothBump (0.03, 0.97, 0.01, mod (2. * qHit.y / (1. + 0.14 * step (1., abs (qHit.z))), 1.));\n    if (qHit.y > 3.65) col4 = vec4 (1., 0., 0., -1.);\n  } else if (idObj == idSparT) {\n    qHit.x *= (1. + 0.07 * qHit.y) * (1. + 0.14 * step (1., abs (qHit.z)));\n    col4 = vec4 (0.7, 0.4, 0., 0.1) *  (0.6 + 0.4 * SmoothBump (0.08, 0.92, 0.01, mod (4. * qHit.x, 1.)));\n  } else if (idObj == idSparL) {\n    col4 = vec4 (0.7, 0.4, 0., 0.1);\n    if (qHit.z > 6.65) col4 = vec4 (1., 1., 0.3, -1.);\n  } else if (idObj == idRig) {\n    col4 = vec4 (0.2, 0.15, 0.1, 0.);\n  }\n  return col4;\n}\n\nvec4 BirdCol (vec3 n)\n{\n  vec4 col4;\n  vec3 nn;\n  float gw, w;\n  int ig, id;\n  ig = idObj / 256;\n  id = idObj - 256 * ig;\n  if (id == idWing) {\n    gw = 0.15 * birdLen;\n    w = mod (qHit.x, gw);\n    w = SmoothBump (0.15 * gw, 0.65 * gw, 0.1 * gw, w);\n    col4 = vec4 (mix (vec3 (0.05), vec3 (1.), w), 0.1);\n  } else if (id == idEye) {\n    col4 = vec4 (0., 0.6, 0., 1.);\n  } else if (id == idBdy) {\n    if (ig == 1) nn = birdMat[0] * n;\n    else nn = birdMat[1] * n;\n    col4 = vec4 (mix (mix (vec3 (1.), vec3 (0.1), smoothstep (0.5, 1., nn.y)), vec3 (1.),\n       1. - smoothstep (-1., -0.7, nn.y)), 0.1);\n  } else if (id == idBk) {\n    col4 = vec4 (1., 1., 0., 0.1);\n  } else if (id == idLeg) {\n    col4 = vec4 ((0.5 + 0.4 * sin (100. * qHit.z)) * vec3 (0.6, 0.4, 0.), 0.1);\n  }\n  return col4;\n}\n\nvoid EvalShipConf ()\n{\n  vec3 vd;\n  shipConf = vec3 (-4. * szFac, 0., 0.);\n  shipRot = 0.25 * pi * cos (0.02 * pi * tCur);\n  vim[0] = vec3 (0., -3.5, 4.3);   vd = vec3 (0., -2.6, 6.7) - vim[0];   vum[0] = vec4 (normalize (vd), length (vd));\n  vim[1] = vec3 (0., -4., 4.1);    vd = vec3 (0., -2.9, 6.) - vim[1];    vum[1] = vec4 (normalize (vd), length (vd));\n  vim[2] = vec3 (0., -1.2, -3.);   vd = vec3 (0., -0.5, -4.5) - vim[2];  vum[2] = vec4 (normalize (vd), length (vd));\n  vim[3] = vec3 (0., -2.7, -3.);   vd = vec3 (0., -2.7, -4.5) - vim[3];  vum[3] = vec4 (normalize (vd), length (vd));\n  vir[0] = vec3 (0., -3., -4.45);  vd = vec3 (0., -2.7, -4.5) - vir[0];  vur[0] = vec4 (normalize (vd), length (vd));\n  vir[1] = vec3 (0., 2.45, 2.65);  vd = vec3 (0., -2.7, 6.5) - vir[1];   vur[1] = vec4 (normalize (vd), length (vd));\n  vir[2] = vec3 (0., 2.5, 2.65);   vd = vec3 (0., -3.2, 4.9) - vir[2];   vur[2] = vec4 (normalize (vd), length (vd));\n  vir[3] = vec3 (0., 2.6, -3.);    vd = vec3 (0., -0.5, -4.5) - vir[3];  vur[3] = vec4 (normalize (vd), length (vd));\n  vir[4] = vec3 (0.65, -3.5, 3.5); vd = vec3 (0.05, -2.7, 6.4) - vir[4]; vur[4] = vec4 (normalize (vd), length (vd));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 vf;\n  float dstObj, reflFac, dstWat;\n  htWat = -1.5;\n  cloudDisp = -0.05 * tCur * vec3 (1., 0., 1.);\n  szFac = 1.;\n  EvalShipConf ();\n  isRefl = false;\n  reflFac = 1.;\n  dstObj = ObjRay (ro, rd);\n  if (rd.y < 0. && dstObj >= dstFar) {\n    isRefl = true;\n    dstWat = - (ro.y - htWat) / rd.y;\n    ro += dstWat * rd;\n    rd = reflect (rd, WaveNf (ro.xz, dstWat));\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n    reflFac *= 0.8;\n  }\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    col4 = (idObj <= idRig) ? ShipCol () : BirdCol (vn);\n    col4.gb *= 0.7;\n    col = reflFac * (col4.rgb * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n       col4.a * pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.));\n  } else {\n    col = SkyCol (ro, rd);\n    if (isRefl) col = reflFac * 0.7 * pow (col, vec3 (0.8));\n  }\n  return col;\n}\n\nvec3 BirdTrack (float t)\n{\n  vec3 bp, tt, fbR;\n  float ti[9], rdTurn, tC, tCyc, tSeq, a, h, hd, tf, rSeg;\n  rdTurn = 0.45 * min (fltBox.x, fltBox.z);\n  tC = 0.5 * pi * rdTurn / birdVel;\n  tt = vec3 (fltBox.x - rdTurn, length (fltBox.xy), fltBox.z - rdTurn) *\n     2. / birdVel;\n  tCyc = 2. * (2. * tt.z + tt.x  + 4. * tC + tt.y);\n  tSeq = mod (t, tCyc);\n  ti[0] = 0.;  ti[1] = ti[0] + tt.z;  ti[2] = ti[1] + tC;\n  ti[3] = ti[2] + tt.x;  ti[4] = ti[3] + tC;  ti[5] = ti[4] + tt.z;\n  ti[6] = ti[5] + tC;  ti[7] = ti[6] + tt.y;  ti[8] = ti[7] + tC;\n  h = - fltBox.y;\n  hd = 1.;\n  if (tSeq > 0.5 * tCyc) { tSeq -= 0.5 * tCyc;  h = - h;  hd = - hd; }\n  rSeg = -1.;\n  fbR = vec3 (1.);\n  fbR.xz -= vec2 (rdTurn) / fltBox.xz;\n  bp.xz = fltBox.xz;\n  bp.y = h;\n  if (tSeq < ti[4]) {\n    if (tSeq < ti[1]) {\n      tf = (tSeq - ti[0]) / (ti[1] - ti[0]);\n      bp.xz *= vec2 (1., fbR.z * (2. * tf - 1.));\n    } else if (tSeq < ti[2]) {\n      tf = (tSeq - ti[1]) / (ti[2] - ti[1]);  rSeg = 0.;\n      bp.xz *= fbR.xz;\n    } else if (tSeq < ti[3]) {\n      tf = (tSeq - ti[2]) / (ti[3] - ti[2]);\n      bp.xz *= vec2 (fbR.x * (1. - 2. * tf), 1.);\n    } else {\n      tf = (tSeq - ti[3]) / (ti[4] - ti[3]);  rSeg = 1.;\n      bp.xz *= fbR.xz * vec2 (-1., 1.);\n    }\n  } else {\n    if (tSeq < ti[5]) {\n      tf = (tSeq - ti[4]) / (ti[5] - ti[4]);\n      bp.xz *= vec2 (- 1., fbR.z * (1. - 2. * tf));\n    } else if (tSeq < ti[6]) {\n      tf = (tSeq - ti[5]) / (ti[6] - ti[5]);  rSeg = 2.;\n      bp.xz *= - fbR.xz;\n    } else if (tSeq < ti[7]) {\n      tf = (tSeq - ti[6]) / (ti[7] - ti[6]);\n      bp.xz *= vec2 (fbR.x * (2. * tf - 1.), - 1.);\n      bp.y = h + 2. * fltBox.y * hd * tf;\n    } else {\n      tf = (tSeq - ti[7]) / (ti[8] - ti[7]);  rSeg = 3.;\n      bp.xz *= fbR.xz * vec2 (1., -1.);\n      bp.y = - h;\n    }\n  }\n  if (rSeg >= 0.) {\n    a = 0.5 * pi * (rSeg + tf);\n    bp += rdTurn * vec3 (cos (a), 0., sin (a));\n  }\n  bp.y -= - fltBox.y - htWat;\n  bp.xz = vec2 (- bp.z, bp.x);\n  return bp;\n}\n\nvoid BirdPM (float t)\n{\n  vec3 bpF, bpB, vel, acc, va, ort, cr, sr;\n  float dt, vy, el;\n  dt = 1.;\n  bdPos = BirdTrack (t);\n  bpF = BirdTrack (t + dt);\n  bpB = BirdTrack (t - dt);\n  vel = (bpF - bpB) / (2. * dt);\n  vy = vel.y;\n  vel.y = 0.;\n  acc = (bpF - 2. * bdPos + bpB) / (dt * dt);\n  acc.y = 0.;\n  va = cross (acc, vel) / length (vel);\n  vel.y = vy;\n  el = - 0.7 * asin (vel.y / length (vel));\n  ort = vec3 (el, atan (vel.z, vel.x) - 0.5 * pi, 0.2 * length (va) * sign (va.y));\n  cr = cos (ort);\n  sr = sin (ort);\n  bdMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n          mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n          mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n  legAng = pi * clamp (0.4 + 1.5 * el, 0.12, 0.8);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  vec3 ro, rd;\n  vec2 canvas, uv;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  birdLen = 0.5;\n  birdVel = 5.;\n  fltBox = vec3 (12., 4., 12.);\n  BirdPM (tCur);\n  birdMat[0] = bdMat;\n  birdPos[0] = bdPos;\n  BirdPM (tCur + 10.);\n  birdMat[1] = bdMat;\n  birdPos[1] = bdPos;\n  ro = vec3 (0., 3., -30.);\n  rd = normalize (vec3 (uv, 2.5));\n  sunDir = normalize (vec3 (0., 0.05, 1.));\n  dstFar = 100.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrEVCapsDf (vec3 p, vec4 u, float r)\n{\n  return length (p - clamp (dot (p, u.xyz), 0., u.w) * u.xyz) - r;\n}\n\nfloat PrEECapsDf (vec3 p, vec3 v1, vec3 v2, float r)\n{\n  return PrEVCapsDf (p - v1, vec4 (normalize (v2 - v1), length (v2 - v1)), r);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (rhi * clamp (p.x / rhi, -1., 1.), 0.)) - rlo, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2BzR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 1177, 1200, 1200, 1938], [1940, 1940, 1971, 1971, 2117], [2119, 2119, 2151, 2151, 3109], [3182, 3182, 3221, 3221, 4413], [4415, 4415, 4454, 4454, 5437], [5439, 5439, 5478, 5478, 6503], [6505, 6505, 6543, 6543, 7844], [7846, 7846, 7883, 7883, 8766], [8768, 8768, 8805, 8805, 9782], [9784, 9784, 9821, 9821, 10407], [10409, 10409, 10431, 10431, 11113], [11115, 11115, 11148, 11148, 11325], [11327, 11327, 11348, 11348, 11548], [11550, 11550, 11567, 11567, 14364], [14366, 14366, 14389, 14389, 15161], [15163, 15163, 15185, 15185, 16349], [16351, 16351, 16386, 16386, 17273], [17275, 17275, 17301, 17301, 19252], [19254, 19254, 19277, 19277, 20016], [20018, 20018, 20071, 20071, 20583], [20585, 20585, 20617, 20617, 20717], [20719, 20719, 20752, 20752, 20841], [20843, 20843, 20886, 20886, 20950], [20952, 20952, 20996, 20996, 21065], [21067, 21067, 21121, 21121, 21202], [21204, 21204, 21237, 21237, 21264], [21266, 21266, 21308, 21308, 21359], [21361, 21361, 21420, 21420, 21519], [21521, 21521, 21567, 21567, 21624], [21626, 21626, 21671, 21671, 21774], [21776, 21776, 21833, 21833, 21916], [21918, 21918, 21948, 21948, 22022], [22056, 22056, 22080, 22080, 22210], [22212, 22212, 22237, 22237, 22423], [22425, 22425, 22446, 22446, 22601]], "test": "untested"}
{"id": "ll2fz1", "name": "golfed truchet (550 chars)", "author": "abje", "description": "a truchet shader in 551 chars\nmany of the variable names are just randomly chosen from the alphabet", "tags": ["3d", "1k", "truchet"], "likes": 10, "viewed": 609, "published": "Public API", "date": "1514674145", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**/\n//torus sdf\n#define v vec3\n#define r(i) length(v(0,length(t[i].xy)-1.,s[i]))-.1\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    v p = iTime*v(.5),\n    \t F = iResolution,\n         d = normalize(v((U.xy * 2.0 - F.xy) / F.y,1)),s,q,f;\n    float D = 0.,\n          l,\n          Q;\n    for (int i = 0; i < 99; i++) {\n        \n        F = floor(p*.5);\n        f =\tv(sign(sin(F.y*F.z+F.zx+.1)),1);\n        s = (mod(p,2.)-1.)*f;\n        \n        v a = v(1,-1,0);\n        mat3 t = mat3(\n            s.yzx+a.xxz,\n            s.zxy-a.xxz,\n            s+a\n        );\n\n        l = min(min(r(0),r(1)),r(2));\n\t\t\n        //position of the nearest torus\n        q = t[ int(r(1)<=l) + 2*int(r(2)<=l) ];\n        \n        p += d*l;\n        D += l;\n    }\n    //coloring the truchet in a rainbow pattern\n    O.xyz = (sin(((mod(F.x+F.y,2.)*2.-1.)\n            *(atan(q.x,q.y)*6.+atan(q.z,length(q.xy)-1.)*f.x*f.y)*1.9+iTime*4.) //+3.14*10.0*atan(q.z,length(q.xy))\n            *2.1+v(1,2,3))*0.5+0.5)\n            /(D*D*.02+1.);\n    \n    //O.xyz = q*0.5+0.5;\n    //O /= (D*D*.02+1.);\n}\n/**/\n\n//341 chars. minimal with boring shading\n/**\n#define r(p,l) length(vec2(length(p)-1.,l))-.1\n\n#define mainImage(O, U)\t\t\t\t\t\t\t\t\t\t\t\\\n    vec3 p = iTime*vec3(.5),\t\t\t\t\t\t\t\t\t\\\n         F = iResolution,\t\t\t\t\t\t\t\t\t\t\\\n         d = normalize(vec3((U.xy * 2.0 - F.xy) / F.y,1)),f;\t\\\n    float D = 0., j = 0., l;\t\t\t\t\t\t\t\t\t\\\n    while (j++ < 99.) {\t\t\t\t\t\t\t\t\t\t\t\\\n        F = floor(p*.5);\t\t\t\t\t\t\t\t\t\t\\\n        f = (p-F*2.-1.)*vec3(sign(sin(F.y+F.z*F+1.)));\t\t\t\\\n        l = min(min(\t\t\t\t\t\t\t\t\t\t\t\\\n            r(f.yz+1.,f.x),\t\t\t\t\t\t\t\t\t\t\\\n            r(f.zx-1.,f.y)),\t\t\t\t\t\t\t\t\t\\\n            r(f.xy+vec2(1,-1),f.z));\t\t\t\t\t\t\t\\\n        p += d*l;\t\t\t\t\t\t\t\t\t\t\t\t\\\n        D += l;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    O = vec4(1./(D*D*.02+1.));\t\t\t\t\t\t\t\t\t\\\n/**/\n\n//469 char. same as under with more random flipping\n/**\n#define r(i) length( vec2( length(t[i].xy)-1., s[i] ) ) -.1  //torus sdf\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec3 p = vec3(iTime*.5),\n         R = iResolution,\n         d = normalize(vec3(U+U - R.xy, R.y)),   F,s,q;\n    float D = 0., l;\n\n    for (int i = 0; i < 99; i++) {       \n        F = floor(p*.5),        \n        s = (mod(p,2.) - 1.)*vec3(sign(sin(F.yz*F.xy)+.01),1); //randomizing truchet direction\n        //i can't have perfect flow with fully random truchets  so i set f.z to 1\n              \n        mat3 t = mat3( s.yzx - 1.,\n                       s.zxy + 1.,\n                       s + vec3(-1,1,0)\n                     );\n\n        l = min(min(r(0),r(1)),r(2)),\n        q = t[ l==r(1) ? 1 : l==r(2) ? 2 : 0 ], //position of the nearest torus\n\t\t   \n        p += d*l,\n        D += l;\n    }\n    \n    l = (mod(F.x+F.y,2.)*2.-1.) * atan(q.x,q.y) * 1.9 + iTime; //the truchet flow\n    O = ( sin( l* vec4(1,2,3,0)*2.1) + 1. ) / (D*D*.04+2.);\n}\n/**/\n\n//467 char. by FabriceNeyret2\n/**\n#define r(i) length( vec2( length(t[i].xy)-1., s[i] ) ) -.1  //torus sdf\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec3 p = vec3(iTime*.5),\n         R = iResolution,\n         d = normalize(vec3(U+U - R.xy, R.y)),   F,s,q;\n    float D = 0., l;\n\n    for (int i = 0; i < 99; i++) {       \n        F = floor(p*.5),        \n        s = mod(p,2.) - 1.,\n        s.xy *= sin(F.x*F.y*F.z) > 0.? 1. :-1.; //randomizing truchet direction\n        //i can't have perfect flow with fully random truchets  so i set f.z to 1\n              \n        mat3 t = mat3( s.yzx - 1.,\n                       s.zxy + 1.,\n                       s + vec3(-1,1,0)\n                     );\n\n        l = min(min(r(0),r(1)),r(2)),\n        q = t[ l==r(1) ? 1 : l==r(2) ? 2 : 0 ], //position of the nearest torus\n\t\t   \n        p += d*l,\n        D += l;\n    }\n    \n    l = (mod(F.x+F.y,2.)*2.-1.) * atan(q.x,q.y) * 1.9 + iTime; //the truchet flow\n    O = ( sin( l* vec4(1,2,3,0)*2.1) + 1. ) / (D*D*.04+2.);\n}\n/**/\n//472 char. by FabriceNeyret2\n/**\n#define r(i) length( vec2(length(t[i].xy)-1.,s[i]) )-.1  //torus sdf\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec3 p = vec3(iTime*.5),\n         R = iResolution,\n         d = normalize(vec3(U+U - R.xy, R.y)),   F,s,q;\n    float D = 0., l, Q;\n\n    for (int i = 0; i < 99; i++) {       \n        F = floor(p*.5);        \n        s = mod(p,2.) - 1.;\n        s.xy *= sin(F.x*F.y*F.z) > 0.? 1. :-1.; //randomizing truchet direction\n        //i can't have perfect flow with fully random truchets  so i set f.z to 1\n              \n        mat3 t = mat3( s.yzx - 1.,\n                       s.zxy + 1.,\n                       s + vec3(-1,1,0)\n                     );\n\n        l = min(min(r(0),r(1)),r(2));\t\n        q = t[ l==r(1) ? 1 : l==r(2) ? 2 : 0 ]; //position of the nearest torus\n\t\t   \n        p += d*l;\n        D += l;\n    }\n    \n    Q = (mod(F.x+F.y,2.)*2.-1.) * atan(q.x,q.y) * 1.9 + iTime; //the truchet flow\n    O = ( sin(Q*vec4(1,2,3,0)*2.1) + 1. ) / (D*D*.04+2.);\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2fz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 86, 127, 127, 1062]], "test": "untested"}
{"id": "llfBDs", "name": "2 balls", "author": "saidwho12", "description": "just 2 balls.", "tags": ["raytracing", "phong", "ray", "spheretracing", "blinn"], "likes": 0, "viewed": 168, "published": "Public", "date": "1513904950", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITERATIONS 256\n\n#define RAY_T_MIN 0.001\n#define RAY_T_MAX 1.0e30\n\n#define EPSILON 0.01\n\n// Polynomial smooth minimum by iq\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n  return mix(a, b, h) - k*h*(1.0-h);\n}\n\nstruct Light\n{\n    vec3 point;\n};\n\nstruct Material \n{\n    float ambient;\n\tfloat diffuse;\n    float specular;\n    float a; // a >> 1.0\n};\n\n\nfloat phong (in vec3 L, in vec3 N, in vec3 R, in vec3 V, in Light light, in Material mat)\n{\n    float diffuse = mat.diffuse*dot(L, N);\n    float specular = mat.specular*pow(dot(R, V), mat.a);\n\n\treturn diffuse + specular + mat.ambient;\n}\n\nstruct Sphere \n{\n\tvec3 center;\n    float r;\n};\n\n    \nstruct Plane\n{\n    vec3 center;\n    vec3 normal;\n};\n    \nfloat opU(float d1, float d2)\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2)\n{\n    return max(-d1,d2);\n}\n\nfloat opI(float d1, float d2)\n{\n    return max(d1,d2);\n}\n\nfloat sphereSDF (vec3 point, Sphere s)\n{\n\treturn distance(point, s.center)-s.r;\n}\n\nfloat opBlendSS (vec3 p, Sphere s1, Sphere s2, float k)\n{\n    float d1 = sphereSDF(p, s1);\n    float d2 = sphereSDF(p, s2);\n    return smin(d1, d2, k);\n}\n\nfloat sceneSDF (vec3 p)\n{\n    Sphere s1 = Sphere(vec3(sin(-iTime)*3., 1.5, 0), 2.0);\n    Sphere s2 = Sphere(vec3(sin(iTime)*3., -1.5, 0), 2.0);\n    vec3 c = vec3(15.,15.,15.);\n    vec3 q = mod(p,c)-0.5*c;\n    return opBlendSS(q, s1, s2, 1.5);\n}\n\nvec3 estimateNormal(vec3 point) {\n    return normalize(vec3(\n        sceneSDF(vec3(point.x + EPSILON, point.y, point.z)) - sceneSDF(vec3(point.x - EPSILON, point.y, point.z)),\n        sceneSDF(vec3(point.x, point.y + EPSILON, point.z)) - sceneSDF(vec3(point.x, point.y - EPSILON, point.z)),\n        sceneSDF(vec3(point.x, point.y, point.z  + EPSILON)) - sceneSDF(vec3(point.x, point.y, point.z - EPSILON))\n    ));\n}\n\nfloat trace (vec3 eye, vec3 dir)\n{\n    \n    float t = RAY_T_MIN;\n    int i = 0;    \n    while(i < MAX_ITERATIONS && t < RAY_T_MAX)\n    {\n        float radius = sceneSDF(eye + (dir*t));\n        if (radius < RAY_T_MIN)\n        {\n            break;\n        }\n        t += radius;\n        i++;\n        \n    if (i==MAX_ITERATIONS || t == RAY_T_MAX)\n        return RAY_T_MAX;\n    }\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    const float PI = 3.14159;\n    \n    vec3 eye = vec3(0,0,5);\n    \n    vec3 forward = vec3(0,0,-1);\n    vec3 up = vec3(0,1,0);\n    vec3 right = cross(forward, up);\n    \n    float fov = PI/4.0;\n    \n    float aspect = iResolution.y / iResolution.x;\n    \n    float w = tan(fov);\n    float h = w * aspect;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 point = uv*2.0-1.0;\n        \n    vec3 dir = normalize(forward + point.x * w * right + point.y * h * up);\n    \n    Light light = Light(vec3(.0, .0, 3.));\n    \n    Material mat = Material(0.0, 0.3, 0.7, 10.0);\n    \n    float t = trace(eye, dir);\n    vec3 P = eye + (dir*t); // P is point of intersection\n    \n    vec3 L = normalize(light.point - P);\n    vec3 V = dir;\n    vec3 N = estimateNormal(P);\n    vec3 R = reflect(N, L);\n   \n    vec3 color = vec3(phong(L, N, R, V, light, mat));\n    \n    /*\n    if (!(trace(P + N*0.01, L) == RAY_T_MAX))\n    {\n        color *= vec3(0.13);\n    }\n\t*/\n\t\n    //color = N+1.0 /2.0;\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llfBDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 135, 174, 174, 261], [402, 402, 493, 493, 638], [750, 750, 781, 781, 806], [808, 808, 840, 840, 866], [868, 868, 899, 899, 924], [926, 926, 966, 966, 1007], [1009, 1009, 1066, 1066, 1162], [1164, 1164, 1189, 1189, 1408], [1410, 1410, 1443, 1443, 1825], [1827, 1827, 1861, 1861, 2223], [2225, 2225, 2282, 2282, 3301]], "test": "untested"}
{"id": "llfBW2", "name": "A Tile Wall", "author": "challenge", "description": "A Wall", "tags": ["2d", "wall"], "likes": 1, "viewed": 410, "published": "Public API", "date": "1513561679", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.1415926535897932384626433832795;\n\nvec2 brickTile(vec2 _st, float _zoom){\n    _st *= _zoom;\n\n    // Here is where the offset is happening\n    float s = sin(iTime);\n    \n    if(s > 0.0) {\n        _st.x += step(1., mod(_st.y,2.0)) * fract(iTime/PI*2.0);\n    } else {\n        _st.y += step(1., mod(_st.x,2.0)) * fract(iTime/PI*2.0); \n    }\n    \n\n    return fract(_st);\n}\n\nfloat box(vec2 _st, vec2 _size){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 uv = smoothstep(_size,_size+vec2(1e-4),_st);\n    uv *= smoothstep(_size,_size+vec2(1e-4),vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //uv -= vec2(0.5);\n    //uv = rotate2d( sin(iTime/5.0)*PI ) * uv;\n    //uv += vec2(0.5);\n    \n    vec2 st = uv;\n    st.x *= iResolution.x / iResolution.y;\n    st /= vec2(2.15,0.65)/1.5;\n    st = brickTile(st,5.0);\n    \n    vec3 color = vec3(box(st,vec2(0.9)));\n\tcolor = mix(vec3(0.85, 0.84, 0.79),\n                vec3(0.82, 0.44, 0.31),\n               color.r);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llfBW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 85, 85, 379], [381, 381, 413, 413, 584], [586, 586, 614, 614, 700], [702, 702, 759, 759, 1213]], "test": "untested"}
{"id": "llfBzl", "name": "Entanglement", "author": "felipunkerito", "description": "Some sine waves interacting in the most classical manner, I am a total noob, so any comments would be appreciated \n", "tags": ["math", "wave", "sin", "trig", "input", "user"], "likes": 6, "viewed": 562, "published": "Public API", "date": "1512876243", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Licensed under IDGF licence which states that everything I have written can be used for whatever\n// the fuck you want including monetization or what not,\n// IDGF stands for I Dont Give a Fuck  \n\nfloat hasher( float hash )\n{\n\n\treturn fract(sin(54556.46 * hash));\n\n}\n\nfloat trig( float dist, float decay, float frequency, float amplitude, float speed )\n{\n\n\treturn exp(-decay * dist) *  \n    sin(dist * frequency + ((iTime) * speed)) * amplitude;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.y;\n    float freq = (50.0);\n    float ampl = 2.1;\n    vec2 center = m;\n    float n = .3;\n    vec2 cir = vec2( 0.7 + n * sin( iTime ), 0.5 + n * cos( iTime ) );\n    vec2 centerOne = vec2( cir.x, cir.y );\n    float dist = length(uv - center);\n    float distOne = length(uv - centerOne);\n    float decay = 5.8;\n    float trigger = dist * distOne;\n    float speed = 2.0;\n    float triggy = 0.0;\n    float maxiter = 5.0;\n    triggy = trig(trigger, decay, freq, ampl, speed);\n    \n    float colourer = mix( triggy*(iTime),0.2, 1.0 );\n    vec3 rgb = vec3( min( triggy, colourer), min( triggy, colourer ), min( triggy, colourer ) );\n    fragColor = vec4( triggy, rgb );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llfBzl.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[0, 198, 226, 226, 267], [269, 269, 355, 355, 453], [455, 455, 512, 512, 1254]], "test": "untested"}
{"id": "llffWs", "name": "Filtered checker (triangle, 3D)", "author": "iq", "description": "An improvement to [url]https://www.shadertoy.com/view/XlXBWs[/url]. Uisng a triangular filter kernel rather than a box filter produces flicker-free animation. The maths are a little bit more involved, but still has an analytical result.", "tags": ["3d", "filtering", "analytical", "integration", "checkedboard"], "likes": 56, "viewed": 3578, "published": "Public API", "date": "1513895944", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Similar to https://www.shadertoy.com/view/XlXBWs, but with a triangular filter kernel,\n// which produces less flickering animations that a box filter. Luckily, it's still easily\n// integrable analytically!\n//\n// Info: http://iquilezles.org/www/articles/filterableprocedurals/filterableprocedurals.htm\n//  \n// More filtered patterns:  https://www.shadertoy.com/playlist/l3KXR1\n  \n\n// --- analytically triangle-filtered checkerboard ---\n\nvec3 pri( in vec3 x )\n{\n    // see https://www.shadertoy.com/view/MtffWs\n    vec3 h = fract(x/2.0)-0.5;\n    return x*0.5 + h*(1.0-2.0*abs(h));\n}\n\nfloat checkersTextureGradTri( in vec3 p, in vec3 ddx, in vec3 ddy )\n{\n    vec3 w = max(abs(ddx), abs(ddy)) + 0.01;       // filter kernel\n    vec3 i = (pri(p+w)-2.0*pri(p)+pri(p-w))/(w*w); // analytical integral (box filter)\n    return 0.5 - 0.5*i.x*i.y*i.z;                  // xor pattern\n}\n\n// --- analytically box-filtered checkerboard ---\n\nvec3 tri( in vec3 x )\n{\n    vec3 h = fract(x/2.0)-0.5;\n    return 1.0-2.0*abs(h);\n}\n\nfloat checkersTextureGradBox( in vec3 p, in vec3 ddx, in vec3 ddy )\n{\n    vec3 w = max(abs(ddx), abs(ddy)) + 0.01;   // filter kernel\n    vec3 i = (tri(p+0.5*w)-tri(p-0.5*w))/w;    // analytical integral (box filter)\n    return 0.5 - 0.5*i.x*i.y*i.z;              // xor pattern\n}\n\n// --- unfiltered checkerboard ---\n\nfloat checkersTexture( in vec3 p )\n{\n    vec3 q = floor(p);\n    return mod( q.x+q.y+q.z, 2.0 );            // xor pattern\n}\n\n//===============================================================================================\n//===============================================================================================\n// sphere implementation\n//===============================================================================================\n//===============================================================================================\n\nfloat softShadowSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = sph.xyz - ro;\n    float b = dot( oc, rd );\n\t\n    float res = 1.0;\n    if( b>0.0 )\n    {\n        float h = dot(oc,oc) - b*b - sph.w*sph.w;\n        res = smoothstep( 0.0, 1.0, 2.0*h/b );\n    }\n    return res;\n}\n\nfloat occSphere( in vec4 sph, in vec3 pos, in vec3 nor )\n{\n    vec3 di = sph.xyz - pos;\n    float l = length(di);\n    return 1.0 - dot(nor,di/l)*sph.w*sph.w/(l*l); \n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    float t = -1.0;\n\tvec3  ce = ro - sph.xyz;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\tt = -b - sqrt(h);\n\t}\n\t\n\treturn t;\n}\n\n//===============================================================================================\n//===============================================================================================\n// scene\n//===============================================================================================\n//===============================================================================================\n\n\n// spheres\nconst vec4 sc0 = vec4(  2.0, 0.5, 0.8, 0.5 );\nconst vec4 sc1 = vec4( -6.0, 1.0,-4.0, 3.0 );\nconst vec4 sc2 = vec4(-16.0, 1.0, 7.0, 4.0 );\nconst vec4 sc3 = vec4(-25.0, 8.0, 0.0, 9.0 );\n\nfloat intersect( vec3 ro, vec3 rd, out vec3 pos, out vec3 nor, out float occ, out float matid )\n{\n    // raytrace\n\tfloat tmin = 10000.0;\n\tnor = vec3(0.0);\n\tocc = 1.0;\n\tpos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = (0.01-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tmatid = 0.0;\n\t\tocc = occSphere( sc0, pos, nor ) * \n\t\t\t  occSphere( sc1, pos, nor ) *\n\t\t\t  occSphere( sc2, pos, nor ) *\n\t\t\t  occSphere( sc3, pos, nor );\n\t}\n\n\t// raytrace-sphere\n\th = iSphere( ro, rd, sc0 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + h*rd;\n\t\tnor = normalize(pos-sc0.xyz); \n\t\tmatid = 1.0;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc1 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(ro+h*rd-sc1.xyz); \n\t\tmatid = 1.0;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc2 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(ro+h*rd-sc2.xyz); \n\t\tmatid = 1.0;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc3 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(ro+h*rd-sc3.xyz); \n\t\tmatid = 1.0;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\treturn tmin;\t\n}\n\nvec3 texCoords( in vec3 p )\n{\n\treturn 5.0*p;\n}\n\n\nvoid calcCamera( out vec3 ro, out vec3 ta )\n{\n\tfloat an = 0.3*sin(0.04*iTime);\n\tro = vec3( 5.5*cos(an), 1.0, 5.5*sin(an) );\n    ta = vec3( 0.0, 1.0, 0.0 );\n\n}\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in float occ, in vec3 rd )\n{\n    float sh = min( min( min( softShadowSphere( pos, vec3(0.57703), sc0 ),\n\t\t\t\t              softShadowSphere( pos, vec3(0.57703), sc1 )),\n\t\t\t\t              softShadowSphere( pos, vec3(0.57703), sc2 )),\n                              softShadowSphere( pos, vec3(0.57703), sc3 ));\n\tfloat dif = clamp(dot(nor,vec3(0.57703)),0.0,1.0);\n\tfloat bac = clamp(dot(nor,vec3(-0.707,0.0,-0.707)),0.0,1.0);\n    vec3 lin  = dif*vec3(1.50,1.40,1.30)*sh;\n\t     lin += occ*vec3(0.15,0.20,0.30);\n\t     lin += bac*vec3(0.10,0.10,0.10);\n\n    return lin;\n}\n//===============================================================================================\n//===============================================================================================\n// render\n//===============================================================================================\n//===============================================================================================\n\nvoid calcRayForPixel( in vec2 pix, in vec2 res, out vec3 resRo, out vec3 resRd )\n{\n\tvec2 p = (-res.xy + 2.0*pix) / res.y;\n\t\n     // camera movement\t\n\tvec3 ro, ta;\n\tcalcCamera( ro, ta );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\t\n\tresRo = ro;\n\tresRd = rd;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = vec2(iResolution.x/3.0,iResolution.y);\n    \n    int   id = int( floor(fragCoord.x/res.x) );\n    vec2  px = vec2( fragCoord.x - float(id)*res.x,fragCoord.y);\n\t\n\tvec3 ro, rd, ddx_ro, ddx_rd, ddy_ro, ddy_rd;\n\tcalcRayForPixel( px + vec2(0.0,0.0), res, ro, rd );\n\tcalcRayForPixel( px + vec2(1.0,0.0), res, ddx_ro, ddx_rd );\n\tcalcRayForPixel( px + vec2(0.0,1.0), res, ddy_ro, ddy_rd );\n\t\t\n    // trace\n\tvec3 pos, nor;\n\tfloat occ, mid;\n    float t = intersect( ro, rd, pos, nor, occ, mid );\n\n\tvec3 col = vec3(0.9);\n\tif( t<100.0 )\n\t{\n#if 1\n\t\t// -----------------------------------------------------------------------\n        // compute ray differentials by intersecting the tangent plane to the  \n        // surface.\t\t\n\t\t// -----------------------------------------------------------------------\n\n\t\t// computer ray differentials\n\t\tvec3 ddx_pos = ddx_ro - ddx_rd*dot(ddx_ro-pos,nor)/dot(ddx_rd,nor);\n\t\tvec3 ddy_pos = ddy_ro - ddy_rd*dot(ddy_ro-pos,nor)/dot(ddy_rd,nor);\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec3     uvw = texCoords(     pos );\n\t\tvec3 ddx_uvw = texCoords( ddx_pos ) - uvw;\n\t\tvec3 ddy_uvw = texCoords( ddy_pos ) - uvw;\n#else\n\t\t// -----------------------------------------------------------------------\n        // Because we are in the GPU, we do have access to differentials directly\n        // This wouldn't be the case in a regular raytrace.\n\t\t// It wouldn't work as well in shaders doing interleaved calculations in\n\t\t// pixels (such as some of the 3D/stereo shaders here in Shadertoy)\n\t\t// -----------------------------------------------------------------------\n\t\tvec3 uvw = texCoords( pos );\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec3 ddx_uvw = dFdx( uvw ); \n        vec3 ddy_uvw = dFdy( uvw ); \n#endif\n\n        \n\t\t// shading\t\t\n\t\tvec3 mate = vec3(0.0);\n\t\tif( id==0 ) \n            mate = vec3(1.0)*checkersTexture( uvw );\n        else if( id==1 )\n            mate = vec3(1.0)*checkersTextureGradBox( uvw, ddx_uvw, ddy_uvw );\n        else if( id==2 )\n            mate = vec3(1.0)*checkersTextureGradTri( uvw, ddx_uvw, ddy_uvw );\n\n        // lighting\t\n\t\tvec3 lin = doLighting( pos, nor, occ, rd );\n\n        // combine lighting with material\t\t\n\t\tcol = mate * lin;\n\t\t\n        // fog\t\t\n        col = mix( col, vec3(0.9), 1.0-exp( -0.0001*t*t ) );\n\t}\n\t\n    // gamma correction\t\n\tcol = pow( col, vec3(0.4545) );\n\n\tcol *= smoothstep( 2.0, 3.0, abs(px.x) );\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llffWs.jpg", "access": "shaders20k", "license": "mit", "functions": [[1462, 1518, 1541, 1590, 1662], [1664, 1664, 1733, 1733, 1956], [1958, 2009, 2032, 2032, 2092], [2094, 2094, 2163, 2163, 2374], [2376, 2412, 2448, 2448, 2535], [2537, 2955, 3018, 3018, 3241], [3243, 3243, 3301, 3301, 3409], [3411, 3411, 3465, 3465, 3651], [4056, 4252, 4349, 4365, 5468], [5470, 5470, 5499, 5499, 5516], [5519, 5519, 5564, 5564, 5677], [5679, 5679, 5750, 5750, 6285], [6286, 6689, 6771, 6771, 7128], [7131, 7131, 7188, 7188, 9606]], "test": "untested"}
{"id": "lljBRh", "name": "Icosahedron 10th Stellation", "author": "mla", "description": "One chiral set of the f1 stellation cells of the icosahedron, the 10th stellation according to Wenninger.\n\nMouse to rotate, Key 'a' to show both chiral sets.\n\nUses code from knighty's polyhedron shader: https://www.shadertoy.com/view/XlX3zB", "tags": ["raymarching", "icosahedron", "stellation", "chiral"], "likes": 1, "viewed": 505, "published": "Public API", "date": "1514628671", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Created by Matthew Arcus, 2017.\n//\n// Uses parts of knighty's polyhedron shader: https://www.shadertoy.com/view/XlX3zB,\n// particularly the raymarching code & some of the geometry.\n//\n// Display one set of the chiral f1 cells in the stellation of the icosahedron.\n// Each set of cells can be generated by the intersection of certain planes\n// of the icosahedron with the fundamental region. Since the f1 cells are\n// chiral, we need to keep track of the number of mirror flips when folding\n// and the final DE has to take into account the parity - for odd parity, use\n// distance when position reflected into the neighbouring cells.\n//\n// All the other cell sets of the icosahedron are achiral and are easier\n// to generate (see forthcoming shader).\n//\n////////////////////////////////////////////////////////////////////////////////\n\nbool achiral = false; // Show both chiral forms\n\nconst float scale = 2.0;\nconst vec3 color0 = vec3(0.7,0.7,0.1);\nconst vec3 color1 = vec3(0.1,0.1,0.1);\n\n// Setup folding planes and vertex\nconst float PI\t= 3.1415927;\nconst int M = 3, N = 5;\nconst float A = cos(PI/float(N));\nconst float B = cos(PI/float(M));\nconst float C = sqrt(1.0 - A*A - B*B);\nconst vec3 R = vec3(-A,-B,C); // 3rd folding plane. The two others are xz and yz planes\nconst vec3 plane0 = vec3(-0.5774, 0.5774, 0.5774);\nconst vec3 plane1 = vec3(0, 0.9342, 0.3568);\nconst vec3 plane2 = vec3(0.5774, -0.5774, 0.5774);\nconst vec3 plane3 = vec3(-0.5774, -0.5774, 0.5774);\n\nvec3 refla(vec3 p) { return vec3(-p.x,p.y,p.z); }\nvec3 reflb(vec3 p) { return vec3(p.x,-p.y,p.z); }\nvec3 reflc(vec3 p) { return p - 2.0*dot(p,R)*R; } //fold about R plane\n\n// Return the parity of the number of mirror flips\nint fold(inout vec3 pos) {\n  int flips = 0;\n  for (int i = 0; i < 5; i++) {\n    flips += int(pos.x < 0.0); // I hope this is branchless\n    pos.x = abs(pos.x);\n    flips += int(pos.y < 0.0);\n    pos.y = abs(pos.y);\n    float k = dot(pos,R);\n    flips += int(k < 0.0);\n    pos -= 2.0*min(0.0,k)*R; //fold about R plane\n  }\n  return flips-flips/2*2; // For version < 3.00\n}\n\nfloat f1a(vec3 pos) {\n  float d = -(dot(pos,plane0) - 1.0);\n  d = max(d,dot(pos,plane1) - 1.0);\n  d = max(d,-(dot(pos,plane2) - 1.0));\n  d = max(d,dot(pos,plane3) - 1.0);\n  return d;\n}\n\nfloat f1(vec3 pos, int parity) {\n  if (parity == 0 || achiral) return f1a(pos);\n  float d = f1a(refla(pos));\n  d = min(d,f1a(reflb(pos)));\n  d = min(d,f1a(reflc(pos)));\n  return d;\n}\n\nfloat poly(vec3 pos) {\n  pos *= scale;\n  int parity = fold(pos);\n  return f1(pos,parity)/scale;\n}\n\nvec3 getcolor(vec3 pos) {\n  pos *= scale;\n  int parity = fold(pos);\n  return (achiral && parity == 1) ? color1 : color0;\n}\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 calcNormal(in vec3 p) {\n  const vec2 e = vec2(0.0001, 0.0);\n  return normalize(vec3(poly(p + e.xyy) - poly(p - e.xyy),\n                        poly(p + e.yxy) - poly(p - e.yxy),\n                        poly(p + e.yyx) - poly(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n  const float maxd = 4.0;\n  const float precis = 0.0001;\n  float h = precis * 2.0;\n  float t = 0.0;\n  float res = -1.0;\n  for (int i = 0; i < 100; i++) {\n      if (h < precis || t > maxd) break;\n      h = poly(ro + rd * t);\n      t += h;\n    }\n  if (t < maxd) res = t;\n  return res;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  p.yz = rotate(p.yz,iTime * 0.125);\n  p.zx = rotate(p.zx,iTime * 0.2);\n  return p;\n}\n\nconst int CHAR_A = 65;\nbool keypress(int code) {\n#if __VERSION__ < 300\n  return false;\n#else\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  achiral = keypress(CHAR_A);\n  vec2 p = 2.0*fragCoord.xy / iResolution.xy - 1.0;\n  p *= 3.0*vec2(1,-1)*iResolution.xy/iResolution.y;\n  vec3 col = vec3(0.3 + p.y * 0.1);\n  vec3 ro = vec3(0.0, 0.0, 2.5);\n  vec3 rd = normalize(vec3(p, -6.0));\n  vec3 li = normalize(vec3(0.5, 0.8, 3.0));\n  ro = transform(ro);\n  rd = transform(rd);\n  li = transform(li);\n  float t = march(ro,rd);\n  if (t > 0.001) {\n    vec3 pos = ro + t * rd;\n    vec3 n = calcNormal(pos);\n    col = getcolor(pos);\n    float diffuse = clamp(dot(n, li), 0.0, 1.0);\n    col *= diffuse;\n    col = pow(col, vec3(0.4545));\n  }\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljBRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1299, 1557, 1577, 1577, 1606], [1607, 1607, 1627, 1627, 1656], [1657, 1657, 1677, 1677, 1706], [1729, 1780, 1806, 1806, 2151], [2153, 2153, 2174, 2174, 2337], [2339, 2339, 2371, 2371, 2521], [2523, 2523, 2545, 2545, 2620], [2622, 2622, 2647, 2647, 2744], [2746, 2844, 2880, 2880, 2932], [2934, 2934, 2962, 2962, 3179], [3181, 3181, 3218, 3218, 3503], [3505, 3505, 3532, 3532, 3836], [3861, 3861, 3886, 3886, 3997], [3999, 3999, 4056, 4056, 4674]], "test": "untested"}
{"id": "lljBzz", "name": "Dizzy The Egg!", "author": "Del", "description": "Dizzy!", "tags": ["raymarch", "dizzy"], "likes": 11, "viewed": 4835, "published": "Public API", "date": "1514396211", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// dizzy the egg - Del 27/12/17\n\n\n//------------------------------------------------------------------------\n// Camera\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    vec2 mouse2 = vec2(0.0);\n    if (iMouse.z > 0.5)\n    {\n        mouse2 = mouse;\n        mouse2.y -= 0.1;\n    }\n    \n//    float an = 0.3*iTime + 10.0*mouse.x;\n    float an = 10.0*mouse2.x;\n    mouse2.y *= 4.0;\n\tcamPos = vec3(5.5*sin(an),0.0+mouse2.y*2.0,5.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n    \n//------------------------------------------------------------------------\n// Modelling \n//------------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdEllipsoid(const in  vec3 p, const in vec3 r) {\n  return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat fakeEllipsoid( vec3 p, vec3 s ) {\n\tvec3 lp = p / s;\n\tvec3 ep = normalize(lp) * s;\n\treturn length(p - ep) * sign(length(lp) - 1.0);\n}\n\nfloat cylinder( vec3 p, vec2 rh )\n{\n\tvec2 cp = vec2( length(p.xz), p.y );\n\treturn length( max(abs(cp) - rh, 0.0) );\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 opUnionRound(const in vec2 a, const in vec2 b, const in float r)\n{\n    vec2 res = vec2(smin(a.x,b.x,r),(a.x<b.x) ? a.y : b.y);\n    return res;\n}\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\n\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n\n// http://mercury.sexy/hg_sdf/\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\n#define PI 3.1415926\n#define DEG2RAD ((PI * 2.0) / 360.0)\n\n\n// model\n\nvec2 doModel( vec3 p )\n{\n    float c = pMod1(p.z,7.5);\n//    p.x += 2.75*c;\t\t\t\t// fucked because of mirroring\n    pMod1(p.x,5.5);\n\n    vec2 res = vec2(0.0,0.0);\t\t\t// distance,material index\n    //p.z += 0.8;\n    \n    vec3 bodyp = p;\n    vec3 legp = p;\n    float bodyanim = 0.12+(1.0+sin(iTime*8.5))*0.06;\n    bodyp.y += bodyanim;\n\n    float d1 = sdEllipsoid(bodyp,vec3(1.3,1.7,1.3));\t// white egg shape...\n    float d2 = sdPlane(p-vec3(0.0,-2.2,0.0));\t\t// checkered floor distance...\n    \n    float armanim = (1.0+sin(iTime*7.5))*0.5;\n    armanim = smoothstep(0.0,1.0,armanim);\n    \n\tlegp = vec3( abs(legp.x), legp.y, legp.z );\n    legp.y += 1.6;\n    legp.x -= 0.5;\n    float d5 = cylinder(legp,vec2(0.18,0.6));\n    legp.y += 0.65;\n    legp.z -= 0.3;\n   \tfloat d6 = sdEllipsoid(legp,vec3(0.35,0.35,0.54));\n    \n\td6 = opS(d6,d2);\t\t// subtract floor from boots!\n    d5 = smin(d5,d6,0.1);\n    \n    // p2 = mirrored position...\n\tvec3 p2 = vec3( abs(bodyp.x), bodyp.y, bodyp.z );\n    // box arm (placeholder)\n    float zrot = mix(-10.0,10.0,armanim);\t\t\t// -10 to +10 degrees rot for arms\n    vec3 p3 = rotateZ(p2,zrot*DEG2RAD)-vec3(1.2,0.0,0.0);\n    p3.x -= 0.10;\n    vec3 p4 = rotateZ(p3,90.0*DEG2RAD);\n    float d3 = cylinder(p4,vec2(0.3,0.05));\n    p3.x -= 0.44;\n\tfloat d4 = sdEllipsoid(p3,vec3(0.44,0.38,0.38));\n    p3.x += 0.1;\n    p3.y -= 0.29;\n\tfloat d8 = sdEllipsoid(p3,vec3(0.1,0.2,0.1));\t// thumb\n    \n    res = vec2(d1,2.0);\n    res = opUnionRound(res,vec2(d2,1.0),0.001);\n    res = opUnionRound(res,vec2(d3,3.0),0.01);\t\t// + glove\n    res = opUnionRound(res,vec2(d4,3.0),0.2);\t\t// + glove\n    res = opUnionRound(res,vec2(d8,3.0),0.15);\t\t// + glove\n    res = opUnionRound(res,vec2(d5,3.0),0.02);\t\t// + feet\n    return res;\n}\n\n\nmat2 rotate(float a)\n{\n    float sa = sin(a), ca = cos(a);\n\treturn mat2(ca, -sa, sa, ca);\n}\n\nfloat circle(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\n\n//======================\n// Line functions\n//======================\n\nfloat distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// bend(Y)\nvec2 opBendTest( vec2 p, float angle )\n{\n    mat2 m = rotate( angle * p.x );\n    return   m*p.xy;\n}\n\n// NAND, our only primitive\nfloat csg_nand (float a, float b) {\n    return -max(a,b);\n}\n\n// aka A AND NOT B, NOT(NAND(A,NOT(B)))\nfloat csg_sub (float a, float b) {\n    float o = csg_nand(a, csg_nand(b, b));\n    return csg_nand(o, o);\n}\n// NAND(NOT(A),NOT(B))\nfloat csg_or (float a, float b) {\n    return csg_nand(\n        csg_nand(a,a),\n        csg_nand(b,b));\n}\n\nfloat Eye(vec2 p,vec2 offset)\n{\n    float rad = 0.06;\n    float rad2 = 0.057;\n    float d = circle(p,rad);\n    float d2 = circle(p,rad2);\n    float d3 = circle(p+offset,0.015);\t// pupil\n    \n    // blink\n    float blink = step(sin(iTime * 2.8 + cos(iTime * 2.0) * 2.0), 0.95);\n\td3 = max(d3,1.0-blink);\n    \n    d = csg_sub(d,d2);\n    d = csg_or(d,d3);\n    return d;\n    \n}\n\n\nvec4 FaceTest(vec2 p)\n{\n    vec4 color = vec4(0.0,0.0,0.0,1.0);\n    vec2 p1 = vec2(-0.15,-0.03);\n    vec2 p2 = vec2(0.15,-0.03);\n    float dist = 100.0;\n\n    vec2 offset1 = vec2(0.015,0.02);\n    vec2 offset2 = vec2(-0.015,0.02);\n    float d2 = Eye(p+vec2(-0.08,-0.2),offset1);\n    float d3 = Eye(p+vec2(0.08,-0.2),offset2);\n\n    p = opBendTest(p,DEG2RAD*174.0);\t////sin(iTime));\n    float d1 = distanceToSegment(p1,p2,p);\n\n    dist = min(dist,d2);\n    dist = min(dist,d3);\n    dist = smoothstep(0.0,0.01, dist);\t\t// alias,thickness\n    color.xyz += vec3(1.0-dist);\n\n    // mouth\n    dist = smoothstep(0.004,0.015, d1);\t\t// alias,thickness\n    color.xyz += vec3(1.0-dist);\n\tcolor = (1.0-color)*0.3;\n    color.w = 0.5;\n    return color;\n    \n}\n\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal.\n//------------------------------------------------------------------------\n// c = colour index (added by del for some materials)\n// c.a == specular val fudged in...\nvec4 doMaterial( in vec3 pos, in vec3 nor,float c )\n{\n    if (c<=1.0)\n    {\n        // checker floor\n        float f = mod( floor(2.0*pos.z) + floor(2.0*pos.x), 2.0);\n        vec4 col = 0.1 + 0.3*f*vec4(0.2,1.0,0.2,0.0);\n\t    return col;\n    }\n    else if (c<=2.0)\n    {\n        vec3 bodyp = pos;\n        float c = pMod1(bodyp.z,7.5);\n        //bodyp.x += 2.75*c;\t// fucked because of mirroring\n        pMod1(bodyp.x,5.5);\n\n        float bodyanim = 0.12+(1.0+sin(iTime*8.5))*0.06;\n        bodyp.y += bodyanim;\n        \n        vec3 q = normalize( bodyp );\n        vec2 uv = vec2( atan(q.z,q.x), acos(-q.y ) )*0.25;\n        \n        uv.y -= 0.3;\n        uv.x -= 0.38;\n        return FaceTest(uv);\n    }\n    else if (c<=3.0)\n    {\n\t\treturn vec4(0.3, 0.0, 0.0,3.0);\t// feet/gloves\n    }\n\n\treturn vec4(0.0, 0.0, 0.0,2.0);\t// eyes\n    \n//    return vec3(0.2,0.07,0.01);\n    \n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec4 mat )\n{\n    \n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(0.7,0.875,0.89));\t\t// dir\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0;\n    if( dif>0.01 )\n        sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n\tfloat spec = pow(dif, 160.0) *mat.a;\n    \n    \n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mat.xyz*lin;\n    col+=spec;\n\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.002*dis*dis);\n\n    return col;\n}\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 50.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\t//float res = -1.0;\n    vec2 res = vec2(-1.0,0.0);\n    float c = 0.0;\n    \n    for( int i=0; i<180; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n        vec2 res2 = doModel( ro+rd*t );\n\t    h = res2.x;\n        c = res2.y;\n        \n        t += h;\n    }\n\n    if( t<maxd )\n    {\n        res.x = t;\n        res.y = c;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t).x;\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n  \tvec3 col = mix( vec3(0.2, 0.2, 0.5), vec3(0.5, 0.7, 1.0), fragCoord.y / iResolution.y );\n\n\t// raymarch\n    vec2 res = calcIntersection( ro, rd ); \n    float t = res.x;\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec4 mat = doMaterial( pos, nor, res.y );\n\n        col = doLighting( pos, nor, rd, t, mat );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljBzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 194, 275, 275, 580], [588, 753, 778, 778, 793], [795, 795, 849, 849, 909], [910, 910, 941, 941, 1032], [1035, 1035, 1074, 1074, 1173], [1175, 1175, 1210, 1210, 1292], [1294, 1294, 1335, 1335, 1428], [1430, 1430, 1501, 1501, 1579], [1580, 1580, 1613, 1613, 1639], [1642, 1642, 1673, 1673, 1779], [1780, 1780, 1811, 1811, 1918], [1919, 1919, 1950, 1950, 2056], [2058, 2233, 2273, 2273, 2394], [2457, 2467, 2491, 2491, 4197], [4200, 4200, 4222, 4222, 4291], [4293, 4293, 4329, 4329, 4359], [4362, 4431, 4482, 4482, 4596], [4598, 4609, 4649, 4649, 4708], [4710, 4738, 4773, 4773, 4797], [4799, 4839, 4873, 4873, 4945], [4946, 4969, 5002, 5002, 5072], [5074, 5074, 5105, 5105, 5446], [5449, 5449, 5472, 5472, 6190], [6193, 6576, 6629, 6629, 7447], [7449, 7660, 7744, 7744, 8416], [8418, 8418, 8467, 8467, 9040], [9042, 9042, 9074, 9074, 9494], [9496, 9496, 9544, 9544, 9972], [9974, 9974, 10038, 10038, 10216], [10218, 10218, 10275, 10275, 11570]], "test": "untested"}
{"id": "lljcWK", "name": "Squids", "author": "squid", "description": ".", "tags": ["3d"], "likes": 2, "viewed": 466, "published": "Public API", "date": "1513989935", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 hash22(vec2 p)\n{\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\n#define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvec4 hash44(vec4 p)\n{\n\tvec4 p4 = fract(p * HASHSCALE4);\n    p4 += dot(p4.wzxy, p4+19.19);\n    return fract(vec4(p4.x * p4.y, p4.x*p4.z, p4.y*p4.w, p4.x*p4.w));\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) {\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat tntl(vec3 q, vec4 h) {\n    q.y += .8;\n    const float an = 6.28 / 8.;\n    const mat2 inc = mat2( cos(an),sin(an),-sin(an),cos(an));\n    \n\tfloat fa = (atan(q.z,q.x)+an*0.52)/an;\n    float ia = floor( fa );\n    \n    float sym = an*ia;\n    vec2 r = mat2(cos(sym),-sin(sym),\n                  sin(sym), cos(sym))*q.xz;\n        \n    if( fract(fa)>0.0 ) r = r*inc; // rotate one backwards\n\n    float d = 2.0 + length(q);\n    for( int i=0; i<2; i++ )\n    {        \n        vec2 p = (r - vec2(0.5,0.0));\n\t\tvec4 hh = hash43(vec3(h.xy, ia));\n        d = sdCapsule(vec3(p.x, q.y, p.y), \n                      vec3(0.),\n                      vec3(sin(q.y*4.+iTime*0.5+hh.x*30.)*0.2+1., \n                           -2.8,\n                           cos(q.y*.5)*0.1), \n                      .12);\n        \n        r = inc*r;\n\t}\n    return d;\n}\n\nmat2 rot2(float t) { return mat2(cos(t), -sin(t), sin(t), cos(t)); }\n\nfloat map(vec3 pos) {\n    pos.y -= 4.;\n    vec4 h = hash43(floor(pos/16.));\n    pos = mod(pos, 16.) - 8.;\n    h.xyz = h.xyz*2.-1.;\n    pos += (h.xyz)*2.;\n    pos.xy *= rot2(h.x);\n    pos.yz *= rot2(h.y);\n    pos.xz *= rot2(h.z);\n    pos.y += sin(iTime*.7+h.w*30.)*0.1;\n    float mantle =\n        max(sdEllipsoid(pos, vec3(1., 2., 1.)), \n               -sdEllipsoid(pos-vec3(0.0, -2.25, 0.0), vec3(1., 2., 1.)));\n    mantle = smin(mantle,\n                 sdEllipsoid(pos-vec3(0.0, 2.2, 0.0), \n                             vec3(.36, .8, .45+abs(sin(pos.y))*.4)), \n                  .1);\n    vec3 ep = pos;\n    ep.z = abs(ep.z);\n    ep-=vec3(.5, -.45, 0.5);\n    float eyes = length(ep)-0.4;\n    mantle = smin(mantle, eyes,.1);\n    return min(mantle, tntl(pos, h)*0.7);\n}\n\nvec3 norm(vec3 pos) {\n\tvec2 e = vec2(0.01, 0.0);\n    return normalize(vec3(\n        map(pos+e.xyy)-map(pos-e.xyy),\n        map(pos+e.yxy)-map(pos-e.yxy),\n        map(pos+e.yyx)-map(pos-e.yyx)));\n}\n\nfloat intersect(vec3 ro, vec3 rd) {\n    float t = 0.;\n\n    for(int i = 0; i < 128; ++i) {\n        float h = map(ro+rd*t);\n        if(h < 0.001 || t>100.) break;\n        t += h;\n    }\n    return t;\n}\n\nconst vec3 lig = normalize(vec3(0.2, .8, 0.));\n\nconst vec3 lc = vec3(0.5, 0.6, 0.65);\n\nvec3 shade(float t, vec3 p, vec3 rd) {\n    vec3 n = norm(p);\n    float sha = intersect(p+0.05*n, lig) < 10. ? 0. : 1.;\n    vec3 matCol = vec3(0.2, 0.1, 0.15);\n    vec3 col = matCol*lc*clamp(dot(n, lig), 0.0, 1.0)*sha;\n    col += matCol*(1.-lc)*(n.y*0.5+0.5)*0.1;\n    col += matCol*pow(clamp(dot(n, normalize(rd+lig)), 0., 1.),2.);\n\treturn col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    vec2 a = (iMouse.xy/iResolution.xy)*6.2-3.1+vec2(3.1,0.);\n    vec3 LA = vec3(sin(iTime*0.1)*3., -0.6+cos(iTime*0.2)*0.2, iTime*0.2),\n        ro = LA + vec3(cos(a.x), sin(a.y), sin(a.x))*6.,\n        c = vec3(0.0,0.01,0.0),sp;\n    \n    vec3 f = normalize(LA-ro),\n        r = normalize(vec3(f.z, 0., -f.x)),\n        u = cross(f, r),\n        rd = normalize(f + uv.x*r + uv.y*u);\n    \n    float t = intersect(ro, rd);\n    vec3 col = vec3(0.0, 0.0, rd.y*0.1+0.1);\n    \n    \n    if(t < 100.) {\n        vec3 p = ro + rd*t;\n        col += shade(t,p,rd) * 20./t;\n    }\n    \n    float v = pow(.95-length(uv), 0.8);\n\tfragColor = vec4(pow(col * v, vec3(0.4545)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljcWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 176], [238, 238, 259, 259, 386], [387, 387, 408, 408, 548], [550, 550, 581, 581, 668], [670, 670, 713, 713, 773], [774, 774, 815, 815, 908], [909, 909, 961, 961, 1088], [1090, 1090, 1118, 1118, 1924], [1926, 1926, 1946, 1946, 1994], [1996, 1996, 2017, 2017, 2764], [2766, 2766, 2787, 2787, 2962], [2964, 2964, 2999, 2999, 3162], [3251, 3251, 3289, 3289, 3596], [3597, 3597, 3654, 3654, 4374]], "test": "untested"}
{"id": "lllBDS", "name": "CRT zoom v0.1", "author": "amason", "description": "Learning how to code shaders.\nFirst part is to draw RGB phosors and allow scaling and translation.\n", "tags": ["tv", "crt"], "likes": 0, "viewed": 499, "published": "Public API", "date": "1513257373", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float zoom = 0.2 * (0.5 + sin(iTime) / 10.0);\n    vec2 scaledRes = fragCoord.xy * zoom;\n    \n    float translateSpeed = sin(iTime) * 30.0;\n    float xPos = fragCoord.x + translateSpeed; \n    float yPos = fragCoord.y - translateSpeed;\n    \n    int x = int(mod(floor(xPos * zoom),3.0));\n    \n    // https://rechneronline.de/function-graphs/#a0=2&a1=1-%20max(0#abs(cos(x*pi))%20*%2010.0-9)&a2=&a3=&a4=1&a5=4&a6=8&a7=1&a8=1&a9=1&b0=500&b1=500&b2=-5&b3=5&b4=-5&b5=5&b6=10&b7=10&b8=5&b9=5&c0=3&c1=0&c2=1&c3=1&c4=1&c5=1&c6=1&c7=0&c8=0&c9=0&d0=1&d1=20&d2=20&d3=0&d4=&d5=&d6=&d7=&d8=&d9=&e0=&e1=&e2=&e3=&e4=14&e5=14&e6=13&e7=12&e8=0&e9=0&f0=0&f1=1&f2=1&f3=0&f4=0&f5=&f6=&f7=&f8=&f9=&g0=&g1=1&g2=1&g3=0&g4=0&g5=0&g6=Y&g7=ffffff&g8=a0b0c0&g9=6080a0&h0=1&h1=&h2=&h3=&h4=0&z\n    float xIntensity = 1.0 - max(0.0, abs(cos(xPos * PI * zoom)) * 20.0 - 19.0);\n    float yIntensity = min(1.0, max(0.0, abs(sin(yPos * PI * zoom * 0.5 )) * 14.0 - 1.0));\n    \n    vec4 col;\n    \n    if (x == 0) {\n        col = vec4(0.0, 0.0, 1.0,1.0) * xIntensity;\n    } else if (x == 1) {\n\t\tcol = vec4(0.0, 1.0, 0.0,1.0) * xIntensity;\n    } else if (x == 2) {\n        col = vec4(1.0, 0.0, 0.0,1.0) * xIntensity;\n    }\n    \n    col *= yIntensity;\n   \n    fragColor = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllBDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 103, 103, 1391]], "test": "untested"}
{"id": "lllBWl", "name": "Circle & Pillar", "author": "FEI", "description": "圆形内部的柱子移动效果", "tags": ["circle", "pillar"], "likes": 0, "viewed": 57, "published": "Public", "date": "1514020322", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float r = iResolution.y / 2.5;\n    vec2 center = iResolution.xy / 2.0;\n    float dis = distance(fragCoord.xy , center);\n    float t = clamp(r - dis, 0.0, 1.0);\n    \n    \n    float c = fragCoord.x / 8.0;\n    \n    c = cos(c - iTime) * 0.5 + 0.5;\n    // c = step(0.5, c);\n    \n    vec4 background = vec4( 0.1, 0.2, 0.3, 1.0);\n    vec4 color = vec4(c, c, c, min(t, c)); // min(t, c)\n    \n\tfragColor = mix(background, color, color.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllBWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 535]], "test": "untested"}
{"id": "lllBz2", "name": "SlimeBorders", "author": "Del", "description": "SinMagic++", "tags": ["slime"], "likes": 3, "viewed": 98, "published": "Public", "date": "1512579255", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// um, some kind of mystical hole...?\n\n\nfloat glint(vec2 p)\n{\n    vec2 uv = p;\n    float speed = 0.68;\n    float linewidth = 1.38;\n    float grad = 3.0;\n    vec2 linepos = uv;\n    linepos.x = linepos.x - mod(iTime*speed,4.0)+2.0;\n    float y = linepos.x*grad;\n\tfloat s = smoothstep( y-linewidth, y, linepos.y) - smoothstep( y, y+linewidth, linepos.y); \n    return s;\n}\n\nfloat _glint(vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float speed = iTime*0.2;\n \tfloat d = 1.0+p.x*0.25;\n    vec2 cst = vec2( cos(d+speed), sin(d+speed) );\n    float zoom = 1.0+(0.5*sin(iTime*0.675));\n    mat2 rot = zoom * mat2(cst.x,-cst.y,cst.y,cst.x);\n    float s = glint(p*rot*0.44);\n    return s;\n}\n\n\nvoid mainImage(out vec4 k, vec2 p)\n{\n    const vec4 col1 = vec4(0.0,.1,.1,1.0);\n    const vec4 col2 = vec4(0.5,0.9,0.3,1.0);\n    vec2 uv = p.xy / iResolution.xy;\n    float gl = _glint(p)*0.5;\n    \n    float s = sin(iTime*0.1);\n    float s2 = 0.5+sin(iTime*1.8);\n    vec2 d = uv*(3.0+s*.3);\t\t\t\t\t\t// mod 4.0 for irregularity...\n    \n    d.x += iTime*0.4-sin(d.x+d.y + iTime*0.3)*0.5;\n    d.y += iTime*0.15+sin(d.x + iTime*0.3)*0.5;\t//-(s*0.5);\n    float v1=length(0.5-fract(d.xy))+0.55;\t\t\t\t// 0.9 =more gooey bits, 1.2 = less gooey bits\n\n    d = (uv);\t\t\t// zoom\n    float v2=length(0.5-fract(d.xx))-0.175;\t\t// border\n    v1 *= 1.0-v2*v1;\n    v1 = v1*v1*v1;\n    v1 *= 2.9+s2*0.2;\n    k = mix(col2,col1,v1)*(3.2+(s2*0.2));\n    k *= 1.0-(v2);\n    \n    if (k.g<=0.4)\n    {\n        float m = 1.0-clamp(k.g,0.0,0.5);\n\t\tfloat f = mod( floor(12.0*uv.x) + floor(12.0*uv.y), 2.0);\n        float col = 0.3 + 0.2*f*1.0;\n        k.x = k.y = k.z = col*m;\n\t\tk.rb *= 1.2;\n    }\n    else\n    {\n\t\tfloat f = mod( floor(12.0*uv.x) + floor(12.0*uv.y), 2.0);\n        vec4 _col = 0.2*f*vec4(0.175);\n        k+=_col;\n    }\n    // glint\n    k *=vec4(1.0+gl);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllBz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 40, 61, 61, 368], [370, 370, 401, 401, 722], [725, 725, 761, 761, 1858]], "test": "untested"}
{"id": "lllfDB", "name": "Cube Tunnel Tron", "author": "balkhan", "description": "really ugly code, too lazy to despaghettify it.", "tags": ["raymarching", "tunnel"], "likes": 5, "viewed": 145, "published": "Public", "date": "1513217495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n** License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n** Created by bal-khan\n*/\n\n// hlsl lazy translation\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\nfloat   t;\n\n#define I_MAX       100\n#define E           0.01\n\nfloat4  march(float3 pos, float3 dir);\nfloat3  camera(float2 uv);\nfloat3  calcNormal(in float3 pos, float e, float3 dir);\nfloat3  color_func(float3 pos, float3 dir);\nvoid    rotate(inout float2 v, float angle);\n\nfloat   neo, h, accum, trinity, rabbit;\nfloat   col_id;\n\nfloat4  render(float3 dir, float3 pos)\n{\n    col_id = 0.;\n    neo = 0.;h = 0.;accum = 0.;trinity = 0.;rabbit = 0.;\n    t = iTime;\n\n    float3  col = float3(0., 0., 0.);\n\trotate(dir.zx, .001251+t*.1);\n    float4  inter = (march(pos-float3(0.,0.,t*.5), dir));\n\n    float3  base = float3(.8, .0, 1.);\n    float4  c_out =  float4(col,1.0)*1.;\n    c_out.xyz += neo * float3(.7, .6, .3);\n    if (col_id == 2.)\n    {\n        c_out.xyz += (1.-inter.w*.051)*float3(.3,.4,.7);\n    }\n    if (col_id == 1.)\n    {\n        c_out.xyz += (1.-inter.w*.051)*float3(.38,.75,.5);\n        c_out.xyz += rabbit*.00001*float3(1., .4, .5);\n    }\n    c_out.xyz += (inter.x*.0051)*float3(.5,.3,.25)*h;\n\tc_out.xyz += .0051*trinity*float3(.2, .150, .950);\n    c_out.xyz *= accum;\n\tc_out.w = 1.;\n    return  c_out;\n}\n\nvoid mainImage(out float4 fragColor, in float2 uv)\n{\n    vec2\tu = (uv.xy - iResolution.xy*.5) / iResolution.y;\n    \n    vec3\tpos = vec3(.0,.0,.0);\n    vec3\tdir = camera(u*1.);\n    fragColor = render(dir, pos);\n}\n\nvoid rotate(inout float2 v, float angle)\n{\n    v = float2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nfloat udBox( float3 p, float3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat   mylength(float p)\n{\n    float   ret = 0.;\n    p = p*p*p*p;\n    ret = p;\n    ret = pow(ret, 1./3.);\n    return (ret);\n}\n\nfloat   mylength(float2 p)\n{\n    float   ret = 0.;\n    p = p*p*p*p;\n    ret = p.x+p.y;\n    ret = pow(ret, 1./4.);\n    return (ret);\n}\n\n\nfloat   mylength(float3 p)\n{\n    float   ret = 0.;\n    p = p*p*p*p;\n    ret = p.x+p.y+p.z;\n    ret = pow(ret, 1./4.);\n    return (ret);\n}\n\nfloat sdCappedCylinder( float3 p, float2 h )\n{\n  float2 d = abs(float2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat2  rot(float2 p, float2 ang)\n{\n    float   c = cos(ang.x);\n    float   s = sin(ang.y);\n    mat2    m = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nfloat   plane_de(float3 p)\n{\n    float   ret = dot(p, float3(1.0, 1.0, -1.) ) + 1. ;\n    return ret;\n}\n\nfloat sdTorus( float3 p, float2 t )\n{\n    float2 q = float2(length(p.zy)-t.x,p.x);\n\n    return length(q)-t.y;\n}\n\nfloat   scene(float3 p)\n{\n    float   minf = 1e5;\n    float   mind = 1e5;\n    float   ming = 1e5;\n    float   minr = 1e5;\n    float   mins = 1e5;\n    float   minc = 1e5;\n    float3  id = float3(0.);\n    minr = length(p.xy)-1.;\n    mins = length(p-float3(.0,.0,0.-t*20.));\n    minr = max(minr, -(length(p.xy)-.99) );\n    float   outer = length(p.xy)-.25;\n    float   s = p.z;\n    id.z  = floor(p.z*3.);\n    p.z = fract(p.z*3.)-.5;\n    p.xy -= float2(cos(id.z*0.+mod(s*1000., 10000.)/(.1+mins*mins)+iTime*1.),sin(id.z*0.+mod(s*1000., 10000.)/(.1+mins*mins)+iTime*1.))*.02512;\n    id.xy = floor(p.xy * 10.);\n    p.xy  = fract(p.xy*(7.5+mod(id.z, 2.5) ))-.5;\n\n\tminf = max(abs(p.x), max(abs(p.y), abs(p.z)))-.0125-.17*abs(sin(s*.125+.0*id.z));\n\tminc = min(minc, (length(fract(p.xy*(3.+ 7.*mod(-id.z*10., 70.)/70. ) )-.5)-.2501) );\n\tminc = min(minc, (length(fract(p.yz*(3.+ 7.*mod(+id.x*10., 70.)/70. ) )-.5)-.2501) );\n\tminc = min(minc, (length(fract(p.zx*(3.+ 7.*mod(+id.y*10., 70.)/70. ) )-.5)-.2501) );\n\ttrinity = .51/(.0+minc*minc);\n\tminc = max(minc, - minf);\n\trabbit += .0051/(.0000001+minc*minc);\n\tming = max(minf, -outer);\n\tneo += .02/(2.1+ming*ming);\n\th += 5.1/(mins*mins);\n    mind = min(minr, ming);\n    mind = min(mind, mins);\n    col_id = (mind == minf) ? 2. : col_id;\n    col_id = (mind == minr) ? 1. : col_id;\n    col_id = (mind == mins) ? 0. : col_id;\n    return mind;\n}\n\nfloat4  march(float3 pos, float3 dir)\n{\n    float2  dist = float2(0.0, 0.0);\n    float3  p = float3(0.0, 0.0, 0.0);\n    float4  step = float4(0.0, 0.0, 0.0, 0.0);\n    float3  dirr;\n    float   dynamiceps = E;\n    for (int i = 1; i < I_MAX; ++i)\n    {\n        dirr = dir;\n        rotate(dirr.xy, (.001*floor(t*2.1-dist.y*300.))) ;\n        p = pos + dirr * dist.y;\n        dynamiceps = -dist.x+(dist.y)/(50.);\n        dist.x = scene(p);\n        dist.y += dist.x*.2;\n        accum += .01;\n        // log trick by aiekick \n        if (log((dist.y*dist.y/dist.x)/1e5)>0. || (dist.x) < dynamiceps)\n        {\n            step.y = 1.;\n            break;\n        }\n        step.x++;\n    }\n    step.w = dist.y;\n    return (step);\n}\n\n// Utilities\n\nfloat3 calcNormal( in float3 pos, float e, float3 dir)\n{\n    e /= 100.;\n    float3 eps = float3(e,0.0,0.0);\n\n    return normalize(float3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nfloat3  camera(float2 uv)\n{\n    float       fov = 1.;\n    float3      forw  = float3(0.0, 0.0, -1.0);\n    float3      right = float3(1.0, 0.0, 0.0);\n    float3      up    = float3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllfDB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[117, 534, 574, 574, 1320], [1322, 1322, 1374, 1374, 1533], [1535, 1535, 1577, 1577, 1657], [1659, 1659, 1694, 1694, 1732], [1734, 1734, 1761, 1761, 1860], [1862, 1862, 1890, 1890, 1995], [1998, 1998, 2026, 2026, 2135], [2137, 2137, 2183, 2183, 2286], [2288, 2288, 2323, 2323, 2441], [2443, 2443, 2471, 2471, 2545], [2547, 2547, 2584, 2584, 2658], [2660, 2660, 2685, 2685, 4039], [4041, 4041, 4080, 4080, 4762], [4764, 4778, 4834, 4834, 5118], [5120, 5120, 5147, 5147, 5385]], "test": "untested"}
{"id": "lllfWs", "name": "Torus_Thingy_6", "author": "balkhan", "description": "I like circles. \nusing track from Pierre Bondoerffer : https://soundcloud.com/pbondoer/inspired-by-circles", "tags": ["raymarch", "interactive", "torus"], "likes": 6, "viewed": 270, "published": "Public", "date": "1514653170", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tsdTorus( vec3 p, vec2 t, float phase );\nfloat\tmylength(vec2 p);\nfloat\tnrand( vec2 n );\n\nfloat \tt;\t\t\t// time\nvec3\th; \t\t\t// light amount\nfloat\tmind;\n\n\n#define I_MAX\t\t100.\n#define E\t\t\t0.0001\n#define FAR\t\t\t30.\n\n/*\n* Leon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\n#define PI 3.14159\n#define TAU PI*2.\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// -------------blackbody----------------- //\n\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(0., 0., 10.);\n\n    h*=0.;\n    vec2\tinter = (march(pos, dir));\n    if (inter.y <= FAR)\n        col.xyz = 1.*vec3(.75-max(inter.x*.025, 1.-inter.y*.051))*h;\n    else\n        col *= 0.;\n    col += h;\n    c_out =  vec4(col,1.0);\n}\n\nfloat\tscene(vec3 p)\n{\n    mind = 1e5;\n\n\trotate(p.xz, 1.57-.515*iTime);\n    rotate(p.yz, sin(.5*iTime)*.125);\n    vec3 op = p;\n    float\tvar = (atan(p.x, p.z)+ PI)/(TAU);\n    float\tvir = 0.;\n    p.xz = modA(p.xz, 64.);\n    p.xz -= vec2(8., .0);\n    vir = (atan(p.x, p.y)+ PI)/(TAU);\n    float\tvir_sound = texture(iChannel0, vec2(floor(vir*64.)/64., .0) ).x;\n    float\tvar_sound = texture(iChannel0, vec2(floor(var*64.)/64., .0) ).x;\n    vec2 q = vec2(length(p.xy)-4.,p.z);\n    q.x += -.51 * (vir_sound+var_sound);\n    // this displace is cool too\n    //q.x += min(var_sound, vir_sound)*.5;\n    mind = mylength(q)-.75;\n\n    h += 1.*abs(vec3(\n        \t\t  sin(+floor( ( (vir_sound +var_sound) )*6.28 )+1.*(3.14*floor(vir*64.)/32.)+1.*(3.14*floor(var*64.)/32.)+0.00)\n                  ,\n                  sin(+floor( ( (vir_sound +var_sound) )*6.28 )+1.*(3.14*floor(vir*64.)/32.)+1.*(3.14*floor(var*64.)/32.)+1.04)\n                  ,\n                  sin(+floor( ( (vir_sound +var_sound) )*6.28 )+1.*(3.14*floor(vir*64.)/32.)+1.*(3.14*floor(var*64.)/32.)+2.08) ))\n        *.021/(mind*mind+1.);\n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\tfloat dinamyceps = E;\n\tfor (float i = -1.; i < I_MAX; ++i)\n\t{\n\t\tp = pos + dir * dist.y;\n\t\tdist.x = scene(p);\n\t\tdist.y += dist.x*.5;\n        dinamyceps = -dist.x+(dist.y)/(2500.);\n        // log trick from aiekick\n\t    if (log(dist.y*dist.y/dist.x/1e5)>0. || dist.x < dinamyceps || dist.y > FAR)\n        {\n            break;\n        }\n\t    s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n    \n    p = p*p*p*p;\n    p = p*p;\n    ret = (p.x+p.y);\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,\n           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,\n           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));\n}", "image_inputs": [{"id": "4sjXRD", "previewfilepath": "https://soundcloud.com/pbondoer/inspired-by-circles", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/pbondoer/inspired-by-circles", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllfWs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[472, 581, 614, 614, 745], [859, 1081, 1109, 1109, 1434], [1436, 1484, 1527, 1527, 1914], [1916, 1916, 1937, 1937, 3027], [3029, 3029, 3061, 3061, 3545], [3547, 3547, 3571, 3571, 3689], [3691, 3705, 3745, 3745, 3820], [3822, 3822, 3850, 3850, 3958], [3960, 3960, 3982, 3982, 4188], [4190, 4190, 4240, 4240, 4503]], "test": "untested"}
{"id": "lllfzX", "name": "Mobius Ball", "author": "shau", "description": "Rework of an old shader demonstrating mobius projection from a sphere", "tags": ["3d", "mobius"], "likes": 23, "viewed": 313, "published": "Public", "date": "1512833264", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by SHAU - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define T iTime * 0.5\n#define EPS 0.005\n#define FAR 100.0 \n#define PI 3.14159265359\n#define FLOOR 1.0\n#define SPHERE 2.0\n\nvec3 lp = vec3(4.0, 5.0, 2.0);\nvec4 sphere = vec4(0.0, 0.0, 0.0, 1.5);\nvec3 fo = vec3(0.0, -2.0, 0.0);\nvec3 fn = vec3(0.0, 1.0, 0.0);\nvec3 pp = vec3(0.0, 1.5 - EPS, 0.0); //projection point just under topmost pole of sphere\n\nfloat rotation = 0.0;\nfloat displayScene = 0.0;\nfloat displayProjection = 0.0;\nfloat rotateProjection = 0.0;\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//IQ Sphere functions\n\nvec2 sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(0.0);\n    h = sqrt(h);\n    float tN = -b - h;\n    float tF = -b + h;\n    return vec2(tN, tF);\n}\n\nfloat planeIntersection(vec3 ro, vec3 rd, vec3 n, vec3 o) {\n    return dot(o - ro, n) / dot(rd, n);\n}\n\nvec3 sphNormal(in vec3 pos, in vec4 sph) {\n    return normalize(pos - sph.xyz);\n}\n\nfloat sphSoftShadow(vec3 ro, vec3 rd, vec4 sph, float k) {\n    vec3 oc = ro - sph.xyz;\n    float r = sph.w * sph.w;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - r;\n    float h = b * b - c;\n    float d = -sph.w + sqrt(max(0.0, r - h));\n    float t = -b - sqrt(max(0.0, h));\n    return (t < 0.0) ? 1.0 : smoothstep(0.0, 1.0, k * d / t);\n}\n\nstruct Scene {\n    float t;\n    vec3 n;\n    float id;\n    float bft;\n};\n\nScene drawScene(vec3 ro, vec3 rd) {\n    \n    float mint = FAR;\n    float bft = 0.0;\n    vec3 minn = vec3(0.0);\n    float id = 0.0;\n    \n    float ft = planeIntersection(ro, rd, fn, fo);\n    if (ft > 0.0) {\n        mint = ft;\n        minn = fn;\n        id = FLOOR;\n    }\n    \n    vec2 st = sphIntersect(ro, rd, sphere);\n    if (st.x > 0.0 && st.x < mint) {\n        \n        vec3 rp = ro + rd * st.x;\n   \n        mint = st.x;\n        bft = st.y;\n        minn = sphNormal(rp, sphere);\n        id = SPHERE;\n    }\n    \n    return Scene(mint, minn, id, bft);\n}\n\nvec3 gridColour(vec3 rp, vec3 col) {\n \n    vec3 pc = vec3(0.0);\n    \n    vec2 grid = fract(rp.xz * 2.0);\n    pc += col * (step(grid.x, 0.1) + step(0.9, grid.x));\n    pc += col * (step(grid.y, 0.1) + step(0.9, grid.y));    \n    pc *= step(abs(rp.x), 2.55) * step(abs(rp.z), 2.55);\n\n    return pc;\n}\n\nvec3 sphereProjectionColour(vec3 rp, vec3 col) {\n    \n    vec3 pc = vec3(0.0);\n\n    rp.xy *= rot(rotation * rotateProjection);\n        \n    vec3 pd = normalize(rp - pp);\n    float ft = planeIntersection(pp, pd, fn, fo);\n    if (ft > 0.0) {\n        vec3 prp = pp + pd * ft; \n        pc += gridColour(prp, col);\n    }\n\n    return pc;\n}\n\nvec3 floorProjectionColour(vec3 rp, vec3 col) {\n \n    vec3 pc = vec3(0.0);\n    \n    vec3 pd = normalize(pp - rp);\n    vec2 st = sphIntersect(rp, pd, sphere);\n    if (st.x > 0.0) {\n        vec3 srp = rp + pd * st.x;\n        pc += sphereProjectionColour(srp, col);            \n    }\n    \n    return pc * 0.4;\n}\n\nvec3 colourScene(vec3 ro, vec3 rd, Scene scene) {\n \n    vec3 pc = vec3(0.0);\n    \n    vec3 rp = ro + rd * scene.t;\n    vec3 ld = normalize(lp - rp);\n    float lt = length(lp - rp);\n    float diff = max(dot(ld, scene.n), 0.03);\n    float spec = pow(max(dot(reflect(-ld, scene.n), -rd), 0.0), 16.0);\n    float atten = 1.0 / (1.0 + lt * lt * 0.008);\n    float sh = 1.0; \n    \n    //scene colour\n    vec3 sc = vec3(0.05, 0.0, 0.3) * 0.1 * clamp(scene.n.y * -1.0, 0.0, 1.0);\n    sc += vec3(0.0, 0.5, 0.0) * diff; \n    sc += vec3(1.0) * spec;\n    sc *= atten;\n    \n    //projection colour\n    vec3 prc = vec3(0.0);\n    \n    if (scene.id == FLOOR) {\n        \n        sh = sphSoftShadow(rp - (rd * EPS), ld, sphere, 2.0);\n        \n        prc += floorProjectionColour(rp, vec3(0.0, 1.0, 0.0));\n\n    } else if (scene.id == SPHERE) {\n                        \n        prc += sphereProjectionColour(rp, vec3(0.0, 1.0, 0.0));\n        //back face\n        vec3 bfrp = ro + rd * scene.bft;\n        prc += sphereProjectionColour(bfrp, vec3(0.0, 1.0, 0.0)) * (1.0 - displayScene) * 0.8;\n\n        //see through to floor\n        vec3 fpc = vec3(0.0);\n        float ft = planeIntersection(ro, rd, fn, fo);\n        if (ft > 0.0) {\n            vec3 frp = ro + rd * ft;\n            fpc = floorProjectionColour(frp, vec3(0.0, 1.0, 0.0)) * (1.0 - displayScene);\n        }  \n        //TODO: this is a bit crap\n        prc += fpc;\n    }\n    \n    sc *= sh;\n    pc += sc * displayScene;\n    \n    prc *= atten;\n    pc += prc * displayProjection;\n    \n    return pc;\n}\n\nvoid setupCamera(vec2 fragCoord, inout vec3 ro, inout vec3 rd) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    ro = lookAt + vec3(3.0, 2.0, -5.0);\n    \n    ro.xz *= rot(T);\n\n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid setupScene() {\n    \n    float timeline = mod(T, 20.0);\n    \n    if (timeline < 5.0) {\n        displayScene = 1.0;\n        displayProjection = 0.0;\n        rotateProjection = 0.0;\n    } else if (timeline < 10.0) {\n        displayScene = 1.0;\n        displayProjection += clamp((timeline - 5.0) * 0.5, 0.0, 1.0);\n        rotateProjection = 0.0;\n    } else if (timeline < 15.0) {\n        displayScene = clamp(1.0 - (timeline - 10.0) * 0.5, 0.0, 1.0);\n        displayProjection = 1.0;\n        rotateProjection = 1.0;\n        rotation = timeline - 10.0;\n    } else if (timeline < 20.0) {\n        displayScene = clamp((timeline - 15.0) * 0.5, 0.0, 1.0);\n        displayProjection = clamp(1.0 - (timeline - 15.0) * 0.5, 0.0, 1.0);\n        rotateProjection = 1.0;\n        rotation = timeline - 10.0;        \n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n        \n    vec3 pc = vec3(0.0);\n    \n    setupScene();\n    \n    vec3 ro, rd;\n    setupCamera(fragCoord, ro, rd);\n    \n    Scene scene = drawScene(ro, rd);\n    if (scene.t > 0.0 && scene.t < FAR) {\n        pc = colourScene(ro, rd, scene);        \n    }\n\t\n    fragColor = vec4(sqrt(clamp(pc, 0.0, 1.0)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllfzX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[463, 627, 646, 646, 692], [694, 717, 764, 764, 1012], [1014, 1014, 1073, 1073, 1115], [1117, 1117, 1159, 1159, 1198], [1200, 1200, 1258, 1258, 1546], [1621, 1621, 1656, 1656, 2175], [2177, 2177, 2213, 2213, 2474], [2476, 2476, 2524, 2524, 2809], [2811, 2811, 2858, 2858, 3119], [3121, 3121, 3170, 3170, 4657], [4659, 4659, 4723, 4723, 5140], [5142, 5142, 5161, 5161, 5954], [5956, 5956, 6011, 6011, 6323]], "test": "untested"}
{"id": "llsBDS", "name": "Spinning Tunnel Stuff", "author": "balkhan", "description": "another tunnel to add to my collection !!", "tags": ["raymarching", "tunnel"], "likes": 11, "viewed": 280, "published": "Public", "date": "1513197386", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n** License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n** Created by bal-khan\n*/\n\nfloat   t;\n\n#define I_MAX       50\n#define E           0.001\n#define FAR         30.\n\n\nvec4    march(vec3 pos, vec3 dir);\nvec3    camera(vec2 uv);\nvec3    calcNormal(in vec3 pos, float e, vec3 dir);\nvec2    rot(vec2 p, vec2 ang);\nvoid    rotate(inout vec2 v, float angle);\n\nvec3    id;\nvec3    base;\nvec3    h;\n\nvoid mainImage(out vec4 c_out, in vec2 uv)\n{\n    h *= 0.;\n    t = iTime;\n\n    vec2\tu = (uv.xy - iResolution.xy*.5) / iResolution.y;\n    \n    vec3\tpos = vec3(.0,.0,.0);\n    vec3\tdir = camera(u*3.);\n    \n    vec4    inter = (march(pos, dir));\n    vec3    col = vec3(0, 0, 0);\n\n    base = vec3\n        (\n            abs(sin(id.z+id.x+id.y+0.00) )\n            ,\n            abs(sin(id.z+id.x+id.y+1.04) )\n            ,\n            abs(sin(id.z+id.x+id.y+2.08) )\n        );\n    if (inter.y == 1.)\n        col.xyz = base * ( -1.*inter.w*.05 + 1. -inter.x*.001 )-h;\n\n    c_out =  vec4(col, 1.);\n}    \n\nfloat   mylength(vec3 p)\n{\n    float   ret = 1e5;\n    \n    p = p*p;\n    p = p*p;\n    p = p*p;\n    \n    ret = p.x + p.y + p.z;\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\nfloat   mylength(vec2 p)\n{\n    float   ret = 1e5;\n    \n    p = p*p;\n    p = p*p;\n    p = p*p;\n    \n    ret = p.x + p.y;\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\nfloat   scene(vec3 p)\n{\n    float   mind = 1e5;\n    p.z -= iTime*3.;\n\n    p.y += sin(iTime*-1.+p.z*.5)*.5;\n    p.x += cos(iTime*-1.+p.z*.5)*.5;\n    rotate(p.xy, p.z*.25 + 1.0*sin(p.z*.06125 - iTime*0.5) + .25*iTime);\n\n    vec3    pr = p;\n    \n    pr.xy = fract(p.xy*.5)-.5;\n    id = vec3(floor(p.xy*.5), floor(p.z*5.));\n    p.z += (mod(id.x*1., 2.)-1. == 0. ? 5. : 0. );\n    p.z += (mod(id.y*1., 2.)-1. == 0. ? 5. : 0. );\n    rotate(pr.xy, clamp( +(mod(id.x, 2.)-1. == 0. ? 1. : -1.) + (mod(id.y, 2.)-1. == 0. ? 1. : -1.), -2., 2.) * iTime*2.+(mod(id.x, 2.)-1. == 0. ? -1. : -1.)*p.z*2.5 + iTime*1. );\n    \n    pr.xy = abs(pr.xy)-.05-(sin(p.z*0.5+iTime*2.5)*.15);\n    pr.xy *= clamp(1./length(pr.xy), .0, 2.5);\n    pr.z = (fract(pr.z*5.)-.5);\n    mind = mylength(pr.xy*(.1*pr.z+.5))-.051;\n    \n    return(mind);\n}\n\nvec4    march(vec3 pos, vec3 dir)\n{\n    vec2    dist = vec2(0.0, 0.0);\n    vec3    p = vec3(0.0, 0.0, 0.0);\n    vec4    step = vec4(0.0, 0.0, 0.0, 0.0);\n    vec3    dirr;\n    //rotate(dir.zy, .7);\n\t//rotate(dir.xy, 1.7);\n\t//rotate(dir.xz, 1.7);\n    \n    for (int i = -1; i < I_MAX; ++i)\n    {\n        dirr = dir;\n        rotate(dirr.zx, .025*dist.y );\n        p = pos + dirr * dist.y;\n        dist.x = scene(p)*1.;\n        dist.y += dist.x;\n        vec3    s = p- 1.*vec3(.0,7.0,0.0); // lightpos\n        float   d = length(s.xy)-.1;\n        h -= vec3(.3, .2, .0)*.1/ (d+.01);\t// it brightens the scene but u can see an ugly cylinder\n        \t\t\t\t\t\t\t\t\t// on the top-middle when not hidden by the scene\n        h += (\n            .001/(dist.x*dist.x+0.01) \n            -\n            1./(dist.y*dist.y+40.)\n             )\n        ;\n        if (log(dist.y*dist.y/dist.x/1e5)>0. || dist.x < E || dist.y >= FAR)\n        {\n            if (dist.x < E || log(dist.y*dist.y/dist.x/1e5)>0.)\n                step.y = 1.;\n            break;\n        }\n        step.x++;\n    }\n    step.w = dist.y;\n    return (step);\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n    v = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3    camera(vec2 uv)\n{\n    float       fov = 1.;\n    vec3        forw  = vec3(0.0, 0.0, -1.0);\n    vec3        right = vec3(1.0, 0.0, 0.0);\n    vec3        up    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x-.85) * right + (uv.y-0.5) * up + fov * forw));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsBDS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 429, 473, 473, 1018], [1024, 1024, 1050, 1050, 1199], [1201, 1201, 1227, 1227, 1370], [1372, 1372, 1395, 1395, 2185], [2187, 2187, 2222, 2222, 3290], [3292, 3306, 3346, 3346, 3424], [3426, 3426, 3476, 3476, 3739], [3741, 3741, 3766, 3766, 4006]], "test": "untested"}
{"id": "llsfDf", "name": "Reality-lens", "author": "metayan", "description": "Go fullscreen and stare into the middle for half a minute, then look around.\nOld idea - tweaked for efficiency.", "tags": ["eyebender"], "likes": 3, "viewed": 69, "published": "Public", "date": "1513765488", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.y/iResolution.x;\n    vec2 P = 75.0 * (fragCoord.xy/iResolution.x - vec2(0.5,ratio/2.0));\n    float C = 1.2 * sin((atan(P.x,P.y) + length(P) + mod(10.0*iTime,6.2831855)) * 5.0);\n    fragColor = vec4(C, C, C, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsfDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 302]], "test": "untested"}
{"id": "llsfDl", "name": "Spiral 3 (Blue/Pink)", "author": "lsdlive", "description": "Twisted menger cube.\n\nShort menger formula borrowed from aiekick/coyote.", "tags": ["raymarching", "spiral"], "likes": 15, "viewed": 687, "published": "Public", "date": "1514056605", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat smin(float a, float b) {\n\tfloat k = 7.;\n\tfloat res = exp(-k*a) + exp(-k*b);\n\treturn -log(res) / k;\n}\n\nfloat sdHexPrism(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.z - h.y, max((q.x*0.866025 + q.y*0.5), q.y) - h.x);\n}\n\nfloat sc(vec3 p, float r) {\n\tfloat s1 = sdHexPrism(p, vec2(r, 1e6));\n\tfloat s2 = sdHexPrism(p.yzx, vec2(r, 1e6));\n\tfloat s3 = sdHexPrism(p.zxy, vec2(r, 1e6));\n\treturn min(s1, min(s2, s3));\n}\n\nfloat ssc(vec3 p, float r) {\n\tfloat s1 = sdHexPrism(p, vec2(r, 1e6));\n\tfloat s2 = sdHexPrism(p.yzx, vec2(r, 1e6));\n\tfloat s3 = sdHexPrism(p.zxy, vec2(r, 1e6));\n\treturn smin(s1, smin(s2, s3));\n}\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat m_particule(vec3 p, float r, float x, float d, vec2 s) {\n\tfloat t = iTime*.3;\n\tp.z = mod(p.z + d, 4.) - 2.;\n\tp.x += s.x*sin(t)*.6;\n\tp.y += s.y*cos(t*2.)*.5;\n\tp.z += sin(t*2.);//*2.6;\n\n\t\t\t\t\t //p.xz *= r2d(iTime);\n\t\t\t\t\t //p.xy *= r2d(iTime);\n\t\t\t\t\t //return length(max(abs(p) - vec3(r*.5), 0.));// - r;\n\t\t\t\t\t //return sdHexPrism(p, vec2(r, r*.5));\n\treturn length(p) - r;\n}\n\nvec2 de(vec3 p) {\n\tfloat d = 0., s = 1.;\n\n\tfloat mp1 = m_particule(p, .02, .5, 0., vec2(-1.));\n\tfloat mp2 = m_particule(p, .045, -.7, 3., vec2(-1., 1.));\n\tfloat mp3 = m_particule(p, .03, .1, 2., vec2(1., -1.));\n\tfloat mp4 = m_particule(p, .025, .1, 1., vec2(1., 1.));\n\n\tfloat particules = min(mp1, min(mp2, mp3));\n\tparticules = min(particules, mp4);\n\n\tp.xy *= r2d(iTime*.1 + p.z);\n\n\tvec3 q = p;\n\n\tfor (int i = 0; i < 5; i++) {\n\t\tq = mod(p*s + 1., 2.) - 1.;\n\t\td = max(d, -ssc(q, .59) / s);\n\t\ts += 6.;\n\t}\n\n\tif (d < particules)\n\t\treturn vec2(d, 1);\n\telse\n\t\treturn vec2(particules, 2);\n}\n\n/*\nvec3 normal(in vec3 pos)\n{\n\tvec2 e = vec2(1., -1.)*.5773*.0005;\n\treturn normalize(e.xyy*de(pos + e.xyy).x +\n\t\te.yyx*de(pos + e.yyx).x +\n\t\te.yxy*de(pos + e.yxy).x +\n\t\te.xxx*de(pos + e.xxx).x);\n}\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 ro = vec3(.15*cos(iTime), .1*sin(iTime), -iTime*.4), p;\n\tvec3 rd = normalize(vec3(uv, -1));\n\tp = ro;\n\n\tfloat it = 0.;\n\tvec2 res;\n\tfor (float i = 0.; i < 1.; i += .02) {\n\t\tit = i;\n\t\tres = de(p);\n\t\tif (res.x < .001) break;\n\t\tp += rd*res.x*.75;\n\t}\n\n\tvec3 c;\n\n\tif (res.y == 2.) {\n\t\tc = mix(vec3(1., .1, .5), vec3(.2, .1, .2), it);\n\t\t//c += vec3(.5, .2, .4) * max(0., dot(-rd, normal(p)));\n\t}\n\telse {\n\t\tc = mix(vec3(.2, .7, .7), vec3(.2, .1, .2), it);\n\t}\n\n\tfloat dist = length(ro - p);\n\tc = mix(c, vec3(.2, .1, .2), 1. - exp(-.1 * dist*dist));\n\n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsfDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 31, 31, 107], [109, 109, 143, 143, 229], [231, 231, 258, 258, 421], [423, 423, 451, 451, 616], [618, 618, 637, 637, 697], [699, 699, 761, 761, 1074], [1076, 1076, 1093, 1093, 1659], [1661, 1862, 1917, 1917, 2580]], "test": "untested"}
{"id": "llsfRj", "name": "Moebius Spiral iso-bands", "author": "FabriceNeyret2", "description": "Application of screenspace isolines in procedural transforms\nLine #65: uncomment for round.\n\nIlusion: lines keeps undistorted despite the stretching. ;-)", "tags": ["spiral", "mobius", "illusion", "complex", "screenspace", "tuto", "weave"], "likes": 47, "viewed": 1595, "published": "Public API", "date": "1512551019", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// === Drawing transformed-space isolines using screen-space metrics ================\n// Application (and cleaning) of https://shadertoy.com/view/Xlffzj\n// Conformal version in https://www.shadertoy.com/view/MllBzj\n\n#define S(v) smoothstep(2./iResolution.y, 0., v )\n\n// --- direct transforms\nvec2 Mobius(vec2 p, vec2 z1, vec2 z2)\n{\n\tz1 = p - z1; p -= z2;\n\treturn mat2(z1,z1.y,-z1.x) * p / dot(p, p);\n}\n\nvec2 spiralZoom(vec2 p, vec2 offs, float n, float spiral, float zoom, vec2 phase)\n{\n\tp -= offs;\n\tfloat a = atan(p.y, p.x)/6.283 + iTime/32.;\n\tfloat d = length(p);\n\treturn mat2(n,1, spiral,-zoom) * vec2(a, log(d)) + phase;\n}\n\n// --- inverse transforms\nvec2 iMobius(vec2 p, vec2 z1, vec2 z2)     \n{                               \n    float s = sign(p.x), sb = sign(p.y),             // make unique sol: s=1,x1,y1 otherwise 4\n          l = length(p), t = p.y/p.x,                // solve  u = v*l ; tan(u,v) = p.y/p.x\n          c = s / sqrt(1.+t*t),                      // c = cos(atan( ) )\n        v = length(z1-z2) / sqrt( 1.+ l*l -2.*l*c ), // c = (u²+v²-|z1z2|² ) / 2uv\n        u = v*l;                                   \n    vec2  a = 2.*(z1-z2);                            // solve |P-z1| = u ; |P-z2| = v\n    float b = u*u-v*v + dot(z2,z2)-dot(z1,z1);       // ||²-||²: a.P + b = 0\n    // y = -( b + a.x* x ) / a.y                     // normalize by a.y\n    b /= a.y; a /= a.y;                              // ( in Shane example a.y was = 0 ! )\n    float A = 1. +  a.x*a.x,                         //  |P-z1|² = u² , P = (x,y)\n          B =     2.* b*a.x -2.*dot(vec2(1,-a.x),z1),\n          C =           b*b +2.*b*z1.y + dot(z1,z1) - u*u,\n          D = max(0., B*B - 4.*A*C),\n         x1 = (-B+sb*sqrt(D))/(2.*A), y1 = -( b + a.x*x1 );\n     //  x2 = (-B-sb*sqrt(D))/(2.*A), y2 = -( b + a.x*x2 );\n  // if (abs(A)<1e-5) { x1 = x2 = -C/B; y1 = y2 = -( b + a.x*x1 ) / a.y; } // degenerate case\n\treturn vec2(x1,y1);                    \n}\n\nvec2 ispiralZoom(vec2 p, vec2 offs, float n, float spiral, float zoom, vec2 phase)\n{\n    p = inverse(mat2(n,1, spiral,-zoom)) * (p-phase) ;\n    p.x = (p.x - iTime/32.) * 6.283;             // ( p.x, p.y )  = ( a, log(d) )\n    return exp(p.y) * vec2(cos(p.x),sin(p.x)) + offs;\n}\n\n// --- demo configuration \nvec2 Z1 = vec2(-.875, -.525),  // in Shane example Z1.y=Z2.y was causing a degenerescence\n     Z2 = vec2(.375, -.125);\n\nvec2 MobiusSpiral(vec2 q)      // total direct transform\n{\n    q = Mobius(q, Z1, Z2);\n    return spiralZoom(q, vec2(-.5), 5., 3.14159*.2, .5, vec2(-1, 1)*iTime*.25);\n}\nfloat DrawInvMobiusSpiral(vec2 q, vec2 uv0, float r) // total inverse transform + draw iso-X\n{\n    vec2 v; float s = 0.;\n    q = ispiralZoom(q, vec2(-.5), 5., 3.14159*.2, .5, vec2(-1, 1)*iTime*.25);\n    v = iMobius(q, Z1, Z2);  \n    return S(length(uv0-v) - r ); // * (.5+.5* cos( 3.14 * length(uv0-v) / r / 2.) );\n}\n\n#define rnd(p) fract( 43758.5453 * sin( dot(p, vec2(12.9898, 78.233))) )\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n\tvec2 R = iResolution.xy,\n        uv0 = (U -.5*R) / R.y,\n    uv = MobiusSpiral(uv0);\n#define f(v) fract(v+.5)-.5                                    // suppress the wrapping glitch\n    mat2 M = inverse(mat2(f(dFdx(uv)),f(dFdy(uv)))) / max(360.,R.y); // measure compression, for LOD\n     \n    O -= O;\n    float l,a, r=.005; vec2 q;\n    for (int i=0; i<2; i++) {\n        //q = floor(uv*4.)/4.;\n        \n        l = log2(20.*length(M[1]));\n        a = fract(l);\n        l = exp2(floor(l));                                    // compute LOD\n      //l = exp2(floor(l+rnd(uv0)));                           // variant: fading by dithering\n        q = vec2( floor(uv.x*l+float(i)) / l, uv.y );          // H isolines in screen space\n        O += (1.-a)* DrawInvMobiusSpiral(q, uv0, r );\n        q = vec2( floor(uv.x*(l*2.)+float(i)) / (l*2.), uv.y );// inter-LOD fading\n        O += a* DrawInvMobiusSpiral(q, uv0, r );\n#if 0    \n        l = exp2(floor(log2(100.*length(M[0])))); \n        q = vec2( uv.x, floor(uv.y*l+float(i)) / l );          // V isolines in screen space\n        O.b += DrawInvMobiusSpiral(q, uv0, r );\n#endif\n#if 0            \n        for (int j=0; j<2; j++) {\n            q = floor(uv*4. +vec2(i,j) ) / 4.;                 // dots in screen space\n            O.g += DrawInvMobiusSpiral(q, uv0, .02 );\n        }\n#endif        \n\n    }\n//  O = sqrt(O);                                               // to sRGB\n    \n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsfRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[267, 292, 331, 331, 401], [403, 403, 486, 486, 626], [628, 654, 699, 699, 1949], [1951, 1951, 2035, 2035, 2228], [2230, 2377, 2435, 2435, 2544], [2545, 2545, 2639, 2639, 2861], [2937, 2937, 2973, 2973, 4398]], "test": "untested"}
{"id": "llsfWl", "name": "Triangle Intersections", "author": "mla", "description": "Playing with ray-triangle intersection.Also attempting to be seriously branch-free.", "tags": ["triangle", "intersection", "barycentric", "branchfree", "trumbore", "moller"], "likes": 7, "viewed": 717, "published": "Public API", "date": "1514071059", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// (c) Matthew Arcus 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Experimenting with ray-triangle intersection algorithms.\n// Finding intersection requires solving a linear system of equations.\n// Can solve directly with matrix inversion or, possibly faster,\n// use Cramer's rule, with simplifications (Möller, Trumbore algorithm).\n\n// Draws a twisted prism of N triangles centred around origin.\n// Color is a direct conversion of barycentric coords to RGB.\n\nconst int N = 50;\nfloat scale = 1.5;\n\nconst float PI = 3.14159;\nconst float TWOPI = 2.0*PI;\n\n// find a,b such that:\n// p + kr = av0 + bv1 + (1-a-b)v2 = a(v0-v2)+b(v1-v2)+v2\n// ie. -kr + a(v0-v2) + b(v1-v2) = p-v2\n// return vec4(k,a,b,c) where c = 1-a-b\n#if 0\n// Solve linear system with a matrix inversion\nvec4 triangle(vec3 p, vec3 r, vec3 v0, vec3 v1, vec3 v2) {\n  vec3 a = inverse(mat3(-r,v0-v2,v1-v2))*(p-v2);\n  return vec4(a,1.0-a.y-a.z);\n}\n#else\n// Standard algorithm by Tomas Möller and Ben Trumbore.\n// Uses Cramer's rule with some simplifications to solve linear system as above.\n// http://webserver2.tecgraf.puc-rio.br/~mgattass/cg/trbRR/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf\nvec4 triangle(vec3 o, vec3 d, vec3 v0, vec3 v1, vec3 v2) {\n  // find a,b such that:\n  // p + kr = av0 + bv1 + (1-a-b)v2 = a(v0-v2)+b(v1-v2)+v2\n  // ie. -kr + a(v0-v2) + b(v1-v2) = p-v2\n  vec3 e1 = v0 - v2;\n  vec3 e2 = v1 - v2;\n  vec3 t = o - v2;\n  vec3 p = cross(d,e2);\n  vec3 q = cross(t,e1);\n  vec3 a = vec3(dot(q,e2),dot(p,t),dot(q,d))/dot(p,e1);\n  return vec4(a,1.0-a.y-a.z);\n}\n#endif\n\n// Rotation matrices, nb: column major.\n// Matrix from quaternion\nmat3 qrot(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  return 2.0*mat3(0.5-y*y-z*z, x*y+z*w,     x*z-y*w,\n                  x*y-z*w,     0.5-x*x-z*z, y*z+x*w,\n                  x*z+y*w,     y*z-x*w,     0.5-x*x-y*y);\n}\n\n// Rotations about x,y,z axes.\nmat3 xrotate(float theta) {\n  return mat3(1,0,0,0,cos(theta),sin(theta),0,-sin(theta),cos(theta));\n}\nmat3 yrotate(float theta) {\n  return mat3(cos(theta),0,sin(theta),0,1,0,-sin(theta),0,cos(theta));\n}\nmat3 zrotate(float theta) {\n  return mat3(cos(theta),sin(theta),0,-sin(theta),cos(theta),0,0,0,1);\n}\n\nvoid mainImage(out vec4 outColor, vec2 fragCoord) {\n  vec2 xy = scale*(2.0*fragCoord - iResolution.xy)/iResolution.y;\n  // p+kq is viewing ray\n  // Rotate camera with quaterion.\n  vec3 axis = normalize(vec3(1,1,1));\n  float theta = -0.1618*iTime;\n  mat3 m = qrot(vec4(sin(theta)*axis,cos(theta)));\n  vec3 p = vec3(0,0,-6);\n  vec3 q = normalize(vec3(xy,0)-p);\n  vec2 mouse = float(iMouse.x > 0.0)*TWOPI*(iMouse.xy-iResolution.xy)/iResolution.xy;\n  // y coord determines rotation about x axis etc.\n  m = m*yrotate(mouse.x)*xrotate(-mouse.y);\n  p = m*p; q = m*q;\n\n  // Initialize triangle matrices\n  mat3 m1 = zrotate(-0.5*iTime); // Rotate triangle about centre\n  mat3 m1inc = zrotate(TWOPI/float(N));\n  mat3 m2 = mat3(1); // Rotate triangle about y-axis\n  mat3 m2inc = yrotate(TWOPI/float(N));\n  vec3 off = vec3(1,0,0); // Base triangle offset\n  vec4 amin = vec4(1e8,0,0,0);\n  for (int i = 0; i < N; i++) {\n    // Equilateral triangle pointing left.\n    vec3 v0 = off + m1*vec3(-1,0,0);\n    vec3 v1 = off + m1*vec3(0.5,-0.866,0);\n    vec3 v2 = off + m1*vec3(0.5,0.866,0);\n    v0 = m2*v0; v1 = m2*v1; v2 = m2*v2;\n    m1 = m1inc*m1;\n    m2 = m2inc*m2;\n    vec4 a = triangle(p,q,v0,v1,v2);\n    // Vectorize comparisons,check:\n    // 0 <= a,b,c <= 1 and 0 <= k < kmin\n    bool hit = all(bvec2(all(greaterThanEqual(a,vec4(0))),\n                         all(lessThanEqual(a,vec4(amin.x,1,1,1)))));\n    amin -= float(hit)*amin; // Try to avoid rounding error\n    amin += float(hit)*a;\n  }\n  outColor = vec4(amin.yzw,1.0); // Use barycentric coords as RGB values\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsfWl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1605, 1671, 1690, 1690, 1900], [1902, 1933, 1960, 1960, 2033], [2034, 2034, 2061, 2061, 2134], [2135, 2135, 2162, 2162, 2235], [2237, 2237, 2288, 2288, 3792]], "test": "untested"}
{"id": "llsfzl", "name": "Blue Beams", "author": "MetCodeMass", "description": "This is my first shader I've made public. It's not much, just a random glowing circle with beams comming out of it, but I thought it would be nice to share it with womever finds it.", "tags": ["circle", "animated", "blue", "beams", "glowing"], "likes": 1, "viewed": 141, "published": "Public", "date": "1513007185", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float r = 100.0;\nfloat halo = 50.0;\nfloat cursorSize = 50.0;\nfloat lineWidth = .15;\nfloat lineOffset = 150.0;\nfloat bigR = 250.0;\n\nbool isDrawing(float d, float dxy) {\n    return dxy > bigR - lineWidth * d && dxy < bigR + lineWidth * sin(iTime) * d;\n}\n\nvec4 lineColor(float lineIntensity) {\n    return vec4(lineIntensity * .25, lineIntensity, lineIntensity, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mid = vec2(iResolution[0] * .5, iResolution[1] * .5);\n    float d = distance(fragCoord, mid);\n    float lineIntensity = 1.0 - sin((d - r) * .006);\n    \n    float d00 = distance(fragCoord, vec2(mid[0] - lineOffset, mid[1] - lineOffset));\n    float d01 = distance(fragCoord, vec2(mid[0] - lineOffset, mid[1] + lineOffset));\n    float d10 = distance(fragCoord, vec2(mid[0] + lineOffset, mid[1] - lineOffset));\n    float d11 = distance(fragCoord, vec2(mid[0] + lineOffset, mid[1] + lineOffset));\n    \n    if (d > r && fragCoord[0] < mid[0] && isDrawing(d, d00)) {\n        fragColor = lineColor(lineIntensity);\n    }\n    else if (d > r && fragCoord[1] > mid[1] && isDrawing(d, d01)) {\n        fragColor = lineColor(lineIntensity);\n    }\n    else if (d > r && fragCoord[1] < mid[1] && isDrawing(d, d10)) {\n        fragColor = lineColor(lineIntensity);\n    }\n    else if (d > r && fragCoord[0] > mid[0] && isDrawing(d, d11)) {\n        fragColor = lineColor(lineIntensity);\n    }\n    else if (d < r) {\n        if (d < r * .75) {\n            fragColor = vec4(.75, 1, 1, 0);\n        }\n        else {\n            float intensity = cos((d - r * .75) * .05);\n        \tfragColor = vec4(.75 * intensity, 1, 1, 0);\n        }\n    }\n    else if (d < r + halo) {\n        float intensity = 1.0 - (distance(fragCoord, mid) - r) / halo;\n\n        intensity *= abs(sin(iTime));\n        fragColor = vec4(intensity * .25, intensity, intensity, 0);\n    }\n    else {\n        fragColor = vec4(0, 0, 0, 0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsfzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 167, 167, 251], [253, 253, 290, 290, 363], [365, 365, 422, 422, 1916]], "test": "untested"}
{"id": "llsyDf", "name": "Flower Lattice", "author": "aiekick", "description": "Flower Lattice", "tags": ["flower", "lattice"], "likes": 12, "viewed": 581, "published": "Public API", "date": "1513532380", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nconst vec3 ld = vec3(0.,1., .5);\n\nfloat t = 0.;\n\nmat3 rotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nvec2 path(float z)\n{\n\treturn vec2(0,0);\n}\n\nfloat fullAtan(vec2 p)\n{\n    return step(0.0,-p.x)*3.1415926535 + sign(p.x) * atan(p.x, sign(p.x) * p.y);\n}\n\nfloat umbrella(vec2 p)\n{\n\tfloat count = floor(5.);\n    float a = atan(p.x,p.y)/3.14159*count/2.;\n    a = fract(a);\n\treturn 2.6 / (0.545 * sin(a) + cos(a)) - length(p);\n}\n\nvec2 df(vec3 p)\n{\n\tp *= rotZ(p.z * 0.036);\n\t//p.xz = mod(p.xz, uSlider11)-uSlider11*.5;\n\tp.xz = cos(p.xz*0.5);\n\tfloat r = (sin(iTime*.2)*.5+.5)*1.12;\n\tp.y = abs(p.y)-r;\n\tfloat um = length(vec2(umbrella(p.xz)+1.6,p.y)) - 3.48;\n\t\n\tfloat plane = p.y;\n\t\n\tfloat d = min(plane, um);\n\t\n    return vec2(d,1.);\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<1; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 10;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint).x;\n\t}\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s).x;\t\t\t\t\t\t// ratio between df step and constant step\n}\n\n// from shane sahders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    p = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// from shane sahders\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf)\n{\n    const vec2 e = vec2(0.001, 0);\n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\nvec4 shade(vec3 ro, vec3 rd, float d, vec3 lp, float li)\n{\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tfloat sb = SubDensity(p, 0.01, 0.04);\t\t\t\t\t\t\t// deep subdensity (10 iterations)\n\tvec3 bb = blackbody(80.*sb+320.);\t\t\t\t\t\t\t\t// bb\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, 0.1);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tn = doBumpMap(iChannel0, p, n, 0.019);\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat amb = 0.23; \t\t\t\t\t\t\t\t\t\t\t\t// ambiance factor\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\t\t// specular\n\tfloat sss = 1. - SubDensity(p, 7.8); \t\t\t\t\t\t\t// one step sub density of df\n\treturn vec4(\n        (diff + fre + bb.x * sss) * amb * li + spe, \n        (diff + fre + bb * sb * 0.8 + sss * 0.4) * amb * li + spe * 0.6 \t\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(1);\n\t\n\tvec2 g = fragCoord.xy;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*g-si)/min(si.x, si.y);\n\t\n\tt = iTime;\n\t\n\tvec3 ro = vec3(0,0,t);\n\tro.xy += path(ro.z);\n\t\n\tvec3 lp = ro;\t// light pos\n\t\n\tvec3 cu = vec3(0,1,0);\n\tvec3 co = ro - vec3(0,0,1);\n\t\n\tfloat fov = .5;\n\tvec3 z = normalize(co - ro);\n\tvec3 x = normalize(cross(cu, z));\n\tvec3 y = normalize(cross(z, x));\n\tvec3 rd = normalize(z + fov * uv.x * x + fov * uv.y * y);\n\t\n\tfloat s = 0.;\n\tfloat d = 0.;\n\tvec3 p = ro + rd * d;\n\tfloat dMax = 20.;\n\tfloat sMin = 0.0001;\n\t\n\tfor (float i=0.; i<250.; i++)\n\t{\n\t\tif (log(d*d/s/1e5)>0. || d>dMax) break;\n\t\ts = df(p).x;\n\t\td += s * 0.5;\n\t\tp = ro + rd * d;\t\n\t}\n\t\n    //vec3 sky = GetSky(rayDir, ld, vec3(1.5));\n    \n\tif (d<dMax)\n\t{\n\t\tvec3 n = nor(p, 0.01);\n\t\t\n\t\t// \tiq primitive shader : https://www.shadertoy.com/view/Xds3zN\n\t\t/*float r = mod( floor(5.0*p.z) + floor(5.0*p.x), 2.0);\n        gl_FragColor.rgb = 0.4 + 0.1*r*vec3(1.0);*/\n\n\t\tfragColor.r = df(p-n*1.).x;\n\t\tfragColor.g = df(p-n*-1.04).x;\n\t\tfragColor.b = df(p-n*-2.6).x;\n\t\t\n        // iq lighting\n\t\t/*float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, ld ), 0.0, 1.0 );\n        float spe = pow(clamp( dot( rayDir, ld ), 0.0, 1.0 ),16.0);\n\n        //dif *= softshadow( p, ld, 0.1, 10. );\n\n\t\t/*gl_FragColor.rgb = mix(\n            shade(rayOrg, rayDir, d, rayOrg, 1.2).yzw, \n            gl_FragColor.rgb, \n            1.-exp(-0.002*d*d));*/\n        //gl_FragColor.rgb = mix( gl_FragColor.rgb, sky, 1.0-exp( -0.01*d*d ) ); \n\t\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\t\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\t\t//vec3 n = nor(p, 0.1);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\t\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\t\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\t\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\t\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\t\t// specular\n\t\tvec3 col = vec3(0.8,0.5,0.2);\n\t\tfloat sss = df(p - n*0.001).x/0.01;\t\t\t\t\t\t\t\t// quick sss 0.001 of subsurface\n\t\t\n\t\tfloat sb = SubDensity(p, 0.01, 0.01);\t\t\t\t\t\t\t// deep subdensity \n\t\tvec3 bb = clamp(blackbody(100. * sb),0.,1.);\t\t\t\t\t// blackbody color\n\t\tfloat sss2 = 1.0 - SubDensity(p, 1.5); \t\t\t\t\t\t\t// one step sub density of df of 1.5 of subsurface\n\t\t\n\t\tvec3 a = (diff + fre + bb * sss * .8 + col * sss * .2) * 0.35 + spe;\n\t\tvec3 b = col * sss2;\n\t\t\n\t\tfragColor.rgb = mix(fragColor.rgb, b, .8-exp(-0.005*d*d));\n\t}\n\telse\n\t{\n\t\t//gl_FragColor.rgb = sky;\n\t}\n}\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsyDf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 263, 282, 282, 340], [342, 342, 362, 362, 383], [385, 385, 409, 409, 492], [494, 494, 518, 518, 663], [665, 665, 682, 682, 968], [970, 970, 1002, 1002, 1180], [1182, 1198, 1272, 1272, 1511], [1513, 1529, 1571, 1571, 1870], [1873, 2094, 2122, 2122, 2447], [2449, 2531, 2588, 2588, 2812], [2814, 2814, 2850, 2850, 2985], [2987, 3163, 3214, 3214, 3388], [3390, 3599, 3662, 3662, 4024], [4026, 4026, 4084, 4084, 4965], [4967, 4967, 5024, 5024, 7538]], "test": "untested"}
{"id": "llXBWB", "name": "Bubbles music visualizer", "author": "liyouvane", "description": "bubbles....\nreference : https://github.com/ashima/webgl-noise\nreference : I/O fragment shader by movAX13h https://www.shadertoy.com/view/XsfGDS", "tags": ["sound"], "likes": 16, "viewed": 452, "published": "Public", "date": "1513112199", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// reference : https://github.com/ashima/webgl-noise\n// reference : I/O fragment shader by movAX13h, August 2013 \n// https://www.shadertoy.com/view/XsfGDS\n\n#define SHOW_BLOCKS\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n\nfloat rand(float x)\n{\n    return fract(sin(x) * 4358.5453123);\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5357);\n}\n\nfloat circle(vec2 p, vec2 b, float r)\n{\n  return length(p-b)-r;\n}\n\nfloat box(vec2 p, vec2 b, float r)\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sampleMusic()\n{\n\treturn 0.5 * (\n//\t\ttexture( iChannel0, vec2( 0.01, 0.25 ) ).x + \n//\t\ttexture( iChannel0, vec2( 0.07, 0.25 ) ).x + \n\t\ttexture( iChannel0, vec2( 0.15, 0.25 ) ).x + \n\t\ttexture( iChannel0, vec2( 0.30, 0.25 ) ).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst float speed = 0.4;\n\tconst float ySpread = 1.6;\n\tconst int numBlocks = 30;\n\tconst int numBubbles = 50;\n\tfloat pulse = sampleMusic();\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec3 baseColor = uv.x > 0.0 ? vec3(0.0,0.3, 0.3) : vec3(0.3, 0.0, 0.3);\n\n\tvec3 color = 5. * pulse*baseColor*0.5*(0.9-cos(uv.x*8.0));\n\tuv.x *= aspect;\n\t\n\tfor (int i = 0; i < numBubbles; i++)\n\t{\n\t\tfloat z = 1.0-0.7*rand(float(i)*1.4333); // 0=far, 1=near\n\t\tfloat tickTime = iTime*z*speed + float(i)*1.23753;\n\t\tfloat tick = floor(tickTime);\n\t\t\n\t\tvec2 pos = vec2(0.6*aspect*(rand(tick)-0.5), -abs(sign(uv.x))*ySpread*(0.5-fract(tickTime)));\n\t\tpos.x += 0.18*sign(pos.x); // move aside\n\t\tif (abs(pos.x) < 0.1) pos.x++; // stupid fix; sign sometimes returns 0\n\t\t\n\t\tvec2 size = 1.8*z*vec2(0.04, 0.04 + 0.1*rand(tick+0.2));\n\t\tfloat b = circle(uv, pos, 0.01 + 0.15 * pulse);\n\t\tfloat dust = z*smoothstep(0.22, 0.0, b)*pulse*0.5;\n\t\tfloat block = 0.2*z*smoothstep(0.012, 0.0, b);\n\t\tfloat shine = 0.6*z*pulse*smoothstep(-0.002, b, 0.007);\n        float u_Scale = 9.;\n        float noise = sin(abs(cnoise(u_Scale * uv.xy)+0.5*cnoise(2. * u_Scale * uv.xy)+0.25*cnoise(4. * u_Scale * uv.xy)+0.125*cnoise(8. * u_Scale * uv.xy)));\n\t\tcolor += dust*baseColor*(1.+3. * noise) + block*z + shine;\n\t}\n    baseColor = vec3(0.1, 0.3, 0.0);\n    for (int i = 0; i < numBlocks; i++)\n\t{\n\t\tfloat z = 1.0-0.7*rand(float(i)*1.4333); // 0=far, 1=near\n\t\tfloat tickTime = iTime*z*speed + float(i)*1.23753;\n\t\tfloat tick = floor(tickTime);\n\t\t\n\t\tvec2 pos = vec2(0.6*aspect*(rand(tick)-0.5), -abs(sign(uv.x))*ySpread*(0.5-fract(tickTime)));\n\t\tpos.x += 0.24*sign(pos.x); // move aside\n\t\tif (abs(pos.x) < 0.1) pos.x++; // stupid fix; sign sometimes returns 0\n\t\t\n\t\tvec2 size = 1.8*z*vec2(0.04, 0.04 + 0.1*rand(tick+0.2));\n\t\tfloat b = circle(uv-pos, size, 0.02);\n\t\tfloat dust = z*smoothstep(0.22, 0.0, b)*pulse*0.5;\n\t\tfloat block = 0.2*z*smoothstep(0.002, 0.0, b);\n\t\tfloat shine = 0.6*z*pulse*smoothstep(-0.002, b, 0.007);\n        float u_Scale = 9.;\n        float noise = sin(abs(cnoise(u_Scale * uv.xy)+0.5*cnoise(2. * u_Scale * uv.xy)+0.25*cnoise(4. * u_Scale * uv.xy)+0.125*cnoise(8. * u_Scale * uv.xy)));\n\t\tcolor += dust*baseColor*(1.+noise) + block*z + shine;\n\t}\n\tcolor /= 1.5;\n\tcolor -= rand(uv)*0.04;\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llXBWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 177, 198, 198, 247], [249, 249, 271, 271, 308], [310, 310, 338, 338, 390], [392, 392, 411, 411, 451], [453, 477, 499, 499, 1531], [1534, 1534, 1555, 1555, 1598], [1600, 1600, 1621, 1621, 1693], [1695, 1695, 1734, 1734, 1760], [1762, 1762, 1798, 1798, 1838], [1840, 1840, 1861, 1861, 2074], [2076, 2076, 2133, 2133, 4467]], "test": "untested"}
{"id": "llXBzB", "name": "3d rendering first attempt", "author": "kparga", "description": "TODO:\n-microphone-based particles\n-refractive sphere\n-metalic cilinder ", "tags": ["3d", "raymarching", "primitives"], "likes": 5, "viewed": 223, "published": "Public", "date": "1512332862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n//  https://www.shadertoy.com/view/Xds3zN\n//\n\n#define AA 1   // make this 1 is your machine is too slow\n\n\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\n\nfloat sdSphere( vec3 position, float radius )\n{\n    return length(position)-radius;\n}\n\nfloat sdTorus( vec3 position, vec2 params )\n{\n    float R=params.x;\n    float r=params.y;\n    return length( vec2(length(position.xz)-R,position.y) )-r;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    float radius = h.x;\n    float height = h.y;\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdOctahedron( vec3 p, vec3 h )// h = { cos a, sin a, height }\n{\n    // Tetrahedron = Octahedron - Cube\n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n    float octa = d - h.z;\n    return octa;\n\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float t = 20.0*sin(iTime);\n    float  c = cos(t*p.y+10.0);\n    float  s = sin(t*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec3 opCheapBend( vec3 p )\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     \tpos), 70.0 ),\n                    vec2( sdSphere(    \tpos-vec3( 0.0,0.40+abs(0.3*sin(iTime+5.0)), 0.0), 0.40 ), 8.0 ) );\n    res = opU( res, vec2( sdTorus(     \tpos-vec3( -1.0,0.4, 1.0), vec2(0.3,0.1) ), 90.0+50.0*sin(iTime*0.2)) );\n    res = opU( res, vec2( sdCylinder(  \tpos-vec3( 1.0,0.55,-1.0), vec2(0.1,0.4) ), 170.0 ) );\n    res = opU( res, vec2( 0.25*sdTorus(\topTwist(pos-vec3(1.0,0.55, 1.0)),vec2(0.3,0.1)), 154.1 ) );\n    res = opU( res, vec2( sdOctahedron( pos-vec3(-1.0,0.55 +0.1*sin(iTime),-1.0), vec3(0.8,0.6,0.25) ),80.0 ) );\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n#if 1\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n        else           tmax = min( tmax, tp2 ); }\n#endif\n\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<65; i++ )\n    {\n        float precis = 0.0005*t;\n        vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n        m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x +\n                      e.yyx*map( pos + e.yyx ).x +\n                      e.yxy*map( pos + e.yxy ).x +\n                      e.xxx*map( pos + e.xxx ).x );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n    float m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n\n        // material\n        col = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n\n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.3 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng\n        float occ = calcAO( pos, nor );\n        vec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n\n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n        vec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n        lin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n        col = col*lin;\n\n        col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n    return vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n    float time = 15.0 + iTime;\n\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n    // camera\n    vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -0.5, -0.4, 0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\n    vec3 col = render( ro, rd );\n\n    // gamma\n    col = pow( col, vec3(0.4545) );\n\n    tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llXBzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 180, 205, 205, 223], [225, 225, 272, 272, 310], [312, 312, 357, 357, 466], [468, 468, 504, 504, 655], [658, 658, 727, 766, 1047], [1049, 1049, 1093, 1093, 1153], [1155, 1225, 1255, 1255, 1291], [1293, 1293, 1323, 1323, 1352], [1354, 1354, 1378, 1378, 1535], [1537, 1537, 1565, 1565, 1684], [1687, 1757, 1782, 1782, 2380], [2382, 2382, 2422, 2422, 3002], [3005, 3005, 3079, 3079, 3348], [3350, 3350, 3382, 3382, 3863], [3865, 3865, 3907, 3907, 4205], [4207, 4207, 4246, 4246, 5823], [5825, 5825, 5877, 5877, 6066], [6068, 6068, 6125, 6125, 7043]], "test": "untested"}
{"id": "llXfDf", "name": "Delay periodic", "author": "smkgames", "description": "delay between periodic functions test", "tags": ["delay"], "likes": 2, "viewed": 126, "published": "Public", "date": "1513626335", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float   N = 1.0,\n    delay = 0.5;//delay is between 0 and 1\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n\tU /= iResolution.xy;\n    float x = fract( U.x * N +iTime), // cut in N cycles\n          L = 1.-delay,\n\t      y = 6.28 * min(1.,  x / L ),   // remap and clamp in each cycle\n          z = sin(y);\n    O = vec4( abs( .5+.2*z - U.y ) < .01 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llXfDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 61, 99, 99, 341]], "test": "untested"}
{"id": "llXfRl", "name": "Welcome to the Starport", "author": "marian42", "description": "Animation that shows when loading a mission board in Elite Dangerous", "tags": ["2d", "triangles"], "likes": 30, "viewed": 1082, "published": "Public API", "date": "1512870252", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.14159265359;\nconst float triangleScale = 0.816497161855865; // ratio of edge length and height\nconst vec3 orange = vec3(0.937, 0.435, 0.0);\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec4 getTriangleCoords(vec2 uv) {\n    uv.y /= triangleScale;\n    uv.x -= uv.y / 2.0;\n    vec2 center = floor(uv);\n    vec2 local = fract(uv);\n    \n    center.x += center.y / 2.0;\n    center.y *= triangleScale;\n    \n    if (local.x + local.y > 1.0) {\n    \tlocal.x -= 1.0 - local.y;\n        local.y = 1.0 - local.y;\n        center.y += 0.586;\n        center.x += 1.0; \n    } else {\n        center.y += 0.287;\n    \tcenter.x += 0.5;\n    }\n    \n    return vec4(center, local);\n}\n\nvec4 getLoader(vec4 triangle) {\n    if (length(triangle.xy) > 1.6) {\n        return vec4(0.0);\n    }\n    \n    float angle = atan(triangle.x, triangle.y);\n    float seed = rand(triangle.xy);\n    float dst = min(triangle.z, min(triangle.w, 1.0 - triangle.z - triangle.w)) * 15.0;\n    float glow = dst < pi ? pow(sin(dst), 1.5) : 0.0;\n    \n    return vec4(mix(orange, vec3(1.0), glow * 0.07), pow(0.5 + 0.5 * sin(angle - iTime * 6.0 + seed), 2.0));\n}\n\nfloat getBackground(vec4 triangle) {\n    float dst = min(triangle.z, min(triangle.w, 1.0 - triangle.z - triangle.w)) - 0.05;\n\t\n    if (triangle.y > 1.9 || triangle.y < -2.4 || dst < 0.0) {\n        return 0.0;\n    }\n\n    float value = pow(0.5 + 0.5 * cos(-abs(triangle.x) * 0.4 + rand(triangle.xy) * 2.0 + iTime * 4.0), 2.0) * 0.08;    \n    return value * (dst > 0.05 ? 0.65 : 1.0);\n}\n\nvec3 getColor(vec2 uv) {\n    uv *= 2.0 / iResolution.y;\n    \n    vec3 background = vec3(getBackground(getTriangleCoords(uv * 6.0 - vec2(0.5, 0.3))));\n \tvec4 loader = getLoader(getTriangleCoords(uv * 11.0));\n    \n    vec3 color = mix(background, loader.rgb, loader.a);\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    fragCoord = fragCoord - 0.5 * iResolution.xy;\n\tfragColor.rgb = 0.25 * (getColor(fragCoord)\n                            + getColor(fragCoord + vec2(0.5, 0.0))\n                            + getColor(fragCoord + vec2(0.5, 0.5))\n                            + getColor(fragCoord + vec2(0.0, 0.5)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llXfRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 160, 180, 180, 250], [252, 252, 285, 285, 725], [727, 727, 758, 758, 1174], [1176, 1176, 1212, 1212, 1559], [1561, 1561, 1585, 1585, 1848], [1850, 1850, 1906, 1906, 2206]], "test": "untested"}
{"id": "lt2Bz1", "name": "Pattern04", "author": "edapx", "description": "patterns, flower", "tags": ["patterns", "flower"], "likes": 1, "viewed": 79, "published": "Public", "date": "1514726784", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 brickTile(vec2 _st, float _zoom){\n    _st *= _zoom;\n\t// http://thebookofshaders.com/09/\n    // Here is where the offset is happening\n    float pari = step(1., mod(_st.y,2.0));\n    _st.x += pari * 0.5;\n\t\n\tfloat frequency = 0.4;\n    //_st.x += fract(iTime * frequency) * pari;\n    _st.x += iTime * frequency * ( pari - step(pari, .1) );\n\n    return fract(_st);\n}\n\nvec3 elica(vec2 st, vec2 orig, float resize, float smoothness, float nPale){\n    // https://thebookofshaders.com/07/\n    // Use polar coordinates instead of cartesian\n    // This technique is a little restrictive but very simple.\n    // It consists of changing the radius of a circle depending \n    // on the angle to achieve different shapes.\n    vec2 toCenter = vec2(orig)-st;\n    float angle = atan(toCenter.y,toCenter.x);\n    float radius = length(toCenter)*resize;\n\n    float f = cos(angle*nPale);\n    return vec3( 1.-smoothstep(f,f+smoothness,radius) );;\n}\n\n\nvec3 when_eq(vec3 x, vec3 y) {\n  return 1.0 - abs(sign(x - y));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 st = fragCoord/iResolution.y;\n    vec3 color = vec3(1.0);\n    \n    vec3 orange = vec3(0.9, 0.5, 0.0);\n    vec3 azul = vec3(0.2, 0.6, 0.7);\n    vec3 yellow = vec3(0.8, 0.7, 0.0);\n    \n    // Apply the brick tiling\n    st = brickTile(st,6.0);\n   \n    orange *= elica(st, vec2(0.44), 4.6, 1.2, 3.0);\n    azul *= elica(st, vec2(0.47), 4.8, 1.9, 6.0);\n    yellow *= elica(st, vec2(0.5), 4.6, 1.2, 9.0);\n    \n    color = orange +azul + yellow;\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2Bz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 365], [367, 367, 443, 710, 929], [932, 932, 962, 962, 997], [1000, 1000, 1054, 1054, 1537]], "test": "untested"}
{"id": "ltBBRz", "name": "Processing Library", "author": "alijaya", "description": "change draw function like processing", "tags": ["processing"], "likes": 5, "viewed": 457, "published": "Public API", "date": "1514254232", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Internal\n\nstruct State {\n    bool isSmooth;\n    float smoothness;\n    bool isFill;\n    vec4 fill;\n    bool isStroke;\n    vec4 stroke;\n    float strokeWeight;\n    float strokeCap;\n    int ellipseMode;\n    int rectMode;\n    mat4 invMatrix;\n    vec2 coord;\n};\n\nState p_states[10];\nint p_states_length;\nState p_state;\nvec4 p_fragColor;\nvec2 p_fragCoord;\n\n// premultiplied\nvoid p_pixel(vec4 color) {\n    vec4 src = vec4(color.rgb * color.a, color.a);\n    vec4 dst = p_fragColor;\n    p_fragColor = src + dst * (1.0 - src.a);\n}\n\nvoid p_fill(float value) {\n    vec4 color = p_state.fill;\n    color.a *= value;\n    if (p_state.isFill && color.a > 0.0) {\n        p_pixel(color);\n    }\n}\n\nvoid p_stroke(float value) {\n    vec4 color = p_state.stroke;\n    color.a *= value;\n    if (p_state.isStroke && color.a > 0.0) {\n        p_pixel(color);\n    }\n}\n\nvoid p_updateCoord() {\n    p_state.coord = (p_state.invMatrix * vec4(p_fragCoord, 0.0, 1.0)).xy;\n}\n\nfloat p_step(float edge, float x) {\n    if (p_state.isSmooth) {\n        float hs = p_state.smoothness * 0.5;\n        return smoothstep(edge - hs, edge + hs, x); \n    } else {\n        return step(edge, x);\n    }\n}\n\nfloat p_not(float a) {\n    return 1.0 - a;\n}\n\nfloat p_and(float a, float b) {\n    return a * b;\n}\n\nfloat p_or(float a, float b) {\n    return 1.0 - ((1.0 - a) * (1.0 - b));\n}\n\nfloat p_line(float x, float y, vec2 n, float o) {\n    vec2 pos = vec2(x, y);\n    n = normalize(n);\n    vec2 v = p_state.coord - pos;\n    float dist = dot(n, v);\n    return p_not(p_step(o, dist));\n}\n\nfloat p_cone(float x, float y, float start, float stop, float o) {\n    vec2 vstart = vec2(cos(start), sin(start));\n    vec2 vstop = vec2(cos(stop), sin(stop));\n    \n    vec2 nstart = vec2(vstart.y, -vstart.x);\n    vec2 nstop = vec2(-vstop.y, vstop.x);\n    \n    float coneStart = p_line(x, y, nstart, o);\n    float coneStop = p_line(x, y, nstop, o);\n    float cone = 0.;\n    if (cross(vec3(vstart, 0.), vec3(vstop, 0.)).z > 0.) {\n        cone = p_and(coneStart, coneStop);\n    } else {\n        cone = p_or(coneStart, coneStop);\n    }\n    return cone;\n}\n\nfloat p_circle(float x, float y, float d, float o) {\n    float r = abs(d) * 0.5;\n    float dist = distance(vec2(x, y), p_state.coord);\n    return p_not(p_step(r + o, dist));\n}\n\nfloat p_ellipse(float x, float y, float w, float h, float o) {\n    float hw = abs(w) * 0.5 + o;\n    float hh = abs(h) * 0.5 + o;\n    vec2 dist =  p_state.coord - vec2(x, y);\n    if (hw < hh) {\n        dist.y *= hw / hh;\n        return p_not(p_step(hw, length(dist)));\n    } else {\n        dist.x *= hh / hw;\n        return p_not(p_step(hh, length(dist)));\n    }\n}\n\nfloat p_rect(float x, float y, float w, float h, float o) {\n    if (w < 0.0) {\n        x += w;\n        w *= -1.0;\n    }\n    if (h < 0.0) {\n        y += h;\n        h *= -1.0;\n    }\n    return p_and(p_and(p_step(x - o, p_state.coord.x), \n                       p_not(p_step(x + w + o, p_state.coord.x))),\n                 p_and(p_step(y - o, p_state.coord.y), \n                       p_not(p_step(y + h + o, p_state.coord.y))));\n}\n\n// End of Internal Function\n\n// Constants\n#define HALF_PI 1.57079632679489661923\n#define PI 3.14159265358979323846\n#define QUARTER_PI 0.7853982\n#define TAU 6.28318530717958647693\n#define TWO_PI 6.28318530717958647693\n\n// Constants / angleMode\n#define DEGREES 0\n#define RADIANS 1\n\n// Constants / ellipseMode / rectMode\n#define CENTER 0\n#define RADIUS 1\n#define CORNER 2\n#define CORNERS 3\n\n// Constants /arc\n#define DEFAULT 0\n#define OPEN 1\n#define CHORD 2\n#define PIE 3\n\n\n// Color / Setting\n\nvoid background(vec4 color) {\n    p_pixel(color);\n}\n\nvoid clear() {\n    p_fragColor = vec4(0.0);\n}\n\n// void colorMode\n\nvoid fill(vec4 color) {\n    p_state.isFill = true;\n    p_state.fill = color;\n}\n\nvoid noFill() {\n    p_state.isFill = false;\n}\n\nvoid stroke(vec4 color) {\n    p_state.isStroke = true;\n    p_state.stroke = color;\n}\n\nvoid noStroke() {\n    p_state.isStroke = false;\n}\n\n// Shape / 2D Primitives\n\nvoid arc(float x, float y, float w, float h, float start, float stop, int mode) {\n    if (p_state.ellipseMode == CENTER) {\n        // nothing / default\n    } else if (p_state.ellipseMode == RADIUS) {\n        w *= 2.0;\n        h *= 2.0;\n    } else if (p_state.ellipseMode == CORNER) {\n        x += w * 0.5;\n        y += h * 0.5;\n    } else if (p_state.ellipseMode == CORNERS) {\n        w = w - x;\n        h = h - y;\n        x += w * 0.5;\n        y += h * 0.5;\n    }\n    \n    float fill    = p_ellipse(x, y, w, h, 0.0);\n    float istroke = p_not(p_ellipse(x, y, w, h, -p_state.strokeWeight * 0.5));\n    float ostroke = p_ellipse(x, y, w, h, p_state.strokeWeight * 0.5);\n    \n    vec2 vstart = vec2(cos(start) * w * 0.5, sin(start) * h * 0.5);\n    vec2 vstop = vec2(cos(stop) * w * 0.5, sin(stop) * h * 0.5);\n    start = atan(vstart.y, vstart.x);\n    stop = atan(vstop.y, vstop.x);\n    \n    float sx = x + vstart.x;\n    float sy = y + vstart.y;\n    vec2 v = vstop - vstart;\n    vec2 n = vec2(-v.y, v.x);\n    \n    if (mode == DEFAULT) {\n        float cone = p_cone(x, y, start, stop, 0.);\n        p_fill(p_and(fill, cone));\n        p_stroke(p_and(p_and(istroke, ostroke), cone));\n        \n    } else if (mode == OPEN) {\n        float line = p_line(sx, sy, n, 0.);\n        p_fill(p_and(fill, line));\n        p_stroke(p_and(p_and(istroke, ostroke), line));\n        \n    } else if (mode == CHORD) {\n        float fillLine = p_line(sx, sy, n, 0.);\n        float istrokeLine = p_not(p_line(sx, sy, n, -p_state.strokeWeight * 0.5));\n        float ostrokeLine = p_line(sx, sy, n, p_state.strokeWeight * 0.5);\n        p_fill(p_and(fillLine, fill));\n        p_stroke(p_and(p_or(istroke, istrokeLine), p_and(ostroke, ostrokeLine)));\n        \n    } else if (mode == PIE) {\n        float fillCone = p_cone(x, y, start, stop, 0.);\n        float istrokeCone = p_not(p_cone(x, y, start, stop, -p_state.strokeWeight * 0.5));\n        float ostrokeCone = p_cone(x, y, start, stop, p_state.strokeWeight * 0.5);\n        p_fill(p_and(fill, fillCone));\n        p_stroke(p_and(p_or(istroke, istrokeCone), p_and(ostroke, ostrokeCone)));\n        \n    }\n}\n\nvoid circle(float x, float y, float d) {\n    if (p_state.ellipseMode == CENTER) {\n        // nothing / default\n    } else if (p_state.ellipseMode == RADIUS) {\n        d *= 2.0;\n    } else if (p_state.ellipseMode == CORNER) {\n        x += d * 0.5;\n        y += d * 0.5;\n    }\n    \n    float fill    = p_circle(x, y, d, 0.0);\n    float istroke = 1.0 - p_circle(x, y, d, -p_state.strokeWeight * 0.5);\n    float ostroke = p_circle(x, y, d, p_state.strokeWeight * 0.5);\n    p_fill(fill);\n    p_stroke(p_and(istroke, ostroke));\n}\n\nvoid ellipse(float x, float y, float w, float h) {\n    if (p_state.ellipseMode == CENTER) {\n        // nothing / default\n    } else if (p_state.ellipseMode == RADIUS) {\n        w *= 2.0;\n        h *= 2.0;\n    } else if (p_state.ellipseMode == CORNER) {\n        x += w * 0.5;\n        y += h * 0.5;\n    } else if (p_state.ellipseMode == CORNERS) {\n        w = w - x;\n        h = h - y;\n        x += w * 0.5;\n        y += h * 0.5;\n    }\n    \n    float fill    = p_ellipse(x, y, w, h, 0.0);\n    float istroke = 1.0 - p_ellipse(x, y, w, h, -p_state.strokeWeight * 0.5);\n    float ostroke = p_ellipse(x, y, w, h, p_state.strokeWeight * 0.5);\n    p_fill(fill);\n    p_stroke(p_and(istroke, ostroke));\n}\n\nvoid line(float x1, float y1, float x2, float y2) {\n    vec2 v = vec2(x2 - x1, y2 - y1);\n    vec2 n = vec2(v.y, -v.x);\n    float istroke = 1.0 - p_line(x1, y1, n, -p_state.strokeWeight * 0.5);\n    float ostroke = p_line(x1, y1, n, p_state.strokeWeight * 0.5);\n    float bstroke = p_line(x1, y1, -v, 0.0);\n    float estroke = p_line(x2, y2, v, 0.0);\n    p_stroke(p_and(p_and(istroke, ostroke), p_and(bstroke, estroke)));\n}\n\nvoid point(float x, float y) {\n    float stroke = p_circle(x, y, p_state.strokeWeight, 0.0);\n    p_stroke(stroke);\n}\n\nvoid rect(float x, float y, float w, float h) {\n    if (p_state.rectMode == CORNER) {\n        // nothing / default\n    } else if (p_state.rectMode == CORNERS) {\n        w = w - x;\n        h = h - y;\n    } else if (p_state.rectMode == CENTER) {\n        x -= w * 0.5;\n        y -= h * 0.5;\n    } else if (p_state.rectMode == RADIUS) {\n        x -= w;\n        y -= h;\n        w *= 2.0;\n        h *= 2.0;\n    }\n    \n    float fill    = p_rect(x, y, w, h, 0.0);\n    float istroke = 1.0 - p_rect(x, y, w, h, -p_state.strokeWeight * 0.5);\n    float ostroke = p_rect(x, y, w, h, p_state.strokeWeight * 0.5);\n    p_fill(fill);\n    p_stroke(p_and(istroke, ostroke));\n}\n\n// Shape / Attributes\n\nvoid noSmooth() {\n    p_state.isSmooth = false;\n}\n\nvoid yesSmooth() {\n    p_state.isSmooth = true;\n}\n\nvoid ellipseMode(int mode) {\n    p_state.ellipseMode = mode;\n}\n\nvoid rectMode(int mode) {\n    p_state.rectMode = mode;\n}\n\n// void strokeCap\n\n// void strokeJoin\n\nvoid strokeWeight(float weight) {\n    p_state.strokeWeight = weight;\n}\n\n// Transform\n\nvoid applyInvMatrix(mat4 invMatrix) {\n    p_state.invMatrix = invMatrix * p_state.invMatrix;\n    p_updateCoord();\n}\n\nvoid rotate(float angle) {\n    mat4 im = mat4(1.0);\n    im[0][0] = cos(-angle);\n    im[0][1] = sin(-angle);\n    im[1][0] = -sin(-angle);\n    im[1][1] = cos(-angle);\n    applyInvMatrix(im);\n}\n\nvoid scale(float x, float y) {\n    mat4 im = mat4(1.0);\n    im[0][0] = 1. / x;\n    im[1][1] = 1. / y;\n    applyInvMatrix(im);\n}\n\nvoid translate(float x, float y) {\n    mat4 im = mat4(1.0);\n    im[3][0] = -x;\n    im[3][1] = -y;\n    applyInvMatrix(im);\n}\n\n// Structure\n\nvoid push() {\n    p_states[p_states_length] = p_state;\n    p_states_length++;\n}\n\nvoid pop() {\n    if (p_states_length > 0) {\n        p_states_length--;\n        p_state = p_states[p_states_length];\n    }\n}\n\n// End of Library\n\nvoid draw() {\n    vec4 black   = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 red     = vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 green   = vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 blue    = vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 yellow  = vec4(1.0, 1.0, 0.0, 1.0);\n    vec4 cyan    = vec4(0.0, 1.0, 1.0, 1.0);\n    vec4 magenta = vec4(1.0, 0.0, 1.0, 1.0);\n    vec4 white   = vec4(1.0, 1.0, 1.0, 1.0);\n    \n    clear();\n    background(black);\n    fill(red);\n    stroke(green);\n    strokeWeight(2.0);\n    translate(iMouse.x, iMouse.y);\n    \n    circle(0., 0., 50.);\n    rectMode(CENTER);\n    \n    for (int i=0; i<10; i++) {\n        push();\n        rotate(iTime + float(i));\n        translate(100. + sin(iTime * 5. + float(i) * 2.) * 10., 0.);\n        rect(0., 0., 10., 10.);\n        rotate(iTime * 2.);\n        translate(20., 0.);\n        point(0., 0.);\n        pop();\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    p_state.isSmooth = true;\n    p_state.isFill = false;\n    p_state.fill = vec4(0.0);\n    p_state.isStroke = false;\n    p_state.stroke = vec4(0.0);\n    p_state.strokeWeight = 1.0;\n    p_state.smoothness = 1.0;\n    p_state.ellipseMode = CENTER;\n    p_state.rectMode = CORNER;\n    p_state.invMatrix = mat4(1.0);\n    p_state.coord = fragCoord;\n    \n    p_fragCoord = fragCoord;\n    p_states_length = 0;\n    \n    draw();\n    \n    fragColor = p_fragColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltBBRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[354, 371, 397, 397, 523], [525, 525, 551, 551, 679], [681, 681, 709, 709, 841], [843, 843, 865, 865, 941], [943, 943, 978, 978, 1155], [1157, 1157, 1179, 1179, 1201], [1203, 1203, 1234, 1234, 1254], [1256, 1256, 1286, 1286, 1330], [1332, 1332, 1381, 1381, 1529], [1531, 1531, 1597, 1597, 2082], [2084, 2084, 2136, 2136, 2259], [2261, 2261, 2323, 2323, 2624], [2626, 2626, 2685, 2685, 3054], [3527, 3547, 3576, 3576, 3598], [3600, 3600, 3614, 3614, 3645], [3647, 3666, 3689, 3689, 3744], [3746, 3746, 3761, 3761, 3791], [3793, 3793, 3818, 3818, 3877], [3879, 3879, 3896, 3896, 3928], [3930, 3956, 4037, 4037, 6081], [6083, 6083, 6123, 6123, 6606], [6608, 6608, 6658, 6658, 7302], [7304, 7304, 7355, 7355, 7725], [7727, 7727, 7757, 7757, 7843], [7845, 7845, 7892, 7892, 8503], [8505, 8528, 8545, 8545, 8577], [8579, 8579, 8597, 8597, 8628], [8630, 8630, 8658, 8658, 8692], [8694, 8694, 8719, 8719, 8750], [8771, 8791, 8824, 8824, 8861], [8863, 8877, 8914, 8914, 8992], [8994, 8994, 9020, 9020, 9184], [9186, 9186, 9216, 9216, 9313], [9315, 9315, 9349, 9349, 9438], [9440, 9454, 9467, 9467, 9533], [9535, 9535, 9547, 9547, 9658], [9660, 9679, 9692, 9692, 10526], [10528, 10528, 10585, 10585, 11039]], "test": "untested"}
{"id": "ltfBDl", "name": "City Fractal", "author": "TekF", "description": "A spiritual successor to my old infinite city, but based on a fractal pattern.\nHere's a map of the city: https://twitter.com/TekF/status/943940594254139393", "tags": ["fractalcityraymarch"], "likes": 20, "viewed": 810, "published": "Public API", "date": "1513983522", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// City Fractal\n// By Hazel Quantock\n\n// disable this if running at high resolution\n#define ANTIALIASING 1\n\n// enable this to smooth out the frame rate (this seems to work better in Chrome than Firefox)\n//#define FPS30 1\n\n// ray march distance multiplier, use range 1-10\n#define DRAWDIST 10\n\n#define WIDESCREEN 1\n#define POSTPROCESS 1\n\n\nuint Hash( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uint k = n * n * n * 48271U;\n    return k & 0xffffffffU;\n}\n\n\nconst float roadRad = .2;\n\n// buildings: x = horizontal distance, y = vertical distance\nvec2 Buildings( vec2 uv )\n{\n//    uv -= .05; // make thick & thin roads\n    uv -= .5; // less repetetive buildings! (nice)\n    \n    uvec2 iuv = uvec2(abs(uv));\n    \n    // DAMMIT! They're all the same building!\n    // can skip the wrap in the last stage, but it's only 1.68 smaller than the next wrap\n    // so we get 2x2 blocks of buildings, of 2 (maybe 4) different heights\n    uint seed = Hash(iuv.x+(iuv.y<<8U));\n    float h = float(seed&0xffffffU)/float(0xffffffU);\n    \n    // => most buildings have a mirror running through them, so I need a mirror that syncs seeds for straddling buildings\n/* e.g: 3D \"buildings\" pattern, reflection = 90 degree rotation...\n=> won't get same angle both sides => will slice through buildings into the ground\nWhich will break the SDFs (creating flat spots and shallower gradients - fairly safe but annoying)\n*/    \n/*\nIt would be easy if we were spawning (not just pickig) tiles\neach tile could check its already picked neighbours so would never create invalid transition\nthough obviously wouldn't be deterministic\n*/\n/*\nI wonder if there's something we can do by colouring in an intermediate buffer...\n*/\n    \n    vec2 d = abs(fract(uv)-.5)-(.5-roadRad);\n    float f = max(d.x,d.y);\n    if ( f > .0 ) f = length(max(d,0.));\n    \n    return vec2(f,h);\n}\n\n// tiled reflection - repeat [0,1] on x & y\nvec2 Wrap( vec2 uv )\n{\n    // 0,1,0,1,0,1,0,1 triangle wave\n//    return abs(mod(uv-.5,2.)-1.)-.5;\n    // allow precession whilst also partly wrapping\n    //0,1,2,1,2,3,2,3,4,3,4,5 - 1:1 gradient so scale isn't affected\n    vec2 fl = floor(uv/3.);\n    vec2 fr = uv-3.*fl;\n    return fl + min(fr,4.-fr);\n}\n\nvec2 Rot( vec2 uv, float a )\n{\n    return uv*cos(a) + uv.yx*vec2(1,-1)*sin(a);\n}\n\n\nvec2 Map( vec2 uv )\n{\n    int n = 4; // lower = cheaper\n    float a = 1.275;\n    float s = 4.1;\n    \n    // adjust our view\n    //uv *= exp(-sin(iTime/3.)+1.);\n    //uv += vec2(.618,.382)*.1*iTime;\n    float scale = 3.;\n\tuv /= scale * pow(s,float(n)); // mul by all the scales we'll accumulate in the loop\n    uv = Rot(uv,.5-a);\n    \n\tfor ( int i=0; i < n; i++ )\n    {\n        //uv += -.07;\n        uv *= s;\n\t    uv = Rot(uv,a);\n        uv = Wrap(uv);\n    }\n    \n    vec2 d = Buildings( uv ); // .5/.0 look okay, other values mess up roads (but .05 gives thick & thin roads\n    d.x *= scale;\n    return d;\n}\n\n\nfloat SDF( vec3 pos )\n{\n    vec2 d = Map(pos.xz);\n    \n    const float minH = .3;\n    const float houseH = 2. - minH;\n    const float scraperH = 6. - houseH;\n    const float maxH = minH+houseH+scraperH;\n    float h = d.y*houseH + pow(d.y,20.)*scraperH + minH;\n    if ( d.y < .1 ) h = 0.; // parks\n    \n    // need to constrain the gradient - because we don't know how tall adjacent buildings are\n    // but this confuses the ambient occlusion, making roofs a bit darker\n    float roof = min( pos.y-h, roadRad*2. );\n    \n    float sdf = max( d.x, roof );\n    \n    // floor\n    sdf = min( sdf, pos.y );\n    \n    sdf = max( sdf, pos.y-maxH ); // max h, let it ramp up above roadRad so the sky looks good\n    \n    return sdf;\n}\n\n\nvec3 mainImage2( vec2 fragCoord )\n{\n    vec3 colour;\n    \n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.x;\n\n#if defined(WIDESCREEN)\n    float sh = iResolution.x/2.4;\n#else\n    float sh = iResolution.y;\n#endif\n\tvec3 ray = normalize(vec3((fragCoord-iResolution.xy*.5)/sh,2.+smoothstep(.1,.4,sin(iTime/8.))));\n    \n    vec2 a = vec2(.29,iTime/50.);\n    ray.zy = ray.zy*cos(a.x)+ray.yz*sin(a.x)*vec2(1,-1);\n    ray.xz = ray.xz*cos(a.y)+ray.zx*sin(a.y)*vec2(1,-1);\n    \n    vec3 pos = vec3(iTime*3.,15,sin(iTime/20.)*100.)+vec3(-20,0,-70);\n/*\tvec3 ray = normalize(vec3((fragCoord-iResolution.xy*.5)/iResolution.y,5.));\n    \n    vec2 a = vec2(.16+.02*sin(iTime*.5),.3+.05*sin(iTime*.2));\n    ray.zy = ray.zy*cos(a.x)+ray.yz*sin(a.x)*vec2(1,-1);\n    ray.xz = ray.xz*cos(a.y)+ray.zx*sin(a.y)*vec2(1,-1);\n    \n    vec3 pos = vec3(iTime*5.,12.+sin(iTime*.3),sin(iTime*.21)*5.);*/\n\n    \n    float t = 0.;\n    float h = 1.;\n    for ( int i=0; i < 50*DRAWDIST; i++ ) // this increases the quality of the horizon\n    {\n        h = SDF(pos+t*ray);\n        t += h;\n        if ( h < .001 ) break;\n    }\n    \n   \tpos += t*ray;\n\n    if ( h < .1 )\n    {\n        vec2 d = vec2(-1,1)*.02;\n        vec3 grad = SDF(pos+d.xxx)/d.xxx+\n                    SDF(pos+d.xyy)/d.xyy+\n                    SDF(pos+d.yxy)/d.yxy+\n                    SDF(pos+d.yyx)/d.yyx;\n        vec3 n = normalize(grad);\n\n        float ao = //smoothstep(-1.,1.,max(pos.y,Map(pos.xz).x))\n                   1.-.7*clamp( pow( max(.0,1.-mix( SDF(pos+n*1.5)/1.5, SDF(pos+n*.4)/.4, .2 )), 2. ), .0, 1. );\n        vec3 ambient = vec3(.2,.3,.5) * ao;\n            \t\t\n        vec3 sunDir = normalize(vec3(-3,1,-2));\n        vec3 sun = vec3(2,1.8,1.6)*max(.0,dot(n,sunDir));\n\n        float ts = .013 *.01/(SDF(pos+sunDir*.01)); // correct by actual gradient!)\n        float hs = 1.;\n        for ( int i=0; i < 10*DRAWDIST; i++ ) // keep this number as low as I can get away with\n        {\n            hs = SDF(pos+ts*sunDir);\n            ts += hs;\n            if ( hs < .01 ) break;\n        }\n        // sun shadow\n        if ( hs < .01 ) sun *= 0.;\n\n        vec2 map = Map(pos.xz);\n        \n        // building colour\n        vec3 paint = fract(map.y*161.8f*vec3(1.,7.,49.)); // pseudo random\n        vec3 albedo = mix( pow(paint*vec3(1,1,.9),vec3(8.)), vec3(.2), .8 ); // tone it down\n        \n        // road colour\n        vec3 road = mix( vec3(.25), vec3(.1), smoothstep(.23,.24,map.x) );\n        road = mix( paint*.1+vec3(.1,.2,.0), road, smoothstep(-.3,.0,map.x) );\n        //road = mix( road, vec3(.8), smoothstep(.015,.005,abs(map.x-.58)) ); // these are nice but they make the buildings look worse by comparison\n        //road = mix( road, vec3(1,.9,0), smoothstep(.015,.005,abs(map.x-.27)) );\n        albedo = mix( road, albedo, smoothstep(.0,.01,pos.y) );\n        \n        colour.rgb = albedo*(ambient+sun);\n    }\n    else\n    {\n        colour.rgb = vec3(.1);\n    }\n    \n\t// atmosphere\n    colour.rgb = mix(vec3(.5,.75,1.),colour.rgb,exp2(-t*vec3(.1,.3,1.)/500.));\n    \n    return colour;\n}\n\n\nvoid mainImage( out vec4 colour, in vec2 fragCoord )\n{\n#if defined( WIDESCREEN )\n    if ( abs(fragCoord.y-iResolution.y*.5) > .5*iResolution.x/2.4 )\n    {\n        colour = vec4(0);\n        return;\n    }\n#endif\n    \n#if defined( FPS30 )\n    if ( (iFrame&1) != 0 ) discard; // run at 30fps - use this if frame rate is bad\n#endif\n    \n#if defined( ANTIALIASING ) // better quality, good for video capture\n    // rotated grid AA - really breaks up the straight lines\n    colour.rgb = (\n\t\tmainImage2(fragCoord+vec2(-3,-1)/8.) +\n\t\tmainImage2(fragCoord+vec2(-1, 3)/8.) +\n\t\tmainImage2(fragCoord+vec2( 1,-3)/8.) +\n\t\tmainImage2(fragCoord+vec2( 3, 1)/8.)\n        )/4.;\n#else\n    colour.rgb = mainImage2(fragCoord);\n#endif\n    \n#if defined(POSTPROCESS)\n#if defined(WIDESCREEN)\n    float sh = iResolution.x/2.4;\n#else\n    float sh = iResolution.y;\n#endif\n\n\t// vignette\n\tcolour.rgb *= smoothstep(1.6,.4,length((fragCoord-iResolution.xy*.5)/sh));\n\t\n\t// contrast\n\tcolour.rgb *= 1.5;\n\tfloat grey = dot(colour.rgb,vec3(.2126,.7152,.0722));\n\tfloat bottom = .03;\n\tcolour.rgb *= (sqrt(grey*grey+bottom*bottom)-bottom)/grey; // squash dark tones together to increase contrast\n#endif\n    \n    colour.rgb = pow(colour.rgb,vec3(.4545));\n    \n    colour.a = 1.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltfBDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[222, 337, 359, 402, 540], [570, 631, 658, 702, 1923], [1925, 1969, 1991, 2188, 2273], [2275, 2275, 2305, 2305, 2355], [2358, 2358, 2379, 2379, 2965], [2968, 2968, 2991, 2991, 3691], [3694, 3694, 3729, 3729, 6748], [6751, 6751, 6805, 6805, 7988]], "test": "untested"}
{"id": "ltfBzf", "name": "Franky and the Drakettes", "author": "dr2", "description": "Captain Francis Drake sailing to meet the Armada", "tags": ["sea", "clouds", "duck", "ship"], "likes": 13, "viewed": 677, "published": "Public API", "date": "1512667619", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Franky and the Drakettes\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Captain Francis Drake sailing to meet the Armada.\n  Mouseable; god-ray idea from frankenburgh's \"Oceanic\".\n*/\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, dukConf, qHit, dispCloud;\nvec2 gId;\nfloat tCur, dstFarO, dstFarW, dstWat, szFac;\nint idObj;\nconst float pi = 3.14159;\nconst float sqrt3 = 1.7320508;\nconst int idBdy = 1, idWng = 2, idHead = 3, idBk = 4, idMast = 5, idSail = 6;\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  vec4 t4, v4;\n  vec2 q, t, tw;\n  float wFreq, wAmp, h;\n  q = 0.5 * p - vec2 (0., tCur);\n  h = 0.3 * sin (q.y) + 0.25 * sin (dot (q, vec2 (0.1, 1.2))) +\n     0.2 * sin (dot (q, vec2 (-0.2, 1.4)));\n  q = p;\n  wFreq = 0.5;\n  wAmp = 0.03;\n  tw = 0.1 * tCur * vec2 (1., -1.);\n  for (int j = 0; j < 4; j ++) {\n    q *= qRot;\n    t4 = q.xyxy * wFreq + tw.xxyy;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    v4 = (1. - abs (sin (t4))) * (abs (sin (t4)) + abs (cos (t4)));\n    t = 1. - sqrt (v4.xz * v4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return h;\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFarW;\n  for (int j = 0; j < 50; j ++) {\n    p = ro + s * rd;\n    h = p.y - WaveHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (6., h);\n    if (s > dstFarW) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 6; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - WaveHt (p.xz));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e;\n  e = vec2 (max (0.1, 5e-5 * d * d), 0.);\n  return normalize (vec3 (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy), WaveHt (p.xz + e.yx)), e.x).xzy);\n}\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 r, cs;\n  float dMin, d, s;\n  p.xz -= HexToPix (gId);\n  p.y -= dukConf.x - 0.02 * szFac;\n  p.yz = Rot2D (p.yz, -3. * dukConf.z);\n  p.xy = Rot2D (p.xy, 10. * dukConf.y);\n  dMin = dstFarO / szFac;\n  p /= szFac;\n  q = p;\n  r = vec2 (0.04, 0.06 + 0.01 * clamp (q.z, -0.4, 0.4));\n  s = (length (q.xz / r) - 1.) * min (r.x, r.y);\n  d = min (max (s, abs (q.y) - 0.1), length (vec2 (s, q.y)) - 0.1);\n  DMINQ (idBdy);\n  q = p;  q.x = abs (q.x);  q -= vec3 (0.1, 0.06, 0.12);\n  cs = vec2 (cos (0.3), sin (0.3));\n  q.yz = Rot2Cs (q.yz, cs);\n  cs.y = - cs.y;\n  q.xy = Rot2Cs (q.xy, cs);\n  q.xz = Rot2Cs (q.xz, cs);\n  q = q.yxz;\n  r = vec2 (0.06, 0.1 + 0.016 * clamp (q.z, -0.4, 0.4));\n  s = (length (q.xz / r) - 1.) * min (r.x, r.y);\n  d = min (max (s, abs (q.y) - 0.014), length (vec2 (s, q.y)) - 0.014);\n  DMINQ (idWng);\n  q = p;  q.yz -= vec2 (0.15, -0.08);\n  d = PrEllipsDf (q, vec3 (0.08, 0.07, 0.1));\n  DMINQ (idHead);\n  q = p;  q.yz -= vec2 (0.14, -0.19);\n  d = PrEllCylDf (q, vec2 (0.03, 0.008), 0.02);\n  DMIN (idBk);\n  q = p;\n  d = min (PrCylDf ((q - vec3 (0., 0.25, 0.06)).xzy, 0.007, 0.25),\n     PrCylDf (vec3 (q.x, abs (q.y - 0.33) - 0.1, q.z - 0.055).yzx, 0.006, 0.155));\n  DMIN (idMast);\n  q = p;  q.y -= 0.33;  q.z -= 3. * q.y * q.y + 0.025;\n  d = max (length (max (abs (q) - vec3 (0.15, 0.1, 0.003), 0.)),\n     0.2 - length (q.xy + vec2 (0., 0.25)));\n  DMINQ (idSail);\n  return 0.9 * dMin * szFac;\n}\n\nvoid EvalDukConf ()\n{\n  vec4 ht;\n  vec2 e, g;\n  float s;\n  s = length (vec3 (gId.xy, gId.x + gId.y));\n  if (s == 0.) szFac = 3.;\n  else if (s <= 2.) szFac = 2.2;\n  else szFac = 1.5;\n  e = vec2 (0.1 * szFac, 0.);\n  g = HexToPix (gId);\n  ht = vec4 (WaveHt (g - e), WaveHt (g + e), WaveHt (g - e.yx), WaveHt (g + e.yx));\n  dukConf = vec3 (0.25 * dot (ht, vec4 (1.)) + 0.1 * (Hashfv2 (17. * gId) - 0.5),\n     vec2 (ht.xz - ht.yw));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = 1. / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = (sqrt3/2.) - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2]));\n  pM = HexToPix (PixToHex (ro.xz));\n  gIdP = vec2 (-99.);\n  eps = 0.0005;\n  dHit = eps;\n  for (int j = 0; j < 150; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = min (hv.x, min (hv.y, hv.z));\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz);\n    if (length (vec3 (gId.xy, gId.x + gId.y)) <= 5.) {\n      if (gId.x != gIdP.x || gId.y != gIdP.y) {\n        EvalDukConf ();\n        gIdP = gId;\n      }\n      d = ObjDf (p);\n    } else d = dstFarO;\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + 0.01;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFarO) break;\n  }\n  if (d >= eps) dHit = dstFarO;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0005, -0.0005);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec4 ObjCol ()\n{\n  vec4 col4;\n  vec4 cBdy;\n  float s;\n  s = length (vec3 (gId.xy, gId.x + gId.y));\n  if (s == 0.) cBdy = vec4 (1., 1., 0.1, 0.3);\n  else if (s <= 2.) cBdy = vec4 (0.9, 0.9, 1., 0.3);\n  else cBdy = vec4 (0.8, 0.4, 0.2, 0.3);\n  if (idObj == idBdy) {\n    col4 = cBdy * (1. - smoothstep (0.02, 0.06, qHit.y) *\n       smoothstep (0., 0.14, qHit.z) * 0.1 * SmoothBump (0.3, 0.5, 0.05,\n       mod (50. * qHit.x, 1.)));\n  } else if (idObj == idWng) {\n    col4 = cBdy * (1. - step (0.004, qHit.y) *\n       smoothstep (0., 0.04, qHit.z) * 0.2 * SmoothBump (0.3, 0.5, 0.05,\n       mod (100. * qHit.x, 1.)));\n  } else if (idObj == idHead) {\n    s = length (qHit.yz - vec2 (0.02, -0.05));\n    if (s > 0.02) col4 = cBdy;\n    else col4 = (abs (s - 0.01) < 0.003) ? vec4 (1., 1., 1., 0.3) : vec4 (0.3, 0.3, 1., 0.1);\n  } else if (idObj == idBk) {\n    col4 = vec4 (1., 0.5, 0., 0.2);\n  } else if (idObj == idMast) {\n    col4 = vec4 (0.6, 0.3, 0., 0.);\n  } else if (idObj == idSail) {\n    col4 = vec4 (1.1, 1.1, 1.1, 0.) * (0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.03, mod (16. * qHit.x, 1.)));\n  }\n  return col4;\n}\n\nvec3 CloudCol (vec3 ro, vec3 rd)\n{\n  vec4 cSum, c;\n  vec3 s1, s2;\n  float sd, t;\n  s1 = 0.003 * (ro + dispCloud + rd * (300. - ro.y) / rd.y);\n  s2 = 0.003 * (rd * 10. / rd.y);\n  cSum = vec4 (0.);\n  for (float ns = 0.; ns < 100.; ns ++) {\n    c.a = 0.8 * smoothstep (0.5, 1., Fbm3 (s1 + s2 * ns));\n    c = vec4 (1., 0.95, 0.9, c.a) - vec4 (0.7, 0.65, 0.7, cSum.a) * c.a;\n    cSum += vec4 (c.rgb * c.a, c.a);\n    if (cSum.a > 0.99) break;\n  }\n  cSum.rgb /= cSum.a + 0.001;\n  sd = max (dot (rd, sunDir), 0.);\n  cSum.rgb += vec3 (0.5) * mix (pow (sd, 4.), - pow (sd, 16.), smoothstep (0.8, 1., cSum.a));\n  t = pow (1. - 0.7 * rd.y, 16.);\n  return mix (vec3 (0.05, 0.2, 0.5) + t * vec3 (0.45, 0.4, 0.3) +\n     0.3 * vec3 (1., 0.9, 0.8) * (pow (sd, 2.) + 4. * pow (sd, 256.)), cSum.rgb, cSum.a * (1. - t));\n}\n\nfloat CloudDens (vec3 ro, vec3 rd)\n{\n  vec3 s1, s2;\n  float attSum;\n  s1 = 0.003 * (ro + dispCloud + rd * (300. - ro.y) / rd.y);\n  s2 = 0.003 * (rd * 10. / rd.y);\n  attSum = 0.;\n  for (float ns = 0.; ns < 100.; ns += 10.) {\n    attSum += 0.8 * (1. - attSum) * smoothstep (0.5, 1., Fbm3 (s1 + s2 * ns));\n    if (attSum > 0.99) break;\n  }\n  return clamp (1. - attSum, 0., 1.);\n}\n\nfloat GRayDens (vec3 ro, vec3 rd)\n{\n  vec3 p, s1, s2;\n  float d, sd, gDens;\n  sd = 0.08 * max (dot (rd, sunDir), 0.);\n  gDens = 0.;\n  if (sd > 0.01) {\n    s1 = ro + 200. * rd;\n    s2 = 40. * rd;\n    for (float ns = 0.; ns < 32.; ns ++) {\n      p = s1 + s2 * ns;\n      gDens += sd * (1. - gDens) * smoothstep (0.8, 1., CloudDens (p, sunDir));\n      if (p.y > 400. || gDens > 0.95) break;\n    }\n  }\n  return gDens;\n}\n\nvec3 WaveCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd;\n  sd = max (dot (rd, sunDir), 0.);\n  col = vec3 (0.15, 0.2, 0.2) * (0.7 * ro.y + 1.) +\n     CloudDens (ro + 300. * rd, rd) * (mix (vec3 (0., 0.1, 0.2), vec3 (0.2, 0.2, 0.3), rd.y) +\n     (1. - rd.y) * vec3 (0.6, 0.6, 0.5) * (pow (sd, 4.) + 2. * pow (sd, 256.)));\n  col *= 0.7 + 0.3 * pow (max (dot (rd, sunDir), 0.), 2.);\n  col = mix (col, vec3 (0.6, 0.8, 0.9) + vec3 (0.2, 0.2, 0.1) * pow (sd, 4.),\n     1. - exp (- pow (0.005 * dstWat, 1.5)));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 col, colW, roo, rdo, vn, ltDir;\n  float dstObj, reflFac;\n  ltDir = normalize (vec3 (1., 1., -1.));\n  dispCloud = vec3 (0., 0., -40. * tCur);\n  roo = ro;\n  rdo = rd;\n  reflFac = 1.;\n  col = vec3 (0.);\n  if (rd.y < 0.) dstWat = WaveRay (ro, rd);\n  else dstWat = dstFarW;\n  dstObj = ObjRay (ro, rd);\n  if (dstWat < min (dstObj, dstFarW)) {\n    ro += dstWat * rd;\n    rd = reflect (rd, VaryNf (ro, WaveNf (ro, dstWat), 0.1));\n    dstObj = ObjRay (ro, rd);\n    reflFac = 0.5;\n  }\n  if (dstObj < dstFarO) {\n    ro += dstObj * rd;\n    EvalDukConf ();\n    objCol = ObjCol ();\n    vn = ObjNf (ro);\n    col = objCol.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       objCol.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 128.);\n  } else if (dstWat < dstFarW) {\n    reflFac = 0.;\n  } else {\n    col = CloudCol (roo, rdo) + 0.9 * vec3 (1., 0.8, 0.6) * GRayDens (roo, rdo);\n  }\n  if (reflFac < 1.) {\n    roo += dstWat * rdo;\n    col = mix (WaveCol (roo, reflect (rdo, VaryNf (32. * roo, WaveNf (roo, dstWat), 0.05))),\n       col, reflFac);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, u;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, f;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  ro = vec3 (3., 5., -20.);\n  zmFac = 2.4;\n  if (mPtr.z > 0.) {\n    ro.x += 10. * mPtr.x;\n    zmFac += 1.5 * (mPtr.y + 0.5);\n  }\n  vd = normalize (vec3 (0., 2., 0.) - ro);\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  sunDir = normalize (vec3 (0.5, 0.25, 1.));\n  dstFarO = 30.;\n  dstFarW = 300.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltfBzf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[132, 886, 909, 909, 1580], [1582, 1582, 1616, 1616, 2134], [2136, 2136, 2167, 2167, 2325], [2456, 2456, 2478, 2478, 3898], [3900, 3900, 3921, 3921, 4329], [4331, 4331, 4364, 4364, 5533], [5535, 5535, 5556, 5556, 5756], [5758, 5758, 5774, 5774, 6866], [6868, 6868, 6902, 6902, 7670], [7672, 7672, 7708, 7708, 8048], [8050, 8050, 8085, 8085, 8464], [8466, 8466, 8499, 8499, 8985], [8987, 8987, 9022, 9022, 10117], [10119, 10119, 10175, 10175, 10929], [10931, 10931, 10973, 10973, 11024], [11026, 11026, 11061, 11061, 11123], [11125, 11125, 11169, 11169, 11244], [11246, 11246, 11270, 11270, 11500], [11502, 11502, 11526, 11526, 11586], [11588, 11588, 11645, 11645, 11728], [11730, 11730, 11760, 11760, 11818], [11820, 11820, 11851, 11851, 11915], [11949, 11949, 11973, 11973, 12033], [12035, 12035, 12059, 12059, 12189], [12191, 12191, 12215, 12215, 12435], [12437, 12437, 12462, 12462, 12648], [12650, 12650, 12675, 12675, 12900], [12902, 12902, 12923, 12923, 13078], [13080, 13080, 13109, 13109, 13321], [13323, 13323, 13362, 13362, 13546]], "test": "untested"}
{"id": "ltffzB", "name": "Endless Engines", "author": "dr2", "description": "Lots of power (mouseable - click in lower-right corner for color image or upper-right for\n color-coded raymarch step count)", "tags": ["machine", "cellmarching"], "likes": 29, "viewed": 805, "published": "Public API", "date": "1512291462", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Endless Engines\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\nfloat RgbToVal (vec3 c);\nfloat Hashfv3 (vec3 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 bSize, qHit, cId;\nvec2 aCs[3], crCs[3], crMid[3];\nfloat tCur, dstFar, crRad, crLen, aRot, stepCnt;\nint idObj;\nbool colImg, marchImg;\nconst float pi = 3.14159;\nconst int idWhl = 1, idSpk = 2, idCrnk = 3, idAx = 4, idPis = 5, idCrod = 6, idCyl = 7,\n   idCylEnt = 8, idValv = 9, idPipes = 10, idSup = 11, idBase = 12, idFlr = 13, idCol = 14,\n   idRail = 15, idLt = 16;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat HallDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  d = max (0.5 * bSize.y - 0.4 - abs (q.y),\n    - PrBox2Df (vec2 (q.x, abs (q.z) - 0.5 * bSize.z), vec2 (16., 8.)));\n  DMINQ (idFlr);\n  d = length (abs (q.xz) - vec2 (16.6, 11.9)) - 0.6;\n  DMIN (idCol);\n  q = p;  q.z = abs (q.z) - 11.8;  q.y -= -4.6;\n  d = min (min (PrCylDf (q.zyx, 0.15, 16.1),\n     PrCylDf (vec3 (abs (abs (q.x) - 7.) - 3.5, q.y + 2.5, q.z).xzy, 0.1, 2.5)),\n     PrCylDf (vec3 (q.x, abs (q.y + 2.5) - 1., q.z).zyx, 0.1, 16.1));\n  q = p;  q.xz = abs (q.xz) - vec2 (16.4, 19.4);  q.y -= -4.6;\n  d = min (d, min (min (PrCylDf (q, 0.15, 7.7),\n     PrCylDf (vec3 (q.x, q.y + 2.5, abs (q.z) - 2.).xzy, 0.1, 2.5)),\n     PrCylDf (vec3 (q.x, abs (q.y + 2.5) - 1., q.z), 0.1, 7.7)));\n  DMIN (idRail);\n  q = p;  q.xz = abs (q.xz);  q -= vec3 (6., 9.6, 6.);\n  d = PrCylDf (q.xzy, 2., 0.2);\n  DMINQ (idLt);\n  return dMin;\n}\n\nfloat CrnkDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, dz;\n  for (int k = 0; k < 3; k ++) {\n    dz = float (k - 1) * 4.;\n    q = p;  q.x -= 8.;\n    q.xy = Rot2Cs (q.xy, aCs[k]);\n    q.z += dz;\n    d = min (PrBoxDf (vec3 (q.x + 0.5 * crRad, q.y, abs (q.z) - 0.5), vec3 (0.5 * crRad, 0.2, 0.1)),\n       PrCylDf (vec3 (abs (q.x + 0.5 * crRad) - 0.5 * crRad, q.y, abs (q.z) - 0.5), 0.6, 0.1));\n    DMIN (idCrnk);\n    d = PrCylDf (vec3 (q.x + crRad, q.yz), 0.3, 0.65);\n    DMIN (idAx);\n    q = p;  q.xz -= vec2 (8., - dz);\n    q.xy = Rot2Cs (q.xy + crMid[k], crCs[k]);\n    d = min (PrCylDf (vec3 (abs (q.y) - 0.12, q.zx), 0.15, crLen - 0.5),\n       PrCylDf (vec3 (abs (q.x) - crLen, q.yz), 0.6, 0.15));\n    DMIN (idCrod);\n    q = p;  q.xz -= vec2 (3.5 - (crMid[k].x + crLen * crCs[k].x), - dz);\n    d = PrCylDf (q.yzx, 0.25, 3.7);\n    DMIN (idPis);\n    d = PrCylDf ((q - vec3 (0.7, 1.7, 0.)).yzx, 0.07, 3.);\n    DMIN (idPis);\n    q.x -= 4.5;\n    d = PrCylDf (q, 0.3, 0.5);\n    DMIN (idAx);\n    d = min (min (PrCylDf ((q + vec3 (0.8, 0., 0.)).yzx, 0.6, 0.13),\n       PrCylDf ((q + vec3 (0.8, -0.8, 0.)).xzy, 0.08, 0.95)),\n       PrCylDf (vec3 (q.xy, abs (q.z) - 0.35), 0.7, 0.1));\n    DMIN (idCrnk);\n  }\n  return dMin;\n}\n\nfloat EngDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  p.y += 4.6;\n  d = min (PrBoxDf (p + vec3 (0., 4., 0.), vec3 (13., 1., 6.)),\n     PrBoxDf (vec3 (abs (p.x + 9.) - 2., p.y + 2.5, p.z), vec3 (1., 1.4, 5.)));\n  DMIN (idBase);\n  q = p;  q.x -= 8.;\n  q.xy = Rot2Cs (q.xy, aCs[0]);\n  q.z = abs (q.z) - 7.;\n  d = min (PrCylAnDf (q, 4., 0.2, 0.6), PrCylDf (q, 0.6, 0.6));\n  DMINQ (idWhl);\n  q.xy = Rot2D (q.xy, 2. * pi * (floor (6. * atan (q.y, - q.x) / (2. * pi) + 0.5)) / 6.);\n  d = PrCylDf (vec3 (q.x + 2.2, q.y, abs (q.z) - 0.35).zyx, 0.2, 1.7);\n  DMIN (idSpk);\n  d = max (PrCylDf (p - vec3 (8., 0., 0.), 0.3, 7.8), min (0.35 - abs (mod (p.z + 2., 4.) - 2.),\n     6. - abs (p.z)));\n  DMIN (idAx);\n  dMin = CrnkDf (p, dMin);\n  q = p;  q.x -= -8.9;  q.z = mod (q.z + 2., 4.) - 2.;\n  d = max (PrCylDf ((q + vec3 (-3.5, 0., 0.)).yzx, 0.7, 0.2), abs (p.z) - 6.);\n  DMINQ (idCylEnt);\n  d = max (PrCylDf (q.yzx, 1.5, 3.5), abs (p.z) - 6.);\n  DMINQ (idCyl);\n  q = p + vec3 (8.9, -1.7, 0.);  q.z = mod (q.z + 2., 4.) - 2.;\n  d = max (PrCylDf (q.yzx, 0.5, 2.5), abs (p.z) - 6.);\n  DMINQ (idValv);\n  q = vec3 (abs (p.x + 8.9) - 1.5, p.y - 2.5, p.z);\n  d = min (min (max (PrCylDf ((vec3 (q.x, q.y, mod (q.z + 2., 4.) - 2.)).xzy, 0.35, 1.25),\n     abs (p.z) - 6.), PrCylDf (vec3 (q.x, q.y - 1.3, q.z), 0.35, 4.)),\n     PrSphDf (vec3 (q.x, q.y - 1.3, abs (q.z) - 4.), 0.35));\n  q = p + vec3 (8.9, -6.3, 0.);\n  d = min (d, min (PrCylDf ((q + vec3 (-1.5, 0., 2.)).xzy, 0.35, 2.5),\n     PrCylDf ((q + vec3 (1.5, 0., -2.)).xzy, 0.35, 2.5)));\n  d = min (d, length (vec2 (abs (q.x) - 1.5, q.y - 2.5)) - 0.4);\n  DMIN (idPipes);\n  q = p;  q.x -= 8.;  q.z = abs (abs (p.z) - 4.) - 1.7;\n  d = min (PrBoxDf (q + vec3 (0., 1.6, 0.), vec3 (0.5, 1.5, 0.2)), PrCylDf (q, 0.5, 0.3));\n  DMIN (idSup);\n  q = p + vec3 (-8., -1.8, -2.3);\n  d = PrCylDf ((q + vec3 (0., 0.6, 0.)).xzy, 0.12, 0.8);\n  q.xz = Rot2D (q.xz, 4. * aRot);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * atan (q.z, - q.x) / (2. * pi) + 0.5)) / 4.);\n  q.xy = Rot2D (q.xy, -0.25 * pi);\n  d = min (d, PrCylDf ((q + vec3 (0.4, -0.1, 0.)).yzx, 0.05, 0.4));\n  DMIN (idAx);\n  d = PrSphDf (q + vec3 (0.7, -0.1, 0.), 0.15);\n  DMIN (idPis);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  dMin = HallDf (p, dMin);\n  dMin = EngDf (p, dMin);\n  return dMin;\n}\n\nvoid SetEngConf ()\n{\n  aRot = -(0.1 + 0.3 * Hashfv3 (cId + 11.)) * 2. * pi * tCur;\n  aCs[0] = vec2 (cos (aRot), sin (aRot));\n  aCs[1] = vec2 (cos (aRot + pi * 2./3.), sin (aRot + pi * 2./3.));\n  aCs[2] = vec2 (cos (aRot + pi * 4./3.), sin (aRot + pi * 4./3.));\n  for (int k = 0; k < 3; k ++) {\n    crMid[k].y = -0.5 * crRad * aCs[k].y;\n    crCs[k] = vec2 (cos (asin (crMid[k].y / crLen)), crMid[k].y / crLen);\n    crMid[k].x = crLen * crCs[k].x + crRad * aCs[k].x;\n  }\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi, s, cIdP;\n  float dHit, d, eps;\n  eps = 0.0005;\n  dHit = eps;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  ro /= bSize;\n  rd /= bSize;\n  rdi = 1. / rd;\n  cIdP = vec3 (-99.);\n  stepCnt = 0.;\n  for (int j = 0; j < 180; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p);\n    if (cId.x != cIdP.x || cId.y != cIdP.y || cId.z != cIdP.z) {\n      SetEngConf ();\n      cIdP = cId;\n    }\n    s = (cId + step (0., rd) - p) * rdi;\n    d = min (ObjDf (bSize * (p - cId - 0.5)), abs (min (min (s.x, s.z), s.y)) + eps);\n    dHit += d;\n    ++ stepCnt;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0005, -0.0005);\n  p -= bSize * (cId + 0.5);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p, cIdP;\n  float sh, d, h;\n  sh = 1.;\n  cIdP = vec3 (-99.);\n  d = 0.1;\n  for (int j = 0; j < 16; j ++) {\n    p = ro + d * rd;\n    cId = floor (p / bSize);\n    if (cId.x != cIdP.x || cId.y != cIdP.y || cId.z != cIdP.z) {\n      SetEngConf ();\n      cIdP = cId;\n    }\n    h = ObjDf (p - bSize * (cId + 0.5));\n    sh = min (sh, smoothstep (0., 0.1 * d, h));\n    d += 0.3;\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nvec3 ShGrid (vec2 p)\n{\n  vec2 q, sq, ss;\n  q = p;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.3 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 ShStagGrid (vec2 p, vec2 g)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.3 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn, lVec, rg;\n  vec2 vf;\n  float dstObj, a, s, fFade;\n  bool fxz;\n  crRad = 2.;\n  crLen = 5.;\n  bgCol = mix (0.6 * vec3 (0.4, 0.4, 0.5), vec3 (0.21), smoothstep (-0.01, 0.01, rd.y));\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    cId = floor (ro / bSize);\n    SetEngConf ();\n    vn = ObjNf (ro);\n    vf = vec2 (0.);\n    fFade = exp (32. * min (0., 0.7 - dstObj / dstFar));\n    if (idObj == idFlr) {\n      if (vn.y > 0.99) {\n        col4 = vec4 (0.4, 0.4, 0.5, 0.1);\n        rg = ShGrid (ro.xz);\n        col4.rgb *= mix (1., rg.y, fFade) * (1. - 0.3 * Fbm2 (2. * ro.xz));\n        if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z * fFade);\n        else vn.yx = Rot2D (vn.yx, rg.x * fFade);\n        col4 *= (1. - 0.5 * smoothstep (12., 16., length (qHit.xz)));\n        vf = vec2 (32., 1.);\n      } else if (vn.y < -0.99) {\n        col4 = vec4 (vec3 (0.3) * (1. - 0.3 * smoothstep (3., 7.,\n           length (abs (qHit.xz) - 6.))), -1.);\n      } else {\n        col4 = vec4 (0.3, 0.3, 0.3, 0.1);\n        vf = vec2 (32., 1.);\n      }\n    } else if (idObj == idBase) {\n      col4 = vec4 (0.6, 0.3, 0.2, 0.1);\n      if (abs (vn.y) < 0.01) {\n        rg = ro;\n        rg.y += 0.5;\n        fxz = (abs (vn.x) > 0.99);\n        rg = ShStagGrid ((fxz ? rg.zy : rg.xy), vec2 (1., 2.));\n        col4.r *= rg.y;\n        col4.rgb *= 1. - 0.3 * Fbm2 (2. * (fxz ? ro.zy : ro.xy));\n        rg.xz *= sign (fxz ? vn.x : vn.z);\n        if (fxz) {\n          if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n          else vn.xz = Rot2D (vn.xz, rg.x);\n        } else {\n          if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n          else vn.zx = Rot2D (vn.zx, rg.x);\n        }\n      } else {\n        rg = ShGrid (ro.xz);\n        col4.r *= rg.y;\n        col4.rgb *= 1. - 0.3 * Fbm2 (2. * ro.xz);\n        if (vn.y > 0.99) {\n          if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);\n          else vn.yx = Rot2D (vn.yx, rg.x);\n        }\n      }\n      vf = vec2 (32., 1.);\n    } else if (idObj == idCol) {\n      col4 = vec4 (0.8, 0.8, 0.75, 0.05);\n      vf = vec2 (32., 1.);\n    } else if (idObj == idCyl) {\n      col4 = vec4 (0.8, 0.8, 0.9, 0.3);\n      a = atan (qHit.z, - qHit.y) / (2. * pi);\n      if (abs (vn.x) > 0.99) {\n        col4.rgb *= 1. - 0.2 * Fbm2 (4. * qHit.yz);\n        col4.rgb *= (1. - 0.5 * SmoothBump (0.2, 0.4, 0.01, mod (16. * a + 0.5, 1.)) *\n           SmoothBump (0.05, 0.13, 0.01, 1. - length (qHit.yz) / 1.5));\n      } else {\n        col4.rgb *= 1. - 0.2 * Fbm2 (4. * vec2 (8. * a, qHit.x));\n        col4.rgb *= (1. - 0.5 * SmoothBump (0.03, 0.06, 0.01, 1. - abs (qHit.x) / 3.5));\n        a = mod (32. * a, 1.);\n        if (abs (qHit.x) < 3.3) vn.yz = Rot2D (vn.yz, 0.4 * SmoothBump (0.25, 0.75, 0.2, a) *\n           sign (a - 0.5));\n      }\n    } else if (idObj == idWhl) {\n      if (abs (vn.z) < 0.01) {\n        s = length (qHit.xy);\n        qHit.xy = vec2 (8. * atan (qHit.x, - qHit.y) / pi, qHit.z);\n        if (s > 4.1) {\n          s = mod (4. * qHit.z, 1.);\n          vn.z = -0.2 * SmoothBump (0.25, 0.75, 0.15, s) * sign (s - 0.5) * sign (ro.z);\n          vn = normalize (vn);\n        }\n      }\n      col4 = vec4 (0.5, 0.5, 0.55, 0.05) * (1. + 0.2 * Noisefv2 (128. * qHit.xy));\n    } else if (idObj == idSpk) {\n      col4 = 1.1 * vec4 (0.5, 0.5, 0.55, 0.2);\n    } else if (idObj == idCrnk) {\n      col4 = vec4 (0.5, 0.5, 0.6, 0.2);\n    } else if (idObj == idAx) {\n      col4 = vec4 (0.6, 0.4, 0.1, 0.3);\n    } else if (idObj == idPis) {\n      col4 = vec4 (0.5, 0.5, 0.2, 0.3);\n    } else if (idObj == idCrod) {\n      col4 = vec4 (0.6, 0.6, 0.5, 0.3);\n    } else if (idObj == idCylEnt) {\n      col4 = vec4 (0.7, 0.7, 0.8, 0.2) * (1. - 0.5 * step (length (qHit.yz), 0.33));\n    } else if (idObj == idValv) {\n      col4 = vec4 (0.7, 0.7, 0.8, 0.5) * (1. - 0.5 * step (0., vn.x) *\n         step (length (qHit.yz), 0.13));\n      vf = vec2 (32., 0.3);\n    } else if (idObj == idPipes) {\n      col4 = vec4 (0.6, 0.4, 0.1, 0.1);\n      vf = vec2 (32., 0.3);\n    } else if (idObj == idSup) {\n      col4 = vec4 (0.2, 0.4, 0.1, 0.05);\n      vf = vec2 (32., 1.);\n    } else if (idObj == idRail) {\n      col4 = vec4 (0.2, 0.4, 0.2, 0.1);\n      vf = vec2 (32., 0.2);\n    } else if (idObj == idLt) {\n      qHit.xz = smoothstep (0.05, 0.1, abs (qHit.xz));\n      col4 = vec4 (vec3 (1., 1., 0.8) * 0.5 * (1. - vn.y) * (0.7 + 0.3 * qHit.x * qHit.z), -1.);\n    }\n    if (col4.a >= 0.) {\n      if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n      lVec = normalize (vec3 (1., 1.3, 1.));\n      col = 0.2 * col4.rgb;\n      for (float sx = -1.; sx <= 1.; sx += 2.) {\n        for (float sz = -1.; sz <= 1.; sz += 2.) {\n          col += 0.5 * col4.rgb * max (dot (vn, lVec * vec3 (sx, 1., sz)), 0.) +\n             col4.a * pow (max (dot (normalize (lVec * vec3 (sx, 1., sz) - rd), vn), 0.), 64.);\n        }\n      }\n      col *= 0.7 + 0.3 * ObjSShadow (ro, vec3 (0., 1., 0.));\n    } else col = col4.rgb;\n    col = clamp (mix (bgCol, col, fFade), 0., 1.);\n  } else col = bgCol;\n  if (! colImg) col = pow (vec3 (1., 0.59, 0.18) * RgbToVal (col), vec3 (0.9));\n  if (marchImg) col = HsvToRgb (vec3 (0.7 * (1. - stepCnt / 180.), 1., 1.));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvs, ori, ca, sa;\n  float el, az, asp;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uvs = uv;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  bSize = vec3 (40., 20., 40.);\n  az = 0.;\n  el = -0.05 * pi;\n  colImg = false;\n  marchImg = false;\n  if (mPtr.z > 0. && mPtr.x > 0.4 && mPtr.y < -0.4) colImg = true;\n  if (mPtr.z > 0. && mPtr.x > 0.4 && mPtr.y > 0.4) marchImg = true;\n  if (mPtr.z > 0. && ! colImg && ! marchImg) {\n    az += 2. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  } else {\n    az = 0.5 * pi * (2. * mod (floor (0.07 * tCur), 2.) - 1.) *\n       SmoothBump (0.2, 0.8, 0.1, mod (0.07 * tCur, 1.));\n  }\n  el = clamp (el, -0.4 * pi, 0.4 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -1.) + vec3 (0., 8., 3. * tCur);\n  asp = canvas.x / canvas.y;\n  uv.xy /= 1.9;\n  rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uv.x / asp)) * asp, uv.y, 1.));\n  dstFar = 180.;\n  col = ShowScene (ro, rd);\n  if (! colImg && ! marchImg) {\n    uvs *= uvs;\n    col = mix (0.2 * vec3 (1., 0.59, 0.18), col, 1. - smoothstep (0.9, 1.,\n       length (uvs * uvs * uvs)));\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nfloat RgbToVal (vec3 c)\n{\n  return max (c.r, max (c.g, c.b));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltffzB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 1094, 1129, 1129, 1989], [1991, 1991, 2026, 2026, 3207], [3209, 3209, 3243, 3243, 5396], [5398, 5398, 5420, 5420, 5521], [5523, 5523, 5543, 5543, 5993], [5995, 5995, 6028, 6028, 6726], [6728, 6728, 6749, 6749, 6977], [6979, 6979, 7016, 7016, 7436], [7438, 7438, 7460, 7460, 7745], [7747, 7747, 7781, 7781, 8135], [8137, 8137, 8172, 8172, 13351], [13353, 13353, 13406, 13406, 14824], [14826, 14826, 14858, 14858, 14958], [14960, 14960, 14993, 14993, 15082], [15084, 15084, 15117, 15117, 15144], [15146, 15146, 15188, 15188, 15239], [15241, 15241, 15294, 15294, 15355], [15357, 15357, 15414, 15414, 15497], [15499, 15499, 15529, 15529, 15587], [15589, 15589, 15620, 15620, 15684], [15686, 15686, 15710, 15710, 15846], [15848, 15848, 15873, 15873, 15911], [15945, 15945, 15969, 15969, 16034], [16036, 16036, 16060, 16060, 16190], [16192, 16192, 16217, 16217, 16403], [16405, 16405, 16426, 16426, 16581], [16583, 16583, 16612, 16612, 16824], [16826, 16826, 16865, 16865, 17049]], "test": "untested"}
{"id": "ltGXWK", "name": "Quadruple Precision Mandelbrot", "author": "mazander", "description": "Quadruple Precision Mandelbrot Fractal with multiple zoom targets.\n\nEmulated quadruple precision GLSL library Created by Henry Thasler (https://www.thasler.com/blog/blog/glsl-part5)\nBased on the QD library (http://crd-legacy.lbl.gov/~dhbailey/mpdist/)\n\n", "tags": ["fractal", "mandel", "quadrupleprecision"], "likes": 5, "viewed": 228, "published": "Public", "date": "1514662766", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// emulated quadruple precision GLSL library\n// created by Henry Thasler (thasler.org/blog)\n// based on the QD library (http://crd-legacy.lbl.gov/~dhbailey/mpdist/)\n\n// inline double quick_two_sum(double a, double b, double &err)\nvec2 quick_2sum(float a, float b)\n{\n    float s = a + b;                       // double s = a + b;\n    return vec2(s, b-(s-a));       // err = b - (s - a);\n}\n\n/* Computes fl(a+b) and err(a+b).  */\n// inline double two_sum(double a, double b, double &err)\nvec2 two_sum(float a, float b)\n{\n    float v,s,e;\n\n    s = a+b;                               // double s = a + b;\n    v = s-a;                               // double bb = s - a;\n    e = (a-(s-v))+(b-v);   // err = (a - (s - bb)) + (b - bb);\n\n    return vec2(s,e);\n}\n\nvec2 split(float a)\n{\n    float t, hi;\n    t = 8193. * a;\n    hi = t - (t-a);\n    return vec2(hi, a-hi);\n}\n\nvec3 three_sum(float a, float b, float c)\n{\n    vec2 tmp;\n    vec3 res;// = vec3(0.);\n    float t1, t2, t3;\n    tmp = two_sum(a, b); // t1 = qd::two_sum(a, b, t2);\n    t1 = tmp.x;\n    t2 = tmp.y;\n\n    tmp = two_sum(c, t1); // a  = qd::two_sum(c, t1, t3);\n    res.x = tmp.x;\n    t3 = tmp.y;\n\n    tmp = two_sum(t2, t3); // b  = qd::two_sum(t2, t3, c);\n    res.y = tmp.x;\n    res.z = tmp.y;\n\n    return res;\n}\n\n//inline void three_sum2(double &a, double &b, double &c)\nvec3 three_sum2(float a, float b, float c)\n{\n    vec2 tmp;\n    vec3 res;// = vec3(0.);\n    float t1, t2, t3;       // double t1, t2, t3;\n    tmp = two_sum(a, b); // t1 = qd::two_sum(a, b, t2);\n    t1 = tmp.x;\n    t2 = tmp.y;\n\n    tmp = two_sum(c, t1); // a  = qd::two_sum(c, t1, t3);\n    res.x = tmp.x;\n    t3 = tmp.y;\n\n    res.y = t2 + t3;      // b = t2 + t3;\n    return res;\n}\n\nvec2 two_prod(float a, float b)\n{\n    float p, e;\n    vec2 va, vb;\n\n    p=a*b;\n    va = split(a);\n    vb = split(b);\n\n    e = ((va.x*vb.x-p) + va.x*vb.y + va.y*vb.x) + va.y*vb.y;\n    return vec2(p, e);\n}\n\nvec4 renorm(float c0, float c1, float c2, float c3, float c4)\n{\n    float s0, s1, s2 = 0.0, s3 = 0.0;\n    vec2 tmp;\n\n    // if (QD_ISINF(c0)) return;\n\n    tmp = quick_2sum(c3,c4); // s0 = qd::quick_two_sum(c3, c4, c4);\n    s0 = tmp.x;\n    c4 = tmp.y;\n\n    tmp = quick_2sum(c2,s0); // s0 = qd::quick_two_sum(c2, s0, c3);\n    s0 = tmp.x;\n    c3 = tmp.y;\n\n    tmp = quick_2sum(c1,s0); // s0 = qd::quick_two_sum(c1, s0, c2);\n    s0 = tmp.x;\n    c2 = tmp.y;\n\n    tmp = quick_2sum(c0,s0); // c0 = qd::quick_two_sum(c0, s0, c1);\n    c0 = tmp.x;\n    c1 = tmp.y;\n\n    s0 = c0;\n    s1 = c1;\n\n    tmp = quick_2sum(c0,c1); // s0 = qd::quick_two_sum(c0, c1, s1);\n    s0 = tmp.x;\n    s1 = tmp.y;\n\n    if (s1 != 0.0) {\n        tmp = quick_2sum(s1,c2); // s1 = qd::quick_two_sum(s1, c2, s2);\n        s1 = tmp.x;\n        s2 = tmp.y;\n\n        if (s2 != 0.0) {\n            tmp = quick_2sum(s2,c3); // s2 = qd::quick_two_sum(s2, c3, s3);\n            s2 = tmp.x;\n            s3 = tmp.y;\n            if (s3 != 0.0)\n                s3 += c4;\n            else\n                s2 += c4;\n        } else {\n            tmp = quick_2sum(s1,c3); // s1 = qd::quick_two_sum(s1, c3, s2);\n            s1 = tmp.x;\n            s2 = tmp.y;\n            if (s2 != 0.0){\n                tmp = quick_2sum(s2,c4); // s2 = qd::quick_two_sum(s2, c4, s3);\n                s2 = tmp.x;\n                s3 = tmp.y;}\n            else{\n                tmp = quick_2sum(s1,c4); // s1 = qd::quick_two_sum(s1, c4, s2);\n                s1 = tmp.x;\n                s2 = tmp.y;}\n        }\n    } else {\n        tmp = quick_2sum(s0,c2); // s0 = qd::quick_two_sum(s0, c2, s1);\n        s0 = tmp.x;\n        s1 = tmp.y;\n        if (s1 != 0.0) {\n            tmp = quick_2sum(s1,c3); // s1 = qd::quick_two_sum(s1, c3, s2);\n            s1 = tmp.x;\n            s2 = tmp.y;\n            if (s2 != 0.0){\n                tmp = quick_2sum(s2,c4); // s2 = qd::quick_two_sum(s2, c4, s3);\n                s2 = tmp.x;\n                s3 = tmp.y;}\n            else{\n                tmp = quick_2sum(s1,c4); // s1 = qd::quick_two_sum(s1, c4, s2);\n                s1 = tmp.x;\n                s2 = tmp.y;}\n        } else {\n            tmp = quick_2sum(s0,c3); // s0 = qd::quick_two_sum(s0, c3, s1);\n            s0 = tmp.x;\n            s1 = tmp.y;\n            if (s1 != 0.0){\n                tmp = quick_2sum(s1,c4); // s1 = qd::quick_two_sum(s1, c4, s2);\n                s1 = tmp.x;\n                s2 = tmp.y;}\n            else{\n                tmp = quick_2sum(s0,c4); // s0 = qd::quick_two_sum(s0, c4, s1);\n                s0 = tmp.x;\n                s1 = tmp.y;}\n        }\n    }\n\n    return vec4(s0, s1, s2, s3);\n\n}\n\nvec4 renorm4(float c0, float c1, float c2, float c3)\n{\n    float s0, s1, s2 = 0.0, s3 = 0.0;\n    vec2 tmp;\n    // if (QD_ISINF(c0)) return;\n\n    tmp = quick_2sum(c2,c3); // s0 = qd::quick_two_sum(c2, c3, c3);\n    s0 = tmp.x;\n    c3 = tmp.y;\n\n    tmp = quick_2sum(c1,s0); // s0 = qd::quick_two_sum(c1, s0, c2);\n    s0 = tmp.x;\n    c2 = tmp.y;\n\n    tmp = quick_2sum(c0,s0); // c0 = qd::quick_two_sum(c0, s0, c1);\n    c0 = tmp.x;\n    c1 = tmp.y;\n\n    s0 = c0;\n    s1 = c1;\n    if (s1 != 0.0) {\n        tmp = quick_2sum(s1,c2); // s1 = qd::quick_two_sum(s1, c2, s2);\n        s1 = tmp.x;\n        s2 = tmp.y;\n\n        if (s2 != 0.0){\n            tmp = quick_2sum(s2,c3); // s2 = qd::quick_two_sum(s2, c3, s3);\n            s2 = tmp.x;\n            s3 = tmp.y;}\n        else{\n            tmp = quick_2sum(s1,c3); // s1 = qd::quick_two_sum(s1, c3, s2);\n            s1 = tmp.x;\n            s2 = tmp.y;}\n    } else {\n        tmp = quick_2sum(s0,c2); // s0 = qd::quick_two_sum(s0, c2, s1);\n        s0 = tmp.x;\n        s1 = tmp.y;\n        if (s1 != 0.0){\n            tmp = quick_2sum(s1,c3); // s1 = qd::quick_two_sum(s1, c3, s2);\n            s1 = tmp.x;\n            s2 = tmp.y;}\n        else{\n            tmp = quick_2sum(s0,c3); // s0 = qd::quick_two_sum(s0, c3, s1);\n            s0 = tmp.x;\n            s1 = tmp.y;}\n    }\n\n    return vec4(s0, s1, s2, s3);\n}\n\nvec3 quick_three_accum(float a, float b, float c)\n{\n    vec2 tmp;\n    float s;\n    bool za, zb;\n\n    tmp = two_sum(b, c); // s = qd::two_sum(b, c, b);\n    s = tmp.x;\n    b = tmp.y;\n\n    tmp = two_sum(a, s); // s = qd::two_sum(a, s, a);\n    s = tmp.x;\n    a = tmp.y;\n\n    za = (a != 0.0);\n    zb = (b != 0.0);\n\n    if (za && zb)\n        return vec3(a,b,s);\n\n    if (!zb) {\n        b = a;\n        a = s;\n    } else {\n        a = s;\n    }\n\n    return vec3(a,b,0.);\n}\n\n// inline qd_real qd_real::ieee_add(const qd_real &a, const qd_real &b)\nvec4 qs_ieee_add(vec4 _a, vec4 _b)\n{\n    vec2 tmp=vec2(0.);\n    vec3 tmp3=vec3(0.);\n    int i, j, k;\n    float s, t;\n    float u, v;   // double-length accumulator\n    float x[4] = float[4](0.0, 0.0, 0.0, 0.0);\n    float a[4], b[4];\n\n    a[0] = _a.x;\n    a[1] = _a.y;\n    a[2] = _a.z;\n    a[3] = _a.w;\n\n    b[0] = _b.x;\n    b[1] = _b.y;\n    b[2] = _b.z;\n    b[3] = _b.w;\n\n    i = j = k = 0;\n    if (abs(a[i]) > abs(b[j]))\n        u = a[i++];\n    else\n        u = b[j++];\n    if (abs(a[i]) > abs(b[j]))\n        v = a[i++];\n    else\n        v = b[j++];\n\n    tmp = quick_2sum(u,v); // u = qd::quick_two_sum(u, v, v);\n    u = tmp.x;\n    v = tmp.y;\n\n    while (k < 4) {\n        if (i >= 4 && j >= 4) {\n            x[k] = u;\n            if (k < 3)\n                x[++k] = v;\n            break;\n        }\n\n        if (i >= 4)\n            t = b[j++];\n        else if (j >= 4)\n            t = a[i++];\n            else if (abs(a[i]) > abs(b[j])) {\n                t = a[i++];\n            } else\n                t = b[j++];\n\n        tmp3 = quick_three_accum(u,v,t)  ; // s = qd::quick_three_accum(u, v, t);\n        u = tmp3.x;\n        v = tmp3.y;\n        s = tmp3.z;\n\n        if (s != 0.0) {\n            x[k++] = s;\n        }\n    }\n\n    // add the rest.\n    for (k = i; k < 4; k++)\n        x[3] += a[k];\n    for (k = j; k < 4; k++)\n        x[3] += b[k];\n\n    // qd::renorm(x[0], x[1], x[2], x[3]);\n    // return qd_real(x[0], x[1], x[2], x[3]);\n    return renorm4(x[0], x[1], x[2], x[3]);\n}\n\n// inline qd_real qd_real::sloppy_add(const qd_real &a, const qd_real &b)\nvec4 qs_sloppy_add(vec4 a, vec4 b)\n{\n    float s0, s1, s2, s3;\n    float t0, t1, t2, t3;\n\n    float v0, v1, v2, v3;\n    float u0, u1, u2, u3;\n    float w0, w1, w2, w3;\n\n    vec2 tmp;\n    vec3 tmp3;\n\n    s0 = a.x + b.x;       // s0 = a[0] + b[0];\n    s1 = a.y + b.y;       // s1 = a[1] + b[1];\n    s2 = a.z + b.z;       // s2 = a[2] + b[2];\n    s3 = a.w + b.w;       // s3 = a[3] + b[3];  \n\n    v0 = s0 - a.x;        // v0 = s0 - a[0];\n    v1 = s1 - a.y;        // v1 = s1 - a[1];\n    v2 = s2 - a.z;        // v2 = s2 - a[2];\n    v3 = s3 - a.w;        // v3 = s3 - a[3];\n\n    u0 = s0 - v0;\n    u1 = s1 - v1;\n    u2 = s2 - v2;\n    u3 = s3 - v3;\n\n    w0 = a.x - u0;        // w0 = a[0] - u0;\n    w1 = a.y - u1;        // w1 = a[1] - u1;\n    w2 = a.z - u2;        // w2 = a[2] - u2;\n    w3 = a.w - u3;        // w3 = a[3] - u3; \n\n    u0 = b.x - v0;        // u0 = b[0] - v0;\n    u1 = b.y - v1;        // u1 = b[1] - v1;\n    u2 = b.z - v2;        // u2 = b[2] - v2;\n    u3 = b.w - v3;        // u3 = b[3] - v3;\n\n    t0 = w0 + u0;\n    t1 = w1 + u1;\n    t2 = w2 + u2;\n    t3 = w3 + u3;\n\n    tmp = two_sum(s1, t0); // s1 = qd::two_sum(s1, t0, t0);\n    s1 = tmp.x;\n    t0 = tmp.y;\n\n    tmp3 = three_sum(s2, t0, t1); // qd::three_sum(s2, t0, t1);\n    s2 = tmp3.x;\n    t0 = tmp3.y;\n    t1 = tmp3.z;\n\n    tmp3 = three_sum2(s3, t0, t2); // qd::three_sum2(s3, t0, t2);\n    s3 = tmp3.x;\n    t0 = tmp3.y;\n    t2 = tmp3.z;\n\n    t0 = t0 + t1 + t3;\n\n    // qd::renorm(s0, s1, s2, s3, t0);\n    return renorm(s0, s1, s2, s3, t0); // return qd_real(s0, s1, s2, s3);\n}\n\nvec4 qs_add(vec4 _a, vec4 _b)\n{\n    return qs_sloppy_add(_a, _b);\n    //  return qs_ieee_add(_a, _b);\n}  \n\nvec4 qs_mul(vec4 a, vec4 b)\n{\n    float p0, p1, p2, p3, p4, p5;\n    float q0, q1, q2, q3, q4, q5;\n    float t0, t1;\n    float s0, s1, s2;\n    vec2 tmp;\n    vec3 tmp3;\n\n    tmp = two_prod(a.x, b.x); // p0 = qd::two_prod(a[0], b[0], q0);\n    p0 = tmp.x;\n    q0 = tmp.y;\n\n    tmp = two_prod(a.x, b.y); // p1 = qd::two_prod(a[0], b[1], q1);\n    p1 = tmp.x;\n    q1 = tmp.y;\n\n    tmp = two_prod(a.y, b.x); // p2 = qd::two_prod(a[1], b[0], q2);\n    p2 = tmp.x;\n    q2 = tmp.y;\n\n    tmp = two_prod(a.x, b.z); // p3 = qd::two_prod(a[0], b[2], q3);\n    p3 = tmp.x;\n    q3 = tmp.y;\n\n    tmp = two_prod(a.y, b.y); // p4 = qd::two_prod(a[1], b[1], q4);\n    p4 = tmp.x;\n    q4 = tmp.y;\n\n    tmp = two_prod(a.z, b.x); // p5 = qd::two_prod(a[2], b[0], q5);\n    p5 = tmp.x;\n    q5 = tmp.y;\n\n    /* Start Accumulation */\n    tmp3 = three_sum(p1, p2, q0); // qd::three_sum(p1, p2, q0);\n    p1 = tmp3.x;\n    p2 = tmp3.y;\n    q0 = tmp3.z;\n\n    /* Six-Three Sum  of p2, q1, q2, p3, p4, p5. */\n    tmp3 = three_sum(p2, q1, q2); // qd::three_sum(p2, q1, q2);\n    p2 = tmp3.x;\n    q1 = tmp3.y;\n    q2 = tmp3.z;\n\n    tmp3 = three_sum(p3, p4, p5); // qd::three_sum(p3, p4, p5);\n    p3 = tmp3.x;\n    p4 = tmp3.y;\n    p5 = tmp3.z;\n\n    /* compute (s0, s1, s2) = (p2, q1, q2) + (p3, p4, p5). */\n    tmp = two_sum(p2, p3); // s0 = qd::two_sum(p2, p3, t0);\n    s0 = tmp.x;\n    t0 = tmp.y;\n\n    tmp = two_sum(q1, p4); // s1 = qd::two_sum(q1, p4, t1);\n    s1 = tmp.x;\n    t1 = tmp.y;\n\n    s2 = q2 + p5;\n    tmp = two_sum(s1, t0); // s1 = qd::two_sum(s1, t0, t0);\n    s1 = tmp.x;\n    t0 = tmp.y;\n    s2 += (t0 + t1);\n\n    /* O(eps^3) order terms */\n    s1 += a.x*b.w + a.y*b.z + a.z*b.y + a.w*b.x + q0 + q3 + q4 + q5;\n\n    return renorm(p0, p1, s0, s1, s2); // qd::renorm(p0, p1, s0, s1, s2);\n}\n\nfloat ds_compare(vec2 dsa, vec2 dsb)\n{\n    if (dsa.x < dsb.x) return -1.;\n    else if (dsa.x == dsb.x)\n    {\n        if (dsa.y < dsb.y) return -1.;\n        else if (dsa.y == dsb.y) return 0.;\n            else return 1.;\n            }\n    else return 1.;\n}\n\nfloat qs_compare(vec4 qsa, vec4 qsb)\n{\n    if(ds_compare(qsa.xy, qsb.xy)<0.) return -1.; // if (dsa.x < dsb.x) return -1.;\n    else if (ds_compare(qsa.xy, qsb.xy) == 0.) // else if (dsa.x == dsb.x)\n    {\n        if(ds_compare(qsa.zw, qsb.zw)<0.) return -1.; // if (dsa.y < dsb.y) return -1.;\n        else if (ds_compare(qsa.zw, qsb.zw) == 0.) return 0.;// else if (dsa.y == dsb.y) return 0.;\n            else return 1.;\n            }\n    else return 1.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\n    float a = 0.4*iTime;\n\tfloat tz = 0.5 - 0.5 * cos(a);\n\n        // array of zoom targets: x + yi\n    vec2[] zoomTargets = vec2[] (\n        vec2(-1.25067, 0.02012),\n        vec2(-0.235125, 0.827215),\n        vec2(-0.74635, 0.11022),\n        vec2(-0.925, 0.266),\n        vec2(-0.745428, 0.113009),\n        vec2(-0.7479, 0.099983)\n    );\n    \n    // select zoom target\n    vec2 target = zoomTargets[int(a / 6.28318530718) % 6];\n    vec2 targetNext = zoomTargets[int(a / 6.28318530718 + 1.0) % 6];\n    \n    \n    vec4 zo = vec4(pow(0.5, 15.0 * tz), 0.0, 0.0, 0.0);\n\n    vec4 cx = vec4(p.x, 0.0, 0.0, 0.0);\n    vec4 cy = vec4(p.y, 0.0, 0.0, 0.0);\n   \t\n\tcx = qs_add(qs_mul(cx, zo), vec4(target.x, 0.0, 0.0, 0.0));\n\tcy = qs_add(qs_mul(cy, zo), vec4(target.y, 0.0, 0.0, 0.0));\n    \n    float n = 0.0;\n\t\n    vec4 tmp;\n    vec4 zx = cx;\n    vec4 zy = cy;\n    vec4 two = vec4(2.0, 0., 0., 0.); \n    \n    vec4 e_radius = vec4(4.0, 0., 0., 0.);   // no sqrt available so compare with radius^2 = 2^2 = 2*2 = 4\n    \n    for( int i=0; i <1500; i++ )\n    {\n\t\ttmp = zx;\n        zx = qs_add(qs_add(qs_mul(zx, zx), -qs_mul(zy, zy)), cx);\n        zy = qs_add(qs_mul(qs_mul(zy, tmp), two), cy);\n\n        if( qs_compare(qs_add(qs_mul(zx, zx), qs_mul(zy, zy)), e_radius) > 0.)\n        {\n            // http://linas.org/art-gallery/escape/escape.html\n            n += 1. - log(log(length(vec2(zx.x, zy.x)))) /log(2.);     \n            break;   \n        }\n        n += 1.0;\n    }\n    \n\n    if(n < 1500.0 ) {\n        fragColor = vec4((-cos(n * vec3(0.025, 0.08, 0.12)) + 1.0) * 0.5, 1.0);\n\n    } else {\n        // black center\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n        \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltGXWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 230, 265, 265, 388], [390, 486, 518, 518, 753], [755, 755, 776, 776, 861], [863, 863, 906, 906, 1269], [1271, 1329, 1373, 1373, 1708], [1710, 1710, 1743, 1743, 1913], [1915, 1915, 1978, 1978, 4555], [4557, 4557, 4611, 4611, 5903], [5905, 5905, 5956, 5956, 6368], [6370, 6442, 6478, 6478, 7922], [7924, 7998, 8034, 8034, 9543], [9545, 9545, 9576, 9576, 9648], [9652, 9652, 9681, 9681, 11411], [11413, 11413, 11451, 11451, 11668], [11670, 11670, 11708, 11708, 12125], [12128, 12128, 12185, 12185, 13964]], "test": "untested"}
{"id": "ltjBRz", "name": "Apollonian Statue", "author": "EvilRyu", "description": "3D one", "tags": ["fractal", "apollonian"], "likes": 25, "viewed": 753, "published": "Public API", "date": "1514472619", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define ROT (iTime*0.3)\n#define ITERATION 4\n//#define ITERATION 8\nmat2 rot(float t)\n{\n    float c=cos(t);\n    float s=sin(t);\n    return mat2(c,-s,s,c);\n}\n\nvec4 orb;\nfloat apollonian(vec3 p)\n{\n   \tfloat scale = 1.0;\n\torb = vec4(1000.0); \n\t\n\tfor( int i=0; i < ITERATION;i++ )\n\t{\n\t\tp = -1.0 + 2.0*fract(0.5*p+0.5);\n        float r2 = dot(p,p);\n        orb = min( orb, vec4(abs(p),r2) );\n        float k = 2./ r2;\n\t\tp *= k;\n\t\tscale *= k;\n\t}\n\t\n\treturn 0.25*abs(p.y)/scale;\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  \tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 path(float p)\n{\n    return vec3(sin(p*0.16)*cos(p*0.1)*11., 0.,0.);\n}\n\nfloat map(vec3 p)\n{\n    p.xz*=rot(ROT);\n    vec3 q=p;\n\n    float d0=apollonian(p*0.5)*2.;;\n    \n   \n    float d1=abs(p.y+0.2);\n    float d3 = box(q+vec3(0.,-2.,0.), 1.12*vec3(2.,2.,1.0));\n    float d = max(d0, d3);\n    d=min(d,d1);\n    return d;\n}\n\nvec3 get_normal(vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy)-map(p - e.xyy), \n                          map(p + e.yxy)-map(p - e.yxy),\t\n                          map(p + e.yyx)-map(p - e.yyx)));\n}\n\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    float pixel_size = 1.0/(iResolution.y * 2.0);\n\n    float t = 1.0;\n    float res_t = 0.0;\n    float res_d = 1000.0;\n    float c, res_c;\n    float max_error = 1000.0;\n\tfloat d = 1.0;\n    float pd = 100.0;\n    float os = 0.0;\n    float step = 0.0;\n    float error = 1000.0;\n    \n    for( int i=0; i<128; i++ )\n    {\n        if( error < pixel_size*0.5 || t > 100.0 )\n        {\n        }\n        else{  // avoid broken shader on windows\n        \n            c = map(ro + rd*t);\n            d = c;\n\n            if(d > os)\n            {\n                os = 0.4 * d*d/pd;\n                step = d + os;\n                pd = d;\n            }\n            else\n            {\n                step =-os; os = 0.0; pd = 100.0; d = 1.0;\n            }\n\n            error = d / t;\n\n            if(error < max_error) \n            {\n                max_error = error;\n                res_t = t;\n                res_c = c;\n            }\n        \n            t += step;\n        }\n\n    }\n\tif( t>100.0 ) res_t=-1.0;\n    return res_t;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<128; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n        if( res<0.0001 ) break;\n        t += clamp( h, 0.01, 0.05 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n  \n    vec3 lookat = vec3(0.0, 2., 0.);\n\tvec3 ro = lookat + vec3(0., 0., -3.5);\n\tro += path(ro.z);\n    \n    vec3 forward=normalize(lookat-ro);\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up=normalize(cross(right, forward));\n    \n    vec3 rd=normalize(p.x*right + p.y*up + 2.*forward);\n    \n    float t=intersect(ro,rd);\n    vec3 col=vec3(0.);\n    if(t>-0.5)\n    {\n        vec3 pos=ro+t*rd;\n        vec3 n=get_normal(pos);\n        \n        vec3 ld0=normalize(vec3(0., 1.0, -4.));\n        \n        float ao = pow(clamp(orb.w*2.0,0.0,1.0), 1.2);\n        float c0=pow(clamp(orb.w, 0.0, 1.0), 2.);\n        float c1=pow(clamp(orb.x, 0.0, 1.0), 2.);\n    \tvec3 col0=c0*vec3(0.0,1.0,1.0);\n\t\tvec3 col1=vec3(1.);\n        col1 = mix(col1, vec3(0.2,0.0,0.0), clamp(5.*orb.y,0.,1.));\n\n\n        float amb=0.5+0.5*n.y;\n        float diff=max(0.0, dot(n,ld0));\n        float bac=max(0.0,dot(n,-ld0));\n        float spec=max(0.0, pow(clamp(dot(ld0, reflect(rd, n)), 0.0, 1.0), 69.0));\n        float sha=softshadow( pos+0.01*n, ld0, 0.0005, 28.0 );\n\t\tvec3 lin=vec3(0.0);\n        \n        lin+=vec3(0.3)*amb*ao;\n        lin+=vec3(7.,4.,3.)*diff*1.0*ao*sha;\n        lin+=vec3(1.0,0.8,0.3)*bac*1.0*ao;\n        lin+=vec3(spec*7.2)*sha;\n        \n       \tcol=(lin*col1-col0)*.2;\n        col=mix(col,vec3(0.), 1.0-exp(-0.001*t*t)); \n        col *= min(2000.0*exp(-0.74*t),1.0);\n\n     }\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\n    col=pow(col,vec3(1.3,1.,1.));\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1);\n    fragColor.xyz=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjBRz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[154, 176, 195, 195, 264], [276, 276, 302, 302, 580], [582, 582, 609, 609, 698], [700, 700, 720, 720, 774], [776, 776, 795, 795, 1023], [1025, 1025, 1050, 1050, 1256], [1259, 1259, 1302, 1302, 2320], [2322, 2322, 2387, 2387, 2650], [2652, 2652, 2709, 2709, 4363]], "test": "untested"}
{"id": "ltlBDS", "name": "Cubic Toris Tunnel", "author": "balkhan", "description": "slow shader", "tags": ["tunnel", "raynarching"], "likes": 14, "viewed": 224, "published": "Public", "date": "1513192107", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nfloat \tt;\n\n#define I_MAX\t\t100\n#define E\t\t\t0.00001\n#define FAR\t\t\t30.\n\n\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nvec2\trot(vec2 p, vec2 ang);\nvoid\trotate(inout vec2 v, float angle);\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\n\nvec3\tid;\nvec3\th;\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    h *= 0.;\n    t = iTime;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2\tuv  = vec2(.35+f.x/iResolution.x, f.y/iResolution.y);\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(-.0, .0, 25.0-sin(iTime*.125)*25.*0.-21.+2.);\n\n    vec4\tinter = (march(pos, dir));\n\n    col = .5 - h;\n\n    c_out =  vec4(col, h.x);\n}\n\nfloat\tscene(vec3 p)\n{\n    float\tmind = 1e5;\n    p.z -= -20.;\n    p.z -= iTime*5.;\n\n    p.y += sin(iTime*-1.+p.z*.5)*.5;\n    p.x += cos(iTime*-1.+p.z*.5)*.5;\n    rotate(p.xy, p.z*.25 + 1.0*sin(p.z*.125 - iTime*0.5) + 1.*iTime);\n    \n    float\ttube = max(-(length(p.yx)-2.), (length(p.yx)-8.));\n    tube = max(tube, p.z-10.-0./length(p.yx*.06125) );\n    tube = max(tube, -p.z-10.-0./length(p.yx*.06125) );\n    vec3\tpr = p;\n    \n    pr.xy = fract(p.xy*.5)-.5;\n    id = vec3(floor(p.xy*.5), floor(p.z*2.));\n    p.z += (mod(id.x*1., 2.)-1. == 0. ? 5. : 0. );\n    p.z += (mod(id.y*1., 2.)-1. == 0. ? 5. : 0. );\n    rotate(pr.xy, clamp( (mod(floor(p.z*.5), 2.)-1. == 0. ? 1. : -1.)+(mod(id.x, 2.)-1. == 0. ? 1. : -1.) + (mod(id.y, 2.)-1. == 0. ? 1. : -1.), -2., 2.) * iTime*2.+(mod(id.x, 2.)-1. == 0. ? -1. : -1.)*p.z*2.5 + iTime*0. );\n    \n    pr.xy = abs(pr.xy)-.05-(sin(p.z*0.5+iTime*0.)*.15);\n    pr.xy *= clamp(1./length(pr.xy), .0, 2.5);\n    pr.z = (fract(pr.z*2.)-.5);\n\tmind = mylength(vec2(mylength(pr.xy)-.1, pr.z ))-.04;\n    \n    return(mind);\n}\n\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec4\tstep = vec4(0.0, 0.0, 0.0, 0.0);\n\tvec3\tdirr;\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n        dirr = dir;\n    \trotate(dirr.zx, .025*dist.y );\n    \tp = pos + dirr * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x*.5;\n        vec3\ts = p- 1.*vec3(.0,7.0,0.0);\n        float\td = length(s.xy)-.1;\n        h -= vec3(.3, .2, .0)*.1/ (d+.0);\n        h += (\n            .001/(dist.x*dist.x+0.01) \n            -\n            1./(dist.y*dist.y+40.)\n             )\n            *\n            vec3\n        (\n    \t\tabs(sin(id.z+id.x+id.y+0.00) )\n            ,\n            abs(sin(id.z+id.x+id.y+1.04) )\n            ,\n            abs(sin(id.z+id.x+id.y+2.08) )\n        );\n        // log trick by aiekick\n        if (log(dist.y*dist.y/dist.x/1e5)>0. || dist.x < E || dist.y >= FAR)\n        {\n            if (dist.x < E || log(dist.y*dist.y/dist.x/1e5)>0.)\n\t            step.y = 1.;\n            break;\n        }\n        step.x++;\n    }\n    step.w = dist.y;\n    return (step);\n}\n\n// Utilities\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret = 1e5;\n    \n    p = p*p;\n    p = p*p;\n    p = p*p;\n    \n    ret = p.x + p.y + p.z;\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret = 1e5;\n    \n    p = p*p;\n    p = p*p;\n    p = p*p;\n    \n    ret = p.x + p.y;\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x-.85) * right + (uv.y-0.5) * up + fov * forw));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlBDS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 401, 444, 444, 743], [745, 745, 766, 766, 1793], [1796, 1796, 1828, 1828, 2877], [2879, 2893, 2917, 2917, 3061], [3063, 3063, 3087, 3087, 3225], [3227, 3227, 3267, 3267, 3342], [3344, 3344, 3372, 3372, 3480], [3483, 3483, 3533, 3533, 3793], [3795, 3795, 3817, 3817, 4031]], "test": "untested"}
{"id": "ltlBW7", "name": "Solar System 1", "author": "ZdravkoD", "description": "Solar", "tags": ["solar"], "likes": 2, "viewed": 203, "published": "Public", "date": "1512144625", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 globalFragCoord;\nvec2 sunCenter;\n\nvec4 drawCircle( in vec2 center_of_circle, in float radius, in vec4 color)\n{\n    float inCircleCoef = ceil(max(radius - distance(globalFragCoord, center_of_circle), 0.0));\n\n    return color * vec4(inCircleCoef);\n}\n\nvec2 rotatePoint(in vec2 pos, in float angle)\n{\n    float currentAngle = atan( pos[1] / pos[0] );\n    float c = sqrt( pow(pos[0] - sunCenter[0], 2.) + pow(pos[1] - sunCenter[1], 2.) );\n    float gama = currentAngle + angle;\n    \n    return vec2(sin(gama) * c + sunCenter[0], cos(gama) * c + sunCenter[1] );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    globalFragCoord = fragCoord;\n    sunCenter = iResolution.xy / vec2(2.0);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float offset = 0.0;\n    float distBetweenPlantes = iResolution.y / 50.0;\n    \n    // set background\n    fragColor = vec4(0.0);\n    \n    float mercuryRotationAngle = mod(iTime, 180.);\n        \n    float earthRadius = iResolution.y / 50.0; vec4 earthColor = vec4(0.231, 0.301, 0.098, 1.0); float earthRotationAngle = mercuryRotationAngle / 1.666;\n    \n    float mercuryRadius = earthRadius * 0.48; vec4 mercuryColor = vec4(0.556, 0.419, 0.196, 1.0);\n    float venusRadius = earthRadius * 0.95; vec4 venusColor = vec4(0.568, 0.278, 0.125, 1.0); float venusRotationAngle = mercuryRotationAngle / 1.428;\n    float marsRadius = earthRadius * 0.53; vec4 marsColor = vec4(0.588, 0.494, 0.352, 1.0); float marsRotationAngle = mercuryRotationAngle / 2.083;\n    float jupiterRadius = earthRadius * 3.2; vec4 jupiterColor = vec4(0.815, 0.819, 0.835, 1.0); float jupiterRotationAngle = mercuryRotationAngle / 3.846;\n    float saturnRadius = earthRadius * 2.45; vec4 saturnColor = vec4(0.866, 0.729, 0.509, 1.0); float saturnRotationAngle = mercuryRotationAngle / 5.0;\n    float uranusRadius = earthRadius * 1.5; vec4 uranusColor = vec4(0.423, 0.623, 0.8, 1.0); float uranusRotationAngle = mercuryRotationAngle / 5.555;\n    float neptuneRadius = earthRadius * 1.2; vec4 neptuneColor = vec4(0.317, 0.423, 0.701, 1.0); float neptuneRotationAngle = mercuryRotationAngle / 7.14;\n    \n    float sunRadius = earthRadius * 6.0; // original 109.24\n    vec4 sunColor = vec4(1.0, 1.0, 0.0, 1.0);\n    \n    fragColor += drawCircle(sunCenter + vec2(offset), sunRadius, sunColor );\n    offset += sunRadius;\n    fragColor += drawCircle( rotatePoint(sunCenter + vec2(offset), mercuryRotationAngle), mercuryRadius, mercuryColor);\n    offset += mercuryRadius + distBetweenPlantes;\n    fragColor += drawCircle( rotatePoint(sunCenter + vec2(offset), venusRotationAngle), venusRadius, venusColor);\n    offset += venusRadius + distBetweenPlantes;\n    fragColor += drawCircle( rotatePoint(sunCenter + vec2(offset), earthRotationAngle), earthRadius, earthColor);\n    offset += earthRadius + distBetweenPlantes;\n    fragColor += drawCircle( rotatePoint(sunCenter + vec2(offset), marsRotationAngle), marsRadius, marsColor);\n    offset += marsRadius + distBetweenPlantes;\n    fragColor += drawCircle( rotatePoint(sunCenter + vec2(offset), jupiterRotationAngle), jupiterRadius, jupiterColor);\n    offset += jupiterRadius + distBetweenPlantes;\n    fragColor += drawCircle( rotatePoint(sunCenter + vec2(offset), saturnRotationAngle), saturnRadius, saturnColor);\n    offset += saturnRadius + distBetweenPlantes;\n    fragColor += drawCircle( rotatePoint(sunCenter + vec2(offset), uranusRotationAngle), uranusRadius, uranusColor);\n    offset += uranusRadius + distBetweenPlantes;\n    fragColor += drawCircle( rotatePoint(sunCenter + vec2(offset), neptuneRotationAngle), neptuneRadius, neptuneColor);\n    offset += neptuneRadius + distBetweenPlantes;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlBW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 115, 115, 252], [254, 254, 301, 301, 562], [564, 564, 621, 621, 3654]], "test": "untested"}
{"id": "ltlBz2", "name": "Circle_Bullshit", "author": "lookezen", "description": "learning stuff", "tags": ["beginner"], "likes": 0, "viewed": 66, "published": "Public", "date": "1512576869", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool cirOL(vec2 center, float rad)\n{\n    return(length(center) < rad);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 col1 = vec4(1., 0., 0., 1.);\n    vec4 col2 = vec4(0., 0., 1., 1.);\n    float f = abs(sin(iTime));\n    int counter = 0;\n    \n    vec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    float c2 = 0.;\n    for(float i = -2.; i < 2.; i += 0.1)\n    { \t\n        c2+= 2.;\n        vec2 temp = r;\n        temp.x += i;\n        temp.y += sin(c2 * (iTime / 16.));\n        if(cirOL(temp, f)){ counter += 1; }\n    }\n    \n    if(counter % 2 == 0)\n    {\n        fragColor = col1;\n    }\n    else\n    {\n        fragColor = col2;\n    }\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlBz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 72], [74, 74, 131, 131, 679]], "test": "untested"}
{"id": "ltlfDs", "name": "General SDF", "author": "brisingre", "description": "http://people.tamu.edu/~ergun/research/implicitmodeling/papers/sm99.pdf", "tags": ["sdf"], "likes": 0, "viewed": 48, "published": "Public API", "date": "1514089410", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PHI = sqrt(5.0)*0.5 + 0.5;\n\nconst vec3 gdfVecs[19] = vec3[](\n    normalize(vec3(1,0,0)),\n    normalize(vec3(0,1,0)),\n    normalize(vec3(0,0,1)),\n    \n    normalize(vec3(1, 1, 1)),\n    normalize(vec3(-1, 1, 1)),\n    normalize(vec3(1, -1 , 1)),\n    normalize(vec3(1, 1, -1)),\n    \n    normalize(vec3(0, 1, PHI+1.0)),\n    normalize(vec3(0, -1, PHI + 1.0)),\n    normalize(vec3(PHI + 1.0, 0, 1)),\n    normalize(vec3(-PHI-1.0,0, 1)),\n    normalize(vec3(1, PHI+1.0, 0)),\n    normalize(vec3(-1, PHI+1.0, 0)),\n    \n    normalize(vec3(0, PHI, 1)),\n    normalize(vec3(0, -PHI, 1)),\n    normalize(vec3(1, 0, PHI)),\n    normalize(vec3(-1, 0, PHI)),\n    normalize(vec3(PHI, 1, 0)),\n    normalize(vec3(-PHI, 1, 0))\n    );\n\n\nfloat generalizedDF(vec3 point, float radius, int start, int end)\n{\n    float retval = 0.0;\n    for(int i = start; i <= end; i++)\n    {\n        retval = max(retval, abs(dot(point, gdfVecs[i])));\n    }\n    return retval - radius;\n}\n\nfloat generalizedDFExp(vec3 point, float radius, float exponent, int start, int end)\n{ \n    float retval = 0.0;\n    for(int i = start; i <= end; i++)\n    {\n        retval += pow(abs(dot(point, gdfVecs[i])), exponent);\n    }\n    return pow(retval, 1.0/exponent) - radius;\n    \n}\n\n//THIS IS WHERE YOU MESS AROUND WITH SHAPES\nfloat sceneSDF(vec3 point)\n{\n    float a = generalizedDFExp(point, 1.0, 60.0, 0, 2);\n    float b = generalizedDFExp(point.zyx, 1.0, 60.0, 3, 6);\n    float combine = min(a, b);\n    \n    float pipe = length(vec2(a, b )) - 0.02;\n    return b;\n    return min(a, min(b, pipe));\n    //return generalizedDFExp(point, 1.0, 15.0, 0,2);\n    //return length(point)-1.0;\n}\n\n\nvec3 diffuseColor(vec3 point)\n{\n    float dist = generalizedDFExp(point, 1.5, 60.0, 7, 18);\n    if(mod(dist * 5.0, 1.0) <0.5)\n    {\n        return vec3(0.2, 0.2, 0.2);\n    }\n    else\n    {\n        return vec3(0.7, 0.7, 0.7);\n    }\n}\n\n\n\n//Raymarching stuff\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float STEP_SCALE =1.0;\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 direction, float start, float end)\n{\n  float depth = start;\n    for(int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        float dist = sceneSDF(eye + depth * direction);\n        if(dist < EPSILON)\n        {\n            return depth;\n        }\n        depth += dist * STEP_SCALE;\n        if (depth >= end)\n        {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord){\n    vec2 xy = fragCoord - size/2.0;\n    float z = size.y/tan(radians(fieldOfView)/2.0);\n    return normalize(vec3(xy,-z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up)\n{\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    \n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n        );\n        \n        \n        \n}\n\nvec3 estimateNormal(vec3 p)\n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z-EPSILON))\n        ));\n}\n\nvec3 phongLight(vec3 diffuse, vec3 specular, float shiny, vec3 point,\n                vec3 eye, vec3 lightPos, vec3 lightCol)\n{\n    vec3 surfaceNormal = estimateNormal(point);\n    vec3 lightDir = normalize(lightPos - point);\n    vec3 viewDir = normalize(eye - point);\n    vec3 R = normalize(reflect(-lightDir, surfaceNormal));\n    \n    float dotLN = dot(lightDir, surfaceNormal);\n    float dotRV = dot(R, viewDir);\n    \n    if(dotLN < 0.0)\n    {\n        //light on the other side of the surface\n        return vec3(0.0, 0.0, 0.0);\n    }\n    \n    if(dotRV < 0.0)\n    {\n     //light reflecting away from the camera, no highlight\n        return lightCol * (diffuse * dotLN);\n    }\n    \n    return lightCol * (diffuse * dotLN + specular * pow(dotRV, shiny));\n}\n\nvec3 phongIllumination(vec3 ambient, vec3 diffuse, vec3 specular, float shiny, vec3 point, vec3 eye)\n{\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * ambient;\n    \n    //vec3 light1Pos = vec3(7.0 * sin(iTime), 2.0, 7.0 * cos(iTime));\n    vec3 light1Pos = vec3(7.0 * sin(7.), 2.0, 7.0 * cos(7.));\n    vec3 light1Col = vec3(0.8, 0.0, 0.7);\n    \n    color += phongLight(diffuse, specular, shiny, point, eye, light1Pos, light1Col);\n    \n    //vec3 light2Pos = vec3(7.0 * sin(iTime), -2.0 * sin(iTime * 0.1), 7.0 * cos(-0.5 * iTime));\n    vec3 light2Pos = vec3(7.0 * sin(7.), -2.0 * sin(7. * 0.1), 7.0 * cos(-0.5 * 7.));\n    vec3 light2Col = vec3(0.0, 0.6, 0.9);\n    \n    color += phongLight(diffuse, specular, shiny, point, eye, light2Pos, light2Col);\n        \n    //vec3 light3Pos = vec3(7.0 * cos(iTime * -.1), 4.0 * cos(iTime * 0.1), 7.0 * sin(-0.5 * iTime));\n    vec3 light3Pos = vec3(7.0 * cos(7. * -.1), 4.0 * cos(7. * 0.1), 7.0 * sin(-0.5 * 7.));\n    vec3 light3Col = vec3(0.9, 0.5, 0.0);\n    \n    color += phongLight(diffuse, specular, shiny, point, eye, light3Pos, light3Col);\n    \n    return color;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    fragColor = vec4(fragCoord, 0, 1);\n\t/*vec2 uv = fragCoord.xy / iResolution.yy;\n    vec3 point = vec3(uv, 0.5+0.5*sin(iTime));\n    \n    point *= vec3(5, 5, 10);\n    point -= vec3(4.5, 2.5, 5.0);\n    \n    \n    float dist = sceneSDF(point);\n    //float dist = generalizedDFExp(point, 1.0, 99.0, 0, 6);\n    \n    //vec3 color = dist < 0.0 ?\n    //    vec3(1,1,1) : point;\n  \n    vec3 color = vec3(dist);\n\tfragColor = vec4(color,1.0);*/\n    \n    vec3 viewDir = rayDirection(60.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(4.0 * sin(iTime * 0.5), 1.5 * sin(iTime), 4.0 * cos(iTime * 0.5));\n    //vec3 eye = vec3(4.0 * sin(7. * 0.5), 1.5 * sin(7.), 4.0 * cos(7. * 0.5));\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n  \n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n      \n    //fragColor = vec4(dist, dist * 0.1, dist * 0.01,1);\n    //return;\n    \n    if(dist > MAX_DIST - EPSILON)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n        \n        vec3 point = eye + dist * worldDir;\n        \n        //THIS IS WHERE YOU MESS AROUND WITH COLOR\n        vec3 diffuse = diffuseColor(point);\n        \n        vec3 ambient = vec3(0.2, 0.2, 0.2);\n        vec3 specular = diffuse  -vec3(0.1, 0.1, 0.1);\n        float shiny = 10.0 * specular.x;\n        \n        vec3 litColor = phongIllumination(ambient, diffuse, specular, shiny, point, eye);\n        \n        fragColor = vec4(litColor, 1.0);\n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlfDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[721, 721, 788, 788, 951], [953, 953, 1039, 1039, 1230], [1232, 1276, 1304, 1304, 1636], [1639, 1639, 1670, 1670, 1871], [1875, 2049, 2132, 2132, 2468], [2470, 2470, 2534, 2534, 2659], [2661, 2661, 2710, 2710, 2974], [2976, 2976, 3005, 3005, 3316], [3318, 3318, 3445, 3445, 4074], [4076, 4076, 4178, 4178, 5229], [5230, 5230, 5287, 5287, 6861]], "test": "untested"}
{"id": "ltlfWB", "name": "\"Lambert's problem\" in velocity", "author": "blalele", "description": "In white is the locus of the points where, starting with a velocity (1,0,0) and with an attraction body with mu = 1, the resulting Keplerian orbit include the point marked by the red cross.\n", "tags": ["orbitalmechanics"], "likes": 0, "viewed": 180, "published": "Public", "date": "1513252131", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float cosh_shad(in float ang) {\n    float res;\n    res = (exp(ang)+exp(-ang))/2.0;\n    return(res);\n}\n\nfloat sinh_shad(in float ang) {\n    float res;\n    res = (exp(ang)-exp(-ang))/2.0;\n    return(res);\n}\n\nfloat atanh_shad(in float ang) {\n    float res;\n    res = log((1.0+ang)/(1.0-ang))/2.0;\n    return(res);\n}\n\nfloat acosh_shad(in float ang) {\n    float res;\n    res = log(ang + sqrt(ang*ang-1.0));\n    return(res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = 3.1415927;\n    vec3 Vc = vec3(1.0,0.0,0.0);\n    float mu = 1.0;\n    float size = 0.1;\n    vec3 posvis = vec3(0.5*cos(iTime),0.5*sin(iTime),0.0);\n    \n    float maxdim = max(iResolution.x,iResolution.y);\n    float mindim = min(iResolution.x,iResolution.y);\n    float rat = mindim/maxdim;\n\tvec3 uv = vec3(fragCoord.xy,0.0) / maxdim;\n    vec3 X = 8.0*(uv - vec3(0.5,rat/2.0,0.0));\n    vec3 h = cross(X, Vc);\n    float hnorm = length(h);\n    float r = length(X);\n    float vel = length(Vc);\n    float sE = vel*vel/2.0 - mu/r;\n    float SMA = - mu/(2.0*sE);\n    float mean_mo = sqrt(mu/pow(abs(SMA),3.0));\n    vec3 Ecv = cross(Vc,h)/mu - X/r;\n    float ECC = length(Ecv);\n    float arglat;\n    float INC;\n    if (h.z>0.0)\n    {arglat = 2.0*pi+atan(X.y,X.x);\n     INC = 0.0;}\n    else\n    {arglat = 2.0*pi-atan(X.y,X.x);\n     INC = pi;}\n    float LPE = 0.0;\n    float MNA = 0.0;\n    float minax = 0.0;\n    float N;\n    float M = 0.0;\n    float E;\n    float nE;\n    float nH;\n    vec3 nX;\n    vec3 nVc;\n    float nr;\n    float nu = 0.0;\n    float nnu;\n    float ntest;\n    float Etest;\n    float f;\n    float cosnu;\n    if (ECC>0.0000001)\n    {\n        cosnu = (SMA*(1.0-ECC*ECC)-r)/(ECC*r);\n        if (cosnu>1.0)\n        {cosnu = 1.0;}\n        else\n        {if (cosnu<-1.0) {cosnu=-1.0;}}\n        if (dot(X,Vc)>0.0)\n        {nu = acos(cosnu);}\n        else\n        {nu = 2.0*pi-acos(cosnu);}\n        LPE = mod(arglat - nu, 2.0*pi);\n        if (sE<0.0)\n        {\n            E = mod(2.0*atan(sqrt(1.0-ECC)*sin(nu/2.0),sqrt(1.0+ECC)*cos(nu/2.0)),2.0*pi);\n            MNA = E - ECC*sin(E);\n            minax = SMA*sqrt(1.0-ECC*ECC);\n        }\n        else\n        {\n            E = 2.0*atanh_shad(sqrt((ECC-1.0)/(1.0+ECC))*tan(nu/2.0));\n            MNA = ECC*sinh_shad(E)-E;\n            minax = SMA*sqrt(ECC*ECC-1.0);\n        }\n    }\n    else\n    {\n    \tvec3 r_un = normalize(X);\n    \tcosnu = dot(vec3(1.0,0.0,0.0),r_un);\n        LPE = 0.0;\n        if (X.y>0.0)\n        {MNA = acos(cosnu);}\n        else\n        {MNA = 2.0*pi-acos(cosnu);}\n    }\n    mat3 mat_rot = mat3(\n        cos(LPE), sin(LPE)*cos(INC), 0.0,\n        -sin(LPE), cos(LPE)*cos(INC), 0.0,\n        0.0, 0.0, cos(INC)\n    );\n    vec3 posvisO = posvis*mat_rot + vec3(SMA*ECC,0.0,0.0);\n    bool touch = false;\n    \n    if (sE<0.0)\n    \t{touch = (abs(pow(posvisO.x/SMA,2.0)+pow(posvisO.y/minax,2.0)-1.0)<(0.02/abs(SMA)));}\n    else\n        {touch = (abs(pow(posvisO.x/SMA,2.0)-pow(posvisO.y/minax,2.0)-1.0)<(0.02/abs(SMA)));}\n    \n    float per = (1.0-ECC)*SMA;\n    bool crashed;\n    \n    if (touch)\n    {fragColor = vec4(1.0,1.0,1.0,1.0);}\n    else\n    {fragColor = vec4(0.0,0.0,0.0,1.0);}\n    \n    \n    //fragColor = vec4(atan(nX)/pi+vec3(0.5,0.5,0.0),1.0);\n    //fragColor = vec4(atan(nr)*2.0/pi,0.0,0.0,1.0);\n    //if (crashed)\n    //{fragColor = vec4(0.0,1.0,1.0,1.0);}\n    if (length(X-vec3(0.0,0.0,0.0))<size)\n    {fragColor = vec4(0.0,0.0,1.0,1.0);}\n    if (((abs(X.x-posvis.x)<0.01)&&(abs(X.y-posvis.y)<0.05))||((abs(X.x-posvis.x)<0.05)&&(abs(X.y-posvis.y)<0.01)))\n    {fragColor = vec4(1.0,0.0,0.0,1.0);}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlfWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 101], [103, 103, 134, 134, 204], [206, 206, 238, 238, 312], [314, 314, 346, 346, 420], [422, 422, 479, 479, 3565]], "test": "untested"}
{"id": "ltlfWl", "name": "CJ textureLod() failure", "author": "chrisjj", "description": "On Firefox WebGL GLSL ES 3.00, fails with \"textureLod no matching function found\"", "tags": ["test"], "likes": 0, "viewed": 173, "published": "Public", "date": "1514028188", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   // iChannel source is ST default\n    vec2 rg = textureLod( iChannel0, fragCoord/256.0, 0. ).yx;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlfWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 94, 250]], "test": "untested"}
{"id": "ltsBzl", "name": "Rainbow Sandwich", "author": "Ultraviolet", "description": "WIP\nCube of layered monochrome material absorbing light.\nClick to control view", "tags": ["cube", "rainbow", "box", "absorption"], "likes": 49, "viewed": 432, "published": "Public", "date": "1513000981", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI\t\t\t\t3.1415926535\n#define ABSORBANCE\t\t1.0\n#define LIGHT_DIR\t\tnormalize(vec3(cos(-iTime*.3+PI*.5), 1.0, sin(-iTime*.3+PI*.5)))\n#define CAM_POS \t\tvec3(4.*cos(-iTime*.3), 4.0, 4.*sin(-iTime*.3))\n\n// credit : http://www.iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 boxIntersection( vec3 ro, vec3 rd, vec3 boxSize, mat4 txx, out vec3 outNormal )\n{\n    // convert from ray to box space\n    vec3 rdd = (txx*vec4(rd,0.0)).xyz;\n    vec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*boxSize;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\n    if( tN > tF || tF < 0.0) return vec2(-1.0); // no intersection\n\n    outNormal = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    \n    float t = (-0.-ro.y)/rd.y;\n    \n    //t = 100.0;\n    \n    \n    if(t<0.)\n    \tt = 10000.;\n    \n    vec3 col = mix(vec3(0.9), vec3(0.5,0.6,0.9), 1.-exp(-0.05*t));\n    \n    vec3 n;    \n    \n    vec3  color[6]     = vec3[](\n        vec3(1., 0., 0.), \n        vec3(1., 1., 0.), \n        vec3(0., 1., 0.), \n        vec3(0., 1., 1.), \n        vec3(0., 0., 1.), \n        vec3(1., 0., 1.));\n    \n    vec3 size = vec3(1., 1./6., 1.);\n    mat4 txx = mat4(1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1., 0., 0. , 0., 0., 1.);\n    \n    \n    if(t < 100.)\n    {\n    \tvec3 roo = ro+rd*t;\n    \tvec3 rdd = LIGHT_DIR;\n        vec3 lightCol = vec3(1.);\n        \n        \n        for(int k = 0; k<6; ++k)\n        {\n            int kk = rdd.y<0.?k:5-k;\n            txx[3].y = -1.0/6.-2./6.*float(kk);\n            vec2 tnf = boxIntersection(roo, rdd, size, txx, n);\n            float depth = max(0., min(t,tnf.y)-max(0., tnf.x));\n            lightCol = mix(lightCol, vec3(0.0), 1.-exp(-ABSORBANCE*depth*color[kk]));\n        }\n        \n    \tcol *= lightCol;\n    }\n    \n    \n    \n    \n    for(int k = 0; k<6; ++k)\n    {\n        int kk = rd.y<0.?k:5-k;\n        txx[3].y = -1.0/6.-2./6.*float(kk);\n        vec2 tnf = boxIntersection(ro, rd, size, txx, n);\n        float depth = max(0., min(t,tnf.y)-max(0., tnf.x));\n        //float depth = tnf.y - tnf.x;\n        col = mix(col, color[kk], 1.-exp(-ABSORBANCE*depth));\n        //col = mix(col, col*color[kk], 1.-exp(-ABSORBANCE*depth));\n    }\n    \n    return col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n        \n    float phi = (iMouse.x-0.5)/iResolution.x * PI * 2.0;\n    float psi = -((iMouse.y-0.5)/iResolution.y-0.5) * PI;\n    \n    if(iMouse.x<1.0 && iMouse.y < 1.0)\n    {\n        phi = iTime * PI * 2.0*0.1;\n        psi = cos(iTime*PI*2.0*0.1)*PI*0.25;\n    }\n    \n    vec3 ro = 5.0*vec3(cos(phi)*cos(psi), sin(psi), sin(phi)*cos(psi));\n    if(iMouse.z < 0.5)\n        ro = CAM_POS;\n    vec3 ta = vec3(0., .5, .0);\n    mat3 m = setCamera(ro, ta, 0.0);\n\t\n    vec3 rd = m*normalize(vec3(p, 2.));\n    \n    // scene rendering\n    vec3 col = render( ro, rd);\n    \n    // gamma correction\n    col = sqrt(col);\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltsBzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 284, 370, 407, 863], [865, 865, 902, 902, 2394], [2397, 2397, 2449, 2449, 2626], [2628, 2628, 2685, 2685, 3390]], "test": "untested"}
{"id": "ltsfRB", "name": "Scrolling through 1/z", "author": "DrLuke", "description": "Just some complex foo", "tags": ["complex", "scrolling", "1z"], "likes": 0, "viewed": 406, "published": "Public API", "date": "1512389410", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under a Creative Commons Attribution 4.0 International License.\n// https://creativecommons.org/licenses/by/4.0/\n\n\n// Thanks to: https://www.shadertoy.com/view/llXBDH\n\nvec2 cexp(vec2 z)\n{\n    return exp(z.x) * vec2(cos(z.y), sin(z.y));\n}\n\nvec2 clog(vec2 z)\n{\n    return vec2(log(length(z)), atan(z.y, z.x));\n}\n\nvec2 cpow(vec2 z, float p)\n{\n    return cexp(clog(z) * p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy *2.) / iResolution.xy - vec2(1);\n    \n    uv *= 1.;\n    \n    float tspeed = 0.4;\n    float t = iTime * tspeed;\n    \n    vec2 graduv = -cpow(uv.yx, -2.);\t// Gradient is -1/z² \n    uv = cpow(uv, -1.);\t\t\t\t\t// Function is 1/z\n    \n    uv += t;\t\t\t// Scroll view \n    \n    float dex = fract(length(uv.x));\t// Get x isolines\n    float dey = fract(length(uv.y));\t// Get y isolines\n    \n    // Increase width with increasing gradient (aka the lines get denser) to reduce aliasing problems\n    #define W (sqrt(length(graduv))*0.02)\n    \n    float linex = smoothstep(0.5 - W, 0.5, dex) - smoothstep(0.5, 0.5 + W, dex);\n    float liney = smoothstep(0.5 - W, 0.5, dey) - smoothstep(0.5, 0.5 + W, dey);\n    \n\tfragColor = vec4(vec3(linex + liney), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltsfRB.jpg", "access": "shaders20k", "license": "cc-by-4.0", "functions": [[139, 192, 211, 211, 261], [263, 263, 282, 282, 333], [335, 335, 363, 363, 395], [397, 397, 454, 454, 1220]], "test": "untested"}
{"id": "ltsfWs", "name": "Shader Showdown r2 (Cookie 2017)", "author": "lsdlive", "description": "Copy of my shader at Shader Showdown Cookie 2017 (round 2).\nPorted from Bonzomatic.\n\nAll competitor's shaders here:\nhttps://github.com/KoltesDigital/Shader-Showdown-Paris/tree/master/2017-12-08\nhttps://www.youtube.com/watch?v=ugs3-B3Tng0", "tags": ["raymarching", "demoparty", "showdown"], "likes": 7, "viewed": 219, "published": "Public", "date": "1514067698", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All competitor's shaders here:\n// https://github.com/KoltesDigital/Shader-Showdown-Paris/tree/master/2017-12-08\n// https://www.youtube.com/watch?v=ugs3-B3Tng0\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat de(vec3 p) {\n\n\t//p.xy *= r2d(1/1e5*fGlobalTime);\n\n\tp.x = abs(p.x) - 25.;\n\n\tp.xz *= r2d(3.14 / 4.);\n\n\tp = mod(p + 30., 60.) - 30.;\n\n\tvec3 q = p;\n\n\tp.y += sin(p.x*3.);\n\n\tfloat r = 15. + 3. * pow(.5 + .5*sin(15. * iTime), 4.);\n\n    // iq's heart formula: https://www.youtube.com/watch?v=aNR4n0i2ZlM\n\tp.z *= 2. - p.y / 15.;\n\tp.y = 4. + 1.2 * p.y - abs(p.x) * sqrt(max((20. - abs(p.x)) / 15., 0.));\n\n\tfloat sph = length(p) - r;\n\tfloat sph2 = length(q) - 9.;\n\n\tq.y -= 7.;\n\tq.x -= 7.;\n\tfloat sph4 = length(q.xy + cos(iTime)) - 3.;\n\tq.x += 14.;\n\tfloat sph5 = length(q.xy - cos(iTime)) - 3.;\n\n\tfloat d = max(sph, -sph2);\n\td = max(d, -sph4);\n\td = max(d, -sph5);\n\n\treturn d / 3.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n\tvec3 ro = vec3(cos(iTime) * 20., iTime * 50., -50. * sqrt(abs(tan(iTime))));\n\tvec3 rd = normalize(vec3(uv, -1)), p;\n\tp = ro;\n\n\tfloat it = 0.;\n\tfor (float i =0.; i < 1.; i += .01) {\n\t\tit = i;\n\t\tfloat d = de(p);\n\t\tif (d < .01) break;\n\t\tp += rd*d;\n\t}\n\n\tvec3 c = mix(vec3(.9, .3, .5), vec3(.2, .1, .2), it);\n\tc = mix(c, vec3(.2, .1, .2), 1. - exp(-.005 * length(ro - p)));\n\n\tfragColor = vec4(c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltsfWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 163, 182, 182, 242], [244, 244, 262, 298, 920], [922, 922, 977, 977, 1477]], "test": "untested"}
{"id": "ltSfzR", "name": "Hypno Circles", "author": "n1kk", "description": "Just look at the dot in the middle.", "tags": ["waves", "circles", "hypno"], "likes": 1, "viewed": 76, "published": "Public", "date": "1514251400", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define UV_CENTERIZE true\n#define UV_SIZE 1.2\n\n// this will adapt smoothing values to different resolutions\n#define UV_DENSITY (UV_SIZE/iResolution)\n\n// ----- CIRCLE \n// fill\nfloat g_circle_fill(vec2 p, vec2 center, float radius)\n{\n\treturn smoothstep(radius + UV_DENSITY.x * 5., radius, length(p - center));\n}\n\n// line \nfloat g_circle_line(vec2 p, vec2 center, float radius, float th)\n{\n    float delta = UV_DENSITY.x * 5.;\n    float rad1 = radius - th;\n    float rad2 = radius + th;\n    float l = length(p - center);\n\treturn min(smoothstep(rad1 - delta, rad1, l),\n              smoothstep(rad2 + delta, rad2, l));\n}\n\nfloat g_circle_line(vec2 p, vec2 center, float radius){\n\treturn g_circle_line(p, center, radius, 0.); \n}\n\n// ------ POLAR\n\nvec2 plr(float x, float y) { return vec2(length(vec2(x, y)), atan(y, x)); }\nvec2 plr(vec2 p) { return plr(p.x, p.y); }\n\n// ------ MATH\n\n#define snap(v,s) (round(v/s) * s)    \n\n// ----- MAIN_IMAGE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    // origin\n    if (UV_CENTERIZE) {\n        uv = -UV_SIZE + 2. * UV_SIZE * uv;\n        uv.x *= iResolution.x / iResolution.y;\n    }\n    \n    vec2 p = plr(uv);\n    vec4 O = vec4(0.);\n    \n    vec3 c_red = vec3(1., .3, .3);\n    \n    float st1 = 0.05;\n    \n    float dt1 = mod(iTime * .1, st1);\n    float sdt1 = (dt1 < 0.05 ? dt1 : .1 - dt1) ;\n\n    for (float i = -1.; i < 2.; i += 1.)\n    \tO.rgb += c_red * g_circle_line(uv, vec2(0.), snap(p.x, st1) + st1*i + dt1);\n    \n    //O.rgb = max(O.rgb, c_red * g_circle_fill(uv, vec2(0.), .01 + sdt1));\n    \n\tfragColor = O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltSfzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 175, 231, 231, 309], [311, 320, 386, 386, 616], [618, 618, 673, 673, 722], [724, 741, 769, 769, 816], [817, 817, 835, 835, 859], [917, 938, 995, 995, 1606]], "test": "untested"}
{"id": "ltXBRX", "name": "Mipumi Games", "author": "xx3000", "description": "Distance field logo of the amazing game company I am a part of.", "tags": ["distancefields", "logo", "webcam", "gamedev", "mipumi"], "likes": 1, "viewed": 292, "published": "Public", "date": "1512663126", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define WEBCAM 0 //set to 1 if you have a webcam\n#define ANIMATION_LENGTH 30.0\n\n#define PI 3.14159265\n\nfloat ns,ns2;\nfloat anim1;\n\nfloat insideSuperEllipse(vec2 uv, float a, float b, float n)\n{\nreturn pow(abs(uv.x/a),n)+pow(abs(uv.y/b),n) - 1.0;\n\n}\n\n\nvec2 Rotate(vec2 p, float rad)\n{\n    mat2 rot = mat2(cos(rad),-sin(rad),sin(rad),cos(rad));\n    return p*rot;\n}\n\nvec2 Move(vec2 from, vec2 to)\n{\n \treturn from-to;   \n}\n\nfloat Merge ( float a, float b)\n{\n    return min(a,b);\n}\n\nfloat Subtract ( float a, float b)\n{\n    return max(-a,b);\n}\n\n\n\n//Voronoise by IQ\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat noise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    float k = 1.0 + 63.0*pow(1.0-v,4.0);\n    float va = 0.0;\n    float wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec3  o = hash3( p + g )*vec3(u,u,1.0);\n        vec2  r = g - f + o.xy;\n        float d = dot(r,r);\n        float w = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n        va += w*o.z;\n        wt += w;\n    }\n\n    return va/wt;\n}\n\n\n\nfloat box(in vec2 p, vec2 size)\n        {\n            vec2 d = (abs(p) - size);\n            return ((min(max(d.x , d.y ), 0.0) + length(max(d, vec2(0.0)))));\n        }\n\nfloat triangle(vec2 p, float width, float height)\n        {\n            vec2 n = normalize(vec2(height, width * 0.5));\n            return max(abs(p).x * n.x + (p.y * n.y) - (height * n.y), -p.y);\n        }\n\nfloat disc(in vec2 p, in float radius)\n        {\n            return (length(p ) - radius);\n        }\n\nfloat ellipse(vec2 p,float rad, float offset,float ns1 )\n{\n    offset = rad-offset;\n    float left =Subtract(box(p-vec2(2,0),vec2(2.0,20.0)),disc(p-vec2(offset,0.0),rad)+ns1);\n    float right =Subtract(box(p+vec2(2,0),vec2(2.0,20.0)),disc(p+vec2(offset,0.0),rad)+ns1);\n    return Merge(left,right);\n}\n\nfloat RenderLeafStem(vec2 uv, vec2 pos)\n{\n    uv= Move(uv,pos);\n    uv.x += sin(uv.y*8.0)*0.003;\n    float eli= ellipse(uv,15.0*anim1,0.02,ns*0.5);\n    float cutout = Subtract(-(uv.y-0.42),eli);\n    cutout = Subtract((uv.y+0.45),cutout);\n    return cutout;\n}\n\n\nfloat RenderLeafRaw(vec2 uv, float mul)\n{\n    float ns1 = ns*0.5;\n    \n    float outer1 = ellipse(uv,0.4*anim1,0.2,ns1);\n    float outer2 = ellipse(uv-vec2(0.01,-0.01),0.35*anim1,0.17,ns1);\n    float outerCut = Subtract(outer2,outer1);\n    return outerCut;\n}\n\nfloat RenderLeaf(vec2 uv, vec2 pos, float rot)\n{\n    uv= Move(uv,pos);\n   \tuv= Rotate(uv,rot);  \n\tfloat outer = RenderLeafRaw(uv,1.0);\n    \n    float stem = RenderLeafStem(uv,vec2(0.0,0.15));\n    return Merge(outer,stem);\n}\n\n\nfloat RenderFirstStem(vec2 uv, vec2 pos)\n{\n    uv= Move(uv,pos);\n    float eli = ellipse(uv,3.0*anim1,0.02,ns2*0.5);\n    float cutout = Subtract((uv.y+0.1)*15.0,eli);\n    return cutout;\n}\n\nfloat RenderStem(vec2 uv, vec2 pos)\n{\n    uv= Move(uv,pos);\n    float eli = ellipse(uv,1.0*anim1,0.02,ns2*0.5);\n    float cutout = Subtract((uv.y+0.1)*15.0,eli);\n    return cutout;\n}\n\nfloat RenderLongStem(vec2 uv, vec2 pos)\n{\n     uv= Move(uv,pos);\n    uv.x += sin(uv.y*8.0)*0.002;\n    float eli = ellipse(uv,30.0*anim1,0.02,ns2*0.4);\n    float cutout = Subtract((uv.y+0.75),eli);\n    cutout = Subtract(-(uv.y-0.8),eli);\n    return cutout;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n\t\n    float introLength = ANIMATION_LENGTH;\n   \n   // e = 2.0/iResolution.y;\n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n     \n    float lum=1.0;\n    #if WEBCAM\n    vec4 cam = texture(iChannel0,uv2);\n    lum =cam.x+cam.y+cam.z/3.0;\n    #endif\n    //fragColor= vec4(lum,lum,lum,1.0);\n    //return;\n    \n    //uv.y-=1.0;\n    \n    float time = mod(iTime,introLength);\n    anim1=min(1.0,time*0.1);\n    float outroTime = max((time-(introLength-10.0))*5.0,1.0);\n\n   \n    \n    vec4 bg = vec4(1.0,1.0,1.0,1.0);\n    vec4 fg = vec4(0.0,0.27059,0.476275,1.0);\n    \n    \n    lum-=0.7;\n    lum=clamp(lum*99999999.0,0.0,1.0);\n    bg-= (1.0-lum)*0.05;\n    \n    \n    //uv.x+=sin(uv.y+time)*(1.0-lum)*0.1;\n    lum= 1.0-lum;\n    ns =noise(120.0*uv+vec2(0,-iTime*max(1.0,lum*5.0)),1.0,1.0)*(0.03+lum*0.03);\n    ns2 =noise(120.0*uv+vec2(-iTime*0.5*max(1.0,lum*5.0),-iTime*max(1.0,lum*5.0)),1.0,1.0)*(0.03+lum*0.03);\n    \n    float spacingX = 3.0/10.0;\n    float startX = -1.3;\n    float leaves =-9999999.9;\n    \n    float stemanimSpeed = 0.3;\n    \n    \n    vec2 grp1 = vec2(-0.7,0.4);\n    anim1=min(1.0,time*stemanimSpeed-1.2);\n    leaves = RenderLeaf(uv,grp1+vec2(-0.4,0.0),PI*0.75);\n    anim1=min(1.0,time*stemanimSpeed-1.4);\n    leaves = Merge(leaves,RenderLeaf(uv,grp1+vec2(0.4,0.2),PI*-0.75));\n    \n    anim1=min(1.0,time*stemanimSpeed-0.3);\n    leaves = Merge(leaves,RenderLongStem(uv,vec2(startX+spacingX*2.0,-0.15)));\n    \n    \n    vec2 grp2 = vec2(0.8,0.1);\n    anim1=min(1.0,time*stemanimSpeed-1.6);\n    leaves = Merge(leaves,RenderLeaf(uv,grp2+vec2(-0.4,0.0),PI*0.75)); \n    anim1=min(1.0,time*stemanimSpeed-1.8);\n    leaves = Merge(leaves,RenderLeaf(uv,grp2+vec2(0.4,0.3),PI*-0.75));\n\n    anim1=min(1.0,time*stemanimSpeed-0.8);\n    leaves = Merge(leaves,RenderLongStem(uv,vec2(startX+spacingX*7.0,-0.2)));\n\n    \n    float leafanimSpeed = 0.3;\n  \n    anim1=min(1.0,time*leafanimSpeed-0.0);\n    leaves = Merge(leaves,RenderFirstStem(uv,vec2(startX+spacingX*0.0,-0.8))); \n    anim1=min(1.0,time*leafanimSpeed-0.1);\n    leaves = Merge(leaves,RenderStem(uv,vec2(startX+spacingX*1.0,-0.8)));\n\n    anim1=min(1.0,time*leafanimSpeed-0.3);\n    leaves = Merge(leaves,RenderStem(uv,vec2(startX+spacingX*3.0,-0.8)));\n    anim1=min(1.0,time*leafanimSpeed-0.4);\n    leaves = Merge(leaves,RenderStem(uv,vec2(startX+spacingX*4.0,-0.8)));\n    anim1=min(1.0,time*leafanimSpeed-0.5);\n    leaves = Merge(leaves,RenderStem(uv,vec2(startX+spacingX*5.0,-0.8)));\n    anim1=min(1.0,time*leafanimSpeed-0.6);\n    leaves = Merge(leaves,RenderStem(uv,vec2(startX+spacingX*6.0,-0.8)));\n\n    anim1=min(1.0,time*leafanimSpeed-0.8);\n    leaves = Merge(leaves,RenderStem(uv,vec2(startX+spacingX*8.0,-0.8))); \n    anim1=min(1.0,time*leafanimSpeed-0.9);\n    leaves = Merge(leaves,RenderStem(uv,vec2(startX+spacingX*9.0,-0.8)));\n\n    fragColor=vec4(ns,ns,ns,1.0)*20.0;\n    //return;\n    \n    //leaves-= (1.0-lum)*0.1;\n    \n    //bg= mix(fg,bg,smoothstep(0.00,0.005,leaves));\n    //leaves-=max((time-(introLength-10.0))*0.05,0.0)*ns;\n    \n    if(leaves <=0.0)\n    {\n    bg= mix(vec4(0.0,0.27059,0.476275,1.0),bg,max((time-(introLength-1.0)),0.0));\n    // bg = vec4(-leaves*1.0,0.0,0.0,1.0);   \n     }\n    \n    \n\tfragColor = bg;\n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltXBRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 132, 194, 194, 249], [252, 252, 284, 284, 363], [365, 365, 396, 396, 419], [421, 421, 454, 454, 477], [479, 479, 515, 515, 539], [543, 561, 583, 583, 734], [736, 736, 780, 780, 1258], [1262, 1262, 1303, 1303, 1429], [1431, 1431, 1490, 1490, 1636], [1638, 1638, 1686, 1686, 1738], [1740, 1740, 1798, 1798, 2040], [2042, 2042, 2083, 2083, 2300], [2303, 2303, 2344, 2344, 2561], [2563, 2563, 2611, 2611, 2786], [2789, 2789, 2831, 2831, 2976], [2978, 2978, 3015, 3015, 3160], [3162, 3162, 3203, 3203, 3419], [3421, 3421, 3478, 3478, 6725]], "test": "untested"}
{"id": "ltXfDl", "name": "PaperColor's Waterfall 001", "author": "PaperColor", "description": "Waterfall ", "tags": ["waterfall"], "likes": 2, "viewed": 598, "published": "Public API", "date": "1513864021", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.141592654\n#define tao 2.0*pi\n\n#define bgColor vec4(0,0.2,0.4,1.0)\n#define waterColor vec4(1.0,1.0,1.0,1.0)\n\n#define lineNumber 5.0\n\nfloat lerp(float a,float b,float v)\n{\n\t//clamp to 0 and 1\n\tif(v>1.0) v=1.0;\n\telse if(v<0.0) v=0.0;\n\treturn a*(1.0-v)+b*v;\n}\n\nvec4 lerp(vec4 a,vec4 b,float v)\n{\n\tfloat red = lerp(a.r,b.r,v);\n\tfloat green = lerp(a.g,b.g,v);\n\tfloat blue = lerp(a.b,b.b,v);\n\tfloat alpha = lerp(a.a,b.a,v);\n\treturn vec4(red,green,blue,alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x*=iResolution.x/iResolution.y; \n    uv.x -= 0.35;\n    \n    float dx = sin(uv.y*tao*lineNumber+iTime*10.0)*0.6*pow(uv.y,.1);//+iTime*10.0)\n    \n    float value = sin(uv.x*tao*lineNumber*5.0+dx);\n\t\n    fragColor = lerp(bgColor,waterColor,value);\n}\n\n//Basic\n\n//void mainImage( out vec4 fragColor, in vec2 fragCoord )\n//{\n//\tvec2 uv = fragCoord.xy / iResolution.xy;\n//    uv.x*=iResolution.x/iResolution.y; \n//    uv.x -= 0.35;\n    \n//    float value = sin(uv.x*tao*lineNumber*5.0+sin(uv.y*tao*lineNumber+iTime*10.0));\n//    fragColor = vec4(value,value,value,.5);\n//}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltXfDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 182, 202, 268], [270, 270, 304, 304, 467], [469, 469, 526, 526, 822]], "test": "untested"}
{"id": "ltXfzl", "name": "Joy In Repetition", "author": "Del", "description": "Joy In Repetition - Flower loading animation... (added a box merge on mouse)", "tags": ["2d", "sdf", "flower", "mod", "polar", "lit"], "likes": 9, "viewed": 195, "published": "Public", "date": "1512881352", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 2d sdf + lighting code taken from https://www.shadertoy.com/view/MsXBWH by wutzhuhn\n// repeating flowers added by Del 10/12/17\n#define roundnes 0.035\n\n#define PI 3.14159265\n#define DEG2RAD ((PI * 2.0) / 360.0)\n\nfloat subtract(float a, float b)\n{\n\treturn min(max(a, -b), -roundnes) + length(max(vec2(roundnes) + vec2(a, -b), vec2(0.0)));\n}\n\nfloat merge(float a, float b)\n{\n\treturn max(min(a, b), roundnes) - length(max(vec2(roundnes) - vec2(a, b), vec2(0.0)));\n}\n\nmat2 rotate(float a)\n{\n    float sa = sin(a), ca = cos(a);\n\treturn mat2(ca, -sa, sa, ca);\n}\n\nfloat box(vec2 p, vec2 size)\n{\n\tvec2 d = abs(p) - size + roundnes;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - roundnes;\n}\n\n\n// http://mercury.sexy/hg_sdf/\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions)\n{\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// render 16 flowers with 9 petals each...\nfloat shapeDist(vec2 p)\n{\n    float d1 = box(p+vec2(0.0,0.0), vec2(1.0, 1.0));\t\t// main box to subtract\n    vec2 p2 = p * rotate(iTime*0.25*PI);\n    float offset = pModPolar(p2,16.0);\n    vec2 p3 = (p2-vec2(0.45,0.0)) * rotate(iTime*0.8);\n\tpModPolar(p3,9.0);    \n    float d2 = box(p3-vec2(0.05,0.0), vec2(0.04, 0.02));\n    \n    // Mouse click box! :)\n    if (iMouse.z>0.5)\n    {\n        vec2 mousep = (  iMouse.xy -.5*iResolution.xy ) / iResolution.y;\n        float d4 = box(p-mousep,vec2(0.1,0.1));\n        d2 = merge(d2,d4);\n    }\n    \n    float dist = subtract(d1,d2);\n    return dist;\n}\n\nfloat maskSharp(vec2 p)\n{\n    return clamp(shapeDist(p) * 100.0, 0.0, 1.0);\n}\n\nfloat maskBlurry(vec2 p)\n{\n    return clamp((shapeDist(p ) + 0.003) * 75.0, 0.0, 1.0);\n}\n\nvec3 normalAt(vec2 p)\n{\n    float ps = 1.0 / iResolution.x;\n    float x = maskBlurry(p - vec2( ps, 0.0)) - maskBlurry(p + vec2( ps, 0.0));\n    float y = maskBlurry(p - vec2(0.0,  ps)) - maskBlurry(p + vec2(0.0,  ps));\n    return normalize(vec3(x, y, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = ( fragCoord -.5*iResolution.xy ) / iResolution.y;\n    vec3 color = vec3(0.1,0.3,0.1);\n    \n    float val = maskSharp(p);\n    float shade = 0.0;\n    if (val>0.0)\n    {\n        float z = (0.5+sin(iTime*3.5))*0.1;\n        vec3 lightPos = vec3(0.0, 0.0, 0.2+z);\n        vec3 toLight = lightPos - vec3(p, 0.0);\n        vec3 normal = normalAt(p);\n\t\tshade = 0.3 + maskSharp(p) * 0.7;\n        float col = clamp(dot(normalize(toLight), normal), 0.0, 1.0) / length(toLight) * shade;\n        color = vec3(0.6,0.2,0.9)*col;\n    }\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltXfzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 214, 248, 248, 341], [343, 343, 374, 374, 464], [466, 466, 488, 488, 557], [559, 559, 589, 589, 695], [698, 842, 892, 892, 1282], [1284, 1327, 1352, 1352, 1918], [1920, 1920, 1945, 1945, 1997], [1999, 1999, 2025, 2025, 2087], [2089, 2089, 2112, 2112, 2347], [2349, 2349, 2404, 2404, 2965]], "test": "untested"}
{"id": "MlfBRB", "name": "Hyperspace Perlin Red", "author": "BenWheatley", "description": "A slowly morphing hyperspace tunnel. Fairly basic Perlin noise, my idea of a decent Hello World in GLSL.", "tags": ["procedural", "perlinnoise"], "likes": 6, "viewed": 355, "published": "Public", "date": "1512260315", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * \"Hyperspace\" by Ben Wheatley - 2017\n * License MIT License\n * Contact: github.com/BenWheatley\n */\n\n// constants\nconst int MAX_OCTAVE = 8;\nconst float PI = 3.14159265359;\nconst float centerToCorner = sqrt((0.5*0.5) + (0.5*0.5));\nconst float tangentScale = PI / (2.0*centerToCorner);\nconst float thetaToPerlinScale = 2.0 / PI;\n\nfloat cosineInterpolate(float a, float b, float x) {\n\tfloat ft = x * PI;\n\tfloat f = (1.0 - cos(ft)) * 0.5;\n\t\n\treturn a*(1.0-f) + b*f;\n}\n\nfloat seededRandom(float seed) {\n    int x = int(seed);\n    x = x << 13 ^ x;\n    x = (x * (x * x * 15731 + 789221) + 1376312589);\n    x = x & 0x7fffffff;\n    return float(x)/1073741824.0;\n}\n\n// The magic constants are essentially arbitary:\n// they define the scale of the largest component of the Perlin noise\nfloat perlinNoise(float perlinTheta, float r, float time) {\n    float sum = 0.0;\n    for (int octave=0; octave<MAX_OCTAVE; ++octave) {\n        float sf = pow(2.0, float(octave));\n        float sf8 = sf*64.0; // I can't remember where this variable name came from\n        \n\t\tfloat new_theta = sf*perlinTheta;\n        float new_r = sf*r/4.0 + time; // Add current time to this to get an animated effect\n\t\t\n        float new_theta_floor = floor(new_theta);\n\t\tfloat new_r_floor = floor(new_r);\n\t\tfloat fraction_r = new_r - new_r_floor;\n\t\tfloat fraction_theta = new_theta - new_theta_floor;\n        \n        float t1 = seededRandom( new_theta_floor\t+\tsf8 *  new_r_floor      );\n\t\tfloat t2 = seededRandom( new_theta_floor\t+\tsf8 * (new_r_floor+1.0) );\n        \n        new_theta_floor += 1.0;\n        float maxVal = sf*2.0;\n        if (new_theta_floor >= maxVal) {\n            new_theta_floor -= maxVal; // So that interpolation with angle 0-360° doesn't do weird things with angles > 360°\n        }\n        \n        float t3 = seededRandom( new_theta_floor\t+\tsf8 *  new_r_floor      );\n\t\tfloat t4 = seededRandom( new_theta_floor\t+\tsf8 * (new_r_floor+1.0) );\n        \n\t\tfloat i1 = cosineInterpolate(t1, t2, fraction_r);\n\t\tfloat i2 = cosineInterpolate(t3, t4, fraction_r);\n        \n        sum += cosineInterpolate(i1, i2, fraction_theta)/sf;\n    }\n    return 2.0*sum;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float dx = 0.5 - uv.x;\n    float dy = 0.5 - uv.y;\n    dy *= iResolution.y / iResolution.x;\n    \n    float perlinTheta = (PI+atan(dy, -dx))/PI;\n    perlinTheta -= 0.01; // Removes a strange artefact at 9 O'Clock that only appears at certain resolutions.\n    float r = sqrt((dx*dx) + (dy*dy));\n    r = centerToCorner - r;\n    r = tan(tangentScale*r);\n    \n    float c = perlinNoise(perlinTheta, r, iTime)/8.0;\n    // Fiddle with brightness and contrast to push it into a nice range\n    c -= 0.3;\n    c *= 2.0;\n    \n    // Just red because I'm bored of the grey version\n    fragColor = vec4(c, 0, 0, 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlfBRB.jpg", "access": "shaders20k", "license": "mit", "functions": [[105, 332, 384, 384, 467], [469, 469, 501, 501, 658], [660, 779, 838, 838, 2143], [2145, 2153, 2210, 2210, 2867]], "test": "untested"}
{"id": "MlffDB", "name": "standing wave modes", "author": "ws", "description": "Vibrations of a circular membrane (https://en.wikipedia.org/wiki/Vibrations_of_a_circular_membrane)", "tags": ["waves", "bessel"], "likes": 21, "viewed": 178, "published": "Public", "date": "1513139220", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Bessel code taken from https://www.atnf.csiro.au/computing/software/gipsy/sub/bessel.c\n// Any errors in conversion are mine\n\n#define ACC 10.0\n#define BIGNO 1.0e10\n#define BIGNI 1.0e-10\n\nfloat bessj0( float x )\n/*------------------------------------------------------------*/\n/* PURPOSE: Evaluate Bessel function of first kind and order  */\n/*          0 at input x                                      */\n/*------------------------------------------------------------*/\n{\n   float ax,z;\n   float xx,y,ans,ans1,ans2;\n\n   if ((ax=abs(x)) < 8.0) {\n      y=x*x;\n      ans1=57568490574.0+y*(-13362590354.0+y*(651619640.7\n         +y*(-11214424.18+y*(77392.33017+y*(-184.9052456)))));\n      ans2=57568490411.0+y*(1029532985.0+y*(9494680.718\n         +y*(59272.64853+y*(267.8532712+y*1.0))));\n      ans=ans1/ans2;\n   } else {\n      z=8.0/ax;\n      y=z*z;\n      xx=ax-0.785398164;\n      ans1=1.0+y*(-0.1098628627e-2+y*(0.2734510407e-4\n         +y*(-0.2073370639e-5+y*0.2093887211e-6)));\n      ans2 = -0.1562499995e-1+y*(0.1430488765e-3\n         +y*(-0.6911147651e-5+y*(0.7621095161e-6\n         -y*0.934935152e-7)));\n      ans=sqrt(0.636619772/ax)*(cos(xx)*ans1-z*sin(xx)*ans2);\n   }\n   return ans;\n}\n\nfloat bessj1( float x )\n/*------------------------------------------------------------*/\n/* PURPOSE: Evaluate Bessel function of first kind and order  */\n/*          1 at input x                                      */\n/*------------------------------------------------------------*/\n{\n   float ax,z;\n   float xx,y,ans,ans1,ans2;\n\n   if ((ax=abs(x)) < 8.0) {\n      y=x*x;\n      ans1=x*(72362614232.0+y*(-7895059235.0+y*(242396853.1\n         +y*(-2972611.439+y*(15704.48260+y*(-30.16036606))))));\n      ans2=144725228442.0+y*(2300535178.0+y*(18583304.74\n         +y*(99447.43394+y*(376.9991397+y*1.0))));\n      ans=ans1/ans2;\n   } else {\n      z=8.0/ax;\n      y=z*z;\n      xx=ax-2.356194491;\n      ans1=1.0+y*(0.183105e-2+y*(-0.3516396496e-4\n         +y*(0.2457520174e-5+y*(-0.240337019e-6))));\n      ans2=0.04687499995+y*(-0.2002690873e-3\n         +y*(0.8449199096e-5+y*(-0.88228987e-6\n         +y*0.105787412e-6)));\n      ans=sqrt(0.636619772/ax)*(cos(xx)*ans1-z*sin(xx)*ans2);\n      if (x < 0.0) ans = -ans;\n   }\n   return ans;\n}\n\nfloat bessj( float n, float x )\n/*------------------------------------------------------------*/\n/* PURPOSE: Evaluate Bessel function of first kind and order  */\n/*          n at input x                                      */\n/* The function can also be called for n = 0 and n = 1.       */\n/*------------------------------------------------------------*/\n{\n   float    j, jsum, m;\n   float ax, bj, bjm, bjp, sum, tox, ans;\n\n   if (n < 0.) return 0.; // setdblank\n\n   ax=abs(x);\n   if (n == 0.)\n      return( bessj0(ax) );\n   if (n == 1.)\n      return( bessj1(ax) );\n      \n   if (ax == 0.0)\n      return 0.0;\n   else if (ax > float(n)) {\n      tox=2.0/ax;\n      bjm=bessj0(ax);\n      bj=bessj1(ax);\n      for (j=1.;j<n;j+=1.) {\n         bjp=j*tox*bj-bjm;\n         bjm=bj;\n         bj=bjp;\n      }\n      ans=bj;\n   } else {\n      tox=2.0/ax;\n      m=2.*((n+floor(sqrt(ACC*n)))/2.);\n      jsum=0.;\n      bjp=ans=sum=0.0;\n      bj=1.0;\n      for (j=m;j>0.;j-=1.) {\n         bjm=j*tox*bj-bjp;\n         bjp=bj;\n         bj=bjm;\n         if (abs(bj) > BIGNO) {\n            bj *= BIGNI;\n            bjp *= BIGNI;\n            ans *= BIGNI;\n            sum *= BIGNI;\n         }\n         if (jsum != 0.) sum += bj;\n         jsum=(jsum == 0.) ? 1. : 0.;\n         if (j == n) ans=bjp;\n      }\n      sum=2.0*sum-bj;\n      ans /= sum;\n   }\n   return  x < 0.0 && mod(n,2.) == 1. ? -ans : ans;\n}\n\n// Goal is to find the n_th (positive) zero of J_m\n// This is my homebrew zero finder, caveat emptor\n// Initial guess calibrated for 0<=m<=10, 1<=n<=5\nfloat GetLambda(float m, float n) {\n    float guess = -0.98368854 + 1.3045853*m + 3.4110198*n +\n        (-0.0134096)*m*m + (-0.0491151)*n*n + 0.04748184*m*n;\n    // Take 1 Newton steps, use d/dx J_m(x) = (m/x)*J_m(x) - J_{m+1}(x)\n    for (int i = 0; i < 1; i++) {\n        float numer = bessj(m, guess);\n        float denom = numer*m/guess - bessj(m+1., guess);\n        guess -= numer/denom;\n    }\n    return guess;\n}\n\n// calculate the height function for p in unit disc\n// m,n,lmda harmonics parameters, t is time parameter\n// height between 0 and 1\nfloat GetHeight(vec2 p, float m, float n, float lmda, float t) {\n\tfloat theta = m*atan(p.y,p.x);\n\treturn .5+.25*(cos(8.*t) + sin(8.*t))*bessj(m, lmda * length(p)) * (cos(theta)+sin(theta));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n\n    // m and n are the mode parameters\n\tfloat m,n;\n    if (uv.x < 0. && uv.y < 0.) { m = 2.; n = 1.; }\n    else if (uv.x < 0. && uv.y > 0.) { m = 0.; n = 2.; }\n    else if (uv.x > 0. && uv.y > 0.) { m = 1.; n = 3.; }\n    else { m = 2.; n = 3.; }\n    float lmda = GetLambda(m, n);\n\n    // Redo uv per quadrant\n    uv = 2.*vec2(mod(uv.x, 1.), mod(uv.y, 1.)) - vec2(1.);\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    float scale = 4.;\n    float time = 6.283185*float(iFrame)/480.;\n    mat3 rotate = mat3(cos(time),0.,-sin(time),0.,1.,0.,sin(time),0.,cos(time));\n\tvec3 ro = rotate*vec3( 2., 2., 2.);\n    vec3 center = vec3( 0.0, 0.5, 0.0 );\n\tvec3 ww = normalize( center - ro );\n    vec3 uu = normalize(cross(ww, vec3(0.0,1.0,0.0) ));\n    vec3 vv = cross(uu,ww);\n\tvec3 rd = normalize( uv.x*uu + uv.y*vv + scale*ww );\n\n    const int steps=30;\n\tfloat t0=(1.-ro.y)/rd.y;\n\tfloat t1=(0.-ro.y)/rd.y;\n\n    vec3 prevp = ro+rd*t0;\n    vec3 p = prevp;\n    float ph = 1.;\n    float pt = t0;\n    \n    // Raymarch through the heightfield with a fixed number of steps.\n    // https://www.shadertoy.com/view/MdBSRW\n    for(int i=1; i<steps; i++)\n    {\n        float t=mix(t0,t1,float(i)/float(steps));\n        p=ro+rd*t;\n        float h = GetHeight(p.xz, m, n, lmda, time);\n\n        if(h>p.y)\n        {\n            // Refine the intersection point.\n            float lrd=length(rd.xz);\n            vec2 v0=vec2(lrd*pt, prevp.y);\n            vec2 v1=vec2(lrd*t, p.y);\n            vec2 v2=vec2(lrd*pt, ph);\n            vec2 dv=vec2(h-v2.y,v2.x-v1.x);\n            float inter=dot(v2-v0,dv)/dot(v1-v0,dv);\n            p=mix(prevp,p,inter);\n\n            // Re-evaluate the height using the refined intersection point.\n            ph=GetHeight(p.xz, m, n, lmda, time);\n            \n            break;\n        }\n        prevp=p;\n        ph = h;\n        pt = t;\n    }\n    \n    // color by height and constrain to circle (+antialias)\n\tfragColor = mix(vec4(.8, ph, 0.,1.), \n                    vec4(105., 105., 105., 256.)/256.,\n                    smoothstep(.999, 1.001, length(p.xz)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlffDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 189, 474, 474, 1194], [1196, 1196, 1481, 1481, 2227], [2229, 2229, 2587, 2587, 3610], [3612, 3763, 3798, 3798, 4179], [4181, 4313, 4377, 4377, 4504], [4506, 4506, 4563, 4563, 6682]], "test": "untested"}
{"id": "MlffDs", "name": "MacSlow's Mandelbulb attempt", "author": "MacSlow", "description": "Raymarching... understood, shading & shadow... understood, cartesian to polar and back... understood. But I just can't get how the distance estimator is derived. This nasty single line 45 makes it feel like cheating and not having a clue what I'm doing :(", "tags": ["3d", "raymarching", "fractal", "mandelbulb", "study"], "likes": 3, "viewed": 1018, "published": "Public API", "date": "1513943738", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_ITER = 96;\nconst float STEP_SIZE = .75;\nconst float EPSILON = .001;\nconst float PI = 3.1415926;\n\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\nstruct Result {\n\tvec3 point;\n    vec3 normal;\n    float dist;\n    int iter;\n    int id;\n};\n\nconst Result nullResult = Result (vec3 (.0), vec3 (.0), .0, 0, -1);\n\nfloat mandelbulb (vec3 pos, in float n, in float bail, in int iter)\n{\n\tvec3 z = pos;\n\tfloat dr = 1.;\n\tfloat r = .0;\n\tfor (int i = 0; i < iter; i++) {\n\t\tr = length (z);\n\t\tif (r > bail) break;\n\t\t\n\t\t// from cartesian to polar\n\t\tfloat theta = acos (z.z / r);\n\t\tfloat phi = atan (z.y, z.x);\n\t\tdr = pow(r, n - 1.) * n * dr + 1.;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow (r, n);\n\t\ttheta = theta * n;\n\t\tphi = phi * n;\n\t\t\n\t\t// back to cartesian\n\t\tz = zr * vec3(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta));\n\t\tz += pos;\n\t}\n\n    return .5 * log (r) * r / dr; // I just don't get this distance estimator here\n}\n\nfloat map (in vec3 p)\n{\n\tfloat d = mandelbulb (p, 8. + 8.*(.5 + .5*cos(iTime)), 4., 8);\n    return d;\n}\n\nvec3 normal (in vec3 p)\n{\n    float d = map (p);\n    vec3 e = vec3 (.001, .0, .0);\n    vec3 n = vec3 (map (p + e.xyy) - d,\n                   map (p + e.yxy) - d,\n                   map (p + e.yyx) - d);\n\n    return normalize (n);\n}\n\nResult march (in Ray ray)\n{\n    Result res = nullResult;\n\n    for (int i = 0; i < MAX_ITER; ++i) {\n        res.iter = i;\n        float tmp = map (ray.ro + res.dist * ray.rd);\n        if (tmp < EPSILON) break;\n        res.dist += tmp * STEP_SIZE;\n    }\n\n    res.point = ray.ro + res.dist * ray.rd;\n    res.normal = normal (res.point);\n    //res.id = tmp.id;\n\n    return res;\n}\n\nfloat shadow (in Ray ray, in vec3 lPos)\n{\n    float distToLight = distance (lPos, ray.ro);\n    float dist = .0;\n\n    for (int i = 0; i < MAX_ITER; ++i) {\n        float tmp = map (ray.ro + dist * ray.rd);\n        if (tmp < EPSILON) {\n            if (dist < distToLight)\n                return .125;\n            else\n                return 1.;\n        }\n        dist += tmp * STEP_SIZE;\n    }\n\n    return 1.;\n}\n\nvec3 shade (in Result res)\n{    \n    vec3 amb = vec3 (.1);\n    vec3 diffM = vec3 (.9, .25, .2);\n    vec3 diffL = vec3 (.95, .9, .3)*3.;\n    vec3 diffL2 = vec3 (.5, .7, .85)*2.;\n    vec3 specM = vec3 (1.);\n    vec3 specL = vec3 (1.);\n    vec3 lPos = vec3 (.4, 1., -1.25);\n    vec3 lPos2 = vec3 (-.25, .5, 1.);\n\tvec3 lDir = normalize (lPos - res.point);\n\tvec3 lDir2 = normalize (lPos2 - res.point);\n\n    float diff = clamp (dot (res.normal, lDir), .0, 1.);\n    float diff2 = clamp (dot (res.normal, lDir2), .0, 1.);\n    vec3 h = normalize (lDir + res.point);\n    vec3 h2 = normalize (lDir2 + res.point);\n    float shininess = 60.;\n    float spec = pow (clamp (dot (res.normal, h), .0, 1.), shininess);\n    float spec2 = pow (clamp (dot (res.normal, h2), .0, 1.), shininess);\n    float sha = shadow (Ray (res.point + .001 * res.normal, lDir), lPos);\n    float sha2 = shadow (Ray (res.point + .001 * res.normal, lDir2), lPos2);\n\n    return amb + sha * (diff * diffM * diffL + spec * specM * specL) + \n        sha2 * (diff2 * diffM * diffL2 + spec2 * specM * specL);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float r = 1.5 + 1.5 * (cos (iTime)*.5+.5);\n    float theta = (iMouse.x / iResolution.x) * PI;\n    float phi = -(iMouse.y / iResolution.y * 2. - 1.) * PI;\n    float x = r * sin (theta) * cos (phi);\n    float y = r * sin (theta) * sin (phi);\n\tfloat z = r * cos (theta);\n    vec3 ro = vec3 (x, y, z);\n    float zoom = 2.;\n    vec3 lookAt = vec3 (.0);\n    vec3 forward = normalize (lookAt - ro);\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 right = normalize (cross (worldUp, forward));\n    vec3 up = normalize (cross (forward, right));\n    vec3 camCenter = ro + zoom * forward;\n    vec3 i = camCenter + uv.x * right + uv.y * up;\n    vec3 rd = normalize (i - ro);\n\n    Ray ray = Ray (ro, rd);\n    Result res = march (ray);\n    vec3 col = shade (res);\n    float fog = float (res.iter) / float (MAX_ITER);\n    col *= 1. - (fog * fog);\n\n    col = col / (.85 + col);\n    col *= vec3 (.95, .9, .85);\n    col = .3*col + .7*sqrt (col);\n\n    fragColor = vec4 (col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlffDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[315, 315, 384, 384, 933], [935, 935, 958, 958, 1038], [1040, 1040, 1065, 1065, 1272], [1274, 1274, 1301, 1301, 1649], [1651, 1651, 1692, 1692, 2059], [2061, 2061, 2089, 2089, 3124], [3126, 3126, 3182, 3182, 4257]], "test": "untested"}
{"id": "MlffDX", "name": "soldering fun", "author": "flockaroo", "description": "heavy soldering action... would be awful in real life!! ;-)\nwatch in [url]https://shaderoo.org[/url] to zoom in/out. also a geometry version available (download as .obj)", "tags": ["truchet", "copper", "atomium", "sodering", "tin"], "likes": 69, "viewed": 2701, "published": "Public API", "date": "1513613695", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// created by florian berger (flockaroo) - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// atomium soldering fun\n\n// same in shaderoo (+zoom in/out):\n//    https://www.shaderoo.org/?shader=xI6vZz\n// also check out geometry version in shaderoo (download as .obj):\n//    https://www.shaderoo.org/?shader=bGKarn\n\n// non periodic tilings on a sphere, startig from an icosahedron\n\n// golden ratio - used for icosahedron\n#define PI2 6.28318531\n#define G (.5+sqrt(5./4.))\n\n#define XCHGV3(a,b) { vec3 d=a; a=b; b=d; }\n\nvoid sortXYZ(inout vec3 p1, inout vec3 p2, inout vec3 p3)\n{\n    #define W(p) (p.x+p.y*.01+p.z*.0001)\n    if(W(p3)>W(p2)) XCHGV3(p3,p2);\n    if(W(p2)>W(p1)) XCHGV3(p2,p1);\n    if(W(p3)>W(p2)) XCHGV3(p3,p2);\n    if(W(p2)>W(p1)) XCHGV3(p2,p1);\n}\n\n// get closest icosahedron triangle by geometric categorizion\n// using icosa symmetry, so dont have to check for every icosa point\nvoid getIcosaTri(vec3 pos, out vec3 p1, out vec3 p2, out vec3 p3)\n{\n    mat2 rot=mat2(0.809016994374947, 0.587785252292473, -0.587785252292473, 0.809016994374947);\n    \n    float ph = atan(pos.y,pos.x);  ph=(ph<0.)?PI2+ph:ph;\n    \n    float dang=PI2/5.;\n    float seg=ph/dang;\n    float fseg=floor(seg);\n    \n    // 3 topmost points of segment + lower point of seg (p4t)\n    vec3 p1t=vec3(0,0,1.);\n    vec3 p2t=vec3(cos(fseg*dang-vec2(0,PI2/4.))*.894427190999916,.447213595499958);\n    vec3 p4t=vec3(rot*p2t.xy,-p2t.z);\n    vec3 p3t=vec3(rot*p4t.xy, p2t.z);\n\n    if (dot(pos,cross(p2t,p4t))<0. || dot(pos,cross(p4t,p3t))<0.) {\n        // xchg p2 and p3 (because bottom is mirrored in z)\n        p1t=vec3(0,0,-1.);\n        p3t=vec3((seg-fseg<.5)?p2t.xy*rot:rot*p2t.xy,-p2t.z);\n        p4t=vec3(rot*p3t.xy,-p3t.z);\n        p2t=vec3(rot*p4t.xy, p3t.z);\n    }\n\n    // mix top or below\n    bool top=(dot(pos,cross(p2t,p3t))>0.);\n    p1=top?p1t:p4t; \n    p2=top?p2t:p3t; \n    p3=top?p3t:p2t;\n}\n\n// get closest icosahedron triangle by geometric categorizion\nvoid getIcosaTri2(vec3 pos, out vec3 p1, out vec3 p2, out vec3 p3)\n{\n    float ph = atan(pos.y,pos.x);  ph=(ph<0.)?PI2+ph:ph;\n    vec2 csth0=vec2(.447213595499958,.894427190999916);\n    \n    float dang=PI2/5.;\n    vec2 ang=floor(ph/dang)*dang-vec2(0,PI2/4.);\n    //vec2 r=cos(.5*dang-vec2(0,PI2/4.));\n    //mat2 rot=mat2(r.x,r.y,-r.y,r.x);\n    mat2 rot=mat2(0.809016994374947, 0.587785252292473, -0.587785252292473, 0.809016994374947);\n    \n    // 3 topmost points of segment + lower point of seg (p4t)\n    vec3 p1t=vec3(0,0,1.);\n    vec3 p2t=vec3(cos(ang),         1)*csth0.yyx;\n    vec3 p3t=vec3(cos(ang+dang),    1)*csth0.yyx;\n    vec3 p4t=vec3(cos(ang+dang*.5),-1)*csth0.yyx;\n\n    if (dot(pos,cross(p2t,p4t))<0. || dot(pos,cross(p4t,p3t))<0.) {\n        // xchg p2 and p3 (because bottom is mirrored in z)\n        ang=(floor(ph/dang-.5)+.5)*dang-vec2(0,PI2/4.);\n        p1t=vec3(0,0,-1.);\n        p3t=vec3(cos(ang),        -1)*csth0.yyx;\n        p2t=vec3(cos(ang+dang   ),-1)*csth0.yyx;\n        p4t=vec3(cos(ang+dang*.5), 1)*csth0.yyx;\n    }\n\n    // mix top or below\n    bool top=(dot(pos,cross(p2t,p3t))>0.);\n    p1=top?p1t:p4t; \n    p2=top?p2t:p3t; \n    p3=top?p3t:p2t;\n}\n\n// get closest icosahedron triangle\nvoid getIcosaTriOld(vec3 pos, out vec3 p1, out vec3 p2, out vec3 p3)\n{\n    float dot1 = -1000.0;\n    float dot2 = -1000.0;\n    float dot3 = -1000.0;\n    for(int s1=0;s1<2;s1++)\n    {\n    \tfor(int s2=0;s2<2;s2++)\n        {\n    \t\tfor(int perm=0;perm<3;perm++)\n            {\n                vec3 p0 = normalize(vec3(G,1,0))*vec3(s1*2-1,s2*2-1,0);\n                if     (perm>1) p0 = p0.yzx;\n                else if(perm>0) p0 = p0.zxy;\n                float dot0 = dot(pos,p0);\n                if(dot0>dot1){\n                    dot3=dot2; p3=p2;\n                    dot2=dot1; p2=p1; \n                    dot1=dot0; p1=p0;\n                }\n                else if(dot0>dot2){\n                    dot3=dot2; p3=p2;\n                    dot2=dot0; p2=p0; \n                }\n                else if(dot0>dot3){\n                    dot3=dot0; p3=p0;\n                }\n            }\n        }\n    }\n}\n\n// check if pos hits triangle\nbool thruTriangle(vec3 pos, vec3 v1, vec3 v2, vec3 v3)\n{\n    vec3 n = cross(v2-v1,v3-v1);\n    // calc where pos hits triangle plane\n    pos = pos*dot(v1,n)/dot(pos,n);\n    v1-=pos; v2-=pos; v3-=pos;\n \tvec3 c1=cross(v1,v2);\n    vec3 c2=cross(v2,v3);\n    vec3 c3=cross(v3,v1);\n    // check if the cross products of all the pos-edge-vectors show into the same direction\n    return dot(c1,c2)>0. && dot(c2,c3)>0. && dot(c3,c1)>0. ;\n}\n\n// subdivide 1 triangle into 4 triangles and give back closest triangle\nvoid getTriSubDiv(vec3 pos, inout vec3 p1, inout vec3 p2, inout vec3 p3)\n{\n    vec3 p4 = normalize(p1+p2);\n    vec3 p5 = normalize(p2+p3);\n    vec3 p6 = normalize(p3+p1);\n\n    // faster, but works only if triangle has postive umlaufsinn\n    if     (dot(pos,cross(p4,p5))<0.) { p1=p4; p2=p2; p3=p5; }\n    else if(dot(pos,cross(p5,p6))<0.) { p1=p6; p2=p5; p3=p3; }\n    else if(dot(pos,cross(p6,p4))<0.) { p1=p1; p2=p4; p3=p6; }\n    else                              { p1=p4; p2=p5; p3=p6; }\n\n    /*if     (sign(dot(pos,cross(p4,p5)))==sign(dot(p2,cross(p4,p5)))) { p1=p4; p2=p2; p3=p5; }\n    else if(sign(dot(pos,cross(p5,p6)))==sign(dot(p3,cross(p5,p6)))) { p1=p6; p2=p5; p3=p3; }\n    else if(sign(dot(pos,cross(p6,p4)))==sign(dot(p1,cross(p6,p4)))) { p1=p1; p2=p4; p3=p6; }\n    else                              { p1=p4; p2=p5; p3=p6; }*/\n\n    /*if     (thruTriangle(pos,p1,p4,p6)) { p1=p1; p2=p4; p3=p6; }\n    else if(thruTriangle(pos,p6,p5,p3)) { p1=p6; p2=p5; p3=p3; }\n    else if(thruTriangle(pos,p6,p4,p5)) { p1=p6; p2=p4; p3=p5; }\n    else if(thruTriangle(pos,p4,p2,p5)) { p1=p4; p2=p2; p3=p5; }*/\n}\n\n// get some 3d rand values by multiplying 2d rand in xy, yz, zx plane\nvec4 getRand(vec3 pos)\n{\n    vec4 r = vec4(1.0);\n    r*=textureLod(iChannel0,pos.xy,0.)*2.-1.;\n    r*=textureLod(iChannel0,pos.xz,0.)*2.-1.;\n    r*=textureLod(iChannel0,pos.zy,0.)*2.-1.;\n    return r;\n}\n\n// distancefield of torus around arbitrary axis z\n// similar to http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat distTorus(vec3 pos, float r1, float r2, vec3 z)\n{\n    float pz = dot(pos,normalize(z));\n    return length(vec2(length(pos-z*pz)-r1,pz))-r2;\n}\n\nfloat getRand01Sph(vec3 pos)\n{\n    return textureLod(iChannel0,pos.xy*123.+pos.z,0.).x;\n}\n\nfloat distSphere(vec3 pos, float r)\n{\n\treturn length(pos)-r;\n}\n\nfloat calcAngle(vec3 v1, vec3 v2)\n{\n    return acos(dot(v1,v2)/length(v1)/length(v2));\n}\n\n// iq's smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - pow(abs(k*h*(1.0-h)),.93);\n}\n\n// distance to 2 torus segments in a triangle\n// each torus segment spans from the middle of one side to the middle of another side\nfloat distTruchet(vec3 pos, vec3 p1, vec3 p2, vec3 p3,float r, bool smth)\n{\n    float d = 10000.0;\n    float rnd=getRand01Sph(p1+p2+p3);\n\n    // random rotation of triangle-edges\n    // no mirroring\n    if      (rnd>.333) { vec3 d=p1; p1=p2; p2=p3; p3=d; }\n    else if (rnd>.666) { vec3 d=p1; p1=p3; p3=p2; p2=d; }\n    \n    vec3 p4=pos-normalize(p1+p2);\n    vec3 p5=pos-normalize(p2+p3);\n    vec3 p6=pos-normalize(p3+p1);\n    vec3 d1=p5-p4;\n    vec3 d2=p6-p4;\n    \n\td=min(d, length( p4 - d1*(dot(p4,d1)/dot(d1,d1)) )-r );\n\td=min(d, length( p4 - d2*(dot(p4,d2)/dot(d2,d2)) )-r );\n\t//d=min(d, length(cross(p4,normalize(p5-p4)))-r );\n\t//d=min(d, length(cross(p4,normalize(p6-p4)))-r );\n\t\n\tif(smth)\n\t{\n        float rnd = .01*(getRand(pos*.3).x);\n\n        d=smin(d,length(p4)-2.2*r,.0065+rnd);\n        d=smin(d,length(p5)-2.2*r,.0065+rnd);\n        d=smin(d,length(p6)-2.2*r,.0065+rnd);\n\t}\n\telse\n\t{\n        d=min(d,length(p4)-2.2*r);\n        d=min(d,length(p5)-2.2*r);\n        d=min(d,length(p6)-2.2*r);\n\t}\n    return d;\n}\n\n// final distance funtion\nfloat dist(vec3 pos, bool smth)\n{\n    pos+=.00015*getRand(pos*1.3).xyz*4.;\n    pos+=.00006*getRand(pos*3.).xyz*4.;\n    pos+=.00040*getRand(pos*.5).xyz*4.;\n    vec3 p1,p2,p3;\n    float d = 10000.;\n    \n    // sphere in the middle\n\td=min(d,distSphere(pos,.9));\n    \n    // start with an icosahedron subdivided once\n    getIcosaTri(pos, p1, p2, p3);\n    getTriSubDiv(pos, p1, p2, p3);\n    // always sort by X, then Y, then Z - to get a unique order of the edges\n    //sortXYZ(p1,p2,p3);\n    float r0=.02;\n    d=min(d,distTruchet(pos, p1,p2,p3,r0,smth));\n    \n    float sc = 1.;\n    // subdivide again for another detail\n    getTriSubDiv(pos,p1,p2,p3);\n    //sortXYZ(p1,p2,p3);\n\tsc = 1./.97;\n    d=min(d,distTruchet(pos*sc, p1,p2,p3,r0/2.,smth)/sc);\n    \n    // subdivide again for another detail\n\tgetTriSubDiv(pos,p1,p2,p3);\n    //sortXYZ(p1,p2,p3);\n    sc = 1./.96;\n    d=min(d,distTruchet(pos*sc, p1,p2,p3,r0/4.,smth)/sc);\n    \n    return d;\n}\n\nfloat dist(vec3 pos)\n{\n    return dist(pos,true);\n}\n\nvec3 getGrad(vec3 pos, float eps)\n{\n    vec2 d=vec2(eps,0);\n    float d0=dist(pos);\n    return vec3(dist(pos+d.xyy)-d0,\n                dist(pos+d.yxy)-d0,\n                dist(pos+d.yyx)-d0)/eps;\n                \n}\n\n// march it...\nvec4 march(inout vec3 pos, vec3 dir)\n{\n    // cull the sphere\n    if(length(pos-dir*dot(dir,pos))>1.05) \n    \treturn vec4(0,0,0,1);\n    \n    float eps=0.001;\n    float bg=1.0;\n    for(int cnt=0;cnt<64;cnt++)\n    {\n        float d = dist(pos);\n        pos+=d*dir;\n        if(d<eps) { bg=0.0; break; }\n    }\n    vec3 n = getGrad(pos,.001);\n    return vec4(n,bg); // .w=1 => background\n}\n\nmat3 rotX(float ang)\n{\n    float c=cos(ang), s=sin(ang);\n    return mat3(1,0,0, 0,c,s, 0,-s,c);\n}\n\nmat3 rotZ(float ang)\n{\n    float c=cos(ang), s=sin(ang);\n    return mat3(c,s,0, -s,c,0, 0,0,1);\n}\n\nvec4 getRand(vec2 coord)\n{\n    vec4 c=vec4(0);\n    c+=texture(iChannel0,coord+.003*iTime);\n    c+=texture(iChannel0,coord/2.+.003*iTime)*2.;\n    c+=texture(iChannel0,coord/4.+.003*iTime)*4.;\n    c+=texture(iChannel0,coord/8.+.003*iTime)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\n#define FloorZ -5.\n// envoronment just a sky and some floor grid...\nvec4 myenv(vec3 pos, vec3 dir, float period)\n{\n    vec3 colHor=vec3(.3,.4,.5)+.25;\n    //vec3 colSky=mix(vec3(1.5,.75,0.)*1.7,vec3(.8,.9,1)*1.2,clamp(7.*dir.z,0.,1.));\n    vec3 colSky=vec3(.8,.9,1)*1.2;\n    vec3 skyPos=pos+dir/abs(dir.z)*(20.-pos.z);\n    float cloudPat=(1.+.4*(getRand(skyPos.xy*.001).x-.5));\n    colSky*=mix(1.,cloudPat,step(0.,dir.z));\n    vec3 colFloor=vec3(.5,.6,.7);\n    vec3 colScale=vec3(1,1,1);\n    vec3 floorPos=pos-dir/dir.z*(pos.z-FloorZ);\n    vec2 s;\n    float scale=1.;\n    s=sin(floorPos.xy*PI2*.5*period);\n    scale*=(1.-.3*exp(-s.x*s.x/.01))*(1.-.3*exp(-s.y*s.y/.01));\n    s=sin(floorPos.xy*PI2*.5/10.*period);\n    scale*=(1.-.5*exp(-s.x*s.x/.001))*(1.-.5*exp(-s.y*s.y/.001));\n    //colFloor=mix(colFloor,colScale,1.-scale);\n    colFloor*=(1.+.4*(getRand(floorPos.xy*.001).x-.5));\n    vec3 col=mix(colSky,colFloor,1.-smoothstep(-.01,.01,dir.z));\n    col=mix(colHor,col,clamp(abs(dir.z*6.)-.1,0.,1.));\n    //return vec4(mix(vec3(.3,.4,.35),vec3(.8,1,.9),dir.z)*1.2+.4,1);\n    return vec4(col*1.1+.0*dir,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // screen coord -1..1\n    vec2 sc = (fragCoord.xy/iResolution.xy)*2.-1.;\n    // viewer position\n    vec3 pos = vec3(0,-1.8,0);\n    #ifdef SHADEROO\n    pos.y+=iMouseData.z*.001;\n    #endif\n    // pixel view direction\n    vec3 dir = normalize(2.*normalize(-pos)+vec3(sc.x,0,sc.y*iResolution.y/iResolution.x));\n    // rotate view around x,z\n    float phi = iMouse.x/iResolution.x*7.;\n    float th  = iMouse.y/iResolution.y*7.;\n    if (iMouse.x==0.) { phi=iTime*.25; th=.27*.25*iTime; }\n    mat3 rx = rotX(th);\n    mat3 rz = rotZ(phi);\n    pos = rz*(rx*pos);\n    dir = rz*(rx*dir);\n    vec3 pos0 = pos;\n    \n    // march it...\n   \tvec4 n=march(pos,dir);\n   \tfloat actMat = clamp((dist(pos,false)-dist(pos,true))*5000.,0.,1.);\n    float bg=n.w;\n        \n    // reflection dir\n    vec3 R = pos-2.0*dot(pos,n.xyz)*n.xyz;\n    //R = -((R*rz)*rx).yzx;\n    R = normalize((pos-pos0)-2.0*dot((pos-pos0),n.xyz)*n.xyz);\n    //R = R*rz*rx;\n    \n    // calc some ambient occlusion\n    float ao=1.;\n    #if 0\n    // calc simple ao by stepping along radius\n    ao*=dist(pos*1.02)/.02;\n    ao*=dist(pos*1.05)/.05;\n    ao*=dist(pos*1.1)/.1;\n    #else\n    vec3 R2=normalize(3.*R.xyz+n.xyz);\n    // calc ao by stepping along normal\n    ao*=dist(pos+R2*.02)/.02;\n    ao*=dist(pos+R2*.05)/.05;\n    ao*=dist(pos+R2*.10)/.10;\n    #endif\n    // adjust contrast of ao\n    ao=pow(clamp(ao,0.,1.),.4);\n    ao=ao*.9+.1;\n    \n    vec3 c = mix(vec3(1),vec3(1.2,.65,.5)*1.2,clamp(dot(n.xyz,R),0.,1.));\n    c=mix(c,vec3(1.4),actMat);\n    // simply add some parts of the normal to the color\n    // gives impression of 3 lights from different dir with different color temperature\n    c += n.xyz*vec3(.05,.0,.05);\n\n    //  reflection of cubemap\n    //c *= mix(vec3(.3,.4,.35),vec3(.8,1,.9),R.z)*1.2+.4;\n    c *= myenv(pos,R,1.).xyz;\n    //c *= texture(iChannel1,R).xyz*1.5+.4;\n    \n    // add some depth darkening\n\t//c*=clamp(-dot(dir,pos)*.7+.7, .2, 1.);\n    \n    // apply ambient occlusion\n    c*=ao;\n    \n    // apply background\n    if(bg>=.5) c=vec3(.5,.6,.75);\n    //if(bg>=.5) c=myenv(pos,dir,1.).xyz;\n    \n    // vignetting\n    float vign = (1.1-.5*dot(sc.xy,sc.xy));\n    \n\tfragColor = vec4(c*vign,1);\n\t//fragColor = vec4(R,1);\n\t/*fragColor = vec4(R2,1);\n\tif (fragCoord.x>iResolution.x*.5)\n\tfragColor = vec4(n.xyz,1);*/\n}\n\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlffDX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[424, 559, 618, 618, 801], [803, 934, 1001, 1001, 1921], [1923, 1985, 2053, 2053, 3161], [3163, 3199, 3269, 3269, 4093], [4095, 4125, 4181, 4181, 4554], [4556, 4628, 4702, 4702, 5733], [5735, 5805, 5829, 5829, 6007], [6009, 6144, 6199, 6199, 6291], [6293, 6293, 6323, 6323, 6382], [6384, 6384, 6421, 6421, 6446], [6448, 6448, 6483, 6483, 6536], [6538, 6551, 6592, 6592, 6699], [6701, 6833, 6908, 6908, 7850], [7852, 7878, 7911, 7911, 8820], [8822, 8822, 8844, 8844, 8873], [8875, 8875, 8910, 8910, 9090], [9092, 9107, 9145, 9168, 9491], [9493, 9493, 9515, 9515, 9590], [9592, 9592, 9614, 9614, 9689], [9691, 9691, 9717, 9717, 9961], [9982, 10031, 10077, 10077, 11071], [11073, 11073, 11130, 11156, 13424]], "test": "untested"}
{"id": "MllBDj", "name": "Submarine Sonar", "author": "ircss", "description": "A submarine Sonar for fun! After finishing this and looking at a real one, I realized that I have apprently never seen a real Sonar!", "tags": ["maths", "submarinesonar"], "likes": 2, "viewed": 473, "published": "Public API", "date": "1513438145", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n\nfloat defineACircle(vec2 center, vec2 currentPixel, float radius){\n    float toReturn = 0.0;\n    \n    if((distance(center , currentPixel) - radius)/ radius< 1.0) toReturn = 1.0;\n    \n \treturn toReturn;  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    const float PI = 3.14159;\n    \n    // Variables\n    \n    float tilingX = 10.0;\n    float tilingY = 10.0;\n    float smoothnesOfLines = 0.06;\n    float radarSmoothness = 1.4;\n    float RadarLineThickness = 0.01;\n    float noiseAmount = 0.18;\n    \n    float rotationSpeed = 0.2;\n    \n    vec4 colorBackground = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 linesBackground = vec4(0.8, 0.5 , 0.1, 1.0);\n    vec4 radarLineColor = vec4(1.0, 1.0, 0.1, 1.0);\n    \n    vec2 circleMiddle = vec2(0.5, 0.5);\n    \n    \n    \n    // Here you map your screen to a uv space between 1 nad 0 \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    // Horizontal\n    \n    float repeatingCoordinateSystemHorizontal = fract(uv.x * tilingX);\n    \n    float distanceToLineToBeDrawnHorizontal = abs( repeatingCoordinateSystemHorizontal - 0.5 ) ;\n    \n    float lerpFactorX = clamp( distanceToLineToBeDrawnHorizontal / smoothnesOfLines, 0.0, 1.0);\n    \n    vec4 endcolor =  mix(colorBackground, linesBackground, 1.0 - lerpFactorX);\n    \n   \n    // Vertical\n    \n    float repeatingCoordinateSystemVertical = fract(uv.y * tilingY);\n    float distanceToLineToBeDrawnVertical =  abs( repeatingCoordinateSystemVertical - 0.5 ) ;\n    \n    float lerpFactorY = clamp( distanceToLineToBeDrawnVertical / smoothnesOfLines, 0.0, 1.0);\n    \n    endcolor =  mix(endcolor, linesBackground, 1.0 - lerpFactorY);\n    \n    // Add the Dots \n    \n    // dot one button left\n    float directionX = rand (vec2(floor(iTime*0.01), floor(iTime*0.1)));\n    float directionY = rand (vec2( 10.0 + floor(iTime*0.01), 30.0 + floor(iTime*0.1)));\n    \n    float dotsLerpFactor =  defineACircle( vec2(fract(iTime*0.2) *directionX ,fract(iTime*0.2) * directionY), uv, 0.024);\n   \n    \n    // dot two up right\n    \n    directionX = rand (vec2(10.0 + floor(iTime*0.01), 15.0 +  floor(iTime*0.1)));\n    directionY = rand (vec2( 35.0 + floor(iTime*0.01), 9.0 + floor(iTime*0.1)));\n    \n    dotsLerpFactor += defineACircle( vec2(1.0 -fract(iTime*0.2) *directionX , 1.0 - fract(iTime*0.2) * directionY), uv, 0.02);\n    \n    \n    \n    \n    // dot three up left\n    \n    directionX = rand (vec2(-17.0 + floor(iTime*0.01), -4.0 +  floor(iTime*0.1)));\n    directionY = rand (vec2( 135.0 + floor(iTime*0.01), 33.0 + floor(iTime*0.1)));\n    \n    dotsLerpFactor += defineACircle( vec2(fract(iTime*0.2) *directionX , 1.0 - fract(iTime*0.2) * directionY), uv, 0.016);\n    \n    \n     // dot four down right\n    \n    directionX = rand (vec2(787.0 + floor(iTime*0.01), 240.0 +  floor(iTime*0.1)));\n    directionY = rand (vec2( 532.0 + floor(iTime*0.01), 241.0 + floor(iTime*0.1)));\n    \n    dotsLerpFactor += defineACircle( 1.0 - vec2(fract(iTime*0.2) *directionX , fract(iTime*0.2) * directionY), uv, 0.028);\n    \n    \n    vec4 dotsColor = mix(vec4(0.0, 0.0, 0.0, 0.0), linesBackground, dotsLerpFactor);\n    endcolor +=dotsColor;\n    \n    // Vector to Middle of the circle \n    \n    vec2 vectorToMiddle = uv - circleMiddle;\n    \n    float angleToPixel = atan(vectorToMiddle.y/vectorToMiddle.x);\n    \n    if((vectorToMiddle.x < 0.0) && (vectorToMiddle.y>0.0)) angleToPixel +=1.0* PI;\n    if((vectorToMiddle.x < 0.0) && (vectorToMiddle.y<0.0)) angleToPixel +=1.0* PI;\n    if((vectorToMiddle.x > 0.0) && (vectorToMiddle.y<0.0)) angleToPixel +=2.0* PI;\n    \n    float cacheForRadarLine = 0.0;\n    float distanceToLawToDraw =  angleToPixel - radians( fract( - iTime * rotationSpeed) * 360.0);\n    \n    float lerpFactorCircularLine = (1.0- distanceToLawToDraw) / radarSmoothness;\n    \n    if(lerpFactorCircularLine > 1.0 ) {\n        \n        if(lerpFactorCircularLine < 1.0 + RadarLineThickness)  cacheForRadarLine = 1.0;\n        lerpFactorCircularLine = 0.0;\n        \n    }\n    \n    \n        \n    // Blend Colors\n    \n    vec4 radarColor  =  mix(vec4(0.0, 0.0, 0.0, 1.0), linesBackground,  lerpFactorCircularLine);\n    \n     endcolor += radarColor;\n    \n    endcolor += (linesBackground * 0.5);\n    \n    if(distanceToLawToDraw + 0.3<0.0) endcolor *=lerpFactorCircularLine ;\n    \n    // Draw \n    \n    \n    endcolor = mix (endcolor, radarLineColor, cacheForRadarLine);\n    \n    \n    // Blend over the static noise on screen\n    vec4 noise = vec4 (rand(uv * iTime), rand(uv* iTime), rand(uv* iTime), 1.0);\n    \n    vec4 toBlend = mix(vec4(0.8, 0.8, 0.8, 1.0), noise, 0.2);\n    \n    endcolor *=toBlend;\n    \n    endcolor += mix(vec4(0.0, 0.0, 0.0, 1.0), noise, noiseAmount);\n    \n   \n    \n\tfragColor =endcolor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MllBDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [96, 96, 162, 162, 301], [303, 303, 360, 360, 4787]], "test": "untested"}
{"id": "MllBWS", "name": "Cuphead", "author": "zackpudil", "description": "Use mouse to look around. Fun game, should check it out.\n\nInspired by: [url=https://vignette.wikia.nocookie.net/p__/images/5/57/Cuphead_prst.jpg/revision/latest?cb=20171022174833&path-prefix=protagonist]This image[/url]", "tags": ["raymarching", "character"], "likes": 13, "viewed": 287, "published": "Public", "date": "1514333223", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define sat(a) clamp(a, 0.0, 1.0)\n\nvec2 dmin(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat smoothmin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 rot(vec2 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c, s, -s, c)*p;\n}\n\nfloat cylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat segment(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a; \n    vec3 ba = b - a;\n    \n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    \n    return length(pa - ba*h) - r;\n}\n\nfloat straw(vec3 p) {\n    p.x += 0.6;\n    p.y -= 1.2;\n    \n    float s = cylinder(p, vec2(0.12 + 0.02*sin(100.0*p.y)*step(0.65, p.y), 0.8));\n    \n    p.y -= 0.97;\n    p.x += 0.3;\n\tp.xy = rot(p.xy, -1.0);\n    \n    p.xy = rot(p.xy + vec2(0, 0.2), 0.2*sin(14.0*iTime)) - vec2(0, 0.2);\n    float us = cylinder(p, vec2(0.12 + 0.02*sin(100.0*p.y)*step(0.15, -p.y), 0.4));\n    us = max(us, -cylinder(p, vec2(0.09, 0.5)));\n    s = min(s, us);\n    \n    return s;\n}\n\nfloat head(vec3 p) {\n    p.y -= 1.0;\n    \n    float c = length(p) - 1.0;\n    c = max(c, -(length(p) - 0.8));\n    c = max(c, p.y - 0.3);\n    \n    p.x += 1.0;\n    p.y += 0.3;\n    \n    float h = length(vec2(length(p.xy) - 0.5, p.z)) - 0.1;\n    h = max(h, p.x - 0.4);\n    \n    h = smoothmin(h, c, 0.1);\n    \n    p.yz = rot(p.yz, sign(p.z)*0.3);\n    float s = length((p - vec3(1.6, -0.37, 0))*vec3(1.6, 1.3, 0.7)) - 0.3;\n    h = max(h, -s);\n    \n    return h;\n}\n\nfloat eyes(vec3 p) {\n    vec3 op = p;\n    \n    p.y -= 1.07;\n    p.x -= 0.65;\n    \n    p.y *= 0.7;\n    p.z *= 0.7;\n    \n\tp.z = abs(p.z) - 0.14;\n    \n    float e = length(p) - 0.4;\n    e = max(e, p.y - 0.16);\n    \n    return max(e, -(length(op) - 0.8));\n}\n\nfloat innereyes(vec3 p) {    \n    p.y -= 1.07;\n    p.x -= 0.65;\n    \n    p.y *= 0.7;\n    p.z *= 0.7;\n    \n    p.xy = rot(p.xy, 0.3);\n\n    p.y *= 0.7;\n    p -= vec3(0.3, -0.0, -0.0);\n    \n    p.z += 0.07*cos(10.0*iTime)*smoothstep(-0.2, 1.0, sin(iTime));\n    p.z = abs(p.z) - 0.25;\n    \n    float e = length(p) - 0.15;\n    return e;\n}\n\nfloat nose(vec3 p) {\n    p.xy -= vec2(0.9, 0.6);\n    return length(p*vec3(0.8, 1.2, 0.8)) - 0.1;\n}\n\nfloat torso(vec3 p) {\n    vec3 q = p;\n    \n    p.xz *= 1.0 - 0.4*smoothstep(-1.1, 0.3, -p.y);\n    float s = cylinder(p, vec2(0.45, 0.7));\n    \n    q.y += 0.4;\n    s = min(s, max(length(q) - 0.83, q.y - 0.1));\n    return s;\n}\n\nfloat legs(vec3 p) {\n    p.z = -abs(p.z) + 0.4;\n    \n \n    float b = -0.1*cos(14.0*iTime);\n    float l = segment(p + vec3(0, b, 0), \n                      vec3(0), \n                      vec3(0.1, -0.5, -0.3), \n                      0.17);\n    \n    l = min(l, segment(p + vec3(0, b, 0), \n                       vec3(0.1, -0.5, -0.3), \n                       vec3(-0.2, -1.0 + 1.2*b, 0), 0.17));\n    \n    p.yz = rot(p.yz, -0.4);\n    return min(l, cylinder(p - vec3(0, 0.5 - b, 0), vec2(0.25, 0.5)));\n}\n\nfloat shoes(vec3 p) {\n    p.y += 0.7;\n\n    float b = -0.1*cos(14.0*iTime);\n    p.z = -abs(p.z) + 0.4;\n\n    vec3 heel = vec3(-0.2, 0.1-b, 0);\n    vec3 toes = vec3(0.3, 0, -0.4);\n    \n    \n    float sh = segment(p*vec3(0.8, 1.0, 0.8), heel, toes, \n                       0.25 + 0.14*smoothstep(0.0, 0.7, p.x));\n    \n    return sh;\n}\n\nfloat arms(vec3 p) {\n    p.y -= 0.2;\n    p.z = -abs(p.z) + 0.85;\n    \n    p.z -= 0.75;\n    p.yz = rot(p.yz, -0.6*smoothstep(-1.0, 0.5, p.y));\n    p.z += 0.75;\n    float a = segment(p, vec3(0), vec3(0, -0.7, -0.3), 0.08);\n    \n    return a;\n}\n\nfloat hands(vec3 p) {\n    p *= 0.9;\n    p.y -= 0.4;\n    p.z = -abs(p.z) + 1.07;\n    \n    float s = length((p - vec3(0, 0.1, 0))*vec3(1.2, 1.4, 1.2)) - 0.35;\n    s = min(s, length((p - vec3(0, 0.4, 0))*vec3(1, 1.6, 1)) - 0.2);\n    \n    s = smoothmin(s, segment(p - vec3(0.0, 0.16, 0.17), \n                             vec3(0), \n                             vec3(-0.1, -0.2, 0.2), 0.08), 0.1);\n    \n    s = smoothmin(s, segment(p - vec3(0.0, 0.16, 0.17),\n                             vec3(-0.1, -0.2, 0.2),\n                             vec3(-0.1, -0.3, 0.1), 0.08), 0.01);\n    \n    p.z = -abs(p.z) + 0.12;\n    p.z = -abs(p.z) + 0.05;\n    \n    p.x -= 0.1;\n    p.y += 0.05;\n    s = smoothmin(s, segment(p, vec3(0), vec3(0, -0.12, 0), 0.07), 0.1);\n    s = smoothmin(s, segment(p, vec3(0, -0.12, 0), vec3(-0.2, -0.1, 0), 0.07), 0.02);\n    return s;\n}\n\n#define SHOES 1.0\n#define LEGS 2.0\n#define HANDS 3.0\n#define TORSO 4.0\n#define HEAD  5.0\n#define STRAW 6.0\n#define EYES 7.0\n#define INNEREYES 8.0\n#define NOSE 9.0\n\nvec2 de(vec3 p) {\n    vec2 f = vec2(min(p.y + 1.0, p.x + 3.0), 0.0);\n    vec2 sh = vec2(shoes(p), SHOES);\n    \n    p.y -= 0.2*cos(14.0*iTime);\n\tp.y -= 0.6;\n    vec2 l = vec2(legs(p), LEGS);\n    vec2 ds = vec2(hands(p), HANDS);\n    p.y -= 1.35;\n    \n    vec2 t = vec2(smoothmin(torso(p), arms(p), 0.4), TORSO);\n    \n    p.y -= 0.6;\n    vec2 h = vec2(head(p), HEAD);\n    vec2 s = vec2(straw(p), STRAW);\n    vec2 e = vec2(eyes(p), EYES);\n    vec2 ie = vec2(innereyes(p), INNEREYES);\n    vec2 m = vec2(nose(p), NOSE);\n    \n    vec2 ret = dmin(f, sh);\n    ret = dmin(ret, dmin(l, t));\n    ret = dmin(ret, dmin(h, s));\n    ret = dmin(ret, e);\n    ret = dmin(ret, ie);\n    ret = dmin(ret, ds);\n    ret = dmin(ret, m);\n    \n    return ret;\n}\n\nvec2 trace(vec3 o, vec3 d, float x) {\n    float t = 0.0;\n    float m = -1.0;\n    \n    for(int i = 0; i < 100; i++) {\n        vec2 d = de(o + d*t);\n        if(d.x < 0.001 || t >= x) break;\n        t += d.x*0.85;\n        m = d.y;\n    }\n    \n    return vec2(t, t < x ? m : -1.0);\n}\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.001, 0.0);\n    vec3 n = vec3(\n        de(p + h.xyy).x - de(p - h.xyy).x,\n        de(p + h.yxy).x - de(p - h.yxy).x,\n        de(p + h.yyx).x - de(p - h.yyx).x\n    );\n    return normalize(n);\n}\n\n\nfloat ao(vec3 p, vec3 n) {\n    float o = 0.0, s = 0.005, w = 1.0;\n    for(int i = 0; i < 15; i++) {\n        float d = de(p + n*s).x;\n        o += (s - d)*w;\n        w *= 0.98;\n        s += s/float(i + 1);\n    }\n    return 1.0 - sat(o);\n}\n\nmat3 camera(vec3 e, vec3 l) {\n    vec3 w = normalize(l - e);\n    vec3 u = normalize(cross(vec3(0, 1, 0), w));\n    vec3 v = normalize(cross(w, u));\n    \n    return mat3(u, v, w);\n}\n\nvec3 materail(vec3 p, float m) {\n    p.y -= 0.2*cos(14.0*iTime);\n    \n    if(m == 0.0) {\n        return vec3(1.5);\n    } else if(m == STRAW) {\n        p.xy = rot(p.xy, -1.0*step(4.4, p.y));\n    \tvec3 m = vec3(1.5, 0, 0);\n        m += vec3(0.5, 2.0, 2.0)*smoothstep(0.3, 0.8, abs(cos(10.0*p.y)));\n        \n        return m;\n    } else if(m == TORSO) return vec3(0.1) + vec3(1, 0, 0)*step(-1.63, -p.y);\n    else if(m == HANDS) return vec3(2.0);\n    else if(m == EYES) return vec3(2.0);\n    else if(m == INNEREYES) return vec3(0.1);\n    else if(m == NOSE) return vec3(1.5, 0.1, 0.1);\n    else if(m == SHOES) return vec3(1.09, 0.54, 0.14);\n    else if(m == LEGS) {\n        p.z = -abs(p.z) + 0.4;\n        p.yz = rot(p.yz, -0.4);\n        \n        p.y -= 0.1*cos(14.0*iTime);;\n        \n        if(p.y > 0.52) return vec3(1.1, 0.1, 0.1);\n        else return vec3(1);\n\t} else return vec3(1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    vec2 mo = iMouse.z == 0.0\n        ? vec2(1.5, 1.0)\n        : (-iResolution.xy + 4.0*iMouse.xy)/iResolution.y;\n    \n    float at = 0.5*iTime;\n    \n    vec3 ro = vec3(7.0*sin(mo.x), 1.0 + 2.0*mo.y, 7.0*cos(mo.x));\n    vec3 rd = camera(ro, vec3(0, 2.5, 0))*normalize(vec3(p, 1.97));\n    \n    vec3 col = vec3(0);\n    vec3 lig = normalize(vec3(0.8, 0.7, -0.6));\n    \n    vec2 t = trace(ro, rd, 50.0);\n    if(t.x < 50.0) {\n        vec3 pos = ro + rd*t.x;\n        vec3 nor = normal(pos);\n        vec3 ref = reflect(rd, nor);\n        \n        float occ = ao(pos, nor);\n        float sha = step(15.0, trace(pos+nor*0.001, lig, 15.0).x);\n        \n        col += 0.5*occ;\n        col += sat(dot(lig, nor))*occ*sha;\n        col += pow(sat(1.0 + dot(rd, nor)), 2.0)*occ;\n        col += 2.0*pow(sat(dot(lig, ref)), 20.0)*occ;\n        \n        col *= materail(pos, t.y);\n    }\n    \n    col = mix(vec3(0), col, exp(-0.1*t.x));\n    \n    col = 1.0 - exp(-0.5*col);\n    col = pow(col, vec3(1.0/2.2));\n    \n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MllBWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 62, 62, 94], [96, 96, 140, 140, 233], [235, 235, 262, 262, 345], [347, 347, 379, 379, 486], [488, 488, 536, 536, 681], [683, 683, 704, 704, 1138], [1140, 1140, 1160, 1160, 1596], [1598, 1598, 1618, 1618, 1851], [1853, 1853, 1878, 1878, 2186], [2188, 2188, 2208, 2208, 2286], [2288, 2288, 2309, 2309, 2512], [2514, 2514, 2534, 2534, 3014], [3016, 3016, 3037, 3037, 3346], [3348, 3348, 3368, 3368, 3589], [3591, 3591, 3612, 3612, 4435], [4601, 4601, 4618, 4618, 5334], [5336, 5336, 5373, 5373, 5614], [5616, 5616, 5637, 5637, 5849], [5852, 5852, 5878, 5878, 6089], [6091, 6091, 6120, 6120, 6270], [6272, 6272, 6304, 6304, 7156], [7158, 7158, 7215, 7215, 8297]], "test": "untested"}
{"id": "MllBzj", "name": "Moebius Spiral iso-grid", "author": "FabriceNeyret2", "description": "Application of screenspace isolines in procedural transforms\nBetter seen in fullscreen.\n\nIlusion: lines keeps undistorted despite the stretching. ;-)", "tags": ["spiral", "mobius", "illusion", "complex", "screenspace", "tuto", "weave"], "likes": 14, "viewed": 726, "published": "Public API", "date": "1512552905", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of  https://shadertoy.com/view/llsfRj\n// application from https://shadertoy.com/view/Xlffzj\n\n#define S(v) smoothstep(2./iResolution.y, 0., v )\n\n// --- direct transforms\nvec2 Mobius(vec2 p, vec2 z1, vec2 z2)\n{\n\tz1 = p - z1; p -= z2;\n\treturn mat2(z1,z1.y,-z1.x) * p / dot(p, p);\n}\n\nvec2 spiralZoom(vec2 p, vec2 offs, float n, float spiral, float spiral2, float zoom, vec2 phase)\n{\n\tp -= offs;\n\tfloat a = atan(p.y, p.x)/6.283 + iTime/32.;\n\tfloat d = length(p);\n\treturn mat2(n,spiral2, spiral,-zoom) * vec2(a, log(d)) + phase;\n}\n\n// --- inverse transforms\nvec2 iMobius(vec2 p, vec2 z1, vec2 z2)     \n{                               \n    float s = sign(p.x), sb = sign(p.y),             // make unique sol: s=1,x1,y1 otherwise 4\n          l = length(p), t = p.y/p.x,                // solve  u = v*l ; tan(u,v) = p.y/p.x\n          c = s / sqrt(1.+t*t),                      // c = cos(atan( ) )\n        v = length(z1-z2) / sqrt( 1.+ l*l -2.*l*c ), // c = (u²+v²-|z1z2|² ) / 2uv\n        u = v*l;                                   \n    vec2  a = 2.*(z1-z2);                            // solve |P-z1| = u ; |P-z2| = v\n    float b = u*u-v*v + dot(z2,z2)-dot(z1,z1);       // ||²-||²: a.P + b = 0\n    // y = -( b + a.x* x ) / a.y                     // normalize by a.y\n    b /= a.y; a /= a.y;                              // ( in Shane example a.y was = 0 ! )\n    float A = 1. +  a.x*a.x,                         //  |P-z1|² = u² , P = (x,y)\n          B =     2.* b*a.x -2.*dot(vec2(1,-a.x),z1),\n          C =           b*b +2.*b*z1.y + dot(z1,z1) - u*u,\n          D = max(0., B*B - 4.*A*C),\n         x1 = (-B+sb*sqrt(D))/(2.*A), y1 = -( b + a.x*x1 );\n     //  x2 = (-B-sb*sqrt(D))/(2.*A), y2 = -( b + a.x*x2 );\n  // if (abs(A)<1e-5) { x1 = x2 = -C/B; y1 = y2 = -( b + a.x*x1 ) / a.y; } // degenerate case\n\treturn vec2(x1,y1);                    \n}\n\nvec2 ispiralZoom(vec2 p, vec2 offs, float n, float spiral, float spiral2, float zoom, vec2 phase)\n{\n    p = inverse(mat2(n,spiral2, spiral,-zoom)) * (p-phase) ;\n    p.x = (p.x - iTime/32.) * 6.283;             // ( p.x, p.y )  = ( a, log(d) )\n    return exp(p.y) * vec2(cos(p.x),sin(p.x)) + offs;\n}\n\n// --- demo configuration \nvec2 Z1 = vec2(-.875, -.525),  // in Shane example Z1.y=Z2.y was causing a degenerescence\n     Z2 = vec2(.375, -.125);\nfloat spiral = 3.14159*.2,\n      spiral2 = 2.5; // ~= 3.14159*.8 . was 1\n\nvec2 MobiusSpiral(vec2 q)      // total direct transform\n{\n    q = Mobius(q, Z1, Z2);\n    return spiralZoom(q, vec2(-.5), 5., spiral, spiral2, .5, vec2(-1, 1)*iTime*.125);\n}\nfloat DrawInvMobiusSpiral(vec2 q, vec2 uv0, float r) // total inverse transform + draw iso-X\n{\n    vec2 v; float s = 0.;\n    q = ispiralZoom(q, vec2(-.5), 5., spiral, spiral2, .5, vec2(-1, 1)*iTime*.125);\n    v = iMobius(q, Z1, Z2);  \n    return S(length(uv0-v) - r ) ; //* (.5+.5* cos( 3.14 * length(uv0-v) / r / 2.) );\n}\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n\tvec2 R = iResolution.xy,\n        uv0 = (U -.5*R) / R.y,\n    uv = MobiusSpiral(uv0);\n#define f(v) (fract(v/spiral2+.5)-.5)*spiral2                    // suppress the wrapping glitch\n    mat2 M = inverse(mat2(f(dFdx(uv)),f(dFdy(uv)))) / R.y;       // measure compression, for LOD\n     \n    O -= O;\n    float l,a, r=0.; vec2 q;\n    for (int i=0; i<2; i++) {\n        //q = floor(uv*4.)/4.;\n        \n        l = log2(20.*length(M[1]));\n        a = fract(l);\n        l = exp2(floor(l));                                      // compute H-LOD\n        q = vec2( floor(uv.x*l+float(i)) / l, uv.y );            // H isolines in screen space\n        O += (1.-O)* (1.-a)* DrawInvMobiusSpiral(q, uv0, r );\n        q = vec2( floor(uv.x*(l*2.)+float(i)) / (l*2.), uv.y );  // inter-LOD fading\n        O += (1.-O)* a* DrawInvMobiusSpiral(q, uv0, r );\n#if 1   \n        l = log2(46.*length(M[0])); // was 100\n        a = fract(l);\n        l = exp2(floor(l));                                      // compute V-LOD\n        q = vec2( uv.x, floor(uv.y*l+float(i)) / l );            // V isolines in screen space\n        O += (1.-O)* (1.-a)* DrawInvMobiusSpiral(q, uv0, r );\n        q = vec2( uv.x, floor(uv.y*(l*2.)+float(i)) / (l*2.) );  // inter-LOD fading\n        O += (1.-O)* a* DrawInvMobiusSpiral(q, uv0, r );\n#endif\n\n    }\n    O = sqrt(O);                                                 // to sRGB\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MllBzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 180, 219, 219, 289], [291, 291, 389, 389, 535], [537, 563, 608, 608, 1858], [1860, 1860, 1959, 1959, 2158], [2354, 2380, 2438, 2438, 2553], [2554, 2554, 2648, 2648, 2876], [2878, 2878, 2914, 2914, 4300]], "test": "untested"}
{"id": "MllfRX", "name": "Marching Ikura", "author": "jakerr", "description": "First shader.", "tags": ["circles", "dots", "cells", "polka"], "likes": 1, "viewed": 102, "published": "Public", "date": "1512744910", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CELL vec2(0.1, 0.1)\n\nfloat circle(vec2 coord, float r) {\n    // Alternate crawl\n    if(mod(coord.y, CELL.y * 2.0) < CELL.y) {\n        coord.x += mod(iTime/30. * (1.0 + floor(coord / CELL).y), CELL.x);\n    } else {\n        coord.x += mod(iTime/30. * (CELL.y - floor(coord / CELL).y), CELL.x);\n    }\n    vec2 cell = floor(coord / CELL);\n    vec2 center = cell * CELL + CELL/2.0;\n    return r - distance(coord, center);\n}\n\nvec4 crawl(vec2 coord) {\n    vec2 uv = coord;\n    float circle1 = smoothstep(0.0, CELL.y/8.0, circle(coord,  CELL.y/3.5));\n    float circle2 = smoothstep(0.0, CELL.y/4.0, circle(coord,  CELL.y/2.0));\n    vec4 grad1 = vec4(uv.rg, 1.0, 1.0);\n    vec4 grad2 = vec4(2.0 * abs(uv.x+sin(iTime)/2.0), 0.5, 0.5, 0.0);\n\n    vec4 bg = vec4(0.1, 0.2, 0.4, 1.0);\n    vec4 color = mix(bg, grad1, circle1);\n    color = mix(color, grad2, circle2 * 0.5);\n    return color;\n}\n\nvec4 ghost(vec2 coord, float times) {\n    vec4 color = vec4(0.0);\n    float m = 1.0;\n    for(float i = 0.; i < times; i++) {\n        color = mix(color, crawl(coord), m);\n        coord.x -= CELL.x/(times);\n        coord.y += CELL.y/(times);\n        m -= (0.5 / (times));\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 coord = fragCoord / iResolution.y;\n    fragColor = ghost(coord, 15. + sin(iTime * (coord.x / CELL.x)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MllfRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 64, 87, 426], [428, 428, 452, 452, 886], [888, 888, 925, 925, 1183], [1185, 1185, 1242, 1242, 1354]], "test": "untested"}
{"id": "MllfWN", "name": "Relative Sky Luminance", "author": "reinsteam", "description": "Logarithmic plot of relative sky luminance distributions (Blue), relative luminance gradations (Green) and scattering indicatrices (Red) according to a paper \"CIE General Sky Standard Defining Luminance Distributions\" by Darula and Kittler. ", "tags": ["ciesky"], "likes": 5, "viewed": 475, "published": "Public API", "date": "1512405058", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by reinsteam / Dec 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// This sample demonstrate various relative sky luminance distributions from the paper\n// \"CIE General Sky Standard Defining Luminance Distributions\" by Darula and Kittler \n// Referenced below as [Darula02]\n\n\n#define USE_SOFT_TYPE_TRANSITION 1\n\nconst float kPiOverTwo = 1.5707963;\n\n// Table (1) from [Darula02]\nconst vec2 kGradation_1 = vec2( 4.0, -0.70);\nconst vec2 kGradation_2 = vec2( 1.1, -0.80);\nconst vec2 kGradation_3 = vec2( 0.0, -1.00);\nconst vec2 kGradation_4 = vec2(-1.0, -0.55);\nconst vec2 kGradation_5 = vec2(-1.0, -0.32);\nconst vec2 kGradation_6 = vec2(-1.0, -0.15);\n\nconst vec3 kIndicatrix_1 = vec3( 0.0, -1.0, 0.00);\nconst vec3 kIndicatrix_2 = vec3( 2.0, -1.5, 0.15);\nconst vec3 kIndicatrix_3 = vec3( 5.0, -2.5, 0.30);\nconst vec3 kIndicatrix_4 = vec3(10.0, -3.0, 0.45);\nconst vec3 kIndicatrix_5 = vec3(16.0, -3.0, 0.30);\nconst vec3 kIndicatrix_6 = vec3(24.0, -2.8, 0.15);\n\nvec2 TypeToAB[15] = vec2[]\n(\n    kGradation_1,\n    kGradation_1,\n    kGradation_2,\n    kGradation_2,\n    kGradation_3,\n    kGradation_3,\n    kGradation_3,\n    kGradation_3,\n    kGradation_4,\n    kGradation_4,\n    kGradation_4,\n    kGradation_5,\n    kGradation_5,\n    kGradation_6,\n    kGradation_6\n);\n\nvec3 TypeToCDE[15] = vec3[]\n(\n    kIndicatrix_1,\n    kIndicatrix_2,\n    kIndicatrix_1,\n    kIndicatrix_2,\n    kIndicatrix_1,\n    kIndicatrix_2,\n    kIndicatrix_3,\n    kIndicatrix_4,\n    kIndicatrix_2,\n    kIndicatrix_3,\n    kIndicatrix_4,\n    kIndicatrix_4,\n    kIndicatrix_5,\n    kIndicatrix_5,\n    kIndicatrix_6\n);\n\n// Formula (5) from [Darula02]\nfloat LuminanceGradation(float Mu, vec2 AB)\n{\n    float A = AB.x;\n    float B = AB.y;\n    return (Mu < 0.0000001) ? 1.0 : 1.0 + A * exp(B / Mu);\n}\n\n\n// Figure (2) from [Darula02]\nfloat LuminanceGradation_Relative(float Angle, vec2 AB)\n{\n    float CosAngle = cos(Angle);\n\treturn LuminanceGradation(CosAngle, AB) / LuminanceGradation(1.0, AB);\n}\n\n// Formula (7) (8) and Figure (3) from [Darula02]\nfloat ScatteringIndicatrix(float Angle, vec3 CDE)\n{\n    float C = CDE.x;\n    float D = CDE.y;\n    float E = CDE.z;\n    float CosAngle = cos(Angle);\n    return 1.0 + C * (exp(D * Angle) - exp(D * kPiOverTwo)) + E * CosAngle * CosAngle;\n}\n\nfloat ScatteringIndicatrix_Relative(float EyeToSun, float SunZenith, vec3 CDE)\n{\n    return ScatteringIndicatrix(EyeToSun, CDE) / ScatteringIndicatrix(SunZenith, CDE);\n}\n\nfloat Luminance_Relative(float EyeZenith, float SunZenith, float EyeToSun, vec2 AB, vec3 CDE)\n{\n    \n    return ScatteringIndicatrix_Relative(EyeToSun, SunZenith, CDE) *\n           LuminanceGradation_Relative(EyeZenith, AB);\n}\n\nfloat Luminance_Relative(float EyeZenith, float SunZenith, float EyeToSun, int Type)\n{\n    return Luminance_Relative(EyeZenith, SunZenith, EyeToSun, TypeToAB[Type], TypeToCDE[Type]);\n}\n\nfloat Plot(float F, float Y)\n{\n    float Y_Scale = 6.0;\n    float Y_Shift = 2.0;\n    F = log2(F);\n    Y = (Y * 2.0 - 1.0);\n    float Y_Delta = F - Y * Y_Scale;\n    //return 1.0 - clamp(abs(F - Y * y_stretch - y_offset)  / fwidth(F - Y * y_stretch), 0.0, 1.0);\n    //return 1.0 - smoothstep(0.0, 1.0, abs(Y_Delta - Y_Shift) * 0.5 / fwidth(Y_Delta));\n    return 1.0 - clamp(abs(Y_Delta - Y_Shift) * 0.5 / fwidth(Y_Delta), 0.0, 1.0);\n}\n\nfloat Max6(float X0, float X1, float X2, float X3, float X4, float X5)\n{\n    return max(max(max(X0, X1), max(X2, X3)), max(X4, X5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat U = fragCoord.x / iResolution.x;\n    float V = fragCoord.y / iResolution.y;\n    \n    float X = iMouse.x / iResolution.x;\n    float Y = iMouse.y / iResolution.y;\n    \n    float ZeroToPi = kPiOverTwo * X * 2.0;\n    float ZeroToPi_U = kPiOverTwo * U * 2.0;\n    float ZeroToHalfPi_U = kPiOverTwo * U;\n    \n    // ZeroToHalfPi_U defines angular difference between EyeDir and Zenith\n    // Corresponds to Figure (2) from [Darula02]\n    float LG1 = LuminanceGradation_Relative(ZeroToHalfPi_U, kGradation_1);\n    float LG2 = LuminanceGradation_Relative(ZeroToHalfPi_U, kGradation_2);\n    float LG3 = LuminanceGradation_Relative(ZeroToHalfPi_U, kGradation_3);\n    float LG4 = LuminanceGradation_Relative(ZeroToHalfPi_U, kGradation_4);\n    float LG5 = LuminanceGradation_Relative(ZeroToHalfPi_U, kGradation_5);\n    float LG6 = LuminanceGradation_Relative(ZeroToHalfPi_U, kGradation_6);\n\n#if 0\n    // ZeroToHalfPi_U defines difference between SunDir and Zenith\n    // ZeroToPi defines difference between SunDir and EyeDir\n    float SI1 = ScatteringIndicatrix_Relative(ZeroToPi, ZeroToHalfPi_U, kIndicatrix_1);\n    float SI2 = ScatteringIndicatrix_Relative(ZeroToPi, ZeroToHalfPi_U, kIndicatrix_2);\n    float SI3 = ScatteringIndicatrix_Relative(ZeroToPi, ZeroToHalfPi_U, kIndicatrix_3);\n    float SI4 = ScatteringIndicatrix_Relative(ZeroToPi, ZeroToHalfPi_U, kIndicatrix_4);\n    float SI5 = ScatteringIndicatrix_Relative(ZeroToPi, ZeroToHalfPi_U, kIndicatrix_5);\n    float SI6 = ScatteringIndicatrix_Relative(ZeroToPi, ZeroToHalfPi_U, kIndicatrix_6);\n#else\n    // ZeroToPI_U defines angular difference between SunDir and EyeDir\n    // Corresponds to Figure (3) from [Darula02]\n    float SI1 = ScatteringIndicatrix(ZeroToPi_U, kIndicatrix_1);\n    float SI2 = ScatteringIndicatrix(ZeroToPi_U, kIndicatrix_2);\n    float SI3 = ScatteringIndicatrix(ZeroToPi_U, kIndicatrix_3);\n    float SI4 = ScatteringIndicatrix(ZeroToPi_U, kIndicatrix_4);\n    float SI5 = ScatteringIndicatrix(ZeroToPi_U, kIndicatrix_5);\n    float SI6 = ScatteringIndicatrix(ZeroToPi_U, kIndicatrix_6);\n#endif\n    \n    \n    float PlotR = Max6(Plot(LG1, V), Plot(LG2, V), Plot(LG3, V),\n                       Plot(LG4, V), Plot(LG5, V), Plot(LG6, V));\n\n    float PlotG = Max6(Plot(SI1, V), Plot(SI2, V), Plot(SI3, V),\n                       Plot(SI4, V), Plot(SI5, V), Plot(SI6, V));\n    \n    float PlotB = 0.0;\n    \n    float EyeZenith = U * kPiOverTwo * 2.0;\n    float EyeToSun  = X * kPiOverTwo * 2.0;    \n    \n    float NumTypes = 15.0;\n    \n    {\n        Y = fract(iTime * 1.0 / NumTypes);\n        \n        float Type = floor(Y * NumTypes);\n        float TypeLerp = fract(Y * NumTypes);\n        for (int SunZenithIdx = 0; SunZenithIdx < 16; ++SunZenithIdx)\n        {\n            float SunZenith = (float(SunZenithIdx) / 16.0) * kPiOverTwo ;\n#if USE_SOFT_TYPE_TRANSITION\n            float Lum0 = Luminance_Relative(EyeZenith, SunZenith, EyeToSun, int(Type));\n            float Lum1 = Luminance_Relative(EyeZenith, SunZenith, EyeToSun, (int(Type) + 1) % int(NumTypes));\n            float Lum = mix(Lum0, Lum1, TypeLerp);\n#else\n            float Lum = Luminance_Relative(EyeZenith, SunZenith, EyeToSun, int(Type));\n#endif\n            PlotB = max(PlotB, Plot(Lum, V));\n        }\n    }\n    fragColor = vec4(PlotR, PlotG, PlotB, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MllfWN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1632, 1663, 1708, 1708, 1809], [1812, 1842, 1899, 1899, 2006], [2008, 2058, 2109, 2109, 2294], [2296, 2296, 2376, 2376, 2465], [2467, 2467, 2562, 2562, 2693], [2695, 2695, 2781, 2781, 2879], [2881, 2881, 2911, 2911, 3313], [3315, 3315, 3387, 3387, 3449], [3451, 3451, 3508, 3508, 6802]], "test": "untested"}
{"id": "MlSBRR", "name": "KIFS fork", "author": "tholzer", "description": "marginally modifies KIFS shader from EvilRyu\nsee [url]https://www.shadertoy.com/view/MdlSRM[/url]\nmouse.x = scaling,  mouse.y = recursion", "tags": ["3d", "raymarching", "fractal", "kifs"], "likes": 20, "viewed": 668, "published": "Public", "date": "1514198169", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// KIFS fork of https://www.shadertoy.com/view/MdlSRM\n\nfloat stime, ctime;\n \nvoid ry(inout vec3 p, float a)\n{\n  float ca = cos(a), sa = sin(a);\n  vec3 q = p;\n  p.x =  ca * q.x + sa * q.z;  \n  p.z = -sa * q.x + ca * q.z; \n}  \n\n/*\n  void rx(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.y = c * q.y - s * q.z;  \n  \tp.z = s * q.y + c * q.z; \n }\n\n void rz(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x - s * q.y;  \n  \tp.y = s * q.x + c * q.y; \n }  \n*/\n\nfloat plane(vec3 p, float y)\n{\n    return length(vec3(p.x, y, p.z) - p);\n}\n\nvec3 mat = vec3(0.0);\nbool bcolor = false;\nvec2 mp = vec2(0);\n\nfloat menger_spone(in vec3 z0)\n{\n\tvec4 z=vec4(z0,1.0);\n    vec3 offset = vec3(0.45+mp.x*6.6, 1.1, 0.46);\n    float scale = 2.48;\n\tfor (int n = 0; n < 5; n++)\n    {\n\t\tz = abs(z);\n\t\tif (z.x<z.y)z.xy = z.yx;\n\t\tif (z.x<z.z)z.xz = z.zx;\n\t\tif (z.y<z.z)z.yz = z.zy;\n\t\tz = z*scale;\n\t\tz.xyz -= offset*(scale-1.0);\n       \tif(bcolor && n==2)mat+=vec3(0.5)+sin(z.xyz)*vec3(1.0, 0.24, 0.245);\n        // translate the middle cube to top right corner\n\t\tif(z.z<-0.5*offset.z*(scale-1.0))z.z+=offset.z*(scale-1.0);\n        if (float(n-1) > mp.y*3.) break;\n\t}\n\treturn (length(max(abs(z.xyz)-vec3(1.0),0.0))-0.05)/z.w;\n}\n\nvec3 f(vec3 p)\n{\n  ry(p, stime);\n  float d1 = plane(p, -1.0);\n  float d2 = menger_spone(p);\n  if(d1 < d2)\n    return vec3(d1, 0.0, 0.0);\n  else\n    return vec3(d2, 1.0, 0.0);\n} \n\nfloat ao(vec3 p, vec3 n)\n{\n  float ao=0.0,sca=1.0; \n  for(float i=0.0;i<20.0;++i)\n  { \n \tfloat hr=0.05+0.015*i*i; \n \tao+=(hr-f(n*hr+p).x)*sca; \n \tsca*=0.75; \n  } \n  return 1.0-clamp(ao,0.0,1.0); \n} \n\nfloat rand(vec2 t)\n{\n  return fract(sin(dot(t*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float k)\n{ \n  float akuma=1.0,h=0.0; \n  float t = 0.01;\n  for(int i=0; i < 50; ++i)\n  { \n    h=f(ro+rd*t).x; \n    if(h<0.001){akuma=0.0;break;} \n    akuma=min(akuma, k*h/t); \n    t+=abs(h);\n  } \n  return clamp(akuma*0.8+0.2, 0.0, 1.0); \n} \n\nvec3 nor(vec3 p)\n{ \n  vec3 e=vec3(0.0001,0.0,0.0); \n  return normalize(vec3(f(p+e.xyy).x-f(p-e.xyy).x, \n  \t\t\t\t\t    f(p+e.yxy).x-f(p-e.yxy).x, \n \t\t\t\t\t\tf(p+e.yyx).x-f(p-e.yyx).x)); \n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec3 res = vec3(-1.0);\n\tvec3 h = vec3(1.0);\n    for( int i=0; i<64; i++ )\n    {\n\t\tif( h.x<0.003 || t>30.0 ){\n\t\t}else {\n        \th = f(ro + rd*t);\n        \tres = vec3(t,h.yz);\n        \tt += abs(h.x);\n\t\t}\n    }\n\tif( t>30.0 ) res=vec3(-1.0);\n    return res;\n}\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n    mp = iMouse.xy / iResolution.xy; \n    if (iFrame < 88) mp = vec2(0.035,0.6);\n \tuv.x *= iResolution.x/iResolution.y; \n\t// camera\n \tstime=sin(iTime*0.2); \n \tctime=cos(iTime*0.2); \n\n \tvec3 ta=vec3(.0,0.0,0.0); \n \t//vec3 ro=vec3(3.0*stime,stime*2.0+1.0, 3.0*ctime); \n\tvec3 ro = vec3(3.5*ctime, 2.2+0.5*ctime, 5.8+1.0*stime) * 0.5;\n\n \tvec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n \tvec3 rd = normalize(uv.x*cs + uv.y*cu + 2.8*cf);  // transform from view to world\n\n    vec3 sundir = normalize(vec3(-3.5, 7.0,2.8)); \n    vec3 sun = vec3(1.64, 1.27, 0.99); \n    vec3 skycolor = vec3(0.6, 1.5, 1.0); \n\n\tvec3 bg = exp(uv.y-1.0)*vec3(0.6, 0.9, 1.4)*1.3;\n\n    float sc=clamp(dot(sundir, rd), 0.0, 1.0); \n    vec3 col=bg+vec3(1.0,0.8,0.4)*pow(sc,50.0); \n\n\n    float t=0.0;\n    vec3 p=ro; \n\t \n\tvec3 res = intersect(ro, rd);\n    if(res.x > 0.0)\n    {\n\t\tp = ro + res.x * rd;\n        bcolor = true;\n        mat=vec3(0.0);\n        vec3 n=nor(p);\n        mat/=6.0;\n        bcolor = false;\n        float occ = ao(p, n); \n        float shadow = softshadow(p, sundir, 10.0);\n\n        float dif = max(0.0, dot(n, sundir)); \n        float sky = 0.6 + 0.4 * max(0.0, dot(n, vec3(0.0, 1.0, 0.0))); \n        float bac = max(0.3 + 0.7 * dot(vec3(-sundir.x, -1.0, -sundir.z), n), 0.0); \n        float spe = max(0.0, pow(clamp(dot(sundir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n\n        vec3 lin = 5.5 * sun * dif * shadow; \n        lin += 0.8 * bac * sun * occ; \n        lin += 0.6 * sky * skycolor * occ; \n        lin += 3.0 * spe * occ; \n\n        col = lin *(vec3(0.9, 0.8, 0.6)*(1.0-res.y)+mat*res.y) *  0.2; \n        col=mix(col,bg, 1.0-exp(-0.02*res.x*res.x)); \n    } \n\n    // post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n \tfragColor.xyz = col; \n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSBRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 78, 110, 110, 223], [227, 538, 568, 568, 612], [677, 677, 709, 709, 1280], [1282, 1282, 1298, 1298, 1458], [1461, 1461, 1487, 1487, 1658], [1661, 1661, 1681, 1681, 1752], [1754, 1754, 1799, 1799, 2027], [2030, 2030, 2048, 2048, 2211], [2213, 2213, 2255, 2255, 2535], [2538, 2538, 2597, 2597, 4674]], "test": "untested"}
{"id": "MlsBRX", "name": "Military grid", "author": "warlock", "description": "Mousedown changes background color.", "tags": ["2d", "mouse", "grid"], "likes": 3, "viewed": 275, "published": "Public", "date": "1512742419", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* based on http://madebyevan.com/shaders/grid/ */\n  \nfloat grid(float width, vec2 step, vec2 pos){\n    vec2 coord = pos / step;\n\n    vec2 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord * width);\n    float line = min(grid.x, grid.y);\n\n    return 1. - min(line, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float v = grid(1., vec2(10.), fragCoord) + grid(2., vec2(100.), fragCoord);\n\n    float s = 500.; // step\n    float mp = mod(fragCoord.x - iTime * 100., s);\n    float sm = 1. - smoothstep(0., 50., mp) * (1. - smoothstep(s - 450.,s,mp));\n\n    vec3 c = v * vec3(0., 1., 1.) * sm;\n    \n    vec3 col = vec3(0.);\n    if (iMouse.w > .5) col = vec3(1.);\n    \n    c = mix(col, c, v);\n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlsBRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 54, 99, 99, 273], [275, 275, 332, 332, 739]], "test": "untested"}
{"id": "MlsfRX", "name": "Islamic Pattern", "author": "rigel", "description": "A study on symmetry. I used this [url=https://patterninislamicart.com/drawings-diagrams-analyses/5/geometric-patterns-borders/gpb033]pattern[/url] as an inspiration and tried to colorize it.. Fullscreen is better.", "tags": ["2d", "pattern", "symmetry"], "likes": 30, "viewed": 1309, "published": "Public API", "date": "1512755594", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: Rigel rui@gil.com\n// licence: https://creativecommons.org/licenses/by/4.0/\n// link: https://www.shadertoy.com/view/MlsfRX\n\n\n/*\nA study on symmetry. Took this pattern as a challenge and then tried to colorize it.\nhttps://patterninislamicart.com/drawings-diagrams-analyses/5/geometric-patterns-borders/gpb033\n\nThe plane has four kind of symmetric operations\n- translations\n- rotations\n- reflections\n- glide reflections\n\nThis pattern only have the first three.\nEverything is made of two simple rectangles, with translations, rotations, and\nreflections.\n\n*/\n\n#define TAU 6.2831\n\n// cartesian to polar coordinates\nvec2 toPolar(vec2 uv) { return vec2(length(uv),atan(uv.y,uv.x)); }\n// polar to cartesian coordinates\nvec2 toCarte(vec2 z) { return z.x*vec2(cos(z.y),sin(z.y)); }\n// 2d rotation matrix\nmat2 uvRotate(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n// A signed distance function for a rectangle\nfloat sdfRect(vec2 uv, vec2 s) { vec2 auv = abs(uv); return max(auv.x-s.x,auv.y-s.y); }\n// To fill an sdf with 0's or 1's\nfloat fill(float d, float i) { return abs(smoothstep(.0,.02,d) - i); }\n\n// palette from iq -> https://www.shadertoy.com/view/ll2GD3\nvec3 pal(float d) { return .5 + .5 * cos(TAU*(d+vec3(.0,.10,.20))); }\n\n// This makes a symmetric rotation around the origin.\n// n is the number of slices, and everything is remmapped to the first one.\nvec2 symrot(vec2 uv, float n) { \n    vec2 z = toPolar(uv); \n    return toCarte(vec2(z.x,mod(z.y,TAU / n) - TAU/(n*2.) ));\n}\n\n// This is the fundamental pattern where everything in the plane is remapped\n// with symmetric operations.\nvec3 pattern(vec2 uv) {\n\t\n    // The coordinates for the two rectangles\n\tvec2 uv1 = uv*uvRotate(radians(30.));\n\tvec2 uv2 = uv*uvRotate(radians(-30.));\n\t\n    // The signed distance functions\n\tfloat sdfr1 = sdfRect(uv1,vec2(.1,.7));\n\tfloat sdfr2 = sdfRect(uv2,vec2(.1,.7));\n\t\n    // A fill to keep track of their areas and masks\n\tfloat r1 = fill(sdfr1,1.);\n\tfloat r2 = fill(sdfr2,1.);\n\n\tfloat r1mask = 1.-r1;\n\tfloat r2mask = 1.-r2;\n\n\t// Two waves, they are nothing more than the difference between two sine waves\n\tfloat wave1 = r1 * max(fill(0.05*sin((uv1.y+.5)*TAU+1.57)-uv1.x,0.),\n\t\t\t\t\t\t   fill(uv1.x-0.05*sin((uv1.y+.5)*TAU),0.));\n\t\n\tfloat wave2 = r1mask * r2 * max(fill(0.05*sin((uv2.y+.5)*TAU+1.57)-uv2.x,0.),\n\t\t\t\t\t\t\t\t\tfill(uv2.x-0.05*sin((uv2.y+.5)*TAU),0.));\n\t// The background\n\tvec3 bg = pal(.5-uv.y*.1);\n    // Three circles to make the center flower\n    float circle = length(uv-vec2(.0,.4));\n    bg =  mix(bg, pal(.0), smoothstep(0.4,.0,circle) );\n\tbg =  mix(bg, pal(.5), smoothstep(0.11,.0,circle) );\n\tbg =  mix(bg, pal(.9), smoothstep(0.02,.0,circle) );\n\t\n \t// Composing the rectangles and the waves to set up the foreground\n\tfloat d =  max(min(max(r1mask*r2,r1),wave1),wave2);\n\t\n    // Colorizing the foreground\n\tvec3 fg = mix(pal(.9-uv.y*2.),pal(.15+uv.y*.1),d);\n\t// Adding a black contour to the rectangles \n    fg = mix(fg,vec3(.0),max(r1mask*fill(abs(sdfr2),1.),fill(abs(sdfr1),1.)));\n\t// Adding a faux 3d to the interlace of the rectangles\n    fg = mix(fg,fg*.4,r2*smoothstep(.0,.01,sdfr1)-smoothstep(.0,.1,sdfr1));\n\t\n    // return foreground and background\n    return mix(fg,bg,min(r1mask,r2mask));\n}\n\n// from Shane -> https://www.shadertoy.com/view/llSyDh\n// I've removed the comments. Go to Shane shader to see them.\n// This provides the translation symmetry, remaps everything in the plane to\n// an hexagon centered at [0,0]\nvec2 lattice6(vec2 uv) {\n    const vec2 s = vec2(1, 1.7320508);\n\t\n    vec4 hC = floor(vec4(uv, uv - vec2(.5, 1))/s.xyxy) + .5;\n    vec4 h = vec4(uv - hC.xy*s, uv - (hC.zw + .5)*s);\n\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec2(h.xy) : vec2(h.zw);\n}\n\n// The scene is just symmetry operations\nvec3 scene(vec2 uv) {\n\t\n    // translation symmetry\n\tuv = lattice6(uv)*6.;\n\t\n    // a small alignement because the lattice is pointy hexagon side up\n    // and my pattern is flat topped.\n\tuv *= uvRotate(radians(30.));\n\n    // 6 fold rotations\n\tuv = symrot(uv,6.)-vec2(2.,.0); // 4\n    // 3 fold rotation\n\tuv = symrot(uv,3.)-vec2(1.,0.); // 3\n    // 3 fold rotation\n\tuv = symrot(uv,3.)-vec2(.5,.0); // 2\n\t\n    // reflection on the y axis with a flip on the x to do an interlace\n\tuv = vec2(sign(uv.y)*uv.x,abs(uv.y))-vec2(0.,.4+.05*cos(iTime+uv.x*6.28)); // 1\n    // if you want to see how the pattern is constructed\n    // comment all the lines 1 to 4, and then uncomment one by one 1,2,3,4\n\t\n    // draw the pattern\n\treturn pattern(uv);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = ( fragCoord.xy - iResolution.xy*.5)/ iResolution.y ;\n    fragColor = vec4( scene(uv), 1.0 );\n    // uncomment to see the original pattern    \n    //fragColor = vec4( pattern(uv*2.), 1.0 ); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlsfRX.jpg", "access": "shaders20k", "license": "cc-by-sa-3.0", "functions": [[586, 620, 643, 643, 686], [687, 721, 743, 743, 781], [782, 804, 828, 828, 873], [874, 920, 952, 952, 1007], [1008, 1042, 1072, 1072, 1112], [1114, 1174, 1193, 1193, 1243], [1245, 1375, 1406, 1406, 1498], [1500, 1607, 1630, 1678, 3225], [3227, 3453, 3477, 3477, 3706], [3708, 3749, 3770, 3800, 4487], [4490, 4490, 4547, 4547, 4753]], "test": "untested"}
{"id": "MlsfWj", "name": "Ellipses 1", "author": "johnsondavies", "description": "Overlapping animated ellipses", "tags": ["ellipses"], "likes": 0, "viewed": 59, "published": "Public", "date": "1513425138", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #define t iTime/100.0\n    vec4 solidBlack = vec4(0,0.0,0.0,1.0);\n    vec2 xy = fragCoord; //We obtain our coordinates for the current pixel\n    xy = xy / iResolution.xy - 0.5; //We divide the coordinates by the screen size\n    solidBlack.r = mod((xy.x * xy.x + xy.y * xy.y - xy.x * xy.y - t) * 50.0, 1.0);\n    solidBlack.g = mod((xy.x * xy.x + xy.y * xy.y + xy.x * xy.y - t) * 50.0, 1.0);\n    solidBlack.b = mod((xy.x * xy.x - xy.y * xy.y + xy.x * xy.y + t) * 50.0, 1.0);\n    fragColor = solidBlack;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlsfWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 563]], "test": "untested"}
{"id": "MlsfzB", "name": "nuclear throne tunnel", "author": "laserdog", "description": "tried to recreate the nuclear throne tunnel. inspired by a previous attempt at the same effect by antonOTI\n\ntarget effect: https://www.youtube.com/watch?v=p0Q_MoMsKlI", "tags": ["tunnel"], "likes": 5, "viewed": 310, "published": "Public", "date": "1512413746", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define tau 6.28318\n\nconst float MAX_DISTANCE = 100.;\n\nvec2 path(vec3 p)\n{\n    float speed = 2.25;\n\tp.x = sin(p.z*speed);\n\tp.y = cos(p.z*speed);\n\treturn p.xy;\n}\n\nfloat df(vec3 p, vec3 eye)\n{\n    float tunnelRadius = 2. - 2. * (p.z - eye.z) /(1.4);\n\tp.xy += path(p);\n\treturn tunnelRadius - length(p.xy);\n}\n\nvec3 dcol(vec3 p)\n{\n\tp.xy += path(p);\n\treturn mix(vec3(0.15,0.02,0.2),vec3(0.25,0.09,0.36),\n               step(fract(2. * (2. * p.z + atan(p.y, p.x) / tau)), .5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv.y *= -1.;\n    float pixel = 50.;\n    uv = floor(uv * pixel)/pixel;\n    \n\tfloat t = iTime * .35;\n\tvec3 eye = vec3(0, 0., t);\n\teye.xy -= path(eye);\n\t\n    vec3 dir = normalize(vec3(uv, .3));\n\t\n\tfloat dist = 0.1, tot = -0.2;\n\tvec3 p = eye + dir * tot;\n    vec3 col;\n    \n\tfor (int i=0; i < 70; i++)\n\t{\n\t\tif (dist < .001 || tot > MAX_DISTANCE) break;\n\t\tp = eye + dir * tot;\n\t\ttot += dist = df(p, eye) * 0.1;\n        col = dcol(p) *  (1.5 - (p.z - eye.z) / .8);\n\t}\n\t\n    fragColor.rgb = col ;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlsfzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 74, 74, 160], [162, 162, 190, 190, 304], [306, 306, 325, 325, 472], [474, 474, 531, 531, 1092]], "test": "untested"}
{"id": "MlSfzz", "name": "Starry sky", "author": "luluco250", "description": "Test to get blinking stars and a pseudo aurora", "tags": ["procedural", "2d", "random", "sky", "stars", "aurora"], "likes": 6, "viewed": 1257, "published": "Public API", "date": "1514290278", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 uv) {\n    const highp float a = 12.9898;\n    const highp float b = 78.233;\n    const highp float c = 43758.5453;\n    highp float dt = dot(uv, vec2(a, b));\n    highp float sn = mod(dt, 3.1415);\n    return fract(sin(sn) * c);\n}\n\nvoid draw_stars(inout vec4 color, vec2 uv) {\n    float t = sin(iTime * 2.0 * rand(-uv)) * 0.5 + 0.5;\n    //color += step(0.99, stars) * t;\n    color += smoothstep(0.975, 1.0, rand(uv)) * t;\n}\n\n#define nsin(x) (sin(x) * 0.5 + 0.5)\n\nvoid draw_auroras(inout vec4 color, vec2 uv) {\n    const vec4 aurora_color_a = vec4(0.0, 1.2, 0.5, 1.0);\n    const vec4 aurora_color_b = vec4(0.0, 0.4, 0.6, 1.0);\n    \n    float t = nsin(-iTime + uv.x * 100.0) * 0.075 + nsin(iTime + uv.x * distance(uv.x, 0.5) * 100.0) * 0.1 - 0.5;\n    t = 1.0 - smoothstep(uv.y - 4.0, uv.y * 2.0, t);\n    \n    vec4 final_color = mix(aurora_color_a, aurora_color_b, clamp(1.0 - uv.y * t, 0.0, 1.0));\n    final_color += final_color * final_color;\n    color += final_color * t * (t + 0.5) * 0.75;\n}\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1.0) / iResolution.xy;\n    vec2 uv = coord * ps;\n    color = vec4(0.0);\n    \n    draw_stars(color, uv);\n    draw_auroras(color, uv);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSfzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 241], [243, 243, 287, 287, 434], [474, 474, 520, 520, 1003], [1005, 1005, 1049, 1049, 1203]], "test": "untested"}
{"id": "MlXBDS", "name": "Noises", "author": "kalkas", "description": "Homework challenge, 2nd", "tags": ["noise", "random", "generator", "hash"], "likes": 3, "viewed": 108, "published": "Public", "date": "1513243054", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int GenerateRandomBitA(vec2 _coords){\n    \n    _coords *= iTime;\n    int seed = floatBitsToInt(_coords.x) + floatBitsToInt(_coords.y)*floatBitsToInt(iResolution.x);;\n    int shift = 29;\n    float c = intBitsToFloat(seed*seed>>shift)*intBitsToFloat(seed*seed>>shift);\n    \n    return floatBitsToInt(c) & 1;\n}\n\nint GenerateRandomBitB(vec2 _coords){\n    \n    int a = int(_coords.x);\n    int b = int(_coords.y);\n    a *= a;\n    b *= b;\n    int s = int(mod(float(((a+23)<<5)*19), iTime*37.0)*mod(float(((b+23)<<5)*11), iTime*37.0));\n    \n    return s & 1;\n}\n\nint GenerateRandomBitC(vec2 _coords){\n    \n    int a = int(_coords.x);\n    int b = int(_coords.y);\n    \n    a *= a;\n    b *= b;\n    int s = int(mod(float(((a+23)<<5)*19), iTime*37.0 + 137.0)*mod(float(((b+23)<<5)*11), iTime*37.0 + 137.0));\n    \n    return s & 1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tfragColor = vec4(GenerateRandomBitB(fragCoord));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlXBDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 307], [309, 309, 346, 346, 552], [554, 554, 591, 591, 818], [820, 820, 877, 877, 934]], "test": "untested"}
{"id": "MsXXzH", "name": "Ink droplets in Poiseuille Flow", "author": "maqflp", "description": "Simple flow with analytic solution.", "tags": ["physics", "fluidflow", "analyticalsolution"], "likes": 2, "viewed": 699, "published": "Public API", "date": "1512119346", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Ink droplets in Poiseuille Flow by maq/flp\n// (Poiseuille Flow)\n// See: http://www.thermopedia.com/content/1042/\n// http://panoramx.ift.uni.wroc.pl/~maq/eng/index.php\n\nfloat dist(vec2 r, vec2 c) {\treturn length(r-c);\t}\nfloat saw(float t, float a) {\treturn 0.5+1.0*(t/a-floor(0.5+t/a));  }\nfloat poiseuille(float r, float R) { return (0.25 - (r/R)*(r/R)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t    \n\tfloat d, tt, tt2;\n\tfloat RadiusI = 0.0125;\n\tfloat Radius = RadiusI;\n\tfloat c = 1.0;\n\tfloat s = 0.0;//0.05*sin(uv.x*2.5);\t\t// @todo\n\t\t\n   //c *= smoothstep(0.25,0., abs(uv.y+s -.5) -.25);\n\tc=smoothstep(0.25,0.256,uv.y+s);\n\tc*=(1.0-smoothstep(0.75,0.756,uv.y+s));\n\n\tfloat xx;\n\tfor(float kulka=0.0; kulka<1.0; kulka+=0.015)//05)\n\t{\n\t\ttt = texture( iChannel0, vec2(kulka,0.02) ).r;\t\n\t\ttt2 = texture( iChannel0, vec2(kulka,0.06) ).r;\t\n\t\t//Radius= RadiusI;\n\t\tRadius = 0.03+Radius * 3.0*abs(uv.y-0.5);\n\t\t//xx = ar * saw(tt+0.25*iTime* pow(poiseuille(uv.y-0.5,0.5),1.0) ,1.0);\n        xx = saw(tt+2.75*iTime*poiseuille((uv.y-0.5),0.5),1.0);\n\t\t\t\t\t\t\n\t\td=dist(uv, vec2(xx, 0.25+0.5*tt2));\n\t\t//if(d < Radius) // FN2\n\t\tc*=smoothstep(Radius*0.3,Radius,d);       \n        //c *= smoothstep(Radius,Radius*1.3, abs(uv.y+s -.5) -.25);\n\t}\t\t\n    \n\tfragColor = vec4(c);\t\t//vec3(c,c,c),1.0);  // FN2\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsXXzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 171, 199, 199, 221], [222, 222, 251, 251, 291], [292, 292, 328, 328, 359], [361, 361, 418, 418, 1346]], "test": "untested"}
{"id": "Mt2BRR", "name": "dancing bubbles", "author": "mds2", "description": "a remake of https://www.shadertoy.com/view/4tsBD2", "tags": ["raymarch", "sdf", "music"], "likes": 0, "viewed": 318, "published": "Public API", "date": "1514345955", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define BLOCKSIZE 0.75\n\n#define EXTENT 7.0\n\n#define MULTI_SAMPLE 3 // do not set higher than 8\n\n#define DROP_BLOCKS 0\n#define DROP_WAFFLE 1\n#define BUBBLES_DENSER_THAN_AIR 0\n\nvec3 camera = vec3(25.0, 0.0, 0.0);\nmat3 dir_mat = mat3(1.0, 0.0, 0.0,\n                    0.0, 1.0, 0.0,\n                    0.0, 0.0, 1.0);\n\nconst float error_bound = 1.0e-5;\n\nconst float blocks_max_height = -1.15; // -1.75 + 0.6 + 0.25 * BLOCKSIZE\nconst float waffle_max_height = -1.75; // -2.0 + 0.1 + 0.15\n\nvec3 sun_dir; // movable, set in main\nconst float sun_sin = 2.0 * 3.141592654 / 180.0; // approx 5 degrees\n\nconst float earth_rad = 60000.0; // off by a factor of 100\nconst float height_above_earth = 1000.0; // 1 km up\n\nfloat in_sun (in vec3 dir) {\n    float pixel_sin = (22.0 / 180.0) * (8.0 / 3.141592654) / iResolution.y;\n\n\tfloat dir_cos = abs(dot(dir, sun_dir));\n    float dir_sin =\n        length(dir - sun_dir * dir_cos);\n    return smoothstep(sun_sin + 2.0 * pixel_sin, sun_sin, dir_sin);\n}\n\nvec4 sky_shade(in vec3 dir) {\n    \n    vec3 base_blue =\n        vec3(0.1, 0.2, 0.6) + \n        0.5 * (1.2 + 0.8 * dot(dir, sun_dir)) * vec3(0.4, 0.5, 0.4);\n    \n    vec4 base =\n        vec4(mix(base_blue, vec3(1.0),\n                 0.5 * smoothstep(0.2, 1.0, dot(dir, sun_dir))), 1.0); \n    \n\treturn base + vec4(2.2 * in_sun(dir) * vec3(0.9, 1.0, 0.2), 1.0);\n}\n\nvec2 dist_to_sphere(in vec3 orig, in vec3 dir, in vec3 cent,\n                     in float rad) {\n    // p = orig + t * dir\n    // (p-cent)^2 = rad^2\n    // t *t * dot(dir, dir) + 2.0 * t * dot(dir, orig - cent) +\n    // dot(orig - cent, orig - cent) - rad * rad = 0\n    vec3 rel = orig - cent;\n    float A = dot(dir, dir);\n    float B = 2.0 * dot(dir, rel);\n    float C = dot(rel, rel) - rad * rad;\n    \n    float discr = B * B - 4.0 * A * C;\n    if (discr < 0.0) {\n        return vec2(-1.0);\n    }\n    \n    return (-B + vec2(-sign(A), sign(A)) * sqrt(discr)) / (2.0 * A);\n}\n\n\nfloat noise(in vec2 p) {\n    vec2 scaled_p = 0.05 * p;\n    float px_step = 1.0 / 64.0;\n    vec2 within = mod(scaled_p, vec2(px_step));\n    vec2 mod_by = vec2(1.0 - px_step);\n    vec2 corner_00 = mod(scaled_p - within, mod_by);\n    vec2 corner_10 = mod(corner_00 + vec2(px_step, 0.0), mod_by);\n    vec2 corner_01 = mod(corner_00 + vec2(0.0, px_step), mod_by);\n    vec2 corner_11 = mod(corner_00 + vec2(px_step, px_step), mod_by);\n    \n    float val_00 = texture(iChannel1, corner_00).r;\n    float val_10 = texture(iChannel1, corner_10).r;\n    float val_01 = texture(iChannel1, corner_01).r;\n    float val_11 = texture(iChannel1, corner_11).r;\n    \n    float val_0 = val_00 +\n        (val_01 - val_00) * smoothstep(0.0, px_step, within.y);\n    \n    float val_1 = val_10 +\n        (val_11 - val_10) * smoothstep(0.0, px_step, within.y);\n    \n    return val_0 +\n        (val_1 - val_0) * smoothstep(0.0, px_step, within.x);\n    \n}\n\nfloat noise_sum(vec2 uv) {\n    vec2 d = 1.0 * vec2(0.3, 0.4) * iTime;\n\treturn noise(uv + d) + 0.5 * noise(d + 3.0 * uv) +\n        0.25 * noise(d + 9.01 * uv)  + 0.125 * noise(d + 27.01 * uv) +\n        0.0625 * noise(d + 81.01 * uv) + 0.03125 * noise(d + 243.01 * uv);\n\n}\n\nvec2 noise_grad(vec2 uv) {\n\tfloat x = noise_sum(uv);\n    float h = 0.01;\n    float one_over_h = 100.0;\n    return one_over_h *\n        vec2(noise_sum(uv + vec2(h, 0.0)) - x,\n             noise_sum(uv + vec2(0.0, h)) - x);\n}\n\nvec3 sea_bounce(in vec3 orig, in vec3 dir, out vec4 color_mul) {\n\n    vec3 earth_cen = vec3(0.0, - height_above_earth - earth_rad, 0.0);\n    vec2 dists = dist_to_sphere(orig, dir, earth_cen,\n                             earth_rad);\n    float t = dists.x;\n    if (t < 0.0) {\n    \tcolor_mul = vec4(1.0);\n        return dir;\n    }\n    vec3 p = orig + t * dir;\n    vec3 n = normalize(p - earth_cen);\n    vec2 uv = p.xz / height_above_earth; // renorm or something\n    n = normalize(n + vec3(0.5 * noise_grad(uv), 0.0).xzy);\n    \n    float edgeness = 1.0 -\n        clamp(3.0 * (dists.y - dists.x) / earth_rad, 0.0, 1.0);\n\n    color_mul = mix(vec4(0.25, 0.4, 0.6, 1.0), vec4(1.0), edgeness);\n    return normalize(reflect(dir, n));\n}\n                                         \n\nvec4 shade(in vec3 orig, in vec3 dir) {\n    vec4 color_mul = vec4(1.0);\n    dir = sea_bounce(orig, dir, color_mul);\n    return color_mul * sky_shade(dir);\n}\n\nfloat waffle_sdf(in highp vec3 point) {\n#if DROP_WAFFLE\n    return 5.0 * EXTENT;\n#else\n    vec3 local = vec3(abs(abs(mod(point.xz, BLOCKSIZE)) - vec2(0.5 * BLOCKSIZE)), point.y).xzy;\n    vec2 lr_dists = 0.5 * BLOCKSIZE - local.xz;\n    float lr_dist = min(lr_dists.x, lr_dists.y);\n    float updist = abs(local.y + 2.0);\n    return length(vec3(lr_dist, max(updist, 0.0), \n                       max(length(point - camera) - EXTENT, 0.0))) - 0.05;\n#endif\n}\n\nfloat blocks_sdf(in highp vec3 point) {\n#if DROP_BLOCKS\n    return 5.0 * EXTENT;\n#else\n\tvec3 local = vec3(abs(abs(mod(point.xz, BLOCKSIZE)) - vec2(0.5 * BLOCKSIZE)),\n                      abs(point.y + 1.75)).xzy;\n    float samp_loc = mod(dot(point.xz - mod(point.xz, BLOCKSIZE),\n                             vec2(0.17, 0.13)), BLOCKSIZE);\n    float samp = texture(iChannel0, vec2(samp_loc, 0.0)).r;\n\tvec3 to_core = max(vec3(0.0), local - vec3(0.05, 0.1 + 0.5 * samp, 0.05));\n    return max(length(to_core), \n                       max(length(point - camera) - EXTENT, 0.0)) - 0.125 * (1.0 + samp) * BLOCKSIZE;\n#endif\n}\n\nfloat grid_sdf(in highp vec3 point) {\n    return min(waffle_sdf(point), blocks_sdf(point));\n}\n\nvec3 waffle_grad(in highp vec3 point) {\n    float p = waffle_sdf(point);\n    return normalize(vec3(waffle_sdf(point + vec3(0.01, 0.0, 0.0)) - p,\n                          waffle_sdf(point + vec3(0.0, 0.01, 0.0)) - p,\n                          waffle_sdf(point + vec3(0.0, 0.0, 0.01)) - p));\n}\n\n\nvec3 blocks_grad(in highp vec3 point) {\n    float p = blocks_sdf(point);\n    return normalize(vec3(blocks_sdf(point + vec3(0.01, 0.0, 0.0)) - p,\n                          blocks_sdf(point + vec3(0.0, 0.01, 0.0)) - p,\n                          blocks_sdf(point + vec3(0.0, 0.0, 0.01)) - p));\n}\n\n\nfloat dist_to_grid(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    if (dir.y < -error_bound) {\n\t    float to_max = (point.y - waffle_max_height) / dir.y;\n    \tresult = to_max;\n    } else if (point.y > waffle_max_height + EXTENT * error_bound) {\n        return 2.0 * EXTENT;\n    }\n    p = p + result * dir;\n    for (int i = 0; i < 128; ++i) {\n    \tfloat d = 0.9 * waffle_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound || result > 2.0 * EXTENT) {\n            return result;\n        }\n    }\n    return result;\n}\n\nfloat dist_to_blocks(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    if (dir.y < -error_bound) {\n        float to_max = (point.y - blocks_max_height) / dir.y;\n        result = to_max;\n    } else {\n        return 2.0 * EXTENT;\n    }\n    p = p + result * dir;\n    for (int i = 0; i < 96; ++i) {\n    \tfloat d = 0.8 * blocks_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound || result > 2.0 * EXTENT) {\n            return result;\n        }\n    }\n    return result;\n}\n\nfloat dist_out_of_blocks(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    for (int i = 0; i < 64; ++i) {\n    \tfloat d = -0.9 * blocks_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound) {\n            return result;\n        }\n    }\n    return result;\n}\n\nconst vec3 light1 = vec3(0.36, 0.48, -0.8);\n\nconst vec3 light2 = vec3(-0.48, 0.64, -0.6);\n\nvec4 getSample(in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    vec4 color_mul = vec4(1.0);\n\n    vec3 ray_orig = camera; // vec3(0.0, 0.0, -1.0); // sin(iTime));\n    vec3 ray_dir = normalize(vec3(uv - vec2(0.0, 0.1), -0.4));\n    float c_pitch = 0.9;\n    float s_pitch = 0.4358898943540673;\n    ray_dir = dir_mat *\n        mat3(1.0, 0.0, 0.0,\n        \t 0.0, c_pitch, -s_pitch,\n             0.0, s_pitch, c_pitch) * ray_dir;\n    float d1 = dist_to_grid(ray_orig, ray_dir);\n    float d2 = dist_to_blocks(ray_orig, ray_dir);\n    vec3 n = ray_dir;\n#if BUBBLES_DENSER_THAN_AIR\n    const float eta = 0.85; // 1.1; // 1.5;\n#else\n    const float eta = 1.1;\n#endif\n    if (d2 < d1 && d2 < 1.5 * EXTENT) {\n        ray_orig = ray_orig + ray_dir * (d2 + 0.01);\n    \tn = blocks_grad(ray_orig);\n        vec3 next_ray_dir = refract(ray_dir, n, eta);\n        float l = length(next_ray_dir);\n\n        if (l > 0.1) {\n            ray_dir = next_ray_dir / l;\n        \td2 = dist_out_of_blocks(ray_orig, ray_dir);\n        \tcolor_mul *= mix(vec4(0.9, 1.2, 0.5, 1.0), vec4(2.0),\n                         exp(-5.0 * max(d2, 0.0)));\n        \tray_orig = ray_orig + d2 * ray_dir;\n       \t\tn = blocks_grad(ray_orig);\n        \tnext_ray_dir = refract(ray_dir, -n, 1.0/eta);\n            l = length(next_ray_dir);\n            if (l > 0.1) {\n                ray_dir = next_ray_dir / l;\n            }\n        } else {\n            ray_dir = normalize(reflect(ray_dir, n));\n        }\n        d1 = dist_to_grid(ray_orig, ray_dir);\n        \n    }\n    vec3 bounce = ray_dir;\n    if ( d1 < 1.5 * EXTENT) {\n        vec3 p = ray_orig + ray_dir * d1;\n        ray_orig = p;\n        n = waffle_grad(p);\n        bounce = normalize(reflect(ray_dir, n));\n        color_mul *= vec4(vec3(0.5), 1.0);\n    }\n    \n    return color_mul * shade(ray_orig, bounce);\n }\n\n\nvec2 offsets[8] = vec2[8](vec2(-0.4, -0.4), \n                         vec2(-0.45, 0.1),\n                         vec2(-0.4, 0.4),\n                         vec2(0.1, 0.45),\n                         vec2(0.4, 0.4),\n                         vec2(0.45, -0.1),\n                         vec2(0.4, -0.4),\n                         vec2(0.0, 0.0));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 result = vec4(0.0);\n    \n    float c_theta = cos(0.05 * iTime);\n    float s_theta = sin(0.05 * iTime);\n\n    camera = mat3(c_theta, 0.0, s_theta,\n                  0.0, 1.0, 0.0,\n                  -s_theta, 0.0, c_theta) * camera;\n    \n    dir_mat = mat3(-c_theta, 0.0, -s_theta,\n                   0.0, 1.0, 0.0,\n                   s_theta, 0.0, -c_theta);\n    \n\tsun_dir = dir_mat * vec3(0.6, 0.0, -0.8);\n    \n    float nsamps = 0.0;\n    \n    for (int i = 0; i < 8; i += max(8 / MULTI_SAMPLE, 1)) {\n        result += getSample(fragCoord + offsets[i]);\n    \tnsamps += 1.0;\n    }\n    \n    fragColor = result / nsamps;\n}\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "ldBXRD", "previewfilepath": "https://soundcloud.com/vantagenoise/aloha-ft-phaun", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/vantagenoise/aloha-ft-phaun", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2BRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[629, 708, 736, 736, 985], [987, 987, 1016, 1016, 1348], [1350, 1350, 1447, 1616, 1925], [1928, 1928, 1952, 1952, 2854], [2856, 2856, 2882, 2882, 3126], [3128, 3128, 3154, 3154, 3351], [3353, 3353, 3417, 3417, 4079], [4123, 4123, 4162, 4162, 4279], [4281, 4281, 4320, 4320, 4734], [4736, 4736, 4775, 4775, 5355], [5357, 5357, 5394, 5394, 5450], [5452, 5452, 5491, 5491, 5744], [5747, 5747, 5786, 5786, 6039], [6042, 6042, 6102, 6102, 6626], [6628, 6628, 6690, 6690, 7163], [7165, 7165, 7231, 7231, 7487], [7580, 7580, 7616, 7616, 9453], [9797, 9797, 9854, 9854, 10481]], "test": "untested"}
{"id": "Mt2fzR", "name": "Apollonian_", "author": "EvilRyu", "description": "a little orbit trap for apollonian gasket", "tags": ["fractal", "apollonian", "circleinversion"], "likes": 8, "viewed": 636, "published": "Public API", "date": "1514383266", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by evilryu - evilryu/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\nvec2 rot(vec2 p, float r)\n{\n    vec2 q;\n    q.x = p.x * cos(r) - p.y * sin(r);\n    q.y = p.x * sin(r) + p.y * cos(r);\n    return q;\n}\n\nvec3 apollonian(vec2 p)\n{\n    p = rot(p, iTime*0.1);\n\n    float scale = 1.0;\n    float t0 = 1e20, t1 = 1e20;\n    for(int i = 0; i < 4; ++i)\n    {\n        p = -1.0 + 2.0*fract(p*0.5+0.5);\n        float k=(1.34)/dot(p,p);\n        p*=k;\n        \n        t0 = min(t0, dot(p,p));\n        t1 = min(t1, max(abs(p.x), abs(p.y)));\n        scale*=k;\n\n    }\n    float d=0.25*abs(p.y)/scale;\n    d=smoothstep(0.001, 0.002,d);\n    \n    float c0=pow(clamp(t0, 0.0, 1.0), 1.5); \n    float c1=pow(clamp(t1, 0.0, 1.0), 2.);\n    vec3 col0=0.5+0.5*sin(1.0+3.4*c0+vec3(2.,1.3, 0.)); \n\tvec3 col1=0.5+0.5*sin(3.7*c1+vec3(2.,1.5, 0.)); \n\n    vec3 col = sqrt(d*col1*col0)*3.;\n    \n    return col;\n}\n\n\nvec2 getsubpixel(int id,vec2 fragCoord)\n{\n\tvec2 aa=vec2(floor((float(id)+0.1)*0.5),mod(float(id),2.0));\n\treturn vec2((2.0*fragCoord.xy+aa-iResolution.xy)/iResolution.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q * 2.0 - 1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    for(int i=0;i<4;++i)\n    {\n        vec2 p = getsubpixel(i,fragCoord);\n        p*=exp(sin(iTime*0.2)*0.2);\n        col += apollonian(p);\n    }\n    col/=4.0;\n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n   \tcol*=0.5+.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);  // vigneting\n\tfragColor.xyz = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2fzR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 128, 155, 155, 261], [263, 263, 288, 288, 937], [940, 940, 981, 981, 1111], [1113, 1113, 1170, 1170, 1624]], "test": "untested"}
{"id": "MtBBRR", "name": "Sailing", "author": "dr2", "description": "Barque sailing through fine and foul weather", "tags": ["waves", "sea", "fog", "lightning", "ship"], "likes": 15, "viewed": 657, "published": "Public API", "date": "1514200951", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Sailing\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEECapsDf (vec3 p, vec3 v1, vec3 v2, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nvec3 RgbToHsv (vec3 c);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, shipConf, bDeck, qHit, cloudDisp, fogDisp;\nfloat tCur, dstFar, tWav, szFac, cloudDens, fogDens;\nint idObj;\nconst int idHull = 1, idRud = 2, idStruc = 3, idMast = 4, idSparT = 5, idSparL = 6, idSailT = 7,\n   idSailA = 8, idSailF = 9, idFlag = 10, idRig = 11;\nconst float pi = 3.14159;\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  vec4 t4, v4;\n  vec2 q, t, tw;\n  float wFreq, wAmp, h;\n  q = 0.25 * p + vec2 (0., tCur);\n  h = 0.2 * sin (q.y) + 0.15 * sin (dot (q, vec2 (0.1, 1.2))) +\n     0.1 * sin (dot (q, vec2 (-0.2, 1.4)));\n  h *= 1.5 * (1. - smoothstep (0.8 * dstFar, dstFar, length (p)));\n  q = p;\n  wFreq = 0.5;\n  wAmp = 0.07;\n  tw = tWav * vec2 (1., -1.);\n  for (int j = 0; j < 4; j ++) {\n    q *= qRot;\n    t4 = q.xyxy * wFreq + tw.xxyy;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    v4 = (1. - abs (sin (t4))) * (abs (sin (t4)) + abs (cos (t4)));\n    t = 1. - sqrt (v4.xz * v4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return h;\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 50; j ++) {\n    p = ro + s * rd;\n    h = p.y - WaveHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (6., h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 6; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - WaveHt (p.xz));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e;\n  e = vec2 (max (0.1, 5e-5 * d * d), 0.);\n  return normalize (vec3 (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy), WaveHt (p.xz + e.yx)), e.x).xzy);\n}\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq, w;\n  float dMin, d, fy, fz, gz, s, rRig, rSpar, yLim, zLim;\n  rRig = 0.02;\n  rSpar = 0.05;\n  p.yz = Rot2D (p.yz, -0.4 * shipConf.z);\n  p.xy = Rot2D (p.xy, 6. * shipConf.y);\n  p.y -= shipConf.x + 4.1 * szFac;\n  p /= szFac;\n  dMin = dstFar / szFac;\n  fy = 1. - 0.07 * p.y;\n  fz = 1. - 0.14 * step (1., abs (p.z));\n  zLim = abs (p.z) - 4.5;\n  q = p;\n  d = zLim;\n  q.z = mod (q.z + 1.4, 2.8) - 1.2;\n  d = max (d, PrCapsDf ((q - vec3 (0., 3.7 * (fz - 1.), 0.)).xzy, 0.1 * fy, 3.7 * fz));\n  DMINQ (idMast);\n  q = p;\n  yLim = abs (q.y - 0.2 * fz) - 3. * fz;\n  qq = q;\n  qq.y = mod (qq.y - 3.3 * (fz - 1.), 2. * fz) - fz;\n  qq.z = mod (qq.z + 1.4, 2.8) - 1.4 + 0.1 * fz;\n  d = max (max (min (d, PrCylDf (vec3 (qq - vec3 (0., 0.05 * fy * fz, 0.1 * fz - 0.23)).xzy,\n     0.15 * fy, 0.11 * fy * fz)), yLim), zLim);\n  DMINQ (idMast);\n  d = max (max (PrCapsDf (qq.yzx, 0.05, 1.23 * fy * fz), yLim), zLim);\n  DMINQ (idSparT);\n  q = p;\n  d = min (d, min (PrEECapsDf (q, vec3 (0., -3.5, 4.3), vec3 (0., -2.6, 6.7), rSpar),\n     PrEECapsDf (q, vec3 (0., -4., 4.1), vec3 (0., -2.9, 6.), rSpar)));\n  d = min (d, min (PrEECapsDf (q, vec3 (0., -1.2, -3.), vec3 (0., -0.5, -4.5), rSpar),\n     PrEECapsDf (q, vec3 (0., -2.7, -3.), vec3 (0., -2.7, -4.5), rSpar)));\n  DMINQ (idSparL);\n  q = p;\n  qq = q;\n  qq.y = mod (qq.y - 3.1 * (fz - 1.), 2. * fz) - fz;\n  qq.z = mod (qq.z + 1.4, 2.8) - 1.4 + 0.2 * (fz - abs (qq.y)) * (fz - abs (qq.y)) - 0.1 * fz;\n  d = max (max (max (PrBoxDf (qq, vec3 ((1.2 - 0.07 * q.y) * fz, fz, 0.01)),\n     min (qq.y, 1.5 * fy * fz - length (vec2 (qq.x, qq.y + 0.9 * fy * fz)))),\n     abs (q.y - 3. * (fz - 1.)) - 2.95 * fz), - PrBox2Df (qq.yz, vec2 (0.01 * fz)));\n  d = max (d, zLim);\n  DMINQ (idSailT);\n  q = p;\n  q.z -= -3.8;  q.y -= -1.75 - 0.2 * q.z;\n  d = PrBoxDf (q, vec3 (0.01, 0.9 - 0.2 * q.z, 0.6));\n  DMINQ (idSailA);\n  q = p;\n  q.yz -= vec2 (-1., 4.5);\n  w = vec3 (1., q.yz);\n  d = max (max (max (abs (q.x) - 0.01, - dot (w, vec3 (2.3, 1., -0.35))),\n     - dot (w, vec3 (0.68, -0.74, -1.))), - dot (w, vec3 (0.41, 0.4, 1.)));\n  DMINQ (idSailF);\n  q = p;\n  d = zLim;  \n  gz = (q.z - 0.5) / 5. + 0.3;\n  gz *= gz;\n  gz = 1.05 * (1. - 0.45 * gz * gz);\n  q.x = abs (q.x);\n  q.z = mod (q.z + 1.4, 2.8) - 1.4;\n  d = max (d, min (PrEECapsDf (q, vec3 (1.05 * gz, -3.25, -0.5), vec3 (1.4 * fz, -2.95, -0.05), 0.7 * rRig),\n     PrEECapsDf (vec3 (q.xy, abs (q.z + 0.2) - 0.01 * (0.3 - 2. * q.y)), vec3 (gz, -3.2, 0.),\n     vec3 (0.05, -0.9 + 2. * (fz - 1.), 0.), rRig)));\n  q = p;\n  d = min (d, PrEECapsDf (q, vec3 (0., -3., -4.45), vec3 (0., -2.7, -4.5), 0.8 * rRig));\n  d = min (min (d, min (PrEECapsDf (q, vec3 (0., 2.45, 2.65), vec3 (0., -2.7, 6.5), rRig),\n     PrEECapsDf (q, vec3 (0., 2.5, 2.65), vec3 (0., -3.2, 4.9), rRig))),\n     PrEECapsDf (q, vec3 (0., 2.6, -3.), vec3 (0., -0.5, -4.5), rRig));\n  q.x = abs (q.x);\n  d = min (d, PrEECapsDf (q, vec3 (0.65, -3.5, 3.5), vec3 (0.05, -2.7, 6.4), rRig));\n  s = step (1.8, q.y) - step (q.y, -0.2);\n  d = min (min (d, min (PrEECapsDf (q, vec3 (0.95, 0.4, 2.7) + vec3 (-0.1, 1.7, 0.) * s,\n     vec3 (0.05, 1.1, -0.15) + vec3 (0., 2., 0.) * s, rRig),\n     PrEECapsDf (q, vec3 (1.05, 1., -0.1) + vec3 (-0.1, 2., 0.) * s,\n     vec3 (0.05, 0.5, -2.95) + vec3 (0., 1.7, 0.) * s, rRig))),\n     PrEECapsDf (q, vec3 (0.95, 0.4, -2.9) + vec3 (-0.1, 1.7, 0.) * s,\n     vec3 (0.05, 0.9, -0.25) + vec3 (0., 2., 0.) * s, rRig));\n  DMINQ (idRig);\n  q = p;\n  q.yz -= vec2 (3.4, 0.18);\n  d = PrBoxDf (q, vec3 (0.01, 0.2, 0.3));\n  DMINQ (idFlag);\n  q = p;\n  d = zLim;\n  q.z = mod (q.z + 1.4, 2.8) - 1.4;\n  q.yz -= vec2 (-3.4, -0.4);\n  d = max (d, PrBoxDf (q, vec3 (0.3, 0.1, 0.5)));\n  DMINQ (idStruc);\n  q = p;\n  q.x = abs (q.x);\n  q.yz -= vec2 (-3.8, 0.5);\n  fz = q.z / 5. + 0.3;\n  fz *= fz;\n  fy = 1. - smoothstep (-1.3, -0.1, q.y);\n  gz = smoothstep (2., 5., q.z);\n  bDeck = vec3 ((1. - 0.45 * fz * fz) * (1.1 - 0.5 * fy * fy) *\n     (1. - 0.5 * smoothstep (-5., -2., q.y) * smoothstep (2., 5., q.z)),\n     0.78 - 0.8 * gz * gz - 0.2 * (1. - smoothstep (-5.2, -4., q.z)), 5. * (1. + 0. * 0.02 * q.y));\n  d = min (PrBoxDf (vec3 (q.x, q.y + bDeck.y - 0.6, q.z), bDeck),\n     max (PrBoxDf (q - vec3 (0., 0.72, -4.6), vec3 (bDeck.x, 0.12, 0.4)),\n     - PrBox2Df (vec2 (abs (q.x) - 0.4, q.y - 0.65), vec2 (0.2, 0.08))));\n  d = max (d, - PrBoxDf (vec3 (q.x, q.y - 0.58 - 0.1 * fz, q.z), vec3 (bDeck.x - 0.07, 0.3, bDeck.z - 0.1)));\n  q = p;\n  d = max (d, - max (PrBox2Df (vec2 (q.y + 3.35, mod (q.z + 0.25, 0.5) - 0.25), vec2 (0.08, 0.1)),\n     abs (q.z + 0.5) - 3.75));\n  DMINQ (idHull);\n  q = p;\n  d = PrBoxDf (q + vec3 (0., 4.4, 4.05), vec3 (0.03, 0.35, 0.5));\n  DMINQ (idRud);\n  return 0.7 * dMin * szFac;\n}\n\nvoid EvalShipConf ()\n{\n  vec4 h;\n  vec2 e;\n  e = vec2 (2. * szFac, 0.);\n  h = vec4 (WaveHt (- e), WaveHt (e), WaveHt (- e.yx), WaveHt (e.yx));\n  shipConf = vec3 (0.25 * dot (h, vec4 (1.)), vec2 (h.xz - h.yw) / (2. * e.x));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 80; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0005, -0.0005);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvoid ShipCol (out vec4 col4, out vec2 vf)\n{\n  vec2 cg;\n  vf = vec2 (0.);\n  if (idObj == idHull) {\n    if (abs (qHit.x) < bDeck.x - 0.08 && qHit.y > -3.6 && qHit.z > - bDeck.z + 0.62) {\n      col4 = vec4 (0.5, 0.3, 0., 0.1) * (0.5 + 0.5 * SmoothBump (0.05, 0.95, 0.02, mod (8. * qHit.x, 1.)));\n    } else if (qHit.y > -4.) {\n      col4 = vec4 (0.7, 0.5, 0.1, 0.1);\n      if (abs (qHit.z - 4.) < 0.25 && abs (qHit.y + 3.55) < 0.05) col4 *= 1.2;\n      else if (qHit.z < -4. && abs (qHit.x) < 0.84 && abs (qHit.y + 3.62) < 0.125) {\n        cg = step (0.1, abs (fract (vec2 (6. * qHit.x, 8. * (qHit.y + 3.62)) + 0.5) - 0.5));\n        if (cg.x * cg.y == 1.) col4 = vec4 (0.8, 0.8, 0.2, -1.);\n        else col4 *= 0.8;\n      } else {\n        col4 *= 0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.02, mod (8. * qHit.y, 1.));\n        vf = vec2 (64., 0.3);\n      } \n    } else if (qHit.y > -4.05) {\n      col4 = vec4 (0.8, 0.8, 0.8, 0.1);\n    } else {\n      col4 = vec4 (0.3, 0.2, 0.1, 0.);\n      vf = vec2 (64., 2.);\n    }\n  } else if (idObj == idRud) {\n    col4 = vec4 (0.5, 0.3, 0., 0.);\n  } else if (idObj == idStruc) {\n    col4 = vec4 (0.4, 0.3, 0.1, 0.1);\n    if (max (abs (qHit.x), abs (qHit.z + 0.22)) < 0.2) {\n      cg = step (0.1, abs (fract (vec2 (10. * vec2 (qHit.x, qHit.z + 0.22)) + 0.5) - 0.5));\n      if (cg.x * cg.y == 1.) col4 = vec4 (0.8, 0.8, 0.2, -1.);\n    }\n  } else if (idObj == idSailT) {\n    qHit.x *= (1. + 0.07 * qHit.y) * (1. + 0.14 * step (1., abs (qHit.z)));\n    col4 = vec4 (1., 1., 1., 0.) * (0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.02, mod (4. * qHit.x, 1.)));\n    if (abs (qHit.z) < 0.2 && abs (abs (length (qHit.xy - vec2 (0., 0.3)) - 0.35) - 0.15) < 0.07)\n       col4 *= vec4 (1., 0.2, 0.2, 1.);\n  } else if (idObj == idSailA) {\n    col4 = vec4 (1., 1., 1., 0.) * (0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.02, mod (5. * qHit.z, 1.)));\n  } else if (idObj == idSailF) {\n    col4 = vec4 (1., 1., 1., 0.) * (0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.02,\n       mod (2.95 * qHit.y + 4. * qHit.z - 0.5, 1.)));\n  } else if (idObj == idFlag) {\n    col4 = vec4 (1., 1., 0.5, 0.1);\n    if (abs (abs (length (qHit.yz) - 0.1) - 0.04) < 0.02) col4 *= vec4 (1., 0.2, 0.2, 1.);\n  } else if (idObj == idMast) {\n    col4 = vec4 (0.7, 0.4, 0., 0.1);\n    if (length (qHit.xz) < 0.16 * (1. - 0.07 * qHit.y)) col4 *= 0.6 + 0.4 *\n       SmoothBump (0.03, 0.97, 0.01, mod (2. * qHit.y / (1. + 0.14 * step (1., abs (qHit.z))), 1.));\n    if (qHit.y > 3.65) col4 = vec4 (1., 0., 0., -1.);\n  } else if (idObj == idSparT) {\n    qHit.x *= (1. + 0.07 * qHit.y) * (1. + 0.14 * step (1., abs (qHit.z)));\n    col4 = vec4 (0.7, 0.4, 0., 0.1) *  (0.6 + 0.4 * SmoothBump (0.08, 0.92, 0.01, mod (4. * qHit.x, 1.)));\n  } else if (idObj == idSparL) {\n    col4 = vec4 (0.7, 0.4, 0., 0.1);\n    if (qHit.z > 6.65) col4 = vec4 (1., 1., 0.3, -1.);\n  } else if (idObj == idRig) {\n    col4 = vec4 (0.2, 0.15, 0.1, 0.);\n    vf = vec2 (32., 0.5);\n  }\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return mix (vec3 (0.45, 0.45, 0.6), vec3 (0.2, 0.2, 0.9), rd.y);\n}\n\nvec3 SkyHrzCol (vec3 ro, vec3 rd)\n{\n  vec3 p, q, dp, col;\n  vec2 cSum;\n  float cloudLo, cloudRngI, att, a, sd;\n  const float nLay = 30.;\n  cloudLo = 300.;  \n  cloudRngI = 1./200.;  \n  a = atan (rd.z, rd.x) / pi;\n  if (rd.y < 0.02 * Fbm1 (64. * a + 1.) + 0.005) col = mix (vec3 (0.12, 0.14, 0.12),\n     vec3 (0.2, 0.2, 0.23), 0.5 + 0.5 * dot (normalize (rd.xz), - normalize (sunDir.xz))) *\n     (1. - 0.2 * Fbm2 (64. * vec2 (a, rd.y)));\n  else {\n    sd = max (dot (rd, sunDir), 0.);\n    ro += cloudDisp;\n    p = ro;\n    p.xz += (cloudLo - p.y) * rd.xz / rd.y;\n    p.y = cloudLo;\n    dp = rd / (cloudRngI * rd.y * (2. - rd.y) * float (nLay));\n    cSum = vec2 (0.);  \n    att = 0.;\n    for (float s = 0.; s < nLay; s ++) {\n      q = p + s * dp;\n      att += 0.04 * max (cloudDens - Fbm3 (0.0035 * q), 0.);\n      cSum += att * (1. - cSum.y) * vec2 ((q.y - cloudLo) * cloudRngI, 1.);\n      if (cSum.y > 1.) break;\n    }\n    cSum.x += 0.5 * min ((1. - cSum.y) * pow (sd, 3.), 1.) + 0.05;\n    col = clamp (mix (SkyBg (rd) + vec3 (1., 1., 0.9) * (pow (sd, 8.) + pow (sd, 1024.)),\n       vec3 (1.) * 2.8 * cSum.x, cSum.y), 0., 1.);\n    col = mix (col, SkyBg (rd), pow (1. - rd.y, 32.));\n  }\n  return col;\n}\n\nvec3 FogCol (vec3 col, vec3 ro, vec3 rd, float dLim)\n{\n  float d, fFac, f, fn;\n  fFac = 1.;\n  ro += fogDisp;\n  d = 1.;\n  fn = fogDens * Fbm3 (0.5 * (ro + d * rd));\n  for (int j = 0; j < 8; j ++) {\n    d += 0.5 + 0.5 * d;\n    f = fn;\n    fn = fogDens * Fbm3 (0.5 * (ro + d * rd));\n    col = mix (col, vec3 (0.8, 0.8, 0.75) * (1. - clamp (f - fn, 0., 1.)),\n       clamp (fFac * f * smoothstep (0.9 * d, 2.3 * d, dLim), 0., 1.));\n    fFac *= 1.25;\n    if (d > dLim) break;\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roo, rdo, row, vnw;\n  vec2 vf;\n  float dstObj, dstWat, dstFog, s, tCyc;\n  bool watRefl, doLtn;\n  tWav = 0.5 * tCur;\n  tCyc = mod (0.02 * tCur, 1.);\n  cloudDens = 0.4 + 0.4 * SmoothBump (0.2, 0.8, 0.15, tCyc);\n  cloudDisp = tCur * vec3 (-15., 0., 5.);\n  fogDisp = tCur * vec3 (0.2, 0., 0.2);\n  fogDens = 0.25 * SmoothBump (0.35, 0.65, 0.15, tCyc);\n  doLtn = (abs (tCyc - 0.65) < 0.1);\n  watRefl = false;\n  col4 = vec4 (0.);\n  if (rd.y < 0.) dstWat = WaveRay (ro, rd);\n  else dstWat = dstFar;\n  szFac = 1.;\n  EvalShipConf ();\n  dstObj = ObjRay (ro, rd);\n  roo = ro;\n  rdo = rd;\n  dstFog = min (min (dstObj, dstWat), dstFar);\n  col = vec3 (0.);\n  if (dstWat < min (dstObj, dstFar)) {\n    ro += dstWat * rd;\n    row = ro;\n    vnw = VaryNf (row, WaveNf (row, dstWat), 0.1);\n    rd = reflect (rd, vnw);\n    dstObj = ObjRay (ro, rd);\n    watRefl = true;\n  }\n  col = vec3 (0.22, 0.25, 0.33);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    ShipCol (col4, vf);\n    if (vf.x > 0.) vn = VaryNf (vf.x * qHit, vn, vf.y);\n    if (col4.a >= 0.) col = col4.rgb * (0.2 + 0.2 * max (vn.y + 0.1, 0.) + \n       0.2 * max (dot (vec3 (- sunDir.x, 0., - sunDir.z), vn), 0.) +\n       0.6 * max (dot (vn, sunDir), 0.)) +\n       col4.a * pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);\n    else col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));\n  } else if (dstWat < dstFar) {\n    s = WaveHt (row.xz);\n    col *= mix (1. + 0.1 * s, 1.5, step (0.75, s + 0.4 * (Fbm2 (128. * row.xz) - 0.5)));\n    vnw = VaryNf (4. * row, WaveNf (row, dstWat), 0.2);\n  } else if (rdo.y < 0.) {\n    row = roo - (roo.y / rdo.y) * rdo + vec3 (0.1 * tCur, 0., 0.);\n    vnw = VaryNf (4. * row, vec3 (0., 1., 0.), 0.2);\n    watRefl = true;\n  } else {\n    col = SkyHrzCol (roo, rdo);\n  }\n  if (watRefl) col = mix (0.8 * col, 0.25 * vec3 (1., 1., 0.8) * SkyHrzCol (row, reflect (rdo, vnw)),\n     smoothstep (0.5, 1., 1. + rdo.y));\n  if (fogDens > 0. && (col4.a >= 0. || watRefl)) col = FogCol (col, roo, rdo, dstFog);\n  if (doLtn && col4.a >= 0.) {\n    s = SmoothBump (0.6, 0.8, 0.05, Fbm1 (8. * tCur));\n    col = HsvToRgb (RgbToHsv (col) * vec3 (1., 1. - 0.6 * s, (watRefl ? 0.4 + 0.6 * s : 0.4 + 1.1 * s)));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 4. * pi * (2. * mod (floor (0.004 * tCur), 2.) - 1.) *\n     SmoothBump (0.25, 0.75, 0.25, mod (0.004 * tCur, 1.));\n  el = 0.17 * pi - 0.12 * pi * cos (0.07 * pi * tCur);\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n    el = clamp (el, 0.05 * pi, 0.45 * pi);\n  }\n  zmFac = 5.2 - 2. * el;\n  ro = 30. * vec3 (cos (el) * cos (az), sin (el), cos (el) * sin (az));\n  vd = normalize (vec3 (0., 3.5, 2.) - ro);\n  vuMat = mat3 (vec3 (vd.z, 0., - vd.x) / sqrt (1. - vd.y * vd.y),\n     vec3 (- vd.y * vd.x, 1. - vd.y * vd.y, - vd.y * vd.z) / sqrt (1. - vd.y * vd.y), vd);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  sunDir = normalize (vec3 (1., 1., 1.));\n  dstFar = 200.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrEECapsDf (vec3 p, vec3 v1, vec3 v2, float r)\n{\n  vec3 s, t;\n  s = p - v1;\n  t = v2 - v1;\n  return length (s - clamp (dot (s, t) / dot (t, t), 0., 1.) * t) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec3 RgbToHsv (vec3 c)\n{\n  vec4 p, q;\n  float d;\n  const float e = 1.e-10;\n  p = mix (vec4 (c.bg, vec2 (-1., 2./3.)), vec4 (c.gb, vec2 (0., -1./3.)), step (c.b, c.g));\n  q = mix (vec4 (p.xyw, c.r), vec4 (c.r, p.yzx), step (p.x, c.r));\n  d = q.x - min (q.w, q.y);\n  return vec3 (abs (q.z + (q.w - q.y) / (6. * d + e)), d / (q.x + e), q.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBBRR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 881, 904, 904, 1637], [1639, 1639, 1673, 1673, 2189], [2191, 2191, 2222, 2222, 2380], [2453, 2453, 2475, 2475, 7135], [7137, 7137, 7159, 7159, 7361], [7363, 7363, 7396, 7396, 7572], [7574, 7574, 7595, 7595, 7795], [7797, 7797, 7840, 7840, 10710], [10712, 10712, 10734, 10734, 10803], [10805, 10805, 10840, 10840, 12002], [12004, 12004, 12058, 12058, 12493], [12495, 12495, 12530, 12530, 14780], [14782, 14782, 14838, 14838, 15845], [15847, 15847, 15879, 15879, 15979], [15981, 15981, 16014, 16014, 16103], [16105, 16105, 16148, 16148, 16212], [16214, 16214, 16268, 16268, 16383], [16385, 16385, 16427, 16427, 16478], [16480, 16480, 16537, 16537, 16620], [16622, 16622, 16652, 16652, 16710], [16712, 16712, 16736, 16736, 16872], [16874, 16874, 16898, 16898, 17214], [17248, 17248, 17272, 17272, 17325], [17327, 17327, 17351, 17351, 17481], [17483, 17483, 17507, 17507, 17727], [17729, 17729, 17754, 17754, 17900], [17902, 17902, 17927, 17927, 18113], [18115, 18115, 18140, 18140, 18365], [18367, 18367, 18389, 18389, 18543], [18545, 18545, 18566, 18566, 18721], [18723, 18723, 18744, 18744, 18899], [18901, 18901, 18930, 18930, 19142], [19144, 19144, 19183, 19183, 19367]], "test": "untested"}
{"id": "MtBBRW", "name": "Drew's Poster", "author": "TheHead", "description": "A friend of mine designed this function years ago, and I thought it would be fun to make a shader to explore it in real-time. You can read more about it here:\nhttp://www.traipse.com/poster/", "tags": ["procedural", "2d"], "likes": 0, "viewed": 171, "published": "Public API", "date": "1514748470", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.14159266\n\n#define ROTATIONS_PER_SECOND (1.0 / 37.345)\n\n#define ZOOMS_PER_SECOND (1.0 / 23.384)\n#define MAX_ZOOM 5.0\n#define MIN_ZOOM 0.8\n\n#define DX_PER_SECOND (1.0 / 25.894)\n#define DY_PER_SECOND (1.0 / 17.127)\n#define MAX_DX 0.3\n#define MAX_DY 0.3\n\nfloat swirl(in vec2 p, in int m, in float s)\n{\n    float d;\n    \n    if (p == vec2(0.0,0.0)) {\n        return 0.0;\n    }\n    \n    d = length(p);\n\n    return cos(float(m)*(atan(p.y, p.x) + s*d))*0.5 + 0.5;\n}\n\nfloat sink(in vec2 p, in float r)\n{\n    float d = length(p);\n    \n    d = d/r - 1.0;\n    d = max(d, 0.0);\n\n    return 1.0 - 1.0/exp(d);\n}\n\nfloat ripple(in vec2 p, in float r)\n{\n    float d = length(p);\n\n    return cos(d/r*M_PI)*0.5 + 0.5;\n}\n\nvec2 bulge(in vec2 p, in vec2 c, float r, float e)\n{\n    vec2 v;\n    float d;\n    \n    v = p - c;\n    d = length(v);\n    if (d == 0.0) {\n        return p;\n    }\n    \n    v /= d;\n    \n    d = pow(d/r, e)*r;\n    return c + v * d;\n}\n\nfloat fn(in vec2 p)\n{\n    float f;\n    float a;\n    vec2 d;\n    \n    p.y = 1.0 - p.y;\n    \n    d = p;\n    \n    p = bulge(p, vec2(0.5, 0.7), 0.6, 3.0);\n    \n    a = 0.1;\n    f = ripple(d - vec2(0.4, 0.4), a)\n        + ripple(d - vec2(0.8, 0.1), a)\n        + ripple(d - vec2(0.9, 0.3), a)\n        + ripple(d - vec2(0.3, 0.8), a)\n        + ripple(d - vec2(0.7, 0.1), a)\n        + ripple(d - vec2(0.4, 0.5), a);\n    f /= 6.0;\n    \n    a *= sink(d - vec2(0.5, 0.7), 0.4);\n    if (a > 0.0) {\n        p.x += cos(f*2.0*M_PI*2.0)*a;\n        p.y += sin(f*2.0*M_PI*2.0)*a;\n    }\n    \n    a = 0.01;\n    f = ripple(p - vec2(0.2, 0.4), a)\n        + ripple(p - vec2(0.4, 0.2), a)\n        + ripple(p - vec2(0.6, 0.8), a)\n        + ripple(p - vec2(0.1, 0.2), a)\n        + ripple(p - vec2(0.9, 0.2), a)\n        + ripple(p - vec2(0.2, 0.3), a);\n    f /= 6.0;\n    \n    p.x += cos(f*2.0*M_PI*2.0)*a;\n    p.y += sin(f*2.0*M_PI*2.0)*a;\n    \n    f = pow(swirl(p - vec2(0.5, 0.7), 3, 12.0), 0.7);\n    f *= sink(p - vec2(0.5, 0.7), 0.005);\n\n    return f;\n}\n\nvec2 rotate(in vec2 p, in vec2 origin, in float rad)\n{\n    float s = sin(rad);\n    float c = cos(rad);\n    \n    mat2 m = mat2(c, -s, s, c);\n\n    return m * (p - origin) + origin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.y;\n    uv.x -= iResolution.x / (4.0 * iResolution.y);\n    \n    // Rotate around the center of interest at the desired rate.\n    vec2 rotateAround = vec2(0.5, 0.5);\n    uv = rotate(uv, rotateAround, iTime * 2.0 * M_PI * ROTATIONS_PER_SECOND);\n    \n    // Get a pair of sine waves with the desired periods and ranges for translation.\n    vec2 d;\n    d.x = sin(iTime * 2.0 * M_PI * DX_PER_SECOND) * MAX_DX;\n    d.y = sin(iTime * 2.0 * M_PI * DY_PER_SECOND) * MAX_DY;\n    uv += d;\n    \n    // Get a sine wave with the desired period on the range [0,1], starting zoomed out.\n    float zoom = (-cos(iTime * 2.0 * M_PI * ZOOMS_PER_SECOND) + 1.0) / 2.0;\n    uv /= mix(MIN_ZOOM, MAX_ZOOM, zoom);\n    \n    float f = fn(uv);\n    \n    fragColor = vec4(f, f, f, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBBRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[266, 266, 312, 312, 472], [474, 474, 509, 509, 611], [613, 613, 650, 650, 714], [716, 716, 768, 768, 945], [947, 947, 968, 968, 1977], [1979, 1979, 2033, 2033, 2159], [2161, 2161, 2218, 2218, 3010]], "test": "untested"}
{"id": "MtBBzh", "name": "try shadow2", "author": "cailuming", "description": "try soft shadow,fog and camera", "tags": ["shadow"], "likes": 0, "viewed": 106, "published": "Public", "date": "1514741615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FAR 64.\n#define PI 3.1415926\n#define BIAS 1e-15\nstruct Ray{\n  vec3 o;\n  vec3 d;\n};\n\n// rotate functions\nmat2 rot2D(float a){\n  float c= cos(a);\n  float s= sin(a);\n  return mat2(\n     c,-s,\n     s, c\n  );\n}\n \n\n//various primitives\nvec2 plane(vec3 p){\n  float len=length(p);\n  float arc=atan(p.y,p.z+BIAS);\n  float v= p.y+1.+2.6*cos(0.1*p.z)*sin(0.2*p.x);\n  return vec2(v,0);    \n}\n\nvec2 obj1(vec3 p,vec3 c){\n  p-=c;\n \n  p.y*=0.1;\n  p-=vec3(2.7*cos(5.*p.y+iTime*6.),0,0);\n\n  return vec2(length(p)-1.,1);    \n}\n\n\n//texture mapping\n\nvoid textureMap(inout vec3 col,vec3 rd,int id){\n    float arc =atan(rd.y,rd.x+BIAS);\n    float len =0.;\n    if(id==0){\n        \n        col=mix(col,texture(iChannel1,rd.xz/10.).xyz,0.5);\n    }else if(id==1){\n        col*=vec3(2.* cos(rd.y*4.),0.7,0.1);\n    }else if(id==2){\n        \n    }else if(id==3){\n        \n    }else if(id==4){\n        \n    }\n}\n\n\n// compare function\nvoid cmp(vec2 a,inout vec2 r){\n    r=a.x>r.x?r:a;\n}\n \n//map functions\nvec2 map(vec3 p){\n    vec2 r=vec2(1.);\n    \n    cmp(obj1(p,vec3(0,0,0)),r);\n  \n    cmp(plane(p),r);\n    \n    return r;\n}\n\n//compute the normal\nvec3 norm(vec3 p,float dis){\n  vec2 e = vec2(0,1)/dis;\n  float m= map(p).x;\n  return -normalize(\n      vec3(\n          m-map(p+e.yxx).x,\n          m-map(p+e.xyx).x,\n          m-map(p+e.xxy).x\n      )\n  );  \n}\n\n// compute the soft shadow\nfloat shadow(vec3 o,vec3 d,float mint,float maxt,float k){\n    float t=0.;\n    vec2 h=vec2(0);\n    float r=1.;\n    for(float i=0.;i<=64.;i++){\n       h=map(o+t*d);\n       r=min(r,h.x*k/t);\n       t+=clamp(h.x,mint,0.3);\n       if(t>maxt||h.x<mint){\n          break;\n       }\n       \n    }\n    return r;\n}\n\n// based on Inigo Quilez's fog method\nvoid fog(inout vec3 col,float dis,vec3 ro,vec3 rd,vec3 ld){\n   float a=0.2;\n   float b=0.14;\n   float fv = a * exp(-ro.y*b) * (1.-exp( -dis*rd.y*b ))/rd.y;\n   float sv =ld.y;//clamp(dot(-rd,ld),ld.y,ld.y);\n   \n   vec3 scol=vec3(0.0,0.5,0.9);  \n   vec3 fogc= vec3(0.3,0.8,1);\n   fogc =mix(fogc,scol,sv); \n   fv*=(1.-exp(-0.004*dis*dis));\n   col=mix(col,fogc,fv);\n}\n\nvoid sun(inout vec3 col,vec3 p,vec3 lp,float t){\n   p-=lp;\n    \n   float v = 0.3 /length(p.xy);\n  \n   v=t>40.?v:0.;\n  \n   if(t>=40.){\n       col=vec3(0.3,0.3,1.)*clamp(lp.y,0.,1.);\n   }\n   //col+=vec3(v);\n   \n}\n\n// ray tracer\nvec2 rayHit(Ray r){\n    float t=1.;\n    vec2 h=vec2(0);\n    \n    for(float i=0.;i<FAR;i++){\n        h=map(r.o+t*r.d);\n        if(h.x<0.0001||t>60.){\n            break;\n        }\n        t+=h.x;\n    }\n    return vec2(t,h.y);\n}\n\n// do light calculation\nvec2 doLight(inout Ray r,float v,vec3 lp){\n    \n    vec3 p = r.o+v*r.d;\n    vec3 ld = normalize(p-lp);\n    vec3 n=norm(p,v);\n    \n    float nl = clamp(dot(n,-ld),0.0,1.);\n    float rl =clamp(dot(r.d,normalize(reflect(normalize(lp),n))),0.,1.);\n    float sl = shadow(lp,ld,0.0001,length(lp-p)*0.95,128.);\n    float fc =clamp(sl,0.1,1.)*nl+0.1+rl*rl;\n    \n    return vec2(fc,v);\n}\n\n//set the camera \nvoid setCamera(inout Ray r,vec3 pos,vec3 tar,vec2 uv){\n    vec3 look= normalize(tar);\n    vec3 right = normalize( cross(vec3(0.0,1.0,0.0),look) );\n    vec3 up = normalize( cross(look,right));\n    vec3 rd = normalize(uv.x*right + uv.y*up + 0.6*look );\n    r.o=pos;\n    r.d=rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-vec2(0.5);\n    float as =iResolution.x/iResolution.y;\n    uv.x*=as;\n    \n    vec3 lp = vec3(10,10.*cos(iTime*0.2),10); \n     \n    Ray ray;\n    \n    vec3 pos =vec3(0,2,-20);\n    vec3 dir =vec3(0,-PI*0.03,1.);\n    pos.xz*=rot2D(iTime*PI*0.1);\n    dir.xz*=rot2D(iTime*PI*0.1);\n    \n    setCamera(ray,pos,dir,uv);\n    \n    vec2 v = rayHit(ray);\n    vec2 res =doLight(ray,v.x,lp);\n    vec3 col =vec3(res.x);\n    \n    textureMap(col,ray.o+ray.d*v.x,int(v.y));\n    sun(col,ray.o+ray.d*v.x,lp,res.y);\n    \n    fog(col,v.x,ray.o,ray.d,normalize(-lp));\n    col=pow(col,vec3(1.5));\n   \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBBzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 112, 132, 132, 213], [217, 238, 257, 257, 387], [389, 389, 414, 414, 515], [518, 537, 584, 584, 887], [890, 910, 940, 940, 961], [964, 980, 997, 997, 1100], [1102, 1123, 1151, 1151, 1331], [1333, 1360, 1418, 1418, 1664], [1666, 1704, 1763, 1763, 2067], [2069, 2069, 2117, 2117, 2279], [2281, 2295, 2314, 2314, 2520], [2522, 2546, 2588, 2588, 2924], [2926, 2944, 2998, 2998, 3221], [3223, 3223, 3280, 3280, 3926]], "test": "untested"}
{"id": "MtBfzR", "name": "Dynamic Targets", "author": "antonOTI", "description": "Randomly adding animations uppon animations I came up with this", "tags": ["2d", "circle"], "likes": 23, "viewed": 681, "published": "Public API", "date": "1514326823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define TAU (2. * PI)\n#define HPI (PI / 2.)\n\n#define SMOOTH(r,p) smoothstep(-.004, .004, p-(r)) \n\nfloat diskDf(vec2 p,float r)\n{\n    return length(p) - r;\n}\n\nfloat circleDf(vec2 p,float r, float t)\n{\n    float ht = t/2.;\n    return max(diskDf(p,r + ht), - diskDf(p,r - ht));\n}\n\n//from https://www.shadertoy.com/view/4sSyDd\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n//from https://www.shadertoy.com/view/Ml33W7\nfloat rectDist(vec2 p, vec2 dim) {\n    return max(abs(p).x - dim.x*0.5, abs(p).y - dim.y*0.5);\n}\n\nmat2 rot(float a)\n{\n    float c = cos(a); float s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat bounce(float p, float b)\n{\n    return .5 - cos(p * PI) * .5 + sin(p * PI) * p * b ;\n}\n\nfloat multiplexer(float channel, float nbChannel, float t, float b)\n{\n    float ft = floor(t);\n    float mt = t- ft;\n    mt *= nbChannel;\n    channel = clamp(mt - channel,0.,1.);\n    channel = bounce(channel, b) ;\n    return ft + channel;\n}\n\nfloat multiplexer(float channel,float nbChannel,float t)\n{\n    return multiplexer(channel, nbChannel, t, .0);\n}\n\nfloat noise(vec2 p)\n{\n    return fract(dot(sin(p.x * 123.12)*142.,cos(p.y *34.95)*165.47));\n}\n\nfloat sigil(vec2 p, float id)\n{\n    p.x = floor(p.x * 4.) / 4.;\n    p.y = floor(p.y * 5.) / 5.;\n    \n    float f = step(.1,p.x) * step(p.x, .9) * step(.1,p.y) * step(p.y, .9);\n    f *= step(noise(p + id), .5);\n    \n    return f;\n}\n\nfloat sigilSheet(vec2 p, float seedDelta)\n{\n    float rep = .1;\n    \n    vec2 ruv = mod(p,rep) / rep;\n    vec2 idUV = floor(p/rep) * rep;\n    \n    float no = noise(idUV + rep*.5);\n    float nbChar = 30.;\n    no = floor(no * nbChar) / nbChar; \n    \n    return sigil(ruv, no + seedDelta);\n}\n\nvec2 triChecker(vec2 p, float s)\n{\n    p.x += p.y * .5 ;\n    vec2 m = mod(p,s); \n    vec2 base = p - m;\n    p = m / s; \n    \n    base.x *= 2. + step(p.x,p.y);\n    \n    return base;\n}\n\n#define NB_CHANNEL 31.\n#define CHANNEL_DURATION .5\n#define TOTAL_DURATION (NB_CHANNEL * CHANNEL_DURATION)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x /= iResolution.y / iResolution.x;\n    \n    float time = mod(iTime,TOTAL_DURATION) / TOTAL_DURATION;\n    \n    float t0 = multiplexer(0.,NB_CHANNEL,time, .1);\n    float t3 = multiplexer(3.,NB_CHANNEL, time, .1);\n    float t5 = multiplexer(5.,NB_CHANNEL, time);\n    float t12 = multiplexer(12.,NB_CHANNEL, time);\n    float t13 = multiplexer(13.,NB_CHANNEL,time);\n    float t14 = multiplexer(14.,NB_CHANNEL,time,.2);\n    float t16 = multiplexer(16.,NB_CHANNEL, time, .2);\n    float t17 = multiplexer(17.,NB_CHANNEL,time);\n    float t17_5 = multiplexer(17.5,NB_CHANNEL,time);\n    float t18 = multiplexer(18.,NB_CHANNEL,time);\n    float t19 = multiplexer(19.,NB_CHANNEL,time);\n    float t21 = multiplexer(21.,NB_CHANNEL,time, .3);\n    float t22 = multiplexer(22.,NB_CHANNEL,time);\n    float t24 = multiplexer(24., NB_CHANNEL, time);\n    float t26 = multiplexer(26., NB_CHANNEL, time);\n    float t28 = multiplexer(28.,NB_CHANNEL,time, .25);\n    float t30 = multiplexer(30.,NB_CHANNEL, time, .1);\n    \n    float distor = 0.;\n    distor += sin(t16 *  PI);\n    uv.x += sin(uv.y * iResolution.y) * .075 * distor;\n    \n    vec2 mirrored;\n    \n    float r1 = .25 + 2. * (1. - t0) + 2. * t28;\n    float f = circleDf(uv, r1, .01);\n    \n    \n    float raSpeed = .15;\n    float a = atan(uv.y,uv.x);\n    float an = (a + PI) / TAU;\n    float aa = mod(an + .25 + time * raSpeed, 1.);\n    float r3 = .32;\n   \tfloat st = sin(aa * TAU * 24.);\n    st = SMOOTH(st,0.);\n    \n    an = mod(an + .25,1.);\n    st *= step(1. - an, t13) * step(t26, 1. - an );\n    \n    float c3 = circleDf(uv,r3, st * .03 - .03);\n   \t\n    f = min(c3,f);\n    float r4 = .45;\n    float c4 = circleDf(uv,r4, st * .03 - .03);\n    f = min(c4,f);\n    \n    float dist = length(uv);\n    vec2 po = vec2(an, dist * .48) * 3.; po.y += .01;\n    \n    \n    float tSigil = floor(time * 400. * step(t12, .0));\n    \n    float si =  sigilSheet(po, tSigil);\n   \t\n    si *= step(sin(t12 * TAU * 4.), .0);\n    \n    si *=  (1. - circleDf(uv,.385,.05));\n    si *=  t5  * step(t26, 1. - an );\n    \n    f = min(f, 1. - si);\n    \n    float nbMirror = 3.;\n    mirrored = modA(uv * rot(t21 * PI - t14 * HPI) ,nbMirror);\n    float quadrant = floor(an * nbMirror);\n    float tLine = multiplexer(4. + quadrant * .1 ,NB_CHANNEL, time);\n    mirrored.x -=  .2 + (1. - tLine) * 2.;\n    \n    \n    float line = rectDist(mirrored, vec2(.03 - t22 *.03,-.005));\n    f = min(f,line);\n    \n    \n    float top = .4; float bot = -.4;\n    float height = top - bot;\n    \n    vec2 siUv = uv; ; siUv.x -= .025;\n    si =  sigilSheet(siUv, 0.);\n    float side = 1. -  si  * step(-.57,uv.x) * step(uv.x,-.47) * step(uv.y, .4) * step(-.4,uv.y);\n    \n    \n    side = max(side, step(t17 * height, uv.y - bot));\n    side = max(side , sin(t18 * TAU * 4.));\n    \n    f = min(f,side);\n    \n    siUv.x += .075;\n    si =  sigilSheet(siUv, 8.);\n    side = 1. -   si  * step(.47,uv.x) * step(uv.x,.57) * step(uv.y, .4) * step(-.4,uv.y);\n    \n    side = max(side, step(t17_5 * height, uv.y - bot));\n    side = max(side , sin(t18 * TAU * 4.));\n    \n    f = min(f,side);\n    \n    float r2 = .15 + 2. * (1. - t3) + 2. * t30;\n    f =  max(step(dist, r2),f);\n    f = min(circleDf(uv, r2, .015), f);\n    \n    mirrored = modA(uv * rot( -t12 * PI + HPI - t30 * PI),3. + t17 * 3. - t28 * 2. - t24);\n    \n    float li = distance(mirrored.x, .03 + (t12 - t24) * .045) * 2.;\n\t\n    f = min(f, li);\n    \n    f = SMOOTH(f,.01);\n    \n    \n    uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x /= iResolution.y / iResolution.x;\n    vec2 tri = triChecker(uv + iTime * .01, .07);\n    f += noise(tri) * .1;\n    \n    fragColor = vec4(mix(vec4(0.),vec4(1.,1.,.7,1.)*.75,f));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBfzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 147, 147, 175], [177, 177, 218, 218, 295], [297, 342, 375, 375, 506], [508, 553, 587, 587, 649], [651, 651, 670, 670, 739], [741, 741, 773, 773, 832], [834, 834, 903, 903, 1074], [1076, 1076, 1134, 1134, 1187], [1189, 1189, 1210, 1210, 1282], [1284, 1284, 1315, 1315, 1514], [1516, 1516, 1559, 1559, 1804], [1806, 1806, 1840, 1840, 1988], [2097, 2097, 2154, 2154, 5871]], "test": "untested"}
{"id": "MtfBWS", "name": "Trippy Hell", "author": "tague", "description": "Random stuff born from boredom.", "tags": ["experiment", "sine", "trippy"], "likes": 2, "viewed": 138, "published": "Public", "date": "1513092844", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rad (float deg) {\n    return deg * 0.01745329;\n}\n\nvec2 rot (vec2 coord, vec2 centre, float angle) {\n    mat2 rm = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    return (coord - centre) * rm + centre;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = rot(fragCoord, iMouse.xy, distance(fragCoord, iMouse.xy) / 100. + iTime / 100. - cos(iTime * 2. + distance(fragCoord, iMouse.xy) / 200.));\n    \n\tvec2 uv = fragCoord / iResolution.xy;\n    uv.y *= 6.;\n    uv.y -= 3.;\n    \n    uv = rot(uv, vec2(0.5, 0.5), -distance(uv, iMouse.xy / iResolution.xy) / 10.);\n    \n    vec2 sinmv = vec2(sin(iTime * 10.) * 10., cos(iTime * 10.) * 10.);\n    vec2 wavy = vec2(sin(fragCoord.x / 3. + iTime * 20.) * (10. + sin(iTime)), cos(fragCoord.y / 4. + iTime * 20.) * (10. - sin(iTime)));\n    \n    if (distance(iMouse.xy, fragCoord + sinmv - wavy) < 100.) uv /= 2.;\n    else if (distance(iMouse.xy, fragCoord - sinmv + wavy) < 150.) uv *= 2.;\n    \n    float sx = uv.x * 6.28318530718 + iTime * 5.;\n    \n    float target =  (sin(sx * 1. + rad(90.)) * 1.);\n    float target2 = (cos(sx * 1. - rad(90.)) * 1.);\n    \n    vec4 color = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    vec4 col2 = vec4(0.5+0.5*cos(iTime), -uv, 1.0);\n    vec4 col3 = vec4(uv.x, 0.5-0.5*sin(iTime), -uv.y, 1.0);\n    \n\tfragColor = color;\n    if (uv.y < target) fragColor = mix(fragColor, col2, 0.5);\n    if (uv.y > target2) fragColor = mix(fragColor, col3, 0.5);\n    \n    if (distance(iMouse.xy, fragCoord + wavy) < 50.) fragColor *= 2.;\n    if (mod(distance(iMouse.xy + vec2(sin(fragCoord.x / 10.) * 20., cos(fragCoord.x / 10. * 20.)), fragCoord - wavy) + iTime * 50., 100.) > 20. * cos(iTime * 5.) + 40.) fragColor = 1. - fragColor;\n    \n    fragColor.r *= 3. * sin(iTime / 3.);\n    fragColor.g *= 3. * cos(iTime / 2.);\n    fragColor.b *= 3. * tan(iTime / 5.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtfBWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 54], [56, 56, 105, 105, 219], [221, 221, 278, 278, 1848]], "test": "untested"}
{"id": "MtfBzB", "name": "Nibble Extraction", "author": "BigotedSJW", "description": "not sure why I'm bothering to publish this, but yeah. Looks like 32bit integers are not truncated down to 24 bits like I feared.", "tags": ["2d", "simple", "bitoperations"], "likes": 0, "viewed": 102, "published": "Public", "date": "1512277611", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const ivec2 bits = ivec2(0x01234567,0x89ABCDEF);\n\nint lookup4(in ivec2 fakeb64, in int pos)\n{  pos &= 0xF;\n \tint shiftby = ((~pos & 7)) << 2;\n\tif((pos & 8) == 8){\treturn (fakeb64.y >> shiftby) & 0xf;}\n \telse\t\t\t  { return (fakeb64.x >> shiftby) & 0xf;}\n}\t//int lookup8(in ivec4 fakeb128, in int pos);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / (iResolution.xy);\n    uv += vec2(sin(iTime + uv.y*3.14159), 0.)/16.;\n    int x = int(uv.x*32.);\n\tfragColor = vec4(  lookup4(bits,x) ) / 15.; //normalize from 0..15 to 0...1.0\n    //thanks Fabrice\n         \n}\n/*\nint lookup8(in ivec4 fakeb128, in int pos)\n{  pos &= 0x3F;\n \t\n \tint shiftby = ((~pos & 7)) << 2;\n\tswitch(0x30 & pos) //bad bug, wrong bits\n    { \tcase 0x00:\treturn (fakeb128.x >> shiftby) & 0xf;\tbreak;\n    \tcase 0x10:\treturn (fakeb128.y >> shiftby) & 0xf;\tbreak;\n     \tcase 0x20:\treturn (fakeb128.z >> shiftby) & 0xf;\tbreak;\n     \tcase 0x30:\treturn (fakeb128.w >> shiftby) & 0xf;\tbreak;\n    }\n \treturn -1;\n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtfBzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 93, 93, 253], [254, 302, 359, 359, 593]], "test": "untested"}
{"id": "MtffDS", "name": "Rorschach Mask", "author": "ab1093996300", "description": "Simulating Rorschach's mask pattern. ", "tags": ["noise", "fluid"], "likes": 0, "viewed": 468, "published": "Public API", "date": "1513110497", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(float t)\n{\n    return fract(sin(t*8415.281)*3810.3821);\n}\n\nfloat rand2(vec2 st)\n{\n    return fract(sin(dot(st, vec2(17.1831, 48.218)))*8471.831);\n}\n\nfloat noise(vec2 st)\n{\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float a = rand2(i);\n    float b = rand2(i + vec2(1.0, 0.0));\n    float c = rand2(i + vec2(0.0, 1.0));\n    float d = rand2(i + vec2(1.0, 1.0));\n    \n    vec2 u = smoothstep(0.0, 1.0, f);\n    \n    return (a * (1.0-u.x) * (1.0-u.y) + \n            b * u.x * (1.0 - u.y) + \n            c * (1.0-u.x) * u.y + \n            d * u.x * u.y);\n}\n\nmat2 rotate2d(float a)\n{\n    return mat2(cos(a), -sin(a),\n                sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st = 2.0 * (st - 0.5);\n    st.x *= iResolution.x/iResolution.y;\n    \n    st *= 3.0;\n    st.x = abs(st.x) - 1.0*iTime;\n    float d = 0.35;\n    \n    float r = noise(st * rotate2d(-0.01*iTime));\n    float c = smoothstep(d, d+0.02, r);\n    fragColor = vec4(vec3(c), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtffDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 68], [70, 70, 92, 92, 158], [160, 160, 182, 182, 573], [575, 575, 599, 599, 667], [669, 669, 726, 726, 1043]], "test": "untested"}
{"id": "MtffWl", "name": "Circle Square Pattern", "author": "PaperColor", "description": "Circle Square Pattern", "tags": ["circlesquarepattern"], "likes": 6, "viewed": 933, "published": "Public API", "date": "1513859866", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//I write this in Unity3d first,then implement here,:)\n#define float2 vec2\n#define float3 vec4\n#define float4 vec4\n#define frac fract\n\n#define speed 0.618\n#define lineNumber 7.0\n#define lineWidth 0.1\n\n#define circlePatternColor float4(1.0,0.0,0.0,1.0)\n#define squarePatternColor float4(0.2,1.0,0.6,0.0)\n//#define backgroundColor float4(0.3,0.8,0.8,1.0)\n#define backgroundColor float4(0.0,0.0,0.0,1.0)\n\nfloat lerp(float a,float b,float v)\n{\n\t//clamp to 0 and 1\n\tif(v>1.0) v=1.0;\n\telse if(v<0.0) v=0.0;\n\treturn a*(1.0-v)+b*v;\n}\n\nvec4 lerp(vec4 a,vec4 b,float v)\n{\n\tfloat red = lerp(a.r,b.r,v);\n\tfloat green = lerp(a.g,b.g,v);\n\tfloat blue = lerp(a.b,b.b,v);\n\tfloat alpha = lerp(a.a,b.a,v);\n\treturn vec4(red,green,blue,alpha);\n}\n\nbool IsInRange(float value,float pos,float width)\n{\n\treturn (value>= pos) && (value<= pos+width);\n}\n\nfloat SquarePattern(float2 uv,float pos,float width)\n{\n    uv = uv*2.0 - 1.0;\n\tuv = abs(uv);\n\t//horizontal\n\tbool h = IsInRange(uv.x,pos,width) && (uv.y<pos+width);\n\t//vertical\n\tbool v= IsInRange(uv.y,pos,width)&&(uv.x<pos+width);\n\n\tif(h||v) return 1.0;\n    return 0.0;\n}\n\nfloat CirclePattern(float2 uv,float pos,float width)\n{\n\tuv = uv*2.0 - 1.0;\n\tfloat dis = length(uv);\n\tbool b= IsInRange(dis,pos,width);\n\tif(b) return 1.0;\n\treturn 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    uv.x*=iResolution.x/iResolution.y; \n    uv.x -= 0.35;\n    \n\tfloat hz = iTime*0.5*speed;\n    \n\t\t\t \n\tfloat circlePatternValue =0.0;\n\tfloat squarePatternValue =0.0;\t\t   \n\n\tfor(float index=0.0;index<lineNumber;index+=1.0)\n\t{\n\t\tsquarePatternValue += SquarePattern(uv,frac(hz + index/lineNumber)*2.0,lineWidth);\n\t}\n\n\tfor(float index=0.0;index<lineNumber;index+=1.0)\n\t{\n\t\tcirclePatternValue += CirclePattern(uv,frac(hz + index/lineNumber)*2.0,lineWidth);\n\t}\n\n\tfloat4 finalSquareColor = squarePatternColor * squarePatternValue;\n\tfloat4 finalCircleColor = circlePatternColor * circlePatternValue;\n\n\n\tfloat4 finalPatternColor = lerp(finalSquareColor,finalCircleColor,0.618)*1.5; \n    \n    float plus = circlePatternValue+squarePatternValue;\n\n    float mul = circlePatternValue*squarePatternValue;\n    \n    float sub = circlePatternValue-squarePatternValue;\n    \n    float div = circlePatternValue/squarePatternValue;\n    \n    //try different operators\n    fragColor = lerp(backgroundColor,finalPatternColor,plus);\n    //fragColor = lerp(backgroundColor,finalPatternColor,mul);\n    //fragColor = lerp(backgroundColor,finalPatternColor,sub);\n    //fragColor = lerp(backgroundColor,finalPatternColor,div);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtffWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[303, 402, 439, 459, 525], [527, 527, 561, 561, 724], [726, 726, 777, 777, 825], [827, 827, 881, 881, 1097], [1099, 1099, 1153, 1153, 1267], [1269, 1269, 1326, 1326, 2571]], "test": "untested"}
{"id": "MtjBR1", "name": "JRS_ParticleTest3", "author": "jrs300", "description": "Trying out an a approach for rendering particles", "tags": ["particles"], "likes": 7, "viewed": 281, "published": "Public", "date": "1514651384", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//Global Variables\n\n//Spawning\n\nint numOfParticles = 100;\n\nfloat gSeed = 213.456;\n\n//Velocity \n\nvec2 vMin = vec2(0.2,-0.25);\nvec2 vMax = vec2(2.0,0.25);\n\nfloat vScaleMin = 0.1;\nfloat vScaleMax = 1.0;\n\n//Life\n    \nfloat lifeMin = 0.8;\nfloat lifeMax = 1.5;\n\n//StartSpread\n\nfloat stSpread = 0.1;\n\n\n//SimTime\n//Creates a looping segment of time to syncronize particle behaviours\n\nfloat sTime()\n{\n//SDur = Sim Duration\n\tfloat sDur = lifeMax;\n\treturn sDur*fract(iTime/sDur);\n}\n\n\n//generates a random value from a seed \n\nfloat rand(float seed)\n{    \n    return fract((seed*7.14376197)+fract(seed*2.5447876)+gSeed);\n}\n\n\n//Linear interpolators for float, vec2 and vec3\n\nvec3 lerpV3(vec3 a, vec3 b, float alpha)\n{\n\treturn (a + alpha*(b-a));\n}\n\nvec2 lerpV2(vec2 a, vec2 b, float alpha)\n{\n\treturn (a + alpha*(b-a));\n}\n\nfloat lerpF(float a, float b, float alpha)\n{\n\treturn (a + alpha*(b-a));\n}\n\n\n// non-uniform interpolation\n// allows x and y values to be altered independantly\nvec2 nui(vec2 a, vec2 b, float alphaA, float alphaB)\n{\n    float x = (a.x + alphaA*(b.x-a.x));\n    float y = (a.y + alphaB*(b.y-a.y));\n    return vec2(x,y);\n}\n\n\n//PARTICLE\n// calculate particle location and render as a radial gradient\n// velocity x time/life plus start location = location\n\nfloat particle(vec2 uv, float seed)\n{\n  \n\t// Random values for velocity\n    float vRandA = fract(rand(seed)*32.456);\n    float vRandB = fract(vRandA+fract(rand(seed))*12.678);\n    float vRandC = fract(vRandB+fract(rand(seed))*24.395);\n    \n    //Rand Value for start time spread\n    float stRand = fract(rand(seed)*121.124);\n    \n\t//Random Value for life  \n    float lRand = fract(rand(seed)*91.124);  \n    \n    //time\n    float t = lifeMax*fract((sTime()/lifeMax)+lerpF(stSpread,0.0,stRand));\n    //float t = sTime;\n    \n    float life= lerpF(lifeMin,lifeMax,lRand);\n\n\t//set particle location\n    vec2 loc = vec2(0.0,0.0);     \n    vec2 sLoc = vec2(0.2,0.5);\n        \n\n\t//Set velocity to an intial random value\n\t//Randomly scales down the velocity to create bunching closer to the emitter\n    vec2 v = nui(vMin,vMax,vRandA,vRandB);\n    v = v*lerpF(vScaleMin,vScaleMax,vRandC); \n    v = v*life;\n                      \n\t//Makes y veclocity proportional to x velocity with some variance   \n    v.y= v.y*((v.x/2.0)+0.5);\n                      \n\t//Generates location based on velcocity and current time    \n    loc = v*fract(clamp(t/life,0.0,1.0))+sLoc; \n                      \n\t//Generates radial gradient to represenet particle                           \n    float p = length(uv-loc)/0.01;    \n    p = 1.0-p;\n    p = clamp(p,0.0,1.0);\n    \n\t//Fades out particle over it's life                    \n    float fade = fract(t/life);    \n    fade = 1.0-fade;    \n    p = p*fade;\n    \n\t//inactivity mask = im\n\t//mask that hides particles that have completed their life \n    float im = step(t/life,1.0); \n    p = p*im;\n        \n    return p;\n}\n\n\n\n\nfloat emitter(vec2 uv)\n{\n\n\tfloat p = 0.0;\n    \n\tfloat lp = 0.0;\n    \n\tfloat vi = 1.0;\n    \n\tvec2 v = vec2(6.0,2.0);\n \n    float seed = 1.0;\n    \n    // for each loop render another particle with a unique seed\n\t// lp = last particle\n\t// p = current particle\n    for (int i = 0; i < 100; ++i) \n    {         \n        vi = vi-0.1;\n        seed = vi*1277.1423557;\n//        v.y = 1.17;\n        lp = particle(uv,seed); \n        p = p+lp;\n    }\n    \n    p = clamp(p,0.0,1.0);\n\treturn p;\n}\n         \n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 pixel = vec3(1.0,1.0,1.0);\n\n    vec2 v = vec2(2.1,0.1);\n    \n    float p = 1.0;\n    \n    p = emitter(uv);\n    \n   \tpixel.x = p;\n    \n   \tpixel.y = p;     \n    \n    pixel.z = p;\n    \n\tfragColor = vec4(pixel,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjBR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[296, 377, 392, 414, 471], [474, 515, 539, 539, 610], [613, 662, 704, 704, 733], [735, 735, 777, 777, 806], [808, 808, 852, 852, 881], [884, 966, 1020, 1020, 1124], [1127, 1257, 1294, 1328, 2891], [2896, 2896, 2920, 2920, 3378], [3394, 3394, 3451, 3451, 3769]], "test": "untested"}
{"id": "MtjBzz", "name": "colourful spiral", "author": "Simplyfire", "description": "Fullscreen the abyss for 15 seconds and then look away.\n\nPermanent damage possible, but hopefully unlikely.", "tags": ["spiral"], "likes": 2, "viewed": 83, "published": "Public", "date": "1514394804", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float myAngle(vec2 a, vec2 b){\n  return atan(b.x - a.x, b.y - a.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat mx = max(iResolution.x, iResolution.y);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 center = vec2(0.5,0.5);\n\tfloat t = iTime * 10.0;\n    float angle = myAngle(uv, center)*2.0;\n    float dist = distance(uv, center)*300.0;\n    float spiral = sin(t - angle - dist);  \n    if(spiral > 0.0){\n      uv.y += cos(iTime*1.0)/2.0;\n      uv.x += sin(iTime*1.0)/2.0;\n    \tfragColor = vec4(spiral, uv*spiral, 1.0);\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjBzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 69], [71, 71, 127, 127, 546]], "test": "untested"}
{"id": "MtlBDj", "name": "BeamRacer", "author": "MacSlow", "description": "A learning experience in raytracing. Unfinished, but it's good enough for having a feel for the algorithm now. Glad with the result. ToDo: swap blinn/phong with PBR, CSG, FXAA. Rays: 1x shadow, 3x reflection, 4x refraction. Lights: 2x point. Mouse control", "tags": ["3d", "raytracing", "study", "fresnel"], "likes": 6, "viewed": 732, "published": "Public API", "date": "1513626046", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// BeamRacer - a basic raytracer for learning the fundamentals\n//\n// Copyright 2017 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nprecision highp float;\n\nstruct Ray {\n\tvec3 ro; // ray origin\n    vec3 rd; // ray direction\n};\n\nstruct Result {\n    bool  hit;    // did a ray hit anything?\n    vec3  point;  // where did it hit in world-space\n    vec3  normal; // surface-normal at the hit-point\n    float dist;   // distance from ro to hit-point\n    int   id;     // material-id at that hit-point\n};\n\nstruct Light {\n    vec3 position; // self-explanatory\n\tvec3 ambient;  // kind of a hack\n    vec3 diffuse;  // the light's color\n    vec3 specular; // kind of a hack\n    float attenuation; // attenuation factor\n};\n\nstruct Material {\n    // PBR part\n    vec3  albedo;    // base-color\n    float metallic;  // .0 dielectric, 1. metal\n    float roughness; // .0 .. 1. polished to rough/dull\n\n    // Blinn/Phong part\n    vec3  ambient;     // fake GI-term\n    vec3  diffuse;     // base-color\n    vec3  specular;    // color of specular highlight under white light\n    float shininess;   // \"hardness\" of surface\n    vec3  emissive;    // light emitted?\n    bool  doesReflect; // flag indicating if surface reflects\n    float reflAmount;  // factor for reflection influence\n    bool  doesRefract; // flag indicating if surface refracts\n    float ior;         // index of refraction\n};\n\nfloat saturate (in float v) {return clamp (v, .0, 1.);}\nmat2 r2d (in float a) { float c = cos(a); float s = sin (a); return mat2 (vec2 (c, s), vec2 (-s, c));}\nconst float PI = 3.14159265359;\nconst Result nullResult = Result (false, vec3 (.0), vec3 (.0), .0, 0);\n\nResult minResult (in Result a, in Result b) {\n    if (!a.hit)\n        return b;\n\n    if (!b.hit)\n        return a;\n\n    bool favourA = a.dist <= b.dist;\n    return  Result (true,\n                    favourA ? a.point : b.point,\n                    favourA ? a.normal : b.normal,\n                    favourA ? a.dist : b.dist,\n                    favourA ? a.id : b.id);\n}\n\nResult sphereIntersect (in Ray ray, in vec3 p, in float r, in int id) {\n    Result res = nullResult;\n\n    float a = dot (ray.rd, ray.rd);\n\n    // exit early, if denominator would almost be zero \n    if (a <= 1e-6) {\n        return res;\n    }\n\n    // set up coefficients a, b and c\n    float b = dot (2. * ray.rd, ray.ro - p);\n    vec3 op = ray.ro - p;\n    float c = dot (op, op) - r * r;\n    float d = sqrt (b * b - 4. * a * c);\n    float twoA = 1. / 2.*a;\n\n    // compute possible values for t\n    float t1 = (-b + d) * twoA;\n    float t2 = (-b - d) * twoA;\n\n    // this case should not be possible \n    if (t1 <= .0 && t2 <= .0) {\n\t\treturn res;\n    }\n\n    if (t1 > .0 && t2 > .0) {\n        if (t1 < t2) {\n            vec3 i1 = ray.ro + t1 * ray.rd;\n            float d1 = distance (i1, ray.ro);\n            res.hit = true;\n            res.point = i1;\n            res.normal = normalize (i1 - p);\n            res.dist = d1;\n            res.id = id;\n        } else {\n            vec3 i2 = ray.ro + t2 * ray.rd;\n            float d2 = distance (i2, ray.ro);\n            res.hit = true;\n            res.point = i2;\n            res.normal = normalize (i2 - p);\n            res.dist = d2;\n            res.id = id;\n        }\n    }\n\n    return res;\n}\n\nResult planeIntersect (in Ray ray, in vec3 p, in vec3 n, in int id) {\n    Result res = nullResult;\n\n\t// are ray and plane parallel?\n    if (dot (n, ray.rd) > 1e-6) {\n        return res;\n    }\n\n    // determine ray-plane intersection point\n    vec3 i = ray.ro + (dot(p - ray.ro, n) / dot (ray.rd, n)) * ray.rd;\n\n\n    // prepare result\n    res.hit = true;\n    res.point = i;\n    res.normal = normalize (n);\n    res.dist = distance (i, ray.ro);\n    res.id = id;\n\n    return res;\n}\n\nResult cylinderIntersect(in Ray ray, in vec3 p, in vec3 n, in float h , in float r, in int id){\n    Result res = nullResult;\n\treturn res;\n}\n\nRay cameraRay (in vec2 uv, in vec3 ro, in vec3 lookAt, in float zoom) {\n\tRay ray = Ray (vec3 (.0), vec3 (.0));\n\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 forward = normalize (lookAt - ro);\n    vec3 right = normalize (cross (worldUp, forward));\n    vec3 up = normalize (cross (forward, right));\n    vec3 camCenter = ro + zoom * forward;\n    vec3 i = camCenter + uv.x * right + uv.y * up;\n    vec3 rd = normalize (i - ro);\n\n    ray.ro = ro;\n    ray.rd = rd;\n\n\treturn ray;\n}\n\nResult trace (in Ray ray) {\n    Result ball1 = sphereIntersect (ray,\n                                    vec3 (-2., -1.4*(cos(iTime)*.5+.5), -.5), // center of sphere\n                                    .6,                   // radius of sphere\n                                    3);                   // material-id\n    Result ball2 = sphereIntersect (ray,\n                                    vec3 (1., -1.5*(cos(1.+iTime)*.5+.5), .5),  // center of sphere\n                                    .5,                   // radius of sphere\n                                    3);                   // material-id\n    Result ball3 = sphereIntersect (ray,\n                                    vec3 (.0, -1.6*(cos(2.+iTime)*.5+.5), 1.5),  // center of sphere\n                                    .4,                   // radius of sphere\n                                    3);                   // material-id\n\n    Result plane1 = planeIntersect (ray,\n                                    vec3 (.0, -2., .0),   // point on plane\n                                    vec3 (.0, 1., .0),    // normal of plane\n                                    1);                   // material-id\n    Result plane2 = planeIntersect (ray,\n                                    vec3 (.0, .0, 4.),    // point on plane\n                                    vec3 (.0, .0, -1.),   // normal of plane\n                                    2);                   // material-id\n    Result plane3 = planeIntersect (ray,\n                                    vec3 (-6.0, .0, 0.),  // point on plane\n                                    vec3 (1., .0, 0.),    // normal of plane\n                                    0);                   // material-id\n    Result plane4 = planeIntersect (ray,\n                                    vec3 (6.0, .0, 0.),   // point on plane\n                                    vec3 (-1., .0, 0.),   // normal of plane\n                                    0);                   // material-id\n    Result plane5 = planeIntersect (ray,\n                                    vec3 (.0, 2.0, 0.),   // point on plane\n                                    vec3 (.0, -1.0, 0.),  // normal of plane\n                                    1);                   // material-id\n    Result plane6 = planeIntersect (ray,\n                                    vec3 (.0, .0, -4.),   // point on plane\n                                    vec3 (.0, .0, 1.),    // normal of plane\n                                    2);                   // material-id\n\n    Result res = minResult (plane1, plane2);\n\tres = minResult (plane3, res);\n\tres = minResult (plane4, res);\n\tres = minResult (plane5, res);\n\tres = minResult (plane6, res);\n\n    res = minResult (ball1, res);\n    res = minResult (ball2, res);\n\tres = minResult (ball3, res);\n\n    return res;\n}\n\nLight light[2] = Light[2] (Light (vec3 (1., .5, -1.), // position\n                                  vec3 (.1),          // ambient\n                                  vec3 (1., 1., .5),  // diffuse\n                                  vec3 (1.),          // specular\n                                  1.),                // attenuation\n                           \n                           Light (vec3 (-2., 1., 2.), // position\n                                  vec3 (.1),          // ambient\n                                  vec3 (.5, 1., 1.),  // diffuse\n                                  vec3 (1.),          // specular\n                                  1.));               // attenuation\n\nMaterial material[4] = Material[4] (Material (vec3 (.5),         // PBR: albedo\n                                              .0,                // PBR: metallic\n                                              1.,                // PBR: roughness\n                                              vec3 (.1),         // Blinn/Phong: ambient\n                                              vec3 (.3, .6, .9), // Blinn/Phong: diffuse\n                                              vec3 (1.),         // Blinn/Phong: specular\n                                              20.,               // Blinn/Phong: shininess\n                                              vec3 (.0),         // Blinn/Phong: emissive\n                                    \t\t  false,             // does reflect\n                                              .05,               // reflection strength\n                                    \t\t  false,             // does refract\n                                    \t\t  .31),              // ior\n\n                                    Material (vec3 (.5),         // PBR: albedo\n                                              .0,                // PBR: metallic\n                                              1.,                // PBR: roughness\n                                              vec3 (.1),         // Blinn/Phong: ambient\n                                              vec3 (.9, .3, .6), // Blinn/Phong: diffuse\n                                              vec3 (1.),         // Blinn/Phong: specular\n                                              20.,               // Blinn/Phong: shininess\n                                              vec3 (.0),         // Blinn/Phong: emissive\n                                    \t\t  true,              // does reflect\n                                              .05,               // reflection strength\n                                    \t\t  false,             // does refract\n                                    \t\t  .31),              // ior\n\n                                    Material (vec3 (.5),         // PBR: albedo\n                                              .0,                // PBR: metallic\n                                              1.,                // PBR: roughness\n                                              vec3 (.1),         // Blinn/Phong: ambient\n                                              vec3 (.6, .9, .3), // Blinn/Phong: diffuse\n                                              vec3 (1.),         // Blinn/Phong: specular\n                                              20.,               // Blinn/Phong: shininess\n                                              vec3 (.0),         // Blinn/Phong: emissive\n                                    \t\t  true,              // does reflect\n                                              .05,               // reflection strength\n                                    \t\t  false,             // does refract\n                                    \t\t  .31),              // ior\n\n                                    Material (vec3 (.5),           // PBR: albedo\n                                              .0,                  // PBR: metallic\n                                              1.,                  // PBR: roughness\n                                              vec3 (.1),           // Blinn/Phong: ambient\n                                              vec3 (.95, .9, .85), // Blinn/Phong: diffuse\n                                              vec3 (.1),           // Blinn/Phong: specular\n                                              20.,                 // Blinn/Phong: shininess\n                                              vec3 (.0),           // Blinn/Phong: emissive);\n                                    \t\t  true,                // does reflect\n                                              .15,                 // reflection strength\n                                    \t\t  true,                // does refract\n                                    \t\t  .752));               // ior\n\nvec3 shade (in Ray ray, in Result res) {\n    vec3 amb = vec3 (.0);\n    vec3 diffC[4];\n\n\tfloat pattern1 = saturate (pow (abs(15. * cos(res.point.x+iTime) * sin (res.point.z+iTime)), .3));\n    float pattern2 = saturate (pow (abs(2. * cos(res.point.x+iTime) * sin (res.point.z+iTime) * .5 + .5), .3));\n    float pattern3 = saturate (pow (length (4.*sin(mod((res.point.y*res.point.x), .3))), .125));\n    float pattern4 = saturate (mod (length(res.point*sin(.1*iTime)), .5));\n\n    diffC[0] = mix (vec3 (.3, .6, .9), vec3 (.8), 1. - pattern1);\n    diffC[1] = mix (vec3 (.9, .3, .6), vec3 (.9), 1. - pattern2);\n    diffC[2] = mix (vec3 (.6, .9, .3), vec3 (.5), 1. - pattern4);\n    diffC[3] = vec3 (.0);\n    vec3 specC = vec3 (.0);\n    vec3 specC2 = vec3 (.0);\n    float shininess = 20.;\n    float shininess2 = 20.;\n\n    vec3 lCol = vec3 (.95, .95, .75);\n    vec3 lPos = vec3 (cos (2. * -iTime) * 3., .5, 1. + sin (1.5 *iTime) * .75);\n    vec3 lDir = normalize (lPos - res.point);\n    float diff = max (dot (res.normal, lDir), .0);\n    vec3 ref = normalize (reflect (ray.rd, res.normal));\n    float spec = pow (clamp (dot (ref, lDir), .0, 1.), shininess);\n    Result shaRes = trace (Ray (res.point, lDir));\n    float lDist = length (lPos - res.point);\n    float attenuation = 2. / (lDist * lDist);\n    lCol *= attenuation;\n    specC *= attenuation;\n    float sha = shaRes.dist < lDist ? .5 : 1.;\n\n    vec3 lCol2 = vec3 (.75, .95, .95);\n    vec3 lPos2 = vec3 (sin (iTime) * 4., -.25, 1. - cos (iTime) * .5);\n    vec3 lDir2 = normalize (lPos2 - res.point);\n    float diff2 = clamp (dot (res.normal, lDir2), .0, 1.);\n    vec3 ref2 = normalize (reflect (ray.rd, res.normal));\n    float spec2 = pow (clamp (dot (ref2, lDir2), .0, 1.), shininess2);\n    Result shaRes2 = trace (Ray (res.point, lDir2));\n    float lDist2 = length (lPos2 - res.point);\n    float attenuation2 = 3. / (lDist2 * lDist2);\n    lCol2 *= attenuation2;\n    specC2 *= attenuation2;\n    float sha2 = shaRes2.dist < lDist2 ? .5 : 1.;\n\n    vec3 col = amb +\n        \t   sha * (diff * diffC[res.id] * lCol) +\n\t\t\t   (sha >= .5 ? .0 : spec) * specC +\n\t\t\t   sha2 * (diff2 * diffC[res.id] * lCol2) +\n               (sha2 >= .5 ? .0 : spec2) * specC;\n\n    return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    // normalize and aspect-correct UVs\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n\n    // generate primary ray from camera\n    vec3 ro = vec3 (.0, .0, -3.);\n    ro.xz *= r2d (PI*sin (.5*PI*(iMouse.x/iResolution.x * 2. - 1.)));\n    ro.yz *= r2d (.25*PI*sin (-.5*PI*(iMouse.y/iResolution.y * 2. - 1.)));\n    vec3 lookAt = vec3 (.0);\n    float zoom = 1.75;\n    Ray ray = cameraRay (uv, ro, lookAt, zoom);\n\n    // ray-trace the scene (primary view-ray)\n    Result res = trace (ray);\n    vec3 col = material[res.id].doesRefract ? vec3 (.0) : shade (ray, res);\n\n    if (material[res.id].doesReflect) {\n        const float airIOR = 1.;\n        const float waterIOR = 1.33;\n        float rZero = pow (((airIOR - waterIOR) / (airIOR + waterIOR)), 2.);\n\n\t    vec3 lPos1 = vec3 (cos (2. * -iTime) * 3., .5, 1. + sin (1.5 *iTime) * .75);\n    \tvec3 lPos2 = vec3 (sin (iTime) * 4., -.25, 1. - cos (iTime) * .5);\n    \tvec3 lDir1 = normalize (lPos1 - res.point);\n    \tvec3 lDir2 = normalize (lPos2 - res.point);\n        \n        float cosTheta1 = max (.0, dot (res.normal, lDir1));\n        float cosTheta2 = max (.0, dot (res.normal, lDir2));\n        float fresnel1  = rZero + (1. - rZero) * pow((1. - cosTheta1), 5.);\n        float fresnel2  = rZero + (1. - rZero) * pow((1. - cosTheta2), 5.);\n\n        // first reflection bounce\n\t    Ray reflectedRay = Ray (res.point + .01 * res.normal,\n                                normalize (reflect (ray.rd, res.normal)));\n        Result bounce = trace (reflectedRay);\n        col += fresnel1*fresnel2*.75*material[res.id].reflAmount * shade (reflectedRay, bounce);\n\n        // second reflection bounce\n        reflectedRay = Ray (bounce.point + .01 * bounce.normal,\n                            normalize (reflect (reflectedRay.rd, bounce.normal)));\n        bounce = trace (reflectedRay);\n        col += fresnel1*fresnel2*.5*material[res.id].reflAmount * shade (reflectedRay, bounce);\n\n        // third reflection bounce\n        reflectedRay = Ray (bounce.point + .01 * bounce.normal,\n                            normalize (reflect (reflectedRay.rd, bounce.normal)));\n        bounce = trace (reflectedRay);\n        col += fresnel1*fresnel2*.25*material[res.id].reflAmount * shade (reflectedRay, bounce);\n    }\n\n    if (material[res.id].doesRefract) {\n        // first refraction\n\t    Ray refractedRay = Ray (res.point - .01 * res.normal,\n                                normalize (refract (ray.rd,\n                                                    res.normal,\n                                                    material[res.id].ior)));\n        Result refracted = trace (refractedRay);\n        col += .5 * shade (refractedRay, refracted);\n\n        // second refraction\n\t    refractedRay = Ray (refracted.point - .01 * refracted.normal,\n                            normalize (refract (refractedRay.rd,\n                                                refracted.normal,\n                                                material[res.id].ior)));\n        refracted = trace (refractedRay);\n        col += .25 * shade (refractedRay, refracted);\n\n        // third refraction\n\t    refractedRay = Ray (refracted.point - .01 * refracted.normal,\n                            normalize (refract (refractedRay.rd,\n                                                refracted.normal,\n                                                material[res.id].ior)));\n        refracted = trace (refractedRay);\n        col += .125 * shade (refractedRay, refracted);\n\n        // fourth refraction\n\t    refractedRay = Ray (refracted.point - .01 * refracted.normal,\n                            normalize (refract (refractedRay.rd,\n                                                refracted.normal,\n                                                material[res.id].ior)));\n        refracted = trace (refractedRay);\n        col += .0625 * shade (refractedRay, refracted);\n    }\n\n    // tone-map and gamma-correct\n    col = col / (1. + col);\n    col = .1*col + .9*sqrt (col);\n\n\tfragColor = vec4 (col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtlBDj.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[0, 2192, 2221, 2221, 2247], [2248, 2248, 2271, 2271, 2350], [2455, 2455, 2500, 2500, 2826], [2828, 2828, 2899, 2899, 4072], [4074, 4074, 4143, 4143, 4551], [4553, 4553, 4648, 4648, 4692], [4694, 4694, 4765, 4765, 5170], [5172, 5172, 5199, 5199, 7970], [12678, 12686, 12726, 12726, 14902], [14904, 14904, 14960, 15000, 19051]], "test": "untested"}
{"id": "MtlBDs", "name": "Arbitrary Weave", "author": "Shane", "description": "Using randomly-rotated hexagonal Truchet tiles with varied patterns to create an arbitrary looking weave design. Inspired by BigWIngs's \"Hexagonal Truchet Weaving\" example.", "tags": ["2d", "random", "hexagon", "truchet", "tile", "photoshop", "weave"], "likes": 30, "viewed": 1112, "published": "Public API", "date": "1514116780", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\n\tArbitrary Weave\n\t---------------\n\n\tUsing randomly-rotated hexagonal Truchet tiles with varied patterns to create an arbitrary \n\tlooking weave design. BigWIngs has already produced one (link below), so this is just my\n\ttake on it. This particular example was written from scratch, and is based on some old \n\tcode of mine, but the concept is essentially the same.\n\n\tI put in a few additions, and partly addressed BigWIngs's UV coordinate mapping concerns. \n\tThe little portal lights are rendered using UV coordinates,\twhich work for the wrappable \n\tdot pattern I chose, but I wouldn't say it's a robust solution. However, it would be with a \n\tlittle extra work.\n\n\tConsidering the time of year, I put in a half hearted attempt to give it a mild Christmas \n\tfeel - Redish background, green Christmas lights... It's a very abstract representation. :) \n\tI find green and red a challenging combination to work with, but I think I got away with it.  \n\t\n\tAlgorithmically speaking, constructing one of these patterns is not difficult: Instead of \n\tusing just the standard triple-arc hexagonal Truchet tile, you mix in other combinations,\n\tsuch as overlapping arcs, straight lines, etc. Uncomment the \"SHOW_GRID\" directive, and you \n\tshould be able to make out a few. Some of the tile combinations involve arcs and lines that \n\tcross over one another, which gives the weave effect. Elements that cross over necessitate \n\ta rendering order requirement, but that's not particularly difficult to implement.\n\n\tThe pattern is rendered in a pseudo-3D vector-graphics style. The cool thing about 2D \n\tdistance field values is that you can use them to produce some simple -- but effective -- \n\toldschool Photoshop effects: Layers, drop shadows, highlights, bevels, edging, etc. All are \n\tvery cheap, and a lot of the time, just involve an extra \"mix\" and \"smoothstep\" combination, \n\tand sometimes, an extra distance function call. This example was produced using these \n\tsimple methods.\n\n\tRelated references:\n\t\n\t// The original: Much less code, so if you're trying to get a handle on how to make\n\t// a random hexagonal weave pattern, this is the one you should be looking at.\n\tBigWIngs - Hexagonal Truchet Weaving \n\thttps://www.shadertoy.com/view/llByzz\n\n\n*/\n\n//#define SHOW_GRID\n//#define MULTICOLORED_LIGHTS\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\nconst vec2 s = vec2(1, 1.7320508);\n\n// Standard float to float hash - Based on IQ's original.\nfloat hash(float n){ return fract(sin(n)*43758.5453); }\n\n\n// Standard vec2 to float hash - Based on IQ's original.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.187, 289.973)))*43758.5453); }\n\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement.\n//\nfloat noise3D(vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(7, 157, 113);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\n\n\n// Dot pattern.\nfloat dots(in vec2 p){\n    \n     \n\tp = abs(fract(p) - .5);\n    \n    return length(p); // Circles.\n    \n    //return (p.x + p.y)/1.5 + .035; // Diamonds.\n    \n    //return max(p.x, p.y);// + .03; // Squares.\n    \n    //return max(p.x*.8660254 + p.y*.5, p.y) + .01; // Hexagons.\n    \n    //return min((p.x + p.y)*.7071, max(p.x, p.y)) + .05; // Stars.\n    \n}\n\n\n// The 2D hexagonal isosuface function: If you were to render a horizontal line and one that\n// slopes at 60 degrees, mirror, then combine them, you'd arrive at the following. As an aside,\n// the function may be a bound - as opposed to a Euclidean distance representation, but either\n// way, the result is hexagonal boundary lines.\nfloat hex(in vec2 p){\n    \n    p = abs(p);\n    \n    // Below is equivalent to:\n    return max(max(p.x*.5 + p.y*.8660254, p.x), 0.); \n    \n    //p = vec2(p.y*.8660254 + p.x*.5, p.x);\n    //return min(max(p.x, p.y), 0.) + length(max(p, 0.));\n\n    \n}\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID - in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything - in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec4 getHex(vec2 p){\n    \n    // The hexagon centers: Two sets of repeat hexagons are required to fill in the space, and\n    // the two sets are stored in a \"vec4\" in order to group some calculations together. The hexagon\n    // center we'll eventually use will depend upon which is closest to the current point. Since \n    // the central hexagon point is unique, it doubles as the unique hexagon ID.\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + vec4(.5, .5, 1, 1.5);\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + vec2(0, -.5))*s );\n    \n    // Nearest hexagon center (with respect to p) to the current point. In other words, when\n    // \"h.xy\" is zero, we're at the center. We're also returning the corresponding hexagon ID -\n    // in the form of the hexagonal central point. Note that a random constant has been added to \n    // \"hC.zw\" to further distinguish it from \"hC.xy.\"\n    //\n    // On a side note, I sometimes compare hex distances, but I noticed that Iomateron compared\n    // the squared Euclidian version, which seems neater, so I've adopted that.\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw);\n    //return hex(h.xy)<hex(h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw);\n    \n}\n\n\n// Object rendering: Scene color (col), object distance field (d), pattern value (c), \n// sample spread shade values (d2), object ID (objID), random ID (rnd).\nvec3 doObject(vec3 col, float d, float c, vec2 d2, float objID, float rnd){\n    \n    // The object is either a pipe (objID = 1.) or a join (objID = 0.), so rendering colors, \n    // etc, are dependant upon that. I probably could have written two seperate functions.\n    \n    // Shade values taken from two different sample points - The rendering point and one in the\n    // opposite direction to the shadow. The difference gives you the beveled look and gives the\n    // impression that the object is being lit from the light causing the shadow. Very cheap bump \n    // mapping of sorts, and all fake.\n    float cF = objID>.5? 13. : 15.;\n    float sh = abs(clamp(d2.x, -cF, cF))*16.; //sh = pow(sh, 2.)*1.4;\n    float sh2 = abs(clamp(d2.y, -cF, cF))*16.; //sh2 = pow(sh2, 2.)*1.4;\n   \n    // The gradient or bump value, used for highlighting. It's based on directional derivative\n    // lighting and is somewhat analogous to diffuse lighting.\n    float b = clamp(sh - sh2, 0., 1.)*4.;\n    \n    // I gave the join a differnet alpha value. Not sure why, because I didn't need it in the end,\n    // but I thought I'd blend it into the pipe ever so slighly.\n    float alpha = 1.;\n    if(objID<.5) alpha = .95;\n\n    // Object edge shadowing - Not to be confused with the drop shadow. In a way, it's a very lame\n    // attempt to give an ambient occlusion effect.\n    col = mix(col, vec3(0), (1. - smoothstep(0., .075*alpha, max(d, -(d + .015)) - .025))*.5*alpha);\n \n    // Dark edges. This line, combined with the one immediately above is a Photoshop staple.\n    col = mix(col, vec3(0), (1. - smoothstep(0., .015,  max(d, -(d + .015)) - .025))*alpha);\n    \n    // The pipe color is gray, and the join color is slightly copper, or something... I make this\n    // stuff up as I go along. :)\n    vec3 oCol = vec3(.45);\n    if(objID<.5) oCol = vec3(.6, .45, .3);\n\n    // Combining the term above to produce the object's color. Shading, diffuse and ambience. Not\n    // much different to normal object coloring.\n    oCol = oCol*max(.75 - sh*.25, 0.)*.7 + vec3(.5, .7, 1)*b*2. + vec3(1, .6, .2)*b*b;\n    \n    // Applying the color to the shadow and edges. \n    col = mix(col, oCol, (1. - smoothstep(0., .01, d))*alpha);\n   \n    // Some extra lines near the pipe edges, just to add a little more detail.\n    col = mix(col, vec3(0),  (1. - smoothstep(0., .015, max(d + .035, -(d + .035 + .01))))*.55);\n    \n    \n    // Each portal object has a unique ID attached to it, which can be used to produce a \n    // blinking light effect.\n    float hRnd = hash(rnd);\n    \n    #ifdef MULTICOLORED_LIGHTS\n    vec3 lCol = hRnd>.666? vec3(2, 5, 1) : hRnd>.333? vec3(6, 3, 1) : vec3(1, 2.5, 7);\n    #else\n    vec3 lCol = vec3(2, 5, 1);\n    #endif\n    \n    float blink = smoothstep(.5, .75, sin(rnd*6.283 + iTime*5.));\n    \n    \n    // Apply the textured dot pattern - where applicable - to the pipes.\n    if(objID>.5){\n        \n        lCol = mix(vec3(1), lCol, blink);\n        // Adding some light color around the portals for a bevelled effect. Photoshop 101. :)\n        col = mix(col, vec3(1), (1. - smoothstep(0., .03, d))*(1. - smoothstep(0., .03, c - .14))*.25);\n        // Dark edges. Also a Photoshop staple.\n    \tcol = mix(col, vec3(0), (1. - smoothstep(0., .015, d))*(1. - smoothstep(0., .03, c - .09)));\n        \n        // The light color. Roled in with object masking.\n    \tcol = mix(col, vec3(max(max(.5 - sh*.5, 0.)*.15 + lCol*b*.45, 0.)), (1. - smoothstep(0., .01, d))*(1. - smoothstep(0., .03, c)));\n    }\n    \n    // Return the color for the object.\n    return col;\n    \n    \n    \n}\n\n// Swap functions. Put together in a hurry to deal with elements that couldn't be swizzled.\n// I'll improve the logic at some stage and get rid of them.\nvoid swap(inout float a, inout float b, inout float c){\n    \n    vec3 v = vec3(a, b, c);\n    a = v.y, b = v.z, c = v.x;\n}\n \nvoid swap(inout float a, inout float b){\n    \n    vec2 v = vec2(a, b);\n    a = v.y, b = v.x;    \n}\n \n\n// The overall scene function - consisting of the Truchet object and the join object.\n//\n// The logic here is sound, but a bit of it was hacked together as I went along, so there'd be\n// some grouping opportunities, etc, missed. However, when I get more time, I'll get in amongst\n// it and tidy it up a bit. If it were not for the texture coordinates and custom shading values,\n// this would be a much shorter function.\n//\n// Anyway, the premise behind the function is very simple: Instead of using just the standard \n// triple-arc hexagonal Truchet tile, you mix in other combinations (outlined in the function\n// below), such as overlapping arcs,  straight lines, etc. Produce a few random numbers, then use \n// them to choose and produce a tile combination, randomly rotate by multiples of 60 degrees, and \n// if applicable, rotate the order in which you render certain tile elements. For a visual, \n// uncomment the \"SHOW_GRID\" directive to view some of the possible combinations.\n\n\n// Shade, pattern and random ID globals. Hacked in along the way. I might tidy these up later.\nvec4 ds, pat, gRnd;\n\nvec4 scene(vec2 p){\n    \n    \n    ds = gRnd = pat = vec4(0);\n    \n    // Rotate the XY axis slightly to give the pattern more randomness. The idea is that the \n    // view can't quite discern the horizontal and vertical nature of the pattern.\n    //p = r2(3.14159265/12.)*p;\n    \n    \n    // Scaling, translating, then converting the input to a hexagonal grid cell coordinate and\n    // a unique coordinate ID. The resultant vector contains everything you need to produce a\n    // pretty pattern, so what you do from here is up to you.\n    vec4 h = getHex(p);\n    \n    // Offset hexagonal variable - used to render the joins. You could render them using the\n    // value above, but sometimes, pixelated seem lines can appear at the hexagonal boundaries\n    // when trying to perform offset diffuse calculations... It's a long story, but creating\n    // an offset grid ensures no artefacts.\n    vec4 h2 = getHex(p - vec2(0, .8660254*2./3.));\n    \n    // Using the idetifying coordinate - stored in \"h.zw,\" to produce a unique random number\n    // for the hexagonal grid cell.\n    vec4 rnd;\n    rnd.x = hash21(h.zw + 11.67);\n    //rnd.x = sin(rnd.x*6.283 + floor(iTime))*.5 + .5; // Peridically changes the patten formation.\n    \n    // More random numbers.\n    rnd.y = hash21(h.zw + vec2(45.37, 91.63) + rnd.x);\n    rnd.z = hash21(h.zw - vec2(12.74 + rnd.y, 13.78 + rnd.x));\n    rnd.w = hash21(h.zw + vec2(32.97 + rnd.x, 45.87 - rnd.y + rnd.z));\n    \n    // Store the hexagonal coordinates in \"p\" to save some writing. \"p\" tends to be the universal\n    // shader variable for \"point,\" so it reads a little better too.\n    p = h.xy;\n    \n    \n    float a;\n    \n    // Constants used for the Truchet pattern. The arc thickness, the small are radius and the large\n    // arc radius.\n    const float th = .14;\n    const float rSm = .8660254/3.;\n    const float rLg = .8660254;\n    \n    \n    // Randomly rotate the tile.\n    p = r2(floor(rnd.x*6.)*3.14159265/3.)*p;\n\n    \n    // Distance field variable, and a hacky flag to turn off pattern rendering - Basically, to stop the \n    // portals being rendered under the joins.\n    vec4 d, noPat = vec4(0);\n    \n    // Utils for point storage and the UV coordinates for each of the shapes.\n    vec2 p1, p2, p3, tu1, tu2, tu3;\n    \n    \n    // DISTANCE FIELD, SHADE, ID, AND TEXTURE CALCULATIONS\n    \n    // If one of the random variables is above a certain threshold, render one of the\n    // tiles. The thresholds are distributed according to how much weighting you'd like\n    // to give a certain kind of tile. For instance, I wanted more curves, so gave more\n    // weighting to the arc tiles than the straight line ones.\n    \n    if(rnd.y>.8){ // Three small arcs segments. So-called standard hexagonal Truchet.\n        \n        // Small arc one.        \n\t\tp1 = p - vec2(.5, .8660254/3.);\n        d.x = length(p1) - rSm;        \n        ds.x = d.x;\n        d.x = abs(d.x) - th;\n        a = atan(p1.y, p1.x);\n        // One dot per small arc segment. Three make up a circle.\n        gRnd.x = hash21(h.zw + floor(a/6.283*6.) + .37);\n        a = mod(a/3.14159265, 2.) - 1.;\n        if(a<.0 || a > .333) noPat.x = 1.;\n        tu1 = vec2(a, ds.x + .5);\n        \n        // Small arc two.\n        p2 = p - vec2(-.5, .8660254/3.);\n        d.y = length(p2) - rSm;\n        ds.y = d.y;\n        d.y = abs(d.y) - th;\n        a = atan(p2.y, p2.x);\n        gRnd.y = hash21(h.zw + floor(a/6.283*6.) + 7.45);\n        a = mod(a/3.14159265, 2.) - 1.;\n        if(a<.666) noPat.y = 1.;\n        tu2 = vec2(a, ds.y + .5);        \n\n        // Small arc three.\n        p3 = p - vec2(0, -.8660254*2./3.);\n        d.z = length(p3) - rSm;\n        ds.z = d.z;\n        d.z = abs(d.z) - th;\n        a = atan(p3.y, p3.x);\n        gRnd.z = hash21(h.zw + floor(a/6.283*6.) + 9.23);\n        a = mod(a/3.14159265, 2.) - 1.;\n        if(a<-.666  || a>-.333) noPat.z = 1.;\n        tu3 = vec2(a, ds.z + .5);\n        \n        // No overlap, so no render order flipping is necessary.\n\n        \n    }\n    else if(rnd.y>.65){ // Two long arcs, straight line, with crossover.\n        \n\n\t\t// Large arc one.\n        p1 = p - vec2(1, 0);\n        d.x = length(p1) - rLg;\n        ds.x = d.x;\n        d.x = abs(d.x) - th;\n        // Three dots per long arc segment.\n        a = atan(p1.y, p1.x)*3.;\n        // 6 Segments make up 2PI. Accounting for the \"3\" above. Hence, the \"6\" factor.\n        // Makes sense now - after stuffing around for ten minutes. :)\n        gRnd.x = hash21(h.zw + floor(a/6.283*6.) + 6.72); \n        a = mod(a/3.14159265, 2.) - 1.;\n        if(abs(a)>.333) noPat.x = 1.;\n        tu1 = vec2(a, ds.x + .5);\n\n\t\t// Large arc two.\n        p2 = p - vec2(-1, 0);\n        d.y = length(p2) - rLg;\n        ds.y = d.y;\n        d.y = abs(d.y) - th;\n        a = atan(p2.y, p2.x)*3.;\n        gRnd.y = hash21(h.zw + floor(a/6.283*6.) + 3.37);\n        a = mod(a/3.14159265, 2.) - 1.;\n        if(abs(a)<.666) noPat.y = 1.;\n        tu2 = vec2(a, ds.y + .5);                \n \n        // Straight line.\n        d.z = abs(p.y);\n        ds.z = d.z;\n        d.z = (d.z) - th;\n        a = mod(p.x, 1.);\n        // Three dots per line segment.\n        gRnd.z = hash21(h.zw + floor(a*3.) + 1.83);\n        if(a<.666 && a>.333) noPat.z = 1.;\n        tu3 = vec2(a, ds.z + .5);\n        \n        \n        // Render order flipping.        \n        \n        if(rnd.w>.75) { // d3, d1, d2\n            d.xz = d.zx;\n            ds.xz = ds.zx;\n            swap(tu1.x, tu3.x); swap(tu1.y, tu3.y); \n            noPat.xz = noPat.zx;\n            gRnd.xz = gRnd.zx;\n        }\n        else if(rnd.w>.5) {  // d1, d3, d2\n            d.yz = d.zy;\n            ds.yz = ds.zy; \n            swap(tu2.x, tu3.x);  swap(tu2.y, tu3.y);  \n            noPat.yz = noPat.zy;\n            gRnd.yz = gRnd.zy;\n        }\n        else if(rnd.w>.25) { // d2, d3, d1\n            d.xyz = d.yzx;\n            ds.xyz = ds.yzx;\n            swap(tu3.x, tu1.x, tu2.x); swap(tu3.y, tu1.y, tu2.y); \n            noPat.xyz = noPat.yzx;\n            gRnd.xyz = gRnd.yzx;\n        } \n \n\n    }\n    else if(rnd.y>.55){ // Two short arcs, straight line, no crossover.\n        \n\n\t\t// Small arc one.\n\t\tp1 = p - vec2(0, .8660254*2./3.);\n        d.x = length(p1) - rSm;        \n        ds.x = d.x;\n        d.x = abs(d.x) - th;\n        a = atan(p1.y, p1.x);\n        // One dot per small arc segment. Three make up a circle.\n        gRnd.x = hash21(h.zw + floor(a/6.283*6.));\n        a = mod(a/3.14159265, 2.) - 1.;\n        if(a<.333 || a>.666) noPat.x = 1.;\n        tu1 = vec2(a, ds.x + .5);\n        \n        // Small arc two.\n        p2 = p - vec2(0, -.8660254*2./3.);\n        d.y = length(p2) - rSm;\n        ds.y = d.y;\n        d.y = abs(d.y) - th;\n        a = atan(p2.y, p2.x);\n        gRnd.y = hash21(h.zw + floor(a/6.283*6.) + 4.78);\n        a = mod(a/3.14159265, 2.) - 1.;\n        if(a<-.666 || a>-.333) noPat.y = 1.;\n        tu2 = vec2(a, ds.y + .5);                \n \n        // Straight line.\n        d.z = abs(p.y);\n        ds.z = d.z;\n        d.z = (d.z) - th;\n        a = mod(p.x, 1.);\n        // Three dots per line segment.\n        gRnd.z = hash21(h.zw + floor(a*3.) + 3.96);\n        if(a<.666 && a>.333) noPat.z = 1.;\n        tu3 = vec2(a, ds.z + .5);\n\n\t\t// No overlap, so no rendering order flipping is necessary.\n \n\n    }\n    else if(rnd.y>.45){ // Three straight lines.\n        \n\t\t\n        // Straight line one.\t\n        d.x = abs(p.y);\n        ds.x = d.x;\n        d.x = (d.x) - th;\n        a = mod(p.x, 1.);\n        gRnd.x = hash21(h.zw + floor(a*3.) + 2.92);\n        if(a<.666 && a>.333) noPat.x = 1.;\n        tu1 = vec2(a, ds.x + .5);\n        \n        // Straight line two.\n        d.y = abs(p.y*.5 - p.x*.8660254);\n        ds.y = d.y;\n        d.y = (d.y) - th;\n        a = mod(p.x*.5 + p.y*.8660254, 1.);\n        gRnd.y = hash21(h.zw + floor(a*3.) + 5.38);\n        if(a<.666 && a>.333) noPat.y = 1.;\n        tu2 = vec2(a, ds.y + .5);\n \n        // Straight line three.\n        d.z = abs(p.y*.5 + p.x*.8660254);\n        ds.z = d.z;\n        d.z = abs(d.z) - th;\n        a = mod(p.x*.5 - p.y*.8660254, 1.);\n        gRnd.z = hash21(h.zw + floor(a*3.) + 1.27);\n        if(a<.666 && a>.333) noPat.z = 1.;\n        tu3 = vec2(a, ds.z + .5);        \n        \n         \n        // Render order flipping.\n        \n        //rnd.w = fract(rnd.w + .37);\n\n        if(rnd.w>.75) { // d3, d1, d2\n            d.xz = d.zx;\n            ds.xz = ds.zx;\n            swap(tu1.x, tu3.x); swap(tu1.y, tu3.y); \n            noPat.xz = noPat.zx;\n            gRnd.xz = gRnd.zx;\n        }\n        else if(rnd.w>.5) {  // d1, d3, d2\n            d.yz = d.zy;\n            ds.yz = ds.zy; \n            swap(tu2.x, tu3.x);  swap(tu2.y, tu3.y);  \n            noPat.yz = noPat.zy;\n            gRnd.yz = gRnd.zy;\n        }\n        else if(rnd.w>.25) { // d2, d3, d1\n            d.xyz = d.yzx; \n            ds.xyz = ds.yzx; \n            swap(tu3.x, tu1.x, tu2.x); swap(tu3.y, tu1.y, tu2.y); \n            noPat.xyz = noPat.yzx;\n            gRnd.xyz = gRnd.yzx;\n        } \n        \n\n    }\n\telse { // Two cross over large arcs, and one small one.\n        \n\n        // Large arc one.\n        p1 = p - vec2(1, 0); \n        d.x = length(p1) - rLg;\n        ds.x = d.x;\n        d.x = abs(d.x) - th;\n        a = atan(p1.y, p1.x)*3.; // Longer arc factor of three.\n        gRnd.x = hash21(h.zw + floor(a/6.283*6.) + 8.71);\n        a = mod(a/3.14159265, 2.) - 1.;\n        if(a > .333 || a<-.333) noPat.x = 1.;\n        tu1 = vec2(a, ds.x + .5);\n\n \t\t// Large arc two.\n        p2 = p - r2(3.14159265/3.)*vec2(1, 0);\n        d.y = length(p2) - rLg;\n        ds.y = d.y;\n        d.y = abs(d.y) - th;\n        a = atan(p2.y, p2.x)*3.; // Longer arc factor of three.\n        gRnd.y = hash21(h.zw + floor(a/6.283*6.) + 3.87);\n        a = mod(a/3.14159265, 2.) - 1.;\n        if(abs(a)<.666) noPat.y = 1.;\n        tu2 = vec2(a, ds.y + .5);\n \n        // Small arc.\n        p3 = p - r2(-3.14159265/3.)*vec2(0, .57735);\n        d.z = length(p3) - rSm;\n        ds.z = d.z;\n        d.z = abs(d.z) - th;\n        a = atan(p3.y, p3.x); // Smaller arc.\n        gRnd.z = hash21(h.zw + floor(a/6.283*6.) + 5.54);\n        a = mod(a/3.14159265, 2.) - 1.;\n        if(a<.666) noPat.z = 1.;\n        tu3 = vec2(a,  ds.z + .5);\n\n       \n        // Render order flipping.\n        //rnd.w = fract(rnd.w + .71);\n        \n        if(rnd.w>.5) {\n            d.xy = d.yx;\n            ds.xy = ds.yx;\n            swap(tu1.x, tu2.x); swap(tu1.y, tu2.y);\n            noPat.xy = noPat.yx;\n            gRnd.xy = gRnd.yx;\n        } \n  \n\n    }\n    \n    \n/////\n    \n    // JOINER BLOCKS\n    //\n    // The joins need to be rendered seperately using an offset hexagonal grid, due to pixelated \n    // mismatching at the hexagonal boundaries when highlighting... It's a long story... :)\n    //\n    // Three blocks, arranged in a tri blade propellor scheme. \n    //     \n    vec2 q = h2.xy;\n    float blc = abs(length(q) - .8660254/3.) - th;\n    \n    q = r2(3.14159/6.)*q;\n    a = atan(q.y, q.x);\n    float ia = floor(a/6.283*3.) + .5;\n    q = r2(ia*6.283/3.)*q;\n    q.x -= .8660254/3.;\n        \n    q = abs(q);// - vec2(th, .04);\n    \n    // Holding the joiner block distance field value in a global variable to be \n    // used elsewhere.\n    // The weird mix function gives the joins a slight pinch at the ends to feed the illusion a little more.\n    d.w = mix(length(q) - .04, max(q.x - .16, q.y - .04), .9);\n    //float blocks = mix(length(q) - .04, min(max(q.x - .15, q.y - .04), 0.) + length(max(q - vec2(.15, .04), 0.)), .9);\n    // The shade value (used for highlighting) has been tweaked in an unnatural way to give the reflected\n    // look I was after, but I wouldn't put too much stock in it.\n    ds.w = mix(length(q), min(max(q.x, q.y), 0.) + length(max(q - vec2(0, .0), 0.)), .9);\n    \n\n    \n//////\n    \n    // TEXTURE PATTERN\n    // The textured dot pattern to make the portals. Stored in a global variable \"pat\" to be used\n    // elsewhere.\n    \n    vec2 sc = vec2(3., 3);\n    pat.x = dots(tu1*sc); // Dot pattern.\n    pat.x = pat.x - .135; // Distance field.\n    if(noPat.x > .5) pat.x = 1.;\n    \n    pat.y = dots(tu2*sc);\n    pat.y = pat.y - .135;\n    if(noPat.y > .5) pat.y = 1.;\n    \n    pat.z = dots(tu3*sc);\n    pat.z = pat.z - .135;\n    if(noPat.z > .5) pat.z = 1.;\n    \n    // Block pattern. Just a dummy variable for completeness, as the as blocks won't be textured.\n    pat.w = 1.;\n    \n/* \n\t// Actual textures. Line UV changes, and changes in the \"doObject\" function are required.\n    pat.x = texture(iChannel0, tu1*1.).x;\n    pat.y = texture(iChannel0, tu2*1.).x;\n    pat.z = texture(iChannel0, tu3*1.).x;\n\tpat = pat*pat;\n*/    \n    \n//////\n    \n    return d;\n    \n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    //vec2 fC = floor(fragCoord*4.)/4.;\n    // Aspect correct screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/clamp(iResolution.y, 300., 650.);\n    \n    vec2 p = u*4. + s.yx*iTime/4.;\n    \n    vec3 tx = texture(iChannel0, p/5.).xyz;//r2(3.14159265/9.)*\n    tx *= tx;\n    //tx = smoothstep(.05, .5, tx);\n    \n    vec3 bg = vec3(1, .05, .15)*max(1. - length(u)*.25, 0.);\n    bg = mix(bg, vec3(0), (1. - clamp(sin((p.x*.8660254 + p.y*.5)*6.283*32.)*2. + 1.25, 0., 1.))*.35);\n    \n    \n        \n\n    // Truchet shadow. We're only after an overall distance field value, so the texturing,\n    // shade values, etc, aren't needed. It's a bit wasteful, but the function is only \n    // called once per pass, so the GPU should barely notice.\n    vec4 ds3 = scene(p + .1);\n    \n    float dShad = min(min(ds3.x, ds3.y), min(ds3.z, ds3.w));\n    \n    // Applying the Truchet shadow to the background.\n    bg = mix(bg, vec3(0), (1. - smoothstep(0., .1, dShad))*.85);\n    \n    // Set the scene color to the background texture.\n    vec3 col = bg;\n    \n\n    // Obtaining an offset shade value, which will be combined with the local shade value to \n    // produce a bit of highlighting. It's based off of directional derivative lighting, and\n    // is just a cheap way to produce something anologous to diffuse light.\n    // \n    // As mentioned above, it's a bit wasteful recalating everything (distance fields, texture \n    // coordinates, etc) just to obtain a shade value, but this isn't a GPU intensive example, \n    // so some extra trig calls, and so forth, shouldn't matter.\n    vec4 d2 = scene(p - .008);\n    // The shade value is global (another hack), so we need to store it before making the \n    // function call again.\n    vec4 ds2 = ds; \n    \n    // The main distance field function - It's called after the offset ones, because there are some\n    // global shade and pattern values that needed: Obtaining the four distance field values. The first\n    // three field values returned depend upon the hexagonal tile used, so will consist of mixtures\n    // or small arcs, large arcs or lines. The fourth value retuned is the join.\n    vec4 d = scene(p);\n\n    // Plugging in the object variables, and rendering them accordingly. Depending on the hexagonal tile \n    // configuration, the objects consist of small arcs, large arcs and lines. In some cases, object are \n    // rendered over one another. Hence, the necessity to make three rendering calls in succession.\n    col = doObject(col, d.x, pat.x, vec2(ds.x, ds2.x), 1., gRnd.x);\n\tcol = doObject(col, d.y, pat.y, vec2(ds.y, ds2.y), 1., gRnd.y);\n    col = doObject(col, d.z, pat.z, vec2(ds.z, ds2.z), 1., gRnd.z);\n    \n    // The joiner blocks. They're drawn on top, so are rendered last.\n    col = doObject(col, d.w, pat.w, vec2(ds.w, ds2.w)/1., 0., gRnd.w);\n    \n    \n    // Adding some grunge, just to break things up a little. Comment this section\n    // out, and the example looks too clean.\n    float fBm = noise3D(vec3(p*32., 1. - col.x))*.66 + noise3D(vec3(p*64., 2. - 2.*col.x))*.34;\n    col *= fBm*.65 + .65;\n\n   \n    \n    #ifdef SHOW_GRID\n    // Putting in the grid borders.\n    float eDist = hex(getHex(p).xy);\n    //col = mix(col, vec3(1), smoothstep(0., .01, min(min(d.x, d.y), d.z))*smoothstep(0., .02, eDist - .5 + .02));\n    col = mix(col, vec3(.3, 1, .2)*2., (smoothstep(0., .01, min(min(d.x, d.y), d.z) - .04))*smoothstep(0., .03, eDist - .5 + .02)*.7);\n  \t#endif\n    \n    // The separate offset grid that the blocks are produce in.\n\t//float eDist2 = hex(getHex(p - vec2(0, .8660254*2./3.)).xy);\n    //col = mix(col, vec3(.5, .7, 1)*2., smoothstep(0., .03, eDist2 - .5 + .02)*.7);\n    \n        // Subtle vignette.\n    u = fragCoord/iResolution.xy;\n    col *= pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .125)*.65 + .35;\n    // Colored variation.\n    //col = mix(pow(min(vec3(1.5, 1, 1).zyx*col, 1.), vec3(1, 3, 16)), col, \n             //pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .125)); \n\n      \n    \n    // Rough gamma correction.    \n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtlBDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2298, 2331, 2351, 2351, 2409], [2627, 2685, 2705, 2705, 2740], [2743, 2800, 2821, 2821, 2885], [2887, 3147, 3169, 3262, 4214], [4218, 4234, 4256, 4256, 4590], [4593, 4925, 4946, 4946, 5172], [5174, 5864, 5884, 6264, 7169], [7172, 7331, 7406, 7932, 10906], [10908, 11061, 11116, 11116, 11182], [11185, 11185, 11225, 11225, 11283], [12274, 12390, 12409, 12409, 25041], [25044, 25044, 25098, 25186, 29165]], "test": "untested"}
{"id": "MtlBW7", "name": "RGB Moiré", "author": "frZ", "description": "simple rgb moiré effect", "tags": ["rgb", "moir", "optic", "graphic"], "likes": 7, "viewed": 3728, "published": "Public API", "date": "1512145495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy *200.;\n    float w = .15+cos(iTime*.5)*.14;\n\tfloat m = step(pow((sin(uv.x+uv.y*.1- iTime*20.8)+1.)*.5,2.2),w);\n\tfloat n = step(pow((sin(uv.x+uv.y*.2+ iTime*20.2)+1.)*.5,2.2),w);\n\tfloat o = step(pow((sin(uv.x+uv.y*.4+ iTime*2.6)+1.)*.5,2.2),w);\n      \n\tfragColor = vec4(m,n,o,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtlBW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 381]], "test": "untested"}
{"id": "MtlBWB", "name": "raymarching ambient occlusion", "author": "glowcoil", "description": "raymarching", "tags": ["raymarching"], "likes": 4, "viewed": 510, "published": "Public", "date": "1513205192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat room(vec3 p, vec3 size) {\n    return min(min(min(p.x, size.x - p.x), min(p.y, size.y - p.y)), min(p.z, size.z - p.z));\n}\n\nvec2 sdf(vec3 p) {\n    float s = min(sphere(p-vec3(.275,.45,0), 0.25), min(sphere(p-vec3(0,0,0), 0.25), sphere(p-vec3(.55,0,0), 0.25)));\n    float r = room(p - vec3(-5, -2.5, -5), vec3(10, 5, 10));\n    if (s < r) {\n        return vec2(s, 0.0);\n    } else {\n        return vec2(r, 1.0);\n    }\n}\n\nfloat ao(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float epsilon = 0.1;\n    \n    vec3 u;\n    if (abs(n.x) < abs(n.y) && abs(n.x) < abs(n.z)) {\n        u = cross(n, vec3(1,0,0));\n    } else if (abs(n.y) < abs(n.z)) {\n        u = cross(n, vec3(0,1,0));\n    } else {\n        u = cross(n, vec3(0,0,1));\n    }\n    vec3 v = cross(n, u);\n    \n    occ += max(sdf(p + epsilon*n).x,0.0);\n    occ += max(sdf(p + epsilon*(u)).x,0.0);\n    occ += max(sdf(p + epsilon*(-u)).x,0.0);\n    occ += max(sdf(p + epsilon*(v)).x,0.0);\n    occ += max(sdf(p + epsilon*(-v)).x,0.0);\n    occ += max(sdf(p + 4.0*epsilon*(n+u)).x/2.0,0.0);\n    occ += max(sdf(p + 4.0*epsilon*(n-u)).x/2.0,0.0);\n    occ += max(sdf(p + 4.0*epsilon*(n+v)).x/2.0,0.0);\n    occ += max(sdf(p + 4.0*epsilon*(n-v)).x/2.0,0.0);\n    occ += max(sdf(p + 2.0*epsilon*n).x/sqrt(2.0),0.0);\n    occ += max(sdf(p + 3.0*epsilon*n).x/sqrt(3.0),0.0);\n    occ += max(sdf(p + 4.0*epsilon*n).x/sqrt(4.0),0.0);\n\n    return clamp(1.0 - 1.0/(1.0+2.0*pow(occ,1.0)), 0.0, 1.0);\n}\n\nvec3 material(float m) {\n    if (m == 0.0) {\n        return vec3(.8, .4, .4);\n    } else {\n        return vec3(.2, .2, .4);\n    }\n}\n\nvec3 normal(vec3 p) {\n    vec3 epsilon = vec3(0.001, 0, 0);\n    return normalize(vec3(\n        sdf(p + epsilon.xyy).x - sdf(p - epsilon.xyy).x,\n        sdf(p + epsilon.yxy).x - sdf(p - epsilon.yxy).x,\n        sdf(p + epsilon.yyx).x - sdf(p - epsilon.yyx).x ));\n}\n\nvec3 ray(vec3 eye, vec3 dir, out int iters) {\n    vec3 p = eye + sdf(eye).x * dir;\n    iters = 0;\n    vec2 d;\n    for (int i = 0; i < 50; i++) {\n        d = sdf(p);\n\n        p += d.x * dir;\n        if (d.x < .001) {\n            break;\n        }\n\n        iters += 1;\n    }\n    \n    vec3 light = normalize(vec3(2.0*cos(2.0*iTime), sin(iTime), 2.0*sin(2.0*iTime)));\n\n    vec3 n = normal(p);\n    vec3 light_dir = normalize(light - p);\n    vec3 mirrored = -normalize(2.0*dot(n,dir)*n - dir);\n    vec3 half_vector = normalize((-dir + light_dir) / 2.0);\n    vec3 brightness = ao(p,n) * (material(d.y) * (0.2 + 0.6 * clamp(.3 + .7 * dot(n, light_dir), 0.0, 1.0)) + vec3(1.0, 1.0, 1.0) * 0.15 * pow(clamp(dot(half_vector, n), 0.0, 1.0), 20.0));\n    return brightness;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int iters;\n\n    vec3 eye = vec3(3.5*cos(iTime), sin(iTime + 1.0), 3.5*sin(iTime));\n    vec3 up = vec3(0,1,0);\n    vec3 forward = normalize(vec3(0,0,.5*sin(iTime)) - eye);\n    vec3 right = cross(forward, up);\n    vec2 pixel = fragCoord.xy / iResolution.x - vec2(.5,.5*iResolution.y/iResolution.x);\n    vec3 dir = forward + (pixel.x * right - pixel.y * up);\n    vec3 color = ray(eye, normalize(dir), iters);\n\n    if (iters > 25) {\n        vec3 dx = .125*right/iResolution.x;\n        vec3 dy = .125*up/iResolution.y;\n        vec3 a = ray(eye, normalize(dir - dx - dy), iters);\n        vec3 b = ray(eye, normalize(dir + dx - dy), iters);\n        vec3 c = ray(eye, normalize(dir + dx + dy), iters);\n        vec3 d = ray(eye, normalize(dir - dx + dy), iters);\n\n        color = mix(mix(a, b, .5), mix(c, d, .5), .5);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtlBWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 59], [61, 61, 92, 92, 187], [189, 189, 207, 207, 482], [484, 484, 510, 510, 1489], [1491, 1491, 1515, 1515, 1622], [1624, 1624, 1645, 1645, 1886], [1888, 1888, 1933, 1933, 2648], [2650, 2650, 2707, 2707, 3564]], "test": "untested"}
{"id": "MtlfRj", "name": "Distance Cells", "author": "doomtaters", "description": "cells with movement, WIP", "tags": ["cells"], "likes": 2, "viewed": 87, "published": "Public", "date": "1512547082", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define c_points 128\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0,1.0);\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nfloat rand1( float x ) {\n    return fract(sin(x*9945.2543)*7239.543);\n}\n\nfloat rand1( int x ) {\n    return rand1( float(x) );\n}\n\nfloat rand2( float x ) {\n    return rand1( x + iTime );\n}\n\nfloat rand2( int x ) {\n    return rand2( float(x) );\n}\n\nfloat distance2( vec2 a, vec2 b ) {\n    float x = a.x-b.x;\n    float y = a.y-b.y;\n    return x*x + y*y;\n}\n\nvec2 translate( vec2 screenSpace ) {\n    return screenSpace/iResolution.y;\n}\n\nvec2 position( int i ) {\n    return vec2( iResolution.x/iResolution.y*rand1(i) + sin((iTime+15.)*rand1(i+99)/5.)/3., rand1(i+999) + cos((iTime+15.)*rand1(i+99)/5.)/3. );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int closest=-1;\n    float dis=999.;\n    \n    for( int i = 0; i < c_points; i++ ) {\n        float distanceToPoint = distance2( position(i), translate(fragCoord) );\n        if( distanceToPoint < dis ) {\n            closest = i;\n            dis = distanceToPoint;\n        }\n    }\n    \n    if( dis<.00001 ) {\n        fragColor = vec4( .4, .8, .4, 1. );\n    } else {\n    \tfragColor = vec4( hsl2rgb(vec3(rand1(closest+1),1.,.5/(dis*256.+1.))), 1. );\n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtlfRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 48, 48, 188], [190, 190, 214, 214, 261], [263, 263, 285, 285, 317], [319, 319, 343, 343, 376], [378, 378, 400, 400, 432], [434, 434, 469, 469, 539], [541, 541, 577, 577, 617], [619, 619, 643, 643, 790], [792, 792, 849, 849, 1305]], "test": "untested"}
{"id": "MtlfRl", "name": "Tunnel Squared", "author": "shau", "description": "a quick variation on my previous tunnel with only one pass and two colours :) Music \"The Tunnel\" by Richie Hawtin", "tags": ["3d"], "likes": 25, "viewed": 689, "published": "Public", "date": "1513256099", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by SHAU - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define EPS 0.002\n#define FAR 40.0 \n#define PI 3.14159265359\n#define T iTime\n#define NTILES 12.0\n\nvec3 ro = vec3(0.0);\nvec4 sphere = vec4(0.0, 0.0, 0.0, 0.3);\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\nfloat rand(vec2 p) {return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);}\n\nvec3 path(float t) {\n    float a = sin(t * PI / 16.0 + 1.5707963 * 1.0);\n    float b = cos(t * PI / 16.0);\n    return vec3(a * 2.0, b * a, t);    \n}\n\nfloat glyphcell(float uvz, float uva, vec2 cellid) {\n    vec2 cuv = vec2(uvz, uva) * 10.0 - 5.0;\n    vec2 cmx = mod(cuv, 1.0) - 0.5;\n    float lc = length(cmx);\n    float r1 = rand(floor(vec2(cuv.x + cellid.y, cuv.y + cellid.x + floor(T)))) > 0.7 ? 1.0 : 0.0;\n    float pc = smoothstep(0.4, 0.3, lc) * r1; \n    pc *= step(cuv.x, 2.0) * step(-2.0, cuv.x);\n    pc *= step(cuv.y, 0.0) * step(-4.0, cuv.y);\n    return pc;\n}\n\n//IQ - Sphere functions\n//http://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    return -b - h;\n}\n\nfloat sphDensity(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer / sph.w;\n    vec3  rc = (ro - sph.xyz) / sph.w;\n\t\n    float b = dot(rd, rc);\n    float c = dot(rc, rc) - 1.0;\n    float h = b*b - c;\n    if (h < 0.0) return 0.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if (t2 < 0.0 || t1 > ndbuffer) return 0.0;\n    t1 = max(t1, 0.0);\n    t2 = min(t2, ndbuffer);\n\n    float i1 = -(c * t1 + b * t1 * t1 + t1 * t1 * t1 / 3.0);\n    float i2 = -(c * t2 + b * t2 * t2 + t2 * t2 * t2 / 3.0);\n    return (i2 - i1) * (3.0 / 4.0);\n}\n\nvec2 nearest(vec2 a, vec2 b){ \n    float s = step(a.x, b.x);\n    return s * a + (1. - s) * b;\n}\n\nvec4 map(vec3 rp) {\n\n    rp.xy -= path(rp.z).xy;      \n\n    rp.xy *= rot(T * 0.5);\n    rp.z += T;\n    \n    vec3 q = rp;\n    \n    float a = atan(q.y, q.x) / 6.2831853;\n    float ia = floor(a * NTILES) / NTILES * 6.2831853;\n\n    vec2 cell = vec2(rp.z, a * NTILES);\n\n    //panels\n    q.xy *= rot(ia);\n    q.z = abs(mod(q.z, 1.0) - 0.5);\n    vec2 panels = vec2(max(length(q.xy) - 1.7, 1.65 - length(q.xy)), 1.0);\n    panels.x = max(panels.x, q.z - 0.25);    \n    panels.x = max(panels.x, q.y - 0.5);\n    \n    //rings\n    q = rp;\n    q.z = abs(mod(q.z + sin(T * 0.4) * 30.0, 80.0) - 40.0);\n    vec2 rings1 = vec2(max(length(q.xy) - 1.5, 1.45 - length(q.xy)), 2.0);\n    rings1.x = max(rings1.x, max(q.z - 0.3, 0.25 - q.z));\n\n    q = rp;\n    q.z = abs(mod(q.z + cos(T * 0.5) * 20.0, 60.0) - 30.0);\n    vec2 rings2 = vec2(max(length(q.xy) - 0.8, 0.75 - length(q.xy)), 2.0);\n    rings2.x = max(rings2.x, max(q.z - 0.3, 0.25 - q.z));\n\n    q = rp;\n    q.z = abs(mod(q.z + sin(T * 0.6) * 15.0, 40.0) - 20.0);\n    vec2 rings3 = vec2(max(length(q.xy) - 0.4, 0.35 - length(q.xy)), 2.0);\n    rings3.x = max(rings3.x, max(q.z - 0.3, 0.25 - q.z));\n\n    return vec4(nearest(panels, nearest(rings1, nearest(rings2, rings3))), cell);\n}\n\nstruct Scene {\n    float t;\n    float id;\n    float li;\n    vec2 cell;\n};\n\nScene march(vec3 ro, vec3 rd) {\n\n    float t = 0.0;\n    float li = 0.0;\n    float id = 0.0;\n    vec2 cell = vec2(0.0);\n    \n    for (int i = 0; i < 96; i++) {\n        vec3 rp = ro + rd * t;\n        vec4 scene = map(rp);\n        if (scene.x < EPS || scene.x > FAR) {\n            id = scene.y;\n            cell = scene.zw;\n            break;\n        }\n        \n        li += 0.005 / (1.0 + scene.x * scene.x * 20.5);\n        \n        t += scene.x;\n    }\n    \n    return Scene(t, id, li, cell);\n}\n\nvoid setupCamera(vec2 fragCoord, inout vec3 rd) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    float ct = T * 6.0;\n\n    vec3 lookAt = vec3(0.0, 0.0, ct);\n    ro = lookAt + vec3(0.0, 0.0, -5.0);\n    sphere.xyz = ro + vec3(0.0, 0.0, sin((T + 80.0) * 0.16) * 80.0);\n    \n    lookAt.xy += path(lookAt.z).xy;\n    ro.xy += path(ro.z).xy;\n    sphere.xy += path(sphere.z).xy;\n    \n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec3 pc = vec3(0.0);\n    float mint = FAR;\n\n    vec3 rd;\n    setupCamera(fragCoord, rd);\n\n    vec3 c1 = vec3(0.0, 1.0, 0.0);\n    vec3 c2 = vec3(0.5, 1.0, 0.0);\n    \n    if (sphere.z < ro.z) {\n        c1 = vec3(1.0, 0.0, 0.0);\n        c2 = vec3(1.0, 0.5, 0.0);\n    }\n    \n    Scene scene = march(ro, rd);\n    if (scene.t > 0.0 && scene.t < FAR) { \n                \n        if (scene.id == 1.0) {\n            vec2 cellid = floor(scene.cell);\n            vec2 celluv = fract(scene.cell);\n\n            float r = rand(cellid);\n\n            if (r > 0.4 && r < 0.8) {\n                pc = c2 * glyphcell(celluv.x, celluv.y, cellid);\n                pc /= scene.t * 0.25;\n            }\n        } else if (scene.id == 2.0 || scene.id == 3.0) {\n            pc = c2;\n        }\n        \n        mint = scene.t;\n    }\n    \n    pc += c1 * scene.li;\n    \n    float st = sphIntersect(ro, rd, sphere);\n    if (st > 0.0 && st < mint) {\n        \n        float h = sphDensity(ro, rd, sphere, mint);\n        if (h > 0.0) {\n            pc = mix(pc, vec3(1.0, 0.0, 0.0), h);\n            pc = mix(pc, 0.85 * vec3(1.0, 0.7, 0.0), h * h * h);   \n        }\n    }\n    \n    fragColor = vec4(sqrt(clamp(pc, 0.0, 1.0)), 1.0);\n}", "image_inputs": [{"id": "lsjXR1", "previewfilepath": "https://soundcloud.com/anoukforza/richie-hawtin-the-tunnel-2005", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/anoukforza/richie-hawtin-the-tunnel-2005", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtlfRl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 330, 349, 349, 395], [396, 396, 416, 416, 478], [480, 480, 500, 500, 628], [630, 630, 682, 682, 1049], [1051, 1152, 1200, 1200, 1391], [1393, 1393, 1454, 1454, 1968], [1970, 1970, 1999, 1999, 2065], [2067, 2067, 2086, 2086, 3281], [3358, 3358, 3389, 3389, 3851], [3853, 3853, 3902, 3902, 4495], [4497, 4497, 4552, 4552, 5758]], "test": "untested"}
{"id": "MtlfRs", "name": "Simple Reflection", "author": "zackpudil", "description": "Nothing new in technique or optimizations.  Was just messing around on and thought it looked nice.", "tags": ["raymarching", "reflection"], "likes": 8, "viewed": 616, "published": "Public", "date": "1513021684", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(vec2 n) {\n\treturn fract(dot(vec2(sin(n.x*2343.34), cos(n.y*30934.0)), vec2(sin(n.y*309392.34), cos(n.x*3991.0))));\n}\n\n// Minkowski operators, can be seen at http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.90.803&rep=rep1&type=pdf\n// It's a paper on generalized distance functions, but it intros on minkowski operators (generalizing them).\nfloat len(vec3 p, float l) {\n\tp = pow(abs(p), vec3(l));\n\treturn pow(p.x + p.y + p.z, 1.0/l);\n}\n\nfloat de(vec3 p) {\n\tvec3 q = p;\n\tvec2 c = floor((p.xz + 3.0)/6.0);\n\t\n\tq.xz = mod(q.xz + 3.0, 6.0) - 3.0;\n\tq.y -= 0.5;\n    // use random value to produce different shape.\n\treturn min(len(q, 1.5 + 9.0*hash(c)) - 1.5, p.y + 1.0);\n}\n\n// basic trace, with some LOD\nfloat trace(vec3 o, vec3 d, float m) {\n\tfloat t = 0.0;\n\tfor(int i = 0; i < 200; i++) {\n\t\tfloat d = de(o + d*t);\n\t\tif(d < (0.001 + 0.0001*t) || t >= m) break;\n\t\tt += d*0.67;\n\t}\n\treturn t;\n}\n\n// basic normal.\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 n = vec3(\n\t\tde(p + h.xyy) - de(p - h.xyy),\n\t\tde(p + h.yxy) - de(p - h.yxy),\n\t\tde(p + h.yyx) - de(p - h.yyx)\n\t);\n\treturn normalize(n);\n}\n\n// slowish ao\nfloat ao(vec3 p, vec3 n) {\n\tfloat o = 0.0, s = 0.005, w = 1.0;\n\t\n\tfor(int i = 0; i < 15; i++) {\n\t\tfloat d = de(p + n*s);\n\t\to += (s - d)*w;\n\t\tw *= 0.98;\n\t\ts += s/float(i + 1);\n\t}\n\t\n\treturn 1.0 - clamp(o, 0.0, 1.0);\n}\n\n//euclidean cameras.\nmat3 camera(vec3 o, vec3 l) {\n\tvec3 w = normalize(l - o);\n\tvec3 u = normalize(cross(vec3(0, 1, 0), w));\n\tvec3 v = normalize(cross(w, u));\n\t\n\treturn mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\t\n\tvec3 ro = vec3(2.7 + cos(iTime*0.3), 0, iTime);\n\tvec3 rd = camera(ro, vec3(2.5 + 0.9*cos(iTime*0.3 + 0.3), 0, iTime + 0.2))*normalize(vec3(p, 1.97));\n\t\n\tvec3 col = vec3(0.45, 0.8, 1.0);\n\tvec3 lig = normalize(vec3(0.8, 0.7, -0.6));\n\t\n\tfor(int i = 0; i < 3; i++) {\n\t\tfloat t = trace(ro, rd, 50.0);\n\t\tif(t < 50.0) {\n\t\t\tvec3 rcol = vec3(0);\n\t\t\t\n            // geometry, hit position, normal, reflect\n\t\t\tvec3 pos = ro + rd*t;\n\t\t\tvec3 nor = normal(pos);\n\t\t\tvec3 ref = reflect(rd, nor);\n\t\t\t\n            // occlusion and shadows\n\t\t\tfloat occ = ao(pos, nor);\n\t\t\tfloat sha = step(5.0, trace(pos + nor*0.001, lig, 5.0));\n\t\t\t\n            // lighting ambient + diffuse + fresnel + specular\n\t\t\trcol += 0.2*occ;\n\t\t\trcol += clamp(dot(lig, nor), 0.0, 1.0)*occ*sha;\n\t\t\trcol += pow(clamp(1.0 + dot(rd, nor), 0.0, 1.0), 2.0)*occ;\n\t\t\trcol += 2.0*pow(clamp(dot(ref, lig), 0.0, 1.0), 30.0)*occ;\n\t\t\t\n            // simple material.\n\t\t\tif(pos.y > -0.99)\n\t\t\t\trcol *= vec3(2.2, 0.7, 0.7);\n\t\t\telse\n\t\t\t\trcol *= 0.3 + 0.7*mod(floor(pos.x) + floor(pos.z), 2.0);\n\t\t\t\n            // set up the ray orgin and direction for reflection.\n\t\t\tro = pos + nor*0.001;\n\t\t\trd = ref;\n\t\t\t\n            // sky fog.\n\t\t\trcol = mix(rcol, vec3(0.45, 0.8, 1.0), 1.0 - exp(-0.1*t));\n\t\t\t\n            // lighten intensity on each successive reflect.\n\t\t\tif(i == 0) col = rcol;            \n\t\t\telse col *= mix(rcol, vec3(1), 1.0 - exp(-0.8*float(i)));\n\t\t}\n\t}\n\t\n    // tone mapping and gamma correction.\n\tcol = 1.0 - exp(-0.5*col);\n\tcol = pow(abs(col), vec3(1.0/2.2));\n\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtlfRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 127], [129, 359, 387, 387, 453], [455, 455, 473, 473, 683], [685, 715, 753, 753, 903], [905, 922, 943, 943, 1113], [1115, 1129, 1155, 1155, 1344], [1346, 1367, 1396, 1396, 1531], [1533, 1533, 1590, 1590, 3192]], "test": "untested"}
{"id": "MtsBDM", "name": "Mandelbulb with DE fade", "author": "sCooZy", "description": "A mandelbulb visualization using distance estimation. I change the exponent value of the equation over time to change the shape.", "tags": ["fractal", "mandelbulb", "distanceestimation"], "likes": 3, "viewed": 172, "published": "Public", "date": "1512211946", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int ITERATIONS = 50;\nconst int MAX_MARCHING_STEPS = 100;\nconst float MIN_DIST = 1.5;\nconst float MAX_DIST = 7.5;\nconst float EPSILON = 0.002;\nconst float ORBIT_TIME = 2.0;\nconst float PI = 3.141592653;\nconst float MIN_POWER = 5.0f;\nconst float MAX_POWER = 8.0f;\nconst float POWER_TIME = 70.0f;\nconst vec3 xDir = vec3(1,0,0);\nconst vec3 yDir = vec3(0,1,0);\nconst vec3 zDir = vec3(0,0,1);\nconst int USE_SPECULAR = 0;\nconst float SHADOW_VISIBILITY = 0.15f;\nconst float ROTATION_TIME = 29.0;\nconst vec3 BACKGROUND_COLOR = vec3(1.0,1.0,1.0);\n\n\nvec3 bulbPower(vec3 z, float power)\n{\n    float r = length(z);\n    // convert to polar coordinates\n\tfloat theta = acos(z.z/r);\n\tfloat phi = atan(z.y,z.x);\n\t\t\n\t// scale and rotate the point\n\tfloat zr = pow(r, power);\n\ttheta = theta * power;\n\tphi = phi * power;\n\t\t\n\t// convert back to cartesian coordinates\n\tz = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n    return z;\n}\n\nfloat DE(vec3 pos) \n{\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    float power = MIN_POWER + (MAX_POWER-MIN_POWER) * (sin(iTime * 2.0 * PI / POWER_TIME) + 1.0) ;\n\tfor (int i = 0; i < ITERATIONS ; i++) {\n\t\tr = length(z);\n\t\tif (r > 2.0) break;\n\t\tdr =  pow( r, power-1.0)*power*dr + 1.0;\n        \n\t\tz = bulbPower(z, power) + pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nvec2 solveQuadratic(float a, float b, float c)\n{\n    float x0,x1;\n    float discr = b * b - 4.0 * a * c;\n    if (discr < 0.0) return vec2(-1.0,-1.0); //dayum this is bad way to do this, but works for this purpose ;)\n    else if (discr == 0.0) x0 = x1 = - 0.5 * b / a;\n    else {\n      \tfloat discrRoot = sqrt(discr);\n        float x0 = (-b + discrRoot) / 2.0 / a;\n        float x1 = (-b - discrRoot) / 2.0 / a;\n        if (x0 > x1) \n           return vec2(x1,x0);\n        else\n           return vec2(x0,x1);\n    }\n}\n\n\n// returns -1 if there is no intersection\nfloat eyeRayToSphereDistance(vec3 rayOrigin, vec3 rayDirection, vec3 sphereOrigin, float sphereRadius)\n{\n    vec3 L = rayOrigin - sphereOrigin;\n\tfloat a = dot(rayDirection, rayDirection);\n\tfloat b = 2.0 * dot(rayDirection, L);\n\tfloat c = dot(L, L) - sphereRadius * sphereRadius;\n\tvec2 results = solveQuadratic(a, b, c);\n    return results.x;\n    \n}\n\n\n/*\nvec3 gradient;\nint last = 0;\nfloat escapeLength(in vec3 pos)\n{\n\tvec3 z = pos;\n\tfor( int i=1; i<ITERATIONS; i++ )\n\t{\n\t\tz = bulbPower(z, POWER) + pos;\n\t\tfloat r2 = dot(z,z);\n\t\tif ((r2 > 4.0 && last==0) || (i==last))\n\t\t{\n\t\t\tlast = i;\n\t\t\treturn length(z);\n\t\t}\n\t}\t\n\treturn length(z);\n}\n \nfloat gradientDE(vec3 p) {\n\tlast = 0;\n\tfloat r = escapeLength(p);\n\tif (r*r < 2.0) return 0.0;\n\tgradient = (vec3(escapeLength(p+xDir*EPSILON), escapeLength(p+yDir*EPSILON), escapeLength(p+zDir*EPSILON))-r)/EPSILON;\n\treturn 0.5*r*log(r)/length(gradient);\n}\n*/\n\n\n/**\n * returns the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * end is returned\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the eye to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = DE(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * returns the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n/**\n * using the gradient of the DE, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        DE(vec3(p.x + EPSILON, p.y, p.z)) - DE(vec3(p.x - EPSILON, p.y, p.z)),\n        DE(vec3(p.x, p.y + EPSILON, p.z)) - DE(vec3(p.x, p.y - EPSILON, p.z)),\n        DE(vec3(p.x, p.y, p.z  + EPSILON)) - DE(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * calculates ighting contribution for a single point light source via Phong illumination.\n * \n * the vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) \n{\n\tvec3 color;\n    \n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    float dotLN = dot(L, N);\n    if (dotLN < 0.0) {\n        // light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    else\n    {\n        if (USE_SPECULAR == 1)\n        {\n            vec3 V = normalize(eye - p);\n            vec3 R = normalize(reflect(-L, N));\n            float dotRV = dot(R, V);\n            //vec3 H = normalize(L * V);\n            //float dotNH = dot(N, H);\n            if (dotRV < 0.0) \n            {\n                // light reflection in opposite direction as viewer, apply only diffuse\n                // component\n                color = lightIntensity * (k_d * dotLN);\n            }\n            else\n                color = lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n        }\n        else\n        {\n            color = lightIntensity * (k_d * dotLN);\n        }\n        \n        vec3 lightToPos = p - lightPos;\n        float maxDist = length(lightToPos);\n        float dist = shortestDistanceToSurface(lightPos, normalize(lightToPos), 0.0f, maxDist);\n        if (dist <= maxDist - EPSILON) \n        {\n            // hit something between light source and point -> shadow\n        \treturn color * SHADOW_VISIBILITY; //\n    \t}\n    }\n    return color;\n}\n\n/**\n * lighting via Phong illumination.\n * \n * the vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color of the surface\n * k_d: Diffuse color of the surface\n * k_s: Specular color of the surface\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(2.5*sin(iTime * 2.0 * PI / ROTATION_TIME), 2.0, 3.0*cos(iTime * 2.0 * PI / ROTATION_TIME));\n    vec3 light1Intensity = vec3(1, 1, 1);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n\n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvec4 getBackgroundColor(vec2 fragCoord)\n{\n\tfloat strength = length((fragCoord - iResolution.xy / 2.0) / iResolution.xy);\n\treturn vec4(BACKGROUND_COLOR - BACKGROUND_COLOR * 2.0 / 3.0 * strength,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(4.5*sin(iTime * 2.0 * PI / ROTATION_TIME), (sin(iTime * 2.0 * PI / ROTATION_TIME) + 1.0), 6.0*cos(iTime * 2.0 * PI / ROTATION_TIME));\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float distanceToBoundingSphere = eyeRayToSphereDistance(eye, worldDir, vec3(0,0,0), 1.2);\n    if(distanceToBoundingSphere  == -1.0)\n    {\n\t\tfragColor = getBackgroundColor(fragCoord);\t\n        return;\n    }\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, distanceToBoundingSphere, distanceToBoundingSphere + 2.4);\n    \n    if (dist > distanceToBoundingSphere + 2.4 - EPSILON) \n       {\n        // Didn't hit anything\n        fragColor = getBackgroundColor(fragCoord);\n        return;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    float distance = length(p);\n    float scale = (distance - 0.5) * 1.2;\n    vec3 K_a = vec3(0.7 - 0.4 * scale, 0.24 - 0.14 * scale, 0.0) / 2.0;\n    vec3 K_d = K_a * 2.8;\n    vec3 K_s = K_a * 2.0;\n    float shininess = 50.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtsBDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[545, 545, 582, 582, 939], [941, 941, 962, 962, 1304], [1306, 1306, 1354, 1354, 1821], [1824, 1866, 1970, 1970, 2214], [2763, 3190, 3281, 3281, 3581], [3596, 3851, 3916, 3916, 4048], [4051, 4139, 4168, 4168, 4442], [4444, 4872, 5013, 5013, 6331], [6333, 6673, 6758, 6758, 7204], [7206, 7533, 7582, 7617, 7843], [7845, 7845, 7886, 7886, 8045], [8047, 8047, 8104, 8104, 9434]], "test": "untested"}
{"id": "MtsBR2", "name": "GooeyVignette", "author": "Del", "description": "goo", "tags": ["goo"], "likes": 6, "viewed": 98, "published": "Public", "date": "1512569980", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// um, some kind of mystical hole...?\n\nfloat glint(vec2 p)\n{\n    vec2 uv = p;\n    float speed = 0.68;\n    float linewidth = 1.38;\n    float grad = 3.0;\n    vec2 linepos = uv;\n    linepos.x = linepos.x - mod(iTime*speed,4.0)+2.0;\n    float y = linepos.x*grad;\n\tfloat s = smoothstep( y-linewidth, y, linepos.y) - smoothstep( y, y+linewidth, linepos.y); \n    return s;\n}\n\nfloat _glint(vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float speed = iTime*0.2;\n \tfloat d = 1.0+p.x*0.25;\n    vec2 cst = vec2( cos(d+speed), sin(d+speed) );\n    float zoom = 1.0+(0.5*sin(iTime*0.675));\n    mat2 rot = zoom * mat2(cst.x,-cst.y,cst.y,cst.x);\n    float s = glint(p*rot*0.44);\n    return s;\n}\n\nvoid mainImage(out vec4 k, vec2 p)\n{\n    const vec4 col1 = vec4(0.0,.1,.1,1.0);\n    const vec4 col2 = vec4(0.5,0.9,0.3,1.0);\n    vec2 uv = p.xy / iResolution.xy;\n\tfloat gl = _glint(p)*0.5;\n    \n    float s = sin(iTime*0.1);\n    float s2 = 0.5+sin(iTime*1.8);\n    vec2 d = uv*(4.0+s*.3);\t\t\t\t\t\t// mod 4.0 for irregularity...\n    \n    d.x += iTime*0.25+sin(d.x+d.y + iTime*0.3)*0.5;\n    d.y += iTime*0.25+sin(d.x + iTime*0.3)*0.5;\t//-(s*0.5);\n    float v1=length(0.5-fract(d.xy))+0.95;\t\t\t\t// 0.9 =more gooey bits, 1.2 = less gooey bits\n\n    d = 0.15+(uv*0.7);\t\t\t// zoom\n    float v2=length(0.5-fract(d.xy));\n    v1 *= 1.0-v2*v1;\n    v1 = v1*v1*v1;\n    v1 *= 1.9+s2*0.2;\n    k = mix(col2,col1,v1)*(3.4+(s2*0.2));\n    k *= 1.0-(v2);\n    \n    \n    if (k.g<=0.4)\n    {\n        float m = 1.0-clamp(k.g,0.0,0.5);\n\t\tfloat f = mod( floor(12.0*uv.x) + floor(12.0*uv.y), 2.0);\n        float col = 0.3 + 0.5*f*1.0;\n        k.x = k.y = k.z = col*m;\n    }\n    else\n    {\n\t\tfloat f = mod( floor(12.0*uv.x) + floor(12.0*uv.y), 2.0);\n        vec4 _col = 0.2*f*vec4(0.175);\n        k+=_col;\n    }\n    // glint\n    k *=vec4(1.0+gl);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtsBR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 60, 60, 367], [369, 369, 400, 400, 721], [723, 723, 759, 759, 1841]], "test": "untested"}
{"id": "MtsBWX", "name": "Golden Dolphin", "author": "dr2", "description": "Another \"egg\" (no.3)", "tags": ["reflect", "egg", "shell", "gliier"], "likes": 8, "viewed": 535, "published": "Public API", "date": "1513700444", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Golden Dolphin\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrEllips2Df (vec3 p, vec2 r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, qHit;\nvec2 opCs;\nfloat tCur, dstFar, opPhs, fishAngI;\nint idObj;\nconst float pi = 3.14159;\n\nfloat FishDf (vec3 p)\n{\n  vec3 q;\n  float dMin, dBodyF, dBodyB, dMouth, dFinT, dFinP, dFinD, dEye, d, szFac;\n  szFac = 0.6;\n  p /= szFac;\n  p.x = abs (p.x);\n  p.z -= 2.;\n  p.yz = Rot2D (p.yz, 0.2 * fishAngI);\n  q = p;\n  q.z -= -0.6;\n  dBodyF = PrEllipsDf (q, vec3 (0.7, 0.8, 2.4));\n  q = p;\n  q.z -= -1.2;\n  q.yz = Rot2D (q.yz, fishAngI);\n  q.z -= -1.6;\n  dBodyB = PrEllipsDf (q, vec3 (0.35, 0.5, 2.5));\n  q.z -= -2.2;\n  q.yz = Rot2D (q.yz, 2. * fishAngI);\n  q.xz -= vec2 (0.5, -0.5);\n  q.xz = Rot2D (q.xz, 0.4);\n  dFinT = PrEllipsDf (q, vec3 (0.8, 0.07, 0.4));\n  q = p;\n  q.yz -= vec2 (-0.3, 1.7);\n  q.yz = Rot2D (q.yz, 0.1);\n  q.y = abs (q.y) - 0.04;\n  dMouth = PrEllipsDf (q, vec3 (0.25, 0.12, 0.6));\n  q = p;\n  q.yz -= vec2 (0.7, -1.);\n  q.yz = Rot2D (q.yz, 0.6);\n  dFinD = PrEllipsDf (q, vec3 (0.05, 1., 0.35));\n  q = p;\n  q.xy = Rot2D (q.xy, 0.8);\n  q.xz -= vec2 (0.7, -0.1);\n  q.xz = Rot2D (q.xz, 0.6);\n  dFinP = PrEllipsDf (q, vec3 (0.9, 0.04, 0.3));\n  q = p;\n  q -= vec3 (0.4, -0.1, 1.1);\n  dEye = PrEllipsDf (q, vec3 (0.11, 0.15, 0.15));\n  idObj = 1;\n  qHit = q;\n  dMin = SmoothMin (dBodyF, dBodyB, 0.3);\n  dMin = SmoothMin (dMin, dFinT, 0.1);\n  dMin = SmoothMin (dMin, dMouth, 0.15);\n  dMin = SmoothMin (dMin, dFinD, 0.02);\n  dMin = SmoothMin (dMin, dFinP, 0.02);\n  if (dEye < dMin) { idObj = 2;  qHit = q; }\n  dMin = SmoothMin (dMin, dEye, 0.01);\n  return dMin * szFac;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qHitA;\n  float dMin, d, r, radH, radV, w;\n  int idObjA;\n  dMin = dstFar;\n  radH = 4.;\n  radV = 3.;\n  w = 0.1;\n  q = p;  q.z += radH;\n  d = PrCapsDf (q.yzx, 0.25, 0.95);\n  if (d < dMin) { dMin = d;  idObj = 4;  qHit = q; };\n  q.yz = Rot2Cs (q.yz, opCs);\n  q.y = abs (q.y);\n  q.yz = Rot2Cs (q.yz, opCs);\n  q.z -= radH;\n  r = radH + 0.1 * (1. - q.y / length (q)) * cos (32. * atan (q.x, q.z));\n  d = max (PrEllips2Df (q.xzy, vec2 (r, radV) + w), - PrEllips2Df (q.xzy, vec2 (r, radV) - w));\n  d = max (d, - q.y);\n  if (d < dMin) { dMin = d;  idObj = 3;  qHit = q; };\n  idObjA = idObj;\n  qHitA = qHit;\n  q = p;  q.y -= -0.5 + 2. * opPhs;\n  q.xz = Rot2D (q.xz, 0.1 * pi * tCur);\n  d = FishDf (q);\n  if (d < dMin) { dMin = d;  idObjA = idObj;  qHitA = qHit; }\n  idObj = idObjA;\n  qHit = qHitA;\n  q = p;  q.y -= -radV + 1.5 + 2. * opPhs;\n  d = PrCylDf (q.xzy, 2.3, 0.1);\n  if (d < dMin) { dMin = d;  idObj = 5;  qHit = q; };\n  q = p;  q.y -= -0.5 * (radV - 2. * opPhs);\n  d = PrCylDf (q.xzy, 0.05, 0.5 * (radV - 0.5 + 2. * opPhs));\n  q = p;  q.y -= - radV + 0.1;\n  d = min (d, PrCylDf (q.xzy, 0.5, 0.05));\n  if (d < dMin) { dMin = d;  idObj = 6; };\n  return 0.9 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0005, -0.0005);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, s;\n  bool isLit, isRefl;\n  opPhs = 0.9 * SmoothBump (0.2, 0.8, 0.15, mod (0.2 * tCur, 1.));\n  opCs = vec2 (cos (0.25 * pi * opPhs), sin (0.25 * pi * opPhs));\n  fishAngI = 0.15 * sin (pi * tCur);\n  isRefl = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar && idObj == 5 && qHit.y > 0. && length (qHit.xz) < 2.25) {\n    ro += dstObj * rd;\n    rd = reflect (rd, vec3 (0., 1., 0.));\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n    isRefl = true;\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    isLit = false;\n    if (idObj == 1) {\n      col = 1.2 * vec3 (0.8, 0.75, 0.2) * (1. - 0.2 * smoothstep (-0.5, -0.4, vn.y));\n    } else if (idObj == 2) {\n      if (length (qHit.yz - vec2 (-0.02, 0.05)) < 0.05) {\n        col = vec3 (1., 0.1, 0.1);\n        isLit = true;\n      } else col = vec3 (0.4, 0.7, 0.2);\n    } else if (idObj == 3) {\n      s = length (qHit / vec3 (4., 3., 4.));\n      col = (s > 1. || qHit.y < 0.05) ? vec3 (0.8, 0.75, 0.2) :\n         mix (vec3 (0.7, 0.7, 0.9), vec3 (0.2, 0.2, 0.8), smoothstep (0.5, 1.5, 3. - qHit.y) *\n         smoothstep (0.96, 0.98, s));\n      if (s > 1.) vn = VaryNf (64. * qHit, vn, 0.5);\n    } else if (idObj == 4) {\n      col = vec3 (0.8, 0.75, 0.2) * (1. - 0.5 * SmoothBump (0.05, 0.1, 0.02, mod (4. * qHit.x, 1.)));\n    } else if (idObj == 5 || idObj == 6) {\n      col = vec3 (0.8, 0.75, 0.2);\n    }\n    if (! isLit) col = col * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.1 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 128.);\n    else col *= (0.5 - 0.5 * dot (rd, vn));\n    if (! isRefl && (idObj == 1 || idObj == 3 && s > 1.)) col += 256. * pow (clamp (0.5 +\n       0.5 * dot (ltDir, reflect (rd, vn)), 0., 1.), 16.) *\n       pow (1. - 0.6 * abs (dot (normalize (ltDir - rd), VaryNf (1024. * qHit, vn, 2.))), 8.);\n  } else {\n    col = vec3 (0.6, 0.6, 1.) * (0.05 + 0.245 * (rd.y + 1.) * (rd.y + 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = pi;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.6 * pi * (2. * mod (floor (0.04 * tCur), 2.) - 1.) *\n       SmoothBump (0.25, 0.65, 0.1, mod (0.04 * tCur, 1.));\n    el -= 0.05 * pi * sin (0.05 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 2.8, -30.);\n  rd = vuMat * normalize (vec3 (uv, 4.5));\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrEllips2Df (vec3 p, vec2 r)\n{\n  return (length (p / r.xxy) - 1.) * min (r.x, r.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtsBWX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 585, 608, 608, 1968], [1970, 1970, 1992, 1992, 3166], [3168, 3168, 3201, 3201, 3378], [3380, 3380, 3401, 3401, 3601], [3603, 3603, 3638, 3638, 5603], [5605, 5605, 5658, 5658, 6582], [6584, 6584, 6626, 6626, 6677], [6679, 6679, 6722, 6722, 6795], [6797, 6797, 6832, 6832, 6894], [6896, 6896, 6932, 6932, 6987], [6989, 6989, 7034, 7034, 7137], [7139, 7139, 7196, 7196, 7279], [7281, 7281, 7311, 7311, 7369], [7371, 7371, 7402, 7402, 7466], [7500, 7500, 7524, 7524, 7654], [7656, 7656, 7681, 7681, 7867], [7869, 7869, 7898, 7898, 8110], [8112, 8112, 8151, 8151, 8335]], "test": "untested"}
{"id": "MtsBzj", "name": "Bulby star", "author": "Ultraviolet", "description": "A simple star made of circles.\nMove mouse along x for branch depth, along y for # of branches.", "tags": ["star"], "likes": 15, "viewed": 151, "published": "Public", "date": "1512563976", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415972\n\nfloat d(vec2 uv)\n{\n    float theta = atan(uv.y, uv.x) + iTime * 0.1;\n    float rho = length(uv);\n    \n    //float period = 2.*PI/5.;\n    float period = 2.*PI/floor(iMouse.y/iResolution.y*8.+2.);\n    if(iMouse.y < 0.5)\n        period = 2.*PI/5.;\n    \n    theta = mod(theta, period);\n    theta = min(theta, period-theta);\n    \n    vec2 p = vec2(cos(theta), sin(theta)) * rho;\n    \n    \n    //float alpha = PI*0.3;\n    float alpha = iMouse.x/iResolution.x * ((PI-period*0.5)-asin(.5)) + asin(.5);\n    if(iMouse.x < 0.5)\n        alpha = 0.5*(1.0+sin(iTime)) * ((PI-period*0.5)-asin(.5)) + asin(.5);\n    \n    float x = 2.*sin(alpha)/(sin(period*.5)+2.*sin(alpha+period*.5));\n    float rad = sin(period*.5)/(sin(period*.5)+2.*sin(alpha+period*.5));\n    \n    //float h0 = 1.-rad-rad*cos(alpha);\n    //float h1 = rad*sin(alpha);\n    //float xl = sqrt(h0*h0+h1*h1);\n    \n    float dist = rad-length(p-vec2(1.0-rad, 0.0));\n    \n    if(cross(vec3(p,0.)-vec3(1.-rad, 0., 0.), vec3(x*cos(.5*period), x*sin(.5*period),0.)-vec3(1.-rad, 0., 0.)).z < 0.)\n       dist = max(dist, length(p-x*vec2(cos(.5*period), sin(.5*period)))-rad);\n    \n    return dist;\n}\n\nvec3 n(vec2 uv)\n{\n    vec2 l = vec2(0.02, 0.0);\n    //vec2 l = vec2(0.2, 0.0);\n    return normalize(vec3(d(uv+l.xy)-d(uv-l.xy), d(uv+l.yx)-d(uv-l.yx), l.x*5.));\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0*(fragCoord.xy / min(iResolution.x,iResolution.y) - 0.5*iResolution.xy/ min(iResolution.x,iResolution.y));\n\t\n    float dist = d(uv);\n    vec3 col =  vec3(dist>0.0?0.0:1.0, 0., dist<0.0?0.0:1.0);\n    float stripes = 0.5*(1.0-cos(dist*iResolution.x/3.));\n    stripes = (stripes+2.0)/3.;\n    float contour = 0.5*(1.0-cos(clamp(dist*iResolution.x/3., -PI, PI)));\n    \n    fragColor = vec4(col * stripes *contour, 1.0);\n    //fragColor = vec4(col*contour, 1.0);\n    //fragColor = vec4(contour);\n    \n    \n    \n    //vec3 n = normalize(vec3(dFdx(dist), dFdy(dist), .01));\n    vec3 n = n(uv);\n    vec3 l = normalize(vec3(cos(iTime*.1), sin(iTime*.1), 1.1));\n    float phong = max(dot(n,l), 0.0);\n    \n    float spec = 0.5*pow(max(dot(reflect(vec3(0.0, 0.0, -1.0),n),l), 0.0), 256.);\n    fragColor = vec4((col * phong+ vec3(spec)) * stripes *contour , 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtsBzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 40, 40, 1162], [1164, 1164, 1181, 1181, 1326], [1333, 1333, 1390, 1390, 2261]], "test": "untested"}
{"id": "MtsfD7", "name": "warp vortex", "author": "laserdog", "description": "inspired by nuclear throne's title/transition screen. decently happy with result, but didn't achieve the target effect (https://www.youtube.com/watch?v=p0Q_MoMsKlI). probably need to try a different approach...", "tags": ["tunnel"], "likes": 27, "viewed": 681, "published": "Public", "date": "1512164676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi  3.14159\n\n// from iq\nfloat expStep( float x, float k, float n ){\n    return exp( -k*pow(x,n) );\n}\n\nmat2 rot(float rads)\n{\n    return mat2(cos(rads), sin(rads), -sin(rads), cos(rads));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    p = rot(iTime * 1.25) * p;\n    p = vec2(p.x, -p.y) + .15;\n    \n    float r = length(p);\n    float a = atan(p.y, p.x);\n    a += 2. * sin(a);\n    float coord = fract(a / pi + expStep(r, 1., .5) * 8. + 1.6 * iTime);\n    vec3 col = mix(vec3(.17, 0., .25), vec3(.3, 0., .5), step(.6, coord));\n    \n    col *= pow(r, .65) * 1.75;\n    fragColor.rgb = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtsfD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 32, 75, 75, 108], [110, 110, 132, 132, 196], [198, 198, 255, 255, 677]], "test": "untested"}
{"id": "MtSfR1", "name": "pattern03", "author": "edapx", "description": "patterns, daisy", "tags": ["patterns"], "likes": 1, "viewed": 75, "published": "Public", "date": "1514726801", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\nmat2 rotateMatrix2D(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    mat2 rot = rotateMatrix2D(_angle);\n    _st =  rot * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvec2 tile(vec2 _st, float _zoom){\n    _st *= _zoom;\n    return fract(_st);\n}\n\nvec3 daisy(vec2 st, vec2 orig, float resize, float smoothness, float nPale){\n    vec2 toCenter = vec2(orig)-st;\n    float angle = atan(toCenter.y,toCenter.x);\n    float radius = length(toCenter)*resize;\n\n    float f = abs(cos(angle*nPale));\n    return vec3( 1.-smoothstep(f,f+smoothness,radius) );;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 colorA = vec3(0.149,0.141,0.912);\n    vec3 colorB = vec3(1.000,0.833,0.224);\n    \n    vec2 st = fragCoord/iResolution.y;\n    vec2 originalSt = st;\n\n    // Divide the space\n    st = tile(st,3.);\n    st = rotate2D(st,(sin(iTime)*PI/16.0) );\n    vec2 rotDaisyA = rotate2D(st,(sin(iTime)*PI/16.0) );\n    \n    // divide the space again\n    st = tile(st,2.);\n    vec2 rotDaisyB = rotate2D(st,(fract(iTime)) );\n\n    // Draw a square\n    //color = vec3(box(st,vec2(0.7),0.01));\n    colorA *= daisy(rotDaisyA, vec2(0.5), -abs(sin(iTime)*PI/2.0)+2.3, 1.9, 8.0);\n    colorB *= daisy(rotDaisyB, vec2(0.5), (abs(sin(iTime)) + 2.0)*7.0, 2.9, 3.0);\n    fragColor = vec4((colorA+colorB),1.0);    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtSfR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 69, 69, 155], [157, 157, 195, 195, 306], [308, 308, 341, 341, 384], [386, 386, 462, 462, 686], [689, 689, 746, 746, 1443]], "test": "untested"}
{"id": "MtsfRl", "name": "Books and Stairs 2", "author": "dr2", "description": "Open-plan library (mouseable, click in right upper/lower corners for other views)", "tags": ["stairs", "library", "cellmarching"], "likes": 14, "viewed": 516, "published": "Public API", "date": "1512991264", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Books and Stairs 2\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\nfloat RgbToVal (vec3 c);\nfloat Hashfv2 (vec2 p);\nfloat Hashfv3 (vec3 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\n\nvec3 bSize, qHit, ltPos, cId;\nfloat tCur, dstFar, stepCnt;\nint idObj;\nbool colImg, marchImg;\nconst float pi = 3.14159;\nconst int idFlr = 1, idCol = 2, idRail = 3, idStr = 4, idShlf = 5, idBk = 6, idLt = 7;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qr;\n  float dMin, d, stAng, r, a, s;\n  dMin = dstFar;\n  r = length (p.xz);\n  stAng = 0.5 * pi * floor (4. * Hashfv2 (cId.xz));\n  q = p;  q.y = 0.5 * bSize.y - 0.3 - abs (p.y);\n  d = max (q.y, 9.8 - r);\n  DMINQ (idFlr);\n  q.xz = abs (q.xz) - 15.;\n  q.y -= 0.1;\n  d = min (length (q.xz) - 0.6, PrCylDf (q.xzy, 1., 0.1));\n  DMIN (idCol);\n  qr = p;\n  qr.xz = Rot2D (qr.xz, stAng);\n  q = qr;\n  d = length (vec2 (r - 10.2, abs (q.y + 6.) - 1.3)) - 0.13;\n  d = max (d, 2. - abs (qr.z));\n  d = min (d, PrCylDf (vec3 (abs (q.x) - 10., q.y + 7.1, abs (q.z) - 2.).xzy, 0.25, 2.8));\n  q.xz = Rot2D (q.xz, 2. * pi / 32.);\n  a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (16. * a + 0.5) / 16.));\n  d = min (d, PrCylDf ((q + vec3 (10.2, + 7.2, 0.)).xzy, 0.13, 2.5));\n  q = qr;\n  q.xy = Rot2Cs (q.xy, vec2 (sqrt (0.5)));\n  d = min (d, max (length (vec2 (abs (q.y - 2.9) - 0.9, abs (q.z) - 2.)) - 0.13, abs (qr.x) - 10. ));\n  q = qr;  q.x += 20.;\n  q.xy = Rot2D (q.xy, 0.25 * pi);\n  d = min (d, max (length (vec2 (abs (q.y - 2.9) - 0.9, abs (q.z) - 2.)) - 0.13, abs (qr.x) - 10.));\n  DMIN (idRail);\n  q = qr;\n  q.xy = Rot2Cs (q.xy - vec2 (10., -10.), vec2 (sqrt (0.5)));\n  s = mod (q.x, 1. * sqrt (2.));\n  d = 0.5 * max (max (q.y - min (s, 1. * sqrt (2.) - s), abs (q.z) - 2.), -0.2 - q.y);\n  DMINQ (idStr);\n  q = p;  q.y -= -6.7;\n  s = min (abs (q.x), abs (q.z));\n  d = max (max (max (abs (r - 17.) - 1., abs (q.y) - 3.), 5. - s),\n     - max (max (abs (r - 16.) - 1.5, abs (abs (q.y) - 1.4) - 1.2), 5.5 - s));\n  DMINQ (idShlf);\n  d = max (max (abs (r - 17.) - 0.5, abs (q.y) - 2.8), 5.2 - s);\n  DMINQ (idBk);\n  q = p;  q.y -= 9.5;\n  d = length (vec2 (r - 11., q.y)) - 0.2;\n  q.xz = abs (q.xz) - 0.5 * bSize.xz;\n  d = min (d, PrCylDf (q.xzy, 2., 0.2));\n  DMIN (idLt);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi, s;\n  float dHit, d, eps;\n  eps = 0.0005;\n  dHit = eps;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  ro /= bSize;\n  rd /= bSize;\n  rdi = 1. / rd;\n  stepCnt = 0.;\n  for (int j = 0; j < 330; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p);\n    s = (cId + step (0., rd) - p) * rdi;\n    d = min (ObjDf (bSize * (p - (cId + 0.5))), abs (min (min (s.x, s.z), s.y)) + eps);\n    dHit += d;\n    ++ stepCnt;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0005, -0.0005);\n  cId = floor (p / bSize);\n  p -= bSize * (cId + 0.5);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float ltDist)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 60; j ++) {\n    p = ro + d * rd;\n    cId = floor (p / bSize);\n    h = ObjDf (p - bSize * (cId + 0.5));\n    sh = min (sh, smoothstep (0., 0.08 * d, h));\n    d += clamp (h, 0.15, 0.3);\n    if (sh < 0.05 || d > ltDist) break;\n  }\n  return sh;\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float ao, d;\n  ao = 0.;\n  for (int j = 0; j < 8; j ++) {\n    d = 0.1 + float (j) / 16.;\n    p = ro + d * rd;\n    cId = floor (p / bSize);\n    ao += max (0., d - 3. * ObjDf (p - bSize * (cId + 0.5)));\n  }\n  return 0.5 + 0.5 * clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 col, bgCol, ltVec, roo, vn;\n  vec2 vf, bt;\n  float dstObj, ltDist, sh, ao, atten, r, s, a;\n  bgCol = mix (0.9 * vec3 (0.2, 0.4, 0.5), vec3 (0.4) * (1. - 0.05 * Noisefv2 (512. * abs (rd.xy))),\n     smoothstep (-0.01, 0.01, rd.y)) * 1.2 / (1. + 0.002 * pow (dstFar, 1.5));\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vf = vec2 (0.);\n    if (idObj == idFlr || idObj == idShlf || idObj == idBk) {\n      r = length (qHit.xz);\n      a = (r > 0.) ? atan (qHit.z, - qHit.x) / pi + 0.5 : 0.;\n    }\n    if (idObj == idFlr) {\n      if (vn.y > 0.99) {\n        objCol = vec4 (0.2, 0.4, 0.5, 0.1) * (1. - 0.3 * Fbm2 (2. * ro.xz)) *\n           (0.5 + 0.5 * SmoothBump (0.03, 0.97, 0.01, mod (r, 1.)));\n        objCol.rgb *= ((1. - 0.3 * smoothstep (1., 5., length (abs (qHit.xz) - 20.))) +\n           (1. - 0.3 * smoothstep (1., 5., r - 11.)));\n        vf = vec2 (32., 1.);\n      } else if (vn.y < -0.99) {\n        objCol = vec4 (vec3 (0.8) * (1. - 0.4 * smoothstep (3., 7., length (abs (qHit.xz) - 20.))) *\n           (1. - 0.4 * smoothstep (0., 4., r - 11.)), -1.);\n      } else {\n        objCol = vec4 (0.3, 0.3, 0.7, 0.1);\n        vf = vec2 (32., 1.);\n      }\n    } else if (idObj == idCol) {\n      objCol = vec4 (0.8, 0.8, 0.85, 0.05);\n      vf = vec2 (32., 1.);\n    } else if (idObj == idRail) {\n      objCol = vec4 (0.8, 0.8, 0.85, 0.2);\n      vf = vec2 (32., 0.2);\n    } else if (idObj == idStr) {\n      if (abs (qHit.z) > 1.9) {\n        objCol = vec4 (0.5, 0.55, 0.5, 0.1);\n        vf = vec2 (32., 0.2);\n      } else if (vn.y > -0.01) {\n        objCol = vec4 (0.2, 0.4, 0.5, 0.1) * (1. - 0.2 * Fbm2 (2. * ro.xz));\n        vf = vec2 (32., 0.2);\n      } else {\n        objCol = vec4 (0.6, 0.6, 0.6, -1.);\n      }\n    } else if (idObj == idShlf) {\n      objCol = vec4 (vec3 (0.7, 0.4, 0.2) * (0.5 + 0.5 * Fbm2 ((r > 17.99) ? vec2 (128. * a, 0.5 * qHit.y) :\n         ((abs (vn.y) < 0.01) ? vec2 (4. * r, 0.5 * qHit.y) : vec2 (32. * a, 4. * r)))), 0.1);\n      vf = vec2 (32., 0.1);\n      a = mod (4. * a + 0.5, 1.) - 0.5;\n      if (r > 17.99 && abs (a) < 0.07 && abs (qHit.y - 2.2) < 0.4) {\n        cId = floor (ro / bSize);\n        if (ShowInt (vec2 (- 10. * a - 0.5, 0.8 * (qHit.y - 2.)), vec2 (1., 0.25), 4.,\n           dot (mod (vec2 (66., 60.) + cId.xz, 100.), vec2 (100., 1.))) != 0.) \n           objCol = vec4 (0.2, 1., 0.2, -1.);\n      }\n    } else if (idObj == idBk) {\n      cId = floor (ro / bSize);\n      a *= 128.;\n      bt = floor (vec2 (16. * a, 16. * qHit.y));\n      s = Hashfv2 (vec2 (floor (a), 1. + floor (qHit.y / 2.8)));\n      qHit.y = mod (qHit.y / 2.8, 1.) / (0.95 - 0.3 * s);\n      if (qHit.y < 1.) {\n        a = mod (a, 1.);\n        objCol = vec4 (HsvToRgb (vec3 (mod (Hashfv3 (cId) + 0.2 * s, 1.), 1.,\n           0.7 * (0.5 + 0.5 * SmoothBump (0.05, 0.95, 0.02, a)))), 0.1);\n        objCol.rgb = mix (mix (objCol.rgb, vec3 (0.9, 0.9, 0.3), SmoothBump (0.2, 0.25, 0.01, qHit.y)),\n           vec3 (1., 1., 0.2), step (abs (qHit.y - 0.5), 0.15) *\n           step (abs (a - 0.5), 0.25) * step (0.5, Noisefv2 (cId.xz * vec2 (19., 31.) + bt)));\n        vn.xz = Rot2D (vn.xz, 0.5 * pi * (a - 0.5));\n      } else {\n        objCol = vec4 (0.02, 0.01, 0., -1.);\n      }\n    } else if (idObj == idLt) {\n      objCol = vec4 (vec3 (1., 1., 0.8) * (0.8 - 0.3 * vn.y), -1.);\n    }\n    ltVec = roo + ltPos - ro;\n    ltDist = length (ltVec);\n    atten = 1.2 / (1. + 0.002 * pow (ltDist, 1.5));\n    ltVec /= ltDist;\n    sh = 1.;\n    ao = 1.;\n    if (idObj != idBk) {\n      sh = 1. - 0.8 * (1. - ObjSShadow (ro, ltVec, ltDist)) * min (0.3 * atten, 1.);\n      ao = ObjAO (ro, vn);\n    }\n    if (objCol.a >= 0.) {\n      if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n      col = 0.2 * objCol.rgb;\n      if (idObj == idBk) col += 0.3 * objCol.rgb * (0.6 - 0.4 * dot (normalize (vn.xz), normalize (qHit.xz)));\n      col += sh * atten * (objCol.rgb * 0.8 * max (dot (vn, ltVec), 0.) +\n         objCol.a * pow (max (dot (normalize (ltVec - rd), vn), 0.), 32.));\n    } else col = objCol.rgb * (0.5 + 0.5 * atten);\n    col *= ao;\n    col = clamp (mix (bgCol, col, exp (32. * min (0., 0.7 - dstObj / dstFar))), 0., 1.);    \n  } else col = bgCol;\n  col = pow (col, vec3 (0.8));\n  if (! colImg) col = vec3 (0.9) * RgbToVal (col);\n  else if (marchImg) col = HsvToRgb (vec3 (0.7 * (1. - stepCnt / 300.), 1., 1.));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, asp;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  bSize = vec3 (40., 20., 40.);\n  az = 0.;\n  el = 0.;\n  colImg = true;\n  marchImg = false;\n  if (mPtr.z > 0. && mPtr.x > 0.4 && mPtr.y < -0.4) colImg = false;\n  if (mPtr.z > 0. && mPtr.x > 0.4 && mPtr.y > 0.4) marchImg = true;\n  if (mPtr.z > 0. && colImg && ! marchImg) {\n    az += 2. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  } else {\n    el = -0.03 * pi;\n    az = 0.5 * pi * (2. * mod (floor (0.07 * tCur), 2.) - 1.) *\n       SmoothBump (0.2, 0.8, 0.1, mod (0.07 * tCur, 1.));\n  }\n  el = clamp (el, -0.45 * pi, 0.45 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -1.) + vec3 (0., 9., 4. * tCur);\n  asp = canvas.x / canvas.y;\n  uv.xy /= 1.8;\n  rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uv.x / asp)) * asp, uv.y, 1.));\n  ltPos = vuMat * vec3 (0., 1., -1.);\n  dstFar = 440.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nfloat RgbToVal (vec3 c)\n{\n  return max (c.r, max (c.g, c.b));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat DigSeg (vec2 q)\n{\n  return step (abs (q.x), 0.12) * step (abs (q.y), 0.6);\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.5, 2.2);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.)) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (sgn < 0.) {\n      if (idChar == mxChar - nDig - 1.) s = ShowDig (q, -1);\n      else ++ v;\n    }\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtsfRl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 865, 887, 887, 2709], [2711, 2711, 2744, 2744, 3306], [3308, 3308, 3329, 3329, 3584], [3586, 3586, 3637, 3637, 3951], [3953, 3953, 3985, 3985, 4255], [4257, 4257, 4292, 4292, 8698], [8700, 8700, 8753, 8753, 10025], [10027, 10027, 10069, 10069, 10120], [10122, 10122, 10179, 10179, 10262], [10264, 10264, 10294, 10294, 10352], [10354, 10354, 10385, 10385, 10449], [10451, 10451, 10475, 10475, 10611], [10613, 10613, 10638, 10638, 10676], [10710, 10710, 10734, 10734, 10794], [10796, 10796, 10820, 10820, 10885], [10887, 10887, 10911, 10911, 11041], [11043, 11043, 11068, 11068, 11254], [11256, 11256, 11277, 11277, 11432], [11434, 11434, 11463, 11463, 11675], [11677, 11677, 11716, 11716, 11900], [11902, 11902, 11925, 11925, 11984], [12057, 12057, 12089, 12089, 12631], [12633, 12633, 12693, 12693, 13268]], "test": "untested"}
{"id": "MtSfRR", "name": "Tree_KIFS", "author": "EvilRyu", "description": "christmas coding", "tags": ["tree", "kifs", "mengerspone"], "likes": 19, "viewed": 993, "published": "Public API", "date": "1514212128", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by EvilRyu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nfloat stime, ctime;\n void ry(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n }  \n void rx(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.y = c * q.y - s * q.z;  \n  \tp.z = s * q.y + c * q.z; \n }  \n\n void rz(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x - s * q.y;  \n  \tp.y = s * q.x + c * q.y; \n }  \nfloat plane(vec3 p, float y) {\n    return length(vec3(p.x, y, p.z) - p);\n}\n\nvec3 mat=vec3(0.0);\nbool bcolor = false;\n\nfloat menger_spone(in vec3 z0){\n\n    z0=z0.yzx;\n\tvec4 z=vec4(z0,1.0);\n    vec3 offset =0.83*normalize(vec3(3.4,2., .2));\n    float scale = 2.;\n\tfor (int n = 0; n < 8; n++) {\n\t\tz = abs(z);\n        ry(z.xyz, 1.5);\n\t\tif (z.x<z.y)z.xy = z.yx;\n\t\tif (z.x<z.z)z.xz = z.zx;\n\t\tif (z.y<z.z)z.yz = z.zy;\n        ry(z.xyz, -1.21);\n        \n\t\tz = z*scale;\n\t\tz.xyz -= offset*(scale-1.0);\n       \tif(bcolor && n==2)mat+=vec3(0.4)+sin(z.zxy*z.yxz)*vec3(0.3, .8, 0.7);\n\t}\n\treturn (length(max(abs(z.xyz)-vec3(1.0),0.0))-0.01)/z.w;\n}\n\n vec3 f(vec3 p){ \n\t ry(p, stime);\n     float d1 = plane(p, -0.5);\n     float d2 = menger_spone(p+vec3(0.,-0.1,0.));\n     //return vec3(d2, 1., 0.);\n     float d = d1;\n     vec3 res = vec3(d1, 0., 0.);\n     if(d > d2) \n     {\n         d = d2;\n         res = vec3(d2, 1., 0.0);\n     }\n    \n\treturn res;\n } \n\n float ao(vec3 p, vec3 n){ \n \tfloat ao=0.0,sca=1.0; \n \tfor(float i=0.0;i<20.0;++i){ \n \t\tfloat hr=0.05+0.015*i*i; \n \t\tao+=(hr-f(n*hr+p).x)*sca; \n \t\tsca*=0.75; \n \t} \n \treturn 1.0-clamp(ao,0.0,1.0); \n } \n\n\nfloat rand(vec2 t){\n\treturn fract(sin(dot(t*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat softshadow(vec3 ro, vec3 rd, float k ){ \n     float akuma=1.0,h=0.0; \n     float t = 0.01;\n     for(int i=0; i < 40; ++i){ \n         h=f(ro+rd*t).x; \n         if(h<0.001){akuma=0.0;break;} \n         akuma=min(akuma, k*h/t); \n         t+=abs(h);\n     } \n     return clamp(akuma*0.8+0.2, 0.0, 1.0); \n} \n vec3 nor(vec3 p){ \n \tvec3 e=vec3(0.0001,0.0,0.0); \n \treturn normalize(vec3(f(p+e.xyy).x-f(p-e.xyy).x, \n \t\t\t\t\t\t  f(p+e.yxy).x-f(p-e.yxy).x, \n \t\t\t\t\t\t  f(p+e.yyx).x-f(p-e.yyx).x)); \n } \n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec3 res = vec3(-1.0);\n\tvec3 h = vec3(1.0);\n    for( int i=0; i<64; i++ )\n    {\n\t\tif( h.x<0.003 || t>30.0 ){\n\t\t}else {\n        \th = f(ro + rd*t);\n        \tres = vec3(t,h.yz);\n        \tt += abs(h.x);\n\t\t}\n    }\n\tif( t>30.0 ) res=vec3(-1.0);\n    return res;\n}\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x/iResolution.y; \n\t// camera\n \tstime=sin(iTime*0.2); \n \tctime=cos(iTime*0.2); \n\n \tvec3 ta=vec3(.0,0.0,0.0); \n\tvec3 ro = vec3(3.5*ctime, 2.2+0.5*ctime, 5.8+1.0*stime) * 0.31;\n\n \tvec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n \tvec3 rd = normalize(uv.x*cs + uv.y*cu + 2.8*cf);  // transform from view to world\n\n    vec3 sundir = normalize(vec3(-8.5, 7.0,18.8)); \n    vec3 sun = vec3(1.64, 1.27, 0.99); \n    vec3 skycolor = vec3(0.6, 1.5, 1.); \n\n\tvec3 bg = exp(uv.y-1.0)*vec3(.6, 0.9, 1.4)*1.3;\n\n    float sc=clamp(dot(sundir, rd), 0.0, 1.0); \n    vec3 col=bg; \n\n\n    float t=0.0;\n    vec3 p=ro; \n\t \n\tvec3 res = intersect(ro, rd);\n\t if(res.x > 0.0){\n\t\t   p = ro + res.x * rd;\n           bcolor = true;\n           mat=vec3(0.0);\n           vec3 n=nor(p);\n           mat/=6.0;\n           bcolor = false;\n           float occ = ao(p, n); \n           float shadow = softshadow(p, sundir, 50.0);\n\n           float dif = max(0.0, dot(n, sundir)); \n           float sky = 0.6 + 0.4 * max(0.0, dot(n, vec3(0.0, 1.0, 0.0))); \n \t\t   float bac = max(0.3 + 0.7 * dot(vec3(-sundir.x, -1.0, -sundir.z), n), 0.0); \n           float spe = max(0.0, pow(clamp(dot(sundir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n\n           vec3 lin = 4.5 * sun * dif * occ * shadow; \n           lin += 0.8 * bac * sun * occ; \n           lin += 0.6 * sky * skycolor * occ; \n           lin += 2.0 * spe * occ; \n\n           col = lin *(vec3(1.5)*(1.0-res.y)+mat*res.y) *  0.2; \n \t\t   col=mix(col,bg, 1.0-exp(-0.001*res.x*res.x)); \n    } \n\n    // post\n\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n\n \tfragColor.xyz = col; \n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtSfRR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 132, 163, 163, 281], [285, 285, 316, 316, 433], [438, 438, 469, 469, 586], [589, 589, 619, 619, 663], [707, 707, 738, 738, 1221], [1224, 1224, 1239, 1239, 1526], [1530, 1530, 1555, 1555, 1728], [1732, 1732, 1751, 1751, 1821], [1822, 1822, 1867, 1867, 2127], [2130, 2130, 2147, 2147, 2311], [2314, 2314, 2356, 2356, 2636], [2639, 2639, 2698, 2698, 4642]], "test": "untested"}
{"id": "MtXBD2", "name": "Line through 2 points", "author": "rkibria", "description": "Use the formula for distance from a point to a line.", "tags": ["2d", "lines", "primitive"], "likes": 0, "viewed": 90, "published": "Public", "date": "1513337853", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\nfloat lineDistance(in vec2 M, vec2 P1, vec2 P2) {\n    float x1 = P1.x, y1 = P1.y;\n    float x2 = P2.x, y2 = P2.y;\n    float x0 = M.x, y0 = M.y;\n    float numer = abs((y2-y1)*x0 - (x2-x1)*y0 + x2*y1 - y2*x1);\n    float denom = length(P2 - P1);\n    return numer / denom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(0);\n\n    const vec2 cen = vec2(0.5);\n    const float radius = 0.4;\n    float sinT = sin(iTime);\n    float cosT = cos(iTime);\n    vec2 P1 = vec2(cen.x + radius * cosT, cen.y + radius * sinT);\n    vec2 P2 = vec2(cen.x, cen.y + radius * cosT);\n\n    const float dotsize = 0.02;\n    if (length(uv-P1) < dotsize) {\n         fragColor = vec4(1.0, 0., 0., 0.);\n \t}\n    else if (length(uv-P2) < dotsize) {\n         fragColor = vec4(1.0, 0., 0., 0.);\n    }\n    else {\n        float d = lineDistance(uv, P1, P2);\n        d = smoothstep(0., 1., d*100.0);\n        fragColor = vec4(d);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtXBD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 65, 114, 114, 335], [337, 337, 394, 394, 1039]], "test": "untested"}
{"id": "MtXfD2", "name": "Purpcycle", "author": "shau", "description": "Inspired by Beeple VJ Clip of same name", "tags": ["3d"], "likes": 65, "viewed": 2729, "published": "Public", "date": "1513445477", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by SHAU - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define T iTime * 2.0\n#define PI 3.14159265359\n#define FAR 50.0 \n#define EPS 0.005\n#define ZERO (min(iFrame,0))\n\n#define FLOOR 1.0\n#define ORB 2.0\n#define WHITE_GLOW 3.0\n#define FLAT_L_BLUE 4.0\n#define FLAT_D_BLUE 5.0\n#define WALL 6.0\n#define BLUE_GLOW 7.0\n#define ARCH 8.0\n#define ARCH_2 9.0\n\nvec3 lp = vec3(0.0);\n\nstruct Scene {\n    float t;\n    vec3 n;\n    float id;\n    float wli;\n    float bli;\n};\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\nfloat rand(vec2 p) {return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n    p.z *= 0.8;\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat planeIntersection(vec3 ro, vec3 rd, vec3 n, vec3 o) {\n    return dot(o - ro, n) / dot(rd, n);\n}\n\nvec2 nearest(vec2 a, vec2 b){ \n    float s = step(a.x, b.x);\n    return s * a + (1. - s) * b;\n}\n\nvec4 archway(vec3 rp) {\n    float rr = (mod(rp.z, 12.0) - 6.0) > 0.0 ? 1.0 : -1.0;\n    rp.xy *= rot(T * 0.2 * rr);\n    float a = atan(rp.y, rp.x) / 6.2831853;\n    float ia = floor(a * 4.0) / 4.0 * 6.2831853;\n    vec3 q = rp;\n    q.xy *= rot(ia);\n    q.z = mod(q.z, 6.0) - 3.0;\n    float t1 = sdTorus(q.xzy, vec2(1.5, 0.15));\n    float t2 = sdTorus(q.xzy, vec2(1.5, 0.22));\n    float t3 = sdTorus(q.xzy, vec2(1.71, 0.02));\n    float t4 = sdTorus(q.xzy - vec3(0.0, -0.22, 0.0), vec2(1.5, 0.05));\n    t2 = max(t2, q.y - 0.5); \n    t4 = max(t4, q.y - 1.2);\n    q = rp;\n    q.x = abs(q.x);\n    q.z = mod(q.z, 6.0) - 3.0;\n    float t5 = sdTorus(q.zyx - vec3(0.0, 0.0, 1.5), vec2(0.26, 0.03));     \n    vec2 near = vec2(t1, ARCH);\n    near = nearest(near, vec2(t2, WALL));    \n    near = nearest(near, vec2(t3, ARCH_2));    \n    near = nearest(near, vec2(t4, BLUE_GLOW));    \n    near = nearest(near, vec2(t5, WHITE_GLOW));    \n    return vec4(near, t4, t5);\n}\n\nvec3 tower1(vec3 rp) {\n    rp.x = abs(rp.x);\n    rp.z = mod(rp.z, 12.0) - 6.0;\n    vec2 core = vec2(fCylinder(rp - vec3(2.5, 0.0, 0.0), 0.2, 3.0), FLAT_L_BLUE);\n    float sh = 2.0 + sin(T * 0.2) * 1.;\n    vec2 sleeve = vec2(fCylinder(rp - vec3(2.5, 0.0, 0.0), 0.3, 3.0), WHITE_GLOW);\n    float sleevecut = fCylinder(rp - vec3(2.5, 0.0, 0.0), 0.4, 3.0);\n    sleeve.x = max(max(sleeve.x, sh - 0.4 - rp.y), rp.y - sh);\n    sleevecut = max(max(sleevecut, sh - 0.3 - rp.y), rp.y - sh + 0.1);\n    sleeve.x = max(sleeve.x, -sleevecut);\n    vec2 base = vec2(fCylinder(rp - vec3(2.5, 0.0, 0.0), 0.3, 0.5), WALL);\n    return vec3(nearest(nearest(base, core), sleeve), sleeve.x);\n}\n\nvec3 tower2(vec3 rp) {\n    vec3 q = rp;\n    q.x = abs(q.x);\n    q.z = mod(q.z, 24.0) - 12.0;\n    vec2 near = vec2(fCylinder(q - vec3(9.0, 0.0, 0.0), 2.0, 1.0), WALL);\n    vec2 core = vec2(fCylinder(q - vec3(9.0, 0.0, 0.0), 1.2, 6.0), WALL);\n    q = rp;\n    float rh = sin(T * 0.1) * 1.5;    \n    q.y += rh;\n    q.x = abs(q.x);\n    q.z = mod(q.z, 24.0) - 12.0;\n    vec2 ringcore = vec2(fCylinder(q - vec3(9.0, 0.0, 0.0), 1.3, 4.2), BLUE_GLOW);\n    q.y = mod(q.y, 0.4) - 0.2;\n    vec2 rings = vec2(fCylinder(q - vec3(9.0, 0.0, 0.0), 1.8, 0.1), WALL);\n    rings.x = max(rings.x, rp.y + rh - 4.4);\n    near = nearest(near, core);\n    near = nearest(near, rings);\n    near = nearest(near, ringcore);    \n    return vec3(near, ringcore.x);\n}\n\nvec3 smallorbs(vec3 rp) {\n    rp.z = mod(rp.z, 3.0) - 1.5;\n    rp.x = abs(rp.x);\n    vec2 orb = vec2(sdSphere(rp - vec3(1.2, 0.0, 0.0), 0.2), ORB);\n    vec2 torus = vec2(sdTorus(rp - vec3(1.2, 0.0, 0.0), vec2(0.25, 0.02)), WHITE_GLOW);\n    return vec3(nearest(orb, torus), torus.x);\n}\n\nvec3 mediumorbs(vec3 rp) {    \n    vec3 q = rp;\n    q.z = mod(q.z, 6.0) - 3.0;\n    q.x = abs(q.x);\n    vec2 near = vec2(sdSphere(q - vec3(3.4, 0.0, 0.0), 0.8), ORB);\n    vec2 torus = vec2(sdTorus(q - vec3(3.4, 0.0, 0.0), vec2(1.0, 0.03)), WHITE_GLOW);\n    torus.x = min(torus.x, sdTorus(q - vec3(1.5, 0.0, 0.0), vec2(0.35, 0.03)));\n    float fins = sdSphere(q - vec3(3.4, 0.0, 0.0), 0.9);\n    q.y = mod(q.y, 0.1) - 0.05;\n    fins = max(fins, q.y - 0.01);    \n    vec2 fins1 = vec2(max(fins, rp.y - 0.55), FLAT_L_BLUE);\n    fins1 = max(fins1, 0.4 - rp.y);\n    vec2 fins2 = vec2(max(fins, rp.y - 0.25), FLAT_D_BLUE);\n    fins2 = max(fins2, 0.2 - rp.y);  \n    near = nearest(near, torus);\n    near = nearest(near, fins1);\n    near = nearest(near, fins2);\n    return vec3(near, torus.x);\n}\n\nvec3 largeorbs(vec3 rp) {\n    vec3 q = rp;\n    q.z = mod(q.z - 12.0, 24.0) - 12.0;\n    q.x = abs(q.x);\n    vec2 near = vec2(sdSphere(q - vec3(16.0, 0.0, 0.0), 6.0), ORB);\n    vec2 torus = vec2(sdTorus(q - vec3(16.0, 0.0, 0.0), vec2(6.5, 0.1)), WHITE_GLOW);\n    float fins = sdSphere(q - vec3(16.0, 0.0, 0.0), 6.3);\n    q.y = mod(q.y, 0.4) - 0.2;\n    fins = max(fins, q.y - 0.05);    \n    vec2 fins1 = vec2(max(fins, rp.y - 1.8), FLAT_L_BLUE);\n    fins1 = max(fins1, 1.1 - rp.y);\n    vec2 fins2 = vec2(max(fins, rp.y - 0.7), FLAT_D_BLUE);\n    fins2 = max(fins2, 0.3 - rp.y);  \n    near = nearest(near, torus);\n    near = nearest(near, fins1);\n    near = nearest(near, fins2);\n    return vec3(near, torus.x);\n}\n\nvec4 map(vec3 rp) {\n    vec4 arch = archway(rp);\n    vec2 near = arch.xy;\n    vec3 tow1 = tower1(rp);\n    near = nearest(near, tow1.xy);\n    vec3 tow2 = tower2(rp);\n    near = nearest(near, tow2.xy);\n    vec3 sorbs = smallorbs(rp);\n    near = nearest(near, sorbs.xy);\n    vec3 morbs =  mediumorbs(rp);\n    near = nearest(near, morbs.xy);\n    vec3 lorbs = largeorbs(rp);\n    near = nearest(near, lorbs.xy);\n    float blt = min(tow2.z, arch.z); //blue light\n    float wlt = min(sorbs.z, morbs.z); //white light\n    wlt = min(wlt, lorbs.z);\n    wlt = min(wlt, tow1.z);\n    wlt = min(wlt, arch.w);\n    return vec4(near, blt, wlt);\n}\n\nvec3 normal(vec3 rp) {\n    vec2 e = vec2(EPS, 0);\n    float d1 = map(rp + e.xyy).x, d2 = map(rp - e.xyy).x;\n    float d3 = map(rp + e.yxy).x, d4 = map(rp - e.yxy).x;\n    float d5 = map(rp + e.yyx).x, d6 = map(rp - e.yyx).x;\n    float d = map(rp).x * 2.0;\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// Based on original by IQ.\n// http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\nfloat AO(vec3 rp, vec3 n) {\n\n    float r = 0.0;\n    float w = 1.0;\n    float d = 0.0;\n\n    for (float i = 1.0; i < 5.0; i += 1.0){\n        d = i / 5.0;\n        r += w * (d - map(rp + n * d).x);\n        w *= 0.5;\n    }\n\n    return 1.0 - clamp(r, 0.0, 1.0);\n}\n\n//IQ\n//http://www.iquilezles.org/www/articles/fog/fog.htm\nvec3 applyFog(vec3  rgb,      // original color of the pixel\n              float d, // camera to point distance\n              vec3  rayDir,   // camera to point vector\n              vec3  sunDir,\n              float b)  // sun light direction\n{\n    //float b = 0.07;\n    float fogAmount = 1.0 - exp(-d * b);\n    float sunAmount = max(dot(rayDir, sunDir), 0.0);\n    vec3  fogColor  = mix(vec3(0.5, 0.3, 0.8), // purple\n                          vec3(0.7, 0.7, 1.0), // blue\n                          pow(sunAmount, 8.0));\n    return mix(rgb, fogColor, fogAmount);\n}\n\nvec4 march(vec3 ro, vec3 rd) {\n    \n    float t = 0.0;\n    float id = 0.0;\n    float bli = 0.0;\n    float wli = 0.0;\n    \n    for (int i = ZERO; i < 96; i++) {\n        vec3 rp = ro + rd * t;    \n        vec4 scene = map(rp);\n        if (scene.x < EPS || t > FAR) {\n            id = scene.y;\n            break;   \n        }\n        \n        bli += 0.05 / (1.0 + scene.z * scene.z * 30.0) * step(0.0, rp.y);\n        wli += 0.05 / (1.0 + scene.w * scene.w * 100.0) * step(0.0, rp.y);\n        \n        t += scene.x;\n    }\n    \n    return vec4(t, id, bli, wli);\n}\n\nScene drawScene(vec3 ro, vec3 rd) {\n    \n    float mint = FAR;\n    vec3 minn = vec3(0.0);\n    float id = 0.0;\n    float bli = 0.0;\n    float wli = 0.0;\n    \n    vec3 fo = vec3(0.0, 0.0, 0.0);\n    vec3 fn = vec3(0.0, 1.0, 0.0);\n    float ft = planeIntersection(ro, rd, fn, fo);\n    if (ft > 0.0 && ft < mint) {\n        mint = ft;\n        minn = fn;\n        id = FLOOR;\n    }\n\n    vec4 scene = march(ro, rd);\n    if (scene.x > 0.0 && scene.x < mint) {\n        if (scene.x < mint) {\n            mint = scene.x;\n            minn = normal(ro + rd * scene.x);\n            id = scene.y;\n        }\n    }\n    \n    bli = scene.z;\n    wli = scene.w;\n\n    return Scene(mint, minn, id, wli, bli);\n}\n\nvec2 floorTexture(vec3 rp, float t) {\n\n    float line = 0.0;\n    float cut = 0.0;\n        \n    //small orbs\n    vec3 q = rp;\n    q.z = mod(q.z, 3.0) - 1.5;\n    q.x = abs(q.x);\n    line += smoothstep(0.33, 0.32, length(q.xz - vec2(1.2, 0.0))); \n    cut += smoothstep(0.3, 0.29, length(q.xz - vec2(1.2, 0.0)));\n                \n    //medium orbs and archway\n    q = rp;\n    q.z = mod(q.z, 6.0) - 3.0;\n    q.x = abs(q.x);\n    line += smoothstep(1.2, 1.18, length(q.xz - vec2(3.4, 0.0))); \n    cut += smoothstep(1.1, 1.08, length(q.xz - vec2(3.4, 0.0)));\n    line += smoothstep(0.5, 0.48, length(q.xz - vec2(1.5, 0.0)));\n    cut += smoothstep(0.42, 0.41, length(q.xz - vec2(1.5, 0.0)));\n        \n    //large orbs\n    q = rp;\n    q.z = mod(q.z - 12.0, 24.0) - 12.0;\n    q.x = abs(q.x);\n    line += smoothstep(7.6, 7.5, length(q.xz - vec2(16.0, 0.0))); \n    cut += smoothstep(7.4, 7.3, length(q.xz - vec2(16.4, 0.0)));\n        \n    q = rp;\n    vec2 grid = fract(vec2(q.x * 0.25, q.z * 0.5));\n    float gridline = (smoothstep(0.01, 0.005, grid.x) + smoothstep(0.998, 0.999, grid.x));\n    gridline += smoothstep(0.02 + t / FAR * 0.2, 0.01, grid.y) / (t * 1.0);\n    \n    line = clamp(line + gridline, 0.0, 1.0);\n    line /= t * 0.5;\n\n    return vec2(line, cut);\n}\n\nfloat tex(vec2 uv) {\n    vec2 mx = mod(uv, 0.1) - 0.05;     \n    float tx = (mx.x * mx.y) > 0.0 ? 1.0 : 0.0;\n    tx *= sin(uv.y * 100.0 + T) * 0.6 + 1.0;\n    tx *= sin(uv.x * 100.0 + T) * 0.6 + 1.0;\n    tx *= step(uv.y, 0.1) + step(-uv.y, -0.2); \n    return tx;\n}        \n\nvec3 colourScene(vec3 ro, vec3 rd, Scene scene) {\n \n    vec3 pc = vec3(0.0);\n    \n    vec3 rp = ro + rd * scene.t;\n    vec3 ld = normalize(lp - rp);\n    float lt = length(lp - rp);\n    \n    float diff = 1.0;\n    float spec = pow(max(dot(reflect(-ld, scene.n), -rd), 0.0), 64.0);\n    float atten = 1.0;\n    float fres = 0.0;\n    \n    if (scene.id == FLOOR) {\n        \n        vec2 flrTex = floorTexture(rp, scene.t);        \n        pc += vec3(0.5, 0.3, 1.0) * clamp(flrTex.x, 0.0, 1.0);\n        pc -= clamp(flrTex.y, 0.0, 1.0);\n        \n    } else if (scene.id == ORB) {\n        \n        diff = max(dot(ld, scene.n), 0.05);\n        spec = pow(max(dot(reflect(-ld, scene.n), -rd), 0.0), 32.0);\n        fres = pow(clamp(dot(scene.n, rd) + 1.0, 0.0, 1.0), 4.0);\n        \n        pc = vec3(0.1) * diff;\n        pc += vec3(1.0) * spec;\n        pc += vec3(0.5, 0.3, 1.0) * fres * diff;\n\n    } else if (scene.id == WALL) {\n\n        diff = max(dot(ld, scene.n), 0.05);\n        fres = pow(clamp(dot(scene.n, rd) + 1.0, 0.0, 1.0), 4.0);\n\n        pc = vec3(0.1) * diff;\n        pc += vec3(1.0) * spec;\n        pc += vec3(0.5, 0.3, 1.0) * fres * diff;\n\n    } else if (scene.id == ARCH) {\n        \n        diff = max(dot(ld, scene.n), 0.05);\n        fres = pow(clamp(dot(scene.n, rd) + 1.0, 0.0, 1.0), 4.0);\n\n        vec3 q = rp;\n        float rr = (mod(q.z, 12.0) - 6.0) > 0.0 ? 1.0 : -1.0;\n        q.xy *= rot(T * 0.2 * rr);\n        float a = atan(q.y, q.x) / 6.2831853;\n        a = fract(a * 8.0);\n        \n        pc = vec3(0.1) * diff;\n        pc += vec3(0.6, 0.3, 1.0) * step(a, 0.3) * tex(vec2(length(rp.xy), a));\n        pc += vec3(1.0) * spec;\n        pc += vec3(0.5, 0.3, 1.0) * fres * diff;\n\n    } else if (scene.id == WHITE_GLOW) {\n        \n        diff = max(dot(ld, scene.n), 0.8);\n        \n        pc = vec3(1.0) * diff;\n        \n    } else if (scene.id == BLUE_GLOW) {\n        \n        diff = max(dot(ld, scene.n), 0.8);\n\n        pc = vec3(0.3, 0.3, 1.0) * diff;\n        pc += vec3(1.0) * spec;\n\n    } else if (scene.id == FLAT_L_BLUE) {\n        \n        diff = max(dot(ld, scene.n), 0.8);\n\n        pc = vec3(0.5, 0.8, 1.0) * diff;\n        pc += vec3(1.0) * spec;\n        \n    } else if (scene.id == FLAT_D_BLUE) {\n\n        diff = max(dot(ld, scene.n), 0.8);\n\n        pc = vec3(0.3, 0.3, 1.0) * diff;\n        pc += vec3(1.0) * spec;\n\n    } else if (scene.id == ARCH_2) {\n        \n        diff = max(dot(ld, scene.n), 0.05);\n        \n        pc = vec3(0.5, 0.3, 1.0);\n        pc *= diff;\n        pc += vec3(1.0) * spec;\n    }\n    \n    //pc *= AO(rp, scene.n);\n    \n    return pc;\n}\n\nvoid setupCamera(vec2 fragCoord, inout vec3 ro, inout vec3 rd) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    vec3 lookAt = vec3(0.0, 0.0, T * 0.5);\n    lp = lookAt + vec3(4.0, 4.0, -2.0);\n    ro = lookAt + vec3(0.0, 0.8, -4.0);\n    \n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec3 pc = vec3(0.0);\n    float mint = FAR;\n    \n    vec3 ro, rd;\n    setupCamera(fragCoord, ro, rd);\n    \n    Scene scene = drawScene(ro, rd);\n    if (scene.t > 0.0 && scene.t < FAR) {\n        mint = scene.t;\n        pc = colourScene(ro, rd, scene);\n        \n        if (scene.id == FLOOR || \n            scene.id == ORB || \n            scene.id == WALL ||\n            scene.id == ARCH) {\n            \n            float lt = scene.t;\n            vec3 rc = vec3(0.5, 0.3, 1.0) * 0.2;\n            float ra = 0.1;\n            \n            vec3 rpb = ro + rd * (scene.t - EPS);\n            vec3 rrd = reflect(rd, scene.n);\n            Scene refl = drawScene(rpb, rrd);\n            \n            if (refl.t > 0.0 && refl.t < FAR) {\n                rc = colourScene(rpb, rrd, refl); \n                lt += refl.t;\n                if (refl.id == WHITE_GLOW ||\n                    refl.id == BLUE_GLOW) {\n                    ra = 0.02;\n                } else if (refl.id == FLAT_L_BLUE ||\n                           refl.id == FLAT_D_BLUE) {\n                    ra = 0.06;\n                }\n            }\n            float rt = 1.0 / (1.0 + lt * lt * ra);\n            pc += rc * rt * 0.5;\n            pc += vec3(1.0) * refl.wli * rt * 0.5;\n        }\n    }\n\n    pc = applyFog(pc, mint, rd, normalize(vec3(2.0, 2.0, 4.0)), 0.01);\n\n    pc += vec3(1.0) * scene.wli * 0.8;\n    pc += vec3(0.3, 0.3, 1.0) * scene.bli;\n    \n\tfragColor = vec4(pc, 1.0);\n    //fragColor = vec4(sqrt(clamp(pc, 0.0, 1.0)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtXfD2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 574, 593, 593, 639], [640, 640, 660, 660, 722], [724, 724, 755, 755, 829], [831, 831, 864, 864, 892], [894, 894, 942, 942, 1032], [1034, 1034, 1093, 1093, 1135], [1137, 1137, 1166, 1166, 1232], [1234, 1234, 1257, 1257, 2187], [2189, 2189, 2211, 2211, 2859], [2861, 2861, 2883, 2883, 3596], [3598, 3598, 3623, 3623, 3882], [3884, 3884, 3910, 3910, 4669], [4671, 4671, 4696, 4696, 5379], [5381, 5381, 5400, 5400, 6009], [6011, 6011, 6033, 6033, 6322], [6324, 6426, 6453, 6453, 6683], [6685, 6743, 6987, 7009, 7307], [7309, 7309, 7339, 7339, 7867], [7869, 7869, 7904, 7904, 8554], [8556, 8556, 8593, 8593, 9810], [9812, 9812, 9832, 9832, 10075], [10085, 10085, 10134, 10134, 12668], [12670, 12670, 12734, 12734, 13173], [13175, 13175, 13230, 13230, 14732]], "test": "untested"}
{"id": "MtXfDj", "name": "GooeyVignette V2", "author": "Del", "description": "Updated 'Gooey Vignette' with proper alpha blending support and various parameters to tweak! - distortion, zoom, gooeyness, wibble, saturation etc.\n\n", "tags": ["2d", "sin", "slime", "goo", "alpha", "wibble"], "likes": 5, "viewed": 672, "published": "Public API", "date": "1513294693", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// GooFunc - now with technical parameters for you to play with :)\nfloat GooFunc(vec2 uv,float zoom,float distortion, float gooeyness,float wibble)\n{\n    float s = sin(iTime*0.1);\n    float s2 = 0.5+sin(iTime*1.8);\n    vec2 d = uv*(distortion+s*.3);\n    d.x += iTime*0.25+sin(d.x+d.y + iTime*0.3)*wibble;\n    d.y += iTime*0.25+sin(d.x + iTime*0.3)*wibble;\n    float v1=length(0.5-fract(d.xy))+gooeyness;\n    d = (1.0-zoom)*0.5+(uv*zoom);\t\t\t\t\t// try removing this :)\n    float v2=length(0.5-fract(d.xy));\n    v1 *= 1.0-v2*v1;\n    v1 = v1*v1*v1;\n    v1 *= 1.9+s2*0.2;\n    return v1;\n}\n\nvoid mainImage(out vec4 k, vec2 p)\n{\n    vec2 uv = p.xy / iResolution.xy;\n\n\tfloat distortion = 4.0;\t\t\t\t\t\t// increase or decrease to suit your taste.\n    float zoom = 0.7;\t\t\t\t\t\t\t// zoom value\n    float gooeyness = 0.95;\t\t\t\t\t\t// smaller = more gooey bits\n    float wibble = 0.5;\t\t\t\t\t\t\t// tweak the wibble!\n    float goo = GooFunc(uv, zoom, distortion, gooeyness,wibble);\n    \n    const vec4 col1 = vec4(0.0,.1,.1,1.0);\n    const vec4 col2 = vec4(0.5,0.9,0.3,1.0);\n    float saturation = 2.4;\n    k = mix(col2,col1,goo)*saturation;\n\n    vec4 background = texture(iChannel0, uv);\n\n    // press mouse for grid background.\n    if (iMouse.z>0.5)\n    {\n        float f = mod( floor(12.0*uv.x) + floor(12.0*uv.y), 2.0);\n        background = vec4(0.3 + 0.5*f*1.0);\n    }\n\n    float avg = max(max(k.r,k.g),k.b);\t\t//float avg = k.g;\t//(k.r+k.g+k.b)/3.0;\n    float alpha=1.0;\n    if (avg<=0.4)\n    {\n        // darken & alpha edge of goo...\n        avg = clamp(avg,0.0,1.0);\n        k*=avg+0.2;\t\t\t\t\t\t// 0.0 = black edges\n        alpha = clamp((avg*avg)*5.5,0.0,1.0);\n    }\n\n    // blend goo + background based on the Alpha\n    k = mix(background,k,alpha);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtXfDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 68, 150, 150, 583], [585, 585, 621, 621, 1729]], "test": "untested"}
{"id": "MtXfRB", "name": "Purple Goo", "author": "harrisonvanderbyl", "description": "Some Goo", "tags": ["goo"], "likes": 3, "viewed": 141, "published": "Public", "date": "1512282827", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FOV 1.0\nfloat random (in vec3 _st) {\n    return fract(sin(dot(_st.xyz,\n                         vec3(12.9898,78.233,82.19)))*\n        43758.5453123);\n}\nfloat noise (in vec3 _st) {\n    vec3 i = floor(_st);\n    vec3 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec3(1.0, 0.0,0.0));\n    float c = random(i + vec3(0.0, 1.0,0.0));\n    float d = random(i + vec3(1.0, 1.0,0.0));\n\n    float e = random(i + vec3(0.0, 0.0,1.0));\n    float g = random(i + vec3(1.0, 0.0,1.0));\n    float h = random(i + vec3(0.0, 1.0,1.0));\n    float j = random(i + vec3(1.0, 1.0,1.0));\n    f = (1.0-cos(f*3.1415))/2.0;\n   // f = pow(abs(f-0.5)*2.0,vec3(2.0,2.0,2.0))*0.5*sign(f-0.5)+0.5;\n   // f = (1.0-cos(clamp(f*2.0,0.0,1.0)*3.1415))/4.0+(1.0-cos(clamp(f*2.0-1.0,0.0,1.0)*3.1415))/4.0;\n    \n    // float a1 = mix(a, b, u.x) \n     //       (c - a)* u.y * (1.0 - u.x) +\n     //(d - b) * u.x * u.y;\n     float a1 = mix(a,b,f.x);\n     float a2 = mix(c,d,f.x);\n     float a3 = mix(e,g,f.x);\n     float a4 = mix(h,j,f.x);\n\n     float a5 = mix(a1,a2,f.y);\n     float a6 = mix(a3,a4,f.y);\n\n\n    return mix(a5,a6,f.z);\n}\n\nfloat fbm ( in vec3 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100.0,22.5,44.0);\n    float r = 1.0;\n    for (int i = 0; i < 4; ++i){\n        v += a * noise(_st);\n        r += a;\n        _st =  shift + _st*2.0;\n        _st = (sin(r)*_st+cos(r)*_st);\n        a *= 0.5;\n    }\n    return v;\n}\nvec4 getint(vec3 cam,vec3 ray,vec3 pos,vec3 norm){\n    float d = dot(pos-cam,norm)/dot(ray,norm);\n    \n    vec3 posa = ray* d;\n    return vec4(posa,sign(d)*0.5+0.5);\n    \n    }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-0.5;\n    \n    vec2 look = (iMouse.xy-iMouse.zw)/iResolution.xy*3.1415*2.0+3.1415;\n    look=mix(vec2(3.1415),look,float(iMouse.z>0.0&&iMouse.w>0.0));\n    look.y=look.y*0.5+3.1415/2.0+3.4415;\n    look.x = -look.x + 3.1415;\n    \n    //xy = mouse when clickdown\n    //zw = mouse when clickfirst\n    vec3 screen = vec3(0.0);//\n    screen.x = uv.x;\n    screen.y = -sin(look.y)*FOV+cos(look.y)*uv.y*(iResolution.y/iResolution.x);\n    screen.z = cos(look.y)*FOV+sin(look.y)*uv.y*(iResolution.y/iResolution.x);\n   float temp = screen.x;\n    screen.x = cos(look.x)*screen.x+sin(look.x)*screen.z;\n    \n    screen.z = -sin(look.x)*temp+cos(look.x)*screen.z;\n    \n    \n   \n    vec3 ray = normalize(screen);\n    vec3 y = vec3(0.0,0.0,0.0);\n    vec3 pass = vec3(100.0);\n    vec3 ye = vec3(0.0);\n    float b = 0.0;\n    for(float i = 0.0;i<1.0;i+=0.01){\n        vec4 pos = getint(vec3(0.0,0.0,0.0),ray,vec3(0.0,-2.0+i,0.0),vec3(0.0,1.0,0.0));\n        vec3 ac = vec3(pos.x,iTime,pos.z);\n        float thy = fbm(ac);\n        bool is =thy>i&&thy<i+0.1;\n        \n        \n       // ref = i;\n        if((pos.w==1.0)&&(length(pos.xyz)<length(pass.xyz))&&(is)){y=vec3(1.0);pass=pos.xyz;b=i;ye = ac;}\n    }\n    vec3 post = vec3(pass.x,fbm(ye),pass.z);\n    vec3 aa = vec3(pass.x+0.1,fbm(ye+vec3(0.1,0.0,0.0)),pass.z);\n    vec3 ab = vec3(pass.x,fbm(ye+vec3(0.0,0.0,0.1)),pass.z+0.1);\n    vec3 norma = (normalize(cross(post-aa , post-ab)));\n    float res = pow(max(dot(reflect(ray,norma),vec3(0.0,1.0,0.0)),0.0),100.0);\n    float ref = dot(norma,vec3(0.0,-1.0,0.0));\n    fragColor = vec4(y*ref+res,1.0)*vec4(0.6,0.5,0.8,1.0);//texture(iChannel0,pass.xz);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtXfRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 44, 44, 159], [160, 160, 187, 187, 1151], [1153, 1153, 1179, 1179, 1465], [1466, 1466, 1516, 1516, 1642], [1643, 1643, 1700, 1700, 3375]], "test": "untested"}
{"id": "MtXfzj", "name": "Contrast speed", "author": "pyalot", "description": "Modification of https://www.shadertoy.com/view/MtfBDN", "tags": ["illusion"], "likes": 3, "viewed": 396, "published": "Public API", "date": "1512467360", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Contrast speed illusion. Created by Reinder Nijhoff 2017\n// @reindernijhoff\n// \n// https://www.shadertoy.com/view/MtfBDN\n//\n// Both rectangles are moving at exactly the same speed.\n//\n// Based on the flash implementation by Jim Cash: https://scratch.mit.edu/projects/188838060/\n//\n// Research paper:\n//\n// https://quote.ucsd.edu/anstislab/files/2012/11/2001-Footsteps-and-inchworms.pdf\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = iResolution.x / 300.;\n    \n    float fade = smoothstep(0.1,0.2,abs(fract(iTime*.05+.5)-.5));\n    \n    vec3 bgpattern = vec3(round(fract(uv.x*5.*scale)-.02*scale));\n    //vec3 bgpattern = .6+.6*cos(6.28*uv.x*20.*scale+vec3(0,-2.1,2.1));\n    //vec3 bgpattern = vec3(.5+.5*sin(6.28*uv.x*20.*scale));\n    \n    vec3 c = mix(vec3(0.7), bgpattern, fade);\n    \n    float p = fract(iTime*.1/scale);\n    float x = step(uv.x,p+.6/scale)*step(p,uv.x);\n    \n    c = mix(c, vec3(0,0,0), x*step(abs(uv.y-.3),.03));\n    c = mix(c, vec3(1,1,1), x*step(abs(uv.y-.7),.03));\n    \n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtXfzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 393, 450, 450, 1098]], "test": "untested"}
{"id": "Xl2Bz1", "name": "Barf Inducer", "author": "couch", "description": "trippy blippy", "tags": ["gradient", "psychedelic", "rainbow", "trippy", "strobe"], "likes": 8, "viewed": 383, "published": "Public", "date": "1514602550", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float square(float n)\n{\n    return n*n;   \n}\nfloat bounce = 0.0;\nfloat bounce2 = 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 res = vec2(1.0, 1.0);\n    vec2 iuv = floor( uv * res )/res;\n    \n    \n    float ww = iResolution.x;\n    float hh = iResolution.y;\n    float sound = texture( iChannel0, vec2(iuv.y, 0.0) ).x*1.0;\n    if (bounce2 < sound*15.0){bounce2 += sound*15.0;}\n    if (bounce2 > sound*15.0){bounce2 -= sound*15.0;}\n    bounce2 /= 1.2;\n    if (bounce < bounce2){bounce += bounce2/5.0;}\n    if (bounce > bounce2){bounce -= bounce2/5.0;}\n    bounce = clamp(bounce, 1.0, 100.0);\n    float time2 = iTime+2.0*(sin(square(1.0*(uv.x-0.5)) + square(1.0*(uv.y-0.5))));\n    \n    float r = sin(time2/2.0)*20.0*bounce;\n    float p = (square(fragCoord.x-ww/2.0) + square(fragCoord.y-hh/2.0))*((sin(time2/8.0)+1.0)/2.0)*((time2-2.0)*4.0)*(bounce/8.0);\n    \n    fragColor.r = sin(p/100.0)+1.0*bounce/2.0;\n    fragColor.g = sin(p/100.0+r/0.5)+1.*bounce/2.0;\n    fragColor.b = sin(p/100.0+r/0.2)+1.0*bounce/2.0;\n}", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2Bz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 44], [87, 87, 144, 144, 1084]], "test": "untested"}
{"id": "XlBfRD", "name": " Atmospheric Scattering", "author": "cubi", "description": "An Approximation Chapman Function for Atmospheric Scattering, Per Pixel with 16 samples, See GPU Pro 3 for more information\n\n* Use mouse to move the sun\n* Run it in fullscreen", "tags": ["sky", "scattering"], "likes": 35, "viewed": 3228, "published": "Public API", "date": "1514725735", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License (MIT) Copyright (C) 2017-2018 Rui. All rights reserved.\n                \n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define PI 3.1415926535f\n#define PI_2 (3.1415926535f * 2.0)\n\n#define EPSILON 1e-5\n\n#define SAMPLES_NUMS 16\n\nfloat saturate(float x){ return clamp(x, 0.0, 1.0); }\n\nstruct ScatteringParams\n{\n    float sunRadius;\n\tfloat sunRadiance;\n\n\tfloat mieG;\n\tfloat mieHeight;\n\n\tfloat rayleighHeight;\n\n\tfloat3 waveLambdaMie;\n\tfloat3 waveLambdaOzone;\n\tfloat3 waveLambdaRayleigh;\n\n\tfloat earthRadius;\n\tfloat earthAtmTopRadius;\n\tfloat3 earthCenter;\n};\n\nfloat3 ComputeSphereNormal(float2 coord, float phiStart, float phiLength, float thetaStart, float thetaLength)\n{\n\tfloat3 normal;\n\tnormal.x = -sin(thetaStart + coord.y * thetaLength) * sin(phiStart + coord.x * phiLength);\n\tnormal.y = -cos(thetaStart + coord.y * thetaLength);\n\tnormal.z = -sin(thetaStart + coord.y * thetaLength) * cos(phiStart + coord.x * phiLength);\n\treturn normalize(normal);\n}\n\nfloat2 ComputeRaySphereIntersection(float3 position, float3 dir, float3 center, float radius)\n{\n\tfloat3 origin = position - center;\n\tfloat B = dot(origin, dir);\n\tfloat C = dot(origin, origin) - radius * radius;\n\tfloat D = B * B - C;\n\n\tfloat2 minimaxIntersections;\n\tif (D < 0.0)\n\t{\n\t\tminimaxIntersections = float2(-1.0, -1.0);\n\t}\n\telse\n\t{\n\t\tD = sqrt(D);\n\t\tminimaxIntersections = float2(-B - D, -B + D);\n\t}\n\n\treturn minimaxIntersections;\n}\n\nfloat3 ComputeWaveLambdaRayleigh(float3 lambda)\n{\n\tconst float n = 1.0003;\n\tconst float N = 2.545E25;\n\tconst float pn = 0.035;\n\tconst float n2 = n * n;\n\tconst float pi3 = PI * PI * PI;\n\tconst float rayleighConst = (8.0 * pi3 * pow(n2 - 1.0,2.0)) / (3.0 * N) * ((6.0 + 3.0 * pn) / (6.0 - 7.0 * pn));\n\treturn rayleighConst / (lambda * lambda * lambda * lambda);\n}\n\nfloat ComputePhaseMie(float theta, float g)\n{\n\tfloat g2 = g * g;\n\treturn (1.0 - g2) / pow(1.0 + g2 - 2.0 * g * saturate(theta), 1.5) / (4.0 * PI);\n}\n\nfloat ComputePhaseRayleigh(float theta)\n{\n\tfloat theta2 = theta * theta;\n\treturn (theta2 * 0.75 + 0.75) / (4.0 * PI);\n}\n\nfloat ChapmanApproximation(float X, float h, float cosZenith)\n{\n\tfloat c = sqrt(X + h);\n\tfloat c_exp_h = c * exp(-h);\n\n\tif (cosZenith >= 0.0)\n\t{\n\t\treturn c_exp_h / (c * cosZenith + 1.0);\n\t}\n\telse\n\t{\n\t\tfloat x0 = sqrt(1.0 - cosZenith * cosZenith) * (X + h);\n\t\tfloat c0 = sqrt(x0);\n\n\t\treturn 2.0 * c0 * exp(X - x0) - c_exp_h / (1.0 - c * cosZenith);\n\t}\n}\n\nfloat GetOpticalDepthSchueler(float h, float H, float earthRadius, float cosZenith)\n{\n\treturn H * ChapmanApproximation(earthRadius / H, h / H, cosZenith);\n}\n\nfloat3 GetTransmittance(ScatteringParams setting, float3 L, float3 V)\n{\n\tfloat ch = GetOpticalDepthSchueler(L.y, setting.rayleighHeight, setting.earthRadius, V.y);\n\treturn exp(-(setting.waveLambdaMie + setting.waveLambdaRayleigh) * ch);\n}\n\nfloat2 ComputeOpticalDepth(ScatteringParams setting, float3 samplePoint, float3 V, float3 L, float neg)\n{\n\tfloat rl = length(samplePoint);\n\tfloat h = rl - setting.earthRadius;\n\tfloat3 r = samplePoint / rl;\n\n\tfloat cos_chi_sun = dot(r, L);\n\tfloat cos_chi_ray = dot(r, V * neg);\n\n\tfloat opticalDepthSun = GetOpticalDepthSchueler(h, setting.rayleighHeight, setting.earthRadius, cos_chi_sun);\n\tfloat opticalDepthCamera = GetOpticalDepthSchueler(h, setting.rayleighHeight, setting.earthRadius, cos_chi_ray) * neg;\n\n\treturn float2(opticalDepthSun, opticalDepthCamera);\n}\n\nvoid AerialPerspective(ScatteringParams setting, float3 start, float3 end, float3 V, float3 L, bool infinite, out float3 transmittance, out float3 insctrMie, out float3 insctrRayleigh)\n{\n\tfloat inf_neg = infinite ? 1.0 : -1.0;\n\n\tfloat3 sampleStep = (end - start) / float(SAMPLES_NUMS);\n\tfloat3 samplePoint = end - sampleStep;\n\tfloat3 sampleLambda = setting.waveLambdaMie + setting.waveLambdaRayleigh + setting.waveLambdaOzone;\n\n\tfloat sampleLength = length(sampleStep);\n\n\tfloat3 scattering = float3(0.0);\n\tfloat2 lastOpticalDepth = ComputeOpticalDepth(setting, end, V, L, inf_neg);\n\n\tfor (int i = 1; i < SAMPLES_NUMS; i++, samplePoint -= sampleStep)\n\t{\n\t\tfloat2 opticalDepth = ComputeOpticalDepth(setting, samplePoint, V, L, inf_neg);\n\n\t\tfloat3 segment_s = exp(-sampleLambda * (opticalDepth.x + lastOpticalDepth.x));\n\t\tfloat3 segment_t = exp(-sampleLambda * (opticalDepth.y - lastOpticalDepth.y));\n\t\t\n\t\ttransmittance *= segment_t;\n\t\t\n\t\tscattering = scattering * segment_t;\n\t\tscattering += exp(-(length(samplePoint) - setting.earthRadius) / setting.rayleighHeight) * segment_s;\n\n\t\tlastOpticalDepth = opticalDepth;\n\t}\n\n\tinsctrMie = scattering * setting.waveLambdaMie * sampleLength;\n\tinsctrRayleigh = scattering * setting.waveLambdaRayleigh * sampleLength;\n}\n\nfloat ComputeSkyboxChapman(ScatteringParams setting, float3 eye, float3 V, float3 L, out float3 transmittance, out float3 insctrMie, out float3 insctrRayleigh)\n{\n\tbool neg = true;\n\n\tfloat2 outerIntersections = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthAtmTopRadius);\n\tif (outerIntersections.y < 0.0) return 0.0;\n\n\tfloat2 innerIntersections = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthRadius);\n\tif (innerIntersections.x > 0.0)\n\t{\n\t\tneg = false;\n\t\touterIntersections.y = innerIntersections.x;\n\t}\n\n\teye -= setting.earthCenter;\n\n\tfloat3 start = eye + V * max(0.0, outerIntersections.x);\n\tfloat3 end = eye + V * outerIntersections.y;\n\n\tAerialPerspective(setting, start, end, V, L, neg, transmittance, insctrMie, insctrRayleigh);\n\n\tbool intersectionTest = innerIntersections.x < 0.0 && innerIntersections.y < 0.0;\n\treturn intersectionTest ? 1.0 : 0.0;\n}\n\nfloat4 ComputeSkyInscattering(ScatteringParams setting, float3 eye, float3 V, float3 L)\n{\n\tfloat3 insctrMie = float3(0.0);\n\tfloat3 insctrRayleigh = float3(0.0);\n\tfloat3 insctrOpticalLength = float3(1.0);\n\tfloat intersectionTest = ComputeSkyboxChapman(setting, eye, V, L, insctrOpticalLength, insctrMie, insctrRayleigh);\n\n\tfloat phaseTheta = dot(V, L);\n\tfloat phaseMie = ComputePhaseMie(phaseTheta, setting.mieG);\n\tfloat phaseRayleigh = ComputePhaseRayleigh(phaseTheta);\n\tfloat phaseNight = 1.0 - saturate(insctrOpticalLength.x * EPSILON);\n\n\tfloat3 insctrTotalMie = insctrMie * phaseMie;\n\tfloat3 insctrTotalRayleigh = insctrRayleigh * phaseRayleigh;\n\n\tfloat3 sky = (insctrTotalMie + insctrTotalRayleigh) * setting.sunRadiance;\n\n\tfloat angle = saturate((1.0 - phaseTheta) * setting.sunRadius);\n\tfloat cosAngle = cos(angle * PI * 0.5);\n\tfloat edge = ((angle >= 0.9) ? smoothstep(0.9, 1.0, angle) : 0.0);\n                         \n\tfloat3 limbDarkening = GetTransmittance(setting, -L, V);\n\tlimbDarkening *= pow(float3(cosAngle), float3(0.420, 0.503, 0.652)) * mix(vec3(1.0), float3(1.2,0.9,0.5), edge) * intersectionTest;\n\n\tsky += limbDarkening;\n\n\treturn float4(sky, phaseNight * intersectionTest);\n}\n\nfloat3 TonemapACES(float3 x)\n{\n\tconst float A = 2.51f;\n\tconst float B = 0.03f;\n\tconst float C = 2.43f;\n\tconst float D = 0.59f;\n\tconst float E = 0.14f;\n\treturn (x * (A * x + B)) / (x * (C * x + D) + E);\n}\n\nfloat noise(float2 uv)\n{\n\treturn fract(dot(sin(uv.xyx * uv.xyy * 1024.0), float3(341896.483, 891618.637, 602649.7031)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if (mouse.x == 0.0 && mouse.y == 0.0)\n        mouse = float2(0.5, 0.7);\n    \n    float3 V = ComputeSphereNormal(uv, 0.0, PI_2, 0.0, PI);\n    float3 L = ComputeSphereNormal(float2(mouse.x, mouse.y), 0.0, PI_2, 0.0, PI);\n    \n\tScatteringParams setting;\n\tsetting.sunRadius = 500.0;\n\tsetting.sunRadiance = 20.0;\n\tsetting.mieG = 0.76;\n\tsetting.mieHeight = 1200.0;\n\tsetting.rayleighHeight = 8000.0;\n\tsetting.earthRadius = 6360000.0;\n\tsetting.earthAtmTopRadius = 6420000.0;\n\tsetting.earthCenter = float3(0, -setting.earthRadius, 0);\n\tsetting.waveLambdaMie = float3(2e-7);\n    \n    // wavelength with 680nm, 550nm, 450nm\n    setting.waveLambdaRayleigh = ComputeWaveLambdaRayleigh(float3(680e-9, 550e-9, 450e-9));\n    \n    // see https://www.shadertoy.com/view/MllBR2\n\tsetting.waveLambdaOzone = float3(1.36820899679147, 3.31405330400124, 0.13601728252538) * 0.6e-6 * 2.504;\n\t\n    float3 eye = float3(0,1000.0,0);\n   \tfloat4 sky = ComputeSkyInscattering(setting, eye, V, L);\n    sky.rgb = TonemapACES(sky.rgb * 2.0);\n    sky.rgb = pow(sky.rgb, float3(1.0 / 2.2)); // gamma\n    sky.rgb += noise(uv*iTime) / 255.0; // dither\n   \n\tfragColor = float4(sky.rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBfRD.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 253, 277, 277, 306], [580, 580, 692, 692, 975], [977, 977, 1072, 1072, 1414], [1416, 1416, 1465, 1465, 1777], [1779, 1779, 1824, 1824, 1927], [1929, 1929, 1970, 1970, 2048], [2050, 2050, 2113, 2113, 2402], [2404, 2404, 2489, 2489, 2560], [2562, 2562, 2633, 2633, 2800], [2802, 2802, 2907, 2907, 3366], [3368, 3368, 3554, 3554, 4624], [4626, 4626, 4787, 4787, 5531], [5533, 5533, 5622, 5622, 6729], [6731, 6731, 6761, 6761, 6934], [6936, 6936, 6960, 6960, 7058], [7060, 7060, 7117, 7117, 8367]], "test": "untested"}
{"id": "XlBfRh", "name": "Escher Cubes computational trick", "author": "keim", "description": "Another trick of [url]https://www.shadertoy.com/view/ltjBzz[/url]. Trick on ray tracing.", "tags": ["illusion", "escher"], "likes": 12, "viewed": 666, "published": "Public API", "date": "1514426712", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n vec2  resolution, mouse;\n float time;\nconst vec3 V  = vec3(0,.001,300);\nconst vec3 BG = vec3(0);\nconst vec3 Amb= vec3(.01);\nconst vec3 PI = vec3(1.5707963,3.1415927,6.2831853);\nconst float BPM = 120.;\nvec2 uv;\nfloat tick;\n\nfloat rnd(vec3 s){s=fract(s*443.8975);s+=dot(s,s.yzx+19.19);return fract(s.x*s.y*s.z);}\nvec4  gamna(vec3 c){return vec4(pow(c,vec3(1./2.2)),1);}\nvec3  hsv(float h,float s,float v){return((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\nmat3  camera(vec3 p, vec3 t, vec3 h){vec3 w=normalize(p-t),u=normalize(cross(w,h));return mat3(u,normalize(cross(u,w)),w);}\nfloat dfPln(vec3 p, vec3 n, float d){return dot(p,n)+d;}\nfloat dfBox(vec3 p, vec3 b, float r){return length(max(abs(p)-b,0.))-r;}\n\nfloat trick(vec3 p) {\n    float d = V.z;\n    for (float i=0.; i<3.; i+=1.) {\n        d = min(d, dfBox(p-vec3(i*1.01-0.025,.5,0), vec3(.42-i*.01), .09));\n    }\n    return d;\n}\n\nfloat map(vec3 p, bool trick) {\n    float d = dfPln(p, vec3(0,1,0), 0.);\n    for (float i=0.; i<3.; i+=1.) {\n        d = min(d, dfBox(p-vec3(i*1.01-0.025,.5,0), vec3(.42-i*.01), .09));\n        d = min(d, dfBox(p-vec3(4.,.5,i), vec3(.4), .09));\n        d = min(d, dfBox(p-vec3(4.,i+.5,4.), vec3(.4), .09));\n    }\n    d = min(d, dfBox(p-vec3(3.,.5,0.), vec3(.4), .09));\n    d = min(d, dfBox(p-vec3(4.,.5,3.), vec3(.4), .09));\n    if (trick) {\n        d = min(d, min(dfBox(p-vec3(4.,3.5,4.), vec3(.4), .09),\n                       dfBox(p-vec3(4.,4.5,4.), vec3(.39), .09)));\n    }\n    return d;\n}\n\nvec3 background(vec3 pos, vec3 dir, inout float bld) {\n    bld = 0.;\n    return BG;\n}\n\nvec3 diff(vec3 nml, vec3 lit, vec3 col){return max(dot(nml,lit)*col,0.);}\nfloat shad(vec3 pos, vec3 lit){float s=V.z,t=.05,d;for(int i=20;i!=0;--i){t+=max(d=map(pos+lit*t, true),.05);s=min(s,d/t);if(t>20.)break;}return clamp(s*.2,0.,1.);}\nfloat occl(vec3 pos, vec3 nml){float s=0.;for(float t=.01;t<.8;t+=.05){s+=t-map(pos+nml*t, true);}return clamp(1.-s*.1,0.,1.);}\n\nbool tricktrace(vec3 pos, vec3 dir) {\n    float t = 0., d;\n    for (int i=80; i!=0; --i) {\n        t += (d = trick(pos + dir * t));\n        if (d < V.y) break;\n        if (t > V.z) return true;\n    }\n    return false;\n}\n\nvec3 trace(inout vec3 pos, inout vec3 dir, inout float bld) {\n    float t = 0., d;\n    bool trick = tricktrace(pos, dir);\n    for (int i=80; i!=0; --i) {\n        t += (d = map(pos + dir * t, trick));\n        if (d < V.y) break;\n        if (t > V.z) return bld * background(pos, dir, bld);\n    }\n    vec3 p = pos + dir * t;\n    vec3 n = normalize(vec3(map(p+V.yxx, true),map(p+V.xyx, true),map(p+V.xxy, true))-map(p, true));\n    vec3 c = vec3(1);\n    vec3 ldir = normalize(vec3(sin(tick/4.*PI.z)*5.+16.,10.,-15.) - p);\n    vec3 lcol = diff(n, ldir, vec3(10)) * shad(p, ldir) * occl(p, n) + Amb;\n    vec3 ldir2 = normalize(vec3(-5.,10.,15.) - p);\n    vec3 lcol2 = diff(n, ldir2, vec3(10)) * shad(p, ldir2) * occl(p, n) + Amb;\n    vec3 col = c * (lcol + lcol2);\n    float b=bld*.2;\n    pos = p + n*V.y;\n    dir = reflect(dir, n);\n    bld *= .8;\n    return mix(col, BG, clamp((length(p.xz)-1.)/16.,0.,1.))*b;\n}\n\nvec3 render(in vec3 pos, in vec3 dir) {\n    float b = 1.;\n    vec3 col = trace(pos, dir, b);\n    if (b > V.y) col += trace(pos, dir, b);\n    if (b > V.y) col += trace(pos, dir, b);\n    return col;\n}\n\nvec4 entryPoint(vec2 fragCoord) {\n    uv = (fragCoord * 2.-resolution) / resolution.y;\n    tick = time * BPM / 60.;\n\n    float scan = 1., dist = 0.;\n    vec3 pos = vec3(70.,70.,70.);\n    if (iMouse.z > .5) {\n        scan = (mod(fragCoord.y, 2.)+1.) * (1.-length(uv)*.3);\n        dist += (.0003/(uv.y+fract(tick/16.)*2.-1.));\n        vec2 r = mouse/resolution*2.-1.;\n        pos = vec3(70.+r.x*120.,70.+r.y*45.,70.-r.x*120.);\n    }\n    vec3 dir = camera(pos, vec3(2,0,2), vec3(0,1,0)) * normalize(vec3(uv+vec2(dist,0),-30));\n    return gamna(render(pos, dir)) * scan;\n}\n\nvoid mainImage(out vec4 flagColor,in vec2 flagCoord) {\n    resolution = iResolution.xy;\n    time = iTime;\n    mouse = iMouse.xy;\n    flagColor = entryPoint(flagCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBfRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 265, 265, 334], [335, 335, 355, 355, 391], [392, 392, 427, 427, 499], [500, 500, 537, 537, 623], [624, 624, 661, 661, 680], [681, 681, 718, 718, 753], [755, 755, 776, 776, 929], [931, 931, 962, 962, 1524], [1526, 1526, 1580, 1580, 1611], [1613, 1613, 1653, 1653, 1686], [1687, 1687, 1718, 1718, 1851], [1852, 1852, 1883, 1883, 1979], [1981, 1981, 2018, 2018, 2200], [2202, 2202, 2263, 2263, 3108], [3110, 3110, 3149, 3149, 3308], [3310, 3310, 3343, 3343, 3878], [3880, 3880, 3934, 3934, 4049]], "test": "untested"}
{"id": "XlBfRR", "name": "Ship in a Shell", "author": "dr2", "description": "Golden ship in a silvery shell (\"egg\" no.4)", "tags": ["raymarch", "glitter", "ship", "shell", "sail"], "likes": 10, "viewed": 513, "published": "Public API", "date": "1514117351", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Ship in a Shell\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEECapsDf (vec3 p, vec3 v1, vec3 v2, float r);\nfloat PrEllips2Df (vec3 p, vec2 r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\nvec3 RgbToHsv (vec3 c);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, shipConf, qHit, bDeck;\nvec2 opCs;\nfloat tCur, dstFar, opPhs, szFac, shipRot;\nint idObj;\nconst int idHull = 1, idRud = 2, idStruc = 3, idMast = 4, idSparT = 5, idSparL = 6, idSailT = 7,\n   idSailA = 8, idSailF = 9, idFlag = 10, idRig = 11, idShell = 21, idArm = 22, idHing = 23,\n   idMir = 24, idLeg = 25;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ShipDf (vec3 p)\n{\n  vec3 q, qq, w;\n  float dMin, d, fy, fz, gz, s, rRig, rSpar, yLim, zLim;\n  rRig = 0.02;\n  rSpar = 0.05;\n  p.yz = Rot2D (p.yz, -0.4 * shipConf.z);\n  p.xy = Rot2D (p.xy, 6. * shipConf.y);\n  p.y -= shipConf.x + 4.1 * szFac;\n  p /= szFac;\n  dMin = dstFar / szFac;\n  fy = 1. - 0.07 * p.y;\n  fz = 1. - 0.14 * step (1., abs (p.z));\n  zLim = abs (p.z) - 4.5;\n  q = p;\n  d = zLim;\n  q.z = mod (q.z + 1.4, 2.8) - 1.2;\n  d = max (d, PrCapsDf ((q - vec3 (0., 3.7 * (fz - 1.), 0.)).xzy, 0.1 * fy, 3.7 * fz));\n  DMINQ (idMast);\n  q = p;\n  yLim = abs (q.y - 0.2 * fz) - 3. * fz;\n  qq = q;\n  qq.y = mod (qq.y - 3.3 * (fz - 1.), 2. * fz) - fz;\n  qq.z = mod (qq.z + 1.4, 2.8) - 1.4 + 0.1 * fz;\n  d = max (max (min (d, PrCylDf (vec3 (qq - vec3 (0., 0.05 * fy * fz, 0.1 * fz - 0.23)).xzy,\n     0.15 * fy, 0.11 * fy * fz)), yLim), zLim);\n  DMINQ (idMast);\n  d = max (max (PrCapsDf (qq.yzx, 0.05, 1.23 * fy * fz), yLim), zLim);\n  DMINQ (idSparT);\n  q = p;\n  d = min (d, min (PrEECapsDf (q, vec3 (0., -3.5, 4.3), vec3 (0., -2.6, 6.7), rSpar),\n     PrEECapsDf (q, vec3 (0., -4., 4.1), vec3 (0., -2.9, 6.), rSpar)));\n  d = min (d, min (PrEECapsDf (q, vec3 (0., -1.2, -3.), vec3 (0., -0.5, -4.5), rSpar),\n     PrEECapsDf (q, vec3 (0., -2.7, -3.), vec3 (0., -2.7, -4.5), rSpar)));\n  DMINQ (idSparL);\n  q = p;\n  qq = q;\n  qq.y = mod (qq.y - 3.1 * (fz - 1.), 2. * fz) - fz;\n  qq.z = mod (qq.z + 1.4, 2.8) - 1.4 + 0.2 * (fz - abs (qq.y)) * (fz - abs (qq.y)) - 0.1 * fz;\n  d = max (max (max (PrBoxDf (qq, vec3 ((1.2 - 0.07 * q.y) * fz, fz, 0.01)),\n     min (qq.y, 1.5 * fy * fz - length (vec2 (qq.x, qq.y + 0.9 * fy * fz)))),\n     abs (q.y - 3. * (fz - 1.)) - 2.95 * fz), - PrBox2Df (qq.yz, vec2 (0.01 * fz)));\n  d = max (d, zLim);\n  DMINQ (idSailT);\n  q = p;\n  q.z -= -3.8;  q.y -= -1.75 - 0.2 * q.z;\n  d = PrBoxDf (q, vec3 (0.01, 0.9 - 0.2 * q.z, 0.6));\n  DMINQ (idSailA);\n  q = p;\n  q.yz -= vec2 (-1., 4.5);\n  w = vec3 (1., q.yz);\n  d = max (max (max (abs (q.x) - 0.01, - dot (w, vec3 (2.3, 1., -0.35))),\n     - dot (w, vec3 (0.68, -0.74, -1.))), - dot (w, vec3 (0.41, 0.4, 1.)));\n  DMINQ (idSailF);\n  q = p;\n  d = zLim;  \n  gz = (q.z - 0.5) / 5. + 0.3;\n  gz *= gz;\n  gz = 1.05 * (1. - 0.45 * gz * gz);\n  q.x = abs (q.x);\n  q.z = mod (q.z + 1.4, 2.8) - 1.4;\n  d = max (d, min (PrEECapsDf (q, vec3 (1.05 * gz, -3.25, -0.5), vec3 (1.4 * fz, -2.95, -0.05), 0.7 * rRig),\n     PrEECapsDf (vec3 (q.xy, abs (q.z + 0.2) - 0.01 * (0.3 - 2. * q.y)), vec3 (gz, -3.2, 0.),\n     vec3 (0.05, -0.9 + 2. * (fz - 1.), 0.), rRig)));\n  q = p;\n  d = min (d, PrEECapsDf (q, vec3 (0., -3., -4.45), vec3 (0., -2.7, -4.5), 0.8 * rRig));\n  d = min (min (d, min (PrEECapsDf (q, vec3 (0., 2.45, 2.65), vec3 (0., -2.7, 6.5), rRig),\n     PrEECapsDf (q, vec3 (0., 2.5, 2.65), vec3 (0., -3.2, 4.9), rRig))),\n     PrEECapsDf (q, vec3 (0., 2.6, -3.), vec3 (0., -0.5, -4.5), rRig));\n  q.x = abs (q.x);\n  d = min (d, PrEECapsDf (q, vec3 (0.65, -3.5, 3.5), vec3 (0.05, -2.7, 6.4), rRig));\n  s = step (1.8, q.y) - step (q.y, -0.2);\n  d = min (min (d, min (PrEECapsDf (q, vec3 (0.95, 0.4, 2.7) + vec3 (-0.1, 1.7, 0.) * s,\n     vec3 (0.05, 1.1, -0.15) + vec3 (0., 2., 0.) * s, rRig),\n     PrEECapsDf (q, vec3 (1.05, 1., -0.1) + vec3 (-0.1, 2., 0.) * s,\n     vec3 (0.05, 0.5, -2.95) + vec3 (0., 1.7, 0.) * s, rRig))),\n     PrEECapsDf (q, vec3 (0.95, 0.4, -2.9) + vec3 (-0.1, 1.7, 0.) * s,\n     vec3 (0.05, 0.9, -0.25) + vec3 (0., 2., 0.) * s, rRig));\n  DMINQ (idRig);\n  q = p;\n  q.yz -= vec2 (3.4, 0.18);\n  d = PrBoxDf (q, vec3 (0.01, 0.2, 0.3));\n  DMINQ (idFlag);\n  q = p;\n  d = zLim;\n  q.z = mod (q.z + 1.4, 2.8) - 1.4;\n  q.yz -= vec2 (-3.4, -0.4);\n  d = max (d, PrBoxDf (q, vec3 (0.3, 0.1, 0.5)));\n  DMINQ (idStruc);\n  q = p;\n  q.x = abs (q.x);\n  q.yz -= vec2 (-3.8, 0.5);\n  fz = q.z / 5. + 0.3;\n  fz *= fz;\n  fy = 1. - smoothstep (-1.3, -0.1, q.y);\n  gz = smoothstep (2., 5., q.z);\n  bDeck = vec3 ((1. - 0.45 * fz * fz) * (1.1 - 0.5 * fy * fy) *\n     (1. - 0.5 * smoothstep (-5., -2., q.y) * smoothstep (2., 5., q.z)),\n     0.78 - 0.8 * gz * gz - 0.2 * (1. - smoothstep (-5.2, -4., q.z)), 5. * (1. + 0. * 0.02 * q.y));\n  d = min (PrBoxDf (vec3 (q.x, q.y + bDeck.y - 0.6, q.z), bDeck),\n     max (PrBoxDf (q - vec3 (0., 0.72, -4.6), vec3 (bDeck.x, 0.12, 0.4)),\n     - PrBox2Df (vec2 (abs (q.x) - 0.4, q.y - 0.65), vec2 (0.2, 0.08))));\n  d = max (d, - PrBoxDf (vec3 (q.x, q.y - 0.58 - 0.1 * fz, q.z), vec3 (bDeck.x - 0.07, 0.3, bDeck.z - 0.1)));\n  q = p;\n  d = max (d, - max (PrBox2Df (vec2 (q.y + 3.35, mod (q.z + 0.25, 0.5) - 0.25), vec2 (0.08, 0.1)),\n     abs (q.z + 0.5) - 3.75));\n  DMINQ (idHull);\n  q = p;\n  d = PrBoxDf (q + vec3 (0., 4.4, 4.05), vec3 (0.03, 0.35, 0.5));\n  DMINQ (idRud);\n  return 0.7 * dMin * szFac;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qHitA;\n  float dMin, d, r, radH, radV, w, hWid, shUp;\n  int idObjA;\n  dMin = dstFar;\n  radH = 4.;\n  radV = 3.5;\n  w = 0.1;\n  hWid = 0.3;\n  q = p;  q.z += radH + 0.9 * hWid;\n  d = PrCapsDf (q.yzx, 0.25, 0.95);\n  DMINQ (idHing);\n  q.yz = Rot2Cs (q.yz, opCs);\n  q.y = abs (q.y);\n  q.yz = Rot2Cs (q.yz, opCs);\n  q.z -= hWid;\n  d = PrBoxDf (q, vec3 (0.95, 0.25, hWid));\n  d = max (d, - q.y);\n  DMINQ (idArm);\n  q.z -= radH + 0.9 * hWid;\n  r = radH + 0.1 * (1. - q.y / length (q)) * cos (32. * atan (q.x, q.z));\n  d = max (PrEllips2Df (q.xzy, vec2 (r, radV) + w), - PrEllips2Df (q.xzy, vec2 (r, radV) - w));\n  d = max (d, - q.y);\n  DMINQ (idShell);\n  shUp = 1.8 * opPhs;\n  q = p;  q.y -= -radV + 1.5 + shUp;\n  d = PrCylDf (q.xzy, 3., 0.1);\n  DMINQ (idMir);\n  q = p;  q.y -= -0.5 * (radV + 2. - shUp);\n  d = PrCylDf (q.xzy, 0.05, 0.5 * (radV - 2. + shUp));\n  q = p;  q.y -= - radV + 0.1;\n  d = min (d, PrCylDf (q.xzy, 0.5, 0.05));\n  DMINQ (idLeg);\n  idObjA = idObj;\n  qHitA = qHit;\n  q = p;  q.y -= 1.5 * szFac + shUp;\n  q.xz = Rot2D (q.xz, shipRot);\n  q.z += 1. * szFac;\n  d = ShipDf (q);\n  if (d < dMin) { dMin = d;  idObjA = idObj;  qHitA = qHit; }\n  idObj = idObjA;\n  qHit = qHitA;\n  return 0.9 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0005, -0.0005);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvoid EvalShipConf ()\n{\n  shipConf = vec3 (-4. * szFac, 0., 0.);\n}\n\nvoid ShipCol (vec3 vn, out vec4 col4, out vec2 vf)\n{\n  vec2 cg;\n  vf = vec2 (0.);\n  if (idObj == idHull) {\n    if (vn.y > 0.9 && qHit.y < -3.4 + 0.1 * step (3.2, qHit.z)) {\n      col4 = vec4 (0.5, 0.3, 0., 0.1) * (0.5 + 0.5 * SmoothBump (0.05, 0.95, 0.02, mod (8. * qHit.x, 1.)));\n    } else if (qHit.y > -4.) {\n      col4 = vec4 (0.7, 0.5, 0.1, 0.1);\n      if (abs (qHit.z - 4.) < 0.25 && abs (qHit.y + 3.55) < 0.05) col4 *= 1.2;\n      else if (qHit.z < -4. && abs (qHit.x) < 0.84 && abs (qHit.y + 3.62) < 0.125) {\n        cg = step (0.1, abs (fract (vec2 (6. * qHit.x, 8. * (qHit.y + 3.62)) + 0.5) - 0.5));\n        if (cg.x * cg.y == 1.) col4 = vec4 (0.8, 0.8, 0.2, -1.);\n        else col4 *= 0.8;\n      } else {\n        col4 *= 0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.02, mod (8. * qHit.y, 1.));\n        vf = vec2 (64., 0.3);\n      } \n    } else if (qHit.y > -4.05) {\n      col4 = vec4 (0.8, 0.8, 0.8, 0.1);\n    } else {\n      col4 = vec4 (0.3, 0.2, 0.1, 0.);\n      vf = vec2 (64., 2.);\n    }\n  } else if (idObj == idRud) {\n    col4 = vec4 (0.5, 0.3, 0., 0.);\n  } else if (idObj == idStruc) {\n    col4 = vec4 (0.4, 0.3, 0.1, 0.1);\n    if (max (abs (qHit.x), abs (qHit.z + 0.22)) < 0.2) {\n      cg = step (0.1, abs (fract (vec2 (10. * vec2 (qHit.x, qHit.z + 0.22)) + 0.5) - 0.5));\n      if (cg.x * cg.y == 1.) col4 = vec4 (0.8, 0.8, 0.2, -1.);\n    }\n  } else if (idObj == idSailT) {\n    qHit.x *= (1. + 0.07 * qHit.y) * (1. + 0.14 * step (1., abs (qHit.z)));\n    col4 = vec4 (1., 1., 1., 0.) * (0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.02, mod (4. * qHit.x, 1.)));\n    if (abs (qHit.z) < 0.2 && abs (abs (length (qHit.xy - vec2 (0., 0.3)) - 0.35) - 0.15) < 0.07)\n       col4 *= vec4 (1., 0.2, 0.2, 1.);\n  } else if (idObj == idSailA) {\n    col4 = vec4 (1., 1., 1., 0.) * (0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.02, mod (5. * qHit.z, 1.)));\n  } else if (idObj == idSailF) {\n    col4 = vec4 (1., 1., 1., 0.) * (0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.02,\n       mod (2.95 * qHit.y + 4. * qHit.z - 0.5, 1.)));\n  } else if (idObj == idFlag) {\n    col4 = vec4 (1., 1., 0.5, 0.1);\n    if (abs (abs (length (qHit.yz) - 0.1) - 0.04) < 0.02) col4 *= vec4 (1., 0.2, 0.2, 1.);\n  } else if (idObj == idMast) {\n    col4 = vec4 (0.7, 0.4, 0., 0.1);\n    if (length (qHit.xz) < 0.16 * (1. - 0.07 * qHit.y))\n       col4 *= 0.6 + 0.4 * SmoothBump (0.03, 0.97, 0.01, mod (2. * qHit.y / (1. + 0.14 * step (1., abs (qHit.z))), 1.));\n    if (qHit.y > 3.65) col4 = vec4 (1., 0., 0., -1.);\n  } else if (idObj == idSparT) {\n    qHit.x *= (1. + 0.07 * qHit.y) * (1. + 0.14 * step (1., abs (qHit.z)));\n    col4 = vec4 (0.7, 0.4, 0., 0.1) *  (0.6 + 0.4 * SmoothBump (0.08, 0.92, 0.01, mod (4. * qHit.x, 1.)));\n  } else if (idObj == idSparL) {\n    col4 = vec4 (0.7, 0.4, 0., 0.1);\n    if (qHit.z > 6.65) col4 = vec4 (1., 1., 0.3, -1.);\n  } else if (idObj == idRig) {\n    col4 = vec4 (0., 0.2, 0., 0.);\n    vf = vec2 (32., 0.5);\n  }\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 vf;\n  float dstObj, s;\n  bool isRefl;\n  szFac = 0.6;\n  EvalShipConf ();\n  isRefl = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar && idObj == idMir && qHit.y > 0. && length (qHit.xz) < 2.95) {\n    ro += dstObj * rd;\n    rd = reflect (rd, vec3 (0., 1., 0.));\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n    isRefl = true;\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vf = vec2 (0.);\n    if (idObj >= idHull && idObj <= idRig) ShipCol (vn, col4, vf);\n    else if (idObj == idShell) {\n      s = length (qHit / vec3 (4., 3.5, 4.));\n      col4 = (s > 1. || qHit.y < 0.05) ? vec4 (0.8, 0.8, 0.85, 0.2) : mix (vec4 (0.4, 0.4, 0.9, 0.1),\n         vec4 (0.9, 0.7, 0.7, 0.1), smoothstep (0.3, 0.5, 3.5 - qHit.y) * smoothstep (0.97, 0.98, s));\n      if (s > 1.) vf = vec2 (64., 0.5);\n    } else if (idObj == idArm || idObj == idMir || idObj == idLeg || idObj == idHing) {\n      col4 = vec4 (0.8, 0.8, 0.85, 0.2);\n      if (idObj == idHing) col4 *= 1. - 0.5 * SmoothBump (0.05, 0.1, 0.02, mod (4. * qHit.x, 1.));\n    }\n    if (vf.x > 0.) vn = VaryNf (vf.x * qHit, vn, vf.y);\n    if (col4.a >= 0.) col = col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 128.);\n    else col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));\n    if (idObj < idShell) {\n      col = RgbToHsv (col);\n      col = HsvToRgb (vec3 (0.15, 0.3 + 0.7 * sqrt (col.y), 0.9 * pow (col.z, 0.7)));\n    }\n    if (! isRefl || idObj == idShell && s > 1.)\n       col += 256. * pow (clamp (0.5 + 0.5 * dot (ltDir, reflect (rd, vn)), 0., 1.), 16.) *\n       pow (1. - 0.6 * abs (dot (normalize (ltDir - rd), VaryNf (1024. * qHit, vn, 2.))), 8.);\n    if (idObj < idShell || idObj == idShell && s < 1.) col *= 0.4 + 0.6 * smoothstep (0.1, 0.2, opPhs);\n  } else {\n    col = vec3 (0.6, 0.6, 1.) * (0.05 + 0.245 * (rd.y + 1.) * (rd.y + 1.)) *\n       (0.9 + 0.1 * SmoothBump (0.3, 0.7, 0.15, mod (64. * atan (rd.z, rd.x) / pi, 1.))) +\n       32. * pow (1. - 0.6 * abs (dot (rd, VaryNf (512. * vec3 (rd.xz, rd.y / length (rd.xz) +\n       0.01 * tCur).xzy, rd, 2.))), 8.);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  opPhs = SmoothBump (0.25, 0.85, 0.15, mod (0.1 * tCur, 1.));\n  opCs = vec2 (cos (0.2 * pi * opPhs), sin (0.2 * pi * opPhs));\n  shipRot = -0.05 * pi * tCur;\n  az = pi;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.5 * pi * (2. * mod (floor (0.04 * tCur), 2.) - 1.) *\n       SmoothBump (0.25, 0.65, 0.1, mod (0.04 * tCur, 1.));\n    el -= 0.05 * pi * sin (0.05 * pi * tCur);\n  }\n  el = clamp (el, -0.45 * pi, 0.45 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 2.7, -30.);\n  zmFac = 4.2 + 2. * opPhs;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrEECapsDf (vec3 p, vec3 v1, vec3 v2, float r)\n{\n  vec3 s, t;\n  s = p - v1;\n  t = v2 - v1;\n  return length (s - clamp (dot (s, t) / dot (t, t), 0., 1.) * t) - r;\n}\n\nfloat PrEllips2Df (vec3 p, vec2 r)\n{\n  return (length (p / r.xxy) - 1.) * min (r.x, r.y);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec3 RgbToHsv (vec3 c)\n{\n  vec4 p, q;\n  float d;\n  const float e = 1.e-10;\n  p = mix (vec4 (c.bg, vec2 (-1., 2./3.)), vec4 (c.gb, vec2 (0., -1./3.)), step (c.b, c.g));\n  q = mix (vec4 (p.xyw, c.r), vec4 (c.r, p.yzx), step (p.x, c.r));\n  d = q.x - min (q.w, q.y);\n  return vec3 (abs (q.z + (q.w - q.y) / (6. * d + e)), d / (q.x + e), q.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBfRR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 984, 1007, 1007, 5667], [5669, 5669, 5691, 5691, 6903], [6905, 6905, 6938, 6938, 7115], [7117, 7117, 7138, 7138, 7338], [7340, 7340, 7362, 7362, 7405], [7407, 7407, 7459, 7459, 10305], [10307, 10307, 10342, 10342, 12534], [12536, 12536, 12589, 12589, 13750], [13752, 13752, 13784, 13784, 13884], [13886, 13886, 13919, 13919, 14008], [14010, 14010, 14052, 14052, 14103], [14105, 14105, 14148, 14148, 14221], [14223, 14223, 14277, 14277, 14392], [14394, 14394, 14430, 14430, 14485], [14487, 14487, 14544, 14544, 14627], [14629, 14629, 14659, 14659, 14717], [14719, 14719, 14750, 14750, 14814], [14816, 14816, 14840, 14840, 14976], [14978, 14978, 15002, 15002, 15318], [15352, 15352, 15376, 15376, 15506], [15508, 15508, 15533, 15533, 15719], [15721, 15721, 15750, 15750, 15962], [15964, 15964, 16003, 16003, 16187]], "test": "untested"}
{"id": "XlBfzW", "name": "My Test Shader", "author": "xsc", "description": "This is a test shader i made", "tags": ["2d", "test", "shader"], "likes": 0, "viewed": 63, "published": "Public", "date": "1514712312", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n\tuv.x *= aspectRatio;\n    \n    float frame = float(iFrame) / 400.0;\n    \n    float radius = 0.2;\n\tvec2 centre = vec2(0.4 + frame, 0.5);\n    float d = distance(centre, uv);\n    \n\tfloat c = smoothstep(radius, radius - 0.01, d);  \n    \n    float secondRadius = 0.1;\n\tvec2 secondCentre = vec2(0.8 - frame, 0.5);\n\tfloat secondD = distance(secondCentre, uv);\n\tfloat secondC = smoothstep(secondRadius, secondRadius - 0.01, secondD);\n    \n    vec4 redColor = vec4(c, 0, 0, 1);\n\tvec4 greenColor = vec4(0, secondC, 0, 1);\n\tvec4 sum = redColor + greenColor;\n\n\tfragColor = sum;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBfzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 727]], "test": "untested"}
{"id": "XlfBD2", "name": "Virtual Dolphins", "author": "dr2", "description": "Kinetic trompe-l'oeil? - mouseable", "tags": ["raymarch", "refraction", "water", "mask"], "likes": 9, "viewed": 770, "published": "Public API", "date": "1513266335", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Virtual Dolphins\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrEllipsDf (vec3 p, vec3 r);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\n\nvec3 sunDir, pSize, fishPos, qHit;\nfloat tCur, dstFar, wWid, fishAngI;\nint idObj;\nconst float pi = 3.14159;\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  vec4 t4, v4;\n  vec2 q, t, tw;\n  float wFreq, wAmp, h;\n  h = -0.15;\n  q = p;\n  wFreq = 1.;\n  wAmp = 0.03;\n  tw = 0.5 * tCur * vec2 (1., -1.);\n  for (int j = 0; j < 4; j ++) {\n    q *= qRot;\n    t4 = q.xyxy * wFreq + tw.xxyy;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    v4 = (1. - abs (sin (t4))) * (abs (sin (t4)) + abs (cos (t4)));\n    t = 1. - sqrt (v4.xz * v4.yw);\n    h += wAmp * length (t); //dot (t, t);\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return h;\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 100; j ++) {\n    p = ro + s * rd;\n    h = p.y - WaveHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.05, h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - WaveHt (p.xz));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  p.xz = abs (p.xz) - 0.5 * pSize.xz;\n  return (max (p.x, p.z) > 0.) ? dstFar : dHit;\n}\n\nvec3 WaveNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy), WaveHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat FishDf (vec3 p)\n{\n  vec3 q;\n  float dMin, dBodyF, dBodyB, dMouth, dFinT, dFinP, dFinD, dEye, d, szFac;\n  szFac = 4.;\n  p *= szFac;\n  p.x = abs (p.x);\n  p.z -= 2.;\n  p.yz = Rot2D (p.yz, 0.2 * fishAngI);\n  q = p;\n  q.z -= -0.6;\n  dBodyF = PrEllipsDf (q, vec3 (0.7, 0.8, 2.4));\n  q = p;\n  q.z -= -1.2;\n  q.yz = Rot2D (q.yz, fishAngI);\n  q.z -= -1.6;\n  dBodyB = PrEllipsDf (q, vec3 (0.35, 0.5, 2.5));\n  q.z -= -2.2;\n  q.yz = Rot2D (q.yz, 2. * fishAngI);\n  q.xz -= vec2 (0.5, -0.5);\n  q.xz = Rot2D (q.xz, 0.4);\n  dFinT = PrEllipsDf (q, vec3 (0.8, 0.07, 0.4));\n  q = p;\n  q.yz -= vec2 (-0.3, 1.7);\n  q.yz = Rot2D (q.yz, 0.1);\n  q.y = abs (q.y) - 0.04;\n  dMouth = PrEllipsDf (q, vec3 (0.25, 0.12, 0.6));\n  q = p;\n  q.yz -= vec2 (0.7, -1.);\n  q.yz = Rot2D (q.yz, 0.6);\n  dFinD = PrEllipsDf (q, vec3 (0.05, 1., 0.35));\n  q = p;\n  q.xy = Rot2D (q.xy, 0.8);\n  q.xz -= vec2 (0.7, -0.1);\n  q.xz = Rot2D (q.xz, 0.6);\n  dFinP = PrEllipsDf (q, vec3 (0.9, 0.04, 0.3));\n  q = p;\n  q -= vec3 (0.4, -0.1, 1.1);\n  dEye = PrEllipsDf (q, vec3 (0.11, 0.15, 0.15));\n  idObj = 2;\n  dMin = SmoothMin (dBodyF, dBodyB, 0.3);\n  dMin = SmoothMin (dMin, dFinT, 0.1);\n  dMin = SmoothMin (dMin, dMouth, 0.15);\n  dMin = SmoothMin (dMin, dFinD, 0.02);\n  dMin = SmoothMin (dMin, dFinP, 0.02);\n  if (dEye < dMin) idObj = 3;\n  dMin = SmoothMin (dMin, dEye, 0.01);\n  qHit = q;\n  return dMin / szFac;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  int idObjA;\n  dMin = dstFar;\n  q = p;\n  d = PrBoxDf (q - vec3 (0., -0.5 * pSize.y, 0.), 0.5 * pSize + vec3 (wWid, 0., wWid));\n  d = max (d, - PrBoxDf (q - vec3 (0., -0.5 * pSize.y + 0.05, 0.), 0.5 * pSize));\n  d = max (d, - PrBoxDf (q  - vec3 (0., fishPos.y, 0.), vec3 (0.5 * pSize.x + wWid - 0.1, 0.5, 0.5)));\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  idObjA = idObj;\n  q = p - fishPos;\n  q.xz = Rot2D (q.xz, 0.5 * pi);\n  d = FishDf (q);\n  if (d < dMin) { dMin = d;  idObjA = idObj; }\n  idObj = idObjA;\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0005, -0.0005);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 50; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += 0.04;\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  if (rd.y >= 0.) {\n    ro.xz += 2. * tCur;\n    col = vec3 (0.1, 0.2, 0.4) + 0.2 * (1. - max (rd.y, 0.)) +\n       0.1 * pow (max (dot (rd, sunDir), 0.), 16.);\n    col = mix (col, vec3 (0.8), clamp (0.2 + Fbm2 (0.1 *\n       (ro.xz + rd.xz * (100. - ro.y) / max (rd.y, 0.001))) * rd.y, 0., 1.));\n  } else {\n    ro -= (ro.y / rd.y) * rd;\n    col = 0.7 * mix (vec3 (0.3, 0.4, 0.1), vec3 (0.4, 0.5, 0.2), Noisefv2 (256. * ro.xz)) *\n         (1. - 0.1 * Fbm2 (4. * ro.xz));\n  }\n  return col;\n}\n\nvec3 ShGrid (vec2 p)\n{\n  vec2 q, sq, ss;\n  q = p;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.3 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, colW, colC, vn, q, rg;\n  vec2 cg;\n  float dstWat, dstObj, aRefl, s, sh;\n  bool isBg, isBase, uWat;\n  aRefl = 0.;\n  colW = vec3 (0.);\n  colC = vec3 (0.);\n  col = BgCol (ro, rd);\n  isBg = true;\n  isBase = false;\n  uWat = false;\n  if (ro.y > 0.) {\n    dstObj = ObjRay (ro, rd);\n    dstWat = WaveRay (ro, rd);\n    if (dstWat < min (dstObj, dstFar)) {\n      ro += rd * dstWat;\n      vn = WaveNf (ro);\n      aRefl = 0.5 * smoothstep (0.9, 1., 1. - pow (dot (- rd, vn), 5.));\n      colW = BgCol (ro, reflect (rd, vn));\n      rd = refract (rd, vn, 1. / 1.3);\n      dstObj = ObjRay (ro, rd);\n      ro += rd * dstObj;\n      isBg = false;\n      uWat = true;\n      if (dot (vn, sunDir) > 0.) {\n        q = ro - (ro.y / sunDir.y) * sunDir;\n        q.xz = abs (q.xz) - 0.5 * pSize.xz;\n        if (max (q.x, q.z) < 0.) colC = 0.3 * vec3 (0.9, 0.9, 1.) *\n           pow (max (0., dot (WaveNf (q), sunDir)), 128.);\n      }\n    } else if (dstObj < dstFar) {\n      ro += rd * dstObj;\n      q.xz = abs (ro.xz) - 0.5 * pSize.xz;\n      s = max (q.x, q.z);\n      if (ro.y < 0. && s > wWid - 0.01 || ro.y >= 0. && s > 0.5) col = BgCol (ro, rd);\n      else isBg = false;\n    }\n  } else {\n    ro -= (ro.y / rd.y) * rd;\n    q.xz = abs (ro.xz) - 0.5 * pSize.xz - 0.5;\n    if (abs (max (q.x, q.z) + 0.2) < 0.2) {\n      col = vec3 (0.6, 0.4, 0.1);\n      vn = vec3 (0., -1., 0.);\n      isBg = false;\n      isBase = true;\n    }\n  }\n  if (! isBg) {\n    sh = 1.;\n    if (! isBase) {\n      vn = ObjNf (ro);\n      if (idObj == 1) {\n        cg = (abs (vn.y) < 0.01) ? ((abs (vn.x) > 0.99) ? ro.zy : ro.xy) : ro.xz;\n        rg = ShGrid (4. * cg);\n        if (abs (vn.y) < 0.01) {\n          if (abs (vn.x) > 0.99) {\n            rg.xz *= sign (vn.x);\n            if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n            else vn.xz = Rot2D (vn.xz, rg.x);\n          } else {\n            rg.xz *= sign (vn.z);\n            if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n            else vn.zx = Rot2D (vn.zx, rg.x);\n          }\n        } else {\n          if (vn.y > 0.99) {\n            if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);\n            else vn.yx = Rot2D (vn.yx, rg.x);\n          }\n        }\n        col = vec3 (0.6, 0.6, rg.y) * (1. - 0.2 * Fbm2 (64. * cg));\n      } else if (idObj == 2) {\n        col = vec3 (0.6, 1., 0.9) * (1. - 0.4 * smoothstep (-0.5, -0.4, vn.y));\n      } else if (idObj == 3) {\n        col = vec3 (1., 0.5, 0.2) * step (0.05, length (qHit.yz - vec2 (-0.02, 0.05)));\n      }\n      if (uWat) col *= vec3 (0.9, 1., 1.);\n      sh = 0.5 + 0.5 * ObjSShadow (ro, sunDir);\n    }\n    col = col * (0.5 + 0.5 * sh * max (dot (vn, sunDir), 0.)) +    \n       0.2 * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    col+= colC;\n  }\n  return pow (clamp (mix (col, colW, aRefl), 0., 1.), vec3 (0.9));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  pSize = vec3 (9., 3., 6.);\n  wWid = 2.5;\n  fishPos = vec3 ((0.5 * pSize.x + 2.) * (2. * mod (0.1 * tCur, 1.) - 1.), -1.5, 0.);\n  fishAngI = 0.15 * sin (pi * tCur);\n  dstFar = 50.;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = pi * mPtr.y;\n  } else {\n    el = -0.35 * pi + 0.4 * pi * SmoothBump (0.39, 0.61, 0.1, mod (0.06 * tCur, 1.));\n    az = pi * (2. * mod (floor (0.07 * tCur), 2.) - 1.) *\n       SmoothBump (0.25, 0.75, 0.1, mod (0.07 * tCur, 1.));\n  }\n  el = clamp (el, -0.4 * pi, 0.2 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -15.);\n  rd = vuMat * normalize (vec3 (uv, 4.2));\n  sunDir = normalize (vec3 (1., 5., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfBD2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 479, 502, 502, 1046], [1048, 1048, 1082, 1082, 1672], [1674, 1674, 1696, 1696, 1835], [1837, 1837, 1860, 1860, 3204], [3206, 3206, 3228, 3228, 3780], [3782, 3782, 3815, 3815, 3991], [3993, 3993, 4014, 4014, 4214], [4216, 4216, 4253, 4253, 4466], [4468, 4468, 4499, 4499, 4999], [5001, 5001, 5023, 5023, 5308], [5310, 5310, 5345, 5345, 8144], [8146, 8146, 8202, 8202, 9325], [9327, 9327, 9359, 9359, 9459], [9461, 9461, 9496, 9496, 9558], [9560, 9560, 9590, 9590, 9648], [9650, 9650, 9695, 9695, 9798], [9800, 9800, 9857, 9857, 9940], [9974, 9974, 9998, 9998, 10128], [10130, 10130, 10155, 10155, 10341], [10343, 10343, 10364, 10364, 10519]], "test": "untested"}
{"id": "Xlffzj", "name": "screenspace Moebius Spiral", "author": "FabriceNeyret2", "description": "Methodology for drawing isolines + dots of constant thickness in screenspace for procedural transforms (here, Moebius Spirals).\nGrey version are lines in final space (distorted in screen space).", "tags": ["spiral", "mobius", "complex", "screenspace", "tuto", "weave"], "likes": 12, "viewed": 637, "published": "Public API", "date": "1512494096", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// === Drawing transformed-space isolines using screen-space metrics ================\n// Inspired by \"Mobius Weave\" by Shane. https://shadertoy.com/view/XtsBRS\n// Cleaning and application here: https://www.shadertoy.com/view/llsfRj\n// Conformal version here: https://www.shadertoy.com/view/MllBzj\n\n#define UNIQ // if on, inverse gives one unique solution. Also, dist more robust !\n#define S(v) smoothstep(2./iResolution.y, 0., v )\n\n// --- direct transforms\nvec2 Mobius(vec2 p, vec2 z1, vec2 z2)\n{\n\tz1 = p - z1; p -= z2;\n\treturn mat2(z1,z1.y,-z1.x) * p / dot(p, p);\n}\n\nvec2 spiralZoom(vec2 p, vec2 offs, float n, float spiral, float zoom, vec2 phase)\n{\n\tp -= offs;\n\tfloat a = atan(p.y, p.x)/6.283 + iTime/32.;\n\tfloat d = length(p);\n\treturn mat2(n,1, spiral,-zoom) * vec2(a, log(d)) + phase;\n}\n\n// --- inverse transforms\nfloat k; // for tests\nvec4 iMobius(vec2 p, vec2 z1, vec2 z2, float s)      // s = -1 or 1, 2 solution for each\n{   float sb = 1.;\n#ifdef UNIQ                                          // ... or if activating signs,\n    s *= sign(p.x); sb = sign(p.y);                  // unique sol: s=1,x1,y1 otherwise 4\n#endif\n    float l = length(p), t = p.y/p.x,                // solve  u = v*l ; tan(u,v) = p.y/p.x\n          c = s / sqrt(1.+t*t),                      // c = cos(atan( ) )\n        v = length(z1-z2) / sqrt( 1.+ l*l -2.*l*c ), // c = (u²+v²-|z1z2|² ) / 2uv\n        u = v*l;                                   \n    vec2  a = 2.*(z1-z2);                            // solve |P-z1| = u ; |P-z2| = v\n    float b = u*u-v*v + dot(z2,z2)-dot(z1,z1);       // ||²-||²: a.P + b = 0\n    // y = -( b + a.x* x ) / a.y                     // normalize by a.y\n    b /= a.y; a /= a.y;                              // ( in Shane example a.y was = 0 ! )\n    float A = 1. +  a.x*a.x,                         //  |P-z1|² = u² , P = (x,y)\n          B =     2.* b*a.x -2.*dot(vec2(1,-a.x),z1),\n          C =           b*b +2.*b*z1.y + dot(z1,z1) - u*u,\n          D = max(0., B*B - 4.*A*C),\n         x1 = (-B+sb*sqrt(D))/(2.*A), y1 = -( b + a.x*x1 ),\n         x2 = (-B-sb*sqrt(D))/(2.*A), y2 = -( b + a.x*x2 );\n    k += 1./ (.1*abs(t)); // for tests\n // if (abs(A)<1e-5) { x1 = x2 = -C/B; y1 = y2 = -( b + a.x*x1 ) / a.y; } // degenerate case\n\treturn vec4(x1,y1, x2,y2);                       // 2 solutions per s\n}\n// horizontal red/blue glitches at t ~ 0 ( or D ~ 0 ) -> solved by #UNIQ\n// vertical red/blue glitches at t ~ inf ( or c ~ 0 )\n\nvec2 ispiralZoom(vec2 p, vec2 offs, float n, float spiral, float zoom, vec2 phase)\n{\n    p = inverse(mat2(n,1, spiral,-zoom)) * (p-phase) ;\n    p.x = (p.x - iTime/32.) * 6.283;             // ( p.x, p.y )  = ( a, log(d) )\n    return exp(p.y) * vec2(cos(p.x),sin(p.x)) + offs;\n}\n\n// --- demo configuration \nvec2 Z1 = vec2(-.875, -.525),  // in Shane example Z1.y=Z2.y was causing a degenerescence\n     Z2 = vec2(.375, -.125);\n\nvec2 MobiusSpiral(vec2 q)      // total direct transform\n{\n    q = Mobius(q, Z1, Z2);\n    return spiralZoom(q, vec2(-.5), 5., 3.14159*.2, .5, vec2(-1, 1)*iTime*.125);\n}\nfloat DrawInvMobiusSpiral(vec2 q, vec2 uv0, float r) // total inverse transform + draw iso-X\n{\n    vec4 v; float s = 0.;\n    q = ispiralZoom(q, vec2(-.5), 5., 3.14159*.2, .5, vec2(-1, 1)*iTime*.125);\n    v = iMobius(q, Z1, Z2, 1.);  \n#ifdef UNIQ\n    return S(length(uv0-v.xy) - r );\n#else\n    s += S(length(uv0-v.xy) - r ); // note that only the quadrant of uv0 contributes\n    s += S(length(uv0-v.zw) - r ); // (but costly to 1st determine it: transfo + inverse + tests )\n    v = iMobius(q, Z1, Z2, -1.);   \n    s += S(length(uv0-v.xy) - r ); \n    s += S(length(uv0-v.zw) - r ); \n\treturn s;\n#endif\n}\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n\tvec2 R = iResolution.xy,\n        uv0 = (U -.5*R) / R.y,\n    uv = MobiusSpiral(uv0);\n     \n    O -= O;\n    vec2 p = uv*4., q;\n  //O += .5*DrawInvMobiusSpiral(uv, uv0, .01 ); return; // check inverse ok ( = grey + white overlaps if !UNIQ )\n\n\n    if ( mod(iTime,2.) > 1. ) {\n        p = abs(fract(p+.5)-.5);                       // --- isolines in Moebius space\n        O += .5*float(min(p.x,p.y)<.1);\n        return;\n    }\n    \n    // --- to get iso-X in screenspace, \n    //     take it in final space ( floor(...) ),  inverse it, and draw distance to the result.\n    const int N = 2, dN = N/2-1;\n    for (int i=0; i<N; i++) {\n        //q = floor(p)/4.;\n        q = vec2( floor(p.x+float(i-dN)), p.y ) / 4.;  // --- H isolines in screen space\n        O.r += DrawInvMobiusSpiral(q, uv0, .005 );\n    \n        q = vec2( p.x, floor(p.y+float(i-dN)) ) / 4.;  // --- V isolines in screen space\n        O.b += DrawInvMobiusSpiral(q, uv0, .005 );\n    \n        for (int j=0; j<N; j++) {\n            q = floor(p+vec2(i-dN,j-dN) ) / 4.;        // --- dots in screen space\n            O.g += DrawInvMobiusSpiral(q, uv0, .02 );\n        }\n    }\n    //O += k/1e4; // for tests\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xlffzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[432, 457, 496, 496, 566], [568, 568, 651, 651, 791], [793, 841, 931, 931, 2321], [2322, 2450, 2534, 2534, 2727], [2729, 2876, 2934, 2934, 3044], [3045, 3045, 3139, 3139, 3645], [3647, 3647, 3683, 3683, 4848]], "test": "untested"}
{"id": "XllBD2", "name": "Minimalist Cube", "author": "glk7", "description": "Minimalist image of a cube.", "tags": ["2d", "3d", "lines", "minimalist"], "likes": 8, "viewed": 662, "published": "Public API", "date": "1513531413", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by genis sole - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n\n//David Hoskins hash: https://www.shadertoy.com/view/4djSRW \nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z)*2.0 - 1.0;\n}\n\nfloat gnoise(float p) \n{\n    float i = floor(p);\n\tfloat f = fract(p);\n    \n    float a = dot(hash11(i), f);\n    float b = dot(hash11(i + 1.0), f - 1.0);\n    \n    float u = smoothstep(0.0, 1.0, f);\n    return mix(a, b, u);\n}\n\nfloat segment(vec2 uv, float e, vec2 a, vec2 b)  {         \n    b -= a;\n    uv -= a;\n    return smoothstep(0.0003, 0.0003 + 1.5*e, \n                      length( uv - b * clamp(dot(b, uv) / dot(b, b), 0.0, 1.0)));\n}\n\nfloat point(vec2 uv, float e, vec2 p) \n{\n\treturn smoothstep(0.002, 0.002 + 1.5*e, length(uv - p)); \n}\n\nvec2 transform(vec3 p, vec4 q) \n{\n    p += 2.0 * cross(q.xyz, cross(q.xyz, p) + q.w * p);\n    return p.xy / (p.z + 10.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat e = 1.0 / iResolution.x;\n    vec2 uv = (fragCoord - iResolution.xy*0.5) * e;\n    \n    float t = iTime*0.3;\n    \n    vec3 a = vec3(gnoise(t + 2.0) * 3.1, \n                  gnoise(t + 6.0) * 3.5, \n                  gnoise(t + 4.0) * 3.2);\n    float s = clamp((gnoise(t + 10.0) + 0.5), -1.0, 1.0);\n    vec4 q = normalize(vec4(a * s, sqrt(1.0 - s*s))); \n    \n    vec2 b1 = transform(vec3(-1.0, -1.0, -1.0), q);\n    vec2 b2 = transform(vec3(-1.0, -1.0,  1.0), q);\n    vec2 b3 = transform(vec3( 1.0, -1.0,  1.0), q);\n    vec2 b4 = transform(vec3( 1.0, -1.0, -1.0), q);\n   \n    vec2 t1 = transform(vec3(-1.0, 1.0, -1.0), q);\n    vec2 t2 = transform(vec3(-1.0, 1.0,  1.0), q);\n    vec2 t3 = transform(vec3( 1.0, 1.0,  1.0), q);\n    vec2 t4 = transform(vec3( 1.0, 1.0, -1.0), q);\n    \n    vec2 o = transform(vec3(0.0), q);\n    \n    float v = 1.0;\n    v *= segment(uv, e, b1, b2);\n    v *= segment(uv, e, b2, b3);\n    v *= segment(uv, e, b3, b4);\n    v *= segment(uv, e, b4, b1);\n    \n    v *= segment(uv, e, t1, t2);\n    v *= segment(uv, e, t2, t3);\n    v *= segment(uv, e, t3, t4);\n    v *= segment(uv, e, t4, t1);\n    \n    v *= segment(uv, e, b1, t1);\n    v *= segment(uv, e, b2, t2);\n    v *= segment(uv, e, b3, t3);\n    v *= segment(uv, e, b4, t4);\n    \n    v *= point(uv, e, b1);\n    v *= point(uv, e, b2);\n    v *= point(uv, e, b3);\n    v *= point(uv, e, b4);\n    \n    v *= point(uv, e, t1);\n    v *= point(uv, e, t2);\n    v *= point(uv, e, t3);\n    v *= point(uv, e, t4);\n    v *= point(uv, e, o);\n    \n    fragColor = vec4(vec3(sqrt(v)), 1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XllBD2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[118, 179, 202, 202, 325], [327, 327, 351, 351, 550], [552, 552, 602, 602, 767], [769, 769, 809, 809, 870], [872, 872, 905, 905, 995], [997, 997, 1054, 1054, 2608]], "test": "untested"}
{"id": "XllBDl", "name": "Festive Pentagram", "author": "mla", "description": "Glowing pentagram (or other star polygon) in 3D.\n\nN controls number of sides\n\n[Jan 2019: now with mouse action]", "tags": ["star", "festive", "pentagram"], "likes": 14, "viewed": 4077, "published": "Public API", "date": "1513959918", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// (c) Matthew Arcus 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Glowing festive pentagram: ray trace 5 rotations of basic line, use\n// distance of ray to line to determine color.\n////////////////////////////////////////////////////////////////////////////////\n\nconst int N = 5; // Number of lines\nconst float scale = 4.0;\nconst float A = 0.6; // Light amplitude\nconst float K = 0.4; // Concentration\nconst float R = 1.0; // Radius\nconst float PI = 3.14159;\nconst float theta = 2.0*PI/float(N);\nconst mat3 m = mat3(cos(theta),sin(theta),0,\n                    -sin(theta),cos(theta),0,\n                    0,0,1);\n\nfloat det(vec2 c0, vec2 c1) {\n  return determinant(mat2(c0,c1));\n}\n\nvec2 closest0(vec3 p,vec3 q,vec3 r,vec3 s) {\n  // Use Cramer's rule to solve linear system\n  // Matrices are column major!\n  // Assume q and s are unit vectors\n  // No cross products, 4 dot products, 3 2x2 determinants\n  vec2 c0 = vec2(1.0,dot(q,s));\n  vec2 c1 = vec2(-dot(q,s),-1.0);\n  vec2 a = vec2(dot(r-p,q),dot(r-p,s));\n  return vec2(det(a,c1),det(c0,a))/det(c0,c1);\n}\n\n// return vec2(k,j) such that p + kq and\n// r + js are closest points on lines\n// Assumes q and s are normalized\nvec2 closest1(vec3 p,vec3 q,vec3 r,vec3 s) {\n  // Matrices are column major!\n  // Assume q and s are unit vectors\n  mat2 m = mat2(1.0,dot(q,s),-dot(q,s),-1.0);\n  return inverse(m)*vec2(dot(r-p,q),dot(r-p,s));\n}\n\n// Nice \"geometric\" solution from Wikipedia.\n// Probably not as fast as Cramer's rule,\n// 3 cross products, 4 dot products & a normalize\nvec2 closest2(vec3 p,vec3 q,vec3 r,vec3 s) {\n   vec3 n = normalize(cross(q,s));\n   vec3 n1 = cross(q,n); \n   vec3 n2 = cross(s,n);\n   return vec2(dot(r-p,n2)/dot(q,n2),\n               dot(p-r,n1)/dot(s,n1));\n}\n\nvec2 mmul(mat2 m, vec2 p) {\n  return vec2(m[0][0]*p[0]+m[1][0]*p[1],\n              m[0][1]*p[0]+m[1][1]*p[1]);\n}\n\nvec2 closest3(vec3 p,vec3 q,vec3 r,vec3 s) {\n  // Matrices are column major!\n  // Assume q and s are unit vectors\n  float k = dot(q,s);\n  mat2 m = mat2(-1.0,-k,k,1.0);\n  //return m*vec2(dot(r-p,q),dot(r-p,s))/(k*k-1.0);\n  return mmul(m,vec2(dot(r-p,q),dot(r-p,s)))/(k*k-1.0);\n}\n\nvec2 closest(vec3 p,vec3 q,vec3 r,vec3 s) {\n  return closest3(p,q,r,s);\n}\n\n// Distance is weird because we see lines from behind\n// the viewing plane.\nfloat dist(vec3 p,vec3 q,vec3 r,vec3 s) {\n   vec3 n = normalize(cross(q,s));\n   return abs(dot(n,p-r));\n}\n\n// Distance is weird because we see lines from behind\n// the viewing plane.\nfloat dist1(vec3 p,vec3 q,vec3 r,vec3 s) {\n  vec2 k = closest(p,q,r,s);\n  return distance(p+k.x*q,r+k.y*s);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb_smooth( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// Quaternion to rotation matrix\n// Assumes normalized\nmat3 qrot(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x*x, y2 = y*y, z2 = z*z;\n  float xy = x*y, xz = x*z, xw = x*w;\n  float yz = y*z, yw = y*w, zw = z*w;\n  return 2.0*mat3(0.5-y2-z2, xy+zw, xz-yw,\n                  xy-zw, 0.5-x2-z2, yz+xw,\n                  xz+yw, yz-xw, 0.5-x2-y2);\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  return p;\n}\n\nvoid mainImage(out vec4 outColor, vec2 fragCoord) {\n  vec2 xy = scale*(2.0*fragCoord - iResolution.xy)/iResolution.y;\n  // p+kq is viewing ray\n  vec3 p = vec3(0,0,-6);\n  vec3 q = vec3(xy,0)-p;\n  p = transform(p);\n  q = transform(q);\n  q = normalize(q);\n  \n  // r+js is polygon line, to be rotated in loop\n  vec3 r = vec3(0,1,0);\n  vec3 s = vec3(1,0,0);\n  // Rotation axis\n  vec3 axis = normalize(vec3(1,1,cos(0.1*iTime)));\n  float phi = iTime*0.15;\n  mat3 n = qrot(vec4(sin(phi)*axis,cos(phi)));\n  p = n*p; q = n*q;\n  float mindist = 1e10;\n  vec3 color = vec3(0); // Accumulate color here\n  for (int i = 0; i < N; i++) {\n    vec2 k = closest(p,q,r,s);\n    vec3 p1 = p+k.x*q;\n    vec3 r1 = r+k.y*s;\n    float d = distance(p1,r1);\n    float h = mod(0.3*(-iTime+log(1.0+abs(k.y))),1.0);\n    vec3 basecolor = hsv2rgb_smooth(vec3(h,1.0,1.0));\n    color += A*float(k.x > 0.0)*(1.0-pow(smoothstep(0.0,R,d),K))*basecolor;\n    s = m*s; r = m*r; // Rotate to next line\n  }\n  outColor = vec4(sqrt(color),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XllBDl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[476, 747, 776, 776, 813], [815, 815, 859, 1033, 1188], [1190, 1303, 1347, 1416, 1513], [1515, 1652, 1696, 1696, 1861], [1863, 1863, 1890, 1890, 1975], [1977, 1977, 2021, 2090, 2254], [2256, 2256, 2299, 2299, 2329], [2331, 2407, 2448, 2448, 2512], [2514, 2590, 2632, 2632, 2699], [2701, 2796, 2830, 2830, 3006], [3008, 3063, 3082, 3082, 3372], [3374, 3374, 3404, 3404, 3454], [3456, 3456, 3483, 3483, 3714], [3716, 3716, 3767, 3767, 4716]], "test": "untested"}
{"id": "XllBRf", "name": "shiny. spheres.", "author": "dahart", "description": "Spheres, shiny spheres, and even more and shinier spheres! A stack based recursive ray tracer. Scrub time with mouse.", "tags": ["ray", "spheres", "recursive", "tracing", "shiny"], "likes": 6, "viewed": 512, "published": "Public", "date": "1512723971", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// crank this up until your GPU chokes\nconst int nSpheres = 10; \n\n\nconst float sphereRadius = 3.0 / log2(float(nSpheres));\n\nconst float tau = 6.28318;\nconst float inf = 999.0;\n\nstruct Hit { \n    float t; \n    vec3 p; \n    vec3 n;\n    int id;\n};\n\nHit noHit;\n\nHit sphereHit(vec3 center, float radius, vec3 rayOrigin, vec3 rayDirection, int id) {\n    float a = dot(rayDirection, rayDirection);\n    vec3 L = rayOrigin - center;\n    float b = 2.0 * dot(rayDirection, L);\n    float c = dot(L, L) - radius*radius;\n    float discrim = b*b - 4.0*a*c;\n    if (discrim < 0.0) return noHit;\n    float t = (-b - sqrt(discrim)) / (2.0 * a);\n    if (t < 0.0) return noHit;\n    vec3 p = rayOrigin + t*rayDirection;\n    return Hit(t, p, normalize(p-center), id);\n}\n\nHit hitSomething(vec3 rayOrigin, vec3 rayDirection, float time) {\n    const float fns = float(nSpheres);\n\n    Hit minHit = noHit;\n\n    for (int i = 0; i < nSpheres; i++) {\n        float fi = float(i);\n        float fni = fi / fns;\n        float d = 3.0 * sin(time * fni + fi);\n        vec3 center = vec3(d*cos(tau*fni+time*10.0*fni)+sin(time*10.0), \n                       d*sin(tau*fni+time*10.0*fni), \n                       d*sin(0.5*tau*fni+time*fni*1.4142)+cos(time*10.0));\n        \n        Hit hit = sphereHit(center, sphereRadius + sphereRadius*2.0*pow(float(i%10)/10.0, 5.0), rayOrigin, rayDirection, 0);\n        if (hit.t <= 0.0 || hit.t > minHit.t) continue;\n        minHit = hit;\n    }\n\n    Hit hit = sphereHit(vec3(0.0, -41.5, 2.0), 40.0, rayOrigin, rayDirection, 1);\n    if (hit.t > 0.0 && hit.t < minHit.t) minHit = hit;\n\n    return minHit;\n}\n\nvec3 colorSomething(Hit hit, float time, vec3 rayOrigin, vec3 rayDirection, mat3x3 cam) {\n    if (hit.t > inf - 0.5) return vec3(0.0, 0.75+0.25*sin(time), 1.0);\n\n    vec3 color;\n\n    // diffuse\n    if (hit.id == 0) {\n        float dup    = 1.0 * dot(hit.n, cam[1]) + 0.0;\n        float dright = 1.0 * dot(hit.n, cam[0]) + 0.0;\n        float dfwd   = 1.0 * dot(hit.n, -cam[2] ) + 0.0;\n        color = vec3(dright, dup, dfwd);\n    } else if (hit.id == 1) {\n        float check = 0.4 + 0.6 * float(int(mod(hit.p.x, 2.0)) ^ int(mod(hit.p.z, 2.0)));\n        color = vec3(check, check, 0.1);\n    }\n\n    // specular\n    vec3 refl = reflect(rayDirection, hit.n);\n    float spec = pow(dot(refl, cam[1]), 20.0);\n    if (spec > 0.0) color += vec3(spec, spec, spec);\n\n    return color;\n}\n\nconst int maxDepth = 4;\nvec3 trace( mat3x3 cam, vec3 rayOrigin, vec3 rayDirection, float time )\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    float ref = 1.0;\n    for (int i = 0; i < maxDepth; i++) {\n        Hit minHit = hitSomething(rayOrigin, rayDirection, time);\n        color += ref * colorSomething(minHit, time, rayOrigin, rayDirection, cam);\n        if (minHit.id < 0) break;\n        ref *= 0.6;\n        rayOrigin = minHit.p;\n        rayDirection = reflect(rayDirection, minHit.n);\n    }\n    color = color * 0.8;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 zero = vec3(0.0, 0.0, 0.0);\n    noHit = Hit(inf, zero, zero, -1);\n    \n    // make time optionally srubbable\n    float time = (iMouse.z > 0.0) ? iMouse.x / iResolution.x :  iTime / 20.0;\n\n    float camDist = 8.0;\n    vec3 rayOrigin = vec3(1.1*camDist*sin(tau * time * 0.5), 0.0, 0.9*camDist*cos(tau * time * 0.5));\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - vec2(1.0, 1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    vec3 fwd   = normalize(lookat - rayOrigin);\n    vec3 right = normalize(cross(fwd, up));\n    vec3 camup = normalize(cross(right, fwd));\n    vec3 rayDirection = normalize(fwd + 0.5 * (uv.x*right + uv.y*up));\n    \n    fragColor = vec4(trace(mat3x3(right, camup, fwd), rayOrigin, rayDirection, time), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XllBRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 260, 345, 345, 749], [751, 751, 816, 816, 1607], [1609, 1609, 1698, 1698, 2384], [2410, 2410, 2483, 2483, 2923], [2925, 2925, 2982, 2982, 3806]], "test": "untested"}
{"id": "XllfzS", "name": "Optical illusion", "author": "kobilica", "description": "Classic optical illusion. Stare into center for ~30 seconds, then look away into something that has a lot of detail. You should see bending effect. \nI repeat, white walls can't bend since it's all white, so look away into something with more detail.", "tags": ["opticalillusion", "manhattan"], "likes": 4, "viewed": 141, "published": "Public", "date": "1512313079", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = abs(fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    \n    float speed = 24.0;\n    float frequency = 128.0;\n    \n    float dist = uv.x + uv.y;\n    \n    float color = 0.5 + 0.5*sin(frequency*dist + speed*iTime);\n    \n\tfragColor = vec4(vec3(color) ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XllfzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 328]], "test": "untested"}
{"id": "XlsBD2", "name": "NotAKnot2", "author": "balkhan", "description": "It may be a trivial knot but I understand it :-D", "tags": ["raymarch", "knot"], "likes": 15, "viewed": 151, "published": "Public", "date": "1513393815", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tloop_circle(vec3 p);\nfloat\tcircle(vec3 p, float phase);\nfloat\tsdTorus( vec3 p, vec2 t, float phase );\nfloat\tmylength(vec2 p);\nfloat\tnrand( vec2 n );\n\nfloat \tt;\t\t\t// time\nvec3\tret_col;\t// torus color\nvec3\th; \t\t\t// light amount\n\n#define I_MAX\t\t100.\n#define E\t\t\t0.001\n#define FAR\t\t\t15.\n#define PI\t\t\t3.14\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 0.0);\n\n    pos.z = 7.5+1.5*sin(t*15.);    \n    h*=0.;\n    vec2\tinter = (march(pos, dir));\n    if (inter.y <= FAR)\n        col.xyz = ret_col*(1.-inter.x*.0025);\n    else\n        col *= 0.;\n    col += h*.005125;\n    c_out =  vec4(col,1.0);\n}\n\nfloat\tscene(vec3 p)\n{  \n    float\tvar;\n    float\tmind = 1e5;\n    rotate(p.xz, 1.57-.5*iTime);\n    rotate(p.yz, 1.57-.75*iTime);\n    var = atan(p.x,p.y);\n    vec2 q = vec2( length(p.xy) -2.,p.z);\n    rotate(q, var*(.5) + iTime*2.*1.);\n    q.x = abs(q.x);\n    q.x -= .25+.75*sin(t*3.);\n    \n    var = cos( floor(var*40.) + t*15.);\n    ret_col = vec3(.5-var*.5, .5-var*.1251, .53+var*.2);\n    mind = max(abs(q.x), abs(q.y)+q.x*.5)-.5-.025*var*3.;\n    h -= vec3(.35,.25,.5)*.075/(.021+max(mind-var*.1, .01)*max(mind-var*.1, .01) );\n    h += 1.5-vec3(.75,.215,.1)*.05/(.0051+mind*mind);\n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n\t    \tp = pos + dir * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x*.5; // makes artefacts disappear\n\t        if (dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n    \n    p = p*p*p*p;\n    p = p*p;\n    ret = (p.x+p.y);\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,\n           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,\n           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsBD2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[427, 567, 610, 610, 1018], [1020, 1020, 1041, 1041, 1622], [1624, 1624, 1656, 1656, 2067], [2069, 2069, 2093, 2093, 2211], [2213, 2227, 2267, 2267, 2342], [2344, 2344, 2372, 2372, 2480], [2482, 2482, 2504, 2504, 2710], [2712, 2712, 2762, 2762, 3025]], "test": "untested"}
{"id": "XlsBRj", "name": "Rainbow Flower", "author": "jennyveens", "description": "Testing out shaping functions", "tags": ["2d"], "likes": 0, "viewed": 62, "published": "Public", "date": "1512486806", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = fragCoord.xy/iResolution.xy;\n\tvec3 color = vec3(0.0);\n\n\tvec2 pos = vec2(0.5)-xy;\n\n\tfloat r = length(pos)*2.0;\n\tfloat a = atan(pos.y, pos.x);\n\n\tfloat f = cos(a*3.0);\n\tf = abs(cos(a*3.0));\n\tf = abs(cos(a*2.5))*0.5+0.3;\n\tf = abs(cos(a*8.0))*sin(a*6.0)*0.4+0.2;\n\n\tcolor = vec3(\n\t\t1.0 - (sin(iTime)-smoothstep(f, f+0.25, r)), // R\n\t\t1.0 - (cos(iTime)-smoothstep(f, f+0.1, r)),  // G\n\t\t1.0 - (sin(iTime)-smoothstep(f, f+0.5, r))   // B\n\t);\n\n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsBRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 536]], "test": "untested"}
{"id": "XlsBRs", "name": "Perpetual Pipe Dream 2", "author": "KilledByAPixel", "description": "I optimized the shader and fixed some bugs. The pipes are more pipelike and interconnected then the original. Also played with the colorization rule and spacial warping.", "tags": ["2d", "fractal", "zoom", "pixel", "endless", "recursion"], "likes": 8, "viewed": 173, "published": "Public", "date": "1513442790", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////////////////////////////////////\n// Perpetual Pipe Dream 2 - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= -0.5;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.2;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 5;\t// how deep to recurse\nconst float recursionFadeDepth\t= 3.0;\t// how deep to fade out\nconst int glyphSize\t\t\t\t= 5;\t// width & height of glyph in pixels\nconst int glyphCount\t\t\t= 16;\t// how many glyphs total\nconst float glyphMargin\t\t\t= 0.0;\t// how much to center the glyph in each pixel\nconst float timeWarp\t\t\t= 1.0;\t// time warp to add curvature\nconst int glyphs[glyphSize*glyphCount] = int[]\n(// glyph sheet - pipes corospond to neighbor connection bits\n 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x0DFE0, 0x0DFE0, 0x0DFE0, 0x0DFE0, 0x0DFE0, 0x0DFE0, 0x0DFE0, 0x0DFE0,\n 0x05760, 0x00057, 0x76000, 0x77777, 0x00000, 0x00577, 0x77600, 0x77777, 0x09FA0, 0x0DFF7, 0x7FFE0, 0x7FFF7, 0x0DFE0, 0x0DFF7, 0x7FFE0, 0x7FFF7,\n 0x0DFE0, 0x001FF, 0xFF200, 0xFFFFF, 0x00400, 0x05FFF, 0xFFF60, 0xFFFFF, 0x00800, 0x09FFF, 0xFFFA0, 0xFFFFF, 0x0DFE0, 0x0DFFF, 0xFFFE0, 0xFFFFF,\n 0x09BA0, 0x0009B, 0xBA000, 0xBBBBB, 0x05F60, 0x0DFFB, 0xBFFE0, 0xBFFFB, 0x00000, 0x009BB, 0xBBA00, 0xBBBBB, 0x0DFE0, 0x0DFFB, 0xBFFE0, 0xBFFFB,\n 0x00000, 0x00000, 0x00000, 0x00000, 0x0DFE0, 0x0DFE0, 0x0DFE0, 0x0DFE0, 0x00000, 0x00000, 0x00000, 0x00000, 0x0DFE0, 0x0DFE0, 0x0DFE0, 0x0DFE0\n);// o       x-       -x       ╾        ,       ┍        ┑       ┭       '       ┖        ┚       ┶       ┃      ┝         ┦       ╀\n//0000=0   0001=1   0010=2   0011=3   0100=4   0101=5   0110=6   0111=7   1000=8   1001=9   1010=A   1011=B   1100=C   1101=D   1110=E   1111=F\n//TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR     TBLR\n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float glyphSizeF = float(glyphSize) + 2.0*glyphMargin;\nconst float glyphSizeLog = log(glyphSizeF);\nconst int powTableCount = 8;\nconst float gsfi = 1.0 / glyphSizeF;\nconst float powTable[powTableCount] = float[]( 1.0, gsfi, pow(gsfi,2.0), pow(gsfi,3.0), pow(gsfi,4.0), pow(gsfi,5.0), pow(gsfi,6.0), pow(gsfi,7.0));\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\n\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5433)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\nvec3 HsvToRgb(vec3 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec3(s_n) + vec3(s) * cos(2.0 * pi * (c.x + vec3(1.0, 0.6666, .3333)));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent - recursionFadeDepth, 0.0);\n    float rc = float(recursionCount) - recursionFadeDepth;\n    return rt / rc;\n}\n\nfloat GetRecursionFade2(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent, 0.0);\n    float rc = float(recursionCount);\n    return rt / rc;\n}\n\nvec3 InitPixelColor() \n{ \n    vec3 color = vec3(0,0.4,0.1);\n    color.x -= (0.033*iTime);\n    return color; \n}\n\nvec3 CombinePixelColor(vec3 color, float timePercent, int i, int r, vec2 pos, ivec2 glyphPos, ivec2 glyphPosLast)\n{\n    float f = GetRecursionFade(r, timePercent);\n    //if (f == 0.0)\n    //    return color;\n    \n    vec3 myColor = vec3\n    (\n    \tmix( 0.5, 0.7, RandFloat(i + r + 419*glyphPosLast.x + 773*glyphPosLast.y)),\n    \tmix(-0.7, 0.7, RandFloat(i + r + 929*glyphPosLast.x + 499*glyphPosLast.y)),\n        1.0\n    );\n    //\n    //float f2 = smoothstep(3.0, 4.0, float(r) + timePercent);\n    //if (r == 5|| r == 6)\n    //    myColor.x = mix(-0.5, 0.5, RandFloat(i + r + 419*glyphPosLast.x + 773*glyphPosLast.y)),\n\n    // combine with my color\n    myColor.x = pow(myColor.x, 3.0);\n    myColor.y = pow(myColor.y, 3.0);\n    float f2 = GetRecursionFade2(r, timePercent);\n    color.x += f2*myColor.x;\n    color.y = max(min( color.y + myColor.y*f2, 1.0), 0.0);\n    color.z = max(color.z, myColor.z*f);\n    return color;\n}\n\nvec3 FinishPixel(vec3 color, vec2 uv)\n{\n    // rotate over time\n    float theta = 0.01177*iTime;\n\tfloat c = cos(theta);\n\tfloat s = sin(theta);\n    uv *= mat2(-s, c, c, s);\n    \n    // color wander\n    color.x += (0.1*uv.y + 0.1*uv.x + 0.01*iTime);\n    \n    // convert to rgb\n    color = HsvToRgb(color);\n    return color;\n}\n\nvec2 InitUV(vec2 uv)\n{\n\t// wave\n\tuv.x += 0.005*sin(10.0*uv.y + 0.51*iTime);\n\tuv.y += 0.005*sin(10.0*uv.x + 0.53*iTime);\n\tuv.x += 0.05*sin(2.0*uv.y + 0.57*iTime);\n\tuv.y += 0.05*sin(2.0*uv.x + 0.55*iTime);\n    \n    // rotate over time\n    float theta = 0.01*iTime;\n\tfloat c = cos(theta);\n\tfloat s = sin(theta);\n\tuv = vec2((uv.x*c - uv.y*s), (uv.x*s + uv.y*c));\n    \n    return uv;\n}\n\nfloat TimeWarp(vec2 uv)\n{\n    // time warp to add add some 3d curve\n    return timeWarp*(uv.x*uv.x + uv.y*uv.y);\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Fractal functions\n\nint GetFocusGlyph(int i) { return RandInt(i) % glyphCount; }\nint GetGlyphPixelRow(int y, int g) { return glyphs[g + (glyphSize - 1 - y)*glyphCount]; }\n\nint GetGlyphPixel(ivec2 pos, int g)\n{\n    // pull glyph out of hex\n\tint glyphRow = GetGlyphPixelRow(pos.y, g);\n    return min(1, 0xF & (glyphRow >> (glyphSize - 1 - pos.x) * 4));\n}\n\nivec2 focusList[max(powTableCount, recursionCount) + 2];\nivec2 GetFocusPos(int i) { return focusList[i+2]; }\n\nint neighborsGrid[glyphSize*glyphSize];\nvoid GetNeighbors(int lastGlyph)\n{\n    for (int y = glyphCount*(glyphSize - 1), z = -1; y >= 0; y -= glyphCount)\n    {\n\t\tint glyphRow = glyphs[lastGlyph + y];\n        for (int x = 4*(glyphSize-1); x >= 0; x -= 4)\n            neighborsGrid[++z] = (0xF & (glyphRow >> x));\n    }\n    \n    // slower way of building neigbors if not precomputed\n    /*for (int y = 0; y < glyphSize; ++y)\n    for (int x = 0; x < glyphSize; ++x)\n    {\n        int neighbors = 0;\n        if (GetGlyphPixel(ivec2(x, y), lastGlyph) != 0)\n        {\n            neighbors |= GetGlyphPixel(ivec2(x+1, y), lastGlyph) << 0; // right\n            neighbors |= GetGlyphPixel(ivec2(x-1, y), lastGlyph) << 1; // left\n            neighbors |= GetGlyphPixel(ivec2(x, y-1), lastGlyph) << 2; // top\n            neighbors |= GetGlyphPixel(ivec2(x, y+1), lastGlyph) << 3; // bottom\n        }\n        \n        neighborsGrid[x + y*glyphSize] = neighbors;\n    }*/\n}\n\nivec2 CalculateFocusPos(int iterations)\n{\n    int glyphLast = GetFocusGlyph(iterations-1);\n    \n  \t// current focus glyph must appear in correct location\n    int focusGlyph = GetFocusGlyph(iterations); \n    \n    // find all pixels that have the right neighbors (or more) for focus glyph\n    ivec2 validPlaces[glyphSize*glyphSize];\n    int c = 0;\n    \n    ivec2 pos;\n    for (int y = glyphCount*(glyphSize - 2), z = -1; y >= 1; y -= glyphCount)\n    {\n\t\tint glyphRow = glyphs[glyphLast + y];\n        for (int x = 4*(glyphSize-2); x >= 1; x -= 4)\n        {\n            int neighbors = (0xF & (glyphRow >> x));\n            if (neighbors > 0 && ((neighbors & focusGlyph) == focusGlyph))\n                validPlaces[c++] = ivec2(glyphSize - 1 - x/4, glyphSize - 1 -y/glyphCount);\n        }\n    }\n\n    // pick one at random\n    return validPlaces[RandInt(iterations) % c];\n}\n  \nint GetGlyph(int iterations, ivec2 glyphPos, int glyphLast, ivec2 glyphPosLast, bool isFocus, ivec2 focusPos)\n{ \n    GetNeighbors(glyphLast);\n\n    // randomly remove some links\n    int r = iterations + 17*glyphPosLast.x + 23*glyphPosLast.y;\n    // random change over time\n    //r += 23*int(0.01*float((11*glyphPos.x + 7*glyphPos.y + 17*glyphPosLast.x + 13*glyphPosLast.y))+ float(glyphLast)/float(glyphCount) + 0.1*iTime);\n    \n   \tint removeCount = 10 + RandInt(++r) % 40;\n    for (int i = 0; i < removeCount; ++i)\n    {\n        int x = RandInt(++r) % (glyphSize);\n        int y = RandInt(++r) % (glyphSize);\n        \n        // remove a link\n        int neighbors = neighborsGrid[x + y*glyphSize];\n        int bit = 3*(RandInt(++r) % 2);\n        neighbors = neighbors & ~(1 << bit);\n        \n        // prevent orphans\n        if (neighbors == 0 && (RandInt(++r) % 5 < 4))\n            continue;\n        if (bit == 0)\n        {\n            if (x == glyphSize-1) continue;\n            int n = neighborsGrid[(x+1) + y*glyphSize] & ~(1 << 1);\n            if (n == 0) continue;\n            neighborsGrid[(x+1) + y*glyphSize] = n;\n        }\n        if (bit == 3)\n        {\n            if (y == glyphSize-1) continue;\n            int n = neighborsGrid[x + (y+1)*glyphSize] & ~(1 << 2);\n            if (n == 0) continue;\n            neighborsGrid[x + (y+1)*glyphSize] = n;\n        }\n        \n        neighborsGrid[x + y*glyphSize] = neighbors;\n    }\n    \n    if (isFocus)\n    {\n        // stamp down the focus glyph\n        int x = focusPos.x;\n        int y = focusPos.y*glyphSize;\n        int n = GetFocusGlyph(iterations);\n        neighborsGrid[x + y] = n; \n        \n        // fix up neighbors\n        neighborsGrid[(x-1) + y] = (0 == (n & (1 << 1)))? \n            neighborsGrid[(x-1) + y] & ~(1 << 0) : neighborsGrid[(x-1) + y] | (1 << 0);\n        neighborsGrid[(x+1) + y] = (0 == (n & (1 << 0)))?\n            neighborsGrid[(x+1) + y] & ~(1 << 1) : neighborsGrid[(x+1) + y] | (1 << 1);\n        neighborsGrid[x + y-glyphSize] = (0 == (n & (1 << 2)))?\n            neighborsGrid[x + y-glyphSize] & ~(1 << 3) : neighborsGrid[x + y-glyphSize] | (1 << 3);\n        neighborsGrid[x + y+glyphSize] = (0 == (n & (1 << 3)))?\n            neighborsGrid[x + y+glyphSize] & ~(1 << 2) : neighborsGrid[x + y+glyphSize] | (1 << 2);\n    }\n    \n    return neighborsGrid[glyphPos.x + glyphPos.y*glyphSize];\n}\n\n// get color of pos, where pos is 0-1 point in the glyph\nvec3 GetPixelFractal(vec2 pos, int iterations, float timePercent)\n{\n    int glyphLast = GetFocusGlyph(iterations-1);\n\tivec2 glyphPosLast = GetFocusPos(-2);\n\tivec2 glyphPos =     GetFocusPos(-1);\n    \n\tbool isFocus = true;\n    ivec2 focusPos = glyphPos;\n    \n\tvec3 color = InitPixelColor();\n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t{\n        color = CombinePixelColor(color, timePercent, iterations, r, pos, glyphPos, glyphPosLast);\n        \n        //if (isFocus && r == 3 && glyphPos == GetFocusPos(r-1))\n\t    //    color.z += 1.0; // debug - show focus\n        \n        if (r > recursionCount)\n\t\t\treturn color;\n           \n        // update pos\n        pos -= vec2(glyphMargin*gsfi);\n        pos *= glyphSizeF;\n\n        // get glyph and pos within that glyph\n        glyphPosLast = glyphPos;\n        glyphPos = ivec2(pos);\n\n        // check pixel\n        int glyphValue = GetGlyphPixel(glyphPos, glyphLast);\n\t\tif (glyphValue == 0)\n\t\t\treturn color;\n        \n        // next glyph\n\t\tpos -= vec2(floor(pos));\n        focusPos = isFocus? GetFocusPos(r) : ivec2(-10);\n        glyphLast = GetGlyph(iterations + r, glyphPos, glyphLast, glyphPosLast, isFocus, focusPos);\n        isFocus = (glyphPos == focusPos);\n\t}\n}\n \n//////////////////////////////////////////////////////////////////////////////////\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\n    uv = InitUV(uv);\n\t\n\t// get time \n    float timePercent = (3.0 + iTime + 180.+TimeWarp(uv))*zoomSpeed;\n\tint iterations = int(floor(timePercent));\n\ttimePercent -= float(iterations);;\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -glyphSizeLog*timePercent);\n\tzoom *= zoomScale;\n    \n    // cache focus positions\n    for(int i = 0; i  < powTableCount + 2; ++i)\n      focusList[i] = CalculateFocusPos(iterations+i-2);\n    \n\t// get offset\n\tvec2 offset = vec2(0);\n\tfor (int i = 0; i < powTableCount; ++i)\n\t\toffset += ((vec2(GetFocusPos(i)) + vec2(glyphMargin)) * gsfi) * powTable[i];\n    \n\t// apply zoom & offset\n    vec2 uvFractal = uv * zoom + offset;\n\t\n\t// check pixel recursion depth\n\tvec3 pixelFractalColor = GetPixelFractal(uvFractal, iterations, timePercent);\n    pixelFractalColor = FinishPixel(pixelFractalColor, uv);\n    \n\t// apply final color\n\tfragColor = vec4(pixelFractalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsBRs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[2127, 2625, 2649, 2649, 2695], [2696, 2696, 2716, 2716, 2753], [2755, 2755, 2779, 2779, 2919], [2921, 3037, 3087, 3087, 3331], [3333, 3333, 3384, 3384, 3586], [3588, 3588, 3612, 3612, 3698], [3700, 3700, 3815, 3815, 4621], [4623, 4623, 4662, 4686, 4946], [4948, 4948, 4970, 4979, 5328], [5330, 5330, 5355, 5397, 5444], [5446, 5551, 5577, 5577, 5611], [5612, 5612, 5648, 5648, 5701], [5703, 5703, 5740, 5769, 5883], [5942, 5942, 5968, 5968, 5993], [6035, 6035, 6069, 6069, 6954], [6956, 6956, 6997, 6997, 7823], [7827, 7827, 7938, 7938, 10212], [10214, 10271, 10338, 10338, 11489], [11492, 11577, 11634, 11662, 12692]], "test": "untested"}
{"id": "XlsBWN", "name": "Extra Credit", "author": "Quincy_Buchanan", "description": "Extra Credit Assignment - Pacman", "tags": ["2d"], "likes": 0, "viewed": 64, "published": "Public", "date": "1512243318", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 Location = vec2(.45, .35);\nvec2 Dot1 = vec2(.6, .28);\nvec2 Dot2 = vec2(.75, .28);\nvec2 Dot3 = vec2(.9, .28);\nfloat Radius1;\nfloat Radius2 = .015;\nfloat Radius3 = .02;\n\nvec3 BgColor = vec3(1.0,1.0,1.0);\nvec3 Black = vec3(0.0,0.0,0.0);\nvec3 Yellow = vec3(1.0,1.0,0.0);\nvec3 Dot = vec3(0.0,0.0,1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    fragCoord = (fragCoord + fragCoord - iResolution.xy) / iResolution.y;\n    Radius1 = length(fragCoord);\n    \n    uv.y *= iResolution.y / iResolution.x;\n    \n    vec4 Layer1 = vec4(BgColor, 1.0);\n    vec4 Layer2 = vec4(Dot, step(length(Dot1-uv), Radius3));\n    vec4 Layer3 = vec4(Dot, step(length(Dot2-uv), Radius3));\n    vec4 Layer4 = vec4(Dot, step(length(Dot3-uv), Radius3));\n    vec4 Layer5 = vec4(Yellow, 1.0) * step(Radius1, .5)\n        * step(fragCoord.x / Radius1, .9 - .1 * sin(iTime * 5.0));\n    vec4 Layer6 = vec4(Black, step(length(Location-uv), Radius2));\n    \n    vec4 Composite = mix(Layer1, Layer2, Layer2.a);\n    Composite = mix(Composite, Layer3, Layer3.a);\n    Composite = mix(Composite, Layer4, Layer4.a);\n    Composite = mix(Composite, Layer5, Layer5.a);\n    Composite = mix(Composite, Layer6, Layer6.a);\n    fragColor = Composite;   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsBWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[303, 303, 360, 360, 1273]], "test": "untested"}
{"id": "XlSBz1", "name": "Polar Snowflakes", "author": "antoineMoPa", "description": "While trying to code something else (a tree), I realized I could create snowflakes easily using polar coordinates with `floor` and other math functions.\n", "tags": ["snow", "winter", "snowflakes", "xmass"], "likes": 13, "viewed": 2878, "published": "Public API", "date": "1514483849", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nprecision highp float;\n\n\n// Convention:\n// vec2s ending with 'c'\n// are in circular coords\n// ex: pc = vec2(angle of p, length of p)\n\n\n\n#define time (iTime / 2.0)\n\n#define PI2 6.28\n#define PI 3.1416\n\n\n// Point to polar coord\nvec2 p_to_pc(vec2 p){\n    return vec2(atan(p.y, p.x), length(p));\n}\n\n// Polar coord to point\nvec2 pc_to_p(vec2 pc){\n    return vec2(pc.y * cos(pc.x), pc.y * sin(pc.x));\n}\n\n// I use these fields to create and tweak the snowflakes\nvec2 fieldA(vec2 pc){\n    // Modify angle and distance\n    pc.y += 0.02 * floor(cos(pc.x * 6.0 ) * 5.0);\n    pc.y += 0.01 * floor(10.0 * cos(pc.x * 30.0));\n    pc.y += 0.5 * cos(pc.y * 10.0);\n    \n    // Take back to position\n    return pc;\n}\n\n\n// Different values of f happen to give quite different\n// snowflake shapes. Interesting...\nvec2 fieldB(vec2 pc, float f){\n    // Modify angle and distance\n    pc.y += 0.1 * cos(pc.y * 100.0 + 10.0);\n    pc.y += 0.1 * cos(pc.y * 20.0 + f);\n    pc.y += 0.04 * cos(pc.y * 10.0 + 10.0);\n    \n    return pc;\n} \n\nvec4 snow_flake(vec2 p, float f){\n    \n    vec4 col = vec4(0.0);\n\n\tvec2 pc = p_to_pc(p * 10.0);\n    \n    \n    pc = fieldA(fieldB(pc, f));\n    \n    p = pc_to_p(pc);\n    \n    float d = length(p);\n    \n    if(d < 0.3){\n        col.rgba += vec4(1.0);\n    }\n    \n    return col;\n}\n\nvec4 snow(vec2 p){\n   \n    vec4 col = vec4(0.0);\n\n\tp.y += 2.0 * time;\n    \n    p = fract(p + 0.5) - 0.5;\n    \n    p *= 1.0;\n    \n    \n    p.x += 0.01 * cos(p.y * 3.0 + p.x * 3.0 + time * PI2);\n    \n    \n    // Just me pseudo randomly adding snowflakes\n    // Could be optimized by not calling the function 8 times\n    // (using some field distortion )\n    col += snow_flake(p, 1.0);\n    col += snow_flake(p + vec2(0.2, -0.1), 4.0);\n    col += snow_flake(p * 2.0 + vec2(-0.4, -0.5), 5.0);\n    col += snow_flake(p * 1.0 + vec2(-0.2, 0.4), 9.0);\n    col += 2.0 * snow_flake(p * 1.0 + vec2(0.4, -0.4), 5.0);\n    col += snow_flake(p * 1.0 + vec2(-1.2, 1.2), 9.0);\n    col += snow_flake(p * 1.0 + vec2(2.4, -1.2), 5.0);\n    col += snow_flake(p * 1.0 + vec2(-1.2, 1.1), 9.0);\n   \n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\tvec2 uv = fragCoord.xy / iResolution.x;\n    float x = uv.x;\n    float y = uv.y;\n    \n    vec2 p = vec2(x, y) - vec2(0.5);\n   \t\n    vec4 col = vec4(0.2, 0.4, 0.7, 1.0);\n    \n    col += 0.3 * snow(p * 2.0);\n    col += 0.2 * snow(p * 4.0 + vec2(time, 0.0));\n    col += 0.1 * snow(p * 8.0);\n    \n    col.a = 1.0;\n    \n    fragColor = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlSBz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[202, 226, 247, 247, 293], [295, 319, 341, 341, 396], [398, 455, 476, 509, 697], [700, 792, 822, 855, 1005], [1008, 1008, 1041, 1041, 1283], [1285, 1285, 1303, 1303, 2080], [2082, 2082, 2136, 2136, 2479]], "test": "untested"}
{"id": "XlsBzj", "name": "target UI", "author": "modelain", "description": "http://www.randomghost.com/post/45955195639", "tags": ["2d", "target", "ui"], "likes": 9, "viewed": 260, "published": "Public", "date": "1513073466", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://www.randomghost.com/post/45955195639\n\n#define red vec3(.933,.255,.106)\n#define glow 2.0\n\nfloat circle(in vec2 uv, in vec2 p, in float r, in float width){\n    float dist = length(uv - p);\n    \n\treturn \n        (1. - smoothstep(r - glow, r + glow, dist)) -\n        (1. - smoothstep((r - width) - glow, (r - width) + glow, dist));\n}\n\nfloat sector(in vec2 uv, in vec2 p, in float r, in float width, in float start, in float end){\n    float dist = length(uv - p);\n    float angle = degrees(atan(uv.y - p.y, uv.x - p.x)) + 180.;\n    \n\treturn \n        ((1. - smoothstep(r - glow, r + glow, dist)) -\n        (1. - smoothstep((r - width) - glow, (r - width) + glow, dist))) * \n        smoothstep(start - glow, start + glow, angle) * \n        (1. - smoothstep(end - glow, end + glow, angle));\n}\n\nfloat rect(in vec2 uv, in vec4 p){\n    float t = p.y; // top\n    float r = p.x + p.z; // right\n    float b = p.y + p.w; // bottom\n    float l = p.x; // left\n        \n    return\n        smoothstep(l - glow, l, uv.x) *\n        (1. - smoothstep(r, r + glow, uv.x)) *\n        smoothstep(t - glow, t, uv.y) *\n        (1. - smoothstep(b, b + glow, uv.y));\n}\n\n// http://thebookofshaders.com/edit.php#06/easing.frag\nfloat expoOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nfloat expoIn(float t) {\n  return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\n\nfloat expoInOut(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n} \n\nvoid rotate(inout vec2 uv, in vec2 center, inout float rotation, in float angle){\n    float a = radians(angle - rotation);\n    \n    rotation = angle;\n    \n    uv -= center;\n    uv = mat2(cos(a), -sin(a), sin(a), cos(a)) * uv;\n    uv += center;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    vec2 center = iResolution.xy / 2.;\n    center.y -= 10.;\n    vec3 color = vec3(0.);\n    float rotation = 0.;\n    float t = fract(iTime * .3);\n    \n    color += circle(uv, center, 65., 3.) * red;\n    \n    float inRotation = 0.;\n    inRotation -= 120. * expoInOut(smoothstep(.6, 1., t)) * step(.6, t) * (1. - step(1., t));\n    \n    rotate(uv, center, rotation, 50. + inRotation);\n\n    float s1 = sector(uv, center, 64., 6., 0., 80.);\n    color = mix(color, red, s1);\n    \n    float s2 = sector(uv, center, 64., 6., 120., 200.);\n    color = mix(color, red, s2);\n    \n    float s3 = sector(uv, center, 64., 6., 240., 320.);\n    color = mix(color, red, s3);\n    \n    float outRotation = 0.; \n    outRotation -= (120. * 2.) * expoInOut(smoothstep(.7, .9, t)) * step(.7, t) * (1. - step(.9, t));\n    \n    rotate(uv, center, rotation, sin(iTime * 3.) * 60. + outRotation);\n\n    float outRadius = 80.;\n    outRadius -= 35. * expoInOut(smoothstep(.3, .5, t)) * step(.3, t) * (1. - step(.5, t));\n    outRadius -= 35. * step(.5, t);\n    outRadius += 35. * expoInOut(smoothstep(.7, 1., t)) * step(.7, t) * (1. - step(1., t));\n    \n    float s7 = sector(uv, center, outRadius, 5., 0., 60.);\n    color = mix(color, red * .4, s7);\n    \n    float s8 = sector(uv, center, outRadius, 5., 120., 180.);\n    color = mix(color, red * .4, s8);\n    \n    float s9 = sector(uv, center, outRadius, 5., 240., 300.);\n    color = mix(color, red * .4, s9);\n    \n    rotate(uv, center, rotation, 45. + outRotation);\n    \n    float s4 = sector(uv, center, outRadius, 5., 0., 90.);\n    color = mix(color, red, s4);\n    \n    float s5 = sector(uv, center, outRadius, 5., 120., 210.);\n    color = mix(color, red, s5);\n    \n    float s6 = sector(uv, center, outRadius, 5., 240., 330.);\n    color = mix(color, red, s6);rotate(uv, center, rotation, 0.);\n    \n    float rectY = center.y + 75.;\n    rectY += 180. * (1. - expoOut(min(t, .3) / .3));\n    rectY -= 65. * expoInOut(smoothstep(.4, .6, t)) * step(.4, t) * (1. - step(.6, t));\n    rectY -= 65. * step(.6, t); \n    rectY += (180. + 65.) * expoIn(smoothstep(.7, .9, t) * step(.7, t * (1. - step(.9, t))));\n    rectY += (180. + 65.) * step(.9, t);\n    \n    float rectColorAlpha = 1.;\n    rectColorAlpha -= (1. - step(.03, t));\n    rectColorAlpha -= step(.9, t);\n    rectColorAlpha -= (1. - step(center.y + 15., rectY)) * ceil(sin(iTime * 100.));\n    rectColorAlpha = clamp(rectColorAlpha, 0., 1.);\n    \n    vec3 rectColor = mix(vec3(0.), red, rectColorAlpha);\n    \n    float r1 = rect(uv, vec4(center.x, rectY, 1., 25.));\n    color = mix(color, rectColor, r1);\n    \n    rotate(uv, center, rotation, 120.);\n    \n    float r2 = rect(uv, vec4(center.x, rectY, 1., 25.));\n    color = mix(color, rectColor, r2);\n    \n    rotate(uv, center, rotation, -120.);\n    \n    float r3 = rect(uv, vec4(center.x, rectY, 1., 25.));\n    color = mix(color, rectColor, r3);\n    \n\tfragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsBzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 99, 163, 163, 339], [341, 341, 435, 435, 794], [796, 796, 830, 830, 1147], [1149, 1204, 1228, 1228, 1281], [1283, 1283, 1306, 1306, 1360], [1362, 1362, 1388, 1388, 1535], [1538, 1538, 1619, 1619, 1783], [1785, 1785, 1842, 1842, 4773]], "test": "untested"}
{"id": "XlsfDf", "name": "RGB Pattern (203c)", "author": "aiekick", "description": "RGB Pattern", "tags": ["rainbow", "pattern"], "likes": 4, "viewed": 587, "published": "Public API", "date": "1513691072", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n// FabriceNeyret2 version \nvoid mainImage( out vec4 C, vec2 g )\n{\n\tg = cos(g / iResolution.y * 12.);\n    float r = length(atan(g.x, -g.y)/6.283 + length(g) + iTime * .2);\n    int i = int(3.*fract(r)); \n\tC = vec4(.25);   \n    C[(i+1)%3] += r = fract(3.*r);\n    C[i]       += 1.-r;\n    C *= sqrt(C*.5);\n}/**/\n\n/*\nvec4 GetRainBow(float r)\n{\n    int i = int(3.*fract(r)); \n\tvec4 C = vec4(.25);   \n    C[(i+1)%3] += r = fract(3.*r);\n    C[i]       += 1.-r;\n\treturn C;\n}*/\n\n// dont remember where i found this func ;) but its not mine\n/*vec3 GetRainBow(float r)\n{\n\tfloat xCol = mod(r * 3.0, 3.0);\n\tvec3 horColour = vec3(0.25);\n    \n\tif (xCol < 1.0)\n\t{\n\t\thorColour.r += 1.0 - xCol;\n\t\thorColour.g += xCol;\n\t}\n\telse if (xCol < 2.0)\n\t{\n\t\txCol -= 1.0;\n\t\thorColour.g += 1.0 - xCol;\n\t\thorColour.b += xCol;\n\t}\n\telse\n\t{\n\t\txCol -= 2.0;\n\t\thorColour.b += 1.0 - xCol;\n\t\thorColour.r += xCol;\n\t}\n\treturn horColour;\n}*/\n\n/*void mainImage( out vec4 f, vec2 g )\n{\n\tg = cos(g / iResolution.y * 12.);\n    f = GetRainBow(length(atan(g.x, g.y) * 0.15915 + length(g) + iTime * 0.2));\n    f *= sqrt(f*0.5);\n}/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsfDf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[214, 241, 279, 279, 516]], "test": "untested"}
{"id": "XlsfDj", "name": "trippy pattern", "author": "demicuz", "description": "A fork of: https://www.shadertoy.com/view/4lfBRr", "tags": ["distancefield", "pattern", "tiling"], "likes": 2, "viewed": 87, "published": "Public", "date": "1514333242", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// THE PIECES\n\n// Rotate the space around (0, 0) by angle.\nvec2 rotate(vec2 uv, float angle)\n{\n\treturn vec2(\n\t\tuv.x*cos(angle) - uv.y*sin(angle),\n\t\tuv.x*sin(angle) + uv.y*cos(angle)\n\t);\n}\n\n// Return 1 if even, 0 if odd.\nfloat is_even(float n)\n{\n    return 1.0 - step(1.0, mod(n, 2.0));\n}\n\n// Tile space, repeats 0->1 for number of times (per square unit space).\nvec4 tile_space(vec2 uv, float times)\n{\n    vec2 scaledUV = uv * times;\n    return vec4(fract(scaledUV), floor(scaledUV));\n}\n\n// Values from Wikipedia page on YUV colorspace.\nvec3 yuv_to_rgb(vec3 yuvCol)\n{\n    return vec3(\n        yuvCol.x +                    1.13983*yuvCol.z,\n\t\tyuvCol.x - 0.39465*yuvCol.y - 0.58060*yuvCol.z,\n\t\tyuvCol.x + 2.03211*yuvCol.y\n    );\n}\n\n// From pixel spirit deck.\nfloat rectSDF(vec2 uv, vec2 size)\n{\n\tuv = uv * 2. - 1.;\n\treturn max(\n\t\tabs(uv.x/size.x),\n\t\tabs(uv.y/size.y)\n\t);\n}\n\n// Adapted from pixel spirit deck.\nfloat crossSDF(vec2 uv, float s, float thick)\n{\n\treturn min(\n\t\trectSDF(uv, vec2(s, thick)),\n\t\trectSDF(uv, vec2(thick, s))\n\t);\n}\n\n// From pixel spirit deck.\nfloat fill(float x, float size)\n{\n\treturn 1.0 - step(size, x);\n}\n\n\n// THE CONSTRUCTION\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize UVs.\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Background color parameter.\n    vec4 bgCol = mix(vec4(.05, .05, .05, 1), vec4(.25, .25, .25, 1.), distance(uv, vec2(.5))*1.4);\n    \n    // Correct UV aspect ratio.\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // More parameters.\n    vec4 strokeCol = vec4(yuv_to_rgb(vec3(.5, uv.x, uv.y-.1)), 1.);\n    const float tileAmt = 4.0;\n    float crossSize = iMouse.x / iResolution.x * 6.;\n    float crossThickness = iMouse.y / iResolution.y * 6.;\n    \n    // Build on these.\n    float sdf = 0.;\n    vec4 col;\n    \n    // Tile the space.\n    vec4 tiledSpace = tile_space(uv, tileAmt);\n    uv = tiledSpace.xy;\n    \n    // Make checkerboard mask to flip rotations for the effect.\n    float xor = is_even(tiledSpace.w) + is_even(tiledSpace.z);\n    //xor = (1.0 - step(1.5, xor)) * xor;\n    xor = 1. - is_even(xor);\n    \n    // Rotate the space (works per tile).\n    uv -= vec2(.5);\n    uv = rotate(uv, mix(1., -1., xor)*iTime*0.5);\n    uv += vec2(.5);\n    \n    uv.x = fract(length(uv * 5.));\n    \n    // Shape the SDF with a cross.\n    sdf = crossSDF(uv, crossSize, crossThickness);\n    \n    // Mix the colors for the final result.\n    col = mix(bgCol, strokeCol, fill(sdf, 0.5));\n    \n    \n    fragColor = vec4(uv.x, .0, .0, 1.);\n    //fragColor = bgCol;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsfDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[15, 59, 94, 94, 187], [189, 220, 244, 244, 287], [289, 362, 401, 401, 486], [488, 537, 567, 567, 729], [731, 758, 793, 793, 871], [873, 908, 955, 955, 1035], [1037, 1064, 1097, 1097, 1128], [1131, 1152, 1207, 1229, 2536]], "test": "untested"}
{"id": "XlsfW2", "name": "subsurface scatter attempt", "author": "mds2", "description": "ugly attempt at subsurface scatter effect.  Decided to add in some refraction and a touch of surface reflection just to give the shape volume.  Then I set it to music, because I set everything to music.  Thanks for adding music, IQ!", "tags": ["ugly", "sdf", "subsurface", "scatter"], "likes": 3, "viewed": 211, "published": "Public", "date": "1513384801", "time_retrieved": "2021-10-01T00:00:00", "image_code": " float cyl_length = 2.0;\n float cyl_rad = 0.8;\n float curve_rad = 0.2;\nconst vec3 cyl_center = vec3(0.1, 0.0, -1.0);\n\nfloat cyl_sdf(in highp vec3 point) {\n    vec3 cyl_dir =\n        vec3(sin(0.1 * iTime) * cos(0.33 * iTime),\n             sin(0.33*iTime),\n             cos(0.1 * iTime) * cos(0.33 * iTime));\n\tvec3 rel = point - cyl_center;\n    float along = dot(rel, cyl_dir);\n    vec3 across = rel - cyl_dir * along;\n    return length(max(vec2(length(across) - cyl_rad + curve_rad,\n                  \t       abs(along) - 0.5 * cyl_length + curve_rad),\n                     0.0)) - curve_rad;\n}\n\nvec3 cyl_norm(in highp vec3 point) {\n\tfloat v = cyl_sdf(point);\n    return normalize(vec3(v + cyl_sdf(point + vec3(0.01, 0.00, 0.00)),\n                          v + cyl_sdf(point + vec3(0.00, 0.01, 0.00)),\n                          v + cyl_sdf(point + vec3(0.00, 0.00, 0.01))));\n}\n\nfloat cyl_isect(in highp vec3 ray_orig, in highp vec3 ray_dir) {\n\tfloat result = 0.0;\n    vec3 p = ray_orig;\n    float last_d = 20.0;\n    for (int i = 0; i < 64; ++i) {\n    \tfloat d = cyl_sdf(p);\n        result += d;\n        p += d * ray_dir;\n        last_d = d;\n    }\n    if (last_d > 1.0e-3) {\n        return -1.0; // miss\n    }\n    return result;\n}\n\nfloat dist_out_of_cyl(in highp vec3 ray_orig, in highp vec3 ray_dir) {\n\n    float result = 0.1;\n    vec3 p = ray_orig + 0.1 * ray_dir;\n    for (int i = 0; i < 64; ++i) {\n        float d = -0.8 * cyl_sdf(p);\n        result += d; // d may be negative\n        p += d * ray_dir;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float texture_y = 0.0;\n    float val1 = \n        texture(iChannel0, vec2(0.2, texture_y)).r + \n        texture(iChannel0, vec2(0.4, texture_y)).r;\n    float val2 =\n        texture(iChannel0, vec2(0.6, texture_y)).r +\n        texture(iChannel0, vec2(0.8, texture_y)).r;\n    cyl_length = 0.5 * (1.0 + 3.0 * val1);\n    cyl_rad = sqrt(4.0 / cyl_length);\n curve_rad = 0.5 * (1.0 + val2) * min(0.9 * cyl_rad, 0.4 * cyl_length);\n    // cyl_rad -= curve_rad;\n    //cyl_length -= 2.0 * curve_rad;\n    const vec3 scatter_color = vec3(1.0, 0.4, 0.1);\n    const vec3 rough_color = vec3(1.0, 0.8, 0.1);\n    vec3 light_loc =\n        //5.0 * vec3(sin(iTime), 1.0, cos(iTime) + 0.5);\n        vec3(5.0, 2.0, -1.0);\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 ray_orig = vec3(0.0, 0.0, 2.0);\n    vec3 ray_dir = normalize(vec3(uv, -1.0));\n    \n    float d = cyl_isect(ray_orig, ray_dir);\n    float eta = 0.16;\n    if (d > 0.0) {\n    \tvec3 p = ray_orig + d * ray_dir;\n        \n        vec3 light_dir = normalize(light_loc - ray_orig);\n\n        vec3 n = cyl_norm(p);\n        vec3 b = reflect(ray_dir, n);\n        float diffuse = smoothstep(0.9, 1.0, dot(b, light_dir));\n        \n        vec3 refr_ray = normalize(refract(ray_dir, n, eta));\n        float refr_d = dist_out_of_cyl(p, refr_ray);\n        vec3 refr_p = p + refr_d * refr_ray;\n        vec3 refr_n = -cyl_norm(refr_p);\n        refr_ray = normalize(refract(refr_ray, refr_n, 1.0 / eta));\n        vec3 refr_light_dir = normalize(light_loc - refr_p);\n        float refracted = smoothstep(0.9, 1.0, dot(refr_ray,\n                                                   refr_light_dir));\n        \n        float d = dist_out_of_cyl(p, light_dir);\n        float subsurface = exp(-1.0 * d);\n\t\tfragColor = vec4(subsurface * scatter_color +\n                         diffuse * rough_color +\n                         refracted * vec3(0.2),1.0);\n\n    } else {\n        vec3 light_dir = normalize(light_loc - ray_orig);\n\t\tfragColor = vec4(0.5 * vec3(smoothstep(0.9, 1.0, dot(ray_dir,\n                                                       light_dir))),1.0);\n    }\n        // fragColor = texture(iChannel0, ray_dir);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsfW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 154, 154, 593], [595, 595, 631, 631, 875], [877, 877, 941, 941, 1228], [1230, 1230, 1300, 1300, 1531], [1533, 1533, 1590, 1590, 3762]], "test": "untested"}
{"id": "XlsfzX", "name": "Twisty Slime Cylinder", "author": "Del", "description": "Cylinder Twist test (bodge)", "tags": ["cylinder"], "likes": 3, "viewed": 410, "published": "Public API", "date": "1512714403", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 Slime(vec2 uv)\n{\n    const vec4 col1 = vec4(0.0,.1,.1,1.0);\n    const vec4 col2 = vec4(0.5,0.9,0.3,1.0);\n    \n    vec4 k = vec4(0.0);\n    \n    float s = sin(iTime*0.1);\n    float s2 = 0.5+sin(iTime*1.8);\n    vec2 d = uv*(3.0+s*.3);\t\t\t\t\t\t// mod 4.0 for irregularity...\n    \n    d.x += iTime*0.3+sin(d.x+d.y + iTime*0.3)*0.5;\n    d.y += iTime*0.15+sin(d.x + iTime*0.3)*0.5;\t//-(s*0.5);\n    float v1=length(0.5-fract(d.xy))+0.55;\t\t\t\t// 0.9 =more gooey bits, 1.2 = less gooey bits\n\n    d = (uv);\t\t\t// zoom\n    float v2=length(0.5-fract(d.xx))-0.175;\t\t// border\n    v1 *= 1.0-v2*v1;\n    v1 = v1*v1*v1;\n    v1 *= 2.9+s2*0.2;\n    k = mix(col2,col1,v1)*(3.2+(s2*0.2));\n    k *= 1.0-(v2);\n    \n    if (k.g<=0.4)\n    {\n        float m = 1.0-clamp(k.g,0.0,0.5);\n\t\tfloat f = mod( floor(6.0*uv.x) + floor(6.0*uv.y), 2.0);\n        float col = 0.3 + 0.2*f*1.0;\n        k.x = k.y = k.z = col*m;\n\t\tk.rb *= 1.2;\n    }\n    else\n    {\n\t\tfloat f = mod( floor(6.0*uv.x) + floor(6.0*uv.y), 2.0);\n        vec4 _col = 0.2*f*vec4(0.175);\n        k+=_col;\n    }\n    return k;\n}\n\n// mirror mod\nfloat pModMirror1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0)*2. - 1.;\n\treturn c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy - iResolution.xy)/ iResolution.y;\n    \n    float speed = iTime*0.15;\n    float _fd = iTime*0.4;\n    vec2 cst = vec2( cos(_fd), sin(_fd) );\n    float zoom = 2.0+sin(speed)*0.5;\n    mat2 rot = mat2(cst.x,-cst.y,cst.y,cst.x) * zoom;\n    uv = rot*uv;\n\n\tfloat t = iTime*0.5;\n    \n    uv.y *= 0.5;\n\n    // click mouse for many... :)\n    if (iMouse.z>0.5)\n    {\n        // repeat :)\n        uv *= 1.25;\t\t// extra zoom\n        float dist = abs(sin(iTime*0.9));\n        dist = 2.+smoothstep(0.0,4.0,dist*3.0);\n        pModMirror1(uv.x,dist);\n    }\n\n    float c = abs(uv.x);\t\t// dirty shading bodge...\n    \n\tfragColor = vec4(0.3,0.3,0.6,1.0);\n\t//fragColor = vec4(0.3,0.3,0.6,1.0)*(3.0-c);\n    if (c-0.5 < 0.5)\n    {\n\t\tuv.x = acos(uv.x)/3.14159;\n\t\tuv.x += sin(t+uv.y*0.7);\n        c = acos(c);\n        //c=smoothstep(1.4,0.1,c*c*c*c);\n        fragColor = Slime(uv*3.0)*c;\n        //fragColor=vec4(c);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsfzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 1055], [1057, 1071, 1117, 1117, 1264], [1267, 1267, 1324, 1324, 2250]], "test": "untested"}
{"id": "XlXBD2", "name": "Sky with clouds", "author": "robobo1221", "description": "An itteration of this: https://www.shadertoy.com/view/4llfDS\n\nHope you like it! :D", "tags": ["clouds", "scattering", "rayleigh", "mie", "atmospheric", "robobo1221"], "likes": 14, "viewed": 1384, "published": "Public API", "date": "1513263479", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 rayleighCoeff = vec3(0.27, 0.5, 1.0) * 1e-5;\nconst float mieCoeff = 1e-6;\n\n#define pi 3.14159265359\n#define d0(x) abs(x) + 1e-8\n\nvec3 totalCoeff = rayleighCoeff + mieCoeff;\n\nvec3 scatter(vec3 coeff, float depth){\n\treturn coeff * depth;\n}\n\nvec3 absorb(vec3 coeff, float depth){\n\treturn exp2(scatter(coeff, -depth));\n}\n\nfloat calculateSceneDepth(float depth){\n\tdepth = depth * 2.0 - 0.1;\n    depth = max(depth + 0.01, 0.01);\n    \n    return depth * depth * (3.0 - 2.0 * depth);\n}\n\nfloat calcParticleThickness(float depth){\n   \t\n\tdepth = calculateSceneDepth(depth);\n    depth = 1.0 / depth;\n    \n\treturn 50000.0 * depth;   \n}\n\nfloat rayleighPhase(vec2 p, vec2 lp){\n\treturn 0.375 * (1.0 + pow(1.0 - distance(p, lp), 2.0) / log(2.0));\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    \n    float time = iTime * 0.075;\n    \n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x + time);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n        x += time;\n\t}\n\treturn v;\n}\n\nvec3 calcClouds(vec2 p, vec2 lp, vec3 background, vec3 scatteredSunlight, vec3 scatteredSkylight, float depth, float rawDepthLight)\n{\n    const int steps = 10;\n    const float invSteps = 1.0 / float(steps);\n    \n    float stepsize = 1.0;\n    \n    p = p * 2.0 - 1.0;\n    p *= 5.0;\n    p /= depth;\n    \n    lp = lp * 2.0 - 1.0;\n    lp *= 5.0;\n    lp /= rawDepthLight;\n\n    vec2 deltaPos = normalize(p - lp) * invSteps * stepsize;\n    float transmittance = 1.0;\n    float scattering = 0.0;\n    \n    const float cloudDensity = 800000.0;\n    \n    #define cloud clamp((fbm(p) - 0.25) * 10.0, 0.0, 1.0)\n    \n    float oldOD = cloud * cloudDensity;\n    \n    for (int i = 0; i < steps; i++){\n\t\tp -= deltaPos;\n        \n        float opticalDepth = cloud * cloudDensity;\n        \n        transmittance += opticalDepth;\n        \n    }\n    \n    const float anisatropicCoeff = 1.0 / (pi * 4.0);\n    \n    vec3 cloudAbsorb = absorb(vec3(mieCoeff), transmittance * stepsize);\n    \n    vec3 scatterCloud = scatter(vec3(mieCoeff), oldOD);\n    vec3 sunScatter = scatterCloud * scatteredSunlight * pi;\n    vec3 skyScatter = scatterCloud * scatteredSkylight * anisatropicCoeff;\n    \n    vec3 viewAbsorb = absorb(vec3(mieCoeff), oldOD);\n    \n    return background * viewAbsorb + (sunScatter * cloudAbsorb + skyScatter);\n}\n\nvec3 calcAtmosphericScatter(vec2 p, vec2 lp){\n    const float ln2 = log(2.0);\n    \n    const float up = 0.6;\n    \n\tfloat opticalDepth = calcParticleThickness(p.y);\n    float opticalDepthLight = calcParticleThickness(lp.y);\n    float opticalDepthUp = calcParticleThickness(up);\n    \n    vec3 scatterView = scatter(totalCoeff, opticalDepth);\n    vec3 absorbView = absorb(totalCoeff, opticalDepth);\n    \n    vec3 scatterLight = scatter(totalCoeff, opticalDepthLight);\n    vec3 absorbLight = absorb(totalCoeff, opticalDepthLight);\n    \n    vec3 scatterUp = scatter(totalCoeff, opticalDepthUp);\n    vec3 absorbUp = absorb(totalCoeff, opticalDepthUp); \n    \n    vec3 absorbSun = abs(absorbLight - absorbView) / d0((scatterLight - scatterView) * ln2);\n    vec3 scatterSun = scatterView * rayleighPhase(p, lp);\n    vec3 absorbUpv = abs(absorbLight - absorbUp) / d0((scatterLight - scatterUp) * ln2);\n    vec3 scatterUpv = scatterUp * rayleighPhase(vec2(up), lp);\n    \n    vec3 skylight = scatterUpv * absorbUpv;\n    \n    vec3 sunSpot = smoothstep(0.01, 0.009, distance(p, lp)) * absorbView * pi;\n    \n    float rawDepth = calculateSceneDepth(p.y);\n    float rawDepthLight = calculateSceneDepth(lp.y);\n    float cloudMult = rawDepth <= 0.05 ? 0.0 : clamp((rawDepth - 0.05) * pi * 2.0, 0.0, 1.0);\n    \n    vec3 color = (scatterSun * absorbSun + sunSpot);\n    vec3 clouds = calcClouds(p, lp, color, absorbLight, skylight, rawDepth, rawDepthLight);\n    \n    color = mix(color, clouds, cloudMult);\n    \n    return color * pi;\n}\n\nvec3 jodieReinhardTonemap(vec3 c){\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / max(iResolution.x, iResolution.y);\n    vec2 lp = iMouse.xy / max(iResolution.x, iResolution.y);\n         lp = lp.x == 0.0 ? vec2(0.2, 0.15) : lp;\n    \n    vec3 color = vec3(0.0);\n    color = calcAtmosphericScatter(uv, lp);\n    color = jodieReinhardTonemap(color);\n    \n\tfragColor = vec4(pow(color, vec3(0.4545)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXBD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 185, 223, 223, 248], [250, 250, 287, 287, 327], [329, 329, 368, 368, 488], [490, 490, 531, 531, 633], [635, 635, 672, 672, 742], [744, 744, 764, 764, 831], [833, 833, 853, 853, 1062], [1087, 1087, 1106, 1106, 1445], [1447, 1447, 1580, 1580, 2745], [2747, 2747, 2792, 2792, 4261], [4263, 4263, 4297, 4297, 4420], [4422, 4422, 4479, 4479, 4826]], "test": "untested"}
{"id": "XlXBRj", "name": "RadialRepeat Around Rounded Quad", "author": "aiekick", "description": "Radial Repeat Around Rounded Qua", "tags": ["radial", "rounded", "repeat", "around", "qua"], "likes": 1, "viewed": 391, "published": "Public API", "date": "1512406552", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// link : https://www.shadertoy.com/view/XlXBRj\n\nfloat df(vec2 p)\n{\n\treturn length(max(abs(p) - vec2(5.0*(sin(iTime *0.5)*0.5+0.5),1.0),0.0));\n}\n\nvec2 nor(vec2 p, float prec)\n{\n\tvec2 e = vec2(prec, 0.0);\n\tfloat x = df(p+e.xy) - df(p-e.xy);\n\tfloat y = df(p+e.yx) - df(p-e.yx);\n\treturn normalize(vec2(x,y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y*10.;\n\t\n\tvec2 n = normalize(uv * 0.1 + nor(uv, 0.1));\n\tuv = vec2(atan(n.x,n.y)/radians(180.)*4., df(uv)*0.4);\n\t\n\tuv.x *= floor(uv.y)+1.;\n\tuv.x += floor(uv.y) * iTime * 0.5 * (sign(mod(floor(uv.y), 2.))*2.-1.);\n\tuv = abs(fract(uv)-0.5);\n\tfloat d = max(abs(uv.x), abs(uv.y));\n\tfragColor = vec4(d);\n\t//fragColor = vec4(1.-d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXBRj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 205, 223, 223, 300], [302, 302, 332, 332, 463], [465, 465, 522, 522, 910]], "test": "untested"}
{"id": "XlXBWj", "name": "3D voronoi fog", "author": "jasondecode", "description": "Spacy 3D Voronoi noise makes foggy feelings.", "tags": ["noise", "raymarch", "fog", "3dvoronoi"], "likes": 35, "viewed": 1381, "published": "Public API", "date": "1513225221", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n3D Voronoi fogness.\n\nAuthor: Tim Gerritsen <tim@mannetje.org>\nDate: December 2017\n\n*/\n\n#define MAX_MARCH_STEPS 16\n#define MARCH_STEP_SIZE 0.2\n\n#define NOISE_AMPLITUDE 0.75\n\n#define FBM_ITERATIONS 3\n#define FBM_AMPLITUDE_GAIN 0.8\n#define FBM_FREQUENCY_GAIN 1.9\n\n// 2*tan(radians(45)/2)\n#define FOV45 0.82842693331417825056778150945139\n\nvec3 UvToWorld(vec2 uv) { return normalize(vec3((uv-0.5) * iResolution.xy, -iResolution.y / FOV45)); }\nvec3 Hash3( vec3 p ) { return fract(sin(vec3( dot(p,vec3(127.1,311.7,786.6)), dot(p,vec3(269.5,183.3,455.8)), dot(p,vec3(419.2,371.9,948.6))))*43758.5453); }\nfloat Voronoi(vec3 p)\n{\n\tvec3 n = floor(p);\n\tvec3 f = fract(p);\n\n\tfloat shortestDistance = 1.0;\n\tfor (int x = -1; x < 1; x++) {\n\t\tfor (int y = -1; y < 1; y++) {\n\t\t\tfor (int z = -1; z < 1; z++) {\n\t\t\t\tvec3 o = vec3(x,y,z);\n\t\t\t\tvec3 r = (o - f) + 1.0 + sin(Hash3(n + o)*50.0)*0.2;\n\t\t\t\tfloat d = dot(r,r);\n\t\t\t\tif (d < shortestDistance) {\n\t\t\t\t\tshortestDistance = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn shortestDistance;\n}\n\nfloat FractalVoronoi(vec3 p)\n{\n\tfloat n = 0.0;\n\tfloat f = 0.5, a = 0.5;\n\tmat2 m = mat2(0.8, 0.6, -0.6, 0.8);\n\tfor (int i = 0; i < FBM_ITERATIONS; i++) {\n\t\tn += Voronoi(p * f) * a;\n\t\tf *= FBM_FREQUENCY_GAIN;\n\t\ta *= FBM_AMPLITUDE_GAIN;\n\t\tp.xy = m * p.xy;\n\t}\n\treturn n;\n}\n\nvec2 March(vec3 origin, vec3 direction)\n{\n\tfloat depth = MARCH_STEP_SIZE;\n\tfloat d = 0.0;\n\tfor (int i = 0; i < MAX_MARCH_STEPS; i++) {\n\t\tvec3 p = origin + direction * depth;\n\t\td = FractalVoronoi(p) * NOISE_AMPLITUDE;\n\t\tdepth += max(MARCH_STEP_SIZE, d);\n\t}\n\treturn vec2(depth, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 res = iResolution.xy;\n\tvec2 uv = (fragCoord.xy / res);\n\n\tvec3 direction = UvToWorld(uv);\n\tvec3 origin = vec3(0.0, -iTime*0.2, 0.0);\n\tvec2 data = March(origin, direction);\n    \n\tvec4 color = vec4(1, 0.615733, 0.476, 1) * data.y * data.x * 0.7;\n\tfragColor = mix(color, vec4(0,0,1,1), max(0.0, 0.3-data.y));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXBWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[264, 338, 363, 363, 440], [441, 441, 463, 463, 598], [599, 599, 622, 622, 1005], [1007, 1007, 1037, 1037, 1275], [1277, 1277, 1318, 1318, 1558], [1560, 1560, 1617, 1617, 1930]], "test": "untested"}
{"id": "XlXBWs", "name": "Filtered checker (box, 3D)", "author": "iq", "description": "Similar to [url]https://www.shadertoy.com/view/XlcSz2[/url], but in 3d, in case you ever needed it. Move the mouse to compare.", "tags": ["3d", "filtering", "analytical", "integration", "checkedboard"], "likes": 23, "viewed": 1236, "published": "Public API", "date": "1513801922", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Info: http://iquilezles.org/www/articles/filterableprocedurals/filterableprocedurals.htm\n//  \n// More filtered patterns:  https://www.shadertoy.com/playlist/l3KXR1\n\n\nvec3 tri( in vec3 x )\n{\n    return 1.0-abs(2.0*fract(x/2.0)-1.0);\n}\n\nfloat checkersTextureGrad( in vec3 p, in vec3 ddx, in vec3 ddy )\n{\n  vec3 w = max(abs(ddx), abs(ddy)) + 0.0001; // filter kernel\n  vec3 i = (tri(p+0.5*w)-tri(p-0.5*w))/w;    // analytical integral (box filter)\n  return 0.5 - 0.5*i.x*i.y*i.z;              // xor pattern\n}\n\nfloat checkersTexture( in vec3 p )\n{\n    vec3 q = floor(p);\n    return mod( q.x+q.y+q.z, 2.0 );\n}\n\n//===============================================================================================\n//===============================================================================================\n// sphere implementation\n//===============================================================================================\n//===============================================================================================\n\nfloat softShadowSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = sph.xyz - ro;\n    float b = dot( oc, rd );\n\t\n    float res = 1.0;\n    if( b>0.0 )\n    {\n        float h = dot(oc,oc) - b*b - sph.w*sph.w;\n        res = smoothstep( 0.0, 1.0, 2.0*h/b );\n    }\n    return res;\n}\n\nfloat occSphere( in vec4 sph, in vec3 pos, in vec3 nor )\n{\n    vec3 di = sph.xyz - pos;\n    float l = length(di);\n    return 1.0 - dot(nor,di/l)*sph.w*sph.w/(l*l); \n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    float t = -1.0;\n\tvec3  ce = ro - sph.xyz;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\tt = -b - sqrt(h);\n\t}\n\t\n\treturn t;\n}\n\n//===============================================================================================\n//===============================================================================================\n// scene\n//===============================================================================================\n//===============================================================================================\n\n\n// spheres\nconst vec4 sc0 = vec4(  0.0, 1.0,  0.0, 1.0 );\nconst vec4 sc1 = vec4(-11.0, 1.0,-12.0, 5.0 );\nconst vec4 sc2 = vec4(-11.0, 1.0, 12.0, 5.0 );\nconst vec4 sc3 = vec4( 13.0, 1.0,-10.0, 4.0 );\n\nfloat intersect( vec3 ro, vec3 rd, out vec3 pos, out vec3 nor, out float occ, out float matid )\n{\n    // raytrace\n\tfloat tmin = 10000.0;\n\tnor = vec3(0.0);\n\tocc = 1.0;\n\tpos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = (0.01-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tmatid = 0.0;\n\t\tocc = occSphere( sc0, pos, nor ) * \n\t\t\t  occSphere( sc1, pos, nor ) *\n\t\t\t  occSphere( sc2, pos, nor ) *\n\t\t\t  occSphere( sc3, pos, nor );\n\t}\n\n\t// raytrace-sphere\n\th = iSphere( ro, rd, sc0 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + h*rd;\n\t\tnor = normalize(pos-sc0.xyz); \n\t\tmatid = 1.0;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc1 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(ro+h*rd-sc1.xyz); \n\t\tmatid = 1.0;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc2 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(ro+h*rd-sc2.xyz); \n\t\tmatid = 1.0;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc3 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(ro+h*rd-sc3.xyz); \n\t\tmatid = 1.0;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\treturn tmin;\t\n}\n\nvec3 texCoords( in vec3 p )\n{\n\treturn 3.0*p;\n}\n\n\nvoid calcCamera( out vec3 ro, out vec3 ta )\n{\n\tfloat an = 0.01*iTime;\n\tro = vec3( 5.5*cos(an), 1.0, 5.5*sin(an) );\n    ta = vec3( 0.0, 1.0, 0.0 );\n\n}\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in float occ, in vec3 rd )\n{\n    float sh = min( min( min( softShadowSphere( pos, vec3(0.57703), sc0 ),\n\t\t\t\t              softShadowSphere( pos, vec3(0.57703), sc1 )),\n\t\t\t\t              softShadowSphere( pos, vec3(0.57703), sc2 )),\n                              softShadowSphere( pos, vec3(0.57703), sc3 ));\n\tfloat dif = clamp(dot(nor,vec3(0.57703)),0.0,1.0);\n\tfloat bac = clamp(dot(nor,vec3(-0.707,0.0,-0.707)),0.0,1.0);\n    vec3 lin  = dif*vec3(1.50,1.40,1.30)*sh;\n\t     lin += occ*vec3(0.15,0.20,0.30);\n\t     lin += bac*vec3(0.10,0.10,0.10);\n\n    return lin;\n}\n//===============================================================================================\n//===============================================================================================\n// render\n//===============================================================================================\n//===============================================================================================\n\nvoid calcRayForPixel( vec2 pix, out vec3 resRo, out vec3 resRd )\n{\n\tvec2 p = (-iResolution.xy + 2.0*pix) / iResolution.y;\n\t\n     // camera movement\t\n\tvec3 ro, ta;\n\tcalcCamera( ro, ta );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\t\n\tresRo = ro;\n\tresRd = rd;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2  p  = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float th = (-iResolution.x + 2.0*iMouse.x) / iResolution.y;\n\t\n    if( iMouse.z<0.01) th = 0.5/ iResolution.y;\n\t\n\tvec3 ro, rd, ddx_ro, ddx_rd, ddy_ro, ddy_rd;\n\tcalcRayForPixel( fragCoord.xy + vec2(0.0,0.0), ro, rd );\n\tcalcRayForPixel( fragCoord.xy + vec2(1.0,0.0), ddx_ro, ddx_rd );\n\tcalcRayForPixel( fragCoord.xy + vec2(0.0,1.0), ddy_ro, ddy_rd );\n\t\t\n    // trace\n\tvec3 pos, nor;\n\tfloat occ, mid;\n    float t = intersect( ro, rd, pos, nor, occ, mid );\n\n\tvec3 col = vec3(0.9);\n\tif( t<100.0 )\n\t{\n#if 1\n\t\t// -----------------------------------------------------------------------\n        // compute ray differentials by intersecting the tangent plane to the  \n        // surface.\t\t\n\t\t// -----------------------------------------------------------------------\n\n\t\t// computer ray differentials\n\t\tvec3 ddx_pos = ddx_ro - ddx_rd*dot(ddx_ro-pos,nor)/dot(ddx_rd,nor);\n\t\tvec3 ddy_pos = ddy_ro - ddy_rd*dot(ddy_ro-pos,nor)/dot(ddy_rd,nor);\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec3     uvw = texCoords(     pos );\n\t\tvec3 ddx_uvw = texCoords( ddx_pos ) - uvw;\n\t\tvec3 ddy_uvw = texCoords( ddy_pos ) - uvw;\n#else\n\t\t// -----------------------------------------------------------------------\n        // Because we are in the GPU, we do have access to differentials directly\n        // This wouldn't be the case in a regular raytrace.\n\t\t// It wouldn't work as well in shaders doing interleaved calculations in\n\t\t// pixels (such as some of the 3D/stereo shaders here in Shadertoy)\n\t\t// -----------------------------------------------------------------------\n\t\tvec3 uvw = texCoords( pos );\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec3 ddx_uvw = dFdx( uvw ); \n        vec3 ddy_uvw = dFdy( uvw ); \n#endif\n\n        \n\t\t// shading\t\t\n\t\tvec3 mate = vec3(0.0);\n\t\tif( p.x<th ) \n            mate = vec3(1.0)*checkersTexture( uvw );\n        else\n            mate = vec3(1.0)*checkersTextureGrad( uvw, ddx_uvw, ddy_uvw );\n\n        // lighting\t\n\t\tvec3 lin = doLighting( pos, nor, occ, rd );\n\n        // combine lighting with material\t\t\n\t\tcol = mate * lin;\n\t\t\n        // fog\t\t\n        col = mix( col, vec3(0.9), 1.0-exp( -0.0001*t*t ) );\n\t}\n\t\n    // gamma correction\t\n\tcol = pow( col, vec3(0.4545) );\n\n\tcol *= smoothstep( 0.006, 0.008, abs(p.x-th) );\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXBWs.jpg", "access": "shaders20k", "license": "mit", "functions": [[1079, 1248, 1271, 1271, 1315], [1317, 1317, 1383, 1383, 1588], [1590, 1590, 1626, 1626, 1687], [1689, 2107, 2170, 2170, 2393], [2395, 2395, 2453, 2453, 2561], [2563, 2563, 2617, 2617, 2803], [3208, 3408, 3505, 3521, 4624], [4626, 4626, 4655, 4655, 4672], [4675, 4675, 4720, 4720, 4824], [4826, 4826, 4897, 4897, 5432], [5433, 5836, 5902, 5902, 6275], [6278, 6278, 6335, 6335, 8665]], "test": "untested"}
{"id": "XlXBzl", "name": "2D Pipe Pattern", "author": "Shane", "description": "Using a mixture of a cross-over tile and double arc tile to produce a pipe pattern. It's a 2D effect, but rendered in a pseudo 3D style.", "tags": ["2d", "shadow", "truchet", "pattern", "tile", "layer"], "likes": 27, "viewed": 1136, "published": "Public API", "date": "1512834157", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\t2D Pipe Pattern\n\t---------------\n\n\tUsing a mixture of a cross-over tile and double arc tile to produce a pipe pattern.\n\tIt's a 2D effect, but is rendered in an oldschool psuedo 3D game style... kind of. :)\n\n\tI like coding in psuedo 3D, because it's relaxing, and it's fun composing the illusion\n\tof depth and lighting...  I also like it because the physics police can't really \n\tcomplain that the mock physical setting isn't fake enough. :D\n\n\tAnyway, there's nothing here that hasn't been done before. It's a relatively brief \n\texample, and it's all pretty easy to code. If you can draw 2D shapes over other 2D \n\tshapes, then it shouldn't present too much of a challenge.\n\n\n\tSimilar examples:\n\n\t// Another dual tiled Truchet example.\n\tTruchet Roads - morgaza\n\thttps://www.shadertoy.com/view/4lsyDX\n\n\t// The 3D counterpart. Not as relaxing to code this one, but still doable. :)\n\tDual 3D Truchet Tilesv- Shaen\n\thttps://www.shadertoy.com/view/4l2cD3\n\n*/\n\n// I put this here for anyone who wants to see the outlines of the individual Truchet tiles.\n//#define SHOW_SINGLE_TILES\n\n// I put these in out of sheer boredom. The idea was to provide a little extra visual \n// interest... I'll leave them in as a default, but I'm still not quite sure about them. :)\n#define ENVIRONMENTAL_LIGHTS\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement.\n//\nfloat noise3D(vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(1, 57, 113);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\n\n// IQ's 2D box function. Necessary for correct box shadows.\nfloat sdBox(vec2 p, vec2 b){\n  \n  return length(max(abs(p) - b, 0.));\n  //vec2 d = abs(p) - b;\n  //return min(max(d.x,d.y), 0.) + length(max(d,0.0));\n}\n\n// Background lines. Horizonal only, or horitonal and vertical, \n// as the case may be.\nfloat bgLines(vec2 p){\n   \n  p = abs(fract(p) - .5);\n  #ifdef SHOW_SINGLE_TILES\n  return min(p.x, p.y);  \n  #else\n  return p.x;\n  #endif\n    \n}\n\n// Vec2 to vec3 hash. Works well enough, but I should probably substitute it for \n// one of Dave Hoskins's more robust versions.\nvec3 hash23(vec2 p){\n    \n    vec3 dt;\n    dt.x = dot(p, vec2(1.361, 113.947));\n    dt.y = dot(p + 7.54, vec2(1.361, 113.947));\n    dt.z = dot(p + 23.893, vec2(1.361, 113.947)); \n    \n    return fract(sin(dt)*43758.5453);\n    \n}\n\n// Background pipe shadows. A bit wasteful, considering that you could put a \n// blurry grid in the background, and the shadows would almost look the same, but\n// something in my mind won't quite accept it. :)\nfloat truSh(vec2 p, float lW){\n   \n    \n    // Two tile Truchet system. Pretty standard.\n    vec2 ip = floor(p);\n    \n    // Three random numbers, used for tile selection and tile flipping.\n    vec3 rnd = hash23(ip);\n    \n    // Grid.\n    p -= ip + .5;\n    \n    // Depending on the random number, select the tile, and flip it if necessary.\n    if(rnd.z>.35){\n        // Cross rotation. Flipping has no effect.\n    \tif(rnd.x > .5) p = p.yx;\n    }\n    else if(rnd.y > .5) p.y = -p.y; // Dual arc flipping. Rotation does the same thing.\n    \n        // Distance field variables.\n    float d1, d2, d3, d4;\n    \n    \n    if(rnd.z>.35){\n        \n        // Cross tile.\n        d1 = abs(p.y) - lW;\n        d2 = abs(p.x) - lW;\n        \n    }\n    else { \n        \n        // Dual arc tile.\n        d1 = length(p - .5) - .5;\n        d2 = length(p + .5) - .5;\n        d1 = abs(d1) - lW;\n        d2 = abs(d2) - lW;\n        \n    }\n    \n    // Joins.\n    d3 = sdBox(vec2(p.x, abs(p.y) - .5 + lW/3.), vec2(lW + .03, lW/6.));\n \td4 = sdBox(vec2(p.y, abs(p.x) - .5 + lW/3.), vec2(lW + .03, lW/6.));\n\n    \n    // Overall object.\n    return min(min(d1, d2), min(d3, d4));\n}\n\n/*\n// Altermative, cheaper shadow. Just a grid. Almost works... almost. :)\nfloat truShFake(vec2 p){\n   \n  p = abs(fract(p) - .5);\n  return min(p.x, p.y);\n}\n*/\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Screen coordinates. I've coded it for the 800 by 450 window, so have put some mild\n    // restrictions on the resolution to account for blurriness, Moire patterns at smaller\n    // canvas sizes, etc.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/clamp(iResolution.y, 350., 600.);\n    \n    // Mild lens distortion. It's a cool effect, but I wasn't feeling it for this example.\n    //uv *= 1. + dot(uv, uv)*.03;\n    \n    \n    // Scale. Analogous to the field of view.\n    const float sc = 4.;\n\n    // Sizing the scene and moving it.\n    vec2 p = uv*sc + vec2(sin(iTime*3.14159/16.)*2., 1.*iTime);\n    \n    // Putting a light slightly up to the right, just to match the fake drop shadows.\n    // It's used for a bit of subtle attenuation.\n    vec3 lp = vec3(vec2(sin(iTime*3.14159/16.), 1.*iTime) + .5, -1);\n    \n    // Keeping a copy of the sized screen coordinates.\n    vec2 oP = p;\n    \n    \n    // GRID SETUP.\n    //\n    // Grid square (tile) ID.\n    vec2 ip = floor(p);\n    \n    // Three random numbers, used for tile selection and tile flipping.\n    vec3 rnd = hash23(ip);\n    \n    // Partition the grid. Equivalent to: p = fract(p) - .5;\n    p -= ip + .5;\n    \n    // Depending on the random number, select the tile, and flip it if necessary.\n    if(rnd.z>.35){\n        // Cross rotation. Flipping has no effect.\n    \tif(rnd.x > .5) p = p.yx;\n    }\n    else if(rnd.y > .5) p.y = -p.y; // Dual arc flipping. Rotation does the same thing.\n\n        \n    \n    // THE BACKGROUND.\n    //\n    // Background: Not sure why I vignetted it, because it gets attenuated later... I'll\n    // amalgamate the two when I get time.\n    vec3 bg = vec3(1.1, 1, .9)*vec3(.85, .75, .65)*max(1. - length(uv)*.35, 0.);\n\n    \n    // Pipe pattern (dual Truchet) drop shadow.\n    float tru = truSh(oP + .1, .15);\n    //float tru = truShFake(oP + .1) - .15; // Fake shadow grid. \n    \n    // Put the drop shadow on the background.\n    bg = mix(bg, vec3(0), (1. - smoothstep(0., .15, tru))*.35);    \n    \n        \n\n    // Putting some lines on the background. I made it up as I went along, so I\n    // wouldn't take it too seriously.\n    #ifdef SHOW_SINGLE_TILES\n    const float scl = 1.;\n    #else\n    const float scl = .5;\n    #endif\n    float vor = bgLines((oP - (scl<.75? 0.: .5))*scl);\n    float sq = vor - .03*scl;\n    bg = mix(bg, vec3(0), (1. - smoothstep(0., .1*scl, sq))*.7);\n    sq = vor - (.075 + .01)*scl;\n    sq = abs(sq) - .0075*scl;\n    bg = mix(bg, vec3(0), (1. - smoothstep(0., .01*scl, sq))*.9);    \n    sq = vor;\n    sq = abs(sq) - .0075*scl;\n    bg = mix(bg, vec3(0), (1. - smoothstep(0., .01*scl, sq))*.9);\n\n    // Quick, diagonal line pattern. Pretty standard way to make one.   \n    float diag = clamp(sin((oP.x - oP.y)*6.283*20.)*1. + .95, 0., 1.)*.5 + .5;      \n    // Applying it to the background.\n\tbg = mix(bg, vec3(0), (smoothstep(0., .01*scl, vor - .0075*sc))*(1. - diag)*.9);\n   \n  \n\n    // MAIN OBJECT COMPOSITION.\n    //\n    // Scene color. Set it to the pre-prepared background.\n    vec3 col = bg;\n    vec3 jCol = vec3(1, .7, .5); //  Join color.\n    vec3 pCol = vec3(.95, .98, 1); // Pipe color.\n    float lW = .125; // Pipe width. \n    const float shadow = .35; // Drop shadow factor.\n    const float lnTrans = .9; // Shape line transparency.\n    \n    const float shPow = 4.; // Shade power.\n    const float shAmp = 1.1; // Shade amplitude.\n    const float shAmb = .1; // Shade ambience.\n    \n    \n    #ifdef ENVIRONMENTAL_LIGHTS\n    // Environmental light display: Interesting, but needs some tweaking. In case it needs to be said, I've \n    // added it in for visual interest. However, I can't really think of a physical reason why it'd be there...\n    // And why isn't at least some light registering on the back wall? ... So many unanswered questions. :D\n    tru = truSh(oP, .0);\n    float tru2 = truSh(r2(-3.14159/3.)*oP*3. + .5 + iTime*.35, .0);\n \tfloat lgtMsk = (1. - smoothstep(0., lW, tru))*(1. - smoothstep(0., .15, tru2));\n    #endif\n    \n    // OBJECT DISTANCE FIELDS.\n    //\n    // Distance and shading variables.\n    float d1, d2, d3, d4, d5, sh1, sh2, sh3, sh4, sh5;\n    \n    \n    // Apply the distance fields and shades for the overlayed straight pipe tile, and for\n    // the quarter bent pipe tile. The code below looks fiddly, but it's all pretty simple.\n    // Draw a rectange, or an arc, etc. Shade and so forth.\n    //\n    // Rendering more straight pipes than curved ones. Pipe bends tend to occur less.\n    if(rnd.z>.35){ \n        \n        // The overlayed straight pipes.\n        \n        // Vertical and horizontal pipes.\n        d1 = abs(p.y) - lW;\n        d2 = abs(p.x) - lW;\n        \n        #ifdef ENVIRONMENTAL_LIGHTS\n        // Adding the moving lights. I hacked this in. The cross over pipe needs a bit of masking,\n        // logic, due to one pipe going under the other. It doesn't look right without it.        \n        if(rnd.x<=.5) pCol = mix(pCol, vec3(2, 3, 4), (1. - smoothstep(0., .05, d2+lW))*lgtMsk*.5);\n\t\tpCol = mix(pCol, vec3(2, 2.5, 3), (smoothstep(0., .02, d2))*lgtMsk*.35);\n        #endif\n\n    }\n    else {\n        \n        // The quarter pipe bends. Two on each tile. I'm rendering both for simplicity.\n        // Plus, I wanted to ensure that the shadows rendered correctly. Having said that,\n        // I'll come back to this and cut down on the double rendering when I have time.\n        \n        // Two arcs (quarter pipes).\n        d1 = length(p - .5) - .5;\n        d2 = length(p + .5) - .5;\n        d1 = abs(d1) - lW;\n        d2 = abs(d2) - lW;\n        \n        #ifdef ENVIRONMENTAL_LIGHTS\n        // Adding the environmental lighting to the pipes.\n        pCol = mix(pCol, vec3(2, 2.5, 3), lgtMsk*.35);\n        #endif\n\n\n        \n    }\n    \n    #ifdef ENVIRONMENTAL_LIGHTS  \n    // Adding the environmental lighting to the joins.\n    jCol = mix(jCol, vec3(2, 2.5, 3), lgtMsk*.15);\n    #endif\n    \n    // Joins. They're the same for each tile, so can be taken outside the \"if\" statement.\n    d3 = sdBox(vec2(p.x, abs(p.y) - .5 + lW/3.25), vec2(lW + .03, lW/6.));\n    d4 = sdBox(vec2(p.y, abs(p.x) - .5 + lW/3.25), vec2(lW + .03, lW/6.));\n\n    // Extra shadowing, to place over the bottom pipe. Makes the shadows a little more realistic.\n    d5 = length(p) - .2;\n    \n    \n    // LIGHTING THE OBJECTS.\n    //\n    // Using the distance field to shade the objects. \n    sh1 = (-d1 + lW)/lW/2.;\n    sh2 = (-d2 + lW)/lW/2.;\n    float d3in = abs(p.x) - lW - .03;\n    float d4in = abs(p.y) - lW - .03;\n    sh3 = (-d3in + lW)/lW/2.;\n    sh4 = (-d4in + lW)/lW/2.;\n\n    // Tube ribbed lines.\n    sh1 *= clamp(sin(d1*6.283*24.)*.5 + 1., 0., 1.);\n    sh2 *= clamp(sin(d2*6.283*24.)*.5 + 1., 0., 1.);\n\n\n    // Ramping up the shading for a more metallic look.\n    sh1 = pow(max(sh1, 0.), shPow)*shAmp + shAmb;\n    sh2 = pow(max(sh2, 0.), shPow)*shAmp + shAmb;\n    sh3 = pow(max(sh3, 0.), shPow)*shAmp + shAmb;\n    sh4 = pow(max(sh4, 0.), shPow)*shAmp + shAmb;\n\n    sh5 = (cos(p.y*6.283*1.5)*.5 + 1.25);\n    sh5 = pow(sh5, 1.)*sh2;\n    \n    // RENDERING THE LAYERS.\n    //\n    // In short, render a drop shadow, sharp dark egde, then apply the main \n    // color and pattern. Pretty standard stuff.\n    //\n    // Drop shadow.\n    col = mix(col, vec3(0), (1. - smoothstep(0., .2, d1 - .03))*shadow);\n    // Dark edge.\n    col = mix(col, vec3(0), (1. - smoothstep(0., .01, d1 - .02))*lnTrans);\n    // Main color and pattern.\n    col = mix(col, pCol*sh1, 1. - smoothstep(0., .01, d1));\n    \n    // Fake drop shadow for the bottom straight tube - cast by the top one.\n    if(rnd.z>.35) col = mix(col, vec3(0), (1. - smoothstep(0., .2, d5))*.5); \n    col = mix(col, vec3(0), (1. - smoothstep(0., .2, d2 - .03))*shadow);\n    col = mix(col, vec3(0), (1. - smoothstep(0., .01, d2 - .02))*lnTrans);\n    col = mix(col, pCol*sh2, 1. - smoothstep(0., .01, d2));\n    \n    \n    // Extra lighting on the top cross section to give a slight bending impression...\n    // I doubt it's fooling anyone. :)\n    if(rnd.z>.35) col = mix(col, pCol*sh5, (1. - smoothstep(0., .01, d2))*.5);\n    \n    // Adding the joins - Pipes first. Joins afterward.\n    col = mix(col, vec3(0), (1. - smoothstep(0., .1, d4 - .02))*shadow);\n    col = mix(col, vec3(0), (1. - smoothstep(0., .01, d4 - .02))*lnTrans);\n    col = mix(col, jCol*sh4, 1. - smoothstep(0., .01, d4));\n        \n    col = mix(col, vec3(0), (1. - smoothstep(0., .1, d3 - .02))*shadow);\n    col = mix(col, vec3(0), (1. - smoothstep(0., .01, d3 - .02))*lnTrans);\n    col = mix(col, jCol*sh3, 1. - smoothstep(0., .01, d3));\n \n    \n    \n    \n    \n\n    // Very fake light attenuation. Using the shading information to pretend there's \n    // some 3D depth, then calculating the distance to the light hovering above it.\n    float atten = length(lp - vec3(oP, -col.x));\n    col *= vec3(1.15)*1./(1. + atten*atten*.05);\n    \n    // Adding some grunge, just to break things up a little. Comment this section\n    // out, and the example looks too clean.\n    float fBm = noise3D(vec3(oP*32., 1. - col.x))*.66 + noise3D(vec3(oP*64., 2. - 2.*col.x))*.34;\n    col *= fBm*.5 + .75;\n    \n    \n   \n    /*\n    // Cheap postprocess hash. Interesting, and looks cool with other examples, but \n\t// possibly a little too much grunge, in this instance. Anyway, I've left it here \n\t// for anyone who's like to take a look.\n    float gr = dot(col, vec3(.299, .587, .114))*1.15;\n    oP = r2(3.14159/3.)*oP;\n    if(gr<.4) col *= clamp(sin((oP.x - oP.y)*6.283*96./sc)*1. + .95, 0., 1.)*.4 + .6;\n    oP = r2(3.14159/3.)*oP;\n    if(gr<.55) col *= clamp(sin((oP.x - oP.y)*6.283*96./sc)*1. + .95, 0., 1.)*.4 + .6;\n    oP = r2(3.14159/3.)*oP;\n    if(gr<.75) col *= clamp(sin((oP.x - oP.y)*6.283*96./sc)*1. + .95, 0., 1.)*.4 + .6;\n    */\n\n\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXBzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1289, 1322, 1342, 1342, 1400], [1403, 1663, 1685, 1778, 2729], [2732, 2792, 2820, 2820, 2943], [2945, 3033, 3055, 3055, 3176], [3178, 3307, 3327, 3327, 3535], [3537, 3747, 3777, 3835, 4900], [4902, 5063, 5117, 5325, 14886]], "test": "untested"}
{"id": "XlXfD2", "name": "water waves - full dispersion", "author": "FabriceNeyret2", "description": "splash equation accounting for gravity waves, capillary waves, water depth.\nNot simulated: trochoïd profile\n\nGravity waves: shorter is slower.\nCapillary waves: opposite.\nShallow: caps gravity waves celerity.", "tags": ["fluids"], "likes": 6, "viewed": 1035, "published": "Public API", "date": "1513270962", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://en.wikipedia.org/wiki/Dispersion_(water_waves)\n\n#define rnd(v)   fract( 43758.5453 * sin( (v) * 78.233 ) )\n#define gauss(v) exp(  -.5*(v)*(v) )\n#define tanh(x)  ( abs(x) > 8. ? sign(x) : tanh(x) ) // to allow values larger than 87\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n\tvec2 R = iResolution.xy;\n    U = 20.* ( U+U - R ) / R.y;                      // window radius (m)\n    O -= O;\n    float h = 100.,                                  // water depth (m) \n          t = iTime -9.*step(R.y,200.),              // splash sync for icon and window\n          l = length(U),\n          s = 0.;\n    t = mod( t, 30.) * 2.;\n    \n    for (float k = 6.28/1.; k < 6.28/.01; k++ ) {    // for all wavelengthes\n        float w = sqrt( (9.81*k + 74E-6*k*k*k) * tanh(k*h) ), // w(k) = dispertion relation\n           // w² = ( gk + s/r k³ ) tanh(kh) , g=9.81, s=0.074, r=10³\n              phi = k*l - w*t ,                      // opt: + rnd(k)*6.28 \n              E = gauss( phi/10. ) / k ;             // emission spectrum in k and spacetime(0)\n           // E = gauss( phi/k )     / k ;             \n           // E = phi<0. ? exp(phi/5.) / k : 0.;\n           // E = ( phi<0. ? exp(phi/10.) : gauss( phi/2. ) ) / k;\n         O += E * cos (phi );                        // wave equation     \n        s += 1./k;\n    }\n    O = .5 + 5.*O/s;              \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXfD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 243, 281, 281, 1351]], "test": "untested"}
{"id": "XlXfW7", "name": "first_tests", "author": "steko", "description": "mm", "tags": ["ss"], "likes": 0, "viewed": 57, "published": "Public", "date": "1512084208", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool isInCircle(vec2 pixelCoords)\n{\n    vec2 circleCenter = vec2(0);\n    float radius = 0.35 * sin(iTime*2.);\n    float distanceToCenter = distance(pixelCoords, circleCenter); \n    \n    bool isInCircle = (distanceToCenter < radius);\n    return isInCircle;\n}\n\nbool isInLeftPart(vec2 pixelCoords)\n{\n    bool isInLeftPart = pixelCoords.x < 0.0;\n    return isInLeftPart;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; // 0 <> 1\n    uv.xy -= 0.5; // -0.5 <> 0.5\n    float aspect = iResolution.x / iResolution.y; // 640 / 360 = 1.78\n    uv.x *= aspect;\n    \n    \n    if(isInCircle(uv))\n    {\n        fragColor = vec4(uv.y + 0.5, uv.x + 0.4, 0.3, 1.0);        \n    }\n    else if(isInLeftPart(uv))\n    {\n        fragColor = vec4(uv + 0.6,0.5+0.5*sin(iTime),1.0);\n    }\n    else\n    {\n        fragColor = vec4(-uv.x + 0.6, uv.y + 0.6, 0.5+0.5*sin(iTime),1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXfW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 257], [259, 259, 296, 296, 368], [370, 370, 427, 427, 914]], "test": "untested"}
{"id": "XlXfz2", "name": "Smooth Yin Yang", "author": "KilledByAPixel", "description": "A smoothly anti aliased yin yang without super sampling\n\n", "tags": ["antialias", "yang", "yin"], "likes": 4, "viewed": 374, "published": "Public API", "date": "1512447985", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////////////////////////////////////\n// Smooth Yin Yang - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nfloat Blur = 8.0;\nfloat DotSize = 0.3;\nfloat OutlineThickness = 0.03;\n\nfloat YinYang( float co, vec2 p, float scale, float blur, float outline, float dotSize )\n{\n   \tfloat b = blur*scale/min(iResolution.y,iResolution.x);\n    float d = dotSize;\n    float o = outline;\n    float c;\n    \n    float r = length(p);\n    float r1 = length(2.0*p + vec2(0, 1));\n    float r2 = length(2.0*p - vec2(0, 1));\n    \n    // curves\n    if (p.x < 0.0)\n\t\tc = mix(1.0, 0.0, smoothstep(1.0-b, 1.0+b, r1));\n    else\n\t\tc = mix(0.0, 1.0, smoothstep(1.0-b, 1.0+b, r2));\n    \n    // dots\n    c = mix(0.0, c, smoothstep(d-b, d+b, r1));\n    c = mix(1.0, c, smoothstep(d-b, d+b, r2));\n\n    // outline\n    c = mix(c, 0.0, smoothstep(1.0-b, 1.0, r));\n    c = mix(c, co, smoothstep(1.0+o, 1.0+o+b, r));\n\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // zoom\n    float z =  mix(1.1, 5.0, pow(smoothstep(-1.0, 1.0, sin(20.0 + 0.5*iTime)), 2.0));\n\tvec2 p = z * (2.0*fragCoord-iResolution.xy)/min(iResolution.y, iResolution.x);\n   \n    // rotate\n    float theta = -0.2*iTime;\n\tfloat ct = cos(theta);\n\tfloat st = sin(theta);\n    p *= mat2(-st, ct, ct, st);\n    \n    // use mouse to pick center line\n    float centerLine = (iMouse.x > 0.0)? iMouse.x : iResolution.x/2.0;\n    \n    // yin yang (no blur on right side)\n   \tfloat c = 0.5;\n    if (fragCoord.x < centerLine)\n\t    c = YinYang(c, p, z, Blur, OutlineThickness, DotSize);\n    else\n\t    c = YinYang(c, p, z, 0.0, OutlineThickness + .005*pow(z, 0.9), DotSize);\n    \n    // center line\n    if (fragCoord.x > centerLine - 1.0 && fragCoord.x < centerLine + 1.0)\n        c = mix(c, 0.0, 0.5);\n    \n    fragColor = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXfz2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 373, 463, 463, 1089], [1092, 1092, 1149, 1161, 1973]], "test": "untested"}
{"id": "XlXfzX", "name": "Boing short sphere tracing.", "author": "gyabo", "description": "Simple shader ;-)", "tags": ["spheretracing"], "likes": 0, "viewed": 98, "published": "Public", "date": "1512594428", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 p) {\n\tfloat t = length(mod(p, 2.0) - 1.0) - 0.1;\n\tt = min(t, length(mod(p.xz, 2.0) - 1.0) - 0.03);\n\tt = min(t, length(mod(p.yz, 2.0) - 1.0) - 0.03);\n\treturn min(t, length(mod(p.xy, 2.0) - 1.0) - 0.03);\n}\n\n\nvec2 rot(vec2 p, float a) {\n\treturn vec2(\n\t\tp.x * cos(a) - p.y * sin(a),\n\t\tp.x * sin(a) + p.y * cos(a));\n\t\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = ( gl_FragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n\n\tvec3 dir = normalize(vec3(uv, 1.0));\n\tdir.xz= rot(dir.xz, iTime * 0.1);\n    dir.yx= rot(dir.yx, iTime * 0.1);\n\n\tvec3 pos = vec3(0, 0, iTime);\n\tfloat t = 0.0;\n\tfor(int i = 0;  i < 100; i++) {\n\t\tfloat k = map(dir * t + pos);\n\t\tif(k < 0.1) break;\n\t\tt += 1.0;\n\t}\n\tvec3 ip = dir * t + pos;\n\n\tfragColor = vec4(t * 0.01) + map(ip + 0.1) + dir.xyzz * 0.7;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXfzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 218], [221, 221, 248, 248, 330], [332, 332, 389, 389, 803]], "test": "untested"}
{"id": "Xt2BzR", "name": "Power Ball", "author": "chrisjj", "description": "V4\n\nI'm striving for the smallest visually-engaging shader on ShaderToy. If you know of any I need to beat, do tell! :)", "tags": ["tiny", "faux3d"], "likes": 1, "viewed": 132, "published": "Public", "date": "1514305469", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy) / min(iResolution.x,iResolution.y);\n\n\tuv /= .7+0.35*sin(t);                           // zoom\n\tuv /= .7 + abs(.7-length(uv));                  // ball\n\tuv += 0.3*tan(t/5.)*cos(t/19.9*vec2(.77,2.22)); // pattern slide\n    uv *= 0.54+.5*sin(t/3.2);                       // pattern zoom\n\n\tvec3 c = cos(uv.x*20.)*cos(uv.y*20.) + sin(t*vec3(1.,1.1,1.11));\n    c = c*c/3.;                                     // colour fold and spiff\n\t\n    fragColor=vec4( c, .0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2BzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 74, 581]], "test": "untested"}
{"id": "Xt2fzh", "name": "SphereNoiser", "author": "felipunkerito", "description": "Play with the sphere nigga", "tags": ["raytracing", "pseudostochasticnumbers"], "likes": 0, "viewed": 508, "published": "Public API", "date": "1514608878", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// hash function by iq\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nvec3 map( vec3 p )\n{\n\n\tvec3 dl = vec3( length( p ) - 1.5 );\n    vec3 dlOne = vec3( p.y + 2.0 );\n    if( dl.y < dlOne.y ) dlOne = dl;\n    return dlOne;\n\n}\n\nvec3 rayIntersect( vec3 ro, vec3 rd )\n{\n\n    vec3 t = vec3( 0.0, 0.0, 0.0);\n    int maxiter = 64;\n    \n    for(int i = 0; i < maxiter; ++i )\n    {\n    \n    \tvec3 hit = ro + rd * t;\n        vec3 d = map(hit);\n        t += d * vec3( 0.5 );\n    \n    }\n    \n    return t;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y; \n    \n    vec2 mouser = iMouse.xy / iResolution.y; \n    \n    vec3 ro = vec3( 0.0, 0.0, 2.5 );\n    vec3 rd = normalize( vec3( uv, -1.0 ) );\n    \n    float f = 0.0;\n    \n    float wav = texture(iChannel0, vec2( 0.0, 0.25 )).x;\n    wav *= 0.3;\n    float fft = texture(iChannel0, vec2( 0.0, 0.75 )).x;\n    fft *= 0.3;\n    \n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    uv += iTime * 0.1; \n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += wav * 0.1 + 0.0625*noise( uv ); uv = m*uv;\n    fft += f * 0.4738*noise( uv ); uv = m*uv;\n    \n    vec3 hitter = vec3( rayIntersect( ro, rd ) );\n    hitter = 1.0 / (2.0 * hitter * hitter * 0.5 );\n    //hitter = smoothstep( hitter, 0.1, 1.2 );\n    vec3 hit = vec3( hitter * f ) * vec3( sin( fft * iMouse.x), f, cos( fft * iMouse.y * fft )  );\n    hit *= vec3(5.0);\n    \n    \n\tfragColor = vec4( hit, 1.0 );\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2fzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 24, 81, 81, 185], [187, 187, 213, 213, 507], [510, 510, 530, 530, 663], [665, 665, 704, 704, 935], [937, 937, 994, 994, 2014]], "test": "untested"}
{"id": "XtBBzR", "name": "Dreaming Cube Snake", "author": "slerpy", "description": "Quick and dirty", "tags": ["raytracing", "colors", "fun", "foggy", "rainbow", "trippy", "experimental", "bored"], "likes": 25, "viewed": 828, "published": "Public API", "date": "1514593829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITER 28\n\nmat2 rot(float a){ float s=sin(a), c=cos(a); return mat2(c,s,-s,c); }\nfloat box(vec3 p, float r){ return length(max(abs(p)-r,0.)); }\n\nfloat map(vec3 p)\n{   \n    float s = sin( iTime + .6*p.z )/4.;\n    p.xy *= rot( s );\n    p.xy += .5 + vec2( -s, s );\n    \n    vec3 q = abs( p-round(p) );\n    float d = min(min(length(q.xy), length(q.xz)), length(q.yz)) - .01;\n    d = min(d, box(q, .05));\n    q = vec3(.0, ( p.xy - vec2(2.5, 0.5) ) * rot( p.z+iTime ) );\n    d = min(d, box(q, .25));\n    \n    return d;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n\tvec3  R = iResolution.xyy,\n         rd = normalize(vec3(U-.5*R.xy, R.y)),\n\t     ro = vec2(.0, iTime).xxy;\n    \n    //uint xor = ( (uint(U.x) ^ uint(U.y)) - uint(iFrame) ) % uint(R.x);\n    //if(xor != 0u)discard;\n    \n    rd.xz *= rot(.6);\n    \n    float t=.0, m;\n    for( int i=0; ++i < ITER; ) {\n    \tt += map(ro+rd*t)/2.;\n    }\n    \n    O = vec4( cos(t*rd.z + iTime - .5),\n              exp(-t/6.),\n              1.-exp(-t/4.), \n              1 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBBzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 35, 35, 86], [87, 87, 114, 114, 149], [151, 151, 170, 170, 520], [522, 522, 560, 560, 1013]], "test": "untested"}
{"id": "XtBfz1", "name": "100000 Pins Valley", "author": "aiekick", "description": "100000 Pins Valley", "tags": ["valley", "100000", "pins"], "likes": 31, "viewed": 2732, "published": "Public API", "date": "1514497895", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float df(vec3 p)\n{\n\tfloat a = p.z * cos(p.z * 2.0) * 0.001;\n\tp.xy *= mat2(cos(a),sin(a),-sin(a), cos(a));\n\tp.y += sin(p.x * .5 + p.z * 0.5);\n\tfloat sp = 10. - abs(p.y * 0.5);\n\tfloat cy = max(1.0-0.2*sin(p.z*0.5)-abs(p.y*0.5),length(mod(p.xz, 1.)-0.5) - 0.2);\n    return min(sp,cy);\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy) - df(pos-eps.xyy),\n\t    df(pos+eps.yxy) - df(pos-eps.yxy),\n\t    df(pos+eps.yyx) - df(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 g = fragCoord;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (g+g-si)/si.y/0.8;\n\tvec3 ro = vec3(0,0, (iTime + 30.) * 2.); \n    vec3 cv = ro + vec3(0,0,1); \n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n    float fov = .9;\n  \tvec3 rd = normalize(fov * (uv.x * x + uv.y * y) + z);\n\t\n\tfloat s = 1., d = 0.;\n\tfor (int i=0; i<150; i++) \n\t{\n\t\tif (log(d*d/s/1e6)>0.) break;\n\t\ts=df(ro+rd*d);\n\t\td += s * .15;\n\t}\n\t\n\tvec3 p = ro + rd * d;\n\tvec3 lid = normalize(ro-p);\n\tvec3 n = nor(p, 0.1);\n\tvec3 refl = reflect(rd,n);\n\tfloat diff = clamp( dot( n, lid ), 0.0, 1.0 );\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. );\n\tfloat spe = pow(clamp( dot( refl, lid ), 0.0, 1.0 ),16.);\n\tvec3 col = vec3(.8,.5,.2);\n    \n    float sss = df(p - n*0.001)/0.05;\n\t\n\tfragColor.rgb = mix(\n\t(diff * vec3(0.8,0.2,0.5) + fre + sss * vec3(0.8,0.5,0.5)) * 0.25,\n\tvec3(spe * 0.5), \n\texp(-0.01 * d*d));\n\n\tvec2 q = g/si;\n    fragColor.rgb *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.55 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBfz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 283], [285, 285, 319, 319, 519], [521, 521, 578, 578, 1626]], "test": "untested"}
{"id": "XtBfzD", "name": "Torus_Thingy_7", "author": "balkhan", "description": "https://soundcloud.com/pbondoer/forever-striving", "tags": ["raymarch", "interactive", "torus"], "likes": 6, "viewed": 164, "published": "Public", "date": "1514738711", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tsdTorus( vec3 p, vec2 t, float phase );\nfloat\tmylength(vec2 p);\nfloat\tnrand( vec2 n );\n\nfloat \tt;\t\t\t// time\nvec3\th; \t\t\t// light amount\nfloat\tmind;\n\n\n#define I_MAX\t\t100.\n#define E\t\t\t0.0001\n#define FAR\t\t\t50.\n\n/*\n* Leon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\n#define PI 3.14159\n#define TAU PI*2.\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// -------------blackbody----------------- //\n\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(0., 0., 10.);\n\n    vec2\tinter = (march(pos, dir));\n    if (inter.y < FAR)\n        col.xyz = vec3(.20,.1, .8)*(inter.y*.5-inter.x*.3);\n    else\n\t    col.xyz = vec3(.50, .52, .27);\n    col.xyz += +1.*blackbody(inter.x*30.-inter.y*10.);\n    c_out =  vec4(col,1.0);\n}\n\nfloat\tscene(vec3 p)\n{\n    mind = 1e5;\n\n    p.z += 15.;\n\trotate(p.xz, -.515*iTime);\n    rotate(p.yz, 1.57+sin(.5*iTime)*.125);\n    vec3 op = p;\n    float\tvar = (atan(p.x, p.z)+ PI)/(TAU);\n    float\tvir = 0.;\n    p.xz = modA(p.xz, 128.);\n    p.xz -= vec2(8., .0);\n    vec2 q = vec2(length(p.xy)-4.,p.z);\n    vir = (atan(p.x, p.y)+ PI)/(TAU);\n    var = abs(var-.5);\n    vir = abs(vir-.5);\n    float\tvir_sound = texture(iChannel0, vec2(floor(vir*128.)/128., .0) ).x;\n    float\tvar_sound = texture(iChannel0, vec2(floor(var*128.)/128., .0) ).x;\n    mind = mylength(q)+.5-1. * max(vir_sound,var_sound);\n\n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\tfloat dinamyceps = E;\n\tfor (float i = -1.; i < I_MAX; ++i)\n\t{\n\t\tp = pos + dir * dist.y;\n\t\tdist.x = scene(p);\n\t\tdist.y += dist.x*.5;\n        dinamyceps = -dist.x+(dist.y)/(2500.);\n        // log trick from aiekick\n\t    if (log(dist.y*dist.y/dist.x/1e5)>0. || dist.x < dinamyceps || dist.y > FAR)\n        {\n            break;\n        }\n\t    s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n    \n    p = p*p*p*p;\n    p = p*p;\n    ret = (p.x+p.y);\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,\n           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,\n           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));\n}", "image_inputs": [{"id": "Xd2XRD", "previewfilepath": "https://soundcloud.com/pbondoer/forever-striving", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/pbondoer/forever-striving", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBfzD.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[472, 581, 614, 614, 745], [859, 1081, 1109, 1109, 1434], [1436, 1484, 1527, 1527, 1951], [1953, 1953, 1974, 1974, 2571], [2573, 2573, 2605, 2605, 3089], [3091, 3091, 3115, 3115, 3233], [3235, 3249, 3289, 3289, 3364], [3366, 3366, 3394, 3394, 3502], [3504, 3504, 3526, 3526, 3732], [3734, 3734, 3784, 3784, 4047]], "test": "untested"}
{"id": "XtBfzz", "name": "Filtered grid (box, 2D)", "author": "iq", "description": "Analytically antialiased grid. Left, naive grid pattern. Right, analytically filtered (NO supersampling and NO mipmapping involved). More info: [url]http://iquilezles.org/www/articles/filterableprocedurals/filterableprocedurals.htm[/ur", "tags": ["procedural", "2d", "grid", "filter"], "likes": 104, "viewed": 5840, "published": "Public API", "date": "1514179525", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Analiyically filtering a grid pattern (ie, not using supersampling or mipmapping.\n//\n// Info: http://iquilezles.org/www/articles/filterableprocedurals/filterableprocedurals.htm\n//  \n// More filtered patterns:  https://www.shadertoy.com/playlist/l3KXR1\n\n\n// --- analytically box-filtered grid ---\n\nconst float N = 10.0; // grid ratio\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n\t// filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n\n\t// analytic (box) filtering\n    vec2 a = p + 0.5*w;                        \n    vec2 b = p - 0.5*w;           \n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))/(N*w);\n    //pattern\n    return (1.0-i.x)*(1.0-i.y);\n}\n\n// --- unfiltered grid ---\n\nfloat gridTexture( in vec2 p )\n{\n    // coordinates\n    vec2 i = step( fract(p), vec2(1.0/N) );\n    //pattern\n    return (1.0-i.x)*(1.0-i.y);   // grid (N=10)\n    \n    // other possible patterns are these\n    //return 1.0-i.x*i.y;           // squares (N=4)\n    //return 1.0-i.x-i.y+2.0*i.x*i.y; // checker (N=2)\n}\n\n\n//===============================================================================================\n//===============================================================================================\n// sphere implementation\n//===============================================================================================\n//===============================================================================================\n\nfloat softShadowSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = sph.xyz - ro;\n    float b = dot( oc, rd );\n\t\n    float res = 1.0;\n    if( b>0.0 )\n    {\n        float h = dot(oc,oc) - b*b - sph.w*sph.w;\n        res = smoothstep( 0.0, 1.0, 2.0*h/b );\n    }\n    return res;\n}\n\nfloat occSphere( in vec4 sph, in vec3 pos, in vec3 nor )\n{\n    vec3 di = sph.xyz - pos;\n    float l = length(di);\n    return 1.0 - dot(nor,di/l)*sph.w*sph.w/(l*l); \n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    float t = -1.0;\n\tvec3  ce = ro - sph.xyz;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\tt = -b - sqrt(h);\n\t}\n\t\n\treturn t;\n}\n\n//===============================================================================================\n//===============================================================================================\n// scene\n//===============================================================================================\n//===============================================================================================\n\n\n// spheres\nconst vec4 sc0 = vec4(  3.0, 0.5, 0.0, 0.5 );\nconst vec4 sc1 = vec4( -4.0, 2.0,-5.0, 2.0 );\nconst vec4 sc2 = vec4( -4.0, 2.0, 5.0, 2.0 );\nconst vec4 sc3 = vec4(-30.0, 8.0, 0.0, 8.0 );\n\nfloat intersect( vec3 ro, vec3 rd, out vec3 pos, out vec3 nor, out float occ, out int matid )\n{\n    // raytrace\n\tfloat tmin = 10000.0;\n\tnor = vec3(0.0);\n\tocc = 1.0;\n\tpos = vec3(0.0);\n    matid = -1;\n\t\n\t// raytrace-plane\n\tfloat h = (0.01-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tmatid = 0;\n\t\tocc = occSphere( sc0, pos, nor ) * \n\t\t\t  occSphere( sc1, pos, nor ) *\n\t\t\t  occSphere( sc2, pos, nor ) *\n\t\t\t  occSphere( sc3, pos, nor );\n\t}\n\n\n\t// raytrace-sphere\n\th = iSphere( ro, rd, sc0 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + h*rd;\n\t\tnor = normalize(pos-sc0.xyz); \n\t\tmatid = 1;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc1 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(pos-sc1.xyz); \n\t\tmatid = 2;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc2 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(pos-sc2.xyz); \n\t\tmatid = 3;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc3 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(pos-sc3.xyz); \n\t\tmatid = 4;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\treturn tmin;\t\n}\n\nvec2 texCoords( in vec3 pos, int mid )\n{\n    vec2 matuv;\n    \n    if( mid==0 )\n    {\n        matuv = pos.xz;\n    }\n    else if( mid==1 )\n    {\n        vec3 q = normalize( pos - sc0.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc0.w;\n    }\n    else if( mid==2 )\n    {\n        vec3 q = normalize( pos - sc1.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc1.w;\n    }\n    else if( mid==3 )\n    {\n        vec3 q = normalize( pos - sc2.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc2.w;\n    }\n    else if( mid==4 )\n    {\n        vec3 q = normalize( pos - sc3.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc3.w;\n    }\n\n\treturn 8.0*matuv;\n}\n\n\nvoid calcCamera( out vec3 ro, out vec3 ta )\n{\n\tfloat an = 0.1*sin(0.1*iTime);\n\tro = vec3( 5.0*cos(an), 0.5, 5.0*sin(an) );\n    ta = vec3( 0.0, 1.0, 0.0 );\n}\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in float occ, in vec3 rd )\n{\n    float sh = min( min( min( softShadowSphere( pos, vec3(0.57703), sc0 ),\n\t\t\t\t              softShadowSphere( pos, vec3(0.57703), sc1 )),\n\t\t\t\t              softShadowSphere( pos, vec3(0.57703), sc2 )),\n                              softShadowSphere( pos, vec3(0.57703), sc3 ));\n\tfloat dif = clamp(dot(nor,vec3(0.57703)),0.0,1.0);\n\tfloat bac = clamp(0.5+0.5*dot(nor,vec3(-0.707,0.0,-0.707)),0.0,1.0);\n    vec3 lin  = dif*vec3(1.50,1.40,1.30)*sh;\n\t     lin += occ*vec3(0.15,0.20,0.30);\n\t     lin += bac*vec3(0.10,0.10,0.10)*(0.2+0.8*occ);\n\n    return lin;\n}\n//===============================================================================================\n//===============================================================================================\n// render\n//===============================================================================================\n//===============================================================================================\n\nvoid calcRayForPixel( in vec2 pix, out vec3 resRo, out vec3 resRd )\n{\n\tvec2 p = (2.0*pix-iResolution.xy) / iResolution.y;\n\t\n     // camera movement\t\n\tvec3 ro, ta;\n\tcalcCamera( ro, ta );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\t\n\tresRo = ro;\n\tresRd = rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n\t\n    float th = (iMouse.z>0.001) ? (2.0*iMouse.x-iResolution.x)/iResolution.y : 0.0;\n    \n\tvec3 ro, rd, ddx_ro, ddx_rd, ddy_ro, ddy_rd;\n\tcalcRayForPixel( fragCoord + vec2(0.0,0.0), ro, rd );\n\tcalcRayForPixel( fragCoord + vec2(1.0,0.0), ddx_ro, ddx_rd );\n\tcalcRayForPixel( fragCoord + vec2(0.0,1.0), ddy_ro, ddy_rd );\n\t\t\n    // trace\n\tvec3 pos, nor;\n\tfloat occ;\n    int mid;\n    float t = intersect( ro, rd, pos, nor, occ, mid );\n\n\tvec3 col = vec3(0.9);\n\tif( mid!=-1 )\n\t{\n#if 1\n\t\t// -----------------------------------------------------------------------\n        // compute ray differentials by intersecting the tangent plane to the  \n        // surface.\t\t\n\t\t// -----------------------------------------------------------------------\n\n\t\t// computer ray differentials\n\t\tvec3 ddx_pos = ddx_ro - ddx_rd*dot(ddx_ro-pos,nor)/dot(ddx_rd,nor);\n\t\tvec3 ddy_pos = ddy_ro - ddy_rd*dot(ddy_ro-pos,nor)/dot(ddy_rd,nor);\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec2     uv = texCoords(     pos, mid );\n\t\tvec2 ddx_uv = texCoords( ddx_pos, mid ) - uv;\n\t\tvec2 ddy_uv = texCoords( ddy_pos, mid ) - uv;\n#else\n\t\t// -----------------------------------------------------------------------\n        // Because we are in the GPU, we do have access to differentials directly\n        // This wouldn't be the case in a regular raytracer.\n\t\t// It wouldn't work as well in shaders doing interleaved calculations in\n\t\t// pixels (such as some of the 3D/stereo shaders here in Shadertoy)\n\t\t// -----------------------------------------------------------------------\n\t\tvec2 uvw = texCoords( pos, mid );\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec2 ddx_uvw = dFdx( uvw ); \n        vec2 ddy_uvw = dFdy( uvw ); \n#endif\n        \n\t\t// shading\t\t\n\t\tvec3 mate = vec3(0.0);\n\n        if( p.x<th ) mate = vec3(1.0)*gridTexture( uv );\n        else         mate = vec3(1.0)*gridTextureGradBox( uv, ddx_uv, ddy_uv );\n            \n        // lighting\t\n\t\tvec3 lin = doLighting( pos, nor, occ, rd );\n\n        // combine lighting with material\t\t\n\t\tcol = mate * lin;\n\t\t\n        // fog\t\t\n        col = mix( col, vec3(0.9), 1.0-exp( -0.00001*t*t ) );\n\t}\n\t\n    // gamma correction\t\n\tcol = pow( col, vec3(0.4545) );\n\n\tcol *= smoothstep( 1.0, 2.0, abs(p.x-th)/(2.0/iResolution.y) );\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBfzz.jpg", "access": "shaders20k", "license": "mit", "functions": [[1401, 1415, 1480, 1498, 1799], [1801, 1829, 1861, 1880, 2143], [2146, 2564, 2627, 2627, 2850], [2852, 2852, 2910, 2910, 3018], [3020, 3020, 3074, 3074, 3260], [3665, 3861, 3956, 3972, 5070], [5072, 5072, 5112, 5112, 5752], [5755, 5755, 5800, 5800, 5911], [5913, 5913, 5984, 5984, 6541], [6542, 6945, 7014, 7014, 7384], [7386, 7386, 7443, 7443, 9767]], "test": "untested"}
{"id": "XtfBRs", "name": "Road_Trip", "author": "kalkas", "description": "Homework, 3rd", "tags": ["homework", "nothingspecial"], "likes": 1, "viewed": 106, "published": "Public", "date": "1513243075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 skyColor = vec4(1.0, 0.3, 0.0, 1.0);\nvec4 sunColor = vec4(1.0, 1.0, 0.0, 1.0);\nvec4 sunraysColor = vec4(1.0, 0.8, 0.0, 1.0);\nvec4 groundColor = vec4(0.0, 0.3, 0.0, 1.0);\n\nvec4 BlendColors(vec4 _c1, vec4 _c2) {\n    \n    //Blend equation. c1 is over c2\n    //c1*a1 + c2*a2(1 - a1)\n    //---------------------\n    //   a1 + a2(1 - a1)\n    \n    return (_c1*_c1.a + _c2*_c2.a*(1.0 - _c1.a)) / (_c1.a + _c2.a*(1.0 - _c1.a));\n}\n\nvec4 DrawTheSun(vec2 _coords) {\n    \n    //Sun's radius is between 90% and 110% of the half vertical resolution\n    float sunRadius = (sin(iTime)/10.0 + 1.0) * iResolution.y / 2.0;\n    \n    //Current pixel's distance from screen's center\n    float currentLength = length(_coords);\n    \n    //Depending on the distance from the center, color is white at center and yellow on the edge\n    sunColor.b = 1.0 - smoothstep(0.0, sunRadius, currentLength);\n    \n    //Alpha is 1.0 at 60% of the radius inwards and drops to 0.0 on the edge\n    sunColor.a = 1.0 - smoothstep(sunRadius * 0.6, sunRadius, currentLength);\n\n    return BlendColors(sunColor, skyColor);\n}\n\nvec4 DrawTheSunrays(vec2 _coords) {\n    \n    //Angle with X axis. Range is [-π, π]\n    float angle = atan(_coords.y, _coords.x);\n    \n    //Scale the angle to get more rays\n    angle *= 16.0;\n    \n    //cos() range is [-1.0, 1.0]. Scale and translate to make it [0.0, 0.5]\n    sunraysColor.a = cos(angle) / 4.0 + 0.25;\n    \n    return sunraysColor;\n}\n\nvec4 DrawTheSky(vec2 _coords) {\n    \n    skyColor = BlendColors(DrawTheSunrays(_coords), skyColor);\n    \n    return BlendColors(DrawTheSun(_coords), skyColor);\n}\n\nvec4 DrawTheRoad(vec2 _coords) {\n    \n    float roadWidth = iResolution.x / 4.0;\n    float xLength = abs(_coords.x);\n    vec4 roadColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    roadWidth *= abs(_coords.y) / iResolution.y * 1.5 + 0.25;\n    \n    if(xLength > roadWidth) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n    }\n    \n    if(xLength < roadWidth*0.85 && xLength > roadWidth*0.8){\n        return vec4(1.0, 1.0, 1.0, 1.0);\n    }\n    \n    if(xLength < roadWidth*0.05 && cos((_coords.y + iTime*200.0 ) / 20.0) > 0.0){\n        return vec4(1.0, 1.0, 1.0, 1.0);\n    }\n    \n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvec4 DrawTheGround(vec2 _coords) {\n    \n    vec4 sunBlend = vec4(1.0, 0.4, 0.0, 0.5);\n    sunBlend.a *= 1.0 - smoothstep(0.0, iResolution.y/2.0, abs(_coords.y));\n    groundColor = BlendColors(DrawTheRoad(_coords), groundColor);\n    \n    return BlendColors(sunBlend, groundColor);\n}\n\nvec4 GetColor(vec2 _coords) {\n    \n    if(_coords.y >= 0.0){\n        return DrawTheSky(_coords);\n    }else{\n        return DrawTheGround(_coords);\n    }\n    //return DrawSky(_coords);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tvec2 newCoords = fragCoord.xy - iResolution.xy / 2.0;\n\tfragColor = GetColor(newCoords);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtfBRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 214, 336, 425], [427, 427, 458, 538, 1082], [1084, 1084, 1119, 1168, 1436], [1438, 1438, 1469, 1469, 1599], [1601, 1601, 1633, 1633, 2204], [2206, 2206, 2240, 2240, 2487], [2489, 2489, 2518, 2518, 2674], [2676, 2676, 2733, 2733, 2829]], "test": "untested"}
{"id": "XtffDX", "name": "fractal_2d_kali_0", "author": "balkhan", "description": "http://iquilezles.org/www/articles/mset_smooth/mset_smooth.htm", "tags": ["fractal", "polar"], "likes": 2, "viewed": 107, "published": "Public", "date": "1513497768", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define I_MAX 150\n\n/*\n**\tLeon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\n#define PI 3.14159\n#define TAU PI*2.\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n/*\n**\tend mod polar\n*/\n\nvec2 \tcmult(vec2 a, vec2 b);\nvec2\tcadd(vec2 a, vec2 b);\n\nvoid\tmainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tuv = fragCoord.xy / iResolution.xy;\n    vec4\tz = vec4(0.0, 0.0, 0.0, 0.0);\n    vec2\tof = vec2((uv.x -0.5)/0.25, (uv.y -0.5)/0.25);\n    vec3\tcol = vec3(0.0);\n    vec2\tdist = vec2(0.0);\n    z.xy = of;\n    float ii = -1.;\n    z.xy = modA(z.xy, 5.);\n    z.x -= .753;\n    for (int i = -1; i < I_MAX; ++i)\n    {\n        ++ii;\n        z.xy = cadd((cmult( abs(z.xy)-1.0*sin(iTime*.25)*.13 , abs(z.xy)-1.0*sin(iTime*.25)*.13 )), vec2(-.3, -2.0));\n        vec2 fz = fract(z.xy*1.1)-.5;\n        z.xy += 1./max(fz*fz, .9750);\n        z.xy = cadd(z.xy, .051*vec2(sin(-3.55), cos(-3.55)) );\n        z.z = 2.0 * (z.x*z.z - z.y*z.w);\n        z.w = 2.0 * (z.y*z.z - z.x*z.w);\n        dist.x = dot(z.xy,z.xy);\n\t\tdist.y = dot(z.zw,z.zw);\n        if (dist.x > 100000000000.0 || dist.y > 100000000000.0)\n            break;\n    }\n    // iq\n    // http://iquilezles.org/www/articles/mset_smooth/mset_smooth.htm\n    vec3\ttmp = vec3(0.);\n        if( ii < float(I_MAX)-.5 )\n        {\n            float sit = ii - log2(log2(dot(z.xy,z.xy))/(log2(2.)))/log2(2.); \n            tmp = \n                +\n                vec3(\n                sin(+sit*.25+0.00)*.25 + .5\n                ,\n                sin(+sit*.25+1.04)*.25 + .3\n                ,\n                sin(+sit*.25+2.08)*.25 + .2\n                )\n                ;\n        }\n    col = tmp;\n    fragColor = vec4(col, 1.0);\n}\n\nvec2 \tcmult(vec2 a, vec2 b)\n{\n    return (vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x));\n}\n\nvec2\tcadd(vec2 a, vec2 b)\n{\n\treturn (vec2(a.x + b.x, a.y + b.y));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtffDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 129, 162, 162, 293], [295, 376, 433, 433, 1797], [1799, 1799, 1828, 1828, 1895], [1897, 1897, 1924, 1924, 1964]], "test": "untested"}
{"id": "XtffzX", "name": "Androgynous bolts", "author": "s23b", "description": "An experiment with an idea I had during a live-coding session. Mouse-enabled.", "tags": ["raymarching", "motionblur", "antialiasing", "screw", "bolt", "nut"], "likes": 59, "viewed": 3099, "published": "Public API", "date": "1513062761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// twist density\n#define SCREW 12.\n\n// animation speed\n#define SPEED 1.\n\n// field of view\n#define FOV 3.\n\n// set to 0 to disable motion blur\n#define MOTION_BLUR 1\n\n// set the antialiasing amount\n#define AA 2.\n\n#define MAX_STEPS 80\n#define SHADOW_STEPS 200\n#define SHADOW_SOFTNESS 20.\n#define EPS .0001\n#define RENDER_DIST 20.\n#define AO_SAMPLES 5.\n#define AO_RANGE 10.\n#define LIGHT_COLOR vec3(1.,.8,.6)\n\n#define PI 3.14159265359\n#define SQRT1_2 0.70710678118\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat time;\n\n// simple 3D hash function\nfloat hash(vec3 uv) {\n    float f = fract(sin(dot(uv, vec3(.09123898, .0231233, .0532234))) * 1e5);\n    return f;\n}\n\n// rotate 2d space with given angle\nvoid tRotate(inout vec2 p, float angel) {\n    vec2 s = sin(vec2(angel, angel + PI * .5));\n\tp *= mat2(s.y, -s.x, s);\n}\n\n// divide 2d space into s chunks around the center\nvoid tFan(inout vec2 p, float s) {\n    float k = s / PI / 2.;\n    tRotate(p, -floor((atan(p.y, p.x)) * k + .5) / k);\n}\n\n// union\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\n// intersection\nfloat opI(float a, float b) {\n    return max(a, b);\n}\n\n// substraction\nfloat opS(float a, float b) {\n    return max(a, -b);\n}\n\n// distance function for the androgynous bolt\nfloat bolt(vec3 p) {\n    float radius = length(p.xz) - .25;\n    \n    // basically a triangle wave spun around Oy, offset by the angle between x and z\n    float thread = (radius - abs(fract(p.y * SCREW - atan(p.z, p.x) / PI / 2.) - .5) / SCREW) * SQRT1_2;\n    \n    // clip the top and bottom\n    float screw = opS(thread, .5 - abs(p.y + .5));\n    float cone = (p.y - radius) * SQRT1_2;\n    \n    // add a diagonal clipping for more realism\n    screw = opS(screw, cone + 1. * SQRT1_2);\n    \n    // the hole is the same thing, but substracted frome the whole thing\n    float hole = opS(thread, cone + .5 * SQRT1_2);\n    hole = opU(hole, -cone - .05 * SQRT1_2);\n    \n    // create the hexagonal geometry for the head\n    tFan(p.xz, 6.);\n    float head = p.x - .5;\n    \n    // the top is also rouded down with a cone\n    head = opI(opI(head, abs(p.y + .25) - .25), (p.y + radius - .22) * SQRT1_2);\n    return opS(opU(screw,head), hole);\n}\n\n// transform for the top screw\nvoid tNextBolt(inout vec3 p) {\n    float t = mod(time, 5.);\n    const float limit = 1. / SCREW;\n    if (t < 1.) {\n        // fall\n        p.y -= smoothstep(1., 0., t) * 2. + 1. - limit;\n    } else if (t < 1.5) {\n        // hold\n        p.y -= 1. - limit;\n    } else if (t < 4.) {\n        // twist\n        float progress = smoothstep(4., 1.5, t);\n        p.y -= .5 + progress * (.5 - limit);\n        tRotate(p.xz, -progress * (SCREW / 2. - 1.) * 2. * PI);\n    } else if (t < 4.5) {\n        // hold\n        p.y -= .5;\n    } else {\n        // drop\n        p.y += .5 * smoothstep(4.5, 5., t) -.5;\n    }\n}\n\n// distance to the top bolt\nfloat nextBolt(vec3 p) {\n    tNextBolt(p);\n    return bolt(p);\n}\n\n// transform for the bottom screw\nvoid tPrevBolt(inout vec3 p) {\n    float t = mod(time, 5.);\n    p.y += .5 * smoothstep(4.5, 5., t);\n}\n\nfloat prevBolt(vec3 p) {\n    tPrevBolt(p);\n    return bolt(p);\n}\n\nfloat map(vec3 p) {\n    p.y += .25;\n\treturn opU(nextBolt(p), prevBolt(p));\n}\n\n// trace the scene from ro (origin) to rd (direction, normalized)\n// until hit or reached maxDist, outputs distance traveled and the number of steps\nfloat trace(vec3 ro, vec3 rd, float maxDist, out float steps) {\n    float total = 0.;\n    steps = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        ++steps;\n        float d = map(ro + rd * total);\n        total += d;\n        if (d < EPS || maxDist < total) break;\n    }\n    \n    return total;\n}\n\n// get the soft shadow value\nfloat softShadow(vec3 ro, vec3 rd, float maxDist) {\n    float total = 0.;\n    float s = 1.;\n    \n    for (int i = 0; i < SHADOW_STEPS; ++i) {\n        float d = map(ro + rd * total);\n        if (d < EPS) {\n            s = 0.;\n            break;\n        }\n        if (maxDist < total) break;\n        s = min(s, SHADOW_SOFTNESS * d / total);\n        total += d;\n    }\n    \n    return s;\n}\n\n// calculate the normal vector\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.005, 0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n\t));\n}\n\n// ambient occlusion\nfloat calculateAO(vec3 p, vec3 n) {\n    \n    float r = 0., w = 1., d;\n    \n    for (float i = 1.; i <= AO_SAMPLES; i++){\n        d = i / AO_SAMPLES / AO_RANGE;\n        r += w * (d - map(p + n * d));\n        w *= .5;\n    }\n    \n    return 1.-saturate(r * AO_RANGE);\n}\n\n// texture function\nvec3 _texture(vec3 p) {\n    p.y += .25;\n    if (prevBolt(p) <= nextBolt(p)) {\n        tPrevBolt(p);\n    } else {\n        tNextBolt(p);\n    }\n    p *= 1.;\n    \n    // yay, looks like we can sneakily get away with a single sample here\n    return pow(texture(iChannel0, p.xy * 2. + p.zz).rgb, vec3(2.2));\n    return vec3(1);\n}\n\nfloat bumpTexture(vec3 p) {\n    return 1. - _texture(p).g;\n}\n\n// bump mapping from Shane\nvec3 doBumpMap(vec3 p, vec3 nor, float bumpfactor) {\n    \n    vec2 e = vec2(.0001, 0);\n    float ref = bumpTexture(p);                 \n    vec3 grad = vec3(bumpTexture(p - e.xyy) - ref,\n                     bumpTexture(p - e.yxy) - ref,\n                     bumpTexture(p - e.yyx) - ref) / e.x;\n             \n    grad -= nor * dot(nor, grad);          \n                      \n    return normalize(nor + grad * bumpfactor);\n\t\n}\n\nvec4 frame(vec2 fragCoord) {\n    vec4 fragColor = vec4(0);\n    \n    // set up global time variable\n    time = iTime * SPEED;\n    \n    // add hash value to create the motion blur effect\n    #if MOTION_BLUR\n    time = time + hash(vec3(fragCoord, time)) / iFrameRate * SPEED;\n    #endif\n    \n    // transform screen coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // transform mouse coordinates\n\tvec2 mouse = iMouse.xy / iResolution.xy * 2. - 1.;\n    mouse.x *= iResolution.x / iResolution.y * 4.;\n    \n    // we are sneaky af, we can't let anyone know, that there's only two bolts the entire time ;)\n    mouse.y = clamp(mouse.y, -.3, .5);\n    \n    // set up camera position\n    vec3 ro =  vec3(0, 0, -2);\n    vec3 rd = normalize(vec3(uv, FOV));\n    \n    // light position\n    vec3 light = vec3(-.4, .3, -1.);\n    \n    vec2 rot = vec2(0);\n    if (iMouse.z > 0.) {\n    \t// rotate the scene using the mouse\n        rot = -mouse;\n    } else {\n        // set a nice angle as default\n        rot = vec2(.6, .05);\n    }\n    \n    tRotate(rd.yz, rot.y);\n    tRotate(rd.xz, rot.x);\n    tRotate(ro.yz, rot.y);\n    tRotate(ro.xz, rot.x);\n    \n    // march\n    float steps, dist = trace(ro, rd, RENDER_DIST, steps); \n    \n    // calculate hit point coordinates\n    vec3 p = ro + rd * dist;\n    \n    // calculate normal\n    vec3 normal = getNormal(p);\n    normal = doBumpMap( p, normal, .005);\n    \n    // light direction\n    vec3 l = normalize(light - p);\n    \n    // calculate shadow\n    vec3 shadowStart = p + normal * EPS * 10.;\n    float shadowDistance = distance(shadowStart,light);\n    float shadow = softShadow(shadowStart, l, shadowDistance);\n    \n    // ambient light\n    float ambient = .02;\n    \n    // diffuse light\n    float diffuse = max(0., dot(l, normal) * 2.);\n    \n    // specular light\n    float specular = pow(max(0., dot(reflect(-l, normal), -rd)), 4.);\n    \n    // \"ambient occlusion\"\n    float ao = calculateAO(p, normal) * .5 + .5;\n    \n    // add this all up\n\tfragColor.rgb = (ao * _texture(p)) * (ambient * (2. - LIGHT_COLOR) * .5 + (specular + diffuse) * shadow * LIGHT_COLOR);\n    \n    // fog\n    vec4 fogColor = vec4(mix(vec3(.0, .025, .05), LIGHT_COLOR * 2., pow(max(0., dot(normalize(light), rd)), 10.)), 1);\n    fragColor = mix(fragColor, fogColor, saturate(dist * dist * .01 - .1));\n    \n    // if we passed the bolts, then apply a dark glow, this makes the bolts pop out\n    if (length(p) > 1.) \n        fragColor *= saturate(1. - sqrt(steps / float(MAX_STEPS)));\n    \n    // add some vignetting\n    fragColor *= smoothstep(2., 0., length(uv));\n    \n    return fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0);\n    float increment = 1. / AA;\n    for (float i = 0.; i < 1.; i += increment) {\n        for (float j = 0.; j < 1.; j += increment) {\n            fragColor += frame(fragCoord + vec2(i,j));\n        }\n    }\n    \n    // divide with subpixel count and apply gamma correction\n    fragColor = pow(fragColor / AA / AA, vec4(1. / 2.2));\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtffzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[511, 538, 559, 559, 653], [655, 691, 732, 732, 808], [810, 861, 895, 895, 979], [981, 990, 1019, 1019, 1043], [1045, 1061, 1090, 1090, 1114], [1116, 1132, 1161, 1161, 1186], [1188, 1234, 1254, 1254, 2166], [2168, 2199, 2229, 2229, 2799], [2801, 2829, 2853, 2853, 2893], [2895, 2929, 2959, 2959, 3030], [3032, 3032, 3056, 3056, 3096], [3098, 3098, 3117, 3117, 3174], [3176, 3325, 3388, 3388, 3628], [3630, 3659, 3710, 3710, 4044], [4046, 4077, 4101, 4101, 4285], [4287, 4308, 4343, 4343, 4574], [4576, 4596, 4619, 4619, 4919], [4921, 4921, 4948, 4948, 4981], [4983, 5010, 5062, 5062, 5437], [5439, 5439, 5467, 5467, 8099], [8101, 8101, 8156, 8156, 8511]], "test": "untested"}
{"id": "XtjBzR", "name": "Animated circle 360 divide", "author": "piotrekb89", "description": "Inspired by https://twitter.com/inversed_ru/status/945306500980989952 ; Currently I not use Highly composite number , just simple n+1", "tags": ["animation", "divide"], "likes": 4, "viewed": 129, "published": "Public", "date": "1514304744", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//after refactor by FabriceNeyret2\n\n#define PI 3.14159\n#define LEVELS 15.\n#define SPEED .5\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - .5* iResolution.xy ) / iResolution.y *2.5;\n    \n    float magnitude_division = LEVELS,\n         angle_division = 1.,\n                  value = 1.,\n              magnitude = length(uv),\n     this_magnitude_division = floor(magnitude * magnitude_division),\n         magnitude_part = fract(magnitude * magnitude_division);\n    \n    if (this_magnitude_division < 1.)\n    {\n        fragColor = vec4(1);\n        return;\n    }\n       \n    angle_division += this_magnitude_division;  \n    value = this_magnitude_division / magnitude_division;\n    if ( value > 1.)    value = 0.; \n    else     \n    {\n      if (magnitude_part > .1)\n          if (magnitude_part < .9) value = 1.; \n          else          value = 1. - (magnitude_part - .9) / .1;           \n      else              value = magnitude_part / .1; \n    }\n\n\n    float    angle = (atan(uv.x,uv.y) + PI) / (2.*PI),\n     polar_divider = abs(sin(angle * PI * angle_division + iTime * SPEED)),\n     divider_thick =  .05 / LEVELS * angle_division / magnitude;  \n     polar_divider = min( 1., polar_divider / divider_thick );   \n    \n\tfragColor = vec4( 1.- value * polar_divider );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjBzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 92, 146, 146, 1302]], "test": "untested"}
{"id": "XtjfRR", "name": "try for shadow", "author": "cailuming", "description": "try a shadow,but the problems are that I can not make a soft shadow and the shadow is not smooth", "tags": ["shadow"], "likes": 2, "viewed": 134, "published": "Public", "date": "1514477523", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FAR 128.\n#define PI 3.1415926\nstruct Ray{\n   vec3 o;\n   vec3 d;\n};\n\nmat3 rotY(float a){\n  float s =sin(a);\n  float c=cos(a);\n  \n  return mat3(\n     c,0,-s,\n     0,1,0,\n     s,0,c\n  );\n}\n\nmat3 rotX(float a){\n  float s =sin(a);\n  float c=cos(a);\n  \n  return mat3(\n     1,0,0,\n     0,c,-s,\n     0,s,c\n  );\n}\n\n\nfloat obj1(vec3 pr,vec3 c){\n    vec3 p=pr-c;\n    p.xz=mod(p.xz,4.);\n    p.xz-=2.;\n    \n    return length(p)-0.4;\n}\n\nfloat obj2(vec3 pr,vec3 c){\n    vec3 p=pr-c;\n  \n    float arc = atan(p.y,p.x);\n    vec3 polor =vec3(cos(arc),sin(arc),5);\n    return length(p-polor)-0.5;\n}   \n\nfloat obj3(vec3 pr,vec3 c){\n    vec3 p=pr-c;\n    p=abs(p);\n    return (p.y+p.x+p.z-2.)/sqrt(3.0);\n}   \n\n\nfloat plane(vec3 p,vec3 c){\n    p-=c;\n   \n    vec3 polor =vec3(p.x,-3.,p.z);\n\n    return length(p-polor);\n}\n\nfloat fog(vec3 p,vec3 c){\n   float dis =length(p-c);\n    dis*=0.040;\n    //dis*=dis;\n   return dis; \n}\n\nvoid drawBg(vec3 p,out vec3 col){\n    p-=vec3(0,24.,0);\n    float arc=atan(p.y,p.x);\n    float v =3./length(p.xy);\n    v=pow(v,2.);\n    \n    float v1=abs(sin(4.*arc+iTime));\n    v1=pow(v1,20.);\n    \n    v+=0.1*v1;\n    col=vec3(0.8,0.8,1.);\n    col=mix(vec3(v),col,0.5);\n}\n\n\nfloat map(vec3 p){\n   float ref=1.;\n    \n   float temp =obj1(p,vec3(0,-2.1,-9));\n     \n   if(ref>temp){\n       ref=temp;\n   }\n   \n   temp =obj2(p,vec3(1,sin(iTime),-8));\n     \n   if(ref>temp){\n       ref=temp;\n   }\n    \n   temp =obj3(p,vec3(-2,sin(iTime),1-1));\n     \n   if(ref>temp){\n       ref=temp;\n   }\n    \n  \n   temp =plane(p,vec3(0,0,0));\n   \n   if(ref>temp){\n        ref=temp;    \n   }\n       \n   return ref;\n}\n\n// compute normal from gradient vector\nvec3 getNormal(vec3 p){\n   \n\tvec2 d = vec2(0.0,0.001);\n    float mc = map(p);\n    return -normalize(vec3(\n        mc-map(p+d.yxx),\n        mc-map(p+d.xyx),\n        mc-map(p+d.xxy)\n    ));\n \n}\n\nfloat getShadowFrac(vec3 lo,vec3 ld,float maxt){\n   \n    float res=1.;\n    float t =0.1;\n    float lds=0.;\n    \n    for(float i=0.;i<64.;i++){\n        // trace forward\n       lds =map(lo+t*ld);\n       \n       res=min(lds*128./t,res);\n       \n       t+=clamp(lds,0.0001,0.4);\n        \n       if(t>=maxt||t<0.0001){\n          break;\n       }\n        \n    }\n    return res;\n}\n\nvec3 rayHit(Ray ray,vec3 lightPos){\n    float t=1.;\n   \n    float nl =0.;\n       \n    vec3 p=vec3(0);\n    vec3 l2p =vec3(0);\n    \n    float lp=0.;\n    float isHit=0.;\n    float hit =0.;\n    \n    for(float i=0.;i<FAR;i++){\n       p=ray.o+t*ray.d;\n       \n       hit =map(p);\n       \n       l2p= p-lightPos;\n       if(hit<=0.006){\n           \n           nl =clamp(dot(normalize(lightPos),getNormal(p)),0.2,1.);\n           lp=getShadowFrac(lightPos,normalize(l2p),length(l2p)-0.3);\n           nl*=lp;\n      \n           nl+=pow(abs(nl),20.); \n           isHit=1.;    \n           break;\n       }\n        \n       if(t>=20.){\n         \n          break;\n       }\n       t+=hit;\n    }\n    \n   \n    return vec3(nl,t/12.,isHit);\n}\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-vec2(0.5);\n    float as = iResolution.x/iResolution.y;\n     \n    vec3 eye =vec3(0,0,-15);\n    vec3 screen =vec3(uv.x*as,uv.y,-14);\n    vec3 col =vec3(0);\n    vec3 lightPos =vec3(10.*cos(iTime),14.,10.*sin(iTime));\n    \n    Ray ray; \n    ray.o= eye;\n    ray.d =normalize(screen-ray.o);\n    ray.o*=rotX(PI*0.02);\n    ray.d*=rotX(PI*0.02);\n   \n    ray.d*=rotY(PI*0.1*sin(iTime*0.2));\n    \n    \n    vec3 eyeHit= rayHit(ray,lightPos);\n    if(eyeHit.z<=0.){\n       drawBg(ray.o+ray.d*80.,col);\n    }\n    \n   \n    col  +=vec3(eyeHit.x);\n    col= mix(col,vec3(0.4,0.8,1)*eyeHit.y,0.5);\n    \n    fragColor = vec4(col,1.0);\n       \n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjfRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 95, 95, 193], [195, 195, 214, 214, 312], [315, 315, 342, 342, 429], [431, 431, 458, 458, 586], [591, 591, 618, 618, 690], [696, 696, 723, 723, 803], [805, 805, 830, 830, 907], [909, 909, 942, 942, 1180], [1183, 1183, 1201, 1201, 1601], [1603, 1642, 1665, 1665, 1833], [1835, 1835, 1883, 1883, 2207], [2209, 2209, 2244, 2244, 2928], [2935, 2935, 2992, 2992, 3657]], "test": "untested"}
{"id": "XtlBzS", "name": "Digital waterfall", "author": "kobilica", "description": "Playing around with noise functions and pixels. ", "tags": ["noise", "square", "digital", "8bit"], "likes": 5, "viewed": 292, "published": "Public", "date": "1512308607", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat random(in float x){\n    return fract(sin(x)*43758.5453);\n}\n\nfloat random(in vec2 st){\n    return fract(sin(dot(st.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat randomColor(in vec2 st) {\n \n    return fract(random(st.x + st.y*st.x + st.y) - st.y + st.x);\n}\n\nvec3 matrix(in vec2 st) {\n    \n    float rows = 128.0;\n    \n    //integer positions\n    vec2 ipos = floor(st * rows);\n    \n    //this is where dancing happens, I am just shifting rows and columns of matrix. Looks very nice.\n    //also when I say shifting, it's not really shifting, since there is sin function in it. It's shifting only on some places. \n    ipos.y += floor(2.5*iTime + 1.5*sin(random(ipos.x)*iTime)*random(ipos.y));\n    \n    return vec3(randomColor(ipos));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //normalizing\n\tvec2 st = fragCoord.xy / iResolution.x;\n    \n\tfragColor = vec4(vec3(matrix(st)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtlBzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 26, 26, 65], [67, 67, 92, 92, 164], [166, 166, 197, 197, 266], [268, 268, 293, 293, 742], [744, 744, 801, 819, 909]], "test": "untested"}
{"id": "XtlfRB", "name": "Neutron Box", "author": "shau", "description": "A quick one using a mask for volumetric shadows", "tags": ["3d"], "likes": 27, "viewed": 431, "published": "Public", "date": "1513173819", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define T iTime * 0.4\n#define EPS 0.005\n#define FAR 20.0 \n#define PI 3.14159265359\n\n//compact 2 axis rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n\n//wireframe edges\nfloat tex(vec3 rp) {\n    float tx = clamp(step(0.8, abs(rp.x)) + step(0.8, abs(rp.y)), 0.0, 1.0);\n    tx *= step(0.1, abs(rp.x)) * step(0.1, abs(rp.y));\n    return tx;\n}        \n\n// Cube mapping routine from Fizzer\n// I'm not sure where I got this from\nfloat fizz(vec3 rp) {\n    vec3 f = abs(rp);\n    f = step(f.zxy, f) * step(f.yzx, f); \n    f.xy = f.x > .5 ? rp.yz / rp.x : f.y > .5 ? rp.xz / rp.y : rp.xy / rp.z; \n    return tex(f);\n}\n\n//IQ - Box and Sphere functions\nvec2 boxIntersection(vec3 ro, vec3 rd, vec3 boxSize) {\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if(tN > tF || tF < 0.0) return vec2(-1.0); // no intersection\n    //vec3 outNormal = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    float fzN = fizz(ro + rd * tN); //wireframe near face\n    return vec2(tN, fzN);\n}\n\nfloat sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    return -b - h;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float s) {\n  return length(p) - s + noise((p * 5.) + T) * 0.1;\n}\n\nfloat map(vec3 rp) {\n\n    float sphere = sdSphere(rp, 1.2);    \n    \n    rp = abs(rp);\n    float ns = sdBox(rp - vec3(2.0, 2.0, 1.2), vec3(0.2, 0.2, 1.0));\n    ns = min(ns, sdBox(rp - vec3(1.2, 2.0, 2.0), vec3(1.0, 0.2, 0.2)));\n    ns = min(ns, sdBox(rp - vec3(2.0, 1.2, 2.0), vec3(0.2, 1.0, 0.2)));\n             \n    return min(sphere, ns);\n}\n\nfloat march(vec3 ro, vec3 rd, float maxStep, float ls, float la) {\n \n    float t = 0.0;\n    float li = 0.0;\n    \n    for (int i = 0; i < 24; i++) {\n        vec3 rp = ro + rd * t;\n        float ns = map(rp);\n        if (ns < EPS || t > FAR) break;\n        \n        vec2 box = boxIntersection(rp, normalize(-rp), vec3(2.2));\n        float ld = sdSphere(rp, 1.2);\n        float fli = 1.0 * ls / (1.0 + ld * ld * la);\n        if (box.x > 0.0 && box.x < ld) {\n            fli *= (1.0 - box.y);\n        }\n        \n        li += fli;\n        \n        t += min(ns, maxStep);\n    }\n    \n    return li;\n}\n\nvoid setupCamera(vec2 uv, inout vec3 ro, inout vec3 rd) {\n\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    ro = lookAt + vec3(3.0, 1.0, -6.0);\n    \n    ro.xz *= rot(T);\n    ro.yz *= rot(T * 0.3);\n\n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec3 pc = vec3(0.0);\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    \n    vec3 ro, rd;\n    setupCamera(uv, ro, rd);\n    \n    pc = vec3(0.0, 1.0, 0.0) * march(ro, rd, 4.0, 0.03, 0.05);\n    \n    fragColor = vec4(pc, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtlfRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 110, 129, 129, 175], [177, 189, 211, 211, 519], [521, 539, 559, 559, 708], [718, 792, 813, 813, 976], [978, 1010, 1064, 1064, 1501], [1503, 1503, 1551, 1551, 1742], [1744, 1744, 1773, 1773, 1864], [1866, 1866, 1899, 1899, 1953], [1955, 1955, 1975, 1975, 2298], [2300, 2300, 2366, 2366, 2894], [2896, 2896, 2953, 2953, 3327], [3329, 3329, 3384, 3384, 3645]], "test": "untested"}
{"id": "XtlfWs", "name": "party grid 3d", "author": "mattz", "description": "Alternates between grid and party! Probably nothing new -- traverse a uniform 3D grid while analytically raytracing objects in grid cells. Practicing to make a better shader later on.", "tags": ["3d", "grid", "raytrace", "march"], "likes": 20, "viewed": 691, "published": "Public API", "date": "1514068720", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* party grid 3d, by mattz. \n   License Creative Commons Attribution 3.0 (CC BY 3.0) Unported License.\n\n   Mouse rotates (or click in bottom left for auto-rotate).\n\n*/\n\n\nconst float farval = 10000.0;\nconst vec4 miss = vec4(vec3(0.0), farval);\nconst float rad = 0.25;\n\n#define INT_FORLOOPS\n\nconst float nbox = 7.0;\n\n#ifdef INT_FORLOOPS\n#define LOOPTYPE int\n#define LOOP0 0\nconst int rsteps = 3*int(nbox);\n#else\n#define LOOPTYPE float\n#define LOOP0 0.\nconst float rsteps = 3.*nbox;\n#endif\n\nconst float linewidth = 0.04;\nconst float kfog = -1.2/nbox;\n\nvec3 L = normalize(vec3(-0.7, 1.0, -1.0));\nmat3 Rview;\n\n// Dave Hoskins' hash without sine https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// RGB from hue\nvec3 hue(float h) {\n    vec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n    return h >= 1.0 ? vec3(h-1.0) : clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\n// rotate about x-axis \nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n\n// rotate about y-axis \nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n// ray-sphere intersection\nvec4 sphere(in vec3 o, in vec3 d, in vec3 ctr, in float r) {\n\t\n    vec3 oc = o - ctr;\n    \n    float a = dot(d, d);\n    float b = 2.0*dot(oc, d);\n    float c = dot(oc, oc) - r*r;\n        \n    float D = b*b - 4.0*a*c;\n    \n    if (D > 0.0) {\n        \n        float sqrtD = sqrt(D);\n        \n        float t = 0.5 * ( -b - sqrtD ) / a;\n        \n        if (t >= 0.0) {\n            vec3 n = normalize( oc + t*d );\n            return vec4(n, t);\t\n        }\n        \n    }\n    \n    return miss;\n\t\t\n}\n\n// minimum of vector\nfloat min3(vec3 a) {\n\treturn min(a.x, min(a.y, a.z));\n}\n\n// max of vector\nfloat max3(vec3 a) {\n\treturn max(a.x, max(a.y, a.z));\n}\n\n// median of vector\nfloat median3(vec3 x) {\n    return dot(x, vec3(1)) - min3(x) - max3(x);\n}\n\n// ray-box intersection\nfloat box(vec3 ro, vec3 rd, vec3 b) {\n\t\n\tvec3 rdi = 1.0/rd;\t\n\t\t\n\tvec3 t1 = (-b - ro)*rdi;\n\tvec3 t2 = ( b - ro)*rdi;\n\t\n\tvec3 tmin = min(t1, t2);\n\tvec3 tmax = max(t1, t2);\n    \n    float ta = max3(tmin);\n    float tb = min3(tmax);\n\t\n\tif (ta <= tb) {\n\t\treturn ta;\n\t} else {\n\t\treturn farval;\n\t}\n\n}\n\n// select whichever basis edge minimizes time to hit\nvec3 bselect(vec3 k, vec3 d, vec3 b1, vec3 b2) {\n\treturn (abs(dot(k,b1)*dot(d,b2)) < abs(dot(k,b2)*dot(d,b1))) ? b1 : b2;\n}\n\n// for stepping through cube lattice\nfloat stepcube(in vec3 p, in vec3 d) {\n\t\n\t// g is half-integer coords from p in the direction of d\n\tvec3 g = floor(p+vec3(0.5))-vec3(0.5) + step(vec3(0.0), d);\n\n\t// k is the vector from p to the corner in direction d\n\tvec3 k = g-p;\n\t\n\t// select the basis vector representing the first to intersect\t\n\tvec3 b = bselect(k, d, \n\t\t\t\t\t bselect(k, d, vec3(1.0, 0.0, 0.0), \n\t\t\t\t\t \t\t\t   vec3(0.0, 1.0, 0.0)), \n\t\t\t\t\t\t           vec3(0.0, 0.0, 1.0));\n\t\n\t// compute the distance along the ray to the nearest cube edge\n\treturn dot(k,b) / dot(d, b);\n\t\n}\n\n// point in box?\nbool inbox(vec3 c, float tol) {\n    float cmin = min(c.x, min(c.y, c.z));\n    float cmax = max(c.x, max(c.y, c.z));\n    return cmin >= -tol && cmax < nbox + tol;\n}\n\n// fog blocking\nfloat fog(vec3 x) {\n    float l = length(x);\n    l = max(0.0, l-nbox);\n    return exp(kfog*l);\n}\n\n// ray trace\nvec3 shade(in vec3 ro, in vec3 rd) {\n    \n    // raytrace against bounding box\n    float curw = box(ro, rd, 0.5*vec3(nbox+linewidth));\n    if (curw == farval) {\n        return vec3(0);\n    }\n    \n    const float t_trans = 2.0;\n    const float t_phase = 5.0;\n    \n    float mtime = mod(iTime+t_trans, 2.0*t_phase);\n    float xtime = mod(mtime, t_phase);\n\n    float party = smoothstep(0.0, t_trans, xtime);\n    if (mtime < t_phase) {\n        party = 1.0 - party;\n    }\n        \n\t// added to cube step\n\tconst float eps = 0.001;\n\t\n    // center box grid\n    ro += 0.5*nbox - 0.5;\n    \n    // pixel color\n\tvec3 color = vec3(0.0);\n    \n    // grid coverage\n    float grid = 0.0;\n    \n    // pixel ray distance\n    float rw = farval;\n\n    // march along ray thru grid\n\tfor (LOOPTYPE i=LOOPTYPE(0); i<rsteps; ++i) {\n        \n        // point in grid\n        vec3 p = ro + curw * rd;\n\n        // check if point inside box for grid rendering\n        if (inbox(p+0.5, 0.5*linewidth)) {\n            \n            // xyz displacement from center of cell\n            vec3 dctr = p - floor(p + 0.5);\n\n            // xyz displacement from face\n            vec3 dface = abs(0.5 - abs(dctr));\n\n            // get median coordinate of face displacement\n            float emid = median3(dface);\n\n\t\t\t// grid line\n            float gbrt = smoothstep(linewidth, 0.0, emid) * fog(p-ro);\n\t\t\tgrid = max(grid, (1.0-party)*gbrt);\n\n        }\n\n        // base cell \n        vec3 cbase = floor(p);\n\n        // for each neighbor in 2x2x2 neighborhood\n        for (LOOPTYPE j=LOOPTYPE(0); j<LOOPTYPE(8); ++j) {\n\n#ifdef INT_FORLOOPS\n            vec3 joffs = vec3(ivec3(j/4, (j%4)/2, j%2));\n#else\n            // offset to neighbor\n            vec3 joffs = vec3(floor(j/4.0), floor(mod(j, 4.0)/2.0), mod(j, 2.0));\n#endif\n\n            // center of cell\n            vec3 ctr = cbase + joffs;\n\n            // if center in box\n            if (inbox(ctr, 0.0)) {\n\n                // raytrace to sphere in cell\n                \n                vec3 h1 = hash33(ctr);\n                vec3 r = 0.5*party*0.5*cos((h1+0.05)*4.0*iTime + 2.0);\n\n                float srad = mix(0.1, rad * (0.5 + h1.z), party);\n                \n                vec4 s = sphere(ro, rd, ctr + r, srad);\n                \n                // if in front of current hit\n                if (s.w < rw) {\n                    \n                    vec3 c = 0.5*hue(h1.x) + 0.5;\n                    \n                    vec3 n = s.xyz;\n                    \n                    vec3 diffamb = (0.5*clamp(dot(n,L), 0.0, 1.0)+0.5) * c;\n                    vec3 R = 2.0*n*dot(n,L)-L;\n                    \n                    float spec = 0.3*pow(clamp(-dot(R, rd), 0.0, 1.0), 20.0);\n                    \n                    color = diffamb + spec;\n                    color *= fog(s.w*rd);\n                    \n                    rw = s.w;\n                    \n                }\n\n            } // center in box\n\n        } // for each neighbor\n        \n        curw += stepcube(p, rd) + eps;\n        \n\t} // for each step along ray\n\t\n    // mix sphere color and grid color\n\treturn max(color, vec3(grid));\n\t\n}\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) * 0.8 / (iResolution.y);\n   \n    const vec3 tgt = vec3(0.0, 0.0, 0.0);\n    const vec3 cpos = vec3(0.0, 0.0, 1.8*nbox);\n    const vec3 up = vec3(0, 1, 0);\n\n    vec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,vec3(0,1.,0))),\n        ry = cross(rx,rz);\n\n    float thetay = 0.1235*iTime;\n    float thetax = 0.75 * smoothstep(0.0, 5.0, iTime);\n\n    if (max(iMouse.x, iMouse.y) > 20.0) { \n        thetax = (iMouse.y - .5*iResolution.y) * -5.0/iResolution.y; \n        thetay = (iMouse.x - .5*iResolution.x) * 10.0/iResolution.x; \n    }\n\n    Rview = mat3(rx,ry,rz)*rotY(thetay)*rotX(thetax); \n    L = Rview*L;\n\n    vec3 rd = Rview*normalize(vec3(uv, 1.)),\n        ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n\n    fragColor.xyz = shade(ro, rd);\n\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtlfWs.jpg", "access": "shaders20k", "license": "cc-by-3.0 AND mit", "functions": [[605, 724, 746, 746, 856], [858, 874, 893, 893, 1010], [1012, 1036, 1059, 1059, 1180], [1183, 1207, 1230, 1230, 1351], [1353, 1380, 1440, 1440, 1874], [1876, 1897, 1917, 1917, 1952], [1954, 1971, 1991, 1991, 2026], [2028, 2048, 2071, 2071, 2121], [2123, 2147, 2184, 2184, 2440], [2442, 2495, 2543, 2543, 2618], [2620, 2657, 2695, 2755, 3196], [3198, 3215, 3246, 3246, 3378], [3380, 3396, 3415, 3415, 3492], [3494, 3507, 3543, 3585, 6632], [6635, 6635, 6692, 6692, 7502]], "test": "untested"}
{"id": "Xtlfz2", "name": "Endrass Surface", "author": "mla", "description": "The Endrass algebraic surface (and others in the code) using a simple zero finder that advances carefully along the ray until a sign change, then uses bisection. Mouse for orientation.\n\nSome functions from Abdelaziz Nait Merzouk's Fragmentarium shaders.", "tags": ["surface", "algebraic", "zerofinder", "endrass"], "likes": 14, "viewed": 931, "published": "Public API", "date": "1512600514", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define FAST\n#define QUALITY\n\n//#define MIRROR\n    \nbool doGamma = true;\nbool doSpecular = true;\nbool doDiffuse = true;\nconst float ambient = 0.5;\nconst float diffuse = 0.5;\nfloat specularPower = 4.0;\n\n\nconst vec3 defaultColor = vec3(0.7,1.0,1.0);\n\nconst float PI =  3.141592654;\nconst float TWOPI = 2.0*PI;\nconst float two31 = 2147483648.0;\nconst float phi = 1.618033;\nconst float phi2 = phi*phi;\nconst float phi4 = phi2*phi2;\n\n\nvec3 light;\nmat3 iMatrix;\n\n// Quaternion multiplication as a matrix.\n// w coordinate is real element of quaternion\nmat4 qmat(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, t = q.w;\n  return mat4( t,-z, y, x, \n               z, t,-x, y,\n              -y, x, t, z,\n              -x,-y,-z, t );\n}\n\nfloat Sphere(vec4 p) {\n  vec4 a = vec4(1.0,1.0,1.0,-2.0);\n  return dot(a*p,p);\n}\n\nfloat T6(float x) {\n   return -1.0+x*x*(18.0+x*x*(-48.0+x*x*32.0));\n}\n\nfloat Chmutov6(vec4 p) {\n  p *= 0.5;\n  float x = p.x; float y = p.y;\n  float z = p.z; float w = p.w;\n  return T6(x)+T6(y)+T6(z)+1.0;\n}\n\n// The following functions for various surfaces are\n// taken from Abdelaziz Nait Merzouk's Fragmentarium\n// shaders.\n// https://plus.google.com/114982179961753756261\n\nfloat Labs(vec4 p) {\n  float x = p.x;\n  float y = p.y;\n  float z = p.z;\n  float w = p.w;\n  // float a = -0.140106854987125;//the real root of 7*a^3+7*a+1=0\n  // Constants\n  float a1= -0.0785282014969835;//(-12./7.*a-384./49.)*a-8./7.;\n  float a2= -4.1583605922880200;//(-32./7.*a+24./49.)*a-4.; \n  float a3= -4.1471434889655100;//(-4.*a+24./49.)*a-4.;\n  float a4= -1.1881659380714800;//(-8./7.*a+8./49.)*a-8./7.; \n  float a5= 51.9426145948147000;//(49.*a-7.)*a+50.;\n  float x2 = x*x,y2 = y*y,z2 = z*z,w2 = w*w;\n  float r2= x2+y2;\n  float U = (z+w)*r2+(a1*z+a2*w)*z2+(a3*z+a4*w)*w2;\n  U = (z+a5*w)*U*U;\n  float P = x*((x2-3.0*7.0*y2)*x2*x2+(5.0*7.0*x2-7.0*y2)*y2*y2);\n  P += z*(7.0*(((r2-8.0*z2)*r2+16.0*z2*z2)*r2)-64.0*z2*z2*z2);\n  return U-P;\n}\n\nfloat Endrass8(vec4 p){\n  float x = p.x;\n  float y = p.y;\n  float z = p.z;\n  float w = p.w;\n  float x2 = x*x,y2 = y*y,z2 = z*z,w2 = w*w;\n  float r2 = x2+y2;\n  float U = 64.0*(x2-w2)*(y2-w2)*((x+y)*(x+y)-2.0*w2)*((x-y)*(x-y)-2.0*w2);\n  float V = -4.0*(1.0+sqrt(2.0))*r2*r2+(8.0*(2.0+sqrt(2.0))*z2+2.0*(2.0+7.0*sqrt(2.0))*w2)*r2;\n  V = V + z2*(-16.0*z2+8.0*(1.0-2.0*sqrt(2.0))*w2) - (1.0+12.0*sqrt(2.0))*w2*w2;\n  return V*V-U;\n}\n\nfloat Barth10(vec4 p){//decic\n  float r2 = dot(p.xyz,p.xyz);\n  vec4 p2 = p*p;\n  float r4 = dot(p2.xyz,p2.xyz);\n  vec4 p4 = p2*p2;\n  return (8.0*(p2.x-phi4*p2.y)*(p2.y-phi4*p2.z)*(p2.z-phi4*p2.x)*(r4-2.0*((p.x*p.y)*(p.x*p.y)+(p.x*p.z)*(p.x*p.z)+(p.y*p.z)*(p.y*p.z)))+(3.0+5.0*phi)*(r2-p2.w)*(r2-p2.w)*(r2-(2.0-phi)*p2.w)*(r2-(2.0-phi)*p2.w)*p2.w);\n}\n\n//   Dodecics\nfloat Sarti12(vec4 p){\n  vec4 p2 = p*p;\n  vec4 p4 = p2*p2;\n  float l1 = dot(p2,p2);\n  float l2 = p2.x*p2.y+p2.z*p2.w;\n  float l3 = p2.x*p2.z+p2.y*p2.w;\n  float l4 = p2.y*p2.z+p2.x*p2.w;\n  float l5 = p.x*p.y*p.z*p.w;\n  float s10 = l1*(l2*l3+l2*l4+l3*l4), s11 = l1*l1*(l2+l3+l4);\n  float s12=l1*(l2*l2+l3*l3+l4*l4),    s51=l5*l5*(l2+l3+l4),  s234=l2*l2*l2+l3*l3*l3+l4*l4*l4;\n  float s23p=l2*(l2+l3)*l3,   s23m=l2*(l2-l3)*l3; \n  float s34p=l3*(l3+l4)*l4,       s34m=l3*(l3-l4)*l4; \n  float s42p=l4*(l4+l2)*l2,       s42m=l4*(l4-l2)*l2;\n  float Q12=dot(p,p); Q12=Q12*Q12*Q12; Q12=Q12*Q12; \n  float S12=33.*sqrt(5.)*(s23m+s34m+s42m)+19.*(s23p+s34p+s42p)+10.*s234-14.*s10+2.*s11-6.*s12-352.*s51+336.*l5*l5*l1+48.*l2*l3*l4;\n  return 22.*Q12-243.*S12;\n}\n\nfloat Kummer(vec4 P) {\n  float A = sqrt(2.0);\n  float mu2 = 0.334 + 3.0*(1.0-cos(0.2*iTime));\n  float x = P.x; float y = P.y;\n  float z = P.z; float w = P.w;\n  float p = w-z-A*x;\n  float q = w-z+A*x;\n  float r = w+z+A*y;\n  float s = w+z-A*y;\n  float lambda = (3.0*mu2-1.0)/(3.0-mu2);\n  float k = x*x + y*y + z*z - mu2*w*w;\n  return k*k-lambda*p*q*r*s;\n}\n\nvec4 transform(vec4 p) {\n  float k = 0.1*iTime;\n  mat4 m = qmat(vec4(0.0,0.0,sin(k),cos(k)));\n  p = m*p;\n  return p;\n}\n\nfloat Fun(vec4 p) {\n  p = transform(p);\n  //return Sphere(p);\n  //return Labs(p);\n  return Endrass8(p);\n  //return Barth10(p);\n  //return Sarti12(p);\n  //return Chmutov6(p);\n  //return Kummer(p);\n}\n\nvec3 selectColor(vec4 q, vec3 eye, vec3 n) {\n#if !defined MIRROR\n  return defaultColor;\n#else\n  // The ShaderToy cubemaps are quite high contrast, which\n  // tends to emphasise edge artefacts, so mute a little.\n  vec3 color = texture(iChannel0,reflect(eye,n)*iMatrix).rgb;\n  return min(vec3(0.75),sqrt(color));\n#endif\n}\n\n// Solution parameters.\n#if defined FAST\nconst int iterations = 100;    // Maximum number of iterations\nconst float maxincrease = 1.1; // Largest allowed step increase.\n#elif defined QUALITY\nconst int iterations = 300;    // Maximum number of iterations\nconst float maxincrease = 1.03; // Largest allowed step increase.\n#else\nconst int iterations = 150;    // Maximum number of iterations\nconst float maxincrease = 1.06; // Largest allowed step increase.\n#endif\n\nconst float maxstep = 1.0;     // The largest step that can be taken.\nconst float minstep = 0.001;  // The smallest step\nconst float initstep = 0.1;\n\nvoid solve(out vec4 fragColor, vec4 p0, vec4 r) {\n  float k0 = 0.0, k1;\n  float a0 = Fun(p0), a1;\n  bool bracketed = false;\n  bool found = false;\n  float step = initstep;\n  vec4 p;\n  float expected = 0.0;\n  for (int i = 0; i < iterations; i++) {\n    if (bracketed) {\n      // Once we are bracketed, just use bisection\n      if (k1-k0 < minstep) {\n        found = true;\n        break;\n      }\n      float k2 = (k0 + k1)/2.0;\n      //x = x0+k2*a, y = y0+k2*b, z = z0+k2*c, w = 1.0;\n      p = p0+k2*r;\n      float a2 = Fun(p);\n      if (a0*a2 <= 0.0) {\n        k1 = k2; a1 = a2;\n      } else {\n        k0 = k2; a0 = a2;\n      }\n    } else {\n      k1 = k0 + step;\n      p = p0 + k1*r;\n      a1 = Fun(p);\n      //The idea here is to try and correct the\n      // step size by seeing how close we are to\n      // the curve, but it doesn't seem to work\n      // very well.\n      float q = abs((a1-expected)/(a1+expected));\n      if (false && expected != 0.0 && q > 0.25) {\n        step *= 0.5;\n        expected = a0 + 0.5*(expected - a0);\n      } else if (a0*a1 <= 0.0) {\n        // We can hit exactly 0 - this counts as bracketed.\n        bracketed = true;\n      } else {\n        float step0 = step;\n        step = a1*step/(a0-a1);\n        step = abs(step);\n        step = min(step,maxstep);\n        // Don't grow step by more than a certain amount\n        // A better strategy should be possible\n        // Detect overstepping & retreat maybe.\n        step = max(step,minstep);\n        step = min(step,maxincrease*step0);\n        if (a1 <= a0) expected = 0.0;\n        else expected = a1 + step*(a1-a0)/(k1-k0);\n        k0 = k1; a0 = a1;\n      }\n    }\n  }\n  if (!found) {\n    fragColor = vec4(0,0,0,1);\n    return;\n  }\n\n  // Compute gradient & normal\n  // Should probably scale eps here\n  float eps = 1e-3;\n  vec2 delta = vec2(eps,0.0);\n#if 0\n  p = p0 + k0*r; // Ensure p corresponds to k0 and a0\n  vec3 n = vec3(Fun(p + delta.xyyy), Fun(p + delta.yxyy), Fun(p + delta.yyxy)) - a0;\n#else\n  // Not sure how much difference this makes\n  vec3 n = vec3(Fun(p + delta.xyyy) - Fun(p - delta.xyyy),\n                Fun(p + delta.yxyy) - Fun(p - delta.yxyy),\n                Fun(p + delta.yyxy) - Fun(p - delta.yyxy));\n#endif\n  float grad = abs(length(n));\n  n = normalize(n);\n\n  vec3 eye = r.xyz;\n  // Point normal towards eye\n  if (dot(eye,n) > 0.0) n *= -1.0;\n  vec3 baseColor = selectColor(p,eye,n);\n  vec3 color = baseColor;\n#if !defined MIRROR\n  color *= ambient;\n  float k = dot(light,n);\n  if (doDiffuse && k > 0.0) {\n    color += baseColor*diffuse*k;\n  }\n  if (doSpecular && k > 0.0) {\n    float specular = pow(max(0.0,dot(reflect(light,n),eye)),4.0);\n    color += 0.8*specular*vec3(1);\n  }\n  if (doGamma) {\n    color = sqrt(color);\n  }\n#endif\n  fragColor = vec4(color,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = normalize(vec3(0.5,1,1));\n\n  // Projection parameters\n  float camera = 10.0;\n\n  float scale = 5.0;\n  float x = scale * (fragCoord.x - 0.5*iResolution.x)/iResolution.y;\n  float y = scale * (fragCoord.y - 0.5*iResolution.y)/iResolution.y;\n\n  vec3 p0 = vec3(0.0,0.0,camera);\n  vec3 r = normalize(vec3(x,y,-camera));\n\n  // Rotate camera according to mouse position\n  float xrot = 0.0; // About x-axis\n  float yrot = 0.0; // About y-axis\n  if (iMouse.x > 0.0) {\n    yrot = TWOPI*(iMouse.x-0.5*iResolution.x)/iResolution.x;\n    xrot = TWOPI*(iMouse.y-0.5*iResolution.y)/iResolution.y;\n  }\n  mat3 mx = mat3(1,0,0,\n                 0,cos(xrot),sin(xrot),\n                 0,-sin(xrot),cos(xrot));\n  mat3 my = mat3(cos(yrot),0,sin(yrot),\n                 0,1,0,\n                 -sin(yrot),0,cos(yrot));\n  iMatrix = my*mx;\n\n  p0 = iMatrix*p0;\n  r = iMatrix*r;\n  light = iMatrix*light; // Light moves with camera\n  \n  solve(fragColor,vec4(p0,1),vec4(r,0));\n}\n", "image_inputs": [{"id": "XdX3zn", "previewfilepath": "/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtlfz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[459, 547, 566, 566, 723], [725, 725, 747, 747, 805], [807, 807, 826, 826, 876], [878, 878, 902, 902, 1012], [1014, 1181, 1201, 1201, 1926], [1928, 1928, 1951, 1951, 2354], [2356, 2356, 2378, 2385, 2704], [2706, 2720, 2742, 2742, 3465], [3467, 3467, 3489, 3489, 3820], [3822, 3822, 3846, 3846, 3940], [3942, 3942, 3961, 3961, 4139], [4141, 4141, 4185, 4185, 4460], [4956, 5075, 5124, 5124, 7845], [7847, 7847, 7904, 7904, 8863]], "test": "untested"}
{"id": "XtsBD7", "name": "Mushrooms", "author": "kvanttiapina", "description": "Mushrooms moving about on a surface of a sphere.", "tags": ["raymarching", "mushrooms"], "likes": 3, "viewed": 107, "published": "Public", "date": "1512107731", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Mushrooms by JUkka Sirkka\n// \n// Credits: early versions based on this tutorial:\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// shadow mapping, ambient occlusion, sky gradient from \n// https://www.shadertoy.com/view/ldl3zn (P_Malin: TimeWarp)\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 600.0;\nconst float EPSILON = 0.0001;\nconst float NORMAL_DELTA = 0.1;\nconst float PI = 3.1415926535897932384626433832795;\nconst float MUSHROOM_RADIUS = 10.;\nconst float EARTH_RADIUS = 200.;\n\n\n\nconst int NO_HITS = -1;\nconst int THING = 1;\nconst int SKY = 3;\nconst int EARTH = 4;\n\nstruct Ray {\n    vec3 eye;\n    vec3 dir;\n};\n\nstruct HitInfo {\n    int object;\n    float dist;\n};\n\nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n};\n\n// ramp function with period = 2\nfloat ramp(float x) {\n    return 2. * mod(x, 1.) - 1.;\n}\n\n// square function with on/off values a & b, period 2\nfloat square(float a, float b, float x) {\n    return mix(a, b, step(ramp(x), 0.));\n}\n\n// http://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float k) {\n    float h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n    return mix(a, b, h) + k * h * (1. - h);\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nHitInfo intersectH(const in HitInfo a, const in HitInfo b) {\n    if (a.dist > b.dist) return a;\n    return b;\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nHitInfo unionH(const in HitInfo a, const in HitInfo b) {\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\n\nHitInfo unionSH(const in HitInfo a, const in HitInfo b) {\n    return HitInfo(a.dist < b.dist ? a.object : b.object, smin(a.dist, b.dist, .5));\n}\n\nHitInfo unionS1(const in HitInfo a, const in HitInfo b) {\n    return HitInfo(a.dist < b.dist ? a.object : b.object, smin(a.dist, b.dist, 1.));\n}\n\nHitInfo unionS2(const in HitInfo a, const in HitInfo b) {\n    return HitInfo(a.dist < b.dist ? a.object : b.object, smin(a.dist, b.dist, 2.));\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nHitInfo differenceH(const in HitInfo a, const in HitInfo b) {\n    if (a.dist > - b.dist) return a;\n    return HitInfo(b.object, -b.dist);\n}\n\nHitInfo differenceSH(const in HitInfo a, const in HitInfo b) {\n    return HitInfo(a.dist > - b.dist ? a.object : b.object, smax(a.dist, -b.dist, .5));\n}\n\nHitInfo differenceS1(const in HitInfo a, const in HitInfo b) {\n    return HitInfo(a.dist > - b.dist ? a.object : b.object, smax(a.dist, -b.dist, 1.));\n}\n\nHitInfo differenceS2(const in HitInfo a, const in HitInfo b) {\n    return HitInfo(a.dist > - b.dist ? a.object : b.object, smax(a.dist, -b.dist, 2.));\n}\n\n\nfloat sphereSDF(const in vec3 p) {\n    return length(p) - 1.0;\n}\n\n\nfloat plateSDF(const in vec2 p, const in vec2 dim) {\n    vec2 d = (abs(p) - dim);\n    return max(d.x, d.y);\n}\n\nfloat cylinderSDF(const in vec3 p, const in vec2 h) {\n    return plateSDF(vec2(length(p.xy), p.z), h);\n}\n\n\nvec3 rotateX(const in vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x, p.y*c - p.z*s, p.y*s + p.z*c);\n}\n\nvec3 rotateZ(const in vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x*c - p.y*s, p.x*s + p.y*c, p.z);\n}\n\nvec3 repeatE(const in vec3 p) {\n    float a = mod(atan(p.y, p.z) + PI, PI / 8.) - PI / 16.;\n    float r = length(p.yz);\n    return vec3(p.x, r*sin(a), r*cos(a));\n}\n\n\nvec3 moveTo(const vec3 p, vec2 pos) {\n    vec3 coe = vec3(0, 0, -EARTH_RADIUS);\n    // 0: latitude, 1: longitude\n    return repeatE(rotateX(rotateZ(p - coe, radians(pos[1])), radians(90. - pos[0]))) + coe;\n}\n\n\nHitInfo mushroom(in HitInfo ground, const in vec3 p, const in vec2 p0) {\n    vec3 q;\n    const float rob = MUSHROOM_RADIUS;\n    const float rou = .5 * MUSHROOM_RADIUS;\n    const float rol = .6 * MUSHROOM_RADIUS;\n    const vec2 cdim = vec2(.5, 6.);\n\n    q = moveTo(p, p0)  + vec3(.0, .0, .6 * rob - cdim[1]);\n    HitInfo mc = HitInfo(THING, cylinderSDF(q, cdim));\n    ground = unionS2(ground, mc);\n\n    q += vec3(.0, .0, -cdim[1] + rou * .95);\n    HitInfo mhu = HitInfo(THING, sphereSDF(q / rou) * rou);\n    q += vec3(.0, .0, mix(1.5, 2.0, 1. + sin(2.*iTime)));\n    HitInfo mhl = HitInfo(THING, sphereSDF(q / rol) * rol);\n\n    return unionH(ground, differenceSH(mhu , mhl));\n\n}\n\n\nHitInfo ground(in HitInfo earth, const in vec3 p, const in vec2 p0) {\n    vec3 q;\n    const float rob = MUSHROOM_RADIUS;\n\n    q = moveTo(p, p0)  - vec3(.0, .0, .4 * rob);\n    HitInfo mb = HitInfo(EARTH, sphereSDF(q / rob) * rob);\n\n    return differenceS2(earth, mb);\n}\n\nHitInfo sceneH(const in vec3 p) {\n    vec3 q;\n\n    vec3 coe = vec3(0., 0., -EARTH_RADIUS);\n\n    vec2 p1 = vec2(70, 90) + iTime * vec2(-3.3, 3.4);\n    vec2 p2 = vec2(70, -30) + iTime * vec2(3.9, -3.4);\n    vec2 p3 = vec2(70, 60) + iTime * vec2(3.6, 3.2);\n\n    q = p - coe;\n    HitInfo earth = HitInfo(EARTH, sphereSDF(q / EARTH_RADIUS) * EARTH_RADIUS);\n\n    earth = ground(earth, p, p1);\n    earth = ground(earth, p, p2);\n    earth = ground(earth, p, p3);\n\n    earth = mushroom(earth, p, p1);\n    earth = mushroom(earth, p, p2);\n    earth = mushroom(earth, p, p3);\n\n    float sky_radius = 2. * EARTH_RADIUS;\n    HitInfo sky = HitInfo(SKY, - sphereSDF(p / sky_radius) * sky_radius);\n\n    return unionH(sky, earth);\n\n}\n\nfloat sceneSDF(const in vec3 samplePoint) {\n    HitInfo hit = sceneH(samplePoint);\n    return hit.dist;\n}\n\nHitInfo raymarch(const in Ray ray, float start, float end) {\n    float depth = start;\n    HitInfo hit;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        hit = sceneH(ray.eye + depth * ray.dir);\n        if (hit.dist < EPSILON) {\n            return HitInfo(hit.object, depth);\n        }\n        depth += hit.dist;\n        if (depth >= end) {\n            return HitInfo(NO_HITS, 0.);\n        }\n    }\n    return HitInfo(NO_HITS, 0.);\n}\n\n\n\n\nvec3 estimateNormal(vec3 p) {\n    // assuming we are on the surface where sceneSDF ~ 0\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + NORMAL_DELTA, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + NORMAL_DELTA, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z + NORMAL_DELTA))\n    ));\n}\n\n\nvec3 getColorGeom(const in Light light, vec3 p, vec3 N, vec3 V, const in Material mat) {\n\n    vec3 c = vec3(0., 0., 0.);\n\n    vec3 L = normalize(light.pos - p);\n\n    float d = dot(L, N);\n\n    if (d < 0.) return c;\n\n    c += d * light.color * mat.diffuse;\n\n    // Blinn-Phong\n    vec3 H = normalize(L + V);\n    float k = dot(H, N);\n    if (k < 0.) return c;\n\n    c += pow(k, mat.shininess) * light.color * mat.specular;\n\n    return c;\n}\n\n\n\nMaterial getMaterial(int object, vec3 p, vec3 n) {\n    Material mat;\n    mat.ambient = vec3(.1, .1, .1);\n    mat.specular = vec3(.6, .6, .6);\n    mat.shininess = 10.;\n    if (object == THING) {\n        mat.diffuse = square(1., 2., p.x * 10.) * square(.5, 1., p.z * 10.) * vec3(.2, .9, .1);\n    } else if (object == SKY) {\n        mat.diffuse = vec3(.1, .1, .3);\n    } else if (object == EARTH) {\n        mat.diffuse = square(.5, 1.4, p.x) * square(.5, .7, p.y) * vec3(.56, .09, .03);\n    } else {\n        mat.diffuse = vec3(.0, .0, .0);\n    }\n\n    return mat;\n}\n\nvec3 getSkyGradient(const in vec3 dir)\n{\n    const vec3 sky = .15 * vec3(13./255., 214./255., 208./255.);\n    float blend = dir.z * 0.5 + 0.5;\n    return mix(vec3(.0), sky, blend);\n}\n\n// use distance field to evaluate ambient occlusion\nfloat getAmbientOcclusion(const in vec3 p, const in vec3 n)\n{\n    float occl = 1.;\n    float dist = 0.;\n\n    for (int i = 0; i < 5; i++) {\n        dist += .1;\n        float sdist = sceneSDF(p + n * dist);\n        occl *= 1. - max(0., (dist - sdist) * .4 / dist);\n    }\n    return occl;\n}\n\nfloat getShadow(const in vec3 l, const in vec3 p) {\n    float dist = length(p - l);\n\n    Ray ray;\n    ray.dir = (p - l) / dist;\n    ray.eye = l;\n\n    HitInfo hit = raymarch(ray, MIN_DIST, MAX_DIST);\n    if (hit.object == NO_HITS) {\n        return 0.;\n    }\n\n    return mix(.2, 1., step(dist - 0.01, hit.dist));\n}\n\n\n\nvec3 getColor(const in Ray ray, const in HitInfo hit) {\n\n    if (hit.object == SKY) {\n        vec3 c = getSkyGradient(ray.dir);\n        return pow(10. * c, vec3(1.8));\n    }\n\n    Light light;\n    vec3 baseColor = vec3(.8);\n\n    vec3 p = ray.eye + hit.dist * ray.dir;\n    vec3 n = estimateNormal(p);\n\n    Material mat = getMaterial(hit.object, p, n);\n\n    float ambientOcclusion = getAmbientOcclusion(p, n);\n    vec3 c = getSkyGradient(n) * ambientOcclusion;\n\n    c += getSkyGradient(reflect(ray.dir, n)) * ambientOcclusion;\n\n    // light.pos = vec3(4*sin(iTime), 4*cos(iTime), 2);\n    // c += getColorGeom(light, p, n, -ray.dir, mat);\n\n    light.pos = vec3(4.*sin(.37 * iTime), 4.*cos(.37 * iTime), 20.);\n    light.color = getShadow(light.pos, p) * baseColor;\n    c += getColorGeom(light, p, n, -ray.dir, mat);\n\n    return c;\n}\n\nmat4 windowToView(const in vec2 dim) {\n\tmat4 m = mat4(1.);\n\n    const float ct = 1. / tan(radians(22.5));\n    const float n = 1.;\n    const float f = 500.;\n    const float d = (n + f) / (n - f);\n    const float e = 2. * n * f / (n - f);\n\n    float a = dim.x / dim.y;\n\n    m[0][0] = a / ct;\n    m[1][1] = 1. / ct;\n    m[2][2] = 0.;\n    m[3][3] = d / e;\n    m[3][2] = -1.;\n    m[2][3] = 1. / e;\n    \n    return m;\n}\n\nmat4 viewToWorld(const in vec3 eye) {\n    const vec3 up = vec3(0., -1., 1.);\n    const vec3 center = vec3(0.);\n    \n    vec3 z = normalize(eye - center);\n    vec3 y = normalize(up - dot(z, up) * z);\n    vec3 x = cross(y, z);\n    \n    return mat4(vec4(x, 0.),\n                vec4(y, 0.),\n                vec4(z, 0.),\n                vec4(eye, 1.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    mat4 inv_proj = windowToView(iResolution.xy);\n    vec4 p1 = vec4(2. * fragCoord / iResolution.xy - 1., 1., 1.);\n    vec3 p2 = (inv_proj * p1).xyz;\n\n    vec3 eye = vec3(50., 70., 10.);\n    float zoom = .6;\n    mat4 inv_cam = viewToWorld(zoom * eye);\n\n    Ray ray;\n    ray.dir = normalize((inv_cam * vec4(p2, .0)).xyz);\n    ray.eye = inv_cam[3].xyz;\n\n    HitInfo hit = raymarch(ray, MIN_DIST, MAX_DIST);\n\n    if (hit.object == NO_HITS) {\n        // Didn't hit anything\n        fragColor = vec4(0., 0., .0, .0);\n        return;\n    }\n\n    fragColor = vec4(getColor(ray, hit), 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsBD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[889, 922, 943, 943, 978], [980, 1034, 1075, 1075, 1118], [1120, 1176, 1215, 1215, 1313], [1315, 1315, 1354, 1354, 1452], [1454, 1545, 1605, 1605, 1656], [1658, 1742, 1798, 1798, 1849], [1852, 1852, 1909, 1909, 1996], [1998, 1998, 2055, 2055, 2142], [2144, 2144, 2201, 2201, 2288], [2290, 2379, 2440, 2440, 2518], [2520, 2520, 2582, 2582, 2672], [2674, 2674, 2736, 2736, 2826], [2828, 2828, 2890, 2890, 2980], [2983, 2983, 3017, 3017, 3047], [3050, 3050, 3102, 3102, 3159], [3161, 3161, 3214, 3214, 3265], [3268, 3268, 3308, 3308, 3406], [3408, 3408, 3448, 3448, 3546], [3548, 3548, 3579, 3579, 3711], [3714, 3714, 3751, 3751, 3921], [3924, 3924, 3996, 3996, 4600], [4603, 4603, 4672, 4672, 4871], [4873, 4873, 4906, 4906, 5588], [5590, 5590, 5633, 5633, 5695], [5697, 5697, 5757, 5757, 6137], [6142, 6142, 6171, 6228, 6426], [6429, 6429, 6517, 6517, 6864], [6868, 6868, 6918, 6918, 7429], [7431, 7431, 7471, 7471, 7613], [7615, 7667, 7728, 7728, 7954], [7956, 7956, 8007, 8007, 8268], [8272, 8272, 8327, 8327, 9099], [9101, 9101, 9139, 9139, 9514], [9516, 9516, 9553, 9553, 9866], [9868, 9868, 9923, 9923, 10507]], "test": "untested"}
{"id": "XtsBRn", "name": "CS1230 Lab10", "author": "vkazas", "description": "cs1230", "tags": ["cs1230"], "likes": 3, "viewed": 184, "published": "Public", "date": "1512527437", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPHERE 0\n#define TERRAIN 1\n#define SEALEVEL 3\n#define NO_INTERSECT 2\n#define HELIX 5\n#define CLOUD 4\n\n#define LOD_NORM 9\n#define LOD_RAY 4\n\n#define SEALEVEL_HEIGHT 5.0\n#define CLOUD_HEIGHT_MIN 70.0\n#define CLOUD_HEIGHT_MAX 74.0\n\n#define AA  0\n\n// Data structure for raymarching results\nstruct PrimitiveDist {\n    float dist;\n    int primitive; // Can be SPHERE, TERRAIN, or NO_INTERSECT\n};\n\nfloat hash21(vec2 p) {\n    float h = dot(vec2(p),vec2(127.1,311.7));\n    return fract(sin(h)*43758.5453123) * 2.0 - 1.0;\n}\n\nfloat hash31(vec3 p) {\n    p = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\n    return -1.0+2.0*fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat valueNoise(vec2 p) {\n    vec2 pi = floor(p);\n    vec2 pf = fract(p);\n    vec2 u = pf*pf*pf*(6.0*pf*pf - 15.0*pf + 10.0);\n\n    float va = hash21(pi + vec2(0.0, 0.0));\n    float vb = hash21(pi + vec2(1.0, 0.0));\n    float vc = hash21(pi + vec2(0.0, 1.0));\n    float vd = hash21(pi + vec2(1.0, 1.0));\n\n    return mix(mix(va, vb, u.x), mix(vc, vd, u.x), u.y);\n}\n\nfloat valueNoise(vec3 p) {\n    vec3 pi = floor(p);\n    vec3 pf = fract(p);\n    vec3 u = pf*pf*pf*(6.0*pf*pf - 15.0*pf + 10.0);\n\n    float va = hash31(pi + vec3(0.0, 0.0, 0.0));\n    float vb = hash31(pi + vec3(1.0, 0.0, 0.0));\n    float vc = hash31(pi + vec3(0.0, 1.0, 0.0));\n    float vd = hash31(pi + vec3(1.0, 1.0, 0.0));\n    float ve = hash31(pi + vec3(0.0, 0.0, 1.0));\n    float vf = hash31(pi + vec3(1.0, 0.0, 1.0));\n    float vg = hash31(pi + vec3(0.0, 1.0, 1.0));\n    float vh = hash31(pi + vec3(1.0, 1.0, 1.0));\n\n    return mix(mix(mix(va, vb, u.x), mix(vc, vd, u.x), u.y),\n               mix(mix(ve, vf, u.x), mix(vg, vh, u.x), u.y), u.z);\n}\n\nfloat fbmTerrain(vec2 p, int level) {\n    float amp = 0.51;\n    float freq = 0.03;\n    float sum = 0.0;\n\n    for (int i = 0; i < level; i++) {\n        float vNoise = valueNoise(p * freq);\n        sum += amp * vNoise;\n        freq *= 2.01;\n        amp *= -0.49;\n    }\n    sum = pow(sum, 2.0);\n    return sum * 45.0;\n}\n\nfloat fbmCloud(vec3 p, int level) {\n    float amp = 0.51;\n    float freq = 0.03;\n    float sum = 0.0;\n\n    for (int i = 0; i < level; i++) {\n        float vNoise = valueNoise(p * freq);\n        sum += amp * vNoise;\n        freq *= 2.01;\n        amp *= -0.49;\n    }\n    \n    sum = (sum + 1.) * .5;\n    return sum;\n}\n\nfloat fbmSealevel(vec3 p, int level) {\n    float amp = 0.51;\n    float freq = 0.03;\n    float sum = 0.0;\n\n    for (int i = 0; i < level; i++) {\n        float vNoise = valueNoise(p * freq);\n        sum += amp * vNoise;\n        freq *= 2.01;\n        amp *= -0.49;\n    }\n    return sin(sum * 10.);\n}\n\n// Signed distance to the twisted sphere.\nfloat sdTwistedSphere(vec3 p) {\n    vec3 spherePosition = vec3(0.0, 2.0, 0.0);\n    float radius = 1.5;\n    float primitive = length(p - spherePosition) - radius;\n    return primitive;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat mapTerrain(vec3 p, int level) {\n\tfloat dist = p.x*p.x + p.z*p.z;\n    float delta = 0.;\n    float h = fbmTerrain(p.xz, level);\n\n    if (dist > 1600.) delta = - h * 1.0;\n    else delta = - h + exp(-dist/500.-1.)*50.;\n\n\n    return p.y -4. + delta;\n}\n\nfloat mapSealevel(vec3 p, int level) {\n    return p.y - SEALEVEL_HEIGHT - fbmSealevel(vec3(p.xz * .1, iTime * .5) * 5., level);\n}\n\nconst float theta = 3.14 * 2. / 16.;\nconst mat2 rotate2D = mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n\nfloat mapHelix(vec3 p) {\n    p.y = mod(p.y, 22.2);\n    vec3 offset = vec3(7., 3., 0.);\n    float dh = 1.2;\n    vec3 dimen = vec3(2.5, .1, 1.);\n    float res = 100000.0;\n    for (int i=0; i<16; i++) {\n        res = min(res, udBox(p - offset, dimen)); p.xz = rotate2D * p.xz; p.y -= dh;\n    }\n\treturn res;\n}\n\nfloat mapCloud(vec3 p) {\n    if (p.y < CLOUD_HEIGHT_MAX && p.y > CLOUD_HEIGHT_MIN) return -1.;\n\treturn min(abs(p.y - CLOUD_HEIGHT_MIN), abs(p.y - CLOUD_HEIGHT_MAX));\n}\n\nPrimitiveDist map(vec3 p) {\n    float terrainDist = mapTerrain(p, LOD_RAY);\n    float sealevelDist = mapSealevel(p, LOD_RAY - 1);\n    float helixDist = mapHelix(p);\n    //float cloudDist = mapCloud(p);\n    PrimitiveDist res = PrimitiveDist(terrainDist, TERRAIN);\n    float dist = res.dist;\n    float which = float(res.primitive);\n    //if (cloudDist < res.dist) res = PrimitiveDist(cloudDist, CLOUD);\n    which = mix(float(SEALEVEL), which, step(dist, sealevelDist));\n    dist = mix(sealevelDist, dist, step(dist, sealevelDist));\n    which = mix(float(HELIX), which, step(dist, helixDist));\n    dist = mix(helixDist, dist, step(dist, helixDist));\n\n    //if (sealevelDist < res.dist) res = PrimitiveDist(sealevelDist, SEALEVEL);\n    //if (helixDist < res.dist) res = PrimitiveDist(helixDist, HELIX);\n\n    return PrimitiveDist(dist, int(which));\n\n}\n\nPrimitiveDist mapUnderSea(vec3 p) {\n    float terrainDist = mapTerrain(p, LOD_RAY);\n    float helixDist = mapHelix(p);\n\n    PrimitiveDist res = PrimitiveDist(terrainDist, TERRAIN);\n\n    if (helixDist < res.dist) res = PrimitiveDist(helixDist, HELIX);\n\n    return res;\n}\n\nconst float epsilon = 0.01;\nvec2 e = vec2(epsilon, 0.0); // For swizzling\nvec3 calcNormal(vec3 p, int which) {\n    vec3 norm = vec3(0.);\n    if (which == TERRAIN) {\n        norm.x = mapTerrain(p + e.xyy, LOD_NORM) - mapTerrain(p - e.xyy, LOD_NORM);\n        norm.y = mapTerrain(p + e.yxy, LOD_NORM) - mapTerrain(p - e.yxy, LOD_NORM);\n        norm.z = mapTerrain(p + e.yyx, LOD_NORM) - mapTerrain(p - e.yyx, LOD_NORM);\n    } else if (which == SEALEVEL){\n        norm.x = mapSealevel(p + e.xyy, LOD_NORM) - mapSealevel(p - e.xyy, LOD_NORM);\n        norm.y = mapSealevel(p + e.yxy, LOD_NORM) - mapSealevel(p - e.yxy, LOD_NORM);\n        norm.z = mapSealevel(p + e.yyx, LOD_NORM) - mapSealevel(p - e.yyx, LOD_NORM);\n    } else {\n        norm.x = map(p + e.xyy).dist - map(p - e.xyy).dist;\n        norm.y = map(p + e.yxy).dist - map(p - e.yxy).dist;\n        norm.z = map(p + e.yyx).dist - map(p - e.yyx).dist;\n    }\n\n    return normalize(norm);\n}\n\n\nPrimitiveDist raymarchUnderSea(vec3 ro, vec3 rd, float maxDist, float marchSpeed) {\n    float marchDist = 0.001;\n    float boundingDist = maxDist;\n    float threshold = 0.1;\n\n    // Fill in the iteration count\n    for (int i = 0; i < 100; i++) {\n        // Fill in loop body\n        vec3 pos = ro + rd * marchDist;\n        PrimitiveDist near = mapUnderSea(pos);\n        if (near.dist < threshold)\n            return PrimitiveDist(marchDist, near.primitive);\n        marchDist += near.dist * marchSpeed;\n        if (marchDist > boundingDist) break;\n    }\n\n    return PrimitiveDist(-1.0, NO_INTERSECT);\n}\n\nPrimitiveDist raymarch(vec3 ro, vec3 rd, float maxDist, float marchSpeed) {\n    float marchDist = 0.001;\n    float boundingDist = maxDist;\n    float threshold = 0.1;\n\n    // Fill in the iteration count\n    for (int i = 0; i < 200; i++) {\n        // Fill in loop body\n        vec3 pos = ro + rd * marchDist;\n        PrimitiveDist near = map(pos);\n        if (near.dist < threshold)\n            return PrimitiveDist(marchDist, near.primitive);\n        marchDist += near.dist * marchSpeed;\n        if (marchDist > boundingDist) break;\n    }\n\n    if ((ro.y < CLOUD_HEIGHT_MIN && rd.y > 0.) || (ro.y > CLOUD_HEIGHT_MAX && rd.y < 0.)) \n        return PrimitiveDist(-1.0, CLOUD);\n    return PrimitiveDist(-1.0, NO_INTERSECT);\n}\n\nvec3 generateTerrainColor(vec3 pos, vec3 norm, vec3 lig) {\n    vec3 col = vec3(0.0);\n\n    vec3 lightGreen = vec3(0.564, 0.833, 0.564);\n    vec3 lawnGreen = vec3(0.498, 0.99, 0);\n    vec3 springGreen = vec3(0.0, 1.0, 0.5);\n    vec3 greenYellow = vec3(.678, 0.99, .184);\n    vec3 olive = vec3(0.5, 0.5, 0.0);\n\n    vec3 grass1 = vec3(.125, .365, .0);\n    vec3 grass2 = vec3(.16, .274, .141);\n    vec3 grass3 = vec3(.0, .2, .0);\n    vec3 grass4 = vec3(.45, .6, .0);\n\n    vec3 earth      = vec3(.824, .706, .549);\n    vec3 calcaire   = vec3(.624, .412, .118);\n    vec3 rocks      = vec3(.412, .388, .422);\n    vec3 beach      = vec3( 1.0, .894, .710);\n\n    float posNoise = valueNoise(pos.xz) + 1.0 * 0.5;\n    float darkness = 1.;\n      \n    // Ambient\n    float ambient = 0.2;\n    // Diffuse\n    float diffuse = clamp(dot(norm, lig), 0.0, 1.0);\n    \n    // Shadow\n    /*\n    if (dot(norm, lig) > 0.) {\n        PrimitiveDist res = raymarch(pos + norm * .8, lig, 30., .8);\n        vec3 shadPos = pos + res.dist * lig;\n        if (res.primitive == HELIX || res.primitive == TERRAIN) {\n            darkness = smoothstep(0., 30., res.dist) * .8;\n        }\n    }*/\n\n\n    // base color\n    col = mix (        beach,    earth, smoothstep(0.0 , 0.08 , pos.y) );\n    col = mix ( col, calcaire, smoothstep(0.08, 0.3 , pos.y) );\n    col = mix ( col,    rocks, smoothstep(0.3, 10.0  , pos.y) );\n\n    return (ambient + diffuse * col) * darkness;\n}\n\nvec3 generateHelixColor(vec3 ro, vec3 rd, vec3 norm, vec3 lig) {\n    float ambient = 0.1;\n    float diffuse = clamp(dot(norm, lig), 0.0, 1.0);\n    float specular = pow(clamp(dot(rd, reflect(lig, norm)), 0.0, 1.0), 16.);\n    \n    vec3 col = vec3(1., 1., .93);\n    return ambient + col * (diffuse + specular);\n}\n\nvec3 generateSeaColor(vec3 ro, vec3 rd, vec3 norm, vec3 lig) {\n    float ndotr = dot(norm, rd);\n    float r0 = .6;\n    r0 = min(r0 + .3 * max(valueNoise(vec3(ro.xz * 5., iTime * 10.)) - .2, 0.), 1.0);\n    float fresnel = r0 + (1. - r0) * pow(1.0 - abs(ndotr), 5.);\n    vec3 col = vec3(.292, .434, .729), reflCol, refrCol;\n    float darkness = 1.;\n    \n    // Reflection\n    vec3 reflD = reflect(rd, normalize(norm + vec3(.0, .3, .0)));\n    PrimitiveDist res = raymarch(ro, reflD, 100., .5);\n    vec3 reflPos = ro + res.dist * reflD;\n    if (res.primitive == TERRAIN) {\n        reflCol = generateTerrainColor(reflPos, calcNormal(reflPos, TERRAIN), lig);\n    } else if (res.primitive == HELIX) {\n    \treflCol = generateHelixColor(reflPos, reflD, calcNormal(reflPos, HELIX), lig);\n    }\n    \n    // Refraction\n    vec3 refrD = refract(rd, vec3(0., 1., 0.), .8);\n    res = raymarchUnderSea(ro, refrD, 20., .8);\n    vec3 refrPos = ro + res.dist * refrD;\n    //refrCol = texture(iChannel1, refrPos.xz * 2.).xyz;\n    if (res.primitive == TERRAIN) {\n        refrCol = generateTerrainColor(refrPos, calcNormal(refrPos, TERRAIN), lig);\n    } else if (res.primitive == HELIX) {\n    \trefrCol = generateHelixColor(refrPos, refrD, calcNormal(refrPos, HELIX), lig);\n    }\n    \n    col = mix(col, fresnel * reflCol + (1. - fresnel) * refrCol, .8);\n\n    // Shadow\n    res = raymarch(ro + vec3(0, .15, 0.), lig, 30., .5);\n    vec3 shadPos = ro + res.dist * lig;\n    if (res.primitive == HELIX || res.primitive == TERRAIN) {\n\t\tdarkness = 1. - 1. / (1. + res.dist * .1 + res.dist * .005);\n    }\n    \n    float ambient = 0.2;\n    float diffuse = clamp(dot(norm, lig), 0.0, 1.0);\n    float specular = pow(clamp(dot(rd, reflect(lig, norm)), 0.0, 1.0), 32.);\n    \n    return (ambient + col * (diffuse + specular)) * darkness;\n}\n\nvec3 generateCloudColor(vec3 ro, vec3 rd) {\n    vec3 bgc = vec3(0.3, .55, .8);\n    vec4 sum = vec4(0.);\n    float dist;\n    if (ro.y < CLOUD_HEIGHT_MIN) {\n    \tdist = (CLOUD_HEIGHT_MIN - ro.y) / rd.y + .01;\n        ro = ro + dist * rd;\n    } else if (ro.y > CLOUD_HEIGHT_MAX) {\n    \tdist = -(ro.y - CLOUD_HEIGHT_MAX) / rd.y + .01;\n        ro = ro + dist * rd;\n    }\n    \n    vec3 cloud1 = vec3(1.0,0.95,0.8);\n    vec3 cloud2 = vec3(0.25,0.3,0.35);\n    \n    //rd.y = max(rd.y, .2);\n    rd.y = sqrt(abs(rd.y)) * sign(rd.y);\n    //rd = normalize(rd);\n    \n    while ((sum.a < 1.0) && (ro.y > CLOUD_HEIGHT_MIN) && (ro.y < CLOUD_HEIGHT_MAX)) {\n    \tfloat density = fbmCloud(ro * rd.y, LOD_NORM) * .1;\n        vec3 col = mix(cloud1, cloud2, density);\n        sum.a += density;\n        sum.rgb += col * density * density * 15.;\n        ro = ro + rd * .5;\n    }\n    bgc = mix(bgc, sum.rgb, sum.a);\n\treturn bgc;\n}\n\nvec3 render(vec3 ro, vec3 rd, float t, int which) {\n\n    // Col is the final color of the current pixel.\n    vec3 col = vec3(0.);\n    vec3 pos = ro + rd * t;\n    // Light vector\n    vec3 lig = normalize(vec3(0.5,0.5,0.5));\n    vec3 lightCol = vec3(1., 1., 1.);\n\n    // Normal vector\n    vec3 nor = calcNormal(pos, which);\n\n    // TODO [Task 5] Assign different intersected objects with different materials\n    // Make things pretty!\n    vec3 material = vec3(0.0);\n    if (which == TERRAIN) {\n        //material = texCube(iChannel0, pos, nor);\n        col = generateTerrainColor(pos, nor, lig);    \n    } else if (which == HELIX) {\n        col = generateHelixColor(pos, rd, nor, lig);\n    } else if (which == SEALEVEL){\n      \tcol = generateSeaColor(pos - rd * .05, rd, nor, lig);\n    } else if (which == CLOUD) {\n    \tcol = generateCloudColor(ro, rd);\n    }\n    \n    // Applying the phong lighting model to the pixel.\n    //col += vec3(((ambient + diffuse + specular) * darkness));\n    //col += vec3(ambient + diffuse + specular);\n\n    return col;\n}\n\nvec3 postProcess(vec3 col, vec2 uv) {\n    // Rain\n    vec2 rainUV = (uv * vec2(5., .3) + vec2(.8 * iTime - (uv.x + uv.y) * 1., .8 * iTime)) * 30. ;\n    float rain = max(valueNoise(rainUV), 0.) * .5;\n    col = mix(col, vec3(rain), .1);  \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float height = iTime * 2.;\n    \n    vec3 rayOrigin = vec3(20.0 * sin(iTime * .1), 20., 20.0 * cos(iTime * .1));\n    \n    float focalLength = 2.0;\n    \n    // The target we are looking at\n    vec3 target = vec3(0.0, 10., 0.0);\n    // Look vector\n    vec3 look = normalize(rayOrigin - target);\n    // Up vector\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // Set up camera matrix\n    vec3 cameraForward = -look;\n    vec3 cameraRight = normalize(cross(cameraForward, up));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraForward)); \n    \n    // Construct the ray direction vector\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    // AA\n    if (AA == 1) {\n        vec2 uvSize = 2. / iResolution.yx;\n    \t\n        for (int dx = -1; dx <= 1; dx += 2) {\n            for (int dy = -1; dy <= 1; dy += 2) {\n            \tvec2 puv = uv + vec2(float(dx) * uvSize.x * .25, float(dy) * uvSize.y * .25);\n                    vec3 rayDirection = vec3(puv, focalLength);\n                    rayDirection = normalize(puv.x * cameraRight + puv.y * cameraUp + focalLength * cameraForward);\n\n                    PrimitiveDist rayMarchResult = raymarch(rayOrigin, rayDirection, 500., .5);\n                    vec3 tcol = vec3(0.3, .55, .8);\n                    if (rayMarchResult.primitive != NO_INTERSECT) {\n                      tcol = render(rayOrigin, rayDirection, rayMarchResult.dist, rayMarchResult.primitive);\n                    }\n\n                    // Postprocess\n    \t\t\t\ttcol = postProcess(tcol, uv);\n                col += tcol;\n            }\n        }\n        col *= .25;\n    } else if (AA == 0) {\n        vec3 rayDirection = vec3(uv, focalLength);\n        rayDirection = normalize(uv.x * cameraRight + uv.y * cameraUp + focalLength * cameraForward);\n\n        PrimitiveDist rayMarchResult = raymarch(rayOrigin, rayDirection, 500., .5);\n        \n        if (rayMarchResult.primitive != NO_INTERSECT) {\n            col = render(rayOrigin, rayDirection, rayMarchResult.dist, rayMarchResult.primitive);\n        }\n\n        // Postprocess\n        col = postProcess(col, uv);\n    }\n      \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsBRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[252, 399, 421, 421, 521], [523, 523, 545, 545, 662], [664, 664, 690, 690, 1027], [1029, 1029, 1055, 1055, 1679], [1681, 1681, 1718, 1718, 1997], [1999, 1999, 2034, 2034, 2313], [2315, 2315, 2353, 2353, 2611], [2613, 2655, 2686, 2686, 2840], [2842, 2842, 2873, 2873, 2911], [2913, 2913, 2950, 2950, 3165], [3167, 3167, 3205, 3205, 3296], [3413, 3413, 3437, 3437, 3718], [3720, 3720, 3744, 3744, 3887], [3889, 3889, 3916, 3916, 4735], [4737, 4737, 4772, 4772, 5006], [5065, 5082, 5118, 5118, 5947], [5950, 5950, 6033, 6033, 6552], [6554, 6554, 6629, 6629, 7274], [7276, 7276, 7334, 7334, 8705], [8707, 8707, 8771, 8771, 9016], [9018, 9018, 9080, 9080, 10821], [10823, 10823, 10866, 10866, 11727], [11729, 11729, 11780, 11833, 12778], [12780, 12780, 12817, 12829, 13034], [13036, 13036, 13091, 13091, 15316]], "test": "untested"}
{"id": "XtsBRS", "name": "Mobius Weave", "author": "Shane", "description": "A Mobius spiral with a pseudo random weave - Inspired by Fabrice's cool \"Round Weave\" example.", "tags": ["spiral", "mobius", "complex", "weave"], "likes": 39, "viewed": 2709, "published": "Public API", "date": "1512387012", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tMobius Weave\n\t------------\n\n\tA Mobius spiral with a pseudo random weave. The idea came from Fabrice's cool \"Round Weaving\" \n\texample. Fabrice always comes up with clever little shaders, and I have a habit of viewing\n\tthem, then going off on a tangent for a few hours. :) \n\n\tHis \"Round Weaving\" shader essentially involves applying something along the lines of a polar \n\ttransform to a standard cross-weave pattern. Although visually different, this is just an extension \n\tof that with some window dressing applied. Instead of the standard over under weave, I've psuedo-\n\trandomized it, and have substituted the polar transform for a reasonably well known Mobius spiral \n\ttransform, which is polar in nature, but a little bit fancier.\n\n\tInspired by:\n\n    // Slightly different, but basically a polar transformed cross weave. As with a lot of Fabrice's\n\t// shaders, it's very concisely written - Roughly a couple of tweets.\n\tround weaving - FabriceNeyret2\n\thttps://www.shadertoy.com/view/MtffzB\n\n\tOther related examples:\n\n    // Very cool, much more complex (no pun intended) example. Mobius spirals are pretty easy;\n\t// Packing circles into them is less so. :)\n\tDoyle spirals - knighty\n\thttps://www.shadertoy.com/view/4tffDH\n\n\t// A simplified circle packed spiral.\n\tDoyle spiral - ws\n\thttps://www.shadertoy.com/view/MtffDn\n\n\t// Just the basics - for anyone who wants to make a Mobius spiral, or whatever they're\n\t// technically called.\n\tLogarithmic Mobius Transform - Shane\n\thttps://www.shadertoy.com/view/4dcSWs\n\n*/\n\n\n// Standard 2D rotation formula - See Nimitz's comment.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n// Standard Mobius transform: f(z) = (az + b)/(cz + d). Slightly obfuscated.\nvec2 Mobius(vec2 p, vec2 z1, vec2 z2){\n\n\tz1 = p - z1; p -= z2;\n\t//return vec2(dot(z1, p), z1.y*p.x - z1.x*p.y)/dot(p, p);\n    // Equivalent to the line above. Fabrice tidied it up. I'd imagine the grouped\n    // operations might make it a little quicker, but don't quote me on that. :)\n    return mat2(z1, z1.y, -z1.x)*p/dot(p, p); \n}\n\n\n// Standard spiral zoom.\nvec2 spiralZoom(vec2 p, vec2 offs, float n, float spiral, float zoom, vec2 phase){\n\t\n\tp -= offs;\n\tfloat a = atan(p.y, p.x)/6.283 + iTime/32.;\n\tfloat d = length(p);\n\t//return vec2(a*n + log(d)*spiral, -log(d)*zoom + a) + phase;\n    // Equivalent to the line above. Fabrice tidied this one up too. :)\n    return mat2(n, 2, spiral,-zoom)*vec2(a, log(d)) + phase;\n\n}\n\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement.\n//\nfloat noise3D(vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(7, 157, 113);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Rotation and scaling.\n    uv = r2(3.14159/6.*sin(iTime/3.))*uv*1.2;    \n    \n     \n/*  \n\t// Polar transformation. Not as fancy looking, but there for comparison.\n    uv = r2(iTime/4.)*uv;\n    uv = r2(atan(uv.y, uv.x)*1.)*uv*2.;\n    float r = length(uv)*.35;\n    vec2 p = uv*16.;\n*/ \n    \n/*   \n\t// Standard patterned weave. Comparitively speaking, not that exciting. :)\n\t// Comment out the four lines below this block first.\n    uv += iTime/16.;\n    float r = 1.;\n    vec2 p = uv*8.;\n*/\n    \n    // Shading over the two singularity points. It serves two purposes: One, to give depth,\n    // but also to alleviate Moire patterns that tend to build up.\n    float r = min(length(uv - vec2(.5, 0)), length(uv - vec2(-.5, 0)));\n    //float r = length(uv - vec2(.5, 0))*length(uv - vec2(-.5, 0));\n    \n    \n    // Transform the screen coordinates: For anyone not familiar with the order in which\n    // you do this, transforms are performed prior to rendering the flat grid.\n    //\n    // The logarithmic Mobius spiral is one of the more interesting transformations, and \n    // just involves a little math. By the way, these transforms work independently, but tend \n    // to look better coupled together.\n    uv = Mobius(uv, vec2(-1, -.5), vec2(.5, 0));\n    // Logarithmic spiral zoom. Odd spiral numbers can sometimes put grid patterns out of\n    // sync, depending on the situation. Just something to think about if yours seams\n    // aren't matching up.\n    uv = spiralZoom(uv, vec2(-.5), 4., 3.14159*.2, .5, vec2(-1, 1)*iTime*.125);\n     \n    \n    // Scene scaling. \n    const float sc = 4.;\n    vec2 p = uv*sc;\n    \n    \n    // Overlapping cross construction. Most of it is common sense - Split space up into\n    // grid cells. In each cell, draw a horizontal line, then overlap it with a vertical \n    // line. Apply shadows, decorative design, etc.\n    \n    \n    // Cell's unique ID.\n    vec2 ip = floor(p);\n    \n    // Partition space into cells. The line below is equivalent to \"p = fract(p) - .5;.\"\n    // It saves a \"fract\" call, which doesn't matter here, but it can be helpful inside\n    // raymarching loops and so forth.\n    p -= ip + .5;\n    \n    // Due to the nature of the transform, the pattern needs to wrap about the line\n    // dividing the two singularity points, so true randomness isn't really possible.\n    // However, it's possible use a symmetrical pattern that looks random... Kind of.\n    //\n    // By the way, I hacked the following together in a hurry, so there's probably a\n    // more elegant way to write it. Although, I could probalby say that about most \n    // of my code. :)\n    if(mod(ip.x*ip.y*.5 + (ip.x + ip.y + 1.)*.75, sc/2.)>.5) p.xy = p.yx;\n\n    // It'd be nice to really randomize with the following, but artifacts are visible\n    // about the line ividing the two singularity points. Hopefully, there's a\n    // workaround, but I'm not sure what it is yet.\n    //if(fract(sin(dot(ip, vec2(1.373, 113.937)))*43758.5453)>.5) p.xy = p.yx;\n    \n\n    // Horizontal line and vertical lines. Fabrices has cleverly used sinsusoids to\n    // do it all, but I needed a little more precission to work with, so went the\n    // 2D distance field route.\n    float cx = abs(p.y) - .21;\n    float cy = abs(p.x) - .21;\n    \n    // Rendering the decorated overlapping crosses. A lot of it was made up as I went\n    // along. I could probably group a lot of it together, but relatively speaking, \n    // this all pretty easy for the GPU to handle.\n    \n    // The patterns that run over the stripes to give it that cheesy yarn-like look. :)\n    float pat = clamp(cos((uv.x - uv.y)*6.283*24.)*.35 + .65, 0., 1.)*.8 + .2;\n    vec2 uv2 = r2(-3.14159/4.)*uv;\n    float pat3 = clamp(cos((uv2.x + uv2.y)*6.283*48.)*.75 + .75, 0., 1.)*.8 + .2;\n    \n    // The longitudinal and latitudinal stripes. One for the vertical line and another\n    // for the horizontal one.\n    float stripeX = clamp(cos(p.y*6.238*6.)*.6 + .57, 0., 1.);\n    float stripeY = clamp(cos(p.x*6.238*6.)*.6 + .57, 0., 1.);\n    \n    // The background pattern - It's supposed to give the impression that there's some more\n    // tightly woven yarn behind the main geometric pattern, or something to that effect.\n    vec3 col = vec3(.25)*(1. - pat3*.9)*pat;\n\n    // Rendering the vertical line.\n    col = mix(col, vec3(0), (1. -smoothstep(0., .1, cx - .125))*.7); // Drop shadow.\n    col = mix(col, vec3(0), 1. -smoothstep(0., .025, cx - .05)); // Sharper border line.\n    // Main pattern.\n    col = mix(col, vec3(.6)*(cos(p.y*6.283) + 1.)*stripeX*pat, 1. -smoothstep(0., .025, cx)); \n    // Darkening the center, just to tone it down a little.\n    col = mix(col, vec3(0), (1. -smoothstep(0., .05, cx + .175))*.65);\n     \n    // Rendering the horizonal line, which is just a repeat of the above.\n    col = mix(col, vec3(0), (1. -smoothstep(0., .1, cy - .125))*.7);\n    col = mix(col, vec3(0), 1. -smoothstep(0., .025, cy - .05));\n    col = mix(col, vec3(.6)*(cos(p.x*6.283) + 1.)*stripeY*pat, 1. -smoothstep(0., .025, cy));\n    col = mix(col, vec3(0), (1. -smoothstep(0., .05, cy + .175))*.65);\n    \n\n    // Add a bit of noise to give the weave material more of an authentic look. 3D noise\n    // was a bit of an indulgence, and not all that necessary, but I thought I'd supply\n    // the fake depth information too.\n    col *= noise3D(vec3(uv*256., r))*.75 + .75;\n    \n    \n    // Artificial depth shading.\n    //\n    // Applying the shading to give the pattern a bit of depth, and to hide singularity\n    // artifacts.\n    vec3 fogCol = vec3(0); // Other - very dark - colors work too, but don't look convincing.\n    col = mix(col, fogCol, 1./(1. + r*.25 + r*r*8.));\n    // Extra fake fog to darken the horizon of those singularities a bit more.\n    col = mix(col, fogCol, smoothstep(0., .99, .03/r));\n    \n    \n    // Very mild sepia, almost charcoal. I did this to pay hommage to Fabrice's version. :)\n    col *= vec3(1.1, 1, .95);\n    \n    \n    // Apply a vignette.\n    uv = fragCoord/iResolution.xy; \n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y), .25)*1.15;\n \n    \n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsBRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1523, 1579, 1599, 1599, 1657], [1660, 1737, 1775, 1775, 2071], [2074, 2099, 2181, 2181, 2461], [2463, 2723, 2745, 2838, 3790], [3792, 3792, 3846, 3874, 10056]], "test": "untested"}
{"id": "XtsBWl", "name": "SprialMove_BabyVersion", "author": "PaperColor", "description": "SprialMove_BabyVersion", "tags": ["sprialmovebabyversion"], "likes": 0, "viewed": 371, "published": "Public API", "date": "1514261003", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//I make this in unity3d first,then implement it here\n//Twitter:@LowpolySun\n\n#define float2 vec2\n#define float3 vec4\n#define float4 vec4\n#define frac fract\n\n//This macro is always the same\n#define SetUVAndMoveToCenter vec2 uv = fragCoord.xy/iResolution.xy;uv.x*=iResolution.x/iResolution.y;uv.x -= 0.35;uv.y+=0.1;\n\n#define pi 3.141592654\n#define tao 2.0*pi\n#define width 0.03\n\n#define moveSpeed 0.05\n#define angleSpeed pi\n#define dotNumber  1.0\t\n\n//every timeCycle animation will reset\n#define timeCycle 50.0\n\nfloat lerp(float a,float b,float v)\n{\n\t//clamp to 0 and 1\n\tif(v>1.0) v=1.0;\n\telse if(v<0.0) v=0.0;\n\treturn a*(1.0-v)+b*v;\n}\n\nvec4 lerp(vec4 a,vec4 b,float v)\n{\n\tfloat red = lerp(a.r,b.r,v);\n\tfloat green = lerp(a.g,b.g,v);\n\tfloat blue = lerp(a.b,b.b,v);\n\tfloat alpha = lerp(a.a,b.a,v);\n\treturn vec4(red,green,blue,alpha);\n}\n\nbool IsInRange(float2 p1,float2 p2,float range)\n{\n\treturn length(p1-p2)<range;\n}\n\nfloat totalLength = 0.0;\nfloat time = 0.0;\nfloat lastTime =0.0;\n\nfloat SprialPattern(float2 uv)\n{\n\tuv = uv*2.0 - 1.0;\n    uv*=2.0;\n    //float time =log(iTime); //sin(iTime);\n\t\n    time =frac(iTime/timeCycle)*timeCycle;\n    \n\tfloat moveLength = moveSpeed*time;\n\tfloat currentAngle = angleSpeed*time;\n\tfloat2 currentPosition = float2(moveLength*cos(currentAngle),moveLength*sin(currentAngle));\n\n\tbool b = IsInRange(currentPosition,uv,width);\n\tif(b) return 1.0;\n\treturn 0.0;\n}\n\nfloat SprialMove(float2 uv,float2 centerPosition,float speedDirection)\n{\n\tuv = uv*2.0 - 1.0;\n    uv*=2.0;\n    //float time =log(iTime); //sin(iTime);\n\t\n    time =frac(iTime/50.0)*50.0;\n    \n    if(speedDirection<=0.0)\n        speedDirection = -1.0;\n    else\n        speedDirection =1.0;\n    \n    \n\tfloat moveLength = moveSpeed*time*speedDirection;\n\tfloat currentAngle = angleSpeed*time*speedDirection;\n\tfloat2 currentPosition =centerPosition + float2(moveLength*cos(currentAngle),moveLength*sin(currentAngle));\n\n\tbool b = IsInRange(currentPosition,uv,width);\n\t\n    if(b) return 1.0;\n\treturn 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tSetUVAndMoveToCenter\n\n    \n\tfloat finalValue =0.0;\n    float dx = iResolution.x/100.0;\n    //Change dotNumber here,but trust me,single dot looks better,\n    for(float index=-dotNumber;index<dotNumber;index+=1.0)\n    {\n        finalValue += SprialMove( uv ,float2( index/100.0 , 0.0 ),sin(index));\n    }\n\t\n\t//float finalValue = moveValue1+moveValue2+moveValue3+moveValue4;\n\n\tfragColor = vec4(finalValue,finalValue,finalValue,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsBWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[447, 510, 547, 567, 633], [635, 635, 669, 669, 832], [834, 834, 883, 883, 914], [981, 981, 1013, 1013, 1390], [1392, 1392, 1464, 1464, 1989], [1992, 1992, 2049, 2049, 2482]], "test": "untested"}
{"id": "XtsBz2", "name": "Blaschke product", "author": "mahalis", "description": "Quick experiment with some math I learned about recently—complex numbers are fun! Further reading: https://en.wikipedia.org/wiki/Blaschke_product", "tags": ["rainbow", "complex"], "likes": 19, "viewed": 652, "published": "Public API", "date": "1512521348", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 cMul(vec2 a, vec2 b) { // complex multiplication\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 cDiv(vec2 a, vec2 b) { // complex division\n    return vec2((a.x * b.x + a.y * b.y), (a.y * b.x - a.x * b.y)) / dot(b, b);\n}\n\nvec2 conj(vec2 a) { // complex conjugate\n    return vec2(a.x, -a.y);\n}\n\nvec2 blaschkeB(vec2 a, vec2 z) { // a is the point in the set, z is the sample point on the grid\n    return cDiv(a - z, vec2(1.,0.) - cMul(conj(a), z));\n}\n\n// from iq’s article here: http://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette(float v) {\n    return vec3(0.5) + 0.5 * cos(6.28318 * (v + vec3(0.0,0.333,0.667)));\n}\n\nvec2 thingPosition(float t) { // from an old thing of mine here: https://www.shadertoy.com/view/Xl33D7\n    return vec2(sin(2.2 * t) - cos(1.4 * t), cos(1.3 * t) + sin(-1.9 * t)) * 0.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    uv *= 1.1;\n    \n    vec2 prod = vec2(1.,0.);\n    for(int i = 0; i < 43; i++) {\n   \t\tvec2 a = thingPosition(float(i) * 37. /* arbitrary */ + iTime * 0.3);\n        prod = cMul(prod, blaschkeB(a, uv));\n    }\n    \n    float angle = atan(prod.y, prod.x) * 1.;\n\tfragColor = vec4(palette(angle / 6.28318 - iTime * 1.9),1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsBz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 53, 118], [120, 120, 147, 167, 248], [250, 250, 269, 290, 320], [322, 322, 354, 418, 476], [478, 568, 591, 591, 666], [668, 668, 697, 770, 854], [856, 856, 913, 913, 1301]], "test": "untested"}
{"id": "XtsBzN", "name": "CS123 Lab", "author": "npolshakova", "description": "Shadeee", "tags": ["shadertoylab"], "likes": 0, "viewed": 100, "published": "Public", "date": "1513446740", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPHERE 0\n#define PLANE 1\n#define NO_INTERSECT 2\n#define DISPLACEMENT_FACTOR 0.1\n\n// Data structure for raymarching results\nstruct PrimitiveDist {\n    float dist;\n    int primitive; // Can be SPHERE, PLANE, or NO_INTERSECT\n};\n\n// Helper function for tri3.\nfloat tri(in float x) {\n\treturn abs(fract(x)-.5);\n}\n\n// Triangle noise. Use it as a sample displacement map for task 7.\nvec3 tri3(in vec3 p) {\n    return vec3(tri(p.z+tri(p.y*1.)), \n                tri(p.z+tri(p.x*1.)), \n                tri(p.y+tri(p.x*1.)));\n}\n\n// TODO [Task 8] Make a displacement map\n// You can check out tri3 above and the functions in the handout as inspiration\nfloat calcDisplacement(in vec3 p) {\n   return sin(p.x) + sin(p.z);\n}\n\n// TODO [Task 6] Implement triplanar texture mapping\n// If you want, you can play around with the textures in iChannels 0 and 1\n// The textures should show no distortion\nvec3 texCube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec4 textX = texture(sam, p.yz);\n    vec4 textY = texture(sam, p.xz);\n    vec4 textZ = texture(sam, p.xy);\n    \n    n = vec3(abs(n.x), abs(n.y), abs(n.z));\n    \n    vec3 xVal = vec3(textX.x, textX.y, textX.z) * n;\n    vec3 yVal = vec3(textY.x, textY.y, textY.z) * n;\n    vec3 zVal = vec3(textZ.x, textZ.y, textZ.z) * n;\n    \n    return mix(xVal,yVal,zVal);\n    \n    //return vec3(0.5);\n}\n\n// Signed distance to the twisted sphere.\nfloat sdTwistedSphere(vec3 p) {\n    vec3 spherePosition = vec3(0.0, 0.25, 0.0);\n    float radius = 1.5;\n    float primitive = length(p - spherePosition) - radius;\n    return primitive + calcDisplacement(p);\n}\n\nfloat sdFloor(vec3 p) {\n    return p.y;\n}\n\nPrimitiveDist map(vec3 p) {\n    // TODO [Task 3] Implement distance map\n    float closest = 0.0;\n    float plane = sdFloor(p);\n    float sphere = sdTwistedSphere(p);\n    if(plane < sphere) {\n        return PrimitiveDist(plane, PLANE);\n    } else {   \n    \treturn PrimitiveDist(sphere, SPHERE);\n    }\n}\n\n// TODO [Task 4] Calculate surface normals\nconst float epsilon = 0.001;\nvec2 e = vec2(epsilon, 0.0); // For swizzling\nvec3 calcNormal(vec3 p) {\n    vec3 norm = vec3(0.0);\n    norm.x = map(p + e.xyy).dist - map(p - e.xyy).dist;\n    norm.y = map(p + e.yxy).dist - map(p - e.yxy).dist;\n    norm.z = map(p + e.yyx).dist - map(p - e.yyx).dist;\n    norm = normalize(norm);\n    return norm;\n    //return normalize(vec3(0.5));\n}\n\nfloat shadow(vec3 ro, vec3 rd, float k) {\n    float marchDist = 0.001;\n    float boundingVolume = 25.0;\n    float darkness = 1.0;\n    float threshold = 0.001;\n    \n    for(int i = 0; i < 30; i++) {\n        if(marchDist > boundingVolume) continue;\n        float h = map(ro + rd * marchDist).dist;\n        // TODO [Task 7] Modify the loop to implement soft shadows\n        if (h < threshold) {\n            darkness = min(darkness, k * h / marchDist);\n            break;\n        }\n        marchDist += h * 0.7;\n    }\n    \n    return darkness;\n}\n\n\nPrimitiveDist raymarch(vec3 ro, vec3 rd) {\n    \n    // TODO [Task 2] Implement ray marching algorithm\n    // Fill in parameters\n    float marchDist = 0.001;\n    float boundingDist = 50.0;\n    float threshold = 0.001;\n    \n    // Fill in the iteration count\n    for (int i = 0; i < 1000; i++) {\n        // Fill in loop body\n        vec3 position = ro + rd * marchDist;\n        PrimitiveDist d = map(position);\n        marchDist = marchDist + d.dist * 0.1;\n        if(d.dist < threshold) {\n            return PrimitiveDist(marchDist, d.primitive);\n        } \n        if(marchDist > boundingDist) {\n            return PrimitiveDist(-1.0, NO_INTERSECT);\n        }\n        \n    }\n    \n    return PrimitiveDist(-1.0, NO_INTERSECT);\n}\n\nvec3 render(vec3 ro, vec3 rd, float t, int which) {\n    \n    // Col is the final color of the current pixel.\n    vec3 col = vec3(0.);\n    vec3 pos = ro + rd * t;\n    // Light vector\n    vec3 lig = normalize(vec3(1.0,0.6,0.5));\n    \n    // Normal vector\n    vec3 nor = calcNormal(pos);\n    \n    // Ambient\n    float ambient = 0.1;\n    // Diffuse\n    float diffuse = clamp(dot(nor, lig), 0.0, 1.0);\n    // Specular\n    float shineness = 32.0; \n    float specular = pow(clamp(dot(rd, reflect(lig, nor)), 0.0, 1.0), 32.0);\n    \n    float darkness = shadow(pos, lig, 18.0);\n    // Applying the phong lighting model to the pixel.\n    col += vec3(((ambient + diffuse + specular) * darkness));\n    \n    // TODO [Task 5] Assign different intersected objects with different materials\n    // Make things pretty!\n    vec3 material = vec3(0.0);\n    if (which == PLANE) {\n        material = texCube(iChannel0, pos, nor);\n    } else if (which == SPHERE) {\n        material = texCube(iChannel1, pos, nor);\n    } else {\n        material = vec3(0.5);\n    }\n    \n    // Blend the material color with the original color.\n    col = mix(col, material, 0.4);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n   \n    vec3 rayOrigin = vec3(6.0 * sin(iTime * .3), 4.8, 6.0 * cos(iTime * .3));\n    \n    float focalLength = 2.0;\n    \n    // The target we are looking at\n    vec3 target = vec3(0.0);\n    // Look vector\n    vec3 look = normalize(rayOrigin - target);\n    // Up vector\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // Set up camera matrix\n    vec3 cameraForward = -look;\n    vec3 cameraRight = normalize(cross(cameraForward, up));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraForward)); \n  \n    // TODO [Task 1] Construct the ray direction vector\n    vec2 uv = vec2(0.0);\n    // fragCoord and screen resolution\n    uv = vec2(2.0 * (fragCoord.x / iResolution.x) - 1.0,\n              2.0 * (fragCoord.y / iResolution.y) - 1.0);\n    //Scale uv.x by screenwidth/screenheight to preserve correct display ratio\n    uv.x = uv.x * iResolution.x/iResolution.y; \n \t//Modify rayDirection to contain uv as the xy coordinates, and focalLength as the z\n    vec3 rayDirection = vec3(0.0);\n    rayDirection.x = uv.x;\n    rayDirection.y = uv.y;\n    rayDirection.z = focalLength;\n    rayDirection = rayDirection.x * cameraRight + rayDirection.y * cameraUp + rayDirection.z * cameraForward;\n    rayDirection = normalize(rayDirection);  \n    \n    PrimitiveDist rayMarchResult = raymarch(rayOrigin, rayDirection);\n    vec3 col = vec3(0.0);\n    if (rayMarchResult.primitive != NO_INTERSECT) {\n      col = render(rayOrigin, rayDirection, rayMarchResult.dist, rayMarchResult.primitive);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsBzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[234, 263, 286, 286, 314], [316, 383, 405, 405, 524], [526, 647, 682, 682, 715], [717, 887, 940, 940, 1332], [1334, 1376, 1407, 1407, 1584], [1586, 1586, 1609, 1609, 1627], [1629, 1629, 1656, 1700, 1930], [2033, 2050, 2075, 2075, 2352], [2354, 2354, 2395, 2395, 2895], [2898, 2898, 2940, 3025, 3625], [3627, 3627, 3678, 3735, 4785], [4787, 4787, 4842, 4842, 6358]], "test": "untested"}
{"id": "XtsfRB", "name": "MacSlow's 1st 3D-truchet attempt", "author": "MacSlow", "description": "The first raymarching-demo I saw years ago was probably a variation of such a truchet-structure. It fascinated me back then and still does now! At least today I'm able to replicate it myself... mostly. Still, I had to peek in one of Shane's examples.", "tags": ["3d", "raymarching", "phong", "shadow", "spheretracing", "truchet", "blinn", "fresnel"], "likes": 12, "viewed": 591, "published": "Public API", "date": "1512357745", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// raymarched 3D-truchet structure \n//\n// Copyright 2017 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// Just for the record... standing on the shoulder of giants like iq, Shane et al\n// of course. For a first attempt ok-ish.\n//\n// Wanted to toss it into the public in the current form, hoping I can get some\n// feedback from more experienced folks here. Thanks in advance!\n//\n// Interaction: LMB-drag controls pitch and yaw of the truchet-structure, when\n// dragged to the right half of the \"screen\" a raymarch-cost (depth) view is\n// displayed\n//\n// Update: Thanks to the input from Shane and Fabrice, I got rid of the artefacts.\n// Renders much cleaner and a bit faster now (even faster in the desktop-GL version).\n// Now stuff like AA and PBR are on my ToDo for this one... and I have to\n// give it my own personal twist to bring something new to the table (to ShaderToy)\n//\n////////////////////////////////////////////////////////////////////////////////\n\nprecision highp float;\n\n#define MAX_ITER 128\n#define STEP_SIZE .95\n#define EPSILON .001\n\nconst vec4 red     = vec4 (1.0, 0.0, 0.0, 1.0);\nconst vec4 green   = vec4 (0.0, 1.0, 0.0, 1.0);\nconst vec4 blue    = vec4 (0.0, 0.0, 1.0, 1.0);\n\nmat3 rotX (in float a) {float c = cos(a); float s = sin (a); return mat3 (vec3 (1., .0, .0), vec3 (.0, c, s), vec3 (.0, -s, c));}\nmat3 rotY (in float a) {float c = cos(a); float s = sin (a); return mat3 (vec3 (c, .0, s), vec3 (.0, 1., .0), vec3 (-s, .0, c));}\nmat3 rotZ (in float a) {float c = cos(a); float s = sin (a); return mat3 (vec3 (c, s, .0), vec3 (-s, c, .0), vec3 (.0, .0, 1.));}\nmat2 rot2d (in float a) { float c = cos (a); float s = sin (a); return mat2 (vec2 (c, s), vec2 (-s, c)); }\n\nvec4 gradient (float v) {\n    float steps = 2.;\n    float step = 1. / steps;\n    vec4 col = green;\n\n    if (v >= .0 && v < step) {\n        col = mix (green, blue, v * steps);\n    } else if (v >= step && v < 2.0 * step) {\n        col = mix (blue, red, (v - step) * steps);\n    }\n    \n    return col;\n}\n\n// basic sdf toolbox\nvec3 opRepeat (in vec3 p, in vec3 size) {return mod (p, 2. * size) - size;}\nfloat sdTorus (in vec3 p, in vec2 t) { vec2 q = vec2 (length (p.xz) - t.x, p.y); return length (q) - t.y; }\n\n// one single truchet-cell with the three tori\n// t.x -> torus radius\n// t.y -> torus \"thickness\"\n// t.z -> the offset by which the torus should be moved from the center\nfloat sdTruchet (in vec3 p, in vec3 t)\n{\n    float offset = t.z;\n    vec3 p1 = vec3 (p - vec3 (offset, offset, .0)) * rotX (radians (90.));\n    vec3 p2 = vec3 (p - vec3 (.0, -offset, offset)) * rotZ (radians (90.));\n    vec3 p3 = vec3 (p - vec3 (-offset, .0, -offset)) * rotY (radians (90.));\n    \n    float t1 = sdTorus (p1, t.xy);\n    float t2 = sdTorus (p2, t.xy);\n    float t3 = sdTorus (p3, t.xy);\n\n    return min (t1, min (t2, t3));\n}\n\nfloat scene (in vec3 p)\n{\n    vec2 mouse = iMouse.xy;\n    if (iMouse.xy == vec2(.0)) mouse.xy = vec2 (212., 192.);\n    mat3 rot = rotX (radians (180. + mouse.y / iResolution.y * 360.)) * rotY (radians (-180. + mouse.x / iResolution.x * 360.));\n\tp *= rot;\n\n    // \"move the camera\" (actually, we're moving space)\n    p.x -= iTime * .3;\n\n    vec3 cellParam = vec3 (.5, .07 + .04 * (.5 + .5 * cos (3.*iTime)), .5);\n\n    // these random functionsand the used values are still major WTF's for me\n    float selector = fract(sin(dot(floor(p) + 13.37, vec3(7., 157., 113.)))*43758.5453);\n\n    // I _hate_ myself for having to peek into one of Shane's truchet-examples for getting a\n    // clue about the cell-rotation and not coming up with coordinate-swiveling... it's so\n    // simple and obvious... argl!\n    if (selector > .75) {\n        p = p;\n    } else if (selector > .5) {\n    \tp = p.yzx;\n    } else if (selector > .25) {\n\t    p = p.zxy;\n    }\n\n    float d = sdTruchet (opRepeat (p, vec3 (.5)), cellParam);\n\n\treturn d;\n}\n\nfloat raymarch (in vec3 ro, in vec3 rd, out int iter)\n{\n    float t = .0;\n\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        iter = i;\n        vec3 p = ro + t * rd;\n        float d = scene (p);\n        if (abs (d) < EPSILON * (1. + .125*d)) break;\n        t += d * STEP_SIZE;\n    }\n\n    return t;\n}\n\nvec3 normal (in vec3 p)\n{\n    vec3 e = vec3(.0001, .0, .0);\n    float d = scene (p);\n    vec3 n = vec3 (scene (p + e.xyy) - d, scene (p + e.yxy) - d, scene (p + e.yyx) - d);\n    return normalize(n);\n}\n\nfloat shadow (in vec3 p, in vec3 n, in vec3 lPos)\n{\n    float distanceToLight = distance (p, lPos);\n    int ignored = 0;\n    float distanceToObject = raymarch (p + .01*n, normalize (lPos - p), ignored);\n    bool isShadowed = distanceToObject < distanceToLight;\n    return isShadowed ? .1 : 1.;\n}\n\n// blinn-phong shading... as much as I can remember it\nvec3 shade (in vec3 ro, in vec3 rd, in float d)\n{\n    vec3 p = ro + d * rd;\n\n    vec3 ambColor = vec3 (.1, .05, .05);\n    vec3 diffColor = vec3 (1.9, 1.4, 1.2);\n    vec3 specColor = vec3 (.95, .85, .85);\n    float shininess = 120.;\n\n    vec3 lightPos = ro + vec3 (cos (iTime) * .5, .5, sin (iTime) * .5);\n    vec3 lightDir = lightPos - p;\n    vec3 lightNDir = normalize (lightDir);\n    vec3 nor = normal (p);\n    vec3 h = normalize (lightDir - rd);\n\n    float diffuse = max (dot (lightNDir, nor), .0);\n    float specular = pow (max (dot (h, nor), .0), shininess);\n\n    float sha = shadow (p, nor, lightPos);\n    float distanceToLight = distance (p, lightPos);\n    float attenuation = 1. / (distanceToLight*distanceToLight);\n\n    vec3 specTerm = ((sha > .1) ? attenuation * specular * specColor : vec3 (.0));\n    return ambColor + sha * attenuation * diffuse * diffColor + specTerm;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    // normalizing and aspect-correction\n\tvec2 uvRaw = fragCoord.xy / iResolution.xy;\n\tvec2 uv = uvRaw;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // create origin and view-ray\n    vec3 ro = vec3 (.0, .0, -.75);\n    vec3 rd = normalize (vec3 (uv, 1.) - ro);\n\n    // \"shake the camera\" around a bit\n    rd.xy *= rot2d (cos (iTime) * .075);\n    rd.xz *= rot2d (sin (iTime) * .15);\n\n    // do the ray-march...\n    int iter = 0;\n    float d = raymarch (ro, rd, iter);\n    float depth = float (iter) / float (MAX_ITER);\n    vec3 cc = gradient (depth).rgb;\n    float fog = 1. / (1. + d * d * .1);\n    vec3 c = shade (ro, rd, d);\n\n    // secondary/1st reflection-ray\n    vec3 p = ro + d*rd;\n    vec3 n = normal (p);\n    vec3 refl = normalize (reflect (rd, n));\n    float refd = raymarch (p + .01*n, refl, iter);\n    vec3 refp = p + refd*refl;\n    vec3 refcol = shade (p, refl, refd);\n\n    // restricting (fresnel) reflections to grazing view-angles\n\tfloat fakeFresnel = pow (1. - max (dot (n, -rd), .0), 1.25);\n    vec3 lPos = ro + vec3 (cos (iTime) * .5, .5, sin (iTime) * .5);\n    float lDist = distance (lPos, p);\n    float attenuation = 1. / (lDist*lDist);\n    c += fakeFresnel*attenuation*.125*refcol;\n\n    // fog, tonemapping, \"gamma-correction\", tint, vignette\n    c *= fog;\n\tc = c / (1. + c);\n    c = .2 * c + .8 * sqrt (c);\n    c *= vec3 (.9, .8, .7);\n    c *= .2 + .8 * pow (16. * uvRaw.x * uvRaw.y * (1. - uvRaw.x) * (1. - uvRaw.y), .3);\n\n    if (iMouse.x / iResolution.x < .5) {\n\t\tfragColor = vec4(c, 1.);\n    } else {\n\t\tfragColor = vec4(cc, 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsfRB.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[916, 2093, 2117, 2117, 2222], [2223, 2223, 2247, 2247, 2352], [2353, 2353, 2377, 2377, 2482], [2483, 2483, 2508, 2508, 2589], [2591, 2591, 2616, 2616, 2891], [2893, 2914, 2955, 2955, 2989], [2990, 2990, 3028, 3028, 3097], [3099, 3269, 3309, 3309, 3709], [3711, 3711, 3736, 3736, 4731], [4733, 4733, 4788, 4788, 5034], [5036, 5036, 5061, 5061, 5236], [5238, 5238, 5289, 5289, 5533], [5535, 5590, 5639, 5639, 6473], [6475, 6475, 6531, 6572, 8119]], "test": "untested"}
{"id": "XtsfRf", "name": "Final Exam", "author": "LCVillafania23", "description": "8 Patterns", "tags": ["submission"], "likes": 0, "viewed": 64, "published": "Public", "date": "1512726808", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pattern 6\n#define PI 3.141\n\nfloat random(in vec2 uv) {\n    return fract(sin(dot(uv.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat randomStars(in vec2 uv) {\n    return fract(sin(dot(uv.xy, vec2(2.0, 30.0))) * 9999999999.0);\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Gradient noise\nvec2 hash( vec2 x ){\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p ){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 8\nfloat fbm (in vec2 uv) {\n    // Initial values\n    float value = 0.0;\n    float amplitud = .5;\n    float frequency = 0.;\n    \n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitud * noise(uv);\n        uv *= 2.;\n        amplitud *= .5;\n    }\n    return value;\n}\n\nmat2 rotate2D(float angle) {\n\treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle));  \n    \n\t//return mat2(-sin(angle), cos(angle), -cos(angle), -sin(angle)); \n}\n\nmat2 scale2D(vec2 value) {\n    return mat2(value.x, 0.0, 0.0, value.y);\n}\n\nvec3 drawRectangle(vec2 uv, vec2 pos, float l, float w, float offset, vec3 color) {\n    float value = step(pos.x, uv.x) - step(pos.x + l, uv.x);\n    \n    value *= step(pos.y, uv.y + offset) - step(pos.y + w, uv.y + offset);\n    \n    vec3 finalColor = mix(vec3(0.0), color, value);\n    \n    return finalColor;\n}\n\nvec3 drawRothko(vec2 uv, vec2 pos, float l, float w, vec3 color) {\n    float value = smoothstep(pos.x + 0.2, pos.x, uv.x) - smoothstep(pos.x + l, pos.x + l - 0.2, uv.x);\n    \n    value *= smoothstep(pos.y + 0.2, pos.y, uv.y) - smoothstep(pos.y + w, pos.y + w - 0.2, uv.y);\n    \n    vec3 finalColor = mix(vec3(0.0), color, value);\n    finalColor *= random(uv);\n    \n    return finalColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n    if (pattern == 1) {\n\t\tuv *= 10.0;\n    \n    \tfloat offset = step(1.0, mod(uv.y, 2.0));\n    \tuv.x += offset * iTime;\n\t\tuv.x -= (1.0 - offset) * iTime;\n    \n    \toffset = step(1.0, mod(uv.x, 2.0));\n    \tuv.y += offset * iTime;\n    \tuv.y -= (1.0 - offset) * iTime;\n             \t\n        uv = fract(uv);\n        \n\t\tvec3 red = vec3(1.0, 0.3, 0.3);\n\t\tvec3 blue = vec3(0.3, 0.3, 1.0);\n        \n\t\tfloat offset1 = 0.9 * sin(iTime) * sin(iTime);\n        float offset2 = -0.9 * sin(iTime) * sin(iTime);\n        \n        vec3 finalColor = drawRectangle(uv, vec2(0.0, 0.0), 0.5, 1.0, offset1, red);\n        finalColor += drawRectangle(uv, vec2(0.5, 0.0), 0.5, 1.0, offset2, blue);\n        \n        fragColor = vec4(finalColor, 1.0);\n    }\n    \n    else if (pattern == 2) {\n        float zoom = 4.0;\n   \t\tfloat offset = gnoise(uv * zoom + iTime);\n    \tfloat value = smoothstep(0.0 - offset, 0.5 - offset, uv.x) - smoothstep(0.6 - offset, 1.0 - offset, uv.x);\n        \n\t\tvec3 magma = vec3(5.0, 0.9, 0.0);\n    \tvec3 finalColor = value * magma;\n    \t\n\t\tfragColor = vec4(finalColor, 1.0);\n    }\n    \n    else if (pattern == 3) {    \n        vec3 blue = vec3(0.3, 0.8, 1.0);\n        vec3 yellow = vec3(1.0, 0.7, 0.3);\n        vec3 red = vec3(1.0, 0.3, 0.2);\n        \n        vec3 finalColor = drawRothko(uv, vec2(-0.025, 0.0), 0.35, 1.0, blue);\n        finalColor += drawRothko(uv, vec2(0.2, -0.1), 0.35, 1.2, yellow);\n        finalColor += drawRothko(uv, vec2(0.425, -0.05), 0.6, 1.1, red);\n        \n        fragColor = vec4(finalColor, 1.0);\n    }\n    \n    else if (pattern == 4) {\n    \tvec3 white = vec3(1.0, 1.0, 1.0);\n        vec3 blue = vec3(0.3, 0.5, 1.0);\n        \n   \t\tfloat offset = gnoise(uv + iTime / 6.0);\n        \n        vec3 clouds = vec3(fbm((uv) * 5.0)) * 0.3;\n    \tvec3 finalColor = mix(blue, white, smoothstep(0.0 - offset, 0.4 - offset, clouds) - smoothstep(0.5 - offset, 0.7 - offset, clouds));\n\t\tfragColor = vec4(finalColor, 1.0);\n    }\n    \n    else if (pattern == 5) {\n\t\tuv *= 5.05;\n    \tuv = fract(uv);\n        \n        vec3 colorA = vec3(0.2, 0.1, 0.9);\n        vec3 colorB = vec3(0.1, 0.4, 0.6);\n        vec3 colorC = vec3(0.5, 0.0, 0.0);\n        vec3 colorD = vec3(1.0, 1.0, 1.0);\n        \n        vec3 finalColor = drawRectangle(uv, vec2(0.0, 0.0), 0.05, 1.0, 0.0, colorC);\n        finalColor += drawRectangle(uv, vec2(0.1, 0.0), 0.45, 0.925, 0.0, colorB);\n        finalColor += drawRectangle(uv, vec2(0.55, 0.0), 0.4, 0.925, 0.0, colorB);\n        finalColor += drawRectangle(uv, vec2(0.05, 0.0), 0.9, 0.45, 0.0, colorC);\n        finalColor += drawRectangle(uv, vec2(0.05, 0.0), 0.05, 1.0, 0.0, colorD);\n        finalColor += drawRectangle(uv, vec2(0.95, 0.0), 0.05, 1.0, 0.0, colorD);\n        finalColor += drawRectangle(uv, vec2(0.05, 0.95), 1.0, 0.05, 0.0, colorD);\n        finalColor += drawRectangle(uv, vec2(0.05, 0.0), 0.05, 1.0, 0.0, colorD);\n        finalColor += drawRectangle(uv, vec2(0.5, 0.0), 0.05, 1.0, 0.0, colorB);\n        \n        finalColor *= random(uv);\n        fragColor = vec4(finalColor,1.0);\n    }\n    \n    else if (pattern == 6) {\n        uv *= rotate2D(60.0 * PI / 180.0);\n        \n        float zoom = 2.0;\n   \t\tfloat offset = noise(uv * zoom - iTime);\n        \n        float stars = randomStars(uv * iTime);\n    \tfloat outer = smoothstep(0.0 - offset, 0.3 - offset, uv.x) - smoothstep(0.5 - offset, 0.7 - offset, uv.x);\n        float inner = smoothstep(0.3 - offset, 0.4 - offset, uv.x) - smoothstep(0.7 - offset, 1.0 - offset, uv.x);\n\t\tfloat overlap = smoothstep(0.45 - offset, 0.7 - offset, uv.x) - smoothstep(0.8 - offset, 0.9 - offset, uv.x); \n        \n        vec3 blue = vec3(0.0, 0.0, 0.175);\n        vec3 purple = vec3(0.7, 0.4, 0.6);\n        vec3 green = vec3(0.4, 1.0, 0.7);\n        vec3 white = vec3(0.9, 1.0, 0.9);\n        \n        vec3 starColor = mix(blue, white, stars);\n    \tvec3 outerColor = mix(starColor, purple, outer);\n        vec3 innerColor = mix(outerColor, green, inner);\n        vec3 overlapColor = mix(innerColor, white, overlap);\n    \t\n\t\tfragColor = vec4(overlapColor, 1.0);\n    }\n    \n    else if (pattern == 7) {\n        vec2 shapePos = vec2(0.5, -sin(iTime * 0.5) * 0.6);    \n    \tfloat dist = distance(shapePos, uv);\n    \n    \tuv -= shapePos;\n    \n    \tfloat angle = atan(uv.x, uv.y);\n    \n    \tfloat radius = sin((angle - iTime / 2.0) * 8.0);\n    \tradius += sin((angle - iTime / 4.0) * 48.0);\n    \tradius += sin((angle - iTime / 8.0) * 128.0);\n    \n    \tradius *= 0.1;\n                              \n    \tfloat sunRays = smoothstep(dist - 0.2, dist, radius) + smoothstep(dist - 0.7, dist + 0.7, 0.2);\n                \n   \t\tfloat offset = gnoise(uv + iTime / 2.0);\n        vec3 clouds = vec3(fbm((uv) * 5.0)) * 0.3;\n        \n        vec3 blue = vec3(-sin(iTime * 0.5) / 1.5, -sin(iTime * 0.5) / 1.5, -sin(iTime * 0.5) + 1.0);\n        vec3 yellow = vec3 (sin(iTime / 2.0) + 1.9, 0.9, 0.2);\n        vec3 white = vec3(1.0, 1.0, 1.0);\n        \n        vec3 sunColor = mix(blue, yellow, sunRays);\n    \tvec3 sky = mix(sunColor, white, smoothstep(0.0 - offset, 0.4 - offset, clouds) - smoothstep(0.5 - offset, 0.7 - offset, clouds));\n\t\t  \t     \n    \tfragColor = vec4(sky, 1.0);\n    }\n    \n    else if (pattern == 8) {\n    \tuv.x *= ratio;\n    \n    \tvec2 shapePos = vec2(0.5f * ratio, 0.5f);\n    \tfloat dist = distance(shapePos, uv);\n        \n    \tuv -=shapePos;\n    \n    \tfloat angle = atan(uv.y, uv.x);\n    \n    \tfloat radius = sin((angle + gnoise(uv * 300.0 - iTime)) * 6.0);\n    \tradius += cos(angle + gnoise(uv * 5.0 - iTime) * 12.0f) * 0.5;\n    \tradius += sin((angle + gnoise(uv * 5.0 - iTime)) * 12.0);\n    \tradius += sin((angle + gnoise(uv * 50.0 - iTime)) * 64.0);\n    \tradius *= 0.1f;\n                              \n    \tfloat value = smoothstep(dist - 0.2, dist, radius);\n    \n    \tvec3 finalColor = vec3(1.0) * value;\n    \n    \tfragColor = vec4(finalColor, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsfRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 62, 62, 137], [139, 139, 170, 170, 239], [241, 256, 281, 281, 800], [802, 820, 840, 840, 978], [980, 980, 1006, 1006, 1404], [1406, 1423, 1444, 1444, 1491], [1492, 1492, 1513, 1513, 1560], [1561, 1561, 1583, 1583, 1618], [1620, 1620, 1642, 1642, 2690], [2710, 2710, 2734, 2756, 3005], [3007, 3007, 3035, 3035, 3175], [3177, 3177, 3203, 3203, 3250], [3252, 3252, 3335, 3335, 3562], [3564, 3564, 3630, 3630, 3953], [3955, 3955, 4010, 4010, 9956]], "test": "untested"}
{"id": "XtsfRs", "name": "InfinityParticles", "author": "nmacholl", "description": "An infinity symbol made using two particle trails.", "tags": ["beginner", "particles"], "likes": 4, "viewed": 681, "published": "Public API", "date": "1512973373", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nInfinity graph using particles. Bezier curves might be more performant?\nBonus is that it is easy to change the shape.\n*/\n\nvec2 dotCoordinates (float radius, vec2 offset, float t)\n{\n\tvec2 pos;\n    pos.x = offset.x + radius*cos(t);\n    pos.y = offset.y + radius*sin(t)*cos(t);\n    return pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(0, 0, 0, 1.0); // Initialize Black.\n    \n    int tailLength = 250; // Number of tail particles.\n    float particleSize = 0.025; // Radius of the particles.\n    \n    for (int h = tailLength; h > 0; h--)\n    {\n        vec2 rightDot = dotCoordinates(0.45, vec2(0.5, 0.5), iTime - (0.02 * float(h)));\n        vec2 leftDot = dotCoordinates(-0.45, vec2(0.5, 0.5), iTime - (0.02 * float(h))); \n        float d = distance(leftDot, uv);\n        if (d < particleSize)\n        {\n            fragColor = vec4(uv.x, uv.y, 0.8 + 0.2*sin(iTime), 1.0) - float(h)/float(tailLength);   \n        }\n        d = distance(rightDot, uv);\n        if (d < particleSize)\n        {\n            fragColor = vec4(uv.x, uv.y, 0.8 + 0.2*sin(iTime), 1.0) - float(h)/float(tailLength);   \n        }\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsfRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 125, 183, 183, 295], [297, 297, 354, 354, 1194]], "test": "untested"}
{"id": "XtsfWX", "name": "Angle Grinder", "author": "shau", "description": "Another Beeple inspired Tunnel ", "tags": ["3d"], "likes": 18, "viewed": 525, "published": "Public", "date": "1513809785", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by SHAU - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define T iTime * 2.0\n#define PI 3.14159265359\n#define FAR 140.0 \n#define EPS 0.003\n#define PLATFORM 1.0\n#define WALL 2.0\n#define BOLLARD_LIGHT 3.0\n#define RAIL_LIGHT 4.0\n#define PANEL 5.0\n\nvec3 lp = vec3(4.0, 5.0, -2.0);\nvec3 glowc = vec3(0.0, 0.0, 0.0);\nvec3 ball = vec3(0.0, 0.0, 0.0);\n\nfloat rand(vec2 p) {return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);}\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n\n//IQ SDF \n//IQ - Sphere functions\n//http://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    return -b - h;\n}\n\nfloat sphDensity(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer / sph.w;\n    vec3  rc = (ro - sph.xyz) / sph.w;\n\t\n    float b = dot(rd, rc);\n    float c = dot(rc, rc) - 1.0;\n    float h = b*b - c;\n    if (h < 0.0) return 0.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if (t2 < 0.0 || t1 > ndbuffer) return 0.0;\n    t1 = max(t1, 0.0);\n    t2 = min(t2, ndbuffer);\n\n    float i1 = -(c * t1 + b * t1 * t1 + t1 * t1 * t1 / 3.0);\n    float i2 = -(c * t2 + b * t2 * t2 + t2 * t2 * t2 / 3.0);\n    return (i2 - i1) * (3.0 / 4.0);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n//mercury\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat boxSection(vec3 rp, float width) {\n    rp.z = mod(rp.z, 4.0) - 2.0;\n    float ns = sdBox(rp - vec3(0.0, 0.4, 0.0), vec3(width, 0.1, 2.0));\n    ns = min(ns, sdBox(rp - vec3(0.0, -0.4, 0.0), vec3(width, 0.1, 2.0)));\n    ns = min(ns, sdBox(rp - vec3(0.0, 0.0, 1.9), vec3(width, 0.4, 0.1)));\n    rp.yz *= rot(0.2);\n    return min(ns, sdBox(rp - vec3(0.0, 0.0, 0.0), vec3(width, 0.1, 2.0)));\n}\n\n//neat trick from Shane\nvec2 nearest(vec2 a, vec2 b){ \n    float s = step(a.x, b.x);\n    return s * a + (1. - s) * b;\n}\n\nvec4 map(vec3 rp) {    \n    vec3 q = rp;\n    float wall = 14.0 - abs(q.x);\n    wall = min(wall, 12.0 - abs(q.y));\n    wall = max(wall, min(2.0 - q.y, -(1.5 - q.y)));\n    wall = max(wall, min(-1.5 - q.y, -(-2.0 - q.y)));    \n    float raillight = length(abs(q.xy) - vec2(15.0, 1.75)) - 0.2;\n    float panel = 10.0 - abs(q.x);\n    panel = max(panel, abs(q.y) - 0.8);\n    \n    float bd = mod(q.z, 160.0) - 80.0 > 0.0 ? 1.0 : -1.0;\n    q.z = mod(q.z, 80.0) - 40.0;\n    q.xz *= rot(0.2 * bd);\n    float platform = boxSection(q.zyx - vec3(0.0, 3.0, 0.0), 1.0);\n    platform = min(platform, boxSection(q.zyx - vec3(30.0, -3.0, 0.0), 1.0));\n    q = rp;\n    bd = mod(q.z, 200.0) - 100.0 > 0.0 ? 1.0 : -1.0;\n    q.z = mod(q.z, 100.0) - 50.0;\n    q.xz *= rot(0.2 * bd);\n    platform = min(platform, boxSection(q.zyx - vec3(0.0, 8.0, 0.0), 1.0));\n    platform = min(platform, boxSection(q.zyx - vec3(20.0, -8.0, 0.0), 1.0));\n    q = rp;\n    q.xy = abs(q.xy);\n    platform = min(platform, boxSection(q - vec3(6.0, 3.0, 0.0), 2.0));\n    platform = min(platform, boxSection(q - vec3(10.5, 3.0, 0.0), 2.0));\n    q = rp;\n    q.z = mod(q.z, 20.0) - 10.0;\n    q.x = abs(q.x);\n    float bollard = fCylinder(q - vec3(6.0, -2.0, 0.0), 0.5, 0.4); \n    //bollard = min(bollard, fCylinder(q - vec3(6.0, -1.4, 0.0), 0.5, 0.05)); \n    float bollardlight = fCylinder(q - vec3(6.0, -1.5, 0.0), 0.55, 0.05); \n    \n    vec2 near = nearest(vec2(platform, PLATFORM), vec2(wall, WALL));\n    near = nearest(near, vec2(raillight, RAIL_LIGHT));\n    near = nearest(near, vec2(bollard, PLATFORM));\n    near = nearest(near, vec2(bollardlight, BOLLARD_LIGHT));\n    near = nearest(near, vec2(panel, PANEL));\n\n    return vec4(near, raillight, bollardlight);\n}\n\nstruct Scene {\n    float t;\n    float id;\n    float rli; //rail light\n    float bollli; //bollard light\n    float glli; //glow light     \n};\n\nScene march(vec3 ro, vec3 rd) {\n \n    float t = 0.0;\n    float id = 0.0;\n    float rli = 0.0;\n    float bollli = 0.0;\n    float glli = 0.0;\n    \n    for (int i = 0; i < 96; i++) {\n        vec3 rp = ro + rd * t;\n        vec4 scene = map(rp);\n        if (scene.x < EPS || t > FAR) {\n            id = scene.y;\n            break;\n        }\n        \n        rli += 0.05 / (1.0 + scene.z * scene.z * 50.);\n        bollli += 0.1 / (1.0 + scene.w * scene.w * scene.w * 400.);\n        vec3 q = rp;\n        q.xy = abs(q.xy);\n        float blt1 = length(ball - q);\n        glli += 0.2 / (1.0 + blt1 * blt1 * 10.) * 16.0; \n        \n        t += scene.x;            \n    }\n    \n    return Scene(t, id, rli, bollli, glli);\n}\n\nvec3 normal(vec3 rp) {\n    vec2 e = vec2(EPS, 0);\n    float d1 = map(rp + e.xyy).x, d2 = map(rp - e.xyy).x;\n    float d3 = map(rp + e.yxy).x, d4 = map(rp - e.yxy).x;\n    float d5 = map(rp + e.yyx).x, d6 = map(rp - e.yyx).x;\n    float d = map(rp).x * 2.0;\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\nvec2 glyphpanel(vec2 uv) {\n    uv.y -= 0.5;\n    vec2 cuv = uv * 4.0 - 2.0;\n    vec2 cmx = mod(cuv, 1.0) - 0.5;\n    float lc = length(cmx);\n    float glyph = smoothstep(0.4, 0.3, lc); \n    float glyphc = smoothstep(0.3, 0.03, lc); \n    glyph *= step(-6.0, cuv.y);\n    glyphc *= step(-6.0, cuv.y);\n    glyph *= step(cuv.y, -2.0);\n    glyphc *= step(cuv.y, -2.0);\n    float r1 = rand(floor(vec2(cuv.x + floor(T * 1.0), cuv.y))) > 0.5 ? 1.0 : 0.0;\n    glyph *= step(cuv.y, -1.0) * step(-8.0, cuv.y) * r1;\n    glyphc *= step(cuv.y, -1.0) * step(-8.0, cuv.y) * r1;\n    float gy = mod(cuv.x + floor(T * 1.0), 15.0);\n    glyph *= step(1.0, gy) * step(gy, 7.0) + step(9.0, gy) * step(gy, 14.0);\n    glyphc *= step(1.0, gy) * step(gy, 7.0) + step(9.0, gy) * step(gy, 14.0);\n    return vec2(glyph, glyphc);\n}\n\n//IQ\n//http://www.iquilezles.org/www/articles/fog/fog.htm\nvec3 applyFog(vec3  rgb,      // original color of the pixel\n              float d, // camera to point distance\n              vec3  rayDir,   // camera to point vector\n              vec3  sunDir,\n              float b)  // sun light direction\n{\n    float fogAmount = 1.0 - exp(-d * b);\n    float sunAmount = max(dot(rayDir, sunDir), 0.0);\n    vec3  fogColor  = mix(vec3(0.5, 0.3, 0.8), // purple\n                          vec3(0.7, 0.7, 1.0), // blue\n                          pow(sunAmount, 16.0));\n    return mix(rgb, fogColor, fogAmount);\n}\n\nfloat shadow(vec3 ro, vec3 lp) {\n\n    vec3 rd = normalize(lp - ro);\n    float shade = 1.0;\n    float t = 0.05;    \n    float end = length(lp - ro);\n    \n    for (int i = 0; i < 20; i++) {\n        float h = map(ro + rd * t).x;\n        shade = min(shade, smoothstep(0.1, 0.5, 2.0 * h / t));\n        t += clamp(h, 0.01, 1.);\n        if (h < EPS || t > end) break; \n    }\n\n    return min(max(shade, 0.) + 0.08, 1.0);\n}\n\nvoid setupCamera(vec2 uv, inout vec3 ro, inout vec3 rd) {\n\n    vec3 lookAt = vec3(0.0, 0.0, T * 12.0);\n    ro = lookAt + vec3(0.0, 0.0, -4.0);\n    lp = lookAt + vec3(0.2, 0.3, 0.1);\n    glowc = lookAt + vec3(0.0, 0.0, 130.0);\n    \n    ball = lookAt + vec3(15.0, 1.75, 20.0 + mod(T * 4.0, 200.0) - 100.0);\n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec3 pc = vec3(0.0);\n    float mint = FAR;\n    float sh = 1.0;\n        \n    vec3 ro, rd;\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    setupCamera(uv, ro, rd);\n    \n    Scene scene = march(ro, rd);\n    if (scene.t > 0.0 && scene.t < FAR) {\n        \n        mint = scene.t;\n        vec3 rp = ro + rd * scene.t;\n        vec3 n = normal(rp);\n        vec3 cld = normalize(lp - rp); //camera light direction\n        float clt = length(lp - rp); //camera light distance\n        vec3 gld = normalize(glowc - rp); //glow light direction\n        float glt = length(glowc - rp);\n        \n        if (scene.id == WALL) {\n            \n        } else if (scene.id == PLATFORM) {\n            \n            float diff = max(dot(cld, n), 0.05);\n            float catten = 1.0 / (1.0 + clt * clt * 0.00005);\n            float gspec = pow(max(dot(reflect(-gld, n), -rd), 0.0), 32.0);\n            float gatten = 1.0 / (1.0 + glt * glt * 0.00005);\n            sh = shadow(ro + rd * (scene.t - EPS), glowc);\n            pc = vec3(0.2) * diff * catten;\n            pc += vec3(0., 0.7, 1.0) * gspec * abs(n.x) * gatten * 2.0;\n            pc *= sh;\n            \n        } else if (scene.id == RAIL_LIGHT) {\n            \n            float diff = max(dot(cld, n), 0.2);            \n            float spec = pow(max(dot(reflect(-gld, n), -rd), 0.0), 32.0);\n            float catten = 1.0 / (1.0 + clt * clt * 0.0005);\n            float la = abs(ball.z - rp.z) * 0.3;\n            la = 1.0 / (1.0 * la * la * 0.1);\n            pc = vec3(0.8, 0.5, 1.0) * clamp(diff * la, 0.0, 2.0);\n            pc += vec3(1.0) * spec * catten;\n\n        } else if (scene.id == BOLLARD_LIGHT) {\n            \n            pc = vec3(0.6, 0.6, 1.1);\n    \n        } else if (scene.id == PANEL) {\n            \n            float diff = max(dot(cld, n), 0.05);\n            float atten = 1.0 / (1.0 + clt * clt * 0.03);\n            vec2 glyph = glyphpanel(rp.zy);\n            pc += vec3(0.8, 0.2, 1.0) * glyph.x * 1.0 * atten;            \n            pc += vec3(0.2, 0.5, 1.0) * glyph.y * 8.0 * atten;            \n        }   \n    } else {\n        float nd = noise(vec3(20.0 * rd.x + 0.8 * T, 100.0 * rd.y + 0.8 * T, 10.0 * rd.z + 0.8 * T));\n        pc = vec3(0.8, 0.5, 1.0) * (1.0 - nd) * .8; //background\n        pc += vec3(0.7, 0.7, 1.0) * smoothstep(0.065, 0.06, length(uv)) * 0.8;\n    }\n    //*/\n    \n    pc += vec3(0.8, 0.5, 1.0) * scene.rli * 0.6;\n    pc += vec3(0.2, 0.7, 1.0) * scene.glli * 0.5;\n    pc += vec3(0.0, 0.7, 1.0) * scene.bollli * sh;\n    \n    float st2 = sphIntersect(ro, rd, vec4(glowc, 130.0));\n    if (st2 > 0.0) {\n        vec3 rp = ro + rd * st2;\n        \n        float h = sphDensity(ro, rd, vec4(glowc, 130.0), mint); \n        if (h > 0.0) {\n            pc += vec3(0.0, 1.0, 1.0) * h * h * 2.0;    \n            pc += vec3(0.4, 1.0, 1.0) * h * h * h * h * 10.0;\n        }\n    }\n    \n    pc = applyFog(pc, mint, rd, normalize(vec3(4.0, 5.0, 2.0)), 0.0008);\n    \n    fragColor = vec4(sqrt(clamp(pc, 0.0, 1.0)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsfWX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 460, 480, 480, 542], [543, 543, 562, 562, 608], [610, 610, 632, 632, 940], [942, 1053, 1101, 1101, 1292], [1294, 1294, 1355, 1355, 1869], [1871, 1871, 1900, 1900, 1995], [1997, 2007, 2055, 2055, 2129], [2131, 2131, 2171, 2171, 2525], [2527, 2551, 2580, 2580, 2646], [2648, 2648, 2667, 2667, 4364], [4508, 4508, 4539, 4539, 5218], [5220, 5220, 5242, 5242, 5531], [5533, 5533, 5559, 5559, 6330], [6332, 6390, 6634, 6634, 6933], [6935, 6935, 6967, 6967, 7349], [7351, 7351, 7408, 7408, 7895], [7897, 7897, 7952, 7952, 10974]], "test": "untested"}
{"id": "XtSfzR", "name": "The china flag", "author": "cailuming", "description": "try square and triangle ,star ", "tags": ["2d"], "likes": 4, "viewed": 128, "published": "Public", "date": "1514222816", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BIAS 1e-15\n#define PI 3.1415926\n\nmat2 rot2D(float a){\n   float c=cos(a);\n   float s=sin(a);\n    return mat2(\n        c,-s,\n        s,c\n   );\n}\nfloat drawSquare(vec2 uv,vec2 c){\n    uv-=c;\n    uv.x*=0.6;\n    float v =max(abs(uv.x),abs(uv.y));\n    v=0.4/v;\n    \n    v=pow(v,50.);\n    return v;\n}\n\nfloat drawCircle(vec2 uv,vec2 c,float r){\n    \n    float arc =atan(uv.y-c.y,uv.x-c.x+BIAS);\n    vec2 sq =vec2(r*cos(arc),r*sin(arc));\n    float v =0.01/length(uv-sq-c);\n    return v;\n} \n\nvec2 drawLine(vec2 uv,vec2 p1,vec2 p2){\n    vec2 pline = p2-p1;\n    vec2 pu = uv-p1;\n    vec2 v = pu -clamp(dot(pline,pu)/dot(pline,pline),0.,1.)*pline;\n    return v;\n}\n\nfloat drawTriangle(vec2 uv,vec2 ct,float r,float a){\n   \n    vec2 v1=drawLine(uv,vec2(ct.x,ct.y+r),vec2(ct.x-r,ct.y-r));\n    vec2 v2=drawLine(uv,vec2(ct.x,ct.y+r),vec2(ct.x+r,ct.y-r));\n    vec2 v3=drawLine(uv,vec2(ct.x-r,ct.y-r),vec2(ct.x+r,ct.y-r));\n    vec2 nv1=normalize(v1);\n    vec2 nv2=normalize(v2);\n    vec2 nv3=normalize(v3);\n    \n    float abias =0.099;\n    float v =min(length(v1)-a,min(length(v2)-a,length(v3)-a));\n    if(dot(nv1,nv2)<=0.&&dot(nv2,nv3)<=0.){\n       v=1.;\n    };\n    v=0.012/abs(v);\n    v=pow(v,2.);\n    return v;\n}\n\nfloat draw5Stars(vec2 uv,vec2 ct,float r,float a){\n    uv-=ct;\n    uv*=rot2D(a);\n    \n    vec2 p1 =vec2(r*cos(PI*0.1),r*sin(PI*0.1));\n    vec2 p2 =vec2(r*cos(PI*0.5),r*sin(PI*0.5));\n    vec2 p3 =vec2(r*cos(PI*0.9),r*sin(PI*0.9));\n    vec2 p4 =vec2(r*cos(PI*1.3),r*sin(PI*1.3));\n    vec2 p5 =vec2(r*cos(PI*1.7),r*sin(PI*1.7));\n   \n    \n    vec2 v1=drawLine(uv,p2,p4);\n    vec2 v2=drawLine(uv,p2,p5);\n    vec2 v3=drawLine(uv,p4,p1);\n    vec2 v4=drawLine(uv,p1,p3);\n    vec2 v5=drawLine(uv,p3,p5);\n    \n    vec2 nv1=normalize(v1);\n    vec2 nv2=normalize(v2);\n    vec2 nv3=normalize(v3);\n    vec2 nv4=normalize(v4);\n    vec2 nv5=normalize(v5);\n    \n    \n    float v =min(length(v1),min(length(v2),min(length(v3),min(length(v4),length(v5)))));\n    v=0.0019/v;\n    v=pow(v,4.);\n    \n    float ref= dot(nv1,nv2)*dot(nv2,nv3)*dot(nv3,nv4)*dot(nv4,nv5)*dot(nv5,nv1);\n       \n    if((dot(nv1,nv2)<=0.\n      &&dot(nv1,nv3)<=0.)\n      ||(dot(nv4,nv5)<=0.\n      &&dot(nv3,nv4)<=0.)\n       ||(dot(nv5,nv2)<=0.\n         &&dot(nv1,nv2)<=0.)\n        \n      ){\n       v=10.;\n    }\n    return v;    \n}  \n\nvec3 drawFlag(vec2 uv,vec2 ct){\n    uv-=ct;\n    uv.y+=0.02*sin(26.*(uv.x*uv.y)+iTime*3.); \n    uv.x+=0.19;\n    vec2 c=vec2(-0.44,0.16);\n    vec2 suv =uv-c+vec2(-0.08,0);\n    float r=0.2;\n    float arc =atan(suv.y,suv.x);\n    float s=0.031;\n    float o =PI*0.2;\n    float v = drawSquare(uv,vec2(0,0));   \n    vec3 col =vec3(v,0,0);\n    \n    \n    v= draw5Stars(uv,c,0.11,0.);\n    v+= draw5Stars(suv,vec2(r*cos(o*1.5),r*sin(o*1.5)),s,-o*1.5);\n    v+= draw5Stars(suv,vec2(r*cos(o*0.5),r*sin(o*0.5)),s,-o*0.9);\n    v+= draw5Stars(suv,vec2(r*cos(-o*0.5),r*sin(-o*0.5)),s,o*0.3);\n    v+= draw5Stars(suv,vec2(r*cos(-o*1.5),r*sin(-o*1.5)),s,o*1.);\n    \n    col+=vec3(v,v,0);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-vec2(0.5);\n    float as = iResolution.x/iResolution.y;\n    uv.x*=as;\n    float arc =atan(uv.y,uv.x);\n    float len = length(uv);\n     \n    float v=0.0;\n   \n    vec3 col =vec3(v)*vec3(0.4*cos(iTime)+0.5,0.3*sin(iTime)+0.6,0.7*cos(iTime)+0.8);\n\t\n    fragColor = vec4(mix(col,drawFlag(uv,vec2(0.15,0.0)),0.5),1.0);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSfzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 61, 61, 150], [151, 151, 184, 184, 301], [303, 303, 344, 344, 487], [490, 490, 529, 529, 658], [660, 660, 712, 712, 1203], [1205, 1205, 1255, 1255, 2287], [2291, 2291, 2322, 2322, 2974], [2976, 2976, 3033, 3033, 3388]], "test": "untested"}
{"id": "XtXBD7", "name": "aurora and sunset", "author": "harrisonvanderbyl", "description": "just thought id share a custom shader i made for a hobby game of mine", "tags": ["sunset", "clouds", "skybox", "aurora"], "likes": 10, "viewed": 601, "published": "Public", "date": "1512112869", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nCLICK AND DRAG TO LOOK AROUND\n\n\n\nSETTINGS ARE BELOW\n\n\n\n\n*/\n\n#define ATMOSPHEREHEIGHT 2400\n#define time -iTime/20.0+0.5\n#define FOV 0.5\n#define AURORORHEIGHT 100.0\n#define AURORORBRIGHTNESS 1.5\n\nvec3 cam = vec3(0,10.0,0);\n\n#define sunpos vec3(0,sin(time),cos(time))\nvec3 CENTER = vec3(0.0,-63710.0,0.0);\nfloat dts( vec3 camm,vec3 poss,vec3 center, float radius,float sig){\nfloat a =\n       pow((dot(normalize(poss-camm),camm-center)),2.0)\n       -pow(length(camm-center),2.0)+pow(radius,2.0);\nif (a<0.0){return -1.0;}\nfloat dd = -(dot(normalize(poss-camm),(camm-center)))\n       +sig*sqrt(a);\n//if (dd < 0.0){return -1.0;}\nreturn dd;\n\n}\n\nfloat random (in vec3 _st) {\n    return fract(sin(dot(_st.xyz,\n                         vec3(12.9898,78.233,82.19)))*\n        43758.5453123);\n}\n\nfloat starnoise (in vec3 _st) {\n    vec3 i = floor(_st);\n    vec3 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float starthreshhold = 0.99;\n    float a = float(random(i)>starthreshhold);\n    float b = float(random(i + vec3(1.0, 0.0,0.0))>starthreshhold);\n    float c = float(random(i + vec3(0.0, 1.0,0.0))>starthreshhold);\n    float d = float(random(i + vec3(1.0, 1.0,0.0))>starthreshhold);\n\n    float e = float(random(i + vec3(0.0, 0.0,1.0))>starthreshhold);\n    float g = float(random(i + vec3(1.0, 0.0,1.0))>starthreshhold);\n    float h = float(random(i + vec3(0.0, 1.0,1.0))>starthreshhold);\n    float j = float(random(i + vec3(1.0, 1.0,1.0))>starthreshhold);\n\n    f = (1.0-cos(f*3.1415))/2.0;\n   // f = 0.5+sign(f-0.5)*0.5*pow(abs(f-0.5)*2.0,vec3(3.0));\n   // float a1 = mix(a, b, u.x) +\n     //       (c - a)* u.y * (1.0 - u.x) +\n     //(d - b) * u.x * u.y;\n     float a1 = mix(a,b,f.x);\n     float a2 = mix(c,d,f.x);\n     float a3 = mix(e,g,f.x);\n     float a4 = mix(h,j,f.x);\n\n     float a5 = mix(a1,a2,f.y);\n     float a6 = mix(a3,a4,f.y);\n\n\n    return mix(a5,a6,f.z);\n}\n\nfloat noise (in vec3 _st) {\n    vec3 i = floor(_st);\n    vec3 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec3(1.0, 0.0,0.0));\n    float c = random(i + vec3(0.0, 1.0,0.0));\n    float d = random(i + vec3(1.0, 1.0,0.0));\n\n    float e = random(i + vec3(0.0, 0.0,1.0));\n    float g = random(i + vec3(1.0, 0.0,1.0));\n    float h = random(i + vec3(0.0, 1.0,1.0));\n    float j = random(i + vec3(1.0, 1.0,1.0));\n\n    f = (1.0-cos(f*3.1415))/2.0;\n   // float a1 = mix(a, b, u.x) +\n     //       (c - a)* u.y * (1.0 - u.x) +\n     //(d - b) * u.x * u.y;\n     float a1 = mix(a,b,f.x);\n     float a2 = mix(c,d,f.x);\n     float a3 = mix(e,g,f.x);\n     float a4 = mix(h,j,f.x);\n\n     float a5 = mix(a1,a2,f.y);\n     float a6 = mix(a3,a4,f.y);\n\n\n    return mix(a5,a6,f.z);\n}\n\nfloat fbm ( in vec3 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100.0,22.5,44.0);\n    float r = 1.0;\n    for (int i = 0; i < 4; ++i){\n        v += a * noise(_st);\n        r += a;\n        _st =  shift + _st*2.0;\n        _st = (sin(r)*_st+cos(r)*_st);\n        a *= 0.5;\n    }\n    return v;\n}\nfloat edis(vec3 from,vec3 to){\nvec3 plac = CENTER;\nfloat rad = -CENTER.y - 6.0;\n\nfloat a = dts(from,to,plac,rad,-1.0);\nfloat b = dts(from,to,plac,rad, 1.0);\n\nif(a<0.0&&b<0.0)\n{\nreturn -1.0;\n}\nif(a < 0.0){return b;}\nif(b < 0.0){return a;}\n\nreturn min(a,b);\n\n}\nfloat sdis(vec3 from,vec3 to){\nvec3 plac = CENTER;\nfloat rad = -CENTER.y + float(ATMOSPHEREHEIGHT);\n\nfloat a = dts(from,to,plac,rad,-1.0);\nfloat b = dts(from,to,plac,rad, 1.0);\n\nif(a<0.0&&b<0.0)\n{\nreturn -1.0;\n}\nif(a < 0.0){return b;}\nif(b < 0.0){return a;}\n\nreturn min(a,b);\n}\nvec3 outscatter(float r){\n\n\nvec3 a =  vec3(1.02651);\nvec3 b = vec3(620.0,540.0,460.0)*1.0f;\nvec3 os = (2.0*3.1415*4079.660796735571*a*a*r)/(b*b*b*b);\nreturn 1.0 - os;\n\n\n\n\n}\nvec3 scatter(float intensity,vec3 lightdir,vec3 from, vec3 to){\n\n\nvec3 l = lightdir;\nfloat d = intensity;\n\nfloat r = distance(from,to);\nfloat c = acos(dot(normalize(to-from),normalize(l)));\nvec3 a =  vec3(1.02651);\nvec3 b = vec3(620.0,540.0,460.0)*1.0f;\n\n\n\n\nfloat si = sdis(mix(to,from,0.5)+l*0.5, mix(to,from,0.5)+l);\nfloat ai = sdis(mix(to,from,0.99)+l*0.5, mix(to,from,0.99)+l);;\nfloat fi = 0.5*(si+ai);\n//float si = edis(from-l*0.5, from+l);\n//if(si<ai){return vec3(0.0);};\nfloat mol = 215443.469003;\nfloat area = sin(c)*r*(si+ai)*0.5;\nvec3 is = d * 100.0*r * (779.180801368*a*a*(1.5+0.5*cos(2.0*c))/(pow(b,vec3(4.0))));\n\n//vec3 os = 2.0*25214649.0*a*a*d*8.0*pow(3.1415,5.0)*r/(16053091.0*b*b*b*b);\nreturn (is*outscatter(((si+ai)/2.0)*300.0));//(0.5*(r+distance(from+l*si,pos+l*fi)))) ;\n\n\n\n\n\n\n}\nfloat getcloud(in vec3 a)\n{\n    float r = fbm( a / 20.0 + vec3(time*3.0, time*2.0, 0.0) );\n       float th = 0.55;//sin(210.11);\nreturn max(1.0-r/th,0.0);\n}\nvec3 getwatnorm(in vec3 a)\n{\nvec3 waveoffset = vec3(0.0, 0.0, time*5.0);\nvec3 dn = normalize(a-CENTER)*0.12;//*fbm(waveoffset.yzx*2.0+a/10.0);\nvec3 d = vec3(0.01, 0.01, 0.0);\nreturn normalize(cross(a+d.xzz+dn*fbm(waveoffset +a+d.xzz)-a-dn*fbm(waveoffset +a),a+d.zzx+dn*fbm(waveoffset +a+d.zzx)-a-dn*fbm(waveoffset +a)));\n\n}\nfloat afbm(in vec3 a){\n\nreturn fbm(a)*max(1.0-a.y,0.0);\n}\nvec3 getaurora(in vec3 a){\n    float av = AURORORHEIGHT;//200.0;\n    vec3 acc = vec3(0.0);\n    for(float i = 0.0;i < av;i++){\n        vec3 z = a;\n        z.xz = z.xz/((float(i)/(50.0))+1.0) ;\nfloat r = fbm(z/800.0+vec3(0.0,time,0.0));\n    float th = sin(210.11);\n       acc+=float(r>th&&r<(th+0.05*sin(distance(a.xz,cam.xz)/5000.0)))*vec3(0.0025*pow(max(1.0-abs(i/av),0.0),2.0),0.025*pow(abs(i/av-0.5)*2.0,1.0),0.0125*pow((i/av),1.0/2.0)).xzy*AURORORBRIGHTNESS*i/av;\n    }\n\n    return acc;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //cam.y=fbm(cam+vec3(0.0,0.0,time*5.0))*10.0;\n\tvec2 uv = fragCoord.xy / iResolution.xy-0.5;\n    \n    vec2 look = (iMouse.xy-iMouse.zw)/iResolution.xy*3.1415*2.0+3.1415;\n    look=mix(vec2(3.1415),look,float(iMouse.z>0.0&&iMouse.w>0.0));\n    look.y=look.y*0.5+3.1415/2.0+3.1415;\n    look.x = -look.x + 3.1415;\n    \n    //xy = mouse when clickdown\n    //zw = mouse when clickfirst\n    vec3 screen = vec3(0.0);//\n    screen.x = uv.x;\n    screen.y = -sin(look.y)*FOV+cos(look.y)*uv.y*(iResolution.y/iResolution.x);\n    screen.z = cos(look.y)*FOV+sin(look.y)*uv.y*(iResolution.y/iResolution.x);\n   float temp = screen.x;\n    screen.x = cos(look.x)*screen.x+sin(look.x)*screen.z;\n    \n    screen.z = -sin(look.x)*temp+cos(look.x)*screen.z;\n    \n    \n   \n    vec3 pos = cam+screen;\nvec3 virtualPos = pos;\nvec3 directionToFragmentPosition = normalize(pos-cam);\nvec3 lightDir = sunpos;\nfloat distanceToGround = edis(cam,pos);\n    vec3 groundPosition = cam+directionToFragmentPosition*distanceToGround;\nfloat preReflectionDistance = 0.0;\n    vec3 preReflectionDirection = vec3(0.1);\n   if(distanceToGround>0.0){\n       preReflectionDistance = distanceToGround;\n       cam = groundPosition;\n       preReflectionDirection = directionToFragmentPosition;\n       directionToFragmentPosition = reflect(directionToFragmentPosition,getwatnorm(groundPosition/10.0));\n       \n       //  fragmentColor = scatter(50.0,-lightDir,cam,groundPosition)*-dot(groundDirection,lightDir)*vec3(getcloud(groundPosition+vec3(10.1)),getcloud(groundPosition),getcloud(-groundPosition));\n     //max(outscatter((distance(cam,groundPosition))*30.0),vec3(0.0))*scatter(50.0,lightDir,cam,groundPosition)*mix(vec3(0.40,0.20,0.2),vec3(0.45,0.33,0.2),getcloud(groundPosition))*-dot(normalize(groundPosition-CENTER),lightDir);\n    }\n    \n   float distanceToSky = sdis(cam,cam+directionToFragmentPosition);\n    vec3 skyPosition = cam+directionToFragmentPosition*distanceToSky;\n   \n    virtualPos = skyPosition;\n    vec3 skyColor = scatter(50.0,lightDir,cam,virtualPos)+scatter(50.0,lightDir,vec3(0.0),preReflectionDirection)*preReflectionDistance;\n    //if(distance(cam,CENTER)>CENTER.y){distanceToSky = distanceToGround - distanceToSky;}\n\n    float sunColor = pow(max(dot(directionToFragmentPosition,vec3(lightDir)),0.0),200.0);\n    skyColor += 2.0 * sunColor * max(outscatter(150.0 * (distance(cam, virtualPos)+preReflectionDistance)),0.0);\n    vec3 skyDirection = normalize(virtualPos - CENTER);\n    vec2 cloudColor =  vec2(( pow(getcloud(skyPosition/50.0),3.0)),( pow(getcloud(skyPosition/50.0+lightDir*3.0*vec3(0.0,0.0,1.0)),2.0))) ;\n vec3 groundDirection = normalize(groundPosition - CENTER);\n    vec2 skyPolarCoords = vec2(atan(skyDirection.y,skyDirection.z),asin(skyDirection.x)+3.1415/2.0);\n    float star = (starnoise(virtualPos/30.0));\n    vec3 starCol = vec3(pow(star,1.0));\n    starCol += getaurora(virtualPos);\n    float a = sdis(virtualPos+lightDir*0.5,virtualPos+lightDir);\n    float b = edis(virtualPos+lightDir*0.5,virtualPos+lightDir);\n    float distanceToNight = float(a>b)*a;\n    skyColor *= max(outscatter((distanceToNight)*300.0),vec3(0.0));\n    skyColor = mix(skyColor,vec3(1.0),cloudColor.x*1.0);\n    skyColor = mix(skyColor,vec3(0.9),cloudColor.y*1.0);\n    vec3 fragmentColor = mix(clamp(skyColor,vec3(0.0),vec3(1.0)),starCol,1.0-max(outscatter((distanceToNight)*300.0),vec3(0.0)));\n  //  if(distanceToGround>0.0){\n  //  fragmentColor = scatter(50.0,-lightDir,cam,groundPosition)*-dot(groundDirection,lightDir)*vec3(getcloud(groundPosition+vec3(10.1)),getcloud(groundPosition),getcloud(-groundPosition));\n     //max(outscatter((distance(cam,groundPosition))*30.0),vec3(0.0))*scatter(50.0,lightDir,cam,groundPosition)*mix(vec3(0.40,0.20,0.2),vec3(0.45,0.33,0.2),getcloud(groundPosition))*-dot(normalize(groundPosition-CENTER),lightDir);\n  //  }\n fragColor = vec4(fragmentColor,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXBD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 306, 374, 374, 638], [640, 640, 668, 668, 783], [785, 785, 816, 816, 1876], [1878, 1878, 1905, 1905, 2695], [2697, 2697, 2723, 2723, 3009], [3010, 3010, 3040, 3040, 3268], [3269, 3269, 3299, 3299, 3546], [3547, 3547, 3572, 3572, 3719], [3720, 3720, 3783, 3783, 4518], [4519, 4519, 4546, 4546, 4675], [4676, 4676, 4704, 4704, 4999], [5000, 5000, 5022, 5022, 5057], [5058, 5058, 5084, 5084, 5549], [5550, 5550, 5607, 5657, 9474]], "test": "untested"}
{"id": "XtXBDs", "name": "4-Color Gradient", "author": "unycone", "description": "Tried to reproduce AfterEffects' 4-color gradient effect.", "tags": ["interpolation", "gradation"], "likes": 6, "viewed": 450, "published": "Public", "date": "1513854108", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    // parameters\n\n    vec2 p[4];\n    p[0] = vec2(0.1, 0.9);\n    p[1] = vec2(0.9, 0.9);\n    p[2] = vec2(0.5, 0.1);\n    p[3] = vec2(cos(iTime), sin(iTime)) * 0.4 + vec2(0.5, 0.5);\n    \n    vec3 c[4];\n    c[0] = vec3(1.0, 0.0, 0.0);\n    c[1] = vec3(0.0, 1.0, 0.0);\n    c[2] = vec3(0.0, 0.0, 1.0);\n    c[3] = vec3(1.0, 1.0, 0.0);\n\n    float blend = 2.0;\n    \n    // calc IDW (Inverse Distance Weight) interpolation\n    \n    float w[4];\n    vec3 sum = vec3(0.0);\n    float valence = 0.0;\n    for (int i = 0; i < 4; i++) {\n        float distance = length(uv - p[i]);\n        if (distance == 0.0) { distance = 1.0; }\n        float w =  1.0 / pow(distance, blend);\n        sum += w * c[i];\n        valence += w;\n    }\n    sum /= valence;\n    \n    // apply gamma 2.2 (Approx. of linear => sRGB conversion. To make perceptually linear gradient)\n\n    sum = pow(sum, vec3(1.0/2.2));\n    \n    // output\n    \n\tfragColor = vec4(sum.xyz, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXBDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1031]], "test": "untested"}
{"id": "XtXBRX", "name": "Simpler Solar System", "author": "Janbg", "description": "The Sun and planets of the Solar System.\nDiameters of the planets are to scale. \nDistances are not to scale.", "tags": ["earth", "planet", "mars", "saturn", "pluto", "mercury", "solarsystem", "venus", "jupiter", "uranus", "neptune"], "likes": 13, "viewed": 541, "published": "Public", "date": "1512648066", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 backgroundColor = vec3(0.0, 0.0, 0.0);\nconst vec2 CENTER   = vec2(0.0, 0.0);\nconst vec3 RED \t    = vec3(1.0, 0.0, 0.0);\nconst vec3 GREEN \t= vec3(0.0, 1.0, 0.0);\nconst vec3 BLUE \t= vec3(0.0, 0.0, 1.0);\nconst vec3 YELLOW   = vec3(1.0, 1.0, 0.0);\nconst vec3 WHITE\t= vec3(1.0, 1.0, 1.0);\nconst vec3 GREY\t\t= vec3(0.5, 0.5, 0.5);\n\nconst vec3 ColMercury\t= vec3(0.96078, 0.90588, 0.71765);\nconst vec3 ColVenus\t\t= vec3(0.95686, 0.82353, 0.38039);\nconst vec3 ColEarth\t\t= vec3(0.61961, 0.79216, 0.37255);\nconst vec3 ColMars\t\t= vec3(0.88235, 0.81569, 0.61961);\nconst vec3 ColJupiter\t= vec3(0.83922, 0.67059, 0.53333);\nconst vec3 ColSaturn\t= vec3(0.89412, 0.87059, 0.63922);\nconst vec3 ColUranus\t= vec3(0.00784, 0.87059, 0.95686);\nconst vec3 ColNeptune\t= vec3(0.00000, 0.51765, 0.89020);\nconst vec3 ColPluto\t\t= vec3(0.62745, 0.63137, 0.64706);\n\n\nvoid drawCircle(vec2 uv, vec3 color, float radiusCircle, float blur, vec2 pos, inout vec3 image) {\n    \n    float d = length(uv - pos);\n\n    if(d <= radiusCircle)\n    {\n\t\timage.r = color.r * (1.0-smoothstep(radiusCircle-blur, radiusCircle, d));\n        image.b = color.b * (1.0-smoothstep(radiusCircle-blur, radiusCircle, d));\n        image.g = color.g * (1.0-smoothstep(radiusCircle-blur, radiusCircle, d));\n    }\n}\n\nvec2 Rotation(float distance, float multi)\n{\n    float x1 = distance*(cos(iTime*multi));\n    float y1 = distance*(sin(iTime*multi));\n    \n    return vec2(x1,y1);\n}\n\nvec3 createOrbit(float m, vec2 uv) \n{ \n    vec3 colorOrbit = vec3(0.0, 0.19, 0.51);\n    return mix(vec3(.0),\n               colorOrbit, \n               smoothstep(1.5/iResolution.y, 0., abs(length(uv)-(m)))); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord.xy / iResolution.xy ) - 0.5;  // -0.5 <> 0.5\n    uv.x *= iResolution.x / iResolution.y;\n\tvec4 backgroundImage = texture(iChannel0,uv);\n    backgroundImage.r -= 0.4;\n    backgroundImage.b -= 0.2;\n    backgroundImage.g -= 0.4;\n    backgroundImage /= 2.0;\n    \n    fragColor = backgroundImage;\n    \n    vec3 c = backgroundColor;\n    \n    \n    float diam = 0.00073; // Diameter\n    float dist = 0.00062; // Distance from the Sun\n    float vel  = 0.031;   // Mean orbital velocity \n    \n    vec3 orbitMercury \t= createOrbit(dist*188.0, uv);\n    vec3 orbitVenus \t= createOrbit(dist*242.0, uv);\n    vec3 orbitEarth \t= createOrbit(dist*300.0, uv);\n    vec3 orbitMars \t\t= createOrbit(dist*345.0, uv);\n    vec3 orbitJupiter \t= createOrbit(dist*425.0, uv);\n    vec3 orbitSaturn \t= createOrbit(dist*542.0, uv);\n    vec3 orbitUranus \t= createOrbit(dist*632.0, uv);\n    vec3 orbitNeptune \t= createOrbit(dist*710.0, uv);\n    vec3 orbitPluto \t= createOrbit(dist*777.0, uv);\n\n    c += orbitMercury;\n    c += orbitVenus;\n    c += orbitEarth;\n    c += orbitMars;\n    c += orbitJupiter;\n    c += orbitSaturn;\n    c += orbitUranus;\n    c += orbitNeptune;\n    c += orbitPluto;\n    \n    \n    drawCircle(uv, YELLOW,\t\t70.0  * diam, 0.005, CENTER, c);\n    drawCircle(uv, ColMercury,\t12.0  * diam, 0.005, Rotation(dist*188.0, vel*47.89), c);\n    drawCircle(uv, ColVenus,  \t26.0  * diam, 0.005, Rotation(dist*242.0, vel*35.03), c);\n\tdrawCircle(uv, ColEarth,    28.0  * diam, 0.005, Rotation(dist*300.0, vel*29.79), c);\n    drawCircle(uv, ColMars,  \t14.0  * diam, 0.005, Rotation(dist*345.0, vel*24.13), c);\n    drawCircle(uv, ColJupiter,  56.0  * diam, 0.005, Rotation(dist*425.0, vel*13.06), c);\n    drawCircle(uv, ColSaturn,  \t46.0  * diam, 0.005, Rotation(dist*542.0, vel*9.64),  c);\n    drawCircle(uv, ColUranus,   29.0  * diam, 0.005, Rotation(dist*632.0, vel*6.81),  c);\n    drawCircle(uv, ColNeptune,  31.0  * diam, 0.005, Rotation(dist*710.0, vel*5.43),  c);\n    drawCircle(uv, ColPluto,  \t14.0  * diam, 0.005, Rotation(dist*777.0, vel*4.74),  c);\n    \n    vec2 starPos = vec2(-0.8,0.3);\n\tdrawCircle(uv, WHITE*(0.1/sin(iTime*2.0)), 34.0  * diam, 0.06, vec2(0.6,0.1),  c);\n    drawCircle(uv, WHITE*(sin(iTime*2.0)), 34.0  * diam, 0.06, vec2(0.5,-0.4),  c);\n    drawCircle(uv, WHITE*(cos(iTime*3.0)+0.2), 34.0  * diam, 0.06, vec2(-0.5,-0.2),  c);\n    drawCircle(uv, WHITE*(sin(iTime)+cos(iTime))*1.2, 24.0  * diam, 0.06, vec2(-0.8,-0.3),  c);\n    \n    drawCircle(uv, WHITE*(sin(iTime)-cos(iTime))*1.2, 34.0  * diam, 0.06, starPos,  c);\n    \n    // Brightness ring around the Sun\n    c[0] += .03/length((mod(length(uv),2.0)-.04));\n    c[1] += .03/length((mod(length(uv),2.0)-.04));\n    \n\tfragColor += vec4(c, 0.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXBRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[844, 844, 942, 942, 1260], [1262, 1262, 1306, 1306, 1425], [1427, 1427, 1464, 1464, 1638], [1640, 1640, 1697, 1697, 4417]], "test": "untested"}
{"id": "XtXBWX", "name": "koziej", "author": "koziej", "description": "koziej", "tags": ["koziej"], "likes": 1, "viewed": 75, "published": "Public", "date": "1513463312", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 z, c;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv.x -= 0.5f;\n    uv.y -= 0.5f;\n    uv.x *= 3.0f;\n    uv.y *= 3.0f;\n    \n    z.x = uv.x;\n    z.y = uv.y;\n    \n    c.x = (iMouse.x / iResolution.x-0.5f) + cos(iTime / 5.0f) / 25.0f;\n    c.y = (iMouse.y / iResolution.y-0.5f) + sin(iTime / 5.0f) / 25.0f;\n\n    int i;\n    \n    for(i=0; i < 100; i++) {\n        float x = (z.x * z.x - z.y * z.y) + c.x;\n        float y = (z.y * z.x + z.x * z.y) + c.y;\n\n        if((x * x + y * y) > 4.0) break;\n        z.x = x;\n        z.y = y;\n    }\n\n    fragColor = vec4(1,1,1,1) * float(i) / 100.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXBWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 656]], "test": "untested"}
{"id": "XtXfDS", "name": "Flows along conic sections", "author": "Reedbeta", "description": "Any conic section is mapped to itself by a one-parameter family of affine transformations.", "tags": ["procedural", "2d", "grid", "math", "conic", "diagram"], "likes": 18, "viewed": 2609, "published": "Public API", "date": "1513124981", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void stroke(float dist, vec3 color, inout vec3 fragColor, float thickness, float aa)\n{\n    float alpha = smoothstep(0.5 * (thickness + aa), 0.5 * (thickness - aa), abs(dist));\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid fill(float dist, vec3 color, inout vec3 fragColor, float aa)\n{\n    float alpha = smoothstep(0.5*aa, -0.5*aa, dist);\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid renderGrid(vec2 pos, out vec3 fragColor)\n{\n    vec3 background = vec3(1.0);\n    vec3 axes = vec3(0.4);\n    vec3 lines = vec3(0.7);\n    vec3 sublines = vec3(0.95);\n    float subdiv = 8.0;\n\n    float thickness = 0.003;\n    float aa = length(fwidth(pos));\n\n    fragColor = background;\n\n    vec2 toSubGrid = pos - round(pos*subdiv)/subdiv;\n    stroke(min(abs(toSubGrid.x), abs(toSubGrid.y)), sublines, fragColor, thickness, aa);\n\n    vec2 toGrid = pos - round(pos);\n    stroke(min(abs(toGrid.x), abs(toGrid.y)), lines, fragColor, thickness, aa);\n\n    stroke(min(abs(pos.x), abs(pos.y)), axes, fragColor, thickness, aa);\n}\n\nvec2 ortho(vec2 v)\n{\n    return vec2(v.y, -v.x);\n}\n\nfloat sdistLine(vec2 a, vec2 b, vec2 pos)\n{\n    return dot(pos - a, normalize(ortho(b - a)));\n}\n\nfloat sdistTri(vec2 a, vec2 b, vec2 c, vec2 pos)\n{\n    return max( sdistLine(a, b, pos),\n            max(sdistLine(b, c, pos),\n                sdistLine(c, a, pos)));\n}\n\nfloat sdistQuadConvex(vec2 a, vec2 b, vec2 c, vec2 d, vec2 pos)\n{\n    return max(  sdistLine(a, b, pos),\n            max( sdistLine(b, c, pos),\n             max(sdistLine(c, d, pos),\n                 sdistLine(d, a, pos))));\n}\n\nvoid renderAxes(vec2 origin, vec2 pos, inout vec3 fragColor)\n{\n    float len = 0.1;\n    float thickness = 0.0075;\n    float aa = length(fwidth(pos));\n\n    float xshaft = sdistQuadConvex(origin + vec2(0.5*thickness),\n                                   origin - vec2(0.5*thickness),\n                                   origin + vec2(len, -0.5*thickness),\n                                   origin + vec2(len, 0.5*thickness), pos);\n    float xhead = sdistTri(origin + vec2(len, -2.0*thickness),\n                           origin + vec2(len + 6.0*thickness, 0),\n                           origin + vec2(len, 2.0*thickness), pos);\n\n    fill(min(xshaft, xhead), vec3(1, 0, 0), fragColor, aa);\n\n    float yshaft = sdistQuadConvex(origin - vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness, len),\n                                   origin + vec2(-0.5*thickness, len), pos);\n    float yhead = sdistTri(origin + vec2(2.0*thickness, len),\n                           origin + vec2(0, len + 6.0*thickness),\n                           origin + vec2(-2.0*thickness, len), pos);\n\n    fill(min(yshaft, yhead), vec3(0, 0.75, 0), fragColor, aa);\n\n}\n\nvoid renderCircle(float r, vec2 pos, inout vec3 fragColor)\n{\n    float sdist = length(pos) - r;\n    stroke(sdist, vec3(0,0.5,1), fragColor, 0.01, length(fwidth(pos)));\n}\n\nvoid renderCirclePoints(float bigR, float littleR, mat2 xfm, vec2 pos, inout vec3 fragColor)\n{\n    float sdistMin = 1e10;\n    \n    int numCircles = 20;\n    for (int i = 0; i < numCircles; ++i)\n    {\n        float theta = float(i) / float(numCircles) * (2.0 * 3.141592654);\n        vec2 center = xfm * (bigR * vec2(cos(theta), sin(theta)));\n        float sdist = length(pos - center) - littleR;\n        sdistMin = min(sdistMin, sdist);\n    }\n    \n    vec3 dotColor = vec3(sin(pos.x)*0.6+0.3, sin(pos.y)*0.8+0.4, 1);\n    fill(sdistMin, dotColor, fragColor, length(fwidth(pos)));\n}\n\nvoid renderEllipse(float rx, float ry, vec2 pos, inout vec3 fragColor)\n{\n    // TODO: more accurate distance to ellipse function\n    float sdist = length(vec2(pos.x * ry/rx, pos.y)) - ry;\n    stroke(sdist, vec3(0,0.5,1), fragColor, 0.01, length(fwidth(pos)));\n}\n\nvoid renderEllipsePoints(float rx, float ry, float littleR, mat2 xfm, vec2 pos, inout vec3 fragColor)\n{\n    float sdistMin = 1e10;\n    \n    int numCircles = 20;\n    for (int i = 0; i < numCircles; ++i)\n    {\n        float theta = float(i) / float(numCircles) * (2.0 * 3.141592654);\n        vec2 center = xfm * vec2(rx * cos(theta), ry * sin(theta));\n        float sdist = length(pos - center) - littleR;\n        sdistMin = min(sdistMin, sdist);\n    }\n    \n    vec3 dotColor = vec3(sin(pos.x)*0.6+0.3, sin(pos.y)*0.8+0.4, 1);\n    fill(sdistMin, dotColor, fragColor, length(fwidth(pos)));\n}\n\nvoid renderHyperbolas(float r, vec2 pos, inout vec3 fragColor)\n{\n    // TODO: more accurate distance to hyperbola function\n    float sdist = sqrt(abs(pos.y*pos.y - pos.x*pos.x)) - r;\n    stroke(sdist, vec3(0,0.5,1), fragColor, 0.01, length(fwidth(pos)));\n}\n\nvoid renderHyperbolaPoints(float bigR, float littleR, mat2 xfm, vec2 pos, inout vec3 fragColor)\n{\n    float sdistMin = 1e10;\n    \n    for (int q = 0; q < 4; ++q)\n    {\n        float qx = float(abs(q - 2) - 1); // 1, 0, -1, 0\n        float qy = float(1 - abs(q - 1)); // 0, 1, 0, -1\n        vec2 qvec = vec2(qx, qy);\n        vec2 qvec2 = ortho(qvec);\n\n        int numCircles = 15;\n        for (int i = -numCircles/2; i <= numCircles/2; ++i)\n        {\n            float omega = float(i) / float(numCircles/2) * 2.2;\n            vec2 center = bigR * vec2(cosh(omega), sinh(omega));\n            center = xfm * (center.x * qvec + center.y * qvec2);\n            float sdist = length(pos - center) - littleR;\n            sdistMin = min(sdistMin, sdist);\n        }\n    }\n\n    vec3 dotColor = vec3(sin(pos.x)*0.6+0.3, sin(pos.y)*0.8+0.4, 1);\n    fill(sdistMin, dotColor, fragColor, length(fwidth(pos)));\n}\n\nvoid renderParabola(float b, vec2 pos, inout vec3 fragColor)\n{\n    // TODO: more accurate distance to parabola function\n    float sdist = pos.y - pos.x*pos.x - b;\n    stroke(sdist, vec3(0,0.5,1), fragColor, 0.01, length(fwidth(pos)));\n}\n\nvoid renderParabolaPoints(float b, float littleR, mat3 xfm, vec2 pos, inout vec3 fragColor)\n{\n    float sdistMin = 1e10;\n    \n    int numCircles = 31;\n    for (int i = -numCircles/2; i <= numCircles/2; ++i)\n    {\n        float x = float(i) / float(numCircles/2) * 1.7;\n        vec2 center = vec2(x, x*x + b);\n        center = (xfm * vec3(center, 1)).xy;\n        float sdist = length(pos - center) - littleR;\n        sdistMin = min(sdistMin, sdist);\n    }\n    \n    vec3 dotColor = vec3(sin(pos.x)*0.6+0.3, sin(pos.y)*0.8+0.4, 1);\n    fill(sdistMin, dotColor, fragColor, length(fwidth(pos)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n\tvec2 pos = ((fragCoord / iResolution.xy) - 0.5) * vec2(aspect, 1.0) * 1.2;\n    vec2 posOrig = pos;\n\n    int conic = int(iTime / 20.0) % 4;\n    float timeConic = mod(iTime, 20.0);\n    float fade = smoothstep(0.0, 0.5, timeConic) * smoothstep(20.0, 19.5, timeConic);\n\n    float ellipseAspect = 0.8 / 0.5;\n    mat2 xfm, xfmInv;\n    mat3 xfm3, xfm3Inv;\n    \n    // TODO: mouse control?\n\n    switch (conic)\n    {\n        case 0:\n        {\n            // (circle) rotate the coordinates\n            float theta = iTime * 0.2;\n            float cosTheta = cos(theta), sinTheta = sin(theta);\n            xfm = mat2(cosTheta, -sinTheta, sinTheta, cosTheta);\n            xfmInv = inverse(xfm);\n            pos = xfm * pos;\n            break;\n        }\n\n        case 1:\n        {\n            // (ellipse) scale, rotate, unscale the coordinates\n            float theta = iTime * 0.3;\n            float cosTheta = cos(theta), sinTheta = sin(theta);\n            xfm = mat2(cosTheta, -sinTheta / ellipseAspect, sinTheta * ellipseAspect, cosTheta);\n            xfmInv = inverse(xfm);\n            pos = xfm * pos;\n\t\t\tbreak;\n        }\n    \n\t\tcase 2:\n        {\n            // (parabola) shear and translate the coordinates\n            float k = 1.5 * sin(iTime * 0.3);\n            xfm3 = mat3(1, k, 0, 0, 1, 0, 0.5*k, 0.25*k*k, 1);\n            xfm3Inv = inverse(xfm3);\n            pos = (xfm3 * vec3(pos, 1)).xy;\n            break;\n        }\n\n        case 3:\n        {\n            // (hyperbolas) apply Lorentz transform\n            float omega = 1.3 * sin(iTime * 0.3);\n            float coshOmega = cosh(omega), sinhOmega = sinh(omega);\n            xfm = mat2(coshOmega, sinhOmega, sinhOmega, coshOmega);\n            xfmInv = inverse(xfm);\n            pos = xfm * pos;\n            break;\n        }\n    }\n\n    fragColor.a = 1.0;\n\trenderGrid(pos, fragColor.rgb);\n    renderAxes(vec2(0), pos, fragColor.rgb);\n\n    switch (conic)\n    {\n        case 0:\n            renderCircle(0.5, posOrig, fragColor.rgb);\n            renderCirclePoints(0.5, 0.015, xfmInv, posOrig, fragColor.rgb);\n        \tbreak;\n\n        case 1:\n            renderEllipse(0.5 * ellipseAspect, 0.5, posOrig, fragColor.rgb);\n            renderEllipsePoints(0.5 * ellipseAspect, 0.5, 0.015, xfmInv, posOrig, fragColor.rgb);\n        \tbreak;\n\n        case 2:\n            renderParabola(-0.5, posOrig, fragColor.rgb);\n            renderParabolaPoints(-0.5, 0.015, xfm3Inv, posOrig, fragColor.rgb);\n        \tbreak;\n\n        case 3:\n            renderHyperbolas(0.4, posOrig, fragColor.rgb);\n            renderHyperbolaPoints(0.4, 0.015, xfmInv, posOrig, fragColor.rgb);\n        \tbreak;\n    }\n    \n    fragColor.rgb *= fade;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXfDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 86, 86, 223], [225, 225, 292, 292, 393], [395, 395, 442, 442, 1017], [1019, 1019, 1039, 1039, 1069], [1071, 1071, 1114, 1114, 1166], [1168, 1168, 1218, 1218, 1336], [1338, 1338, 1403, 1403, 1564], [1566, 1566, 1628, 1628, 2793], [2795, 2795, 2855, 2855, 2964], [2966, 2966, 3060, 3060, 3544], [3546, 3546, 3618, 3674, 3807], [3809, 3809, 3912, 3912, 4397], [4399, 4399, 4463, 4521, 4655], [4657, 4657, 4754, 4754, 5553], [5555, 5555, 5617, 5674, 5791], [5793, 5793, 5886, 5886, 6385], [6387, 6387, 6442, 6442, 9161]], "test": "untested"}
{"id": "XtXfRf", "name": "Circle_bullshit3", "author": "lookezen", "description": "bullshit", "tags": ["circles"], "likes": 0, "viewed": 82, "published": "Public", "date": "1512602895", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool cirOL(vec2 center, float rad)\n{\n    return(length(center) < rad);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 col1 = vec4( 0., 0, 0., 1.);\n    float f = abs(sin(iTime * 0.02));\n    int counter = 0;\n    vec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    float c2 = 0.;\n    for(float i = -2.; i < 2.; i += 0.05)\n    { \t\n        c2+= 10.;\n        vec2 temp = r;\n        temp.x += i;\n        temp.y += sin(c2 * (iTime /400.));\n        if(cirOL(temp, f)){ counter += 1; }\n    }\n    \n    if(counter % 2 == 0)\n    {\n    \tcol1.r = (float(counter) / 28.);\n    \tcol1.g = (float(counter) / 28.);\n    \tfragColor = col1;\n    }\n    \n    else\n    {\n\t\tcol1.r = (float(counter) / 28.);\n    \tcol1.b = 1. - (float(counter) / 28.);\n    \tfragColor = col1;\n    }\n}\n    \n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXfRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 72], [74, 74, 131, 131, 792]], "test": "untested"}
{"id": "XtXfRM", "name": "3DMandelbulb Set", "author": "qq456cvb", "description": "3D Mandelbulb Set using sphere tracing and sdf approximation", "tags": ["3dmandelbulb"], "likes": 3, "viewed": 506, "published": "Public API", "date": "1512088161", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int NUM_STEPS = 40;\nconst float CELL_SIZE = 0.3;\nconst float RADIUS = 0.1;\nconst float EPSILON = 1e-3;\n\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\nconst vec3 ORANGE = vec3(1.0, 0.647, 0.0);\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\nconst vec3 GREEN = vec3(0.0, 1.0, 0.0);\nconst vec3 INDIGO = vec3(0.0, 0.5, 1.0);\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\nconst vec3 PURPLE = vec3(0.45, 0.0, 1.0);\n\n\n// reference: https://www.shadertoy.com/view/Ms2SD1\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ),  u.x), u.y);\n}\n\n// polynomial smooth min (k = 0.1) from iq;\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opRepSphere( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sdSphere( q, RADIUS );\n}\n\nfloat opRepTorus( vec3 p, vec3 c, vec2 t )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sdTorus( q, t );\n}\n\n\nfloat hash3d( vec3 p ) {\n    float h = dot(p,vec3(1.127,3.117, 2.038));\t\n    return fract(sin(h)*71451.5453123);\n}\n\nmat2 rot( float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat noise3d( in vec3 p ) {\n    vec3 idx = vec3(fract(sin(dot(p / 0.3, vec3(2.5,3.46,1.29))) * 12394.426),\n                   fract(sin(dot(p / 0.17, vec3(3.987,2.567,3.76))) * 52422.82465),\n                   fract(sin(dot(p / 0.44, vec3(6.32,3.87,5.24))) * 34256.267));\n    //p.z *= p.z;\n    //p.y *= p.y;\n    //p.z = mix(p.y, p.z, idx.x * (1.0 - idx.y));\n    p.xz = mod(p.xz - 0.5 * CELL_SIZE, vec2(CELL_SIZE));\n    p.xz = rot(fract(sin(dot(idx.xz, vec2(3.124,1.75)))) * 312.2) * p.xz;\n    float s = hash3d(1e4 * p + idx);\n    return s;\n}\n\nvec3 colorLookup( in vec3 p ) {\n    float freq = 1e-7;\n    float f = noise3d(p * freq);\n    if (f < 1.0 / 7.0) return RED;\n    if (f < 2.0 / 7.0) return ORANGE;\n    if (f < 3.0 / 7.0) return YELLOW;\n    if (f < 4.0 / 7.0) return GREEN;\n    if (f < 5.0 / 7.0) return INDIGO;\n    if (f < 6.0 / 7.0) return BLUE;\n    return PURPLE;\n}\n\nfloat map (in vec3 p) {\n    float bailout = 2.0;\n    float power = 3.0 * sin(iTime / 5.0) + 6.0;\n    vec3 z = p;\n    float dr = 1.0;\n    float r = 0.0;\n    for (int i = 0; i < 200; i++) {\n        r = length(z);\n        if (r>bailout) break;\n\n        // convert to polar coordinates\n        float theta = acos(z.z/r);\n        float phi = atan(z.y,z.x);\n        dr =  pow( r, power-1.0)*power*dr + 1.0;\n\n        // scale and rotate the point\n        float zr = pow( r,power);\n        theta = theta*power;\n        phi = phi*power;\n\n        // convert back to cartesian coordinates\n        z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        z += p;\n    }\n    return 0.5*log(r)*r/dr;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n\n\nbool interSect( vec3 ro, vec3 rd, out vec3 p ) {\n    float t = 0.0;\n    p = ro;\n    for (int i = 0; i < NUM_STEPS; i++) {\n        p = ro + t * rd;\n        float d = map(p);\n        if (abs(d) < EPSILON) {\n            return true;\n        }\n        t += d;\n    }\n    return false;\n}\n\nmat3 cam2world(vec3 ro, vec3 target, vec3 up) {\n    vec3 forward = normalize(target - ro);\n    vec3 right = cross(up, forward);\n    return mat3(right, up, forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 light_dir = normalize(vec3(0.3, 0.4, -0.5));\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(rot(iTime / 5.0) * vec2(sin(iTime / 2.0) + 2.5, 0.0), 0.0);\n    //vec3 ro = vec3(rot(iTime / 5.0) * vec2(3.0, 0.0), 0.0);\n    vec3 target = vec3(0.0);\n    vec3 up = vec3(0.0, 0.0, 1.0);\n    vec3 rd = cam2world(ro, target, up) * normalize(vec3(uv, 2.1));\n    float t = 0.0;\n    vec3 p, norm;\n    if (interSect(ro, rd, p)) {\n    //if (rayTracing(ro, rd, t)) {\n    //if (abs(sdf(ro + t * rd)) < EPSILON) {\n        norm = calcNormal(p);\n        vec3 baseColor = colorLookup(p);\n        float light_pow = 2.0;\n        float brdf = 0.4;\n        vec3 diff = vec3(dot(light_dir, norm) * brdf * light_pow);\n        fragColor = vec4(mix(baseColor, diff, 0.99), 1.0);\n        //fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    } else {\n        fragColor = vec4(0,0,0,1.0);\n    }\n    fragColor.xyz = pow(fragColor.xyz, vec3(1.0/2.2));\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXfRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[396, 448, 470, 470, 550], [552, 552, 578, 578, 880], [882, 926, 967, 967, 1060], [1064, 1064, 1099, 1099, 1123], [1125, 1125, 1158, 1158, 1223], [1225, 1225, 1262, 1262, 1327], [1329, 1329, 1373, 1373, 1432], [1435, 1435, 1459, 1459, 1549], [1551, 1551, 1576, 1576, 1660], [1662, 1662, 1690, 1690, 2204], [2206, 2206, 2237, 2237, 2536], [2538, 2538, 2561, 2561, 3242], [3244, 3244, 3276, 3276, 3707], [3710, 3710, 3758, 3758, 3991], [3993, 3993, 4040, 4040, 4159], [4161, 4161, 4218, 4218, 5226]], "test": "untested"}
{"id": "XtXfWX", "name": "Plenty of HSV to RGB", "author": "TimoKinnunen", "description": "Various HSV-to-RGB conversion functions. Drag in top part to display a single function or in bottom part to compare two functions. Pause and rewind time for development mode.", "tags": ["spectrum", "rgb", "rainbow", "hsv", "hue", "function", "hsv2rgb", "conversion"], "likes": 13, "viewed": 673, "published": "Public API", "date": "1513478569", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define borderW 10.0\n#define lineW 2.0\n#define dim 0.85\n#define num_f 10.\n\n// From http://blog.saikoled.com/post/45630908157/implementing-arbitrary-color-correction-with-the\nvec3 hsi2rgb(float H, float S, float I) {\n\tfloat r, g, b;\n\tfloat M_PI = radians(180.0);\n\tH = mod(H*360.0, 360.0); // cycle H around to 0-360 degrees\n\tH *= M_PI / 180.0; // Convert to radians.\n\tS = S > 0. ? (S < 1. ? S : 1.) : 0.; // clamp S and I to interval [0,1]\n\tI = I > 0. ? (I < 1. ? I : 1.) : 0.;\n\t// Math! Thanks in part to Kyle Miller.\n\tif(H < 2.09439) {\n\t\tr = I / 3. * (1. + S * cos(H) / cos(1.047196667 - H));\n\t\tg = I / 3. * (1. + S * (1. - cos(H) / cos(1.047196667 - H)));\n\t\tb = I / 3. * (1. - S);\n\t} else if(H < 4.188787) {\n\t\tH -= 2.09439;\n\t\tg = I / 3. * (1. + S * cos(H) / cos(1.047196667 - H));\n\t\tb = I / 3. * (1. + S * (1. - cos(H) / cos(1.047196667 - H)));\n\t\tr = I / 3. * (1. - S);\n\t} else {\n\t\tH -= 4.188787;\n\t\tb = I / 3. * (1. + S * cos(H) / cos(1.047196667 - H));\n\t\tr = I / 3. * (1. + S * (1. - cos(H) / cos(1.047196667 - H)));\n\t\tg = I / 3. * (1. - S);\n\t}\n\treturn vec3(r, g, b);\n}\n// From http://blog.saikoled.com/post/45630908157/implementing-arbitrary-color-correction-with-the\nvec4 hsi2rgbw_4(float H, float S, float I) {\n\tfloat r, g, b, w;\n\tfloat cos_h, cos_1047_h;\n\tfloat M_PI = radians(180.0);\n\tH = mod(H*360.0, 360.0); // cycle H around to 0-360 degrees\n\tH *= M_PI / 180.0; // Convert to radians.\n\tS = S > 0. ? (S < 1. ? S : 1.) : 0.; // clamp S and I to interval [0,1]\n\tI = I > 0. ? (I < 1. ? I : 1.) : 0.;\n\tif(H < 2.09439) {\n\t\tcos_h = cos(H);\n\t\tcos_1047_h = cos(1.047196667 - H);\n\t\tr = S * I / 3. * (1. + cos_h / cos_1047_h);\n\t\tg = S * I / 3. * (1. + (1. - cos_h / cos_1047_h));\n\t\tb = 0.;\n\t\tw = (1. - S) * I;\n\t} else if(H < 4.188787) {\n\t\tH -= 2.09439;\n\t\tcos_h = cos(H);\n\t\tcos_1047_h = cos(1.047196667 - H);\n\t\tg = S * I / 3. * (1. + cos_h / cos_1047_h);\n\t\tb = S * I / 3. * (1. + (1. - cos_h / cos_1047_h));\n\t\tr = 0.;\n\t\tw = (1. - S) * I;\n\t} else {\n\t\tH -= 4.188787;\n\t\tcos_h = cos(H);\n\t\tcos_1047_h = cos(1.047196667 - H);\n\t\tb = S * I / 3. * (1. + cos_h / cos_1047_h);\n\t\tr = S * I / 3. * (1. + (1. - cos_h / cos_1047_h));\n\t\tg = 0.;\n\t\tw = (1. - S) * I;\n\t}\n\treturn vec4(r, g, b, w);\n}\nvec3 hsi2rgbw(float h, float s, float i) {\n\tvec4 col = hsi2rgbw_4(h,s,i);\n\treturn col.rgb+ col.a;\n}\n// Spectrum with 6 distict peaks in hue and 3 in value\nvec3 hsv2rgb_peak6(float h, float s, float v) {\n\tvec3 hueP = max(vec3(0),abs(mod(h* 12.+ vec3( 0, 8,4),12.)- 6.)- 5.);\n\tvec3 hue1 = max(vec3(0),abs(mod(h* 12.+ vec3(11, 7,3),12.)- 6.)- 5.);\n\tvec3 hue2 = max(vec3(0),abs(mod(h* 12.+ vec3( 2,10,6),12.)- 6.)- 5.);\n\tvec3 hue3 = max(vec3(0),abs(mod(h* 12.+ vec3( 1, 9,5),12.)- 6.)- 5.);\n\tvec3 hueF = mat3(3,1,0,0,3,1,1,0,3)* hue1*.25;\n\tvec3 hueC = mat3(1,0,1,1,1,0,0,1,1)* hue2*1.;\n\tvec3 hueL = mat3(3,0,1,1,3,0,0,1,3)* hue3*.25;\n\tvec3 hue = hueP+ hueF+ hueC+ hueL;\n\treturn v* mix(vec3(1),hue,s);\n}\n// Constant brightness but desaturated\nvec3 hsv2rgb_cosine15(float h, float s, float v) {\n\tvec3 hue = .5+ .5* cos((3.* h+ vec3(0,2,1))* radians(120.0));\n\treturn v* mix(vec3(1),clamp(hue,0.,1.),s);\n}\n// Constant brightness but muddy mixes of primary colors\nvec3 hsv2rgb_cosine10(float h, float s, float v) {\n\tvec3 hue = .5*cos(min(vec3(.5),1.5 *abs(fract(h+.5+ vec3(0,2,1)/3.)-0.5))*radians(360.))+ .5;\n\treturn v* mix(vec3(1),clamp(hue,0.,1.),s);\n}\n// Approximates official HSV using cosine\nvec3 hsv2rgb_tricos(float h, float s, float v) {\n\treturn v* mix(vec3(1),clamp(cos(radians(120.)* (3.* h+ vec3(0,2,1)))+ .5,0.,1.),s);\n}\n// Simplified FastLED spectrum implementation\nvec3 hsv2rgb_spectrum(float h, float s, float v) {\n\treturn v* mix(vec3(1),clamp(1.- abs(1.- mod(3.* h+ vec3(1,0,2), 3.)),0.,1.),s);\n}\n// Simplified FastLED rainbow implementation\nvec3 hsv2rgb_rainbow(float h, float s, float v) {\n\tvec3 hue = vec3(0);\n\tfloat x = fract(h) * (8. / 3.) - 1.;\n\tif(x < 0.) {\n\t\thue.x = (-x) + max(0., 1. / 3. - abs(x + (1. / 3.)));\n\t\thue.y = 1. + x;\n\t} else if(x < 1. / 3.) {\n\t\thue.y = 1. - x;\n\t\thue.z = x;\n\t} else if(x < 2. / 3.) {\n\t\thue.y = 1. - (x * 2. - (1. / 3.));\n\t\thue.z = x * 2. - (1. / 3.);\n\t} else {\n\t\thue.x = x - 1. + (1. / 3.);\n\t\thue.z = 1. - (x - 1. + (1. / 3.));\n\t}\n\treturn v* mix(vec3(1),clamp(hue,0.,1.),s);\n}\n\n// Official HSV to RGB conversion\nvec3 hsv2rgb(float h, float s, float v) {\n\treturn v* mix(vec3(1),clamp(abs(mod(h* 6.+ vec3(0,4,2),6.)- 3.)- 1.,0.,1.),s);\n}\nvec3 cubic(vec3 x) {\n\treturn x* x* (3.0- 2.0* x);\n}\n// Smooth HSV to RGB conversion\nvec3 hsv2rgb_smooth(float h, float s, float v) {\n\treturn v* mix(vec3(1),cubic(clamp(abs(mod(h* 6.+ vec3(0,4,2),6.)- 3.)- 1.,0.,1.)),s);\n}\nint uint8_t(int a) {\n\treturn clamp(a,0,255);\n}\nint uint8_t(float a) {\n\treturn uint8_t(int(floor(a* 255.)));\n}\nint scale8(int i, int scale) {\n\treturn i* (1+ scale)>> 8;\n}\nint scale8_video_LEAVING_R1_DIRTY(int i, int scale) {\n\treturn ((i* scale)>> 8)+ ((i!= 0&& scale!= 0)? 1: 0);\n}\nvec3 hsv2rgb_raw_C(float hsvhue,float hsvsat,float hsvval) {\n\t// Convert hue, saturation and brightness ( HSV/HSB ) to RGB\n\t// \"Dimming\" is used on saturation and brightness to make\n\t// the output more visually linear.\n\t// Apply dimming curves\n\tint hue = uint8_t(hsvhue);\n\tint sat = uint8_t(hsvsat);\n\tint val = uint8_t(hsvval);\n\tint value = uint8_t(val);\n\tint saturation = uint8_t(sat);\n\t// The brightness floor is minimum number that all of\n\t// R, G, and B will be set to.\n\tint invsat = uint8_t(255- saturation);\n\tint brightness_floor = uint8_t((value* invsat)/ 256);\n\t// The color amplitude is the maximum amount of R, G, and B\n\t// that will be added on top of the brightness_floor to\n\t// create the specific hue desired.\n\tint color_amplitude = uint8_t(value- brightness_floor);\n\t// Figure out which section of the hue wheel we're in,\n\t// and how far offset we are within that section\n\tint section = uint8_t(hue/ 0x40); // 0..2\n\tint offset = uint8_t(hue% 0x40); // 0..63\n\tint rampUp = uint8_t(offset); // 0..63\n\tint rampDown = uint8_t((0x40- 1)- offset); // 63..0\n\t// We now scale rampUp and rampDown to a 0-255 range -- at least\n\t// in theory, but here's where architecture-specific decisions\n\t// come in to play:\n\t// To scale them up to 0-255, we'd want to multiply by 4.\n\t// But in the very next step, we multiply the ramps by other\n\t// values and then divide the resulting product by 256.\n\t// So which is faster?\n\t//   ((ramp * 4) * otherValue) / 256\n\t// or\n\t//   ((ramp    ) * otherValue) /  64\n\t// It depends on your processor architecture.\n\t// On 8-bit AVR, the \"/ 256\" is just a one-cycle register move,\n\t// but the \"/ 64\" might be a multi-cycle shift process. So on AVR\n\t// it's faster do multiply the ramp values by four, and then\n\t// divide by 256.\n\t// On ARM, the \"/ 256\" and \"/ 64\" are one cycle each, so it's\n\t// faster to NOT multiply the ramp values by four, and just to\n\t// divide the resulting product by 64 (instead of 256).\n\t// Moral of the story: trust your profiler, not your instincts.\n\t// Since there's an AVR assembly version elsewhere, we'll\n\t// assume what we're on an architecture where any number of\n\t// bit shifts has roughly the same cost, and we'll remove the\n\t// redundant math at the source level:\n\t//  // scale up to 255 range\n\t//  //rampUp *= 4; // 0..252\n\t//  //rampDown *= 4; // 0..252\n\t// compute color-amplitude-scaled-down versions of rampUp and rampDown\n\tint rampUp_amp_adj = uint8_t((rampUp* color_amplitude)/ (256/ 4));\n\tint rampDown_amp_adj = uint8_t((rampDown* color_amplitude)/ (256/ 4));\n\t// add brightness_floor offset to everything\n\tint rampUp_adj_with_floor = uint8_t(rampUp_amp_adj+ brightness_floor);\n\tint rampDown_adj_with_floor = uint8_t(rampDown_amp_adj+ brightness_floor);\n\tint rgbr,rgbg,rgbb;\n\tif(section!= 0) {\n\t\tif(section== 1) {\n\t\t\t// section 1: 0x40..0x7F\n\t\t\trgbr = brightness_floor;\n\t\t\trgbg = rampDown_adj_with_floor;\n\t\t\trgbb = rampUp_adj_with_floor;\n\t\t} else {\n\t\t\t// section 2; 0x80..0xBF\n\t\t\trgbr = rampUp_adj_with_floor;\n\t\t\trgbg = brightness_floor;\n\t\t\trgbb = rampDown_adj_with_floor;\n\t\t}\n\t} else {\n\t\t// section 0: 0x00..0x3F\n\t\trgbr = rampDown_adj_with_floor;\n\t\trgbg = rampUp_adj_with_floor;\n\t\trgbb = brightness_floor;\n\t}\n\treturn vec3(rgbr,rgbg,rgbb)/ 255.;\n}\n// Ported FastLED spectrum function\nvec3 hsv2rgb_fl_spectrum(float hsvhue,float hsvsat,float hsvval) {\n\tint hsv2hue = scale8(uint8_t(hsvhue),191);\n\treturn hsv2rgb_raw_C(float(hsv2hue)/ 255.,hsvsat,hsvval);\n}\n// Ported FastLED rainbow function\nvec3 hsv2rgb_fl_rainbow(float hsvhue,float hsvsat,float hsvval) {\n\t// Yellow has a higher inherent brightness than\n\t// any other color; 'pure' yellow is perceived to\n\t// be 93% as bright as white.  In order to make\n\t// yellow appear the correct relative brightness,\n\t// it has to be rendered brighter than all other\n\t// colors.\n\t// Level Y1 is a moderate boost, the default.\n\t// Level Y2 is a strong boost.\n\tint Y1 = uint8_t(1);\n\t// G2: Whether to divide all greens by two.\n\t// Depends GREATLY on your particular LEDs\n\tint G2 = uint8_t(0);\n\t// gScale: what to scale green down by.\n\t// Depends GREATLY on your particular LEDs\n\tint gScale = uint8_t(0);\n\tint hue = uint8_t(hsvhue);\n\tint sat = uint8_t(hsvsat);\n\tint val = uint8_t(hsvval);\n\tint offset = uint8_t(hue& 0x1F); // 0..31\n\t// offset8 = offset * 8\n\tint offset8 = uint8_t(offset);\n\t{\n\t\t// On ARM and other non-AVR platforms, we just shift 3.\n\t\toffset8 <<= 3;\n\t}\n\tint third = uint8_t(scale8(offset8,(256/ 3))); // max = 85\n\tint r,g,b;\n\tif(!((hue& 0x80)!= 0)) {\n\t\t// 0XX\n\t\tif(!((hue& 0x40)!= 0)) {\n\t\t\t// 00X\n\t\t\t//section 0-1\n\t\t\tif(!((hue& 0x20)!= 0)) {\n\t\t\t\t// 000\n\t\t\t\t//case 0: // R -> O\n\t\t\t\tr = 255- third;\n\t\t\t\tg = third;\n\t\t\t\tb = 0;\n\t\t\t} else {\n\t\t\t\t// 001\n\t\t\t\t//case 1: // O -> Y\n\t\t\t\tif(Y1!= 0) {\n\t\t\t\t\tr = 171;\n\t\t\t\t\tg = 85+ third;\n\t\t\t\t\tb = 0;\n\t\t\t\t} else {\n\t\t\t\t\tr = 170+ third;\n\t\t\t\t\tint twothirds = uint8_t(scale8(offset8,((256* 2)/ 3))); // max=170\n\t\t\t\t\tg = 85+ twothirds;\n\t\t\t\t\tb = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t//01X\n\t\t\t// section 2-3\n\t\t\tif(!((hue& 0x20)!= 0)) {\n\t\t\t\t// 010\n\t\t\t\t//case 2: // Y -> G\n\t\t\t\tif(Y1!= 0) {\n\t\t\t\t\tint twothirds = uint8_t(scale8(offset8,((256* 2)/ 3))); // max=170\n\t\t\t\t\tr = 171- twothirds;\n\t\t\t\t\tg = 170+ third;\n\t\t\t\t\tb = 0;\n\t\t\t\t} else {\n\t\t\t\t\tr = 255- offset8;\n\t\t\t\t\tg = 255;\n\t\t\t\t\tb = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 011\n\t\t\t\t// case 3: // G -> A\n\t\t\t\tr = 0;\n\t\t\t\tg = 255- third;\n\t\t\t\tb = third;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// section 4-7\n\t\t// 1XX\n\t\tif(!((hue& 0x40)!= 0)) {\n\t\t\t// 10X\n\t\t\tif(!((hue& 0x20)!= 0)) {\n\t\t\t\t// 100\n\t\t\t\t//case 4: // A -> B\n\t\t\t\tr = 0;\n\t\t\t\tint twothirds = uint8_t(scale8(offset8,((256* 2)/ 3))); // max=170\n\t\t\t\tg = 171- twothirds; //K170?\n\t\t\t\tb = 85+ twothirds;\n\t\t\t} else {\n\t\t\t\t// 101\n\t\t\t\t//case 5: // B -> P\n\t\t\t\tr = third;\n\t\t\t\tg = 0;\n\t\t\t\tb = 255- third;\n\t\t\t}\n\t\t} else {\n\t\t\tif(!((hue& 0x20)!= 0)) {\n\t\t\t\t// 110\n\t\t\t\t//case 6: // P -- K\n\t\t\t\tr = 85+ third;\n\t\t\t\tg = 0;\n\t\t\t\tb = 171- third;\n\t\t\t} else {\n\t\t\t\t// 111\n\t\t\t\t//case 7: // K -> R\n\t\t\t\tr = 170+ third;\n\t\t\t\tg = 0;\n\t\t\t\tb = 85- third;\n\t\t\t}\n\t\t}\n\t}\n\t// This is one of the good places to scale the green down,\n\t// although the client can scale green down as well.\n\tif(G2!= 0) g = g>> 1;\n\tif(gScale!= 0) g = scale8_video_LEAVING_R1_DIRTY(g,gScale);\n\t// Scale down colors if we're desaturated at all\n\t// and add the brightness_floor to r, g, and b.\n\tif(sat!= 255) {\n\t\tif(sat== 0) {\n\t\t\tr = 255;\n\t\t\tb = 255;\n\t\t\tg = 255;\n\t\t} else {\n\t\t\tif(r!= 0) r = scale8(r,sat);\n\t\t\tif(g!= 0) g = scale8(g,sat);\n\t\t\tif(b!= 0) b = scale8(b,sat);\n\t\t\tint desat = uint8_t(255- sat);\n\t\t\tdesat = scale8(desat,desat);\n\t\t\tint brightness_floor = uint8_t(desat);\n\t\t\tr += brightness_floor;\n\t\t\tg += brightness_floor;\n\t\t\tb += brightness_floor;\n\t\t}\n\t}\n\t// Now scale everything down if we're at value < 255.\n\tif(val!= 255) {\n\t\tval = scale8_video_LEAVING_R1_DIRTY(val,val);\n\t\tif(val== 0) {\n\t\t\tr = 0;\n\t\t\tg = 0;\n\t\t\tb = 0;\n\t\t} else {\n\t\t\tif(r!= 0) r = scale8(r,val);\n\t\t\tif(g!= 0) g = scale8(g,val);\n\t\t\tif(b!= 0) b = scale8(b,val);\n\t\t}\n\t}\n\treturn vec3(r,g,b)/255.;\n}\nvec4 total(vec3 f) {\n\treturn vec4(f,f.x+f.y+f.z);\n}\nbool singleMode;\nfloat gain(float i) {\n\treturn .5* iResolution.y- 2.* borderW- (iMouse.x< 10. ? i* 2.5* lineW : 0.);\n}\nfloat off(float i) {\n\treturn borderW+ (iMouse.x< 10. ? i* 2.5* lineW : 0.);\n}\nvec4 rgb;\nvec3 combine(vec3 col, float n) {\n\tif(iMouse.x>= 10.) {\n\t\tif(singleMode) {\n\t\t\tn = 0.;\n\t\t} else if(n> 0.) {\n\t\t\tn = 2.;\n\t\t}\n\t}\n\trgb *= pow(dim,n);\n\tvec3 cols = vec3(.2,.8,.2);\n\tcol = mix(col,cols.zzz,rgb.a);\n\tcol = mix(col,cols.xxy,rgb.b);\n\tcol = mix(col,cols.yxx,rgb.r);\n\tcol = mix(col,cols.xyx,rgb.g);\n\trgb = vec4(0);\n\treturn col;\n}\nvec2 resi,reso,frag;\nfloat sat, val;\nvoid satval(float x) {\n\tsat = 1.0- clamp(iTime,0.,1.)* clamp(sin(iTime* .99+ (frag.x+ x)*resi.x* 2.)+ .255,0.,1.);\n\tval = 1.0- clamp(iTime,0.,1.)* clamp(sin(iTime* .61+ (frag.x+ x)*resi.x* 2.)+ .125,0.,1.);\n}\nvoid plot(float x, float og, vec4 val, vec2 pos) {\n\tfloat o = off(og);\n\tfloat g = gain(og);\n\tvec4 y = o+g*val;\n\tfloat dr = distance(vec2(x,y.r),pos);\n\tfloat dg = distance(vec2(x,y.g),pos);\n\tfloat db = distance(vec2(x,y.b),pos);\n\tfloat da = distance(vec2(x,y.a),pos);\n\tvec4 res = clamp(lineW- vec4(dr,dg,db,da),0.,1.);\n\trgb = max(rgb,res);\n}\nvoid plot(float x, float og, vec3 val, vec2 pos) {\n\tplot(x,og,total(val),pos);\n}\nbool shown(float which) {\n\treturn iMouse.x< 10.\n\t|| floor(fract(iMouse.y/ iResolution.y* 2.)* num_f)== which\n\t|| !singleMode&& floor(iMouse.x/ iResolution.x* num_f)== which;\n}\nvec4 image(vec2 U) {\n\treso = iResolution.xy;\n\tresi = 1./iResolution.xy;\n\tfrag = U;\n\tsingleMode = iMouse.y>= .5* iResolution.y;\n\tsatval(0.);\n\tvec3 col;\n#define FILL(NUM,FUNC) \\\n\tif(frag.y* resi.y>= .5+ .5* (NUM)/ num_f&& shown(NUM)) {\\\n\t\tcol = FUNC(frag.x*resi.x,sat,val);\\\n\t} else\n\tFILL(9.,hsv2rgb_cosine15   )\n\tFILL(8.,hsv2rgb_cosine10   )\n\tFILL(7.,hsv2rgb_fl_spectrum)\n\tFILL(6.,hsv2rgb_fl_rainbow )\n\tFILL(5.,hsi2rgb            )\n\tFILL(4.,hsi2rgbw           )\n\tFILL(3.,hsv2rgb_peak6      )\n\tFILL(2.,hsv2rgb_smooth     )\n\tFILL(1.,hsv2rgb            )\n\tFILL(0.,hsv2rgb_tricos     )\n#undef FILL\n\t{col = vec3(0);}\n\trgb = vec4(0);\n#define PLOT(NUM,FUNC) {\\\n\tif(shown(NUM)) {\\\n\t\tfor(float i = -lineW; i<= lineW; i++) {\\\n\t\t\tsatval(i);\\\n\t\t\tplot(i+ frag.x,NUM,FUNC((frag.x+ i)* resi.x,sat,val),frag);\\\n\t\t}\\\n\t\tcol = combine(col,NUM);\\\n\t}}\n\tPLOT(9.,hsv2rgb_cosine15   )\n\tPLOT(8.,hsv2rgb_cosine10   )\n\tPLOT(7.,hsv2rgb_fl_spectrum)\n\tPLOT(6.,hsv2rgb_fl_rainbow )\n\tPLOT(5.,hsi2rgb            )\n\tPLOT(4.,hsi2rgbw           )\n\tPLOT(3.,hsv2rgb_peak6      )\n\tPLOT(2.,hsv2rgb_smooth     )\n\tPLOT(1.,hsv2rgb            )\n\tPLOT(0.,hsv2rgb_tricos     )\n#undef PLOT\n\treturn vec4(col,1);\n}\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tfragColor = image(fragCoord);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXfWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 174, 215, 215, 1072], [1073, 1172, 1216, 1216, 2178], [2179, 2179, 2221, 2221, 2278], [2279, 2334, 2381, 2381, 2877], [2878, 2917, 2967, 2967, 3076], [3077, 3134, 3184, 3184, 3325], [3326, 3368, 3416, 3416, 3503], [3504, 3550, 3600, 3600, 3683], [3684, 3729, 3778, 3778, 4201], [4203, 4237, 4278, 4278, 4360], [4361, 4361, 4381, 4381, 4412], [4413, 4445, 4493, 4493, 4582], [4583, 4583, 4603, 4603, 4629], [4630, 4630, 4652, 4652, 4692], [4693, 4693, 4723, 4723, 4752], [4753, 4753, 4806, 4806, 4863], [4864, 4864, 4924, 5107, 8089], [8090, 8126, 8192, 8192, 8297], [8298, 8333, 8398, 8739, 11778], [11779, 11779, 11799, 11799, 11830], [11848, 11848, 11869, 11869, 11949], [11950, 11950, 11970, 11970, 12027], [12038, 12038, 12071, 12071, 12370], [12408, 12408, 12430, 12430, 12616], [12617, 12617, 12667, 12667, 12957], [12958, 12958, 13008, 13008, 13038], [13039, 13039, 13064, 13064, 13214], [13215, 13215, 13235, 13235, 13825], [14380, 14380, 14432, 14432, 14465]], "test": "untested"}
{"id": "XtXfzS", "name": "Flame attempt", "author": "harrisonvanderbyl", "description": "flame", "tags": ["flame"], "likes": 8, "viewed": 509, "published": "Public API", "date": "1512202466", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat random (in vec3 _st) {\n    return fract(sin(dot(_st.xyz,\n                         vec3(12.9898,78.233,82.19)))*\n        43758.5453123);\n}\nfloat noise (in vec3 _st) {\n    vec3 i = floor(_st);\n    vec3 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec3(1.0, 0.0,0.0));\n    float c = random(i + vec3(0.0, 1.0,0.0));\n    float d = random(i + vec3(1.0, 1.0,0.0));\n\n    float e = random(i + vec3(0.0, 0.0,1.0));\n    float g = random(i + vec3(1.0, 0.0,1.0));\n    float h = random(i + vec3(0.0, 1.0,1.0));\n    float j = random(i + vec3(1.0, 1.0,1.0));\n    f = (1.0-cos(f*3.1415))/2.0;\n   // f = pow(abs(f-0.5)*2.0,vec3(2.0,2.0,2.0))*0.5*sign(f-0.5)+0.5;\n   // f = (1.0-cos(clamp(f*2.0,0.0,1.0)*3.1415))/4.0+(1.0-cos(clamp(f*2.0-1.0,0.0,1.0)*3.1415))/4.0;\n    \n    // float a1 = mix(a, b, u.x) \n     //       (c - a)* u.y * (1.0 - u.x) +\n     //(d - b) * u.x * u.y;\n     float a1 = mix(a,b,f.x);\n     float a2 = mix(c,d,f.x);\n     float a3 = mix(e,g,f.x);\n     float a4 = mix(h,j,f.x);\n\n     float a5 = mix(a1,a2,f.y);\n     float a6 = mix(a3,a4,f.y);\n\n\n    return mix(a5,a6,f.z);\n}\n\nfloat fbm ( in vec3 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100.0,22.5,44.0);\n    float r = 1.0;\n    for (int i = 0; i < 4; ++i){\n        v += a * noise(_st);\n        r += a;\n        _st =  shift + _st*2.0;\n        _st = (sin(r)*_st+cos(r)*_st);\n        a *= 0.5;\n    }\n    return v;\n}\nvec3 getflame(in vec3 a){\n    vec3 acc = vec3(0.0);\n    float vf = 50.0;\n    for(float i = 0.0;i<vf;i++){\n float b = fbm(a+vec3(0.0,i/10.0,i/vf));\n        float cv = 1.0-i/vf;\n        float c = float(b>cv&&b<1.0);\n        acc+=c*pow(vec3(c*0.35*(1.0-i/vf),0.0,b*0.3*(i/vf)),vec3(2.0,1.0,2.0));\n    }\n   return acc;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy ;\n    vec3 coords = vec3(uv.x*10.0,uv.y*10.0,iTime);\n    vec2 fb1 = vec2(fbm(coords),fbm(coords.yxz));\n    vec2 fb = fb1*3.0+coords.xy;\n    vec3 coords2 = (vec3(floor(fb),iTime));\n    vec2 fb2 = vec2(fbm(coords2),fbm(coords2.zyx));\n    float diff = fbm(coords2) - fbm(coords);\n    \n    \n\tfragColor = vec4(dot(fb2,fb1));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXfzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 29, 29, 144], [145, 145, 172, 172, 1136], [1138, 1138, 1164, 1164, 1450], [1451, 1451, 1476, 1476, 1768], [1770, 1770, 1827, 1827, 2190]], "test": "untested"}
