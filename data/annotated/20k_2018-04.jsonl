{"id": "4d3fD4", "name": "My Oscilloscope", "author": "phrz", "description": "A very poor recreation of an old cathode ray tube oscilloscope in its green beauty.", "tags": ["oscilloscope", "grid", "wave", "green", "sine"], "likes": 3, "viewed": 516, "published": "Public API", "date": "1525058748", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795\n#define border(B,X) smoothstep(B, B+1e-4, X)\n#define saturate(X) clamp(X,0.0,1.0)\n\n#define drawPointX 0.75\n\nvec4 screenColor(float x) {\n\treturn vec4(x*0.75,x,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = fragCoord/iResolution.xy;\n\t\n\tfloat tx = uv.x + iTime * 0.3;\n\tfloat dy = uv.y + 0.2*sin(20.0*tx);\n\tfloat sinLine = saturate(border(0.9999, sin(M_PI * dy)) - (0.75 - uv.x));\n\tif(uv.x > drawPointX) { sinLine = 0.0; }\n\t\n\tfloat hLines = border(0.99, sin(M_PI * uv.y * 20.0 + 0.1));\n\tfloat vLines = border(0.99, sin(M_PI * uv.x * 32.0 + 0.1));\n\tfloat grid = 0.5 * saturate(hLines + vLines);\n\t\n\tfloat drawDot = smoothstep(.88, .89, .9 - length(vec2(uv.x,dy)-vec2(drawPointX,0.5)));\n\t\n\t// Output to screen\n\tfragColor = screenColor(saturate(sinLine + grid + drawDot));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d3fD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 182, 182, 216], [218, 218, 275, 322, 895]], "test": "ok"}
{"id": "4dcfRr", "name": "3D Worley/Voronoise fBm", "author": "chronos", "description": "2D slice through 3D fBm Voronoise through time.", "tags": ["3d", "fractal", "worley", "brownian", "motion", "voronoise"], "likes": 8, "viewed": 262, "published": "Public", "date": "1523900668", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define NUM_OCTAVES 6\n\nvec3 rnd33( vec3 p ) {\n    vec3 q = vec3( dot(p,vec3(127.1,311.7, 109.2)),\n                   dot(p,vec3(269.5,183.3, 432.6)),\n                   dot(p,vec3(419.2,371.9, 304.4)) );\n    return fract(sin(q)*43758.5453);\n}\n\nfloat rnd13( vec3 p ) {\n    return fract(43758.5453*sin(dot(p,vec3(127.1,311.7, 109.2))));\n}\n\nfloat worley3D(vec3 u) {\n    float d = 1e4, a;\n    float acc = 0., acc_w = 0.;\n    vec3 k =  floor(u), f = u-k, p, q = k;\n    const int r = 3;\n    for(int i = -r; i < r; i++) {\n        for(int j = -r; j < r; j++) {\n            for(int l = -r; l < r; l++) {\n\t            vec3 p_i = vec3(i, j, l),\n                     p_f = rnd33(k+p_i);\n        \t    float d = length(p_i - f + p_f);\n            \tfloat w = exp(-8. * d) * (1.-step(sqrt(float(r*r)),d));\n            \tacc += w * rnd13(k+p_i);\n            \tacc_w += w;\n    \t} } }\n    return acc / acc_w;\n}\n\nfloat fbm3D(vec3 u) {\n    float v = 0.;\n    for(int i = 0; i < NUM_OCTAVES; i++) {\n        v += pow(.5, float(i+1)) * worley3D(u);\n        u = 2. * u + 1e3;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n\tvec2 p = uv * 3.;\n    vec3 col = vec3(0.);\n    float t = iTime/3.;\n    float f;\n    #if 0\n    \tcol += fbm3D( vec3(p, iTime/3.) );\n    #elif 0\n    \tcol += fbm3D( vec3(p, t) + \n            \t   vec3( fbm3D(vec3(p, t)+1e3),\n                       \t fbm3D(vec3(p, t)-1e3),\n                         fbm3D(vec3(p, -t))\n                       )\n          \t\t );\n    #elif 1\n    \tcol = vec3( fbm3D(vec3(p, t)+1e3),\n                    fbm3D(vec3(p, t)-1e3),\n                    fbm3D(vec3(p, -t))\n                   );\n    #endif\n            \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dcfRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 46, 46, 243], [245, 245, 268, 268, 337], [339, 339, 363, 363, 890], [892, 892, 913, 913, 1070], [1072, 1072, 1129, 1129, 1735]], "test": "ok"}
{"id": "4dcfW8", "name": "line segment (tuto)", "author": "FabriceNeyret2", "description": "I'm just fed up searching this piece of code again and again, for me or others, so here is once for all  ;-)", "tags": ["lines", "antialiasing", "lissajous", "utils", "tuto", "segments"], "likes": 17, "viewed": 1305, "published": "Public API", "date": "1524818726", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// self-URL: https://www.shadertoy.com/view/4dcfW8\n\n#define S(d,r) smoothstep( r*2./R.y, 0., d)   // antialiased draw. r >= 1.5\n\n// --- line segment with disc ends: seamless distance to segment\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    return length(p - b * h);                         // dist to segment\n    // You might directly return smoothstep( 3./R.y, 0., dist),\n    //     but more efficient to factor all lines.\n    // Indeed we can even return dot(,) and take sqrt at the end of polyline:\n    // p -= b*h; return dot(p,p);\n}\n\n// --- macro version  ( attention: a,b unprotected )\nvec2 _d;\n#define L(a,b) ( _d=b-a, length( U-a - _d * clamp( dot(U-a, _d) / dot(_d, _d), 0., 1.)))\n\n\n// --- line segment without disc ends\n// ( sometime useful with semi-transparency )\nfloat line0(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b),                  // proj coord on line\n          c = clamp(h, 0., 1.);\n    return h==c ? length(p - b * h) : 1e5;            // dist to strict segment\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U = 1.2* ( U+U - R ) / R.y;\n\n    float d = 1e5, t=iTime-4.;\n#define f(x) vec2( sin(6.*x-t) , cos(8.*x-t) ) -.2*sin(x) // func to draw\n    vec2 _P, P=f(0.);\n    for (float x = 0.; x < 4.; x += .03 )\n        d = min(d, line( U, _P = P, P = f(x)) );\n   \n // d = sqrt(d);\n    float width = 1.5 + 10.*(.5-.5*cos(t) );\n    O = sin(t)>0. ? vec4( S( d, width ) )                  // thick smooth line\n                  : vec4( S( d - (width-1.5)/R.y , 1.5) ); // thick dense line\n    O.b += .5*sin(100.*d);                           // bg isovalues\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dcfW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 194, 229, 229, 628], [783, 867, 903, 903, 1114], [1116, 1116, 1154, 1154, 1730]], "test": "ok"}
{"id": "4dcfzr", "name": "Opticazoomiii", "author": "bonofobia", "description": "some optical illusion zoomer", "tags": ["illusion"], "likes": 1, "viewed": 73, "published": "Public", "date": "1523905638", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float bx=6.0+3.0*sin(iTime);\n    float bw=0.04+0.01*cos(iTime*10.0);\n    float col=0.0;\n    float bd=1.0/bx;\n    float cpx=mod(uv.x-2.0*sin(iTime/2.0),bd);\n    float cpy=mod(uv.y-2.0*cos(iTime/2.0),bd);\n    float fx=1.0/(bw/2.0);\n\tif(cpx<(bw/2.0))\n    {\n        col=1.0-(cpx*fx);\n    }\n    else if(cpx>(bd-bw/2.0))\n    {\n        col=1.0-(bd-cpx)*fx;\n    }\n    if(cpy<(bw/2.0))\n    {\n        col+=1.0-(cpy*fx);\n    }\n    else if(cpy>(bd-bw/2.0))\n    {\n        col+=1.0-(bd-cpy)*fx;\n    }\n    // Output to screen\n    fragColor = vec4(col,col,col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dcfzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 704]], "test": "ok"}
{"id": "4ddfDr", "name": "Live-coding #1: Continuum 1", "author": "lsdlive", "description": "Live-coding session I did for a rap music set last week end.\nThis is the part 1 of the shader session, this was prepared before the show.\n\nThanks to Vova 365 VisParis for the music.\nThanks to la Ligne13 Salle de Concerts Saint-Denis.", "tags": ["raymarching", "livecoding"], "likes": 26, "viewed": 536, "published": "Public", "date": "1524744366", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// @lsdlive\n\n// Live-coding session I did for a rap music set last week end.\n// This is the part 1 of the shader session, this was prepared before the show.\n// The code below is almost the code that was on stage at the mid-show,\n// ported from atom-veda to shadertoy.\n\n// Several code snippets you will find, as it or revisited, in this shader:\n// * aiekick's phantom mode - https://www.shadertoy.com/view/MtScWW\n// * balkhan's glow - https://www.shadertoy.com/view/4t2yW1\n// * lj's short octahedron formula - \"float od = dot(q, normalize(sign(q))) - .15;\"\n// * iq & mercury's hglib sdf functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// http://mercury.sexy/hg_sdf/\n// * iq's signed cross sc() - http://iquilezles.org/www/articles/menger/menger.htm\n\n// Thanks to shadertoy community & shader showdown paris, making this possible.\n\n// This is under CC-BY-NC-SA (shadertoy default licence)\n\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sc(vec3 p, float d) {\n\tp = abs(p);\n\tp = max(p, p.yzx);\n\treturn min(p.x, min(p.y, p.z)) - d;\n}\n\nfloat rep(float p, float d) {\n\treturn mod(p - d*.5, d) - d*.5;\n}\n\nvec3 rep(vec3 p, float d) {\n\treturn mod(p - d*.5, d) - d*.5;\n}\n\nfloat dt = 0.;\nfloat g = 0.;\nfloat de(vec3 p) {\n\n\tvec3 q = p;\n\tfloat t = iTime*8.6*2.;\n\tfloat s = t*.1 + sin(t)*.1;\n\tq.xy += vec2(cos(iTime)*sin(iTime)*.3, sin(iTime)*.3);\n\tq.z -= dt + sin(iTime);\n\tq.xz *= r2d(iTime);\n\tq.xy *= r2d(iTime);\n\tfloat od = dot(q, normalize(sign(q))) - .15;\n\n\tfloat pl = p.y + .6;\n\n\tq = p;\n\t//q.y+=.2;\n\tq.x += sin(q.z + iTime)*.6;\n\tq.y += cos(q.z + iTime*2.)*.6;\n\tfloat cyl = length(q.xy) - .02;\n\n\tq = p;\n\tq += iTime*.2;\n\tq.xy += sin(q.z*.4)*2.;\n\tq = rep(q, 1.);\n\tfloat s1 = length(q) - .002 + sin(iTime*30.)*.002;\n\n\n\tp.z = rep(p.z, 2.);\n\n\tfloat sc2 = sc(p, .4);\n\n\tp.x = abs(p.x) - 2.;\n\tp.xy *= r2d(3.14*.25);\n\tfloat sc1 = sc(p, .3);\n\n\tfloat d = min(sc1, pl);\n\td = max(d, -sc2);\n\td = min(d, od);\n\td = min(d, cyl);\n\td = min(d, s1);\n\n\tg += .01 / (.01 + d*d);\n\treturn d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tdt = iTime*2.;\n\n\tvec3 ro = vec3(0, 0, -3. + dt);\n\tvec3 ta = vec3(0, 0, 0. + dt);\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = cross(vec3(0, 1, 0), fwd);\n\tvec3 up = cross(fwd, left);\n\tvec3 rd = normalize(fwd + left*uv.x + up*uv.y);\n\n\t//rd.xy *= r2d(sin(iTime*.5)*.3);\n\n\tvec3 p;\n\tfloat t = 0., ri;\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tri = i;\n\t\tp = ro + rd*t;\n\t\tfloat d = de(p);\n\t\t//if (d < .001) break;\n\t\td = max(abs(d), .0002);\n\t\tt += d*.3;\n\t}\n\n\tvec3 c = mix(vec3(.6, .3, .3), vec3(0), abs(p.x*p.y) + ri);\n\tc += g*.01;\n\tfragColor = vec4(c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddfDr.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[922, 922, 941, 941, 1001], [1003, 1003, 1030, 1030, 1102], [1104, 1104, 1133, 1133, 1168], [1170, 1170, 1197, 1197, 1232], [1263, 1263, 1281, 1281, 2030], [2032, 2032, 2087, 2087, 2724]], "test": "ok"}
{"id": "4ddfzH", "name": "Eyeball Explosion", "author": "nr4", "description": "Polar coords / sdf and rotating colors. Also lowfreq noise with smoothstep.", "tags": ["2d", "noise", "sdf", "colors"], "likes": 8, "viewed": 304, "published": "Public", "date": "1524089167", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Eyeball Explosion\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst float pi = acos(-1.);\nconst vec2 c = vec2(1.,0.);\n\nfloat rand(vec2 a0)\n{\n    return fract(sin(dot(a0.xy ,vec2(12.9898,78.233)))*43758.5453);\n}\n\nfloat smoothstep_noise(float x)\n{\n    float r1 = -1.+2.*rand(floor(x)*c.xx), r2 = -1.+2.*rand(ceil(x)*c.xx);\n    return mix(r1, r2, smoothstep(.25, .75, fract(x)));\n}\n\nfloat mfsmoothstep_noise(float x, float f0, float f1, float phi)\n{\n    float sum = 0.;\n    float a = 1.;\n    \n    for(float f = f0; f<f1; f = f*2.)\n    {\n        sum = a*smoothstep_noise(f*x) + sum;\n        a = a*phi;\n    }\n    \n    return sum;\n}\n\nvec2 rot(vec2 x, float p)\n{\n    return mat2(cos(p), sin(p), -sin(p), cos(p))*x;\n}\n\nmat3 rot(vec3 p)\n{\n    vec3 cp = cos(p), sp = sin(p);\n    mat3 m = mat3(cp.y*cp.x, cp.x*sp.z+cp.z*sp.x*sp.y, sp.x*sp.z-cp.x*cp.z*sp.y, \n           -cp.y*sp.z, cp.x*cp.z-sp.x*sp.y*sp.z, cp.z*sp.x+cp.x*sp.y*sp.z, \n           sp.y, -cp.y*sp.x, cp.x*cp.y);\n    return m;\n}\n\nfloat rect(vec2 x, vec2 b)\n{\n    return length(max(abs(x)-b,0.));\n}\n\nvec3 synthcol(float scale, float phase)\n{\n    vec3 c2 = vec3(207.,30.,102.)/255.,\n        c3 = vec3(245., 194., 87.)/255.;\n    mat3 r1 = rot((5.e-1*phase)*vec3(1.1,1.3,1.5));\n    return \n        (\n            1.1*mix\n            (\n                -(cross(c2, r1*c2)),\n                -(r1*c2), \n                scale\n            )\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy-.5-.33*c.xy;\n    uv = rot(uv, .25*iTime);\n    \n    vec4 sdf = vec4(0., c.yyy);\n    \n    float N = 128.,\n        r_inner = .2;\n    \n    for(int i=0; i<12; ++i)\n    {\n        uv = rot(uv, 1.1);\n        vec2 p = vec2(length(uv), atan(uv.y/uv.x)-float(i)*.1*iTime),\n        q = vec2(p.x-.05*float(i), mod(p.y, 2.*pi/N)-pi/N),\n        q0 = vec2(r_inner, q.y);\n    \n    \tfloat index = (p-q).y;\n        \n        r_inner = .2+float(i)*.005+ .0005*12.;\n        \n        float dr = .1*mfsmoothstep_noise(index-iTime-4.*float(i), 1., 100., .45) + .05*rand(index*c.xx+.2*c.yx),\n            len = abs(.005*float(i)+dr),\n            width = abs(.015+.005*rand(index*c.xx+.4));\n\n        vec4 sda = vec4(rect(q-r_inner*c.xy, len*c.xy+width*c.yx), synthcol(((q.x-r_inner)/.05+(q.y/2./pi)), iTime+sin(iTime+1.*float(i))));\n        sdf = mix(sdf, sda, step(sda.x, sdf.x));\n    }\n    \n    vec3 col = sdf.gba*step(sdf.x, 0.);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddfzH.jpg", "access": "shaders20k", "license": "gpl-3.0-plus", "functions": [[796, 796, 817, 817, 887], [889, 889, 922, 922, 1055], [1057, 1057, 1123, 1123, 1303], [1305, 1305, 1332, 1332, 1386], [1388, 1388, 1406, 1406, 1656], [1658, 1658, 1686, 1686, 1725], [1727, 1727, 1768, 1768, 2070], [2072, 2072, 2129, 2129, 3107]], "test": "error"}
{"id": "4dGcWd", "name": "hungry Caterpillar", "author": "vapoi", "description": "This is the walking animation of the main character in my new Video:\n\n\"2 Minutes and 36 Pixels in the life of a graphic programmer\"\nwww.youtube.com/watch?v=BgF8_HwbNjA\n\nenjoy coding :)", "tags": ["2d", "simple", "bug", "caterpillar"], "likes": 5, "viewed": 399, "published": "Public API", "date": "1523658938", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float fPi = 3.14159;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 pMid = vec2(-1.0, -2.0) + uv * vec2(6.0, 4.0);\n    \n    float fTime = iTime + 25.0;\n    \n\tvec2 pPixel = pMid * 100.0;\n\tvec2 pPixelRaw = pPixel;\n\t\n\tpPixel.y *= 1.0;\n\tvec2 dotPos;\n\tfloat fNearestDot = 100.0;\n    \n    float animCycle = fract(fTime * 0.333);\n    float animCycles = floor(fTime * 0.333);\n    animCycles -= floor(animCycles / 21.0) * 21.0;\n    animCycles -= 5.0;\n    \n\tfloat moveStep01 = 0.5 * (1.0 + cos(fPi + fPi * smoothstep(0.3, 1.0, animCycle)));\n\tfloat moveStep = 0.85 * max(0.0, sin(fPi * moveStep01));\n    pPixel.x -= moveStep01 * 39.0 + animCycles * 39.0;\n    \n\t// Standard-Bend + idle-Animation + extra value while walking (=more dynamic walking animation)\n\tfloat fBreath = 0.25 + 0.065 * sin(fTime * 1.0 + 2.5 * sign(moveStep01));\n\t\n\tfloat fDot01 = 0.0;\n\t\n\tfloat fHair = 0.0;\n\tfloat fAllHairs = 0.0;\n\tfloat sinStep = 0.0;\n\t\n\tfloat hairBend = 0.0;\n\t\n\tfloat rotateAlpha = 0.6;\n\tfloat weightedAlpha = 0.0;\n\t\n\tvec2 dotPixel;\n\tvec2 v2Step;\n\t\n\t\n\tfor (int i = 0; i < 8; i++)\n\t{\n\n\t\tfDot01 = float(i) / 7.0;\n\t\t\n\t\t\n\t\tdotPos = vec2(-80.0 + float(i) * 20.0, 0.0);\n\t\t\n\t\t\n\t\t// MoveStep Main Curve\n\t\t//sinStep = 60.0 * (fBreath + moveStep) * cos(-fPi * 0.5 + (i - 0.24) * 0.45) \n\t\t//\t\t + 9.0 * (fBreath * 1.5 + moveStep) * cos(i * 0.5 + moveStep * 1.3);\n\t\tsinStep = 60.0 * (fBreath + moveStep) * cos(-fPi * 0.5 + (fDot01 - 0.03) * fPi) \n\t\t\t\t + 9.0 * (fBreath * 1.5 + moveStep) * cos(fDot01 * 3.5 + moveStep * 1.3);\n\t\tv2Step = vec2(0.0, sinStep);\n\t\t// MoveStep delayed front-up\n\t\tv2Step += vec2(7.0, 14.0) * sin(fPi * smoothstep(0.4, 1.0, moveStep01)) * sin(max(0.0, 0.5 * fPi - (1.0 - fDot01) * 5.0));\n\t\tv2Step += vec2(6.0, 15.0) * sin(fPi * smoothstep(0.4, 1.0, 1.0 - moveStep01)) * sin(max(0.0, 0.5 * fPi - fDot01 * 4.0));\n\t\t// MoveStep, Contraction\n\t\tdotPos += v2Step;\n\t\tdotPos.x *= 1.0 - 0.3 * moveStep;\n\t\t\n\t\tdotPixel = pPixel - dotPos;\n\t\t\n\t\t\n\t\t\n\t\t// Haare\n\t\thairBend = moveStep * 1.30 * (-fDot01 + 0.5);\n\t\tfHair = 1.0 * (max(0.0, -abs(dotPixel.x + hairBend * dotPixel.y) + 5.0) / 4.5) *\n\t\t\t\t(max(0.0, -abs(dotPixel.y - 16.0) + 13.0) / 10.0);\n\t\t\t\t//(clamp((50.0 - max(-10.0, dotPixel.y)) * 0.05, 0.0, 1.0) ) * sign(max(0.0, dotPixel.y));\n\t\t\t\t\n\t\tfAllHairs = max(fAllHairs, min(1.0, fHair));\n\t\t\n\t\t// Leg\n\t\tdotPixel += vec2(0.0, max(0.0, -abs(dotPixel.x) + 6.5) * ( clamp(-dotPixel.y - 6.0, 1.00, 4.0)) * 0.250);\n\t\t\n\t\tfNearestDot = min(fNearestDot, length(dotPixel));\n\t}\n\t\n\tfloat fSkin = smoothstep(-25.0, -7.0, -fNearestDot);\n\tfloat fInnen = smoothstep(-13.0, -2.0, -fNearestDot);\n\t\n\tvec3 colSkin = vec3(0.25, 0.6, 0.1);\n\tvec3 colInnen = vec3(1.0);\n\tvec3 colHair = vec3(0.6, 0.2, 0.05);\n\tvec3 colFin = mix(colSkin - vec3(0.5) * smoothstep(-4.5, 0.20, -fNearestDot), colHair, fAllHairs) + colInnen * 0.3 * fInnen;\n\t\n\tfloat fValue = max(fAllHairs, fSkin);\n    \n    vec3 colLine = vec3(0.5) * smoothstep(-0.05, 0.0, -abs(pMid.y + 0.25));\n\tfragColor = vec4(colLine + colFin * fValue, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGcWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 85, 85, 3039]], "test": "ok"}
{"id": "4dGcWt", "name": "simple crosshair", "author": "laserdog", "description": "nothing fancy, just testing out a UI effect for my game.", "tags": ["game", "ui"], "likes": 3, "viewed": 184, "published": "Public", "date": "1523639878", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define pi 3.14159265359\n\nfloat rr(vec2 uv, float halfExtent, float borderRadius, float anim)\n{\n    halfExtent += sin(iTime * 6.) * .05 * anim;\n    return smoothstep(.02, .01, \n                      length(max(abs(uv) - halfExtent, 0.)) - borderRadius);\n}\n\nfloat outerNotch(vec2 uv, float angle) \n{\n    const float notchSize = .045;\n    const float skew = 1.3;\n    uv *= rot(angle);\n    uv.y -= .55 + sin(iTime * 12.) * .095;\n    uv.x /= ((uv.y + notchSize) / (2. * notchSize)) * (skew - 1.) + 1.;\n    uv.y /= 2.75;\n    return smoothstep(.018, .01, length(max(abs(uv) - notchSize, 0.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float inner = rr(uv, .18, .02, 1.) * (1. - rr(uv, .12, .02, 1.));\n    float dawt = rr(uv, .03, .02, 0.);\n    float notch = outerNotch(uv, 0.) + outerNotch(uv, pi / 2.)\n        + outerNotch(uv, pi) + outerNotch(uv, 1.5 * pi);\n    fragColor.rgb = (notch + dawt + inner + rr(uv, .35, .05, 1.) * (1. - rr(uv, .275, .05, 1.))\n        * step(.15, min(abs(uv.x), abs(uv.y)))) * vec3(0., 1., 0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGcWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 148, 148, 308], [310, 310, 351, 351, 642], [644, 644, 701, 701, 1158]], "test": "ok"}
{"id": "4dGyRc", "name": "noisy Sphere", "author": "nawafuji", "description": "Tested noise function for sphere ", "tags": ["practice"], "likes": 2, "viewed": 91, "published": "Public", "date": "1522724171", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Sebastien Durand - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define U(a,b) (a.x*b.y-b.x*a.y)\n\nconst float PI = 3.14159265359;\nconst float ONE_OVER_PI = 1.0/PI;\n\nfloat noiseScaleIn = 10.0;\nfloat noiseScaleOut = 0.5;\n// rolled brass\n/*\nconst vec2 lo = vec2(0.100, 0.330);\nconst vec2 alpha= vec2(0.050, 0.160);\nconst vec3 Scale = vec3(1.0, 1.0, 1.0);\nvec3 surfaceColor = vec3(1.0,0.62,0.31);\n*/\n\n// semi-gloss paint, rolled\n\nconst vec2 lo = vec2(0.450, 0.048);\nconst vec2 alpha = vec2(0.045, 0.068);\nconst vec3 Scale = vec3(1.0, 20.0, 10.0);\nvec3 surfaceColor = vec3(0.45,0.54,1.0);\n\n\n// lightly brushed aluminum\n/*\nconst vec2 lo = vec2(0.150, 0.190);\nconst vec2 alpha = vec2(0.088, 0.130);\nconst vec3 Scale = vec3(2.0, 2.0, 2.0);\nvec3 surfaceColor = vec3(1.0,0.99,1.0);\n*/\n\n// white ceramic tile\n/*\nconst vec2 lo = vec2(0.700, 0.050);\nconst vec2 alpha = vec2(0.071, 0.071);\nconst vec3 Scale = vec3(1.0, 10.0, 10.0);\nvec3 surfaceColor = vec3(1.0,1.0,1.0);\n*/\n\nvec2 A[15];\nvec2 T1[5];\nvec2 T2[5];\n\nconst vec3 L = normalize(vec3(1,.72, 1)), Y = vec3(0,1,0), E = Y*.01;\n\nfloat tMorph;\nmat2 mat2Rot;\n\n// Distance to Bezier\n// inspired by [iq:https://www.shadertoy.com/view/ldj3Wh]\n// calculate distance to 2D bezier curve on xy but without forgeting the z component of p\n// total distance is corrected using pytagore just before return\nvec2 B(vec2 m, vec2 n, vec2 o, vec3 p) {\n\tvec2 q = p.xy;\n\tm-= q; n-= q; o-= q;\n\tfloat x = U(m, o), y = 2. * U(n, m), z = 2. * U(o, n);\n\tvec2 i = o - m, j = o - n, k = n - m, \n\t\t s = 2. * (x * i + y * j + z * k), \n\t\t r = m + (y * z - x * x) * vec2(s.y, -s.x) / dot(s, s);\n\tfloat t = clamp((U(r, i) + 2. * U(k, r)) / (x + x + y + z), 0.,1.); // parametric position on curve\n\tr = m + t * (k + k + t * (j - k)); // distance on 2D xy space\n\treturn vec2(sqrt(dot(r, r) + p.z * p.z), t); // distance on 3D space\n}\n\n            \n\nfloat smin(float a, float b, float k){\n    float h = clamp(.5+.5*(b-a)/k, 0., 1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\n\n//#define METHOD_2\n\nvoid basis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n#if defined(METHOD_2)\n  // method 2a variant\n  float sz = n.z >= 0.0 ? 1.0 : -1.0;\n  float a  =  n.y/(1.0+abs(n.z));\n  float b  =  n.y*a;\n  float c  = -n.x*a;\n    \n  xp = vec3(n.z+sz*b, sz*c, -n.x);\n  yp = vec3(c, 1.0-b, -sz*n.y);\n#else\n    \n  // method 1: ignoring n approaching -z\n#if 1\n  float a =  n.y/(1.0+n.z);\n  float b =  n.y*a;\n  float c = -n.x*a;\n    \n  xp = vec3(n.z+b, c, -n.x);\n  yp = vec3(c, 1.0-b, -n.y);\n    \n#else\n    \n  // nimitz's impl of frisvad\n  float a = 1./(1. + n.z);\n  float b = -n.x*n.y*a;\n  xp = vec3(1. - n.x*n.x*a, b, -n.x);\n  yp = vec3(b, 1. - n.y*n.y*a , -n.y);\n#endif\n#endif\n}\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l, vec3 e, vec3 h, vec3 surfaceColor, vec3 lightColor){\n \n    vec3 lightVector = l;\n    vec3 eyeVector = e;\n    vec3 halfVector = h;\n    \n    float nDotLV = max(0.0, dot(lightVector, n));\n    float nDotHV = max(0.0, dot(halfVector, n));\n  \n    float attenuation = 1.0;\n    float shininess = 10.0;\n    float pf;\n    if(nDotLV == 0.0)\n        pf = 0.0;\n \telse\n        pf = pow(nDotHV, shininess);\n    \n    vec3 ambient = vec3(0.1) * attenuation;\n    vec3 diffuse = vec3(1.0,1.0,1.0) * nDotLV * attenuation;\n    vec3 specular = vec3(1.0,1.0,1.0) * pf * attenuation*1.0;\n    return min(((ambient + diffuse)*surfaceColor + specular * vec3(1.0)) * lightColor, vec3(1.0));\n}\n\nvec3 computeBRDF(vec3 n, vec3 l, vec3 h, vec3 r, vec3 t, vec3 b, vec2 p, vec2 a, vec3 s, vec3 color){\n    \n    float e1, e2, E, cosThetaI, cosThetaR, brdf, intensity;\n    \n    e1 = dot(h,t)/a.x;\n    e2 = dot(h,b)/a.y;\n    E = -2.0*((e1*e1+e2*e2)/(1.0+dot(h,n)));\n    \n    cosThetaI = dot(n,l);\n    cosThetaR = dot(n,r);\n    \n    brdf = p.x * ONE_OVER_PI + p.y * (1.0 / sqrt(cosThetaI * cosThetaR)) * ( 1.0 / (4.0 * PI * a.x * a.y)) * exp(E);\n    \n    intensity = s[0] * p.x * ONE_OVER_PI + s[1] * p.y * cosThetaI * brdf + s[2] * dot(h,n) * p.y;\n    return intensity * color;\n}   \n\nfloat cube(vec3 p){\n    float s = 1.0;\n    vec3 d = abs(p) - vec3(s);\n    return min(max(d.x, max(d.y,d.z)), 0.0)\n        + length(max(d,0.0));\n}\n\nfloat sphere(vec3 p){\n    return length(vec3(0.0) - p) - 1.0;\n}\n\nfloat teapot(vec3 p){\n    \n// Distance to Teapot --------------------------------------------------- \n\t// precalcul first part of teapot spout\n\tvec2 h = B(T1[2],T1[3],T1[4], p);\n\tfloat a = 99., \n    // distance to teapot handle (-.06 => make the thickness) \n\t\tb = min(min(B(T2[0],T2[1],T2[2], p).x, B(T2[2],T2[3],T2[4], p).x) - .06, \n    // max p.y-.9 => cut the end of the spout \n                max(p.y - .9,\n    // distance to second part of teapot spout (abs(dist,r1)-dr) => enable to make the spout hole \n                    min(abs(B(T1[0],T1[1],T1[2], p).x - .07) - .01, \n    // distance to first part of teapot spout (tickness incrase with pos on curve) \n                        h.x * (1. - .75 * h.y) - .08)));\n\t\n    // distance to teapot body => use rotation symetry to simplify calculation to a distance to 2D bezier curve\n    vec3 qq= vec3(sqrt(dot(p,p)-p.y*p.y), p.y, 0);\n    // the substraction of .015 enable to generate a small thickness arround bezier to help convergance\n    // the .8 factor help convergance  \n\tfor(int i=0;i<13;i+=2) \n\t\ta = min(a, (B(A[i], A[i + 1], A[i + 2], qq).x - .015) * .7); \n    // smooth minimum to improve quality at junction of handle and spout to the body\n\tfloat dTeapot = smin(a,b,.02);\n    return dTeapot;\n}\n\n// Distance to scene\nfloat M(vec3 p) {\n\n    //float dTeapot = teapot(p);\n    float dSphere = sphere(p);\n    \n    //float dCube = cube(p);\n\t// !!! The morphing is here !!!\n    //return mix(dCube, dSphere, abs(sin(iTime)));\n    //return dSphere + noise3(p + vec3(abs(sin(iTime)), 0, 0));\n    return dSphere + texture(iChannel0, p.xy * noiseScaleIn + vec2(iTime,iTime)).r * noiseScaleOut;\n}\n\n// HSV to RGB conversion \n// [iq: https://www.shadertoy.com/view/MsS3Wc]\nvec3 hsv2rgb_smooth(float x, float y, float z) {\n    vec3 rgb = clamp( abs(mod(x*6.+vec3(0.,4.,2.),6.)-3.)-1., 0., 1.);\n\trgb = rgb*rgb*(3.-2.*rgb); // cubic smoothing\t\n\treturn z * mix( vec3(1), rgb, y);\n}\n\nvec3 normal(in vec3 p, in vec3 ray, in float t) {\n\tfloat pitch = .4 * t / iResolution.x;\n\t\n    vec2 d = vec2(-1,1) * pitch;\n    \n\tvec3 p0 = p+d.xxx; // tetrahedral offsets\n\tvec3 p1 = p+d.xyy;\n\tvec3 p2 = p+d.yxy;\n\tvec3 p3 = p+d.yyx;\n\t\n\tfloat f0 = M(p0);\n\tfloat f1 = M(p1);\n\tfloat f2 = M(p2);\n\tfloat f3 = M(p3);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - p*(f0+f1+f2+f3);\n\t//return normalize(grad);\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat aa=3.14159/4.;\n\tmat2Rot = mat2(cos(aa),sin(aa),-sin(aa),cos(aa));\n\t\n\t// Teapot body profil (8 quadratic curves) \n\tA[0]=vec2(0,0);A[1]=vec2(.64,0);A[2]=vec2(.64,.03);A[3]=vec2(.8,.12);A[4]=vec2(.8,.3);A[5]=vec2(.8,.48);A[6]=vec2(.64,.9);A[7]=vec2(.6,.93);\n    A[8]=vec2(.56,.9);A[9]=vec2(.56,.96);A[10]=vec2(.12,1.02);A[11]=vec2(0,1.05);A[12]=vec2(.16,1.14);A[13]=vec2(.2,1.2);A[14]=vec2(0,1.2);\n\t// Teapot spout (2 quadratic curves)\n\tT1[0]=vec2(1.16, .96);T1[1]=vec2(1.04, .9);T1[2]=vec2(1,.72);T1[3]=vec2(.92, .48);T1[4]=vec2(.72, .42);\n\t// Teapot handle (2 quadratic curves)\n\tT2[0]=vec2(-.6, .78);T2[1]=vec2(-1.16, .84);T2[2]=vec2(-1.16,.63);T2[3]=vec2(-1.2, .42);;T2[4]=vec2(-.72, .24);\n\n\t// Configure camera\n\tvec2 r = iResolution.xy, m = iMouse.xy / r,\n\t     q = fragCoord.xy/r.xy, p =q+q-1.;\n\tp.x *= r.x/r.y;\n\tfloat j=.0, s=1., h = .1, t=5.+.2*iTime + 4.*m.x;\n\tvec3 o = 2.9*vec3(cos(t), .7- m.y,sin(t)),\n\t     w = normalize(Y * .4 - o), u = normalize(cross(w, Y)), v = cross(u, w),\n         d = normalize(p.x * u + p.y * v + w+w), n, x;\n\t\t\t\n\t// Ray marching\n\tt=0.;\n    for(int i=0;i<48;i++) { \n\t\tif (h<.0001 || t>4.7) break;\n        t += h = M(o + d*t);\n    }\n    \n\t// Background colour change as teapot complementaries colours (using HSV)\n\tvec3 c = mix(hsv2rgb_smooth( .5+iTime*.02,.35,.4), \n\t\t\t \t hsv2rgb_smooth(-.5+iTime*.02,.35,.7), q.y);\n\t\t\n    // Calculate color on point\n\tif (h < .001) {\n\t\tx = o + t * d;\n\t\tn = normal(x,d,t);//normalize(vec3(M(x+E.yxx)-M(x-E.yxx),M(x+E)-M(x-E),M(x+E.xxy)-M(x-E.xxy)));\n\n        vec3 N = n;\n        vec3 V = normalize(o-x);\n        vec3 H = normalize(L+V);\n        vec3 R = normalize(reflect(-L, N));\n        \n        vec3 T;\n        vec3 B;\n        \n        basis(N,T,B);\n       // vec3 T = normalize(vec3(-N.y, N.x, 0));\n        //vec3 B = normalize(cross(N,T));\n        \n            \n        //vec3 pixelColor = computeLambert(x, N, L, V, H, vec3(0,0.0,1.0), vec3(1.0));\n\t\tvec3 pixelColor = computeBRDF(N,L,H,R,T,B,lo,alpha,Scale,surfaceColor);\n        \n\t\t// Calculate Shadows\n\t\tfor(int i=0;i<20;i++){\n\t\t\tj += .02;\n\t\t\ts = min(s, M(x+L*j)/j);\n\t\t}\n\t\t// Teapot color rotation in HSV color space\n\t\tvec3 c1 = hsv2rgb_smooth(.9+iTime*.02, 1.,1.); \n\t\t// Shading\n\t    c = pixelColor;\n        //mix(c,mix(sqrt((clamp(3.*s,0.,1.)+.3)*c1),\n\t\t//\t          vec3(pow(max(dot(reflect(L,n),d),0.),99.)),.4),2.*dot(n,-d));\n\t} \n\n\tc *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .16); // Vigneting\n\tfragColor=vec4(c,1);\t\n\t\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGyRc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1160, 1395, 1435, 1435, 1901], [1917, 1917, 1955, 1955, 2035], [2058, 2058, 2107, 2107, 2717], [2719, 2719, 2815, 2815, 3427], [3429, 3429, 3530, 3530, 4005], [4010, 4010, 4029, 4029, 4155], [4157, 4157, 4178, 4178, 4220], [4222, 4222, 4243, 4364, 5478], [5480, 5501, 5518, 5552, 5867], [5869, 5942, 5990, 5990, 6146], [6148, 6148, 6197, 6197, 6673], [6676, 6676, 6733, 6733, 9186]], "test": "error"}
{"id": "4dGyzt", "name": "Spiny poly", "author": "Michael_Manning", "description": "The shimmer effect is by Pr0fed https://www.shadertoy.com/view/XdyyRK .\n\nUnlike my last shader, this uses just 1 shape per layer for the drop shadow. The color is based on the shape layer number.  I couldn't get anti aliasing to work because of this.", "tags": ["noise", "rotation", "polygon"], "likes": 14, "viewed": 378, "published": "Public", "date": "1523031219", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Time simplification and easier overall speed control.\n#define speed 0.6\n#define scaleCo 0.25\n#define rotation 1.4\n#define angleOffset 0.0\n#define intensity 2.1\n#define polygonSides 5\n#define staticShadows true\n//the result of the offset it affected by the speed\n#define outerOffset 1.5 \n\n\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n\n\n//controlls the transition state from static to warped shadows\nint shadowToggle = 1;\n\n//delays the shimmer effect in time between polygon layers to create contrast\nfloat timeOffset = 0.0;\n\n//the polygon being worked on (0 - 20)\nfloat shapeI = 0.0;\n\n\n//Most of the shimmer pattern code is by Pr0fed https://www.shadertoy.com/view/XdyyRK\nconst mat2 m = mat2( 1.40,  1.00, -1.00,  1.40 );\n\nvec2 hash( vec2 x )  \n{\n    const vec2 k = vec2( 0.318653, 0.3673123 );\n    x = x * k + k.yx;\n    return smoothstep(0.0, 1.35, -1.0 + 2.0 * fract( 16.0 * k * fract( x.x * x.y * (x.x + x.y))));\n}\n\n// 2D gradient noise\nfloat noise2D( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat r(float n)\n{\n \treturn fract(cos(n*72.42)*173.42);\n}\n\nvec2 r(vec2 n)\n{\n \treturn vec2(r(n.x*63.62-234.0+n.y*84.35),r(n.x*45.13+156.0+n.y*13.89)); \n}\n\nfloat worley2D(in vec2 n)\n{\n    float dis = 2.0;\n    for (int y= -1; y <= 1; y++) \n    {\n        for (int x= -1; x <= 1; x++) \n        {\n            // Neighbor place in the grid\n            vec2 p = floor(n) + vec2(x,y);\n\n            float d = length(r(p) + vec2(x, y) - fract(n));\n            if (dis > d)\n            {\n             \tdis = d;   \n            }\n        }\n    } \n    return 1.0 - dis;\n}\n\n// Four octave worley FBM.\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000 * worley2D( p ); p = p * 2. * m;\n    f += 0.2500 * worley2D( p ); p = p * 2. * m;\n    f += 0.1250 * worley2D( p ); p = p * 2. * m;\n    f += 0.0625 * worley2D( p );\n    return f;\n}\n\n// Six octave perlin FBM.\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.250000 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.125000 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.062500 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.031250 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.015625 * (0.5 + 0.5 * noise2D( p ));\n    return f;\n}\n\nfloat GetFBM( vec2 q, out vec4 ron, out vec2 rk)\n{\n    // First layer.\n    vec2 o = vec2(fbm4(q + fbm6( vec2(2.0 * q + vec2(6.)))));\n\n    // Second layer.\n    vec2 n = vec2(fbm6(q + fbm4( vec2(2.0 * o + vec2(2.)))));\n    \n    //The shimmer transition is controlled by white circles that expand outwards   \n    vec2 k  = vec2( 0.55* sin(1.0 * (length(q) + 1.9* -(iTime - shapeI * 0.7)) + 1.0));\n    \n    // Sum of points with increased sharpness. \n    vec2 p = 4.0 * o + 6.0 * n + 8.0 * k ;\n    float f = 0.5 + 0.5 * fbm6( p ) ;\n\n    f = mix( f, f * f * f * 3.5, f * abs(n.y));\n\n    f *= 1.0 - 0.55 * pow( f, 8.0 );\n    \n\tron = vec4( o, n );\n    \n    rk = vec2(k);\n\n    return f;\n}\n\n// I made this, monochrome, but the original settings are still the best \nfloat GetShimmer(vec2 p)\n{\n    vec4 on = vec4(0.0);\n    vec2 k = vec2(0.0);\n    \n    float f = GetFBM(p, on, k);\n    \n    vec3 col = vec3(0.0);\n    \n    // Our 'background' bluish color.\n    col = mix( vec3(1.0), vec3(0.0), f );\n    \n    // Dark orange front layer.\n    col = mix( col, vec3( 0.0), dot(on.xy, on.zw));\n    \n    \n   \n    col = (col * col * 7. * 0.4545);\n    return col.x;\n}\n\n//from thebookofshaders.com/07/\nfloat polygon (vec2 st, float radius, int sides , float angle, float blur) {\n    \n      // Angle and radius from the current pixel\n      float a = atan(st.x,st.y)+PI;\n      float r = TWOPI/float(sides);\n\n      // Shaping function that modulate the distance\n      float d = cos(floor(.5+a/r)*r-a)*length(st);\n      float temp = 1.0-smoothstep(radius, radius + blur ,d);\n      //temp +=  1.0-smoothstep(radius, radius - blur ,d);\n      return (temp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\t\n\tvec2 twistedUV;   \n\tvec3 pixel;\n    \n    float warpedTerm = length(uv) * -cos(speed * (iTime - outerOffset)) * intensity;\n    float originalAngle = PI * rotation * sin(speed * iTime) + warpedTerm;\n \t\n    //using the warped term instead makes a different effect\n    if(originalAngle < 0.1){\n        if(shadowToggle == 1){\n        shadowToggle = 0;\n        }\n        else{\n            shadowToggle = 1;\n        }\n    }\n    \n    //finds the polygon being worked on and stores it in shapeI\n    //this is faster because it avoides calculating the shimmer 20 times\n    for(float j = 20.0; j > 0.0; j-= 1.0)\n    {    \n        float scale = (j * scaleCo);\n        float angle = originalAngle+  angleOffset * j;\n        twistedUV.x =   cos(angle)*uv.x + sin(angle)*uv.y;\n\t\ttwistedUV.y = - sin(angle)*uv.x + cos(angle)*uv.y;\n       // twistedUV = uv;\n        \n        //updates shapeI too find the smallest polgon the pixel might be in\n        if(polygon(twistedUV, 0.4 * scale, polygonSides, 0.0, 0.065) > 0.0){\n            shapeI = j;\n        }\n    }  \n    \n    //The angle and twisted UVs need to be calculated one extra time now that we know the shapeI value\n    float angle = originalAngle + angleOffset * shapeI;\n    float scale = (shapeI * scaleCo);\n    vec3 changingColor =0.7 + 0.5*cos(2.0*iTime+  (12.0-shapeI) * 0.4 +vec3(0,2,4));     \n    twistedUV.x =   cos(angle)*uv.x + sin(angle)*uv.y;\n    twistedUV.y = - sin(angle)*uv.x + cos(angle)*uv.y;\n\t\n    //Using another UV variable to toggle the static shadow effect\n    vec2 shadowUV = (staticShadows && shadowToggle == 1) ? uv : twistedUV;\n  \n    float shimmer = GetShimmer(shadowUV * 3.0); //3.0 is the shimmer effect scale\n    \n    //gets the polygon pixel again which is basically just the shadow value\n    float t = polygon(shadowUV, (0.40 - 0.055/scale) * scale, polygonSides, 0.0, 0.13);\t\n\tpixel =changingColor -(sqrt(20.0 * shapeI) *0.03);\n\t\n    if(shapeI != 1.0){\n        pixel = mix(pixel, vec3(0.004), t );        \n    }\n  //  pixel = pow(pixel, vec3(1.0/1.01));\n    //don't want the shimmer to apear ontop of shadow pixels\n    shimmer *= -t + 1.0;\n    pixel+=0.1;\n    pixel = (pixel+ 0.4 *(shimmer));\n    fragColor = vec4(pixel, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGyzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[734, 734, 757, 757, 928], [930, 951, 979, 979, 1385], [1387, 1387, 1405, 1405, 1444], [1446, 1446, 1462, 1462, 1539], [1541, 1541, 1568, 1568, 1943], [1945, 1972, 1994, 1994, 2209], [2211, 2237, 2259, 2259, 2662], [2664, 2664, 2714, 2734, 3344], [3346, 3420, 3446, 3446, 3808], [3810, 3842, 3918, 3972, 4292], [4294, 4294, 4351, 4351, 6623]], "test": "timeout"}
{"id": "4dKcRG", "name": "Eye Animation test", "author": "twitchingace", "description": "An attempt to mimic the sort of facial animation seen in Wind Waker. Keyframed blinking + pupil dilation.\n\nFor now I'm way too lazy to have the eyes properly focus, so Lonk is forever looking in the distance.", "tags": ["eyes", "eye", "animation", "face", "windwaker", "loz", "eyebrow"], "likes": 2, "viewed": 199, "published": "Public", "date": "1523028547", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n\tAn attempt to mimic the animation of Link's expressions in Wind Waker.\n\tThe whole thing is reasonably simple, but this code is an absolute mess.\n\tIt's mostly just a few keyframes (drawn via bezier curves and intersecting parabolas mostly),\n\t\tbasic lerp'd stuff.\n\n\tAs per usual, you're free to use this work in whatever you want, but I'd appreciate if\n\t\tyou credited me (my Shadertoy name and a link to this work is fine).\n**/\n\n/** TODO: \n\tMaybe add in more eyebrow shapes so we can actually tween\n\tAntialiasing would probably be nice\n\tAdd in the original colour gradient\n\tExtra, non-blink related, eyelid shapes\t\n**/\n\n// Shape map:\n// 0: standard eye\n// 1-3: blink stages\n\nfloat blinkStageDuration = 1./7.;\nfloat blinkDuration = .45;\nvec2 lPupilCenter = vec2(.23, .19);\nvec2 lEyeSize = vec2(0.09, 0.105);\n\nfloat rEyeOffset = 0.53;\nvec2 rPupilCenter = vec2(.76, .19);\nvec2 rEyeSize = vec2(0.09, 0.105);\n\nvec3 focusPoint;\nfloat pupilDilation = 1.0;\nvec3 skinColour = vec3(247.0, 219.0, 156.0)/255.;\n\n// Bezier drawing tech taken from https://www.shadertoy.com/view/MtS3Dy\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1); // ð›¼,ð›½,ð›¿(ð‘)\n  float f=b*d-a*a; // ð‘“(ð‘)\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x); // âˆ‡ð‘“(ð‘)\n  vec2 pp=-f*gf/dot(gf,gf); // ð‘â€²\n  vec2 d0p=b0-pp; // ð‘â€² to origin\n  float ap=det(d0p,d20), bp=2.0*det(d10,d0p); // ð›¼,ð›½(ð‘â€²)\n  // (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))\n  float t=clamp((ap+bp)/(2.0*a+b+d), 0.0, 1.0); // ð‘¡Ì…\n  return mix(mix(b0,b1,t),mix(b1,b2,t),t); // ð‘£ð‘– = ð‘(ð‘¡Ì…)\n}\nfloat approx_distance(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n  return length(get_distance_vector(b0-p, b1-p, b2-p));\n}\n\n\nbool paintScleras( in vec2 uv)\n{\n    vec2 tempUV = uv;\n    if (tempUV.x > 0.5) tempUV.x -= rEyeOffset;\n    float toSquare = tempUV.x * 1.8 - .42;\n    if ((tempUV.y >= .9 * toSquare*toSquare + .04) &&\n        (tempUV.y <= -1.0* toSquare*toSquare + .34))\n    {\n        return true;   \n    }\n\n \treturn false;  \n}\n\nbool paintPupil (in vec2 uv, in vec2 pupilCenter, in vec2 eyeSize)\n{\n\tvec2 dist = uv - pupilCenter - focusPoint.xy;\n\tvec2 part = vec2(dist.x/eyeSize.x / pupilDilation, dist.y/eyeSize.y / pupilDilation); // (x/a, y/b)\n\tfloat equation = part.x * part.x + part.y * part.y;\n\tif(equation < 1.0){ \n\t\treturn true;\n    }\n    \n    return false;\n}\n\nbool restrictPupil (in vec2 uv, in int shape1, in int shape2, in float tween){\n    vec2 tempUV = uv;\n    if (tempUV.x > 0.5) tempUV.x -= rEyeOffset;\n    float toSquare = tempUV.x * 1.8 - .42;\n    vec3 A,B,C,D;\n    if (shape1 == 0){\n        A.y = 0.9;\n        B.y = 0.04;\n        C.y = -1.0;\n        D.y = 0.34;\n    } else if (shape1 == 1){\n        A.y = .7;\n        B.y = 0.06;\n        C.y = -0.7;\n        D.y = 0.3;\n    } else if (shape1 == 2){\n        A.y = 0.5;\n        B.y = 0.1;\n        C.y = -0.4;\n        D.y = 0.24;\n    } else if (shape1 == 3){\n        A.y = 0.3;\n        B.y = 0.2;\n        C.y = -0.1;\n        D.y = 0.2;\n    }\n    \n    if (shape2 == 0){\n        A.z = 0.9;\n        B.z = 0.04;\n        C.z = -1.0;\n        D.z = 0.34;\n    } else if (shape2 == 1){\n        A.z = 0.7;\n        B.z = 0.06;\n        C.z = -0.7;\n        D.z = 0.3;\n    } else if (shape2 == 2){\n        A.z = 0.5;\n        B.z = 0.1;\n        C.z = -0.4;\n        D.z = 0.24;\n    } else if (shape2 == 3){\n        A.z = 0.3;\n        B.z = 0.2;\n        C.z = -0.1;\n        D.z = 0.2;\n    }\n    \n    A.x = mix(A.y, A.z, tween);\n    B.x = mix(B.y, B.z, tween);\n    C.x = mix(C.y, C.z, tween);\n    D.x = mix(D.y, D.z, tween);\n    \n    if ((tempUV.y <= A.x * toSquare*toSquare + B.x) ||\n            (tempUV.y >= C.x * toSquare*toSquare + D.x))\n    {\n    \treturn true;   \n    }\n    return false;\n}\n\nbool paintEyebrow (in vec2 uv, bool isRightBrow, int shape1, int shape2, float tween){\n    vec2 A1, A1Start, A1End, B1, B1Start, B1End, C1, C1Start, C1End;\n    vec2 A2, A2Start, A2End, B2, B2Start, B2End, C2, C2Start, C2End;\n    // Map the shape of the initial eyebrow to the three points\n    // defining the associated bezier curve\n    if (shape1 == 0){\n\t\tA1Start = vec2(0.44, 0.35);\n    \tB1Start = vec2(0.17, 0.52);\n    \tC1Start = vec2(0.03, 0.41);\n        \n        A2Start = vec2(0.44, 0.35);\n    \tB2Start = vec2(0.14, 0.61);\n    \tC2Start = vec2(0.03, 0.41);\n    }\n    \n    if (shape2 == 0){\n\t\tA1End = vec2(0.44, 0.35);\n    \tB1End = vec2(0.17, 0.52);\n    \tC1End = vec2(0.03, 0.41);\n        \n        A2End = vec2(0.44, 0.35);\n    \tB2End = vec2(0.14, 0.61);\n    \tC2End = vec2(0.03, 0.41);\n    }\n    \n    if (isRightBrow){\n        A1Start.x = 1. - A1Start.x;\n        B1Start.x = 1. - B1Start.x;\n        C1Start.x = 1. - C1Start.x;\n        A2Start.x = 1. - A2Start.x;\n        B2Start.x = 1. - B2Start.x;\n        C2Start.x = 1. - C2Start.x;\n        \n        A1End.x = 1. - A1End.x;\n        B1End.x = 1. - B1End.x;\n        C1End.x = 1. - C1End.x;\n        A2End.x = 1. - A2End.x;\n        B2End.x = 1. - B2End.x;\n        C2End.x = 1. - C2End.x;\n    }\n    \n    // Lerp between the expression we started in and the one we're going to\n    A1 = mix(A1Start, A1End, tween);\n    B1 = mix(B1Start, B1End, tween);\n    C1 = mix(C1Start, C1End, tween);\n    float d = approx_distance(uv, A1, B1, C1);\n    if (d < 0.0215)\n    {\n    \treturn true;\n    }\n    \n     // Lerp between the expression we started in and the one we're going to\n    A2 = mix(A2Start, A2End, tween);\n    B2 = mix(B2Start, B2End, tween);\n    C2 = mix(C2Start, C2End, tween);\n    d = approx_distance(uv, A2, B2, C2);\n    if (d < 0.0255)\n    {\n    \treturn true;\n    }\n    \n    return false;\n}\n\nbool paintEyelids (in vec2 uv, bool isRightLid, int shape1, int shape2, float tween){\n    \n    vec2 A1, A1Start, A1End, B1, B1Start, B1End, C1, C1Start, C1End;\n    // Map the shape of the initial eye to the three points\n    // defining the associated bezier curve\n    if (shape1 == 0){\n\t\tA1Start = vec2(0.01, 0.19);\n    \tB1Start = vec2(0.26, 0.5);\n    \tC1Start = vec2(0.47, 0.15);\n    } else if (shape1 == 1){\n   \t\tA1Start = vec2(0.01, 0.19);\n        B1Start = vec2(0.3,  0.44);\n    \tC1Start = vec2(0.47, 0.15);   \n    } else if (shape1 == 2){\n   \t\tA1Start = vec2(0.01, 0.19);\n        B1Start = vec2(0.30, 0.32);\n    \tC1Start = vec2(0.47, 0.15);   \n    } else if (shape1 == 3){\n   \t\tA1Start = vec2(0.01, 0.19);\n        B1Start = vec2(0.30, 0.23);\n    \tC1Start = vec2(0.47, 0.17);   \n    }\n    \n    if (shape2 == 0){\n\t\tA1End = vec2(0.01, 0.19);\n    \tB1End = vec2(0.26, 0.5);\n    \tC1End = vec2(0.47, 0.15);\n    } else if (shape2 == 1){\n   \t\tA1End = vec2(0.01, 0.19);\n        B1End = vec2(0.3,  0.44);\n    \tC1End = vec2(0.47, 0.15);   \n    } else if (shape2 == 2){\n   \t\tA1End = vec2(0.01, 0.19);\n        B1End = vec2(0.30, 0.32);\n    \tC1End = vec2(0.47, 0.15);   \n    } else if (shape2 == 3){\n   \t\tA1End = vec2(0.01, 0.19);\n        B1End = vec2(0.30, 0.23);\n    \tC1End = vec2(0.47, 0.17);   \n    } \n    \n    if (isRightLid){\n        A1Start.x = 1. - A1Start.x;\n        B1Start.x = 1. - B1Start.x;\n        C1Start.x = 1. - C1Start.x;\n        \n        A1End.x = 1. - A1End.x;\n        B1End.x = 1. - B1End.x;\n        C1End.x = 1. - C1End.x;\n    }\n    \n    // Lerp between the expression we started in and the one we're going to\n    A1 = mix(A1Start, A1End, tween);\n    B1 = mix(B1Start, B1End, tween);\n    C1 = mix(C1Start, C1End, tween);\n    float d = approx_distance(uv, A1, B1, C1);\n        if (d < 0.007 + 0.0025)\n        {\n            return true;\n        }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 lEyeShapes = vec4(0);\n    vec4 rEyeShapes = vec4(0);\n    float lEyeTween = 0.;\n    float rEyeTween = 0.;\n    \n    // This doesn't *really* focus the eyes, but it makes them slide around together\n    // which I guess is close enough\n    focusPoint = vec3(sin(iTime * 1.4) * .08, cos(iTime * 0.6) * .07, 0.);\n    pupilDilation = abs(sin(iTime * 0.2 + 1.4)) * 0.5 + 0.7; \n    \n    // Blink every 4 seconds\n    if (int(floor(iTime)) % 4 == 0){\n        rEyeTween = fract(iTime);\n        lEyeTween = fract(iTime);\n        if (rEyeTween <= blinkDuration){\n            blinkStageDuration *= blinkDuration;\n            while (rEyeTween > blinkStageDuration){\n                rEyeTween -= blinkStageDuration;\n            }\n            rEyeTween /= blinkStageDuration;\n            if (fract(iTime) <= blinkStageDuration)\n            {\n                lEyeShapes.x = 0.;\n                lEyeShapes.y = 1.;\n                rEyeShapes.x = 0.;\n                rEyeShapes.y = 1.;\n            }\n            else if (fract(iTime) <= 2. * blinkStageDuration)\n            {\n                lEyeShapes.x = 1.;\n                lEyeShapes.y = 2.;\n                rEyeShapes.x = 1.;\n                rEyeShapes.y = 2.;\n            }\n            else if (fract(iTime) <= 3. * blinkStageDuration)\n            {\n                lEyeShapes.x = 2.;\n                lEyeShapes.y = 3.;\n                rEyeShapes.x = 2.;\n                rEyeShapes.y = 3.;\n            }\n            else if (fract(iTime) <= 4. * blinkStageDuration)\n            {\n                lEyeShapes.x = 3.;\n                lEyeShapes.y = 3.;\n                rEyeShapes.x = 3.;\n                rEyeShapes.y = 3.;\n            }\n            else if (fract(iTime) <= 5. * blinkStageDuration)\n            {\n                lEyeShapes.x = 3.;\n                lEyeShapes.y = 2.;\n                rEyeShapes.x = 3.;\n                rEyeShapes.y = 2.;\n            }\n            else if (fract(iTime) <= 6. * blinkStageDuration)\n            {\n                lEyeShapes.x = 2.;\n                lEyeShapes.y = 1.;\n                rEyeShapes.x = 2.;\n                rEyeShapes.y = 1.;\n            }\n            else {\n                lEyeShapes.x = 1.;\n                lEyeShapes.y = 0.;\n                rEyeShapes.x = 1.;\n                rEyeShapes.y = 0.;\n            }\n        }\n    }\n    \n    //lEyeShapes.xy = vec2(3., 3.);\n    //rEyeShapes.xy = vec2(3., 3.);\n    //rEyeTween = 0.;\n    //lEyeTween = 0.;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n\n    // Initial colour\n    vec3 pixelColour = skinColour;\n\n    // Add in the full iris shape in flat white\n    if (paintScleras(uv))\n    {\n    \tpixelColour = vec3(1.0);   \n    }\n    \n    // Add in full pupil\n    // TODO: bring in the gradient from the original game\n    if (paintPupil(uv, lPupilCenter, lEyeSize) ||\n        paintPupil(uv, rPupilCenter, rEyeSize)){\n    \tpixelColour = vec3(0.0);\n    }\n    \n    // Mask the iris and pupil to create the proper shape of the eye\n    if ((uv.x < 0.5 && restrictPupil(uv, int(lEyeShapes.x), int(lEyeShapes.y), lEyeTween)) ||\n        (uv.x > 0.5 && restrictPupil(uv, int(rEyeShapes.x), int(rEyeShapes.y), rEyeTween)))\n    {\n     \tpixelColour = skinColour;   \n    }\n    \n    // Paint the eyelids on\n    if (paintEyelids(uv, false, int(lEyeShapes.x), int(lEyeShapes.y), lEyeTween) ||\n        paintEyelids(uv, true,  int(rEyeShapes.x), int(rEyeShapes.y), rEyeTween)){\n        pixelColour = vec3(0.0);\n    }\n    \n    // TODO: Maybe actually add in extra shapes so we can tween for real sometime\n    if (paintEyebrow(uv, false, int(lEyeShapes.z), int(lEyeShapes.w), 0.) ||\n        paintEyebrow(uv, true, int(lEyeShapes.z), int(lEyeShapes.w), 0.)){\n\t\tpixelColour = vec3(0.0);\n    }\n \n\n    fragColor = vec4(pixelColour, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dKcRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1003, 1075, 1102, 1102, 1128], [1129, 1129, 1182, 1182, 1856], [1857, 1857, 1915, 1915, 1973], [1976, 1976, 2008, 2008, 2285], [2287, 2287, 2355, 2355, 2624], [2626, 2626, 2704, 2704, 3996], [3998, 3998, 4084, 4084, 5841], [5843, 5843, 5928, 5928, 7724], [7726, 7726, 7783, 7783, 11588]], "test": "ok"}
{"id": "4dKczd", "name": "Katabatic caustic of an ellipse", "author": "dpiponi", "description": "Rendered using wave optics. Mouse controls the wavelength.\nThere's some colour leaking outside of the ellipse. Need to fix that.\nFiddle with the source code if you want to see some other shapes.\nParabola's nice if you can see which lines to comment out", "tags": ["physics", "optics", "diffraction"], "likes": 7, "viewed": 261, "published": "Public", "date": "1522986848", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat hypot(vec2 p) {\n    return sqrt(p.x*p.x+p.y*p.y);\n}\n\nfloat pi = 3.1415926;\n\nfloat cross2(vec2 u, vec2 v) {\n    return u.x*v.y-u.y*v.x;\n}\n\nvec2 path(float t) {\n    float theta = 2.0*pi*(t-0.5);\n    float alpha = 0.2*iTime;\n    mat2 m = mat2(cos(alpha), -sin(alpha), sin(alpha), cos(alpha));\n\n    vec2 xy = vec2(0.75*cos(theta), sin(theta));\n    //vec2 xy = vec2(theta, 1.5*theta*theta-1.0);\n    //return vec2(-theta*theta, theta);\n    //return vec2(-cos(theta), sin(theta));\n    //vec2 xy = vec2(-cos(theta)*cos(theta)*cos(theta), sin(theta)*sin(theta)*sin(theta));\n\n    return 1.0*m*xy;\n}\n\n// float l(vec2 xy, float theta) {\n//     return -path(theta).x+hypot(xy-path(theta));\n// }\n\nfloat gain = 0.70;\n//float wavelength = 0.03;\n\nfloat integrate(vec2 xy) {\n    float tx = 0.0;\n    float ty = 0.0;\n    int n = 2000;\n    vec2 last_p = path(0.0);\n\n    float wavelength = 0.02+0.02*iMouse.x/iResolution.x;\n\n    for (int i = 0; i < 2000; ++i) {\n        float t = float(i)/float(n);\n        vec2 p = path(t);\n        float d = hypot(xy-p);\n\n        float dt = p.y-last_p.y;\n\n        if (dt < 0.0 && cross2(p-last_p, xy-p) > 0.0) {\n            float path_length = d-p.x;\n            float s = 2.0*pi/wavelength*path_length;\n            tx += cos(s)*dt/d;\n            ty += sin(s)*dt/d;\n        }\n\n//        path_length = d+p.x;\n//        s = -2.0*pi/wavelength*path_length;\n//        tx += cos(s)*dt/d;\n//        ty += sin(s)*dt/d;\n\n        last_p = p;\n    }\n    return hypot(vec2(tx, ty));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = vec2(0.5*iResolution.x, 0.5*iResolution.y);\n    vec2 uv = fragCoord.xy-center;\n    uv = 2.0*uv/iResolution.y;\n    float c = gain*integrate(uv);\n    fragColor = vec4(1.2*sqrt(c), c, 0.5*c, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dKczd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 58], [83, 83, 113, 113, 143], [145, 145, 165, 165, 595], [737, 737, 763, 763, 1492], [1494, 1494, 1549, 1549, 1763]], "test": "ok"}
{"id": "4dKyD3", "name": "Failed Menger Sponge", "author": "bombshell93", "description": "I tried to make a menger sponge from scratch, test my ability to bodge together a working formula, I didn't quite get it but I found this shape interesting in its place, threw some bad lighting and ao in there and gave it a spin.", "tags": ["fractal", "light", "color", "ao", "ambientocclusion", "spin", "repeat"], "likes": 8, "viewed": 222, "published": "Public", "date": "1523644644", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14\n#define FOV PI * 0.5\n#define COSTIME cos(iTime * 0.1)\n#define SINTIME sin(iTime * 0.1)\n\n#define SHAPE_DIVISION 4\n#define SHAPE_SPACE 2.1\n\n#define RAY_STEPS 64\n#define RAY_MIN_DIST 0.001\n#define RAY_MAX_DIST 1024.0\n\n#define AO_SAMPLES 32\n\n#define NORMAL_SAMPLE_LENGTH 0.005\n\n#define LIGHT_AMBIENT vec3(0.5, 0.5, 0.5);\n#define LIGHT_INTENSITY 0.5\n#define LIGHT_RAY_STEPS 64\n#define LIGHT_RAY_DIST 0.0001\n\n#define SPECULAR_POWER 4.0\n#define SPECULAR_INTENSITY 1.0\n\nfloat sat(float a) {\n    \n    return min(1.0, max(0.0, a));\n}\nfloat opU(float a, float b) { return min(a, b); }\nfloat opS(float a, float b) { return max(a, -b); }\nvec3 opT(vec3 p, vec3 o) { return p - o; }\nvec3 opR(vec3 p, vec3 c) { return mod(p, c) - 0.5 * c; }\nfloat box(vec3 p, vec3 b) { vec3 d = abs(p) - b; return max(d.x, max(d.y, d.z)); }\nfloat ibox(vec3 p, vec3 b) { vec3 d = abs(p) - b; return -max(d.x, max(d.y, d.z)); }\nfloat map(vec3 p) {\n    \n    float d = RAY_MAX_DIST;\n    vec3 rp = p;\n    rp = opR(rp, vec3(SHAPE_SPACE, SHAPE_SPACE, SHAPE_SPACE));\n    float fd = box(rp, vec3(1.0, 1.0, 1.0));\n    float sd = RAY_MAX_DIST;\n    for (int i = 0; i < SHAPE_DIVISION; ++i) {\n        \n        vec3 tp = rp;\n        float s = pow(3.0, float(i ));\n        tp = opT(tp, vec3(2.0, 2.0, 2.0) / s);\n        tp = opR(tp, vec3(2.0, 2.0, 2.0) / s);\n        sd = opU(sd, box(tp, vec3(0.66, 0.66, 0.66) / s));\n    }\n    fd = opS(fd, sd);\n    d = opU(d, fd);\n    return d;\n}\n\nfloat findDist(vec3 ro, vec3 rd, int max_steps, float min_dist, float max_dist) {\n    \n    float len = min_dist;\n    for (int i = 0; i < max_steps && len < max_dist; ++i) {\n        \n        float dist = map(ro + rd * len);\n        if (dist <= min_dist) {\n            \n            return len;\n        }\n        len += dist;\n    }\n    return RAY_MAX_DIST;\n    \n}\n\nvec3 findNormal(vec3 p) {\n    \n    float u = map(p + vec3(0.0, 0.0, NORMAL_SAMPLE_LENGTH))\n        , d = map(p - vec3(0.0, 0.0, NORMAL_SAMPLE_LENGTH))\n        , r = map(p + vec3(NORMAL_SAMPLE_LENGTH, 0.0, 0.0))\n        , l = map(p - vec3(NORMAL_SAMPLE_LENGTH, 0.0, 0.0))\n        , f = map(p + vec3(0.0, NORMAL_SAMPLE_LENGTH, 0.0))\n        , b = map(p - vec3(0.0, NORMAL_SAMPLE_LENGTH, 0.0));\n    return normalize(vec3(r - l, f - b, u - d));\n}\n\nfloat findAO(vec3 p, vec3 n) {\n    \n    float ao = 0.0;\n    for (int i = 0; i < AO_SAMPLES; ++i) {\n        \n        float w = pow(float(i + 1), 2.0);\n        float sd = 0.001 * w;\n        ao += max(0.0, map(p + n * sd) / sd) / float(AO_SAMPLES);\n    }\n    return max(min(ao, 1.0), 0.0);\n}\n\nvec3 phong(vec3 p, vec3 e, vec3 n, vec3 l, vec3 c, float i) {\n    \n    vec3 ptol = l - p;\n    vec3 etop = p - e;\n    float diff = dot(normalize(ptol), n);\n    float spec = pow(sat(dot(normalize(etop), normalize(ptol))), SPECULAR_POWER) * SPECULAR_INTENSITY;\n    float dist = 1.0 / (pow(length(ptol) / i, 2.0));\n    if (findDist(l, normalize(-ptol), LIGHT_RAY_STEPS, LIGHT_RAY_DIST, length(ptol)) < RAY_MAX_DIST) {\n        \n        return vec3(0.0, 0.0, 0.0);\n    }\n    return (c * (diff + spec) * dist) / i;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fc ) {\n    \n    vec2 uv = (vec2(fc.x, fc.y) - iResolution.xy * 0.5) / iResolution.y;\n    vec3 e = vec3(0.0, iTime * 0.25, 0.0);\n    vec3 l = e + vec3(0.0, 1.0, 0.0);\n    \n    vec3 f = normalize(l - e);\n    vec3 u = vec3(COSTIME, 0.0, SINTIME);\n    vec3 r = cross(u, f);\n    \n    vec3 rd = normalize(f + r * uv.x * FOV + u * uv.y * FOV);\n    vec3 ro = e + rd * RAY_MIN_DIST;\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    float d = findDist(ro, rd, RAY_STEPS, RAY_MIN_DIST, RAY_MAX_DIST);\n    if (d < RAY_MAX_DIST) {\n        \n        vec3 p = ro + rd * d;\n        vec3 n = findNormal(p);\n        float ao = findAO(p, n);\n\n        vec3 l = phong(p, e, n, e + vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 1.0), LIGHT_INTENSITY) + LIGHT_AMBIENT;\n        l *= ao;\n        vec3 c = normalize(vec3(mod(floor(p / SHAPE_SPACE), vec3(1.0, 1.0, 1.0) * SHAPE_SPACE)) * 0.5 + 0.5);\n        fragColor = vec4(c * l, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dKyD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[478, 478, 498, 498, 539], [540, 540, 569, 569, 589], [590, 590, 619, 619, 640], [641, 641, 667, 667, 683], [684, 684, 710, 710, 740], [741, 741, 768, 768, 823], [824, 824, 852, 852, 908], [909, 909, 928, 928, 1449], [1451, 1451, 1532, 1532, 1811], [1813, 1813, 1838, 1838, 2255], [2257, 2257, 2287, 2287, 2545], [2547, 2547, 2608, 2608, 3056], [3058, 3058, 3108, 3108, 4011]], "test": "ok"}
{"id": "4dKyWG", "name": "5x6 bitcompressed font", "author": "crundle", "description": "My first attempt at creating a bitcompressed font. Can anyone tell me why this is so slow?", "tags": ["font", "bitcompressed"], "likes": 3, "viewed": 89, "published": "Public", "date": "1523139580", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TEXTSIZE 10.0\n\n//ints, because i had precision problems with floats\n//5x6 - top left corner is LSB\n//generated from http://asset-d.soupcdn.com/asset/14134/8421_d52e.png\nint[99] ichars = int[99]( 0, 422402636, 277094732, 1008824846, 487092750, 277117250, 487077982, 422131804, 138551838, 422130252, 487092812, 489636288, 489245122, 941689728, 959007632, 942098816, 69667404, 1024347008, 623462850, 138547204, 211034120, 623331906, 421595202, 727373280, 623462848, 422136192, 69683648, 554584448, 69290432, 486935424, 943854532, 959007296, 145312320, 358274592, 581052960, 1024346688, 1009140672, 623856204, 1025985102, 941688924, 489245262, 1009191006, 69666910, 959252572, 623856210, 474091662, 422068764, 623331922, 1008797762, 727373499, 623471314, 422136396, 69683790, 959269452, 623331918, 486934620, 138547359, 422136402, 212421202, 358274737, 581052977, 1024346706, 1008869918, 134353028, 134357580, 368409920, 134217728, 142999552, 142999808, 134348800, 35791360, 545392672, 136382592, 142876800, 203491520, 411312512, 491197888, 1040187392, 458752, 422135828, 422129684, 959332372, 4224, 14694400, 4657152, 9078784, 355019340, 330, 572662304, 455431816, 134348800, 138547332, 272699648, 71569472, 324, 10627072, 492519982, 809570456, 210247942  );\n\n//Extracts bit b from the given number.\nfloat extract_bit_int(int n, float b)\n{\n    return float( (n / int(exp2(b)) ) %2 );   \n}\n\nfloat drawchar(vec2 o, vec2 p, int ich) {\n    p-=o;\n    \n    p*=iResolution.xy/TEXTSIZE; //scale stuff\n    if((p.x<0.||p.x>=5.) || (p.y<0.||p.y>=6.)) return 0.;\n    float cpx = trunc(mod(p.x,5.)); //pixel in cell, x\n    float cpy = 5.-trunc(mod(p.y, 6.)); // pixel in cell, y\n    float cpno = mod(cpy*5.+cpx,32.); //pixel/bit in char\n    ich=ich%99;\n    return (extract_bit_int(ichars[ich],(cpno))); //is bit set?\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y*=iResolution.y/iResolution.x;\n    \n    float time = 0.0;\n    float charstep = (TEXTSIZE*5.)/iResolution.x;\n    vec2 p = vec2(0);\n    for(int i = 3; i>=-2;i--) {\n        float clip = float(abs(iTime) > pow(10.0, float(i)) || i == 0); //Clip off leading zeros.\n        \n        float digit = mod(iTime / pow(10.0, float(i)),10.0);\n        \n        if(i == -1)\n        {\n            time += drawchar(vec2(0),uv-p,66) * clip;\n            p.x += charstep * clip;\n        }\n        time += drawchar(vec2(0)+p,uv,int(digit)+1) * clip;\n        \n        \n        p.x += charstep * clip;\n        \n    }\n    time += drawchar(vec2(0.,.25),uv, 44 );\n    time += drawchar(vec2(0.,.25)+vec2(charstep,0.),uv,19);\n    time += drawchar(vec2(0.,.25)+vec2(charstep*2.,0.),uv,63);\n    vec3 col = mix(vec3(0),vec3(1,0,0),time);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dKyWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1265, 1305, 1344, 1344, 1393], [1395, 1395, 1436, 1436, 1810], [1813, 1813, 1870, 1920, 2809]], "test": "ok"}
{"id": "4dtfDr", "name": "Gerstner Waves", "author": "nr4", "description": "Analytic liquid rendering with Gerstner Waves.\nIntroduction: http://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch01.html", "tags": ["waves", "analytic", "gerstner"], "likes": 20, "viewed": 1035, "published": "Public", "date": "1524753513", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Gerstner Waves\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n//Changes:\n//1: removed the incompatible inverse(.) call\n//2: removed the S() and C() functions\n//3: removed array setup and combined in one single function call\n\n//universal constants\nconst float pi = acos(-1.);\nconst vec2 c = vec2(1.,0.);\nconst int nwaves = 9;\n\nfloat rand(vec2 a0)\n{\n    return fract(sin(dot(a0.xy ,vec2(12.9898,78.233)))*43758.5453);\n}\n\nvoid wave(in int i, out float st, out float am, out vec2 di, out float fr, out float sp)\n{\n    //setup wave params\n\tst = abs(.35*rand(vec2(float(i))));//qi\n\tam = .02+.005*rand(vec2(float(i+2)));//ai\n    di = (1.e0+vec2(1.7e0*rand(vec2(i,i+1)), 2.e0*rand(vec2(i+1,i))));//di\n    fr = 6.+12.*rand(vec2(float(i+5)));//wi\n    sp = 55.e-1+52.e-1*rand(vec2(float(i+4)));//phi\n}\n\nvoid gerst(in vec2 xy, in float t, out vec3 val, out vec3 deriv)\n{\n    val = vec3(xy, 0.);\n    deriv = c.yyy;\n    \n   \tfloat st,fr,sp,am;\n    vec2 di;\n    \n    for(int i=0; i<nwaves; ++i)\n    {\n   \t\twave(i, st, am, di, fr, sp);\n        \n        //gen values\n        float d = dot(di, xy);\n\t\tval += vec3(st*am*di*cos(fr*d+sp*t), am*sin(fr*d+sp*t));\n    }\n\n    for(int i=0; i<nwaves; ++i)\n    {\n        wave(i, st, am, di, fr, sp);\n        \n        //gen derivatives\n        deriv += vec3(\n            -di*fr*am*cos(fr*dot(di,val.xy)+sp*t),\n            1.-st*fr*am*sin(fr*dot(di,val.xy)+sp*t)\n        );\n    }\n    \n    deriv = normalize(deriv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //raytrace and colorize\n    vec2 uv = fragCoord/iResolution.yy;\n\tvec3 o = c.yyx, r = 1.*c.xyy, u = 1.*c.yxy+c.yyx, d = normalize(cross(u,r)),\n        ro = o+uv.x*r+uv.y*u;\n    \n    vec3 l = (c.yyx-3.*c.yxy),\n        //p = inverse(mat3(d,c.xyy,c.yxy))*ro, //unportable!\n        p = mat3(c.yxy, c.yyx, 1./d.z, -d.x/d.z, -d.y/d.z)*ro,\n        n, val;\n        \n    gerst(p.xy, iTime, val, n);\n    \n    vec3 re = normalize(reflect(-l, n)), \n        v = normalize(p-ro);\n    \n    vec3 col = .2*c.yxx+.2*c.yyx*dot(l, n)+3.6e1*c.xxx*pow(dot(re,v), 4.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dtfDr.jpg", "access": "shaders20k", "license": "gpl-3.0-plus", "functions": [[1000, 1000, 1021, 1021, 1091], [1093, 1093, 1183, 1207, 1464], [1466, 1466, 1532, 1532, 2110], [2112, 2112, 2169, 2197, 2776]], "test": "error"}
{"id": "4dtfW8", "name": "helix 1b", "author": "FabriceNeyret2", "description": ".", "tags": ["raymarching", "sdf", "spiral", "helix", "short"], "likes": 1, "viewed": 303, "published": "Public API", "date": "1524904653", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/XsdBW8\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t = iTime, l,d;\n    mat2  R = mat2( sin(t+vec4(0,33,11,0)) );\n    vec3  q = iResolution,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),    // ray direction\n          p = 30./q;                          // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p,\n        q.xz *= R, q.yz *= R,                 // rotation\n        l = length(q.xy), d = atan(q.y,q.x) - q.z,\n        t = max(abs(l-3.5)-.5, abs(sin(d)) - .02 ), // double helix\n        p += t*D;                             // step forward = dist to obj\n    if (cos(d)<0.) O.gb *= .8; else O.rg *= .8;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dtfW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 85, 85, 702]], "test": "error"}
{"id": "4dtfz8", "name": "FuzzyBrain", "author": "jj99", "description": "stuff", "tags": ["fuzzy"], "likes": 1, "viewed": 104, "published": "Public", "date": "1524058426", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWO_PI  6.283\n\nvec2 rand(vec2 p)\n{\n\treturn fract(sin(vec2(dot(p,vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 7.0;\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    float _d = length(uv)*0.95;\n    \n    uv = (uv * scale);// + vec2(iTime * 1.1, iTime * 0.75);\n\tvec2 st1 = floor(uv);\n\tvec2 st2 = fract(uv);\n\n\tfloat mindist = 0.25;\n\tfloat speed = iTime;\n\tfor (int x = -1; x <= 1; x++)\n    {\n\t\tfor (int y = -1; y <= 1; y++)\n        {\n\t\t\tvec2 n = vec2(float(y), float(x));\n\t\t\tvec2 offset = rand(st1 + n);\n            offset.x = 0.5+sin(speed + TWO_PI * offset.x)*0.5;\n            offset.y = 0.5+sin(speed + TWO_PI * offset.y)*0.5;\n\t\t\tvec2 pos = n + offset - st2;\n\t\t\tfloat d = length(pos);\n\t\t\tmindist = min(mindist, mindist * d);\n\t\t}\n\t}\n\t\n    \n\tvec3 col = vec3(mindist*3.5);\n    col *= _d*_d;\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dtfz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 42, 42, 138], [140, 140, 197, 197, 968]], "test": "ok"}
{"id": "4dVcRK", "name": "2D rings", "author": "i0r", "description": "2D test", "tags": ["discs2d"], "likes": 0, "viewed": 309, "published": "Public API", "date": "1522617685", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float t = 0.0; \n    vec2 dp;\n    for ( float j = 1.; j < 4.; j++ ) {\n        for ( float i = 0.; i < 1023.; i++ ) {\n            dp = uv - vec2( \n                0.5 + sin( j * iTime + i * 0.01 ) * 0.1 * j, \n                0.5 + j * sin( iTime - i * 0.01 ) * 0.1\n            );\n            \n            t += smoothstep( 0.02, 0.0, sqrt( dot( dp, dp ) ) );\n        }\n    }\n    \n    fragColor = vec4( mix( vec3( 0.3 ), vec3( 0.5426, 0.4574, 0.0 ), t ), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dVcRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 568]], "test": "ok"}
{"id": "4dVcWV", "name": "CircularIndicator", "author": "charo", "description": "Experimenting with progress indicator UI", "tags": ["ui"], "likes": 5, "viewed": 165, "published": "Public", "date": "1523398660", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926535897932384626433832795;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV -.5 -> .5\n    vec2 uv = fragCoord/vec2(iResolution.y,iResolution.y)  - vec2(0.9, 0.5);\n    \n    float rsq = uv.x * uv.x + uv.y * uv.y;\n    float r = sqrt(rsq);\n    //float theta = atan(-uv.y, uv.x) + PI;\n    // Rotate\n    float theta = atan(-uv.x, -uv.y) + PI;\n\n    float Angle = mod(iTime, 360.0) * (PI / 180.0);\n\n    const float rsq1 = 0.11;\n    const float rsq2 = 0.16;\n    vec3 graycol = vec3(0.196, 0.196, 0.266);  // #323244\n    vec3 greencol = vec3(0.286, 0.8078, 0.545);  // #49CE8B\n    float aa_angle_edge = smoothstep(Angle - 0.02, Angle, theta);\n    vec3 col = mix(greencol, graycol, 1.0 - aa_angle_edge);\n    \n    col *= vec3(smoothstep(rsq1 - 0.005, rsq1, rsq));\n    col *= vec3(1.0 - smoothstep(rsq2 - 0.005, rsq2, rsq));\n\n    // Output to screen\n    fragColor.rgb = col;\n    //fragColor = vec4(theta / (2.0*PI));\n    //fragColor = vec4(uv.x, uv.y, 0.0, 1.0);\n    fragColor.a = 1.0;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dVcWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 111, 131, 1025]], "test": "ok"}
{"id": "4dVyD3", "name": "osu! logo", "author": "robin_be", "description": "'forked' from sunpy's https://www.shadertoy.com/view/MdVyRK\nthis is the first time I'm writing shader code so I tried lots of things which ended up in this wall of code", "tags": ["fft", "osu"], "likes": 0, "viewed": 324, "published": "Public API", "date": "1523565016", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based off https://www.shadertoy.com/view/MdVyRK\n\n#define SEED 0.12345679\n\n#define TRI 64.0\n#define SP 0.5\n#define COLOR vec3(0.9411764705882353,0.4274509803921569,0.6549019607843137)\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define HALFPI 1.5707963268\n\nfloat rand (vec2 p) {\n    return fract(sin(dot(p.xy,\n                         vec2(6.8245,7.1248)))*\n        9.1283);\n}\n\nfloat tri(vec2 uv, vec2 p, float s){\n    vec2 v = uv;\n    v -= p;\n    v /= max(s, 0.01);\n    \n\tfloat a = atan(v.x, v.y) + PI;\n    float r = TWO_PI / 3.0;\n    \n    float t = cos(floor(0.5 + a / r) * r - a) * length(v);\n    \n    return smoothstep(0.4, 0.41, t);\n}\n\nfloat yPos(float i){\n    vec2 p = vec2(SEED, i);\n    \n    float r = rand(p);\n    return fract(iTime * SP + r);\n}\n\nfloat xPos(float i, float t){\n    vec2 p = vec2(i, t - iTime * SP);\n    return rand(p) + .375;\n}\n\nvec3 triCol(float i, float t){\n    vec3 col = COLOR;\n    float r = xPos(i + 1.0, t);\n    col *= mix(0.9, 1.1, r);\n    return col;\n}\n\nfloat atan2(float y, float x) {\n \tif(x>0.)return atan(y/x);\n    if(x==0.)if(y>0.)return HALFPI;else return -HALFPI;\n    if(y<0.)return atan(y/x)-PI;return atan(y/x)+PI;\n}\nfloat atan2(vec2 v){return atan2(v.y,v.x);}\nfloat steq(float x,float a,float b){return step(a,x)*step(x,b);}\nvec2 cub_(float t,vec2 a,vec2 b){\n    float ct=1.-t;\n    return 3.*ct*ct*t*a+3.*ct*t*t*b+t*t*t;\n}\nfloat cub(float x,vec2 a,vec2 b){\n    vec2 it=vec2(0.,1.);\n    for (int i=0;i<7;i++) {\n        float pos=(it.x+it.y)/2.;\n        vec2 r=cub_(pos,a,b);\n        if (r.x>x){\n            it.y=pos;\n        }else{\n            it.x=pos;\n        }\n    }\n    return cub_((it.x+it.y)/2.,a,b).y;\n}\nfloat isine(float t){return -1.*cos(t*HALFPI)+1.;}\nfloat osine(float t){return sin(t*HALFPI);}\nfloat iquad(float t){return t*t;}\nfloat oc(float t){t=t-1.;return t*t*t+1.;}\nvec2 oc(vec2 v){return vec2(oc(v.x),oc(v.y));}\nfloat icirc(float t){return -1.*(sqrt(1.-t*t)-1.);}\nvec3 spin(vec3 col_,vec2 fc) {\n    vec3 col=col_;\n    float a=mod(degrees(atan2(fc-iResolution.xy/2.-.5)),360.);\n    float b=mod(iTime*100.,360.);\n    float s=25.;\n    float mi=mod(b-s,360.);\n    float ma=mod(b+s,360.);\n    float d=abs(b-a);\n    if(d>180.)d=a<b?a-b+360.:b+360.-a;\n    if((a>mi||(mi>ma&&a<ma))&&(a<ma||mi>ma))col+=1.-iquad(d/s);\n    return col;\n}\nfloat mb(){\n    return clamp(texture(iChannel0,vec2(0.02,0.2)),0.,1.).x;\n}\nvec3 barz(float d,vec2 fc,float off,float sp) {\n    float a=degrees(atan2(fc-iResolution.xy/2.-.5))/180.+1.;\n    a=mod(a+iTime/sp+off+mb()/3.,2.);\n    a-=1.;\n    if(a<0.)a=-a+0.01;\n    float m=mod(a,.025);\n    if(m<0.01*(1.+d*.6))return vec3(0.);\n    a-=m;\n    float v=clamp(texture(iChannel0,vec2(a,0.1)).x,0.,1.);\n    if (v>d) return vec3(1.);\n    return vec3(0.);\n}\nfloat osu_excdot(vec2 uv) {\n    const float ds=.07;\n    vec2 exc=oc((ds*2.-abs(uv))/ds/2.)*.04;\n    return steq(uv.x,-ds-exc.y,ds+exc.y)*steq(uv.y,-ds-exc.x,ds+exc.x);\n}\nfloat osu_excbody(vec2 uv) {\n    float e=oc((.2-abs(uv.x))/.2)*.04;\n    float ew=(uv.y+.15)*.01;\n    return steq(uv.x,-.1-ew,.1+ew)*steq(uv.y,-.2-e,.2+e);\n}\nfloat osu_u(vec2 uv) {\n    float r=1.18181818;\n    uv+=vec2(.5/r,.5);\n    uv.x*=r;\n    uv.y=1.-uv.y;\n    float c=1.;\n    c-=steq(uv.x,.31,.69)*steq(uv.y,.0,.765-.245*cub(1.-(uv.x-.31)/.38,vec2(.4,-.116),vec2(.994,-.27)));\n    float b=.48*cub(1.-uv.x,vec2(.252,-.164),vec2(1.038,-.52));\n    return c*steq(uv.x,0.,1.)*steq(uv.y,.02*isine(abs(mod(uv.x,.69)-.155)/.31),.933-b);\n}\nfloat osu_sunpy(vec2 uv) {\n    float r=1.397928994;\n    uv+=vec2(.5/r,.5);\n    uv.x*=r;\n    if (steq(uv.x,0.,1.)*steq(uv.y,0.,1.)==0.) {\n        return 0.;\n    }\n    uv.y=1.-uv.y;\n    float c=1.;\n    c-=steq(uv.x,.0,.035+.515*icirc((.3-uv.y)/.3))*steq(uv.y,.0,.3);\n    c-=steq(uv.x,.55,1.)*steq(uv.y,.0,.055*isine(clamp((uv.x-.55)/.4,.0,1.)));\n    c-=steq(uv.x,.95-.07*isine(clamp((uv.y-.055)/.192/*.195*/,.0,1.)),1.)*steq(uv.y,.055,.28);\n    c-=steq(uv.x,.59,.88)*steq(uv.y,.2+.045*isine((uv.x-.59)/.29),.28);\n    c-=steq(uv.x,.4+.19*icirc(1.-(uv.y-.2)/.08),.59)*steq(uv.y,.2,.28);\n    c-=steq(uv.x,.4+.6*cub((uv.y-.28)/.395,vec2(.408,.011),vec2(.104,1.014)),1.)*steq(uv.y,.28,.675);\n    c-=steq(uv.x,1.-.585*icirc((uv.y-.675)/.325),1.)*steq(uv.y,.675,1.);\n    c-=steq(uv.x,.0,.415)*steq(uv.y,.94+.06*osine(uv.x/.415),1.);\n    c-=steq(uv.x,.0,.085*isine(1.-(uv.y-.75)/.19))*steq(uv.y,.75,.94);\n    c-=steq(uv.x,.0,.4)*steq(uv.y,.69,.75+.045*osine(clamp((uv.x-.085)/.315,0.,1.)));\n    c-=steq(uv.x,.4,.645)*steq(uv.y,.69,.795-.105*icirc((uv.x-.4)/.245));\n    c-=steq(uv.x,.0,.035+.61*cub((uv.y-.3)/.39,vec2(.891,-.042),vec2(.592,.977)))*steq(uv.y,.3,.69);\n    return c;\n}\nfloat osu_o(vec2 uv) {\n    float r=1.091666;\n    uv.x*=r;\n    uv.y=1.-abs(uv.y);\n    uv.x=abs(uv.x);\n    float te=cub(uv.x,vec2(.667,.013),vec2(.988,.366));\n    float be=1.-cub(clamp(uv.x/.402,0.,1.),vec2(.783,.035),vec2(.915,.241));\n    return steq(uv.x,0.,1.)*steq(uv.y,0.+te,1.-.595*be);\n}\nfloat osu(vec2 uv) {\n    float col=0.;\n    col+=osu_excdot((uv-vec2(.806,-.192))*1.4);\n    col+=osu_excbody((uv-vec2(.806,.23))*vec2(1.35,.9));\n    col+=osu_u((uv-vec2(.379,.0))*1.7);\n    col+=osu_sunpy((uv-vec2(-.134,.0))*1.7);\n    col+=osu_o((uv-vec2(-.667,.0))*3.4);\n    return col;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float s = 1.2-texture(iChannel0, vec2(0.52,0.2)).x*.4;\n    vec2 uv = fragCoord/iResolution.xy * s-(s-1.)*.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = COLOR;\n    \n    // Generate all dem triangles\n    for (float i = TRI; i > 0.0; i--){\n        float id = i / TRI;\n        float y = yPos(id);\n        float x = xPos(id, y);\n        float s = min(0.89, max(0.071, id * 0.5));\n        float shad = tri(\n            uv,\n            vec2(x, mix(-s, 1.0 + s / 2.0, y)),\n            s\n        );\n        \n        if (shad < 0.1)\n        \tcol = triCol(id, y) * (1.0 - shad);\n    }\n    \n    // Set background mask\n    vec2 mid=vec2(.5*iResolution.x/iResolution.y,.5);\n    float dist = distance(uv,mid);\n    if (dist > 0.4) {\n        col = vec3(0.0);\n        if (dist<0.65){\n            float sp=3.;\n            float el=.1+.2*mb();\n            float d=(dist-.4)/.25;\n          \tcol+=barz(d,fragCoord,0.,sp);\n          \tcol+=barz(d,fragCoord,.5,sp);\n          \tcol+=barz(d,fragCoord,1.,sp);\n          \tcol+=barz(d,fragCoord,1.5,sp);\n            col*=el;\n            col.x*=.75;\n            col.y*=.75;\n        }\n    } else\n        if(dist>0.32&&dist<0.37)col=spin(col,fragCoord);\n    \n    // Make circle logo shadow\n    float dist_shad = distance(uv, vec2(0.5 * iResolution.x / iResolution.y, 0.49));\n    float l_shad = abs(dist_shad - 0.4);\n    col *= mix(0.3, 1.0, min(1.0, l_shad * 30.0));\n    \n    // Make circle logo\n    float l = abs(dist - 0.4);\n    col += vec3(smoothstep(0.96, 0.97, 1.0 - l));\n    \n    if(dist<0.3) //for perf\n    col+=vec3(osu((uv-mid)/.3));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dVyD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[270, 270, 291, 291, 389], [391, 391, 427, 427, 652], [654, 654, 674, 674, 766], [768, 768, 797, 797, 864], [866, 866, 896, 896, 997], [999, 999, 1030, 1030, 1169], [1170, 1170, 1190, 1190, 1213], [1214, 1214, 1250, 1250, 1278], [1279, 1279, 1312, 1312, 1376], [1377, 1377, 1410, 1410, 1663], [1664, 1664, 1685, 1685, 1714], [1715, 1715, 1736, 1736, 1758], [1759, 1759, 1780, 1780, 1792], [1793, 1793, 1811, 1811, 1835], [1836, 1836, 1852, 1852, 1882], [1883, 1883, 1904, 1904, 1934], [1935, 1935, 1965, 1965, 2297], [2298, 2298, 2309, 2309, 2372], [2373, 2373, 2420, 2420, 2741], [2742, 2742, 2769, 2769, 2911], [2912, 2912, 2940, 2940, 3068], [3069, 3069, 3091, 3091, 3444], [3445, 3445, 3471, 3471, 4616], [4617, 4617, 4639, 4639, 4909], [4910, 4910, 4930, 4930, 5197], [5198, 5198, 5252, 5252, 6872]], "test": "error"}
{"id": "4dVyzc", "name": "Supercoiled Helix Bundle", "author": "dr2", "description": "Lots of helix...", "tags": ["helix"], "likes": 5, "viewed": 408, "published": "Public API", "date": "1522793520", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Supercoiled Helix Bundle\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir;\nfloat tCur, dstFar;\nconst float pi = 3.14159;\n\nfloat ObjDf (vec3 p)\n{\n  float cvOrd, a;\n  cvOrd = 7.;\n  a = atan (p.z, p.x) / (2. * pi);\n  p.xz = Rot2D (vec2 (length (p.xz) - 2., mod (p.y + 2. * a + 2., 2.) - 1.),\n     2. * pi * (cvOrd - 1.) * a);\n  return 0.4 * (length (Rot2D (p.xz, - (floor ((0.5 * pi - atan (p.x, p.z)) + pi / cvOrd))) -\n     vec2 (0.6, 0.)) - 0.15);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col = vec3 (0.7, 0.7, 0.8) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.4 * vec3 (1., 1., 0.7) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (0.6, 0.6, 1.) * (0.2 + 0.2 * (rd.y + 1.) * (rd.y + 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.1 * pi * tCur;\n    el -= 0.35 * pi * sin (0.07 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, 0.4 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -20.);\n  rd = vuMat * normalize (vec3 (uv, 5. + 2. * sin (0.05 * pi * tCur)));\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dVyzc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[222, 222, 244, 244, 548], [550, 550, 583, 583, 760], [762, 762, 783, 783, 983], [985, 985, 1020, 1020, 1433], [1435, 1435, 1491, 1491, 2378], [2380, 2380, 2410, 2410, 2468]], "test": "ok"}
{"id": "4dycDd", "name": "Voxel /w diffuse", "author": "konidia", "description": "Voxel rendering is interesting", "tags": ["raycasting", "voxel", "diffuse", "traversal"], "likes": 7, "viewed": 214, "published": "Public", "date": "1523733531", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_ITERATION = 256;\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Camera\n{\n    vec3 pos;\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    float fovScalar;\n};\n\n// to setup camera\nvoid setCamera(vec3 pos, vec3 forward, vec3 upGuide, float fov, out Camera cam)\n{\n    cam.pos = pos;\n    cam.forward = normalize(forward);\n    cam.right = cross(-cam.forward, normalize(upGuide));\n    cam.up = cross(cam.right, -cam.forward);\n    cam.fovScalar = tan(radians(fov/2.0));\n}\n\n// to setup ray\nRay castRay(vec2 uv, in Camera cam)\n{\n    uv *= cam.fovScalar;\n    return Ray(\n        cam.pos,\n        normalize(cam.forward + uv.x * cam.right + uv.y * cam.up)\n    );\n}\n\n// rand generator\nfloat rand(float x)\n{\n    vec2 xx = vec2(x);\n    return fract(sin(dot(xx, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// test intersection with randomly generated voxel\nbool randIntersected(vec3 p)\n{\n    vec3 upperBound = vec3(4,4,4);\n    vec3 lowerBound = vec3(-4,0,-4);\n    \n    if(all(lessThanEqual(p, upperBound))\n       && all(greaterThanEqual(p, lowerBound)))\n    {\n        float x = ceil(iTime/4.+1.) * dot(p, p);\n        \n        if(rand(x) > 0.75)\n           return true;\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n\tuv.y *= iResolution.y/iResolution.x;\n    \n    // sun pos\n    vec3 sunPos = vec3(cos(iTime)*7.,6,-sin(iTime)*7.);\n    \n    // camera\n    Camera cam;\n    vec3 pos = vec3(cos(iTime/4.)*20., sin(iTime)*10.+15., -sin(iTime/4.)*20.);\n    setCamera(pos, vec3(0, 1, 0)-pos, vec3(0, 1, 0), 70., cam);\n    \n    // initialize ray pos\n    vec3 mapPos = floor(cam.pos);\n    \n    // ray and ray displacement setup\n    Ray ray = castRay(uv, cam);\n    vec3 rayStep = sign(ray.dir);\n    vec3 deltaDist = abs(length(ray.dir)/ray.dir);\n    vec3 sideDist = sign(ray.dir)*(mapPos - ray.pos + sign(ray.dir)*0.5+0.5)*deltaDist;\n    \n    bvec3 mask;\n    vec3 col = vec3(0);\n    \n    // ray incrementation loop\n    for(int i = 0; i < MAX_ITERATION; ++i)\n    {\n        // check for intersection /w sun\n        if(all(equal(mapPos, ceil(sunPos))))\n        {\n            col = vec3(1);\n            break;\n        }\n        // check for intersection /w noise generated voxel\n        if(randIntersected(mapPos))\n        {\n            vec3 blockCol = vec3(\n                rand(mapPos.x+mapPos.y),\n                rand(mapPos.x-mapPos.y),\n                rand(mapPos.x*mapPos.y));\n            \n            vec3 normal = -normalize(rayStep*vec3(mask));\n            vec3 toSun = normalize(sunPos - mapPos);\n            col = blockCol*(vec3(max(dot(vec3(normal), toSun), 0.0)) + 0.35);\n            break;\n        }\n        // check for intersection /w floor\n        if(mapPos.y < 0.)\n        {\n            vec3 normal = -normalize(rayStep*vec3(mask));\n            vec3 toSun = normalize(sunPos - mapPos);\n            col = vec3(max(dot(vec3(normal), toSun), 0.0));\n            break;\n        }\n        \n        // increment ray in x, y, or z direction\n        \n        mask = lessThanEqual(sideDist.xyz, min(sideDist.yxx, sideDist.zzy));\n        \n        mapPos += vec3(mask) * rayStep;\n    \tsideDist += vec3(mask) * deltaDist;\n    }\n    \n    // final color\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dycDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 198, 279, 279, 483], [485, 501, 538, 538, 671], [673, 691, 712, 712, 804], [806, 857, 887, 887, 1199], [1201, 1201, 1258, 1258, 3266]], "test": "ok"}
{"id": "4dyyDc", "name": "Pattern #2: owl", "author": "lsdlive", "description": "Doodling, 2D practice.", "tags": ["2d", "doodling"], "likes": 4, "viewed": 128, "published": "Public", "date": "1523483003", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// @lsdlive\n\nmat2 r2d(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvoid amod(inout vec2 p, float m) {\n    float a = mod(atan(p.x, p.y) - m*.5, m*.5) - m*.5;\n\tp = vec2(cos(a), sin(a)) * length(p);\n}\n\nvoid mo(inout vec2 p, vec2 d) {\n    p.x = abs(p.x) - d.x;\n    p.y = abs(p.y) - d.y;\n    if(p.y>p.x) p=p.yx;\n}\n\nfloat ncos(float a) {\n    return .5 + .5 * cos(a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy - .5;\n    p.x *= iResolution.x / iResolution.y;\n    \n    p *= 5.;\n    \n    float circ = length(p);\n    \n    p*=r2d(3.14/2.);\n    //p *= r2d(iTime*.2);\n    mo(p, vec2(.2, 1.));//.3\n    amod(p, 6.28/(1. + ncos(iTime)*3.));\n    mo(p, vec2(.7, .1));\n\n    p.x = abs(p.x) - .3 - ncos(iTime*4.)*.2;\n    vec3 c = vec3(1) * smoothstep(p.x, p.x+.01, p.y);\n    \n    /*\n    c+=.8;\n    c*=length(p);\n    c = step(.4, c);\n\t*/    \n    \n    c+=.12;\n    c-=smoothstep(2., 2.02, circ);\n    \n    float stp=12.;\n\tif(length(fract((floor(p*stp)/stp))) > .85){\n        c=vec3(.5, 0, 0);\n    }\n\n\n    fragColor = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dyyDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[13, 13, 32, 32, 98], [100, 100, 134, 134, 230], [232, 232, 263, 263, 341], [343, 343, 364, 364, 395], [397, 397, 454, 454, 1095]], "test": "ok"}
{"id": "4s3BR7", "name": "No expectations", "author": "mlkn", "description": "Exercise", "tags": ["raymarching", "repeat"], "likes": 2, "viewed": 4000, "published": "Public API", "date": "1524404955", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float glow = 0.0;\nfloat time, timeOff;\nconst float EPSILON = 0.000001;\n\nmat3 makeRotationMatrix(vec3 a)\n{\n    return mat3(\n    \tcos(a.x) * cos(a.z) - sin(a.x) * cos(a.y) * sin(a.z),\n        -cos(a.x) * sin(a.z) - sin(a.x) * cos(a.y) * cos(a.z),\n        sin(a.x) * sin(a.y),\n        sin(a.x) * cos(a.z) + cos(a.x) * cos(a.y) * sin(a.z),\n        -sin(a.x) * sin(a.z) + cos(a.x) * cos(a.y) * cos(a.z),\n        -cos(a.x) * sin(a.y),\n        sin(a.y) * sin(a.z),\n        sin(a.y) * cos(a.z),\n        cos(a.y)\n    );\n}\n\n#define sph(p, r) (length(p) - r)\n#define cube(p, b) length(max(abs(p) - vec3(b), 0.))\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat capsules(vec3 q) {\n    float capsulesT = sin(iTime);\n    vec3 a = vec3(0.05);\n    vec3 b = vec3(0.2);\n    float r = 0.05 * abs(capsulesT);\n    \n    float c1 = sdCapsule(q, a, b, r);\n    float c2 = sdCapsule(q, -a, -b, r);\n    float c3 = sdCapsule(vec3(-q.x, -q.y, q.z), a, b, r);\n    float c4 = sdCapsule(vec3(-q.x, -q.y, q.z), -a, -b, r);\n    \n    float c5 = sdCapsule(vec3(-q.x, q.y, q.z), a, b, r);\n    float c6 = sdCapsule(vec3(-q.x, q.y, q.z), -a, -b, r);\n    float c7 = sdCapsule(vec3(q.x, -q.y, q.z), a, b, r);\n    float c8 = sdCapsule(vec3(q.x, -q.y, q.z), -a, -b, r);\n    \n    return min(min(min(min(min(min(min(c1, c2), c3), c4), c5), c6), c7), c8);\n}\n\nfloat sceneSDF(vec3 p) {\n    float rotationDir = p.x > 0.0 ? 1.0 : -1.0;\n    mat3 rot = makeRotationMatrix(vec3(0.0, 0.0, rotationDir * iTime * 0.6));\n    vec3 q = rot * p.xyz;\n\tfloat d = max(sph(p, mix(.125, .15, time)), cube(q, .092)); \n    \n    d = max(-capsules(q), d);\n    \n    d = max(-sph(p.xyz, mix(.1, .125, time)), d);\n\n\t// https://www.shadertoy.com/view/4t2yW1\n\tglow += 0.0001 / (.01 + d * d);\n\treturn d;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 computeSingleLight(vec3 n, vec3 p, vec3 l)\n{\n    float diffTerm = max(dot(normalize(n), normalize(l)), 0.0) * 0.6;\n    vec3 reflectVec = normalize(-reflect(l, n));\n    float specTerm = pow(max(dot(reflectVec, normalize(p)), 0.0), 10.0) * 0.8;\n    \n    return vec3(1.0 + timeOff * 0.3, 0.4, 0.4) * diffTerm +\n       vec3(0.5 + timeOff * 0.5, 1.0, 1.0) * specTerm;\n}\n\nvec3 computeLighting(vec3 n, vec3 p)\n{    \n    return computeSingleLight(n, p, vec3(0.2, 0.4, 0.6))\n        + computeSingleLight(n, p, vec3(-0.4, -0.3, 0.7));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n\tvec3 ro = vec3(0., 0., -iTime), p, repeatedP;\n    \n    float rt = sin(iTime * 0.6);\n    mat2 rot2 = mat2(cos(rt), sin(rt), -sin(rt), cos(rt));\n\tvec3 rd = normalize(vec3(rot2 * uv, -1));\n    \n    time = sin(iTime * 2.);\n    timeOff = sin(iTime * 2.0 + 3.14);\n    time = time*time;\n    timeOff = timeOff*timeOff;\n    \n\tp = ro;\n    \n    float repeat = 0.28;\n\n\tfloat t = 0.;\n    float hit = 0.;\n    vec3 normal = vec3(0.0);\n    \n\tfor (float i = 0.; i < 3.0; i += .01) {\n\t\tp = ro + rd * t;\n        repeatedP = mod(p, repeat) - repeat * 0.5;\n        \n\t\tfloat d = sceneSDF(repeatedP);\n        if (d < .001) {\n            hit = 1.0;\n            normal = estimateNormal(repeatedP);\n            break;\n        }\n        \n\t\tt += d * 0.3;\n        if (t > 70.) {\n            hit = 0.0;\n            break;\n        }\n\t}\n    vec3 l = computeLighting(normal, p);\n    l = mix(vec3(0.0), l, hit);\n    vec3 glowC = glow * vec3(timeOff * 0.5 + 0.65, 1.0, 1.0) * 0.5;\n\tvec3 c = mix(l, glowC, max(glow - 0.2, 0.0));\n\tfragColor = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s3BR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 105, 105, 512], [602, 672, 724, 724, 851], [853, 853, 877, 877, 1520], [1522, 1522, 1546, 1546, 1939], [1941, 1941, 1970, 1970, 2280], [2282, 2282, 2331, 2331, 2651], [2653, 2653, 2691, 2691, 2813], [2815, 2815, 2870, 2870, 3954]], "test": "ok"}
{"id": "4s3BR8", "name": "Radar_", "author": "Txoka", "description": "radar", "tags": ["radar"], "likes": 18, "viewed": 718, "published": "Public API", "date": "1523989809", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 1\nconst float tau =atan(1.)*8.;\n\nhighp float hash(float x) {\n    return fract(sin(x)*43758.5453);\n}\nhighp float rand(vec2 co) {\n    return fract(sin(mod(dot(co.xy ,vec2(12.9898,78.233)),3.14))*43758.5453);\n}\nfloat mark(int n,float ang2,vec2 uv,float mn,float mx){\n\tfloat aa=float(AA)/iResolution.y;\n    ang2-=tau/float(n)/2.;\n\treturn smoothstep(mn,mx,distance(uv,vec2(0)))*smoothstep(aa*2.,0.,abs(fract(ang2/tau*float(n))-0.5)/float(n)*tau*distance(uv,vec2(0)));\n}\nfloat circle(float dist,vec2 uv){\n\tfloat aa=float(AA)/iResolution.y;\n\treturn (smoothstep(dist-aa*2.,dist-aa,distance(uv,vec2(0)))-smoothstep(dist,dist+aa,distance(uv,vec2(0))))/10.;\n}\nfloat point(vec2 coord,vec2 uv,float ang){\n\tfloat aa=float(AA)/iResolution.y;\n\treturn smoothstep(0.004+aa,0.002,distance(uv,coord))*smoothstep(tau*0.7,0.,ang)/2.;\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n\tfloat aa=float(AA)/iResolution.y;\n\t\n    //uv.x+=(rand(uv*iTime)-0.5)/100.*smoothstep(0.7,1.,hash(floor(iTime)));\n    \n    float dist=distance(uv,vec2(0));\n\tfloat sdist=smoothstep(0.5+aa,0.5,dist);\n    \n    float ang=iTime*tau/5.;\n\tfloat ang2=atan(uv.x,uv.y);\n    ang=mod(ang2+ang,tau);\n    \n    float col=smoothstep(1.,0.,ang);\n    col/=2.;\n    col+=smoothstep(tau-aa/distance(uv,vec2(0)),tau,ang)/2.;\n\tcol+=sdist/10.;\n    col+=smoothstep(aa,0.,abs(uv.x))/4.;\n    col+=smoothstep(aa,0.,abs(uv.y))/4.;\n\t\n    col+=mark(9*4,ang2,uv,0.45,0.5)/2.;\n    col+=mark(9*4*5,ang2,uv,0.475,0.5)/5.;\n    col+=circle(0.1,uv);\n    col+=circle(0.2,uv);\n    col+=circle(0.3,uv);\n    col+=circle(0.4,uv);\n   \tcol+=point(vec2(0.3,0.1),uv,ang);\n    col+=point(vec2(-0.2,-0.3),uv,ang);\n    col+=point(vec2(0.2,-0.1),uv,ang);\n    \n    o = mix(vec4(0,col,0,0),vec4(0.055,0.089,0.0,0)/1.3,1.-sdist);\n\to=o;\n    \n    float l=cos(fragCoord.y);\n    l*=l;\n    l/=3.;\n    l+=0.6+rand(uv*iTime);\n    \n    o*=l;\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s3BR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 274, 274, 475], [476, 476, 509, 509, 659], [660, 660, 702, 702, 824], [826, 826, 874, 874, 1915]], "test": "error"}
{"id": "4s3BWn", "name": "Tentacle Tunnel v2", "author": "ChloeSnyder", "description": "CIS 566 final project v2", "tags": ["566"], "likes": 1, "viewed": 135, "published": "Public", "date": "1524591459", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define deg2rad PI / 180.0\n\n// RAY MARCHING CODE SOURCE JAMIE WONG\nconst int MAX_MARCHING_STEPS = 400;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 250.0;\nconst float EPSILON = 0.001;\nconst float EPSILON_NORM = .001;\n\nconst vec3 A = vec3(-3.142, -3.142, .618);\nconst vec3 B = vec3(-3.142, -3.142,-.362);\nconst vec3 C = vec3(-3.142, -3.142, 2.0);\nconst vec3 D = vec3(-3.142, -3.142, -3.142);\n\nconst vec3 A2 = vec3(0.070, 0.095, 0.157);\nconst vec3 B2 = vec3(0.636, 0.633, 0.069);\nconst vec3 C2 = vec3(1.508, 0.758, 0.951);\nconst vec3 D2 = vec3(4.307, 5.442, 2.733);\n\n// stripes are too thin\nconst vec3 A3 = vec3(.421, .116, .699);\nconst vec3 B3 = vec3(.001, .238, .050);\nconst vec3 C3 = vec3(.119, .888, 1.262);\nconst vec3 D3 = vec3(4.926, .433, 4.186);\n\n//thicker stripes\nconst vec3 A4 = vec3(-0.412, -0.202, -0.412);\nconst vec3 B4 = vec3(1.458, 1.122, 3.295);\nconst vec3 C4 = vec3(1.820, 1.820, 1.820);\nconst vec3 D4 = vec3(4.625, 2.557, 2.557);\n\nconst vec3 PINK = 1.2 * vec3(203.0/255.0, 49.0/255.0, 122.0/255.0);\nconst vec3 DARK_PURPLE = 1.2 * vec3(115.0/255.0, 49.0/255.0, 111.0/255.0);\nconst vec3 NAVY = vec3(13.0/255.0, 26.0/255.0, 60.0/255.0);\nconst vec3 BLACK = vec3(0.0);\nconst vec3 WHITE = vec3(1.0);\nconst vec3 TEAL = 1.2 * vec3(107.0/255.0, 192.0/255.0, 185.0/255.0);\nconst vec3 DARK_TEAL = 1.2 * vec3(54.0/256.0, 83.0/256.0, 78.0/256.0);\nconst vec3 ORANGE = 1.2 * vec3(233.0/255.0, 89.0/255.0, 55.0/255.0);\nconst vec3 DARK_ORANGE = .82 * vec3(184.0/255.0, 75.0/255.0, 44.0/255.0);\nconst vec3 RED = 1.2 * vec3(200.0/255.0, 28.0/255.0, 35.0/255.0);\nconst vec3 DARK_RED = 1.2 * vec3(54.0/255.0, 6.0/255.0, 4.0/255.0);\nconst vec3 GREEN = 1.2 * vec3(45.0/255.0, 121.0/255.0, 91.0/255.0);\nbool colorSet = false;\n\nvec3 K_d = vec3(-1, -1, -1); // diffuse color\nfloat shininess;\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat noise( in vec2 x )\n{\n\treturn sin(1.5*x.x)*sin(1.5*x.y);\n}\n\n\nfloat noise2(vec3 x)\n{\n        return fract(sin(dot(x.xy,\n                         vec2(12.9898,78.233)))\n                * 43758.5453123);\n}\n\nvec2 rot(vec2 r, float a) {\n\treturn vec2(\n\t\tcos(a) * r.x - sin(a) * r.y,\n\t\tsin(a) * r.x + cos(a) * r.y);\n}\n\n\n\n\n//https://github.com/BrianSharpe/GPU-Noise-Lib/blob/master/gpu_noise_lib.glsl\nvec4 FAST32_hash_3D_Cell( vec3 gridcell )\t//\tgenerates 4 different random numbers for the single given cell point\n{\n    //    gridcell is assumed to be an integer coordinate\n\n    //\tTODO: \tthese constants need tweaked to find the best possible noise.\n    //\t\t\tprobably requires some kind of brute force computational searching or something....\n    const vec2 OFFSET = vec2( 50.0, 161.0 );\n    const float DOMAIN = 69.0;\n    const vec4 SOMELARGEFLOATS = vec4( 635.298681, 682.357502, 668.926525, 588.255119 );\n    const vec4 ZINC = vec4( 48.500388, 65.294118, 63.934599, 63.279683 );\n\n    //\ttruncate the domain\n    gridcell.xyz = gridcell - floor(gridcell * ( 1.0 / DOMAIN )) * DOMAIN;\n    gridcell.xy += OFFSET.xy;\n    gridcell.xy *= gridcell.xy;\n    return fract( ( gridcell.x * gridcell.y ) * ( 1.0 / ( SOMELARGEFLOATS + gridcell.zzzz * ZINC ) ) );\n}\n\n//https://github.com/BrianSharpe/GPU-Noise-Lib/blob/master/gpu_noise_lib.glsl\nfloat Falloff_Xsq_C2( float xsq ) { xsq = 1.0 - xsq; return xsq*xsq*xsq; }\n\n//https://github.com/BrianSharpe/GPU-Noise-Lib/blob/master/gpu_noise_lib.glsl\nfloat PolkaDot3D( \tvec3 P,\n                    float radius_low,\t\t\n                    float radius_high\t)\n{\n    //\testablish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n\n    //\tcalculate the hash.\n    vec4 hash = FAST32_hash_3D_Cell( Pi );\n\n    //\tuser variables\n    float RADIUS = max( 0.0, radius_low + hash.w * ( radius_high - radius_low ) );\n    float VALUE = RADIUS / max( radius_high, radius_low );\t//\tnew keep value in proportion to radius.  Behaves better when used for bumpmapping, distortion and displacement\n\n    //\tcalc the noise and return\n    RADIUS = 2.0/RADIUS;\n    Pf *= RADIUS;\n    Pf -= ( RADIUS - 1.0 );\n    Pf += hash.xyz * ( RADIUS - 2.0 );\n    //Pf *= Pf;\t\t//\tthis gives us a cool box looking effect\n    return Falloff_Xsq_C2( min( dot( Pf, Pf ), 1.0 ) ) * VALUE;\n}\n\n\n/**\n * Rotation matrix around the X axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// modified from jamie wong\nvec3 scaleOp(vec3 samplePoint, vec3 scale)\n{\n\treturn (samplePoint / scale) * min(scale.x, min(scale.y, scale.z));\n}\n\n//JW\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n//JW\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n//JW\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n// iq\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//iq\nfloat smin2( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n\n// iq\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n//iq\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n// iq\nfloat cylinderSDF( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//http://glslsandbox.com/e#40928.0\nfloat saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\n\n// Based off: //http://glslsandbox.com/e#40928.0\n// Creates the main body of tentacle\nfloat noodle (vec3 p)\n{\n   \n    float scale = 1.0 - 2.5 * saturate( abs( p.y ) * 0.01 );  \n    \n    // sdCapsule, second argument defines lower end point, third is upper end point\n    // p is the point being evaluated, last argument is thickness\n    float cap = sdCapsule(p, vec3( 0.0, -6.0, 0.0 ), vec3( 0.0, 4.0, 0.0 ), 0.3 * scale );\n\t\n    // want more tapering at the end\n    float cone = sdCone(rotateX(-PI/2.0) * p + vec3(0.0, 0.0, -1.0), normalize(vec2(1.5, .30)));\n    //return cone;\n    return smin(cone, cap, -.5);\n}\n\nfloat suctionCup(vec3 p, float scale, int i, int tentacleID)\n{\n    \n    vec3 cp = rotateX(-PI/2.0) * p;\n    float outer = cylinderSDF(cp, vec2(1.0, .30) / scale);\n    float inner = cylinderSDF(cp, vec2(.25, .5) / ((.4) * scale));\n    \n    float mid = differenceSDF(outer, inner);\n    \n    if(mid < EPSILON) {\n        float currTent = mod(float(tentacleID), 4.0);\n        float currSC = mod(float(i), 2.0);\n       \n        if(currTent == 0.0)\n        {\n   \t\t\tif(currSC == 0.0 && !colorSet)\n    \t\t{ \n        \t\tK_d = PINK;\n        \t\tcolorSet = true;\n    \t\t} else if(currSC != 0.0 && !colorSet)\n    \t\t{\n        \t\tK_d = DARK_PURPLE;\n            \tcolorSet = true;\n    \t\t}\n        } else if (currTent == 1.0) {\n            if(currSC == 0.0 && !colorSet)\n    \t\t{ \n        \t\tK_d = TEAL;\n        \t\tcolorSet = true;\n    \t\t} else if(currSC != 0.0 && !colorSet)\n    \t\t{\n        \t\tK_d = DARK_TEAL;\n            \tcolorSet = true;\n    \t\t}\n        } else if (currTent == 2.0) {\n            if(currSC == 0.0 && !colorSet)\n    \t\t{ \n        \t\tK_d = RED;\n        \t\tcolorSet = true;\n    \t\t} else if(currSC != 0.0 && !colorSet)\n    \t\t{\n        \t\tK_d = DARK_RED;\n            \tcolorSet = true;\n    \t\t}\n        } else {\n            if(currSC == 0.0 && !colorSet)\n    \t\t{ \n        \t\tK_d = ORANGE;\n        \t\tcolorSet = true;\n    \t\t} else if(currSC != 0.0 && !colorSet)\n    \t\t{\n        \t\tK_d = DARK_ORANGE;\n            \tcolorSet = true;\n    \t\t}\n        }\n    }\n    \n    return mid;\n}\n\n\n\n\n//http://glslsandbox.com/e#40928.0\n// Creates the tentacle by calling noodle and placing suction cups along body of tentacle\nfloat Tentacle( vec3 p , int tentacleID)\n{\n    p.x -= sin( p.y * 2.0 + iTime * 7.0 ) * 0.21;\n    \n    float noodle = noodle(p); // The \"main body\" of the tentacle\n    if(noodle < EPSILON)\n    {\n        \n        float pt = PolkaDot3D(p, .0, .5);\n        if(pt < EPSILON)\n        {\n            K_d = BLACK;//vec3(pt, pt, pt);\n            colorSet = true;\n        } else {\n       \t\tK_d = NAVY;// vec3(0.0, 0.0, 0.0);// palette(sin(iTime), A, B, C, D);\n            colorSet = true;\n        }\n    } \n    \n    float scale = 150.0;\n    p += vec3(0.0, -.70, 0.0);\n    vec3 sc_p1 = p - vec3(0.01, 0.0, 0.03);\n    vec3 sc_p2 = p - vec3(-0.01, 0.0, 0.03);\n    \n    \n    sc_p1 = rotateY(PI/4.0) * sc_p1;\n    sc_p2 = rotateY(-PI/4.0) * sc_p2;\n    \n    vec3 init_sc_p1 = sc_p1;\n    vec3 init_sc_p2 = sc_p2;\n    float init_scale = scale;\n    \n    float sc1 = suctionCup(sc_p1, scale, 0, tentacleID);\n    float sc2 = suctionCup(sc_p2, scale, 0, tentacleID);\n    float sc = unionSDF(sc1, sc2);\n    \n    // first six suction cups: start small and scale bigger\n    // as they are placed from the tip towards the base\n    // also, rotate so that they lie \"on\" the surface of the tentacle\n    // alternate colors\n    for(int i = 0; i < 6; i++)\n    {\n        scale /= 1.45;\n        sc_p1 += vec3(-0.00005, .05 * float(i),float(i) * -0.0085);\n        sc_p2 += vec3(0.00005, .05 * float(i),float(i) * -0.0085);\n        sc1 = suctionCup(sc_p1, scale, i, tentacleID);\n        sc2 = suctionCup(sc_p2, scale, i, tentacleID);    \n        sc = unionSDF(sc, sc1);\n        sc = unionSDF(sc, sc2);\n     }\n  \n    \n    sc_p1 = rotateY(-PI/8.0) * sc_p1;\n    sc_p2 = rotateY(PI/8.0) * sc_p2;\n    \n    // Once close enough to the base, can be the same size and rotation\n    for(int j = 6; j < 15; j++)\n    {\n    \n        sc_p1 += vec3(0, .25 , -0.0179);\n        sc_p2 += vec3(0, .25 , -0.0179);\n        sc1 = suctionCup(sc_p1, scale, j, tentacleID);\n        sc2 = suctionCup(sc_p2, scale, j, tentacleID);\n        sc = unionSDF(sc, sc1);\n        sc = unionSDF(sc, sc2);\n    }\n    \n   \n    return smin(noodle, sc, .01);\n  \n}\n\n// modified from iq\nfloat opRep(vec3 p, int i)\n{\n    vec3 q = vec3(p.x + cos(iTime), p.y + sin(iTime), mod(p.z,9.0));\n\n    float scale = 1.0 - 2.5 * saturate( abs( q.y ) * 0.01 );  \n   \tfloat boundingCapsule = sdCapsule(q, vec3( 0.0, -6.0, 0.0 ), vec3( 0.0, 4.0, 0.0 ),  .50 * scale );\n    float tentacle; \n\n    if(boundingCapsule < .001)\n   \t{\n    \ttentacle = Tentacle(q, i);\n        \n    } else {\n        tentacle = boundingCapsule;\n   \t}\n\n    return tentacle;\n}\n\n\n// Creates the tunnel and maps the tentacles onto it\nfloat map( vec3 p){\n   \n    float tentacleRing = -1.0;\n    float amplitude = 1.9;\n    int numTentacles = 12;\n    float offSet = (noise(.75 * PI * p.xy)/2.0 * sin(3.0 * iTime));\n    float m = cos(p.x) + cos(p.y) + sin(p.z) + offSet;\n\n    if(m < EPSILON)\n    {\n\t        \n        vec3 colorPoint = vec3(cos(p.x) + offSet + p.x + sin(iTime), cos(p.y) + offSet + p.y + iTime, sin(p.z) + offSet + p.z + iTime);\n        float whitept = PolkaDot3D(mod(p, 3.0), .0, .50);\n        float blackInside = PolkaDot3D(mod(p, 3.0), .0, .4);\n        \n        \n        float greenpt = PolkaDot3D(p, .30, .35);\n        float blackInside2 = PolkaDot3D(p, .30, .15);\n\t\t\n        float ptOffY = PolkaDot3D(colorPoint + p, .0, .2);\n        float ptOffR = PolkaDot3D(mod(colorPoint, 25.0), .0, .2);\n       \n        vec3 redDotsOff = vec3(ptOffR, 0.0, 0.0);\n        vec3 yellowDotsOff = vec3(ptOffY, ptOffY, 0.0);\n        \n        \n       if(whitept > 0.0)\n        {\n            if(blackInside > 0.0)\n            {\n                K_d = BLACK;//vec3(-1.0);\n            } else {\n                K_d = WHITE;\n            }\n        }\n        else if(redDotsOff.x > 0.0)\n        {\n            K_d = RED;\n        }\n         else if(greenpt > 0.0)\n        {\n            if(blackInside2 > 0.0)\n            {\n                K_d = BLACK;//vec3(-1.0);\n            } else {\n                K_d =  ORANGE;\n            }\n        }\n        else if(yellowDotsOff.x > 0.0)\n        {\n            K_d = ORANGE;\n        } else {\n            vec3 c1 = .52 * palette( p.z, A4, B4, C4, D4);\n            vec3 c2 = .52 * palette( p.z , A3, B3, C3, D3);\n\n            K_d = mix(c1, c2, cos(iTime * 2.));\n            \n        }\n       \n    }\n    float gap = 360.0 / float(numTentacles) * deg2rad;\n    \n    for(int i = 0; i < numTentacles; i++)\n    {\n\n       \tfloat angle = float(i) * gap;     \n             \n        float offsetX = (amplitude) * sin(angle);\n    \tfloat offsetY = (amplitude) * cos(angle);\n        \n        vec3 localP = p;\n        localP += vec3(offsetX, offsetY, 0.0);\n        localP = rotateZ(-angle) * localP;\n        \n        \n        float tentacle = opRep(localP, i);\n        \n        if(tentacleRing == -1.0)\n        {\n            tentacleRing = tentacle;\n        }\n      \n        tentacle = unionSDF(tentacle, m); \n        tentacleRing = unionSDF(tentacle, tentacleRing);\n\n    }\n    \n    \n             \n    return tentacleRing;\n    \n}\n\n  \nfloat sceneSDF(vec3 samplePoint) {\n    \n    float sdf = map(samplePoint);\n     return sdf;\n\n  \n}\n\n\n/** JW\n * \n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/** JW\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/** JW\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON_NORM, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON_NORM, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON_NORM, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON_NORM, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON_NORM)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON_NORM))\n    ));\n}\n\n\nfloat lambert(vec3 N, vec3 L)\n{\n  vec3 nrmN = normalize(N);\n  vec3 nrmL = normalize(L);\n  float result = dot(nrmN, nrmL);\n  return max(result, 0.0);\n}\n\n\n/** JW\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n//iq\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayOri,   // camera position\n               in vec3  rayDir )  // camera to point vector\n{\n    float b = .1;\n    float c = .1;\n    float fogAmount = c * exp(-rayOri.y*b) * (1.0-exp( -distance*rayDir.y*b ))/rayDir.y;\n    vec3  fogColor  = mix(vec3(01.5,0.6,1.7), TEAL, sin(iTime));// mix(TEAL, vec3(01.5,0.6,1.7), sin(iTime));\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 2.5 * iTime);\n      \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    \n    worldDir.xy = rot(worldDir.xy, (iTime));\n\n   \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(WHITE,1.0);//vec4(mix(vec3(01.5,0.6,1.7), TEAL, sin(iTime)),1.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n\n    \n    vec3 color = K_d * lambert(estimateNormal(p), eye);\n\n    vec3 color_fog = applyFog(color, dist, eye, worldDir);\n    \n    fragColor = vec4(color_fog, 1.0);\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s3BWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1815, 1815, 1887, 1887, 1930], [1932, 1932, 1958, 1958, 1995], [1998, 1998, 2020, 2020, 2139], [2141, 2141, 2168, 2168, 2247], [2252, 2330, 2445, 2673, 3183], [3185, 3263, 3298, 3298, 3337], [3339, 3417, 3525, 3574, 4240], [4243, 4327, 4354, 4354, 4501], [4503, 4587, 4614, 4614, 4761], [4763, 4847, 4874, 4874, 5021], [5023, 5051, 5095, 5095, 5166], [5168, 5173, 5219, 5219, 5251], [5253, 5258, 5300, 5300, 5332], [5334, 5339, 5386, 5386, 5419], [5421, 5427, 5468, 5468, 5561], [5563, 5568, 5610, 5610, 5681], [5684, 5690, 5742, 5742, 5869], [5871, 5876, 5908, 5936, 5997], [5999, 6005, 6042, 6042, 6141], [6143, 6178, 6205, 6205, 6240], [6243, 6329, 6352, 6352, 6855], [6857, 6857, 6919, 6919, 8310], [8315, 8440, 8482, 8482, 10524], [10526, 10546, 10574, 10574, 10990], [10993, 11046, 11065, 11065, 13451], [13456, 13456, 13490, 13490, 13552], [13555, 13570, 13661, 13661, 13967], [13982, 13993, 14058, 14058, 14190], [14192, 14284, 14313, 14313, 14653], [14656, 14656, 14687, 14687, 14806], [14809, 15139, 15188, 15223, 15449], [15451, 15456, 15697, 15697, 15978], [15980, 15980, 16037, 16037, 16904]], "test": "timeout"}
{"id": "4scBDr", "name": "Finally some 3d (self pass)", "author": "Sunpy", "description": "Attempt on making some sort of 3d feel.", "tags": ["3d", "loop"], "likes": 0, "viewed": 110, "published": "Public", "date": "1524646483", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat map(vec3 p){\n    vec3 q = fract(p) * 2. - 1.;\n    \n    return length(q) - 1.25;\n}\n\nfloat trace(vec3 o, vec3 r){\n    float t = 0.;\n    for (int i = 0; i < 32; ++i){\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * .5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 r = normalize(vec3(uv, 1.));\n    float rot = iTime * .5;\n    r.xz *= mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    r.xy *= mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    \n    vec3 o = vec3(.5 + cos(iTime * PI * .5), .5 + sin(iTime * PI * .5), -iTime);\n    float t = trace(o, r);\n    float fog = 1. / (1. + t * t * 2.);\n    \n    col += fog;\n    \n    \n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4scBDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 64, 64, 133], [135, 135, 163, 163, 312], [314, 314, 371, 371, 912]], "test": "ok"}
{"id": "4scBW8", "name": "Blurry Spheres", "author": "Klems", "description": "Short exemple of depth of field with cone tracing. Click the screen to change the focal length.", "tags": ["3d", "raymarch", "dof"], "likes": 117, "viewed": 4469, "published": "Public API", "date": "1524815120", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define rot(a) mat2(cos(a + PI*0.25*vec4(0,6,2,0)))\n#define FOV 2.0\n#define HEX vec2(1, 1.73205080757)\n\n#define LIGHT_ENABLE\n#define LIGHT_FREQ 0.3\n#define LIGHT_COLOR vec3(0.05, 0.2, 0.8)\n\n// Dave Hoskins hash\nfloat hash13( in vec3 p3 ) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// hexagonal tiling\nvec2 hexCenter( in vec2 p ) {\n    vec2 centerA = (floor(p.xy*HEX)+0.5)/HEX;\n    vec2 centerB = (floor((p.xy+HEX*0.5)*HEX)+0.5)/HEX-HEX*0.5;\n    vec2 a = p.xy-centerA.xy; vec2 b = p.xy-centerB.xy;\n    return dot(a,a)<dot(b,b) ? centerA : centerB;\n}\n\n// control sphere height\nvec3 getSphereCenter( in vec2 c ) {\n    return vec3(c, sin(c.x-c.y*4.3+iTime)*0.2);\n}\n\n// main distance function, returns distance and color\nfloat de( in vec3 p, in vec3 dir, in float r, out vec3 color ) {\n    \n    // translate and get the center\n    p.xy += iTime;\n    vec2 center = hexCenter(p.xy);\n    // find out where the red light is\n    float red = floor(iTime*LIGHT_FREQ)+0.5;\n    float fRed = smoothstep(0.5, 0.0, abs(fract(iTime*LIGHT_FREQ)-0.5));\n    vec3 centerRed = getSphereCenter(hexCenter(red/LIGHT_FREQ + vec2(0.5, 1.5)));\n    \n    #ifndef LIGHT_ENABLE\n    fRed = 0.0;\n    #endif\n    \n    // accumulate distance and color\n    float d = 9e9;\n    color = vec3(0);\n    float colorAcc = 0.0;\n    for (int i = 0 ; i < 7 ; i++) {\n        float theta = float(i) * (2.0*PI/6.0);\n        vec2 offset = vec2(sin(theta), cos(theta))*min(1.0/HEX.y, float(i));\n        vec3 sphere = getSphereCenter(center + offset);\n        vec3 inCenter = p - sphere;\n        float len = length(inCenter);\n        vec3 norm = inCenter / len;\n        vec3 toRed = sphere-centerRed;\n\n        // select the nearest sphere\n        float dist = len-0.3;\n        d = min(d, dist);\n\n        // colors and light\n        vec3 albedo = vec3(sin(sphere.x*90.0+sphere.y*80.0)*0.45+0.5);\n        vec3 colorHere = vec3(0);\n        \n        if (dot(toRed, toRed) < 0.001) {\n            albedo = mix(albedo, vec3(0.0), fRed);\n            colorHere += LIGHT_COLOR*fRed*4.0;\n        } else {\n            vec3 lightDir = centerRed-p;\n            float len = dot(lightDir, lightDir);\n            lightDir *= inversesqrt(len);\n            vec3 col = LIGHT_COLOR*fRed/(len+1.0)*2.0;\n            colorHere += albedo*max(0.0, dot(norm, lightDir)+0.5/len)*col;\n            colorHere += albedo*pow(max(0.0, dot(lightDir, reflect(dir, norm))), 8.0)*col;\n        }\n        \n        const vec3 lightDir = normalize(vec3(1, -1, 3));\n        colorHere += albedo*max(0.0, dot(lightDir, norm));\n        colorHere += albedo*pow(max(0.0, dot(lightDir, reflect(dir, norm))), 8.0);\n        \n        // accumulate color across neighborhood\n        float alpha = max(0.0001, smoothstep(r, -r, dist));\n        color += colorHere*alpha;\n        colorAcc += alpha;\n    }\n    \n    color /= colorAcc;\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\tvec3 from = vec3(0, 0, 1.2);\n\tvec3 dir = normalize(vec3(uv, -1.0/tan(FOV*0.5)));\n\tdir.yz *= rot(-0.85);\n    dir.xy *= rot(0.2);\n    \n    float focal = 2.5;\n    if (iMouse.z > 0.5) focal = 1.0+iMouse.y/iResolution.y*4.0;\n    float sinPix = sin(FOV / iResolution.y);\n    vec4 acc = vec4(0, 0, 0, 1);\n    vec3 dummy = vec3(0);\n    float totdist = de(from, dir, 0.0, dummy)*hash13(vec3(fragCoord, iFrame));\n    for (int i = 0 ; i < 100 ; i++) {\n\t\tvec3 p = from + totdist * dir;\n        float r = max(totdist*sinPix, abs((totdist-focal)*0.1));\n        vec3 color = vec3(1);\n        float dist = de(p, dir, r, color);\n        \n        // cone trace the surface\n\t\tfloat alpha = smoothstep(r, -r, dist);\n        acc.rgb += acc.a * (alpha*color.rgb);\n        acc.a *= (1.0 - alpha);\n        \n        // hit a surface, stop\n        if (acc.a < 0.01) break;\n        // continue forward\n        totdist += max(abs(dist), r*0.5);\n\t}\n    \n    fragColor.rgb = clamp(acc.rgb, vec3(0), vec3(1));\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4scBW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[215, 236, 264, 264, 367], [369, 389, 418, 418, 636], [638, 663, 698, 698, 748], [750, 804, 868, 909, 2924], [2926, 2926, 2983, 2983, 4112]], "test": "error"}
{"id": "4sdBD8", "name": "helix 5 (double helix)", "author": "FabriceNeyret2", "description": ".", "tags": ["raymarching", "sdf", "spiral", "helix", "spring", "short"], "likes": 7, "viewed": 470, "published": "Public API", "date": "1524917269", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/4sdBW8\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t = iTime,l,d, r=20., a;\n    mat2  R = mat2( sin(t+vec4(0,33,11,0)) );\n    vec3  q = iResolution, c,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),    // ray direction\n          p = 90./q;                          // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p,\n        q.xz *= R, q.yz *= R,                 // rotation\n        c = q, c.x+=r, a = atan(c.z,c.x), \n        q.x = length(c.xz)-r, q.z = r*a, q.y = mod(q.y-a*r/6.3,r)-r/2.,// global helix\n        l = length(q.xy), d = sin(atan(q.y,q.x)-q.z),           // sin: double\n                      //  d = mod(atan(q.y,q.x)-q.z,6.28)-3.14, // mod: single\n        t = length(vec2(l-4.,d)) - .5,        // double-spring\n        p += t*D;                             // step forward = dist to obj\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdBD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 85, 85, 898]], "test": "error"}
{"id": "4sdBW8", "name": "helix 2", "author": "FabriceNeyret2", "description": ".", "tags": ["raymarching", "sdf", "spiral", "helix", "spring", "short"], "likes": 3, "viewed": 361, "published": "Public API", "date": "1524903016", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/XsdBW8\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t = iTime,l,d;\n    mat2  R = mat2( sin(t+vec4(0,33,11,0)) );\n    vec3  q = iResolution,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),    // ray direction\n          p = 30./q;                          // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p,\n        q.xz *= R, q.yz *= R,                 // rotation\n        l = length(q.xy), d = sin(atan(q.y,q.x)-q.z),           // sin: double\n                      //  d = mod(atan(q.y,q.x)-q.z,6.28)-3.14, // mod: single\n        t = length(vec2(l-4.,d)) - .5,        // double-spring\n        p += t*D;                             // step forward = dist to obj\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdBW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 85, 85, 755]], "test": "error"}
{"id": "4sdBWn", "name": "catadioptre 5d", "author": "FabriceNeyret2", "description": ".", "tags": ["raymarching", "sdf", "short"], "likes": 2, "viewed": 308, "published": "Public API", "date": "1524693362", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/XdtBWn\n\n#define C      max(max(a.x,a.y),a.z)\n#define R(x,y) t = max(t, max(abs(q.x+q.y),abs(q.x-q.y)) /1.41 )  \n#define O(a)   q=q0, q.a=b.a, t-=t, R(x,y), R(y,z), R(x,z) -7., v = max(v,-t)\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t = iTime,v;\n    mat2  R = mat2( sin(t+vec4(0,33,11,0)) );\n    vec3  q = iResolution,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),    // ray direction\n          p = 30./q, q0,a,b;                  // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p,\n        q.xz *= R, q.yz *= R,                 // rotation\n        q0 = q,\n        a = abs(q), v = C - 5.,               // cube\n        a = abs(mod(q,3.2)-1.6),\n        v = max(v, 1.6-C),                    // grid of hollow cubes\n        b = mod(q0,20.)-10.,\n        v = max(v,-t),\n        O(x), O(y), O(z),                     // - octaedron pairs along x,y,z axis\n        t = .5*v,\n        p += t*D;                             // step forward = dist to obj\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[232, 232, 268, 268, 1042]], "test": "error"}
{"id": "4sGcDG", "name": "l o a d i n g", "author": "zlnimda", "description": "Little animation inspired from @motions_work : https://twitter.com/motions_work/status/977509125016842240", "tags": ["loading", "easing"], "likes": 10, "viewed": 620, "published": "Public API", "date": "1523050358", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* ----------------\n*\tzlnimda wrote this file and is under license CC-BY-SA-4.0 \n* \t( see legal notice: https://creativecommons.org/licenses/by-sa/4.0/legalcode )\n/* ----------------\n* \tAnimation of loading\n*/\nprecision highp float;\n\n// AA\n#define\tLOW_RPX\t(20./max(iResolution.x,iResolution.y))\n\n#define RATIO\t(iResolution.x/iResolution.y)\n#define FONT_R\t(16.)\n#define FONT_S\t(1./FONT_R)\n\nconst float M_PI = 3.1415926535897932384626433832795;\n\nconst vec4\tYELOW  = vec4(vec3(0xD3, 0xE7, 0x14) / vec3(0xFF), 1.);\nconst vec4 \tRED    = vec4(vec3(0xFF, 0x38, 0x67) / vec3(0xFF), 1.);\nconst vec4\tBLUE   = vec4(vec3(0x46, 0x2D, 0xFE) / vec3(0xFF), 1.);\nconst vec4\tCYAN   = vec4(vec3(0x09, 0xDE, 0xAF) / vec3(0xFF), 1.);\nconst vec4 \tWHITE  = vec4(1.);\nconst vec4 \tBBLACK = vec4(0., 0., 0., 1.);\n\n\nvec2 rot(vec2 uv, float a)\n{\n    return (mat2(cos(a), -sin(a), sin(a), cos(a)) * mat2(RATIO, 0., 0., 1.)) * uv;\n}\n\n// almost signed dist sq\nvec2 sdsq(vec2 uv, vec2 o, vec2 s, float a)\n{\n    // handle angle & ratio\n    uv = rot(o - uv, a);\n    return s/2.0 - abs(uv);\n}\n\n\n// almost signed dist sp\nfloat sdsp(vec2 uv, vec2 o, float s)\n{\n    // handle angle & ratio\n    uv = o - uv;\n    return length(uv) - s*.5;\n}\n\n// text\nvec4 tx(vec2 uv, vec2 o, float s, float c, float a)\n{\n    // italic weird, keep ratio\n    mat2 rot = mat2(cos(a), 0., -sin(a), 1.) * mat2(RATIO, 0., 0., 1.);\n    uv = rot * (o - uv);\n    vec2 d = s/2.0 - abs(uv);\n    vec2 texCoord = -1.*uv/s+vec2(.5);\n    vec2 offset = vec2(mod(c, FONT_R), -1.-floor(c / FONT_R)) * FONT_S;\n    vec4 f = textureGrad(iChannel0, texCoord*FONT_S + offset, dFdx(uv/16.),dFdy(uv/16.));\n    \n    return mix(vec4(0.0), smoothstep(.5,.485,f.wwww)*f.x, step(0.0, min(d.x, d.y)));\n}\n\n// sq color\nvec4 sq(vec2 uv, vec2 o, vec2 s, vec4 c, float a)\n{\n    // AA\n    s *= 1.+LOW_RPX;\n    vec2 d = sdsq(uv, o, s, a);\n    // AA\n    float dd = min(d.x, d.y);\n    vec3 rc = mix(vec3(.0), c.xyz,\n               // step(.0, dd)\n                clamp(smoothstep(.0, LOW_RPX, dd) / LOW_RPX, .0, 1.)\n              );\n    return vec4(rc, mix(.0, c.a, step(.0, dd)));\n}\n\n// sp color\nvec4 sp(vec2 uv, vec2 o, float s, vec4 c)\n{\n    // AA\n    s *= 1.+LOW_RPX;\n    float d = sdsp(uv, o, s);\n    //return mix(c, vec4(0.0), step(0.0, d));\n    \n    // AA\n    vec3 rc = mix(c.xyz, vec3(.0),\n               // step(.0, dd)\n                clamp(smoothstep(.0, LOW_RPX, d) / LOW_RPX, .0, 1.)\n              );\n    return vec4(rc, mix(c.a, .0, step(.0, d)));\n}\n\nvec4 loading(vec2 uv, vec2 o, float s)\n{\n    vec4 c;\n    float off = 0.;\n    const float d = 0.42;\n    o -= vec2(3.5 *s*d, .0);\n    c += tx(uv, o+vec2((off       ), 0.), s, 108., .0);\n    c += tx(uv, o+vec2((off += s*d), 0.), s, 111., .0);\n    c += tx(uv, o+vec2((off += s*d), 0.), s, 097., .0);\n    c += tx(uv, o+vec2((off += s*d), 0.), s, 100., .0);\n    c += tx(uv, o+vec2((off += s*d), 0.), s, 105., .0);\n    c += tx(uv, o+vec2((off += s*d), 0.), s, 110., .0);\n    c += tx(uv, o+vec2((off += s*d), 0.), s, 103., .0);\n    return c;\n}\n\nfloat BezierDeg4(float p0, float p1, float p2, float p3, float t)\n{\n    // bezier formula following bernstein Bez(t) = E(i->n)Bern(t).Pi with t=[0,1]\n    return p0*pow(1.-t, 3.) + p1*3.*t*pow(1.-t, 2.) + p2*3.*t*t*(1.-t) + p3*t*t*t;\n}\n\nfloat easingBezier(vec2 r, vec2 p0, vec2 p1, float t)\n{\n    t = BezierDeg4(0., p0.x, p1.x, 1., t);\n    return BezierDeg4(r.x, p0.y, p1.y, r.y, t);\n}\n\nfloat easingInOutBack(float t)\n{\n    return easingBezier(vec2(0., 1.), vec2(0.265, -0.55), vec2(0.68, 1.55), t);\n}\n\nvec4 anim(vec2 uv, float t, vec4 c, float i)\n{\n    float ta = t + i *0.03 * mix(-1., 1., step(.5, t));\n    ta = mix(1.-easingInOutBack(ta*2.),\n            easingBezier(vec2(0., 1.), vec2(0.1, 0.75), vec2(0.67, 3.6), (ta-.5)*2.),\n            step(.5, ta));\n    vec2 s = vec2(ta * .25, .015);\n    float e = step(1.8, ta);\n    return sq(uv, vec2(s.x*.5, s.y*i*4.)/RATIO, s, mix(WHITE, c, e), .0)\n        + e * sp(uv, vec2(.315, s.y*i*2.3), .011, c);\n}\n\nvec4 drawsq(vec2 uv, float t, vec4 c)\n{\n    vec4 ec;\n    ec += anim(uv, t, c, 0.);\n    ec += anim(uv, t, c, 1.);\n    ec += anim(uv, t, c, 2.);\n    return ec;\n}\n\nvec4 animDrawSq(vec2 uv, float t)\n{\n    vec4 c;\n    vec2 uvfk;\n    float r = easingInOutBack(t)+.125;\n    \n    const vec2 off  = vec2(.0, .030);\n    const vec2 cent = vec2(.5, .55);\n    uvfk = rot(uv-cent + off, r *2.* M_PI) - off;\n    c += drawsq(uvfk, t, YELOW);\n    uvfk = rot(uv-cent + off, (r + 0.25) *2.* M_PI) - off;\n    c += drawsq(uvfk, t, CYAN);\n    uvfk = rot(uv-cent + off, (r + 0.50) *2.* M_PI) - off;\n    c += drawsq(uvfk, t, BLUE);\n    uvfk = rot(uv-cent + off, (r + 0.75) *2.* M_PI) - off;\n    c += drawsq(uvfk, t, RED);\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float t = mod(iTime, 2.)/2.;\n    \n    vec4 c;\n    \n    c += animDrawSq(uv, t);\n    \n    const float stp = 20.;\t\t// 20 step\n    const float dt = 5./60.; \t// 5 frames\n    float mm = 1.;\n    for (float it = 1.; it < stp; ++it)\n    {\n        float imp = it/stp;\n        imp = pow(1.-imp, 7.);\n    \tc += animDrawSq(uv, t-dt*(it/stp)) * imp;\n        mm += imp * imp;\n    }\n    c /= mm;\n    \n    // txt independant\n    c += loading(uv, vec2(.5, .1), .1);\n    \n    fragColor = c;\n}\n", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sGcDG.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[789, 789, 817, 817, 902], [904, 929, 974, 1002, 1057], [1060, 1085, 1123, 1151, 1200], [1202, 1210, 1263, 1295, 1715], [1717, 1729, 1780, 1790, 2086], [2088, 2100, 2143, 2153, 2466], [2468, 2468, 2508, 2508, 3003], [3005, 3005, 3072, 3154, 3239], [3241, 3241, 3296, 3296, 3389], [3391, 3391, 3423, 3423, 3505], [3507, 3507, 3553, 3553, 3955], [3957, 3957, 3996, 3996, 4116], [4118, 4118, 4153, 4153, 4670], [4672, 4672, 4727, 4777, 5295]], "test": "error"}
{"id": "4sGcR3", "name": "Palette lookup + animation", "author": "gbirbilis", "description": "fragColor=palette[int(f(x,y)*time*speed) % palette_size]\n\nthe palette can also have hardcoded colors (e.g. grab a palette from some color-specific website), should look much better with such", "tags": ["patterns", "palette", "animation"], "likes": 0, "viewed": 372, "published": "Public API", "date": "1522709743", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int PALETTE_SIZE = 100;\nfloat SPEED = 1.0; //on a slower computer try 5.0 //also try the .01 and .001 for other effect\n\nbool initialized;\nvec4[PALETTE_SIZE] palette;\n\nvoid init()\n{\n    for(int i=0; i<PALETTE_SIZE; i++)\n      palette[i]=vec4(float(i)*1.5/float(PALETTE_SIZE),\n                      float(i+i)*1.0/float(PALETTE_SIZE),\n                      float(i*i)*0.5/float(PALETTE_SIZE),\n                      1.0); //could set other colors here\n\n  initialized = true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 p)\n{     \n    if (!initialized)\n        init();\n    \n    fragColor = palette[int((p.x*p.y) * iTime*SPEED) % PALETTE_SIZE];\n    \n    //fragColor = vec4(mod((p.x*p.y) * iTime*SPEED, float(PALETTE_SIZE))/ float(PALETTE_SIZE)); //test without using a color lookup\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sGcR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 173, 186, 186, 479], [481, 481, 528, 528, 785]], "test": "ok"}
{"id": "4sGczK", "name": "Uh... what did I just do?", "author": "chao_mu", "description": "I was messing around with some concepts and accidentally created this. Figured I'd share.", "tags": ["mistake"], "likes": 2, "viewed": 73, "published": "Public", "date": "1522541945", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Produce a 1 if the provided value is <= 0, with a small transitional blur\n#define S(v) smoothstep(blur, 0., v)\n\n// Draw (return 1) a circle at the origin with the radius of r. \n#define circle(U, r) S(length(U) - r)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1) so that 0,0 is the center\n    vec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n    float blur = 4./iResolution.y;\n    \n    float mask = 0.;\n    \n    for (int i=0; i < 54; i++) {\n        vec2 st = vec2(cos(float(i) * iTime * uv.x), sin(float(i) * iTime * uv.y));\n        mask += circle(st, .2);\n    }\n\n    // Output to screen\n    fragColor = vec4(vec3(mask),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sGczK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[220, 220, 277, 354, 705]], "test": "ok"}
{"id": "4sGyzt", "name": "Scorched world", "author": "Pr0fed", "description": "Some practice on raymarching, and noise of course.\nTried to add lights, but it comes out very blurred and 90th style-like. \nThis looks better to me. ", "tags": ["3d", "raymarching", "voronoi"], "likes": 14, "viewed": 329, "published": "Public", "date": "1522959365", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Time simplification and easier overall speed control.\n#define time iTime * 0.5\n\nconst vec3 FogColor = vec3(1.6, 0.80, 0.00);\n\n// Rotation matrix, to add more variety to FBM.\nconst mat2 m = mat2( 1.4,  1.0, -1.0,  1.4 );\n\n// Check without any rotation.\n//const mat2 m = mat2( 1.0,  1.0, -1.0,  1.0 );\n\nvec2 hash( vec2 p ) \n{ \n    p = vec2( dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5,183.3))); \n    return fract(cos(p) * 12.5453); \n}\n\n\nfloat voronoi2D(in vec2 n)\n{\n    float dis = 2.0;\n    for (int y= -1; y <= 1; y++) \n    {\n        for (int x= -1; x <= 1; x++) \n        {\n            // Neighbor place in the grid\n            vec2 p = floor(n) + vec2(x,y);\n\n            float d = length(hash(p) + vec2(x, y) - fract(n));\n            \n            if (dis > d)\n            {\n             \tdis = d;\n            }\n        }\n    }\n    \n    return dis * dis;\n}\n\n// Four octave voronoi FBM.\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000 * voronoi2D( p ); p = p * 2. * m;\n    f += 0.2500 * voronoi2D( p ); p = p * 2. * m;\n    f += 0.1250 * voronoi2D( p ); p = p * 2. * m;\n    f += 0.0625 * voronoi2D( p );\n    return f;\n}\n\nfloat map(vec3 p) \n{\n    float pattern = voronoi2D(p.xz) * fbm4(p.xz) + p.y;\n     \n    // Return the height hit point.\n    return pattern;\n}\n\nfloat trace(vec3 ro, vec3 rd)\n{\n    float t = 0., d;\n\n    for (int i = 0; i < 96; i++)\n    { \n        d = map(ro + rd * t);\n        if (abs(d) < .001 * (t * .125 + 2.) || t > 20.) break;\n\n        t += d *.5;\n    }\n\t\n    // We either hit something, or exceeded the drawdist.\n    return min(t, 20.);\n}\n\n// Main color mixing function.\nvec3 GetColor(vec3 p, float t)\n{\n    float f = voronoi2D(p.xz) + fbm4(p.xz) + p.y * 0.5;\n    \n    f = mix( f, f * f * f * 3.5, f * abs(p.y));\n    \n    vec3 col = vec3(0.0);\n    \n    col = mix( vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 2.0), f * f);\n    \n    // Ridges color animation.\n    col = mix( col, vec3( 1.74, 0.95, 0.0), 2.5 * smoothstep(0.2, 1.8, 2.5 * fbm4(p.xz) + 0.3 * sin(time) * sin(time)));\n    \n\t// Gamma correction.\n    return col * col * 0.4545;\n}\n\n// Using the hit point, unit direction ray, etc, to color the scene. Diffuse, specular, shadows etc.\n// Personally i'm not yet very familiar with all the lighting techniques, so making the basics only.\nvec3 doColor(in vec3 ro, in vec3 rd, in vec3 lp, float t)\n{\n    // Initiate the scene (for this pass) to zero.\n    vec3 sceneCol = vec3(0.18, 0., 0.35) - rd.y;\n\n    if (t < 20.)\n    {\n        // Advancing the ray origin, \"ro,\" to the new hit point.\n        vec3 sp = ro + rd * t;    \n        sceneCol = GetColor(sp, t);\n    }\n\n    // Return the color. Done once for each pass.\n    return sceneCol;\n}\n\nvec3 applyFog(in vec3  rgb,    // original color of the pixel\n\t\t\t\tin float dist, // camera to point distance\n\t\t\t\tin vec3  ro,   // camera position\n\t\t\t\tin vec3  rd)   // camera to point vector\n{\n\tfloat fogAmount = 0.025 * exp(sin(ro.y) * 0.5) * (1.0 - exp(-dist * rd.y * 0.5)) / rd.y;\n    \n    // We leave some minumum, to always have some horizon 'fire'.\n\treturn mix(rgb, 0.75 * FogColor + FogColor * sin(time) * sin(time), fogAmount);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Aspect ratio - UV normalization.\n   \tvec2 uv = (2. * fragCoord - iResolution.xy ) / iResolution.y;\n    \n    // Camera setup and movement.\n\tvec3 ro = vec3(-5.9, 0.75, 1. + iTime * 0.5); \n\tvec3 lk = ro + vec3(0., -1.0, 2.);\n    \n    // FOV - Field of view.\n    float FOV = 3.14159 / 3.; \n    vec3 forward = normalize(lk - ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n    \n    // Main tracing func.\n    float t = trace(ro, rd);\n    \n    // Adding color.\n    vec3 sceneColor = doColor(ro, rd, lk, t);\n    \n    // Adding background fog.\n    sceneColor = applyFog(sceneColor, t - ro.y, ro, rd);\n\n    // Output to screen.\n    fragColor = vec4(sceneColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sGyzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 304, 326, 326, 437], [440, 440, 468, 468, 860], [862, 890, 912, 912, 1131], [1133, 1133, 1153, 1153, 1273], [1275, 1275, 1306, 1306, 1574], [1576, 1607, 1639, 1639, 2066], [2068, 2270, 2329, 2380, 2669], [2671, 2671, 2864, 2864, 3108], [3110, 3110, 3167, 3207, 3991]], "test": "ok"}
{"id": "4sKcW3", "name": "\"Off-white\" ver1", "author": "yasuo", "description": "endless road", "tags": ["demo"], "likes": 1, "viewed": 344, "published": "Public API", "date": "1523554996", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPEED 5.0\n\nvec3 lineTex(vec2 uv)\n{\n    return vec3(tan((uv.x+uv.y+(-iTime/10.0))*10.0)*10.0,tan((uv.x+uv.y+(-iTime/10.0))*10.0)*10.0,tan((uv.x+uv.y+(-iTime/10.0))*10.0)*10.0);\n}\n\nfloat noise(float x) {\n    return fract(sin(dot(vec2(x), vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// Tunnel pattern studied from shane & shau\n// i.e. https://www.shadertoy.com/view/4tKXzV\nvec2 path(float t) {\n    float a = sin(t*.2 + 1.5), b = sin(t*.2);\n    return vec2(a*2., a*b);\n}\n\nvec3 camera(vec3 ro, vec2 uv, vec3 ta) {\n    vec3 fwd = normalize(ta - ro);\n    vec3 left = cross(vec3(0, 1, 0), fwd);\n    vec3 up = cross(fwd, left);\n    return normalize(fwd + uv.x*left + up*uv.y);\n}\n\nfloat sdSphere (vec3 p, float r) {\n    return length(p)-r; \n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) return val1;\n    return val2;\n}\n\nvec4 map(vec3 p) {\n    vec3 lTex = lineTex(p.xy);\n    \n    p.xy -= path(p.z)*0.1;\n    float t = 100.0;\n    float w = 0.0;\n\n    float n = floor(p.z/0.5);\n\n    vec3 oldp = p;\n    p.z = mod(p.z, 1.0)-0.5;\n\n    w = sdBox(p-vec3(0.0,-1.2,0.0),vec3(0.03, 0.01, 0.3));\n    t = min(t, w);\n\n    w = 0.1 + dot(oldp, vec3(0, 0.0, 0.0));\n    t = min(t, w);\n\n\n    vec4 temp1 = vec4(0.0,0.0,0.0, t);\n \tvec4 temp2 = vec4(0.8,0.8,0.1, sdBox(p-vec3(0.0,-1.21,0.0),vec3(1.0, 0.01, 1.0)));\n    \n    p.y += noise(n)*1.0+sin(2.0)*0.1;\n    p.x += noise(n)*0.3-0.15;\n\t\n   \n    vec4 temp3 = vec4(lTex, sdBox(p+vec3(0.8,0.0,0.0),vec3(0.2, 1.0, 0.3)));\n    vec4 temp4 = vec4(lTex, sdBox(p+vec3(-0.8,0.0,0.0),vec3(0.2, 1.0, 0.3)));\n\n    vec4 res1 = combine(temp1,temp2);\n    vec4 res2 = combine(temp3,temp4);\n    vec4 res3 = combine(res1,res2);\n\n    return res3;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = ( fragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n    vec3  dir;\n\n    vec3 pos = vec3(0.0, 0.0, iTime*SPEED);\n\n    float dt = iTime * 6.;\n    vec3 ro = vec3(0, 0, -4. + dt);\n    vec3 ta = vec3(0, -2, dt);\n    vec3 rd;\n\n    ro.xy += path(ro.z);\n    ta.xy += path(ta.z);\n\n    dir = camera(ro, uv, ta);\n\n    float t = 0.0;\n    vec3 modelCl;\n    for(int i = 0 ; i < 50; i++) {\n        vec4 temp = map(t * dir + pos);\n        modelCl = temp.xyz;\n        if(temp.w < 0.01) break;\n        t += temp.w * 1.0;\n    }\n\n    vec3 ip = pos + dir * t;\n    vec4 cl = vec4(t * 0.01) * map(ip - 0.02) + t * 0.3;\n\n    fragColor = cl+vec4(modelCl,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sKcW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 42, 42, 185], [187, 187, 209, 209, 283], [285, 285, 316, 316, 407], [409, 499, 519, 519, 595], [597, 597, 637, 637, 798], [800, 800, 834, 834, 861], [863, 863, 899, 899, 958], [960, 960, 978, 978, 1797], [1800, 1800, 1857, 1857, 2503]], "test": "ok"}
{"id": "4stBzr", "name": "Light and Motion", "author": "dr2", "description": "Playing around with ideas from Kali's \"Generators\" shader resulted in this... ", "tags": ["fractal", "raymarch", "light"], "likes": 36, "viewed": 7904, "published": "Public API", "date": "1523964082", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Light and Motion\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Playing around with ideas from Kali's \"Generators\" shader resulted in this...  \n\n#define AA  0    // optional antialiasing\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ballPos, ltDir;\nfloat tCur, dstFar, frctAng;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p) \n{\n  float dMin, d, s, f;\n  dMin = dstFar;\n  d = 0.47 - abs (p.y - 3.5);\n  DMIN (1);\n  p.xz = abs (0.5 - mod ((2./3.) * p.xz, 1.));\n  s = 1.;\n  for (int j = 0; j < 9; j ++) {\n    p = abs (p) - vec3 (-0.02, 1.98, -0.02);\n    f = 2. / clamp (dot (p, p), 0.4, 1.);\n    p = f * p - vec3 (0.5, 1., 0.4);\n    s *= f;\n    p.xz = Rot2D (p.xz, frctAng);\n  }\n  d = PrRoundBoxDf (p, vec3 (0.1, 5., 0.1), 0.1) / s;\n  DMIN (2);\n  return dMin;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (float j = 1.; j < 5.; j ++) {\n    d = 0.002 * j * j;\n    ao += max (0., d - ObjDf (ro + rd * d));\n  }\n  return 0.2 + 0.8 * clamp (1. - 20. * ao, 0., 1.);\n}\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  float bRad, b, d;\n  bRad = 0.025;\n  b = dot (rd, ro);\n  d = b * b + bRad * bRad - dot (ro, ro);\n  if (d > 0.) {\n    d = - b - sqrt (d);\n    if (d < 0.) d = dstFar;\n  } else d = dstFar;\n  return d;\n}\n\nfloat TxPattern (vec3 p)\n{\n  float t, tt, c;\n  p = abs (0.5 - fract (4. * p));\n  c = 0.;\n  t = 0.;\n  for (float j = 0.; j < 6.; j ++) {\n    p = abs (p + 3.) - abs (p - 3.) - p;\n    p /= clamp (dot (p, p), 0., 1.);\n    p = 3. - 1.5 * p;\n    if (mod (j, 2.) == 0.) {\n      tt = t;\n      t = length (p);\n      c += exp (-1. / abs (t - tt));\n    }\n  }\n  return c;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, rg, col, bgCol, amb;\n  float dstBall, dstObj, dstGlow, d, eGap, bGlow, eGlow, eFlash, eMid, eVib, rnd;\n  int idObjT;\n  bool isRefl;\n  frctAng = 0.18172 + pi * (2. * SmoothBump (0.25, 0.75, 0.25, mod (0.01 * tCur, 1.)) - 1.);\n  dstBall = BallHit (ro - ballPos, rd);\n  isRefl = false;\n  if (dstBall < dstFar) {\n    isRefl = true;\n    ro += dstBall * rd;\n    rd = reflect (rd, normalize (ro - ballPos));\n  }\n  dstObj = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dstObj * rd);\n    dstObj += d;\n    if (d > 0.03) dstGlow = dstObj;\n    if (d < 0.001 || dstObj > dstFar) break;\n  }\n  bgCol = vec3 (0.9, 0.9, 1.) * (0.1 + 0.1 * max (0., dot (rd, normalize (vec3 (0.5, 0.2, 1.)))));\n  if (dstObj < dstFar) {\n    if (idObj == 2) {\n      rnd = Hashfv2 (11. + 77. * floor ((ro + dstObj * rd).xz / 1.5));\n      bGlow = 0.;\n      eGlow = 0.;\n      eGap = mod (0.0625 * (tCur + 7. * rnd), 1.);\n      eMid = 3.35;\n      eVib = eMid + 0.005 * rnd * sin ((64. + rnd) * tCur); \n      for (int j = 0; j < 30; j ++) {\n        rg = ro + dstGlow * rd;\n        d = ObjDf (rg);\n        dstGlow += d;\n        bGlow += max (0., 0.02 - d) * exp (- 0.5 * dstGlow);\n        eGlow += max (0., 0.03 - d) * (pow (max (0., 1. - 7. * abs (eVib - rg.y)), 8.) +\n           pow (max (0., 1. - 20. * min (abs (eMid - rg.y - eGap), abs (eMid - rg.y + eGap))), 4.));\n        if (d < 0.001 || dstGlow > dstFar) break;\n      }\n      eFlash = 0.6 + 0.4 * sin (8. * (tCur + 7. * rnd + rg.z));\n    }\n    ro += dstObj * rd;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    amb = vec3 (0.2);\n    if (idObjT == 1) {\n      col = vec3 (0.1) * (1. + TxPattern ((ro.y < 3.5) ? ro : 2. * ro));\n      if (ro.y < 3.2) col *= vec3 (0.9, 1., 0.9);\n      vn = VaryNf (128. * ro, vn, 0.2);\n    } else if (idObjT == 2) {\n      col = vec3 (0.7, 0.7, 0.6);\n      amb += 1.5 * eFlash * vec3 (1., 0.2, 0.1) * pow (max (0., 1. - 2.5 * abs (eMid - ro.y)), 2.) *\n         max (0.5, sign (eMid - ro.y) * vn.y);\n    }\n    col = ObjAO (ro, vn) * col * (amb + max (0., dot (ltDir, vn)) +\n       pow (max (dot (normalize (ltDir - rd), vn), 0.), 8.));\n    col = mix (col, bgCol, 1. - exp (- dstObj));\n    if (idObjT == 2) col += mix (vec3 (0., 0.3, 1.), vec3 (0., 1., 0.3), rnd) *\n       (bGlow + 20. * eGlow * eGlow * eFlash) * (1. - smoothstep (0.4, 1., dstObj / dstFar));\n  } else col = bgCol;\n  if (isRefl) col = mix (mix (0.9 * col, vec3 (0.7, 0.7, 0.8), 0.2), bgCol, 1. - exp (- dstBall));\n  return col;\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (0.75 * sin (t), 3.35 + 0.15 * sin (0.8 * t), 0.75 * cos (0.5 * t));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur + 30., 36000.) + floor (dateCur.w / 7200.);\n  az = 0.;\n  el = 0.02 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  }\n  t = 0.1 * tCur;\n  ballPos = TrackPath (t + 0.4);\n  ro = TrackPath (t);\n  vd = normalize (ballPos - ro);\n  az += 1.1 * (0.5 * pi + atan (- vd.z, vd.x));\n  el += 0.8 * asin (vd.y);\n  el = clamp (el, -0.25 * pi, 0.25 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  dstFar = 5.;\n  ltDir = normalize (vec3 (1., 1.5, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), 1.2));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (clamp (col, 0., 1.), vec3 (0.9)), 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4stBzr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[595, 595, 618, 618, 1047], [1049, 1049, 1070, 1070, 1270], [1272, 1272, 1304, 1304, 1493], [1495, 1495, 1529, 1529, 1730], [1732, 1732, 1758, 1758, 2093], [2095, 2095, 2130, 2130, 4591], [4593, 4593, 4619, 4619, 4704], [4706, 4706, 4762, 4762, 6072], [6074, 6074, 6120, 6120, 6167], [6169, 6169, 6226, 6226, 6309], [6311, 6311, 6341, 6341, 6454], [6488, 6488, 6512, 6512, 6572], [6574, 6574, 6598, 6598, 6728], [6730, 6730, 6755, 6755, 6941], [6943, 6943, 6972, 6972, 7184], [7186, 7186, 7225, 7225, 7405]], "test": "error"}
{"id": "4stfWr", "name": "Fractal Ring", "author": "dr2", "description": "Inside a changing fractal (mouseable)", "tags": ["fractal", "raymarch"], "likes": 11, "viewed": 443, "published": "Public API", "date": "1524729370", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Fractal Ring\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Inside a changing fractal (similar to \"Light and Motion\", mouseable)\n\n#define AA  0   // optional antialiasing\n\nvec3 HsvToRgb (vec3 c);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv3 (vec3 p);\n\nvec3 ltPos[2], ltAx;\nfloat tCur, dstFar, rRad, frctAng;\nconst float pi = 3.14159;\nconst float itMax = 18.;\n\nfloat ObjDf (vec3 p) \n{\n  vec4 p4;\n  float s, r;\n  p.xy = Rot2D (p.xy, 0.5 * pi);\n  r = length (p.yz);\n  p.yz = vec2 (2. * pi * rRad * ((r > 0.) ? atan (p.z, - p.y) / (2. * pi) : 0.), r - rRad);\n  p4 = vec4 (p, 1.);\n  for (float j = 0.; j < itMax; j ++) {\n    p4.xyz = abs (p4.xyz) - vec3 (-0.02, 1.98, -0.02);\n    p4 = (2. / clamp (dot (p4.xyz, p4.xyz), 0.4, 1.)) * p4 - vec4 (0.5, 1., 0.4, 0.);\n    p4.xz = Rot2D (p4.xz, frctAng);\n  }\n  return max ((length (p4.xyz) - 0.02) / p4.w, 0.01 - length (p.xz));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, h, s, sLo, sHi, eps;\n  eps = 0.0003;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 120; j ++) {\n    h = ObjDf (ro + s * rd);\n    if (h < eps || s > dstFar) {\n      sHi = s;\n      break;\n    }\n    sLo = s;\n    s += h;\n  }\n  if (h < eps) {\n    for (int j = 0; j < 4; j ++) {\n      s = 0.5 * (sLo + sHi);\n      h = step (eps, ObjDf (ro + s * rd));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 40; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += min (0.05, 3. * h);\n    if (sh < 0.05 || d > dMax) break;\n  }\n  return 0.2 + 0.8 * sh;\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (float j = 1.; j < 4.; j ++) {\n    d = 0.03 * j;\n    ao += max (0., d - ObjDf (ro + d * rd));\n  }\n  return clamp (1. - 5. * ao, 0., 1.);\n}\n\nvec4 ObjCol (vec3 p)\n{\n  float pp, ppMin, cn, s, r;\n  p.xy = Rot2D (p.xy, 0.5 * pi);\n  r = length (p.yz);\n  p.yz = vec2 (2. * pi * rRad * ((r > 0.) ? atan (p.z, - p.y) / (2. * pi) : 0.), r - rRad);\n  cn = 0.;\n  ppMin = 1.;\n  for (float j = 0.; j < itMax; j ++) {\n    p = abs (p) - vec3 (-0.02, 1.98, -0.02);\n    pp = clamp (dot (p, p), 0.4, 1.);\n    if (pp < ppMin) {\n      cn = j;\n      ppMin = pp;\n    }\n    p = (2. / pp) * p - vec3 (0.5, 1., 0.4);\n    p.xz = Rot2D (p.xz, frctAng);\n  }\n  return vec4 (HsvToRgb (vec3 (mod (0.6 + 1.7 * cn / itMax, 1.), 0.8, 1.)), 0.5);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{ \n  vec4 col4;\n  vec3 col, vn, ltDir, rds;\n  float dstObj, atten, ao, sh, dfSum, spSum;\n  frctAng = 0.5 * pi + 2. * pi * mod (0.005 * tCur, 1.);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    dfSum = 0.;\n    spSum = 0.;\n    for (int k = 0; k < 2; k ++) {\n      ltDir = ltPos[k] - ro;\n      atten = 1. / (1. + 0.3 * dot (ltDir, ltDir));\n      ltDir = normalize (ltDir);\n      atten *= smoothstep (0.3, 0.4, dot (ltAx, - ltDir));\n      dfSum += atten * max (dot (vn, ltDir), 0.);\n      spSum += atten * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.);\n    }\n    ltDir = normalize (0.5 * (ltPos[0] + ltPos[1]) - ro);\n    sh = ObjSShadow (ro, ltDir, max (dstObj - 0.2, 0.));\n    ao = ObjAO (ro, vn);\n    col4 = ObjCol (ro);\n    col = (0.1 + 0.4 * sh * dfSum) * col4.rgb + col4.a * sh * spSum * vec3 (1.);\n    col *= 0.2 + 0.8 * ObjAO (ro, vn);\n    col += vec3 (0.2) * max (dot (- rd, vn), 0.) *\n       (1. - smoothstep (0., 0.02, abs (dstObj - mod (0.1 * tCur, 2.))));\n  } else {\n    if (rd.y < 0.) {\n      rd.y = - rd.y;\n      rd.xz = vec2 (- rd.z, rd.x);\n    }\n    rds = floor (2000. * rd);\n    rds = 0.00015 * rds + 0.1 * Noisefv3 (0.0005 * rds.yzx);\n    for (int j = 0; j < 19; j ++) rds = abs (rds) / dot (rds, rds) - 0.9;\n    col = vec3 (0.02, 0.02, 0.05) + 0.8 * vec3 (1., 1., 0.7) * min (1., 0.5e-3 *\n       pow (min (6., length (rds)), 5.));\n  }\n  return clamp (pow (col, vec3 (0.8)), 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, vd, ori, ca, sa;\n  vec2 canvas, uv;\n  float el, az, a;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  }\n  rRad = 9.9 / (2. * pi);\n  a = 0.01 * 2. * pi * tCur;\n  ro = rRad * vec3 (cos (a), 0., sin (a));\n  ori = vec3 (el, az - a, 0.2 * pi * sin (3. * a));\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.);\n  ltPos[0] = ro + vuMat * vec3 (-0.3, 0.3, -0.2);\n  ltPos[1] = ro + vuMat * vec3 (0.3, 0.3, -0.2);\n  ltAx = vuMat * vec3 (0., 0., 1.);\n  dstFar = 10.;\n  #if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), 3.));\n    rd = vuMat * rd;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4stfWr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[423, 423, 446, 446, 931], [933, 933, 966, 966, 1446], [1448, 1448, 1469, 1469, 1669], [1671, 1671, 1720, 1720, 1971], [1973, 1973, 2005, 2005, 2176], [2178, 2178, 2200, 2200, 2750], [2752, 2752, 2787, 2787, 4244], [4246, 4246, 4302, 4302, 5573], [5575, 5575, 5599, 5599, 5735], [5737, 5737, 5767, 5767, 5880], [5914, 5914, 5938, 5938, 6158], [6160, 6160, 6185, 6185, 6410]], "test": "error"}
{"id": "4sVczV", "name": "h e e e l i x", "author": "tdhooper", "description": "My entry for the Revision 2018 Animated GIF Compo (1st place \\o/), with an extra bit of post process that blew the file size limit.\n\nUncomment ANOTHER_LEVEL to go deeper", "tags": ["fractal", "spiral", "antialias", "loop", "helix", "outline", "revision", "carpaint"], "likes": 239, "viewed": 8662, "published": "Public API", "date": "1522669971", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//#define ANOTHER_LEVEL\n\n\nfloat guiLead = 0.6;\nfloat guiInnerRatio = 0.4407892623709694;\nfloat guiFocal = 3.;\nfloat guiRotateModel = 0.4560833039600971;\nfloat guiDebug = 0.6749066960348409;\nfloat guiZipOffset = 30.;\nfloat guiZipSize = 60.;\nfloat guiZipSpeed = 3.3;\nfloat guiZoom = 0.1;\nfloat guiModelScale = 7.749066960348409;\n\nmat4 cameraMatrix = mat4(\n    -0.7063226699829102,\n    0.7052236199378967,\n    0.06198469549417496,\n    0,\n    -0.30620118975639343,\n    -0.3832840919494629,\n    0.8714323043823242,\n    0,\n    0.6382971405982971,\n    0.5965006947517395,\n    0.48660656809806824,\n    0,\n    0.14653973281383514,\n    0.6211488246917725,\n    0.13233166933059692,\n    1\n);\n\nvec3 camPosition = vec3(0.14653973281383514, 0.6211488246917725, 0.13233166933059692);\n\nfloat time;\n\n#define PI 3.14159265359\n#define HALF_PI 1.5707963267948966\n#define TAU 6.28318530718\n#define PHI 1.618033988749895\n\n\n// --------------------------------------------------------\n// Utils\n// --------------------------------------------------------\n\n#define saturate(x) clamp(x, 0., 1.)\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );\n}\n\nfloat range(float vmin, float vmax, float value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\nfloat rangec(float a, float b, float t) {\n    return clamp(range(a, b, t), 0., 1.);\n}\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\nvec3 cartToPolar(vec3 p) {\n    float x = p.x; // distance from the plane it lies on\n    float a = atan(p.y, p.z); // angle around center\n    float r = length(p.zy); // distance from center\n    return vec3(x, a, r);\n}\n\nvec3 polarToCart(vec3 p) {\n    return vec3(\n        p.x,\n        sin(p.y) * p.z,\n        cos(p.y) * p.z\n    );\n}\n\n\n// --------------------------------------------------------\n// Helix\n// https://www.shadertoy.com/view/MstcWs\n// --------------------------------------------------------\n\nvec2 closestPointOnRepeatedLine(vec2 line, vec2 point){\n\n    // Angle of the line\n    float a = atan(line.x, line.y);\n\n    // Rotate space so we can easily repeat along\n    // one dimension\n    pR(point, -a);\n\n    // Repeat to create parallel lines at the corners\n    // of the vec2(lead, radius) polar bounding area\n    float repeatSize = sin(a) * line.y;\n    float cell = pMod1(point.x, repeatSize);\n\n    // Rotate space back to where it was\n    pR(point, a);\n\n    // Closest point on a line\n    line = normalize(line);\n    float d = dot(point, line);\n    vec2 closest = line * d;\n\n    // Part 2 of the repeat, move the line along it's\n    // tangent by the repeat cell\n    vec2 tangent = vec2(line.y, -line.x);\n    closest += cell * repeatSize * tangent;\n\n    return closest;\n}\n\n// Closest point on a helix\nvec3 closestHelix(vec3 p, float lead, float radius) {\n\n    p = cartToPolar(p);\n    p.y *= radius;\n\n    vec2 line = vec2(lead, radius * PI * 2.);\n    vec2 closest = closestPointOnRepeatedLine(line, p.xy);\n\n    closest.y /= radius;\n    vec3 closestCart = polarToCart(vec3(closest, radius));\n\n    return closestCart;\n}\n\n// Cartesian to helix coordinates\nvoid pModHelix(inout vec3 p, float lead, float radius) {\n    vec3 closest = closestHelix(p, lead, radius);\n    float helixAngle = atan((2. * PI * radius) / lead);\n    vec3 normal = normalize(closest - vec3(closest.x,0,0));\n    vec3 tangent = vec3(1,0,0) * rotationMatrix(normal, helixAngle);\n    float x = (closest.x / lead) * radius * PI * 2.;\n    float y = dot(p - closest, cross(tangent, normal));\n    float z = dot(p - closest, normal);\n    p = vec3(x, y, z);\n}\n\nfloat pModHelixScale(inout vec3 p, float lead, float innerRatio) {\n    float radius = mix(.25, .5, innerRatio);\n    pModHelix(p, lead, radius);\n    float scale = mix(.5, 0., innerRatio);\n    p /= scale;\n    return 1. / scale;\n}\n\nfloat pModHelixUnwrap(inout vec3 p, float lead, float innerRatio, float t) {\n    float radius = mix(.25, .5, innerRatio);\n    float width = cos(asin(t));\n    float adjust = (1. / width);\n    float offset = ((.5 * adjust) - .5) * 7.;\n\n    vec3 pp = p;\n    pp.z -= radius;\n    pR(pp.xy, PI * -.5);\n    pp.x *= -1.;\n\n    p.z += offset;\n    radius += offset;\n    pModHelix(p, lead, radius);\n\n    p = mix(p, pp, rangec(.8, 1., t));\n\n    float scale = mix(.5, 0., innerRatio);\n    p /= scale;\n    return 1. / scale;\n}\n\n\n// --------------------------------------------------------\n// Modelling\n// --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    vec3 albedo;\n    int id;\n};\n\nfloat anim(float t, float index) {\n    float overlap = .5;\n    float steps = 2.;\n    float all = mix(steps, 1., overlap);\n    float width = 1. / (all - 1.);\n    float each = width * (1.- overlap);\n    float start = index * each - width * .5;\n    float end = start + width;\n    return range(start, end, t);\n}\n\nfloat unzip(vec3 p, float t) {\n    float size = guiZipSize;\n    float speed = guiZipSpeed;\n\n    t *= size * speed;\n\n    if (sign(p.y) != sign(p.x)) {\n        float radius = mix(.25, .5, guiInnerRatio);\n        float scale = mix(.5, 0., guiInnerRatio);\n        float factor = radius / scale * PI * 2.;\n        t -= (factor - .5);\n    }\n\n    return range(size, 0., abs(p.x) + size - t);\n}\n\nvoid addPipe(inout float d, vec3 p, float scale, float tt) {\n\n    float t = clamp(tt, 0., 1.);\n\n    float boundry = 1.;\n    float part;\n    float separate = (\n        rangec(0., boundry * .01, t) * .3 +\n        rangec(boundry * .01, boundry, t) * .7\n    );\n\n    float round = rangec(.0, 1., t);\n\n    part = fBox2(p.yz, vec2(mix(guiLead * 2., .5, separate), .5));\n    part = mix(part, length(p.yz) - .5, round);\n    part /= scale;\n\n    d = mix(d, part, smoothstep(.0, .01, t));\n}\n\nvoid unzipHelixModel(inout float d, inout float scale, inout vec3 p, float lead, float innerRatio, float step, float invert) {\n    float offset = guiZipOffset / lead;\n    scale *= pModHelixScale(p, lead, innerRatio);\n    p.x *= -1.;\n    float t1 = unzip(p + vec3(offset,0,0) * invert, anim(time, step));\n    addPipe(d, p, scale, t1);\n}\n\nModel map(vec3 p) {\n\n    float part, d, t1, t2, t3, t4;\n    float lead = guiLead;\n    float innerRatio = guiInnerRatio;\n    vec2 uv1, uv2, uv3;\n\n    p /= guiModelScale;\n\n    vec3 pp = p;\n\n    d = 1e12;\n\n    float s = mix(.5, 0., innerRatio);\n\n    float scale = 1./pow(1./s, time);\n\n    pR(p.xy, PI * -.5 * time + guiRotateModel * PI * 2.);\n    \n    p *= scale;\n    p.z += .5;\n\n    scale *= pModHelixUnwrap(p, lead, innerRatio, time);\n    p.x *= -1.;\n    scale *= pModHelixScale(p, lead, innerRatio);\n    p.x *= -1.;\n\n    #ifdef ANOTHER_LEVEL\n        scale *= pModHelixScale(p, lead, innerRatio);\n        p.x *= -1.;\n    #endif\n\n    d = min(d, length(p.yz) - .5);\n    d /= scale;\n\n    unzipHelixModel(d, scale, p, lead, innerRatio, -1., 1.);\n    unzipHelixModel(d, scale, p, lead, innerRatio, 0., -1.);\n    unzipHelixModel(d, scale, p, lead, innerRatio, 1., 1.);\n\n    d *= guiModelScale;\n\n    return Model(d, vec3(0), 1);\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nconst float OUTLINE = .003; // Outline thickness\nconst float OUTLINE_BOUNDRY = .5; // Where to feather the inside/outside\nconst float MAX_TRACE_DISTANCE = 1.5; // max trace distance\nconst float INTERSECTION_PRECISION = .001; // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float FUDGE_FACTOR = 1.; // Default is 1, reduce to fix overshoots\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\n// Faster runtime\nvec3 calcNormal(vec3 pos){\n    vec3 eps = vec3(.001,0,0);\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n\n// Faster compilation\nconst int NORMAL_STEPS = 6;\nvec3 _calcNormal(vec3 pos){\n    vec3 eps = vec3(.001,0,0);\n    vec3 nor = vec3(0);\n    float invert = 1.;\n    for (int i = 0; i < NORMAL_STEPS; i++){\n        nor += map(pos + eps * invert).dist * eps * invert;\n        eps = eps.zxy;\n        invert *= -1.;\n    }\n    return normalize(nor);\n}\n\n// https://www.shadertoy.com/view/lsKcDD\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    float ph = 1e10;\n    \n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t ).dist;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).dist;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n// Adapted from https://www.shadertoy.com/view/Xds3zN\nvec3 doLighting(vec3 pos, vec3 nor, vec3 rd) {\n\n    vec3 col;\n    vec3 up = normalize(vec3(1));\n\n    // lighitng        \n    float occ = mix(calcAO( pos, nor ), 1., .8);\n    vec3  lig = normalize(vec3(0,.2,1));\n    float amb = clamp(dot(nor, up) * .5 + .5, 0., 1.);\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    vec3  hal = normalize( lig-rd );\n    float spe = pow(clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n\n    vec3 cA = vec3(.7,.3,.9);\n    vec3 cB = vec3(.4,.9,.8);\n    vec3 cC = vec3(.7,0,.7);\n\n    col = mix(cA, cB, rangec(.0, 1., dot(-rd, nor))); // need better ramp\n    col = mix(col, vec3(.8,.5,1), rangec(.5, 1., dif) * .5);\n    col += cC * rangec(.5, 1., dif) * .1;\n\n    dif *= softshadow( pos, lig, 0.02, 2.5 ) * .9;\n\n    vec3 lin = vec3(0);\n    lin += .5 * dif;\n    lin += .1 * spe * dif;\n    lin += .2 * fre * occ;\n    lin += .5 * amb * occ;\n    lin += .4 * occ;\n    col = col*lin;\n\n    return col;\n}\n\nvec3 background;\n\nvoid applyFog(inout vec3 color, vec3 pos) {\n    float fog = length(camPosition - pos);\n    fog = smoothstep(float(MAX_TRACE_DISTANCE) * .36, float(MAX_TRACE_DISTANCE), fog);\n    color = mix(color, background, fog);\n}\n\nvec3 shadeSurface(vec3 pos, Ray ray) {\n\n    if (ray.len > MAX_TRACE_DISTANCE) {\n        return background;\n    }\n\n    vec3 normal = calcNormal(pos);\n\n    vec3 color = doLighting(\n        pos,\n        normal,\n        ray.direction\n    );\n\n    applyFog(color, pos);\n    \n    return color;\n}\n\nvec4 shadeOutline(vec3 pos, float t) {\n    float alpha = smoothstep(0., OUTLINE_BOUNDRY, t);\n    alpha -= smoothstep(OUTLINE_BOUNDRY, 1., t);\n    alpha *= .5;\n\tvec3 color = vec3(0);\n    applyFog(color, pos);\n    return vec4(color, alpha);\n}\n\n\n// --------------------------------------------------------\n// Ray Marching\n// --------------------------------------------------------\n\nvec3 raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    float lastDist = currentDist;\n    vec3 pos, lastPos = vec3(0);    \n    vec4 outline = vec4(0);\n    \n    Model model;\n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for (int i = 0; i < NUM_OF_TRACE_STEPS; i++) {\n\n        lastPos = pos;\n        pos = ray.origin + ray.direction * ray.len;\n\n        if (ray.len > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        if (currentDist < INTERSECTION_PRECISION) {\n            break;\n        }\n\n        if (currentDist > lastDist && currentDist < OUTLINE) {\n\n            float t = lastDist / OUTLINE;\n            \n            vec4 newOutline = shadeOutline(pos, t);\n            float contribution = 1. - outline.a;\n            outline.rgb = mix(outline.rgb, newOutline.rgb, contribution);\n            outline.a += newOutline.a * contribution;\n\n            if (t < OUTLINE_BOUNDRY) {\n                pos = lastPos;\n                break;\n\t\t\t}\n        }\n\n        model = map(pos);\n        lastDist = currentDist;\n        currentDist = model.dist;\n        ray.len += currentDist * FUDGE_FACTOR;\n    }\n\t\n    vec3 color = mix(\n        shadeSurface(pos, ray),\n       \toutline.rgb,\n        outline.a\n\t);\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    vec3 bgA = vec3(.6,.5,.8) * .55;\n    vec3 bgB = vec3(.7,.9,1.) * .5;\n    background = mix(bgA, bgB, dot(p, normalize(vec2(.2,-.6))) * .5);\n    //background = mix(vec3(.4,.3,.5) * .9, vec3(.6), -.2);\n\n    time = iTime;\n    time *= .6;\n    time += .53;\n    time = mod(time, 1.);\n    \n    float camDist = length(camPosition);\n\n    mat4 camMat = cameraMatrix;\n    float focalLength = guiFocal;\n    vec3 rd = normalize(\n        (vec4(p, -focalLength, 1) * camMat).xyz\n    );\n    \n    vec3 color = raymarch(CastRay(camPosition, rd));\t\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float vig = pow(\n        16. * uv.x * uv.y * (1. - uv.x) * (1. - uv.y),\n        0.075\n    );\n    color *= vec3(.9, .95, 1.) * vig * 1.1;\n\n    color = mix(color, vec3(pow(length(color * .6), 2.)), .1);\n    color *= 1.05;\n    color = pow(color, vec3(1.2,1.3,1.2));\n\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sVczV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1069, 1307, 1339, 1339, 1384], [1386, 1455, 1500, 1500, 1970], [1972, 1972, 2022, 2022, 2065], [2067, 2067, 2108, 2108, 2152], [2154, 2154, 2174, 2174, 2202], [2204, 2204, 2233, 2233, 2320], [2322, 2466, 2506, 2506, 2639], [2641, 2641, 2667, 2667, 2857], [2859, 2859, 2885, 2885, 2971], [3145, 3145, 3200, 3226, 3925], [3927, 3955, 4008, 4008, 4270], [4272, 4306, 4362, 4362, 4771], [4773, 4773, 4839, 4839, 5000], [5002, 5002, 5078, 5078, 5513], [5714, 5714, 5748, 5748, 6021], [6023, 6023, 6053, 6053, 6409], [6411, 6411, 6471, 6471, 6889], [6891, 6891, 7017, 7017, 7226], [7228, 7228, 7247, 7247, 8150], [8782, 8800, 8826, 8826, 9074], [9126, 9126, 9153, 9153, 9416], [9418, 9459, 9533, 9533, 9823], [9825, 9866, 9908, 9908, 10213], [10216, 10270, 10316, 10316, 11252], [11272, 11272, 11315, 11315, 11488], [11490, 11490, 11528, 11528, 11778], [11780, 11780, 11818, 11818, 12020], [12160, 12160, 12191, 12191, 13437], [13439, 13439, 13494, 13494, 14441]], "test": "error"}
{"id": "4sVyDt", "name": "Menger Helix", "author": "dr2", "description": "Twisted fractal helix (mouseable, Moebius ring and antialiasing options)", "tags": ["fractal", "moebius"], "likes": 18, "viewed": 3782, "published": "Public API", "date": "1523781015", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Menger Helix\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Twisted fractal helix (mouseable, Moebius ring and antialiasing options)\n\n#define MOB 0   // optional Moebius ring\n#define AA  1   // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir;\nfloat tCur, dstFar;\nconst float pi = 3.14159;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 b;\n  float r, a;\n  const float nIt = 5., sclFac = 2.4;\n  b = (sclFac - 1.) * vec3 (1., 1.125, 0.625);\n  p.xz = Rot2D (p.xz, 0.05 * tCur);\n  r = length (p.xz);\n  a = (r > 0.) ? atan (p.z, - p.x) / (2. * pi) : 0.;\n#if ! MOB\n  p.y = mod (p.y - 4. * a + 2., 4.) - 2.;\n#endif\n  p.x = mod (16. * a + 1., 2.) - 1.;\n  p.z = r - 32. / (2. * pi);\n#if ! MOB\n  p.yz = Rot2D (p.yz, 2. * pi * a);\n#else\n  p.yz = Rot2D (p.yz, pi * a);\n#endif\n  for (float n = 0.; n < nIt; n ++) {\n    p = abs (p);\n    p.xy = (p.x > p.y) ? p.xy : p.yx;\n    p.xz = (p.x > p.z) ? p.xz : p.zx;\n    p.yz = (p.y > p.z) ? p.yz : p.zy;\n    p = sclFac * p - b;\n    p.z += b.z * step (p.z, -0.5 * b.z);\n  }\n  return 0.8 * PrBoxDf (p, vec3 (1.)) / pow (sclFac, nIt);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += min (0.2, 3. * h);\n    if (sh < 0.001) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 3.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0.25, 0.5, 1.), vec3 (0., 0.4, 0.3), 0.5 * (1. - rd.y)) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + 0.25 * gd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, sh;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    sh = ObjSShadow (ro, ltDir);\n    col = mix (vec3 (0.2, 0.4, 0.8), BgCol (reflect (rd, vn)), 0.8);\n    col = sh * col * (0.4 + 0.2 * max (vn.y, 0.) + 0.5 * max (dot (vn, ltDir), 0.)) +\n       0.1 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else col = BgCol (rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    el = -0.25 * pi * sin (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, 0.4 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -30.);\n  zmFac = 6. + 2. * sin  (0.07 * pi * tCur);;\n  ltDir = normalize (vec3 (1., 1., -1.));\n  dstFar = 100.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sVyDt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[402, 402, 424, 424, 1157], [1159, 1159, 1192, 1192, 1369], [1371, 1371, 1392, 1392, 1592], [1594, 1594, 1631, 1631, 1869], [1871, 1871, 1893, 1893, 2314], [2316, 2316, 2351, 2351, 2799], [2801, 2801, 2857, 2857, 4006], [4008, 4008, 4040, 4040, 4140], [4142, 4142, 4172, 4172, 4285]], "test": "ok"}
{"id": "4sVyWt", "name": "purebreed", "author": "MonterMan", "description": "a simulation of 2d life. ", "tags": ["2d"], "likes": 7, "viewed": 156, "published": "Public", "date": "1523751488", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float uTime = mod(iTime, 230.0);\n    float t = uTime;\n    \n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n \t\n    float offset;\n    float freq;\n    if (t < 9.6)\n    {\n        offset = 0.0;\n    \tfreq = 0.7;\n    }\n    else if (t < 23.0)\n    {\n        offset = 1.7;\n        freq = 1.2;\n    }\n    else if (t < 35.5)\n    {\n        offset = -0.1;\n        freq = 1.9;\n    }\n    else\n    {\n        offset = 0.0;\n        freq = 3.88;\n    }\n    \n    float osci = pow(sin(offset + freq*t), 2.0);\n    float period = (1.0 / freq) * 3.1415926; \n    float soul_count = min(150.0, 1.0 + floor(t / period));\n    \n    float col = 0.0;\n    for (float i = 1.0; i < 150.0; i += 1.0)\n    {\n        if (soul_count < i)\n        {\n\t\t\tcontinue;\n        }\n        \n        vec2 p = osci * vec2(sin(i*0.23 + 1.7*t) + cos(i*1.32 + 1.6*t), sin(i*2.1 + 0.21*t) + cos(i*1.5 + 1.5*t));\n        \n        float d = length(p - uv);\n        col += 0.0003 / (max(pow(osci, 0.2), 0.01) * pow(d, 1.6));\n    }\n    \n    vec3 background = vec3(0.2, 0.0, 0.0);\n    vec3 free_col = vec3(0.8, 0.5, 0.2);\n    vec3 breed_col = vec3(0.2, 0.8, 0.5);\n    fragColor = vec4(mix(background, mix(breed_col, free_col, pow(osci, 0.2)), col), 1.0);\n}\n", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sVyWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 1269]], "test": "ok"}
{"id": "4sycDK", "name": "ZoneAlarm", "author": "dila", "description": "I wanted to write something tonight but had to finish up quick. Could use some more lighting. Sorry about the stale metal texture and lack of bump mapping.", "tags": ["raymarched"], "likes": 51, "viewed": 4501, "published": "Public", "date": "1523312419", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nconst float mk = 8.0;\nvec3 tuv = vec3(0.0);\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat map(vec3 p) {\n    vec2 bt = vec2(mk, 0.0);\n    vec2 dk = floor(mod(p.xz / mk * 2.0, 2.0)) * 2.0 - 1.0;\n    \n    float t = fract(iTime * 0.5) * 2.0;\n    float dt0 = smoothstep(0.0, 1.0, clamp(t, 0.0, 1.0));\n    float dt1 = smoothstep(0.0, 1.0, clamp(t - 1.0, 0.0, 1.0));\n    \n    float d = 1000.0;\n    for (int i = 0; i < 4; ++i) {\n        float fi = float(i);\n        float xo = mod(fi, 2.0) * 2.0 - 1.0;\n        float yo = floor(fi / 2.0) * 2.0 - 1.0;\n\n        vec2 po = vec2(xo, yo) * rot(3.141592 * 0.25) * sqrt(0.5);\n\n        vec3 r = p + vec3(po.x, 0.0, po.y) * mk * 0.5;\n        \n        r.x += dk.y * dt0 * mk * 0.5;\n        r.z += dk.x * dt1 * mk * 0.5;\n\n        vec2 fp = (fract(r.xz / mk) - 0.5) * mk;\n        vec3 q = vec3(fp.x, abs(p.y) - 4.0, fp.y);\n        \n        tuv = q;\n\n        float bss = 0.23;\n        vec3 bs = vec3(mk * bss, 0.25, mk * bss);\n    \tfloat ba = udRoundBox(q - bt.xyx * 0.25, bs, 0.125);\n    \tfloat bb = udRoundBox(q + bt.xyx * 0.25, bs, 0.125);\n        \n        vec3 cbs = vec3(0.4, 100.0, 0.4);\n        vec3 sf = vec3(-1.0, 0.0, 1.0) * 0.25;\n        vec3 dp = vec3(q.x, p.y, q.z);\n        \n        vec3 ca = dp + bt.xyx * sf;\n        float da = udRoundBox(ca, cbs, 0.25);\n\n        vec3 cb = dp - bt.xyx * sf;\n        float db = udRoundBox(cb, cbs, 0.25);\n        \n        float gb = min(ba, bb);\n        float pb = min(da, db);\n        \n    \td = min(d, min(gb, pb));\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        t += map(o + r * t);\n    }\n    return t;\n}\n\nvec3 tex(vec3 p) {\n    vec3 ta = texture(iChannel0, p.yz).xyz;\n    vec3 tb = texture(iChannel0, p.xz).xyz;\n    vec3 tc = texture(iChannel0, p.xy).xyz;\n    return (ta * ta + tb * tb + tc * tc) / 3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv, uv) * 0.12));\n    vec3 o = vec3(mk * 0.5, 0.0, 0.0);\n    \n    r.xy *= rot(3.141592 * -0.125);\n    r.xz *= rot(iTime * 0.5);\n\n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 tc = tuv;\n    vec3 sn = normal(w);\n    float aoc = map(w + sn * 1.3);\n    \n    vec3 lp = vec3(mk, 1.5, mk);\n    \n    vec3 lv = w - lp;\n    float ld = length(lv);\n    lv /= ld;\n    float lk = max(dot(lv, -sn), 0.0);\n    lk /= 1.0 + ld * 0.01;\n    \n    float lt = trace(w + sn * 0.1, -lv);\n    float s = max(sign(lt - ld), 0.0);\n    \n    float f = 1.0 / (1.0 + t * t * 0.01);\n    vec3 ref = reflect(lv, sn);\n    float sp = pow(abs(dot(ref, r)), 12.0) * f * lk;\n    \n    float fs = mix(0.2, 1.0, s) * lk;\n    vec3 spc = sp * vec3(0.0, 1.0, 1.0);\n    vec3 fc = tex(tc * 0.25) * fs * f * aoc + spc;\n\n    fragColor = vec4(sqrt(fc), 1.0);\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sycDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 71], [118, 118, 163, 163, 203], [205, 205, 224, 224, 1642], [1644, 1644, 1665, 1665, 1866], [1868, 1868, 1897, 1897, 2002], [2004, 2004, 2022, 2022, 2204], [2206, 2206, 2263, 2263, 3242]], "test": "error"}
{"id": "4sycWy", "name": "Learning, in progress....", "author": "FlashyTheCreeper", "description": "trying to learn how to make shader\nand just to let ya know that i had to delete two of my shaders cuz it sucked", "tags": ["sinus"], "likes": 2, "viewed": 145, "published": "Public", "date": "1523065450", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nSome codes taken from:\nhttps://www.shadertoy.com/view/Xsl3WH\n*/\n#define pie 3.1415926\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    uv.x = atan(uv.x, uv.y) / pie;\n    uv.y = 1. / length(uv) * .2;\n    \n    vec3 col = vec3(.0);\n    col.r = abs(50. / (150. * uv.x + sin(uv.y * 10. + iTime) * 90.));\n    col.g = abs(50. / (150. * uv.y + sin(uv.x * 10.1 + iTime) * 90.));\n    col.b = abs(50. / (150. * uv.y + sin(uv.y * 10.2 + iTime) * 90.));\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sycWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 147, 147, 610]], "test": "ok"}
{"id": "4syyzc", "name": "Side pulse", "author": "eliemichel", "description": "25 min live coding at Shader Showdown #6 in Paris", "tags": ["abstract"], "likes": 2, "viewed": 73, "published": "Public", "date": "1522738692", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat sdSphere (vec3 p, float r) { return length(p) - r; }\n\nfloat map (vec3 pos) {\n  float scene = 1000.;\n  //pos = mod(pos, vec3(10.0)) - vec3(5);\n  pos.x *= 1. / (1. + pos.y);\n  scene = min(scene, sdSphere(pos, 1. + pos.x * (2.0 + 0.5 * sin(iTime * 1.5))));\n  return scene;\n}\n\nvec3 lookAt (vec3 eye, vec3 at, vec2 uv) {\n  vec3 forward = normalize(at - eye);\n  vec3 right = normalize(cross(forward, vec3(0,1,0)));\n  vec3 up = normalize(cross(right, forward));\n  return normalize(forward + right * uv.x + up * uv.y);\n}\n\nfloat grain(vec2 uv) {\n  return fract(sin(dot(uv, vec2(31.492, 271.0))));\n}\n\nvec3 mainmain(vec2 uv) {\n  vec3 eye = vec3(0,1,-3);\n  vec3 ray = lookAt(eye, vec3(0), uv);\n  vec3 pos = eye;\n  float shade = 0.;\n  for (float i = 0.; i <= 1.; i += 1./30.) {\n    float dist = map(pos);\n    if (dist < .001) {\n      shade = 1.-i;\n      break;\n    }\n    pos += dist * ray;\n  }\n  vec3 color = vec3(1., 0.5, 0.);\n  color.r += 0.2 * sin(1.0*iTime);\n  color += 0.5*dot(vec3(0.5, exp(pow(sin(iTime), 2.)), 0.5), pos);\n    \n  color.z += 0.6*grain(uv + grain(uv) * vec2(1.0, 2.0+sin(100.*iTime)));\n    \n  float s = sin(iTime);\n  float c = cos(iTime);\n  vec3 c2 = color;\n  c2.r = s * color.g + c * color.r;\n  c2.g = -s * color.r + c * color.g;\n  color += (0.2) * c2;\n  color *= shade;\n  return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n  vec3 c = vec3(0);\n    \n  float x = sin(2.*iTime);\n  float y = sin(2.315*iTime);\n  float r = pow(10., -2.-2.*(1.-pow(x*x, 5.) - pow(y*y, 5.)));\n    \n  c += mainmain(uv+vec2(r, r));\n  c += mainmain(uv+vec2(r, -r));\n  c += mainmain(uv+vec2(-r, r));\n  c += mainmain(uv+vec2(-r, -r));\n  c /= 4.;\n  fragColor = vec4(c, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4syyzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 35, 35, 59], [61, 61, 83, 83, 278], [280, 280, 322, 322, 519], [521, 521, 543, 543, 596], [598, 598, 622, 622, 1305], [1307, 1307, 1364, 1364, 1745]], "test": "ok"}
{"id": "4syyzK", "name": "Shader Showdown Round 1", "author": "Flopine", "description": "My shader during live coding shader showdown event at Revision 2018, for the preselection. \n\nHope you'll enjoy it! :)", "tags": ["raymarching", "revision2018"], "likes": 12, "viewed": 278, "published": "Public", "date": "1522538781", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, lsdlive, XT95 and lamogui for teaching me and their help\n\n\n#define ITER 60.\n\nmat2 rot (float a)\n{float c = cos(a);float s = sin(a); return mat2(c,s,-s,c);}\n\nvec2 moda(vec2 p, float per)\n{\nfloat a = atan(p.y,p.x);\nfloat l = length(p);\na = mod(a-per/2.,per)-per/2.;\nreturn vec2 (cos(a),sin(a))*l;\n}\n\nfloat stmin (float a, float b, float k, float n)\n{\nfloat st = k/n;\nfloat u = b-k;\nreturn min(min(a,b),0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\nreturn a+b*cos(2.*3.141592*(c*t+d));\n}\n\nfloat cyl (vec2 p, float r)\n{\nreturn length(p)-r;\n}\n\n\nfloat sphe (vec3 p, float r)\n{\nreturn length(p)-r;\n}\n\n\nfloat od (vec3 p, float d)\n{\nreturn dot(p,normalize(sign(p)))-d;\n}\n\n\nfloat prim1 (vec3 p)\n{\np.xz *= rot(p.y+iTime);\np.xz = moda(p.xz, 2.*3.141592/6.);\np.x -= .4;\nreturn stmin(cyl(p.xz,0.1),sphe(p,0.8),0.5,5.);\n}\n\nfloat shape1 (vec3 p)\n{\np.xy = moda(p.xy, 2.*3.141592/7.);\np.x -=5.;\nreturn prim1(p);\n}\n\nfloat prim2 (vec3 p)\n{\np.xz *= rot(iTime);\np.xy *= rot(iTime);\nfloat sp = 1.;\nfloat steps = 3.;\nfloat _od = od(vec3(p.x-sp,p.y,p.z),1.);\nfloat _od1 = od(vec3(p.x+sp,p.y,p.z),1.);\nfloat _od3 = od(vec3(p.x,p.y+sp,p.z),1.);\nfloat _od2 = od(vec3(p.x,p.y-sp,p.z),1.);\nreturn  stmin(_od3,stmin(_od2,stmin(_od,_od1,0.5,steps),0.5,steps),0.5,steps);\n}\n\nfloat sdf (vec3 p)\n{\nfloat _od = prim2(p);\nfloat per = 2.;\np.xy *= rot(p.z*0.1);\np.z = mod(p.z-per/2.,per)-per/2.;\nreturn min(shape1(p),_od);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n    uv.x *= iResolution.x/iResolution.y;\n\t\n    vec3 ro = vec3(0.01,0.01,-10.+exp(-fract(iTime))); vec3 p = ro;\n    vec3 dir = normalize(vec3(uv,1.));\n    float shad = 0.;\n    float t = 0.;\n\n    for (float i=0.; i<ITER; i++)\n    {\n    float d = sdf(p);\n    if (d<0.01)\n    {\n    shad = i/ITER;\n    break;\n    }\n    p+=d*dir*0.5;\n    }\n\n    t = length(ro-p);\n    vec3 pal = palette(abs(uv.y),\n                        vec3(0.5),\n                        vec3(0.5),\n                        vec3(0.4),\n                        vec3(0.,0.2,0.5)\n                    );\n    vec3 color = vec3(1.-shad)/vec3(0.7,0.5,0.5);\n    color = mix(color, pal,1.-exp(-0.008*t*t));\n\n    // Output to screen\n    fragColor = vec4(pow(color,vec3(0.45)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4syyzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 143, 143, 201], [203, 203, 233, 233, 342], [344, 344, 394, 394, 485], [487, 487, 542, 542, 581], [583, 583, 612, 612, 634], [637, 637, 667, 667, 689], [692, 692, 720, 720, 758], [761, 761, 783, 783, 903], [905, 905, 928, 928, 992], [994, 994, 1016, 1016, 1337], [1339, 1339, 1359, 1359, 1482], [1485, 1485, 1542, 1592, 2374]], "test": "ok"}
{"id": "ld3BzM", "name": "Desert Sand", "author": "Shane", "description": "Bump mapping a procedural sand texture onto some basic terrain and applying some lighting to produce a stylized desert sand scene.", "tags": ["procedural", "terrain", "texture", "sand", "desert", "dune"], "likes": 117, "viewed": 3785, "published": "Public API", "date": "1525007454", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tDesert Sand\n\t-----------\n\n\tSand, and more sand -- Monotony, at it's finest. :) I've visited and flown over many sandy \n\tregions in my time, and I can say unequivocably that this particular scene doesn't remotely  \n\tresemble the real thing. :D \n\n\tHaving said that, there's something that I really like about minimal artificial dune scenes.  \n\tThey're somewhat of a visual programmer cliche -- I think that's partly due to the fact that \n\tthey have a decent \"aesthetic appeal to algorithmic complexity\" ratio.\n\t\n\tFor the sand dunes, rather than deal with dune physics, I used a pretty standard smoothstep \n\tnoise layer formula. I wouldn't say that dune physics is particularly difficult, but I'd \n\trather leave that to people like Dr2. :) Besides, with this example, I wanted to save some\n\tcycles and focus on the sand texture generation.\n\n\tThere are so many different ways to create wavy sand patterns. Some are expensive -- using\n\tthings like gradient erosion -- and some are cheap. Not suprisingly, the expensive methods \n\ttend to look better. I bump mapped the sand layer to give myself a few extra cycles to play \n\twith, but I still had to keep things relatively simple.\n\n\tThe pattern you see is a mixture of a simple trick I've seen around and some of my own\n\tadjustments. Without going into detail, the idea is to create a layer of repeat rounded \n\tgradient lines, and another rotated at a slight angle, then perturb them slightly and mix \n\ttogether using an underlying noise layer. It's simple, but reasonably effective. Anyway, \n\tI've explained in more detail in the \"sand\" function below.\n\n\tBy the way, with some tweaking, grouping, rearranging, etc, I'm pretty sure I could make this \n\trun faster. However, it'd be at the expense of the readability of the sand texture function,\n\tso for now, I'm going to leave it alone. Anyway, I'm going to produce a few surface realated\n\texamples later.\n\t\n\n\tRelated examples:\n\n\t// It won Breakpoint way back in 2009. Ten people on Pouet gave it the thumbs down -- I hope\n\t// they put their work up on Shadertoy, because I'd imagine it'd be insanely good. :D\n\tElevated - IQ\n\thttps://www.shadertoy.com/view/MdX3Rr\n\n\n\t// One of my favorite simple coloring jobs.\n    Skin Peeler - Dave Hoskins\n    https://www.shadertoy.com/view/XtfSWX\n    Based on one of my all time favorites:\n    Xyptonjtroz - Nimitz\n\thttps://www.shadertoy.com/view/4ts3z2\n\n*/\n\n// The far plane. I'd like this to be larger, but the extra iterations required to render the \n// additional scenery starts to slow things down on my slower machine.\n#define FAR 80.\n\n\n// Fabrice's concise, 2D rotation formula.\n//mat2 rot2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n// Standard 2D rotation formula - Nimitz says it's faster, so that's good enough for me. :)\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n// 3x1 hash function.\nfloat hash( vec3 p ){ return fract(sin(dot(p, vec3(21.71, 157.97, 113.43)))*45758.5453); }\n\n\n// IQ's smooth minium function. \nfloat smin(float a, float b , float s){\n    \n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n\n/*\n// Dave's hash function. More reliable with large values, but will still eventually break down.\n//\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// vec2 to vec2.\nvec2 hash22(vec2 p){\n\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    p = fract((p3.xx + p3.yz)*p3.zy)*2. - 1.;\n    return p;\n    \n    \n    // Note the \"mod\" call. Slower, but ensures accuracy with large time values.\n    //mat2  m = r2(mod(iTime, 6.2831853)); \n\t//p.xy = m * p.xy;//rotate gradient vector\n  \t//return p;\n    \n\n}\n*/\n\n\n#define RIGID\n// Standard 2x2 hash algorithm.\nvec2 hash22(vec2 p) {\n    \n    // Faster, but probaly doesn't disperse things as nicely as other methods.\n    float n = sin(dot(p, vec2(113, 1)));\n    p = fract(vec2(2097152, 262144)*n)*2. - 1.;\n    #ifdef RIGID\n    return p;\n    #else\n    return cos(p*6.283 + iGlobalTime);\n    //return abs(fract(p+ iGlobalTime*.25)-.5)*2. - .5; // Snooker.\n    //return abs(cos(p*6.283 + iGlobalTime))*.5; // Bounce.\n    #endif\n\n}\n\n\n\n// Gradient noise. Ken Perlin came up with it, or a version of it. Either way, this is\n// based on IQ's implementation. It's a pretty simple process: Break space into squares, \n// attach random 2D vectors to each of the square's four vertices, then smoothly \n// interpolate the space between them.\nfloat gradN2D(in vec2 f){\n    \n    // Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy. \n   const vec2 e = vec2(0, 1);\n   \n    // Set up the cubic grid.\n    // Integer value - unique to each cube, and used as an ID to generate random vectors for the\n    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed\n    // to them.\n    vec2 p = floor(f);\n    f -= p; // Fractional position within the cube.\n    \n\n    // Smoothing - for smooth interpolation. Use the last line see the difference.\n    //vec2 w = f*f*f*(f*(f*6.-15.)+10.); // Quintic smoothing. Slower and more squarish, but derivatives are smooth too.\n    vec2 w = f*f*(3. - 2.*f); // Cubic smoothing. \n    //vec2 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w; // Super smooth, but less practical.\n    //vec2 w = .5 - .5*cos(f*3.14159); // Cosinusoidal smoothing.\n    //vec2 w = f; // No smoothing. Gives a blocky appearance.\n    \n    // Smoothly interpolating between the four verticies of the square. Due to the shared vertices between\n    // grid squares, the result is blending of random values throughout the 2D space. By the way, the \"dot\" \n    // operation makes most sense visually, but isn't the only metric possible.\n    float c = mix(mix(dot(hash22(p + e.xx), f - e.xx), dot(hash22(p + e.yx), f - e.yx), w.x),\n                  mix(dot(hash22(p + e.xy), f - e.xy), dot(hash22(p + e.yy), f - e.yy), w.x), w.y);\n    \n    // Taking the final result, and converting it to the zero to one range.\n    return c*.5 + .5; // Range: [0, 1].\n}\n\n// Gradient noise fBm.\nfloat fBm(in vec2 p){\n    \n    return gradN2D(p)*.57 + gradN2D(p*2.)*.28 + gradN2D(p*4.)*.15;\n    \n}\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function - based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values. I'll swap it for something more robust later.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; \n    //p *= p*p*(p*(p*6. - 15.) + 10.);\n    p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n\n// Repeat gradient lines. How you produce these depends on the effect you're after. I've used a smoothed\n// triangle gradient mixed with a custom smoothed gradient to effect a little sharpness. It was produced\n// by trial and error. If you're not sure what it does, just call it individually, and you'll see.\nfloat grad(float x, float offs){\n    \n    // Repeat triangle wave. The tau factor and \".25\" factor aren't necessary, but I wanted its frequency\n    // to overlap a sine function.\n    x = abs(fract(x/6.283 + offs - .25) - .5)*2.;\n    \n    float x2 = clamp(x*x*(-1. + 2.*x), 0., 1.); // Customed smoothed, peaky triangle wave.\n    //x *= x*x*(x*(x*6. - 15.) + 10.); // Extra smooth.\n    x = smoothstep(0., 1., x); // Basic smoothing - Equivalent to: x*x*(3. - 2.*x).\n    return mix(x, x2, .15);\n    \n/*    \n    // Repeat sine gradient.\n    float s = sin(x + 6.283*offs + 0.);\n    return s*.5 + .5;\n    // Sine mixed with an absolute sine wave.\n    //float sa = sin((x +  6.283*offs)/2.);\n    //return mix(s*.5 + .5, 1. - abs(sa), .5);\n    \n*/\n}\n\n// One sand function layer... which is comprised of two mixed, rotated layers of repeat gradients lines.\nfloat sandL(vec2 p){\n    \n    // Layer one. \n    vec2 q = rot2(3.14159/18.)*p; // Rotate the layer, but not too much.\n    q.y += (gradN2D(q*18.) - .5)*.05; // Perturb the lines to make them look wavy.\n    float grad1 = grad(q.y*80., 0.); // Repeat gradient lines.\n   \n    q = rot2(-3.14159/20.)*p; // Rotate the layer back the other way, but not too much.\n    q.y += (gradN2D(q*12.) - .5)*.05; // Perturb the lines to make them look wavy.\n    float grad2 = grad(q.y*80., .5); // Repeat gradient lines.\n      \n    \n    // Mix the two layers above with an underlying 2D function. The function you choose is up to you,\n    // but it's customary to use noise functions. However, in this case, I used a transcendental \n    // combination, because I like the way it looked better.\n    // \n    // I feel that rotating the underlying mixing layers adds a little variety. Although, it's not\n    // completely necessary.\n    q = rot2(3.14159/4.)*p;\n    //float c = mix(grad1, grad2, smoothstep(.1, .9, n2D(q*vec2(8))));//smoothstep(.2, .8, n2D(q*8.))\n    //float c = mix(grad1, grad2, n2D(q*vec2(6)));//smoothstep(.2, .8, n2D(q*8.))\n    //float c = mix(grad1, grad2, dot(sin(q*12. - cos(q.yx*12.)), vec2(.25)) + .5);//smoothstep(.2, .8, n2D(q*8.))\n    \n    // The mixes above will work, but I wanted to use a subtle screen blend of grad1 and grad2.\n    float a2 = dot(sin(q*12. - cos(q.yx*12.)), vec2(.25)) + .5;\n    float a1 = 1. - a2;\n    \n    // Screen blend.\n    float c = 1. - (1. - grad1*a1)*(1. - grad2*a2);\n    \n    // Smooth max\\min\n    //float c = smax(grad1*a1, grad2*a2, .5);\n   \n    return c;\n    \n    \n}\n\n// A global value to record the distance from the camera to the hit point. It's used to tone\n// down the sand height values that are further away. If you don't do this, really bad\n// Moire artifacts will arise. By the way, you should always avoid globals, if you can, but\n// I didn't want to pass an extra variable through a bunch of different functions.\nfloat gT;\n\nfloat sand(vec2 p){\n    \n    // Rotating by 45 degrees. I thought it looked a little better this way. Not sure why.\n    // I've also zoomed in by a factor of 4.\n    p = vec2(p.y - p.x, p.x + p.y)*.7071/4.;\n    \n    // Sand layer 1.\n    float c1 = sandL(p);\n    \n    // Second layer.\n    // Rotate, then increase the frequency -- The latter is optional.\n    vec2 q = rot2(3.14159/12.)*p;\n    float c2 = sandL(q*1.25);\n    \n    // Mix the two layers with some underlying gradient noise.\n    c1 = mix(c1, c2, smoothstep(.1, .9, gradN2D(p*vec2(4))));\n    \n/*   \n\t// Optional screen blending of the layers. I preferred the mix method above.\n    float a2 = gradN2D(p*vec2(4));\n    float a1 = 1. - a2;\n    \n    // Screen blend.\n    c1 = 1. - (1. - c1*a1)*(1. - c2*a2);\n*/    \n    \n    // Extra grit. Not really necessary.\n    //c1 = .7 + fBm(p*128.)*.3;\n    \n    // A surprizingly simple and efficient hack to get rid of the super annoying Moire pattern \n    // formed in the distance. Simply lessen the value when it's further away. Most people would\n    // figure this out pretty quickly, but it took me far too long before it hit me. :)\n    return c1/(1. + gT*gT*.015);\n}\n\n/////////\n\n\n// The path is a 2D sinusoid that varies over time, which depends upon the frequencies and amplitudes.\nvec2 path(in float z){ \n    \n    return vec2(4.*sin(z * .1), 0);\n}\n\n// The standard way to produce \"cheap\" dunes is to apply a triangle function to individual\n// noise layers varying in amplitude and frequency. However, I needed something more subtle\n// and rounder, so I've only applied a triangle function to the middle layer.\n// \n// Here's an example using a more standard routine that's worth taking a look at:\n//\n// desert - wachel\n// https://www.shadertoy.com/view/ltcGDl\nfloat surfFunc( in vec3 p){\n    \n    p /= 2.5;\n    \n    // Large base ampltude with lower frequency.\n    float layer1 = n2D(p.xz*.2)*2. - .5; // Linear-like discontinuity - Gives an edge look.\n    layer1 = smoothstep(0., 1.05, layer1); // Smoothing the sharp edge.\n\n    // Medium amplitude with medium frequency. \n    float layer2 = n2D(p.xz*.275);\n    layer2 = 1. - abs(layer2 - .5)*2.; // Triangle function, to give the dune edge look.\n    layer2 = smoothstep(.2, 1., layer2*layer2); // Smoothing the sharp edge.\n    \n    // Smaller, higher frequency layer.\n\tfloat layer3 = n2D(p.xz*.5*3.);\n\n     // Combining layers fBm style. Ie; Amplitudes inversely proportional to frequency.\n    float res = layer1*.7 + layer2*.25 + layer3*.05;\n    //float res = 1. - (1. - layer1*.7)*(1. - layer2*.25)*(1. - layer3*.05); // Screen \n    //float res = layer1*.75 + layer2*.25;\n\n    return res;\n    \n}\n\n\n// A similar -- trimmed down and smoothed out -- version of function above, for camera path usage.\nfloat camSurfFunc( in vec3 p){\n    \n    p /= 2.5;\n    \n    // Large base ampltude with lower frequency.\n    float layer1 = n2D(p.xz*.2)*2. - .5; // Linear-like discontinuity - Gives an edge look.\n    layer1 = smoothstep(0., 1.05, layer1); // Smoothing the sharp edge.\n\n    // Medium amplitude with medium frequency. \n    float layer2 = n2D(p.xz*.275);\n    layer2 = 1. - abs(layer2 - .5)*2.; // Triangle function, to give the dune edge look.\n    layer2 = smoothstep(.2, 1., layer2*layer2); // Smoothing the sharp edge.\n\n     // Combining layers fBm style. Ie; Amplitudes inversely proportional to frequency.\n    float res = (layer1*.7 + layer2*.25)/.95;\n    //float res = 1. - (1. - layer1*.75)*(1. - layer2*.25); // Screen \n\n    return res;\n    \n}\n\n\n\n// The desert scene. Adding a heightmap to an XZ plane. Not a complicated distance function. :)\nfloat map(vec3 p){\n    \n\t// Height map to perturb the flat plane. On a side note, I'll usually keep the\n    // surface function within a zero to one range, which means I can use it later\n    // for a bit of shading, etc. Of course, I could cut things down a bit, but at\n    // the expense of confusion elsewhere... if that makes any sense. :)\n    float sf = surfFunc(p);\n\n    // Add the height map to the plane.\n    return p.y + (.5-sf)*2.; \n \n}\n\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0., h;\n    \n    for(int i=0; i<96; i++){\n    \n        h = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.001*(t*.125 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        t += h; \n    }\n\n    return min(t, FAR);\n}\n\n/*\n// Tetrahedral normal - courtesy of IQ. I'm in saving mode, so the two \"map\" calls saved make\n// a difference. Also because of the random nature of the scene, the tetrahedral normal has the \n// same aesthetic effect as the regular - but more expensive - one, so it's an easy decision.\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n*/\n\n \n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 normal(in vec3 p, float ef) {\n\tvec2 e = vec2(0.001*ef, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n/*\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, fract(p.zx)).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n\n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n*/\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(113, 157, 1);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n// 3D noise fBm.\nfloat fBm(in vec3 p){\n    \n    return n3D(p)*.57 + n3D(p*2.)*.28 + n3D(p*4.)*.15;\n    \n}\n\n\n// Surface bump function..\nfloat bumpSurf3D( in vec3 p){\n    \n    // Obtaining some terrain samples in order to produce a gradient\n    // with which to distort the sand. Basically, it'll make it look\n    // like the underlying terrain it effecting the sand. The downside\n    // is the three extra taps per bump tap... Ouch. :) Actually, it's\n    // not that bad, but I might attempt to come up with a better way.\n    float n = surfFunc(p);\n    vec3 px = p + vec3(.001, 0, 0);\n    float nx = surfFunc(px);\n    vec3 pz = p + vec3(0, 0, .001);\n    float nz = surfFunc(pz);\n    \n    // The wavy sand, that has been perturbed by the underlying terrain.\n    return sand(p.xz + vec2(n - nx, n - nz)/.001*1.);\n\n}\n\n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(0.001, 0); \n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    float ref = bumpSurf3D(p);\n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx)) - ref)/e.x; \n    \n    /*\n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n                     bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n                     bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    */\n       \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= nor*dot(nor, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(nor + grad*bumpfactor);\n\t\n}\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = 0.0015;  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n         \n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        h = clamp(h, .1, .5); // max(h, .02);//\n        dist += h;\n\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (shade<.001 || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also, just for kicks. :)\n    return min(max(shade, 0.) + .05, 1.); \n}\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 4.;\n\tconst float nbIte = 5.;\n\t//const float falloff = .9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i + .0)*.5/nbIte*maxDist;        \n        ao += (l - map( p + n*l )); // / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n\n\n\n// Standard sky routine: Gradient with sun and overhead cloud plane. I debated over whether to put more \n// effort in, but the dust is there and I'm saving cycles. I originally included sun flares, but wasn't \n// feeling it, so took them out. I might tweak them later, and see if I can make them work with the scene.\nvec3 getSky(vec3 ro, vec3 rd, vec3 ld){ \n    \n    // Sky color gradients.\n    vec3 col = vec3(.8, .7, .5), col2 = vec3(.4, .6, .9);\n    \n    //return mix(col, col2, pow(max(rd.y*.5 + .9, 0.), 5.));  // Probably a little too simplistic. :)\n     \n    // Mix the gradients using the Y value of the unit direction ray. \n    vec3 sky = mix(col, col2, pow(max(rd.y + .15, 0.), .5));\n    sky *= vec3(.84, 1, 1.17); // Adding some extra vibrancy.\n     \n    float sun = clamp(dot(ld, rd), 0., 1.);\n    sky += vec3(1, .7, .4)*vec3(pow(sun, 16.))*.2; // Sun flare, of sorts.\n    sun = pow(sun, 32.); // Not sure how well GPUs handle really high powers, so I'm doing it in two steps.\n    sky += vec3(1, .9, .6)*vec3(pow(sun, 32.))*.35; // Sun.\n    \n     // Subtle, fake sky curvature.\n    rd.z *= 1. + length(rd.xy)*.15;\n    rd = normalize(rd);\n   \n    // A simple way to place some clouds on a distant plane above the terrain -- Based on something IQ uses.\n    const float SC = 1e5;\n    float t = (SC - ro.y - .15)/(rd.y + .15); // Trace out to a distant XZ plane.\n    vec2 uv = (ro + t*rd).xz; // UV coordinates.\n    \n    // Mix the sky with the clouds, whilst fading out a little toward the horizon (The rd.y bit).\n\tif(t>0.) sky =  mix(sky, vec3(2), smoothstep(.45, 1., fBm(1.5*uv/SC))*\n                        smoothstep(.45, .55, rd.y*.5 + .5)*.4);\n    \n    // Return the sky color.\n    return sky;\n}\n\n\n\n// More concise, self contained version of IQ's original 3D noise function.\nfloat noise3D(in vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(113, 157, 1);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\n/////\n// Code block to produce some layers of smokey haze. Not sophisticated at all.\n// If you'd like to see a much more sophisticated version, refer to Nitmitz's\n// Xyptonjtroz example. Incidently, I wrote this off the top of my head, but\n// I did have that example in mind when writing this.\n\n// Hash to return a scalar value from a 3D vector.\nfloat hash31(vec3 p){ return fract(sin(dot(p, vec3(127.1, 311.7, 74.7)))*43758.5453); }\n\n// Several layers of cheap noise to produce some subtle smokey haze.\n// Start at the ray origin, then take some samples of noise between it\n// and the surface point. Apply some very simplistic lighting along the \n// way. It's not particularly well thought out, but it doesn't have to be.\nfloat getMist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist = 0.;\n    \n    //ro -= vec3(0, 0, iTime*3.);\n    \n    float t0 = 0.;\n    \n    for (int i = 0; i<24; i++){\n        \n        // If we reach the surface, don't accumulate any more values.\n        if (t0>t) break; \n        \n        // Lighting. Technically, a lot of these points would be\n        // shadowed, but we're ignoring that.\n        float sDi = length(lp-ro)/FAR; \n\t    float sAtt = 1./(1. + sDi*.25);\n\t    \n        // Noise layer.\n        vec3 ro2 = (ro + rd*t0)*2.5;\n        float c = noise3D(ro2)*.65 + noise3D(ro2*3.)*.25 + noise3D(ro2*9.)*.1;\n        //float c = noise3D(ro2)*.65 + noise3D(ro2*4.)*.35; \n\n        float n = c;//max(.65-abs(c - .5)*2., 0.);//smoothstep(0., 1., abs(c - .5)*2.);\n        mist += n*sAtt;\n        \n        // Advance the starting point towards the hit point. You can \n        // do this with constant jumps (FAR/8., etc), but I'm using\n        // a variable jump here, because it gave me the aesthetic \n        // results I was after.\n        t0 += clamp(c*.25, .1, 1.);\n        \n    }\n    \n    // Add a little noise, then clamp, and we're done.\n    return max(mist/48., 0.);\n    \n    // A different variation (float n = (c. + 0.);)\n    //return smoothstep(.05, 1., mist/32.);\n\n}\n\n//////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\t\n\n\n\t\n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.     \n\tvec3 ro = vec3(0, 1.2, iTime*2.); // Camera position, doubling as the ray origin.\n    vec3 lookAt = ro + vec3(0, -.15, .5);  // \"Look At\" position.\n    \n\t\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera and \"look at\" vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function.\n\tro.xy += path(ro.z);\n\tlookAt.xy += path(lookAt.z);\n    \n    // Raising the camera up and down with the terrain function and tilting it up or down\n    // according to the slope. It's subtle, but it adds to the immersiveness of that mind \n    // blowing, endless-sand experience. :D\n    float sfH = camSurfFunc(ro); \n    float sfH2 = camSurfFunc(lookAt); \n    float slope = (sfH2 - sfH)/length(lookAt - ro); // Used a few lines below.\n    //slope = smoothstep(-.15, 1.15, (slope*.5 + .5)) - .5; // Smoothing the slope... Needs work.\n     \n    // Raising the camera with the terrain.\n    ro.y += sfH2; \n    lookAt.y += sfH2;\n    \n \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159265/2.5; // FOV - Field of view.\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/96.)*rd.xy;\n    \n    // Subtle up and down tilt, or camera pitch, if you prefer.\n    rd.yz = rot2(-slope/3.)*rd.yz;\n\t\n    // Usually, you'd just make this a unit directional light, and be done with it, but I\n    // like some of the angular subtleties of point lights, so this is a point light a\n    // long distance away. Fake, and probably not advisable, but no one will notice.\n    vec3 lp = vec3(FAR*.25, FAR*.25, FAR) + vec3(0, 0, ro.z);\n \n\n\t// Raymarching.\n    float t = trace(ro, rd);\n    \n    gT = t;\n    \n   \n    // Sky. Only retrieving a single color this time.\n    //vec3 sky = getSky(rd);\n    \n    // The passage color. Can't remember why I set it to sky. I'm sure I had my reasons.\n    vec3 col = vec3(0);\n    \n    // Surface point. \"t\" is clamped to the maximum distance, and I'm reusing it to render\n    // the mist, so that's why it's declared in an untidy postion outside the block below...\n    // It seemed like a good idea at the time. :)\n    vec3 sp = ro+t*rd; \n    \n    float pathHeight = sp.y;//surfFunc(sp);// - path(sp.z).y; // Path height line, of sorts.\n    \n    // If we've hit the ground, color it up.\n    if (t < FAR){\n    \n        \n        vec3 sn = normal(sp, 1.); // Surface normal. //*(1. + t*.125)\n        \n        // Light direction vector. From the sun to the surface point. We're not performing\n        // light distance attenuation, since it'll probably have minimal effect.\n        vec3 ld = lp - sp;\n        float lDist = max(length(ld), 0.001);\n        ld /= lDist; // Normalize the light direct vector.\n        \n        lDist /= FAR; // Scaling down the distance to something workable for calculations.\n        float atten = 1./(1. + lDist*lDist*.025);\n\n        \n        // Texture scale factor.        \n        const float tSize = 1./8.;\n        \n        \n        // Function based bump mapping.\n        sn = doBumpMap(sp, sn, .07);///(1. + t*t/FAR/FAR*.25)\n        \n        // Texture bump mapping.\n        float bf = .01;//(pathHeight + 5. < 0.)?  .05: .025;\n        //sn = doBumpMap(iChannel0, sp*tSize, sn, bf/(1. + t/FAR));\n        \n        \n        // Soft shadows and occlusion.\n        float sh = softShadow(sp + sn*.002, lp, 6., t); \n        float ao = calcAO(sp, sn); // Ambient occlusion.\n        \n        // Add AO to the shadow. No science, but adding AO to things sometimes gives a bounced light look.\n        sh = min(sh + ao*.25, 1.); \n        \n        float dif = max( dot( ld, sn ), 0.0); // Diffuse term.\n        float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 5.); // Specular term.\n        float fre = clamp(1.0 + dot(rd, sn), 0.0, 1.0); // Fresnel reflection term.\n \n        // Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a sandstone consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n\t\tfloat fre2 = mix(.2, 1., Schlick);  //F0 = .2 - Hard clay... or close enough.\n       \n        // Overal global ambience. It's made up, but I figured a little occlusion (less ambient light\n        // in the corners, etc) and reflectance would be in amongst it... Sounds good, anyway. :)\n        float amb = ao*.35;// + fre*fre2*.2;\n        \n\n        \n        // Give the sand a bit of a sandstone texture.\n        col = mix(vec3(1, .95, .7), vec3(.9, .6, .4), fBm(sp.xz*16.));\n        col = mix(col*1.4, col*.6, fBm(sp.xz*32. - .5));///(1. + t*t*.001)\n        \n       \n        // Extra shading in the sand crevices.\n        float bSurf = bumpSurf3D(sp);\n        col *= bSurf*.75 + .5;\n       \n        \n        // Lamest sand sprinkles ever. :)\n        col = mix(col*.7 + (hash(floor(sp*96.))*.7 + hash(floor(sp*192.))*.3)*.3, col, min(t*t/FAR, 1.));\n        \n        col *= vec3(1.2, 1, .9); // Extra color -- Part of last minute adjustments.\n        \n        \n        // Combining all the terms from above. Some diffuse, some specular - both of which are\n        // shadowed and occluded - plus some global ambience. Not entirely correct, but it's\n        // good enough for the purposes of this demonstation.        \n        col = col*(dif + amb + vec3(1, .97, .92)*fre2*spe*2.)*atten;\n        \n        \n        // A bit of sky reflection. Not really accurate, but I've been using fake physics since the 90s. :)\n        vec3 refSky = getSky(sp, reflect(rd, sn), ld);\n        col += col*refSky*.05 + refSky*fre*fre2*atten*.15; \n        \n \n        // Applying the shadows and ambient occlusion.\n        col *= sh*ao;\n\n        //col = vec3(ao);\n    }\n    \n  \n    // Combine the scene with the sky using some cheap volumetric substance.\n\tfloat dust = getMist(ro, rd, lp, t)*(1. - smoothstep(0., 1., pathHeight*.05));//(-rd.y + 1.);\n    vec3 gLD = normalize(lp - vec3(0, 0, ro.z));\n    vec3 sky = getSky(ro, rd, gLD);//*mix(1., .75, dust);\n    //col = mix(col, sky, min(t*t*1.5/FAR/FAR, 1.)); // Quadratic fade off. More subtle.\n    col = mix(col, sky, smoothstep(0., .95, t/FAR)); // Linear fade. Much dustier. I kind of like it.\n    \n    \n    // Mild dusty haze... Not really sure how it fits into the physical situation, but I thought it'd\n    // add an extra level of depth... or something. At this point I'm reminded of the \"dog in a tie \n    // sitting at the computer\" meme with the caption, \"I have no idea what I'm doing.\" :D\n    vec3 mistCol = vec3(1, .95, .9); // Probably, more realistic, but less interesting.\n    //col += (mix(col, mistCol, .66)*.66 + col*mistCol*1.)*dust;\n    \n    \n    // Simulating sun scatter over the sky and terrain: IQ uses it in his Elevated example.\n    col += vec3(1., .6, .2)*pow( max(dot(rd, gLD), 0.), 16.)*.45;\n    \n    \n    // Applying the mild dusty haze.\n    col = col*.75 + (col + .25*vec3(1.2, 1, .9))*mistCol*dust*1.5;\n    //col *= 1.05;\n    \n    \n    // Really artificial. Kind of cool, but probably a little too much.    \n    //col *= vec3(1.2, 1, .9);\n\n    \n    // Standard way to do a square vignette. Note that the maxium value value occurs at \"pow(0.5, 4.) = 1./16,\" \n    // so you multiply by 16 to give it a zero to one range. This one has been toned down with a power\n    // term to give it more subtlety.\n    u = fragCoord/iResolution.xy;\n    col = min(col, 1.)*pow( 16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .0625);\n \n    // Done.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld3BzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2577, 2803, 2825, 2825, 2883], [2886, 2908, 2929, 2929, 2998], [3001, 3034, 3073, 3073, 3169], [3171, 3220, 3258, 3258, 3353], [3998, 4030, 4051, 4135, 4446], [4450, 4748, 4773, 4865, 6319], [6321, 6344, 6365, 6365, 6444], [6447, 6716, 6735, 6735, 6984], [6987, 7296, 7328, 7474, 8038], [8040, 8145, 8165, 8189, 9752], [10120, 10120, 10139, 10280, 11287], [11301, 11404, 11426, 11426, 11470], [11472, 11882, 11909, 11909, 12771], [12774, 12873, 12903, 12903, 13620], [13624, 13720, 13738, 14062, 14165], [14169, 14190, 14226, 14226, 14662], [15145, 15245, 15279, 15279, 15434], [16819, 16962, 16983, 16983, 17329], [17332, 17349, 17370, 17370, 17437], [17440, 17467, 17496, 17852, 18144], [18146, 18337, 18394, 18495, 19481], [19483, 19784, 19837, 19915, 21248], [21252, 21404, 21440, 21440, 21748], [21752, 22069, 22108, 22142, 23462], [23466, 23542, 23567, 23660, 24612], [24909, 24960, 24981, 24981, 25047], [25049, 25337, 25399, 25399, 26634], [26644, 26644, 26700, 26729, 34732]], "test": "error"}
{"id": "ld3fDr", "name": "catadioptre 2", "author": "FabriceNeyret2", "description": ".", "tags": ["raymarching", "sdf", "short"], "likes": 3, "viewed": 311, "published": "Public API", "date": "1524689607", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/MdcBDr\n\n#define C(r)   t = max(t, r - max(max(a.x,a.y),a.z)  )\n#define R(x,y) t = max(t, max(abs(q.x+q.y),abs(q.x-q.y)) /1.41 )  \n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t = iTime;\n    mat2  R = mat2( sin(t+vec4(0,33,11,0)) );\n    vec3  q = iResolution,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),    // ray direction\n          p = 30./q, a;                       // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p,\n        q.xz *= R, q.yz *= R,                 // rotation\n        t-=t,\n        R(x,y), R(y,z), R(x,z) -6.,           // octaedron\n        t = max(t, -t-.1 ),                   // hollowing\n        a = abs(q), C(5.),                    // inner cube hole\n        p += t*D;                             // step forward = dist to obj\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld3fDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 208, 208, 850]], "test": "error"}
{"id": "ldcBD4", "name": "Rotating Julia Sets", "author": "Boomerang", "description": "Rotating Julia sets. Use your mouse to set an initial value for c! :D", "tags": ["fractal", "juliasets"], "likes": 0, "viewed": 380, "published": "Public API", "date": "1525118781", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 5.0;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    vec2 coord = scale * mouse - scale/2.0;\n    \n    float theta = atan(coord.y, coord.x);\n    float r = sqrt(coord.x*coord.x + coord.y*coord.y);\n    \n    vec2 c = r * vec2(cos(theta+iTime), sin(theta+iTime));\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    int i = 0;\n    int iters = 5000;\n    vec2 z = scale * uv - scale/2.0;\n    \n    while (i < iters && z.x*z.x + z.y*z.y < 4.0) {\n        z = vec2(z.x*z.x - z.y*z.y + c.x, 2.0 * z.x * z.y + c.y);\n        i++;\n    }\n    // Time varying pixel color\n    vec3 col = i == iters ? vec3(0): vec3((30 * i) % 255, (-40 * i) % 255, 50 + 50 * (i % 4)) / 255.0;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n                  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldcBD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 861]], "test": "ok"}
{"id": "ldcBW4", "name": "Floreate Dodecacyte", "author": "dpiponi", "description": "Iterating various kinds of dodecahedral folding\nAdded subsurface scattering model for a more waxy look", "tags": ["subsurfacescattering"], "likes": 12, "viewed": 297, "published": "Public", "date": "1525109843", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float theTime = 0.0;\n\nmat4 translate(vec3 p) {\n    return mat4(1.0,  0.0,  0.0,  -p.x,\n              0.0,  1.0,  0.0,  -p.y,\n              0.0,  0.0,  1.0,  -p.z,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 scale(vec3 s) {\n    return mat4(s.x,  0.0,  0.0,  0.0,\n              0.0,  s.y,  0.0,  0.0,\n              0.0,  0.0,  s.z,  0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(c,  -s,  0.0,  0.0,\n              s,  c,  0.0,  0.0,\n              0.0,  0.0,  1.0,  0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(c,  0.0, s,  0.0,\n              0.0,  1.0, 0.0, 0.0,\n              -s,  0.0, c,  0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, c,  -s,  0.0, \n                0.0, s,  c,  0.0,\n                0.0,  0.0,  0.0,  1.0);\n}\n\n// Assume n normalised\nvec3 fold(vec3 n, vec3 x) {\n    float nx = dot(n, x);\n    return nx >= 0.0 ? x : x-2.0*nx*n;\n}\n\nfloat g(vec3 x) {\n    //return length(x)-1.0;\n    return max(x.z,max(-x.z,max(x.y,max(-x.y,max(x.x, -x.x)))))-0.85;\n}\n\nfloat h(vec3 x) {\n    mat4 m = rotateZ(0.2101*theTime-3.128)*rotateY(0.1311*theTime+1.234);\n    return g((vec4(x, 1.0)*m).xyz);\n}\n\nvec2 xy;\n\n// {{1., 0., 0.}, {0., -1., 0.}, {0.809017, 0.5, -0.309017}}\nvec3 pc = vec3(0.809017, 0.5, -0.309017);\n\nvec3 dodecafold(vec3 x) {\n    x.xy = -abs(x.xy);\n    x = fold(pc, x);\n    x.xy = -abs(x.xy);\n    x = fold(pc, x);\n    x.xy = -abs(x.xy);\n    x = fold(pc, x);\n    x.xy = -abs(x.xy);\n    x = fold(pc, x);\n    x.xy = -abs(x.xy);\n    x = fold(pc, x);\n\n    return x;\n}\n\nfloat f(vec3 x) {\n    x = dodecafold(x);\n\n    x = (vec4(x,1.0)*rotateZ(0.478*theTime-9.128)*rotateY(0.13001*theTime+1.234)*scale(vec3(1.0, 1.0, 1.0))).xyz;\n    x = x+vec3(0.0, -0.4, 0.1);\n\n    x = dodecafold(x);\n\n    x = (vec4(x,1.0)*rotateZ(0.07*theTime-3.128)*rotateY(0.1*theTime+1.234)*scale(vec3(1.0, 1.0, 1.0))).xyz;\n    x = x+vec3(0.0, 0, 0.3);\n\n    x = dodecafold(x);\n\n    x = (vec4(x,1.0)*rotateZ(0.27*theTime-3.999)*rotateY(0.121*theTime+7.034)*scale(vec3(1.0, 1.0, 1.0))).xyz;\n    x = x+vec3(0.1, 0.3, 0.0);\n\n    x = dodecafold(x);\n\n    x = (vec4(x,1.0)*rotateZ(0.7654*theTime-31.128)*rotateY(0.201*theTime+1.034)*scale(vec3(1.0, 1.0, 1.0))).xyz;\n    x = x+vec3(0.1, 0.2, 0.0);\n\n    x = dodecafold(x);\n\n    x = (vec4(x,1.0)*rotateZ(0.91*theTime-3.128)*rotateY(0.0901*theTime+1.034)*scale(vec3(1.0, 1.0, 1.0))).xyz;\n    x = x+vec3(0.25, 0.3, 0.0);\n    \n    x = dodecafold(x);\n\n    return h(x);\n}\n\nfloat eps = 0.0001;\nfloat lambda = 2.0;\n\nvec3 ico[12];\n\n//vec3 hash3(vec3 x) {\n//    float u = 1000.0*sin(x.x*x.y+3.3*x.z-2.2*x.y+10.123*x.y+11.12*x.y*x.z);\n//    float v = 1000.0*sin(x.z*x.y-2.1*x.z+3.0*x.z+7.211*x.y+32.12*x.y*x.x);\n//    float w = 1000.0*cos(x.z*x.y+3.4*x.z-3.0*x.x+17.97*x.y+11.12*x.x*x.y);\n//    return vec3(u-floor(u), v-floor(v), w-floor(w));\n//}\n\nfloat lighting(vec3 x, vec3 n) {\n    float t = 0.0;\n    for (int i = 0; i < 12; ++i) {\n        float p = f(x-0.05*n+0.10*ico[i]);\n        t += 0.8+10.0*p;\n    }\n    return t/12.0;\n}\n\nmat4 view() {\n    return rotateY(0.2*theTime-6.28*xy.x)*rotateX(0.02*theTime);\n}\n\nvec3 march(vec3 p, vec3 d) {\n    float c;\n    c = f(p);\n    if (c < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    for (int i = 0; i < 70; ++i) {\n        float step = max(0.0025, c);\n        p = p+step*d;\n        c = f(p);\n        if (c <= 0.0) {\n            float ex, ey, ez;\n            ex = f(p+vec3(eps, 0.0, 0.0));\n            ey = f(p+vec3(0.0, eps, 0.0));\n            ez = f(p+vec3(0.0, 0.0, eps));\n            vec3 n = vec3(ex-c, ey-c, ez-c)/eps;\n            n = normalize(n);\n            mat4 m = view();\n            vec3 light = (vec4(1.0,1.0,-1.0,1.0)*m).xyz;\n            float l = 0.0;\n            l += 0.15+0.85*max(dot(n, light)/sqrt(3.0), 0.0);\n            l += 1.0*lighting(p, n);\n            return vec3(l)*vec3(0.74, 0.72, 0.7);\n        }\n    }\n    return vec3(0.1, 0.1, 0.1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    theTime = iTime;\n    //theTime = 39.0;\n\n    ico[0] = vec3(-0.26286500, 0.0000000, 0.42532500);\n    ico[1] = vec3(0.26286500, 0.0000000, 0.42532500);\n    ico[2] = vec3(-0.26286500, 0.0000000, -0.42532500);\n    ico[3] = vec3(0.26286500, 0.0000000, -0.42532500);\n    ico[4] = vec3(0.0000000, 0.42532500, 0.26286500);\n    ico[5] = vec3(0.0000000, 0.42532500, -0.26286500);\n    ico[6] = vec3(0.0000000, -0.42532500, 0.26286500);\n    ico[7] = vec3(0.0000000, -0.42532500, -0.26286500);\n    ico[8] = vec3(0.42532500, 0.26286500, 0.0000000);\n    ico[9] = vec3(-0.42532500, 0.26286500, 0.0000000);\n    ico[10] = vec3(0.42532500, -0.26286500, 0.0000000);\n    ico[11] = vec3(-0.42532500, -0.26286500, 0.0000000);    \n    \n    vec2 uv = fragCoord.xy-0.5*iResolution.xy;\n    uv = 2.0*uv/iResolution.y;\n    xy = iMouse.xy/iResolution.xy;\n\n    vec3 p = vec3(0.0, 0.0, -2.0);\n    vec3 d = normalize(vec3(0.5*uv, 1.0));\n    mat4 m = view();\n    p = (vec4(p, 1.0)*m).xyz;\n    d = (vec4(d, 1.0)*m).xyz;\n    vec3 color = march(p, d);\n    fragColor = vec4(color, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldcBW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 46, 46, 199], [201, 201, 221, 221, 371], [373, 373, 400, 400, 595], [597, 597, 624, 624, 815], [817, 817, 844, 844, 1044], [1046, 1069, 1096, 1096, 1163], [1165, 1165, 1182, 1210, 1282], [1284, 1284, 1301, 1301, 1413], [1529, 1529, 1554, 1554, 1791], [1793, 1793, 1810, 1810, 2697], [3070, 3070, 3102, 3102, 3251], [3253, 3253, 3266, 3266, 3333], [3335, 3335, 3363, 3363, 4137], [4139, 4139, 4194, 4194, 5248]], "test": "timeout"}
{"id": "ldcfWH", "name": "simpler audiotunnel", "author": "sclavel", "description": "completely based on https://www.shadertoy.com/view/lslfR7 , but without the multi-pass bloom effect", "tags": ["tunnel", "audio", "mic"], "likes": 12, "viewed": 3752, "published": "Public API", "date": "1524869603", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat time = 0.1;\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length( p.xz - c.xy ) - c.z;\n}\n\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n mat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\n\nvec2 map(vec3 p)\n{\n\n    vec3 q = p;\n\tp.z -= 0.1 * iTime + sin(iTime * 0.01)* 0.5;\n    vec3 c = vec3(0.53 / 4.0);\n    \n    p.z = mod(p.z,c.z)-0.5*c.z;\n         \n    vec4 noise = texture(iChannel1, floor(q.zz / 1.0));\n    \n    float freq =  atan(p.x, -p.y) / 3.1415 * 2.0 + fract(q.z) * 3.1415 * 2.0;\n    \n    float audio = texture(iChannel0, vec2((freq), 0.0)).r;\n    float audio2 = texture(iChannel0, vec2(fract(0.01*q.z), 0.0)).r;\n    \n  \tfloat r1 = 1.9 ;\n           \n    float r2 = r1 * (1.0 -  audio2);\n        \n    \n    float thickness = 0.02 * audio2;\n\n    \n    float inner = sdCappedCylinder(p.xzy , vec2(r2, 0.5));\n    float outer = sdCappedCylinder(p.xzy, vec2(r1, thickness));\n        \n    float result = opS(inner, outer);\n\n    float theta = iTime + q.z + audio2;\n    float r = 1.0;\n\tfloat ball = length(p + vec3(r * cos(theta), r * sin(theta), 0.0)) - audio2* 2.0;\n\tresult = opS(ball, result);                  \n\n\tball = length(p + vec3(r * cos(-theta), r * sin(-theta), 0.0)) - audio2* 2.0;\n\tresult = opS(ball, result);   \n    \n\tball = length(p + vec3(r * cos(theta + 3.1415), r * sin(theta + 3.1415), 0.0)) - audio2* 2.0;\n\tresult = opS(ball, result);   \n    \n\tball = length(p + vec3(r * cos(-theta + 3.1415), r * sin(-theta + 3.1415), 0.0)) - audio2* 2.0;\n\tresult = opS(ball, result);   \n    \n    return vec2(result, audio2);\n    \n}\n\n\n// See http://iquilezles.org/www/articles/palettes/palettes.htm for more information\n\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid getCamPos(inout vec3 ro, inout vec3 rd)\n{\n    ro.z = iTime  ;\n  //  ro.x -= sin(iTime /5.7);\n  //  ro.y -= cos(iTime /  2.3);\n}\n\n vec3 gradient(vec3 p, float t) {\n\t\t\tvec2 e = vec2(0., t);\n\n\t\t\treturn normalize( \n\t\t\t\tvec3(\n\t\t\t\t\tmap(p+e.yxx).x - map(p-e.yxx).x,\n\t\t\t\t\tmap(p+e.xyx).x - map(p-e.xyx).x,\n\t\t\t\t\tmap(p+e.xxy).x - map(p-e.xxy).x\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n#define MAX_D 20.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iTime * 0.5;\n\n    vec2 _p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    vec2 noise = texture(iChannel0, _p).rg;\n\n    vec3 ray = normalize(vec3(_p + noise * 0.01, 1.0));\n    vec3 cam = vec3(0.0, 0.0, 0.0);\n    bool hit = false;\n    getCamPos(cam, ray);\n    \n    float depth = 0.0, iter = 0.0;\n    vec2 d; \n    vec3 p;\n    \n    for( int i = 0; i < 50; i ++)\n    {\n    \tp = depth * ray + cam;\n        d = map(p);\n                  \n        if (d.x < 0.001 * pow(depth, 2.0)) {\n\t\t\thit = true;\n            break;\n        }\n        \n        if (depth > MAX_D)\n            break;\n                   \n\t\tdepth += d.x * 0.2; \n\t\titer++; \n    }\n    float ii = 1.0 - iter / 50.0;\n    vec3 col = vec3(ii); \n    if ( hit)\n    col *= pal(d.y, vec3(0.5,0.5,0.9),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20));\n    \n    fragColor = vec4(sqrt(sqrt(col)),1.0);\n    \n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldcfWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 55, 55, 95], [98, 98, 140, 140, 239], [241, 241, 274, 274, 300], [303, 303, 348, 348, 820], [824, 824, 842, 842, 2169], [2259, 2259, 2327, 2327, 2370], [2373, 2373, 2419, 2419, 2505], [2508, 2508, 2540, 2540, 2727], [2748, 2748, 2805, 2805, 3687]], "test": "error"}
{"id": "ldcfzn", "name": "padded union", "author": "expertmouser", "description": "an sdf union function which leaves a margin between the shapes.", "tags": ["sdf", "union", "padding"], "likes": 1, "viewed": 317, "published": "Public API", "date": "1523918502", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec4 oColor;\nvec2 vTexcoord;\n\n//-----------------------------------------------------------\n\n\nconst float kEpsilon     = 0.0001;\nconst float kMyPI        = 3.14159265359;\nconst float kLargeFloat  = 10000000.0; \nconst float kCloseEnough = 0.005;\nconst float kDegToRad    = (kMyPI * 2.0) / 360.0;\nconst float kRadToDeg    = 360.0 / (kMyPI * 2.0);\nconst vec3  kVecX        = vec3(1.0, 0.0, 0.0);\nconst vec3  kVecY        = vec3(0.0, 1.0, 0.0);\nconst vec3  kVecZ        = vec3(0.0, 0.0, 1.0);\nconst vec3  kVec0        = vec3(0.0);\nconst vec3  kVec1        = vec3(1.0);\n\n      float myTime       = 0.0;\n\n//--------------------------------------------\n// basic math\n\nfloat avg(float a, float b) {\n  return (a + b) * 0.5;\n}\n\nmat2 rot2(float radians) {\n  float c = cos(radians);\n  float s = sin(radians);\n  return mat2(c, s, -s, c);\n}\n\nfloat sdfUnionPadded(float a, float b, float padA, float padB) {\n  // i'm not sure this can be simplified.\n  // it can be expressed as five abs() calls plus some divide by fours,\n  // but i'm hesitant to go there. i suspect min/max are non-branching in GPUs.\n  float sub1 = max(a - padA, -a);\n  float sub2 = max(b - padB, -b);\n  float sub  = min(sub1, sub2);\n  float ret  = max(min(a, b), -sub);\n  return ret;\n}\n\nfloat sdfUnion(float a, float b) {\n  return min(a, b);\n}\n\nfloat sdfIntersect(float a, float b) {\n  return max(a, b);\n}\n\nfloat sdfMinus(float a, float b) {\n  return max(a, -b);\n}\n\n//--------------------------------------------\n// SDF Primititves\n\nfloat sdfCircle(vec2 pnt, vec2 center, float radius) {\n  return length(pnt - center) - radius;\n}\n\nfloat sdfAnulus(vec2 pnt, vec2 center, float radius1, float radius2) {\n  return sdfMinus(\n    sdfCircle(pnt, center, radius2),\n    sdfCircle(pnt, center, radius1));\n}\n\nfloat sdfSquare(vec2 pnt, vec2 center, float shortRadius) {\n  vec2 v = pnt - center;\n  float ret = -kLargeFloat;\n  ret = max(ret,  v.x - shortRadius);\n  ret = max(ret, -v.x - shortRadius);\n  ret = max(ret,  v.y - shortRadius);\n  ret = max(ret, -v.y - shortRadius);\n  return ret;\n}\n\n//--------------------------------------------\n// scene\n\nfloat sdfScene(vec2 pnt) {\n  float t = myTime * 0.51;\n\n  float rad = (sin(t) * 0.5 + 1.0) * 7.0;\n  float pad1 = rad * 0.95 * (sin(t * 0.27) * 0.21 + 0.19);\n  \n  vec2 c1 = vec2(sin(t * 1.0), cos(t * 1.2)) * 10.0;\n  vec2 c2 = vec2(sin(t * 1.3), cos(t * 1.5)) * 10.0;\n  vec2 c3 = vec2(sin(t * 1.6), cos(t * 1.7)) * 10.0;\n\n  float sdfc1 = sdfCircle(pnt, c1, rad);\n  float sdfc2 = sdfAnulus(pnt, c2, rad + 2.0, rad + 6.0);\n  float sdfc3 = sdfSquare(pnt * rot2(t * -0.81), c3, rad);\n\n  float ret;\n  bool usePadded = true;\n  usePadded = int(myTime ) / 4 % 2 == 0;\n  if (usePadded) {  \n    ret = sdfUnionPadded(sdfc1, sdfc2, pad1, pad1);\n    ret = sdfUnionPadded(ret  , sdfc3, pad1, pad1);\n  }\n  else {\n    ret = sdfUnion(sdfc1, sdfc2);\n    ret = sdfUnion(ret  , sdfc3);\n  }\n    \n  return ret;\n}\n\nvec3 background(vec2 pnt) {\n  float t = myTime * 0.221;\n\n  pnt *= 0.9;\n  pnt.y += sin(t * 1.0);\n  pnt *= rot2(t * 0.1);\n  // pnt *= mod(pnt, 0.3)* 9.1;\n  float g = sin(length(pnt) - t * 20.0) * 1.2 + 0.4;\n  float f = 0.0;\n  float r = 0.0;\n  f += sin((pnt * rot2(kDegToRad * (t *   7.0 + g))).x + t * 0.9);\n  f += sin((pnt * rot2(kDegToRad * (t * -11.0 + g))).x + t * 1.0);\n  f += sin((pnt * rot2(kDegToRad * (t * -21.0 + g))).x + t * 1.1);\n  f += sin((pnt * rot2(kDegToRad * (t *  31.0 + g))).x + t * 1.1);\n  f = f * 0.35 + 0.7;\n  f *= f * f;\n  f *= f;\n  f = f * 0.05 + 0.5;\n  vec3 ret = vec3(f);\n  // ret.x += sin(pnt.x) > 0.99 ? 0.1 : 0.0;\n  // ret.x += sin(pnt.y) > 0.99 ? 0.1 : 0.0;\n  return ret;\n}\n\n//--------------------------------------------\n\nvoid otherMain(void)\n{\n  float sceneScale = sin(myTime * 0.1) * 19.0 + 27.0;\n\n  vec2  squareUV = 2.0 * (vTexcoord - 0.5) * iResolution.xy / avg(min(iResolution.x, iResolution.y), avg(iResolution.x, iResolution.y));\n\n  vec2 pnt = squareUV * sceneScale;\n\n  float sdf = sdfScene(pnt);\n  float isdf = min(sdf * 0.3 + 0.7, 1.0);\n  vec3 bg = background(pnt);\n  vec3 itemsColor = vec3(\n    sin(myTime * 0.201) * 0.2 + 0.3,\n    sin(myTime * 0.211) * 0.2 + 0.4,\n    sin(myTime * 0.221) * 0.2 + 0.7\n  );\n  oColor.rgb = bg;\n  oColor.rgb = sdf < 0.0 ? bg * itemsColor * -sdf : bg * isdf;\n\n    \n  oColor.a = 1.0;\n}\n\n\n//---------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vTexcoord = fragCoord / iResolution.xy;\n    myTime = iTime;\n    otherMain();\n    fragColor = oColor;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldcfzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[662, 662, 691, 691, 717], [719, 719, 745, 745, 827], [829, 829, 893, 1087, 1240], [1242, 1242, 1276, 1276, 1298], [1300, 1300, 1338, 1338, 1360], [1362, 1362, 1396, 1396, 1419], [1488, 1488, 1542, 1542, 1584], [1586, 1586, 1656, 1656, 1752], [1754, 1754, 1813, 1813, 2034], [2093, 2093, 2119, 2119, 2880], [2882, 2882, 2909, 2909, 3584], [3634, 3634, 3656, 3656, 4235], [4293, 4293, 4350, 4350, 4457]], "test": "ok"}
{"id": "lddBR7", "name": "Raymarching demo", "author": "fizzgig", "description": "raymarch thing", "tags": ["raymarch"], "likes": 1, "viewed": 151, "published": "Public", "date": "1524588890", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Light {\n    vec3 position;\n    float strongth;\n    vec3 color;\n};\n\n#define PI 3.1415926\n    \nmat4 euler(float x, float y, float z) {\n    mat4 xmat = mat4(vec4(1.0,  0.0,    0.0,    0.0),\n                     vec4(0.0,  cos(x), sin(x), 0.0),\n                     vec4(0.0, -sin(x), cos(x), 0.0),\n                     vec4(0.0,  0.0,    0.0,    1.0));\n    mat4 ymat = mat4(vec4( cos(y), 0.0, sin(y), 0.0),\n                     vec4( 0.0,    1.0, 0.0,    0.0),\n                     vec4(-sin(y), 0.0, cos(y), 0.0),\n                     vec4( 0.0,    0.0, 0.0,    1.0));\n    mat4 zmat = mat4(vec4( cos(z),  sin(z), 0.0, 0.0),\n                     vec4(-sin(z),  cos(z), 0.0, 0.0),\n                     vec4( 0.0,     0.0,    1.0, 0.0),\n                     vec4( 0.0,     0.0,    0.0, 1.0));\n    \n    return xmat*ymat*zmat;\n}\n\nmat4 transform(float x, float y, float z) {\n    return mat4(vec4(1.0, 0.0, 0.0, 0.0),\n                vec4(0.0, 1.0, 0.0, 0.0),\n                vec4(0.0, 0.0, 1.0, 0.0),\n                vec4(x,   y,   z,   1.0));\n}\n\nfloat sphereSDF(vec3 center, float radius, vec3 point) {\n    return length(point - center) - radius;\n}\n\nfloat planeSDF(vec3 origin, vec3 normal, vec3 point) {\n    return dot(point - origin, normal);\n}\n\nfloat sceneSDF(vec3 point) {\n   return min(\n       min(\n           min(\n               sphereSDF(vec3(-0.7, 0.7, 0.0), 0.5, point),\n               sphereSDF(vec3(0.7, 0.7, 0.0), 0.5, point)\n           ),\n           sphereSDF(vec3(0.0), 1.0, point)\n       ),\n       planeSDF(vec3(0.0), vec3(0.0, 1.0, 0.0), point)\n     );\n}\n\nvec3 sceneSDFGradient(vec3 point, float epsilon) {\n    vec3 xe = vec3(epsilon, 0.0, 0.0)/2.0;\n    vec3 ye = vec3(0.0, epsilon, 0.0)/2.0;\n    vec3 ze = vec3(0.0, 0.0, epsilon)/2.0;\n    \n    return vec3(\n        (sceneSDF(point + xe) - sceneSDF(point - xe)) / epsilon,\n        (sceneSDF(point + ye) - sceneSDF(point - ye)) / epsilon,\n        (sceneSDF(point + ze) - sceneSDF(point - ze)) / epsilon\n      );\n}\n\nvec3 sceneSDFNormal(vec3 point) {\n    return normalize(sceneSDFGradient(point, 0.01));\n}\n\nvec3 rayPoint(Ray ray, float dist) {\n    return ray.origin + dist * ray.direction;\n}\n\nvec3 screen(vec3 a, vec3 b) {\n    return vec3(1.0) - (vec3(1.0) - a)*(vec3(1.0) - b);\n}\n\nvec3 lightPoint(Light light, vec3 point, vec3 normal, vec3 camera, vec3 diffuse, vec3 bounce, vec3 current) {\n    vec3 lightchord = light.position - point;\n    \n    vec3 lightcolor = light.color * 1.0 / pow(length(lightchord)/light.strongth+1.0, 2.0);\n    \n    vec3 colour = diffuse * lightcolor * max(dot(normal, normalize(lightchord)), 0.0);\n    colour = screen(colour, bounce * lightcolor * max(vec3(1.0) - 5.0*(vec3(1.0) - dot(normalize(lightchord), reflect(normalize(point - camera), normal))), 0.0));\n    \n    return screen(current, colour);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float lightangle = iTime;\n    \n    Light light1 = Light(vec3(2.0*cos(lightangle), 2.0, 2.0*sin(lightangle)), 10.0, vec3(1.0, 0.0, 0.0));\n    \n    lightangle += PI*2./3.;\n    \n    Light light2 = Light(vec3(2.0*cos(lightangle), 2.0, 2.0*sin(lightangle)), 10.0, vec3(0.0, 1.0, 0.0));\n    \n    lightangle += PI*2./3.;\n    \n    Light light3 = Light(vec3(2.0*cos(lightangle), 2.0, 2.0*sin(lightangle)), 10.0, vec3(0.0, 0.0, 1.0));\n    \n    float disttoscreen = 0.5;\n    \n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec3 camorigin = vec3(0.0, 0.5*sin(iTime) + 0.51, -3.0);\n    \n    mat4 camtoscene = transform(camorigin.x, camorigin.y, camorigin.z)*euler(0.0, 0.0, 0.0);\n    \n    Ray ray = Ray((camtoscene*vec4(vec3(0.0),1.0)).xyz,\n                  normalize(camtoscene*vec4(uv.x, uv.y, disttoscreen, 0.0)).xyz);\n    \n    vec3 point = camorigin;\n    \n    float scenedist = sceneSDF(point);\n    float raydist = 0.0;\n    \n    float epsilon = 0.01;\n    float end = 100.0;\n    \n    while (scenedist > epsilon) {\n        if (raydist > end) {\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n            return;\n        }\n        \n        point = rayPoint(ray, raydist);\n        \n        scenedist = sceneSDF(point);\n        \n        raydist += scenedist;\n    }\n    \n    vec3 normal = sceneSDFNormal(point);\n    vec3 diffuse = vec3(1.0);\n    vec3 bounce = vec3(1.0);\n        \n    vec3 colour = lightPoint(light1, point, normal, camorigin, diffuse, bounce, vec3(0.0));\n    colour = lightPoint(light2, point, normal, camorigin, diffuse, bounce, colour);\n    colour = lightPoint(light3, point, normal, camorigin, diffuse, bounce, colour);\n\n    // Output to screen\n    fragColor = vec4(colour,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lddBR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 193, 193, 882], [884, 884, 927, 927, 1098], [1100, 1100, 1156, 1156, 1202], [1204, 1204, 1258, 1258, 1300], [1302, 1302, 1330, 1330, 1624], [1626, 1626, 1676, 1676, 2032], [2034, 2034, 2067, 2067, 2122], [2124, 2124, 2160, 2160, 2208], [2210, 2210, 2239, 2239, 2297], [2299, 2299, 2408, 2408, 2848], [2850, 2850, 2907, 2907, 4655]], "test": "ok"}
{"id": "lddfWH", "name": "sun_or_flower", "author": "Del", "description": "Left mouse for inversion", "tags": ["sun", "triangle", "flower", "smooth"], "likes": 1, "viewed": 358, "published": "Public API", "date": "1524997238", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// smoothtri sun / flower test... - Del 29/04/18\n\n#define\tPI 3.14159\n#define\tTAU 6.28318\n\nfloat circle(vec2 pq, float radius)\n{\n    float pix = 3. / iResolution.y;\n    return smoothstep(pix, -pix, pq.y - radius);\n}\n\nfloat SmoothTri(float t, float val)\n{\n\treturn val - (val * abs(cos(t*PI)) );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy ) / iResolution.y;\n    \n    float _d = length(uv);\n    \n    vec2 pq = vec2(atan(uv.x, uv.y) / TAU, _d);\n    \n\tfloat h = pq.x - iTime * .075;\n    float nseg = 10.0;\n    float segheight = 0.35;\n    \n    float stime1 = 0.5+sin(iTime)*0.5;\n    float stime2 = 0.5+sin(iTime*0.1)*0.5;\n    \n    segheight += stime1*0.25;\n\n    float d = SmoothTri(h*nseg,segheight);\n    if (iMouse.z > 0.5)\n        d = segheight-d;\t\t\t\t\t\t\t// inverted :)\n    \n\tfloat c0 = circle(pq, .45+(stime2*0.1) + d);\n\n    vec3 sky = vec3(0.3,0.3,0.75);\n    vec3 sun = mix(vec3(1.0,1.0,0.8),vec3(0.85,0.85,0.25),_d);\n    vec3 col = mix(sky,sun,c0);\n\tfragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lddfWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 127, 127, 214], [216, 216, 253, 253, 294], [296, 296, 351, 351, 1041]], "test": "ok"}
{"id": "ldGcDK", "name": "Stars & Polygons", "author": "tayloia", "description": "A sandbox for exploring star and polygon formulas", "tags": ["stars", "polygons"], "likes": 7, "viewed": 493, "published": "Public API", "date": "1523377707", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415927;\n\nfloat smoothfill(in float a, in float b, in float epsilon)\n{\n    // A resolution-aware smooth edge for (a < b)\n    return smoothstep(0., epsilon / iResolution.y, b - a);\n}\n\nfloat disc(in vec2 uv, in float radius)\n{\n    // Function for a circular disc\n    return smoothfill(length(uv), radius, 10.);\n}\n\nfloat box(in vec2 uv, in vec2 size)\n{\n    // Function for an axis-aligned rectangle\n    // We have to do this independently for x- and y-direction to get smooth edging correct\n    vec2 t = abs(uv / size);\n    return smoothfill(t.x, 1., 10. / size.x) * smoothfill(t.y, 1., 10. / size.y);\n}\n\nfloat polygon(vec2 uv, in int sides, in float size, in float rotation)\n{\n    // Function for an N-sided regular polygon\n\tfloat repeat = PI / float(sides);\n\tfloat theta = atan(uv.x, uv.y) + rotation;\n\tfloat t = cos(repeat - mod(theta, repeat * 2.)) * length(uv) / cos(repeat);\n    return smoothfill(t, size, 10.);\n}\n\nfloat curved(vec2 uv, in int points, in float size)\n{\n    // Function for an N-pointed star approximation that produces curved edges\n\tfloat repeat = 2. * PI / float(points);\n\tfloat theta = atan(uv.x, uv.y);\n\tfloat t = cos(repeat - mod(theta, repeat) * 2.) * length(uv) / cos(repeat);\n    return smoothfill(t, size, 50.);\n}\n\nfloat straight(vec2 uv, in int points, in float size)\n{\n    // Function for an N-pointed star with straight edges\n\tfloat repeat = 2. * PI / float(points);\n    float theta = abs(mod(atan(uv.x, uv.y) + repeat * 0.5, repeat) - repeat * 0.5) - repeat;\n\tfloat t = cos(theta) * length(uv) / cos(repeat);\n    return smoothfill(t, size, 25.);\n}\n\nfloat star(vec2 uv, in int points, in float outer, in float inner, in float rotation)\n{\n    // Function for a fully-specified N-pointed star\n\tfloat repeat = PI / float(points);\n\tfloat theta = atan(uv.x, uv.y) + rotation;\n\tfloat t1 = cos(repeat - mod(theta, repeat * 2.));\n    float t2 = cos(repeat - mod(theta + repeat, repeat * 2.));\n    float t = (t1 * outer - t2 * (outer - inner)) * length(uv) / (cos(repeat) * outer - (outer - inner));\n    return smoothfill(t, outer, 25.);\n}\n\nfloat golf(vec2 uv, in float size)\n{\n    // Short function for a 5-pointed star\n\tfloat t = cos(abs(fract(atan(uv.x, uv.y) * .8 + .5) - .5) / .8 - 1.26) * length(uv) / .3;\n    return smoothfill(t, size, 33.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    const int ROWS = 3;\n    const int COLUMNS = 4;\n    const float GAP = 0.1;\n    vec2 uv = fragCoord / iResolution.y;\n    uv.x -= (iResolution.x / iResolution.y - float(COLUMNS) / float(ROWS)) * 0.5;\n    vec3 col = vec3(0.1);\n    uv = uv * (float(ROWS) + GAP) - GAP;\n    if ((uv.x >= 0.) && (uv.y >= 0.) && (uv.x < float(COLUMNS)))\n    {\n        ivec2 iuv = ivec2(uv);\n        uv = fract(uv) * (2. + GAP * 2.) - 1.;\n        if (max(abs(uv.x), abs(uv.y)) < 1.)\n        {\n\t        int panel = iuv.x + iuv.y * COLUMNS;\n            float size1 = sin(iTime + float(panel)) * 0.4 + 0.6;\n            float size2 = sin(iTime * 0.7 + float(panel)) * 0.3 + 0.7;\n            switch (panel)\n            {\n                case 0:\n                    col = vec3(1,0,0) * disc(uv, size1);\n                    break;\n                case 1:\n                    col = vec3(0,1,0) * box(uv, vec2(size1, size2));\n                    break;\n                case 2:\n                    col = vec3(1,1,0) * polygon(uv, 5, size1, 0.);\n                    break;\n                case 3:\n                    col = vec3(0,0,1) * polygon(uv, 6, size2, iTime);\n                    break;\n                case 4:\n                    col = vec3(1,0,1) * curved(uv, 5, size1);\n                    break;\n                case 5:\n                    col = vec3(0,1,1) * curved(uv, 6, size2);\n                    break;\n                case 6:\n                    col = vec3(1,0,0) * straight(uv, 5, size1);\n                    break;\n                case 7:\n                    col = vec3(0,1,0) * straight(uv, 6, size2);\n                    break;\n                case 8:\n                    col = vec3(1,1,0) * star(uv, 5, size1, size1 * 0.382, 0.);\n                    break;\n                case 9:\n                    col = vec3(0,0,1) * star(uv, 6, size2, size1, 0.);\n                    break;\n                case 10:\n                    col = vec3(1,0,1) * star(uv, 7, 0.6, size1, iTime);\n                    break;\n                case 11:\n                    col = vec3(0,1,1) * golf(uv, size1);\n                    break;\n                default:\n                \tcol = vec3(0);\n                \tbreak;\n            }\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldGcDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 89, 139, 200], [202, 202, 243, 279, 329], [331, 331, 368, 506, 619], [621, 621, 693, 740, 935], [937, 937, 990, 1069, 1259], [1261, 1261, 1316, 1374, 1597], [1599, 1599, 1686, 1739, 2079], [2081, 2081, 2117, 2160, 2290]], "test": "ok"}
{"id": "ldGczK", "name": "My first party", "author": "antonOTI", "description": "This year I attended my first Revision party (and thus, my first big demo party) \nThough I haven't subbmited anything, this is fun :D", "tags": ["2d", "revision", "noshader", "justshader"], "likes": 2, "viewed": 356, "published": "Public API", "date": "1522593740", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159 \n#define TAU (2. * PI)\n#define HPI (PI / 2.)\n\nfloat noise(vec2 p) // NO NOISE\n{\n    return fract(dot(sin(p.x * 123.12)*142.,cos(p.y *34.95)*165.47));\n}\n\nfloat revision(vec2 uv, float s)\n{\n    \n    float dist = length(uv);\n    float ang = atan(uv.y,uv.x); // NO ANGLE\n    \n    float cellSize = 7.5;\n    float ringId = floor(dist * cellSize + .065);\n    \n    ang += iTime * (mod(ringId + s, 2.)* 2. - 1.)* .1  * (ringId + 1.);\n    ang = mod(ang, TAU);\n    \n    float f = sin(dist * 44.) * .5 + .5;\n    \n\tfloat thick = noise(vec2(floor(ang * 3.) / 3. + 100. + s * 30., ringId));    \n    thick = floor(thick * 3.) / 3. + .15;\n    f = smoothstep(thick - .005,.005 + thick,f); // NO CIRCLE\n    f *= step(dist,.4);\n    f *= step(.03,dist);\n    return f;\n}\n\nvoid lineGlitch(inout vec2 uv, float force)\n{\n\n\tuv.y += force * uv.x * .05;\n    uv.x += force * sin(noise(vec2(force * 20.))*TAU) * noise(vec2(floor(uv.y * 30.) ) ) * .25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; // NO COORD\n    \n    float len = 6.;\n    float time = mod(iTime,len);\n    float seed = floor(iTime / len);\n    float glitch = pow(1. - time * 1. / len, 10.);\n    \n    \n    uv -= .5; // NO CENTER\n\tuv.x *= iResolution.x / iResolution.y;\n    uv *= .8; // NO ZOOM\n    \n    \n    lineGlitch(uv, glitch);\n    \n    float f = revision(uv, seed);\n    \n    vec3 col =vec3(f );\n    \n    fragColor = vec4(col,1.0); // JUST SHADE\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldGczK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 98, 98, 170], [172, 172, 206, 206, 767], [769, 769, 814, 814, 942], [944, 944, 1001, 1001, 1459]], "test": "error"}
{"id": "ldGyWy", "name": "Temp1caustic", "author": "dpiponi", "description": "Caustic rendering hoplelessly undersampled. But it looks cool.", "tags": ["pretty"], "likes": 8, "viewed": 217, "published": "Public", "date": "1523121378", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat hypot(vec2 p) {\n    return sqrt(p.x*p.x+p.y*p.y);\n}\n\nfloat pi = 3.1415926;\n\nfloat cross2(vec2 u, vec2 v) {\n    return u.x*v.y-u.y*v.x;\n}\n\nvec2 path(float t) {\n    float theta = 2.0*pi*(t-0.5);\n    float alpha = 0.2*iTime;\n    mat2 m = mat2(cos(alpha), -sin(alpha), sin(alpha), cos(alpha));\n\n    vec2 xy = vec2(0.75*cos(theta), sin(theta));\n    //vec2 xy = vec2(theta, 1.5*theta*theta-1.0);\n    //return vec2(-theta*theta, theta);\n    //return vec2(-cos(theta), sin(theta));\n    //vec2 xy = vec2(-cos(theta)*cos(theta)*cos(theta), sin(theta)*sin(theta)*sin(theta));\n\n    return 1.0*m*xy;\n}\n\n// float l(vec2 xy, float theta) {\n//     return -path(theta).x+hypot(xy-path(theta));\n// }\n\nfloat gain = 0.70;\n//float wavelength = 0.03;\n\nfloat integrate(vec2 xy) {\n    float tx = 0.0;\n    float ty = 0.0;\n    int n = 2000;\n    vec2 last_p = path(0.0);\n\n    float wavelength = 0.02+0.02*iMouse.x/iResolution.x;\n\n    for (int i = 0; i < 100; ++i) {\n        float t = float(i)/float(100);\n        vec2 p = path(t);\n        float d = hypot(xy-p);\n\n        float dt = p.y-last_p.y;\n\n        if (dt < 0.0 && cross2(p-last_p, xy-p) > 0.0) {\n            float path_length = d-p.x;\n            float s = 2.0*pi/wavelength*path_length;\n            tx += cos(s)*dt/d;\n            ty += sin(s)*dt/d;\n        }\n\n//        path_length = d+p.x;\n//        s = -2.0*pi/wavelength*path_length;\n//        tx += cos(s)*dt/d;\n//        ty += sin(s)*dt/d;\n\n        last_p = p;\n    }\n    return hypot(vec2(tx, ty));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = vec2(0.5*iResolution.x, 0.5*iResolution.y);\n    vec2 uv = fragCoord.xy-center;\n    uv = 2.0*uv/iResolution.y;\n    float c = gain*integrate(uv);\n    fragColor = vec4(1.2*sqrt(c), c, 0.5*c, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldGyWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 58], [83, 83, 113, 113, 143], [145, 145, 165, 165, 595], [737, 737, 763, 763, 1493], [1495, 1495, 1550, 1550, 1764]], "test": "ok"}
{"id": "ldKcWy", "name": "Weird cityline ", "author": "dathor", "description": "A weird cityline with a palmtree.", "tags": ["noise", "simple", "clouds", "fbm", "flare"], "likes": 8, "viewed": 312, "published": "Public", "date": "1523272891", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p ) {\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n    \n    return f/0.9375;\n}\n\n\nvec3 clouds(vec2 st){\n\t\n\t\n\tvec3 color = vec3(0);\n\t\n\tvec2 q = vec2(0.);\n\tq.x = fbm( st + 0.00*iTime);\n\tq.y = fbm( st + vec2(1.0));\n\t\n\tvec2 r = vec2(0.);\n\tr.x = fbm( st + 1.0*q + vec2(1.7,9.2)+ 0.25*iTime );\n\tr.y = fbm( st + 1.0*q + vec2(8.3,2.8)+ 0.126*iTime);\n\t\n\tfloat f = fbm(st+r);\n\t\n\tcolor = mix(vec3(0.101961,0.619608,0.666667),\n\t\tvec3(0.666667,0.666667,0.498039),\n\t\tclamp((f*f)*4.0,0.0,1.0));\n\t\n\tcolor = mix(color,\n\t\tvec3(0,0,0.164706),\n\t\tclamp(length(q),0.0,1.0));\n\t\n\tcolor = mix(color,\n\t\tvec3(0.666667,1,1),\n\t\tclamp(length(r.x),0.0,1.0));\n\t\n\treturn color;\n}\n\nvec3 postprocess(vec2 uv,vec3 col){\n    \n\tcol.gb *=  uv.y * .6; \n\tcol.g = 0.0+0.6*smoothstep(-0.1,0.9,col.g*2.0);\n\tcol = 0.001+pow(col, vec3(1.2))*1.5;\n\t//col = clamp(1.06*col-0.03, 0., 1.);   \n    col *= mod(gl_FragCoord.y, 4.0)<2.0 ? 0.6 : 1.0;\n\n\treturn col;\n}\nfloat sun(float x,float y,float t){\n   float xx  =x+1.25;\n   float yy = y-0.5;\n   return 0.5/sqrt(xx*xx+yy*yy);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tvec2 p = -1.0 + 2.0*uv;\n    \n\tp.x *= iResolution.x / iResolution.y;\n\t\n\tif (uv.y < .12 || uv.y >= .88) {\n\t\tfragColor=vec4(0.,0.,0.,1.);\n\t\treturn;\n\t}\n\t\n\tvec3 color =  vec3(0);\n\t\t color = clouds(p);\t\n\t\n\tvec3 sundot = vec3(2.0,2.0,1.2)*(sun(p.x,p.y,iTime)/10.0);\n\t\n    p.x += 1.5;\n\tfloat r = 0.2 + 0.1*cos( atan(p.y,p.x)*10.0 + 30.0*p.x + 1.5 * sin(iTime));\n\tcolor *= smoothstep( r, r+0.01, length( p ) );\n\tr = 0.015;\n\tr += 0.002*sin(120.0*uv.y);\n\tr += exp(-20.0*uv.y);\n \tcolor *= 1.0 - (1.0-smoothstep(r,r+0.002, abs(p.x-0.25*sin(2.0*p.y))))*(1.0-smoothstep(0.0,0.1,p.y));\n\t\n\tcolor = postprocess(p,sundot + color);\n\t\n\t\n\tvec4 final = vec4( color, 1.0 ) ;\n\t\t\n   \tif(-p.y< hash(ceil(p.x*20.))*.5) final-=final*p.y; \n    \n\tfragColor = final ;\n\n}\n\n\n\n\n\n\n\n\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldKcWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 66], [68, 68, 94, 94, 313], [365, 365, 386, 386, 590], [593, 593, 614, 614, 1157], [1159, 1159, 1194, 1194, 1421], [1422, 1422, 1457, 1457, 1535], [1538, 1538, 1595, 1595, 2382]], "test": "ok"}
{"id": "ldKczK", "name": "paques18", "author": "jmaire", "description": "box en rotation", "tags": ["3d", "rotate", "quaternion", "rotation"], "likes": 0, "viewed": 90, "published": "Public", "date": "1522744427", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//paques2018 de jmaire\n\n\n /*\n    Tutorial used and credit: https://www.shadertoy.com/view/lt33z7\n    tutorial used and credit:http://jamie-wong.com */\n\n\nconst int MAX_MARCHING_STEPS = 255; \nconst float MIN_DIST = 0.0; \nconst float MAX_DIST = 100.0; \nconst float EPSILON = 0.0001; \nconst float PI = 3.14159; \nconst float sq2 = cos(PI/4.0); \n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat boxSDF(vec3 p, vec3 b ) {\n    return length(max(abs(p) - b, 0.0)); \n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat pMod(float t, float d) {\n    return mod(t + d/2.0, d) - d/2.0; \n}\n\nvec3 qrotate(vec3 axe, float angl, vec3 v) {\n    float a = angl/2.0; \n    vec3 axens = normalize(axe) * sin(a); \n    return v + 2.0 * cross(cross(v, axens) - v * cos(a), axens); \n}\n\n\nfloat bras(float an, vec3 pos, vec3 p) {\n vec3  p1 = qrotate(vec3(0., 1., 0.), an + PI/4.0, p); \n p1 = p1 + vec3(sq2, 0., 0.); \n vec3 p2 = qrotate(vec3(0.0, 0.0, 1.0), iTime, p1); \n float boo = boxSDF(p2, vec3(0.1, 0.1, 2.0)); \n vec3 p3 = qrotate(vec3(0.0, 1.0, 0.0),  - PI/4.0, p2); \n p3 = p3 + vec3(0.25, 0., 0.25); \n float bo1 = boxSDF(p3, vec3(0.25, 0.1, 0.25)); \nreturn min(boo, bo1); \n}\n\n\n\nfloat sceneSDF(vec3 p) {\n float  s0 = bras(0.0, vec3(-1.0, 0.0, -1.0), p); \n float  s1 = bras(PI/2.0, vec3(-1., 0.0, -1.0), p); \n float  s2 = bras(PI, vec3(-1., 0., -1.), p); \n float  s3 = bras(3.0 * PI/2.0, vec3(-1., 0., -1.), p); \t\nreturn min(s3, min(s2, min(s1, s0))); \n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)), \n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)), \n        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    )); \n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phoneContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                            vec3 lightPos, vec3 lightIntensity)\n{ \n    vec3 N = estimateNormal(p); // Estimate normal of surface\n    vec3 L = normalize(lightPos - p); // Point from point on surface to light\n    vec3 V = normalize(eye - p); // Viewing vector, used to diffuse reflected light\n    vec3 R = normalize(reflect(-L, N)); // Reflect light to the normal\n\n    float dotLN = dot(L,N); // cosine angle between light direction and normal direction\n    float dotRV = dot(R,V); // cosine angle between reflection direction and viewing direction\n    \n    // Light is coming from behind the normal of the face, pitch black\n    if (dotLN < 0.)\n    {\n        return vec3(0.0);\n    }\n    // Reflected light points away from the camera, so there are no direct light. Only ambient light and diffuse color\n    if (dotRV < 0.)\n    {\n        // This value maxes when dotLN = 1, which is when L(light) and N(normal) are equal. 100% of the light is reflected back\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n    }\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 globalAmbentLight = 0.9 * vec3(1.);\n    vec3 color = globalAmbentLight * k_a; // Multiply brightness by color to get ambient color\n\n    // Light 1\n    vec3 light1Pos = vec3(0.,1.,3.);\n    vec3 light1Insentity = vec3(0, 67.1/100., 43.5/100.);\n    color += phoneContribForLight(k_d, k_s, alpha, p, eye, light1Pos, light1Insentity);\n\n\n    // Light 2\n    vec3 light2Pos = vec3(-1.,-1.,1.);\n    vec3 light2Insentity = vec3(100./100., 59.2/100., 0);\n    color += phoneContribForLight(k_d, k_s, alpha, p, eye, light2Pos, light2Insentity);\n\n    // Light 3\n    vec3 light3Pos = vec3(-0.5,2,-3.);\n    vec3 light3Insentity = vec3(4.7/100., 35.3/100., 65.1/100.);\n    color += phoneContribForLight(k_d, k_s, alpha, p, eye, light3Pos, light3Insentity);\n\n    return color;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\n\n\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end)\n{\n    // Start depth\n    float depth = start;\n    // Keep looking for where the marching ray hits a surface\n    for (int i = 0; i < MAX_MARCHING_STEPS; ++i)\n    {\n        // Get the distance from marching ray point to surface of box\n        float dist = sceneSDF(eye + marchingDirection * depth);\n        // If we've hit near the surface, return this distance\n        if (dist < EPSILON) {\n            return depth; \n        }\n        // Didn't find anything, let's go to where we found something\n        depth   = depth + dist; \n      // We're at the end, stop\n        if (depth > end)\n        {\n            return end;\n        }\n    }\n    // Ran out of steps before we hit the end, just return end\n    return end;\n}\n\n/**\n    fov:         Field of View of camera\n    screen_size: Screen size\n   fragCoord:   Screen coord of pixel\n    return:      Direction of rendering ray of the projection camera\n */\n\n\n\nvec3 rayDirection(float fov, vec2 screen_size, vec2 fragCoord)\n{\n\tvec2 xy = fragCoord - screen_size / 2.0;\n    float z = (screen_size.y / 2.) / tan(radians(fov) / 2.);\n    return normalize(vec3(xy,-z));\n}\n\n\n\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 lookAtMatrix(vec3 eye, vec3 center, vec3 up) \n{\n    // Based on gluLookAt man page\n    // Forward/Look at vector\n    vec3 f = normalize(center - eye);\n    // Right vector\n    vec3 v = normalize(cross(f, up));\n    // Camera local up Vector\n    vec3 u = cross(v, f);\n    return mat3(\n        vec3(v),\n        vec3(u),\n        vec3(-f)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 camera_space_dir = rayDirection(30., iResolution.xy, fragCoord.xy);\n    vec3 eye = \n        vec3(\n            6.*cos(iTime) +2.,\n            6.*cos(iTime*0.5) +2.,\n            6.*sin(iTime)+2. \n            );\n\n   vec3 world_space_dir = lookAtMatrix(eye, vec3(0.), vec3(0,1,0)) * camera_space_dir;\n    // Find shortest distance surface\n    float dist = shortestDistanceToSurface(\n        eye,\n        world_space_dir, \n        MIN_DIST, \n        MAX_DIST);\n    if (dist > MAX_DIST - EPSILON)\n    {\n        fragColor = vec4(0.07);\n        return;\n    }\n\n    // We've hit a surface\n    // Phong shading time!!\n    // Surface point\n    vec3 p = eye + dist * world_space_dir; \n\n    vec3 K_ambientColor = vec3(0.2, 0.2, 0.0); \n    vec3 K_diffuseColor = vec3(0.7, 1.0, 1.0); \n    vec3 K_specularColor = vec3(1.0, 0.5, 1.0); \n    float shineness = 100.0; \n\n    vec3 color = phongIllumination(K_ambientColor, K_diffuseColor, K_specularColor, shineness, p, eye); \n    fragColor = vec4(color, 1.); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldKczK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[341, 430, 461, 461, 505], [748, 748, 778, 778, 819], [821, 821, 865, 865, 1001], [1004, 1004, 1044, 1044, 1396], [1400, 1400, 1424, 1424, 1674], [1676, 1676, 1705, 1705, 2017], [2019, 2511, 2653, 2653, 3669], [3671, 4041, 4126, 4126, 4902], [5328, 5328, 5419, 5438, 6135], [6325, 6325, 6389, 6389, 6529], [6534, 6861, 6913, 6978, 7207], [7209, 7209, 7265, 7265, 8261]], "test": "error"}
{"id": "ldKyDt", "name": "2D Adventures #3 - Better Hex", "author": "bombshell93", "description": "The purpose behind this shader was a cleaner hex pattern than my previous attempt and I figured while I was at it a truchet pattern, overall I'm happy with this shader, its looking cleaner than my previous and the result is certainly more interesting.", "tags": ["2d"], "likes": 6, "viewed": 954, "published": "Public", "date": "1523989940", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//// ABSTRACT\n//\n//\tThe purpose behind this shader was a cleaner hex pattern than my previous\n//\tattempt and I figured while I was at it a truchet pattern, through some trial\n//\tand error and a bit of intuition I managed to find a way to get coordinates\n//\tfor the lines which seemed to flow from one tile to the other.\n//\n//\tOverall I'm happy with this shader, its looking cleaner than my previous\n//\tand the result is certainly more interesting, \n//\n//// AUTHOR\n//\n//\tScott R Howell (Bombshell93)\n\n\n#define SCALE .25\n\n// hex axes\n\nconst vec2 X = vec2(1., 0.);\nconst vec2 Y = vec2(.5, .866);\nconst vec2 Z = vec2(-.5, .866);\n\n// handy dandy pi bros\n\nconst float pi = 3.14;\nconst float pi2 = 6.28;\n\n// used when finding hex coordinates and hex corners\n\nconst float sqrt3 = sqrt(3.);\nconst float sqrtc = sqrt3 / 3. * .5;\n\n//// axial\n//\n//\tfinds axial coordniates via dot products of\taxis vectors, effectively the\n//\tmatrix multiplication I was using before albeit minimalized, based on the\n//\t\"branchless method\" found here:\n//\t\thttps://www.redblobgames.com/grids/hexagons/more-pixel-to-hex.html\n\nvec2 axial(vec2 p) {\n    \n    float y3 = p.y * sqrt3;\n    return floor((\n        floor(vec2(p.x * 2., y3 - p.x) + 1.)\n        + (y3 + 1. + p.x)) / 3.);\n}\n\n//// pixel\n//\n//\tfinds pixel coordinates via axial coordinates\n\nvec2 pixel(vec2 a) {\n    \n    return vec2(a.x - a.y * .5, a.y * sqrt3 * .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    \n    vec2 uv = iTime * .33 + fragCoord / iResolution.y / SCALE;\n    \n    // get axial coordinates\n    \n    vec2 a = axial(uv);\n    \n    // find pixel coordinates of hex tile and distance from center\n    \n    vec2 h = pixel(a);\n    vec2 d = uv - h;\n    float da =  atan(d.y, d.x);\n    d = abs(vec2(dot(d, X), dot(d, Y)));\n    \n    // find arbitrary index and use it to decide whether to use fipped corners\n    \n    float i = mod(mod(h.x, 3.) - mod(h.y * 2., 16.), 3.);\n    float flip = step(1.5, i) * 2. - 1.;\n    \n    //find distance to corners\n    \n    vec2 dta = (pixel(a) + (X + Y) * flip / 3.) - uv\n    \t, dtb = (pixel(a) - (Y + Z) * flip / 3.) - uv\n    \t, dtc = (pixel(a) - (X - Z) * flip / 3.) - uv;\n    float lta = dot(dta, dta)\n        , ltb = dot(dtb, dtb)\n        , ltc = dot(dtc, dtc);\n    \n    // find distance from nearest tile corner and mask the truchet pattern line\n    \n    float len = sqrt(min(lta, min(ltb, ltc)));\n    float m = 1.;\n    m *= step(0., len - sqrtc + .1) \n        - step(0., len - sqrtc - .1);\n    \n    // find the angle of the truchet pattern line\n    \n    vec2 dt = lta < ltb ? (lta < ltc ? dta : dtc) : (ltb < ltc ? dtb : dtc);\n    vec3 pcol = vec3(1., mod(flip * atan(dt.x, dt.y) + iTime, pi / 3.), 0.);\n    \n    // find cube-like color and mix it with the truchet pattern respecting its mask\n    \n    float bgl = floor(mod(da - .52359, pi2) / (pi2 / 3.)) * .5;\n    vec3 col = mix(vec3(0., 0., 1.) * (1. - bgl) + vec3(1.) * bgl, pcol, m);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldKyDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1096, 1096, 1116, 1116, 1249], [1315, 1315, 1335, 1335, 1393], [1395, 1395, 1452, 1452, 2976]], "test": "error"}
{"id": "ldKyDy", "name": "first shader I guess", "author": "siapran", "description": "a circle rotating around a light source", "tags": ["shadow"], "likes": 2, "viewed": 93, "published": "Public", "date": "1523277787", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define LIGHT_RADIUS 0.7\n#define SHAPE_RADIUS 0.1\n#define PI 3.1415\n\n\n\nfloat circle(in vec2 _st, in float _radius){\n    float dist = distance(_st, vec2(0.0));\n\treturn 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dist);\n}\n\n\nbool seg_cir(in vec2 A, in vec2 B, in vec2 C, in float r) {\n\tvec2 d = B - A;\n    vec2 f = A - C;\n    \n    float a = dot(d, d);\n\tfloat b = 2.0 * dot(f, d);\n\tfloat c = dot(f, f) - r * r;\n\n\tfloat discriminant = b * b - 4.0 * a * c;\n    if( discriminant < 0.0 ) {\n\t\treturn false;\n\t} else {\n\t\tdiscriminant = sqrt( discriminant );\n\t\n\t\tfloat t1 = (-b - discriminant)/(2.0*a);\n\t\tfloat t2 = (-b + discriminant)/(2.0*a);\n\t\t\n        if( t1 >= 0.0 && t1 <= 1.0 ) {\n\t\t    return true ;\n        }\n\t\t\n        if( t2 >= 0.0 && t2 <= 1.0 ) {\n    \t\treturn true ;\n\t\t}\n        \n\t\treturn false ;\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/min(iResolution.x,iResolution.y);\n    vec2 mouse = iMouse.xy/min(iResolution.x,iResolution.y);\n    \n    vec3 col = vec3(0.0);\n\n    // grid\n    //vec2 grid = uv * 10.0;\n    //if (fract(grid.x) < 0.05 || fract(grid.y) < 0.05) col += 1.0;\n    \n    vec2 circle_pos = vec2(cos(iTime),sin(iTime)) * 0.25 + 0.5;\n    //vec2 circle_pos = vec2(0.5);\n    \n    // circle shape, casts shadow\n    col += circle(uv - circle_pos, SHAPE_RADIUS);\n    col -= circle(uv - circle_pos, SHAPE_RADIUS * 0.9);\n    \n    // mouse is a light source\n    col += circle(uv - mouse, 0.0005);\n    \n    // ray casting\n    vec2 ray = uv;\n    \n    float dist = distance(ray, mouse);\n    if (dist < LIGHT_RADIUS) {\n        if (!seg_cir(ray, mouse, circle_pos, SHAPE_RADIUS)) {\n            col += 1.0 - smoothstep(0.0, 1.0, dist / LIGHT_RADIUS);\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldKyDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 115, 115, 287], [290, 290, 349, 349, 869], [871, 871, 928, 928, 1838]], "test": "ok"}
{"id": "ldKyWc", "name": "Terrain Traveler", "author": "MonterMan", "description": "a terrain raymarcher with some stuff", "tags": ["terrain"], "likes": 9, "viewed": 295, "published": "Public", "date": "1523602305", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//NOTE(chen): here are the defines u can tweak\n\n//change the below define if you don't want to see cool glitch\n#define SHOW_GLITCH 1\n\nfloat hash(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(73211.171, 841.13))) * 32131.18128);\n}\n\nfloat noise(vec2 uv)\n{\n    vec2 ipos = floor(uv);\n    vec2 fpos = fract(uv);\n    \n    float a = hash(ipos);\n    float b = hash(ipos + vec2(1, 0));\n    float c = hash(ipos + vec2(0, 1));\n    float d = hash(ipos + vec2(1, 1));\n    \n    vec2 t = smoothstep(0.0, 1.0, fpos);\n    \n    return mix(mix(a, b, t.x), mix(c, d, t.x), t.y);\n}\n\nfloat fbm(vec2 uv)\n{\n    float acc = 0.0;\n    float amp = 0.5;\n    float freq = 1.0;\n    for (int i = 0; i < 6; ++i)\n    {\n        acc += amp * noise(freq * uv);\n        freq *= 2.0;\n        amp *= 0.5;\n    }\n    return acc;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, in float t_max, out bool hit)\n{\n    hit = false;\n    float t = 0.1;\n    \n    for (int i = 0; i < 256; ++i)\n    {\n        vec3 p = ro + t*rd;\n        float h = p.y - fbm(p.xz);\n        if (h < 0.004*t || t > t_max)\n        {\n#if !SHOW_GLITCH\n            if (t <= t_max)\n            {\n#endif\n            \thit = true;\n#if !SHOW_GLITCH  \n            }\n#endif\n            break;\n        }\n\n        \n        t += 0.45 * h;\n    }\n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 1.0, 0.0);\n    vec3 at = vec3(0.0, 0.2, 4.0);\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0, 1, 0), cam_z));\n    vec3 cam_y = normalize(cross(cam_z, cam_x));\n    vec3 rd = cam_x * uv.x + cam_y * uv.y + 2.0 * cam_z;\n    \n    ro += vec3(0.0, 0.8, mod(10.0*iTime, 1000.0));\n    vec3 l = normalize(vec3(0.5, -0.5, 0.5));\n    \n    bool hit;\n    float t_max = 27.5;\n    float t = intersect(ro, rd, t_max, hit);\n    \n    vec3 p = ro + t*rd;\n    \n    //NOTE(chen): a hack, note dpdx and dpdz are not actual partial derivatives, just some offseted vector\n    vec3 px = vec3(p.x + 0.0001, 0.0, p.z);\n    vec3 pz = vec3(p.x, 0.0, p.z + 0.0001);\n    vec3 dpdx = vec3(px.x, fbm(px.xz), px.z);\n    vec3 dpdz = vec3(pz.x, fbm(pz.xz), pz.z);\n    \n    vec3 normal = normalize(cross(dpdz, dpdx));\n    \n    vec3 background = vec3(0.8, 0.8, 0.5);\n    vec3 col = background;\n    if (hit)\n    {\n        float occ = p.y;\n        float dl = 0.25 * pow(dot(normal, -l) + 1.0, 2.0);\n        float lighting = 0.9 * dl + 0.3;\n        vec3 mat = vec3(0.8, 0.3, 0.0);\n        \n        col = mix(occ * lighting * mat, background, pow(t / t_max, 1.5));\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldKyWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 155, 155, 228], [230, 230, 252, 252, 560], [562, 562, 582, 582, 788], [1270, 1270, 1325, 1325, 2616]], "test": "ok"}
{"id": "ldKyWV", "name": "Visualizer #1", "author": "cwrawls", "description": "A visualizer of raymarched spheres. Inspired by https://www.shadertoy.com/view/Ms3SWr", "tags": ["raymarching", "sound", "sphere"], "likes": 1, "viewed": 4254, "published": "Public API", "date": "1523563231", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nInspired by Sound Blob : https://www.shadertoy.com/view/Ms3SWr\n*/\n//rotation & color\n#define TWOPI 6.28318530718\n#define PI \t3.14159265\n#define SPEED 0.05\n\n//ray marching\n#define MAX_STEPS 32.0\n#define EPSILON 0.002\n#define MIN_STEP_SIZE 0.001\n#define MIN_DISTANCE 0.0\n\n//modify to change number of spheres\n#define NumSpheres 6\n//modify to change spread of spheres\n#define MAX_ORBIT_DIST 1.0\n\n#define CAMZ -2.0\n\n\nvec3 getColor(float amt) {\n\tfloat colDeg = amt * TWOPI;\n    float x = 1.0 - abs(mod(colDeg/radians(60.0), 2.0) -1.0);\n    if(colDeg < radians(60.00)){return vec3(1.0,\tx, \t\t0.0);}\n    if(colDeg < radians(120.0)){return vec3(x,\t\t1.0, \t0.0);}\n    if(colDeg < radians(180.0)){return vec3(0.0, \t1.0, \tx);}\n    if(colDeg < radians(240.0)){return vec3(0.0, \tx, \t\t1.0);}\n    if(colDeg < radians(300.0)){return vec3(x, \t\t0.0, \t1.0);}\n    return vec3(1.0, 0.0, x);\n}\n\nmat2 rotate(float deg) {return mat2(cos(deg), sin(deg), -sin(deg), cos(deg));}\n\n//rotate about y-axis\nvec3 getRay(vec3 rayDir, float rot) {\n\trayDir = normalize(rayDir);\n    float cosVal = cos(rot);\n    float sinVal = sin(rot);    \n    return vec3((rayDir.x * cosVal) + (rayDir.z * sinVal), rayDir.y, (rayDir.z * cosVal) - (rayDir.x * sinVal));\n}\n\nfloat sdfSphere(vec3 center, vec3 pos, float rad) {\n\tfloat dist = length(center - pos) - rad;\n    \n    return dist;\n}\n\nfloat smin(float dist0, float dist1, float scaleFactor) {\n\tfloat mixVal = clamp(0.5 + 0.5 * (dist1 - dist0) / scaleFactor, 0.0, 1.0);\n    return mix(dist1, dist0, mixVal) - scaleFactor * mixVal * (1.0 - mixVal);\n}\n\nvec2 map(in vec3 pos, out float rad) {\n\n    \n    float minDist = 10000000.0;\n    float xStep = MAX_ORBIT_DIST / float(NumSpheres);\n    float maxRadius = (xStep * 2.0 / 2.0);\n    float zPos = 3.0;\n    float yPos = 0.0;\n    \n    float distFromCenter = length(pos.xy);\n    \n    //if(distFromCenter > MAX_ORBIT_DIST + maxRadius) {distFromCenter = MAX_ORBIT_DIST;}\n    \n    float sphereNum = distFromCenter / xStep;\n    \n    //optimizations, no loops, only calculate nearest 2 spheres\n    //distinct orbits should keep there from ever being 3 all in mutual contact\n    \n    //get the closest two spheres by radius from origin\n    float sphere0 = floor(sphereNum);\n    if(sphere0 > float(NumSpheres) ) {sphere0 = float(NumSpheres);}\n    float sphere1 = ceil(sphereNum);\n    if(sphere1 > float(NumSpheres) ) {sphere1 = float(NumSpheres);}\n    \n    //get relevant info about each sphere\n    float rotDir0 = mod(sphere0, 2.0);\n    float rotDeg0 = fract( (sphere0 + 1.0) * SPEED * iTime) * TWOPI;\n    mat2  rotAmt0 = rotate(rotDeg0);\n\tfloat sampX0  = sphere0 / float(NumSpheres);\n    float amp0    = texture(iChannel0, vec2(sampX0, 0.25)).x;\n    float xDist0   = sphere0 * xStep + 0.01;\n    if(rotDir0 == 1.0) {xDist0 = -xDist0;}\n    vec3 spherePos0 = vec3(vec2(0. + xDist0, yPos) * rotAmt0, zPos);\n    float rad0  = amp0 * pow(1.01,sphere0)* maxRadius + 0.01;\n    float dist0 = sdfSphere(spherePos0, pos, rad0);\n    \n    float rotDir1 = mod(sphere1, 2.0);\n    float rotDeg1 = fract( (sphere1 + 1.0) * SPEED * iTime) * TWOPI;\n    mat2  rotAmt1 = rotate(rotDeg1);\n\tfloat sampX1  = sphere1 / float(NumSpheres);\n    float amp1    = texture(iChannel0, vec2(sampX1, 0.25)).x;\n    float xDist1  = sphere1 * xStep + 0.01;\n    if(rotDir1 == 1.0) {xDist1 = -xDist1;}\n    vec3 spherePos1 = vec3(vec2(0. + xDist1, yPos) * rotAmt1, zPos);\n    float rad1 =  amp1 * pow(1.01,sphere1)* maxRadius + 0.01;\n    float dist1 = sdfSphere(spherePos1, pos, rad1);\n    \n    rad = rad0 / maxRadius;\n    \n    minDist = smin(minDist, dist0, 0.04);\n    \n    if(dist1 < minDist) {rad = rad1 / maxRadius;}\n    minDist = smin(minDist, dist1, 0.04);\n    \n    \n    /*\n    for(int i = 0; i < NumSpheres; i++) {\n        float rotDir = mod(float(i), 2.0);\n        float rotDeg =fract( (float(i) + 1.0) * SPEED * iTime) * TWOPI;\n        //rotDeg = rotDeg + (TWOPI / float(NumSpheres));\n        //if(rotDir == 1.0) {rotDeg = -rotDeg;}\n        mat2 rotAmt = rotate(rotDeg);\n        float xDist = float(i) * xStep + 0.01;\n        if(rotDir == 1.0) {xDist = -xDist;}\n        vec3 spherePos = vec3(vec2(0. + xDist, yPos) * rotAmt, zPos);\n\t\tfloat sampX = float(i) / float(NumSpheres);\n        float amp = texture(iChannel0, vec2(sampX, 0.25)).x;\n        float dist = sdfSphere(spherePos, pos, amp * pow(1.01,float(i))* maxRadius + 0.01);\n        if(dist < minDist) { rad = (amp * pow(1.01,float(i))* maxRadius + 0.01) / maxRadius;}\n        minDist = smin(minDist, dist, 0.04);\n    }\n    */\n    return vec2(1.0, minDist);\n}\n \nvec3 getNormal(vec3 pos, float epsilon) {\n    float rad = 0.0;\n\tvec3 e = vec3(epsilon, 0.0, 0.0);\n    vec3 normal = vec3(map(pos + e.xyy, rad).y - map(pos - e.xyy,rad).y,\n                       map(pos + e.yxy,rad).y - map(pos - e.yxy,rad).y,\n                       map(pos + e.yyx,rad).y - map(pos - e.yyx,rad).y);\n    return normalize(normal);\n}\n                       \nvec3 marchIt(vec3 origin, vec3 dir) {\n\n    float rad = 0.0;\n    float traveled = 0.0;\n    for(float i = 0.0; i < MAX_STEPS; i += 1.0) {\n        vec3 pos = origin + (dir * traveled);\n        vec2 result = map(pos, rad);\n        \n        if(traveled > MIN_DISTANCE && result.y < EPSILON) {\n\t\t\treturn vec3(traveled, i / MAX_STEPS, rad);\n        }\n        \n        traveled += max(MIN_STEP_SIZE, result.y);\n    }\n    \n    return vec3(0.0,1.0,0.0);\n}\n    \n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xx) -vec2( 0.5,0.5*iResolution.y/iResolution.x);\n\n    vec3 camPos = vec3(0.0, 0.0, CAMZ);\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n       \n    vec3 result = marchIt(camPos, rayDir);\n    \n    vec3 col = vec3(0.0);\n    \n    if(result.x > 0.0) {\n        \n        vec3 surfPos = camPos + (rayDir * result.x);\n        vec3 normal = getNormal(surfPos, 0.001);\n        vec3 light = normalize(vec3(-1.0, 1.0, -0.5));\n        vec3 reflection = reflect(rayDir, normal);\n        float diffuse = dot(normal, light);\n        float specular = pow(clamp(dot(reflection, light), 0.0, 1.0), 20.0);\n        \n        col += vec3(specular * diffuse) * vec3(1.) + vec3(diffuse*0.4+0.6)* getColor(result.z);//vec3(0.9,0.5-(result.y)*0.5,(1.0/result.x)*0.1);\n    }\n                               \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "ld2XWw", "previewfilepath": "https://soundcloud.com/illeniumofficial/kaskade-disarm-you-illenium-remix-1", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/illeniumofficial/kaskade-disarm-you-illenium-remix-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldKyWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[416, 416, 442, 442, 872], [874, 874, 898, 898, 952], [954, 976, 1013, 1013, 1219], [1221, 1221, 1272, 1272, 1338], [1340, 1340, 1397, 1397, 1553], [1555, 1555, 1593, 1593, 4524], [4527, 4527, 4568, 4568, 4874], [4899, 4899, 4936, 4936, 5344], [5355, 5355, 5412, 5412, 6376]], "test": "error"}
{"id": "ldVcDc", "name": "Menger Ring", "author": "dr2", "description": "Fractal space station (some mouseability, optional antialiasing)", "tags": ["fractal", "space"], "likes": 10, "viewed": 521, "published": "Public API", "date": "1523624537", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Menger Ring\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1   // optional antialiasing (0/1 - off/on)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nfloat tCur, dstFar;\nconst float pi = 3.14159;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 b;\n  float r, a;\n  const float nIt = 5., sclFac = 2.4;\n  b = (sclFac - 1.) * vec3 (1., 1.125, 0.625);\n  r = length (p.xz);\n  a = (r > 0.) ? atan (p.z, - p.x) / (2. * pi) : 0.;\n  p.x = mod (16. * a + 1., 2.) - 1.;\n  p.z = r - 32. / (2. * pi);\n  for (float n = 0.; n < nIt; n ++) {\n    p = abs (p);\n    p.xy = (p.x > p.y) ? p.xy : p.yx;\n    p.xz = (p.x > p.z) ? p.xz : p.zx;\n    p.yz = (p.y > p.z) ? p.yz : p.zy;\n    p = sclFac * p - b;\n    p.z += b.z * step (p.z, -0.5 * b.z);\n  }\n  return PrBoxDf (p, vec3 (1.)) / pow (sclFac, nIt);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 24; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += min (0.05, 3. * h);\n    if (sh < 0.001) break;\n  }\n  return 0.3 + 0.7 * sh;\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = 0; j < 8; j ++) {\n    d = 0.1 + float (j) / 16.;\n    ao += max (0., d - 3. * ObjDf (ro + d * rd));\n  }\n  return 0.5 + 0.5 * clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 ltPos[4], ltDir, col, vn, rds;\n  float dstObj, dfTot, spTot, at, ao, sh, ul;\n  for (int k = 0; k < 4; k ++) {\n    ul = (k < 2) ? 1. : - 1.;\n    ltPos[k] = vec3 (0., 20. * ul, 20.);\n    ltPos[k].xz = Rot2D (ltPos[k].xz, float (k) * pi + 0.1 * ul * pi * tCur);\n  }\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vn = VaryNf (256. * ro, vn, 1.);\n    dfTot = 0.;\n    spTot = 0.;\n    for (int k = 0; k < 4; k ++) {\n      ltDir = normalize (ltPos[k]);\n      at = smoothstep (0., 0.3, dot (normalize (ltPos[k] - ro), ltDir));\n      sh = ObjSShadow (ro, ltDir);\n      dfTot = max (dfTot, at * sh * max (dot (vn, ltDir), 0.));\n      spTot = max (spTot, at * smoothstep (0.5, 0.8, sh) *\n         pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.));\n    }\n    ao = ObjAO (ro, vn);\n    col = ao * (vec3 (0.75, 0.8, 0.75) * (0.2 + 0.8 * dfTot) + 0.3 * vec3 (1., 1., 0.) * spTot);\n  } else {\n    col = vec3 (0.02, 0.02, 0.04);\n    if (rd.y < 0.) {\n      rd.y = - rd.y;\n      rd.xz = vec2 (- rd.z, rd.x);\n    }\n    rds = floor (2000. * rd);\n    rds = 0.00015 * rds + 0.1 * Noisefv3 (0.0005 * rds.yzx);\n    for (int j = 0; j < 19; j ++) rds = abs (rds) / dot (rds, rds) - 0.9;\n    col += vec3 (1., 1., 0.5) * min (1., 0.5e-3 * pow (min (6., length (rds)), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, t, tt, ph;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  t = 0.05 * tCur;\n  tt = t - floor (t);\n  ph = mod (floor (t), 3.);\n  if (tt > 0.95 && 0.5 * uv.x * canvas.y / canvas.x + 0.5 < (tt - 0.95) / 0.05)\n     ph = mod (ph + 1., 3.);\n  az = 0.;\n  el = 0.;\n  if (ph == 0.) {\n    if (mPtr.z > 0.) {\n      az += 2. * pi * mPtr.x;\n      el += 0.5 * pi * mPtr.y;\n    } else {\n      az = 0.03 * pi * tCur;\n      el = -0.25 * pi * cos (0.02 * pi * tCur);\n    }\n    zmFac = 4.;\n  } else if (ph == 1.) {\n    if (mPtr.z > 0.) {\n      az -= 2. * pi * mPtr.x;\n    } else {\n      az = 0.5 * pi * (1. - 2. * SmoothBump (0.25, 0.75, 0.2, mod (0.02 * tCur, 1.)));\n      el = 0.15 * pi * (1. - 2. * SmoothBump (0.25, 0.75, 0.2, mod (0.017 * tCur, 1.)));\n    }\n    t = 0.03 * tCur;\n    ro = (32. / (2. * pi)) * vec3 (cos (t), 0., sin (t));\n    vd = normalize (- ro);\n    zmFac = 1.8;\n  } else if (ph == 2.) {\n    t = 0.043 * tCur;\n    tt = mod (t, 1.);\n    ro.xz = 8. * ((mod (t, 2.) < 1.) ? vec2 (- cos (2. * pi * tt) + 1., sin (2. * pi * tt)) :\n       vec2 (cos (2. * pi * tt) - 1., sin (2. * pi * tt)));\n    ro.y = 5. * (0.5 - SmoothBump (0.3, 0.7, 0.15, tt));\n    vd = normalize (vec3 (1., 0., 1.) - ro);\n    zmFac = 2.4;\n  }\n  if (ph == 0.) {\n    ori = vec2 (el, az);\n    ca = cos (ori);\n    sa = sin (ori);\n    vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n            mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n    ro = vuMat * vec3 (0., 0., -25.);\n  } else {\n    vd.yz = Rot2D (vd.yz, - el);\n    vd.xz = Rot2D (vd.xz, az);\n    vuMat = mat3 (vec3 (vd.z, 0., - vd.x) / sqrt (1. - vd.y * vd.y),\n       vec3 (- vd.y * vd.x, 1. - vd.y * vd.y, - vd.y * vd.z) / sqrt (1. - vd.y * vd.y), vd);\n  }\n  dstFar = 60.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldVcDc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[407, 407, 429, 429, 971], [973, 973, 1006, 1006, 1183], [1185, 1185, 1206, 1206, 1406], [1408, 1408, 1445, 1445, 1685], [1687, 1687, 1719, 1719, 1917], [1919, 1919, 1954, 1954, 3300], [3302, 3302, 3358, 3358, 5647], [5649, 5649, 5681, 5681, 5781], [5783, 5783, 5840, 5840, 5923], [5925, 5925, 5955, 5955, 6068], [6102, 6102, 6126, 6126, 6256], [6258, 6258, 6282, 6282, 6502], [6504, 6504, 6529, 6529, 6715], [6717, 6717, 6742, 6742, 6967], [6969, 6969, 6998, 6998, 7210], [7212, 7212, 7251, 7251, 7431]], "test": "error"}
{"id": "ldVcRK", "name": "CrystalCave", "author": "EvilRyu", "description": "Continue playing with folding and lattice.", "tags": ["reflection", "tunnel", "folding", "lattice"], "likes": 8, "viewed": 603, "published": "Public API", "date": "1522936874", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Continue playing with folding lattice\n\n#define PI 3.14159265\n\nvec3 path(float p)\n{\n\treturn vec3(sin(p*0.05)*cos(p*0.05)*18., 0.,0.);\n}\n\n// folding from gaz: https://www.shadertoy.com/view/4tX3DS\nvec2 fold(vec2 p, float a)\n{\n    p.x=abs(p.x);\n    vec2 n = vec2(cos(a),sin(a));\n    // change iteration to see different variations\n    for(int i = 0; i < 2; ++i)\n    {\n        p -= 2.*min(0.,dot(p,n))*n;\n        n = normalize(n-vec2(1.,0.));\n    }\n    return p;\n}\n\nmat2 rot(float t)\n{\n    float c=cos(t);\n    float s=sin(t);\n    return mat2(c,-s,s,c);\n}\n\nvec3 tri(vec3 p)\n{\n    return abs(fract(p)-0.5);\n}\n\nfloat tri_surf(vec3 p)\n{\n    return dot(tri(p*0.5+tri(p*0.25)), vec3(0.6666));\n}\n\nint mateid=0;\n\nfloat map(vec3 p)\n{\n    mateid=0;\n    \n    p-=path(p.z);\n    \n    vec3 q=p;\n    \n    p.z*=0.6;\n    p=vec3(rot(0.07*p.z)*p.xy, p.z);\n    p.xy=fold(p.xy,PI/3.);\n    vec3 p1=mod(p,2.5)-1.25;\n\t\n    float ts=0.5-tri_surf(p*7.);\n    // variation of BCC lattice from paniq: https://www.shadertoy.com/view/llfGRj\n    vec3 o=abs(p1); \n    o-=(o.x*1.95+o.y+o.z)*0.33333;\n    float d0=max(o.x,max(o.y,o.z))-0.03+0.05*ts;\n    \n    // another layer\n\tvec3 p2=mod(p-vec3(4.2,0.,0),2.5)-1.25;\n    o = abs(p2); \n    o-=(o.x*1.8+o.y+o.z)*0.33333;\n    float d4=max(o.x,max(o.y,o.z))-0.01+0.05*ts;\n    if(d4<d0)\n    {\n        d0=d4;\n        mateid=2;\n    }\n    \n    float d1=length(q.xy)-1.+0.2*ts;\n    d0=max(d0,-d1);\n   \n    float d2=abs(q.y+1.1+0.02*texture(iChannel1,0.1*q.xz).x);\n    if(d2<d0) mateid=1;\n    \n    d0=min(d0,d2);    \n\n    return d0;\n}\n\nvec3 get_normal(vec3 p)\n{ \n    vec3 e=vec3(0.003,0.0,0.0); \n    return normalize(vec3(map(p+e.xyy)-map(p-e.xyy), \n                          map(p+e.yxy)-map(p-e.yxy), \n                          map(p+e.yyx)-map(p-e.yyx))); \n} \n\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float t=0.01;\n    float d=map(ro+t*rd);\n    for(int i=0;i<128;++i)\n    {\n        if(abs(d)<0.001||t>100.)\n            continue;\n        t+=d;\n        d=map(ro+t*rd);\n    }\n    if(t>100.)t=-1.;\n    return t;\n}\n\nvec3 hash13(float n)\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n// curvature from iq: https://www.shadertoy.com/view/MsXGzM\nfloat curvature(vec3 p, vec3 n)\n{\n    float acc=0.0;\n    for(int i=0;i<4;i++)\n    {\n        vec3 aopos=normalize(hash13(float(i)*213.47));\n        aopos=aopos-dot(n,aopos)*n;\n        aopos=p+aopos*0.03;\n        float dd=clamp(map(aopos)*100.0, 0.0, 1.0 );\n        acc+=dd;\n    }\n    return smoothstep(0.2, 1.0, acc/4.0);\n}\n\nfloat shadow(vec3 ro, vec3 rd, float dist)\n{\n    float res=1.0;\n    float t=0.05;\n    float h;\n    \n    for(int i=0;i<12;i++)\n    {\n        if(t>dist) continue;\n        h=map(ro+rd*t);\n        res = min(6.0*h/t, res);\n        t+=h;\n    }\n    return max(res, 0.0);\n}                                                           \n\n// density from aiekick: https://www.shadertoy.com/view/lljyWm\nfloat density(vec3 p, float ms) \n{\n\tvec3 n = get_normal(p); \n\treturn map(p-n*ms)/ms;\n}\n\n// env mapping from Shane: https://www.shadertoy.com/view/4ttGDH\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\nvec3 env_map(vec3 rd, vec3 n)\n{\n    vec3 col = texcube(iChannel1, rd, n).xyz;\n    return smoothstep(0., 1., col);\n}\n\nvec3 tonemap(vec3 x) \n{\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q=fragCoord.xy/iResolution.xy;\n    vec2 p=q*2.-1.;\n    p.x*=iResolution.x/iResolution.y;\n    vec3 ro=vec3(0.,0.,-iTime*2.);\n    vec3 ta=ro+vec3(0,0,-1.);\n    \n    vec3 lp0=ro+vec3(0,-0.6,-3.);\n    \n    ro+=path(ro.z);\n    ta+=path(ta.z);\n\tlp0+=path(lp0.z);\n    \n    vec3 f=normalize(ta-ro);\n    vec3 r=normalize(cross(f,vec3(0,1,0)));\n    vec3 u=normalize(cross(r,f));\n    \n    vec3 rd=normalize(mat3(r,u,f)*vec3(p.xy,PI/2.));\n    vec3 col=vec3(0.6,0.8,1.1);\n\n    float t=intersect(ro,rd);\n    if(t>-0.5)\n    {\n        vec3 pos=ro+t*rd;\n        vec3 n=get_normal(pos);\n        \n        vec3 mate=2.*vec3(.9,0.3,.9);\n        float cur = curvature(pos, n);\n        \n        mate+=cur*vec3(1.);\n        if(mateid==1)\n        {\n        \tvec3 tex=texture(iChannel1,0.5*pos.xz).xyz;\n            mate=1.*vec3(.6*tex.x,.8*tex.x,1.*tex.x);\n        }\n        else if(mateid>1)\n        {\n            mate=2.*vec3(1.2,.85,.2);\n        }\n                \n        vec3 ld0=lp0-pos;\n        float ldist=length(ld0);\n        ld0/=ldist;\n        vec3 lc0=vec3(1.2,0.8,0.5);\n        \n        float sha=shadow(pos+0.01*n, ld0, ldist);\n        float dif=max(0.,dot(n,ld0))*sha;\n        float bac=max(0.,dot(n,-ld0));\n        float amb=max(0.,dot(n,vec3(0,1,0)))*max(0.,(pos.y+1.));\n        float spe=pow(clamp(dot(ld0, reflect(rd, n)), 0.0, 1.0), 16.0);\n        float fre=clamp(1.0+dot(rd,n), .0, 1.); \n        \n        float sca=1.-density(pos,0.2);\n \n        vec3 Lo=(2.5*dif*lc0+\n                 5.*spe*vec3(1.)*sha+\n                 pow(fre,8.)*vec3(1.1))/(ldist);\n        Lo+=.5*amb*vec3(0.5,0.8,1.);    \n        Lo+=0.3*bac*lc0;\n        \n        vec3 refl=env_map(reflect(rd,n), n);\n        vec3 refr=env_map(refract(rd,n,1./1.35), n);\n\n        if(mateid==2)\n        \tLo+=vec3(1.2,0.6,0.2)*sca*0.25;\n        if(mateid==0)\n        \tLo+=vec3(0.2,0.6,1.2)*sca*0.25*sha;\n        Lo+=mix(refr,refl,pow(fre, 5.));\n        \n        col=mate*Lo*0.2;\n    }\n\n    col=mix(col, .6*vec3(2.3,0.6,1.1), 1.0-exp(-0.0034*t*t) );\n    col=tonemap(col);\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));    \n    col=pow(col,vec3(0.95,.9,0.85));\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1);\n    fragColor.xyz=col;\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldVcRK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[174, 174, 194, 194, 246], [248, 307, 335, 335, 572], [574, 574, 593, 593, 662], [664, 664, 682, 682, 714], [716, 716, 740, 740, 796], [813, 813, 832, 832, 1647], [1649, 1649, 1674, 1674, 1874], [1877, 1877, 1912, 1912, 2125], [2127, 2127, 2149, 2149, 2243], [2245, 2305, 2338, 2338, 2627], [2629, 2629, 2673, 2673, 2894], [2955, 3018, 3052, 3052, 3104], [3106, 3171, 3216, 3216, 3421], [3423, 3423, 3454, 3454, 3538], [3540, 3540, 3563, 3563, 3749], [3751, 3751, 3808, 3808, 6001]], "test": "error"}
{"id": "ldVczd", "name": "RGB WORM", "author": "Thomas_nathan21", "description": "WORM", "tags": ["worm"], "likes": 0, "viewed": 288, "published": "Public API", "date": "1523031327", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \t //sets 0 as the centre of the screen \n\tvec2 r = 2.*fragCoord / iResolution.xy -1.;\n    \n    //variables\n    float x = r.x;\n    float y = r.y;\n    float Thickness = 0.3;\n    float Yoffset = 0.9; \n    float Height = 0.2;\n    \n    //Colors\n    vec3 red = vec3(1,0,0);\n    vec3 green = vec3(0,1,0);\n    vec3 blue = vec3(0,0,1);\n    vec3 pixelCol = vec3(0, 0, 0);\n\t\n    if(abs((x * Height) * sin(PI * (x + iTime)) - (y - Yoffset)) < Thickness) pixelCol = red;\n    if(abs((x * Height) * sin(PI * (x + iTime)) - (y + Yoffset)) < Thickness) pixelCol = blue;\n    if(abs((x * Height) * sin(PI * (x + iTime)) - y) < (Thickness * 2.0)) pixelCol = green;\n   \n    // Output to screen\n    fragColor = vec4(pixelCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldVczd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 82, 125, 795]], "test": "ok"}
{"id": "ldVyR3", "name": "Twisty Box", "author": "Michael_Manning", "description": "Some twisty boxes for my first shader", "tags": ["rotation"], "likes": 3, "viewed": 184, "published": "Public", "date": "1522808162", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define speed 0.9\n#define scaleCo 0.35\n#define rotation 1.4\n#define angleOffset 0.1\n#define intensity 3.1\n#define outerOffset 0.9\n#define tiles 3.0\n\n#define PI 3.14159265359\nfloat rectangle(vec2 r, vec2 topLeft, vec2 bottomRight, float blur) {\n\tfloat ret;\n\tret = smoothstep(topLeft.x-blur, topLeft.x+blur, r.x);\n\tret *= smoothstep(topLeft.y-blur, topLeft.y+blur, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.y-blur, bottomRight.y+blur, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.x-blur, bottomRight.x+blur, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\t\n\n    \n\tvec3 bgCol = vec3(0.85,0.85,1.0);\n\tvec3 ret = bgCol;\n    vec2 q;\n\t\n    for(float i = 20.0; i > 0.0; i--)\n    {    \n        float angle;\n\t\tangle = PI * rotation * sin(speed * iTime) + length(r) * -cos(speed * (iTime - outerOffset)) * intensity;\n    \tangle += angleOffset * i;\n        vec3 changingColor = 0.5 + 0.5*cos(iTime+  i*0.4 +vec3(0,2,4));\n        \n\t\t// q is the rotated coordinate system\n\t\tq.x =   cos(angle)*r.x + sin(angle)*r.y;\n\t\tq.y = - sin(angle)*r.x + cos(angle)*r.y;\n\t//q=r;\n        float scale = (i * scaleCo);\n      \n        \n        ret = mix(ret, (vec3(0.03 * i, 0.03 * i, 0.15 * i) + changingColor)/2.0 , rectangle(q, vec2(-0.3, -0.5) * scale, vec2(0.3, 0.5) * scale, 0.0002));\n        ret = mix(ret, (vec3(0.06 * i, 0.06 * i, 0.15 * i) + changingColor)/2.0 , rectangle(q, vec2(-0.28, -0.48) * scale, vec2(0.28, 0.48) * scale, 0.04));\n    }  \n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldVyR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 243, 243, 525], [527, 527, 584, 584, 1577]], "test": "ok"}
{"id": "ldVyW3", "name": "maybe what", "author": "Eugene_One", "description": "http://www.maybewhat.com/\nhttps://www.newrafael.com/websites/", "tags": ["math", "abstract", "rr"], "likes": 0, "viewed": 107, "published": "Public", "date": "1523630471", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 U) {\n    U/=iResolution.xy; float t=fract(iTime*.6),x=U.x-1.;\n    O=2.+x*exp2(t+ceil(-log2(x*log2(1.-t/2.)-x)))>=U.y?\n    vec4(.17,.65,.9,1):\n    vec4(1,.5,1,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldVyW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 195]], "test": "ok"}
{"id": "ldycR3", "name": "Pulse - circle", "author": "bozhkov", "description": "First shader! Tried to get some nice pulsing effect", "tags": ["2d", "pulse", "circle", "organic"], "likes": 27, "viewed": 910, "published": "Public", "date": "1522754204", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsb2rgb(in vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    float r = length(p) * 0.9;\n\tvec3 color = hsb2rgb(vec3(0.24, 0.7, 0.4));\n    \n    float a = pow(r, 2.0);\n    float b = sin(r * 0.8 - 1.6);\n    float c = sin(r - 0.010);\n    float s = sin(a - iTime * 3.0 + b) * c;\n    \n    color *= abs(1.0 / (s * 10.8)) - 0.01;\n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldycR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 258], [260, 260, 317, 317, 683]], "test": "ok"}
{"id": "ldycRt", "name": "triangle kaleidoscope", "author": "epicycle", "description": "Equilateral triangle reflected everywhere, rotating texture source", "tags": ["triangle", "kaleidoscope"], "likes": 7, "viewed": 289, "published": "Public", "date": "1523148151", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nmat2 rot(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 1.0 / 3.0; // triangle length\n                             // as fraction of viewport height\n    \n    //scale = 1.0 / (10.0 + 3.0 * sin(iTime / 5.0));\n    \n    float tHeight = scale * sqrt(3.0) / 2.0;\n    float tCenterToBase = scale * 0.5 * tan(PI / 6.0);\n    float tRadius = tHeight - tCenterToBase;\n    \n    // Aspect-normalized pixel coordinates (from 0 to 1 for y axis)\n    vec2 R = iResolution.xy,\n        uv = fragCoord / R.y;\n\n    // Repeat triangles\n    vec2 Repeat = vec2(tHeight, scale),\n        Index = uv / Repeat;\n    uv = mod(uv, Repeat);\n    \n    // Flip every column\n    uv.x = mod(Index.x, 2.0) > 1.0 ? uv.x : tHeight - uv.x;\n    \n    // normalize texture coordinates\n   \tuv /= scale;\n    \n    // reflect\n    float tAngle = radians(60.0);\n    vec2 angleVec = vec2(cos(-tAngle), sin(-tAngle));\n    float dAngleBottom = dot(uv, angleVec);\n    vec2 bottomReflect = uv - dAngleBottom * 2.0 * angleVec;\n    uv = dAngleBottom > 0. ? bottomReflect : uv;\n    \n    vec2 angleVecReflected = vec2(angleVec.x, -angleVec.y);\n    float dAngleTop = dot(uv - vec2(0.0, 1.0), angleVecReflected);\n    vec2 topReflect = uv - dAngleTop * 2.0 *  angleVecReflected;\n    uv = dAngleTop > 0.0 ? topReflect : uv;\n    \n    // adjust texture\n    float theta = floor(Index.y) * 2.0 * PI / 3.0 + iTime / 2.0;\n    uv -= vec2(tCenterToBase / scale, 0.5);\n    uv *= rot(theta);\n    uv /= (2.0 * tRadius) / scale;\n    uv += 0.5;\n    \n    vec4 tColor = texture(iChannel0, uv);\n    vec2 cuv = fragCoord/R;\n    tColor = vec4(cuv.x, 0.35 + 0.25 * sin(iTime + cuv.y), 1.0 - cuv.x, 1.0) - tColor.r;\n    fragColor = tColor;\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldycRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 45, 45, 97], [99, 99, 156, 156, 1777]], "test": "error"}
{"id": "ldycWV", "name": "necessary-disorder \"Gif7\"", "author": "FabriceNeyret2", "description": "reproduce some  Étienne Jacob's effects [url]https://goo.gl/vBGWwj[/url] (see ref below)\n\nfollowing his tuto (based of Processing) [url]https://necessarydisorder.wordpress.com/[/url]\ncore Idea:  interpolated points delayed.", "tags": ["2d", "curves", "interpolation", "art", "reproduction", "etiennejacob"], "likes": 43, "viewed": 839, "published": "Public API", "date": "1523368521", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// #4b: https://shadertoy.com/view/MsGcWK\n// #4: https://shadertoy.com/view/lsGcWK\n// #3: https://shadertoy.com/view/MdGcWK\n// shaking grid: https://www.shadertoy.com/view/MdyyWK\n// #2: https://shadertoy.com/view/lsGyWK\n// #1: https://shadertoy.com/view/MdGyWK\n\n// http://www.thisiscolossal.com/2018/04/animation-of-sinusoidal-waves-in-gifs-by-etienne-jacob\n// EJ's tutos: https://necessarydisorder.wordpress.com/\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))          // rotation\n#define S(D,e) smoothstep( 3., 0., length(D)*R.y -e )      // for antialiasing\nvec2 A,B,R; float l;\n#define line(p,a,b) ( l = dot(B=b-a, A=p-a)/dot(B,B), clamp(l,0.,1.) == l ? S(A-B*l,0.) : 0.)\n//float line(vec2 p, vec2 a, vec2 b) {                     // draw a segment without round ends\n//    b -= a; p -= a;\n//    float l = dot(b,p)/dot(b,b);\n//    return clamp(l, 0., 1.) == l ? S( p - b * l ,0.) : 0.;\n//}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    R = iResolution.xy;\n    U = ( U+U - R ) / R.y;\n    O -= O;\n    \n    float v,f, t = 2.*iTime, T = 12., S=1.6, K = .05;\n    mat2 M  = rot(6.283/8.), M2 = rot(6.283/48.);\n    vec2 _P, P, Ui, Uj = U;\n    \n#define  P0(t) vec2(-.9,.4) + K* vec2(2.*cos(t+1.) ,sin(t+1.)  )\n#define  P1(t) vec2(  0,.4) + K* vec2(2.*cos(t1(t)),-sin(t1(t)))\n#define  t1(t)  S*(t) + .5*cos( S*(t) )\n\n    // 48 curves = 8 angular copies (4+sym) of 6 dephased-curves \n    for (float j=0.; j<6.; j++, Uj*=M2 ) {         // 6 phases\n        f  = t + 6.283*j/6.;\n        _P= P0(f);\n        for (float s=0.; s<1.; s+=.01) {           // draw delayed-interpolation P0 -> P1\n            P = mix( P0(f-T*s) , P1(f-T*(1.-s)) , s ); \n            v =  1. + 1e2* length(P-_P);           // thicker when slow\n            Ui = Uj;\n            for (int i = 0; i < 4; i++, Ui*= M )   // 4 angular copies\n                O += line(Ui*sign(Ui.y),_P,P) / v; // + central symmetry\n            _P = P;                                // NB: doable to use 2ble symmetry\n        }\n        for (int i = 0; i < 8; i++, Ui*= M )       // draw dots\n            O += S(P0(f)-Ui, 2.),\n            O += S(P1(f)-Ui, 2.);\n   }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldycWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[899, 899, 937, 937, 2108]], "test": "ok"}
{"id": "ldycz3", "name": "soulevement", "author": "jmaire", "description": "rotate par les quaternions", "tags": ["boxrotatequaternion"], "likes": 5, "viewed": 114, "published": "Public", "date": "1522765169", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//soulevement  de jmaire\n\n\n\n /*\n    Tutorial used and credit: https://www.shadertoy.com/view/lt33z7\n    tutorial used and credit:http://jamie-wong.com */\n\n\nconst int MAX_MARCHING_STEPS = 255; \nconst float MIN_DIST = 0.0; \nconst float MAX_DIST = 100.0; \nconst float EPSILON = 0.0001; \nconst float PI = 3.14159; \nconst float sq2 = cos(PI/4.0); \n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat boxSDF(vec3 p, vec3 b ) {\n    return length(max(abs(p) - b, 0.0)); \n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat pMod(float t, float d) {\n    return mod(t + d/2.0, d) - d/2.0; \n}\n\nvec3 qrotate(vec3 axe, float angl, vec3 v) {\n    float a = angl/2.0; \n    vec3 axens = normalize(axe) * sin(a); \n    return v + 2.0 * cross(cross(v, axens) - v * cos(a), axens); \n}\n\n\nfloat bras(float an, vec3 pos, vec3 p) {\n vec3  p1 = qrotate(vec3(0., 1., 0.), an + PI/4.0, p); \n p1 = p1 + vec3(sq2, 0., 0.); \n vec3 p2 = qrotate(vec3(0.0, 0.0, 1.0), iTime, p1); \n float boo = boxSDF(p2, vec3(0.1, 0.1, 2.0)); \n vec3 p3 = qrotate(vec3(0.0, 1.0, 0.0),  - PI/4.0, p2); \n p3 = p3 + vec3(0.25, 0., 0.25); \n float bo1 = boxSDF(p3, vec3(0.25, 2.1, 0.25)); \nreturn min(boo, bo1); \n}\n\n\n\nfloat sceneSDF(vec3 p) {\n     p.z=pMod(p.z,2.0);\n     p.x=pMod(p.x,2.0);\n float  s0 = bras(0.0, vec3(-1.0, 0.0, -1.0), p); \n float  s1 = bras(PI/2.0, vec3(-1., 0.0, -1.0), p); \n float  s2 = bras(PI, vec3(-1., 0., -1.), p); \n float  s3 = bras(3.0 * PI/2.0, vec3(-1., 0., -1.), p); \t\nreturn min(s3, min(s2, min(s1, s0))); \n}\n\nvec3 estimateNormal(vec3 p) {\n   \n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)), \n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)), \n        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    )); \n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phoneContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                            vec3 lightPos, vec3 lightIntensity)\n{ \n    vec3 N = estimateNormal(p); // Estimate normal of surface\n    vec3 L = normalize(lightPos - p); // Point from point on surface to light\n    vec3 V = normalize(eye - p); // Viewing vector, used to diffuse reflected light\n    vec3 R = normalize(reflect(-L, N)); // Reflect light to the normal\n\n    float dotLN = dot(L,N); // cosine angle between light direction and normal direction\n    float dotRV = dot(R,V); // cosine angle between reflection direction and viewing direction\n    \n    // Light is coming from behind the normal of the face, pitch black\n    if (dotLN < 0.)\n    {\n        return vec3(0.0);\n    }\n    // Reflected light points away from the camera, so there are no direct light. Only ambient light and diffuse color\n    if (dotRV < 0.)\n    {\n        // This value maxes when dotLN = 1, which is when L(light) and N(normal) are equal. 100% of the light is reflected back\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n    }\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 globalAmbentLight = vec3(0.1,0.1,0.8);\n    vec3 color = globalAmbentLight * k_a; // Multiply brightness by color to get ambient color\n    color += phoneContribForLight(k_d, k_s, alpha, p, eye, vec3(-30.,6.,30.), vec3(1.,.1, 0.));\n    color += phoneContribForLight(k_d, k_s, alpha, p, eye,vec3(20.,6.,-30.), vec3(0.3, 0.05, 0.5));\n    color += phoneContribForLight(k_d, k_s, alpha, p, eye,vec3(3.,8.0,-30.), vec3(0.1, 0.35, 1.0));\n    return color;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\n\n\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end)\n{\n    // Start depth\n    float depth = start;\n    // Keep looking for where the marching ray hits a surface\n    for (int i = 0; i < MAX_MARCHING_STEPS; ++i)\n    {\n        // Get the distance from marching ray point to surface of box\n        float dist = sceneSDF(eye + marchingDirection * depth);\n        // If we've hit near the surface, return this distance\n        if (dist < EPSILON) {\n            return depth; \n        }\n        // Didn't find anything, let's go to where we found something\n        depth =depth +  dist; \n        // We're at the end, stop\n        if (depth > end)\n        {\n            return end;\n        }\n    }\n    // Ran out of steps before we hit the end, just return end\n    return end;\n}\n\n/**\n    fov:         Field of View of camera\n    screen_size: Screen size\n    gl_FragCoord:   Screen coord of pixel\n    return:      Direction of rendering ray of the projection camera\n */\n\n\n\nvec3 rayDirection(float fov, vec2 screen_size, vec2 fragCoord)\n{\n\tvec2 xy = fragCoord - screen_size / 2.0;\n    float z = (screen_size.y / 2.) / tan(radians(fov) / 2.);\n    return normalize(vec3(xy,-z));\n}\n\n\n\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 lookAtMatrix(vec3 eye, vec3 center, vec3 up) \n{\n    // Based on gluLookAt man page\n    // Forward/Look at vector\n    vec3 f = normalize(center - eye);\n    // Right vector\n    vec3 v = normalize(cross(f, up));\n    // Camera local up Vector\n    vec3 u = cross(v, f);\n    return mat3(\n        vec3(v),\n        vec3(u),\n        vec3(-f)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 camera_space_dir = rayDirection(30., iResolution.xy, gl_FragCoord.xy);\n    vec3 eye = \n        vec3(\n            6.*cos(iTime*0.2) +2.,\n            2.*cos(iTime*0.5) +6.,\n            6.*sin(iTime*0.2)+2. \n            );\n\n   vec3 world_space_dir = lookAtMatrix(eye, vec3(0.), vec3(0,1,0)) * camera_space_dir;\n    // Find shortest distance surface\n    float dist = shortestDistanceToSurface(\n        eye,\n        world_space_dir, \n        MIN_DIST, \n        MAX_DIST);\n    if (dist > MAX_DIST - EPSILON)\n    {\n        fragColor = vec4(0.07);\n        return;\n    }\n\n    // We've hit a surface\n    // Phong shading time!!\n    // Surface point\n    vec3 p = eye + dist * world_space_dir; \n\n    vec3 K_ambientColor = vec3(1.0, 0.0, 0.0); \n    vec3 K_diffuseColor = vec3(1.0, 1.0, 1.0); \n    vec3 K_specularColor = vec3(0.0, 1.0, 0.0); \n    float shineness = 3.0; \n\n    vec3 color = phongIllumination(K_ambientColor, K_diffuseColor, K_specularColor, shineness, p, eye); \n    fragColor = vec4(color, 1.); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldycz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[345, 434, 465, 465, 509], [752, 752, 782, 782, 823], [825, 825, 869, 869, 1005], [1008, 1008, 1048, 1048, 1400], [1404, 1404, 1428, 1428, 1726], [1728, 1728, 1757, 1757, 2073], [2075, 2567, 2709, 2709, 3725], [3727, 4097, 4182, 4182, 4647], [5073, 5073, 5164, 5183, 5880], [6074, 6074, 6138, 6138, 6278], [6283, 6610, 6662, 6727, 6956], [6958, 6958, 7015, 7015, 8020]], "test": "error"}
{"id": "ldyczd", "name": "sdf of star (internal)", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "sdf", "shapes", "short", "mz"], "likes": 3, "viewed": 508, "published": "Public API", "date": "1522954919", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 O, vec2 U )\n{\n   float t = mod(iTime,8.), \n         N = 3.+5.*min(t,8.-t),\n         r = 1.,                   // radius\n        r0 = .5;                   // relative interior radius\n    \n    vec2 R = iResolution.xy;\n    U = ( U+U - R ) / R.y;\n    float a = atan(U.x,U.y), l = length(U),\n          b = 3.14159/N,\n        tb = tan(b),\n       // s = sin(b); // if control by peak angle\n          s = (r0 * tb)/(sqrt(1.+tb*tb)-r0); // control by r\n    a = mod(a,2.*b)-b;\n    U = l * vec2(cos(a),sin(a)) / cos(b);\n    U.y = abs(U.y);\n    U.x -= r/cos(b);\n    l = -(s*U.x+U.y)/sqrt(1.+s*s);  // true euclidian distance ( +: inside )\n  //l = -(U.x+U.y/s);               // field fitting radial distance ( +: indide )\n    O = vec4( l );\n    \n    //O = sin(30.*O);\n    if (O.x<0.) O=vec4(1,0,0,0);\n    O.b = .5*sin(6.28*10.*l);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldyczd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 39, 39, 847]], "test": "ok"}
{"id": "ldyyRK", "name": "M.A.M.", "author": "leon", "description": "Tribute to Marc-Antoine Mathieu.  \nShadertoy version of a 8k party prod made for Revision 2018.  \nMusic by Alkama.", "tags": ["raymarching", "demoscene", "revision"], "likes": 31, "viewed": 681, "published": "Public", "date": "1522661886", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// M.A.M. by Leon Denise aka ponk 01 / 04 / 2018\n// Tribute to Marc-Antoine Mathieu.\n// Shadertoy version of a 8k party prod made for Revision 2018.\n// Thanks to koltes, lamogui, wsmind, halcy, iq, LJ, Duke, mercury, blueberry, mentor.\n\n#define time mod(iTime,103.)\n//#define HD\n\n#ifdef HD\n#define RAY_STEP 100.\n#define RAY_DAMPING .5\n#else\n#define RAY_STEP 50.\n#define RAY_DAMPING .8\n#endif\n\nconst float PI = 3.14159;\nconst float TAU = 6.28318;\nconst float aFadeIn1 = 6.;\nconst float aLampsIn = 20.;\nconst float aLibraryIn = 28.;\nconst float aLibrarySwingIn = 50.;\nconst float aLibraryTwistIn = 40.;\nconst float aRotate = 80.;\nconst float aDoor = 60.;\nconst float aPaper1 = 64.;\nconst float aPaper2 = 68.;\nconst float aPaper3 = 75.;\nconst float aPaper4 = 80.;\nconst float aDoor1 = 60.;\nconst float aDoor2 = 70.;\nconst float aDoor3 = 75.;\nconst float aDoor4 = 80.;\nconst float aDoor5 = 85.;\nconst float toroidalRadius = 30.;\nconst float innerRadius = 15.;\nconst vec2 roomCount = vec2(58., 90.);\nconst float roomHeight = 1.;\nconst float roomThin = .01;\n\n#define anim(start,delay) smoothstep(start, start+delay, time)\n#define repeat(p,c) (mod(p,c)-c/2.)\n#define sdist(p,r) (length(p)-r)\n\nfloat rng (vec2 seed) { return fract(sin(dot(seed*.1684,vec2(54.649,321.547)))*450315.); }\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat sdBox( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\nfloat amod (inout vec2 p, float count) { float an = TAU/count; float a = atan(p.y,p.x)+an/2.; float c = floor(a/an); c = mix(c,abs(c),step(count*.5,abs(c))); a = mod(a,an)-an/2.; p.xy = vec2(cos(a),sin(a))*length(p); return c; }\nfloat amodIndex (vec2 p, float count) { float an = TAU/count; float a = atan(p.y,p.x)+an/2.; float c = floor(a/an); c = mix(c,abs(c),step(count*.5,abs(c))); return c; }\nvec2 toroidal (vec2 p, float r) { return vec2(length(p.xy)-r, atan(p.y,p.x)); }\nvec3 getCamera (vec3 eye, vec3 lookAt, vec2 uv) {\n\tvec3 forward = normalize(lookAt - eye);\n\tvec3 right = normalize(cross(forward, vec3(0,1,0)));\n\tvec3 up = normalize(cross(right, forward));\n\treturn normalize(.6 * forward + uv.x * right + uv.y * up);\n}\n\nfloat mapRooms (vec3 pos) {\n\n\tfloat scene = 1000.;\n\tvec3 p = pos;\n\tvec3 pRoom = pos;\n\tvec3 pWall = pos;\n\tvec2 seed;\n\tfloat repeaty = toroidalRadius*TAU/roomCount.y;\n\n\t// toroidal distortion\n\tvec3 pTorus = p;\n\tpTorus.y += innerRadius + roomHeight / 2.75;\n\tpTorus.x += toroidalRadius;\n\tpTorus.xz = toroidal(pTorus.xz, toroidalRadius);\n\tpTorus.z += time * .03 + anim(aDoor2, 20.);\n\tpTorus.z *= toroidalRadius;\n\tpTorus.xzy = pTorus.xyz;\n\tpTorus.xz *= rot(anim(aDoor4, 30.) * 5.);\n\n\t// walls\n\tp = pTorus;\n\tp.y = repeat(p.y, repeaty);\n\tvec2 wall = vec2(1000.);\n\twall.x = max(abs(p.y)-roomThin, sdist(p.xz, innerRadius));\n\tamod(p.xz, roomCount.x);\n\tp.x -= innerRadius;\n\twall.y = max(abs(p.z)-roomThin, p.x);\n\tpWall = p;\n\n\t// room cell\n\tp = pTorus;\n\tp.xz *= rot(PI/roomCount.x);\n\tfloat py = p.y+repeaty/2.;\n\tseed.y = floor(py/repeaty);\n\tp.y = repeat(py, repeaty);\n\tseed.x = amod(p.xz, roomCount.x);\n\tp.x -= innerRadius-roomHeight/2.;\n\n\tpRoom = p;\n\tfloat chairSide = step(0., p.x);\n\n\tfloat salt = rng(seed);\n\tfloat pepper = rng(seed+vec2(.612,0.5023));\n\tfloat spice = rng(seed+vec2(.698,0.756));\n\n\t// ground\n\tscene = min(scene, p.x+roomHeight*.5);\n\n\tfloat table = 1000.;\n\tfloat tableHeight = .2+.1*salt;\n\tfloat tableThin = .001+.001*pepper;\n\tfloat tableWidth = .1+.2*spice;\n\tfloat tableLegThin = .005+.003*pepper;\n\tp = pRoom;\n\tp.x += roomHeight/2.-tableHeight;\n\tp.yz *= rot((salt*2.-1.)*.2);\n\ttable = min(table, max(abs(p.x)-tableThin, sdist(p.yz, tableWidth)));\n\tp.yz *= rot(pepper*TAU);\n\tp.yz = abs(p.yz)-tableWidth*.5+tableLegThin;\n\tp.x += tableHeight*.5;\n\ttable = min(table, sdBox(p, vec3(tableHeight*.5, tableLegThin, tableLegThin)));\n\n\tfloat chair = 1000.;\n\tp = pRoom;\n\tfloat chairHeight = .15+.07*mix(salt, pepper, chairSide);\n\tfloat chairWidth = .06+.07*mix(pepper, spice, chairSide);\n\tfloat chairLegThin = .002+.005*mix(spice, salt, chairSide);\n\tfloat chairSitThin = .01;\n\tfloat chairBackHeight = .05;\n\tp.yz *= rot(sin(salt * TAU));\n\tp.z = abs(p.z) - tableWidth - chairWidth*2.;\n\tp.yz *= rot(sin(mix(salt, pepper, chairSide)*TAU)*.6 + PI/2.);\n\tp.x -= chairHeight;\n\tp.x += roomHeight/2.;\n\tchair = min(chair, sdBox(p, vec3(chairSitThin, chairWidth, chairWidth)));\n\tchair = min(chair, sdBox(p+vec3(-chairHeight+chairBackHeight,chairWidth-chairLegThin,0), vec3(chairBackHeight, chairLegThin, chairWidth)));\n\tfloat chairArm = step(0.,p.y);\n\tp.yz = abs(p.yz)-chairWidth+chairLegThin;\n\tp.x += chairArm * chairHeight * .5;\n\tchair = min(chair, sdBox(p, vec3(chairHeight*mix(1.,.5,chairArm), chairLegThin, chairLegThin)));\n\n\tfloat door = 1000.;\n\tp = pTorus;\n\tseed.y = floor(p.y/repeaty);\n\tp.y = repeat(p.y, repeaty);\n\tp.xz *= rot(PI/roomCount.x);\n\tseed.x = amodIndex(p.xz, roomCount.x);\n\tsalt = rng(seed);\n\tpepper = rng(seed+vec2(.132,0.9023));\n\tspice = rng(seed+vec2(.672,0.1973));\n\tfloat doorWidth = .2+.05*pepper;\n\tfloat doorHeight = .3+.15*spice;\n\tamod(p.xz, roomCount.x);\n\tp.x -= innerRadius-roomHeight+doorHeight;\n\twall.x = max(wall.x, -sdBox(p, vec3(doorHeight, .1, doorWidth)));\n\tp.x += .2;\n\tp.z = abs(p.z)-.4;\n\twall.x = max(wall.x, -sdBox(p, vec3(doorHeight, .1, doorWidth * .5)));\n\n\t// window\n\tp = pTorus;\n\tseed.x = amodIndex(p.xz, roomCount.x);\n\tseed.y = floor((p.y+repeaty/2.)/repeaty);\n\tsalt = rng(seed);\n\tpepper = rng(seed+vec2(.132,0.9023));\n\tspice = rng(seed+vec2(.672,0.1973));\n\tvec2 windowRepeatWidth = vec2(.2+.2*salt, .4+.4*pepper);\n\tp.y = repeat(p.y+repeaty/2., repeaty);\n\tamod(p.xz, roomCount.x);\n\tp.x -= innerRadius-roomHeight/2.;\n\twall.y = max(wall.y, -sdBox(p, vec3(windowRepeatWidth.x, windowRepeatWidth.y, 1.)));\n\n\treturn min(scene, min(chair, min(table, min(wall.x, wall.y))));\n}\n\nfloat sdStairs (vec3 p) {\n\tfloat stairs = max(abs(p.x)-1., abs(p.y + 1. + floor(p.z) * .2)-.2);\n\tstairs = max(stairs, -(p.y + p.z * .2 + 1.));\n\tstairs = max(stairs, p.z-aDoor);\n\treturn stairs;\n}\n\nfloat sdPaper (vec3 pos) {\n\tpos.z -= 3.;\n\tfloat z = pos.z;\n\tfloat door = 1.-smoothstep(aDoor - 6., aDoor - 3., pos.z) * (1.-smoothstep(aDoor + 3., aDoor + 6., pos.z));\n\tpos.z -= time * 2.;\n\tfloat id = floor(pos.z/.5);\n\tpos.y += min(id, aDoor) * .1 + .35 + min(time, aDoor+1.) * .4 + sin(id*.5+time) * .3 * door;\n\tpos.y -= anim(aDoor, 1.);\n\tpos.xy *= rot(sin(pos.z * .3 + time));\n\tpos.x += sin(id*.5+time*2.+sin(pos.y+time))*.6*door;\n\tpos.z = repeat(pos.z, .5);\n\tvec3 p = pos;\n\tfloat d = sin(pos.x*2. - time);\n\tp.x = mix(p.x, abs(p.x), step(aPaper1, z)) - 2. * (1.-smoothstep(z - 10., z, aPaper1));\n\tp.y = mix(p.y, abs(p.y), step(aPaper2, z)) - 2. * (1.-smoothstep(z - 10., z, aPaper2));\n\tp.x = mix(p.x, abs(p.x), step(aPaper3, z)) - 2. * (1.-smoothstep(z - 10., z, aPaper3));\n\tp.y = mix(p.y, abs(p.y), step(aPaper4, z)) - 2. * (1.-smoothstep(z - 10., z, aPaper4));\n\tp.xz *= rot(d*.9);\n\tp.yz *= rot(d*2.6+id);\n\tfloat paper = max(0.,max(abs(p.y),max(abs(p.x)-.1, abs(p.z)-.1)));\n\tpaper = max(paper, id+8.);\n\treturn paper;\n}\n\nfloat sdLibrary (vec3 pos) {\n\tfloat scene = max(0., -abs(pos.x) + 1.5);\n\tfloat a = 1.-anim(aLibraryIn + abs(floor(pos.z)-25.)*.4, 10.);\n\tpos.y += a * 50.;\n\tpos.y -= 2.5;\n\tvec3 id = vec3(floor(pos.yz),0);\n\tpos.y += mix(1.,-1.,mod(id.y, 2.))*sin(time) * anim(aLibrarySwingIn, 5.);\n\tvec3 p = pos;\n\tp.y += id.y * .2;\n\tfloat y = p.y;\n\tid.x = floor(p.y);\n\tp.yz = repeat(p.yz, 1.);\n\tscene = max(scene, min(-abs(p.y) + .49, -abs(p.z) + .49));\n\tid.z = floor(pos.z/.1);\n\tfloat offset = .05 * sin((id.z+id.y+id.x) * 4.);\n\tp = pos;\n\tp.z = repeat(p.z, .1);\n\tscene = min(scene, max(-abs(p.x) + 1.7 - offset, abs(p.z)-.04));\n\tscene = max(scene, abs(pos.x) - 2.);\n\tscene = max(scene, y);\n\tscene = max(scene, pos.z-aDoor);\n\treturn scene;\n}\n\nfloat sdLamp (vec3 pos) {\n\tvec3 p = pos;\n\tfloat a = anim(aLampsIn, 5.);\n\tfloat z = floor(pos.z/2.);\n\tp.y -= 20. - 18. * a - z * .2*2.;\n\tp.z = repeat(p.z, 2.);\n\tp.y -= 10.;\n\tp.xy *= rot(sin(time * 2. + z)*.07);\n\tp.y += 10.;\n\tp.xz *= rot(p.y * 8. + time);\n\tfloat scene = sdist(p,.2);\n\tamod(p.xz, 5.);\n\tp.x -= max(.01, .19 * (1.-clamp(p.y*2., 0., 1.)));\n\tscene = min(scene, max(sdist(p.xz, .01*a), -p.y));\n\tscene = mix(10., scene, anim(aLampsIn, 1.));\n\tscene = max(scene, pos.z - aDoor);\n\treturn scene;\n}\n\nfloat sdDoor (vec3 pos) {\n\tpos.z -= aDoor;\n\tpos.y += .1 + aDoor*.2;\n\tvec3 p = pos;\n\tp.x = abs(p.x) - .5;\n\tp.x -= .5;\n\tp.xz *= rot(.6+smoothstep(aDoor-2., aDoor + 2., time) * 1.5);\n\tp.x += .5;\n\tp.y -= .5;\n\tfloat scene = sdBox(p, vec3(.5,1,.02));\n\tscene = min(scene, max(sdist(p.xy-vec2(0,1.), .5), abs(p.z)-.02));\n\tfloat x = p.x;\n\tp.x = repeat(p.x, .2);\n\tscene = max(scene, -abs(p.x)+.02);\n\tp.x = x;\n\tp.z += .04;\n\tp.y = abs(p.y)-.775;\n\tp.xy *= rot(-.1);\n\tscene = min(scene, sdBox(p, vec3(.39,.1,.01)));\n\tp.x = abs(p.x) - .2;\n\tscene = min(scene, max(sdist(p.xy, .02), abs(p.z)-.04));\n\treturn scene;\n}\n\nvec2 map (vec3 pos) {\n\tvec3 p = pos;\n\tfloat fade = (1.-smoothstep(aPaper1, aPaper1 + 5.,time));\n\tp.xz *= rot(sin(p.z * .2 + time) * .35*(1.-clamp(length(pos.z)/50., 0., 1.)));\n\tp.xy *= rot(sin(-p.z * .2 + time)*.5 * anim(aLibraryTwistIn, 5.) * fade);\n\tp.y -= min(time, aDoor) * .2;\n\tp.y -= sin(pos.z * .4) * .3 + pos.z * pos.z * .01;\n\tp.z += time;\n\tfloat paper = sdPaper(p);\n\tfloat dist = 100.;\n\tvec2 sdf = vec2(0);\n\tif (time < aDoor + 2.) {\n\t\tdist = min(min(min(sdLamp(p), sdStairs(p)), sdLibrary(p)), sdDoor(p));\n\t\tsdf.y = step(dist, paper);\n\t} else {\n\t\tpos.zy *= rot(.3);\n\t\tpos.y -= 1.7;\n\t\tdist = mapRooms(pos+vec3(0,.25,0));\n\t\tsdf.y = step(dist, paper) * 2.;\n\t}\n\tsdf.x = min(paper, dist);\n\treturn sdf;\n}\n\nvoid animCamera (inout vec3 eye, inout vec3 target) {\n\teye.y = mix(eye.y, 1., anim(aDoor1, 5.));\n\ttarget.y = mix(target.y, 1.1, anim(aDoor1, 5.));\n\teye = mix(eye, vec3(0,.9,-1.5), anim(aDoor1, 5.));\n\teye = mix(eye, vec3(0,12.,-1.5), anim(aDoor4, 5.));\n\teye = mix(eye, vec3(6,12.,-1.5), anim(aDoor5, 5.));\n\ttarget = mix(target, vec3(0,1,3), anim(aDoor3, 5.));\n\ttarget = mix(target, vec3(0,1,8), anim(aDoor4, 5.));\n\ttarget = mix(target, vec3(-15,0,3), anim(aDoor5, 5.));\n}\n\nvec4 raymarch () {\n\tvec2 uv = (gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\tfloat dither = rng(uv.xx+uv.yy);\n\tvec3 eye = vec3(0,1,-1);\n\tvec3 target = vec3(0,0,1);\n\tanimCamera(eye, target);\n\tvec3 ray = getCamera(eye, target, uv);\n\tvec3 pos = eye;\n\tfloat shade = 0.;\n\tfloat total = 0.;\n\tvec2 sdf;\n\tfor (float i = 0.; i <= 1.; i += 1./RAY_STEP) {\n\t\tsdf = map(pos);\n\t\tfloat dist = sdf.x;\n\t\tif (dist < .0001) { shade = 1.-i; break; }\n\t\tif (total > 100.) { shade = 0.; break; }\n\t\ttotal += dist;\n\t\tdist *= RAY_DAMPING + .1 * dither;\n\t\tpos += ray * dist;\n\t}\n\n\tshade *= 1. - smoothstep(50., 99., total);\n\tshade *= mix(step(sdf.y,0.5), 1., anim(aFadeIn1, 5.));\n\tshade *= mix(anim(aDoor + 1., 5.), 1., step(sdf.y, 1.5));\n\tshade *= smoothstep(0.1, 1., time) * (1.-smoothstep(100., 103., time));\n\treturn vec4(smoothstep(.0, .8, shade));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = raymarch();\n}", "image_inputs": [{"id": "lsSXDw", "previewfilepath": "https://soundcloud.com/leon-denise/sweet-hug-by-alkama", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/leon-denise/sweet-hug-by-alkama", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldyyRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1186, 1186, 1209, 1209, 1276], [1277, 1277, 1297, 1297, 1347], [1348, 1348, 1379, 1379, 1462], [1463, 1463, 1503, 1503, 1691], [1692, 1692, 1731, 1731, 1860], [1861, 1861, 1894, 1894, 1940], [1941, 1941, 1990, 1990, 2192], [2194, 2194, 2221, 2221, 5791], [5793, 5793, 5818, 5818, 5987], [5989, 5989, 6015, 6015, 7010], [7012, 7012, 7040, 7040, 7734], [7736, 7736, 7761, 7761, 8237], [8239, 8239, 8264, 8264, 8837], [8839, 8839, 8860, 8860, 9546], [9548, 9548, 9601, 9601, 10018], [10020, 10020, 10038, 10038, 10851], [10853, 10853, 10910, 10910, 10940]], "test": "timeout"}
{"id": "ldyyW3", "name": "Sineland", "author": "stox", "description": "sin", "tags": ["sine"], "likes": 2, "viewed": 110, "published": "Public", "date": "1523494823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n\tfragCoord = fragCoord/iResolution.xy * vec2(3.14159,2.2) - vec2(0,1.1);\n    \n    vec3 col = vec3(0.97, 0.97, 0.97);\n    float thickness = 0.01f;\n    int count = 50;\n    for (int i = 0; i < count; i++)\n    {\n        float value = cos(iTime*5.0 + float(i)/10.0 + cos(float(i))/10.0)*sin(1.7*fragCoord.x + cos(iTime)*3.14)*fragCoord.x/10.0 + 3.0*float(i-(count/2))/float(count);\n\n        float e = 2.2/iResolution.y;\n        col *= smoothstep(-e, e, abs(fragCoord.y - value) - thickness);\n    }\n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldyyW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 587]], "test": "ok"}
{"id": "ls3BDH", "name": "SoundEclipse rpm", "author": "sclavel", "description": "a twist on DuckMonster's SoundEclipse (https://www.shadertoy.com/view/4tGXzt), adding some rotation.\nIt looks better as a visualization in virtualdj with the rotation and beatmove.", "tags": ["visualization", "mic", "virtualdj"], "likes": 60, "viewed": 17349, "published": "Public API", "date": "1524874591", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// credit: https://www.shadertoy.com/view/4tGXzt\n\n#define BEATMOVE 1\n\nconst float FREQ_RANGE = 64.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.6;\nconst float BRIGHTNESS = 0.2;\nconst float SPEED = 0.5;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat getfrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 doHalo(vec2 fragment, float radius) {\n\tfloat dist = length(fragment);\n\tfloat ring = 1.0 / abs(dist - radius);\n\t\n\tfloat b = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcol += hsv2rgb( vec3( ( angle + iTime * 0.25 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\n\t\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcol *= frequency;\n\t\n\t// Black halo\n\tcol *= smoothstep(radius * 0.5, radius, dist);\n\t\n\treturn col;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\n\t\n\tfloat freq = abs(fragment.x * 0.5);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\n\tcolor += doHalo(fragPos, RADIUS);\n\n    float c = cos(iTime * SPEED);\n    float s = sin(iTime * SPEED);\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\n\tcolor += doLine(rot, RADIUS, rot.x);\n\t\n\tcolor += max(luma(color) - 1.0, 0.0);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls3BDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 229, 250, 250, 419], [421, 421, 445, 445, 495], [497, 497, 526, 526, 619], [621, 621, 657, 657, 868], [870, 870, 905, 905, 969], [971, 971, 1013, 1013, 1480], [1482, 1482, 1533, 1533, 1785], [1788, 1788, 1845, 1845, 2278]], "test": "error"}
{"id": "ls3fD8", "name": "MY EYES ARE BLEEDING 2", "author": "slerpy", "description": "A redo of one of my least popular shaders, because why not", "tags": ["3d", "simple", "eyes", "fake", "burning", "flickering", "bleeding", "dying"], "likes": 6, "viewed": 120, "published": "Public", "date": "1524854432", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat3 rx(float a){ float s=sin(a), c=cos(a); return mat3(1.,0.,0.,0.,+c,+s,0.,-s,+c); }\nmat3 ry(float a){ float s=sin(a), c=cos(a); return mat3(+c,0.,+s,0.,1.,0.,-s,0.,+c); }\nmat3 rz(float a){ float s=sin(a), c=cos(a); return mat3(+c,+s,0.,-s,+c,0.,0.,0.,1.); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    float mTime = mod(iTime, 65.);\n    \n\tvec2 uv = (.7+3.*exp(-mTime)) * (2.*fragCoord.xy-iResolution.xy) / iResolution.y;\n    \n    float a = dot(uv,uv);\n    vec3 sn = vec3(pow(0.1*a, 0.1));\n    \n    if(3.*a < 1.)\n    {\n    \tfloat t = (2.-sqrt(1.-3.*a))/(1.+a);\n    \tsn = vec3(t*uv, t-2.);\n        sn *= rx(-.2*iTime) * ry(iTime);\n    }\n    \n    vec3 yv = fract(exp(.2*mTime)*mTime*sn);\n    float y = yv.x * yv.y * yv.z;\n    \n    fragColor = vec4(y);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls3fD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 86], [87, 87, 104, 104, 173], [174, 174, 191, 191, 260], [262, 262, 319, 319, 797]], "test": "ok"}
{"id": "lscfRM", "name": "Teleporter", "author": "watusimoto", "description": "Bitfighter teleporter (http://bitfighter.org)", "tags": ["2dbitfighter"], "likes": 5, "viewed": 242, "published": "Public", "date": "1524499923", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159\n#define tau (2.0 * pi)\n\n// Gold Noise ©2017-2018 dcerisano@standard3d.com\n// - based on the Golden Ratio, PI and the Square Root of Two\n// - fastest noise generator function\n// - works with all chipsets (including low precision)\n\nprecision lowp    float;\n\nfloat PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   \nfloat PI  = 3.14159265358979323846264 * 00000.1; // PI\nfloat SQ2 = 1.41421356237309504880169 * 10000.0; // Square Root of Two\n\nfloat gold_noise(in vec2 coordinate, in float seed){\n    return fract(sin(dot(coordinate*(seed+PHI), vec2(PHI, PI)))*SQ2);\n}\n\n\n\nvec3 getColor(vec2 fragCoord, float time, vec3 color, float theta, float rad, float len, float life, float dist, float ang) {\n       \n    float beamWidth = 2.0;\n    float timeLived = mod(time, life);\n\n    rad -= timeLived * rad / life;\t\t\t// Reduce radius as we spiral towards center\n\n\n    float angdiff = theta - ang;\t\t\t// Angle between pixel and head of tracker\n    if(angdiff < 0.0) \n        angdiff += tau;\n\n    float alpha = 0.0;\n    if(dist > (rad - beamWidth * (1.0 - angdiff)) && dist < rad + beamWidth + angdiff)\n        alpha = (1.0 - angdiff / len) * smoothstep(0.1, 1.0, timeLived/life + .4);\n    \n  \treturn vec3(color * alpha);\n}\n\n\nvec3 getBaseColor(int index) {\n    \n    if(index == 1)\n     \treturn vec3( 0.0, 0.25, 0.8 );\n    if(index == 2)\n     \treturn vec3( 0.0, 0.5,  1.0 );\n    if(index == 3)\n     \treturn vec3( 0.0, 0.0,  1.0 );\n    if(index == 4)\n     \treturn vec3( 0.0, 1.0,  1.0 );\n    if(index == 5)\n     \treturn vec3( 0.0, 0.5,  0.5 );\n    if(index == 6)\n     \treturn vec3( 0.0, 0.0,  1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float rad =  80.0;\n    \n    \n    const int trackers = 100;\n    #define baseColorCount 6\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 cen = iResolution.xy / 2.0;\n    float dist = distance(fragCoord, cen);\n\n       \n    vec3 color = vec3(0.0);\t// Start with black; we'll add up colors as we go\n    \n    if(dist < rad) {\n    \tfloat ang = -atan(fragCoord.y - cen.y, fragCoord.x - cen.x);\n\n        for(int i = 0; i < trackers; i++) {\n\n            float fi = float(i);\n\n            float life = 5.0 + 4.0 * gold_noise(vec2(fi),fi);\n            float len = 0.25 + 1.75 * gold_noise(vec2(fi)*3.0, fi); // in radians\n            float theta = mod(iTime * (0.5 +  2.0 * gold_noise(vec2(fi)*2.0,fi)), tau) - pi;\n\n            int colorIndex = int(mod(fi,float(baseColorCount)));\n\n            vec3 baseColor = getBaseColor(colorIndex);\n\n            vec3 col = getColor(fragCoord, iTime, baseColor, theta, rad, len, life, dist, ang);\n\n            color += col;\n        }\n    }\n\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lscfRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[471, 471, 523, 523, 595], [599, 599, 724, 724, 1240], [1243, 1243, 1273, 1273, 1616], [1619, 1619, 1676, 1676, 2770]], "test": "error"}
{"id": "lscfz8", "name": "DomainDistortion2", "author": "ChloeSnyder", "description": "566", "tags": ["566"], "likes": 1, "viewed": 58, "published": "Public", "date": "1524012053", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define deg2rad PI / 180.0\n\n// RAY MARCHING CODE SOURCE JAMIE WONG\nconst int MAX_MARCHING_STEPS = 100;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 500.0;\nconst float EPSILON = 0.0001;\nconst float EPSILON_NORM = .001;\n\nvec3 K_d = vec3(-1.0, -1.0, -1.0); // diffuse color\nfloat shininess;\n\nfloat noise( in vec2 x )\n{\n\treturn sin(1.5*x.x)*sin(1.5*x.y);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n//sdSphere(p - vec3(0.0, -2.0, 0.0), .40)\nfloat opTwist( vec3 p )\n{\n    float c = cos(20.0*p.y) + noise(p.xy);\n    float s = sin(20.0*p.y) + noise(p.xy);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdSphere(q/2.0, .40);\n}\n\n\n\n/**\n * Rotation matrix around the X axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// modified from jamie wong\nvec3 scaleOp(vec3 samplePoint, vec3 scale)\n{\n\treturn (samplePoint / scale) * min(scale.x, min(scale.y, scale.z));\n}\n\n//JW\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n//JW\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n//JW\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n// iq\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n// iq\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n//iq\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n// iq\nfloat cylinderSDF( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//http://glslsandbox.com/e#40928.0\nvoid Rotate( inout vec2 p, float a ) \n{\n    p = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\n\n//http://glslsandbox.com/e#40928.0\nfloat saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\n//http://glslsandbox.com/e#40928.0\nfloat Smooth( float x )\n{\n\treturn smoothstep( 0.0, 1.0, saturate( x ) );   \n}\n\n\n\n// Based off: //http://glslsandbox.com/e#40928.0\nfloat noodle (vec3 p)\n{\n   \n    float scale = 1.0 - 2.5 * saturate( abs( p.y ) * 0.01 );  \n    //p.x -= sin( p.y * 2.0 + iTime * 10.0 ) * 0.1; //controls animation of tentacle\n   \n    \n    // For ret: sdCapsule, second argument defines lower end point, third is upper end point\n    // p is the point being evaluated, last argument is thickness\n    float cap = sdCapsule(p, vec3( 0.0, -2.0, 0.0 ), vec3( 0.0, 4.0, 0.0 ), 0.3 * scale );\n\t\n    // want more tapering at the end\n    float cone = sdCone(rotateX(-PI/2.0) * p + vec3(0.0, 0.0, -1.0), normalize(vec2(1.5, .30)));//sdCappedCone(p , vec3(1.0, 1.0, 1.0));\n    //return cone;\n    float f = smin(cone, cap, -.5);\n    \n    return smin(f, opTwist(p - vec3(0.0, -2.0, 0.0)), .1);//sdSphere(p - vec3(0.0, -2.0, 0.0), .40));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat suctionCup(vec3 p, float scale)\n{\n    \n    vec3 cp = rotateX(-PI/2.0) * p;\n    float outer = cylinderSDF(cp, vec2(1.0, .30) / scale);\n    float inner = cylinderSDF(cp, vec2(.25, .5) / scale);\n    \n    float mid = differenceSDF(outer, inner);\n\n   \n    if(mid <= 0.0 + EPSILON)\n    {\n        K_d = vec3(1.0, 0.0, 1.0);\n    } \n\n    return mid;\n}\n\n\n//http://glslsandbox.com/e#40928.0\nfloat Tentacle( vec3 p )\n{\n    p.x -= sin( p.y * 2.0 + iTime * 10.0 ) * 0.1;\n    \n    float noodle = noodle(p); // The \"main body\" of the tentacle\n    if(noodle < 0.0 + EPSILON)\n    {\n        K_d = vec3(1.0, 0.0, 0.0);\n    } \n    \n    float scale = 150.0;\n    p += vec3(0.0, -.70, 0.0);\n    vec3 sc_p1 = p - vec3(0.01, 0.0, 0.02);\n    vec3 sc_p2 = p - vec3(-0.01, 0.0, 0.02);\n    \n    \n    sc_p1 = rotateY(PI/4.0) * sc_p1;\n    sc_p2 = rotateY(-PI/4.0) * sc_p2;\n    float sc1 = suctionCup(sc_p1, scale);\n    float sc2 = suctionCup(sc_p2, scale);\n    float sc = unionSDF(sc1, sc2);\n    \n    \n    // first six suction cups: start small and scale bigger\n    // as they are placed from the tip towards the base\n    // also, rotate so that they lie \"on\" the surface of the tentacle\n    for(int i = 0; i < 6; i++)\n    {\n        scale /= 1.45;\n        sc_p1 += vec3(-0.00005, .05 * float(i),float(i) * -0.0085);\n        sc_p2 += vec3(0.00005, .05 * float(i),float(i) * -0.0085);\n        sc1 = suctionCup(sc_p1, scale);\n        sc2 = suctionCup(sc_p2, scale);\n        sc = unionSDF(sc, sc1);\n        sc = unionSDF(sc, sc2);\n    }\n    \n    sc_p1 = rotateY(-PI/8.0) * sc_p1;\n    sc_p2 = rotateY(PI/8.0) * sc_p2;\n    \n    // Once close enough to the base, can be the same size and rotation\n    for(int j = 6; j < 14; j++)\n    {\n        if(j > 12)\n        {\n            sc_p1 = rotateY(PI/16.0) * sc_p1;\n    \t\tsc_p2 = rotateY(-PI/16.0) * sc_p2;\n        }\n        sc_p1 += vec3(0, .25 , -0.0176);\n        sc_p2 += vec3(0, .25 , -0.0176);\n        sc1 = suctionCup(sc_p1, scale);\n        sc2 = suctionCup(sc_p2, scale);\n        sc = unionSDF(sc, sc1);\n        sc = unionSDF(sc, sc2);\n    }\n    \n   \n    float f = smin(noodle, sc, .01);\n    return f;//unionSDF(f, sdSphere(p - vec3(0.0, .50, 0.0), .40));\n  \n}\n\n// iq\n\n\nfloat opCheapBend( vec3 p )\n{\n    float c = cos(p.y) + noise(p.xy);\n    float s = sin(p.y) ;//+ noise(p.xy);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    \n    // TODO: the bounding capsule has to go here.\n    float scale = 1.0 - 2.5 * saturate( abs( p.y ) * 0.01 );  \n    float boundingCapsule = sdCapsule(p, vec3( 0.0, -30.0, 0.0 ), vec3( 0.0, 4.0, 0.0 ),  scale );\n    if(boundingCapsule < .015)\n    {\n        return Tentacle(p);\n        \n    } else {\n       // K_d = vec3(noise(p.xy), noise(p.xz), noise(p.yz));\n        return boundingCapsule;\n    }\n}\n\n\nfloat opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return opCheapBend( q );\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    \n    vec3 p = samplePoint;\n    \n  // return opRep(p, vec3(4.0, 0.0, 5.0));\n   \n    \n    /*if(boundingCapsule < .015)\n    {\n        //return Tentacle(p);\n        return opRep(p, vec3(0.0, 0.0, PI));\n    } else {\n        return boundingCapsule;\n    }*/\n    \n    \n     float tentacleRing = opRep(samplePoint, vec3(2.0, 0.0, 10));//-1.0;//-1.0;\n    float amplitude = 1.0;\n    int numTentacles = 3;\n   \n    float gap = 360.0 / float(numTentacles) * deg2rad;\n    \n    for (int i = 0; i < numTentacles; i++)\n    {\n        float angle = float(i) * gap;     \n             \n        float offsetX = (amplitude) * sin(angle);\n    \tfloat offsetY = (amplitude) * cos(angle);\n        \n        vec3 localP = p;\n        localP += vec3(offsetX, offsetY, 0.0);\n        localP = rotateZ(-angle) * localP;\n        float tentacle = opRep(localP, vec3(float(i) * PI, 0.0, float(i) * PI));\n        \n        \n        tentacleRing = unionSDF(tentacle, tentacleRing);\n       // tentacleRing = unionSDF(tentacleRing, sdSphere(localP, 1.0));\n    }\n    \n    \n   /* for(int i = 0; i < numTentacles; i++)\n    {\n\n       \tfloat angle = float(i) * gap;     \n             \n        float offsetX = (amplitude) * sin(angle);\n    \tfloat offsetY = (amplitude) * cos(angle);\n        \n        vec3 localP = p;\n        localP += vec3(offsetX, offsetY, 0.0);\n        localP = rotateZ(-angle) * localP;\n        \n        float scale = 1.0 - 2.5 * saturate( abs( localP.y ) * 0.01 );  \n    \tfloat boundingCapsule = sdCapsule(localP, vec3( 0.0, -2.0, 0.0 ), vec3( 0.0, 4.0, 0.0 ), 0.5 * scale );\n\t\tif(boundingCapsule < .015)\n        {\n            float tentacle = opRep(localP, vec3(2.0, 0.0, 10));\n        \tif(tentacleRing == -1.0)\n        \t{\n            \ttentacleRing = tentacle;\n        \t}\n      \n        \ttentacleRing = unionSDF(tentacle, tentacleRing);\n        }   else {\n            tentacleRing = unionSDF(boundingCapsule, tentacleRing);\n        }\n    }\n    */\n        \n    return tentacleRing;\n    \n    \n  //  return opRep(samplePoint, vec3(0.0, 0.0, PI));\n    //return opCheapBend(samplePoint);\n   // return opTwist(samplePoint);\n   //return(Tentacle(samplePoint));\n\n}\n\n\n/** JW\n * \n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/** JW\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/** JW\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON_NORM, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON_NORM, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON_NORM, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON_NORM, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON_NORM)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON_NORM))\n    ));\n}\n\n\nfloat lambert(vec3 N, vec3 L)\n{\n  vec3 nrmN = normalize(N);\n  vec3 nrmL = normalize(L);\n  float result = dot(nrmN, nrmL);\n  return max(result, 0.0);\n}\n\n\n/** JW\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nmat2 rot(float a) \n{\n    vec2 s = sin(vec2(a, a + PI/2.0));\n    return mat2(s.y,s.x,-s.x,s.y);\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 10.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    \n    /*  vec3 rayDir = cam* normalize( vec3(screenPos.xy,2.0) );\n    rayDir.xy *= rot(iTime*0.1);\n    float dist = rayMarch(rayDir, cameraOrigin);*/\n    // https://www.shadertoy.com/view/4slyRs\n   // worldDir.xy *= rot(iTime*.2);\n    \n    \n //   worldDir.x += fbm6(worldDir.xy);\n //   worldDir.xy *= rot(iTime * fbm6(worldDir.xy));\n    worldDir.xz *= rot(cos(iTime) * fbm6(worldDir.xy));\n    worldDir.xy *= rot(sin(iTime));\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        //fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n       // fragColor = vec4(fbm4(iTime * fragCoord), iTime * fbm6(fragCoord), iTime * noise(iTime * fragCoord), 1.0);\n\t\tfragColor = vec4(fbm4(iTime * fragCoord), 0.0, 0.0, 1.0);\n\n        return;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    \n    vec3 color = K_d * lambert(estimateNormal(p), eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lscfz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[320, 320, 346, 346, 383], [385, 385, 420, 420, 444], [445, 487, 512, 512, 695], [699, 783, 810, 810, 957], [959, 1043, 1070, 1070, 1217], [1219, 1303, 1330, 1330, 1477], [1479, 1507, 1551, 1551, 1622], [1624, 1629, 1675, 1675, 1707], [1709, 1714, 1756, 1756, 1788], [1790, 1795, 1842, 1842, 1875], [1877, 1883, 1924, 1924, 2017], [2020, 2026, 2078, 2078, 2205], [2207, 2212, 2244, 2272, 2333], [2335, 2341, 2378, 2378, 2477], [2479, 2514, 2553, 2553, 2608], [2611, 2646, 2673, 2673, 2708], [2710, 2745, 2770, 2770, 2822], [2826, 2875, 2898, 2898, 3649], [3651, 3651, 3684, 3684, 3749], [3751, 3751, 3790, 3790, 4099], [4102, 4137, 4163, 4163, 5929], [5939, 5939, 5968, 5968, 6514], [6517, 6517, 6548, 6548, 6608], [6610, 6610, 6644, 6644, 8778], [8781, 8796, 8887, 8887, 9193], [9208, 9219, 9284, 9284, 9416], [9418, 9510, 9539, 9539, 9879], [9882, 9882, 9913, 9913, 10032], [10035, 10365, 10414, 10449, 10675], [10677, 10677, 10697, 10697, 10773], [10826, 10826, 10848, 10848, 11044], [11046, 11046, 11068, 11068, 11421], [11423, 11423, 11480, 11480, 12793]], "test": "timeout"}
{"id": "lscfzn", "name": "Fractal Noise - After Effects", "author": "alijaya", "description": "Try to recreate fractal noise from after effects.\nIt's Value noise", "tags": ["fractal", "noise"], "likes": 8, "viewed": 819, "published": "Public API", "date": "1523918661", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * 0: basic\n * 1: turbulent smooth\n * 2: turbulent basic\n * 3: turbulent sharp\n * 4: dynamic\n */\nint fractalType = 3;\n/*\n * 0: block\n * 1: linear\n * 2: softlinear\n * 3: spline\n */\nint noiseType = 3;\n\nbool invert = false;\nfloat contrast = 1.;\nfloat brightness = 0.;\n/*\n * 0: clip\n * 1: soft clamp\n * 2: wrap back\n * 3: allow hdr results\n */\nint overflow = 3;\n\n// transform\nfloat rotation = 0.; // in Periode\nvec2 scale = vec2(32., 32.);\nvec2 offsetTurbulence = vec2(0., 0.);\n\nfloat complexity = 5.;\n\n// sub settings\nfloat subInfluence = 0.7;\nfloat subScaling = 0.57;\nfloat subRotation = 0.; // in Periode\nvec2 subOffset = vec2(0., 0.);\nbool centerSubscale = false;\n\nfloat evolution = 0.; // in Periode\nbool cycleRevolution = false;\nint cycle = 1; // not used if cycleRevolution is false\n\nint randomSeed = 0;\n\n#define SIZE 64.0\n#define PI acos(-1.)\n#define TAU 2.*PI\n#define toRad PI/180.\n#define toDeg 180./PI\n\n// copy from https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec2 flip(vec2 coord) {\n    return vec2(coord.x, iResolution.y - coord.y);\n}\n\nfloat bicubic(float a, float b, float c, float d, float t) {\n    float p = - a / 2. + b * 3./2. - c * 3./2. + d / 2.;\n    float q = a - b * 5./2. + c * 2. - d / 2.;\n    float r = - a / 2. + c / 2.;\n    float s = b;\n    \n    return p * t*t*t + q * t*t + r * t + s;\n}\n\nfloat wrap(float value, float minValue, float maxValue) {\n    return mod((value - minValue), (maxValue - minValue)) + minValue;\n}\n\n// Fractal Type\n\nfloat basic(float f) {\n    return f;\n}\n\nfloat turbulentBasic(float f) {\n    return abs(f - 0.5) * 2.;\n}\n\nfloat turbulentSmooth(float f) {\n    float x = turbulentBasic(f);\n    return x*x;\n}\n\nfloat turbulentSharp(float f) {\n    float x = turbulentBasic(f);\n    return sqrt(x);\n}\n\nfloat selectFractal(float f) {\n    float ret = 0.;\n    if (fractalType == 0) {\n        ret = basic(f);\n    } else if (fractalType == 1) {\n        ret = turbulentSmooth(f);\n    } else if (fractalType == 2) {\n        ret = turbulentBasic(f);\n    } else if (fractalType == 3) {\n        ret = turbulentSharp(f);\n    } else {\n        ret = basic(f);\n    }\n    return ret;\n}\n\n// Cycle\n\nfloat selectCycle(float value, float base, float periode) {\n    float ret = 0.;\n    if (cycleRevolution) {\n        ret = wrap(value, base, base + periode);\n    } else {\n        ret = value;\n    }\n    return ret;\n}\n\n// Noise Type\n\nfloat block(vec2 fragCoord, float depth) {\n    float randf = float(randomSeed);\n    if (centerSubscale) randf += depth;\n    vec3 hash = hash33(vec3(floor(fragCoord), randf));\n    float freq = hash.x; // random freq for each coord\n    float periode = 1. + floor(freq * float(cycle + 1));\n    if (cycleRevolution) {\n        freq = periode / float(cycle);\n    }\n    float evo = evolution * freq + hash.y;\n    float e = randf + floor(evo); // evolution here\n    float f = fract(evo);\n    \n    float a = hash33(vec3(floor(fragCoord), selectCycle(e - 1., randf, periode))).x;\n    float b = hash33(vec3(floor(fragCoord), selectCycle(e + 0., randf, periode))).x;\n    float c = hash33(vec3(floor(fragCoord), selectCycle(e + 1., randf, periode))).x;\n    float d = hash33(vec3(floor(fragCoord), selectCycle(e + 2., randf, periode))).x;\n    \n    return bicubic(a, b, c, d, f);\n}\n\nfloat linear(vec2 fragCoord, float depth) {\n    fragCoord -= 0.5;\n    float tl = block(fragCoord, depth);\n    float tr = block(fragCoord + vec2(1., 0.), depth);\n    float bl = block(fragCoord + vec2(0., 1.), depth);\n    float br = block(fragCoord + vec2(1., 1.), depth);\n    \n    vec2 f = fract(fragCoord);\n    return mix(mix(tl, tr, f.x), mix(bl, br, f.x), f.y);\n}\n\nfloat softLinear(vec2 fragCoord, float depth) {\n    fragCoord -= 0.5;\n    float tl = block(fragCoord, depth);\n    float tr = block(fragCoord + vec2(1., 0.), depth);\n    float bl = block(fragCoord + vec2(0., 1.), depth);\n    float br = block(fragCoord + vec2(1., 1.), depth);\n    \n    vec2 f = fract(fragCoord);\n    f = smoothstep(0., 1., f);\n    return mix(mix(tl, tr, f.x), mix(bl, br, f.x), f.y);\n}\n\nfloat spline(vec2 fragCoord, float depth) {\n    fragCoord -= 0.5;\n    \n    float ttll = block(fragCoord + vec2(-1., -1.), depth);\n    float ttl = block(fragCoord + vec2(0., -1.), depth);\n    float ttr = block(fragCoord + vec2(1., -1.), depth);\n    float ttrr = block(fragCoord + vec2(2., -1.), depth);\n                       \n    float tll = block(fragCoord + vec2(-1, 0.), depth);\n    float tl = block(fragCoord, depth);\n    float tr = block(fragCoord + vec2(1., 0.), depth);\n    float trr = block(fragCoord + vec2(2, 0.), depth);\n    \n    float bll = block(fragCoord + vec2(-1., 1.), depth);\n    float bl = block(fragCoord + vec2(0., 1.), depth);\n    float br = block(fragCoord + vec2(1., 1.), depth);\n    float brr = block(fragCoord + vec2(2., 1.), depth);\n    \n    float bbll = block(fragCoord + vec2(-1., 2.), depth);\n    float bbl = block(fragCoord + vec2(0., 2.), depth);\n    float bbr = block(fragCoord + vec2(1., 2.), depth);\n    float bbrr = block(fragCoord + vec2(2., 2.), depth);\n                       \n    vec2 f = fract(fragCoord);\n    \n    float tt = bicubic(ttll, ttl, ttr, ttrr, f.x);\n    float t = bicubic(tll, tl, tr, trr, f.x);\n    float b = bicubic(bll, bl, br, brr, f.x);\n    float bb = bicubic(bbll, bbl, bbr, bbrr, f.x);\n    \n    return bicubic(tt, t, b, bb, f.y);\n}\n\n// Overflow\n\nfloat clipOverflow(float value) {\n    return clamp(value, 0., 1.);\n}\n\nfloat softClampOverflow(float value) {\n    return 1. / (1. + exp(2. - 4.*value));\n}\n\nfloat wrapBackOverflow(float value) {\n    return abs(value - 2.*floor(value*0.5 + 0.5));\n}\n\nfloat allowHdrResultsOverflow(float value) {\n    return value;\n}\n\nfloat selectOverflow(float value) {\n    float ret = 0.;\n    if (overflow == 0) {\n        ret = clipOverflow(value);\n    } else if (overflow == 1) {\n        ret = softClampOverflow(value);\n    } else if (overflow == 2) {\n        ret = wrapBackOverflow(value);\n    } else if (overflow == 3) {\n        ret = allowHdrResultsOverflow(value);\n    } else {\n        ret = allowHdrResultsOverflow(value);\n    }\n    return ret;\n}\n\nfloat layer(vec2 fragCoord, float depth) {\n    float ret = 0.;\n    if (noiseType == 0) {\n        ret = block(fragCoord, depth);\n    } else if (noiseType == 1) {\n        ret = linear(fragCoord, depth);\n    } else if (noiseType == 2) {\n        ret = softLinear(fragCoord, depth);\n    } else if (noiseType == 3) {\n        ret = spline(fragCoord, depth);\n    } else {\n        ret = spline(fragCoord, depth);\n    }\n    return selectFractal(ret);\n}\n\nmat3 inverseMatrix(vec2 translate, float rotate, vec2 scale) {\n    return transpose(mat3(\n        cos(-rotate)/scale.x, -sin(-rotate)/scale.x, -translate.x,\n        sin(-rotate)/scale.y, cos(-rotate)/scale.y, -translate.y,\n        0., 0., 1.\n    ));\n}\n\nvoid transformed( out vec4 fragColor, in vec2 fragCoord ) {\n    mat3 matrix = inverseMatrix(subOffset, subRotation * TAU, vec2(subScaling));\n    \n    float val = 0.;\n    \n    float totalWeight = 0.;\n    mat3 trans = mat3(1.);\n    float weight = 1.;\n    for (float i=1.; i<complexity; i++) {\n        vec2 newCoord = (trans * vec3(fragCoord, 1.)).xy;\n        val  += layer(newCoord, i) * weight;\n        \n        totalWeight += weight;\n        \n        trans = matrix * trans;\n        weight *= subInfluence;\n    }\n    \n    float f = fract(complexity);\n    if (f == 0.) f = 1.;\n    \n    vec2 newCoord = (trans * vec3(fragCoord, 1.)).xy;\n    val  += layer(newCoord, floor(complexity)+1.) * weight * f;\n\n    totalWeight += weight * f;\n    \n    val /= totalWeight;\n\n    // color\n    \n    if (invert) {\n        val = 1. - val;\n    }\n    val = (val - 0.5) * contrast + 0.5;\n    val += brightness;\n    \n    val = selectOverflow(val);\n    \n    fragColor = vec4(vec3(val),1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    evolution = iTime;\n    \n    vec2 flipCoord = flip(fragCoord);\n    mat3 trans = inverseMatrix(offsetTurbulence, rotation * TAU, scale);\n    flipCoord = (trans * vec3(flipCoord, 1.)).xy;\n    transformed(fragColor, flipCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lscfzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1011, 1011, 1033, 1033, 1142], [1144, 1144, 1167, 1167, 1220], [1222, 1222, 1282, 1282, 1487], [1489, 1489, 1546, 1546, 1618], [1637, 1637, 1659, 1659, 1675], [1677, 1677, 1708, 1708, 1740], [1742, 1742, 1774, 1774, 1825], [1827, 1827, 1858, 1858, 1913], [1915, 1915, 1945, 1945, 2283], [2295, 2295, 2354, 2354, 2508], [2525, 2525, 2567, 2567, 3391], [3393, 3393, 3436, 3436, 3758], [3760, 3760, 3807, 3807, 4160], [4162, 4162, 4205, 4205, 5453], [5468, 5468, 5501, 5501, 5536], [5538, 5538, 5576, 5576, 5621], [5623, 5623, 5660, 5660, 5713], [5715, 5715, 5759, 5759, 5779], [5781, 5781, 5816, 5816, 6200], [6202, 6202, 6244, 6244, 6644], [6646, 6646, 6708, 6708, 6897], [6899, 6899, 6958, 6958, 7867], [7869, 7869, 7926, 7926, 8156]], "test": "timeout"}
{"id": "lsdBD8", "name": "Logo experiment #1", "author": "Cierpliwy", "description": "Logo experiment #1", "tags": ["logoprocedural"], "likes": 0, "viewed": 5945, "published": "Public", "date": "1524983645", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nvec4 logo(in vec2 uv, float time) {\n    float rad = atan(-uv.y, uv.x) + time * 0.1;\n    float r = length(uv * smoothstep(0.0, 1.0, time)) - tan(rad * 3.0) * 0.1;\n    float rayv = fract((rad - sin(r * 64.0 + time * 4.0) * r / 32.0) / PI * 16.0);\n    float ray = smoothstep(0.45, 0.5, rayv) * smoothstep(0.9, 0.85, rayv);\n    float circle = smoothstep(1.0, .2, r);     \n    float circle2 = smoothstep(0.2, 0.4, r);\n    float radiance = 0.6 + 0.4 * fract((1.0 - r*r) * 16.0 - time);\n    return circle * circle2 * radiance * (mix(vec4(0.278, 0.733, 0.831, 1.0), vec4(0.145, 0.541, 0.627, 1.0), ray));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = fract(iTime / 4.0) * 5.0;\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y * (1.0 + smoothstep(4.0, 5.0, time) * 2048.0);\n    fragColor = logo(uv, time) / dot(uv, uv) / 4.0 * smoothstep(0.0,1.0,time) * (1.0 - smoothstep(3.5, 4.5, time));\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsdBD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 61, 61, 625], [627, 627, 684, 684, 958]], "test": "ok"}
{"id": "lsdBRN", "name": "Easyp Radar", "author": "easyp", "description": "Radar", "tags": ["radar"], "likes": 0, "viewed": 100, "published": "Public", "date": "1524347986", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float interval = .8;\nconst float cycle = .5;\nconst float gradient = 2.;\nconst float speed = .8;\n\nconst float angle = radians(135.);\n\nconst vec3 color = vec3(0.3, 1., 0.2);\n\n#define RADIAL 0\n#define SOLID 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.x;\n    \n    float r = angle;\n    vec2 dir = normalize(vec2(sin(r), cos(r)));\n    vec2 p = vec2(0.5, 0.5 * (iResolution.y / iResolution.x));\n  \n    float m = gradient;\n    float b = mod(iTime * speed, interval);\n    \n#if RADIAL\n    float x = -distance(uv, p);\n#else \n    float x = -dot(uv, dir);\n#endif\n    \n    float y = (m * x) + b;\n    y = mod(y, interval) * (1./cycle);\n    \n#if SOLID\n    y = round(y);\n#endif\n    \n    // Output to screen\n    fragColor = vec4(color - y, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsdBRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[213, 213, 270, 270, 790]], "test": "error"}
{"id": "lsdfD8", "name": "helix 6 ( triple helix DNA)", "author": "FabriceNeyret2", "description": "use ds = .5 for better qualitty (but slower).\n\nNB: adding a far plan increases perf by 50%  (  t = abs(q.z+2e3) before rots )", "tags": ["raymarching", "sdf", "spiral", "helix", "spring", "short"], "likes": 18, "viewed": 795, "published": "Public API", "date": "1524989712", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of \"helix 5b ( triple helix )\" https://shadertoy.com/view/XdtfD8\n//                    and \"helix 4 (DNA)\" https://www.shadertoy.com/view/XddBD8\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t = iTime/2.+11., l,a,d,v, ds = 1.,  // ds=.5 for better look\n          r0 = 200., r1 = 20., n = 3.82,       // n = 24/2pi\n          A = 2.38, H = 4.*cos(A/2.);\n    mat2  R = mat2( sin(t+vec4(0,33,11,0)) );  \n    vec3  q = iResolution,\n          D = normalize(vec3(.3*(U+U-q.xy)/q.y, -1)).zxy,  // ray direction\n          c, p // = 30./q;                     // marching point along ray \n               = vec3(-30.*(iTime-2.),-2,-15.); D.yz*=R;\n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015*ds )\n        q = p, //q.xz *= R, q.yz *= R,         // rotation (could be factored out loop on p,D)\n\n        c = q, c.z += r0, a = atan(c.y,c.z), \n        q.z = length(c.zy)-r0, q.y = r0*a, q.x = mod(q.x-a*r0/6.3,r0)-r0/2.,// large helix\n        c = q, c.x += r1, a = atan(c.z,c.x), \n        q.x = length(c.xz)-r1, q.z = r1*a, q.y = mod(q.y-a*r1/6.3,r1)-r1/2.,// medium helix\n\n        l = length(q.xy), a = atan(q.y,q.x), d = a-q.z,\n        d = min( abs( mod(d  ,6.28) -3.14), \n                 abs( mod(d-A,6.28) -3.14) ),  // double strand (~2pi/3)\n        t = length( vec3( l-4., d, fract(n*a)-.5 ) ) - .3, // spheres along spring\n        d = a - round(q.z*n)/n -A/2. -3.14 +.5/n,\n        d = ( length(vec2( (fract(q.z*n-.5)-.5)/n, l*cos(d)-H ))-.05 )/n, //rods\n        t = min( t, v=max(l-4.,d) ),           // bounded rods\n        p += ds*t*D;                           // step forward = dist to obj\n\n    if (t==v) O.rg *= .9; else O.gb *= .9;     // colored rods vs spheres\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsdfD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 193, 193, 1690]], "test": "error"}
{"id": "lsdfRM", "name": "Procedural Thread Texture Model ", "author": "stuck_in_math", "description": "Implementation of \"A Procedural Thread Texture Model by Neeharika Adabala and Nadia Magnenat-Thalmann\"\nfound here (5 pages total with reference images)\nhttps://www.researchgate.net/publication/230605029_A_Procedural_Thread_Texture_Model", "tags": ["procedural", "2d", "cloth", "weave", "thread", "yarn"], "likes": 5, "viewed": 183, "published": "Public", "date": "1524557875", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// First I implemented model in full\n// When it weren't behaving as it should i started commenting out parts trying to pinpoint\n// problematic spot\n// It seems to be displacement calculation that is a problem \n// but maybe there is something in twist_trajectory calculation also\n//\n// Commenting out all parts that seem irrelevant to the problem \n// as to concentrate just on the problematic spot \n\n// UPDATE: FIXED, displacement calculation indeed was lacking small detail which is \n// thickness change compensation at the beginning of formula \n// instead of just ( 2.0 ) we need ( 2.0 / thickness )\n// uncommenting full model\n\n#define M_PI 3.1415926535897932384626433832795\n\n// Used to perturb the value of the displacement for rough thread appearance\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat remap( float range_a_point, float a0, float a1, float b0, float b1 ){\n    return (((range_a_point - a0) * (abs(b1-b0)))/abs(a1-a0)) + b0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float x = uv.x * 5.;\n    float y = uv.y * 1.;\n    \n    \n    // When the facet length increases, if we still keep x and y varying between [0,1], \n    // then the texture stretches to facetlength and would appear loose. \n    // By increasing the tightness by a factor of facetlength, the thread appears tight again \n    \n    float facetlength = 5.0;\n    float tightness = 0.5; // (0,1]\n    float twist_trajectory = \n        ( ( asin( 2. * y - 1. )/( M_PI / 2. ) + 1. ) * tightness * facetlength ) / 2.; // (1)\n    \n    \n    // The trajectory of the twist in equation (1) is used to deﬁne the shading by \n    // considering the distance/displacement of a point from the trajectory\n    // where thickness indicates the thickness of the bundle that is twisted and has values in (0,1]\n    \n    float thickness = 1. - remap( sin( iTime - M_PI / 2.), -1., 1., 0., 0.6 ); // (0,1]\n    float x_plus_traj = x + twist_trajectory;\n    float displacement = \n        ( 2. / thickness ) * ( x_plus_traj - ( floor( x_plus_traj / thickness ) * thickness) ) - 1.; // (2)\n\n    \n    // To add roughness to the appearance of the twist \n    // we perturb the value of the displacement by a random value\n    // For this a parameter smoothness in [0,1] is introduced\n    // where rand_value has values in [ 0, thickness )\n    \n    float smoothness = 1.; //[0,1]\n    float rand_value = rand( uv ) * thickness;\n    float pdisplacement = \n        smoothness * displacement + ( 1. - smoothness) * rand_value; // (3)\n    \n    \n    // When the displacement is zero we would like the shading to be maximum \n    // and as the displacement increases we would like the value to decrease \n    // therefore we use the Gaussian function to achieve this behavior \n    \n    float twist_shading = exp( -(  pow( pdisplacement, 2. )/0.5 ) ); // (4)\n    \n    // Linear shading also looks great\n    // twist_shading = abs(pdisplacement);\n    \n    // The appearance of a thread facet is created by \n    // modulating the above shading of the twist of ﬁbers with \n    // the shading resulting from the shape of the thread. \n    // offset in [0,1] is used to control the darkness of shading at the periphery\n \n    float y_offset = 0.1; // [0,1]\n    float y_shading = y_offset + ( 1. - y_offset ) * sin( y * M_PI );\n    \n    \n    // The same formula can be used for the shading in the x direction \n    // if the thread facet is short. However the length of a facet can vary \n    // depending on the weave pattern, and if the facet is long the above shading \n    // gives the appearance of a wicker basket to the weave \n    // The shading when the thread facet is long is therefore deﬁned with the help \n    // of the tanh function as follows\n    \n    float x_shading = 1.;\n    float x_offset = 0.3; // [0,1]\n    float steepness = facetlength; // facetlength used as in original paper\n    if( uv.x < 0.5 ){\n        x_shading = x_offset + ( 1. - x_offset ) * tanh( uv.x * steepness );\n    }\n    if( uv.x >= 0.5 ){\n        x_shading = x_offset + ( 1. - x_offset ) * tanh( ( 1.0 - uv.x ) * steepness );\n    }\n    \n    // Final calculation of thread appearance\n    float thread_shading = twist_shading * y_shading * x_shading;\n    \n    vec3 col = vec3( thread_shading );\n    \n    // Output to screen\n    fragColor = vec4( col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsdfRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[677, 754, 774, 774, 846], [848, 848, 923, 923, 993], [995, 995, 1052, 1102, 4436]], "test": "ok"}
{"id": "lsGcDK", "name": "Display contents of a vector", "author": "ketschik", "description": "Displays the content of the vec3-vector v.", "tags": ["numbers", "vector", "digits", "vec3"], "likes": 1, "viewed": 169, "published": "Public", "date": "1523358391", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Band(float t, float start, float end, float blur) \n{\n    float step1 = smoothstep(start - blur, start + blur, t);\n    float step2 = smoothstep(end + blur,   end - blur,   t);\n\n    return step1*step2;\n}\n\nfloat Rect(vec2 uv, float l, float r, float bottom, float top, float blur)\n{\n    float band1 = Band(uv.x, l,        r, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n\n    return band1 * band2;\n}\n\nfloat r(vec2 uv, float xBegin, float yBegin, float h, float w) \n{\n    float xEnd = xBegin + w;\n    float yEnd = yBegin + h;\n\t\n    return Rect(uv, xBegin, xEnd, yBegin, yEnd, 0.000001);\n}\n\nfloat draw(vec2 uv, float x, float y, float w, float h, int digit)\n{\n    float f = 0.0;\n\n\tif(digit == 0)\n\t{\n\t\tf += r(uv, x + w * 0., y + h * 4., h, w); f += r(uv, x + w * 1., y + h * 4., h, w); f += r(uv, x + w * 2., y + h * 4., h, w);\n\t    f += r(uv, x + w * 0., y + h * 3., h, w); f += r(uv, x + w * 2., y + h * 3., h, w);\n\t    f += r(uv, x + w * 0., y + h * 2., h, w); f += r(uv, x + w * 2., y + h * 2., h, w);\n\t    f += r(uv, x + w * 0., y + h * 1., h, w); f += r(uv, x + w * 2., y + h * 1., h, w);\n\t    f += r(uv, x + w * 0., y + h * 0., h, w); f += r(uv, x + w * 1., y + h * 0., h, w); f += r(uv, x + w * 2., y + h * 0., h, w);\n\t}\n\t\n\telse if(digit == 1)\n\t{\n\t\tf += r(uv, x + w * 2., y + h * 4., h, w);\n\t    f += r(uv, x + w * 2., y + h * 3., h, w);\n\t    f += r(uv, x + w * 2., y + h * 2., h, w);\n\t    f += r(uv, x + w * 2., y + h * 1., h, w);\n\t    f += r(uv, x + w * 2., y + h * 0., h, w);\n\t}\n\t\n\telse if(digit == 2)\n\t{\n\t    f += r(uv, x + w * 0., y + h * 4., h, w); f += r(uv, x + w * 1., y + h * 4., h, w); f += r(uv, x + w * 2., y + h * 4., h, w);\n\t    f += r(uv, x + w * 2., y + h * 3., h, w);\n\t    f += r(uv, x + w * 0., y + h * 2., h, w); f += r(uv, x + w * 1., y + h * 2., h, w); f += r(uv, x + w * 2., y + h * 2., h, w);\n\t    f += r(uv, x + w * 0., y + h * 1., h, w);\n\t    f += r(uv, x + w * 0., y + h * 0., h, w); f += r(uv, x + w * 1., y + h * 0., h, w); f += r(uv, x + w * 2., y + h * 0., h, w);\n\t}\n\t\n\telse if(digit == 3)\n\t{\n\t\tf += r(uv, x + w * 0., y + h * 4., h, w); f += r(uv, x + w * 1., y + h * 4., h, w); f += r(uv, x + w * 2., y + h * 4., h, w);\n    \tf += r(uv, x + w * 2., y + h * 3., h, w);\n\t    f += r(uv, x + w * 0., y + h * 2., h, w); f += r(uv, x + w * 1., y + h * 2., h, w); f += r(uv, x + w * 2., y + h * 2., h, w);\n\t    f += r(uv, x + w * 2., y + h * 1., h, w);\n\t    f += r(uv, x + w * 0., y + h * 0., h, w); f += r(uv, x + w * 1., y + h * 0., h, w); f += r(uv, x + w * 2., y + h * 0., h, w);\n\t}\n\t\n\telse if(digit == 4)\n\t{\n\t\tf += r(uv, x + w * 0., y + h * 4., h, w); f += r(uv, x + w * 2., y + h * 4., h, w);\n\t    f += r(uv, x + w * 0., y + h * 3., h, w); f += r(uv, x + w * 2., y + h * 3., h, w);\n\t    f += r(uv, x + w * 0., y + h * 2., h, w); f += r(uv, x + w * 1., y + h * 2., h, w); f += r(uv, x + w * 2., y + h * 2., h, w);\n\t    f += r(uv, x + w * 2., y + h * 1., h, w);\n\t    f += r(uv, x + w * 2., y + h * 0., h, w);\n\t}\n\t\n\telse if(digit == 5)\n\t{\n\t\tf += r(uv, x + w * 0., y + h * 4., h, w); f += r(uv, x + w * 1., y + h * 4., h, w); f += r(uv, x + w * 2., y + h * 4., h, w);\n\t    f += r(uv, x + w * 0., y + h * 3., h, w);\n\t    f += r(uv, x + w * 0., y + h * 2., h, w); f += r(uv, x + w * 1., y + h * 2., h, w); f += r(uv, x + w * 2., y + h * 2., h, w);\n        f += r(uv, x + w * 2., y + h * 1., h, w);\n\t    f += r(uv, x + w * 0., y + h * 0., h, w); f += r(uv, x + w * 1., y + h * 0., h, w); f += r(uv, x + w * 2., y + h * 0., h, w);\n\t}\n\t\n\telse if(digit == 6)\n\t{\n\t\tf += r(uv, x + w * 0., y + h * 4., h, w); f += r(uv, x + w * 1., y + h * 4., h, w); f += r(uv, x + w * 2., y + h * 4., h, w);\n\t    f += r(uv, x + w * 0., y + h * 3., h, w);\n\t    f += r(uv, x + w * 0., y + h * 2., h, w); f += r(uv, x + w * 1., y + h * 2., h, w); f += r(uv, x + w * 2., y + h * 2., h, w);\n        f += r(uv, x + w * 0., y + h * 1., h, w); f += r(uv, x + w * 2., y + h * 1., h, w);\n\t    f += r(uv, x + w * 0., y + h * 0., h, w); f += r(uv, x + w * 1., y + h * 0., h, w); f += r(uv, x + w * 2., y + h * 0., h, w);\n\t}\n\t\n\telse if(digit == 7)\n\t{\n\t\tf += r(uv, x + w * 0., y + h * 4., h, w); f += r(uv, x + w * 1., y + h * 4., h, w); f += r(uv, x + w * 2., y + h * 4., h, w);\n\t    f += r(uv, x + w * 2., y + h * 3., h, w);\n\t    f += r(uv, x + w * 2., y + h * 2., h, w);\n\t    f += r(uv, x + w * 2., y + h * 1., h, w);\n        f += r(uv, x + w * 2., y + h * 0., h, w);\n\t}\n\t\n\telse if(digit == 8)\n\t{\n\t    f += r(uv, x + w * 0., y + h * 4., h, w); f += r(uv, x + w * 1., y + h * 4., h, w); f += r(uv, x + w * 2., y + h * 4., h, w);\n\t    f += r(uv, x + w * 0., y + h * 3., h, w); f += r(uv, x + w * 2., y + h * 3., h, w);\n\t    f += r(uv, x + w * 0., y + h * 2., h, w); f += r(uv, x + w * 1., y + h * 2., h, w); f += r(uv, x + w * 2., y + h * 2., h, w);\n\t    f += r(uv, x + w * 0., y + h * 1., h, w); f += r(uv, x + w * 2., y + h * 1., h, w);\n\t    f += r(uv, x + w * 0., y + h * 0., h, w); f += r(uv, x + w * 1., y + h * 0., h, w); f += r(uv, x + w * 2., y + h * 0., h, w);\n\t}\n\t\n\telse if(digit == 9)\n\t{\n\t    f += r(uv, x + w * 0., y + h * 4., h, w); f += r(uv, x + w * 1., y + h * 4., h, w); f += r(uv, x + w * 2., y + h * 4., h, w);\n\t    f += r(uv, x + w * 0., y + h * 3., h, w); f += r(uv, x + w * 2., y + h * 3., h, w);\n\t    f += r(uv, x + w * 0., y + h * 2., h, w); f += r(uv, x + w * 1., y + h * 2., h, w); f += r(uv, x + w * 2., y + h * 2., h, w);\n\t    f += r(uv, x + w * 2., y + h * 1., h, w);\n\t    f += r(uv, x + w * 0., y + h * 0., h, w); f += r(uv, x + w * 1., y + h * 0., h, w); f += r(uv, x + w * 2., y + h * 0., h, w);\n\t}\n\t\n\treturn f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n\tuv *= 3.;\n\tvec2 idx = floor( uv );\n\t\n\tuv = fract( uv );\n\t\n    uv.x *= iResolution.x/iResolution.y;\n\n\tfloat h  = 0.025;\n\tfloat w = h;\n\t\n    vec3 col = vec3(0.0);\n\t\n    float f = 0.0;\n\n    float xx = w;\n\tfloat yy = h * 18.;\n\t\n\tfloat xxx = xx;\n\tfloat yyy = yy;\n\t\n\tfloat a;\n\n\tvec3 test = vec3(iTime, 1.0 / 3.0, -1389.4235);\n\tvec3 v = test;\n\t\n\tif(idx.x == 1. && idx.y == 2.)\n\t{\n\t    a = v.x;\n\t\tyyy -= h * 18.0;\n\t}\n\t\n\telse if(idx.x == 1. && idx.y == 1.)\n\t{\n\t    a = v.y;\n\t}\n\t\n\telse if(idx.x == 1. && idx.y == 0.)\n\t{\n\t    a = v.z;\n\t\tyyy += h * 17.0;\n\t}\n\t\n\telse\n\t{\n\t    fragColor = vec4(0.0);\n\t    return;\n\t}\n\t\n\tf = 0.0;\n\t\n\t// Minus \n\tif(a < 0.0)\n\t{\n\t    f += r(uv, xxx + w * 0., yyy + h * 2., h, w);\n    \tf += r(uv, xxx + w * 1., yyy + h * 2., h, w);\n\t    f += r(uv, xxx + w * 2., yyy + h * 2., h, w);\n\t\ta = abs(a); \n    }\n\t\n\txxx += w * 4.0;\n\t\n\tint e  = int(mod(a,         10.));\n\tint z  = int(mod(a /   10., 10.));\n\tint hu = int(mod(a /  100., 10.));\n\tint t  = int(mod(a / 1000., 10.));\n\t\n\tint n1 = int(mod(a *    10., 10.));\n\tint n2 = int(mod(a *   100., 10.));\n\tint n3 = int(mod(a *  1000., 10.));\n\tint n4 = int(mod(a * 10000., 10.));\n\t\n    f += draw(uv, xxx, yyy, w, h, t);\n\txxx += w * 4.0;\n    f += draw(uv, xxx, yyy, w, h, hu);\n\txxx += w * 4.0;\n\tf += draw(uv, xxx, yyy, w, h, z);\n\txxx += w * 4.0;\n\tf += draw(uv, xxx, yyy, w, h, e);\n\txxx += w * 4.0;\n\t\n\tf += r(uv, xxx + w * 0.0, yyy + h * 0.0, h, w);\n\t\n\txxx += w * 2.0;\n\tf += draw(uv, xxx, yyy, w, h, n1);\n\txxx += w * 4.0;\n\tf += draw(uv, xxx, yyy, w, h, n2);\n\txxx += w * 4.0;\n\tf += draw(uv, xxx, yyy, w, h, n3);\n\txxx += w * 4.0;\n\tf += draw(uv, xxx, yyy, w, h, n4);\n\t \n    col = vec3(0.0, 1.0, 0.0) * f;\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGcDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 207], [209, 209, 285, 285, 412], [414, 414, 479, 479, 600], [602, 602, 670, 670, 5552], [5554, 5554, 5611, 5611, 7347]], "test": "timeout"}
{"id": "lsGcDV", "name": "windmill 001", "author": "Koji", "description": "windmill-ish", "tags": ["windmill"], "likes": 0, "viewed": 86, "published": "Public", "date": "1523372648", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    // ring\n    float u = abs(sin((atan(p.y, p.x) + iTime * 0.5 + length(p) ) * 15.0)*0.5) + 0.25;\n    float t = 0.2 / abs(0.35*sin(iTime) + u - length(p));  \n    fragColor = vec4(vec3(t*0.75), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGcDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 347]], "test": "ok"}
{"id": "lsGcRV", "name": "The chase", "author": "CensoredUsername", "description": "Raymarching shader, procedural texturing, basic phong lighting with some extra effects. If you've got a beefy machine set AA to 2 to enjoy proper anti aliasing. Party coded @ Revision 2018, code can use some cleanup.", "tags": ["raymarching"], "likes": 6, "viewed": 171, "published": "Public", "date": "1522600425", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float INFINITY = 1.e20;\nconst float PI       = 3.1415;\n\n// scene globals\nvec3 light_pos;\nvec3 origin;\nvec3 target;\nvec3 up;\n\n// update scene\nvec3 path(float time) {\n    float x = time * 8.;\n    return vec3(x, -2. - 1.5 * cos(x / 7. * PI), sin(iTime / 2.) * 2.);\n}\n\nvoid update_world() {\n    light_pos = vec3(3.5 * cos(iTime / 3.), 3.5 * sin(iTime / 3.), 4.);\n    origin = path(iTime);\n    up = normalize(vec3(0., cos(origin.x / 7. * PI), 6.));\n    light_pos = path(iTime + 1. + 0.8 * cos(iTime / 3.));\n    light_pos.z = light_pos.z * 2.;\n    target = light_pos;\n    target.yz = mix(origin.yz, target.yz, 0.2);\n}\n\n\n// operations\n\nfloat smootherstep(float e0, float e1, float x) {\n    x = clamp((x - e0) / (e1 - e0), 0., 1.);\n    return x * x * x * (x * (x * 6. - 15.) + 10.);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = smootherstep(0., 1., 0.5+0.5*(b-a)/k);\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 repeat(vec3 pos, vec3 distance) {\n    return mod(pos + 0.5 * distance, distance) - 0.5 * distance;\n}\n\n// produces n-1 steps of a staircase\nfloat stairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// primitives\n\nfloat plane(vec3 pos) {\n    return pos.z;\n}\n\nfloat sphere(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\nfloat cylinder(vec3 pos, vec3 axis, float radius) {\n    return length(cross(pos, axis)) - radius;\n}\n\n// map function\n\nvec2 map(vec3 pos) {\n    vec3 abspos = pos;\n    pos.z = -abs(pos.z);\n    \n    pos.y += 4. * round(pos.x / 7.);\n    pos = repeat(pos, vec3(7., 8., 100.));\n    \n    return vec2(smin(\n        stairs(\n            cylinder(pos, vec3(0., 0., 1.), 1.),\n            sphere(pos, 2.),\n            2., 8.\n        ),\n        plane(pos + vec3(0., 0., 6. + cos(pos.x / 7. * PI * 4.) * cos(pos.y / 8. * PI * 4.) * 0.5)),\n        3.\n    ) * 0.8, 1.);\n}\n\n// rendering\n\nvec2 march_ray_enhanced(vec3 origin, vec3 direction, float pixel_radius) {\n    // see http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf for details\n    // ray marching parameters\n    const float min_distance = .1;\n    const float max_distance = 500.;\n    const int max_iter = 50;\n    const int max_smooth_iter = 4;\n    \n    // initial conditions\n    float omega = 1.2;\n    float distance = min_distance;\n    float candidate_error = INFINITY;\n    float candidate_distance = 0.;\n    float candidate_material = 0.;\n    float previous_radius = 0.;\n    float advance_size = 0.;\n    \n    int i;\n    for (i = 0; i < max_iter; i++) {\n        // determine distance and material of closest-by object\n        vec2 dist_mat = map(origin + direction * distance);\n        \n        // determine absolute radius for over-relaxation and error checks\n        float radius = abs(dist_mat.x);\n        \n        // checks if we were progressing over-relaxed and if it failed\n        bool failed_over_relaxed_advance = omega != 1.0 && (radius + previous_radius) < advance_size;\n\n        // update the previous radius \n        previous_radius = radius;\n        \n        // calculate error as a screen space angle\n        float error = radius / distance;\n        \n        // determines how far we should advance\n        if (failed_over_relaxed_advance) {\n            // if we failed, we have to step back to where normal advancement would've brought us\n            advance_size -= advance_size * omega;\n            omega = 1.;\n\n        } else {\n            advance_size = dist_mat.x * omega;\n            \n            // was this a better hit than the previous one?\n            if (error < candidate_error) {\n                candidate_distance = distance;\n                candidate_error = error;\n                candidate_material = dist_mat.y;\n            }\n            \n            // did we hit something or the end of the ray\n            if (error < pixel_radius || distance > max_distance) {\n                break;\n            }\n        }\n        \n        // advance\n        distance += advance_size;\n    }\n    \n    if (distance > max_distance) {\n        return vec2(INFINITY, -1.);\n    }\n\n    // post-processing on the hit point: a few iteration steps to get smooth coordinates\n    for (int j = 0; j < max_smooth_iter; j++) {\n        float allowable_error = pixel_radius * candidate_distance;\n        candidate_distance += map(origin + direction * candidate_distance).x - allowable_error;\n    }\n\n    return vec2(candidate_distance, candidate_material);\n}\n\nvec3 estimate_normal(vec3 pos) {\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.05;\n    \n    // for four points on a cube, none of them\n    // next to another, calculate the change\n    // basically in any axis there are two points at +e and two points at -e\n    // note that length(e) is sqrt(3 * e) for any point to get the actual change\n    // in that axis you should divide by sqrt(3) (1/sqrt(3) = 0.5773)\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat shadow(vec3 p, vec3 light_dir, float mind, float maxd) {\n    float d = mind;\n    float dist;\n    float res = 1.;\n\n    for (int i = 0; i < 10; i++) {\n        vec2 dist_mat = map(p + d * light_dir);\n        dist = dist_mat.x;\n        res = min(res, 4. * dist / d);\n        d += clamp(dist, mind, mind * 10.);\n\n        if (dist < 0.001 || d > maxd) {\n          break;\n        }\n \n    }\n\n    return clamp(res, 0., 1.);\n}\n\n// really cheap occlusion\n// 0.0 = occluded, 1.0 = not occluded\nfloat occlude(vec3 p, vec3 norm, float fewaf) {\n    float dist = .1;\n    float tot = 0.;\n    \n    for (int i = 1; i < 7; i++) {\n        float try_dist = dist * float(i);\n        float d = map(p + norm * try_dist).x;\n        tot += (d / try_dist);\n    }\n    return clamp((tot - 2.) / 4., 0.0, 1.0);\n    \n}\n\nvec3 render(vec3 origin, vec3 direction, float pixel_radius) {\n    // cast our initial ray to determine what we'll hit\n    vec2 dist_mat = march_ray_enhanced(origin, direction, pixel_radius);\n    float distance = dist_mat.x;\n    float material = dist_mat.y;\n    \n    vec3 hit = origin + direction * distance;\n    \n    // calculate a normal vector around the hit point and a reflection vector\n    vec3 normal = estimate_normal(hit);\n    vec3 reflect_dir = reflect(direction, -normal);\n    \n    // return the color (currently just based on total distance travelled through 2 reflections.\n    //return (material > -0.5) ? vec3(10. / (dist_mat.x + reflect_dist_mat.x + rreflect_dist_mat.x)) : vec3(0.);\n    if (material < 0.) {\n        return vec3(0.02, 0.015, 0.01) * 0.5;\n    }\n    \n    // basic phong shading\n    vec3 light_dir = hit - light_pos;\n    vec3 reflect_light_dir = reflect(normalize(light_dir), -reflect_dir);\n\n    float diff = max(0.0, -dot(normal, normalize(light_dir)));\n    float spec = pow(max(0.0, -dot(direction, reflect_light_dir)), 4.) * smoothstep(0., 1., diff * 10.);\n\n    float occ = shadow(hit, -light_dir, 0.01, length(light_dir));\n    float light_intensity = 40. * occ * pow(1. / length(light_dir), 2.);\n\n    vec3 color = vec3(0.01) +\n                 vec3(0.04) * diff * light_intensity +\n                 vec3(0.8)  * spec * light_intensity;\n    \n    // occlusion\n    color *= vec3(occlude(hit, normal, 0.04));\n    \n    // particle effect\n    float z_plane = floor(hit.z * 100.) / 100.;\n\n    float angle = atan(normal.y, normal.x) * ((hash(vec2(z_plane, 8.)) > .5) ? -1. : 1.);\n    float expected_angle = hash(vec2(z_plane, 5.)) * 2. * PI + iTime * 2. * pow(hash(vec2(z_plane, 4.)), 2.);\n    \n    float h = hash(vec2(z_plane, 1.));\n    float angle_from_lead = mod((angle - expected_angle + sin(hit.x * 0.1 * h) - cos(hit.y * 0.13 * h)) / 2. / PI, 1.);\n    \n    float brightness = pow(max(angle_from_lead - 0.9, 0.0) * 10., 4.);\n    float fade = max(0.0, min(1.0, 5. * cos(iTime * 0.1 * hash(vec2(z_plane, 2.))) - 2. + 5. * hash(vec2(z_plane, 3.)) ));\n\n    if (length(normal.xy) > 0.01) {\n        color += brightness * fade * vec3(0.8, 0.5, 0.1) * length(normal.xy) * 2.;\n    }\n    \n    // fog\n    color = mix(vec3(0.02, 0.015, 0.01) * 0.5, color, exp(-distance * 0.1));\n    \n    // sphere glow\n    vec3 sphere_diff = light_pos - origin;\n    float sphere_dist = length(sphere_diff - direction * dot(sphere_diff, direction));\n    color += smoothstep(-3.5, 0., distance - length(sphere_diff)) * min(1.0, exp(-(sphere_dist - 0.6) * 4.)) * vec3(1.);\n    \n    return color;\n}\n\nmat3 look_at(vec3 origin, vec3 target, vec3 reference_up, float tilt) {\n    // note: I'm using a reference frame where Z is upwards, and X/Y a groundplane\n    // direction the camera is looking at.\n    // this function returns a transformation matrix that takes X/Y screenpos + Z depth into that reference frame\n    vec3 direction = normalize(target - origin);\n\n    // construct upwards pointing direction aligned frame\n    vec3 side = normalize(cross(direction, reference_up));\n    vec3 up   = cross(side, direction);\n    \n    // rotate around direction\n    vec3 up_rotated   = cos(tilt) * up   - sin(tilt) * side;\n    vec3 side_rotated = cos(tilt) * side + sin(tilt) * up;\n    \n    // construct reference frame.\n    return mat3(side_rotated, up_rotated, direction);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // calculate scene\n    update_world();\n    \n    // anti-aliasing oversampling\n    const int AA = 1;\n    // screen height / screen distance. 2 = 90deg, 1.15 = 60deg\n    const float FOV_scale = 4.;\n    \n    // normalized cursor location\n    vec2 cursor = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n            \n    // approximate normalized projected pixel size. multiply by distance to get local projected pixel radius\n    // Note that this is only really true for the center pixel, the sphere that fits in pixels further to the\n    // outside gets smaller\n    float pixel_radius = FOV_scale / iResolution.y / 2.;\n    \n    // camera location\n    //vec3 origin = vec3(-10. * cos(cursor.x), -10. * sin(cursor.x), cursor.y * 5.);\n    \n    // camera to world transform matrix\n    mat3 camera = look_at(origin, target, up, 0.);\n    \n    vec3 color = vec3(0.);\n    for (int i = 0; i < AA; i++) {\n        for (int j = 0; j < AA; j++) {\n            \n            // subpixel coordinates for anti-aliasing\n            vec2 subpixel_coord = -0.5 + (0.5 + vec2(float(i), float(j))) / float(AA);   \n\n            // map pixel location to a -1 to 1 field on the y axis, and an appropriately scaled x axis.\n            // Scale this to control FoV (currently 90 deg)\n            vec2 pixel_coord = FOV_scale * (fragCoord + subpixel_coord - 0.5 * iResolution.xy) / iResolution.y;\n    \n            // translate screenspace to worldspace and normalize pixel coordinate position\n            vec3 direction = normalize(camera * vec3(pixel_coord, 1.));\n\n            // render in that direction\n            color += render(origin, direction, pixel_radius);\n            \n        }\n    }\n    \n    color /= pow(float(AA), 2.);\n    \n    // gamma correct and write to output\n    fragColor = vec4(pow(color, vec3(1. / 2.2)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGcRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 147, 170, 170, 269], [271, 271, 292, 292, 617], [635, 635, 684, 684, 782], [784, 784, 823, 823, 919], [921, 921, 959, 959, 1026], [1028, 1065, 1115, 1115, 1225], [1242, 1242, 1265, 1265, 1285], [1287, 1287, 1325, 1325, 1360], [1362, 1362, 1413, 1413, 1461], [1480, 1480, 1500, 1500, 1916], [1932, 1932, 2006, 2126, 4483], [4485, 4485, 4517, 4517, 5048], [5050, 5050, 5072, 5072, 5152], [5154, 5154, 5216, 5216, 5576], [5578, 5642, 5689, 5689, 5946], [5948, 5948, 6010, 6066, 8544], [8546, 8546, 8617, 8857, 9315], [9317, 9317, 9372, 9395, 11186]], "test": "ok"}
{"id": "lsGcWV", "name": "Lightning Attractor", "author": "dr2", "description": "Lightning in 3D (from the Tesla demos)", "tags": ["raymarch", "lightning"], "likes": 2, "viewed": 469, "published": "Public API", "date": "1523365296", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Lightning Attractor\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Lightning in 3D (from the Tesla demos)\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\n\nvec4 pth[8];\nvec3 sunDir, qHit;\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat SparkDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  dMin *= 2.;\n  for (int k = 0; k < 8; k ++) {\n    q = p;\n    if (k < 4) {\n      q.xz = Rot2D (q.xz, (0.5 + float (k)) * 0.5 * pi + 0.15 * tCur);\n      q.yz = Rot2D (q.yz, 0.25 * pi);\n    } else {\n      q.xz = Rot2D (q.xz, (0.5 + float (k)) * 0.5 * pi - 0.15 * tCur);\n      q.yz = Rot2D (q.yz, -0.25 * pi);\n    }\n    q.z += 20.2;\n    d = PrCylDf (q, 0.9, 20.);\n    if (d < dMin) {\n      q.xy -= (1. - smoothstep (19.5, 20., q.z)) * (2. * vec2 (Fbm2 (vec2 (0.4 * q.z, 0.) +\n         pth[k].xy), Fbm2 (vec2 (0.3 * q.z, 0.) + pth[k].zw)) - 1.);\n      d = PrCylDf (q, 0.02, 20.);\n      DMINQ (1);\n    }\n  }\n  return 0.5 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  d = PrSphDf (q, 0.3);\n  DMINQ (2);\n  dMin = SparkDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, f, t;\n  for (int k = 0; k < 8; k ++) {\n    f = 0.1 * float (k);\n    t = 0.1 * tCur;\n    pth[k] = vec4 (4. + f - (10. + 3. * f) * t + (0.8 - f) * sin ((0.1 + 0.1 * f) * t),\n       sin ((0.11 + 0.1 * f) * t) + (0.3 + 0.2 * f) * sin ((0.17 + 0.5 * f) * t),\n       5. + 2. * f - (12. - 2. * f) * t + (0.5 + 0.3 * f) * sin ((0.15 - 0.2 * f) * t),\n       sin ((0.12 - 0.1 * f) * t) + (0.4 - 0.2 * f) * sin ((0.12 + 0.2 * f) * t));\n  }\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      col = vec3 (1., 1., 0.6) * clamp (1.3 - 0.3 * Fbm1 (5. * qHit.z), 0., 1.) *\n         (0.1 + 1.3 * max (0.3 - dot (rd, vn), 0.)) * (1. - dstObj / dstFar);\n    } else if (idObj == 2) {\n      col = vec3 (0.5, 0.5, 0.6) * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n         0.1 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    }\n  } else {\n    col = vec3 (0.6, 0.6, 1.) * (0.05 + 0.245 * (rd.y + 1.) * (rd.y + 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 10.;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = 0.2 * pi * mPtr.y;\n  } else {\n    az = 0.1 * pi * tCur;\n    el = 0.15 * pi * sin (0.13 * pi * tCur);\n  }\n  el = clamp (el, -0.1 * pi, 0.1 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -30.);\n  zmFac = 6. + 2. * sin (0.13 * pi * tCur);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  dstFar = 100.;\n  sunDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGcWV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[480, 480, 516, 516, 1163], [1165, 1165, 1187, 1187, 1322], [1324, 1324, 1357, 1357, 1534], [1536, 1536, 1557, 1557, 1757], [1759, 1759, 1794, 1794, 2841], [2843, 2843, 2899, 2899, 3828], [3830, 3830, 3863, 3863, 3890], [3892, 3892, 3934, 3934, 3985], [3987, 3987, 4017, 4017, 4130], [4164, 4164, 4188, 4188, 4241], [4243, 4243, 4267, 4267, 4397], [4399, 4399, 4424, 4424, 4570], [4572, 4572, 4597, 4597, 4783], [4785, 4785, 4807, 4807, 4961], [4963, 4963, 4984, 4984, 5139]], "test": "error"}
{"id": "lsGczc", "name": "Gradient flag", "author": "bonofobia", "description": "Self-explanatory, by holding the left-mouse button and moving the mouse you move the midpoint of the gradient (such as the midpoint slider in Illustrator in a gradient between two stops in the gradient)", "tags": ["gradient"], "likes": 0, "viewed": 101, "published": "Public", "date": "1522775473", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 p1=vec3(1.0,0.8,0);\n    vec3 p2=vec3(0,0,1.0);\n    vec3 p3=vec3(1.0,0,0);\n    vec3 p4=vec3(1.0,1.0,1.0);\n    vec3 p5=vec3(0,0,0);\n    vec3 p6=vec3(1.0,0,0);\n    \n   \n    float midpoint=0.499*sin(iTime)+0.5;\n    \n    \n    float factor=0.0;\n    if(midpoint<=0.5)\n    {\n        factor=1.0-pow(1.0-uv.x,1.0/(midpoint*2.0));\n    }\n    else\n    {\n        factor=pow(uv.x,1.0/((1.0-midpoint)*2.0));\n    }\n   \n    vec3 interpolated1=(1.0-factor)*p1+(factor)*p2;\n    vec3 interpolated2=(1.0-factor)*p3+(factor)*p4;\n    vec3 interpolated3=(1.0-factor)*p5+(factor)*p6;\n    if(uv.y>=0.0 && uv.y<=0.33)\n    \tfragColor = vec4(interpolated1,0);    \n    else if(uv.y>0.33 && uv.y<=0.66)\n        fragColor = vec4(interpolated2,0);\n    else \n        fragColor = vec4(interpolated3,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGczc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 925]], "test": "ok"}
{"id": "lsGczd", "name": "sdf of polygon (internal)", "author": "FabriceNeyret2", "description": "Normalization = relative to borders.\nFor SDF normalized to world (for ray-marching), see comments.\n", "tags": ["2d", "sdf", "shapes", "short", "mz"], "likes": 6, "viewed": 458, "published": "Public API", "date": "1522948593", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 O, vec2 U )\n{\n   float t = mod(iTime,8.), \n         r = 1.,\n         N = 3.+5.*min(t,8.-t);\n    \n    vec2 R = iResolution.xy;\n    U = ( U+U - R ) / R.y;\n    float a = atan(U.x,U.y), l = length(U),d,\n          b = 3.14159/N;\n    a = mod(a,2.*b)-b;\n    // --- SDF relative to borders\n    d = 1. - l * cos(a) / cos(b);\n#if 1                        // 0: cheap  1: full rounded outside\n    if (d<0.) d = -length(vec2(min(0., (sin(b) - abs(l * sin(a))) / cos(b) ), d));\n#endif\n    O = vec4(d);\n/** // variant :\n    U = l * vec2(cos(a),sin(a));\n    O = vec4( 1.-U.x/cos(b) );   // but if you simplify, it's same expression :-)\n/**/\n  // --- SDF relative to world:\n  //O = vec4( l = r*cos(b) - l * cos(a) ); // or r - l * cos(a) if r=faces instead of vertices\n    \n  //O = sin(30.*O);\n    if (O.x<0.) O=vec4(1,0,0,0);\n    O.b = .5*sin(6.28*10.*d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGczd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 39, 39, 868]], "test": "ok"}
{"id": "lsKyRK", "name": "Psychedelic Swarm", "author": "nr4", "description": "Challenge: Code scene visuals for a .5s-beat music track. Time limit: 25min, bring only keyboard and mouse.\nMy first practice shader.", "tags": ["raymarching", "livecoding", "25min"], "likes": 3, "viewed": 176, "published": "Public", "date": "1522861472", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Psychedelic swarm\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst vec2 c = vec2(1.,0.);\nfloat iScale;\n\nvec3 rot(vec3 x, vec3 theta)\n{\n    vec3 c = cos(theta), s = sin(theta);\n    return mat3(c.x,0.,s.x,0.,1.,0.,-s.x,0.,c.x)\n        *mat3(1., 0., 0., 0., c.y, -s.y, 0., s.y, c.y)\n        *mat3(c.z,-s.z,0., s.z,c.z,0., 0.,0.,1.)*x;\n}\n\nfloat rand(vec2 x)\n{\n    return fract(255123.*sin(3241.*x.x+2123034.*cos(2144235.*x.y)));\n}\n\nvec2 scene(vec3 x)\n{\n    x += .5;\n    x = vec3(length(x), acos(x.x/length(x)), acos(x.y/length(x)));\n    \n    x.y += x.y*sin(x.x);\n    x = rot(x, 1.e-1*vec3(1.,1.4,2.)*iTime);\n    \n    vec3 y = x-.1;\n    \n    x = mod(x, .2)-.1;\n    vec2 sdf = vec2(length(x)-.05-.05*iScale, 1.);\n    x = mod(x, .02)-.01;\n    vec2 sda = vec2(length(x)-.005-.005*iScale, 2.);\n    sdf = mix(sda, sdf, step(-sdf.x, sda.x));\n    \n    y = mod(y, .2)-.1;\n    vec2 sdb = vec2(length(y)-.05-.05*(.5-iScale), 3.);\n    sdf = mix(sdf, sdb, step(sdb.x, sdf.x));\n    y = mod(y, .02)-.01;\n    vec2 sdc = vec2(length(y)-.005-.005*(.5-iScale), 4.);\n    sdf = mix(sdc, sdf, step(-sdf.x, sda.x));\n    \n    return sdf;\n}\n\nvec3 normal(vec3 x)\n{\n    float s = scene(x).x;\n    return normalize(vec3(scene(x+1.e-4*c.xyy).x-s, scene(x+1.e-4*c.yxy).x-s, scene(x+1.e-4*c.yyx).x-s));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy, sdm = c.yy;\n    vec3 col = c.yyy, o = 2.*c.xxx, t = c.yxy, dir = normalize(t-o), r = c.xyy, ro = uv.x*r+uv.y*cross(r, dir), x=c.yyy;\n    iScale = mod(iTime, .5);\n    int i=0, ni=100;\n    float d = 0.;\n    for(i; i<ni; ++i)\n    {\n        x = ro + d*dir;\n        sdm = scene(x);\n        if(sdm.x<1.e-4)break;\n        if(d>=100.)return;\n        d += sdm.x;\n    }\n    if(i==ni)return;\n    \n    vec3 n = normal(x);\n    if(sdm.y == 1.)\n        col = .2*c.yyx+c.xyy*dot(c.yxx, n);\n    else if(sdm.y == 2.)\n        col = .2*c.yyx+c.yxy*dot(c.yyx, n);\n    else if(sdm.y == 3.)\n        col = .2*c.xyy+c.yyx*dot(c.yyx, n);\n    else if(sdm.y == 4.)\n        col = .2*c.xyy+c.yxy*dot(c.yyx, n);\n    else col = c.yyy;\n\n    col = mix( rot(col, -vec3(2.*iTime+length(x))), rot(col, vec3(3.*iTime-length(x))), .5+.5*sin(5.*iTime));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsKyRK.jpg", "access": "shaders20k", "license": "gpl-3.0-plus", "functions": [[782, 782, 812, 812, 1011], [1013, 1013, 1033, 1033, 1104], [1106, 1106, 1126, 1126, 1789], [1791, 1791, 1812, 1812, 1946], [1948, 1948, 2005, 2005, 2916]], "test": "ok"}
{"id": "lsKyWV", "name": "curlesque", "author": "klk", "description": "Curly plasma like pattern", "tags": ["curlplasma"], "likes": 21, "viewed": 3985, "published": "Public API", "date": "1523431572", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Alex Kluchikov\n\n#define pi 3.14159265359\n\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n\nfloat saw(float x)\n{\n    return abs(fract(x)-0.5)*2.0;\n}\n\nfloat dw(float2 p, float2 c, float t)\n{\n    return sin(length(p-c)-t);\n}\n\nfloat dw1(float2 uv)\n{\n    float v=0.0;\n    float t=iTime*2.0;\n    v+=dw(uv,float2(sin(t*0.07)*30.0,cos(t*0.04)*20.0),t*1.3);\n    v+=dw(uv,float2(cos(t*0.13)*30.0,sin(t*0.14)*20.0),t*1.6+1.0);\n    v+=dw(uv,float2( 18,-15),t*0.7+2.0);\n    v+=dw(uv,float2(-18, 15),t*1.1-1.0);\n    return v/4.0;\n}\n\nfloat fun(float x, float y)\n{\n\treturn dw1(float2(x-0.5,y-0.5)*80.0);\n}\n\nfloat3 duv(float2 uv)\n{\n    float x=uv.x;\n    float y=uv.y;\n    float v=fun(x,y);\n    float d=1.0/400.0;\n\tfloat dx=(v-fun(x+d,y))/d;\n\tfloat dy=(v-fun(x,y+d))/d;\n    float a=atan(dx,dy)/pi/2.0;\n    return float3(v,0,(v*4.0+a));\n}\n\nvoid mainImage( out float4 fragColor, in float2 fragCoord )\n{\n\tfloat2 uv = fragCoord.xy/iResolution.x;\n    float3 h=duv(uv);\n    float sp=saw(h.z+iTime*1.3);\n    //sp=(sp>0.5)?0.3:1.0;\n    sp=clamp((sp-0.25)*2.0,0.5,1.0);\n    fragColor = float4((h.x+0.5)*sp, (0.3+saw(h.x+0.5)*0.6)*sp, (0.6-h.x)*sp, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsKyWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 138, 138, 174], [176, 176, 215, 215, 248], [250, 250, 272, 272, 544], [546, 546, 575, 575, 616], [618, 618, 641, 641, 846], [848, 848, 909, 909, 1155]], "test": "ok"}
{"id": "lstfRH", "name": "Simple plasma", "author": "shockdesign", "description": "Simple plasma", "tags": ["demolearningbasics"], "likes": 1, "viewed": 117, "published": "Public", "date": "1524121375", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653589793\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    float x = fragCoord.x + sin(iTime/PI) * iResolution.x / 4.0;\n    float y = fragCoord.y + cos(iTime/PI) * iResolution.y / 2.0;\n    float hue = sin(x / iResolution.x) + cos(y / iResolution.y) + sin((x + y) / 500.0) + cos(sqrt(x * x + y * y) / 100.0);\n    \n    col = hsv2rgb(vec3(hue + iTime/8.0, 1.0, mod(iTime, 1000.0)));\n\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lstfRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 52, 52, 215], [217, 217, 274, 274, 646]], "test": "ok"}
{"id": "lsVcDt", "name": "shade", "author": "Nicolas2", "description": "shade", "tags": ["visuals"], "likes": 0, "viewed": 58, "published": "Public", "date": "1523952829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(iTime*0.25,iTime/10.))) * mod(99.53*iTime/200.,10.));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //shift so 0 centered\n    uv=uv-(0.5,0.5);\n    \n    float x=uv[0];\n    float y=uv[1];\n    \n    \n    vec3 col=vec3(0,0,0);\n    \n    if(x*x+y*y+0.105*abs(x)<0.07*rand(uv)){\n        \n        float val=(0.71*rand(uv))-(x*x+y*y+0.105*abs(x));\n        col = 0.55*exp(val)*vec3(1,0.7,0.2);\n        \n        \n    }\n    else{\n        col=vec3(0,0.0,0.1);\n    }\n    \n    \n\n    // Time varying pixel color\n\n    // Output to screen\n    fragColor = vec4(col,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVcDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 113], [117, 117, 174, 224, 726]], "test": "ok"}
{"id": "lsVcRt", "name": "Chromatic Cube", "author": "JuliaPoo", "description": "Originally written for a phone background so there are extra variables", "tags": ["cube"], "likes": 1, "viewed": 364, "published": "Public API", "date": "1523001712", "time_retrieved": "2021-10-01T00:00:00", "image_code": " #ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n\nuniform vec2 resolution;\n\nfloat ballDistP(vec3 objpos, vec3 rd, vec3 ro){\nreturn length(cross(objpos - ro, rd))/length(rd);\n}\n\nfloat cubepoints(float radius, float blur, vec3 rd, vec3 ro, vec3 pos){\nfloat d = 0.;\nd = smoothstep(radius,radius-blur,ballDistP(vec3(pos), rd, ro));\n  d += smoothstep(radius,radius-blur,ballDistP(vec3(1,0,0)+vec3(pos), rd, ro));\n  d += smoothstep(radius,radius-blur,ballDistP(vec3(0,1,0)+vec3(pos), rd, ro));\n  d += smoothstep(radius,radius-blur,ballDistP(vec3(0,0,1)+vec3(pos), rd, ro));\n  d += smoothstep(radius,radius-blur,ballDistP(vec3(1,1,0)+vec3(pos), rd, ro));\n  d += smoothstep(radius,radius-blur,ballDistP(vec3(1,0,1)+vec3(pos), rd, ro));\n  d += smoothstep(radius,radius-blur,ballDistP(vec3(0,1,1)+vec3(pos), rd, ro));\n  d += smoothstep(radius,radius-blur,ballDistP(vec3(1,1,1)+vec3(pos), rd, ro));\n  return d;\n}\n\nvoid mainImage( out vec4 FragColor, in vec2 FragCoord ){\n    vec2 touch = iMouse.xy;\n    float time = iTime;\nvec2 uv = FragCoord.xy / iResolution.xy;\n  uv += -.5;\n  uv.y *= iResolution.y/iResolution.x;\n  float t= time*.4;\n  vec2 T = 6.*touch/iResolution.y;\n\n  //Camera setup\n  float R = 1.;\n  float zoom = 0.3;\n  vec3 ro = vec3(R*sin(t+T.x)*cos(1.7*t + T.y),R*cos(t+T.x)*cos(2.1*t+T.y),R*cos(t+T.x));\n  vec3 lookat = vec3(0,.3,0);\n  vec3 fw = normalize(lookat - ro);\n  vec3 r = cross(vec3(0,1.,0), fw);\n  vec3 up = cross(fw,r);\n  vec3 scrC = ro + zoom*fw;\n  vec3 scrP = scrC + uv.x*r + uv.y*up;\n  vec3 rd = scrP - ro;\n\n  float radius = .1;\n  float blur = .03;\n\n  float d = cubepoints(radius, blur, rd, ro, vec3(0,.1,0));\n  float d1= cubepoints(radius, blur, rd, ro, vec3(0,.1,blur));\n  float d2= cubepoints(radius, blur, rd, ro, vec3(0,blur+.1,0));\n\nFragColor = vec4(d,d1,d2,1.) + .95*vec4(.7,.8,.7,1.)+.3*vec4(uv.x*sin(t+T.x),uv.y*cos(2.*t+T.y),1,.1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVcRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 171, 171, 223], [225, 225, 296, 296, 949], [951, 951, 1007, 1007, 1905]], "test": "error"}
{"id": "lsVcRV", "name": "Spiky zoom", "author": "NohatCoder", "description": "Continued the concept in my speedshading. Still a simple effect, but much nicer looking. Antialiasing is done by picking samples in a line that is oriented orthogonally to the spike pattern, thus getting good effect for relatively few samples.", "tags": ["2d", "zoom", "antialiasing"], "likes": 3, "viewed": 383, "published": "Public API", "date": "1522697351", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rnd(float a, float i, float arms){\n    //const float arms=20.;\n    float i1=mod(floor(a*arms),arms)+mod(i*12.672,2236.77621);\n    float i2=mod(floor(a*arms+1.),arms)+mod(i*12.672,2236.77621);\n\n    float i11=mod(cos(i1*mod(i1,3.)*.00632)*356.9,1.);\n    float i22=mod(cos(i2*mod(i2,3.)*.00632)*356.9,1.);\n    float span=mod(a*arms,1.);\n    return i22*span+i11*(1.-span);\n}\n\nvec3 col(float i){\n    if(cos(i*i)<-.98){\n        return (1.+cos(acos(-1.)*vec3(mod(cos(i*.045621)*2341.,1.),mod(cos(i*.085601)*2311.,1.),mod(cos(i*.049691)*2141.,1.))))*.5;\n    }\n    else{\n        float phase=mod(floor(i/20.),3.);\n        float mixx=mod(i,20.)/20.;\n        vec3 c1;\n        vec3 c2;\n        if(phase<.5){\n            c1=vec3(0.,0.,0.);\n            c2=vec3(1.,0.6,0.);\n        }\n        else if(phase<1.5){\n            c1=vec3(1.,0.6,0.);\n            c2=vec3(0.,0.3,1.);\n        }\n        else{\n            c1=vec3(0.,0.3,1.);\n            c2=vec3(0.,0.,0.);\n        }\n        return c1*(1.-mixx)+c2*mixx;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.yy;\n    \n    // Output to screen\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    \n    float angle=atan(uv.y,uv.x)/acos(-1.)/2.;\n    \n    float layer=floor(iTime/2.);\n    float zoom=mod(iTime/2.,1.);\n    float pixelsize=1./iResolution.y;\n    float stepsclose=floor(log(length(uv))/log(1.2));\n    float aa;\n    for(aa=1.;aa<14.;aa++){\n        float a=aa+stepsclose;\n        float zooma=pow(1.2,a+zoom);\n        vec2 uvzoom=uv/zooma;\n        float bend=.6-length(uvzoom);\n        float pixelsize2=pixelsize/length(uv)*.05;\n        float angle2=mod(angle+bend*bend*bend*bend*.4*sin((a-layer)*.3+iTime),1.);\n        float b;\n        float cover=0.;\n        for(b=-2.;b<=2.;b++){\n            float h=rnd(mod(angle2+b*pixelsize2,1.),a-layer,floor(60.*(1.2+sin(0.0774*(a-layer)))))*.5+.1;\n            if(h<length(uvzoom)){\n                cover+=0.2;\n                //fragColor = vec4(vec3(a+zoom)*.02+.2,1.0);\n            }\n        }\n        fragColor = vec4(col(a-layer),1.0)*cover+fragColor*(1.-cover);\n    }\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVcRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 68, 376], [378, 378, 396, 396, 1007], [1009, 1009, 1066, 1066, 2126]], "test": "ok"}
{"id": "lsVczd", "name": "WORM WITH WHITE", "author": "Thomas_nathan21", "description": "WORM WITH WHITE ", "tags": ["wormwithwhite"], "likes": 0, "viewed": 294, "published": "Public API", "date": "1523032072", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \t //sets 0 as the centre of the screen \n\tvec2 r = 2.*fragCoord / iResolution.xy -1.;\n    \n    //variables\n    float x = r.x;\n    float y = r.y;\n    float Thickness = 0.3;\n    float Yoffset = 0.9; \n    float Height = 0.2;\n    \n    //Colors\n    vec3 white = vec3(1,1,1);\n    vec3 green = vec3(0,1,0);\n    vec3 blue = vec3(0,0,1);\n    vec3 pixelCol = vec3(0, 0, 0);\n\t\n    if(abs((x * Height) * sin(PI * (x + iTime)) - (y - Yoffset)) < Thickness) pixelCol = white;\n    if(abs((x * Height) * sin(PI * (x + iTime)) - (y + Yoffset)) < Thickness) pixelCol = blue;\n    if(abs((x * Height) * sin(PI * (x + iTime)) - y) < (Thickness * 2.0)) pixelCol = green;\n   \n    // Output to screen\n    fragColor = vec4(pixelCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVczd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 82, 125, 799]], "test": "ok"}
{"id": "lsVyz3", "name": "Falling Stars", "author": "dr2", "description": "Sinking spiked objects", "tags": ["reflection", "light", "polyhedron"], "likes": 10, "viewed": 3222, "published": "Public API", "date": "1522839671", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Falling Stars\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat SmoothMin (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3v3 (vec3 p);\n\nvec3 ltDir;\nvec2 csI, csI2, csD, csD2;\nfloat tCur, dstFar;\nconst vec3 bGrid = vec3 (2.);\nconst float pi = 3.14159;\n\nvec3 IcosSym (vec3 p)\n{\n  float a, w;\n  w = 2. * pi / 3.;\n  p.yz = Rot2Cs (vec2 (p.y, abs (p.z)), csI);\n  p.x = - abs (p.x);\n  for (int k = 0; k < 3; k ++) {\n    if (dot (p.yz, csI) > 0.) p.zy = Rot2Cs (p.zy, csI2) * vec2 (1., -1.);\n    p.xy = Rot2D (p.xy, - w);\n  }\n  if (dot (p.yz, csI) > 0.) p.zy = Rot2Cs (p.zy, csI2) * vec2 (1., -1.);\n  a = mod (atan (p.x, p.y) + 0.5 * w, w) - 0.5 * w;\n  p.yx = vec2 (cos (a), sin (a)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nvec3 DodecSym (vec3 p)\n{\n  float a, w;\n  w = 2. * pi / 5.;\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), vec2 (csD.x, - csD.y));\n  p.xy = Rot2D (p.xy, - 0.25 * w);\n  p.x = - abs (p.x);\n  for (int k = 0; k < 3; k ++) {\n    if (dot (p.yz, csD) > 0.) p.zy = Rot2Cs (p.zy, csD2) * vec2 (1., -1.);\n    p.xy = Rot2D (p.xy, - w);\n  }\n  if (dot (p.yz, csD) > 0.) p.zy = Rot2Cs (p.zy, csD2) * vec2 (1., -1.);\n  a = mod (atan (p.x, p.y) + 0.5 * w, w) - 0.5 * w;\n  p.yx = vec2 (cos (a), sin (a)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nfloat ObjDf (vec3 p, vec3 cId)\n{\n  vec3 q, h;\n  float d;\n  d = dstFar;\n  h = Hashv3v3 (cId);\n  if (h.x * step (2., length (cId.xz)) > 0.6) {\n    p -= bGrid * (cId + 0.5);\n    p -= (0.2 + 0.1 * bGrid.x * h.x) * vec3 (cos (h.z * tCur + h.x), 0., sin (h.z * tCur + h.x));\n    p.xz = Rot2D (p.xz, (h.y - 0.5) * tCur);\n    p.xy = Rot2D (p.xy, (h.z - 0.5) * tCur);\n    q = p;\n    d = PrSphDf (q, 0.2);\n    q = IcosSym (p);\n    q.z += 0.48;\n    d = SmoothMin (d, PrCylDf (q, 0.05 * (0.55 + 1.5 * q.z), 0.3), 0.01);\n    q = DodecSym (p);\n    q.z += 0.48;\n    d = 0.9 * SmoothMin (d, PrCylDf (q, 0.05 * (0.55 + 1.5 * q.z), 0.3), 0.01);\n  }\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cId, s;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  dHit = eps;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + rd * dHit;\n    cId.xz = floor (p.xz / bGrid.xz);\n    p.y += 0.2 * tCur * (1. + Hashfv2 (cId.xz));\n    cId.y = floor (p.y / bGrid.y);\n    d = ObjDf (p, cId);\n    s = (bGrid * (cId + step (0., rd)) - p) / rd;\n    d = min (d, abs (min (min (s.x, s.y), s.z)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nfloat ObjDfN (vec3 p)\n{\n  vec3 cId;\n  cId.xz = floor (p.xz / bGrid.xz);\n  p.y += 0.2 * tCur * (1. + Hashfv2 (cId.xz));\n  cId.y = floor (p.y / bGrid.y);\n  return ObjDf (p, cId);\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  v = vec4 (ObjDfN (p + e.xxx), ObjDfN (p + e.xyy), ObjDfN (p + e.yxy), ObjDfN (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 3.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0.25, 0.6, 1.), vec3 (0., 0.4, 0.3), 0.5 * (1. - rd.y)) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + 0.25 * gd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn;\n  float dstObj, dihedIcos, dihedDodec;\n  dihedIcos = 0.5 * acos (sqrt (5.) / 3.);\n  csI = vec2 (cos (dihedIcos), - sin (dihedIcos));\n  csI2 = vec2 (cos (2. * dihedIcos), - sin (2. * dihedIcos));\n  dihedDodec = 0.5 * atan (2.);\n  csD = vec2 (cos (dihedDodec), - sin (dihedDodec));\n  csD2 = vec2 (cos (2. * dihedDodec), - sin (2. * dihedDodec));\n  bgCol = BgCol (rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col = mix (vec3 (0.15, 0.35, 0.7), BgCol (reflect (rd, vn)), 0.8);\n    col = col * (0.4 + 0.1 * max (vn.y, 0.) + 0.5 * max (dot (vn, ltDir), 0.)) +\n       0.1 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    col *= 0.3 + 0.7 * min (rd.y + 1., 1.5);\n    col = mix (col, bgCol, smoothstep (0.5 * dstFar, dstFar, dstObj));\n  } else col = bgCol;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.02 * pi * tCur;\n  el = 0.2 * pi * sin (0.01 * pi * tCur);\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = 0.6 * pi * mPtr.y;\n  }\n  tCur += 100.;\n  el = clamp (el, -0.3 * pi, 0.3 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vec3 (0.5);\n  rd = vuMat * normalize (vec3 (uv, 3.));\n  ltDir = normalize (vec3 (0.2, 1., -0.2));\n  dstFar = 50.;\n  fragColor = vec4 (pow (ShowScene (ro, rd), vec3 (0.8)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec3 Hashv3v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec3 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3))) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVyz3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[467, 467, 490, 490, 956], [958, 958, 982, 982, 1501], [1503, 1503, 1535, 1535, 2147], [2149, 2149, 2182, 2182, 2767], [2769, 2769, 2792, 2792, 2947], [2949, 2949, 2970, 2970, 3172], [3174, 3174, 3196, 3196, 3617], [3619, 3619, 3654, 3654, 4530], [4532, 4532, 4585, 4585, 5417], [5419, 5419, 5452, 5452, 5479], [5481, 5481, 5523, 5523, 5574], [5576, 5576, 5621, 5621, 5724], [5726, 5726, 5756, 5756, 5814], [5816, 5816, 5847, 5847, 5911], [5945, 5945, 5969, 5969, 6029], [6031, 6031, 6055, 6055, 6248]], "test": "timeout"}
{"id": "lsVyzV", "name": "2D sun", "author": "Pr0fed", "description": "This time simple sin-cos pattern noise (does it have a name?) with a voronoi in a circle-like shape.", "tags": ["2d", "noise", "pattern"], "likes": 4, "viewed": 178, "published": "Public", "date": "1522701945", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Rotation matrix, it does a big impact, as usual.\nconst mat2 m = mat2( 1.20,  0.80, -0.80,  1.20 );\n\n// Time simplification and easier overall speed control.\n#define time iTime * 0.23\n\n// Just a simple checker-like pattern.\n// Not even sure if we can call it noise.\nfloat squareNoise( in vec2 x )\n{\n\treturn cos(x.x) * sin(x.y);\n}\n\n// Six octave FBM square noise (3 seems enough).\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000 * (0.5+0.5*squareNoise( p )); p = m * p * 2.02;\n    f += 0.250000 * (0.5+0.5*squareNoise( p )); p = m * p * 2.03;\n    f += 0.125000 * (0.5+0.5*squareNoise( p )); p = m * p * 2.01;\n    //f += 0.062500 * (0.5+0.5*squareNoise( p )); p = m * p * 2.04;\n    //f += 0.031250 * (0.5+0.5*squareNoise( p )); p = m * p * 2.01;\n    //f += 0.015625 * (0.5+0.5*noise( p ));\n    return f / 0.96875;\n}\n\n// This two hash voronoi might sucks. At least it seems ugly to me.\n// I guess i should use IQ's version. But really don't have time today.\nfloat r(float n)\n{\n \treturn fract(cos(n*72.42)*173.42);\n}\n\nvec2 r(vec2 n)\n{\n \treturn vec2(r(n.x*63.62-234.0+n.y*84.35),r(n.x*45.13+156.0+n.y*13.89)); \n}\n\nfloat voronoi2D(in vec2 n)\n{\n    float dis = 2.0;\n    for (int y= -1; y <= 1; y++) \n    {\n        for (int x= -1; x <= 1; x++) \n        {\n            // Neighbor place in the grid.\n            vec2 p = floor(n) + vec2(x,y);\n\n            float d = length(r(p) + vec2(x, y) - fract(n));\n            if (dis > d)\n            {\n             \tdis = d;   \n            }\n        }\n    }\n    \n    return 1.0 - dis;\n}\n\n// Four octave voronoi FBM.\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000 * voronoi2D( p ); p = p * 2. * m;\n    f += 0.2500 * voronoi2D( p ); p = p * 2. * m;\n    f += 0.1250 * voronoi2D( p ); p = p * 2. * m;\n    f += 0.0625 * voronoi2D( p );\n    return f;\n}\n\nfloat GetFBM( vec2 q, out vec4 ron)\n{\n    // Base motion.\n    float ql = length( q * m );\n\n    // First layer.\n    vec2 o;\n    \n    // Vice versing fbm's addition for points gives nice result.\n    // Note that we pass q length inside outer fbm4 to get a circle pattern.\n    o = vec2(fbm4(vec2(0.5 * ql - time) + fbm6( vec2(2.0 * q + vec2(q)))));\n\n    // Second layer. Note that we use previous result as input.\n    vec2 n;\n    n = vec2(fbm4(q + fbm6( vec2(2.0 * o + vec2(o)))));\n    \n    // Sum of points with increased sharpness. \n    vec2 p = 4.0 * o + 6.0 * n;\n    float f = 0.5 + 0.5 * fbm6(p);\n\n    // I have seen that cubic mixing a couple of times\n    // is it just gives a nice result, or there is something\n    // behind it? Anyone?\n    f = mix( f, f * f * f * 3.5, f * abs(n.y));\n\n    f *= 1.0 - 0.5 * pow( f, 8.0 );\n    \n\tron = vec4( o, n );\n\n    return f;\n}\n\n\n// Main color mixing function.\nvec3 GetColor(vec2 p)\n{\n    vec4 on = vec4(0.0);\n    \n    float f = GetFBM(p, on);\n    \n    vec3 col = vec3(0.0);\n    \n    // You can play with this. Nothing really complex.\n    col = mix( vec3(0.78, 0.45, 0.06), vec3(0.35, 0.0, 0.4), f );\n    col = mix( col, vec3( 0.81, 0.55, 0.0), dot(on.xy, on.zw));\n\n    return col * col * 4. * 0.4545;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Aspect ratio - UV normalization.\n   \tvec2 p = (2. * fragCoord - iResolution.xy ) / iResolution.y;\n    \n    // Zoom level.\n    p *= 5.;\n\n    // Time varying pixel color.\n    vec3 col = GetColor(p);\n\n    // Output to screen.\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVyzV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[275, 356, 388, 388, 419], [421, 470, 492, 492, 915], [917, 1057, 1075, 1075, 1114], [1116, 1116, 1132, 1132, 1209], [1211, 1211, 1239, 1239, 1619], [1621, 1649, 1671, 1671, 1890], [1892, 1892, 1929, 1949, 2761], [2764, 2795, 2818, 2818, 3137], [3139, 3139, 3196, 3237, 3461]], "test": "ok"}
{"id": "lsycDG", "name": "Doodling #7: Speed", "author": "lsdlive", "description": "Doodling session for live-coding or sketching new ideas.\nThanks to iq, mercury, lj, shane, shau, aiekick, balkhan & all shadertoyers.\nGreets to all the shader showdown paris gang.\n\nMusic by CoLD SToRaGE for the game wipEout.", "tags": ["tunnel", "raymarch", "speed", "doodling"], "likes": 61, "viewed": 7041, "published": "Public", "date": "1523118896", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// @lsdlive\n\n// Doodling session for live-coding or sketching new ideas.\n// Thanks to iq, mercury, lj, shane, shau, aiekick, balkhan\n// & all shadertoyers.\n// Greets to all the shader showdown paris gang.\n\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvoid amod(inout vec2 p, float m) {\n\tfloat a = mod(atan(p.x, p.y) - m*.5, m) - m*.5;\n\tp = vec2(cos(a), sin(a)) * length(p);\n}\n\nfloat rep(float p, float m) {\n\treturn mod(p - m*.5, m) - m*.5;\n}\n\nvec3 rep(vec3 p, float m) {\n\treturn mod(p - m*.5, m) - m*.5;\n}\n\nfloat cmin(float a, float b, float k) {\n\treturn min(min(a, b), (a - k + b) * sqrt(.5));\n}\n\nfloat stmin(float a, float b, float k, float n) {\n\tfloat s = k / n;\n\tfloat u = b - k;\n\treturn min(min(a, b), .5 * (u + a + abs((mod(u - a + s, 2. * s)) - s)));\n}\n\nfloat length8(vec2 p) {\n\tvec2 q = p*p*p*p*p*p*p*p;\n\treturn pow(q.x + q.y, 1. / 8.);\n}\n\nfloat torus82(vec3 p, vec2 d) {\n\tvec2 q = vec2(length(p.xz) - d.x, p.y);\n\treturn length8(q) - d.y;\n}\n\nfloat path(float t) {\n\treturn cos(t*.1)*2.;\n}\n\nfloat g = 0.;\nfloat de(vec3 p) {\n\n\tp.x -= path(p.z);\n    \n    vec3 q = p;\n    q.x += sin(q.z*.2)*4.;\n    q.y += cos(q.z*.3)*4.;\n    q += iTime*2.;\n    q.yz += sin(iTime*.2)*4.;\n    q = rep(q, 1.);\n    float s1 = length(q) - .01 + sin(iTime*30.)*.004;\n\n\tp.z = rep(p.z, 3.);\n\n\tfloat d = torus82(p.xzy, vec2(1., .1));\n\tfloat pl = p.y + 2.4 + p.y*texture(iChannel1, p.xz*.1).r*1.;\n    float pl2 = p.y + .7;\n\td = min(d, pl-d*.9);\n    d = cmin(d, pl2, .1);\n\n\tamod(p.xy, 6.28 / 3.);\n\tp.x = abs(p.x) - 1.;\n\tfloat cyl = length(p.xy) - .05;\n\td = stmin(d, cyl, .1, 4.);\n   \n    d = min(d, s1);\n\n\tg += .015 / (.01 + d*d);\n\treturn d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord - .5*iResolution.xy) / iResolution.y;\n\n\tfloat dt = iTime * 8.3;\n\n\tvec3 ro = vec3(0, 0, -3. + dt);\n\tvec3 ta = vec3(0, 0, dt);\n\tro.x += path(ro.z);\n\tta.x += path(ta.z);\n\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = cross(vec3(0, 1, 0), fwd);\n\tvec3 up = cross(fwd, left);\n\tvec3 rd = normalize(fwd + uv.x*left + uv.y*up);\n\n\trd.xy *= r2d(sin(-ro.x / 3.14)*.4);\n\n\tvec3 p;\n\tfloat t = 0., ri;\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tri = i;\n\t\tp = ro + rd*t;\n\t\tfloat d = de(p);\n\t\tif (d < .001) break;\n\t\tt += d*.3;\n\t}\n\n\tvec3 bg = vec3(.2, .1, .2);\n\tvec3 col = bg;\n\tcol = mix(vec3(.4, .52, .6)*1.5, bg,  uv.x*uv.y*uv.y+ri);\n    col += g*.01;\n    col.b += sin(p.z*.1)*.1;\n\tcol = mix(col, bg, 1. - exp(-.01*t*t));\n    \n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4s2XWw", "previewfilepath": "https://soundcloud.com/brandon-mark-8/cold-storage-slipstream-volume-one-03-cairodrome?in=user-881335089/sets/wipeout-cold-storage", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/brandon-mark-8/cold-storage-slipstream-volume-one-03-cairodrome?in=user-881335089/sets/wipeout-cold-storage", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsycDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 207, 226, 226, 286], [288, 288, 322, 322, 412], [414, 414, 443, 443, 478], [480, 480, 507, 507, 542], [544, 544, 583, 583, 633], [635, 635, 684, 684, 796], [798, 798, 821, 821, 883], [885, 885, 916, 916, 985], [987, 987, 1008, 1008, 1032], [1048, 1048, 1066, 1066, 1656], [1658, 1658, 1713, 1713, 2473]], "test": "error"}
{"id": "lsycWy", "name": "SickBow's Sines", "author": "sickbow", "description": "sines", "tags": ["sines"], "likes": 3, "viewed": 485, "published": "Public", "date": "1523143574", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 smoothSine(vec2 uv, vec3 background, float freq, float amp, float size, vec2 shift, vec3 baseCol){\n    vec3 ret = background;\n    \n    vec2 sine = vec2(uv.x, shift.y + amp*sin(uv.x*freq+shift.x));\n    \n    //vector tangent to curve\n    //vec2 tang = vec2(uv.x, shift.y + amp*cos(uv.x*freq+shift.x));\n    \n    //vector normal to curve\n    //vec2 norm = normalize(-1.*vec2(tang.y,tang.x));\n    \n    float dist = length(uv-sine);\n    \n    if (dist < size){\n     ret = background + smoothstep(size,0.,dist);   \n    }\n    \n \tret*=baseCol;\n    \n    return ret;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 qr = fragCoord/iResolution.xy;\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float freq = smoothstep(.75,.1,(texture(iChannel0, vec2(qr.x,1))).x);\n    \n    vec3 baseCol = vec3(cos(iTime)*uv.x*181./255., 199./255., 229./255.);\n    \n    vec3 col = vec3(0);\n    \n    //should use loop here\n    col = smoothSine(uv, col, sin(iTime+.3)*5., freq/7.+.25, .01, vec2(6.*iTime+.3,-0.10625 + sin(2.*iTime)/6.), baseCol);\n    col = smoothSine(uv, col, sin(iTime+.25)*5., freq/6.+.25, .0125, vec2(6.*iTime+.25,-0.1125+ sin(2.*iTime+.05)/6.), baseCol);\n    col = smoothSine(uv, col, sin(iTime+.2)*5., freq/5.+.25, .015, vec2(6.*iTime+.2,-0.125+ sin(2.*iTime+.1)/6.), baseCol);\n    col = smoothSine(uv, col, sin(iTime+.15)*5., freq/4.+.25, .0175, vec2(6.*iTime+.15,-0.15+ sin(2.*iTime+.15)/6.), baseCol);  \n\tcol = smoothSine(uv, col, sin(iTime+.1)*5., freq/5.+.25, .02, vec2(6.*iTime+.1,0.-.2+ sin(2.*iTime+.2)/6.), baseCol);\n    col = smoothSine(uv, col, sin(iTime+.05)*5., freq/6.+.25, .0225, vec2(6.*iTime+.05,-.3+ sin(2.*iTime+.25)/6.), baseCol);\n    col = smoothSine(uv, col, sin(iTime)*5., freq/7.+.25, .025, vec2(6.*iTime,-.425+ sin(2.*iTime+.3)/6.), baseCol); \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xd2XWm", "previewfilepath": "https://soundcloud.com/thetaildragger/tool-the-grudge-2001?in=michael-cilona/sets/dank", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/thetaildragger/tool-the-grudge-2001?in=michael-cilona/sets/dank", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsycWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 103, 103, 566], [568, 568, 625, 661, 1904]], "test": "error"}
{"id": "lsyyDK", "name": "Moving dotted pattern", "author": "Sunpy", "description": "Scalable dotted pattern", "tags": ["pattern"], "likes": 1, "viewed": 99, "published": "Public", "date": "1523355544", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define COLOR1 vec4(0.0, 0.0, 0.8, 1.0)\n#define COLOR2 vec4(0.8, 0.0, 0.7, 1.0)\n\n// Feel free to change these ;)\nconst float HEIGHT = 6.0,\n\t\t\tRADIUS = 0.5;\n\n// Author's note:\n// I added comment blocks where I can see the old code vs\n// the new code donated by FabriceNeyret2 ;)\n// This is useful for me as a beginner as I can go back and\n// easily re-read this and recheck my code for simular things.\nvec4 getCol(vec2 uv){\n    /*/\n    bool c = true;\n    \n    if (floor(fract(uv.x * 0.5) * 2.0) == 0.0)\n        c = false;\n    \n    if (floor(fract(uv.y * 0.5) * 2.0) == 0.0)\n        c = !c;    \n    \n    if (c)\n        return COLOR1;\n    return COLOR2;\n\t/*/\n    uv = floor(uv);\n    return mod(uv.x + uv.y, 2.0) == 0.0 ? COLOR1 : COLOR2;\n    /**/\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv_r = fragCoord / iResolution.y * HEIGHT;\n    \n    /*/\n    bool direction = mod(iTime, 2.0) > 1.0;\n    float shift = floor(direction ? uv_r.x : uv_r.y);\n    shift = 2.0 * mod(shift,2.) - 1.0;\n\n\tif (direction)\n    \tuv_r.y += shift * iTime;\n    else\n        uv_r.x += shift * iTime;\n\t/*/\n    int direction = int(iTime) % 2;\n    float shift = floor(uv_r)[1 - direction];\n    shift = 2.0 * mod(shift,2.) - 1.0;\n    uv_r[direction] += shift * iTime;\n    /**/\n    \n    float dist = 1.0 - length(fract(uv_r) - 0.5) / RADIUS;\n    //float dist = 1.0 - distance(uv_r - 0.5, floor(uv_r)) / RADIUS;\n    \n    fragColor = dist * getCol(uv_r);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsyyDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 401, 422, 655, 745], [747, 747, 801, 801, 1442]], "test": "ok"}
{"id": "lsyyzK", "name": "Doodling #4: Structures", "author": "lsdlive", "description": "Things I did before the Revision 2018 to train shader showdown (but showmatch were cancelled).\n\nVarious utilities code from iq, lj, mercury, shane, aiekick & balkhan.", "tags": ["tunnel", "raymarch"], "likes": 19, "viewed": 388, "published": "Public", "date": "1522593583", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// @lsdlive\n\nfloat dt =0.;\nvec2 path(float t) {\n\tfloat a = sin(t*.2 + 1.5), b = sin(t*.2);\n\treturn vec2(a*2., a*b);\n}\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvoid amod(inout vec2 p, float m) {\n\tfloat a = mod(atan(p.x, p.y) - m*.5, m) - m*.5;\n\tp = vec2(cos(a), sin(a)) * length(p);\n}\n\nvoid mo(inout vec2 p, vec2 d) {\n\tp.y = abs(p.y) - d.x;\n\tp.x = abs(p.x) - d.y;\n\tif (p.y > p.x) p.xy = p.yx;\n}\n\nfloat sc(vec3 p, float s) {\n\tp = abs(p);\n\tp = max(p, p.yzx);\n\treturn min(p.x, min(p.y, p.z)) - s;\n}\n\nfloat od(vec3 p, float s) {\n\treturn dot((p),normalize(sign(p)))-s;\n}\n\nfloat rep(float p, float m) {\n\treturn mod(p-m*.5, m) - m*.5;\n}\n\nfloat g = 0.;\nfloat id=0.;\nfloat de(vec3 p) {\n    p.xy -= path(p.z);\n    \n   // float s1 = length(p-vec3(0, 0, 2.+dt+sin(iTime))) -.2 - sin(iTime)*.1;\n    vec3 q = p;\n    q -= vec3(0, 0, 2.+dt+sin(iTime));\n    q.xz*=r2d(iTime);\n    q.xy*=r2d(iTime);\n    float s1 = od(q, .2- sin(iTime)*.1);\n    \n    q = p;\n    q.xy*=r2d(q.z*.1);\n    amod(q.xy, 4./6.28);\n    q.x = abs(q.x) - 3.;\n    float cyl = length(q.xy) - .3;\n    \n    \n    p.xy *= r2d(iTime*.4);\n    \n    //p.y += 2.;\n    \n    //p.xy *= r2d(p.z*.4);\n    \n    \n    amod(p.xy, 12./6.28);\n    mo(p.xy, vec2(2, 2.));\n    //mo(p.zy, vec2(.04, .7));\n    \n    p.xy *= r2d(p.z*.2);\n    \n    p.z = rep(p.z, 1.);\n    \n    \n    amod(p.xy, .785);\n    \n    //p.x = abs(p.x) - 1.;\n\tmo(p.xy, vec2(.8, .4));\n    \n    float sc2 = sc(p, .5);\n    \n    p.xy *= r2d(3.14*.25);\n    \n    float d = sc(p, .3);\n    d = max(d, -sc2);\n    d = min(d, s1);\n    if(d<cyl) {\n        id = 1.;\n        //d= d;\n    }else {\n        id = 2.;\n       // d= cyl;\n    }\n\tg += .01 / (.02 + d*d);\n\treturn d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tdt = iTime * 6.;\n\tvec3 ro = vec3(0, 0, -3. + dt);\n\tvec3 ta = vec3(0, 0, dt);\n\n\tro.xy += path(ro.z);\n\tta.xy += path(ta.z);\n\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = cross(vec3(0, 1, 0), fwd);\n\tvec3 up = cross(fwd, left);\n\n\tvec3 rd = normalize(fwd + left*uv.x + up*uv.y);\n\n\tvec3 p;\n\tfloat ri, t = 0.;\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tri = i;\n\t\tp = ro + rd*t;\n\t\tfloat d = de(p);\n\t\tif (d < .001) break;\n\t\tt += d*.3;\n\t}\n\tvec3 bg = vec3(.2, .1, .2);\n\tvec3 col = mix(vec3(1., .0, .0), bg, uv.x+ri);\n    /*if(id == 2.)*/ col.g += sin(p.z*.1)*.4; \n       // col = mix(vec3(.3, .1+sin(p.z)*.3, .2), bg, ri);\n\tcol += g*.03;\n\tcol = mix(col, bg, 1. - exp(-.01*t*t));\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsyyzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 47, 47, 117], [119, 119, 138, 138, 198], [200, 200, 234, 234, 324], [326, 326, 357, 357, 434], [436, 436, 463, 463, 535], [537, 537, 564, 564, 605], [607, 607, 636, 636, 669], [698, 698, 716, 716, 1694], [1696, 1696, 1751, 1751, 2536]], "test": "ok"}
{"id": "Md3Bz7", "name": "torus normal uv distortion", "author": "mv", "description": "Inspired by an attempt to understand what has been done here: https://twitter.com/klemen_lozar/status/987743611289681920", "tags": ["torus", "distortion", "uv", "normal"], "likes": 5, "viewed": 457, "published": "Public API", "date": "1524496489", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 split_uv(vec2 uv) {\n    return uv - vec2(0.5*sign(uv.x)*iResolution.x/iResolution.y, 0.0);\n}\n\nvec3 get_normal(vec2 uv) {\n    // http://web.cs.ucdavis.edu/~amenta/s12/findnorm.pdf\n \tuv = uv * (1.0 + 0.6*cos(iTime));\n    \n    float phi = 2.0*3.1416*uv.x;\n    float theta = 2.0*3.1416*uv.y;\n    \n    vec3 dphi = vec3(-sin(phi), cos(phi), 0.0);\n    vec3 dtheta = vec3(-sin(theta)*cos(phi), -sin(theta)*sin(phi), cos(theta));\n    \n    return normalize(cross(dphi, dtheta));  \n}\n\nfloat checkerboard(vec2 uv, float size) {\n    // https://www.shadertoy.com/view/lt2XWK\n\tvec2 p = floor(uv / size);\n    return mod(p.x + p.y, 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float cell_size = 0.125*iResolution.x/iResolution.y;\n    \n    // uv coordinates, corrected for aspect ratio\n    vec2 uv0 = (2.0*fragCoord.xy - iResolution.xy)/iResolution.yy;\n    \n    // uv coordinates split in half and duplicate left hand side\n    vec2 uv1 = split_uv(uv0);\n    \n    // grab the normals from the torus using these uv coordinates\n    vec3 n = get_normal(uv1.yx);\n    \n    // distort uv's based on normal\n    uv1 = uv1 + 0.1*cell_size*n.xy;\n    \n    // apply a scrolling motion upwards\n    uv1 = uv1 - vec2(0.0, 0.2*iTime);\n    \n    // create a checkerboard effect\n    float s = checkerboard(uv1, cell_size);\n    \n    // output\n    if (uv0.x > 0.0) {   \n        fragColor = vec4(s, s, s, 1.0);\n        //fragColor = texture(iChannel0, uv1/cell_size);\n    } else {\n    \tfragColor = vec4(0.5 + 0.5*n, 1.0);\n    }\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md3Bz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 97], [99, 99, 125, 183, 477], [479, 479, 520, 565, 627], [629, 629, 686, 686, 1518]], "test": "ok"}
{"id": "Md3BzN", "name": "spiraltest", "author": "halcy", "description": "set SPEC_INTENS to a high value to make everything look, well, more intense.", "tags": ["test"], "likes": 5, "viewed": 300, "published": "Public", "date": "1524249020", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Various knobs to twiddle\n#define MIN_DIST 0.001\n#define STEP_MULTIPLIER 0.9\n#define NORMAL_OFFSET 0.01\n#define MAX_STEPS 64\n#define RAY_FUZZ 0.001\n#define SPEC_INTENS 0.7\n\n// Shit sync\n#define BPM 128.0\n#define SPEED (BPM / 60.0) * 3.14 * 0.25\n\n// Palette helper\nvec3 color(float inVal, float glow) {\n\tvec3 col = \n        mix(\n           mix(\n           \tvec3(0.3, 0.3, 0.4),\n           \tvec3(0.2, 0.5, 1.0),\n           \tabs(clamp(inVal - 0.75, 0.0, 0.25)) * 4.0\n           ),\n           vec3(0.5, 1.0, 1.0) * (0.8 + glow * 3.0),\n           abs(clamp(inVal - 0.9, 0.0, 0.1)) * 10.0\n        );\n    return col;\n}\n\n// For fuzzing up rays a little\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n// Distance / color combiner\nvec4 distcompose(vec4 dista, vec4 distb, float softness) {\n    float mixfact = clamp(0.5 + 0.5 * (distb.a - dista.a) / softness, 0.0, 1.0);\n    return mix(distb, dista, mixfact) - vec4(0.0, 0.0, 0.0, softness * mixfact * (1.0 - mixfact));\n}\n\n// World\nvec4 distfunc(vec3 pos, float glow) {\n  \tfloat dist = -(length(pos.xy) - 0.4 + cos(pos.z * 20.0 + atan(pos.y, pos.x)) * 0.04);\n    \n    float abspos = pos.z - iTime * 0.2 * SPEED;\n    dist -= texture(iChannel0, vec2((cos(abspos * 1.3) + 1.0) / 2.0, 0.0)).r * 0.1 * SPEC_INTENS;\n    \n    float ranp = sin(pos.z + iTime * 2.0 * SPEED);\n    float line = (length(pos.xy - vec2(0.0, 0.1)) - 0.001) + (ranp > 0.7 ? 0.0 : 1000.0);\n    \n    ranp = sin(pos.z + iTime * 1.7 * SPEED);\n    line = min(line, (length(pos.xy - vec2(-0.2, 0.06)) - 0.001) + (ranp > 0.7 ? 0.0 : 1000.0));\n    \n    ranp = sin(pos.z + iTime * 2.2 * SPEED);\n    line = min(line, (length(pos.xy - vec2(-0.2, -0.11)) - 0.001) + (ranp > 0.7 ? 0.0 : 1000.0));\n    \n    ranp = sin(pos.z + iTime * 2.5 * SPEED);\n    line = min(line, (length(pos.xy - vec2(0.1, -0.2)) - 0.001) + (ranp > 0.7 ? 0.0 : 1000.0));\n    \n    vec4 lines = vec4(0.8, 0.8, 1.0, line);\n    \n        \n    float colsel = cos(sin(atan(pos.y, pos.x) * 5.0 + pos.z * 10.0));\n    float colval = cos(sin(atan(pos.y, pos.x) * 10.0 + pos.z * 20.0));\n\t\n    if(mod(iTime * SPEED, 3.14 * 0.5) < 3.14 * 0.25) {\n    \tglow = glow * (colsel < 0.75 ? 2.0 : 0.2);\n    }\n    else {\n        glow = glow * (colsel > 0.75 ? 2.0 : 0.2);\n    }\n    vec4 tube = vec4(color(colval, glow), dist);\n    return(distcompose(tube, lines, 0.0));\n}\n\n// Renderer\nvec4 pixel(vec2 fragCoord) {\n    float glow = abs(cos(mod(iTime * 2.0 * SPEED, 3.14 / 2.0))) / 3.0;\n    \n    // Screen -1 -> 1 coordinates\n    vec2 coords = (2.0 * fragCoord.xy  - iResolution.xy) / max(iResolution.x, iResolution.y);\n    \n    // Camera as eye + imaginary screen at a distance\n    vec3 eye = vec3(cos(iTime * SPEED) * 0.1, 0.0, iTime * 0.2 * SPEED);\n    vec3 lookat = vec3(cos(iTime * SPEED) * 0.1, 0.0, iTime * 0.2 * SPEED + 1.0);\n    vec3 lookdir = normalize(lookat - eye);\n    vec3 left = normalize(cross(lookdir, vec3(cos(iTime * 0.1 * SPEED), -sin(iTime * 0.1 * SPEED), 0.0)));\n    vec3 up = normalize(cross(left, lookdir));\n    vec3 lookcenter = eye + lookdir;\n\tvec3 pixelpos = lookcenter + coords.x * left + coords.y * up;\n    vec3 ray = normalize(pixelpos - eye);\n    ray += hash33(ray) * RAY_FUZZ;\n    \n    vec3 lightpos = vec3(eye.x, eye.y, eye.z + 0.8);\n    \n    // March\n    vec3 pos = eye;\n    float dist = 0.0;\n    float curdist = 1.0;\n    float iters = float(MAX_STEPS);\n    for(int i = 0; i < MAX_STEPS; i++) {\n        curdist = distfunc(pos, glow).a;\n        dist += curdist * STEP_MULTIPLIER;\n        pos = eye + ray * dist;\n        if(curdist < MIN_DIST) {\n        \titers = float(i);\n            break;\n        }\n    }\n    \n    vec3 shadowray = normalize(lightpos - pos);    \n    vec2 d = vec2(NORMAL_OFFSET, 0.0);\n    vec3 normal = normalize(vec3(\n        distfunc(pos + d.xyy, glow).a - distfunc(pos - d.xyy, glow).a,\n        distfunc(pos + d.yxy, glow).a - distfunc(pos - d.yxy, glow).a,\n        distfunc(pos + d.yyx, glow).a - distfunc(pos - d.yyx, glow).a\n    ));\n    float light = min(1.0, max(0.0, dot(normal, shadowray)) + 0.01);\n    vec4 color = light * distfunc(pos, glow);\n    color = color + vec4(0.5, 1.0, 1.0, 1.0) * iters * 0.05 * glow;\n\treturn(color);\n}\n\n// Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = pixel(fragCoord);\n}", "image_inputs": [{"id": "XsjXzy", "previewfilepath": "https://soundcloud.com/user-188235281/prototyperaptor-awe", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/user-188235281/prototyperaptor-awe", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md3BzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 266, 303, 303, 613], [615, 647, 667, 667, 771], [773, 802, 860, 860, 1042], [1044, 1053, 1090, 1090, 2394], [2396, 2408, 2436, 2436, 4211], [4213, 4222, 4277, 4277, 4313]], "test": "error"}
{"id": "MdcBRn", "name": "Bonometaballs", "author": "bonofobia", "description": "blobbiething", "tags": ["blobs"], "likes": 2, "viewed": 92, "published": "Public", "date": "1523957732", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//A metaball 'tutorial'\n#define ANIMATION_SPEED_FACTOR 1.0\n    \n#define NUM_BLOBS 10\n#define SPHERE 0\n#define CUBE 1\n#define DIAMOND 2\n#define HLINE 3\n#define VLINE 4\n\nvec4 colorize(float energy)\n{\n    vec3 color=vec3(energy,0,0);\n    if(energy>1.0)\n    {\n        color.x=1.0;\n        color.z=energy-1.0;\n    }\n    if(energy>2.0)\n    {\n        color.x=1.0;\n        color.y=energy-2.0;\n        color.z=1.0;\n    }\n    return vec4(color,1.0);\n}\n\n\nstruct blob {float distribution; float sd;float cd; int type;};   \nblob[] blobs=blob[NUM_BLOBS]\n(\n\tblob(10.0,\t1.57,\t\t3.14,\tSPHERE),\n    blob(15.0,\t3.14, \t\t1.57,\tSPHERE),\n    blob(20.0,\t3.24, \t\t1.77,\tSPHERE),\n    blob(25.0,\t3.34, \t\t1.97,\tSPHERE),\n    blob(30.0,\t3.44, \t\t2.17,\tSPHERE),\n    blob(35.0,\t3.54, \t\t2.37,\tSPHERE),\n    blob(20.0,\t1.05,\t\t0.63,\tCUBE),\n    blob(10.0,\t0.68, \t\t1.05,\tDIAMOND),\n    blob(100.0,\t0.0, \t\t1.0,\tHLINE),\n    blob(100.0,\t2.15, \t\t0.0,\tVLINE)\n    \n);    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n    \n    float energy=0.0;\n    float hx=iResolution.x/2.0;\n    float hy=iResolution.y/2.0;\n    float ratio=iResolution.x;\n    \n    float tt=iTime/(1.0/ANIMATION_SPEED_FACTOR);\n    \n    for(int i=0;i<NUM_BLOBS;i++)\n    {\n        blob b=blobs[i];\n        float radius=ratio/b.distribution;\n        float bx=(hx-radius)*sin(b.sd*tt)+hx;\n        float by=(hy-radius)*cos(b.cd*tt)+hy;\n        switch(b.type)\n        {\n            case SPHERE:\n            \tenergy+=radius/sqrt(pow(uv.x-bx,2.0)+pow(uv.y-by,2.0));\n            \tbreak;\n            case CUBE:\n            \tenergy-=radius/max(abs(uv.x-bx),abs(uv.y-by));\n            \tbreak;\n            case DIAMOND:\n            \tenergy-=radius/(abs(uv.x-bx)+abs(uv.y-by));\n            \tbreak;\n           \tcase HLINE:\n            \tenergy+=radius/abs(uv.y-by);\n            \tbreak; \n           \tcase VLINE:\n            \tenergy+=radius/abs(uv.x-bx);\n            \tbreak;        }\n    }\n    fragColor=colorize(energy);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdcBRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 197, 197, 441], [924, 924, 981, 981, 1961]], "test": "error"}
{"id": "MdcfRr", "name": "hexaspinner", "author": "sapph0", "description": "mlem", "tags": ["spinner"], "likes": 1, "viewed": 96, "published": "Public", "date": "1523994415", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\n#define TAU PI*2.\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat pow3(float x) {\n    return x*x*x;\n}\n\nfloat ease(float t) {\n  return .5*(pow3(2.*t-1.)+1.);\n}\n\n// soft clamp a sdf edge to get free AA\nfloat aaEdge(float dist) {\n    float pixelSize = 4./iResolution.y;\n    return clamp(dist/pixelSize, 0., 1.);\n}\n\nvec4 easeblob(vec2 uv) {\n    float t = .5*(sin(iTime)+1.);\n    \n    float val = 1.;\n    for (float i=0.; i<6.; i++) {\n        float ang = i/6.*TAU + iTime/2.;\n        vec2 v = vec2(cos(ang), sin(ang))*.5;\n    \tvec2 pos = mix(v, -v, ease(t));\n\n        float blobval = aaEdge(length(uv-pos)-.1);\n    \tval = mix(blobval, val, blobval);\n    }\n\n    return vec4(vec3(val), 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // pixel coords ∈ [-1, 1]^2\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n  \n    fragColor = easeblob(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdcfRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 130, 130, 150], [152, 152, 173, 173, 207], [209, 249, 275, 275, 359], [361, 361, 385, 385, 734], [736, 736, 791, 825, 921]], "test": "error"}
{"id": "MddfD8", "name": "loop-6", "author": "erwin94", "description": "Some trigonometry tests, with a bit of polishing", "tags": ["checkerboard", "abstract", "loop"], "likes": 4, "viewed": 79, "published": "Public", "date": "1524989670", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nvec2 star(vec2 uv, vec2 center, float rot, float reps) {\n    vec2 diff = uv - center;\n    float c = atan(diff.y, diff.x)*reps + rot;\n    return vec2(clamp(cos(c)*5., -1., 1.), mod(c/4.0/M_PI, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv_sq = fragCoord/iResolution.xx;\n\n    //vec2 c1 = vec2(-0.1-sin(iTime/5.)/4.-0.25, 0.1);\n    //vec2 c2 = vec2(1.1+sin(iTime/5.)/4.+0.25, 0.1);\n    vec2 c1 = vec2(-0.1, 0.1);\n    vec2 c2 = vec2(1.1, 0.1);\n\tfloat reps = 50.;\n    float speed = 1.8;\n\n    vec2 s1 = star(uv_sq, c1,  iTime*speed, reps);\n    vec2 s2 = star(uv_sq, c2, -iTime*speed, reps);\n    \n    float c = smoothstep(0., 1., uv.y) * clamp(s1.x, 0., 1.0) * clamp(s2.x, 0., 1.0)\n            + smoothstep(0., 1., 1.-uv.y) * clamp(-s1.x, 0., 1.0) * clamp(-s2.x, 0., 1.0);\n\n    vec2 uv_distort = vec2(s1.y, s2.y);\n    float noise = texture(iChannel0, uv_distort).r*.6 + 0.3;\n    float vignette = pow((1.0-length(uv-0.5)-.2)*1.5, 2.);\n    \n    vec3 fg_color = vec3(0.8,1.3,1.5);\n    vec3 bg_color = vec3(0.08,0.05,0.05);\n\n    vec3 linearCol = (c*fg_color + bg_color) * noise * vignette;\n\n    float displayGamma = 2.2;\n    fragColor.r = pow ( linearCol.r, 1.0/displayGamma );\n    fragColor.g = pow ( linearCol.g, 1.0/displayGamma );\n    fragColor.b = pow ( linearCol.b, 1.0/displayGamma );\n    fragColor.a = 1.0;\n}\n\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MddfD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 104, 104, 248], [250, 250, 307, 307, 1427]], "test": "error"}
{"id": "MddfR7", "name": "escherized tiling 3", "author": "FabriceNeyret2", "description": "define 3 polylines for the 6 brick segments: (must visit corners + midside)\n .---1---.---2---.\n |                   |\n 3                 3\n |                   |\n .---2---.---1---.\nrobust colored version of [url]https://www.shadertoy.com/view/MstBR7[/url]", "tags": ["escher", "pattern", "tile", "mz"], "likes": 2, "viewed": 436, "published": "Public API", "date": "1524577172", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// better filling variant of https://shadertoy.com/view/lsdBR7\n// colored variant of https://shadertoy.com/view/MstBR7\n\n// polylines must pass to corners and mid-side of brick.\n// trying to release the last constraint here: https://www.shadertoy.com/view/lsdfR7\n\n#define MM 0\nfloat  CELL = 5.,                  // grid size vertically -> cell size\n      RATIO = 2.,                  // brick length / brick width\n      BEVEL = .2,                  // bevel width ( cell %  )\n       GAP  = 0.;                  // inter brick gap ( cell % )\n\nvec2  CYCLE = 0.*vec2(3,2);        // pattern repeat scale ( in #brick )\n\n#define SHAPE 0                    // 0...6 : presets of shapes\n#define ANIM  1                    // anim (for demo) \n\n#if SHAPE==0 \nbool  BRICK = true;                // tiling or bricks\n//bool  BRICK = false;             // tiling or bricks\n\n// .---1---.---2---.\n// |               |\n// 3               3\n// |               |\n// .---2---.---1---.\n// polylines must pass to corners and mid-side of brick.\nvec2 polyline1[] = vec2[]( vec2(0,0), vec2(.25,.1), vec2(.75,-.1),vec2(1,0) );\nvec2 polyline2[] = vec2[]( vec2(0,0), vec2(.25,.3), vec2(.5,.1), vec2(.3,0),vec2(.5,-.2), vec2(.75,-.3),vec2(1,0) );\nvec2 polyline3[] = vec2[]( vec2(0,0), vec2(.1,-.25), vec2(0,-.4), vec2(-.5,-.5),vec2(-1.,-.3), vec2(-.8,-.2),vec2(-1.2,-.3), vec2(-.3,-.75),vec2(0,-1) );\n\n#elif SHAPE==1\n\nbool  BRICK = false;                // tiling or bricks\nvec2 polyline1[] = vec2[]( vec2(0,0), vec2(.7,.3),vec2(1.3,-.3), vec2(2,0));\nvec2 polyline2[1];\nvec2 polyline3[] = vec2[]( vec2(0,0), vec2(-.3,-.6), vec2(0,-1));                          \n\n#elif SHAPE==2\n\nbool  BRICK = true;                // tiling or bricks\nvec2 polyline1[] = vec2[]( vec2(0,0),vec2(.5,0),vec2(.43,-.33),vec2(.76,-.33),vec2(.7,0),vec2(1,0));\nvec2 polyline2[] = vec2[]( vec2(0,0),vec2(.3,0),vec2(.23, .33),vec2(.56, .33),vec2(.5,0),vec2(1,0));\nvec2 polyline3[] = vec2[]( vec2(0,0), vec2(0,-.4),vec2(-.33,-.33),vec2(-.33,-.66),vec2(0,-.6),vec2(0,-1));                          \n\n#elif SHAPE==3\n\nbool  BRICK = true;                // tiling or bricks\nvec2 polyline1[] = vec2[]( vec2(0,0),vec2(.25,.2),vec2(.75,-.2),vec2(1,0));\nvec2 polyline2[] = vec2[]( vec2(0,0),vec2(.25,.2),vec2(.75,-.2),vec2(1,0));\nvec2 polyline3[] = vec2[]( vec2(0,0),vec2(.2,-.25),vec2(-.2,-.75),vec2(0,-1));\n\n#elif SHAPE==4 \n\n#define RATIO 1.\nbool  BRICK = false;               // tiling or bricks\nvec2 polyline1[] = vec2[]( vec2(0,0),vec2(.45,.25),vec2(.7,-.2),vec2(1,0));\nvec2 polyline2[1];\nvec2 polyline3[] = vec2[]( vec2(0,0),vec2(.25,-.45),vec2(-.2,-.7),vec2(0,-1));\n\n#elif SHAPE==5 \n\nbool  BRICK = true;               // tiling or bricks\nvec2 polyline1[] = vec2[]( vec2(0,0),/*vec2(.2,.2), */vec2(.5,.3),vec2(1,0));\nvec2 polyline2[] = vec2[]( vec2(0,0),/*vec2(.2,-.2),*/vec2(.5,-.3),vec2(1,0));\nvec2 polyline3[] = vec2[]( vec2(0,0),vec2(-.4,-.5),vec2(0,-1));\n\n#elif SHAPE==6 \n\nbool  BRICK = true;               // tiling or bricks\nvec2 polyline1[] = vec2[]( vec2(0,0),vec2(1,0));\nvec2 polyline2[] = vec2[]( vec2(0,0),vec2(1,0));\nvec2 polyline3[] = vec2[]( vec2(0,0),vec2(0,-.3),vec2(-.1,-.3),vec2(-.4,-.1),vec2(-.6,-.1),vec2(-.9,-.3),vec2(-1.,-.5),vec2(-.9,-.7),vec2(-.6,-.9),vec2(-.4,-.9),vec2(-.1,-.7),vec2(0,-.7),vec2(0,-1));\n\n#endif\n\n\n// std int hash, inspired from https://www.shadertoy.com/view/XlXcW4\nvec3 hash3( uvec3 x )              // integer param\n{\n#   define scramble  x = ( (x>>8U) ^ x.yzx ) * 1103515245U // GLIB-C const\n    scramble; scramble; scramble; \n    return vec3(x) / float(0xffffffffU);\n}\nvec3 hash3f(vec3 x) {              // float[0,1] param\n    return hash3(uvec3( x * float(0xffffffffU) ) );\n}\n\n// distance to line\nfloat line( vec2 p, vec2 a, vec2 b )\n{\n    p -= a; b -= a;\n\tfloat h = dot(p,b)/dot(b,b),   // projection index on line in [0,1]\n         hs = clamp( h, 0., 1. ); \n\treturn length( p - b*hs );     // with round edges\n  //return h==hs ? length( p - b*hs ) : 1e5; // without round edge\n}\n\n// signed distance to line\nfloat sline( vec2 p, vec2 a, vec2 b , float s)\n{\n    p -= a; b -= a;\n\tfloat h = dot(p,b)/dot(b,b),   // projection index on line in [0,1]\n         hs = clamp( h, 0., 1. ), l;\n    p -= b*hs;                     // projection point on line\n    l = length(p) * s* sign(p.x*b.y-p.y*b.x); // signed distance to line\n\t//return l;                   // with round edges\n    return h==hs ? l : 1e5;       // without round edge\n}\n\n// distance to line + inside count\nfloat lineC( vec2 p, vec2 a, vec2 b , inout int c)\n{\n    p -= a; b -= a;\n    if ( p.y >= min(0.,b.y) && p.y < max(0.,b.y) \n        && b.y!=0. && b.x*p.y/b.y > p.x ) c++;\n\tfloat h = dot(p,b)/dot(b,b),    // projection index on line in [0,1]\n         hs = clamp( h, 0., 1. ); \n    p -= b*hs;                      // projection point on line\n\treturn length(p);               // with round edges\n  //return h==hs ? length(p) : 1e5; // without round edge\n}\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy; U /= R.y;          // normalized coordinates \n    O -= O;\n    vec2 W = vec2(RATIO,1);                     // normalize in cells units\n    U *= CELL/W;\n#if !MM                                         // <- demo mode\n     if (!BRICK && RATIO==2.) polyline1[polyline1.length()-1] = vec2(2,0);\n    BEVEL = 1.5*CELL/R.y;                       // 1-pixel thick line\n   #if ANIM                                     // animation\n    for (int i=1; i<polyline1.length()-1; i++)\n        polyline1[i] += .1*cos(iTime+float(i)+vec2(0,1.57));\n    for (int i=1; i<polyline2.length()-1; i++)\n        polyline2[i] += .1*cos(iTime+.3+float(i)+vec2(0,1.57));\n    for (int i=1; i<polyline3.length()-1; i++)\n        polyline3[i] += .05*cos(iTime+.6+float(i)+vec2(0,1.57));\n   #endif\n#endif\n    float ofs = mod(floor(U.y),2.);\n    if (BRICK) \n        U.x += .5*ofs;\n    else ofs = 0.;\n    vec2 S = W* (fract(U) - 1./2.);             // centered coords in a brick\n\n    float d = 1e5,s,l, X = RATIO/2.;\n    int c=0;\n    \n#define testline(O,T)                        \\\n        l =  lineC( S-O, _P, P , c) ;        \\\n        if ( l < d) d = l, D = T;\n    \n    vec2 P = polyline1[0], _P, D=vec2(0);\n    float X0 = BRICK ? 0. : -X;\n    for (int i=0; i < polyline1.length()-1; i++) {\n        _P = P; P = polyline1[i+1];\n        testline( vec2(-X, .5), vec2(  -ofs, 1) );\n        testline( vec2(X0,-.5), vec2(float(BRICK)-ofs,-1) );\n    }\n    if (BRICK) {\n    P = polyline2[0];\n    for (int i=0; i < polyline2.length()-1; i++) {\n        _P = P; P = polyline2[i+1];\n        testline( vec2( 0, .5), vec2(1.-ofs, 1) );\n        testline( vec2(-X,-.5), vec2(  -ofs,-1) );\n    }}\n    P = polyline3[0];\n    for (int i=0; i < polyline3.length()-1; i++) {\n        _P = P; P = polyline3[i+1];\n        testline( vec2( X, .5), vec2( 1,0) );\n        testline( vec2(-X, .5), vec2(-1,0) );\n    }\n    \n    if ((c&1)==1) D = vec2(0);\n\n    vec2 H = U+D+1.; // vec2 tile id\n    H = CYCLE==vec2(0) ? H : mod(H,CYCLE);\n    O += clamp ( (d-GAP)/BEVEL, 0., 1.); \n#if !MM    \n    O.rgb *= hash3(uvec3(H,2));\n#else  \n // O-=O;\n    O.r =  hash3(uvec3(H,2)).r;\n#endif    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MddfR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3280, 3349, 3402, 3402, 3555], [3556, 3556, 3577, 3610, 3664], [3666, 3686, 3724, 3724, 3969], [3971, 3998, 4046, 4046, 4417], [4419, 4454, 4506, 4506, 4905], [4908, 4908, 4946, 4946, 7092]], "test": "error"}
{"id": "MddfW8", "name": "Bokeh Cone Tracing", "author": "Klems", "description": "Cone traced depth of field, based on [url]https://www.shadertoy.com/view/4scBW8[/url], after a suggestion by bioccular. Not really the most efficient way of doing that particular effect... Now the last thing I want to try is cone traced motion blur.", "tags": ["3d", "raymarch", "dof"], "likes": 21, "viewed": 1328, "published": "Public API", "date": "1524987206", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define rot(a) mat2(cos(a + PI*0.25*vec4(0,6,2,0)))\n#define FOV 0.7\n\nconst vec3 forward = normalize(vec3(1, 2, 3));\n\n// Dave Hoskins hash\nvec3 hash33( in vec3 p3 ) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// cosine based hue to rgb conversion\nvec3 hue( in float c ) {\n    return cos(2.0*PI*c + 2.0*PI/3.0*vec3(3,2,1))*0.5+0.5;\n}\n\n// tonemapping from https://www.shadertoy.com/view/lslGzl\nvec3 filmicToneMapping( vec3 col ) {\n    col = max(vec3(0.), col - vec3(0.004));\n    return (col * (6.2 * col + .5)) / (col * (6.2 * col + 1.7) + 0.06);\n}\n\n// main distance function, returns distance, color and normal\nfloat de( in vec3 p, in float r, out vec3 color, out vec3 normal ) {\n    float d = 9e9;\n    color = vec3(0);\n    vec3 center = floor(p)+0.5;\n    float phase = 0.01*dot(p, forward);\n    \n    // 8 taps voronoi\n    for (float x = -0.5 ; x < 1.0 ; x++)\n    for (float y = -0.5 ; y < 1.0 ; y++)\n    for (float z = -0.5 ; z < 1.0 ; z++) {\n        vec3 sphere = center+vec3(x, y, z);\n        vec3 rnd = hash33(sphere);\n        sphere += (rnd-0.5)*0.3;\n        vec3 inSphere = p-sphere;\n        float len = length(inSphere);\n        vec3 norm = inSphere/len;\n        float R = 0.01+(rnd.x*rnd.y)*0.1;\n        float dist = len-R;\n        \n        // found the closest sphere, update distance and normal\n        if (dist < d) {\n            d = dist;\n            normal = norm;\n        }\n        \n        // figure out how much light there is inside the radius\n        float area = R*R*R;\n    \tfloat maxArea = r*r*r;\n        float scale = smoothstep(r, -r, dist)*area/max(area, maxArea);\n        \n        // add lights\n        vec3 lightColor = hue(rnd.z*0.2 + phase);\n        color += scale*lightColor*100.0;\n    }\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 rnd = hash33(vec3(fragCoord, iFrame));\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));\n    vec3 up = cross(right, forward);\n    vec3 dir = normalize(forward/tan(FOV*0.5)+right*uv.x+up*uv.y);\n    vec3 from = forward*iTime*4.0;\n    \n    float focal = 4.0;\n    float sinPix = sin(FOV / iResolution.y);\n    vec4 acc = vec4(0, 0, 0, 1);\n    vec3 dummy = vec3(0);\n    float totdist = de(from, 0.0, dummy, dummy)*rnd.x;\n    \n    for (int i = 0 ; i < 50 ; i++) {\n\t\tvec3 p = from + totdist * dir;\n        float r = max(totdist*sinPix, abs((totdist-focal)*0.03));\n        vec3 color = vec3(0);\n        vec3 normal = vec3(0);\n        float dist = de(p, r, color, normal);\n        \n        // apply fog to the given color\n        float fog = 1.0-exp(-totdist * 0.15);\n        color = mix(color, vec3(0), fog);\n        \n        // find out the orientation of the light source with the aperture\n        float theta = atan(dot(normal, right), dot(normal, up));\n        // change the shape of the cone tracing radius according to that\n        float R = r * (cos(theta*6.0)*0.2+0.8);\n        \n        // cone trace the surface\n\t\tfloat alpha = smoothstep(R, -R, dist);\n        acc.rgb += acc.a * (alpha*color.rgb);\n        acc.a *= (1.0 - alpha);\n        \n        // hit a surface, stop\n        if (acc.a < 0.01) break;\n        // continue forward\n        totdist += max(abs(dist), r*0.5);\n\t}\n    \n    fragColor.rgb = filmicToneMapping(acc.rgb);\n    fragColor.a = 1.0;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MddfW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 163, 190, 190, 314], [316, 354, 378, 378, 439], [441, 499, 535, 535, 653], [655, 717, 785, 785, 1842], [1844, 1844, 1901, 1901, 3446]], "test": "error"}
{"id": "Mddfzr", "name": "2.5D Water", "author": "Rafbeam", "description": "Very simple 2D water. Fixed those weird waves... + Added 3D effect to reflection.", "tags": ["2d", "reflection", "simple", "pixel", "water", "waving", "over"], "likes": 7, "viewed": 345, "published": "Public", "date": "1523982714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 drawWater(vec4 water_color, sampler2D color, float transparency, float height, float angle, float wave_strength, float wave_ratio, vec2 uv);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float WATER_HEIGHT = 0.2;\n    vec4 WATER_COLOR = vec4(0.5, 0.5, 0.53, 1.0);\n    float WAVE_STRENGTH = 3.0;\n    float WAVE_FREQUENCY = 8.0;\n    float WATER_TRANSPARENCY = 0.4;\n    float WATER_ANGLE = 2.0;\n    \n    fragColor = drawWater(WATER_COLOR, iChannel0, WATER_TRANSPARENCY, WATER_HEIGHT, WATER_ANGLE, WAVE_STRENGTH, WAVE_FREQUENCY, uv);\n}\n\nvec4 drawWater(vec4 water_color, sampler2D color, float transparency, float height, float angle, float wave_strength, float wave_frequency, vec2 uv)\n{\n    angle *= uv.y/height+angle/1.5; //3D effect\n    wave_strength /= 1000.0;\n    float wave = sin(10.0*uv.y+10.0*uv.x+wave_frequency*iTime)*wave_strength;\n    wave += sin(20.0*-uv.y+20.0*uv.x+wave_frequency*1.0*iTime)*wave_strength*0.5;\n    wave += sin(15.0*-uv.y+15.0*-uv.x+wave_frequency*0.6*iTime)*wave_strength*1.3;\n    wave += sin(3.0*-uv.y+3.0*-uv.x+wave_frequency*0.3*iTime)*wave_strength*10.0;\n    \n    if(uv.y - wave <= height)\n        return mix(\n        mix(\n            texture(color, vec2(uv.x, ((1.0 + angle)*(height + wave) - angle*uv.y + wave))),\n            water_color,\n            0.6-(0.3-(0.3*uv.y/height))),\n        texture(color, vec2(uv.x + wave, uv.y - wave)),\n        transparency-(transparency*uv.y/height));\n    else\n        return texture(color, vec2(uv.x, uv.y));\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mddfzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 202, 202, 597], [599, 599, 749, 749, 1545]], "test": "error"}
{"id": "MdGcDc", "name": "VoxelRayCaster", "author": "menackni", "description": ".", "tags": ["voxel"], "likes": 8, "viewed": 563, "published": "Public API", "date": "1523539442", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//perlin noise from here https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//rayCast from here https://www.shadertoy.com/view/4tlfDn\n\nfloat rayMaxDis(){return 84.0;}\nfloat noisePower(){return 184.0;}\n\nfloat seed=42.0;\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(.0, .0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(.0, .0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0);\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0;\n  vec4 gy = abs(gx) - .5;\n  vec4 tx = floor(gx + .5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159-.85373472095314 * \n  vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xyx).xy;\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P);\n  vec3 Pi1 = mod(Pi0+1.0, seed);\n       Pi0 = mod(Pi0, seed);\n  vec3 Pf0 = fract(P);\n  vec3 Pf1 = Pf0-1.0;\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - .5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(.0, gx0) - .5);\n  gy0 -= sz0 * (step(.0, gy0) - .5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - .5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(.0));\n  gx1 -= sz1 * (step(.0, gx1) - .5);\n  gy1 -= sz1 * (step(.0, gy1) - .5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = inversesqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = inversesqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nvec4 map(in vec3 p){\n    float n=cnoise(vec2(p.x/87.0,p.z/87.0));\n\tfloat nn=0.0;\n\tnn=n*(n*2.0*noisePower());\n\tfloat minus=60.0;\n\tif((p.y*4.0)-minus>nn){\n\t    vec4(0.0,0.0,0.0,0.0);\n\t    if((p.y)<=17.0){\n\t\t    float m=0.0;\n            m=cnoise(vec2((p.x+(0.9*iTime*5.0))/3.0,p.z/3.0));\n            return vec4(mix(0.4,m/2.0,0.4),mix(0.7,m,0.1),1.0,1.0);\n\t    }\n\t}else if((p.y)<=18.0){\n\t\tif(((p.y+4.0)*4.0)-minus>nn){\n            float m=cnoise(vec2(p.x/3.0,p.z/3.0));\n            return vec4(mix(1.0,m,0.1),mix(1.0,m,0.1),mix(0.6,m,0.1),1.0);\n\t\t}else{\n            float m=cnoise(vec2((p.x+100.0)/3.0,p.z/3.0));\n            return vec4(mix(0.5,m,0.1),mix(0.5,m,0.1),mix(0.5,m,0.1),1.0);\n\t\t}\n\t}else{\n\t    if(((p.y+1.0)*4.0)-minus>nn){\n            float m=cnoise(vec2(p.x/7.0,p.z/7.0));\n            return vec4(mix(0.1,m,0.1),mix(0.7,m,0.1),mix(0.2,m,0.1),1.0);\n\t\t}else \n\t\tif(((p.y+4.0)*4.0)-minus>nn){\n            float m=cnoise(vec2(p.x/3.0,p.z/3.0));\n            return vec4(mix(0.7,m,0.1),mix(0.6,m,0.1),mix(0.1,m,0.1),1.0);\n\t\t}else{\n            float m=cnoise(vec2((p.x-100.0)/3.0,p.z/3.0));\n            return vec4(mix(0.5,m,0.1),mix(0.5,m,0.1),mix(0.5,m,0.1),1.0);\n\t\t}\n\t}\n    return vec4(0.0,0.0,0.0,0.0);\n}\n\nvec4 clouds(in vec3 eye,in vec3 ray) {\n    if(ray.y<.0){\n        return vec4(0,0,1,1);\n    }\n    vec3 pos = floor(eye);\n    vec3 ri = 1.0 / ray;\n    vec3 rs = sign(ray);\n    vec3 ris = ri * rs;\n    vec3 dis = (pos - eye + 0.5 + rs * 0.5) * ri;\n    vec3 dim = vec3(.0);\n    float accamulate=.0;\n    \n    \n    for(int i=0;i<8;i++){\n        if(length(eye-pos)>8.0){\n            break;\n        }\n        if(accamulate>=1.0){\n           break;\n        }\n        \n        float nois=cnoise(vec3(pos.x+(iTime),pos.y,pos.z)/32.0);\n        accamulate+=nois/2.0;\n        \n        nois=cnoise(vec3(pos.x+(iTime),pos.y,pos.z)/4.0);\n        accamulate+=nois/4.0;\n        \n        dim = step(dis, dis.yzx);\n\t\tdim *= (1.0 - dim.zxy);\n        \n        dis += dim * ris;\n        pos += floor(dim * rs);\n    }\n\n\treturn vec4(mix(0.0,accamulate,ray.y),mix(0.0,accamulate,ray.y),1.0,1.0);\n}\n\nvec4 castRay(in vec3 eye,in vec3 ray,in float mDis) {\n    vec3 pos = floor(eye);\n    vec3 ri = 1.0 / ray;\n    vec3 rs = sign(ray);\n    vec3 ris = ri * rs;\n    vec3 dis = (pos - eye + 0.5 + rs * 0.5) * ri;\n    \n    vec3 dim = vec3(0.0);\n    for (float i = 0.0; i < mDis*2.0; ++i) {\n        if(length(eye-pos)>mDis){\n            break;\n        }\n        if(map(pos).w>0.0){\n            return map(pos);\n        }\n    \n        dim = step(dis, dis.yzx);\n\t\tdim *= (1.0 - dim.zxy);\n        dis += dim * ris;\n        pos += dim * rs;\n    }\n\n\treturn clouds(pos,ray);\n}\n\nmat2 rot2(float a){\n    return mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 r1=vec3(uv.x,uv.y,1.0);\n    vec3 r=r1;\n         r.yz*=rot2(sin(iTime*0.35)/4.0);\n         r.xz*=rot2(sin(iTime*0.35)/8.0);\n    \n    vec3 o=vec3(sin(iTime*1.0)/2.0,0,iTime*8.0);\n    \n    float n=cnoise(vec2(o.x/87.0,o.z/87.0));\n    float nn=n*(n*1.0*noisePower());               \n    o=vec3(o.x,20.0+nn,o.z);\n    \n    fragColor=castRay(o, r, rayMaxDis());\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdGcDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 168, 168, 181], [182, 182, 201, 201, 215], [234, 234, 255, 255, 292], [293, 293, 312, 312, 348], [350, 350, 371, 371, 1376], [1379, 1379, 1400, 1400, 3518], [3520, 3520, 3540, 3540, 4730], [4732, 4732, 4770, 4770, 5601], [5603, 5603, 5656, 5656, 6163], [6165, 6165, 6184, 6184, 6233], [6235, 6235, 6292, 6292, 6734]], "test": "ok"}
{"id": "MdGcDG", "name": "strangeterrain", "author": "nezza", "description": "minified, but based on http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/ added terrain functions etc, just took phong + raymarching code", "tags": ["terraintest"], "likes": 2, "viewed": 139, "published": "Public", "date": "1523117366", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int m=255;const float v=0.,f=100.,e=.01;float n(float v,float f){return max(v,f);}float s(float v,float f){return min(v,f);}float x(float v,float e){return max(v,-e);}float n(vec3 v){vec3 f=abs(v)-vec3(1.,1.,1.);float m=min(max(f.r,max(f.g,f.b)),0.),e=length(max(f,0.));return m+e;}float n(vec3 v,vec3 e,float m){return length(v-e)-m;}float s(vec3 v){return length(v)-1.;}float x(vec3 v){float m=sin(iTime+v.b)*sin(iTime+v.r)*.5;m*=texture(iChannel0,v.rb*.08).r;return v.g-m;}float i(vec3 v){float f=n(v/1.2,vec3(4.*sin(iTime),1.,4.*cos(iTime)),.3);return min(x(v),f);}float i(vec3 v,vec3 f,float n,float b){float r=n;for(int l=0;l<m;l++){float t=i(v+r*f);if(t<e)return r;r+=t;if(r>=b)return b;}return b;}vec3 i(float v,vec2 m,vec2 e){vec2 f=e-m/2.;float b=m.g/tan(radians(v)/2.);return normalize(vec3(f,-b));}vec3 t(vec3 v){return normalize(vec3(i(vec3(v.r+e,v.g,v.b))-i(vec3(v.r-e,v.g,v.b)),i(vec3(v.r,v.g+e,v.b))-i(vec3(v.r,v.g-e,v.b)),i(vec3(v.r,v.g,v.b+e))-i(vec3(v.r,v.g,v.b-e))));}vec3 i(vec3 v,vec3 m,float f,vec3 e,vec3 i,vec3 r,vec3 b){vec3 n=t(e),g=normalize(r-e),l=normalize(i-e),c=normalize(reflect(-g,n));float s=dot(g,n),o=dot(c,l);if(s<0.)return vec3(0.,0.,0.);if(o<0.)return b*(v*s);return b*(v*s+m*pow(o,f));}vec3 i(vec3 v,vec3 f,vec3 m,float e,vec3 r,vec3 b){const vec3 n=.5*vec3(1.,1.,1.);vec3 l=n*v,g=vec3(4.*sin(iTime),1.,4.*cos(iTime)),s=vec3(.4,.4,.4);l+=i(f,m,e,r,b,g,s);vec3 t=vec3(2.*sin(.37*iTime),2.*cos(.37*iTime),2.),c=vec3(.4,.4,.4);l+=i(f,m,e,r,b,t,c);return l;}mat4 s(vec3 v,vec3 f,vec3 e){vec3 m=normalize(f-v),r=normalize(cross(m,e)),i=cross(r,m);return mat4(vec4(r,0.),vec4(i,0.),vec4(-m,0.),vec4(0.,0.,0.,1));}void mainImage(out vec4 r,in vec2 b){vec3 m=i(45.,iResolution.rg,b),g=vec3(8.,5.,7.);mat4 n=s(g,vec3(0.,0.,0.),vec3(0.,1.,0.));vec3 l=(n*vec4(m,0.)).rgb;float t=i(g,l,v,f);if(t>f-e){r=vec4(0.,0.,0.,0.);return;}vec3 c=g+t*l,o=vec3(.2,.2,.2),x=vec3(.2,0.,1.),a=vec3(1.,0.,0.);float u=10.;vec3 T=i(o,x,a,u,c,g);r=vec4(T,1.);}\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdGcDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 71, 71, 88], [88, 88, 113, 113, 130], [130, 130, 155, 155, 173], [173, 173, 189, 189, 288], [288, 288, 319, 319, 341], [341, 341, 357, 357, 378], [378, 378, 394, 394, 482], [482, 482, 498, 498, 575], [575, 575, 614, 614, 711], [711, 711, 741, 741, 816], [816, 816, 831, 831, 994], [994, 994, 1052, 1052, 1233], [1233, 1233, 1284, 1284, 1501], [1501, 1501, 1530, 1530, 1654], [1654, 1654, 1691, 1691, 1976]], "test": "error"}
{"id": "MdGczK", "name": "Doodling #6: eh!", "author": "lsdlive", "description": "Stuff I did at the Revision 2018 demoparty.\n\nVarious utilities code from iq, lj, mercury, shane, aiekick & balkhan.", "tags": ["raymarch", "demoparty"], "likes": 10, "viewed": 301, "published": "Public", "date": "1522594070", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// @lsdlive\n\n\nfloat sc(vec3 p, float d){p=abs(p);p=max(p,p.yzx);return min(p.x,min(p.y,p.z))-d;}\nmat2 r2d(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\nfloat re(float p,float d){return mod(p-d*.5,d)-d*.5;}\nvoid amod(inout vec2 p, float m){float a=re(atan(p.x,p.y),m);p=vec2(cos(a),sin(a))*length(p);}\nvoid mo(inout vec2 p, vec2 d){p.x=abs(p.x)-d.x;p.y=abs(p.y)-d.y;if(p.y>p.x)p=p.yx;}\n\n\nfloat scc(vec3 p, float d){\n    float c1 = length(p.xy) - d;\n    float c2 = length(p.xz) - d;\n    float c3 = length(p.zy) - d;\n    return min(c1,min(c2,c3));\n}\n\nfloat g=0.;\nfloat de(vec3 p){\n    //p.y-=1.;\n    p.xy*=r2d(iTime*.3);    \n    \n  p.xy*=r2d(p.z*.3);  \n    \n    p.z=re(p.z,9.);\n    \n    amod(p.xy, 6.28/4.);\n    mo(p.xy, vec2(2., .3));\n    amod(p.xy, 6.28/8.3);\n    mo(p.zy, vec2(1., .3));\n       \n    p.x=abs(p.x)-3.;\n    \n    p.y=abs(p.y)-2.;\n    p.xy*=r2d(.5);\n    \n    float d = sc (p,.5);\n    \n    p.xy*=r2d(iTime*.3);\n    d = min(d, -scc(p,1.));\n    g+=.01/(.01+d*d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy -.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 ro=vec3(0,0,-3.+iTime);\n    vec3 rd=normalize(vec3(uv,1));\n    \n    vec3 p;\n    float t=0.;\n    float ri;\n    for(float i=0.;i<1.;i+=.01){\n        ri=i;\n    \tp=ro+rd*t;\n        float d=de(p);\n        //if(d<.001)break;\n        d=max(abs(d), .005);\n        t+=d*.3;\n    }\n    \n    vec3 bg= vec3(.2, .1, .2);\n\tvec3 c=mix(vec3(.7, .1, .1), bg, uv.x*4.3+ri);\n    c.g+=sin(iTime);\n    c+=g*.02;\n    c=mix(c, bg,1.-exp(-.01*t*t));\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdGczK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 40, 40, 96], [97, 97, 115, 115, 162], [163, 163, 189, 189, 216], [217, 217, 250, 250, 311], [312, 312, 342, 342, 395], [398, 398, 425, 425, 557], [571, 571, 588, 603, 997], [999, 999, 1056, 1056, 1609]], "test": "ok"}
{"id": "MdGyDc", "name": "dancing balls v1", "author": "indominator", "description": "this is a shader of moving balls. comments in portuguese because of how lazy i am :/\n\nmade during class because it was boring", "tags": ["sphere", "ball", "points"], "likes": 0, "viewed": 336, "published": "Public API", "date": "1523540634", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//pontos estaticos na tela para as bolas se mexherem atraves\n//converter a vec3\nconst vec2 \n    pos1 = vec2(0.,0.),pos2 = vec2(1.,1.), \n    pos3 = vec2(0.2,0.2), \n    pos4 = vec2(0.54,0.73),pos5 = vec2(0.23,0.4);\n\n\n//array de corres\nconst vec3 \n    cor1 = vec3(0.,0.,1.),cor2 = vec3(1.,1.,1.), \n    cor3 = vec3(0.,0.,1.), \n    cor4 = vec3(1.,1.,1.),cor5 = vec3(0.,0.,1.);\n\n//origem da luz \nconst vec3 light_origin = vec3(0.2,0.3,1.);\nconst vec3 light_color = vec3(1.,1.,1.);\n\n//posicao pontos\n//converter a vec3\nvec2 \n    p1,p2,\n    p3,\n    p4,p5;\n\n//tamanho dos circulos\nfloat s1 = 10.,s2 = 10.,s3 = 10.,s4 = 10.,s5 = 10.;\n\n\n\n//////////// POSICAO PONTOS\nvec2 lerp_pos(  float t){ \n    //REFAZRE POS PONTOS\n    vec2 p1,p2;\nint p = int(mod((t - mod(t,1.)),5.));\n    switch (p){\n     case 0:\n        p1 = pos1;\n                p2 = pos2;\n        break;\n             case 1:\n        p1 = pos2;\n                p2 = pos3;\n\n        break;\n             case 2:\n        p1 = pos3;\n                p2 = pos4;\n\n        break;\n             case 3:\n        p1 = pos4;\n                p2 = pos5;\n\n        break;\n             case 4:\n        p1 = pos5;\n                p2 = pos1;\n\n        break;\n    }\n    return p1*mod(t,1.) + p2*(1. - mod(t,1.));\n\n}\n\nvoid set_pontos(){\n    //t set\n    \n    p1 = lerp_pos(0.3 + iTime);\n    p2 = lerp_pos(0.4 + iTime);\n    p3 = lerp_pos(0.5 + iTime);\n    p4 = lerp_pos(0.6 + iTime);\n    p5 = lerp_pos(0.7 + iTime);\n}\n\n///////////////\n//CORES E LUYZ\n///////////\nvec3 sphere_color(float size, vec2 ponto, vec2 center,vec3 cor){\n    \n    \n    if(size - length(center - ponto) <0.)return vec3(0.,0.,0.);\n    \n    //get z for lightning\n    float z =sqrt( pow(size,2.) - pow(ponto.x - center.x,2.) - pow(center.y - ponto.y,2.));\n    vec3 normal = normalize(vec3(ponto - center,z));\n    \n    float cosTheta = clamp( dot( normal,   light_origin   - vec3(center/iResolution.xy,0.) ), 0.3,1.0);\n    \n    //cor mais luz\n    cor = cor*cosTheta \n        // a luz forte\n        + light_color.rgb * pow( length( light_origin - vec3(center/iResolution.xy,0.) - normal )/2., 8.0);\n    \n    return cor;\n}\nvec4 cores(vec2 ponto,  vec2 iRes){\n    vec3 cor = vec3(0.,0.,0.);\n    cor += sphere_color(s1,ponto,p1*iRes,cor1);\n    cor +=sphere_color(s2,ponto,p2*iRes,cor2);\n    cor +=sphere_color(s3,ponto,p3*iRes,cor3);\n    cor +=sphere_color(s4,ponto,p4*iRes,cor4);\n    cor +=sphere_color(s5,ponto,p5*iRes,cor5);\n    return vec4(cor.xyz,1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    set_pontos();\n    \n    fragColor = cores(fragCoord,iResolution.xy);\n}\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdGyDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[627, 655, 680, 706, 1238], [1240, 1240, 1258, 1270, 1437], [1439, 1482, 1546, 1546, 2107], [2108, 2108, 2143, 2143, 2441], [2444, 2444, 2501, 2501, 2575]], "test": "ok"}
{"id": "MdGyWd", "name": "1981 SEGA TURBO demo", "author": "yasuo", "description": "Idea is from previous experiment comments. I just tried to make look like \"SEGA TURBO\" game.", "tags": ["demo", "raytrace", "oldgame"], "likes": 3, "viewed": 440, "published": "Public API", "date": "1523712513", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPEED 5.0\nfloat c_0 = 31599.0;\nfloat c_1 = 9362.0;\nfloat c_2 = 29671.0;\nfloat c_3 = 29391.0;\nfloat c_4 = 23497.0;\nfloat c_5 = 31183.0;\nfloat c_6 = 31215.0;\nfloat c_7 = 29257.0;\nfloat c_8 = 31727.0;\nfloat c_9 = 31695.0;\n\n// this code is from GLSL sandbox\n//returns 0/1 based on the state of the given bit in the given number\nfloat getBit(float num,float bit)\n{\n    num = floor(num);\n    bit = floor(bit);\n\n    return float(mod(floor(num/pow(2.,bit)),2.) == 1.0);\n}\n\nfloat Sprite3x5(float sprite,vec2 p)\n{\n    float bounds = float(all(lessThan(p,vec2(3,5))) && all(greaterThanEqual(p,vec2(0,0))));\n\n    return getBit(sprite,(2.0 - p.x) + 3.0 * p.y) * bounds;\n}\n\nfloat Digit(float num,vec2 p)\n{\n    num = mod(floor(num),10.0);\n\n    if(num == 0.0) return Sprite3x5(c_0,p);\n    if(num == 1.0) return Sprite3x5(c_1,p);\n    if(num == 2.0) return Sprite3x5(c_2,p);\n    if(num == 3.0) return Sprite3x5(c_3,p);\n    if(num == 4.0) return Sprite3x5(c_4,p);\n    if(num == 5.0) return Sprite3x5(c_5,p);\n    if(num == 6.0) return Sprite3x5(c_6,p);\n    if(num == 7.0) return Sprite3x5(c_7,p);\n    if(num == 8.0) return Sprite3x5(c_8,p);\n    if(num == 9.0) return Sprite3x5(c_9,p);\n\n    return 0.0;\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) return val1;\n    return val2;\n}\n\n\nfloat dBox2d(vec2 p, vec2 b) {\n\treturn max(abs(p.x) - b.x, abs(p.y) - b.y);\n}\n\nvec4 drawGuage(vec2 p) {\n\tp *= 6.0;\n\t\n    float startX = 3.5;\n    float ypos = -5.0;\n    vec2 size = vec2(0.3,0.6);\n    float padX = 0.8;\n \n    vec3 cb0 = vec3(1.0,0.0,0.0);\n    vec3 cb1 = vec3(1.0,0.0,0.0);\n    vec3 cb2 = vec3(1.0,0.0,0.0);\n    vec3 cb3 = vec3(1.0,0.0,0.0);\n    vec3 cb4 = vec3(1.0,0.0,0.0);\n    vec3 cb5 = vec3(1.0,0.0,0.0);\n    vec3 cb6 = vec3(1.0,0.0,0.0);\n    vec3 cb7 = vec3(1.0,0.0,0.0);\n    vec3 cb8 = vec3(1.0,0.0,0.0);\n    vec3 cb9 = vec3(1.0,0.0,0.0);\n    \n    float t = mod(iTime,10.0);\n    if(t<1.0){\n        cb0 = vec3(0.0,1.0,0.0);\n    } else if(t>=1.0 && t<2.0){\n        cb0 = vec3(0.0,1.0,0.0);\n    \tcb1 = vec3(0.0,1.0,0.0);\n\t} else if(t>=2.0 && t<3.0){\n        cb0 = vec3(0.0,1.0,0.0);\n    \tcb1 = vec3(0.0,1.0,0.0);\n        cb2 = vec3(0.0,1.0,0.0);\n\t} else if(t>=3.0 && t<4.0){\n        cb0 = vec3(0.0,1.0,0.0);\n    \tcb1 = vec3(0.0,1.0,0.0);\n        cb2 = vec3(0.0,1.0,0.0);\n        cb3 = vec3(0.0,1.0,0.0);\n\t} else if(t>=4.0 && t<5.0){\n\t\tcb0 = vec3(0.0,1.0,0.0);\n    \tcb1 = vec3(0.0,1.0,0.0);\n        cb2 = vec3(0.0,1.0,0.0);\n        cb3 = vec3(0.0,1.0,0.0);\n    \tcb4 = vec3(0.0,1.0,0.0);\n\t} else if(t>=5.0 && t<6.0){\n\t\tcb0 = vec3(0.0,1.0,0.0);\n    \tcb1 = vec3(0.0,1.0,0.0);\n        cb2 = vec3(0.0,1.0,0.0);\n        cb3 = vec3(0.0,1.0,0.0);\n    \tcb4 = vec3(0.0,1.0,0.0);\n    \tcb5 = vec3(0.0,1.0,0.0);\n\t} else if(t>=6.0 && t<7.0){\n\t\tcb0 = vec3(0.0,1.0,0.0);\n    \tcb1 = vec3(0.0,1.0,0.0);\n        cb2 = vec3(0.0,1.0,0.0);\n        cb3 = vec3(0.0,1.0,0.0);\n    \tcb4 = vec3(0.0,1.0,0.0);\n    \tcb5 = vec3(0.0,1.0,0.0);\n    \tcb6 = vec3(0.0,1.0,0.0);\n\t} else if(t>=7.0 && t<8.0){\n\t\tcb0 = vec3(0.0,1.0,0.0);\n    \tcb1 = vec3(0.0,1.0,0.0);\n        cb2 = vec3(0.0,1.0,0.0);\n        cb3 = vec3(0.0,1.0,0.0);\n    \tcb4 = vec3(0.0,1.0,0.0);\n    \tcb5 = vec3(0.0,1.0,0.0);\n    \tcb6 = vec3(0.0,1.0,0.0);\n    \tcb7 = vec3(0.0,1.0,0.0);\n\t} else if(t>=8.0 && t<9.0){\n\t\tcb0 = vec3(0.0,1.0,0.0);\n    \tcb1 = vec3(0.0,1.0,0.0);\n        cb2 = vec3(0.0,1.0,0.0);\n        cb3 = vec3(0.0,1.0,0.0);\n    \tcb4 = vec3(0.0,1.0,0.0);\n    \tcb5 = vec3(0.0,1.0,0.0);\n    \tcb6 = vec3(0.0,1.0,0.0);\n    \tcb7 = vec3(0.0,1.0,0.0);\n    \tcb8 = vec3(0.0,1.0,0.0);\n\t} else if(t>=9.0 && t<10.0){\n\t\tcb0 = vec3(0.0,1.0,0.0);\n    \tcb1 = vec3(0.0,1.0,0.0);\n        cb2 = vec3(0.0,1.0,0.0);\n        cb3 = vec3(0.0,1.0,0.0);\n    \tcb4 = vec3(0.0,1.0,0.0);\n    \tcb5 = vec3(0.0,1.0,0.0);\n    \tcb6 = vec3(0.0,1.0,0.0);\n    \tcb7 = vec3(0.0,1.0,0.0);\n    \tcb8 = vec3(0.0,1.0,0.0);\n        cb9 = vec3(0.0,1.0,0.0);\n    }\n    \n\tvec4 b0 = vec4(cb0, dBox2d(p+vec2(startX,ypos),size));\n\tvec4 b1 = vec4(cb1, dBox2d(p+vec2(startX-padX,ypos),size));\n\tvec4 b2 = vec4(cb2, dBox2d(p+vec2(startX-(padX*2.0),ypos),size));\n\tvec4 b3 = vec4(cb3, dBox2d(p+vec2(startX-(padX*3.0),ypos),size));\n\tvec4 b4 = vec4(cb4, dBox2d(p+vec2(startX-(padX*4.0),ypos),size));\n\tvec4 b5 = vec4(cb5, dBox2d(p+vec2(startX-(padX*5.0),ypos),size));\n\tvec4 b6 = vec4(cb6, dBox2d(p+vec2(startX-(padX*6.0),ypos),size));\n\tvec4 b7 = vec4(cb7, dBox2d(p+vec2(startX-(padX*7.0),ypos),size));\n    vec4 b8 = vec4(cb8, dBox2d(p+vec2(startX-(padX*8.0),ypos),size));\n    vec4 b9 = vec4(cb9, dBox2d(p+vec2(startX-(padX*9.0),ypos),size));\n\t\n\tvec4 res1 = combine(b0, b1);\n\tvec4 res2 = combine(b2, b3);\n\tvec4 res3= combine(b4, b5);\n\tvec4 res4= combine(b6, b7);\n    vec4 res5= combine(b8, b9);\n\tvec4 res6 = combine(res1, res2);\n\tvec4 res7 = combine(res3, res4);\n\tvec4 res8 = combine(res5, res6);\n    vec4 res9 = combine(res7, res8);\n\t\n\treturn res9;\n}\n\nfloat box(vec2 st, float size)\n{\n    size = 0.5 + size * 0.5;\n    st = step(st, vec2(size)) * step(vec2(1.0 - st.x,1.0 - st.y),  vec2(size));\n    return st.x * st.y;\n}\n\nvec3 buildingTex(vec2 uv)\n{\n    float n = 10.0;\n    vec2 st = fract(uv * n);\n    return vec3(box(st, 0.5));\n}\n\nfloat noise(float x) {\n    return fract(sin(dot(vec2(x), vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// Tunnel pattern studied from shane & shau\n// i.e. https://www.shadertoy.com/view/4tKXzV\nvec2 path(float t) {\n    float a = sin(t*.2 + 1.5), b = sin(t*.2);\n    return vec2(a*2., a*b);\n}\n\nvec3 camera(vec3 ro, vec2 uv, vec3 ta) {\n    vec3 fwd = normalize(ta - ro);\n    vec3 left = cross(vec3(0, 1, 0), fwd);\n    vec3 up = cross(fwd, left);\n    return normalize(fwd + uv.x*left + up*uv.y);\n}\n\nfloat sdSphere (vec3 p, float r) {\n    return length(p)-r; \n}\n\nvec4 map(vec3 p, vec3 p2) {\n    vec3 lTex = buildingTex(p.xy);\n    \n    p.xy -= path(p.z)*0.1;\n    float t = 100.0;\n    float w = 0.0;\n\n    float n = floor(p.z/0.5);\n\n    vec3 oldp = p;\n    p.z = mod(p.z, 1.0)-0.5;\n\n    w = sdBox(p-vec3(0.4,-1.2,0.0),vec3(0.02, 0.01, 0.3));\n    t = min(t, w);\n\n    w = 0.1 + dot(oldp, vec3(0, 0.0, 0.0));\n    t = min(t, w);\n\n\n    vec4 temp1 = vec4(0.0,0.0,0.0, t);\n    vec4 temp2 = vec4(0.0,0.0,0.0, sdBox(p-vec3(-0.4,-1.2,0.0),vec3(0.02, 0.01, 0.3)));\n    vec4 temp3 = vec4(0.8,0.8,0.1, sdBox(p-vec3(0.0,-1.21,0.0),vec3(0.4, 0.01, 1.0)));\n    \n    p.y += noise(n)*1.0+sin(2.0)*0.1;\n    p.x += noise(n)*0.3-0.15;\n    \n   \n    vec4 temp4 = vec4(lTex, sdBox(p+vec3(0.8,0.0,0.0),vec3(0.2, 1.0, 0.3)));\n    vec4 temp5 = vec4(lTex, sdBox(p+vec3(-0.8,0.0,0.0),vec3(0.2, 1.0, 0.3)));\n    \n    vec4 carbody = vec4(0.8,0.4,0.4, sdBox(p2-vec3(0.0,-1.0,0.8),vec3(0.05, 0.05, 0.1)));\n    vec4 frontTire = vec4(0.2,0.1,0.1, sdBox(p2-vec3(0.0,-1.0,0.88),vec3(0.08, 0.03, 0.01)));\n    vec4 backTire = vec4(0.2,0.1,0.1, sdBox(p2-vec3(0.0,-1.0,0.72),vec3(0.08, 0.03, 0.01)));\n    \n    float xCarPos = sin(iTime)*0.12;\n    float zCarPos = 0.6;\n    vec4 carbody2 = vec4(0.4,0.4,0.8, sdBox(p2-vec3(xCarPos,-1.0,0.8+zCarPos),vec3(0.05, 0.05, 0.1)));\n    vec4 frontTire2 = vec4(0.1,0.1,0.2, sdBox(p2-vec3(xCarPos,-1.0,0.88+zCarPos),vec3(0.08, 0.03, 0.01)));\n    vec4 backTire2 = vec4(0.1,0.1,0.2, sdBox(p2-vec3(xCarPos,-1.0,0.72+zCarPos),vec3(0.08, 0.03, 0.01)));\n    \n    \n    vec4 res1 = combine(temp1,temp2);\n    vec4 res2 = combine(temp3,temp4);\n    vec4 res3 = combine(temp5,carbody);\n    vec4 res4 = combine(frontTire,backTire);\n    vec4 res5 = combine(carbody2,frontTire2);\n    vec4 res6 = combine(backTire2,res1);\n    \n    vec4 res7 = combine(res2,res3);\n    vec4 res8 = combine(res4,res5);\n    vec4 res9 = combine(res6,res7);\n    vec4 res10 = combine(res8,res9);\n    \n    return res10;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = ( fragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n    vec3  dir;\n\n    vec3 pos = vec3(0.0, 0.0, iTime*SPEED);\n\n    float dt = iTime * 6.;\n    vec3 ro = vec3(0, 0, -4. + dt);\n    vec3 ta = vec3(0, -2, dt);\n    vec3 rd;\n\n    ro.xy += path(ro.z);\n    ta.xy += path(ta.z);\n\n    dir = camera(ro, uv, ta);\n\n    float t = 0.0;\n    vec3 modelCl;\n    for(int i = 0 ; i < 50; i++) {\n        vec4 temp = map(t * dir + pos, t * dir);\n        modelCl = temp.xyz;\n        if(temp.w < 0.01) break;\n        t += temp.w * 1.0;\n    }\n\n    vec3 ip = pos + dir * t;\n    vec4 cl = vec4(t * 0.01) * map(ip - 0.02, ip - 0.02) + t * 0.3;\n\n    // UI\n    uv = ( fragCoord.xy /iResolution.xy ) * vec2(80,40);\n    \n    vec2 cpos = vec2(37,28);\n    float dc = Digit(mod(iTime,60.0),floor(uv-cpos));\n    cpos.x += 3.5;\n    dc += Digit(mod(iTime*10.0,10.0),floor(uv-cpos));\n\n    vec3 cl2 = vec3(dc)*vec3(1,1,1);\n    \n    uv = ( fragCoord.xy * 2.0 - iResolution.xy ) / min( iResolution.x, iResolution.y );\n    vec4 res = drawGuage(uv);\n\tvec3 resColor = res.xyz;\n\n    if(res.w>0.0){\n        fragColor = (cl+vec4(modelCl,1.0))-vec4(cl2,1.0);\n    } else {\n        fragColor = vec4( vec3(resColor), 1.0 );\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdGyWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[228, 332, 367, 367, 471], [473, 473, 511, 511, 666], [668, 668, 699, 699, 1191], [1193, 1193, 1229, 1229, 1288], [1291, 1291, 1321, 1321, 1368], [1370, 1370, 1394, 1394, 4836], [4838, 4838, 4870, 4870, 5005], [5007, 5007, 5034, 5034, 5116], [5118, 5118, 5140, 5140, 5214], [5216, 5216, 5247, 5247, 5338], [5340, 5430, 5450, 5450, 5526], [5528, 5528, 5568, 5568, 5729], [5731, 5731, 5765, 5765, 5792], [5794, 5794, 5821, 5821, 7702], [7705, 7705, 7762, 7762, 8951]], "test": "ok"}
{"id": "MdKyDy", "name": "Surprise!", "author": "neurom", "description": "I made this for the wild compo revision 2018. You can drag the light around with the mouse.", "tags": ["raymarching", "space", "stars", "kindersurprise", "easteregg"], "likes": 3, "viewed": 453, "published": "Public API", "date": "1523279548", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\n#define PI acos(-1.0)\n#define TAU (2.*PI)\n\nvec3 v01 = vec3(0.0, 1.0, 0.1);\n\n// Taken from the book of shaders\nfloat random (vec2 st) {\n    return fract(sin(dot(st,vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nfloat random (float st) { return random(vec2(st)); }\n\nfloat frandom (vec2 st) {\n\tvec2 t = fract(st);\n\tvec2 a = floor(st);\n\tvec2 b =  ceil(st);\n\treturn mix(\n\t\tmix(random(vec2(a.x, a.y)), random(vec2(b.x, a.y)), t.x),\n\t\tmix(random(vec2(a.x, b.y)), random(vec2(b.x, b.y)), t.x),\n\t\tt.y); \n}\n\nfloat sat(float n) { return clamp(n, 0.0, 1.0); }\nvec3 sat(vec3 n) { return clamp(n, v01.xxx, v01.yyy); }\n\nvec2 rotate(inout vec2 p, float a) {\n\tp = p*cos(a) - vec2(p.y, -p.x)*sin(a);\n\treturn p;\n}\n\n\nvec4 egg = vec4(0, 0., 30., 8.);\n\nfloat sphere(vec3 point, vec3 p, float r) {\n\treturn distance(point, p) - r;\n}\n\nfloat vmax(vec3 v) { return max(max(v.x, v.y), v.z); }\nfloat box(vec3 point, vec3 p, vec3 r) {\n\treturn vmax(abs(point - p) - r);\n}\t\n\nfloat rod(vec2 point, vec2 c, float r) {\n\treturn distance(point, c) - r;\n}\n\n\nint mi = 0;\nfloat map(vec3 point) {\n\tvec3 op = point.xyz;\n\tpoint.y += 4.;\n\n\tvec3 p1 = point.xyz;\n\n\tif (p1.y > egg.y) {\n\t\tp1.y /=2.;\n\t}\n\n\tfloat result = sphere(p1, egg.xyz, egg.w);\n\n\tvec3 p2 = point.xyz;\n\tp2 -= egg.xyz;\n\trotate(p2.xz, time/2.);\n\trotate(p2.xy, -TAU/10.);\n\tp2 += egg.xyz;\n\n\n\n\tfloat d = -box(p2, egg.xyz + v01.yxx*10.15*(1.5 + 0.5*sin(time*1.)), vec3(8., 30, 10.));\n\t// d = max(d, -sphere(p1, egg.xyz, egg.w*0.93));\n\t\n\td = max(d, -sphere(p1, egg.xyz, egg.w*0.93));\n    if (d > result) { result = d; mi = 1; }\n\t\n\n\n\tp1 = op.xyz;\n\t\n\tp1.y = p1.y*p1.y/12.;\n\n\td = sphere(p1, egg.xyz, egg.w*.7);\n\td = min(d, max(box(p1, egg.xyz, vec3(10., .25, 10.)), rod(p1.xz, egg.xz, egg.w*.715)));\n\n    if (d < result) { result = d; mi = 2; }\n\n\treturn result;\n}\n\n\nvec3 hsv2rgb(float h, float s, float v) {\n\tvec3 p = sat(abs(fract(vec3(3.0, 2.0, 1.0)/3.0 + h)*6.0 - 3.0) - 1.0);\n\treturn v*mix(p, vec3(1.0), s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.x;\n\n\tvec3 camP = vec3(0), rayD = normalize(vec3(uv, 1.));\n\n\tfloat marched = 0.01, d, far = distance(egg.xyz, camP) + egg.w*2.;\n\tvec3 p;\n\n\tfor (int i = 0; i < 300; ++i) {\n\t\tp = camP + rayD*marched;\n\t\td = map(p);\n\t\tmarched += d;\n\n\t\tif (abs(d) < 0.001 || d > far) break;\n\t}\n\n\n\n\n\tfloat starT = random(uv)*time*2.;\n\tfloat value = 4.*mix(\n\t\tpow(random(uv + floor(starT)), 120.),\n\t\tpow(random(uv +  ceil(starT)), 120.),\n\t\tfract(starT));\n\n\tvalue *= (pow(frandom((uv * 7. + time/8.)) + 0.2, 4.));\n\tvec3 c = hsv2rgb(0.7133, 0.9, value);\n\n\n\tif (marched < far) {\n        vec3 normal = normalize(vec3(\n\t\t\tmap(p + v01.zxx),\n            map(p + v01.xzx),\n            map(p + v01.xxz)\n        ));\n        \n        vec2 m = (2.*iMouse.xy - iResolution.xy) / iResolution.x;\n\n        vec3 lightDir = normalize(vec3(2.*m, -1.));\n\n\n\t\tif (mi == 0) {\n\t\t\tc = vec3(1.0);\n\t\t\tif (p.y + sin(p.x*2. + time*10.) < -3.) {\n\t\t\t\tc.gb *= 0.;\n\t\t\t}\n\n\t\t\tvec3 egg2p = p - egg.xyz;\n\t\t\tfloat u = atan(egg2p.z, egg2p.x) + time/1.5;\n\t\t\tnormal = normalize(normal + 2.*normalize(egg2p)*frandom(vec2(u*79. + p.y*20., random(floor(u*10. + p.y*2.))*4. + u*5. + p.y*2.)));\n            \n\t\t\tc += pow(dot(rayD, reflect(lightDir, normal)) + 0.1, 13.)*.05;\n            \n\t\t\tc *= sat(dot(normal, lightDir));\n            \n\t\t} else if (mi == 1) {\n\t\t\tc = vec3(.3, .2, 0.13);\n\t\t\tc *= dot(normal, lightDir);\n\t\t\t\n\t\t} else if (mi == 2) {\n\t\t\tc = vec3(1., .8, 0.3);\n\t\t\tc += pow(dot(rayD, reflect(lightDir, normal)), 50.)*1.;\n\t\t\tc *= dot(normal, lightDir);\n\t\t\t\n\t\t} else {\n\t\t\tc += 0.5; // This is just so I can see which material indexes I missed\n\t\t}\n\n\t}\n\n\tfragColor = vec4(c, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdKyDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 130, 154, 154, 232], [233, 233, 258, 258, 285], [287, 287, 312, 312, 519], [521, 521, 541, 541, 570], [571, 571, 589, 589, 626], [628, 628, 664, 664, 717], [754, 754, 797, 797, 831], [833, 833, 853, 853, 887], [888, 888, 927, 927, 963], [966, 966, 1006, 1006, 1040], [1055, 1055, 1078, 1078, 1797], [1800, 1800, 1841, 1841, 1947], [1949, 1949, 2006, 2006, 3684]], "test": "ok"}
{"id": "MdKyWd", "name": "Hello world with Mandelbrot", "author": "darkeclipz", "description": "Mandelbrot set! First time programming with GLSL / shaders.", "tags": ["mandelbrot"], "likes": 0, "viewed": 120, "published": "Public", "date": "1523873039", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord/iResolution.y - vec2(1.15, .5);\n    vec2 c = 2.3*p; vec2 z = vec2(0); float i = 0., t; t = iTime;\n    float lim = 32.;\n    \n    for(; z.x*z.x < 12. && ++i < lim ;)\n        z = mat2(z, -z.y, z.x) * z + c;\n    \n    fragColor = vec4((.5 + .5*cos(t+p.xyx+vec3(0,2,4))) * i / lim, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdKyWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 363]], "test": "ok"}
{"id": "MdKyWy", "name": "Helical Frame", "author": "dr2", "description": "Hollow twisted helix (mouseable, optional antialiasing)", "tags": ["helix", "frame", "structure"], "likes": 5, "viewed": 397, "published": "Public API", "date": "1523268324", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Helical Frame\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing (0/1 - off/on)\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrBoxAn2Df (vec2 p, vec2 b, float w);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir;\nfloat tCur, dstFar;\nconst float pi = 3.14159;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d, a, aa, gz;\n  q = p;\n  aa = atan (q.z, q.x) / (2. * pi);\n  a = 0.5 * sign (q.z) - aa;\n  q.y = mod (q.y + 2. * a + 1., 2.) - 1.;\n  d = PrBoxAn2Df (Rot2D (vec2 (length (q.xz) - 4., q.y), 6. * pi * aa), vec2 (0.5), 0.05);\n  gz = dot (q.zx, sin (2. * pi * ((floor (32. * a) + 0.5) / 32. + vec2 (0.25, 0.))));\n  q.xy = Rot2D (vec2 (dot (q.xz, sin (2. * pi * (vec2 (0.25, 0.) - a))) + 4., q.y), 6. * pi  * a);\n  d = max (d, - min (PrBox2Df (vec2 (q.x, gz), vec2 (0.35, 0.25)),\n     PrBox2Df (vec2 (q.y, gz), vec2 (0.35, 0.25))));\n  return 0.6 * d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 50; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += min (0.2, 3. * h);\n    if (sh < 0.001) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, sh;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    sh = ObjSShadow (ro, ltDir);\n    col = vec3 (0.7, 0.6, 0.6) * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       0.4 * vec3 (0.7, 0.7, 1.) * smoothstep (0.5, 0.8, sh) *\n       pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n  } else {\n    col = vec3 (0.6, 1., 0.6) * (0.2 + 0.2 * (rd.y + 1.) * (rd.y + 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.8 * pi * mPtr.y;\n  } else {\n    az += 0.1 * pi * tCur;\n    el += 0.35 * pi * sin (0.07 * pi * tCur);\n  }\n  el = clamp (el, -0.35 * pi, 0.35 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -20.);\n  zmFac = 5. + 2. * sin (0.05 * pi * tCur);\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (-1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrBoxAn2Df (vec2 p, vec2 b, float w)\n{\n  return max (PrBox2Df (p, vec2 (b + w)), - PrBox2Df (p, vec2 (b - w)));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdKyWy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[345, 345, 367, 367, 931], [933, 933, 966, 966, 1143], [1145, 1145, 1166, 1166, 1366], [1368, 1368, 1405, 1405, 1643], [1645, 1645, 1680, 1680, 2171], [2173, 2173, 2229, 2229, 3402], [3404, 3404, 3437, 3437, 3526], [3528, 3528, 3572, 3572, 3647], [3649, 3649, 3679, 3679, 3792]], "test": "ok"}
{"id": "MdKyzy", "name": "Scanner screen", "author": "Abvadabra", "description": "Shader for scanner's screen", "tags": ["noise", "screen"], "likes": 1, "viewed": 121, "published": "Public", "date": "1522742955", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 bg = texture(iChannel0, uv);\n    \n    vec3 col = bg.rgb;\n\tcol *= vec3(.6, 1., .6);\n    \n    col += sin(uv.y * 700.) * 0.15;\n    \n    float y = fract(-iTime / 2.);\n    float b = 0.002;\n    col += (smoothstep(y - b, y, uv.y) - smoothstep(y, y + b, uv.y)) * abs(sin((uv.y + iTime) * 1.)) * .5;\n    \n    float p = fract(-iTime / 4.);\n    float s = 0.2;\n    float d = smoothstep(p - s, p, uv.y) - smoothstep(p, p + s, uv.y);\n    col += noise((uv * 1000. + iTime * 10.) * 5.) * (0.1  + 0.2 * d);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdKyzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 86], [88, 88, 108, 108, 316], [318, 318, 375, 375, 953]], "test": "error"}
{"id": "MdscWn", "name": "Odecee spinners", "author": "rubixcom", "description": "try some simple shapes", "tags": ["marchingsimple"], "likes": 5, "viewed": 313, "published": "Public API", "date": "1524560763", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float plane( vec3 p , float t)\n{\n\treturn p.y - t;\n}\n\nfloat roundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\n\nfloat sphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 subtract( vec2 d1, vec2 d2 )\n{\n    vec2 res = max(d2.x,d1.x) == d1.x ? d1 : d2;\n    res.y = d1.y;\n    return res;\n}\n\nvec2 unity( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 repeatXZ( vec3 p, vec3 c )\n{\n    vec3 res = mod(p,c)-0.5*c;\n    res.y = p.y;\n    return res;\n}\n\nvec3 repeatXYZ( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec2 map( in vec3 p )\n{\n   float len=1.45;\n   float thick=.1;\n   float rad=.3;\n    vec3 pp = repeatXZ(p, vec3(6.0));\n    pp.z = pp.z + .4 * pp.y;\n  //  pp.y += -1.+sin(iTime + p.x - mod(p.x,6.));\n\n    float scale = 1.; float ang = \n        0.5*sin(iTime) * p.x +\n        .2*iTime*(1.0 + p.x - mod(p.x,6.)) + .2*iTime*(p.z - mod(p.z,6.));\n        mat3 rotation = mat3(cos(ang),0.,sin(ang),\n                             0.,1.,0.,\n                  -sin(ang),0.,cos(ang));\n\n    pp = pp * rotation;\n    \n    vec3 ppp = repeatXYZ(p, vec3(.5));\n    vec3 pppw = p - ppp;\n    \n    vec2 res = unity( vec2( plane(     p, -2.5), 1.0 ), vec2( roundBox(pp, vec3(thick,thick,len), rad), 101.0 ) );\n    res = unity(res, vec2( roundBox(pp+vec3(0.,len,0.), vec3(thick,thick,len), rad), 101.0 ) );\n    res = unity(res, vec2( roundBox(pp+vec3(0.,0.+(len-8.*thick),0.-(len-8.*thick)), vec3(thick,len,thick), rad), 101.0 ) );\n    res = unity(res, vec2( roundBox(pp+vec3(0.,0.+(len-8.*thick),len-(len-8.*thick)), vec3(thick,len,thick), rad), 101.0 ) );\n    res = subtract(res, vec2( sphere(ppp,  abs(sin(iTime / 10.))), 0.));\n        \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 90.0;\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x * .6;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(1.0, 1.0, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = step(0.,sin(10.*length(pos.xz)+20.*atan(pos.x, pos.z)));\n            col = 0.3 + 0.1*f*vec3(1.0);\n        }\n        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(0.4, 0.7, 0.6) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n\t\tlin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(1.0,1.0,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // camera\t\n    vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -0.5, -0.0, 0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,1.5) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n    // gamma\n//    col = pow( col, vec3(0.4545) );\n\n\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdscWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 51], [53, 53, 96, 96, 138], [141, 141, 174, 174, 200], [202, 202, 237, 237, 322], [324, 324, 356, 356, 389], [391, 391, 424, 424, 490], [492, 492, 526, 526, 555], [557, 557, 580, 580, 1687], [1689, 1689, 1729, 1729, 2060], [2063, 2063, 2137, 2137, 2397], [2399, 2399, 2431, 2431, 2639], [2641, 2641, 2683, 2683, 2982], [2984, 2984, 3023, 3023, 4553], [4555, 4555, 4607, 4607, 4784], [4786, 4786, 4843, 4843, 5429]], "test": "ok"}
{"id": "MdtBzH", "name": "improved perlin noise (+tilable)", "author": "FabriceNeyret2", "description": "Bottom: base noise. top: cascade   SPACE: raw noises\nLeft to right: improved true Perlin noise, displacement from 2D noise, from grad(1D noise), from curl(1D noise), from grad(cascade) ( which corrupts scale weights)\nNB: grads from hardware derivatives.", "tags": ["noise", "perlin", "mz"], "likes": 19, "viewed": 782, "published": "Public API", "date": "1524165339", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// - shadertoy contains a lot of pseudo Perlin noise, showing indeed value noise \n//   (possibly spline-interpolated) rather than gradient noise\n// - original Perlin noise shows poor derivatives\n// - in 2002, Perlin proposed an improved version\n// - here, I show a 2D version (z=0) and replace permutations by quality integer hash.\n\nfloat noise_A = .5,               // displacement amplitude\n      noise_S = 10.,              // noise scale\n        WIDTH = .2;               // vein width: 1. .2 .01\nvec2 CYCLE = 0.*vec2(1./4.);      // tilable domain\nvec2 R;\n\n// === Perlin noise ( true gradient noise + improved scheme for nice derivatives )\n// Ref implem of 2002 Perlin improved noise: http://mrl.nyu.edu/~perlin/noise/\n// Here, 2D & integer hash instead of permutations.\n\n// std int hash, inspired from https://www.shadertoy.com/view/XlXcW4\nvec3 hash3i( uvec3 x ) \n{\n#   define scramble  x = ( (x>>8U) ^ x.yzx ) * 1103515245U // GLIB-C const\n    scramble; scramble; scramble; \n    return vec3(x) / float(0xffffffffU) + 1e-30; // <- eps to fix a windows/angle bug\n}\n#define unsigned(v) ( (v) >= 0. ? uint(v) : -1U-uint(-(v)) ) // for uint(float < 0) is bugged\n#define hash(v) hash3i(uvec3(unsigned((v).x),unsigned((v).y),11)).x \n//#define hash(v) hash3i(uvec3(v+float(0x0000ffffU),11)).x // why ?\n//#define hash(x)  fract(sin(dot(x,vec2(1,17.53))) * 43758.5453123)\n\nfloat grad(float r, vec2 p) {\n      int h = int(r*256.) & 15;\n      float u = h<8 ? p.x : p.y,                 // 12 gradient directions\n            v = h<4 ? p.y : h==12||h==14 ? p.x : 0.; // p.z;\n      return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);\n}\n\n#define G(v) grad(hash(I+v),p-v)\n#define fade(t)  t * t * t * (t * (t * 6. - 15.) + 10.) // super-smoothstep\n\nfloat Inoise2(vec2 p) {\n    vec2 I = floor(p); p -= I;    \n    vec2 f = fade(p);\n    \n    return mix( mix( G(vec2(0,0)),G(vec2(1,0)), f.x),\n                mix( G(vec2(0,1)),G(vec2(1,1)), f.x), f.y );\n}  \n\n//#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nfloat fbm2(vec2 p) {\n    float v = 0.,  a = .5;\n    //mat2 R = rot(.37); // should no longer be necessary\n\n    for (int i = 0; i < 3; i++, p*=2.,a/=2.) \n        //p *= R,\n        v += a * Inoise2(p);\n        //v += a *a*2.* Inoise2(p); // trying to get derivatives respect the scale profile\n\n    return v;\n}\n\n// --- tilable version \n#define Gt(v) grad(hash(mod(I+v,cycle)),p-v)\n\nfloat InoiseT2(vec2 p, vec2 cycle) {\n    vec2 I = floor(p); p -= I;    \n    vec2 f = fade(p);\n    \n    return mix( mix( Gt(vec2(0,0)),Gt(vec2(1,0)), f.x),\n                mix( Gt(vec2(0,1)),Gt(vec2(1,1)), f.x), f.y );\n}  \n\n//#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nfloat fbmT2(vec2 p, vec2 cycle) {\n    float v = 0.,  a = .5;\n    //mat2 R = rot(.37); // should no longer be necessary\n\n    for (int i = 0; i < 3; i++, p*=2.,a/=2.,cycle*=2.) \n        //p *= R,\n        v += a * InoiseT2(p,cycle);\n        //v += a *a*2.* Inoise2(p); // trying to get derivatives respect the scale profile\n\n    return v;\n}\n\n// --- version returning vec2\n#define G2(v) vec2( grad(hash(I+v),p-v), grad(hash(I+v+117.),p-v))\nvec2 Inoise22(vec2 p) {\n    vec2 I = floor(p); p -= I;    \n    vec2 f = fade(p);\n    \n    return mix( mix( G2(vec2(0,0)),G2(vec2(1,0)), f.x),\n                mix( G2(vec2(0,1)),G2(vec2(1,1)), f.x), f.y );\n}  \n\nvec2 fbm22(vec2 p) {\n    vec2 v = vec2(0); float  a = .5;\n    //mat2 R = rot(.37);\n\n    for (int i = 0; i < 3; i++, p*=2.,a/=2.) \n        //p *= R,\n        v += a * Inoise22(p);\n\n    return v;\n}\n\n// --- tilable version\n#define Gt2(v) vec2( grad(hash(mod(I+v,cycle)),p-v), grad(hash(mod(I+v,cycle)+117.),p-v))\nvec2 InoiseT22(vec2 p, vec2 cycle) {\n    vec2 I = floor(p); p -= I;    \n    vec2 f = fade(p);\n    \n    return mix( mix( Gt2(vec2(0,0)),Gt2(vec2(1,0)), f.x),\n                mix( Gt2(vec2(0,1)),Gt2(vec2(1,1)), f.x), f.y );\n}  \n\nvec2 fbmT22(vec2 p, vec2 cycle) {\n    vec2 v = vec2(0); float  a = .5;\n    //mat2 R = rot(.37);\n\n    for (int i = 0; i < 3; i++, p*=2.,a/=2., cycle*=2.) \n        //p *= R,\n        v += a * InoiseT22(p,cycle);\n\n    return v;\n}\n\n// --- variant: multifractal \nvec2 mfbm22(vec2 p) {\n    vec2 v = vec2(0), m=vec2(1), n; float  a = .5;\n    //mat2 R = rot(.37);\n\n    for (int i = 0; i < 3; i++, p*=2.,a/=2.) \n        //p *= R,\n        n = Inoise22(p),\n        v += a * m * n,\n        m *= n;\n\n    return v;\n}\n\n// --- variant: make 2D noise using derivative of base\nvec2 gradInoise2(vec2 p) { \n    float n = Inoise2(p); \n    return vec2( dFdx(n), dFdy(n) )/1.875/1.3 * R.y/noise_S ; // / vec2(dFdx(p.x) ,dFdy(p.y) ); \n}\nvec2 gradfbm2(vec2 p) {\n    vec2 v = vec2(0); float  a = .5;\n    //mat2 R = rot(.37); // should no longer be necessary\n\n    for (int i = 0; i < 3; i++, p*=2.,a/=2.) \n        //p *= R,\n        v += a * gradInoise2(p) * a/.5;\n        //v += a *a*2.* Inoise2(p); // trying to get derivatives respect the scale profile\n\n    return v;\n}\n// -- variant: make 2D noise using curl-derivative of base\nvec2 div0Inoise2(vec2 p) { \n    float n = Inoise2(p); \n    return vec2( -dFdy(n), dFdx(n) )/1.875/1.3  * R.y/noise_S ;  // / vec2(dFdx(p.x) ,dFdy(p.y) ); \n}\nvec2 div0fbm2(vec2 p) {\n    vec2 v = vec2(0); float  a = .5;\n    //mat2 R = rot(.37); // should no longer be necessary\n\n    for (int i = 0; i < 3; i++, p*=2.,a/=2.) \n        //p *= R,\n        v += a * div0Inoise2(p) * a/.5;\n\n    return v;\n}\n\n// ------------------------------------------------------\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel3,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    R = iResolution.xy;\n    int i = int(5.*U.x/R.x), j = int(2.*U.y/R.y);\n    U /= R.y; \n    vec2 U0 = U, D;\n    U.y -= .1*iTime;\n    O -= O;\n    //i=0; j=1;\n    U *= noise_S; // U-=100.;\n    if (i==0) {        // raw noise\n        float v = j==1 ? CYCLE==vec2(0) ? fbm2(U)    : fbmT2(U,CYCLE*noise_S)\n                       : CYCLE==vec2(0) ? Inoise2(U) : InoiseT2(U,CYCLE*noise_S);\n        D = vec2(v);\n    } if (i==1) {      // displacement: 2D noise\n        vec2 v = j==1 ? CYCLE==vec2(0) ? fbm22(U)    : fbmT22(U,CYCLE*noise_S)\n                      : CYCLE==vec2(0) ? Inoise22(U) : InoiseT22(U,CYCLE*noise_S);\n        D = v;\n        O.b += .15;\n    } else if (i==2) { // displacement: grad(1D noise)\n        vec2 v = j==1 ? gradfbm2(U)\n                      : gradInoise2(U);\n        D = v;\n        O.g += .15;   \n    } else if (i==3) { // displacement: grad-curl(1D noise): conservative\n        vec2 v = j==1 ? div0fbm2(U)\n                      : div0Inoise2(U);\n        D = v;\n        O.r += .15;   \n    } else if (i==4) { // displacement: grad(cascade)\n        float v = j==1 ? fbm2(U)\n                       : Inoise2(U);\n        D = vec2( dFdx(v),dFdy(v) ) / 1.875  * R.y/noise_S;\n        O.rg += .15;\n    } \n    if (i==0 || keyToggle(32) )\n            O = vec4(.5+.5*D.xyxy);       // raw noise\n        else {\n            U = U0 + noise_A/noise_S * D; // displacement\n            WIDTH = .01+WIDTH*(.5+.5*sin(iTime));\n            O += pow(.5-.5*cos(10.*R.y/R.x*6.28*U.x), 1./WIDTH );\n            //U = (U*R.y-.5*R)/R.x*5.; U.x = fract(U.x-.5)-.5; O += pow(.5-.5*cos(6.28*length(U)*1.2), 1./WIDTH );\n            //O = texture(iChannel0, U);          \n        }\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdtBzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[777, 846, 871, 871, 1069], [1370, 1370, 1399, 1399, 1629], [1741, 1741, 1764, 1764, 1943], [1947, 1999, 2019, 2019, 2306], [2378, 2378, 2414, 2414, 2597], [2601, 2653, 2686, 2686, 2990], [3089, 3089, 3112, 3112, 3295], [3299, 3299, 3319, 3319, 3493], [3608, 3608, 3644, 3644, 3831], [3835, 3835, 3868, 3868, 4060], [4062, 4092, 4113, 4113, 4336], [4338, 4393, 4419, 4419, 4546], [4547, 4547, 4570, 4570, 4878], [4879, 4938, 4964, 4964, 5094], [5095, 5095, 5118, 5118, 5335], [5396, 5396, 5423, 5423, 5496], [5498, 5498, 5536, 5536, 7210]], "test": "error"}
{"id": "MdVcWt", "name": "MandelBox Slice", "author": "thiagoborn", "description": "A slice of the mandelbox fractal, formula taken straight from wikipedia", "tags": ["mandelbox"], "likes": 3, "viewed": 287, "published": "Public API", "date": "1523843994", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int iterations = 5;\nconst float scale = 3.0;\nconst float scape = 3.8;\nconst float eps = 0.003;\n\nvec3 BoxFold(vec3 vec)\n{\n    vec3 o = vec3(0.,0.,0.);\n    for (int k = 0; k < 3; k++)\n    {\n        float axis = vec[k];\n        if (axis > 1.0)\n        {\n            axis = 2.0 - axis;\n        }\n        else if (axis < -1.0)\n        {\n            axis = -2.0 - axis;\n        }\n        o[k] = axis;\n    }\n    return o;\n}\n\nvec3 SphereFold(vec3 vec)\n{\n    float mag = length(vec);\n    if (mag < .5)\n    {\n        vec = vec * 4.0;\n    }\n    else if (mag < 1.0)\n    {\n        vec = vec / (mag * mag);\n    }\n    return vec;\n}\n\nfloat Iteration(vec3 vec)\n{\n    for (int i = 0; i < iterations; i++)\n    {\n        vec = BoxFold(vec);\n        vec = SphereFold(vec);\n        vec = vec * scale;\n    }\n    float mag = length(vec);\n    if(mag < scape){\n        float amt = mag / scape;\n        return amt;\n    }\n    return 1.0/mag;\n    \n}\n\nfloat AAIteration(vec3 v){\n    float aa = Iteration(v);\n\n    aa += Iteration(vec3(v.x + eps, v.y, v.z));\n    aa += Iteration(vec3(v.x - eps, v.y, v.z));\n    aa += Iteration(vec3(v.x, v.y + eps, v.z));\n    aa += Iteration(vec3(v.x, v.y - eps, v.z));\n    aa /= 5.0;\n    \n    return aa;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    vec2 ncs = (fragCoord/iResolution.xy)*2.0-1.0;\n    ncs.x *= aspect;\n    ncs.y *= -1.0;\n    \n  \tvec3 v = vec3(ncs.x + cos(iTime/10.1),ncs.y+cos(iTime/10.7),cos(iTime/25.0)*.9);\n   \t\n    float mag = AAIteration(v);\n    \n  \t// vignette from https://www.shadertoy.com/view/lsKSWR by Ippokratis \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;   \n    float vig = uv.x*uv.y * 15.0; \n    vig = pow(vig, 0.25); \n    \n  \n    mag *= vig;\n\tfragColor = vec4(mag,mag,mag,1.0);\n \n      \n  \t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdVcWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 126, 126, 422], [424, 424, 451, 451, 622], [624, 624, 651, 651, 926], [928, 928, 954, 954, 1213], [1215, 1215, 1272, 1272, 1885]], "test": "ok"}
{"id": "MdVczK", "name": "Bossman makes doughnuts", "author": "demografica", "description": "Lots toruses", "tags": ["sdf", "torus"], "likes": 1, "viewed": 65, "published": "Public", "date": "1522691346", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SHADERTOY\n#define SHADERTOY_ZOOM 1.0\n#define BLEND_COLOR\nprecision mediump float;\nuniform vec3 uOrigin;\nuniform mat3 uView;\nuniform vec2 uInvSize;\nuniform mat4 uBaseTransform;\nuniform vec3 uBaseColor;\nuniform vec3 uBaseMod;\nuniform vec2 uTorusRadii;\nuniform float uRoundRadius;\nuniform float uChamferRadius;\nuniform vec2 uColumns;\nuniform vec2 uStairs;\n#define PI 3.141592653589793\n#define PI_2 1.5707963267948966\n#define SQRT1_2 0.7071067811865476\n#define SQRT2 1.4142135623730951\n\n// raymarching code from https://www.shadertoy.com/view/Xds3zN\n\n// blend color for chamfer and round operators (sd is simple operator distance)\nvec3 colorBlending(const in float sd, const in vec4 a, const in vec4 b) {\n  float ra = clamp(sd / a.x, 0.0, 1.0);\n  float rb = clamp(sd / b.x, 0.0, 1.0);\n  return (a.yzw * ra + b.yzw * rb) / (ra + rb);\n}\n\nvec3 colorUnion(const in vec4 a, const in vec4 b){\n#ifdef BLEND_COLOR\n  return colorBlending(min(a.x, b.x), a, b);\n#else\n  return (a.x < b.x) ? a.yzw : b.yzw;\n#endif\n}\n\nvec3 colorInter(const in vec4 a, const in vec4 b){\n#ifdef BLEND_COLOR\n  return colorBlending(max(a.x, b.x), a, b);\n#else\n  return (a.x < b.x) ? a.yzw : b.yzw;\n#endif\n}\n\nvec2 pR45(const in vec2 p) {\n  return (p + vec2(p.y, -p.x)) * SQRT1_2;\n}\n\n/////////////\n// PRIMITIVES\n/////////////\n\nfloat cullPlane(const in vec3 p) {\n  return p.y >= -0.502 ? p.y + 0.5 : 20.0;\n}\n\nfloat sdSphere(const in vec3 p, const in float s) {\n  return length(p) - s;\n}\n\nfloat sdBox(const in vec3 p, const in vec4 b) {\n  vec3 d = abs(p) - b.xyz;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - b.w;\n}\n\nfloat sdTorus(const in vec3 p, const in vec2 t) {\n  return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nfloat sdCapsule(const in vec3 p, const in vec2 rh) {\n  return mix(length(p.xz) - rh.x, length(vec3(p.x, abs(p.y) - rh.y, p.z)) - rh.x, step(rh.y, abs(p.y)));\n}\n\nfloat sdEllipsoid(const in  vec3 p, const in vec3 r) {\n  return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n///////////////\n// COMBINATIONS\n///////////////\n\n// UNION\nfloat opUnion(const in float a, const in float b) {\n  return min(a, b);\n}\nvec4 opUnion(const in vec4 a, const in vec4 b) {\n  return (a.x < b.x) ? a : b;\n}\n\n// INTER\nfloat opInter(const in float a, const in float b) {\n  return max(a, b);\n}\nvec4 opInter(const in vec4 a, const in vec4 b) {\n  return (a.x > b.x) ? a : b;\n}\n\n// SUB\nfloat opSub(const in float a, const in float b) {\n  return max(-b, a);\n}\nvec4 opSub(const in vec4 a, const in vec4 b) {\n  // to keep b material on diff intersection instead of a mat\n  // return (-b.x > a.x) ? vec4(-b.x, b.yzw) : a);\n  return vec4(max(-b.x, a.x), a.yzw);\n}\n\n// see hg_sdf.glsl\n/////////////////////\n// COMBINATIONS ROUND\n/////////////////////\n\n// UNION ROUND (soft media mol version)\nfloat opUnionRound(const in float a, const in float b, const in float r) {\n  float e = max(r - abs(a - b), 0.0);\n  return min(a, b) - e * e * 0.25 / r;\n}\nvec4 opUnionRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opUnionRound(a.x, b.x, r), colorUnion(a, b));\n}\n\n// INTER ROUND\nfloat opInterRound(const in float a, const in float b, const in float r) {\n  vec2 u = max(vec2(r + a, r + b), vec2(0.0));\n  return min(-r, max(a, b)) + length(u);\n}\nvec4 opInterRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterRound(a.x, b.x, r), colorInter(a, b));\n}\n\n// SUB ROUND\nfloat opSubRound(const in float a, const in float b, const in float r) {\n  return opInterRound(a, -b, r);\n}\nvec4 opSubRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterRound(a.x, -b.x, r), a.yzw);\n}\n\n///////////////////////\n// COMBINATIONS CHAMFER\n///////////////////////\n\n// UNION CHAMFER\nfloat opUnionChamfer(const in float a, const in float b, const in float r) {\n  return min(min(a, b), (a - r + b) * SQRT1_2);\n}\nvec4 opUnionChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opUnionChamfer(a.x, b.x, r), colorUnion(a, b));\n}\n\n// INTER CHAMFER\nfloat opInterChamfer(const in float a, const in float b, const in float r) {\n  return max(max(a, b), (a + r + b) * SQRT1_2);\n}\nvec4 opInterChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterChamfer(a.x, b.x, r), colorInter(a, b));\n}\n\n// SUB CHAMFER\nfloat opSubChamfer(const in float a, const in float b, const in float r) {\n  return opInterChamfer(a, -b, r);\n}\nvec4 opSubChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterChamfer(a.x, -b.x, r), a.yzw);\n}\n\n//////////////////////\n// COMBINATION COLUMNS\n//////////////////////\n\n// UNION COLUMNS\nfloat opUnionColumns(const in float a, const in  float b, const in vec2 rn) {\n  float r = rn.x;\n  float n = rn.y;\n  if((a < r) && (b < r)) {\n    vec2 p = vec2(a, b);\n    float columnradius = r * SQRT2 / ((n - 1.0) * 2.0 + SQRT2);\n    p = pR45(p);\n    p.x -= SQRT1_2 * r;\n    p.x += columnradius * SQRT2;\n    if(mod(n, 2.0) == 1.0) {\n      p.y += columnradius;\n    }\n    // At this point, we have turned 45 degrees and moved at a point on the\n    // diagonal that we want to place the columns on.\n    // Now, repeat the domain along this direction and place a circle.\n    p.y = mod(p.y + columnradius, columnradius * 2.0) - columnradius;\n    float result = length(p) - columnradius;\n    result = min(result, p.x);\n    result = min(result, a);\n    return min(result, b);\n  } \n\n  return min(a, b);\n}\nvec4 opUnionColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opUnionColumns(a.x, b.x, rn), colorUnion(a, b));\n}\n\n// SUB COLUMNS\nfloat opSubColumns(const in float ain, const float b, const vec2 rn) {\n  float a = -ain;\n  float r = rn.x;\n  float n = rn.y;\n  float m = min(a, b);\n  //avoid the expensive computation where not needed (produces discontinuity though)\n  if((a < r) && (b < r)) {\n    vec2 p = vec2(a, b);\n    float columnradius = r * SQRT2 / n / 2.0;\n    columnradius = r * SQRT2 / ((n - 1.0) * 2.0 + SQRT2);\n\n    p = pR45(p);\n    p.y += columnradius;\n    p.x -= SQRT1_2 * (r + columnradius);\n\n    if(mod(n, 2.0) == 1.0) {\n      p.y += columnradius;\n    }\n    p.y = mod(p.y + columnradius, columnradius * 2.0) - columnradius;\n\n    float result = -length(p) + columnradius;\n    result = max(result, p.x);\n    result = min(result, a);\n    return -min(result, b);\n  }\n\n  return -m;\n}\nvec4 opSubColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opSubColumns(a.x, b.x, rn), a.yzw);\n}\n\n// INTER COLUMNS\nfloat opInterColumns(const in float a, const in float b, const in vec2 rn) {\n  return opSubColumns(a, -b, rn);\n}\nvec4 opInterColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opSubColumns(a.x, -b.x, rn), colorInter(a, b));\n}\n\n/////////////////////\n// COMBINATION STAIRS\n/////////////////////\n// UNION STAIRS\nfloat opUnionStairs(const in float a, const in float b, const in vec2 rn) {\n  float s = rn.x / rn.y;\n  float u = b - rn.x;\n  return min(min(a, b), 0.5 * (u + a + abs((mod(u - a + s, 2.0 * s)) - s)));\n}\nvec4 opUnionStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opUnionStairs(a.x, b.x, rn), colorUnion(a, b));\n}\n\n// INTER STAIRS\nfloat opInterStairs(const in float a, const in float b, const in vec2 rn) {\n  return -opUnionStairs(-a, -b, rn);\n}\nvec4 opInterStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(-opUnionStairs(-a.x, -b.x, rn), colorInter(a, b));\n}\n\n// SUB STAIRS\nfloat opSubStairs(const in float a, const in float b, const in vec2 rn) {\n  return -opUnionStairs(-a, b, rn);\n}\nvec4 opSubStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(-opUnionStairs(-a.x, b.x, rn), a.yzw);\n}\n\n/////////////\n// REPETITION\n/////////////\n\nvec3 pMod(const in vec3 p, const in vec3 size) {\n  vec3 pmod = p;\n  if(size.x > 0.0) pmod.x = mod(p.x + size.x * 0.5, size.x) - size.x * 0.5;\n  if(size.y > 0.0) pmod.y = mod(p.y + size.y * 0.5, size.y) - size.y * 0.5;\n  if(size.z > 0.0) pmod.z = mod(p.z + size.z * 0.5, size.z) - size.z * 0.5;\n  return pmod;\n}\n\n////////////\n// HELPERS\n////////////\nvec4 mapDistanceColor(const in vec3 point) {\n  vec4 tmpPrim_5 = vec4(cullPlane(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.30000001192092896,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0))) * 1.0, vec3(0.1) * (mod(floor(5.0 * point.z) + floor(5.0 * point.x), 2.0)) + 0.4);\nvec4 tmpPrim_6 = vec4(sdTorus(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,1.47)), vec2(0.4,0.05)) * 1.0, vec3(0.5,0.5,1.0));\nvec4 tmpComb_5 = opUnionRound(tmpPrim_5, tmpPrim_6, 1.0);\nreturn tmpComb_5;\n}\n\nfloat mapDistance(const in vec3 point) {\n  float tmpComb_6 = opUnionRound(cullPlane(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.30000001192092896,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0))) * 1.0, sdTorus(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,1.47)), vec2(0.4,0.05)) * 1.0, 1.0);\nreturn tmpComb_6;\n}\n    \nvec4 castRay(const in vec3 ro, const in vec3 rd) {\n  float t = 1.0;\n  float tmax = 50.0;\n\n  float precis = 0.002;\n  for(int i = 0; i < 50; i++) {\n    float dist = mapDistance(ro + rd * t);\n    if(dist < precis || t > tmax)\n      break;\n    t += dist;\n  }\n\n  vec3 m = t > tmax ? vec3(-1.0) : mapDistanceColor(ro + rd * t).yzw;\n  return vec4(t, m);\n}\n\nfloat softshadow(const in vec3 ro, const in vec3 rd) {\n  float t = 0.02;\n  float tmax = 2.5;\n  float precis = 0.001;\n  float res = 1.0;\n  for(int i = 0; i < 16; i++) {\n    float h = mapDistance(ro + rd * t);\n    res = min(res, 20.0 * h / t);\n    t += clamp( h, 0.02, 0.10 );\n    if(h < 0.001 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(const in vec3 pos) {\n  vec3 eps = vec3(0.001, 0.0, 0.0);\n  vec3 nor = vec3(\n      mapDistance(pos + eps.xyy) - mapDistance(pos - eps.xyy),\n      mapDistance(pos + eps.yxy) - mapDistance(pos - eps.yxy),\n      mapDistance(pos + eps.yyx) - mapDistance(pos - eps.yyx));\n  return normalize(nor);\n}\n\nfloat calcAO(const in vec3 pos, const in vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for(int i = 0; i < 5; i++) {\n      float hr = 0.01 + 0.03 * float(i);\n      vec3 aopos = nor * hr + pos;\n      occ += (hr - mapDistance(aopos)) * sca;\n      sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0 * occ, 0.0, 1.0 );    \n}\n\nvec3 render(const in vec3 ro, const in vec3 rd) {\n  vec3 col = vec3(0.5, 0.5, 0.5);\n  vec4 res = castRay(ro, rd);\n\n  if(res.y >= 0.0) {\n    vec3 pos = ro + res.x * rd;\n    vec3 nor = calcNormal(pos);\n\n    vec3 ref = reflect( rd, nor );\n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize(vec3(-0.6, 0.7, -0.5));\n    float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float dif = clamp(dot(nor, lig), 0.0, 1.0);\n    float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0 ) * clamp( 1.0 - pos.y, 0.0, 1.0);\n    float dom = smoothstep(-0.1, 0.1, ref.y);\n    float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n    float spe = pow(clamp(dot(ref, lig), 0.0, 1.0),16.0);\n        \n    dif *= softshadow(pos, lig);\n    dom *= softshadow(pos, ref);\n\n    vec3 lin = vec3(0.0);\n    lin += 1.20 * dif * vec3(1.00, 0.85, 0.55);\n    lin += 1.20 * spe * vec3(1.00, 0.85, 0.55) * dif;\n    lin += 0.20 * amb * vec3(0.50, 0.70, 1.00) * occ;\n    lin += 0.30 * dom * vec3(0.50, 0.70, 1.00) * occ;\n    lin += 0.30 * bac * vec3(0.25, 0.25, 0.25) * occ;\n    lin += 0.40 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\n    col = res.yzw * lin;\n  }\n\n  return clamp(col, 0.0, 1.0);\n}\n\n#ifdef SHADERTOY\nmat3 setCamera( const in vec3 ro, const in vec3 ta, const float cr ){\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr),0.0);\n  vec3 cu = normalize( cross(cw,cp) );\n  vec3 cv = normalize( cross(cu,cw) );\n  return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec2 p = -1.0 + 2.0 * q;\n  p.x *= iResolution.x / iResolution.y;\n  vec2 mo = iMouse.xy / iResolution.xy;\n  float time = 15.0 + iTime;\n\n  // camera \n  vec3 ro = SHADERTOY_ZOOM * vec3( -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x), 1.0 + 2.0 * mo.y, 0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n  vec3 ta = vec3(-0.5, -0.4, 0.5);\n\n  // camera-to-world transformation\n  mat3 ca = setCamera(ro, ta, 0.0);\n\n  // ray direction\n  vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n  fragColor = vec4(render(ro, rd), 1.0);\n}\n\n#else\n\nvec3 raymarch(const in vec3 origin, const in mat3 view, const in vec2 uv, const in vec2 invSize) {\n  vec2 p = -1.0 + 2.0 * uv;\n  p.x *= invSize.y / invSize.x;\n  vec3 rd = normalize(view * vec3(p, 2.0));\n  return render(origin, rd);\n}\n\nvoid main() {\n  gl_FragColor = vec4(raymarch(uOrigin, uView, gl_FragCoord.xy * uInvSize, uInvSize), 1.0);\n}\n\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdVczK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "error"}
{"id": "MdVyR3", "name": "Random Color", "author": "Koji", "description": "Random Color", "tags": ["random"], "likes": 0, "viewed": 599, "published": "Public", "date": "1522823220", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rnd(float i) {\n\treturn mod(4000.*sin(23464.345*i+45.345),1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 - 0.5*cos(iTime+uv.xyx+vec3(0,2,4))/rnd(iTime * 7.)+0.05;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdVyR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 69], [71, 71, 128, 178, 386]], "test": "ok"}
{"id": "MdVyRK", "name": "osu!lazer", "author": "Sunpy", "description": "osu!lazer logo\n\nThis is not optimal and its me just trying to learn how to write shaders.\nI do not know how to use buffers but if someone where to push me in the right direction that should be appreciated.", "tags": ["triangle", "osu"], "likes": 3, "viewed": 255, "published": "Public", "date": "1522678213", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SEED 0.12345679\n\n#define TRI 128.0\n#define SP 0.1\n#define COLOR vec3(0.9411764705882353,0.4274509803921569,0.6549019607843137)\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nfloat rand (vec2 p) {\n    return fract(sin(dot(p.xy,\n                         vec2(6.8245,7.1248)))*\n        9.1283);\n}\n\nfloat tri(vec2 uv, vec2 p, float s){\n    vec2 v = uv;\n    v -= p;\n    v /= max(s, 0.01);\n    \n\tfloat a = atan(v.x, v.y) + PI;\n    float r = TWO_PI / 3.0;\n    \n    float t = cos(floor(0.5 + a / r) * r - a) * length(v);\n    \n    return smoothstep(0.4, 0.41, t);\n}\n\nfloat yPos(float i){\n    vec2 p = vec2(SEED, i);\n    \n    float r = rand(p);\n    return fract(iTime * SP + r);\n}\n\nfloat xPos(float i, float t){\n    vec2 p = vec2(i, t - iTime * SP);\n    return rand(p) + .375;\n}\n\nvec3 triCol(float i, float t){\n    vec3 col = COLOR;\n    float r = xPos(i + 1.0, t);\n    col *= mix(0.9, 1.1, r);\n    return col;\n}\n\nmat2 rot(float a){\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat circ(vec2 uv, vec2 p, float s){\n    vec2 d = uv - p;\n    return 1.-smoothstep(s-(s*0.01),\n                         s+(s*0.01),\n                         dot(d,d)*4.0);\n}\n\nfloat box(vec2 uv, vec2 s){\n    s = vec2(0.0) - s*0.5;\n    vec2 _uv = smoothstep(s,\n                        s+vec2(0.001),\n                        uv);\n    _uv *= smoothstep(s,\n                    s+vec2(0.001),\n                    vec2(0.0)-uv);\n    return _uv.x*_uv.y;\n}\n/*\nvec3 cLine(vec2 p, float s){ // Can be used to precalc data to be used for improved line function\n    return vec3(p, s);\n}\n\nfloat line(vec2 uv, vec3 c){\n    vec2 v = uv;\n    v -= c.xy;\n    v /= max(c.z, 0.01);\n    \n    float t = 0.0;\n    \n    t += circ(v, vec2(0.0, 1.0), c.z);\n    t += circ(v, vec2(0.0, -1.0), c.z);\n    t += box(v, vec2(0.45, 2.0));\n    \n    return t;\n}\n*/\nfloat line(vec2 uv, vec2 p, float s){\n    vec2 v = uv;\n    v -= p;\n    v /= max(s, 0.01);\n    \n    float t = 0.0;\n    \n    t += circ(v, vec2(0.0, 1.0), s);\n    t += circ(v, vec2(0.0, -1.0), s);\n    t += box(v, vec2(s * 1.8 + 0.1, 2.0)); // Randomly found out that the value I used for testing scale was unique so this is just me trying to make it seem like it works with a weird formula\n    \n    \n    return t;//smoothstep(0.4, 0.41, t);\n}\n\nvec3 lineCol(vec2 uv){\n    vec3 col = mix(\n        vec3(0.453125, 0.75, 0.828125),\n        vec3(0.59375, 0.81640625, 0.828125),\n        sin(uv.y * 6.0 + cos(uv.x * 3.6))\n    );\n    \n    return col;\n}\n\nfloat getLines(vec2 uv){\n    float lines = 0.0;\n    \n    for (float i = 0.0; i < 64.0; i++){\n        float id = i / 64.0;\n        \n        mat2 a = rot(0.7853981633974483); // PI / 4\n        vec2 v = uv * a;\n        \n        float y = yPos(id);\n        float x = xPos(id, y);\n        float s = xPos(id, y) * 0.2;\n        \n        float l = line(v, vec2(-s) + vec2(x, y) * 2.5 - vec2(1.6, 0.0), s);\n        lines += max(0.0, l);\n    }\n    \n    lines = max(0.0, min(1.0, lines));\n    return lines;\n}\n\nvec3 background(vec2 uv){\n    vec3 col = mix(\n        mix(\n            vec3(0.51953125, 0.52734375, 0.5859375),\n            vec3(0.21875, 0.2890625, 0.37890625),\n            cos(uv.x * sin(uv.y * 4.0 + iTime) + uv.y * 2.0)\n            ),\n        vec3(0.21, 0.4, 0.5),\n        sin(uv.y * 7.24 + cos(uv.x * uv.y + iTime) * sin(iTime + uv.x * 5.3)) / 2.0 + 1.0\n    );\n    \n    uv.x *= (iResolution.x / iResolution.y);\n    \n    col = max(vec3(0.0), col - 0.2 * getLines(uv * vec2(1.04, 1.0) - vec2(0.04, 0.0)));\n    \n    float l = getLines(uv);\n    if (l > 0.0)\n    \tcol = lineCol(uv) * l;\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = COLOR;\n    \n    // Generate all dem triangles\n    for (float i = TRI; i > 0.0; i--){\n        float id = i / TRI;\n        float y = yPos(id);\n        float x = xPos(id, y);\n        float s = min(0.89, max(0.071, id * 0.5));\n        float shad = tri(\n            uv,\n            vec2(x, mix(-s, 1.0 + s / 2.0, y)),\n            s\n        );\n        \n        if (shad < 0.1)\n        \tcol = triCol(id, y) * (1.0 - shad);\n    }\n    \n    // Set background mask\n    float dist = distance(uv, vec2(0.5 * iResolution.x / iResolution.y, 0.5));\n    float l = abs(dist - 0.4);\n    if (dist > 0.4)\n        col = background(vec2(uv.x / (iResolution.x / iResolution.y), uv.y));\n    \n    // Make circle logo shadow\n    float dist_shad = distance(uv, vec2(0.5 * iResolution.x / iResolution.y, 0.49));\n    float l_shad = abs(dist_shad - 0.4);\n    col *= mix(0.3, 1.0, min(1.0, l_shad * 30.0));\n    \n    // Make circle logo\n    col = max(col, vec3(smoothstep(0.97, 0.971, 1.0 - l)));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdVyRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[191, 191, 212, 212, 310], [312, 312, 348, 348, 573], [575, 575, 595, 595, 687], [689, 689, 718, 718, 785], [787, 787, 817, 817, 918], [920, 920, 938, 938, 1004], [1006, 1006, 1043, 1043, 1180], [1182, 1182, 1209, 1209, 1454], [1455, 1834, 1871, 1871, 2273], [2275, 2275, 2297, 2297, 2474], [2476, 2476, 2500, 2500, 2973], [2975, 2975, 3000, 3000, 3583], [3585, 3585, 3640, 3640, 4739]], "test": "ok"}
{"id": "MdycDc", "name": "Rainbow Ball", "author": "nightfox", "description": "The RGB cube mapped onto a sphere.", "tags": ["rgb"], "likes": 2, "viewed": 390, "published": "Public API", "date": "1523541516", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 200\n#define MIN_DIST 0.005\n#define zoom 1.\n\nfloat sphere(vec3 ro, float r) {\n\treturn length(ro)-r;   \n}\n\nvec3 getColor(vec3 ro, vec3 s) {\n \treturn vec3(.5+ro.x-s.x,.5+ro.y-s.y,.5+ro.z-s.z);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.5*cos(iTime+2.*uv.x));\n\n    col += mod(sin(iTime*uv.x+uv.y)*cos(uv.x)*4., uv.x);\n    col.g += 2.*uv.x*sin(iTime);\n    col /= 10.*uv.y;\n    uv -= .5;\n    uv *= 2.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = vec3(2.*sin(iTime),0.6*sin(iTime),2.*cos(iTime));\n    vec3 sph = vec3(0.);\n    vec3 f = normalize(sph-ro);\n    vec3 r = cross(vec3(0.,1.,0.), f);\n    vec3 u = cross(f, r);\n    vec3 c = ro + f * zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = i - ro;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tfloat d = sphere(ro-sph, 1.);\n        if (d < MIN_DIST) {\n        \tcol.rgb = getColor(ro,sph);\n            break;\n        }\n        ro += d*rd;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdycDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 94, 94, 121], [123, 123, 155, 155, 212], [214, 214, 271, 321, 1118]], "test": "ok"}
{"id": "MdycDt", "name": "Mandelbrot toying", "author": "trisslotten", "description": "fractals", "tags": ["mandelbrot"], "likes": 3, "viewed": 86, "published": "Public", "date": "1524215265", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 sqr(vec2 z) {\n \treturn vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y); \n}\n\nconst float iterations = 1000.0;\n\nfloat iterate(vec2 num) {\n    vec2 z = num;\n    float i = 0.0;    \n    for(; i < iterations; i++) {\n        if(length(z) > 2.0) {\n        \tbreak;   \n        }\n        \n        z = sqr(z) + num;\n    }\n    return i;\n}\n\nconst float PI = 3.14159265359;\n\nvec3 color(float i) {\n    if(i >= iterations) {\n     \treturn vec3(0);   \n    }\n    i = log(i) + 5.0*iTime;\n    vec3 result;\n    result.r = 0.5*sin(i) + 0.5;\n    result.g = 0.5*sin(i + 2.0*PI*1.0/3.0) + 0.5;\n    result.b = 0.5*sin(i + 2.0*PI*2.0/3.0) + 0.5;\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy;\n\n    vec2 center = vec2(-1.4015, 0);\n    float size = 2.0*pow(0.5*sin(iTime*0.5)+0.5, 2.0) + 0.0001;\n    \n    vec2 num = center + (uv-0.5)*size;\n \n    float i = iterate(num);   \n    vec3 col = color(i);\n    \n    \n    \n    \n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdycDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 19, 19, 69], [105, 105, 130, 130, 320], [355, 355, 376, 376, 632], [634, 634, 691, 691, 988]], "test": "ok"}
{"id": "MdycDV", "name": "Triangle Mesh With Incircles", "author": "Shane", "description": "Applying some mild adaptions to Tomkh's random triangulation algorithm to create a haphazard triangular mesh with some inscribed packed circles.", "tags": ["triangle", "circle", "packing", "delaunay", "incircle"], "likes": 48, "viewed": 1367, "published": "Public API", "date": "1523626331", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tTriangle Mesh With Incircles\n\t----------------------------\n\n\tApplying some mild adaptions to Tomkh's random triangulation algorithm to create a \n\thaphazard triangular mesh with some inscribed packed circles.\n\n\tI'd made a few half-hearted attempts to put together a geometric Delaunay triangulation in\n\tshader form, but for some reason the lack of random pixel access was throwing me off. Anyway, \n\tI made a side comment regarding my desire to see one on Shadertoy, and Tomkh posted a really\n\tcool looking and clever example almost immediately afterward, which pleased me no end. :)\n\tIf you haven't seen it, I've provided a link below.\n\n\tThis shader is just a variation of the original. I wrote it from scratch, but based it on \n\tthe logic from Tomkh's example. I expanded the 2x2 grid count to 3x3, in order to enable \n\tthe grid vertices to move further away from their original positions. In addition, I've \n\ttaken a polygon hit approach. Basically, I've iterated through all possible contributing \n\tquadrilaterals within the pixel area, determined the specific triangle, then effectively \n\tbroken from the loop and returned its three vertices and unique identifier.\n\n\tThe beauty of having access to the triangle vertices and ID in screen space is that you can\n\trender anything you want using normal vector rendering techniques. It's also pretty easy\n\tto render inscribed circles, circumscribed circles, etc. With more work, and provided you\n\thave a Delaunay triangulation, Voronoi edge lists are possible, and you can do some really\n\tcool things with those.\n\n\tNote that I haven't called this a Delaunay triangulation. Tohkh's example puts a restriction\n\ton the grid vertex movement, whereas I've allowed them to move more, which might break the \n\talgorithm -- I have a feeling that additional neighboring checks might be necessary, but I \n    can't be sure. That's a question for someone else to answer, but either way, I'm going to \n\tattempt to construct a dual Voronoi edge-list version next, so I'll find out soon enough... \n\tunless Tomkh wants to do that too. :D\n\n\tFor anyone interested, I've provided a bunch of \"define\" directives below. For instance,\n\tthere are defines that'll exclude the background mesh and incircles for anyone who wants\n\tto study the mesh without the visual clutter. There's also a few different palette choices.\n\n\n\n\tBased on:\n\n\t// I'd been wanting to see a geometric Delaunay triangulation example on Shadertoy for ages,\n\t// so Tomkh (Tomasz Dobrowolski) was kind enough to whip one up in virtually no time. In\n\t// addition to helping me out, I really like the way this is presented.\n\tRandom Delaunay Triangulation - Tomkh\n\thttps://www.shadertoy.com/view/4sKyRD\n\n\tAnother example:\n    \n\t// Really nice screensaver-like example. To my knowledge, Mattz was the first to put up a \n\t// quasi-randomized 2D triangle mesh. However, his particular example uses the same diagonal\n\t// orientation on each quadrilateral.\n\tice and fire - mattz\n\thttps://www.shadertoy.com/view/MdfBzl\n\n\n*/\n\n// Color palette. The default red and gold trim (0), a four-colored pastel palette (1), greyscale with\n// color (2), or just greyscale (3).\n#define PALETTE 0 \n//#define GREY_LINES\n\n// Fixed unanimated triangles, if you don't like the triangle popping effect. :)\n//#define FIXED\n\n// Include the background mesh, or not. Excluding it gives a cleaner, but less interesting, look. \n#define BG_MESH\n\n// Inscribed circle inclusion. Excluding will make the example less exciting, but easier to inspect \n// the mesh constuction.\n#define INCIRCLES\n\n// A visual aid to show the physical square grid.\n//#define SHOW_GRID_CELLS\n\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n\n// Greyscale.\nvec3 grey(vec3 col){ return vec3(1)*dot(col, vec3(.299, .587, .114)); }\n\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(113, 1)));\n    #ifdef FIXED\n    return (fract(vec2(262144, 32768)*n) - .5)*2.*.35;//*.8 + .2; \n    #else\n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    // Note the \".35,\" insted of \".5\" that you'd expect to see. .\n    return sin( p*6.2831853 + iTime/2.)*.35;\n    #endif\n}\n\n\n// vec2 to vec2 hash.\nfloat hash21(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    return fract(sin(dot(p, vec2(113, 1)))*43758.5453);\n} \n\n// Triangle's incenter: The center of the inscribed circle, which in essence is the largest\n// circle that you can fit into a triangle.\nvec2 inCent(vec2 p0, vec2 p1, vec2 p2){\n    \n    // Side lengths.\n    float bc = length(p1 - p2), ac = length(p0 - p2), ab = length(p0 - p1);\n    return (bc*p0 + ac*p1 + ab*p2)/(bc + ac + ab);    \n}\n\n// The radius of the triangle's incircle: I'm keeping this separate to the function\n// above, but you could amalgamate the two. \nfloat inCentRad(vec2 p0, vec2 p1, vec2 p2){\n\n    // Side lengths.\n    float bc = length(p1 - p2), ac = length(p2 - p0),  ab = length(p0 - p1);\n        \n    // Area.\n    float p = (bc + ac + ab)/2.;\n    float area = sqrt(p*(p - bc)*(p - ac)*(p - ab));\n    \n    return area/p;\n}\n\n\n\n// Signed distance to the segment joining \"a\" and \"b.\" We need this one to determine\n// which side of the line a point is on.\n//\n// From Tomkh's original example. I trimmed it a bit, but for all I know, I might have\n// made is slower. :)\nfloat sDistLine(vec2 a, vec2 b) {\n       \n    b -= a; return dot(a, vec2(-b.y, b.x)/length(b)); //return dot(a, normalize(vec2(-b.y, b.x)));\n}\n\n// Unsigned distance to the segment joining \"a\" and \"b.\"\nfloat distLine(vec2 a, vec2 b){\n    \n\tvec2 pa = a;\n\tvec2 ba = a - b;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\t//return smoothstep(-thickness*.5, thickness, length(pa - ba * h));\n    return length(a - ba*h);\n}\n\n// From the the following example:\n// Random Delaunay Triangulation - Tomkh\n// https://www.shadertoy.com/view/4sKyRD\n//\n// Use \"parabolic lifting\" method to calculate if two triangles are about to flip.\n// This is actually more reliable than circumscribed circle method.\n// The technique is based on duality between Delaunay Triangulation\n// and Convex Hull, where DT is just a boundary of convex hull\n// of projected seeds onto paraboloid.\n// We project (h1 h2 h3) triangle onto paraboloid\n// and return the distance of the origin\n// to a plane crossing projected triangle.\nfloat flipDistance(vec2 h1, vec2 h2, vec2 h3)\n{\n   // Projects triangle on paraboloid.\n   vec3 g1 = vec3(h1, dot(h1, h1));\n   vec3 g2 = vec3(h2, dot(h2, h2));\n   vec3 g3 = vec3(h3, dot(h3, h3));\n   // Return signed distance of (g1, g2, g3) plane to the origin.\n   //#if FLIP_ANIMATION\n    // return dot(g1, normalize(cross(g3-g1, g2-g1)));\n   //#else\n     // If we don't do animation, we are only interested in a sign,\n     // so normalization is unnecessary.\n   \t return dot(g1, cross(g3-g1, g2-g1));\n   //#endif\n}\n\n/*\n// IQ's triangle hit routine.\nbool insideTri(vec2 p, vec2 a, vec2 b, vec2 c){\n    \n \t// Compute vectors        \n    vec2 v0 = c - a;\n    vec2 v1 = b - a;\n    vec2 v2 = p - a;\n\n    // Compute dot products\n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n\n    // Compute barycentric coordinates\n    float invDenom = 1./(dot00*dot11 - dot01*dot01);\n    float u = (dot11*dot02 - dot01*dot12)*invDenom;\n    float v = (dot00*dot12 - dot01*dot02)*invDenom;\n\n    // Check if point is in triangle\n    return (u>0. && v>0. && (u + v)<1.)? true : false;  \n    \n}\n*/\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n// IQ's point in a quadrilateral routine -- IQ's original is more sophisticated, but\n// I only needed to return a hit, so I hacked at it a bit. There are probably faster \n// routines, especially since the UV coordinates aren't required. However, I might use them\n// later, so I'll leave it as is for now. By the way, if someone has a fast \"point inside a\n// quad\" algorithm, I'd like to hear about it.\n//\n// Given a point p and a quad defined by four points {a,b,c,d}, return the bilinear\n// coordinates of p in the quad. Returns (-1,-1) if the point is outside of the quad.\nbool insideQuad(in vec2 a, in vec2 b, in vec2 c, in vec2 d){\n\n    vec2 res = vec2(-1.0);\n\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = -a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n\n    // otherwise, it's a quadratic\n    float w = k1*k1 - 4.0*k0*k2;\n    if( w<0.0 ) return false; //vec2(-1.0);\n    w = sqrt( w );\n\n\n    float ik2 = 0.5/k2;\n    float v = (-k1 - w)*ik2; if( v<0.0 || v>1.0 ) v = (-k1 + w)*ik2;\n    float u = (h.x - f.x*v)/(e.x + g.x*v);\n    if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return false;//vec2(-1.0);\n    //res = vec2( u, v );\n    \n    return true;\n}\n\n\n\n// The triangle object.\nstruct triObj{\n    \n    vec2 p0, p1, p2; // The triangle vertices.\n    \n    // Unique ID and one of four triangle cell IDs, which depend on the quadrilateral arrangement.\n    vec2 id, cID; \n    \n};\n    \n\n// The triangle mesh routine: Iterate through the cell and it's 8 neighbors until we hit a quadrilateral, \n// then determine which triangle information to return.\n//\n// I wrote this from scratch, but basically adapted the logic from Tomkh's Delaunay triangle mesh example.\n// It was surprisingly easy to write, but if it were not for his example, I wouldn't have known where to begin. :)\ntriObj triangulate(in vec2 p){\n    \n    // I'm declaring the vertices outside the loop, because it looks neater, but I hear it's faster to declare them\n    // as locally as possible.\n    vec2 o, o1, o2, o3;\n\t\n    // Cell identifier and fractional position.\n    vec2 g = floor(p); p -= g + .5;\n    \n    triObj tri; // The triangle object.\n    tri.p0 = tri.p1 = tri.p2 = vec2(0); // Not really necessary, but just in case I've overlooked something.\n    tri.id = vec2(-1); // Not necessary, since we're guaranteed a hit, but it's a raytracing habit.\n    tri.cID = vec2(-1); // Not necessary, since we're guaranteed a hit, but it's a raytracing habit.\n    \n    // Precalculating the hash values so as not to recalculate too many in the main loop. Basically, I'm setting \n    // up an extra loop, an array, plus indexing, etc, in order to cut down from a possible 36 hash calculations \n    // to 16. Not to mention, making thing less readable... Therefore, it might be a case of diminishing returns. \n    // I'd like to hear what the experts have to say about this, because I'm on the fence as to whether I should\n    // be complicating things and wasting resources with this step. :)\n    //\n    vec2 aO[16];\n    for(int j=0; j<=3; j++){\n\t\tfor(int i=0; i<=3; i++){\n            \n            aO[j*4 + i] = vec2(i - 1, j - 1) + hash22(g + vec2(i - 1, j - 1)) - p;            \n        }\n    }\n    \n    \n    // Iterate through the cell and its 8 neighbors until we hit a quadrilateral, then determine which\n    // triangle to return. I've allowed the grid vertices to randomly move further away from their original\n    // positions, which requires 9 cell checks, instead of just 4. If you restricted random vertex movement\n    // to a factor of \".25\" (See the \"hash22\" function), only 4 checks would be necessary.\n    //\n    // By the way, once a triangle has been found, we break from the loop to avoid further redundant \n    // calculations. This means fewer than 9 checks are performed on average -- A rough guess would be an\n    // average of 5 checks per pass which I'd expect most GPUs can handle in their sleep.\n    //\n\tfor(int j=0; j<=2; j++){\n\t\tfor(int i=0; i<=2; i++){\n            \n \t\t\t// The four quadrilateral vertices for this particular cell. Clockwise arrangement.\n            // o -- o1\n            // |    |\n            // o3-- o2\n\t\t\t//o = vec2(i - 1, j) + hash22(g + vec2(i - 1, j)) - p; // Origin -- Top left.\n            //o1 = vec2(i, j) + hash22(g + vec2(i, j)) - p; // Top right.\n            //o2 = vec2(i, j - 1) + hash22(g + vec2(i, j - 1)) - p; // Bottom right.\n            //o3 = vec2(i - 1, j - 1) + hash22(g + vec2(i - 1, j - 1)) - p; // Bottom left.\n            o = aO[(j+1)*4 + i]; // Origin -- Top left.\n            o1 = aO[(j+1)*4 + i + 1]; // Top right.\n            o2 = aO[j*4 + i + 1]; // Bottom right.\n            o3 = aO[j*4 + i]; // Bottom left.\n\n            \n    \n            // If the point resides in this particular cell's quad, determine which triangle it resides in.\n            if(insideQuad(o, o1, o2, o3)){\n                \n                // Applying the Delaunay rule to the quad: Basically, split the quad along an arbitrary diagonal to form\n                // a triangle. Circumscribe a circle around them, then determine whether the excluded fourth point lies \n                // within the circle. If it does, then flip the diagonal. There's a bit of math and theory behind it, but \n                // thankfully, Tomkh took care of that bit. :)\n                //\n                // By the way, there's no rule that says you need to do it this way -- You could restric the vertice\n                // movement more, then simply flip the diagonal on a random basis. However, the following tends to look \n                // better. Plus, if you wish to put together a Delaunay triangulation for various reasons -- like \n                // constructing the dual Voronoi representation -- this step is necessary.\n                float f = flipDistance(o - o2, o1 - o2, o3 - o2)<0.? 1. : -1.;\n                //\n                // Random. Only works with more restricted vertice movement, and not as nice.\n                //float f = hash21(g + vec2(i , j))>.5? 1. : -1.; \n\n                \n                if(f>0.){ // Diagonal runs from the top right vertex to the bottom left vertex.\n                    \n                     // Determining which side of the diagonal quadrilateral line the point is on. In other words,\n                     // determine which of the two triangles that make up the quad the point is in.\n                     if(sDistLine(o1, o3)>=0.){\n                        o2 = o1; o1 = o; o = o3; // o3, o, o1 triangle.\n                        tri.cID = vec2(0);\n                    }\n                    else {\n                        o = o1; o1 = o2; o2 = o3; // o1, o2, o3 triangle.\n                        tri.cID = vec2(1);\n                    }\n                    \n                }\n                else { // Diagonal runs from the top left vertex to the bottom right vertex.\n                   \n                    // If we have the flipped diagonal arrangement, determine which triangle the point is in.\n                    if(sDistLine(o, o2)>=0.){\n                        o1 = o3; o3 = o; o = o2; o2 = o3; // o2, o3, o triangle.\n                        tri.cID = vec2(2);\n                    }\n                    else {\n                        tri.cID = vec2(3); // o, o1, o2 triangle.\n                    }                  \n                }\n\n                \n                tri.p0 = o; tri.p1 = o1; tri.p2 = o2;\n                tri.id = tri.cID + g + vec2(i - 1, j - 1);\n                \n                // Once we've effectively hit a triangle, break to save further calculations.\n                break;\n                \n            }\n            \n                       \n\t\t}\n\t}\n    \n    // Return the triangle object -- Vertices, IDs, etc.\n    return tri;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Screen coordinates. Note that I've put restrictions on the resolution. I coded this for\n    // the 800 by 450 canvas, so the image looks a little bloated in fullscreen. Therefore, I've\n    // attempted to counter that by restricting is to 800 pixels... It kind of works. :)\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5)/clamp(iResolution.y, 350., 800.);\n    \n    \n    #ifdef FIXED\n    // Basic diagonal scrolling.\n    vec2 p = uv*5. - vec2(2, 1)*iTime/8.;\n    #else \n    // Moving everything down slightly to give the mild impression that the structure is\n    // slowly sliding down a wall... or something. I make this up as I go along. :)\n    vec2 p = uv*5. - vec2(0, -1)*iTime/8.;\n    #endif\n    \n    \n\n    // Perform the triangulation: This function returns the triangle object struct, which consists of the\n    // three triangle vertices, the unique cell ID, and another triangle ID for coloring.\n    triObj tri = triangulate(p);\n    \n    // Use the three triangle vertices to calculate the inner circle center.\n    vec3 inC;\n    inC.xy = inCent(tri.p0, tri.p1, tri.p2); // Inner circle center.\n    inC.z = inCentRad(tri.p0, tri.p1, tri.p2); // Maximum radius to the three sides.\n    \n    // Using the three vertices to calculate the triangle distance value -- which can be used for shading\n    // triangle edge outlines, etc.\n    float d0, d1, d2;\n    d0 = distLine(tri.p0, tri.p1);\n    d1 = distLine(tri.p1, tri.p2);\n    d2 = distLine(tri.p2, tri.p0);\n    float triDist = min(min(d0, d1), d2);\n    \n    \n \n    // Cell color, based on the four triangle arrangements: Top-left, top-right, bottom-left and bottom-right.\n    vec3 cellCol;\n    \n    if(tri.cID.x == 3.) cellCol = vec3(1, 1.3, .6); // Green.\n    else if(tri.cID.x == 2.) cellCol = vec3(1.4, 1, .6); // Orangey brown.\n    else if(tri.cID.x == 1.) cellCol = vec3(.6, 1, 1.4); // Blue.\n    else cellCol = vec3(1.4, .7, .8); // Pinkish red.\n    \n    //if(hash21(tri.id)>.4) cellCol = grey(cellCol);\n    \n    #if PALETTE==0\n    // The less complicated default palette. For amateurs like myself, fewer colors are easier to work with. :)\n    if(tri.cID.x != 3.) cellCol = grey(cellCol); // Greyscale.\n    else cellCol = vec3(1.3, .2, .1); // Redish. //vec3(1.2, .1, .15); //vec3(.8, .28, .05)\n    #elif PALETTE==2\n    if(tri.cID.x == 1. || tri.cID.x == 3.) cellCol = grey(cellCol);\n    #elif PALETTE==3\n    cellCol = grey(cellCol);\n    #endif\n    \n    // The triangle cell background.\n    // Mixing in a bit of the edge color with the cell color to give the impression that some mild lighting \n    // is occurring.\n    vec3 bg = mix(cellCol, vec3(1, .9, .7), .25);\n    // Mutliplying by a factor of the triangular distance for a bit of shading.\n    bg *= (triDist*.7 + .3)*1.55;\n    \n    // Start the layering process by initating to the triangle cell background.\n    vec3 col = bg;\n    \n        \n    // Cell background lines.\n    //col *= clamp(sin((rot2((id).x)*p).x*6.283*20.)*1.5 + 1.35, 0., 1.)*.5 + .5;\n    //col *= clamp(sin((line)*6.283*16.)*1.5 + 1.35, 0., 1.)*.5 + .5;\n    float hatch = clamp(sin((p.y - p.x)*6.283*14.)*1.5 + 1.35, 0., 1.);\n    //float hRnd = hash21(floor(p/5.*240.) + .73);\n    //if(hRnd>.8) hatch = hRnd; // Slight, randomization of the diagonal lines.  \n    col *= hatch*.5 + .5; // Combining the background with the lines.\n\n\n    #ifdef BG_MESH\n    // Finer background layer mesh.\n    // Cover some of the triangle cells with a smaller triangulated mesh. Because of the layering order,\n    // it gives the impression that the mesh is behind the top layer, which in turn gives the image\n    // some faux depth. Comment this block out for a cleaner, but less interesting, look.\n\tif(tri.cID.x != 3. && hash21(tri.id)>.5){ // if(hash21(id).x>.5), etc.    \n         \n        const float scF = 2.5; // Second mesh scaling factor.\n        triObj tri2 = triangulate(p*scF);\n\n        float point2 = min(min(length(tri2.p0/2.5), length(tri2.p1/2.5)), length(tri2.p2/2.5)) - .04;\n        vec3 inC2;\n        inC2.xy = inCent(tri2.p0, tri2.p1, tri2.p2);\n\n        d0 = (distLine(tri2.p0, tri2.p1));\n        d1 = (distLine(tri2.p1, tri2.p2));\n        d2 = (distLine(tri2.p2, tri2.p0));\n        float triDist2 = min(min(d0, d1), d2)/scF - .015;\n\n        // Triangle borders.\n        col = mix(col, vec3(0), (1. - smoothstep(0., .1, triDist2))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., .015, triDist2 - .02));\n        vec3 lCol2 = vec3(1, .85, .4)*.8;\n        #ifdef GREY_LINES\n        lCol2 = grey(lCol2);\n        #endif\n        col = mix(col, lCol2, 1. - smoothstep(0., .015, triDist2));\n\n\t\t// Vertices.\n        col = mix(col, vec3(0), 1. - smoothstep(0., .01, point2 - .02));        \n        col = mix(col, vec3(1, .9, .7), 1. - smoothstep(0., .01, point2));\n\t}\n    #endif\n    \n\n    #ifdef INCIRCLES\n    // Inner circles.\n    //if(hash21(tri.id)>.35){ // Leave some cells empty.\n    vec2 a = inC.xy;\n    // Polar lines around the circle edges.\n    float dir = (tri.cID.x==0. || tri.cID.x==2.)? -1. : 1.;\n    float ang = mod(atan(a.y, a.x) + dir*iTime/2., 3.14159*2.);\n    float hLines = clamp(sin(ang*(floor((inC.z - .055)*69.) + 3.))*1.5 + 1.35, 0., 1.)*.7 + .3;\n    // Innercircle.\n    float inPoint = length(inC.xy) - inC.z + .055;\n    col = mix(col, vec3(0), (1. - smoothstep(0., .1, inPoint - .0))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, inPoint - .02));\n    vec3 iC = cellCol*max(1. - length(inC.xy)/inC.z*.7, 0.);\n    //iC *= clamp(cos(length(inC.xy)*6.283*16.)*1. + .85, 0., 1.)*.15 + .85; // Subtle concentric pattern.\n\tcol = mix(col, mix(vec3(1, .9, .7), iC, .4)*hLines, 1. - smoothstep(0., .01, inPoint));\n    col = mix(col, vec3(0), (1. - smoothstep(0., .01, inPoint - .02 + .08))*.9);\n    col = mix(col, iC, 1. - smoothstep(0., .01, inPoint + .08));\n    // Innercircle points.\n    inPoint = length(inC.xy) - .025;\n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, inPoint - .02));\n\tcol = mix(col, mix(vec3(1, .9, .7), cellCol, .25), 1. - smoothstep(0., .01, inPoint));\n\t//} \n    #endif\n    \n    \n   \n    \n    // Triangle borders.\n    vec3 lCol = vec3(1, .8, .3);//*min(.8 + triDist*16., 1.); // Line color.\n    #ifdef GREY_LINES \n    lCol = grey(lCol);\n    #endif\n    triDist -= .0175;\n    col = mix(col, vec3(0), (1. - smoothstep(0., .1, triDist))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., .015, triDist - .02));\n    col = mix(col, lCol, 1. - smoothstep(0., .015, triDist));//vec3(1, .8, .25)\n\n    //col = mix(col, (vec3(0)), (1. - smoothstep(0., .01, triDist + .02))*.35);\n\n    \n    \n    // Triangle vertices.\n    float verts = min(min(length(tri.p0), length(tri.p1)), length(tri.p2)) - .06;\n    col = mix(col, vec3(0), (1. - smoothstep(0., .1, verts))*.35);\n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, verts - .02));\n\tcol = mix(col, vec3(1, .9, .7), 1. - smoothstep(0., .01, verts));\n    verts += .05;\n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, verts - .02));\n\tcol = mix(col, vec3(1, .9, .7), 1. - smoothstep(0., .01, verts)); \n\n \n    #ifdef SHOW_GRID_CELLS\n    // Cell borders: If you take a look at the triangles overlapping any individual square cell, \n    // you'll see that several partial triangles contribute, and the vertices that make up each \n    // triangle span the 8 surrounding cells. This is the reason why you have to test for\n    // contributing triangle intersections from all 9 cells.\n    vec2 q = abs(fract(p) - .5);\n    float bord = max(q.x, q.y) - .5;\n    bord = max(bord, -(bord + .01));\n    \n    col = mix(col, vec3(0), (1. - smoothstep(0., .1, bord))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., .01, bord - .02)));\n    col = mix(col, vec3(1), (1. - smoothstep(0., .01, bord))*.75);\n    #endif\n       \n    \n    // Vignette.\n    uv = fragCoord/iResolution.xy;\n    col = mix(col, vec3(0), (1. - pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.125*.5)));\n\n    \n    // Rough gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdycDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3632, 3784, 3805, 3805, 3871], [3874, 3888, 3908, 3908, 3959], [3962, 3984, 4005, 4354, 4669], [4672, 4694, 4716, 5065, 5123], [5126, 5262, 5301, 5327, 5460], [5462, 5591, 5634, 5656, 5867], [5871, 6109, 6142, 6142, 6251], [6253, 6310, 6341, 6341, 6531], [6533, 7108, 7155, 7194, 7623], [8290, 8290, 8329, 8329, 8357], [8359, 8934, 8994, 8994, 9611], [9843, 10231, 10261, 10413, 16168], [16171, 16171, 16225, 16507, 24156]], "test": "ok"}
{"id": "MdycRK", "name": "Tesla's Tower", "author": "dr2", "description": "Repurposing the Wardenclyffe Tower to receive rather than transmit energy (mouseable)", "tags": ["tower", "lightning", "frame", "structure"], "likes": 4, "viewed": 412, "published": "Public API", "date": "1522588919", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Tesla's Tower\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm1 (float p);\nfloat Fbm2p (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define AA   0   // optional antialiasing (0/1 - off/on)\n\nvec4 pth[4];\nvec3 sunDir, qHit;\nfloat illum[4], tCur, dstFar;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat SparkDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  dMin *= 2.;\n  for (int k = 0; k < 4; k ++) {\n    if (illum[k] > 0.) {\n      q = p;\n      q.xz = Rot2D (q.xz, (0.5 + float (k)) * 0.5 * pi + 0.1 * tCur);\n      q.y -= 10. + 0.2 * Fbm1 (5. * tCur);\n      q.z += 3.;\n      q.yz = Rot2D (q.yz, -0.25 * pi);\n      q.z += 16.;\n      d = PrCylDf (q, 0.9, 20.);\n      if (d < dMin) {\n        q.xy -= (1. - smoothstep (19., 19.5, q.z)) * (2. * vec2 (Fbm2p (vec2 (0.4 * q.z, 0.) +\n           pth[k].xy), Fbm2p (vec2 (0.3 * q.z, 0.) + pth[k].zw)) - 1.);\n        d = PrCylDf (q, 0.02, 20.);\n        DMINQ (7);\n      }\n    }\n  }\n  return 0.5 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  vec2 b;\n  float dMin, d, r, w, ww;\n  dMin = dstFar;\n  p.y -= 5.36;\n  r = length (p.xz);\n  qq = p;\n  qq.xz = Rot2D (qq.xz, 2. * pi * (floor (16. * ((r > 0.) ?\n     atan (qq.z, - qq.x) / (2. * pi) : 0.) + 0.5) / 16.));\n  q = qq;\n  w = (0.5 - q.y / 10.);\n  ww = (1. + w * w);\n  q.x += 1.6 * ww;\n  q.y = mod (q.y, 1.) - 0.5;\n  d = PrBox2Df (q.xy, vec2 (0.05 * ww, 0.5));\n  b = abs (q.yz) - vec2 (0.45, 0.265 * ww);\n  d = max (max (d, - max (min (max (b.x, b.y), 0.), max (0.1 * (1. + 0.1 * ww) - length (q.yz),\n     0.07 - abs ((1.85 - w) * abs (b.y) - abs (b.x))))), abs (qq.y) - 5.05);\n  DMINQ (1);\n  d = PrCylDf (q.yzx, 0.02, 0.06 * ww);\n  q.yz = abs (q.yz) - vec2 (0.46, 0.27 * ww);\n  d = max (min (d, PrCylDf (q.yzx, 0.02, 0.06 * ww)), abs (qq.y) - 5.05);\n  DMINQ (2);\n  dMin *= 0.6;\n  q = p;\n  q.y -= 5.1;\n  d = PrCylAnDf (q.xzy, 1.7, 0.2, 0.05);\n  q.y = abs (q.y - 0.45) - 0.15;\n  d = min (d, PrTorusDf (q.xzy, 0.03, 1.85));\n  DMINQ (3);\n  q = qq;\n  q.xy -= vec2 (-1.85, 5.4);\n  d = PrCylDf (q.xzy, 0.03, 0.3);\n  DMINQ (3);\n  q = p;\n  q.y -= 7.;\n  d = PrSphDf (q, 1.);\n  DMINQ (4);\n  qq = p;\n  qq.xz = Rot2D (qq.xz, pi / 16.);\n  qq.xz = Rot2D (qq.xz, 2. * pi * (floor (16. * ((r > 0.) ?\n     atan (qq.z, - qq.x) / (2. * pi) : 0.) + 0.5) / 16.));\n  q = qq;\n  q.xy -= vec2 (-3.3, -5.2);\n  d = PrCylDf (q.xzy,  0.25, 0.15);\n  DMINQ (6);\n  q = p;\n  q.y -= 0.65;\n  d = PrCylDf (q.xzy, 0.1 + 0.02 * abs (sin (6. * pi * q.y)), 6.);\n  DMINQ (5);\n  q = qq;\n  q.y -= 7.7;\n  q.xy = Rot2D (q.xy, -0.33 * pi);\n  q.x += 1.5;\n  d = PrCylDf (q.yzx, 0.04 + 0.01 * abs (sin (12. * pi * q.x)), 1.5);\n  DMINQ (5);\n  dMin = SparkDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 CloudNf (vec3 p, float d)\n{\n  vec2 s, e;\n  e = vec2 (0.0005 * d, 0.);\n  s = p.xz + 0.03 * tCur;\n  return normalize (vec3 (0.1 * (Fbm2p (s) - vec2 (Fbm2p (s + e.xy), Fbm2p (s + e.yx))), e.x).xzy);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float d;\n  if (rd.y < 0.) { \n    ro += (- ro.y / rd.y) * rd;\n    col = 0.5 * mix (vec3 (0.35, 0.4, 0.2), vec3 (0.4, 0.45, 0.1),\n       smoothstep (0.3, 0.7, Fbm2p (ro.xz)));\n    vn = VaryNf (ro, vec3 (0., 1., 0.), 2.);\n    col = col * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) * (0.7 + 0.3 * smoothstep (3.5, 4., length (ro.xz)));\n   } else {\n    d = (30. - ro.y) / max (rd.y, 0.001);\n    ro += d * rd;\n    vn = mix (vec3 (0., 1., 0.), CloudNf (0.02 * ro, d), smoothstep (0., 0.3, rd.y));\n    col = vec3 (1.) * (0.3 + 0.7 * Fbm2p (0.01 * ro.zx)) * (0.2 + 0.8 * max (dot (rd, vn), 0.));\n    col += vec3 (0.1, 0.1, 0.05) * Fbm1 (4. * tCur) * smoothstep (0., 0.3, rd.y);\n  }\n  col = mix (vec3 (0.14), col, smoothstep (0., 0.1, abs (rd.y)));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, illTot, f, t, r, c, ae;\n  illTot = 0.;\n  for (int k = 0; k < 4; k ++) {\n    f = 0.1 * float (k);\n    t = 0.2 * tCur;\n    pth[k] = vec4 (4. + f - (10. + 3. * f) * t + (0.8 - f) * sin ((0.1 + 0.1 * f) * t),\n       sin ((0.11 + 0.1 * f) * t) + (0.3 + 0.2 * f) * sin ((0.17 + 0.5 * f) * t),\n       5. + 2. * f - (12. - 2. * f) * t + (0.5 + 0.3 * f) * sin ((0.15 - 0.2 * f) * t),\n       sin ((0.12 - 0.1 * f) * t) + (0.4 - 0.2 * f) * sin ((0.12 + 0.2 * f) * t));\n    illum[k] = step (0.5, Fbm1 (4. * tCur + 100. * f));\n    illTot += 0.25 * illum[k];\n  }\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 7) {\n      col = vec3 (0.9, 0.9, 0.6) * clamp (1.3 - 0.3 * Fbm1 (5. * qHit.z), 0., 1.) *\n         (0.2 + 1.3 * max (0.3 - dot (rd, vn), 0.));\n    } else {\n      r = length (ro.xz);\n      if (idObj == 1) {\n        col = mix (vec3 (0.8, 0.8, 0.9), vec3 (0.9, 0.9, 0.3),\n           step (dot (normalize (vn.xz), normalize (ro.xz)), -0.9)) * (0.8 + 0.2 * Fbm3 (16. * ro));\n      } else if (idObj == 2) {\n        col = vec3 (0.3, 0.7, 0.3);\n      } else if (idObj == 3) {\n        col = vec3 (0.7, 0.5, 0.2) * (0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.03, mod (9. * r, 1.)));\n      } else if (idObj == 4) {\n        ae = asin (ro.y / length (ro)) / (0.5 * pi);\n        c = cos (0.5 * pi * ae);\n        col = vec3 (0.2, 0.2, 0.5) * (1. + illTot) * (1. - 0.2 * max (SmoothBump (0.5 - c, 0.5 + c,\n           0.5 * c, mod (6. * ro.y, 1.)), (1. - smoothstep (0.99, 0.995, abs (ae))) *\n           SmoothBump (0.5 - 0.005 / c, 0.5 + 0.005 / c, 0.5 * 0.005 / c,\n           mod (16. * ((r > 0.) ? atan (ro.z, - ro.x) / (2. * pi) : 0.), 1.))));\n      } else if (idObj == 5) {\n         col = vec3 (0.7, 0.4, 0.2) * (0.7 + 0.3 * illTot * step (r, 0.15));\n      } else if (idObj == 6) {\n        col = vec3 (0.4, 0.2, 0.1);\n      }\n      col = col * (0.3 + 0.7 * max (dot (vn, sunDir), 0.)) * (0.8 + 0.2 * illTot) +\n         0.05 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    }\n  } else col = BgCol (ro, rd) * (0.7 + 0.3 * illTot);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvd, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.03 * pi;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += 0.45 * pi * mPtr.y;\n  } else {\n    az = 2. * pi * (2. * mod (floor (0.01 * tCur), 2.) - 1.) *\n       SmoothBump (0.25, 0.75, 0.24, mod (0.01 * tCur, 1.));\n    el -= 0.17 * pi * sin (0.02 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 6., -40.);\n  if (ro.y < 1.) {\n    ro.y = 1.;\n    ro.xz *= sqrt (1635.) / length (ro.xz);\n  }\n  zmFac = 7. - 3. * cos (2. * az);\n  dstFar = 200.;\n  sunDir = vuMat * normalize (vec3 (0.5, 2., -1.));\n\n  #if ! AA\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ShowScene (ro, rd);\n#else\n  col = vec3 (0.);\n  for (int iy = 0; iy <= 1; iy ++) {\n    for (int ix = 0; ix <= 1; ix ++) {\n      uvd = (0.5 / canvas.y) * (2. * vec2 (float (ix), float (iy)) - 1.);\n      rd = vuMat * normalize (vec3 (uv + uvd, zmFac));\n      col += ShowScene (ro, rd);\n    }\n  }\n  col *= 0.25;\n#endif\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2p (vec2 p)\n{\n  float f, a, s;\n  f = 0.;\n  s = 0.;\n  a = 1.;\n  for (int j = 0; j < 4; j ++) {\n    f += a * Noisefv2 (p);\n    s += a;\n    a *= 1./2.5;\n    p *= 2.5;\n  }\n  return f / s;\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdycRK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[749, 749, 785, 785, 1396], [1398, 1398, 1420, 1420, 3078], [3080, 3080, 3113, 3113, 3290], [3292, 3292, 3313, 3313, 3513], [3515, 3515, 3547, 3547, 3717], [3719, 3719, 3750, 3750, 4521], [4523, 4523, 4558, 4558, 6707], [6709, 6709, 6765, 6765, 8153], [8155, 8155, 8188, 8188, 8277], [8279, 8279, 8312, 8312, 8339], [8341, 8341, 8383, 8383, 8434], [8436, 8436, 8489, 8489, 8550], [8552, 8552, 8598, 8598, 8655], [8657, 8657, 8714, 8714, 8797], [8799, 8799, 8829, 8829, 8887], [8921, 8921, 8945, 8945, 8998], [9000, 9000, 9024, 9024, 9154], [9156, 9156, 9180, 9180, 9400], [9402, 9402, 9427, 9427, 9573], [9575, 9575, 9600, 9600, 9786], [9788, 9788, 9813, 9813, 10038], [10040, 10040, 10062, 10062, 10216], [10218, 10218, 10240, 10240, 10412], [10414, 10414, 10435, 10435, 10590], [10592, 10592, 10621, 10621, 10833], [10835, 10835, 10874, 10874, 11054]], "test": "error"}
{"id": "Mdyczt", "name": "Fusion spiral", "author": "bozhkov", "description": "experimenting with transformations", "tags": ["2d", "pulse", "spiral", "circle"], "likes": 3, "viewed": 247, "published": "Public", "date": "1522934103", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec2 rotate2D (vec2 _st, float _angle) {\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tvec3 color = hsb2rgb(vec3(fract(iTime*.1),.5,1.2));\n    float r = length(p)*1.;\n    float w = 1.5;\n    float t = sin(r*2.8+iTime*PI*1.)*4.5;\n    p *= t;\n    p = rotate2D(p,(r*PI*2.8-iTime*1.));\n    color *= smoothstep(-w,.0,p.x)*smoothstep(w,.0,p.x);\n    color *= distance(vec2(0.), vec2(cos(r*4.+iTime*PI*1.)));\n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mdyczt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 52, 52, 285], [287, 287, 327, 327, 435], [437, 437, 494, 494, 902]], "test": "ok"}
{"id": "MdyyRK", "name": "Mandelbrot Mania", "author": "nightfox", "description": "Today is the day I understood the Mandelbrot set. Thanks to The Art of Code on YouTube.", "tags": ["fractal", "mandelbrot"], "likes": 1, "viewed": 362, "published": "Public API", "date": "1522583819", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= .4;\n    uv *= 2.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv *= 1.+sin(-iTime/10.);\n    float it = 0.;\n    \n    uv.x -= .745;\n    uv.y += .1;\n    \n    const int MAX_STEPS = 1000;\n    \n    vec2 c = uv;\n    vec2 z = c;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        float x = pow(z.x, 2.) - pow(z.y, 2.);\n        float y = 2. * z.x * z.y;\n     \tz = vec2(x, y) + c;\n            \n        if (length(z) > 2.) break;\n        it++;\n    }\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.5 + 0.5*cos(iTime+it));\n    col.g = 1.-sin(it);\n    col.b = cos(it);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdyyRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 789]], "test": "ok"}
{"id": "MdyyzD", "name": "gravity_field_3d", "author": "Crackhausen", "description": "Simplified 'gravity field 2'.\nUse mouse.x to change coloring. ", "tags": ["field", "gravity"], "likes": 1, "viewed": 2178, "published": "Public API", "date": "1523510175", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"gravity_field_3\" by tholzer. https://shadertoy.com/view/lsGcRD\n// 2018-03-16 11:43:38\n\n//----------- gravity_field_3 ---------------\n\n// simplified https://www.shadertoy.com/view/4slSWN\n\n#define POINTS 20  \t\t // number of stars\n\n#define t iTime\n\nfloat hash (float i) { return 3.*fract(sin(i*7467.25)*1e5) - 1.; }\n//vec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\n\t\n\nvec2 P (int i)  // position of point[i]\n{\n  vec4 c = hash4(float(i));\n  return vec2( cos(t*c.x-c.z) +0.15*cos(2.765*t*c.y+c.w),\n\t\t\t ( sin(t*c.y+c.w) +0.5*sin(1.893*t*c.x+c.z)) / 1.5);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 R = iResolution.xy;\n  vec2 uv = (2.*fragCoord - R*1.7) / R.y;\n  vec2 mp = iMouse.xy / R;\n    \n  float my = 0.5*pow(.5*(1.-cos(1.1*t)),3.0);\n  float fMODE = (1.0-cos(3.1415*mp.x))-sin(iMouse.x/t);\n\n  vec2 V = vec2(0.1);\n  for (int i=1; i<POINTS; i++)\n  {\t\n    vec2 d = P(i) - uv;  // distance point->pixel\n\tV +=  d / dot(d,1.5-d);  // gravity force field\n  }\n  float c = (length(V)* 1./(23.*float(POINTS)))*(2.+210.*fMODE);\n  int MODE = int(3.*mp.x);\n  if (MODE==0) fragColor = vec4(0.2*c)+smoothstep(.05,.04,abs(c-5.*my))*vec4(1,0,0,0);\n  if (MODE==1) fragColor = vec4(.5+.5*sin(2.*c));\n  if (MODE==2) fragColor = vec4(sin(c),sin(c+2.),sin(c/4.),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdyyzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[258, 258, 280, 280, 324], [325, 385, 407, 407, 464], [468, 468, 509, 509, 653], [655, 655, 711, 711, 1371]], "test": "ok"}
{"id": "Ms3Bz8", "name": "Subspace selection", "author": "darkeclipz", "description": "testing to draw different scenes and show the selected subspace with the mouse.", "tags": ["testing"], "likes": 3, "viewed": 97, "published": "Public", "date": "1524002283", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code is a mess.\n\n// http://www.iquilezles.org/apps/graphtoy/\n#define SCALE 3.0\n#define GRID_THICKNESS 5.0 * SCALE\n#define MOUSE_CURSOR_SIZE 0.01 * SCALE\n\nfloat anim(float t) { return (-cos(t)+1.0)/2.0; }\n\n// (0, 0)\nvec3 window0(vec2 uv, float t) {\n\tfloat d = length(uv - vec2(0.5, 0.5));\n    return vec3(1.0-d) * 1.5;\n}\n\n// (1,0)\nvec3 window1(vec2 uv, float t) {\n\tfloat d = length(uv - vec2(0.5, 0.5));\n    return vec3(1.0-d) * 1.5 + 0.5 * anim(t);\n}\n\n// (0,1)\nvec3 window2(vec2 uv, float t) {\n    float size = anim(t) / 2.0;\n\tfloat box = float((uv.x > size && uv.x < 1.0-size) && (uv.y > size && uv.y < 1.0-size));\n    return vec3(box);\n}\n\n// (1,1)\nvec3 window3(vec2 uv, float t) {\n    t = pow(anim(t), 2.0);\n    float size = t / 2.0;\n\tfloat box = float((uv.x > size && uv.x < 1.0-size) && (uv.y > size && uv.y < 1.0-size));\n    return vec3(box);\n}\n\n// (2,1)\nvec3 window4(vec2 uv, float t) {\n    t = sqrt(anim(t));\n    float size = t / 2.0;\n\tfloat box = float((uv.x > size && uv.x < 1.0-size) && (uv.y > size && uv.y < 1.0-size));\n    return vec3(box);\n}\n\n// (0,2)\nvec3 window5(vec2 uv, float t) {\n    //t = sqrt(anim(t));\n\tfloat box = length(vec2(anim(t)) - uv) < 0.5 ? 1.0 : 0.0;\n    return vec3(box);\n}\n\n// (1,2)\nvec3 window6(vec2 uv, float t) {\n    //t = sqrt(anim(t));\n\tfloat box = length(vec2(0.5) - uv) < fract(pow(anim(t), 0.3)) / 2.0 ? 1.0 : 0.0;\n    return vec3(box);\n}\n\n// (2,2)\nvec3 window7(vec2 uv, float t) {\n    //t = sqrt(anim(t));\n\tfloat box = length(vec2(0.5) - uv) < (fract(anim(t)) + fract(6.0*anim(t)) / 6.0) / 2.35 ? 1.0 : 0.0;\n    return vec3(box);\n}\n\n// (3,2)\nvec3 window8(vec2 uv, float t) {\n    //t = sqrt(anim(t));\n\tfloat box = length(vec2(0.5) - uv) < (fract(8.0*anim(t)) * pow(anim(t), 1.2) + anim(t)) / 4.0 ? 1.0 : 0.0;\n    return vec3(box);\n}\n\n// (0,3)\nvec3 window9(vec2 uv, float t) {\n    float d = length(uv - vec2(0.5, 0.5)) * 2.0;\n    float vary = 0.1 * anim(t);\n    d = smoothstep(0.3, 0.4+vary, d)-smoothstep(0.6,0.9-vary,d);\n    return vec3(d) * anim(t) * 1.618;\n}\n\n// (3,1)\nvec3 window10(vec2 uv, float t) {\n    float tau = 3.14159265359*2.;\n    float speed = 0.125;\n    mat2 m = mat2(cos(fract(t*speed)*tau), -sin(fract(t*speed)*tau), sin(fract(t*speed)*tau), cos(fract(t*speed)*tau));\n    uv -= vec2(0.5);\n    uv = m * uv;\n    uv += vec2(0.5);\n\tfloat box = float((uv.x > 0.2 && uv.x < 0.8) && (uv.y > 0.2 && uv.y < 0.8));\n    return vec3(box);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 norm = vec2(iResolution.y);\n    vec2 uv = fragCoord / norm * SCALE;\n    vec2 mouse = iMouse.xy / norm * SCALE;\n    float t = iTime;\n    \n    // Used to create subspaces.\n\tvec2 ipart, fpart; \n    fpart = modf(uv, ipart);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(t+fpart.xyx+vec3(0,2,4));\n\n    // Mouse cursor\n    if( length(uv - mouse.xy) < MOUSE_CURSOR_SIZE ) \n        col = mix(col, vec3(1), 0.618); \n    \n    // Selected cell\n    if((mouse.x > ipart.x && mouse.x < ipart.x + 1.0)\n       && (mouse.y > ipart.y && mouse.y < ipart.y + 1.0)) \n        col = mix(col, vec3(1.0), 0.5);\n    \n    // Window selection\n    if(ipart.x == 0.0 && ipart.y == 0.0) col = mix(col, window0(fpart, t), 0.5); // window0\n    if(ipart.x == 4.0 && ipart.y == 0.0) col = mix(col, window7(fpart, t), 0.5); // window1\n    if(ipart.x == 0.0 && ipart.y == 1.0) col = mix(col, window5(fpart, t), 0.5); // window2\n    if(ipart.x == 1.0 && ipart.y == 1.0) col = mix(col, window9(fpart, t), 0.5); // window3\n    if(ipart.x == 2.0 && ipart.y == 1.0) col = mix(col, window4(fpart, t), 0.5); // window4\n    if(ipart.x == 0.0 && ipart.y == 2.0) col = mix(col, window2(fpart, t), 0.5); // window5\n    if(ipart.x == 1.0 && ipart.y == 2.0) col = mix(col, window6(fpart, t), 0.5); // window6\n    if(ipart.x == 4.0 && ipart.y == 1.0) col = mix(col, window1(fpart, t), 0.5); // window7\n    if(ipart.x == 3.0 && ipart.y == 2.0) col = mix(col, window8(fpart, t), 0.5); // window8\n    if(ipart.x == 2.0 && ipart.y == 0.0) col = mix(col, window3(fpart, t), 0.5); // window9\n    if(ipart.x == 3.0 && ipart.y == 1.0) col = mix(col, window10(fpart, t), 0.5); // window10\n    \n    // Gridlines\n\t//float epsilon = 0.000001; // To remove flickering gridlines (why does this work??).\n    //float dx = (1.0 / iResolution.x) * iResolution.x / iResolution.y + epsilon;\n    //float dy = 1.0 / iResolution.y + epsilon;\n    //if(fpart.x < dx * GRID_THICKNESS || fpart.y < dy * GRID_THICKNESS ) \n    //    col = mix(col, vec3(0), 1.0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3Bz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 178, 178, 206], [208, 218, 250, 250, 322], [324, 333, 365, 365, 453], [455, 464, 496, 496, 642], [644, 653, 685, 685, 852], [854, 863, 895, 895, 1058], [1060, 1069, 1101, 1126, 1209], [1211, 1220, 1252, 1277, 1383], [1385, 1394, 1426, 1451, 1577], [1579, 1588, 1620, 1645, 1777], [1779, 1788, 1820, 1820, 2006], [2008, 2017, 2050, 2050, 2390], [2392, 2392, 2449, 2499, 4573]], "test": "error"}
{"id": "Ms3BzH", "name": "Tentacle Tunnel", "author": "ChloeSnyder", "description": "OwO what's this", "tags": ["m"], "likes": 4, "viewed": 123, "published": "Public", "date": "1524084311", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define deg2rad PI / 180.0\n\n// RAY MARCHING CODE SOURCE JAMIE WONG\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\nconst float EPSILON_NORM = .001;\n\nconst vec3 A = vec3(-3.142, -3.142, .618);\nconst vec3 B = vec3(-3.142, -3.142,-.362);\nconst vec3 C = vec3(-3.142, -3.142, 2.0);\nconst vec3 D = vec3(-3.142, -3.142, -3.142);\n\nvec3 K_d = vec3(-1, -1, -1); // diffuse color\nfloat shininess;\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat noise( in vec2 x )\n{\n\treturn sin(1.5*x.x)*sin(1.5*x.y);\n}\n\n\nfloat noise2(vec3 x)\n{\n        return fract(sin(dot(x.xy,\n                         vec2(12.9898,78.233)))\n                * 43758.5453123);\n}\n\nvec2 rot(vec2 r, float a) {\n\treturn vec2(\n\t\tcos(a) * r.x - sin(a) * r.y,\n\t\tsin(a) * r.x + cos(a) * r.y);\n}\n\n\n\n\n//https://github.com/BrianSharpe/GPU-Noise-Lib/blob/master/gpu_noise_lib.glsl\nvec4 FAST32_hash_3D_Cell( vec3 gridcell )\t//\tgenerates 4 different random numbers for the single given cell point\n{\n    //    gridcell is assumed to be an integer coordinate\n\n    //\tTODO: \tthese constants need tweaked to find the best possible noise.\n    //\t\t\tprobably requires some kind of brute force computational searching or something....\n    const vec2 OFFSET = vec2( 50.0, 161.0 );\n    const float DOMAIN = 69.0;\n    const vec4 SOMELARGEFLOATS = vec4( 635.298681, 682.357502, 668.926525, 588.255119 );\n    const vec4 ZINC = vec4( 48.500388, 65.294118, 63.934599, 63.279683 );\n\n    //\ttruncate the domain\n    gridcell.xyz = gridcell - floor(gridcell * ( 1.0 / DOMAIN )) * DOMAIN;\n    gridcell.xy += OFFSET.xy;\n    gridcell.xy *= gridcell.xy;\n    return fract( ( gridcell.x * gridcell.y ) * ( 1.0 / ( SOMELARGEFLOATS + gridcell.zzzz * ZINC ) ) );\n}\n\n//https://github.com/BrianSharpe/GPU-Noise-Lib/blob/master/gpu_noise_lib.glsl\nfloat Falloff_Xsq_C2( float xsq ) { xsq = 1.0 - xsq; return xsq*xsq*xsq; }\n\n//https://github.com/BrianSharpe/GPU-Noise-Lib/blob/master/gpu_noise_lib.glsl\nfloat PolkaDot3D( \tvec3 P,\n                    float radius_low,\t\t\n                    float radius_high\t)\n{\n    //\testablish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n\n    //\tcalculate the hash.\n    vec4 hash = FAST32_hash_3D_Cell( Pi );\n\n    //\tuser variables\n    float RADIUS = max( 0.0, radius_low + hash.w * ( radius_high - radius_low ) );\n    float VALUE = RADIUS / max( radius_high, radius_low );\t//\tnew keep value in proportion to radius.  Behaves better when used for bumpmapping, distortion and displacement\n\n    //\tcalc the noise and return\n    RADIUS = 2.0/RADIUS;\n    Pf *= RADIUS;\n    Pf -= ( RADIUS - 1.0 );\n    Pf += hash.xyz * ( RADIUS - 2.0 );\n    //Pf *= Pf;\t\t//\tthis gives us a cool box looking effect\n    return Falloff_Xsq_C2( min( dot( Pf, Pf ), 1.0 ) ) * VALUE;\n}\n\n\n/**\n * Rotation matrix around the X axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// modified from jamie wong\nvec3 scaleOp(vec3 samplePoint, vec3 scale)\n{\n\treturn (samplePoint / scale) * min(scale.x, min(scale.y, scale.z));\n}\n\n//JW\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n//JW\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n//JW\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n// iq\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//iq\nfloat smin2( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n\n// iq\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n//iq\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n// iq\nfloat cylinderSDF( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//http://glslsandbox.com/e#40928.0\nfloat saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\n\n// Based off: //http://glslsandbox.com/e#40928.0\n// Creates the main body of tentacle\nfloat noodle (vec3 p)\n{\n   \n    float scale = 1.0 - 2.5 * saturate( abs( p.y ) * 0.01 );  \n    \n    // sdCapsule, second argument defines lower end point, third is upper end point\n    // p is the point being evaluated, last argument is thickness\n    float cap = sdCapsule(p, vec3( 0.0, -6.0, 0.0 ), vec3( 0.0, 4.0, 0.0 ), 0.3 * scale );\n\t\n    // want more tapering at the end\n    float cone = sdCone(rotateX(-PI/2.0) * p + vec3(0.0, 0.0, -1.0), normalize(vec2(1.5, .30)));\n    //return cone;\n    return smin(cone, cap, -.5);\n}\n\nfloat suctionCup(vec3 p, float scale)\n{\n    \n    vec3 cp = rotateX(-PI/2.0) * p;\n    float outer = cylinderSDF(cp, vec2(1.0, .30) / scale);\n    float inner = cylinderSDF(cp, vec2(.25, .5) / scale);\n    \n    float mid = differenceSDF(outer, inner);\n    \n    return mid;\n}\n\n\n\n\n//http://glslsandbox.com/e#40928.0\n// Creates the tentacle by calling noodle and placing suction cups along body of tentacle\nfloat Tentacle( vec3 p )\n{\n    p.x -= sin( p.y * 2.0 + iTime * 7.0 ) * 0.21;\n    \n    float noodle = noodle(p); // The \"main body\" of the tentacle\n    if(noodle < EPSILON)\n    {\n        K_d = vec3(0.0, 0.0, .8);// palette(sin(iTime), A, B, C, D);\n    } \n    \n    float scale = 150.0;\n    p += vec3(0.0, -.70, 0.0);\n    vec3 sc_p1 = p - vec3(0.01, 0.0, 0.03);\n    vec3 sc_p2 = p - vec3(-0.01, 0.0, 0.03);\n    \n    \n    sc_p1 = rotateY(PI/4.0) * sc_p1;\n    sc_p2 = rotateY(-PI/4.0) * sc_p2;\n    float sc1 = suctionCup(sc_p1, scale);\n    float sc2 = suctionCup(sc_p2, scale);\n    float sc = unionSDF(sc1, sc2);\n    if(sc < EPSILON)\n    {\n        K_d = palette(noise(sc_p1.xy), vec3(.5, .5, .5), vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(0.0, .333, .667));\n    }\n    \n    \n    // first six suction cups: start small and scale bigger\n    // as they are placed from the tip towards the base\n    // also, rotate so that they lie \"on\" the surface of the tentacle\n    for(int i = 0; i < 6; i++)\n    {\n        scale /= 1.45;\n        sc_p1 += vec3(-0.00005, .05 * float(i),float(i) * -0.0085);\n        sc_p2 += vec3(0.00005, .05 * float(i),float(i) * -0.0085);\n        sc1 = suctionCup(sc_p1, scale);\n        sc2 = suctionCup(sc_p2, scale);    \n        sc = unionSDF(sc, sc1);\n        sc = unionSDF(sc, sc2);\n        \n        if(sc < EPSILON)\n        {\n            K_d = palette(noise(sc_p1.xy), vec3(.5, .5, .5), vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(0.0, .333, .667));\n        }\n    }\n    \n    sc_p1 = rotateY(-PI/8.0) * sc_p1;\n    sc_p2 = rotateY(PI/8.0) * sc_p2;\n    \n    // Once close enough to the base, can be the same size and rotation\n    for(int j = 6; j < 15; j++)\n    {\n    \n        sc_p1 += vec3(0, .25 , -0.0177);\n        sc_p2 += vec3(0, .25 , -0.0177);\n        sc1 = suctionCup(sc_p1, scale);\n        sc2 = suctionCup(sc_p2, scale);\n        sc = unionSDF(sc, sc1);\n        sc = unionSDF(sc, sc2);\n        if(sc < EPSILON)\n        {\n            K_d = palette(noise(sc_p1.xy), vec3(.5, .5, .5), vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(0.0, .333, .667));\n        }\n    }\n    \n   \n    return smin(noodle, sc, .01);\n  \n}\n\n// modified from iq\nfloat opRep(vec3 p)\n{\n    vec3 q = vec3(p.x + cos(iTime), p.y + sin(iTime), mod(p.z,9.0));\n\n    float scale = 1.0 - 2.5 * saturate( abs( q.y ) * 0.01 );  \n   \tfloat boundingCapsule = sdCapsule(q, vec3( 0.0, -6.0, 0.0 ), vec3( 0.0, 4.0, 0.0 ),  .50 * scale );\n    float tentacle; \n\n    if(boundingCapsule < .001)\n   \t{\n    \ttentacle = Tentacle(q);\n       // K_d += palette(noise(p.yz), vec3(.5, .5, .5), vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(0.0, .333, .667));\n        \n    } else {\n        tentacle = boundingCapsule;\n   \t}\n\n    return tentacle;\n}\n\n\n// Creates the tunnel and maps the tentacles onto it\nfloat map( vec3 p){\n   \n    float tentacleRing = -1.0;\n    float amplitude = 1.9;\n    int numTentacles = 10;\n    float offSet = (noise(.75 * PI * p.xy)/2.0 * sin(3.0 * iTime));\n    float m = cos(p.x) + cos(p.y) + sin(p.z) + offSet;\n\n    if(m < EPSILON)\n    {\n\t\t// coloring the tunnel\n       /* vec3 colorPoint = vec3(cos(p.x) + offSet + p.x + sin(iTime), cos(p.y) + offSet + p.y + iTime, sin(p.z) + offSet + p.z + iTime);\n        float redpt = PolkaDot3D(mod(p, 3.0), .0, .70);\n        vec3 redDots = vec3(2.0 * redpt, 0.0, 0.0);\n        float yellowpt = PolkaDot3D(p, .60, .60);\n        vec3 yellowDots = vec3(2.0 * yellowpt, 2.0 * yellowpt, 0.0);\n\t\t\n        float ptOffY = PolkaDot3D(colorPoint, .5, .5);\n        float ptOffR = PolkaDot3D(mod(colorPoint, 25.0), .5, .5);\n        vec3 redDotsOff = vec3(2.0 * ptOffR, 0.0, 0.0);\n        vec3 yellowDotsOff = vec3(2.0 * ptOffY, 2.0 * ptOffY, 0.0);\n        \n        if(redDots.x > 0.0)\n        {\n            redDots.x = 1.0;\n        }\n        if(redDotsOff.x > 0.0)\n        {\n            redDotsOff.x = 1.0;\n        }\n        if(yellowDots.x > 0.0)\n        {\n            yellowDots.y = 1.0;\n            yellowDots.x = 1.0;\n        }\n        if(yellowDotsOff.x > 0.0)\n        {\n            yellowDotsOff.y = 1.0;\n            yellowDotsOff.x = 1.0;\n        }*/\n        \n        vec3 colorPoint = vec3(cos(p.x) + offSet + p.x + sin(iTime), cos(p.y) + offSet + p.y + iTime, sin(p.z) + offSet + p.z + iTime);\n        float redpt = PolkaDot3D(mod(p, 3.0), .0, .50);\n        vec3 redDots = vec3(redpt, 0.0, 0.0);\n        float yellowpt = PolkaDot3D(p, .30, .5);\n        vec3 yellowDots = vec3(yellowpt, yellowpt, 0.0);\n\t\t\n        float ptOffY = PolkaDot3D(colorPoint + p, .0, .2);\n        float ptOffR = PolkaDot3D(mod(colorPoint, 25.0), .0, .2);\n        vec3 redDotsOff = vec3(ptOffR, 0.0, 0.0);\n        vec3 yellowDotsOff = vec3(ptOffY, ptOffY, 0.0);\n        \n        vec3 blue =  palette(p.z, A, B, C, D);\n        \n        if(redDots.x > 0.0)\n        {\n            redDots.x = 1.0;\n           // K_d = vec3(1.0, 0.0, 0.0);\n             K_d = palette(redpt, vec3(0.478, 1.068, -0.212), vec3(2.238, 1.118, 1.388), vec3(0.108, 0.528, 0.478), vec3(0.907, 1.547, 1.657));\n        }\n        else if(redDotsOff.x > 0.0)\n        {\n            redDotsOff.x = 1.0;\n           // K_d = vec3(1.0, 0.0, 0.0);\n             K_d = palette(ptOffR, vec3(0.478, 1.068, -0.212), vec3(2.238, 1.118, 1.388), vec3(0.108, 0.528, 0.478), vec3(0.000, 0.478, 0.478));\n        }\n         else if(yellowDots.x > 0.0)\n        {\n            yellowDots.y = 1.0;\n            yellowDots.x = 1.0;\n            K_d =  palette(-yellowpt, vec3(.5, .5, .0), vec3(.5, .5, .0), vec3(.10, .50, .0), vec3(0.0, .0, .0));\n        }\n        else if(yellowDotsOff.x > 0.0)\n        {\n            yellowDotsOff.y = 1.0;\n            yellowDotsOff.x = 1.0;\n            K_d = vec3(1.0, 1.0, 0.0);\n        } else {\n\t\t\tK_d = yellowDots + redDots + redDotsOff + yellowDotsOff + vec3(0, 0, blue.z);      \n        }\n        \n    }\n    float gap = 360.0 / float(numTentacles) * deg2rad;\n    \n    for(int i = 0; i < numTentacles; i++)\n    {\n\n       \tfloat angle = float(i) * gap;     \n             \n        float offsetX = (amplitude) * sin(angle);\n    \tfloat offsetY = (amplitude) * cos(angle);\n        \n        vec3 localP = p;\n        localP += vec3(offsetX, offsetY, 0.0);\n        localP = rotateZ(-angle) * localP;\n        \n        \n        float tentacle = opRep(localP);\n        \n        if(tentacleRing == -1.0)\n        {\n            tentacleRing = tentacle;\n        }\n      \n        tentacle = unionSDF(tentacle, m); //smin(tentacle, m, .1);\n        tentacleRing = unionSDF(tentacle, tentacleRing);\n\n    }\n    \n    \n             \n    return tentacleRing;//smin2(tentacleRing, m, 4.0);\n    \n}\n\n  \nfloat sceneSDF(vec3 samplePoint) {\n    \n    float sdf = map(samplePoint);\n     return sdf;\n\n  \n}\n\n\n/** JW\n * \n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/** JW\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/** JW\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON_NORM, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON_NORM, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON_NORM, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON_NORM, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON_NORM)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON_NORM))\n    ));\n}\n\n\nfloat lambert(vec3 N, vec3 L)\n{\n  vec3 nrmN = normalize(N);\n  vec3 nrmL = normalize(L);\n  float result = dot(nrmN, nrmL);\n  return max(result, 0.0);\n}\n\n\n/** JW\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n//iq\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayOri,   // camera position\n               in vec3  rayDir )  // camera to point vector\n{\n    float b = .1;\n    float c = .1;\n    float fogAmount = c * exp(-rayOri.y*b) * (1.0-exp( -distance*rayDir.y*b ))/rayDir.y;\n    vec3  fogColor  = vec3(01.5,0.6,1.7);\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 2.5 * iTime);\n      \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    \n    worldDir.xy = rot(worldDir.xy, (iTime));\n\n   \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n\n    \n    vec3 color = K_d * lambert(estimateNormal(p), eye);\n    \n    vec3 color_fog = applyFog(color, dist, eye, worldDir);\n    \n    fragColor = vec4(color_fog, 1.0);\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3BzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[491, 491, 563, 563, 606], [608, 608, 634, 634, 671], [674, 674, 696, 696, 815], [817, 817, 844, 844, 923], [928, 1006, 1121, 1349, 1859], [1861, 1939, 1974, 1974, 2013], [2015, 2093, 2201, 2250, 2916], [2919, 3003, 3030, 3030, 3177], [3179, 3263, 3290, 3290, 3437], [3439, 3523, 3550, 3550, 3697], [3699, 3727, 3771, 3771, 3842], [3844, 3849, 3895, 3895, 3927], [3929, 3934, 3976, 3976, 4008], [4010, 4015, 4062, 4062, 4095], [4097, 4103, 4144, 4144, 4237], [4239, 4244, 4286, 4286, 4357], [4360, 4366, 4418, 4418, 4545], [4547, 4552, 4584, 4612, 4673], [4675, 4681, 4718, 4718, 4817], [4819, 4854, 4881, 4881, 4916], [4919, 5005, 5028, 5028, 5531], [5533, 5533, 5572, 5572, 5803], [5808, 5933, 5959, 5959, 8074], [8076, 8096, 8117, 8117, 8652], [8655, 8708, 8727, 8727, 12492], [12497, 12497, 12531, 12531, 12593], [12596, 12611, 12702, 12702, 13008], [13023, 13034, 13099, 13099, 13231], [13233, 13325, 13354, 13354, 13694], [13697, 13697, 13728, 13728, 13847], [13850, 14180, 14229, 14264, 14490], [14492, 14497, 14738, 14738, 14951], [14953, 14953, 15010, 15010, 15836]], "test": "timeout"}
{"id": "Ms3BzN", "name": "Vector Phase Space", "author": "fabricatedmath", "description": "Varying vector phase space under a kind of domain coloring", "tags": ["nonlinear", "phasespace"], "likes": 3, "viewed": 663, "published": "Public API", "date": "1524231448", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2018 Charles Durham, 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Stolen hsl2rgb function from https://www.shadertoy.com/view/lsS3Wc\n\n//========================================================================\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 color(in vec2 p)\n{\n    float pi = 3.141593;\n    float theta = atan(p.y,p.x);\n    float h = theta/(2.0*pi);\n    float s = 0.5;\n    float v = 0.6*length(p);\n    vec3 hsv = vec3 (h,s,v);\n    return hsl2rgb(hsv);\n}\n\nvec2 func(in vec3 p)\n{\n    float x = p.x;\n    float y = p.y;\n    float t = p.z;\n    float f = sin(2.0*sin(0.02*t)*y - 3.0*cos(0.03*t)*x)*exp(-abs (sin(0.11*t)*sin (3.0*x+1.0-2.0*y) - sin(0.19*t)*cos(x-3.0*y+1.0)));\n    float g = cos(2.0*sin(0.07*t)*y - 3.0*cos(0.05*t)*x)*exp(-abs (cos(0.13*t)*cos (3.0*x+1.0-2.0*y) - cos(0.17*t)*cos(x-3.0*y+1.0)));\n    return vec2(f,g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Stretch to be between from -4 to 4\n    float h = 4.0;\n    uv = vec2(h*2.0)*uv - vec2(h);\n    \n    //Scale time by 10\n    float t = iTime * 10.0;\n    \n    uv = func(vec3(uv,t));\n\n    vec3 col = color(uv);\n\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3BzN.jpg", "access": "shaders20k", "license": "mit", "functions": [[1247, 1247, 1274, 1274, 1416], [1418, 1418, 1441, 1441, 1633], [1635, 1635, 1657, 1657, 2008], [2010, 2010, 2067, 2117, 2406]], "test": "ok"}
{"id": "Ms3fD8", "name": "Times table and mandelbrot set", "author": "akhgary", "description": "as mentioned in the mathologer video, there is a relation. so  i decided to put them together as well.\n\nafter a lot of experiments, i found the exact circle radius that matches the Mandelbrot set for positive powers. \n\nr = (7+n)/(10+n)\n\n", "tags": ["mandelbrot", "line", "circle", "distance", "complex", "draw", "pattern", "generalized", "modular", "times", "timestable", "timestables"], "likes": 6, "viewed": 532, "published": "Public", "date": "1524855077", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ===========================================\n// Times tables and mandelbrot set\n// a great video by Mathologer\n// https://www.youtube.com/watch?v=qhbuKbxJsk8\n// ===========================================\n//\n// Mandelbrot set and modular times tables relation\n//\n// in order to match times table with the mandelbrot set\n// the circle is rotated by amount of -pi/(N-1) where N is the power.\n// notice that \"N\" is also the \"times\" value for Times table\n//\n// the circle has a radius of (7+N)/(10+N)\n// this is where the cardioid (for N=2) attaches to secondary circle.\n// it holds for all N>=2. (teseted by zooming 100x at attachment positions)\n//\n// ============================================\n// all of this was achieved by experiment. i have no mathematical proof \n// or what so ever that this is correct or not. \n// but it seems to be some how working this way.\n\nconst float pi = 3.14159265359;\nconst float epsilon = 1e-5;\n\nconst float scale = 1.5;\nconst float thickness = 3.0*scale;\n\n// mandelbrot set properties\nconst int iterations = 100;\nconst float bailout = 100.0;\n\n// times table properties\nconst int modular = 200;\n\n// shared properties\nconst float minPower = 0.0; // minimum power of Z.\nconst float maxPower = 5.0; // maximum power of Z.\nconst float duration = 50.0; // transition cycle duration in seconds.\n\n\nvec2 uvmap(vec2 uv) {\n    return (2.0*uv-iResolution.xy)/iResolution.y;\n}\n\nvec3 pickColor(float n) {\n    return 0.6+0.6*cos(6.3*n+vec3(0,23,21));\n}\n\nfloat smoothout(float dist){\n    return smoothstep(thickness/iResolution.y,0.0,dist);\n}\n\nfloat smoothfloor(float x) {\n    return x - sin(2.0*pi*x)/(2.0*pi);\n}\n\nfloat clock(){\n    float t = 1.-abs(mod(2.*iTime/duration,2.)-1.);\n    return (maxPower-minPower)*t + minPower;\n}\n\nfloat circle(vec2 uv, vec2 C, float r, bool fill)\n{\n    vec2 p = uv-C;\n    float fx = length(p)-r;\n    float dist = fill? fx:abs(fx);\n    return smoothout(dist);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a, ba = b - a; \n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float dist = length(pa - ba * h);\n    return smoothout(dist);\n}\n\nvec2 function(vec2 z, float n) {\n    float r = pow(dot(z, z), n/2.0);\n    float th = n*atan(z.y,z.x+epsilon);\n    return r*vec2(cos(th), sin(th));\n}\n\nvec2 dfunction(vec2 z, vec2 dz, float n){\n    // f(f(z))' = f'(f(z))*f'(z)\n\tvec2 df = n*function(z, n - 1.0);\n\treturn vec2(df.x*dz.x-df.y*dz.y, df.x*dz.y + df.y*dz.x) + vec2(1,0);\n}\n\nfloat mandelbrotDistance(float r, float dr) {\n    float dist = r*log(r)/dr;\n    return clamp(pow(dist,0.25),0.0,1.0);\n}\n\nvec3 mandelbrot(vec2 uv, float n) {\n    vec3 set = vec3(0);\n    vec2 c = uv;\n    vec2 z = c;\n    vec2 dz = vec2(1, 0);\n    \n    for(int i = 0; i < iterations && dot(z, z) <= bailout; i++) {\n\t    dz = dfunction(z,dz,n);\n\t    z = function(z,n) + c;\n    }\n    \n    float dist = mandelbrotDistance(length(z), length(dz));\n    \n    if(dot(z, z) > bailout) set = dist+pickColor(n/5.0)/2.0;\n    \n    return clamp(set*0.8,0.0,1.0);\n}\n\nvec3 timesTable(vec2 uv, float times)\n{\n    vec3 col = vec3(0);\n    float len = 2.0*pi/float(modular);\n    float r = (7.0+times)/(10.0+times); // radius of the circle\n    float phase = -pi/(times-1.0);\n    \n    col+=circle(uv,vec2(0),r,false);\n    \n    for(int i = 0; i < modular; i++) {\n        float n = float(i);\n        \n        vec2 c = vec2(cos(n*len+phase),sin(n*len+phase))*r;\n        vec2 p = vec2(cos(n*len*times+phase),sin(n*len*times+phase))*r;\n        \n        col+= circle(uv,c,0.005,true);\n        col+= line(uv,c,p)*pickColor(n/float(modular)/3.+iTime/10.0);\n    }\n    return clamp(col*0.5,0.0,1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = uvmap(fragCoord.xy)*scale;\n\t\n    float time = smoothfloor(clock());\n    \n    vec3 color = mandelbrot(uv,time)\n               + timesTable(uv,time);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3fD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1324, 1324, 1345, 1345, 1397], [1399, 1399, 1424, 1424, 1471], [1473, 1473, 1501, 1501, 1560], [1562, 1562, 1590, 1590, 1631], [1633, 1633, 1647, 1647, 1746], [1748, 1748, 1799, 1799, 1911], [1913, 1913, 1949, 1949, 2109], [2111, 2111, 2143, 2143, 2259], [2261, 2261, 2302, 2335, 2442], [2444, 2444, 2489, 2489, 2563], [2565, 2565, 2600, 2600, 2990], [2992, 2992, 3031, 3031, 3609], [3611, 3611, 3666, 3666, 3868]], "test": "ok"}
{"id": "Ms3fzn", "name": "Easyp Checkerboard", "author": "easyp", "description": "Simple checkerboard", "tags": ["basic"], "likes": 1, "viewed": 67, "published": "Public", "date": "1523917938", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 colorA = vec4(52./255., 152./255., 219./255., 1.);\nvec4 colorB = vec4(241./255., 196./255., 15./255., 1.);\n\nfloat min_zoom = 3.5f;\nfloat max_zoom = 19.5f;\n\nfloat bars = 20.f;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    \n    float size = (sin(iTime)+1.)*((max_zoom-min_zoom)/2.)+min_zoom;\n    float index = round(uv.x*size) + round(uv.y*size);\n    float even = max(sign(mod(index, 2.)), 0.);\n    \n    fragColor = vec4(even > 0.? colorA : colorB );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3fzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 238, 238, 518]], "test": "ok"}
{"id": "MscBzn", "name": "task unrelated", "author": "Eugene_One", "description": "http://www.taskunrelated.com/\nhttps://www.newrafael.com/websites/", "tags": ["math", "abstract", "rr"], "likes": 0, "viewed": 56, "published": "Public", "date": "1523929218", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t(z) 1.-abs(mod(-iTime*3.+(U.x<iResolution.x/2.?U.x:U.y)*.04,3.)-z)\nvoid mainImage(out vec4 O,vec2 U){O=vec4(abs(t(0.)+.5)-.5,t(1.),t(2.),1);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MscBzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 110, 110, 150]], "test": "ok"}
{"id": "MsdBDn", "name": "Awesome!", "author": "MadEqua", "description": "Awesome!\nInspired by https://www.shadertoy.com/view/lsXcWn", "tags": ["shapes", "smiley", "emoji"], "likes": 12, "viewed": 503, "published": "Public API", "date": "1524765370", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 YELLOW = vec3(.9921, .898, .4823);\nconst vec3 RED = vec3(.5294, .1294, .2862);\nconst vec3 PINK = vec3(.9764, .7568, .8705);\nconst vec3 BLACK = vec3(0.);\nconst vec3 WHITE = vec3(1.);\n\nconst vec3 DARK_YELLOW_1 = vec3(.949, .8627, .2313);\nconst vec3 DARK_YELLOW_2 = vec3(.945, .9058, .6627);\nconst vec3 LIGHT_YELLOW_1 = vec3(.9921, .9843, .5019);\nconst vec3 LIGHT_YELLOW_2 = vec3(.9372, .9294, .8313);\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat circle(vec2 uv, vec2 center, float r, float sm)\n{\n    return 1. - smoothstep(r - sm, r, distance(uv, center));\n}\n\nfloat rectangle(vec2 uv, vec2 center, vec2 size, float sm)\n{\n    vec2 lb = center - size * .5;\n    vec2 rt = center + size * .5;\n    vec2 lbRes = smoothstep(lb, lb + sm, uv);\n    vec2 rtRes = 1. - smoothstep(rt - sm, rt, uv);\n    return lbRes.x * lbRes.y * rtRes.x * rtRes.y;\n}\n\n//sidesToCut -> radius percentage [l, b, r, t]\nfloat circleCut(vec2 uv, vec2 center, float r, vec4 sidesToCut, float sm)\n{\n    float c = circle(uv, center, r, sm);\n    \n    vec2 posToCut = center - (1. - sidesToCut.xy) * r;\n    vec2 lb = smoothstep(posToCut, posToCut + sm, uv);\n    posToCut = center + (1. - sidesToCut.zw) * r;\n    vec2 rt = 1. - smoothstep(posToCut - sm, posToCut, uv);    \n    return c * lb.x * lb.y * rt.x * rt.y;\n}\n\n//range and target -> [minX, minY, maxX, maxY]\nvec2 map(vec2 v, vec4 range, vec4 target)\n{\n    return ((v - range.xy) / (range.zw - range.xy)) * (target.zw - target.xy) + target.xy;\n}\n\nvec2 map01(vec2 v, vec4 range) \n{\n\treturn map(v, range, vec4(.0, .0, 1., 1.));\n}\n\nvec4 head(vec2 uv)\n{\n    float outline = circle(uv, vec2(.0), .45, .005);\n    float inside = circle(uv, vec2(.0), .425, .005);\n    float shadow = circle(uv, vec2(.015, -.015), .49, .12);\n    \n    vec3 col = YELLOW * inside;\n\treturn vec4(col, saturate(outline + shadow));\n}\n\nvec4 eye(vec2 uv)\n{\n    uv -= .5;\n    \n    float outline = circleCut(uv, vec2(0.), .5, vec4(0., .65, 0., 0.), .012);\n    float inside = circleCut(uv, vec2(0.), .424, vec4(0., .73, 0., 0.), .012);\n    float pupil = circle(uv, vec2(.27 , .25), .15, .012);\n    \n\tvec3 col = vec3(inside - pupil);\n    return vec4(col, outline);\n}\n\nvec4 mouth(vec2 uv)\n{\n    uv -= .5;\n    uv.x += .15 * uv.y ;\n    \n    float outline = circleCut(uv, vec2(0.), .5, vec4(0., .0, 0., 1.15), .005);\n    float inside = circleCut(uv, vec2(0.), .465, vec4(0., .0, 0., 1.21), .005);\n    float upperLip = rectangle(uv, vec2(-.009, -.08), vec2(1.02, .033), .005);\n    float tongue = circle(uv, vec2(.12 , -.5), .23, .005);\n        \n    vec3 col = RED * inside;\n    col = mix(col, PINK, tongue * inside);\n    return vec4(col, saturate(outline + upperLip));\n}\n\nvec3 background(vec2 uv)\n{\n    float angle = atan(uv.y, uv.x);\n    float dist = length(uv) * 2.;\n    \n    vec3 c1 = mix(DARK_YELLOW_2, DARK_YELLOW_1, dist);\n    vec3 c2 = mix(LIGHT_YELLOW_2, LIGHT_YELLOW_1, dist);\n    \n    float v = cos(iTime + angle * 8.0) * .5 + .5;\n    return mix(c1, c2, smoothstep(0.48, 0.52, v));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec2 uv = fragCoord / iResolution.xy;\n\tfloat ratio = iResolution.x / iResolution.y;\n    \n    uv -= .5;\n    uv.x *= ratio;\n    \n    vec4 h = head(uv);\n    vec4 le = eye(map01(uv, vec4(-.207 * ratio, -.08, -.07 * ratio, .25)));\n    vec4 re = eye(map01(uv, vec4(.0, -.08, .155 * ratio, .25)));\n    vec4 m = mouth(map01(uv, vec4(-.19 * ratio, -.37, .165 * ratio, .35)));\n    \n    vec3 col = background(uv);\n    col.rgb = mix(col, h.rgb, h.a);\n    col.rgb = mix(col, le.rgb, le.a);\n    col.rgb = mix(col, re.rgb, re.a);\n\tcol.rgb = mix(col, m.rgb, m.a);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsdBDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[449, 449, 504, 504, 567], [569, 569, 629, 629, 846], [848, 895, 970, 970, 1284], [1286, 1333, 1376, 1376, 1469], [1471, 1471, 1504, 1504, 1551], [1553, 1553, 1573, 1573, 1825], [1827, 1827, 1846, 1846, 2152], [2154, 2154, 2175, 2175, 2651], [2653, 2653, 2679, 2679, 2974], [2976, 2976, 3031, 3031, 3626]], "test": "ok"}
{"id": "MsGcWc", "name": "Polyhedral Menger", "author": "dr2", "description": "Polygonal Mengers on a dodecahedron (mouseable, optional antialiasing)", "tags": ["fractal", "menger", "symmetry", "polyhedron"], "likes": 15, "viewed": 637, "published": "Public API", "date": "1523525412", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Polyhedral Menger\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing (0/1 - off/on)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nvec3 HsvToRgb (vec3 c);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\n\nvec2 csD, csD2;\nfloat tCur, dstFar;\nconst float pi = 3.14159;\n\nvec3 DodecSym (vec3 p)\n{\n  float a, w;\n  w = 2. * pi / 5.;\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), vec2 (csD.x, - csD.y));\n  p.xy = Rot2D (p.xy, - 0.25 * w);\n  p.x = - abs (p.x);\n  for (int k = 0; k < 3; k ++) {\n    if (dot (p.yz, csD) > 0.) p.zy = Rot2Cs (p.zy, csD2) * vec2 (1., -1.);\n    p.xy = Rot2D (p.xy, - w);\n  }\n  if (dot (p.yz, csD) > 0.) p.zy = Rot2Cs (p.zy, csD2) * vec2 (1., -1.);\n  a = mod (atan (p.x, p.y) + 0.5 * w, w) - 0.5 * w;\n  p.yx = vec2 (cos (a), sin (a)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 b;\n  const float nIt = 5., sclFac = 2.4;\n  b = (sclFac - 1.) * vec3 (0.8, 1., 0.5) * (1. + 0.03 * sin (vec3 (1.23, 1., 1.43) * tCur));\n  p = DodecSym (p);\n  p.z += 0.6 * (1. + b.z);\n  p.xy /= 1. - 0.2 * p.z;\n  for (float n = 0.; n < nIt; n ++) {\n    p = abs (p);\n    p.xy = (p.x > p.y) ? p.xy : p.yx;\n    p.xz = (p.x > p.z) ? p.xz : p.zx;\n    p.yz = (p.y > p.z) ? p.yz : p.zy;\n    p = sclFac * p - b;\n    p.z += b.z * step (p.z, -0.5 * b.z);\n  }\n  return 0.9 * PrBoxDf (p, vec3 (1.)) / pow (sclFac, nIt);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 24; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += min (0.08, 3. * h);\n    if (sh < 0.001) break;\n  }\n  return 0.3 + 0.7 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 ltPos[4], ltDir, col, vn;\n  float dstObj, dfTot, spTot, at, sh;\n  float dihedDodec, h;\n  dihedDodec = 0.5 * atan (2.);\n  csD = vec2 (cos (dihedDodec), - sin (dihedDodec));\n  csD2 = vec2 (cos (2. * dihedDodec), - sin (2. * dihedDodec));\n  for (int k = 0; k < 3; k ++) {\n    ltPos[k] = vec3 (0., 4., 6.);\n    ltPos[k].xz = Rot2D (ltPos[k].xz, float (k) * 2. * pi / 3. -0.1 * pi * tCur);\n  }\n  ltPos[3] = vec3 (0., 6., 0.);\n  ltPos[3].xy = Rot2D (ltPos[3].xy, pi * (0.05 + 0.04 * sin (0.14 * pi * tCur)));\n  ltPos[3].xz = Rot2D (ltPos[3].xz, 0.1 * pi * tCur);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    dfTot = 0.;\n    spTot = 0.;\n    for (int k = 0; k < 4; k ++) {\n      ltDir = normalize (ltPos[k]);\n      at = smoothstep (0., 0.3, dot (normalize (ltPos[k] - ro), ltDir));\n      sh = ObjSShadow (ro, ltDir);\n      dfTot = max (dfTot, at * sh * max (dot (vn, ltDir), 0.));\n      spTot = max (spTot, at * smoothstep (0.5, 0.8, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.));\n    }\n    h = mod (length (ro) - 0.03 * tCur, 1.);\n    col = HsvToRgb (vec3 (h, 0.5, 0.8)) * (0.2 + 0.8 * dfTot) +\n       HsvToRgb (vec3 (mod (h + 0.5, 1.), 1., 0.4)) * spTot;\n  } else {\n    col = vec3 (0.6, 1., 1.) * (0.2 + 0.2 * (rd.y + 1.) * (rd.y + 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    az = 0.03 * pi * tCur;\n    el = - pi * (0.2 + 0.25 * sin (0.02 * pi * tCur));\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -12.);\n  zmFac = 8. + 4. * sin (0.05 * pi * tCur);\n  dstFar = 20.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsGcWc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[363, 363, 387, 387, 906], [908, 908, 930, 930, 1444], [1446, 1446, 1479, 1479, 1656], [1658, 1658, 1679, 1679, 1879], [1881, 1881, 1918, 1918, 2158], [2160, 2160, 2195, 2195, 3541], [3543, 3543, 3599, 3599, 4694], [4696, 4696, 4728, 4728, 4828], [4830, 4830, 4854, 4854, 4990], [4992, 4992, 5022, 5022, 5135], [5137, 5137, 5168, 5168, 5232]], "test": "error"}
{"id": "MsGcWd", "name": "color clock (111 chars)", "author": "FabriceNeyret2", "description": ".", "tags": ["clock", "short", "1tweet", "golf"], "likes": 3, "viewed": 393, "published": "Public API", "date": "1523721804", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 u) { O.xy = u+u-iResolution.xy;\n                                    O = .6 + .6 * cos( fract( atan(O.x,O.y)/6.3 -iTime ) + iTime + vec4(0,23,21,0) ); }\n    \n        \n        \n        \n/** // 123 chars     \n\n#define mainImage(O,u)  vec2 R = iResolution.xy, U = (u+u-R)/R.y;  \\\n    O = .6 + .6 * cos( fract( atan(U.x,U.y)/6.3 -iTime ) + iTime + vec4(0,23,21,0) )\n/**/\n\n        \n        \n\n/** // 150 chars\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, U = (u+u-R)/R.y;\n    float t = iTime,                             //  / 60. if you want minutes\n    a = fract( atan(U.x,U.y) / 6.2832 -t ) + t;\n    O = .6 + .6 * cos( a + vec4(0,23,21,0)  );\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsGcWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 183]], "test": "ok"}
{"id": "MsGczV", "name": "Planetary gears", "author": "AntoineC", "description": "Simple animation using a gear polar function discovered mostly by chance. ", "tags": ["2d", "gear"], "likes": 128, "viewed": 13096, "published": "Public", "date": "1522676947", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Inspired by:\n//  http://cmdrkitten.tumblr.com/post/172173936860\n\n\n#define Pi 3.14159265359\n\nstruct Gear\n{\n    float t;\t\t\t// Time\n    float gearR;\t\t// Gear radius\n    float teethH;\t\t// Teeth height\n    float teethR;\t\t// Teeth \"roundness\"\n    float teethCount;\t// Teeth count\n    float diskR;\t\t// Inner or outer border radius\n    vec3 color;\t\t\t// Color\n};\n\n    \n    \nfloat GearFunction(vec2 uv, Gear g)\n{\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    \n    // Gear polar function:\n    //  A sine squashed by a logistic function gives a convincing\n    //  gear shape!\n    float p = g.gearR-0.5*g.teethH + \n              g.teethH/(1.0+exp(g.teethR*sin(g.t + g.teethCount*a)));\n\n    float gear = r - p;\n    float disk = r - g.diskR;\n    \n    return g.gearR > g.diskR ? max(-disk, gear) : max(disk, -gear);\n}\n\n\nfloat GearDe(vec2 uv, Gear g)\n{\n    // IQ's f/|Grad(f)| distance estimator:\n    float f = GearFunction(uv, g);\n    vec2 eps = vec2(0.0001, 0);\n    vec2 grad = vec2(\n        GearFunction(uv + eps.xy, g) - GearFunction(uv - eps.xy, g),\n        GearFunction(uv + eps.yx, g) - GearFunction(uv - eps.yx, g)) / (2.0*eps.x);\n    \n    return (f)/length(grad);\n}\n\n\n\nfloat GearShadow(vec2 uv, Gear g)\n{\n    float r = length(uv+vec2(0.1));\n    float de = r - g.diskR + 0.0*(g.diskR - g.gearR);\n    float eps = 0.4*g.diskR;\n    return smoothstep(eps, 0., abs(de));\n}\n\n\nvoid DrawGear(inout vec3 color, vec2 uv, Gear g, float eps)\n{\n\tfloat d = smoothstep(eps, -eps, GearDe(uv, g));\n    float s = 1.0 - 0.7*GearShadow(uv, g);\n    color = mix(s*color, g.color, d);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = 0.5*iTime;\n    vec2 uv = 2.0*(fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    float eps = 2.0/iResolution.y;\n\n    // Scene parameters;\n\tvec3 base = vec3(0.95, 0.7, 0.2);\n    const float count = 8.0;\n\n    Gear outer = Gear(0.0, 0.8, 0.08, 4.0, 32.0, 0.9, base);\n    Gear inner = Gear(0.0, 0.4, 0.08, 4.0, 16.0, 0.3, base);\n    \n    \n    // Draw inner gears back to front:\n    vec3 color = vec3(0.0);\n    for(float i=0.0; i<count; i++)\n    {\n        t += 2.0*Pi/count;\n \t    inner.t = 16.0*t;\n        inner.color = base*(0.35 + 0.6*i/(count-1.0));\n        DrawGear(color, uv+0.4*vec2(cos(t),sin(t)), inner, eps);\n    }\n    \n    // Draw outer gear:\n    DrawGear(color, uv, outer, eps);\n    \n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsGczV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[369, 369, 406, 406, 821], [824, 824, 855, 899, 1177], [1181, 1181, 1216, 1216, 1378], [1381, 1381, 1442, 1442, 1574], [1580, 1580, 1637, 1637, 2382]], "test": "ok"}
{"id": "MsGyDK", "name": "Hilbert Square", "author": "dr2", "description": "Four Hilbert curves", "tags": ["hilbertcurve"], "likes": 5, "viewed": 396, "published": "Public API", "date": "1523354392", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Hilbert Square\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Four Hilbert curves; algorithm adapted from FabriceNeyret2's Hilbert curve generator\n// (https://www.shadertoy.com/view/XljSW3)\n\n#define AA  1   // optional antialiasing (0/1 - off/on)\n\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir;\nfloat tCur, dstFar, lWid;\nconst float maxIter = 5.;\nconst float pi = 3.14159;\n\nvec4 BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp, qnBlk;\n  float dMin, dn, df;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  dMin = dstFar;\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    qnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return vec4 (dMin, qnBlk);\n}\n\nfloat LineDrw (vec2 p, vec2 v)\n{\n  return (dot (p, v) > 0.) ? smoothstep (0.1, 1., abs (dot (p, vec2 (- v.y, v.x)))) : 1.;\n}\n\nfloat HilbDrw (vec2 p, float nIter)\n{\n  vec4 lr;\n  vec2 sp, e;\n  e = vec2 (1., 0.);\n  lr.xy = e.yx;\n  for (float i = 0.; i < maxIter; i ++) {\n    sp = step (0.5, p);\n    p = 2. * p - sp;\n    lr = vec4 ((sp.x > 0.) ? ((sp.y > 0.) ? - e.yx : - e) : ((sp.y > 0.) ? lr.xy : e.yx),\n       (sp.x == sp.y) ? e : ((sp.y > 0.) ? - e.yx : e.yx));\n    if (sp.x > 0.) {\n      p.x = 1. - p.x;\n      lr.xz = - lr.xz;\n      lr = lr.zwxy;\n    }\n    if (sp.y > 0.) {\n      p = 1. - p.yx;\n      lr = - lr.yxwz;\n    }\n    if (i == nIter - 1.) break;\n  }\n  p = (p - 0.5) / lWid;\n  return min (LineDrw (p, lr.xy), LineDrw (p, lr.zw));\n}\n\nfloat DotDrw (vec2 p, float nIter)\n{\n  p = mod (pow (2., nIter - 1.) * (2. * p - 1.), 1.) - 0.5;\n  return smoothstep (0.1, 1., length (p) / lWid);\n}\n\nfloat MixDrw (vec2 p, float nIter)\n{\n  return min (HilbDrw (p, nIter), DotDrw (p, nIter));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 bb;\n  vec3 col, vn;\n  vec2 w, dw;\n  float dstBlk, nIter, t, h;\n  bb = BlkHit (ro, rd, vec3 (2., 0.01, 2.));\n  dstBlk = bb.x;\n  if (dstBlk < dstFar) {\n    vn = bb.yzw;\n    ro += dstBlk * rd;\n    col = vec3 (0., 0., 0.2);\n    if (vn.y > 0.99) {\n      w = 1. - 0.5 * abs (ro.xz);\n      t = mod (0.5 * tCur, 2. * maxIter);\n      if (t >= maxIter) t = 2. * maxIter - t;\n      h = SmoothBump (0.1, 0.9, 0.1, fract (t));\n      nIter = 1. + floor (t);\n      lWid = 0.02 * pow (1.7, nIter);\n      col = mix (vec3 (0.9, 0.9, 1.), mix (vec3 (0.8, 0.8, 0.), vec3 (0.9, 0.9, 1.),\n         smoothstep (0.9, 0.91, MixDrw (w, nIter))), h);\n      dw = 0.01 * vec2 (sqrt (lWid), 0.);\n      vn.xz = vec2 (MixDrw (w - dw, nIter) - MixDrw (w + dw, nIter),\n                    MixDrw (w - dw.yx, nIter) - MixDrw (w + dw.yx, nIter));\n      vn = normalize (vec3 (h * vn.xz * sign (ro.xz), 250. * dw.x).xzy);\n    }\n    col = col * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.2 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n  } else {\n    col = vec3 (0.6, 0.6, 1.) * (0.2 + 0.2 * (rd.y + 1.) * (rd.y + 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = -0.2 * pi + 0.2 * pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n  }\n  el = clamp (el, -0.3 * pi, -0.15 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., -0.3, -7.);\n  dstFar = 20.;\n  ltDir = vuMat * normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), 4.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsGyDK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[490, 490, 534, 534, 977], [979, 979, 1011, 1011, 1103], [1105, 1105, 1142, 1142, 1720], [1722, 1722, 1758, 1758, 1870], [1872, 1872, 1908, 1908, 1964], [1966, 1966, 2001, 2001, 3144], [3146, 3146, 3202, 3202, 4292], [4294, 4294, 4351, 4351, 4434], [4436, 4436, 4466, 4466, 4579]], "test": "ok"}
{"id": "MsKyR3", "name": "nSpiral Circle Test 0.0.1", "author": "Chris_M_Thomasson", "description": "Just testing out isolating multiple circles in a single pass. Julia mode... ;^)", "tags": ["fractal", "circle", "vector"], "likes": 7, "viewed": 615, "published": "Public API", "date": "1522815050", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fractal Spin by Chris M. Thomasson\n\n\n\n// Viewport Axes\nstruct ct_axes\n{\n    float xmin;\n    float xmax;\n    float ymin;\n    float ymax;\n};\n    \n    \nct_axes ct_axes_from_radius(\n    in vec3 vpcircle\n){\n    return ct_axes(\n        vpcircle.x - vpcircle.z,\n        vpcircle.x + vpcircle.z,\n        vpcircle.y - vpcircle.z,\n        vpcircle.y + vpcircle.z\n    );\n}\n\n\n// Simple 2d Plane\nstruct ct_plane2d\n{\n    ct_axes axes;\n    float xstep;\n    float ystep;\n};\n    \n    \nct_plane2d ct_plane2d_create(\n    in ct_axes axes\n){\n    float awidth = axes.xmax - axes.xmin;\n    float aheight = axes.ymax - axes.ymin;\n    \n    float daspect = abs(iResolution.y / iResolution.x);\n    float waspect = abs(aheight / awidth);\n    \n    if (daspect > waspect)\n    {\n        float excess = aheight * (daspect / waspect - 1.0);\n        axes.ymax += excess / 2.0;\n        axes.ymin -= excess / 2.0;\n    }\n    \n    else if (daspect < waspect)\n    {\n        float excess = awidth * (waspect / daspect - 1.0);\n        axes.xmax += excess / 2.0;\n        axes.xmin -= excess / 2.0;\n    }\n    \n    return ct_plane2d(\n        axes,\n        (axes.xmax - axes.xmin) / iResolution.x,\n        (axes.ymax - axes.ymin) / iResolution.y\n    );\n}\n\n\nvec2 ct_plane2d_project(\n\tin ct_plane2d self,\n    in vec2 z\n){\n\treturn vec2(\n        self.axes.xmin + z.x * self.xstep,\n        self.axes.ymin + z.y * self.ystep\n    );\n}\n\n\nvec4 ct_circle(\n    in vec2 c,\n    in vec2 z,\n    in float radius\n){\n    float d = length(c - z);\n    \n    if (d < radius) \n    {\n        d = d / radius;\n        float b = -(.25 + abs(sin(iTime)));\n        return exp(b*dot(d,d) ) * vec4(1,.7,.4,0)*2.;\n    }\n    \n    return vec4(0.0, 0.0, 0.0, 0.0);\n}\n\nvec2 ct_cmul(in vec2 p0, in vec2 p1)\n{\n    return vec2(p0.x * p1.x - p0.y * p1.y, p0.x * p1.y + p0.y * p1.x);\n}\n\n\nvec4 ct_spiral_arm(\n    in vec2 c,\n    in float astart,\n    in int n\n){\n\tvec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    float rbase = 1.0 / float(n);\n    float abase = 6.28 / float(n);\n    \n    vec2 prev = vec2(0.0, 0.0);\n    \n    c = ct_cmul(c, c) + cos(iTime * .5) * .35;\n    c = ct_cmul(c, c) + sin(iTime * .25) * .45;\n    c = ct_cmul(c, c) + sin(iTime * .25) * .25;\n    \n    for (int i = 1; i < n + 1; ++i)\n    {\n        float angle = abase * float(i) + astart;\n        float radius = rbase * float(i);\n        \n        vec2 cur = vec2(cos(angle) * radius, sin(angle) * radius);\n        \n        vec2 dif = cur - prev;\n        \n        float br = length(dif) / 2.0;\n        \n        vec2 mid = vec2(prev.x + dif.x * .5, prev.y + dif.y * .5);\n        \n        color += ct_circle(c, mid, br * (.2 + abs(sin(iTime * 1.5)) * .8));\n        \n        prev = cur;\n    }\n    \n    \n    return color;\n}\n\n\n// High-Level Entry\nvec4 ct_main(\n    in ct_plane2d plane,\n    in vec2 c\n){\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    vec2 center = vec2(0.0, 0.0);\n    float radius = 1.8;\n    //int n = 6;//2 + (int(floor(iTime * 3.)) % 16);\n    \n    int sn = 23;\n    float aspin = -iTime * 1.0;\n    \n    int n = 6;\n    float abase = 6.28 / float(n);\n    \n    for (int i = 0; i < n; ++i)\n    {\n     \tfloat angle = abase * float(i) + aspin;\n        \n        color += ct_spiral_arm(c, angle, sn);\n    }\n    \n    return color;\n}\n\n\n\n// Raw Entry.\nvoid mainImage(\n  \tout vec4 fragColor, \n\tin vec2 fragCoord\n){\n    vec3 vpcircle = vec3(\n        0., \n        0., \n        abs(cos(iTime * .25)) + .5\n    );\n    \n    ct_plane2d plane = ct_plane2d_create(\n        ct_axes_from_radius(vpcircle)\n    );\n    \n    vec2 c = ct_plane2d_project(plane, fragCoord);\n    \n    // Exec...\n    vec4 color = ct_main(plane, c);\n    \n    fragColor = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsKyR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 152, 204, 204, 364], [471, 471, 523, 523, 1212], [1215, 1215, 1277, 1277, 1385], [1388, 1388, 1456, 1456, 1689], [1691, 1691, 1729, 1729, 1802], [1805, 1805, 1876, 1876, 2701], [2704, 2724, 2779, 2779, 3222], [3226, 3240, 3301, 3301, 3629]], "test": "error"}
{"id": "MstfDH", "name": "Cubicalotahedron", "author": "dpiponi", "description": "Iterated transforms and reflections of a cube.\nAdded some mouse control.", "tags": ["geometric"], "likes": 6, "viewed": 407, "published": "Public", "date": "1525026289", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat4 translate(vec3 p) {\n    return mat4(1.0,  0.0,  0.0,  -p.x,\n              0.0,  1.0,  0.0,  -p.y,\n              0.0,  0.0,  1.0,  -p.z,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 scale(vec3 s) {\n    return mat4(s.x,  0.0,  0.0,  0.0,\n              0.0,  s.y,  0.0,  0.0,\n              0.0,  0.0,  s.z,  0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(c,  -s,  0.0,  0.0,\n              s,  c,  0.0,  0.0,\n              0.0,  0.0,  1.0,  0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(c,  0.0, s,  0.0,\n              0.0,  1.0, 0.0, 0.0,\n              -s,  0.0, c,  0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, c,  -s,  0.0, \n                0.0, s,  c,  0.0,\n                0.0,  0.0,  0.0,  1.0);\n}\n\nfloat g(vec3 x) {\n    return max(x.z,max(-x.z,max(x.y,max(-x.y,max(x.x, -x.x)))))-1.0;\n}\n\nfloat h(vec3 x) {\n    mat4 m = rotateZ(1.5*iTime-3.128)*scale(vec3(1.0, 1.0, 1.0));\n    return g((vec4(x, 1.0)*m).xyz);\n}\n\nvec2 xy;\n\nfloat f(vec3 x) {\n    mat4 m = translate(vec3(1.4, -0.71+0.0*xy.y, 0.1+0.0*xy.x))*rotateY(5.123+0.01*iTime)\n        *scale(vec3(1.02, 1.01, 1.01))*rotateZ(-0.125+0.075*iTime);\n    float norm = 1.02;\n    float s = 1.0;\n    float t = 1000.0;\n    for (int i = 0; i < 10; ++i) {\n        x.x = abs(x.x);\n        float hh = h(x)/s;\n        t = min(t, hh);\n        x = (vec4(x, 1.0)*m).xyz;\n        s *= norm;\n    }\n    return t;\n}\n\nfloat eps = 0.0001;\nfloat lambda = 2.0;\n\nvec3 ico[12];\n\n//vec3 hash3(vec3 x) {\n//    float u = 1000.0*sin(x.x*x.y+3.3*x.z-2.2*x.y+10.123*x.y+11.12*x.y*x.z);\n//    float v = 1000.0*sin(x.z*x.y-2.1*x.z+3.0*x.z+7.211*x.y+32.12*x.y*x.x);\n//    float w = 1000.0*cos(x.z*x.y+3.4*x.z-3.0*x.x+17.97*x.y+11.12*x.x*x.y);\n//    return vec3(u-floor(u), v-floor(v), w-floor(w));\n//}\n\nfloat lighting(vec3 x, vec3 n) {\n    float t = 0.0;\n    for (int i = 0; i < 12; ++i) {\n        t += f(x+0.5*n+0.25*ico[i]);\n    }\n    return t/12.0;\n}\n\nvec3 march(vec3 p, vec3 d) {\n    float c;\n    c = f(p);\n    if (c < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    for (int i = 0; i < 70; ++i) {\n        float step = max(0.02, c);\n        p = p+step*d;\n        c = f(p);\n        if (c <= 0.0) {\n            float ex, ey, ez;\n            ex = f(p+vec3(eps, 0.0, 0.0));\n            ey = f(p+vec3(0.0, eps, 0.0));\n            ez = f(p+vec3(0.0, 0.0, eps));\n            vec3 n = vec3(ex-c, ey-c, ez-c)/eps;\n            n = normalize(n);\n            mat4 m = rotateY(0.1*iTime);\n            vec3 light = (vec4(1.0,1.0,-1.0,1.0)*m).xyz;\n            float l = 0.0;\n            l += 0.1+0.4*max(dot(n, light)/sqrt(3.0), 0.0);\n            l += 1.0*lighting(p, n);\n            return vec3(l)*vec3(0.7, 0.7, 0.7);\n        }\n    }\n    return vec3(0.1, 0.1, 0.1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n\nico[0]=    vec3(-0.26286500, 0.0000000, 0.42532500);\nico[1]=    vec3(0.26286500, 0.0000000, 0.42532500);\nico[2]=    vec3(-0.26286500, 0.0000000, -0.42532500);\nico[3]=    vec3(0.26286500, 0.0000000, -0.42532500);\nico[4]=    vec3(0.0000000, 0.42532500, 0.26286500);\nico[5]=    vec3(0.0000000, 0.42532500, -0.26286500);\nico[6]=    vec3(0.0000000, -0.42532500, 0.26286500);\nico[7]=    vec3(0.0000000, -0.42532500, -0.26286500);\nico[8]=    vec3(0.42532500, 0.26286500, 0.0000000);\nico[9]=    vec3(-0.42532500, 0.26286500, 0.0000000);\nico[10]=    vec3(0.42532500, -0.26286500, 0.0000000);\nico[11]=    vec3(-0.42532500, -0.26286500, 0.0000000);    \n    \n    vec2 uv = fragCoord.xy-0.5*iResolution.xy;\n    uv = 2.0*uv/iResolution.y;\n    xy = iMouse.xy/iResolution.xy;\n\n    vec3 p = vec3(0.0, 0.0, -12.0)+0.1*vec3(xy.x, xy.y, 0.0);;\n    vec3 d = normalize(vec3(0.5*uv, 1.0));\n    mat4 m = rotateY(0.1*iTime-6.28*xy.x);\n    p = (vec4(p, 1.0)*m).xyz;\n    d = (vec4(d, 1.0)*m).xyz;\n    vec3 color = march(p, d);\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MstfDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 177], [179, 179, 199, 199, 349], [351, 351, 378, 378, 573], [575, 575, 602, 602, 793], [795, 795, 822, 822, 1022], [1024, 1024, 1041, 1041, 1112], [1114, 1114, 1131, 1131, 1235], [1247, 1247, 1264, 1264, 1671], [2044, 2044, 2076, 2076, 2194], [2196, 2196, 2224, 2224, 3004], [3006, 3006, 3061, 3061, 4103]], "test": "ok"}
{"id": "MstyD4", "name": "FlowerOfLife", "author": "goanautix", "description": "-can´t get the cam out", "tags": ["rings", "rotation"], "likes": 0, "viewed": 251, "published": "Public", "date": "1524669998", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define v2 vec2\n#define v3 vec3\n#define v4 vec4\n#define f1 float\n#define i1 int\n// press A key to use static Degrees\n#define aKey (texture(iChannel2, vec2(0.254901961, 0.25)).x)\n#define DEGRAD ((aKey > 0.5)? true : false)\n\n#define PI2 6.283185307\n#define PI1 3.141592653\n#define FL 0.866025404\n#define scale 30.0\nf1 ci(v2 p){\n\treturn 1.0-length(p);\n}\nf1 cc(v2 p , f1 s){\n    f1 c = ci(p);\n\treturn\tsmoothstep(-s\t, 0.0\t, c) -\n        \tsmoothstep(0.0\t, s \t, c);\t\n}\nf1 flower( v2 p , f1 s , f1 disp , i1 row , i1 cei){\n    // the first loop make the step between the rings\n    // the second loop rotates the UV every for segment\n    // the third loop draw an circle and move the UV to next positon\n    i1 fcount = 1;\n    i1 ceile = cei;\n    f1 displace = disp;\n    f1 angle = (DEGRAD) ? radians(360.0/f1(cei)) : PI2/f1(cei)*sin(iTime*0.1);\n    f1 HFL = disp*sin(radians(360.0/f1(cei)));\n    f1 f = cc(p,s)+cc(p*10.0,s*10.0);\n    p += vec2(0.5,HFL);\n    for(i1 i=0; i<row; i++){\n        for(i1 k=0; k<cei; k++){\n        \tfor(i1 j=0; j<(ceile/cei); j++){\n        \t    p.x -= displace;\n                fcount += 1;\n        \t    f = max(f,cc(p,s));\n        \t}//lklklj\n            v2 sc = v2(sin(angle),cos(angle));\n        \tp *= mat2(sc.y,sc.x,-sc.x,sc.y); \n        }\n        ceile += cei;\n        p.y += displace*HFL;\n        p.x += displace*0.5;\n    }\n    return f;   \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0/0 to 1/1) and move 0/0 to the center\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n\tuv.x *= iResolution.x/iResolution.y;// * aspect ratio \n    uv *= scale*((iMouse.y == 0.0) ? 1.0 : (iMouse.y/iResolution.y)) ;\n    vec3 col = flower(uv,0.01*(scale*((iMouse.x == 0.0) ? 1.0 : (iMouse.x/iResolution.x))),1.0,6,6)*vec3(1.0);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MstyD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[313, 313, 325, 325, 350], [351, 351, 370, 370, 461], [462, 462, 514, 693, 1364], [1365, 1365, 1422, 1503, 1819]], "test": "error"}
{"id": "MsVcDy", "name": "AudioBlob - iq remix", "author": "cacheflowe", "description": "Deformed sphere based on audio input", "tags": ["sphere", "deform", "audioreactive"], "likes": 13, "viewed": 266, "published": "Public", "date": "1523288420", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Original code by iq: https://www.shadertoy.com/view/XtjSDK\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float PHI = 1.6180339887498948482045868343656;\n\nvec4 grow = vec4(1.0);\n\nvec3 mapP( vec3 p )\n{\n    p.xyz += 1.000*sin( 2.0*p.yzx )*grow.x;\n    p.xyz += 0.500*sin( 4.0*p.yzx )*grow.y;\n    p.xyz += 0.250*sin( 8.0*p.yzx )*grow.z;\n    p.xyz += 0.050*sin( 16.0*p.yzx )*grow.w;\n    return p;\n}\n\nfloat map( vec3 q )\n{\n    vec3 p = mapP( q );\n    float d = length( p ) - 1.5;\n\treturn d * 0.05;\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 50.0;\n\n\tfloat precis = 0.001;\n    float h = 1.0;\n    float t = 1.0;\n    for( int i=0; i<2048; i++ )\n    {\n        if( (h<precis) || (t>maxd) ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\treturn t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.005,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinate\n    vec2 p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n\tvec2 q = fragCoord/iResolution.xy;\n\n    // rotation\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n    \n    \n    grow = smoothstep( 0.0, 1.0, (iTime-vec4(0.0,1.0,2.0,3.0))/3.0 );\n\tgrow = vec4(\n    \ttexture(iChannel0, vec2(0.1)).r * 0.5,\n        texture(iChannel0, vec2(0.2)).r,\n        texture(iChannel0, vec2(0.5)).r,\n        texture(iChannel0, vec2(0.3)).r\n    );\n    \n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\t\n\tfloat an = 1.1 + 0.5*(iTime-10.0) - 7.0*m.x;\n\n\tvec3 ro = vec3(4.5*sin(an),1.0,4.5*cos(an));\n    vec3 ta = vec3(0.0,0.2,0.0);\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n    \n\tvec3 col = vec3(0.3)*clamp(1.0-length(q-0.5),0.0,1.0);\n\n\t// raymarch\n    float t = intersect(ro,rd);\n\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 sor = nor;\n        \n        vec3 q = mapP( pos );\n\n        // materials\n\t\tcol = vec3(0.14);\n        float ar = clamp(1.0-0.7*length(q-pos),0.0,1.0);\n        col = mix( col, vec3(0.7,1.0,0.6), ar);\n        // col = mix( col, vec3(0.5 + 0.5 * sin(pos.y * 100.)), ar);\n        col  *= 0.3;          \n        \n        // lighting\n        float sky = 0.5 + 0.5*nor.y;\n        float fre = 0.5 * clamp( 1.0 + dot(nor,rd), 0.0, 1.0 );\n        float spe = 0.5 * pow(max( dot(-rd,nor),0.0),8.0);\n        \n\t\t// apply lights\n\t\tvec3 lin  = vec3(0.0);\n\t\t     lin += 3.0*vec3(0.7,0.80,1.00)*sky;\n             lin += 1.0*fre*vec3(1.2,0.70,0.60)*(0.1+0.9);\n        col += 0.3*4.0*vec3(0.7,0.8,1.00)*smoothstep(0.0,0.2,pos.y)*(0.05+0.95*pow(fre,5.0))*(0.5+0.5*nor.y);\n        col += 4.0*1.5*spe*col.x;\n        col += 2.0*1.0*pow(spe,8.0)*col.x;\n        col = col * lin;\n    }    \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "Xs2XWm", "previewfilepath": "https://soundcloud.com/cacheflowe/cacheflowe-ooh-ooh", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/cacheflowe/cacheflowe-ooh-ooh", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsVcDy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[317, 317, 338, 338, 531], [533, 533, 554, 554, 631], [633, 633, 676, 676, 932], [934, 934, 966, 966, 1177], [1179, 1179, 1236, 1254, 3442]], "test": "error"}
{"id": "MsVcRy", "name": "rm -f", "author": "shau", "description": "Playing with fractal by GUIL (again)", "tags": ["3d"], "likes": 78, "viewed": 7666, "published": "Public", "date": "1522552625", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define T iTime\n#define PI 3.14159265359\n#define FAR 20.0\n#define EPS 0.005\n\n#define SPHERE_EXTERIOR 1.0\n#define SPHERE_INTERIOR 2.0\n#define FLOOR 3.0\n#define SR 0.2\n\n#define CA vec3(0.5, 0.5, 0.5)\n#define CB vec3(0.5, 0.5, 0.5)\n#define CC vec3(1.0, 1.0, 1.0)\n#define CD vec3(0.0, 0.33, 0.67)\n\n#define CT T / 14.0\n\nconst vec4 sphere = vec4(0.0, 0.0, 0.0, 1.0);\n\nstruct Scene {\n    float t;\n    float id;\n    vec3 n;\n    float stn;\n    float stf;\n};\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n//IQ cosine palattes\n//http://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {return a + b * cos(6.28318 * (c * t + d));}\nvec3 glowColour() {return palette(T * 0.1, CA, CB, CC, CD);}\nvec2 csqr(vec2 a) {return vec2(a.x * a.x - a.y * a.y, 2.0 * a.x * a.y);}\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n\nfloat fbm(vec3 x) {\n    float r = 0.0;\n    float w = 1.0;\n    float s = 1.0;\n    for (int i = 0; i < 5; i++) {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\nfloat tex(vec3 rp) {\n    rp.xy *= rot(T);\n    if (rp.x > 0.3 && rp.x < 0.5) return 0.0;\n    return 1.0;\n}        \n\n//Cube mapping trick from Fizzer\nfloat pattern(vec3 rp) {\n    vec3 f = abs(rp);\n    f = step(f.zxy, f) * step(f.yzx, f); \n    f.xy = f.x > .5 ? rp.yz / rp.x : f.y > .5 ? rp.xz / rp.y : rp.xy / rp.z; \n    return tex(f);\n}\n\n//See sphere functions IQ\n//http://iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\n//slightly modified for cut patterns\nvec4 sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec4(0.0); //missed\n    h = sqrt(h);\n    float tN = -b - h;\n    float tNF = tN;\n    if (pattern(ro + rd * tNF) == 0.0) tNF = 0.0;\n    float tF = -b + h;\n    float tFF = tF;\n    if (pattern(ro + rd * tFF) == 0.0) tFF = 0.0;\n    return vec4(tNF, tFF, tN, tF);\n}\n\nvec3 sphNormal(in vec3 pos, in vec4 sph) {\n    return normalize(pos - sph.xyz);\n}\n\nfloat sphSoftShadow(vec3 ro, vec3 rd, vec4 sph, float k) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    // physically plausible shadow\n    float d = sqrt( max(0.0, sph.w * sph.w - h)) - sph.w;\n    float tN = -b - sqrt( max(h, 0.0));\n    float tF = -b + sqrt( max(h, 0.0));\n    if ((pattern(ro + rd * tN) + pattern(ro + rd * tF)) == 0.0) return 1.0;\n    if (tN > 0.0) return smoothstep(0.0, 1.0, 4.0 * k * d / tN) * 1.0;\n    return 1.0;\n}\n\nfloat sphOcclusion(vec3 pos, vec3 nor, vec4 sph) {\n    vec3  r = sph.xyz - pos;\n    float l = length(r);\n    float d = dot(nor, r);\n    float res = d;\n\n    if (d < sph.w) res = pow(clamp((d + sph.w) / (2.0 * sph.w), 0.0, 1.0), 1.5) * sph.w;\n    \n    return clamp(res * (sph.w * sph.w) / (l * l * l), 0.0, 1.0);\n}\n\nfloat planeIntersection(vec3 ro, vec3 rd, vec3 n, vec3 o) {\n    return dot(o - ro, n) / dot(rd, n);\n}\n\nfloat map(vec3 rp) {\n\treturn min(length(rp) - sphere.w, rp.y + 1.0);\n}\n\nvec3 vMarch(vec3 ro, vec3 rd) {\n\n    vec3 pc = vec3(0.0);\n    float t = 0.0;\n    \n    for (int i = 0; i < 96; i++) {\n        \n        vec3 rp = ro + rd * t;\n        float ns = map(rp);\n        float fz = pattern(rp);\n        \n        if ((ns < EPS && fz > 0.0) || t > FAR) break;\n        \n        vec3 ld = normalize(-rp);\n        float lt = length(rp);\n        if (sphIntersect(rp, ld, sphere).x == 0.0 || lt < sphere.w) {\n            lt -= SR;\n            pc += glowColour() * 0.1 / (1.0 + lt * lt * 12.0);        \n        }\n        \n        t += 0.05;\n    }\n    \n    return pc;\n}\n\n//fractal from GUIL\n//https://www.shadertoy.com/view/MtX3Ws\nfloat fractal(vec3 rp) {\n\t\n\tfloat res = 0.0;\n\tfloat x = 0.8 + sin(T * 0.2) * 0.3;\n    \n    rp.yz *= rot(T);\n    \n    vec3 c = rp;\n\t\n    for (int i = 0; i < 10; ++i) {\n        rp = x * abs(rp) / dot(rp, rp) - x;\n        rp.yz = csqr(rp.yz);\n        rp = rp.zxy;\n        res += exp(-99.0 * abs(dot(rp, c)));   \n\t}\n    \n    return res;\n}\n\nvec3 fractalMarch(vec3 ro, vec3 rd, float maxt) {\n    \n    vec3 pc = vec3(0.0);\n    float t = 0.0;\n    float ns = 0.;\n    \n    for (int i = 0; i < 64; i++) {\n        \n        vec3 rp = ro + t * rd;\n        float lt = length(rp) - SR;\n\n        ns = fractal(rp); \n        \n        if (lt < EPS || t > maxt) break;\n        t += 0.02 * exp(-2.0 * ns);\n\n        pc = 0.99 * (pc + 0.08 * glowColour() * ns) / (1.0 + lt * lt * 1.);\n        pc += 0.1 * glowColour() / (1.0 + lt * lt);  \n    } \n    \n    return pc;\n}\n    \nScene drawScene(vec3 ro, vec3 rd) {\n \n    float mint = FAR;\n    vec3 minn = vec3(0.0);\n    float id = 0.0;\n\n    vec3 fo = vec3(0.0, -1.0, 0.0);\n    vec3 fn = vec3(0.0, 1.0, 0.0);\n    float ft = planeIntersection(ro, rd, fn, fo);\n    if (ft > 0.0 && ft < FAR) {\n        mint = ft;\n        id = FLOOR;\n        minn = fn;\n    }    \n    \n    vec4 si = sphIntersect(ro, rd, sphere);\n    if (si.x > 0.0 && si.x < mint) {        \n        vec3 rp = ro + rd * si.x;\n        mint = si.x;\n        id = SPHERE_EXTERIOR;\n        minn = sphNormal(rp, sphere);\n    } else if (si.y > 0.0 && si.y < mint) {        \n        vec3 rp = ro + rd * si.y;\n        mint = si.y;\n        id = SPHERE_INTERIOR;\n        minn = -sphNormal(rp, sphere);\n    }\n    \n    return Scene(mint, id, minn, si.z, si.w);;\n}\n\n//Moody clouds from Patu\n//https://www.shadertoy.com/view/4tVXRV\nvec3 clouds(vec3 rd) {\n    vec2 uv = rd.xz / (rd.y + 0.6);\n    float nz = fbm(vec3(uv.yx * 1.4 + vec2(CT, 0.0), CT)) * 1.5;\n    return clamp(pow(vec3(nz), vec3(4.0)) * rd.y, 0.0, 1.0);\n}\n\n// see https://www.shadertoy.com/view/MtffWs\nvec3 pri(vec3 x) {\n    vec3 h = fract(x / 2.0) - 0.5;\n    return x * 0.5 + h * (1.0 - 2.0 * abs(h));\n}\n\nfloat checkersTextureGradTri(vec3 p, vec3 ddx, vec3 ddy) {\n    p.z += T;\n    vec3 w = max(abs(ddx), abs(ddy)) + 0.01; // filter kernel\n    vec3 i = (pri(p + w) - 2.0 * pri(p) + pri(p - w)) / (w * w); // analytical integral (box filter)\n    return 0.5 - 0.5 * i.x *  i.y * i.z; // xor pattern\n}\n\nvec3 texCoords(vec3 p) {\n\treturn 5.0 * p;\n}\n\nvec3 colourScene(vec3 ro, vec3 rd, Scene scene) {\n    \n    vec3 pc = clouds(rd) * glowColour();\n    vec3 gc = vec3(0.0);\n    vec3 lp = vec3(4.0, 5.0, -2.0);\n\t    \n    vec3 rp = ro + rd * scene.t;\n    \t\n    vec3 ld = normalize(lp - rp);\n    float lt = length(lp - rp);\n    float atten = 1.0 / (1.0 + lt * lt * 0.051);\n    \n    if (scene.stn > 0.0) {\n        gc = fractalMarch(ro + rd * scene.stn, rd, scene.stf - scene.stn);\n        pc = gc;\n    }\n\n    if (scene.id == FLOOR) {\n        \n        // calc texture sampling footprint\t\n        vec3 uvw = texCoords(rp * 0.15);\n\t\tvec3 ddx_uvw = dFdx(uvw); \n    \tvec3 ddy_uvw = dFdy(uvw);\n        float fc = checkersTextureGradTri(uvw, ddx_uvw, ddy_uvw);\n        \n    \tfloat diff = max(dot(ld, scene.n), 0.05);\n        float ao = 1.0 - sphOcclusion(rp, scene.n, sphere);  \n        float spec = pow(max(dot(reflect(-ld, scene.n), -rd), 0.0), 32.0);\n        float sh = sphSoftShadow(rp, ld, sphere, 2.0);\n\n        pc += glowColour() * fc * diff * atten;\n        pc += vec3(1.0) * spec;\n        pc *= ao * sh; \n        \n        vec3 gld = normalize(-rp);\n        if (sphIntersect(rp, gld, sphere).x == 0.0) {\n            pc += glowColour() / (1.0 + length(rp) * length(rp));    \n        }\n    }\n    \n    if (scene.id == SPHERE_EXTERIOR) {\n    \t\n        float ao = 0.5 + 0.5 * scene.n.y;\n        float spec = pow(max(dot(reflect(-ld, scene.n), -rd), 0.0), 32.0);\n        float fres = pow(clamp(dot(scene.n, rd) + 1.0, 0.0, 1.0), 2.0);\n        \n        pc *= 0.4 * (1.0 - fres);\n        pc += vec3(1.0) * fres * 0.2;\n        pc *= ao;\n        pc += vec3(1.0) * spec;\n    }\n\n      \n    if (scene.id == SPHERE_INTERIOR) {\n    \tfloat ao = 0.5 + 0.5 * scene.n.y;\n        float ilt = length(rp) - SR;\n        pc += glowColour() * ao / (1.0 + ilt * ilt);\n    }\n    //*/\n    \n    return pc;\n}\n\nvoid setupCamera(vec2 uv, inout vec3 ro, inout vec3 rd) {\n\n    ro = vec3(0.0, 0.0, -4.0);\n    vec3 lookAt = ro + vec3(0.0, 0.0 , 4.0);\n    \n    ro.xz *= rot(T * 0.4);\n    \n    float FOV = PI / 4.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n\tvec3 pc = vec3(0.0);\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\tvec3 ro, rd;\n\tsetupCamera(uv, ro, rd);\n    \n    Scene scene = drawScene(ro, rd);\n\tpc = colourScene(ro, rd, scene);    \n    \n    pc += vMarch(ro, rd);\n    \n    fragColor = vec4(pc*2.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsVcRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[450, 450, 469, 469, 515], [516, 600, 655, 655, 698], [699, 699, 718, 718, 759], [760, 760, 779, 779, 832], [834, 846, 868, 868, 1176], [1178, 1178, 1197, 1197, 1377], [1379, 1379, 1399, 1399, 1484], [1494, 1527, 1551, 1551, 1714], [1716, 1852, 1899, 1899, 2306], [2308, 2308, 2350, 2350, 2389], [2391, 2391, 2449, 2449, 2910], [2912, 2912, 2962, 2962, 3224], [3226, 3226, 3285, 3285, 3327], [3329, 3329, 3349, 3349, 3399], [3401, 3401, 3432, 3432, 3983], [3985, 4045, 4069, 4069, 4379], [4381, 4381, 4430, 4430, 4888], [4894, 4894, 4929, 4929, 5675], [5677, 5742, 5764, 5764, 5928], [5930, 5975, 5993, 5993, 6077], [6079, 6079, 6137, 6137, 6372], [6374, 6374, 6398, 6398, 6417], [6419, 6419, 6468, 6468, 8241], [8243, 8243, 8300, 8300, 8654], [8656, 8656, 8711, 8711, 9005]], "test": "ok"}
{"id": "MsVczd", "name": "The Worm of France ", "author": "Thomas_nathan21", "description": "My French Breathren are so proud of me ", "tags": ["worm", "fance"], "likes": 0, "viewed": 316, "published": "Public API", "date": "1523032419", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \t //sets 0 as the centre of the screen \n\tvec2 r = 2.*fragCoord / iResolution.xy -1.;\n    \n    //variables\n    float x = r.x;\n    float y = r.y;\n    float Thickness = 0.3;\n    float Yoffset = 0.9; \n    float Height = 0.2;\n    \n    //Colors\n    vec3 red = vec3(1,0,0);\n    vec3 white = vec3(1,1,1);\n    vec3 blue = vec3(0,0,1);\n    vec3 pixelCol = vec3(0, 0, 0);\n\t\n    if(abs((x * Height) * sin(PI * (x + iTime)) - (y - Yoffset)) < Thickness) pixelCol = red;\n    if(abs((x * Height) * sin(PI * (x + iTime)) - (y + Yoffset)) < Thickness) pixelCol = blue;\n    if(abs((x * Height) * sin(PI * (x + iTime)) - y) < (Thickness * 2.0)) pixelCol = white;\n   \n    // Output to screen\n    fragColor = vec4(pixelCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsVczd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 82, 125, 795]], "test": "ok"}
{"id": "MsyyDV", "name": "Beating Heart 2D", "author": "shicz86", "description": "Beating Heart", "tags": ["2d"], "likes": 1, "viewed": 123, "published": "Public", "date": "1523371203", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n* Inspired By @Candycat https://blog.csdn.net/candycat1992/article/details/44040273\n* Using Polar Coordinate To Calculate Distance\n*/\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 p = (2.*fragCoord.xy-iResolution.xy)/min(iResolution.x,iResolution.y);\n    p.y -= 0.45;\n    \n    vec2 uv = p;\n    vec2 st = vec2(atan(uv.x,uv.y),length(uv));//[-pi,pi]\n\n    //heart curve http://mathworld.wolfram.com/HeartCurve.html\n    float r = .3*(2.-2.*cos(st.x)+.85*cos(st.x)*sqrt(abs(.55*sin(st.x)))/(cos(st.x)+1.4));\n    \n    //background color\n    vec3 bCol = vec3(1.,0.8,0.7-.07*p.y)*(1.-.25*length(p));\n    \n    //heart color\n    vec3 hCol = vec3(1.,.25*length(p),.75*length(p)*.5);\n    \n    ///animation\n    float tt = mod(iTime,1.5)/1.5;\n    float ss = pow(tt,.2)*.5+.5;\n    ss=1.+ss*.5*sin(tt*6.283185*3.+p.y*.5)*exp(-tt*4.);\n    p*= vec2(0.5,1.5)+ss*vec2(.5,-.5);\n    \n    //smoothstep https://en.wikipedia.org/wiki/Smoothstep\n    fragColor = vec4(mix(bCol,hCol,smoothstep(-0.01,0.05,r-length(p))),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsyyDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 193, 193, 1020]], "test": "ok"}
{"id": "MsyyzK", "name": "Doodling #5: North", "author": "lsdlive", "description": "Things I did before the Revision 2018 to train shader showdown (but showmatch were cancelled).\n\nVarious utilities code from iq, lj, mercury, shane, aiekick & balkhan.", "tags": ["raymarch", "architecture"], "likes": 22, "viewed": 286, "published": "Public", "date": "1522593737", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// @lsdlive\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvoid amod(inout vec2 p, float m) {\n\tfloat a = mod(atan(p.x, p.y) - m*.5, m) - m*.5;\n\tp = vec2(cos(a), sin(a)) * length(p);\n}\n\nvoid mo(inout vec2 p, vec2 d) {\n\tp.y = abs(p.y) - d.x;\n\tp.x = abs(p.x) - d.y;\n\tif (p.y > p.x) p.xy = p.yx;\n}\n\nfloat rep(float p, float m) {\n\treturn mod(p - m*.5, m) - m*.5;\n}\n\nvec2 rep(vec2 p, float m) {\n\treturn mod(p - m*.5, m) - m*.5;\n}\n\nvec3 rep(vec3 p, float m) {\n\treturn mod(p - m*.5, m) - m*.5;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(.5 + .5*(b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat cmin(float a, float b, float k) {\n\treturn min(min(a, b), (a - k + b) * sqrt(.5));\n}\n\nfloat stmin(float a, float b, float k, float n) {\n\tfloat s = k / n;\n\tfloat u = b - k;\n\treturn min(min(a, b), .5 * (u + a + abs((mod(u - a + s, 2. * s)) - s)));\n}\n\nfloat length8(vec2 p) {\n\tvec2 q = p*p*p*p*p*p*p*p;\n\treturn pow(q.x + q.y, 1. / 8.);\n}\n\nfloat torus88(vec3 p, vec2 d) {\n\tvec2 q = vec2(length8(p.xz) - d.x, p.y);\n\treturn length8(q) - d.y;\n}\n\n\nfloat box(vec3 p, vec3 d) {\n\treturn length(max(abs(p) - d, 0.));\n}\n\nfloat g = 0.;\nfloat id = 0.;\nfloat de(vec3 p) {\n    \n    float wl = p.x + 1.25;\n    float wr = -p.x + 1.25;\n    float fl = p.y + 1.;\n    float cl = -p.y + 1.;\n    \n    vec3 q = p;\n    q.x += sin(q.z*.2)*4.;\n    q += iTime;\n    q.yz += sin(iTime*.2)*4.;\n    q = rep(q, 2.);\n    float s1 = length(q) - .01 + sin(iTime*30.)*.004;\n    \n    p.x += 1.;\n    p = rep(p, 2.);\n    \n\tfloat d = box(p, vec3(.2, 1., .2));\n    d = smin(d, cl +d*.9, .2);\n    d = stmin(d, fl, .2, 3.);\n    \n    //d = stmin(d, wl+d*.8, .4, 8.);\n    //d = stmin(d, wr+d*.8, .4, 8.);\n    d = cmin(d, wl+d*.2, .4);\n    d = cmin(d, wr+d*.2, .4);\n    \n    d = min(s1, d);\n    \n    \n    p.z += .4;\n    p.y-=.6;\n    q=p;\n    q.xy*=r2d(3.14/4.);\n    float symb = 1e6;\n    symb = min(symb, torus88(q.xzy, vec2(.05, .01)));\n    p.y+=.07;\n    p.xy*=r2d(3.14/4.);\n    symb = min(symb, box(p, vec3(.01, .07, .01)));\n    p.xy*=r2d(-3.14/2.);\n    symb = min(symb, box(p, vec3(.01, .07, .01)));\n    \n    d=min(d,symb);\n    \n\tg += .01 / (.01 + d*d);\n\treturn d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 ro = vec3(0, 0, -3. + iTime);\n\tvec3 rd = normalize(vec3(uv, 1));\n\n\n\tvec3 p;\n\tfloat t = 0., ri;\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tri = i;\n\t\tp = ro + rd*t;\n\t\tfloat d = de(p);\n\t\tif (t > 30.) break;\n        d = max(abs(d), .001);\n        t+=d*.2;\n\t}\n\n\t vec3 bg = vec3(.2, .1, .2);\n\n    vec3 col = bg;\n    if(t<=30.)\n\t    col = mix(vec3(.2, .2, .4), bg, uv.y*2.+ri);\n    \n    //if(p.y < .13 && p.y > -.2) col = mix(vec3(1, 0,0), bg, uv.y+ri);\n    \n    //if (id == 1.)\n      //  col = vec3(1., 0.,0.);;\n    \n\tcol+=g*.015;\n    col = mix(col, bg, 1.-exp(-.09*t*t));\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsyyzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[13, 13, 32, 32, 92], [94, 94, 128, 128, 218], [220, 220, 251, 251, 328], [330, 330, 359, 359, 394], [396, 396, 423, 423, 458], [460, 460, 487, 487, 522], [524, 524, 563, 563, 653], [655, 655, 694, 694, 744], [746, 746, 795, 795, 907], [909, 909, 932, 932, 994], [996, 996, 1027, 1027, 1097], [1100, 1100, 1127, 1127, 1166], [1197, 1197, 1215, 1215, 2180], [2182, 2182, 2237, 2237, 2926]], "test": "ok"}
{"id": "MtlBWH", "name": "2D sine Ocean Waves", "author": "Tezza48", "description": "porting what i've done in the Andriod shader editor, it's a learning experience.", "tags": ["sinewave"], "likes": 3, "viewed": 131, "published": "Public", "date": "1523015006", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 aqua = vec4(0.3, 0.6, 0.8, 1.0);\n    vec4 blue = vec4(0.4, 0.6, 1.0, 1.0);\n    vec4 deepPurple = vec4(0.1, 0.2, 0.5, 1.0);\n    \n    vec4 water = mix(aqua, deepPurple, (1.0 - uv.y) * 2.0 - 1.5 + sin(iTime + uv.x * 8.0)/6.0);\n    \n    float waveHeight = sin(iTime + uv.x * 4.0)/8.0 +0.6 + (sin(-iTime * 2.0 + uv.x * 16.0)/64.0);\n    \n    if(uv.y < waveHeight)\n\t\tfragColor = water;\n    else\n        fragColor = blue;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtlBWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 529]], "test": "ok"}
{"id": "Xd3BD4", "name": "Red Spot", "author": "oalpha", "description": "A red circle on top of a regular grid distorted by fractal perlin noise.", "tags": ["noise", "domain", "distortion", "perlin"], "likes": 2, "viewed": 113, "published": "Public", "date": "1525045105", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 warp(\n    in vec3 p,\n    out vec3 q,\n    int warpsteps,\n    float warpfactor,\n    int fractalsteps,\n    float res,\n    float scale,\n    float scaleStep,\n    vec3 feedback,\n    mat4 ds,\n    vec4 ss\n);\nfloat grid(vec2 p, float size, float width) {\n    p = fract(p * size);\n    float gx = smoothstep(0.0, width, p.x) -\n        smoothstep(1.0 - width, 1.0, p.x);\n    float gy = smoothstep(0.0, width, p.y) -\n        smoothstep(1.0 - width, 1.0, p.y);\n    return gx * gy;\n}\nfloat inside(vec2 st, float target, float tolerance){\n  return 1.0 - smoothstep( target, target+tolerance / 2.0, st.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4 dotseed = mat4(\n        84.4239141, 72.1623789, 54.2539214, 94.8233014,\n        45.8097063, 19.6603408, 41.9881591, 17.7513314,\n        70.6492482, 72.8228071, 31.9941736, 29.7793959,\n        68.9614210, 33.3000043, 38.8602285, 67.0907920\n    );\n    mat4 sineseed = mat4(\n        8442.39141, 7216.23789, 5425.39214, 9482.33014,\n        4580.97063, 1966.03408, 4198.81591, 1775.13314,\n        7064.92482, 7282.28071, 3199.41736, 2977.93959,\n        6896.14210, 3330.00043, 3886.02285, 6709.07920\n    );\n    vec2 st = 2.0 * gl_FragCoord.xy/iResolution.xy - 1.0;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 st3 = vec3(st, iTime * 0.05);\n    vec3 q = vec3(0.0);\n    vec3 st3p = st3 + warp(\n        st3, // vec3 p\n        q, // vec3 q\n        0, // int warpsteps\n        //1.0, // float warpfactor\n        0.2, // float warpfactor\n        7, // int fractalsteps\n        0.5, // float res\n        1.0, // float scale\n        2.0, // float scaleStep\n        vec3(0.0), // vec3 feedback\n        dotseed, // mat4 ds\n        sineseed[0] // vec4 ss\n    );\n    vec2 tr = vec2(atan(st3p.y, st3p.x), length(st3p.xy));\n    float target = cos(12.0 * tr.x + iTime) * 0.01 + 0.4;\n    float line = inside(tr,target, 0.05);\n    fragColor = vec4(vec3(grid(st3p.xy, 10.0, 0.1) * (1.0 - vec3(line)) + vec3(line, vec2(0.0))), 1.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n}\nfloat rand(float f, float o, float r, vec4 ss) {\n  return o + r * fract(sin(f * ss.x + ss.y) * ss.z + ss.z);\n}\nvec4 rand4(vec4 v, float o, float r, mat4 d, vec4 s) {\n    return vec4(\n        rand(dot(v, d[0]), o, r, s),\n        rand(dot(v, d[1]), o, r, s),\n        rand(dot(v, d[2]), o, r, s),\n        rand(dot(v, d[3]), o, r, s)\n    );\n}\nvec3 rand3Rot(vec3 v, mat4 ds, vec4 ss) {\n  float x = rand(dot(v, ds[1].xyz), 0.0, 2.0 * 3.14159265358, ss);\n  float y = rand(dot(v, ds[2].xyz), 0.0, 2.0 * 3.14159265358, ss);\n  float z = rand(dot(v, ds[3].xyz), 0.0, 2.0 * 3.14159265358, ss);\n    //*\n  return mat3(\n      1.0, 0.0, 0.0,\n      0.0, cos(x), -sin(x),\n      0.0, sin(x), cos(x)\n  ) * mat3(\n      cos(y), 0.0, sin(y),\n      0.0, 1.0, 0.0,\n      -sin(y), 0.0, cos(y)\n  ) * mat3(\n      cos(z), -sin(z), 0.0,\n      sin(z), cos(z), 0.0,\n      0.0, 0.0, 1.0\n  ) * vec3(1.0, 0.0, 0.0);\n}\nfloat mix1(float x, float y, float a) {\n  return (1.0 - a) * x + a * y;\n}\nfloat curve3(float a) {\n  return a * a * (3.0 - 2.0 * a);\n}\nfloat mix3(float x, float y, float a) {\n  return mix1(x, y, curve3(a));\n}\nfloat perlinGradient(vec3 pos, mat4 ds, vec4 ss) {\n  vec3 F = fract(pos);\n    vec3 a = floor(pos)\n        , h = ceil(pos)\n        , b = vec3(a.xy, h.z)\n        , c = vec3(a.x, h.y, a.z)\n        , d = vec3(a.x, h.yz)\n        , e = vec3(h.x, a.yz)\n        , f = vec3(h.x, a.y, h.z)\n        , g = vec3(h.xy, a.z);\n  float nnn = dot(rand3Rot(a, ds, ss), pos - a), nnp = dot(rand3Rot(b, ds, ss), pos - b);\n  float npn = dot(rand3Rot(c, ds, ss), pos - c), npp = dot(rand3Rot(d, ds, ss), pos - d);\n  float pnn = dot(rand3Rot(e, ds, ss), pos - e), pnp = dot(rand3Rot(f, ds, ss), pos - f);\n  float ppn = dot(rand3Rot(g, ds, ss), pos - g), ppp = dot(rand3Rot(h, ds, ss), pos - h);\n  float nn = mix3(nnn, nnp, F.z), np = mix3(npn, npp, F.z);\n  float pn = mix3(pnn, pnp, F.z), pp = mix3(ppn, ppp, F.z);\n  float n = mix3(nn, np, F.y), p = mix3(pn, pp, F.y);\n  return mix3(n, p, F.x);\n}\nfloat fractalNoise(vec3 p, int steps, float res, float scale, float scaleStep, vec3 feedback, mat4 dotseed,  vec4 sineseed) {\n    float value = 0.0;\n    vec4 f = sineseed;\n    for(int i = 0; i < 10; i++) {\n        if(i < steps) {\n            f = rand4(f, 12345.6789012, 32109.8765432, dotseed, sineseed);\n            value += 3.0 * perlinGradient(feedback * value + vec3(p.xy / res, p.z), dotseed, f) / scale;\n            scale = scale * scaleStep;\n            res = res / scaleStep;\n        }\n    }\n    return value * 0.5 + 0.5;\n}\nvec3 warp(\n    in vec3 p,\n    out vec3 q,\n    int warpsteps,\n    float warpfactor,\n    int fractalsteps,\n    float res,\n    float scale,\n    float scaleStep,\n    vec3 feedback,\n    mat4 ds,\n    vec4 ss\n) {\n    q.x = -1.0 + 2.0 * fractalNoise( p + vec3(0.0), fractalsteps, res, scale, scaleStep, feedback, ds, ss );\n    q.y = -1.0 + 2.0 * fractalNoise( p + vec3(5.2,1.3,2.4), fractalsteps, res, scale, scaleStep, feedback, ds, ss );\n    q.z = -1.0 + 2.0 * fractalNoise( p + vec3(1.2,6.5,3.7), fractalsteps, res, scale, scaleStep, feedback, ds, ss );\n\n    vec3 r = vec3(0.0);\n      r.x = -1.0 + 2.0 * fractalNoise( p + warpfactor*q + vec3(1.7,9.2,3.1), fractalsteps, res, scale, scaleStep, feedback, ds, ss );\n      r.y = -1.0 + 2.0 * fractalNoise( p + warpfactor*q + vec3(8.3,2.8,5.7), fractalsteps, res, scale, scaleStep, feedback, ds, ss );\n      r.z = -1.0 + 2.0 * fractalNoise( p + warpfactor*q + vec3(6.1,3.2,9.1), fractalsteps, res, scale, scaleStep, feedback, ds, ss );\n\n    return warpfactor*r;\n  }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3BD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 250, 250, 473], [474, 474, 527, 527, 595], [596, 596, 653, 653, 2222], [2223, 2223, 2271, 2271, 2333], [2334, 2334, 2388, 2388, 2561], [2562, 2562, 2603, 2603, 3105], [3106, 3106, 3145, 3145, 3179], [3180, 3180, 3203, 3203, 3239], [3240, 3240, 3279, 3279, 3313], [3314, 3314, 3364, 3364, 4186], [4187, 4187, 4312, 4312, 4718], [4719, 4719, 4924, 4924, 5724]], "test": "error"}
{"id": "Xd3BWH", "name": "Colourful Squares", "author": "JuliaPoo", "description": "Simple doodle", "tags": ["background", "squares"], "likes": 10, "viewed": 478, "published": "Public API", "date": "1524826204", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Noice function [0,1]\nvec2 T = vec2(0.);\nfloat No(float x, vec2 T){\nreturn fract(9627.5*sin(7933.75*(x + 0.5 + T.x) + 297. + T.y));\n}\n\nvec4 Rancol(vec2 x){\nreturn vec4(No(x.x + x.y,T), No(x.x*x.x+ x.y,T), No(x.x*x.x + x.y*x.y,T),1.);\n}\n\n//squaress\nvec4 grid(vec2 uv, float t){\nvec4 C1,C2;\nuv *= 20.;\nvec2 id = vec2(int(uv.x),int(uv.y));\nuv.y += (5.*No(id.x*id.x, T) + 1.)*t*.4\t;\nuv.y += No(id.x, T);\n  id = vec2(int(uv.x), int(uv.y));\nuv = fract(uv) - .5;\n\n//if (id == vec2(1,10)){C1 = vec4(1.);}\n\nfloat d = length(uv);\nt *= 10.*No(id.x + id.y, T);\n//if uv.x += No(id.x);(uv.x > .48 || uv.y > .48){C1 = vec4(1.);}\n\nfloat r = .1*sin(t + sin(t)*.5)+.3;\n  if (abs( uv.x)<r && abs(uv.y) < r){\n  C2 = .5*Rancol(id + vec2(1.)) + vec4(.5);\n  }\n  if (abs(uv.x)>r+.07 || abs(uv.y)>r + .07){\n  C2 += vec4(.7,.9,.8,1.);\n  }\n  return C2 + C1;\n  }\n\nvoid mainImage( out vec4 C, in vec2 F ){\nT = iMouse.xy;\nvec2 uv = F / iResolution.xy;\nuv.y *= iResolution.y/iResolution.x;\nfloat t = iTime;\nC = vec4(grid(uv, t));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3BWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 68, 68, 134], [136, 136, 156, 156, 236], [238, 249, 277, 277, 835], [837, 837, 877, 877, 1001]], "test": "ok"}
{"id": "Xd3Bz7", "name": "Bouncing Blob", "author": "nr4", "description": "Visuals for the invitation intro to the Z10 Shader Coding Regular's Table by Team210.\nCODE/SFX :: QM\nCODE/GFX :: NR4", "tags": ["2d", "noise", "sdf", "analytic", "visuals"], "likes": 1, "viewed": 83, "published": "Public", "date": "1524491243", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Bouncing Blob\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nvec2 c = vec2(1.,0.);\nfloat pi = acos(-1.);\n\nfloat iScale;\n\nfloat circle(vec2 x, float r)\n{\n    return length(x)-r;\n}\n\nvec2 cnormal(vec2 x, float r)\n{\n    return c.xx*(1.-length(x)/r);\n}\n\nfloat rand(vec2 a0)\n{\n    return fract(sin(dot(a0.xy ,vec2(12.9898,78.233)))*43758.5453);\n}\n\nfloat smoothstep_noise(float x)\n{\n    float r1 = -1.+2.*rand(floor(x)*c.xx), r2 = -1.+2.*rand(ceil(x)*c.xx);\n    return mix(r1, r2, smoothstep(.25, .75, fract(x)));\n}\n\nfloat mfsmoothstep_noise(float x, float f0, float f1, float phi)\n{\n    float sum = 0.;\n    float a = 1.;\n    \n    for(float f = f0; f<f1; f = f*2.)\n    {\n        sum = a*smoothstep_noise(f*x) + sum;\n        a = a*phi;\n    }\n    \n    return sum;\n}\n\nfloat smoothstep_noise2d(vec2 x)\n{\n    vec2 d = floor(x);\n    x = fract(x);\n    float x00 = -1.+2.*rand(d),\n        x01 = -1.+2.*rand(d+c.yx),\n        x10 = -1.+2.*rand(d+c.xy), \n        x11 = -1.+2.*rand(d+c.xx);\n    return mix(mix(x00, x01, x.y), mix(x10, x11, x.y), x.x);\n}\n\nfloat mfsmoothstep_noise2d(vec2 x, float f0, float f1, float phi)\n{\n    float sum = 0.;\n    float a = 1.;\n    \n    for(float f = f0; f<f1; f = f*2.)\n    {\n        sum = a*smoothstep_noise2d(f*x) + sum;\n        a = a*phi;\n    }\n    \n    return sum;\n}\n\nfloat branch(vec2 x, vec3 whbhs, float s)\n{\n    x += .03*c.xy*mfsmoothstep_noise(x.y+s, 1.e1, 1.e2, .2);\n    vec2 b = vec2(mix(whbhs.y, whbhs.z, clamp(x.y/whbhs.x, -1., 1.)), whbhs.x);\n    return length(max(abs(x)-b,0.));\n}\n\n\nvec2 bnormal(vec2 x, vec3 whbhs, float s)\n{\n    x += .03*c.xy*mfsmoothstep_noise(x.y+s, 1.e1, 1.e2, .2);\n    return c.xx*(1.-abs(2.*x.x)/mix(whbhs.y, whbhs.z,clamp(-x.y/whbhs.x, -1., 1.)));\n}\n\nvec2 rot(vec2 x, float p)\n{\n    vec2 d = vec2(cos(p), sin(p));\n    return mat2(d.x, d.y, -d.y, d.x)*x;\n}\n\nvec4 branch(vec2 x, vec2 f, vec2 t, float w1, float w2)\n{\n    return c.xxxx;\n}\n\nfloat func(vec2 x, float f)\n{\n    return x.y-f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.yy-.5-.4*c.xy;\n\n    iScale = 4.*mod(iTime, .2);\n    \n    //uv *= 1.+.03*iScale;\n    \n    float px = 100.;\n    uv = round(px*uv)/px;\n    \n    vec2 x = uv+2.e-1*iTime*c.xy, \n        y = vec2(mod(x.x, .4)-.2, x.y), \n        index = x-y;\n    \n    vec4 sdf = c.xyyy;\n    \n    //trees\n    //(a) leaves\n    vec2 z = y;\n    y += .35*c.yx - .1*mfsmoothstep_noise(x.x-y.x, 8.e0, 20., .6)*c.yx;\n    for(int i=0; i<22; ++i)\n    {\n        float leafsize = .05+.03*rand(float(i)*index);\n        vec2 leaf_offset = vec2(-.1+.2*rand(index+float(i)*21.), -.1+.3*rand(index+float(i)*22.));\n        vec2 n = cnormal(y-.2*c.yx-leaf_offset, leafsize);\n        vec4 sda = vec4(circle(y-.2*c.yx-leaf_offset, leafsize), max(n.x, n.y)*(c.yxy-2.*c.yyx*rand(float(i+10)*c.xx)+1.*c.xyy*rand(float(i+20)*c.xx))+.1*c.yxy*rand(float(i)*c.xx));\n        sdf = mix(sdf, sda, step(sda.x, sdf.x));\n    }\n    //(b) stem\n    vec3 stemc1 = vec3(31., 12., 2.)/255., stemc2 = vec3(145., 57., 9.)/255.;\n    vec2 n = bnormal(y, vec3(.5, .3, .4), index.x);\n    vec4 sda = vec4(branch(y, vec3(.3, .05, .02), index.x), stemc1+stemc2*max(n.x, n.y)-.2*c.xyy);\n    sdf = mix(sdf, sda, step(sda.x, sdf.x));\n    \n    //night sky\n    vec3 bgcol = mix(vec3(0., 96., 255.)/255., vec3(0., 25., 66.)/255., 1.-.5*uv.y);\n    //(a) clouds\n    bgcol = mix(bgcol, c.xxx, smoothstep(-.2,.2,uv.y)*clamp(1.7*mfsmoothstep_noise2d(uv-2.2e-2*iTime*c.xy, 5., 100., .45+.01*sin(1.3e1*iTime-2.)), 0., 1.));\n\tbgcol = mix(bgcol, c.xxx, smoothstep(-.2,.2,uv.y)*clamp(1.7*mfsmoothstep_noise2d(uv-.2-2.1e-2*iTime*c.yx, 7., 100., .45+.01*sin(1.5e1*iTime-3.)), 0., 1.));\n    bgcol = mix(bgcol, c.xxx, smoothstep(-.2,.2,uv.y)*clamp(1.*mfsmoothstep_noise2d(uv-.2-2.3e-2*iTime*c.xx, 6., 100., .45+.01*sin(1.7e1*iTime-4.)), 0., 1.));\n    //(b) mountains\n    for(int i=-2; i<2; ++i)\n    {\n        n = vec2(mfsmoothstep_noise2d((x.x-10.*float(i)+2.e-2*float(i)*iTime)*c.xy+1.2*x.y*c.yx+.2*float(i)*x.yx, 1., 190., .7),\n                 mfsmoothstep_noise2d((x.x-10.*float(i))*c.xy+1.2*x.y*c.yx+.2*float(i)*x.yx, 1., 190., .7)); \n        vec4 sdc = vec4(func(z+.1*float(i)*c.yx, -.3+.3*mfsmoothstep_noise(x.x-10.*float(i)+1.e-2*float(i)*iTime, 1., 19., .6)), mix(stemc1+.1,  .5*stemc2-.3, -.3+(2.*length(n))*c.xxx));\n    \tbgcol = mix(bgcol, sdc.gba, step(sdc.x, 0.));\n    }\n    fragColor = vec4(mix(bgcol, sdf.gba, step(sdf.x, 0.)),1.);\n    \n    //bouncing blob\n    vec2 xi = uv+.5*c.yx-.2*abs(sin(2.*pi*iScale/2.))*c.yx;\n    n = cnormal(xi, .1);\n    vec4 sdd = vec4(circle(xi, .1),  max(n.x, n.y)*c.xxy+.5*c.xyy);\n    fragColor = vec4(mix(fragColor.xyz,sdd.gba, step(sdd.x, 0.)),1.);\n    sdd = vec4(circle(xi-.025*c.xx, .02), c.xxx);\n    fragColor = vec4(mix(fragColor.xyz,sdd.gba, step(sdd.x, 0.)),1.);\n    sdd = vec4(circle(xi-.025*c.xx, .01), c.yyy);\n    fragColor = vec4(mix(fragColor.xyz,sdd.gba, step(sdd.x, 0.)),1.);\n    vec4 sdb = c.xyyy;\n    xi += .01*c.xy;\n    xi += .01*c.yx;\n    sdf = mix(sdd, sdb, step(sdb.x, sdd.x));\n    sdd = vec4(circle(xi-.02*c.xy+.02*c.yx,  .01), c.yyy);\n    sdf = mix(sdd, sdf, step(sdf.x, sdd.x));\n    sdd = vec4(circle(xi-.03*c.xy+.03*c.yx,  .01), c.yyy);\n    sdf = mix(sdd, sdf, step(sdf.x, sdd.x));\n    sdd = vec4(circle(xi-.035*c.xy+.035*c.yx,.01), c.yyy);\n    sdf = mix(sdd, sdf, step(sdf.x, sdd.x));\n    sdd = vec4(circle(xi-.04*c.xy+.04*c.yx,  .01), c.yyy);\n    sdf = mix(sdd, sdf, step(sdf.x, sdd.x));\n    sdd = vec4(circle(xi-.045*c.xy+.04*c.yx, .01), c.yyy);\n    sdf = mix(sdd, sdf, step(sdf.x, sdd.x));\n    sdd = vec4(circle(xi-.055*c.xy+.04*c.yx, .01), c.yyy);\n    sdf = mix(sdd, sdf, step(sdf.x, sdd.x));\n    sdd = vec4(circle(xi-.06*c.xy+.045*c.yx, .01), c.yyy);\n    sdf = mix(sdd, sdf, step(sdf.x, sdd.x));\n    sdd = vec4(circle(xi-.065*c.xy+.05*c.yx, .01), c.yyy);\n    sdf = mix(sdd, sdf, step(sdf.x, sdd.x));\n    fragColor = vec4(mix(fragColor.xyz,sdf.gba, step(sdf.x, 0.)),1.);\n    \n    //[add text here]\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3Bz7.jpg", "access": "shaders20k", "license": "gpl-3.0-plus", "functions": [[795, 795, 826, 826, 852], [854, 854, 885, 885, 921], [923, 923, 944, 944, 1014], [1016, 1016, 1049, 1049, 1182], [1184, 1184, 1250, 1250, 1430], [1432, 1432, 1466, 1466, 1708], [1710, 1710, 1777, 1777, 1959], [1961, 1961, 2004, 2004, 2184], [2187, 2187, 2230, 2230, 2378], [2380, 2380, 2407, 2407, 2484], [2486, 2486, 2543, 2543, 2564], [2566, 2566, 2595, 2595, 2615], [2617, 2617, 2673, 2673, 6589]], "test": "ok"}
{"id": "Xd3Bzn", "name": "Digested", "author": "EvilRyu", "description": "A practice of voronoi.", "tags": ["voronoi", "noise", "fbm", "thron"], "likes": 23, "viewed": 669, "published": "Public API", "date": "1523978321", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define PI 3.14159265\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\nvec3 path(float p)\n{\n    return vec3(sin(p*0.05)*cos(p*0.05)*18., sin(p*0.1+2.)*10.,0.);\n}\n\nvec2 hash2(vec2 p) \n{\n    const vec2 k = vec2(0.3183099, 0.3678794);\n    p = p*k + k.yx;\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x+p.y)) );\n}\n\n\n// From Shane: https://www.shadertoy.com/view/lstGRB\nfloat noise(vec3 p)\n{\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip; \n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nconst mat3 m=mat3(0.00,  0.80,  0.60,\n                  -0.80,  0.36, -0.48,\n                  -0.60, -0.48,  0.64);\n\nfloat fbm(vec3 x)\n{\n    float f=2.0;\n    float s=0.5;\n    float a=0.0;\n    float b=0.5;\n    for(int i=0;i<4;i++)\n    {\n        float n=noise(x);\n        a+=b*n;\n        b*=s;\n        x=f*m*x;\n    }\n\treturn a;\n}\n\n\nfloat tunnel(vec3 p)\n{\n    return 3.-length(p.xy+vec2(sin((iTime+p.z)*1.8)*0.2,0.));\n}\n\n// cone and torus from iq\nfloat cone(vec3 p, vec3 c)\n{\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  \tvec2 q = vec2(length(p.xz)-t.x,p.y);\n  \treturn length(q)-t.y;\n}\n\n//vec4 thorn_texcoord;\nvec3 thorn_texcoord;\n\nfloat thorn(vec3 p, float noi, float base, out float dhole, out float dtorus)\n{\n    float d=10.,dh=10.,dt=10.;\n    \n    vec2 k=normalize(p.xy);\n    \n   \tvec2 n=floor(vec2(asin(k.y)*2.5,p.z));\n    vec2 f=fract(vec2(asin(k.y)*2.5,p.z));\n    \n    for(int i=-1;i<=1;++i)\n    {\n        for(int j=-1;j<=1;++j)\n        {\n            vec2 g=vec2(float(i),float(j));\n            vec2 o=hash2(n+g);\n            vec2 v=hash2(n+g+vec2(13.1,71.7));\n            vec2 r=g-f+o;\n                        \n            vec3 q=vec3(r.x,base,r.y);\n            vec3 qq=q+vec3(0.,-1.+0.6*sin(4.*(iTime+3.*v.x+5.*v.y)),0.);;\n                \n            float d0=cone(qq, vec3(1.,.1, 4.));\n        \tfloat d1=cone(q+vec3(0.,-1.3,0.), vec3(1.,.1, 3.));\n            float d2=torus(q+vec3(0.,-0.08,0.),vec2(0.25,0.07));\n            //if(d0<d)thorn_texcoord=vec4(qq,7.*v.x+17.*v.y);\n            if(d0<d)thorn_texcoord=qq;\n            \n            d=min(d,d0);\n            dh=min(d1,dh);\n            dt=min(d2,dt);\n            \n        }\n    }\n    \n    dhole=dh;\n    dtorus=dt;\n \n    d += noi*noi*0.11;\n    \n    return d;\n}\n\nfloat infi_box(vec3 p, vec2 b)\n{\n    vec2 d = abs(p.xy) - b;\n    return min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n}\n\nint mateid=0;\n\nfloat map(vec3 p)\n{    \n    p-=path(p.z);\n    \n    mateid=0;\n    \n    // displacement is too expensive\n    //float noi=fbm(p*3.0);\n    //float d0=tunnel(p)+(.5-noi)*.2;\n    float d0=tunnel(p);\n    float dh,dt;\n    //float d1=thorn(p, noi, dh);\n    float d1=thorn(p, 0., d0, dh, dt);\n    \n    d0=smax(d0,-dh+0.05,.2);\n    d0=smin(dt,d0,.3);\n    \n    \n    if(d1<d0)\n    {\n        d0=d1;\n        mateid=1;\n    }\n    \n    return d0;\n}\n\nvec3 get_normal(in vec3 p) \n{\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat intersect2(vec3 ro, vec3 rd)\n{\n    float t=0.01;\n    float d=map(ro+t*rd);\n    for(int i=0;i<96;++i)\n    {\n        if(abs(d)<0.002*(1.+t)||t>50.)\n            continue;\n        t+=step(d,1.)*d*0.2+d*0.5;\n        d=map(ro+t*rd);\n    }\n    if(t>50.)t=-1.;\n    return t;\n}\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\nfloat bump(vec3 p, vec3 n)\n{\n    return dot(texcube(iChannel0, 0.25*p, n).xyz, vec3(0.299, 0.587, 0.114)); \n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e = vec2(2./iResolution.y, 0); \n    vec3 g=vec3(bump(p-e.xyy, n)-bump(p+e.xyy, n),\n                bump(p-e.yxy, n)-bump(p+e.yxy, n),\n                bump(p-e.yyx, n)-bump(p+e.yyx, n))/(e.x*2.);  \n    g=(g-n*dot(g,n));\n    return normalize(n+g*weight);\n}\n\nfloat shadow(vec3 ro, vec3 rd, float dist)\n{\n    float res=1.0;\n    float t=0.05;\n    float h;\n    \n    for(int i=0;i<10;i++)\n    {\n        if(t>dist-0.2)continue;\n        h=map(ro+rd*t);\n        res = min(6.0*h/t, res);\n        t+=h;\n    }\n    return max(res, 0.0);\n}     \n\n// density from aiekick: https://www.shadertoy.com/view/lljyWm\nfloat density(vec3 p, float ms) \n{\n\tvec3 n = get_normal(p); \n\treturn map(p-n*ms)/ms;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q=fragCoord.xy/iResolution.xy;\n    vec2 p=q*2.-1.;\n    p.x*=iResolution.x/iResolution.y;\n    vec3 ro=vec3(0.5,0.,-iTime*.6);\n    vec3 ta=ro+vec3(0,0,-1.);\n    \n    vec3 lp0=ro+vec3(0,0.,-3.);\n    \n    ro+=path(ro.z);\n    ta+=path(ta.z);\n\tlp0+=path(lp0.z);\n    \n    vec3 f=normalize(ta-ro);\n    vec3 r=normalize(cross(f,vec3(0,1,0)));\n    vec3 u=normalize(cross(r,f));\n    \n    vec3 rd=normalize(mat3(r,u,f)*vec3(p.xy,PI/2.));\n    vec3 col=vec3(0.6,0.8,1.1);\n\n    float t=intersect2(ro,rd);\n    \n    if(t>-0.5)\n    {\n        vec3 pos=ro+t*rd;\n        vec3 n=get_normal(pos);\n        \n        if(mateid==0)\n        \tn=bump_mapping(pos*0.05, n, 0.08);\n        else \n        \tn=mix(n,bump_mapping(thorn_texcoord.xyz, n, 0.03),\n                  1.-smoothstep(-1.5,-0.5,thorn_texcoord.y));\n            \n\t\tvec3 ld0=lp0-pos;\n        float ldist=length(ld0);\n        ld0/=ldist;        \n        vec3 lc0=vec3(1.1,0.8,.7);\n        \n        float sha=shadow(pos+0.1*n,ld0,ldist);\n        float dif=max(0.,dot(ld0,n));\n        float bac=max(0.,dot(-ld0,n));\n        float amb=max(0.,dot(n,vec3(0,1,0)));\n        float spe=max(0.0, pow(clamp(dot(ld0, reflect(rd, n)), 0.0, 1.0), 128.0));\n        float fre=clamp(1.0+dot(rd,n), .0, 1.); \n        float sca=1.-density(pos,.5);\n\n        vec3 Lo=4.*dif*lc0*sha;\n        Lo+=.5*bac*lc0;\n        Lo+=2.*spe*vec3(1.);\n        Lo+=1.5*pow(fre,8.)*vec3(.6,0.1,0.1);\n        Lo/=ldist;\n\t\t\n        map(pos);\n        \n        float tex=fbm(pos*3.5);\n        \n        vec3 mate=.5*vec3(1.5,0.2,0.)+tex*tex*3.2;\n      \n        if(mateid==1)\n        {\n            // I tried to record and add some randomness here, \n            // but it will crash on my windows nvidia desktop.\n            // it's 1:12 am now, I'm giving up.\n            //float tt=fbm(thorn_texcoord.xyz*15.+thorn_texcoord.w);\n            float tt=fbm(thorn_texcoord*15.);\n            tt=pow(smoothstep(0.1,0.5,tt), 5.);\n            mate=mix(vec3(3.),vec3(3.)-vec3(0.5,1.4*tt,3.*tt),\n                     1.-smoothstep(-1.5,-0.5,thorn_texcoord.y));\n            Lo+=vec3(.4)*(1.-sca)*(1.-sca);\n        }\n        \n        if(mateid==0)\n        {\n            Lo+=5.*spe*vec3(1.,.6,.2)/ldist*sha;\n            Lo+=.3*vec3(0.3,0.07,0.1)*sca*sca*sca;\n        }\n        Lo+=0.2*amb;\n        col=Lo*mate*0.2;        \n    }\n    col=mix(col,vec3(0), 1.0-exp(-0.015*t*t) );\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=pow(col,vec3(0.9,1.,0.95));\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1);\n    fragColor.xyz=col;\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3Bzn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[134, 134, 173, 173, 262], [264, 264, 303, 303, 332], [334, 334, 354, 354, 424], [426, 426, 447, 447, 572], [575, 628, 649, 649, 937], [1057, 1057, 1076, 1076, 1267], [1270, 1270, 1292, 1292, 1356], [1358, 1384, 1412, 1412, 1579], [1581, 1581, 1610, 1610, 1677], [1724, 1724, 1803, 1803, 2816], [2818, 2818, 2850, 2850, 2937], [2954, 2954, 2973, 2973, 3384], [3386, 3386, 3415, 3415, 3573], [3575, 3575, 3611, 3611, 3849], [3851, 3851, 3896, 3896, 4042], [4044, 4044, 4072, 4072, 4153], [4155, 4155, 4204, 4204, 4468], [4470, 4470, 4514, 4514, 4738], [4745, 4808, 4842, 4842, 4894], [4896, 4896, 4953, 4953, 7475]], "test": "error"}
{"id": "Xd3fWr", "name": "SDF Test:Bridge and Fishing-boat", "author": "FishMan", "description": "Test SDF ", "tags": ["sdf", "bridge", "boat"], "likes": 21, "viewed": 363, "published": "Public", "date": "1524969436", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// the base scene is from iq  //https://www.shadertoy.com/view/Xds3zN\n// i just want to test SDF functions\n// jiepengtan@gmail.com\n\n#define ITERATIONS 4\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n#define AA 1   // make this 1 is your machine is too slow\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec2 opRep( vec2 p, vec2 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\nvec3 rX(const in vec3 v, const in float cs, const in float sn) {return mat3(1.0,0.0,0.0,0.0,cs,sn,0.0,-sn,cs)*v;}\nvec3 rY(const in vec3 v, const in float cs, const in float sn) {return mat3(cs,0.0,-sn,0.0,1.0,0.0,sn,0.0,cs)*v;}\nvec3 rZ(const in vec3 v, const in float cs, const in float sn) {return mat3(cs,sn,0.0,-sn,cs,0.0,0.0,0.0,1.0)*v;}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n#define clamp01(a) clamp(a,0.0,1.0)\n#define opS(d1,d2) max(-d1,d2)\n// union 2 objects carrying material info\n#define opU(a,b) ((a.x < b.x) ? a : b)\n\n#define PI 3.14159\n\n// implicitly specifies shading rules\n#define WOOD_MAT 0.\n#define STRAW_MAT 1.\n#define VILLAGE_MAT 2.\nfloat sdCappedCone( in vec3 p, in vec3 c ) // c=vec3(bottom radius, angle , height)\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\n\n\nfloat sdBounceBalls(vec3 pos){\n    float SIZE = 2.;\n    vec2 gridSize = vec2(SIZE,SIZE);\n    float rv = hash12( floor((pos.xz) / gridSize));\n    pos.xz = opRep(pos.xz,gridSize);\n    float bollSize = 0.1;\n    float bounceH = 1.;\n    return sdSphere(pos- vec3(0.,(bollSize+bounceH+sin(iTime*3.14 + rv*6.24)*bounceH),0.),bollSize);\n}\n\nfloat sdBoatHull( vec3 vPos )\n{\n    vPos.y-=0.4;\n    vec3 vBoatDomain = vPos;\n    vBoatDomain.x = abs(vBoatDomain.x);\n    \n    float boatDist = length( vBoatDomain.xyz - vec3(-3.9,3.2,0.)) - 5.6;\n\t\n    float bs = 14.5;\n    float gap = 0.3;\n    vec2 offset=vec2(0.3,bs+gap);\n    float cylinder= length(vBoatDomain.xy-offset)-bs;\n    boatDist=opS(cylinder,boatDist);\n    float sSize = 15.0;\n    float sOff = 0.05;\n    float sphere = length( vBoatDomain.xyz - vec3(0,sSize+sOff,0)) - sSize;\n    boatDist=opS(sphere,boatDist);\n    \n    float bx = vPos.y+0.4;\n    boatDist=opS(bx,boatDist);\n    \n    return boatDist;\n}\n\n\nfloat sdHalfCylinder(vec3 pos , vec3 h){\n    float cy=opS(\n        sdCylinder(pos.yzx,h.xy),\n        sdCylinder(pos.yzx,h.xy + vec2(0.03,-0.03))\n    );\n    float bx = sdBox(pos-vec3(0.,-h.x*h.z*2.,0.),vec3(h.x+0.3,h.x,h.y+0.3));\n    return opS(bx,cy);\n}\nfloat sdPin( vec3 pos, vec3 h)\n{\n    \n   pos.x += h.x*h.z*2. - h.x;\n   float cy = sdCylinder(pos,h.xy);\n   float bx = sdBox(pos-vec3(h.x*(1.+2.*h.z),0.,0.),vec3(h.x*2.,h.y+0.3,h.x*2.));\n   return opS(bx,cy);\n}\n\nfloat sdQuant(vec3 pos){\n    pos -= vec3(-0.,.3,0.);\n    float barLen = 0.3;\n    float quantLen = 0.2;\n\tfloat cy = sdCylinder(pos-vec3(0.,0.,0.),vec2(0.008,barLen));\n    float bx = udRoundBox(pos-vec3(0.,barLen+quantLen,0.),vec3(0.025,quantLen,0.002),0.003);\n    return min(cy,bx);\n}\n\nfloat sdBoat(vec3 pos){\n    float ret = 10000.;\n    //body\n    float vb = sdBoatHull(pos);\n    pos.y -=0.07;\n    float vs = sdBoatHull(pos);\n    float boatBody =  opS(vs,vb);\n    \n    ret = min(ret , boatBody);\n    //quant\n    vec3 quantPos = pos ;\n    quantPos.x = abs(pos.x);\n    quantPos = quantPos- vec3(0.05,.72,1.5);\n    \n    float degZ= PI*-0.15;\n    quantPos = rZ(quantPos,sin(degZ),cos(degZ));\n    float degX= PI*0.65;\n    quantPos = rX(quantPos,sin(degX),cos(degX));\n    float quant = sdQuant(quantPos*0.5);\n    ret = min(ret , quant);\n    \n    //quant Ring\n    \n    vec3 ringPos = pos ;\n    ringPos.x = abs(pos.x);\n    ringPos = ringPos- vec3(0.44,.49,1.72);\n    \n    degZ= PI*-0.05;\n    ringPos = rZ(ringPos,sin(degZ),cos(degZ));\n    degZ= PI*-0.45;\n    ringPos = rX(ringPos,sin(degZ),cos(degZ));\n    float ringd = sdTorus(ringPos,vec2(0.05,0.005));\n    ret = min(ret , ringd);\n    //bar\n    vec3 bpos = pos;\n    bpos.z = abs(bpos.z);\n    float bar1 = udRoundBox(bpos-vec3(0.,0.4,1.5),vec3(.46,0.01,0.04),0.01);\n    ret = min(ret , bar1);\n    \n    // roof\n   \tvec3 q1=pos-vec3(0.,0.65,0.);\n    vec3 roofSize = vec3(0.65,1.0,0.7);\n    float roof = sdHalfCylinder(q1,roofSize);\n    ret = min(ret , roof);\n    \n    //pos.x= abs(pos.x);//!! it is strange that i cann't use pos.x= abs(pos.x) to simplify the code\n    vec3 padPos = pos;\n    //padPos.x = abs(pos.x);\n    float paddingT = sdPin( padPos - vec3(-0.65,0.42,0.),vec3(8,0.02,0.003));\n    ret = min(ret , paddingT);\n    padPos.x = -pos.x;\n    paddingT = sdPin( padPos - vec3(-0.65,0.42,0.),vec3(8,0.02,0.003));\n    ret = min(ret , paddingT);\n    \n    return ret;\n}\n\n\n#define BridgeL 40.\n#define BridgeW 2.\n#define BridgeH 4.\n\n#define BridgeL1 50.\n\n\n#define LegGap (BridgeW*0.45)\n#define LegWid 0.1\n#define LegLenGap LegGap * 4.\n\n#define BoardLen  0.2\nfloat BridgeSeg1(float mindist,in vec3 pos){\n    float dis= 0.;\n\t\n    // bridge leg\n    vec3 legPos = pos;\n    legPos.z -= LegLenGap * 0.5;\n    if( legPos.z < BridgeL-LegLenGap && legPos.z >0.){\n    \tlegPos.z = mod(legPos.z- LegLenGap * 0.5,LegLenGap) - LegLenGap * 0.5;\n    }\n    \n   \tdis = sdCylinder( vec3(abs(legPos.x),legPos.yz)-vec3(LegGap,0.,0.0), vec2(LegWid,BridgeH) );\n    mindist = min( dis, mindist );\n    \n    dis = sdBox( legPos-vec3(0.,BridgeH*0.8,0.0), vec3(LegGap*0.95,LegWid*0.7,LegWid*0.7) );\n    mindist = min( dis, mindist );\n    \n    // bridge face\n    vec3 facePos = pos;\n    dis = sdBox( facePos-vec3(0.,BridgeH,BridgeL*0.5 ), vec3(BridgeW,LegWid*0.7,BridgeL*0.5) );\n    mindist = min( dis, mindist );\n    \n    vec3 boardPos = pos;\n    if( boardPos.z < BridgeL && boardPos.z >0.){\n    \tboardPos.z = mod(boardPos.z,BoardLen)- BoardLen * 0.5;\n    }\n    dis = sdBox( boardPos-vec3(0.,BridgeH + .1,0.), vec3(BridgeW,0.1,BoardLen*0.3));\n    //dis = sdSphere( boardPos-vec3(0.,BridgeH + 4.,BridgeL*0.5),vec4(0.,0.,0.,0.5));\n    //dis = sdSphere( boardPos, vec4(0.,BridgeH,0.,0.5) );\n    mindist = min( dis, mindist );\n   \n    return mindist;  \n}\n\nfloat BridgeSeg2(float mindist,in vec3 pos){\n    float dis= 0.;\n\tpos.z -= BridgeL;\n    pos.xz = pos.zx;\n    pos.z = -pos.z;\n    pos.z += BridgeW;\n    \n    return BridgeSeg1(mindist,pos);\n}\nfloat sdBridge( in vec3 pos )\n{\n    pos*=3.;\n\tfloat mindist = 10000000.0;\n\t\n    float f = 0.5;//-0.5*cos(3.14159*pos.z/20.0);\n\tmindist = BridgeSeg1(mindist,pos);\n  \tmindist = BridgeSeg2(mindist,pos);\n\treturn 0.25*mindist;\n}\n\n\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( sdPlane(     pos), 1.0 );\n    res = opU( res, vec2( sdBounceBalls( pos),1.) );\n    res = opU( res, vec2( sdBridge( pos),1.) );\n    pos -=vec3(-1,0.,-.5);\n    \n    float deg = 1.*3.14159/180.;\n    pos = rY(pos,sin(deg),cos(deg));\n    res = opU( res, vec2( sdBoat( pos),1.) );\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n   \n\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<40; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 10.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat remap(float a,float b ,float c, float d,float v){\n\treturn ((v-a)/(b-a))*(d-c)+ c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    \n    vec3 tot = vec3(0.0);\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    #define Deg2Rad (3.14159/180.)\n    #define Rad2Deg (180./3.14159)\n\t\n    float deg = 0.1*time + 6.0*mo.x;\n    deg = remap(0.,360.,-230.,40.,mod(deg,6.28318) * Rad2Deg) * Deg2Rad;\n    \n    // -230 ~40\n    //deg = Deg2Rad*40.;\n    float radius = 4.8;\n    // camera\t\n    vec3 ro = vec3( radius*cos(deg), 1. + 2.0*mo.y, radius*sin(deg) );\n    vec3 ta = vec3( -0.5, .1, 0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n    // gamma\n    col = pow( col, vec3(0.4545) );\n\n    tot += col;\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3fWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[278, 388, 410, 410, 532], [664, 664, 689, 689, 704], [706, 706, 741, 741, 767], [769, 769, 800, 800, 891], [894, 894, 939, 939, 981], [983, 983, 1016, 1016, 1071], [1075, 1075, 1111, 1111, 1210], [1283, 1283, 1316, 1316, 1342], [1344, 1344, 1374, 1374, 1407], [1409, 1409, 1439, 1439, 1468], [1470, 1470, 1500, 1500, 1529], [1531, 1531, 1555, 1555, 1687], [2031, 2031, 2072, 2072, 2165], [2438, 2438, 2523, 2523, 2815], [2819, 2819, 2849, 2849, 3149], [3151, 3151, 3182, 3182, 3764], [3767, 3767, 3807, 3807, 4020], [4021, 4021, 4053, 4053, 4230], [4232, 4232, 4256, 4256, 4515], [4517, 4517, 4540, 4540, 6146], [6333, 6333, 6377, 6377, 7496], [7498, 7498, 7542, 7542, 7686], [7687, 7687, 7718, 7718, 7910], [7914, 7914, 7939, 7939, 8253], [8255, 8255, 8295, 8295, 8622], [8625, 8625, 8703, 8703, 8963], [8965, 8965, 8997, 8997, 9205], [9207, 9207, 9249, 9249, 9548], [9550, 9626, 9662, 9683, 9906], [9908, 9908, 9947, 9947, 11649], [11651, 11651, 11703, 11703, 11880], [11882, 11882, 11937, 11937, 11971], [11972, 11972, 12029, 12029, 12872]], "test": "error"}
{"id": "XdcfWn", "name": "Easyp Tiling", "author": "easyp", "description": "Basic", "tags": ["basic"], "likes": 1, "viewed": 65, "published": "Public", "date": "1524596123", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float scale = 4.f;\nconst vec2 speed = vec2(-0.8, 0.8);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / iResolution.x);\n\n    vec3 col = vec3(0.);\n    \n    vec2 st = fract((uv * scale) + iTime * speed);\n    \n    col.r = st.x;\n    col.g = st.y;\n    \n    vec2 p = vec2(0.5, 0.5);\n    col.b = 1. - step(distance(p, st), 0.4);\n    \n    col *= (1. - (step(0.98, st.x) + step(st.x, 0.01))) * (1. - (step(0.99, st.y) + step(st.y, 0.01)));\n    \n    // Output to screen\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdcfWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 119, 119, 534]], "test": "ok"}
{"id": "XddBD8", "name": "helix 4 (DNA)", "author": "FabriceNeyret2", "description": "WIP:   why are the stems noisy ? ( relates to d )\n\nref: [url] https://en.wikipedia.org/wiki/DNA [/url]", "tags": ["raymarching", "sdf", "spiral", "helix", "spring", "dna", "short"], "likes": 3, "viewed": 439, "published": "Public API", "date": "1524915810", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of \"helix 3b\" https://shadertoy.com/view/XddfW8\n//        and \"helix 2c\" https://www.shadertoy.com/view/4ddfW8\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t = iTime,l,a,d,v, r = 50., n = 3.82, // 24/2pi\n          A = 2.38, H = 4.*cos(A/2.); // A=2.1\n    mat2  R = mat2( sin(t+vec4(0,33,11,0)) );\n    vec3  q = iResolution,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),     // ray direction\n          p = 30./q, c;                        // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p,\n        q.xz *= R, q.yz *= R,                  // rotation\n   //   c = q, c.x+=r, a = atan(c.z,c.x), q.x = length(c.xz)-r, q.z = r*a,// global curvature\n        l = length(q.xy), a = atan(q.y,q.x), d = a-q.z,\n        d = min(v=abs( mod(d  ,6.28) -3.14), \n                  abs( mod(d-A,6.28) -3.14)),  // double strand (2pi/3)\n        t = length(vec3(l-4.,d,fract(n*a)-.5)) - .3,  // spheres along double spring\n        d = a-round(q.z*n)/n-A/2. -3.14 +.5/n,\n        t = min(t, v=max(l-4.,(length(vec2((fract(q.z*n-.5)-.5)/n, l*cos(d)-H ))-.05)/n)),// rods\n        p += t*D;                              // step forward = dist to obj\n\n // if (cos(a-q.z)<0.) O.gb *= .9; else O.rg *= .9;   // colored strands\n    if (t==v) O.rg *= .9; else O.gb *= .9;       // colored rods vs spheres\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XddBD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 159, 159, 1340]], "test": "error"}
{"id": "XddBR8", "name": "Simple light and shadow", "author": "darkeclipz", "description": "Testing a simple light and shadow with a circle. ", "tags": ["2d", "shadow", "testing", "light"], "likes": 3, "viewed": 126, "published": "Public", "date": "1524240779", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Circle line segment collision from:\n// https://stackoverflow.com/questions/1073336/circle-line-segment-collision-detection-algorithm\n\nstruct circle { vec2 pos; float r; };\n\nbool inCircle(vec2 uv, vec2 xy, float r) {\n\treturn length(xy-uv) < r;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-R/2.)/R.y;\n    vec3 col = vec3(0);\n    \n    // Light source\n    vec2 Lpos = vec2(0., 0.);\n    vec2 L = uv - Lpos;\n    \n    // Circle\n    circle C = circle(vec2(cos(iTime)/3., sin(iTime)/3.), 0.1);\n\n\tvec2 E = uv;\t \t// Ray start pos\n    vec2 d = L;\t\t    // Ray end pos\n    vec2 f = C.pos-uv;\t// Direction vector of start pos and circle center.\n    \n    // Solve y=ax^2+bx+c\n    float a = dot(d,d);\t\t\t\t// d dot d\n    float b = 2. * dot(d, f);\t\t// 2 * d dot f\n    float c = dot(f, f) - C.r*C.r;\t// f dot f - r^2\n    \n    float discr = b*b-4.*a*c; // discr < 0; no intersection\n    \t\t\t\t\t\t  // discr = 0; 1 intersection\n    \t\t\t\t\t\t  // discr > 0; 2 intersections\n    \n    // next time: check for t1, t2, and determine real intersection.\n    // https://stackoverflow.com/questions/1073336/circle-line-segment-collision-detection-algorithm\n\n\t// Background light color\n    col = mix(col, vec3(1), 0.20-length(L)/32.);\n    \n    // Light source\n    col = mix(col, vec3(1), inCircle(uv, Lpos, 0.1) ? 1.-length(uv-Lpos)/.1 : 0.);\n    col = mix(col, vec3(1), inCircle(uv, Lpos, 0.05) ? 1.-length(uv-Lpos)/.05 : 0.);\n    col = mix(col, vec3(1), inCircle(uv, Lpos, 0.02) ? 1.-length(uv-Lpos)/.03 : 0.);\n    \n    // Light\n    col = mix(col, vec3(1), .15 * max(0., 1.-length(uv-Lpos)/.80));\n    col = mix(col, vec3(1), .15 * max(0., 1.-length(uv-Lpos)/.40));\n    col = mix(col, vec3(1), .15 * max(0., 1.-length(uv-Lpos)/.20));    \n    \n    // Shadow\n    col = mix(col, vec3(0), discr > 0. \n              \t\t\t \t&& length(Lpos-uv) > length(Lpos-C.pos)\n              \t\t\t\t&& length(Lpos-uv) > length(C.pos-uv) ? .50 : 0.); \n    \n    // Circle\n    col = mix(col, vec3(1), float(inCircle(uv, C.pos, C.r)));\n    col = mix(col, vec3(0), float(inCircle(uv, C.pos, C.r-0.005)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XddBR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 218, 218, 250], [252, 252, 309, 359, 2220]], "test": "ok"}
{"id": "XddfDH", "name": "Julia Set Fractal - Self moving", "author": "Alazorth", "description": "Attempting a Julia Set Fractal with smooth coloring. Click and drag on the fractal to change the c value.", "tags": ["fractal", "juliaset"], "likes": 0, "viewed": 80, "published": "Public", "date": "1524955043", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#ifdef GL_ES\n#define MAX_ITER 1000\n\n\n//z starts with an initial value of the pixel(c1) and then you \n//add c2 in the iteration which can \n//be a constant or mouse position\n\nfloat fJulia(vec2 c1, vec2 c2){\n    float l = 0.;\n    vec2 z = c1;\n    float B = 256.;\n    for(float i=0.;i<float(MAX_ITER);i++) {\n        if (z.x*z.x + z.y*z.y > 4.) {\n        \treturn l;\n            break;\t\n        }\n        float xtemp = z.x*z.x-(z.y*z.y);\n        z.y = 2.*z.x*z.y + c2.y;\n        z.x = xtemp + c2.x;\n        l+=1.;\n    }\n    float sl = l - log(log(length(z))/log(B))/log(2.0);\n    return sl;\n    //return l;\n}\n\nvec3 trueCmap(float n)\t{  \n    // GLSL has it's own syntax for creating arrays . . .\n    if (n == float(MAX_ITER)){\n    \tvec3 black = vec3(0.,0.,0.); \n        return black;\n    }\n    vec3 cMap[7] = vec3[7](vec3(0.,0.,0.), vec3(1.,0.,1.), vec3(0.,0.,1.), vec3(0.,1.,0.), vec3(1.,1.,0.), vec3(1.,0.5,0.), vec3(0.,0.,0.)) ;\n    \n    float quotient = float(cMap.length()) * n / float(MAX_ITER);\n    float lowerIndex = floor(quotient);\n    float upperIndex = ceil(quotient);\n    highp int lIndex = int(lowerIndex);\n    highp int uIndex = int(upperIndex);\n    float fraction = quotient - lowerIndex;\n    vec3 c = cMap[lIndex] + fraction * (cMap[uIndex] - cMap[lIndex]);\n    \nreturn c;\n}\n\n\nvec4 nmap(float n) {\n\tvec3 colmap;\n    if (float(n) <= float(MAX_ITER)) {\n        float quotient = float(n) / float(MAX_ITER);\n        float color = clamp(quotient,0.,1.);\n        \tif (quotient > 0.5) {\n        \t// Close to the mandelbrot set the color changes from green to white \n \t\t\t\tcolmap = vec3(0.); //(color,1.,color);\n        \t}\n        \telse {\n                colmap = vec3(0.,color,0.);\n            }\n    }\n    return vec4(colmap,1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = fragCoord.xy/iResolution.xy;\n    //float aspect = iResolution.y/iResolution.x;\n    //vec2 p = uv*2.-1.;\n    //p.y*=aspect;\n    //float n = fJulia(p*2.);\n    vec2 p = (2.*fragCoord - iResolution.xy)/iResolution.x;\n    vec2 mousein = (2.*iMouse.xy - iResolution.xy)/iResolution.x;\n    vec2 automove = vec2(sin(iTime)-0.3,cos(iTime))*3./4.; //vec2(sin(0.1*iTime),cos(0.1*iTime));\n    //vec2 c2 = vec2(-0.88,-0.23);\n    float iCount = fJulia(2.*p, automove);\n    fragColor = vec4(trueCmap(iCount*2.),1.);\n \t//fragColor = nmap(iCount*2.),1.;   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XddfDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 206, 206, 604], [606, 606, 630, 690, 1286], [1289, 1289, 1309, 1309, 1735], [1738, 1738, 1795, 1964, 2353]], "test": "ok"}
{"id": "XddfDr", "name": "fourier convergence transitions", "author": "akhgary", "description": "visualization of fourier series for square, triangle and sawtooth waves.\n\nspecial thanks to FabriceNeyret2.", "tags": ["wave", "triangle", "visualization", "animation", "square", "plot", "convergence", "fourier", "squarewave", "trianglewave", "sawtooth", "series", "sawtoothwave"], "likes": 19, "viewed": 514, "published": "Public", "date": "1524743124", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fourier series:\n// https://en.wikipedia.org/wiki/Fourier_series#Convergence\n//\n// ========================================\n// Square wave:\n// http://mathworld.wolfram.com/FourierSeriesSquareWave.html\n//\n// Triangle wave:\n// http://mathworld.wolfram.com/TriangleWave.html\n//\n// Sawtooth wave:\n// http://mathworld.wolfram.com/SawtoothWave.html\n//\n// ========================================\n// distance formula used to plot waves smoothly\n// d = |fx-y|/sqrt(1+(dfx/dx)^2)\n// http://www.iquilezles.org/www/articles/distance/distance.htm\n// ========================================\n//\n// hue color picker taken from :\n// https://www.shadertoy.com/view/ll2cDc\n//\n// following function is used for smooth transition:\n// https://math.stackexchange.com/questions/2746958/smooth-floor-function\n\nconst float pi = 3.14159265359;\nconst float scale = 2.0;\nconst float thickness = 3.0*scale;\n\nconst float duration = 12.0; // duration visualizing each wave in seconds.\nconst float transition = 5.0; // transition speed. (dont know the unit) \n                              // but 1.0 means transition takes half of duration.\n                              // so it takes half of duration to make \"n\" terms\n                              // and another half of duration to remove \"n\" terms\n\nconst int terms = 10; // number of terms to produce\nconst float freq = 0.795; // frequency in hz\nconst float len = 2.0; // length of the wave. (period)\nconst float amp = 1.0; // amplitude of the wave.\n\nvec2 uvmap(vec2 uv)\n{\n    return (2.0*uv - iResolution.xy)/iResolution.y;\n}\n\n// color picker:\n// https://www.shadertoy.com/view/ll2cDc\nvec3 pickColor(float n) {\n    return 0.6+0.6*cos(6.3*n+vec3(0,23,21));\n}\n\nfloat smoothout(float dist){\n    return smoothstep(thickness/iResolution.y,0.0,dist);\n}\n\nfloat circle(vec2 uv, vec2 C, float r, bool fill)\n{\n    vec2 p = uv-C;\n    float fx = length(p)-r;\n    float dist = fill? fx:abs(fx);\n    return smoothout(dist);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a, ba = b - a; \n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float dist = length(pa - ba * h);\n    return smoothout(dist);\n}\n\n// ==================Square Wave===================== \nfloat squarewave(float n, float x, float l, float phase){\n    n = n*2.0+1.0;\n    return amp*4.0/(n*pi)*sin(n*pi*x/l+phase);\n}\n\n// derivative of series terms.\nfloat dsquarewave(float n, float x, float l, float phase){\n    n = n*2.0+1.0;\n    return amp*4.0/l*cos(n*pi*x/l+phase);\n}\n\n// ===================Triangle Wave==================\nfloat trianglewave(float n, float x, float l, float phase){\n    float k = n*2.0+1.0;\n    return amp*8.0/(pi*pi)/(k*k)*cos(pi*n)*sin(k*pi*x/l+phase);\n}\n\nfloat dtrianglewave(float n, float x, float l, float phase){\n    float k = n*2.0+1.0;\n    return amp*8.0/pi/(k*l)*cos(pi*n)*cos(k*pi*x/l+phase);\n}\n\n// ====================Sawtooth Wave===================\nfloat sawtoothwave(float n, float x, float l, float phase){\n    n++;\n    return amp*2.0/(pi*n)*sin(n*pi*x/l+phase);\n}\n\nfloat dsawtoothwave(float n, float x, float l, float phase){\n    n++;\n    return amp*2.0/l*cos(n*pi*x/l+phase);\n}\n\n// ====================Wave switch===================\nfloat wave(float n, float x, float l, float phase){\n    switch(int(mod(iTime, duration*3.0) / duration))\n    {\n        case 0: return squarewave(n,x,l,phase);\n        case 1: return sawtoothwave(n,x,l,phase);\n        case 2: return trianglewave(n,x,l,phase);\n    }\n}\n\n// derivative of series terms.\nfloat dwave(float n, float x, float l, float phase){\n    switch(int(mod(iTime, duration*3.0) / duration))\n    {\n        case 0: return dsquarewave(n,x,l,phase);\n        case 1: return dsawtoothwave(n,x,l,phase);\n        case 2: return dtrianglewave(n,x,l,phase);\n    }\n}\n// =======================================\n\n// used for smooth transitions\nfloat smoothfloor(float x) {\n    return x - sin(2.0*pi*x)/(2.0*pi);\n}\n\n// maps sin wave with amplitude [-1,1]    and period 2*pi\n// to   sin wave with amplitude [0,terms] and period duration\nfloat clock(){\n    return float(terms)/2.0*(1.0 - cos(iTime*2.0*pi/duration));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = uvmap(fragCoord.xy)*scale;\n    vec3 col = vec3(0);\n        \n    float l = len/2.0; // wave length divided by two.\n    vec2 c = vec2(0); // center of the circles\n    float sum = 0.0; // fourier series sum\n    float dsum = 0.0; // derivative of the sum\n    float tsum = 0.0; // sum for red line\n    \n    float smfloor = smoothfloor(clock()*transition);\n    float time = iTime*freq;\n    \n    for(int i=0; i<terms; i++) {\n        float n = float(i);\n        vec3 color = pickColor(n/float(terms));\n        \n        float mul = clamp(smfloor - n,0.0,1.0);\n        \n        // calculate fourier series terms for circles\n        float term = wave(n, time, l, 0.0)*mul;\n        float cterm = wave(n, time, l, pi/2.0)*mul;\n        vec2 r = vec2(cterm,term);\n        \n        // plot circles\n        col += circle(uv,c,length(r),false)*color;\n        col += line(uv,c, c += r)*color;\n        \n        // calculate fourier series terms for wave plot\n        sum += wave(n, time-uv.x+len/2.0, l, 0.0)*mul;\n        dsum += dwave(n, time-uv.x+len/2.0, l, 0.0)*mul;\n        tsum += term;\n    }\n    \n    // wave plot\n    float dist = abs(uv.y-sum)/sqrt(1.0+dsum*dsum);\n    col+=smoothout(dist);\n\n    // red line\n    col+=(line(uv,c,vec2(+l,c.y))\n        + line(uv,c,vec2(-l,c.y))\n        + circle(uv,vec2(+l,tsum),0.01,true)\n        + circle(uv,vec2(-l,tsum),0.01,true))*vec3(1,0,0);\n    \n    // grid lines\n    col+=(smoothout(abs(uv.y+amp))\n        + smoothout(abs(uv.y-amp))\n        + smoothout(abs(uv.x+l))\n        + smoothout(abs(uv.x-l)))*vec3(0.25);\n    \n    // output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XddfDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1477, 1477, 1498, 1498, 1552], [1554, 1612, 1637, 1637, 1684], [1686, 1686, 1714, 1714, 1773], [1775, 1775, 1826, 1826, 1938], [1940, 1940, 1976, 1976, 2136], [2138, 2193, 2250, 2250, 2318], [2320, 2351, 2409, 2409, 2472], [2474, 2528, 2587, 2587, 2678], [2680, 2680, 2740, 2740, 2826], [2828, 2884, 2943, 2943, 3001], [3003, 3003, 3063, 3063, 3116], [3118, 3172, 3223, 3223, 3438], [3440, 3471, 3523, 3523, 3741], [3786, 3817, 3845, 3845, 3886], [3888, 4008, 4022, 4022, 4088], [4090, 4090, 4147, 4147, 5763]], "test": "error"}
{"id": "XdGcWd", "name": "ascending", "author": "airtight", "description": "radial gradient + shepard tone ∞\n\nFULL SCREEN PLZ\n\n\n", "tags": ["ascending"], "likes": 1, "viewed": 128, "published": "Public", "date": "1523657277", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//TRIANGLE WAVE\nfloat tri(float x) {\n    return abs(2.0 * fract(x) - 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;    \n    float rx = tri(length(uv) + iTime * 0.6) ;\n    fragColor = vec4(vec3(rx),1.0);\n}", "image_inputs": [{"id": "XlSGzt", "previewfilepath": "https://soundcloud.com/shepard-tone/shepard-tone-1", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/shepard-tone/shepard-tone-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdGcWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 16, 36, 36, 76], [78, 78, 135, 135, 320]], "test": "ok"}
{"id": "XdGyRt", "name": "Shaders are the new Rasterbars", "author": "DonTom", "description": "Shaders a the new Rasterbars", "tags": ["tunnel"], "likes": 2, "viewed": 93, "published": "Public", "date": "1522863225", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.1415;\nfloat EPSILON = 0.001;\nconst int marchSteps = 50;\n\nstruct light {\n    vec3 pos;\n    vec3 dir; //(0,0,0) means point\n    vec3 color;    \n}; \nstruct distPoint {\n\tfloat dist;\n    vec3 p;\n    //vec4 c;\n};\n        \nvec4 tunnel(in vec2 origin){    \n    vec2 uv = origin;\n    float zoom = 1.0 * (0.9 + 0.1 * sin(iTime));\n    float speed = 1.2;\n    \n    float r = sqrt(uv.x*uv.x + uv.y*uv.y);\n    \n    if ( r > 0.0) {\n        vec2 xy = vec2(\n        \t(.5/r)+iTime*speed\n            ,\n            0.2*sin(iTime)+2.0*sin(iTime*0.2)+5.0*(uv.x > 0.0 ? atan(uv.y/uv.x)/2.0/PI : atan(uv.y/uv.x)/2.0/PI + 0.5)\n        \t);\n        return vec4(texture(iChannel0,xy)*1.5*r);    \n    } else {return vec4(0,0,0,1.0);\n        \n    }        \n}\n\ndistPoint distSphere(vec3 p, float radius){\n\treturn distPoint(\n        length(p) - radius,\n        p\n        );\n}\n                      \ndistPoint unionP(distPoint dp1, distPoint dp2){\n    if(dp1.dist > dp2.dist) return dp2; else return dp1;    \n}\n\ndistPoint intersectP(distPoint dp1, distPoint dp2){\n    if(dp1.dist < dp2.dist) return dp2; else return dp1;    \n}\n\ndistPoint subtractP(distPoint dp1, distPoint dp2){\n\tif(dp1.dist < -1.*dp2.dist) return dp2; else return dp1;\n}\n\nvec4 saturate4(vec4 color){\n\tcolor = vec4(\n    \tmin(color.x,1.),\n        min(color.y,1.),\n        min(color.z,1.),\n        min(color.a,1.)\n    );\n        \n    return vec4(\n        max(color.x,0.),\n        max(color.y,0.),\n        max(color.y,0.),\n        max(color.a,0.)   \n    );\n        \n}\n\nfloat saturate(float val){\n\tval = min(val,1.);\n    return max(val,0.);\n}\n\ndistPoint distScene(vec3 p){\n    \n    return /*subtractP(\n        unionP(\n    \t\tunionP(\n            \tdistSphere(p-vec3(5.* sin (-iTime-0.*PI), 2. * sin(iTime*.5), 30. + 5.* cos(-iTime-0.*PI)),1.5),\n            \tdistSphere(p-vec3(5.* sin (-iTime-0.5*PI), 2. * sin(iTime*.5), 30. + 5.* cos(-iTime-0.5*PI)),1.5)    \n        \t),\n            unionP(\n                distSphere(p-vec3(5.* sin (-iTime-1.*PI), 2. * sin(iTime*.5), 30. + 5.* cos(-iTime-1.*PI)),1.5),\n            \tdistSphere(p-vec3(5.* sin (-iTime-1.5*PI), 2. * sin(iTime*.5), 30. + 5.* cos(-iTime-1.5*PI)),1.5) \n            )\n        ),*/\n        unionP(\n            unionP(\n            \tdistSphere(p-vec3(5.* sin (iTime+0.*PI), 2. * sin(iTime*.5), 30. + 5.* cos(iTime+0.*PI)),2.),\n            \tdistSphere(p-vec3(5.* sin (iTime+0.5*PI), 2. * sin(iTime*.5), 30. + 5.* cos(iTime+0.5*PI)),2.)    \n        \t),\n            unionP(\n                distSphere(p-vec3(5.* sin (iTime+1.*PI), 2. * sin(iTime*.5), 30. + 5.* cos(iTime+1.*PI)),2.),\n            \tdistSphere(p-vec3(5.* sin (iTime+1.5*PI), 2. * sin(iTime*.5), 30. + 5.* cos(iTime+1.5*PI)),2.) \n            )\n        \n        //) \n    );\n    \n}\n\nvec3 normScene(vec3 p){\n    return normalize(vec3(\n        distScene(vec3(p.x + EPSILON, p.y, p.z)).dist - distScene(vec3(p.x - EPSILON, p.y, p.z)).dist,\n        distScene(vec3(p.x, p.y + EPSILON, p.z)).dist - distScene(vec3(p.x, p.y - EPSILON, p.z)).dist,\n        distScene(vec3(p.x, p.y, p.z  + EPSILON)).dist - distScene(vec3(p.x, p.y, p.z - EPSILON)).dist\n    ));\n}\n\nvec4 colorScene(vec3 p, vec3 eyePos, light[2] lights){\n\tvec3 lightVec; \n    vec3 normal = normScene(p);\n    float intens = .5;\n    vec4 color = vec4(.4,.0,.0,1.); //ambient light\n    for(int i = 0; i < 2; i++){\n        //punktlicht\n        color += saturate4(\n            length(lights[i].color) \n            * saturate(\n                dot(normal,normalize(lights[i].pos - p))\n                ///length(lights[i].pos - p)) \n                )\n            * vec4(1.,.0,0.,1.)\n    \t);\n        color += saturate4(\n            pow(\n                saturate(\n                \tdot(\n                    \tnormalize(normalize(eyePos - p) + normalize(lights[i].pos-p)) , //halber Winkel zwichen licht und sicht\n                    \tnormal\n                \t)///length(lights[i].pos - p)\n                )\n                ,pow(10.,2.5))\n            * vec4(1,1,1,1)\n            );\n        \n        //paralell\n        //color += length(lights[i].color) * skalar(normal,normalize(lights[i].pos)) * vec4(.5,0,0,1.);\n    \t\n    }\n    return color;\n}\n\nvec4 march(in vec2 uv){\n\tvec3 camPos = vec3(0,0,-5);\n    \n    vec3 lightPos = vec3(-5,-5,30);//40.+30.*sin(iTime));\n    vec3 lightPos2 = vec3(5,5,30);//40.-30.*sin(iTime*2.));\n    light lights[2];\n    lights[0] = light(lightPos,vec3(0,0,0),.25*vec3(1,1,1));\n    lights[1] = light(lightPos2,vec3(0,0,0),.25*vec3(1,1,1));\n   \n    float viewPortDistance = 2.0;\n    \n    vec3 viewRay = normalize(vec3(uv,viewPortDistance));\n    \n    //march\n    \n    float dist = 1.0;\n    vec3 p = camPos + viewRay * dist;\n    for (int i = 0; i < marchSteps; i++){\n        \n        dist = distScene(p).dist;\n        if (dist < EPSILON){\n        \treturn colorScene(p,camPos, lights);\n        }\n        p += dist*viewRay; \n    }\n    \n    //sonst tunnel\n    uv = uv + vec2(0.2*cos(iTime*1.1),0.2*sin(iTime));\n    return tunnel(uv);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    // Normalized pixel coordinates (from -.5 to +.5 in x)\n    vec2 uv = fragCoord/iResolution.xy.x-vec2(0.5,iResolution.xy.y/iResolution.xy.x/2.0);\n\tfragColor = march(uv);     \n}\n\n    \n\n\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdGyRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[229, 229, 257, 257, 740], [742, 742, 785, 785, 855], [879, 879, 926, 926, 989], [991, 991, 1042, 1042, 1105], [1107, 1107, 1157, 1157, 1217], [1219, 1219, 1246, 1246, 1510], [1512, 1512, 1538, 1538, 1584], [1586, 1586, 1614, 1614, 2738], [2740, 2740, 2763, 2763, 3109], [4144, 4144, 4167, 4167, 4956], [4958, 4958, 5015, 5076, 5197]], "test": "error"}
{"id": "XdGyWG", "name": "space warp", "author": "bozhkov", "description": "transformation+tiling exercise", "tags": ["warp"], "likes": 6, "viewed": 285, "published": "Public", "date": "1523035805", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec2 rotate2D(vec2 _st, float _angle){\n    // _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    // _st += 0.5;\n    return _st;\n}\n\nvec2 tile(vec2 _st, float _zoom){\n    _st = _st*.5+.5;\n    _st *= _zoom;\n    return fract(_st);\n}\n\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n    _size = -_size*.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_st);\n    uv *= smoothstep(_size,_size+aa,-_st);\n    return uv.x*uv.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (fragCoord.xy*2.-iResolution.xy)/iResolution.x;\n    vec3 c = hsb2rgb(vec3(.06, .86,1.));\n    \n    float r = length(st)*1.;\n    float s = pow(abs(cos(r*2.-iTime*3.)),9.)*.1;\n    st *= 1.-s;\n    st = tile(st,25.);\n    st = st*2.-1.;\n    \n    vec3 color = c;\n    st = rotate2D(st,PI*0.25);\n\t\n    color *= vec3(box(st,vec2(.6),0.1));\n    st = rotate2D(st,PI*.75);\n    float w = .2;\n    color += (c-color)*vec3(box(st,vec2(w, 2.1),.1));\n    st = rotate2D(st,PI*.5);\n    color += (c-color)*vec3(box(st,vec2(w, 2.1),.1));\n    color += s*color*15.;\n\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdGyWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 60, 60, 293], [295, 295, 333, 352, 479], [481, 481, 514, 514, 578], [580, 580, 632, 632, 806], [808, 808, 865, 865, 1456]], "test": "ok"}
{"id": "XdKcWG", "name": "Hypnosis spiral", "author": "rory618", "description": "Spiral effect from https://www.youtube.com/channel/UCfQ_5i_x0r5OOUvt7Wygx7g", "tags": ["spiral"], "likes": 3, "viewed": 140, "published": "Public", "date": "1523149657", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define T(x) mat2(  cos(x+vec4(0,-pi,pi,0)/4.) )\n#define N(v,m,t)  ( round ( (v)*(m)+t ) - (t) ) / (m)\n#define R iResolution\nfloat pi = 6.283;\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    float r = -iTime*8.;\n    vec2 p = (I+I-R.xy)/R.y*T(r);\n\n\n    float n = length(p),\n     t = N( atan(p.y,p.x) +r , 80./pi ,0. ) -r, \n     d =  N( n, 14.+n*1.6, t/pi);\n    \n    O = vec4(1,0,.8,0) * \n        (1.-(\n            (1.2*(pow(dot(pow(abs(\n                (p-d*cos(t-vec2(0,pi/4.)))\n                *T(t+pi/4.)*vec2(d,.6)*T(pi/8.+pi/2e2)\n            ),vec2(1.2)),vec2(1)),1./1.2))\n            -.02*n)*R.y/4.\n            ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdKcWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 184, 184, 619]], "test": "error"}
{"id": "XdKyDt", "name": "2D Adventures #2 - Hex Grid", "author": "bombshell93", "description": "The purpose of this was to understand hexagonal coordinate systems in the context of a shader, I'd expected this to take a bit more fiddling, but I also don't want to over develop it, so I put in some mouse interaction for the fun of it.", "tags": ["2d", "mouse", "grid", "interactive", "hex", "hexagonal"], "likes": 5, "viewed": 825, "published": "Public", "date": "1523845788", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//// ABSTRACT\n//\n//\tThe purpose of this was to understand hexagonal coordinate systems in the\n//\tcontext of a shader, the ease of understanding is thanks in no small part\n//\tto the redblobgames blog on the subject:\n//\t\thttps://www.redblobgames.com/grids/hexagons/#distances\n//\n//\tI'd expected this to take a bit more fiddling, but I also don't want to over\n//\tdevelop this shader, as its fulfilling its purpose, so I put in some mouse\n//\tinteraction (click to see what I mean) for the fun of it.\n//\t\n//\n//// AUTHOR\n//\n//\tScott R Howell (bombshell93)\n\n#define PI 3.14\n#define PI2 6.28\n\n#define HX vec2(1., 0.)\n#define HY vec2(.5, 0.866)\n#define HMAT mat2(HX, HY)\n#define HSCALE 0.05\n\n//// pixelToCubial\n//\n//\tconverts a pixel coordinate to a hex grid cubial coordinates\n\nvoid pixelToCubial(vec2 uv, out vec3 cubial, out vec3 grid) {\n    \n    vec2 axial = inverse(HMAT) * uv;\n    cubial = vec3(axial, -axial.x - axial.y) / HSCALE;\n    grid = round(cubial);\n    vec3 dist = abs(cubial - grid);\n    if (dist.x > dist.y && dist.x > dist.z) {\n    \t\n        grid.x = -grid.y - grid.z;\n    }\n    else if (dist.y > dist.z) {\n        \n        grid.y = -grid.x - grid.z;\n    }\n    else {\n        \n        grid.z = -grid.x - grid.y;\n    }\n}\n\n//// cubialDistance\n//\n//\tfinds the distance between 2 hex cell positions\n\nfloat cubialDistance(vec3 a, vec3 b) {\n    \n    vec3 c = abs(a - b);\n    return max(c.x, max(c.y, c.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    // find cubial coordinates\n    \n    vec3 cubial;\n    vec3 grid;\n    vec3 mouse;\n    pixelToCubial((iMouse.xy - iResolution.xy * .5) / iResolution.y, cubial, mouse);\n    pixelToCubial(uv, cubial, grid);\n    \n    \n    // get per tile coordinates\n    \n    vec3 coord = cubial - grid;\n    vec3 dist = abs(coord.xyz - coord.zxy);\n    \n    vec3 col = cos(grid + iTime) * .5 + .5;\n    \n    // outline\n    \n    col *= smoothstep(.2, .2 + (2.0 / iResolution.y) / HSCALE, 1.0 - max(dist.x, max(dist.y, dist.z)));\n    \n    // react to mouse input\n    \n    float mouseDist;\n    if (iMouse.z > .0 && iMouse.w > .0 && (mouseDist = cubialDistance(grid, mouse)) < 4.) {\n        \n        float mouseDist = cubialDistance(grid, mouse);\n    \tcol = mix(col, vec3(1.), max(.0, sin(mouseDist - iTime * 4.) * .5 + .5));\n    }\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdKyDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[771, 771, 832, 832, 1229], [1306, 1306, 1344, 1344, 1412], [1414, 1414, 1471, 1471, 2391]], "test": "error"}
{"id": "XdtBzN", "name": "Fragance", "author": "lomateron", "description": "Wanted to make a noise texture\naccidentally put that last min() instead of max()\nwhat came out was look good so I added colors and some animation", "tags": ["colors", "abstract"], "likes": 5, "viewed": 492, "published": "Public API", "date": "1524277115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 f(vec2 u, float i)\n{\n    vec2 a = floor(u*.25)+i;\n    vec2 c = vec2(1.,1.123);\n    vec3 d = vec3(dot(a,c), dot(a+1.1,c), dot(a+2.1,c));\n    d = fract(sin(d)*1111.);\n    vec2 b = mod(u,vec2(4.))-1.-(sin(d.yz*iTime*2.)+1.);\n    return (fract(sin(d+5.22)*1111.)*.5+.25)/dot(b,b);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = 32.*fragCoord/iResolution.x+iTime*.5;\n    vec3 l = f(u,0.);\n    l = max(l, f(u+vec2(2.,0.),.11));\n    l = max(l, f(u+vec2(0.,2.),.22));\n    l = max(l, f(u+2.         ,.33));\n    l = min(l, f(u+1.         ,.44));\n    \n    fragColor = vec4(l,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdtBzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 283], [284, 284, 341, 341, 598]], "test": "ok"}
{"id": "XdtfW8", "name": "helix 3", "author": "FabriceNeyret2", "description": ".", "tags": ["raymarching", "sdf", "spiral", "helix", "spring", "dna", "short"], "likes": 0, "viewed": 319, "published": "Public API", "date": "1524903631", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/4sdBW8\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t = iTime,l,a,d;\n    mat2  R = mat2( sin(t+vec4(0,33,11,0)) );\n    vec3  q = iResolution,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),    // ray direction\n          p = 30./q;                          // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p,\n        q.xz *= R, q.yz *= R,                 // rotation\n        l = length(q.xy), a = atan(q.y,q.x), d = sin(a-q.z), // sin: double\n                               //  d = mod(a-q.z,6.28)-3.14, // mod: single\n        t = length(vec3(l-4.,d,fract(4.*a)-.5)) - .5,  // spheres along double spring\n        p += t*D;                             // step forward = dist to obj\n\n  // if (cos(a-q.z)<0.) O.gb *= .8; else O.rg *= .8; // 2 colored strands\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdtfW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 85, 85, 849]], "test": "error"}
{"id": "Xdtfzr", "name": "Kanizsa Triangle", "author": "fjavifabre", "description": "Another optical illusion", "tags": ["illusion", "perception"], "likes": 1, "viewed": 121, "published": "Public", "date": "1523967262", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// TODO: use 2D functions instead of just copying from\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define USE_WHITE 0 // Time varying pixel color\n#define AVOID_DISTORSIONS 1\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat circle( vec2 p, vec2 c, float radius) \n{\n    \n    return sqrt(pow(p.x-c.x, 2.) + pow(p.y-c.y, 2.)) - radius;\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n#if AVOID_DISTORSIONS\n    vec2 uv = fragCoord/iResolution.y;\n   \tuv.x += (iResolution.y - iResolution.x) \n        / max(iResolution.x,iResolution.y) ;\n#else    \n    vec2 uv = fragCoord/iResolution.xy;\n#endif    \n\n\n#if USE_WHITE\n    vec3 col = vec3(1.);\n#else\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n#endif\n    \n    // Geometry\n    float d0 = udTriangle(vec3(uv.xy, 0), vec3(.5,0.9,0), vec3(.2,.25,0), vec3(0.8,.25,0));\n   \tfloat d1 = udTriangle(vec3(uv.xy, 0), vec3(.5,0.1,0), vec3(.8,.7,0), vec3(0.2,.7,0));\n    float s0 = circle(uv.xy, vec2(0.2, 0.7), 0.1 );\n    float s1 = circle(uv.xy, vec2(0.8, 0.7), 0.1 );\n    float s2 = circle(uv.xy, vec2(0.5, 0.1), 0.1 );\n    \n    // Scene\n    if( d0 > 0. && d0 < 0.01)\n    \tfragColor = vec4(vec3(0),1.0);\n    else\n        fragColor = vec4(col,1.0);\n    \n    if(s0 <= 0. || s1 <= 0. || s2 <= 0. )\n        fragColor = vec4(vec3(0),1.0);\n    \n    if(d1 == 0.)\n        fragColor = vec4(col,1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdtfzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 228, 228, 247], [248, 248, 300, 300, 807], [809, 809, 855, 855, 934], [936, 936, 993, 1043, 2030]], "test": "ok"}
{"id": "XdVcDw", "name": "(Not as) Boring cube raymarching", "author": "Pr0fed", "description": "Playing with raymarching. Nothing interesting, move on :)", "tags": ["raymarching"], "likes": 0, "viewed": 89, "published": "Public", "date": "1524597016", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Materials\n#define LAMB 0\n#define METAL 1\n#define DIEL 2\n#define EMISSIVE 3\n\n#define NUM_OBJECTS 4\n\n#define PI  3.14159265359\n#define PI2 6.28318530717\n\n#define time iTime * 0.7\n\nstruct Material\n{\n\tint type;\n    vec3 albedo;\n    \n    // value corresponds to a material. \n    //\n    // Roughness for metal.\n    // Refract index for dielectrics.\n    // Color multiplier for current fake emission mat.\n    float v; \n};\n    \nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n// Spheres on scene declaration.\nMaterial materials[NUM_OBJECTS];\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p, c) - 0.5 * c;\n    return udRoundBox( q , vec3(0.15, 0.15, 0.15), 0.05);\n}\n\nvec2 map( in vec3 pos)\n{   \n    vec2 res = vec2(opRep(pos - vec3(0.0, 1.0, 2.0), vec3(1.1, 1.1, 1.1)), 1.0);\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd)\n{\n    float tmin = 1.0;\n    float tmax = 25.0;\n    \n    float t = tmin;\n    float m = -1.0;\n\n    for( int i = 0; i < 128; i++ )\n    {\n\t    float precis = 0.001 * t;\n\t    vec2 res = map( ro + rd * t);\n        \n        if( res.x < precis || t > tmax ) break;\n        \n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t > tmax ) m = - 1.0;\n    \n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 col = vec3(0.7, 0.1, 1.0) - rd.y * 2.2;\n    \n    vec2 res = castRay(ro, rd);\n    float t = res.x;\n\tfloat m = res.y;\n   \n    \n    if (m == 1.0)\n    {     \n        col = materials[0].albedo;\n        vec3 pos = ro + t * rd;\n    \tvec3 nor = calcNormal( pos );\n    \n    \tvec3  light = normalize( vec3(0.5, -0.5, -0.8) );\n    \tfloat dif = clamp( dot( nor, light ), 0.0, 1.0 );\n    \tcol = col * dif;\n    }\n    \n    return col * 2.;\n}\n\nvoid SetMaterials()\n{\n    materials[0] = Material(LAMB, vec3(0.0, 0.43, 0.82), 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    SetMaterials();\n    \n    vec2 uv = (fragCoord - .5 * iResolution.xy ) / iResolution.y;\n\n    vec3 ro = vec3(4.0 * sin(time * 0.1), 7.0 * cos(time * 0.1), 1.0 + time);\n    \n    // 'Look at' vector.\n    vec3 la = vec3(-1., .25, 1.) + vec3(.5 + cos(time * .7), 0.5 * cos(time), .5 + sin(time * .5));\n    \n    // Uncomment for mouse look.\n    //la = vec3(1., .25, 1.0) + vec3(-0.5 + iMouse.x / 50., -0.5 + iMouse.y / 50., 0.5);\n    \n    vec3 forward = normalize(la);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Final ray direction.\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n    \n    // render\t\n    vec3 col = render( ro, rd );\n    \n\t// gamma\n    col = pow( col, vec3(0.4545) );\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdVcDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[423, 423, 445, 445, 605], [674, 674, 719, 719, 759], [761, 761, 792, 792, 886], [888, 888, 912, 912, 1019], [1021, 1021, 1060, 1060, 1429], [1431, 1431, 1463, 1463, 1676], [1678, 1678, 1715, 1715, 2151], [2153, 2153, 2174, 2174, 2239], [2241, 2241, 2298, 2298, 3122]], "test": "ok"}
{"id": "XdVyW3", "name": "RC", "author": "menackni", "description": ".", "tags": ["raycast"], "likes": 2, "viewed": 371, "published": "Public API", "date": "1523638622", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float musB(float p){return texture(iChannel0,vec2(p,0.0)).x;}\n\n//perlin noise from here https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nfloat seed=42.0;\n\nfloat noise(vec3 P){\n  vec3 Pi0 = floor(P);\n  vec3 Pi1 = mod(Pi0+1.0, seed);\n       Pi0 = mod(Pi0, seed);\n  vec3 Pf0 = fract(P);\n  vec3 Pf1 = Pf0 - vec3(1.0);\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - .5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(.0));\n  gx0 -= sz0 * (step(.0, gx0) - .5);\n  gy0 -= sz0 * (step(.0, gy0) - .5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - .5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(.0));\n  gx1 -= sz1 * (step(.0, gx1) - .5);\n  gy1 -= sz1 * (step(.0, gy1) - .5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = inversesqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = inversesqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2. * n_xyz;\n}\n\nvec4 castRay(in vec3 eye,in vec3 ray,in float mDis) {\n    vec3 pos=eye+ray;\n    float t=.0;\n    float accamulate=.0;\n    vec3 pos2=eye+ray;\n    vec4 color;\n    float dis=length(eye-pos);\n    while(true){\n        dis=length(eye-pos);\n        if(dis>mDis){\n            break;\n        }\n        if(accamulate>.5){\n            return color;\n        }\n        float nois=noise((pos/1.7)-(vec3(.0,.0,1.0-musB(dis/6.0)*2.0)));\n        float fd=dis/mDis;\n        color=vec4(musB(dis/6.0)/1.5,\n                   fd-nois,\n                   dis,\n                   dis);\n        accamulate+=nois/8.0;\n        t+=.1;\n        pos=eye+ray*t;\n    }\n\n\treturn color;\n}\n\nmat2 rot2(float a){\n    return mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 r1=vec3(uv.x,uv.y,-1.0);\n    vec3 r=r1;r.xz*=rot2(0.25-sin(iTime*.3)/4.0);r.yz*=rot2(0.25-sin(iTime*.3)/8.0);\n    \n    vec3 o=vec3(0,0,iTime*1.0);\n    \n    float dis=8.0;\n    vec4 t1=castRay(o+r*3.0, r, dis);\n    \n    float fog=(t1.w/dis);\n    vec3 fogColor=1.0-vec3(musB(dis/16.0),musB(dis/8.0),musB(dis/4.0))/4.0;\n    fragColor=vec4(mix(t1.xyz,fogColor,fog),1.0);\n}", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdVyW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 61], [63, 154, 175, 175, 212], [213, 213, 232, 232, 268], [287, 287, 307, 307, 2431], [2433, 2433, 2486, 2486, 3086], [3088, 3088, 3107, 3107, 3156], [3158, 3158, 3215, 3215, 3658]], "test": "error"}
{"id": "Xdyyzd", "name": "Spiral pulse aura", "author": "bozhkov", "description": "Mixing a spiral with a pulsing wave\nLooks nice for an aura or something", "tags": ["2d", "pulse", "spiral", "circle", "aura"], "likes": 11, "viewed": 418, "published": "Public", "date": "1522892941", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec2 rotate2D (vec2 _st, float _angle) {\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.x;\n    p *= 1.6;\n    vec3 color = hsb2rgb(vec3(fract(iTime*.1),1.,1.));\n    float r = length(p);\n    float w = .3;\n    p = rotate2D(p,(r*PI*6.-iTime*2.));\n    color *= smoothstep(-w,.0,p.x)*smoothstep(w,.0,p.x);\n    color *= abs(1./(sin(pow(r,2.)*2.-iTime*1.3)*6.))*.4;\n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdyyzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 52, 52, 285], [287, 287, 327, 327, 435], [437, 437, 494, 494, 855]], "test": "ok"}
{"id": "Xl2BRh", "name": "Outrun Sunset", "author": "aflesher", "description": "An outrun sunset", "tags": ["grid", "sun", "outrun", "neon"], "likes": 13, "viewed": 382, "published": "Public", "date": "1524535099", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(in vec2 st, in float radius, in float edge){\n    vec2 dist = st - vec2(0.5);\n    return 1.0 - smoothstep(radius - (radius * edge),\n                         radius + (radius * edge),\n                         dot(dist , dist) * 4.0);\n}\n\nfloat line(float center, float size, float edge, float y) {\n\treturn max(\n        max(\n        \tsmoothstep(center - size - edge, center - size, y) *\n            smoothstep(center + size + edge, center + size, y),\n        \tsmoothstep(center + size + edge - 1.0, center + size - 1.0, y)\n        ),\n        smoothstep(center - size + 1.0 - edge, center - size + 1.0, y)\n    );\n}\n\nvec3 bottomGrid(in vec2 st, in vec3 col) {\n    vec2 lines = vec2(10.0, 20.0);\n    float activeVLines = 5.0;\n    float maxVlines = 40.0;\n    vec2 shift = vec2(mix(lines.x, maxVlines, st.y), lines.y);\n    \n    vec2 suv = vec2((st.x * shift.x) - (shift.x * 0.5), st.y * shift.y);\n    vec2 fuv = fract(suv);\n    vec2 iuv = floor(suv);\n    \n    // black\n    col *= step(activeVLines, suv.y);\n    \n    // glow lines\n    vec3 glowCol = vec3(0.3, 1.0, 0.3);\n    float time = 1.0 - fract(iTime * 0.6);\n    \n    float gvLine = line(0.0, 0.04, 0.08, fuv.x);\n    float ghLine = max(\n        line(time, 0.12, 0.24, fuv.y),\n        line(0.0, 0.12, 0.12, fuv.y) * step(activeVLines - 0.16, suv.y)\n    );\n    \n    col = mix(col, glowCol, max(ghLine, gvLine) * step(suv.y, activeVLines + .16) * 0.3);\n    \n    // lines\n    vec3 lineCol = vec3(1.0, 1.0, 1.0);\n    \n    float vLine = line(0.0, 0.0025, 0.03, fuv.x);\n    float hLine = max(\n        line(time, 0.015, 0.06, fuv.y),\n        line(0.0, 0.03, 0.03, fuv.y) * step(activeVLines - 0.04, suv.y)\n    );\n    \n    col = mix(col, lineCol, max(hLine, vLine) * step(suv.y, activeVLines + .04));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float scaleX = iResolution.x / iResolution.y;\n    vec2 sunUV = vec2((uv.x * scaleX) - ((scaleX - 1.0) * 0.5), uv.y);\n    vec2 texelSize = vec2(1.0 / iResolution.x, 1.0 / iResolution.y);\n\n    \n    float sunPct = circle(sunUV, 0.5, 0.01);\n    \n    // background\n    fragColor += (1.0 - fragColor.r) * vec4(0.2, 0.129, 0.286, 1);\n    \n    // stars\n    fragColor.rgb += vec3(max(90.* fract(dot(sin(fragCoord),fragCoord))-89.5, 0.0));\n    fragColor.rgb += vec3(max(70.* fract(dot(cos(fragCoord),fragCoord))-69.7, 0.0));\n    \n    // sun haze\n    float sunHazePct = circle(sunUV, 0.57, 0.2) * 0.35;\n    fragColor.rgb = ((1.0 - sunHazePct) * fragColor.rgb) + (vec3(0.909, 0.167, 0.596) * sunHazePct);\n    \n    // sun color\n    // get a 0 -> 1 value within our sun\n    float sunValue = smoothstep(0.3, 0.63, uv.y);\n    // line size increases the closer we are to the bottom of the sun\n    float lineSize = floor(mix(80.0, 0.0, sunValue)) * texelSize.y;\n    // lerp between our sun colors to get a gradient\n    vec3 sunColor = mix(vec3(0.909, 0.167, 0.596), vec3(1, 0.913, 0.305), sunValue);\n    \n    // line speed ( 1 - to make it go down)\n    float lineInt = 1.0 - fract(iTime * 0.3);\n    \n    // line count\n    float lineY = fract(uv.y * 14.0);\n    \n    // select our lines, invert so that active lines = 0\n    float lines = 1.0 - line(lineInt, lineSize, 0.05, lineY);\n    \n    // cutoff the top lines\n    lines = max(lines, step(0.6, uv.y));\n    \n    // cancel out sun on lines\n    sunPct *= lines;\n    \n    // add main circle\n    fragColor.rgb = ((1.0 - sunPct) * fragColor.rgb) + (sunColor * sunPct);\n    \n    fragColor.rgb = bottomGrid(uv, fragColor.rgb);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2BRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 246], [248, 248, 307, 307, 622], [624, 624, 666, 666, 1767], [1769, 1769, 1826, 1826, 3527]], "test": "ok"}
{"id": "Xs3BRn", "name": "finals_1", "author": "ilaschino", "description": "pulse from r6", "tags": ["1"], "likes": 0, "viewed": 52, "published": "Public", "date": "1524014970", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 gray = vec3(.5,.5,.5);\n\nfloat random (in vec2 uv) {\n    return fract(sin(dot(uv.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);   \n}\n\nfloat rect(vec2 uv, vec2 pos, vec2 size)\n{\n\tpos -= size/2.;\n    float value = step(pos.x,uv.x);\n    value = (step(pos.x,uv.x) - step(pos.x+size.x,uv.x)); \n    value *= (step(pos.y, uv.y) - step(pos.y+size.y,uv.y));\n   \t\n    return value;\n}\n\nfloat circle(vec2 uv,float radius, vec2 shapePos, float width)\n{\n  \n    float ratio = iResolution.x / iResolution.y;\n     \n    float dist = distance(shapePos,uv) * 3.0;\n    float value =step(radius - width,dist) - step(radius, dist);\n\n    shapePos.x *= ratio;\n    \n    return value; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat ratio = iResolution.x / iResolution.y;\n     \n    vec2 size;\n    vec2 pos;\n    float value;\n    vec3 color;\n    float radius,width;\n    vec2 shapepos;\n   \n \tcolor = mix(gray,color,value);\n    \n    //cross\n    pos = vec2(.5 ,.5);\n    size = vec2(.02,1.);\n    value = 1.- rect(uv, pos,size);    \n    color = mix(vec3(0,0,0),color,value);    \n    \n    pos = vec2(.5 ,.5);\n    size = vec2(1,.03);\n    value = 1.-rect(uv, pos,size);    \n    color = mix(vec3(0,0,0),color,value); \n    \n    //red bar\n    pos = vec2(tan(iTime)/1.5,0.5);\n    size = vec2(.05,1);\n    value = 1.-rect(uv, pos,size);    \n    color = mix(vec3(1,0,0),color,value); \n    \n    //heartbeat1\n    vec2 uv2 = uv;\n    uv2.x *=ratio;\n    pos = vec2(.3 + (sin(iTime) * .15),.4);\n \tradius = .35;\n    width = .02;\n    value = 1. -circle(uv2,radius,pos,width);\n    color = mix(vec3(1,1,1),color,value);\n        \n \tradius = .05 * (sin(iTime * 15.)+ .5);\n    width = 1.;\n    value = 1. -circle(uv2,radius,pos,width);\n    color = mix(vec3(1,0,0),color,value);\n    \n   \n    pos = vec2(1.4,0.8 + (sin(iTime) * .15));\n \tradius = .35;\n    width = .02;\n    value = 1. -circle(uv2,radius,pos,width);\n    color = mix(vec3(1,1,1),color,value);\n        \n \tradius = .05 * (sin(iTime * 15.)+ .5);\n    width = 1.;\n    value = 1. -circle(uv2,radius,pos,width);\n    color = mix(vec3(1,0,0),color,value);\n    \n    \n    value = random(uv + iTime) * 1.5;\n    color = mix(vec3(1,1,1),color,value);\n    \n    \n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3BRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 56, 56, 166], [168, 168, 210, 210, 407], [409, 409, 473, 473, 694], [696, 696, 753, 753, 2284]], "test": "ok"}
{"id": "Xs3BWH", "name": "Trippy Lava Lamps", "author": "Azleur", "description": "Basic experiment on HSV and warping.", "tags": ["hsv"], "likes": 1, "viewed": 93, "published": "Public", "date": "1524827377", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nvec3 hsv2rgb(vec3 c) // http://stackoverflow.com/a/17897228/605869\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat f(float x, float w, float a0)\n{\n    return x + 0.5 * sin(0.25 * iTime + 2.0 * M_PI * w * x + a0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 hsv = vec3(f(uv.x, 2.0, 0.0) + f(uv.y, 1.0, M_PI), 1.0, 1.0);\n    vec3 col = hsv2rgb(hsv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3BWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 116, 116, 285], [287, 287, 324, 324, 392], [394, 394, 451, 501, 680]], "test": "ok"}
{"id": "Xs3fR4", "name": "Vorocracks marble", "author": "FabriceNeyret2", "description": "marble as fractalized variant of Voronoi-based cracks of [url]https://shadertoy.com/view/lsVyRy[/url].\n\nreference: see below.", "tags": ["voronoi", "perlin", "worley", "pattern", "cracks", "bark", "mz"], "likes": 88, "viewed": 1879, "published": "Public API", "date": "1524149883", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of Vorocracks: https://shadertoy.com/view/lsVyRy\n// integrated with cracks here: https://www.shadertoy.com/view/Xd3fRN\n\n#define MM 0\n\n#define VARIANT 1              // 1: amplifies Voronoi cell jittering\n#if VARIANT\n      float ofs = .5;          // jitter Voronoi centers in -ofs ... 1.+ofs\n#else\n      float ofs = 0.;\n#endif\n    \n//int FAULT = 1;                 // 0: crest 1: fault\n\nfloat RATIO = 1.,              // stone length/width ratio\n /*   STONE_slope = .3,        // 0.  .3  .3  -.3\n      STONE_height = 1.,       // 1.  1.  .6   .7\n      profile = 1.,            // z = height + slope * dist ^ prof\n */   \n      CRACK_depth = 3.,\n      CRACK_zebra_scale = 1.,  // fractal shape of the fault zebra\n      CRACK_zebra_amp = .67,\n      CRACK_profile = 1.,      // fault vertical shape  1.  .2 \n      CRACK_slope = 50.,       //                      10.  1.4\n      CRACK_width = .0;\n    \n\n// std int hash, inspired from https://www.shadertoy.com/view/XlXcW4\nvec3 hash3( uvec3 x ) \n{\n#   define scramble  x = ( (x>>8U) ^ x.yzx ) * 1103515245U // GLIB-C const\n    scramble; scramble; scramble; \n    return vec3(x) / float(0xffffffffU) + 1e-30; // <- eps to fix a windows/angle bug\n}\n\n// === Voronoi =====================================================\n// --- Base Voronoi. inspired by https://www.shadertoy.com/view/MslGD8\n\n#define hash22(p)  fract( 18.5453 * sin( p * mat2(127.1,311.7,269.5,183.3)) )\n#define disp(p) ( -ofs + (1.+2.*ofs) * hash22(p) )\n\nvec3 voronoi( vec2 u )  // returns len + id\n{\n    vec2 iu = floor(u), v;\n\tfloat m = 1e9,d;\n#if VARIANT\n    for( int k=0; k < 25; k++ ) {\n        vec2  p = iu + vec2(k%5-2,k/5-2),\n#else\n    for( int k=0; k < 9; k++ ) {\n        vec2  p = iu + vec2(k%3-1,k/3-1),\n#endif\n            o = disp(p),\n      \t      r = p - u + o;\n\t\td = dot(r,r);\n        if( d < m ) m = d, v = r;\n    }\n\n    return vec3( sqrt(m), v+u );\n}\n\n// --- Voronoi distance to borders. inspired by https://www.shadertoy.com/view/ldl3W8\nvec3 voronoiB( vec2 u )  // returns len + id\n{\n    vec2 iu = floor(u), C, P;\n\tfloat m = 1e9,d;\n#if VARIANT\n    for( int k=0; k < 25; k++ ) {\n        vec2  p = iu + vec2(k%5-2,k/5-2),\n#else\n    for( int k=0; k < 9; k++ ) {\n        vec2  p = iu + vec2(k%3-1,k/3-1),\n#endif\n              o = disp(p),\n      \t      r = p - u + o;\n\t\td = dot(r,r);\n        if( d < m ) m = d, C = p-iu, P = r;\n    }\n\n    m = 1e9;\n    \n    for( int k=0; k < 25; k++ ) {\n        vec2 p = iu+C + vec2(k%5-2,k/5-2),\n\t\t     o = disp(p),\n             r = p-u + o;\n\n        if( dot(P-r,P-r)>1e-5 )\n        m = min( m, .5*dot( (P+r), normalize(r-P) ) );\n    }\n\n    return vec3( m, P+u );\n}\n\n// === pseudo Perlin noise =============================================\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nint MOD = 1;  // type of Perlin noise\n    \n// --- 2D\n#define hash21(p) fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123)\nfloat noise2(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p); f = f*f*(3.-2.*f); // smoothstep\n\n    float v= mix( mix(hash21(i+vec2(0,0)),hash21(i+vec2(1,0)),f.x),\n                  mix(hash21(i+vec2(0,1)),hash21(i+vec2(1,1)),f.x), f.y);\n\treturn   MOD==0 ? v\n\t       : MOD==1 ? 2.*v-1.\n           : MOD==2 ? abs(2.*v-1.)\n                    : 1.-abs(2.*v-1.);\n}\n\nfloat fbm2(vec2 p) {\n    float v = 0.,  a = .5;\n    mat2 R = rot(.37);\n\n    for (int i = 0; i < 9; i++, p*=2.,a/=2.) \n        p *= R,\n        v += a * noise2(p);\n\n    return v;\n}\n#define noise22(p) vec2(noise2(p),noise2(p+17.7))\nvec2 fbm22(vec2 p) {\n    vec2 v = vec2(0);\n    float a = .5;\n    mat2 R = rot(.37);\n\n    for (int i = 0; i < 6; i++, p*=2.,a/=2.) \n        p *= R,\n        v += a * noise22(p);\n\n    return v;\n}\nvec2 mfbm22(vec2 p) {  // multifractal fbm \n    vec2 v = vec2(1);\n    float a = .5;\n    mat2 R = rot(.37);\n\n    for (int i = 0; i < 6; i++, p*=2.,a/=2.) \n        p *= R,\n        //v *= 1.+noise22(p);\n          v += v * a * noise22(p);\n\n    return v-1.;\n}\n\n/*\n// --- 3D \n#define hash31(p) fract(sin(dot(p,vec3(127.1,311.7, 74.7)))*43758.5453123)\nfloat noise3(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p); f = f*f*(3.-2.*f); // smoothstep\n\n    float v= mix( mix( mix(hash31(i+vec3(0,0,0)),hash31(i+vec3(1,0,0)),f.x),\n                       mix(hash31(i+vec3(0,1,0)),hash31(i+vec3(1,1,0)),f.x), f.y), \n                  mix( mix(hash31(i+vec3(0,0,1)),hash31(i+vec3(1,0,1)),f.x),\n                       mix(hash31(i+vec3(0,1,1)),hash31(i+vec3(1,1,1)),f.x), f.y), f.z);\n\treturn   MOD==0 ? v\n\t       : MOD==1 ? 2.*v-1.\n           : MOD==2 ? abs(2.*v-1.)\n                    : 1.-abs(2.*v-1.);\n}\n\nfloat fbm3(vec3 p) {\n    float v = 0.,  a = .5;\n    mat2 R = rot(.37);\n\n    for (int i = 0; i < 9; i++, p*=2.,a/=2.) \n        p.xy *= R, p.yz *= R,\n        v += a * noise3(p);\n\n    return v;\n}\n*/\n    \n// ======================================================\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U *= 4./iResolution.y;\n    U.x += iTime;                                     // for demo\n // O = vec4( 1.-voronoiB(U).x,voronoi(U).x, 0,0 );   // for tests\n    vec2 I = floor(U/2.); \n    bool vert = mod(I.x+I.y,2.)==0.; //if (vert) U = U.yx;\n    vec3 H0;\n    O-=O;\n\n    for(float i=0.; i<CRACK_depth ; i++) {\n        vec2 V =  U / vec2(RATIO,1),                  // voronoi cell shape\n             D = CRACK_zebra_amp * fbm22(U/CRACK_zebra_scale) * CRACK_zebra_scale;\n        vec3  H = voronoiB( V + D ); if (i==0.) H0=H;\n        float d = H.x;                                // distance to cracks\n   /*         r = voronoi(V).x,                       // distance to center\n              s = STONE_height-STONE_slope*pow(r,profile);// stone interior\n    */                                                // cracks\n        d = min( 1., CRACK_slope * pow(max(0.,d-CRACK_width),CRACK_profile) );\n  \n        O += vec4(1.-d) / exp2(i);\n        U *= 1.5 * rot(.37);\n    }\n    /*\n    O = vec4( \n        FAULT==1 ? d * s                              // fault * stone\n                 : mix(1.,s, d)                       // crest or stone\n            ); */\n    if (vert) O = 1.-O; O *= vec4(.9,.85,.85,1);      // for demo\n    \n#if MM\n    O.g = hash3(uvec3(H0.yz,1)).x;\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3fR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[909, 978, 1002, 1002, 1200], [2876, 2876, 2898, 2898, 3244], [3246, 3246, 3266, 3266, 3424], [3475, 3475, 3495, 3495, 3667], [3668, 3668, 3689, 3711, 3922], [4828, 4828, 4866, 4866, 6141]], "test": "ok"}
{"id": "Xs3fWr", "name": "Surfer Worms", "author": "MadEqua", "description": "Playing with voronoi cells and sound.", "tags": ["voronoi", "waves", "sound"], "likes": 1, "viewed": 418, "published": "Public API", "date": "1524623596", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.141519;\nconst float TWO_PI = PI * 2.0;\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\nvec2 rotate2D(float angle, vec2 uv, vec2 pivot)\n{\n    vec2 newUv = uv - pivot;\n\n    newUv = mat2(cos(angle), -sin(angle), \n                sin(angle), cos(angle)) * newUv;\n    return newUv + pivot;\n}\n\nvec2 scale(vec2 scale, vec2 uv, vec2 pivot)\n{\n\tvec2 newUv = uv - pivot;\n    newUv = mat2(scale.x, 0.0,\n                0.0, scale.y) * newUv;\n    return newUv + pivot;\n}\n\nfloat fetchFft(int start, int end, float power)\n{\n    // first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n   \tfloat fft = 0.0;\n    for(int i = start; i <= end; ++i)\n         fft += texelFetch(iChannel0, ivec2(i, 0), 0).x;\n    return pow(fft / float(end - start + 1), power);\n}\n\nfloat bass()\n{\n    return fetchFft(2, 5, 30.0);\n}\n\nfloat deepBass()\n{\n    return fetchFft(0, 2, 5.0);\n}\n\nfloat high()\n{\n    return fetchFft(250, 350, 1.0);\n}\n\nfloat voronoi(vec2 uv, vec2 size)\n{\n    vec2 iPos = floor(uv);\n    //vec2 fPos = fract(uv);\n    \n    float minDist = 2.0;\n    vec2 closestPoint = vec2(0.0);\n    \n    for(int x = -1; x <= 1; ++x)\n        for(int y = -1; y <= 1; ++y)\n        {\n            vec2 iNeighbour = iPos + vec2(x, y);  \n            vec2 neighbourPoint;\n            \n            neighbourPoint.x = abs(sin(0.6 * iTime + distance(size/2.0, uv)));\n            neighbourPoint.y = abs(sin(0.6 * iTime + 0.5 * distance(size/2.0, uv)));\n            \n            const float HIGH_K = 0.6;\n            neighbourPoint.x += HIGH_K * (high() - 0.5);\n            neighbourPoint.y += HIGH_K * (high() - 0.5);\n            \n            float dist = distance(uv, iNeighbour + neighbourPoint);           \n            if(dist < minDist)\n            {\n                minDist = dist;\n                closestPoint = iNeighbour + neighbourPoint;\n            }            \n        }\n    \n    return minDist + (1.0 - smoothstep(0.07, 0.15, distance(uv, closestPoint)));\n    //return smoothstep(0.1, 0.8, minDist) + (1.0 - smoothstep(0.04, 0.11, distance(uv, closestPoint)));\n}\n\nfloat borderLight(vec2 uv, vec2 size)\n{\n    float d = distance(uv, size * 0.5);\n    return smoothstep(0.7, 1.0, d);\n}\n\nfloat centerLight(vec2 uv, vec2 size)\n{\n    float d = distance(uv, size * 0.5);\n    return 1.0 - smoothstep(0.0, 0.6, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 center = vec2(0.5) * vec2(ratio, 1.0);\n    uv = rotate2D(pow(sin(0.013 * deepBass() + iTime * 0.15), 6.0) * TWO_PI, uv, center);\n    \n    vec2 scaledUv = scale(1.6 + 0.6 * sin(vec2(0.3 * iTime + deepBass() * 0.5)), uv, center);\n    \n    const vec2 TILES = vec2(15.0);\n    scaledUv *= TILES;\n    \n    vec2 size = TILES * vec2(ratio, 1.0);\n    \n    const float SHADOW_DEPTH = 0.08;\n    vec2 shadowDisp = vec2(sin(iTime), cos(iTime)) * SHADOW_DEPTH;\n    \n    float v1 = voronoi(scaledUv, size);\n    float v2 = voronoi(scaledUv + shadowDisp, size);\n         \n    vec3 G = rgb2hsb(vec3(0.0, 255.0, 39.0) / vec3(255.0));\n    vec3 B = rgb2hsb(vec3(10.0, 25.0, 255.0) / vec3(255.0));\n    vec3 W = rgb2hsb(vec3(1.0));\n    vec3 Y = rgb2hsb(vec3(204.0, 115.0, 20.0) / vec3(255.0));\n       \n    vec3 mix1 = mix(G, Y, 0.5 + 0.5 * sin(0.5 * iTime - 6.0 * distance(uv, center)));\n    vec3 mix2 = mix(Y, B, 0.5 + 0.5 * sin(0.7 * iTime - 8.0 * distance(uv, center)));\n    vec3 finalMix = mix(mix1, mix2, 0.5 + 0.5 * sin(iTime * 0.5));\n    \n    vec3 col = vec3(0.0);    \n\tcol = mix(finalMix, col, pow(v1, 0.4 + bass()));\n    col = mix(col, W, v2 * v2);\n    \n    const float HIGHLIGHT_K = 0.35;\n    col.z += HIGHLIGHT_K * bass() * borderLight(uv, vec2(ratio, 1.0));\n    col.z += HIGHLIGHT_K * bass() * centerLight(uv, vec2(ratio, 1.0));\n    \n    col = hsb2rgb(col);\n    col = pow(col, vec3(1.5 + bass()));\n        \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3fWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 85, 85, 515], [517, 591, 617, 617, 849], [852, 852, 901, 901, 1051], [1053, 1053, 1098, 1098, 1222], [1224, 1224, 1273, 1357, 1528], [1530, 1530, 1544, 1544, 1579], [1581, 1581, 1599, 1599, 1633], [1635, 1635, 1649, 1649, 1687], [1689, 1689, 1724, 1724, 2814], [2816, 2816, 2855, 2855, 2933], [2935, 2935, 2974, 2974, 3058], [3060, 3060, 3117, 3117, 4671]], "test": "error"}
{"id": "XscBz4", "name": "Function testing", "author": "darkeclipz", "description": "Playing around with different types of functions.", "tags": ["testing", "functions"], "likes": 4, "viewed": 106, "published": "Public", "date": "1524144345", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Working through https://thebookofshaders.com/05/\n#define pi 3.14159265359\n\nfloat plot(vec2 uv, float pct) {\n\treturn smoothstep( pct - 0.02, pct, uv.y ) -\n           smoothstep( pct, pct + 0.02, uv.y );\n}\n\nfloat step2(float a, float b, float v) {\n\treturn step(a,v) - step(b,v);    \n}\n\nfloat smoothstep2(float a, float b, float w, float v) {\n\treturn smoothstep(a-w, a, v) - smoothstep(b, b+w, v);\n}\n\nfloat sqr(float x) { return x*x; }\n\nvec2 tile(vec2 uv, float scale) { return fract(uv*scale); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float t = iTime;\n    \n    // How many tiles we want to create.\n    float tiles = 6.;\n    \n    // Get the integer part of our tiled coordinates\n    vec2 uvIntPart; modf(tiles * uv, uvIntPart);\n    \n    // Get the index for the tile [0, ..., tiles]\n    int tileIndex = int(uvIntPart.y * tiles + uvIntPart.x);\n    \n    // Get normalized coordinates [0, 1] for each tile.\n    vec2 coord = tile(uv, tiles);\n    \n    // Function x, y\n    float x, y; x = coord.x; \n\n    // Select each tile to render a different function.\n    switch(tileIndex) {\n        // Basic functions\n        case 0: y = x;\t\t\t\t\t\t\t\tbreak;\n    \tcase 1: y = sqr(x); \t\t\t\t\t\tbreak;\n        case 2: y = sqrt(x);\t\t\t\t\t\tbreak;\n        case 3: y = .5*log(x) + 1.;\t\t\t\t\tbreak;\n        case 4: y = pow(x, 5.);\t\t\t\t\t\tbreak;\n        case 5: y = .5*sin(x * pi * 2.) + .5; \t\tbreak;\n        \n        // Other functions\n        case 6: y = fract(3.*x); \t\t\t\t\tbreak;\n        case 7: y = ceil(5.*x)/5.;  \t\t\t\tbreak;\n        case 8: y = floor(5.*x)/5.;  \t\t\t\tbreak;\n        case 9: y = atan(x*pi/2.); \t\t\t\t\tbreak;\n        case 10: y = asin(x*pi/4.);\t\t\t\t\tbreak;\n        case 11: y = 1.-sqr(x); \t\t\t\t\tbreak;\n        \n        // Step examples\n        case 12: y = step(.5,x);\t\t\t\t\tbreak;\n        case 13: y = step(.4,x) - step(.6,x); \t\tbreak;\n        case 14: y = x * step2(.4, .6, x);\t\t\tbreak;\n        case 15: y = step2(.0, .2, fract(4.*x));\tbreak;\n        case 16: y = x * step2(.0, .2, fract(4.*x));break;\n        case 17: y = sin(x*pi) \n           \t  * (1.-step(.2, fract(12.*x)))\n              + 0.2 * (step2(.2, 1., fract(12.*x)));break;\n        \n        // Smoothstep examples\n        case 18: y = smoothstep(.0,1.,x); \t\t\tbreak;\n        case 19: y = smoothstep2(.4,.6,.2,x); \t\tbreak;\n        case 20: y = x * smoothstep2(.4,.6,.1,x);\tbreak;\n        case 21: y = x * smoothstep2(fract(4.*x), \n                                     fract(4.*x+0.1)\n                                     , 0.2, x); \tbreak;\n        //case 22: y = 0.5 * smoothstep2(mod(4.*x,.5),\n        //                              mod(4.*x+0.1,.5)\n        //                              , 0.2, x)+.2;\tbreak;\n        \n        // Clamp examples\n        case 24: y = clamp(x,0.,1.); \t\t\t\tbreak;\n        case 25: y = clamp(x,.5,1.); \t\t\t\tbreak;\n        case 26: y = clamp(x,0.,.5); \t\t\t\tbreak;\n        case 27: y = 1.-clamp(x,.5,1.); \t\t\tbreak;\n        case 28: y = 1.-clamp(x,0.,1.);\t\t\t\tbreak;\n        \n        // Misc. examples\n        case 30: y = fract(sin(x*pi*4.)); \t\t\tbreak;\n        case 31: y = fract(abs(sin(x*pi*4.))); \t\tbreak;\n        case 32: y = mod(x, .25);\t\t\t \t\tbreak;\n        case 33: y = sin(x*pi);\t\t\t\t\t\tbreak;\n        case 34: y = 0.5 + .05 * ( sin(29.*x+8.*t)\n                           \t\t + sin(38.*x+8.*t) \n                          \t\t + sin(17.*x+8.*t));break;\n    }\n    \n    // Set color\n    vec3 col = vec3(y);\n    \n    // Line\n    float pct = plot(coord, y);\n    col = (1.0-pct)*col+pct*vec3(0,1,0);\n    \n    // Grid\n    float gridWidth = 0.01;\n    col = mix(col, vec3(0), 1.-step(gridWidth, coord.x));\n    col = mix(col, vec3(0), 1.-step(gridWidth, coord.y));\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XscBz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 110, 110, 206], [208, 208, 248, 248, 285], [287, 287, 342, 342, 399], [401, 401, 421, 421, 435], [437, 437, 470, 470, 496], [498, 498, 555, 605, 3794]], "test": "error"}
{"id": "XscBzn", "name": "Worley fractal Brownian motion", "author": "chronos", "description": "Simple fBm based on animated Worley noise.", "tags": ["fractal", "worley", "brownian", "motion"], "likes": 11, "viewed": 331, "published": "Public", "date": "1523894026", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define NUM_OCTAVES 6\n#define FBM_NOISE_FUNCTION worley2\n\n\nfloat rnd(vec2 u) { return fract(3e5 * sin(dot(u, vec2(1, 78)))); }\n\nvec2 rnd2( vec2 p ) {\n    vec2 q = vec2( dot(p,vec2(127.1,311.7)),\n                   dot(p,vec2(269.5,183.3)));\n    return fract(sin(q)*43758.5453);\n}\n\nfloat valueNoise(vec2 u)\n{\n\tvec2 i = floor(u), f = u-i,\n    X = vec2(rnd(i), rnd(i+vec2(1, 0))),\n    Y = vec2(rnd(i + vec2(0, 1)), rnd(i + 1.));\n    f *= f*(3. - 2.*f);\n    u = mix(X, Y, f.y);\n    return mix(u.x, u.y, f.x);\n}\n\nvec2 valueNoise2(vec2 u) {\n\tvec2 i = floor(u), f = u-i,\n    X = vec2(rnd(i), rnd(i+vec2(1, 0))),\n    Y = vec2(rnd(i + vec2(0, 1)), rnd(i + 1.));\n    f *= f*(3. - 2.*f);\n    u = mix(X, Y, f.y);\n    return u;\n}\n\n// input, rotation angle, scaling, translation\nvec2 rigidTransform(vec2 p, float theta, float scale, vec2 t) {\n    float c = cos(theta), s = sin(theta);\n    return scale * (mat2(c, s, -s, c) * p) + t;\n}\n\nvec2 spin(vec2 u) { return .5 + .5 * sin(iTime + 6.2831*u); }\n\n#define WORLEY_ANIMATION spin\nfloat worley(vec2 u) {\n    float d = 1e3, a;\n    vec2 k =  floor(u), f = u-k, p, q = k + vec2(0, 0);\n    for(int i = -1; i < 2; i++) {\n        for(int j = -1; j < 2; j++) {\n            p = WORLEY_ANIMATION(valueNoise2(k+vec2(i, j)));\n            a = distance(f, vec2(i, j) + p);\n            if(a < d) {\n            \td = a;\n                q = p;\n            }\n    } }\n    return dot(q, vec2(.3,.6));\n}\n\nfloat worley2(vec2 u) {\n    float d = 1e4, a;\n    float acc = 0., acc_w = 0.;\n    vec2 k =  floor(u), f = u-k, p, q = k + vec2(0, 0);\n    for(int i = -3; i < 3; i++) {\n        for(int j = -3; j < 3; j++) {\n            vec2 p_i = vec2(i, j);\n            vec2 p_f = WORLEY_ANIMATION(rnd2(k+p_i));\n            float d = length(p_i - f + p_f);\n            float w = exp(-8. * d);\n            acc += w * d;\n            acc_w += w;\n    } }\n    return acc / acc_w;\n}\n\nfloat worley3(vec2 u) {\n    float d = 1e4, a;\n    float acc = 0., acc_w = 0.;\n    vec2 k =  floor(u), f = u-k, p, q = k + vec2(0, 0);\n    const int r = 3;\n    for(int i = -r; i < r; i++) {\n        for(int j = -r; j < r; j++) {\n            vec2 p_i = vec2(i, j);\n            vec2 p_f = WORLEY_ANIMATION(rnd2(k+p_i));\n            float d = length(p_i - f + p_f);\n            float w = exp(-8. * d) * (1.-step(sqrt(float(r*r)),d));\n            acc += w * valueNoise(k+p_i);\n            acc_w += w;\n    } }\n    return acc / acc_w;\n}\n\nfloat fbm(vec2 u) {\n    float v = 0.;\n    for(int i = 0; i < NUM_OCTAVES; i++) {\n        v += pow(.5, float(i+1)) * FBM_NOISE_FUNCTION(u);\n        u = rigidTransform(u, .5, 2., vec2(1e3));\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n\tvec2 p = uv * 3.;\n    vec3 col = vec3(0.);\n    float f = fbm( p );\n    //f = fbm( p + f);\n    //f = fbm( p + f);\n\t\n    col += f;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XscBzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 79, 79, 127], [129, 129, 150, 150, 280], [282, 282, 308, 308, 507], [509, 509, 535, 535, 717], [719, 766, 829, 829, 921], [923, 923, 942, 942, 984], [1016, 1016, 1038, 1038, 1417], [1419, 1419, 1442, 1442, 1878], [1880, 1880, 1903, 1903, 2408], [2410, 2410, 2429, 2429, 2620], [2622, 2622, 2679, 2679, 2882]], "test": "ok"}
{"id": "XscBzr", "name": "Rocketbean", "author": "vapoi", "description": "The not-good-at-gaming-Rocketbean i used in my latest visualization video:\nyoutube.com/watch?v=_7r3CWvHnNU\n\nIt's a sort of caricature of the logo of the nerdy Internet-TV Station \"RocketbeansTV\" from Germany.", "tags": ["2d", "simple", "rocketbean"], "likes": 2, "viewed": 752, "published": "Public API", "date": "1523902218", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float fPi = 3.14159;\nconst float fSmile = 0.0;\t// 1.0 for a smiling bean\n\nfloat DistanceP(vec2 p, vec2 segA, vec2 segB)\n{\n    \tvec2 p2 = vec2(segB.x - segA.x,segB.y - segA.y);\n    \tfloat num = p2.x * p2.x + p2.y * p2.y;\n    \tfloat u = ((p.x - segA.x) * p2.x + (p.y - segA.y) * p2.y) / num;\n\n    \tif (u > 1.0 ) {\n    \t\tu = 1.0;\n    \t}\n    \telse if (u < 0.0) {\n    \t\tu = 0.0;\n    \t}\n\n    \tfloat x = segA.x + u * p2.x;\n    \tfloat y = segA.y + u * p2.y;\n\n    \tfloat dx = x - p.x;\n    \tfloat dy = y - p.y;\n\n    \treturn sqrt(dx*dx + dy*dy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 pMid = vec2(-2.5, -1.5) + uv * vec2(5.0, 3.0);\n    float fTime = iTime + 25.0;\n\n    \tfloat distMid = DistanceP(pMid, vec2(0.0, -0.5), vec2(0.0, 0.5));\n\t\n\t\n\tfloat beanForm = distMid * (1.0 - 0.17 * abs(cos(2.0 + pMid.y * 3.1)));\n\t\n\tbeanForm *= 1.0 - 0.1 * max(0.0, sin(fTime * 2.1)) * max(0.0, sin(-pMid.y * fPi + 0.5)); //clamp(-pMid.y * 3.0, 0.0, 1.0);\n\t\n\tfloat fBean = smoothstep(-0.4, -0.35, -beanForm);\n\tfloat fBeanSoft = smoothstep(-0.4, -0.3, -beanForm);\n\tfloat fBeanSuperSoft = smoothstep(-0.4, 0.05, -beanForm);\n\t\n\t// Augen\n\tvec2 v2Eyes = vec2(abs(pMid.x), pMid.y); \n\t\n\tvec2 v2LookTo = 0.03 * vec2(sin(pMid.x * 3.7 + fTime * 0.91), \n\t\t\t\t\t\t\t\tsin(pMid.x * 4.2 + fTime * 1.03));\n\t\n\tfloat fPupiDist = length(v2Eyes - vec2(0.175, 0.32) + v2LookTo);\n\t\n\tvec2 v2Blink = vec2(1.0, 1.0 + 12.0 * (max(0.0, 3.0 * sin(fTime * 1.7) - 2.9)));\n\tfloat fEyeDist = length(v2Blink * (v2Eyes - vec2(0.175, 0.32)));\n\tfloat fEyesBorder = smoothstep(-0.17, -0.16, -fEyeDist);\n\tfloat fEyes = smoothstep(-0.16, -0.12, -fEyeDist);\n\t\n\tfloat fPupi = smoothstep(-0.08, -0.06, -fPupiDist);\n\tvec3 colEye = mix(vec3(0.0), vec3(1.0) * (1.0 - fPupi), fEyes);\n\tfEyes = max(fEyes, fEyesBorder);\n\t\n\t\n\t// Mund\n\tfloat fMouth = smoothstep(-0.03, -0.005, -abs(pMid.y + (0.1 - 0.27 * fSmile) * (1.0 - cos(pMid.x * fPi * 0.8))));\n\t//fMouth = max(fMouth, clamp(fValue - 0.5, 0.0, 1.0) * 2.0 * smoothstep(-0.11, -0.07, -length(pMid * vec2(0.3, 1.0))));\n\tfMouth = fMouth * fBeanSuperSoft;\n\t\n\t// Helm\n\tfloat fHelmet = smoothstep(-0.5, -0.4, -beanForm);\n\tfHelmet = clamp((fHelmet - \n\t\t\t\t\t min(fBeanSoft, fBeanSoft * (-pMid.y * 3.0 + 3.2)))  // Bohnenkopf nicht bedecken, ganz oben einen Streifen lassen\n\t\t\t\t\t * max(0.0, (pMid.y - 0.05) * 7.5), 0.0, 1.0);\t\t // Helm ist nur am Kopf\n\t\n\tfHelmet += 0.5 * fHelmet * max(0.0, cos(abs(pMid.y * fPi)) - fBean); // Lichteffekt\n\t\n\t// Engine\n\t// 1) Grundform\n\tfloat fEngine = (  0.15 + -pMid.y * 0.8 - abs(pMid.x) * 1.4  \t// shape\n\t\t\t\t\t + 0.2 * (1.0 - cos(pMid.x * 4.6)))\t\t\t\t// swing\n\t\t\t\t\t* smoothstep(-0.75, -0.7, pMid.y + 0.15);\t\t// Bottom\n\n\tfEngine *= 5.0;\t\t// mehr Kontur\n\tfEngine = smoothstep(0.7, 1.0, fEngine);\n\t\n\t// 2) dasselbe nochmal etwas niedriger (y-Achse)\n\tfloat fEngineBottom = (-0.4 + -pMid.y * 1.2 - abs(pMid.x) * 1.25  \t\n\t\t\t\t\t\t   + 0.2 * (1.0 - cos(pMid.x * 4.3)))\n\t\t\t\t\t\t   ;\t\n\tfEngineBottom *= 5.0;\n\tfEngineBottom = smoothstep(0.7, 1.0, fEngineBottom);\t\n\t\n\t// 3) und extrahieren für die endgültige Form\n\tfEngine = fEngine - fEngineBottom;\n\t\n\t// 4) nochmal die Engine für die Kante:\n\tfEngine = \tfEngine * 1.2 - fEngine * \n\t\t\t\t0.4 * smoothstep(0.7, 1.0,\n\t\t\t\t(5.75 * (0.05 + -pMid.y * 0.8 - abs(pMid.x) * 1.4\n\t\t\t\t+ 0.2 * (1.0 - cos(pMid.x * 4.6)))));\n\tfEngine = clamp(fEngine, 0.0, 1.0);\n\t\n\t// 5) Fertig, noch die Bohne bevorzugen:\n\tfEngine = clamp(fEngine - fBeanSoft, 0.0, 1.0);\n\t\n\t\n\t// alle Farben addieren:\n\tvec3 col1 = vec3(0.85, 0.2, 0.2) * (0.8 * fBean + 0.4 * fBeanSuperSoft);\n\tcol1 += vec3(0.85, 0.65, 0.25) * fHelmet;\n\tcol1 += vec3(0.85, 0.65, 0.25) * fEngine * 1.2;\n\tcol1 = mix(col1, colEye, fEyes);\n\tcol1 = mix(col1, vec3(0.0), fMouth);\n\t\n    // background\n\tcol1 = mix(vec3(0.2, 0.3, 0.6), col1, fBean + fHelmet + fEngine);\n\tfragColor = vec4(col1, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XscBzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 127, 127, 542], [544, 544, 601, 601, 3843]], "test": "ok"}
{"id": "XscfRN", "name": "SolarSystemProject", "author": "LesserDog", "description": "EGP-200-01\nA simple 3D solar system, containing the Earth, Moon, and Sun.\nNot to scale, and orbits not reflective of reality.\n\nPatrick Gregg", "tags": ["earth"], "likes": 0, "viewed": 76, "published": "Public", "date": "1524762304", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float lineDist(vec3 rO, vec3 rD, vec3 point)\n{\n    return length(cross(point - rO, rD))/length(rD);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n// Normalized pixel coordinates (from 0 to 1)\nvec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= 0.5;\n    \n//Correct for aspect ratio\nfloat aspectRatio = iResolution.y/iResolution.x;\nuv.y = uv.y * aspectRatio;\n\n//Ray Origin and direction\n    vec3 rayO = vec3(0.0, 0.0, -2);\n    vec3 rayD = vec3(uv.x,uv.y,0) - rayO;\n\n//Colors\nvec4 Canvas = vec4(1.0,1.0,1.0,1.0);\nvec4 EarthCol = vec4(0.0,0.0,1.0,1.0);\nvec4 MoonCol = vec4(0.9,0.9,0.9,1.0);\nvec4 SunCol = vec4(1.0,1.0,0.0,1.0);\nvec4 BgColor = texture(iChannel0, uv);\n    \n//Distances from the Earth\nvec3 MoonDist = vec3(0.05,0.05,0.05);\nvec3 SunDist = vec3(0.3,0.3,0.3);\n\n//Modify aspect ratio for distances\nMoonDist.x *= aspectRatio;\nSunDist.x *= aspectRatio;\n\n//Angles\nfloat EarthTheta = iTime*0.5;\nfloat EarthPhi = iTime*0.9;\nfloat MoonTheta = iTime*0.5;\nfloat MoonPhi = iTime*0.3;\n    \n//Planet locations\t\n    //Will work regardless of where the sun's location is\nvec3 SunLoc = vec3(0.0, 0.0, 0.0);\n//3D\nvec3 EarthLoc = vec3 (SunLoc.x + SunDist.x*cos(EarthTheta)*sin(EarthPhi),SunLoc.y+SunDist.y*sin(EarthTheta)*sin(EarthPhi), SunDist.z*cos(EarthPhi));\n//2D\n//vec3 EarthLoc = vec3 (SunDist.x*cos(EarthTheta),SunDist.y*sin(EarthTheta),0.0);\n//3D\nvec3 MoonLoc = vec3 (EarthLoc.x + MoonDist.x*cos(MoonTheta)*sin(MoonPhi), EarthLoc.y + MoonDist.y*sin(MoonTheta)*sin(MoonPhi), EarthLoc.z + MoonDist.z*(MoonPhi));\n//2D\n//vec3 MoonLoc = vec3 (EarthLoc.x + MoonDist.x*cos(MoonTheta), EarthLoc.y+MoonDist.y*sin(MoonTheta), 0.0);\nfloat SunRad = 0.04;\nfloat EarthRad = 0.01;\nfloat MoonRad = 0.003;\n    \n//Fix aspect ratio\nEarthLoc.y *= aspectRatio;\nMoonLoc.y *= aspectRatio;\nSunLoc.y *= aspectRatio;\n\n//Create planets\nfloat Earth = lineDist(rayO, rayD, EarthLoc);\nfloat Sun = lineDist(rayO, rayD, SunLoc);\nfloat Moon = lineDist(rayO, rayD, MoonLoc);\n\nEarthCol.a = step(EarthRad, Earth);\nMoonCol.a = step(MoonRad, Moon);\nSunCol.a = step(SunRad, Sun);\n\n\n  \n//Draw\nCanvas = BgColor;\nCanvas = mix(Canvas, EarthCol, 1.0-EarthCol.a);\nCanvas = mix(Canvas, MoonCol, 1.0-MoonCol.a);\nCanvas = mix(Canvas, SunCol, 1.0-SunCol.a);\nfragColor = vec4(Canvas);\n\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XscfRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 101], [103, 103, 160, 207, 2250]], "test": "error"}
{"id": "XsdfRH", "name": "Induced Contrast Asynchrony", "author": "fjavifabre", "description": "Changing the background produces the effect that the circles are blinking asynchronously, although they are synchronized", "tags": ["illusion", "perception"], "likes": 4, "viewed": 134, "published": "Public", "date": "1524070704", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AVOID_DISTORSIONS 1\n\n#define PI 3.14159265359\n\nfloat circle( vec2 p, vec2 c, float radius) \n{\n    \n    return sqrt(pow(p.x-c.x, 2.) + pow(p.y-c.y, 2.)) - radius;\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n#if AVOID_DISTORSIONS\n    vec2 uv = fragCoord/iResolution.y;\n   \tuv.x += (iResolution.y - iResolution.x) \n        / max(iResolution.x,iResolution.y) ;\n#else    \n    vec2 uv = fragCoord/iResolution.xy;\n#endif    \n\n    float c0 = circle(uv, vec2(.15, .5), 0.2);\n    float c1 = circle(uv, vec2(.85, .5), 0.2);\n    \n    float h = abs(mod(iTime * .1+ 10.2 , 1.)*2. - 1.);\n    \n    if(iMouse.z > 0.)\n        h = iMouse.y / iResolution.y;\n\n    vec3 circleColor = vec3(abs(mod(iTime, 1.)*2. - 1.)) * 0.6;\n    \n    if(c0 <=0. || c1 <= 0.)\n        fragColor = vec4(circleColor, 1.);\n    else if(uv.y < h)\n        fragColor = vec4((uv.x > 0.5) ? .6 : 0.);\n    \n    else\n        fragColor = vec4(1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsdfRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 101, 101, 180], [182, 182, 239, 289, 980]], "test": "ok"}
{"id": "XsdfRn", "name": "F03 Moon", "author": "Azunyan_Taichou", "description": "Moon", "tags": ["moon"], "likes": 4, "viewed": 88, "published": "Public", "date": "1524011999", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 colorA= vec3(0,0,0); // Black\nvec3 colorB= vec3(1.0,1.0,1); // Red\nvec3 colorC= vec3(0,0,0); // White\n\n// Value Noise\nfloat vhash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat vnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( vhash( i + vec2(0.0,0.0) ), \n                     vhash( i + vec2(1.0,0.0) ), u.x),\n                mix( vhash( i + vec2(0.0,1.0) ), \n                     vhash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n// Gradient Noise\nvec2 ghash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( ghash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( ghash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( ghash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( ghash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex Noise\nvec2 shash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat snoise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,shash(i+0.0)), dot(b,shash(i+o)), dot(c,shash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\n\nfloat circle(vec2 uv, vec2 pos, float radius, float width)\n{\n    float dist = distance(pos, uv);\n    float value = step(radius - width, dist) - step(radius - gnoise(uv *1005.) , dist);\n    \n    return value;\n}\n\nfloat rect(vec2 uv, vec2 pos, vec2 size)\n{\n\n    float value = step(pos.x,uv.x);\n    value = (step(pos.x,uv.x) - step(pos.x+size.x,uv.x)); \n    value *= (step(pos.y, uv.y) - step(pos.y+size.y,uv.y));\n   \n    return value;\n}\n\nfloat rand(vec2 uv)\n{\n    return fract(sin(dot(uv.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    float zoom = 8.;\n    float scale = .02;\n    \n    float offset = gnoise(uv *zoom * iTime) * scale; // Noise\n   \tvec2 pos = vec2(0.5 *ratio, 0.5);\n    float radius = abs(0.2);\n    float width = 1.0;\n    float value = circle(uv, pos +offset, radius, width);\n    vec3 color = mix(colorC, colorB, value);\n\n   \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsdfRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 123, 181, 181, 285], [287, 287, 314, 314, 612], [615, 633, 692, 692, 830], [832, 832, 859, 859, 1261], [1263, 1280, 1338, 1338, 1459], [1461, 1461, 1488, 1488, 1946], [1949, 1949, 2009, 2009, 2158], [2160, 2160, 2202, 2202, 2382], [2384, 2384, 2405, 2405, 2477], [2479, 2479, 2536, 2536, 2988]], "test": "ok"}
{"id": "XsdfWH", "name": "Sausage bird", "author": "dpiponi", "description": "Some kind of swimmy thing. Gotta work on that aliasing and the occasional bits the marcher misses", "tags": ["organic"], "likes": 0, "viewed": 101, "published": "Public", "date": "1524945335", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat4 translate(vec3 p) {\n    return mat4(1.0,  0.0,  0.0,  -p.x,\n              0.0,  1.0,  0.0,  -p.y,\n              0.0,  0.0,  1.0,  -p.z,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 scale(vec3 s) {\n    return mat4(s.x,  0.0,  0.0,  0.0,\n              0.0,  s.y,  0.0,  0.0,\n              0.0,  0.0,  s.z,  0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(c,  -s,  0.0,  0.0,\n              s,  c,  0.0,  0.0,\n              0.0,  0.0,  1.0,  0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(c,  0.0, s,  0.0,\n              0.0,  1.0, 0.0, 0.0,\n              -s,  0.0, c,  0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, c,  -s,  0.0, \n                0.0, s,  c,  0.0,\n                0.0,  0.0,  0.0,  1.0);\n}\n\nfloat g(vec3 x) {\n    mat4 m = rotateZ(1.5*iTime)*scale(vec3(1.5, 2.5, 1.0));\n    x = (vec4(x, 1.0)*m).xyz;\n    return (length(x)-1.0)/2.5;\n}\n\nfloat h(vec3 x) {\n    mat4 m = rotateZ(1.5*iTime)*scale(vec3(1.0, 1.0, 1.0));\n    return g((vec4(x, 1.0)*m).xyz);\n}\n\nfloat f(vec3 x) {\n    mat4 m = translate(vec3(0.2, -0.11, 0.1))*rotateX(0.03*sin(0.5+2.0*iTime))*scale(vec3(1.01, 1.01, 1.01))*rotateZ(-0.025+0.075*sin(2.0*iTime));\n    float norm = 1.01;\n    float s = 1.0;\n    float t = 1000.0;\n    for (int i = 0; i < 30; ++i) {\n        x.x = abs(x.x);\n        float hh = h(x)/s;\n        t = min(t, hh);\n        x = (vec4(x, 1.0)*m).xyz;\n        s *= norm;\n    }\n    return t;\n}\n\nfloat eps = 0.0001;\nfloat lambda = 2.0;\n\n\nfloat lighting(vec3 x, vec3 n) {\n    return 4.0*f(x+0.1*n);\n}\n\nvec3 march(vec3 p, vec3 d) {\n    float c;\n    c = f(p);\n    if (c < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    for (int i = 0; i < 80; ++i) {\n        float step = max(0.01, 1.0*c);\n        p = p+step*d;\n        c = f(p);\n        if (c <= 0.0) {\n            float ex, ey, ez;\n            ex = f(p+vec3(eps, 0.0, 0.0));\n            ey = f(p+vec3(0.0, eps, 0.0));\n            ez = f(p+vec3(0.0, 0.0, eps));\n            vec3 n = vec3(ex-c, ey-c, ez-c)/eps;\n            n = normalize(n);\n            //mat4 m = rotateY(0.1*iTime);\n            //vec3 light = (vec4(1.0,1.0,-1.0,1.0)*m).xyz;\n            //float l = 0.2+0.8*max(dot(n, light)/sqrt(3.0), 0.0);\n            float l = 1.5*lighting(p, n);\n            return vec3(l)*vec3(1.9, 1.2, 1.2);\n        }\n    }\n    return vec3(0.1, 0.2, 0.3);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy-0.5*iResolution.xy;\n    uv = 2.0*uv/iResolution.y;\n    vec2 xy = iMouse.xy/iResolution.xy;\n\n    vec3 p = vec3(0.0, 0.0, -10.0)+0.1*vec3(xy.x, xy.y, 0.0);;\n    vec3 d = normalize(vec3(0.5*uv, 1.0));\n    mat4 m = rotateY(0.1*iTime);\n    p = (vec4(p, 1.0)*m).xyz;\n    d = (vec4(d, 1.0)*m).xyz;\n    vec3 color = march(p, d);\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsdfWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 177], [179, 179, 199, 199, 349], [351, 351, 378, 378, 573], [575, 575, 602, 602, 793], [795, 795, 822, 822, 1022], [1024, 1024, 1041, 1041, 1165], [1167, 1167, 1184, 1184, 1282], [1284, 1284, 1301, 1301, 1697], [1741, 1741, 1773, 1773, 1802], [1804, 1804, 1832, 1832, 2605], [2607, 2607, 2662, 2662, 3046]], "test": "ok"}
{"id": "XsdfWn", "name": "Squarewave fourier series visual", "author": "akhgary", "description": "visualization of square wave Fourier series using plots i learned recently. with help of yours of course.\n\nspecial thanks to FabriceNeyret2 and iq\n\nit messes up after the timer grows up. probably because of loss of precision. reset timer to fix the issue.", "tags": ["wave", "sin", "cos", "plot", "visualisation", "fourier", "squarewave", "series", "fourierseries"], "likes": 10, "viewed": 231, "published": "Public", "date": "1524697249", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fourier series:\n// http://mathworld.wolfram.com/FourierSeriesSquareWave.html\n// https://en.wikipedia.org/wiki/Fourier_series#Convergence\n// ========================================\n// distance formula used to plot squarewave smoothly\n// d = |fx-y|/sqrt(1+(dfx/dx)^2)\n// http://www.iquilezles.org/www/articles/distance/distance.htm\n// ========================================\n\nconst float pi = 3.14159265359;\nconst float scale = 2.0;\nconst float thickness = 3.0*scale;\n\nvec2 uvmap(vec2 uv)\n{\n    return (2.0*uv - iResolution.xy)/iResolution.y;\n}\n\n// color picker:\n// https://www.shadertoy.com/view/ll2cDc\nvec3 pickColor(float n) {\n    return 0.6+0.6*cos(6.3*n+vec3(0,23,21));\n}\n\nfloat circle(vec2 uv, vec2 C, float r, bool fill)\n{\n    vec2 p = uv-C;\n    float fx = length(p)-r;\n    float dist = fill? fx:abs(fx);\n    return smoothstep(thickness/iResolution.y,0.0,dist);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a, ba = b - a; \n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float dist = length(pa - ba * h);\n    return smoothstep(thickness/iResolution.y,0.0,dist);\n}\n\nfloat squarewave(float n, float x, float l, float phase){\n    return 4.0/(n*pi)*sin(n*pi*x/l+phase);\n}\n\n// derivative of series terms.\nfloat dsquarewave(float n, float x, float l, float phase){\n    return 4.0/l*cos(n*pi*x/l+phase);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = uvmap(fragCoord.xy)*scale;\n    float time = iTime/3.0;\n    vec3 col = vec3(0);\n    int terms = 10; // number of terms to produce\n    \n    float l = 1.0; // squarewave length divided by two.\n    vec2 c = vec2(0); // center of the circles\n    float sum = 0.0; // fourier series sum\n    float dsum = 0.0; // derivative of the sum\n    float tsum = 0.0; // sum for red line\n    \n    for(int i=0; i<terms; i++) {\n        float n = float(i)*2.0+1.0;\n        vec3 color = pickColor(n/float(terms*2));\n        \n        // calculate fourier series terms for circles\n        float term = squarewave(n, time, l, 0.0);\n        float cterm = squarewave(n, time, l, pi/2.0);\n        vec2 r = vec2(cterm,term);\n        \n        // plot circles\n        col += circle(uv,c,length(r),false)*color;\n        col += line(uv,c, c += r)*color;\n        \n        // calculate fourier series terms for wave plot\n        sum += squarewave(n, uv.x-time, l, 0.0);\n        dsum += dsquarewave(n, uv.x-time, l, 0.0);\n        tsum += term;\n    }\n    \n    // squarewave plot\n    float dist = abs(uv.y-sum)/sqrt(1.0+dsum*dsum);\n    col+=smoothstep(thickness/iResolution.y,0.0,dist);\n    \n    // red line\n    col+=(line(uv,c,vec2(+l,c.y))\n        + line(uv,c,vec2(-l,c.y))\n        + circle(uv,vec2(+l,tsum),0.01,true)\n        + circle(uv,vec2(-l,tsum),0.01,true))*vec3(1,0,0);\n    \n    // fill main circle\n    float term = squarewave(1., time, l, 0.0);\n    float cterm = squarewave(1., time, l, pi/2.0);\n    col+= circle(uv,vec2(0), sqrt(term*term+cterm*cterm), true)*.2*c.y*\n           vec3(sin(time), sin(time+2.*pi/3.), sin(time-2.*pi/3.));\n    \n    // output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsdfWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[472, 472, 493, 493, 547], [549, 607, 632, 632, 679], [681, 681, 732, 732, 873], [875, 875, 911, 911, 1100], [1102, 1102, 1159, 1159, 1204], [1206, 1237, 1295, 1295, 1335], [1337, 1337, 1394, 1394, 3078]], "test": "ok"}
{"id": "XsGcWG", "name": "tube yes", "author": "trbrmrdr", "description": "experiments in checkpoints", "tags": ["2d", "pulse", "eyes", "spiral", "circle", "shape"], "likes": 8, "viewed": 107, "published": "Public", "date": "1523038770", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\n#define Lenght 60.\nconst vec2 s_va = vec2(.0,.1);\nconst vec2 ss0 = vec2(.1,.2);\nconst vec2 s0 = vec2(.1,1.);\nconst vec2 s1 = vec2(.3, 1.);\nconst vec2 s2 = vec2(.4, .65);\nconst vec2 s3 = vec2(.45, .75);\nconst vec2 s_tex0 = vec2(.65,1.);\nconst vec2 s_tex1 = vec2(.55,1.);\n\nfloat sinab(float a,float b,float v){return a+((sin(v)+1.)*.5)*(b-a);}\n\nfloat check(vec2 pi) { \n    float p_time = mod(time, Lenght);\n    float ret = smoothstep(pi.x, pi.y, p_time/Lenght);\n    return ret;\n}\n\nfloat check(vec2 pi,float f_t){ return check(pi) * f_t; }\n\n//___________________\n                          \nfloat saturate(float x){return clamp(x,0.,3.);}\n\nvec3 tex0(vec2 u){\n\tvec2 p= fract( fract(u) + \n                  (sin(u.y+time)/\n                   (6.4 + check(s_tex0,-6.1))\n                   //sinab(4.,4.5,u_time)\n                  )\n                 );\n\tfloat f=1. - saturate((max(length(p-vec2(0.25,0.5)),length(p-vec2(0.75,0.5)))-.5)*50.);\n\tf-=1.-saturate((length(p\n                           -.5\n                           //-sinab(.1,.2,time)\n                          )\n                    //-hash(floor(u*10.1)).x\n                    //-sinab(.2,.28,u_time + u.y + u.x*3.14)\n                    -(.2 - check(s_tex1, -.2))\n                    //-.2\n                \t//-sinab(.2,.4,time +u.y+u.x*3.14 )\n                   ) *50.);\n\treturn vec3(f);\n}\n\n\n#define time2 (time*.5)\nvec3 tex(vec2 u){\n    float dm = sinab(.0,1.,time2);\n    //dm=.3;\n    float v1 = .0;\n    float v2 = .0;\n    v1 = v2 = check(s2,.3);\n    {\n    \tv1 += check(s3, smoothstep(.0,.3,dm));\n    \tv2 += check(s3, smoothstep(.0,1.1,dm));\n\t}\n    \n\tvec2 u1 =  vec2(sin(time2+3.14),cos(time2+1.45)) *v1;\n\tvec2 u2 = vec2(sin(time2+2.78),cos(time2)) * v2;\n\tfloat mixv = distance(u1,u2) *.13;\n\tvec3 c1 = tex0(u+u1);\n\tvec3 c2 = tex0(u+u2);\n\tfloat r = mix(c1.r, c2.r, mixv);\n\tfloat g = mix(c1.g, c2.g, 1.-mixv);\n\tfloat b = mix(c1.b, c2.b, mixv);\n\treturn vec3(r, g, b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float st_x = iResolution.x/iResolution.y; \n    uv.x *= st_x;\n    uv = uv*2.-vec2(1.*st_x,1.);\n    \n    float v_a = 1.+ check(s_va, .57);\n    float a = atan(uv.x,uv.y)/v_a;\n\tfloat d =  length(uv);\n    \n    float t = check(s0, time*.4 * (1.+check(vec2(.7,1.),-1.)));\n    float v_d = check(ss0,1.348);\n    vec2 k = vec2(a\n                  +check(s1,(time*0.005))\n                  ,v_d/d + t );\n    \n    vec3 tx =  tex(k * 4.);\n    fragColor = vec4(tx, 1.);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsGcWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[291, 291, 328, 328, 361], [363, 363, 385, 385, 497], [499, 499, 530, 530, 556], [607, 607, 631, 631, 654], [656, 656, 674, 674, 1365], [1392, 1392, 1409, 1409, 1943], [1945, 1945, 2002, 2002, 2506]], "test": "ok"}
{"id": "XsGcWV", "name": "SickBow's ellipses", "author": "sickbow", "description": "ellipses", "tags": ["ellipses"], "likes": 0, "viewed": 79, "published": "Public", "date": "1524382723", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159265358979\n\nvec3 ellipse(vec2 uv, vec3 baseCol, vec3 col, vec2 c, vec2 axes, float thickness){\n    \n    //thickness*=sin(iTime)+1.1;\n    \n    float eq = pow(uv.x - c.x,2.)/pow(axes.x,2.) + pow(uv.y - c.y,2.)/pow(axes.y,2.);\n\tfloat dist = abs(1.-eq);\n    \n    \n    col += smoothstep(thickness,0.,dist) * baseCol;\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.);\n    vec3 baseCol = vec3(.5*(cos(iTime)+1.)/2.,.5*(cos(iTime/2.)+1.)/2.,.5*(cos(iTime)+1.)/2.);\n    \n    for (float i = 0.; i < 314.;i++){\n    \n        col = ellipse(uv, baseCol, col,vec2(cos(iTime+i*.06),-.85+1.6*(sin(iTime+i*.08)+1.)/2.),\n                      \n                      vec2(.1,.05),.45);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsGcWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 111, 149, 356], [358, 358, 415, 465, 923]], "test": "ok"}
{"id": "XsKczV", "name": "Computed Spherical Harmonics", "author": "hallabada", "description": "Simple ray tracer for SHs\n\nChange L and M values to draw different SH.\nRotation of SH is not included. Current implementation of rotation is wrong.", "tags": ["raytracer", "sphericalharmonics"], "likes": 0, "viewed": 142, "published": "Public", "date": "1522730583", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n* Written by Jung, Yucheol <ycjung@postech.ac.kr>\n* ycjungSubhuman@github.com\n*\n* Reference : Robin Green, Spherical Harmonic Lighting - The Grity Details\n* Visualizes spherical harmonics\n*\n* Calculates SH without using pre-computed values\n*/\n\n/** \n * MODIFY THESE VALUES TO SEE DIFFERENT SHs \n * L > 0, L is int.\n * -L <= M <= L, M is int.\n */\n#define L 1\n#define M 0\n\n/* MATH UTILITIES *************************************************************/\n#define PI 3.14159265358979323846264\n#define SQRT_TWO 1.41421356237309504880169\n\nconst int factorial_table[12] = int[12](\n  1,\n  2,\n  6,\n  24,\n  120,\n  720,\n  5040,\n  40320,\n  362880,\n  3628800,\n  39916800,\n  479001600);\n\nint factorial (int n) {\n  return factorial_table[n-1];\n}\n\n/* SH *************************************************************************/\n\n/**\n* Calculate associated Legendre polynomial\n*\n* \"Numerical Methods in C: The Art of Scientific Computing”,\n* Cambridge University Press, 1992, pp 252-254\n*/\nfloat P(int l, int m, float x) {\n  // Calculate P_m^m first (Because it has a closed form)\n  float p_mm=1.0;\n  if (m>0) {\n    float somx2 = sqrt((1.0-x)*(1.0+x));\n    float fact = 1.0;\n    for(int i=1; i<=m; i++) {\n      p_mm *= (-fact) * somx2;\n      fact += 2.0;\n    }\n  }\n  // If l==m, no need for further calculation, return.\n  if (l==m) return p_mm;\n  // Proceed to P_{m+1}^{m} using P_m^m\n  float p_mmp1 = x * (2.0*float(m) + 1.0) * p_mm;\n  // Just a micro optimization with early return\n  if (l==m+1) return p_mmp1;\n  // Calclulate general p_l^{m}\n  // Using relation\n  //   (l-m)P_l^m = x(2l-1)P_{l-1}^m - (l+m-1)P_{l-2}^m\n  float p_ll = 0.0;\n  for (int ll=m+2; ll<=l; ll++) {\n    p_ll = ( (2.0*float(ll)-1.0)*x*p_mmp1-(float(ll)+float(m)-1.0)*p_mm )\n    / float(ll-m);\n    p_mm = p_mmp1;\n    p_mmp1 = p_ll;\n  }\n  return p_ll;\n}\n\n/** Normalization coefficient for SH */\nfloat K(int l, int m) {\n  return sqrt(\n    (2.0*float(l)+1.0)*float(factorial(l-m))\n    / (4.0*PI*float(factorial(l+m)))\n    );\n}\n\n/** SH of l, m, theta(zenith), phi(azimuth) */\nfloat SH(int l, int m, float theta, float phi) {\n  if (m==0) {\n    return K(1, 0)*P(l, m, cos(theta));\n  }\n  else if (m>0) {\n    return SQRT_TWO*K(l,m)*cos(float(m)*phi)*P(l,m,cos(theta));\n  }\n  else {\n    return SQRT_TWO*K(l,-m)*sin(-float(m)*phi)*P(l,-m,cos(theta));\n  }\n}\n\n/* RAYTRACING *****************************************************************/\n// Reference : Annotated Ray Tracing by Polytonic\n// (https://www.shadertoy.com/view/4ljGRd)\n// Reference : Jamie Wong, Ray marching signed distance functions\n// (http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/)\n#define RENDER_EPSILON    1e-4\n#define RENDER_ITERATION  200\n#define RENDER_RAY_RECURSION  1\n#define RENDER_ENDDEPTH   50.0\n#define RENDER_EXPOSURE   5e-2\n#define RENDER_GAMMA      2.2\n#define RENDER_INTENSITY  100.0\n#define RENDER_AMBIENT (vec3(0.6, 0.8, 1.0) * RENDER_INTENSITY / RENDER_GAMMA)\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\n\nstruct Intersect {\n  float len;\n  vec3 normal;\n};\n    \nconst Intersect MISS = Intersect(0.0, vec3(0.0));\n\n/* RAYTRACING-SDF *************************************************************/\nfloat sdf_sh(int l, int m, float scale, vec3 sh_position, vec3 ray_position, vec3 ro) {\n  vec3 p = (ray_position - sh_position);\n  float pr = length(p);\n  float theta = atan(sqrt(p.x*p.x + p.y*p.y)/p.z);\n  float phi = PI+atan(p.x, p.y);\n  \n  float fr = scale*abs(SH(l, m, theta, phi));\n   \n  vec3 delta = ray_position - fr*normalize(p);\n  if(dot(delta, p) < 0.0) {\n      return -length(delta);\n  }\n  else {\n      return length(delta);\n  }\n}\n\n/* RAYTRACING-SCENE-RENDER ****************************************************/\n#define NUM_SH_BANDS 5\n#define SCENE_SH_COUNT (NUM_SH_BANDS*NUM_SH_BANDS)\n\nfloat sdf_scene(vec3 p, vec3 ro) {\n  float sh = sdf_sh(L,M, 5.0, vec3(0.0, 0.0, 0.0), p, ro);\n  return sh;\n}\n\nvec3 estimate_normal(vec3 p, vec3 ro) {\n  return normalize(vec3(\n    sdf_scene(vec3(p.x + RENDER_EPSILON, p.y, p.z), ro)\n    - sdf_scene(vec3(p.x - RENDER_EPSILON, p.y, p.z), ro),\n    sdf_scene(vec3(p.x, p.y + RENDER_EPSILON, p.z), ro)\n    - sdf_scene(vec3(p.x, p.y - RENDER_EPSILON, p.z), ro),\n    sdf_scene(vec3(p.x, p.y, p.z + RENDER_EPSILON), ro)\n    - sdf_scene(vec3(p.x, p.y, p.z - RENDER_EPSILON), ro)\n    ));\n}\n\nIntersect trace(Ray ray) {\n  float depth = 0.0;\n\n  for (int i=0; i<RENDER_ITERATION; i++) {\n    float dist = sdf_scene(ray.origin + depth*ray.direction, ray.origin);\n\n    if (dist < RENDER_EPSILON) {\n      break;\n    }\n    depth += dist;\n\n    if (depth >= RENDER_ENDDEPTH) {\n      return MISS;\n      break;\n    }\n  }\n  return Intersect(depth, estimate_normal(ray.origin + depth*ray.direction, ray.origin));\n}\n\nLight light = Light(vec3(1.0, 1.0, 1.0), normalize(vec3(1.0, 1.0, 1.0)));\n\nvec3 render(Ray ray) {\n  vec3 color = vec3(0.0);\n  vec3 color_surf = vec3(1.0, 2.0, 1.0);\n\n  for (int i=0; i<RENDER_RAY_RECURSION; i++) {\n    Intersect hit = trace(ray);\n\tvec3 reflection = reflect(ray.direction, hit.normal);\n    Intersect next_hit = trace(Ray(ray.origin + ray.direction*hit.len + 1e9*light.direction, light.direction));\n    if (next_hit == MISS){\n      color += clamp(dot(hit.normal, light.direction), 0.1, 1.0)\n                 * light.color * color_surf;\n    }\n    \n    if (hit == MISS) { \n      color *= RENDER_AMBIENT;\n      break;\n    }\n\n    ray = Ray(ray.origin + ray.direction*hit.len + RENDER_EPSILON*reflection,\n      reflection);\n  }\n  return color;\n}\n\n/* MAIN ***********************************************************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  // coordinate whose (0,0) is the center of canvas.\n  // independent of aspect ratio\n  vec2 p = vec2((-0.5+uv.x)*(iResolution.x/iResolution.y), -0.5+uv.y);\n\n    //Camera code from iq (https://www.shadertoy.com/view/lsfXWH)\n    // camera\n    float an = 10.0*iMouse.x/iResolution.x;\n    vec3  ro = vec3(12.0*sin(an),0.0,12.0*cos(an));\n    vec3  ta = vec3(0.0,0.0,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n  light.direction = normalize(vec3(1, 2.0*sin(iTime), 1.0*sin(2.0*iTime)));\n  //Ray ray = Ray(vec3(0.0, 0.0, 12), normalize(vec3(p.x, p.y, -1.0)));\n    Ray ray = Ray(ro, rd);\n  fragColor = vec4(pow(render(ray)*RENDER_EXPOSURE, vec3(1.0/RENDER_GAMMA)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsKczV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[677, 677, 700, 700, 733], [1817, 1857, 1880, 1880, 1986], [1988, 2035, 2083, 2083, 2309], [3133, 3214, 3301, 3301, 3654], [3812, 3812, 3846, 3846, 3920], [3922, 3922, 3961, 3961, 4340], [4342, 4342, 4368, 4368, 4750], [4827, 4827, 4849, 4849, 5505], [5507, 5588, 5645, 5645, 6530]], "test": "error"}
{"id": "XsKyz3", "name": "Fbm test", "author": "ircss", "description": "Continue learning from Book of Shaders. ", "tags": ["fbm"], "likes": 24, "viewed": 463, "published": "Public", "date": "1522795458", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWO_PI 6.28318530718\nvec3 random3(vec3 st)\n{\n    st = vec3( dot(st,vec3(127.1,311.7,211.2)/20.),\n            \tdot(st,vec3(269.5,183.3, 157.1)), dot(st,vec3(269.5,183.3, 17.1))  );\n   \treturn -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\nfloat noise3D(vec3 st) \n{\n\tvec3 i = floor(st) ;\n  \tvec3 f = fract(st);\n\t\t\n    vec3 u = smoothstep(0.,1.,f);\n    \n\tfloat valueNowxy01 =mix( mix( dot( random3(i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ),\n                    \t\t \t dot( random3(i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                \t\tmix( dot( random3(i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ),\n                     \t\t \t dot( random3(i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y);\n\tfloat valueNowxy02 =mix( mix( dot( random3(i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ),\n                    \t\t \t dot( random3(i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                \t\tmix( dot( random3(i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ),\n                     \t\t \t dot( random3(i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y);\n\n    float toReturn = abs(mix(valueNowxy01, valueNowxy02, u.z));\n    return pow(.2, toReturn) -0.4;;\n\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nfloat fbm(vec2 st){\n    \n    const int n = 6;\n    float toReturn = 0.;\n    float frequencyIncrease = 2.9;\n    float amplitudeDecrese = 0.5;\n    float amplitude = 0.9;\n    float frequency = 1.;\n    \n    for(int i = 0; i < n; i++){\n        \n        float det =  float(mod(float(i),2.)==0.);\n        int signMul = (int(det)*2)-1;\n        toReturn += amplitude*noise3D(vec3(st.xy *rotate2d(float(i/n))*frequency, iTime*0.1*amplitude));\n        \n        amplitude *= amplitudeDecrese ;\n        \n        frequency *= frequencyIncrease;\n    }\n    \n    return toReturn;\n    \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\tvec2 toCenter = vec2(0.5) - uv ;\n    float dis = length(toCenter);\n    float angle = (acos(toCenter.x*1.0/dis)/TWO_PI)*2. ;\n    //vec2 st = vec2(angle , dis );\n    vec2 st = uv;\n    // Time varying pixel color\n    float r1 = fbm( st);\n    float r2 = fbm( st*rotate2d(1.14) + vec2(1412., 124.)+r1);\n\tfloat colt = fbm( st*rotate2d(0.213) +vec2(14122., 14.)+r2);\n    // Output to screen\n    vec3 finColor = mix(vec3(r1, r2, colt), vec3(0.121, pow(min(r1,r2),2.), 0.2), colt);\n    finColor = mix(finColor, \n                   vec3(dot(finColor, vec3(0.91,abs(sin(iTime*0.2)),0.2)), dot(finColor, vec3(colt)), colt*r1), r2); \n    fragColor = vec4(finColor,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsKyz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 52, 52, 241], [242, 242, 267, 267, 1208], [1209, 1209, 1237, 1237, 1323], [1902, 1902, 1959, 2009, 2707]], "test": "timeout"}
{"id": "XsKyzc", "name": "Spinning Square - No Antialias", "author": "DonKarlssonSan", "description": "You must give a description to your shader", "tags": ["square", "step"], "likes": 0, "viewed": 328, "published": "Public API", "date": "1522792965", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rotate(a)  mat2(cos(a), -sin(a), sin(a), cos(a))\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -0.5 * iResolution.xy) / iResolution.x * rotate(iTime / 3.0);\n\n    float left = step(-0.2, uv.x); \n    float bottom = step(-0.2, uv.y);\n    float top = step(0.8, 1.0 - uv.x);\n    float right = step(0.8, 1.0 - uv.y);   \n    \n    vec3 color = vec3(left * top * right * bottom);\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsKyzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 113, 113, 458]], "test": "ok"}
{"id": "XsKyzV", "name": "25 Minutes", "author": "NohatCoder", "description": "Inspired by the competition at RevisionParty I wanted to see what I could do in 25 minutes. I don't think this would have impressed the floor greatly, but at least I got something.", "tags": ["speedshading"], "likes": 0, "viewed": 314, "published": "Public API", "date": "1522656840", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rnd(float i){\n    float i1=floor(i*100.);\n    float i2=ceil(i*100.);\n    float i11=mod(cos(i1*mod(i1,3.)*.00632)*346.9,1.);\n    float i22=mod(cos(i2*mod(i2,3.)*.00632)*346.9,1.);\n    float span=mod(i*100.,1.);\n    return i22*span+i11*(1.-span);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.yy;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    float layer=floor(iTime/2.);\n    float zoom=mod(iTime/2.,1.);\n    float a;\n    for(a=0.;a<10.;a++){\n        float zooma=pow(1.2,a+zoom);\n        vec2 uvzoom=uv/zooma;\n        float h=rnd(a-layer+uvzoom.x)*.1-.2;\n        if(h>uvzoom.y){\n            fragColor = vec4(vec3(a+zoom)*.1,1.0);\n        }\n    }\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsKyzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 252], [254, 254, 311, 311, 836]], "test": "ok"}
{"id": "XstBD8", "name": "Mandelbrot attachment positions", "author": "akhgary", "description": "this is the zoomed version of https://www.shadertoy.com/view/Ms3fD8\n\nI wanted to make sure that radius i calculated was correct. so i made a zoomed version of it. \n\nmodify \"zoom\" to your desired value.", "tags": ["mandelbrot", "line", "circle", "distance", "complex", "draw", "pattern", "generalized", "modular", "times", "timestable", "timestables"], "likes": 5, "viewed": 108, "published": "Public", "date": "1524909504", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ===========================================\n// mandelbrot set attachment positions\n//\n// coordinates of attachment positions of mandelbrot set \n// this only holds for N>=2 assuming N is integer\n//\n// there are always N-1 attachments from primary shape to secondary shapes.\n// for example there is 1 attachment from cardioid to the left circle when N=2.\n//\n// coordinates of this attachments can be calculated in this way. \n//\n// let \n//\t\tradian = -k*pi/(N-1);   k = 1,3,5,7 ...      \n//\t\tradius = (7+N)/(10+N);\n// then \n// \t\tx = radius*cos(radian)\n// \t\ty = radius*sin(radian)\n//\n// note that k always cycles through N. \n// that means k and mod(k, N) gives same coordinates.\n//\n// ============================================\n// all of this was achieved by experiment. i dont have mathematical proof.\n// ============================================\n\nconst float pi = 3.14159265359;\nconst float epsilon = 1e-5;\n\nconst float zoom = 4.0;\nconst float thickness = 3.0/zoom;\n\n// mandelbrot set properties\nconst int iterations = 100;\nconst float bailout = 100.0;\n\n// times table properties\nconst int modular = 200;\n\n// shared properties\nconst float minPower = 2.0; // minimum power of Z.\nconst float maxPower = 10.0; // maximum power of Z.\nconst float duration = 50.0; // transition cycle duration in seconds.\n\n\nvec2 uvmap(vec2 uv) {\n    return (2.0*uv-iResolution.xy)/iResolution.y;\n}\n\nvec3 pickColor(float n) {\n    return 0.6+0.6*cos(6.3*n+vec3(0,23,21));\n}\n\nfloat smoothout(float dist){\n    return smoothstep(thickness/iResolution.y,0.0,dist);\n}\n\nfloat smoothfloor(float x) {\n    return x - sin(2.0*pi*x)/(2.0*pi);\n}\n\nfloat clock(){\n    float rad = acos(cos(2.0*pi*iTime/duration));\n    return (maxPower-minPower)*rad/pi + minPower;\n}\n\nfloat circle(vec2 uv, vec2 C, float r, bool fill)\n{\n    vec2 p = uv-C;\n    float fx = length(p)-r;\n    float dist = fill? fx:abs(fx);\n    return smoothout(dist);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a, ba = b - a; \n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float dist = length(pa - ba * h);\n    return smoothout(dist);\n}\n\nvec2 function(vec2 z, float n) {\n    float r = pow(dot(z, z), n/2.0);\n    float th = n*atan(z.y,z.x+epsilon);\n    return r*vec2(cos(th), sin(th));\n}\n\nvec2 dfunction(vec2 z, vec2 dz, float n){\n    // f(f(z))' = f'(f(z))*f'(z)\n\tvec2 df = n*function(z, n - 1.0);\n\treturn vec2(df.x*dz.x-df.y*dz.y, df.x*dz.y + df.y*dz.x) + vec2(1,0);\n}\n\nfloat mandelbrotDistance(float r, float dr) {\n    float dist = r*log(r)/dr;\n    return clamp(pow(dist,0.25),0.0,1.0);\n}\n\nvec3 mandelbrot(vec2 uv, float n) {\n    vec3 set = vec3(0);\n    vec2 c = uv;\n    vec2 z = c;\n    vec2 dz = vec2(1, 0);\n    \n    for(int i = 0; i < iterations && dot(z, z) <= bailout; i++) {\n\t    dz = dfunction(z,dz,n);\n\t    z = function(z,n) + c;\n    }\n    \n    float dist = mandelbrotDistance(length(z), length(dz));\n    \n    if(dot(z, z) > bailout) set = dist+pickColor(n/5.0)/2.0;\n    \n    return clamp(set*0.8,0.0,1.0);\n}\n\nvec3 timesTable(vec2 uv, float times)\n{\n    vec3 col = vec3(0);\n    float len = 2.0*pi/float(modular);\n    float r = (7.0+times)/(10.0+times); // radius of the circle\n    float phase = -pi/(times-1.0);\n    \n    col+=circle(uv,vec2(0),r,false);\n    \n    for(int i = 0; i < modular; i++) {\n        float n = float(i);\n        \n        vec2 c = vec2(cos(n*len+phase),sin(n*len+phase))*r;\n        vec2 p = vec2(cos(n*len*times+phase),sin(n*len*times+phase))*r;\n        \n        col+= circle(uv,c,0.005,true);\n        col+= line(uv,c,p)*pickColor(n/float(modular)/3.+iTime/10.0);\n    }\n    return clamp(col*0.5,0.0,1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t\n    float N = smoothfloor(clock());\n    float radian = -pi/(N-1.0);\n    float radius = (7.0+N)/(10.0+N);\n    vec2 position = vec2(cos(radian),sin(radian))*radius; // attachment position\n    \n    vec2 uv = uvmap(fragCoord.xy)/zoom+position;\n    \n    vec3 color = mandelbrot(uv,N)\n               + timesTable(uv,N);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XstBD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1307, 1307, 1328, 1328, 1380], [1382, 1382, 1407, 1407, 1454], [1456, 1456, 1484, 1484, 1543], [1545, 1545, 1573, 1573, 1614], [1616, 1616, 1630, 1630, 1732], [1734, 1734, 1785, 1785, 1897], [1899, 1899, 1935, 1935, 2095], [2097, 2097, 2129, 2129, 2245], [2247, 2247, 2288, 2321, 2428], [2430, 2430, 2475, 2475, 2549], [2551, 2551, 2586, 2586, 2976], [2978, 2978, 3017, 3017, 3595], [3597, 3597, 3652, 3652, 4008]], "test": "ok"}
{"id": "XstBDr", "name": "make's first shader", "author": "make", "description": "Moving gradient from center to edges", "tags": ["gradient"], "likes": 0, "viewed": 342, "published": "Public API", "date": "1524737227", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) * 2.0;\n    uv = uv * uv;\n        \n    vec3 phases = (vec3(0.0, 1.0/3.0, 2.0/3.0) + sqrt(uv.x + uv.y)) * M_PI - iTime;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * sin(phases);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XstBDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 105, 155, 451]], "test": "ok"}
{"id": "XsVcD3", "name": "My New Osu Circle Skin ", "author": "Acivev", "description": "Kappa", "tags": ["osu"], "likes": 4, "viewed": 129, "published": "Public", "date": "1523568883", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based off https://www.shadertoy.com/view/MdVyRK\n\n#define SEED 0.12345679\n\n#define TRI 64.0\n#define SP 0.5\n#define COLOR vec3(0.9411764705882353,0.4274509803921569,0.6549019607843137)\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define HALFPI 1.5707963268\n\nfloat rand (vec2 p) {\n    return fract(sin(dot(p.xy,\n                         vec2(6.8245,7.1248)))*\n        9.1283);\n}\n\nfloat tri(vec2 uv, vec2 p, float s){\n    vec2 v = uv;\n    v -= p;\n    v /= max(s, 0.01);\n    \n\tfloat a = atan(v.x, v.y) + PI;\n    float r = TWO_PI / 3.0;\n    \n    float t = cos(floor(0.5 + a / r) * r - a) * length(v);\n    \n    return smoothstep(0.4, 0.41, t);\n}\n\nfloat yPos(float i){\n    vec2 p = vec2(SEED, i);\n    \n    float r = rand(p);\n    return fract(iTime * SP + r);\n}\n\nfloat xPos(float i, float t){\n    vec2 p = vec2(i, t - iTime * SP);\n    return rand(p) + .375;\n}\n\nvec3 triCol(float i, float t){\n    vec3 col = COLOR;\n    float r = xPos(i + 1.0, t);\n    col *= mix(0.9, 1.1, r);\n    return col;\n}\n\nfloat atan2(float y, float x) {\n \tif(x>0.)return atan(y/x);\n    if(x==0.)if(y>0.)return HALFPI;else return -HALFPI;\n    if(y<0.)return atan(y/x)-PI;return atan(y/x)+PI;\n}\nfloat atan2(vec2 v){return atan2(v.y,v.x);}\nfloat steq(float x,float a,float b){return step(a,x)*step(x,b);}\nvec2 cub_(float t,vec2 a,vec2 b){\n    float ct=1.-t;\n    return 3.*ct*ct*t*a+3.*ct*t*t*b+t*t*t;\n}\nfloat cub(float x,vec2 a,vec2 b){\n    vec2 it=vec2(0.,1.);\n    for (int i=0;i<7;i++) {\n        float pos=(it.x+it.y)/2.;\n        vec2 r=cub_(pos,a,b);\n        if (r.x>x){\n            it.y=pos;\n        }else{\n            it.x=pos;\n        }\n    }\n    return cub_((it.x+it.y)/2.,a,b).y;\n}\nfloat isine(float t){return -1.*cos(t*HALFPI)+1.;}\nfloat osine(float t){return sin(t*HALFPI);}\nfloat iquad(float t){return t*t;}\nfloat oc(float t){t=t-1.;return t*t*t+1.;}\nvec2 oc(vec2 v){return vec2(oc(v.x),oc(v.y));}\nfloat icirc(float t){return -1.*(sqrt(1.-t*t)-1.);}\nvec3 spin(vec3 col_,vec2 fc) {\n    vec3 col=col_;\n    float a=mod(degrees(atan2(fc-iResolution.xy/2.-.5)),360.);\n    float b=mod(iTime*100.,360.);\n    float s=25.;\n    float mi=mod(b-s,360.);\n    float ma=mod(b+s,360.);\n    float d=abs(b-a);\n    if(d>180.)d=a<b?a-b+360.:b+360.-a;\n    if((a>mi||(mi>ma&&a<ma))&&(a<ma||mi>ma))col+=1.-iquad(d/s);\n    return col;\n}\nfloat mb(){\n    return clamp(texture(iChannel0,vec2(0.02,0.2)),0.,1.).x;\n}\nvec3 barz(float d,vec2 fc,float off,float sp) {\n    float a=degrees(atan2(fc-iResolution.xy/2.-.5))/180.+1.;\n    a=mod(a+iTime/sp+off+mb()/3.,2.);\n    a-=1.;\n    if(a<0.)a=-a+0.01;\n    float m=mod(a,.025);\n    if(m<0.01*(1.+d*.6))return vec3(0.);\n    a-=m;\n    float v=clamp(texture(iChannel0,vec2(a,0.1)).x,0.,1.);\n    if (v>d) return vec3(1.);\n    return vec3(0.);\n}\nfloat osu_excdot(vec2 uv) {\n    const float ds=.07;\n    vec2 exc=oc((ds*2.-abs(uv))/ds/2.)*.04;\n    return steq(uv.x,-ds-exc.y,ds+exc.y)*steq(uv.y,-ds-exc.x,ds+exc.x);\n}\nfloat osu_excbody(vec2 uv) {\n    float e=oc((.2-abs(uv.x))/.2)*.04;\n    float ew=(uv.y+.15)*.01;\n    return steq(uv.x,-.1-ew,.1+ew)*steq(uv.y,-.2-e,.2+e);\n}\nfloat osu_u(vec2 uv) {\n    float r=1.18181818;\n    uv+=vec2(.5/r,.5);\n    uv.x*=r;\n    uv.y=1.-uv.y;\n    float c=1.;\n    c-=steq(uv.x,.31,.69)*steq(uv.y,.0,.765-.245*cub(1.-(uv.x-.31)/.38,vec2(.4,-.116),vec2(.994,-.27)));\n    float b=.48*cub(1.-uv.x,vec2(.252,-.164),vec2(1.038,-.52));\n    return c*steq(uv.x,0.,1.)*steq(uv.y,.02*isine(abs(mod(uv.x,.69)-.155)/.31),.933-b);\n}\nfloat osu_sunpy(vec2 uv) {\n    float r=1.397928994;\n    uv+=vec2(.5/r,.5);\n    uv.x*=r;\n    if (steq(uv.x,0.,1.)*steq(uv.y,0.,1.)==0.) {\n        return 0.;\n    }\n    uv.y=1.-uv.y;\n    float c=1.;\n    c-=steq(uv.x,.0,.035+.515*icirc((.3-uv.y)/.3))*steq(uv.y,.0,.3);\n    c-=steq(uv.x,.55,1.)*steq(uv.y,.0,.055*isine(clamp((uv.x-.55)/.4,.0,1.)));\n    c-=steq(uv.x,.95-.07*isine(clamp((uv.y-.055)/.192/*.195*/,.0,1.)),1.)*steq(uv.y,.055,.28);\n    c-=steq(uv.x,.59,.88)*steq(uv.y,.2+.045*isine((uv.x-.59)/.29),.28);\n    c-=steq(uv.x,.4+.19*icirc(1.-(uv.y-.2)/.08),.59)*steq(uv.y,.2,.28);\n    c-=steq(uv.x,.4+.6*cub((uv.y-.28)/.395,vec2(.408,.011),vec2(.104,1.014)),1.)*steq(uv.y,.28,.675);\n    c-=steq(uv.x,1.-.585*icirc((uv.y-.675)/.325),1.)*steq(uv.y,.675,1.);\n    c-=steq(uv.x,.0,.415)*steq(uv.y,.94+.06*osine(uv.x/.415),1.);\n    c-=steq(uv.x,.0,.085*isine(1.-(uv.y-.75)/.19))*steq(uv.y,.75,.94);\n    c-=steq(uv.x,.0,.4)*steq(uv.y,.69,.75+.045*osine(clamp((uv.x-.085)/.315,0.,1.)));\n    c-=steq(uv.x,.4,.645)*steq(uv.y,.69,.795-.105*icirc((uv.x-.4)/.245));\n    c-=steq(uv.x,.0,.035+.61*cub((uv.y-.3)/.39,vec2(.891,-.042),vec2(.592,.977)))*steq(uv.y,.3,.69);\n    return c;\n}\nfloat osu_o(vec2 uv) {\n    float r=1.091666;\n    uv.x*=r;\n    uv.y=1.-abs(uv.y);\n    uv.x=abs(uv.x);\n    float te=cub(uv.x,vec2(.667,.013),vec2(.988,.366));\n    float be=1.-cub(clamp(uv.x/.402,0.,1.),vec2(.783,.035),vec2(.915,.241));\n    return steq(uv.x,0.,1.)*steq(uv.y,0.+te,1.-.595*be);\n}\nfloat osu(vec2 uv) {\n    float col=0.;\n    col+=osu_excdot((uv-vec2(.806,-.192))*1.4);\n    col+=osu_excbody((uv-vec2(.806,.23))*vec2(1.35,.9));\n    col+=osu_u((uv-vec2(.379,.0))*1.7);\n    col+=osu_sunpy((uv-vec2(-.134,.0))*1.7);\n    col+=osu_o((uv-vec2(-.667,.0))*3.4);\n    return col;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float s = 1.2-texture(iChannel0, vec2(0.52,0.2)).x*.4;\n    vec2 uv = fragCoord/iResolution.xy * s-(s-1.)*.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = COLOR;\n    \n    // Generate all dem triangles\n    for (float i = TRI; i > 0.1; i--){\n        float id = i / TRI;\n        float y = yPos(id);\n        float x = xPos(id, y);\n        float s = min(0.89, max(0.071, id * 0.5));\n        float shad = tri(\n            uv,\n            vec2(x, mix(-s, 3.0 + s / 2.0, y)),\n            s\n        );\n        \n        if (shad < 0.1)\n        \tcol = triCol(id, y) * (1.0 - shad);\n    }\n    \n    // Set background mask\n    vec2 mid=vec2(.5*iResolution.x/iResolution.y,.5);\n    float dist = distance(uv,mid);\n    if (dist > 0.4) {\n        col = vec3(0.0);\n        if (dist<0.65){\n            float sp=3.;\n            float el=.1+.2*mb();\n            float d=(dist-.4)/.25;\n          \tcol+=barz(d,fragCoord,0.,sp);\n          \tcol+=barz(d,fragCoord,.5,sp);\n          \tcol+=barz(d,fragCoord,1.,sp);\n          \tcol+=barz(d,fragCoord,1.5,sp);\n            col*=el;\n            col.x*=.75;\n            col.y*=.75;\n        }\n    } else\n        if(dist>0.32&&dist<0.37)col=spin(col,fragCoord);\n    \n    // Make circle logo shadow\n    float dist_shad = distance(uv, vec2(0.5 * iResolution.x / iResolution.y, 0.49));\n    float l_shad = abs(dist_shad - 0.4);\n    col *= mix(0.3, 1.0, min(1.0, l_shad * 30.0));\n    \n    // Make circle logo\n    float l = abs(dist - 0.5);\n    col += vec3(smoothstep(0.96, 0.97, 1.0 - l));\n    \n    if(dist<0.3) //for perf\n    col+=vec3(osu((uv-mid)/.02));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "ld2XWm", "previewfilepath": "https://soundcloud.com/nocopyrightsounds/cartoon-why-we-lose-feat-coleman-trapp-ncs-release", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/nocopyrightsounds/cartoon-why-we-lose-feat-coleman-trapp-ncs-release", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVcD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[270, 270, 291, 291, 389], [391, 391, 427, 427, 652], [654, 654, 674, 674, 766], [768, 768, 797, 797, 864], [866, 866, 896, 896, 997], [999, 999, 1030, 1030, 1169], [1170, 1170, 1190, 1190, 1213], [1214, 1214, 1250, 1250, 1278], [1279, 1279, 1312, 1312, 1376], [1377, 1377, 1410, 1410, 1663], [1664, 1664, 1685, 1685, 1714], [1715, 1715, 1736, 1736, 1758], [1759, 1759, 1780, 1780, 1792], [1793, 1793, 1811, 1811, 1835], [1836, 1836, 1852, 1852, 1882], [1883, 1883, 1904, 1904, 1934], [1935, 1935, 1965, 1965, 2297], [2298, 2298, 2309, 2309, 2372], [2373, 2373, 2420, 2420, 2741], [2742, 2742, 2769, 2769, 2911], [2912, 2912, 2940, 2940, 3068], [3069, 3069, 3091, 3091, 3444], [3445, 3445, 3471, 3471, 4616], [4617, 4617, 4639, 4639, 4909], [4910, 4910, 4930, 4930, 5197], [5198, 5198, 5252, 5252, 6873]], "test": "error"}
{"id": "XsVcDy", "name": "glyphspinner", "author": "mattz", "description": "Mouse to zig-zag through alphabet; click in lower left to return to animation.", "tags": ["text", "font", "rotation", "mesmerizing", "90scolors"], "likes": 167, "viewed": 4320, "published": "Public API", "date": "1523238126", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \"glyphspinner\" by mattz\n   License: https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n   I've been carrying this shader in my head for a long time, \n   glad I finally had some time to work on it!\n\n   Towards the end of developing a shader, I'm always pleased\n   if I realize I've zoned out watching it run instead of \n   putting the finishing touches on it, which certainly was\n   the case here.\n\n   Since I couldn't get the glyph edges nicely antialiased, \n   I decided to leave the backgrounda  bit rough, too, which\n   you can see if you pause the shader. \n\n*/\n\n//#define PERSPECTIVE\n\nconst vec3 bgcolor = vec3(0, 0.1, 0.1);\nconst vec3 color_a = vec3(1.0, 0.4, 0);\nconst vec3 color_b = vec3(0.3, 0, 0.7);\nconst vec3 outline = vec3(1, 0, 0.2);\n\nfloat t = 0.0;\n\n// texture is 1024x1024\nconst float TEX_RES = 1024.;\n\n// texture is 16x16 glyphs\nconst float GLYPHS_PER_UV = 16.;\n\n// since the texture is uint8 it has a bias to represent 0\nconst float TEX_BIAS = 127./255.;\n\n// get font UV coords from screen coords\nvec2 font_from_screen(vec2 tpos, vec2 char_pos) {    \n    return (tpos + char_pos + 0.5)/GLYPHS_PER_UV;\n}\n\n\nfloat sample_dist_gaussian(vec2 uv) {\n\n    float dsum = 0.;\n    float wsum = 0.;\n    \n    const int nstep = 3;\n    \n    const float w[3] = float[3](1., 2., 1.);\n    \n    for (int i=0; i<nstep; ++i) {\n        for (int j=0; j<nstep; ++j) {\n            \n            vec2 delta = vec2(float(i-1), float(j-1))/TEX_RES;\n            \n            float dist = textureLod(iChannel0, uv-delta, 0.).w - TEX_BIAS;\n            float wij = w[i]*w[j];\n            \n            dsum += wij * dist;\n            wsum += wij;\n\n        }\n    }\n    \n    return dsum / wsum;\n}\n\n\n/* Rotate about x-axis */\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n\n/* Rotate about y-axis */\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n\nfloat approx_font_dist(vec2 p, int cidx) {\n\n    float d = max(abs(p.x) - 0.25,\n                  max(p.y - 0.3, -0.28 - p.y));\n    \n    vec2 cpos = vec2(float(cidx%16), float(15-cidx/16));\n    vec2 uv = font_from_screen(p, cpos);\n    \n    float fd = sample_dist_gaussian(uv); \n        \n    \n    d = max(d, fd);\n        \n    \n    return d;\n    \n}\n\nvec3 map(in vec3 pos) {\t\n\n    int ca = int(t) % 26;\n    int cb = (ca + 1) % 26;\n    int cc = (ca + 2) % 26;\n\n    float da = approx_font_dist(pos.xy, 65+ca);\n    float dc = approx_font_dist(pos.xy, 65+cc);\n    \n    float ft = fract(t);\n    \n    if (ft > 0.95) {\n        da = mix(min(da, dc), dc, smoothstep(0.95, 1.0, ft));\n    } else if (ft > 0.9) {\n        da = mix(da, min(da, dc), smoothstep(0.9, 0.95, ft));\n    }\n                   \n    float db = approx_font_dist(pos.zy, 65+cb);\n                   \n    \n    return vec3(max(da, db), da, db);\n   \n}\n\n/* IQ's distance marcher. */\nvec3 castRay( in vec3 ro, in vec3 rd) {\n    \n    const int rayiter = 80;\n    const float dmax = 8.;\n\n    const float precis = 0.001;   \n    float h=2.0*precis;\n\n    float t = 0.0;\n    vec2 m = vec2(-1.0);\n\n    for( int i=0; i<rayiter; i++ ) {\n\n        if( abs(h)<precis||t>dmax ) { continue; }\n        \n        t += min(0.25, h);\n        vec3 res = map( ro+rd*t );\n        h = res.x;\n        m = res.yz;\n        \n    }    \n\n    if (t > dmax) { return vec3(-1); }\n    if (abs(h) > 4.0*precis) { return vec3(-1); }\n\n    return vec3(t, m);\n\n}\n\nvec3 shade( in vec3 ro, in vec3 rd ,\n           inout vec3 c){\n\n    vec3 tm = castRay(ro, rd);        \n\n    if (tm.x >= 0.0) {\n\n        vec3 pos = ro + tm.x*rd;\n        \n        vec3 d = map(pos);\n        \n        \n        float flip = mod(t, 2.0) < 1.0 ? -1.0 : 1.0;\n        \n        vec3 fg = mix(color_a, color_b,\n                      step(flip*d.y, flip*d.z));\n                \n        c = mix(fg, outline, smoothstep(0.003, 0.0, abs(d.y-d.z)-0.008));\n\n    }\n\n    return c;\n\n}\n\nfloat scribble(vec2 p, float k) {\n    \n    float scl = k/iResolution.y;\n    \n    float kspiral = 0.2;\n    \n    vec2 c = p*scl;\n    vec2 c0 = floor(c+0.5);\n    \n    float d = 1e5;\n    \n    for (int i=-1; i<2; ++i) {\n        for (int j=-1; j<2; ++j) {\n            \n            vec2 cij = c0 + vec2(float(i), float(j));\n                       \n            vec4 r = textureLod(iChannel1, (cij+0.5)/256., 0.);\n            cij += 0.5*(r.xy - 0.5);\n            \n            vec2 diff = c - cij;\n            float sz = 0.3 + 0.3*(r.z - 0.5);\n            \n            float t = r.z *  10253.5721;\n            float c = cos(t), s = sin(t);\n            \n            diff = mat2(c, -s, s, c) * diff;\n\n            vec2 sq = abs(diff) - sz;\n            float dsqr = max(sq.x, sq.y);\n            \n            if (r.w < 0.5) {\n                \n                if (r.w < 0.25) {\n                    d = min(d, abs(dsqr));\n                } else {\n                    float dx = abs(dot(abs(diff), normalize(vec2(-1,1))));\n                    dx = max(dx, dsqr);\n                    d = min(d, dx);\n                }\n                \n            } else if (r.w < 0.75) {\n                \n                d = min(d, abs(length(diff) - sz));\n                                \n            } else {\n                \n                diff.x = abs(diff.x);\n                \n                float dtri = max(-diff.y, \n                                 dot(diff, vec2(0.8660254037844386, 0.5)));\n                \n                d = min(d, abs(dtri-0.85*sz));\n                \n            }\n\n        }\n    }\n    \n    return step(0., d-0.1);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) * 0.8 / (iResolution.y);\n\n    t = 0.45*max(0.0, iTime-2.0);\n    \n    float s = scribble(fragCoord + 0.45*iTime*vec2(75., 30), 7.);\n\n    vec3 bgdark = mix(bgcolor, vec3(0), 0.6);\n    vec3 bglite = mix(bgcolor, vec3(1), 0.25);\n    vec3 color = mix(bgcolor, bgdark, s);\n    \n    float rad = 0.05*iResolution.y;\n    float m = rad;\n    float x0 = m+rad;\n    \n    if (max(iMouse.x, iMouse.y) > x0) {        \n\n        float row = floor(4.0 - 4.0 * iMouse.y / iResolution.y);\n        float ux = clamp( (iMouse.x - x0) / (iResolution.x - 2.*x0), 0., 1.);\n        \n        if (mod(row, 2.0) != 0.0) { ux = 1.0 - ux; }\n        \n        t = 6.5 * (ux + row) + 1e-5;\n\n    }\n    \n    float u = fract(t);\n    u = smoothstep(0.1, 0.9, u);\n    \n    float midbump = smoothstep(0.5, 0.0, abs(u-0.5));\n\n    float thetay = -1.5707963267948966*u;\n    float thetax = 0.4*midbump;\n\n    mat3 Rview = rotY(thetay)*rotX(thetax); \n\n#ifdef PERSPECTIVE\n    const float f = 1.5;\n    vec3 rd = Rview*normalize(vec3(uv, f));\n    vec3 ro = Rview*vec3(0,0,-f);\n#else\n    vec3 rd = Rview*vec3(0, 0, 1);\n    vec3 ro = Rview*vec3(uv*0.9, -3.5);\n#endif\n    \n    if (max(iMouse.z, iMouse.w) > x0) {\n        \n        vec2 p = fragCoord - iResolution.xy*vec2(0.5, 0);\n        \n        float row = floor(4.0*fragCoord.y/iResolution.y);\n        float rowy = (row + 0.5)* iResolution.y * 0.25;\n         \n        float dx = sign(p.x);\n        float dy = mod(row, 2.0) > 0.0 ? -1.0 : 1.0;\n        dy *= dx;\n        \n        vec2 ctr = vec2(dx*(0.5*iResolution.x - x0),\n                        rowy + dy*rad);\n        \n        float dcirc = 1e5;\n        float dly = abs(p.y - rowy);\n        float dlx = abs(p.x) - (0.5*iResolution.x - m);\n        \n        if (p.x > 0.5 || (row != 0. && row != 3.)) { \n            vec2 dctr = p - ctr;\n            dcirc = abs(length(dctr) - rad);\n            dcirc = max(-dctr.x*dx, max(dctr.y*dy, dcirc));\n            dcirc = min(dcirc, max(dctr.y*-dy, abs(dctr.x-dx*rad)));\n            dlx = abs(p.x) - (0.5*iResolution.x - x0);\n        }\n        \n        float dpath = min(dcirc, max(dlx, dly)) - 2.0;\n        \n        color = mix(color, bglite, smoothstep(1., 0., dpath));\n    }\n    \n    shade(ro, rd, color);\n\n    color = pow(color, vec3(1.0/2.2));\n\n    fragColor = vec4(color, 1);\n\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVcDy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[977, 1018, 1067, 1067, 1123], [1126, 1126, 1163, 1163, 1680], [1683, 1709, 1732, 1732, 1853], [1856, 1882, 1905, 1905, 2026], [2029, 2029, 2071, 2071, 2374], [2376, 2376, 2399, 2399, 2930], [2932, 2961, 3000, 3000, 3500], [3502, 3502, 3564, 3564, 3983], [3985, 3985, 4018, 4018, 5603], [5605, 5605, 5662, 5662, 7987]], "test": "error"}
{"id": "XsVcWt", "name": "Septagram Loader", "author": "blackle", "description": "bep", "tags": ["shader"], "likes": 6, "viewed": 200, "published": "Public", "date": "1523763654", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//returns p's projection onto and distance to line segment p0:p1\nvec2 projectToSegment(vec2 p, vec2 p0, vec2 p1) {\n    vec2 v = p1 - p0;\n    vec2 w = p - p0;\n    \n    float b = dot(v,w)/dot(v,v);\n    float dist = distance(p, p0 + v * clamp(b, 0.0, 1.0));\n    return vec2(b, dist);\n}\n\n//returns ith star point coordinates\nvec2 pointFromIndex(float i) {\n    float ang = i/7.0*6.28;\n    return vec2(sin(ang), cos(ang));\n}\n\n//antialiases a distance value to an edge\nfloat aaEdge(float edge) {\n    float pixelSize = 2.0/iResolution.y*1.1;\n    return clamp(edge/pixelSize, 0.0, 1.0);\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    // if (k == 0.0) return min(a,b);\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sclamp(float x, float a, float b, float k) {\n    return smin(-smin(-x, -a, k), b, k);\n}\n\n\n//returns color+alpha for distance to a line segment\nvec2 colorForDistance(float dist, float projx) {\n    float thiccness = 0.035;\n    float border = 0.015;\n\n    float pixelSize = 2.0/iResolution.y*1.1;\n    \n    float col = aaEdge(thiccness - dist);\n    //shading\n    col *= mix(0.6,1.0,smin(pow(projx-1.00,2.0)*128.0,1.0,4.0));\n    col *= mix(0.6,1.0,smin(pow(projx-0.56,2.0)*512.0,1.0,4.0));\n    col *= mix(0.6,1.0,smin(pow(projx-0.35,2.0)*512.0,1.0,4.0));\n    \n    float alpha = aaEdge(thiccness + border - dist);\n\n    return vec2(col, alpha);\n}\n\n//mixes two colours with alpha blending\nvec2 compose(vec2 bottom, vec2 top) {\n    float outalpha = top.y + bottom.y * (1.0- top.y);\n    float outcol = (bottom.x*bottom.y*(1.0-top.y) + top.x*top.y)/outalpha;\n    return vec2(outalpha == 0.0 ? 0.0 : outcol, outalpha);\n}\n\nfloat septagram(vec2 uv, float time) {\n    \n    vec2 col = vec2(0.0);\n    for (float i = 0.0; i < 7.0; i++) {\n        vec2 p0 = pointFromIndex(i*3.0);\n        vec2 p1 = pointFromIndex(i*3.0+3.0);\n        vec2 proj = projectToSegment(uv, p0, p1);\n        \n        //this part does the cool loading fade\n        float fillCol = mix(0.1, 1.0, sclamp((time - proj.x - i)*16.0, 0.0, 1.0, 1.0));\n        if (time > 15.0) {\n            float fillCol2 = mix(0.1, 1.0, cos((time - proj.x - i)*6.283)*0.5+0.5);\n            fillCol = mix(fillCol, fillCol2, clamp(time-15.0, 0.0, 1.0));\n        }\n        vec2 lineCol = colorForDistance(proj.y, proj.x) * vec2(fillCol, 1.0);\n        //the first half of the line goes over everything, the second half goes under everything\n        if (proj.x > 0.4 && proj.x < 0.5) {\n            col = compose(col, lineCol);\n        } else if (proj.x > 0.5 && proj.x < 0.6) {\n            col = compose(lineCol, col);\n        } else if (proj.x > 0.6 && proj.x < 0.7) {\n            col = compose(col, lineCol);\n        } else if (proj.x < 0.1) {\n            col = compose(col, lineCol);\n        } else {\n            col = compose(lineCol, col);\n        }\n    }\n    \n    float capborder = length(uv) - 0.97 + (0.08 - cos(atan(uv.x,uv.y)*7.0*2.0)*0.08);\n    \n    vec2 caps = 1.0 - vec2(aaEdge(capborder*0.9 + 0.015), aaEdge(capborder*0.9));\n    col = vec2(min(caps.x, col.x), min(caps.y, col.y));\n    \n    //set iChannel0 to a texture to see alpha transparency\n    return compose(vec2(texture(iChannel0, uv*0.5).x,1.0), col).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 1.1;\n\n    float col = septagram(uv, iTime*0.5 - 0.5);\n\n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVcWt.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 259, 308, 308, 476], [478, 515, 545, 545, 612], [614, 656, 682, 682, 773], [776, 776, 817, 855, 948], [950, 950, 1000, 1000, 1043], [1046, 1099, 1147, 1147, 1594], [1596, 1636, 1673, 1673, 1863], [1865, 1865, 1903, 1903, 3410], [3412, 3412, 3469, 3520, 3737]], "test": "error"}
{"id": "XsVyRt", "name": "Capped cone", "author": "MrShoor", "description": "Small sample of capped cone ray intersection", "tags": ["raytrace"], "likes": 3, "viewed": 179, "published": "Public", "date": "1522953258", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool SolveSquare(float A, float B, float C, out vec2 x) {\n    float D = B*B - 4.0 * A * C;\n    if (D < 0.0) return false;\n    x.x = (-B - sqrt(D)) / (2.0 * A);\n    x.y = (-B + sqrt(D)) / (2.0 * A);\n    return true;\n}\n\nbool ConeIntersect(float ConeR, vec2 ConeCaps, vec3 ro, vec3 rd, out float t, out vec3 norm) {\n    float Al = ConeR * rd.z;\n    float Bl = ConeR * ro.z;\n    \n    float A = dot(rd.xy, rd.xy) - Al*Al;\n    float B = 2.0*(dot(rd.xy, ro.xy) - Al*Bl);\n    float C = dot(ro.xy, ro.xy) - Bl*Bl;\n    \n    vec2 tt;\n    if (!SolveSquare(A, B, C, tt)) return false;\n    vec2 zz = ro.zz + rd.zz*tt;\n    \n    int n = 2;\n    if ((zz.x < ConeCaps.x)||(zz.x > ConeCaps.y)) {\n        tt.x = tt.y;\n        n--;\n    }\n    if ((zz.y < ConeCaps.x)||(zz.y > ConeCaps.y)) {\n        tt.y = tt.x;\n        n--;\n    }\n    if (n==0) return false;\n    t = min(tt.x, tt.y);\n    \n    norm.xy = normalize(ro.xy + rd.xy*t);\n    norm.z = -ConeR * sign(ro.z + rd.z*t);\n    norm = normalize(norm);\n    \n    return true;\n}\n\nmat3 RotateTransform()\n{\n    mat3 res;\n    float t = iTime;\n    res[2] = normalize(vec3(cos(t), sin(t), cos(t)));\n    res[1] = vec3(cos(t), sin(t), 0.0);\n    res[0] = normalize(cross(res[1], res[2]));\n    res[1] = normalize(cross(res[2], res[0]));\n    return res;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 rd;\n    rd.xy = 2.0*fragCoord.xy/iResolution.xy - 1.0;\n    rd.x *= iResolution.x/iResolution.y;\n    rd.z = 1.0;\n    \n    vec3 ro = vec3(0.0,0.0,-10.0);\n    mat3 m = RotateTransform();\n    ro = ro * m;\n    rd = rd * m;\n    \n    rd = normalize(rd);\n       \n    vec4 Out;\n    vec3 crd, norm;\n    float t;\n    if (ConeIntersect(0.3, vec2(4.0, 8.0), ro, rd, t, norm)) {\n        float dk = abs(dot(norm,rd));\n        Out = vec4(dk, dk, dk, 1.0);\n    } else {\n        Out = vec4(0.0);\n    }\n    \n    fragColor = Out;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVyRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 216], [218, 218, 312, 312, 1002], [1004, 1004, 1028, 1028, 1274], [1276, 1276, 1333, 1333, 1857]], "test": "ok"}
{"id": "XsVyRV", "name": "Mistakes... burn!", "author": "raxter", "description": "Was an attempt to be a helix ray march.... it failed... added modulo, Ponk said add some flame.... fire happened", "tags": ["fire"], "likes": 0, "viewed": 94, "published": "Public", "date": "1522637161", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.141592;\nmat2 rot(float a) { a = PI/180.*a; float s = sin(a); float c = cos(a); return mat2(c,s,-s,c);}\n\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat cyl(vec3 p, vec3 c)\n{\n    return length(p.xz - c.xy) - c.z;\n}\n\nfloat box(vec3 p, vec3 b) // ??\n{\n    vec3 d = abs(p) - b;\n    return min(.0, max(max(d.x, d.y), d.z)) - length(max(d, .0));\n}\n    \n\nfloat sdf(vec3 p)\n{\n    //return sphere(p, 1.);\n\t//return box(p, vec3(1.,1.,1.));\n    vec3 o = p;\n    o = (p - vec3(0,0,7));\n \to = mod(o, vec3(10, 10,10));\n    //o.yz *= rot((p.y + iTime*4.)*30.);   \n    //o.xz *= rot((p.y + iTime*2.234)*20.);\n    o.xz *= rot((p.y - iTime*2.234)*20.);\n\n\treturn cyl(o - .0*vec3(mod(iTime,1.),0,0), vec3(1.,2.,2.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv *= 2.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    \n    vec3 dir = normalize(vec3(uv, 1.));\n    float d = .0;\n    vec3 eye = vec3(-4,-3,-10. + 0.*iTime);\n    \n    float maxDist = 200.;\n    int maxItt = 20;\n    for (int i = 0 ; i < maxItt ; i++)\n    {\n        float id = sdf(eye + dir * d);\n        \n        if (id < 0.001)\n        {\n            break;\n        }\n        \n        d += id;\n        \n        if (d > maxDist)\n        {\n            d = maxDist;\n        \tbreak;\n        }\n    }\n    \n    float f = d/maxDist;\n    f = 1.-pow(1.-mod(f+iTime/8., 1.),0.7);\n    vec3 c = mix(vec3(0.3, 0.4,0.6)/**pow((1.+sin(iTime/40.))/2.,0.1)*1.*/, vec3(0.2, 0.55, 0.07)/**(1.+sin((iTime+0.125)/6.))/2.*1.*/, (f-0.5)*1.5 + 0.5);\n    \n    float l = 0.72;\n    if (f > l)\n        fragColor = mix(vec4(1,0,0,1), vec4(1,1,0.,1), (f-l)*1./(1.-l));\n        //fragColor = vec4(0,0,0,1);\n//else if (f > 0.86)\n    //    fragColor = vec4(0,0,0,1);    \n    \n    else\n\t    fragColor = vec4(c,1);    \n    //fragColor = vec4(uv,f,1);\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVyRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 40, 40, 115], [118, 118, 149, 149, 177], [179, 179, 206, 206, 246], [248, 248, 281, 281, 374], [381, 381, 400, 462, 730], [732, 732, 789, 839, 2061]], "test": "ok"}
{"id": "XsVyzc", "name": "Spinning Square - Antialias", "author": "DonKarlssonSan", "description": "You must give a description to your shader", "tags": ["square", "smoothstep", "spin"], "likes": 1, "viewed": 463, "published": "Public API", "date": "1522793474", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rotate(a)  mat2(cos(a), -sin(a), sin(a), cos(a))\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    /*\n    vec2 uv = (fragCoord.xy -0.5 * iResolution.xy) / iResolution.x * rotate(iTime / 3.0);\n\n    float smoothness = 2.0 / iResolution.x;\n    float size = 0.18;\n    float left = smoothstep(-size, -size + smoothness, uv.x); \n    float bottom = smoothstep(-size, -size + smoothness, uv.y);\n    float top = smoothstep(1.0 - size - smoothness, 1.0 - size, 1.0 - uv.x);\n    float right = smoothstep(1.0 - size -smoothness, 1.0 - size, 1.0 - uv.y);   \n    \n    vec3 color = vec3(left * top * right * bottom);\n    \n    fragColor = vec4(color, 1.0);\n    */\n    \n    \n    float size = 0.18;\n    float smoothness = 2.0 / iResolution.x;\n    vec2 uv = (fragCoord.xy -0.5 * iResolution.xy) / iResolution.x * rotate(iTime / 3.0);\n\n    // Thanks to FabriceNeyret2 for this clever snippet!\n    uv = abs(uv);\n    float d = max(uv.x, uv.y);\n    fragColor = vec4(smoothstep(size, size - smoothness, d));\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVyzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 113, 666, 1005]], "test": "ok"}
{"id": "XsVyzd", "name": "Random Moon", "author": "GuntherRox", "description": "Bored, Moon, just learning and practicing ", "tags": ["bored"], "likes": 0, "viewed": 68, "published": "Public", "date": "1522980291", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RADIUS 0.02\n\nbool circle (vec2 uv, vec2 p, float radius)\n{\n    float dist = sqrt((uv.x - p.x)*(uv.x - p.x) + (uv.y - p.y)*(uv.y - p.y));\n    if(dist<radius)\n        return true;\n    \n    else return false;\n              \n}\n\nfloat dist_to_line(vec2 p1, vec2 p2, vec2 uv)\n{\n\tfloat a = abs(distance(p1, uv));\n\tfloat b = abs(distance(p2, uv));\n\tfloat c = abs(distance(p1, p2));\n\n\tfloat d = abs(sqrt(c*c + RADIUS*RADIUS));\n    \n\tif (a >= d || b >= d)\t{\n        float dist1 = distance(p1, uv);\n        float dist2 = distance(p2, uv);\n        return min(dist1,dist2);\n\t}\n\n\tfloat p = (a + b + c) * 0.6;\n\n\tfloat h = 2.0 / c * sqrt( p * ( p - a) * ( p - b) * ( p - c));\n    return h;\n}\n\nfloat falloff(float dist)\n{\n    if (dist*1.5 > RADIUS) {\n        return 0.0;\n    } else {\n        return 1.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n   //uv -= .5; \n   // uv += .06;\n   //  uv.x += -0.5;\n    \n    \n    //legs line\n    vec2 p1 = vec2(9.8,.61);\n    vec2 p2 = vec2(.8,.65);\n    float dist1 = dist_to_line(p1, p2, uv);        \n\tfloat i1 = falloff(dist1);\n\n\n    \n  // fragColor = vec4(0.0 * 0.5,0.0,1.0,1.0); \n    \n    \n  //MoonCover Up\n     vec2 Letter8C = vec2 (1.2, 0.72);\n // Moon CU Size\n\tfloat Letter81C  = 0.11 * (1.0);\n //Moon Color Design\n    bool isInLetter8C = circle (uv, Letter8C, Letter81C);\n    if (isInLetter8C) fragColor = vec4 (1.0,1.0,1.0,1.0);\n        \n //Moon top\n     vec2 Letter8 = vec2 (1.11, 0.74);\n // Moon Size\n\tfloat Letter81  = 0.1 * (1.0);\n //Moon Design\n    bool isInLetter8 = circle (uv, Letter8, Letter81);\n    if (isInLetter8) fragColor = vec4 (0.0,0.0,0.0,0.0);    \n    \n \n     //wave\n\t\tbool isWave = sin(iTime*2. + uv.x * 6.0 )+ 1.4> uv.y * 6.0;\n    \n    \tif(isWave) fragColor = vec4(0.,0.,1.,1.);\n\n\t//Yellow Ball \n       vec2 c2 = vec2(1.0,(sin(-iTime * 2. + 1.0) * .25 + .15));\n    \n    //Ball Size\n       float rBody = 0.10;\n     \n       bool isAdot = circle(uv, c2, rBody );\n    \n       if(isAdot == true)\n           fragColor = vec4(1.0,1.0,0.0,0.0);\n\t\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVyzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 66, 66, 230], [232, 232, 279, 279, 683], [685, 685, 712, 712, 801], [803, 803, 860, 860, 2108]], "test": "ok"}
{"id": "XsycDd", "name": "Triangle-Voronoi Graph Weave", "author": "Shane", "description": "Expanding on Tomkh's previous work by constructing a dual Voronoi graph from the Delaunay triangulation of random points.", "tags": ["voronoi", "triangle", "edge", "graph", "dual", "delaunay", "weave", "circumcenter"], "likes": 22, "viewed": 931, "published": "Public API", "date": "1524317037", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tTriangle-Voronoi Graph Weave\n\t----------------------------\n\n\tExpanding on Tomkh's previous work by constructing a dual Voronoi graph from the Delaunay \n\ttriangulation of random points. It's mainly a proof of concept, but in order to make it\n\tslightly more interesting, I went to the extra trouble to weave the graph components.\n\n\tThis turned out to be a trickier exercise than I expected. Obtaining the Voronoi information\n\trequired a little extra work -- due to the necessity to determine neighboring triangle \n\tinformation, but overall, it wasn't too bad. However, creating the weave required unique \n\tID's for neighboring edges, which required a whole bunch of point IDs, etc.\n\n\tI wouldn't call this a lot of code, but it's probably a little more than someone with better\n\tthings to do would like to decipher. I thought it would be novel to weave the dual graph, \n\tbut that complicated things and added a lot of extra code. The extra window dressing also \n\tadded to the line count. With that in mind, I'll put together a much more concise and easier \n\tto consume version pretty soon. In the meantime, it's still possible to use this in \n\tconjunction with Tomkh's or my previous example to get the general idea.\n\n\tThe logic for this seems to be sound, but was rushed, so it wouldn't surprise me if there are\n\tbetter ways to go about it. Having said that, the routine consists of just four checks, plus \n\ta bit of decision making and variable setting, so it should suffice.\n\n\tBy the way, I'm pretty sure that the Delaunay triangulation will break with too much of a \n\tpoint spread, so a pretty tight restriction has been set, which in turn, has resulted in boxy\n\tlooking cell sites. At some stage, I'll try to improve on that... or just wait for someone \n\tmore clever on Shadertoy to do it -- You'd be amazed at how often that strategy works. :D\n\t\n\n\tBased on:\n\n\t// I'd been wanting to see a geometric Delaunay triangulation example on Shadertoy for ages,\n\t// so Tomkh (Tomasz Dobrowolski) was kind enough to whip one up in virtually no time. In\n\t// addition to helping me out, I really like the way this is presented.\n\tRandom Delaunay Triangulation - Tomkh\n\thttps://www.shadertoy.com/view/4sKyRD\n\n\tAnother example:\n    \n\t// Really nice screensaver-like example. To my knowledge, Mattz was the first to put up a \n\t// quasi-randomized 2D triangle mesh. However, his particular example uses the same diagonal\n\t// orientation on each quadrilateral.\n\tice and fire - mattz\n\thttps://www.shadertoy.com/view/MdfBzl\n\n\n*/\n\n// Color palette. The default red and gold trim (0), a four-colored pastel palette (1), greyscale with\n// color (2), or just greyscale (3).\n#define PALETTE 0 \n//#define GREY_LINES // Grey triangle lines.\n\n// Fixed unanimated triangles, if you don't like the triangle popping effect. :)\n#define FIXED\n\n\n// A visual aid to show the physical square grid.\n//#define SHOW_GRID_CELLS\n\n\n// Greyscale.\nvec3 grey(vec3 col){ return vec3(1)*dot(col, vec3(.299, .587, .114)); }\n\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(11, 157)));\n    #ifdef FIXED\n    return (fract(vec2(262144, 32768)*n) - .5)*2.*.24;\n    #else\n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    // Note the \".35,\" insted of \".5\" that you'd expect to see. .\n    return sin(p*6.2831853 + iTime/2.)*.24;\n    #endif\n}\n\n\n// vec2 to vec2 hash.\nfloat hash21(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    return fract(sin(dot(p, vec2(113.927, 1.763)))*43758.5453);\n} \n\n\n// The triangle line pattern.\nfloat linePattern(vec2 p, vec2 a, vec2 b){\n  \n    // Determine the angle between the vertical 12 o'clock vector and the edge\n    // we wish to decorate (put lines on), then rotate \"p\" by that angle prior\n    // to decorating. Simple.\n    vec2 v1 = vec2(0, 1);\n    vec2 v2 = (b - a);\n\n    if(a.x>b.x) v2.y = -v2.y;\n\n    // Angle between vectors.\n    //float ang = acos(dot(v1, v2)/(length(v1)*length(v2))); // In general.\n    float ang = acos(v2.y/length(v2)); // Trimed down.\n    p = rot2(ang - .2)*p; // Putting the angle slightly past 90 degrees is optional.\n\n    float ln = clamp(cos(p.y*64.*2.)*1. - .5, 0., 1.);\n\n    return ln*.25 + clamp(sin(p.y*64.)*3. + 2.95, 0., 1.)*.75 + .15; // Ridges.\n \n}\n\n\n// Signed distance to the segment joining \"a\" and \"b.\" We need this one to determine\n// which side of the line a point is on.\n//\n// From Tomkh's original example. I trimmed it a bit, but for all I know, I might have\n// made is slower. :)\nfloat sDistLine(vec2 a, vec2 b) {\n       \n    b -= a; return dot(a, vec2(-b.y, b.x)/length(b)); //return dot(a, normalize(vec2(-b.y, b.x)));\n    \n}\n\n// Unsigned distance to the segment joining \"a\" and \"b.\"\nfloat distLine(vec2 a, vec2 b){\n    \n\tb = a - b;\n\tfloat h = clamp(dot(a, b) / dot(b, b), 0., 1.);\n    return length(a - b*h);\n}\n\n// From the the following example:\n// Random Delaunay Triangulation - Tomkh\n// https://www.shadertoy.com/view/4sKyRD\n//\n// Use \"parabolic lifting\" method to calculate if two triangles are about to flip.\n// This is actually more reliable than circumscribed circle method.\n// The technique is based on duality between Delaunay Triangulation\n// and Convex Hull, where DT is just a boundary of convex hull\n// of projected seeds onto paraboloid.\n// We project (h1 h2 h3) triangle onto paraboloid\n// and return the distance of the origin\n// to a plane crossing projected triangle.\nfloat flipDistance(vec2 h1, vec2 h2, vec2 h3)\n{\n   // Projects triangle on paraboloid.\n   vec3 g1 = vec3(h1, dot(h1, h1));\n   vec3 g2 = vec3(h2, dot(h2, h2));\n   vec3 g3 = vec3(h3, dot(h3, h3));\n   // Return signed distance of (g1, g2, g3) plane to the origin.\n   //#if FLIP_ANIMATION\n    // return dot(g1, normalize(cross(g3-g1, g2-g1)));\n   //#else\n     // If we don't do animation, we are only interested in a sign,\n     // so normalization is unnecessary.\n   \t return dot(g1, cross(g3-g1, g2-g1));\n   //#endif\n}\n\n\n// IQ's triangle hit routine.\nbool insideTri(vec2 p, vec2 a, vec2 b, vec2 c){\n    \n \t// Compute vectors        \n    vec2 v0 = c - a;\n    vec2 v1 = b - a;\n    vec2 v2 = p - a;\n\n    // Compute dot products\n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n\n    // Compute barycentric coordinates\n    float invDenom = 1./(dot00*dot11 - dot01*dot01);\n    float u = (dot11*dot02 - dot01*dot12)*invDenom;\n    float v = (dot00*dot12 - dot01*dot02)*invDenom;\n\n    // Check if point is in triangle\n    return (u>0. && v>0. && (u + v)<1.)? true : false;  \n    \n}\n\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n// IQ's point in a quadrilateral routine -- IQ's original is more sophisticated, but\n// I only needed to return a hit, so I hacked at it a bit. There are probably faster \n// routines, especially since the UV coordinates aren't required. However, I might use them\n// later, so I'll leave it as is for now. By the way, if someone has a fast \"point inside a\n// quad\" algorithm, I'd like to hear about it.\n//\n// Given a point p and a quad defined by four points {a,b,c,d}, return the bilinear\n// coordinates of p in the quad. Returns (-1,-1) if the point is outside of the quad.\nbool insideQuad(in vec2 a, in vec2 b, in vec2 c, in vec2 d){\n\n    vec2 res = vec2(-1.0);\n\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = -a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n\n    // otherwise, it's a quadratic\n    float w = k1*k1 - 4.0*k0*k2;\n    if( w<0.0 ) return false; //vec2(-1.0);\n    w = sqrt( w );\n\n\n    float ik2 = 0.5/k2;\n    float v = (-k1 - w)*ik2; if( v<0.0 || v>1.0 ) v = (-k1 + w)*ik2;\n    float u = (h.x - f.x*v)/(e.x + g.x*v);\n    if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return false;//vec2(-1.0);\n    //res = vec2( u, v );\n    \n    return true;\n}\n\n    \n// The center of a triangle's circumcircle. Also, the intersection of the perpendicular bisectors.\nvec2 circCent(vec2 a, vec2 b, vec2 c){\n    \n    float d = (a.x*(b.y - c.y) + b.x*(c.y - a.y) + c.x*(a.y - b.y))*2.;\n\n    vec2 a2 = a*a, b2 = b*b, c2 = c*c, u;\n    \n    u.x =  (a2.x + a2.y)*(b.y - c.y) + (b2.x + b2.y)*(c.y - a.y) + (c2.x + c2.y)*(a.y - b.y);\n    u.y =  (a2.x + a2.y)*(c.x - b.x) + (b2.x + b2.y)*(a.x - c.x) + (c2.x + c2.y)*(b.x - a.x);\n\n    return u/d;\n\n}\n\n/*\n// Circum radius -- A circle that encloses the triangle and passes through all vertices. \nfloat circumR(vec2 p0, vec2 p1, vec2 p2){\n\n    // Side lengths.\n    float a = length(p0 - p1), b = length(p1 - p2),  c = length(p2 - p0);\n    \n    float s = (a + b + c)/2.; // Semiperimeter.\n    float area = sqrt(s*(s - a)*(s - b)*(s - c)); // Area.\n    \n    return a*b*c/(4.*area);// Circumradius.\n}\n\n*/ \n\n// The triangle object. A lot of these variables were hacked in as they were needed, so it lacks\n// naming consistency, etc. I'll tidy this up later though.\nstruct triObj{\n    \n    vec2 p0, p1, p2; // The triangle vertices.\n    \n    vec2 id0, id1, id2; // The triangle vertice IDs.\n    \n    // l - Diagonal opposite, m - top or bottom neighbor, n - left or right neighbor.\n    vec2 l, l1, l2, m, m1, m2, n, n1, n2; // Three neighboring triangle vertices.\n    \n    vec2 lID[3], mID[3], nID[3]; // Three neighboring triangle vertices IDs.\n    \n    // Unique triangel ID. and one of four triangle cell IDs that identify the \n    // particular triangle's quadrilateral arrangement.\n    vec2 id, cID; \n    \n};\n    \n \n    \n\n// The triangle mesh routine: Iterate through the cell and it's neighbors until we hit a quadrilateral, \n// then determine which triangle information to return. By that I mean, triangle vertices and IDs, plus\n// the neighboring triangle vertices and IDs. It was exhausting to write out, but logically, not all that\n// complicated.\n//\n// I wrote this from scratch, but basically adapted the logic from Tomkh's Delaunay triangle mesh example.\n// It was surprisingly easy to write, but if it were not for his example, I wouldn't have known where to begin. :)\ntriObj triangulate(in vec2 p){\n    \n    // I'm declaring the vertices outside the loop, because it looks neater, but I hear it's faster to declare them\n    // as locally as possible.\n    vec2 o, o1, o2, o3, o4, o5;\n    vec2 id0, id1, id2, id3, id4, id5;\n\t\n    // Cell identifier and fractional position.\n    vec2 g = floor(p); p -= g + .5;\n \n    // Main triangle vertices, and its neighboring vertices. These particular variables are stored in the\n    // triangle object. The only reason they're declared here is to save writing \"tri..\"\n    vec2 h = vec2(1e8), h1 = vec2(1e8), h2 = vec2(1e8);\n    vec2 l = vec2(1e8), l1 = vec2(1e8), l2 = vec2(1e8);\n    vec2 m = vec2(1e8), m1 = vec2(1e8), m2 = vec2(1e8);\n    vec2 n = vec2(1e8), n1 = vec2(1e8), n2 = vec2(1e8);\n    \n    \n    \n    triObj tri; // The triangle object.\n    tri.cID = vec2(-1); // Not necessary, since we're guaranteed a hit, but it's a raytracing habit.\n    tri.id0 = tri.id1 = tri.id2 = vec2(1e8); // Main triangle vertice IDs.\n    \n/*    \n    // Precalculating the hash values so as not to recalculate too many in the main loop. Basically, I'm setting \n    // up an extra loop, an array, plus indexing, etc, in order to cut down from a possible 36 hash calculations \n    // to 16. Not to mention, making thing less readable... Therefore, it might be a case of diminishing returns. \n    // I'd like to hear what the experts have to say about this, because I'm on the fence as to whether I should\n    // be complicating things and wasting resources with this step. :)\n    //\n    vec2 aO[16];\n    for(int j=0; j<=3; j++){\n\t\tfor(int i=0; i<=3; i++){\n            \n            aO[j*4 + i] = vec2(i - 1, j - 1) + hash22(g + vec2(i - 1, j - 1)) - p;            \n        }\n    }\n\n*/\n    \n    \n    // Iterate through the cell and its neighbors until we hit a quadrilateral, then determine which\n    // triangle to return. I've allowed the grid vertices to randomly move further away from their original\n    // positions, which requires 9 cell checks, instead of just 4.\n    //\n    // By the way, once a triangle has been found, we break from the loop to avoid further redundant \n    // calculations. This means fewer than 9 checks are performed on average -- A rough guess would be an\n    // average of 5 checks per pass which I'd expect most GPUs can handle in their sleep.\n    //\n\tfor(int j=0; j<=1; j++){\n\t\tfor(int i=0; i<=1; i++){\n            \n \t\t\t// The four quadrilateral vertices for this particular cell. Clockwise arrangement.\n            // o -- o1\n            // |    |\n            // o3-- o2\n            id0 = vec2(i - 1, j);\n            id1 = vec2(i, j);\n            id2 = vec2(i, j - 1);\n            id3 = vec2(i - 1, j - 1);\n            o = id0 + hash22(g + id0) - p; // Origin -- Top left.\n            o1 = id1 + hash22(g + id1) - p; // Top right.\n            o2 = id2 + hash22(g + id2) - p; // Bottom right.\n            o3 = id3 + hash22(g + id3) - p; // Bottom left.\n            //o = aO[(j+1)*4 + i]; // Origin -- Top left.\n            //o1 = aO[(j+1)*4 + i + 1]; // Top right.\n            //o2 = aO[j*4 + i + 1]; // Bottom right.\n            //o3 = aO[j*4 + i]; // Bottom left.\n\n            // Quad and four neighboring arrangements.\n            //\n            //     4  5\n\n\t\t\t//\t4  0  1  4\n\n\t\t\t//  5  3  2  5\n\n\t\t\t//\t   4  5\n            \n    \n            // If the point resides in this particular cell's quad, determine which triangle it resides in, then \n            // determine it's neighboring triangles. Return all relevant vertex points, ID, etc.\n            if(insideQuad(o, o1, o2, o3)){\n                \n                // Applying the Delaunay rule to the quad: Basically, split the quad along an arbitrary diagonal to form\n                // a triangle. Circumscribe a circle around them, then determine whether the excluded fourth point lies \n                // within the circle. If it does, then flip the diagonal. There's a bit of math and theory behind it, but \n                // thankfully, Tomkh took care of that bit. :)\n                //\n                // By the way, there's no rule that says you need to do it this way -- You could restric the vertice\n                // movement more, then simply flip the diagonal on a random basis. However, the following tends to look \n                // better. Plus, if you wish to put together a Delaunay triangulation for various reasons -- like \n                // constructing the dual Voronoi representation -- this step is necessary.\n                float f = flipDistance(o - o2, o1 - o2, o3 - o2)<0.? 1. : -1.;\n                 \n                \n\t\t\t\tif(f>0.){ // Diagonal runs from the top right vertex to the bottom left vertex.\n                    \n                     // Determining which side of the diagonal quadrilateral line the point is on. In other words,\n                     // determine which of the two triangles that make up the quad the point is in.\n                     if(sDistLine(o1, o3)>0.){\n                         // o3, o, o1 triangle.\n                         tri.cID = vec2(0); // Red\n                         h = o3, h1 = o, h2 = o1;\n                         l = o1, l1 = o2, l2 = o3;\n                         \n                         // Top triangle.\n                         id4 = vec2(i - 1, j + 1);\n                         id5 = vec2(i, j + 1);\n                         o4 = id4 + hash22(g + id4) - p; \n            \t\t\t o5 = id5 + hash22(g + id5) - p; \n                         f = flipDistance(o4 - o1, o5 - o1, o - o1)<0.? 1. : -1.;\n                         if(f>0.){ m = o, m1 = o5, m2 = o1; tri.mID[0] = id0; tri.mID[1] = id5; tri.mID[2] = id1; }                         \n                         else { m = o, m1 = o4, m2 = o1; tri.mID[0] = id0; tri.mID[1] = id4; tri.mID[2] = id1; }\n                         \n                         // Left triangle.\n                         id4 = vec2(i - 2, j);\n                         id5 = vec2(i - 2, j);\n                         o4 = id4 + hash22(g + id4) - p; \n            \t\t\t o5 = id5 + hash22(g + id5) - p;\n                         f = flipDistance(o4 - o3, o - o3, o5 - o3)<0.? 1. : -1.;\n                         if(f>0.){ n = o3, n1 = o5, n2 = o; tri.nID[0] = id3; tri.nID[1] = id5; tri.nID[2] = id0; }\n                         else { n = o3, n1 = o4, n2 = o; tri.nID[0] = id3; tri.nID[1] = id4; tri.nID[2] = id0; }\n                         \n                         tri.id0 = id3; tri.id1 = id0; tri.id2 = id1; \n                         tri.lID[0] = id1; tri.lID[1] = id2; tri.lID[2] = id3;\n                         \n                         \n                    }\n                    else {\n                         // o1, o2, o3 triangle.\n                         tri.cID = vec2(1); // Blue.\n                        \n                         h = o1, h1 = o2, h2 = o3;\n                         l = o3, l1 = o, l2 = o1;                        \n                        \n                         // Bottom triangle.\n                         id4 = vec2(i - 1, j - 2);\n                         id5 = vec2(i, j - 2);\n                         o4 = id4 + hash22(g + id4) - p; \n            \t\t\t o5 = id5 + hash22(g + id5) - p;\n                         f = flipDistance(o3 - o5, o2 - o5, o4 - o5)<0.? 1. : -1.;\n                         if(f<0.){ m = o2, m1 = o5, m2 = o3; tri.mID[0] = id2; tri.mID[1] = id5; tri.mID[2] = id3; }\n                         else { m = o2, m1 = o4, m2 = o3; tri.mID[0] = id2; tri.mID[1] = id4; tri.mID[2] = id3; }\n                        \n                         // Right triangle.\n                         id4 = vec2(i + 1, j);\n                         id5 = vec2(i + 1, j - 1);\n                         o4 = id4 + hash22(g + id4) - p; \n            \t\t\t o5 = id5 + hash22(g + id5) - p;\n                         f = flipDistance(o1 - o5, o4 - o5, o2 - o5)<0.? 1. : -1.;\n                         if(f>0.){ n = o1, n1 = o4, n2 = o2; tri.nID[0] = id1; tri.nID[1] = id4; tri.nID[2] = id2; }\n                         else { n = o1, n1 = o5, n2 = o2; tri.nID[0] = id1; tri.nID[1] = id5; tri.nID[2] = id2; } \n                        \n                         tri.id0 = id1; tri.id1 = id2; tri.id2 = id3; \n                         tri.lID[0] = id3; tri.lID[1] = id0; tri.lID[2] = id1;\n                         \n                    }\n                    \n                }\n                else { // Diagonal runs from the top left vertex to the bottom right vertex.\n                   \n                    // If we have the flipped diagonal arrangement, determine which triangle the point is in.\n                    if(sDistLine(o, o2)>0.){\n                         //o1 = o2; o2 = o3; // o2, o3, o triangle.\n                         tri.cID = vec2(2); // Orange.\n                         h = o2, h1 = o3, h2 = o;\n                         l = o, l1 = o1, l2 = o2;\n                        \n                         // Bottom triangle.\n                         id4 = vec2(i - 1, j - 2);\n                         id5 = vec2(i, j - 2);\n                         o4 = id4 + hash22(g + id4) - p; \n            \t\t\t o5 = id5 + hash22(g + id5) - p;\n                         f = flipDistance(o3 - o5, o2 - o5, o4 - o5)<0.? 1. : -1.;\n                         if(f<0.){ m = o2, m1 = o5, m2 = o3; tri.mID[0] = id2; tri.mID[1] = id5; tri.mID[2] = id3; }\n                         else { m = o2, m1 = o4, m2 = o3; tri.mID[0] = id2; tri.mID[1] = id4; tri.mID[2] = id3; }\n                         \n                         // Left triangle.\n                         id4 = vec2(i - 2, j);\n                         id5 = vec2(i - 2, j - 1);\n                         o4 = id4 + hash22(g + id4) - p; \n            \t\t\t o5 = id5 + hash22(g + id5) - p;\n                         f = flipDistance(o4 - o3, o - o3, o5 - o3)<0.? 1. : -1.;\n                         if(f>0.){ n = o3, n1 = o5, n2 = o; tri.nID[0] = id3; tri.nID[1] = id5; tri.nID[2] = id0; }\n                         else { n = o3, n1 = o4, n2 = o; tri.nID[0] = id3; tri.nID[1] = id4; tri.nID[2] = id0; }\n                         \n                         tri.id0 = id2; tri.id1 = id3; tri.id2 = id0;\n                         tri.lID[0] = id0; tri.lID[1] = id1; tri.lID[2] = id2;\n                        \n                         \n                    }\n                    else {\n                        \n                        // o, o1, o2 triangle.\n                         tri.cID = vec2(3); // Green.\n                         h = o, h1 = o1, h2 = o2;\n                         l = o2, l1 = o3, l2 = o;\n                        \n                         // Top triangle.\n                         id4 = vec2(i - 1, j + 1);\n                         id5 = vec2(i, j + 1);\n                         o4 = id4 + hash22(g + id4) - p; \n            \t\t\t o5 = id5 + hash22(g + id5) - p;\n                         f = flipDistance(o4 - o1, o5 - o1, o - o1)<0.? 1. : -1.;\n                         if(f>0.){ m = o, m1 = o5, m2 = o1; tri.mID[0] = id0; tri.mID[1] = id5; tri.mID[2] = id1; }\n                         else { m = o, m1 = o4, m2 = o1; tri.mID[0] = id0; tri.mID[1] = id4; tri.mID[2] = id1; }\n                         \n                         // Right triangle.\n                         id4 = vec2(i + 1, j);\n                         id5 = vec2(i + 1, j - 1);\n                         o4 = id4 + hash22(g + id4) - p; \n            \t\t\t o5 = id5 + hash22(g + id5) - p;\n                         f = flipDistance(o1 - o5, o4 - o5, o2 - o5)<0.? 1. : -1.;\n                         if(f>0.){ n = o1, n1 = o4, n2 = o2; tri.nID[0] = id1; tri.nID[1] = id4; tri.nID[2] = id2; }\n                         else { n = o1, n1 = o5, n2 = o2; tri.nID[0] = id1; tri.nID[1] = id5; tri.nID[2] = id2; } \n                        \n                          \n                         tri.id0 = id0; tri.id1 = id1; tri.id2 = id2; \n                         tri.lID[0] = id2; tri.lID[1] = id3; tri.lID[2] = id0;\n                        \n                    }                  \n                }\n\n                \n                tri.p0 = h; tri.p1 = h1; tri.p2 = h2; // Triangle vertices.\n                tri.id = tri.cID + g + vec2(i - 1, j); // Triangle ID.\n                \n                tri.id0 += g; tri.id1 += g; tri.id2 += g; // Individual triangle vertex IDs.\n                \n                // Neighboring triangle vertices.\n                tri.l = l; tri.l1 = l1; tri.l2 = l2;\n                tri.m = m; tri.m1 = m1; tri.m2 = m2;\n                tri.n = n; tri.n1 = n1; tri.n2 = n2;\n                \n                // Neighboring triangle vertex IDs.\n                tri.lID[0] += g; tri.lID[1] += g; tri.lID[2] += g;\n                tri.mID[0] += g; tri.mID[1] += g; tri.mID[2] += g;\n                tri.nID[0] += g; tri.nID[1] += g; tri.nID[2] += g;\n\n\n                \n                // Once we've effectively hit a triangle, break to save further calculations.\n                break;\n                \n            }\n            \n                       \n\t\t}\n\t}\n    \n     \n    \n    // Return the triangle object -- Vertices, IDs, etc.\n    return tri;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // COORDINATES AND SETUP\n    //\n    // Screen coordinates. Note that I've put restrictions on the resolution. I coded this for\n    // the 800 by 450 canvas, so the image looks a little bloated in fullscreen. Therefore, I've\n    // attempted to counter that by restricting is to 800 pixels... It kind of works. :)\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5)/clamp(iResolution.y, 350., 800.);\n    \n    // Subtle convex screen bulge for a bit of visual variance and that slightly dizzying effect. :)\n    vec2 uv2 = uv*vec2(iResolution.y/iResolution.x, 1);\n    uv *= .95 + dot(uv2, uv2)*.1;\n    \n    \n    #ifdef FIXED\n    // Basic diagonal scrolling.\n    vec2 p = uv*5. - vec2(2, 1)*iTime/8.;\n    #else \n    // Moving everything down slightly to give the mild impression that the structure is\n    // slowly sliding down a wall... or something. I make this up as I go along. :)\n    vec2 p = uv*5. - vec2(0, -1)*iTime/8. - vec2(0, 1);\n    #endif\n    \n    \n\n    // DUEL TRIANGLE AND VORONOI PROCESSING\n    //\n    // Perform the triangulation: This function returns the triangle object struct, which consists of the\n    // three triangle vertices, the unique cell ID, and another triangle ID for coloring.\n    triObj tri = triangulate(p);\n    \n    \n    // Calculating the circumcenters of the central triangle and its neighbors. Connecting the central\n    // circumcenter to the neighboring ones produce the dual Voronoi edges. A few other connections need\n    // to made -- due to the grid nature of this example, but that's the gist of it.\n    vec2 cC = circCent(tri.p0, tri.p1, tri.p2);\n    vec2 cC0 = circCent(tri.l, tri.l1, tri.l2);\n    vec2 cC1 = circCent(tri.m, tri.m1, tri.m2);\n    vec2 cC2 = circCent(tri.n, tri.n1, tri.n2);\n   \n/*\n    // Distances from our pixel to the three edges. Since we're weaving lines, each have to be accounted\n    // for seperately.\n    float d0 = distLine(tri.p0, tri.p1); \n    float d1 = distLine(tri.p1, tri.p2);\t\n    float d2 = distLine(tri.p2, tri.p0);\n    \n        // Depending on quad arrangement (diagonal arrangement), \"d0\" and \"d1\" need to be swapped in order to\n    // match the correct edges... Like too many things, I found that out the hard way. :D\n    if(tri.cID.x<1.5){\n        \n        float temp = d0;\n        d0 = d1;\n        d1 = temp;\n        \n    }\n*/\n\n    // Distances from our pixel to the three edges. Since we're weaving lines, each have to be accounted\n    // for seperately. We're using the shared neighboring edge coordinates, since they're oriented \n    // correctly.\n    float d2 = distLine(tri.l, tri.l2); \n    float d1 = distLine(tri.n, tri.n2);\t\n    float d0 = distLine(tri.m, tri.m2);\n    \n\n    \n    // Triangle line identification. We need to identify which line we're rendering in order to randomly \n    // render it above or below the Voronoi lines.\n    float lineID = (d0<d1 && d0<d2)? 0. : d1<d2? 1. : 2.;\n    \n    // The triangle distance field value, for shading purposes.\n    float triDist = min(min(d0, d1), d2);\n    \n\n    // Cell color, based on the four triangle arrangements: Top-left, top-right, bottom-left and bottom-right.\n    vec3 cellCol;\n    \n    if(tri.cID.x == 3.) cellCol = vec3(1, 1.3, .6); // Green.\n    else if(tri.cID.x == 2.) cellCol = vec3(1.4, 1, .6); // Orangey brown.\n    else if(tri.cID.x == 1.) cellCol = vec3(.6, 1, 1.4); // Blue.\n    else cellCol = vec3(1.4, .7, .8); // Pinkish red.\n    \n    //if(hash21(tri.id)>.4) cellCol = grey(cellCol);\n    \n    #if PALETTE==0\n    // The less complicated default palette. For amateurs like myself, fewer colors are easier to work with. :)\n    if(hash21(tri.id)>.25) cellCol = grey(cellCol); // Greyscale.\n    else cellCol = mix(vec3(1.3, .2, .1), vec3(1.3, .5, .3), dot(sin(p*3. - cos(p.yx*3.)), vec2(.25)) + .5);\n    \n    /*\n    // Blinking color version.\n    float blink = smoothstep(.65, .75, sin(hash21(tri.id)*6.283 + iTime));\n    vec3 col1 = grey(cellCol); \n    vec3 col2 =  mix(vec3(1.3, .2, .1), vec3(1.3, .5, .3), dot(sin(p*3. - cos(p.yx*3.)), vec2(.25)) + .5);\n    cellCol = mix(col1, col2, blink);\n    */\n        \n    #elif PALETTE==2\n    if(tri.cID.x == 1. || tri.cID.x == 3.) cellCol = grey(cellCol);\n    #elif PALETTE==3\n    cellCol = grey(cellCol);\n    #endif\n    \n    // The triangle cell background.\n    // Mixing in a bit of the edge color with the cell color to give the impression that some mild lighting \n    // is occurring.\n    vec3 bg = mix(cellCol, vec3(1, .9, .7), .25);\n    // Mutliplying by a factor of the triangular distance for a bit of shading.\n    bg *= (triDist*.7 + .3)*1.55;\n    \n    // Start the layering process by initating to the triangle cell background.\n    vec3 col = bg;\n    \n        \n    // Cell background lines: Apologies for the compiler directive mess below. :) Basically, I wanted\n    // a triangle pattern in the colored triangles and diagonal hash lines in the greyscale ones.\n    #if PALETTE==1 || PALETTE==3\n    //float str = clamp(sin((rot2(tri.id.x)*p).x*6.283*20.)*1.5 + 1.35, 0., 1.); // Cell rotated lines.\n    #if PALETTE==1\n    float str = clamp(sin((triDist)*6.283*16.)*1.5 + 1.25, 0., 1.); // Triangle lines.\n    #else\n    float str = clamp(sin((p.y - p.x)*6.283*14.)*1.5 + 1.35, 0., 1.);\n    str = max(str, hash21(floor((p)*96.)) - .35);\n    #endif\n    col *= str*.35 + .65; // Diagonal lines.\n    #else\n    float str;\n    #if PALETTE==0\n    if(hash21(tri.id)<=.25)\n    #elif PALETTE==2\n    if(tri.cID.x == 0. || tri.cID.x == 2.)\n    #endif\n        str = clamp(sin((triDist)*6.283*16.)*1.5 + 1.25, 0., 1.); // Triangle lines.\n    else {\n        str = clamp(sin((p.y - p.x)*6.283*14.)*1.5 + 1.35, 0., 1.);\n        str = max(str, hash21(floor((p)*96.)) - .35);\n    }\n    col *= str*.35 + .65; // Diagonal lines.\n    #endif\n     \n  \n    \n \n////    \n    \n    // BOTTOM TRIANGLE LINES    \n \n    vec3 lCol = vec3(1, .8, .6); // Line color.\n    #ifdef GREY_LINES \n    lCol = grey(lCol);\n    #endif\n    \n    // Layering order flags to determine whether to render a particular triangle line under the Voronoi line,\n    // or over the top. It took me ages to come up with -- then convince myself -- of this logic: The line \n    // consists of two half edges; The actual triangle edge, and the same shared edge from the neighboring \n    // triangle. The sum of the two point IDs describing the shared edge will be the same for each side of the edge, \n    // which makes it a unique identifier... OK, I'm getting confused again... but it works anyway. :D\n    bool lineFirst[3];\n    lineFirst[2] = hash21(tri.lID[0] + tri.lID[2])>.5? true : false; // Diagonal rendering.\n    lineFirst[1] = hash21(tri.nID[0] + tri.nID[2])>.5? true : false; // Vertical (left\\right) rendering.\n    lineFirst[0] = hash21(tri.mID[0] + tri.mID[2])>.5? true : false; // Horizonal (top\\bottom) rendering.\n     \n    \n    \n    \n    vec2 p0 = vec2(0), p1 = vec2(0);\n    float d = 1e8;\n     \n    // Triangle line logic.\n    if(lineID == 2.) { // Diagonal edge line.\n        \n        // lCol =  lCol.zyx;  // Debug line color.        \n        if(lineFirst[2]){ d = d2; p0 = tri.p0; p1 = tri.p2; }\n        \n    }\n    else if(lineID == 1.){ // Vertical edge line.\n        \n        // lCol =  lCol.xzy;  // Debug line color.        \n        if(lineFirst[1]){ d = d1; p0 = tri.n; p1 = tri.n2; }\n \n    }\n    else { // Horizontal edge line.\n        \n        // lCol =  lCol.zxy;  // Debug line color.        \n        if(lineFirst[0]){ d = d0; p0 = tri.m; p1 = tri.m2; }\n        \n    }\n    \n    // Rendering the triangle lines.\n    const float lw = .03;\n    float lns = linePattern(p, p0, p1);\n    float shade = clamp(1. - d*4., 0., 1.)*.75 + clamp(d*32., 0., 1.)*.4;        \n    d -= lw;\n    col = mix(col, vec3(0), (1. - smoothstep(0., .1, d - .01))*.65);\n    col = mix(col, vec3(0), 1. - smoothstep(0., .015, d - .0225));\n    col = mix(col, lCol*lns*shade*.9, 1. - smoothstep(0., .015, d));\n    col = mix(col, vec3(0), (1. - smoothstep(0., .015, d + .025))*.5);\n     \n     \n    // VORONOI EDGES AND VERTICES\n    \n    float vorDist = 1e8;//tri.circ;// - length(cC - tri.p0);\n    \n    \n    // The lines connecting the circumcenter of the hit triangle to the circumcenters of the three \n    // neighboring triangles. These represent Voronoi edges. Normally, you'd need just these three, \n    // but sometimes a triangle's circumcenter will fall outside the triangle, meaning we have to\n    // render some extra lines. See below.\n    vorDist = min(vorDist, distLine(cC, cC0));\n    vorDist = min(vorDist, distLine(cC, cC1));\n    vorDist = min(vorDist, distLine(cC, cC2));\n\n    // Opposite bisecting sides of the diagonally opposite neighboring triangle... Don't worry. That confuses\n    // me as well, and I wrote it. :D Seriously, just comment out any of the pairs of lines below to see \n    // what they connect, and why they're necessary.\n    vorDist = min(vorDist, distLine(cC0, (tri.l + tri.l1)/2.));\n    vorDist = min(vorDist, distLine(cC0, (tri.l1 + tri.l2)/2.));\n    \n    // Opposite bisecting sides of the top or bottom neighboring triangle.\n    vorDist = min(vorDist, distLine(cC1, (tri.m + tri.m1)/2.));\n    vorDist = min(vorDist, distLine(cC1, (tri.m1 + tri.m2)/2.));\n    \n    // Opposite bisecting sides of the left or right neighboring triangle.\n    vorDist = min(vorDist, distLine(cC2, (tri.n + tri.n1)/2.));\n    vorDist = min(vorDist, distLine(cC2, (tri.n1 + tri.n2)/2.));\n        \n    \n    // Rendering the Voronoi lines.\n    vec3 vorCol = vec3(1, .9, .8);\n    // Dark strip shading.\n    float vShade = clamp(vorDist*40. - .5, 0., 1.);\n    // Alternate light strip shading.\n    //float vShade = clamp(1. - vorDist*8., 0., 1.)*.75 + clamp(.0 + vorDist*32., 0., 1.)*.5;//clamp(vorDist*32. + .5, 0., 1.);\n    vorDist -= .035;\n    col = mix(col, vec3(0), (1. - smoothstep(0., .1, vorDist - .01))*.65);\n    col = mix(col, vec3(0), 1. - smoothstep(0., .015, vorDist - .02));\n    col = mix(col, vorCol*vShade, 1. - smoothstep(0., .015, vorDist));\n    \n    \n    // Individual Voronoi edge vertices.    \n    float verts = 1e8;\n    const float vw = .06; \n    float vertcC = min(verts, length(cC)) - vw;\n    float vert0 = min(verts, length(cC0)) - vw;\n    float vert1 = min(verts, length(cC1)) - vw;\n    float vert2 = min(verts, length(cC2)) - vw;\n    \n \n    // Rendering the Voronoi edge end-point vertices.\n    vec3 vertCol = vec3(1, .96, .92);//vec3(.85, .92, 1)\n    float vertSh = min(min(vertcC, vert0), min(vert1, vert2));\n    col = mix(col, vec3(0), (1. - smoothstep(0., .1, vertSh - .01))*.75);\n     \n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, vert2 - .02));\n    col = mix(col, vertCol, 1. - smoothstep(0., .01, vert2));\n    vert2 += .05;\n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, vert2 - .02));\n\tcol = mix(col, vec3(1, .9, .7), 1. - smoothstep(0., .01, vert2));\n    \n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, vert1 - .02));\n    col = mix(col, vertCol, 1. - smoothstep(0., .01, vert1));\n    vert1 += .05;\n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, vert1 - .02));\n\tcol = mix(col, vec3(1, .9, .7), 1. - smoothstep(0., .01, vert1));\n    \n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, vert0 - .02));\n    col = mix(col, vertCol, 1. - smoothstep(0., .01, vert0));\n    vert0 += .05;\n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, vert0 - .02));\n\tcol = mix(col, vec3(1, .9, .7), 1. - smoothstep(0., .01, vert0));\n    \n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, vertcC - .02));\n    col = mix(col, vertCol, 1. - smoothstep(0., .01, vertcC));\n    vertcC += .05;\n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, vertcC - .02));\n\tcol = mix(col, vec3(1, .9, .7), 1. - smoothstep(0., .01, vertcC));\n    \n    \n    \n    \n   \n    \n    \n    \n    \n    // TOP TRIANGLE LINES     \n    \n    // Triangle line logic.\n    p0 = vec2(0), p1 = vec2(0);\n    d = 1e8;\n     \n    if(lineID == 2.) { // Diagonal edge line.\n        \n        // lCol =  lCol.zyx;  // Debug line color.        \n        if(!lineFirst[2]){ d = d2; p0 = tri.p0; p1 = tri.p2; }\n        \n    }\n    else if(lineID == 1.){ // Vertical edge line.\n        \n        // lCol =  lCol.xzy;  // Debug line color.        \n        if(!lineFirst[1]){ d = d1; p0 = tri.n; p1 = tri.n2; }\n \n    }\n    else { // Horizontal edge line.\n        \n        // lCol =  lCol.zxy;  // Debug line color.        \n        if(!lineFirst[0]){ d = d0; p0 = tri.m; p1 = tri.m2; }\n        \n    }\n    \n    // Rendering the triangle lines.\n    lns = linePattern(p, p0, p1);\n    shade = clamp(1. - d*4., 0., 1.)*.75 + clamp(d*32., 0., 1.)*.4;        \n    d -= lw;\n    col = mix(col, vec3(0), (1. - smoothstep(0., .1, d - .02))*.65);\n    col = mix(col, vec3(0), 1. - smoothstep(0., .015, d - .0225));\n    col = mix(col, lCol*lns*shade, 1. - smoothstep(0., .015, d));\n    col = mix(col, vec3(0), (1. - smoothstep(0., .015, d + .025))*.5);  \n    \n      \n    // Triangle vertices.\n    vertCol = vec3(1, .9, .75);//vec3(.85, .92, 1)\n    float tVerts = min(min(length(tri.p0), length(tri.p1)), length(tri.p2));\n    shade = 1.;//clamp(1.1 - tVerts*4., 0., 1.);\n    tVerts -= .09;\n    //verts = tri.verts - .04;\n    col = mix(col, vec3(0), (1. - smoothstep(0., .1, tVerts - .01))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, tVerts - .02));\n\tcol = mix(col, vertCol*shade, 1. - smoothstep(0., .01, tVerts));//vec3(1, .9, .7)\n    \n    tVerts += .06;\n    col = mix(col, vec3(0), 1. - smoothstep(0., .01, tVerts - .02));\n\tcol = mix(col, vec3(1, .8, .6)*.75, 1. - smoothstep(0., .01, tVerts)); \n    \n    tVerts += .02;\n\tcol = mix(col, vec3(0), (1. - smoothstep(0., .01, tVerts))*.7); \n    \n\n  \n    // SQUARE GRID\n    //\n    // Square grid -- for a visual guide.\n    #ifdef SHOW_GRID_CELLS\n    // Cell borders: If you take a look at the triangles overlapping any individual square cell, \n    // you'll see that several partial triangles contribute, and the vertices that make up each \n    // triangle span the 8 surrounding cells. This is the reason why you have to test for\n    // contributing triangle intersections from all 9 cells.\n    vec2 q = abs(fract(p) - .5);\n    float bord = max(q.x, q.y) - .5;\n    bord = max(bord, -(bord + .008));\n    \n    col = mix(col, vec3(0), (1. - smoothstep(0., .1, bord - .01))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., .01, bord - .015)));\n    col = mix(col, vec3(.8, .9, 1), (1. - smoothstep(0., .01, bord))*1.);\n    #endif     \n    \n    \n    // POSTPROCESSING AND SCREEN PRESENTATION \n     \n    // Vignette.\n    uv = fragCoord/iResolution.xy;\n    col = mix(col*1.05, vec3(0), (1. - pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.125)));\n\n    \n    // Rough gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsycDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2898, 2912, 2932, 2932, 2983], [2986, 3138, 3159, 3159, 3225], [3228, 3250, 3271, 3620, 3923], [3926, 3948, 3970, 4319, 4385], [4389, 4419, 4461, 4652, 5120], [5123, 5361, 5394, 5394, 5508], [5510, 5567, 5598, 5598, 5694], [5696, 6271, 6318, 6357, 6786], [6789, 6819, 6866, 6900, 7446], [7449, 7449, 7488, 7488, 7516], [7518, 8093, 8153, 8153, 8770], [8777, 8876, 8914, 8914, 9247], [10367, 10923, 10953, 11105, 23932]], "test": "error"}
{"id": "XsycWy", "name": "The obligatory pathtracer", "author": "dpiponi", "description": "Fixed bug.", "tags": ["pathtracing"], "likes": 7, "viewed": 188, "published": "Public", "date": "1523064395", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 cube[6] = vec4[6](\n    vec4(0.0, 0.0, -1.0, -1.0),      // -z-1 < 0 i.e. z > -1\n    vec4(0.0, 0.0, 1.0, -1.0),       // \n    vec4(-1.0, 0.0, 0.0, -1.0),      // \n    vec4(1.0, 0.0, 0.0, -1.0),\n    vec4(0.0, -1.0, 0.0, -1.0),\n    vec4(0.0, 1.0, 0.0, -1.0));     // \n\nfloat rand(inout float seed) {\n    seed = seed+0.63;\n    float s = 1000.0*(seed+cos(17.0*seed-22.1*seed*seed));\n    seed = 11.37*seed+1.2;\n    seed = seed-floor(seed);\n    return s-floor(s);\n}\n\nfloat pi = 3.1415926;\n\nvec3 pointOrthoToPlane(inout float seed, vec3 n) {\n    float z = -1.0+2.0*rand(seed);\n    float rxy = sqrt(1.0 - z*z);\n    float phi = 2.0*pi*rand(seed);\n    float x = rxy * cos(phi);\n    float y = rxy * sin(phi);\n    vec3 d = vec3(x, y, z);\n    return dot(n, d) < 0.0 ? -d : d;\n}\n\nmat4 rotateX(float theta) {\n    float s = sin(theta);\n    float c = cos(theta);\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, c, s, 0.0,\n                0.0, -s, c, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 invRotateX(float theta) {\n    return rotateX(-theta);\n}\n\nmat4 rotateY(float theta) {\n    float s = sin(theta);\n    float c = cos(theta);\n    return mat4(c, 0.0, -s, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                s, 0.0, c, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 invRotateY(float theta) {\n    return rotateY(-theta);\n}\n\nmat4 translate(vec3 p) {\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                p.x, p.y, p.z, 1.0);\n}\n\n\nmat4 invTranslate(vec3 p) {\n    return translate(-p);\n}\n\nmat4 scale(float s) {\n    return mat4(s, 0.0, 0.0, 0.0,\n                0.0, s, 0.0, 0.0,\n                0.0, 0.0, s, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 invScale(float s) {\n    return scale(1.0/s);\n}\n\nbool intersectConvex(out float near, out vec3 normal, vec4 cube[6], vec3 p, vec3 d) {\n    near = -1000.0;\n    float far = 1000.0;\n    for (int i = 0; i < 6; ++i) {\n        vec4 n = cube[i];\n        float np = dot(n, vec4(p, 1.0)); // 4\n        float nd = dot(n, vec4(d, 0.0)); // -1\n        if (nd == 0.0) {\n            // Parallel\n            if (np > 0.0) {\n                // All outside\n                return false;\n            }\n        } else {\n            // Find t at intersection\n            float t = -np/nd; // -p.z/d.z\n            if (nd < 0.0) {\n                // Entering\n                if (t > near) {\n                    normal = n.xyz;\n                    near = t;\n                }\n            } else {\n                // Exiting\n                far = min(far, t);\n            }\n        }\n    }\n    if (near > 0.0 && near < far) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nbool intersectScene(out float near, out vec3 normal, vec4 cube[6], vec3 p, vec3 d) {\n    bool did = false;\n    near = 1e8;\n\n    mat4 m = translate(vec3(0.6, 0.4, 0.0));\n    mat4 im = invTranslate(vec3(0.6, 0.4, 0.0));\n    m = m*rotateX(0.2*iTime);\n    im = invRotateX(0.2*iTime)*im;\n    m = m*rotateY(0.25*iTime);\n    im = invRotateY(0.25*iTime)*im;\n    m = m*scale(0.5);\n    im = invScale(0.5)*im;\n    vec3 new_p = (im*vec4(p, 1.0)).xyz;\n    vec3 new_d = (im*vec4(d, 0.0)).xyz;\n    float new_near;\n    vec3 new_normal;\n    if (intersectConvex(new_near, new_normal, cube, new_p, new_d)) {\n        did = true;\n        if (new_near < near) {\n            normal = (m*vec4(new_normal, 0.0)).xyz;\n            near = new_near;\n        }\n    }\n\n    m = translate(vec3(0.6, -0.4, 0.0));\n    im = invTranslate(vec3(0.6, -0.4, 0.0));\n    m = m*rotateY(0.35*iTime);\n    im = invRotateY(0.35*iTime)*im;\n    m = m*rotateX(0.3*iTime);\n    im = invRotateX(0.3*iTime)*im;\n    m = m*scale(0.5);\n    im = invScale(0.5)*im;\n    new_p = (im*vec4(p, 1.0)).xyz;\n    new_d = (im*vec4(d, 0.0)).xyz;\n    if (intersectConvex(new_near, new_normal, cube, new_p, new_d)) {\n        did = true;\n        if (new_near < near) {\n            normal = (m*vec4(new_normal, 0.0)).xyz;\n            near = new_near;\n        }\n    }\n\n    m = translate(vec3(-0.6, 0.4, 0.0));\n    im = invTranslate(vec3(-0.6, 0.4, 0.0));\n    m = m*rotateY(0.2*iTime);\n    im = invRotateY(0.2*iTime)*im;\n    m = m*scale(0.5);\n    im = invScale(0.5)*im;\n    new_p = (im*vec4(p, 1.0)).xyz;\n    new_d = (im*vec4(d, 0.0)).xyz;\n    if (intersectConvex(new_near, new_normal, cube, new_p, new_d)) {\n        did = true;\n        if (new_near < near) {\n            normal = (m*vec4(new_normal, 0.0)).xyz;\n            near = new_near;\n        }\n    }\n\n    m = translate(vec3(-0.6, -0.4, 0.0));\n    im = invTranslate(vec3(-0.6, -0.4, 0.0));\n    m = m*rotateY(0.5*iTime);\n    im = invRotateY(0.5*iTime)*im;\n    m = m*rotateX(0.6*iTime);\n    im = invRotateX(0.6*iTime)*im;\n    m = m*scale(0.5);\n    im = invScale(0.5)*im;\n    new_p = (im*vec4(p, 1.0)).xyz;\n    new_d = (im*vec4(d, 0.0)).xyz;\n    if (intersectConvex(new_near, new_normal, cube, new_p, new_d)) {\n        did = true;\n        if (new_near < near) {\n            normal = (m*vec4(new_normal, 0.0)).xyz;\n            near = new_near;\n        }\n    }\n\n    return did;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy-0.5*iResolution.xy;\n    uv = 2.0*uv/iResolution.y;\n\n    vec3 p = vec3(0.0, 0.0, -3.0);\n    vec3 d = vec3(0.5*uv, 1.0);\n    float seed = uv.x+uv.y;\n    seed = rand(seed)+uv.y-uv.x;\n    seed = rand(seed)+iTime;\n    seed = rand(seed);\n\n    vec3 normal;\n    float near;\n    if (intersectScene(near, normal, cube, p, d)) {\n        p = p+near*d;\n        vec3 color = vec3(0.0, 0.0, 0.0);\n        float gain = 1.0/float(64);\n        for (int i = 0; i < 64; ++i) {\n            vec3 secondary = pointOrthoToPlane(seed, normal);\n            vec3 new_p = p+0.00001*secondary;\n            vec3 ignore;\n            float ignore2;\n            bool did = intersectScene(ignore2, ignore, cube, new_p, secondary);\n            if (did) {\n                color += vec3(0.0, 0.0, 0.0);\n            } else {\n                color += vec3(0.8, 0.8, 0.8);\n            }\n        }\n        fragColor = vec4(gain*color, 1.0);\n    } else {\n        fragColor = vec4(0, 0, 0, 1.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsycWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[271, 271, 301, 301, 463], [488, 488, 538, 538, 768], [770, 770, 797, 797, 989], [991, 991, 1021, 1021, 1051], [1053, 1053, 1080, 1080, 1272], [1274, 1274, 1304, 1304, 1334], [1336, 1336, 1360, 1360, 1507], [1510, 1510, 1537, 1537, 1565], [1567, 1567, 1588, 1588, 1729], [1731, 1731, 1755, 1755, 1782], [1784, 1784, 1869, 1869, 2700], [2702, 2702, 2786, 2786, 5055], [5057, 5057, 5112, 5112, 6100]], "test": "ok"}
{"id": "Xsycz3", "name": "Sphere Cube Morphing", "author": "nawafuji", "description": "morphing sphere and cub", "tags": ["practice"], "likes": 1, "viewed": 111, "published": "Public", "date": "1522722896", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Sebastien Durand - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define U(a,b) (a.x*b.y-b.x*a.y)\n\nconst float PI = 3.14159265359;\nconst float ONE_OVER_PI = 1.0/PI;\n\n// rolled brass\n/*\nconst vec2 lo = vec2(0.100, 0.330);\nconst vec2 alpha= vec2(0.050, 0.160);\nconst vec3 Scale = vec3(1.0, 1.0, 1.0);\nvec3 surfaceColor = vec3(1.0,0.62,0.31);\n*/\n\n// semi-gloss paint, rolled\n\nconst vec2 lo = vec2(0.450, 0.048);\nconst vec2 alpha = vec2(0.045, 0.068);\nconst vec3 Scale = vec3(1.0, 20.0, 10.0);\nvec3 surfaceColor = vec3(0.45,0.54,1.0);\n\n\n// lightly brushed aluminum\n/*\nconst vec2 lo = vec2(0.150, 0.190);\nconst vec2 alpha = vec2(0.088, 0.130);\nconst vec3 Scale = vec3(2.0, 2.0, 2.0);\nvec3 surfaceColor = vec3(1.0,0.99,1.0);\n*/\n\n// white ceramic tile\n/*\nconst vec2 lo = vec2(0.700, 0.050);\nconst vec2 alpha = vec2(0.071, 0.071);\nconst vec3 Scale = vec3(1.0, 10.0, 10.0);\nvec3 surfaceColor = vec3(1.0,1.0,1.0);\n*/\n\nvec2 A[15];\nvec2 T1[5];\nvec2 T2[5];\n\nconst vec3 L = normalize(vec3(1,.72, 1)), Y = vec3(0,1,0), E = Y*.01;\n\nfloat tMorph;\nmat2 mat2Rot;\n\n// Distance to Bezier\n// inspired by [iq:https://www.shadertoy.com/view/ldj3Wh]\n// calculate distance to 2D bezier curve on xy but without forgeting the z component of p\n// total distance is corrected using pytagore just before return\nvec2 B(vec2 m, vec2 n, vec2 o, vec3 p) {\n\tvec2 q = p.xy;\n\tm-= q; n-= q; o-= q;\n\tfloat x = U(m, o), y = 2. * U(n, m), z = 2. * U(o, n);\n\tvec2 i = o - m, j = o - n, k = n - m, \n\t\t s = 2. * (x * i + y * j + z * k), \n\t\t r = m + (y * z - x * x) * vec2(s.y, -s.x) / dot(s, s);\n\tfloat t = clamp((U(r, i) + 2. * U(k, r)) / (x + x + y + z), 0.,1.); // parametric position on curve\n\tr = m + t * (k + k + t * (j - k)); // distance on 2D xy space\n\treturn vec2(sqrt(dot(r, r) + p.z * p.z), t); // distance on 3D space\n}\n\n            \n\nfloat smin(float a, float b, float k){\n    float h = clamp(.5+.5*(b-a)/k, 0., 1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\n\n//#define METHOD_2\n\nvoid basis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n#if defined(METHOD_2)\n  // method 2a variant\n  float sz = n.z >= 0.0 ? 1.0 : -1.0;\n  float a  =  n.y/(1.0+abs(n.z));\n  float b  =  n.y*a;\n  float c  = -n.x*a;\n    \n  xp = vec3(n.z+sz*b, sz*c, -n.x);\n  yp = vec3(c, 1.0-b, -sz*n.y);\n#else\n    \n  // method 1: ignoring n approaching -z\n#if 1\n  float a =  n.y/(1.0+n.z);\n  float b =  n.y*a;\n  float c = -n.x*a;\n    \n  xp = vec3(n.z+b, c, -n.x);\n  yp = vec3(c, 1.0-b, -n.y);\n    \n#else\n    \n  // nimitz's impl of frisvad\n  float a = 1./(1. + n.z);\n  float b = -n.x*n.y*a;\n  xp = vec3(1. - n.x*n.x*a, b, -n.x);\n  yp = vec3(b, 1. - n.y*n.y*a , -n.y);\n#endif\n#endif\n}\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l, vec3 e, vec3 h, vec3 surfaceColor, vec3 lightColor){\n \n    vec3 lightVector = l;\n    vec3 eyeVector = e;\n    vec3 halfVector = h;\n    \n    float nDotLV = max(0.0, dot(lightVector, n));\n    float nDotHV = max(0.0, dot(halfVector, n));\n  \n    float attenuation = 1.0;\n    float shininess = 10.0;\n    float pf;\n    if(nDotLV == 0.0)\n        pf = 0.0;\n \telse\n        pf = pow(nDotHV, shininess);\n    \n    vec3 ambient = vec3(0.1) * attenuation;\n    vec3 diffuse = vec3(1.0,1.0,1.0) * nDotLV * attenuation;\n    vec3 specular = vec3(1.0,1.0,1.0) * pf * attenuation*1.0;\n    return min(((ambient + diffuse)*surfaceColor + specular * vec3(1.0)) * lightColor, vec3(1.0));\n}\n\nvec3 computeBRDF(vec3 n, vec3 l, vec3 h, vec3 r, vec3 t, vec3 b, vec2 p, vec2 a, vec3 s, vec3 color){\n    \n    float e1, e2, E, cosThetaI, cosThetaR, brdf, intensity;\n    \n    e1 = dot(h,t)/a.x;\n    e2 = dot(h,b)/a.y;\n    E = -2.0*((e1*e1+e2*e2)/(1.0+dot(h,n)));\n    \n    cosThetaI = dot(n,l);\n    cosThetaR = dot(n,r);\n    \n    brdf = p.x * ONE_OVER_PI + p.y * (1.0 / sqrt(cosThetaI * cosThetaR)) * ( 1.0 / (4.0 * PI * a.x * a.y)) * exp(E);\n    \n    intensity = s[0] * p.x * ONE_OVER_PI + s[1] * p.y * cosThetaI * brdf + s[2] * dot(h,n) * p.y;\n    return intensity * color;\n}   \n\nfloat cube(vec3 p){\n    float s = 1.0;\n    vec3 d = abs(p) - vec3(s);\n    return min(max(d.x, max(d.y,d.z)), 0.0)\n        + length(max(d,0.0));\n}\n\nfloat sphere(vec3 p){\n    return length(vec3(0.0) - p) - 1.0;\n}\n\nfloat teapot(vec3 p){\n    \n// Distance to Teapot --------------------------------------------------- \n\t// precalcul first part of teapot spout\n\tvec2 h = B(T1[2],T1[3],T1[4], p);\n\tfloat a = 99., \n    // distance to teapot handle (-.06 => make the thickness) \n\t\tb = min(min(B(T2[0],T2[1],T2[2], p).x, B(T2[2],T2[3],T2[4], p).x) - .06, \n    // max p.y-.9 => cut the end of the spout \n                max(p.y - .9,\n    // distance to second part of teapot spout (abs(dist,r1)-dr) => enable to make the spout hole \n                    min(abs(B(T1[0],T1[1],T1[2], p).x - .07) - .01, \n    // distance to first part of teapot spout (tickness incrase with pos on curve) \n                        h.x * (1. - .75 * h.y) - .08)));\n\t\n    // distance to teapot body => use rotation symetry to simplify calculation to a distance to 2D bezier curve\n    vec3 qq= vec3(sqrt(dot(p,p)-p.y*p.y), p.y, 0);\n    // the substraction of .015 enable to generate a small thickness arround bezier to help convergance\n    // the .8 factor help convergance  \n\tfor(int i=0;i<13;i+=2) \n\t\ta = min(a, (B(A[i], A[i + 1], A[i + 2], qq).x - .015) * .7); \n    // smooth minimum to improve quality at junction of handle and spout to the body\n\tfloat dTeapot = smin(a,b,.02);\n    return dTeapot;\n}\n\n// Distance to scene\nfloat M(vec3 p) {\n\n    //float dTeapot = teapot(p);\n    float dSphere = sphere(p);\n    \n    float dCube = cube(p);\n\t// !!! The morphing is here !!!\n    return mix(dCube, dSphere, abs(sin(iTime)));\n}\n\n// HSV to RGB conversion \n// [iq: https://www.shadertoy.com/view/MsS3Wc]\nvec3 hsv2rgb_smooth(float x, float y, float z) {\n    vec3 rgb = clamp( abs(mod(x*6.+vec3(0.,4.,2.),6.)-3.)-1., 0., 1.);\n\trgb = rgb*rgb*(3.-2.*rgb); // cubic smoothing\t\n\treturn z * mix( vec3(1), rgb, y);\n}\n\nvec3 normal(in vec3 p, in vec3 ray, in float t) {\n\tfloat pitch = .4 * t / iResolution.x;\n\t\n    vec2 d = vec2(-1,1) * pitch;\n    \n\tvec3 p0 = p+d.xxx; // tetrahedral offsets\n\tvec3 p1 = p+d.xyy;\n\tvec3 p2 = p+d.yxy;\n\tvec3 p3 = p+d.yyx;\n\t\n\tfloat f0 = M(p0);\n\tfloat f1 = M(p1);\n\tfloat f2 = M(p2);\n\tfloat f3 = M(p3);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - p*(f0+f1+f2+f3);\n\t//return normalize(grad);\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat aa=3.14159/4.;\n\tmat2Rot = mat2(cos(aa),sin(aa),-sin(aa),cos(aa));\n\t\n\t// Teapot body profil (8 quadratic curves) \n\tA[0]=vec2(0,0);A[1]=vec2(.64,0);A[2]=vec2(.64,.03);A[3]=vec2(.8,.12);A[4]=vec2(.8,.3);A[5]=vec2(.8,.48);A[6]=vec2(.64,.9);A[7]=vec2(.6,.93);\n    A[8]=vec2(.56,.9);A[9]=vec2(.56,.96);A[10]=vec2(.12,1.02);A[11]=vec2(0,1.05);A[12]=vec2(.16,1.14);A[13]=vec2(.2,1.2);A[14]=vec2(0,1.2);\n\t// Teapot spout (2 quadratic curves)\n\tT1[0]=vec2(1.16, .96);T1[1]=vec2(1.04, .9);T1[2]=vec2(1,.72);T1[3]=vec2(.92, .48);T1[4]=vec2(.72, .42);\n\t// Teapot handle (2 quadratic curves)\n\tT2[0]=vec2(-.6, .78);T2[1]=vec2(-1.16, .84);T2[2]=vec2(-1.16,.63);T2[3]=vec2(-1.2, .42);;T2[4]=vec2(-.72, .24);\n\n\t// Configure camera\n\tvec2 r = iResolution.xy, m = iMouse.xy / r,\n\t     q = fragCoord.xy/r.xy, p =q+q-1.;\n\tp.x *= r.x/r.y;\n\tfloat j=.0, s=1., h = .1, t=5.+.2*iTime + 4.*m.x;\n\tvec3 o = 2.9*vec3(cos(t), .7- m.y,sin(t)),\n\t     w = normalize(Y * .4 - o), u = normalize(cross(w, Y)), v = cross(u, w),\n         d = normalize(p.x * u + p.y * v + w+w), n, x;\n\t\t\t\n\t// Ray marching\n\tt=0.;\n    for(int i=0;i<48;i++) { \n\t\tif (h<.0001 || t>4.7) break;\n        t += h = M(o + d*t);\n    }\n    \n\t// Background colour change as teapot complementaries colours (using HSV)\n\tvec3 c = mix(hsv2rgb_smooth( .5+iTime*.02,.35,.4), \n\t\t\t \t hsv2rgb_smooth(-.5+iTime*.02,.35,.7), q.y);\n\t\t\n    // Calculate color on point\n\tif (h < .001) {\n\t\tx = o + t * d;\n\t\tn = normal(x,d,t);//normalize(vec3(M(x+E.yxx)-M(x-E.yxx),M(x+E)-M(x-E),M(x+E.xxy)-M(x-E.xxy)));\n\n        vec3 N = n;\n        vec3 V = normalize(o-x);\n        vec3 H = normalize(L+V);\n        vec3 R = normalize(reflect(-L, N));\n        \n        vec3 T;\n        vec3 B;\n        \n        basis(N,T,B);\n       // vec3 T = normalize(vec3(-N.y, N.x, 0));\n        //vec3 B = normalize(cross(N,T));\n        \n            \n        //vec3 pixelColor = computeLambert(x, N, L, V, H, vec3(0,0.0,1.0), vec3(1.0));\n\t\tvec3 pixelColor = computeBRDF(N,L,H,R,T,B,lo,alpha,Scale,surfaceColor);\n        \n\t\t// Calculate Shadows\n\t\tfor(int i=0;i<20;i++){\n\t\t\tj += .02;\n\t\t\ts = min(s, M(x+L*j)/j);\n\t\t}\n\t\t// Teapot color rotation in HSV color space\n\t\tvec3 c1 = hsv2rgb_smooth(.9+iTime*.02, 1.,1.); \n\t\t// Shading\n\t    c = pixelColor;\n        //mix(c,mix(sqrt((clamp(3.*s,0.,1.)+.3)*c1),\n\t\t//\t          vec3(pow(max(dot(reflect(L,n),d),0.),99.)),.4),2.*dot(n,-d));\n\t} \n\n\tc *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .16); // Vigneting\n\tfragColor=vec4(c,1);\t\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xsycz3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1106, 1341, 1381, 1381, 1847], [1863, 1863, 1901, 1901, 1981], [2004, 2004, 2053, 2053, 2663], [2665, 2665, 2761, 2761, 3373], [3375, 3375, 3476, 3476, 3951], [3956, 3956, 3975, 3975, 4101], [4103, 4103, 4124, 4124, 4166], [4168, 4168, 4189, 4310, 5424], [5426, 5447, 5464, 5498, 5645], [5647, 5720, 5768, 5768, 5924], [5926, 5926, 5975, 5975, 6451], [6454, 6454, 6511, 6511, 8964]], "test": "error"}
{"id": "XsyczV", "name": "LatticeWithFolding", "author": "EvilRyu", "description": "Simple effect", "tags": ["tunnel", "grid", "folding", "lattice"], "likes": 36, "viewed": 939, "published": "Public API", "date": "1522601057", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Continue playing with folding lattice, code is not interesting.\n\n#define PI 3.14159265\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k,0.,1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\nfloat bump(vec3 p, vec3 n)\n{\n    return dot(texcube(iChannel0, 0.2*p, n).xyz, vec3(0.299, 0.587, 0.114)); \n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e = vec2(2./iResolution.y, 0); \n    vec3 g=vec3(bump(p-e.xyy, n)-bump(p+e.xyy, n),\n                bump(p-e.yxy, n)-bump(p+e.yxy, n),\n                bump(p-e.yyx, n)-bump(p+e.yyx, n))/(e.x*2.);  \n    g=(g-n*dot(g,n));\n    return normalize(n+g*weight);\n}\n\nvec3 path(float p)\n{\n    return vec3(sin(p*0.05)*cos(p*0.05)*18., 0.,0.);\n}\n\n// folding from gaz: https://www.shadertoy.com/view/4tX3DS\nvec2 fold(vec2 p, float a)\n{\n    p.x=abs(p.x);\n    vec2 n = vec2(cos(a),sin(a));\n    for(int i = 0; i < 3; ++i)\n    {\n        p -= 2.*min(0.,dot(p,n))*n;\n        n = normalize(n-vec2(1.,0.));\n    }\n    return p;\n}\n\nmat2 rot(float t)\n{\n    float c=cos(t);\n    float s=sin(t);\n    return mat2(c,-s,s,c);\n}\n\nfloat infi_box(vec3 p, vec2 b)\n{\n    vec2 d = abs(p.xy) - b;\n    return min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n}\n\nint mateid=0;\n\nfloat map(vec3 p)\n{\n    p-=path(p.z);\n    vec3 q=p;\n    p=vec3(rot(0.05*p.z)*p.xy, p.z);\n    p.xy=fold(p.xy,PI/3.);\n    p=mod(p,2.)-1.;\n\n    // variation of BCC lattice from paniq: https://www.shadertoy.com/view/llfGRj\n    vec3 o = abs(p); \n    o-=(o.x+o.y+o.z)*0.33333;\n    float d0=max(o.x,max(o.y,o.z))-0.03;\n    float d1=length(q.xy)-1.;\n    d0=max(d0,-d1);\n    \n    mateid=0;\n    \n    float d2=infi_box(q+vec3(0.,1.2,0.),vec2(1.5,0.1+0.06*texture(iChannel1,0.1*q.xz).x));\n  \tfloat d3=d1-4.;\n    if(d2<d0) mateid=1;\n    \n    d0=smin(d0,d2,0.5);\n    \n    if(-d3<d0) mateid=2;\n    \n    // warped by a tunnel\n    d0=smin(d0,-d3,0.5);\n    \n    return d0;\n}\n\nvec3 get_normal(vec3 p)\n{ \n    vec3 e=vec3(0.001,0.0,0.0); \n    return normalize(vec3(map(p+e.xyy)-map(p-e.xyy), \n                          map(p+e.yxy)-map(p-e.yxy), \n                          map(p+e.yyx)-map(p-e.yyx))); \n} \n\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float t=0.01;\n    float d=map(ro+t*rd);\n    for(int i=0;i<128;++i)\n    {\n        if(abs(d)<0.002||t>100.)\n            continue;\n        t+=d;\n        d=map(ro+t*rd);\n    }\n    if(t>100.)t=-1.;\n    return t;\n}\n\nvec3 hash3(float n)\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n// curvature from iq: https://www.shadertoy.com/view/MsXGzM\nfloat curvature(vec3 p, vec3 n)\n{\n    float acc=0.0;\n    for(int i=0;i<4;i++)\n    {\n        vec3 aopos=normalize(hash3(float(i)*213.47));\n        aopos=aopos-dot(n,aopos)*n;\n        aopos=p+aopos*0.07;\n        float dd=clamp(map(aopos)*100.0, 0.0, 1.0 );\n        acc+=dd;\n    }\n    return smoothstep(0.2, 1.0, acc/4.0);\n}\n\nfloat shadow(vec3 ro, vec3 rd, float dist)\n{\n    float res=1.0;\n    float t=0.05;\n    float h;\n    \n    for(int i=0;i<12;i++)\n    {\n        // break still breaks on my windows.\n        if(t>dist) continue;\n        h=map(ro+rd*t);\n        res = min(6.0*h/t, res);\n        t+=h;\n    }\n    return max(res, 0.0);\n}\n\nvec3 light_source(vec3 spot_light, vec3 dir, float dis)\n{\n    float g = 0.0;\n    if (length(spot_light) < dis)\n    {\n\t\tg = pow(max(dot(normalize(spot_light), dir), 0.0), 600.0);\n    }\n    return vec3(1.6,1.2,1.) * g;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q=fragCoord.xy/iResolution.xy;\n    vec2 p=q*2.-1.;\n    p.x*=iResolution.x/iResolution.y;\n\n    vec3 ro=vec3(0.,0.,-iTime);\n    vec3 ta=ro+vec3(0,0,-1.);\n    \n    vec3 lp0=ro+vec3(0,0.2,-3);\n    \n    ro+=path(ro.z);\n    ta+=path(ta.z);\n    lp0+=path(lp0.z-1.*(.5+.5*sin(iTime)));\n    \n    vec3 f=normalize(ta-ro);\n    vec3 r=normalize(cross(f,vec3(0,1,0)));\n    vec3 u=normalize(cross(r,f));\n    \n    vec3 rd=normalize(mat3(r,u,f)*vec3(p.xy,1.717));\n    vec3 col=vec3(0.6,0.8,1.1);\n\n    float t=intersect(ro,rd);\n    if(t>-0.5)\n    {\n        vec3 pos=ro+t*rd;\n        vec3 n=get_normal(pos);\n        \n        vec3 mate=texcube(iChannel0, pos, n).xyz*vec3(0.5,0.7,1.);\n        float cur = curvature(pos, n);\n        \n        mate += cur*vec3(1.);\n        vec3 tex=texture(iChannel1,pos.xz).xyz;\n        if(mateid==1)\n        {\n            mate=.5*vec3(.6*tex.x,.8*tex.x,1.*tex.x);\n            n=bump_mapping(pos, n, 0.2/(1.+t*0.4));\n        }\n        else if(mateid==2)\n        {\n            mate=2.*vec3(0.5,.6, .6);\n            n=bump_mapping(pos, n, 0.2/(1.+t*0.4));\n        }\n        \n        if(mateid!=1)\n       \tmate=mix(mate,mate*tex,smoothstep(2.5,-1.,pos.y));\n        \n        vec3 ld0=lp0-pos;\n        float ldist=length(ld0);\n        ld0/=ldist;\n        vec3 lc0=2.*vec3(1.2,0.8,0.5);\n        \n        float sha=shadow(pos+0.01*n, ld0, ldist);\n        float dif=max(0.,dot(n,ld0))*sha;\n        float bac=max(0.,dot(n,-ld0));\n        float amb=max(0.,dot(n,vec3(0,1,0)))*max(0.,(pos.y+1.));\n        float spe=max(0.0, pow(clamp(dot(ld0, reflect(rd, n)), 0.0, 1.0), 32.0));\n        \n        vec3 Lo=10.*dif*lc0/(1.5*ldist);\n        Lo+=2.*amb*vec3(0.5,0.8,1.0);    \n        Lo+=0.5*bac*lc0;\n        Lo+=2.*spe*vec3(1.);\n        \n        Lo*=clamp(pos.y+1.8,0.0,1.);\n        \n        col=mate*Lo*0.2;\n    }\n    col=mix(col, 0.5*vec3(0.6,0.8,1.1), 1.0-exp(-0.005*t*t) );\n    col += light_source(lp0-ro, rd, 10.);\n    \n    col=pow(clamp(col,0.0,1.0),vec3(0.45));    \n    col=pow(col,vec3(0.95,.95,0.9));\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1);\n    fragColor.xyz=col;\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsyczV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[200, 200, 239, 239, 319], [321, 321, 366, 366, 512], [514, 514, 542, 542, 622], [624, 624, 673, 673, 937], [939, 939, 959, 959, 1014], [1016, 1075, 1103, 1103, 1288], [1290, 1290, 1309, 1309, 1378], [1380, 1380, 1412, 1412, 1499], [1516, 1516, 1535, 1535, 2172], [2174, 2174, 2199, 2199, 2399], [2402, 2402, 2437, 2437, 2650], [2652, 2652, 2673, 2673, 2767], [2769, 2829, 2862, 2862, 3150], [3152, 3152, 3196, 3196, 3462], [3464, 3464, 3521, 3521, 3682], [3684, 3684, 3741, 3741, 5836]], "test": "error"}
{"id": "XsyyzK", "name": "Sea", "author": "manoloide", "description": "the feeling of walking along the coast", "tags": ["noise", "ray", "wave", "sea", "texture", "water", "light", "sine", "sand", "swimming", "moment", "sum"], "likes": 9, "viewed": 629, "published": "Public API", "date": "1522537675", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//created by manoloide 2018\n//@manoloidee\n\n\n#define TAU 6.28318530718\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    float tt = iTime*0.11;\n    float dt = mod(-tt, 0.5);\n    \n    vec2 st = fragCoord/iResolution.xy;\n    st -= 0.5;\n    float asp = iResolution.x/iResolution.y;\n    st.x *= asp;\n    \n    vec3 color = mix(vec3(0.965,0.837,0.692), vec3(0.795,0.577,0.270), rand(st+iTime*0.0000000001));\n    color *= 0.95+min(1.0, pow(rand(iTime*0.00001+st*10.0+20.0), 200.0)*20.0);\n    color *= 0.5+color*(1.1+cos(iTime*.1)*0.1);\n    \n    float mov = pow(cos(tt*TAU), 1.0);\n    float m1 = st.y+cos(+cos(st.x*3.0+iTime*0.4)+cos(st.x*2.0+iTime*.013))*0.2+1.0;\n    float sw = smoothstep(0.4, 0.1, m1-1.0-mov*0.02)*0.8;\n    float lm = smoothstep(0.5, 0.1, m1-mov*1.1);\n    float wave = pow(lm*1.2, 2.4)+pow(lm*1.2, 1.4)*0.001;\n    float wo2 = 120.0;\n    float light = wave*cos((((st.y+wave*0.1+m1)+lm*0.1)+cos(iTime)*0.2-mov+iTime*0.01)*400.0+cos((st.x)*wo2))*(cos(((st.y+wave*0.0001+m1)-mov*2.0)*20.0)*1.0);\n    \n    color = mix(color*(1.-sw*0.1), vec3(0.0), sw*pow(dt, 0.8));\n    color = mix(color, vec3(1.000,0.714,0.832), wave*1.0);\n    color = mix(color, vec3(0.109,0.910,0.893), min(wave, 0.98));\n    float li = light*pow(1.-st.y*0.02, 0.02)*0.5+pow(light, 5.0)*0.05;\n    color = mix(color, vec3(1.0), li-(0.5-st.y)*0.5);\n    \n    float dd = distance(st, vec2(0.0))/asp;\n    color = mix(color, vec3(0.0), pow(dd, 2.2));\n    color += color*(0.24+cos(iTime*0.2)*0.1);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsyyzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 91, 91, 163], [165, 165, 222, 314, 1725]], "test": "ok"}
