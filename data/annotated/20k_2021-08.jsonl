{"id": "7d3GD8", "name": "inner torus in colors", "author": "FabriceNeyret2", "description": ".", "tags": ["torus", "short"], "likes": 9, "viewed": 225, "date": "1629663876", "time_retrieved": "2024-06-20T20:46:24.434153", "image_code": "\n#define r(a)    mat2( cos(a+vec4(0,11,33,0)) )                // rotation                  \n#define hue(v) ( .6 + .6 * cos( v  + vec4(0,23,21,0)  ) )     // hue\n\nvoid mainImage(out vec4 O, vec2 U) {    \n    vec3  R = iResolution,     // 3.*R.y for normal field of view\n          D = normalize(vec3( U+U, -R.y ) - R ),              // ray direction\n          p = 30./R, q,                                       // marching point along ray \n          M = cos(iTime+vec3(0,11,0)) / vec3(1,2,.5);         // camera animation\n    float t=9.,d;\n     \n    for ( O += 1.1-O ; O.x > 0. && t > .01 ; O-=.01 ) //  O.x>0. just for security\n        q = p, \n        q.yz *= r( .5+M.y ),                                  // rotations\n        q.xz *= r(    M.x ),          // R0=20        R1=17\n        t = abs( length(vec2(d=length(q.xz)-20., q.y)) - 17.),// abs for inside + outside\n        p += .9*t*D;                                          // step forward = dist to obj\n\n    U  = 2.* atan( q.zy, vec2(q.x,d) );                       // strip texture  \n    O *= ( .5 + .5* sin(9.*(U.x+=U.y)) )  * hue(U.x);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7d3GD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[163, 163, 199, 199, 1099]]}
{"id": "7d3GRX", "name": "Geometric Thingy", "author": "Flopine", "description": "I have creativity but not for shader names XD still, here is a thingy :D ", "tags": ["3d", "raymarching", "animation", "isometric"], "likes": 14, "viewed": 181, "date": "1630318185", "time_retrieved": "2024-06-20T20:46:25.046248", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings and FabriceNeyret for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define rep(p,c) p=(mod(p-c*.5,c)-c*.5)\n#define hash11(x) fract(sin(x)*242.4)\n\n#define frt(sp,off) fract((iTime+off)*sp)\n#define flt(sp,off) floor((iTime+off)*sp)\n\nstruct obj\n{\n    float d;\n    vec3 sha;\n    vec3 li;\n};\n\nobj minobj (obj a, obj b)\n{if(a.d<b.d)return a; else return b;}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat sc (vec3 p, float d)\n{\n    p=abs(p);\n    p=max(p,p.yzx);\n    return min(p.x,min(p.y,p.z))-d;\n}\n\nfloat idx,speed;\nobj stairs (vec3 p)\n{\n    p.y += .6;\n    float perx = 2.;\n    idx=floor((p.x-perx*.5)/perx);\n    speed = .5+hash11(idx)*2.;\n    p.z -= flt(speed,0.)+pow(frt(speed,0.),5.)*.5+.1;\n    rep(p.x,perx);\n\n    float perz = .5;\n    float idz = floor((p.z-perz*.5)/perz);\n\n    rep(p.z,perz);\n    float d = box(p,vec3(.4,2.,.2));\n\n    return obj(d,vec3(0.,0.1,0.3),vec3(0.3,0.99,0.5));\n}\n\nobj cubes (vec3 p)\n{\n    float id = floor((p.x-1.)/2.);\n    float anim = (PI/2.)*(flt(speed,0.)+pow(frt(speed,0.),3.));\n    rep(p.x,2.);\n    rep(p.z,3.);\n    p.y -= 1.7;\n    p.yz *= rot(-anim);\n    float d = max(-sc(p,.13),box(p, vec3(.2)));\n    d = hash11(id)<.5?min(d, box(p,vec3(.12))):d;\n    return obj(d, vec3(0.5,.0,.1), vec3(.99,.45,.8));\n}\n\nobj SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.); \n\n    p.y += asin(sin(idx*1.4))*.4;\n\n    obj scene = stairs(p);\n    scene = minobj(scene,cubes(p));\n\n    return scene;\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p).d-vec3(SDF(p-eps.xyy).d,SDF(p-eps.yxy).d,SDF(p-eps.yyx).d));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(uv*4.,-30.), rd=vec3(0.,0.,1.), p=ro,\n    col=vec3(0.),l=normalize(vec3(1.,2.,-2.));\n    obj O;\n    \n    for (float i=0.;i<64.;i++)\n    {\n        O = SDF(p);\n        if (O.d<0.001) break;\n        p += O.d*rd*.5;\n    }\n\n    vec3 n = getnorm(p);\n    float light = max(dot(n,l),0.);\n    col = mix(O.sha, O.li, light);\n    \n    fragColor = vec4(sqrt(col),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7d3GRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[208, 654, 681, 681, 717], [719, 719, 747, 747, 832], [834, 834, 862, 862, 934], [953, 953, 974, 974, 1329], [1331, 1331, 1351, 1351, 1678], [1680, 1680, 1698, 1698, 1880], [1882, 1882, 1905, 1905, 2026], [2028, 2028, 2085, 2085, 2529]]}
{"id": "7d3GW8", "name": "Shard Laundry", "author": "104", "description": "sunday afternoon shader fun", "tags": ["simple"], "likes": 22, "viewed": 234, "date": "1629656522", "time_retrieved": "2024-06-20T20:46:25.416007", "image_code": "const float SceneDurationSeconds = 3.;\nconst float Complexity = 10.;\nconst float ResolutionDivisor = 1.;\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nmat2 rot2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat bayer8x8(vec2 uvScreenSpace) {\n  return texture(iChannel0, uvScreenSpace / (ResolutionDivisor * 8.)).r;\n}\n\n\nvoid mainImage(out vec4 o, vec2 C) {\n  vec2 uv = C / iResolution.xx;\n  //uv += iMouse.xy/iResolution.xy*.1 - .5;\n  uv += 100.; // seed @ 0 is just black because of rng\n  float q = 1.;\n  vec4 h;\n  float sh = 1.0;\n\n  float scene = floor((iTime + 100.) / SceneDurationSeconds);\n  vec4 hscene = hash42(uv - uv + scene);\n  uv.x += scene;\n  float escape = 1. - hscene.x * .12;\n  float Speed = hscene.z * .01;\n\n  for (float i = 0.0; i < Complexity; ++i) {\n    vec2 cell = floor(uv / q) * q;\n    vec2 sq = abs(fract(uv / q));\n    sh *= 1. - pow(max(sq.y, max(max(1. - sq.y, sq.x), 1. - sq.x)), 3.5);\n    h = hash42(cell);\n    if (i > 3. && h.w > escape)\n      break;\n    uv.x += iTime * sin(h.z * 6.28) * Speed * (i + 1.);\n    uv *= rot2D(h.w * 6.28 * hscene.z);\n    uv *= 1.2 +\n          hscene.y *\n              h.y; // scale; there's a small chance of under layer being bigger.\n  }\n  o = h * pow(sh, .25);\n  //o = pow(o, vec4(.6));\n  vec2 uvn = C / iResolution.xy - .5;\n  float v = 1. - dot(uvn, uvn * 1.6);\n  o *= Complexity / 12.; // it's just really dark otherwise\n\n  vec4 rotated = o;\n  rotated.xy *= rot2D(iTime * .4);\n  rotated.yz *= rot2D(iTime * .4 * .618);\n  rotated = abs(rotated);\n  rotated = clamp(rotated, 0., 1.);\n  o = mix(o, rotated, .3);\n  o = abs(o);\n  o = clamp(o, 0., 1.);\n  o = mix(o, o - o + (max(o.x, max(o.y, o.z))), .4);\n\n  o += (bayer8x8(C) - .5) * .15;\n  o = step(o - o + .12, o);\n  o *= v;\n}\n", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7d3GW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[106, 106, 127, 127, 275], [277, 277, 297, 297, 349], [351, 351, 387, 387, 462], [465, 465, 501, 501, 1879]]}
{"id": "7dc3D8", "name": "Return from space", "author": "Tater", "description": "Inspired by @byt3_m3chanic's experiments with log polar mapping. I still have some more ideas I might try with it. ", "tags": ["3d", "raymarching", "space", "logpolar"], "likes": 14, "viewed": 221, "date": "1629750658", "time_retrieved": "2024-06-20T20:46:26.319145", "image_code": "#define STEPS 200.0\n#define MDIST 150.0\n#define pi 3.1415926535\n#define pmod(p,x) (mod(p,x)-0.5*(x))\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\n\nvec3 glow;\n\nvec2 pmodp(vec2 p, float x){\n    float a = atan(p.y,p.x);\n    a = mod(a-x/2.,x)-x/2.;\n    return vec2 (cos(a),sin(a))*length(p);\n}\nfloat vSeg(vec3 p, float h, float r){\n  p.y -= clamp(p.y, 0.0, h);\n  return length(p)-r;\n}\n\nvec2 map(vec3 p){\n    vec2 a = vec2(1);\n    vec2 b = vec2(2);\n    vec3 po = p;\n    float t= mod(iTime,999.);\n    p.xz*=rot(t*0.2);\n\n    //Log-polar mapping from\n    //https://www.osar.fr/notes/logspherical/\n    vec2 p2 = p.xz;\n    float r = length(p2);\n    p2 = vec2(log(r),atan(p2.y,p2.x));  \n    float scl = 12.0/pi;\n    \n    t*=0.65;\n    p2.x+=t;\n    float yoff = 20.5;\n\n    //p.y+=t*scl*(2.0/3.0)*yoff;\n    \n    p2 *= scl;\n    \n    vec2 id = vec2(floor((p2.x)/1.5)+0.5,floor(p2.y/1.5)+0.5);\n    \n    p2 = pmod(p2,1.5);\n\n    p.y-=sin(id.y+t)*0.75;\n    p.y-=sin(id.x+t*2.5)*0.75;\n    \n    float dSpd = 10.0;\n    float uSpd = 15.0;\n    \n    //apply up/down warp-in motion\n    float ring =smoothstep(6.0,9.0,id.x-t*scl*(2.0/3.0))*yoff*dSpd*floor(mod(id.x,2.0));\n          ring -= smoothstep(6.0,9.0,id.x-t*scl*(2.0/3.0))*yoff*uSpd*floor(mod(id.x+1.0,2.0));\n    p.y -= ring;\n    \n    float mul = r/(scl);\n    \n    vec3 p3 = vec3(p2.x, p.y/mul,p2.y);\n     \n    //======BEGIN NON-DOMAIN WARPED SDF======  \n    \n    //Boxes\n    a.x = box(p3,vec3(0.6,0.6+0.15,0.6));\n    a.x = max(a.x,-box(p3,vec3(3.0,0.3,0.3)));\n    //a.x-=0.1;\n    \n    //anti overstep artifact hidden stuff\n        vec3 d = abs(p3)-1.0;\n        float outerBox = max(d.x,d.z);    \n        if(length(po.xz)>0.1) a.x = min(-outerBox,a.x);\n    \n    //=======END NON-DOMAIN WARPED SDF=======\n    a.x*=mul;\n    \n    //if(length(po.xz)<0.3) a.x = 0.1;\n    a.x = max(a.x,(length(p.xz)-20.0));\n    a.x = max(a.x,-(length(p.xz)-0.3)); //this ended up being useless\n    \n    p = po;\n    //GLOWY BEAM THING\n    b.x = length(p.xz)-0.8-sin(p.y-t*10.0)*0.2-sin(p.y*0.3-t*20.0)*0.2-abs(p.y)*0.2;\n    glow+=vec3(0.529,0.400,1.000)*0.1/(0.1+b.x*b.x);\n    \n    a =(a.x<b.x)?a:b;\n    \n    //ROTATING SEGMENTS\n    p.zx*=rot(t);\n    float alpha = atan(p.z,p.x);\n    p.y = abs(p.y)-9.0;\n    p.xz = pmodp(p.zx,pi/16.);\n    p-=vec3(17,sin(alpha*3.0-t)*2.0,0);\n    p.xy*=rot(alpha*1.5-t*3.0);\n    p.y+=2.;\n    \n    b.x = vSeg(p, 4.0,0.4);\n    b.y = 3.0;\n    a =(a.x<b.x)?a:b;\n\n    return a;\n}\n\n\nvec3 norm(vec3 p, float s){\n    vec2 e= vec2(s,0);\n    return normalize(vec3(\n    map(p+e.xyy).x,map(p+e.yxy).x,\n    map(p+e.yyx).x)-vec3(map(p-e.xyy).x,\n    map(p-e.yxy).x,map(p-e.yyx).x));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    float t = mod(iTime,999.);\n    vec3 ro = vec3(0,2.0+14.0*sin(t),-29.0);\n    \n    vec3 lk = vec3(0,0,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*0.7+uv.x*r+uv.y*cross(f,r));\n    \n    float dO, shad;\n    bool hit = false;\n    vec2 d; vec3 p;\n    \n    for(float i = 0.0; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+= d.x*0.85;\n        \n        if(abs(d.x)<0.005){\n            shad = i/STEPS;\n            hit = true;\n            break;\n        }\n        if(dO>MDIST){\n            dO = MDIST; break;\n        }\n    }\n    if(hit){\n        vec3 n = norm(p,0.02);\n        float edge = length(n-norm(p,0.12))*min(1.0,length(p)*0.2);\n        //edge =smoothstep(0.,0.15,edge);\n        \n        if(d.y == 1.0) col = vec3(0.388);\n        if(d.y == 2.0) col = vec3(0.502,0.000,1.000);\n        if(d.y == 3.0) col = vec3(0.388);\n        \n        //Shamelessly stealing blackle's lighting techniques \n        float ao = smoothstep(-.1,.1,map(p+n*.1).x)*\n                   smoothstep(-.3,.3,map(p+n*.3).x)*\n                   smoothstep(-.7,.7,map(p+n*.7).x);\n        vec3 r = reflect(rd, n);\n        float diff = length(sin(n*3.)*.7+.3)/sqrt(3.);\n        float spec = length(sin(r*3.)*.5+.5)/sqrt(3.);\n        float fres = 1.-abs(dot(rd,n))*.95;\n        col = col*pow(diff,3.0) + pow(spec, 12.)*fres*vec3(0.463,0.490,0.898);\n        col*=ao;\n        \n        if(d.y == 1.0)col+=smoothstep(0.,0.1,edge)*vec3(0.188,0.804,0.910);\n        if(d.y == 3.0)col+=smoothstep(0.,0.15,edge)*vec3(0.659,0.188,0.910)*10.0;\n    }\n\n    col = mix(col,mix(vec3(0.075),vec3(0.),length(uv)),dO/MDIST);\n    col+=glow*0.6;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dc3D8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[101, 101, 119, 119, 162], [164, 164, 190, 190, 249], [263, 263, 291, 291, 393], [394, 394, 431, 431, 484], [486, 486, 503, 503, 2517], [2520, 2520, 2547, 2547, 2712], [2715, 2715, 2772, 2772, 4564]]}
{"id": "7dc3WN", "name": "heart of my rays", "author": "fenoloftaleina", "description": "heart", "tags": ["raymarching", "asdf"], "likes": 0, "viewed": 51, "date": "1629831034", "time_retrieved": "2024-06-20T20:46:26.973709", "image_code": "// BASED ON:\n// \"ShaderToy Tutorial - Ray Marching for Dummies!\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/PGtv-dBi2wE\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat GetDist(vec3 p) {\n\tvec4 s = vec4(0, 1, 6, 1);\n    \n    float sphereDist =  length(p-s.xyz)-s.w + noise(p.xy * 10.0) * 0.5 * (2.95 + pow(sin(iTime), 2.0));\n    //float planeDist = p.y;\n    \n    //float d = min(sphereDist, planeDist);\n    float d = sphereDist;\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 30, 0);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1, 3);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    //float dif = GetLight(p);\n    float dif = (GetDist(p)<=SURF_DIST) ? GetLight(p) : 0.3;\n\n    col = vec3(dif);\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dc3WN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 362, 386, 386, 493], [495, 495, 521, 521, 1038], [1040, 1040, 1063, 1063, 1325], [1327, 1327, 1361, 1361, 1567], [1569, 1569, 1593, 1593, 1782], [1784, 1784, 1808, 1808, 2114], [2116, 2116, 2173, 2173, 2616]]}
{"id": "7dc3zS", "name": "Colorful circle", "author": "stoman", "description": "Learning how this stuff works", "tags": ["tutorial"], "likes": 1, "viewed": 107, "date": "1630055337", "time_retrieved": "2024-06-20T20:46:26.973709", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dist = distance(fragCoord, iResolution.xy/2.0);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col;\n    if(dist < iResolution.y/4.0) {\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    }\n    else {\n        col = 0.5 + 0.5*sin(iTime+uv.xyx+vec3(0,2,4));\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dc3zS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 370]]}
{"id": "7dcGRf", "name": "plötty", "author": "nexor", "description": ".", "tags": ["sdf"], "likes": 18, "viewed": 122, "date": "1630337668", "time_retrieved": "2024-06-20T20:46:26.973709", "image_code": "#define max2(v) max((v.x),(v.y))\n\nconst float pi = acos(-1.);\nconst float pi2 = pi*2.;\n\nmat2 rot(float a)\n{\n    float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat circle(vec2 p, float r)\n{return length(p)-r;}\n\nfloat box(vec2 p, vec2 b)\n{\np=abs(p)-b;\nreturn max(p.x,p.y)+length(max(p,0.));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat sdf(float d)\n{\n    return smoothstep(0.,fwidth(d)*1.5,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/max2(iResolution.xy);\n    \n    float w = fwidth(uv.y);\n\n    vec3 col = vec3(0);\n    \n    \n    \n    float d[] = float[](1e3,1e3);\n    \n    {\n        vec2 p = uv;\n        float k = cos(iTime*2.);\n        k = 2.*abs(k)-1.;\n        p.y -= k*.45;\n        d[0] = circle(p,.1);\n        p = rot(-cos(iTime*2.)*pi2)*p;\n        d[1] = min(d[1],box(p,vec2(.1-w*7.5))-w*15.);\n    }\n    \n    {\n        vec2 p = uv;\n        float k = 24.;\n        d[0] = smin(d[0],-p.y,k);\n        d[1] = smin(d[1],p.y,k);               \n    }\n    \n    float mask = sdf(uv.y);\n    \n    float d0 = sdf(d[0]);\n    float d1 = sdf(d[1]);\n    float fd = mix(1.-d0,d1,mask);\n    \n    col += fd;\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dcGRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[88, 88, 107, 107, 165], [167, 167, 198, 198, 218], [220, 220, 247, 247, 300], [302, 302, 343, 343, 417], [419, 419, 439, 439, 484], [486, 486, 543, 543, 1284]]}
{"id": "7dcGRj", "name": "Experiments with Perlin Noise", "author": "Sprocket", "description": "Trying to learn how perlin noise works\nusing:\nhttps://en.wikipedia.org/wiki/Perlin_noise\nhttps://www.shadertoy.com/view/MdGSzt\nhttps://www.shadertoy.com/view/4sc3z2\nhttps://www.shadertoy.com/view/4djSRW", "tags": ["perlinnoise", "learning"], "likes": 2, "viewed": 41, "date": "1630170136", "time_retrieved": "2024-06-20T20:46:27.264739", "image_code": "//  https://www.shadertoy.com/view/4djSRW\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 randomGradient(vec2 point)\n{\n    return -1.0 + 2.0 * hash22(point);\n}\n\nfloat perlin_noise(vec2 position)\n{\n    vec2 gridCell = floor(position);\n    vec2 local = position - gridCell;\n    \n    vec2 weight = local * local * (3.0 - 2.0 * local);\n    \n    return mix(\n                mix(\n                    dot(local - vec2(0,0), randomGradient(gridCell + vec2(0,0))),\n                    dot(local - vec2(1,0), randomGradient(gridCell + vec2(1,0))),\n                    weight.x),\n                mix(\n                    dot(local - vec2(0,1), randomGradient(gridCell + vec2(0,1))),\n                    dot(local - vec2(1,1), randomGradient(gridCell + vec2(1,1))),\n                    weight.x),\n                weight.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    uv += iTime * 0.2;\n    uv *= 8.0;\n    \n    // Time varying pixel color\n    vec3 col = vec3(perlin_noise(uv));\n    \n    col += 1.0;\n    col /= 2.0;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dcGRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 62, 83, 83, 217], [219, 219, 252, 252, 293], [295, 295, 330, 330, 947], [949, 949, 1006, 1056, 1309]]}
{"id": "7dcGzH", "name": "Simple ChessBoard", "author": "mengxin", "description": "A Chess Board Pattern", "tags": ["chessboard"], "likes": 1, "viewed": 55, "date": "1629131181", "time_retrieved": "2024-06-20T20:46:27.573958", "image_code": "\nconst float PI = 3.1415926535;\n\nfloat SampleChessBoard(vec2 uv)\n{\n    return step(0.0,sin(uv.x  * 12.0 * PI + PI) + sin(uv.y  * 6.75 * PI + PI));\n}\n\n\nfloat SuperSample(vec2 uv,vec2 Resolution)\n{\n    float SSAAX = 1.0/(Resolution.x * 2.0);\n    float SSAAY = 1.0/(Resolution.y * 2.0);\n    float sample0 = SampleChessBoard(uv + vec2(SSAAX,SSAAY));\n    float sample1 = SampleChessBoard(uv + vec2(SSAAX,-SSAAY));\n    float sample2 = SampleChessBoard(uv + vec2(-SSAAX,SSAAY));\n    float sample3 = SampleChessBoard(uv + vec2(-SSAAX,-SSAAY));\n    \n    return (sample0 + sample1 + sample2 + sample3)/4.0;\n}\n\n\nvec2 RotateUV(vec2 uv,float radian)\n{\n    return vec2(uv.x * cos(radian) - uv.y * sin(radian), uv.x * sin(radian) + uv.y * cos(radian));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = RotateUV(fragCoord,iTime*0.3)/iResolution.xy;\n    \n    uv += 0.5*cos(iTime);\n    \n    //uv = RotateUV(uv,iTime);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float ChessBoard = SuperSample(uv,iResolution.xy);\n    \n    \n    col = vec3(ChessBoard,ChessBoard,ChessBoard);\n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dcGzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[33, 33, 66, 66, 148], [151, 151, 195, 195, 598], [601, 601, 638, 638, 739], [742, 742, 799, 849, 1248]]}
{"id": "7dcGzn", "name": " Rectangle with Distortion", "author": "CosmicCrowMC", "description": "Made this after watching the first 4 tutorials from The Art of Code! I'm excited to begin my shader-programming journey.", "tags": ["basic", "newbie", "rectangle"], "likes": 1, "viewed": 57, "date": "1628974037", "time_retrieved": "2024-06-20T20:46:27.573958", "image_code": "float Circle (vec2 uv, vec2 p, float radius, float blur) {\n    float d = length(uv-p);\n    float c = smoothstep(radius, radius-blur, d);\n    return c;\n}\n\nfloat Mask (vec2 uv, vec2 p, float size) {\n    uv -= p; //Translate Coordinate System\n    uv /= size; //Scale Coordinate System\n    float mask = Circle(uv,vec2(0.0),0.4,0.01);\n    mask -= Circle(uv,vec2(-0.2,0.0),0.03,0.01);\n    mask -= Circle(uv,vec2(0.2,0.0),0.03,0.01);\n    return mask;\n}\n\nfloat Band (float t, float start, float end, float blur) {\n    float step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    return step1*step2;\n}\n\nfloat Rect (vec2 uv, vec4 dims, float blur) {\n    float band1 = Band(uv.x,dims.x,dims.x+dims.z,blur);\n    float band2 = Band(uv.y,dims.y,dims.y+dims.w,blur);\n    return band1*band2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = vec3(1.0);\n    uv-=0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv.x+=sin(uv.y*5.0-iTime*6.)/(5.0+cos(iTime));\n    \n    float mask = Mask(uv, vec2(0.0,0.0), 0.7);\n    mask = Rect(uv, vec4(-0.3,-0.2,0.6,0.4),.01);\n    // Output to screen\n    fragColor = vec4(col,1.0)*mask;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dcGzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 58, 58, 152], [154, 154, 196, 196, 445], [447, 447, 505, 505, 641], [643, 643, 688, 688, 826], [828, 828, 885, 935, 1277]]}
{"id": "7dd3Dn", "name": "Chess table", "author": "TestCoder", "description": "chess", "tags": ["chess"], "likes": 2, "viewed": 118, "date": "1629606277", "time_retrieved": "2024-06-20T20:46:27.579868", "image_code": "float getSquareSine(float x) {\n    return sign(sin(x));\n}\n\nfloat getRotatingMagnifier(vec2 uv, float radius, float rotationDisplacement) {\n    return distance(\n        uv,\n        vec2(\n            sin(iTime + rotationDisplacement),\n            cos(iTime + rotationDisplacement)\n        )\n    ) * radius;\n}\n\n\nfloat getChessPattern(vec2 uv, float size) {\n    return (\n        (\n            getSquareSine(-uv.x * size) + getSquareSine(-uv.y * size)\n        ) * -1. * (\n            getSquareSine(uv.x * size) + getSquareSine(uv.y * size)\n        )\n    );\n}\n\nfloat getDistortedTable(vec2 uv, float radius, float size, float rotationDisplacement) {\n    float magnifier = getRotatingMagnifier(uv, radius, rotationDisplacement);\n\n    return (\n        getChessPattern(\n            uv\n\n            // table distortion\n            * magnifier\n            ,\n            size\n        ) * magnifier * (1. - magnifier)\n    );\n}\n\nfloat getDistortionStack(vec2 uv, float slicingSteps) {\n    float distortionStack = 0.;\n    \n    for (float timeSlice = 1.; timeSlice <= pow(2., slicingSteps); timeSlice += timeSlice) {\n        distortionStack +=\n             getDistortedTable(uv, 1., 50., sin(iTime / timeSlice))\n           + getDistortedTable(uv, 1., 50., cos(iTime / timeSlice));\n    }\n\n    return distortionStack;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    \n    uv.y *= iResolution.y / iResolution.x;\n    \n    float distortionStack = getDistortionStack(uv, 3.);\n\n    vec3 col = distortionStack * vec3(1);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dd3Dn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 30, 30, 57], [59, 59, 138, 138, 306], [309, 309, 353, 353, 553], [555, 555, 643, 643, 913], [915, 915, 970, 970, 1301], [1303, 1303, 1360, 1360, 1589]]}
{"id": "7dd3Rj", "name": "metaball wejfkhdhrio", "author": "jy483752", "description": "i eat meatball, meatball delicious", "tags": ["w"], "likes": 3, "viewed": 76, "date": "1630252354", "time_retrieved": "2024-06-20T20:46:27.579868", "image_code": "// Simplex 2D noise\n//https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\nfloat metaball(in float radius, in vec2 st){\n    return (radius-length(st))/length(st);;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.5/iResolution.x;\n    \n    vec2 uv = fragCoord/iResolution.y;\n    uv -= 0.5*vec2(iResolution.x/iResolution.y, 1.0);\n    \n    float t = iTime/12.;\n    float t2 = t+0.005;\n    float t3 = t+0.01;\n\n    float rsum = 0.; \n    float num = 12.;\n    for(float i=0.; i<num; i++){\n        float r = snoise(vec2(t, i*300.))*0.4+0.6;\n        vec2 pos = vec2(\n            snoise(vec2(i+200., t)), \n            snoise(vec2(i*20., t+200.))\n            );\n        rsum += metaball(r, uv-pos);\n    }\n    rsum = smoothstep(fwidth(rsum),0.,rsum);\n    \n    float gsum = 0.; \n    for(float i=0.; i<num; i++){\n        float r = snoise(vec2(t2, i*300.))*0.4+0.6;\n        vec2 pos = vec2(\n            snoise(vec2(i+200., t2)), \n            snoise(vec2(i*20., t2+200.))\n            );\n        gsum += metaball(r, uv-pos);\n    }\n    gsum = smoothstep(fwidth(gsum),0.,gsum);\n    \n    float bsum = 0.; \n    for(float i=0.; i<num; i++){\n        float r = snoise(vec2(t3, i*300.))*0.4+0.6;\n        vec2 pos = vec2(\n            snoise(vec2(i+200., t3)), \n            snoise(vec2(i*20., t3+200.))\n            );\n        bsum += metaball(r, uv-pos);\n    }\n    bsum = smoothstep(fwidth(bsum),0.,bsum);\n\n    vec3 col = rsum*vec3(1,0,0) + bsum*vec3(0,0,1) + gsum*vec3(0,1,0);\n    col = 1. - col;\n    //vec3 col = smoothstep(1., 1.-px, \n    //    vec3(rsum, gsum, bsum)\n    //    );\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dd3Rj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 88, 110, 110, 149], [151, 151, 172, 172, 992], [995, 995, 1039, 1039, 1085], [1087, 1087, 1144, 1144, 2539]]}
{"id": "7ddGRn", "name": "Fireworks by Mendi", "author": "mendi80", "description": "My fireworks, based on \"The art of code\".", "tags": ["fireworks"], "likes": 10, "viewed": 220, "date": "1629047003", "time_retrieved": "2024-06-20T20:46:27.901055", "image_code": "\n\n#define NUM_EXPLOSIONS 7.\n#define NUM_PARTICLES 100.\n#define inv_nparticels (1./NUM_PARTICLES)\n#define PI 3.1415926\n\nfloat Hash11(float t){\n    return fract(sin(t*613.2)*614.8);\n}\nvec2 Hash12(float t){\n  return vec2(fract(sin(t*213.3)*314.8)-0.5,fract(sin(t*591.1)*647.2)-0.5);\n}\n\nvec2 Hash12_Polar(float t){\n    float o = fract(sin(t*213.3)*314.8)*PI*2.0;\n    float r = fract(sin(t*591.1)*647.2);\n    return vec2(sin(o)*r,cos(o)*r);\n}\n\nfloat Explosion(vec2 uv, float t)\n{\n    float fract_t=fract(t);\n    float floor_t=floor(t);\n    float power=0.3+Hash11(floor_t);\n    float sparks=0.;\n    for(float i=0.;i<NUM_PARTICLES;i++)\n    {\n        vec2 dir=Hash12_Polar(i*floor_t)*1.;\n        float inv_d=1./(length(uv-dir*sqrt(fract_t)));\n        float brightness=mix(0.3,0.09,smoothstep(0.,0.1,fract_t))*(1.0-(0.5+0.5*Hash11(i))*fract_t);\n        float sparkling= .5+.5*sin(t*10.2+floor_t*i);\n        sparks+=power*brightness*sparkling*inv_nparticels*inv_d;\n    }\n    return sparks;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col=vec3(0);    \n\n    for(float i=0.;i<NUM_EXPLOSIONS;i++){\n        float t=iTime*(0.3+0.4*Hash11(i))+i/NUM_EXPLOSIONS;\n        float fract_t=fract(t);\n        float floor_t=floor(t);\n    \n        vec3 color=0.7+0.3*sin(vec3(.34,.54,.43)*floor_t*i);\n        vec2 center = Hash12(i+10.+5.*floor_t);\n        col+=Explosion(uv-center,t)*color;\n    }\n    col-=0.1;\n    fragColor = vec4(col,1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7ddGRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[119, 119, 141, 141, 181], [182, 182, 203, 203, 281], [283, 283, 310, 310, 437], [439, 439, 474, 474, 981], [983, 983, 1038, 1038, 1501]]}
{"id": "7ddGWN", "name": "Metallic Menger Sponge", "author": "otkazano", "description": "Menger Sponge with simple reflection.", "tags": ["raymarching", "fractals", "reflections", "mengersponge"], "likes": 3, "viewed": 64, "date": "1629910582", "time_retrieved": "2024-06-20T20:46:28.870967", "image_code": "/*\nMenger Sponge with simple reflection.\nNO OPTIMIZED!\n*/\n\n//scene params\n#define SpongeMaxIterations 4\n#define CyclePeriod 10.0\n#define IdlePeriod 6.0\n#define SolidPeriod 4.0\n\n//quality params\n#define subSamples 2\n\n//uv screen params\n#define du 0.5\n#define dv 0.5\n#define iR vec2(1.0/iResolution.x, 1.0/iResolution.y)\n//camera params\n#define CameraZoom 0.75\n#define CameraDistance 5.0\n//mice params\n#define miceFactor vec2(-9.0, 3.0)\n//march tracing params\n#define MarchMaxDistance 1e3\n#define MarchSteps 80\n#define MarchThreshold 1e-3\n#define MarchNormalPrecision 0.03/float(SpongeMaxIterations+1)\n\n\n\nfloat mtf;\n\nmat2 rotate(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\nfloat sdSphere(vec3 orgn, vec3 pos, float r){\n    return length(pos-orgn)-r;\n}\nfloat sdBox(vec3 orgn, vec3 pos, vec3 size){\n    vec3 p = abs(pos-orgn)-size;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n    \n}\nfloat crosshair(vec3 orgn, float size){\n    float far = 200.0;\n    return min(min(sdBox(orgn,vec3(0.0),vec3(far,size,size)), sdBox(orgn,vec3(0.0),vec3(size,far,size))),sdBox(orgn,vec3(0.0),vec3(size,size,far)));\n}\nfloat mengerSponge(vec3 orgn, vec3 pos,float size, int iterations){\n    pos = pos-orgn;\n    vec3 c = abs(pos)-size;\n    float dist = max(max(c.x,c.y),c.z);\n    \n    vec3 p = pos;\n    float space;\n    float ii;\n    for(int i=1; i<=iterations; i++){\n        ii = float(i);\n        p = pos;\n        space = size*pow(1.0/3.0,ii-1.0) * 2.0;\n        p = mod(p+space*0.5,space);\n        p = p-space*0.5;\n        dist = max(-crosshair(p, size*pow(1.0/3.0,ii)), dist);\n    }\n    return dist;\n}\n\n\nfloat distMap(vec3 pos){\n    float initSize = 0.5;\n    \n    //distField optomize\n    float phase1 = sdSphere(pos, vec3(0.0), 1.75*initSize*pow(pow(27.0/20.0,float(SpongeMaxIterations)),1.0/3.0));\n    if(phase1 > MarchThreshold*10.0){\n        return phase1;\n    }\n    \n    int it1 = 0;\n    int it2 = 0;\n    int maxIterations = SpongeMaxIterations;\n\n\n    \n    float period = CyclePeriod;\n    float idle = IdlePeriod;\n    float solid = SolidPeriod;\n    float fullPeriod = period * float(SpongeMaxIterations+1);\n    \n    float transFunction = min(mod(iTime,period)/(period-idle),1.0);\n    float solidFunction = max((min(abs(-2.0*(mod(iTime,period)-(period-idle)-idle/2.0)/idle),1.0)-1.0)*(2.0/(idle-solid))+1.0, 0.0);\n    float influFunction = pow(smoothstep(0.0,1.0,transFunction),1.0);\n    mtf = solidFunction;\n\n    it1 = int(mod(iTime/period,float(maxIterations+1)));\n    it2 = int(mod((iTime+period)/period,float(maxIterations+1)));\n    \n    \n    float influence = pow(pow(27.0/20.0,1.0/3.0),float(it1)+influFunction);\n\n\n    \n\n    if(it2==0){\n        mtf = 1.0;\n        influence = mix(pow(pow(27.0/20.0,1.0/3.0),float(maxIterations)),1.0,1.0-pow(smoothstep(1.0,0.0,transFunction),3.0));\n    }\n    \n    float fig1 = mengerSponge(pos, vec3(0.0,0.0,0.0), initSize*influence, it1);\n    float fig2 = mengerSponge(pos, vec3(0.0,0.0,0.0), initSize*influence, it2);\n    \n    return mix(fig1, fig2, smoothstep(0.0,1.0,transFunction)) + (0.01*sin(length(pos)*9.0-iTime*3.9)/(influence+1.0) + (sin(pos.x*15.7+iTime*9.0)+sin(pos.y*16.1+iTime*7.0)+sin(pos.z*17.2+iTime*8.0))*0.001)*(pow(mtf,3.0))/float(it1+1);\n}\nvec3 getNormal(vec3 pos){\n    float e = MarchNormalPrecision;\n    int id;\n    vec3 options;\n    float anchor = distMap(pos);\n    return normalize(vec3(\n        anchor - distMap(pos-vec3(e,0.0,0.0)),\n        anchor - distMap(pos-vec3(0.0,e,0.0)),\n        anchor - distMap(pos-vec3(0.0,0.0,e))\n     ));\n}\n\nvec4 rayMarch(vec3 position, vec3 direction, float dirFactor, out float pathLen){\n    float dist = 0.0;\n    pathLen = 0.0;\n    for(int i=0; i<MarchSteps; i++){\n        dist = distMap(position);\n        pathLen += dist;\n        if(dist<=MarchThreshold || dist>=MarchMaxDistance) break;\n        position += direction*dirFactor*dist;\n    }\n    return vec4(position, dist);\n}\n\nvec2 mice(){\n    return vec2(iMouse.x/iResolution.x-.5,iMouse.y/iResolution.y-.5);\n}\n\nvec3 getDirection(vec2 uv, vec2 angle, float zoom, out vec3 pos){\n    vec3 n = normalize(vec3(uv.x,-uv.y,zoom));\n    pos = vec3(0.0, 0.0, -CameraDistance);\n    pos.yz *= rotate(angle.y);\n    pos.xz*= rotate(angle.x);\n    n.yz*= rotate(angle.y);\n    n.xz*= rotate(angle.x);\n    return n;\n}\n\nvec4 sky(vec3 dir, float k, float sh){\n    float sharpness = 1.0-sh;\n    vec3 upCol = mix(vec3(0.7,0.8,0.9)*1.5,vec3(0.6,0.75,0.9),(1.0+dir.z)*0.5);\n    vec3 dnCol = mix(vec3(0.2,0.4,0.7),vec3(0.2,0.3,0.5)*.6,(1.0+dir.z)*0.5);\n    return vec4(vec3(mix(upCol,dnCol,(mix(dir.y,pow(abs(dir.y),sharpness)*sign(dir.y), k)+1.0)*0.5)),1.0);\n}\nvec3 frameSubProcessing(vec2 uv){\n    vec3 pos;\n    vec3 dir = getDirection(uv, mice()*miceFactor, CameraZoom, pos);\n    vec3 norm;\n    float pathLen;\n        \n    vec4 d = rayMarch(pos, dir, 1.0, pathLen);  \n    norm = getNormal(d.xyz);\n    \n    vec3 mat1_Col = vec3(0.99,0.99,0.99)*.9;\n    vec3 mat2_Col = vec3(0.99,0.85,0.80)*.9;\n    \n    if(d.w < MarchMaxDistance){\n        return sky(reflect(dir,norm),mix(0.22,.99,mtf),mix(0.1,.99,mtf)).rgb * mix(mat1_Col,mat2_Col,mtf);\n    }\n    return sky(dir,0.99,.9).rgb;\n}\nvec3 frameProcessing(vec2 uv){\n    float ss = float(subSamples);\n    vec2 offset;\n    vec3 curPix = frameSubProcessing(uv);\n    float count = 1.0;\n    \n    float delta = 1.0/(ss+1.0);\n    for(int y=0; y<subSamples; y++){\n        for(int x=0; x<subSamples; x++){\n            offset = vec2((delta*float(x+1)-.5)*iR.x,(delta*float(y+1)-.5)*iR.y);\n            if(mod(ss,2.0)>0.0){\n                if(x==(subSamples+1)/2 && y==(subSamples+1)/2) continue;\n            }\n            curPix += frameSubProcessing(uv+offset);\n            count += 1.0;\n        }\n    }\n    return curPix/count;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = vec2(fragCoord.x * iR.x - du, (fragCoord.y * iR.y - dv)*iR.x*iResolution.y);\n    vec3 rgb = frameProcessing(uv);\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7ddGWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[435, 615, 636, 636, 699], [700, 700, 745, 745, 778], [779, 779, 823, 823, 924], [925, 925, 964, 964, 1138], [1139, 1139, 1206, 1206, 1623], [1626, 1626, 1650, 1650, 3226], [3227, 3227, 3252, 3252, 3529], [3531, 3531, 3612, 3612, 3902], [3904, 3904, 3916, 3916, 3988], [3990, 3990, 4055, 4055, 4278], [4280, 4280, 4318, 4318, 4615], [4616, 4616, 4649, 4649, 5133], [5134, 5134, 5164, 5164, 5719], [5721, 5721, 5775, 5775, 5935]]}
{"id": "7ddGzS", "name": "Turbulent cloud flythrough", "author": "jarble", "description": "A modified version of Shane's [url=https://www.shadertoy.com/view/Xsc3R4]\"Cheap Cloud Flythrough\"[/url] with some [url=https://www.shadertoy.com/view/7sc3z7]fake fluid physics[/url].", "tags": ["noise", "cloud", "volumetric", "turbulence", "turbulence", "sinusoidal", "flythrough"], "likes": 12, "viewed": 288, "date": "1630102945", "time_retrieved": "2024-06-20T20:46:30.180019", "image_code": "/*\n\n\tCheap Cloud Flythrough \n\t----------------------\n\t\n\t\"Cheap\" should probably refer to the quality of the physics in this shader, which is\n\tvirtually non-existent, but it actually refers to the fake cloud algorithm... if you could \n\tcall it that. :)\n\t\n\tThis is merely an attempt to give the impression of a cloud flythrough, whilst maintaining\t\n\ta reasonably acceptable framerate. The key to that is keeping the distance field as simple \n\tas possible.\n\n\tDue to the amount of cost cutting, it's far from  perfect. However, there's still plenty \n\tof room for improvement.\n\n    I've used density based accumulation, which in one way or another, uses concepts from many \n\tvolumetric examples, but particularly from the following:\n\t\n\tCloudy Spikeball - Duke\n    https://www.shadertoy.com/view/MljXDw\n    // Port from a demo by Las - Worth watching.\n    // http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n    \n    Other shaders worth looking at:\n\n\tClouds - IQ: One of my favorite shaders, and everyone elses, it seems.\n\thttps://www.shadertoy.com/view/XslGRr\n\t\t\n\tSample Pinning - huwb: Fast, and pretty.\n\thttps://www.shadertoy.com/view/XdfXzn\n\t\n\tFakeVolumetricClouds - Kuvkar: Fast, using parallax layers. Really cool.\n\thttps://www.shadertoy.com/view/XlsXzN\n\n    Emission clouds - Duke: Nice, and straight forward.\n    https://www.shadertoy.com/view/ltBXDm\n\n\n*/\n\n\n// IQ's texture lookup noise... in obfuscated form. There's less writing, so\n// that makes it faster. That's how optimization works, right? :) Seriously,\n// though, refer to IQ's original for the proper function.\n// \n// By the way, you could replace this with the non-textured version, and the\n// shader should run at almost the same efficiency.\nfloat pn( in vec3 p ){\n    \n    vec3 i = floor(p); p -= i; p *= p*(3. - 2.*p);\n\tp.xy = texture(iChannel0, (p.xy + i.xy + vec2(37, 17)*i.z + .5)/256., -100.).yx;\n\treturn mix(p.x, p.y, p.z);\n}\n\n\n\n// Basic low quality noise consisting of three layers of rotated, mutated \n// trigonometric functions. Needs work, but sufficient for this example.\nfloat trigNoise3D(in vec3 p){\n\n    p /= 2.;\n    float res = 0., sum = 0.;\n    \n    // IQ's cheap, texture-lookup noise function. Very efficient, but still \n    // a little too processor intensive for multiple layer usage in a largish \n    // \"for loop\" setup. Therefore, just one layer is being used here.\n    float n = pn(p*8. + iTime*2.);\n\n\n    // Two sinusoidal layers. I'm pretty sure you could get rid of one of \n    // the swizzles (I have a feeling the GPU doesn't like them as much), \n    // which I'll try to do later.\n    \n    vec3 t = sin(p.yzx*3.14159265 + cos(p.zxy*3.14159265+1.57/2.))*0.5 + 0.5;\n    p = p*1.5 + (t - 1.5); //  + iTime*0.1\n    res += (dot(t, vec3(0.333)));\n\n    t = sin(p.yzx*3.14159265 + cos(p.zxy*3.14159265+1.57/2.))*0.5 + 0.5;\n    res += (dot(t, vec3(0.333)))*0.7071;    \n\t \n\treturn ((res/1.7071))*0.85 + n*0.15;\n}\n\nvec3 fluid(vec3 uv1,float iters){\n //fake fluid physics\n vec3 uv = uv1;\n for (float i = 1.; i < iters; i++)\n  {\n    uv.x += sin((iTime-uv.y)*.5)*1.5/i* sin(i * uv.y + iTime * 0.5);\n    uv.y += sin((iTime-uv.z)*.5)*1.5/i* sin(i * uv.z + iTime * 0.5 );\n    uv.z += sin((iTime-uv.x)*.5)*1.5/i* sin(i * uv.x + iTime * 0.5 );\n  }\n  return uv;\n}\n\n// Distance function.\nfloat map(vec3 p,float iters) {\n    p = fluid(p,iters);\n    return trigNoise3D(p);\n    \n    // Three layers of noise, for comparison.\n    //p += iTime;\n    //return pn(p*.75)*0.57 + pn(p*1.875)*0.28 + pn(p*4.6875)*0.15;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\n    // Unit direction ray vector: Note the absence of a divide term. I came across\n    // this via a comment Shadertoy user \"coyote\" made. I'm pretty easy to please,\n    // but I thought it was pretty cool.\n    vec3 rd = normalize(vec3(fragCoord - iResolution.xy*.5, iResolution.y*.75)); \n    float t1 = iTime/2.;\n    // Ray origin. Moving along the Z-axis.\n    vec3 ro = vec3(0, 0, t1);\n\n    // Cheap camera rotation.\n    //\n    // 2D rotation matrix. Note the absence of a cos variable. It's there, but in disguise.\n    // This one came courtesy of Shadertoy user, \"Fabrice Neyret.\"\n    vec2 a = sin(vec2(1.5707963, 0) + t1*0.1875); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xy = rd.xy*rM; // Apparently, \"rd.xy *= rM\" doesn't work on some setups. Crazy.\n    rd.xz = rd.xz*rM;\n\n    // Placing a light in front of the viewer and up a little, then rotating it in sync\n    // with the camera. I guess a light beam from a flying vehicle would do this.\n    vec3 lp = vec3( 0, 1, 4);\n    lp.xy = lp.xy*rM;\n    lp.xz = lp.xz*rM;\n    lp += ro;\n\n    // The ray is effectively marching through discontinuous slices of noise, so at certain\n    // angles, you can see the separation. A bit of randomization can mask that, to a degree.\n    // At the end of the day, it's not a perfect process. Note, the ray is deliberately left \n    // unnormalized... if that's a word.\n    //\n    // Randomizing the direction.\n    //rd = (rd + ((rd.zyx)*.006 - .003)); \n    // Randomizing the length also. \n    rd *= (1. + fract((dot(vec3(7, 157, 113), rd.zyx))*43758.5453)*0.06-0.03);      \n\n    // Local density, total density, and weighting factor.\n    float lDe = 0., td = 0., w = 0.;\n\n    // Closest surface distance, and total ray distance travelled.\n    float d = 1., t = 0.;\n\n    // Distance threshold. Higher numbers give thicker clouds, but fill up the screen too much.    \n    const float h = .5;\n\n\n    // Initializing the scene color to black, and declaring the surface position vector.\n    vec3 col = vec3(0), sp;\n\n\n\n    // Particle surface normal.\n    //\n    // Here's my hacky reasoning. I'd imagine you're going to hit the particle front on, so the normal\n    // would just be the opposite of the unit direction ray. However particles are particles, so there'd\n    // be some randomness attached... Yeah, I'm not buying it either. :)\n    vec3 sn = normalize(-rd);\n\n    // Raymarching loop.\n    for (int i=0; i<64; i++) {\n\n        // Loop break conditions. Seems to work, but let me\n        // know if I've overlooked something.\n        if((td>1.) || d<.01*t || t>80.)break;\n\n\n        sp = ro + rd*t; // Current ray position.\n        d = map(sp,15.-d*15.); // Closest distance to the surface... particle.\n\n        // If we get within a certain distance, \"h,\" of the surface, accumulate some surface values.\n        // The \"step\" function is a branchless way to do an if statement, in case you're wondering.\n        //\n        // Values further away have less influence on the total. When you accumulate layers, you'll\n        // usually need some kind of weighting algorithm based on some identifying factor - in this\n        // case, it's distance. This is one of many ways to do it. In fact, you'll see variations on \n        // the following lines all over the place.\n        //\n        lDe = (h - d)*step(d, h); \n        w = (1. - td)*lDe;   \n\n        // Use the weighting factor to accumulate density. How you do this is up to you. \n        td += w*w*8. + 1./64.; //w*w*5. + 1./50.;\n        //td += w*.4 + 1./45.; // Looks cleaner, but a little washed out.\n\n\n        // Point light calculations.\n        vec3 ld = lp-sp; // Direction vector from the surface to the light position.\n        float lDist = max(length(ld), .001); // Distance from the surface to the light.\n        ld/=lDist; // Normalizing the directional light vector.\n\n        // Using the light distance to perform some falloff.\n        float atten = 1./(1. + lDist*.125 + lDist*lDist*.05);\n\n        // Ok, these don't entirely correlate with tracing through transparent particles,\n        // but they add a little anglular based highlighting in order to fake proper lighting...\n        // if that makes any sense. I wouldn't be surprised if the specular term isn't needed,\n        // or could be taken outside the loop.\n        float diff = max(dot( sn, ld ), 0.);\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0. ), 4.);\n\n\n        // Accumulating the color. Note that I'm only adding a scalar value, in this case,\n        // but you can add color combinations. Note the \"d*3. - .1\" term. It's there as a bit\n        // of a fudge to make the clouds a bit more shadowy.\n        col += w*(d*3. - .1)*(.5 + diff + spec*.5)*atten;\n\n        // Try this instead, to see what it looks like without the fake contrasting. Obviously,\n        // much faster.\n        //col += w*atten*1.25;\n\n\n        // Enforce minimum stepsize. This is probably the most important part of the procedure.\n        // It reminds me a little of of the soft shadows routine.\n        t +=  max(d*.5, .02); //\n        // t += .2; // t += d*.5;// These also work, but don't seem as efficient.\n\n    }\n\n    col = max(col, 0.);\n\n    // trigNoise3D(rd*1.)\n    col = mix(pow(vec3(1.5, 1, 1)*col,  vec3(1, 2, 8)), col, dot(cos(rd*6. +sin(rd.yzx*6.)), vec3(.333))*.35 + .65);\n    col = mix(col.zyx, col, dot(cos(rd*9. +sin(rd.yzx*9.)), vec3(.333))*.15 + .85);//xzy\n    \n\n    //col = mix(col.zyx, col, dot(rd, vec3(.5))+.5);\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7ddGzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1370, 1716, 1738, 1738, 1906], [1910, 2058, 2087, 2087, 2907], [2909, 2909, 2942, 2964, 3248], [3250, 3272, 3303, 3303, 3493], [3495, 3495, 3552, 3762, 9063]]}
{"id": "7dt3Rf", "name": "Breathe Red", "author": "shv_luffy_98", "description": "mirrored animation", "tags": ["mirror"], "likes": 1, "viewed": 36, "date": "1630410904", "time_retrieved": "2024-06-20T20:46:30.180019", "image_code": "#define deg 0.01745329251\n\nfloat rangeConvert(float OldValue, float OldMin, float OldMax, float NewMin, float NewMax){\n    return (((OldValue - OldMin) * (NewMax - NewMin)) / (OldMax - OldMin)) + NewMin;\n}\nfloat myRangeConvert(float v){\n    return v * .8 + .2;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv = abs(uv);\n    uv = vec2(max(uv.x, uv.y), min(uv.x, uv.y));\n    \n    vec3 col1 = vec3(1, 0, 0) * (1. - step(0.005, uv.y) ) *\n                    clamp(sin((iTime * 30. - 30. * (1. - (.25 - uv.x) / .25) ) * deg), 0., 1.);\n    vec3 col2 = vec3(1, 0, 0) * (1. - step(0.005, abs(uv.x - .25 - uv.y) ) ) *\n                    clamp(sin((iTime * 30. - 30. - 30. * (1. - (.5 - uv.x) / .25) ) * deg), 0., 1.);\n    vec3 col3 = vec3(1, 0, 0) * (1. - step(0.005, abs(.5 - uv.x) ) ) * step(.25, uv.y) *\n                    clamp(sin((iTime * 30. - 60. - 30. * (1. - (.5 - uv.y) / .25) ) * deg), 0., 1.); \n    \n   \n    vec3 col = mix(col1, col2, step(.25, uv.x));\n    float mixv = smoothstep(.495, .5, uv.x);\n    col = col * (1. - mixv) + col3 * mixv;\n    \n    fragColor = vec4(col * (1. - step(.5, uv.y)), 1.);\n}\n\n// float weight1 = step(.25, uv.x);\n//vec3 col = (col1 * (1. - weight1) + col2 * weight1 ) * (1. - step(.5, uv.x) )\n//            + col3 * step(.495, uv.x);\n//\n//vec3 col = mix(mix(col1, col2, step(.25, uv.x)), col3, step(.495, uv.x));", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dt3Rf.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[27, 27, 118, 118, 205], [206, 206, 236, 236, 262], [263, 263, 320, 320, 1224]]}
{"id": "7dt3Rr", "name": "shiny beat", "author": "snflwrfld", "description": "mouseX controls the density of squares", "tags": ["2d", "beat"], "likes": 6, "viewed": 77, "date": "1629062519", "time_retrieved": "2024-06-20T20:46:30.823136", "image_code": "#define PI 3.14159265359\n#define TAU 6.28318530718\n\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st,vec2(1.9898,7.233))+2.)*\n        4378.5453123);\n}\n\nfloat growing_poly_pattern(vec2 st,float t,int N,float WIDTH,float GROWING_SPEED){\n    float l = length(st),th = atan(st.x,st.y)+PI;\n    float r = TAU/float(N);\n    float d = cos(floor(0.5+th/r)*r-th)*length(st);\n    return 1.0-smoothstep(.4,.41,mod(pow(d,0.508)-t*GROWING_SPEED,WIDTH));\n}\n\nfloat flashing_grid(vec2 st,float t,in vec2 ipos) {\n    return step(1.-iMouse.x/iResolution.x,mod(ipos.x+ipos.y,2.)+2.496*random(ipos*.2+t/900000.));\n}\n\nfloat pulse( float x, float a, float b ){\n    float k = pow(a+b,a+b) / (pow(a,a)*pow(b,b));\n    return k * pow( x, a ) * pow( 1.0-x, b );\n}\n\nfloat box (vec2 st,float size) {\n    float d = max(abs(st.x),abs(st.y));\n    return step(d,size);\n}\n\nmat2 rotate2d (float th) {\n    return mat2(cos(th),-sin(th),sin(th),cos(th));\n}\n\nfloat triangle (vec2 st, float size){\n  int N = 3;\n  float a = atan(st.x,st.y)+PI;\n  float r = TAU/float(N);\n\n  float d = cos(floor(.5+a/r)*r-a)*length(st);\n\n  return 1.0-step(.5*size,d);\n}\n\nfloat shapesnbeats(vec2 st, float t) {\n    float r = length(st);\n\n    vec3 color = vec3(0.);\n    \n    float beat = floor(mod(t,4.));\n    \n    float a=.5,b=2.;float x_max=a/(a+b);\n    float size = pulse(fract(t),a,b);\n    \n    \n    if (beat==0. || beat==2.){\n        color += step(r,1.*size);\n    } else if (beat==1.){\n        st = rotate2d(smoothstep(0.,.5,fract(t))*PI)*st;\n        color += box(st,1.*size);\n    } else {\n        st = rotate2d(smoothstep(0.,.5,fract(t))*2.*PI/3.)*st;\n        color += triangle(st,1.3*size);\n    }\n    \n    return color.x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st = st*2.-1.;\n    st.x *= iResolution.x/iResolution.y;\n    \n    // beat\n    float BPM = 120.;\n    float t = iTime*BPM/60.;\n    \n    \n    \n    // polygon pattern\n    int N = 6; //number of sides\n    float WIDTH = .7;\n    float GROWING_SPEED = 0.125;\n    \n    st = 2.*rotate2d(PI/6.)*st;\n    float hex = growing_poly_pattern(st,t,N,WIDTH,GROWING_SPEED);\n    \n    \n    \n    // grid parameters\n    float GRID_ROTATE_ANGLE = PI/25.;\n    float GRID_ZOOM = 6.5;\n    vec2 GRID_VEL = vec2(4.,1.5);\n    \n    st = rotate2d(GRID_ROTATE_ANGLE-PI*1./6.)*GRID_ZOOM*st;\n    st += GRID_VEL*t;\n    vec2 ipos=floor(st),fpos=fract(st);\n    \n    \n    \n    // white anim\n    vec2 COLOR_SHIFT = vec2(2.,0.0); //COULD BE IMPROVED\n    vec3 color_w ;\n    color_w.b= flashing_grid(st-COLOR_SHIFT,t,ipos);\n    color_w.g= flashing_grid(st,t,ipos);\n    color_w.r= flashing_grid(st+COLOR_SHIFT,t,ipos);\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    color_w += mix(vec3(0.225,0.820,0.702),vec3(1.000,0.977,0.720),smoothstep(.4,1.7,uv.x+uv.y));\n    \n    \n    \n    // black anim\n    vec3 color_b = vec3(0.100,0.072,0.063);\n    fpos = fpos*2.-1.;\n    float r = length(fpos);\n    \n    vec2 COLOR_SHIFT2 = vec2(.45,0.0)*pow(clamp(0.,1.,length(uv*2.-1.)),2.3);\n    color_b.r += shapesnbeats(fpos-COLOR_SHIFT2,t);\n    color_b.g  += shapesnbeats(fpos,t);\n    color_b.b += shapesnbeats(fpos+COLOR_SHIFT2,t);\n    \n    color_b *= 1.-flashing_grid(st,t,ipos);\n    \n    \n    \n    // mixing\n\tvec3 color = mix(color_w,color_b,hex);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dt3Rr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[53, 53, 76, 76, 154], [156, 156, 238, 238, 445], [447, 447, 498, 498, 598], [600, 600, 641, 641, 739], [741, 741, 773, 773, 840], [842, 842, 868, 868, 921], [923, 923, 960, 960, 1112], [1114, 1114, 1152, 1152, 1671], [1673, 1673, 1728, 1728, 3307]]}
{"id": "7dt3W4", "name": "Metadots", "author": "rs_creative", "description": "Concepting a metaball effect. Click and drag to move central spot.", "tags": ["noise", "metaballs", "color"], "likes": 1, "viewed": 59, "date": "1629888532", "time_retrieved": "2024-06-20T20:46:30.823136", "image_code": "\nfloat sDot( vec2 uv, vec2 position, float val, vec2 target )\n{\n    float distToTarget = 1.0 - distance( uv, target );\n    return smoothstep( 0.0, 0.65, max( 0.02 + ( 0.02 * distToTarget ), 0.02) / distance( uv, position + ( ( val * 2.0 - 1.0 ) * 0.015 ) ) );\n    //return smoothstep( 0.0, 0.65, ( 0.02 + ( 0.04 * ( sin( iTime * 0.5 ) * 0.5 + 0.5) ) ) / distance( uv, position + ( ( val * 2.0 - 1.0 ) * 0.015 ) ) );\n}\n\nfloat rand (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec3 dithering( vec3 color, vec2 uv ) {\n\n    float grid_position = rand( uv );\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n    return color + dither_shift_RGB;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse.x -= 0.5;\n    mouse.x *= iResolution.x / iResolution.y;\n    mouse.x += 0.5;    \n    \n    uv.x -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x += 0.5;\n    \n    vec4 noise = texture( iChannel0, ( fragCoord / iResolution.xy ) * 0.1 );\n    \n    vec3 col = vec3( sDot( uv, vec2(mouse.x, mouse.y), noise.r, mouse ) );       \n    \n    col += vec3( sDot( uv, vec2(cos( iTime * 0.6 ) * 0.5 + 0.5, 0.5), noise.r, mouse ) );\n    col += vec3( sDot( uv, vec2(0.5, 0.1), noise.r, mouse ) );\n    col += vec3( sDot( uv, vec2(0.5, cos( iTime * 0.6 ) * 0.5 + 0.5), noise.r, mouse ) );\n    \n    vec3 bgGrad = mix( vec3(33.,67.,101.) / 255.0, vec3(4.0, 5.0 ,7.0) / 255.0, uv.y );\n    \n    vec3 blobColors = mix( vec3(1.0, 0.0, 0.8), vec3(1.0, 1.0, 1.0), sin( iTime * 0.8 ) * 0.5 + 0.5 );\n    \n    vec3 composition = mix( bgGrad, blobColors, col.r );\n       \n    fragColor = vec4( dithering( composition, uv ), 1.0 );\n    \n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dt3W4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 63, 63, 417], [419, 419, 441, 441, 548], [550, 550, 589, 589, 841], [843, 843, 900, 900, 1923]]}
{"id": "7dt3WH", "name": "Silence of the Lambs", "author": "dean_the_coder", "description": "Hannibal Lecter's cell from the 'Silence of the Lambs' movie.", "tags": ["3d", "raymarching", "voronoi", "rock", "dungeon", "horror", "movie", "cineshader"], "likes": 31, "viewed": 1083, "date": "1629804106", "time_retrieved": "2024-06-20T20:46:32.665088", "image_code": "// 'Silence of the Lambs' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/7dt3WH (YouTube: https://youtu.be/DkaaJbfpNxE)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Hannibal Lecter's cell from the 'Silence of the Lambs' movie.\n// I wish my GPU has enough power to render some posters and drawings\n// on the cell wall! Probably quite doable if I used multiple buffers,\n// but I always try to make my code single-buffer with no predefined\n// textures.\n//\n// Tricks to ('try and'!) get the performance:\n// - The stone walls are flat planes, and the material is bump-mapped.\n//   Adding texture by adjusting the SDF would look nice, but increase\n//   the number of steps in the march loop.\n//   (I use dFdx and dFdy to approximate the normal of the texture.)\n// - The material code (lights()) is called _outside_ the raymarch loop\n//   to keep the loop code minimal (should the compiler decide to unroll it).\n// - The glass is a flat plane, so the normal passed into 'reflect()'\n//   can be hard-coded.\n// - The FBM noise function is only called once in lights(), and then used\n//   by several materials.\n// - Lots of use of abs() to mirror along axis.\n//   (There's only one 'actual' prison cell - The other is mirrored.)\n// - Use of fract() on the x-axis to repeat the holes in the glass.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// Blackle, totetmatt, byt3_m3chanic, and a bunch of others for sharing\n// their time and knowledge! If you want to get into shader coding, I'd\n// recommend giving them a 'Google'.\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define LIGHT_RGB\tvec3(4.9, 3.9, 3.5)\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n#define NM normalize\n#define minH(a, b)\t{ float u = a; if (u < h.x) h = vec2(u, b); }\n\nfloat g = 0.;\n\nvec2 h22(vec2 v) {\n\tvec3 p = fract(v.xyx * vec3(.1031, .103, .0973));\n\tp += dot(p, p.yzx + 33.33);\n\treturn fract((p.xx + p.yz) * p.zy);\n}\n\nvec4 h44(vec4 p) { p = fract(p * .1031); p *= p + 3.3456; return fract(p * (p + p)); }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(h44(h), h44(h + s.x), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\tfloat i,\n\t      a = 0.,\n\t      b = .5;\n\tfor (i = Z0; i < 4.; i++) {\n\t\ta += b * n31(p);\n\t\tb *= .5;\n\t\tp *= 2.;\n\t}\n\n\treturn a * .5;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat min3(vec3 v) { return min(v.x, min(v.y, v.z)); }\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0., h);\n\treturn length(p) - r;\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = NM(lookAt - ro),\n\t     r = NM(cross(vec3(0, 1, 0), f));\n\treturn NM(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvec4 brkT(vec3 p) {\n\tfloat n = n31(p * 7.),\n\t      s = step(.4, dot(vec3(n31(p), n, n31(p * 15.)), vec3(.75, .15, .1)));\n\tp.y -= .03;\n\tp.x -= step(fract(p.y * 1.87 - .05), .5) * 2.6;\n\tp.z -= .33;\n\tvec3 c = vec3(.2, .03, .01);\n\tc *= .2 + n * n * .5;\n\treturn vec4(mix(vec3(.2), c, sat(S(0., .02, min3(abs(fract(p * vec3(1, 3.74, 2.23)) - .1))) - s)), (s + n) * .01);\n}\n\nvec2 proj(vec3 p, vec3 n) {\n\tn = abs(n);\n\tfloat m = max3(n);\n\treturn n.x == m ? p.zy : n.y == m ? p.xz : p.xy;\n}\n\nfloat vor(vec2 p) {\n\tvec2 o,\n\t     g = floor(p);\n\tp -= g;\n\tvec3 d = vec3(2);\n\tfor (int y = -1; y <= 1; y++) {\n\t\tfor (int x = -1; x <= 1; x++) {\n\t\t\to = vec2(x, y);\n\t\t\to += h22(g + o) * vec2(.5, .7) - p;\n\t\t\td.z = dot(o, o);\n\t\t\td.y = max(d.x, min(d.y, d.z));\n\t\t\td.x = min(d.x, d.z);\n\t\t}\n\t}\n\n\treturn d.y - d.x;\n}\n\nvec2 map(vec3 p, bool addGlass) {\n\tfloat f, e, l,\n\t      d = 1e7;\n\tvec2 h;\n\th.x = 1e7;\n\tvec3 pp,\n\t     cp = p,\n\t     op = p;\n\tif (addGlass) {\n        minH(max(abs(p.z - 3.2), abs(p.x) - 4.), 11);\n\t} else {\n\t\tp.x = fract(p.x * 1.74) / 1.74 - .25;\n\t\tp.y = abs(p.y + .7) - 1.5;\n\t\tp.z -= 3.4;\n\t\tminH(max(abs(length(p.xy) - .06) - .0015, abs(p.z) - .03), 9);\n\t}\n\n\tp = cp;\n\tp.y += 3.5;\n\tp = p.zyx;\n\tp.xz *= rot(.2);\n\tminH(max(max(cap(p, 1., .45), abs(p.y) - .05), -p.x), 8);\n\tp.x -= .15;\n\tp.z = abs(p.z) - .5;\n\tp.xy *= rot(-.1);\n\td = max(length(p.xz) - .04, p.y - .5);\n\tp.xy *= rot(.6);\n\tp.x -= .3;\n\tminH(smin(d, max(length(p.xz) - .04, p.y - .8), .04), 3);\n\tp.z = cp.x - .03;\n\tp.xy = p.yx;\n\tminH(max(max(cap(p, .6, .45), abs(p.y) - .04), .3 - p.x), 8);\n\tp = cp;\n\tp -= vec3(9, -4.7, 5);\n\tmat2 r = rot(.36);\n\tfor (f = 0.; f < 5.; f++) {\n\t\tminH(max(box(p, vec3(2, .3, 10)), p.z - .5), 1);\n\t\td = smin(d, abs(-8.1 - p.z), 2.);\n\t\tp.xz *= r;\n\t\tp.y -= .6;\n\t}\n\n\tminH(d, 1);\n\tp = cp;\n\tp.y++;\n\td = min(box(p, vec3(90, 4, 3)), 8. - p.x);\n\tp.x = abs(p.x + 8.) - 8.;\n\tp.z -= 7.;\n\tcp = p;\n\td = -min(d, box(p, vec3(4, 4, 4.1)));\n\tminH(d, 1);\n\td = length(p - vec3(0, 4, 0)) - .2;\n\tg += .005 / (.01 + d * d);\n\tminH(d, 12);\n\tp += vec3(-2.48, 1.8, 2.4);\n\te = box(p, vec3(1.4, .02, .5));\n\tp.x = abs(p.x) - .8;\n\td = max(box(p, vec3(.05, 5, .05)), p.y);\n\tp = cp - vec3(0, .8, 3.95);\n\tminH(box(p, vec3(.5, .7, .01)), 10);\n\tminH(box(p, vec3(.6, .8, .01)), 8);\n\tp.y += 2.;\n\tl = length(p) - .8;\n\tf = min(max(max(min(min(l + .05, max(l, abs(p.x) - .2)), max(l, abs(p.y) - .1)), p.y - .1), -l - .1), max(box(p, vec3(.65, .8, .1)), -p.y - .2));\n\tminH(f, 4);\n\tp.x = abs(p.x) - .3;\n\tp.y -= .35;\n\td = min(d, length(p) - .1);\n\tp = cp + vec3(-2.48, 2.5, 1.2);\n\te = min(e, box(p, vec3(1.4, .02, .3)));\n\tp.x = abs(p.x) - .8;\n\td = min(d, max(box(p, vec3(.05, 5, .05)), p.y));\n\te -= .03;\n\tp = cp + vec3(3.7, -.5, -2);\n\te = min(e, box(p, vec3(.3, .05, 1)));\n\tp.y -= .48;\n\tp.z = abs(abs(p.z - .4) - .3) - .15;\n\tminH(box(p, vec3(.2, .4, .05)) - .03, 5);\n\tminH(d - .04, 3);\n\tminH(e, 8);\n\tp = cp;\n\tp.x += 2.8;\n\tp.y += 2.4;\n\tminH(box(p, vec3(.94, .08, 2.9)) - .1, 7);\n\tp.y += .23;\n\td = box(p, vec3(1.02, .08, 3.05));\n\tp.y += .7;\n\tp.z = abs(p.z) - 3.;\n\td = min(d, box(p, vec3(1.02, .78, .08)));\n\tp = cp;\n\tp.x = abs(abs(p.x) - 2.1) - .75;\n\tp.z += 3.8;\n\td = min(d, box(p, vec3(.1, 4, .1)));\n\tpp = p;\n\tp.y = fract(p.y) - .5;\n\tp.z += .12;\n\td = min(d, length(p) - .01);\n\tp = pp;\n\tminH(d - .04, 3);\n\td = box(cp - vec3(0, 3.5, -3.8), vec3(4, .5, .5));\n\tp.x = abs(cp.x) - 3.5;\n\tp.z = abs(p.z + 3.175) - 3.175;\n\td = min(d, box(p, vec3(.5, 4, .5)));\n\td -= brkT(op).a;\n\tminH(d, 2);\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .2;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h, false).x;\n\t}\n\n\treturn NM(n);\n}\n\nfloat shadow(vec3 p, vec3 lp) {\n\tfloat d,\n\t      s = 1.,\n\t      t = .1,\n\t      mxt = length(p - lp);\n\tvec3 ld = (lp - p) / mxt;\n\tfor (float i = Z0; i < 2e2; i++) {\n\t\td = map(t * ld + p, false).x;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.1, d);\n\t\tif (mxt - t < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\nfloat ao(vec3 p, vec3 n, float h) { return map(h * n + p, true).x / h; }\n\nvec3 lights(vec3 p, vec3 rd, float d, vec2 h) {\n\tvec4 t;\n\tfloat spe = 1.,\n\t      gg = g,\n\t      f = h.y <= 6. ? fbm(p * 7.5) : 0.;\n\tvec3 c,\n\t     ld = NM(vec3(0, 2.8, 7) - p),\n\t     n = N(p, d);\n\tif (h.y == 1.) {\n\t\tvec2 uv = proj(p, n) * vec2(1, 2);\n\t\tfloat d = S(0., .15, vor(uv) * f);\n\t\tn.xy += vec2(dFdx(d), -dFdy(d)) * 1.5;\n\t\tn = NM(n);\n\t\td += f;\n\t\tc = mix(vec3(.15, .09, .06), vec3(.04, .03, .04) + S(.4, 1., S(.6, .5, d + f) * n31(p)) * vec3(.054, .06, .04), S01(d + .4));\n\t\tspe = .3;\n\t}\n\telse if (h.y == 2.) {\n\t\tt = brkT(p);\n\t\tc = t.rgb;\n\t\tn.xy += f;\n\t\tn = NM(n);\n\t\tspe = .1;\n\t}\n\telse if (h.y == 7.) c = vec3(.01, .013, .01);\n\telse if (h.y == 10.) {\n\t\tc = vec3(.02);\n\t\tspe = 15.;\n\t}\n\telse if (h.y == 3.) c = mix(vec3(.15, .05, .01), vec3(.16, .2, .24) * (.2 + .8 * f), S(0., .15, f));\n\telse if (h.y == 8.) c = mix(vec3(.04, .02, .02), vec3(.06, .04, .02), S01(n31(p * vec3(2.3, 1, 20))));\n\telse if (h.y == 5.) c = vec3(.12, .11, 0) - f * .2;\n\telse if (h.y == 4.) c = vec3(.4, .4, .38) - f * .4;\n\telse if (h.y == 9.) c = vec3(.9);\n\telse return LIGHT_RGB;\n\n\tfloat ao = sat(mix(ao(p, n, .2), ao(p, n, 2.), .7)),\n\t      l1 = sat(.1 + .9 * dot(ld, n)) * (.05 + .95 * shadow(p, vec3(0, 2.8, 7))) * (.3 + .7 * ao),\n\t      l2 = sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .2 + pow(sat(dot(rd, reflect(ld, n))), 10.) * spe;\n\tg = gg;\n\treturn (l1 + l2 * ao) * c * LIGHT_RGB;\n}\n\nbool hitGlass;\nvec3 ghit;\nvec3 march(inout vec3 p, vec3 rd, float s) {\n\tfloat i,\n\t      d = .01;\n\tg = 0.;\n\tvec2 h;\n\tfor (i = Z0; i < s; i++) {\n\t\th = map(p, !hitGlass);\n\t\tif (abs(h.x) < .0015) {\n\t\t\tif (h.y == 11.) {\n\t\t\t\thitGlass = true;\n\t\t\t\tghit = p;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\n\t\td += h.x;\n\t\tp += h.x * rd;\n\t}\n\n\treturn g * LIGHT_RGB + lights(p, rd, d, h);\n}\n\nvec3 scene(vec3 ro, vec3 rd) {\n\thitGlass = false;\n\tvec3 p = ro,\n\t     col = march(p, rd, 120.) * exp(dot(p - ro, p - ro) * -.001);\n\tif (hitGlass) {\n\t\trd = reflect(rd, vec3(0, 0, -1));\n\t\tp = ghit;\n\t\tcol += .01 + .99 * sat(march(p, rd, 64.));\n\t}\n\n\treturn col;\n}\n\n#define rgba(col)\tvec4(pow(max(vec3(0), col), vec3(.45)) * sat(iTime), 0)\n\nvoid mainVR(out vec4 fragColor, vec2 fc, vec3 ro, vec3 rd) {\n\trd.xz *= mat2(1, 0, 0, -1);\n\tfragColor = rgba(scene(ro, rd));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tfloat t = mod(iTime, 25.),\n\t      f = S(0., 18., t);\n\tvec2 uv = (fc - .5 * R.xy) / R.y,\n\t     q = fc.xy / R.xy;\n\tvec3 ro = vec3(-23. + 22.5 * f, 0, 0),\n\t     col = scene(ro, rayDir(ro, vec3(0, mix(-1. - sat(t), 0., S(16., 20., t)), -sin(S01(f) * 5.7) * 5.), uv));\n\tcol *= .2 + .4 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\tfragColor = rgba(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dt3WH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1617, 1992, 2010, 2010, 2129], [2131, 2131, 2149, 2149, 2217], [2219, 2219, 2238, 2238, 2483], [2485, 2485, 2504, 2504, 2636], [2638, 2638, 2677, 2677, 2759], [2761, 2761, 2781, 2781, 2815], [2817, 2817, 2837, 2837, 2871], [2873, 2873, 2892, 2892, 2959], [2961, 2961, 2988, 2988, 3059], [3061, 3061, 3098, 3098, 3150], [3152, 3152, 3196, 3196, 3311], [3313, 3313, 3332, 3332, 3679], [3681, 3681, 3708, 3708, 3793], [3795, 3795, 3814, 3814, 4103], [4105, 4105, 4138, 4138, 6737], [6739, 6739, 6764, 6764, 6983], [6985, 6985, 7016, 7016, 7287], [7289, 7289, 7324, 7324, 7361], [7363, 7363, 7410, 7410, 8737], [8765, 8765, 8809, 8809, 9093], [9095, 9095, 9125, 9125, 9354], [9431, 9431, 9491, 9491, 9556], [9558, 9558, 9603, 9603, 9964]]}
{"id": "7dt3zB", "name": "Hill Pattern", "author": "TestCoder", "description": "hill pattern", "tags": ["hillpattern"], "likes": 2, "viewed": 128, "date": "1630123321", "time_retrieved": "2024-06-20T20:46:32.804570", "image_code": "float getHillPattern(float x) {\n   return -(sin(-x)+2.)*log(abs(abs(mod(x,2.)) - 1.)) / 100.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-.5;\n\n    // Time varying pixel color\n    vec3 col = (\n            getHillPattern((uv.x/uv.y+iTime/10.)*10.)\n    )*vec3(0,2,4);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dt3zB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 31, 31, 95], [97, 97, 154, 204, 428]]}
{"id": "7dt3zH", "name": "Basic Tile(1)", "author": "chenxiaoleizi", "description": "sinple pattern implement", "tags": ["pattern"], "likes": 1, "viewed": 37, "date": "1629189046", "time_retrieved": "2024-06-20T20:46:32.962196", "image_code": "// Tile the coordinates \nvec2 tile(vec2 v, float scale){\n    v *= scale;\n    return fract(v);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = tile(uv, 5.0);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dt3zH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 25, 56, 56, 99], [101, 101, 158, 208, 428]]}
{"id": "7dt3zn", "name": "Fireworks are awesome!", "author": "modog", "description": "my first shade", "tags": ["simple", "first", "fireworks"], "likes": 3, "viewed": 83, "date": "1629053770", "time_retrieved": "2024-06-20T20:46:32.962196", "image_code": "#define NUM_OF_PARTICLES 72.\n#define ANGLE_CIRCLE 6.2832\n\nvec2 Hash12(float threshold){\n    float x = fract(sin(threshold * 620.2) * 423.5);\n    float y = fract(sin(threshold * 703.2) * 207.5);\n     \n    return vec2(x, y);\n}\n\nvec2 Hash12_Polar(float threshold){\n    float angle = fract(sin(threshold * 620.2) * 423.5) * ANGLE_CIRCLE;\n    float dist = fract(sin((threshold + angle) * 703.2) * 207.5);\n     \n    return vec2(sin(angle), cos(angle)) * dist;\n}\n\nfloat Explosion(vec2 uv, float time){\n    float sparks = 0.;\n    for(float i = 0.; i < NUM_OF_PARTICLES; i++){\n        vec2 direction = Hash12_Polar(6. * i) * .5;\n\n        float brightness = mix(.0005, .002, smoothstep(.05, 0., time));\n        float dist = length(uv - direction * time);\n\n        brightness *= sin(time * 20. * i) * .5 + .5;\n        sparks += brightness / dist;\n    }\n    \n    return sparks;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    vec3 color = sin(vec3(.34, .54, .43) * floor(iTime)) * .5 + .5;\n    \n    col += Explosion(uv, fract(iTime)) * color;\n    \n    col *= 2.;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dt3zn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[58, 58, 87, 87, 224], [226, 226, 261, 261, 455], [457, 457, 494, 494, 867], [869, 869, 926, 926, 1193]]}
{"id": "7dtGRB", "name": " HexTruchet", "author": "hjd3481", "description": "Triangular grid to create some triangular Truchet tiles. leaving out the corners of the original grid leaves a hexagonal gap in the wires.\nSome kind of techy dynamic neural net thing.", "tags": ["truchet", "hex", "tiles", "electronic", "beinner"], "likes": 10, "viewed": 144, "date": "1630422297", "time_retrieved": "2024-06-20T20:46:34.022926", "image_code": "#define SIN_60 0.8660254\n\n/////////////////////////////////////////////////////////////\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n/////////////////////////////////////////////////////////////\nvec3 blob( vec2 uv, vec2 p )\n{\n    //un-skew the uv to get round dots\n    uv.x += uv.y * 0.5; //skew x to shift diagonal into triangles\n    uv.x /= SIN_60;\n    //also scale the position to get the origin to the correct place.\n    p.x /= SIN_60;\n        \n    float d = distance( uv, p );\n    \n    float r = 0.123;\n    float outer = smoothstep(r + 0.001, r - 0.001, d); //invert\n    \n    float rb = 0.066;\n    float inner = smoothstep(rb - 0.001, rb + 0.001, d); \n    \n    \n    float glow = smoothstep(rb+0.3, rb, d);  //invert\n    \n    return vec3(outer,inner, glow);\n}\n/////////////////////////////////////////////////////////////\nvec3 pulse( float falloff, vec3 rnd )\n{\n    //vec3 colA = vec3(0.4,0.01,0.0);\n    //vec3 colB = vec3(1.0,0.7,0.0);\n    \n    vec3 colA = vec3(0.1,0.01,0.5);\n    vec3 colB = vec3(0.4,0.45,1.0);\n    \n    float v = abs(sin(((iTime*(1.0+rnd.z))+rnd.x) * (rnd.y+0.1) * 5.0));\n    vec3 col = mix( colA, colB, vec3(v*v*v));\n    \n    return col * pow( falloff, mix(7.0,3.0,v));\n    \n}\n/////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.y; //y-fov\n    vec2 uv = fragCoord/iResolution.x; //x-fov\n\n     // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    //offset zoom centre\n    uv -= 0.5;    \n     \n    //sacle (zoom)\n    float tilesY = mix(10.0, 14.0, sin(iTime*0.1)*0.5+0.5); //zoom in and out\n    uv *= tilesY;\n    \n    //pan the image \n    uv += vec2(0.45233 * iTime, sin(iTime*-0.1250235) * 1.41 );    \n   \n        \n    //squares -> euqlaterial triangles\n    uv.x *= SIN_60; //scale to get equalateral. mul by sin60 to get h == 1/2a (equalaterial triangle corner = 60deg)\n    uv.x -= uv.y * 0.5; //skew x to shift diagonal into triangles\n    \n    vec2 id = floor(uv.xy);\n    \n    vec2 idRightB = id + vec2(1.0, 0.0);\n\n    vec2 idBottomA = id + vec2(0.0, -1.0);   \n    \n    \n    \n    uv = fract(uv);\n    \n    //get diagonal of the skewed grid to get a triangular chequer pattern.\n    float sn = sign( (uv.x+uv.y)-1.0f );\n    \n    uv = mix(uv, vec2(1)-uv, sn*0.5+0.5); //flip UV in top right triangle\n        \n    //convert the grid-id to a triangle-id\n    \n    float daigonalHashOffset = 1.7133453;\n    \n    vec2 idSign = id + ((-sn)*daigonalHashOffset);\n    id += sn*daigonalHashOffset; //add some offset based on the chequer/sign \n    \n    idRightB += (-sn)*daigonalHashOffset; //flipping the sign gets us the upper-right triangle in the un-skewed cell.\n    idBottomA += (-sn)*daigonalHashOffset; \n    \n    vec3 rnd = hash32(id); //get a noise per triangle\n       \n    \n    float dots = 0.0;\n    \n    //Draw edges between triangles randomly\n    int numEdges = 0;\n    \n    vec3 rndEdges = fract(rnd + (floor(iTime)*vec3(0.2,0.1,0.3)) ); //step-tick the random values by adding a \n    \n    if(rndEdges.x < 0.5)\n    {\n        dots += smoothstep( 0.05, 0.04, abs(uv.x - 0.5));\n        ++numEdges;\n    }\n  \n    if(rndEdges.y < 0.5)\n    {\n        dots += smoothstep( 0.05, 0.04, abs(uv.y - 0.5));\n        ++numEdges;\n    }\n    \n    if( rndEdges.z < 0.5 && numEdges < 2 /*|| numEdges==0*/ )\n    {\n        dots += smoothstep( 0.05, 0.04, abs((uv.x+uv.y) - 0.5));\n    }\n    \n    //Draw rings around the edge-centres between trianges, between the solid edges above\n    vec3 dotA = blob(uv, vec2(0.5,0.0));\n    vec3 dotB = blob(uv, vec2(0.25,0.5));\n    vec3 dotC = blob(uv, vec2(0.75,0.5));\n    \n    float dotsMask = 1.0;\n    \n    dots += dotA.x;\n    dotsMask *= dotA.y;\n    \n    dots += dotB.x;\n    dotsMask *= dotB.y;\n    \n    dots += dotC.x;\n    dotsMask *= dotC.y;\n      \n    //cut out the ring centres\n        \n     \n    //draw backgound       \n    //random dark gray triangle bg\n    col = vec3((sin((iTime*rnd.z+rnd.x)*5.)+1.0)*0.05); \n    \n    //draw wires\n    //colour a bit like copper traces\n    vec3 wiresCol = vec3( 0.8,0.6,0.4 );\n    col = mix( col, wiresCol ,clamp(dots,0.0,1.0) );\n    \n    col *= dotsMask; //mask out holes to black again (ingore bg)\n    \n    //draw glow \n    \n    //get the same random values from neighbouring triangles so the blobs on the edges match up\n    vec3 rndA = hash32(idBottomA); \n    if(sn >= 0.0)\n    {\n        rndA = hash32(id);\n    }\n    \n    vec3 rndB = hash32(id); \n    if(sn >= 0.0)\n    {\n        rndB = hash32(idRightB);\n    }\n    \n    vec3 rndC = hash32(idSign);\n    if(sn >= 0.0)\n    {\n        rndC = hash32(id);\n    }\n\n    col += pulse(dotA.z,rndA); \n    col += pulse(dotB.z,rndB); \n    col += pulse(dotC.z,rndC); \n    \n        \n    //visualise random triangle\n    //col += rnd*0.25;\n    \n    //visualize uvs\n    //col.rg += uv * 0.5;\n    \n       \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dtGRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[26, 214, 236, 236, 353], [355, 355, 376, 376, 512], [514, 576, 606, 645, 1144], [1145, 1207, 1246, 1321, 1582], [1583, 1645, 1702, 1801, 5317]]}
{"id": "7dtGzN", "name": "Persian rug patterns 2", "author": "jarble", "description": "These rug-like patterns are generated using triangle waves with a pseudorandom hash function.", "tags": ["fractal", "rug"], "likes": 6, "viewed": 129, "date": "1629317242", "time_retrieved": "2024-06-20T20:46:34.465267", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 12.0;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float t2 = floor((iTime)/10.0+uv.x);\n\n    for(int c=0;c<3;c++){\n        float t3 = t2 + float(c);\n        float scale = c1.z;\n        float scale1 = 1.0;\n        vec3 random1 = hash31(t3)*10.;\n        //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n        vec3 random3 = (hash31(2.+t3)-vec3(.5))/4.;\n        vec3 random4 = (hash31(3.+t3)-vec3(.5))/4.;\n    \n        float offset = .16+random4.z*.04;\n        float scale2 = 1.16+.04*random4.y;\n        for(int i=0;i<3;i++)\n        {\n            uv = triangle_wave(uv+offset,scale)+triangle_wave(uv.yx,scale);\n            //uv.x *= -1.0;\n\n            uv = triangle_wave(uv+random1.x,scale+random3.z);\n            //uv.x /= -1.0;\n            \n            uv = triangle_wave(uv+random1.y,scale+random3.y);\n            //uv.x *= -1.0;\n \n            uv = triangle_wave(uv+random1.z,scale+random3.z);\n            uv.x /= -1.;\n            \n            //uv.x *= -1.0;\n            //uv = triangle_wave(uv+c1.y,scale);\n            scale /= scale2+col.x;\n            offset *= scale2/(1.+random4.x);\n            \n            //uv = uv.yx;\n            //uv = uv.yx;\n            scale2 += col.x/2.;\n            random1 = random3+hash31(col.x/4.)/4.;\n            random3 = random4+hash31(col.y/4.)/4.;\n            random4 = random1+hash31(col.z/4.)/4.;\n\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dtGzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[277, 387, 409, 455, 588], [591, 591, 630, 630, 675], [677, 677, 734, 734, 2320]]}
{"id": "7l2SWV", "name": "Simple Music Pan", "author": "YUIT", "description": "A simple music visualizer", "tags": ["musicvisual"], "likes": 3, "viewed": 63, "date": "1628701301", "time_retrieved": "2024-06-20T20:46:34.465267", "image_code": "#define PI 3.141592654\n\n// From https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// From https://www.shadertoy.com/view/XdXGW8\nvec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n#if 0\n\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));\n    \n#else\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;\n#endif                              \n}\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fBM(in vec2 p)\n{\n    float f;\n    vec2 uv = p;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    return f*0.5+0.5;\n}\n\n\nfloat sdSphere(in vec2 p, float r)\n{\n    return length(p) - r;\n}\n\n// from https://www.shadertoy.com/view/wdyXzy\nvec2 opRepAng( in vec2 p, float theta, float offset)\n{\n    float a = atan(p.y, p.x) - offset;\n    a = mod(a + .5 * theta, theta) - .5 * theta;\n    return length(p) * vec2(cos(a), sin(a));\n}\n\n// From iq\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 backCol = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec2 p = uv - vec2(0.85, 0.5);\n    float circle = 1.0 - smoothstep(0.0, 0.2, sdSphere(p*(2.-0.55*noise(p*5.50 + vec2(iTime*1.5))), 0.35));\n    float circle1 = 1.0 - smoothstep(0.1, 1.0, sdSphere(p*(2.33-1.9*noise(p*10.50 + vec2(iTime, iTime*2.))), 0.2));\n\n    p = opRepAng(p, 2.*PI / 20., PI*0.5);\n    float len = 0.4;\n    float offset = 0.02 * sin(iTime * 10.0) * 5.02*(circle1 - circle);\n    float val = smoothstep(0.01, 0.015, sdSegment(p*1.5, vec2(len*0.9 - offset, 0.0), vec2(len + offset, 0.0)));\n    float addVal = mix(0.21, 13., sdSegment(p*1.5, vec2(len*0.9 - offset, 0.0), vec2(len + offset, 0.0)));\n    vec3 addValCol = clamp(0.,1.,1.0-addVal)*vec3(0.3,0.5,0.99);\n    vec3 baseValCol = vec3(0.4,0.8,0.88)*(1.0-val);\n    vec3 col = vec3(addValCol+baseValCol);\n    \n    col = mix(col, backCol + col, col.x);\n    // vec3 col = vec3(circle1 - circle);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7l2SWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[24, 70, 92, 92, 209], [211, 257, 334, 388, 868], [870, 870, 896, 896, 1337], [1339, 1339, 1361, 1361, 1619], [1622, 1622, 1658, 1658, 1686], [1688, 1734, 1788, 1788, 1923], [1925, 1936, 1988, 1988, 2107], [2109, 2109, 2166, 2216, 3259]]}
{"id": "7l2Szt", "name": "mt audio visualizer", "author": "momie", "description": "my third audio visualizer", "tags": ["audio"], "likes": 2, "viewed": 51, "date": "1628422681", "time_retrieved": "2024-06-20T20:46:34.465267", "image_code": "float PI = 3.14;\n\nvec4 nami_nami(vec2 uv){\n    float theta = mod( (atan(uv.y,uv.x)+PI)/(2.*PI), .3);\n    vec4 spect = texture(iChannel0, vec2(theta,0.0));\n    vec4 spect_low = texture(iChannel0, vec2(0.2,0.0));\n    float f = floor((iTime/4.)*spect_low.x*2.);\n    vec4 nami_theta = vec4((sin(f*atan(uv.y,uv.x) + iTime + 5.*spect.x)));\n    vec4 nami_r = vec4(sin(2.*length(uv)*2.*PI + iTime*2. + 3.*spect.x));\n    return .01/mix(nami_theta, nami_r, .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy -.5;\n    uv.x *= (iResolution.x / iResolution.y);\n    fragColor = nami_nami(uv);\n}", "image_inputs": [{"id": "XsXGzn", "previewfilepath": "/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7l2Szt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[18, 18, 42, 42, 453], [455, 455, 512, 512, 634]]}
{"id": "7l2Xzt", "name": "Box (Max Norm Distance)", "author": "TheTurk", "description": "Maximum norm distance function for a box.", "tags": ["3d", "distancefield", "sdf", "distance", "box", "primitive", "linfinity", "maximumnorm"], "likes": 1, "viewed": 49, "date": "1628429038", "time_retrieved": "2024-06-20T20:46:34.659323", "image_code": "float box(vec3 position, vec3 halfSize) {\n    position = abs(position) - halfSize;\n    return max(max(position.x, position.y), position.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = fragCoord / iResolution.xy;\n    position = (position * 2.0) - 1.0;\n    position.x *= iResolution.x / iResolution.y;\n    \n    vec2 mousePosition = iMouse.xy / iResolution.xy;\n    mousePosition = (mousePosition * 2.0) - 1.0;\n    mousePosition.x *= iResolution.x / iResolution.y;\n    \n    float z = (-1.0 + fract(iTime * 0.2) * 2.0) * 0.7;\n       \n    vec3 halfSize = vec3(0.5);\n    float d = box(vec3(position, z), halfSize);\n\n    // same colorization that Inigo Quilez uses in his shaders\n    vec3 color = vec3(1.0, 0.9, 1.0) + sign(d) * vec3(-0.3, 0.4, 0.3); // base color\n    color *= 1.0 - exp(-3.0 * abs(d)); // gradient\n\tcolor *= 0.8 + 0.2 * cos(180.0 * d); // ripples\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d))); // outline\n    fragColor = vec4(color, 1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7l2Xzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 41, 41, 141], [143, 143, 198, 198, 1007]]}
{"id": "7lBGDt", "name": "3D balls fuse", "author": "TFoucour", "description": "3D balls fuse", "tags": ["3dballsfuse"], "likes": 1, "viewed": 61, "date": "1628598340", "time_retrieved": "2024-06-20T20:46:35.247028", "image_code": "float sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nvec3 hash( vec3 p ) // replace this by something better. really. do\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// returns 3D value noise\nfloat noise( vec3 x )\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    \n    // gradients\n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    return va + \n           u.x*(vb-va) + \n           u.y*(vc-va) + \n           u.z*(ve-va) + \n           u.x*u.y*(va-vb-vc+vd) + \n           u.y*u.z*(va-vc-ve+vg) + \n           u.z*u.x*(va-vb-ve+vf) + \n           u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}\n\nfloat map(vec3 p){\n    float noise = noise(p*5.);\n    float d = sphere(p+vec3(0., sin(iTime), -2.), 1.3);\n    d = min(d, p.y+1.);\n    //d = cos(d)*sin(d)*.4;\n    return d+noise*.2;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ));\n}\n\nvec3 trace( vec3 ro, vec3 rd) {\n\n    vec3 p = ro;\n    for(int i=0; i <255; i++){\n        p += rd * map(p); \n    }\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0., 0., -1.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    vec3 p = trace(ro, rd);\n    \n    vec3 color = vec3(.5,.3,.0);\n    \n    \n    vec3 normal = calcNormal(p);\n    vec3 soleil_direction = normalize(vec3(0.25, 1., 0.5));\n    \n\n    // Time varying pixel color\n    vec3 col = vec3(1.) * max( dot(normal,soleil_direction), 0.); \n    col = clamp(col, vec3(0.), vec3(1.));\n    col = mix(col, vec3(1.), min(distance(p,ro)*0.1, 1.));\n    \n    //col += vec3(.6, .5, .3);\n\n\n    vec3 pshadow = trace(p+normal*.1, soleil_direction);\n    if (map(pshadow) < 1.)\n        col *= 0.25;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7lBGDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 33, 33, 57], [59, 59, 128, 128, 297], [299, 325, 348, 360, 1526], [1528, 1528, 1546, 1546, 1710], [1712, 1712, 1744, 1744, 1944], [1946, 1946, 1977, 1977, 2075], [2077, 2077, 2134, 2184, 2941]]}
{"id": "7lBSDw", "name": "Morphing Prototype Shader", "author": "NotTofuFood", "description": "A shader I made for a game jam.", "tags": ["2d", "sdf", "morph", "combine"], "likes": 2, "viewed": 46, "date": "1627787330", "time_retrieved": "2024-06-20T20:46:35.247028", "image_code": "#define BG_C vec4(0.6,0.8,0.9,1.)\n\n//SDF from https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return sign(k)*length(max(w,0.0)) + r;\n}\n\n// Smooth Union Function from https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n// Simplex 2D noise\n// GLSL Function from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = 2.*(gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\n    vec2 camera_pos = uv;\n    \n    float cube = sdBox(camera_pos + vec2(0., cos(iTime)*.2), vec2(.5));\n    float cube_subtract = sdBox(camera_pos + vec2(0., cos(iTime)*.2), vec2(.6));\n    \n    float sphere = sdCircle(camera_pos+vec2(.5,.0) - vec2(cos(iTime)*.2), .3) ;\n    float sphere_subtract = sdCircle(camera_pos+vec2(.5,.0) - vec2(cos(iTime)*.2), .33);\n\n    float final_cube = opSubtraction(cube * snoise(uv + iTime*.3), cube_subtract);\n    \n    float final_sphere = opSubtraction(sphere, sphere_subtract);\n\n    float depth = opSmoothUnion(final_cube, final_sphere, .1);\n\n    vec3 color = vec3(1.0) - sign(depth);\n    \n    if(depth <= 0.01) {\n        fragColor = vec4(color,1.0);\n    } else {\n        fragColor = BG_C;\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7lBSDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[35, 119, 156, 156, 236], [238, 238, 280, 280, 306], [308, 308, 357, 357, 542], [544, 647, 690, 690, 712], [714, 714, 766, 766, 865], [867, 975, 997, 997, 1036], [1038, 1038, 1059, 1059, 1879], [1881, 1881, 1938, 1938, 2749]]}
{"id": "7lBXDm", "name": "Sound lines by liner", "author": "Liners", "description": "Music line reacting on sound ", "tags": ["soundlines", "musicline"], "likes": 2, "viewed": 84, "date": "1627824182", "time_retrieved": "2024-06-20T20:46:35.247028", "image_code": "void mainImage( out vec4 O, in vec2 I ) {\n    //obj\n    vec2 uv = (I/iResolution.xy);\n    float r = length(uv);    \n    float dx = 1./iResolution.x;\n    int tx = int(uv.y);\n    float react = texelFetch( iChannel0, ivec2(tx,0), 0 ).x*0.05;\n    \n    float v = texture(iChannel0, vec2(uv.x, 1.)).r;\n    float vp = texture(iChannel0, vec2(uv.x+dx, 1.)).r;\n    \n    vec2 p  = vec2(uv.y, v );\n    vec2 pp = vec2(uv.y+dx, vp );    \n    vec2 np = normalize(pp-p);\n    \n    //col\n    \n    float d = max(abs(np.x)-react * 0.5, abs(np.x)*react/0.25)*0.8 * react + .01;\n    \n    float k = mix(1.,0., (abs(uv.y-.5)*iResolution.y*5.01*v) * d);\n    \n    vec3 c = vec3(k + cos(iTime+uv.xyx+vec3(0,2,4)));\n\n    O += vec4(c * .5 + react * (10. + c), 1.0);\n}\n\n//---------------------------------------  NAME OF THE MUSIC    Dream space - dvrst  ---------------------------------------//\n", "image_inputs": [{"id": "XlfXDj", "previewfilepath": "https://soundcloud.com/wazmusic/dream-space", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/wazmusic/dream-space", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7lBXDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 41, 51, 739]]}
{"id": "7lBXWR", "name": "Hexagonal spiral", "author": "felipetovarhenao", "description": "Reflecting hexagonal spiral, using shapers, modular distortion, and value quantization.", "tags": ["spiral", "sdfs"], "likes": 2, "viewed": 53, "date": "1628273397", "time_retrieved": "2024-06-20T20:46:35.768360", "image_code": "/*\n    Author: Felipe Tovar-Henao [www.felipe-tovar-henao.com]\n    Description: Reflecting hexagonal spiral, using shapers, modular distortion, and value quantization.\n*/\n\n#define PI 3.14159265359\n#define u_time iTime\n#define u_resolution iResolution\n\nfloat quantize(in float x, in float d) {\n    return floor(x/d)*d;\n}\n\nfloat fold(in float x) {\n    return abs(mod(x+1.0,2.0)-1.0);\n}\n\nvec2 rotate2D(in vec2 vUV, in float theta) {\n    vec2 r = vec2(cos(theta), sin(theta));\n    return vUV * mat2(r.x, -r.y, r.y, r.x);\n}\n\nfloat relu_ramp(in float x, in float s) {\n    return floor(x) + clamp((max(1.0, s)*(fract(x) - 0.5)) + 0.5, 0.0, 1.0);\n}\n\nfloat cosine_ramp(in float x, in float s) {\n    float y = cos(fract(x)*3.14159265359);\n    return floor(x) + 0.5 - (0.5*pow(abs(y), 1.0/s)*sign(y));\n}\n\nfloat sine_ramp(in float x, in float s) {\n    float y = fract(x);\n    float h = abs(0.5 - (0.5/max(1.0, s*s)));\n    return floor(x) + y + h*sin(6.28318530718*y);\n}\n\nfloat bump_ramp(in float x, in float s) {\n    float y = fract(x);\n    return floor(x) + pow(y, exp(s*y));\n}\n\nfloat polygonSDF(in vec2 vUV, in int V) {\n    float N = max(1.0, float(V));\n    float rot = floor(N*(atan(-vUV.x,-vUV.y) / 6.28318530718 + 0.5));\n    float offset = 3.14159265359*(N+2.0)/(2.0*N);\n    float theta = (6.28318530718/N) * rot + offset;\n    float side = tan(3.14159265359/max(N, 3.0));\n    vUV *= mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n    float scl = 0.5 * (float(N==2.0)*(0.25/sqrt(3.0)) + step(2.0,N)) / (step(1.0,N) + step(N, 2.0));\n    vec2 r = vec2(step(3.0, N), side) * scl;\n    vec2 P = abs(vUV)-r;\n    return length(max(vec2(0.0), P)) + min(0.0, max(P.x, P.y/side));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUV = fragCoord.xy / u_resolution.xy;\n    vUV -= 0.5;\n    vUV.x *= u_resolution.x / u_resolution.y;\n\n    float r = polygonSDF(vUV * 1.5, 6)*20.0;\n    float res = fold(bump_ramp(u_time*0.1, 5.0)) / 1500.0;\n    float a = atan(vUV.x, vUV.y) / PI + (u_time*r*res);\n    float theta = relu_ramp((r + a - sine_ramp(u_time*0.1, 1.7)), 8.0);\n\n    vUV = rotate2D(vUV, quantize(fold(theta), 1.0) + u_time * 0.025);\n\n    float t = cosine_ramp(u_time*0.23, 1.5) + sine_ramp(-u_time*0.12, 4.0);\n\n    float vx = fold(fract(vUV.x+vUV.y - t*0.013));\n    float vy = fold(fract(vUV.y-vUV.x + t*0.023));\n\n    float qx = fract(vUV.x*3.13 + t*0.131);\n    float qy = fract(vUV.y*2.329 - t*0.151);\n    float lim = 0.1;\n    float mx = fold(quantize(vx, max(lim, qx) + lim));\n    float my = fold(quantize(vy, max(lim, qy) + lim));\n    float x = mod(vx, mx);\n    float y = mod(vy, my);\n\n    vec3 color = vec3(0.0);\n\n    float c = abs(fold(x*y*2.0));\n    c = quantize(sqrt(c), 0.2) * fold(quantize(theta+a, 0.125));\n\n    vec3 c1a = vec3(0.502, 0.4863, 0.4118) * sin(sine_ramp(u_time*0.25, 4.0))*0.5 + 0.5;\n    vec3 c1b = vec3(0.302, 0.4549, 0.5333);\n    vec3 c2a = vec3(0.102, 0.0863, 0.0863);\n    vec3 c2b = vec3(0.1412, 0.1725, 0.1882);\n\n    color += clamp(c, 0.0, 1.0) * mix(c1a, c1b, fold(theta*3.0));\n    vec3 shadow= clamp(1.0-color, 0.0, 1.0) * mix(c2a, c2b, fold(theta*4.32));\n    color = clamp(color-shadow, 0.0, 1.0) + shadow + color;\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7lBXWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 252, 292, 292, 319], [321, 321, 345, 345, 383], [385, 385, 429, 429, 518], [520, 520, 561, 561, 640], [642, 642, 685, 685, 792], [794, 794, 835, 835, 957], [959, 959, 1000, 1000, 1066], [1068, 1068, 1109, 1109, 1672], [1674, 1674, 1731, 1731, 3198]]}
{"id": "7lBXzV", "name": "Ellipsoid (Max Norm Distance)", "author": "TheTurk", "description": "Maximum norm distance function for an ellipsoid.", "tags": ["distancefield", "sdf", "sphere", "circle", "distance", "ellipsoid", "ellipse", "linfinity", "maximumnorm"], "likes": 1, "viewed": 59, "date": "1628078851", "time_retrieved": "2024-06-20T20:46:36.326139", "image_code": "/* \nTo compute the maximum norm distance between a point p and a \nprimitive we need to find the size of the smallest \naxis-aligned cube (compared to the size of the smallest \nsphere under Euclidian norm) centered at p that touches the \nsurface of the primitive. There are usually three cases that \nneed to be handled depending on whether the point that \ntouches the surface of the primitive lies on a corner, edge \nor face of the cube.\n*/\n\nfloat ellipse(vec2 position, vec2 radius) {\n    position = abs(position);\n    float d = max(abs(position.x - radius.x), position.y);\n    d = min(d, max(position.x, abs(position.y - radius.y)));\n    float a = dot(vec2(1.0), 1.0 / (radius * radius));\n    float b = dot(vec2(1.0), position / (radius * radius));\n    float c = dot(vec2(1.0), (position * position) / (radius * radius)) - 1.0;\n    float discriminant = b * b - a * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / a;\n        d = min(t, d);\n    }\n    return d;\n}\n\nfloat ellipsoid(vec3 position, vec3 radius) {\n    position = abs(position);\n\n    // closest point lies on cube face\n    float d = max(max(abs(position.x - radius.x), position.y), position.z);\n    d = min(d, max(max(position.x, abs(position.y - radius.y)), position.z));\n    d = min(d, max(max(position.x, position.y), abs(position.z - radius.z)));\n      \n    // closest point lies on cube edge\n    {\n        float a = dot(vec2(1.0), 1.0 / (radius.yz * radius.yz));\n        float b = dot(vec2(1.0), position.yz / (radius.yz * radius.yz));\n        float c = dot(vec2(1.0), (position.yz * position.yz) / (radius.yz * radius.yz)) - 1.0;\n        float discriminant = b * b - a * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / a;\n            d = min(d, max(t, position.x));\n        }\n    }\n    \n    // closest point lies on cube edge\n    {\n        float a = dot(vec2(1.0), 1.0 / (radius.xz * radius.xz));\n        float b = dot(vec2(1.0), position.xz / (radius.xz * radius.xz));\n        float c = dot(vec2(1.0), (position.xz * position.xz) / (radius.xz * radius.xz)) - 1.0;\n        float discriminant = b * b - a * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / a;\n            d = min(d, max(t, position.y));\n       }\n    }\n    \n    // closest point lies on cube edge\n    {\n        float a = dot(vec2(1.0), 1.0 / (radius.xy * radius.xy));\n        float b = dot(vec2(1.0), position.xy / (radius.xy * radius.xy));\n        float c = dot(vec2(1.0), (position.xy * position.xy) / (radius.xy * radius.xy)) - 1.0;\n        float discriminant = b * b - a * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / a;\n            d = min(d, max(t, position.z));\n        }\n    }\n\n    // closest point lies on cube corner\n    float a = dot(vec3(1.0), 1.0 / (radius * radius));\n    float b = dot(vec3(1.0), position / (radius * radius));\n    float c = dot(vec3(1.0), (position * position) / (radius * radius)) - 1.0;\n    float discriminant = b * b - a * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / a;\n        d = min(d, t);\n    }\n    \n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = fragCoord / iResolution.xy;\n    position = (position * 2.0) - 1.0;\n    position.x *= iResolution.x / iResolution.y;\n    \n    vec2 mousePosition = iMouse.xy / iResolution.xy;\n    mousePosition = (mousePosition * 2.0) - 1.0;\n    mousePosition.x *= iResolution.x / iResolution.y;\n      \n    float z = (-1.0 + fract(iTime * 0.2) * 2.0) * 0.6;\n\n    // float d = ellipse(position, vec2(0.75, 0.5));\n    vec3 radius = vec3(0.75, 0.5, 0.5);\n    float d = ellipsoid(vec3(position, z), radius);\n\n    // same colorization that Inigo Quilez uses in his shaders\n    vec3 color = vec3(1.0, 0.9, 1.0) + sign(d) * vec3(-0.3, 0.4, 0.3); // base color\n    color *= 1.0 - exp(-3.0 * abs(d)); // gradient\n\tcolor *= 0.8 + 0.2 * cos(180.0 * d); // ripples\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d))); // outline\n    fragColor = vec4(color, 1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7lBXzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 440, 483, 483, 991], [993, 993, 1038, 1038, 3168], [3170, 3170, 3225, 3225, 4095]]}
{"id": "7lfSRH", "name": "Nuit éclairée", "author": "TFoucour", "description": "2D nuit éclairée", "tags": ["nuitclaire"], "likes": 1, "viewed": 45, "date": "1628598415", "time_retrieved": "2024-06-20T20:46:36.326139", "image_code": "float random (in vec2 st) {\n    return fract(sin(dot(st.xy,vec2(23.4325,67.233)))*54634.545422);\n}\n\nfloat noise2D (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nfloat fbm ( vec2 st, int octaves) {\n    // Initial values\n    float value = 0.;\n    float amplitude = .4;\n\n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * noise2D(st);\n        st *= 4.;\n        amplitude *= .6;\n    }\n    return value*1.3;\n}\n\nfloat moon(vec2 uv, float r){\n    vec2 pos = uv - vec2(5., 8.);\n    pos.x += sin(iTime/50.)*5.;\n    \n    float delta = sin(iTime/1.)*.08+0.45;\n    return 1.-smoothstep(r,r+delta,dot(pos, pos));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv*=10.;\n    \n    float n = fbm(uv, 7);\n    \n    vec3 col = vec3(n);\n\n    for(int i = 0; i < 3; i++){\n        n *= fbm(uv+vec2(.2*iTime), 9);\n    }\n    \n    vec3 starColor = smoothstep(0.89, 0.94, texture(iChannel0, uv).rrr);\n    float star = starColor.x;\n    if(star < 0.8){\n    \tstar = 0.;   \n    }\n    \n    col += vec3(star)*3.*abs(sin(iTime));\n    \n    col += vec3(moon(uv, .1))*6.;\n    \n    col *= n;\n    \n    col *= vec3(.4, .5, .8);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7lfSRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 27, 27, 98], [100, 100, 125, 125, 505], [508, 508, 543, 565, 792], [794, 794, 823, 823, 989], [992, 992, 1049, 1099, 1641]]}
{"id": "7ljXDG", "name": "Valentine's Day EKG Waves", "author": "jhorowitz1996", "description": "EKG waves\n\noriginally forked from \"Day 2: Heart Monitor\": https://www.shadertoy.com/view/wd2cRV", "tags": ["waves"], "likes": 3, "viewed": 65, "date": "1628544154", "time_retrieved": "2024-06-20T20:46:36.635167", "image_code": "vec3 foreg= vec3(1.,.25,.55);//pink\nvec3 backg= vec3(0.1,0.25,.9);//water blue\n\nconst float rate = .2;//advance\nconst float speed = .3;//retract\nconst float repeats = 6.;\nconst float verticalduplicate= 11.;\nfloat thickness = 0.09;\nfloat fade= 1.5;\nfloat height= 2.;\n\nfloat rand(float x){ return fract(sin(x*1234.4321)*4321.1234);}//classic\n\nfloat shape(float x){\n    x= fract(x);\n    \n    float s1 = 0.15;      // flat\n    float s2 = s1 + 0.2;  // b1\n    float s3 = s2 + 0.34; // flat\n    float s4 = s3 + 0.1;  // b2\n    float s5 = s4 + 0.03; // flat\n    float s6 = s5 + 0.2;  // b3\n    \n    if (x < s1)  return 0.00;    \n    if (x < s2)  return 0.05 - 0.05*cos((x-s1)*30.0);\n    if (x < s3)  return 0.00;\n    if (x < s4)  return 0.02 - 0.02*cos((x-s3)*60.0);\n    if (x < s5)  return 0.0 ;\n    if (x < s6)  return 0.3*sin((x-s5)*35.0);\n    if (x > 1.0) return -.4;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv= (2.*fragCoord.xy+iResolution.xy)/iResolution.x;\n\n    float offset= speed*iTime;\n    float rate=  rate*(rand(floor(uv.y*repeats*2.))+1.);//random speed per row\n\n    float x= fract(rate*iTime)+offset;\n    uv.x+= offset;\n    vec2 headPos = vec2(   x, shape(x   *repeats)*height);\n    vec2 linePos = vec2(uv.x, shape(uv.x*repeats)*height);\n\n    uv.y= fract(uv.y*verticalduplicate)*2.-1.;//repeat vertical\n    \n    fragColor = vec4(sqrt(\n        mix(backg,foreg,\n            abs(uv.y-linePos.y)>thickness ?\n                0.:\n                pow( fract(linePos.x-headPos.x), fade)\n        )),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7ljXDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[102, 267, 287, 287, 330], [330, 341, 362, 362, 866], [867, 867, 924, 924, 1533]]}
{"id": "7lSSRG", "name": "Plane (Max Norm Distance)", "author": "TheTurk", "description": "Maximum norm distance function for a plane.", "tags": ["distancefield", "sdf", "distance", "plane", "linfinity", "maximumnorm"], "likes": 3, "viewed": 40, "date": "1627909888", "time_retrieved": "2024-06-20T20:46:36.901879", "image_code": "/* \nTo compute the maximum norm distance between a point p and a \nprimitive we need to find the size of the smallest \naxis-aligned cube (compared to the size of the smallest \nsphere under Euclidian norm) centered at p that touches the \nsurface of the primitive. There are usually three cases that \nneed to be handled depending on whether the point that \ntouches the surface of the primitive lies on a corner, edge \nor face of the cube. In the case of a plane the point \nclosest to the primitive always lies on a corner of the \ncube. \n*/\n\nfloat plane(vec3 position, vec3 planeNormal, float planeDistance) {\n    float d = dot(position, planeNormal) + planeDistance;\n    return d / dot(planeNormal, sign(planeNormal));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = fragCoord / iResolution.xy;\n    position = (position * 2.0) - 1.0;\n    position.x *= iResolution.x / iResolution.y;\n    \n    vec2 mousePosition = iMouse.xy / iResolution.xy;\n    mousePosition = (mousePosition * 2.0) - 1.0;\n    mousePosition.x *= iResolution.x / iResolution.y;\n    \n    vec3 planeNormal = vec3(cos(iTime), sin(iTime), 0.0);\n    float planeDistance = 0.0; // distance from plane to origin\n    float d = plane(vec3(position, 0.0), planeNormal, planeDistance);\n    \n    // same colorization that Inigo Quilez uses in his shaders\n    vec3 color = vec3(1.0, 0.9, 1.0) + sign(d) * vec3(-0.3, 0.4, 0.3); // base color\n    color *= 1.0 - exp(-3.0 * abs(d)); // gradient\n\tcolor *= 0.8 + 0.2 * cos(180.0 * d); // ripples\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d))); // outline\n    \n    d = plane(vec3(mousePosition, 0.0), planeNormal, planeDistance);\n    color = mix(color, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.01, abs(max(abs(position.x - mousePosition.x), abs(position.y - mousePosition.y)) - abs(d)))); // box\n\tfragColor = vec4(color,1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7lSSRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 538, 605, 605, 717], [720, 720, 775, 775, 1878]]}
{"id": "7s33DH", "name": "Bézier Curve", "author": "wylm", "description": "It's base on https://www.shadertoy.com/view/tlKcRm.", "tags": ["beziercurve"], "likes": 0, "viewed": 60, "date": "1629688954", "time_retrieved": "2024-06-20T20:46:36.907983", "image_code": "#define E 2.718281828459\n\nfloat CubicBezier(float x, vec4 u) {\n    return u.x*pow(1.-x,3.)+3.*u.y*pow(1.-x,2.)*x+3.*u.z*pow(1.-x,2.)*pow(x,2.)+u.w*pow(x,3.);\n}\n\nfloat move(){\n    return pow(E, -5. * pow(fract(iTime),2.));\n}\n\nvec3 shade(vec4 res )\n{\n    float ra = length(res.yz);\n    float an = atan(res.y,res.z) + 2.0*iTime;\n    float pa = sin(3.0*an);\n\n    vec3 cola = 0.5 + 0.5*sin( (res.w/32.0)*3.5 + vec3(0.0,1.0,2.0) );\n    \n    vec3 col = vec3(0.0);\n    col += cola*0.4*(1.0-smoothstep( 0.90, 1.00, ra) );\n    col += cola*1.0*(1.0-smoothstep( 0.00, 0.03, abs(ra-0.8)))*(0.5+0.5*pa);\n    col += cola*1.0*(1.0-smoothstep( 0.00, 0.20, abs(ra-0.8)))*(0.5+0.5*pa);\n    col += cola*0.5*(1.0-smoothstep( 0.05, 0.10, abs(ra-0.5)))*(0.5+0.5*pa);\n    col += cola*0.7*(1.0-smoothstep( 0.00, 0.30, abs(ra-0.5)))*(0.5+0.5*pa);\n\n    return col*0.3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.y *= 2.;\n    \n    vec4 bezierU = vec4(0., 1., 0., 1.);\n    uv.y -= CubicBezier(clamp(uv.x, 0.0, 1.), bezierU);\n\n    vec3 col = vec3(0.5);\n    col += smoothstep(0.03, 0.02, distance(uv.y, 0.5) * 2.)  \n            * smoothstep(0., 0.1, 1. - distance(uv.x, 0.5) * 2.) \n            * smoothstep(0.5, 0., distance(1. - uv.x, move()) * 2. );\n\n    fragColor = vec4(1.0/(1.0+col),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7s33DH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[26, 26, 62, 62, 159], [161, 161, 174, 174, 223], [225, 225, 248, 248, 843], [845, 845, 902, 902, 1331]]}
{"id": "7s33RB", "name": "Mutual Attraction", "author": "rattlesneker", "description": "Quantization", "tags": ["quantization"], "likes": 1, "viewed": 41, "date": "1630062378", "time_retrieved": "2024-06-20T20:46:36.907983", "image_code": "\nconst int COLORS_SIZE = 4;\nconst vec3 ERR_COLOR = vec3(0.0, 0.0, 0.0);\n\nconst int SAMPLES_S = 4;\nconst int N_SAMPLES = SAMPLES_S * SAMPLES_S;\n\nfloat function(float x, float y, float t)\n{\n    t = t + 1.8;    \n    float t2 = t / 2.0;\n    float t4 = t / 4.0;\n    float st2 = sin(t2);\n    float ct2 = cos(t2);\n    float st4 = sin(t4);\n    float tt4 = tan(t4);\n    \n    float xr = x * cos(pow(t2, 1.01));\n    float yr = y * sin(pow(t2, 1.01));\n    \n    return (0.4*x * cos(0.5*y)) + (tt4 * 0.6*xr * sin(xr)) + (st4 + 1.0) * pow(0.3*xr + 0.2*yr, 2.0);\n}\n\nvec2[N_SAMPLES] supersampling(vec2 coord, float pixSize)\n{\n    float sampleSize = pixSize / float(SAMPLES_S);\n    vec2 leftUp = coord - pixSize / 2.0 + sampleSize / 2.0; \n    \n    vec2 samples[N_SAMPLES];\n    for (int i = 0; i < SAMPLES_S; i++)\n    {\n        for (int j = 0; j < SAMPLES_S; j++)\n        {\n            vec2 sampl = leftUp + vec2(sampleSize * float(j), sampleSize * float(i)); \n            samples[i * SAMPLES_S + j] = sampl;\n        }\n    }\n    return samples;    \n}\n\nvec2 uvToCarthesian(vec2 uv, vec2 xDomain, vec2 yDomain)\n{\n    float x = xDomain.x + uv.x * (xDomain.y - xDomain.x);\n    float y = yDomain.x + uv.y * (yDomain.y - yDomain.x);\n    return vec2(x, y);\n}\n\nvec2 getOrigin(vec2 xDomain, vec2 yDomain)\n{\n    float x = xDomain.x + (xDomain.y - xDomain.x) / 2.0;\n    float y = yDomain.x + (yDomain.y - yDomain.x) / 2.0;\n    return vec2(x, y);\n}\n\nvec2 carthesianCircleInversion(vec2 carth, vec2 o, float r)\n{\n    vec2 dir = carth - o;\n    float x = r * r / length(dir);\n    return x * normalize(dir) + o;\n}\n\nvec3 getColor(float value, vec2 range, vec4 colors[COLORS_SIZE])\n{\n    value = clamp(value, range.x, range.y);\n    \n    float len = range.y - range.x; \n    float norm = (value - range.x) / len;\n    \n    // Get two closest colors and mix them\n    vec3 color = ERR_COLOR;\n    for (int i = 0; i < COLORS_SIZE-1; i++)\n    {\n        vec4 curr = colors[i];\n        vec4 next = colors[i+1];\n        if (curr.w <= norm && norm <= next.w)\n        {\n            float btw = (norm - curr.w) / (next.w - curr.w);\n            color = mix(curr.xyz, next.xyz, btw);\n            break;\n        }\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Function domain\n    const vec2 xDomain = vec2(-35.0, 35.0);\n    const vec2 yDomain = vec2(-25.0, 25.0);\n    \n    // Function range\n    const vec2 range = vec2(0, 100);\n    \n    // Colors\n    vec4 colors[COLORS_SIZE] = vec4[](\n        vec4(0.0, 0.0, 0.0, 0.0),\n        vec4(0.78, 0.16, 0.11, 0.34),\n        vec4(0.89, 0.48, 0.21, 0.63),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    \n    vec2 origin = getOrigin(xDomain, yDomain);\n    \n    vec2 samples[] = supersampling(fragCoord, 1.0);\n    vec3 totalColor = vec3(0.0);\n    for (int i = 0; i < N_SAMPLES; i++)\n    {\n        vec2 uv = samples[i] / iResolution.xy;\n        uv.y = 1.0 - uv.y;\n    \n        vec2 coord = uvToCarthesian(uv, xDomain, yDomain);\n        coord = carthesianCircleInversion(coord, origin, 22.0);\n\n        float value = function(coord.x, coord.y, iTime);\n\n        totalColor = totalColor + getColor(value, range, colors);\n    }\n    vec3 avgColor = totalColor / float(N_SAMPLES);    \n\n    fragColor = vec4(avgColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7s33RB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[144, 144, 187, 187, 548], [1033, 1033, 1091, 1091, 1232], [1234, 1234, 1278, 1278, 1417], [1419, 1419, 1480, 1480, 1578], [1580, 1580, 1646, 1646, 2185], [2187, 2187, 2242, 2265, 3241]]}
{"id": "7s33WM", "name": "Persian carpet 5", "author": "jarble", "description": "A slightly simpler formula, with a much nicer range of colors.", "tags": ["fractal", "carpet", "rug"], "likes": 7, "viewed": 150, "date": "1629939421", "time_retrieved": "2024-06-20T20:46:37.350307", "image_code": "\n//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//to do: drag and drop using https://www.shadertoy.com/view/WdGGWh\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   //from David Hoskins' \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5*3./2.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    float t2 = floor((iTime+4.)/20.0+uv.x);\n    //vec3 random2 = hash31(1.+t2);\n    \n    \n    float offset = .25;\n    \n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        float t3 = float(c)+t2;\n        vec3 random2 = hash31(1.+t3);\n        float scale2 = 1.+random2.x;\n        //vec3 col_prev = 0.0;\n        for(int i=0;i<3;i++)\n        {\n            vec3 col_prev = col;\n            float factor = -1.1;\n            \n            uv = triangle_wave(uv.yx+1.5,scale)+triangle_wave(uv,scale);\n            for(int j = 0; j < 3;j++){\n                uv = triangle_wave((uv+offset),scale);\n            }\n            uv.x /= factor;\n            \n            //uv.x *= -1.0;\n            //uv = triangle_wave(uv+c1.y,scale);\n            scale /= 1.+scale2*col.x;\n            //offset *= scale2/(1.+random4.x);\n            \n            //uv = -uv.yx;\n            //uv = uv.yx;\n            scale2 += col.x/8.;\n            if(i>0) col = (col.yzx*random2.x + col_prev*random2.y)/(random2.x+random2.y);\n            col[c] = fract((uv.x)-(uv.y));\n\n            \n\n        }\n\n            //random3 = (hash31(2.+t3)-vec3(.5))/4.;\n            //random4 = (hash31(3.+t3)-vec3(.5))/4.;\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7s33WM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[346, 456, 478, 523, 656], [658, 658, 697, 697, 742], [744, 744, 801, 801, 2284]]}
{"id": "7s3GWH", "name": "phong box", "author": "pema99", "description": "more attempts to keep sharp and write stuff without looking at any resources", "tags": ["phong"], "likes": 1, "viewed": 146, "date": "1629675417", "time_retrieved": "2024-06-20T20:46:37.350307", "image_code": "float smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nmat2 rot(float r)\n{\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat map(vec3 p)\n{\n    // ball\n    float d = length(p + vec3(0., 0.5, -0.5)) - 0.5;\n    \n    // walls\n    d = min(d, abs(p.y+1.0));\n    d = min(d, abs(p.y-1.0));\n    d = min(d, abs(p.x+1.5));\n    d = min(d, abs(p.x-1.5));\n    d = min(d, abs(p.z-2.0));\n\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    vec3 p = ro;\n    int i = 0;\n    for (; i < 50; i++)\n    {\n        float dist = map(p);\n        if (dist < 0.001) break;\n        t += dist;\n        p = ro + t * rd;\n    }\n    return vec2(t, i);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 o = vec2(0.001, 0.);\n    return normalize(vec3(\n        map(p + o.xyy) - map(p - o.xyy),\n        map(p + o.yxy) - map(p - o.yxy),\n        map(p + o.yyx) - map(p - o.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * ((fragCoord/iResolution.xy) - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    for (int i = 0; i < 2; i++)\n    {\n        for (int j = 0; j < 2; j++)\n        {\n            vec3 ro = vec3(0., 0., -3.);\n            vec3 rd = normalize(vec3(uv + vec2(float(i)*0.5+0.25, float(j)*0.5+0.25)*0.006, 0.) - ro);\n\n            vec2 res = march(ro, rd);\n            float dist = res.x;\n            float iters = res.y;\n\n            if (dist < 10.)\n            {\n                vec3 hit = ro + dist * rd;\n                vec3 light = vec3(sin(iTime), 0.5, cos(iTime)) - hit;\n                vec3 ld = normalize(light);\n                vec3 norm = normal(hit);\n                vec3 albedo = (norm * 0.5 + 0.5);\n                float diff = 0.;\n                \n                if (march(hit + norm * 0.001, ld).x >= length(light))\n                {\n                    diff = dot(norm, ld);\n                }\n                \n                col += max(diff, 0.2) * albedo;\n            }\n        }\n    }\n    \n    fragColor = vec4(col / 4.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7s3GWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 43, 43, 142], [144, 144, 163, 163, 215], [217, 217, 236, 248, 486], [488, 488, 518, 518, 735], [737, 737, 758, 758, 947], [949, 949, 1006, 1056, 2146]]}
{"id": "7sc3D8", "name": "blob blob blob", "author": "pema99", "description": "attempt at metaballs without looking at any resources.. except iq's smin function", "tags": ["raymarching"], "likes": 1, "viewed": 51, "date": "1629671687", "time_retrieved": "2024-06-20T20:46:37.350307", "image_code": "float smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nmat2 rot(float r)\n{\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat map(vec3 p)\n{\n    p.xy *= rot(iTime);\n    float d = length(p) - 0.5;\n    d = smin(d, length(p+vec3(0.4, 0., 0.))-0.5, 0.05);\n    //float d = length(p - vec3(0., 0., 15.)) - 10.0;\n    //d = min(d, length(p - vec3(0., 11., 0.)) - 10.0);\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    vec3 p = ro;\n    int i = 0;\n    for (; i < 50; i++)\n    {\n        float dist = map(p);\n        if (dist < 0.001) break;\n        t += dist;\n        p = ro + t * rd;\n    }\n    return vec2(t, i);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 o = vec2(0.001, 0.);\n    return normalize(vec3(\n        map(p + o.xyy) - map(p - o.xyy),\n        map(p + o.yxy) - map(p - o.yxy),\n        map(p + o.yyx) - map(p - o.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * ((fragCoord/iResolution.xy) - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    for (int i = 0; i < 2; i++)\n    {\n        for (int j = 0; j < 2; j++)\n        {\n            vec3 ro = vec3(0., 0., -3.);\n            vec3 rd = normalize(vec3(uv + vec2(float(i)*0.5+0.25, float(j)*0.5+0.25)*0.006, 0.) - ro);\n\n            vec2 res = march(ro, rd);\n            float dist = res.x;\n            float iters = res.y;\n\n            if (dist < 10.)\n            {\n                col += (normal(ro + dist * rd) * 0.5 + 0.5) * 0.25;\n            }\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sc3D8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 43, 43, 142], [144, 144, 163, 163, 215], [217, 217, 236, 236, 473], [475, 475, 505, 505, 722], [724, 724, 745, 745, 934], [936, 936, 993, 1043, 1684]]}
{"id": "7sc3DN", "name": "Kiss from a rose", "author": "AeroShark333", "description": "White rose shader (ray-marched)\n\nMy first ever shader published here :D\nThe performance isn't that great but it works I guess :D\nMaybe I will add leaves someday :D", "tags": ["3d", "noise", "raymarch", "rose", "raymarchingwhiterose"], "likes": 4, "viewed": 76, "date": "1629845608", "time_retrieved": "2024-06-20T20:46:38.792938", "image_code": "/*\n * \"Kiss from a rose\" by Abiram Kanagaratnam (AeroShark333)\n *\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * Contact: <see bottom of shader>\n */\n\n// Recommended range (9.0 ~ 33.0)\n#define FLOWER_QUALITY 15.0\n\n// Ray-marcher options\n#define MAX_STEPS 100\n#define MIN_DIST 0.0003\n#define MAX_DIST 24.0\n#define MIN_LIGHTING_DIST 2.0 * MIN_DIST\n#define NORMAL_OFFSET 0.01\n#define SHADOW_STRENGTH 0.1\n\n// Constants\n#define PI 3.14159265359\n\n// (P)RNG\nfloat hash(float x){\n    return fract(sin(x*1234.0)*4321.0);\n}\n\n// Noise\nfloat value(vec2 xy){\n    vec2 f0 = floor(xy);\n\n    float h1 = hash(f0.y);\n    float h2 = hash(f0.y + 1.0);\n\n    float f1 = f0.x + 1.0;\n\n    float bl = hash(f0.x + h1);\n    float br = hash(f1 + h1);\n\n    float tl = hash(f0.x + h2);\n    float tr = hash(f1 + h2);\n\n    vec2 fr = xy - f0;\n    fr = (3.0 - 2.0*fr)*fr*fr;\n\n    float b = mix(bl, br, fr.x);\n    float t = mix(tl, tr, fr.x);\n\n    return mix(b, t, fr.y);\n}\n\n// Rotate\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Plane\nfloat getPlaneDistance(vec3 position){\n    return position.y;\n}\n\n// Cylinder\nfloat getCylinderDistance(vec3 position, vec3 cylinderLowerPosition, vec3 cylinderUpperPosition, float radius){\n    vec3 cylinderVector = cylinderUpperPosition - cylinderLowerPosition;\n    vec3 positionVector = position - cylinderLowerPosition;\n    \n    float innerDistance = dot(cylinderVector, positionVector) / dot(cylinderVector, cylinderVector);\n    \n    vec3 cylinderPosition = cylinderLowerPosition + innerDistance * cylinderVector;\n\n    float x = length(position-cylinderPosition) - radius;\n    float y = (abs(innerDistance-0.5)-0.5)*length(cylinderVector);\n    \n    float exteriorDistance = length(max(vec2(x,y),0.0));\n    float interiorDistance = min(max(x,y), 0.0);\n    \n    float distance = exteriorDistance + interiorDistance;\n    \n    return distance;\n}\n\n// Stem\nfloat getStemDistance(vec3 position){\n\n    vec3 customPosition = position;\n    customPosition.x += 0.05* sin(2.0*position.y);\n    \n    return getCylinderDistance(customPosition, vec3(0.0, 0.75, 0.0), vec3(0.0, 0.0, 0.0), 0.006);\n    \n}\n\n// Flower\nfloat getFlowerDistance(vec3 position){\n    float dist = 100.0;\n    \n    // Quality of rose\n    float hMax = FLOWER_QUALITY;\n    \n    float norm = 10.0 / hMax;\n    for(float h=0.0; h < hMax; h++){\n        vec3 newPosition = position;\n        \n        // More dense in center\n        float h2 = (h / hMax);\n        h2 *= h2 * hMax * norm;\n        \n        // Make sure flower begins at stem\n        newPosition.x += 0.05* sin(2.0*0.75);\n        \n        // Create parabolic displacement in y-direction depending on the radius\n        newPosition.y -= mix(0.0,2.0*sin(distance(newPosition.xz, vec2(0.0, 0.0))),sqrt(abs(newPosition.y-0.75)));\n     \n        // Rotate flower (aka 'cylinder')\n        float offset =  h2*1.3; // + iTime*0.3;\n        float x = clamp(mod(atan(newPosition.x,newPosition.z) + PI/2.0 + offset, PI), 0.0, PI);\n        \n        // Creates petal-like effect\n        newPosition.xz *= 1.0+0.24* clamp(pow(sin(x),1.2),0.0,1.0);\n     \n        float top = 0.84;\n     \n        // Artifacts or something...\n        if(position.y < 1.0){\n            newPosition.xz *= mix(1.0, 0.75, clamp(abs(position.y-top-0.03),0.0,1.0));\n            newPosition.xz *= mix(1.0, 0.45, clamp(abs(position.y-top+0.00),0.0,1.0));\n            newPosition.xz *= mix(1.0, 0.15, clamp(abs(position.y-top+0.03),0.0,1.0));\n        }\n        \n        // Vary radius for every flower (aka 'cylinder')\n        float customRadius = 0.001 + 0.009*h2;\n        customRadius *= 0.01/customRadius + pow(abs((position.y-0.75)/(0.18-0.0057*h2)), 0.3);\n        dist = min(dist, 0.2*getCylinderDistance(newPosition, vec3(0.0, top-0.0057*h2, 0.0), vec3(0.0, 0.75, 0.0), customRadius));\n    }\n    \n    // Artifacts due to deforming I guess...\n    return 3.9*dist;\n    \n}\n\n// Distance\nfloat getDistance(vec3 position){\n    float dist = 0.0;\n    \n    dist = getPlaneDistance(position);\n    \n    dist = min(dist, getStemDistance(position));\n    \n    dist = min(dist, getFlowerDistance(position));\n    \n    return dist;\n}\n\n// Ray-marcher\nfloat rayMarch(vec3 origin, vec3 direction){\n    float distance = 0.0;\n    for(int i = 0 ; i< MAX_STEPS; i++){\n        vec3 position = origin + direction * distance;\n        float step = getDistance(position);\n        distance += step;\n        if(step < MIN_DIST || distance > MAX_DIST){\n            break;\n        }\n    \n    }\n    return distance;\n\n}\n\n// Normal\nvec3 getNormal(vec3 position){\n    vec2 offset = vec2(NORMAL_OFFSET, 0.0);\n    \n    float distance = getDistance(position);\n    \n    vec3 normal = vec3(\n        distance - getDistance(position-offset.xyy),\n        distance - getDistance(position-offset.yxy),\n        distance - getDistance(position-offset.yyx));\n        \n    return normalize(normal);\n}\n\n// Lighting\nfloat getLighting(vec3 position){\n    vec3 lightPosition = vec3(-3.0, 3.0, 0.0);\n    \n    //vec3 lightDirection = normalize(lightPosition - position);\n    vec3 lightDirection = normalize(lightPosition - vec3(0.0));\n    \n    vec3 normal = getNormal(position);\n    \n    \n    float diffuse = clamp(dot(lightDirection, normal),\n                    0.0,\n                    1.0);\n                    \n    float distance = rayMarch(position + normal * MIN_LIGHTING_DIST, lightDirection);\n    \n    // Shadow\n    if(distance < length (lightPosition - position)){\n        diffuse *= 0.45;\n    }\n    \n    // Include ambient lighting\n    return max(diffuse, 0.15);\n}\n\n// Main loop\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initial color\n    vec3 col = vec3(0.0);\n\n    // Centered UV-coordinates\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    // Input\n    vec2 control = iMouse.xy/iResolution.xy;\n    \n    // Camera\n    vec3 origin = vec3(0.0, 1.0, -3.0);\n    \n    origin.xz *= rotate(iTime*0.3+(1.0-control.x)*PI*2.0);\n    \n    origin *= 1.0-0.93*control.y;\n    origin.y +=  0.87; // +0.3*control.x;\n    \n    vec3 direction = normalize(vec3(uv.x, uv.y-0.5, 1.0));\n    direction.xz *= rotate(iTime*0.3+(1.0-control.x)*PI*2.0);\n    \n    float dist = rayMarch(origin, direction);\n    \n    vec3 position = origin + direction * dist;\n    \n    float diffuse = getLighting(position);\n    \n    col = vec3(diffuse);\n    \n    if(position.y > 0.75){\n    \n        float yVal = 3.0*4.0*(position.y - 0.75);\n        float angleVal = 150.0*dot(getNormal(position),vec3(1.0,0.0,0.0));\n        float factor = value(vec2(yVal,angleVal));\n        \n        col = col * (0.06*factor+1.0) * vec3(1.2,1.2,1.1*sqrt(clamp(distance(position.xz,vec2(-0.05* sin(2.0*0.75),0.0))/0.09,0.0,1.0)));\n        \n        col = clamp(col, vec3(0.0), vec3(1.0));\n    }else if(position.y > MIN_DIST){\n        // 0.0 ~ 0.75\n        float yVal = position.y / 0.75;\n        float angleVal = dot(getNormal(position),vec3(1.0,0.0,0.0));\n        float factor = value(9.0*vec2(yVal,angleVal));\n        col = col * vec3(0.0,0.45+0.30*sin(factor*PI),0.0);\n    }else{\n        float factor = value(9.0*position.xz);\n        col *= col.x;\n        col *= vec3(0.3,1.0-factor*0.1,0.3);\n        col *= pow(1.0 - clamp(distance(position.xz,vec2(0.0))/100.0,0.0,1.0),45.0);\n    }\n    \n    if(distance(position.xz,vec2(0.0))>9.0){\n        col = vec3(0.0);\n    }\n    \n    fragColor = vec4(col,1.0);\n}\n\n// E-mail: abiram26@hotmail.com", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sc3DN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[486, 496, 516, 516, 558], [560, 569, 590, 590, 983], [985, 995, 1017, 1017, 1093], [1095, 1104, 1142, 1142, 1167], [1169, 1181, 1292, 1292, 1948], [1950, 1958, 1995, 1995, 2193], [2195, 2205, 2244, 2244, 3949], [3951, 3963, 3996, 3996, 4196], [4198, 4213, 4257, 4257, 4564], [4566, 4576, 4606, 4606, 4929], [4931, 4943, 4976, 4976, 5598], [5600, 5613, 5670, 5691, 7418]]}
{"id": "7sc3R4", "name": "rotatintg A", "author": "sunhokim", "description": "a", "tags": ["sdf"], "likes": 6, "viewed": 137, "date": "1629223648", "time_retrieved": "2024-06-20T20:46:38.799077", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec3 hash3( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*13.5453123);\n}\n\nfloat noise( in vec3 p ) {\n    vec3 a = hash3(p);\n    return sin(dot(a,a));\n}\n\nvec3 rotateX( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\nvec3 rotateY( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\nvec3 rotateZ( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec4 opS( vec4 d2, vec4 d1 )\n{\n\treturn (-d1.x>d2.x) ? vec4(-d1.x, d1.yzw) : d2;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nvec4 mapA(vec3 p) {\n    vec3 q = rotateZ(p, M_PI*0.15);\n    vec4 A = vec4(sdBox(q, vec3(0.5,3.0, 0.5)), vec3(1.0));\n    q -= vec3(-1.0, 0.0, 0.0);\n    vec4 D = vec4(sdBox(q, vec3(0.5,3.0, 0.6)), vec3(1.0));\n    q = rotateZ(p- vec3(1.4, 0.0, 0.0), -M_PI*0.15) ;\n    vec4 A2 = vec4(sdBox(q, vec3(0.5,3.0, 0.5)),vec3(1.0));\n    q -= vec3(1.0, 0.0, 0.0);\n    vec4 D2 = vec4(sdBox(q, vec3(0.5,3.0, 0.6)), vec3(1.0));\n    q = p - vec3(0.7, -2.1, 0.0);\n    vec4 D3 = vec4(sdBox(q, vec3(0.7,0.7, 0.6)), vec3(1.0));\n    q = p - vec3(0.7, 1.3, 0.0);\n    vec4 A3 = vec4(sdBox(q, vec3(1.1, 0.4, 0.5)),vec3(1.0));\n    A = opU(A, A2);\n    A = opS(A, D);\n    A = opS(A, D2);\n    A = opS(A, D3);\n    A = opU(A, A3);\n    return A;\n}\n\nvec4 map(vec3 p) {\n    vec4 res = vec4(1e10, 0, 0,0);\n\n    {\n    float s = (1.0+sin((p.x/20.0)*M_PI+(p.z/20.0)*M_PI+iTime*M_PI))/2.0;\n    vec3 c = vec3(10.0, 10.0, 6.0);\n    vec3 q = opRep(p, c);\n    vec3 id = floor((p+0.5*c)/c);\n    float t2 = 2.0*M_PI*noise((id)*0.1);\n    float t = t2;\n    q.xy*=rot(-t);\n    q.yz*=rot(-t);\n    q.zx*=rot(t);\n    vec4 A = mapA(q/s)*s;\n    res = opU(res, A);\n    res.x = max(res.x, sdBox(id, vec3(2.0, 2.0,3.0)));\n    //res.x -= 0.3*noise(p);\n    }\n\n    return res;\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in float rad )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 0.05;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );\n}   \n\nvec4 raycast( in vec3 ro, in vec3 rd )\n{\n    vec4 res = vec4(-1.0);\n    vec2 tminmax = iSphere( ro, rd, 100.0 );\n\tif( tminmax.y>0.0 )\n    {\n        float t = max(tminmax.x,0.001);\n        for( int i=0; i<256 && t<tminmax.y; i++ )\n        {\n            vec4 h = map(ro+t*rd);\n            if( h.x<0.01 ) { res=vec4(t,h.yzw); break; }\n            t += 0.5*h.x;\n        }\n    }\n    \n    return res;\n}\n\nvec3 skyColor(vec3 rd) {\n    float k = (max(rd.y,0.0)*0.8+0.2)*0.8;\n    vec3 sky = vec3(pow(1.0-k,2.0), 1.0-k, 0.6+(1.0-k)*0.4) * 1.1;\n    return sky;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 render( in vec3 ro, vec3 rd )\n{ \n    vec4 res = raycast(ro, rd);\n    vec3 pos = ro + res.x*rd;\n    vec3 col = vec3(0.0);\n    vec3 normal = calcNormal(pos);\n\n    if (res.x <0.0) {\n        return skyColor(rd);\n    }\n    vec3 sunDir = normalize(vec3(1.0,-1.0,1.0));\n    vec3 material = vec3(1.0);\n    float sun = clamp( dot( normal, sunDir ), 0.0, 1.0 );\n    float sky = clamp( 0.5 + 0.5*normal.y, 0.0 ,1.0 );\n    float sha = softshadow(pos, sunDir, 0.03, 100.0, 30.0);\n    return 0.4*sky + sun*vec3(1.64,1.27,0.99)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMat( in vec3 eye, in vec3 look )\n{\n    vec3 w = normalize(eye-look);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(w, u);\n    return mat3( u, v, w );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec2 mouse = iMouse.xy /iResolution.xy;\n    if (iMouse.xy == vec2(0)) {\n        mouse = vec2(0.5,0.5);\n    }\n    vec2 spr = vec2(mouse.x * M_PI - M_PI/2.0, mouse.y*M_PI-M_PI)*0.8;\n    spr.x += 0.3*iTime;\n    float r = 100.0;\n    vec3 eye = vec3(-r*sin(spr.x)*sin(spr.y), -r*cos(spr.y),-r*sin(spr.y)*cos(spr.x)) + vec3(0.0, -2.0, 0.0);\n    vec3 look = vec3(0.0,0.0,0);\n    mat3 view = viewMat(eye, look);\n    dir = view * dir;\n    fragColor = vec4(render(eye, dir), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sc3R4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[99, 99, 121, 121, 287], [289, 289, 315, 315, 366], [368, 368, 404, 404, 502], [503, 503, 539, 539, 637], [638, 638, 674, 674, 772], [774, 774, 805, 805, 892], [894, 894, 924, 924, 957], [959, 959, 989, 989, 1040], [1042, 1042, 1077, 1077, 1112], [1114, 1114, 1149, 1149, 1173], [1175, 1175, 1194, 1194, 1890], [1892, 1892, 1910, 1910, 2394], [2396, 2396, 2450, 2450, 2610], [2612, 2612, 2642, 2642, 2909], [2914, 2914, 2954, 2954, 3310], [3312, 3312, 3336, 3336, 3464], [3466, 3466, 3543, 3543, 3758], [3760, 3760, 3796, 3796, 4313], [4315, 4315, 4380, 4380, 4512], [4514, 4514, 4557, 4557, 4694], [4696, 4696, 4753, 4753, 5289]]}
{"id": "7sc3RB", "name": "Pentakis Reflections", "author": "dr2", "description": "Reflections from spheres on surface of pentakis dodecahedron", "tags": ["dodecahedron", "symmetry"], "likes": 14, "viewed": 184, "date": "1630061412", "time_retrieved": "2024-06-20T20:46:38.806751", "image_code": "// \"Pentakis Reflections\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\n\nvec3 ltDir;\nfloat tCur, dstFar;\nint idObj;\nbool isRefl;\nconst float pi = 3.1415927;\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 DodecSym (vec3 p)\n{\n  vec2 csD;\n  csD = sin (0.5 * atan (2.) + vec2 (0.5 * pi, 0.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), csD);\n  p.xy = Rot2D (p.xy, - pi / 10.);\n  p.x = - abs (p.x);\n  for (int k = 0; k <= 3; k ++) {\n    p.zy = Rot2Cs (p.zy, vec2 (csD.x, - csD.y));\n    p.y = - abs (p.y);\n    p.zy = Rot2Cs (p.zy, csD);\n    if (k < 3) p.xy = Rot2Cs (p.xy, sin (-2. * pi / 5. + vec2 (0.5 * pi, 0.)));\n  }\n  p.xy = sin (mod (atan (p.x, p.y) + pi / 5., 2. * pi / 5.) - pi / 5. +\n     vec2 (0., 0.5 * pi)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 t;\n  float dMin, d, a1, a2, rEx, s;\n  rEx = 3.;\n  dMin = dstFar;\n  t = vec2 (0.365, -1.);\n  q = DodecSym (p);\n  a1 = 0.5 * acos (-1. / sqrt (5.));\n  a2 = 0.5 * acos (- (80. + 9. * sqrt (5.)) / 109.);\n  d = length (q) - rEx;\n  d = SmoothMax (d, min (dot (q.yz, sin (a1 - pi + vec2 (0., 0.5 * pi))),\n     dot (q.xy, sin (pi / 5. + vec2 (0.5 * pi, 0.)))) - 0.04, 0.04);\n  DMIN (1);\n  s = - dot (q.yz, sin (a1 - a2 + vec2 (0., 0.5 * pi)));\n  q.yz -= t * 0.82 * rEx;\n  d = length (q) - 0.17 * rEx;\n  d = max (s - 0.91 * rEx, - d);\n  DMIN (1);\n  q.yz -= t * 0.05 * rEx;\n  if (! isRefl) { \n    d = length (q) - 0.16 * rEx;\n    DMIN (2);\n  }\n  q.yz -= t * 6. * rEx;\n  d = length (q) - rEx;\n  DMIN (3);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ObjCol (vec3 rd, vec3 vn)\n{\n  vec4 col4;\n  vec3 col;\n  if (idObj == 1) col4 = vec4 (0.7, 0.5, 0., 0.2);\n  else if (idObj == 2) col4 = vec4 (0.6, 0.6, 0.7, 0.5);\n  else if (idObj == 3) col4 = vec4 (1., 0., 0., -1.);\n  if (col4.a >= 0.) col = col4.rgb * (0.1 + 0.2 * max (- dot (vn, ltDir), 0.) +\n     0.8 * max (dot (vn, ltDir), 0.)) + col4.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n  else col = col4.rgb * (0.2 + 0.8 * max (- dot (vn, rd), 0.));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, colR, vn;\n  float dstObj;\n  isRefl = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col = ObjCol (rd, vn);\n    if (idObj == 2) {\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      isRefl = true;\n      dstObj = ObjRay (ro, rd);\n      if (dstObj < dstFar) {\n        ro += dstObj * rd;\n        vn = ObjNf (ro);\n        colR = ObjCol (rd, vn);\n      } else colR = vec3 (0.1, 0.1, 0.2);\n      col = mix (col, colR, 0.7);\n    }\n  } else col = vec3 (0.1, 0.1, 0.2);\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.03 * pi * tCur;\n    el -= 0.1 * pi * sin (0.02 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -18.);\n  zmFac = 5.;\n  dstFar = 50.;\n  ltDir = normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sc3RB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 520, 544, 544, 1095], [1097, 1097, 1119, 1119, 1847], [1849, 1849, 1882, 1882, 2066], [2068, 2068, 2089, 2089, 2344], [2346, 2346, 2378, 2378, 2826], [2828, 2828, 2863, 2863, 3434], [3478, 3478, 3534, 3534, 4568], [4570, 4570, 4603, 4603, 4630], [4632, 4632, 4677, 4677, 4769], [4771, 4771, 4816, 4816, 4854], [4856, 4856, 4892, 4892, 5098], [5100, 5100, 5130, 5130, 5243], [5245, 5245, 5276, 5276, 5340]]}
{"id": "7sc3RS", "name": "Temporal Fire [golf] [252 char]", "author": "Tater", "description": "Golfed version of https://shadertoy.com/view/fs23zy", "tags": ["2d", "fire", "golf"], "likes": 4, "viewed": 214, "date": "1630057286", "time_retrieved": "2024-06-20T20:46:38.807748", "image_code": "// Fork of \"Temporal Fire\" by Tater. https://shadertoy.com/view/fs23zy\n// 2021-08-27 07:55:20\n\n//My first golfed shader\n#define b(a) step(max(abs(U.x),U.y),a)\nvoid mainImage(out vec4 O,vec2 C)\n{\n    for(O-=O; ++O.w<7.;){\n        vec2 U=C/iResolution.xy-.5;\n        U.y=U.y*.4+.2+U.x*U.x;        \n        U.x+=U.y*sin(O+O+U.y*25.-iTime*9.).w*.2;\n        U.y-=asin(sin(U.x*34.))/20.;\n        O+=.3*vec4(.8*b(.3)+b(.2),b(.2),b(.1),5);       \n    }\n}\n\n/* original 263 chars\n#define b(a) step(max(d.x,d.y),a)\nvoid mainImage(out vec4 O,vec2 C){\n    for(;O.w++<3.;){\n        vec2 d,U=C.yx/iResolution.yx;   \n        U.y-=.5;\n        U.x=U.x*.4+U.y*U.y;        \n        U.y+=U.x*sin(-iTime*9.+O.w*2.+U.x*25.)*.2;\n        U.x-=asin(sin(U.y*34.))/20.;\n        d=abs(U);\n        O+=.3*vec4(.8*b(.3)+b(.2),b(.2),b(.1),-1.);       \n    }\n}\n*/\n\n/*\n#define b(a) step(max(d.x,d.y),a)\nvoid mainImage(out vec4 O,vec2 C){for(;O.w++<3.;){vec2 d,U=C.yx/iResolution.yx;U.y=U.y-.5;U.x=U.x*.4+U.y*U.y;U.y+=U.x*sin(-iTime*9.+O.w*2.+U.x*25.)*.2;U.x-=asin(sin(U.y*34.))/20.;d=abs(U);O+=.3*vec4(.8*b(.3)+b(.2),b(.2),b(.1),-1.);}}\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sc3RS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[95, 159, 194, 194, 446]]}
{"id": "7sc3z7", "name": "Fake fluid physics", "author": "jarble", "description": "This fluid simulation is completely fake, but it somehow manages to look realistic.\nThis illusion works [url=https://www.shadertoy.com/view/7ddGzS]in 3 dimensions[/url], too.", "tags": ["fluid"], "likes": 4, "viewed": 197, "date": "1630026035", "time_retrieved": "2024-06-20T20:46:38.807748", "image_code": "vec2 fluid(vec2 uv1){\n vec2 uv = uv1;\n for (float i = 1.; i < 15.; i++)\n  {\n    uv.x += sin((iTime-uv.y)*.5)*1.5/i* sin(i * uv.y + iTime * 0.5);\n    uv.y += sin((iTime-uv.x)*.5)*1.5/i* sin(i * uv.x + iTime * 0.5 );\n    //uv.x += (sin((uv.y)*i-iTime))/i;\n    //uv.y += (sin((uv.x)*i-iTime))/i;\n  }\n  return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = fragCoord/iResolution.xy*10.;\n uv = fluid(uv);\n float r = abs(sin(uv.x))+.5;\n float g =abs(sin(uv.x+2.+iTime*.2))-.2;\n float b = abs(sin(uv.x+4.));   \n vec3 col = vec3(r,g,b);   \n \n fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sc3z7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 21, 21, 311], [313, 313, 370, 370, 593]]}
{"id": "7sc3zj", "name": "Disk Reconfigurator [Livecode]", "author": "Tater", "description": "My shader from the 2021 Chaos Constructions Shader jam.\n\n[url]https://www.youtube.com/watch?v=gcoDX7bonX0[/url]", "tags": ["3d", "raymarching", "jam", "bonzomatic", "livecode", "shaderjam"], "likes": 10, "viewed": 294, "date": "1630180222", "time_retrieved": "2024-06-20T20:46:38.809743", "image_code": "\n#define fGlobalTime iTime\n#define STEPS 128.0\n#define MDIST 2000.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n#define fft1 texelFetch( iChannel0, ivec2(1,0), 0 ).x*0.08\n#define fft2 texelFetch( iChannel0, ivec2(128,0), 0 ).x*0.04\n#define fft3 texelFetch( iChannel0, ivec2(25,0), 0 ).x*0.02\nvec3 glow = vec3(0);\nvec3 cam = vec3(0);\nbool bnc = false;\nvoid mo(inout vec2 p){if(p.y<p.x) p = p.yx;}\nvoid boxFold(inout vec3 z, vec3 r){\n  z = clamp(z,-r,r)*2.0-z;\n}\nfloat frame (vec3 p, vec3 s, float r){\n  p = abs(p)-s;\n  mo(p.xz);\n  mo(p.zy);\n  p.z=max(0.,p.z);\n  return length(p)-r; \n}\nfloat ext(vec3 p, float s, float h){\n  vec2 b = vec2(s,abs(p.y)-h);\n  return min(max(b.x,b.y),0.)+length(max(b,0.));\n}\n\nfloat disks(vec3 p, float t){\n  float m = 1.0+fft1*20.0;\n  float id = floor(p.y/m)+0.5;\n  p.y = pmod(p.y, m);\n  float width = 5.0-id*0.1;\n  \n  p.zx*=rot(id*3.0*t*0.1);\n  p.zx = abs(p.zx)-6.0+sin(t*2.5);\n  float a = length(p.xz)-width;\n  a = ext(p,a,0.3);\n  a-=0.15;\n  return a;\n}\nvec2 map(vec3 p){\n  float t= mod(fGlobalTime,999.0);\n  vec3 po = p;\n  vec2 a = vec2(1);\n  vec2 b = vec2(2);\n  \n  \n   //FANCY ROT\n  float tt = pow(fract(t*2.2),3.0)+floor(t*2.2);\n  p.xy*=rot(tt*pi/3.0);\n  p.zx*=rot(-tt*pi/3.0);\n  p.yz*=rot(-tt*pi/3.0);\n  \n  p = abs(p)-40.0-fft2*1000.0;\n  \n  p.yz*=rot(-0.4);\n  p.zx*=rot(-0.4);\n  p.xy*=rot(0.4);\n   //FANCY ROT\n // float tt = pow(fract(t*1.5),3.0)+floor(t*1.5);\n  p.xy*=rot(tt*pi/3.0);\n  p.zx*=rot(-tt*pi/3.0);\n  p.yz*=rot(tt*pi/3.0);\n \n  \n  //DISKS\n  a.x = disks(p,t);\n  a.x*=0.6;\n  a.y = 1.0;\n  glow+=0.1/(0.1+a.x*a.x)*vec3(0.75,0.3,0.1);\n  \n  \n  //FRAME\n  p.zx*=rot(t);\n  b.x = frame(p,vec3(15,200,15),0.75);\n  glow+=0.1/(0.1+b.x*b.x)*vec3(0.4,0.23,0.6);\n  b.y = 2.0;\n  a =(a.x<b.x)?a:b;\n  \n  //SPHERE \n  p = po;\n  \n  p.xy*=rot(-tt*pi/16.0);\n  p.zx*=rot(-tt*pi/16.0);\n  p.yz*=rot(-tt*pi/16.0);\n  \n  \n  boxFold(p,vec3(110.0));\n  b.x = length(p)-40.0;\n  p.zx*=rot(-t*0.75);\n  p*=0.1;\n  float disp = sin(p.x)*sin(p.y)*sin(p.z);\n\n  b.y = 3.0;\n  glow+=0.3/(0.1+b.x*b.x)*\n  mix(vec3(0,0.2,0.6),vec3(0.600,0.102,0.392),clamp(length(po/300.0),0.0,1.0));\n  b.x+=disp*(1.5+fft3*200.0);\n  a =(a.x<b.x)?a:b;\n  \n  //POLE\n  p = po;\n  b.y = 5.0;\n  p.zx = pmod(p.zx,600.0);\n  p.xy = pmod(p.xy,600.0);\n  p.yz = pmod(p.yz+300.0,600.0);\n  b.x = length(p.zx)-20.0;\n  b.x = min(b.x,length(p.xy)-20.0);\n  b.x = min(b.x,length(p.yz)-20.0);\n  //glow+=\n  if(!bnc)a =(a.x<b.x)?a:b;\n  \n  a.x = max(a.x,-(length(po-cam)-35.0));\n\n  return a;\n}\nvec3 norm(vec3 p){\n  vec2 e = vec2(0.01,0);\n  return normalize(map(p).x-vec3(\n  map(p-e.xyy).x,\n  map(p-e.yxy).x,\n  map(p-e.yyx).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  vec3 col = vec3(0);\n  float t= mod(fGlobalTime,999.0);\n  vec3 ro = vec3(0,20.0+sin(t)*70.0,-70.0)*2.2;\n  ro.zx*=rot(t*0.2);\n  cam = ro;\n  vec3 lk = vec3(0,10,0);\n  vec3 f = normalize(lk-ro);\n  vec3 r = normalize(cross(vec3(0,1,0),f));\n  vec3 rd = normalize(f*0.65+uv.x*r+uv.y*cross(f,r));\n  vec3 p = ro;\n  vec2 d;\n  float shad, dO;\n  bool hit = false;\n  //bool bnc = false;\n  for(float i = 0.0; i<STEPS; i++){\n    p = ro+rd*dO;\n    d = map(p);\n    \n    if(abs(d.x)<0.005){\n      if(!bnc&&d.y==3.0){\n        vec3 n = norm(p);\n        ro = p+n*0.05;\n        rd = n;\n        dO = 0.0;\n        bnc = true;\n      }\n      else{\n        hit = true;\n      shad = i/STEPS;\n      break;\n      }\n    }\n    if(dO>MDIST){\n      dO=MDIST;\n      break;\n    }\n    dO+=d.x*0.8;\n  }\n  col+=glow*0.1;\n  \n  if(hit){\n    \n    vec3 ld = vec3(-1,1,1);\n    float shadow = 1.0;\n    for(float h = 0.4;h<100.0;){\n      float dd = map(p+ld*h).x;\n      if(dd<0.1){shadow = 0.; break;}\n      h+=dd*0.9;\n      shadow = min(shadow,dd*3.0);\n    }\n    shadow = max(0.4,shadow);\n    \n    vec3 n = norm(p);\n    //col = vec3(shad);\n    col += vec3(length(n*0.5+0.5))*0.6;\n    col *=shadow;\n    \n    if(d.y==5.0)col = glow*3.0;\n  }\n  \n  //if(bnc) col = 1.0-col;\n\tfragColor = vec4(col,0);\n}", "image_inputs": [{"id": "MlXXW2", "previewfilepath": "https://soundcloud.com/syntheofficial/moonstone", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/syntheofficial/moonstone", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sc3zj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[418, 418, 440, 440, 462], [463, 463, 498, 498, 527], [528, 528, 566, 566, 650], [651, 651, 687, 687, 769], [771, 771, 800, 800, 1050], [1051, 1051, 1068, 1068, 2517], [2518, 2518, 2536, 2536, 2653], [2655, 2655, 2712, 2712, 4100]]}
{"id": "7sdGDn", "name": "Rectangle twist", "author": "blastbuilder", "description": "Rectangle version", "tags": ["fractal"], "likes": 5, "viewed": 49, "date": "1629601349", "time_retrieved": "2024-06-20T20:46:38.809743", "image_code": "vec2 rot(vec2 uv,float a){\n\treturn vec2(uv.x*cos(a)-uv.y*sin(a),uv.y*cos(a)+uv.x*sin(a));\n}\n\nfloat draw(vec2 uv) {\n    uv -= vec2(0.75, 0.5);\n    uv = abs(uv);\n    float c = abs(max(uv.x, uv.y) - 0.15);\n    return clamp(10.0 * c, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2(fragCoord.x/iResolution.y - 0.5, fragCoord.y/iResolution.y - 0.5);\n\n    float s=1.3;\n    float c = draw(uv);\n    for(int i=0;i<300;i++){\n\t\tuv=uv * 1.04;\n\t\tuv=rot(uv, iTime / 105.0);\n\t\t//s=s/2.1;\n        c = min(c, draw(uv));\n\t}\n\n    // Output to screen\n    fragColor = vec4(c, c, c, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sdGDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 26, 26, 91], [93, 93, 114, 114, 242], [244, 244, 301, 351, 666]]}
{"id": "7st3DH", "name": "Persian carpet 4", "author": "jarble", "description": "A slightly simpler formula, with a much nicer range of colors.", "tags": ["fractal", "carpet", "rug"], "likes": 2, "viewed": 147, "date": "1629758307", "time_retrieved": "2024-06-20T20:46:39.283932", "image_code": "\n//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//to do: drag and drop using https://www.shadertoy.com/view/WdGGWh\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   //from David Hoskins' \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5*3./2.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    float t2 = floor((iTime+4.)/20.0+uv.x);\n    //vec3 random2 = hash31(1.+t2);\n    \n    \n    float offset = .25;\n    \n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        float scale1 = 1.0;\n        float t3 = float(c)+t2;\n        vec3 random2 = hash31(1.+t3);\n        float scale2 = 1.+random2.x;\n        //vec3 col_prev = 0.0;\n        for(int i=0;i<3;i++)\n        {\n            vec3 col_prev = col;\n            float factor = -1.1;\n            \n            uv = triangle_wave(uv.yx+1.5,scale)+triangle_wave(uv,scale);\n            uv.x *= factor;\n\n            uv = triangle_wave((uv+offset),scale);\n            uv.x /= factor;\n            \n            uv = triangle_wave(uv+offset,scale);\n            uv.x *= factor;\n            \n            uv = triangle_wave((uv+offset),scale);\n            uv.x /= factor;\n            \n            //uv.x *= -1.0;\n            //uv = triangle_wave(uv+c1.y,scale);\n            scale /= 1.+scale2*col.x;\n            //offset *= scale2/(1.+random4.x);\n            \n            //uv = -uv.yx;\n            //uv = uv.yx;\n            scale2 += col.x/8.;\n            if(i>0) col = (col.yzx*random2.x + col_prev*random2.y)/(random2.x+random2.y);\n            col[c] = fract((uv.x)-(uv.y));\n\n            \n\n        }\n\n            //random3 = (hash31(2.+t3)-vec3(.5))/4.;\n            //random4 = (hash31(3.+t3)-vec3(.5))/4.;\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7st3DH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[346, 456, 478, 523, 656], [658, 658, 697, 697, 742], [744, 744, 801, 801, 2466]]}
{"id": "7t2Szc", "name": "Orange Glow", "author": "user_name", "description": "I don't like my code. :)", "tags": ["procedural", "2d", "noise"], "likes": 8, "viewed": 201, "date": "1628284169", "time_retrieved": "2024-06-20T20:46:39.526245", "image_code": "float n(vec2 v) {\nreturn fract(cos(dot(v, vec2(3.12394978, 6.24381234))) * 203489.1234);\n}\nfloat snap(float a, float b){\n    return floor(a / b) * b;\n}\nfloat n2(vec2 v){\nv.y=snap(v.y,1.0);\nfloat a=n(vec2(v.x,v.y));\nfloat b=n(vec2(v.x,v.y+1.0));\nreturn mix(a,b,v.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = fragCoord/iResolution.x;\n    vec2 uv3 = fragCoord/iResolution.x;\n    uv3.y += iTime * 0.1 * (n(vec2(snap(uv2.x, 0.02), 0.0)) * 0.5 + 0.5);\n    uv3.y+=n2(vec2(snap(uv3.x,0.02),uv3.y/0.015))*0.04;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    float dith = length(vec2(snap(uv.x, 0.02), snap(uv.y, 0.04 * iResolution.x / iResolution.y)) - 0.5);\n    float mid = n(vec2(snap(uv2.x, 0.02), snap(uv2.y, 0.02)))*0.2+0.4;\n    mid -= 2.0;\n    mid += dith * 3.0;\n    mid += length(uv - 0.5) * 1.0 - 0.2;\n    uv3.y += n(vec2(snap(uv3.x, 0.02), 0.0));\n    float mad = n(vec2(snap(uv3.x, 0.02), snap(uv3.y, 0.06)));\n    float fac=fract(uv.x/0.02);\n    fac=smoothstep(0.0,0.1,fac)*smoothstep(1.0,0.9,fac);\n    float fac2=fract(uv3.y/0.06);\n    fac*=smoothstep(0.0,0.05,fac2)*smoothstep(1.0,0.95,fac2);\n    float gry=smoothstep(mid+0.01,mid,mad)*fac + pow(length(uv - 0.5),2.0);\n    fragColor = vec4(vec3(gry)*vec3(1.2,0.55,0.2),1.0);\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7t2Szc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 17, 17, 90], [91, 91, 120, 120, 151], [152, 152, 169, 169, 267], [269, 269, 326, 376, 1425]]}
{"id": "7t2XDd", "name": "3D Barycentric Interpolation", "author": "Sambi", "description": "Uses barycentric coords to map the coordinates of a 2x2 unit cube onto an arbitrary convex irregular cube. The values of this regular unit cube are then used to colour the irregular cube. Could be seen as inverse trilinear interpolation.", "tags": ["raymarch", "sdf", "barycentric", "lerp", "trilinear", "interpolation"], "likes": 0, "viewed": 138, "date": "1628972889", "time_retrieved": "2024-06-20T20:46:40.605058", "image_code": "#define ROT rotationMatrix(vec3(1.0, 0.0, 0.0), iTime * 0.5)\n\n// define the unit 2x2 cube centred on the origin by 8 corners.\n#define uT0 vec3(-1.0, 1.0, -1.0)\n#define uT1 vec3(1.0, 1.0, -1.0)\n#define uT2 vec3(1.0, 1.0, 1.0)\n#define uT3 vec3(-1.0, 1.0, 1.0)\n#define uB0 vec3(-1.0, -1.0, -1.0)\n#define uB1 vec3(1.0, -1.0, -1.0)\n#define uB2 vec3(1.0, -1.0, 1.0)\n#define uB3 vec3(-1.0, -1.0, 1.0)\n\n// deform the unit cube. this is what we'll raymarch, and we'll map positions back onto the\n// unit cube to determine colour using barycentric coordinates.\n#define T0 (ROT * vec4(uT0, 1.0) + vec4(sin(iTime), 0.0, cos(iTime), 0.0) * 0.5).xyz\n#define T1 (ROT * vec4(uT1, 1.0) + vec4(0.0, sin(iTime), cos(iTime), 0.0) * 0.5).xyz\n#define T2 (ROT * vec4(uT2, 1.0) + vec4(cos(iTime), sin(iTime), 0.0, 0.0) * 0.5).xyz\n#define T3 (ROT * vec4(uT3, 1.0) + vec4(0.0, 0.0, 0.0, 0.0) * 0.5).xyz\n#define B0 (ROT * vec4(uB0, 1.0) + vec4(cos(iTime), sin(iTime), 0.0, 0.0) * 0.5).xyz\n#define B1 (ROT * vec4(uB1, 1.0) + vec4(0.0, 0.0, 0.0, 0.0) * 0.5).xyz\n#define B2 (ROT * vec4(uB2, 1.0) + vec4(sin(iTime), 0.0, cos(iTime), 0.0) * 0.5).xyz\n#define B3 (ROT * vec4(uB3, 1.0) + vec4(0.0, sin(iTime), cos(iTime), 0.0) * 0.5).xyz\n\nstruct Tetrahedra\n{\n    vec3 p0;\n    vec3 p1;\n    vec3 p2;\n    vec3 p3;\n};\n\nTetrahedra uTet[5];\nTetrahedra tet[5];\nint numTet = 5;\n\n// Utils ------------------------------------------------------------------\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n// SDF ------------------------------------------------------------------\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat sdTri( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nvec4 opU(vec4 d1, vec4 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nvec4 sdf(in vec3 pos)\n{\n    vec4 res = vec4(1e10, 0.0, 0.0, 0.0);\n    for (int i = 0; i < numTet; i++)\n    {\n        res = opU(res, vec4(sdTri(pos, tet[i].p0, tet[i].p1, tet[i].p2), 0.0, 0.0, 0.0));\n        res = opU(res, vec4(sdTri(pos, tet[i].p0, tet[i].p2, tet[i].p3), 0.0, 0.0, 0.0));\n        res = opU(res, vec4(sdTri(pos, tet[i].p0, tet[i].p3, tet[i].p1), 0.0, 0.0, 0.0));\n        res = opU(res, vec4(sdTri(pos, tet[i].p1, tet[i].p3, tet[i].p2), 0.0, 0.0, 0.0));\n    }    \n    return res;\n}\n\n// Interpolation ------------------------------------------------------------------\n\n// calculate barycentric coordinates from the 4 tetrahedron verts.\nvec4 bary(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    vec3 vap = p - a;\n    vec3 vbp = p - b;\n    vec3 vab = b - a;\n    vec3 vac = c - a;\n    vec3 vad = d - a;\n    vec3 vbc = c - b;\n    vec3 vbd = d - b;    \n    float v6 = 1.0 / dot(vab, cross(vac, vad));\n    float va6 = dot(vbp, cross(vbd, vbc)) * v6;\n    float vb6 = dot(vap, cross(vac, vad)) * v6;\n    float vc6 = dot(vap, cross(vad, vab)) * v6;\n    return vec4(va6, vb6, vc6, 1.0 - va6 - vb6 - vc6);\n}\n\n// calculate cartesian from barycentric coordinates using 4 tetrahedron verts. \nvec3 invBary(vec4 bary, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    vec3 ret = vec3(0.0);\n    ret.x = bary.x * a.x + bary.y * b.x + bary.z * c.x + bary.w * d.x;\n    ret.y = bary.x * a.y + bary.y * b.y + bary.z * c.y + bary.w * d.y;\n    ret.z = bary.x * a.z + bary.y * b.z + bary.z * c.z + bary.w * d.z;\n    return ret;\n}\n\n// map cartesian coordinate onto unit cube using barycentric coordinates.\nvec3 mapToUnitCube(vec3 pos)\n{\n    float highest = -999.9;\n    vec4 b = vec4(0.0);\n    int iT = -1;\n    \n    // determine which tetrahedron the point is closest to (if not inside)\n    // by finding the barycentric coords of each tetrahedron with the largest\n    // minimum.\n    for (int i = 0; i < tet.length(); i++)\n    {\n        vec4 bTest = bary(pos, tet[i].p0, tet[i].p1, tet[i].p2, tet[i].p3);\n        float low = min(min(min(bTest.x, bTest.y), bTest.z), bTest.w);\n        if (low >= 0.0)\n        {\n            // if all barycentric coords are positive, point is definitely within\n            // that tetrahedra.\n            b = bTest;\n            iT = i;\n            break;\n        }\n        else if (low > highest)\n        {\n            b = bTest;\n            highest = low;\n            iT = i;\n        }\n    }\n    // take the barycentric coords of point on the nearest tetrahedron, and\n    // convert back into cartesian coords using the corresponding unit tetrahedron.\n    return invBary(b, uTet[iT].p0, uTet[iT].p1, uTet[iT].p2, uTet[iT].p3);\n}\n\n// Rendering ------------------------------------------------------------------\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    // background\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    \n    // raycast scene\n    float t = 0.0;\n    for(int i = 0; i < 90; i++)\n    {\n        vec3 p = ro + rd * t;\n        vec4 h = sdf(p);        \n        if(h.x < (0.001 * t))\n        {\n            col = mapToUnitCube(p);\n            break;\n        }\n        t += h.x;\n        if (t > 7.0)\n            break;\n    }\n\treturn col;\n}\n\nmat3 calcLookAtMatrix(in vec3 ro, in vec3 ta, in float roll)\n{\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,vec3(sin(roll),cos(roll),0.0)));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    \n    // drag along x to show/hide tetrahedrons\n    vec2 m = iMouse.xy / iResolution.xy;\n    numTet = 5 - int(m.x * 6.0);\n    \n    // break the cube down into 5 tetrahedra\n    tet[0] = Tetrahedra(T1, B2, T3, B0); // centre\n    tet[1] = Tetrahedra(T0, T1, T3, B0); // t0\n    tet[2] = Tetrahedra(T2, T3, T1, B2); // t2\n    tet[3] = Tetrahedra(B1, B0, B2, T1); // b1\n    tet[4] = Tetrahedra(B3, B2, B0, T3); // b3\n    \n    // this is our unit tetrahedra we're mapping onto\n    uTet[0] = Tetrahedra(uT1, uB2, uT3, uB0); // centre\n    uTet[1] = Tetrahedra(uT0, uT1, uT3, uB0); // t0\n    uTet[2] = Tetrahedra(uT2, uT3, uT1, uB2); // t2\n    uTet[3] = Tetrahedra(uB1, uB0, uB2, uT1); // b1\n    uTet[4] = Tetrahedra(uB3, uB2, uB0, uT3); // b3\n\n    // camera\n    vec3 ro = vec3(5.0 * sin(iTime * 0.5), 2.0, 5.0 * cos(iTime * 0.5));\n    mat3 camMat = calcLookAtMatrix(ro, vec3(0.0, 0.0, 0.0), 0.0);\n    \n\t// view ray\n\tvec3 rd = normalize(camMat * vec3(p.xy, 2.0));\n\n    // render\n    fragColor = vec4(render(ro, rd), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7t2XDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1336, 1413, 1458, 1458, 2081], [2083, 2158, 2183, 2183, 2202], [2203, 2203, 2250, 2250, 2747], [2749, 2749, 2777, 2777, 2812], [2814, 2814, 2837, 2837, 3310], [3397, 3464, 3515, 3515, 3922], [3924, 4004, 4061, 4061, 4318], [4320, 4394, 4424, 4424, 5448], [5450, 5531, 5568, 5586, 5952], [5954, 5954, 6016, 6016, 6186], [6188, 6188, 6245, 6245, 7327]]}
{"id": "7t2XDK", "name": "Displacement Sphere", "author": "kithy", "description": "displacement sphere surface.", "tags": ["raymarching", "displacement"], "likes": 1, "viewed": 108, "date": "1628692995", "time_retrieved": "2024-06-20T20:46:40.611214", "image_code": "#define ITR 128\n#define EPS 0.001\n\nmat2 rot(float angle){\n\tfloat s=sin(angle);\n\tfloat c=cos(angle);\n\treturn mat2(s,-c,c,s);\n}\n\nfloat sdSphere(vec3 p){\n\treturn length(p)-1.0;\n}\n\n//from iq\nfloat displacement(vec3 p){\n\treturn sin(10.0*p.x)*sin(10.0*p.y)*sin(10.0*p.z)*sin(iTime);\n}\n\nfloat mainDist(vec3 p){\n\tp.xy*=rot(iTime*0.5);\n\tp.xz*=rot(iTime*0.5);\n\tfloat d1=sdSphere(p);\n\tfloat d2=displacement(p);\n\treturn d1+d2;\n}\n\n//generate normal of sphere\nvec3 genNormal(vec3 p){\n\treturn normalize(p);\n}\n\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tvec3 ro=vec3(0.0,0.0,-9.0);\n\tvec3 lookat=vec3(0.0,0.0,0.0);\n\tfloat zoom=5.0;\n\n\tvec3 f=normalize(lookat-ro);\n\tvec3 r=normalize(cross(vec3(0.0,1.0,0.0),f));\n\tvec3 u=cross(f,r);\n\tvec3 c=ro+f*zoom;\n\tvec3 i=c+uv.x*r+uv.y*u;\n\tvec3 rd=normalize(i-ro);\n   \n    float d,t;\n    vec3 p,n;\n\n\tvec3 col=vec3(0.0);\n    \n    for(int i=0;i<ITR;i++){\n        p=ro+rd*t;\n        d=mainDist(p);\n        n=genNormal(p);\n        if(d<EPS)break;\n        t+=d;\n    }\n\tcol=n*0.5+0.5;\n\n\tfragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7t2XDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[35, 35, 57, 57, 125], [127, 127, 150, 150, 175], [177, 187, 214, 214, 278], [280, 280, 303, 303, 416], [418, 446, 469, 469, 493], [497, 497, 550, 550, 1097]]}
{"id": "7tBSDd", "name": "粒子", "author": "tangyuan", "description": "粒子作业", "tags": ["2d"], "likes": 3, "viewed": 77, "date": "1628863593", "time_retrieved": "2024-06-20T20:46:40.611214", "image_code": "//随机数1in 2out\nvec2 hash21(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//随机数1in 1out\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// ------------------------------------------------------------------------\n\n//着色函数\nvec3 color(float t) {\n    // from IQ's color pattern\n    return .3 + .7 * cos(6.283 * (vec3(1., .5, .0) * (1. - t) + vec3(.7, .75, .3)));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // -1 - 1\n    vec2 uv = fragCoord / iResolution.y * 2. - 1.;\n    \n    vec3 col = vec3(0., 0., 0.);\n    \n    for(int i = 0; i < 20; i ++){\n        //获取id\n        float id = floor(iTime + float(i) * 3303.1031);\n        //随机大小0- 1\n        float random = hash11(id);\n        \n        //随机位置 0- 1 => -.5 - .5\n        vec2 pos = hash21(id) * 0.5 - 0.5;\n        \n        // -1 - 1  => \n        vec2 off = vec2(cos(iTime * 0.1 + random) * 0.5, - fract(iTime * 0.3 + random) + 1.);\n   \n        vec2 newuv = uv + pos + off;\n        \n        float l = length(newuv);\n        \n        float sdf = random * 0.01 / l;\n        vec3 rancolor = color(fract(id));\n        col += rancolor * sdf;\n    }\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7tBSDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 20, 42, 42, 176], [178, 198, 221, 221, 306], [385, 400, 421, 452, 539], [543, 543, 600, 614, 1345]]}
{"id": "7tBSR1", "name": "Rave Lasers", "author": "R3N", "description": "Lasers and fog machines", "tags": ["light", "smoke", "laser"], "likes": 24, "viewed": 487, "date": "1629301539", "time_retrieved": "2024-06-20T20:46:40.950549", "image_code": "// Rand value between 0 and 1\nfloat rand(vec2 p) {\n\treturn fract(sin(dot(p, vec2(12.543,514.123)))*4732.12);\n}\n\n// Value noise\nfloat noise(vec2 p) {\n\tvec2 f = smoothstep(0.0, 1.0, fract(p));\n\tvec2 i = floor(p);\n\tfloat a = rand(i);\n\tfloat b = rand(i+vec2(1.0,0.0));\n\tfloat c = rand(i+vec2(0.0,1.0));\n\tfloat d = rand(i+vec2(1.0,1.0));\n\treturn mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n\t\n}\n\n// Fractal noise\nfloat fbm(vec2 p) {\n    float a = 0.5;\n    float r = 0.0;\n    for (int i = 0; i < 8; i++) {\n        r += a*noise(p);\n        a *= 0.5;\n        p *= 2.0;\n    }\n    return r;\n}\n\n// Lasers originating from a central point\nfloat laser(vec2 p, int num) {\n\tfloat r = atan(p.x, p.y);\n\tfloat sn = sin(r*float(num)+iTime);\n    float lzr = 0.5+0.5*sn;\n    lzr = lzr*lzr*lzr*lzr*lzr;\n    float glow = pow(clamp(sn, 0.0, 1.0),100.0);\n\treturn lzr+glow;\n}\n\n// Mix of fractal noises to simulate fog\nfloat clouds(vec2 uv) {\n    vec2 t = vec2(0,iTime);\n\tfloat c1 = fbm(fbm(uv*3.0)*0.75+uv*3.0+t/3.0);\n\tfloat c2 = fbm(fbm(uv*2.0)*0.5+uv*7.0+t/3.0);\n\tfloat c3 = fbm(fbm(uv*10.0-t)*0.75+uv*5.0+t/6.0);\n    float r = mix(c1, c2, c3*c3);\n\treturn r*r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 hs = iResolution.xy/iResolution.y*0.5;\n    vec2 uvc = uv-hs;\n\tfloat l = (1.0 + 3.0*noise(vec2(15.0-iTime)))\n        * laser(vec2(uv.x+0.5, uv.y*(0.5 + 10.0*noise(vec2(iTime/5.0))) + 0.1), 15);\n\tl += fbm(vec2(2.0*iTime))\n        * laser(vec2(hs.x-uvc.x-0.2, uv.y+0.1), 25);\n\tl += noise(vec2(iTime-73.0))\n        * laser(vec2(uvc.x, 1.0-uv.y+0.5), 30);\n    float c = clouds(uv);\n    vec4 col = vec4(0, 1, 0, 1)*(uv.y*l+uv.y*uv.y)*c;\n    fragColor = pow(col, vec4(0.75));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7tBSR1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 30, 50, 50, 110], [112, 127, 148, 148, 386], [388, 405, 424, 424, 579], [581, 624, 654, 654, 846], [848, 889, 912, 912, 1135], [1137, 1137, 1193, 1193, 1712]]}
{"id": "7tBSRV", "name": "70s Petals", "author": "JennySchub", "description": "I like it a lot", "tags": ["flower", "petals", "70s"], "likes": 20, "viewed": 250, "date": "1628057289", "time_retrieved": "2024-06-20T20:46:40.950549", "image_code": "#define PI 3.141592653 \n#define countX 17.\n#define petalWidth .4\n#define AA 2.\n\nvec3 colMap(float v) {\n\n\tv=mod(v, PI+1.3)-.8;\t\n    return vec3(\n\t\tsin(sin(v-.6)),\n\t\tsin(sin(v)),\n\t\tsin(sin(v+.8))\n\t);\n\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    for(float aa=0.; aa<AA; aa++){\n        for(float bb=0.; bb<AA; bb++){\n\n            vec2 uv = (fragCoord + vec2(aa,bb)*1./AA)/iResolution.xy;\n\n\n            uv-=.5;\n            uv.y*=iResolution.y/iResolution.x;\n            uv*=2.;\n\n            float tim=-iTime*.1;\n            float posintim=sin(tim)*.5+.5;\n            float dst=length(uv);\n            vec2 tuv = vec2(0.,dst);\n            vec2 id = vec2(0.);\n            float zoomSpeed=tim*.4;\n            float angle1=(atan(uv.x,uv.y)/PI*.5+.5)+zoomSpeed + tim*.3;\n            float angle2=angle1-2.*zoomSpeed;\n            float add=pow(dst, posintim*.7+.1)*countX*petalWidth;\n            tuv.x=mod(angle1*countX+add, 1.);\n            tuv.y=mod(angle2*countX-add, 1.);\n            id.x=ceil(angle1*countX+add);\n            id.y=floor(angle2*countX-add);\n            float edgeDist = max(max(tuv.x, tuv.y), max(1.-tuv.x, 1.-tuv.y));\n            tuv-=.5;\n            tuv*=dst*3.;\n            float t=log(dst+1.6);\n            float v=abs(tuv.x+tuv.y)+pow(tuv.y-tuv.x, 2.);\n            v+=posintim *pow(edgeDist,25.);\n            vec3 col=vec3(smoothstep(t+.1,t,v) );\n            col*=colMap(abs(id.x-id.y)*.4);\n\n\n            fragColor += vec4(col/(AA*AA),1.0);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7tBSRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[80, 80, 102, 102, 200], [203, 203, 260, 260, 1494]]}
{"id": "7tBSWG", "name": "first try at domain warping", "author": "wnu", "description": "dw", "tags": ["dw"], "likes": 11, "viewed": 182, "date": "1628492586", "time_retrieved": "2024-06-20T20:46:42.671971", "image_code": "#define PI 3.1415926538\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat simnoise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) )*0.5;\n}\n\n// * The MIT License\n// * Copyright © 2013 Nikita Miropolskiy\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvec2 skew (vec2 st) {\n    vec2 r = vec2(0.0);\n    r.x = 1.1547*st.x;\n    r.y = st.y+0.5*r.x;\n    return r;\n}\n\nvec3 simplexGrid (vec2 st) {\n    vec3 xyz = vec3(0.0);\n\n    vec2 p = fract(skew(st));\n    if (p.x > p.y) {\n        xyz.xy = 1.0-vec2(p.x,p.y-p.x);\n        xyz.z = p.y;\n    } else {\n        xyz.yz = 1.0-vec2(p.x-p.y,p.y);\n        xyz.x = p.x;\n    }\n\n    return fract(xyz);\n}\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\nfloat ridgeNoise(vec2 _st, float t){\n    float n = abs(simnoise(_st));\n    while(n > t){\n        n = t - (n - t);\n        if(n < 0.) {n = -n;}\n    }\n    \n    return pow(n/t,0.31); // this value is good for tweaking\n    \n}\n\nfloat ridgeNoise3(vec3 _st, float t){\n    float n = abs(simplex3d(_st));\n    while(n > t){\n        n = t - (n - t);\n        if(n < 0.) {n = -n;}\n    }\n    \n    return pow(n/t,0.31); // this value is good for tweaking\n    \n}\n\n\n\n#define NUM_OCTAVES 3\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    float offset = 0.;\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        //v += a * sin((_st.y + _st.x+ _st.y)*10.)*1.5;\n        offset += a*2.5;\n        v += a * ridgeNoise(_st,0.3)*2.5;\n        _st = _st * 2. + shift;\n        a *= 0.5;\n    }\n    return v/offset;\n}\n\nfloat fbm3 ( in vec3 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100.0);\n    float offset = 0.;\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        //v += a * sin((_st.y + _st.x+ _st.y)*10.)*1.5;\n        offset += a*2.5;\n        v += a * ridgeNoise3(_st,0.3)*2.5;\n        _st = _st * 2. + shift;\n        a *= 0.5;\n    }\n    return v/offset;\n}\n\nfloat fbmN(vec2 _st, int n){\n\tfloat v = 0.;\n    for (int i = 0;i<4;i++){\n        if(i>=n) break;\n        v= fbm(_st + v*4.);\n    }\n    \n    return v;\n}\n\nfloat thresh = 0.5;\n\nvec2 warp (vec2 p, float maxDist){\n    float angle = fbm(p*4.1) * PI*2.;\n    float dist = fbm(p*4.) * maxDist;// dist high angle gives like acid like look, reverse gives whisps?\n    vec2 offset = vec2(cos(angle),sin(angle))*dist;\n    return p + offset;\n}\n\nvec2 warp3 (vec3 p, float maxDist){\n    float angle = fbm3(p*4.1) * PI*2.;\n    float dist = fbm3(p*4.) * maxDist;// dist high angle gives like acid like look, reverse gives whisps?\n    vec2 offset = vec2(cos(angle),sin(angle))*dist;\n    return p.xy + offset;\n}\n\nfloat noise2(vec2 p){\n    return ridgeNoise(warp(p,0.1),thresh);\n}\n\nvec2 warp2 (vec2 p, float maxDist){\n    float angle = noise2(p*4.1) * PI*2.;\n    float dist = noise2(p*4.) * maxDist;// dist high angle gives like acid like look, reverse gives whisps?\n    vec2 offset = vec2(cos(angle),sin(angle))*dist;\n    return p + offset;\n}\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord/R -0.5);\n    uv.x *= R.x/R.y;\n\n    // Time varying pixel color\n    //vec3 col = vec3(noise(uv*10.));\n    //vec3 col = vec3(ridgeNoise(uv*2.,0.55));\n    \n    uv = warp3(vec3(uv*1.,iTime/20.),0.08);\n    \n    float diam = 0.5;\n    float e = 0.5;\n    float circle = smoothstep(diam,diam - e,length(uv));\n    //maybe use somethnig other than smooth step to only smooth the bottom\n    \n    \n    vec3 col = vec3(circle);\n    col = vec3(hsl2rgb(vec3(circle*0.4-0.25,0.8,circle)))*circle;\n    col = 1. - col;\n    col.r = pow(col.r,0.6);\n    //col = vec3(noise2(uv*1.));\n    //col = vec3(ridgeNoise(uv*10.,0.3));\n    //col = vec3(fbm(uv*5.));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7tBSWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[25, 25, 53, 53, 161], [163, 163, 220, 220, 335], [337, 337, 366, 366, 849], [851, 915, 937, 937, 1110], [1217, 1240, 1265, 1518, 2435], [2438, 2438, 2465, 2465, 2847], [2849, 2849, 2870, 2870, 2957], [2959, 2959, 2987, 2987, 3232], [3234, 3234, 3255, 3255, 3302], [3303, 3303, 3324, 3324, 3371], [3372, 3372, 3394, 3394, 3429], [3431, 3431, 3453, 3506, 5203], [5205, 5205, 5241, 5241, 5426], [5428, 5428, 5465, 5465, 5651], [5678, 5678, 5704, 5704, 6041], [6043, 6043, 6070, 6070, 6408], [6410, 6410, 6438, 6438, 6561], [6584, 6584, 6618, 6618, 6838], [6840, 6840, 6875, 6875, 7100], [7102, 7102, 7123, 7123, 7168], [7170, 7170, 7205, 7205, 7431], [7433, 7433, 7460, 7460, 7603], [7606, 7606, 7663, 7713, 8457]]}
{"id": "7tBXRt", "name": "Patterned_Circles", "author": "Dmitry_Gantimurov", "description": "Hypnodance", "tags": ["shader"], "likes": 2, "viewed": 35, "date": "1628352822", "time_retrieved": "2024-06-20T20:46:42.671971", "image_code": "float BlackCircle(vec2 uv, vec2 p, float r, float blur) {\n\n    float d = length(uv - p);\n    float c = smoothstep(r - blur, r, d);\n    \n    return c;\n}\n\nfloat RoundLine(vec2 uv, vec2 p, float r, float thickness) {\n    float c = BlackCircle(uv, p, r, 0.);\n    c += 1. - BlackCircle(uv, p, r - thickness, 0.);\n    \n    return c;\n}\n\nfloat PatternedCircle(vec2 uv, vec2 p, float r, float thickness, float gap) {\n    \n    float c = RoundLine(uv, p, r, thickness);\n    \n    float new_r = r - (thickness + gap);\n    for(new_r; new_r > 0.; new_r -= (thickness+gap)) {\n    \n        c *= RoundLine(uv, p, new_r, thickness);\n    \n    }\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    uv *= 5.;\n    vec3 col = vec3(1.0);\n    \n    vec2 p = vec2(0.);\n    \n    vec2 gv = fract(uv) - .5;\n    vec2 id = floor(uv);\n    //float c = PatternedCircle(gv, p, 0.6, 0.02, 0.03);\n    float c = PatternedCircle(gv, p, 0.6, abs(3.*sin(iTime*0.1)*0.01), abs(3.*cos(iTime*0.1)*0.01));\n    col *= c;\n    //if(gv.x>.48 || gv.y>.48) col.r = 0.;\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7tBXRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 151], [153, 153, 213, 213, 328], [330, 330, 407, 407, 640], [643, 643, 700, 700, 1161]]}
{"id": "7tjSRK", "name": "Eyes of Sauron", "author": "Smake", "description": "next step with left eye of Sauron  - glasses of Sauron )", "tags": ["eye", "organic", "parametric"], "likes": 9, "viewed": 112, "date": "1628117573", "time_retrieved": "2024-06-20T20:46:42.671971", "image_code": "// started from Trisomie21's \"Ball Of Fire\" https://www.shadertoy.com/view/lsf3RH\n// \n\nfloat snoise(vec3 uv, float res)\n{\n\tvec3 s = vec3(1e0, 1e1, 1e2);\n\tuv *= res;\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\n\tvec4 r = fract(sin(v*1e-1)*1e3);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\t//vec2 p = -.5 + fragCoord.xy / iResolution.xy;\n    vec2 pL,pR;\n    pL.x = -1.4 + 2.*fragCoord.x / iResolution.x;  //-.5: -1.5 - shift x\n    pL.y = -1. + 2.*fragCoord.y / iResolution.y;\n\tpR.x = .6 - 2.*fragCoord.x / iResolution.x;  //-.5: shift, - mirror\n    pR.y = -1. + 2.*fragCoord.y / iResolution.y;\n    \n    \n    float colorL =2.5 - (2.5*length(2.*pL));\n\tvec3 coordL = vec3(atan(pL.x+.5,pL.y)/6.3, length(pL)*.4, .5);\n\tfor(int i = 1; i <= 7; i++)\t{\n\t\tfloat power = pow(2.0, float(i));\n\t\tcolorL += (1.5 / power) * snoise(coordL + vec3(0.,-iTime*.01, iTime*.01), power*20.);\n\t}\n    if (fragCoord.x>iResolution.x/2.)\n    fragColor = vec4( colorL, pow(max(colorL,0.),2.)*0.4, pow(max(colorL,0.),3.)*0.15 , 1.0);\n\n    float colorR =2.5 - (2.5*length(2.*pR));\n\tvec3 coordR = vec3(atan(pR.x+.5,pR.y)/6.3, length(pR)*.4, .5);\n\tfor(int i = 1; i <= 7; i++)\t{\n\t\tfloat power = pow(2.0, float(i));\n\t\tcolorR += (1.5 / power) * snoise(coordR + vec3(0.,-iTime*.01, iTime*.01), power*20.);\n\t}\n     if (fragCoord.x<iResolution.x/2.)\n   fragColor += vec4( colorR, pow(max(colorR,0.),2.)*0.4, pow(max(colorR,0.),3.)*0.15 , 1.0);\n\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7tjSRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 87, 121, 121, 636], [638, 638, 696, 745, 1815]]}
{"id": "7tjSWy", "name": "Surveillance mosaic", "author": "felipetovarhenao", "description": "Animated eye mosaic using value noise, and shaping functions.", "tags": ["sdf", "eyes", "mosaic"], "likes": 27, "viewed": 175, "date": "1628549025", "time_retrieved": "2024-06-20T20:46:43.605487", "image_code": "/*\n    Author: Felipe Tovar-Henao [www.felipe-tovar-henao.com]\n    Description: Animated eye mosaic using value noise, and shaping functions.\n*/\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define edge 0.005\n\n\n/* -------- SHAPERS/MISC -------- */\nfloat fold(in float x) {\n    return abs(mod(x+1.0,2.0)-1.0);\n}\n\nfloat reliRamp(in float x, in float s) {\n    return floor(x) + clamp((max(1.0, s)*(fract(x) - 0.5)) + 0.5, 0.0, 1.0);\n}\n\nfloat cosine_ramp(in float x, in float s) {\n    float y = cos(fract(x)*3.14159265359);\n    return floor(x) + 0.5 - (0.5*pow(abs(y), 1.0/s)*sign(y));\n}\nfloat camel_ramp(in float x, in float s) {\n    float y = fract(x);\n    return floor(x) + pow(0.5 - (0.5 * cos(6.28318530718*y) * cos(3.14159265359*y)), s);\n}\n\nvec2 rotate2D(in vec2 vUV, in float theta) {\n    return vUV * mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\n\nfloat scale(in float x, in float inmin, in float inmax, in float outmin, in float outmax) {\n    return ((x-inmin)/(inmax-inmin))*(outmax-outmin)+outmin;\n}\n\n/* -------- NOISE -------- */\nfloat random1D(in vec2 vUV, in int seed) {\n    return fract(abs(sin(dot(vUV, vec2(11.13, 57.05)) + float(seed)) * 48240.41));\n}\n\nfloat value_noise(in vec2 vUV, in int seed) {\n    vec2 x = floor(vUV);\n    vec2 m = fract(vUV);\n\n    float bl = random1D(x, seed);\n    float br = random1D(x + vec2(1.0, 0.0), seed);\n    float tl = random1D(x + vec2(0.0, 1.0), seed);\n    float tr = random1D(x + vec2(1.0, 1.0), seed);\n\n    vec2 cf = smoothstep(vec2(0.0), vec2(1.0), m);\n\n    float tm = mix(tl, tr, cf.x);\n    float bm = mix(bl, br, cf.x);\n\n    return mix(bm, tm, cf.y);\n}\n\n/* -------- EYE FUNCTIONS -------- */\nfloat eyeSDF(in vec2 vUV, in float s) {\n    float o = 0.125;\n    vec2 uv = abs(vUV*vec2(1. + o, 1.0));\n    float x = clamp(uv.x*(1.-o),0.0,0.5);\n    uv -= vec2(0.5, pow(cos(x*PI)/s, s));\n    return length(max(vec2(0.0), uv)) + min(0.0, max(uv.x, uv.y));\n}\n\nvec4 mk_tearduct(in float sdf, in float t) {\n    vec3 col = mix(vec3(0.0, 0.0, 0.0), vec3(0.8471, 0.8471, 0.8471), cosine_ramp(fold(sdf*60.0 + t*0.25), 2.0));\n    float a = smoothstep(edge, 0.0, sdf+edge);\n    return vec4(col, a);\n}\n\nvec4 mk_eyelids(in float sdf) {\n    return smoothstep(edge*2.0, 0.0, abs(sdf)-0.01) * vec4(0.6471, 0.6471, 0.6471, 1.0);\n}\n\nvec4 mk_sclera(in vec2 vUV, in float d, in float t) {\n    float g = rotate2D(vUV, length(vUV)*TWO_PI*sin(t*0.1) + t*0.01).y;\n    vec3 glow = smoothstep(edge, 0.0, g) * vec3(1.0);\n    vec4 sclera = smoothstep(edge, 0.0, d-0.25) * vec4(0.8275, 0.8235, 0.8235, 1.0);\n    vec4 border = smoothstep(edge, 0.0, abs(d-0.25)-0.0025) * vec4(0.2549, 0.2549, 0.2549, 1.0);\n    sclera.rgb = mix(sclera.rgb, glow, glow.r);\n    sclera = mix(sclera, border, border.a);\n    return sclera;\n}\n\nvec4 mk_iris(in vec2 vUV, in float d, in float t) {\n    float a = atan(vUV.x, vUV.y);\n    vec3 col = mix(vec3(0.6784, 0.7922, 0.8431), vec3(0.6118, 0.7255, 0.7804), fold(cosine_ramp(sin(a*3.0*cos(a*2.0)+t*0.5), 4.0)));\n    col = mix(col, vec3(0.7765, 0.8196, 0.8392), cosine_ramp(cos(3.0*a*sin(-a*1.5) + t*0.4)* 0.5 + 0.5, 4.0));\n    vec4 iris = smoothstep(edge, 0.0, d-0.125) * vec4(col, 1.0);\n    vec4 border = smoothstep(edge, 0.0, abs(d-0.125)-0.002) * vec4(0.2627, 0.2353, 0.2353, 1.0);\n\n    float shade = cos(a+t*0.25)*0.5+0.5;\n    shade *= shade;\n    shade = cosine_ramp(shade, 4.0);\n    iris = mix(iris, border, border.a);\n    iris.rgb = mix(iris.rgb, vec3(0.3529, 0.4627, 0.4941), shade*0.75);\n    \n    return iris;\n} \n\nvec4 mk_pupil(in float d, in float t) {\n    t = sin(d+t*0.125)*0.01;\n    return smoothstep(edge, 0.0, d-0.05+t) * vec4(0.0627, 0.0588, 0.0588, 1.0);\n}\n\nvec4 mk_glow(in vec2 vUV, in float t) {\n    float d = length(vUV);\n    vUV *= vec2(sin(d*2.123 - t*0.798347), cos(d*3.123 + t*0.91823))*0.1 + 1.0;\n    d = length((vUV-(vUV.y*0.1))-0.05);\n\n    vec4 glow = smoothstep(edge*1.5, 0.0, d-0.03) * vec4(1.0);\n\n    d = length((vUV-(vUV.y*0.1))+0.05);\n    glow = mix(glow, smoothstep(edge*1.25, 0.0, d-0.02) * vec4(1.0), 1.0-glow.a);\n\n    return glow;\n}\n\nvec4 mk_retina(in vec2 vUV, in float t) {\n    vec4 retina = vec4(0.0);\n    vUV *= length(vUV)*1.5+1.0;\n    vUV += vec2(cos(t*0.98), sin(t*0.234))*0.08;\n    float d = length(vUV);\n    vec4 glow = mk_glow(vUV, t);\n    vec4 iris = mk_iris(vUV, d, t);;\n    vec4 pupil = mk_pupil(d+sin(t*0.5 + 0.12)*0.005, t);    \n\n    retina = mix(retina, iris, iris.a);\n    retina = mix(retina, pupil, pupil.a*retina.a);\n    retina = mix(retina, glow, glow.a*0.975*iris.a);\n\n    return retina;\n}\n\nvec4 mk_eyeball(in vec2 vUV, in float t) {\n    float d = length(vUV);\n    vec4 eyeball = vec4(0.0);\n    vec4 sclera = mk_sclera(vUV, d, t);\n    vec4 retina = mk_retina(vUV, t + reliRamp(t, 2.0));\n    \n    eyeball = mix(eyeball, sclera, sclera.a);\n    eyeball = mix(eyeball, retina, retina.a*sclera.a);\n\n    return eyeball;\n}\n\nvec4 mk_eye(in vec2 vUV, in float b, in float t) {\n    vec4 eye = vec4(0.0);\n    float eye_sdf = eyeSDF(vUV*1.06, b);\n    vec4 tearduct = mk_tearduct(eye_sdf, t);\n    vec4 eyelids = mk_eyelids(eye_sdf);\n    vec4 eyeball = mk_eyeball(vUV, t);\n\n    eye = mix(eye, tearduct, tearduct.a);\n    eye = mix(eye, eyeball, eyeball.a*tearduct.a);\n    eye = mix(eye, eyelids, eyelids.a);\n\n    return vec4(eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUV = fragCoord.xy / iResolution.xy;\n    vUV.x *= iResolution.x / iResolution.y;\n    float scl = 1.75;\n    vec2 pUV = vUV * scl + vec2(iTime * 0.01, iTime * -0.0107);\n    vec4 color = vec4(0.0);\n    float sdf = 1.0;\n\n    for (float i = 0.0; i <= 1.0; i ++) {\n        vUV = pUV + 7.5*(1.0-i);\n        vec2 iUV = floor(vUV);\n        vUV = fract(vUV)-0.5;\n        float rand = value_noise(iUV, int(vUV.x*vUV.y));\n        float t = (iTime + 100.0*(i+0.5)) * (rand + 1.0);\n        vUV = rotate2D(vUV, t*0.01);\n        float b = scale(pow(fold(t * 0.1), 100.0), 0.0, 1.0, 2.0, 10.0);\n        vec4 eye = mk_eye(vUV*pow(2.0, rand), b, t * 0.5);\n        sdf = min(sdf, eyeSDF(vUV*scl, b));\n        color = mix(color, eye, eye.a);\n    }\n    \n    sdf = camel_ramp(fold(sdf*(16. + sin(iTime*0.25)*2.0) - iTime*0.1), 1.0);\n    sdf *= sdf;\n    color = mix(color, sdf*vec4(0.6824, 0.6824, 0.6824, 1.0), sdf*(1.0-color.a));\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7tjSWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[221, 258, 282, 282, 320], [322, 322, 362, 362, 441], [443, 443, 486, 486, 593], [594, 594, 636, 636, 751], [753, 753, 797, 797, 871], [873, 873, 964, 964, 1027], [1029, 1059, 1101, 1101, 1186], [1188, 1188, 1233, 1233, 1625], [1627, 1665, 1704, 1704, 1920], [1922, 1922, 1966, 1966, 2154], [2156, 2156, 2187, 2187, 2278], [2280, 2280, 2333, 2333, 2753], [2755, 2755, 2806, 2806, 3481], [3484, 3484, 3523, 3523, 3634], [3636, 3636, 3675, 3675, 4029], [4031, 4031, 4072, 4072, 4507], [4509, 4509, 4551, 4551, 4833], [4835, 4835, 4885, 4885, 5235], [5237, 5237, 5294, 5294, 6236]]}
{"id": "7tjSzG", "name": "FS Inject Pressure Tool", "author": "GabrieleGiuseppini", "description": "Experiments for visual feedback of the Inject Pressure tool.", "tags": ["floatingsandbox"], "likes": 5, "viewed": 45, "date": "1627977506", "time_retrieved": "2024-06-20T20:46:43.890369", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 _uv = fragCoord/iResolution.xy;\n    vec2 haloSpacePosition = (_uv - vec2(.5)) * 2.;\n    haloSpacePosition.x *= (iResolution.x / iResolution.y); // obey aspect ratio\n\n    float paramTime = float(iTime) / 1.;\n        \n    vec4 cBase = texture(iChannel0, haloSpacePosition);\n    fragColor = cBase;\n    \n    ////////////////////////////////////////////////////////////////\n    \n    #define T 1.\n    #define RADIUS 1.\n    #define THICKNESS .4\n\n    // Where in a half period\n    float ht = fract(paramTime / (T / 2.));\n    \n    float radius1 = (RADIUS / 2.) * ht;\n    float radius2 = RADIUS / 2. + (RADIUS / 2.) * ht;\n    \n    float alpha1 = 1.;\n    float alpha2 = 1. - ht;\n    \n    //\n    // Render\n    //\n        \n    float d = length(haloSpacePosition);\n    \n    float w1 = \n        smoothstep(radius1 - THICKNESS / 2., radius1, d)\n        - smoothstep(radius1, radius1 + THICKNESS / 2., d);\n\n    float w2 = \n        smoothstep(radius2 - THICKNESS / 2., radius2, d)\n        - smoothstep(radius2, radius2 + THICKNESS / 2., d);\n\n    float whiteDepth = max(w1 * alpha1, w2 * alpha2) / 2.;\n    \n    vec4 c1 = vec4(whiteDepth, whiteDepth, whiteDepth, 1.); // white\n    \n    ////////////////////////////////////////////////////////////////\n    \n    fragColor = c1 * c1 + cBase; // GL_SRC_COLOR, GL_ONE, GL_FUNC_ADD\n    //fragColor = mix(cBase, vec4(1.), whiteDepth);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7tjSzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 107, 1476]]}
{"id": "7tjXRc", "name": "superegg Joukowsky", "author": "suitzero", "description": " Piet Hein.. super egg..", "tags": ["superegg"], "likes": 2, "viewed": 56, "date": "1628274880", "time_retrieved": "2024-06-20T20:46:44.157135", "image_code": "float egg(vec2 uv)\n{\n   vec2 a = vec2(.8,.5);\n    float x = a.x-uv.x;\n    float y = a.y-uv.y;\n    float p = 2.5;\n    return pow(abs(x)/5.,p) + pow(abs(y)/6.,p);\n\n}\n\nvec2 zhoukowski(vec2 uv)\n{\n    vec2 w =(uv+1./uv);\n    return w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\nuv.x = uv.x*1.7;\n    uv.x = uv.x-0.6;\n    uv.y = uv.y-0.2+sin(iTime)*0.01;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    uv = zhoukowski((uv)*3.+0.4);\n    if( egg(uv) < 0.1)\n    {\n        vec2 a = vec2(.8,.5);\n        float t = smoothstep(0.9,.0,length(a-uv*0.376));\n        fragColor = vec4(pow(t,0.16));\n    }\n    else{\n    // Output to screen\n    fragColor = vec4(vec3(1.),1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7tjXRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 20, 20, 163], [165, 165, 191, 191, 231], [233, 233, 290, 340, 821]]}
{"id": "7tjXRt", "name": "Black Panther Tribute (Old)", "author": "chenglou", "description": "[b]New one at [url]https://www.shadertoy.com/view/sscGR8[/url][/b]\nBeat synced up to [url=https://youtu.be/Iuw8Lrg0Jyg]Black Panther's ending theme[/url]. Try that song!\nColor scheme inspired by the movie's tunnel fight\nMouse drag.", "tags": ["raytracing", "sdf", "scene"], "likes": 1, "viewed": 124, "date": "1628421082", "time_retrieved": "2024-06-20T20:46:45.120592", "image_code": "// Beat is synced to All The Stars: https://youtu.be/Iuw8Lrg0Jyg\n// New one at https://www.shadertoy.com/view/sscGR8\n\n#define MAX_DEPTH 3 // 2 reflection passes. 60fps on this machine\n\n#define PI 3.14159\n\n// utils from inigo\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat opRep( in float p, in float s ) {\n    return mod(p+s*0.5,s)-s*0.5;\n}\nfloat expImpulse(float x, float k) {\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n// modified from mercury sdf\nvec3 pModPolarXY(vec3 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2. + p.z / 2.; // twist the tunnel\n\tfloat r = length(p.xy);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\treturn vec3(cos(a) * r, sin(a) * r, p.z);\n}\n\nconst vec3 Killmonger = vec3(0.77, 0.62, 0.32);\nconst vec3 TChalla = vec3(0.72, 0.52, 0.99); // RIP\nconst vec3 Okoye = vec3(0.84, 0.53, 0.46);\n// All The Stars from Black Panther has a beat per minute of 97\nconst float secondPerBeat = 60. / 97.;\n// Beat's peak doesn't happen at time 0. Shift it to be so\n// This eases manually syncing with the music's beat if you press restart\nconst float beatOffset = 0.075;\n\nstruct material { vec3 attenuation; vec3 emission; float sdf; };\n\nmaterial map(vec3 p, float beat) {\n    // polar repeat & twist field\n    vec3 rotatedP = pModPolarXY(p, 8.); // 8 rail blocks\n    rotatedP.x += beat * 0.03 - 0.3; // periodic impulse, try in graphtoy\n    rotatedP.z = opRep(p.z - iTime / 2., 0.25); // z axis move & rail block repeat\n    \n    const vec3 halfSize = vec3(.015, .077, 0.11);\n    float dRailways = sdBox(rotatedP, halfSize);\n    float dLights = sdBox(rotatedP, halfSize + vec3(-0.01, 0.01, -0.01)) - 0.004; // rounder\n    float dOrb = sdSphere(p, 0.1);\n    \n    // colors\n    vec3 attenuation, emission;\n    if (dRailways > dLights || dRailways > dOrb) {\n        vec3 color = mod(iTime + beatOffset, secondPerBeat * 2.) > secondPerBeat ? TChalla : Killmonger;\n        attenuation = color;\n        emission = color * (0.7 + beat / 2.); // tune up emission when the beat's high\n    } else {\n        attenuation = Okoye;\n        emission = vec3(0);\n    }\n\n    return material(attenuation, emission, min(dRailways, min(dLights, dOrb)));\n}\n\nvec3 calcNormal( in vec3 p, float beat) {\n    float h = 1e-5;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h, beat).sdf + \n                      k.yyx*map( p + k.yyx*h, beat).sdf + \n                      k.yxy*map( p + k.yxy*h, beat).sdf + \n                      k.xxx*map( p + k.xxx*h, beat).sdf );\n}\n\nfloat maxT = 12.;\nbool rayMarch(vec3 ro, vec3 rd, float beat, out float t, out material m, out vec3 glow) {\n    t = 1e-3;\n    glow = vec3(1);\n    for(int i = 0; i < 85; i++) {\n        vec3 p = ro + t * rd;\n        m = map(p, beat);\n        float df = abs(m.sdf);\n        \n        if (df < 0.0007) return true;\n        if (t > maxT) return false;\n        \n        // add a physically incorrect glow when near an emissive material\n        const float glowDist = .05;\n        float diff = glowDist - df;\n        glow += m.emission * step(0., diff) * diff * 5.; // adjust 5 for glow strengh\n        \n        t += max(0.001, m.sdf);\n    }\n    return false;\n}\n\nvec3 rayTrace(vec3 ro, vec3 rd, float beat, vec2 seed) {\n    vec3 color = vec3(0);\n    // We want the emissive lights to also keep reflecting. See usage below\n    // This should be the correct way to calculate such light. I haven't seen\n    // it anywhere else (iteratively, on GLSL) so I had to derive the calculations.\n    vec3 accumulatedAttenuation = vec3(1);\n\n    vec3 ro_ = ro;\n    vec3 rd_ = rd;\n\n    const vec3 background = vec3(0.09, 0.09, .27);\n    const vec3 backgroundAttenuation = background * 0.1;\n    vec3 glow;\n\n    for (int depth = 0; depth < MAX_DEPTH; depth++) {\n        float t;\n        material m;\n        bool hit = rayMarch(ro_, rd_, beat, t, m, glow);\n\n        if (hit) {\n            vec3 pos = ro_ + rd_ * t;\n            vec3 normal = calcNormal(pos, beat);\n            vec3 reflected = reflect(rd_, normal);\n\n            color += accumulatedAttenuation * m.emission;\n            accumulatedAttenuation *= m.attenuation;\n\n            if (dot(reflected, normal) > 0.) {\n                ro_ = pos;\n                rd_ = reflected;\n            }\n        } else {\n            float gradient = rd_.y / iResolution.y * 500. + 0.5;\n            vec3 emission = background * gradient;\n            \n            color += accumulatedAttenuation * emission;\n            accumulatedAttenuation *= backgroundAttenuation;\n            color += accumulatedAttenuation;\n            \n            break;\n        }\n    }\n    color *= glow; // this isn't physically accurate but whatever\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (1. * fragCoord) / iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;\n\n    // camera\n    vec3 ro;\n    if (length(iMouse.xy) == 0.) {\n        ro = smoothstep(0., 0.9, vec3(vec2(1) - iTime / 4., 1));\n    } else {\n        ro = vec3(-(2. * iMouse.xy - iResolution.xy) / iResolution.y, 1);\n    }\n    vec3 lookat = vec3(cos(iTime) / 10., sin(iTime) / 10., 0);\n    vec3 vup = vec3(0, 1, 0);\n    float vfov = 50.;\n\n    float theta = radians(vfov);\n    float h = tan(theta / 2.);\n    float viewport_height = 2.0 * h;\n    float viewport_width = aspect_ratio * viewport_height;\n\n    vec3 w = normalize(ro - lookat);\n    vec3 u = normalize(cross(vup, w));\n    vec3 v = cross(w, u);\n\n    vec3 horizontal = viewport_width * u;\n    vec3 vertical = viewport_height * v;\n    vec3 lower_left_corner = ro - horizontal / 2. - vertical / 2. - w;\n\n    vec3 rd = normalize(lower_left_corner + uv.x * horizontal + uv.y * vertical - ro);\n\n    float beat = expImpulse(mod(iTime + beatOffset, secondPerBeat), 14.);\n    vec3 color = rayTrace(ro, rd, beat, uv);\n    \n    color = pow(color, vec3(1.0/2.2)); // gamma correction\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7tjXRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[205, 225, 258, 258, 284], [285, 285, 314, 314, 401], [402, 402, 441, 441, 476], [477, 477, 513, 513, 559], [560, 589, 634, 634, 864], [1112, 1344, 1378, 1412, 2340], [2342, 2342, 2383, 2383, 2672], [2692, 2692, 2781, 2781, 3327], [3329, 3329, 3385, 3385, 4843], [4845, 4845, 4902, 4902, 6071]]}
{"id": "7tSSWw", "name": "SpaceEYE", "author": "jj99", "description": "color please", "tags": ["fbm"], "likes": 4, "viewed": 117, "date": "1627776186", "time_retrieved": "2024-06-20T20:46:45.126721", "image_code": "float hash( float n )\n{\n    return fract(sin(n)*758.5453)*2.;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x); \n    //f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + p.z*800.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n            mix(mix( hash(n+800.0), hash(n+801.0),f.x), mix( hash(n+857.0), hash(n+858.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm(vec3 p)\n{\n    float f = 0.0;\n    f += 0.50000*noise( p ); p = p*2.02+0.15;\n    f -= 0.25000*noise( p ); p = p*2.03+0.15;\n    f += 0.12500*noise( p ); p = p*2.01+0.15;\n    f += 0.06250*noise( p ); p = p*2.04+0.15;\n    f -= 0.03125*noise( p );\n    //return f/0.984375;\n    return f;\n}\n\nfloat cloud(vec3 p)\n{\n    p-=fbm(vec3(p.x,p.y,0.0)*0.5)*0.7;\n    \n    float a =0.0;\n    a-=fbm(p*3.0)*2.2-1.1;\n    if (a<0.0) a=0.0;\n    a=a*a;\n    return a;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\nvec3 hash33(vec3 p)\n{\n    const float UIF = (1.0/ float(0xffffffffU));\n    const uvec3 UI3 = uvec3(1597334673U, 3812015801U, 2798796415U);\n    uvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n\n// 3D Voronoi- (IQ)\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++)\n    {\n\t    for(int i = -1; i <= 1; i++)\n        {\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t    }\n\t}\n\treturn d;\n}\n\n// fbm layer\nfloat noiseLayers(in vec3 p) {\n\n    vec3 pp = vec3(0., 0., p.z + iTime*.09);\n    float t = 0.;\n    float s = 0.;\n    float amp = 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        t += voronoi(p + pp) * amp;\n        p *= 2.;\n        pp *= 1.5;\n        s += amp;\n        amp *= .5;\n    }\n    return t/s;\n}\n\nvec3 n2 (vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n        float dd = length(uv*uv)*.025;\n    \n\tvec3 rd = vec3(uv.x, uv.y, 1.0);\n    \n    float rip = 0.5+sin(length(uv)*20.0+iTime)*0.5;\n    rip = pow(rip*.38,4.15);\n    rd.z=1.0+rip*1.15;// apply a subtle ripple\n    rd = normalize(rd);\n    rd.xy *= rot(dd+iTime*.0125);\n    rd*=2.0;\n\t\n\tfloat c = noiseLayers(rd*1.85);\n    float oc = c;\n    c = max(c + dot(hash33(rd)*2. - 1., vec3(.006)), 0.);\n    c = pow(c*1.55,2.5);    \n    vec3 col =  vec3(.55,0.85,.25);\n    vec3 col2 =  vec3(1.4,1.4,1.4)*5.0;\n    float pulse2 = voronoi(vec3((rd.xy*1.5),iTime*.255));\n    float pulse = pow(oc*1.35,4.0);\n    col = mix(col,col2,pulse*pulse2)*c;\n    return col;\n\n}\n#define PI 3.14159\n\n\nfloat vDrop(vec2 uv,float t)\n{\nuv.y *= 0.25;\n    uv.x = uv.x*128.0;\t\t\t\t\t\t// H-Count\n    float dx = fract(uv.x);\n    uv.x = floor(uv.x);\n    uv.y *= 0.05;\t\t\t\t\t\t\t// stretch\n    float o=sin(uv.x*215.4);\t\t\t\t// offset\n    float s=cos(uv.x*33.1)*.3 +.7;\t\t\t// speed\n    float trail = mix(95.0,35.0,s);\t\t\t// trail length\n    float yv = fract(uv.y + t*s + o) * trail;\n    yv = 1.0/yv;\n    yv = smoothstep(0.0,1.0,yv*yv);\n    yv = sin(yv*PI)*(s*5.0);\n    float d2 = sin(dx*PI);\n    return yv*(d2*d2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n\tvec2 position = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tfloat ss = sin(length(position*3.0)+time*0.1)*2.5;\n\tss+=8.0;\n   \tvec2 coord = ss*position;\n    coord*=rot(ss*0.04+time*0.037);\n    coord*=0.25;\n    coord+=fbm(sin(vec3(coord*8.0,time*0.001)))*0.05;\n    coord+=time*0.0171;\n    float q = cloud((vec3(coord*1.0,0.222)));\n    coord+=time*0.0171;\n    q += cloud((vec3(coord*0.6,0.722)));\n    coord+=time*0.0171;\n    q += cloud(vec3(coord*0.3,.722));\n    coord+=time*0.1171;\n    q += cloud((vec3(coord*0.1,0.722)));\n    \n    \n\tfloat vv1 = sin(time+ss+coord.x)*0.3;\n\tfloat vv2 = sin(time*0.9+ss+coord.y)*0.2;\n\n    vec3 col = vec3(1.7-vv2,1.7,1.7+vv1) + vec3(q*vec3(0.7+vv1,0.5,0.3+vv2*1.15));\n\tcol = pow(col,vec3(2.2))*0.08;\n\t\n\tfloat dd = length(col*.48)+vv1;\n\t\n\tfloat nn = 0.5+sin(ss*2.7+position.x*2.41+time*0.9)*0.5;\n\t\n    vec3 col2 = n2(fragCoord)*0.9;\n    \n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float d = length(p);\n\tp = vec2(atan(p.x, p.y) / PI, 2.5 / d);\n    float t = -time*0.014;\n    float drop = vDrop(p,t);\n    drop += vDrop(p,t+0.5);\n    drop*=d;\n    \n        col2+=(col*.565);\n    \n\tcol = mix(col,col2,nn);\n    col = mix(col,col*1.075,drop);\n    \n    col+=col*((d+dd)*0.28);\n    col *= d;\n    \n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7tSSWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 23, 23, 63], [65, 65, 91, 91, 440], [442, 442, 461, 461, 734], [736, 736, 757, 757, 895], [897, 897, 918, 918, 986], [989, 989, 1010, 1010, 1217], [1220, 1240, 1262, 1262, 1659], [1661, 1674, 1704, 1704, 1977], [1979, 1979, 2005, 2005, 2722], [2744, 2744, 2774, 2774, 3236], [3239, 3239, 3296, 3296, 4619]]}
{"id": "7tSXzc", "name": "Spiral RGB shift", "author": "python273", "description": "---", "tags": ["spiral"], "likes": 8, "viewed": 222, "date": "1628226092", "time_retrieved": "2024-06-20T20:46:45.126721", "image_code": "#define PI 3.1415926535897932384626433832795\n#define half_PI 1.570796326794896619231321692\n\nfloat max_dist = length(vec2(.5));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - .5*iResolution.xy) / min(iResolution.x, iResolution.y);\n    float l = length(uv) / max_dist;\n\n    float a = (1.0 + atan(uv.y, uv.x) / PI) / 2.0;\n\n    //a = fract(a + cos(l) / 5.0 + iTime / 60.0);\n    a = fract(a + l / 1.0 - iTime / 30.0);\n    \n    float val;\n    //val = smoothstep(0.0, 1.0, abs(2.*fract(a * 5.0)-1.));\n    //val = smoothstep(1., abs(2.*fract(a * 5.0)-1.), l * 1.5);\n    val = smoothstep(1.0, sin(a * PI * 10.0) / PI, l * 1.4);\n\n    //fragColor = vec4(vec3(val), 1.0);\n    \n    float val1 = smoothstep(1.0, sin(a * PI * 10.0 + 1.1) / PI, l * 1.5);\n    float val2 = smoothstep(1.0, sin(a * PI * 10.0 + 2.2) / PI, l * 1.5);\n\n    fragColor = vec4(val, val1, val2, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7tSXzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[128, 128, 185, 185, 895]]}
{"id": "fd33DH", "name": "lost in cels", "author": "snflwrfld", "description": "1st shot at raymarching, experimenting with shadings other that phong, looks cool\n\nmaybe next time i'll try to have a different material for the ring and add shadow of an object to another\n\ninspirations : \"Planetarium\" by Daniel Linssen and Outer Wilds", "tags": ["raymarching", "celshading"], "likes": 5, "viewed": 89, "date": "1629650375", "time_retrieved": "2024-06-20T20:46:45.920717", "image_code": "#define MIN_DIST 0.\n#define MAX_DIST 100.\n#define MAX_STEPS 100\n#define EPSILON 0.0001\n\n\n// UTILITIES\nfloat norm1(vec3 p){return abs(p.x)+abs(p.y)+abs(p.z);}\nfloat norminf(vec3 p) {return max(abs(p.x),max(abs(p.y),abs(p.z)));}\nfloat random(vec3 p){\n    return fract(sin(dot(p,vec3(24.5825,92.4585,134.4876))+27.66+iTime*.0001));\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n//PRIMITIVES\nfloat cubeSDF(vec3 p,vec3 center, float size) {\n    return norminf(p-center) -size;\n}\nfloat diamondSDF(vec3 p) {\n    return norm1(p) - 1.;\n}\nfloat sphereSDF(vec3 p,vec3 center,float size) {\n    return length(p-center)-size;\n}\nfloat torusSDF(vec3 p, vec3 center,float radius, float width){\n    vec2 q = vec2(length((p-center).xz)-radius,(p-center).y);\n    return length(q)-width;\n}\n\n\n// SCENE AND TRACING\nfloat SDF(vec3 p) {\n    float t =iTime;\n    float SDF = sphereSDF(p,vec3(0.),.5);\n    SDF = unionSDF(SDF,sphereSDF(p,1.5*vec3(cos(t),0.,sin(t)),.3));\n    SDF = unionSDF(SDF,differenceSDF(torusSDF(p,vec3(0.),1.5,.0075),sphereSDF(p,1.5*vec3(cos(t),0.,sin(t)),.5)));\n    return SDF;\n}\n\nfloat trace(vec3 cam,vec3 dir,float start,float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = SDF(cam + depth*dir);\n        if (dist < EPSILON){\n            return depth;\n        }\n        depth += dist;\n        if (dist >= end){\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SDF(vec3(p.x + EPSILON, p.y, p.z)) - SDF(vec3(p.x - EPSILON, p.y, p.z)),\n        SDF(vec3(p.x, p.y + EPSILON, p.z)) - SDF(vec3(p.x, p.y - EPSILON, p.z)),\n        SDF(vec3(p.x, p.y, p.z  + EPSILON)) - SDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n//CEL SHADING \nvec3 cel_single(vec3 colorMat,vec3 colorSpec,float alphaSpec,float slices, vec3 p, vec3 cam, vec3 lightPos, vec3 lightInt){\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos-p);\n    vec3 V = normalize(cam - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    if (dot(L,N)<0.) {\n        return vec3(0.0);\n    } else if (dot(R,V)<0.) {\n        return lightInt*colorMat*dot(L,N);\n    } else {\n        return lightInt*(colorMat*dot(L,N) + colorSpec*pow(dot(R,V),alphaSpec));\n    }\n}\nvec3 cel_scene(vec3 colorAmb,vec3 colorMat,vec3 colorSpec,float alphaSpec, float slices, vec3 p, vec3 cam, float t) {\n    vec3 color = colorAmb*colorMat;\n    vec3 illu = vec3(0.);\n  \n    t = t*.5 + .5;\n    vec3 light2pos = 6.*vec3(cos(t),.3,sin(t));\n    vec3 light2int = vec3(0.525,0.525,0.525);\n    illu = max(illu,cel_single(colorMat,colorSpec,alphaSpec,slices,p,cam,light2pos,light2int));\n    \n    //color += sqrt(illu*floor(slices*norminf(illu))/slices);\n    color += floor(slices*norminf(illu))/slices;\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st = st*2.-1.;\n    st.x *= iResolution.x/iResolution.y;\n    \n    float bitCrushFactor = 90.;\n    st = floor(st*bitCrushFactor)/bitCrushFactor;\n    \n    float t = iTime;\n    \n    \n    \n    //ray casting\n    vec3 cam = vec3(2.,2.,-2.);\n    vec3 dir = normalize(vec3(st,-2.));\n    mat4 view = viewMatrix(cam,vec3(0.),vec3(0.,1.,0.));\n    dir = (view*vec4(dir,0.)).xyz;\n    \n    float dist = trace(cam,dir,MIN_DIST,MAX_DIST);\n    vec3 p = cam+dist*dir;\n    \n    \n    \n    //background\n    vec3 backgroundColor = vec3(0.123,0.145,0.104);\n    vec3 starColor = vec3(0.765,0.765,0.367);\n    vec2 ipos = floor(st*250.);\n    \n    float lit = smoothstep(.99996,.99999,random(vec3(ipos,.0)));\n    backgroundColor = backgroundColor*(1.-lit)+starColor*lit ;\n    \n    \n    \n    //shading\n    vec3 color;\n    if (dist > MAX_DIST-EPSILON){\n        color = backgroundColor;\n    } else {\n        vec3 colorAmb = vec3(0.225,0.225,0.225);\n        vec3 colorMat = vec3(1.000,0.648,0.851);\n        vec3 colorSpec = vec3(0.110,0.110,0.110);\n        float alpha = 2.;\n        \n        color = cel_scene(colorAmb,colorMat,colorSpec,alpha,7.,p,cam,t);\n    }\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fd33DH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[89, 102, 122, 122, 157], [158, 158, 181, 181, 226], [227, 227, 248, 248, 330], [332, 332, 378, 378, 410], [412, 412, 454, 454, 486], [488, 488, 535, 535, 568], [570, 570, 619, 654, 880], [882, 895, 942, 942, 980], [981, 981, 1007, 1007, 1035], [1036, 1036, 1084, 1084, 1120], [1121, 1121, 1183, 1183, 1275], [1278, 1299, 1318, 1318, 1580], [1582, 1582, 1636, 1636, 1918], [1920, 1920, 1949, 1949, 2229], [2231, 2246, 2369, 2369, 2739], [2740, 2740, 2857, 2857, 3272], [3275, 3275, 3332, 3332, 4546]]}
{"id": "fd33zn", "name": "Saturday Torus", "author": "mrange", "description": "License CC0: Saturday Torus\nInspired by: https://www.istockphoto.com/photo/black-and-white-stripes-projection-on-torus-gm488221403-39181884\n", "tags": ["torus", "bw"], "likes": 24, "viewed": 271, "date": "1628948950", "time_retrieved": "2024-06-20T20:46:47.096723", "image_code": "// License CC0: Saturday Torus\n//  Inspired by: https://www.istockphoto.com/photo/black-and-white-stripes-projection-on-torus-gm488221403-39181884\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define TIME        iTime\n#define TTIME       (TAU*TIME)\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)     (0.5+0.5*cos(x))\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayTorus(vec3 ro, vec3 rd, vec2 tor) {\n  float po = 1.0;\n\n  float Ra2 = tor.x*tor.x;\n  float ra2 = tor.y*tor.y;\n\n  float m = dot(ro,ro);\n  float n = dot(ro,rd);\n\n  // bounding sphere\n  {\n    float h = n*n - m + (tor.x+tor.y)*(tor.x+tor.y);\n    if(h<0.0) return -1.0;\n    //float t = -n-sqrt(h); // could use this to compute intersections from ro+t*rd\n  }\n\n  // find quartic equation\n  float k = (m - ra2 - Ra2)/2.0;\n  float k3 = n;\n  float k2 = n*n + Ra2*rd.z*rd.z + k;\n  float k1 = k*n + Ra2*ro.z*rd.z;\n  float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\n  #ifndef TORUS_REDUCE_PRECISION\n  // prevent |c1| from being too close to zero\n  if(abs(k3*(k3*k3 - k2) + k1) < 0.01)\n  {\n    po = -1.0;\n    float tmp=k1; k1=k3; k3=tmp;\n    k0 = 1.0/k0;\n    k1 = k1*k0;\n    k2 = k2*k0;\n    k3 = k3*k0;\n  }\n  #endif\n\n  float c2 = 2.0*k2 - 3.0*k3*k3;\n  float c1 = k3*(k3*k3 - k2) + k1;\n  float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n\n\n  c2 /= 3.0;\n  c1 *= 2.0;\n  c0 /= 3.0;\n\n  float Q = c2*c2 + c0;\n  float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n\n  float h = R*R - Q*Q*Q;\n  float z = 0.0;\n  if(h < 0.0) {\n    // 4 intersections\n    float sQ = sqrt(Q);\n    z = 2.0*sQ*cos(acos(R/(sQ*Q)) / 3.0);\n  } else {\n    // 2 intersections\n    float sQ = pow(sqrt(h) + abs(R), 1.0/3.0);\n    z = sign(R)*abs(sQ + Q/sQ);\n  }\n  z = c2 - z;\n\n  float d1 = z   - 3.0*c2;\n  float d2 = z*z - 3.0*c0;\n  if(abs(d1) < 1.0e-4) {\n    if(d2 < 0.0) return -1.0;\n    d2 = sqrt(d2);\n  } else {\n    if(d1 < 0.0) return -1.0;\n    d1 = sqrt(d1/2.0);\n    d2 = c1/d1;\n  }\n\n  //----------------------------------\n\n  float result = 1e20;\n\n  h = d1*d1 - z + d2;\n  if(h > 0.0) {\n    h = sqrt(h);\n    float t1 = -d1 - h - k3; t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = -d1 + h - k3; t2 = (po<0.0)?2.0/t2:t2;\n    if(t1 > 0.0) result=t1;\n    if(t2 > 0.0) result=min(result,t2);\n  }\n\n  h = d1*d1 - z - d2;\n  if(h > 0.0) {\n    h = sqrt(h);\n    float t1 = d1 - h - k3;  t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = d1 + h - k3;  t2 = (po<0.0)?2.0/t2:t2;\n    if(t1 > 0.0) result=min(result,t1);\n    if(t2 > 0.0) result=min(result,t2);\n  }\n\n  return result;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 torusNormal(vec3 pos, vec2 tor) {\n  return normalize(pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec3 color(vec2 p, vec2 q) {\n  const float rdd = 2.0;\n  vec3 ro  = 1.*vec3(0., 0.75, -0.2);\n  vec3 la  = vec3(0.0, 0.0, 0.2);\n  vec3 up  = vec3(0.3, 0.0, 1.0);\n  vec3 lp1 = ro;\n  lp1.xy  *= ROT(0.85);\n  lp1.xz  *= ROT(-0.5);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n\n  const vec2 tor = 0.55*vec2(1.0, 0.75);\n  float td    = rayTorus(ro, rd, tor);\n  vec3  tpos  = ro + rd*td;\n  vec3  tnor  = -torusNormal(tpos, tor);\n  vec3  tref  = reflect(rd, tnor);\n\n  vec3  ldif1 = lp1 - tpos;\n  float ldd1  = dot(ldif1, ldif1);\n  float ldl1  = sqrt(ldd1);\n  vec3  ld1   = ldif1/ldl1;\n  vec3  sro   = tpos+0.05*tnor;\n  float sd    = rayTorus(sro, ld1, tor);\n  vec3  spos  = sro+ld1*sd;\n  vec3  snor  = -torusNormal(spos, tor);\n\n  float dif1  = max(dot(tnor, ld1), 0.0);\n  float spe1  = pow(max(dot(tref, ld1), 0.0), 10.0);\n  float r     = length(tpos.xy);\n  float a     = atan(tpos.y, tpos.x)-PI*tpos.z/(r+0.5*abs(tpos.z))-TTIME/45.0;\n  float s     = mix(0.05, 0.5, tanh_approx(2.0*abs(td-0.75)));\n  vec3  bcol0 = vec3(0.3);  \n  vec3  bcol1 = vec3(0.025);  \n  vec3  tcol  = mix(bcol0, bcol1, smoothstep(-s, s, sin(9.0*a)));\n\n  vec3 col = vec3(0.0);\n\n  if (td > -1.0) {\n    col += tcol*mix(0.2, 1.0, dif1/ldd1)+0.25*spe1;\n    col *= sqrt(abs(dot(rd, tnor)));\n  }\n  \n  if (sd < ldl1) {\n    col *= mix(1.0, 0.0, pow(abs(dot(ld1, snor)), 3.0*tanh_approx(sd)));\n  }\n\n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = color(p, q);\n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fd33zn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[394, 510, 554, 554, 2612], [2614, 2730, 2768, 2768, 2856], [2858, 2918, 2946, 3012, 3088], [3090, 3090, 3118, 3118, 4569], [4571, 4658, 4694, 4694, 4927], [4929, 4929, 4986, 4986, 5171]]}
{"id": "fd3GzX", "name": "SomeGalaxyIdeas", "author": "antoinefortin", "description": "hello", "tags": ["particles"], "likes": 7, "viewed": 111, "date": "1630294635", "time_retrieved": "2024-06-20T20:46:47.478488", "image_code": "#define NUM_PARTICLES 350.\n\nvec2 Hash12(float t)\n{\n    float x = fract(sin(t * 674.3) * 453.2);\n    float y = fract(sin(t * 2674.3) * 453.2);\n    \n    return vec2(x,y);\n}\nvec2 rotate(vec2 pos, float angle)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c,s,-s,c) * pos;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5 * iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n    for(float i = 0.; i < NUM_PARTICLES; i++)\n    {\n        vec2 dir= Hash12(i) - .5;\n        float t = sin(iTime);\n        float d = length(uv-dir * (t));\n        \n        float brightness = 0.0008;\n        \n        uv = rotate(uv, iTime * 0.005);\n        \n\n       // uv = abs(uv);\n        // Particle layer 2\n        vec2 dir2 = Hash12(i * i) - .5;\n        float t2 = cos(iTime * 1.5);\n        float d2 = length(uv-dir2 * (t2));\n        \n        \n        vec2 dir3 = Hash12(i * i * i) - .5;\n        float t3 = 4. * cos(iTime * 1.5) * sin(dir3.x);\n        float d3 = length(uv-dir3 * (t3));\n        \n        vec2 dir4 = Hash12(i * i * sin(i)) - .5;\n        float t4 = 2. * cos(iTime * 1.5) * cos(dir4.x);\n        float d4 = length(uv-dir4 * (t4));\n        \n        \n        \n        \n        \n        col += vec3(brightness / d);\n        col += vec3(brightness / d2) * vec3(1.0, 0.0, 0.0);\n        col += vec3(brightness / d3) * vec3(0.0, 1.0, 0.0);\n        col += vec3(brightness / d4) * vec3(0.0, 0.0, 1.0);\n        \n        \n        \n        \n    \n    }\n  //  col = vec3(Hash12(12.).x);\n    // Output to screen\n    fragColor = vec4((col * .15) - .15,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fd3GzX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[28, 28, 50, 50, 170], [171, 171, 207, 207, 297], [300, 300, 357, 407, 1694]]}
{"id": "fdc3DH", "name": "Fork Smiling Mike by Moustave", "author": "Moustave", "description": "sus", "tags": ["3d", "raymarching", "distancefield"], "likes": 1, "viewed": 54, "date": "1629653103", "time_retrieved": "2024-06-20T20:46:49.624071", "image_code": "// Created by inigo quilez - iq/2013\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a techer, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n// Made with love after a famous movie character. Modeling is pretty arbitrary and was \n// done by visual inspiration from the first picture you get in google images when you \n// type \"mike wazowski\".\n\n// Uncomment the following define in order to see Mike in 3D!\n//#define STEREO \n\n\nfloat hash( float n )\n{\n    return fract(sin(n)*158.5453123);\n}\n\nfloat noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    return mix( hash(p+0.0), hash(p+1.0),f);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\nvec3 texturize( sampler2D sa, vec3 p, vec3 n )\n{\n\tvec3 x = texture( sa, p.yz ).xyz;\n\tvec3 y = texture( sa, p.zx ).xyz;\n\tvec3 z = texture( sa, p.xy ).xyz;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n//----------------------------------------------------------------\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 sdSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length(p/r) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n#define ZERO (min(iFrame,0))\n\n//----------------------------------------------------------------\n\nvec2 map( vec3 p )\n{\n\tp.y -= 1.8;\n\tp.x = abs(p.x);\n\n\tvec3 q = p;\n\tq.y -= 0.3*pow(1.0-length(p.xz),1.0)*smoothstep(0.0, 0.2, p.y);\n\tq.y *= 1.05;\n\tq.z *= 1.0 + 0.1*smoothstep( 0.0, 0.5, q.z )*smoothstep( -0.5, 0.5, p.y );\n    float dd = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.75,1.0) );\n\tfloat am = clamp( 4.0*abs(p.y-0.45), 0.0, 1.0 );\n\tfloat fo = -0.03*(1.0-smoothstep( 0.0, 0.04*am, abs(dd-0.42) ))*am;\n    float dd2 = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.25,1.0) );\n\tfloat am2 = clamp( 1.5*(p.y-0.45), 0.0, 1.0 );\n\tfloat fo2 = -0.085*(1.0-smoothstep( 0.0, 0.08*am2, abs(dd2-0.42) ))*am2;\n    q.y += -0.05+0.05*length(q.x);\n\t\n\tfloat d1 = length( q ) - 0.9 + fo + fo2;\n    vec2 res = vec2( d1, 1.0 );\n\n\t// arms\n\tvec2 h = sdSegment( p, vec3(.83,0.15,0.0), vec3(1.02,-0.6,-.1) );\n\tfloat d2 = h.x - 0.07;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( p, vec3(1.02,-0.6,-.1), vec3(0.95,-1.2,0.1) );\n\td2 = h.x - 0.07 + h.y*0.02;\n\tres.x = smin( res.x, d2, 0.02 );\n\t\n\t// hands\n\tif( p.y<-1.0 )\n\t{\n    float fa = sin(3.0*iTime);\n\th = sdSegment( p, vec3(0.95,-1.2,0.1), vec3(0.97,-1.5,0.0) );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.01 );\n\th = sdSegment( p, vec3(0.97,-1.5,0.0), vec3(0.95,-1.7,0.0)-0.01*fa );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( p, vec3(0.95,-1.2,0.1), vec3(1.05,-1.5,0.1) );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( p, vec3(1.05,-1.5,0.1), vec3(1.0,-1.75,0.1)-0.01*fa );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( p, vec3(0.95,-1.2,0.1), vec3(0.98,-1.5,0.2) );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( p, vec3(0.98,-1.5,0.2), vec3(0.95,-1.7,0.15)-0.01*fa );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( p, vec3(0.95,-1.2,0.1), vec3(0.85,-1.4,0.2) );\n\td2 = h.x - 0.04 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.05 );\n\th = sdSegment( p, vec3(0.85,-1.4,0.2), vec3(0.85,-1.63,0.15)+0.01*fa );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.03 );\n\t}\n\t\n\t// legs\n\tif( p.y<0.0 )\n\t{\n\th = sdSegment( p, vec3(0.5,-0.5,0.0), vec3(0.6,-1.2,0.1) );\n\td2 = h.x - 0.14 + h.y*0.08;\n\tres.x = smin( res.x, d2, 0.06 );\n\th = sdSegment( p, vec3(0.6,-1.2,0.1), vec3(0.5,-1.8,0.0) );\n\td2 = h.x - 0.06;\n\tres.x = smin( res.x, d2, 0.06 );\n\t}\n\n    // feet\n\tif( p.y<-0.5 )\n\t{\n\th = sdSegment( p, vec3(0.5,-1.8,0.0), vec3(0.6,-1.8,0.4) );\n\td2 = h.x - 0.09 + 0.02*h.y;\n\tres.x = smin( res.x, d2, 0.06 );\n\th = sdSegment( p, vec3(0.5,-1.8,0.0), vec3(0.77,-1.8,0.35) );\n\td2 = h.x - 0.08 + 0.02*h.y;\n\tres.x = smin( res.x, d2, 0.06 );\n\th = sdSegment( p, vec3(0.5,-1.8,0.0), vec3(0.9,-1.8,0.2) );\n\td2 = h.x - 0.07 + 0.02*h.y;\n\tres.x = smin( res.x, d2, 0.06 );\n\t}\n\t\n\t// horns\n\tvec3 hp = p - vec3(0.25,0.7,0.0);\n    hp.xy = mat2(0.6,0.8,-0.8,0.6)*hp.xy;\n    hp.x += 0.8*hp.y*hp.y;\n    float d4 = sdEllipsoid( hp, vec3(0.13,0.5,0.16) );\n\tif( d4<res.x ) res = vec2( d4, 3.0 );\n    \n\t// eyes\n\tfloat d3 = length( (p - vec3(0.0,0.25,0.35))*vec3(1.0,0.8,1.0) ) - 0.5;\n\tif( d3<res.x ) res = vec2( d3, 2.0 );\n\n\t// mouth\n\tfloat mo = length( (q-vec3(0.0,-0.35,1.0))*vec3(1.0,1.2,0.25)/1.2 ) -0.3/1.2;\n\tfloat of = 0.1*pow(smoothstep( 0.0, 0.2, abs(p.x-0.3) ),0.5);\n\tmo = max( of+q.y+0.35+0.01*cos(iTime*5.0), -q.y-0.35+mo+0.01*sin(iTime*5.0) );\n\n\tfloat li = smoothstep( 0.0, 0.05, mo+0.02 ) - smoothstep( 0.05, 0.10, mo+0.02 );\n\tres.x -= 0.03*li*clamp( (-q.y-0.4)*10.0, 0.0, 1.0 );\n\t\n\tif( -mo > res.x )\n\t\tres = vec2( -mo, 4.0 );\n\n    res.x += 0.01*(smoothstep( 0.0, 0.05, mo+0.062 ) - smoothstep( 0.05, 0.10, mo+0.062 ));\n\n    // teeth\t\n\tif( p.x<0.3 )\n\t{\n    p.x = mod( p.x, 0.16 )-0.08;\t\n    float d5 = length( (p-vec3(0.0,-0.37,0.65))*vec3(1.0,2.0,1.0))-0.08;\n\tif( d5<res.x )\n\t\tres = vec2( d5, 2.0 );\n\t}\n\t\n\treturn vec2(res.x*0.8,res.y);\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0    \n    vec3 eps = vec3(0.002,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.002*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float m = -1.0;\n\tfloat mint = 10.0;\n\n    // floor\t\n\tfloat tf = (0.0-ro.y)/rd.y;\n\tif( tf>0.0 ) { mint = tf; m = 0.0; }\n\t\n\t// mike\n\tfloat maxd = min(5.0,mint);\n\tfloat precis = 0.001;\n    float t = 0.0;\n\tfloat d = 0.0;\n    for( int i=ZERO; i<128; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        float h = res.x;\n\t\td = res.y;\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t<maxd && t<mint )\n\t{\n\t\tmint = t;\n\t\tm = d;\n\t}\n\n    return vec3( mint, m, m );\n}\n\n// https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<50; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n\t\tt += clamp( h, 0.01, 0.25 );\n\t\tif( res<0.005 || t>10.0 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\nconst vec3 lig = normalize(vec3(1.0,0.7,0.9));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n\t#ifdef STEREO\n\tfloat eyeID = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n    #endif\n\t\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\t\n\tfloat an = sin(-0.25 + 0.31416*iTime);\n\tvec3 ro = vec3(3.5*sin(an),1.8,3.5*cos(an));\n    vec3 ta = vec3(0.0,1.5,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n\t#ifdef STEREO\n\tvec3 fo = ro + rd*7.0; // put focus plane behind Mike\n\tro -= 0.1*uu*eyeID;    // eye separation\n\trd = normalize(fo-ro);\n    #endif\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = vec3(1.0);\n\n\t// raymarch\n    vec3 tmat = intersect(ro,rd);\n    if( tmat.z>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\n        // materials\n\t\tvec4 mate = vec4(0.0);\n\t\tvec2 mate2 = vec2(1.0,1.0);\n\t\tif( tmat.z<0.5 )\n\t\t{\n\t\t\tnor = vec3(0.0,1.0,0.0);\n\t\t    ref = reflect( rd, nor );\n\t\t\tmate.xyz = vec3(1.0);\n            mate2.y = 1.0 - 0.9*(2.0/(2.0+dot(pos.xz,pos.xz)));\n\t\t}\n\t\telse if( tmat.z<1.5 )\n\t\t{\n            mate2.x = 4.0;\n\t\t\tmate = vec4(0.16,0.32,0.0,0.8);\n\n            float f = texturize( iChannel0, 0.15*pos, nor ).x * texturize( iChannel0, 0.2*0.25*pos, nor ).x;\n\t\t\tmate.xyz = mix( 0.56*mate.xyz, vec3(0.21,0.28,0.0), f );\n\n\t\t\tf = texturize( iChannel0, pos, nor ).x * texturize( iChannel0, 0.25*pos, nor ).x;\n\t\t\tf = f*f;\n\t\t    mate.xyz = mix( mate.xyz, vec3(0.21,0.28,0.0), 0.6*f );\n\n\t\t\tvec3 bnor = -1.0+2.0*texturize( iChannel0, 4.0*pos, nor );\n\t\t\tnor = normalize( nor + 0.15*bnor );\n\t\t}\n\t\telse if( tmat.z<2.5 )\n\t\t{\n\t\t\tvec3 q = pos-vec3(0.0,1.8,0.0) - vec3(0.0,0.44,0.35);\n\n\t\t\tfloat an2 = an + 0.015*(-1.0+2.0*noise( 6.0*iTime ));\n            vec3 oq = q;\t\t\t\n\t\t\tq.x += -2.0*0.15*clamp(sin(an2),-0.42,0.42);\n\t\t\tfloat f = length( q.xy );\n\t\t\t\n\t\t\tmate2.y = 1.0-smoothstep(0.24,0.35,length( oq.xy-vec2(0.0,0.035) ));\n\t\t\tmate = vec4(0.5,0.5,0.5,1.0);\n\t\t\tmate.xyz = mix( mate.xyz, vec3(0.6,0.4,0.3), 0.5*smoothstep(0.1,0.4,f) );\n\t\t\t\n            vec3 c1 = vec3(0.0,0.15,0.05)*(1.0-0.85*f/0.19);\n\t\t\tfloat a = atan(q.y,-q.x);\n            float te = fbm( 20.0*vec2(0.3*a,1.0*f) );\n\t\t\tc1 *= 0.3 + 5.0*te;\n            \n            c1 += vec3(0.5,1.0,0.1)*0.35*(0.5+te)*\n                (1.0-smoothstep( 0.3,1.2,abs(a+0.5)))*\n                (1.0-smoothstep( 0.0, 0.06, abs(f-0.125) ));\n            \n\t\t\tmate.xyz = mix( mate.xyz, c1, 1.0-smoothstep( 0.18, 0.19, f ) );\n\n\t\t\toq.x += -2.0*0.19*clamp(sin(an2),-0.42,0.42);\n\t\t\tf = length( oq.xy );\n\t\t\tmate.xyz *= smoothstep( 0.07, 0.10, f );\n            mate.xyz *= 1.0-0.2*vec3(0.5,0.9,1.0)*smoothstep( 0.2, 0.4, f );\n            \n\t\t\tmate.w = 2.0;\n            mate2.x = 64.0;\n\t\t}\n\t\telse if( tmat.z<3.5 )\n\t\t{\n\t\t\tmate = 0.8*vec4(0.85,0.7,0.6,0.0);\n            mate2.x = 0.0;\n\t\t\tfloat f = smoothstep( 0.0, 0.1, 0.5*abs(pos.x)+pos.y-3.02 );\n\t\t\tmate.xyz *= 1.0 - 0.8*vec3( f );\n\t\t\tmate.xyz *= 0.2 + 0.8*smoothstep( 0.0, 1.0, texturize( iChannel0, 0.1*2.1*pos*vec3(4.0,0.1,4.0), nor ).x );\n\t\t}\n\t\telse if( tmat.z<4.5 )\n\t\t{\n\t\t\tfloat z = smoothstep( 0.0, 2.0, pos.z+0.5 );\n\t\t\tmate = 0.5*vec4(0.5,0.25,0.1,0.0);\n\t\t\tmate.x += 0.1*(1.0-z);\n\t\t\tmate2.y = z;\n\t\t}\n\n\t\t// lighting\n\t\tfloat occ = (0.5 + 0.5*nor.y)*mate2.y;\n        float amb = 0.5;\n\t\tfloat bou = clamp(-nor.y,0.0,1.0);\n\t\tfloat dif = max(dot(nor,lig),0.0);\n        float bac = max(0.3 + 0.7*dot(nor,-lig),0.0);\n\t\tfloat sha = 0.0; if( dif>0.01 ) sha=softshadow( pos+0.01*nor, lig, 0.001, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n        vec3  hal = normalize(lig-rd);\n        float spe = max(pow( clamp( dot(nor,hal), 0.0, 1.0), mate2.x*4.0 ),0.0 );\n\t\t\n\t\t// lights\n\t\tvec3 lin = vec3(0.0);\n        lin += 2.0*dif*vec3(1.00,1.00,1.00)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tlin += 1.0*amb*vec3(0.30,0.30,0.30)*occ;\n\t\tlin += 2.0*bou*vec3(0.40,0.40,0.40)*mate2.y;\n\t\tlin += 4.0*bac*vec3(0.40,0.30,0.25)*occ;\n        lin += 1.0*fre*vec3(1.00,1.00,1.00)*2.0*mate.w*(0.5+0.5*dif*sha)*occ;\n\t\tcol = mate.xyz*lin;\n\t\tcol += 4.0*spe*vec3(2.0)*mate.w*dif*sha*(0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n\t// vigneting\n\tvec2 q = fragCoord / iResolution.xy;\n    col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 );\n\n    #ifdef STEREO\t\n    col *= vec3( eyeID, 1.0-eyeID, 1.0-eyeID );\t\n\t#endif\n\t   \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "proprietary-license", "thumbnail": "https://www.shadertoy.com/media/shaders/fdc3DH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[797, 879, 902, 902, 942], [944, 944, 971, 971, 1093], [1095, 1095, 1121, 1121, 1343], [1395, 1395, 1416, 1416, 1617], [1619, 1619, 1667, 1667, 1820], [1822, 1964, 2015, 2015, 2136], [2138, 2213, 2256, 2256, 2314], [2316, 2373, 2414, 2414, 2500], [2502, 2577, 2610, 2610, 2636], [2668, 2736, 2756, 2756, 6527], [6529, 6593, 6625, 6625, 7174], [7176, 7176, 7218, 7218, 7697], [7699, 7766, 7831, 7831, 8105], [8156, 8156, 8213, 8213, 13087]]}
{"id": "fdc3Wn", "name": "Basic SVG", "author": "jorge2017a1", "description": "test--svg-n2\n//Referencia\n///https://www.shadertoy.com/view/ldXyRn... FabriceNeyret2", "tags": ["basicsvg"], "likes": 5, "viewed": 178, "date": "1629470913", "time_retrieved": "2024-06-20T20:46:50.557431", "image_code": "//Por Jorge2017a1..Jorge Flores.P.---Ago-2021-\n//Referencia\n//https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n///https://www.shadertoy.com/view/ldXyRn... FabriceNeyret2\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(1.0),b,d)\n\n\nfloat d;\nfloat _x,_y;\nfloat x0,y0;\nvec2 gUV;\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nvoid IniciarPath(vec2 uv)\n{   gUV=uv;\n    d=10000.0;\n}\n\n//moveto\nvoid M(float x, float y)\n{   _x = x;\n    _y = y;\n    x0 = x;\n    y0 = y;   \n}\n\n\nvec3 FinPath( vec3 colIn, vec3 colOut)\n{   colOut= DrawFig(colIn, colOut,d);\n    return colOut;\n}\n\n\nfloat line( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat circle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n\nvoid Z(void)\n{ d = unionSDF(d, line(gUV, vec2(_x,_y), vec2(x0,y0)) );  }\n\n//line\nvoid L(float x, float y)\n{    float d1=line(gUV, vec2(_x,_y), vec2(x,y));\n    d = unionSDF(d, d1 ); \n    _x=x;\n    _y=y;\n}\n\n\nvoid Ci(float x, float y,float r)\n{    float d1=circle(vec2(gUV.x- x,gUV.y-y),r);\n    d = unionSDF(d, d1 ); \n    _x=x;\n    _y=y;\n}\n\n//https://www.shadertoy.com/view/sdX3zN\nvec3 getBackgroundColor(vec2 uv) \n{\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(0., 0., 0.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n     vec2 uv = (2.*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n    uv*=0.8;\n    uv-=vec2(-0.5,-0.5);\n    \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //vec3 col =vec3(1.0);\n    vec3 col = getBackgroundColor(uv); \n    \n     //cuarto casa\n     IniciarPath(uv );\n     M(0.2,0.5);\n     L(0.5 ,0.6);\n     L(0.5 ,0.3);\n     L(0.6 ,0.3);\n     L(0.6 ,0.12);\n     L(0.2 ,0.12);\n     Z();\n     col= FinPath(vec3(0.0,0.0,0.0), col);\n     \n     ///ventana\n     IniciarPath(uv );\n     M(0.3,0.2);\n     L(0.3 ,0.4);\n     L(0.4 ,0.4);\n     L(0.4 ,0.2);\n     Z();\n     col= FinPath(vec3(0.0,0.0,1.0), col);\n     \n     //ventana division\n     IniciarPath(uv );\n     M(0.3,0.3);\n     L(0.4 ,0.3);\n     Z();\n     col= FinPath(vec3(0.5,0.0,1.0), col);\n     \n     //pasto\n     IniciarPath(uv );\n     for(float i=0.0; i<5.0;i+=0.02)\n     {\n         M(-2.2+i,0.0);\n         L(-2.25+i,0.1);\n         col= FinPath(vec3(0.0,1.0,0.0), col);\n     }\n  \n  \n    \n     //montaña\n     IniciarPath(uv );\n     M(-0.3,0.7);\n     L(0.0 ,0.3);\n     L(0.2 ,0.6);\n     L(0.3 ,0.8);\n     L(0.4 ,0.7);\n     L(0.6 ,0.9);\n     L(0.8 ,0.7);\n     L(0.9 ,0.9);\n     L(1.0 ,0.7);\n     L(1.1 ,0.6);\n     L(1.3 ,0.9);\n     col= FinPath(vec3(1.0,0.0,0.0), col);\n     \n     //nube\n     float py=0.1*sin(iTime);\n     IniciarPath(uv );\n     Ci(0.3, 0.7+ py,0.05);\n     Ci(0.4, 0.7+ py,0.06);\n     Ci(0.35,0.72+py,0.05);\n     Ci(0.45,0.7 +py,0.05);\n     col= FinPath(vec3(0.5,0.5,1.0), col);\n     \n     \n     //arbol\n     IniciarPath(uv-vec2(0.2,-0.2) );\n     M(0.5,0.3);\n     L(0.5 ,0.4);\n     L(0.55 ,0.5);\n     M(0.5,0.4);\n     L(0.5,0.5);\n     L(0.4,0.6);\n     M(0.5,0.4);\n     L(0.5,0.6);\n     Ci(0.5, 0.6,0.05);\n     Ci(0.55, 0.55,0.05);\n     Ci(0.43, 0.6,0.04);\n     col= FinPath(vec3(0.0,0.8,0.0), col);\n     \n     \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdc3Wn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[403, 447, 494, 494, 521], [522, 522, 565, 565, 592], [593, 593, 641, 641, 669], [675, 675, 737, 737, 927], [930, 930, 987, 987, 1053], [1055, 1055, 1082, 1082, 1109], [1111, 1120, 1146, 1146, 1197], [1200, 1200, 1240, 1240, 1297], [1300, 1300, 1347, 1347, 1466], [1468, 1468, 1501, 1501, 1529], [1532, 1532, 1546, 1546, 1604], [1606, 1613, 1639, 1639, 1735], [1738, 1738, 1773, 1773, 1868], [1870, 1910, 1945, 1945, 2197], [2200, 2200, 2257, 2257, 4159]]}
{"id": "fdcGR2", "name": "Water Drops", "author": "midorikuma", "description": "moist", "tags": ["surface", "wet"], "likes": 1, "viewed": 85, "date": "1630156464", "time_retrieved": "2024-06-20T20:46:50.557431", "image_code": "const float Nlen = 100.0;\nconst float Ns = 1.0;\nconst float Ts = 1.5;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 _ms = vec3(1.0,0.0,0.0);\n    vec4 _ps = vec4(-10.0);\n    vec2 rd0 = abs(fragCoord/iResolution.xy);\n    vec2 rds = rd0;\n    vec2 fc = fragCoord;\n    float nlim = floor(iTime*Ns+abs(cos(iTime))*Ns);\n    float nmin = (nlim-Nlen)*step(Nlen, nlim);\n\n    for(float n = nmin; n < nlim; n++){\n        float t=(iTime-n/Ns);\n        t = (t-0.9*abs(sin(t/1.5-n)))*Ts;\n        float s = 30.0+cos(n)*10.0;\n        float r = min(iResolution.x,iResolution.y)/s;\n        vec2 p0 = vec2( cos(n*cos(n)) , cos(n*sin(n)) );\n        vec2 pt = vec2( t*0.0005*cos(n/7.0) , t*0.005*abs(cos(n)*5.0+pow(100.0,cos(n))) );\n        vec2 p = p0+pt;\n        vec2 rdc = fc * 2.0 - iResolution.xy + p*iResolution.xy;\n        float rl = r + sin(length(fc)/r*7.0)*r/(10.0+cos(n)*2.0);\n        float m1 = rl - length(rdc);\n\n        vec2 rl0 = vec2(r,pt.y*iResolution.y*(1.0-smoothstep(0.0,100.0,t)));\n        float m2 = rl/1.1 - length(vec2(rdc.x,rdc.y-rl/10.0));\n        float rr = (r+_ms.z)/min(iResolution.x,iResolution.y)*0.6;\n        float py = _ps.y+(_ms.y-t)*(_ps.w-_ps.y)/_ms.y;\n        bool fx = (_ps.x < p0.x+rr && p.x-rr < _ps.z)||(p0.x-rr < _ps.x && _ps.z < p.x+rr);\n        bool fy = (py < p0.y+rr && p.y-rr < _ps.w)||(p0.y-rr < py && _ps.w < p.y+rr);\n        if(fx&&fy){\n            rds = rd0;\n            _ms.x = 1.0;\n        }\n\n        vec2 rs =rd0*2.0-1.0;\n        if (step(length(rdc/rl0),1.0)*step(0.0,rdc.y)==1.0){\n            if (step(0.0,m1)==0.0){\n                rds.xy=vec2((-(rs.x+p.x)-p.x+1.0)/1.8,rds.y);\n            }\n        }\n        if (step(0.0,m1)==1.0){\n            rds = abs(1.0-((rs+p)*length(rdc)/rl*s*1.5+vec2(p.x,0.0)+1.0)/2.0);\n            _ms = vec3(m2,t,r);\n            _ps = vec4(p0,p);\n        }\n    }\n    \n    vec3 bg = vec3(3.0,4.0,10.0)*(rds.y/3.5+rds.x*rds.x/20.0)+0.15;\n    vec3 bg0 = vec3(3.0,4.0,10.0)*(rd0.y/3.5+rd0.x*rd0.x/20.0)+0.1;\n    vec4 Color = vec4(bg,1.0)-step(_ms.x,0.0);\n    fragColor =Color*0.35+vec4(bg0,1.0)*0.65;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdcGR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[70, 70, 127, 127, 2083]]}
{"id": "fdcGRH", "name": "3D close-loop spiral - 2", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/NddGzn[/url]\nmouse control\nWIP: still connection artifacts.", "tags": ["spiral", "short"], "likes": 13, "viewed": 190, "date": "1629103326", "time_retrieved": "2024-06-20T20:46:50.836451", "image_code": "// variant of https://shadertoy.com/view/NddGzn\n\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )             // rotation                  \nvec3 M;\n\n#define TAU 6.283185\n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.,l,a,A,s,z=0.,S,H,h,l2,r=25.,r2=20.33; //, Z=0.;\n    vec2  P,d;\n    vec3  R = iResolution,\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),         // ray direction\n          p = 90./R, q;                                      // marching point along ray \n       // M =  iMouse.xyz/R -.5;\n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0));\n     \n    for ( O=vec4(0) ; O.x < 1.5 && t > .01 ; O+=.01 )\n        t=9., q = p,\n        q.yz *= rot( .5+6.*M.y),                             // rotations\n        q.xz *= rot( 2.-6.*M.x),\n        q.zy *= H = sign(h=q.y),           q.y -= r/2.,      // top-down symmetry\n        q.xz *= S = sign(q.x +sign(q.z)) , q.x -= TAU*3.5,   // left-right symmetry\n        l = length(q.xz), a = atan(q.z,q.x),\n        s = min( TAU*3.5, l - a),                            // spiral coord ( truncated )\n        l = round(s/TAU)*TAU + a,                            // l reset at tube center\n        l = max(0.,r-l),\n        q.y += r2 - sqrt(max(0.,r2*r2-l*l)),                 // spiral sinking\n    a = max (0., round(s/TAU)*TAU + a ),\n    a = S*H*a*a/2.-20.*iTime -H*1.4, a*=2.,                      // curvilinear coordinate\n    q.y += sin(a), s += cos(a),                              // helicoid\n        t = min(t, length(vec2( mod(s+TAU/2.,TAU)-TAU/2.,q.y)) - .5), // SDF\n        p += .25*t*D; // , Z+=t;                             // step forward = dist to obj          \n\n // O = vec4(1.6-Z/200.); return;                    // for Depth buffer\n  //O = max(1.5-3.*O,0.);\n    O = O.x > 1.5 ? vec4(0.) : 4.*exp(-3.*O/2.);             // luminance (depth + pseudo-shading )\n                           // vec4(exp(-(Z-300.)/200.));\n    O *= vec4(.5+.5*h/r2,.5-.5*h/r2,0,0);    // color\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdcGRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 171, 207, 207, 1983]]}
{"id": "fdcGRj", "name": "大龙猫 - Quicky#058", "author": "totetmatt", "description": "One logpolar is nice, but how about a second one ? ", "tags": ["logpolar"], "likes": 7, "viewed": 193, "date": "1630133339", "time_retrieved": "2024-06-20T20:46:50.836451", "image_code": "/*\n\n Blame @byt3_m3chanic for the abuse of LogPolar\n and djH0ffman for the overuse of good sounds :D \n \n Thanks folks !\n\n*/\n\n#define PI 3.141592\n#define fGlobalTime iTime\nvec2 logpol(vec2 uv){\n    return vec2(log((length(uv))),atan(uv.y,uv.x));\n }\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n\n    vec3 col;\n\n   \n  uv*=rot(fGlobalTime*.5);\n  \n  uv = -logpol(uv)*3.0;\n  \n  uv+=fGlobalTime*.5;\n  uv = asin(sin(uv));\n  \n\n  uv = logpol(uv)*3.5*.5; // A 2 c'est MIEUX :D \n\n  uv.x -=sqrt(texture(iChannel0,fract(vec2(.1))).r*10.)*2.+fGlobalTime*1.0;\n  uv.y +=pow(fGlobalTime,1.2);\n  vec2 id = floor(uv);\n  uv = fract(uv)*2.-1.;\n  float d = length(uv)-.35-sin(id.x*3.+id.y*4.)*.2;\n  d/=3.5;\n  d = smoothstep(fwidth(d),0.,d);\n  d = d+abs(uv.x)-.1;\n    d = smoothstep(fwidth(d),-0.01,d);\n   \n  col  = mod(length(floor(uv)),2.) == 0. ? 1.-vec3(d) :  vec3(d);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "llXXDj", "previewfilepath": "https://soundcloud.com/freestylers/black-blue-feat-blapps-posse", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/freestylers/black-blue-feat-blapps-posse", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdcGRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 171, 192, 192, 247], [248, 248, 266, 266, 313], [314, 314, 371, 421, 1070]]}
{"id": "fdd3D8", "name": "double AA with fwidth", "author": "FabriceNeyret2", "description": "left:   bottom:   no AA\n         top:         only the strip borders are AA with fwidth. Problem when strip themselves get too thin.\nright:                too thin strips are AA too with another fwidth.\n\ntry variant patterns for 'a' ", "tags": ["moire", "aa", "fwidth"], "likes": 15, "viewed": 266, "date": "1629707617", "time_retrieved": "2024-06-20T20:46:51.005980", "image_code": "  #define SQR(v)     ( (v)*(v) )\n  #define fwidth2(v)  sqrt( SQR(dFdx(v)) + SQR(dFdy(v)) ) // for more isotropic\n//#define fwidth2(v)  fwidth(v)\n\nvoid mainImage(out vec4 O, vec2 u ) {    \n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y;\n          \n    float a = round(R.y/2.) * atan(U.y,U.x) + 3.*iTime,   // strip parameterization\n       // a = round(R.y/6.) * ( sin(4.*atan(U.y,U.x)) - length(U) ) , // variant pattern\n          s = sin( a ),                                   // strip base\n          v = U.y > 0.\n                ? clamp(.5 + .5 * s/fwidth(s), 0.,1.)     // top: strip pattern with AA borders\n                : step( 0., s ),                          // bottom: no AA\n      aa = smoothstep(3.14/3., 6.28/3., fwidth2(a));      // detect param going too fast\n          \n     if (U.x > 0.) v = mix(  v, .5, aa );                 // right: switch to grey to AA high strip freq\n    \n    O = vec4( sqrt( v ) );                                // to sRGB\n\n    if ( int(u.x)==int(R.x)/2 ) O = vec4(1,0,0,1);        // vertical separator\n    if ( int(u.y)==int(R.y)/2 ) O = vec4(1,0,0,1);        // horizontal separator\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdd3D8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[113, 146, 183, 183, 1144]]}
{"id": "fdd3Rr", "name": "Sailor Mars", "author": "kithy", "description": "background  when Sailor Mars transforms in the animation \"SailorMoon\".", "tags": ["raymarching", "particle"], "likes": 4, "viewed": 70, "date": "1629028291", "time_retrieved": "2024-06-20T20:46:51.012064", "image_code": "#define PI 3.1415\n#define NUM_LAYERS 4.0\n\nvec4 firstColor = vec4(0.9,0.7,0.0,1.0);//orange\nvec4 endColor = vec4(1.0,0.0,0.0,1.0);//red\n\n//gradient\nvec4 gradient(vec2 uv){\n\tvec4 col = mix(mix(firstColor*0.9, endColor*1.2, abs(uv.x)),mix(firstColor*0.9, endColor*1.2, abs(uv.x)),uv.x);\t\n\treturn col;\n}\n\n//rotation matrix\nmat2 rot(float a){\n\tfloat s=sin(a);\n\tfloat c=cos(a);\n\treturn mat2(c,-s,s,c);\n}\n//draw 1 circle\nfloat Circle(vec2 uv){\n\tfloat d=length(uv);\n\tfloat m=0.05/d;\n\tm*=smoothstep(1.0,0.2,d);\n\treturn m;\n}\n\n\n//draw 1 star\nfloat Star(vec2 uv,float flare){\n\n\t//center of star\n\tfloat d=length(uv);\n\tfloat m=0.05/d;\n\n\t//flare\n\tfloat rays=max(0.0,1.0-abs(uv.x*uv.y*1000.0));\n\tm+=rays*flare;\n\tuv*=rot(PI/4.0);\n\trays=max(0.0,1.0-abs(uv.x*uv.y*1000.0));\n\tm+=rays*flare*0.3;\n\tm*=smoothstep(1.0,0.2,d);\n\treturn m;\n}\n\n//make random value\nfloat Hash21(vec2 p){\n\tp=fract(p*vec2(123.34,456.21));\n\tp+=dot(p,p+45.32);\n\treturn fract(p.x*p.y);\n}\n\n//repetition circles\nvec3 CircleLayer(vec2 uv){\n\tvec2 gv=fract(uv)-0.5;\n\tvec2 id=floor(uv);\n\n\tvec3 col=vec3(0.0);\n\n\tfor(int y=-1;y<=1;y++){\n\t\tfor(int x=-1;x<=1;x++){\n\t\t\tvec2 offset=vec2(x,y);\n\t\t\tfloat n=Hash21(id+offset);\n\t\t\tfloat size=fract(n*345.32);\n\t\t\tfloat circle=Circle(gv-offset-vec2(n,fract(n*34.0))+0.5);\n\t\t\tcol+=circle*n*4.0;\n\t\t}\n\t}\n\treturn col;\n}\n\n//repetition stars\nvec3 StarLayer(vec2 uv){\n\tvec3 col=vec3(0.0);\n\t\n\tvec2 gv=fract(uv)-0.5;\n\tvec2 id=floor(uv);\n\t\n\tfor(int y=-1;y<=1;y++){\n\t\tfor(int x=-1;x<=1;x++){\n\t\t\tvec2 offset=vec2(x,y);\n\t\t\tfloat n=Hash21(id+offset);\n\t\t\tfloat size=fract(n*345.32);\n\t\t\tfloat star=Star(gv-offset-vec2(n,fract(n*34.0))+0.5,smoothstep(0.5,0.9,size));\n\t\t\t\n\t\t\t//blink\n\t\t\tstar*=sin(iTime*3.0+n*PI*2.0)*0.5+1.0;\n\t\t\tcol+=star*size;\n\t\t}\n\t}\n\treturn col;\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(fragCoord-iResolution.xy*0.5)/iResolution.y;\n\tuv*=2.0;\n\t//uv*=rot(t);\n\tuv.y-=iTime;\n\t\n\tvec4 background=gradient(uv);\n\tvec4 circle=vec4(CircleLayer(uv),1.0);\n\n\tvec3 col=vec3(0.0);\n\n\tfor(float i=0.0;i<1.0;i+=1.0/NUM_LAYERS){\n\t\tfloat depth=fract(i);\n\t\tfloat scale=mix(20.0,0.5,depth);\n\t\tfloat fade=depth*smoothstep(1.0,0.9,depth);\n\t\tcol=StarLayer(uv*scale+i*453.2*fade);\t\n\t}\n\t//col=pow(col,vec3(0.4545));\n\tfragColor=vec4(col,1.0)+circle+background;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdd3Rr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[136, 147, 170, 170, 299], [301, 319, 337, 337, 397], [398, 414, 436, 436, 514], [517, 531, 563, 582, 814], [816, 836, 857, 857, 936], [938, 959, 985, 985, 1295], [1297, 1316, 1340, 1340, 1727], [1730, 1730, 1783, 1783, 2241]]}
{"id": "fdt3Dr", "name": "Fork Piano by Moustave", "author": "Moustave", "description": "hoho", "tags": ["procedural", "3d", "raymarching", "distancefield"], "likes": 2, "viewed": 105, "date": "1629581874", "time_retrieved": "2024-06-20T20:46:53.127399", "image_code": "// Created by inigo quilez - iq/2013\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat udRoundBox( vec3 p, vec3 b, vec3 r )\n{\n  return length(max(abs(p)-b,0.0))-r.x;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opRepLim( in float p, in float s, in float mi, in float ma )\n{\n    return p-s*clamp(round(p/s),mi,ma);\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(13.5453123,31.1459123,37.3490423));\n}\n\n//----------------------------\n\nfloat obj1( in vec3 p )\n{\n    vec3 q = vec3( opRepLim(p.x+1.1,0.2,-122.0,123.0), p.yz-0.1 );\n\treturn udRoundBox( q, vec3(0.091,0.06*sin(10.0*(floor(5.0*p.x))+(iTime*10.0))+0.075,0.6)-0.005, vec3(0.01) );\n}\n\nfloat obj2( in vec3 p, in float d )\n{\n    vec3 q = vec3( opRepLim(p.x,0.2,-121.0,123.0), p.y-0.185, p.z - 0.3 );\n\tfloat k = mod( round( p.x/0.2 ), 7.0 );\n\n\tif( k==2.0 || k==6.0 ) return d;\n\n\treturn udRoundBox( q, vec3(0.06,0.075,0.4)-0.01, vec3(0.01,0.01,0.01) );\n}\n\nfloat obj3( in vec3 p )\n{\n\tfloat d1 = udRoundBox( p - vec3(0.0, 0.0,1.7), vec3(115.4,0.6,1.0), vec3(0.05) );\n\tfloat d2 = udRoundBox( p - vec3(0.0,-0.3,0.1), vec3(115.4,0.3,0.6), vec3(0.05) );\n\tfloat d3 = udRoundBox( p - vec3(0.0,-1.0,2.5), vec3(115.4,3.0,1.0), vec3(0.05) );\n\tfloat d4 = sdCylinder( vec3(abs(p.x),p.y,p.z) - vec3(115.25,-2.2,-0.35), vec2(0.1,2.0) );\n    d4 -= 0.03*smoothstep(-0.7,0.7,sin(18.0*p.y)) + 0.017*p.y + 0.025;\n\t\n\treturn min( min( min( d1, d2 ), d3 ), d4 );\n}\n\nfloat obj4( in vec3 p )\n{\n    return 3.75+p.y;\n}\n\nfloat obj5( in vec3 p )\n{\n    return min( 3.5-p.z, p.x+6.5 );\n}\n\nfloat obj6( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,1.3,1.1);\n\tfloat x = abs(q.x);\n\tq.z += 0.15*4.0*x*(1.0-x);\n\tq.yz = mat2(0.9,-0.43,0.43,0.9)*q.yz;\n    return 0.5*udRoundBox( q, vec3(1.0,0.7,0.0), vec3(0.01) );\n}\n\nfloat obj8( in vec3 p )\n{\n\tvec3 q = p - vec3(-0.5,-1.8,-2.0);\n\t\n\tq.xz = mat2( 0.9,0.44,-0.44,0.9)*q.xz;\n\t\n\tfloat y = 0.5 + 0.5*sin(8.0*q.x)*sin(8.0*q.z);\n\ty = 0.1*pow(y,3.0) * smoothstep( 0.1,0.4,q.y );\n    float d = udRoundBox( q, vec3(1.5,0.25,0.6), vec3(0.3) );\n\td += y;\n\t\n\tvec3 s = vec3( abs(q.x), q.y, abs(q.z) );\n\tfloat d2 = sdCylinder( s - vec3(1.4,-1.5,0.6), vec2(0.15,1.5) );\n\treturn min( d, d2 );\n}\n\nfloat obj7( in vec3 p )\n{\n\tvec3 q = p - vec3(1.0,-3.6,1.2);\n\tvec3 r = vec3( mod( q.x-0.25, 0.5 ) - 0.25, q.yz );\n    return max( 0.5*udRoundBox( r, vec3(0.05,0.0,0.38), vec3(0.08) ), sdBox( q, vec3(0.75,1.0,1.0) ) );\n}\n\nvec2 map( in vec3 p )\n{\n\t// white keys\n    vec2 res = vec2( obj1( p ), 0.0 );\n\n\t// black keys\n    vec2 ob2 = vec2( obj2( p, res.x ), 1.0 );\n\tif( ob2.x<res.x ) res=ob2;\n\n    // piano body\n    vec2 ob3 = vec2( obj3( p ), 2.0 );\n    if( ob3.x<res.x ) res=ob3;\n\n    // floor\n    vec2 ob4 = vec2( obj4( p ), 3.0 );\n    if( ob4.x<res.x ) res=ob4;\n\n    // wall\n    vec2 ob5 = vec2( obj5( p ), 4.0 );\n    if( ob5.x<res.x ) res=ob5;\n\n\t// paper\n    vec2 ob6 = vec2( obj6( p ), 5.0 );\n    if( ob6.x<res.x ) res=ob6;\n\t\n\t// pedals\n    vec2 ob7 = vec2( obj7( p ), 6.0 );\n    if( ob7.x<res.x ) res=ob7;\n\n\t// bench\n    vec2 ob8 = vec2( obj8( p ), 2.0 );\n    if( ob8.x<res.x ) res=ob8;\n\n\treturn res;\n}\n\n// https://iquilezles.org/www/articles/biplanar/biplanar.htm\nfloat boxmap( vec3 p, vec3 n )\n{\n\tp *= 0.15;\n\tfloat x = texture( iChannel3, p.yz ).x;\n\tfloat y = texture( iChannel3, p.zx ).x;\n\tfloat z = texture( iChannel3, p.xy ).x;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nfloat floorBump( vec2 pos, out vec2 id )\n{\n    pos *= 0.25;\n    float w = 0.015;\n    float y = mod( pos.x*8.0, 1.0 );\n    float iy = floor(pos.x*8.0);\n    float x = mod( pos.y*1.0 + sin(iy)*8.0, 1.0 );\n    float f = smoothstep( 0.0, w,     y ) - smoothstep( 1.0-w,     1.0, y );\n         f *= smoothstep( 0.0, w/8.0, x ) - smoothstep( 1.0-w/8.0, 1.0, x );\n    id = vec2( iy, floor(pos.y*1.0 + sin(iy)*8.0) );\n    return f;\n}\n\nvec4 floorColor( vec3 pos, out vec3 bnor )\n{\n\tpos *= 0.75;\n\tbnor = vec3(0.0);\n\n\tvec2 id;\n    vec2 e = vec2( 0.005, 0.0 );\n    float er = floorBump( pos.xz, id );\n    \n    vec3 col = vec3(0.6,0.35,0.25);\n\tfloat f = 0.5+0.5*texture( iChannel3, 0.1*pos.xz*vec2(6.0,0.5)+0.5*id ).x;\n    col = mix( col, vec3(0.4,0.15,0.05), f );\n\t\n\tcol.x *= 0.8;\n\n\tcol *= 0.85 + 0.15*texture( iChannel3, 2.0*pos.xz ).x;\n\n    // frekles\n    f = smoothstep( 0.4, 0.9, texture( iChannel3, pos.xz*0.2 - id*10.0).x );\n    col = mix( col, vec3(0.07), f*0.25 );\n\n    col *= 1.0 + 0.2*sin(32.0*(id.x-id.y));\n    col.x += 0.009*sin(0.0+32.0*(id.x+id.y));\n    col.y += 0.009*sin(1.0+32.0*(id.x+id.y));\n    col.z += 0.009*sin(2.0+32.0*(id.x+id.y));\n\n\treturn vec4( col*0.5, 0.35 );\n}\n\nvec4 pianoColor( in vec3 pos, in vec3 nor )\n{\n    float o = boxmap( 0.25*pos, nor );\n    float f = smoothstep( -0.25, 0.5, boxmap( 8.0*o + 1.0*pos*vec3(0.5,8.0,0.5), nor ) );\n\tfloat sp = f;\n\tvec3 col = 0.14*mix( 0.4*vec3(0.24,0.22,0.18), vec3(0.26,0.22,0.18), f );\n\n\tf = floor(pos.y*4.0) + 13.0*floor(abs(nor.x*pos.z + nor.z*pos.x)*0.4);\t\t\t\n\tcol *= 0.6 + 0.4*fract(sin(f)*13.5453);\n\n\tcol += 0.0012*sin( f*6.2831 + vec3(0.0,1.0,2.0) );\n    return vec4( col*0.6, 0.007*sp );\n}\n\nvec4 wallColor( in vec3 pos, in vec3 nor )\n{\n    vec3 col = 2.0*vec3(0.30,0.30,0.30);\n\n\tfloat f = 1.0-0.4*pow( boxmap( 1.5*pos*vec3(1.0,0.25,1.0), nor ), 1.7 );\n    col *= f;\n\n    return vec4(col,0.01*f);\n}\n\nvec4 paperColor( in vec3 pos, in vec3 nor )\n{\n    vec3 col = 0.7*vec3(0.22,0.21,0.18);\n\tcol = mix( col, col*vec3(1.0,0.9,0.8), clamp(0.5 + 0.5*abs(pos.x),0.0,1.0) );\n\tcol *= clamp(0.75 + 0.25*abs(2.0*pos.x),0.0,1.0);\n\t\n\tfloat f = smoothstep( 0.5,1.0, sin(250.0*pos.y) );\n\tf *=      smoothstep(-0.1,0.1, sin(250.0*pos.y/10.0) );\n\tf *= smoothstep( 0.1,0.11, abs(pos.x) ) - smoothstep( 0.85,0.86, abs(pos.x) );\n\tcol *= 1.0-f;\n\n\tf = smoothstep( -0.8,-0.2, sin(250.0*pos.y) );\n\tf *=      smoothstep(-0.1,0.1, sin(250.0*pos.y/10.0) );\n\tf *= smoothstep( 0.1,0.11, abs(pos.x) ) - smoothstep( 0.85,0.86, abs(pos.x) );\n\t\n\tfloat of = floor(0.5*250.0*pos.y/6.2831);\n\tfloat g = 1.0-smoothstep( 0.2,0.3,texture( iChannel3, pos.xy*vec2(0.5,0.01) + 0.15*of).x);\n\tcol *= mix( 1.0, 1.0-g, f );\n\t\n\tcol *= 0.5 + 0.7*texture( iChannel3, 0.02*pos.xy ).x;\n\t\t\n    return vec4(col,0.0);\n}\n\nvec4 benchColor( in vec3 pos, in vec3 nor )\n{\n    vec3 col = vec3(0.01,0.01,0.01);\n\t\n\tfloat g = smoothstep( 0.0, 1.0, boxmap( 1.0*pos*vec3(1.0,0.5,1.0), nor ) );\n\tcol = mix( col, vec3(0.021,0.015,0.015), g );\n\n\tfloat f = smoothstep( 0.3, 1.0, boxmap( 16.0*pos*vec3(1.0,1.0,1.0), nor ) );\n\tcol = mix( col, vec3(0.04,0.03,0.02), f );\n\n\treturn vec4( 10.2*col*vec3(1.3,0.9,1.0), 0.005*(1.0-g) );\n}\t\n\t\t\nvec4 calcColor( in vec3 pos, in vec3 nor, float matID, out vec3 bnor )\n{\n    bnor = vec3(0.0);\n\n\tvec4 mate = vec4(0.0);\n\t     if( matID<0.5 ) mate = vec4(0.22,0.19,0.15,0.2); // white keys\n\telse if( matID<1.5 ) mate = vec4(0.00,0.00,0.00,0.1); // black keys\n\telse if( matID<2.5 ) mate = pianoColor(pos,nor);      // piano\n\telse if( matID<3.5 ) mate = floorColor(pos,bnor);     // floor\n\telse if( matID<4.5 ) mate = wallColor(pos,nor);       // wall\n\telse if( matID<5.5 ) mate = paperColor(pos,nor);      // paper\n\telse if( matID<6.5 ) mate = vec4(0.04,0.03,0.01,0.9); // pedals\n\telse                 mate = benchColor(pos,nor);      // bench\n\treturn mate;\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 25.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    vec2 h = map( ro+rd*t );\n\t    m = h.y;\n        if( abs(h.x)<0.001 || t>maxd ) break;\n        t += h.x;\n    }\n\n    return (t<maxd) ? vec2( t, m ) : vec2(-1.0);\n}\n\n// https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    const vec3 eps = vec3(0.0002,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\n// https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<45; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, k*h/t);\n        t += clamp( h, 0.04, 0.1 );\n\t\tif( res<0.01 ) break;\n    }\n    return smoothstep(0.0,1.0,res);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<8; i++ )\n    {\n        float hr = 0.01 + 1.2*pow(float(i)/8.0,1.5);\n        vec3 aopos =  pos + nor*hr;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.85;\n    }\n    return clamp( 1.0 - 0.6*occ, 0.0, 1.0 );\n}\n\nfloat calcEdges( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    for( int i=0; i<4; i++ )\n    {\n\t\tvec3 aopos = normalize(hash3(float(i)*213.47));\n\t\taopos = aopos - dot(nor,aopos)*nor;\n\t\taopos = pos + aopos*0.5;\n        float dd = clamp( map( aopos ).x*10.0, 0.0, 1.0 );\n        occ += dd;\n    }\n\tocc /= 4.0;\n\t\n    return smoothstep( 0.5, 1.0, occ );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\t\n    // camera\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= 0.5 + 0.5*(7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n\tfloat an = 2.0 + 1.5*(0.5+0.5*sin(0.15*iTime - 6.2*m.x));\n    vec3 ro = 8.0*normalize(vec3(sin(an),0.4-0.3*m.y, cos(an)));\n    vec3 ta = vec3( -1.0, -1.7, 3.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n\t// render\n    vec3 col = vec3(0.0);\n\tfloat atten = 1.0;\n\tfor( int k=0; k<2; k++ )\n\t{\n\n\t// raymarch\n    vec2 tmat = raycast(ro,rd);\n    if( tmat.y>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd,nor);\n\t\tvec3 lig = normalize(vec3(-0.5,2.0,-1.0));\n        float edg = calcEdges(pos,nor);\n\t\tfloat occ = calcAO( pos, nor );\n\t\t\n        // material\n\t\tvec3 bnor = vec3(0.0);\n\t\tvec4 mate = calcColor( pos, nor, tmat.y, bnor );\n        nor = normalize( nor + bnor );\n\n\t\tif( tmat.y>1.5 && tmat.y<2.5 ) \n        {\n        float ru = edg*smoothstep( 0.3, 0.6, 0.1-0.2*occ + boxmap(pos,nor) );\n        mate = mix( mate, 0.25*vec4(0.3,0.28,0.2,0.0), ru );\n        }\n\t\t\n\t\t// lights\n        float amb = 0.6 + 0.4*nor.y;\n        float dif = max(dot(nor,lig),0.0);\n        float spe = pow(clamp(dot(lig,ref),0.0,1.0),3.0);\n\t\tfloat sha = softshadow( pos, lig, 0.01, 10.0 );\n\n\t\tvec3 win = pos + lig* (-10.0-pos.y)/lig.y;\n\t\twin.xz -= vec2(.0,4.0);\n        float wpa = pow( pow(abs(win.x),16.0) + pow(abs(win.z),16.0), 1.0/16.0 );\n        float wbw = 1.0-smoothstep( 3.0, 6.2, wpa*0.8 );\n        float wbg = 1.0-smoothstep( 3.5,14.0, wpa*0.8 );\n        wpa *= 1.0-smoothstep( 2.5, 3.5, wpa*0.8 );\n        wpa *= smoothstep( 0.1, 0.45, abs(win.x) );\n        wpa *= smoothstep( 0.1, 0.45, abs(win.z) );\n        sha *= wpa;\n\n\t\tvec3 lin = vec3(0.0);\n        lin  = 4.00*dif*vec3(1.5,0.85,0.55)*pow( vec3(sha), vec3(1.0,1.2,1.4) );\n\t\tlin += 0.50*wbg*wbw*vec3(1.2,0.6,0.3)*(0.5+0.5*clamp(0.5-0.5*nor.y,0.0,1.0))*pow(1.0-smoothstep(0.0,3.5,3.8+pos.y),2.0)*(0.2+0.8*occ);\n\t\tlin += 0.025*wbg*amb*vec3(0.75,0.85,0.9)*(0.1+0.9*occ);\n\t\tlin += (1.0-mate.xyz)*0.15*occ*vec3(1.0,0.5,0.1)*clamp(0.5+0.5*nor.x,0.0,1.0)*pow(clamp(0.5*(pos.x-1.5),0.0,1.0),2.0);\n\t\t\n\t\tcol += atten*mate.xyz*lin;\n        col += atten*10.0*mate.w*mate.w*(0.5+0.5*mate.xyz)*spe*sha*occ*vec3(1.0,0.95,0.9);\n\n\t\tatten *= 2.0*mate.w;\n\t\tro = pos + 0.001*nor;\n\t\trd = ref;\n    }\n\t}\n\t\n    // gain\n    col = 1.2*col/(1.0+col);\n    \n\t// desat\n\tcol = mix( col, vec3(dot(col,vec3(0.33))), 0.3 );\n\t\n    // gamma\n\tcol = pow( col, vec3(0.45) );\n\n\t// tint\n\tcol *= vec3(1.0,1.04,1.0);\n\t\n\t// vignetting\n\tvec2 q = fragCoord / iResolution.xy;\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n    fragColor = vec4( col,1.0 );\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "proprietary-license", "thumbnail": "https://www.shadertoy.com/media/shaders/fdt3Dr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[591, 662, 706, 706, 748], [750, 821, 852, 852, 939], [941, 1012, 1048, 1048, 1098], [1100, 1170, 1238, 1238, 1280], [1282, 1282, 1305, 1305, 1390], [1392, 1424, 1449, 1449, 1629], [1631, 1631, 1668, 1668, 1896], [1898, 1898, 1923, 1923, 2383], [2385, 2385, 2410, 2410, 2433], [2435, 2435, 2460, 2460, 2498], [2500, 2500, 2525, 2525, 2711], [2713, 2713, 2738, 2738, 3121], [3123, 3123, 3148, 3148, 3341], [3343, 3343, 3366, 3381, 4027], [4029, 4090, 4122, 4122, 4305], [4307, 4307, 4349, 4349, 4731], [4733, 4733, 4777, 4777, 5483], [5485, 5485, 5530, 5530, 5959], [5961, 5961, 6005, 6005, 6167], [6169, 6169, 6214, 6214, 7032], [7034, 7034, 7079, 7079, 7427], [7432, 7432, 7504, 7504, 8089], [8091, 8091, 8131, 8131, 8392], [8394, 8459, 8491, 8491, 8722], [8724, 8787, 8852, 8852, 9101], [9103, 9103, 9145, 9145, 9446], [9448, 9448, 9493, 9493, 9802], [9804, 9804, 9861, 9861, 12766]]}
{"id": "fdt3Rn", "name": "Double Spiral", "author": "dr2", "description": "Even more logarithmic spiraling", "tags": ["spiral", "logarithm", "project"], "likes": 13, "viewed": 196, "date": "1629012218", "time_retrieved": "2024-06-20T20:46:53.133474", "image_code": "// \"Double Spiraling\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// (see \"Spiraling Out\" and \"Spiraling In and Out\")\n\n#define AA  1   // =0/1 - optional antialiasing\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nvec3 ltDir;\nfloat tCur, dstFar, wSep;\nint idObj;\nconst float pi = 3.1415927;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r, a, dc;\n  dMin = dstFar;\n  for (float k = -1.; k <= 1.; k += 2.) {\n    q = p;\n    q.x -= k * wSep;\n    r = length (q.xz);\n    if (r > 0.01) {\n      q.xz *= k;\n      dc = max (r - wSep - 0.45, min (r - wSep + 0.55, - q.z));\n      a = atan (q.z, q.x) / pi;\n      q.xz = fract (vec2 (pi * log (r) - 0.5 * a, -5. * a) + 0.5) - 0.5;\n      if (r < 1.) q.y /= sqrt (r);\n      d = max (r * PrRoundBox2Df (vec2 (q.x, q.y - 0.12), vec2 (0.18, 0.1), 0.02), dc);\n      DMIN (1);\n      d = max (r * PrRoundCylDf (vec3 (q.x, q.y - 0.44, fract (2. * q.z - 0.7 * k * tCur +\n         0.5) - 0.5).xzy, 0.13, 0.04, 0.2), dc);\n      DMIN (2);\n    }\n  }\n  return 0.1 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 300; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, nDotL;\n  wSep = 5.77;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj >= dstFar && rd.y < 0.) {\n    dstObj = - ro.y / rd.y;\n    idObj = 3;\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = (idObj != 3) ? ObjNf (ro) : vec3 (0., 1., 0.);\n    if (idObj == 1) col4 = vec4 (0.1, 0.3, 0.8, 0.1);\n    else if (idObj == 2) col4 = vec4 (0.9, 0.8, 0.8, 0.3);\n    else if (idObj == 3) col4 = vec4 (0.2, 0.5, 0.2, 0.05);\n    if (idObj <= 2) col4 = mix (vec4 (0.2, 0.5, 0.2, 0.05), col4,\n       smoothstep (0.05, 0.1, length (vec2 (abs (ro.x) - wSep, ro.z))));\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (idObj == 2) nDotL *= nDotL;\n    col = col4.rgb * (0.2 + 0.8 * nDotL) + col4.a * pow (max (dot (ltDir,\n       reflect (rd, vn)), 0.), 32.);\n  } else {\n    col = vec3 (0.5);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.25 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.35 * pi, -0.15 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -30.);\n  zmFac = 4.;\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdt3Rn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[124, 606, 628, 628, 1313], [1315, 1315, 1348, 1348, 1596], [1598, 1598, 1619, 1619, 1874], [1876, 1876, 1911, 1911, 2763], [2765, 2765, 2821, 2821, 3834], [3836, 3836, 3883, 3883, 3930], [3932, 3932, 3989, 3989, 4064], [4066, 4066, 4102, 4102, 4308], [4310, 4310, 4340, 4340, 4453]]}
{"id": "fdt3WN", "name": "Kaleidoscope (atz)", "author": "ilyaev", "description": "Kaleidoscope study", "tags": ["kaleidoscope"], "likes": 1, "viewed": 47, "date": "1629868164", "time_retrieved": "2024-06-20T20:46:53.133474", "image_code": "#define PI 3.14159265359\n#define PI2 6.28309265359\n\n\nfloat n21(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898 + floor(1.), 4.1414))) * 43758.5453);\n}\n\nmat2 rot2d(float a) {\n    return mat2(vec2(sin(a), cos(a)), vec2(-cos(a), sin(a)));\n}\n\nvec3 wheelOfFortune(vec2 uv, float segments) {\n    float angle = atan(uv.y, uv.x) + iTime;\n    float segmentAngle = PI2 / segments;\n    float wid = floor((angle + PI) / segmentAngle);\n    float n = n21(vec2(wid, 3.2));\n    vec3 color = vec3(n, fract(n * 10.23) + sin(iTime + uv.y * 6.), fract(n* 123123.342) + cos(iTime + uv.x*6.1));\n    return color;\n}\n\nvec3 background(vec2 uv) {\n    vec3 color = vec3(0.);\n\n    vec3 c1 = wheelOfFortune(uv * rot2d(iTime), 8.); \n    vec3 c2 = wheelOfFortune(uv + vec2(sin(iTime) * .1, cos(iTime*.3) * .1) * rot2d(-iTime), 15.);\n    vec3 c3 = wheelOfFortune(uv - vec2(sin(iTime*.6) * .2, cos(iTime) * .2) * rot2d(-iTime), 15.);\n    color = (c1 * c2 / c3) / 3.;\n\n    // color /= 3.;\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float _SegmentCount = 7.;\n\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    vec2 shiftUV = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\n\n    float radius = sqrt(dot(shiftUV, shiftUV));\n    float angle = atan(shiftUV.y, shiftUV.x) + mouse.x;\n\n    float segmentAngle = PI2 / _SegmentCount;\n\n    float wid = floor((angle + PI) / segmentAngle);\n\n    angle -= segmentAngle * floor(angle / segmentAngle);\n\n    angle = min(angle, segmentAngle - angle);\n\n    vec2 uv = vec2(cos(angle), sin(angle)) * radius + sin(iTime) * 0.1;\n\n\n    vec3 color = vec3(0.);\n\n    color += background(uv);\n\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdt3WN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[53, 53, 72, 72, 153], [155, 155, 176, 176, 240], [242, 242, 288, 288, 595], [597, 597, 623, 623, 978], [980, 980, 1037, 1037, 1661]]}
{"id": "fdt3zj", "name": "Infinite spider web", "author": "sunhokim", "description": "Spider web!", "tags": ["procedual", "spider"], "likes": 8, "viewed": 176, "date": "1630215030", "time_retrieved": "2024-06-20T20:46:53.133474", "image_code": "// golfed version by FabriceNeyret2 (208 chars)\nvoid mainImage( out vec4 O,  vec2 p )\n{   \n    vec2  R = iResolution.xy;\n    float l = length( p -= .5 * R ) / R.y,\n          a = atan(p.y,p.x);\n\n\tO =     .3 * l \n        + ( .01 + .006 / ( 1.  + sin( 6.*l - 3.*iTime ) *.8 ) ) \n          / abs(  sin( 15.*a) \n                * sin( l*l*l*27. -1.5*iTime - a*.5 - l ) \n                * sin( l*2.7 ) \n               ) - O;\n}\n\n// golfed version by FabriceNeyret2 (218 chars)\n/*\nvoid mainImage( out vec4 O,  vec2 p )\n{   \n    vec2  R = iResolution.xy;\n    float l = length( p -= .5 * R ) / R.y,\n          a = atan(p.y,p.x);\n\n\tO =     .3 * l \n        + ( .01 + .03 / ( 1.  + sin( 6.*l - 3.*iTime ) *.8 ) / vec4(5,5,4,1) ) \n          / abs(  sin( 15.*a) \n                * sin( l*l*l*27. -1.5*iTime - a*.5 - l ) \n                * sin( l*2.7 ) \n               );\n}\n*/\n\n// original\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 p = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    float r = length(p)*3.0;\n    float a = atan(p.y,p.x);\n    float r2 = a*0.5+length(p);\n    vec3 color = vec3(0.1)*r;\n    float web = sin(15.0*a)*sin(pow(r, 3.0)-r2-1.5*iTime)*sin(r*0.9);\n    float ww = (abs(1.0 / (web * 30.7)) - 0.01);\n    float ww2 = (abs(1.0 / (web * (30.7-sin(-r*2.0+3.0*iTime)*25.0))) - 0.04);\n    color += vec3(0.3)*ww;\n    color += vec3(0.2,0.2,0.25)*ww2;\n\tfragColor = vec4(color, 1.0);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdt3zj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 48, 87, 87, 420]]}
{"id": "fdt3zX", "name": "Mandelbrot - AT", "author": "athibaul", "description": "Just a simple old Mandelbrot set, and some fun with coloring.", "tags": ["mandelbrot", "complex", "set", "coloring"], "likes": 7, "viewed": 80, "date": "1630359463", "time_retrieved": "2024-06-20T20:46:53.533573", "image_code": "vec2 cmul(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouseUV = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float ITER = 100.;\n    \n    if(iMouse.z > 0.)\n    {\n        // Magnification around the mouse position\n        uv = mouseUV + 0.1*uv;\n        ITER = 200.;\n    }\n\n    vec2 z = vec2(0);\n    float zz;\n    vec2 zmin = z;\n    float zzmin = 1000.;\n    float i;\n    for(i=0.; i<ITER; i++)\n    {\n        // The loop to determine whether a point is inside or outside\n        z = cmul(z, z) + uv;\n        zz = dot(z,z);\n        //zzmin = min(zz, zzmin);\n        if(zz < zzmin)\n        {\n            zzmin = zz;\n            zmin = z;\n        }\n        if(zz > 1000.) break;\n    }\n    \n    vec3 col;\n    if(i < ITER)\n    {\n        // We're outside!\n        // Color outside according to the rate of exit\n        // https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set#Continuous_(smooth)_coloring\n        float phi = log2(zz)/exp2(i);\n        col = 0.5 + 0.5*cos(log2(phi) + vec3(0,1,2) - iTime);\n        col *= smoothstep(0.8,0.,phi);\n    }\n    else\n    {\n        //col = 0.5 + 0.5*cos(0.5*round(iTime+6.*z.xyx)+vec3(0,1,2));\n        //col = 0.5 + 0.5*cos(iTime+3.*z.xyx+vec3(0,1,2));\n        \n        // Color inside according to smallest absolute value of the orbit\n        col = 0.5 + 0.5*cos(iTime+log(zzmin) + vec3(0,1,2));\n        //col = (0.5 + 0.5*cos(iTime+log(zzmin))) * vec3(0.1,0.5,1.);\n        \n        // Color according to the point whose orbit goes nearest the origin\n        vec3 col2 = 0.5 + 0.5*cos(iTime+zmin.yyy/zzmin+vec3(0,1,2));\n        //col += (0.5 + 0.5*cos(iTime+5.*zmin.yyy)) * vec3(1., 0.5, 0.1);\n        \n        float limit = 0.1 + 0.09*cos(0.618*iTime + uv.x);\n        col = mix(col, col2, smoothstep(0.0,limit,zzmin));\n        \n        //col = sqrt(1.-exp(-col));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdt3zX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 27, 27, 84], [86, 86, 143, 143, 2046]]}
{"id": "fdtGDN", "name": "Tone mapping experiments", "author": "tiusic", "description": "Playing with tone mapping. I'm not aiming for realism, I want cartoonishly extravagant colors. In particular, I want red to fade to orange/yellow before fading to white.", "tags": ["hdr", "tonemapping"], "likes": 2, "viewed": 78, "date": "1629915714", "time_retrieved": "2024-06-20T20:46:54.800243", "image_code": "// Experimenting with tone mapping. I'm not aiming for realism, I want\n// cartoonishly extravagant colors. In particular, I want red to fade to orange\n// or yellow before fading to white, whereas most tone mappers just fade from\n// red to white. Similarly, green should fade through cyan, and blue should fade\n// through magenta.\n\n// The function commented as \"Old HDR function\" did this, but had patches where\n// the color didn't change. This produced ugly results in the final image. It's\n// easy to do smooth tone mapping, and it's easy to bleed one channel into\n// another in the asymmetric way I want, but it turns out to be really hard to\n// do both of those things at the same time.\n\n// After a bunch of failed experiments I settled on the hdr function it's\n// running now. This is a complicated piecewise function that essentially has\n// six hard coded gradients, for different hues, and lerps between them (plus a\n// bunch of corrections and hacks).\n\n\nvec3 mid3_(vec3 v) { return v.y < v.z ? vec3(0, v.y, 0) : v.x < v.z ? vec3(0, 0, v.z) : vec3(v.x, 0, 0); }\nvec3 mid3(vec3 v) { return v.x < v.y ? mid3_(v) : mid3_(v.yxz).yxz; }\nvec3 max3v(vec3 v) { return v.x < v.y ? (v.y < v.z ? vec3(0, 0, v.z) : vec3(0, v.y, 0)) : (v.x < v.z ? vec3(0, 0, v.z) : vec3(v.x, 0, 0)); }\nfloat max3(vec3 v) { return max(max(v.x, v.y), v.z); }\nvec3 lerp(vec3 a, vec3 b, float t) { return (1. - t) * a + t * b; }\nvec3 qerp(vec3 a, vec3 b, float t) { return sqrt(1. - t * t) * a + t * b; }\n\nfloat tri(float x) {\n  x = mod(2. * x, 2.);\n  return x < 1. ? 3. * x - 1. : 5. - 3. * x;\n}\n\nvec3 hue(float h) {\n  return clamp(vec3(tri(h+0.5), tri(h+1./6.), tri(h-1./6.)), 0., 1.);\n}\n\nvec3 baseColor(vec2 uv) {\n  return 3. * uv.y * lerp(hue(uv.x), vec3(1), 0.5 + 0.5 * sin(iTime));\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Uchimura is copied from https://www.shadertoy.com/view/llXyWr\nfloat Tonemap_Uchimura(float x, float P, float a, float m, float l, float c, float b) {\n    // Uchimura 2017, \"HDR theory and practice\"\n    // Math: https://www.desmos.com/calculator/gslcdxvipg\n    // Source: https://www.slideshare.net/nikuque/hdr-theory-and-practicce-jp\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    float w0 = 1.0 - smoothstep(0.0, m, x);\n    float w2 = step(m + l0, x);\n    float w1 = 1.0 - w0 - w2;\n\n    float T = m * pow(x / m, c) + b;\n    float S = P - (P - S1) * exp(CP * (x - S0));\n    float L = m + a * (x - m);\n\n    return T * w0 + L * w1 + S * w2;\n}\n\nfloat Tonemap_Uchimura(float x) {\n    const float P = 1.0;  // max display brightness\n    const float a = 1.0;  // contrast\n    const float m = 0.22; // linear section start\n    const float l = 0.4;  // linear section length\n    const float c = 1.33; // black\n    const float b = 0.0;  // pedestal\n    return Tonemap_Uchimura(x, P, a, m, l, c, b);\n}\n\nvec3 Tonemap_Uchimura_RGB(vec3 v) {\n  return vec3(Tonemap_Uchimura(v.r), Tonemap_Uchimura(v.g), Tonemap_Uchimura(v.b));\n}\n\n\nfloat uchi(float x) {\n  float w0 = 1.0 - smoothstep(0.0, 0.22, x);\n  float w2 = step(0.532, x);\n  float S = 1. - 0.468 * exp((0.532 - x) / 0.468);\n  return 0.22 * pow(x / 0.22, 1.33) * w0 + S * w2 + x * (1.0 - w0 - w2);\n}\nvec3 uchi(vec3 v) { return vec3(uchi(v.r), uchi(v.g), uchi(v.b)); }\n\n\n// Old HDR function\n//vec3 hdr(vec3 c) { return c + max(c - 1., 0.).brg + max(c - 2., 0.).gbr; }\n\n\n// Experiments\n// vec3 hdr(vec3 c) { return c + max(max3(c) - 1., 0.); }\n// vec3 hdr(vec3 c) { return c + max(length(c) - 1., 0.); }\n// vec3 hdr(vec3 c) { return Tonemap_Uchimura_RGB(c); }\n\n/*vec3 hdr(vec3 c) {\n  float k = max3(c);\n  float k1 = max(k - 1., 0.);\n  float k2 = max(k - 2., 0.);\n  vec3 d = clamp(c, 0., 1.);\n  return d + k1 * d.brg + k2 * vec3(1.);\n}*/\n\n/*vec3 hdrc(vec3 v) {\n  const float p = 1.;\n  return vec3(pow(v.b, p), pow(v.r, p), pow(v.g, p));\n}\n\nvec3 hdr(vec3 c) {\n  float k = max3(c);\n  float k1 = max(k - 1., 0.);\n  float k2 = clamp(k - 2., 0., 1.);\n  vec3 d = clamp(c, 0., 1.);\n  return lerp(d + k1 * hdrc(d), vec3(1.), k2);\n}*/\n\n/*vec3 hdr(vec3 c) {\n  vec3 k = max3v(c);\n  //float p = mid3(c);\n  //float k1 = max(k - 1., 0.);\n  //float k2 = max(k - 2., 0.);\n  //return vec3(p);\n  //return c + max(k - 1., 0.);\n  \n  return c + max(k - 1., 0.).brg;\n}*/\n\n/*vec3 hdr(vec3 c) {\n  float k = max3(c);\n  if (k < 1.) return c;\n  c = c / k + max(k - 1., 0.);\n  return c;\n}*/\n\n/*vec3 hdr(vec3 c) {\n  float m = max3(c);\n  if (m <= 1.) return c;\n  float k = 0.5 * (m - 1.);\n  float q = clamp(k, 0., 1.);\n  c = lerp(c / m, vec3(1.), q);\n  vec3 z = c - max3v(c);\n  return c + q * z;\n}*/\n\n/*vec3 hdr(vec3 c) {\n    float brightest = max(max(c.x, c.y), c.z);\n\n    const float kBrightBlendStart = .5;\n    const float kBrightBlendEnd = 3.5;\n\n    float super_bright = smoothstep(kBrightBlendStart, kBrightBlendEnd, brightest);\n\n    return mix(c, vec3(1), super_bright);\n}*/\n\n/*vec3 hdr(vec3 c) {\n    float brightest = max(max(c.x, c.y), c.z);\n\n    const float kBrightHueStart = .5;\n    const float kBrightHueEnd = 2.;\n    float hue_super_bright = smoothstep(kBrightHueStart, kBrightHueEnd, brightest);\n\n    const float kBrightSatStart = 2.;\n    const float kBrightSatEnd = 3.5;\n    float sat_super_bright = smoothstep(kBrightSatStart, kBrightSatEnd, brightest);\n\n    vec3 hsv = rgb2hsv(c);\n\n    float mapped_hue = mix(hsv.x, hsv.x + .1, hue_super_bright);\n    float mapped_sat = mix(hsv.y, 0., sat_super_bright);\n\n    return hsv2rgb(vec3(mapped_hue, mapped_sat, hsv.z));\n}*/\n\n/*vec3 hdr1(vec3 c) {\n  vec3 d0 = vec3(c.r + max(c.b - 0.8, 0.), c.g + 0.8 * max(c.b - 1.6, 0.), c.b);\n  float k = max(c.r, c.g) / c.b;\n  if (c.r > c.g) {\n    vec3 d1 = vec3(c.r, c.g + 0.8 * max(c.r - 0.8, 0.), c.b);\n    return lerp(d0, d1, k);\n  } else {\n    vec3 d1 = vec3(c.r + 0.8 * max(c.g - 0.8, 0.), c.g, c.b);\n    return lerp(d0, d1, k);\n  }\n}*/\n\n\n// Nicest algorithm I've got so far. Super complicated piecewise approach.\nfloat qq(float q, float p) { return pow(p, 4. * q * (q - 1.)); }\nvec3 hdrr(vec3 c) {\n  float l = min(c.g, c.b);\n  float m = (c.r - l);\n  if (m < 1e-6) return c;\n  float k = (max(c.g, c.b) - l) / m;\n  vec3 d = c + (1. - k) * vec3(0, 1.1 * max(c.r - 0.7, 0.), max(c.r - 1.2, 0.));\n  if (c.g > c.b) {\n    d.b += k * max(c.g - 0.8, 0.);\n  } else {\n    d.g += k * max(c.b - 0.8, 0.);\n  }\n  float j = 0.5 + 0.5 * (c.g > c.b ? k : -k);\n  float g = clamp(log(m / l), 0., 1.);\n  const float J = 0.38;\n  if (j < J) {\n    d.g *= qq(j / J, 1. - g * 0.2);\n    d.b /= qq(j / J, 1. - g * 0.2);\n  } else {\n    d.b *= qq((j - J) / (1. - J), 1. - g * 0.4);\n    d.g /= qq((j - J) / (1. - J), 1. - g * 0.2);\n  }\n  if (m < 0.3) {\n    return lerp(c, d, m / 0.3);\n  }\n  return d;\n}\n\nvec3 hdr(vec3 c) {\n  if (c.r > c.g && c.r > c.b) {\n    c = hdrr(c);\n  } else if (c.g > c.b && c.g > c.r) {\n    c = hdrr(c.gbr).brg;\n  } else if (c.b > c.r && c.b > c.g) {\n    c = hdrr(c.brg).gbr;\n  }\n  return uchi(c) * 1.05;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv.x = 1./6.;\n    //uv.x = 1./12.;\n    //uv.x = 0.;\n    //uv.x = 11./12.;\n    //uv.x = 5./6.;\n    //uv.x = iTime / 30.;\n    vec3 c = baseColor(uv);\n    c = hdr(c);\n    //if (c.r >= 1. && c.g >= 1. && c.b >= 1.) c = vec3(0);\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdtGDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[691, 961, 981, 981, 1067], [1068, 1068, 1087, 1087, 1137], [1138, 1138, 1158, 1158, 1278], [1279, 1279, 1299, 1299, 1333], [1334, 1334, 1370, 1370, 1401], [1402, 1402, 1438, 1438, 1477], [1479, 1479, 1499, 1499, 1569], [1571, 1571, 1590, 1590, 1662], [1664, 1664, 1689, 1689, 1762], [1764, 1764, 1786, 1786, 2117], [2119, 2119, 2141, 2141, 2310], [2312, 2377, 2464, 2648, 3116], [3118, 3118, 3151, 3151, 3467], [3469, 3469, 3504, 3504, 3590], [3593, 3593, 3614, 3614, 3814], [3815, 3815, 3834, 3834, 3882], [6421, 6496, 6524, 6524, 6560], [6561, 6561, 6580, 6580, 7254], [7256, 7256, 7274, 7274, 7482], [7484, 7484, 7541, 7541, 7842]]}
{"id": "fdtGW8", "name": "Text Fixed Color", "author": "Glsl_Fish", "description": "it is just  a  simple trying of my first shadertoy; ", "tags": ["test"], "likes": 0, "viewed": 115, "date": "1630051723", "time_retrieved": "2024-06-20T20:46:55.000358", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(1.0);\n    float a = 0.5+0.5*cos(iTime +uv.x+uv.y+iMouse.x*0.01);\n    float b = 0.5+0.5*sin(iTime +uv.x+uv.y+iMouse.x*0.01);\n    if(uv.x>a && uv.y>a)\n    {\n        // Time varying pixel color\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    }\n    else if(uv.x>a && uv.y<a)\n    {\n        col = 0.5 + 0.5*sin(iTime+uv.xyx+vec3(0,2,4));\n    }\n    else if(uv.x<a && uv.y<a)\n    {\n        col = 0.5 + 0.5*sin(iTime+uv.xyx+vec3(0,2,6));\n    }\n    else\n    {\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,6));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdtGW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 107, 747]]}
{"id": "fdtGz2", "name": "[CC 2021-08-28]  Shure Iken", "author": "totetmatt", "description": "Done for Chaos Constructions 2021 Shader Jam.\n\n** With comments ! **", "tags": ["terrain", "green", "outline"], "likes": 4, "viewed": 168, "date": "1630233109", "time_retrieved": "2024-06-20T20:46:56.145803", "image_code": "/*\n\nFOR THE SOUNDCLOUD, REFRESH THE PAGE IF YOU HAVE THE ERROR MESSAGE\n\nChaos Constructions 2021-08-28\n\n*** Thanks to all the shader showdown scene folks ***\n\n*** Thanks my co-participants Tater, eimink & provod. Go check their stuff ! ***\n\n*** Thanks havoc and random for organising the jam ! ***\n\n>>>>\n***** PRIVIET CHAOS CONSTRUCTION ! KAK DELA ?  *****\n<<<<\n*/\n\n//Bonzo Trick\n#define fGlobalTime iTime \n\n// Need this for switch Iso to non iso\n// You will see after, it's a munch of mix on camera \n// But keep in mind to respect everywhere the order of the mix\n// Here 0, mix left = Non iso and  1,mix right = Iso\n#define timer (clamp(cos(fGlobalTime*.5),-.25,.05)*2.+.5) \nmat2 rot(float a){float c=cos(a),s=sin(a);return  mat2(c,-s,s,c);}\n\nfloat txt(vec2 uv,float s){\n    uv = vec2(log(length(uv)),atan(uv.y,uv.x))*3.5/atan(1.); // LogPolar coordinates\n    uv -=fGlobalTime*.5; // Rotate and zoom in one  (thx logpolar)\n    int x = int(abs(uv.x)*s); \n    int y = int(abs(uv.y)*s);\n    float z = float(x ^ y) ;  // Some messing up, need int to play with Bit operation :) \n     return texture(iChannel0,fract(vec2( (z /s)*.1))).r; // I love fft based effect ;\n}\n// Based on iq\nfloat diam(vec3 p,float s){\n      p  =abs(p);\n      return (p.x+p.y+p.z-s)*inversesqrt(3.);\n       //                      ^----- does it make sense instead of sqrt(1./3.) ? I don't know\n  }\n// Based on iq  \n float box(vec3 p,vec3 b){ // Taht's a box, nothing fancy\n      vec3 q = abs(p)-b;\n      return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n    \n   }\n   \n   \n// a mix of Iq article on fbmdetail (and all fbm related stuff)\n// & Evvvvil stuff about displacement\n// It's a nice way to generate sort of terrain \nfloat dd(vec3 p){\n    p*=.1; // Scaling makes this low poly effect\n    float q = 0.; // Start at 0 but could tune that\n    vec4 pp= vec4(p,1.);\n    for(float i=0.;i<=12.;i++){ // yes 12 loop, but still \"cheap\" sort of ? \n           \n           // Doing whatever you want, clamp it and don't forget scale compentation\n           q += clamp(cos(length(pp.xz))+sin(pp.x)+sin(pp.z*2.) ,0.,.75)/pp.a; \n           pp.xz*=rot(-.785*i+i);\n           pp*=1.2;\n           pp.xyz = abs(pp.xyz)-.5;\n      }\n      return q;\n  \n }\n \n float qq = 0.; // Keep the displacement\n vec3 oop ;  // Keep the position for later\nvec2 sdf(vec3 p){\n   vec3 op =p ;\n    p.yz=mix(p.yz,p.yz*rot(atan(inversesqrt(1./2.))),timer); // Camera Switch between iso and non iso\n    p.xz=mix(p.xz,p.xz*rot(3.1415/4.),timer); // Camera Switch between iso and non iso\n    \n    vec2 h;\n   vec3 hp = p+vec3(0.,asin(sin(fGlobalTime)),0.); // Object doing up and down -> '/\\/\\/\\'\n    hp .x = abs(abs(hp.x)-3.1-texture(iChannel0,vec2(.3)).r)-1.5; // Duplication of 4 objects \n    hp.yz *=rot(-fGlobalTime); // You see them rollin\n    h.x = mix(box(hp,vec3(1.)),diam(hp,1.),1.3)*.9; // Secret receipe of the start / 3D shuriken\n    qq= sqrt(\n         texture(iChannel0,\n                 fract(vec2(floor(length(p.xz*10.)*.1)*.1-fGlobalTime*.5))\n                 ).r\n        )*.5; // did I told you I love fft  ? \n     h.y = mod(floor(fGlobalTime-p.x-p.z),2.) ==0. ? 3.:4.; // Texture switch for later\n     oop = hp; // need this for txture application later\n     \n     // Done with the shuriken, now the terrain\n     // Going forward right, or forwad on iso cam\n     p.zx +=fGlobalTime+100.;\n     vec2 t;\n    // Non conventional, not using the dot(n,vec3(0.,1.,0.)) but just p.y and then adding stuff\n    t.x = p.y+3.2+dd(p+qq*.5)*2.5+qq*.1+texture(iChannel0,vec2(p.z*.01)).r*.5;\n    \n    \n    //t.x = max(-(abs(p.x)+.5),t.x); I wanted to 'cut' the terrain in a band, couldn't remember how\n  \n    // Texture switch, the \"texture wave\" in the terrain\n    t.y = sin((op.x+op.z)*.1+fGlobalTime) < 0.01+qq? 1.:2.;\n    \n \n  // Mixing everything\n    h= t.x < h.x ? t:h;\n    \n    // OH YEAH\n    return h;  \n}\n\n// Routine for normal compute, sooo tini\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p, float e){vec2 nv= vec2(-e,e);return normalize(q(nv.xyy)+q(nv.yxy)+q(nv.yyx)+q(nv.xxx));}\n\n// Some ao, completly useless here and mostly incorrect\n#define ao(rp,n,k) (sdf(rp+n*k).x/k)\n#define AO(rp,n) (ao(rp,n,.1)+ao(rp,n,.3)+ao(rp,n,.5))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // El famoso background\n   vec3 col = vec3(.1)*txt(uv,100.);\n  \n  // Camera\n  vec3 ro = vec3(0.,0.,-5.);\n  float zz = 20.;\n  \n  ro = mix(ro,vec3(uv*zz,-zz),timer); // Camera Switch between iso and non iso\n  vec3 rd = normalize(vec3(uv,1.));\n  rd = mix(rd,vec3(0,0,1),timer);// Camera Switch between iso and non iso\n  vec3 light = vec3(1.,2.,-3.);\n  vec3 rp = ro;\n  vec3 acc = vec3(0.);\n  for(float i=0.;i<=128.;i++){\n      vec2 d= sdf(rp);\n      if(d.y == 1.){ // Add some \"glow\" on terrain\n        acc +=vec3(.1,0.,1.)*exp(-abs(d.x))/(69.-qq*10.);\n        \n        }\n      if(length(rp) > 75.) break; // If too far break;\n      if(d.x<.001){\n          vec3 n = norm(rp,.003); // Get normal\n          if(d.y == 1.){ // Texture 1 : \"Normal terrain\"\n          // For people that really know their stuff\n          // I'm still learning lightning, so what is under this comment\n          // will mostly be incorrect. I'm aware, and I'm working on it\n          float diff=  max(0.,dot(normalize(light-rp),n)); // diffraction \n          float spc = pow(max(0.,dot(normalize(ro-rp),reflect(-normalize(light),n))),16.); // Specular\n          float fr = pow(1.+dot(n,rd),8.); // Frenel\n          col = vec3(.01)*diff+ vec3(1.)*spc+fr*vec3(.0,1.,.0)*.5; //Color composition\n      \n          break; \n          } else if(d.y == 2.){ // Texture 2 : The terrain outline\n          // Outline stuff is basically computing the normal on the same point but at different\n          // \"scale / resolution / epsilon value\" and taking the different / lenght of it\n          // -> If you are on a surface that doesn't change that much (plane of sphere) length will be 0\n          // -> If you are close to and edge (corner , breaking in the shape), the length > 0\n              float edge = length(n-norm(rp,.001*length(ro-rp))); \n            col  = vec3(.0,1.,.0)*edge;\n            \n              break;\n          } else if(d.y== 3.){  // texture 3: Boring texture for shuriken\n  float diff=  max(0.,dot(normalize(light-rp),n));            \n            col = diff * vec3(1.);\n            \n                break;\n            } else if(d.y == 4.){ // Texture 4, the generative texture applied to shuriken\n               float diff=  max(0.,dot(normalize(light-rp),n));\n                col = diff*vec3(2.)*txt(oop.xz*.1,1.);\n                break;\n            }\n       }\n       \n       rp+=rd*d.x*.9; // Poor trick to avoid glitch (as you can see not fixing everything)\n    \n   }\n  col +=acc; // Don't forget the glow\n\n    // YAY\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": "llfXW2", "previewfilepath": "https://soundcloud.com/rezdubstep/signals-ep-out-now", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/rezdubstep/signals-ep-out-now", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdtGz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[408, 676, 694, 694, 742], [744, 744, 771, 771, 1163], [1164, 1179, 1206, 1206, 1369], [1370, 1388, 1413, 1444, 1547], [1556, 1706, 1723, 1723, 2222], [2241, 2310, 2327, 2327, 3860], [3862, 3929, 3956, 3956, 4035], [4037, 4186, 4243, 4293, 6905]]}
{"id": "fdtGzH", "name": "Fade to Green Tie-dye Spiral", "author": "vtgco", "description": "Strange tie-dye spiral thing", "tags": ["spiral"], "likes": 1, "viewed": 77, "date": "1629882305", "time_retrieved": "2024-06-20T20:46:56.145803", "image_code": "#define TWO_PI 6.2832\n\nbool ALIASED = false;\n\nfloat MOON_SIZE = 0.005;\nfloat BREATHING_ROOM = 0.001;\nfloat R_STEP;\n\nfloat ANTI_ALIAS_RADIUS;\nfloat ARC_ANTI_ALIAS_RADIUS;\n    \nfloat DISPLACEMENT_FACTOR;\n\n// -------------------------\n\nvec2 hash( vec2 x )  \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( in vec2 uv )\n{\n \tuv *= 2.;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f = 0.;\n    f  = abs(sin(0.5000*noise( uv ))); uv = m*uv;\n\tf += abs(sin(0.2500*noise( uv ))); uv = m*uv;\n\tf += abs(sin(0.1250*noise( uv ))); uv = m*uv;\n\tf += abs(sin(0.0625*noise( uv ))); uv = m*uv;\n\t//f  = 0.5 + 0.5*f;\n    return f;\n}\n\n\n// ------------------\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n// ------------------\n\nvoid setup() {\n    R_STEP = (MOON_SIZE + BREATHING_ROOM)*2.;\n    \n    float rel_moon_size = 0.02 / MOON_SIZE;\n    \n    ARC_ANTI_ALIAS_RADIUS = (0.2 * rel_moon_size);\n    ANTI_ALIAS_RADIUS = 1. - ARC_ANTI_ALIAS_RADIUS;\n    \n    ANTI_ALIAS_RADIUS *= MOON_SIZE;\n    \n    DISPLACEMENT_FACTOR = 0.01 / pow(rel_moon_size, 0.5);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setup();\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n     uv -= vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    uv.y -= 0.2;\n    uv *= 10.;\n    \n    \n    \n    float new_theta = atan(uv.y, uv.x) + TWO_PI*float(uv.y<0.);\n    float new_r = length(uv)/ R_STEP + 0.5;\n    \n    new_r += fbm(uv)*pow(new_r+1000.,1.5)*0.0005;\n    new_theta += fbm(uv)*pow(new_r+1000.,1.6)*0.0001;\n    \n    \n    float phase = new_theta*2./TWO_PI + pow(new_r,0.75)*0.1 - iTime * 0.25;\n    phase = mod(phase, 2.);\n    \n\n    \n    //phase += *0.5;\n   \n    //phase *= (1. + fbm(uv)*pow((new_r-1.),0.2)*5.);\n    \n    phase = 2. - smoothstep(-1., 1., (phase - 1.))*2.;\n    \n    \n    \n    //phase = mix(2. - smoothstep(0.,1.,smoothstep(-1., 1., (phase - 1.)))*2., 2. - smoothstep(-1., 1., (phase - 1.))*2., min(10000.*pow(new_r + 90.,-2.),1.));\n    \n    vec3 col = vec3(1.0);\n\n    //float brightness = max((1. - min(phase, 2. - phase))*2.  + (1.-abs(1.-phase))/length(uv)* 0.3, 0.01);\n    \n    float brightness = smoothstep(0., 1., smoothstep(0., 1., smoothstep(0., 1., smoothstep(0., 1., abs(phase - 1.)))))*1.5;\n    brightness = max(brightness, 1.5*min(1., pow(new_r*0.015, -2.)));\n\n    \n    vec3 colorHSL = vec3(phase * .5 + 0.3, 0.6, .76);\n    vec3 colorRGB = hsl2rgb(colorHSL);\n    \n    col = mix(col, colorRGB, brightness);\n\n    fragColor = vec4(col, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdtGzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[203, 233, 256, 256, 394], [396, 396, 422, 422, 820], [822, 822, 847, 847, 1146], [1149, 1172, 1199, 1199, 1342], [1344, 1367, 1381, 1381, 1695], [1698, 1698, 1755, 1755, 3161]]}
{"id": "fl2SDV", "name": "infinite maze", "author": "FabriceNeyret2", "description": "porting Own_Army5576's https://www.desmos.com/calculator/hnsjwwp02s\n\n( of course it would be cooler with a procedural maze + trajectory :-D \n  Sketched here: https://www.shadertoy.com/view/stjXWV \n)", "tags": ["infinite", "maze"], "likes": 42, "viewed": 317, "date": "1628679625", "time_retrieved": "2024-06-20T20:46:56.503525", "image_code": "// porting Own_Army5576's  https://www.desmos.com/calculator/hnsjwwp02s\n// see https://old.reddit.com/r/desmos/comments/ovpnyg/desmos_challenge_12_mazes/h7k89oz/\n\n// draw line segment https://www.shadertoy.com/view/llySRh\nfloat D(vec2 p, vec2 a, vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    p -= b * h;\n    return dot(p,p);\n}\n#define S(v) smoothstep( 9./R.y, 0., v )    \n\n// draw poly-line.  NB: GLSL func can't have vec2[] parameter → macro\n#define L( U, L, n, s )                                          \\\n    for( a = L[i=0] ; i < n ; a=b, i++ ) {                       \\\n        b = L[i];                                                \\\n        if (b.x==99.) a = L[++i], b = L[++i];                    \\\n        m = min(m, D(U,a*s,b*s) );                               \\\n    } \n\n// maze tile\nvec2 L[] = vec2[] (\n    vec2(5,-5),vec2(3,-5),vec2(3,-7),vec2(  1,-7),vec2(1,-9),vec2(9,-9),vec2(9,9),vec2(-9,9),vec2(-9,-9),vec2(-1,-9),vec2(-1,-5),vec2(1,-5),vec2(1,-3),vec2(99),\n    vec2(3,-3),vec2(7,-3),vec2(7,-7),vec2(7,7),vec2(99),\n    vec2(5,-9),vec2(5,-7),vec2(99),\n    vec2(5,9),vec2(5,3),vec2(99),\n    vec2(5,-1),vec2(5,1),vec2(3,1),vec2(3,7),vec2(99),\n    vec2(1,9),vec2(1,5),vec2(99),\n    vec2(-1,3),vec2(-1,7),vec2(99),\n    vec2(-3,9),vec2(-3,5),vec2(-5,5),vec2(-5,1),vec2(-5,5),vec2(-7,5),vec2(-7,7),vec2(-5,7),vec2(99),\n    vec2(-3,-1),vec2(-7,-1),vec2(-7,3),vec2(-7,-3),vec2(-5,-3),vec2(99),\n    vec2(-7,-5),vec2(-3,-5),vec2(-3,-3),vec2(-3,-7),vec2(-7,-7),vec2(99),\n    vec2(1,-3),vec2(3,-3),vec2(3,3),vec2(-3,3),vec2(-3,-3),vec2(-1,-3)\n  );\n// solved trajectory  \nvec2 T[] = vec2[] ( \n   vec2(0,-9),vec2(0,-6),vec2(2,-6),vec2(2,-4),vec2(4,-4),vec2(6,-4),vec2(6,-6),vec2(6,-8),vec2(8,-8),vec2(8,-6),vec2(8,-4),vec2(8,-2),vec2(8,0),\n   vec2(8,2),vec2(8,4),vec2(8,6),vec2(8,8),vec2(6,8),vec2(6,6),vec2(6,4),vec2(6,2),vec2(4,2),vec2(4,4),vec2(4,6),vec2(4,8),vec2(2,8),vec2(2,6),\n   vec2(2,4),vec2(0,4),vec2(0,6),vec2(0,8),vec2(-2,8),vec2(-2,6),vec2(-2,4),vec2(-4,4),vec2(-4,2),vec2(-4,0),vec2(-6,0),vec2(-6,2),vec2(-6,4),\n   vec2(-8,4),vec2(-8,2),vec2(-8,0),vec2(-8,-2),vec2(-8,-4),vec2(-8,-6),vec2(-8,-8),vec2(-6,-8),vec2(-4,-8),vec2(-2,-8),vec2(-2,-6),vec2(-2,-4),vec2(0,-4),vec2(0,-3) \n  );\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = 3.*( 2.*u - R ) / R.y, a,b;\n\n    float s = .33+.67*exp2( mod(iTime,2.) ), // original: 1. + mod(iTime,2.);\n          m =  99., l;\n    \n    int i,z,p = T.length(), n = int(26.5*(s-1.)+1.);\n    for ( z=0; z < 3; s/=3., z++ ) {                    // fractal levels\n        if (z==2) p = n;                                // full L0,L1, evol L2\n        L( U, T, p, s);                                 // draw trajectory tile\n    }\n    l = m; s*=27.;\n    \n    for ( z=0; z < 6; s/=3., z++ )                      // fractal levels\n        L( U, L, L.length(), s );                       // draw maze tile\n\n    O = vec4(1);                                        // paint\n    O -= m==l ? S( sqrt(m) - 20./R.y ) * vec4(0,1,1,0)\n              : vec4( S( sqrt(m)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fl2SDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[163, 222, 255, 255, 367], [1600, 2250, 2288, 2288, 3090]]}
{"id": "fl2SRd", "name": "Simple Wiggly Gradient", "author": "AngryKnees", "description": "It's a gradient that wiggles and shadertoy wants a description", "tags": ["colorgradient"], "likes": 1, "viewed": 107, "date": "1628394581", "time_retrieved": "2024-06-20T20:46:56.503525", "image_code": "const float TAU = 6.28318530718;\n\nconst vec3 color1 = vec3(0.035, 0.011, 0.149);\nconst vec3 color2 = vec3(0.141, 0.019, 0.137);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = mix(color1, color2, uv.x \n        + sin(uv.y * TAU + iTime) * 0.1\n        + sin(uv.y * TAU * 1.734 - iTime * 1.743) * 0.1\n        + sin(uv.y * TAU * 0.823 + iTime * 1.324) * 0.1\n    );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fl2SRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[129, 129, 186, 236, 535]]}
{"id": "fl2Sz3", "name": "Desert Postcard 2", "author": "dr2", "description": "Updated: wobbly blob in a (pseudo-)Nabatean treasury, with some dynamic trompe-l'oeil (mousing recommended)", "tags": ["reflection", "illusion", "archaeology", "petra"], "likes": 16, "viewed": 183, "date": "1628237659", "time_retrieved": "2024-06-20T20:46:56.528973", "image_code": "// \"Desert Postcard 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 bSize, sunDir, vnBlk;\nvec2 blbRad;\nfloat tCur, dstFar, pcUp;\nint idObj;\nbool isSh;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 SMap (vec3 p, float t)\n{\n  float f;\n  f = 2.;\n  for (int k = 0; k < 5; k ++) {\n    p += 0.4 * sin (1.7 * p.yzx / f + f * t);\n    f *= 0.8;\n  }\n  return p;\n}\n\nfloat BlobDf (vec3 p)\n{\n  vec3 q;\n  float d, t;\n  t = tCur + 1.31;\n  q = p;\n  q.xz = Rot2D (q.xz, 0.2 * t);\n  d = SmoothMin (PrBoxDf (SMap (q - vec3 (0.7, 0., 0.), t + 2.), vec3 (blbRad.x)),\n     PrBoxDf (SMap (q - vec3 (-0.7, 0., 0.), 1.3 * t), vec3 (blbRad.y)), 0.2);\n  return d * (isSh ? 1. : 0.25);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 cs, b, s;\n  float dMin, d, g, w;\n  dMin = dstFar;\n  cs = sin (pi / 16. + vec2 (0., 0.5 * pi));\n  w = 0.06;\n  p.y -= pcUp;\n  q = p;\n  q.y -= 7.5;\n  g = dot (vec2 (abs (q.x), q.y), cs);\n  d = min (max (min (abs (g) - w, 0.), - q.y - 0.7),\n     max (min (abs (q.y + 0.725) - w, 0.), g - w));\n  q.y -= -0.25;\n  g = dot (vec2 (abs (q.x), q.y), cs);\n  b = vec2 (4., 3);\n  q = p;\n  q.y -= 3.5;\n  s = abs (q.xy) - b;\n  d = min (d, min (max  (min (s.y - w, 0.), min (abs (s.x) - w, 0.)),\n     max  (min (s.x - w, 0.), min (abs (s.y) - w, 0.))));\n  q = p;\n  q.yz -= vec2 (4., bSize.z);\n  d = max (PrBoxDf (q - vec3 (0., 0., -0.2), bSize), - d);\n  q.y -= -0.5;\n  d = max (d, - PrBox2Df (q.xy, b - 3. * w));\n  q.y -= -2.7;\n  d = max (d, - PrCylDf (q.xzy, 3., 0.3));\n  DMIN (1);\n  q = p;\n  q.y -= 4.;\n  d = PrBoxDf (q, vec3 (bSize.xy, 0.1));\n  q.y -= -0.5;\n  d = max (d, - PrBox2Df (q.xy, b - 3. * w + 0.05));\n  DMIN (2);\n  q = p;\n  q.y -= 3.5;\n  g = abs (q.x) - b.x;\n  q.xz = vec2 (mod (q.x + 0.75, 1.5) - 0.75, abs (q.z - bSize.z) - bSize.z + 0.3);\n  d = PrCylDf (q.xzy, 0.2, b.y - 4. * w);\n  q.y = abs (q.y) - b.y + 4. * w;\n  d = max (min (d, PrCylDf (q.xzy, 0.275, w)), g);\n  DMIN (3);  \n  q = p;\n  q.yz -= vec2 (3., bSize.z);\n  if (! isSh) d = PrBoxDf (q, vec3 (b - 3. * w, bSize.z)) + 0.1;\n  if (isSh || d < dMin) {\n    d = BlobDf (q);\n    DMIN (4);\n    q.y -= -2.75;\n    d = PrCylDf (q.xzy, 3., 0.3);\n    DMIN (5);\n  } else dMin = min (dMin, d);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 180; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 ObjNfL (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  float s;\n  e = vec2 (0.01, -0.01);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  s = dot (v, vec4 (1.));\n  return vec4 (normalize (2. * v.yzw - s), (s - 2. * v.x - 4. * ObjDf (p)) / (e.x * e.x));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float d;\n  p.y -= bSize.y + pcUp;\n  p.z -= -0.1;\n  q = p;\n  d = PrBoxDf (q, vec3 (bSize.xy, 0.1));\n  q.xy -= bSize.xy * vec2 (-0.8, 0.6);\n  d = max (d, - PrBox2Df (q.xy, vec2 (1.)));\n  return d;\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat BlkHit (vec3 ro, vec3 rd, vec3 sz)\n{\n  vec3 v, tm, tp;\n  float dMin, dn, df;\n  dMin = dstFar;\n  v = ro / rd;\n  tp = sz / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    vnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return dMin;\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi) * vec2 (0.5, 1.);\n  s1 = abs (sin (4. * pi * abs (q.y + 1.5 * Fbm2 (0.7 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi) * vec2 (0.5, 1.);\n  s2 = abs (sin (3.1 * pi * abs (q.y + 1.9 * Fbm2 (0.5 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return 1.2 * mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec3 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e;\n  float h;\n  e = vec2 (0.002, 0.);\n  h = RippleHt (p);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vn;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  if (rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.02 * (ro.xz + 0.5 * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    col = mix (vec3 (0.4, 0.5, 0.8), clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col * vec3 (1., 0.8, 0.8);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, vn4;\n  vec3 col, vn, rob, roo;\n  vec2 vf, s;\n  float dstObj, dstGrnd, db, sh, f, y, sb;\n  bool isBg;\n  isBg = true;\n  sh = 1.;\n  roo = ro;\n  db = BlkHit (ro + vec3 (0., - bSize.y - pcUp, 0.1), rd, vec3 (bSize.xy, 0.05));\n  if (db < dstFar) {\n    rob = ro + db * rd;\n    vf = vec2 (0.);\n    sb = Maxv2 (abs (vec2 (rob.x, rob.y - bSize.y - pcUp)) - bSize.xy);\n    if (rob.z < -0.1 && sb < -0.2) {\n      blbRad = vec2 (1.1 + 0.31 * sin (tCur + 1.31), 1. + 0.41 * sin (1.7 * (tCur + 1.31)));\n      isSh = false;\n      dstObj = ObjRay (ro, rd);\n      if (dstObj < dstFar && idObj == 5) {\n        ro += dstObj * rd;\n        rd = reflect (rd, vec3 (0., 1., 0.));\n        ro += 0.01 * rd;\n        dstObj = ObjRay (ro, rd);\n      }\n      if (dstObj < dstFar) {\n        ro += dstObj * rd;\n        if (idObj != 4) vn = ObjNf (ro);\n        else {\n          vn4 = ObjNfL (ro);\n          vn = vn4.xyz;\n        }\n        y = ro.y - pcUp;\n        if (idObj == 1) {\n          if (vn.y > 0.99 && length (ro.xz - vec2 (0., bSize.z)) < 3.) {\n            col4 = vec4 (0.95, 0.95, 1., 0.3);\n          } else {\n            col4 = vec4 (0.6, 0.4, 0.3, 0.05) * (0.7 + 0.3 * Fbm2 (vec2 (ro.x, y) * vec2 (1., 32.)));\n            if (vn.z < -0.99) vf = vec2 (8., 1.);\n            else vf = vec2 (16., 1.);\n          }\n        } else if (idObj == 2) {\n          col4 = vec4 (0.5, 0.4, 0.3, 0.1);\n        } else if (idObj == 3) {\n          col4 = vec4 (0.6, 0.4, 0.2, 0.2) * (1. -\n             0.5 * smoothstep (0.45, 0.5, abs (mod (3. * y + 0.5, 1.) - 0.5)));\n          s = vec2 (mod (ro.x + 0.75, 1.5) - 0.75, abs (ro.z - bSize.z) - bSize.z + 0.3);\n          vn.xz = Rot2D (vn.xz, -0.15 * pi * sin (pi * (0.5 -\n             mod (12. * (atan (s.x, s.y) / (2. * pi) + 0.5), 1.))));\n        } else if (idObj == 4) {\n          col4 = vec4 (vec3 (0.95, 0.95, 1.) * (1. - step (8., vn4.w)), 0.3);\n        }\n        if (vf.x > 0.) vn = VaryNf (vf.x * vec3 (ro.x, y, ro.z), vn, vf.y);\n        isSh = true;\n        isBg = false;\n      } else if (rd.y < 0.) {\n        dstGrnd = - ro.y / rd.y;\n        ro += dstGrnd * rd;\n        isSh = true;\n      }\n      sh = isSh ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n      if (! isBg) col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n      else if (isSh) ro -= dstGrnd * rd;\n    } else {\n      ro = rob;\n      vn = vnBlk;\n      col4 = vec4 (0.85, 0.85, 0.8, 0.1);\n      vf = vec2 (64., 0.5);\n      if (rob.z < -0.1) {\n        if (sb < -0.2) col4 *= 0.5;\n        isBg = false;\n      } else {\n        vn.z *= -1.;\n        f = 0.;\n        rob.y -= bSize.y + pcUp;\n        if (abs (rob.y) < bSize.y - 0.5) f = abs (rob.x);\n        if (abs (rob.x + 0.5 * bSize.x) < 0.5 * bSize.x - 1.) \n           f = abs (abs (rob.y + 0.3 * bSize.y) - 0.5);\n        s = abs (vec2 (rob.xy) - bSize.xy * vec2 (-0.8, 0.6)) - 0.8;\n        if (Maxv2 (s) < 0.02) f = Minv2 (abs (s));\n        if (f > 0.) col4 *= 0.5 + 0.5 * smoothstep (0.02, 0.04, f);\n        isBg = false;\n        if (max (s.x, s.y) < -0.02) {\n          isBg = true;\n          ro = roo;\n        }\n      }\n      if (! isBg) {\n        vn = VaryNf (vf.x * ro, vn, vf.y);\n        col = col4.rgb * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n           col4.a * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n      }\n    }\n    col *= vec3 (1., 0.9, 0.9);\n  }\n  if (isBg) {\n    ro = roo;\n    if (rd.y < 0.) {\n      dstGrnd = - ro.y / rd.y;\n      ro += dstGrnd * rd;\n      vn = vec3 (0., 1., 0.);\n      f = 1. - smoothstep (0.3, 0.6, dstGrnd / dstFar);\n      if (f > 0.) vn = VaryNf (4. * ro, RippleNorm (ro.xz, vn, 4. * f), f);\n      if (sh == 1.) sh = ExObjSShadow (ro + 0.01 * vn, sunDir);\n      col = mix (vec3 (1., 0.8, 0.5), vec3 (0.9, 0.7, 0.5), 0.2 +\n         0.6 * smoothstep (0.7, 1.1, 2. * Fbm2 (2. * ro.xz)));\n      col = col * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.));\n      col = mix (col, vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.)) * vec3 (1., 0.8, 0.8);\n    } else col = SkyBgCol (ro, rd);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.015 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el -= pi * mPtr.y;\n  } else {\n    az = 0.8 * pi * (2. * mod (floor (0.05 * tCur), 2.) - 1.) *\n       SmoothBump (0.3, 0.7, 0.15, mod (0.05 * tCur, 1.));\n  }\n  el = clamp (el, -0.4 * pi, 0.02 * pi);\n  vuMat = StdVuMat (el, az);\n  bSize = vec3 (7., 4., 3.75);\n  pcUp = 0.3 * bSize.y * SmoothBump (0.25, 0.75, 0.2, mod (0.1 * tCur, 1.));\n  ro = vuMat * vec3 (0., 4.5, -27.);\n  zmFac = 4.5;\n  dstFar = 100.;\n  sunDir = normalize (vec3 (0., 0., -1.));\n  sunDir.xz = Rot2D (sunDir.xz, 0.2 * pi * sin (0.05 * 2. * pi * tCur));\n  sunDir.yz = Rot2D (sunDir.yz, pi * (0.17 + 0.07 * sin (0.03 * 2. * pi * tCur)));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  }\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fl2Sz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 823, 852, 852, 984], [986, 986, 1009, 1009, 1290], [1292, 1292, 1314, 1314, 2788], [2790, 2790, 2823, 2823, 3007], [3009, 3009, 3030, 3030, 3285], [3287, 3287, 3309, 3309, 3636], [3638, 3638, 3675, 3675, 3904], [3906, 3906, 3930, 3930, 4139], [4141, 4141, 4180, 4180, 4411], [4413, 4413, 4455, 4455, 4742], [4744, 4744, 4769, 4769, 5188], [5190, 5190, 5234, 5234, 5423], [5425, 5425, 5459, 5459, 6055], [6057, 6057, 6092, 6092, 10209], [10211, 10211, 10267, 10267, 11662], [11664, 11664, 11696, 11696, 11796], [11798, 11798, 11831, 11831, 11920], [11922, 11922, 11964, 11964, 12015], [12017, 12017, 12039, 12039, 12066], [12068, 12068, 12090, 12090, 12117], [12119, 12119, 12141, 12141, 12179], [12181, 12181, 12203, 12203, 12241], [12243, 12243, 12288, 12288, 12380], [12382, 12382, 12439, 12439, 12522], [12524, 12524, 12560, 12560, 12766], [12768, 12768, 12798, 12798, 12911], [12945, 12945, 12969, 12969, 13022], [13024, 13024, 13048, 13048, 13178], [13180, 13180, 13205, 13205, 13351], [13353, 13353, 13378, 13378, 13564], [13566, 13566, 13588, 13588, 13742], [13744, 13744, 13765, 13765, 13920], [13922, 13922, 13951, 13951, 14163], [14165, 14165, 14204, 14204, 14461]]}
{"id": "fl2SzG", "name": "Eroded rivers and plains", "author": "jarble", "description": "The erosion here is totally fake, but it looks realistic enough.", "tags": ["procedural", "fractal", "terrain", "river", "erosion"], "likes": 4, "viewed": 143, "date": "1627941607", "time_retrieved": "2024-06-20T20:46:57.521749", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\n\n//increase this constant to increase the amount of erosion\n#define OCTAVES 5\n\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    float value = 0.;\n    float factor = 3.;\n    uv *= factor;\n    for (int i = 0; i < OCTAVES; i++)\n    {\n        //uv = sin(uv/factor)*factor;\n        uv += min(sin(uv*factor)/factor,cos(uv/factor)*factor).yx;\n        value += sin((uv.x-uv.y-value))/factor;\n        \n        //uv += sin(dot(sin(uv/factor),sin(uv.yx/factor)));\n        uv= -uv/(factor);\n    }\n    \n    return value;\n}\n\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    float factor = 3.0;\n    return fbm(uv/factor)*factor;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*iTime);\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    #endif\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 1.;\n\n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fl2SzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[411, 489, 512, 561, 947], [1021, 1021, 1059, 1059, 1119], [1121, 1121, 1154, 1154, 1374], [1376, 1376, 1414, 1414, 1641], [1643, 1643, 1681, 1681, 1905], [1907, 1907, 1936, 1936, 2031], [2033, 2033, 2070, 2070, 2129], [2132, 2200, 2219, 2219, 2258], [2260, 2260, 2280, 2280, 2356], [2358, 2358, 2377, 2377, 2416], [2418, 2418, 2475, 2475, 2710], [2712, 2712, 2747, 2747, 3141], [3143, 3143, 3197, 3197, 3863], [3866, 3866, 3918, 3918, 4353], [4355, 4355, 4412, 4412, 5597]]}
{"id": "fl2XD3", "name": "mf audio visualizer", "author": "momie", "description": "my fourth audio visualizer", "tags": ["audio"], "likes": 0, "viewed": 20, "date": "1628938122", "time_retrieved": "2024-06-20T20:46:58.127730", "image_code": "// Reuse some code to calculate ray direction from shader created by inigo quilez - iq/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst float PI = 3.14159265;\n\nconst vec3 lightDir = vec3(-0.577, 0.577, 0.577);\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat dFn(vec3 p){\n    const float div = 7.;\n    const float an = 2.*PI/div;\n    float index = round(atan(p.y,p.x)/an);\n    float pick = (index+1.)/div;\n    vec4 spect = texture(iChannel0, vec2(pick,0.));\n    float angrot = index*an;\n    vec3 q = p;\n    q.xy = mat2(cos(angrot),-sin(angrot),\n                sin(angrot), cos(angrot))*q.xy;\n\n    float r = 1.5;\n    float lenxy = r*spect.x ;\n    float d = sdSphere( abs(q) - vec3(lenxy, 0, .5*sqrt(pow(r,2.) - lenxy)), .2*lenxy );\n    float d2 = sdSphere( p , 1. );\n    return smoothMin(d, d2, 20.0);\n}\n\nvec3 norm(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        dFn(p + vec3(  d, 0.0, 0.0)) - dFn(p + vec3( -d, 0.0, 0.0)),\n        dFn(p + vec3(0.0,   d, 0.0)) - dFn(p + vec3(0.0,  -d, 0.0)),\n        dFn(p + vec3(0.0, 0.0,   d)) - dFn(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 march(vec2 p){\n            \n    vec4 spect = texture(iChannel0, vec2(0,0.));\n    spect = spect-.5;\n    \n    float rotate = spect.x*.5*PI + 1.5*iTime;\n    vec3 target = vec3( 0.0, 0.0, 0.0 );\n    float r = 5.;\n    vec3 cPos = target + vec3( r*cos(rotate), 1.5*cos(.3*rotate), r*sin(rotate) );\n    mat3 direction = setCamera( cPos, target, 0. );\n    float fl = 2.0;\n    vec3 ray = direction * normalize( vec3(p,fl) );\n    \n    float distance = 0.0;\n    float rLen = 0.0;\n    vec3  rPos = cPos;\n    for(int i = 0; i < 64; i++){\n        distance = dFn(rPos);\n        rLen += distance;\n        rPos = cPos + ray * rLen*.5;\n    }\n    \n    vec4 col = vec4(0);\n    if(abs(distance) < 0.001){\n        vec3 normal = norm(rPos);\n        float diff = clamp(dot(lightDir, normal), 0., 1.0);\n        col = vec4(vec3(1.007*normal), 1.0);\n    }else{\n        col += vec4(0.5 + 0.5*cos(iTime+p.xyx+vec3(0,2,4)), 0);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    fragColor = march(p);\n}", "image_inputs": [{"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fl2XD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 260, 288, 288, 396], [398, 398, 443, 443, 512], [514, 514, 555, 555, 581], [583, 583, 601, 601, 1133], [1135, 1135, 1153, 1153, 1417], [1419, 1419, 1471, 1471, 1648], [1650, 1650, 1669, 1669, 2576], [2578, 2578, 2635, 2635, 2731]]}
{"id": "fl2XRK", "name": "Left Eye of Sauron ", "author": "Smake", "description": "Exps with coords and noise. \nThanks to Trisomie21 for the Ball Of Fire )", "tags": ["noise", "eye"], "likes": 5, "viewed": 51, "date": "1628089776", "time_retrieved": "2024-06-20T20:46:58.134088", "image_code": "// from Trisomie21's \"Ball Of Fire\" https://www.shadertoy.com/view/lsf3RH\n// very slight strokes over\n\nfloat snoise(vec3 uv, float res)\n{\n\tvec3 s = vec3(1e0, 1e1, 1e2);\n\tuv *= res;\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\n\tvec4 r = fract(sin(v*1e-1)*1e3);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 p = -.5 + fragCoord.xy / iResolution.xy;\n\tfloat color =2.5 - (2.5*length(2.*p));\n\t\n\tvec3 coord = vec3(atan(p.x+.5,p.y)/6.3, length(p)*.4, .5);\n\t\n\tfor(int i = 1; i <= 7; i++)\n\t{\n\t\tfloat power = pow(2.0, float(i));\n\t\tcolor += (1.5 / power) * snoise(coord + vec3(0.,-iTime*.01, iTime*.01), power*20.);\n\t}\n\tfragColor = vec4( color, pow(max(color,0.),2.)*0.4, pow(max(color,0.),3.)*0.15 , 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fl2XRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 103, 137, 137, 652], [654, 654, 712, 712, 1110]]}
{"id": "flBSDy", "name": "Dunes and ridges", "author": "jarble", "description": "A desert fractal landscape.\nThis is based on dyla's [url=https://www.shadertoy.com/view/WdcfDn]\"Fyords\"[/url] shader.", "tags": ["procedural", "fractal", "terrain", "dune"], "likes": 5, "viewed": 179, "date": "1628475448", "time_retrieved": "2024-06-20T20:46:59.121793", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\n\n//increase this constant to increase the amount of detail\n#define OCTAVES 2\n\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    float value = 0.;\n    float factor = 3.;\n    uv *= factor;\n    for (int i = 0; i < OCTAVES; i++)\n    {\n        uv += min(sin(uv*factor)/factor,cos(uv/factor)*factor).yx;\n        value = -min(value+cos(uv.x-uv.y)/factor,-value+sin((uv.x-uv.y))/factor);\n        uv /= factor;\n    }\n    \n    return value+1.5;\n}\n\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    float factor = 3.0;\n    return fbm(uv/factor)*factor;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*iTime);\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    #endif\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 1.;\n\n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/flBSDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[411, 488, 511, 560, 873], [947, 947, 985, 985, 1045], [1047, 1047, 1080, 1080, 1300], [1302, 1302, 1340, 1340, 1567], [1569, 1569, 1607, 1607, 1831], [1833, 1833, 1862, 1862, 1957], [1959, 1959, 1996, 1996, 2055], [2058, 2126, 2145, 2145, 2184], [2186, 2186, 2206, 2206, 2282], [2284, 2284, 2303, 2303, 2342], [2344, 2344, 2401, 2401, 2636], [2638, 2638, 2673, 2673, 3067], [3069, 3069, 3123, 3123, 3789], [3792, 3792, 3844, 3844, 4279], [4281, 4281, 4338, 4338, 5523]]}
{"id": "fljSDG", "name": "Pattern process #2", "author": "louis_C", "description": "The main square is an interactive part, you can move the form to change the pattern.\n\nAs part of this project :     https://www.cosamentale.fr/frages-flux-of-generative-researches/ \n\nFirst part : ttps://www.shadertoy.com/view/stjSzc", "tags": ["interactive"], "likes": 19, "viewed": 181, "date": "1628522197", "time_retrieved": "2024-06-20T20:46:59.121793", "image_code": "float map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\nvec2 map(vec2 value, vec2 min1, vec2 max1, vec2 min2, vec2 max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\nconst float threshold[16] = float[16](\n    1./16., 9./16., 3./16., 11./16., \n    13./16., 5./16., 15./16., 7./16., \n    4./16., 12./16., 2./16., 10./16.,\n    16./16., 8./16., 14./16., 6./16.);\n\nfloat dit2(int x, int y, float v)\n{\n    return step(threshold[4*y+x],v);\n}\nfloat smin(float a, float b, float k){ float h = clamp(0.5+0.5*(b-a)/k,0.,1.);\nreturn mix(b,a,h)-k*h*(1.-h);}\nfloat pi = 3.141592653589793;\nmat2 rot(float t){ float c = cos(t); float s = sin(t); return mat2(c,-s,s,c);}\nfloat bl(vec2 p ,vec2 b){vec2 q = abs(p)-b;\nreturn length(max(q,vec2(0.)))+min(0.,max(q.y,q.x));}\nfloat box(vec3 p ,vec3 b){vec3 q = abs(p)-b;\nreturn length(max(q,vec3(0.)))+min(0.,max(q.y,max(q.z,q.x)));}\nvec2 z1 ;\nvec3 map(vec3 p){\nfloat ft = 4.;\nfloat fo = (sin(p.y*pi*0.5)*0.5+0.5)*ft;\nint r = int(1.+floor(clamp(fo-1.,0.,ft))*2.);\nfloat tr = step(1.,fo);\nfloat td = 0.1*tr;\nvec2 pp = abs(map(iMouse.xy/iResolution.xy,vec2(0.29,0.5),vec2(1.,0.),vec2(0.),vec2(2.5,1.)));\nvec2 ppp = mix( vec2(0.),pp,step(pp.x,0.7)*step(pp.y,0.7));\np.xz += td;\nvec3 pr = p;\nfor(int i = 0 ; i <r ; i++){\npr.xz -= td;\npr.xz *= rot(pi*0.25);\npr = abs(pr);\n}\nfloat dr3 = min(pr.x,pr.z)/step(1.,fo);\nfor(int i = 0 ; i <r+1 ; i++){\np.xz -= td;\np.xz *= rot(pi*0.25);\np =abs(p);\n}\nvec3 re = vec3 (1.,0.,1.)*0.1;\nvec3 pg = p;\npg = mod(pg,re)-0.5*re;\nfloat d1 = length(pg.x);\nfloat d2 = length(pg.z);\nfloat d3 = min(d1,d2);\nfloat d4 = bl(p.xz-ppp,vec2(0.3)*0.2);\nz1 = pr.xz;\nreturn vec3(d4,dr3,d3);}\n\nfloat map2(vec3 p){\nvec2 ppp = abs(map(iMouse.xy/iResolution.xy,vec2(0.29,0.5),vec2(1.,0.),vec2(0.),vec2(2.5,1.)));\nvec2 pp2 = mix(vec2(0.),ppp,step(ppp.x,0.7)*step(ppp.y,0.7));\nvec3 pp = vec3(pp2.x,0.,pp2.y)*-1.;\nfloat fo = (sin(iTime*pi*0.5)*0.5+0.5)*4.;\nfloat t1 = step(1.,fo);\nfloat t2 = step(2.,fo);\nfloat t3 = step(3.,fo);\nfloat td = 0.1*t1;\np.xz += td;\nvec3 p1 = p; vec3 p2 = p; vec3 p3 = p; vec3 p4 = p;\n\np1.xz -= td;\np1.xz *= rot(pi*0.25*2.);\np1 = abs(p1);\nfor(int i = 0 ; i <2 ; i++){\np2.xz -= td;\np2.xz *= rot(pi*0.25);\np2.xz = abs(p2.xz);\n}\nfor(int i = 0 ; i <int(mix(2.,4.,t2)); i++){\np3.xz -= td;\np3.xz *= rot(pi*0.25);\np3.xz = abs(p3.xz);\n}\nfor(int i = 0 ; i <int(mix(2.,mix(4.,6.,t3),t2)) ; i++){\np4.xz -= td;\np4.xz *= rot(pi*0.25);\np4.xz = abs(p4.xz);\n}\nfloat fa = 0.8;\nfloat f1 = pow(1.,fa);float f2 = pow(2.,fa);float f3 =pow(3.,fa);\n\nfloat d1 = max(box(p1+pp,vec3(0.3)*vec3(0.2,pow(4.,fa),0.2)),-(length(p.y)-0.3*f3));\nfloat d2 = max(box(p2+pp,vec3(0.3)*vec3(0.2,pow(3.,fa),0.2)),-(length(p.y)-0.3*f2));\nfloat d3 = max(box(p3+pp,vec3(0.3)*vec3(0.2,f2,0.2)),-(length(p.y)-0.3*f1));\nfloat d4 = box(p4+pp,vec3(0.3)*vec3(0.2,f1,0.2));\nfloat ts = pow(clamp(sin(iTime*pi*0.5),0.,1.),2.)*0.2;\nfloat d5 = smin(smin(smin(d4,d3,ts),d2,ts),d1,ts)+ts*0.05;\nreturn d5;}\nvec3 nor (vec3 p){vec2 e = vec2(0.001,0.);return normalize(map2(p)-vec3(map2(p-e.xyy),map2(p-e.yxy),map2(p-e.yyx)));}\nvoid mainImage( out vec4 O, vec2 uu )\n{\n     vec2 uv = -1. + 2. *uu/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n      float li = step(0.1,uv.x);\n    vec2 up = uv*mix(1.,4.,li)+vec2(0.75-li*3.2,li*-1.58);\n    float bf = bl(up,vec2(0.75+li*0.7));\n    vec3 fo = map(vec3(up.x,iTime,up.y));\n    vec3 d1 = smoothstep(0.,(0.0015+li*0.005)*(1080./iResolution.y),fo);\n    float c1 = mix(mix(step(0.25,distance(fract(z1.y*30.),0.5)),(max(max(d1.x,0.),step(1.,fract(iTime*0.25)))*mix(0.,1.,d1.z)),d1.y)*step(bf,-0.004-li*0.01),max(d1.y,mix(0.8,1.,step(0.05*(1.-li),bf))),step(0.,bf));\n    vec2 ur = uv*2.78-vec2(1.71,-1.10);\n    float zr = bl(ur,vec2(1.));\n    vec3 r = normalize(vec3(ur,5.));\n    vec3 p = vec3(0.,1.6,-5.);\n    float tt = -0.3;float t2 = iTime*0.5;\n    r.zy *= rot(tt);\n    r.xz *= rot(t2);\n    p.xz *= rot(t2);\n    float dd  = 0.;\n    for(int  i = 0 ; i < 100 ; i++){\n    if(zr>0.){break;}\n    float d = map2(p);\n    if(d>7.){dd = 7.;break;}\n    if(d<0.001){break;}\n    p += r*d;\n    dd += d;\n    }\n    float s = smoothstep(6.,4.6,dd);\n    vec3 n = nor(p);\n    float dao = 0.035;float dao2 = 5.;\n    float ao = pow(clamp(map2(p+n*dao)/dao,0.0,1.),0.5);\n    float ao2 = clamp(map2(p+n*dao2)/dao2,0.,1.);\n    float aof = ao2*mix(0.3,1.,ao)*s;\n      vec2 co = uu/2.;\n     float tm = 4.;\n    int cox = int(mod(co.x,tm));\n    int coy = int(mod(co.y,tm));\n    float r2 = mix(dit2(cox,coy,aof),aof,0.4);\n    float bs = bl(uv+-vec2(1.65,0.),vec2(0.02,0.75));\n    float sa = max(step(0.,bs),step(bs,-0.0051)*step(sin(iTime*pi*0.5),floor(uv.y*2.)/2.));\n    O = vec4 (c1*r2*vec3(0.905882,0.,0.22745)*sa,0.);\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fljSDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 72, 72, 138], [139, 139, 205, 205, 271], [466, 466, 501, 501, 540], [541, 541, 579, 579, 650], [681, 681, 699, 699, 759], [760, 760, 785, 785, 857], [858, 858, 884, 884, 965], [976, 976, 993, 993, 1734], [1736, 1736, 1755, 1755, 3012], [3013, 3013, 3031, 3031, 3130], [3131, 3131, 3170, 3170, 4756]]}
{"id": "fljSWt", "name": "stars live", "author": "SORJ", "description": "idk", "tags": ["star"], "likes": 1, "viewed": 35, "date": "1628864890", "time_retrieved": "2024-06-20T20:46:59.121793", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    int t = int(iTime) % 100;\n    float tt = float(t) / 100.0;\n    float r = 0.07;\n    vec3 col;\n    float umn = 1.0;\n    float del = 0.0;\n    t = int(iTime) % 6;\n    float rast = sqrt((0.5 - uv.x) * (0.5 - uv.x) + (0.5 - uv.y) * (0.5 - uv.y));\n    if(t < 3){\n        umn = float(int(iTime * 100.0) % 301)/ 300.0;\n        r = 0.07 * umn;\n        \n    }\n    else{\n        del = float(int(iTime * 100.0) % 301)/ 300.0;\n        \n    }\n    col = vec3((1.0 / rast / 10.0* umn) - del, (1.0 / rast / 10.0 * umn) / 2.0 - del, 0.0);\n    if(rast < r){\n        col = vec3(1.0 - del, 0.8 - del, 0.0);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fljSWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 107, 799]]}
{"id": "fljXDt", "name": "Dziabong", "author": "Langwedocjusz", "description": "Description", "tags": ["2d"], "likes": 0, "viewed": 35, "date": "1628870777", "time_retrieved": "2024-06-20T20:46:59.630913", "image_code": "//Distance to a sphere:\nfloat sdfSphere(vec2 position, float radius){\n    return length(position) - radius;\n}\n\n//Distance to a square with rounded corners:\nfloat sdfSquare(vec2 position, float side_lenght, float roundness)\n{\n    vec2 d = abs(position) - vec2(side_lenght - roundness);\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - roundness;\n}\n\n//Simple coordinate transofrm to rotate existing sdf:\nfloat sdfRotated(vec2 position, float theta){\n    mat2 rotation_matrix = mat2(cos(theta), -sin(theta),\n                                sin(theta),  cos(theta));\n                                \n    vec2 q = rotation_matrix * position;\n    \n    //Return desired sdf passing in q as position:\n    return sdfSquare(q, 0.5, 0.1);\n}\n\n//Signed angle between two vectors:\nfloat signedAngle(vec2 v1, vec2 v2){\n    vec3 w1 = vec3(v1, 0.0), w2 = vec3(v2, 0.0);\n    \n    float angle = acos(dot(normalize(w1), normalize(w2)));\n    vec3 normal = cross(w1, w2);\n    vec3 up = vec3(0.0, 0.0, 1.0);\n    if (dot(up, normal) < 0.0) {\n      angle = -angle;\n    }\n    return angle;\n}\n\n//Check if a point is between two vectors:\nbool isBetweenVectors(vec2 point, vec2 v1, vec2 v2) {\n    float range = signedAngle(v1, v2);\n    if (range < 0.0) {\n        range += 360.0;\n    }\n    \n    float a1 = signedAngle(v1, point);\n    if (a1 < 0.0){\n        a1 += 360.0;\n    }\n    \n    float a2 = signedAngle(point, v2);\n    if (a2 < 0.0){\n        a2 += 360.0;\n    }\n    \n    if (a1<range && a2<range){\n        return true;\n    }\n\n    return false;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    //Normalize coordinates to (-1;1):\n    uv = 2.0 * uv - 1.0;\n    //Aspect ratio correction:\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Background color:\n    vec3 col = vec3(0.0);\n    \n    //Composite in the box:\n    if (sdfRotated(uv, -4.0*iTime) <= 0.0 ) {\n        col = vec3(0.21, 0.50, 0.74);\n    }\n    \n    \n    //Composite in the swirling bullshit:\n    \n    float angle1 = -4.0*iTime, angle2 = -8.0*iTime;\n    \n    //Standard polar parametrization:\n    vec2 v1 = vec2(cos(angle1), sin(angle1));\n    vec2 v2 = vec2(cos(angle2), sin(angle2));\n    \n    if (!isBetweenVectors(uv, v1, v2)) {\n        if (sdfSphere(uv, 0.49) <= 0.0 && sdfSphere(uv, 0.44) >= 0.0){\n            col = vec3(0.88, 0.88, 1.0);\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fljXDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 24, 69, 69, 109], [111, 156, 224, 224, 353], [355, 409, 454, 454, 736], [738, 774, 810, 810, 1072], [1074, 1117, 1170, 1170, 1526], [1529, 1529, 1586, 1586, 2419]]}
{"id": "fljXW3", "name": "rainbow loading", "author": "lasoy", "description": "rainbow loading", "tags": ["rainbow"], "likes": 2, "viewed": 157, "date": "1628772648", "time_retrieved": "2024-06-20T20:46:59.630913", "image_code": "#define PI 3.1415926\nvec3 rainbowColor(float t) {\n    return .5 + .5 * cos(6.283 * (t + vec3(0., .33, .67)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float pix = 2./iResolution.y;\n    float len = length(uv);\n    float angle = atan(uv.x, uv.y)/PI*.5 + iTime*.4;\n\n    vec3 col = rainbowColor(angle);\n    col *= smoothstep(pix, -pix, abs(len-.55) -.05 );\n    col *= smoothstep(0., .9, fract(angle));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fljXW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[21, 21, 49, 49, 111], [113, 113, 170, 220, 594]]}
{"id": "flSSDy", "name": "Tunnel - distance", "author": "iq", "description": "Distance to a tunnel shape", "tags": ["2d", "distancefield", "tunnel", "sdf", "distance"], "likes": 19, "viewed": 495, "date": "1628471259", "time_retrieved": "2024-06-20T20:47:00.152201", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance to a 2D tunnel shape\n\n// List of some other 2D distances:\n//    https://www.shadertoy.com/playlist/MXdSRf\n// and\n//    www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\nfloat dot2( vec2 v ) { return dot(v,v); }\n\nfloat sdTunnel( in vec2 p, in vec2 wh )\n{\n    p.x = abs(p.x); p.y = -p.y;\n    vec2 q = p - wh;\n\n    float d1 = dot2(vec2(max(q.x,0.0),q.y));\n    q.x = (p.y>0.0) ? q.x : length(p)-wh.x;\n    float d2 = dot2(vec2(q.x,max(q.y,0.0)));\n    float d = sqrt( min(d1,d2) );\n    \n    return (max(q.x,q.y)<0.0) ? -d : d;\n}\n\n// alternative formulation\nfloat sdTunnel2( in vec2 p, in vec2 wh )\n{\n    vec2 q = abs(p);\n    q.x -= wh.x;\n\n    if( p.y>=0.0 )\n    {\n    q.x = max(q.x,0.0);\n    q.y += wh.y;\n    return -min( wh.x-length(p), length(q) );\n    }\n    else\n    {\n    q.y -= wh.y;\n    float f = max(q.x,q.y);\n    return (f<0.0) ? f : length(max(q,0.0));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    vec2 wh = 0.4 + 0.4*sin(iTime*vec2(1.1,1.2)+vec2(3.0,1.0));\n\n\tfloat d = sdTunnel( p, wh );\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdTunnel( m, wh );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/flSSDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1119, 1285, 1307, 1307, 1326], [1328, 1328, 1369, 1369, 1638], [1640, 1667, 1709, 1709, 1979], [1981, 1981, 2038, 2038, 2712]]}
{"id": "flSSzd", "name": "Simple Truchet Weaving Pattern", "author": "sylvain69780", "description": "Randomly watching videos on Youtube, this one was about washing a carpet ! \nNo idea why this has been suggested to me, I'am not fan of washing.\nThe pattern of the carpet interested me !\n[url=https://youtu.be/SCP20vK0JKc]LUBUSKIE CENTRUM CZYSTOŚCI[/url]", "tags": ["truchet", "weaving"], "likes": 8, "viewed": 68, "date": "1628333511", "time_retrieved": "2024-06-20T20:47:00.540249", "image_code": "/*\n\nA very simple truchet pattern.\n\nReferences\n\n    Shane has many many many awesome Truchet shaders.\n\n    Animated Two-Tiled Truchet  - Shane\n    https://www.shadertoy.com/view/tsSfWK\n    \n    Fabrice already made ultra short versions of this \"weaving\" pattern\n    https://www.shadertoy.com/view/llfyDn\n    https://www.shadertoy.com/view/4lsyWn (I like this one, 185 chars !)\n\n    iResolution, iMouse, iDate, etc - FabriceNeyret2\n    https://www.shadertoy.com/view/llySRh\n\n    Ring Twister - Flyguy - I may use this as a variation.\n    https://www.shadertoy.com/view/Xt23z3 \n    \n    more: https://www.shadertoy.com/results?query=weaving\n\n*/\n\n#define T iTime*.1\n#define AA(d,r,pix) smoothstep( .75, -.75, (d)/(pix)-(r))   // antialiased draw. r >= 1.\n\nvec4 blendOver (vec4 A, vec4 B) {\n        return (A + (1.-A.a)*B); \n}\n\nmat2 rot(float a) {\n    float s = sin(a),\n          c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvec4 tape(vec2 uv, float pix, float side) {\n    float d = abs(uv.x);\n    vec4 col = vec4(0);\n    float spec = .5+.5*cos((uv.y+side)*3.14159);\n    spec*=spec;\n    vec3 c1 = vec3(0.25,0.25,1.5);\n    c1 *= 1.0 - max(0.0,cos((uv.x+uv.y)*3.14159*14.0)*.5); \n    vec3 c2 = vec3(1.2,1.2,0.7);\n    c2 *= 1.0 - max(0.0,cos((uv.x-uv.y)*3.14159*14.0)*.5); \n    col.a = AA(d-.3,1.0,pix);    // r=1 pixel black border for contrast\n    col.rgb = mix(col.rgb,c1,AA(d-.3,0.0,pix));    \n    col.rgb = mix(col.rgb,c2,AA(d-.15,0.0,pix))*spec;        \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    float zoom = 3.0 + sin(T);\n    \n    uv*=zoom;\n    uv*=rot(T+1.0);\n    uv += vec2(T,T*.1)*.2;\n    float pix = 2.0*zoom/iResolution.y;\n    vec2 guv = fract(uv)-.5;\n    vec2 gid = floor(uv);\n    vec4 col = vec4(vec3(0.025),1.0); \n    col.rgb *= 1.0 - max(0.0,cos((guv.x-guv.y)*3.14159*14.0)*.25);\n    if ( mod(gid.x + gid.y,2.0 ) == 1.0 ) guv = guv.yx;\n    col = blendOver(tape(guv,pix,1.0),col);\n    col = blendOver(tape(guv.yx,pix,0.0),col);\n    fragColor = vec4(sqrt(col.rgb),1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/flSSzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 753, 786, 786, 822], [824, 824, 843, 843, 916], [918, 918, 961, 961, 1467], [1469, 1469, 1526, 1526, 2074]]}
{"id": "flSXWt", "name": "彩虹圈", "author": "tangyuan", "description": "彩虹圆环", "tags": ["2d"], "likes": 3, "viewed": 62, "date": "1628814787", "time_retrieved": "2024-06-20T20:47:00.540249", "image_code": "#define PI 3.14159256\n\n//彩虹插色函数\nvec3 rainbowColor(float t) {\n    return .5 + .5 * cos(6.283 * (t + vec3(0., .33, .67)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 坐标转换至屏幕中心变为-1至1\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    //0 - 0.5\n    float len = length(uv);\n    //相对中心的角度\n    float angle = atan(uv.y, uv.x);\n    //n 2PI\n    float f = angle / PI / 2. - iTime;\n    f = fract(f);\n    // 颜色\n    vec3 circleColor = rainbowColor(f);\n    \n    //画圆，并且彩虹色根据f再和黑色混色\n    circleColor = len < 0.4 || len > 0.5 ? vec3(0.): mix(circleColor, vec3(0.), 1. - f);\n\n    // Output to screen\n    fragColor = vec4(circleColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/flSXWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[23, 44, 72, 72, 134], [137, 137, 194, 241, 751]]}
{"id": "flXSRX", "name": "space threads", "author": "slackmage", "description": "space threads", "tags": ["space"], "likes": 1, "viewed": 44, "date": "1629766864", "time_retrieved": "2024-06-20T20:47:01.855524", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n//#define ANALYSE_RM\n\n#ifdef ANALYSE_RM\n/////////////////////////\n// GLSL Number Printing - @P_Malin (CCO 1.0)=> https://www.shadertoy.com/view/4sBSWW\nfloat DigitBin(const in int x){\n    if(x==0) return 480599.0; if(x==1) return 139810.0; if(x==2) return 476951.0; if(x==3) return 476999.0;\tif(x==4) return 350020.0; \n    if(x==5) return 464711.0; if(x==6) return 464727.0; if(x==7) return 476228.0; if(x==8) return 481111.0; if(x==9) return 481095.0; \n    return 0.0;}\nfloat PrintValue(vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces){\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n            if((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;} \n        else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;} \n            else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));} } }\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));}\nvec3 WriteValueToScreenAtPos(vec2 fragCoord, float vValue, vec2 vPixelCoord, vec3 vColour, vec2 vFontSize, float vDigits, float vDecimalPlaces, vec3 vColor){\n    float num = PrintValue(fragCoord, vPixelCoord, vFontSize, vValue, vDigits, vDecimalPlaces);\n    return mix( vColour, vColor, num);}\n\n/////////////////////////////////////////////////////////////////\n#endif\n\nvec2 mo = vec2(0);\n\nfloat pn( in vec3 x ) // iq noise\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture(iChannel0, (uv+ 0.5)/256.0, -100.0 ).yx;\n\treturn -55.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\nvec2 path(float t)\n{\n\treturn vec2(cos(t*0.2), sin(t*0.2)) * 2.;\n}\n\nconst mat3 mx = mat3(1,0,0,0,7,0,0,0,7);\nconst mat3 my = mat3(7,0,0,0,1,0,0,0,7);\nconst mat3 mz = mat3(7,0,0,0,7,0,0,0,1);\n\n// base on shane tech in shader : One Tweet Cellular Pattern\nfloat func(vec3 p)\n{\n    p = fract(p/68.6) - .5;\n    return min(min(abs(p.x), abs(p.y)), abs(p.z)) + 0.1;\n}\n\nvec3 effect(vec3 p)\n{\n\tp *= mz * mx * my * sin(p.zxy); // sin(p.zxy) is based on iq tech from shader (Sculpture III)\n\treturn vec3(min(min(func(p*mx), func(p*my)), func(p*mz))/1.6);\n}\n//\n\nvec4 displacement(vec3 p)\n{\n    vec3 col = 1.-effect(p*0.8);\n   \tcol = clamp(col, -.5, 1.);\n    float dist = dot(col,vec3(0.023));\n\tcol = step(col, vec3(0.82));// black line on shape\n    return vec4(dist,col);\n}\n\nvec4 map(vec3 p)\n{\n\tp.xy -= path(p.z);\n    vec4 disp = displacement(sin(p.zxy*2.)*0.8);\n\tp += sin(p.zxy*.5)*4.5;\n    float l = length(p.xy) - 1.4;\n    return vec4(max(-l + 0.09, l) - disp.x, disp.yzw);\n}\n\nvec3 nor( in vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nvec4 light(vec3 ro, vec3 rd, float d, vec3 lightpos, vec3 lc)\n{\n\tvec3 p = ro + rd * d;\n\t\n\t// original normale\n\tvec3 n = nor(p, 0.1);\n\t\n\tvec3 lightdir = lightpos - p;\n\tfloat lightlen = length(lightpos - p);\n\tlightdir /= lightlen;\n    \n\tfloat amb = 0.6;\n\tfloat diff = clamp( dot( n, lightdir ), 0.0, 1.0 );\n\t    \n\tvec3 brdf = vec3(0);\n\tbrdf += amb * vec3(0.2,0.5,0.3); // color mat\n\tbrdf += diff * 0.6;\n\t\n\tbrdf = mix(brdf, map(p).yzw, 0.5);// merge light and black line pattern\n\t\t\n\treturn vec4(brdf, lightlen);\n}\n\nvec3 stars(vec2 uv, vec3 rd, float d, vec2 s, vec2 g)\n{\n\tuv *= 800. * s.x/s.y;\n\tfloat k = fract( cos(uv.y * 0.0001 + uv.x) * 90000.);\n\tfloat var = sin(pn(d*0.6+rd*182.14))*0.5+0.5;// thank to klems for the variation in my shader subluminic\n\tvec3 col = vec3(mix(0., 1., var*pow(k, 200.)));// come from CBS Shader \"Simplicity\" : https://www.shadertoy.com/view/MslGWN\n\treturn col;\n}\n\n////////MAIN///////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 s = iResolution.xy;\n    vec2 g = fragCoord;\n    \n#ifdef ANALYSE_RM\n    vec2 uvn = (fragCoord*2.-s)/s.y*vec2(1.,5.);\n\tif (iMouse.z > 0.)\n\t\tg = iMouse.xy;\n#else\n\tif (iMouse.z > 0.)\n\t\tmo = (iMouse.xy*2. - s) / s.y*10.;\n#endif\n    \n\tfloat time = iTime*0.4;\n    float cam_a = time; // angle z\n    \n    float cam_e = 4.2; // elevation\n    float cam_d = 4.; // distance to origin axis\n    \n    float maxd = 50.; // ray marching distance max\n    \n    vec2 uv = (g*2.-s)/s.y;\n    \n    vec3 col = vec3(0.);\n\n    vec3 ro = vec3(path(time)+mo,time);\n  \tvec3 cv = vec3(path(time+0.1)+mo,time+0.1);\n    \n\tvec3 cu=vec3(0,1,0);\n  \tvec3 rov = normalize(cv-ro);\n    vec3 u = normalize(cross(cu,rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    \n    vec3 curve0 = vec3(0);\n\tvec3 curve1 = vec3(0);\n    vec3 curve2 = vec3(0);\n    float outStep = 0.;\n    \n    float ao = 0.; // ao low cost :)\n    \n    float st = 0.;\n    float d = 0.;\n    for(int i=0;i<250;i++)\n    {      \n        \n#ifdef ANALYSE_RM\n        if (iMouse.z > 0. && abs(fragCoord.x - float(i)*4.) < 1.)\n\t\t{\n\t\t\tcurve0 += 0.048 * vec3(1,1,0) / length(uvn.y - st * 0.6);\n\t\t\tcurve1 += 0.048 * vec3(0.48,0,0.48) / length(uvn.y - 0.025*log(d*d/st/1e5));\n            if(d>maxd)\n            \tcurve2 += vec3(0,0,1) - smoothstep( 1., 2., uvn.x );\n            else if(st < 0.025*log(d*d/st/1e5))\n            \tcurve2 += vec3(1,0,1) - smoothstep( 1., 2., uvn.x );\n        }\n#endif\n        \n        if (st<0.025*log(d*d/st/1e5)||d>maxd) break;// special break condition for low thickness object\n        st = map(ro+rd*d).x;\n        d += st * 0.6; // the 0.6 is selected according to the 1e5 and the 0.025 of the break condition for good result\n        ao++;\n        \n#ifdef ANALYSE_RM\n    \toutStep++;\n#endif\n        \n    }\n\t\n#ifdef ANALYSE_RM\n    if (iMouse.z > 0.)\n    {\t\n        fragColor = vec4(curve0 + curve1 + curve2,1);\n    \tfragColor.rgb = WriteValueToScreenAtPos(fragCoord, outStep, vec2(20,s.y-20.), \n                                                fragColor.rgb, vec2(12.0, 15.0), 1., 0., vec3(0.9));\n    }\n\telse\n    {\n#endif\n        if (d < maxd)\n        {\n            vec4 li = light(ro, rd, d, ro, vec3(0));// point light on the cam\n            col = li.xyz/(li.w*0.2);// cheap light attenuation\n            \n           \tcol = mix(vec3(1.-ao/100.), col, 0.5);// low cost ao :)\n        \tfragColor.rgb = mix( col, vec3(0), 1.0-exp( -0.003*d*d ) );\n\t\t}\n        else\n        {\n          \tfragColor.rgb = stars(uv, rd, d, s, fragCoord);// stars bg\n        }\n        \n        \n        // vignette\n        vec2 q = fragCoord/s;\n        fragColor.rgb *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 ); // iq vignette\n        \n#ifdef ANALYSE_RM\n    }\n#endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/flXSRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[214, 2238, 2273, 2273, 2491], [2493, 2493, 2513, 2513, 2558], [2684, 2745, 2765, 2765, 2852], [2854, 2854, 2875, 2875, 3036], [3037, 3041, 3068, 3068, 3252], [3254, 3254, 3272, 3272, 3457], [3459, 3459, 3496, 3496, 3714], [3717, 3717, 3780, 3780, 4227], [4229, 4229, 4284, 4284, 4608], [4610, 4654, 4711, 4711, 7456]]}
{"id": "fs33DM", "name": "Geometric Factory", "author": "Flopine", "description": "Inspiration is still heeeeeeere )0) ", "tags": ["raymarching", "cubes", "animation", "isometric", "pipes"], "likes": 12, "viewed": 206, "date": "1629915410", "time_retrieved": "2024-06-20T20:47:02.515939", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings and FabriceNeyret for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU (2.*PI)\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define crep(p,c,l) p-=c*clamp(round(p/c),-l,l)\n#define cyl(p,r,h) max(length(p.xy)-r,abs(p.z)-h)\n\n#define frt(sp,off) fract((iTime+off)*sp)\n#define flt(sp,off) floor((iTime+off)*sp)\n\nstruct obj{\n    float d;\n    vec3 sha;\n    vec3 li;\n};\n\nobj minobj (obj a, obj b)\n{if(a.d<b.d)return a; else return b;}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p,p.yzx);\n    return min(p.x,min(p.y,p.z))-d;\n}\n\nobj grid (vec3 p)\n{\n    crep(p.xz,8.,2.);\n    float per=1.;\n    crep(p,per,2.);\n    float d = max(-sc(p,per*0.34),box(p,vec3(per*0.4)));\n    obj scene = obj(d,vec3(0.),vec3(1.));\n    \n    return scene;  \n}\n\nfloat pipe (vec3 p, float pid)\n{\n    float d = cyl(p,0.15,20.);\n    \n    float per = 1.5, id = round(p.z/per), speed=1., off=id*0.1,\n    anim=(TAU/4.)*(flt(speed,off)+pow(frt(speed,off),6.));\n    crep(p.z,per,6.);\n    p.xy *= (mod(pid,2.)<0.5)?rot(anim):rot(-anim);\n    d = min(d,cyl(p,0.2, 0.15));\n    d = min(d, cyl(p.xzy,0.065,0.4));\n    d = min(d, cyl(p.yzx,0.065,0.4));\n    \n    return d; \n}\n\nobj SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    vec3 pp = p;\n    obj scene = grid(p);\n    \n    p.y -= 1.;\n    float p1id = round(p.x/2.);\n    crep(p.x, 2., 5.);\n    scene = minobj(scene,obj(pipe(p,p1id),vec3(0.2,0.,0.),vec3(1.,0.5,0.9)));\n    \n    p=pp;\n    p.y += 1.;\n    float p2id = round(p.z/2.);\n    crep(p.z,2.,5.);\n    scene = minobj(scene,obj(pipe(p.yzx,p2id),vec3(0.,0.,0.1),vec3(0.,1.,0.5)));\n    \n    return scene;\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(SDF(p).d-vec3(SDF(p-eps.xyy).d,SDF(p-eps.yxy).d,SDF(p-eps.yyx).d));\n}\n\nfloat AO (float eps, vec3 p, vec3 n)\n{return clamp(SDF(p+eps*n).d/eps,0.,1.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro=vec3(uv*5.,-30.),rd=vec3(0.,0.,1.),p=ro,\n    col=vec3(0.),l=normalize(vec3(2.,3.,-3.));\n    \n    bool hit=false; obj O;\n    for(float i=0.;i<64.;i++)\n    {\n        O = SDF(p);\n        if (O.d<0.001)\n        {hit=true; break;}\n        p += O.d*rd;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = max(dot(n,l),0.);\n        float ao = AO(0.1,p,n)+AO(0.3,p,n)+AO(0.5,p,n);\n        col = mix(O.sha,O.li,light)*ao/3.;\n    }\n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fs33DM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[208, 693, 720, 720, 756], [758, 758, 786, 786, 871], [873, 873, 901, 901, 977], [979, 979, 998, 998, 1184], [1186, 1186, 1218, 1218, 1582], [1584, 1584, 1602, 1602, 2047], [2049, 2049, 2072, 2072, 2194], [2196, 2196, 2234, 2234, 2274], [2276, 2276, 2333, 2333, 2896]]}
{"id": "fs33R4", "name": "xor pattern animated", "author": "hikiko", "description": "based on a xor pattern", "tags": ["xor"], "likes": 2, "viewed": 148, "date": "1629200859", "time_retrieved": "2024-06-20T20:47:02.515939", "image_code": "float M_PI = 3.14;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int xor = (int(fragCoord.x) ^ int(fragCoord.y));\n    \n    float r = float((xor * 2) & 0xff) / 255.0 * 0.3;\n    float g = float((xor * 4) & 0xff) / 255.0 * 0.7;\n\tfloat b = float((xor * 8) & 0xff) / 255.0 * 0.6;\n    \n    vec3 col = vec3(b * atan(r * cos(iTime + M_PI / 3.0), b * sin(iTime - M_PI / 2.0) + 0.0001), \n    g * atan(r * cos(iTime - M_PI / 4.0), g * sin(iTime + M_PI * 4.0 / 3.0) + 0.0004),\n    b * atan(b * sin(iTime + M_PI / 2.0), g * cos(iTime + M_PI / 2.0)) + 0.0004);\n    \n    fragColor = vec4(mix(col.x * atan(iTime * 0.8 + M_PI / 8.0, col.y), 1.0, cos(g * b - M_PI / r / 2.0)), col.y, col.z, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fs33R4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[20, 20, 77, 77, 697]]}
{"id": "fs3GRn", "name": "Moon Healing Escalation", "author": "kithy", "description": "background inspired from the animation, \"SailorMoon\".\n\nthanks for BigWing's tutorial\nhttps://www.shadertoy.com/view/tlyGW3", "tags": ["gradient", "particle"], "likes": 7, "viewed": 93, "date": "1628936003", "time_retrieved": "2024-06-20T20:47:02.515939", "image_code": "#define PI 3.1415\n#define NUM_LAYERS 4.0\n\nvec4 firstColor = vec4(0.2,1.0,0.4,1.0);//green\nvec4 endColor = vec4(0.0,0.3,1.0,1.0);//blue\n\n//rotation matrix\nmat2 rot(float a){\n\tfloat s=sin(a);\n\tfloat c=cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\n//gradient\nvec4 gradient(vec2 uv){\n    //uv*=rot(iTime*0.1);\n\tvec4 col = mix(mix(firstColor*0.9, endColor*1.2, abs(uv.x)),mix(firstColor*0.9, endColor*1.2, abs(uv.x)),uv.x);\t\n\treturn col;\n}\n\n//draw 1 circle\nfloat Circle(vec2 uv){\n\tfloat d=length(uv);\n\tfloat m=0.05/d;\n\tm*=smoothstep(1.0,0.2,d);\n\treturn m;\n}\n\n//draw 1 star\nfloat Star(vec2 uv,float flare){\n\n\t//center of star\n\tfloat d=length(uv);\n\tfloat m=0.05/d;\n\n\t//flare\n\tfloat rays=max(0.0,1.0-abs(uv.x*uv.y*1000.0));\n\tm+=rays*flare;\n\tuv*=rot(PI/4.0);\n\trays=max(0.0,1.0-abs(uv.x*uv.y*1000.0));\n\tm+=rays*flare*0.3;\n\tm*=smoothstep(1.0,0.2,d);\n\treturn m;\n}\n\n//make random value\nfloat Hash21(vec2 p){\n\tp=fract(p*vec2(123.34,456.21));\n\tp+=dot(p,p+45.32);\n\treturn fract(p.x*p.y);\n}\n\n//repetition circles \nvec3 CircleLayer(vec2 uv){\n\tvec2 gv=fract(uv)-0.5;\n\tvec2 id=floor(uv);\n\n\tvec3 col=vec3(0.0);\n\n\tfor(int y=-1;y<=1;y++){\n\t\tfor(int x=-1;x<=1;x++){\n\t\t\tvec2 offset=vec2(x,y);\n\t\t\tfloat n=Hash21(id+offset);\n\t\t\tfloat size=fract(n*345.32);\n\t\t\tfloat circle=Circle(gv-offset-vec2(n,fract(n*34.0))+0.5);\n\t\t\tcol+=circle*n*1.5;\n\t\t}\n\t}\n\treturn col;\n}\n\n//repetition stars\nvec3 StarLayer(vec2 uv){\n\tvec3 col=vec3(0.0);\n\t\n\tvec2 gv=fract(uv)-0.5;\n\tvec2 id=floor(uv);\n\t\n\tfor(int y=-1;y<=1;y++){\n\t\tfor(int x=-1;x<=1;x++){\n\t\t\tvec2 offset=vec2(x,y);\n\t\t\tfloat n=Hash21(id+offset);\n\t\t\tfloat size=fract(n*345.32);\n\t\t\tfloat star=Star(gv-offset-vec2(n,fract(n*34.0))+0.5,smoothstep(0.5,0.9,size));\n\t\t\t\n\t\t\t//blink\n\t\t\tstar*=sin(iTime*3.0+n*PI*2.0)*0.5+1.0;\n\t\t\tcol+=star*size;\n\t\t}\n\t}\n\treturn col;\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(fragCoord-iResolution.xy*0.5)/iResolution.y;\n\tuv*=2.0;\n\tuv.y-=iTime;\n\t\n\tvec4 background=gradient(uv);\n    vec4 circle=vec4(CircleLayer(uv),1.0);\n\n\n\tvec3 col=vec3(0.0);\n\n\tfor(float i=0.0;i<1.0;i+=1.0/NUM_LAYERS){\n\t\tfloat depth=fract(i);\n\t\tfloat scale=mix(20.0,0.5,depth);\n\t\tfloat fade=depth*smoothstep(1.0,0.9,depth);\n\t\tcol=StarLayer(uv*scale+i*453.2*fade);\t\n\t}\n\t\n\tfragColor=vec4(col,1.0)+background+circle;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fs3GRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[136, 154, 172, 172, 232], [234, 245, 268, 294, 423], [425, 441, 463, 463, 541], [543, 557, 589, 608, 840], [842, 862, 883, 883, 962], [964, 986, 1012, 1012, 1322], [1324, 1343, 1367, 1367, 1754], [1757, 1757, 1810, 1810, 2229]]}
{"id": "fsc3Rr", "name": "Random peak line generator", "author": "xintrea", "description": "Random line generator by time", "tags": ["sin", "random", "generator"], "likes": 0, "viewed": 26, "date": "1628958283", "time_retrieved": "2024-06-20T20:47:02.515939", "image_code": "const float e=2.7182818284;\nconst float pi=3.1415926535;\n\n// Sinus based random\nfloat sinRand(float x)\n{\n    float y1=( sin(x+e) + cos(x*e) + sin(x/e) )/6.0+0.5;\n    float y2=sqrt(abs(sin(x*e))); // (mod( sin(mod(x, 11.0)) * 7.0, 7.0))/7.0;\n    float y3=sin(x*7.0)/2.0+0.5;\n    \n    return sqrt(y1*y2*y3);\n}\n\n\nvec4 sinRandColor(float randValue)\n{\n    bool isRedNote  =randValue>0.08 && randValue<0.16 ? true:false;\n    bool isGreenNote=randValue>0.24 && randValue<0.48 ? true:false;\n    bool isBlueNote =randValue>0.48 && randValue<0.96 ? true:false;\n\n    if(isRedNote)\n    {\n        return vec4( 1.0, 0.0, 0.0, 1.0 );\n    }\n    if(isGreenNote)\n    {\n        return vec4( 0.0, 1.0, 0.0, 1.0 );\n    }\n    if(isBlueNote)\n    {\n        return vec4( 0.2, 0.8, 1.0, 1.0 );\n    }\n\n    return vec4( vec3(0.0), 0.0 );\n}\n\n\nvec4 showLines(vec2 uvPixelPosition)\n{\n    const float timeStep=0.1;\n    const float timeWidth=0.002;\n\n    float timeSpeed=0.1;\n    float geometricSpeed=2.5;\n\n    vec4 color=vec4( 0.0 );\n    \n    // First color\n    // 1.0-uv.x for move from left to right\n    float seed=iTime*timeSpeed + (1.0-uvPixelPosition.x)*geometricSpeed;\n    float randValue=sinRand( seed );\n\n    // Time graduate filter\n    float modTime=mod(seed, timeStep);\n    if( !(modTime>=0.0 && modTime<timeWidth))\n    {\n        randValue=0.0;\n    }\n\n    vec4 color1=sinRandColor(randValue);\n\n    // Second color for nearest point\n    float seed2=seed+timeWidth;\n    float randValue2=sinRand( seed2 );\n    vec4 color2=sinRandColor(randValue2);\n\n    // Result color\n    if(color1==color2)\n    {\n        color=color1;\n    }\n\n    // Sin vertical moving\n    if(color!=vec4( 0.0 ))\n    {\n        float phaseSeed=seed*1.5;\n        float apmSeed=seed*1.7;\n        float timeSeed=seed*1.9;\n        \n        float phase=sinRand(phaseSeed)*2.0*pi;\n        \n        float amp=sinRand(phaseSeed);\n        if(amp<0.1)\n        {\n            amp=1.0-amp;\n        }\n        \n        \n        // float time=iTime*(1.0-sinRand(timeSeed/100.0));\n        float time=iTime;\n        \n        float y=(sin(phase+time)*amp)/2.0 + 0.5;\n\n        if(y>0.0 && uvPixelPosition.y>y && uvPixelPosition.y<y+0.01)\n        {\n            return color;\n        }\n    \n    }\n    \n    return vec4( 0.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 color = showLines( uv );\n\n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsc3Rr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[58, 80, 104, 104, 307], [310, 310, 346, 346, 811], [814, 814, 852, 852, 2246], [2249, 2249, 2306, 2356, 2485]]}
{"id": "fsc3W4", "name": "VACUOLE :: fast perlin noise", "author": "ENDESGA", "description": "A clean and simple Perlin Noise using my hept32", "tags": ["noise", "perlinnoise", "gradient", "random", "hash", "hept32"], "likes": 2, "viewed": 211, "date": "1629766090", "time_retrieved": "2024-06-20T20:47:03.079769", "image_code": "#define T iTime\n#define R iResolution.yy\n\n// hept32 bitmagic hash\n// https://www.shadertoy.com/view/flXXWs\n\nuint _HEPT32_X = 0u, _HEPT32_Y = 0u, _HEPT32_Z = 0u;\nuint hept32(uint x, uint y, uint z) {\n    x = (x * _HEPT32_X) - (~x * 0x77777777u) - ~(x * _HEPT32_Y);\n\ty = (y * _HEPT32_Y) - (~y * 0x77777777u) - ~(y * _HEPT32_Z);\n\tz = (z * _HEPT32_Z) - (~z * 0x77777777u) - ~(z * _HEPT32_X);\n\tz = ~(~(~x * y * z) * ~(x * ~y * z) * ~(x * y * ~z));\n    return z ^ (z >> 16);\n}\n\nvoid hept32_seed(uint seed) {\n\t_HEPT32_X = (hept32(seed,0x77777777u,0x77777777u) * 0x77777777u) - 0x77777777u;\n\t_HEPT32_Y = (hept32(0x77777777u,seed,0x77777777u) * 0x77777777u) - 0x77777777u;\n\t_HEPT32_Z = (hept32(0x77777777u,0x77777777u,seed) * 0x77777777u) - 0x77777777u;\n}\n\n// Based off TheTurk's Fast Improved 3D Perlin Noise\n// https://www.shadertoy.com/view/slB3z3\n\nuint hash(uvec3 h) {\n    return hept32(h.x,h.y,h.z);\n}\n\nvec3 grad_dir(uint h) {\n    switch (int(h) & 15) {\n        case 0:\n        case 12:\n            return vec3(1, 1, 0);\n        case 1:\n        case 13:\n            return vec3(-1, 1, 0);\n        case 2:\n        case 14:\n            return vec3(1, -1, 0);\n        case 3:\n        case 15:\n            return vec3(-1, -1, 0);\n        case 4:\n            return vec3(1, 0, 1);\n        case 5:\n            return vec3(-1, 0, 1);\n        case 6:\n            return vec3(1, 0, -1);\n        case 7:\n            return vec3(-1, 0, -1);\n        case 8:\n            return vec3(0, 1, 1);\n        case 9:\n            return vec3(0, -1, 1);\n        case 10:\n            return vec3(0, 1, -1);\n        case 11:\n            return vec3(0, -1, -1);\n    }\n}\n\nfloat interp(float v1, float v2, float v3, float v4, float v5, float v6, float v7, float v8, vec3 t) {\n    return mix(\n        mix(mix(v1, v2, t.x), mix(v3, v4, t.x), t.y),\n        mix(mix(v5, v6, t.x), mix(v7, v8, t.x), t.y),\n        t.z\n    );\n}\n\nvec3 fade(vec3 t) {\n\treturn t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nfloat noise(vec3 p) {\n    vec3 fl_p = floor(p);\n    vec3 fr_p = p - fl_p;\n    uvec3 c = uvec3(fl_p);\n    \n    return interp(\n        dot(grad_dir(hash(c)), fr_p),\n        dot(grad_dir(hash((c + uvec3(1, 0, 0)))), fr_p - vec3(1, 0, 0)),\n        dot(grad_dir(hash((c + uvec3(0, 1, 0)))), fr_p - vec3(0, 1, 0)),\n        dot(grad_dir(hash((c + uvec3(1, 1, 0)))), fr_p - vec3(1, 1, 0)),\n        dot(grad_dir(hash((c + uvec3(0, 0, 1)))), fr_p - vec3(0, 0, 1)),\n        dot(grad_dir(hash((c + uvec3(1, 0, 1)))), fr_p - vec3(1, 0, 1)),\n        dot(grad_dir(hash((c + uvec3(0, 1, 1)))), fr_p - vec3(0, 1, 1)),\n        dot(grad_dir(hash((c + uvec3(1, 1, 1)))), fr_p - vec3(1, 1, 1)),\n        fade(fr_p));\n}\n\nfloat perlin(vec3 p, int freq, int octa, float pers, float lacu) {\n    float v = 0., a = 1., c_f = float(freq);\n    for (int i = 0; i < octa; i++) {\n        v += noise(p * c_f) * a;\n        a *= pers;\n        c_f *= lacu;\n    }\n    return v;\n}\n\nvoid mainImage(out vec4 O, in vec2 I) {\n    vec2 UV = ((I / R) + (T*.03)) * 4.;\n    \n    hept32_seed(7u);\n    \n    float V = perlin(vec3(UV, T * 0.25), 1, 7, 0.333, 1.777);\n    V = 1.-abs(((V*V)+V)*.5);\n    \n    O = vec4(vec3(floor((pow(V,7.777))+.5))*vec3(1.,.0,.25), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsc3W4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[42, 161, 198, 198, 470], [472, 472, 501, 501, 746], [748, 843, 863, 863, 897], [899, 899, 922, 922, 1639], [1641, 1641, 1743, 1743, 1888], [1890, 1890, 1909, 1909, 1959], [1961, 1961, 1982, 1982, 2657], [2659, 2659, 2725, 2725, 2902], [2904, 2904, 2943, 2943, 3180]]}
{"id": "fsc3WM", "name": "Planar Light", "author": "rodousse", "description": "Just a plane and a quad, playing around with polygonal mesh lights as a first draft of a real time implementation ", "tags": ["raytracingbrdfplanarlight"], "likes": 10, "viewed": 211, "date": "1629909690", "time_retrieved": "2024-06-20T20:47:03.673712", "image_code": "#define PI 3.14159265\n//Camera field of view °\n#define FOV 45.0\n//Camera rotation speed \n#define ROTATION_SPEED 0.5\n//distance of the camera from the sphere\n#define CAM_DISTANCE 10.0\n//distance of the camera from the ground\n#define CAM_HEIGHT 3.0\n\nvec3 center = vec3(0.0,1.0,0.0);\n\nvec3 lightColor = vec3(1.0,1.0,1.0);\nfloat intensity = 5.0;\nvec3 diffuse = vec3(1.0,1.0,1.0);\nvec3 spec = vec3(1.0, 1.0,1.0);\n\nvec3 quadCenter = vec3(0.0,1.0,0.0);\nvec3 quadNormal = normalize(vec3(1.0,0.0,0.0)); // fix Y orientation causing trouble to compute the up vector\nvec2 quadSize = vec2(3.5, 2.0);\n\nvec3 background = vec3(.05); \n\n//Todo : Compute the spherical triangle area not the planar triangle\nfloat triangleArea(vec3 A, vec3 B, vec3 C)\n{\n    vec3 AB = B-A;\n    return length(cross(B-A, C-A))/2.0;\n    return length(AB) * length(C - (A + AB * dot(AB, C-A))) / 2.;\n}\n\n// Diffuse BRDF\n// Todo, sample the quad domain, and weight the samples with a ggx\nvec3 BRDF(vec3 normal, vec3 pos, vec3 qc, vec3 qn, vec2 qs)\n{\n    vec3 right = cross(qn, vec3(0., 1., 0.));\n    vec3 up = cross(right, qn);\n    \n    vec3 A = vec3(qc - (right * qs.x / 2.) - (up * qs.y / 2.));\n    vec3 B = vec3(qc - (right * qs.x / 2.) + (up * qs.y / 2.));\n    vec3 C = vec3(qc + (right * qs.x / 2.) + (up * qs.y / 2.));\n    vec3 D = vec3(qc + (right * qs.x / 2.) - (up * qs.y / 2.));\n    \n    return intensity * lightColor * (triangleArea(normalize(A-pos), normalize(B-pos), normalize(C-pos)) +\n        triangleArea(normalize(A-pos), normalize(D-pos), normalize(C-pos))) / (2. * PI)\n        ;\n}\n\n\nfloat hitPlane(vec3 dir, vec3 rayPoint, vec3 center, vec3 normal)\n{\n    return max(-(dot(rayPoint, normal)-dot(center, normal)) / dot(normal, dir),0.0);\n}\n\nfloat hitQuad(vec3 dir, vec3 rayPoint, vec3 center, vec3 normal, vec2 size, out vec2 uv)\n{\n    float t = hitPlane(dir, rayPoint, center, normal);\n    vec3 interPoint = rayPoint + t*dir;\n    vec3 right = cross(normal, vec3(0., 1., 0.));\n    vec3 up = cross(right, normal);\n    vec3 interVec = interPoint - center;\n    uv = vec2(dot(right, interVec), dot(up, interVec));\n    vec2 posCenter = abs(uv);\n    uv = (uv/size) + vec2(.5);\n    if(posCenter.x<size.x/2. && posCenter.y<size.y/2.)\n        return t;\n    else\n        return -9999999999999.;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    quadNormal.y = quadNormal.y - .000001;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (uv - vec2(0.5)) * 2.0 * vec2(1.0, float(iResolution.x)/float(iResolution.y));\n    \n    // Camera infos\n    vec3 cam = vec3(CAM_DISTANCE, 1.0, CAM_DISTANCE) * vec3(cos(iTime * ROTATION_SPEED), CAM_HEIGHT, sin(iTime * ROTATION_SPEED)) ;\n    \n    float near = 0.01f;\n    float viewportHeight = 2.0f * near * tan(FOV * 0.5f * PI/180.0f);\n    float viewportWidth = viewportHeight * iResolution.x / iResolution.y;\n    vec3 forward = normalize(center-cam) * near;\n\n    vec3 right = normalize(cross(forward, vec3(0.0,1.0,0.0)));\n    vec3 up = normalize(cross(right, forward)) / (float(iResolution.x)/float(iResolution.y));\n    \n    // Ray generation\n    vec3 dir = (right * cuv.x * (viewportWidth/2.0f));\n    dir += (up * cuv.y * (viewportHeight/2.0f));\n    dir += forward;\n    dir = normalize(dir);\n    \n    // Raytrace ground\n    vec3 normal = vec3(0.0,1.0,0.0);\n    float t = hitPlane(dir, cam, vec3(0.0,0.0,0.0), normal);\n    vec3 colGround = BRDF(normal, cam + dir*t, quadCenter, quadNormal , quadSize);\n    \n    //Raytrace quad\n    vec2 quadUv;\n    float quadT = hitQuad(dir, cam, quadCenter, quadNormal , quadSize, quadUv);\n    vec3 colQuad = lightColor;\n    \n    //Compose\n\tvec3 col;\n    if(length(t*dir) < length(quadT*dir))\n     col = colGround;\n    else\n     col = colQuad;\n     \n    col = mix(background, col, min(max(t, quadT),1.0));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsc3WM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[621, 690, 734, 734, 861], [863, 946, 1007, 1007, 1557], [1560, 1560, 1627, 1627, 1714], [1716, 1716, 1806, 1806, 2261], [2265, 2265, 2322, 2322, 3798]]}
{"id": "fsc3zn", "name": "Planet Expedition", "author": "omegasbk", "description": "SDF planet", "tags": ["sdf", "planet"], "likes": 7, "viewed": 122, "date": "1628953346", "time_retrieved": "2024-06-20T20:47:03.673712", "image_code": "// Made by Darko Supe (omegasbk)\n// 14.8.2021.\n\n#define MAX_STEPS 100\n#define MAX_DIST 200.\n#define SURF_DIST .005\n\n#define PI 3.14159265359\n\nconst vec3 lightPosition = vec3(0, 3, 4);\nconst vec3 lightColor    = vec3(0.2, 0.2, 0.226) * 2.;\n\nfloat noise(vec2 uv)\n{\n    return fract(sin(uv.x * 113. + uv.y * 412.) * 6339.);\n}\n\nfloat noiseSmooth(vec2 uv)\n{\n    vec2 index = floor(uv);\n    \n    vec2 pq = fract(uv);\n    pq = smoothstep(0., 1., pq);\n     \n    float topLeft = noise(index);\n    float topRight = noise(index + vec2(1, 0.));\n    float top = mix(topLeft, topRight, pq.x);\n    \n    float bottomLeft = noise(index + vec2(0, 1));\n    float bottomRight = noise(index + vec2(1, 1));\n    float bottom = mix(bottomLeft, bottomRight, pq.x);\n    \n    return mix(top, bottom, pq.y);\n}\n\nfloat plane(vec3 p, vec3 n, float h)\n{\n  return dot(p,n) + h;\n}\n\nfloat getDist(in vec3 p)\n{\n    float h = noiseSmooth(p.xz / 8.) * 5.2;\n\n    h += texture(iChannel1, p.xz / 20.).r;\n    return plane(p, vec3(0., 1., 0), h);\n}\n\nvec3 getNormal(in vec3 p) \n{\n    int body;\n    float d = getDist(p);\n    \n    vec2 e = vec2(.01, 0); \n    \n    vec3 n = d - vec3(\n        getDist(p - e.xyy), \n        getDist(p - e.yxy), \n        getDist(p - e.yyx));\n        \n    return normalize(n);\n}\n\nfloat rayMarch(in vec3 ro, in vec3 rd)\n{\n    float dO = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * dO;\n        float dS = getDist(p);\n        dO += dS;\n        \n        if (dO > MAX_DIST || dS < SURF_DIST) \n            break;\n    }\n    \n    return dO;\n}\n\nvec3 getLight(in vec3 p, in vec3 rd)\n{    \n\tvec3 normal = getNormal(p);\n    vec3 lightDir = normalize(p - lightPosition);\n    \n    float cosa = pow(0.5+0.5*dot(normal, -lightDir), 3.0);\n    float cosr = max(dot(-rd, reflect(lightDir, normal)), 0.0);\n    \n    vec3 ambiant = vec3(0.42);\n    vec3 diffuse = vec3(0.8 * cosa);\n    vec3 phong = vec3(0.5 * pow(cosr, 16.0));\n    \n    return lightColor * (ambiant + diffuse + phong);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(-.15 + sin(iTime) / 4., 1.9 + sin(sin(iTime)) / 2., iTime * 2.);\n    vec3 rd = normalize(vec3(uv.x, uv.y-0.2, 0.8));\n        \n    float d = rayMarch(ro, rd);\n    if (d < MAX_DIST)\n    {\n        vec3 p = ro + rd * d;   \n        \n        vec3 n = getNormal(p);\n        col = (vec3(getLight(p, rd)) / exp(d / 4.) * 10.); \n    }\n    else \n    {    \n        col = vec3(smoothstep(0.998, 0.999, noise(uv)) * noise(uv * 0.5));\n        col -= min(0., noiseSmooth((uv + sin(iTime/10.)) * 20.) / 2.);\n        // col += (1.1 - uv.y * 2.) / 20.;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsc3zn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 240, 262, 262, 322], [324, 324, 352, 352, 781], [783, 783, 821, 821, 846], [848, 848, 874, 874, 1005], [1007, 1007, 1035, 1035, 1259], [1261, 1261, 1301, 1301, 1553], [1555, 1555, 1593, 1593, 1983], [1985, 1985, 2041, 2041, 2732]]}
{"id": "fsc3zX", "name": "Kaleidoscope 2 (atz)", "author": "ilyaev", "description": "Kaleidoscope example", "tags": ["kaleidoscope"], "likes": 6, "viewed": 106, "date": "1630304805", "time_retrieved": "2024-06-20T20:47:03.673712", "image_code": "precision mediump float;\n#define PI 3.14159265359\n#define PI2 6.28309265359\n\n\nfloat n21(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898 + floor(1.), 4.1414))) * 43758.5453);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nvec3 renderPlasmaOriginal(vec2 uv) {\n    for(float i = 1.0; i < 10.0; i++){\n        uv.x += 0.6 / i * cos(i * 2.5* uv.y + iTime);\n        uv.y += 0.6 / i * cos(i * 1.5 * uv.x + iTime);\n    }\n    vec3 col = 0.5 + 0.5*sin(iTime+uv.xyx+vec3(0,2,4));\n    return col/(2.1*abs(cos(iTime-uv.y-uv.x)));\n}\n\n\nfloat sdCircle(vec2 p, vec2 pos, float radius) {\n    return distance(p, pos) - radius;\n}\n\nmat2 rot2d(float a) {\n    return mat2(vec2(sin(a), cos(a)), vec2(-cos(a), sin(a)));\n}\n\nvec3 background(vec2 uv) {\n    uv += vec2(0.);\n    float d = 1. - step(.5, length(uv));\n    float a = atan(uv.x, uv.y) + PI;\n\n    float segments = 18.;\n    float sector = floor(segments * (a/PI2));\n\n\n    vec3 color = vec3(0.);\n\n    if (a < PI) {\n        color = vec3(.9, .2, .1) * d;\n    } else {\n        color =vec3(.5, .6, .2) * d;\n    }\n\n    float box = sdBox(abs(uv * rot2d(PI/3.3)), vec2(.3, .5));\n    if (a < PI/2. || (a > PI && a < PI + PI/2.)) {\n        float d = (1. - step(.0, box));\n        if (d > 0.) {\n            color = d * vec3(.0, .4, .9);\n        }\n        color -= (1. - step(.0, abs(box) - .005)) * vec3(2.);\n    }\n\n    float box2 = sdBox(abs(uv * rot2d(-PI/5.)), vec2(.3, .5));\n    float d1 = (1. - step(.0, box2));\n    if ( a < PI && a > PI/2.) {\n        if (d1 > 0.) {\n            color = d1 * vec3(.5, .6, .2);\n        }\n        color -= (1. - step(.0, abs(box2) - .005)) * vec3(2.);\n\n    }\n\n    if ( a > PI + PI/2. ) {\n        if (d1 > 0.) {\n            color = d1 * vec3(.9, .2, .1);\n        }\n        color -= (1. - step(.0, abs(box2) - .005)) * vec3(2.);\n    }\n\n\n    color *= step(.005, abs(uv.x));\n    color *= step(.005, abs(uv.y));\n\n\n    return max(vec3(0.), color / abs(sin(uv.y*(13. + cos(iTime)*5.) + iTime + cos(uv.x*(20. + sin(iTime)*5. + sin(uv.y*12.)*4.) + iTime*2.)))*.48);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float n = n21(vec2(floor(iTime)));\n    float n1 = n21(vec2(floor(iTime) + 1.));\n    float nn = mix(n, n1, fract(iTime));\n    \n    float _SegmentCount = 7.;\n\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    vec2 shiftUV = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\n    shiftUV *= rot2d((nn - .5) * PI/2.);\n\n\n    float radius = sqrt(dot(shiftUV, shiftUV));\n    float angle = atan(shiftUV.y, shiftUV.x) + mouse.x;\n\n    float segmentAngle = PI2 / _SegmentCount;\n\n    float wid = floor((angle + PI) / segmentAngle);\n\n    angle -= segmentAngle * floor(angle / segmentAngle);\n\n    angle = min(angle, segmentAngle - angle);\n\n    vec2 uv = vec2(cos(angle), sin(angle)) * radius;// + sin(iTime) * 0.1;\n\n\n    vec3 color = vec3(0.);\n    \n\n    color += background((uv/1.4 + vec2(sin(iTime - uv.y*(3. + nn))*.08, cos(iTime + uv.x)*.05)) * rot2d(iTime*.3 + uv.x*sin(iTime + uv.y/4. + uv.x*4.) * 4.*nn));\n    color += renderPlasmaOriginal(uv * rot2d(iTime*.2 + nn) + vec2(sin(iTime + uv.x - nn * 2.), cos(iTime + uv.y))*(.2 + nn *.1)) *.3;\n  \n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsc3zX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[78, 78, 97, 97, 178], [180, 180, 217, 217, 297], [300, 300, 336, 336, 596], [599, 599, 647, 647, 687], [689, 689, 710, 710, 774], [776, 776, 802, 802, 2091], [2094, 2094, 2151, 2151, 3224]]}
{"id": "fscGz2", "name": "Stars with no for loops", "author": "TestCoder", "description": "stars", "tags": ["stars"], "likes": 0, "viewed": 190, "date": "1630165832", "time_retrieved": "2024-06-20T20:47:03.673712", "image_code": "float getSoftNoise(float x) {\n    float wave = sin(x / 32.)\n            + sin(x)\n            + cos(2. * x) / 2.\n            + sin(4. * x) / 4.\n            + sin(8. * x) / 8.\n            + sin(16. * x) / 16.\n            + sin(32. * x) / 32.;\n    return wave / 1000.;\n}\n\nfloat getStarSwitch(float x) {\n    float zoom = 1000000.;\n    float softNoise = getSoftNoise(x * zoom);\n    float density = .000001;\n\n    if (softNoise < 0. && softNoise > -density) {\n        return -softNoise * (1. / density) * sin(\n            iTime + sin(x * 50.) * 5.\n        );\n    }\n\n    return 0.;\n}\n\nfloat getStarPattern(vec2 uv) {\n    float voidSwitch = (\n        getStarSwitch(uv.x + cos(uv.x) * sin(uv.y)) +\n        getStarSwitch(uv.y + sin(uv.x) * cos(uv.y) / 20.)\n    );\n\n    return voidSwitch;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 col = getStarPattern(uv) * vec3(1, 1, 2);\n\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fscGz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 29, 29, 267], [269, 269, 299, 299, 575], [577, 577, 608, 608, 778], [780, 780, 835, 835, 1010]]}
{"id": "fscGzX", "name": "StarFieldAleph", "author": "AriesTiger", "description": "Just a project on making a starfield following the Art of Code tutorial https://www.youtube.com/watch?v=rvDo9LvfoVE.", "tags": ["random", "star", "space", "stars"], "likes": 12, "viewed": 209, "date": "1630302483", "time_retrieved": "2024-06-20T20:47:04.176847", "image_code": "//takes input angle rotation func, returns a rotation matrix\n\n#define NUM_LAYERS 9.\nmat2 Rotate(float a)\n\n{\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Star(vec2 uv, float flare)\n{\n     \n    //gets length to center of screen\n    float d = length(uv);\n    float m = .05/d;\n    \n    //lense flare\n    float rays = max(0., .5-abs(uv.x*uv.y*1200.0));\n    m += rays*flare;\n    \n    //second lense flare\n    uv *= Rotate(3.14159265/4.);\n    rays = max(0., 1./.5-abs(uv.x*uv.y*2000.0));\n    m += rays*.3*flare;\n    m*= smoothstep(.4, .2, d);\n    return m;\n     \n}\n//RNG\nfloat Hash21(vec2 p)\n{\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nvec3 StarLayer(vec2 uv)\n{\n    vec3 col = vec3(0);\n //making boxes\n    vec2 gv = fract(uv)-.5;\n   vec2 id = floor(uv);\n   \n   //iter thru 3x3 nbhd to add local contributions of light\n   for(int y=-1; y<=1; y++)\n    {\n        for(int x = -1; x<=1; x++)\n        {\n        //offset\n        vec2 offs = vec2(x, y);\n        float r = Hash21(id + offs); //rand btwn 0 & 1\n        float luminosity = fract(r*3817345.32);\n        float star = Star(gv-offs-vec2(r-.5,fract(r*72.)), smoothstep(.6, .8, luminosity));\n        col += star*luminosity;\n        \n        float colNum = 8682.90;\n        vec3 color = sin(vec3(.2, .3, .9)*fract(r*546.657)*colNum)*.7+.5;\n        //specifying colors\n        color = color*vec3(1.+.5, 0., 1.+.5);\n        star *= sin(iTime*3.+r*6.3)*.5+1.;\n        col+=star*luminosity*color;\n\n        }\n    }\n            return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t = iTime*.05;\n    uv*=8.;\n    uv*= Rotate(t);\n    vec3 col = vec3(0);\n    \n    for(float i=0.; i<1.; i+=1./NUM_LAYERS)\n    {\n        float depth = fract(i+t);\n        \n        float scale = mix(7., .5, depth);\n        float fade = depth*smoothstep(1., .9, depth);\n        col+=StarLayer(uv*scale+i*42.)*fade;\n    }\n    \n   \n \n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fscGzX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 84, 107, 107, 169], [171, 171, 205, 249, 581], [582, 588, 610, 610, 704], [706, 706, 731, 731, 1558], [1560, 1560, 1617, 1617, 2050]]}
{"id": "fsd3Dn", "name": "RGB Sludge", "author": "Pelegefen", "description": "some noise blending using fbms and iq's fbm pattern function, modified for my needs.", "tags": ["noise", "value", "generation", "landmass"], "likes": 4, "viewed": 192, "date": "1630067519", "time_retrieved": "2024-06-20T20:47:04.176847", "image_code": "float hash(vec2 p) \n{\n    p  = 50.0*fract( p*0.132151241 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )// thanks to iq\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat pattern( in vec2 p )\n{\n    vec2 q = vec2( noise( p + vec2(0.0,0.0) ),\n                   noise( p + vec2(5.2,1.3) ) );\n\n    vec2 r = vec2( noise( p + 8.0*q + vec2(1.7,9.2) ),\n                   noise( p + 8.0*q + vec2(8.3,2.8) ) );\n\n    return noise( p + 4.0*r );\n}\nvec4 Terrain(vec2 uv){\n\nvec2 ms = (iMouse.xy / iResolution.xy);\nfloat mousePos = length(ms);\nfloat f = 0.0;\n   \n       \tuv *= 5.0;\n        mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\t\tf  = 0.5000*noise( (uv- ms)- iTime ); uv = m*uv;\n\t\tf += 0.2500*noise( (uv+ ms)+ iTime ); uv = m*uv;\n\t\tf += 0.1250*noise( (uv- ms)- (iTime * .25) ); uv = m*uv;\n\t\tf += 0.0625*noise( (uv+ ms) + (iTime * .5)); uv = m*uv;\n        f = ((fract(uv.y * uv.x + iTime)+f ));\n     \n        \n        \n      vec4 landCol = vec4(\n       sin(f*.75+ iTime)*.5+.5,\n       sin(f- iTime)   *.5+.5,\n       sin(f*.1  + iTime)*.5+.5,\n       1.);\n       \n       //landCol *= vec4(.1 + f,.7+ f,.9,1.);\n       \n       \n       vec4 colorLand = vec4(landCol + pow(f , smoothstep(.2,.21,f)));\n       float b = smoothstep(.05,.08,f);\n       float c = smoothstep(.1,.2,f);\n      float d = smoothstep(.25,.3,f);\n       vec4 color = vec4(f); \n       \n      // float  iTime = iTime - 200000.;\n        color = max(color , colorLand );\n       return color - (c * d * b) * max(pattern((uv-iTime) *.04), pattern((uv+iTime) *.04));\n       \n       }\n       \n       \n       \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n     vec3 col;\n     vec2 p = fragCoord.xy / iResolution.xy;\n    vec4 color;\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0)+ 1000. ;\n\tuv -= (iMouse.xy / iResolution.xy);\n        color = Terrain(uv*1.) ;\n\n    //vignnette\n    color -= length((p*vec2(iResolution.x/iResolution.y,1.0)-vec2(.85,.5))*2.);\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsd3Dn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 21, 21, 127], [129, 129, 170, 170, 464], [465, 465, 493, 493, 736], [737, 737, 759, 759, 1827], [1852, 1852, 1909, 1909, 2238]]}
{"id": "fsd3R2", "name": "ZCAM and Oklab gamut", "author": "kdrag0n", "description": "Visualizing the sRGB gamut in ZCAM (default) and Oklab (mouse down) color spaces.\n\nThis shader has many other features that can be enabled by uncommenting the respective sections in mainImage. See https://github.com/kdrag0n/glcolortest for more info.", "tags": ["color", "cam", "gamut", "colorscience", "oklab", "zcam"], "likes": 1, "viewed": 159, "date": "1630231596", "time_retrieved": "2024-06-20T20:47:09.953151", "image_code": "precision highp float;\n\n/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2021 Danny Lin <danny@kdrag0n.dev>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n/*\n * Config\n */\n\nconst float HUE_RATE = 20.0;\n\nconst float SRGB_WHITE_LUMINANCE = 203.0; // cd/m^2\nconst float SRGB_WHITE_LUMINANCE_DYN_MAX = 10000.0; // cd/m^2\n\n\n/*\n * Helpers\n */\n\nconst float PI = 3.141592653589793;\nconst float FLT_MAX = 3.402823466e+38;\n\nfloat degreesToRadians(float x) {\n    return x * PI / 180.0;\n}\n\nfloat radiansToDegrees(float x) {\n    return x * 180.0 / PI;\n}\n\nfloat atan2(float y, float x) {\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nfloat cbrt(float x) {\n    return sign(x) * pow(abs(x), 1.0 / 3.0);\n}\n\nfloat square(float x) {\n    return x * x;\n}\n\nfloat cube(float x) {\n    return x * x * x;\n}\n\nfloat sqrtStd(float x) {\n    if (x < 0.0) {\n        return 0.0 / 0.0;\n    } else {\n        return sqrt(x);\n    }\n}\n\n\n/*\n * Number rendering\n */\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0)\n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{\n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n\n    bool bNeg = ( fValue < 0.0 );\n    fValue = abs(fValue);\n\n    float fLog10Value = log2(abs(fValue)) / log2(10.0);\n    float fBiggestIndex = max(floor(fLog10Value), 0.0);\n    float fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n    float fCharBin = 0.0;\n    if(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n        if(fDigitIndex > fBiggestIndex) {\n            if((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n        } else {\n            if(fDigitIndex == -1.0) {\n                if(fDecimalPlaces > 0.0) fCharBin = 2.0;\n            } else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n                float fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n            }\n        }\n    }\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\n/*\n * LCh\n */\n\nvec3 labToLch(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float hDeg = radiansToDegrees(atan2(b, a));\n    return vec3(\n        L,\n        sqrt(a*a + b*b),\n        (hDeg < 0.0) ? hDeg + 360.0 : hDeg\n    );\n}\n\nvec3 lchToLab(vec3 c) {\n    float L = c.x;\n    float C = c.y;\n    float h = c.z;\n\n    float hRad = degreesToRadians(h);\n    return vec3(\n        L,\n        C * cos(hRad),\n        C * sin(hRad)\n    );\n}\n\n\n/*\n * sRGB\n */\n\nvec3 srgbTransfer(vec3 c) {\n    vec3 gamma = 1.055 * pow(c, vec3(1.0/2.4)) - 0.055;\n    vec3 linear = 12.92 * c;\n    bvec3 selectParts = lessThan(c, vec3(0.0031308));\n    return mix(gamma, linear, selectParts);\n}\n\nvec3 srgbTransferInv(vec3 c) {\n    vec3 gamma = pow((c + 0.055)/1.055, vec3(2.4));\n    vec3 linear = c / 12.92;\n    bvec3 selectParts = lessThan(c, vec3(0.04045));\n    return mix(gamma, linear, selectParts);\n}\n\nbool linearSrgbInGamut(vec3 c) {\n    vec3 clamped = clamp(c, 0.0, 1.0);\n    return c == clamped;\n}\n\nfloat _int8ToFloat(int x) {\n    return float(x) / 255.0;\n}\n\nvec3 rgb8ToFloat(int c) {\n    return vec3(\n        _int8ToFloat((c >> 16) & 0xff),\n        _int8ToFloat((c >> 8) & 0xff),\n        _int8ToFloat(c & 0xff)\n    );\n}\n\n\n/*\n * XYZ\n */\n\nconst vec3 D65 = vec3(0.95047, 1.0, 1.08883);\nconst vec3 DCI_P3 = vec3(0.89458689, 1.0, 0.95441595);\n\nconst mat3 M_SRGB_TO_XYZ = mat3(\n    0.4123908 , 0.21263901, 0.01933082,\n    0.35758434, 0.71516868, 0.11919478,\n    0.18048079, 0.07219232, 0.95053215\n);\nconst mat3 M_XYZ_TO_SRGB = mat3(\n     3.24096994, -0.96924364,  0.05563008,\n    -1.53738318,  1.8759675 , -0.20397696,\n    -0.49861076,  0.04155506,  1.05697151\n);\n\nconst mat3 M_DISPLAY_P3_TO_XYZ = mat3(\n     0.48657095,  0.22897456, -0.        ,\n     0.26566769,  0.69173852,  0.04511338,\n     0.19821729,  0.07928691,  1.04394437\n);\nconst mat3 M_XYZ_TO_DISPLAY_P3 = mat3(\n     2.49349691, -0.82948897,  0.03584583,\n    -0.93138362,  1.76266406, -0.07617239,\n    -0.40271078,  0.02362469,  0.95688452\n);\n\nconst mat3 M_BT2020_TO_XYZ = mat3(\n    0.63695805, 0.26270021, 0.        ,\n    0.1446169 , 0.67799807, 0.02807269,\n    0.16888098, 0.05930172, 1.06098506\n);\nconst mat3 M_XYZ_TO_BT2020 = mat3(\n     1.71665119, -0.66668435,  0.01763986,\n    -0.35567078,  1.61648124, -0.04277061,\n    -0.25336628,  0.01576855,  0.94210312\n);\n\nconst mat3 M_DCI_P3_TO_XYZ = mat3(\n     0.44516982,  0.20949168, -0.        ,\n     0.27713441,  0.72159525,  0.04706056,\n     0.17228267,  0.06891307,  0.90735539\n);\nconst mat3 M_XYZ_TO_DCI_P3 = mat3(\n     2.72539403, -0.79516803,  0.04124189,\n    -1.01800301,  1.68973205, -0.08763902,\n    -0.4401632 ,  0.02264719,  1.10092938\n);\n\nvec3 linearSrgbToXyz(vec3 c) {\n    return M_SRGB_TO_XYZ * c;\n}\n\nvec3 xyzToLinearSrgb(vec3 c) {\n    return M_XYZ_TO_SRGB * c;\n}\n\n\n/*\n * CIELAB\n */\n\n\nfloat cielabF(float x) {\n    if (x > 216.0/24389.0) {\n        return cbrt(x);\n    } else {\n        return x / (108.0/841.0) + 4.0/29.0;\n    }\n}\n\nfloat cielabFInv(float x) {\n    if (x > 6.0/29.0) {\n        return cube(x);\n    } else {\n        return (108.0/841.0) * (x - 4.0/29.0);\n    }\n}\n\nvec3 xyzToCielab(vec3 c) {\n    float L = 116.0 * cielabF(c.y / D65.y) - 16.0;\n    float a = 500.0 * (cielabF(c.x / D65.x) - cielabF(c.y / D65.y));\n    float b = 200.0 * (cielabF(c.y / D65.y) - cielabF(c.z / D65.z));\n    return vec3(L, a, b);\n}\n\nvec3 cielabToXyz(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float lp = (L + 16.0) / 116.0;\n    float x = D65.x * cielabFInv(lp + (a / 500.0));\n    float y = D65.y * cielabFInv(lp);\n    float z = D65.z * cielabFInv(lp - (b / 200.0));\n    return vec3(x, y, z);\n}\n\n\n/*\n * Oklab\n */\n\nvec3 xyzToOklab(vec3 c) {\n    float l = 0.8189330101 * c.x + 0.3618667424 * c.y - 0.1288597137 * c.z;\n    float m = 0.0329845436 * c.x + 0.9293118715 * c.y + 0.0361456387 * c.z;\n    float s = 0.0482003018 * c.x + 0.2643662691 * c.y + 0.6338517070 * c.z;\n\n    float l_ = cbrt(l);\n    float m_ = cbrt(m);\n    float s_ = cbrt(s);\n\n    return vec3(\n        0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_,\n        1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_,\n        0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_\n    );\n}\n\nvec3 oklabToXyz(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float l_ = L + 0.3963377774f * a + 0.2158037573f * b;\n    float m_ = L - 0.1055613458f * a - 0.0638541728f * b;\n    float s_ = L - 0.0894841775f * a - 1.2914855480f * b;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    return vec3(\n        +1.2270138511 * l - 0.5577999807 * m + 0.2812561490 * s,\n        -0.0405801784 * l + 1.1122568696 * m - 0.0716766787 * s,\n        -0.0763812845 * l - 0.4214819784 * m + 1.5861632204 * s\n    );\n}\n\nvec3 linearSrgbToOklab(vec3 c) {\n    return xyzToOklab(linearSrgbToXyz(c));\n}\n\nvec3 oklabToLinearSrgb(vec3 c) {\n    return xyzToLinearSrgb(oklabToXyz(c));\n}\n\n\n/*\n * Oklab gamut clipping\n */\n\n/*\n * Ported from the original C/C++ implementation:\n *\n * Copyright (c) 2021 Björn Ottosson\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n    // Max saturation will be when one of r, g or b goes below zero.\n\n    // Select different coefficients depending on which component goes below zero first\n    float k0, k1, k2, k3, k4, wl, wm, ws;\n\n    if (-1.88170328f * a - 0.80936493f * b > 1.0)\n    {\n        // Red component\n        k0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n        wl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n    }\n    else if (1.81444104f * a - 1.19445276f * b > 1.0)\n    {\n        // Green component\n        k0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n        wl = -1.2681437731f; wm = +2.6097574011f; ws = -0.3413193965f;\n    }\n    else\n    {\n        // Blue component\n        k0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n        wl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n    }\n\n    // Approximate max saturation using a polynomial:\n    float S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n    // Do one step Halley's method to get closer\n    // this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n    // this should be sufficient for most applications, otherwise do two/three steps\n\n    float k_l = +0.3963377774f * a + 0.2158037573f * b;\n    float k_m = -0.1055613458f * a - 0.0638541728f * b;\n    float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n    {\n        float l_ = 1.f + S * k_l;\n        float m_ = 1.f + S * k_m;\n        float s_ = 1.f + S * k_s;\n\n        float l = l_ * l_ * l_;\n        float m = m_ * m_ * m_;\n        float s = s_ * s_ * s_;\n\n        float l_dS = 3.f * k_l * l_ * l_;\n        float m_dS = 3.f * k_m * m_ * m_;\n        float s_dS = 3.f * k_s * s_ * s_;\n\n        float l_dS2 = 6.f * k_l * k_l * l_;\n        float m_dS2 = 6.f * k_m * k_m * m_;\n        float s_dS2 = 6.f * k_s * k_s * s_;\n\n        float f  = wl * l     + wm * m     + ws * s;\n        float f1 = wl * l_dS  + wm * m_dS  + ws * s_dS;\n        float f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n        S = S - f * f1 / (f1*f1 - 0.5f * f * f2);\n    }\n\n    return S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b)\n{\n    // First, find the maximum saturation (saturation S = C/L)\n    float S_cusp = compute_max_saturation(a, b);\n\n    // Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n    vec3 rgb_at_max = oklabToLinearSrgb(vec3( 1.0, S_cusp * a, S_cusp * b ));\n    float L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n    float C_cusp = L_cusp * S_cusp;\n\n    return vec2( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by\n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n    // Find the cusp of the gamut triangle\n    vec2 cusp = find_cusp(a, b);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    // Find the intersection for upper and lower half seprately\n    float t;\n    if (((L1 - L0) * cuspC - (cuspL - L0) * C1) <= 0.f)\n    {\n        // Lower half\n\n        t = cuspC * L0 / (C1 * cuspL + cuspC * (L0 - L1));\n    }\n    else\n    {\n        // Upper half\n\n        // First intersect with triangle\n        t = cuspC * (L0 - 1.f) / (C1 * (cuspL - 1.f) + cuspC * (L0 - L1));\n\n        // Then one step Halley's method\n        {\n            float dL = L1 - L0;\n            float dC = C1;\n\n            float k_l = +0.3963377774f * a + 0.2158037573f * b;\n            float k_m = -0.1055613458f * a - 0.0638541728f * b;\n            float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n            float l_dt = dL + dC * k_l;\n            float m_dt = dL + dC * k_m;\n            float s_dt = dL + dC * k_s;\n\n            // If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n            {\n                float L = L0 * (1.f - t) + t * L1;\n                float C = t * C1;\n\n                float l_ = L + C * k_l;\n                float m_ = L + C * k_m;\n                float s_ = L + C * k_s;\n\n                float l = l_ * l_ * l_;\n                float m = m_ * m_ * m_;\n                float s = s_ * s_ * s_;\n\n                float ldt = 3.0 * l_dt * l_ * l_;\n                float mdt = 3.0 * m_dt * m_ * m_;\n                float sdt = 3.0 * s_dt * s_ * s_;\n\n                float ldt2 = 6.0 * l_dt * l_dt * l_;\n                float mdt2 = 6.0 * m_dt * m_dt * m_;\n                float sdt2 = 6.0 * s_dt * s_dt * s_;\n\n                float r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.0;\n                float r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n                float r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n                float u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n                float t_r = -r * u_r;\n\n                float g = -1.2681437731f * l + 2.6097574011f * m - 0.3413193965f * s - 1.0;\n                float g1 = -1.2681437731f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n                float g2 = -1.2681437731f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n                float u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n                float t_g = -g * u_g;\n\n                float b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.0;\n                float b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n                float b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n                float u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n                float t_b = -b * u_b;\n\n                t_r = u_r >= 0.f ? t_r : FLT_MAX;\n                t_g = u_g >= 0.f ? t_g : FLT_MAX;\n                t_b = u_b >= 0.f ? t_b : FLT_MAX;\n\n                t += min(t_r, min(t_g, t_b));\n            }\n        }\n    }\n\n    return t;\n}\n\nvec3 gamut_clip_preserve_lightness(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L0 = clamp(L, 0.0, 1.0);\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_0_5(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L0 = 0.5;\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_L_cusp(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n    vec2 cusp = find_cusp(a_, b_);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    float L0 = cuspL;\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_0_5(vec3 rgb, float alpha)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float Ld = L - 0.5f;\n    float e1 = 0.5f + abs(Ld) + alpha * C;\n    float L0 = 0.5f*(1.f + sign(Ld)*(e1 - sqrt(e1*e1 - 2.f *abs(Ld))));\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.f - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_L_cusp(vec3 rgb, float alpha)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n    vec2 cusp = find_cusp(a_, b_);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    float Ld = L - cuspL;\n    float k = 2.f * (Ld > 0.0 ? 1.f - cuspL : cuspL);\n\n    float e1 = 0.5f*k + abs(Ld) + alpha * C/k;\n    float L0 = cuspL + 0.5f * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.f - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\n\n/*\n * ZCAM (JCh values)\n */\n\nconst float B = 1.15;\nconst float G = 0.66;\nconst float C1 = 3424.0 / 4096.0;\nconst float C2 = 2413.0 / 128.0;\nconst float C3 = 2392.0 / 128.0;\nconst float ETA = 2610.0 / 16384.0;\nconst float RHO = 1.7 * 2523.0 / 32.0;\nconst float EPSILON = 3.7035226210190005e-11;\n\nconst float SURROUND_DARK = 0.525;\nconst float SURROUND_DIM = 0.59;\nconst float SURROUND_AVERAGE = 0.69;\n\nstruct ZcamViewingConditions {\n    // Given\n    float F_s;\n    float L_a;\n    float Y_b;\n    vec3 refWhite;\n    float whiteLuminance;\n\n    // Calculated\n    float F_b;\n    float F_l;\n    float refWhiteIz;\n};\n\nfloat pq(float x) {\n    float num = C1 + C2 * pow(x / 10000.0, ETA);\n    float denom = 1.0 + C3 * pow(x / 10000.0, ETA);\n\n    return pow(num / denom, RHO);\n}\n\nfloat pqInv(float x) {\n    float num = C1 - pow(x, 1.0/RHO);\n    float denom = C3*pow(x, 1.0/RHO) - C2;\n\n    return 10000.0 * pow(num / denom, 1.0/ETA);\n}\n\nvec3 xyzToIzazbz(vec3 c) {\n    float xp = B*c.x - (B-1.0)*c.z;\n    float yp = G*c.y - (G-1.0)*c.x;\n\n    float rp = pq( 0.41478972*xp + 0.579999*yp + 0.0146480*c.z);\n    float gp = pq(-0.20151000*xp + 1.120649*yp + 0.0531008*c.z);\n    float bp = pq(-0.01660080*xp + 0.264800*yp + 0.6684799*c.z);\n\n    float az = 3.524000*rp + -4.066708*gp +  0.542708*bp;\n    float bz = 0.199076*rp +  1.096799*gp + -1.295875*bp;\n    float Iz = gp - EPSILON;\n\n    return vec3(Iz, az, bz);\n}\n\nfloat hpToEz(float hp) {\n    return 1.015 + cos(degreesToRadians(89.038 + hp));\n}\n\nfloat izToQz(float Iz, ZcamViewingConditions cond) {\n    return 2700.0 * pow(Iz, (1.6 * cond.F_s) / pow(cond.F_b, 0.12)) *\n            (pow(cond.F_s, 2.2) * pow(cond.F_b, 0.5) * pow(cond.F_l, 0.2));\n}\n\nZcamViewingConditions createZcamViewingConditions(float F_s, float L_a, float Y_b, vec3 refWhite, float whiteLuminance) {\n    float F_b = sqrt(Y_b / refWhite.y);\n    float F_l = 0.171 * cbrt(L_a) * (1.0 - exp(-48.0/9.0 * L_a));\n    float refWhiteIz = xyzToIzazbz(refWhite).x;\n\n    return ZcamViewingConditions(\n        F_s, L_a, Y_b, refWhite, whiteLuminance,\n        F_b, F_l, refWhiteIz\n    );\n}\n\nstruct Zcam {\n    float brightness;\n    float lightness;\n    float colorfulness;\n    float chroma;\n    float hueAngle;\n    /* hue composition is not implemented */\n\n    float saturation;\n    float vividness;\n    float blackness;\n    float whiteness;\n\n    ZcamViewingConditions cond;\n};\n\nZcam xyzToZcam(vec3 c, ZcamViewingConditions cond) {\n    /* Step 2 */\n    // Achromatic response\n    vec3 izazbz = xyzToIzazbz(c);\n    float Iz = izazbz.x;\n    float az = izazbz.y;\n    float bz = izazbz.z;\n    float Iz_w = cond.refWhiteIz;\n\n    /* Step 3 */\n    // Hue angle\n    float hz = radiansToDegrees(atan2(bz, az));\n    float hp = (hz < 0.0) ? hz + 360.0 : hz;\n\n    /* Step 4 */\n    // Eccentricity factor\n    float ez = hpToEz(hp);\n\n    /* Step 5 */\n    // Brightness\n    float Qz = izToQz(Iz, cond);\n    float Qz_w = izToQz(cond.refWhiteIz, cond);\n\n    // Lightness\n    float Jz = 100.0 * (Qz / Qz_w);\n\n    // Colorfulness\n    float Mz = 100.0 * pow(square(az) + square(bz), 0.37) *\n            ((pow(ez, 0.068) * pow(cond.F_l, 0.2)) /\n                    (pow(cond.F_b, 0.1) * pow(Iz_w, 0.78)));\n    \n    // Chroma\n    float Cz = 100.0 * (Mz / Qz_w);\n\n    /* Step 6 */\n    // Saturation\n    float Sz = 100.0 * pow(cond.F_l, 0.6) * sqrt(Mz / Qz);\n\n    // Vividness, blackness, whiteness\n    float Vz = sqrt(square(Jz - 58.0) + 3.4 * square(Cz));\n    float Kz = 100.0 - 0.8 * sqrt(square(Jz) + 8.0 * square(Cz));\n    float Wz = 100.0 - sqrt(square(100.0 - Jz) + square(Cz));\n\n    return Zcam(\n        Qz,\n        Jz,\n        Mz,\n        Cz,\n        hp,\n\n        Sz,\n        Vz,\n        Kz,\n        Wz,\n\n        cond\n    );\n}\n\nvec3 zcamToXyz(vec3 c, ZcamViewingConditions cond) {\n    float Jz = c.x;\n    float Cz = c.y;\n    float hz = c.z;\n\n    float Iz_w = cond.refWhiteIz;\n    float Qz_w = izToQz(Iz_w, cond);\n\n    /* Step 1 */\n    // Achromatic response\n    float Iz_denom = 2700.0 * pow(cond.F_s, 2.2) * pow(cond.F_b, 0.5) * pow(cond.F_l, 0.2);\n    float Iz_src = (Jz * Qz_w) / (Iz_denom * 100.0);\n    float Iz = pow(Iz_src, pow(cond.F_b, 0.12) / (1.6 * cond.F_s));\n\n    /* Step 2 */\n    // Chroma\n    /* skipped because we take Cz as input */\n\n    /* Step 3 is missing because hue composition is not supported */\n\n    /* Step 4 */\n    // ... and back to colorfulness\n    float Mz = (Cz * Qz_w) / 100.0;\n    float ez = hpToEz(hz);\n    float Cz_p = pow((Mz * pow(Iz_w, 0.78) * pow(cond.F_b, 0.1)) /\n            // Paper specifies pow(1.3514) but this extra precision is necessary for more accurate inversion\n            (100.0 * pow(ez, 0.068) * pow(cond.F_l, 0.2)), 1.0 / 0.37 / 2.0);\n    float az = Cz_p * cos(degreesToRadians(hz));\n    float bz = Cz_p * sin(degreesToRadians(hz));\n\n    /* Step 5 */\n    float I = Iz + EPSILON;\n\n    float r = pqInv(I + 0.2772100865*az +  0.1160946323*bz);\n    float g = pqInv(I);\n    float b = pqInv(I + 0.0425858012*az + -0.7538445799*bz);\n\n    float xp =  1.9242264358*r + -1.0047923126*g +  0.0376514040*b;\n    float yp =  0.3503167621*r +  0.7264811939*g + -0.0653844229*b;\n    float z  = -0.0909828110*r + -0.3127282905*g +  1.5227665613*b;\n\n    float x = (xp + (B - 1.0)*z) / B;\n    float y = (yp + (G - 1.0)*x) / G;\n\n    return vec3(x, y, z);\n}\n\nvec3 zcamJchToLinearSrgb(vec3 jch, ZcamViewingConditions cond) {\n    vec3 xyzAbs = zcamToXyz(jch, cond);\n    vec3 xyzRel = xyzAbs / cond.whiteLuminance;\n    return xyzToLinearSrgb(xyzRel);\n}\n\nconst float ZCAM_CHROMA_EPSILON = 0.0001;\nconst bool CLIP_ZCAM = false;\nvec3 clipZcamJchToLinearSrgb(vec3 jch, ZcamViewingConditions cond) {\n    vec3 initialResult = zcamJchToLinearSrgb(jch, cond);\n    if (linearSrgbInGamut(initialResult)) {\n        return initialResult;\n    }\n\n    float lightness = jch.r;\n    float chroma = jch.g;\n    float hue = jch.b;\n    if (lightness <= ZCAM_CHROMA_EPSILON) {\n        return vec3(0.0);\n    } else if (lightness >= 100.0 - ZCAM_CHROMA_EPSILON) {\n        return vec3(1.0);\n    }\n\n    float lo = 0.0;\n    float hi = chroma;\n\n    vec3 newLinearSrgb = initialResult;\n    while (abs(hi - lo) > ZCAM_CHROMA_EPSILON) {\n        float mid = (lo + hi) / 2.0;\n\n        newLinearSrgb = zcamJchToLinearSrgb(vec3(lightness, mid, hue), cond);\n        if (!linearSrgbInGamut(newLinearSrgb)) {\n            hi = mid;\n        } else {\n            float mid2 = mid + ZCAM_CHROMA_EPSILON;\n\n            vec3 newLinearSrgb2 = zcamJchToLinearSrgb(vec3(lightness, mid2, hue), cond);\n            if (linearSrgbInGamut(newLinearSrgb2)) {\n                lo = mid;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return newLinearSrgb;\n}\n\n\n/*\n * Theme generation\n */\n\nconst float OKLAB_ACCENT1_CHROMA = 0.1328123146401862;\nconst float OKLAB_LIGHTNESS_MAP[13] = float[](\n    1.0,\n    0.9880873963836093,\n    0.9551400440214246,\n    0.9127904082618294,\n    0.8265622041716898,\n    0.7412252673769428,\n    0.653350946076347,\n    0.5624050605208273,\n    0.48193149058901036,\n    0.39417829080418526,\n    0.3091856317280812,\n    0.22212874192541768,\n    0.0\n);\n\nconst float ZCAM_ACCENT1_CHROMA = 20.54486422; // careful!\nconst float ZCAM_ACCENT1_COLORFULNESS = 36.47983487;\nconst float ZCAM_LIGHTNESS_MAP[13] = float[](\n    100.00000296754273,\n    98.60403974009428,\n    94.72386350388908,\n    89.69628870011267,\n    79.3326296037671,\n    68.938947819272,\n    58.15091644790415,\n    46.991689840263206,\n    37.24709908558773,\n    26.96785892507836,\n    17.67571012446932,\n    9.36696155986009,\n    0.0\n);\n\nconst float CIELAB_LIGHTNESS_MAP[13] = float[](\n    100.0,\n    99.0,\n    95.0,\n    90.0,\n    80.0,\n    70.0,\n    60.0,\n    49.6,\n    40.0,\n    30.0,\n    20.0,\n    10.0,\n    0.0\n);\n\nconst float ZCAM_LINEAR_LIGHTNESS_MAP[13] = float[](\n    100.0,\n    99.0,\n    95.0,\n    90.0,\n    80.0,\n    70.0,\n    60.0,\n    50.0,\n    40.0,\n    30.0,\n    20.0,\n    10.0,\n    0.0\n);\n\nconst int REF_ACCENT1_COLOR_COUNT = 9;\nconst int REF_ACCENT1_COLORS[9] = int[](\n    0xd3e3fd,\n    0xa8c7fa,\n    0x7cacf8,\n    0x4c8df6,\n    0x1b6ef3,\n    0x0b57d0,\n    0x0842a0,\n    0x062e6f,\n    0x041e49\n);\n\nconst float SWATCH_CHROMA_SCALES[5] = float[](\n    1.0, // accent1\n    1.0 / 3.0, // accent2\n    (1.0 / 3.0) * 2.0, // accent3\n    1.0 / 8.0, // neutral1\n    1.0 / 5.0 // neutral2\n);\n\nvec3 calcShadeParams(int swatch, float lightness, float seedChroma, float seedHue, float chromaFactor, float accent1Chroma) {\n    float refChroma = accent1Chroma * SWATCH_CHROMA_SCALES[0];\n    float targetChroma = accent1Chroma * SWATCH_CHROMA_SCALES[swatch];\n    float scaleC = (refChroma == 0.0) ? 0.0 : (clamp(seedChroma, 0.0, refChroma) / refChroma);\n    float chroma = targetChroma * scaleC * chromaFactor;\n    float hue = (swatch == 2) ? seedHue + 60.0 : seedHue;\n\n    return vec3(lightness, chroma, hue);\n}\n\nvec3 generateShadeOklab(int swatch, int shade, float seedChroma, float seedHue, float chromaFactor) {\n    float cielabL = CIELAB_LIGHTNESS_MAP[shade];\n    vec3 cielabXyz = cielabToXyz(vec3(cielabL, 0.0, 0.0));\n    float lightness = xyzToOklab(cielabXyz).x;\n\n    vec3 lch = calcShadeParams(swatch, lightness, seedChroma, seedHue, chromaFactor, OKLAB_ACCENT1_CHROMA);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nZcamViewingConditions getZcamCond() {\n    float whiteLuminance = SRGB_WHITE_LUMINANCE;\n\n    // Dynamic luminance for testing\n    //whiteLuminance = pow(10.0, (iMouse.x / iResolution.x) * (log(SRGB_WHITE_LUMINANCE_DYN_MAX) / log(10.0)));\n\n    float dynVal1 = (iMouse.x / iResolution.x) * whiteLuminance;\n    float dynVal2 = (iMouse.y / iResolution.y) * whiteLuminance;\n\n    ZcamViewingConditions cond = createZcamViewingConditions(\n        /* surround */ SURROUND_AVERAGE,\n        /* L_a */ 0.4 * whiteLuminance,\n        /* Y_b */ cielabToXyz(vec3(50.0, 0.0, 0.0)).y * whiteLuminance,\n        /* ref white */ D65 * whiteLuminance,\n        /* white luminance */ whiteLuminance\n    );\n\n    return cond;\n}\n\nvec3 generateShadeZcam(int swatch, int shade, float seedChroma, float seedHue, float chromaFactor) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    float cielabL = CIELAB_LIGHTNESS_MAP[shade];\n    vec3 cielabXyz = cielabToXyz(vec3(cielabL, 0.0, 0.0)) * cond.whiteLuminance;\n    float lightness = xyzToZcam(cielabXyz, cond).lightness;\n\n    // Calculate accent1 chroma given the viewing conditions\n    float chromaAcc = 0.0;\n    for (int i = 0; i < REF_ACCENT1_COLOR_COUNT; i++) {\n        vec3 srgb = rgb8ToFloat(REF_ACCENT1_COLORS[i]);\n        vec3 xyzAbs = linearSrgbToXyz(srgbTransferInv(srgb)) * cond.whiteLuminance;\n        Zcam zcam = xyzToZcam(xyzAbs, cond);\n        chromaAcc += zcam.chroma;\n    }\n    float avgChroma = 1.2 * chromaAcc / float(REF_ACCENT1_COLOR_COUNT);\n\n    // For constant values\n    //lightness = ZCAM_LIGHTNESS_MAP[shade];\n    //avgChroma = ZCAM_ACCENT1_CHROMA;\n    // For linear shade lightness in ZCAM\n    //lightness = ZCAM_LINEAR_LIGHTNESS_MAP[shade];\n\n    vec3 jch = calcShadeParams(swatch, lightness, seedChroma, seedHue, chromaFactor, avgChroma);\n\n    if (CLIP_ZCAM) {\n        return clipZcamJchToLinearSrgb(jch, cond);\n    } else {\n        return zcamJchToLinearSrgb(jch, cond);\n    }\n}\n\nvec3 getThemeColor(vec2 uv, float hue) {\n    int shadeIdx = int(uv.x * 13.0);\n    int swatchIdx = int((1.0 - uv.y) * 5.0);\n    float seedChroma = 1000000.0;\n\n    if (shadeIdx == 0) {\n        return vec3(1.0);\n    } else if (shadeIdx == 12) {\n        return vec3(0.0);\n    }\n\n    if (iMouse.z > 0.0) {\n        return gamut_clip_preserve_lightness(generateShadeOklab(swatchIdx, shadeIdx, seedChroma, hue, 1.0));\n    } else {\n        return generateShadeZcam(swatchIdx, shadeIdx, seedChroma, hue, 1.0);\n    }\n}\n\n\n/*\n * Color space interfaces\n */\n\nvec3 getColorOklab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawLightness, rawChroma, hue);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nvec3 getColorCielab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawLightness * 100.0, rawChroma * 170.0, hue);\n    vec3 cielab = lchToLab(lch);\n    return xyzToLinearSrgb(cielabToXyz(cielab));\n}\n\nvec3 getColorZcam(float rawLightness, float rawChroma, float hue) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    vec3 jch = vec3(rawLightness * 100.0, rawChroma * 170.0, hue);\n\n    if (CLIP_ZCAM) {\n        return clipZcamJchToLinearSrgb(jch, cond);\n    } else {\n        return zcamJchToLinearSrgb(jch, cond);\n    }\n}\n\n\nvec3 getLightnessOklab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma, 0.0, hue);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nvec3 getLightnessCielab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma * 100.0, 0.0, hue);\n    vec3 cielab = lchToLab(lch);\n    return xyzToLinearSrgb(cielabToXyz(cielab));\n}\n\nvec3 getLightnessZcam(float rawLightness, float rawChroma, float hue) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    vec3 zcam = vec3(rawChroma * 100.0, 0.0, hue);\n\n    vec3 xyzAbs = zcamToXyz(zcam, cond);\n    vec3 xyzRel = xyzAbs / cond.whiteLuminance;\n    return xyzToLinearSrgb(xyzRel);\n}\n\n\n/*\n * Blending\n */\n\nvec3 blendZcam(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    Zcam lhs = xyzToZcam(linearSrgbToXyz(srgbTransferInv(lhsRgb)) * cond.whiteLuminance, cond);\n    Zcam rhs = xyzToZcam(linearSrgbToXyz(srgbTransferInv(rhsRgb)) * cond.whiteLuminance, cond);\n\n    vec3 lhsJch = vec3(lhs.lightness, lhs.chroma, lhs.hueAngle);\n    vec3 rhsJch = vec3(rhs.lightness, rhs.chroma, lhs.hueAngle);\n    return clipZcamJchToLinearSrgb(mix(lhsJch, rhsJch, uv.x), cond);\n}\n\nvec3 blendLinearSrgb(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    vec3 lhs = srgbTransferInv(lhsRgb);\n    vec3 rhs = srgbTransferInv(rhsRgb);\n\n    return srgbTransfer(mix(lhs, rhs, uv.x));\n}\n\nvec3 blendSrgb(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    return mix(lhsRgb, rhsRgb, uv.x);\n}\n\n\n/*\n * Main\n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy; // NDC (0-1)\n\n    float rawLightness = uv.y;\n    float rawChroma = uv.x;\n    float hue = mod(iTime * HUE_RATE, 360.0); // degrees\n    //hue = 286.66117416556847;\n    vec3 camOut;\n\n    // Rainbow\n    //rawLightness = 0.7502;\n    //rawChroma = 0.138;\n    //hue = uv.x * 360.0;\n\n    // Gamut/cusp animation\n    if (iMouse.z > 0.0) {\n        camOut = getColorOklab(rawLightness, rawChroma, hue);\n        //camOut = gamut_clip_preserve_lightness(camOut);\n    } else {\n        camOut = getColorZcam(rawLightness, rawChroma, hue);\n    }\n\n    // Lightness ramp\n    /*if (iMouse.z > 0.0) {\n        camOut = getLightnessOklab(rawLightness, rawChroma, hue);\n    } else {\n        camOut = getLightnessZcam(rawLightness, rawChroma, hue);\n    }*/\n\n    // Theme generation\n    //camOut = getThemeColor(uv, hue);\n\n    // Chroma contrast\n    /*int testSwatch = 3; // neutral1\n    int testShade = 11; // 900\n    testShade = 4; // 200\n    testSwatch = 0; // accent1\n    if (uv.x > 0.5) {\n        ZcamViewingConditions cond = getZcamCond();\n        vec3 xyzAbs = linearSrgbToXyz(srgbTransferInv(rgb8ToFloat(0x533b79))) * cond.whiteLuminance;\n        Zcam seed = xyzToZcam(xyzAbs, cond);\n        camOut = generateShadeZcam(testSwatch, testShade, seed.chroma, seed.hueAngle, 1.0);\n    } else {\n        testSwatch = 3;\n        testShade = 11;\n        camOut = generateShadeZcam(testSwatch, testShade, 0.0, 0.0, 1.0);\n    }*/\n\n    // Blending\n    /*if (uv.y >= 0.5) {\n        camOut = blendZcam(uv, vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    } else {\n        camOut = blendSrgb(uv, vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    }*/\n\n    // Oklab gamut clipping\n    //camOut = gamut_clip_preserve_lightness(camOut);\n    //camOut = gamut_clip_project_to_0_5(camOut);\n    //camOut = gamut_clip_project_to_L_cusp(camOut);\n    //camOut = gamut_clip_adaptive_L0_0_5(camOut, 0.05);\n    //camOut = gamut_clip_adaptive_L0_L_cusp(camOut, 0.05);\n\n    // Simple RGB clipping (also necessary after gamut clipping)\n    //camOut = clamp(camOut, 0.0, 1.0);\n\n    if (linearSrgbInGamut(camOut)) {\n        vec3 dither = texture(iChannel0, uv * (iResolution.xy / 64.0)).rgb * 2.0 - 1.0;\n        dither = sign(dither) * (1.0 - sqrt(1.0 - abs(dither))) / 64.0;\n        fragColor = vec4(srgbTransfer(camOut) + dither, 1.0);\n    } else {\n\t    vec2 fontSize = vec2(16.0, 30.0);\n        float digit = PrintValue((fragCoord - vec2(iResolution.x - 80.0, 10.0)) / fontSize, hue, 3.0, 0.0);\n        fragColor = vec4(vec3(0.5) + digit, 1.0);\n    }\n\n    // Print dynamic sRGB white luminance\n    /*\n    float whiteL = pow(10.0, (iMouse.x / iResolution.x) * (log(SRGB_WHITE_LUMINANCE_DYN_MAX) / log(10.0)));\n    vec2 fontSize = vec2(16.0, 30.0);\n    float digit2 = PrintValue((fragCoord - vec2(iResolution.x - 80.0, 10.0)) / fontSize, whiteL, 3.0, 0.0);\n    fragColor = vec4(fragColor.rgb + digit2, 1.0);\n    */\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsd3R2.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1352, 1447, 1480, 1480, 1509], [1511, 1511, 1544, 1544, 1573], [1575, 1575, 1606, 1606, 1690], [1692, 1692, 1713, 1713, 1760], [1762, 1762, 1785, 1785, 1805], [1807, 1807, 1828, 1828, 1852], [1854, 1854, 1878, 1878, 1968], [1999, 2147, 2178, 2178, 2336], [2338, 2338, 2432, 2432, 3544], [3600, 3615, 3638, 3638, 3849], [3851, 3851, 3874, 3874, 4052], [4055, 4071, 4098, 4098, 4283], [4285, 4285, 4315, 4315, 4494], [4496, 4496, 4528, 4528, 4594], [4596, 4596, 4623, 4623, 4654], [4656, 4656, 4681, 4681, 4817], [4820, 6255, 6285, 6285, 6317], [6319, 6319, 6349, 6349, 6381], [6384, 6403, 6427, 6427, 6546], [6548, 6548, 6575, 6575, 6691], [6693, 6693, 6719, 6719, 6936], [6938, 6938, 6964, 6964, 7227], [7230, 7247, 7272, 7272, 7791], [7793, 7793, 7818, 7818, 8344], [8346, 8346, 8378, 8378, 8423], [8425, 8425, 8457, 8457, 8502], [9711, 9875, 9923, 10081, 12107], [12109, 12200, 12234, 12297, 12674], [12676, 12814, 12893, 12936, 15967], [15969, 15969, 16015, 16015, 16585], [16587, 16587, 16629, 16629, 17184], [17186, 17186, 17231, 17231, 17992], [17994, 17994, 18050, 18050, 18725], [18727, 18727, 18786, 18786, 19737], [19740, 20350, 20369, 20369, 20507], [20509, 20509, 20531, 20531, 20663], [20665, 20665, 20691, 20691, 21137], [21139, 21139, 21163, 21163, 21220], [21222, 21222, 21274, 21274, 21422], [21424, 21424, 21545, 21545, 21821], [22110, 22110, 22162, 22206, 23442], [23444, 23444, 23496, 23496, 25007], [25009, 25009, 25073, 25073, 25199], [25273, 25273, 25341, 25341, 26380], [26847, 28004, 28129, 28129, 28517], [28519, 28519, 28620, 28620, 28955], [28957, 28957, 28994, 28994, 29658], [29660, 29660, 29760, 29760, 30886], [30888, 30888, 30928, 30928, 31395], [31398, 31432, 31500, 31500, 31622], [31624, 31624, 31693, 31693, 31844], [31846, 31846, 31913, 31913, 32170], [32173, 32173, 32245, 32245, 32358], [32360, 32360, 32433, 32433, 32567], [32569, 32569, 32640, 32640, 32868], [32871, 32891, 32942, 32942, 33385], [33387, 33387, 33444, 33444, 33573], [33575, 33575, 33626, 33626, 33666], [33669, 33685, 33740, 33740, 36644]]}
{"id": "fsd3R7", "name": "2D Landmasses and weather", "author": "Pelegefen", "description": "2D Landmasses, generated using FBM functions described by iq(inigo quilez) on his blog.\nthe wheater, clouds, are a mix between volume and fbm noise.\n\ni've also made a 3D version - https://www.shadertoy.com/view/Ndd3z7", "tags": ["noise", "value", "generation", "landmass"], "likes": 4, "viewed": 53, "date": "1629413871", "time_retrieved": "2024-06-20T20:47:09.953151", "image_code": "float hash(vec2 p)  // thanks to iq\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )// thanks to iq\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat pattern( in vec2 p )\n{\n    vec2 q = vec2( noise( p + vec2(0.0,0.0) ),\n                   noise( p + vec2(5.2,1.3) ) );\n\n    vec2 r = vec2( noise( p + 8.0*q + vec2(1.7,9.2) ),\n                   noise( p + 8.0*q + vec2(8.3,2.8) ) );\n\n    return noise( p + 8.0*r );\n}\nvec4 Terrain(vec2 uv){\n\n\nfloat f = 0.0;\n   \n       \tuv *= 5.0;\n        mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\t\tf  = 0.5000*noise( uv ); uv = m*uv;\n\t\tf += 0.2500*noise( uv ); uv = m*uv;\n\t\tf += 0.1250*noise( uv ); uv = m*uv;\n\t\tf += 0.0625*noise( uv ); uv = m*uv;\n        \n     \n        \n        \n      vec4 landCol = vec4(\n       sin(f*.75)*.5+.5,\n       sin(f)   *.5+.5,\n       sin(f*.1)*.5+.5,\n       1.);\n       \n       landCol *= vec4(.4 + f,.7+ f,.1,1.);\n       \n       \n       vec4 colorLand = vec4(landCol / pow(f , smoothstep(.2,.21,f)));\n       \n       float c = smoothstep(.1,.4,f);\n      // colorLand = mix(\n       vec4 color = vec4(.05,c,.6,1.) + (f*.5); \n       \n       \n        color = max(color , colorLand);\n       return color -= c;\n       \n       }\n       \n       \n       \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n     vec3 col;\n     vec2 p = fragCoord.xy / iResolution.xy;\n\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0) + iTime * .1;\n\tuv -= (iMouse.xy / iResolution.xy);\n\tvec4 color = Terrain(uv*2.);\n    \n    //atmosphere winds\n    float f = min(\n    noise((uv * 1.5) - iTime * 0.1 ),\n    pattern((uv * 1.) + noise(uv * 2.5) + iTime* .15 )\n    );\n    \n    //clouds\n    f += pattern(uv + iTime * .1);\n    f = max(f * .5,noise(uv  * 10. + iTime)) * color.b;\n    \n    \n    color =max(color, vec4(f));\n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsd3R7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 37, 37, 141], [143, 143, 184, 184, 478], [479, 479, 507, 507, 750], [751, 751, 773, 773, 1517], [1542, 1542, 1599, 1599, 2140]]}
{"id": "fsdGDr", "name": "Fork Snail by Moustave", "author": "Moustave", "description": "haha", "tags": ["procedural", "3d", "raymarching", "distancefield", "sdf", "snail"], "likes": 2, "viewed": 88, "date": "1629581120", "time_retrieved": "2024-06-20T20:47:13.638170", "image_code": "// Created by inigo quilez - iq/2015\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n// You can buy a metal print of this shader here:\n// https://www.redbubble.com/i/metal-print/Snail-by-InigoQuilez/39845499.0JXQP\n\n\n// antialiasing - make AA 2, meaning 4x AA, if you have a fast machine\n#define AA 1\n\n\n#define ZERO (min(iFrame,0))\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( in vec3 p, in vec4 s )\n{\n    return length(p-s.xyz) - s.w;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n    return (length( (p-c)/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 udSegment( vec3 p, vec3 a, vec3 b )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec4 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v =          ( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec4( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z, length(cp.xy), p3.z );\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nvec3 smax( vec3 a, vec3 b, float k )\n{\n    vec3 h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n//---------------------------------------------------------------------------\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\n//---------------------------------------------------------------------------\n\nconst float pi = 3.1415927;\n\n//---------------------------------------------------------------------------\n\nfloat mapShell( in vec3 p, out vec4 matInfo ) \n{\n    p -= vec3(0.05,0.12,-0.09);    \n\n    vec3 q = mat3(-0.6333234236, -0.7332753384, 0.2474039592,\n                   0.7738444477, -0.6034162289, 0.1924931824,\n                   0.0081370606,  0.3133626215, 0.9495986813) * p;\n\n    const float b = 0.1759;\n    \n    float r = length( q.xy );\n    float t = atan( q.y, q.x );\n \n    // https://swiftcoder.wordpress.com/2010/06/21/logarithmic-spiral-distance-field/\n    float np = (log(   r)/b-t)/(2.0*pi);\n    float nm = (log(0.11)/b-t)/(2.0*pi);\n    float n = min(np,nm);\n    \n    float ni = floor( n );\n    \n    float r1 = exp( b * (t + 2.0*pi*ni));\n    float r2 = r1 * 3.019863;\n    \n    //-------\n\n    float h1 = q.z + 1.5*r1 - 0.5; float d1 = sqrt((r1-r)*(r1-r)+h1*h1) - r1;\n    float h2 = q.z + 1.5*r2 - 0.5; float d2 = sqrt((r2-r)*(r2-r)+h2*h2) - r2;\n    \n    float d, dx, dy;\n    if( d1<d2 ) { d = d1; dx=r1-r; dy=h1; }\n    else        { d = d2; dx=r2-r; dy=h2; }\n\n    float di = textureLod( iChannel2, vec2(t+r,0.5), 0. ).x;\n    d += 0.002*di;\n    \n    matInfo = vec4(dx,dy,r/0.4,t/pi);\n\n    vec3 s = q;\n    q = q - vec3(0.34,-0.1,0.03);\n    q.xy = mat2(0.8,0.6,-0.6,0.8)*q.xy;\n    d = smin( d, sdTorus( q, vec2(0.28,0.05) ), 0.06);\n    d = smax( d, -sdEllipsoid(q,vec3(0.0,0.0,0.0),vec3(0.24,0.36,0.24) ), 0.03 );\n    d = smax( d, -sdEllipsoid(s,vec3(0.52,-0.0,0.0),vec3(0.42,0.23,0.5) ), 0.05 );\n    \n    return d;\n}\n\nvec2 mapSnail( vec3 p, out vec4 matInfo )\n{\n    const vec3 head = vec3(-0.76,0.6,-0.3);\n    \n    vec3 q = p - head;\n\n    // body\n    vec4 b1 = sdBezier( vec3(-0.13,-0.65,0.0), vec3(0.24,0.9+0.1,0.0), head+vec3(0.04,0.01,0.0), p );\n    float d1 = b1.x;\n    d1 -= smoothstep(0.0,0.2,b1.y)*(0.16 - 0.07*smoothstep(0.5,1.0,b1.y));\n    b1 = sdBezier( vec3(-0.085,0.0,0.0), vec3(-0.1,0.9-0.05,0.0), head+vec3(0.06,-0.08,0.0), p );\n    float d2 = b1.x;\n    d2 -= 0.1 - 0.06*b1.y;\n    d1 = smin( d1, d2, 0.03 );\n    matInfo.xyz = b1.yzw;\n\n    d2 = sdSphere( q, vec4(0.0,-0.06,0.0,0.085) );\n    d1 = smin( d1, d2, 0.03 );\n    d1 = smin( d1, sdSphere(p,vec4(0.05,0.52,0.0,0.13)), 0.07 );\n    \n    q.xz = mat2(0.8,0.6,-0.6,0.8)*q.xz;\n\n    vec3 sq = vec3( q.xy, abs(q.z) );\n    \n    // top antenas\n    vec3 af = 0.05*sin(0.5*iTime+vec3(0.0,1.0,3.0) + vec3(2.0,1.0,0.0)*sign(q.z) );\n    vec4 b2 = sdBezier( vec3(0.0), vec3(-0.1,0.2,0.2), vec3(-0.3,0.2,0.3)+af, sq );\n    float d3 = b2.x;\n    d3 -= 0.03 - 0.025*b2.y;\n    d1 = smin( d1, d3, 0.04 );\n    d3 = sdSphere( sq, vec4(-0.3,0.2,0.3,0.1016) + vec4(af,0.0) );\n    d1 = smin( d1, d3, 0.01 );    \n    \n    // bottom antenas\n    vec3 bf = 0.02*sin(0.3*iTime+vec3(4.0,1.0,2.0) + vec3(3.0,0.0,1.0)*sign(q.z) );\n    vec2 b3 = udSegment( sq, vec3(0.06,-0.05,0.0), vec3(-0.04,-0.25+0.05*sin(iTime*5.0),0.18)+bf );\n    d3 = b3.x;\n    d3 -= 0.1025 - 0.001*b3.y;\n    d1 = smin( d1, d3, 0.06 );\n    d3 = sdSphere( sq, vec4(-0.04,-0.2,0.18,0.008)+vec4(bf,0.0) );\n    d1 = smin( d1, d3, 0.02 );\n    \n    // bottom\n    vec3 pp = p-vec3(-0.17,0.15,0.0);\n    float co = 0.988771078;\n    float si = 0.149438132;\n    pp.xy = mat2(co,-si,si,co)*pp.xy;\n    d1 = smin( d1, sdEllipsoid( pp, vec3(0.0,0.0,0.0), vec3(0.084,0.3,0.15) ), 0.05 );\n    d1 = smax( d1, -sdEllipsoid( pp, vec3(-0.08,-0.0,0.0), vec3(0.06,0.55,0.1) ), 0.02 );\n    \n    // disp\n    float dis = textureLod( iChannel1, 5.0*p.xy, 0. ).x;\n    float dx = 0.5 + 0.5*(1.0-smoothstep(0.5,1.0,b1.y));\n    d1 -= 0.005*dis*dx*0.5;\n        \n    return vec2(d1,1.0);\n}\n    \nfloat mapDrop( in vec3 p )\n{\n    p -= vec3(-0.826,0.325,-0.302);\n    p.x -= 2.5*p.y*p.y;\n    return sdCapsule( p, vec3(0.0,-0.06,0.0), vec3(0.014,0.06,0.0), 0.037 );\n}\n\n\n\nfloat mapLeaf( in vec3 p )\n{\n    p -= vec3(-1.8,0.6,-0.75);\n    \n    p = mat3(0.671212, 0.366685, -0.644218,\n            -0.479426, 0.877583,  0.000000,\n             0.565354, 0.308854,  0.764842)*p;\n \n    p.y += 0.2*exp2(-abs(2.9*p.z) );\n    \n    float ph = 0.25*50.0*p.x - 0.25*75.0*abs(p.z);\n    float rr = sin( ph );\n    rr = rr*rr;    \n    rr = rr*rr;    \n    p.y += 0.005*rr;\n    \n    float r = clamp((p.x+2.0)/4.0,0.0,1.0);\n    r = 0.0001 + r*(1.0-r)*(1.0-r)*6.0;\n    \n    rr = sin( ph*2.0 );\n    rr = rr*rr;    \n    rr *= 0.5+0.5*sin( p.x*12.0 );\n\n    float ri = 0.035*rr;\n    \n    float d = sdEllipsoid( p, vec3(0.0), vec3(2.0,0.25*r,r+ri) );\n\n    float d2 = p.y-0.02;\n    \n    return smax( d, -d2, 0.02 );\n}\n\nvec2 mapOpaque( vec3 p, out vec4 matInfo )\n{\n    matInfo = vec4(0.0);\n    \n    // leaf    \n    vec2 res = vec2( mapLeaf( p ), 4.0);\n    \n    // stem\n    vec4 b3 = sdBezier( vec3(-0.15,-1.5,0.0), vec3(-0.1,0.5,0.0), vec3(-0.6,1.5,0.0), p );\n    float d3 = b3.x - 0.04 + 0.02*b3.y;\n    if( d3<res.x ) res = vec2(d3,3.0);\n    \n   \t// snail \n    float boundingVolume = sdCapsule(p, vec3(0.0), vec3(-0.6,0.7,0.0), 0.55);\n    if( boundingVolume<res.x )\n    {\n    vec2 tmp = mapSnail( p, matInfo );\n    if( tmp.x<res.x  ) { res = tmp; }\n    \n    // shell\n    float bb = length( p-vec3(0.25,0.3,-0.1) )-0.6;\n    if( bb<res.x )\n    {\n    vec4 tmpMatInfo;\n    float d4 = mapShell( p, tmpMatInfo );    \n    if( d4<res.x  ) { res = vec2(d4,2.0); matInfo = tmpMatInfo; }\n    }\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormalOpaque( in vec3 pos, in float eps )\n{\n    vec4 kk;\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapOpaque( pos + e.xyy, kk ).x + \n\t\t\t\t\t  e.yyx*mapOpaque( pos + e.yyx, kk ).x + \n\t\t\t\t\t  e.yxy*mapOpaque( pos + e.yxy, kk ).x + \n\t\t\t\t\t  e.xxx*mapOpaque( pos + e.xxx, kk ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*mapOpaque(pos+eps*e,kk).x;\n    }\n    return normalize(n);\n#endif    \n}\n\n//=========================================================================\n\nfloat mapLeafWaterDrops( in vec3 p )\n{\n    p -= vec3(-1.8,0.6,-0.75);\n    vec3 s = p;\n    p = mat3(0.671212, 0.366685, -0.644218,\n            -0.479426, 0.877583,  0.000000,\n             0.565354, 0.308854,  0.764842)*p;\n  \n    vec3 q = p;\n    p.y += 0.2*exp(-abs(2.0*p.z) );\n    \n    float r = clamp((p.x+2.0)/4.0,0.0,1.0);\n    r = r*(1.0-r)*(1.0-r)*6.0;\n    float d1 = sdEllipsoid( q, vec3(0.5,0.0,0.2), 1.0*vec3(0.15,0.13,0.15) );\n    float d2 = sdEllipsoid( q, vec3(0.8,-0.07,-0.15), 0.5*vec3(0.15,0.13,0.15) );\n    float d3 = sdEllipsoid( s, vec3(0.76,-0.8,0.6), 0.5*vec3(0.15,0.2,0.15) );\n    float d4 = sdEllipsoid( q, vec3(-0.5,0.09,-0.2), vec3(0.04,0.03,0.04) );\n\n    d3 = max( d3, p.y-0.01);\n    \n    return min( min(d1,d4), min(d2,d3) );\n}\n\nvec2 mapTransparent( vec3 p, out vec4 matInfo )\n{\n    matInfo = vec4(0.0);\n    \n    float d5 = mapDrop( p );\n    vec2  res = vec2(d5,4.0);\n\n\n\n    float d6 = mapLeafWaterDrops( p );\n    res.x = min( res.x, d6 );\n\n    return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormalTransparent( in vec3 pos, in float eps )\n{\n    vec4 kk;\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapTransparent( pos + e.xyy, kk ).x + \n\t\t\t\t\t  e.yyx*mapTransparent( pos + e.yyx, kk ).x + \n\t\t\t\t\t  e.yxy*mapTransparent( pos + e.yxy, kk ).x + \n\t\t\t\t\t  e.xxx*mapTransparent( pos + e.xxx, kk ).x );\n}\n\n//=========================================================================\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    vec4 kk;\n\tfloat ao = 0.0;\n    for( int i=ZERO; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n        float h = hash1(float(i));\n\t\tap *= sign( dot(ap,nor) ) * h*0.1;\n        ao += clamp( mapOpaque( pos + nor*0.01 + ap, kk ).x*3.0, 0.0, 1.0 );\n    }\n\tao /= 32.0;\n\t\n    return clamp( ao*6.0, 0.0, 1.0 );\n}\n\nfloat calcSSS( in vec3 pos, in vec3 nor )\n{\n    vec4 kk;\n\tfloat occ = 0.0;\n    for( int i=ZERO; i<8; i++ )\n    {\n        float h = 0.002 + 0.11*float(i)/7.0;\n        vec3 dir = normalize( sin( float(i)*13.0 + vec3(0.0,2.1,4.2) ) );\n        dir *= sign(dot(dir,nor));\n        occ += (h-mapOpaque(pos-h*dir, kk).x);\n    }\n    occ = clamp( 1.0 - 11.0*occ/8.0, 0.0, 1.0 );    \n    return occ*occ;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow( in vec3 ro, in vec3 rd, float k )\n{\n    vec4 kk;    \n    float res = 1.0;\n    float t = 0.01;\n    for( int i=ZERO; i<32; i++ )\n    {\n        float h = mapOpaque(ro + rd*t, kk ).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n        t += clamp( h, 0.04, 0.1 );\n\t\tif( res<0.01 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nconst vec3 sunDir = normalize( vec3(0.2,0.1,0.02) );\n\nvec3 shadeOpaque( in vec3 ro, in vec3 rd, in float t, in float m, in vec4 matInfo )\n{\n    float eps = 0.002;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormalOpaque( pos, eps );\n\n    vec3 mateD = vec3(0.0);\n    vec3 mateS = vec3(0.0);\n    vec2 mateK = vec2(0.0);\n    vec3 mateE = vec3(0.0);\n\n    float focc = 1.0;\n    float fsha = 1.0;\n\n    if( m<1.5 ) // snail body\n    {\n        float dis = texture( iChannel1, 5.0*pos.xy ).x;\n\n        float be = sdEllipsoid( pos, vec3(-0.3,-0.5,-0.1), vec3(0.2,1.0,0.5) );\n        be = 1.0-smoothstep( -0.01, 0.01, be );        \n        \n        float ff = abs(matInfo.x-0.20);\n        \n        mateS = 6.0*mix( 0.7*vec3(2.0,1.2,0.2), vec3(2.5,1.8,0.9), ff );\n        mateS += 2.0*dis;\n        mateS *= 1.5;\n        mateS *= 1.0 + 0.5*ff*ff;\n        mateS *= 1.0-0.5*be;\n        \n        mateD = vec3(1.0,0.8,0.4);\n        mateD *= dis;\n        mateD *= 0.015;\n        mateD += vec3(0.8,0.4,0.3)*0.15*be;\n        \n        mateK = vec2( 60.0, 0.7 + 2.0*dis );\n        \n        float f = clamp( dot( -rd, nor ), 0.0, 1.0 );\n        f = 1.0-pow( f, 8.0 );\n        f = 1.0 - (1.0-f)*(1.0-texture( iChannel2, 0.3*pos.xy ).x);\n        mateS *= vec3(0.5,0.1,0.0) + f*vec3(0.5,0.9,1.0);\n        \n        float b = 1.0-smoothstep( 0.25,0.55,abs(pos.y));\n        focc = 0.2 + 0.8*smoothstep( 0.0, 0.15, sdSphere(pos,vec4(0.05,0.52,0.0,0.13)) );\n    }\n\telse if( m<2.5 ) // shell\n    {\n        mateK = vec2(0.0);\n        \n        float tip = 1.0-smoothstep(0.05,0.4, length(pos-vec3(0.17,0.2,0.35)) );\n        mateD = mix( 0.7*vec3(0.2,0.21,0.22), 0.2*vec3(0.15,0.1,0.0), tip );\n        \n        vec2 uv = vec2( .5*atan(matInfo.x,matInfo.y)/3.1416, 1.5*matInfo.w );\n        \n        vec3 ral = texture( iChannel1, vec2(2.0*matInfo.w+matInfo.z*0.5,0.5) ).xxx;\n        mateD *= 0.25 + 0.75*ral;\n        \n        float pa = smoothstep(-0.2,0.2, 0.3+sin(2.0+40.0*uv.x + 3.0*sin(11.0*uv.x)) );\n        float bar = mix(pa,1.0,smoothstep(0.7,1.0,tip));\n        bar *= (matInfo.z<0.6) ? 1.0 : smoothstep( 0.17, 0.21, abs(matInfo.w)  );\n        mateD *= vec3(0.06,0.03,0.0)+vec3(0.94,0.97,1.0)*bar;\n        \n        mateK = vec2( 64.0, 0.2 );\n        mateS = 1.5*vec3(1.0,0.65,0.6) * (1.0-tip);//*0.5;\n    }\n    else if( m<3.5 ) // plant\n    {\n        mateD = vec3(0.05,0.1,0.0)*0.2;\n        mateS = vec3(0.1,0.2,0.02)*25.0;\n        mateK = vec2(5.0,1.0);\n        \n        float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n        mateD += 0.2*fre*vec3(1.0,0.5,0.1);\n        \n        vec3 te = texture( iChannel2, pos.xy*0.2 ).xyz;\n        mateS *= 0.5 + 1.5*te;\n        mateE = 0.5*vec3(0.1,0.1,0.03)*(0.2+0.8*te.x);\n    }\n    else //if( m<4.5 ) // leaf\n    {\n        vec3 p = pos - vec3(-1.8,0.6,-0.75);\n        vec3 s = p;\n        p = mat3(0.671212, 0.366685, -0.644218,\n                -0.479426, 0.877583,  0.000000,\n                 0.565354, 0.308854,  0.764842)*p;\n\n        vec3 q = p;\n        p.y += 0.2*exp(-abs(2.0*p.z) );\n\n        float v = smoothstep( 0.01, 0.02, abs(p.z));\n        \n        float rr = sin( 4.0*0.25*50.0*p.x - 4.0*0.25*75.0*abs(p.z) );\n\n        vec3 te = texture( iChannel2, p.xz*0.35 ).xyz;\n\n        float r = clamp((p.x+2.0)/4.0,0.0,1.0);\n        r = r*(1.0-r)*(1.0-r)*6.0;\n        float ff = length(p.xz/vec2(2.0,r));\n\n        mateD = mix( vec3(0.07,0.1,0.0), vec3(0.05,0.2,0.01)*0.25, v );\n        mateD = mix( mateD, vec3(0.16,0.2,0.01)*0.25, ff );\n        mateD *= 1.0 + 0.25*te;\n        mateD *= 0.8;\n        \n        mateS = vec3(0.15,0.2,0.02)*0.8;\n        mateS *= 1.0 + 0.2*rr;\n        mateS *= 0.8;\n\n        mateK = vec2(64.0,0.25);\n        \n        //---------------------\n        \n        nor.xz += v*0.15*(-1.0+2.0*texture( iChannel3, 1.0*p.xz ).xy);\n        nor = normalize( nor );\n\n        float d1 = sdEllipsoid( q, vec3( 0.5-0.07, 0.0,  0.20), 1.0*vec3(1.4*0.15,0.13,0.15) );\n        float d2 = sdEllipsoid( q, vec3( 0.8-0.05,-0.07,-0.15), 0.5*vec3(1.3*0.15,0.13,0.15) );\n        float d4 = sdEllipsoid( q, vec3(-0.5-0.07, 0.09,-0.20), 1.0*vec3(1.4*0.04,0.03,0.04) );\n        float dd = min(d1,min(d2,d4));\n        fsha = 0.05 + 0.95*smoothstep(0.0,0.05,dd);\n        \n        d1 = abs( sdCircle( q.xz, vec2( 0.5, 0.20), 1.0*0.15 ));\n        d2 = abs( sdCircle( q.xz, vec2( 0.8,-0.15), 0.5*0.15 ));\n        d4 = abs( sdCircle( q.xz, vec2(-0.5,-0.20), 1.0*0.04 ));\n        dd = min(d1,min(d2,d4));\n        focc *= 0.55 + 0.45*smoothstep(0.0,0.08,dd);\n        \n        d1 = distance( q.xz, vec2( 0.5-0.07, 0.20) );\n        d2 = distance( q.xz, vec2( 0.8-0.03,-0.15) );\n        fsha += (1.0-smoothstep(0.0,0.10,d1))*1.5;\n        fsha += (1.0-smoothstep(0.0,0.05,d2))*1.5;    \n    }\n  \n    vec3 hal = normalize( sunDir-rd );\n    float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n    float occ = calcAO( pos, nor )*focc;\n    float sss = calcSSS( pos, nor );\n    sss = sss*occ + fre*occ + (0.5+0.5*fre)*pow(abs(matInfo.x-0.2),1.0)*occ;\n    \n    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );\n    dif1 *= fsha;\n    float sha = 1.0; if( dif1>0.0001 ) sha=calcSoftShadow( pos, sunDir, 20.0 ); \n    dif1 *= sha;\n    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );\n\n    float bou = clamp( 0.3-0.7*nor.y, 0.0, 1.0 );\n\n    // illumination\n    vec3 col = vec3(0.0);\n    col += 7.0*vec3(1.7,1.2,0.6)*dif1*2.0;               // sun\n    col += 4.0*vec3(0.2,1.2,1.6)*occ*(0.5+0.5*nor.y);    // sky\n    col += 1.8*vec3(0.1,2.0,0.1)*bou*occ;                // bounce\n\n    col *= mateD;\n\n    col += 0.4*sss*(vec3(0.15,0.1,0.05)+vec3(0.85,0.9,0.95)*dif1)*(0.05+0.95*occ)*mateS; // sss\n    col = pow(col,vec3(0.6,0.8,1.0));\n    \n    col += vec3(1.0,1.0,1.0)*0.2*pow( spe1, 1.0+mateK.x )*dif1*(0.04+0.96*pow(fre,4.0))*mateK.x*mateK.y;   // sun lobe1\n    col += vec3(1.0,1.0,1.0)*0.1*pow( spe1, 1.0+mateK.x/3.0 )*dif1*(0.1+0.9*pow(fre,4.0))*mateK.x*mateK.y; // sun lobe2\n\tcol += 0.1*vec3(1.0,max(1.5-0.7*col.y,0.0),2.0)*occ*occ*smoothstep( 0.0, 0.3, reflect( rd, nor ).y )*mateK.x*mateK.y*(0.04+0.96*pow(fre,5.0)); // sky\n\n    col += mateE;\n\n    return col;        \n}\n\nvec3 shadeTransparent( in vec3 ro, in vec3 rd, in float t, in float m, in vec4 matInfo, in vec3 col, in float depth )\n{\n    vec3 oriCol = col;\n    \n    float dz = depth - t;\n    float ao = clamp(dz*50.0,0.0,1.0);\n    vec3  pos = ro + t*rd;\n    vec3  nor = calcNormalTransparent( pos, 0.002 );\n    float fre = clamp( 1.0 + dot( rd, nor ), 0.0, 1.0 );\n    vec3  hal = normalize( sunDir-rd );\n    vec3  ref = reflect( -rd, nor );\n    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );\n    float spe2 = clamp( dot(ref,sunDir), 0.0, 1.0 );\n\n    float ds = 1.6 - col.y;\n    \n    col *= mix( vec3(0.0,0.0,0.0), vec3(0.4,0.6,0.4), ao );\n\n    col += ds*1.5*vec3(1.0,0.9,0.8)*pow( spe1, 80.0 );\n    col += ds*0.2*vec3(0.9,1.0,1.0)*smoothstep(0.4,0.8,fre);\n    col += ds*0.9*vec3(0.6,0.7,1.0)*smoothstep( -0.5, 0.5, -reflect( rd, nor ).y )*smoothstep(0.2,0.4,fre);    \n    col += ds*0.5*vec3(1.0,0.9,0.8)*pow( spe2, 80.0 );\n    col += ds*0.5*vec3(1.0,0.9,0.8)*pow( spe2, 16.0 );\n    col += vec3(0.8,1.0,0.8)*0.5*smoothstep(0.3,0.6,texture( iChannel1, 0.8*nor.xy ).x)*(0.1+0.9*fre*fre);\n    \n    // hide aliasing a bit\n    return mix( col, oriCol, smoothstep(0.6,1.0,fre) ); \n}\n\n//--------------------------------------------\n\nvec2 intersectOpaque( in vec3 ro, in vec3 rd, const float mindist, const float maxdist, out vec4 matInfo )\n{\n    vec2 res = vec2(-1.0);\n    \n    float t = mindist;\n    for( int i=ZERO; i<128; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = mapOpaque( p, matInfo );\n        res = vec2(t,h.y);\n\n        if( h.x<(0.001*t) ||  t>maxdist ) break;\n        \n        t += h.x*0.9;\n    }\n\treturn res;\n}\n\nvec2 intersectTransparent( in vec3 ro, in vec3 rd, const float mindist, const float maxdist, out vec4 matInfo )\n{\n    vec2 res = vec2(-1.0);\n    \n    float t = mindist;\n    for( int i=ZERO; i<64; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = mapTransparent( p, matInfo );\n        res = vec2(t,h.y);\n\n        if( h.x<(0.001*t) ||  t>maxdist ) break;\n        \n        t += h.x;\n    }\n\treturn res;\n}\n\nvec3 background( in vec3 d )\n{\n    // cheap cubemap\n    vec3 n = abs(d);\n    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz/d.x: \n              (n.y>n.x && n.y>n.z) ? d.zx/d.y:\n                                     d.xy/d.z;\n    // fancy blur\n    vec3  col = vec3( 0.0 );\n    for( int i=ZERO; i<200; i++ )\n    {\n        float h = float(i)/200.0;\n        float an = 31.0*6.2831*h;\n        vec2  of = vec2( cos(an), sin(an) ) * h;\n\n        vec3 tmp = texture( iChannel2, uv*0.25 + 0.0075*of, 4.0 ).yxz;\n        col = smax( col, tmp, 0.5 );\n    }\n    \n    return pow(col,vec3(3.5,3.0,6.0))*0.2;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 q )\n{\n    //-----------------------------\n\n    vec3 col = background( rd );\n    \n    //-----------------------------\n    \n    float mindist = 1.0;\n    float maxdist = 4.0;\n\n    vec4 matInfo;\n    vec2 tm = intersectOpaque( ro, rd, mindist, maxdist, matInfo );\n    if( tm.y>-0.5 && tm.x < maxdist )\n    {\n        col = shadeOpaque( ro, rd, tm.x, tm.y, matInfo );\n        maxdist = tm.x;\n    }\n\n    //-----------------------------\n    \n    tm = intersectTransparent( ro, rd, mindist, maxdist, matInfo );\n    if( tm.y>-0.5 && tm.x < maxdist )\n    {\n        col = shadeTransparent( ro, rd, tm.x, tm.y, matInfo, col, maxdist );\n    }\n\n    //-----------------------------\n    \n    float sun = clamp(dot(rd,sunDir),0.0,1.0);\n    col += 1.0*vec3(1.5,0.8,0.7)*pow(sun,4.0);\n\n    //-----------------------------\n\n    col = pow( col, vec3(0.45) );\n    \n    col = vec3(1.05,1.0,1.0)*col*(0.7+0.3*col*max(3.0-2.0*col,0.0)) + vec3(0.0,0.0,0.04);\n\n    col *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n\n    return clamp( col, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt )\n{\n    vec3 w = normalize(ro-rt);\n    float m = sqrt(1.0-w.y*w.y);\n    return mat3( w.z,     0.0, -w.x, \n                 0.0,     m*m, -w.z*w.y,\n                 w.x*m, w.y*m,  w.z*m );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    #if AA<2\n        vec2  p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        vec2  q = fragCoord/iResolution.xy;\n        float an = 1.87 - 0.04*(1.0-cos(0.5*iTime));\n\n        vec3  ro = vec3(-0.4,0.2,0.0) + 2.2*vec3(cos(an),0.0,sin(an));\n        vec3  ta = vec3(-0.6,0.2,0.0);\n        mat3  ca = setCamera( ro, ta );\n        vec3  rd = normalize( ca * vec3(p,-2.8) );\n\n        vec3 col = render( ro, rd, q );\n    #else\n        vec3 col = vec3(0.0);\n        for( int m=ZERO; m<AA; m++ )\n        for( int n=ZERO; n<AA; n++ )\n        {\n            vec2 rr = vec2(float(m),float(n))/float(AA);\n\n            vec2 p = (2.0*(fragCoord+rr)-iResolution.xy)/iResolution.y;\n            float an = 1.87 - 0.04*(1.0-cos(0.5*iTime));\n            vec2 q = (fragCoord+rr)/iResolution.xy;\n\n            vec3 ro = vec3(-0.4,0.2,0.0) + 2.2*vec3(cos(an),0.0,sin(an));\n            vec3 ta = vec3(-0.6,0.2,0.0);\n            mat3 ca = setCamera( ro, ta );\n            vec3 rd = normalize( ca * vec3(p,-2.8) );\n\n\t\t    col += render( ro, rd, q );\n        }    \n        col /= float(AA*AA);\n    #endif\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "proprietary-license", "thumbnail": "https://www.shadertoy.com/media/shaders/fsdGDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[843, 917, 957, 957, 993], [995, 1069, 1123, 1123, 1187], [1189, 1263, 1315, 1315, 1345], [1347, 1421, 1454, 1454, 1509], [1511, 1585, 1637, 1637, 1751], [1753, 1827, 1869, 1869, 1990], [1992, 2056, 2085, 2085, 2111], [2112, 2112, 2159, 2159, 2637], [2639, 2639, 2688, 2688, 3098], [3100, 3152, 3193, 3193, 3265], [3267, 3319, 3360, 3360, 3432], [3434, 3486, 3524, 3524, 3595], [3597, 3676, 3700, 3700, 3742], [3744, 3744, 3780, 3780, 4044], [4154, 4233, 4281, 4281, 5656], [5658, 5658, 5701, 5701, 7703], [7709, 7709, 7737, 7737, 7876], [7880, 7880, 7908, 7908, 8597], [8599, 8599, 8643, 8643, 9391], [9393, 9457, 9509, 9509, 10096], [10098, 10175, 10213, 10213, 10925], [10927, 10927, 10976, 10976, 11156], [11158, 11222, 11279, 11279, 11557], [11559, 11636, 11678, 11678, 12004], [12006, 12006, 12049, 12049, 12400], [12402, 12464, 12521, 12521, 12817], [12873, 12873, 12958, 12958, 18881], [18883, 18883, 19002, 19002, 20043], [20045, 20093, 20201, 20201, 20495], [20497, 20497, 20610, 20610, 20904], [20906, 20906, 20936, 20957, 21489], [21491, 21491, 21541, 21577, 22569], [22571, 22571, 22613, 22613, 22799], [22801, 22801, 22858, 22858, 23979]]}
{"id": "fsdGR4", "name": "Polar Texture Disk Intersection ", "author": "Yusef28", "description": "For just a disk intersection you can check this out: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection\nor this https://www.shadertoy.com/view/lsfGDB\n\n", "tags": ["triangle", "intersection", "barycentric"], "likes": 3, "viewed": 37, "date": "1629256630", "time_retrieved": "2024-06-20T20:47:15.165674", "image_code": "/////////////////////////////////////////////////////////////\n//                                                         //\n// Author:Yusef28                                          //\n// Start Date: 17-08-2021                                  //\n// Status: On-going                                        //\n// Topic: Disk Intersection + Text                         //\n// Sources:https: www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection\n// Listening to:Best post-rock songs of 2020               //\n//                                                         // \n/////////////////////////////////////////////////////////////\n\n\n#define Samples 20.\n#define bounces 1.\n\n#define pi 3.14159\n\n\nfloat iPlane(vec3 ro, vec3 rd, vec3 n, vec3 pop){\n\n    //first of all, if the dot of the rd and n is ... nvm\n    //if(dot(rd,n) > 0.9999) return -1.;\n    //dot(vector in plane with normal) = zero (orthogonal)\n    //(p-pointinplane)*n = 0\n    \n    //ray origin + rd at time t is point\n    //p = ro + rd*t;\n    \n    //what time t is p from eq 1 = p in eq 2\n    //(ro + rd*t - pointinplane)*n = 0\n    \n    //rearange to get some time alone\n    //float t = (dot(pop,n) - dot(ro,n)) / dot(rd,n);\n    \n    //we can do better than that, factor out n from top \n    return dot(pop-ro,n) / dot(rd,n);\n}\n\n/*\n\n//First try based on the triangle intersection and barycentric\n//coordinates\nvec3 iDisk(vec3 ro,vec3 rd,vec3 A,vec3 B,vec3 Center){\n\n    float t;\n    vec2 uv;\n    \n    //if there isn't a hit we give backa  t of -1., \n    //and a u and v of 0.,0.\n    \n    vec3 no_hit = vec3(-1.,0.,0.);\n    \n    //imagine a triagle with 3 points.\n    //the vector from point a to b\n    vec3 AzuB = normalize(B-A);\n    \n    //from point b to c\n    vec3 BzuC = normalize(Center-B);\n    \n    //usw\n    vec3 CzuA = normalize(A-Center);\n    \n    \n    //we use the cross of two of the above vectors\n    //to get a vector perpendicular to both\n    //any two of these holds all three points (a,b,and c)\n    //so the normal of them is the normal of the plane all three\n    //points lie in\n    vec3 planeN = cross(AzuB,BzuC);\n    \n    //so we find the intersection of that plane\n    t = iPlane(ro,rd,planeN,A);\n    \n    //and get the hit point\n    vec3 point_on_plane = ro + rd*t;\n    \n    //and return no hit if the t negative meaning it's behind us\n    if(t < 0.)\n        return no_hit;\n\n    // most of this code is from the triangle intersection\n    //and barycentric coordinates\n    //I am just modifying to hit whenever the distance to our\n    //specified disk cetner is less than 2.\n    float lange = length(point_on_plane-Center);\n    if( lange > 2.)\n        return no_hit;\n    \n    //another mod from the barycentric coordinates\n    //I just use the same two coordinates which are now\n    //the x and y on the plane oriented by the normal\n    float x = dot(planeN, cross(BzuC, point_on_plane-B ) );\n    float y = dot(planeN, cross(CzuA, point_on_plane-Center ) );\n    \n    //this is the usual way to get polar coordinates \n    float u = atan(y,x);\n    float v = lange;\n    \n\n    return vec3(t,u,v);\n}\n\n*/\n\n//second try since the first one didn't allow me to make\n//usable texture coordinates\n//Here I create a basis (3 orthogonal vectors)\n//based on the plane normal\n//then I get the vector from center to hit point(call it CP)\n//then I take the dot(CP,basisUP) as y\n//and dot(CP,basisRIGHT) as x\n//then convert to polar and return.\n//I think the first method might actually be ok\n//now looking at it again. The main issue is in main heh\n// in  main I rotate the normal and center. I have to \n//rotate them by the same amount on the same axis\n//or else I get the same issue as in the first try.\nvec3 iDisk2(vec3 ro, vec3 rd, vec3 normal, vec3 Center){\n\n    float t;\n    vec2 uv;\n    \n    //if there isn't a hit we give backa  t of -1., \n    //and a u and v of 0.,0.\n    \n    vec3 no_hit = vec3(-1.,0.,0.);\n    \n    //trying something like this\n    //https://www.shadertoy.com/view/4tySz1\n    //I think the idea is creating a basis from the normal\n    //and then projecting the vector form centerto hit point\n    //onto the right and up of that basis.\n    //to get coordinates I mean\n    \n    vec3 uu = vec3(0.,1.,0.); \n    vec3 right = cross(normal,uu);\n    vec3 up = cross(right,normal);\n    \n    //we use the cross of two of the above vectors\n    //to get a vector perpendicular to both\n    //any two of these holds all three points (a,b,and c)\n    //so the normal of them is the normal of the plane all three\n    //points lie in\n    \n    //so we find the intersection of that plane\n    t = iPlane(ro,rd,normal,right);\n    \n    //and get the hit point\n    vec3 point_on_plane = ro + rd*t;\n    vec3 center_to_hit = point_on_plane - Center;\n    \n    //and return no hit if the t negative meaning it's behind us\n    if(t < 0.)\n        return no_hit;\n\n    // most of this code is from the triangle intersection\n    //and barycentric coordinates\n    //I am just modifying to hit whenever the distance to our\n    //specified disk cetner is less than 2.\n    float lange = length(point_on_plane-Center);\n    if( lange > 2.)\n        return no_hit;\n    \n    //another mod from the barycentric coordinates\n    //I just use the same two coordinates which are now\n    //the x and y on the plane oriented by the normal\n    float x = dot(up,normalize(center_to_hit));\n    float y = dot(right,normalize(center_to_hit));\n    \n    //this is the usual way to get polar coordinates \n    float u = atan(y,x);\n    float v = lange;\n    return vec3(t,u,v);\n}\n\nfloat checker(vec2 st){\n    return mod(floor(st.x)+floor(st.y),2.);\n}\n\nmat2 rot(float a){\n    float si = sin(a);\n    float cs = cos(a);\n    \n    return mat2(cs,-si,si,cs);\n}\n\nvec3 grid_design(vec2 uv){\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////      BACKGROUND GRID DESIG          //\n      //                                   //\n      /////////////////////////////////////\n      \n      \n    vec2 st = uv;//save the unscaled uv\n    //I'm only making an 8(*aspect)x8 grid, higher variables\n    //may end up with graphs completely outside it\n    uv*=8.;\n    \n    //graph background\n    vec3 col = vec3(0.1);\n    \n    //center highlights\n    col = mix(col,vec3(0.16),1.0-length(uv/8.));\n    \n    //dust \n    float specks = fract(sin(dot(uv,vec2(123.,16.)))*433413.);\n    \n    //nice soft texture \n    float tex = texture(iChannel0,st).x;\n    col = mix(col,vec3(0.25),pow(tex,2.));\n    \n    //small grid lines\n    vec2 lines = fract(uv*5.);\n    lines = smoothstep(0.45,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.24),lines.x);\n    col = mix(col,vec3(0.24),lines.y);\n    \n    //larger grid lines\n    lines = fract(uv);\n    lines = smoothstep(0.47,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.5),lines.x);\n    col = mix(col,vec3(0.5),lines.y);\n    \n    //axis lines\n    lines = smoothstep(0.0,0.02,abs(uv));\n    col = mix(col,vec3(0.6),1.0-lines.x);\n    col = mix(col,vec3(0.6),1.-lines.y);\n    col = mix(col,vec3(0.1),step(0.1,specks)*0.2);\n    \n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec3 col = vec3(1.);\n    float a = iTime/4.;\n    vec3 ro = vec3(6.*cos(a), 0., 6.*sin(a));\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 fwd = normalize(ta - ro);\n    vec3 uu = vec3(0., -1., 0.);\n    \n    vec3 right = normalize(cross(uu,fwd));\n    vec3 up = normalize(cross(right,fwd));\n    \n    float focal = 1.52;\n    \n    vec3 rd = right*uv.x + up*uv.y + fwd*focal;\n    \n    vec3 planeN = vec3(0., 1., 0.);\n    vec3 point_on_plane = vec3(0., -1., 0.);\n    \n    float t = iPlane(ro, rd, planeN, point_on_plane);\n    \n    if(t >= 0.){\n        vec3 pos = ro + rd*t;\n        col = grid_design(pos.xz/10.5);\n    }\n    \n    vec3 cPos = vec3(0., 0., 0.);\n    float r = 1.;\n    \n    vec3 A = vec3(-1.,1.,0.);\n    A.xy*=rot(iTime);\n    //vec3 B = vec3(1.,0.,0.);\n    //B.zx*=rot(iTime);\n    vec3 Center = vec3(0.,2.,0.);\n    Center.xy*=rot(iTime);\n    //vec3 t_and_uv = iDisk(ro,rd,A,B,Center);\n    \n    \n    vec3 t_and_uv = iDisk2(ro,rd,A,Center);\n    \n    if(t_and_uv.x >= 0.){\n            \n        vec3 tex = texture(iChannel0, t_and_uv.yz).xyz;\n        col = tex;\n        \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsdGR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 768, 817, 1320, 1360], [3153, 3742, 3798, 3798, 5583], [5585, 5585, 5608, 5608, 5654], [5656, 5656, 5674, 5674, 5758], [5760, 5760, 5786, 6030, 7120], [7121, 7121, 7178, 7228, 8420]]}
{"id": "fsdGzj", "name": "Circles Circles", "author": "trigophers", "description": "Whatever", "tags": ["who"], "likes": 1, "viewed": 65, "date": "1630213477", "time_retrieved": "2024-06-20T20:47:15.165674", "image_code": "bool hit = false;\nvec3 color = vec3(0.);\n\nvoid circle(float x, float y, float r, vec2 fragCoord, vec3 c) {\n    if (!hit) {\n        if (distance(vec2(x, y), fragCoord) <= r) {\n            hit = true;\n            color = c;\n        }\n    }\n}\n\nvoid scene(vec2 fragCoord) {\n    for (float woof = 0.; woof/98. < 6.; woof+=98.) {\n        for (float meow = 0.; meow/98. < 10.; meow+=98.) {\n            circle(meow, woof, (sin(iTime-fragCoord.x/iResolution.x*3.)+1.)*5.-2., fragCoord, vec3(0, 0, 0));\n            circle(meow, woof, (sin(iTime-fragCoord.x/iResolution.x*3.)+1.)*5., fragCoord, vec3((sin(fragCoord/iResolution.xy+iTime)+1.)/2., 0.5));\n            circle(meow, woof, (sin(iTime-fragCoord.x/iResolution.x*3.)+1.)*25.-2., fragCoord, vec3(0, 0, 0));\n            circle(meow, woof, (sin(iTime-fragCoord.x/iResolution.x*3.)+1.)*25., fragCoord, vec3((sin(fragCoord/iResolution.xy+iTime)+1.)/2., 0.5));\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    scene(fragCoord);\n    fragColor = vec4(hit?color:vec3(0.), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsdGzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[42, 42, 106, 106, 239], [241, 241, 269, 269, 918], [920, 920, 977, 977, 1048]]}
{"id": "fst3R2", "name": "project stochastics round 2", "author": "Dusty", "description": "noise everywhere!", "tags": ["experiment"], "likes": 0, "viewed": 33, "date": "1630230827", "time_retrieved": "2024-06-20T20:47:15.802005", "image_code": "// ---------------------------------------------------------------------------\n// project stochastics round 2\n//\n// continuing goal: \n//\n//   approximate an ideal noise function,\n//   that reveals no visual correlations,\n//   when sampled at regular intervals,\n//   everywhere!\n//\n//   efficiency is still of only secondary consideration\n//\n//   diving in and generalizing now\n//   almost to the point of an actual noise() function\n//\n// NOTES\n//\n//   lehmer()     known as lehmer hash, or lehmer cipher, or lehmer rng\n//\n//       the analogy I like to use is that it can be viewed as a function of a \n// _pile_shuffle_ of a very large (4 billion cards) abstract deck of cards .. \n//\n//                it answers the question:\n//                  where does the card that was in position #h go after \n//                  doing this pile shuffle once?\n//\n//  it is both good and bad that lehmer() is a simple singular multiplication \n//  by an odd constant with good properties\n//\n//  the good is that it is efficient\n//  the bad is that bitwise information only propagates \"upwards\"\n// \n//  lox() is a 2-operation shuffle that bitwise propagates \"downwards\"\n//\n//  note that all bijective transforms of a machine word can be viewed as some kind\n//  of shuffling - its shuffling all the way down - addition is a cut of the deck - \n//  multiplication is a pile shuffle - bitwise rolling is a faro shuffle!\n// ---------------------------------------------------------------------------\n// lehmer shuffle (bijective) propgates information towards the MSBs\n\nuint LEHMER(uint h)   { return 0xCC2BFE9Du * h; }\nuvec2 LEHMER(uvec2 h) { return 0xCC2BFE9Du * h; } \nuvec3 LEHMER(uvec3 h) { return 0xCC2BFE9Du * h; }\nuvec4 LEHMER(uvec4 h) { return 0xCC2BFE9Du * h; }\n\n// ---------------------------------------------------------------------------\n// XOR shuffle (bijective) propgates information towards the LSBs\n\nuint LOX(uint h)        { return h ^ (h >> 16); }\nuvec2 LOX(uvec2 h)      { return h ^ (h >> 16); }\nuvec3 LOX(uvec3 h)      { return h ^ (h >> 16); }\nuvec4 LOX(uvec4 h)      { return h ^ (h >> 16); }\n\n// ---------------------------------------------------------------------------\n// key handling - the keys themselves could get a minor preshuffle (bijective)\n\nuint KEYBITS(float k) {return floatBitsToUint(k);} //{ return LOX(LEHMER(floatBitsToUint(k))); }\nuvec2 KEYBITS(vec2 k) {return floatBitsToUint(k);} //{ return LOX(LEHMER(floatBitsToUint(k))); }\nuvec3 KEYBITS(vec3 k) {return floatBitsToUint(k);} //{ return LOX(LEHMER(floatBitsToUint(k))); }\nuvec4 KEYBITS(vec4 k) {return floatBitsToUint(k);} //{ return LOX(LEHMER(floatBitsToUint(k))); }\n\n// ---------------------------------------------------------------------------\n// interprets as uniformly distributed in the range 0.0 <= x < 1.0, loses 8-bits\n\nfloat UNIFORM(uint h) { return float(h & 0xffffffu) * (1.0 / float(0x1000000)); }\nvec2 UNIFORM(uvec2 h) { return vec2(h & 0xffffffu) * (1.0 / float(0x1000000)); }\nvec3 UNIFORM(uvec3 h) { return vec3(h & 0xffffffu) * (1.0 / float(0x1000000)); }\nvec4 UNIFORM(uvec4 h) { return vec4(h & 0xffffffu) * (1.0 / float(0x1000000)); }\n\n// ---------------------------------------------------------------------------\n// sufficient decorrelation is called a hash here, yet it too is a shuffle\n\nuint HASH(uint h, vec2 key)\n{ uvec2 k = KEYBITS(key);\n  h = LOX(LEHMER(h + k.x)); // cut-shuffle-shuffle\n  h = LOX(LEHMER(h + k.y)); // cut-shuffle-shuffle\n  return LEHMER(LOX(LEHMER(h))); // shuffle-shuffle-shuffle\n}\n\nuvec2 HASH(uvec2 h, vec2 key)\n{ uvec2 k = KEYBITS(key);\n  h = LOX(LEHMER(h + k.x));\n  h = LOX(LEHMER(h + k.y));\n  return LEHMER(LOX(LEHMER(h)));\n}\n\nuvec3 HASH(uvec3 h, vec2 key)\n{ uvec2 k = KEYBITS(key);\n  h = LOX(LEHMER(h + k.x));\n  h = LOX(LEHMER(h + k.y));\n  return LEHMER(LOX(LEHMER(h)));\n}\n\nuvec4 HASH(uvec4 h, vec2 key)\n{ uvec2 k = KEYBITS(key);\n  h = LOX(LEHMER(h + k.x));\n  h = LOX(LEHMER(h + k.y));\n  return LEHMER(LOX(LEHMER(h)));\n}\n\n// handy\n\nuint  HASH1(vec2 key) { return HASH(2u, key); }\nuvec2 HASH2(vec2 key) { return HASH(uvec2(3u, 5u), key); }\nuvec3 HASH3(vec2 key) { return HASH(uvec3(7u, 11u, 13u), key); }\nuvec4 HASH4(vec2 key) { return HASH(uvec4(17u, 19u, 23u, 29u), key); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = floor(fragCoord + 100.0 * vec2(cos(0.1 * sqrt(iTime)), sin(0.1 * sqrt(iTime))) * iTime);\n    vec3 c = UNIFORM(HASH3(p));\n    fragColor = vec4(c*c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fst3R2.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 1553, 1576, 1576, 1602], [1603, 1603, 1626, 1626, 1652], [1654, 1654, 1677, 1677, 1703], [1704, 1704, 1727, 1727, 1753], [1755, 1901, 1926, 1926, 1950], [1951, 1951, 1976, 1976, 2000], [2001, 2001, 2026, 2026, 2050], [2051, 2051, 2076, 2076, 2100], [2102, 2261, 2284, 2284, 2311], [2312, 2358, 2381, 2381, 2408], [2409, 2455, 2478, 2478, 2505], [2506, 2552, 2575, 2575, 2602], [2650, 2811, 2834, 2834, 2892], [2893, 2893, 2916, 2916, 2973], [2974, 2974, 2997, 2997, 3054], [3055, 3055, 3078, 3078, 3135], [3137, 3292, 3321, 3321, 3509], [3511, 3511, 3542, 3542, 3657], [3659, 3659, 3690, 3690, 3805], [3807, 3807, 3838, 3838, 3953], [3955, 3965, 3988, 3988, 4012], [4013, 4013, 4036, 4036, 4071], [4072, 4072, 4095, 4095, 4136], [4137, 4137, 4160, 4160, 4207], [4209, 4209, 4266, 4266, 4433]]}
{"id": "fstGDN", "name": "effin w/Silexars' shader XsXXDn ", "author": "femalefaust", "description": "all in title.  see https://www.shadertoy.com/view/XsXXDn.  ", "tags": ["silexars", "sphere"], "likes": 6, "viewed": 520, "date": "1629876546", "time_retrieved": "2024-06-20T20:47:15.995906", "image_code": "// http://www.pouet.net/prod.php?which=57245\n// If you intend to reuse this shader, please add credits to 'Danilo Guanabara'\n\n#define t iTime\n#define r iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 c;\n\tfloat l,z=t;\n\tfor(int i=0;i<3;i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p;\n\t\tp-=.5;\n\t\tp.x*=r.x/r.y;\n\t\tz+=.07;\n\t\tl=length(p);\n\t\tuv+=p/l*(tan(z)+1.)*abs(tan(l*9.-z*2.));\n\t\tc[i]=.01/length(abs(mod(uv,1.)-.5));\n\t}\n\tfragColor=vec4(c/l,t);\n}\n\n// based on this shader by Silexars\n// https://www.shadertoy.com/view/XsXXDn", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fstGDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 168, 224, 224, 468]]}
{"id": "fstGRr", "name": "Shards - 2", "author": "birdbird", "description": "Variation of Shards - 1.\nUsing log polar-tiling (https://www.osar.fr/notes/logspherical) to create an infitely zooming shader. (again)\nThe colors are done with the help of the spectrum response function here: https://www.shadertoy.com/view/wlSBzD", "tags": ["spectrum", "tiling"], "likes": 8, "viewed": 76, "date": "1629063672", "time_retrieved": "2024-06-20T20:47:16.432310", "image_code": "const float pi = acos(-1.);\n\n//https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\nfloat map_range(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n//https://gist.github.com/ayamflow/c06bc0c8a64f985dd431bd0ac5b557cd\nvec2 rotateUV(vec2 uv, float rotation)\n{\n    float mid = 0.5;\n    return vec2(\n        cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,\n        cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid\n    );\n}\n\n//https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat map(vec2 uv) {\n    int iterations = 5;\n    vec2 ouv = uv;\n\n    uv = abs(mod(uv, 1.)*4. - 2.);\n    \n    for(int i = 0; i < iterations; i ++) {\n        float fi = float(i);\n        float fit = float(iterations);\n        uv = abs(uv - (vec2(cos(iTime/4.) + (fi/fit)*1. )));\n        uv *= 1.6;        \n        uv = rotateUV(uv, map_range(ouv.x,-1.,1., 0.5, 5.) );\n    }\n    \n    return sdBox(uv, vec2(0.2));\n}\n\n//https://www.shadertoy.com/view/MsGSRd\nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        map(uv+d.xy)-map(uv-d.xy),\n        map(uv+d.yx)-map(uv-d.yx)\n    )/delta;\n}\n\n// https://www.shadertoy.com/view/wlSBzD\nvec3 SpectrumPoly(in float x) {\n    return (vec3( 1.220023e0,-1.933277e0, 1.623776e0)+(vec3(-2.965000e1, 6.806567e1,-3.606269e1)+(vec3( 5.451365e2,-7.921759e2, 6.966892e2)+(vec3(-4.121053e3, 4.432167e3,-4.463157e3)+(vec3( 1.501655e4,-1.264621e4, 1.375260e4)+(vec3(-2.904744e4, 1.969591e4,-2.330431e4)+(vec3( 3.068214e4,-1.698411e4, 2.229810e4)+(vec3(-1.675434e4, 7.594470e3,-1.131826e4)+ vec3( 3.707437e3,-1.366175e3, 2.372779e3)*x)*x)*x)*x)*x)*x)*x)*x)*x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 uv_o = uv;\n    uv /= dot(uv,uv);\n    \n    //Log polar-tiling -> https://www.osar.fr/notes/logspherical/\n    vec2 pos = vec2(log(length(uv)), atan(uv.y, uv.x));\n    pos *= 1./pi;\n    pos = fract(pos) - 0.5;   \n    uv = pos;\n    uv.x += iTime/2. + 5700.;\n\n    //Lightning\n    vec2 norm = normalize(getGrad(uv, 0.011));\n    float l_speed = 4.;\n    vec2 lightpos = vec2(sin(iTime*l_speed), cos(iTime*l_speed));\n    float light = abs(dot(norm, normalize(lightpos)));  \n    vec3 color = SpectrumPoly(sin(light*2. + sin(iTime/3.))*0.5 + 0.5)*1.4;\n    \n    //Shine\n    float mask = (1. - pow(length(uv_o),0.2))*map_range(sin(iTime), -1.,1., 1.8, 2.);\n    color += vec3(mask,mask,mask*0.78);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fstGRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[29, 97, 175, 175, 241], [243, 311, 351, 351, 547], [549, 627, 664, 664, 744], [746, 746, 766, 766, 1157], [1159, 1199, 1234, 1234, 1361], [1363, 1404, 1435, 1435, 1862], [1864, 1864, 1921, 1921, 2712]]}
{"id": "fstGRX", "name": "Crystal Ritual", "author": "Drakyen", "description": "Originally made as a audio-responsive shader in Bonzomatic, this is a none-audio-responsive shadertoy port. Easily my best shader so far, I'm really happy with how this one turned out.", "tags": ["3d", "raymarching", "transparency"], "likes": 4, "viewed": 118, "date": "1630351825", "time_retrieved": "2024-06-20T20:47:17.026363", "image_code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat t; //time\nvec3 glw = vec3(0); //glow\n\nfloat bx(vec3 p, vec3 s) //box sdf\n{\n  vec3 q=abs(p)-s;\n  return min(max(q.x,max(q.y,q.z)), 0.) + length(max(q,0.));\n}\n\nfloat cy(vec3 p, float r) //cylinder sdf\n{\n  return length(p.xz)-r;\n}\n\n\nvec2 mp(vec3 p) //map/scene\n{\n  vec3 pp = p; //temp position\n\n  //audio based modifier - just replaced with a sine here\n  float fb = sin(t)*0.5+0.5;//texture(texFFTSmoothed,0.1).x * 300. + texture(texFFTSmoothed,0.99).x * 300.;\n  float tt = t + fb*0.6; //audio adjusted time\n  float g = length(pp) - fb*2.; //centre glow calculation\n  glw +=0.01/(0.01+g*g)*vec3(0.4,0.1,0.9); //add glow\n  \n  for(float i=0.;i<4.;i++) //kifs loop for centre\n  {\n     pp.xy=abs(pp.xy)-1.2 - fb*0.5;\n     pp.xy *= rot(tt + i);\n     pp.yz *= rot(i);\n     pp.z += fb;\n\n  }\n  vec2 b = vec2(bx(pp, vec3(1.)) - 0.1, 1.); //create centre crystal\n  pp=p; //reset temp position\n  \n  pp.xz *= rot(t/10.); //rotate around y\n  pp.xz=abs(pp.xz)-9.; //domain repeat to create 4 pillars\n \n  vec2 c = vec2(cy(pp,1.),2.); //outer cylinders\n  pp.y*=sin(t/3.); //hacky way to get the colours to shift by shifting the y\n  g = length(pp.xz) * 0.85; //slight glow on pillars\n  glw += 0.01/(0.01+g*g)*mix(vec3(0.1,0.0,0.9), vec3(0.9,0.0,0.1), (pp.y+10.)/20.); //add glow with y based colour\n  c.x = min(c.x, -abs(p.y) + 15.); //floor plane, domain repeated to create ceiling too\n  \n  return b.x < c.x ? b : c;\n} \n\n\nvec2 tr(vec3 ro,vec3 rd,float x) //raymarcher\n{\n  vec2 d = vec2(0);\n  for(int i = 0; i < 256; i++)\n  {\n    vec3 p=ro+rd*d.x;\n    vec2 s=mp(p);s.x*=x;\n    d.x+=s.x;d.y=s.y;\n    if(d.x>64.||s.x<0.001)break;\n  }\n  if(d.x>64.)d.y=0.;return d;\n}\n\nvec3 nm(vec3 p) //normal calc\n{\n  vec2 e = vec2(0.001,0); return normalize(mp(p).x-vec3(mp(p-e.xyy).x,mp(p-e.yxy).x,mp(p-e.yyx).x));\n}\n\nvec4 px(vec4 h, vec3 rd, vec3 n) //hit \"shader\" - calculates the colour from position + object + ray + normal data\n{\n  vec4 b=vec4(0,0,0,1); //background\n  if(h.a==0.)return vec4(b.rgb,1.); //return background for object id 0\n  vec4 a=h.a == 1. ? vec4(cos(t)*0.5+0.5,0.1,0.3, 0.2) : vec4(0.,0.,0.,0.8); //base colour\n  float d=dot(n,-rd); //unclamped diffuse\n  float dd=max(d,0.); //diffuse proper\n  float f=pow(1.-d,4.); //easy fres by using inverse of unclamped diffuse\n  float s=pow(abs(dot(reflect(rd,n),-rd)),40.); //specular\n  return vec4(a.rgb*(dd+f)+s,a.a); //mix together\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n  t=iTime; //assign time global\n  vec2 uv = vec2(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y); //uv\n  uv-=0.5;uv/=vec2(iResolution.y/iResolution.x,1); //uv normalise\n  vec3 ro = vec3(0, 0, -30),rd=normalize(vec3(uv + vec2(0, 0),1.)), //ray origin and direction\n  oro=ro,ord=rd,cn,cp,cc;float ts=1.; //lots of variables to track transparency loop\n  for(int i=0;i<4;i++) //transparency loop\n  {\n    vec2 f=tr(oro,ord,1.); //march to front object\n    cp=oro+ord*f.x;cn=nm(cp); //update current position and normal\n    vec4 c=px(vec4(cp,f.y),ord,cn); //colour for front object\n    if(f.y==0.||c.a==1.){cc=mix(cc,c.rgb,ts);break;}; //mix colour and break if object is solid or there was no object\n    ro=cp-cn*0.01;rd=refract(ord,cn,1./1.3); //refract and update ray\n    vec2 z=tr(ro,rd,-1.); //march through object\n    cp=ro+rd*z.x;cn=nm(cp); //update current position and normal\n    oro=cp+cn*0.01;ord=refract(rd,-cn,1.3); //refract and update the original ray variables\n    if(dot(ord,ord)==0.)ord=reflect(rd,-cn); //reflect if refraction failed\n    cc=mix(cc,c.rgb,ts);ts-=c.a; //mix colour\n    if(ts<=0.)break; //break if we reached 0 transmission\n  }\n  fragColor=vec4(cc + glw,1); //write output\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fstGRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[60, 95, 131, 131, 213], [215, 215, 257, 257, 284], [287, 287, 316, 316, 1456], [1460, 1460, 1507, 1507, 1700], [1702, 1702, 1733, 1733, 1836], [1838, 1838, 1954, 1954, 2420], [2422, 2422, 2478, 2478, 3686]]}
{"id": "fstGz2", "name": "ZCAM color palette generation", "author": "kdrag0n", "description": "Generating Material You color palettes in the ZCAM (default) and Oklab (mouse down) color spaces.\n\nThis shader has many other features; see https://github.com/kdrag0n/glcolortest for more info.", "tags": ["color", "palette", "cam", "colorscience", "oklab", "zcam"], "likes": 2, "viewed": 218, "date": "1630233390", "time_retrieved": "2024-06-20T20:47:22.760110", "image_code": "precision highp float;\n\n/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2021 Danny Lin <danny@kdrag0n.dev>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n/*\n * Config\n */\n\nconst float HUE_RATE = 20.0;\n\nconst float SRGB_WHITE_LUMINANCE = 203.0; // cd/m^2\nconst float SRGB_WHITE_LUMINANCE_DYN_MAX = 10000.0; // cd/m^2\n\n\n/*\n * Helpers\n */\n\nconst float PI = 3.141592653589793;\nconst float FLT_MAX = 3.402823466e+38;\n\nfloat degreesToRadians(float x) {\n    return x * PI / 180.0;\n}\n\nfloat radiansToDegrees(float x) {\n    return x * 180.0 / PI;\n}\n\nfloat atan2(float y, float x) {\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nfloat cbrt(float x) {\n    return sign(x) * pow(abs(x), 1.0 / 3.0);\n}\n\nfloat square(float x) {\n    return x * x;\n}\n\nfloat cube(float x) {\n    return x * x * x;\n}\n\nfloat sqrtStd(float x) {\n    if (x < 0.0) {\n        return 0.0 / 0.0;\n    } else {\n        return sqrt(x);\n    }\n}\n\n\n/*\n * Number rendering\n */\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0)\n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{\n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n\n    bool bNeg = ( fValue < 0.0 );\n    fValue = abs(fValue);\n\n    float fLog10Value = log2(abs(fValue)) / log2(10.0);\n    float fBiggestIndex = max(floor(fLog10Value), 0.0);\n    float fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n    float fCharBin = 0.0;\n    if(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n        if(fDigitIndex > fBiggestIndex) {\n            if((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n        } else {\n            if(fDigitIndex == -1.0) {\n                if(fDecimalPlaces > 0.0) fCharBin = 2.0;\n            } else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n                float fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n            }\n        }\n    }\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\n/*\n * LCh\n */\n\nvec3 labToLch(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float hDeg = radiansToDegrees(atan2(b, a));\n    return vec3(\n        L,\n        sqrt(a*a + b*b),\n        (hDeg < 0.0) ? hDeg + 360.0 : hDeg\n    );\n}\n\nvec3 lchToLab(vec3 c) {\n    float L = c.x;\n    float C = c.y;\n    float h = c.z;\n\n    float hRad = degreesToRadians(h);\n    return vec3(\n        L,\n        C * cos(hRad),\n        C * sin(hRad)\n    );\n}\n\n\n/*\n * sRGB\n */\n\nvec3 srgbTransfer(vec3 c) {\n    vec3 gamma = 1.055 * pow(c, vec3(1.0/2.4)) - 0.055;\n    vec3 linear = 12.92 * c;\n    bvec3 selectParts = lessThan(c, vec3(0.0031308));\n    return mix(gamma, linear, selectParts);\n}\n\nvec3 srgbTransferInv(vec3 c) {\n    vec3 gamma = pow((c + 0.055)/1.055, vec3(2.4));\n    vec3 linear = c / 12.92;\n    bvec3 selectParts = lessThan(c, vec3(0.04045));\n    return mix(gamma, linear, selectParts);\n}\n\nbool linearSrgbInGamut(vec3 c) {\n    vec3 clamped = clamp(c, 0.0, 1.0);\n    return c == clamped;\n}\n\nfloat _int8ToFloat(int x) {\n    return float(x) / 255.0;\n}\n\nvec3 rgb8ToFloat(int c) {\n    return vec3(\n        _int8ToFloat((c >> 16) & 0xff),\n        _int8ToFloat((c >> 8) & 0xff),\n        _int8ToFloat(c & 0xff)\n    );\n}\n\n\n/*\n * XYZ\n */\n\nconst vec3 D65 = vec3(0.95047, 1.0, 1.08883);\nconst vec3 DCI_P3 = vec3(0.89458689, 1.0, 0.95441595);\n\nconst mat3 M_SRGB_TO_XYZ = mat3(\n    0.4123908 , 0.21263901, 0.01933082,\n    0.35758434, 0.71516868, 0.11919478,\n    0.18048079, 0.07219232, 0.95053215\n);\nconst mat3 M_XYZ_TO_SRGB = mat3(\n     3.24096994, -0.96924364,  0.05563008,\n    -1.53738318,  1.8759675 , -0.20397696,\n    -0.49861076,  0.04155506,  1.05697151\n);\n\nconst mat3 M_DISPLAY_P3_TO_XYZ = mat3(\n     0.48657095,  0.22897456, -0.        ,\n     0.26566769,  0.69173852,  0.04511338,\n     0.19821729,  0.07928691,  1.04394437\n);\nconst mat3 M_XYZ_TO_DISPLAY_P3 = mat3(\n     2.49349691, -0.82948897,  0.03584583,\n    -0.93138362,  1.76266406, -0.07617239,\n    -0.40271078,  0.02362469,  0.95688452\n);\n\nconst mat3 M_BT2020_TO_XYZ = mat3(\n    0.63695805, 0.26270021, 0.        ,\n    0.1446169 , 0.67799807, 0.02807269,\n    0.16888098, 0.05930172, 1.06098506\n);\nconst mat3 M_XYZ_TO_BT2020 = mat3(\n     1.71665119, -0.66668435,  0.01763986,\n    -0.35567078,  1.61648124, -0.04277061,\n    -0.25336628,  0.01576855,  0.94210312\n);\n\nconst mat3 M_DCI_P3_TO_XYZ = mat3(\n     0.44516982,  0.20949168, -0.        ,\n     0.27713441,  0.72159525,  0.04706056,\n     0.17228267,  0.06891307,  0.90735539\n);\nconst mat3 M_XYZ_TO_DCI_P3 = mat3(\n     2.72539403, -0.79516803,  0.04124189,\n    -1.01800301,  1.68973205, -0.08763902,\n    -0.4401632 ,  0.02264719,  1.10092938\n);\n\nvec3 linearSrgbToXyz(vec3 c) {\n    return M_SRGB_TO_XYZ * c;\n}\n\nvec3 xyzToLinearSrgb(vec3 c) {\n    return M_XYZ_TO_SRGB * c;\n}\n\n\n/*\n * CIELAB\n */\n\n\nfloat cielabF(float x) {\n    if (x > 216.0/24389.0) {\n        return cbrt(x);\n    } else {\n        return x / (108.0/841.0) + 4.0/29.0;\n    }\n}\n\nfloat cielabFInv(float x) {\n    if (x > 6.0/29.0) {\n        return cube(x);\n    } else {\n        return (108.0/841.0) * (x - 4.0/29.0);\n    }\n}\n\nvec3 xyzToCielab(vec3 c) {\n    float L = 116.0 * cielabF(c.y / D65.y) - 16.0;\n    float a = 500.0 * (cielabF(c.x / D65.x) - cielabF(c.y / D65.y));\n    float b = 200.0 * (cielabF(c.y / D65.y) - cielabF(c.z / D65.z));\n    return vec3(L, a, b);\n}\n\nvec3 cielabToXyz(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float lp = (L + 16.0) / 116.0;\n    float x = D65.x * cielabFInv(lp + (a / 500.0));\n    float y = D65.y * cielabFInv(lp);\n    float z = D65.z * cielabFInv(lp - (b / 200.0));\n    return vec3(x, y, z);\n}\n\n\n/*\n * Oklab\n */\n\nvec3 xyzToOklab(vec3 c) {\n    float l = 0.8189330101 * c.x + 0.3618667424 * c.y - 0.1288597137 * c.z;\n    float m = 0.0329845436 * c.x + 0.9293118715 * c.y + 0.0361456387 * c.z;\n    float s = 0.0482003018 * c.x + 0.2643662691 * c.y + 0.6338517070 * c.z;\n\n    float l_ = cbrt(l);\n    float m_ = cbrt(m);\n    float s_ = cbrt(s);\n\n    return vec3(\n        0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_,\n        1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_,\n        0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_\n    );\n}\n\nvec3 oklabToXyz(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float l_ = L + 0.3963377774f * a + 0.2158037573f * b;\n    float m_ = L - 0.1055613458f * a - 0.0638541728f * b;\n    float s_ = L - 0.0894841775f * a - 1.2914855480f * b;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    return vec3(\n        +1.2270138511 * l - 0.5577999807 * m + 0.2812561490 * s,\n        -0.0405801784 * l + 1.1122568696 * m - 0.0716766787 * s,\n        -0.0763812845 * l - 0.4214819784 * m + 1.5861632204 * s\n    );\n}\n\nvec3 linearSrgbToOklab(vec3 c) {\n    return xyzToOklab(linearSrgbToXyz(c));\n}\n\nvec3 oklabToLinearSrgb(vec3 c) {\n    return xyzToLinearSrgb(oklabToXyz(c));\n}\n\n\n/*\n * Oklab gamut clipping\n */\n\n/*\n * Ported from the original C/C++ implementation:\n *\n * Copyright (c) 2021 Björn Ottosson\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n    // Max saturation will be when one of r, g or b goes below zero.\n\n    // Select different coefficients depending on which component goes below zero first\n    float k0, k1, k2, k3, k4, wl, wm, ws;\n\n    if (-1.88170328f * a - 0.80936493f * b > 1.0)\n    {\n        // Red component\n        k0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n        wl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n    }\n    else if (1.81444104f * a - 1.19445276f * b > 1.0)\n    {\n        // Green component\n        k0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n        wl = -1.2681437731f; wm = +2.6097574011f; ws = -0.3413193965f;\n    }\n    else\n    {\n        // Blue component\n        k0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n        wl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n    }\n\n    // Approximate max saturation using a polynomial:\n    float S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n    // Do one step Halley's method to get closer\n    // this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n    // this should be sufficient for most applications, otherwise do two/three steps\n\n    float k_l = +0.3963377774f * a + 0.2158037573f * b;\n    float k_m = -0.1055613458f * a - 0.0638541728f * b;\n    float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n    {\n        float l_ = 1.f + S * k_l;\n        float m_ = 1.f + S * k_m;\n        float s_ = 1.f + S * k_s;\n\n        float l = l_ * l_ * l_;\n        float m = m_ * m_ * m_;\n        float s = s_ * s_ * s_;\n\n        float l_dS = 3.f * k_l * l_ * l_;\n        float m_dS = 3.f * k_m * m_ * m_;\n        float s_dS = 3.f * k_s * s_ * s_;\n\n        float l_dS2 = 6.f * k_l * k_l * l_;\n        float m_dS2 = 6.f * k_m * k_m * m_;\n        float s_dS2 = 6.f * k_s * k_s * s_;\n\n        float f  = wl * l     + wm * m     + ws * s;\n        float f1 = wl * l_dS  + wm * m_dS  + ws * s_dS;\n        float f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n        S = S - f * f1 / (f1*f1 - 0.5f * f * f2);\n    }\n\n    return S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b)\n{\n    // First, find the maximum saturation (saturation S = C/L)\n    float S_cusp = compute_max_saturation(a, b);\n\n    // Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n    vec3 rgb_at_max = oklabToLinearSrgb(vec3( 1.0, S_cusp * a, S_cusp * b ));\n    float L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n    float C_cusp = L_cusp * S_cusp;\n\n    return vec2( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by\n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n    // Find the cusp of the gamut triangle\n    vec2 cusp = find_cusp(a, b);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    // Find the intersection for upper and lower half seprately\n    float t;\n    if (((L1 - L0) * cuspC - (cuspL - L0) * C1) <= 0.f)\n    {\n        // Lower half\n\n        t = cuspC * L0 / (C1 * cuspL + cuspC * (L0 - L1));\n    }\n    else\n    {\n        // Upper half\n\n        // First intersect with triangle\n        t = cuspC * (L0 - 1.f) / (C1 * (cuspL - 1.f) + cuspC * (L0 - L1));\n\n        // Then one step Halley's method\n        {\n            float dL = L1 - L0;\n            float dC = C1;\n\n            float k_l = +0.3963377774f * a + 0.2158037573f * b;\n            float k_m = -0.1055613458f * a - 0.0638541728f * b;\n            float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n            float l_dt = dL + dC * k_l;\n            float m_dt = dL + dC * k_m;\n            float s_dt = dL + dC * k_s;\n\n            // If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n            {\n                float L = L0 * (1.f - t) + t * L1;\n                float C = t * C1;\n\n                float l_ = L + C * k_l;\n                float m_ = L + C * k_m;\n                float s_ = L + C * k_s;\n\n                float l = l_ * l_ * l_;\n                float m = m_ * m_ * m_;\n                float s = s_ * s_ * s_;\n\n                float ldt = 3.0 * l_dt * l_ * l_;\n                float mdt = 3.0 * m_dt * m_ * m_;\n                float sdt = 3.0 * s_dt * s_ * s_;\n\n                float ldt2 = 6.0 * l_dt * l_dt * l_;\n                float mdt2 = 6.0 * m_dt * m_dt * m_;\n                float sdt2 = 6.0 * s_dt * s_dt * s_;\n\n                float r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.0;\n                float r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n                float r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n                float u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n                float t_r = -r * u_r;\n\n                float g = -1.2681437731f * l + 2.6097574011f * m - 0.3413193965f * s - 1.0;\n                float g1 = -1.2681437731f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n                float g2 = -1.2681437731f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n                float u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n                float t_g = -g * u_g;\n\n                float b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.0;\n                float b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n                float b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n                float u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n                float t_b = -b * u_b;\n\n                t_r = u_r >= 0.f ? t_r : FLT_MAX;\n                t_g = u_g >= 0.f ? t_g : FLT_MAX;\n                t_b = u_b >= 0.f ? t_b : FLT_MAX;\n\n                t += min(t_r, min(t_g, t_b));\n            }\n        }\n    }\n\n    return t;\n}\n\nvec3 gamut_clip_preserve_lightness(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L0 = clamp(L, 0.0, 1.0);\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_0_5(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L0 = 0.5;\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_L_cusp(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n    vec2 cusp = find_cusp(a_, b_);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    float L0 = cuspL;\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_0_5(vec3 rgb, float alpha)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float Ld = L - 0.5f;\n    float e1 = 0.5f + abs(Ld) + alpha * C;\n    float L0 = 0.5f*(1.f + sign(Ld)*(e1 - sqrt(e1*e1 - 2.f *abs(Ld))));\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.f - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_L_cusp(vec3 rgb, float alpha)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n    vec2 cusp = find_cusp(a_, b_);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    float Ld = L - cuspL;\n    float k = 2.f * (Ld > 0.0 ? 1.f - cuspL : cuspL);\n\n    float e1 = 0.5f*k + abs(Ld) + alpha * C/k;\n    float L0 = cuspL + 0.5f * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.f - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\n\n/*\n * ZCAM (JCh values)\n */\n\nconst float B = 1.15;\nconst float G = 0.66;\nconst float C1 = 3424.0 / 4096.0;\nconst float C2 = 2413.0 / 128.0;\nconst float C3 = 2392.0 / 128.0;\nconst float ETA = 2610.0 / 16384.0;\nconst float RHO = 1.7 * 2523.0 / 32.0;\nconst float EPSILON = 3.7035226210190005e-11;\n\nconst float SURROUND_DARK = 0.525;\nconst float SURROUND_DIM = 0.59;\nconst float SURROUND_AVERAGE = 0.69;\n\nstruct ZcamViewingConditions {\n    // Given\n    float F_s;\n    float L_a;\n    float Y_b;\n    vec3 refWhite;\n    float whiteLuminance;\n\n    // Calculated\n    float F_b;\n    float F_l;\n    float refWhiteIz;\n};\n\nfloat pq(float x) {\n    float num = C1 + C2 * pow(x / 10000.0, ETA);\n    float denom = 1.0 + C3 * pow(x / 10000.0, ETA);\n\n    return pow(num / denom, RHO);\n}\n\nfloat pqInv(float x) {\n    float num = C1 - pow(x, 1.0/RHO);\n    float denom = C3*pow(x, 1.0/RHO) - C2;\n\n    return 10000.0 * pow(num / denom, 1.0/ETA);\n}\n\nvec3 xyzToIzazbz(vec3 c) {\n    float xp = B*c.x - (B-1.0)*c.z;\n    float yp = G*c.y - (G-1.0)*c.x;\n\n    float rp = pq( 0.41478972*xp + 0.579999*yp + 0.0146480*c.z);\n    float gp = pq(-0.20151000*xp + 1.120649*yp + 0.0531008*c.z);\n    float bp = pq(-0.01660080*xp + 0.264800*yp + 0.6684799*c.z);\n\n    float az = 3.524000*rp + -4.066708*gp +  0.542708*bp;\n    float bz = 0.199076*rp +  1.096799*gp + -1.295875*bp;\n    float Iz = gp - EPSILON;\n\n    return vec3(Iz, az, bz);\n}\n\nfloat hpToEz(float hp) {\n    return 1.015 + cos(degreesToRadians(89.038 + hp));\n}\n\nfloat izToQz(float Iz, ZcamViewingConditions cond) {\n    return 2700.0 * pow(Iz, (1.6 * cond.F_s) / pow(cond.F_b, 0.12)) *\n            (pow(cond.F_s, 2.2) * pow(cond.F_b, 0.5) * pow(cond.F_l, 0.2));\n}\n\nZcamViewingConditions createZcamViewingConditions(float F_s, float L_a, float Y_b, vec3 refWhite, float whiteLuminance) {\n    float F_b = sqrt(Y_b / refWhite.y);\n    float F_l = 0.171 * cbrt(L_a) * (1.0 - exp(-48.0/9.0 * L_a));\n    float refWhiteIz = xyzToIzazbz(refWhite).x;\n\n    return ZcamViewingConditions(\n        F_s, L_a, Y_b, refWhite, whiteLuminance,\n        F_b, F_l, refWhiteIz\n    );\n}\n\nstruct Zcam {\n    float brightness;\n    float lightness;\n    float colorfulness;\n    float chroma;\n    float hueAngle;\n    /* hue composition is not implemented */\n\n    float saturation;\n    float vividness;\n    float blackness;\n    float whiteness;\n\n    ZcamViewingConditions cond;\n};\n\nZcam xyzToZcam(vec3 c, ZcamViewingConditions cond) {\n    /* Step 2 */\n    // Achromatic response\n    vec3 izazbz = xyzToIzazbz(c);\n    float Iz = izazbz.x;\n    float az = izazbz.y;\n    float bz = izazbz.z;\n    float Iz_w = cond.refWhiteIz;\n\n    /* Step 3 */\n    // Hue angle\n    float hz = radiansToDegrees(atan2(bz, az));\n    float hp = (hz < 0.0) ? hz + 360.0 : hz;\n\n    /* Step 4 */\n    // Eccentricity factor\n    float ez = hpToEz(hp);\n\n    /* Step 5 */\n    // Brightness\n    float Qz = izToQz(Iz, cond);\n    float Qz_w = izToQz(cond.refWhiteIz, cond);\n\n    // Lightness\n    float Jz = 100.0 * (Qz / Qz_w);\n\n    // Colorfulness\n    float Mz = 100.0 * pow(square(az) + square(bz), 0.37) *\n            ((pow(ez, 0.068) * pow(cond.F_l, 0.2)) /\n                    (pow(cond.F_b, 0.1) * pow(Iz_w, 0.78)));\n    \n    // Chroma\n    float Cz = 100.0 * (Mz / Qz_w);\n\n    /* Step 6 */\n    // Saturation\n    float Sz = 100.0 * pow(cond.F_l, 0.6) * sqrt(Mz / Qz);\n\n    // Vividness, blackness, whiteness\n    float Vz = sqrt(square(Jz - 58.0) + 3.4 * square(Cz));\n    float Kz = 100.0 - 0.8 * sqrt(square(Jz) + 8.0 * square(Cz));\n    float Wz = 100.0 - sqrt(square(100.0 - Jz) + square(Cz));\n\n    return Zcam(\n        Qz,\n        Jz,\n        Mz,\n        Cz,\n        hp,\n\n        Sz,\n        Vz,\n        Kz,\n        Wz,\n\n        cond\n    );\n}\n\nvec3 zcamToXyz(vec3 c, ZcamViewingConditions cond) {\n    float Jz = c.x;\n    float Cz = c.y;\n    float hz = c.z;\n\n    float Iz_w = cond.refWhiteIz;\n    float Qz_w = izToQz(Iz_w, cond);\n\n    /* Step 1 */\n    // Achromatic response\n    float Iz_denom = 2700.0 * pow(cond.F_s, 2.2) * pow(cond.F_b, 0.5) * pow(cond.F_l, 0.2);\n    float Iz_src = (Jz * Qz_w) / (Iz_denom * 100.0);\n    float Iz = pow(Iz_src, pow(cond.F_b, 0.12) / (1.6 * cond.F_s));\n\n    /* Step 2 */\n    // Chroma\n    /* skipped because we take Cz as input */\n\n    /* Step 3 is missing because hue composition is not supported */\n\n    /* Step 4 */\n    // ... and back to colorfulness\n    float Mz = (Cz * Qz_w) / 100.0;\n    float ez = hpToEz(hz);\n    float Cz_p = pow((Mz * pow(Iz_w, 0.78) * pow(cond.F_b, 0.1)) /\n            // Paper specifies pow(1.3514) but this extra precision is necessary for more accurate inversion\n            (100.0 * pow(ez, 0.068) * pow(cond.F_l, 0.2)), 1.0 / 0.37 / 2.0);\n    float az = Cz_p * cos(degreesToRadians(hz));\n    float bz = Cz_p * sin(degreesToRadians(hz));\n\n    /* Step 5 */\n    float I = Iz + EPSILON;\n\n    float r = pqInv(I + 0.2772100865*az +  0.1160946323*bz);\n    float g = pqInv(I);\n    float b = pqInv(I + 0.0425858012*az + -0.7538445799*bz);\n\n    float xp =  1.9242264358*r + -1.0047923126*g +  0.0376514040*b;\n    float yp =  0.3503167621*r +  0.7264811939*g + -0.0653844229*b;\n    float z  = -0.0909828110*r + -0.3127282905*g +  1.5227665613*b;\n\n    float x = (xp + (B - 1.0)*z) / B;\n    float y = (yp + (G - 1.0)*x) / G;\n\n    return vec3(x, y, z);\n}\n\nvec3 zcamJchToLinearSrgb(vec3 jch, ZcamViewingConditions cond) {\n    vec3 xyzAbs = zcamToXyz(jch, cond);\n    vec3 xyzRel = xyzAbs / cond.whiteLuminance;\n    return xyzToLinearSrgb(xyzRel);\n}\n\nconst float ZCAM_CHROMA_EPSILON = 0.0001;\nconst bool CLIP_ZCAM = true;\nvec3 clipZcamJchToLinearSrgb(vec3 jch, ZcamViewingConditions cond) {\n    vec3 initialResult = zcamJchToLinearSrgb(jch, cond);\n    if (linearSrgbInGamut(initialResult)) {\n        return initialResult;\n    }\n\n    float lightness = jch.r;\n    float chroma = jch.g;\n    float hue = jch.b;\n    if (lightness <= ZCAM_CHROMA_EPSILON) {\n        return vec3(0.0);\n    } else if (lightness >= 100.0 - ZCAM_CHROMA_EPSILON) {\n        return vec3(1.0);\n    }\n\n    float lo = 0.0;\n    float hi = chroma;\n\n    vec3 newLinearSrgb = initialResult;\n    while (abs(hi - lo) > ZCAM_CHROMA_EPSILON) {\n        float mid = (lo + hi) / 2.0;\n\n        newLinearSrgb = zcamJchToLinearSrgb(vec3(lightness, mid, hue), cond);\n        if (!linearSrgbInGamut(newLinearSrgb)) {\n            hi = mid;\n        } else {\n            float mid2 = mid + ZCAM_CHROMA_EPSILON;\n\n            vec3 newLinearSrgb2 = zcamJchToLinearSrgb(vec3(lightness, mid2, hue), cond);\n            if (linearSrgbInGamut(newLinearSrgb2)) {\n                lo = mid;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return newLinearSrgb;\n}\n\n\n/*\n * Theme generation\n */\n\nconst float OKLAB_ACCENT1_CHROMA = 0.1328123146401862;\nconst float OKLAB_LIGHTNESS_MAP[13] = float[](\n    1.0,\n    0.9880873963836093,\n    0.9551400440214246,\n    0.9127904082618294,\n    0.8265622041716898,\n    0.7412252673769428,\n    0.653350946076347,\n    0.5624050605208273,\n    0.48193149058901036,\n    0.39417829080418526,\n    0.3091856317280812,\n    0.22212874192541768,\n    0.0\n);\n\nconst float ZCAM_ACCENT1_CHROMA = 20.54486422; // careful!\nconst float ZCAM_ACCENT1_COLORFULNESS = 36.47983487;\nconst float ZCAM_LIGHTNESS_MAP[13] = float[](\n    100.00000296754273,\n    98.60403974009428,\n    94.72386350388908,\n    89.69628870011267,\n    79.3326296037671,\n    68.938947819272,\n    58.15091644790415,\n    46.991689840263206,\n    37.24709908558773,\n    26.96785892507836,\n    17.67571012446932,\n    9.36696155986009,\n    0.0\n);\n\nconst float CIELAB_LIGHTNESS_MAP[13] = float[](\n    100.0,\n    99.0,\n    95.0,\n    90.0,\n    80.0,\n    70.0,\n    60.0,\n    49.6,\n    40.0,\n    30.0,\n    20.0,\n    10.0,\n    0.0\n);\n\nconst float ZCAM_LINEAR_LIGHTNESS_MAP[13] = float[](\n    100.0,\n    99.0,\n    95.0,\n    90.0,\n    80.0,\n    70.0,\n    60.0,\n    50.0,\n    40.0,\n    30.0,\n    20.0,\n    10.0,\n    0.0\n);\n\nconst int REF_ACCENT1_COLOR_COUNT = 9;\nconst int REF_ACCENT1_COLORS[9] = int[](\n    0xd3e3fd,\n    0xa8c7fa,\n    0x7cacf8,\n    0x4c8df6,\n    0x1b6ef3,\n    0x0b57d0,\n    0x0842a0,\n    0x062e6f,\n    0x041e49\n);\n\nconst float SWATCH_CHROMA_SCALES[5] = float[](\n    1.0, // accent1\n    1.0 / 3.0, // accent2\n    (1.0 / 3.0) * 2.0, // accent3\n    1.0 / 8.0, // neutral1\n    1.0 / 5.0 // neutral2\n);\n\nvec3 calcShadeParams(int swatch, float lightness, float seedChroma, float seedHue, float chromaFactor, float accent1Chroma) {\n    float refChroma = accent1Chroma * SWATCH_CHROMA_SCALES[0];\n    float targetChroma = accent1Chroma * SWATCH_CHROMA_SCALES[swatch];\n    float scaleC = (refChroma == 0.0) ? 0.0 : (clamp(seedChroma, 0.0, refChroma) / refChroma);\n    float chroma = targetChroma * scaleC * chromaFactor;\n    float hue = (swatch == 2) ? seedHue + 60.0 : seedHue;\n\n    return vec3(lightness, chroma, hue);\n}\n\nvec3 generateShadeOklab(int swatch, int shade, float seedChroma, float seedHue, float chromaFactor) {\n    float cielabL = CIELAB_LIGHTNESS_MAP[shade];\n    vec3 cielabXyz = cielabToXyz(vec3(cielabL, 0.0, 0.0));\n    float lightness = xyzToOklab(cielabXyz).x;\n\n    vec3 lch = calcShadeParams(swatch, lightness, seedChroma, seedHue, chromaFactor, OKLAB_ACCENT1_CHROMA);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nZcamViewingConditions getZcamCond() {\n    float whiteLuminance = SRGB_WHITE_LUMINANCE;\n\n    // Dynamic luminance for testing\n    //whiteLuminance = pow(10.0, (iMouse.x / iResolution.x) * (log(SRGB_WHITE_LUMINANCE_DYN_MAX) / log(10.0)));\n\n    float dynVal1 = (iMouse.x / iResolution.x) * whiteLuminance;\n    float dynVal2 = (iMouse.y / iResolution.y) * whiteLuminance;\n\n    ZcamViewingConditions cond = createZcamViewingConditions(\n        /* surround */ SURROUND_AVERAGE,\n        /* L_a */ 0.4 * whiteLuminance,\n        /* Y_b */ cielabToXyz(vec3(50.0, 0.0, 0.0)).y * whiteLuminance,\n        /* ref white */ D65 * whiteLuminance,\n        /* white luminance */ whiteLuminance\n    );\n\n    return cond;\n}\n\nvec3 generateShadeZcam(int swatch, int shade, float seedChroma, float seedHue, float chromaFactor) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    float cielabL = CIELAB_LIGHTNESS_MAP[shade];\n    vec3 cielabXyz = cielabToXyz(vec3(cielabL, 0.0, 0.0)) * cond.whiteLuminance;\n    float lightness = xyzToZcam(cielabXyz, cond).lightness;\n\n    // Calculate accent1 chroma given the viewing conditions\n    float chromaAcc = 0.0;\n    for (int i = 0; i < REF_ACCENT1_COLOR_COUNT; i++) {\n        vec3 srgb = rgb8ToFloat(REF_ACCENT1_COLORS[i]);\n        vec3 xyzAbs = linearSrgbToXyz(srgbTransferInv(srgb)) * cond.whiteLuminance;\n        Zcam zcam = xyzToZcam(xyzAbs, cond);\n        chromaAcc += zcam.chroma;\n    }\n    float avgChroma = 1.2 * chromaAcc / float(REF_ACCENT1_COLOR_COUNT);\n\n    // For constant values\n    //lightness = ZCAM_LIGHTNESS_MAP[shade];\n    //avgChroma = ZCAM_ACCENT1_CHROMA;\n    // For linear shade lightness in ZCAM\n    //lightness = ZCAM_LINEAR_LIGHTNESS_MAP[shade];\n\n    vec3 jch = calcShadeParams(swatch, lightness, seedChroma, seedHue, chromaFactor, avgChroma);\n\n    if (CLIP_ZCAM) {\n        return clipZcamJchToLinearSrgb(jch, cond);\n    } else {\n        return zcamJchToLinearSrgb(jch, cond);\n    }\n}\n\nvec3 getThemeColor(vec2 uv, float hue) {\n    int shadeIdx = int(uv.x * 13.0);\n    int swatchIdx = int((1.0 - uv.y) * 5.0);\n    float seedChroma = 1000000.0;\n\n    if (shadeIdx == 0) {\n        return vec3(1.0);\n    } else if (shadeIdx == 12) {\n        return vec3(0.0);\n    }\n\n    if (iMouse.z > 0.0) {\n        return gamut_clip_preserve_lightness(generateShadeOklab(swatchIdx, shadeIdx, seedChroma, hue, 1.0));\n    } else {\n        return generateShadeZcam(swatchIdx, shadeIdx, seedChroma, hue, 1.0);\n    }\n}\n\n\n/*\n * Color space interfaces\n */\n\nvec3 getColorOklab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawLightness, rawChroma, hue);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nvec3 getColorCielab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawLightness * 100.0, rawChroma * 170.0, hue);\n    vec3 cielab = lchToLab(lch);\n    return xyzToLinearSrgb(cielabToXyz(cielab));\n}\n\nvec3 getColorZcam(float rawLightness, float rawChroma, float hue) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    vec3 jch = vec3(rawLightness * 100.0, rawChroma * 170.0, hue);\n\n    if (CLIP_ZCAM) {\n        return clipZcamJchToLinearSrgb(jch, cond);\n    } else {\n        return zcamJchToLinearSrgb(jch, cond);\n    }\n}\n\n\nvec3 getLightnessOklab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma, 0.0, hue);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nvec3 getLightnessCielab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma * 100.0, 0.0, hue);\n    vec3 cielab = lchToLab(lch);\n    return xyzToLinearSrgb(cielabToXyz(cielab));\n}\n\nvec3 getLightnessZcam(float rawLightness, float rawChroma, float hue) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    vec3 zcam = vec3(rawChroma * 100.0, 0.0, hue);\n\n    vec3 xyzAbs = zcamToXyz(zcam, cond);\n    vec3 xyzRel = xyzAbs / cond.whiteLuminance;\n    return xyzToLinearSrgb(xyzRel);\n}\n\n\n/*\n * Blending\n */\n\nvec3 blendZcam(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    Zcam lhs = xyzToZcam(linearSrgbToXyz(srgbTransferInv(lhsRgb)) * cond.whiteLuminance, cond);\n    Zcam rhs = xyzToZcam(linearSrgbToXyz(srgbTransferInv(rhsRgb)) * cond.whiteLuminance, cond);\n\n    vec3 lhsJch = vec3(lhs.lightness, lhs.chroma, lhs.hueAngle);\n    vec3 rhsJch = vec3(rhs.lightness, rhs.chroma, lhs.hueAngle);\n    return clipZcamJchToLinearSrgb(mix(lhsJch, rhsJch, uv.x), cond);\n}\n\nvec3 blendLinearSrgb(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    vec3 lhs = srgbTransferInv(lhsRgb);\n    vec3 rhs = srgbTransferInv(rhsRgb);\n\n    return srgbTransfer(mix(lhs, rhs, uv.x));\n}\n\nvec3 blendSrgb(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    return mix(lhsRgb, rhsRgb, uv.x);\n}\n\n\n/*\n * Main\n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy; // NDC (0-1)\n\n    float rawLightness = uv.y;\n    float rawChroma = uv.x;\n    float hue = mod(iTime * HUE_RATE, 360.0); // degrees\n    //hue = 286.66117416556847;\n    vec3 camOut;\n\n    // Rainbow\n    //rawLightness = 0.7502;\n    //rawChroma = 0.138;\n    //hue = uv.x * 360.0;\n\n    // Gamut/cusp animation\n    /*if (iMouse.z > 0.0) {\n        camOut = getColorOklab(rawLightness, rawChroma, hue);\n        //camOut = gamut_clip_preserve_lightness(camOut);\n    } else {\n        camOut = getColorZcam(rawLightness, rawChroma, hue);\n    }*/\n\n    // Lightness ramp\n    /*if (iMouse.z > 0.0) {\n        camOut = getLightnessZcam(rawLightness, rawChroma, hue);\n    } else {\n        camOut = getLightnessOklab(rawLightness, rawChroma, hue);\n    }*/\n\n    // Theme generation\n    camOut = getThemeColor(uv, hue);\n\n    // Chroma contrast\n    /*int testSwatch = 3; // neutral1\n    int testShade = 11; // 900\n    testShade = 4; // 200\n    testSwatch = 0; // accent1\n    if (uv.x > 0.5) {\n        ZcamViewingConditions cond = getZcamCond();\n        vec3 xyzAbs = linearSrgbToXyz(srgbTransferInv(rgb8ToFloat(0x533b79))) * cond.whiteLuminance;\n        Zcam seed = xyzToZcam(xyzAbs, cond);\n        camOut = generateShadeZcam(testSwatch, testShade, seed.chroma, seed.hueAngle, 1.0);\n    } else {\n        testSwatch = 3;\n        testShade = 11;\n        camOut = generateShadeZcam(testSwatch, testShade, 0.0, 0.0, 1.0);\n    }*/\n\n    // Blending\n    /*if (uv.y >= 0.5) {\n        camOut = blendZcam(uv, vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    } else {\n        camOut = blendSrgb(uv, vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    }*/\n\n    // Oklab gamut clipping\n    //camOut = gamut_clip_preserve_lightness(camOut);\n    //camOut = gamut_clip_project_to_0_5(camOut);\n    //camOut = gamut_clip_project_to_L_cusp(camOut);\n    //camOut = gamut_clip_adaptive_L0_0_5(camOut, 0.05);\n    //camOut = gamut_clip_adaptive_L0_L_cusp(camOut, 0.05);\n\n    // Simple RGB clipping (also necessary after gamut clipping)\n    camOut = clamp(camOut, 0.0, 1.0);\n\n    if (linearSrgbInGamut(camOut)) {\n        vec3 dither = texture(iChannel0, uv * (iResolution.xy / 64.0)).rgb * 2.0 - 1.0;\n        dither = sign(dither) * (1.0 - sqrt(1.0 - abs(dither))) / 64.0;\n        fragColor = vec4(srgbTransfer(camOut) + dither, 1.0);\n    } else {\n\t    vec2 fontSize = vec2(16.0, 30.0);\n        float digit = PrintValue((fragCoord - vec2(iResolution.x - 80.0, 10.0)) / fontSize, hue, 3.0, 0.0);\n        fragColor = vec4(vec3(0.5) + digit, 1.0);\n    }\n\n    // Print dynamic sRGB white luminance\n    /*\n    float whiteL = pow(10.0, (iMouse.x / iResolution.x) * (log(SRGB_WHITE_LUMINANCE_DYN_MAX) / log(10.0)));\n    vec2 fontSize = vec2(16.0, 30.0);\n    float digit2 = PrintValue((fragCoord - vec2(iResolution.x - 80.0, 10.0)) / fontSize, whiteL, 3.0, 0.0);\n    fragColor = vec4(fragColor.rgb + digit2, 1.0);\n    */\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fstGz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1352, 1447, 1480, 1480, 1509], [1511, 1511, 1544, 1544, 1573], [1575, 1575, 1606, 1606, 1690], [1692, 1692, 1713, 1713, 1760], [1762, 1762, 1785, 1785, 1805], [1807, 1807, 1828, 1828, 1852], [1854, 1854, 1878, 1878, 1968], [1999, 2147, 2178, 2178, 2336], [2338, 2338, 2432, 2432, 3544], [3600, 3615, 3638, 3638, 3849], [3851, 3851, 3874, 3874, 4052], [4055, 4071, 4098, 4098, 4283], [4285, 4285, 4315, 4315, 4494], [4496, 4496, 4528, 4528, 4594], [4596, 4596, 4623, 4623, 4654], [4656, 4656, 4681, 4681, 4817], [4820, 6255, 6285, 6285, 6317], [6319, 6319, 6349, 6349, 6381], [6384, 6403, 6427, 6427, 6546], [6548, 6548, 6575, 6575, 6691], [6693, 6693, 6719, 6719, 6936], [6938, 6938, 6964, 6964, 7227], [7230, 7247, 7272, 7272, 7791], [7793, 7793, 7818, 7818, 8344], [8346, 8346, 8378, 8378, 8423], [8425, 8425, 8457, 8457, 8502], [9711, 9875, 9923, 10081, 12107], [12109, 12200, 12234, 12297, 12674], [12676, 12814, 12893, 12936, 15967], [15969, 15969, 16015, 16015, 16585], [16587, 16587, 16629, 16629, 17184], [17186, 17186, 17231, 17231, 17992], [17994, 17994, 18050, 18050, 18725], [18727, 18727, 18786, 18786, 19737], [19740, 20350, 20369, 20369, 20507], [20509, 20509, 20531, 20531, 20663], [20665, 20665, 20691, 20691, 21137], [21139, 21139, 21163, 21163, 21220], [21222, 21222, 21274, 21274, 21422], [21424, 21424, 21545, 21545, 21821], [22110, 22110, 22162, 22206, 23442], [23444, 23444, 23496, 23496, 25007], [25009, 25009, 25073, 25073, 25199], [25272, 25272, 25340, 25340, 26379], [26846, 28003, 28128, 28128, 28516], [28518, 28518, 28619, 28619, 28954], [28956, 28956, 28993, 28993, 29657], [29659, 29659, 29759, 29759, 30885], [30887, 30887, 30927, 30927, 31394], [31397, 31431, 31499, 31499, 31621], [31623, 31623, 31692, 31692, 31843], [31845, 31845, 31912, 31912, 32169], [32172, 32172, 32244, 32244, 32357], [32359, 32359, 32432, 32432, 32566], [32568, 32568, 32639, 32639, 32867], [32870, 32890, 32941, 32941, 33384], [33386, 33386, 33443, 33443, 33572], [33574, 33574, 33625, 33625, 33665], [33668, 33684, 33739, 33739, 36643]]}
{"id": "ft2SRd", "name": "It's Britneys All the Way Down", "author": "milkfat", "description": "I've been playing around looking for efficient ways of making trees. At this point I realized I had some handy UV coordinates.\n\nVery basic mouse control: X-axis controls the angular multiplier, Y-axis controls the radial base", "tags": ["treelogarithmicpolarinfinite"], "likes": 10, "viewed": 106, "date": "1628469898", "time_retrieved": "2024-06-20T20:47:23.148023", "image_code": "#define SS 3.0  //super sampling\n\n#define iR iResolution\n\nconst float PI = 355./113.;\n\nvec2 rotate(vec2 p, float a) {return vec2 (cos(a)*p.x-sin(a)*p.y,sin(a)*p.x+cos(a)*p.y);}\n\nvec4 obj2(vec2 uv)\n{\n    float time = pow(3.0,iTime);\n    uv*=1.5*(iR.x/iR.y);                                      //scale to screen\n    uv.xy = rotate(uv.xy,.05*sin(iTime+atan(uv.x,uv.y)*4.));  //wavy motion \n    float s = sign(uv.x);\n    uv.x=abs(uv.x);                                           //mirror x-axis\n    \n    float a = length(uv)+.5;                        //pixel distance from center\n    if(a>2.0)return vec4(0,0,0,0);                  //mask values beyond infiniti\n    float my = iMouse.y/iR.y;                       //mouse control y-axis\n    my=(iMouse.z>0.0)?1.0-pow(1.0-(my*.3),10.0):.6; \n    float rad = log(2.0-a)/log(my)+1.0;             //number of rings grows logarithmically\n    float am = floor(rad);                          //quantize radius into discrete rings\n    \n    float am2 = pow(2.0,am);                  //number of divisions grows exponentially as rings get larger\n    float mx = iMouse.x/iR.x;                 //mouse control x-axis\n    am2*=(iMouse.z>0.0)?pow(mx,10.0)*10.0:.7;                   \n    float circ = atan(uv.x,uv.y)*am2;         //pixel angle\n    float b0 = round(circ);                   //quantize circumference into discrete slices\n    \n    float u = circ-b0;\n    float v = 1.0-fract(rad);\n    float g = 1.0-2.0*mod(floor(b0),2.0); //two groups (1 and -1)\n    return vec4(u*s+.5,v,1.0,g);\n}\n\nvec4 get_color(vec2 p)\n{\n    vec4 F;\n    vec4 obj = obj2(p);\n    vec2 uv = obj.xy;\n    uv.y=-uv.y;\n    F=texture(iChannel0,fract(uv));\n    \n    F=pow(F,vec4(2.2));\n    F*=obj.z;\n    if(obj.w>0.0)F=vec4(.03,0,0,1.0);\n    return F;\n}\n\nvoid mainImage( out vec4 F, in vec2 C )\n{  \n    F=vec4(0);\n    vec2 uv = (C-vec2(iR.x*.5,0))/iR.xy; //bottom center of screen = (0,0)\n    uv.y*=iR.y/iR.x;                     //square pixels\n    \n    for(float y = 0.0; y < SS; y++) //super sampling\n    {\n        for(float x = 0.0; x < SS; x++)\n        {\n            F+=get_color(uv+vec2((x/SS)/iR.x,(y/SS)/iR.x));\n        }\n    }\n    \n    F/=SS*SS;\n    F=pow(F,vec4(1./2.2));\n    \n    \n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ft2SRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[87, 87, 117, 117, 176], [178, 178, 198, 198, 1528], [1530, 1530, 1554, 1554, 1761], [1763, 1763, 1804, 1804, 2201]]}
{"id": "ft2SRK", "name": "MRR_RaymarchedAnimatedGrid", "author": "MiguelRodRic", "description": "Grid of raymarched boxes animated using noise", "tags": ["raymarching", "noise", "box"], "likes": 4, "viewed": 62, "date": "1628083328", "time_retrieved": "2024-06-20T20:47:24.008823", "image_code": "#define MAXSTEPS 100\n#define MAXDISTANCE 32.0\n#define HITDISTANCE 0.005\n#define SURFACEOFFSET 0.1\n#define GRIDWIDTH 8\n#define GRIDDEPTH 8\n\nvec3 boxes[GRIDWIDTH * GRIDDEPTH];\n\n\n////////////////\n// From Iñigo Quilez's Value Noise shader -> https://www.shadertoy.com/view/lsf3WH\nfloat hash(vec2 p)  \n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n////////////////\n\nvoid UpdateBoxGrid(vec4 timeParams)\n{\n    vec2 noiseAspectRatio = vec2(iResolution.x/iResolution.y,1.0);\n    \n    int halfwidth = GRIDWIDTH / 2;\n    for (int x = 0; x < GRIDWIDTH; ++x)\n    {\n        for (int y = 0; y < GRIDDEPTH; ++y)\n        {\n            //Using noise texture \n            \n            //vec2 noiseUV1 = vec2(y,x) * timeParams.z;\n            //vec2 noiseUV2 = vec2(x,y) * timeParams.w;\n            //vec4 noiseTex1 = texture(iChannel3, noiseUV1);\n            //vec4 noiseTex2 = texture(iChannel3, noiseUV2);\n            //float noiseA = noiseTex1.x * noiseTex1.x * 0.4;\n            //float noiseB = noiseTex2.x * noiseTex1.x * 0.4;\n            //vec3 box = vec3((x - halfwidth) * 2, (((noiseA + noiseB)) * float(y)), y * 2);\n\n            //Using IQ's runtime noise\n            \n            vec2 noiseUV = vec2(x,y) * noiseAspectRatio;\n            vec3 box = vec3((x - halfwidth) * 2, 1.0 - (timeParams.x * noise(noiseUV * vec2(4.0)) + timeParams.y * noise(noiseUV * vec2(2.0))) * 0.2 * float(y), y * 2);\n            \n            boxes[(x * GRIDWIDTH) + y] = box;\n        }\n    }     \n}\n\nfloat GetDistanceToBox(vec3 point, vec3 center, float side)\n{\n    vec3 pointTransformed = point - center;\n    float distance = length(max(abs(pointTransformed) - side, .0));\n    \n    return distance;\n}\n\nfloat GetDistanceToSphere(vec3 point, vec3 center, float radius)\n{\n    float distance = length(point - center.xyz) - radius;\n    return distance;\n}\n\nfloat GetDistance(vec3 point)\n{\n    vec4 sphere = vec4(0.0, 2.4, 2.0, 0.3);\n    \n    float sphereDistance = GetDistanceToSphere(point, sphere.xyz, sphere.w);\n    \n    float planeDistance = point.y; //Plane is axis-aligned with y = 0\n    float distance = min(planeDistance, sphereDistance);\n    \n        \n    //Animated Box grid\n    for (int x = 0; x < GRIDWIDTH; ++x)\n    {\n        for (int z = 0; z < GRIDDEPTH; ++z)\n        {\n            float boxDistance = GetDistanceToBox(point, boxes[(x * GRIDWIDTH) + z], 0.95); \n\n            distance = min(boxDistance, distance);\n        }\n    }    \n    \n    return distance;\n}\n\nfloat RayMarch(vec3 rOrigin, vec3 rDirection)\n{\n    float distanceFromOrigin = 0.0;\n    \n    for(int i = 0; i < MAXSTEPS; ++i)\n    {\n        vec3 p = rOrigin + rDirection * distanceFromOrigin;\n        float distanceToScene = GetDistance(p);\n        distanceFromOrigin += distanceToScene;\n        \n        if (distanceFromOrigin > MAXDISTANCE || distanceToScene < HITDISTANCE) break;\n    }\n    \n    return distanceFromOrigin;\n}\n\nvec3 GetNormal(vec3 point)\n{\n    float distance = GetDistance(point);\n    vec2 offset = vec2(0.01, 0.0);\n    \n    vec3 normal = distance - vec3(GetDistance(point - offset.xyy), GetDistance(point - offset.yxy),  GetDistance(point - offset.yyx));\n        \n    return  normalize(normal);\n}\n\nfloat GetLight(vec3 point)\n{\n    vec3 lightPosition = vec3(5.0 * sin(iTime), 5.0, 4.0 + cos(iTime) * 6.0);\n    vec3 lightDirection = normalize(lightPosition - point);\n    vec3 surfaceNormal = GetNormal(point);\n    \n    float diffuse = clamp(dot(surfaceNormal, lightDirection), 0.0, 1.0);\n    \n    float shadow = RayMarch(point + (surfaceNormal * SURFACEOFFSET), lightDirection);\n    \n    diffuse -= step(shadow, length(lightPosition - point)) * 0.9;\n    \n    return diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 rOrigin = vec3(0.0, 3.0, 0.0);\n    vec3 rDirection = normalize(vec3(uv.x, uv.y - 0.5, 1.0));\n\n    //Time Params    \n    float timeSin = sin(iTime);\n    float timeCos = cos(iTime);\n    float timeSinUV = sin(iTime * 0.15) * 0.003;\n    float timeCosUV = cos(iTime * 0.15) * 0.002;\n    vec4 timeParams = vec4(timeSin, timeCos, timeSinUV, timeCosUV);\n    \n    //Animate Box Grid\n    UpdateBoxGrid(timeParams);\n        \n    //Raymarching\n    float d = RayMarch(rOrigin, rDirection);\n\n    vec3 point = rOrigin + rDirection * d;\n    \n    float diffuseLight = clamp(GetLight(point), 0.1, 0.9);\n    \n    vec3 col = vec3(diffuseLight, 0.0, 0.0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ft2SRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[176, 277, 299, 299, 403], [405, 405, 431, 431, 725], [727, 745, 782, 782, 1849], [1851, 1851, 1912, 1912, 2052], [2054, 2054, 2120, 2120, 2201], [2203, 2203, 2234, 2234, 2822], [2824, 2824, 2871, 2871, 3250], [3252, 3252, 3280, 3280, 3538], [3540, 3540, 3568, 3568, 4016], [4018, 4018, 4075, 4125, 4902]]}
{"id": "ft2XRV", "name": "Static - random", "author": "voler", "description": "Static effect using a lightweight random number generator function.", "tags": ["random", "static"], "likes": 3, "viewed": 60, "date": "1628106878", "time_retrieved": "2024-06-20T20:47:24.166276", "image_code": "float GetRandom(float extent, vec2 vertex)\n{\n    float a =  iTime + vertex.x * 1.2 + vertex.y * 17.21;\n    float multiplier = fract(a);\n    float b = (a * 3.0 + 1.0) * multiplier + (1.0 - multiplier) * a * 0.5f;\n    multiplier = fract(b);\n    a = (b * 3.0 + 1.0) * multiplier + (1.0 - multiplier) * b * 0.5f;\n    return mod(a, extent);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float random = GetRandom(256.0, fragCoord) * 0.00390625/*(1/256)*/;\n    fragColor = vec4(random,random,random,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ft2XRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 44, 44, 337], [339, 339, 396, 396, 518]]}
{"id": "ft2XWw", "name": "The Fly", "author": "dean_the_coder", "description": "The Fly was one of the first 'horror' movies I saw (waaay too young...).\nI think the unsung hero in the movie is the fly itself. This is a tribute to that little performer.\nIf anyone has tips to speed up compile time they'd be most welcome!", "tags": ["3d", "raymarching", "glow", "movie", "cineshader"], "likes": 22, "viewed": 958, "date": "1627821460", "time_retrieved": "2024-06-20T20:47:25.608881", "image_code": "// 'The Fly' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/ft2XWw\n//  YouTube HD: https://youtu.be/Vq-9sCiXFLo\n// YouTube 360: https://youtu.be/wJyUM3pxl7I\n//\n// Processed by 'GLSL Shader Shrinker' (Shrunk by 1,642 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// The Fly was one of the first 'horror' movies I saw (waaay\n// too young...). An awesome movie!\n// I think the unsung hero in the movie is the fly itself.\n// This is a tribute to that little performer.\n//\n// Tricks to get the performance:\n// - As always, making use of abs() to reflect objects.\n//   (There's only one window pane, and one horizontal pipe\n//   on the wall - The others are mirrored.)\n// - There's only one point light. The extra whiteness inside\n//   the 'pod' is faked in the material code.\n// - I tend to avoid using Shadertoy's textures.\n//   This is partly due to performance, but mostly because I'm\n//   a bit of a purist and like the idea of 'everything you\n//   see is generated in real time'. Although using that wood\n//   texture is always very tempting! :)\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// Blackle and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S01(a)\tsmoothstep(0., 1., a)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n\nfloat t,\n      g = 0.;\n\n#define HASH\tp = fract(p * .1031); p *= p + 3.3456; return fract(p * (p + p));\n\nvec4 h44(vec4 p) { HASH }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(h44(h), h44(h + s.x), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\nfloat fbm(vec3 p) {\n\tfloat i,\n\t      a = 0.,\n\t      b = .5;\n\tfor (i = Z0; i < 4.; i++) {\n\t\ta += b * n31(p);\n\t\tb *= .5;\n\t\tp *= 2.;\n\t}\n\n\treturn a * .5;\n}\n\n#define minH(a)\tif (a.x < h.x) h = a\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.y -= clamp(p.y, 0., h);\n\treturn length(p) - r;\n}\n\nfloat tor(vec3 p, vec2 t) {\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n\nfloat link(vec3 p, float le, float r1, float r2) {\n\tvec3 q = vec3(p.x, max(abs(p.y) - le, 0.), p.z);\n\treturn length(vec2(length(q.xy) - r1, q.z)) - r2;\n}\n\nfloat pod(vec3 p, bool isDr, out float w) {\n\tfloat d, dr,\n\t      s = step(3.25, p.y),\n\t      a = atan(p.x, p.z);\n\tw = (max(0., p.y - 1.) + sat(1. - p.y)) * .25 + s * .1;\n\td = max(cap(p, 3.2, 1.5 - sqrt(w * w + .001)), -p.y);\n\tw = d;\n\tdr = p.y * .09 - 1.3 - p.z - S(2.3, 3.3, p.y) - S(.3, 1.5, abs(p.x));\n\tif (isDr) return max(d, -dr);\n\td -= .15 * sat(sin(p.y * 30.)) * (1. - s) * step(1., p.y) + sat(sin(a * 25.) * .1 * s) * step(p.y, 3.5);\n\treturn isDr ? max(w, -dr) : max(max(d, dr), dr);\n}\n\nvec2 map(vec3 p) {\n\tvec2 h = vec2(p.y, 2);\n\tfloat d, podd,\n\t      w = t * 4.;\n\tvec3 pp = vec3(cos(w) * cos(w * 1.3) * .5, 1.5 + sin(w * .5) * .5, -6. * (S(10., 5., t) + S(32., 40., t)));\n\tpp = mix(pp, vec3(0, .3, 0), sat(S(16., 20., t) - S(28., 32., t)));\n\tminH(vec2(length(p - pp) - .02, 1));\n\tminH(vec2(8. - p.z, 4));\n\tpp = p;\n\tpp.x++;\n\tpp.y -= 3.3;\n\td = max(min(abs(4.5 - pp.z) - .5, 18. - p.x), -box(pp, vec3(1.26, 2.12, 4.6)));\n\tpp.xy = abs(abs(pp.xy) - vec2(.64, 1.08)) - vec2(.32, .54);\n\td = max(d, -box(pp, vec3(.3, .5, 9)));\n\tminH(vec2(d, 3));\n\tpp = p - vec3(7, 1, 0);\n\tminH(vec2(cyl(pp - vec3(0, .3, 1.2), vec2(S01(2. - pp.y), .1) * .8), 5));\n\tw = .05 * step(p.y, 1.5);\n\td = box(pp, vec3(2. - w, .7, 1. - w));\n\tpp.x = abs(pp.x) - 1.5;\n\tpp.y += .7;\n\td = min(d, box(pp, vec3(.05, .2, .8)) - .1);\n\tminH(vec2(d, 8));\n\tpp = p.zxy;\n\tpp.x -= 4.1;\n\tpp.y -= 1.4;\n\td = length(pp.xy + vec2(.5, 5.1)) - .16 - .03 * step(abs(cos(pp.z)), .05);\n\tpp.z = abs(pp.z - .4) - .15;\n\td = min(d, link(pp, 4., .5, .1));\n\tp.z--;\n\tpp = p;\n\tw = S(15., 12., t) + S(23., 26., t);\n\tpp.x += pow(sin(w * 1.6), 4.);\n\tpp.z += S(.7, 0., abs(w * 1.7 - 1.) - .3) * .3;\n\tminH(vec2(pod(pp, true, w), 7));\n\td = min(d, pod(p, false, podd) * .9);\n\tw = .05 + abs(.01 * sin((p.y - abs(p.x)) * 36.));\n\tp.yz++;\n\td = min(min(d, link(p, .5, 1.5, w)), link(p, .5, 1.2, w));\n\tp.y -= 1.7;\n\tp.z -= .3;\n\td = max(min(d, max(max(tor(p, vec2(.9, .7)), -p.z), tor(p - vec3(0, -.7, 0), vec2(1)))), -podd - .06);\n\tminH(vec2(d, 6));\n\td = max(length(p.xz) - .4, abs(p.y + .6) - .01);\n\tminH(vec2(d, 0));\n\tw = 1.;\n\tif (t > 16.) {\n\t\tif (t < 19.) w = .001 + .02 * (.5 + .5 * sin(t * 6.));\n\t\telse if (t < 23.) w = step(fbm(vec3(1, 1, t * 10.)), .2);\n\t}\n\n\tg += .005 / (.1 + d * d * 1e2 * w);\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .2;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).x;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld) {\n\tfloat i, h,\n\t      s = 1.,\n\t      t = .1;\n\tfor (i = Z0; i < 30.; i++) {\n\t\th = map(t * ld + p).x;\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > 18.) break;\n\t}\n\n\treturn sat(s);\n}\n\nfloat ao(vec3 p, vec3 n, float h) { return map(h * n + p).x / h; }\n\nfloat fog(vec3 v) { return exp(dot(v, v) * -.002) * S(12., 6., v.y); }\n\nvec3 lights(vec3 p, vec3 rd, float d, vec2 h) {\n\tif (h.y == 1.) return vec3(.01);\n\tvec3 ld = normalize(vec3(2, 4, -1) - p),\n\t     n = N(p, d),\n\t     c = vec3(.2);\n\tfloat lig,\n\t      hs = 0.,\n\t      gg = g;\n\tif (h.y == 3.) c -= n31(p * .8) * .06;\n\telse if (h.y == 6.) c = vec3(.5 - .18 * n31(p * 26.)) * .3 * (1. + 6. * step(length(p - vec3(0, 1.5, 2)), 1.7));\n\telse if (h.y == 2.) c = mix(vec3(.04, .02, .02), vec3(.06, .04, .02), n21(p.xz * vec2(2.3, 30)));\n\telse if (h.y == 0.) c = vec3(1.2);\n\telse if (h.y == 4.) {\n\t\tc = vec3(.1, .2, .3) * (.24 - rd.y) * .6 + .01;\n\t\ths++;\n\t}\n\telse if (h.y == 5.) c = vec3(.15, .01, .02);\n\n\tfloat ao = mix(ao(p, n, 1.), ao(p, n, 2.), .7),\n\t      l1 = sat(.1 + .9 * dot(ld, n)) * (.3 + .7 * sat(hs + shadow(p, ld))) * (.3 + .7 * ao),\n\t      l2 = sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .3 + pow(sat(dot(rd, reflect(ld, n))), 10.),\n\t      fre = S(.7, 1., 1. + dot(rd, n)) * .5;\n\tlig = l1 + l2 * ao;\n\tg = gg;\n\treturn mix(lig * c * vec3(2, 1.6, 1.5), vec3(.01), fre);\n}\n\nvec4 march(inout vec3 p, vec3 rd, float s) {\n\tfloat i,\n\t      d = .01;\n\tg = 0.;\n\tvec2 h;\n\tfor (i = Z0; i < s; i++) {\n\t\th = map(p);\n\t\tif (abs(h.x) < .0015) break;\n\t\td += h.x;\n\t\tif (d > 25.) return vec4(0);\n\t\tp += h.x * rd;\n\t}\n\n\treturn vec4(g + lights(p, rd, d, h), h.y);\n}\n\nvec3 scene(vec3 rd) {\n\tvec3 p = vec3(0);\n\tp -= vec3(1, -2. + t * .0125, 5.5 - t / 40.);\n\tvec4 col = march(p, rd, 80.);\n\tcol.rgb *= fog(p);\n\tif (col.w >= 6.) {\n\t\tfloat lp = length(p);\n\t\tvec3 n = N(p, lp);\n\t\tif (col.w == 7.) {\n\t\t\trd = refract(rd, n, 1.);\n\t\t\tp -= n * .3;\n\t\t\tcol += march(p, rd, 32.) * fog(p);\n\t\t\tcol *= .5;\n\t\t\tn = N(p, lp);\n\t\t}\n\n\t\trd = reflect(rd, n);\n\t\tp += n * .01;\n\t\tcol += .1 * march(p, rd, 32.) * fog(p);\n\t}\n\n\treturn col.rgb;\n}\n\n#define rgba(col)\tvec4(pow(max(vec3(0), col), vec3(.45)) * sat(t), 0)\n\nvoid mainVR(out vec4 fragColor, vec2 fc, vec3 ro, vec3 rd) {\n\tt = mod(iTime, 40.);\n\trd.xz *= mat2(1, 0, 0, -1);\n\tfragColor = rgba(scene(rd));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tt = mod(iTime, 40.);\n\tvec2 q = fc.xy / R.xy,\n\t     uv = (fc - .5 * R.xy) / R.y;\n\tvec3 f = normalize(vec3(mix(.5, .33, S(1., 10., t)), 0, 1)),\n\t     r = normalize(cross(vec3(0, 1, 0), f)),\n         col = scene(normalize(f + r * uv.x + cross(f, r) * uv.y));\n\tcol *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\tfragColor = rgba(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ft2XWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1223, 1572, 1590, 1590, 1597], [1599, 1599, 1618, 1618, 1863], [1865, 1865, 1884, 1884, 1910], [1912, 1912, 1931, 1931, 2063], [2103, 2103, 2130, 2130, 2217], [2219, 2219, 2247, 2247, 2347], [2349, 2349, 2386, 2386, 2438], [2440, 2440, 2467, 2467, 2535], [2537, 2537, 2587, 2587, 2690], [2692, 2692, 2735, 2735, 3184], [3186, 3186, 3204, 3204, 4932], [4934, 4934, 4959, 4959, 5178], [5180, 5180, 5211, 5211, 5402], [5404, 5404, 5439, 5439, 5470], [5472, 5472, 5491, 5491, 5542], [5544, 5544, 5591, 5591, 6551], [6553, 6553, 6597, 6597, 6824], [6826, 6826, 6847, 6847, 7272], [7345, 7345, 7405, 7405, 7488], [7490, 7490, 7535, 7535, 7888]]}
{"id": "ftBSR3", "name": "MRR_SoftShadow_BlueNoise", "author": "MiguelRodRic", "description": "Soft Shadow sample using raymaching for the shapes, cone tracing for the shadows, and blue noise to mitigate color banding.", "tags": ["softshadows", "bluenoise"], "likes": 3, "viewed": 46, "date": "1628161629", "time_retrieved": "2024-06-20T20:47:26.476197", "image_code": "//CHEAPER VERSION OF -> https://www.shadertoy.com/view/stjSzV\n\n//REDUCING THE SHADOW RAY SAMPLE COUNT TO 1/4 OF THE ORIGINAL\n//QUITE BETTER PERFORMANCE BUT AT THE EXPENSE OF VISUAL QUALITY (COLOR BANDING IN THE PENUMBRA AREA)\n//USING BLUE NOISE TO TRY TO MITIGATE THE BANDING\n\n#define MAXSTEPS 100\n#define MAXDISTANCE 100.0\n#define HITDISTANCE 0.01\n#define SURFACEOFFSET 0.1\n#define HSHADOWSAMPLES 4\n#define SAMPLINGWEIGHT 0.015625\n//SAMPLINGWEIGHT == 1 / (HSHADOWSAMPLES * 2 * HSHADOWSAMPLES * 2)\n#define SHADOWOFFSET 0.015\n\nfloat GetDistanceToSphere(vec3 point, vec3 center, float radius)\n{\n    float distance = length(point - center.xyz) - radius;\n    return distance;\n}\n\nfloat GetDistanceToTorus(vec3 point, vec3 torusCenter, float radiusA, float radiusB)\n{\n    vec3 pointTransformed = point - torusCenter;\n    float x = length(pointTransformed.xz) - radiusA; //torus is aligned to the X-Z plane\n    float y = pointTransformed.y;\n    float distance = length(vec2(x,y)) - radiusB;\n    \n    return distance;\n}\n\nfloat GetDistanceToCapsule(vec3 point, vec3 capsuleA, vec3 capsuleB, float radius)\n{\n    vec3 AB = capsuleB - capsuleA;\n    vec3 AP = point - capsuleA;\n    \n    float t = clamp(dot(AB, AP) / dot(AB, AB), 0.0, 1.0);\n    \n    vec3 closestPoint = capsuleA + t * AB;\n    float distance = length(point - closestPoint) - radius;\n    \n    return distance;\n}\n\nfloat GetDistance(vec3 point)\n{\n    vec4 sphere = vec4(2.5, 1.0, 5.0, 1.0); //center + radius\n    \n    vec3 capsuleA = vec3(-2.5, 1.5, 5.0); //centerA\n    vec3 capsuleB = vec3(-2.5, 0.5, 5.0); //centerB\n    \n    float planeDistance = point.y; //Plane is axis-aligned with y = 0\n    \n    float sphereDistance = GetDistanceToSphere(point, sphere.xyz, sphere.w);\n    \n    float capsuleDistance = GetDistanceToCapsule(point, capsuleA, capsuleB, 0.5);\n    \n    float torusDistance = GetDistanceToTorus(point, vec3(0.0, 0.5, 6.0), 0.8, 0.3);\n       \n    \n    float distance = min(sphereDistance, planeDistance);\n    distance = min(distance, capsuleDistance);\n    distance = min(distance, torusDistance);\n    \n    return distance;\n}\n\nfloat RayMarch(vec3 rOrigin, vec3 rDirection)\n{\n    float distanceFromOrigin = 0.0;\n    \n    for(int i = 0; i < MAXSTEPS; ++i)\n    {\n        vec3 p = rOrigin + rDirection * distanceFromOrigin;\n        float distanceToScene = GetDistance(p);\n        distanceFromOrigin += distanceToScene;\n        \n        if (distanceFromOrigin > MAXDISTANCE || distanceToScene < HITDISTANCE) break;\n    }\n    \n    return distanceFromOrigin;\n}\n\nvec3 GetNormal(vec3 point)\n{\n    float distance = GetDistance(point);\n    vec2 offset = vec2(0.01, 0.0);\n    \n    vec3 normal = distance - vec3(GetDistance(point - offset.xyy), GetDistance(point - offset.yxy),  GetDistance(point - offset.yyx));\n        \n    return  normalize(normal);\n}\n\nfloat GetLight(vec3 point, vec2 screenUV)\n{\n    vec3 lightPosition = vec3(3.0 * sin(iTime), 4.5, 5.0 + cos(iTime) * 3.0);\n    vec3 lightDirection = normalize(lightPosition - point);\n    vec3 surfaceNormal = GetNormal(point);\n    \n    float diffuse = clamp(dot(surfaceNormal, lightDirection), 0.0, 1.0);\n    \n    //Using blue noise texture to reduce banding  \n    float blueNoise = texture(iChannel3, screenUV + iTime).x;\n    \n    //Basic Cone Tracing\n    float shadow = 0.0;\n    for (int x = -HSHADOWSAMPLES; x < HSHADOWSAMPLES; ++x)\n    {\n        for (int z = -HSHADOWSAMPLES; z < HSHADOWSAMPLES; ++z)\n        {\n            float shadowRay = RayMarch(point  + (surfaceNormal * SURFACEOFFSET), vec3(lightDirection.x + (float(x) * SHADOWOFFSET), lightDirection.y, lightDirection.z + (float(z) * SHADOWOFFSET)));\n            shadow += float(step(shadowRay, length(lightPosition - point)));\n        }\n    }\n        \n    //Using blue noise only in penumbra area\n    \n    float finalShadow = shadow;\n    if (shadow < float(HSHADOWSAMPLES * 2 * HSHADOWSAMPLES * 2) && shadow > 0.0)\n    {\n        finalShadow = shadow * SAMPLINGWEIGHT * 2.0; //extra weight to compensate the multiplication by the noise\n        finalShadow = mix(finalShadow, blueNoise * finalShadow, 0.5);\n    }\n    else\n    {\n        finalShadow = shadow * SAMPLINGWEIGHT;\n    }\n    \n    //Using blue noise in the whole shadow\n    \n    //float finalShadow = shadow * SAMPLINGWEIGHT * 2.0;\n    //finalShadow = mix(finalShadow, blueNoise * finalShadow, 0.8);\n    \n    diffuse -= finalShadow * 0.9;\n    \n    return diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 rOrigin = vec3(0.0, 8.0, -2.0);\n    vec3 rDirection = normalize(vec3(uv.x, uv.y - 1.0, 1.0));\n\n    float d = RayMarch(rOrigin, rDirection);\n\n    vec3 point = rOrigin + rDirection * d;\n    \n    float diffuseLight = GetLight(point, uv);\n    \n    vec3 col = vec3(diffuseLight);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ftBSR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[432, 526, 592, 592, 673], [675, 675, 761, 761, 1011], [1013, 1013, 1097, 1097, 1363], [1365, 1365, 1396, 1396, 2090], [2092, 2092, 2139, 2139, 2518], [2520, 2520, 2548, 2548, 2806], [2808, 2808, 2851, 2851, 4391], [4393, 4393, 4450, 4500, 4913]]}
{"id": "ftBSWd", "name": "firebug particles", "author": "jcyuan", "description": "flying firebug particles.\nI don't know why CloudSound does not work now so I did not add a bgm for it...\n", "tags": ["hash", "particle"], "likes": 7, "viewed": 317, "date": "1628852459", "time_retrieved": "2024-06-20T20:47:26.476197", "image_code": "// hash functions from https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n// ------------------------------------------------------------------------\n\nvec3 color(float t) {\n    // from IQ's color pattern formula\n    return .3 + .7 * cos(6.283 * (vec3(1., .5, .0) * (1. - t) + vec3(.7, .75, .3)));\n}\n// ------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    uv.y += .9;\n\t\n    vec3 col = vec3(0.);\n    float time = iTime * .5;\n\n    for (int i = 0; i < 30; i++) {\n        float sd = time + float(i) * 3303.1031;\n        float id = floor(sd);\n        float t = sd - id;\n        \n        float rnd = hash11(id);\n        vec2 p = hash21(id);\n        \n        p.y *= -t * (rnd + .5) - .5;\n        p.x *= rnd > .5 ? -1. : 1.;\n        \n        float size = rnd * .0075 + .00025;\n        float flicker = hash11(t * .5) * .0015;\n        \n        float cycle = rnd * 8.;\n        float w = p.x * .3 - p.x * p.y * .45;\n        float d = (size + flicker) / length(uv + vec2(cos(sd * cycle - abs(t) * 2.) * w, p.y));\n\n        col += color(rnd) * d;\n    }\n    \n    col = pow(col, vec3(1.9));\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ftBSWd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 61, 83, 83, 211], [213, 213, 236, 236, 321], [322, 399, 420, 459, 546], [547, 624, 679, 679, 1507]]}
{"id": "ftBSzc", "name": "Hello noise", "author": "N4M3L355", "description": "yeet", "tags": ["simplex"], "likes": 4, "viewed": 45, "date": "1628189172", "time_retrieved": "2024-06-20T20:47:27.215011", "image_code": "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20201014 (stegu)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+10.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float epsilon = 0.01;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.0,0.0,0.0);\n    if(abs(snoise(vec3(uv.xy*4.0,iTime/4.0))-0.1)<epsilon) {\n    col = vec3(\n    snoise(vec3(uv.xy*10.0,iTime*1.02/2.0+65536.0))/2.0+0.5,\n    snoise(vec3(uv.xy*10.0,iTime/2.0))/2.0+0.5,\n    snoise(vec3(uv.xy*10.0,iTime*1.04/2.0+32768.0))/2.0+0.5);\n    }\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/ftBSzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 452, 473, 473, 522], [524, 524, 545, 545, 594], [596, 596, 618, 618, 659], [661, 661, 689, 689, 741], [743, 743, 767, 767, 2914], [2917, 2917, 2974, 2974, 3537]]}
{"id": "ftBSzV", "name": "sound spiral by  liners", "author": "Liners", "description": "spiral reacting on sound ", "tags": ["spiralmusic"], "likes": 2, "viewed": 74, "date": "1628032309", "time_retrieved": "2024-06-20T20:47:27.215011", "image_code": "void mainImage( out vec4 O, vec2 I ) {\n    float N = 10.;\n    vec2 uv = (I.xy / iResolution.xy);\n    int tx = int(uv.y);\n    float react = texelFetch( iChannel0, ivec2(tx,0), 0 ).x*0.05;\n    I = (I+I-(O.xy=iResolution.xy))/O.y;\n    float r = length(I);\n    float a = atan(I.y,I.x);\n    a -= 100.*(react+2.+.1*iTime)-100.*r;\n    r +=  (0.5+sin(a+.15*react)/.15*cos(a))/ N-react ;    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,3,6));\n\tO = (1.-r)*vec4(col*0.1+30.*react*col,1.);\n}", "image_inputs": [{"id": "XlfSD2", "previewfilepath": "https://soundcloud.com/braves_only/5hvrmvn-malo-braves-only-remix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/braves_only/5hvrmvn-malo-braves-only-remix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ftBSzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 38, 38, 484]]}
{"id": "ftjSRd", "name": "Glowey Cubic Flower", "author": "scry", "description": "Same code as the previous cubes shader, playing with domain repetition and glow effects", "tags": ["3d"], "likes": 4, "viewed": 168, "date": "1628390511", "time_retrieved": "2024-06-20T20:47:27.839297", "image_code": "#define time iTime*0.6\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n//from iqs sdf functions page\nvec3 opRepLim( in vec3 p, in float c, in vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return q;\n    //return primitive( q );\n}\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n//Taken from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl.\n\nvec4 map(vec3 p) {\n    float pd = 1.;\n    //p.z += time*2.1;\n    vec3 o = p;\n    float c = length(p);\n    //p.xy *= r2d(sin(time*1.)+time);\n    //p.xz *= r2d(sin(time*1.+c*13.));\n    p.xy *= r2d(sin(c*50.+time)*0.2);\n    //p = (fract(p*pd)-0.5)/pd;\n    //float ramnt = clamp((sin(time*1.)),0.,1.);\n    float rt = time*0.5;\n    float ramnt = sin((3.14159/2.)*cos(rt)+rt);\n    ramnt -= 1.;\n    p.xz *= r2d(sin(c*0.5+time*0.3)*4.*ramnt);\n    p.yz *= r2d(cos(c*0.5+time*0.3)*4.*ramnt);\n    p.xy = vec2(length(p.xy),atan(p.x,p.y));\n    //p.y = abs(p.y);\n    //p.y *= 8./3.14159;\n    p.y *= 1./3.1415;\n    p.y *= (sin(time*0.13-2.)*0.5+0.5)*10.;\n    p.y *= 0.5;\n    p.y += p.z*sin(time);\n    p.y = (fract(p.y)-0.5);\n    p.y = abs(p.y);\n    p.xy = vec2(p.x*sin(p.y),p.x*cos(p.y));\n    p = opRepLim(p,0.21,vec3(1.));\n    p.xz *= r2d(sin(time*1.+c*13.));\n    p = opRepLim(p,0.018,vec3(2.));\n    p.xy *= r2d(sin(time*1.)+time);\n    p = opRepLim(p,mix(0.01,0.003,(sin(time*0.35+15.)*0.5+0.5)),vec3((0.5-c)*10.));\n\n    float d = length(p)+0.005*sin(time*0.1+c*5.);\n    return vec4(p,d);\n}\n\n\n\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    \n    for (int i=0;i<200;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w;\n        dO += dS*0.5;\n        ii += 0.1;\n        if (dS < 0.001 || dO > 1000.) {break;}\n    }\n    return vec2(dO,ii);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = -1. + 2.* fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    //vec2 uv = -1. + 2. * inData.v_texcoord;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    uv.x *= ar;\n    vec3 col = vec3(0.);\n    float c = length(uv*0.9);\n    //uv *= r2d(c*4.+time);\n    //uv *= r2d(uv.y*time*.1-time*4.3);\n    vec3 ro = vec3(0.,0.,-0.5);\n    //ro.z += time*0.2;\n    vec3 rd = normalize(vec3(uv,1.));\n    vec2 d = RM(ro,rd);\n    \n    //col = sin(uv.xyy*39.);\n    col = vec3((d.y*2.15)-0.3);\n    col = sin(d.yyy*0.1);\n    //col -= d.y*0.3;\n    vec3 hsv = vec3(\n    sin(sin(d.x)*40.)*0.3+time*0.1,\n    sin(d.x*300.)*0.5+0.5,\n    (d.y*0.1)\n    );\n    if (d.x > 100.) {\n        hsv.y *= 0.2;\n    }\n    col = hsv2rgb(hsv);\n    \n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ftjSRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[23, 23, 42, 42, 91], [93, 123, 173, 173, 259], [260, 319, 341, 341, 672], [676, 735, 757, 757, 926], [927, 998, 1016, 1016, 2074], [2078, 2078, 2105, 2105, 2354], [2356, 2356, 2413, 2463, 3291]]}
{"id": "ftjSRt", "name": "Rounded Square - ifurkend", "author": "ifurkend", "description": "How to implement softmax/argmax on ShaderToy?", "tags": ["geometry"], "likes": 2, "viewed": 35, "date": "1628376988", "time_retrieved": "2024-06-20T20:47:27.839297", "image_code": "void mainImage( out vec4 c, in vec2 u )\n{\n    u /= iResolution.xy;\n    u = abs(u * 2. - 1.);\n    u.x *= max(iResolution.x,iResolution.y)/min(iResolution.x,iResolution.y);\n    u *= cos(iTime*.33)*6.+7.;\n    vec2 g = floor(u);\n    u = fract(u);\n    u.x = fract(g.x*.5)==0.?u.x:1.-u.x;\n    u.y = fract(g.y*.5)==0.?u.y:1.-u.y;\n    u *= 1.13;\n    \n    //rounded corner radius:\n    float r = sin(iTime)*.5+.5;\n    \n    float oor  = 1./r;\n    float omr  = 1.-r;\n    float cir  = length(u*oor-oor+1.);\n    float rec1 = max(u.x/omr,u.y);\n    float rec2 = max(u.y/omr,u.x);\n    float rec  = min(rec1,rec2);\n    float less = min(cir,rec);\n    float rs   = less > 1.? 0.:1.;\n\n    c = vec4(1.-rs,rec,cir,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ftjSRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 41, 41, 697]]}
{"id": "ftjSWc", "name": "Noisy Displacement", "author": "kithy", "description": "displacement sphere surface random.", "tags": ["raymarching", "displacement", "hash"], "likes": 0, "viewed": 30, "date": "1628779640", "time_retrieved": "2024-06-20T20:47:27.839297", "image_code": "#define ITR 64\n#define EPS 0.001\n#define PI 3.141592\n\nmat2 rot(float angle){\n\tfloat s=sin(angle);\n\tfloat c=cos(angle);\n\treturn mat2(s,c,-c,s);\n}\n\nfloat hash(vec2 p){\n\treturn fract(sin(dot(p,vec2(43.232,75.876)))*4526.3257);\n}\n\nfloat sdSphere(vec3 p){\n\treturn length(p)-clamp(sin(iTime),0.2,1.0);\n}\n\nfloat sdTorus(vec3 p){\n\tvec2 t=vec2(1.0,0.5);\n\tvec2 q=vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nfloat sdPlane(vec3 p){\n\treturn p.y;\n}\n\nfloat displacement(vec3 p){\n\tp*=hash(vec2(p.x,p.y))*5.0;\n\treturn sin(p.x)*sin(p.y)*sin(p.z);\n}\n\nfloat mainDist(vec3 p){\n\tp.xy*=rot(iTime*0.5);\n\tp.yz*=rot(iTime*0.5);\n\tfloat dis=displacement(p);\n\tfloat d1=sdSphere(p);\n\t//float d2=sdPlane(p);\n\tfloat d3=sdTorus(p);\n\t//return d2;\n\treturn d1+dis;\n}\n\n//generate normal of sphere\n// vec3 genNormal(vec3 p){\n// \treturn normalize(p);\n// }\n\nvec3 genNormal(vec3 p){\n\tvec3 normal=vec3(\n\t\tsdSphere(p+vec3(EPS,0.0,0.0))-sdSphere(p+vec3(-EPS,0.0,0.0)),\n\t\tsdSphere(p+vec3(0.0,EPS,0.0))-sdSphere(p+vec3(0.0,-EPS,0.0)),\n\t\tsdSphere(p+vec3(0.0,0.0,EPS))-sdSphere(p+vec3(0.0,0.0,-EPS))\n\t\t);\n\treturn normalize(normal);\n}\n\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tvec3 ro=vec3(0.0,0.0,-10.0);\n\tvec3 lookat=vec3(0.0,0.0,0.0);\n\tfloat zoom=5.0;\n\n\tvec3 f=normalize(lookat-ro);\n\tvec3 r=normalize(cross(vec3(0.0,1.0,0.0),f));\n\tvec3 u=cross(f,r);\n\tvec3 c=ro+f*zoom;\n\tvec3 i=c+uv.x*r+uv.y*u;\n\tvec3 rd=normalize(i-ro);\n   \n    float d,t;\n    vec3 p,n;\n\n\tvec3 col=vec3(1.0);\n    \n    for(int i=0;i<ITR;i++){\n        p=ro+rd*t;\n        d=mainDist(p);\n        n=genNormal(p);\n        if(d<EPS)break;\n        t+=d;\n    }\n\tcol=n*0.5+0.5;\n\n\tfragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ftjSWc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[54, 54, 76, 76, 144], [146, 146, 165, 165, 225], [227, 227, 250, 250, 297], [299, 299, 321, 321, 405], [407, 407, 429, 429, 444], [446, 446, 473, 473, 540], [542, 542, 565, 565, 740], [742, 828, 851, 851, 1095], [1099, 1099, 1152, 1152, 1700]]}
{"id": "ftjSWy", "name": "Quadtree Octahedrons", "author": "byt3_m3chanic", "description": "Quadtrees - how do they work? Obviously not the way I'm doing it - but looking for some golfing help. Is this Brute Force? Is there a better way? ", "tags": ["raymarching", "quadtree", "branching"], "likes": 18, "viewed": 289, "date": "1628580687", "time_retrieved": "2024-06-20T20:47:27.839297", "image_code": "/**\n    Quadtree Octahedrons\n    @byt3_m3chanic | 08/09/21\n    \n    I dont know how to break space down and do the\n    quad tree thing - so doing some brute force \n    attempts.\n\n*/\n\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\n//@iq\nfloat octa( vec3 p, float s) {\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nmat2 r45,r22;\nvec3 hit,hitPoint;\nvec2 gid,sid;\nfloat time,srnd,grnd;\nvec2 sc = vec2(.0),ssc,gsc;\n\nvec2 map(vec3 p) {\n    p.y+=5.;\n    p.x+=time;\n    vec2 res = vec2(1e5,0);\n    \n    sc = vec2(.25);\n    vec2 bsize = vec2(1.);\n    \n    vec2 id = floor(p.xz*sc) + .5;    \n    vec2 r = p.xz - id/(sc);\n    vec3 q = vec3(r.x,p.y,r.y);\n\n    float rnd = hash21(id);\n    float tn=-1.;\n    if(rnd>.5){\n       sc*=2.;\n       id = floor(q.xz*(sc)) + .5;    \n       r = q.xz - id/(sc);\n       q = vec3(r.x,p.y,r.y);\n       rnd = hash21(id+rnd);\n       tn=0.;\n       if(rnd>.5){\n           sc*=2.;\n           id = floor(q.xz*(sc)) + .5;    \n           r = q.xz - id/(sc);\n           q = vec3(r.x,p.y,r.y);\n           rnd = hash21(id+rnd);\n           if(rnd>.5){\n               sc*=2.;\n               id = floor(q.xz*(sc)) + .5;    \n               r = q.xz - id/(sc);\n               q = vec3(r.x,p.y,r.y);\n               rnd = hash21(id+rnd);\n               if(rnd>.5){\n                   sc*=2.;\n                   id = floor(q.xz*(sc)) + .5;    \n                   r = q.xz - id/(sc);\n                   q = vec3(r.x,p.y,r.y);\n                   rnd = hash21(id+rnd);\n                   tn=1.;\n               }\n           }\n       }\n    }\n    vec3 qs=q;\n    q.xz*=rot(rnd*T*1.5);\n\n    bsize = .375/sc.xx;\n    float b1 = octa(q-vec3(0,bsize.y,0),bsize.x);\n    \n    if(tn==0.){\n        q.xz*=r45;\n        b1 = min(octa(q-vec3(0,bsize.y,0),bsize.x),b1);\n    }\n    if(tn==-1.){\n        q.xz*=r22;\n        b1 = min(octa(q-vec3(0,bsize.y,0),bsize.x),b1);\n        q.xz*=r22;\n        b1 = min(octa(q-vec3(0,bsize.y,0),bsize.x),b1);\n    }\n    \n    if(b1<res.x) {\n        res = vec2(b1,2.);\n    \thit=q;\n        gid=id;\n        grnd=rnd;\n        gsc=sc;\n    }\n\n    float d9 = p.y;\n    if(d9<res.x) {\n        res = vec2(d9,1.);\n    \thit=qs;\n        gid=id;\n        grnd=rnd;\n    }\n    return res;\n}\n\nvec3 normal(vec3 p, float t, float mindist)\n{\n    float e = mindist*t;\n    vec2 h = vec2(1.0,-1.0);\n    return normalize( h.xyy*map( p + h.xyy*e).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e).x );\n}\n\nvec3 hue(float t)\n{ \n    vec3 d = vec3(0.220,0.961,0.875);\n    return .375 + .375*cos(PI2*t*(vec3(.985,.98,.95)+d)); \n}\n\nvec3 render(vec3 p, vec3 rd, vec3 ro, float d, float m, inout vec3 n, inout float fresnel)\n{\n    n = normal(p,d,1.01);\n    vec3 lpos =  vec3(5,4,1);\n    vec3 l = normalize(lpos-p);\n\n    float diff = clamp(dot(n,l),0.,1.);\n    \n    fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 3.);\n    fresnel = mix(.01, .7, fresnel);\n        \n    float shdw = 1.;\n    float t=.0;\n    for(float i=.0;i<24.;i++)\n    {\n        float h = map(p + l*t).x;\n        if( h<1e-4 ) { shdw = 0.; break; }\n        shdw = min(shdw, 18.*h/t);\n        t += h;\n        if( shdw<.01 || t>64. ) break;\n    }\n    diff = mix(diff,diff*shdw,.4);\n\n    vec3 h = vec3(0.914,0.984,0.973);\n    if(m==1.) {\n        float cir = length(hitPoint.xz)-(.15/ssc.x);\n        float of =(.045/ssc.x);\n        float ox =(.015/ssc.x);\n        cir=abs(abs(abs(cir)-of)-of)-ox;\n        cir = smoothstep(.001,.0011,cir);\n        h=mix(vec3(0.561,0.639,0.627),h,1.-cir);\n    }\n\n    if(m==2.) {\n        h=hue(((srnd+fresnel)+hitPoint.z*.05)*3.);\n    }\n    return diff*h;//mix(h,h*shdw,.6);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    // precal\n    time = T*.35;\n    r45=rot(45.*PI/180.);\n    r22=rot(30.*PI/180.);\n    //\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    float zoom = 3.;\n    //orthographic camera\n    vec3 ro = vec3(uv*zoom,-zoom);\n    vec3 rd = vec3(0,0,1.);\n\n    mat2 rx = rot(-0.58539816339);\n    mat2 ry = rot(-0.78539816339);\n    ro.yz *= rx;\n    rd.yz *= rx;\n    ro.xz *= ry;\n    rd.xz *= ry;\n\n    vec3 C = vec3(0);\n    vec3  p = ro + rd;\n    float atten = 1.;\n    float k = 1.;\n    float d = 0.;\n    for(int i=0;i<125;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float m = ray.y;\n\n        d = ray.x*.5;\n        p += rd * d *k;\n        \n        if (d*d < 1e-6) {\n            hitPoint = hit;\n            sid = gid;\n            ssc = gsc;\n            srnd=grnd;\n            float fresnel=0.;\n            C+=render(p,rd,ro,d,ray.y,n,fresnel)*atten;\n            if(m==1.)break;\n            \n            atten *= .65;\n            p += rd*.025;\n            k = sign(map(p).x);\n            \n            vec3 rr = vec3(0);\n            if(int(F.x)%3 != int(F.y)%3) {\n                rr = refract(rd,n,.45);\n                rd=mix(rr,rd,.9-fresnel);\n            }else{\n                vec3 rr=reflect(-rd,n);\n                rd=mix(rr,rd, vec3(.8)-fresnel);\n                p+=n*.05;\n            }\n  \n        } \n       \n        if(distance(p,rd)>75.) { break; }\n    }\n\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ftjSWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 293, 313, 313, 358], [359, 359, 383, 383, 441], [442, 448, 478, 478, 531], [631, 631, 649, 649, 2407], [2409, 2409, 2454, 2454, 2669], [2671, 2671, 2690, 2690, 2790], [2792, 2792, 2884, 2884, 3822], [3824, 3824, 3865, 3879, 5297]]}
{"id": "ftjSzy", "name": "Fork Point Tunn rafaelcast 394", "author": "rafaelcastrocouto", "description": " A 3d point based tunnel effect based off the scene from Second Reality.", "tags": ["3d", "tunnel", "dots", "points", "secondreality"], "likes": 3, "viewed": 71, "date": "1627953456", "time_retrieved": "2024-06-20T20:47:28.415127", "image_code": "//Constants\n#define TAU 6.2831853071795865\n\n//Parameters\n#define TUNNEL_LAYERS 32\n#define RING_POINTS 48\n#define POINT_SIZE 12.0\n#define POINT_COLOR_A vec3(1.0)\n#define POINT_COLOR_B vec3(0.2)\n#define SPEED 0.1\n\n//Square of x\nfloat sq(float x)\n{\n\treturn x*x;   \n}\n\n//Angular repeat\nvec2 AngRep(vec2 uv, float angle)\n{\n    vec2 polar = vec2(atan(uv.y, uv.x), length(uv));\n    polar.x = mod(polar.x + angle / 2.0, angle) - angle / 2.0; \n\n    return polar.y * vec2(cos(polar.x), sin(polar.x));\n}\n\n//Signed distance to circle\nfloat sdCircle(vec2 uv, float r)\n{\n    return length(uv) - r;\n}\n\n//Mix a shape defined by a distance field 'sd' with a 'target' color using the 'fill' color.\nvec3 MixShape(float sd, vec3 fill, vec3 target)\n{\n    float blend = smoothstep(0.0,1.0/iResolution.y, sd);\n    return mix(fill, target, blend);\n}\n\n//Tunnel/Camera path\nvec2 TunnelPath(float x)\n{\n    vec2 offs = vec2(0, 0);\n    \n    offs.x = 0.2 * sin(TAU * x * 0.5) + 0.4 * sin(TAU * x * 0.2 + 0.3);\n    offs.y = 0.3 * cos(TAU * x * 0.3) + 0.2 * cos(TAU * x * 0.1);\n    \n    offs *= smoothstep(1.0,4.0, x);\n    \n    return offs;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    uv -= res/2.0;\n    \n    vec3 color = vec3(0);\n    \n    float repAngle = TAU / float(RING_POINTS);\n    float pointSize = POINT_SIZE/2.0/iResolution.y;\n    \n    float camZ = iTime * SPEED;\n    vec2 camOffs = TunnelPath(camZ);\n    \n    for(int i = 1;i <= TUNNEL_LAYERS;i++)\n    {\n        float pz = 1.0 - (float(i) / float(TUNNEL_LAYERS));\n        \n        //Scroll the points towards the screen\n        pz -= mod(camZ, 4.0 / float(TUNNEL_LAYERS));\n        \n        //Layer x/y offset\n        vec2 offs = TunnelPath(camZ + pz) - camOffs;\n        \n        //Radius of the current ring\n        float ringRad = 0.1 * (1.0 / sq(pz * 0.7 + 0.3));\n        \n        //Only draw points when uv is close to the ring.\n        float d = abs(length(uv + offs) - ringRad);\n             \n        //Angular repeated uv coords\n        vec2 aruv = AngRep(uv + offs, repAngle);\n\n        //Distance to the nearest point\n        float pdist = sdCircle(aruv - vec2(ringRad, 0), pointSize);\n\n        //Distance fade\n        float shade = 1.0 - pz;\n        \n        //0 or 1\n        if (mod(float(i+1 / 2), 2.0) == 0.0) \n        {\n            if(d > pointSize * 1.7 || d < pointSize * 0.3) // 1\n            {\n\n                color = MixShape(pdist + (pz * 0.04), POINT_COLOR_A * shade, color);\n            } \n        } else {\n            if (pdist > pointSize - 0.036)  // 0\n            {\n\n                color = MixShape(pdist + (pz * 0.015), POINT_COLOR_A * shade, color);\n            }\n\n        }\n        \n    }\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ftjSzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[212, 226, 245, 245, 263], [265, 282, 317, 317, 492], [494, 522, 556, 556, 585], [587, 680, 729, 729, 825], [827, 848, 874, 874, 1110], [1112, 1112, 1169, 1169, 2795]]}
{"id": "ftSSWm", "name": "Raytracer < 100 lines", "author": "iothesis", "description": "balling", "tags": ["raytracer", "pathtracer"], "likes": 3, "viewed": 52, "date": "1627770766", "time_retrieved": "2024-06-20T20:47:28.421183", "image_code": "struct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Hit {\n    vec3 normal;\n    float t;\n};\n\nfloat focal = 1.0;\nvec3 origin = vec3(0, 0.0, 2);\n\n\nRay cammapray(vec2 uv) {\n    vec2 siz = vec2((iResolution.x/iResolution.y)*2.0, 2.0);\n\n    vec3 blc = origin-vec3(siz/2., focal);\n    return Ray(\n        origin,\n        vec3(blc.xy+uv*siz, blc.z)-origin\n    );\n}\n\nvec3 camraycolor(Ray ray) {\n    vec3 ndir = normalize(ray.dir);\n    float t = 0.5 * (ndir.y + 1.0);\n    return t*vec3(0.5, 0.7, 1.0) + (1.0-t)*vec3(1.0, 1.0, 1.0);\n}\n\nHit rayvssphere(Ray ray, vec3 center, float radius) {\n    vec3 asubc = ray.pos-center;\n    \n    float a = dot(ray.dir, ray.dir),\n          b = 2.0 * dot(asubc, ray.dir),\n          c = dot(asubc, asubc)-(radius*radius);\n\n    float disc = b*b-4.0*a*c;\n    float t = disc < 0.0 ? -1.0 : (-b - sqrt(disc))/(2.0*a);\n    return Hit((ray.dir*t+ray.pos-center)/radius, t);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 scatter(vec2 seed) {\n    vec3 v = vec3(rand(vec2(seed.x, 0)), rand(vec2(0, seed.y)), rand(seed));\n    v *= 2.0;\n    v -= vec3(1, 1, 1);\n    return normalize(v);\n}\n\nvec3 scene(Ray r) {\n    Hit hit;\n    float mul = 1.0;\n    for (int hits = 0; hits < 3; hits += 1) {\n        Hit hit_list[3] = Hit[3](\n            rayvssphere(r, vec3(cos(iTime), 0, sin(iTime)), 0.5),\n            rayvssphere(r, vec3(-cos(iTime), 0, -sin(iTime)), 0.5),\n            rayvssphere(r, vec3(0, -100.5, -1.0), 100.0)\n        );\n        bool hit_anything = false;\n        \n        for (int i = 0; i < 3; i += 1) {\n            if (hit_list[i].t > 0.0) {\n                if (hit_anything && hit_list[i].t > hit.t) continue;\n                hit_anything = true;\n                hit = hit_list[i];\n            }\n        }\n        \n        if (hit_anything) {\n            vec3 at = hit.t*r.dir+r.pos;\n            r = Ray(at, scatter(r.dir.xy)+hit.normal);\n            mul *= 0.5;\n            continue;\n        }\n        return camraycolor(r)*mul;\n    }\n    return camraycolor(r)*mul;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    origin.y += sin(iTime/2.0)/2.0+0.3;\n    vec3 col = vec3(0, 0, 0);\n    for (int i = 0; i < 30; i += 1) {\n        Ray r = cammapray(uv+vec2(rand(uv+vec2(float(i),uv.x)), rand(uv+vec2(uv.y,float(i))))/iResolution.xy);\n        col += scene(r);\n    }\n    fragColor = vec4(col/30.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ftSSWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[144, 144, 168, 168, 356], [358, 358, 385, 385, 523], [525, 525, 578, 578, 891], [893, 893, 913, 913, 983], [985, 985, 1010, 1010, 1152], [1154, 1154, 1173, 1173, 2041], [2043, 2043, 2100, 2100, 2428]]}
{"id": "ftSXW3", "name": "parametric bounce + drop shadow", "author": "archrona", "description": "not quite right physically but it does sort of bounce", "tags": ["sdf", "bounce"], "likes": 4, "viewed": 60, "date": "1628713372", "time_retrieved": "2024-06-20T20:47:28.421183", "image_code": "\n#define PI 3.1415926535897\n#define DD 0.001\n\nvec4 circle(vec2 p, float radius, vec3 color) {\n    return vec4(length(p) - radius, color);\n}\n\nvec4 pentagon( in vec2 p, in float r, vec3 color )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return vec4(length(p)*sign(p.y), color);\n}\n\nvec4 subtract(vec4 d1, vec4 d2) {\n    return d1.x > -d2.x ? d1 : vec4(-d2.x, d2.yzw);\n}\n\nvec4 smooth_union(float k, vec4 a, vec4 b)\n{\n    float diff = abs(a.x - b.x);\n    float h = max(k - diff, 0.0) / k;\n    if (a.x < b.x) {\n        return vec4(a.x - h*h*h*k/6.0, b.yzw * (h/2.0) + a.yzw * (1.0-h/2.0));\n    } else {\n        return vec4(b.x - h*h*h*k/6.0, b.yzw * (1.0-h/2.0) + a.yzw * (h/2.0));\n    }\n}\n\nvec4 map(vec2 p) {\n    vec4 sdf = vec4(1e5, 0, 0, 0);\n\n    for (float th = 0.0; th < 6.28; th += 2. * PI / 3.) {\n        float r = 0.5;\n        float rc =  0.5 + 0.07 * cos(3.0 * th + 3.0 * iTime);\n        sdf = smooth_union(clamp(0.5 + 1.0 * pow(sin(iTime), 3.0), 0.001, 1.0), sdf, \n            pentagon(\n                p - r * vec2(cos(th), sin(th)),\n                rc,\n                vec3(\n                    0.4 + 0.3 * pow(sin(th + 2.), 2.),\n                    0.2 + 0.2 * sin(iTime + 5.0),\n                    0.2 + 0.7 * pow(sin(iTime), 2.)\n                )\n            )\n        );\n    }\n\n    sdf = smooth_union(0.1, sdf, \n        circle(p + vec2(cos(iTime), sin(iTime)), 0.3, vec3(0.2, 0.1, 0.3)));\n\n    return sdf;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 aspectRatio = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = aspectRatio * (fragCoord.xy / iResolution.xy - 0.5) * 4.0;\n    \n    float p = max(0.0, (52.0 - pow(max(0.0, mod(iTime, 10.0) + 0.0), 2.0)) / 5.778);\n    float a = floor(p);\n    float bounce = a * (1.0 - 4.0 * pow(p - a - 0.5, 2.0));\n    bounce *= 0.1;\n    bounce += 0.005;\n\n    vec4 sdf = map(uv - vec2(0.0, bounce));\n\n    vec3 color;\n\n    if (sdf.x > 0.0) {\n        vec4 shadow = map(uv);\n        color = clamp(0.1 + shadow.x / (0.1 + bounce * 1.5), 0.02 + 0.10 * bounce, 0.25) \n            * vec3(0.32, 0.35, 0.41) \n            * (3.0 / (3.0 + dot(uv,uv)))\n            * (3.0 + pow(sin(iTime + uv.x * 3.0 + sin(iTime + uv.y * 2.3 + uv.x * -2.7)), 5.0));\n    } else if (sdf.x > -0.02) {\n        color = vec3(0);  \n    } else {\n        color = sdf.yzw;\n    }\n\n    fragColor = vec4(pow(color, vec3(0.4545)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ftSXW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[46, 46, 93, 93, 139], [141, 141, 193, 193, 488], [490, 490, 523, 523, 577], [579, 579, 623, 623, 894], [896, 896, 914, 914, 1628], [1630, 1630, 1686, 1686, 2580]]}
{"id": "ftSXWK", "name": "Wavy dunes", "author": "jarble", "description": "This is a fairly realistic-looking desert landscape, based on dyla's [url=https://www.shadertoy.com/view/WdcfDn]\"Fyords\"[/url] shader.", "tags": ["procedural", "fractal", "terrain", "desert", "dune"], "likes": 2, "viewed": 159, "date": "1628563980", "time_retrieved": "2024-06-20T20:47:29.427618", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\n\n//increase this constant to increase the amount of detail\n#define OCTAVES 2\n\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    float value = 0.;\n    float factor = -3.;\n    uv *= factor;\n    for (int i = 0; i < OCTAVES; i++)\n    {\n        uv += max(sin(uv*factor)/factor,cos(uv/factor)*factor).yx;\n        value = -min(value+sin(uv.x)/factor,value+cos((uv.y)/factor)/factor);\n        \n        uv = uv/1.5/factor;\n        //factor /= 1.5;\n        \n    }\n    \n    return value/2.+1.5;\n}\n\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    float factor = 2.;\n    return fbm(uv/factor)*factor;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*iTime);\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    #endif\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 1.;\n\n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ftSXWK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[411, 488, 511, 560, 922], [996, 996, 1034, 1034, 1093], [1095, 1095, 1128, 1128, 1348], [1350, 1350, 1388, 1388, 1615], [1617, 1617, 1655, 1655, 1879], [1881, 1881, 1910, 1910, 2005], [2007, 2007, 2044, 2044, 2103], [2106, 2174, 2193, 2193, 2232], [2234, 2234, 2254, 2254, 2330], [2332, 2332, 2351, 2351, 2390], [2392, 2392, 2449, 2449, 2684], [2686, 2686, 2721, 2721, 3115], [3117, 3117, 3171, 3171, 3837], [3840, 3840, 3892, 3892, 4327], [4329, 4329, 4386, 4386, 5571]]}
{"id": "Nd33R4", "name": "xor pattern test", "author": "hikiko", "description": "xor pattern", "tags": ["xor"], "likes": 2, "viewed": 46, "date": "1629198300", "time_retrieved": "2024-06-20T20:47:29.427618", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int xor = (int(fragCoord.x) ^ int(fragCoord.y));\n    float r = float((xor * 2) & 0xff) / 255.0;\n    float g = float((xor * 4) & 0xff) / 255.0;\n\tfloat b = float((xor * 8) & 0xff) / 255.0;\n    \n    vec3 col = vec3(r, g, b);\n\tfragColor = vec4(col, 1.0);\n}\t\n\n\n/* See also: the 88 chars version in the comments!! */", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nd33R4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 314]]}
{"id": "Nd33z8", "name": "Raymarching a Scalar Field", "author": "Mafrans", "description": "A simple Raymarcher that marches through an infinite procedual field generated with a noise function. ", "tags": ["raymarching"], "likes": 3, "viewed": 42, "date": "1629106596", "time_retrieved": "2024-06-20T20:47:31.094046", "image_code": "uniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n#define NUM_OCTAVES 5\n\n\n/*\n *\n *    VARIOUS NOISE FUNCTIONS\n *\n *    Not necessary for the shader, but fun to play with\n *\n *    https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n *\n */\n\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n}\n\n\n// Random number generators, quite predictable so shouldn't be directly used for noise\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n// 1D Random Noise function\nfloat noise(float p){\n\tfloat fl = floor(p);\n    float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n// 2D Random Noise function\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n// 3D Random Noise function\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = permute(b.xyxy);\n    vec4 k2 = permute(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = permute(c);\n    vec4 k4 = permute(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n// 3D Simplex Noise, like perlin noise but cooler\nfloat snoise(vec3 v){ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n    i = mod(i, 289.0 ); \n    vec4 p = permute( permute( permute( \n        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n      + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n      + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    float n_ = 1.0/7.0;\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n// 4D Simplex Noise, like perlin noise but cooler\nfloat snoise(vec4 v){\n    const vec2  C = vec2( 0.138196601125010504,\n                          0.309016994374947451);\n\n    vec4 i  = floor(v + dot(v, C.yyyy) );\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    vec4 i0;\n\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    \n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n    vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n    vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n    vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n    i = mod(i, 289.0); \n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n        i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n      + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n      + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n      + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n        + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n\n// 1D Fractal Brownian Motion Noise\nfloat fbm(float x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfloat shift = float(100);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n// 2D Fractal Brownian Motion Noise\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n// 3D Fractal Brownian Motion Noise\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\n\n/*\n *\n *    MAIN KERNEL\n *\n *\n */\n\n// The main noise function that determines the noise field. Feel free to play around with it!\nfloat noiseFn(vec3 origin, vec3 dir, float len) {\n    return snoise(vec4(vec3((origin + len * dir) / 4.), 1.)) - 0.5;\n}\n\n// Performance settings, you may have to tweak these based on how complicated your code is\nconst float stepSize = .2;\nconst float viewDistance = 40.;\n\nfloat intersectFn(in vec3 rayOrigin, in vec3 rayDir) {\n    float len = 0.;\n    float val = noiseFn(rayOrigin, rayDir, len);\n    \n    // If we are already inside the noise field, step out of it. \n    // This solves an issue where the entire screen would become completely black if the camera was inside the field\n    for (float i = 0.; i < viewDistance / stepSize; i++) {\n        if (val <= 0.) break;\n        len += 1.;\n        val = noiseFn(rayOrigin, rayDir, len);\n    }\n    \n    // Step according to stepSize until we hit the noise field.\n    for (float i = 0.; i < viewDistance / stepSize; i++) {\n        if (val >= 0.) break;\n        len += stepSize;\n        val = noiseFn(rayOrigin, rayDir, len);\n    }\n\n    if (len <= 0. || len >= viewDistance) {\n        return viewDistance;\n    }\n    \n    // Use the secant method to linearly smooth the result\n    float x0 = len - stepSize;\n    float x1 = len;\n    float valX0 = noiseFn(rayOrigin, rayDir, x0);\n    float result = x1 - val * (x1 - x0) / (val - valX0);\n\n    return result;\n}\n\nfloat intersect(in vec3 rayOrigin, in vec3 rayDir) {\n    float len = intersectFn(rayOrigin, rayDir);\n    \n    return len;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    // Stretch the canvas to make up for aspect ratios other than 1:1\n    vec2 stretch = vec2(1., iResolution.y / iResolution.x);\n    \n    vec3 rayOrigin = vec3(iMouse.xy / iResolution.xy * 20., -iTime);\n    vec3 rayDir = normalize(vec3((2. * uv - 1.) * stretch, -1.));\n    \n    // Intersect the ray with the scene\n    float id = intersect(rayOrigin, rayDir);\n    \n    vec3 col = vec3(0.);\n    \n    if (id > 0.) {\n        // Given a hit, draw a shade of gray relative to how far away the hit was\n        col = vec3(1./id);\n    }\n    \n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nd33z8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[96, 275, 296, 296, 333], [334, 334, 357, 357, 401], [402, 402, 429, 429, 477], [478, 478, 507, 507, 555], [557, 557, 586, 586, 847], [850, 937, 957, 957, 995], [996, 996, 1016, 1016, 1083], [1085, 1113, 1134, 1134, 1226], [1228, 1256, 1276, 1276, 1485], [1487, 1515, 1535, 1535, 2038], [2040, 2090, 2111, 2111, 3766], [3768, 3818, 3839, 3839, 5625], [5627, 5663, 5683, 5683, 5855], [5857, 5893, 5912, 5912, 6183], [6185, 6221, 6240, 6240, 6410], [6449, 6543, 6592, 6592, 6662], [6664, 6815, 6869, 6869, 7847], [7849, 7849, 7901, 7901, 7972], [7974, 7974, 8031, 8081, 8695]]}
{"id": "Nd33zM", "name": "exksv", "author": "ksviety", "description": "noise", "tags": ["noise"], "likes": 2, "viewed": 51, "date": "1629337882", "time_retrieved": "2024-06-20T20:47:31.397249", "image_code": "#define NUM_OCTAVES 100\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\t\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm(float x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfloat shift = float(100);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2(sin(max(fragCoord.x, fragCoord.y)), cos(min(fragCoord.x, fragCoord.y)))/1.0;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float layer1 = noise(vec2(uv.x * (iTime / uv.y),uv.y * (iTime / uv.x)));\n    \n    float layer2 = noise(vec2(uv.y * (iTime / uv.x),uv.x * (iTime / uv.y)));\n    \n    vec3 c = vec3(\n        layer1 * layer2\n    );\n   \n\n    // Output to screen\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nd33zM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[24, 24, 44, 44, 82], [85, 85, 105, 105, 172], [174, 174, 195, 195, 285], [288, 288, 309, 309, 507], [509, 509, 529, 529, 701], [703, 703, 760, 810, 1275]]}
{"id": "Nd33zr", "name": "Audio visualizer", "author": "alexandre_lamure", "description": "Audio visualizer test", "tags": ["audio"], "likes": 3, "viewed": 106, "date": "1628983965", "time_retrieved": "2024-06-20T20:47:32.094272", "image_code": "// To test it, click on iChannel0 and choose a Music\n\n#define PI 3.141592\n\nvec3 drawWave(in vec2 uv)\n{\n    //resize uv\n    float downsize_x = 2.5;\n    uv.x = (uv.x * downsize_x) - (downsize_x-1.0)*0.5;\n    float downsize_y = 7.5;\n    uv.y = (uv.y * downsize_y) - (downsize_y-1.0)*0.5;\n    \n    // the sound texture is 512x2\n    int tx = int(uv.x*512.0);\n    \n    // second row is the sound wave, one texel is one mono sample\n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    \n\n    // add wave form\t\n    float waveThickness = pow(abs(wave - 0.5), 0.6) * 3.0;\n\tvec3 waveCol = vec3(1.0 - smoothstep(0.0, waveThickness, abs(wave - uv.y)));\n    // colorize wave\n    float x_color_speed = 1.2;\n    float x_color1 = cos(iTime * x_color_speed + PI * uv.x) * 0.5 + 0.5;\n    float x_color2 = cos(iTime * x_color_speed + PI * uv.x + PI*0.25) * 0.5 + 0.5;\n    float x_color3 = 1.0 - x_color2;\n    waveCol *= vec3(waveCol.x * x_color3,\n                    waveCol.x * x_color2,\n                    waveCol.x * x_color1);\n    // enhance color\n    waveCol *= 1.2;\n    \n    // draw middle line\n    float line_thickness = 0.02;\n    float lineIsInXRange = float(uv.x > 0.0 && uv.x < 1.0);\n    float lineIsInYRange = float(uv.y > (0.5 - line_thickness) && uv.y < (0.5 + line_thickness));\n    float line_col = 1.0 * lineIsInXRange * lineIsInYRange;\n    \n    // combine\n    vec3 col = line_col > 0.0 ? vec3(1.0) : waveCol;\n    \n    // Fade left/right borders of wave\n    float fade = 0.2;\n    col *= smoothstep(0.0, fade, uv.x) * (1.0 - smoothstep(1.0-fade, 1.0, uv.x));\n    \n    return col;\n}\n\nvec3 drawFreq(const vec2 uv, vec2 fragCoord)\n{\n    // cartesian to polar\n    vec2 centered_uv = (fragCoord.xy - iResolution.xy*0.5) / max(iResolution.x, iResolution.y);\n    float r = sqrt(centered_uv.x*centered_uv.x + centered_uv.y*centered_uv.y);\n    float theta = atan(centered_uv.y, centered_uv.x);\n    // re-range to [0,1]\n    theta = theta / (2.0*PI) + 0.5;\n    \n    // Define bands\n    float nBands = 128.0;\n    float intBand = floor(theta*nBands);\n    float fractBand = fract(theta*nBands);\n    \n    // the sound texture is 512x2\n    int tx = int(intBand / nBands * 512.0);\n    \n    // first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n    \n    // draw bands circle\n    float circleMinRadius = 0.24;\n    float circleMaxRadius = 0.30;\n    float bandWidth = 0.1;\n    // add band width depending smoothly on time and theta\n    bandWidth += 0.3 * abs(cos(iTime * 0.4 + PI * theta));\n    // remap fft (freq amount) between [circleMinRadius, circleMaxRadius]\n    float freqAmount = circleMinRadius + (circleMaxRadius - circleMinRadius) * fft;\n    float isInBandRange = float(\n                fractBand < bandWidth // band width\n                && r > circleMinRadius // min radius\n                && r < freqAmount); // freq radius\n    vec3 freqColor = vec3(1.0) * isInBandRange;\n    \n    // colorize freq bands\n    float x_color_speed = 1.2;\n    float x_color1 = cos(iTime * x_color_speed + PI * theta) * 0.5 + 0.5;\n    float x_color2 = cos(iTime * x_color_speed + PI * theta + PI*0.25) * 0.5 + 0.5;\n    float x_color3 = 1.0 - x_color2;\n    freqColor *= vec3(x_color1, x_color2, x_color3);\n    \n    // draw line\n    float lineThickness = 0.003;\n    vec3 lineColor = vec3(float(r > circleMinRadius && r < circleMinRadius + lineThickness));\n    \n    \n    vec3 col = freqColor + lineColor;\n    \n    return col;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 drawCircles(in vec2 uv)\n{\n    // the sound texture is 512x2\n    int tx = int(uv.x * 512.0);\n    \n    // first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n    \n    vec3 col = vec3(0.0);\n    if (fft > 0.9)\n    {\n        col += rand(vec2(uv.y));\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // create pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    col += drawFreq(uv, fragCoord);    \n    col += drawWave(uv);\n    //col += drawCircles(uv);\n\n\t// output final color\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nd33zr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 75, 102, 118, 1586], [1588, 1588, 1634, 1660, 3484], [3486, 3486, 3506, 3506, 3576], [3578, 3578, 3608, 3642, 3939], [3941, 3941, 3998, 4030, 4252]]}
{"id": "Nd3GDM", "name": "Republic Of Korea Flag", "author": "hyunamy", "description": "Republic Of Korea Flag", "tags": ["flag", "korea", "rok", "nation"], "likes": 8, "viewed": 136, "date": "1629911556", "time_retrieved": "2024-06-20T20:47:32.997462", "image_code": "// Created by hyunamy - 2021.08\n// License Creative Commons Attribution-NonCommercial-Share Hyunamy 3.0 Unported License.\n\nconst float PI = 3.141592;\n\nvec3 RED = vec3(206., 17., 39.) / 255.;\nvec3 BLUE = vec3(0., 62., 135.) / 255.;\n\nconst float PadX = .39;\nconst float PadY = .26;\n\nconst float LW = .3;\nconst float CenterScale = .625;\nconst float WingScale = .43;\n\nmat2 rotationMatrix(float angle)\n{\n\tangle *= PI / 180.0;\n    float s = sin(angle), c=cos(angle);\n    return mat2( c, -s, s, c );\n}\n\nfloat Band(float t, float start, float end, float blur)\n{\n    float step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    return step1 * step2;\n}\n\nfloat Rect(vec2 uv, float l, float r, float b, float t, float blur) \n{\n    float band1 = Band(uv.x, l, r, blur);\n    float band2 = Band(uv.y, b, t, blur);    \n    \n    return band1 * band2;\n}\n\nvec4 LeftTop(vec2 uv, float angle, float scale)  \n{\n    vec4 col = vec4(0);\n    \n    uv *= rotationMatrix(angle) / scale;\n    \n    col += Rect(uv, -LW, LW, .1, .2, .005);   \n    col += Rect(uv, -LW, LW, -.05, .05, .005);   \n    col += Rect(uv, -LW, LW, -.2, -.1, .005);   \n    col.rgb *= 0.;\n    \n    return col;\n}\n\nvec4 RightTop(vec2 uv, float angle, float scale)\n{\n    vec4 col = vec4(0);   \n    \n    uv *= rotationMatrix(angle) / scale;\n    \n    float w = .45;\n    float l = LW - LW * w;\n    float r = LW - LW * w;\n    \n    col += Rect(uv, -LW * w - l, LW * w - l, .1, .2, .005);   \n    col += Rect(uv, -LW * w + r, LW * w + r, .1, .2, .005);   \n    col += Rect(uv, -LW, LW, -.05, .05, .005);    \n    col += Rect(uv, -LW * w - l, LW * w - l, -.2, -.1, .005);   \n    col += Rect(uv, -LW * w + r, LW * w + r, -.2, -.1, .005);   \n    \n    col.rgb *= 0.;\n    return col;\n}\n\nvec4 LeftBottom(vec2 uv, float angle, float scale)\n{\n    vec4 col = vec4(0);   \n    \n    uv *= rotationMatrix(angle) / scale;\n    \n    float w = .45;\n    float l = LW - LW * w;\n    float r = LW - LW * w;\n    \n    col += Rect(uv, -LW, LW, .1, .2, .005);   \n    col += Rect(uv, -LW * w - l, LW * w - l, -.05, .05, .005);   \n    col += Rect(uv, -LW * w + r, LW * w + r, -.05, .05, .005);\n    col += Rect(uv, -LW, LW, -.2, -.1, .005); \n    \n    col.rgb *= 0.;\n    return col;\n}\n\nvec4 RightBottom(vec2 uv, float angle, float scale)\n{\n    vec4 col = vec4(0);   \n    \n    uv *= rotationMatrix(angle) / scale;\n    \n    float w = .45;\n    float l = LW - LW * w;\n    float r = LW - LW * w;\n     \n    col += Rect(uv, -LW * w - l, LW * w - l, .1, .2, .005);   \n    col += Rect(uv, -LW * w + r, LW * w + r, .1, .2, .005);   \n    col += Rect(uv, -LW * w - l, LW * w - l, -.05, .05, .005);   \n    col += Rect(uv, -LW * w + r, LW * w + r, -.05, .05, .005);\n    col += Rect(uv, -LW * w - l, LW * w - l, -.2, -.1, .005);   \n    col += Rect(uv, -LW * w + r, LW * w + r, -.2, -.1, .005);     \n    \n    col.rgb *= 0.;\n    return col;\n}\n\nvec4 CenterBody(vec2 uv, float scale)\n{\n    vec2 rotatedUV = uv * rotationMatrix(30.) / scale;\n    \n    float body = smoothstep(0.01, 0., rotatedUV.y);    \n    vec4 col = vec4(mix(RED, BLUE, body), 1.);\n\n    float d = length(rotatedUV);\n    col.a = smoothstep(0.4, 0.39, d);    \n    \n    float sd = length(rotatedUV - vec2(-0.2, 0.0));\n    float sc = smoothstep(0.205, 0.195, sd);\n    col.rgb = mix(col.rgb, RED, sc);\n    \n    sd = length(rotatedUV - vec2(0.2, 0.0));\n    sc = smoothstep(0.205, 0.195, sd);\n    col.rgb = mix(col.rgb, BLUE, sc);\n    \n    return col;\n}\n\nvec4 Flag(vec2 uv)\n{\n    vec4 col = vec4(0); \n    \n    vec4 body = CenterBody(uv, CenterScale);    \n    col = mix(col, body, body.a);\n    \n    vec4 lt = LeftTop(uv - vec2(-PadX,PadY), -50., WingScale);\n    col = mix(col, lt, lt.a);\n    \n    vec4 rt = RightTop(uv - vec2(PadX,PadY), 50., WingScale);\n    col = mix(col, rt, rt.a);\n    \n    vec4 lb = LeftBottom(uv - vec2(-PadX,-PadY), 50., WingScale);\n    col = mix(col, lb, lb.a);\n    \n    vec4 rb = RightBottom(uv - vec2(PadX,-PadY), -50., WingScale);\n    col = mix(col, rb, rb.a);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    float t = uv.x * 5. - iTime * 1.4 + uv.y * 3.5;\n    uv.y += sin(t)*.035;\n    \n    vec4 col = vec4(1);    \n    \n    vec4 flag = Flag(uv);\n    col = mix(col, flag, flag.a);\n    float shadow = .95 + cos(t) *.156;    \n    col *= shadow;\n    col *= smoothstep(0.5, 0.495, abs(uv.y)); \n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0 AND proprietary-license", "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3GDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 364, 398, 398, 494], [496, 496, 553, 553, 691], [693, 693, 763, 763, 884], [886, 886, 937, 937, 1200], [1202, 1202, 1252, 1252, 1757], [1759, 1759, 1811, 1811, 2232], [2234, 2234, 2287, 2287, 2873], [2875, 2875, 2914, 2914, 3442], [3444, 3444, 3464, 3464, 3998], [4000, 4000, 4057, 4057, 4438]]}
{"id": "Nd3GRN", "name": "dart cube", "author": "sunhokim", "description": "It's a dart cube.", "tags": ["sdf"], "likes": 5, "viewed": 105, "date": "1629223618", "time_retrieved": "2024-06-20T20:47:32.997462", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nvec3 rotateX( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\nvec3 rotateY( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\nvec3 rotateZ( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec4 mapSide(vec3 p, float displace) {\n    vec2 k = p.xz;\n    vec2 por = vec2(sqrt(k.x*k.x+k.y*k.y), atan(k.y,k.x));\n    float a = por.x/0.2;\n    float h2 = displace*0.4*a;\n    float h = displace*0.4*floor(a);\n    float b = smoothstep(0.1, 0.2, mod(por.x,0.2));\n    vec3 q = p;\n    float hh = displace*5.0*0.4;\n    q.y = 1.0*q.y-h+hh;\n    return vec4(sdBox(q, vec3(1.0,0.2, 1.0)),vec3(b, h2/hh, 0.0));\n}\n\nvec4 map(vec3 p) {\n    vec4 res = vec4(1e10, 0, 0,0);\n\n    float d = 0.7;\n    float s = 1.0;\n    if (iTime < 1.0) {\n        s = (1.0+sin(iTime*M_PI - M_PI*0.5))/2.0;\n    }\n    float dd = d*0.5*(1.0+sin(iTime - M_PI*0.5))+0.01;\n    {\n    vec3 q = p - vec3(0,0.0, -1.0);\n    q /= s;\n    res = opU(res, mapSide(q, dd)*s);\n    }\n    {\n    vec3 q = rotateX(p, M_PI*1.5) - vec3(0,0.0, 1.0);\n    q /= s;\n    res = opU(res, mapSide(q, dd)*s);\n    }\n    {\n    vec3 q = rotateX(p, M_PI*0.5) - vec3(0,-2.0, -1.0);\n    q /= s;\n    res = opU(res, mapSide(q, dd)*s);\n    }\n    {\n    vec3 q = rotateZ(p, M_PI*0.5) - vec3(1.0,-1.0, -1.0);\n    q /= s;\n    res = opU(res, mapSide(q, dd)*s);\n    }\n    {\n    vec3 q = rotateZ(p, M_PI*1.5) - vec3(-1.0,-1.0, -1.0);\n    q /= s;\n    res = opU(res, mapSide(q, dd)*s);\n    }\n    {\n    vec3 q = rotateX(p, M_PI*1.0) - vec3(0.0,-2.0, 1.0);\n    q /= s;\n    res = opU(res, mapSide(q, dd)*s);\n    }\n    \n    return res;\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in float rad )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 0.05;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );\n}   \n\nvec4 raycast( in vec3 ro, in vec3 rd )\n{\n    vec4 res = vec4(-1.0);\n    vec2 tminmax = iSphere( ro, rd, 20.0 );\n\tif( tminmax.y>0.0 )\n    {\n        float t = max(tminmax.x,0.001);\n        for( int i=0; i<1024 && t<tminmax.y; i++ )\n        {\n            vec4 h = map(ro+t*rd);\n            if( h.x<0.01 ) { res=vec4(t,h.yzw); break; }\n            t += 0.1*h.x;\n        }\n    }\n    \n    return res;\n}\n\nvec3 gradient(float z) {\n    vec3 a = vec3(0.46,0.76,1);\n    vec3 b = vec3(0.11,0.98,1);\n    vec3 c = vec3(0.69,0.49,1);\n    vec3 d = vec3(1,1,1);\n    if (z < 0.3) {\n        return mix(a, b, z);\n    } else if (z < 0.99999) {\n        return mix (b, c, z);\n    } else {\n        return mix(c,d, z);\n    }\n}\n\nvec3 render( in vec3 ro, vec3 rd )\n{ \n    vec4 res = raycast(ro, rd);\n    vec3 pos = ro + res.x*rd;\n    vec3 col = vec3(0.0);\n    vec3 mat =  mix(vec3(1.0), gradient(res.z), res.y);\n    vec3 normal = calcNormal(pos);\n    if (res.x < 0.0) {\n        return vec3(0.0);\n    } \n\n    vec3 lin = vec3(0.0);\n    lin += 1.0;\n    col = lin * mat;\n\treturn vec3(clamp(col,0.0,1.0));\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMat( in vec3 eye, in vec3 look )\n{\n    vec3 w = normalize(eye-look);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(w, u);\n    return mat3( u, v, w );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec2 mouse = iMouse.xy /iResolution.xy;\n    if (iMouse.xy == vec2(0)) {\n        mouse = vec2(0.4,0.7);\n    }\n    vec2 spr = vec2(mouse.x * M_PI - M_PI/2.0, mouse.y*M_PI-M_PI)*0.8;\n    float r = 20.0;\n    vec3 eye = vec3(-r*sin(spr.x)*sin(spr.y), -r*cos(spr.y),-r*sin(spr.y)*cos(spr.x)) + vec3(0.0, -2.0, 0.0);\n    vec3 look = vec3(0.0,0.0,0);\n    mat3 view = viewMat(eye, look);\n    dir = view * dir;\n    vec3 col = render(eye, dir);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3GRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[48, 48, 84, 84, 182], [183, 183, 219, 219, 317], [318, 318, 354, 354, 452], [454, 454, 485, 485, 572], [574, 574, 604, 604, 637], [639, 639, 677, 677, 1042], [1044, 1044, 1062, 1062, 1985], [1987, 1987, 2041, 2041, 2201], [2203, 2203, 2233, 2233, 2500], [2505, 2505, 2545, 2545, 2901], [2903, 2903, 2927, 2927, 3206], [3208, 3208, 3244, 3244, 3580], [3582, 3582, 3647, 3647, 3779], [3781, 3781, 3824, 3824, 3961], [3963, 3963, 4020, 4020, 4551]]}
{"id": "Ndc3RH", "name": "Arachnogenesis", "author": "dr2", "description": "Spiders have to come from somewhere...", "tags": ["spiral", "spider", "gait", "logarithm"], "likes": 25, "viewed": 233, "date": "1629108034", "time_retrieved": "2024-06-20T20:47:34.379247", "image_code": "// \"Arachnogenesis\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  No. 7 in \"Spider\" series\n    \"Octopod\"                     (4tjSDc)\n    \"Moebius Strip\"               (lddSW2)\n    \"Moebius Strip 2\"             (MscXWX)\n    \"Spider Ascent\"               (4sd3WX)\n    \"Moebius, Menger, Spiders\"    (wsXyzM)\n    \"Helical Ramps with Spiders\"  (3sscWf)\n*/\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrEETapCylDf (vec3 p, vec3 v1, vec3 v2, float r, float rf);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nvec3 footPos[8], kneePos[8], hipPos[8], ltDir, qHit;\nfloat tCur, dstFar, legLenU, legLenD, bdyHt, spdVel;\nint idObj;\nconst int idBdy = 1, idHead = 2, idEye = 3, idAnt = 4, idLegU = 5, idLegD = 6;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat SpdDf (vec3 p, float dMin)\n{ // (see \"Moebius, Menger, Spiders\")\n  vec3 q;\n  float d, s, len, szFac;\n  szFac = 0.12;\n  p /= szFac;\n  dMin /= szFac; \n  p.y -= bdyHt - 0.1;\n  q = p - vec3 (0., -0.15, 0.2);\n  d = PrEllipsDf (q, vec3 (0.7, 0.5, 1.3));\n  DMINQ (idBdy);\n  q = p - vec3 (0., 0.1, 1.1);\n  d = PrEllipsDf (q, vec3 (0.2, 0.4, 0.5));\n  DMINQ (idHead);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 0.25, 1.5);\n  d = PrSphDf (q, 0.13);\n  DMINQ (idEye);\n  q -= vec3 (0., 0.15, -0.3);\n  d = PrEETapCylDf (q, 1.3 * vec3 (0.3, 1.1, 0.4), vec3 (0.), 0.07, 0.7);\n  DMINQ (idAnt);\n  p.y += bdyHt;\n  for (int j = 0; j < 8; j ++) {\n    q = p - hipPos[j];\n    d = 0.6 * PrEETapCylDf (q, kneePos[j], hipPos[j], 0.25, 0.3);\n    DMINQ (idLegU);\n    q = p - kneePos[j];\n    d = 0.6 * PrEETapCylDf (q, footPos[j] - vec3 (0.3), kneePos[j] - vec3 (0.3), 0.2, 1.2);\n    DMINQ (idLegD);\n  }\n  dMin *= szFac;\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{ // (see \"Spiraling Out\")\n  vec3 q;\n  float dMin, d, r, a;\n  dMin = dstFar;\n  q = p;\n  r = length (q.xz);\n  if (r > 0.01) {\n    a = atan (q.z, q.x) / pi;\n    q.xz = - (mod (vec2 (0.5 * (pi * log (r) + a) - 0.05 * tCur, 5. * a) + 0.5, 1.) - 0.5);\n    q.y *= 0.7 / sqrt (r);\n    dMin = 0.5 * r * SpdDf (q, dMin);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (h, 0.01);\n    if (h < 0.001 || d > dMax) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SpdCol (vec3 vn)\n{\n  vec3 col, c1, c2;\n  c1 = vec3 (0.5, 1., 0.2);\n  c2 = vec3 (0.5, 0.2, 0.2);\n  if (idObj == idBdy) {\n    col = mix (c1, c2, SmoothBump (0.2, 0.7, 0.05, mod (4. * qHit.z, 1.)));\n  } else if (idObj == idHead) {\n    col = c2;\n    if (qHit.z > 0.4) col = mix (vec3 (0.2, 0.05, 0.05), col,\n       smoothstep (0.02, 0.04, abs (qHit.x)));\n  } else if (idObj == idEye) {\n    col = (vn.z < 0.6) ? vec3 (0., 1., 0.) : c1;\n  } else if (idObj == idLegU || idObj == idLegD) {\n    col = mix (c2, c1,  SmoothBump (0.4, 1., 0.2, fract (3.5 * length (qHit))));\n  } else if (idObj == idAnt) {\n    col = vec3 (1., 1., 0.3);\n  }\n  return col;\n}\n\nvoid SpdSetup (float gDisp)\n{\n  vec3 v;\n  float a, az, fz, d, ll;\n  for (int j = 0; j < 4; j ++) {\n    a = 0.2 * (1. + float (j)) * pi;\n    hipPos[j] = 0.5 * vec3 (- sin (a), 0., 1.5 * cos (a));\n    hipPos[j + 4] = hipPos[j];\n    hipPos[j + 4].x *= -1.;\n  }\n  bdyHt = 1.5;\n  legLenU = 2.2;\n  legLenD = 3.;\n  ll = legLenD * legLenD - legLenU * legLenU;\n  for (int j = 0; j < 8; j ++) {\n    fz = fract ((gDisp + 0.93 + ((j < 4) ? -1. : 1.) + mod (7. - float (j), 4.)) / 3.);\n    az = smoothstep (0.7, 1., fz);\n    footPos[j] = 5. * hipPos[j];\n    footPos[j].x *= 1.7;\n    footPos[j].y += 0.7 * sin (pi * clamp (1.4 * az - 0.4, 0., 1.));\n    footPos[j].z += ((j < 3) ? 0.5 : 1.) - 3. * (fz - az);\n    hipPos[j] += vec3 (0., bdyHt - 0.3, 0.2);\n    v = footPos[j] - hipPos[j];\n    d = length (v);\n    a = asin ((hipPos[j].y - footPos[j].y) / d);\n    kneePos[j].y = footPos[j].y + legLenD *\n       sin (acos ((d * d + ll) / (2. * d *  legLenD)) + a);\n    kneePos[j].xz = hipPos[j].xz + legLenU * sin (acos ((d * d - ll) /\n       (2. * d *  legLenU)) + 0.5 * pi - a) * normalize (v.xz);\n  }\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, sh;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col = SpdCol (vn);\n    if (idObj != idEye) col = Maxv3 (col) * vec3 (1.);\n    col = col * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.2 * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    col = mix (vec3 (0.3), col, smoothstep (0.05, 0.1, length (vec2 (ro.xz))));\n  } else if (rd.y < 0.) {\n    ro += (- ro.y / rd.y) * rd;\n    vn = vec3 (0., 1., 0.);\n    sh = ObjSShadow (ro + 0.01 * vn, ltDir, dstFar);\n    col = vec3 (0.4) * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.));\n  } else col = vec3 (0.4);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = -0.03 * pi * tCur;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.35 * pi, -0.15 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -30.);\n  zmFac = 4.;\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (0.7, 1., -1.));\n  spdVel = 1.5;\n  SpdSetup (spdVel * tCur);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrEETapCylDf (vec3 p, vec3 v1, vec3 v2, float r, float rf)\n{\n  vec3 v;\n  float s;\n  v = v1 - v2;\n  s = clamp (dot (p, v) / dot (v, v), 0., 1.);\n  return length (p - s * v) - r * (1. - rf * s * s);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ndc3RH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[122, 1062, 1096, 1132, 1979], [1981, 1981, 2003, 2028, 2334], [2336, 2336, 2369, 2369, 2617], [2619, 2619, 2640, 2640, 2895], [2897, 2897, 2946, 2946, 3199], [3201, 3201, 3224, 3224, 3849], [3851, 3851, 3880, 3880, 4936], [4938, 4938, 4973, 4973, 5654], [5656, 5656, 5712, 5712, 6437], [6439, 6439, 6472, 6472, 6499], [6501, 6501, 6567, 6567, 6705], [6707, 6707, 6742, 6742, 6804], [6806, 6806, 6828, 6828, 6866], [6868, 6868, 6925, 6925, 7008], [7010, 7010, 7046, 7046, 7252], [7254, 7254, 7284, 7284, 7397]]}
{"id": "Ndc3W4", "name": "Ray March Phong Template + color", "author": "CannaVizion", "description": "Just the same template as @alijaya's, but added the color picking system I learnt from @samlo https://www.shadertoy.com/view/wd2SR3", "tags": ["raymarching"], "likes": 0, "viewed": 135, "date": "1629768721", "time_retrieved": "2024-06-20T20:47:35.518720", "image_code": "//Fork from @alijaya Ray Marching Phong Template https://www.shadertoy.com/view/4t2fR1\n//Added the color picking system I learnt from @samlo https://www.shadertoy.com/view/wd2SR3\n\n#define EPSILON 0.01\n#define MIN_DISTANCE 0.0\n#define MAX_DISTANCE 2000.0\n#define MAX_MARCHING_STEP 256\n\n#define COLOR1 1.\n#define COLOR2 2.\n#define COLOR3 3.\n\n\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction, always normalized\n};\n\nstruct Camera {\n    vec3 pos;\n    vec3 lookAt;\n    float focal;\n    vec2 sensorSize;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n};\n    \nvec3 xe = vec3(EPSILON, 0., 0.);\nvec3 ye = vec3(0., EPSILON, 0.);\nvec3 ze = vec3(0., 0., EPSILON);\n\n// get corresponding ray from uv (0.0 -> 1.0)\nRay getRay( Camera cam, vec2 uv ) {\n    vec3 camDir = normalize(cam.lookAt - cam.pos); // the camera direction\n    vec3 center = cam.pos + cam.focal * camDir; // get the coordinate of the screen center\n    vec2 coord = (uv - 0.5) * cam.sensorSize; // convert from 0.0 -> 1.0 to -sensorSize / 2. -> sensorSize / 2.\n    \n    // axis relative to camera\n    vec3 zpos = -camDir; // k hat, outward the screen\n    vec3 xpos = cross(vec3(0., 1., 0.), zpos); // i hat, cross from ypos global and zpos local\n    vec3 ypos = cross(zpos, xpos); // j hat, cross from zpos local and xpos local\n    \n    // target in screen\n    vec3 target = center + coord.x * xpos + coord.y * ypos; // get pixel target coordinate from the screen\n    \n    Ray ray;\n    ray.o = cam.pos; // the origin of the ray is from the camera duh\n    ray.d = normalize(target - cam.pos); // the direction is from the camera to the target\n    \n    return ray;\n}\n\n// project point to ray\nvec3 projPoint2Ray( vec3 point, Ray ray ) {\n    vec3 rel = point - ray.o; // get relative vector from the point to the ray origin\n    float len = dot(rel, ray.d); // project that vector to vector direction of the ray, we get the length\n    return len * ray.d + ray.o; // multiply the length with unit vector direction and add to ray origin\n}\n\n// get the distance from point to ray (or line)\nfloat distPoint2Ray( vec3 point, Ray ray ) {\n    vec3 proj = projPoint2Ray(point, ray); // project it first to the ray\n    return distance(proj, point); // get the distance from the projected position to the original position\n}\n\n// just linear interpolation, map value v between fromA and fromB to between toA and toB\nfloat lerp( float v, float fromA, float fromB, float toA, float toB ) {\n    return (v - fromA) / (fromB - fromA) * (toB - toA) + toA;\n}\n\n// sphere function\nfloat sdSphere( vec3 p, float radius ) {\n    return length(p) - radius;\n}\n\n// box function\nfloat sdBox( vec3 p, float width, float height, float depth ) {\n    vec3 d = abs(p) - vec3(width, height, depth);\n    return max(d.x, max(d.y, d.z));\n}\n\n// cylinder function\nfloat sdCylinder( vec3 p, float radius, float height ) {\n    return max(length(p.xz) - radius, abs(p.y) - height);\n}\n\nfloat sdUnion( float sd1, float sd2 ) {\n    return min(sd1, sd2);\n}\n\nfloat sdIntersect( float sd1, float sd2 ) {\n    return max(sd1, sd2);\n}\n\nfloat sdSubstract( float sd1, float sd2 ) {\n    return max(sd1, -sd2);\n}\n\nfloat add (inout vec2 a, vec2 b){\n    a = mix(a,b,step(b.x,a.x));\n    return 0.;\n}\n\n// change this            \\\\\\now, instead of returning a float with the distance, returns vec2(distance,colorID)\nvec2 sdScene( vec3 p ) {\n    float sphere = sdSphere( p-vec3(-100), 220. );\n    float box = sdBox(p-vec3(-150), 200., 50., 200.);\n    float box2 = sdBox(p, 50., 200., 200.);\n    float cylinder = sdCylinder(p-vec3(100), 150., 250.);\n    vec2 S = vec2(sphere,COLOR1);\n    vec2 B = vec2(box,COLOR2);\n    vec2 C = vec2(max(-box2,cylinder),COLOR3);\n    vec2 result = C;\n    add(result,S);\n    add(result,B);\n    return result;\n}\n\n// estimate normal with nudging\nvec3 estimateNormal( vec3 p ) {\n    return normalize(vec3(\n        sdScene(p+xe).x - sdScene(p-xe).x,\n        sdScene(p+ye).x - sdScene(p-ye).x,\n        sdScene(p+ze).x - sdScene(p-ze).x\n    ));\n}\n\n// ray marching algorithm\nvec2 getSDF( Ray r ) {\n    float depth = MIN_DISTANCE;\n    float matID;\n    for (int i=0; i<MAX_MARCHING_STEP; i++) {\n        float dist = sdScene( r.o + depth * r.d ).x;      //checks distance\n        matID = sdScene (r.o + depth * r.d).y;            //checks colorID\n        \n        if (dist < EPSILON) { // inside a scene\n            return vec2(depth,matID);\n        }\n        \n        depth += dist; // circle marching!\n        \n        if (depth >= MAX_DISTANCE) {\n            return vec2(MAX_DISTANCE,matID);\n        }\n    }\n    \n    return vec2(MAX_DISTANCE,matID);\n}\n\nvec3 ambientLight( vec3 ambientColor ) {\n    return ambientColor;\n}\n\nvec3 phongLight( vec3 diffuseColor, vec3 specularColor, float shininess, Ray ray, float dist, Light light ) {\n    vec3 p = ray.o + dist * ray.d;\n    \n    vec3 N = estimateNormal(p); // surface normal\n    vec3 L = normalize(light.pos - p); // surface to light direction\n    vec3 V = -ray.d; // surface to camera direction\n    vec3 R = reflect(-L, N); // mirror of L by the axis N\n    \n    float dotLN = dot(L, N); // project light direction to surface normal\n    float dotRV = dot(R, V); // project light reflection direction to direction to camera\n    \n    vec3 color = vec3(0.);\n    if (dotLN > 0.) { // we can see the diffuse\n        color += diffuseColor * dotLN;\n    }\n    if (dotRV > 0.) { // we can see the specular\n        color += specularColor * pow(dotRV, shininess);\n    }\n    color *= light.color; // influence of color of the light\n    return color;\n}\n\nvec3 calcMaterial (float id) { //here you assign the colors you want\n    if (id == COLOR1)      return vec3(1.,0,0);\n    if (id == COLOR2)     return vec3(0,1.,0);\n    if (id == COLOR3)     return vec3(0,0,1.);\n    return vec3(1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // convert from fragCoord (0.0 -> iResolution.xy) to uv (0.0 -> 1.0)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 circleMovement = vec3(600. * cos(iTime * 2.), 600. * cos(iTime * 2.), 600. * sin(iTime * 2.)); // to get circle movement\n    \n    // set camera\n    Camera cam;\n    cam.sensorSize = iResolution.xy; // set sensor size to the screenSize\n    cam.focal = 200.; // set the focal length (distance between sensor (screen) to the aperture\n    cam.lookAt = vec3(0., 0., 0.); // where to look at (this camera use two point system)\n    cam.pos = circleMovement; // the position of the camera\n    \n    // get ray\n    Ray ray = getRay(cam, uv); // get corresponding ray, given the uv\n\n    \n    // render\n    float dist = getSDF(ray).x;\n    float colID = getSDF(ray).y;\n\n\n    if (dist > MAX_DISTANCE - EPSILON) { // don't hit anything, set to background\n        fragColor = vec4(0.);\n        return; // or discard?\n    }\n    \n    vec3 ambientColor = vec3(0.1);\n    vec3 diffuseColor = calcMaterial(colID);//transforms the colorID to assigned colors\n    vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    float shininess = 50.0;\n    \n    Light light1;\n    light1.pos = vec3(500. * sin(iTime), 500. * cos(iTime), 400.);\n    light1.color = vec3(1., .3, .1);\n    \n    Light light2;\n    light2.pos = vec3(1000. * cos(iTime), 400., 1000. * sin(iTime));\n    light2.color = vec3(.1, .3, 1.);\n    \n    vec3 color = vec3(0.);\n    color += ambientLight(ambientColor);\n    color += phongLight(diffuseColor, specularColor, shininess, ray, dist, light1);\n    color += phongLight(diffuseColor, specularColor, shininess, ray, dist, light2);\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ndc3W4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[666, 712, 747, 747, 1629], [1631, 1655, 1698, 1698, 1996], [1998, 2046, 2090, 2090, 2273], [2275, 2364, 2435, 2435, 2499], [2501, 2520, 2560, 2560, 2593], [2595, 2611, 2674, 2674, 2762], [2764, 2785, 2841, 2841, 2901], [2903, 2903, 2942, 2942, 2970], [2972, 2972, 3015, 3015, 3043], [3045, 3045, 3088, 3088, 3117], [3119, 3119, 3152, 3152, 3201], [3203, 3316, 3340, 3340, 3739], [3741, 3773, 3804, 3804, 3969], [3971, 3997, 4019, 4019, 4573], [4575, 4575, 4615, 4615, 4642], [4644, 4644, 4753, 4753, 5508], [5510, 5510, 5540, 5578, 5742], [5744, 5744, 5800, 5873, 7472]]}
{"id": "Ndc3WM", "name": "Birds of Paradise in 183ch", "author": "104", "description": "for fun", "tags": ["smallsizecoding"], "likes": 2, "viewed": 50, "date": "1629909600", "time_retrieved": "2024-06-20T20:47:35.524801", "image_code": "void mainImage(out vec4 o, vec2 u)\n{\n    u /= iResolution.y*.5;\n    for(int i=0;i<16;++i) {\n        vec2 v = fract(u.yx-iTime*.7)-.5,\n        s = min(fract(u += v*v),1.-fract(u));\n        o = fract(u.xyyy+sin(u.yxyx))*min(s.x,s.y);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ndc3WM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 36, 36, 239]]}
{"id": "NdcGDN", "name": "Simple Barycentric Coordinates", "author": "wylm", "description": "Simple application for Barycentric Coordinates.", "tags": ["barycentriccoordinates"], "likes": 0, "viewed": 28, "date": "1629797911", "time_retrieved": "2024-06-20T20:47:35.524801", "image_code": "// The triangle UI is base on https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n\nvec3 caculate_col(vec3 p, vec3 pos_a, vec3 pos_b, vec3 pos_c, \n                    vec3 col_a, vec3 col_b, vec3 col_c){\n    float alpha = (-(p.x-pos_b.x)*(pos_c.y-pos_b.y) + (p.y-pos_b.y)*(pos_c.x-pos_b.x))/(-(pos_a.x-pos_b.x)*(pos_c.y-pos_b.y)+(pos_a.y-pos_b.y)*(pos_c.x-pos_b.x));\n    float beta = (-(p.x-pos_c.x)*(pos_a.y-pos_c.y) + (p.y-pos_c.y)*(pos_a.x-pos_c.x))/(-(pos_b.x-pos_c.x)*(pos_a.y-pos_c.y)+(pos_b.y-pos_c.y)*(pos_a.x-pos_c.x));\n    float gamma = 1. - alpha - beta;\n    \n    return alpha*col_a + beta*col_b + gamma*col_c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 pos_a = vec3(0.25, 0.5,0.);\n    vec3 pos_b = vec3(0.5, 0.75,0.);\n    vec3 pos_c = vec3(0.75, 0.25,0.);\n    \n    vec3 col_a = vec3(1.,0.,0.);\n    vec3 col_b = vec3(0.,1.,0.);\n    vec3 col_c = vec3(0.,0.,1.);\n    \n    float d = udTriangle(vec3(uv.xy,0.),pos_a,pos_b,pos_c);\n    \n    vec3 col = vec3(0.);\n    \n    if(d > 0.){\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    }else{\n        col = caculate_col(vec3(uv.xy,0.),pos_a,pos_b,pos_c,col_a,col_b,col_c);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdcGDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 99, 124, 124, 143], [144, 144, 169, 169, 188], [189, 189, 225, 225, 253], [255, 255, 307, 307, 804], [807, 807, 926, 926, 1346], [1349, 1349, 1406, 1456, 2043]]}
{"id": "NdcGWN", "name": "Sphere - Soft shadow ", "author": "wylm", "description": "base on https://www.shadertoy.com/view/4d2XWV", "tags": ["softshadow"], "likes": 0, "viewed": 27, "date": "1629788574", "time_retrieved": "2024-06-20T20:47:36.118715", "image_code": "// This shader is base on https://www.shadertoy.com/view/4d2XWV\n\n//-------------------------------------------------------------------------------------------\n// sphere related functions\n//-------------------------------------------------------------------------------------------\n\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph, in float k )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    \n#if 1\n    // physically plausible shadow\n    float d = sqrt( max(0.0,sph.w*sph.w-h)) - sph.w;\n    float t = -b - sqrt( max(h,0.0) );\n    return (t<0.0) ? 1.0 : smoothstep(0.0, 1.0, 2.5*k*d/t );\n#else\n    // cheap but not plausible alternative\n    return (b>0.0) ? step(-0.0001,c) : smoothstep( 0.0, 1.0, h*k/b );\n#endif    \n}    \n            \nfloat sphOcclusion( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3  r = sph.xyz - pos;\n    float l = length(r);\n    return dot(nor,r)*(sph.w*sph.w)/(l*l*l);\n}\n\nvec3 sphNormal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\n//=====================================================\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    \n\tvec3 ro = vec3(0.0, 0.0, 4.0 );\n\tvec3 rd = normalize( vec3(p,-1.5) );\n\t\n    // sphere animation\n    vec4 sph = vec4( cos( iTime + vec3(2.0,1.0,1.0) + 2.0 )*vec3(1.5,0.0,1.0), 1.0 );\n\n    vec3 lig = normalize( vec3(sin(iTime),sin(iTime)+1.5,-sin(iTime)) );\n    vec3 col = vec3(0.0);\n\n    float tmin = 1e10;\n    vec3 nor;\n    float occ = 1.0;\n    \n    // deal plane intersection\n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        vec3 pos = ro + t1*rd;\n        nor = vec3(0.0,1.0,0.0);\n        occ = 1.0-sphOcclusion( pos, nor, sph );\n\n    }\n\n    // deal sphere intersection\n    float t2 = sphIntersect( ro, rd, sph );\n    if( t2>0.0 && t2<tmin )\n    {\n        tmin = t2;\n        vec3 pos = ro + t2*rd;\n        nor = sphNormal( pos, sph );\n        occ = 0.5 + 0.5*nor.y;\n\t}\n    \n    // deal sphere soft-shadow\n    if( tmin<1000.0 )\n    {\n        vec3 pos = ro + tmin*rd;\n        \n\t\tcol = vec3(1.0);\n        col *= clamp( dot(nor,lig), 0.0, 1.0 ); // this line code is to caculate diffuse term\n        col *= sphSoftShadow( pos, lig, sph, 2.0 ); // actually this line code is to caculate sphere soft-shadow\n        col += 0.05*occ; // this line code is to caculate ambient occlusion term\n\t    col *= exp( -0.05*tmin ); // this line code is to make the plane's border softly\n    }\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdcGWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[65, 282, 341, 341, 504], [507, 507, 579, 579, 1033], [1051, 1051, 1112, 1112, 1213], [1215, 1215, 1259, 1259, 1296], [1298, 1355, 1378, 1378, 1448], [1450, 1450, 1490, 1490, 1523], [1525, 1525, 1582, 1582, 2995]]}
{"id": "NdcGzj", "name": "Black-body spectrum", "author": "Althar", "description": "The spectrum is computed via integration, rather than the approximated planckian locus formula (e.g. 'https://www.shadertoy.com/view/tsKczy' which matches very closely). Mouse click and drag to show a single temperature or let the cursor slide by itself.", "tags": ["blackbody", "colortemperature", "cie"], "likes": 2, "viewed": 76, "date": "1630150040", "time_retrieved": "2024-06-20T20:47:36.846257", "image_code": "// Constants\nconst float pi                   = 3.14159265359;\nconst float plancks_constant     = 6.62607015 * 10e-35;\nconst float boltzmanns_constant  = 1.38064852 * 10e-24;\nconst float speed_of_light       = 299792458.0;\n\n// Settings\nconst uint number_of_iterations       = 64u;\nconst float min_temperature_in_kelvin = 1000.0;\nconst float max_temperature_in_kelvin = 12000.0;\n\n// Gaussian function - see : https://en.wikipedia.org/wiki/CIE_1931_color_space\nfloat gaussian(float x, float a, float u, float a1, float a2)\n{\n    float t = (x - u) / (x < u ? a1 : a2);\n\treturn a * exp(-(t * t) / 2.0);\n}\n\n// Wave length to XYZ conversion - see : https://en.wikipedia.org/wiki/CIE_1931_color_space\nvec3 convert_wave_length_to_XYZ(float wave_length_nm)\n{\n\t// The analytical approximation assumes the wave length is measured in angstroms\n\tfloat wave_length_angstroms = wave_length_nm * 10.0;\n    \n\t// Approximate with the sum of gaussian functions\n\tvec3 XYZ;\n\tXYZ.x = gaussian(wave_length_angstroms, 1.056, 5998.0, 379.0, 310.0) + gaussian(wave_length_angstroms, 0.362, 4420.0, 160.0, 267.0) + gaussian(wave_length_angstroms, -0.065, 5011.0, 204.0, 262.0);\n\tXYZ.y = gaussian(wave_length_angstroms, 0.821, 5688.0, 469.0, 405.0) + gaussian(wave_length_angstroms, 0.286, 5309.0, 163.0, 311.0);\n\tXYZ.z = gaussian(wave_length_angstroms, 1.217, 4370.0, 118.0, 360.0) + gaussian(wave_length_angstroms, 0.681, 4590.0, 260.0, 138.0);\n    \n    // Done\n\treturn XYZ;\n}\n\n// XYZ to sRGB conversion - see : https://en.wikipedia.org/wiki/SRGB\nvec3 convert_XYZ_to_sRGB(vec3 XYZ)\n{\n\t// CIE XYZ -> sRGB\n\tvec3 sRGB;\n\tsRGB.x =  3.2406 * XYZ.x - 1.5372 * XYZ.y - 0.4986 * XYZ.z;\n\tsRGB.y = -0.9689 * XYZ.x + 1.8758 * XYZ.y + 0.0415 * XYZ.z;\n\tsRGB.z =  0.0557 * XYZ.x - 0.2040 * XYZ.y + 1.0570 * XYZ.z;\n\t\n\t// Apply gamma correction\n\tfloat a = 0.055;\n\tsRGB.x = (sRGB.x <= 0.0031308) ? 12.92 * sRGB.x : (1.0 + a) * pow(sRGB.x, 1.0 / 2.4) - a;\n\tsRGB.y = (sRGB.y <= 0.0031308) ? 12.92 * sRGB.y : (1.0 + a) * pow(sRGB.y, 1.0 / 2.4) - a;\n\tsRGB.z = (sRGB.z <= 0.0031308) ? 12.92 * sRGB.z : (1.0 + a) * pow(sRGB.z, 1.0 / 2.4) - a;\n\t\n\t// Done\n\treturn vec3(sRGB.x, sRGB.y, sRGB.z);\n}\n\n// Implementation of Planck's law - see : https://en.wikipedia.org/wiki/Planck%27s_law\nfloat convert_wave_length_to_black_body_spectrum(float wave_length_nm, float temperature_in_kelvin)\n{\n    float wave_length_in_meters = wave_length_nm * 1e-9;\n    float c1                    = 2.0 * pi * plancks_constant * speed_of_light * speed_of_light;\n    float c2                    = plancks_constant * speed_of_light / boltzmanns_constant;\n    float m                     = c1 / pow(wave_length_in_meters, 5.0) * 1.0 / (exp(c2 / (wave_length_in_meters * temperature_in_kelvin)) - 1.0);\n    return m;\n}\n\n// Information on remapping the black body temperature to sRGB - see : https://astronomy.stackexchange.com/questions/39994/what-is-the-rgb-curve-for-blackbodies\n// Another good reference for implementation : https://www.fourmilab.ch/documents/specrend/specrend.c\nvec3 convert_black_body_temperature_to_sRGB(float temperature_in_kelvin) \n{\n\tvec3 XYZ = vec3(0.0);\n\n    // Integrate\n    for (uint k = 0u ; k < number_of_iterations ; ++k)\n    {\n        float wave_length_nm = mix(380.0, 780.0, float(k) / float(number_of_iterations - 1u));\n        float spectrum       = convert_wave_length_to_black_body_spectrum(wave_length_nm, temperature_in_kelvin);\n\n        // Accumulate\n        XYZ += spectrum * convert_wave_length_to_XYZ(wave_length_nm);\n    }\n\n    // Normalize to the tristimulus values\n    vec2 xy = XYZ.xy / (XYZ.x + XYZ.y + XYZ.z);\n\n\t// The sRGB colour space assumed that the XYZ has been scaled to (0.9505, 1, 1.0890) for CIE D65, i.e. Y = 1\n\tXYZ = vec3(xy.x / xy.y, 1.0, (1.0 - xy.x - xy.y) / xy.y);\n\t\n\t// XYZ to sRGB\n\tvec3 sRGB = convert_XYZ_to_sRGB(XYZ);\n\n    // Normalize RGB to preserve chromaticity\n\treturn sRGB / max(sRGB.x, max(sRGB.y, sRGB.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n     \n    // Normalised cursor\n    float cursor_position = (iMouse.z > 0.0) ? (iMouse.x / iResolution.x) : cos(0.25 * iTime) * 0.5 + 0.5;\n    \n    if( uv.y < 0.5 )\n    {\n        // Black body temperature\n        float temperature_in_kelvin = mix(min_temperature_in_kelvin, max_temperature_in_kelvin, cursor_position);\n        vec3 sRGB = convert_black_body_temperature_to_sRGB(temperature_in_kelvin);\n        \n        fragColor = vec4(sRGB,1.0);\n    }\n    else\n    {\n        // Black body temperature\n        float temperature_in_kelvin = mix(min_temperature_in_kelvin, max_temperature_in_kelvin, uv.x);\n        vec3 sRGB = convert_black_body_temperature_to_sRGB(temperature_in_kelvin);\n\n        // Output to screen\n        fragColor = vec4(sRGB,1.0);\n        \n        // Show cursor\n        if( abs(fragCoord.x - cursor_position * iResolution.x) < 1.0 )\n        {\n            fragColor = mix(fragColor, vec4(1.0) - fragColor, 0.1);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdcGzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[379, 459, 522, 522, 600], [602, 694, 749, 831, 1450], [1452, 1521, 1557, 1577, 2143], [2145, 2232, 2333, 2333, 2740], [2742, 3005, 3080, 3080, 3907], [3909, 3909, 3966, 4016, 5007]]}
{"id": "NdcGzN", "name": "plasma overflow", "author": "hikiko", "description": "Some color here overflows I think but I like the pink result :)", "tags": ["plasma", "pink", "salata", "overflow"], "likes": 3, "viewed": 91, "date": "1629217006", "time_retrieved": "2024-06-20T20:47:36.846257", "image_code": "#define M_PI 3.14159\nconst vec2 res = vec2(800.0, 600.0);\n\nfloat psin(float x)\n{\n\treturn sin(x) * 0.5 + 0.5;\n}\n\nfloat pcos(float x)\n{\n\treturn cos(x) * 0.5 + 0.5;\n}\n\nfloat rsin(vec2 uv, vec2 c, float freq)\n{\n\treturn psin(length(uv - c) * freq);\n}\n\nfloat rcos(vec2 uv, vec2 c, float freq)\n{\n\treturn pcos(length(uv - c) * freq);\n}\nvec3 hsv2rgb(in vec3 c)\n{\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 plasma_color(float n)\n{\n\treturn hsv2rgb(vec3(n, 0.66, 1.9));\n\n\t/* float t = n * M_PI * 2.0;\n\treturn vec3(pcos(t), psin(t), 1.0 - pcos(t)); */\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n\n    vec2 uv = fragCoord/iResolution.xy * vec2(aspect, 1.0);\n\n\tfloat plasma = rcos(uv + psin(uv.y * 3.0 * cos(iTime)) * 0.3, vec2(0.2, 0.4), 8.0);\n\tplasma += psin(uv.x * 4.0 + pcos(uv.y * 3.0) + rsin(uv, vec2(0.8, 0.6), 8.0) * 6.0 * sin(iTime));\n\tplasma += pcos(uv.y * 6.0 + psin(uv.x * 1.5));\n\tplasma += psin(uv.x * uv.y * 5.0 * sin(cos(iTime * 0.4))) * 3.0;\n\n\tfragColor.rgb = plasma_color(plasma);\n\tfragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdcGzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[59, 59, 80, 80, 110], [112, 112, 133, 133, 163], [165, 165, 206, 206, 245], [247, 247, 288, 288, 327], [328, 328, 353, 353, 516], [518, 518, 546, 546, 666], [668, 668, 725, 725, 1197]]}
{"id": "Ndd3R8", "name": "O -= O tests", "author": "elenzil", "description": "setups, top to bottom:\n1) O\n2) float(iFrame)\n3) sin(t) in [-1, 1]\n4) NaN\n5) Inf\n6) O -= O\n7 .. 9) various O -= styles which should yield 0.5\n\ntests, left to right:\nA) isnan()\nB) isinf()\nC) bits!\nD) value", "tags": ["ios"], "likes": 2, "viewed": 140, "date": "1629139773", "time_retrieved": "2024-06-20T20:47:36.846257", "image_code": "\nvoid mainImage( out vec4 O, in vec2 XY )\n{\n    vec2 UV = XY / iResolution.xy;\n    \n    //----------------------------------------------\n    // Setup the value\n    \n    float runtimeInf = uintBitsToFloat(uint(0x7f800000));\n    float runtimeNaN = uintBitsToFloat(uint(0x7fffffff));\n    \n    const float NumSetups = 9.0;\n    \n    float t = iTime * 3.14159265 * 2.0 / 10.0;\n\n    if (false) { /* noop */ }\n    else if (UV.y > 8.0 / NumSetups) {       // O\n        /* noop */\n    }\n    else if (UV.y > 7.0 / NumSetups) {       // iFrame\n        O = vec4(float(iFrame));\n    }\n    else if (UV.y > 6.0 / NumSetups) {       // sin(t) in [-1, 1]\n        O = vec4(sin(t));\n    }\n    else if (UV.y > 5.0 / NumSetups) {       // NaN\n        O = vec4(runtimeNaN);\n    }\n    else if (UV.y > 4.0 / NumSetups) {       // Inf\n        O = vec4(runtimeInf);\n    }\n    else if (UV.y > 3.0 / NumSetups) {       // O -= O\n        O -= O;\n    }\n    else if (UV.y > 2.0 / NumSetups) {       // O += 0.5 - O\n        O += 0.5 - O;\n    }\n    else if (UV.y > 1.0 / NumSetups) {       // O -= O - 0.5\n        O -= O - 0.5;\n    }\n    else if (UV.y > 0.0 / NumSetups) {       // O -= -0.5 + O\n        O -= -0.5 + O;\n    }\n    \n    //----------------------------------------------\n    // Examine the value\n    \n    const float NumTests = 4.0;\n    if (false) {}\n    else if (UV.x < 1.0 / NumTests) {\n        O.rgb = vec3(isnan(O.r) ? 0.5 : 0.0);\n    }\n    else if (UV.x < 2.0 / NumTests) {\n        O.rgb = vec3(isinf(O.r) ? 0.5 : 0.0);\n    }\n    else if (UV.x < 3.0 / NumTests) {\n        float testWidthPx = iResolution.x / NumTests;\n        int i = int(XY.x - testWidthPx * 2.0);\n        int bitIndex = int(float(i) * 32.0 / testWidthPx);\n        uint bitValue = (floatBitsToUint(O.r) >> (31 - bitIndex)) % uint(2);\n        O = vec4(bitValue == uint(1) ? 1.0 : 0.0);\n        O = mix(O, vec4(0.5), step(0.7, fract(float(i)  * 32.0 / testWidthPx)));\n    }\n    else { /* noop */ }\n    \n    bool isGridLine = false;\n    isGridLine = isGridLine || !bool(step(3.0, mod(XY.y, (iResolution.y - 2.0) / NumSetups)));\n    isGridLine = isGridLine || !bool(step(3.0, mod(XY.x, (iResolution.x - 2.0) / NumTests )));\n\n    if (isGridLine) {\n        O.rgb = vec3(0.7, 0.0, 0.5);\n    }\n\n    \n    O.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ndd3R8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 43, 43, 2258]]}
{"id": "Ndd3zN", "name": "Luminary", "author": "DrNoob", "description": "Animated reproduction of \"Luminary\" by Ben Kovach:\nhttps://bendotk.com/#/luminary/", "tags": ["noise", "grid", "circle", "reproduction"], "likes": 10, "viewed": 101, "date": "1629314449", "time_retrieved": "2024-06-20T20:47:37.688622", "image_code": "// Author: Thomas Stehle\n// Title: Hommage à Ben Kovach 2 (\"Luminary\", 2021)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Animated reproduction of \"Luminary\" by Ben Kovach:\n// https://bendotk.com/#/luminary/\n//\n// Technical note: I didn't find a good solution for analytical\n// anti-aliasing so this piece does the unsatisfactory multipass\n// approach instead.\n\n// Constants\nconst int AA = 2; // Anti aliasing passes = AA^2\nconst int NCOLORS = 5;\nconst int NLAYERS = NCOLORS - 1;\nconst int GRIDSIZE = 9;\nconst vec2 GRID = vec2(GRIDSIZE);\n\n// 1D hash for 1D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash(in float p) {\n    p = fract(p * 0.011);\n    p *= p + 7.5;\n    p *= p + p;\n    return fract(p);\n}\n\n// 1D hash for 2D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 2D value noise by Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vnoise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash12(i);\n    float b = hash12(i + vec2(1.0, 0.0));\n    float c = hash12(i + vec2(0.0, 1.0));\n    float d = hash12(i + vec2(1.0, 1.0));\n\n    // Smooth interpolation (smoothstep without clamping)\n    vec2 u = f*f * (3.0 - 2.0*f);\n\n    // Mix 4 coorners\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// SDF for a circle\nfloat sdCircle(in vec2 p, in vec2 c, in float r) {\n    return length(p - c) - r;\n}\n\n// Circles arranged in a grid\n// Returns the distance to a circle and its ID\nvec2 circleLayer(in vec2 p) {\n    p *= GRID;\n    vec2 uv = fract(p);\n    vec2 id = floor(p);\n\n    float d = sdCircle(uv, vec2(0.5), 0.5);\n    return (d < 0.0) ?\n        vec2(d, 1.0 + id.x + GRID.x * id.y) :\n        vec2(d, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 result = vec3(0.0);\n\n    // Anti-aliasing loop\n    for (int j = 0; j < AA; ++j) {\n    for (int i = 0; i < AA; ++i) {\n        // Screen coordinates\n        vec2 off = vec2(i,j) / float(AA);\n        vec2 st = (fragCoord.xy + off) / iResolution.xy;\n        st.x *= iResolution.x / iResolution.y;\n    \n        // Circle layer with specific offset\n        vec2 layers[NLAYERS];\n        layers[0] = circleLayer(st);\n        layers[1] = circleLayer(st + vec2(0.5, 0.0));\n        layers[2] = circleLayer(st + vec2(0.0, 0.5));\n        layers[3] = circleLayer(st + vec2(0.5));\n\n        // Principal color per layer\n        vec3 colors[NCOLORS];\n        colors[0] = vec3(251, 246, 223) / 255.0; // beige\n        colors[1] = vec3(247, 210,  73) / 255.0; // yellow\n        colors[2] = vec3(153, 164, 137) / 255.0; // green\n        colors[3] = vec3( 60,  62,  58) / 255.0; // brown\n        colors[4] = vec3( 19,  54, 131) / 255.0; // blue\n\n        // Time\n        float t = 0.5 * iTime;\n\n        // Bias the noise towards the right\n        float f = st.x;\n\n        // Noise value per pixel per layer\n        float noise[NCOLORS];\n        noise[0] = 1.0;\n        noise[1] = f * vnoise(1.0 * st + t);\n        noise[2] = f * vnoise(2.0 * st + t + 1.0);\n        noise[3] = f * vnoise(3.0 * st + t - 1.0);\n        noise[4] = f * vnoise(4.0 * st + t + 1.0);\n\n        // Combine the IDs to form one ID that represents a circle fragment\n        int id = int(layers[0].y) +\n                 int(layers[1].y) * GRIDSIZE +\n                 int(layers[2].y) * GRIDSIZE*GRIDSIZE +\n                 int(layers[3].y) * GRIDSIZE*GRIDSIZE*GRIDSIZE;\n\n        // Hash for the combined ID\n        float h = hash(float(id));\n\n        // Mix colors of all layers per circle fragment\n        vec3 col = colors[0];\n        for (int k = 1; k < NCOLORS; ++k) {\n            float w = h * step(h, noise[k]);\n            col = mix(col, colors[k], w);\n        }\n\n        // Accumulate result color\n        result += col;\n    }\n    }\n    result /= float(AA * AA);\n    \n    // Contrast stretching\n    result = pow(result, vec3(1.2));\n    \n    // Final color\n    fragColor = vec4(result, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ndd3zN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[587, 669, 693, 693, 776], [778, 860, 885, 885, 1003], [1005, 1082, 1107, 1107, 1561], [1563, 1583, 1633, 1633, 1665], [1667, 1744, 1773, 1773, 1974], [1976, 1976, 2031, 2031, 4189]]}
{"id": "NddGDN", "name": "Bézier Curve – Algebraic Formula", "author": "wylm", "description": "quadratic Bézier curve from three points.", "tags": ["beziercurve"], "likes": 3, "viewed": 52, "date": "1629877521", "time_retrieved": "2024-06-20T20:47:38.118889", "image_code": "#define E 2.718281828459\n\nfloat t(){\n    return pow(E,-1. * pow(2. * cos(iTime),2.));\n}\n\nfloat line(vec2 uv, vec2 p1, vec2 p2){\n    float k = (p1.y-p2.y)/(p1.x-p2.x);\n    float b = p1.y - k * p1.x;\n    return k*uv.x + b - uv.y;\n}\n\nvec2 line_pos(float t, vec2 b0, vec2 b1){\n    return (1.-t)*b0 + t*b1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.8);\n    \n    \n    vec2 b0 = vec2(0.25,0.25);\n    vec2 b1 = vec2(1.,0.75);\n    vec2 b2 = vec2(1.5,0.25);\n    \n    float t = t();\n    vec2 b01 = line_pos(t, b0, b1);\n    vec2 b11 = line_pos(t, b1, b2);\n    vec2 b02 = line_pos(t, b01, b11);\n    \n    //draw line\n    float d = abs(line(uv,b0,b1));\n    if(d < 0.005 && uv.x>b0.x && uv.x<b1.x){\n        col *= mix(col, vec3(0.1), smoothstep(-fwidth(d), fwidth(d), d));\n    }\n    \n    d = abs(line(uv,b1,b2));\n    if(d < 0.005 && uv.x>b1.x && uv.x<b2.x){\n        col *= mix(col, vec3(0.1), smoothstep(-fwidth(d), fwidth(d), d));\n    }\n    \n    // draw point\n    float ps = 0.02;\n    float r = length(uv-b0);\n    if(r<ps){\n        col *= mix(col, vec3(1.,0.1,0.1), smoothstep(-fwidth(r), fwidth(r), r));\n    }\n    \n    r = length(uv-b1);\n    if(r<ps){\n        col *= mix(col, vec3(0.1,1.,0.1), smoothstep(-fwidth(r), fwidth(r), r));\n    }\n    \n    r = length(uv-b2);\n    if(r<ps){\n        col *= mix(col, vec3(0.1,0.1,1.), smoothstep(-fwidth(r), fwidth(r), r));\n    }\n    \n    r = length(uv-b01);\n    if(r<ps){\n        col *= mix(col, vec3(1.,1.,0.1), smoothstep(-fwidth(r), fwidth(r), r));\n    }\n    \n    r = length(uv-b11);\n    if(r<ps){\n        col *= mix(col, vec3(0.1,1.,1.), smoothstep(-fwidth(r), fwidth(r), r));\n    }\n    \n    r = length(uv-b02);\n    if(r<ps){\n        col *= mix(col, vec3(1.,0.1,1.), smoothstep(-fwidth(r), fwidth(r), r));\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NddGDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[26, 26, 36, 36, 87], [89, 89, 127, 127, 229], [231, 231, 272, 272, 303], [305, 305, 362, 412, 2011]]}
{"id": "NddGWN", "name": "CubeLand", "author": "scry", "description": "why are there cubes\n\nidk why I couldn't quite get the fllor on line 68 to line up correctly\nalso if anyone knows why is gets grainy as it gets to ~300 iTime, that would be appreciated.", "tags": ["3d", "raymarch", "trippy", "polar", "logpolar"], "likes": 4, "viewed": 171, "date": "1629864618", "time_retrieved": "2024-06-20T20:47:38.118889", "image_code": "#define time iTime\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 map(vec3 p) {\n    \n    p.z -= 5.;\n    //p.z += time*20.; \n    //p.xy -= (sin(time)*3);\n    //p.yz *= r2d(-02);\n    vec3 o = p;\n    float d = 1000.;\n    p = o;\n    float lxz = (length(p.xz));\n    //vec2 pc = p.xz;\n    vec2 pc = vec2(log(lxz),atan(p.x,p.z));\n    //p.y += (sin(pc.x*10.-time*30)+sin(pc.y*1.+lxz+time*10.)*3)*0.01*lxz;\n    //pc.y += time*0.01;\n    //pc = vec2(log(length(pc)),atan(pc.x,pc.y));\n    \n    float ns = 1.;\n    //pc.y *= 3./3.141;\n    //pc.y = (fract(pc.y-0.5));\n    //pc.y *= 2./3.141;\n    \n    pc.x -= time*0.3;\n\n\n    vec3 bp = p;\n    float fy = 0.;\n    float bps = 0.6;\n    vec2 fpc = pc;\n    //fpc.y *= .;\n    //fpc.x *= 16./3.14159; \n    fpc = floor(fpc/bps)*bps;\n   \n    //fpc.y = floor(fpc.y/bps)*bps;\n    //fpc.y += sin(time);\n    for (int i=0;i<4;i++) {\n        ns += 1.0;\n        //p.y += (sin(pc.x*10*ns*0.1*pc.y*0.00)*0.4)*lxz*0.1;\n        p.y += (sin(pc.y*6.*ns*0.5+pc.x*sin(ns*0.5)*10.)*0.04)*lxz;\n        p.y += (sin(pc.y*2.*ns*0.5+pc.x*sin(ns*20.)*20.)*0.04)*lxz;\n        fy += (sin(fpc.y*6.*ns*0.5+fpc.x*sin(ns*0.5)*10.)*0.04)*lxz;\n        fy += (sin(fpc.y*2.*ns*0.5+fpc.x*sin(ns*20.)*20.)*0.04)*lxz;\n        //p.y += (sin(pc.x*sin(ns)*20.03)+sin(pc.y*sin(ns)*40.+pc.x*0.1))*0.01*lxz;\n        //p.y += (sin(pc.x*ns-time*3*ns+pc.y)+sin(pc.y*ns+pc.x))*0.04*lxz;\n        \n    }\n    bp.zx = pc;\n    //bp.z *= 1;\n    bp.y += 1.; \n    bp.x /= 1./bps;\n    bp.x *= 8./3.14159;\n    bp.x += sin(bp.z*.1)*5.;\n    bp.xz = (fract(bp.xz/bps)-0.5)*bps;\n    //bp.y /= lxz;\n    //bp.y += -0.05;\n    \n    bp.y += (fy*sin(log(lxz)*2.+time));\n    bp.y -= 0.2;\n    bp.y /= lxz;\n    bp.xz *= r2d(pc.y*0.1);\n    bp.xy *= r2d(pc.y*0.4);\n    //bp.y *= 0.3;\n    float db = sdBoxFrame(bp,vec3(0.03),0.004)*(lxz+0.1)*0.5;\n    //db *= lxz;\n    //db *= 0.99;\n    //db -= 0.001;\n    //d = min(d,//);\n    //pc.y *= 3./3.141;\n    //pc.y = (fract(pc.y-0.5));\n    //pc.y += 1./3.14;\n    \n    //pc.y *= 10./3.14;\n    //p.y += sin(pc.y*10.+pc.x*20.+time*4.)*0.2;\n    //p.y += lxz;\n    if (p.y+1. > db) {\n        pc.y -= 2.;\n    }\n    d = db-0.;\n    d = min(d,length(p.y+1.)*0.3);\n    //d += 0.01;\n    //float d = length(p)-1.;\n    return vec4(pc.x,lxz,pc.y,d);\n}\n\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<64;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w;\n        dO += dS;\n        ii += 0.02;\n        if (dO > 24.2 || dS < 0.0005) {break;}\n    }\n    return vec2(dO,ii);\n}\n\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.00003; // or some other value\n    const vec2 h = vec2(eps,0.);\n    return normalize( vec3(map(p+h.xyy).w - map(p-h.xyy).w,\n                           map(p+h.yxy).w - map(p-h.yxy).w,\n                           map(p+h.yyx).w - map(p-h.yyx).w ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1. + 2. * (fragCoord/iResolution.xy);\n    //vec2 uv = -1. + 2. * inData.v_texcoord;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    uv.x*=ar;\n    float c = length(uv);\n    //uv.y -= 0.3;\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.,0.,2.);\n    vec3 rd = normalize(vec3(uv,.75+c*0.75));\n    vec2 ra = vec2(cos(time),sin(time))*0.3;\n\n    //ro.z += sin(uv.x*4.*uv.y+time*2.)-c*2.;\n    //ro.z *= 0.2;\n    //ra.z += sin(time+sin(uv.x));\n    //ra.x += floor(sin((uv.x*1.)*150.*(sin(uv.x*0.01+time*0.1)*0.5+0.5)))*0.1;\n    //ra.y += floor(sin((uv.y*1.)*150.*(sin(uv.y*0.01+time*0.08)*0.5+0.5)))*0.1;\n    //ra.x += sin(uv.y*1.+time)*0.2;\n    //ro.xz *= r2d(ra.x);\n    //rd.xz *= r2d(ra.x);\n    //ro.yz *= r2d(ra.y);\n    rd.yz *= r2d(-.25);\n    vec2 d = RM(ro,rd);\n    vec3 p = ro+rd*d.x;\n    \n    vec3 mp = map(p).xyz;\n    //p.xy *= r2d(time);\n    vec3 norm = calcNormal(p);\n    p.z -= 5.;\n    float lz = length(p.xz);\n    \n    //col = 1.-d.xxx*.1;\n    col = hsv2rgb(vec3(floor(mp.z/3.14/2.*5.+mp.x*0.4)/5.,floor(sin(mp.x*10.1+mp.z*2.)*2.)/2.,(1.15-d.x*0.2)));\n    \n    //col = hsv2rgb(vec3(floor(mp.z/3.14/2*5.+mp.x*0.4)/5.,floor(sin(mp.x*10.1+mp.z*2.)*2.)/2,clamp(1.-d.x*0.1,0.,1.)));\n    col += (clamp(sin(mp.z*30.)+sin(mp.x*90.),-0.,0.1)*5.-0.5)+d.y*0.08;\n    norm.xz *= r2d(mp.x*0.2);\n    col += (norm.x*2.)*0.4;\n    //col.rg += (d.y*0.05-0.5);\n    fragColor = vec4(col,1.);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NddGWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[20, 20, 39, 39, 88], [90, 90, 135, 135, 417], [419, 478, 500, 500, 831], [835, 894, 916, 916, 1085], [1087, 1087, 1105, 1105, 3258], [3260, 3260, 3287, 3287, 3527], [3530, 3530, 3581, 3581, 3854], [3856, 3856, 3913, 3913, 5368]]}
{"id": "NddGzn", "name": "3D close-loop spiral", "author": "FabriceNeyret2", "description": "WIP\nmouse control\n", "tags": ["spiral", "short"], "likes": 26, "viewed": 227, "date": "1629026481", "time_retrieved": "2024-06-20T20:47:38.367645", "image_code": "\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )             // rotation                  \nvec3 M;\n\n#define TAU 6.283185\n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.,l,a,A,s,z=0.,S,H,h,l2,r=25.,r2=20.33; //, Z=0.;\n    vec2  P,d;\n    vec3  R = iResolution,\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),         // ray direction\n          p = 90./R, q;                                      // marching point along ray \n       // M =  iMouse.xyz/R -.5;\n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0));\n     \n    for ( O=vec4(0) ; O.x < 1.5 && t > .01 ; O+=.01 )\n        t=9., q = p,\n        q.yz *= rot( .5+6.*M.y),                             // rotations\n        q.xz *= rot( 2.-6.*M.x),\n        q.zy *= H = sign(h=q.y),           q.y -= r/2.,      // top-down symmetry\n        q.xz *= S = sign(q.x +sign(q.z)) , q.x -= TAU*3.5,   // left-right symmetry\n        l = length(q.xz), a = atan(q.z,q.x),\n        s = min( TAU*3.5, l - a),                            // spiral coord ( truncated )\n        l = round(s/TAU)*TAU + a,                            // l reset at tube center\n        l = max(0.,r-l),\n        q.y += r2 - sqrt(max(0.,r2*r2-l*l)),                 // spiral sinking\n        t = min(t, length(vec2( mod(s+TAU/2.,TAU)-TAU/2.,q.y)) - 1.), // SDF\n        p += .25*t*D; // , Z+=t;                             // step forward = dist to obj          \n\n // O = vec4(1.6-Z/200.); return;                    // for Depth buffer\n    a = max (0., round(s/TAU)*TAU + a );\n    a = S*H*a*a/2.-20.*iTime -H;                             // curvilinear coordinate\n  //O = max(1.5-3.*O,0.);\n    O = O.x > 1.5 ? vec4(0.) : 4.*exp(-3.*O/2.);             // luminance (depth + pseudo-shading )\n                           // vec4(exp(-(Z-300.)/200.));\n    O *= (.6+.4*sin(a)) *vec4(.5+.5*h/r2,.5-.5*h/r2,0,0);    // color\n      // (.6+.4*clamp(sin(a)/fwidth(a),-1.,1.))\n // O *= .5+.5* vec4(cos(a),sin(a),min(2.,4.*h/r),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NddGzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[123, 123, 159, 159, 1976]]}
{"id": "NddGzr", "name": "shooting stars", "author": "snflwrfld", "description": "rows of stars w/ daynight cycle", "tags": ["2d"], "likes": 8, "viewed": 114, "date": "1629033437", "time_retrieved": "2024-06-20T20:47:38.931267", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat PI = 3.14159;\nfloat TAU = 6.28318530718;\n\nvec3 color1 = vec3(0.960,0.843,0.911);\nvec3 color2 = vec3(0.816,0.576,0.505);\nvec3 color3 = vec3(0.773,0.522,0.702);\n\nmat2 rotate2d (float th) {\n    return mat2(cos(th),-sin(th),sin(th),cos(th));\n}\n\nfloat ring (vec2 st, float r, float e) {\n    return step(r,length(st))+(1.-step(r-e,length(st)));\n}\n\nfloat fract_usd (float x) {\n    return min(fract(x/2.),fract(-x/2.))*2.;\n}\n\nfloat fract2 (float x){\n    return abs((fract(x)-.5)*2.);\n}\n\nfloat star_mot (float x) {\n    return fract_usd(x*2.)*step(floor(mod(x,2.)),.9);\n}\n\nvec3 pattern (vec2 st, float t,float size) {\n    st = st*2. - 1.;\n    st *= size;\n    vec3 color = vec3(1.);\n    float r = length(st),th=atan(st.y,st.x);\n    \n    // circle\n    float c_size = fract_usd(t/2.);\n    \n    r = length(st),th=atan(st.y,st.x);\n    color *= ring(st,.9*smoothstep(0.,1.,c_size),.18);\n\n    // star\n    float s_size = smoothstep(.2,.85,star_mot(-.5+t/2.000));\n    float s_angle = smoothstep(.1,.9,fract(t/4.))*TAU;\n    \n    th += s_angle;\n    color *= step(.5,(r*(pow(abs(sin(th*2.5))+1.,1.216))*.85)/s_size);\n    return color;\n}\n\nfloat slider (float t,float cursor,float length) {\n    float tm = floor(mod(t,length));\n    if (tm<cursor){\n        return 1.;\n    }\n    else if (tm==cursor) {\n        return 1.-fract(t);\n    }\n    else  {\n        return 0.;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    float t = iTime*1.2;\n\t\n    // tilt+scale\n    float SCALE = 0.280;\n    float TILT_ANGLE = PI/11.112;\n    vec2 SLIDE_VEL = vec2(-.04,.02);\n    \n    st = st*2. -1.;\n    st = SCALE*(1.+.1*sin(t/10.))*rotate2d(TILT_ANGLE)*st + t*SLIDE_VEL ;\n    \n    \n    // pattern tiling\n    vec2 WAVE_VECTOR = vec2(0.770,0.740);\n    float WAVE_VEL = 1.;\n    \n    float n = 16.;\n    st *= n;\n\tvec2 ipos = floor(st), fpos = fract(st);\n    \n    vec3 color = pattern(fpos,t*WAVE_VEL+dot(ipos,WAVE_VECTOR),.9);\n    \n    // coloring\t-- CHANGE THE COLORS OUTSIDE OF MAIN()\n    st = ipos+fpos;\n    color += mix(color1,color2,smoothstep(0.,1.,fract_usd(st.x+st.y))/6.);\n    \n    // sliders animation\n    float CYCLE_LENGTH = 12.;\n    float FIRST_SLIDER_BEGIN = 0.;\n    float SECOND_SLIDER_EGIN = 3.;\n    float SLIDING_SPEED = .5;\n    \n    st = fragCoord.xy/iResolution.xy;\n    if (st.x > smoothstep(0.15,.85,slider(t*SLIDING_SPEED,FIRST_SLIDER_BEGIN,CYCLE_LENGTH)) && st.x < smoothstep(0.15,.85,slider(t*SLIDING_SPEED,SECOND_SLIDER_EGIN,CYCLE_LENGTH)) ){\n        color = 1. - color;\n        color = step(0.0,color)*0.882;\n    }\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NddGzr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[284, 284, 310, 310, 363], [365, 365, 405, 405, 464], [466, 466, 493, 493, 540], [542, 542, 565, 565, 601], [603, 603, 629, 629, 685], [687, 687, 731, 731, 1238], [1240, 1240, 1290, 1290, 1472], [1474, 1474, 1529, 1529, 2757]]}
{"id": "Ndt3D8", "name": "ripple wave ", "author": "hahnzhu", "description": "ripple wave", "tags": ["wave"], "likes": 1, "viewed": 77, "date": "1629704529", "time_retrieved": "2024-06-20T20:47:38.931267", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);\n    float angle = atan(uv.y, uv.x);\n\n    float from = .1;  // origin size\n    float width = .2;  // ripple width\n    \n    for (float t = 0.0; t <= 1.0; t++) {\n        from = fract((iTime+0.9*t)*0.5)*2.;\n        float len = smoothstep(from, from-width, length(uv)) - smoothstep(from-width, from-width*2., length(uv));\n        float opacity = 1. - smoothstep(1.5, 2., from);\n        col += len * opacity;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ndt3D8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 618]]}
{"id": "Ndt3RS", "name": "project stochastics round 1", "author": "Dusty", "description": "a shuffling function", "tags": ["experiment"], "likes": 1, "viewed": 47, "date": "1630067586", "time_retrieved": "2024-06-20T20:47:39.161462", "image_code": "// a shuffling function, \n// that approximates an ideal noise generator to a high degree (*), \n// over all possible floating-point keys\n//\n// efficiency is the secondary consideration\n//\n// (*) visual artifact free over regular latices, non-repeating\n//\n// this strategy seems ok for the 2D case - not observing correlations\n// the transforms of both the key and hash value are each bijective\n//\n// quick update to improve survey \"camera\", added a single mixing op\n// and ... color ...\nfloat stochastics(uint h, vec2 key)\n{  \n  uvec2 k = uvec2(floatBitsToUint(key.x), floatBitsToUint(key.y));\n  k *= 0xCC2BFE9Du; k ^= (k >> 16);\n  h += k.x; h *= 0xCC2BFE9Du; h ^= (h >> 16); \n  h += k.y; h *= 0xCC2BFE9Du; h ^= (h >> 16);\n  h *= 0xCC2BFE9Du; h ^= (h >> 16);\n  return float((h * 0xCC2BFE9Du) & 0xffffffu) * (1.0 / float(0x1000000));\n}\n\nfloat stochastics(vec2 key)\n{\n  return stochastics(0u, key);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = floor(fragCoord + 100.0 * vec2(cos(0.1 * sqrt(iTime)), sin(0.1 * sqrt(iTime))) * iTime);\n    float r = stochastics(0u, p);\n    float g = stochastics(1u, p);\n    float b = stochastics(2u, p);\n    fragColor = vec4(r,g,b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ndt3RS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 486, 523, 523, 833], [835, 835, 864, 864, 897], [899, 899, 956, 956, 1195]]}
{"id": "Ndt3z7", "name": "spinning...cirles?", "author": "watershed", "description": "rotating circles domain warped via fbm(cellular_noise(st))", "tags": ["noise", "rotation", "domainwarp"], "likes": 8, "viewed": 164, "date": "1629415986", "time_retrieved": "2024-06-20T20:47:40.434281", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define TWO_PI 6.28318530718\n#define PI 3.141592653589793\n#define HALF_PI 1.5707963267948966\n\nfloat circle(in vec2 st, in vec2 center, float r, float smoothing_factor){\n    return 1.0-smoothstep(r-smoothing_factor, r+smoothing_factor, distance(st, center)); //*sin(atan(st.y,st.x))); //*TWO_PI*6.)+smoothstep(0.,1.,fract(st.x))));\n}\n\nfloat rand(float x){\n    return fract(sin(12.59585855*PI*x)+4102200.398383);\n}\n\nfloat circle_outline(in vec2 st, in vec2 center, float r, float stroke_weight){\n    float d = distance(st, center);\n    return smoothstep(fwidth(d), 0.0, abs(d-r));\n}\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\n\n//below fuctions from https://github.com/ashima/webgl-noise via Patricio Gonzalez\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n// vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\t\n\n\nfloat fbm(vec2 x)\n{    \n    float G = 0.5; //exp2(-H);\n    float freq = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        t += a*snoise(freq*x);\n        freq = pow(2.0, float(i));\n        // f += 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n\nfloat map(float x, float oldMin, float oldMax, float newMin, float newMax){\n    return (newMax-newMin) - (x-oldMin)/(oldMax-oldMin) + newMin;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nmat2 scale(float _scale){ //overload for scalar \n    return mat2(_scale,0.0,\n                0.0,_scale);\n}\n\nfloat spinning_cirlces_illusion(vec2 st, float time_scale, float offset){\n    vec2 center = vec2(.5); //translate to center of screen (assumes normalized st coords)\n    st -= center; //translate coords - remember origin in in the btm left\n    st = rotate2d((offset)) * st; //rotate\n    float circle = circle_outline(st, vec2(0), 0.25, 0.005); //circle centered at 0,0 since already translated\n    st += center; //untranslate coords \n\n    int t = 12;\n    for(int i=0; i<12; i++){\n        float r = 0.25;\n        // st = scale(1.5)*st;\n        vec2 new_center = vec2(r*cos(float(i)*TWO_PI/18.), r*sin(float(i)*TWO_PI/18.)); //relative to translated coord sys (dividing with numbers with various common factors leads to more symmetric or chaotic ring resonance)\n        st -= center; //translate coords - remember origin in in the btm left\n        st = rotate2d(iTime*time_scale) * st; //rotate\n        // circle += plot(st, r);\n        \n        circle += circle_outline(st, new_center, 0.25, 0.005); //circle centered at 0,0 since already translated\n        st += center; //untranslate coords \n    }\n\n    return circle;\n}\n\nfloat spinning_cirlces_illusion(vec2 st, float time_scale, float offset, float smoothing_factor){\n    vec2 center = vec2(.5); //translate to center of screen (assumes normalized st coords)\n    st -= center; //translate coords - remember origin in in the btm left\n    st = rotate2d((offset)) * st; //rotate\n    // float circle = (0.);\n    float circle = circle_outline(st, vec2(0), 0.25, 0.005); //circle centered at 0,0 since already translated\n    st += center; //untranslate coords \n\n    int t = 12;\n    for(int i=0; i<12; i++){\n        float r = 0.25;\n        // st = scale(1.5)*st;\n        vec2 new_center = vec2(r*cos(float(i)*TWO_PI/18.), r*sin(float(i)*TWO_PI/18.)); //relative to translated coord sys (dividing with numbers with various common factors leads to more symmetric or chaotic ring resonance)\n        st -= center; //translate coords - remember origin in in the btm left\n        st = rotate2d(iTime*time_scale) * st; //rotate\n        // circle += plot(st, r);\n        vec2 travelling_center = vec2(0);\n\n\n        circle += circle_outline(st, new_center, 0.25, smoothing_factor); //circle centered at 0,0 since already translated\n        st += center; //untranslate coords \n    }\n\n    return circle;\n}\n\nvec2 random2(vec2 st){ //generate 2d random values (i.e. a random gradient in 2d)\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return fract(sin(st)*43758.5453123);\n}\n\nfloat cellular_noise(vec2 st, float scale){\n    st *= scale;\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n    float m_dist = 100.;\n    //loop through neighboring cells to check points\n    for(int i=-1; i<=1; i++){\n        for(int j=-1; j<=1; j++){\n            //find the neighbor\n            vec2 neighbor = vec2(float(i), float(j));\n            //random (deterministicallly) point\n            vec2 point = random2(i_st+neighbor);\n            // point = 0.5 + 0.5*sin(u_time + 6.2831*point); //animate\n            //vector from pixel to point \n            vec2 diff = neighbor + point - f_st;\n            //dist \n            float dist = length(diff);\n            //keep closer distance \n            m_dist=min(m_dist, dist);\n        }\n    }\n    return m_dist;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 st = fragCoord.xy/iResolution.xy;   \n    vec2 xy=st;\n    \n    float s = 2.0;\n    st = scale(s) * st;\n    st = fract(st);\n    \n    \n\n\n    // float warp = fbm(xy*cellular_noise(st, 5.));\n    vec2 warp = rotate2d((0.3*fbm(xy*cellular_noise(st, 5.)))) * st; //rotate\n    float circle = (circle(warp, vec2(0.5), 0.25, .035) + circle_outline(warp, vec2(0.5)+vec2(0.25,0), 0.25, 0.05));\n\n    vec3 color = vec3(0);\n\n    // color += circle;\n    color += spinning_cirlces_illusion(st, 0.15,  fbm(xy*cellular_noise(st, 5.)*sin(iTime)), 0.005);\n\n    fragColor = vec4(color, 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ndt3z7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[140, 140, 214, 214, 378], [380, 380, 400, 400, 458], [460, 460, 539, 539, 626], [628, 628, 651, 651, 723], [726, 809, 830, 830, 877], [878, 878, 899, 899, 946], [947, 947, 969, 969, 1004], [1006, 1072, 1094, 1147, 2844], [2849, 2849, 2868, 2868, 3123], [3126, 3126, 3201, 3201, 3269], [3271, 3271, 3299, 3299, 3385], [3387, 3387, 3411, 3411, 3474], [3476, 3476, 3501, 3524, 3583], [3585, 3585, 3658, 3658, 4704], [4706, 4706, 4803, 4803, 5923], [5925, 5925, 5947, 6006, 6134], [6136, 6136, 6179, 6179, 6907], [6910, 6910, 6967, 6967, 7547]]}
{"id": "Ndt3zM", "name": "Perspective Correct Interp.", "author": "oneshade", "description": "Implementation of perspective correct interpolation.\nContinuing to learn about rasterization!\nLeft: rasterized (background is red when perspective correction is turned off, green when turned on)\nRight: raytraced (gives direct access to the 3D coordinates)", "tags": ["perspective", "interpolation", "correct"], "likes": 14, "viewed": 100, "date": "1629399761", "time_retrieved": "2024-06-20T20:47:41.198011", "image_code": "// From this lesson:\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/perspective-correct-interpolation-vertex-attributes\n\nstruct TriIntersect {\n    bool hit;\n    vec3 pos;\n    float dist;\n    vec3 bary;\n};\n\nTriIntersect iTriangle(in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in vec3 c) {\n    ro -= a; b -= a; c -= a; a = vec3(0.0);\n    vec3 ba = b - a, cb = c - b, ac = a - c;\n\n    vec3 n = cross(ba, -ac);\n    float denom = dot(rd, n);\n    if (denom != 0.0) {\n        float t = -dot(ro, n) / denom;\n\n        vec3 p = ro + rd * t;\n        vec3 pa = p - a, pb = p - b, pc = p - c;\n\n        float abc = length(n);\n        float u = length(cross(cb, pb)) / abc;\n        float v = length(cross(ac, pc)) / abc;\n        float w = length(cross(ba, pa)) / abc;\n\n        return TriIntersect(abs(u + v + w - 1.0) < 0.001, p, t, vec3(u, v, w));\n    }\n\n    return TriIntersect(false, vec3(0.0), 0.0, vec3(0.0));\n}\n\nbool pointInTriangle(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    bool pa = p.y > a.y, pb = p.y > b.y, pc = p.y > c.y;\n    bool wa = pa != pc && pc != ((c.x - a.x) * (p.y - a.y) > (c.y - a.y) * (p.x - a.x));\n    bool wb = pb != pa && pa != ((a.x - b.x) * (p.y - b.y) > (a.y - b.y) * (p.x - b.x));\n    bool wc = pc != pb && pb != ((b.x - c.x) * (p.y - c.y) > (b.y - c.y) * (p.x - c.x));\n    return wa ^^ wb ^^ wc;\n}\n\nvec3 barycentric(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 pa = p - a, pb = p - b, pc = p - c;\n    vec2 ba = b - a, cb = c - b, ac = a - c;\n\n    float abc = abs(ba.y * ac.x - ba.x * ac.y);\n    float abp = abs(ba.x * pa.y - ba.y * pa.x);\n    float bcp = abs(cb.x * pb.y - cb.y * pb.x);\n    float cap = abs(ac.x * pc.y - ac.y * pc.x);\n\n    return vec3(bcp, cap, abp) / abc;\n}\n\nvoid render(inout vec4 fragColor, in vec2 fragCoord) {\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord / iResolution.y - vec2(0.5 * aspect, 0.5);\n    float unit = 2.0 / iResolution.y;\n    float offset = 0.25 * aspect;\n    vec3 color = vec3(0.0);\n\n    // Vertices\n    float transition = smoothstep(1.0, 0.0, abs(mod(iTime * 0.25, 2.0) - 1.0));\n    vec3 a = mix(vec3(-2.0, -2.0, -6.0), vec3(-2.0, -1.0, -7.0), transition);\n    vec3 b = mix(vec3( 2.0, -2.0, -6.0), vec3(2.0, -1.0, -5.0), transition);\n    vec3 c = mix(vec3( 2.0,  2.0, -6.0), vec3(0.0, 1.5, -11.0), transition);\n\n    // UVs\n    vec2 uv1 = vec2(0.0, 0.0);\n    vec2 uv2 = vec2(1.0, 0.0);\n    vec2 uv3 = vec2(1.0, 1.0);\n\n    if (uv.x > 0.0) { // Raytrace triangle on right\n        uv.x -= offset; // Recenter\n\n        vec3 ro = vec3(0.0, 0.0, 0.0);\n        vec3 rd = normalize(vec3(uv, -1.0));\n\n        // Blue gradient background\n        color.b += exp(-2.0 * length(fragCoord / iResolution.xy * vec2(2.0, 1.0) - vec2(1.5, 0.5)));\n\n        TriIntersect tri = iTriangle(ro, rd, a, b, c);\n        if (tri.hit) {\n            vec2 triUv = uv1 * tri.bary.x + uv2 * tri.bary.y + uv3 * tri.bary.z;\n\n            float grid = 1.0 - max(smoothstep(0.01, 0.0, abs(mod(triUv.x + 0.1, 0.2) - 0.1) - 0.002),\n                                   smoothstep(0.01, 0.0, abs(mod(triUv.y + 0.1, 0.2) - 0.1) - 0.002));\n\n            color = vec3(grid);\n        }\n\n        uv.x += offset;\n    }\n\n    if (uv.x < 0.0) { // Rasterize triangle on left\n        uv.x += offset; // Recenter\n\n        // Toggle perspective correction\n        bool correct = mod(iTime, 16.0) < 8.0;\n\n        // Gradient background (red when perspective correction is off, green when its on)\n        color.rg = vec2(!correct, correct) * exp(-2.0 * length(fragCoord / iResolution.xy * vec2(2.0, 1.0) - 0.5));\n\n        // Compute inverse z coordinates\n        float azInv = 1.0 / a.z;\n        float bzInv = 1.0 / b.z;\n        float czInv = 1.0 / c.z;\n\n        // Project (flipping the z due to the camera facing in the -z direction)\n        vec2 aProj = a.xy * -azInv;\n        vec2 bProj = b.xy * -bzInv;\n        vec2 cProj = c.xy * -czInv;\n\n        if (pointInTriangle(uv, aProj, bProj, cProj)) {\n            vec3 bary = barycentric(uv, aProj, bProj, cProj);\n\n            // Divide attributes by corresponding z coordinate\n            if (correct) {\n                uv1 *= azInv;\n                uv2 *= bzInv;\n                uv3 *= czInv;\n            }\n\n            vec2 triUv = uv1 * bary.x + uv2 * bary.y + uv3 * bary.z; // Interpolate like usual\n\n            if (correct) {\n                float z = 1.0 / (azInv * bary.x + bzInv * bary.y + czInv * bary.z); // Perspective correct z coordinate\n                triUv *= z;\n            }\n\n            float grid = 1.0 - max(smoothstep(0.01, 0.0, abs(mod(triUv.x + 0.1, 0.2) - 0.1) - 0.002),\n                                   smoothstep(0.01, 0.0, abs(mod(triUv.y + 0.1, 0.2) - 0.1) - 0.002));\n\n            color = vec3(grid);\n        }\n\n        uv.x -= offset;\n    }\n\n    color = mix(color, vec3(0.8, 0.6, 0.0), smoothstep(unit, 0.0, abs(uv.x) - 0.005));\n    fragColor.rgb += color;\n}\n\n// Supersample\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n     fragColor = vec4(0.0);\n     render(fragColor, fragCoord);\n     render(fragColor, fragCoord + vec2(0.5, 0.0));\n     render(fragColor, fragCoord + vec2(0.0, 0.5));\n     render(fragColor, fragCoord + vec2(0.5, 0.5));\n     fragColor.rgb /= 4.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ndt3zM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 258, 339, 339, 953], [955, 955, 1021, 1021, 1374], [1376, 1376, 1438, 1438, 1762], [1764, 1764, 1818, 1818, 4936], [4938, 4953, 5008, 5008, 5256]]}
{"id": "NdtGDH", "name": "Alien plants field", "author": "kastorp", "description": "using boxIntersection() to prevent artifacts on domain repetition and allow double sized SDF", "tags": ["domainrepetition", "plants"], "likes": 15, "viewed": 156, "date": "1629727279", "time_retrieved": "2024-06-20T20:47:41.804137", "image_code": "//Alien plants field  by kastorp\n//-------------------------------------------------\n//fork of https://www.shadertoy.com/view/3lcBD2 by Blakle\n//90% of the code from Blackle's shader\n\n#define hue(v) ( .6 + .6 * cos( v  + vec3(0,23,21)  ) )     // hue\n\nfloat hash(in float x) { return fract(sin(x*.0007)*29835.24389); }\nfloat hash(in vec2 x) { return hash(dot(x,vec2(23.17,17.23))); }\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nvec2 edge(vec2 p) {\n    vec2 p2 = abs(p);\n    if (p2.x > p2.y) return vec2((p.x < 0.) ? -1. : 1., 0.);\n    else             return vec2(0., (p.y < 0.) ? -1. : 1.);\n}\n//Iq stuff\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); \n    return vec2( tN, tF );\n}\n\nvec2 plant(vec3 p,vec2 center) {\n    const float sh=.3; //shift\n    float a =hash(center*1.1),b=hash(center*11.1);\n    vec3 s1= vec3(sin(a*25.),cos(a*25.),0)*sh; //bottom\n    vec3 s2= vec3(sin(a*37.+iTime)*sh,cos(a*37.+iTime)*sh,5.+b*2.5); //top\n     float tk = .15 *smoothstep(30.,5.,p.z)+ .2* smoothstep(.6,0.1,abs(s2.z-p.z -.3))+ .2* smoothstep(.6,0.1,p.z); //thickness\n     return vec2(sdCapsule(p- vec3(center, 0),s1,s2,tk),abs(s2.z-p.z -.3)<0.6? b*5.:0.);\n}\n#define mmin(a,b) (a.x<b.x?a:b)\nvec2 scene(vec3 p) {\n    vec2 center = floor(p.xy) + .5;\n    vec2 neighbour = center + edge(p.xy - center);\n    float height = sin(center.y + center.x+iTime)*2.;\n    vec2 me = plant(p,center);\n    vec2 next =plant(p,neighbour); //closest plant can \"invade\" current cell (but must stay in the 2x 45 degrees square)\n    return mmin(mmin(me, next),vec2(p.z,0.));\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p).x - vec3(scene(k[0]).x,scene(k[1]).x,scene(k[2]).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-30,0,0);\n    \n    float yrot = .45;\n    float zrot = iTime*.05;\n    if (iMouse.z > 0.) {\n        yrot = clamp(1.-2.*mouse.y,-0.,3.14/2.);\n        zrot = 4.*mouse.x;\n    }\n    \n    cam = erot(cam,vec3(0,1,0),yrot);\n    init = erot(init,vec3(0,1,0),yrot);\n    cam = erot(cam,vec3(0,0,1),zrot);\n    init = erot(init,vec3(0,0,1),zrot);\n    //init.z += 1.;\n\n    vec3 p =init;\n    bool hit = false;\n    vec2 d;\n    for (int i = 0; i < 200 && !hit; i++) {\n       d = scene(p);\n        \n        //if inside a box, don't march after border\n        vec3 center = vec3(floor(p.xy) + .5,10.);\n        vec2 tb= boxIntersection(  p-center,  cam, vec3(.501,.501,10.) ) ;\n        if( tb.x<0. &&tb.y>0. && tb.y<d.x) d.x=tb.y;       \n        \n        hit = d.x*d.x < 1e-6;\n        p += d.x*cam;\n        if(distance(p,init)>70.)break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n    vec3 col=  mix( hue(vec3(d.y*.4+3.6 +mod(p.z,.1)*15.)) ,vec3(0.278,0.835,0.204), smoothstep(5.3,4.2,p.z));     \n    \n    float l =length(sin(r*2.)*.5+.5)/sqrt(3.);\n    l = l*.1 + pow(l, 6.);\n    col= hit ? col*l: vec3(.05);\n    col = mix(col,vec3(0.529,0.525,0.796),exp(min(0.,-5.+distance(init,p)/10.))); //fog\n    fragColor =  vec4(sqrt(col),0) ;\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdtGDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 252, 276, 276, 318], [319, 319, 342, 342, 383], [385, 385, 423, 423, 485], [487, 487, 506, 506, 652], [653, 664, 716, 716, 837], [838, 838, 899, 899, 1179], [1181, 1181, 1213, 1213, 1644], [1677, 1677, 1697, 1697, 2038], [2040, 2040, 2059, 2059, 2182], [2184, 2184, 2241, 2241, 3659]]}
{"id": "Nl2SRK", "name": "venetian blinds", "author": "NakedBowman", "description": "Venetian Blinds Effect, this is a working ground for something else, I thought it  might be useful for someone else...", "tags": ["lines", "venetian", "blinds"], "likes": 2, "viewed": 99, "date": "1628235732", "time_retrieved": "2024-06-20T20:47:42.052675", "image_code": "mat2 rot(in float r)\n{\n\tfloat cr = cos(r);\n\tfloat sr = sin(r);\n\treturn mat2(\n\t\tcr,-sr,\n\t\tsr,cr\n\t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     \n         \n    vec2 uv = fragCoord/iResolution.xy;\n       vec2 st = uv;\n     uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 center = vec2(0.5+.47,0.5);\n    uv-=center;            \n    uv *= rot(iTime*0.5);\n    \n    vec4 text = texture(iChannel0, st);\n   \n    //Get controls\n    float r = iMouse.y/iResolution.y;\n    float v = iMouse.x/iResolution.x;\n    r = clamp(r, 0.,0.249);\n    v = clamp(v, 0.249,1.);\n    uv*=20.; //Change count here\n    uv = fract(uv);\n \n    float blind = smoothstep(v+r,v+0.5-r,uv.x) - 1. + smoothstep(1.-r-v,.5+r-v,uv.x);  \n    text = text -1. *-blind;\n \n\n\n    fragColor = vec4(text);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2SRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 22, 22, 100], [103, 103, 160, 160, 781]]}
{"id": "Nl2SWc", "name": "Powderly sphere", "author": "kithy", "description": "powder like surface.", "tags": ["raymarching", "noise", "displacement"], "likes": 1, "viewed": 52, "date": "1628781400", "time_retrieved": "2024-06-20T20:47:42.052675", "image_code": "#define ITR 32\n#define EPS 0.001\n\nfloat hash(vec2 p){\n\treturn fract(sin(dot(p,vec2(43.232,75.876)))*4526.3257);\n}\n\nfloat sdSphere(vec3 p){\n\treturn length(p)-(sin(iTime)*0.5+1.0);\n}\n\nfloat displacement(vec3 p){\n\treturn hash(vec2(p.x,p.y));\n}\n\nfloat mainDist(vec3 p){\n\tfloat dis=displacement(p);\n\tfloat d1=sdSphere(p);\n\treturn d1+dis;\n}\n\n\nvec3 genNormal(vec3 p){\n\tvec3 normal=vec3(\n\t\tsdSphere(p+vec3(EPS,0.0,0.0))-sdSphere(p+vec3(-EPS,0.0,0.0)),\n\t\tsdSphere(p+vec3(0.0,EPS,0.0))-sdSphere(p+vec3(0.0,-EPS,0.0)),\n\t\tsdSphere(p+vec3(0.0,0.0,EPS))-sdSphere(p+vec3(0.0,0.0,-EPS))\n\t\t);\n\treturn normalize(normal);\n}\n\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tvec3 ro=vec3(0.0,0.0,-10.0);\n\tvec3 lookat=vec3(0.0,0.0,0.0);\n\tfloat zoom=5.0;\n\n\tvec3 f=normalize(lookat-ro);\n\tvec3 r=normalize(cross(vec3(0.0,1.0,0.0),f));\n\tvec3 u=cross(f,r);\n\tvec3 c=ro+f*zoom;\n\tvec3 i=c+uv.x*r+uv.y*u;\n\tvec3 rd=normalize(i-ro);\n   \n    float d,t;\n    vec3 p,n;\n\n\tvec3 col=vec3(1.0);\n    \n    for(int i=0;i<ITR;i++){\n        p=ro+rd*t;\n        d=mainDist(p);\n        n=genNormal(p);\n        if(d<EPS)break;\n        t+=d;\n    }\n\tcol=n*0.5+0.5;\n\n\tfragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2SWc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[34, 34, 53, 53, 113], [115, 115, 138, 138, 180], [182, 182, 209, 209, 240], [242, 242, 265, 265, 334], [337, 337, 360, 360, 604], [608, 608, 661, 661, 1209]]}
{"id": "Nl2XWK", "name": "prime number screen saver", "author": "ArmandB", "description": "a simple shader that uses primes to make a cool pattern", "tags": ["simple", "primes"], "likes": 2, "viewed": 167, "date": "1628642050", "time_retrieved": "2024-06-20T20:47:42.052675", "image_code": "bool is_prime(float x){\n    x = round(abs(x));//round to remove decimals, abs to remove negatives\n    for(float i = 2.0; i < x/2.0; i++){//divide by (low 2, high x/2)\n        if (mod(x,i) == 0.0){\n            return false;//if divisible exit\n        }\n    }\n    return true;//if not divisible by anything draw\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float angle = 45.0;\n    float size = 100.0;\n    vec2 uv = fragCoord/iResolution.xy*size;//set uv units\n    uv.x *= iResolution.x/iResolution.y;//scale so contents are square\n    uv *= mat2(cos(angle),-sin(angle),sin(angle),cos(angle));//rotation matrix\n    vec3 col = vec3(0);//set bg\n    \n    //changes num to check based on mousepos, sin(time, uv)\n    if(is_prime(uv.x + iMouse.x + sin(iTime+uv.x)) == true \n    && is_prime(uv.y + iMouse.y + cos(iTime+uv.y)) == true){\n        //sets color to change based on uv offset by mousepos\n        col = vec3(0,normalize((uv.yx+iMouse.xy)/size));\n        \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2XWK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 23, 23, 311], [313, 313, 370, 370, 1037]]}
{"id": "NlBSWy", "name": "大龙猫 - Quicky #058", "author": "totetmatt", "description": "Inspiration from https://imgur.com/e9IMX", "tags": ["quicky"], "likes": 9, "viewed": 264, "date": "1628462377", "time_retrieved": "2024-06-20T20:47:42.058881", "image_code": "#define fGlobalTime iTime\nfloat diam(vec3 p,float s){\n   p=  abs(p);\n   return (p.x+p.z+p.y-s)*inversesqrt(3.);  \n }\nfloat box(vec3 p, vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n }\n float sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat smin( float a, float b, float k )\n{\nfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat bbox(vec3 p,float q){\n    float h = sdBoxFrame(p,vec3(1.),.1);\n    return smin(h, diam(abs(p)-.9,.3),q);\n  \n }\nvec3 extp,intp;\n vec2 struc(vec3 p,float q){\n      \n     vec2 h,t;\n     vec3 pp = p;\n     p.xy*=rot(fGlobalTime);\n     p.xz*=rot(fGlobalTime);\n     extp=p;\n     h.x = box(p,vec3(2.55));\n     h.y = 1.;\n     p = abs(p)-.9;\n     p = abs(p)-.9;\n     h.x = max(-h.x,bbox(p,q));\n     \n     \n     pp.xy*=rot(-fGlobalTime);\n     pp.xz*=rot(-fGlobalTime);\n     t.x = bbox(pp,q);\n     t.y = 1.5;\n     h= t.x < h.x ? t:h;\n     intp=pp;\n   return h;\n   \n }\n\nvec2 sdf(vec3 p){\n\n     p.yz*=rot(atan(inversesqrt(1./2.)));\n     p.xz*=rot(3.141592/4.);\n      p.xz/=4.;\n     p.xz = asin(sin(p.xz)*(.925-texture(iChannel0,p.xz*.1).r*.075));\n     p.xz*=4.;\n    vec2 h;\n\n     h= struc(p*.92,-.01);\n     vec2 t = struc(p,.0);\n     t.y += 1.;\n     h= t.x < h.x ? t:h;\n    return h;\n}\n#define q(s) s*sdf(p+s).x\nvec2 e=vec2(-.003,.003);\nvec3 norm(vec3 p){return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\n#define ao(rp,n,k) (sdf(rp+n*k).x/k)\n#define AO(rp,n) (ao(rp,n,.1)+ao(rp,n,.5)+ao(rp,n,1.1))\nvec3 pal(float t){\n  \n  return .5+.5*cos(6.28*(.1*t+vec3(1.,.4,.3)));\n  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\nvec3  col = vec3(.1);\n  vec3 ro = vec3((uv)*10.,-30.);\n  vec3 rd = vec3(0.,0.,1.);\n  vec3 light = vec3(7.,5.,-5.);\n  vec3 rp = ro;\n  vec3 acc = vec3(.0);\n  for(float i=0.;i<=128.;i++){\n      vec2 d = sdf(rp);\n    if(d.y >= 2.){\n         vec3 off = d.y == 2.5 ? intp:extp;\n         acc +=sqrt(pal(length(off)+iTime*2.))*exp(2.*-abs(d.x))/(29.+sin(atan(off.x,off.y)*10.)*20.);\n       d.x = max(.002+sin(off.y*20.+off.x*20.)*.01,abs(d.x));\n     }\n    if(length(rp)>50.) break;\n     if(d.x <=.001){\n         if(d.y==1.){\n          vec3 n = norm(rp);\n          float diff = max(0.,dot(normalize(light-rp),n));\n          float sp = max(0.,dot(normalize(ro-rp),reflect(-normalize(light),n)));\n            col = vec3(.5)*diff+vec3(5.,0.,0.)*pow( sp,32.);\n            col *=AO(rp,n)/1.7;\n           }\n        break;\n      }\n      rp+=d.x*rd;\n  }\n  col +=acc;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NlBSWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[26, 26, 53, 53, 116], [117, 117, 143, 143, 235], [237, 237, 282, 282, 564], [565, 565, 583, 583, 630], [631, 631, 672, 672, 761], [762, 762, 789, 789, 878], [896, 896, 923, 923, 1323], [1325, 1325, 1342, 1342, 1639], [1691, 1691, 1709, 1709, 1764], [1858, 1858, 1876, 1876, 1931], [1933, 1933, 1990, 2040, 2983]]}
{"id": "NljSRd", "name": "Basic loading indicator", "author": "disambiguator", "description": "Baisc loading clock effect", "tags": ["arc"], "likes": 2, "viewed": 69, "date": "1628392661", "time_retrieved": "2024-06-20T20:47:42.058881", "image_code": "// A simplication of https://www.shadertoy.com/view/tlSGzG\n\nconst float PI = 3.14159;\n\nfloat arcSDF(vec2 pos, vec2 loc,  float r, float start, float end) {\n    vec2 dist = pos - loc;\n    float mid = mod(atan(dist.x, dist.y), 2.*PI),\n          d = max( start - mid, mid - end );     \n\n   return max( length(dist)*d ,  length(dist) - r );\n}\n\nfloat sceneSDF(vec2 uv) {\n\n    float location = mod(iTime, 4.*PI);\n    float angleStart, angleEnd;\n   \n    if(location > 2.*PI) {\n        angleStart = 0.;\n        angleEnd = mod(iTime, 2.*PI);\n    } else {\n        angleStart = mod(iTime, 2.*PI);\n        angleEnd = 2.*PI;\n    }\n    \n    \n    return arcSDF(uv, vec2(0.), 0.3, angleStart, angleEnd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - .5* iResolution.xy ) /iResolution.y;\n\n    float dist = sceneSDF(uv);\n    fragColor = vec4( smoothstep(2./iResolution.y, 0., dist ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NljSRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 87, 155, 155, 338], [340, 340, 365, 365, 689], [692, 692, 749, 749, 913]]}
{"id": "NljSz1", "name": "Pattern mosaic study", "author": "felipetovarhenao", "description": "Using shaping functions to create tiling, animated patterns.", "tags": ["patterns", "mosaic"], "likes": 2, "viewed": 49, "date": "1628273345", "time_retrieved": "2024-06-20T20:47:42.470846", "image_code": "/*\nAuthor: Felipe Tovar-Henao [www.felipe-tovar-henao.com]\n*/\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nfloat fold(in float x) {\n    return abs(mod(x+1.0,2.0)-1.0);\n}\n\nfloat sine_ramp(in float x, in float s) {\n    float y = fract(x);\n    float h = 0.5 - (0.5/(s*s));\n    return floor(x) + y + h*sin(6.28318530718*y);\n}\n\nfloat boot_ramp(in float x, in float s) {\n    float y = fract(x);\n    return floor(x) + pow(y, s*y+(1.0/s));\n}\n\nfloat shelf_ramp(in float x, in float s) {\n    float y = fract(x);\n    return floor(x) + 1.0-pow(1.0-y, s*y+(1.0/s));\n}\n\nfloat N_ramp(in float x, in float s) {\n    float y = fract(x);\n    float h = max(0.3, s);\n    return floor(x) + length(vec2(y,0.0)-vec2(pow(y,1.0/h),pow(y,h)));\n}\n\nvec2 rotate2D(in vec2 vUV, in float theta) {\n    vec2 r = vec2(cos(theta), sin(theta));\n    return vUV * mat2(r.x, -r.y, r.y, r.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 vUV = fragCoord.xy / iResolution.xy;\n    vUV -= 0.5;\n    vUV *= 2.5;\n    vUV = rotate2D(vUV, -iTime*0.025);\n    vUV += iTime*vec2(0.05*(-vUV.y*0.01), 0.05*(vUV.x*0.01)) + (iTime*0.05);\n    vUV.x *= iResolution.x / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float scl = 4.0;\n    float slope = scl* pow(fold(iTime*0.05), 2.0) + 1.0;\n    vUV = vec2(sine_ramp(vUV.x,slope), sine_ramp(vUV.y,slope));\n    vUV = vec2(fold(vUV.y*scl),fold(vUV.x*scl));\n\n    vUV /= N_ramp(length(vUV) * 0.9, 2.0);\n\n    float dx = length(vUV);\n\n    dx = length(vUV);\n    dx = fold(3.0*dx);\n    dx = clamp(dx, 0.0, 1.0);\n    dx = N_ramp(dx, 5.0);\n\n    float br = 3.0*shelf_ramp(fold(iTime*0.25), 1.0) + 4.0;\n\n    color += boot_ramp(dx, br);\n    color = color * 1.4;\n    color = clamp(color, 0.0, 1.0);\n\n    vec3 A = vec3(1.0, 0.3686, 0.3686) * color;\n    vec3 B = vec3(0.3843, 0.7333, 1.0) * color;\n    vec3 C = vec3(0.5098, 1.0, 0.5098) * color;\n\n    color = mix(A, C, N_ramp(fold(length(vUV)), 4.0));\n    color = mix(color, B, fold((vUV.y+vUV.x)*0.5 + (iTime*0.1)));\n    color = smoothstep(0.0, 1.0, color);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NljSz1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 118, 142, 142, 180], [182, 182, 223, 223, 332], [334, 334, 375, 375, 444], [446, 446, 488, 488, 565], [567, 567, 605, 605, 729], [731, 731, 775, 775, 864], [866, 866, 922, 922, 2059]]}
{"id": "NljSzV", "name": "Angle visualization - atan fix", "author": "xintrea", "description": "Videocard Intel i915 incorrect calculate atan() function. This code sample show how to write custom handmade function for calculate arctan from arcsin.", "tags": ["angle", "circlemotion"], "likes": 0, "viewed": 162, "date": "1628109999", "time_retrieved": "2024-06-20T20:47:42.470846", "image_code": "\nconst float PI=3.1415926535897932384626433832795;\n\n\nfloat arctangens(float a)\n{\n    return asin(a/sqrt(1.0+a*a));\n}\n\n\nfloat getAngle(float x, float y)\n{\n    // For i915 with Linux replace atan() to arctangens()\n    float alpha=atan( abs(y/x) );\n\n    if(x>=0.0 && y>=0.0)\n    {\n        return alpha;\n    }\n\n    if(x<0.0 && y>=0.0)\n    {\n        return PI-alpha;\n    }\n\n    if(x<0.0 && y<0.0)\n    {\n        return PI+alpha;\n    }\n\n    return 2.0*PI-alpha;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n\n    float x=sin(iTime);\n    float y=cos(iTime);\n    \n    \n    // Square move by circle\n    float visX=x/2.0+0.5;\n    float visY=y/2.0+0.5;\n\n    if(uv.y>=visY && uv.y<visY+0.01)\n      if(uv.x>=visX && uv.x<visX+0.01)\n        color=vec3( 0.4, 0.4, 1.0 );\n    \n    \n    // Angle visualization\n    float angle=getAngle(x, y)/(2.0*PI);\n    \n    if(uv.y>=0.9 && uv.y<1.0)\n        if(uv.x>=angle && uv.x<(angle+0.01))\n            color=vec3( 0.1, 0.8, 0.8 );    \n\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NljSzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[53, 53, 80, 80, 116], [119, 119, 153, 211, 456], [459, 459, 516, 566, 1169]]}
{"id": "NljXDK", "name": "Mountains and plains", "author": "jarble", "description": "Another realistic-looking mountain terrain.\nThis is based on dyla's [url=https://www.shadertoy.com/view/WdcfDn]\"Fyords\"[/url] shader.", "tags": ["procedural", "fractal", "terrain", "lake", "mountain"], "likes": 2, "viewed": 159, "date": "1628653443", "time_retrieved": "2024-06-20T20:47:43.471000", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\n\n//increase this constant to increase the amount of detail\n#define OCTAVES 4\n\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    float value = 0.;\n    float factor = -3.;\n    uv *= factor;\n    for (int i = 0; i < OCTAVES; i++)\n    {\n        uv += max(sin(uv*factor)/factor,cos(uv/factor)*factor).yx;\n        value = 3.+max(value+value*sin(uv.x)/factor,value+cos((uv.y/value)/factor)/factor);\n        uv = uv.yx*1.5/factor;\n        //factor /= 1.5;\n        \n    }\n    \n    return value;\n}\n\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    float factor = 1.;\n    return fbm(uv/factor)*factor/2.;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*iTime);\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    #endif\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 1.;\n\n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NljXDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[411, 488, 511, 560, 923], [997, 997, 1035, 1035, 1097], [1099, 1099, 1132, 1132, 1352], [1354, 1354, 1392, 1392, 1619], [1621, 1621, 1659, 1659, 1883], [1885, 1885, 1914, 1914, 2009], [2011, 2011, 2048, 2048, 2107], [2110, 2178, 2197, 2197, 2236], [2238, 2238, 2258, 2258, 2334], [2336, 2336, 2355, 2355, 2394], [2396, 2396, 2453, 2453, 2688], [2690, 2690, 2725, 2725, 3119], [3121, 3121, 3175, 3175, 3841], [3844, 3844, 3896, 3896, 4331], [4333, 4333, 4390, 4390, 5575]]}
{"id": "NljXRG", "name": "Georgian Flag", "author": "Peace", "description": "Georgian Flag", "tags": ["flag"], "likes": 4, "viewed": 30, "date": "1627945793", "time_retrieved": "2024-06-20T20:47:43.471000", "image_code": "float p;\n#define AAstep(edge, x) smoothstep(edge - p, edge + p, x)\n\nfloat getCross(vec2 uv, float size, float len)\n{\n    uv = abs(uv);\n    vec2 line = step(uv.yx * 2., step(uv,vec2(len)) * size);\n    return max(line.x, line.y);\n}\n\nvec3 georgianFlag(vec2 uv)\n{\n  \n    float rot = uv.x * 6. - iTime * 2.5 + uv.y * 2.;\n    uv.y += sin(rot) * 0.05;\n\n    if(abs(uv.y) > .5 || abs(uv.x) > 0.75) \n        return vec3(0);\n    \n    float mainCross = getCross(uv, 0.175, .75);\n    float crosses = getCross(-abs(uv) + vec2( 0.5,  0.3), 0.07, 0.15);\n    float flag = mainCross + crosses;\n    \n    float shade = .9 + cos(rot) * .2;\n    \n    const vec3 WHITE = vec3(1);\n    const vec3 RED = vec3(0.85, 0.16, 0.2); \n    vec3 col = mix(WHITE, RED, flag) * shade; \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord - R.xy * 0.5) / R.y; \n    p = length(fwidth(fragCoord / R.xy))*8.;\n    fragColor = vec4(georgianFlag(uv * 1.25),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NljXRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[68, 68, 116, 116, 229], [231, 231, 259, 259, 770], [772, 772, 829, 829, 1003]]}
{"id": "NljXzm", "name": "Kaleidoscopic tiling", "author": "felipetovarhenao", "description": "Kaleidoscopic tiling using shaping functions and tile rotations", "tags": ["kaleidoscope", "tiling"], "likes": 1, "viewed": 53, "date": "1628273375", "time_retrieved": "2024-06-20T20:47:43.913385", "image_code": "/*\n    Author: Felipe Tovar-Henao [www.felipe-tovar-henao.com]\n    Description: Kaleidoscopic tiling using shaping functions and tile rotations.\n*/\n\n#define u_resolution iResolution\n#define u_time iTime\n\nfloat fold(in float x) {\n    return abs(mod(x+1.0,2.0)-1.0);\n}\n\nfloat camel_ramp(in float x, in float s) {\n    float y = fract(x);\n    return floor(x) + pow(0.5 - (0.5 * cos(6.28318530718*y) * cos(3.14159265359*y)), s);\n}\n\nfloat cosine_ramp(in float x, in float s) {\n    float y = cos(fract(x)*3.14159265359);\n    return floor(x) + 0.5 - (0.5*pow(abs(y), 1.0/s)*sign(y));\n}\n\nfloat bump_ramp(in float x, in float s) {\n    float y = fract(x);\n    return floor(x) + pow(y, exp(s*y));\n}\n\nvec2 rotate2D(in vec2 vUV, in float theta) {\n    vec2 r = vec2(cos(theta), sin(theta));\n    return vUV * mat2(r.x, -r.y, r.y, r.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUV = fragCoord.xy / u_resolution.xy;\n    vUV -= 0.5;\n    float aspect = u_resolution.x / u_resolution.y;\n    vUV.x *= aspect;\n    float theta = cosine_ramp(u_time * 0.075, 2.0);\n    vUV = rotate2D(abs(vUV+vec2(0.15*aspect, 0.0))*3.7, theta);;\n    vec2 vUVA = mod(vUV, max(vec2(0.1), mod(abs(fract(vUV)*2.3 - fract(vUV+0.3) + 0.2), 2.0)));    \n    vUV = mix(vUV, vUVA, fold(theta));\n    vUV = vec2(fold(vUV.x), fold(vUV.y));\n    vec2 fUV = fract(vUV);\n    vec2 iUV = floor(vUV);\n    float dx = length(iUV-0.5);\n    fUV = rotate2D(fUV, cosine_ramp(u_time*0.3, 2.0));\n\n    float s = fold(u_time*0.4)*2.0 + 2.0;\n    float border = dx * 0.05 + 0.25;\n    float x1 = camel_ramp(fUV.x,s) * border;\n    float y1 = camel_ramp(fUV.y,s) * border;\n \n    float edge = 0.015;\n    float bottom = smoothstep(edge,0.0, abs(x1-fUV.y));\n    float top = smoothstep(edge,0.0, abs(x1+(1.0-border)-fUV.y));\n    float left = smoothstep(edge,0.0, abs((1.0-border)+y1-fUV.x));\n    float right = smoothstep(edge, 0.0, abs(y1-fUV.x));\n\n    float tile = clamp(top+bottom+left+right, 0.0, 1.0);\n    tile = smoothstep(0.0, 1.0, tile);\n    float len = length(vec2(x1, y1)*1.2);\n\n    vec3 color = vec3(0.0);\n    vec3 c1a = vec3(0.9412, 0.5725, 0.5725);\n    vec3 c1b = vec3(0.9216, 0.4275, 0.4196);\n    vec3 c1 = tile * mix(c1a, c1b, fold(u_time*0.125));\n    color = clamp(color-c1, 0.0, 1.0) + c1;\n    \n    vec3 c2a = vec3(0.5294, 0.6784, 0.8039);\n    vec3 c2b = vec3(0.3922, 0.4627, 0.5804);\n    vec3 c2 = bump_ramp(fold(len*13.0 + (sin(0.3*u_time + vUV.x) * 3.0)), 3.5) * mix(c2a, c2b, fold(u_time * 0.2));\n    c2 = smoothstep(0.0,1.0,c2);\n    color = clamp(color-c2, 0.0, 1.0) + c2;\n    vec3 shade = clamp(1.0-color, 0.0, 1.0) * vec3(0.098, 0.098, 0.1098);\n    color = clamp(color-shade, 0.0, 1.0) + shade;\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NljXzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 204, 228, 228, 266], [268, 268, 310, 310, 425], [427, 427, 470, 470, 577], [579, 579, 620, 620, 686], [688, 688, 732, 732, 821], [823, 823, 880, 880, 2703]]}
{"id": "NljXzV", "name": "quantum field (somewhat)", "author": "sukupaper", "description": "Badly optimized, but I love the render of this thing I've made hehe ✨", "tags": ["raymarching", "abstract", "field", "quantum"], "likes": 17, "viewed": 202, "date": "1628115921", "time_retrieved": "2024-06-20T20:47:44.307343", "image_code": "// Author: paperu\n// Title: quantum field\n\nfloat t;\n#define P 6.283185307\n\nvec3 SpectrumPoly(in float x) {\n    // https://www.shadertoy.com/view/wlSBzD\n    return (vec3( 1.220023e0,-1.933277e0, 1.623776e0)+(vec3(-2.965000e1, 6.806567e1,-3.606269e1)+(vec3( 5.451365e2,-7.921759e2, 6.966892e2)+(vec3(-4.121053e3, 4.432167e3,-4.463157e3)+(vec3( 1.501655e4,-1.264621e4, 1.375260e4)+(vec3(-2.904744e4, 1.969591e4,-2.330431e4)+(vec3( 3.068214e4,-1.698411e4, 2.229810e4)+(vec3(-1.675434e4, 7.594470e3,-1.131826e4)+ vec3( 3.707437e3,-1.366175e3, 2.372779e3)*x)*x)*x)*x)*x)*x)*x)*x)*x;\n}\nmat2 rot(in float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat box(in vec3 p, in float s) { p = abs(p) - s; return max(p.x,max(p.y,p.z)); }\nfloat cyl(in vec3 p, in float h) { return length(p.xz) - h; }\n\nfloat df(in vec3 p) {\n    vec3 pp = p;\n    \n    float d = 10e9;\n    \n    for(int i = 0; i < 15; i++) {\n        d = min(d, cyl(p, -.002));\n        p.xy *= rot(P/3. + t + length(p)*2.);\n        p.z = abs(p.z) - .5;\n        p.xz *= rot(P/3. - t + length(p)*5.1);\n        p.x = abs(p.x) - .5;\n    }\n    \n    return max(d, box(pp, .75));\n}\n\n#define LIM .001\n#define MAX_D 5.\n#define MAX_IT 50\nint rm(in vec3 c, in vec3 r) {\n    vec3 p = c;\n    int it = 0;\n    bool hit = false;\n    for(int i = 0; i < MAX_IT; i++) {\n        float d = df(p);\n        if(d < LIM || distance(c,p) > MAX_D) break;\n        p += d*r;\n        it = i;\n    }\n    return it;\n}\n\nvec3 plane2sphere(in vec2 p) {\n    float t = -4./(dot(p,p) + 4.);\n    return vec3(-p*t, 1. + 2.*t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = (fragCoord.xy - iResolution.xy*.5)/iResolution.y;\n    t = iTime*.25 + 3.;\n    \n    vec3 c = vec3(0.,0.,0.);\n    vec3 r = normalize(vec3(st,1.));\n    r = plane2sphere(st*12.);\n    \n    r.xy *= rot(t);\n    r.xz *= rot(t);\n    r.yz *= rot(t);\n\n    int it = rm(c,r);\n    \n    float s = pow(float(it)*.02,2.);\n    vec3 color = mix(vec3(0.), SpectrumPoly((max(1.-s,.55))), s*1.);\n    color = mix(color*1., vec3(1.), s);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NljXzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 75, 106, 151, 578], [579, 579, 601, 601, 646], [648, 648, 682, 682, 730], [731, 731, 765, 765, 792], [794, 794, 815, 815, 1128], [1182, 1182, 1212, 1212, 1438], [1440, 1440, 1470, 1470, 1541], [1543, 1543, 1598, 1598, 2062]]}
{"id": "NlSSDG", "name": "DragonEye II", "author": "mrange", "description": "License CC0: DragonEye II\nA year or so ago I played with quasi crystals and I found they looked like \"dragon eyes\" with certain parameters\nThis is an evolution of that idea.\n", "tags": ["2d", "fbm"], "likes": 37, "viewed": 391, "date": "1628452763", "time_retrieved": "2024-06-20T20:47:46.646939", "image_code": "// License CC0: DragonEye II\n// A year or so ago I played with quasi crystals and I found they looked like \"dragon eyes\" with certain parameters\n// This is an evolution of that idea.\n\n#define TIME        iTime\n#define TTIME       (TAU*TIME)\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define LAYERS      6\n#define FBM         3\n#define DISTORT     1.4\n#define PCOS(x)     (0.5+0.5*cos(x))\n\n// https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float eyeAngle = 0.8;\nconst mat2  eyeRot = ROT(eyeAngle);\nconst vec2  eyeRef = vec2(cos(eyeAngle), sin(eyeAngle));\n\nfloat g_psy_th = 0.0;\nfloat g_psy_hf = 0.0;\n\nvec2 g_psy_vx = vec2(0.0);\nvec2 g_psy_vy = vec2(0.0);\n\nvec2 g_psy_wx = vec2(0.0);\nvec2 g_psy_wy = vec2(0.0);\n\nconst vec3 lightPos1 = 100.0*vec3(-1.3, 1.9, 2.0);\nconst vec3 lightPos2 = 100.0*vec3(9.0,  3.2, 1.0);\nconst vec3 lightDir1 = normalize(lightPos1);\nconst vec3 lightDir2 = normalize(lightPos2);\nconst vec3 lightCol1 = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\nconst vec3 lightCol2 = vec3(8.0/8.0,6.0/8.0,7.0/8.0);\nconst vec3 skinCol1  = vec3(0.6, 0.2, 0.2);\nconst vec3 skinCol2  = vec3(0.6);\n\nvec3 saturate(in vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(in vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(in float a) { return clamp(a, 0.0, 1.0); }\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// IQ's smooth min: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\n// https://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat vesica(vec2 p, vec2 sz) {\n  if (sz.x < sz.y) {\n    sz = sz.yx;\n  } else {\n    p  = p.yx; \n  }\n  vec2 sz2 = sz*sz;\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r  = sqrt(sz2.x+d*d);\n  float b  = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\n// https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat raySphere(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    return -b - h;\n}\n\nfloat outer(vec2 p) {\n  p *= eyeRot;\n  return vesica(p, 1.0*vec2(0.5, 0.25))-0.15;\n}\n\nfloat inner(vec2 p) {\n  p *= eyeRot;\n  return vesica(p, 1.0*vec2(0.125, 0.35));\n}\n\n\nfloat qc_wave(float theta, vec2 p) {\n  return (cos(dot(p,vec2(cos(theta),sin(theta)))));\n}\n\nfloat qc_noise(vec2 p) {\n  float sum = 0.;\n  float a = 1.0;\n  for(int i = 0; i < LAYERS; ++i)  {\n    float theta = float(i)*PI/float(LAYERS);\n    sum += qc_wave(theta, p)*a;\n    a*=DISTORT;\n  }\n\n  return abs(tanh_approx(sum));\n}\n\nfloat qc_fbm(vec2 p, float time) {\n  float sum = 0.;\n  float a = 1.0;\n  float f = 1.0;\n  for(int i = 0; i < FBM; ++i)  {\n    sum += a*qc_noise(p*f);\n    a *= 2.0/3.0;\n    f *= 2.31;\n  }\n\n  return 0.45*(sum);\n}\n\nfloat qc_height(vec2 p) {\n  float od = outer(p);\n  float l = length(p);\n  const float s = 5.0;\n  p *= s;\n//  return -5.0*pmin(fbm(p), 0.75, 2.5)*exp(-5.0*l);\n  float sm = 0.05;\n  float oh = smoothstep(0.0, sm, od); \n  \n  float h =  -5.0*qc_fbm(p, TIME)*exp(-4.0*l)*oh;\n  return h;\n}\n\nvec3 qc_normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = qc_height(p + e.xy) - qc_height(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = qc_height(p + e.yx) - qc_height(p - e.yx);\n  \n  return normalize(n);\n}\n\nfloat psy_noise(vec2 p) {\n  float a = sin(p.x);\n  float b = sin(p.y);\n  float c = 0.5 + 0.5*cos(p.x + p.y);\n  float d = mix(a, b, c);\n  return d;\n}\n\nfloat psy_fbm(vec2 p, float aa) {\n  const mat2 frot = mat2(0.80, 0.60, -0.60, 0.80);\n\n  float f = 0.0;\n  float a = 1.0;\n  float s = 0.0;\n  float m = 2.0;\n  for (int x = 0; x < 4; ++x) {\n    f += a*psy_noise(p); \n    p = frot*p*m;\n    m += 0.01;\n    s += a;\n    a *= aa;\n  }\n  return f/s;\n}\n\nfloat psy_warp(vec2 p, out vec2 v, out vec2 w) {\n  float id = inner(p); \n  \n  const float r  = 0.5;\n  const float rr = 0.25;\n  float l2 = length(p);\n  float f  = 1.0;\n\n  p   -= eyeRef*pmax(0.0, dot(p, eyeRef), 0.25)*2.0;\n  p   -= 0.25*eyeRef;\n\n  f = smoothstep(-0.1, 0.15, id);\n  const float rep = 50.0;\n  const float sm = 0.125*0.5*60.0/rep;\n  float  n = smoothKaleidoscope(p, sm, rep);\n  p.y += TIME*0.125+1.5*g_psy_th;\n\n  g_psy_hf = f;\n  vec2 pp = p;\n\n  vec2 vx = g_psy_vx;\n  vec2 vy = g_psy_vy;\n\n  vec2 wx = g_psy_wx;\n  vec2 wy = g_psy_wy;\n\n  //float aa = mix(0.95, 0.25, tanh_approx(pp.x));\n  float aa = 0.5;\n\n  v = vec2(psy_fbm(p + vx, aa), psy_fbm(p + vy, aa))*f;\n  w = vec2(psy_fbm(p + 3.0*v + wx, aa), psy_fbm(p + 3.0*v + wy, aa))*f;\n  \n  return -tanh_approx(psy_fbm(p + 2.25*w, aa)*f);\n}\n\nvec3 psy_normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = psy_warp(p + e.xy, v, w) - psy_warp(p - e.xy, v, w);\n  n.y = 2.0*e.x;\n  n.z = psy_warp(p + e.yx, v, w) - psy_warp(p - e.yx, v, w);\n  \n  return normalize(n);\n}\n\nvec3 psy_weird(vec2 p) {\n  vec3 ro = vec3(0.0, 10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec2 v;\n  vec2 w;\n \n  float h  = psy_warp(p, v, w);\n  float hf = g_psy_hf;\n  vec3  n  = psy_normal(p);\n\n  vec3 lcol1 = lightCol1;\n  vec3 lcol2 = lightCol2;\n  vec3 po  = vec3(p.x, 0.0, p.y);\n  vec3 rd  = normalize(po - ro);\n  \n  float diff1 = max(dot(n, lightDir1), 0.0);\n  float diff2 = max(dot(n, lightDir2), 0.0);\n\n  vec3  ref   = reflect(rd, n);\n  float ref1  = max(dot(ref, lightDir1), 0.0);\n  float ref2  = max(dot(ref, lightDir2), 0.0);\n\n  const vec3 col1 = vec3(0.1, 0.7, 0.8).xzy;\n  const vec3 col2 = vec3(0.7, 0.3, 0.5).zyx;\n  \n  float a = length(p);\n  vec3 col = vec3(0.0);\n//  col -= 0.5*hsv2rgb(vec3(fract(0.3*TIME+0.25*a+0.5*v.x), 0.85, abs(tanh_approx(v.y))));\n//  col -= 0.5*hsv2rgb(vec3(fract(sqrt(0.5)*TIME+0.25*a+0.125*w.x), 0.85, abs(tanh_approx(w.y))));\n  col += hsv2rgb(vec3(fract(-0.1*TIME+0.125*a+0.5*v.x+0.125*w.x), abs(0.5+tanh_approx(v.y*w.y)), tanh_approx(0.1+abs(v.y-w.y))));\n  col -= 0.5*(length(v)*col1 + length(w)*col2*1.0);\n   /*\n  col += 0.25*diff1;\n  col += 0.25*diff2;\n  */\n  col += 0.5*lcol1*pow(ref1, 20.0);\n  col += 0.5*lcol2*pow(ref2, 10.0);\n  col *= hf;\n\n  return max(col, 0.0);\n}\n\nfloat vmax(vec2 v) {\n  return max(v.x, v.y);\n}\n\nfloat corner(vec2 p) {\n  return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float ld1      = max(dot(lightDir1, rd), 0.0);\n  float ld2      = max(dot(lightDir2, rd), 0.0);\n  vec3 final     = vec3(0.0);\n\n  rd.xy *= ROT(-1.);\n  vec2 bp = rd.xz/max(0.0,rd.y);\n  float bd = corner(-bp);\n  final += 0.3*exp(-5.0*max(bd, 0.0)); \n  final += 0.20*smoothstep(0.025, 0.0, bd); \n  \n  final += 8.0*lightCol1*pow(ld1, 100.0);\n  final += 8.0*lightCol2*pow(ld2, 100.0);\n  \n  return final;\n}\n\nvec3 eyeColor(vec2 p, vec3 ro, vec3 rd, vec3 po, float od) {\n  float aa = 2.0/RESOLUTION.y;\n  vec3 sc    = vec3(0.0);\n  float sd   = raySphere(ro, rd, vec4(sc, 0.75));\n  vec3 spos  = ro + sd*rd;\n  vec3 snor  = normalize(spos - sc);\n  vec3 refl  = reflect(rd, snor);\n  vec3 scol  = skyColor(spos, refl);\n  float dif1 = max(dot(snor, lightDir1), 0.0);\n  float dif2 = max(dot(snor, lightDir2), 0.0);\n\n\n  vec3 pcol = psy_weird(p);\n  vec3 col1 = vec3(0.0);\n  col1 += pcol;\n  col1 += scol;\n  col1 += 0.025*(dif1*dif1+dif2*dif2);\n\n  vec3 col2 = 0.125*(skinCol1)*(dif1 + dif2)+0.125*sqrt(scol);\n \n  snor.xz *= ROT(-0.5*eyeAngle);\n  snor.xy *= ROT(-2.4*smoothstep(0.99, 1.0, sin(TTIME/12.0)));\n  float a = atan(snor.y, snor.x);\n\n  vec3 col = mix(col1, col2, step(a, 0.0));\n\n  col *= smoothstep(0.0, -0.1, od);\n  \n  return col;\n}\n\nvec3 skinColor(vec2 p, vec3 ro, vec3 rd, vec3 po, float od) {\n  float lp = length(p);\n  float aa = 2.0/RESOLUTION.y;\n\n  float qch = qc_height(p);\n  vec3  qcn = qc_normal(p);\n\n  float diff1 = max(dot(qcn, lightDir1), 0.0);\n  float diff2 = max(dot(qcn, lightDir2), 0.0);\n\n  vec3  ref   = reflect(rd, qcn);\n  vec3  scol  = skyColor(po, ref);\n\n  vec3 lcol1 = lightCol1;\n  vec3 lcol2 = lightCol2;\n  vec3 lpow1 = 0.25*lcol1;\n  vec3 lpow2 = 0.5*lcol2;\n  vec3 dm = mix(1.0*skinCol1, skinCol2, 1.0+tanh_approx(2.0*qch))*tanh_approx(-qch*10.0+0.125);\n  vec3 col = vec3(0.0);\n  col += dm*sqrt(diff1)*lpow1;\n  col += dm*sqrt(diff2)*lpow2;\n\n  const float ff = 0.6;\n  float f = ff*exp(-2.0*od);\n\n  col *= f;\n  col += 0.5*ff*sqrt(scol);\n  col -= (1.0-tanh_approx(10.0*-qch))*f;\n  col *= smoothstep(0.0, 0.025, od);\n  return col;\n}\n\nvoid compute_globals() {\n\n  vec2 vx = vec2(0.0, 0.0);\n  vec2 vy = vec2(3.2, 1.3);\n\n  vec2 wx = vec2(1.7, 9.2);\n  vec2 wy = vec2(8.3, 2.8);\n\n  vx *= ROT(TTIME/1000.0);\n  vy *= ROT(TTIME/900.0);\n\n  wx *= ROT(TTIME/800.0);\n  wy *= ROT(TTIME/700.0);\n  \n  g_psy_vx = vx;\n  g_psy_vy = vy;\n  \n  g_psy_wx = wx;\n  g_psy_wy = wy;\n}\n\nvec3 color(vec2 p) {\n  compute_globals();\n  \n  float aa = 2.0/RESOLUTION.y;\n  float od = outer(p);\n\n\n  vec3 ro = vec3(0.0, 10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, 0.0, p.y);\n  vec3 rd = normalize(po-ro);\n\n\n  vec3 col = od > 0.0 ? skinColor(p, ro, rd, po, od) : eyeColor(p, ro, rd, po, od); \n  \n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float a = PCOS(TTIME/60.0);\n  p *= mix(0.8, 1.2, 1.0-a);\n  vec3 col = color(p);\n\n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NlSSDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[498, 606, 628, 628, 774], [775, 1633, 1659, 1659, 1688], [1689, 1689, 1715, 1715, 1744], [1745, 1745, 1773, 1773, 1802], [1804, 1804, 1832, 1852, 1928], [1930, 2004, 2043, 2043, 2128], [2130, 2130, 2169, 2169, 2198], [2200, 2200, 2230, 2230, 2257], [2259, 2259, 2281, 2281, 2325], [2327, 2327, 2348, 2348, 2393], [2395, 2427, 2472, 2472, 2626], [2628, 2628, 2689, 2689, 2902], [2904, 2904, 2935, 2935, 3233], [3235, 3314, 3359, 3359, 3551], [3553, 3553, 3574, 3574, 3637], [3639, 3639, 3660, 3660, 3720], [3723, 3723, 3759, 3759, 3813], [3815, 3815, 3839, 3839, 4043], [4045, 4045, 4079, 4079, 4254], [4256, 4256, 4281, 4281, 4538], [4540, 4540, 4564, 4564, 4782], [4784, 4784, 4809, 4809, 4931], [4933, 4933, 4966, 4966, 5222], [5224, 5224, 5272, 5272, 6021], [6023, 6023, 6048, 6048, 6286], [6288, 6288, 6312, 6312, 7503], [7505, 7505, 7525, 7525, 7551], [7553, 7553, 7575, 7575, 7635], [7637, 7637, 7670, 7670, 8072], [8074, 8074, 8134, 8134, 8893], [8895, 8895, 8956, 8956, 9710], [9712, 9712, 9736, 9736, 10033], [10035, 10035, 10055, 10055, 10372], [10374, 10374, 10410, 10410, 10643], [10645, 10645, 10700, 10700, 10941]]}
{"id": "NlSXRV", "name": "Kerbal Kraken", "author": "Roninkoi", "description": "Deep Space Kraken as found on Bop in Kerbal Space Program [url]https://aliens.fandom.com/wiki/Deep_Space_Kraken[/url]\n\nOut of its element!", "tags": ["sea", "kraken", "kerbalspaceprogram"], "likes": 7, "viewed": 178, "date": "1628022227", "time_retrieved": "2024-06-20T20:47:46.652750", "image_code": "#define PI 3.14159265\n#define MAXIT 150\n#define EPSILON 0.05\n#define STEP 0.5\n\n#define minx4(a, b) ((a.x) < (b.x) ? (a) : (b))\n#define minx2(a, b) ((a.x) < (b.x) ? (a) : (b))\n\n#define GROUNDCOL 1.\n#define KRAKENCOL 2.\n#define TENTACLECOL 3.\n#define BEAKCOL 4.\n#define EYECOL 5.\n\nmat3 rotX(float a)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\n\nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, -sin(a),\n        0., 1., 0.,\n        sin(a), 0.0, cos(a)\n    );\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n\nfloat hash(vec2 r) {\n    return fract(sin(dot(r, vec2(15.5921, 96.654654))) * 23626.3663);\n}\n\nfloat t;\n\nfloat sphere(vec3 r, float a)\n{\n    return length(r) - a;\n}\n\nfloat beak(vec3 r, float a)\n{\n\tvec3 p = r;\n\tp.x *= 0.8;\n\tp.y *= 0.6;\n\t\n\tvec3 b1 = rotZ(PI/4. - 0.4 - abs(sin(t*3.)) * 0.9)*vec3(p.x - p.y * p.y * p.y, p.y, 0.);\n\tvec3 b2 = rotZ(PI/4. + 0.4 + abs(sin(t*3.)) * 0.9)*vec3(p.x + p.y * p.y * p.y, p.y, 0.);\n\t\n    return length(p) - a + max(-b1.x-b1.y + 0.12, 0.)*max(-b2.x-b2.y + 0.12, 0.)*10.;\n}\n\nfloat body(vec3 r, float a)\n{\n\tr.y -= abs(r.y)*0.33;\n    return length(r) - a;\n}\n\nfloat torus(vec3 r, vec3 a)\n{\n    vec2 p = vec2(length(r.xz) - a.x, r.y);\n    return length(p) - a.y;\n}\n\nfloat plane(vec3 r, vec3 o, vec3 n) {\n\tr.y += sin(r.x * 0.1) * 2.;\n\tr.y += cos(r.z * 0.1) * 2.;\n\tr.y += (sin(r.x)) * 0.2;\n\tr.y += (sin(r.x) + cos(r.z * 0.5)) * 0.2;\n\t\n    return dot(r - o, n);\n}\n\nfloat tentacle(vec3 r, vec3 a, float tt)\n{\n\tfloat d = a.y - r.y;\n\tr.x += sin(r.x * 0.2 + r.y * 0.5 + tt) * d * 0.3;\n\tr.z += cos(r.z * 0.1 + r.y * 0.8 + tt) * d * 0.3;\n\ta.z = clamp(a.z - d * a.z / a.y / 2., 0., a.z);\n    \n\tvec2 p = abs(vec2(length(r.xz), r.y)) - a.xy;\n\tp.x = abs(p.x) - a.z;\n\n\treturn min(max(p.x, p.y), 0.0) + length(max(p, 0.));\n}\n\nfloat box(vec3 r, vec3 a)\n{\n    vec3 p = (abs(r) - a);\n\n    return length(max(p + 0.1, 0.));\n}\n\nfloat shade(vec3 n, vec3 rd)\n{\n    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n\nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n    return mix(fogCol, col, exp(-z));\n}\n\nvec3 matCol(vec4 o)\n{\n\tvec2 cc = o.zw;\n\t\n    if (o.y == GROUNDCOL) {\n\t    cc.x += cos(.3*t) * 2.;\n\t    cc.y += sin(.3*t) * 2.;\n        return normalize(vec3(0.8 + sin(cc.x + cc.y) * 0.05, 0.5 + sin(cc.x) * 0.1, 0.0));\n    }\n    \n    if (o.y == KRAKENCOL) {\n\t    float fade = cos(clamp(cc.y*1.2, 0., PI/2.));\n\t    vec3 top = normalize(vec3(0., 0.9, 0.)) * (sin(cc.x * 6.) * fade * 0.6 + 0.4);\n\t    float bfade = clamp(-cc.y+.3, 0., 1.);\n\t    vec3 bot = vec3(0.7, 0.3, 0.);\n\t    return top * (1.-bfade) + bot * bfade;\n    }\n    \n    if (o.y == TENTACLECOL) {\n\t    float fade = clamp(abs(cc.y), 0., PI/2.);\n\t    vec3 top = normalize(vec3(0., 0.9, 0.)) * ((fade) * 0.8) * 0.5;\n\t    return top;\n    }\n    \n    if (o.y == EYECOL) {\n\t    float fade = cos(clamp(cc.y*10., 0., PI/2.));\n\t    \n\t    float pupil = smoothstep(-0.6,-0.5, cc.y);\n\t    float lid = smoothstep(0.0,-0.2, cc.y);\n\t    vec3 top = vec3(1.2, 1.2, 0.) * (cos(cc.x * 6.) * fade * 0.6 + 0.4) + vec3(0.9, 1., 0.);\n\t    \n\t    return top * pupil * lid + vec3(0.2, 0.0, 0.2) * (1. - pupil) + vec3(0.5, 0.8, 0.) * (1.-lid);\n    }\n    \n    if (o.y == BEAKCOL) {\n\t    float fade = clamp(abs(sin(cc.y * cc.y)), 0., PI/2.);\n\t    vec3 top = normalize(vec3(1.7, 1., 0.8)) * (fade * 0.6 + 0.4);\n\t    return top * fade;\n    }\n    \n    return normalize(vec3(0.8, 0.2, 0.));\n}\n\nmat3 obj;\n\nvec4 kraken(vec3 r, float tt)\n{\n\tvec3 br = r * rotY(0.7) * rotX(-PI / 2.);\n\tbr *= rotY((sin(t) + t * 1.5) * 0.5);\n\tvec2 bc = vec2(atan(br.x, br.z), br.y / 3.);\n\t\n\tvec4 bd = vec4(\n\t\tbody(br, 3.), matCol(vec4(0., KRAKENCOL, bc))\n\t);\n\t\n\tvec4 td = vec4(1000., 0., 0., 0.);\n\tfor (int a = 0; a < 6; ++a) {\n\t\tfloat aa = float(a) - PI / 4.;\n\t\tfloat split = (floor(float(a) / 3.) * 2. - 1.) * 0.3;\n\t\ttd = minx4(td, \n            vec4(tentacle(br + 1.7 * vec3(cos(float(aa)) - split, 1.8, sin(float(aa))),\n                vec3(.01, 2., .6), tt * 0.5), \n            matCol(vec4(0., TENTACLECOL, bc))\n\t\t));\n\t}\n\t\n\tvec3 er = br + vec3(0., 2., -1.5);\n\tfloat eax = sin(t * 2.) * 0.4;\n\tfloat eaz = cos(t * 2.) * 0.4;\n\ter *= rotX(eax * sin(t * 0.71)) * rotZ(eaz * sin(t * 0.54));\n\tvec2 ec = vec2(atan(er.x, er.z), er.y);\n\tvec4 ed1 = vec4(\n\t\tsphere(er, 0.6), matCol(vec4(0., EYECOL, ec))\n\t);\n\ter = br + vec3(0., 2., 1.5);\n\ter *= rotX(-eax * cos(t * 0.32)) * rotZ(-eaz * sin(t * 0.76));\n\tec = vec2(atan(er.x, er.z), er.y);\n\tvec4 ed2 = vec4(\n\t\tsphere(er, 0.6), matCol(vec4(0., EYECOL, ec))\n\t);\n\tvec4 ed = minx4(ed1, ed2);\n\t\n\tvec3 kr = br + vec3(0., 2.3, 0.);\n\tvec4 kd = vec4(\n\t\tbeak(kr, 0.6), matCol(vec4(0., BEAKCOL, bc))\n\t);\n\t\n\treturn minx4(minx4(minx4(bd, td), ed), kd);\n}\n\nvec4 map(vec3 r)\n{\n\tfloat tt = t * 10. - sin(t) * 5.;\n\t\n\tr *= rotY(sin(t * 0.5));\n\t\n\tvec4 kd = kraken(r, tt);\n\t\n\tvec3 gr = r;\n\tgr.x += tt * 0.4;\n\tgr.z += tt;\n\tgr.y += 7.;\n\t\n\tvec4 gd = vec4(\n\t\tplane(gr, vec3(0., 0., 0.), vec3(0., 1., 0.)), matCol(vec4(0., GROUNDCOL, gr.xz))\n\t);\n\t\n\treturn minx4(gd, kd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    t = iTime;\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    mat3 cam = rotY(-PI) * rotX(0.3);\n\n    vec3 ro = vec3(0., 2.0, -10.0);\n    vec3 rd = cam * normalize(vec3(uv * 2., -1.));\n    vec3 r = ro;\n\n    vec3 bcol = vec3(0.2, 0.7, 0.8) * 1.1;\n    vec4 col = vec4(0.);\n    col.rgb = bcol;\n\n    float sh = 1.;\n\n    float glow = 0.;\n\n    int ch = 1;\n\n    for (int i = 0; i < MAXIT; ++i) {\n        vec4 d = map(r);\n        float z = length(r - ro);\n\n        glow += exp(-d.x);\n\n        if (d.x < EPSILON) {\n            col.rgb = mix(col.rgb, d.yzw,\n                shade(normalize(r), rd));\n\t\t\n            col.rgb = fog(z * 0.1, col.rgb, bcol);\n            break;\n        }\n\n        d.x *= 0.8 - 0.2 * hash(uv);\n        r += rd * d.x * STEP;\n\n        sh = (float(i) / float(MAXIT));\n    }\n\n    if (sh < 0.5)\n        col.rgb *= clamp(exp(-sh * 2.0 + 1.0), 0., 1.);\n\n    fragColor = vec4(col.rgb, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NlSXRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[279, 279, 299, 299, 401], [403, 403, 423, 423, 527], [529, 529, 549, 549, 651], [653, 653, 673, 673, 745], [757, 757, 788, 788, 816], [818, 818, 847, 847, 1158], [1160, 1160, 1189, 1189, 1240], [1242, 1242, 1271, 1271, 1345], [1347, 1347, 1384, 1384, 1541], [1543, 1543, 1585, 1585, 1890], [1892, 1892, 1919, 1919, 1986], [1988, 1988, 2018, 2018, 2073], [2075, 2075, 2117, 2117, 2157], [2159, 2159, 2180, 2180, 3477], [3490, 3490, 3521, 3521, 4743], [4745, 4745, 4763, 4763, 5049], [5051, 5051, 5106, 5106, 6068]]}
{"id": "NlSXW3", "name": "Glacial moraines", "author": "jarble", "description": "A flowing glacial landscape.\nThis is based on dyla's [url=https://www.shadertoy.com/view/WdcfDn]\"Fyords\"[/url] shader.", "tags": ["procedural", "fractal", "mountain", "glacier", "moraine"], "likes": 2, "viewed": 139, "date": "1628714483", "time_retrieved": "2024-06-20T20:47:47.671733", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\n\n//increase this constant to increase the amount of detail\n#define OCTAVES 4\n\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    float value = 0.;\n    float factor = -3.;\n    uv *= factor;\n    for (int i = 0; i < OCTAVES; i++)\n    {\n        uv += vec2(sin(uv.x*factor)/factor,cos(uv.y/factor)*factor).yx;\n        value = 1.+max(value+value*sin(uv.x/factor)/factor,value+cos((uv.y/factor)/factor)/factor);\n        uv += max(uv,uv.yx);\n        uv /= factor/1.5;\n        if(i%2 == 0){\n           uv = -uv.yx;\n        }\n        \n        //factor /= 1.5;\n        \n    }\n    \n    return value;\n}\n\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    float factor = 1.5;\n    return fbm(uv/factor);\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*(iTime+11.));\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    #endif\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 1.;\n\n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NlSXW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[411, 488, 511, 560, 1025], [1099, 1099, 1137, 1137, 1190], [1192, 1192, 1225, 1225, 1445], [1447, 1447, 1485, 1485, 1712], [1714, 1714, 1752, 1752, 1976], [1978, 1978, 2007, 2007, 2102], [2104, 2104, 2141, 2141, 2200], [2203, 2271, 2290, 2290, 2329], [2331, 2331, 2351, 2351, 2427], [2429, 2429, 2448, 2448, 2487], [2489, 2489, 2546, 2546, 2781], [2783, 2783, 2818, 2818, 3212], [3214, 3214, 3268, 3268, 3934], [3937, 3937, 3989, 3989, 4424], [4426, 4426, 4483, 4483, 5674]]}
{"id": "NlXSDr", "name": "Isreal's Flag", "author": "Pelegefen", "description": "It's israel's flag drawn in a shader.", "tags": ["flag", "israel"], "likes": 7, "viewed": 175, "date": "1630073820", "time_retrieved": "2024-06-20T20:47:47.671733", "image_code": "//music link -  https://soundcloud.com/sajankamusic/sajanka-sun-is-coming\n\n//#define DANCING; //uncomment to make the flag dance to the music( By Sajanka, an isreali artist, hence the flag)\n\n\n\n#define WHITE vec3(255,255,255)/255.\n#define BLUE vec3(0,56,184)/255.\n#define PI 3.14159265359\n#define S smoothstep \n\n\n\nfloat StarOfDavid(vec2 uv, float size){\n\n    uv *= size;\n    uv.x = abs(uv.x);\n    uv.y *= 1.4;\n    float a = 1.08;\n    float a2 = 4.286389;\n    float a3 = 2.03;\n    \n    float offs = .1;\n    float d1 = S(-.501,-.50,dot(uv , vec2(0.,1.05 - offs)));\n    float d2 = S(.541,.54,dot(uv , vec2(sin(a),cos(a))));\n    \n    float d11 = S(-.001-offs,-.00-offs,dot(uv , vec2(0.,0.4 - offs)));\n    float d12 = S(.501-offs,.50-offs,dot(uv, vec2(sin(a),cos(a))));\n    \n    float d3 = S(.501,.50,dot(uv, vec2(sin(a3),cos(a3))));\n    float d4 = S(.501,.50,dot(uv , vec2(0.,.8)));\n    \n     float d21 = S(.001+offs,.00+offs,dot(uv , vec2(0.,0.33 - offs)));\n     float d22 =  S(.251+offs,.250+offs,dot(uv, vec2(sin(a3),cos(a3))));\n     \n    float m1 = min(d1,d2);\n    \n    float m11 = min(d11,d12);\n    m1 -= m11;\n    \n    \n    float m2 = min(d4,d3);\n    \n    float m21 = min(d21,d22);\n    m2 -= m21;\n    \n    //if(uv.x>=0. && uv.x <= .01)col = vec3(1.,0.,0.);\n     //if(uv.y>=0. && uv.y <= .01)col = vec3(1.,0.,0.);\n     float s = max(m1, m2);\n     \n  return s; \n   }\n   \n   \n   vec3 Flag(vec2 uv){\n    //blue stripes\n    uv *= 1.5;\n    vec2 st = uv;\n    uv.x *= 1.2;\n    st.y = abs(st.y);\n    \n    \n    float s = S(0.41,.4,abs(st.y));\n    s  -= S(0.26,.25,abs(st.y));\n    vec3 nCol = mix(WHITE,BLUE,s);\n    vec3 col = vec3(nCol);\n\n    \n    float star = StarOfDavid(uv,4.);\n    vec3 cstar =  mix(col, BLUE,star);\n    \n    \n    cstar *= S(0.01,0.,abs(uv.y)-.5+0.012);\n     //cstar *= S(0.01,0.,abs(uv.y)-.5+0.01);\n    return cstar;\n    \n    }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // unNormalized pixel coordinates (from -.5 to .5)\n     vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;    \n    \n   # ifdef DANCING\n   float freq = texture( iChannel0, vec2( 0.01, 0.01 ) ).x; \n   float freq1 = texture( iChannel0, vec2( 0.15, 0.15 ) ).x; \n   #else\n   float freq = .5; \n   float freq1 = .5; \n   #endif\n   \n   \n    float t = sin(iTime + sin(iTime + (uv.x  - uv.y))*5.5+5.5)*(.03 );\n    \n    uv.y -= clamp(t / max(freq ,.1),-.5,.5) ;\n    uv.x -= clamp(t / max(freq1,.1),-.5,.5) ;\n    \n    \n    float sd = cos(iTime + sin(iTime + (uv.x - uv.y ))*5.5+5.5)*(.3 );\n    vec3 col = vec3(Flag(uv)) -clamp( sd,0.,1. );\n   \n    \n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NlXSDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[75, 313, 352, 352, 1364], [1376, 1376, 1395, 1414, 1838], [1839, 1839, 1896, 1951, 2612]]}
{"id": "Ns3GWn", "name": "Persian carpet 2", "author": "jarble", "description": "Another random carpet generator, with an even greater variety of shapes and colors.", "tags": ["fractal", "carpet", "rug"], "likes": 4, "viewed": 151, "date": "1629468331", "time_retrieved": "2024-06-20T20:47:48.131893", "image_code": "\n//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//to do: drag and drop using https://www.shadertoy.com/view/WdGGWh\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5*3./2.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    float t2 = floor((iTime+4.)/20.0+uv.x);\n    //vec3 random2 = hash31(1.+t2);\n    //vec3 random4 = (hash31(3.+t2)-vec3(.5))/4.;\n    \n    \n    \n    for(int c=0;c<3;c++){\n    float scale = c1.z;\n    float scale1 = 1.0;\n    float t3 = float(c)+t2;\n    vec3 random2 = hash31(1.+t3);\n    vec3 random3 = (hash31(2.+t3)-vec3(.5))/4.;\n    vec3 random4 = (hash31(3.+t3)-vec3(.5))/4.;\n    float offset = .16+random4.z*.04;\n    float scale2 = 1.+random2.x;\n        //vec3 col_prev = 0.0;\n        for(int i=0;i<3;i++)\n        {\n            vec3 col_prev = col;\n            float factor = -1.1;\n            uv = triangle_wave(uv.yx+1.5,scale)+triangle_wave(uv,scale);\n            uv.x *= factor;\n\n            uv = triangle_wave((uv+offset)/(random4.y+1.),scale+random3.x);\n            uv.x /= factor;\n            \n            uv = triangle_wave(uv+offset,scale+random3.y);\n            uv.x *= factor;\n            \n            uv = triangle_wave((uv+offset)*(random4.x+1.),scale+random3.z);\n            uv.x /= factor;\n            \n            //uv.x *= -1.0;\n            //uv = triangle_wave(uv+c1.y,scale);\n            scale /= 1.+scale2*col.x;\n            //offset *= scale2/(1.+random4.x);\n            \n            uv = -uv.yx;\n            //uv = uv.yx;\n            scale2 += col.x/8.;\n            if(i>0) col = (col.yzx*random2.x + col_prev*random2.y)/(random2.x+random2.y);\n            col[c] = fract((uv.x)-(uv.y));\n\n            \n\n        }\n\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3GWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[346, 456, 478, 524, 657], [659, 659, 698, 698, 743], [745, 745, 802, 802, 2546]]}
{"id": "Nsc3Dn", "name": "Mixing materials", "author": "mouseDown", "description": "After a good while of lurking & learning from everyone on here I decided to publish something. Thanks to Inigo, ArtofCode and many others for being such good tutors! Any and all feedback is more than welcome!", "tags": ["raymarching", "mixing"], "likes": 12, "viewed": 170, "date": "1629481076", "time_retrieved": "2024-06-20T20:47:50.416853", "image_code": "precision highp float;\n\n// Change OBJECTS_NUMBER up to 6 to add more objects, but making the app heavier\n#define OBJECTS_NUMBER 6\n\n// Turn REFLECTIONS off by setting the value to zero\n#define REFLECTIONS 1\n\n#define MAX_STEPS 150\n#define MAX_DIST 75.0\n#define SURF_DIST 0.01\n#define PI 3.14159265359\n#define ZERO 0\n#define FOV 0.55\n#define ORBIT 6.0\n#define T iTime * 0.15\n#define S smoothstep\n\nmat2 rotate( float a ){ float s = sin( a ), c = cos( a ); return mat2( c, -s, s, c ); }\nfloat hash21( vec2 seed ){ return fract( sin( dot( seed * .1684,vec2( 54.649, 321.547 ) ) ) * 450315. ); }\nfloat smin( float a, float b, float k ){ float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 ); return mix( b, a, h ) - k*h*(1.0-h) + 0.01; }\nfloat ssmin( float a, float b, float k ){ float h = S( 0.275, 0.725, 0.5+0.5*(b-a)/k ); return mix( b, a, h ) - h*(1.0-h); }\nfloat smax( float a, float b, float k ){ return log( exp( k * a ) + exp( k * b ) ) / k; }\n\nstruct Mat {\n    vec3   albedo;          // RGB color\n    float  reflectivity;    // Reflection strength\n    vec2   specular;        // Specular highlight : Smoothstep min(x) and max(y)\n    vec4   fresnel;         // Used for inner glow. 'w' Is used for application strength\n    vec4   emissive;        // If this value is > 0.0 it will be re-applied after diffuse\n};\n\nstruct Solution {\n    float d; // Distance to the scene\n    Mat m; // Material properties\n};\n\n\nvec3 black   = vec3( 0.0, 0.0, 0.0 );\nvec3 white   = vec3( 1.0, 1.0, 1.0 );\nvec3 red     = vec3( 0.9, 0.1, 0.2 );\nvec3 blue    = vec3( 0.2, 0.1, 0.9 );\nvec3 yellow  = vec3( 1.0, 0.6, 0.2 );\nvec3 green   = vec3( 0.05, 0.6, 0.3 );\n\n\n\nMat GetMat( float m, vec3 p ){\n\n    Mat mat;\n\n    if( m == 0.0 ){ // B L A C K\n        mat.albedo = black;\n        mat.reflectivity = 0.0;\n        mat.specular = vec2( 0.0, 1.0 );\n        mat.fresnel = vec4( black, 0.0 );\n        mat.emissive = vec4( black, 0.0 );\n        return mat;\n    }\n    if( m == 1.0 ){ // B L U E\n        mat.albedo = mix( black, blue, 0.5 );\n        mat.reflectivity = 0.0;\n        mat.specular = vec2( 0.5, 0.9 );\n        mat.fresnel = vec4( mix(blue, white, 0.25), 0.75 );\n        mat.emissive = vec4( blue, 0.0 );\n        return mat;\n    }\n    if( m == 2.0 ){ // R E D\n        mat.albedo = mix( red, yellow, 0.2 );\n        mat.reflectivity = 0.0;\n        mat.specular = vec2( 0.8, 0.9 );\n        mat.fresnel = vec4( yellow, 0.0 );\n        mat.emissive = vec4( mix( red, blue, 0.15 ), 0.15 );\n        return mat;\n    }\n    if( m == 3.0 ){ // M I R R O R \n        mat.albedo = black;\n        mat.reflectivity = 1.0;\n        mat.specular = vec2( 0.92, 0.95 );\n        mat.fresnel = vec4( white, 0.25 );\n        mat.emissive = vec4( black, 0.0 );\n        return mat;\n    }\n    if( m == 4.0 ){ /// G R E E N\n        mat.albedo = mix( green, yellow, 0.2 );\n        mat.reflectivity = 0.0;\n        mat.specular = vec2( 0.0, 1.5 );\n        mat.fresnel = vec4(  mix(green, blue, 0.2), 0.3 );\n        mat.emissive = vec4( mix(green, blue, 0.1), 0.2 );\n        return mat;\n    }\n    if( m == 5.0 ){ /// W H I T E\n        mat.albedo = white;\n        mat.reflectivity = 0.3;\n        mat.specular = vec2( 0.0, 1.0 );\n        mat.fresnel = vec4( white, 0.05 );\n        mat.emissive = vec4( white, 0.6 );\n        return mat;\n    }\n    if( m == 6.0 ){ /// Y E L L O W\n        mat.albedo = mix( black, blue, 0.15 );\n        mat.reflectivity = 0.0;\n        mat.specular = vec2( 0.2, 0.9 );\n        mat.fresnel = vec4( red, 0.0 );\n        mat.emissive = vec4( yellow, 2.0 );\n        return mat;\n    }\n\n}\n\nMat MixMat( Mat m1, Mat m2, float k, vec3 p ){\n\n    Mat newMat;\n\n    newMat.albedo       = mix( m1.albedo, m2.albedo, k );\n    newMat.reflectivity = mix( m1.reflectivity, m2.reflectivity, k );\n    newMat.specular     = mix( m1.specular, m2.specular, k );\n    newMat.fresnel      = mix( m1.fresnel, m2.fresnel, k );\n    newMat.emissive     = mix( m1.emissive, m2.emissive, k );\n\n    return newMat;\n\n}\n\n\n// S D F\nfloat sdSphere( vec3 p, float s ){\n    return length( p ) - s;\n}\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 q = abs( p ) - b;\n    return length( max( q,0.0 ) ) + min( max( q.x, max( q.y,q.z ) ), 0.0 );\n}\nfloat sdTorus( vec3 p, vec2 t ){\n    vec2 q = vec2( length( p.xz ) - t.x, p.y );\n    return length( q ) - t.y;\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h ){\n    vec2 d = vec2( length( p.xz ) - 2.0 * ra + rb, abs( p.y ) - h );\n    return min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) ) - rb;\n}\n\n\n// M A P\nSolution map( vec3 p ){\n\n    float d  = 9e9;\n    float d2 = 9e9;\n    Mat m = GetMat( 0.0, p );\n    float t = 0.0;\n    float k = 0.0;\n\n\n// O B J E C T S\n\n    float amp = 1.0 / length(p) * 20.;\n    float offset = T*50.0;\n    float dots = ( cos( p.x * amp ) +\n                   cos( p.y * amp + offset ) + \n                   cos( p.z * amp ) ) / amp;\n    \n    // Center sphere\n    float sphere = sdSphere( p, 1.25);\n    Mat sM = GetMat( 4.0, p );\n    \n    // Perforated cube\n    vec3 cP = p;\n         cP.yz *= rotate( T * 1.05);\n         cP.xz *= rotate( -T * 0.93 );\n         cP += vec3( sin( T * 0.2 ) * 3.25, 0.0, cos( T * 0.2 ) * ( 3.0 + sin(T) ) );\n    float cube = sdBox( cP, vec3( 1.0, 0.8, 1.0 ) ) - 0.2;\n    float cubeS = sdBox( cP, vec3( 0.4, 1.5, 0.4 ) );\n    float sphereS = sdSphere( p, 2.0 );\n          cube = max( cube, -cubeS );\n    Mat cM = GetMat( 2.0, p );\n\n    // Pole / french fry\n    float pole = sdBox( cP + vec3( 0.0, sin(T*5.0)*1.15, 0.0), vec3( 0.3, 0.5, 0.3 ) )-0.1;\n    Mat poleM = GetMat( 6.0, p );\n\n    vec3 tP = p - vec3( 0.0, sin(T/2.0)*3.35, 0.0 );\n         tP.xy *= rotate(T/2.0);\n         tP.xz *= -rotate(T/2.0);\n    float torus = sdTorus( tP, vec2( 1.65, 0.5 ) );\n    Mat tM = GetMat( 3.0, p ); \n \n    // Cylinder\n    vec3 cylP = p - vec3( sin(T)*2.5, sin(-T)*3.0, cos(T)*2.5 );\n         cylP.xy *= rotate(  T );\n         cylP.xz *= rotate( -T * 1.4 );\n         cylP.yz *= rotate(  T * 3.1 );\n    Mat cylM = GetMat( 1.0, p );\n    float cylT = S( 0.49, 0.51, T );\n    float cyl = sdRoundedCylinder( cylP, 0.75, 0.15, 0.3 );\n    \n    // Plus\n    vec3 plusP = p - vec3( sin(T*0.457)*6.73, 0.0, 0.0 );\n         plusP.xy *= rotate(sin(T*0.457)*6.73);\n    float shield = sdSphere( plusP, 2.0 );\n    float cubeP = sdBox( plusP, vec3( 0.75, 0.25, 0.25 ) ) ;\n    float cubeM = sdBox( plusP, vec3( 0.25, 0.25, 0.75 ) ) ;\n    float plus = min( cubeM, cubeP)-0.1;\n    Mat plusM = GetMat( 5.0, p );\n\n    \n    \n// B O O L\n    \n    if( OBJECTS_NUMBER > 0 ){\n        d = min( d, sphere ); // Center sphere\n        k = d < sphere ? 0.0 : 1.0;\n        m = MixMat( m, sM, k, p );\n    }\n    \n    if( OBJECTS_NUMBER > 1 ){\n        d = min( d, torus ); // Torus\n        k = d < torus ? 0.0 : 1.0;\n        m = MixMat( m, tM, k, p );\n    }\n\n    if( OBJECTS_NUMBER > 2 ){\n        d = smin( d, cyl, 2.25 ); // Cylinder\n        t = d + cyl;\n        k = S( 0.0, 1.0, 1.0 - ( t - d ) * 0.75); // 0.35\n        m = MixMat( m, cylM, k, p );\n    }\n    \n    if( OBJECTS_NUMBER > 3 ){\n        d = ssmin( d, cube, 0.85 ); // Perforated cube\n        t = d + cube;\n        k = S( 0.4, 0.6, 1.0 - ( t - d ) * 1.4 );\n        m = MixMat( m, cM, k, p );\n    }\n    if( OBJECTS_NUMBER > 4 ){\n        d2 = min( d2, pole ); // Pole / french Fry\n        t = d2 + pole;\n        k = S( 0.0, 1.0, 1.0 - ( t - d2 ) * 0.65 );\n        m = MixMat( m, poleM, k, p );\n    }\n    if( OBJECTS_NUMBER > 5 ){\n        d = smax( d, -shield, 5.0 ); // Shield\n        d2 = smin( d2, plus, 2.0 ); // Plus\n        t = d2 + plus;\n        k = S( 0.0, 1.0, 1.0 - ( t - d2 ) * 2.0 );\n        m = MixMat( m, plusM, k, p );\n    }\n\n    \n// O U T\n\n    Solution so;\n    so.d = min(d, d2);\n    so.m = m;\n\n    return so;\n\n}\n\n\n// M A R C H\nSolution RayMarch( vec3 ro, vec3 rd ){\n\t\n    float d = 0.0; // Distance total\n    Solution dS;\n\n    for( int i = 0; i < MAX_STEPS; i++ ){\n\n    \tvec3 p = ro + rd * d;\n             dS = map( p ); // Distance per step\n             d += dS.d;\n    \n        if( abs( dS.d ) < SURF_DIST || d > MAX_DIST ){\n            break;\n        }\n        \n    }\n\n    dS.d = d;\n    return dS;\n\n}\n\nvec3 GetNormal( vec3 p ){\n\n\tfloat d = map( p ).d;\n    vec2 e = vec2( .01, 0 );\n    vec3 n = d - vec3(\n        map( p-e.xyy ).d,\n        map( p-e.yxy ).d,\n        map( p-e.yyx ).d );\n    \n    return normalize( n );\n\n}\n\nfloat calculateObstruction( vec3 p, vec3 lp, float lrad ){\n\n    float h = hash21( vec2( lp.x, p.y ) ) * 0.1;\n    vec3 toLight = normalize( lp - p );\n    float distToLight = length( lp - p );\n    float d; \n    float t = lrad * h;\n    float obstruction = 0.0;\n    for( int j=0; j<128; j++ ){\n    \n        d = map( p + t * toLight ).d;\n        obstruction = max( 0.5 + ( -d ) * distToLight / ( 2.0 * lrad * t ), obstruction );\n        if( obstruction >= 1.){ break; }\n        t += max( d, lrad * 0.1 / distToLight );\n        if( t >= distToLight ) break;\n\n    }\n    float obs = clamp( S(0.0, 1.0, obstruction ), 0., 1.);\n    return obs;\n\n}\n\nvec3 GetSpecular( vec3 p, vec3 r, Mat m, vec3 lp ){\n\n    float spec = max( 0.0, 0.5 * dot( r, normalize( lp - p ) ) + 0.45 );\n          spec = S( m.specular.x, m.specular.y, spec );\n    float obstruction = calculateObstruction( p, lp, 2.0 );\n    \n    float spec_o = 1.0 + abs( m.specular.x - m.specular.y );\n          spec_o = 1.0 / ( spec_o * spec_o * spec_o );\n          \n    spec *= 1.0 - obstruction;\n    vec3 level = spec * mix( m.albedo, white, spec_o );\n         level.r = S(0.0, 1.0, level.r);\n         level.g = S(0.1, 0.9, level.g);\n         level.b = S(0.2, 0.8, level.b);\nreturn level;\n}\n\n\nvec3 GetDiffuse( vec3 p, vec3 n, vec3 lp ){\n  \n    float lightRadius = 2.0;\n    float lightStrength = 5.0;\n\n    float obstruction = calculateObstruction( p, lp, lightRadius );\n    vec3  toLight = normalize( lp - p );\n    float distToLight = length( lp - p);\n    float diffuse = max( dot( n, toLight ), 0. ) /  distToLight * lightStrength;\n\n    vec3 dif = vec3( diffuse * ( 1.0 - obstruction ));\n    return dif;\n\n}\n\nfloat GetFresnel( vec3 rd, vec3 n ){\n    float e = dot( rd, n );\n    e = 0.5 + e * 0.5;\n    float e2 = S( 0.2, 0.6, e );\n    return S( 0.0, 1.0, e+e2 );\n}\n\nfloat GetAO( in vec3 p, in vec3 n ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i = ZERO; i < 5; i++ ){\n        float h = 0.0075 + 0.1 * float( i ) / 4.0;\n        float d = map( p + h * n ).d;\n        occ += ( h - d ) * sca;\n        sca *= 0.95;\n        if( occ > 0.3 ) break;\n    }\n    return 1.0 - occ;\n}\n\nvec3 GetReflection( vec3 inp, vec3 rd, vec3 inn, vec3 lp ){\n\n    vec3 r = reflect( rd, inn );\n    vec3 ro = inp + ( SURF_DIST * 2. ) * r;\n    Solution so = RayMarch( ro, r );\n\n    vec3 col;\n    vec3 p = ro + r * so.d;\n    vec3 n = GetNormal( p );\n    float angle = abs( dot( r, n ) );\n    \n    if( so.d < MAX_DIST ){\n\n        // A L B E D O \n        col = so.m.albedo;\n     \n        // D I F F U S E\n        vec3 dif = GetDiffuse( p, n, lp );\n        col *= dif;\n        \n        // E M I S S I V E\n        col = mix( col, so.m.emissive.rgb, so.m.emissive.a );\n\n        // I N N E R   G L O W   /   F R E S N E L\n        if( so.m.fresnel.a > 0.0 ){\n            float fresnel = GetFresnel( r, n );\n            col += so.m.fresnel.rgb * so.m.fresnel.a * fresnel;\n        }\n\n        // S P E C \n        vec3 spec = GetSpecular( p, r, so.m, lp );\n        col += spec * angle;\n\n    } else { col = black; }\n    \n    return col;\n\n}\n\nvec3 GetRayDir( vec2 uv, vec3 ro, vec3 ta, float fov ){\n    vec3 f = normalize( ta - ro ),\n         r = normalize(cross( vec3( 0, 1, 0 ), f )),\n         u = cross( f, r ),\n         c = f * fov, \n         i = c + uv.x * r + uv.y * u,\n         d = normalize( i );\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = ( fragCoord - 0.5 * iResolution.xy ) / iResolution.y; \n    vec2 m  = iMouse.xy / iResolution.xy;\n    vec2 mn = vec2( ( m +0.5 ) * 2.5 );\n    \n    vec3 ro = vec3( 0.0, 0.0, -6.5 );\n         ro.yz *= rotate( 4.0 * mn.y ), ro.xz *= rotate( -4.0 * mn.x );\n         \n    vec3 ta_wiggle = vec3( sin(T * 0.36 ) * 0.17, sin(T * 2.7 ) * 0.2, cos(T) * 0.23 );\n    vec3 ta = ta_wiggle * 0.5;\n\n\n    vec3 rd = GetRayDir( uv, ro, ta, FOV );\n\n    // Pointlight position\n    vec3 lp = vec3( sin( T *3.) * ORBIT, \n                    3.0, \n                    cos( T *3.) * ORBIT );\n    \n    vec3 col = black;\n\n\n    Solution so = RayMarch( ro, rd );\n    vec3 p = ro + rd * so.d;\n    vec3 n  = GetNormal( p );\n    vec3 r  = reflect( rd, n );\n    float angle = S( 0.01, 0.25, abs( dot( rd, n ) ) );\n    \n    if( so.d < MAX_DIST ){\n\n        // A L B E D O \n        col = so.m.albedo;\n     \n        // D I F F U S E\n        vec3 dif = GetDiffuse( p, n, lp );\n        col *= dif;\n\n        // E M I S S I V E\n        col = mix( col, so.m.emissive.rgb, so.m.emissive.a );\n        \n        // R E F L E C T I O N\n        if( REFLECTIONS > 0 ){\n            if( so.m.reflectivity > 0.0 ){\n                vec3 ref = GetReflection( p, rd, n, lp );\n                col = mix( col, col+ref, so.m.reflectivity );\n            }\n        }\n        // I N N E R   G L O W   /   F R E S N E L\n        if( so.m.fresnel.a > 0.0 ){\n            float fresnel = GetFresnel( rd, n );\n            col += so.m.fresnel.rgb * so.m.fresnel.a * fresnel * angle;\n        }\n\n        // S P E C \n        vec3 spec = GetSpecular( p, r, so.m, lp );\n        col += spec * angle;\n        \n        // A O \n        float ao = GetAO( p, n );\n        col *= S(0.0, 1.2, ao*ao );\n\n        \n    } else { col = black; }\n\n    fragColor = vec4( col, 1.0 );\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nsc3Dn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[131, 394, 417, 417, 481], [482, 482, 508, 508, 588], [589, 589, 629, 629, 721], [722, 722, 763, 763, 846], [847, 847, 887, 887, 936], [1634, 1634, 1664, 1664, 3546], [3548, 3548, 3594, 3594, 3947], [3950, 3959, 3993, 3993, 4023], [4024, 4024, 4054, 4054, 4159], [4160, 4160, 4192, 4192, 4272], [4273, 4273, 4336, 4336, 4478], [4481, 4490, 4513, 4513, 7671], [7674, 7687, 7725, 7725, 8062], [8064, 8064, 8089, 8089, 8280], [8282, 8282, 8340, 8340, 8918], [8920, 8920, 8971, 8971, 9519], [9522, 9522, 9565, 9565, 9935], [9937, 9937, 9973, 9973, 10091], [10093, 10093, 10129, 10129, 10408], [10410, 10410, 10469, 10469, 11334], [11336, 11336, 11391, 11391, 11613], [11615, 11615, 11671, 11671, 13487]]}
{"id": "Nsc3Rn", "name": "Hyperbolic checkerboard", "author": "kaihagseth", "description": "Checkerpattern in hyperbolic space", "tags": ["hyperbolicgeometry"], "likes": 2, "viewed": 159, "date": "1628945701", "time_retrieved": "2024-06-20T20:47:50.653321", "image_code": "float checker(in vec2 st)\n{\n  const float checkSize = 3.0;\n  vec2 tile = abs( mod(checkSize * st, 2.) - 1.);\n  tile = smoothstep( checkSize*length(fwidth(st)),0.,tile-.5);\n  tile = tile*2.-1.;\n  return tile.x*tile.y *.5 + .5;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Set coordinate system from -1.5 to 1.5 on y-axis\n    // dist 1.0 is where distance will go to infinite in hyperbolic space.\n    vec2 uv = 1. * ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    uv = rotate2d(iTime/5.) * uv;\n    \n    //Transfrom to hyperbolic space.\n    if (length(uv) > .5) {\n        fragColor = vec4(vec3(1),1.);\n        return;\n    }\n    uv /=  (1. / (length(uv) + .5) ) - 1.;\n    uv += vec2(iTime, 2.*sin(iTime/3.));\n    fragColor = vec4(vec3(checker(uv)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nsc3Rn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 27, 27, 227], [229, 229, 257, 257, 343], [346, 346, 403, 534, 897]]}
{"id": "Nsd3Dr", "name": "Matrixish", "author": "goodingc", "description": "matrix looking shader made using hashing", "tags": ["matrix"], "likes": 9, "viewed": 63, "date": "1629588915", "time_retrieved": "2024-06-20T20:47:50.653321", "image_code": "const uint GLYPH_SIZE = 5u;\nconst uint GLYPH_SEP = 2u;\n\n// https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x) {\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    uvec2 cellIndex = uvec2(fragCoord / 5.);\n    \n    uint colIndex = uint(float(cellIndex.x) / float(GLYPH_SIZE + GLYPH_SEP));\n    \n    \n    cellIndex.y += uint(iTime * (float(triple32(colIndex)) / float( 0xffffffffU ) * 10. + 5.));\n\n    vec3 col = vec3(0.);\n    \n    vec2 glyphCellIndex = mod(vec2(cellIndex), vec2(float(GLYPH_SIZE + GLYPH_SEP)));\n    \n    if(!(glyphCellIndex.x < float(GLYPH_SEP) || glyphCellIndex.y < float(GLYPH_SEP))) {\n        col = step(0.5, float(triple32(cellIndex.x + triple32(cellIndex.y))) / float( 0xffffffffU )) * vec3(0., 1., 0.);\n    }\n\n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nsd3Dr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[56, 100, 123, 123, 277], [280, 280, 337, 337, 971]]}
{"id": "Nsd3RN", "name": "This Is Not A Reflected Pipe 2", "author": "dr2", "description": "The non-pipe again - now inside a reflecting pentakis dodecahedron", "tags": ["reflection", "art", "symmetry", "magritte", "pentakis"], "likes": 15, "viewed": 196, "date": "1629280445", "time_retrieved": "2024-06-20T20:47:52.586833", "image_code": "// \"This Is Not A Reflected Pipe 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  From \"This Is Not A Pipe\": This is clearly not Magritte's masterpiece.\n  But is the 3D form less 'not a pipe' than the original?\n*/\n\n#define AA  0  // optional antialiasing\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 StdVuMat (float el, float az);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir;\nfloat dstFar, tCur, szFac;\nint idObj;\nconst int idFace = 1, idEdge = 2, idPipe = 3, idCoal = 4;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat PipeDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 rp;\n  float d;\n  dMin /= szFac;\n  p /= szFac;\n  p.x += 1.;\n  q = p;\n  d = SmoothMax (abs (PrCapsDf (q.xzy, 0.55, 0.25)) - 0.06, q.y - 0.5, 0.05);\n  q.y -= smoothstep (0.5, 2.5, q.x) - 0.5;\n  q.x -= 1.3;\n  rp = vec2 (0.1, 0.17) - vec2 (0.05, 0.06) * (q.x / 0.6 - 1.);\n  d = 0.5 * SmoothMin (d, max (SmoothMin (PrEllCylDf (q.yzx, rp, 1.2),\n     PrEllCylDf (q.yzx - vec3 (0., 0., 1.2), rp + 0.007, 0.007), 0.05),\n     0.03 - length (q.yz * vec2 (1.1, 0.35))), 0.12);\n  DMIN (idPipe);\n  q = p;\n  q.y -= 0.3;\n  d = PrCylDf (q.xzy, 0.5, 0.01);\n  DMIN (idCoal);\n  return szFac * dMin;\n}\n\nvec3 DodecSym (vec3 p)\n{\n  vec2 csD;\n  csD = sin (0.5 * atan (2.) + vec2 (0.5 * pi, 0.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), csD);\n  p.xy = Rot2D (p.xy, -0.1 * pi);\n  p.x = - abs (p.x);\n  for (int k = 0; k <= 3; k ++) {\n    p.zy = Rot2Cs (p.zy, vec2 (csD.x, - csD.y));\n    p.y = - abs (p.y);\n    p.zy = Rot2Cs (p.zy, csD);\n    if (k < 3) p.xy = Rot2Cs (p.xy, sin (-2. * pi / 5. + vec2 (0.5 * pi, 0.)));\n  }\n  p.xy = sin (mod (atan (p.x, p.y) + pi / 5., 2. * pi / 5.) - pi / 5. +\n     vec2 (0., 0.5 * pi)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a1, a2, s;\n  dMin = dstFar;\n  dMin = PipeDf (p, dMin);\n  q = DodecSym (p);\n  a1 = 0.5 * acos (-1. / sqrt (5.));\n  a2 = 0.5 * acos (- (80. + 9. * sqrt (5.)) / 109.);\n  s = abs (dot (q.yz, sin (a1 - a2 + vec2 (0., 0.5 * pi))) + 2.);\n  d = SmoothMax (s - 0.07, min (dot (q.yz, sin (a1 - pi + vec2 (0., 0.5 * pi))),\n     dot (q.xy, sin (pi / 5. + vec2 (0.5 * pi, 0.)))) - 0.04, 0.05);\n  DMIN (idEdge);\n  d = s - 0.05;\n  DMIN (idFace);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat PipeSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = PipeDf (ro + d * rd, dstFar);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.02;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn, q;\n  float dstObj, sh;\n  int nRef;\n  const int maxRef = 4;\n  szFac = 0.3;\n  bgCol = vec3 (0.3, 0.25, 0.25);\n  col = bgCol;\n  nRef = 0;\n  for (int k = VAR_ZERO; k <= maxRef; k ++) {\n    dstObj = ObjRay (ro, rd);\n    if (dstObj < dstFar && idObj == idFace) {\n      ro += dstObj * rd;\n      rd = reflect (rd, ObjNf (ro));\n      ro += 0.001 * rd;\n      nRef = k;\n    } else break;\n  }\n  if (dstObj < dstFar && idObj != idFace) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idEdge) {\n      col = vec3 (0.7, 0.7, 0.75) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.));\n    } else {\n      q = ro / szFac;\n      if (idObj == idPipe) {\n        q.xy -= vec2 (0.4);\n        q.xy = Rot2D (q.xy, -0.2 * pi);\n        if (q.x < -0.03) vn = VaryNf (16. * q, vn, 0.1);\n        col = mix ((q.x < 0.) ? mix (vec3 (0.6, 0.3, 0.), vec3 (0.3, 0.1, 0.), 0.5 * Fbm3 (4. * q)) :\n           vec3 (0.1), vec3 (0.7, 0.6, 0.), SmoothBump (-0.03, 0.03, 0.01, q.x));\n        sh = PipeSShadow (ro, ltDir);\n        col = col * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n           0.2 * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n      } else if (idObj == idCoal) {\n        col = mix (vec3 (0.8, 0., 0.) * (0.2 + 0.8 * smoothstep (0.1, 0.9, Fbm1 (0.5 * tCur))),\n           vec3 (0.1, 0., 0.), smoothstep (0.2, 0.7, Fbm2 (64. * q.xz)));\n      }\n    }\n    col = mix (bgCol, col, pow (0.9, 8. * float (nRef) / float (maxRef)));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    t = mod (0.01 * tCur, 1.);\n    t = (floor (32. * t) + smoothstep (0.8, 1., mod (32. * t, 1.))) / 32.;\n    az = pi * sin (2. * pi * t);\n    el = -0.1 * pi - 0.2 * pi * sin (4. * pi * t);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -1.8);\n  zmFac = 3.;\n  dstFar = 10.;\n  ltDir = vuMat * normalize (vec3 (-1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  }\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nsd3RN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[138, 1062, 1097, 1097, 1694], [1696, 1696, 1720, 1720, 2270], [2272, 2272, 2294, 2294, 2769], [2771, 2771, 2804, 2804, 2988], [2990, 2990, 3011, 3011, 3266], [3268, 3268, 3306, 3306, 3547], [3549, 3549, 3584, 3584, 5112], [5114, 5114, 5170, 5170, 6333], [6335, 6335, 6377, 6377, 6428], [6430, 6430, 6473, 6473, 6537], [6539, 6539, 6583, 6583, 6658], [6660, 6660, 6705, 6705, 6797], [6799, 6799, 6844, 6844, 6882], [6884, 6884, 6941, 6941, 7024], [7026, 7026, 7056, 7056, 7169], [7171, 7171, 7202, 7202, 7266], [7268, 7268, 7304, 7304, 7510], [7544, 7544, 7568, 7568, 7621], [7623, 7623, 7647, 7647, 7759], [7761, 7761, 7785, 7785, 7928], [7930, 7930, 7955, 7955, 8101], [8103, 8103, 8128, 8128, 8314], [8316, 8316, 8341, 8341, 8566], [8568, 8568, 8590, 8590, 8744], [8746, 8746, 8767, 8767, 8922], [8924, 8924, 8945, 8945, 9100], [9102, 9102, 9131, 9131, 9343], [9345, 9345, 9384, 9384, 9641]]}
{"id": "NsdGDN", "name": "Urban Smog", "author": "dr2", "description": "Where's the fresh air?", "tags": ["fog", "city", "glider", "flight", "skyscraper"], "likes": 24, "viewed": 327, "date": "1629879378", "time_retrieved": "2024-06-20T20:47:52.620141", "image_code": "// \"Urban Smog\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // (= 0/1) optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\nfloat BumpFbm3 (vec3 p);\nfloat Hashfv2 (vec2 p);\nfloat Hashfv3 (vec3 p);\nfloat Noisefv2 (vec2 p);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm1 (float p);\nfloat IFbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 flyerMat;\nvec3 flyerPos, qHit, sunDir, noiseDisp;\nvec2 cId, cIdT;\nfloat dstFar, tCur, szFacFl, flrHt, bShape, bWid, bWidU, bHt, bHtU, hiMid,\n   tWid, twHt, nFloor, fogAmp, fogTop;\nint idObj;\nconst int idBldgF = 1, idBldgC = 2, idTwr = 3, idTwrTop = 4, idRoad = 5, idSWalk = 6,\n   idFlyer = 7;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat FlyerDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, a;\n  dMin = dstFar / szFacFl;\n  q = flyerMat * (p - flyerPos) / szFacFl;\n  q.x = abs (q.x);\n  a = 0.22 * pi;\n  q.z -= -0.25;\n  qq = q;\n  qq.xy = Rot2D (vec2 (abs (qq.x), qq.y), - a);\n  d = abs (max (max (abs (dot (vec2 (qq.y, abs (dot (vec2 (qq.x, qq.z - 1.1),\n     sin (0.012 * pi + vec2 (0.5 * pi, 0.))))), sin (a + vec2 (0.5 * pi, 0.)))) -\n     0.002, 0.), max (dot (q.xz, sin (0.15 * pi + vec2 (0.5 * pi, 0.))) - 0.5, - q.z - 0.5))) - 0.02;\n  DMINQ (idFlyer);\n  return szFacFl * dMin;\n}\n\nfloat FlyerRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = FlyerDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 FlyerNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = FlyerDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvoid SetBldgParms ()\n{  //  (based on \"Urban Growth\")\n  bHt = (0.25 * Hashfv2 (13. * cId) + 0.05) * (1. + 0.15 / flrHt) + 0.1;\n  nFloor = floor (bHt * (0.6 + 0.4 * length (sin (0.125 * pi * cId))) / flrHt);\n  bHt = (nFloor + 0.3) * flrHt;\n  bWid = floor ((0.17 /*0.2*/ + Hashfv2 (11. * cId) * 0.1) / flrHt + 0.5) * flrHt;\n  bShape = Hashfv2 (17. * cId);\n  cIdT = mod (cId + 8., vec2 (16.)) - 8.;\n  hiMid = 0.75 * clamp (4. / max (length (cIdT), 1.), 0., 1.);\n  bWidU = floor (bWid * (0.5 + 0.3 * Hashfv2 (12. * cId)) / flrHt + 0.5) * flrHt;\n  bHt = (0.5 * Hashfv2 (13. * cId) + 0.05) * hiMid *\n     (1.5 + (bWid - 0.15) / flrHt) + 0.1;\n  bHtU = 0.25 * bHt + 0.75 * max (0., Hashfv2 (15. * cId) - 0.5) * hiMid + 0.05;\n  bHt = (floor (bHt / flrHt) + 0.2) * flrHt;\n  bHtU = floor (bHtU / flrHt) * flrHt;\n  if (bHtU > 0.) bHtU += 0.2 * flrHt;\n  if (cIdT == vec2 (0.)) {\n    bHt = max (bHt, 40.2 * flrHt);\n    bHtU = max (bHtU, 20.2 * flrHt);\n  }\n  tWid = ((bHtU > 0.) ? bWidU : bWid) - 0.0125;\n}\n\nfloat BldgDf (vec3 p, float dMin)\n{\n  vec3 pp, q;\n  vec2 s;\n  float d;\n  q = p;\n  d = q.y;\n  DMINQ (idRoad);\n  pp = p;\n  pp.xz = fract (pp.xz) - vec2 (0.5);\n  q = pp;\n  q.y -= 0.0015;\n  d = PrBoxDf (q, vec3 (0.35, 0.0015, 0.35));\n  DMINQ (idSWalk);\n  if (bHt > 0.) {\n    q.y -= bHt - 0.2 * flrHt + 0.0005;\n    if (bShape > 0.25) {\n      d = PrBoxDf (q, vec3 (bWid, bHt, bWid));\n      DMINQ (idBldgF);\n    } else {\n      d = PrCylDf (q.xzy, bWid, bHt);\n      DMINQ (idBldgC);\n    }\n    q.y -= bHt + bHtU - 0.2 * flrHt - 0.001;\n    if (bHtU > 0.) {\n      if (bShape > 0.5) {\n        d = max (PrBoxDf (q, vec3 (bWidU, bHtU, bWidU)),\n           - PrBoxDf (q - vec3 (0., bHtU, 0.), vec3 (tWid, 0.1 * flrHt, tWid)));\n        DMINQ (idBldgF);\n      } else {\n        d = max (PrCylDf (q.xzy, bWidU, bHtU),\n           - PrCylDf ((q - vec3 (0., bHtU, 0.)).xzy, tWid, 0.1 * flrHt));\n        DMINQ (idBldgC);\n      }\n    }\n    q.y -= bHtU - 0.2 * flrHt - 0.001;\n    if (bShape < 0.1) {\n      d = PrCapsDf (q.xzy, 0.4 * bWidU, 1.25 * flrHt);\n      DMINQ (idBldgC);\n    } else if (bShape > 0.7) {\n      d = PrBoxDf (q, vec3 (0.25 * bWidU, 1.25 * flrHt, 0.25 * bWidU));\n      DMINQ (idBldgF);\n    }\n    if (bHt + bHtU > 30. * flrHt) {\n      twHt = 0.1 * (bHt + bHtU);\n      q.y -= twHt;\n      d = PrCapsDf (q.xzy, 0.3 * flrHt, twHt);\n      DMINQ (((q.y > 0.9 * twHt) ? idTwrTop : idTwr));\n    }\n    if (cIdT.x == 0. && cIdT.y == 0.) {\n      q = pp;\n      q.y -= 2. * (bHt + bHtU) + 0.2 * flrHt;\n      d = PrCylDf (q.xzy, 0.3, flrHt);\n      DMINQ (idBldgC);\n    }\n  }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  return BldgDf (p, dstFar);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP, rdi, s;\n  float dHit, d;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  rdi = 1. / rd.xz;\n  cIdP = vec2 (-999.);\n  dHit = 0.01;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p.xz);\n    if (cId != cIdP) {\n      cIdP = cId;\n      SetBldgParms ();\n    }\n    d = ObjDf (p);\n    s = (cId + step (0., rd.xz) - p.xz) * rdi.xy;\n    dHit += min (d, 0.001 + max (0., min (s.x, s.y)));\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 BldgCol (vec3 vn)\n{\n  vec4 col4;\n  vec2 g;\n  float wFac, f;\n  wFac = 1.;\n  col4 = vec4 (HsvToRgb (vec3 (0.7 * Hashfv2 (19. * cId), 0.2,\n     0.4 + 0.2 * Hashfv2 (21. * cId))), 0.3);\n  if (abs (vn.y) < 0.05) {\n    f = mod (qHit.y / flrHt - 0.2, 1.) - 0.5;\n    wFac = 1. - (step (0., f) - 0.5) * step (abs (abs (f) - 0.24), 0.02) -\n       0.801 * step (abs (f), 0.22);\n    if (wFac < 0.2) {\n      f = (idObj == idBldgF) ? 1.5 * dot (qHit.xz, normalize (vn.zx)) :\n         length (qHit.xz) * (atan (qHit.z, qHit.x) + 0.5 * pi);\n      wFac = min (0.2 + 0.8 * floor (fract (f / flrHt + 0.25) *\n         (1. + Hashfv2 (51. * cId))), 1.);\n    }\n    col4.rgb *= wFac;\n  } else if (vn.y > 0.95) {\n    g = step (0.05, fract (qHit.xz * 70.));\n    col4.rgb *= mix (0.8, 1., g.x * g.y);\n  }\n  if (vn.y < 0.95 && wFac > 0.5)\n     col4.rgb *= (0.8 + 0.2 * Noisefv2 (512. * vec2 (qHit.x + qHit.z, qHit.y)));\n  if (wFac < 0.5) col4.a = -2.;\n  return col4;\n}\n\nvec4 ObjCol (vec3 ro, vec3 rd, vec3 vn)\n{\n  vec4 col4;\n  col4 = vec4 (0.);\n  if (idObj == idBldgF || idObj == idBldgC) {\n    col4 = BldgCol (vn);\n  } else if (idObj == idTwr) {\n    col4 = vec4 (0.3);\n  } else if (idObj == idTwrTop) {\n    col4 = vec4 (1., 0., 0., -2.);\n  } else if (idObj == idRoad) {\n    col4.rgb = vec3 (0.15, 0.15, 0.17);\n  } else if (idObj == idSWalk) {\n    col4.rgb = vec3 (0.2);\n  }\n  return col4;\n}\n\nfloat FogHt (vec2 p)\n{  // (based on \"Misty Terraces\")\n  mat2 qRot;\n  vec4 t4;\n  vec2 q, t, tw;\n  float wAmp, h;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  q = p + vec2 (0., 0.05 * tCur);\n  wAmp = 1.;\n  h = 0.;\n  tw = 0.05 * tCur * vec2 (1., -1.);\n  for (int j = 0; j < 5; j ++) {\n    q *= 2. * qRot;\n    t4 = abs (sin (2. * (q.xyxy + tw.xxyy) + 2. * Noisev2v4 (t4).xxyy - 1.));\n    t4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (t4.xz * t4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    wAmp *= 0.5;\n  }\n  return fogTop - 0.5 * h;\n}\n\nfloat FogDens (vec3 p)\n{\n  return fogAmp * (0.2 + 0.8 * smoothstep (0., 1., 1. - p.y / fogTop)) *\n     BumpFbm3 (0.03 * (p + noiseDisp)) * smoothstep (0., 1., FogHt (0.1 * p.xz) - p.y);\n}\n\nvec3 FogCol (vec3 col, vec3 ro, vec3 rd, float dHit)\n{\n  float s, ds, f, fn;\n  s = 1.;\n  ds = 1.;\n  fn = FogDens (ro + s * rd);\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    s += ds;\n    f = fn;\n    fn = FogDens (ro + (s + 0.5 * ds * Hashfv3 (16. * rd)) * rd);\n    col = mix (col, vec3 (0.95, 0.95, 1.) * (1. - clamp (f - fn, 0., 1.)),\n       min (f * (1. - smoothstep (0.5 * dHit, dHit, s)), 1.));\n    if (s > dHit) break;\n  }\n  return col;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 p, col, clCol;\n  float fd, f, ff;\n  rd.y = (rd.y + 0.1) / 1.1;\n  rd = normalize (rd);\n  col = vec3 (0.7);\n  if (rd.y > 0.) {\n    p = rd * (200. - ro.y) / max (rd.y, 0.0001);\n    p += ro + 4. * tCur;\n    p *= 0.01;\n    ff = Fbm2 (p.xz);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (p.xz + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix (vec3 (0.7, 0.7, 0.75), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd),\n       clCol, 0.1 + 0.9 * f * fd);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roo, rdr;\n  vec2 g, vf;\n  float dstObj, dstFlyer, s, f;\n  noiseDisp = 0.02 * tCur * vec3 (-1., 0., 1.) + 0.5 * sin (vec3 (0.2, 0.1, 0.3) * pi * tCur);\n  fogAmp = 1.;\n  fogTop = 4.;\n  roo = ro;\n  vf = vec2 (0.);\n  dstFlyer = FlyerRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < min (dstFlyer, dstFar)) {\n    ro += dstObj * rd;\n    cId = floor (ro.xz);\n    SetBldgParms ();\n    vn = ObjNf (ro);\n    col4 = ObjCol (ro, rd, vn);\n    col = col4.rgb;\n    if (col4.a >= 0.) {\n      if (idObj == idRoad) vf = vec2 (512., 1.);\n      else if (idObj == idBldgF || idObj == idBldgC) vf = vec2 (512., 0.5);\n      if (vf.x > 0.) vn = VaryNf (vf.x * qHit, vn, vf.y);\n      col = col * (0.3 + 0.3 * max (dot (vn.xz, - normalize (sunDir.xz)), 0.) +\n         0.2 * max (vn.y, 0.) + 0.7 * max (dot (vn, sunDir), 0.)) +\n         col4.a * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    } else if (col4.a == -2.) {\n      rdr = reflect (rd, vn);\n      g = Rot2D (rdr.xz, 5.1 * atan (20. + cId.y, 20. + cId.x));\n      f = step (1., 0.3 * ro.y + 4. * rdr.y -\n         0.1 * floor (5. * IFbm1 (0.3 * atan (g.y, g.x) + pi) + 0.05));\n      if (idObj == idBldgF || idObj == idBldgC) {\n        if (f == 1.) col = mix (0.7 * col, BgCol (ro, rdr), 0.5);\n        else col += 0.05;\n      }\n    }\n    if (col4.a == -2.) col *= 1. - 0.95 * smoothstep (0.4, 0.7, dstObj / dstFar);\n    col = mix (col, vec3 (0.3), smoothstep (0.6, 1., dstObj / dstFar));\n  } else if (dstFlyer < dstFar) {\n    ro += dstFlyer * rd;\n    vn = FlyerNf (ro);\n    col = vec3 (0.3, 1., 0.3);\n    col = mix (col, 1. - col, smoothstep (0.02, 0.04, abs (length (vec2 (qHit.xz -\n       vec2 (0.3, -0.1))) - 0.17)) * (1. - smoothstep (0.95, 0.97, qHit.z)));\n    col = col * (0.2 + 0.2 * max (- dot (vn, sunDir), 0.) + 0.8 * max (dot (vn, sunDir), 0.)) +\n       0.2 *  pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n  } else col = BgCol (ro, rd);\n  col = FogCol (col, roo, rd, min (dstFlyer, dstObj));\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{ \n  vec3 p;\n  float pLen, s, cCount;\n  pLen = 2.;\n  p.y = 2.5;\n  s = mod (t, 11.);\n  if (s < 7.) p.xz = (s < 4.) ? vec2 (0., s) : vec2 (s - 4., 4.);\n  else p.xz = (s < 9.) ? vec2 (3., 11. - s) : vec2 (12. - s, 2.);\n  cCount = floor (t / 11.);\n  if (mod (cCount, 2.) == 0.) p.x *= -1.;\n  else p.x -= 1.;\n  p.z += 2. * cCount;\n  p.xz *= pLen;\n  return p;\n}\n\nvoid FlyerPM (float s, float rl, float vu, out vec3 flPos, out mat3 flMat)\n{\n  vec3 fpF, fpB, vel, acc, va, ort, ca, sa;\n  float ds, rlFac, elFac, el, az;\n  ds = 0.12;\n  elFac = 0.7;\n  rlFac = 0.02;\n  fpF = 0.5 * (TrackPath (s + 2. * ds) + TrackPath (s + ds));\n  fpB = 0.5 * (TrackPath (s - 2. * ds) + TrackPath (s - ds));\n  vel = normalize (fpF - fpB);\n  acc = (fpF - 2. * TrackPath (s) + fpB) / (2.25 * ds * ds);\n  flPos = 0.5 * (fpF + fpB);\n  va = cross (acc, vel);\n  el = - elFac * asin (vel.y);\n  az = atan (vel.z, vel.x) - 0.5 * pi;\n  rl += rlFac * length (va) * sign (va.y);\n  ort = (vu >= 0.) ? vec3 (el, az, rl) : vec3 (- el, az + pi, - rl);\n  ca = cos (ort);\n  sa = sin (ort);\n  flMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat, flMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col, ori, ca, sa, vd;\n  vec2 canvas, uv, uvv;\n  float spd, el, az, zmFac, asp, sr, tPos;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 2400.) + 30. * floor (dateCur.w / 7200.);\n  el = 0.;\n  az = 0.;\n  spd = 0.3;\n  tPos = spd * tCur;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = clamp (0.45 * pi * mPtr.y, -0.18 * pi, 0.18 * pi);\n  }\n  zmFac = 2.5;\n  asp = canvas.x / canvas.y;\n  szFacFl = 0.04;\n  FlyerPM (tPos, 0.2 * pi * (Fbm1 (3.5 * tPos) - 0.5), 1., flyerPos, flyerMat);\n  flyerPos.y -= 0.2;\n  FlyerPM (tPos - 0.3, 0., 0., ro, flMat);\n  ro.xz += 0.01;\n  ori = vec3 (-0.02 * pi, 0.001 * pi, 0.1 * pi * (Fbm1 (1.5 * tPos) - 0.5));\n  ori.xy += vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.);\n  dstFar = 50.;\n  flrHt = 0.07;\n  sunDir = normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n    rd = normalize (vec3 (2. * tan (0.5 * atan (uvv.x / (asp * zmFac))) * asp, uvv.y / zmFac, 1.));\n    rd = (vuMat * rd) * flMat;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat PerBumpf (float p)\n{\n  return 0.5 * smoothstep (0., 0.5, abs (fract (p) - 0.5));\n}\n\nvec3 PerBumpv3 (vec3 p)\n{\n  return 0.5 * smoothstep (0., 0.5, abs (fract (p) - 0.5));\n}\n\nfloat BumpFbm3 (vec3 p)\n{\n  vec3 q;\n  float a, f;\n  a = 1.;\n  f = 0.;\n  q = p;\n  for (int j = 0; j < 4; j ++) {\n    p += PerBumpv3 (q + PerBumpv3 (q).yzx);\n    p *= 1.5;\n    f += a * (PerBumpf (p.z + PerBumpf (p.x + PerBumpf (p.y))));\n    q = 2. * q + 0.5;\n    a *= 0.75;\n  }\n  return f;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat IFbm1 (float p)\n{\n  float s, a;\n  p *= 5.;\n  s = 0.;\n  a = 10.;\n  for (int j = 0; j < 4; j ++) {\n    s += floor (a * Noiseff (p));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return 0.1 * s;\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsdGDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 1126, 1150, 1150, 1672], [1674, 1674, 1709, 1709, 1895], [1897, 1897, 1920, 1920, 2172], [2174, 2174, 2196, 2227, 3165], [3167, 3167, 3202, 3202, 4735], [4737, 4737, 4759, 4759, 4790], [4792, 4792, 4825, 4825, 5346], [5348, 5348, 5369, 5369, 5626], [5628, 5628, 5652, 5652, 6573], [6575, 6575, 6616, 6616, 6996], [6998, 6998, 7020, 7052, 7546], [7548, 7548, 7572, 7572, 7735], [7737, 7737, 7791, 7791, 8179], [8181, 8181, 8212, 8212, 8861], [8863, 8863, 8898, 8898, 10923], [10925, 10925, 10951, 10951, 11305], [11307, 11307, 11383, 11383, 12186], [12188, 12188, 12244, 12244, 13975], [13977, 13977, 14009, 14009, 14109], [14111, 14111, 14153, 14153, 14204], [14206, 14206, 14249, 14249, 14313], [14315, 14315, 14372, 14372, 14455], [14457, 14457, 14487, 14487, 14600], [14602, 14602, 14633, 14633, 14697], [14699, 14699, 14723, 14723, 14840], [14842, 14842, 14868, 14868, 14930], [14932, 14932, 14957, 14957, 15019], [15021, 15021, 15046, 15046, 15310], [15344, 15344, 15368, 15368, 15405], [15407, 15407, 15431, 15431, 15491], [15493, 15493, 15517, 15517, 15582], [15584, 15584, 15608, 15608, 15661], [15663, 15663, 15687, 15687, 15799], [15801, 15801, 15825, 15825, 15888], [15890, 15890, 15914, 15914, 16057], [16059, 16059, 16084, 16084, 16230], [16232, 16232, 16257, 16257, 16443], [16445, 16445, 16470, 16470, 16807], [16809, 16809, 16831, 16831, 16985], [16987, 16987, 17010, 17010, 17174], [17176, 17176, 17197, 17197, 17352], [17354, 17354, 17383, 17383, 17595], [17597, 17597, 17636, 17636, 17888]]}
{"id": "NsdGRX", "name": "Zany 90's Art", "author": "104", "description": "fashion", "tags": ["worms"], "likes": 11, "viewed": 102, "date": "1630355050", "time_retrieved": "2024-06-20T20:47:52.620141", "image_code": "const float SceneDurationSeconds = 3.;\nconst float Complexity = 12.;\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nmat2 rot2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat bayer8x8(vec2 uvScreenSpace) {\n  return texture(iChannel0, uvScreenSpace / 8.).r;\n}\n\nvoid mainImage(out vec4 o, vec2 C) {\n  vec2 uv = C / iResolution.x;\n\n  vec2 N = C / iResolution.xy-.5;\n  float SD = clamp(1.-2.*length(N),0.,1.); // radial distance\n  N = abs(N);\n  float SQ = 1.-2.*max(N.x,N.y); // rectangular distance\n  \n  uv += 100.;\n  vec4 h;\n  float sh = 1.0;\n  \n  float t = iTime * .5;\n\n  float scene = floor(iTime / SceneDurationSeconds) + 100.;\n  vec4 hscene = hash42(uv - uv + scene);\n  uv.x += scene;\n\n  for (float i = 1.0; i < Complexity; ++i) {\n    vec2 cell = floor(uv);\n    vec2 sq = fract(uv);\n    sh *= 1. - pow(max(sq.y, max(max(1. - sq.y, .5+.5*h.z), 1. - sq.x)), 4.);\n    h = hash42(cell);\n    uv.x += mix(3., 6., sin((hscene.w-.5)*t*.3)*.5+.5) * sin(h.z * 6.28) * mix(SD,SQ,.5+.5*h.x)/i;//(i + 1. + SD);\n    uv *= rot2D(h.w * 6.28 * hscene.z);\n    uv *= 1.-h.z*.1;\n  }\n  o = h * sqrt(sh);\n  vec4 rotated = o;\n  rotated.xy *= rot2D(t * 1.5 + hscene.x * 6.2);\n  rotated.yz *= rot2D(t * 2.62 + hscene.y * 6.2);\n  rotated = clamp(rotated, 0., 1.);\n  o *= 100.; // lol\n  o = clamp(mix(o, rotated, .3), 0., 1.);\n\n  float v = 1. - dot(N, N * 1.5);\n  o += (bayer8x8(C) - .5) * .15*v;\n  o = mix(o, step(.09, o), .7);\n  o *= v;\n}\n", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsdGRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[70, 70, 91, 91, 239], [241, 241, 261, 261, 313], [315, 315, 351, 351, 404], [406, 406, 442, 442, 1561]]}
{"id": "Nst3DH", "name": "looking glass test", "author": "z0rg", "description": "zefzef", "tags": ["zef"], "likes": 2, "viewed": 172, "date": "1629730325", "time_retrieved": "2024-06-20T20:47:53.738467", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define QUILT\n\n#if HW_PERFORMANCE==0\n#else\n//#define AA\n#endif\n\n#define BIASED_NORMAL \t1\n#define MAX_DIST\t\t150.\nconst float PI = radians(180.);\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l =abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}\n\nfloat _cucube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-0.01;\n    float x = max(l.y, l.z);\n    //l.xy *= r2d(iTime*.5+l.y);\nfloat y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    float cucube = max(min(min(x, y), z), cube);\n    return cucube;\n}\n\nfloat map(vec3 p)\n{\np.xy += vec2(sin(iTime), cos(iTime*.5))*.5;\np*=2.+sin(iTime*.5)*.2;\n    vec3 pouter = p;\n    float acc = 1000.;\n    for (int i = 0; i < 5; ++i)\n    {\n        pouter.xy *= r2d(-iTime*.2);\n        pouter.yz *= r2d(iTime*.25);\n        acc = min(acc, _cucube(pouter, vec3(.4+float(i+1)*.07)));\n    }\n\n    p.xy *= r2d(iTime);\n    p.xz *= r2d(iTime*.5);\n\treturn acc;//min(acc,_cube(p, vec3(.5)));\n}\n\n#define sat(a) clamp(a, 0., 1.)\nvec3 accCol;\nfloat rayMarch(in vec3 ro, in vec3 rd, in float offT)\n{\n  float t = offT;\n  for (int i = 0; i < 200; i++)\n  {\n      vec3 p = ro + rd * t;\n    float h = map(p);\n    t += h*.5;\n    if (h < 0.001 || t > MAX_DIST)\n        break;\n        accCol += vec3(sin(p.z*3.+iTime)*.5+.5,.3+.3*sin(p.x),.3)*(1.-sat(h/.25))*.2;\n  }\n  return t;\n}\n\n#define EPS  0.01\n\n#if BIASED_NORMAL\nvec3 calcNormal(vec3 pos)\n{\n    float\tref;\n    float\ttrans;\n    vec3\tabsorb;\n    vec3\tcol;\n    vec2\teps = vec2(EPS, 0);\n\tfloat d = map(pos);\n\treturn normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));\n}\n#else\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = EPS;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n#endif\n\nvec3 applyFog(vec3 rgb,float distance, vec3 fogColor)\n{\n    float fogAmount = 1.0 - exp( -distance*0.2 );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nvec3 Render(in vec3 ro, in vec3 rd)\n{\n    accCol = vec3(0.);\n    float t = rayMarch(ro, rd, 0.);\n    vec3\tcol = vec3(0);\n    \n    vec2 fakeuv = rd.xy-vec2(-1.,1.)*.5+vec2(sin(iTime), cos(iTime))*.1;\n    col = vec3(.34, .2, .3)*pow(length(fakeuv), 5.)*texture(iChannel1, vec2(atan(fakeuv.y, fakeuv.x)*.1, length(fakeuv.xy*.01)-.02*iTime)).xxx;\n    if(t < MAX_DIST)\n    {\n        vec3 p = ro + rd * t;\n        vec3 n = calcNormal(p);\n        vec3 lpos = vec3(5.);\n        vec3 ldir = lpos-p;\n        //col = texture(iChannel0, reflect(rd, n)).rgb;\n        col = vec3(.05)\n        +sat(dot(n, ldir))*vec3(.1,.2,.4)*(length(ldir)/4.)*.0\n        +pow(sat(dot(n, normalize(ldir+rd))),.2)*vec3(.1,.2,.3);\n        \n    }\n    col += accCol;\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    fragColor = vec4(Render(ro + vec3(0, 0, 9), rd), 1);\n}\n\n\n// Comment the original mainImage\n#ifndef QUILT\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 tot = vec3(0.0);\n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + PI * 0.3;\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5) - PI / 2.;\n        vec3 ro = 2. * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        tot += Render(ro ,rd);\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n\tfragColor = vec4( sqrt(tot), 1.0 );\n}\n#else // QUILT\n\n    #define QAA\t2                                     \n\nconst float\tsideAngle = radians(35.0);\nconst float\thorizontalAngle = radians(14.0);\nconst float\tcameraSize = 2.0;\nconst float\taspectRatio = 0.75;\nconst vec3  \tVROffset = vec3(0, 0, 9);\nfloat quiltColumns\t=\t8.;\nfloat quiltRows\t\t=\t6.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4\taccColor = vec4(0.);\n    for( int m = 0; m < QAA; m++ )\n    for( int n = 0; n < QAA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = (vec2(float(m), float(n)) / float(QAA) - 0.5) / iResolution.xy                                                                                 ;\n\t\t\n\t\tvec2\tcoord = (fragCoord / iResolution.xy  + o) * vec2(quiltColumns,quiltRows);\n\t\tvec2\tfract = fract(coord);\n\t\tvec2\tfloor = floor(coord);\n\t\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\t\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\t\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\t\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\t\n\t\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\t\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize/aspectRatio,0);\n\t\t\n\t\tvec3\tdir = normalize(screenPos - camPos);\n\t\tvec4\tcolor;\n\t\tmainVR(color, fragCoord, camPos - VROffset, dir);\n\t\taccColor += clamp(color, 0.0, 1.0);\n\t}\n\tfragColor = accColor / float(QAA*QAA);\n}\n#endif\n\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "XsfGzn", "previewfilepath": "/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0 AND proprietary-license", "thumbnail": "https://www.shadertoy.com/media/shaders/Nst3DH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 258, 277, 277, 335], [337, 337, 366, 366, 426], [428, 428, 459, 459, 736], [738, 738, 757, 757, 1150], [1197, 1197, 1252, 1252, 1525], [2082, 2082, 2137, 2137, 2233], [2236, 2236, 2273, 2273, 2985], [2987, 2987, 3029, 3029, 3193], [3195, 3195, 3273, 3273, 3332]]}
{"id": "Nst3R4", "name": "Persian rug patterns", "author": "jarble", "description": "This shader generates random patterns that resemble Persian rugs.", "tags": ["fractal", "rug"], "likes": 6, "viewed": 180, "date": "1629257212", "time_retrieved": "2024-06-20T20:47:54.162747", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.45,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 3.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float t2 = floor((iTime)/10.0+uv.x);\n    vec3 random1 = hash31(t2)*10.;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    vec3 random3 = (hash31(2.+t2)-vec3(.5))/4.;\n    vec3 random4 = (hash31(3.+t2)-vec3(.5))/4.;\n    \n    float offset = .16+random4.z*.04;\n    float scale2 = 1.16+.04*random4.y;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            uv = triangle_wave(uv+offset,scale)+triangle_wave(uv.yx,scale);\n            //uv.x *= -1.0;\n\n            uv = triangle_wave((uv+random1.x)/(random4.y*.0+1.),scale+random3.z);\n            //uv.x /= -1.0;\n            \n            uv = triangle_wave(uv+random1.y,scale+random3.y);\n            //uv.x *= -1.0;\n            \n            uv = triangle_wave((uv+random1.z)*(random4.y*.0+1.),scale+random3.z);\n            uv.x /= -1.0;\n            \n            //uv.x *= -1.0;\n            //uv = triangle_wave(uv+c1.y,scale);\n            scale /= scale2+col.x;\n            offset *= scale2/(1.+random4.x);\n            \n            //uv = uv.yx;\n            //uv = uv.yx;\n            scale2 += col.x/3.;\n\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nst3R4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[278, 388, 410, 456, 589], [591, 591, 630, 630, 675], [677, 677, 734, 734, 2158]]}
{"id": "Nt23RD", "name": "Pythagorean Triples", "author": "iq", "description": "Pythagorean triples. All points in the plane which distance to the origin is an integer are green. In this render every pixel represents a 8x8 grid of integers.", "tags": ["2d", "math", "maths", "pythagorean", "triplets"], "likes": 25, "viewed": 465, "date": "1630181305", "time_retrieved": "2024-06-20T20:47:54.841671", "image_code": "// Created by inigo quilez - iq/2021\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n\n// Pythagorean triples - https://en.wikipedia.org/wiki/Pythagorean_triple\n//\n// All points in the plane which distance to the origin is\n// an integer are green. In this render every pixel represents\n// a 8x8 grid of integers. You can change that in line 15.\n\n\n#define INTS_PER_PIXEL 8\n#define USE_EXACT_SQRT 0\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 6\n#endif\n\n#if USE_EXACT_SQRT==1\nuint intsqrt( uint s );\n#endif\n\nvec3 render( in vec2 px )\n{\n    float s = exp2( -(1.0+cos(6.283185*iTime/20.0)) );\n    uvec2 p = uvec2( abs(floor((px-iResolution.xy*0.5)*s)) );\n\n    const uint S = uint(INTS_PER_PIXEL);\n    \n    float f = 0.0;\n    for( uint j=0u; j<S; j++ )\n    for( uint i=0u; i<S; i++ )\n    {\n        uvec2 q = S*p + uvec2(i,j);\n        uint h2 = q.x*q.x + q.y*q.y;\n        \n        #if USE_EXACT_SQRT==0\n        uint h = uint(round(sqrt(float(h2))));\n        #else\n        uint h = intsqrt(h2);\n        #endif\n        \n        if( h*h==h2 ) { f = 1.0; break; }\n    }\n    \n    return vec3(0.5*f,f,0.0);\n}\n\n\n// --------------------------------------\n// Integer square root\n// https://en.wikipedia.org/wiki/Integer_square_root\n// --------------------------------------\n#if USE_EXACT_SQRT==1\nuint intsqrt( uint s )\n{\n\tuint x0 = s >> 1;\n    if( x0==0u ) return s;\n    uint x1 = ( x0 + s / x0 ) >> 1;\n    while( x1 < x0 )\n    {\n        x0 = x1;\n        x1 = ( x0 + s / x0 ) >> 1;\n    }\n    return x0;\n}\n#endif\n\n\n\n#if AA>1\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint  seed = 1;\nvoid srand(int s ) { seed = s; }\nint  rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n\n// --------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n// --------------------------------------\nint hash( int n )\n{\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n#endif\n\n// --------------------------------------\n// main\n// --------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if AA>1\n    seed = hash( int(fragCoord.y)*3840 + int(fragCoord.x) );\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = 2.0*vec2(float(m)+frand(),float(n)+frand())/float(AA)-1.0;\n        col += render(fragCoord+o);\n    }\n    col /= float(AA*AA);\n#else\n    vec3 col = render(fragCoord);\n#endif\n    col = sqrt(col);\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "proprietary-license", "thumbnail": "https://www.shadertoy.com/media/shaders/Nt23RD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[597, 1024, 1051, 1051, 1614], [2581, 2673, 2730, 2730, 3137]]}
{"id": "Nt2SR3", "name": "an atmosphere scattering", "author": "yunhai", "description": "a single scattering demo,\nand this serials helped me a lot:\nhttps://www.alanzucconi.com/2017/10/10/atmospheric-scattering-1/\nmaybe I should draw a better sun next time :)", "tags": ["atmosphere"], "likes": 4, "viewed": 57, "date": "1628227609", "time_retrieved": "2024-06-20T20:47:54.841671", "image_code": "#define TOTALSAMPLES 5.\n#define iR iResolution.xy\n#define PI 3.14159265\n//#define SUN3D\nconst vec3 lmd=vec3(680,550,440);\nconst vec3 invplmd=1./pow(lmd,vec3(4.));\nconst float P=1e6*550.1;//scattering magic coeff\nconst vec3 PC=vec3(0,0,0);//planet center\nconst float R=7000.;//planet radius\nconst float H=60.;//atmosphere thick\nconst float IS=0.9;//sun intensity\nfloat iS(vec3 ro,vec3 rd,vec4 s)\n{\n    vec3 co=ro-s.xyz;\n    float b=2.*dot(co,rd),c=dot(co,co)-s.w*s.w;\n    float delta=b*b-4.*c;\n    if(delta<0.)\n        return -1.;\n    if(c<0.)\n        return (-b+sqrt(delta))/2.;\n    if(b>0.)\n        return -1.;\n    return (-b-sqrt(delta))/2.;\n}\nfloat density(float h)\n{\n    return exp(-h/H);\n}\n//Rayleigh's phase function\nfloat pf(float cosTheta)\n{\n    return (1.+cosTheta*cosTheta);\n}\n//opticalDepth\nfloat od(vec3 from,vec3 to,float steps)\n{\n    vec3 dir=to-from;\n    float l=length(dir),ds=l/steps;dir/=l;\n    float sum=0.;\n    vec3 p=from+dir*(.5)*ds;//sample seg middle point\n    for(float i=0.;i<steps;i+=1.)\n    {\n        sum+=density(length(p-PC)-R)*ds;\n        p+=dir*ds;\n    }\n    return sum;\n}\nvoid mainImage( out vec4 O, in vec2 C)\n{\n    vec2 uv=(C-.5*iR)*2./iR.y;uv.y+=.8;\n    vec3 ro=PC+vec3(0,R+1.,0),\n         rd=normalize(vec3(uv,1)),\n         sp=vec3(0,0,100000);//sun Position\n         //sd=normalize(vec3(0,0,1));//sunDirection\n    float t=mod(iTime*.3,1.3)-.1,sunH=t;\n    mat2 rot=mat2(cos(t),sin(t),-sin(t),cos(t));sp.yz*=rot;\n    vec3 sum=vec3(0);\n    vec4 e1=vec4(PC,R),e2=e1;e2.w+=H;\n    float d=iS(ro,rd,e2),\n          tsp=TOTALSAMPLES,\n          ds=d/tsp;\n    \n    for(float i=0.;i<tsp;i+=1.)\n    {\n        float time=ds*(i+.5);\n        vec3 p=ro+rd*time;\n        vec3 sd=normalize(sp-p);\n        //oc\n        if(iS(p,sd,e1)>0.||iS(p,-rd,e1)<time)\n            continue;\n\n        vec3 transmittance=exp(-P*invplmd*(od(ro,p,tsp)+od(p,p+iS(p,sd,e2)*sd,tsp)));\n        vec3 scat=P*invplmd*density(length(p-PC)-R)*pf(dot(rd,sd));\n        sum+=scat*transmittance*ds;\n    }\n    O.rgb =sum*IS;\n    \n    //sun\n    #ifdef SUN3D\n    d=iS(ro,rd,vec4(sp*100.,300000.));\n    vec3 sd=normalize(sp-ro);\n    if(d>0.)\n        O.rgb=mix(vec3(1.,.2,.01),vec3(.89,.34,.0)*1.5,pow((1.-dot(rd,sd))*200.,1.3));\n    #endif\n    \n    float sunDist=length(uv-vec2(0,sunH)),sunR=.08;\n    O.rgb=mix(O.rgb,vec3(1.+pow((sunDist+.1),2.)*4.2/sunR,.5,.1)*exp(sunH*.5),smoothstep(1.2*sunR,.01,sunDist));\n    \n    //land\n    O.rgb=mix(vec3(.3,.8,.2)*.5*max((1.04-dot(vec3(0,0,1),normalize(sp-PC)))*2.,0.)*(-uv.y*2.+.5),O.rgb,\n          smoothstep(.0,.1,uv.y));\n    \n    O.rgb=pow(O.rgb,vec3(0.4545));\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2SR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[187, 362, 396, 396, 645], [646, 646, 670, 670, 694], [695, 723, 749, 749, 786], [787, 802, 843, 843, 1104], [1105, 1105, 1145, 1145, 2593]]}
{"id": "Nt2Szm", "name": "Bright cubes", "author": "morimea", "description": "Simple scene. I hope it does not look too bad.", "tags": ["3d", "voxels", "art"], "likes": 12, "viewed": 268, "date": "1628616911", "time_retrieved": "2024-06-20T20:47:58.023764", "image_code": "\n// Created by Danil (2021+) https://twitter.com/AruGL\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// self https://www.shadertoy.com/view/Nt2Szm\n\n\n#define AA 2\n\n// does not speedup compiling but slowdown performance, comp time 2 sec without this\n//#define iZero min(iFrame,0)\n\n#define iZero 0\n\n#define PI 3.141592653589793\n#define TAU (2.*PI)\nmat2 MD(float a){float s = sin( a );float c = cos( a );return mat2(vec2(c, -s), vec2(s, c));}\n\nconst vec3 white=vec3(0xf1,0xe8,0xf2)/float(0xff);\nconst vec3 blue=vec3(0x0a,0x1f,0x73)/float(0xff);\n\nconst vec2 voxbox = vec2(6.5,9.5);\nconst float voxmax_h = 1.918;\nconst vec3 voxposl = vec3(0.,-3.5,-8.5);\n\n\n// --------Common moved to have al in one shader\n\nfloat fresnel(vec3 d, vec3 n)\n{\n    float a = clamp(1.0-dot(n,-d), 0.0, 1.0);\n    return clamp(exp((5.0*a)-5.0), 0.0, 1.0);\n}\n\n// ANGLE bug https://bugs.chromium.org/p/chromium/issues/detail?id=1238461\n// ANGLE compile time slowdown 20x times because of single call of (0.5 * t * t * t) below\n\nfloat easeInOutCubic(float t) {\n    if ((t *= 2.0) < 1.0) {\n        //return 0.5 * t * t * t; // uncomment for bug\n        return 0.5 * pow(abs(t),3.); //fix\n    } else {\n        return 0.5 * ((t -= 2.0) * t * t + 2.0);\n    }\n}\n\nuint uhash(uint x) {\n    x = ((x >> uint(16)) ^ x) * uint(73244475);\n    x = ((x >> uint(16)) ^ x) * uint(73244475);\n    x = (x >> uint(16)) ^ x;\n    return x;\n}\n\nfloat rand_from_seed(inout uint seed) {\n    int k;\n    int s = int(seed);\n    if (s == 0)\n    s = 305420679;\n    k = s / 127773;\n    s = 16807 * (s - k * 127773) - 2836 * k;\n    if (s < 0)\n        s += 2147483647;\n    seed = uint(s);\n    return float(seed % uint(65536)) / 65535.0;\n}\n\nfloat hash11(float v){\n    uint hs = uhash(floatBitsToUint(v * 12.9898));\n    return rand_from_seed(hs);\n}\n\nfloat hash21(vec2 v){\n    uint hs = uhash(floatBitsToUint(v.y + v.x * 12.9898));\n    return rand_from_seed(hs);\n}\n\nfloat hash31(vec3 v){\n    uint hs = uhash(floatBitsToUint(v.y + v.x * 12.9898 + v.z * 25.831));\n    return rand_from_seed(hs);\n}\n\nvec3 hash33(vec3 v){\n    uint hs = uhash(floatBitsToUint(v.y + v.x * 12.9898 + v.z * 25.831));\n    float a = rand_from_seed(hs);\n    float b = rand_from_seed(hs);\n    float c = rand_from_seed(hs);\n    return vec3(a,b,c);\n}\n\nfloat get_rand(vec2 pos,vec2 box){\n    float tps = hash21(pos);\n    tps = tps*0.1+0.9*smoothstep(0.2,.9,tps);\n    tps *= min((abs(pos.x-box.x-3.)/box.x)*((pos.y+3.)/(box.y*2.)),1.);\n    return 0.05+0.95*tps;\n}\n\n\n// https://www.shadertoy.com/view/XsX3zB\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;r.z = fract(512.0*j);j *= .125;r.x = fract(512.0*j);j *= .125;r.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t vec4 w, d;\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t w = max(0.6 - w, 0.0);\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t return dot(d, vec4(52.0));\n}\n\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\n#define MAX_DIST 1000.\n#define MIN_DIST .001\n\n// ffix float precision fix, cy height shift animation, stimer shift timer 0-1\n// ffix also used in reflections to control voxel size to remove white borders on glow reflections\nbool VoxelsIntersect(int steps, vec2 box, float max_h, float ffix, in vec3 ro, in vec3 rd,\n                        out vec3 normal , out float tnew, out vec2 idx, inout float cy, float stimer) {\n    vec2 pos = floor(ro.xz);\n    \n    vec3 rdi = 1./rd;\n\n    vec3 rda = abs(rdi);\n    vec3 rds = sign(rd);\n    vec2 dis = (pos - ro.xz + .5 + rds.xz*.5) * rdi.xz;\n    \n    vec3 roi = rdi*(ro-vec3(.5,0.,.5));\n\n    vec2 mm = vec2(0.0);\n    for( int i=0; i<steps; i++ ) {    \n        float tps = get_rand(pos, box);\n        float tm=1.;\n        if (any(greaterThan(pos,box*2.))||any(lessThan(pos,vec2(1.))))tm=0.;\n        cy = mix(-(tm*max_h*tps-1.)+max_h*2.-2.,tm*max_h*tps-1.,stimer);\n        vec3 n = roi - rdi * vec3(pos.x, cy, pos.y);\n        vec3 k = rda*vec3(.5, -0.00099+tm*max_h*tps, .5);\n\n        vec3 t1 = -n - k;\n        vec3 t2 = -n + k;\n\n        float tN = max( max( t1.x, t1.y ), t1.z )-ffix;\n        float tF = min( min( t2.x, t2.y ), t2.z );\n\n        if ( tN < tF && tN>MIN_DIST && tN<MAX_DIST ) {\n            normal = -rds*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            tnew = tN;\n            idx = pos;\n            return true;\n        }\n\n    mm = step( dis.xy, dis.yx ); \n    dis += mm*rda.xz;\n    pos += mm*rds.xz;\n    }\n\n    return false;\n}\n\n\n// using iq's intersectors: http://iquilezles.org/www/articles/intersectors/intersectors.htm\n\nbool SphereIntersectInv(vec3 SpPos, float SpRad, vec3 ro, vec3 rd, out float t, out vec3 norm) {\n    ro -= SpPos;\n\n    float A = dot(rd, rd);\n    float B = 2.0*dot(ro, rd);\n    float C = dot(ro, ro)-SpRad*SpRad;\n    float D = B*B-4.0*A*C;\n    t=-1.;\n    norm=vec3(0.,1.,0.);\n    if (D < 0.0) return false;\n\n    D = sqrt(D);\n    A *= 2.0;\n    float t1 = (-B+D)/A;\n    float t2 = (-B-D)/A;\n    if (t1 < 0.0) t1 = t2;\n    if (t2 < 0.0) t2 = t1;\n    t1 = max(t1, t2);\n    //t1 = min(t1, t2);\n    if (t1 < 0.0) return false;\n    norm = ro+t1*rd;\n    t = t1;\n    norm = normalize(norm);\n    return true;\n}\n// --- Common end\n\n\nvec2 lUV(vec3 p) {\n    float x = dot(p, vec3(-1,0.,0.));\n    float y = dot(p, vec3(0.,1.,0.));\n    float td = dot(p, vec3(0.,0.,1.));\n    td += 0.0001 * (1.0 - abs(sign(td)));\n    float d = -1. / td;\n    float u = d * x + 0.5;\n    float v = d * y + 0.5;\n    return vec2(u, v);\n}\n\nvec3 color_spiral(vec3 p, float d) {\n    p.z+=-1.;\n    vec2 uv=((lUV(p))-0.5)*.75;\n    uv *=MD(-0.5/max(length(uv),0.0001));\n    float td=(1.-smoothstep(-2.0,-.815,p.z))*(smoothstep(-2.,-1.95,p.z))*(1.-smoothstep(-1.5,2.35,length(uv)));\n    float c = d / max(abs(5.0/uv.x),0.0001);\n    return clamp(.85-c,0.,1.)*((blue+vec3(0.4,0.8,1.5)))*td;\n}\n\nvec3 blurred_background(vec3 rd)\n{\n    return vec3(0.7, 0.8, 1.6)*max((rd.y*0.49 + 0.51),0.001)*0.8+color_spiral(-rd,10.)*1.5;\n}\n\nvec3 background_sky(vec3 rd)\n{\n    return vec3(0.7, 0.8, 1.4)*max((rd.y*0.6 + 0.3),0.001)+color_spiral(-rd,15.)*2.;\n}\n\n\n#define OBJ_SKY 0\n#define OBJ_FLOOR 1\n#define OBJ_REFLOOR 2\n#define OBJ_BOX 3\n#define OBJ_BALL 4\n\nstruct HitInfo {\n    float t;\n    vec3 norm;\n    vec4 color;\n    int obj_type;\n    vec2 exdata;\n};\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nfloat atimer=1.; //global timer 0-1\n\nconst vec3 anim_camera[]=vec3[](\n    vec3(-1.,5.,-3.),vec3(2.,3.5,-1.5),\n    vec3(3.,3.05,11.5),vec3(0.5,4.5,18.5),vec3(6.5,3.5,19.5),\n    vec3(6.5,5.15,20.5),vec3(0.5,4.5,10.5),vec3(0.5,4.5,-2.5),\n    vec3(-2.5,8.5,-2.5)\n);\n\nconst float timers[]=float[](\n    4.0,6.0,11.,\n    16.,21.,26.,\n    31.,36.5,40.,\n    42.\n);\n\nvec3 camera_anim(float gt){\n    vec3 dx[3];\n    for(int a=0;a<3+iZero;a++){\n        float timer=mod(gt+1.25*float(a-1),timers[timers.length()-1]);\n        timer+=timers[0];\n        dx[a]=anim_camera[0];\n        for(int i=1;i<anim_camera.length()+iZero;i++){\n            float t=smoothstep(timers[i-1],timers[i],timer);\n            dx[a]=mix(dx[a],anim_camera[i],t);\n        }\n        float t=smoothstep(timers[timers.length()-1],timers[timers.length()-1]+timers[0],timer);\n        dx[a]=mix(dx[a],anim_camera[0],t);\n    }\n    float timer=mod(gt,timers[timers.length()-1]);\n    timer+=timers[0];\n    atimer=1.-smoothstep(timers[4]+4.,timers[4]+6.5,timer);\n    atimer=max(atimer,smoothstep(timers[8]+0.,timers[9]+1.5,timer));\n    return mix(dx[1],mix(dx[0],dx[2],0.5),0.5);\n}\n\nvec2 get_look(float gt){\n    float timer=mod(gt,timers[timers.length()-1]);\n    timer=smoothstep(0.,timers[timers.length()-1],timer);\n    float et=easeInOutCubic(timer);\n    float ot=((1.-smoothstep(0.,0.5,timer))-1.5*smoothstep(0.5,0.6,timer)*(1.-smoothstep(0.75,0.9,timer)))+smoothstep(0.9,1.,timer);\n    timer=(timer*(1.-et))-0.5;\n    return vec2(0.2-3.*sin((0.5+timer)*PI),-0.25*sin(0.5*ot*PI));\n}\n\nRay SetCamera(vec2 uv, vec3 ro, vec2 m)\n{\n    if(iMouse.z>0.)\n        m+=(iMouse.xy/iResolution.y-0.5*iResolution.xy/iResolution.y)*2.5;\n    m.y = -m.y;\n    float fov=70.;\n    float aspect = iResolution.x / iResolution.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    vec3 rd = normalize(vec3(uv*screenSize, 1./aspect));\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n\n    rd = (rotY * rotX) * rd;\n    return Ray(ro,rd);\n}\n\nbool boxAABB(in vec3 dims, vec3 ro, vec3 rd) {\n    vec3 n = ro / rd;\n    vec3 k = dims / abs(rd);\n    vec3 t1 = -k - n, t2 = k - n;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    return tN < tF && tF > 0.0;\n}\n\nvoid VoxelsIntersectMin_ref(vec2 box, float max_h , vec3 posl,vec3 ro, vec3 rd,\n                            inout HitInfo hit, float rfnl, float sky_pow, float col_pow, inout float refc) {\n    float tnew;\n    vec2 idx;\n    vec3 normnew;\n    float cy;\n    \n    if(VoxelsIntersect(6, box, max_h, -0.001, ro, rd, normnew, tnew, idx, cy, atimer)){\n        bool in_box=(idx.x<=box.x*2.)&&(idx.y<=box.y*2.);\n        in_box=in_box&&all(greaterThan(idx,vec2(0.)));\n        float fnl = fresnel(rd,normnew);\n        if(in_box){\n            float alb = hash21(idx+1.);\n            float trnd = get_rand(idx+20., box*0.7);\n            float emi = step(0.65,trnd-0.75*trnd*hash21(idx+5.));\n            alb*=0.25;\n            alb *= rfnl * (1.-fnl) \n                * (.8 + .2 * dot(normnew, vec3(-.25916,.8639,-.4319)));\n            \n            emi *= col_pow;\n            vec3 tuv = fract(ro+tnew*rd) * 2.0 - 1.0;\n            float vig=max(tuv.x*tuv.x, tuv.z*tuv.z)*0.5;\n            vec3 tc = white+blue;\n            tc=mix(tc,tc*.65,vig);\n            vec3 col=max(alb*white,emi*1.175*tc);\n            hit.color.rgb += col;\n            hit.color.a += emi*0.25;\n            refc*=0.12;\n        }\n        else {\n            vec3 bg=clamp(vec3(.5,.8,1)*0.+1.*blurred_background(rd),0.,1.);\n            hit.color.rgb  += sky_pow*clamp(bg * (rfnl*(5.-2.5*rd.y)),vec3(0.),bg);\n        }\n    }\n    else {\n        vec3 bg=clamp(vec3(.5,.8,1)*0.+1.*blurred_background(rd),0.,1.);\n        hit.color.rgb += sky_pow*clamp(bg * (rfnl*(5.-2.5*rd.y)),vec3(0.),bg);\n    }\n}\n\nvoid VoxelsIntersectMin(vec2 box, float max_h , vec3 posl,vec3 ro, vec3 rd,\n                        inout bool result, inout HitInfo hit, vec3 sky) {\n    float tnew;\n    vec2 idx;\n    vec3 normnew;\n    \n    posl.xz+=1.;\n    ro+=posl;\n    \n    if(!boxAABB(vec3(box.x,max_h,box.y), ro+vec3(-1.,-max_h+1.,-1.), rd))return;\n    ro.xz+=box;\n    float vros = length(ro.xz-(box+1.));\n    if(VoxelsIntersect(min(int(vros*1.5)+18,40), box, max_h, 0.0001, ro, rd, normnew, tnew, idx, hit.exdata.y, atimer)){\n        bool in_box=(idx.x<=box.x*2.)&&(idx.y<=box.y*2.);\n        in_box=in_box&&all(greaterThan(idx,vec2(0.)));\n        if (in_box&&(tnew>0.)) {\n            float tmx = 0.;\n            if((hit.obj_type==OBJ_BALL)&&(tnew>hit.t))tmx=clamp(dot(hit.color.rgb,vec3(1.))*0.25,0.,1.);\n            hit.color = vec4(0.,0.,0.,0.);\n            float fnl = fresnel(rd,normnew);\n            \n            float alb = hash21(idx+1.);\n            float trnd = get_rand(idx+20., box*0.7);\n            float emi = step(0.65,trnd-0.75*trnd*hash21(idx+5.));\n            vec3 col = vec3(0.);\n            alb*=0.1*alb;\n\n            alb *= (1.-fnl) \n                * (.8 + .2 * dot(normnew, vec3(-.25916,.8639,-.4319)));\n            \n            vec3 tuv = fract(ro+tnew*rd) * 2.0 - 1.0;\n            float vig=max(tuv.x*tuv.x, tuv.z*tuv.z)*0.5;\n            vec3 tc = white+blue;\n            tc=mix(tc,tc*.85,vig);\n            col=max(alb*white,emi*2.35*(tc));\n            vec3 skyo = background_sky(rd);\n            hit.color.rgb += mix(col,skyo,fnl*fnl);\n            hit.color.a += emi;\n\n            hit.obj_type = OBJ_FLOOR;\n            result = true;\n            hit.t = tnew;\n            hit.norm = normnew;\n            \n            float vrds = length(tnew * rd.xz);\n            if((emi<0.5)&&(fnl > .001)){\n                hit.obj_type = OBJ_REFLOOR;\n                hit.norm = normnew;\n                hit.exdata.x = fnl;\n            }\n            \n            hit.color.rgb = mix(hit.color.rgb,sky,smoothstep(24.,27.5,vrds));\n            hit.color.rgb = mix(hit.color.rgb,sky,tmx);\n        }\n    }\n}\n\n\nfloat glow_sphere(vec3 rd, vec3 n){\n    float a = pow(0.7122 + max(dot(n, reflect(rd,n)),0.), 10.85);\n    float b = pow(0.7122 + max(1.-dot(n, reflect(rd,n)),0.), 3.85);\n    \n    return clamp(min(a,b),0.,10.);\n}\n\nvoid SphereIntersectMin(vec3 SpPos, float SpRad, vec3 ro, vec3 rd, inout bool result, inout HitInfo hit, bool refl, bool sph2, float ot) {\n    float tnew;\n    vec3 normnew;\n    if (SphereIntersectInv(SpPos, SpRad, ro, rd, tnew, normnew)) {\n        if(!refl){\n        if (tnew < hit.t||sph2&&(tnew < ot)) \n        {\n            hit.t = min(tnew,hit.t);\n            hit.norm = normnew;\n            if(sph2){\n                vec3 spotLightOrigin \t= (SpPos - vec3(0.,0.,1.)*22.9);\n                vec3 Ln = normalize(spotLightOrigin-(ro+rd*tnew));\n                hit.color.rgb += color_spiral(Ln,20.)*4.;\n            }\n            else\n            hit.color.rgb += glow_sphere(rd,-normnew)*(sqrt(blue))*3.;\n            hit.obj_type = OBJ_BALL;\n            result = true;\n        }\n        }else{\n            if(sph2)\n            {\n                vec3 spotLightOrigin \t= (SpPos - vec3(0.,0.,1.)*19.9);\n                vec3 Ln = normalize(spotLightOrigin-(ro+rd*tnew));\n                hit.color.a += color_spiral(Ln,10.).b*.85;\n            }\n            else\n            hit.color.a = glow_sphere(rd,-normnew);\n            hit.obj_type = OBJ_BALL;\n            result = true;\n        }\n    }\n}\n\n\nHitInfo render(Ray r, inout vec3 sky)\n{\n    HitInfo hit;\n    hit.t = MAX_DIST;\n    hit.obj_type = OBJ_SKY;\n    hit.color = vec4(sky,0.);\n    hit.norm = vec3(0.,1.,0.);\n    hit.exdata = vec2(0.);\n    \n    vec4 col = vec4(0.);\n\n    vec3 ro = r.pos; vec3 rd = r.dir;\n    \n    bool result = false;\n    float angle=0.;\n\n    vec3 spherex=vec3(0.,8.15,8.5+voxbox.y+15.);\n    vec3 spherex2=vec3(0.,8.15,8.5+voxbox.y+15.-22.25);\n    \n    rd += 0.0001 * (1.0 - abs(sign(rd)));\n    \n    float ot=hit.t;\n    SphereIntersectMin(spherex, 13.5, ro, rd, result, hit, false, false,0.);\n    SphereIntersectMin(spherex2, 23.5, ro, rd, result, hit, false, true,ot);\n    sky=hit.color.rgb;\n    \n    VoxelsIntersectMin(voxbox, voxmax_h , voxposl,ro, rd, result, hit, sky);\n    \n    return hit;\n}\n\n// reflections\nHitInfo render_refl(Ray r, HitInfo hit, float fbmx, inout vec3 sky)\n{\n    vec3 skyo = background_sky(r.dir);\n    \n    if(hit.obj_type == OBJ_REFLOOR){\n        vec3 ro = r.pos;\n        ro = ro+r.dir*hit.t;\n        float vrds = length(hit.t * r.dir.xz);\n        fbmx*=1.-smoothstep(10.,14.5,vrds);\n        float gfnl = fresnel((r.dir),hit.norm);\n        fbmx*=max(1.-gfnl*2.,0.);\n        vec3 ord = reflect(r.dir-(.0295*fbmx*hit.norm), hit.norm);\n        vec3 rd = reflect(r.dir-(.295*fbmx*hit.norm), hit.norm);\n        rd += 0.0001 * (1.0 - abs(sign(rd)));\n        \n        bool result = false;\n        float angle=0.1;\n\n        vec3 spherex=vec3(0.,10.15,8.5+voxbox.y+15.);\n        vec3 spherex2=vec3(0.,10.15-2.,8.5+voxbox.y+15.-22.25);\n        float oemi=hit.color.a;\n        float ot=hit.t;\n        SphereIntersectMin(spherex, 13.5, ro, rd, result, hit, true, false,0.);\n        SphereIntersectMin(spherex2, 23.5, ro, ord, result, hit, true, true,ot);\n        float refc=0.;\n        float fnl = 0.; \n        if(hit.obj_type == OBJ_BALL){\n            fnl=1.;refc=hit.color.a;hit.color.a=oemi;\n        }\n        ro+=voxposl;ro.xz+=voxbox+1.;\n\n        rd = reflect(r.dir+(.695*fbmx*hit.norm), hit.norm);\n        rd += 0.0001 * (1.0 - abs(sign(rd)));\n        \n        VoxelsIntersectMin_ref(voxbox, voxmax_h , voxposl+1.,ro, rd, hit, hit.exdata.x, 01.5, 01.+0.25*fbmx,refc);\n        hit.color.rgb = 0.985*hit.color.rgb+0.015*hit.color.rgb*fbmx;\n        \n        fnl = max(fresnel(rd,hit.norm),fnl);\n        hit.color.rgb = mix(hit.color.rgb,skyo,1.-sqrt(fnl))+refc*(sqrt(blue))*3.;\n        \n        hit.color.rgb = mix(hit.color.rgb,sky,smoothstep(24.,27.5,vrds));\n    }\n    return hit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 ret_col = vec3(0.0);\n    float emi = 0.;\n    vec3 tro = camera_anim(iTime);\n    vec2 m=get_look(iTime);\n#if AA>1\n    const int ta=AA*AA;\n#else\n    const int ta = 1;\n#endif\n\n    HitInfo hit[ta];\n    Ray cam[ta];\n    vec3 sky[ta];\n{\n#if AA>1\n    for( int mx=0; mx<AA+iZero; mx++ )\n    for( int nx=0; nx<AA+iZero; nx++ )\n    {\n    vec2 o = vec2(float(mx),float(nx)) / float(AA) - 0.5;\n    vec2 uv = (fragCoord+o)/iResolution.xy * 2.0 - 1.0;\n#else\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n#endif\n    uv.y *= iResolution.y/iResolution.x;\n#if AA>1\n    int idx=mx*AA+nx;\n#else\n    int idx=0;\n#endif\n    cam[idx] = SetCamera(uv,tro,m);\n    sky[idx] = background_sky(cam[idx].dir);\n    hit[idx] = render(cam[idx],sky[idx]);\n#if AA>1\n    }\n#endif\n}\n\n    vec3 ro = cam[0].pos;\n    ro+=voxposl;ro.xz+=voxbox+1.;ro = ro+cam[0].dir*hit[0].t;\n    float fbmx = (simplex3d_fractal(5.*(ro-vec3(0.,hit[0].exdata.y,0.))+vec3(0.,.5,1.)*iTime));\n{\n#if AA>1\n    for( int mx=0; mx<AA+iZero; mx++ )\n    for( int nx=0; nx<AA+iZero; nx++ )\n    {\n#endif\n#if AA>1\n    int idx=mx*AA+nx;\n#else\n    int idx=0;\n#endif\n    hit[idx] = render_refl(cam[idx],hit[idx],fbmx,sky[idx]);\n#if AA>1\n    }\n#endif\n}\n\n{\n#if AA>1\n    for( int mx=0; mx<AA+iZero; mx++ )\n    for( int nx=0; nx<AA+iZero; nx++ )\n    {\n#endif\n#if AA>1\n    int idx=mx*AA+nx;\n#else\n    int idx=0;\n#endif\n    ret_col += hit[idx].color.rgb;\n    emi += hit[idx].color.a;\n#if AA>1\n    }\n    ret_col /= float(AA*AA);\n    emi /= float(AA*AA);\n#endif\n}\n    \n\n    vec3 glow = vec3(0.7, 0.8, 1.6)*max((cam[0].dir.y*0.49 + 0.51),0.001)*0.8;\n    ret_col += glow*glow*glow / 4.0;\n\n    ret_col *= 0.425;\n    ret_col = clamp(ret_col,0.,1.);\n    ret_col = sqrt(ret_col);\n    \n    vec2 vig = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    ret_col = mix(ret_col, ret_col*ret_col, dot(vig, vig)*0.5);\n    ret_col = mix(ret_col, ret_col*ret_col, 0.5);\n    \n    ret_col = clamp(ret_col,0.,1.);\n    ret_col = pow(ret_col, vec3(01.4545));\n    \n    ret_col=mix(ret_col,ret_col.bgr,atimer);\n    fragColor = vec4(ret_col,clamp(emi,0.,1.));\n    fragColor.a=1.; //bloom not used\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2Szm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[206, 388, 405, 405, 481], [693, 743, 774, 774, 868], [870, 1037, 1068, 1068, 1264], [1266, 1266, 1286, 1286, 1427], [1429, 1429, 1468, 1468, 1712], [1714, 1714, 1736, 1736, 1820], [1822, 1822, 1843, 1843, 1935], [1937, 1937, 1958, 1958, 2065], [2067, 2067, 2087, 2087, 2289], [2291, 2291, 2325, 2325, 2500], [2503, 2544, 2566, 2566, 2732], [2793, 2816, 2841, 2841, 3417], [3650, 3650, 3683, 3683, 3830], [3878, 4056, 4250, 4250, 5316], [5319, 5413, 5509, 5509, 6012], [6013, 6033, 6051, 6051, 6311], [6313, 6313, 6349, 6349, 6657], [6659, 6659, 6693, 6693, 6787], [6789, 6789, 6819, 6819, 6906], [7169, 7509, 7536, 7536, 8282], [8284, 8284, 8308, 8308, 8685], [8687, 8687, 8728, 8728, 9275], [9277, 9277, 9323, 9323, 9528], [9530, 9530, 9718, 9718, 11076], [11078, 11078, 11227, 11227, 13162], [13165, 13165, 13200, 13200, 13376], [13378, 13378, 13516, 13516, 14567], [14570, 14570, 14609, 14609, 15343], [15345, 15360, 15429, 15429, 17047]]}
{"id": "Nt2XDG", "name": "lighting02", "author": "wangxiaochen", "description": "this is a simple lighting", "tags": ["3d"], "likes": 3, "viewed": 139, "date": "1628771765", "time_retrieved": "2024-06-20T20:47:58.023764", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define Light_pos vec3(5.,5.,9.)\n#define selfcol vec3(.9,.9,.9)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.1,0.5,0.9) );\n}\nfloat smin(float a,float b,float h){\n    float c=clamp((b-a)/h*0.5+0.5,0.,1.);\n    //return c;\n    return mix(b,a,c)-h*c*(1.0-c);\n}\n\nmat2 rot(float a){\n   float c=sin(a);\n   float s=cos(a);\n    return mat2(c,s,-s,c);\n    \n}\nfloat GetDist(vec3 p){\n    vec4 s=vec4(0.,1.,6.,2.);\n    float spheredist=length(p-s.xyz)-s.w;\n    float planedist=p.y;\n    float d=smin(spheredist,planedist,.9);\n    return d;\n}\nfloat rayMarch(vec3 ro,vec3 rd){\n    float d0=0.;\n    for(int i=0;i<MAX_STEPS;i++){\n        vec3 p=ro+rd*d0;\n        float ds=GetDist(p);\n        d0+=ds;\n        if(d0>MAX_DIST||ds<SURF_DIST)break;\n    }\n    return d0;\n}\nvec3 getNormal(vec3 p){\n    float l= GetDist(p);\n    vec2 cau=vec2(.01,0.);\n    vec3 n=normalize(vec3(l-GetDist(p-cau.xyy),\n                          l- GetDist(p-cau.yxy),\n                          l- GetDist(p-cau.yyx)\n                           ));\n    return n;\n    \n}\nfloat  getLight(vec3 p){\n    vec3 ld=Light_pos;\n    //shadow\n    ld.xz*=rot(iTime);\n    vec3 li=normalize(ld-p);\n    vec3 sn=getNormal(p);\n    float sh=rayMarch(p+sn*SURF_DIST*2.,li);\n    float dif=clamp(dot(sn,li),0.,1.) ;\n        if(sh<length(ld-p)) {\n            dif*=.5;\n        }\n    return dif;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n     vec3 ld=Light_pos;\n    ld.xz*=rot(iTime);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro=vec3(0.,3.,-3);\n    vec3 rd=normalize(vec3(uv.x,uv.y-.2,1));\n    float d= rayMarch(ro,rd);\n    vec3 p=ro+rd*d;\n    vec3 n=getNormal(p);\n    float difu=getLight(p);\n    float ndotv=max(0.,dot(normalize(rd),n));\n    vec3 halfh=normalize(normalize(-rd)+normalize(ld-p));\n    float ndothalfh=max(0.,dot(halfh,n));\n    vec3 col =mix(vec3(difu)*selfcol,spectrum(ndothalfh),0.1);\n    col+=vec3(pow(ndothalfh,25.));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2XDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[131, 131, 199, 199, 242], [243, 243, 267, 267, 363], [364, 364, 400, 400, 495], [497, 497, 515, 515, 587], [588, 588, 610, 610, 766], [767, 767, 799, 799, 987], [988, 988, 1011, 1011, 1260], [1261, 1261, 1285, 1285, 1563], [1564, 1564, 1621, 1671, 2254]]}
{"id": "Nt2XRV", "name": "FractalPractice01", "author": "lambmeow", "description": "fractal", "tags": ["fractal", "sdf"], "likes": 0, "viewed": 126, "date": "1628107380", "time_retrieved": "2024-06-20T20:47:58.538908", "image_code": "#define time iTime\n#define resolution iResolution\nfloat c  =0.;\n\nmat2 rot(float f)\n{\n\tfloat s = sin(f), c = cos(f);\n\treturn mat2(c, -s , s, c);\n}\nfloat scene(vec3 p)\n{\n\t\n    for( int i = 0; i<10; ++i){\n        float t = time*.2;\n        p = abs(p -.2);\n        p.xy *= rot(t + c);\n\t\t\n        c -= .1;\n\t}\n\t\n\tfloat thing = max(dot(p , normalize(vec3(45., 0.,-524.))), length(p) - 2.);\n\t\n\treturn max(thing, p.y);\n}\n\n\nvec3 calcnorm(vec3 value)\n{\n    vec3 n = vec3(0);\n    if(length(n - value) == 0.)\n    \treturn vec3(0);\n    for(int i = 0; i < 4; i++)\n    {\n        vec3 eps = 0.001 * (vec3(9 >> i&1, i >> 1 & 1, i & 1) * 2. - 1.);\n        n += eps * scene(value + eps);\n    }\n    return normalize(n);\n}\n\n\nvec4 rc(vec3 ro, vec3 rd)\n{\n\tfloat len = 0.;\n\tfloat closest = 100.;\n\tfor(int i = 0; i < 255; i ++)\n\t{\n\t\tfloat dist = scene(ro + rd * len);\n\t\t\n\t\tclosest = min(closest, dist/.01);\n\t\tif(dist < 0.001)\n\t\t\treturn vec4(ro + rd * len,closest);\n\t\t\n\t\tlen += dist;\n\t\t\n\t\tif(len  > 100. ) \n\t\t\tbreak;\n\t}\n\t\n\treturn vec4(ro + rd * len,closest);\n}\n\nmat3 cam(vec3 pos, vec3 la, vec3 up)\n{\n\tvec3 ww = normalize(la - pos);\n\tvec3 vv = normalize(up);\n\tvec3 uu = normalize(cross(ww, vv));\n\treturn mat3(ww, uu ,vv);\n} \n\n\nvec3 pallete( vec3 pos)\n{\n\tfloat len = length(pos) / 15.;\n\t\n\treturn mix(1.- vec3 (0., 0.5, 0.7), 1.-vec3(1., 0.,10.), len)/100.; \n}\nvec3 color(vec4 pos)\n{\n\tvec3 lightcolor = vec3( 1, 1, 1), lightpos = vec3(0, 4, -4);\n\tvec3 norm = calcnorm(pos.xyz);\n\t\n\treturn pallete(pos.xyz)- (1./(1. + (pos.w * 0.3))) * vec3(0,1,1);\n}\n\nvoid mainImage(out vec4 fc , in vec2 uv)\n{\n\tvec2 r = resolution.xy, u = ((2.*uv) - r)/r.y;\n\t\n\tvec3 ro = vec3(0., 0., -4.);\n\n\tvec3 rd = normalize(vec3(u, 2.0));\n\t\n\n\t\n\tfc = vec4(color(rc(ro,rd) ), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2XRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[65, 65, 84, 84, 145], [146, 146, 167, 167, 411], [414, 414, 441, 441, 699], [702, 702, 729, 729, 1032], [1034, 1034, 1072, 1072, 1195], [1199, 1199, 1224, 1224, 1330], [1331, 1331, 1353, 1353, 1518], [1520, 1520, 1562, 1562, 1721]]}
{"id": "Nt2XWc", "name": "loading icon", "author": "keyuliang", "description": "小作业", "tags": [], "likes": 2, "viewed": 57, "date": "1628783085", "time_retrieved": "2024-06-20T20:47:58.538908", "image_code": "vec3 rainbowColor(float t) {\n    return .5 + .5 * cos(6.283 * (t + vec3(0., .33, .67)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    \n     float l = length(uv);\n     float a = atan(uv.x, uv.y) / (3.14156 * 2.0) - iTime;\n     \n\n     vec3 circle1 = mix(vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),smoothstep(0.5,0.49,l));\n     \n     vec3 circle2 = mix(vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),smoothstep(0.39,0.4,l));\n      a = fract(a);\n     vec3 col = mix(vec3(0.0,0.0,0.0),rainbowColor(a), (circle1 * circle2).r * a);\n     \n    \n\n    // Output to screen\n    fragColor = vec4(col,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2XWc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 28, 28, 90], [93, 93, 150, 200, 716]]}
{"id": "Nt2XzD", "name": "Generalized regular polygon SDF", "author": "felipetovarhenao", "description": "Rotation-based generalization of a regular polygon SDF, taking Inigo Quilez's approach as a departure. The length of the apothem is constant for all polygons.", "tags": ["sdfs"], "likes": 1, "viewed": 72, "date": "1628273404", "time_retrieved": "2024-06-20T20:47:58.951027", "image_code": "/*\nAuthor: Felipe Tovar-Henao [www.felipe-tovar-henao.com]\n\nDescription: Rotation-based generalization of a regular polygon's signed distance field (SDF), \nbased on Inigo Quilez's method in https://youtu.be/62-pRVZuS5c\nThe length of the apothem is constant for all polygons.\n*/\n\n#define u_resolution iResolution\n#define u_time iTime\n\nfloat polygonSDF(in vec2 vUV, in int V) {\n    float N = max(1.0, float(V));\n    float rot = floor(N*(atan(-vUV.x,-vUV.y) / 6.28318530718 + 0.5));\n    float offset = 3.14159265359*(N+2.0)/(2.0*N);\n    float theta = (6.28318530718/N) * rot + offset;\n    float side = tan(3.14159265359/max(N, 3.0));\n    vec2 r = vec2(cos(theta), sin(theta));\n    vUV *= mat2(r.x, -r.y, r.y, r.x);\n    float scl = 0.5 * (float(N==2.0)*(0.25/sqrt(3.0)) + step(2.0,N)) / (step(1.0,N) + step(N, 2.0));\n    vec2 s = vec2(step(3.0, N), side) * scl;\n    vec2 p = abs(vUV)-s;\n    return length(max(vec2(0.0), p)) + min(0.0, max(p.x, p.y/side));\n}\n\nfloat fold(in float x) {\n    float y = fract(x);\n    return mix(y, 1.0-y, float(mod(x, 2.0) >= 1.0));\n}\n\nfloat relu_ramp(in float x, in float s) {\n    return floor(x) + clamp((max(1.0, s)*(fract(x) - 0.5)) + 0.5, 0.0, 1.0);\n}\n\nfloat dx_ramp(in float x, in float s) {\n    float y = fract(x);\n    float h = max(0.0, pow(y, s));\n    return floor(x) + 1.0 - length(vec2(y-1.0,(h*h)-1.0)) * 0.707106781187;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUV = fragCoord.xy / u_resolution.xy;\n    float scl = 2.25;\n    vUV = (vUV-0.5) * scl;\n    vUV.x *= u_resolution.x / u_resolution.y;\n    float max_sides = 15.0;\n    vec3 color = vec3(0.0);\n\n    float t = max_sides*pow(fract(u_time/max_sides), 1.25);\n    float V1 = mod(t, max_sides) + 1.0;\n    float V2 = mod(t+1.0, max_sides) + 1.0;\n    float sdfA = polygonSDF(vUV, int(V1));\n    float sdfB = polygonSDF(vUV, int(V2));\n    float sdf = mix(sdfA, sdfB, relu_ramp(fract(V1), 3.0));\n    float border = 1.0-clamp(smoothstep(0.0,0.005,abs(sdf)), 0.0, 1.0);\n    sdfA = max(0.0, sdf);\n    sdfB = abs(min(0.0, sdf));\n    vec3 c1 = vec3(1.0, 0.1961, 0.1961) * pow(sdfA, 0.5);\n    vec3 c2 = vec3(0.1765, 1.0, 0.9882)  * pow(sdfB, 0.5);    \n    color = dx_ramp(fold(sdfA*scl*15.0), 4.0) * c1;\n    color += dx_ramp(fold(sdfB*scl*15.0), 4.0) * c2;\n    color += border*vec3(0.7412, 1.0, 0.9608);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2XzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 334, 375, 375, 953], [955, 955, 979, 979, 1058], [1060, 1060, 1101, 1101, 1180], [1182, 1182, 1221, 1221, 1358], [1360, 1360, 1417, 1417, 2344]]}
{"id": "NtBSRw", "name": "Beating blob", "author": "felipetovarhenao", "description": "Using cellular noise and shaping functions to create a pulsing blob.", "tags": ["noise", "drawing"], "likes": 5, "viewed": 67, "date": "1628372298", "time_retrieved": "2024-06-20T20:47:59.429778", "image_code": "/*\n    Author: Felipe Tovar-Henao [www.felipe-tovar-henao.com]\n    Description: Beating blob, using cellular noise and shaping functions.\n*/\n\n#define u_resolution iResolution\n#define u_time iTime\n#define TWO_PI 6.28318530718\n\nvec3 random3D(in vec3 vUV, in int seed) {\n    return fract(abs(sin(vec3(dot(vUV, vec3(11.13, 57.05, 41.87) + float(seed)), dot(vUV, vec3(43.17, 85.39, 38.97)), dot(vUV, vec3(56.91, 39.59, 81.33)))) * 48240.41));\n}\n\nfloat worley_noise3D(in vec3 vUV, in int seed) {\n    vec3 xyz = floor(vUV);\n    vec3 f = fract(vUV);\n    float mindist = 90000.0;\n    for (float x = -1.0; x <= 1.0; x++) {\n        for (float y = -1.0; y <= 1.0; y++) {\n            for (float z = -1.0; z <= 1.0; z++) {\n                vec3 node = random3D(xyz + vec3(x,y,z), seed) + vec3(x,y,z);\n                mindist = min(mindist, distance(node,f));\n            }\n        }\n    }\n    return mindist;\n}\n\nvec2 rotate2D(in vec2 vUV, in float theta) {\n    vec2 r = vec2(cos(theta), sin(theta));\n    return vUV * mat2(r.x, -r.y, r.y, r.x);\n}\n\nfloat fold(in float x) {\n    return abs(mod(x+1.0,2.0)-1.0);\n}\n\nfloat cosine_ramp(in float x, in float s) {\n    float y = cos(fract(x)*3.14159265359);\n    return floor(x) + 0.5 - (0.5*pow(abs(y), 1.0/s)*sign(y));\n}\n\nfloat sine_ramp(in float x, in float s) {\n    float y = fract(x);\n    float h = 0.5 - (0.5/(s*s));\n    return floor(x) + y + h*sin(6.28318530718*y);\n}\n\nfloat seat_ramp(in float x, in float s) {\n    float y = (2.0*fract(x))-1.0;\n    return floor(x) + 0.5 + 0.5*pow(abs(y), 1.0/s)*sign(y);\n}\n\nfloat N_ramp(in float x, in float s) {\n    float y = fract(x);\n    float h = max(0.3, s);\n    return floor(x) + length(vec2(y,0.0)-vec2(pow(y,1.0/h),pow(y,h)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUV = fragCoord.xy / u_resolution.xy;\n    vUV -= 0.5;\n    vUV *= 3.0;\n    vUV.x *= u_resolution.x / u_resolution.y;\n\n    vec3 color = vec3(0.0);\n    float t = sine_ramp(u_time * 0.09, 9.0);\n    float theta = worley_noise3D(vec3(vUV*length(vUV), seat_ramp(t, 2.0)), 4) * pow(length(vUV)*TWO_PI, 0.8);\n    theta = sine_ramp(theta, 1.0);\n    vUV = rotate2D(vUV, fold(theta + u_time*0.2) + N_ramp(t*0.23, 2.0));\n    vUV = clamp(vUV, 0.0, 1.0);\n    vUV.x = fold(vUV.x*3.0);\n    vUV.y = fold(vUV.y*2.0);\n\n    vUV.x = cosine_ramp(vUV.x, 2.5 + sin(u_time*0.17)*0.25);\n    vUV.y = cosine_ramp(vUV.y, 2.5 + cos(u_time*0.03)*0.25);\n\n    vec3 c1a = vUV.x * vec3(0.8039, 0.6196, 0.4824);\n    vec3 c2a = vUV.y * vec3(0.2118, 0.3922, 0.549);\n    vec3 c1b = vUV.x*vUV.y * vec3(0.6353, 0.4667, 0.4392);\n    vec3 c2b = abs(vUV.x-vUV.y) * 0.5 * vec3(0.3922, 0.7373, 1.0);\n\n    color += mix(c1a, c1b, fold(u_time*0.015)) + mix(c2a, c2b, fold(t*0.013));\n    color = clamp(color, 0.0, 1.0);\n\n    float shade = 1.0 - (color.r * color.b * color.g);\n    vec3 sh1 = shade * vec3(0.1255, 0.1373, 0.149);\n    vec3 sh2 = shade * vec3(0.2039, 0.1843, 0.1725);\n\n    color += mix(sh1, sh2, fold(t*0.007));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NtBSRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 226, 267, 267, 439], [441, 441, 489, 489, 895], [897, 897, 941, 941, 1030], [1032, 1032, 1056, 1056, 1094], [1096, 1096, 1139, 1139, 1246], [1248, 1248, 1289, 1289, 1398], [1400, 1400, 1441, 1441, 1537], [1539, 1539, 1577, 1577, 1701], [1703, 1703, 1760, 1760, 2980]]}
{"id": "NtBSz3", "name": "Dance Dance Revolution", "author": "cmzw", "description": "A glsl port of the \"Dance Dance Revolution\" animation I did in Blender.", "tags": ["2d", "animation", "ddr"], "likes": 10, "viewed": 278, "date": "1628169986", "time_retrieved": "2024-06-20T20:48:00.047943", "image_code": "// Originally done in Blender:\n// https://twitter.com/cmzw_/status/1380115994320859147\n\n#define PI 3.14159265359\n\n#define RES 24.0\n#define SCALE 1.0\n#define SPEED_FAC 3.0\n\n#define ARROW_MASK 0\n#define ARROW_COL 1\n#define ARROW_HIT_AREA 2\n#define ARROW_HIT_AREA_MASK 3\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h);\n}\n\nvec3 overlay(in vec3 a, in vec3 b) {\n\treturn vec3((b.r > .5) ? (2. * a.r * b.r) : 1. - 2. * (1. - a.r) * (1. - b.r),\n\t            (b.g > .5) ? (2. * a.g * b.g) : 1. - 2. * (1. - a.g) * (1. - b.g),\n\t            (b.b > .5) ? (2. * a.b * b.b) : 1. - 2. * (1. - a.b) * (1. - b.b));\n}\n\nfloat sstep(in float f) { return 1. - step(0.0001, f); }\n\nmat2 rot2(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\nvec3 arrow(in vec2 p, in float scale, int mode, in vec3 acol) {\n\tp *= scale;\n\tp = vec2(round(p * RES) / RES);\n\tvec2 p1 = vec2(abs(p.x), p.y);\n\n\tfloat af = sdSegment(p1, vec2(.58, .0), vec2(.0, .58));\n\tfloat al = sdSegment(p, vec2(.0, .48), vec2(.0, -.58));\n\n\tfloat a1 = sstep(af - .08);\n\tfloat a2 = sstep(sdSegment(p, vec2(.0, .15), vec2(.0, -.05)) - .15);\n\tfloat a3 = sstep(sdSegment(p, vec2(.0, .13), vec2(.0, -.51)) - .11);\n\tfloat tp = sstep(dot(p1 + vec2(.0, -mod(iTime / .4, 1.6)) + .4, vec2(.22)));\n\tfloat ts = sstep(abs(dot(p1 - vec2(0., -.15), vec2(.21, .26))) - .01);\n\tfloat rect = sstep(length(max(abs(p - vec2(.0, .42)) - vec2(.3, .2), 0.)));\n\n\tfloat arrow =\n\t    clamp(rect * sstep(dot(p1, vec2(.22)) - .11) + a1 - a2, 0., 1.) + clamp(a3 - ts, 0., 1.);\n\tfloat region = min(af, al) - .2;\n\tfloat outline = sstep(abs(region) - .02);\n\n\tvec3 color = overlay(acol, vec3(round((p.y + 1.) * 4.) / 4.) + .5);\n\n\tcolor = mix(vec3(0.), color, sstep(region));\n\n\tfloat mask = sstep(region - .02);\n\n\tswitch ( mode ) {\n\tcase ARROW_MASK:\n\t\treturn vec3(mask);\n\tcase ARROW_COL:\n\t\treturn vec3(outline + color + arrow * tp + arrow * .2);\n\tcase ARROW_HIT_AREA:\n\t\treturn vec3(mask * .3 * mod(iTime / .5, 1.) + .5 - arrow + outline);\n\tcase ARROW_HIT_AREA_MASK:\n\t\treturn vec3(mask - arrow);\n\t}\n}\n\nvec3 hit_arrow(in vec3 col, in vec2 ha) {\n\tvec3 acol = vec3(0.);\n\treturn mix(col, arrow(ha, 2., ARROW_HIT_AREA, acol), arrow(ha, 2., ARROW_HIT_AREA_MASK, acol));\n}\n\nvec3 ca(in vec3 col, in vec3 ac, in vec2 p, in vec2 ha, in mat2 rot, in vec2 ss) {\n\tvec3 left_m = vec3(1. - step(0., abs(p.x - .25 * 3.) - .25)) * step(ss.x, mod(p.y * ss.y, 2.));\n\tvec2 a = mod((p * 2. - .5) + .5, 1.) - .5;\n\tvec2 ap = a * rot;\n\treturn mix(col, arrow(ap, 2., ARROW_COL, ac),\n\t           arrow(ap, 2., ARROW_MASK, ac) * left_m * (sstep(ha.x - a.y)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec3 col;\n\tvec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\tp *= SCALE;\n\n\t// checker bg\n\tvec2 cp = floor(p * 2.);\n\tcol += mix(.13, .17, mod(cp.x + cp.y, 2.));\n\n\t// hit areas\n\tvec2 ha = (p * 2. - vec2(-1.5, 1.5)) * -rot2(PI / 2.);\n\tcol = hit_arrow(col, ha);\n\tcol = hit_arrow(col, (p * 2. - vec2(-.5, 1.5)) * rot2(PI));\n\tcol = hit_arrow(col, (p * 2. - vec2(.5, 1.5)) * -rot2(PI));\n\tcol = hit_arrow(col, (p * 2. - vec2(1.5, 1.5)) * rot2(PI / 2.));\n\n\t// colors\n\tvec3 blue = vec3(0., .1, .3);\n\tvec3 bluep = vec3(0., .202, .139);\n\tvec3 orange = vec3(.34, .045, .0);\n\tvec3 green = vec3(.0, .159, .03);\n\tvec3 red = vec3(.19, .0, .0);\n\tvec3 redp = vec3(.15, .0, .057);\n\tvec3 purple = vec3(.106, .001, .34);\n\tvec3 yellow = vec3(.202, .174, .0);\n\n\t// arrows\n\tvec2 tr = p - vec2(0., iTime * SPEED_FAC);\n\tcol = ca(col, blue, tr - vec2(-1.5, .4), ha, -rot2(PI / 2.), vec2(1.5, 1.));\n\tcol = ca(col, redp, tr - vec2(-1.5, -.2), ha, -rot2(PI / 2.), vec2(1., 2.));\n\tcol = ca(col, green, tr - vec2(-1, 1.1), ha, rot2(PI), vec2(1.5, 1.));\n\tcol = ca(col, orange, tr - vec2(-1, .1), ha, rot2(PI), vec2(1.5, 1.));\n\tcol = ca(col, purple, tr - vec2(-.5, .1), ha, -rot2(PI), vec2(1., 2.));\n\tcol = ca(col, red, tr - vec2(-.5, -.5), ha, -rot2(PI), vec2(1., 2.));\n\tcol = ca(col, yellow, tr - vec2(0., -.5), ha, rot2(PI / 2.), vec2(1.5, 1.));\n\tcol = ca(col, bluep, tr - vec2(0., .4), ha, rot2(PI / 2.), vec2(1.5, 1.));\n\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NtBSz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 269, 319, 319, 435], [437, 437, 473, 473, 716], [718, 718, 743, 743, 774], [776, 776, 796, 796, 844], [846, 846, 909, 909, 2128], [2130, 2130, 2171, 2171, 2293], [2295, 2295, 2377, 2377, 2662], [2664, 2664, 2719, 2719, 4152]]}
{"id": "NtBXDK", "name": "Smile Face Study", "author": "Trospy", "description": "Source Code from Youtube \"The Art of Code\" https://www.youtube.com/watch?v=GgGBR4z8C9o!!", "tags": ["shader"], "likes": 0, "viewed": 19, "date": "1628581641", "time_retrieved": "2024-06-20T20:48:00.047943", "image_code": "float Circle(vec2 uv, vec2 position, float r, float blur)\n{\n    float distance = length(uv-position);\n    float color = smoothstep(r,r-blur,distance);\n    \n    return color;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5; // make viewport center as (0,0)\n    uv.x *= iResolution.x/iResolution.y;\n    float r = 0.3;\n    float face = Circle(uv,vec2(0.,0),r,0.01);\n    \n    //eye 1\n    face -= Circle(uv,vec2(-0.15,0.1),0.01*sin(iTime)+0.05,0.01); \n    \n    //eye mirror to +x axis\n    face -= Circle(uv,vec2(0.15,0.1),0.01*sin(iTime)+0.05,0.01);\n    \n    //make mouth\n    //lower lip\n    float mouth = Circle(uv,vec2(0.,-0.05),0.2,0.01);\n    //upper lip\n    mouth -= Circle(uv,vec2(0.,0.04*(sin(iTime)+0.02)),0.2,0.01);\n    mouth = clamp(mouth,0.0,1.0);\n    \n    face -= mouth;\n    \n    vec3 col = vec3(0.5+0.3*sin(iTime),0.7+0.*sin(iTime),1.0+0.5*sin(iTime))*face;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NtBXDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 59, 59, 176], [178, 178, 235, 235, 965]]}
{"id": "NtBXWV", "name": "Magic Portal", "author": "Delincoter", "description": "My first shadertoy XD", "tags": ["2d"], "likes": 6, "viewed": 306, "date": "1628589976", "time_retrieved": "2024-06-20T20:48:00.047943", "image_code": "//noise funtion abstract from https://www.shadertoy.com/view/4sc3z2\nvec3 hash33(vec3 p3)\n{\n\tvec3 MOD3 = vec3(.1031, .11369, .13787);\n\tp3 = fract(p3* MOD3);\n\tp3 += dot(p3, p3.yxz + 19.19);\n\treturn -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x + p3.z)*p3.y, (p3.y + p3.z)*p3.x));\n}\n\nfloat simplex_noise(vec3 p)\n{\n\tconst float K1 = 0.333333333;\n\tconst float K2 = 0.166666667;\n\n\tvec3 i = floor(p + (p.x + p.y + p.z) * K1);\n\tvec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n\n\tvec3 e = step(vec3(0, 0, 0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\n\tvec3 d1 = d0 - (i1 - 1.0 * K2);\n\tvec3 d2 = d0 - (i2 - 2.0 * K2);\n\tvec3 d3 = d0 - (1.0 - 3.0 * K2);\n\n\tvec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n\tvec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n\n\treturn dot(vec4(31.316, 31.316, 31.316, 31.316), n);\n}\n\n\n\nfloat render(vec2 uv)\n{\n    float side = smoothstep(0.5, 0.3, length(uv));\n    float center = smoothstep(0.1, 0.0, length(uv));\n    vec3 rd = vec3(uv, 0.);\n\n    float t = pow(iTime+0.5,5.)*0.001;\n\n    float n2 = simplex_noise((rd*t+t) * (1. / length(rd*t+rd)));\n    \n    if(iTime>1.5)\n    {\n        n2 = simplex_noise((rd*t+t) * (1. / length(rd*t+rd))+(iTime-1.5));\n    }\n    \n    \n    float flare = smoothstep(0.,1.,0.002 / length(rd*length(rd)*n2))*side;\n    \n    flare = flare-center*clamp((iTime-1.5)*10.,0.,5.);\n    \n    return flare;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    \n    vec3 col = vec3(0.102,0.5,1.)*2.;\n    col *= render(uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NtBXWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 68, 90, 90, 283], [285, 285, 314, 314, 949], [953, 953, 976, 976, 1494], [1496, 1496, 1553, 1553, 1753]]}
{"id": "NtfSzs", "name": "Distance-aided Raymarching", "author": "lerping", "description": "Morphing volumetric shapes, with ambient occlusion, using \"distance-aided\" raymarchig.", "tags": ["sdf"], "likes": 2, "viewed": 49, "date": "1628958110", "time_retrieved": "2024-06-20T20:48:00.053852", "image_code": "const int steps = 55;\n\nfloat magnitude(vec3 a)\n{\n    return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);\n}\n\nvec3 normalized(vec3 a)\n{\n    return a/length(a);\n}\n\nfloat sdfUnion(float sdf1, float sdf2)\n{\n    return min(sdf1, sdf2);\n}\n\n// Polynomial smooth min - https://www.iquilezles.org/www/articles/smin/smin.htm && Media Molecule\nfloat sdfSmoothUnion(float sdf1, float sdf2, float k)\n{\n    float h = max( k-abs(sdf1-sdf2), 0.0 )/k;\n    return min( sdf1, sdf2 ) - h*h*k*(1.0/4.0);\n}\n\nfloat sdfSphere(vec3 origin, vec3 center, float radius)\n{\n    // if distance from origin to center, is bigger than radius, return positive value\n    // if distance from origin to center, is smaller/equal to radius, return negative value  \n    return (magnitude(center-origin) - radius);\n}\n\n\nfloat rayMarch(vec3 origin, vec3[2] center, float radius, vec3 viewDir, vec3 lightPos, float specExpo, inout float diff, inout float spec, inout float ao)\n{   \n    float sdf;\n\n    for(int i=0; i<steps; i++)\n    {\n        float sdf1 = sdfSphere(origin, center[0], radius);\n        float sdf2 = sdfSphere(origin, center[1], radius);        \n        float sdf = sdfSmoothUnion(sdf1, sdf2, 0.75);\n        \n        origin += sdf * viewDir;        \n        \n        if ( sdf < 0.001 ) \n        {\n        // return 0 if center0 is closer than center1\n        // return 1 if center0 is distant than center1\n        float a =  min(1.0, floor(magnitude(center[0]-origin) / magnitude(center[1]-origin)) );\n        vec3 nearestCenter = a * center[1] + (1.0-a) * center[0];\n\n        vec3 normal = normalized(origin - nearestCenter);\n        vec3 lightDir = normalized(lightPos - origin);\n        // dot product will return negative value is vectors pointing in opposite directions.\n        // make sure result >= 0\n        diff = max(0.0, dot(normal, lightDir));\n\n        vec3 reflectDir = reflect(-lightDir, normal);\n        spec = pow(max(0.0, dot(-viewDir, reflectDir)), specExpo);\n\n        ao =  (float(i) / float(steps));\n        return 1.0;\n        }\n    }   \n    return 0.0;\n}\n\nvec3[] _center = vec3[]\n( \n    vec3(-1.1, 0.0, 5.0), \n    vec3( 1.1, 0.0, 5.0)\n);\n    \nfloat _radius = 1.0;\n\nvec3 _matAmbient = vec3(1.0, 1.0, 1.0);\nvec3 _matDiffuse = vec3(0.5, 0.5, 0.5);\nvec3 _matSpecular = vec3(1.0, 1.0, 1.0);\n\nvec3 _lightPos = vec3(0.0, 10.0, 0.0);\n\nvec3 _lightColor = vec3(1.0, 1.0, 1.0);\nfloat _lightAmbient = 0.2;\nfloat _lightDiffuse = 0.75;\nfloat _lightSpecular = 1.0;\nfloat _lightSpecularExpo = 32.0;\n\nmat4 rotZ(float angle)\n{\n    mat4 rotMatrix = mat4(\n        vec4( cos(angle), sin(angle), 0.0, 0.0),\n        vec4(-sin(angle), cos(angle), 0.0, 0.0),\n        vec4(        0.0,        0.0, 1.0, 0.0),\n        vec4(        0.0,        0.0, 0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //_radius = mix(0.5, 2.0, abs(sin(iTime)));\n    _lightPos.z = mix(0.0, 10.0, sin(iTime*.5));\n    \n    _center[0].x -=  .2 * sin(iTime*.25);\n    _center[1].x +=  .2 * sin(iTime*.25);   \n           \n       \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 nfc = 2.0 * uv - 1.0;\n   \n    // fragment and camera world-space position\n    vec3 fragPos = vec3(nfc.x, nfc.y, 0.0) * vec3((iResolution.x/iResolution.y),1.0,1.0);\n    vec3 camPos = vec3(0.0, 0.0, -5.0);\n    \n    vec3 viewDir = normalized(fragPos - camPos);\n    \n    float diff;\n    float spec;\n    float ao;\n    float test = rayMarch(camPos, _center, _radius, viewDir, _lightPos, _lightSpecularExpo, diff, spec, ao);\n                                \n    vec3 ambient = (_lightAmbient * _lightColor) * _matAmbient;\n    vec3 diffuse = (_lightDiffuse * _lightColor) * (_matDiffuse * diff);\n    vec3 specular = (_lightSpecular * _lightColor) * (_matSpecular * spec);\n\n    //float edge = (ao*ao)*(3.0-2.0*ao);\n    \n    vec3 bg = vec3(0.3,0.3,0.3);\n     \n    vec3 col = ambient + diffuse + specular;\n    col = mix(bg, col*(1.0-ao), test);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NtfSzs.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[23, 23, 48, 48, 96], [98, 98, 123, 123, 149], [151, 151, 191, 191, 221], [223, 322, 377, 377, 473], [475, 475, 532, 713, 763], [766, 766, 922, 922, 2036], [2466, 2466, 2490, 2490, 2749], [2750, 2750, 2807, 2855, 4008]]}
{"id": "NtjSW3", "name": "Spiraling In and Out", "author": "dr2", "description": "More logarithmic spiraling (based on \"Spiraling Out\")", "tags": ["spiral", "projection", "logarithm"], "likes": 16, "viewed": 235, "date": "1628770907", "time_retrieved": "2024-06-20T20:48:00.060776", "image_code": "// \"Spiraling In and Out\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // 0/1 - optional antialiasing\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nvec3 ltDir, qHit;\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r, a, s;\n  dMin = dstFar;\n  q = p;\n  r = length (q.xz);\n  if (r > 0.01) {\n    a = atan (q.z, q.x) / pi;\n    q.xz = mod (vec2 (0.5 * (pi * log (r) - a) - 0.4 * tCur, -5. * a) + 0.5, 1.) - 0.5;\n    q.y /= sqrt (r);\n    q.y -= 0.15 - 0.01 / r;\n    s = 0.25 * r;\n    d = s * min (PrRoundBoxDf (q, vec3 (0.16, 0.12, 0.2), 0.02), \n       PrRoundCylDf (vec3 (q.x, q.y - 0.24, abs (q.z) - 0.1).xzy, 0.05, 0.01, 0.12));\n    DMINQ (1);\n    d = s * max (abs (abs (q.x) - 0.3) - 0.1, q.y + 0.06);\n    DMINQ (2);\n    d = s * min (PrRoundCylDf (vec3 (q.x - 0.3, q.y, mod (q.z - 0.3 * tCur + 0.25, 0.5) - 0.25).xzy,\n       0.07, 0.01, 0.12),\n       PrRoundCylDf (vec3 (q.x + 0.3, q.y, mod (q.z + 0.3 * tCur + 0.25, 0.5) - 0.25).xzy,\n       0.07, 0.01, 0.12));\n    DMINQ (3);\n  }\n  q = p;\n  d = max (0., q.y);\n  DMINQ (4);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 24; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, sh, nDotL;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col4 = vec4 (0.2, 0.5, 1., 0.2) * (0.93 + 0.07 * cos (60. * pi * qHit.y));\n    else if (idObj == 2) col4 = vec4 (0.5, 0.2, 0.1, 0.2);\n    else if (idObj == 3) col4 = vec4 (1., 0.9, 0.9, 0.3) * (0.93 + 0.07 * cos (60. * pi * qHit.y));\n    else if (idObj == 4) col4 = vec4 (0.3, 0.6, 0.3, 0.2);\n    sh = ObjSShadow (ro + 0.01 * vn, ltDir);\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = col4.rgb * (0.2 + 0.8 * sh * nDotL * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n  } else {\n    col = vec3 (0.1);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, asp, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  az = 0.03 * pi * tCur;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += pi * mPtr.x;\n    el += 0.25 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.3 * pi, -0.17 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 1., -20.);\n  zmFac = 2.5;\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NtjSW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 567, 589, 589, 1440], [1442, 1442, 1475, 1475, 1659], [1661, 1661, 1682, 1682, 1937], [1939, 1939, 1976, 1976, 2205], [2207, 2207, 2242, 2242, 3003], [3005, 3005, 3061, 3061, 4182], [4184, 4184, 4230, 4230, 4277], [4279, 4279, 4336, 4336, 4411], [4413, 4413, 4449, 4449, 4655], [4657, 4657, 4687, 4687, 4800]]}
{"id": "NtjXzc", "name": "Capsule (Max Norm Distance)", "author": "TheTurk", "description": "Maximum norm distance function for a capsule.", "tags": ["distancefield", "sdf", "distance", "capsule", "maxnorm", "linfinity", "maximumnorm"], "likes": 1, "viewed": 61, "date": "1628252408", "time_retrieved": "2024-06-20T20:48:00.635940", "image_code": "/* \nTo compute the maximum norm distance between a point p and a \nprimitive we need to find the size of the smallest \naxis-aligned cube (compared to the size of the smallest \nsphere under Euclidian norm) centered at p that touches the \nsurface of the primitive. There are usually three cases that \nneed to be handled depending on whether the point that \ntouches the surface of the primitive lies on a corner, edge \nor face of the cube.\n*/\n\nfloat capsule(vec2 position, float radius, float halfHeight) {\n    position = abs(position);\n    position.y -= halfHeight - radius;\n    if (position.x < position.y - radius || position.y < position.x - radius) {\n        return max(position.x, position.y) - radius;\n    }\n    float p = dot(position, vec2(0.5));\n    float q = dot(position, position) * 0.5 - p * p;\n    float h = sqrt(radius * radius * 0.5 - q); \n    return p - h;\n}\n\nfloat capsule(vec3 position, float radius, float halfHeight) {\n    position = abs(position);\n    position.y -= halfHeight - radius;\n    \n    // the remaining implementation is identical to that of a sphere\n    // closest point lies on cube face\n    float d = max(max(position.x - radius, position.y), position.z);\n    d = min(d, max(max(position.x, position.y - radius), position.z));\n    d = min(d, max(max(position.x, position.y), position.z - radius));\n    \n    // closest point lies on cube edge\n    {\n        float b = dot(vec2(1.0), position.yz);\n        float c = dot(position.yz, position.yz) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.x));\n        }\n    }\n    \n    // closest point lies on cube edge\n    {\n        float b = dot(vec2(1.0), position.xz);\n        float c = dot(position.xz, position.xz) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.y));\n       }\n    }\n    \n    // closest point lies on cube edge\n    {\n        float b = dot(vec2(1.0), position.xy);;\n        float c = dot(position.xy, position.xy) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.z));\n        }\n    }\n\n    // closest point lies on cube corner\n    float b = dot(vec3(1.0), position);\n    float c = dot(position, position) - (radius * radius);\n    float discriminant = b * b - 3.0 * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / 3.0;\n        d = min(d, t);\n    }\n    \n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = fragCoord / iResolution.xy;\n    position = (position * 2.0) - 1.0;\n    position.x *= iResolution.x / iResolution.y;\n    \n    vec2 mousePosition = iMouse.xy / iResolution.xy;\n    mousePosition = (mousePosition * 2.0) - 1.0;\n    mousePosition.x *= iResolution.x / iResolution.y;\n      \n    float z = (-1.0 + fract(iTime * 0.2) * 2.0) * 0.35;\n    float radius = 0.3;\n    float halfHeight = 0.6;\n    float d = capsule(vec3(position, z), radius, halfHeight);\n    // float d = capsule(position, radius, halfHeight);\n \n    // same colorization that Inigo Quilez uses in his shaders\n    vec3 color = vec3(1.0, 0.9, 1.0) + sign(d) * vec3(-0.3, 0.4, 0.3); // base color\n    color *= 1.0 - exp(-3.0 * abs(d)); // gradient\n\tcolor *= 0.8 + 0.2 * cos(180.0 * d); // ripples\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d))); // outline\n \n    fragColor = vec4(color, 1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NtjXzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 440, 502, 502, 871], [873, 873, 935, 935, 2725], [2727, 2727, 2782, 2782, 3680]]}
{"id": "NtSSzK", "name": "chungaTest2.23", "author": "chungaloid", "description": "test", "tags": ["test"], "likes": 0, "viewed": 32, "date": "1628012780", "time_retrieved": "2024-06-20T20:48:02.745210", "image_code": "// source https://www.shadertoy.com/view/lssSWH\n\n\n// trace visualization\n// -- @paniq\n\n//////////////////////////////////////////////////////////\n\n#define iafloat vec2\n#define iavec3 mat3 // in glsl: mat3x2\n#define PI 3.14159265\n#define EPSILON .0001\n\nvec3 rotZ(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return vec3 (\n        c*p.x - s*p.y,\n        s*p.x + c*p.y,\n        p.z\n    );\n}\n\nvec3 rotY(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return vec3 (\n        c*p.x + s*p.z,\n        p.y,\n        -s*p.x + c*p.z\n    );\n}\n\niavec3 iavec3_new(iafloat x, iafloat y, iafloat z) {\n\treturn iavec3(x, 0.0, y, 0.0, z, 0.0);\n}\n\niavec3 iavec3_new(float x, float y, float z) {\n\treturn iavec3(x, x, 0.0, y, y, 0.0, z, z, 0.0);\n}\n\niavec3 iavec3_new(vec3 p) {\n\treturn iavec3(p.xx, 0.0, p.yy, 0.0, p.zz, 0.0);\n}\n\niavec3 iavec3_new(vec3 p0, vec3 p1) {\n\treturn iavec3(p0.x, p1.x, 0.0, p0.y, p1.y, 0.0, p0.z, p1.z, 0.0);\n}\n\niafloat imin(iafloat a, iafloat b) {\n\treturn iafloat(min(a.x,b.x),min(a.y,b.y));\n}\n\niafloat imax(iafloat a, iafloat b) {\n\treturn iafloat(max(a.x,b.x),max(a.y,b.y));\n}\niafloat iabs(iafloat a) {\t\n\treturn (a.x>=0.0)?\n        iafloat(a):\n        (a.y<0.0) ? \n            iafloat(abs((a).yx)):\n            iafloat(0.0,max(abs(a.x),abs(a.y)));\n}\n\n\n\niafloat iadd(iafloat a, iafloat b) {\n\treturn a + b;\n}\n\niavec3 iadd(iavec3 a, iavec3 b) {\n\treturn iavec3_new(\n\t\ta[0].xy + b[0].xy,\n\t\ta[1].xy + b[1].xy,\n\t\ta[2].xy + b[2].xy);\n}\n\niavec3 iadd(vec3 a, iavec3 b) {\n\treturn iavec3_new(\n\t\ta.xx + b[0].xy,\n\t\ta.yy + b[1].xy,\n\t\ta.zz + b[2].xy);\n}\n\niafloat isub(iafloat a, iafloat b) {\n\treturn a - b.yx;\n}\n\niavec3 isub(iavec3 a, iavec3 b) {\n\treturn iavec3_new(\n\t\ta[0].xy - b[0].yx,\n\t\ta[1].xy - b[1].yx,\n\t\ta[2].xy - b[2].yx);\n}\n\niavec3 isub(iavec3 a, vec3 b) {\n\treturn iavec3_new(\n\t\ta[0].xy - b.xx,\n\t\ta[1].xy - b.yy,\n\t\ta[2].xy - b.zz);\n}\n\niafloat imul(iafloat a, iafloat b) {\n\tvec4 f = vec4(\n\t\ta.xxyy * b.xyxy\n\t);\t\n\treturn iafloat(\n\t\tmin(min(f[0],f[1]),min(f[2],f[3])),\n\t\tmax(max(f[0],f[1]),max(f[2],f[3])));\n}\n\niafloat imul(float a, iafloat b) {\n\tvec2 f = vec2(a*b);\t\n\treturn iafloat(\n\t\tmin(f[0],f[1]),\n\t\tmax(f[0],f[1]));\n}\n\niavec3 imul(iavec3 a, iavec3 b) {\n\treturn iavec3_new(\n\t\timul(a[0].xy, b[0].xy),\n\t\timul(a[1].xy, b[1].xy),\n\t\timul(a[2].xy, b[2].xy)\n\t);\n}\n\niavec3 imul(float a, iavec3 b) {\n\treturn iavec3_new(\n\t\timul(a, b[0].xy),\n\t\timul(a, b[1].xy),\n\t\timul(a, b[2].xy)\n\t);\n}\n\niavec3 imul(vec3 a, iavec3 b) {\n\treturn iavec3_new(\n\t\timul(a.xx, b[0].xy),\n\t\timul(a.yy, b[1].xy),\n\t\timul(a.zz, b[2].xy)\n\t);\n}\n\niavec3 imul(vec3 a, iafloat b) {\n\treturn iavec3_new(\n\t\timul(a.x, b),\n\t\timul(a.y, b),\n\t\timul(a.z, b)\n\t);\n}\n\n\niafloat idiv(iafloat a, iafloat b) {\n\tvec4 f = vec4(\n\t\ta.x/b, a.y/b\n\t);\n\treturn iafloat(\n\t\tmin(min(f[0],f[1]),min(f[2],f[3])),\n\t\tmax(max(f[0],f[1]),max(f[2],f[3])));\n}\n\niavec3 idiv(iavec3 a, iavec3 b) {\n\treturn iavec3_new(\n\t\tidiv(a[0].xy, b[0].xy),\n\t\tidiv(a[1].xy, b[1].xy),\n\t\tidiv(a[2].xy, b[2].xy)\n\t);\n}\n\niafloat isqrt(iafloat a) {\n\treturn iafloat(sqrt(a.x),sqrt(a.y));\n}\n\n// for even powers in general,\n// for odd powers, it's just iafloat(a*a)\niafloat ipow2(iafloat a) {\t\n\treturn (a.x>=0.0)?\n        iafloat(a*a):\n        (a.y<0.0) ? \n            iafloat((a*a).yx):\n            iafloat(0.0,max(a.x*a.x,a.y*a.y));\n}\n\niavec3 ipow2(iavec3 v) {\n\treturn iavec3_new(\n\t\tipow2(v[0].xy),\n\t\tipow2(v[1].xy),\n\t\tipow2(v[2].xy));\n}\n\niafloat ilensq(iavec3 a) {\n\tiavec3 c = ipow2(a);\n\treturn c[0].xy + c[1].xy + c[2].xy;\n}\n\niafloat ilength(iavec3 a) {\n\tiavec3 c = ipow2(a);\n\treturn isqrt(c[0].xy + c[1].xy + c[2].xy);\n}\n\niafloat idot(iavec3 a, iavec3 b) {\n\tiavec3 c = imul(a,b);\n\treturn c[0].xy + c[1].xy + c[2].xy;\n}\n\nbool icontains(iafloat a, float v) {\n\treturn ((v >= a.x) && (v < a.y));\n}\n\niafloat icos(iafloat a) {\n    float x = cos(a.x);\n    float y = cos(a.y);\n    return iafloat(min(x, y), max(x, y));\n}\n\n/*\niafloat imod(iafloat a, float b) {\n    \n}\n*/\niafloat imod(float a, iafloat x) {\n    vec2 x1Segment = vec2(ceil(a/abs(x.x)), floor(a/abs(x.x)));\n    vec2 x2Segment = vec2(ceil(a/abs(x.y)), floor(a/abs(x.y)));\n\n    if (abs(x1Segment.x - x2Segment.x) < EPSILON && abs(x1Segment.y - x2Segment.y) < EPSILON)\n        if (x.x >= 0.)\n            return vec2(mod(a, x.y), mod(a, x.x));\n        else\n            return vec2(mod(a, x.x), mod(a, x.y));\n    else\n        if (x.x >= 0.)\n            return vec2(0, mod(a, x2Segment.x));\n        else if (x.y > 0.)\n            return vec2(mod(a, -x1Segment.x), mod(a, x2Segment.x));\n        else \n            return vec2(mod(a, -x1Segment.x), 0);\n}\n//////////////////////////////////////////////////////////\n\niafloat sphere(iavec3 p, float r) {\n\t// x^2 + y^2 + z^2 - r^2\n\treturn isub(ilensq(p),iafloat(r*r));\n}\n\niafloat teardrop(iavec3 p) {\n\t// -0.5x^5 - 0.5x^4 + y^2 + z^2\n\t\n\tiafloat x2 = ipow2(p[2].xy);\n\tiafloat y2 = ipow2(p[1].xy);\n\tiafloat z2 = ipow2(p[0].xy);\n\t\n\tiafloat x4 = ipow2(x2);\n\tiafloat x5 = imul(p[2].xy,x4);\n\t\n\treturn iadd(iadd(isub(imul(-0.5,x5), imul(0.5,x4)), y2), z2);\t\n}\n\niafloat cube(iavec3 p, float r) {\n    // max( |x|, max( |y|, |z|) ) - r\n    return isub( imax( iabs(p[0].xy) , imax(iabs(p[1].xy), iabs(p[2].xy)) ) , iafloat(r));\n}\n\niafloat dcos(iavec3 p) {\n    // cos(x) - y\n    return isub(icos(p[0].xy), p[1].xy);\n}\n\niafloat dmod(iavec3 p, float a) {\n    // mod(a, x) - y\n    return isub(imod(a, p[0].xy), p[1].xy);\n}\n\niafloat oct(iavec3 p, float r) {\n    // |x| + |y| + |z| - r\n    return isub( iadd( iabs(p[0].xy) , iadd(iabs(p[1].xy), iabs(p[2].xy)) ) , iafloat(r));    \n}\n\niafloat steiner(iavec3 p) {\n     // x^2.y^2 + y^2.z^2 + x^2.z^2 + xyz     \n\tiafloat x2 = ipow2(p[2].xy);\n\tiafloat y2 = ipow2(p[1].xy);\n\tiafloat z2 = ipow2(p[0].xy);    \n    return iadd( iadd(imul(x2, y2), imul(x2, y2)), iadd(imul(x2, y2), imul(p[0].xy, imul(p[1].xy, p[2].xy))));\n}\n\niafloat dtest1(iavec3 p) {\n    // x^2 - y^2 + |z|\n    return iadd(isub(ipow2(p[0].xy), ipow2(p[1].xy)), iabs(p[2].xy));\n}\n\niafloat dtest2(iavec3 p) {\n    // x^2 - |y| + |z|\n    return iadd(isub(ipow2(p[0].xy), iabs(p[1].xy)), iabs(p[2].xy));\n}\n\niafloat dtest3(iavec3 p) {\n    // (x^2)^2 - 2xy + z^2  = 0\n    return iadd(isub(ipow2(ipow2(p[0].xy)), imul(2., imul(p[0].xy, p[1].xy))), ipow2(p[2].xy));\n}\n\niafloat dtest4(iavec3 p) {\n    // x^5-5x - y  = 0\n    return isub(isub(imul(imul(imul(imul(p[0].xy, p[0].xy), p[0].xy), p[0].xy), p[0].xy), imul(5., p[0].xy)), p[1].xy);\n}\n\n#define TEST 1\niafloat map2(iavec3 p, int o) {\n#if TEST==0\n    switch (o) {\n    case 0:\n        return sphere(isub(p, vec3(0.0,0.0,0.0)), 0.4); break;\n    case 1:\n        return imax(teardrop(imul(2.0,isub(p, vec3(1.0,0.0,0.0)))), \n            sphere(isub(p, vec3(1.0,0.0,0.0)), 0.8)); break;\n    case 2:\n        return sphere(isub(p, vec3(-1.5,0.5,1.0)), 0.8); break;\n    case 3:\n        return cube(isub(p, vec3(0.0,-1.0,-1.0)), 0.8); break;\n    case 4:\n        return oct(isub(p, vec3(0.5,0.5,1.0)), 0.8); break;\n    case 5:\n        return steiner(p); break;\n    }\n#elif TEST==1 \n    switch (o) {\n    case 0:\n        return sphere(isub(p, vec3(0.0,0.0,0.0)), 0.4); break;\n    case 1:\n        return dmod(isub(p, vec3(cos(iTime), 0., 0.)), 1.);\n    }\n#endif\n}\n\n#define DRAWING_LIMIT 3.\niafloat map(iavec3 p, int o) {\n    return map2(p, o);\n    //return imax(cube(p, DRAWING_LIMIT), map2(p, o));\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n// https://www.shadertoy.com/view/wdXGDr\nvec3 calcNormal( in vec3 pos, int o )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy * map(iavec3_new(pos + e.xyy*eps), o).x + \n\t\t\t\t\t  e.yyx * map(iavec3_new(pos + e.yyx*eps), o).x + \n\t\t\t\t\t  e.yxy * map(iavec3_new(pos + e.yxy*eps), o).x + \n\t\t\t\t\t  e.xxx * map(iavec3_new(pos + e.xxx*eps), o).x );\n}\n\n\n#define LIGHTING 0\n#define BACKGROUND 1\n#define OBJECTS 2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 m = iMouse.xy;\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;  \n    \n     // camera movement\t\n\tvec2 an = vec2(10. * m.x / iResolution.x, 5. * (m.y / iResolution.y - 0.5));\n    \n    vec3 ro0 = vec3(5., 0., 0.);\n    vec3 ta = vec3( 0., 0., 0. );\n    \n    \n    vec3 ro = rotZ(ro0, min(abs(an.y), PI / 2.0001) * sign(an.y));\n    ro = rotY(ro, an.x);\n    \n    // camera matrix\n    \n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    \n    vec3 col = vec3(.7);\n    #if BACKGROUND==0\n        col = vec3((p.x + 1.) / 15., (p.y + 1.) / 15., 0.4);\n    #elif BACKGROUND==1\n        col = vec3((p.x + 1.) / 15., (p.y + 1.) / 15., 0.4);\n        float greyscale = (col.r + col.g + col.b) / 3.; \n        col = (col + vec3(greyscale)) * 0.5;\n    #elif BACKGROUND==2\n        float gradient =  2. * ww.y + p.y;\n        col = vec3(0.3 * gradient, 0.5 * gradient, 0.3 * gradient + .5);  \n    #endif    \n    const vec3 lightCol = vec3(0.8, 0.8, 0.7);\n    const vec3 ambCol = vec3(0.2);\n    bool hasObj = false; // if there is a non background colour on this pixel\n    \n    \n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    \n    const float maxt = 30.1;\n\tconst float mine = 1e-3;    \n    \n    \n    for (int o = 0; o < OBJECTS; o++) {\t\n        iafloat t = iafloat(0.0, maxt); // t is the range to look at\n\n        bool hit = false;\t\n        bool shouldBreak = false;\n        const int maxI = 256;\n        float thMin = maxt;\n        for (int i = 0; i < maxI; i++) {\t\n            float th = (t.x + t.y) * 0.5;\n            thMin = min(thMin, th);\n\n            iafloat t0 = iafloat(t.x, th); // first half of segment\n            iafloat t1 = iafloat(th, t.y); // second half\n\n            iafloat d0 = map(iadd(ro, imul(rd, t0)), o); // map(ro + rd*t0)\n            iafloat d1 = map(iadd(ro, imul(rd, t1)), o);\n            if (icontains(d0, 0.0)) {\n                t.y = th;\n                if (max(abs(d0.y),abs(d0.x)) < mine) {\n                    hit = true;\n                    break;\n                }\n            } else if (icontains(d1, 0.0)) {\n                t.x = th;\n                if (max(abs(d1.y),abs(d1.x)) < mine) {\n                    hit = true;\n                    break;\n                }\n            } else {\n                // nudge to back, double interval\n                float d = (t.y-t.x);\n                t.x += d;\n                t.y += d*2.0;\n                if (t.x >= maxt)\n                    break;\n            }\n            \n        }\n        if (hit) {    \n            vec3 nor = calcNormal(ro + rd * (t.x + t.y) * 0.5, o);               \n            vec3 thisCol = nor / 2. + .5;\n            if (hasObj)\n                col *= thisCol * 3.;\n            else {\n                col = thisCol;\n                hasObj = true;\n            }\n        }\n    }\n    \n    \n    col = sqrt( col );\n    \n    \n    fragColor = vec4(col, 1.);\n    \n}\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NtSSzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[87, 252, 280, 280, 409], [411, 411, 439, 439, 569], [571, 571, 623, 623, 665], [667, 667, 713, 713, 764], [766, 766, 793, 793, 844], [846, 846, 883, 883, 952], [954, 954, 990, 990, 1036], [1038, 1038, 1074, 1074, 1120], [1121, 1121, 1146, 1146, 1293], [1297, 1297, 1333, 1333, 1350], [1352, 1352, 1385, 1385, 1471], [1473, 1473, 1504, 1504, 1581], [1583, 1583, 1619, 1619, 1639], [1641, 1641, 1674, 1674, 1760], [1762, 1762, 1793, 1793, 1870], [1872, 1872, 1908, 1908, 2043], [2045, 2045, 2079, 2079, 2157], [2159, 2159, 2192, 2192, 2295], [2297, 2297, 2329, 2329, 2414], [2416, 2416, 2447, 2447, 2541], [2543, 2543, 2575, 2575, 2648], [2651, 2651, 2687, 2687, 2818], [2820, 2820, 2853, 2853, 2956], [2958, 2958, 2984, 2984, 3024], [3026, 3099, 3125, 3125, 3269], [3271, 3271, 3295, 3295, 3372], [3374, 3374, 3400, 3400, 3461], [3463, 3463, 3490, 3490, 3558], [3560, 3560, 3594, 3594, 3656], [3658, 3658, 3694, 3694, 3731], [3733, 3733, 3758, 3758, 3850], [3852, 3900, 3934, 3934, 4537], [4538, 4598, 4633, 4659, 4699], [4701, 4701, 4729, 4762, 4981], [4983, 4983, 5016, 5054, 5147], [5149, 5149, 5173, 5191, 5234], [5236, 5236, 5269, 5290, 5336], [5338, 5338, 5370, 5397, 5494], [5496, 5496, 5523, 5570, 5777], [5779, 5779, 5805, 5828, 5900], [5902, 5902, 5928, 5951, 6022], [6024, 6024, 6050, 6082, 6180], [6182, 6182, 6208, 6231, 6353], [6370, 6370, 6401, 6401, 7116], [7143, 7143, 7173, 7173, 7253], [7255, 7360, 7399, 7399, 7706], [7767, 7767, 7824, 7824, 10793]]}
{"id": "NtSSzy", "name": "扎点，圆，光圈，发光，线条", "author": "moshuying", "description": "fork自别人的shader", "tags": ["2d", "pulse", "circle", "organic"], "likes": 5, "viewed": 116, "date": "1627960523", "time_retrieved": "2024-06-20T20:48:02.751277", "image_code": "vec3 iColor = vec3(1., 0.5, 0.);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    // 调整半径\n    float r = length(p) * 1.4;\n    // 颜色在这里设置\n    vec3 color =iColor;\n    \n    float timer=iTime / 1.2;\n    float a = pow(r, 2.0);\n    float b = sin(r * 0.8 - 1.6);\n    float c = sin(r - 0.010);\n    float s = sin(a - timer * 3.0 + b) * c;\n\n    color *= abs(1.0 / (s * 10.8)) - 0.01;\n    // 限制输出值\n    color.x = color.x>iColor.x?iColor.x:color.x;\n    color.y = color.y>iColor.y?iColor.y:color.y;\n    color.z = color.z>iColor.z?iColor.z:color.z;\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NtSSzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[33, 33, 90, 90, 687]]}
{"id": "NtSXDd", "name": "snow tape noise", "author": "zyc", "description": "snow tape noise", "tags": ["practice"], "likes": 4, "viewed": 48, "date": "1628844706", "time_retrieved": "2024-06-20T20:48:02.751277", "image_code": "\n#define t iTime\n\n//random hash\nvec4 hash42(vec2 p){\n    \n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(443.8975,397.2973, 491.1871, 470.7827));\n    p4 += dot(p4.wzxy, p4+19.19);\n    return fract(vec4(p4.x * p4.y, p4.x*p4.z, p4.y*p4.w, p4.x*p4.w));\n}\n\n\nfloat hash( float n ){\n    return fract(sin(n)*43758.5453123);\n}\n\n// 3d noise function (iq's)\nfloat n( in vec3 x ){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n//tape noise\nfloat nn(vec2 p){\n    float y = p.y;\n    float s = t*2.;\n    \n    float v = (n( vec3(y*.01 +s, \t\t\t1., 1.0) ) + .0)\n          \t *(n( vec3(y*.011+1000.0+s, \t1., 1.0) ) + .0) \n          \t *(n( vec3(y*.51+421.0+s, \t1., 1.0) ) + .0)   \n        ;\n    //v*= n( vec3( (fragCoord.xy + vec2(s,0.))*100.,1.0) );\n   \tv*= hash42(   vec2(p.x +t*0.01, p.y) ).x +.3 ;\n    \n    v = pow(v+.3, 1.);\n\tif(v<.7) v = 0.;  //threshold\n    return v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float linesN = 240.; //fields per seconds\n    float one_y = iResolution.y / linesN; //field line\n    vec2 uv2 = floor(uv*iResolution.xy/one_y)*one_y;\n\tfloat col =  nn(uv2);\n    \n    vec4 noiseColor = vec4(vec3(col), step(0.05, col));\n    vec4 texColor = texture(iChannel0, uv);\n    \n    // Output to screen\n\tfragColor = mix(texColor, noiseColor, noiseColor.a);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NtSXDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[18, 32, 52, 52, 241], [244, 244, 266, 266, 308], [310, 338, 359, 359, 761], [763, 776, 793, 793, 1202], [1205, 1205, 1262, 1312, 1719]]}
{"id": "NtSXRc", "name": "Foldable French fancy", "author": "evvvvil", "description": "Foldable French fancy - Result of an improvised live coding session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_\n", "tags": ["demoscene", "glow", "unwrap", "lights", "rotation", "fold", "fancy", "french", "neat", "reveal", "structure"], "likes": 34, "viewed": 437, "date": "1628180734", "time_retrieved": "2024-06-20T20:48:03.387676", "image_code": "// \"Foldable French fancy\" - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\n// \"The french are no good at war: they're too busy painting and fornicating.\" - Some British general who obviously didn't get laid much\n\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\nvec2 z,e=vec2(.00035,-.00035);float t,tt,b,bb,g,gg,gr,gt;vec3 np,pp,op,po,no,al,ld,rp; //GLOBAL VARIABLES\nfloat bo(vec3 p, vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);} //CHEAP BOX FUNCTION\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} //ROTATE FUNCTION\nconst mat2 deg45 = mat2(.7071,.7071,-.7071,.7071); //OPTIMIZE ROTATIONS IN LOOP THAT USE FIXED 45 DEG ROTATION\nvec4 texNoise(vec2 uv,sampler2D tex ){ float f = 0.; f+=texture(tex, uv*.125).r*.5; f+=texture(tex,uv*.25).r*.25; //Funciton simulating the perlin noise texture we have in Bonzomatic shader editor, written by yx\n                       f+=texture(tex,uv*.5).r*.125; f+=texture(tex,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nvec2 mp( vec3 p ,float ga){ \n  op=p; //REMEMBER ORIGINAL POSITION BEFORE WE FUCK WITH IT\n  p.z=mod(p.z-tt*2.,30.)-15.; //MAKE WHOLE SCENE INFINIT AND MOVE FORWARD\n  pp=p;   //SETUP MAIN POSITION\n  b=smoothstep(0.,1.,sin(op.z*.05+tt*.2+3.5)*.5+.5); //ANIM VARIABLE  \n  pp.xy=vec2(abs(abs(pp.x)-8.2)-(1.+4.*b),abs(pp.y));    //CLONE MAIN POS A COUPLE OF TIMES\n  pp.z=mod(pp.z,2.)-1.; //INFINITE MODULO MAIN POS TO REPEAT FOLDABLE BIT ALONG Z \n  rp=pp; //ROTATE POSITION BASED ON MAIN POSITION\n  rp.y-=4.*b+1.;  //SHIFT UP AND DOWN\n  rp.xy*=r2(b*6.28); //ROTATE MAIN POSITION\n  gr=gt=1.; //SETUP GREEBLES DETAILS\n  vec2 sca=vec2(0.5,1);  //SETUP SCALER\n  vec4 gp=vec4(p.xz*.5,rp.xy); //PACK BOTH GREEBLE DETAILS POSITIONS INTO ONE VEC4 - THIS IS TO OPTIMIZE AND REDUCE CODE LENGTH\n  for(int i=0;i<3;i++){ //FRACTAL GREEBLE BULLSHIT\n    gp=abs(gp)-1.5; //SYMETRY MOVE EACH ITER\n    gp.xy*=deg45; //ROTATE EACH ITER 45 DEG POSITION 1\n    gp.zw*=deg45;//ROTATE EACH ITER 45 DEG POSITION 2\n    gp*=.85;sca*=0.85; //EACH ITER WE SCALE DOWN A BIT\n    gr=min(gr,clamp(sin(gp.x*5.),-.25,.25)*.5*sca.x); //ADD ITERATION GREEBLE TO PREVIOUS GREEBLE DETAIL FOR GREEBLE ON FLOOR\n    gt=min(gt,clamp(sin(gp.z*5.),-.25,.25)*.5*sca.y); //ADD ITERATION GREEBLE TO PREVIOUS GREEBLE DETAIL FOR GREEBLE ON ROTATING OBJECTS\n  }\n  vec2 h,t=vec2(.75*bo(rp,vec3(1.,1.,1.-b*.2)),3);   //BLACK BOX\n  np=rp; np.xz*=r2(b*.785);  //BLACK BOX CUTTER POSITION\n  t.x=max(t.x,.7*bo(np-gt*.7*b,vec3(1.,1.,1.-b*.2))); //BLACK BOX CUTER    \n  vec3 sp=rp;sp.y-=2.6-sin(b*3.14)*7.25+b*3.; //SPHERE POSITON\n  t.x=min(t.x,0.7*max(length(rp.xz)-.1,abs(sp.y+1.-sin(b*3.14)*2.1)-1.)); //THIN BLACK CYLINDER  \n  float whiteCyl=0.6*max(abs(abs(length(rp.xz)-.5-gt*.5)-.1)-.05,abs(rp.y)-1.1-b*3.4);//WHITE CYLINDERS\n  h=vec2(whiteCyl,6); //ADD WHITE CYLINDER TO MATERIAL ID 6\n  h.x=min(h.x,length(rp.xy)-.2); //LONG Z WHITE CYLINDER\n  h.x=min(h.x,max(abs(length(abs(rp.yz)-.0)-.2*b)-.1,abs(rp.x)-1.1)); //LONG Z WHITE CYLINDER    \n  float spheres=0.7*(length(sp)-.1);  //GLOW SPHERES\n  h.x=min(h.x,spheres); //ADD GLOW SPHERES  TO MATERIAL ID 6\n  g+=1.0/(0.1+spheres*spheres*100.)*ga; //MAKE SPHERES GLOW\n  np=abs(p)-vec3(0,7,0); np.xy*=deg45;//GROUND DIGGER POSITION\n  pp=p;pp.y=abs(pp.y)-21.; //GROUND AND CEILING POSITION\n  float ter=0.8*bo(pp,vec3(50,10,200)-gr*2.); //GROUND AND CEILING\n  ter=max(ter,-0.9*bo(np,vec3(8,8,200)-gr*2.));//DIG TRIANGULAR SHAPE INTO GROUND\n  float vertCyl=length(rp.xz)-.15; //VERTICAL GLOW CYLINDER\n  bb=max(0.,(b-.9)*10.); //animation variable\n  vertCyl=max(vertCyl,abs(rp.y+5.*bb)-1.); //VERTICAL GLWO CYLINDER\n  vertCyl=min(vertCyl,0.7*max(length(rp.yz),abs(rp.x-1.)-2.2*bb)); //VERTICA GLOW CYLINDER CUT\n  gg+=1.0/(0.1+vertCyl*vertCyl*(200.-sin(bb+op.z*.2+tt*2.)*180.))*ga*bb; //GLOW CYLINDERS\n  h.x=min(h.x,vertCyl);  //ADD CYLINDER TO SCENE MATERIAL ID 6\n  t=t.x<h.x?t:h;//MERGE T AND H MATERIAL ID GEOMETRIES INTO SCENE\n  h=vec2(ter,7); //ADD GROUND / CEILING TO MATERIAL ID 7\n  t=t.x<h.x?t:h; //MERGE T AND H MATERIAL ID GEOMETRIES INTO SCENE\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd )//RAYMARCHING LOOP\n{\n  vec2 h,t=vec2(.1);//NEAR PLANE\n  for(int i=0;i<128;i++){//LOOOP MAX 128 STEPS\n  h=mp(ro+rd*t.x,1.);//GET DISTANCE TO GEOM\n    if(h.x<.0001||t.x>80.) break; //IF WE CLOSE ENOUGH OR IF WE TOO FAR, BREAK\n    t.x+=h.x;t.y=h.y;//BIG JUMP TO GEOMETRY IN NEXT ITERATION, REMEMBER MATERIAL ID\n  }  \n  if(t.x>80.) t.y=0.;//IF WE TOO FAR RETURN 0 MAT ID\n  return t;\n}\n#define a(d) clamp(mp(po+no*d,0.).x,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d,0.).x)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){ //LINES ABOVE ARE ambient ollcusion and sss\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);   //GET UVS  \n  tt=mod(iTime,57.973)+8.;//MOD TIME TO AVOID ARTIFACT\n  b=smoothstep(0.,1.,sin(tt*.2)*.5+.5); //ANIMATION VARIABLE\n  vec3 ro=mix(vec3(0,15.-15.*b,20.),vec3(-18.*sin(tt*.2),(10.-20.*ceil(sin(tt*.2)))*sign(sin(tt*.1)),15.),ceil(cos(tt*.2))),//RAY ORIGIN = CAMERA POSITION\n  cw=normalize(vec3(0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)), //CAMERA STUFF\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo; //CAMERA STUFF...\n  co=fo=vec3(.1,.15,.2)-length(uv)*.18+texNoise(rd.xz,iChannel0).r*.2; //BACKGROUND COLOUR\n  ld=normalize(vec3(-.2,.3,-.3));//LIGHT DIRECTION\n  z=tr(ro,rd);t=z.x; //RAYMARCH PIXEL\n  if(z.y>0.){//IF WE HIT SOMETHING THEN DO LIGHTING\n    po=ro+rd*t;//GET WHERE WE AT\n    no=normalize(e.xyy*mp(po+e.xyy,0.).x+e.yyx*mp(po+e.yyx,0.).x+e.yxy*mp(po+e.yxy,0.).x+e.xxx*mp(po+e.xxx,0.).x); //DERIVE NORMALS FROM WEHERE WE AT    \n    al=vec3(.05); //DEFAULT MATERIAL IS BLACK\n    if(z.y>5.)al=vec3(1.); //MATERIAL ID 6 IS WHITE\n    if(z.y>6.)al=mix(vec3(1.5),vec3(.05,.2,.5),sin(gr*60.)*.5+.5);//MATERIAL ID 7 IS WHITE + GREEBLE COLOUR\n    float dif=max(0.,dot(no,ld)), //DIFFUSE\n    fr=pow(1.+dot(no,rd),4.), //FRESNEL\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),40.); //SPECULAR\n    co=mix(sp+al*(a(.1)+.2)*(dif+s(2.)),fo,min(fr,.5));//FINAL LIGHTING RESULT\n    co=mix(fo,co,exp(-.00001*t*t*t)); //FOG\n  }\n  co+=g*.2*mix(vec3(.7,.3,0),vec3(1,.2,.1),1.-b)+gg*.2*vec3(.05,.2,.5);//ADD GLOWS\n  co=mix(co,co.zyx,length(uv)*.5); //CHEAP RADIAL UV SHADING\n  fragColor = vec4(pow(co,vec3(.55)),1); //GAMME CORRECTION\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NtSXRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[532, 551, 576, 576, 617], [618, 639, 656, 656, 699], [700, 829, 867, 867, 1161], [1162, 1162, 1189, 1189, 4213], [4214, 4214, 4261, 4261, 4621], [4713, 4713, 4769, 4813, 6456]]}
{"id": "NtSXWm", "name": "SmokeDMT", "author": "jj99", "description": "I smoked some drugs today", "tags": ["fbm"], "likes": 6, "viewed": 192, "date": "1627773417", "time_retrieved": "2024-06-20T20:48:03.387676", "image_code": "float hash( float n )\n{\n    return fract(sin(n)*758.5453)*2.;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x); \n    //f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + p.z*800.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n            mix(mix( hash(n+800.0), hash(n+801.0),f.x), mix( hash(n+857.0), hash(n+858.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm(vec3 p)\n{\n    float f = 0.0;\n    f += 0.50000*noise( p ); p = p*2.02+0.15;\n    f -= 0.25000*noise( p ); p = p*2.03+0.15;\n    f += 0.12500*noise( p ); p = p*2.01+0.15;\n    f += 0.06250*noise( p ); p = p*2.04+0.15;\n    f -= 0.03125*noise( p );\n    //return f/0.984375;\n    return f;\n}\n\nfloat cloud(vec3 p)\n{\n    p-=fbm(vec3(p.x,p.y,0.0)*0.5)*0.7;\n    \n    float a =0.0;\n    a-=fbm(p*3.0)*2.2-1.1;\n    if (a<0.0) a=0.0;\n    a=a*a;\n    return a;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\nvec3 hash33(vec3 p)\n{\n    const float UIF = (1.0/ float(0xffffffffU));\n    const uvec3 UI3 = uvec3(1597334673U, 3812015801U, 2798796415U);\n    uvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n\n// 3D Voronoi- (IQ)\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++)\n    {\n\t    for(int i = -1; i <= 1; i++)\n        {\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t    }\n\t}\n\treturn d;\n}\n\n// fbm layer\nfloat noiseLayers(in vec3 p) {\n\n    vec3 pp = vec3(0., 0., p.z + iTime*.09);\n    float t = 0.;\n    float s = 0.;\n    float amp = 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        t += voronoi(p + pp) * amp;\n        p *= 2.;\n        pp *= 1.5;\n        s += amp;\n        amp *= .5;\n    }\n    return t/s;\n}\n\nvec3 n2 (vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n        float dd = length(uv*uv)*.025;\n    \n\tvec3 rd = vec3(uv.x, uv.y, 1.0);\n    \n    float rip = 0.5+sin(length(uv)*20.0+iTime)*0.5;\n    rip = pow(rip*.38,4.15);\n    rd.z=1.0+rip*1.15;// apply a subtle ripple\n    rd = normalize(rd);\n    rd.xy *= rot(dd+iTime*.0125);\n    rd*=2.0;\n\t\n\tfloat c = noiseLayers(rd*1.85);\n    float oc = c;\n    c = max(c + dot(hash33(rd)*2. - 1., vec3(.006)), 0.);\n    c = pow(c*1.55,2.5);    \n    vec3 col =  vec3(.55,0.85,.25);\n    vec3 col2 =  vec3(1.4,1.4,1.4)*5.0;\n    float pulse2 = voronoi(vec3((rd.xy*1.5),iTime*.255));\n    float pulse = pow(oc*1.35,4.0);\n    col = mix(col,col2,pulse*pulse2)*c;\n    return col;\n\n}\n#define PI 3.14159\n\n\nfloat vDrop(vec2 uv,float t)\n{\nuv.y *= 0.25;\n    uv.x = uv.x*128.0;\t\t\t\t\t\t// H-Count\n    float dx = fract(uv.x);\n    uv.x = floor(uv.x);\n    uv.y *= 0.05;\t\t\t\t\t\t\t// stretch\n    float o=sin(uv.x*215.4);\t\t\t\t// offset\n    float s=cos(uv.x*33.1)*.3 +.7;\t\t\t// speed\n    float trail = mix(95.0,35.0,s);\t\t\t// trail length\n    float yv = fract(uv.y + t*s + o) * trail;\n    yv = 1.0/yv;\n    yv = smoothstep(0.0,1.0,yv*yv);\n    yv = sin(yv*PI)*(s*5.0);\n    float d2 = sin(dx*PI);\n    return yv*(d2*d2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n\tvec2 position = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tfloat ss = sin(length(position*2.0)+time*0.125)*1.5;\n\tss+=7.0;\n   \tvec2 coord = ss*position;\n    coord*=rot(ss*0.04+time*0.037);\n    coord*=0.34;\n    coord+=fbm(sin(vec3(coord*8.0,time*0.001)))*0.05;\n    coord+=time*0.0171;\n    float q = cloud((vec3(coord*1.0,0.222)));\n    coord+=time*0.0171;\n    q += cloud((vec3(coord*0.6,0.722)));\n    coord+=time*0.0171;\n    q += cloud(vec3(coord*0.3,.722));\n    coord+=time*0.1171;\n    q += cloud((vec3(coord*0.1,0.722)));\n    \n    \n\tfloat vv1 = sin(time+ss+coord.x)*0.3;\n\tfloat vv2 = sin(time*0.9+ss+coord.y)*0.2;\n\n    vec3 col = vec3(1.7-vv2,1.7,1.7+vv1) + vec3(q*vec3(0.7+vv1,0.5,0.3+vv2*1.15));\n\tcol = pow(col,vec3(2.2))*0.08;\n\t\n\tfloat dd = length(col*.48)+vv1;\n\t\n\tfloat nn = 0.5+sin(ss*2.7+position.x*2.41+time*0.9)*0.5;\n\t\n    vec3 col2 = n2(fragCoord)*0.9;\n    \n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float d = length(p);\n\tp = vec2(atan(p.x, p.y) / PI, 2.5 / d);\n    float t = time*0.014;\n    float drop = vDrop(p,t);\n    drop += vDrop(p,t+0.5);\n    drop*=d;\n    \n        col2+=(col*.565);\n    \n\tcol = mix(col,col2,nn);\n    col = mix(col,col*1.075,drop);\n    \n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NtSXWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 23, 23, 63], [65, 65, 91, 91, 440], [442, 442, 461, 461, 734], [736, 736, 757, 757, 895], [897, 897, 918, 918, 986], [989, 989, 1010, 1010, 1217], [1220, 1240, 1262, 1262, 1659], [1661, 1674, 1704, 1704, 1977], [1979, 1979, 2005, 2005, 2722], [2744, 2744, 2774, 2774, 3236], [3239, 3239, 3296, 3296, 4573]]}
{"id": "sd33zN", "name": "Neural Stanford Bunny (4 kb)", "author": "goingdigital", "description": "Based on Blackle's original work, with an alternative neural network structure and new training script.\n", "tags": ["bunny"], "likes": 17, "viewed": 339, "date": "1629241493", "time_retrieved": "2024-06-20T20:48:03.872563", "image_code": "// Fork of \"Neural Stanford Bunny (5 kb)\" by blackle. https://shadertoy.com/view/wtVyWK\n\n//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n// GoingDigital:\n// Ported to Tensorflow SIREN 3x12 / 12x12 / 12x12 / 12x1 network which is a little more compact.\n// Google Colab: https://colab.research.google.com/github/going-digital/ml_sdf/blob/main/ml_sdf.ipynb\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n  if (length(p) > 1.) return length(p)-.8;\n  vec4 x=vec4(p,1),\n    f00=sin(x*mat4(-1.74,-1.05,-1.82,2.64,-3.5,-4.23,2.91,-3.83,-.67,2.72,1.37,10.45,-1.46,-1.9,3.0,5.41)),\n    f01=sin(x*mat4(-3.12,-3.3,1.11,-1.54,2.91,-2.94,.82,-9.88,.92,1.34,2.62,2.71,1.16,1.04,-1.25,-9.69)),\n    f02=sin(x*mat4(3.42,-1.21,2.28,9.64,-2.02,1.15,1.83,-4.09,3.23,-.52,2.07,5.01,.52,-.6,3.35,.87)),\n    f10=sin(mat4(-.99,.53,-.28,.66,.15,-.02,-.09,-.06,-.01,-.05,-.04,-.56,-.1,-.31,-.83,-.43)*f00+mat4(.15,.04,-.09,.21,.42,-.23,.02,.17,.23,.31,.6,.56,-.93,1.47,.0,-.48)*f01+mat4(.71,-.44,-.18,.43,-.6,.42,.45,.5,-.92,.35,-.72,-.44,.0,.76,-.31,-.05)*f02+vec4(-13.95,-3.14,5.36,-9.25)),\n    f11=sin(mat4(-.54,-.75,-.21,-.24,-.38,.06,-.03,.55,.81,.51,-1.12,-.01,-.38,.11,-.02,.67)*f00+mat4(.11,.15,-.05,1.59,.04,-.23,-.18,-1.16,-.08,-.14,-.53,-.07,.23,-.36,-.4,-.15)*f01+mat4(.72,.28,-.18,-.61,.22,-.23,-.65,.28,.83,.41,.11,-.29,-.39,-.32,-.92,-.51)*f02+vec4(-4.81,6.95,9.26,-6.26)),\n    f12=sin(mat4(.73,.76,-.2,-1.04,-.46,.18,.21,1.15,-.06,-.43,.94,.13,.37,-.67,.6,.11)*f00+mat4(.38,.4,.04,.88,-.27,-1.18,.03,-.33,.14,1.54,.69,1.17,.37,1.3,.26,-1.7)*f01+mat4(.33,.42,-.4,-.97,-.23,.84,.42,-.1,-.67,.39,-.84,-.62,.45,.69,.37,1.29)*f02+vec4(-4.38,5.86,13.65,-9.16)),\n    f20=sin(mat4(-.39,.06,1.14,.07,-.06,-.82,.13,-.17,.19,-.79,-1.93,.11,-.39,-.02,-.48,-.05)*f10+mat4(-.51,-.77,-.35,-.02,.1,.47,-1.25,.08,-.1,-.3,1.4,.13,-.1,.21,-.59,.21)*f11+mat4(-.23,.03,-.68,-.08,.06,.15,1.01,-.11,-.27,-.01,-1.56,.02,-.34,.06,.51,.13)*f12+vec4(4.79,-5.84,7.28,4.74)),\n    f21=sin(mat4(.18,.07,.29,-.19,.59,-.03,-.27,.18,.05,.16,.17,-.06,.14,.36,-.24,.0)*f10+mat4(-.38,-.24,-.07,.23,.11,.1,.04,.55,.3,-.2,-.09,.03,.12,.13,.05,.01)*f11+mat4(-.09,.19,.08,.15,.18,.06,-.08,-.03,-.26,-.09,.15,.17,-.06,.07,.14,.19)*f12+vec4(-7.29,1.85,-4.88,.69)),\n    f22=sin(mat4(.32,-.19,.24,.29,.95,.0,.93,.07,1.3,-.76,-.57,-.45,.22,.87,-.6,.95)*f10+mat4(-.65,-.3,-.38,-.3,-.61,.58,-.78,1.04,-.32,-.06,.12,.59,-.94,-.06,-.04,-.07)*f11+mat4(.16,-.5,.46,1.24,.39,-.43,.28,-.91,-.76,-.98,-1.13,.27,-1.26,-.3,-.01,-.11)*f12+vec4(-6.24,1.26,-1.13,-13.77));\n  return dot(vec4(-.18,.16,.02,-.4),f20)+dot(vec4(-.18,-.51,-.55,.39),f21)+dot(vec4(.03,.08,.11,.05),f22)+.28;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>5.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    //don't ask how I stumbled on this texture\n    vec3 nz = p - erot(p, vec3(1), 2.) + erot(p, vec3(1), 4.);\n    float spec = length(sin(r*3.5+sin(nz*120.)*.15)*.4+.6)/sqrt(3.);\n    spec *= smoothstep(-.3,.2,scene(p+r*.2));\n    vec3 col = vec3(.1,.1,.12)*spec + pow(spec,8.);\n    float bgdot = length(sin(cam*8.)*.4+.6)/2.;\n    vec3 bg = vec3(.1,.1,.11) * bgdot + pow(bgdot, 10.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = smoothstep(-.02,1.05,sqrt(fragColor)) * (1.- dot(uv,uv)*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sd33zN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[283, 501, 539, 539, 601], [603, 603, 624, 624, 2838], [2840, 2840, 2859, 2859, 2975], [2977, 2977, 3034, 3034, 4302]]}
{"id": "sd3GW7", "name": "learning-the simplest 3d", "author": "luoruchong", "description": "learning-the simplest 3d", "tags": ["learning"], "likes": 0, "viewed": 25, "date": "1629946831", "time_retrieved": "2024-06-20T20:48:03.878651", "image_code": "float LineDist(vec3 ro, vec3 rd, vec3 p)\n{\n    return length(cross(rd, p-ro))/length(rd);\n}\n\nfloat DrawPoint(vec3 ro, vec3 rd, vec3 p)\n{\n    float d = LineDist(ro, rd, p);\n    d = smoothstep(0.05, 0.04, d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(3.*sin(t), 0., -3.*cos(t));\n    //vec3 rd = vec3(uv.x, uv.y, -2.)-ro;\n    \n    float zoom = 1.;\n    \n    vec3 lookat = vec3(.5);\n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    vec3 c = ro+f*zoom;\n    vec3 i = c+uv.x*r+uv.y*u;\n    vec3 rd = i-ro;\n    \n    float d = 0.;\n    d += DrawPoint(ro, rd, vec3(0., 0., 0.));\n    d += DrawPoint(ro, rd, vec3(1., 0., 0.));\n    d += DrawPoint(ro, rd, vec3(0., 1., 0.));\n    d += DrawPoint(ro, rd, vec3(1., 1., 0.));\n    d += DrawPoint(ro, rd, vec3(0., 0., 1.));\n    d += DrawPoint(ro, rd, vec3(1., 0., 1.));\n    d += DrawPoint(ro, rd, vec3(0., 1., 1.));\n    d += DrawPoint(ro, rd, vec3(1., 1., 1.));\n    \n    vec3 col = vec3(d);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sd3GW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 42, 42, 91], [93, 93, 136, 136, 222], [224, 224, 281, 281, 1182]]}
{"id": "sdc3R2", "name": "Tooth (neural volume)", "author": "harry7557558", "description": "I just see a lot of siren shaders and want to have a try.", "tags": ["volume", "tooth", "neural", "network", "siren"], "likes": 14, "viewed": 134, "date": "1630185108", "time_retrieved": "2024-06-20T20:48:04.793858", "image_code": "// Volume source: https://klacansky.com/open-scivis-datasets/ (1.43MB, modified)\n\n// Ground truth:\n// https://harry7557558.github.io/Graphics/raytracing/webgl_volume/index.html#volume=tooth&visual=skinbone&colormap=cThermometer&iso=0.500\n// (much faster rendering, looks better/worse?)\n\n// Trained in TensorFlow with Adam optimizer, mean squared error, equal weight for each voxel\n\n\n// Siren neural net, defined in -1 < x,y,z < 1\nfloat neuralVolume(in vec3 p) {\nvec4 f00=sin(p.x*vec4(.135,-.92,.997,.893)+p.y*vec4(.345,.911,-.651,-1.521)+p.z*vec4(-.825,.656,-.139,.463)+vec4(-.428,.988,-.046,-.945));\nvec4 f01=sin(p.x*vec4(.025,1.443,-1.637,.75)+p.y*vec4(-1.56,-1.163,-.861,.431)+p.z*vec4(-1.054,.9,.071,.182)+vec4(-.201,1.218,-.115,-.13));\nvec4 f02=sin(p.x*vec4(1.734,-.576,-2.458,1.011)+p.y*vec4(.851,.527,.45,3.14)+p.z*vec4(-1.08,-.05,.364,.691)+vec4(.826,-.068,.883,.768));\nvec4 f03=sin(p.x*vec4(.613,-1.078,-.187,-1.355)+p.y*vec4(.051,-2.254,1.874,-.106)+p.z*vec4(1.081,-1.454,2.599,1.164)+vec4(1.106,-.922,-.243,.976));\nvec4 f10=sin(mat4(.237,1.184,-.33,-.309,.159,-.064,-1.225,.508,-.225,-.165,.229,-.875,.076,.21,.066,-.435)*f00\n    +mat4(.314,1.199,.731,-.684,-.823,-.291,-.164,-.045,-.91,-.19,.737,-.423,-.123,.186,-.421,.414)*f01\n    +mat4(-.115,-.24,-.15,-.717,.602,.069,-.02,1.011,.675,.108,.622,-.361,.271,-.1,-.129,.324)*f02\n    +mat4(-.423,-.41,.885,-.368,.071,.488,.829,1.093,-.33,-.02,.687,.951,-.645,-.794,1.003,-1.404)*f03\n    +vec4(-.314,.42,.682,.317));\nvec4 f11=sin(mat4(.623,-.917,-.059,-.484,.052,-.276,.139,-.057,.517,.572,-.709,-.641,-.634,.198,-.309,.73)*f00\n    +mat4(.848,-.171,-1.178,-.745,-.204,-.572,-.527,-.213,1.727,.241,.068,.143,-.447,.469,.724,.306)*f01\n    +mat4(.76,-.992,.072,-.405,-.568,-.705,.697,.529,-.335,.303,.432,.145,.04,-.056,.288,.171)*f02\n    +mat4(-.274,.7,-.054,-.363,.056,-.209,.752,.272,-.394,.361,.048,.035,-.176,.607,-.182,.402)*f03\n    +vec4(.498,.69,.346,.271));\nvec4 f12=sin(mat4(-.002,-.7,.11,-.593,1.26,-.066,-.275,-.545,-.502,.698,.187,-.258,-.593,-.014,.767,.504)*f00\n    +mat4(-.788,-.514,-.677,.159,-.181,.25,1.02,.09,.432,-.637,-.284,-1.395,-.355,.422,.785,.94)*f01\n    +mat4(.921,1.168,-.1,-.368,.65,-.37,-.272,-.237,.1,-.382,-1.027,-.366,.283,-.588,.271,.115)*f02\n    +mat4(-.317,1.604,.237,.099,.279,-.171,-.186,-.055,-.186,.185,.531,.769,-1.034,-.079,.731,.179)*f03\n    +vec4(.315,.32,.234,-.247));\nvec4 f13=sin(mat4(.432,.461,-.251,-.908,.118,.238,-.62,.765,.697,.838,.623,-.889,.589,-1.182,.556,.012)*f00\n    +mat4(.439,.094,.068,-.764,-.284,-.376,-.227,.695,-.842,.786,.325,.366,.96,-.432,-1.067,-.669)*f01\n    +mat4(-1.989,-.098,-.284,-.049,.168,.028,-.32,.836,-.263,.361,.243,-.538,.396,.685,-.115,-.6)*f02\n    +mat4(.142,.179,-.491,-.033,.666,-.194,.313,-.496,.953,-.925,.257,.116,-.007,-.351,-.388,1.296)*f03\n    +vec4(-.286,.268,.283,.384));\nvec4 f20=sin(mat4(1.067,.576,.5,-1.351,1.617,.496,-.806,-.089,-.99,.11,.77,-.887,.573,.052,-1.012,1.272)*f10\n    +mat4(-.509,.281,.883,-.813,-.399,-1.383,-.242,1.315,-.499,.01,-.12,1.965,-.121,-.214,-2.116,-1.099)*f11\n    +mat4(.901,.547,.566,-2.171,-.461,-.476,.454,.768,-1.299,-.416,.3,-.383,.142,-.181,-.009,.49)*f12\n    +mat4(-.097,.154,.28,1.032,-.722,.505,-.243,-.543,-.404,-.341,-1.44,.607,-1.119,-.307,.489,-1.45)*f13\n    +vec4(-.528,.114,-1.355,.252));\nvec4 f21=sin(mat4(-.557,1.041,-.158,.194,-.752,.698,-.197,-.19,-.001,-.476,-.422,.448,-.181,.869,.953,-.999)*f10\n    +mat4(.201,.42,-.784,-.225,.706,-.481,-.053,-.872,.126,-.226,-.153,-.126,-.046,.366,-.939,-.012)*f11\n    +mat4(-.417,-.122,-1.034,.703,.524,-.386,.321,-.627,.381,.476,.171,-.402,.319,.038,.652,-.168)*f12\n    +mat4(-.266,.401,1.156,-.259,-.405,1.071,.893,.748,-.134,.318,.808,.448,.217,-.316,-.825,.276)*f13\n    +vec4(.122,.251,-.471,-.455));\nvec4 f22=sin(mat4(-.305,1.162,.973,-.676,.767,-1.133,1.428,-.979,-1.136,1.027,-1.219,.286,.618,.265,1.458,-.905)*f10\n    +mat4(.54,-.608,-.982,.567,.95,-.17,-.41,.435,-.303,.344,.365,.071,.476,-1.229,.844,-.176)*f11\n    +mat4(.638,-.702,.295,.409,.565,-.454,-1.215,.15,.073,-.058,-1.183,.654,.733,-.836,-.686,-.318)*f12\n    +mat4(.014,-.521,.263,-.234,-1.002,.819,.821,-.636,-1.256,-1.13,1.972,-.295,-.522,.21,-1.572,.714)*f13\n    +vec4(.185,-.447,.147,.098));\nvec4 f23=sin(mat4(-1.731,.056,.409,.383,.686,-.257,-.788,.816,-.286,.455,-.436,-.631,-.877,-.547,-.16,1.115)*f10\n    +mat4(.72,.585,1.283,-.416,-.108,.838,.228,-.616,-.188,-.517,-1.421,.339,-.07,.594,.406,1.143)*f11\n    +mat4(-.033,.243,1.652,.793,-.308,1.091,.522,-.488,-.253,.923,.113,-.276,-.714,-.292,-.316,-.049)*f12\n    +mat4(-.091,-.93,-.056,.757,-.748,-.943,-.746,.662,.657,-.903,-.781,.594,.302,.593,-1.175,-.572)*f13\n    +vec4(.231,-.572,.081,.417));\nvec4 f30=sin(mat4(.315,.409,.083,.363,-1.403,.808,-.4,-.939,-.884,.19,-.307,-.108,.514,-.2,.185,-.058)*f20\n    +mat4(-.128,.494,.029,-.702,.599,-.318,-.25,-.187,1.227,-.095,.094,-.128,.654,-.295,-.511,.316)*f21\n    +mat4(.183,.325,.106,.282,-.856,.088,-.24,-.001,.817,-.571,.114,-.437,-.973,.449,-.11,.282)*f22\n    +mat4(-.667,-.02,-.083,.162,.015,-.363,-.605,-.683,.239,-.088,.156,.159,.832,-.301,.224,.395)*f23\n    +vec4(.043,-.11,-.304,-.07));\nvec4 f31=sin(mat4(.473,.023,.568,.182,-.401,-.025,-.402,-1.307,-.338,-.286,.112,-.784,.107,.184,-.12,.415)*f20\n    +mat4(.373,-.005,-.018,-.133,.135,.298,-.421,.479,-.151,.395,-.615,.995,-.139,.448,-.313,.08)*f21\n    +mat4(.062,.051,.221,-.043,-.012,-.262,.467,-.65,.416,.164,-.003,.844,.042,-.205,-.186,-.835)*f22\n    +mat4(-.154,-.283,.331,-.52,-.621,.373,-.804,-.261,.298,-.063,.369,.261,.243,.142,-.225,.765)*f23\n    +vec4(-.224,-.446,.427,-.272));\nvec4 f32=sin(mat4(1.812,-.311,-.889,-.265,-2.924,-.344,2.515,-1.312,-2.656,.39,1.888,-.736,1.839,-.226,-1.219,.338)*f20\n    +mat4(.158,-.342,-.45,-.489,1.195,-.193,-.442,.789,1.664,-.668,-1.055,.804,.585,-.828,.254,-.43)*f21\n    +mat4(1.203,-.327,-.743,-.423,-2.251,.4,1.369,-.552,2.255,-.175,-1.347,.844,-.784,.501,.619,-.266)*f22\n    +mat4(-2.196,.307,1.213,-.512,-2.076,-.619,1.82,-.405,.963,-.051,-.593,.212,2.068,-.046,-1.471,.712)*f23\n    +vec4(1.433,-.302,-1.556,-.575));\nvec4 f33=sin(mat4(-1.071,.971,.6,-.127,.287,-.307,-.569,.175,.125,-.304,-.32,.016,-.145,.22,.04,-.074)*f20\n    +mat4(.326,-.204,.429,-.039,.521,-.318,-.023,-.054,.328,-.067,-.014,.046,.457,-.352,.354,-.259)*f21\n    +mat4(-.581,.496,.36,-.008,.203,-.336,-.024,.028,-.571,.695,-.111,-.28,.407,-.416,-.112,-.023)*f22\n    +mat4(.312,-.463,.008,-.018,.911,-.82,-.581,-.062,-.469,.448,.222,-.078,-.069,.165,.629,.03)*f23\n    +vec4(-.116,-.003,-.303,.134));\nreturn dot(vec4(-.43,-.112,-.491,.23),f30)+dot(vec4(.378,-.747,-.252,.696),f31)+dot(vec4(-.065,-.318,.122,-.303),f32)+dot(vec4(-.521,-.659,-.376,.469),f33)-.324;\n}\n\nconst vec3 BoxRadius = vec3(0.424, 0.398, 0.678);\n\nfloat map(vec3 p) {\n    p = p / BoxRadius;\n    return neuralVolume(-p);\n}\nvec3 mapNormal(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.001);\n    return -normalize(map(p) - vec3(map(k[0]),map(k[1]),map(k[2])));\n}\n\n// rendering quality\n#define STEP 0.01\n#define MAX_STEP 120.\n\n// adjust this number to see what happens\n#define uIso 0.5\n\n// light, comment the line in mainImage if you like\nvec3 light = normalize(vec3(0.5,0.5,1.0));\n\n// colormap - https://www.shadertoy.com/view/NsSSRK\nvec3 cThermometer(float t) {\n  float r = .453+.122*t+.385*cos(4.177*t-2.507);\n  float g = .284+.142*t+.554*cos(4.181*t-1.918);\n  float b = .464+.05*t+.475*cos(3.217*t-.809);\n  return vec3(r, g, b);\n}\n\n// constant step raymarching + volume sampling\nvec3 vSkinBone(in vec3 ro, in vec3 rd, float t0, float t1) {\n    float step_count = min(ceil((t1-t0)/STEP), MAX_STEP);\n    float t = t0, dt = (t1-t0) / step_count;\n    float iso1 = 1.0-uIso;\n    float iso2 = 0.5-0.5*uIso;\n    vec3 totcol = vec3(0.0);\n    float totabs = 1.0;\n    float v_old = 0.0, v;\n    for (t = t0; t < t1; t += dt) {\n        v = map(ro+rd*t);\n        vec3 col = clamp(cThermometer(v), 0.0, 1.0);\n        float absorb = abs(v-iso2)<0.2*(1.0-uIso) ? 20.0*uIso : 0.0;\n        totabs *= exp(-absorb*dt);\n        totcol += col*absorb*totabs*dt;\n        if (v > iso1) break;\n        v_old = v;\n    }\n    if (v < iso1) return totcol;\n    for (int s = 0; s < 4; s += 1) {\n        v_old = v;\n        dt *= -0.5;\n        for (int i = 0; i < 2; i++) {\n            t += dt;\n            v = map(ro+rd*t);\n            if ((v-iso1)*(v_old-iso1)<0.0) break;\n        }\n    }\n    vec3 n = mapNormal(ro+rd*t);\n    float col = 0.2+0.05*n.y+0.6*max(dot(n, light),0.0);\n    return totcol + col * totabs;\n}\n\n// ray intersection with a box\nbool boxIntersection(vec3 ro, vec3 rd, out float tn, out float tf) {\n    vec3 inv_rd = 1.0 / rd;\n    vec3 n = inv_rd*(ro);\n    vec3 k = abs(inv_rd)*BoxRadius;\n    vec3 t1 = -n - k, t2 = -n + k;\n    tn = max(max(t1.x, t1.y), t1.z);\n    tf = min(min(t2.x, t2.y), t2.z);\n    if (tn > tf) return false;\n    return true;\n}\n\n// main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // set camera\n    float rx = iMouse.z>0.?3.14*(iMouse.y/iResolution.y)-1.57:0.0;\n    float rz = iMouse.z>0.?-iMouse.x/iResolution.x*4.0*3.14:0.5*iTime-2.0;\n    rx += 1e-4, rz += 1e-4;  // prevent dividing by zero\n\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec3 ro = 4.0*w + 0.8*(uv.x*u+uv.y*v);\n    vec3 rd = -w;\n\n    // comment this line if you wish\n    light = normalize(w+0.5*u+0.1*v);\n\n    // calculate pixel color\n    float t0, t1;\n    if (!boxIntersection(ro, rd, t0, t1)) {\n        fragColor = vec4(vec3(0.0), 1.0);\n        return;\n    }\n    vec3 col = vSkinBone(ro, rd, t0, t1);;\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdc3R2.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[383, 430, 461, 461, 6658], [6711, 6711, 6730, 6730, 6784], [6785, 6785, 6809, 6809, 6920], [7140, 7192, 7220, 7220, 7391], [7393, 7440, 7500, 7500, 8443], [8445, 8476, 8544, 8544, 8793], [8795, 8803, 8858, 8877, 9653]]}
{"id": "sdcGWH", "name": "RayMarching Army", "author": "CannaVizion", "description": "Thanks to @iq @BigWIngs for their time sharing their knowledge and specially to @samlo because today I learnt how to colorize different objects! \nCheck https://www.shadertoy.com/view/wd2SR3 !\nAnd now with fog thanks to @FabriceNeyret2 !", "tags": ["raymarching", "sdf", "instances", "instancing", "army"], "likes": 9, "viewed": 201, "date": "1629676780", "time_retrieved": "2024-06-20T20:48:07.624537", "image_code": "//Second shader after watching some tutorials from The Art of Code (AKA BigWIngs) https://www.youtube.com/c/TheArtofCodeIsCool/videos\n//and getting some code from Iñigo Quilez (https://iquilezles.org/www/articles/distfunctions/distfunctions.htm)\n//Also many thanks to @samlo for his great explanation on how to colorize diferent objects https://www.shadertoy.com/view/wd2SR3\n//First steps... totally unoptimized and I still get some artifacts on the feet and the shadows\n//Starts dropping frames when in fullscreen @4K\n//This one is inspired on a video I saw about the Chinese army\n//Play around with Camera Rotation and/or Mouse Rotation\n//It's a pitty I can't add a song that matches the rhythm (something seems to be wrong when importing links from SoundCloud) \n//Feedback appreciated!\n//---Edit:\n//Added fog thanks to @FabriceNeyret2!!\n//---Edit:\n//And now with Phong illumination!\n//I replaced the previous code (see bellow) with a fork of Ray Marching Phong Template by @alijaya https://www.shadertoy.com/view/4t2fR1\n//where I added the color picking system I learnt from @samlo\n\n\n#define EPSILON 0.01\n#define MIN_DISTANCE 0.1 \n#define MAX_DISTANCE 100.0\n#define MAX_MARCHING_STEP 200\n\n#define CAM_ROTATION 1\n#define MOUSE_CAM_ROT 0\n#define HEAD_ROTATION 0                 \n#define SHADOWS 1                       //change it to 0 to disable shadows\n\n#define DARK_ID 0.\n#define CLOTH_ID 1.\n#define SKIN_ID 2.\n#define WHITE_ID 3.\n#define GROUND_ID 4.\n\n#define time iTime*4.\n#define PI 3.14159265\n\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction, always normalized\n};\n\nstruct Camera {\n    vec3 pos;\n    vec3 lookAt;\n    float focal;\n    vec2 sensorSize;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n};\n    \nvec3 xe = vec3(EPSILON, 0., 0.);\nvec3 ye = vec3(0., EPSILON, 0.);\nvec3 ze = vec3(0., 0., EPSILON);\n\nfloat max3 (vec3 v) {\n  return max (max (v.x, v.y), v.z);\n}\n\nmat2 rotMat(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2 (c,-s,s,c);\n}\n\n\n// get corresponding ray from uv (0.0 -> 1.0)\nRay getRay( Camera cam, vec2 uv ) {\n    vec3 camDir = normalize(cam.lookAt - cam.pos); // the camera direction\n    vec3 center = cam.pos + cam.focal * camDir; // get the coordinate of the screen center\n    vec2 coord = (uv - 0.5) * cam.sensorSize; // convert from 0.0 -> 1.0 to -sensorSize / 2. -> sensorSize / 2.\n    \n    // axis relative to camera\n    vec3 zpos = -camDir; // k hat, outward the screen\n    vec3 xpos = cross(vec3(0., 1., 0.), zpos); // i hat, cross from ypos global and zpos local\n    vec3 ypos = cross(zpos, xpos); // j hat, cross from zpos local and xpos local\n    \n    // target in screen\n    vec3 target = center + coord.x * xpos + coord.y * ypos; // get pixel target coordinate from the screen\n    \n    Ray ray;\n    ray.o = cam.pos; // the origin of the ray is from the camera duh\n    ray.d = normalize(target - cam.pos); // the direction is from the camera to the target\n    \n    return ray;\n}\n\n// project point to ray\nvec3 projPoint2Ray( vec3 point, Ray ray ) {\n    vec3 rel = point - ray.o; // get relative vector from the point to the ray origin\n    float len = dot(rel, ray.d); // project that vector to vector direction of the ray, we get the length\n    return len * ray.d + ray.o; // multiply the length with unit vector direction and add to ray origin\n}\n\n// get the distance from point to ray (or line)\nfloat distPoint2Ray( vec3 point, Ray ray ) {\n    vec3 proj = projPoint2Ray(point, ray); // project it first to the ray\n    return distance(proj, point); // get the distance from the projected position to the original position\n}\n\n// just linear interpolation, map value v between fromA and fromB to between toA and toB\nfloat lerp( float v, float fromA, float fromB, float toA, float toB ) {\n    return (v - fromA) / (fromB - fromA) * (toB - toA) + toA;\n}\n\n\n// box function\nfloat sdBox( vec3 p, vec3 s ) {\n    vec3 d = abs(p) - s;\n    return max(d.x, max(d.y, d.z));\n}\n\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nvec3 opRep( in vec3 p, in vec3 c )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q ;\n}\n\nfloat add (inout vec2 a, vec2 b){\n    a = mix(a,b,step(b.x,a.x));\n    return 0.;\n}\n\nvec2 sdScene( vec3 p ) {\n    vec3 armSize = vec3 (.2,.4,.2);                           //Arms Size\n    vec3 handSize = vec3 (.2,.2,.13);          \n    vec3 legSize = vec3 (.22,.8,.2);\n    vec3 bodySize = vec3 (.6,1.,.3);\n    vec3 headSize = vec3(.3,.35,.3);\n    vec3 footSize = vec3(.2,.1,.43);\n    vec3 capSize = vec3(.36,.1,.45);\n\n    vec3 clothColor = vec3(0.027,0.27,0.05);\n    vec3 skinColor = vec3(0.764,0.6,0.552);\n\n    vec3 pG = p;\n    pG.z += mod(time,4.);                                                //Global Position\n    pG = opRep(pG,vec3(3,0,4));\n    vec3 pB = pG;                                               //Body Position\n    vec3 pH = pG -vec3(0,bodySize.y+headSize.y+0.05,0);         //Head Position\n#if HEAD_ROTATION \n    pH.xz *= rotMat(-sin(time)*.5);                               //Head Rotation\n#endif\n    vec3 pCap = pH - vec3(0,headSize.y+capSize.y-.05,-capSize.z/3.3);                                               \n    vec3 pShouldL = pG - vec3 (-(bodySize.x+armSize.x+0.05),bodySize.y,0);   //Shoulder Position\n    pShouldL.yz *= rotMat(sin(time));                          //Shoulder Rotation    \n    vec3 pArmL = pShouldL + vec3 (0,armSize.y,0);               //Arm Position\n    vec3 pForeL = pShouldL-vec3(0,-2.*armSize.y-0.05,0);                       //Forearm Position\n    pForeL.xz *= rotMat(radians(90.));                           //Forearm Rotation\n    pForeL.yz *= rotMat(clamp(-sin(time)*PI/2.,0.,PI/2.));\n    pForeL += vec3(0,armSize.y,0);                             //Forearm Anchor P reposition\n    vec3 pHandL = pForeL-vec3(0,-armSize.y-handSize.y-0.05,0);\n    pHandL.xz *= rotMat(-1.*clamp(-sin(time)*PI,0.,PI/2.)+PI);    \n    vec3 pLegL = pB - vec3(-.4,-bodySize.y-.05,0);\n    pLegL.yz *= rotMat(-sin(time));\n    pLegL += vec3(0,legSize.y,0);\n    vec3 pFootL = pLegL - vec3(0,-legSize.y-footSize.y-0.05,-footSize.z/2.);\n\n    vec3 pShouldR = pG - vec3(bodySize.x+armSize.x+0.05,bodySize.y,0);\n    pShouldR.yz *= rotMat(-sin(time));\n    vec3 pArmR = pShouldR + vec3 (0,armSize.y,0);;\n    vec3 pForeR = pShouldR-vec3(0,-2.*armSize.y-0.05,0);\n    pForeR.xz *= rotMat(radians(-90.));\n    pForeR.yz *= rotMat(clamp(sin(time)*PI/2.,0.,PI/2.));\n    pForeR += vec3(0,armSize.y,0);\n    vec3 pHandR = pForeR-vec3(0,-armSize.y-handSize.y-0.05,0);\n    pHandR.xz *= rotMat(-1.*clamp(-sin(time)*PI,-PI/2.,0.)+PI);\n    vec3 pLegR = pB - vec3(.4,-bodySize.y-.05,0);\n    pLegR.yz *= rotMat(sin(time));\n    pLegR += vec3(0,legSize.y,0);\n    vec3 pFootR = pLegR - vec3(0,-legSize.y-footSize.y-0.05,-footSize.z/2.);\n\n\n    vec2 body = vec2(sdBox(pB,bodySize),CLOTH_ID);\n    vec2 head = vec2(sdBox(pH,headSize),SKIN_ID);\n    vec2 cap = vec2(sdBox(pCap,capSize)*.5,CLOTH_ID);                      \n    \n    vec2 armL = vec2(sdBox (pArmL,armSize),CLOTH_ID); \n    vec2 foreL = vec2(sdBox(pForeL,armSize),CLOTH_ID);\n    vec2 handL = vec2(sdBox(pHandL,handSize),WHITE_ID);\n    vec2 legL = vec2(sdBox(pLegL,legSize),CLOTH_ID);\n    vec2 footL = vec2(sdBox(pFootL,footSize)*.5,DARK_ID);\n\n    vec2 armR = vec2(sdBox(pArmR,armSize),CLOTH_ID);\n    vec2 foreR = vec2(sdBox(pForeR,armSize),CLOTH_ID);\n    vec2 handR = vec2(sdBox(pHandR,handSize),WHITE_ID);\n    vec2 legR = vec2(sdBox(pLegR,legSize),CLOTH_ID);\n    vec2 footR = vec2(sdBox(pFootR,footSize)*.5,DARK_ID);\n\n    vec2 floor = vec2(sdPlane(p,vec3(0,1.,0),3.),GROUND_ID);\n    // vec2 floor = vec2(p.y+3,GROUND_ID);\n\n    vec2 result = body;\n    // result = mix(result,head,step(head.x,result.x));\n    // result = mix(result,cap,step(cap))\n    add (result,head);\n    add (result,cap);\n    add (result,armL);\n    add (result,foreL);\n    add (result,handL);\n    add (result,legL);\n    add (result,footL);\n    add (result,armR);\n    add (result,foreR);\n    add (result,handR);\n    add (result,legR);\n    add (result,footR);\n    add (result,floor);\n\n    return result;\n}\n\n// estimate normal with nudging\nvec3 estimateNormal( vec3 p ) {\n    return normalize(vec3(\n        sdScene(p+xe).x - sdScene(p-xe).x,\n        sdScene(p+ye).x - sdScene(p-ye).x,\n        sdScene(p+ze).x - sdScene(p-ze).x\n    ));\n}\n\n// ray marching algorithm\nvec2 getSDF( Ray r ) {\n    float depth = MIN_DISTANCE;\n    float matID;\n    for (int i=0; i<MAX_MARCHING_STEP; i++) {\n        float dist = sdScene( r.o + depth * r.d ).x;\n        matID = sdScene (r.o + depth * r.d).y;\n        \n        if (dist < EPSILON) { // inside a scene\n            return vec2(depth,matID);\n        }\n        \n        depth += dist; // circle marching!\n        \n        if (depth >= MAX_DISTANCE) {\n            return vec2(MAX_DISTANCE,matID);\n        }\n    }\n    \n    return vec2(MAX_DISTANCE,matID);\n}\n\nvec3 ambientLight( vec3 ambientColor ) {\n    return ambientColor;\n}\n\nvec3 phongLight( vec3 diffuseColor, vec3 specularColor, float shininess, Ray ray, float dist, Light light ) {\n    vec3 p = ray.o + dist * ray.d;\n    \n    vec3 N = estimateNormal(p); // surface normal\n    vec3 L = normalize(light.pos - p); // surface to light direction\n    vec3 V = -ray.d; // surface to camera direction\n    vec3 R = reflect(-L, N); // mirror of L by the axis N\n    \n    float dotLN = dot(L, N); // project light direction to surface normal\n    float dotRV = dot(R, V); // project light reflection direction to direction to camera\n    \n    vec3 color = vec3(0.);\n    if (dotLN > 0.) { // we can see the diffuse\n        color += diffuseColor * dotLN;\n    } \n    if (dotRV > 0.) { // we can see the specular\n        color += specularColor * pow(dotRV, shininess);\n    }\n    color *= light.color; // influence of color of the light\n#if SHADOWS\n    float dif = clamp(dotLN*.5+0.5,0.,1.);\n    vec3 n = estimateNormal(p);\n    Ray shadow;\n    shadow.o = p+n*EPSILON;\n    shadow.d = L; \n    float d = getSDF(shadow).x;\n    if (d<length(light.pos-p)) color *=.1;\n#endif\n\n    return color;\n}\n\n\nvec3 calcMaterial (float id) {\n    if (id == DARK_ID)      return vec3(.1, .1, .1);\n    if (id == CLOTH_ID)     return vec3(61., 74., 37.)/256.;\n    if (id == SKIN_ID)     return vec3(0.764,0.6,0.552);\n    if (id == WHITE_ID)     return vec3(1.);\n    if (id == GROUND_ID)     return vec3(.4);\n    return vec3(.2);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // convert from fragCoord (0.0 -> iResolution.xy) to uv (0.0 -> 1.0)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 m  = iMouse.xy/iResolution.xy;\n    vec3 circleMovement = vec3(600. * cos(iTime * 2.), 600. * cos(iTime * 2.), 600. * sin(iTime * 2.)); // to get circle movement\n    \n    // set camera\n    Camera cam;\n    cam.sensorSize = iResolution.xy; // set sensor size to the screenSize\n    cam.focal = 400.; // set the focal length (distance between sensor (screen) to the aperture\n    cam.lookAt = vec3(0., 1., 0.); // where to look at (this camera use two point system)\n    cam.pos = vec3(0,4,-4.2);//circleMovement; // the position of the camera#if CAM_ROTATION\n#if CAM_ROTATION\n    cam.pos = vec3 (sin(time*.1)*8.,7.+sin(time*.05)*4.,cos(time*.1)*8.);\n#endif\n#if MOUSE_CAM_ROT\n    cam.pos.yz *= rotMat(m.y*3.14);\n    cam.pos.xz *= rotMat(-m.x*6.2831);\n#endif\n    // get ray\n    Ray ray = getRay(cam, uv); // get corresponding ray, given the uv\n\n    \n    // render\n    float dist = getSDF(ray).x;\n    float colID = getSDF(ray).y;\n\n\n    if (dist > MAX_DISTANCE - EPSILON) { // don't hit anything, set to background\n        fragColor = vec4(vec3(.7,.8,1.),1);\n        return; // or discard?\n    }\n    \n    vec3 ambientColor = vec3(0.1);\n    vec3 diffuseColor = calcMaterial(colID);\n    vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    float shininess = 50.0;\n    \n    Light light1;\n    light1.pos = vec3(0,4,-5);\n    light1.color = vec3(1);\n    \n    // Light light2;\n    // light2.pos = vec3(4,4,4);\n    // light2.color = vec3(1);\n    \n    vec3 color = vec3(0.);\n    color += ambientLight(ambientColor);\n    color += phongLight(diffuseColor, specularColor, shininess, ray, dist, light1);\n    \n    color = mix(vec3(.7,.8,1.), color, exp(-max(0.,dist-12.)/20.)  );\n    // color += phongLight(diffuseColor, specularColor, shininess, ray, dist, light2);\n    fragColor = vec4(color, 1.);\n}\n\n\n\n\n/* OLD_CODE\n\n#define HEAD_ROTATION 1\n#define CAM_ROTATION 1\n#define MOUSE_CAM_ROT 0\n\n#define time iTime*4.\n\n#define MAX_STEPS 120\n#define MAX_DIST 60.\n#define SURF_DIST 0.001\n\n\n#define DARK_ID 0.\n#define CLOTH1_ID 1.\n#define CLOTH2_ID 1.5\n#define SKIN_ID 2.\n#define WHITE_ID 3.\n#define GROUND_ID 4.\n\n\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat max3 (vec3 v) {\n  return max (max (v.x, v.y), v.z);\n}\n\nmat2 rotMat(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2 (c,-s,s,c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+max3(min(p, vec3(0)))-0.02;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat add (inout vec2 a, vec2 b){\n    a = mix(a,b,step(b.x,a.x));\n    return 0.;\n}\nvec3 opRep( in vec3 p, in vec3 c )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q ;\n}\n\nvec2 GetDist (vec3 p){\n    \n    vec3 armSize = vec3 (.2,.4,.2);                           //Arms Size\n    vec3 handSize = vec3 (.2,.2,.13);          \n    vec3 legSize = vec3 (.22,.8,.2);\n    vec3 bodySize = vec3 (.6,1.,.3);\n    vec3 headSize = vec3(.3,.35,.3);\n    vec3 footSize = vec3(.2,.1,.43);\n    vec3 capSize = vec3(.36,.1,.45);\n\n    vec3 pG = p;\n    pG.z += mod(time,4.);                                                //Global Position\n    pG = opRep(pG,vec3(3,0,4));\n    vec3 pB = pG;                                               //Body Position\n    vec3 pH = pG -vec3(0,bodySize.y+headSize.y+0.05,0);         //Head Position\n#if HEAD_ROTATION \n    pH.xz *= rotMat(-sin(time)*.5);                               //Head Rotation\n#endif\n    vec3 pCap = pH - vec3(0,headSize.y+capSize.y-.05,-capSize.z/3.3);                                               \n    vec3 pShouldL = pG - vec3 (-(bodySize.x+armSize.x+0.05),bodySize.y,0);   //Shoulder Position\n    pShouldL.yz *= rotMat(sin(time));                          //Shoulder Rotation    \n    vec3 pArmL = pShouldL + vec3 (0,armSize.y,0);               //Arm Position\n    vec3 pForeL = pShouldL-vec3(0,-2.*armSize.y-0.05,0);                       //Forearm Position\n    pForeL.xz *= rotMat(radians(90.));                           //Forearm Rotation\n    pForeL.yz *= rotMat(clamp(-sin(time)*PI/2.,0.,PI/2.));\n    pForeL += vec3(0,armSize.y,0);                             //Forearm Anchor P reposition\n    vec3 pHandL = pForeL-vec3(0,-armSize.y-handSize.y-0.05,0);\n    pHandL.xz *= rotMat(-1.*clamp(-sin(time)*PI,0.,PI/2.)+PI);    \n    vec3 pLegL = pB - vec3(-.4,-bodySize.y-.05,0);\n    pLegL.yz *= rotMat(-sin(time));\n    pLegL += vec3(0,legSize.y,0);\n    vec3 pFootL = pLegL - vec3(0,-legSize.y-footSize.y-0.05,-footSize.z/2.);\n\n    vec3 pShouldR = pG - vec3(bodySize.x+armSize.x+0.05,bodySize.y,0);\n    pShouldR.yz *= rotMat(-sin(time));\n    vec3 pArmR = pShouldR + vec3 (0,armSize.y,0);;\n    vec3 pForeR = pShouldR-vec3(0,-2.*armSize.y-0.05,0);\n    pForeR.xz *= rotMat(radians(-90.));\n    pForeR.yz *= rotMat(clamp(sin(time)*PI/2.,0.,PI/2.));\n    pForeR += vec3(0,armSize.y,0);\n    vec3 pHandR = pForeR-vec3(0,-armSize.y-handSize.y-0.05,0);\n    pHandR.xz *= rotMat(-1.*clamp(-sin(time)*PI,-PI/2.,0.)+PI);\n    vec3 pLegR = pB - vec3(.4,-bodySize.y-.05,0);\n    pLegR.yz *= rotMat(sin(time));\n    pLegR += vec3(0,legSize.y,0);\n    vec3 pFootR = pLegR - vec3(0,-legSize.y-footSize.y-0.05,-footSize.z/2.);\n\n\n    vec2 body = vec2(sdBox(pB,bodySize),CLOTH1_ID);\n    vec2 head = vec2(sdBox(pH,headSize),SKIN_ID);\n    vec2 cap = vec2(sdBox(pCap,capSize),CLOTH2_ID);                      \n    \n    vec2 armL = vec2(sdBox (pArmL,armSize),CLOTH1_ID); \n    vec2 foreL = vec2(sdBox(pForeL,armSize),CLOTH1_ID);\n    vec2 handL = vec2(sdBox(pHandL,handSize)*.5,WHITE_ID);\n    vec2 legL = vec2(sdBox(pLegL,legSize),CLOTH2_ID);\n    vec2 footL = vec2(sdBox(pFootL,footSize),DARK_ID);\n\n    vec2 armR = vec2(sdBox(pArmR,armSize),CLOTH1_ID);\n    vec2 foreR = vec2(sdBox(pForeR,armSize),CLOTH1_ID);\n    vec2 handR = vec2(sdBox(pHandR,handSize)*.5,WHITE_ID);\n    vec2 legR = vec2(sdBox(pLegR,legSize),CLOTH2_ID);\n    vec2 footR = vec2(sdBox(pFootR,footSize),DARK_ID);\n\n    vec2 floor = vec2(sdPlane(p,vec3(0,1.,0),3.),GROUND_ID);\n    // vec2 floor = vec2(p.y+3,GROUND_ID);\n\n    vec2 result = body;\n    // result = mix(result,head,step(head.x,result.x));\n    // result = mix(result,cap,step(cap))\n    add (result,head);\n    add (result,cap);\n    add (result,armL);\n    add (result,foreL);\n    add (result,handL);\n    add (result,legL);\n    add (result,footL);\n    add (result,armR);\n    add (result,foreR);\n    add (result,handR);\n    add (result,legR);\n    add (result,footR);\n    add (result,floor);\n\n    return result;\n}\n\nvec3 calcMaterial (float id) {\n    if (id == DARK_ID)      return vec3(.1, .1, .1);\n    if (id == CLOTH1_ID)     return vec3(92., 112., 56.)/256.;\n    if (id == CLOTH2_ID)    return vec3(61., 74., 37.)/256.;\n    if (id == SKIN_ID)     return vec3(0.764,0.6,0.552);\n    if (id == WHITE_ID)     return vec3(1.);\n    if (id == GROUND_ID)     return vec3(.4);\n    return vec3(.2);\n}\n\nvec4 RayMarch (vec3 ro, vec3 rd){\n    float dO = 0.;\n    vec3 color;\n\n    for (int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p).x;\n        float matID = GetDist(p).y;\n        color = calcMaterial(matID);\n        dO += dS;\n        if (dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n\n    }    \n    \n    return vec4(color,dO);\n}\n\nvec3 GetNormal (vec3 p){\n    vec2 d = GetDist(p);\n    vec2 e = vec2(0.01,0);\n\n    vec3 n = d.x - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3 (1.,10.,-10.);\n    //lightPos.xz += vec2(sin(time),cos(time));\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal (p);\n    float dif = clamp(dot(n,l)*.5+0.5,0.,1.);\n    float d = RayMarch(p+n*SURF_DIST*2.,l).w;\n    if (d<length(lightPos-p)) dif *= .1;  //Shadows\n\n    return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1.,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 m  = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0.);        //vec3(0.,.3,.6)*smoothstep(-0.1,1.,length(uv.y));\n\n    vec3 ro = vec3 (0,4,-4.2);\n#if CAM_ROTATION\n    ro = vec3 (sin(time*.1)*8.,7.+sin(time*.05)*4.,cos(time*.1)*8.);\n#endif\n#if MOUSE_CAM_ROT\n    ro.yz *= rotMat(m.y*3.14);\n    ro.xz *= rotMat(-m.x*6.2831);\n#endif\n    vec3 la = vec3(0,0,1.);\n    vec3 rd = R(uv, ro, la,.7);\n\n    float d = RayMarch(ro,rd).w;\n    vec3 c = RayMarch(ro,rd).xyz;\n    if (d<MAX_DIST){\n        vec3 p = ro + rd*d;\n        float difuse = GetLight(p);\n        difuse = pow(difuse,.4545);\n        col= vec3(difuse)*c;\n\n    }\n\n    col = mix(vec3(.8,.9,1.), col, exp(-max(0.,d-12.)/30.)  );  //Thanks to FabriceNeyret2 for the fog!\n    //col = mix(vec3(.8,.9,1.), col, exp(-d/90.)  );\n    fragColor = vec4 (col,1.);\n\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdcGWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 1828, 1849, 1849, 1887], [1889, 1889, 1910, 1910, 1984], [1987, 2033, 2068, 2068, 2950], [2952, 2976, 3019, 3019, 3317], [3319, 3367, 3411, 3411, 3594], [3596, 3685, 3756, 3756, 3820], [3823, 3839, 3870, 3870, 3933], [3936, 3936, 3978, 4004, 4029], [4031, 4031, 4067, 4067, 4119], [4121, 4121, 4154, 4154, 4203], [4205, 4205, 4229, 4229, 8044], [8046, 8078, 8109, 8109, 8274], [8276, 8302, 8324, 8324, 8827], [8829, 8829, 8869, 8869, 8896], [8898, 8898, 9007, 9007, 9996], [9999, 9999, 10029, 10029, 10314], [10319, 10319, 10375, 10448, 12273]]}
{"id": "sdd3DM", "name": "Ordered dither with TPDF offsets", "author": "mystran", "description": "Here we try using 2x2 ordered dither to get 4x \"fake quantization levels\" and then dither those levels with TPDF to even out the expected value. Idea is that the ordered part puts the bulk of the noise at high frequencies without having to filter.\n", "tags": ["dithertest"], "likes": 1, "viewed": 78, "date": "1629988716", "time_retrieved": "2024-06-20T20:48:07.951759", "image_code": "\nconst float levels = 4.; // number of quantisation levels, must be at least 2\n\nuint hash(uint x)\n{\n    x ^= x >> 16; x *= 0x7feb352du; \n    x ^= x >> 15; x *= 0x846ca68bu; \n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash2tf(uint x, uint y)\n{\n    // take a hash, split it into components\n    uint h = hash(uint(x)+(uint(y)<<16));\n    \n    return float((h>>16)+(h&0xffffu)) / float(0xffffu);\n}\n\nvec3 dither(vec3 c, uvec2 xy)\n{\n    uint t = uint(iFrame);\n    // compute noise\n    float h = hash2tf(xy.x + t*12345u, xy.y) - 1.;\n    \n    // shift the rows of the ordered dither every other frame\n    // this gives a more even checkerboard pattern over time\n    h += float( ((xy.x^xy.y)&1u)*2u + ((t^xy.y)&1u)) - 1.75;\n    \n    // normalizing to 1 step allows some banding in the ordered dither\n    // dividing by 2 instead should mostly avoid this at the cost of more noise\n    h *= 1./4.;\n    \n    float g = levels-1.;\n    return clamp(round(c*g + h) / g, 0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 c = texture(iChannel0,uv.xy).xyz;\n    \n    if(abs(iMouse.x - fragCoord.x) < iResolution.x*.25) \n    {\n        c = dither(c, uvec2(fragCoord.xy));\n    }\n\telse if(iMouse.y < .5*iResolution.y) c = round(c*(levels-1.)) / (levels-1.);\n    \n    \n    // Output to screen\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdd3DM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[26, 80, 99, 99, 207], [209, 209, 240, 285, 390], [392, 392, 423, 423, 960], [962, 962, 1019, 1069, 1415]]}
{"id": "sdd3R4", "name": "Conformal Torus Texture Mapping2", "author": "FabriceNeyret2", "description": "right: naive tiling of the torus\nleft: conformal mapping\n( simpler approach than https://www.shadertoy.com/view/tdGfzz )", "tags": ["torus", "uv", "conformal", "short"], "likes": 24, "viewed": 279, "date": "1629297421", "time_retrieved": "2024-06-20T20:48:08.188083", "image_code": "#define hue(v)  ( .6 + .6 * cos( v  + vec4(0,23,21,0)  ) )    // hue\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )              // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.,d,  k = 2., // .9                              // tile multiplier\n          R0 = 20., R1 = 10.;                                 // large and small radii\n\n    vec3  R = iResolution,\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),          // ray direction\n          p = 90./R, q,                                       // marching point along ray \n       // M =  iMouse.xyz/R -.5;\n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0));\n     \n    for ( O=vec4(0) ; O.x < 1. && t > .01 ; O+=.01 )\n        q = p,\n        q.yz *= rot( .5+6.*M.y),                              // rotations\n        q.xz *= rot( 2.-6.*M.x),\n        t = min(9., length(vec2(d=length(q.xz)-R0,q.y)) - R1),// abs for inside + outside\n        p += t*D;                                             // step forward = dist to obj          \n\n    O = O.x > 1. ? vec4(0.) : exp(-3.*O/2.);                  // luminance (depth + pseudo-shading )\n    float a = atan(q.z,q.x), b = atan(q.y,d);\n    \n    if (U.x < R.x/2. ) {                                     // left: conformal mapping\n     // b -= R1/R0 * sin(b); //  wrong (or approx): antiderivative of circonf(b)\n        float r = R1/R0, ir = sqrt(1.-r*r);       // antiderivative of 1/circonf(b) \n        b = .996*  2./ir* atan( (r-1.)/ir* tan(b/2.) );        \n     //                                NB: tan(b/2) = ( -d + sqrt(d*d+q.y*q.y) )/q.y )        \n    }\n    O *= hue( floor(k*R0*a/6.283) + 17.*mod(round(k*R1*b/6.283),R1) ); // colored tiles \n\n    a = sin(k*R0*a/2.), b = cos(k*R1*b/2.);\n    O *= sqrt( min(abs(a)/fwidth(a),1.) * min( abs(b)/fwidth(b),1.) );// tiles borders\n    \n    if (int(U)==int(R/2.) ) O++;                              // vertical separator\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdd3R4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[162, 162, 198, 198, 1948]]}
{"id": "sdd3W4", "name": "Growing trees", "author": "kastorp", "description": "another experiment on domain repetition\nhere another [url=https://www.shadertoy.com/view/Ndc3W7]example[/url] with more realistic trees", "tags": ["domainrepetition", "trees"], "likes": 12, "viewed": 111, "date": "1629904302", "time_retrieved": "2024-06-20T20:48:09.042825", "image_code": "//Growing Trees by kastorp\n\n//dean_the_coder  stuff\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n\nvec2 h22(vec2 v) {\n\tvec3 p = fract(v.xyx * vec3(.1031, .103, .0973));\n\tp += dot(p, p.yzx + 33.33);\n\treturn fract((p.xx + p.yz) * p.zy);\n}\n\nvec2 map(vec3 p);\nfloat shadow(vec3 p, vec3 lp) {\n\tfloat d,\n\t      s = 1.,\n\t      t = .1,\n\t      mxt = length(p - lp);\n\tvec3 ld = (lp - p) / mxt;\n\tfor (float i = Z0; i < 2e2; i++) {\n\t\td = map(t * ld + p).x;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.1, d);\n\t\tif (mxt - t < .5 || s < .001) break;\n\t}\n\treturn S01(s);\n}\n\nfloat ao(vec3 p, vec3 n, float h) { return map(h * n + p).x / h; }\n//\n\n//Blackle stuff\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(map(p).x - vec3(map(k[0]).x,map(k[1]).x,map(k[2]).x));\n}\n\n//Iq stuff\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); \n    return vec2( tN, tF );\n}\n//Shane stuff\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){  \n    n = max(abs(n), 0.001);//n = max((abs(n) - 0.2)*7., 0.001); //  etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// Texture bump mapping. \nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){   \n    const vec2 e = vec2(0.001, 0);  \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.    \n}\n\n//-------------------------------------------------\nvec2 plant(vec3 p,vec2 center) {\n    const float sh=.3; //shift\n    vec2 a =h22(center*1.1); \n    float\n     s =sin(a.y*20.+iTime/8.),\n     h = 5.5- s*s*s*s*3. +a.y*1.5, //height\n     v = .51 -.5*s,  //color\n     tk = max(+.05,+.85*smoothstep(.1,.4,v)* (1.-.1*fract(p.z*3.)-.1*fract(p.z*3.+.1))* smoothstep(h+.7,h-4.,p.z) *smoothstep(.1,0.2,p.z-3.7));  //thickness\n    vec3 s1= vec3(sin(a.x*25.),cos(a.x*25.),0)*sh; //bottom\n    vec3 s2= s1 + vec3(0,0,h); //top\n      \n    return vec2(sdCapsule(p- vec3(center, 0),s1,s2,tk),2.*v-v*v);\n}\n\n#define mmin(a,b) (a.x<b.x?a:b)\n\n\nvec2 edge(vec2 p) { //modified\n    return vec2((p.x < 0.) ? -1. : 1., (p.y < 0.) ? -1. : 1.);\n}\n\nvec2 map(vec3 p) {\n    vec2  d= vec2(p.z-3.7,0.);\n    vec2 center = floor(p.xy) + .5;\n    vec2 dir=edge(p.xy - center);\n    for(float i = -0.;i<2.;i++)for(float j = -0.;j<2.;j++)\n    {\n        vec2 pos = center + dir*vec2(i,j);    \n         //d = smin(d, plant(p,pos),0.2); \n         d = mmin(d, plant(p,pos)); \n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n    vec2 uv = (fc-.5*R.xy)/R.y;\n    vec2 mouse = (iMouse.xy-0.5*R.xy)/R.y;\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 ro = vec3(-25,0,10);    \n    float yrot = .45, zrot = iTime*.05;\n    if (iMouse.z > 0.) {\n        yrot = clamp(1.-2.*mouse.y,-0.,3.14/2.);\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(erot(cam,vec3(0,1,0),yrot),vec3(0,0,1),zrot);\n\n    vec3 p =ro;\n    bool hit = false;\n    vec2 d;\n    for (int i = 0; i < 100 && !hit; i++) {\n       d = map(p);\n        \n        //if inside a box, don't march after border\n        vec3 center = vec3(floor(p.xy) + .5,10.);\n        vec2 tb= boxIntersection(  p-center,  cam, vec3(.501,.501,10.) ) ;\n        if( tb.x<0. &&tb.y>0. && tb.y<d.x) d.x=tb.y;       \n        \n        hit = d.x*d.x < 1e-6;\n        p += d.x*cam;\n        if(distance(p,ro)>30.)break;\n    }\n    vec3 n = norm(p);\n    \n\n    vec3 lp=vec3(100, 200, 200), ld = normalize(lp - p);\n    vec3 col= mix(vec3(0.3,0.,0.),vec3(0.,.1,0.02), smoothstep(.1,.4,d.y)) ;\n    if(d.y<=0.){\n        n = doBumpMap( iChannel2, (p)*.25, n, 0.01);\n        col=min(vec3(0.5,0.8,0.0),tex3D( iChannel2, (p)*.25, n));\n    } else \n    {\n       n = doBumpMap( iChannel1, (p.zyx)*.25, n, 0.03*d.y);\n    }\n \n    \n    float ao = sat(mix(ao(p, n, .1), ao(p, n, .5), .7)),\n\t      l1 = sat(.1 + .9 * dot(ld, n)) * (.05 + .95 * shadow(p, lp)) * (.3 + .7 * ao),\n\t      l2 = sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .2 + pow(sat(dot(cam, reflect(ld, n))), 10.) * .05;          \n    col*=(l1 + l2 * ao);\n    \n    col = mix(col,vec3(0.835,0.851,0.549),exp(min(0.,-5.+distance(ro,p)/5.))); //fog  \n    fragColor =  vec4(sqrt(col),0) ;\n    \n}\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdd3W4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[28, 200, 218, 218, 337], [357, 357, 388, 388, 651], [653, 653, 688, 688, 719], [724, 740, 778, 778, 840], [842, 842, 861, 861, 977], [979, 990, 1042, 1042, 1163], [1164, 1164, 1225, 1225, 1505], [1506, 1586, 1636, 1636, 1844], [1846, 1872, 1934, 1934, 2332], [2334, 2386, 2418, 2418, 2922], [2958, 2958, 2977, 2988, 3053], [3055, 3055, 3073, 3073, 3388], [3390, 3390, 3440, 3440, 5074]]}
{"id": "sdd3zH", "name": "Blinn-Phong Sphere & RimLight", "author": "wylm", "description": "Blinn-Phong Sphere base on https://www.shadertoy.com/view/MdBfW3.", "tags": ["blinnphong", "rimlight"], "likes": 1, "viewed": 33, "date": "1629189755", "time_retrieved": "2024-06-20T20:48:09.042825", "image_code": "#define PI 3.1415926535897932384626433832795\n#define t iTime * 0.5\n\nvec3 shade(float r, vec2 center, vec2 pos, vec3 l[2])\n{\n    float z = sqrt(r * r - pos.x * pos.x - pos.y * pos.y);\n    \n    vec3 n = normalize(vec3(pos.x, pos.y, z)); \t\t// Surface normal\n\n    vec3 c_diff = vec3(0.9, 0.0, 0.7);\t\t\t\t// Diffuse color    \n    vec3 c_spec = vec3(0.0, 1.0, 1.0);\t\t\t\t// Specular color\n\n    float m = 11.0; \t\t\t\t\t\t\t\t// Surface Smoothness\n    float El = 0.9; \t\t\t\t\t\t\t\t// Irradiance of light source\n    vec3 Kd = c_diff.xyz / PI; \t\t\t\t\t\t// Diffuse term\n    vec3 Ks = c_spec.xyz * ((m + 8.0) / (8.0 * PI));// Specular term\n\n    vec3 Lo = vec3(0.2);\n    for (int i = 0; i < 2; i++)\n    {\n        vec3 h = normalize(l[i] + n); // Half vector\n\n        float cosTi = max(dot(n, l[i]), 0.0);\n        float cosTh = max(dot(n, h), 0.0);\n        Lo += (Kd.xyz + Ks.xyz * pow(cosTh, m)) * El * cosTi; // Outgoing radiance\n    }\n    \n    return Lo; \n    \n}\n\nvec3 RimLight(vec3 Lo,float r,vec2 center,vec2 pos)\n{\n    float det = r * r - pos.x * pos.x - pos.y * pos.y;\n    if(det < 0.0){\n        return Lo;\n    }\n    float z = sqrt(det);\n    \n    vec3 n = normalize(vec3(pos.x, pos.y, z)); \t\t// Surface normal\n    \n    float param = 1.0 - max(0.0, dot(n, normalize(vec3(center.xy, 1.0))));\n    \n    return Lo + vec3(pow(param, 3.0) * 1.5);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//\tSphere Definition\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 center = vec2(0.0,0.0);\n    float r = 0.75;\n    vec2 pos = uv;\n\n\t//\tLight vector\n\tvec3 l[2];\n    l[0] = normalize(vec3(sin(t), sin(t), cos(t)));\n    l[1] = normalize(vec3(-sin(t), cos(t), sin(t)));\n\n    // Outgoing radiance\n\tvec3 Lo = shade(r, center, pos, l);\n    \n    Lo = RimLight(Lo, r, center, pos);\n\n\tfragColor = vec4(Lo, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdd3zH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[68, 68, 123, 123, 933], [935, 935, 988, 988, 1317], [1319, 1319, 1376, 1398, 1861]]}
{"id": "sddGW7", "name": "pali raymarching 1", "author": "pali6", "description": "A very basic raymarching thingie.\nClickdrag mouse to rotate camera.", "tags": ["raymarching"], "likes": 2, "viewed": 90, "date": "1629992019", "time_retrieved": "2024-06-20T20:48:09.915501", "image_code": "vec3 camPos = vec3(0, 0, 0);\nvec3 camDir = vec3(0, 0, -1);\nvec3 camUp = vec3(0, 450. / 800., 0);\nfloat camF = 0.5;\nfloat rtStep = 0.4;\nfloat rtlStep = 0.025;\nfloat rtglStep = 0.3;\nconst int maxSteps = 32;\nconst int maxlSteps = 32;\nconst int maxglSteps = 32;\n\nfloat time;\n\nvec3 lightPos = vec3(4, 3, -1);\n\nvec3 INVALID = vec3(1e10, 1e20, -1e30);\n\nfloat smin(float a, float b)\n{\n    return (a + b - log(exp(a - b) + exp(b - a))) / 2.;\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 rayDir(vec2 uv)\n{\n    vec3 camRight = normalize(cross(camDir, camUp));\n    return normalize(camDir * camF + (uv.y - 0.5) * 2. * camUp + (uv.x - 0.5) * 2. * camRight);\n}\n\nvec3 orbit(vec3 normal, float dist, float speed, float offset)\n{\n    vec3 v1 = normalize(cross(normal, vec3(0.42, 0.1, -0.1)));\n    vec3 v2 = normalize(cross(normal, v1));\n    return dist * (v1 * cos(time * speed + offset) + v2 * sin(time * speed + offset));\n}\n\nfloat scene(vec3 pos)\n{\n    vec3 ballCenter = vec3(0, 0, -5);\n    float ballRadius = 2.;\n    float result =  distance(pos, ballCenter) - ballRadius + sin(pos.y * 5. + time) / 3. * cos(time * 0.2);\n    vec3 ballCenter2 = ballCenter + orbit(vec3(0, 1, 0), 3., 1., 0.);\n    result = smin(result, distance(pos, ballCenter2) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-4, 12, 0), 2.7, 1.7, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-4, 2, 5), 2.7, 1.8, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(8, 7, -8), 2.7, 1.9, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-14, -5, -1), 2.7, 2.0, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(1, 12, 0), 2.7, 0.8, 0.8)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-7, -5, 8), 2.6, 1.7, 0.1)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-1, 1, 22), 2.5, 1.2, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter2 + orbit(vec3(0.1, -0.5, -1), 0.8, -0.41, -0.2)) - 0.15);\n    /*\n    result -= (dot(pos - ballCenter, normalize(vec3(1, 3, 7)))) * 0.1;\n    result -= (dot(pos - ballCenter, normalize(vec3(-7, 2, 1)))) * 0.1;\n    result -= (dot(pos - ballCenter, normalize(vec3(2, -1, 0.3)))) * 0.1;\n    result -= (dot(pos - ballCenter, normalize(vec3(4, 3, -1)))) * 0.1;\n    */\n    // result += 1./distance(pos, vec3(-2, -2, -7));\n    result = 2. - abs(result - 2.);\n    result = smin(result, length((pos - ballCenter).xz) - 0.3);\n    return result;\n}\n\nvec3 sceneNormal(vec3 pos)\n{\n    float d = 0.001;\n    float base = scene(pos);\n    return normalize(vec3(\n        scene(pos + vec3(d, 0, 0)) - base,\n        scene(pos + vec3(0, d, 0)) - base,\n        scene(pos + vec3(0, 0, d)) - base\n    ));\n}\n\nvec4 rt(vec3 rayPos, vec3 rayDir)\n{\n    float lastVal = 0.;\n    float retVal = 0.;\n    float stp = rtStep;\n    for(int i = 0; i < maxSteps; i++)\n    {\n        float val = scene(rayPos);\n        if(val < 0.001)\n        {\n            retVal = 1.;\n        }\n        if(sign(val * lastVal) == -1.)\n            stp /= 2.;\n        lastVal = val;\n        rayPos += rayDir * stp * sign(val);\n    }\n    return vec4(rayPos, 1.);\n}\n\nvec4 rtl(vec3 rayPos, vec3 rayDir, float maxDist)\n{\n    float lastVal = 0.;\n    float tot = 0.;\n    for(int i = 0; i < maxlSteps; i++)\n    {\n        float val = scene(rayPos);\n        if(maxDist <= 0.1 || val > 40.)\n        {\n            float a = -val / (lastVal - val);\n            rayPos -= rtStep * rayDir * a;\n            return vec4(rayPos, tot);\n        }\n        if(val <= 0.001)\n            tot += rtlStep * (-val);\n        lastVal = val;\n        float step = rtlStep;\n        maxDist -= length(rayDir) * step;\n        rayPos += rayDir * step;\n    }\n    return vec4(rayPos, tot);\n}\n\nfloat rtgl(vec3 rayPos, vec3 rayDir)\n{\n    float lastVal = 0.;\n    float result = 0.;\n    for(int i = 0; i < maxglSteps; i++)\n    {\n        float val = scene(rayPos);\n        if(val < 0. || val > 40.)\n        {\n            float a = -val / (lastVal - val);\n            // val = (lastVal + val) / 2.;\n            //result += rtStep * smoothstep(0.1, 0.2, val) * (1. - smoothstep(0.2, 0.3, val)) * val * a;\n            return result;\n        }\n        //if(lastVal > 0.1 && val < 0.09)\n        //    result += rtStep * val * 3.;\n        result += rtglStep * smoothstep(0.1, 0.2, val) * (1. - smoothstep(0.2, 0.3, val)) * val * val;\n        // result += min(10., 1. / pow(val, 2.2) * smoothstep(0., 1., (val - 0.05) / 0.1)) * rtStep;\n        rayPos += rayDir * rtglStep * val;\n        lastVal = val;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    lightPos = vec3(3., 3.*sin(iTime), -1. + cos(iTime));\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    camPos = vec3(cos(mousePos.x * 3.14 * 2.), -(mousePos.y - 0.5) * 1.5, sin(mousePos.x * 3.14 * 2.)) * 4.5 + vec3(0, 0, -5);\n    camDir = normalize(vec3(0, 0, -5) - camPos);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col;\n    \n    vec4 hitInfo = rt(camPos, rayDir(uv));\n    vec3 hit = hitInfo.xyz;\n    if(hitInfo.w != 0.)\n    {\n        vec4 lightHitInfo = rtl(lightPos, hit - lightPos, distance(hit, lightPos));\n        vec3 lightHit = lightHitInfo.xyz;\n        col = mix(vec3(1, 0.1, 0.2), vec3(0.4, 0.4, 0.2), distance(hit, vec3(0, 0, -5)) / 6.);\n        /*if(distance(hit, vec3(0, 0, -5)) > 4.)\n            col = vec3(0.4, 0.25, 0.2);\n        else\n            col = vec3(1, 0.1, 0.2);// * (1.-abs(dot(rayDir(uv), sceneNormal(hit))));\n        */\n        float light = 0.1;\n        light += 4. / distance(lightHit, lightPos) * max(0., dot(sceneNormal(hit), -normalize(hit - lightPos)) * (1. / (1. + lightHitInfo.w * 100.)));\n        // light += 4. / distance(hit, lightPos) * max(0., dot(sceneNormal(hit), -normalize(hit - lightPos)));\n        col *= light;\n        // col -= vec3(1.-light, 1.-light, 1.-light);\n    }\n    else\n    {\n        col = vec3(0, 0, 0); //texture(iChannel0, hit.xy / 5.0 - vec2(1, 1)).xyz;\n    }\n    col.b += rtgl(camPos, rayDir(uv)) * 5.;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sddGW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[346, 346, 376, 376, 434], [436, 436, 457, 457, 527], [529, 529, 551, 551, 702], [704, 704, 768, 768, 964], [966, 966, 989, 989, 2578], [2580, 2580, 2608, 2608, 2823], [2825, 2825, 2860, 2860, 3245], [3247, 3247, 3298, 3298, 3837], [3839, 3839, 3877, 3877, 4662], [4664, 4664, 4721, 4721, 6163]]}
{"id": "sddGWN", "name": "Corona Pirates Pissed 24/7", "author": "j3553", "description": "Again an adaptation made back in 2016...forgot to post though. All credits go to @iq...right now cannot retrace origine. My goodness...the bar has raised another mile, last lustrum...anyways...it took a while to recove the pirates. Due to covid I guess...", "tags": ["iqmusicpirates"], "likes": 6, "viewed": 86, "date": "1629898951", "time_retrieved": "2024-06-20T20:48:09.921600", "image_code": "\nconst float period = 48.0;\nconst float dX = 4.8;\nconst float offsetMoonY = 0.5;\nconst float dY = 0.2;\n\nconst vec3 offset=vec3(1.5,2.,-2.5);\n\n#define PI 3.14159265358979\n\n// Origin (https://www.shadertoy.com/view/ldXXDj) created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat fbm( vec2 p )\n{\n    return 0.5000*texture( iChannel1, p*1.00 ).x + \n           0.2500*texture( iChannel1, p*2.02 ).x + \n           0.1250*texture( iChannel1, p*4.03 ).x + \n           0.0625*texture( iChannel1, p*8.04 ).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\tfloat generalTime = iTime / 54.35;\n\tvec2 p = (-iResolution.xy+2.0*gl_FragCoord.xy) / iResolution.y;\n    vec2 i = p;\n\n    // camera\n    p += vec2(1.0,3.0)*0.001*2.0*cos( generalTime*5.0 + vec2(0.0,1.5) );    \n    p += vec2(1.0,3.0)*0.001*1.0*cos( generalTime*9.0 + vec2(1.0,4.5) );    \n    p *= 0.85 + 0.05*length(p);\n    \n    // water\n    vec2 q = vec2(p.x,1.0)/p.y;\n    q.y -= 0.9*generalTime;    \n        vec2 off = texture( iChannel0, 0.1*q*vec2(1.0,2.0) - vec2(0.0,0.007*iTime) ).xy;\n    q += 0.4*(-1.0 + 2.0*off);\n    vec3 col = 0.2*sqrt(texture( iChannel0, 0.05*q *vec2(1.0,4.0) + vec2(0.0,0.01*iTime) ).zyx);\n    col *= 0.4;\n    \n    float dLight = dX - 0.6;\n    float lightReflect = (dLight/period)*(mod(iTime,period))-(dLight/2.0);\n    \n    float re = 1.0-smoothstep( 0.0, 0.7, abs(p.x-lightReflect) - abs(p.y)*0.5+0.2 );\n    col += 1.0*vec3(1.0,0.9,0.73)*re*0.2*off.y*5.0*(1.0-col.x);\n    float re2 = 1.0-smoothstep( 0.0, 2.0, abs(p.x-0.6) - abs(p.y)*0.85 );\n    col += 0.7*re2*smoothstep(0.35,1.0,texture( iChannel1, 0.075*q *vec2(1.0,4.0) ).x);\n    \n    // sky\n    vec3 sky = vec3(0.01, 0.01, 0.1) * 1.4;\n    \n    // stars    \n    sky += 0.5*smoothstep( 0.95,1.00,texture( iChannel1, 0.25*p ).x);\n    sky += 0.5*smoothstep( 0.85,1.0,texture( iChannel1, 0.25*p ).x);\n    sky += 0.2*pow(1.0-max(0.0,p.y),2.0);\n    \n    // clouds    \n    float f = fbm( 0.002*vec2(p.x,1.0)/p.y );\n    vec3 cloud = vec3(0.3,0.4,0.5)*0.7*(1.0-0.85*sqrt(smoothstep(0.4,1.0,f)));\n    sky = mix( sky, cloud, 0.95*smoothstep( 0.4, 0.6, f ) );\n    sky = mix( sky, vec3(0.33,0.34,0.35), pow(1.0-max(0.0,p.y),2.0) );\n    col = mix( col, sky, smoothstep(0.0,0.1,p.y) );\n    \n    // horizon\n    col += 0.1*pow(clamp(1.0-abs(p.y),0.0,1.0),9.0);\n\n    // moon\n    \n    float moonPositionX = (dX / period) * mod(iTime, period) - ( dX / 2.);\n    float moonPositionY = dY * cos( iTime / ( period / (2.0*PI))  + PI ) + offsetMoonY;\n    \n    float d = length(p-vec2(moonPositionX,moonPositionY));\n    \n    float g = 1.0 - smoothstep( 0.2, 0.22, d );\n    \n    float moontex = 0.82+0.1*smoothstep(0.25,0.7,fbm(0.06*p));\n    \n    vec3 moon = vec3(1.0,0.97,0.9)*(1.0-0.1*smoothstep(0.2,0.5,f));\n    \n    \tmoon = abs(fract((moon+offset/1.15)*.17)-.5);  // tile folding from Hot Shower by Kali\n\t\n\tfor (int i=0; i<11; i++) {  moon = abs(moon)/dot(moon,moon)-.319; } // the magic formula for the hot flow\n\n    col += 0.8*moon*exp(-4.0*d)*vec3(1.1,1.0,0.8);\n    col += 0.2*moon*exp(-2.0*d);\n    col = mix( col, moon*moontex, g );\n    \n    // postprocess\n    col *= 1.4;\n    col = pow( col, vec3(1.5,1.2,1.0) );    \n    col *= clamp(1.0-0.3*length(i), 0.0, 1.0 );\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sddGWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[171, 343, 364, 364, 572], [574, 574, 632, 632, 3296]]}
{"id": "sdfGWX", "name": "Rover", "author": "oneshade", "description": "Very old shader I was working on. Also my slowest one yet (~8fps on my computer) :(", "tags": ["3d", "raymarching", "terrain", "ik", "robot"], "likes": 10, "viewed": 85, "date": "1628217826", "time_retrieved": "2024-06-20T20:48:11.661220", "image_code": "// Constants\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n// Compiler trick to avoid loop unrolling (the compiler doesn't know about iFrame\n// so it can't make this a constant which would allow it to unroll loops depending on it)\n#define ZERO min(iFrame, 0)\n\n// SDFs\nfloat sdLine(in vec3 p, in vec3 a, in vec3 b) {\n    vec3 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdDisc(in vec3 p, in float r) {\n    p.x = length(p.xz);\n    return length(p - vec3(min(p.x, r), 0.0, p.z));\n}\n\nfloat sdCylinder(in vec3 p, in float h, in float r) {\n    vec2 q = vec2(length(p.xz) - r, abs(p.y) - h);\n    return length(max(q, 0.0)) + min(0.0, max(q.x, q.y));\n}\n\nfloat sdSphere(in vec3 p, in vec3 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdBox(in vec3 p, in vec3 o, in vec3 b) {\n    vec3 q = abs(p - o) - b;\n    return length(max(q, 0.0)) + min(0.0, max(q.x, max(q.y, q.z)));\n}\n\n// 3D version of Inigo Quilez's horseshoe SDF\n// I haven't put much thought into optimizing :P\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdHorseshoe(in vec3 p, in float a, in vec3 w, in float r) {\n    p.x = abs(p.x);\n\n    float t = min(atan(p.y, p.x), a);\n    vec2 aq = abs(vec2(length(p.xy - vec2(cos(t), sin(t)) * r), p.z)) - w.xz;\n    float arc = length(max(aq, 0.0)) + min(0.0, max(aq.x, aq.y));\n\n    float c = cos(a), s = sin(a);\n    vec3 tq = abs(vec3(p.x * c + p.y * s - r, p.x * s - p.y * c + w.y, p.z)) - w;\n    float prong = length(max(tq, 0.0)) + min(0.0, max(tq.x, max(tq.y, tq.z)));\n\n    return min(arc, prong);\n}\n\nfloat sdBezier(in vec3 p, in vec3 v1, in vec3 v2, in vec3 v3) {\n    vec3 c1 = p - v1;\n    vec3 c2 = 2.0 * v2 - v3 - v1;\n    vec3 c3 = v1 - v2;\n\n    float t3 = dot(c2, c2);\n    float t2 = dot(c3, c2) * 3.0 / t3;\n    float t1 = (dot(c1, c2) + 2.0 * dot(c3, c3)) / t3;\n    float t0 = dot(c1, c3) / t3;\n\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);\n        return length(p - mix(mix(v1, v2, root), mix(v2, v3, root), root));\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);\n        vec3 p1 = p - mix(mix(v1, v2, roots.x), mix(v2, v3, roots.x), roots.x);\n        vec3 p2 = p - mix(mix(v1, v2, roots.y), mix(v2, v3, roots.y), roots.y);\n        return sqrt(min(dot(p1, p1), dot(p2, p2)));\n    }\n}\n\n// Hash from \"Hash without Sine\" by Dav_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(in vec2 p) {\n\t//vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //p3 += dot(p3, p3.yzx + 33.33);\n    //return fract((p3.x + p3.y) * p3.z);\n    return texture(iChannel0, p * 0.1).r; // Attempt to lower complexity\n}\n\nvec2 Hash22(in vec2 p) {\n\tvec3 p3 = fract(p.xyx * vec3(0.1031, 0.103, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat snoise(in vec2 p) {\n    vec2 cell = floor(p);\n    vec2 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float bl = Hash11(cell);\n    float br = Hash11(cell + vec2(1.0, 0.0));\n    float tl = Hash11(cell + vec2(0.0, 1.0));\n    float tr = Hash11(cell + 1.0);\n\n    return mix(mix(bl, br, local.x), mix(tl, tr, local.x), local.y);\n}\n\nfloat getTerrain(in vec2 p, in float t) {\n    p *= 0.25;\n\n    float height = 0.0;\n    float noiseScale = 1.0;\n    float totalScale = 0.0;\n\n    for (int oct=ZERO; oct < 7; oct++) {\n        height += snoise(p) * noiseScale;\n        totalScale += noiseScale;\n        noiseScale *= 0.5;\n        p *= 2.0;\n    }\n\n    height /= totalScale;\n    float height2 = height * height; // To reduce multiplications\n    return height2 * height2 * height * 5.0;\n}\n\n// SDF Operators\nvec2 pModPolar2(in vec2 p, in float n) { // 2D polar repetition\n    float rep = 6.28 / n, hRep = 0.5 * rep;\n    p = sin(mod(atan(p.y, p.x) + hRep, rep) - hRep + vec2(1.57, 0.0)) * length(p);\n    return p;\n}\n\n// 2 link IK solver (positions only)\n// https://www.shadertoy.com/view/NsfGRf\n// config sets the handedness, -1 for left, 1 for right\nvec2 solveJoint2D(in vec2 a, in vec2 b, in float ra, in float rb, in float config) {\n    vec2 ba = b - a;\n    float d = dot(ba, ba), l = sqrt(d);\n    float q = (d + ra * ra - rb * rb) / (2.0 * ra * l);\n    return a + (ba * q + vec2(-ba.y, ba.x) * sqrt(1.0 - q * q) * config) * ra / l;\n}\n\nvec3 solveJoint3D(in vec3 a, in vec3 b, in float ra, in float rb, in float config) {\n    b -= a;\n    float u = length(b.xz);\n    vec3 j = vec3(solveJoint2D(vec2(0.0), vec2(u, b.y), ra, rb, config), 0.0);\n    return a + vec3(b.xz / u * j.x, j.y).xzy;\n}\n\n// Quadratic bezier\nvec3 bezierArc(in vec3 a, in vec3 b, in vec3 c, in float t) {\n    float tInv = 1.0 - t;\n    return a * tInv * tInv + b * 2.0 * t * tInv + c * t * t;\n}\n\n// Computes a coordinate system \"looking\" at a target along the z axis\n// I think it is actually inverted\n// https://www.shadertoy.com/view/WlKBDw\nmat3 lookAt(in vec3 pos, in vec3 target) {\n    vec3 f = normalize(target - pos);         // Forward\n    vec3 r = normalize(vec3(-f.z, 0.0, f.x)); // Right\n    vec3 u = cross(r, f);                     // Up\n    return mat3(r, u, f);\n}\n\nvoid addShape(in float dist, in int id, inout vec2 scene) {\n    if (dist < scene.x) scene = vec2(dist, id);\n}\n\nvoid subShape(in float dist, in int id, inout vec2 scene) {\n    dist = -dist;\n    if (dist > scene.x) scene = vec2(dist, id);\n}\n\nvec2 mapScene(in vec3 p, in float t) {\n    vec2 scene = vec2(p.y, 1);\n    float time = iTime;\n\n    vec2 robotPos = vec2(0.0, iTime);\n\n    // Terrain\n    scene.x -= getTerrain(p.xz + robotPos, t) - 2.25;\n    scene.x *= 0.8; // Improve raymarching accuracy\n\n    // Tilt to match terrain\n    vec3 w1 = vec3(-1.5, getTerrain(vec2(-1.5, -2.5) + robotPos, t), -2.5);\n    vec3 w2 = vec3( 1.5, getTerrain(vec2( 1.5, -2.5) + robotPos, t), -2.5);\n    vec3 w3 = vec3( 1.5, getTerrain(vec2( 1.5,  2.5) + robotPos, t),  2.5);\n    vec3 w4 = vec3(-1.5, getTerrain(vec2(-1.5,  2.5) + robotPos, t),  2.5);\n\n    vec3 up = normalize(normalize(cross(w2 - w1, w1 - w3)) +\n                        normalize(cross(w3 - w2, w2 - w4)) +\n                        normalize(cross(w4 - w3, w3 - w1)) +\n                        normalize(cross(w1 - w4, w4 - w2)));\n\n    vec3 forward = normalize(cross(up, vec3(-1.0, 0.0, 0.0)));\n    vec3 right = cross(up, forward);\n\n    // Debug coordinate system\n    //addShape(sdLine(p, vec3(0.0), up * 3.0) - 0.1, 1, scene);\n    //addShape(sdLine(p, vec3(0.0), right * 3.0) - 0.1, 1, scene);\n    //addShape(sdLine(p, vec3(0.0), forward * 3.0) - 0.1, 1, scene);\n\n    vec3 op = p; // Keep untransformed copy\n    p.y -= 0.25 * (w1.y + w2.y + w3.y + w4.y);\n    p *= mat3(right, up, forward);\n\n    // TODO: add movement\n\n    float bodyAngle = 0.0;\n    float wheelAngle = time;\n\n    vec3 arcV1 = vec3(-1.0, 1.0, 4.0);\n    vec3 arcV2 = vec3(0.0, 4.0, 4.0);\n    vec3 arcV3 = vec3(1.0, 1.0, 4.0);\n\n    // Visualize arm path\n    //addShape(sdSphere(p, arcV1, 0.3), 7, scene);\n    //addShape(sdSphere(p, arcV2, 0.3), 7, scene);\n    //addShape(sdSphere(p, arcV3, 0.3), 7, scene);\n    //addShape(sdBezier(p, arcV1, arcV2, arcV3) - 0.1, 7, scene);\n\n    vec3 base = vec3(0.0, 0.0, 1.5);\n    vec3 end = bezierArc(arcV1, arcV2, arcV3, 0.5 + 0.5 * cos(iTime));//vec3(cos(iTime), 2.0 + sin(iTime), 3.0);\n    vec3 middle = solveJoint3D(base, end, 3.0, 2.0, 1.0);\n\n    float c = cos(bodyAngle), s = sin(bodyAngle);\n    p.xz *= mat2(c, s, -s, c);\n\n    // Body\n    addShape(sdBox(p, vec3(0.0, -0.5, 0.0), vec3(1.5, 0.5, 2.5)), 2, scene);\n\n    // Bolts\n    vec3 wp = vec3(abs(p.xz) - vec2(1.9, 1.6), p.y + 1.1).xzy;\n    addShape(sdBox(wp, vec3(-1.25, -0.1, 0.05), vec3(0.2, 0.1, 0.15)) - 0.1, 3, scene);\n\n    // Wheels\n    wheelAngle *= -sign(p.z);\n    c = cos(wheelAngle), s = sin(wheelAngle);\n    wp.yz *= mat2(c, -s, s, c);\n\n    vec2 wheels = vec2(sdDisc(wp.yxz, 0.6) - 0.35, 4);\n    addShape(sdCylinder(vec3(p.y + 1.15, p.x, abs(p.z) - 1.65), 2.0, 0.15), 5, wheels);\n\n    // Hubcaps\n    addShape(sdDisc(wp.yxz - vec3(0.0, 0.35, 0.0), 0.25) - 0.1, 5, scene);\n\n    // Treads\n    float turn = wp.x * sign(p.x * p.z);\n    c = cos(turn), s = sin(turn);\n    wp.yz *= mat2(c, -s, s, c);\n    wp.yz = pModPolar2(wp.yz, 24.0);\n    subShape(sdLine(wp, vec3(-0.25, 1.0, 0.0), vec3(1.0, 1.0, 0.0)) - 0.1, 4, wheels);\n    addShape(wheels.x, int(wheels.y), scene);\n\n    // Links\n    addShape(min(sdLine(p, base, middle), sdLine(p, middle, end)) - 0.25, 6, scene);\n\n    // Joints\n    addShape(sdSphere(p, base, 0.35), 7, scene);\n    addShape(sdSphere(p, middle, 0.35), 7, scene);\n\n    // Gripper\n    vec3 gp = (p - end) * lookAt(end, middle);\n    gp = vec3(gp.x, -gp.z - 0.5, gp.y);\n    addShape(sdHorseshoe(gp, mix(-0.2, 0.5, 0.5 + 0.5 * cos(iTime * 2.0)), vec3(0.1, 0.175, 0.2), 0.35), 8, scene);\n\n    return scene;\n}\n\n// Tetrahedral central differences method (2 less mapScene() evaluations) plus a\n// compiler trick: https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 getNormal(in vec3 p, in float t) {\n    float h = 0.005 * t;\n    vec3 n = vec3(0.0);\n    for (int i=ZERO; i < 4; i++) {\n        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);\n        n += e * mapScene(p + e * h, t).x;\n    }\n\n    return normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 8.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 3.14;\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(0.6, -0.1) * 3.14;\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Raymarch\n    bool hit = false;\n    float t = 0.0;\n\n    vec3 p;\n    int id;\n\n    //float iters = 0.0;\n    for (int i=ZERO; i < 100; i++) {\n        p = ro + rd * t;\n        vec2 d = mapScene(p, t);\n        if (d.x < 0.001 * t) {\n            id = int(d.y);\n            hit = true;\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d.x;\n        //iters++;\n    }\n\n    if (hit) {\n        vec3 n = getNormal(p, t);\n        float diff = sqrt(max(0.0, dot(-rd, n)));\n\n        vec3 mat = vec3(1.0);\n        if (id == 1) mat = vec3(0.8, 0.6, 0.4); // Terrain\n        if (id == 2) mat = vec3(0.5); // Body\n        if (id == 3) mat = vec3(0.5); // Bolts\n        if (id == 4) mat = vec3(0.25); // Wheels\n        if (id == 5) mat = vec3(0.75); // Shaft and hubcaps\n        if (id == 6) mat = vec3(0.75); // Arm\n\n        fragColor.rgb = mat * diff;\n    }\n\n    // Iteration heatmap\n    //fragColor.rgb = mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), iters / 100.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdfGWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[266, 274, 321, 321, 429], [431, 431, 468, 468, 546], [548, 548, 601, 601, 712], [714, 714, 764, 764, 796], [798, 798, 844, 844, 943], [945, 1119, 1184, 1184, 1614], [1616, 1616, 1679, 1679, 2892], [2894, 2982, 3007, 3128, 3203], [3205, 3205, 3229, 3229, 3364], [3366, 3366, 3391, 3391, 3715], [3717, 3717, 3758, 3758, 4163], [4165, 4182, 4222, 4245, 4388], [4390, 4524, 4608, 4608, 4810], [4812, 4812, 4896, 4896, 5063], [5065, 5085, 5146, 5146, 5235], [5237, 5384, 5426, 5426, 5618], [5620, 5620, 5679, 5679, 5729], [5731, 5731, 5790, 5790, 5858], [5860, 5860, 5898, 5898, 9249], [9251, 9417, 9456, 9456, 9710], [9712, 9712, 9767, 9767, 11385]]}
{"id": "sdt3R2", "name": "Complex Function Plotter", "author": "Escher", "description": "Plots a general complex functions", "tags": ["plotterplotcomplex"], "likes": 2, "viewed": 96, "date": "1630261281", "time_retrieved": "2024-06-20T20:48:11.661220", "image_code": "#define pi acos(-1.)\n#define ss(a,b,c) smoothstep(a-b,a+b,c)\n#define angle(z) (atan(z.y/z.x) + pi * step(0.0, z.x))\n#define transition_speed 100.0\n#define st ((atan(transition_speed*cos(iTime/10.0))/atan(transition_speed)) * 0.5 + 0.5)\n#define res iResolution\n#define dd .02\n\n#define zoom 5.\n\nvec2 frame(vec2 v){\n    v=2.*v.xy/res.xy-1.;\n    v.x*=res.x/res.y;return v;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 i = vec2(0.0,1.0);\n\nvec2 header(vec2 z) {\n    z.y -= z.x;\n    return z;\n}\n\nvec2 footer(vec2 r) {\n    r.y += r.x;\n    return r;\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    vec2 r = vec2(\n        z.x*w.x - z.y*w.y, \n        z.x*w.y + z.y*w.x\n    );\n    return r;\n}\n\nvec2 pol(vec2 z) {\n    float size = sign(z.x) * length(z);\n    float angle = angle(z);\n    return vec2(length(z), angle);\n}\n\nvec2 cart(vec2 pol) {\n    return pol.x * vec2(cos(pol.y), sin(pol.y));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n    vec2 p1 = pol(z);\n    vec2 p = vec2(\n        pow(p1.x, w.x) * exp(-w.y*p1.y), \n        p1.y * w.x + log(p1.x) * w.y);\n    vec2 r = cart(p);\n    return r;\n}\n\nvec2 cpow(vec2 z, float w) {\n    return cpow(z, vec2(w,0.0));\n}\n\nvec2 cpow(vec2 z, int w) {\n    return cpow(z, float(w));\n}\n\nvec2 cmix(vec2 z, vec2 w, float t) {\n    //z = cart(z);\n    //w = cart(w);\n\n    vec2 r = mix(z,w,t);\n    //r = pol(r);\n    return r;\n}\n\nvec2 cln(vec2 z) {\n    vec2 p = pol(z);\n    vec2 r = vec2(log(p.x), p.y);\n    return r;\n}\n\nvec2 cexp(vec2 z) {\n    vec2 r = cart(vec2(exp(z.x), z.y));\n    return r;\n}\n\nfloat reduce(float x) {\n    return 1.0 - pow(1.01, -x);\n}\n\nvec3 hsv_from_complex(vec2 p) {\n    float size = length(p);\n    float p_grid = length(fract(p));\n    float radial = fract(log2(length(p)));\n    float angle = angle(p)/pi;\n    float angle_grid = 0.0 * fract(8.0*angle*floor(size));\n    float hue = 0.91 + 0.5 * angle;\n    float saturation = 0.4 + 0.2 * reduce(length(p));\n    float value = 0.4 + 0.1 * p_grid + 0.1 * angle_grid + 0.1 * radial;\n    vec3 hsv = vec3(hue, saturation, value);\n    return hsv;\n}\n\nvec4 projection(vec2 p) {\n    float othogonal = length(fract(p));\n    vec3 hsv = hsv_from_complex(p);\n    float transparency=0.2*othogonal;\n    return vec4(hsv2rgb(hsv), transparency);\n}\n\nvec2 mapping(vec2 z) {\n    vec2 r = cexp(cln(z) + cln(z));\n    return r; //z + cpow(z,5) + vec2(1.0,0.0);\n}\n\nvoid mainImage(out vec4 r,in vec2 i){\n    i-=iMouse.xy - res.xy * .5;\n    vec2 z=frame(i)*zoom;\n    float orthogonal = length(fract(z));\n    vec2 p = mapping(z);\n    p = cmix(z, p, st);\n    vec3 p_hsv = hsv_from_complex(p);\n    vec3 z_hsv = hsv_from_complex(z);\n    vec3 hsv = p_hsv;\n    hsv.x = p_hsv.x + 0.005 * fract(z_hsv.x * pow(2.0, 2.0 + floor(length(z))));\n    hsv.z = pow(2.0, mix(log2(p_hsv.z), log2(z_hsv.z), 0.4));\n\n    r = vec4(hsv2rgb(hsv), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdt3R2.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[293, 293, 312, 312, 370], [372, 372, 394, 394, 563], [590, 590, 611, 611, 643], [645, 645, 666, 666, 698], [700, 700, 727, 727, 823], [825, 825, 843, 843, 948], [950, 950, 971, 971, 1022], [1024, 1024, 1051, 1051, 1211], [1213, 1213, 1241, 1241, 1276], [1278, 1278, 1304, 1304, 1336], [1338, 1338, 1374, 1412, 1472], [1474, 1474, 1492, 1492, 1563], [1565, 1565, 1584, 1584, 1640], [1642, 1642, 1665, 1665, 1699], [1701, 1701, 1732, 1732, 2155], [2157, 2157, 2182, 2182, 2343], [2345, 2345, 2367, 2367, 2452], [2454, 2454, 2491, 2491, 2916]]}
{"id": "sdt3R7", "name": "Engine Sketches", "author": "dr2", "description": "Design drawings for \"Steam Engine No.3\" (mouseable)", "tags": ["projection", "drawing", "machine"], "likes": 32, "viewed": 288, "date": "1629454000", "time_retrieved": "2024-06-20T20:48:11.691748", "image_code": "// \"Engine Sketches\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Noisefv2 (vec2 p);\n\nvec3 qHit, pgSize, ltDir, ltDirS;\nvec2 aCs[3], crCs[3], crMid[3];\nfloat tCur, dstFar, dMiss, crRad, crLen, aRot, szFac, aPen;\nint idObj;\nbool isSh;\nconst int idWhl = 1, idSpk = 2, idCrnk = 3, idAx = 4, idPis = 5, idCrod = 6, idCyl = 7,\n   idCylEnt = 8, idValv = 9, idPipes = 10, idSup = 11, idBase = 12, idPen = 13, idFrm = 14;\nconst float pi = 3.1415927;\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat CrnkDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, dz;\n  for (int k = 0; k < 3; k ++) {\n    dz = float (1 - k) * 4.;\n    q = p;\n    q.xy = Rot2Cs (q.xy, aCs[k]);\n    q.z -= dz;\n    d = min (PrRoundBoxDf (vec3 (q.x + 0.5 * crRad, q.y, abs (q.z) - 0.5),\n       vec3 (0.5 * crRad, 0.2, 0.1), 0.02), PrRoundCylDf (vec3 (abs (q.x + 0.5 * crRad) -\n       0.5 * crRad, q.y, abs (q.z) - 0.5), 0.6, 0.02, 0.1));\n    DMIN (idCrnk);\n    d = PrRoundCylDf (vec3 (q.x + crRad, q.yz), 0.3, 0.02, 0.65);\n    DMIN (idAx);\n    q = p;\n    q.z -= dz;\n    q.xy = Rot2Cs (q.xy + crMid[k], crCs[k]);\n    d = min (PrCylDf (vec3 (abs (q.y) - 0.12, q.zx), 0.15, crLen - 0.5),\n       PrCylDf (vec3 (abs (q.x) - crLen, q.yz), 0.6, 0.15));\n    DMIN (idCrod);\n    q = p;\n    q.xz -= vec2 (- (4.5 + crMid[k].x + crLen * crCs[k].x), dz);\n    d = PrCylDf (q.yzx, 0.25, 3.7);\n    DMIN (idPis);\n    d = PrCylDf ((q - vec3 (0.7, 1.7, 0.)).yzx, 0.07, 3.);\n    DMIN (idPis);\n    q.x -= 4.5;\n    d = PrRoundCylDf (q, 0.3, 0.02, 0.5);\n    DMIN (idAx);\n    d = min (min (PrCylDf ((q - vec3 (-0.8, 0., 0.)).yzx, 0.6, 0.13),\n       PrCylDf ((q - vec3 (-0.8, 0.8, 0.)).xzy, 0.08, 0.95)),\n       PrRoundCylDf (vec3 (q.xy, abs (q.z) - 0.35), 0.7, 0.02, 0.1));\n    DMIN (idCrnk);\n  }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, dz;\n  dMin = dstFar / szFac;\n  p /= szFac;\n  p.x -= 12.;\n  q = p;\n  if (! isSh) d = PrCapsDf (q.yzx, 10., 7.);\n  if (isSh || d < 0.2) {\n    p.x -= 8.;\n    q = p;\n    d = max (PrCylDf (q, 0.3, 8.2), min (0.35 - abs (mod (q.z + 2., 4.) - 2.), 6. - abs (q.z)));\n    DMIN (idAx);\n    q.xy = Rot2Cs (q.xy, aCs[0]);\n    q.z = abs (q.z) - 7.3;\n    d = min (SmoothMax (abs (length (q.xy) - 4.) - 0.2, abs (q.z) - 0.8, 0.04),\n       PrRoundCylDf (q, 0.6, 0.02, 0.8));\n    DMINQ (idWhl);\n    q.xy = Rot2D (q.xy, 2. * pi * (floor (6. * atan (q.y, - q.x) / (2. * pi) + 0.5)) / 6.);\n    d = PrRoundBoxDf (vec3 (q.x + 2.2, q.y, abs (q.z) - 0.5), vec3 (1.7, 0.15, 0.25), 0.04);\n    DMIN (idSpk);\n    dMin = CrnkDf (p, dMin);\n    q = p ;\n    q.z = mod (q.z + 2., 4.);\n    q.xz -= vec2 (-16.9, 2.);\n    d = max (PrCylDf ((q + vec3 (-3.5, 0., 0.)).yzx, 0.7, 0.2), abs (p.z) - 6.);\n    DMINQ (idCylEnt);\n    d = max (PrRoundCylDf (q.yzx, 1.5, 0.02, 3.5), abs (p.z) - 6.);\n    DMINQ (idCyl);\n    q = p;\n    q.z = mod (q.z + 2., 4.);\n    q -= vec3 (-16.9, 1.7, 2.);\n    d = max (PrRoundCylDf (q.yzx, 0.5, 0.02, 2.5), abs (p.z) - 6.);\n    DMINQ (idValv);\n    q = p;\n    q.x = abs (q.x + 16.9);\n    q.xy -= vec2 (1.5, 2.7);\n    d = min (min (max (PrCylDf ((vec3 (q.x, q.y, mod (q.z + 2., 4.) - 2.)).xzy, 0.35, 0.75),\n       abs (p.z) - 6.), PrCylDf (vec3 (q.x, q.y - 0.75, q.z), 0.35, 4.)),\n       PrSphDf (vec3 (q.x, q.y - 0.75, abs (q.z) - 4.), 0.35));\n    q = p;\n    q.xy -= vec2 (-16.9, 1.);\n    d = min (d, min (PrCylDf ((q + vec3 (-1.5, 0., 2.)).xzy, 0.35, 2.5),\n       PrCylDf ((q + vec3 (1.5, 0., -2.)).xzy, 0.35, 2.5)));\n    DMINQ (idPipes);\n    q = p;\n    q.z = abs (abs (q.z) - 4.) - 1.7;\n    d = min (PrRoundBoxDf (q + vec3 (0., 1.6, 0.), vec3 (0.48, 1.5, 0.2), 0.02),\n       PrRoundCylDf (q, 0.5, 0.02, 0.25));\n    DMINQ (idSup);\n    q = p;\n    q.yz -= vec2 (1.8, -2.3);\n    if (! isSh) d = PrSphDf (q, 1.);\n    if (isSh || d < 0.1) {\n      d = PrCylDf ((q + vec3 (0., 0.6, 0.)).xzy, 0.12, 0.8);\n      q.xz = Rot2D (q.xz, 4. * aRot);\n      q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * atan (q.z, - q.x) / (2. * pi) + 0.5)) / 4.);\n      q.xy = Rot2D (q.xy, -0.25 * pi);\n      d = min (d, PrCylDf ((q + vec3 (0.4, -0.1, 0.)).yzx, 0.05, 0.4));\n      DMIN (idAx);\n      d = PrSphDf (q + vec3 (0.7, -0.1, 0.), 0.15);\n      DMIN (idPis);\n    } else dMin = min (dMin, d);\n    q = p;\n    q.xy -= vec2 (-8., -4.);\n    d = min (PrRoundBoxDf (q, vec3 (13., 1., 6.), 0.04),\n       PrRoundBoxDf (vec3 (abs (q.x + 9.) - 2., q.y - 1.5, q.z), vec3 (1., 1.4, 5.), 0.04));\n    DMINQ (idBase);\n    dMin *= szFac;\n    dMiss = min (dMiss, dMin);\n  } else dMin = min (dMin, d) * szFac;\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 ObjNfL (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  float s;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  s = dot (v, vec4 (1.));\n  return vec4 (normalize (2. * v.yzw - s), (s - 2. * v.x - 4. * ObjDf (p)) / (e.x * e.x));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  q -= vec3 (2.5, -2.2, -6.8);\n  q.xz = Rot2D (q.xz, 0.2 * pi);\n  q.yz = Rot2D (vec2 (q.y, q.z + 4.5), 0.035 * pi + aPen) - vec2 (0., 4.5);\n  d = PrRoundCylDf (q, 0.33, 0.02, 5.);\n  d = max (d, - dot (vec2 (q.z, dot (q.xy, cos (2. * pi * floor (16. * (atan (q.y, - q.x) / (2. * pi) +\n     0.5) + 0.5) / 16. + vec2 (0., 0.5 * pi)))), sin (-0.4 * pi + vec2 (0.5 * pi, 0.))) - 1.6);\n  DMINQ (idPen);\n  q = p;\n  q.yz -= vec2 (-2.6, -4.);\n  d = max (PrRoundBoxDf (q, vec3 (pgSize + vec3 (1., 0.1, 1.)), 0.03), - PrBox2Df (q.xz, pgSize.xz));\n  DMINQ (idFrm);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ExObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShGrid (vec2 p, vec2 g, int stag)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (stag > 0 && 2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.3 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.xy, 1. - 0.1 * sq.x * sq.y).xzy;\n}\n\nvec2 ExBlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u, fcBlk;\n  vec2 qBlk;\n  float dn, df, bSize;\n  bSize = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    fcBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rd;\n    qBlk = vec2 (dot (u.zxy, fcBlk), dot (u.yzx, fcBlk)) / bSize;\n  } else qBlk = vec2 (0.);\n  return qBlk;\n}\n\nvec4 BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp, fcBlk;\n  vec2 qBlk;\n  float dMin, dn, df;\n  dMin = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    fcBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return vec4 (dMin, fcBlk);\n}\n\nvec4 ObjCol (inout vec3 vn)\n{\n  vec4 col4;\n  vec3 rg;\n  float a, s;\n  bool fxz;\n  if (idObj == idBase) {\n    col4 = vec4 (0.7, 0.8, 0.4, 0.1);\n    if (abs (vn.y) < 0.01) {\n      rg = qHit;\n      rg.y += 0.5;\n      fxz = (abs (vn.x) > 0.99);\n      rg = ShGrid ((fxz ? rg.zy : rg.xy), vec2 (1., 2.), 1);\n      col4 *= rg.y;\n      rg.xz *= sign (fxz ? vn.x : vn.z);\n      if (fxz) {\n        if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n        else vn.xz = Rot2D (vn.xz, rg.x);\n      } else {\n        if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n        else vn.zx = Rot2D (vn.zx, rg.x);\n      }\n    } else {\n      rg = ShGrid (qHit.xz, vec2 (1.), 0);\n      col4 *= rg.y;\n      if (vn.y > 0.99) {\n        if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);\n        else vn.yx = Rot2D (vn.yx, rg.x);\n      }\n    }\n  } else if (idObj == idCyl) {\n    col4 = vec4 (0.8, 0.5, 0.2, 0.2);\n    a = atan (qHit.z, - qHit.y) / (2. * pi);\n    if (abs (vn.x) > 0.99) {\n      col4.rgb *= (1. - 0.5 * SmoothBump (0.2, 0.4, 0.01, mod (16. * a + 0.5, 1.)) *\n         SmoothBump (0.05, 0.13, 0.01, 1. - length (qHit.yz) / 1.5));\n    } else {\n      col4.rgb *= (1. - 0.5 * SmoothBump (0.03, 0.06, 0.01, 1. - abs (qHit.x) / 3.5));\n      a = mod (32. * a, 1.);\n      if (abs (qHit.x) < 3.3) vn.yz = Rot2D (vn.yz, 0.4 * SmoothBump (0.25, 0.75, 0.2, a) *\n         sign (a - 0.5));\n    }\n  } else if (idObj == idWhl) {\n    col4 = vec4 (0.8, 0.8, 0.85, 0.1);\n    if (abs (vn.z) < 0.01) {\n      s = length (qHit.xy);\n      qHit.xy = vec2 (8. * atan (qHit.x, - qHit.y) / pi, qHit.z);\n      if (s > 4.1) {\n        s = mod (4. * qHit.z, 1.);\n        vn.z = -0.2 * SmoothBump (0.25, 0.75, 0.15, s) * sign (s - 0.5) * sign (qHit.z);\n        vn = normalize (vn);\n      }\n    }\n  } else if (idObj == idSpk) {\n    col4 = 1.1 * vec4 (0.8, 0.8, 0.85, 0.1);\n  } else if (idObj == idCrnk) {\n    col4 = vec4 (0.7, 0.7, 0.8, 0.2);\n  } else if (idObj == idAx) {\n    col4 = vec4 (0.8, 0.6, 0.2, 0.3);\n  } else if (idObj == idPis) {\n    col4 = vec4 (0.7, 0.7, 0.4, 0.3);\n  } else if (idObj == idCrod) {\n    col4 = vec4 (0.7, 0.75, 0.7, 0.3);\n  } else if (idObj == idCylEnt) {\n    col4 = vec4 (0.85, 0.5, 0.3, 0.2) * (0.5 + 0.5 * step (0.33, length (qHit.yz)));\n  } else if (idObj == idValv) {\n    col4 = vec4 (0.8, 0.5, 0.2, 0.2) * mix (1., 0.5 + 0.5 * step (0.13, length (qHit.yz)),\n       step (0., vn.x));\n  } else if (idObj == idPipes) {\n    col4 = vec4 (0.8, 0.5, 0.2, 0.2);\n  } else if (idObj == idSup) {\n    col4 = vec4 (0.8, 0.9, 0.3, 0.05);\n  }\n  return col4;\n}\n\nvoid SetConf ()\n{\n  aRot = -0.4 * 2. * pi * tCur;\n  aCs[0] = vec2 (cos (aRot), sin (aRot));\n  aCs[1] = vec2 (cos (aRot + pi * 2./3.), sin (aRot + pi * 2./3.));\n  aCs[2] = vec2 (cos (aRot + pi * 4./3.), sin (aRot + pi * 4./3.));\n  crRad = 2.;\n  crLen = 5.;\n  for (int k = 0; k < 3; k ++) {\n    crMid[k].y = -0.5 * crRad * aCs[k].y;\n    crCs[k] = vec2 (cos (asin (crMid[k].y / crLen)), crMid[k].y / crLen);\n    crMid[k].x = crLen * crCs[k].x + crRad * aCs[k].x;\n  }\n  aPen = 0.015 * pi * max (sin (pi * tCur), 0.);\n}\n\nvec3 SkShowScene (vec3 ro, vec3 rd, vec2 uv)\n{\n  vec4 col4, vn4;\n  vec3 col, vn;\n  float dstObj;\n  dMiss = dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn4 = ObjNfL (ro);\n    vn = vn4.xyz;\n    col4 = ObjCol (vn);\n    col = vec3 (1., 0.98, 0.96) * pow (Maxv3 (col4.rgb), 0.7);\n    col *= (1. - 0.5 * smoothstep (0.5, 1., abs (vn4.w) / 64.)) *\n       (0.9 + 0.2 * Noisefv2 (Rot2D (uv, 0.2 * pi) * vec2 (16., 256.))) *\n       (0.5 + 0.5 * max (dot (vn, ltDirS), 0.));\n    dMiss = dstFar;\n  } else {\n    col = vec3 (1.);\n  }\n  col = mix (col, vec3 (0.3), exp (- 64. * dMiss));\n  return clamp (col, 0., 1.);\n}\n\nvec3 SkMain (vec2 fCoord, float vp)\n{\n  mat3 vuMat;\n  vec3 ro, rd, col;\n  vec2 uv;\n  float el, az, szFacT;\n  szFacT = szFac;\n  uv = fCoord / vec2 (5., 5.5);\n  if (vp == 0.) {\n    szFac = 0.38;\n    uv -= vec2 (-0.9, -1.1);\n    el = -0.3 * pi;\n    az = 0.1 * pi;\n  } else if (vp == 1.) {\n    szFac = 0.32;\n    uv -= vec2 (-0.4, -0.7);\n    el = -0.13 * pi;\n    az = -0.4 * pi;\n  } else if (vp == 2.) {\n    szFac = 0.4;\n    uv -= vec2 (0.3, -1.4);\n    el = -0.25 * pi;\n    az = 0.7 * pi;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., -5., -20.);\n  rd = vuMat * normalize (vec3 (uv, 4.2));\n  ltDirS = vuMat * normalize (vec3 (0.7, 1., -0.7));\n  col = SkShowScene (ro, rd, uv);\n  szFac = szFacT;\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, db4;\n  vec3 col, vn, qHitEx;\n  vec2 qBlk, q, sq;\n  float dstObj, dstExObj, sh, r;\n  int idObjEx;\n  bool isBg;\n  SetConf ();\n  szFac = 0.5;\n  pgSize = vec3 (15., 0.1, 10.);\n  isBg = false;\n  isSh = false;\n  dstExObj = ExObjRay (ro, rd);\n  idObjEx = idObj;\n  qHitEx = qHit;\n  dstObj = ObjRay (ro, rd);\n  db4 = BlkHit (ro - vec3 (0., -2.6, -4.), rd, pgSize);\n  if (min (dstObj, dstExObj) < min (db4.x, dstFar)) {\n    if (dstObj < dstExObj) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      qBlk = mod (2. * ExBlkHit (ro, reflect (rd, vn)), 1.);\n      col4 = ObjCol (vn);\n    } else {\n      ro += dstExObj * rd;\n      vn = ExObjNf (ro);\n      if (idObjEx == idPen) {\n        r = length (qHit.xy);\n        col4 = mix (vec4 (0.9, 0.7, 0.1, 0.), vec4 (1., 0.9, 0.1, 0.01), step (0.34, r));\n        col4 = mix (vec4 (0.3, 0.3, 0.3, 0.), col4, step (0.18, r));\n        col4 = mix (vec4 (0.8, 0.4, 0.1, 0.2), col4, step (qHitEx.z, 4.5));\n      } else if (idObjEx == idFrm) {\n        col4 = vec4 (0.4, 0.5, 0.6, 0.) * (0.9 + 0.1 * Noisefv2 (32. * qHit.xz));\n      }\n    }\n  } else if (db4.x < dstFar) {\n    ro += db4.x * rd;\n    vn = db4.yzw;\n    q = ro.xz - vec2 (0., -4.);\n    if (vn.y > 0.5 && PrBox2Df (q, pgSize.xz - 0.96) < 0.) {\n      sq = sign (q);\n      col = (sq.x < 0. || sq.y < 0.) ? SkMain (q - 0.5 * sq * pgSize.xz,\n         sq.y + 1. + 0.5 * (sq.x + 1.)) : vec3 (1.);\n      if (Minv3 (col) > 0.95) {\n        q = smoothstep (0.02, 0.05, abs (mod (q + 0.5, 1.) - 0.5));\n        col = mix (vec3 (0.6, 0.8, 0.9), vec3 (1.), min (q.x, q.y));\n      }\n    } else {\n      col = vec3 (1.) * (0.8 + 0.2 * step (0.5, vn.y));\n      sh = 1.;\n    }\n  } else {\n    isBg = true;\n  }\n  if (! isBg) {\n    isSh = true;\n    sh = min (ObjSShadow (ro + 0.01 * vn, ltDir), ExObjSShadow (ro + 0.01 * vn, ltDir));\n    if (min (dstObj, dstExObj) < min (db4.x, dstFar)) {\n      col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n      col += col4.a * vec3 (0.5) * (0.5 + 0.5 * SmoothBump (0.25, 0.75, 0.05, qBlk.x) *\n         SmoothBump (0.25, 0.75, 0.05, qBlk.y));\n    } else {\n      col *= 0.3 + 0.7 * sh * max (dot (vn, ltDir), 0.);\n    }\n  } else {\n    qBlk = mod (8. * ExBlkHit (ro, rd), 1.);\n    col = vec3 (0.4, 0.5, 0.4) * (0.05 + 0.245 * (rd.y + 1.) * (rd.y + 1.)) +\n       vec3 (0.2) * (0.9 + 0.1 * SmoothBump (0.25, 0.75, 0.1, qBlk.x) *\n       SmoothBump (0.25, 0.75, 0.1, qBlk.y));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.28 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.8 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.5 * pi, -0.1 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., -4.8, -40.);\n  rd = vuMat * normalize (vec3 (uv, 4.));\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (0.7, 1., -0.7));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdt3R7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 1249, 1284, 1284, 2508], [2510, 2510, 2532, 2532, 5228], [5230, 5230, 5263, 5263, 5446], [5448, 5448, 5469, 5469, 5724], [5726, 5726, 5748, 5748, 6077], [6079, 6079, 6116, 6116, 6345], [6347, 6347, 6371, 6371, 6994], [6996, 6996, 7031, 7031, 7215], [7217, 7217, 7240, 7240, 7497], [7499, 7499, 7538, 7538, 7769], [7771, 7771, 7811, 7811, 8175], [8177, 8177, 8211, 8211, 8655], [8657, 8657, 8701, 8701, 9057], [9059, 9059, 9088, 9088, 11576], [11578, 11578, 11595, 11595, 12092], [12094, 12094, 12140, 12140, 12741], [12743, 12743, 12780, 12780, 13476], [13478, 13478, 13513, 13513, 16040], [16042, 16042, 16095, 16095, 16717], [16719, 16719, 16765, 16765, 16812], [16814, 16814, 16847, 16847, 16936], [16938, 16938, 16971, 16971, 16998], [17000, 17000, 17042, 17042, 17093], [17095, 17095, 17138, 17138, 17202], [17204, 17204, 17261, 17261, 17337], [17339, 17339, 17361, 17361, 17399], [17401, 17401, 17423, 17423, 17461], [17463, 17463, 17508, 17508, 17600], [17602, 17602, 17647, 17647, 17685], [17687, 17687, 17744, 17744, 17827], [17829, 17829, 17865, 17865, 18071], [18073, 18073, 18103, 18103, 18216], [18218, 18218, 18249, 18249, 18313], [18347, 18347, 18371, 18371, 18483], [18485, 18485, 18510, 18510, 18696]]}
{"id": "sdt3Rn", "name": "A Simple Laser effect", "author": "wangxiaochen", "description": "a simple laser effect", "tags": ["3d", "laser"], "likes": 0, "viewed": 189, "date": "1629211367", "time_retrieved": "2024-06-20T20:48:11.692671", "image_code": "#define MAX_STEPS 32\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Light_pos vec3(5.,5.,9.)\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.1,0.5,0.9) );\n}\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\nfloat smin(float a,float b,float h){\n    float c=clamp((b-a)/h*0.5+0.5,0.,1.);\n    //return c;\n    return mix(b,a,c)-h*c*(1.0-c);\n}\n\nmat2 rot(float a){\n   float c=sin(a);\n   float s=cos(a);\n    return mat2(c,s,-s,c);\n    \n}\nfloat GetDist(vec3 p){\n   return 1.9*(max(0.,fbm(p*.3)-.35+.05*abs(sin(iTime))));\n}\nfloat rayMarch(vec3 ro,vec3 rd){\n    float d0=0.;\n    float T=1.;\n    for(int i=0;i<MAX_STEPS;i++){\n        vec3 p=ro+rd*d0;\n        float ds=GetDist(p)/32.;\n        T*=(1.-ds);\n        d0+=50.*ds*T;\n        if(T<.001)break;\n        //if(d0>MAX_DIST||ds<SURF_DIST)break;\n    }\n    return d0;\n}\nvec3 getNormal(vec3 p){\n    float l= GetDist(p);\n    vec2 cau=vec2(.01,0.);\n    vec3 n=normalize(vec3(l-GetDist(p-cau.xyy),\n                          l- GetDist(p-cau.yxy),\n                          l- GetDist(p-cau.yyx)\n                           ));\n    return n;\n    \n}\nfloat  getLight(vec3 p){\n    vec3 ld=Light_pos;\n    vec3 li=normalize(ld-p);\n    vec3 sn=getNormal(p);\n    float sh=rayMarch(p+sn*SURF_DIST*2.,li);\n    float dif=clamp(dot(sn,li),0.,1.) ;\n    return dif;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 r0=vec3(0.,0.,5.);\n    vec3 rd=vec3(uv.x,uv.y-.2,1.);\n    vec3 col = vec3(1.);\n    col.xyz=vec3(1.)*rayMarch(r0,rd)*.09;\n    float d= rayMarch(r0,rd);\n    vec3 p=r0+rd*d;\n    vec3 n=getNormal(p);\n    float difu=getLight(p);\n     float ndotv=max(0.,dot(normalize(rd),n));\n    vec3 halfh=normalize(normalize(-rd)+normalize(Light_pos-p));\n    float ndothalfh=max(0.,dot(halfh,n));\n     col =mix(vec3(difu),spectrum(.4+ndothalfh),0.9);\n    col+=vec3(pow(ndothalfh,25.));\n    fragColor = vec4(col*difu,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdt3Rn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[99, 99, 167, 167, 210], [211, 211, 235, 235, 331], [439, 439, 462, 462, 501], [503, 503, 529, 529, 934], [936, 936, 957, 957, 1098], [1099, 1099, 1135, 1135, 1230], [1232, 1232, 1250, 1250, 1322], [1323, 1323, 1345, 1345, 1406], [1407, 1407, 1439, 1439, 1700], [1701, 1701, 1724, 1724, 1973], [1974, 1974, 1998, 1998, 2179], [2180, 2180, 2237, 2237, 2791]]}
{"id": "sdt3Rr", "name": "my shapes wont cooperate ", "author": "MyGoodSir", "description": "hacking on iq's code trying to experement and learn. my code is embarrassingly icky so dont look >:(\ni also broke some stuff trying to avoid having to comprehend iq's lighting/material code bc im lazy :/\n", "tags": ["sorryiq", "imadeamess"], "likes": 1, "viewed": 68, "date": "1629062512", "time_retrieved": "2024-06-20T20:48:13.800655", "image_code": "// Credit goes to inigo quilez for most of this code.\n//original can be found here:\n//https://www.shadertoy.com/view/4tVyWw\n\n// 0 = orthographics\n// 1 = perspective\n#define PROJECTION 1\n#define AA 1   // make this 1 is your machine is too slow\n\n//------------------------------------------------------------------\n\nvec3 v[16];\nivec4 faces[6] = ivec4[](\n    ivec4(0, 1, 2, 3), \n    ivec4(0, 1, 5, 4), \n    ivec4(1, 2, 6, 5), \n    ivec4(2, 3, 7, 6), \n    ivec4(3, 0, 4, 7), \n    ivec4(4, 5, 6, 7)\n    );\nstruct Indices{\n    int v[8];\n\n};\nIndices cube_indices[8];\n  \nvec3 cubecols[8] = vec3[](\n    vec3(1.,1.,1.),\n    vec3(1.,1.,0.),\n    vec3(1.,0.,1.),\n    vec3(0.,1.,1.),\n    vec3(0.,0.,1.),\n    vec3(0.,1.,0.),\n    vec3(1.,0.,0.),\n    vec3(0.,0.,0.)\n);\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n\n\nconst int lut[4] = int[](1,2,0,1); //\"left-upper triangle\"??\n\n// 0--b--3\n// |\\\n// a c\n// |  \\\n// 1    2\n//\nvec3 quadIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2, in vec3 v3 )\n{\n    // lets make v0 the origin\n    vec3 a = v1 - v0;\n    vec3 b = v3 - v0;\n    vec3 c = v2 - v0;\n    vec3 p = ro - v0;//change basis\n\n    // intersect plane\n    vec3 nor = cross(a,b);//normal of plane (kinda. might not have the right magnitude, but we care about direction)\n    float t = -dot(p,nor)/dot(rd,nor);\n    if( t<0.0 ) return vec3(-1.0);\n    \n    // intersection point\n    vec3 pos = p + t*rd;\n\n    // bilinear interpolation: https://www.shadertoy.com/view/lsBSDm\n    \n    // select projection plane\n    vec3 mor = abs(nor);\n    int id = (mor.x>nor.y && mor.x>mor.z ) ? 0 : \n             ((mor.y>mor.z)                ? 1 : \n                                             2);\n    int idu = lut[id  ];\n    int idv = lut[id+1];\n    \n    // project to 2D\n    vec2 kp = vec2( pos[idu], pos[idv] );\n    vec2 ka = vec2( a[idu], a[idv] );\n    vec2 kb = vec2( b[idu], b[idv] );\n    vec2 kc = vec2( c[idu], c[idv] );\n    \n    // find barycentric coords of the quadrilateral\n    vec2 kg = kc-kb-ka;\n\n    float k0 = cross2d( kp, kb );\n    float k2 = cross2d( kc-kb, ka );        // float k2 = cross2d( kg, ka );\n    float k1 = cross2d( kp, kg ) - nor[id]; // float k1 = cross2d( kb, ka ) + cross2d( kp, kg );\n    \n    // if edges are parallel, this is a linear equation\n\tfloat u, v;\n    if( abs(k2)<0.001 )\n    {\n\t\tv = -k0/k1;\n\t    //u  = (kp.x*k1+ka.x*k0) / (kb.x*k1-kg.x*k0);\n    }\n\telse\n    {\n        // otherwise, it's a quadratic\n        float w = k1*k1 - 4.0*k0*k2;\n        if( w<0.0 ) return vec3(-1.0);\n        w = sqrt( w );\n\n        float ik2 = 1.0/(2.0*k2);\n\n        v = (-k1 - w)*ik2; \n        if( v<0.0 || v>1.0 ) \n            v = (-k1 + w)*ik2;\n    }\n    u = (kp.x - ka.x*v)/(kb.x + kg.x*v);\n    if( u<0.0 || u>1.0 || v<0.0 || v>1.0) return vec3(-1.0);\n    \n    return vec3( t, u, v );\n}\n\n\n\n\nfloat iCapsule( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        float y = baoa + t*bard;\n        \n        // body\n        if( y>0.0 && y<baba ) return t;\n\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 )\n        {\n            return -b - sqrt(h);\n        }\n    }\n    return -1.0;\n}\n\nvec3 nCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 ba = b-a, pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return (pa - h*ba)/r;\n}\n\nvec3 dCapsule( in vec3 ro, in vec3 rd, vec3 pa, vec3 pb, float rad )\n{\n\tvec3 ba = pb - pa;\n\tvec3 oa = ro - pa;\n\t\n\tfloat oad  = dot( oa, rd );\n\tfloat dba  = dot( rd, ba );\n\tfloat baba = dot( ba, ba );\n\tfloat oaba = dot( oa, ba );\n\t\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\t\n\tth.x = max(   th.x, 0.0 );\n\tth.y = clamp( th.y, 0.0, 1.0 );\n\t\n\tvec3 p = pa + ba*th.y;\n\tvec3 q = ro + rd*th.x;\n\t\n\treturn vec3( length( p-q )-rad, th );\n}\n\n\n\nint objA, objB;\nbool cubeHit[8];\nbool poleHit;\nconst float rad = 0.07;\n\nfloat intersect( in vec3 ro, in vec3 rd, in vec3 v[16] )\n{\n    cubeHit = bool[](false,false,false,false,false,false,false,false);\n    poleHit=false;\n    float tmp;\n    \n    float res = 1e10;\n\n    \n\n    for( int i=0; i<16; i++ ) // for each vertex\n    for( int j=0; j< 4; j++ ) // connect it to its 4 neighbors\n    {\n        int a = i;\n        int b = a ^ (1<<j); // change one bit/dimension\n        if( a<b )          // skip edge if already visited\n        {\n            tmp = iCapsule( ro, rd, v[a], v[b], rad );\n            if( tmp>0.0 && tmp<res )\n            {\n                poleHit=true;\n                res = tmp; \n                objA = a; \n                objB = b;\n            }\n        }\n    }\n    \n    \n    for(int ci=0; ci<8; ci++){\n        for(int fi; fi<6; fi++){\n            ivec4 fvoffsets = faces[fi];\n            Indices cube_verts = cube_indices[ci];\n            vec3 v0 = v[cube_verts.v[fvoffsets.x]];\n            vec3 v1 = v[cube_verts.v[fvoffsets.y]];\n            vec3 v2 = v[cube_verts.v[fvoffsets.z]];\n            vec3 v3 = v[cube_verts.v[fvoffsets.w]];\n            tmp = quadIntersect(ro, rd, v0, v1, v2, v3).x;\n            if(tmp > 0. && tmp<res){\n                cubeHit[ci] = true;\n                res=tmp;\n            }\n\n        //     int a = ci;\n        //     int b = a^(1<<fi);\n        //     if( a<b )          // skip edge if already visited\n        // {\n        //     tmp = iCapsule( ro, rd, v[a], v[b], rad );\n        //     if( tmp>0.0 && tmp<res )\n        //     {\n        //         res = tmp; \n        //         objA = a; \n        //         objB = b;\n        //     }\n        // }\n\n        }\n    }\n    \n\n    return (res<1e9)?res:-1.0;\n}\n\nvec3 calcNormal( in vec3 pos, in vec3 v[16] )\n{\n    return nCapsule( pos, v[objA], v[objB], rad );\n}\n\nfloat softShadowCapsule( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r )\n{\n    const float k = 16.0;\n    vec3 t = dCapsule( ro, rd, a, b, r );\n    return clamp( k*t.x/max(t.z,0.0001), 0.0, 1.0 );\n}\n\n\n// soft shadows\nfloat calcShadow( in vec3 ro, in vec3 rd, in vec3 v[16] )\n{\n    float t = 1.0;\n    \n    for( int i=0; i<16; i++ ) // for each vertex\n    for( int j=0; j< 4; j++ ) // connect it to its 4 neighbors\n    {\n        int a = i;\n        int b = a ^ (1<<j); // change one bit/dimension\n        if( a<b )           // skip edge if already visited\n        {\n            t = min( t, softShadowCapsule( ro, rd, v[a], v[b], rad ) );\n        }\n    }    \n\n    return t;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float seed, in vec3 v[16] )\n{\n    return 1.0;\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd, in float seed, in vec3 v[16] )\n{ \n    vec3 col = vec3(0.04) + 0.03*rd.y;\n\n    float t = intersect(ro,rd,v);\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, v );\n        // material        \n\t\tcol = vec3(0.4);\n\n        // lighting\n        if(poleHit){\n        float occ = calcAO( pos, nor, seed, v )*(0.7+0.3*nor.y);\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        float sha = (dif>0.001) ? calcShadow( pos+0.02*nor, lig, v ) : 0.0;\n\n\t\tfloat spe = pow( clamp( dot(nor,hal), 0.0, 1.0 ),16.0)*dif*sha*\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.20,0.80,0.65)*vec3(sha,0.5*sha+0.5*sha*sha,sha*sha);\n        lin += 0.70*amb*vec3(0.70,0.80,1.00)*occ;\n        lin += 1.00*fre*vec3(1.20,1.10,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 15.00*spe*vec3(1.00,0.90,0.70);\n        }\n        for(int i = 0; i<8; i++){\n            if(cubeHit[i]){\n                col += cubecols[i]*(1./8.);\n            }\n        }\n    }\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 transform( in vec4 p )\n{\n    p.xw *= rot(iTime*0.41);\n    p.yw *= rot(iTime*0.23);\n    p.xy *= rot(iTime*0.73);\n    p.wz *= rot(iTime*0.37);\n    \n    // orthogonal projection\n    #if PROJECTION==0\n    return p.xyz;\n    #else\n    // perspective projection\n\treturn 2.5*p.xyz/(3.0+p.w);\n    #endif\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    cube_indices[0] = Indices(int[](3, 0,  4,  7,  11, 8,  12, 15));\n    cube_indices[1] = Indices(int[](1, 2,  6,  5,  9,  10, 14, 13));\n    cube_indices[2] = Indices(int[](0, 1,  5,  4,  8,  9,  13, 12));\n    cube_indices[3] = Indices(int[](2, 3,  7,  6,  10, 11, 15, 15));\n    cube_indices[4] = Indices(int[](0, 1,  2,  3,  8,  9,  10, 11));\n    cube_indices[5] = Indices(int[](4, 5,  6,  7,  12, 13, 14, 15));\n    cube_indices[6] = Indices(int[](0, 1,  2,  3,  4,  5,  6,  7));\n    cube_indices[7] = Indices(int[](8, 9,  10, 11, 12, 13, 14, 15));\n    vec3 v[16];\n\n    // rotate 4D cube\n    v[ 0] = transform( vec4(-1,-1,-1,-1));\n    v[ 1] = transform( vec4(-1,-1,-1, 1));\n    v[ 2] = transform( vec4(-1,-1, 1,-1));\n    v[ 3] = transform( vec4(-1,-1, 1, 1));\n    v[ 4] = transform( vec4(-1, 1,-1,-1));\n    v[ 5] = transform( vec4(-1, 1,-1, 1));\n    v[ 6] = transform( vec4(-1, 1, 1,-1));\n    v[ 7] = transform( vec4(-1, 1, 1, 1));\n    v[ 8] = transform( vec4( 1,-1,-1,-1));\n    v[ 9] = transform( vec4( 1,-1,-1, 1));\n    v[10] = transform( vec4( 1,-1, 1,-1));\n    v[11] = transform( vec4( 1,-1, 1, 1));\n    v[12] = transform( vec4( 1, 1,-1,-1));\n    v[13] = transform( vec4( 1, 1,-1, 1));\n    v[14] = transform( vec4( 1, 1, 1,-1));\n    v[15] = transform( vec4( 1, 1, 1, 1));\n    \n    \n    // camera (static)\n    vec3 ro = vec3( 4.5, 1.5, -10.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n\t#define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float seed =  gl_FragCoord.x + gl_FragCoord.y*131.1 + iTime + 17.1*float(m) + 37.4*float(n);\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float seed =  gl_FragCoord.x + gl_FragCoord.y*131.1 + iTime;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd, seed, v );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // cheap dither to remove banding from background\n    tot += 0.5*sin(fragCoord.x)*sin(fragCoord.y)/256.0;\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdt3Rr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[245, 754, 793, 793, 821], [887, 932, 1026, 1057, 2825], [2830, 2830, 2908, 2908, 3639], [3641, 3641, 3703, 3703, 3816], [3818, 3818, 3888, 3888, 4280], [4356, 4356, 4414, 4414, 6039], [6041, 6041, 6088, 6088, 6141], [6143, 6143, 6228, 6228, 6351], [6354, 6370, 6429, 6429, 6825], [6827, 6827, 6899, 6899, 6917], [6920, 6920, 6989, 6989, 8229], [8231, 8231, 8283, 8283, 8460], [8462, 8462, 8481, 8481, 8554], [8556, 8556, 8585, 8585, 8857], [8860, 8860, 8917, 8917, 11341]]}
{"id": "sdtGzM", "name": "Basic Tile(2)", "author": "chenxiaoleizi", "description": "move the tile", "tags": ["movetile"], "likes": 1, "viewed": 27, "date": "1629440821", "time_retrieved": "2024-06-20T20:48:13.806497", "image_code": "vec2 tile(vec2 st, float scale, float t){\n    st *= scale;\n    \n    // Move direction\n    float a = mod(st.y, 2.0) > 1.0 ? 1.0 : -1.0;\n    // Offset\n    st.x += a * t;\n    \n    return fract(st);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    uv = tile(uv, 15.0, iTime);\n\n    // Block dot\n    float d = length(uv - vec2(0.5, 0.5));\n    float pix = 22./iResolution.y;\n    vec3 col = vec3(smoothstep(0.3, 0.3+pix, d));\n    col += vec3(1.0, 0.0, 0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdtGzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 41, 41, 196], [198, 198, 255, 305, 617]]}
{"id": "sl2SDG", "name": "大龙猫 - Terrain I ", "author": "totetmatt", "description": "Testing some idea function. pretty sure it's not optimized and / or heavy but yolo I like the rendering :) ", "tags": ["terrain"], "likes": 9, "viewed": 219, "date": "1628541862", "time_retrieved": "2024-06-20T20:48:13.806769", "image_code": "#define fGlobalTime iTime\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat _tx(float t){\n  return clamp(abs(sin(t))-.5,0.,.35)*2.;\n  }\nfloat tx(vec2 t){\n  float q = 4.0;\n  for(float i=1.;i<=8.;i++){\n       \n       q =q + sign(mod(i,1.)-.5)* _tx(t.y+t.x*i*3.1415+i*2.)/(i*4.);\n       t*=rot(-.785);\n    }\n    return q;\n  \n  }\nvec2 sdf(vec3 p){\n  vec3 op = p;\n  p.z +=fGlobalTime*.1;\n\n    vec2 h;\n  h.x = dot(p,vec3(0.,1.,.0))-tx(p.xz*.8+tx(p.zx*.8)/8.)/4.;\n  h.x = max(length( op+vec3(0.,-1.5,0.) )-1.2,h.x);\n  h.x*=.9;\n  h.y = 1.;\n  return h;\n}\n\n#define q(s) s*sdf(p+s).x\nvec2 e= vec2(-.0005,.0005);\nvec3 norm(vec3 p){return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\n#define ao(rp,n,k) (sdf(rp+n*k).x/k)\n#define AO(rp,n) (ao(rp,n,.1)+ao(rp,n,10.)+ao(rp,n,100.))\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col =vec3(.1);\n  vec3 ro = vec3(sin(fGlobalTime*.1)*1.,1.2,cos(fGlobalTime*.2)*1.);\n  vec3 rt = vec3(0.,0.5,0);\n  vec3 z = normalize(rt-ro);\n  vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n  vec3 y = normalize(cross(z,x));\n  vec3 rd =mat3(x,y,z)*normalize(vec3(uv,1.));\n  vec3 light =mat3(x,y,z)*vec3(0.,1.,-0.5);\n  vec3 rp = ro;\n \n  for(float i=0.;i<=128.;i++){\n      vec2 d = sdf(rp);\n      if(length(rp) > 100.)break;\n      if(d.x <=.001){\n          vec3 n= norm(rp);\n        \n          float diff = max(0.,dot(normalize(light-rp),n));\n          float spec = pow(max(0.,dot(normalize(ro-rp),reflect(-normalize(light),n))),32.);\n        float  fr=pow(1.+dot(n,rd),8.);\n          col = vec3(.1)*diff+spec+2.*vec3(1.,.7,0.5)*fr;\n          col = mix(vec3(.1),col,fr+AO(rp,n)/3.);\n        \n          break;\n       }\n       rp+=rd*d.x;\n  }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sl2SDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[26, 26, 44, 44, 91], [92, 92, 111, 111, 157], [158, 158, 175, 175, 347], [348, 348, 365, 365, 567], [623, 623, 641, 641, 696], [792, 792, 849, 849, 1792]]}
{"id": "sl2SRt", "name": "2d tree branching SDF ", "author": "TLC123", "description": "2d, sdf, distance, primitive, tree, branch.\n", "tags": ["2d", "sdf", "tree", "distance", "primitive", "branch"], "likes": 10, "viewed": 83, "date": "1628433175", "time_retrieved": "2024-06-20T20:48:13.806769", "image_code": "float PI=acos(-1.);\nfloat TAU=acos(-1.)*2.;\n\nfloat  smin( float a, float b,float k ){\n    float h =  clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 ) ;\n    return mix( b, a, h ) - k*h*(1.0-h);  }\n    \nfloat  smax( float a, float b,float k )\n{ return -smin(-a,-b,k);}\n\nfloat Tree(vec2 uv, int branches){\n// to polar\nvec2 p=vec2((atan(uv.x,uv.y)/TAU)*float(branches),length(uv));\n\n//f\nfloat Y,y,X;\n // the magic number hoha\n  Y= exp2( floor(p.y));\n  y=  .5+( pow(fract(p.y),.85 ))*.5+.5;\n  X=abs(p.x* Y);\n  p.x=        abs(fract(X-y*.5)-.5)*2.;\n  p.x= max(p.x,abs(fract(X+ y*.5)-.5)*2. );\n // \n  float branchwidth=.1/(.25+p.y);\n  float outerlimit =p.y-4.6;\n  float scaleAdjusted= 1.5*(((1.-p.x)/Y)*p.y);\n  return  smax(outerlimit, scaleAdjusted-branchwidth ,.2)* .5 ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (sin(iTime*1.73)*3.+ 9.1)*(fragCoord/max(iResolution.y,iResolution.x) -vec2(.4)- .1*vec2(sin(iTime*.37),cos(iTime*.4)));\n//\n int branches=3;\n float d=Tree(uv,branches) ;\n   // coloring\n    vec3 col = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7);\n    col *= 1.0 - exp(-2.0 * abs(d));\n    col *= 0.8 + 0.2 * cos(128.0 * abs(d));\n    col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n\n     fragColor = vec4(col, 1.0);\n \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sl2SRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[45, 45, 85, 85, 181], [187, 187, 228, 228, 252], [254, 254, 288, 300, 753], [756, 756, 813, 863, 1309]]}
{"id": "slBSDV", "name": "Trip - 1", "author": "birdbird", "description": "Using log polar-tiling (as described here https://www.osar.fr/notes/logspherical/) to create an infinitely zooming shader.", "tags": ["infinitezoom", "logtiling"], "likes": 4, "viewed": 170, "date": "1628627748", "time_retrieved": "2024-06-20T20:48:14.176937", "image_code": "const float pi = acos(-1.);\n\n//https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\nfloat map_range(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n//https://gist.github.com/ayamflow/c06bc0c8a64f985dd431bd0ac5b557cd\nvec2 rotateUV(vec2 uv, float rotation)\n{\n    float mid = 0.5;\n    return vec2(\n        cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,\n        cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid\n    );\n}\n\nfloat map(vec2 uv) {\n    int iterations = 2;\n    vec2 ouv = uv;\n    \n    uv.y += iTime/10.;\n    uv = abs(mod(uv, 1.)*4. - 2.);\n    \n    for(int i = 0; i < iterations; i ++) {\n        float fi = float(i);\n        float fit = float(iterations);\n        \n        uv = abs(uv - (vec2(0.5 + (fi/fit)*0.6 )));\n        \n        uv *= 1.16;\n        \n        uv = rotateUV(uv, map_range(ouv.x,-1.,1., 0.2, 5.) );\n    }\n    \n    return sin(length(uv)*10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 uv_o = uv;\n    \n    //Barrel distortion\n    vec2 w_uv = uv * dot(uv,uv);\n    uv = mix(uv, w_uv, 0.4);\n    \n    //Log polar-tiling -> https://www.osar.fr/notes/logspherical/\n    vec2 pos = vec2(log(length(uv)), atan(uv.y, uv.x));\n    pos *= 6./pi;\n    pos = fract(pos) - 0.5;   \n    uv = pos;\n    uv.x -= iTime/(2.8) + 5700.;\n    \n    //RGB offset\n    float offset_range = 0.04;\n    float offset = map_range(sin(iTime),-1.,1.,0.2,1.) * offset_range;\n    float offset_y = cos(iTime) * offset_range * 0.2;\n    \n    float cr = map(uv + vec2(offset, 0.));\n    float cg = map(uv + vec2(offset*2., offset_y*2.));\n    float cb = map(uv + vec2(offset*3., offset_y*3.));\n    vec3 color = vec3(cr, cg, cb)*3.;\n    \n    //Fade to black towards center to hide aliasing\n    float mask = (1. - pow(length(uv_o),0.96) )*3.;\n    color -= mask;\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/slBSDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[29, 97, 175, 175, 241], [243, 311, 351, 351, 547], [549, 549, 569, 569, 997], [999, 999, 1056, 1056, 1991]]}
{"id": "slBXRG", "name": "Rectangle A-A", "author": "modesty", "description": "t", "tags": ["aliasing", "antialiasing", "rectangle", "aa", "help"], "likes": 0, "viewed": 124, "date": "1627912419", "time_retrieved": "2024-06-20T20:48:14.176937", "image_code": "#define linearstep(edge0, edge1, x) clamp((x - (edge0)) / (edge1 - (edge0)), 0.0, 1.0)\n\nfloat box(in vec2 _st, in vec2 _size, vec2 aa, vec3 color, inout vec3 pixel){\n    _size = vec2(0.5) - _size*0.5;\n    vec2 uv = smoothstep(_size, _size+aa, _st);\n        uv *= smoothstep(_size, _size+aa, vec2(1.0)-_st);\n    float res = uv.x*uv.y;\n    if (res > 0.) {\n        pixel = color;   \n    }\n    return res;\n}\n\nfloat stationary(vec2 st, vec3 color, inout vec3 pixel) {\n    float res = 0.;\n    vec2 aa = vec2(0.01);\n    // top\n    res = max(res, box(st - vec2(0.0, 0.225), vec2(0.35, 0.150), aa, color, pixel));\n    // right\n    res = max(res, box(st - vec2(0.17, 0.0), vec2(0.2, 0.60), aa, color, pixel));\n    // bottom\n    res = max(res, box(st - vec2(0.0, -0.225), vec2(0.35, 0.150), aa, color, pixel));\n    // left\n    res = max(res, box(st - vec2(-0.17, 0.0), vec2(0.2, 0.60), aa, color, pixel));\n    if (res >0.) {\n        pixel = color;    \n    }\n\n    return res;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}      \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = 2. * vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    // increase the value to receive smaller uv\n    float sizeNumber = 10.;\n    \n    uv *= vec2(sizeNumber);\n    \n    // rotation to see the issue with AA(anti-aliasing)\n    uv = rotate2d(iTime) * uv;\n    \n    uv += vec2(0.5);\n    \n    // some articles (ex: http://jeremt.github.io/pages/anti-aliased_shapes_in_glsl.html \n    // suggests to use fWidth function to get the scale, can't do it with this rectangle which has shadow \n    // and emtpiness inside\n    highp vec2 uvPixel = fwidth(uv);\n    \n    vec3 col = vec3(1.);\n    \n    float on = 0.0;\n    vec3 pixel = vec3(0.0);\n\n    vec2 stShadow = uv*0.7;\n    stShadow += 0.15;\n\n    on = max(on, stationary(stShadow, vec3(0.0), col));\n    on = max(on, stationary(uv, vec3(0.0, 1.0, 0.0), col));\n            \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/slBXRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[88, 88, 165, 165, 403], [405, 405, 462, 462, 965], [967, 967, 995, 995, 1081], [1089, 1089, 1146, 1146, 2045]]}
{"id": "sljSD3", "name": "spinning star", "author": "snflwrfld", "description": "a star that spins", "tags": ["simple"], "likes": 3, "viewed": 75, "date": "1628792534", "time_retrieved": "2024-06-20T20:48:14.176937", "image_code": "mat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nfloat fract2(float x){\n    return abs((fract(x)-.5)*2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Initialisation\n    vec2 st = fragCoord/iResolution.y;\n    vec3 color = vec3(1.0);\n    float t = iTime*.5;\n    //remap\n    st = st*2.-1.;\n\n    st = rotate2d(t*.9)*st;\n    float r = length(st)*.9,th = atan(st.y,st.x);\n    for(int i=0;i<3;i++){\n        color[i] *= smoothstep(.4,.6,fract2(r*(abs(sin(th*2.5+float(i)*.07))+1.)*.85+t*2.));\n    }\n    \n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sljSD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 28, 28, 114], [117, 117, 139, 139, 175], [177, 177, 233, 255, 621]]}
{"id": "slSSDd", "name": "morphing sphere", "author": "kithy", "description": "displacement shpere surface", "tags": ["raymarching", "displacement", "morphing"], "likes": 4, "viewed": 54, "date": "1628862444", "time_retrieved": "2024-06-20T20:48:14.176937", "image_code": "#define ITR 32\n#define EPS 0.001\n\nmat2 rot(float angle){\n\tfloat s=sin(angle);\n\tfloat c=cos(angle);\n\treturn mat2(c,-s,s,c);\n}\n\nfloat sdSphere(vec3 p){\n\treturn length(p)-1.0;\n}\n\nfloat displacement(vec3 p){\n\tfloat h=(sin(p.x)*sin(p.y)*sin(p.z));\n\treturn h*sin(iTime)*2.0;\n}\n\nfloat mainDist(vec3 p){\n\tp.xy*=rot(iTime);\n\tp.xz*=rot(iTime);\n\tfloat disp=displacement(p);\n\tfloat dist=sdSphere(p);\n\treturn disp+dist;\n}\n\nvec3 genNormal(vec3 p){\n\treturn normalize(p);\n}\n\n\n// vec3 genNormal(vec3 p){\n// \tvec3 normal=vec3(\n// \t\tsdSphere(p+vec3(EPS,0.0,0.0))-sdSphere(p+vec3(-EPS,0.0,0.0)),\n// \t\tsdSphere(p+vec3(0.0,EPS,0.0))-sdSphere(p+vec3(0.0,-EPS,0.0)),\n// \t\tsdSphere(p+vec3(0.0,0.0,EPS))-sdSphere(p+vec3(0.0,0.0,-EPS))\n// \t\t);\n// \treturn normalize(normal);\n// }\n\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tvec3 ro=vec3(0.0,0.0,-10.0);\n\tvec3 lookat=vec3(0.0,0.0,0.0);\n\tfloat zoom=5.0;\n\n\tvec3 f=normalize(lookat-ro);\n\tvec3 r=normalize(cross(vec3(0.0,1.0,0.0),f));\n\tvec3 u=cross(f,r);\n\tvec3 c=ro+f*zoom;\n\tvec3 i=c+uv.x*r+uv.y*u;\n\tvec3 rd=normalize(i-ro);\n   \n    float d,t;\n    vec3 p,n;\n\n\tvec3 col=vec3(1.0);\n    \n    for(int i=0;i<ITR;i++){\n        p=ro+rd*t;\n\n        d=mainDist(p);\n        n=genNormal(p);\n        if(d<EPS)break;\n        t+=d;\n    }\n\tcol=n*0.5+0.5;\n\n\tfragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/slSSDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[34, 34, 56, 56, 124], [126, 126, 149, 149, 174], [176, 176, 203, 203, 270], [272, 272, 295, 295, 408], [410, 410, 433, 433, 457], [460, 755, 808, 808, 1357]]}
{"id": "slSSzt", "name": "Raymarching wavefront", "author": "pyBlob", "description": "The original shader interactively shows raymarching iterations for a *single* ray.\nThis shader simultaneously shows raymarching iterations for *all* rays starting from a single point.", "tags": ["raymarching", "visualization"], "likes": 12, "viewed": 285, "date": "1629027301", "time_retrieved": "2024-06-20T20:48:15.340213", "image_code": "/*\nThe original shader interactively shows raymarching for a single ray.\nThis shader simultaneously shows raymarching for ALL rays starting from a single point.\nEvery red point is the endpoint of some ray for some raymarching iteration.\nI think, this is one of the first visualizations that shows the individual raymarching steps all at once.\n\nWavefront mode:\n    - Move raymarching source with your mouse.\n    - Uncomment original sdf in scene(vec2) function.\n\nRay mode (original):\n    - Pick raymarching source by pressing mouse.\n    - Move raymarchign target.\n    - R: toggle original ray visualization.\n*/\n\nconst int AA = 16;\nconst int iterations = 20;\nconst int substep = 1;\n\n#define T (iTime * 1.)\nconst float _precision = 1e-4;\nconst float maxSteps = float(iterations);\nconst float maxDistance = 5.;\n\nconst int y_press = 0;\nconst int y_delta = 1;\nconst int y_toggle = 2;\n\nconst int key_R = 0x52;\nbool visualizeRay()\n{\n    return texelFetch(iChannel3, ivec2(key_R, y_toggle), 0).x > .5;\n}\n\nvec2 _p; float _d = 1e10;\n\nfloat sdBox(vec2 p,vec2 s)\n{\n    return length(max(p=abs(p)-s,0.))+min(max(p.x,p.y),0.);\n}\n\nfloat sdLine(vec2 p,vec2 a,vec2 b)\n{\n    return length(-clamp(dot(p-=a,b-=a)/dot(b,b),0.,1.)*b+p);\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    sca = normalize(sca);\n    scb = normalize(scb);\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x > scb.x*p.y) ? dot(p,scb) : length(p);\n    return sqrt(max(0., dot(p,p) + ra*ra - 2.0*ra*k)) - rb;\n}\n\nfloat side(float r, float h)\n{\n    return sqrt(r*r - h*h);\n}\n\nfloat sdArcTo(in vec2 p, in vec2 a, in vec2 b, float r)\n{\n    vec2 m = a + b;\n    float tb = dot(m, b) / length(m);\n    float arc = sdArc(p, vec2(m.y, -m.x), vec2(side(r, tb), tb), r, 0.);\n    //return min(min(length(p-a), length(p-b)), min(length(p-m), min(arc, length(p)))) -.01;\n    return arc;\n}\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat scene(vec2 p)\n{\n    p.x += .5;\n    float ball = length(p - vec2(1, 0)) - .3;\n    float lens = length(p - vec2(.8, 0)) - .15;\n    float wire = abs(p.y) - .05;\n    vec2 q = p; q.y = abs(q.y);\n    float eye = max(max(ball,-lens),-wire);\n    float bx = (pow(.3,2.)-pow(.15,2.)+pow(.2,2.))/(2.*.2);\n    float bh = side(.3, bx);\n    float ballArc = sdArcTo(q - vec2(1, 0), vec2(-bx,bh), vec2(side(.3,.05), .05), .3);\n    float lensArc = sdArcTo(q - vec2(.8, 0), vec2(.2-bx,bh), vec2(side(.15,.05), .05), .15);\n    float wireLine = sdLine(q, vec2(.8+side(.15,.05), .05), vec2(1.+side(.3,.05), .05));\n    float eye1 = min(min(ballArc, lensArc), wireLine) * sign(eye);\n    float socket = min(\n        sdBox(vec2(p.x,abs(p.y))-vec2(1,.6),vec2(.3,.05)),\n        sdBox(vec2(p.x,abs(p.y))-vec2(1.25,.55),vec2(.05,.05))\n    );\n    //if (false)\n        return min(eye1, socket); // proper sdf\n    return min(eye, socket); // original sdf\n}\n\nvec2 getNormal(vec2 p)\n{    \n\tvec2 e = vec2(_precision, 0);\n    return normalize(vec2(scene(p+e.xy)-scene(p-e.xy),scene(p+e.yx)-scene(p-e.yx)));\n}\n\nvoid visualize(vec2 ro, vec2 rd, float t, float d, float i)\n{\n    vec2 n = getNormal(ro+rd*t);\n    \n    float x  = clamp(floor(T)-i,0.,1.);\n    float f1 = x + (1.-x) * fract(T);\n    float f2 = clamp((f1-.75)*16.,0.,1.);\n    float f3 = floor(abs(cos(min(f1*8.,1.)*6.283))+.5);\n    float a  = mix(atan(-n.y,-n.x),atan(rd.y,rd.x),f2);\n\n    // ray line\n    _d = min(_d,sdLine(_p,ro+rd*t,ro+rd*t+vec2(cos(a),sin(a))*d*floor(f3)));\n\n    // step indicator\n    _d = min(_d,length(_p-ro-rd*t)-.015);\n\n    if (i == floor(T))\n    {\n        // circle\n        _d = min(_d,abs(length(_p-ro-rd*t)-clamp(d*f3,0.,1e4)));\n    }\n}\n\nvec4 march(vec2 ro, vec2 rd)\n{\n    float t = 0., s = float(maxSteps), d;\n\n    for(float i = 0.; i < maxSteps; i++)\n    {\n        d = scene(ro+rd*t);\n\n        if (d < _precision || t > maxDistance || i > floor(T))\n        {\n            s = float(i);\n            break;\n        }\n\n\t\tvisualize(ro,rd,t,d,i);\n        \n        t += d;\n    }\n    \n    return vec4(ro+rd*t,d,s);\n}\n\nvoid swap(inout vec2 a, inout vec2 b)\n{\n    vec2 z = a;\n    a = b;\n    b = z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zero = min(0., iTime);\n\n    _p = (2.*fragCoord.xy-iResolution.xy)/iResolution.yy;\n\tvec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.yy;\n    vec2 c = (2.*abs(iMouse.zw)-iResolution.xy)/iResolution.yy;\n    bool demo = iMouse.z == 0.;\n    \n    if (demo)\n    {\n        float a = .3 * iTime;\n        c = vec2(.5, 0.) + .5 * vec2(cos(a), sin(a));\n        m = c;\n    }\n    else if (visualizeRay())\n    {\n        //swap(m, c);\n    }\n    else\n    {\n        c = m;\n    }\n    \n    vec2 ro = c;//vec2(-1,0);\n    vec2 rd = normalize(m-ro);\n    vec4 h  = march(ro,rd);\n    \n    // camera & scene\n    _d = min(_d,min(min(abs(length(_p-ro)-.01),sdLine(_p,ro,ro+rd*.05)),scene(_p)));\n        \n    // normal arrow\n    if (h.z < _precision)\n    {\n        vec2 n = getNormal(h.xy);\n        vec2 t = vec2(-n.y,n.x);\n\n        _d = min(_d,sdLine(_p,h.xy,h.xy+n*.1));\n        _d = min(_d,sdLine(_p,h.xy+n*.1,h.xy+n*.1+t*.025));\n        _d = min(_d,sdLine(_p,h.xy+n*.1,h.xy+n*.1-t*.025));\n        _d = min(_d,sdLine(_p,h.xy+n*.1+t*.025,h.xy+n*.125));\n        _d = min(_d,sdLine(_p,h.xy+n*.1-t*.025,h.xy+n*.125));\n    }\n    \n    _d = abs(_d)-1./iResolution.y;\n    \n\tfragColor = vec4(vec3(smoothstep(_d,_d+.005,.005)),1.0);\n\n    vec4 col = vec4(0);\n    for (int i=1 ; i<2*AA ; i+=2)\n    for (int j=1 ; j<2*AA ; j+=2)\n    {\n        vec2 jitter = (vec2(i, j) / float(AA) - .5) / iResolution.yy;\n        vec2 ro1 = ro;// + jitter;\n        vec2 _p1 = _p + jitter;\n        vec2 rd1 = normalize(_p1 - ro1);\n        float r = length(_p1 - ro1);\n        float t1 = 0.;\n        for (int i=0 ; i<iterations*substep ; ++i)\n        {\n            t1 += scene(ro1 + rd1 * t1) / float(substep);\n            //col += vec4(1,0,0,1) * max(0., 1. - abs(t1 - r) * iResolution.y / 1.);\n            col += vec4(1,0,0,1) * step(abs(t1 - r) * iResolution.y, 1.);\n        }\n    }\n    col /= float(AA * AA);\n    fragColor = col + fragColor * (1. - col.w);\n    fragColor.xyz = pow(fragColor.xyz, vec3(.45));\n    //fragColor = vec4(visualizeRay());\n    \n    //fragColor = vec4(sin(scene(_p) * iResolution.y));\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/slSSzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 903, 924, 924, 994], [1023, 1023, 1051, 1051, 1113], [1115, 1115, 1151, 1151, 1215], [1217, 1217, 1292, 1292, 1531], [1533, 1533, 1563, 1563, 1593], [1595, 1595, 1652, 1652, 1894], [1896, 1896, 1948, 1948, 2225], [2227, 2227, 2279, 2279, 2398], [2400, 2400, 2421, 2421, 3330], [3332, 3332, 3356, 3356, 3478], [3480, 3480, 3541, 3541, 4091], [4093, 4093, 4123, 4123, 4465], [4467, 4467, 4506, 4506, 4546], [4548, 4548, 4605, 4605, 6674]]}
{"id": "slSXRV", "name": "Fire Gateway", "author": "scry", "description": "I wanted to make glowing strands of stuff, kinda did, learned how to get the effect I had in mind, also created an effect which I have no idea of its working(some of the color patterning that occurs)", "tags": ["3d", "fractal", "raymarch", "kifs"], "likes": 4, "viewed": 174, "date": "1628058339", "time_retrieved": "2024-06-20T20:48:15.346789", "image_code": "#define MAXD 100.\n#define SURF 0.01\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n//Taken from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl.\n\n//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec4 map(vec3 p) {\n    \n    //float d = \n    float pd = 0.1;\n    float psz = floor(p.z);\n    p.xy *= r2d(psz+psz*09.5);\n    vec3 o = p;\n    p -= 5.;\n    p = (fract(p*pd)-0.5)/pd;\n    p = abs(p)-1.0;\n    //*/\n    for (int i=0;i<4;i++) {\n        //\n        p.xy = vec2(length(p.xy),atan(p.x,p.y));\n        p.xy = abs(p.xy)+0.3;\n        p.xy *= r2d(0.3);\n        p.xy = vec2(p.x*sin(p.y),p.x*cos(p.y));\n        p = abs(p)-sin(o.z*0.06+iTime*0.01)*2.;\n        p.xy *= r2d(o.z*0.02);\n    }\n    //float d = length(p)+0.1;\n    \n    float an = 3.14*0.75;\n    float d = sdCappedTorus(p,vec2(sin(an),cos(an)),1.,0.)+0.0;\n    d = max(d,-(length(o.xy)-0.4));\n    return vec4(p.xy,o.z,d);\n}\n\nvec2 RM(vec3 ro, vec3 rd,float c) {\n    float dO = 0.;\n    float ii = 0.;\n    int steps = 60-int(c*20.);\n    for (int i=0;i<steps;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w;\n        dO += dS*0.2;\n        ii += 0.1;\n        if (dO > MAXD || dS < SURF) {break;}\n    }\n    return vec2(dO,ii);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 1.- 2.*uv;\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    //vec2 uv = -1. + 2. * inData.v_texcoord;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    uv.x *= ar;\n    vec3 col = vec3(0.);\n    //uv *= 0.1;\n    float c = length(uv);\n    //uv *= r2d(sin(c*8.+time)*0.01);\n    vec3 ro = vec3(0.,0.,-5.);\n    ro.z += iTime*0.6;\n    vec3 rd = normalize(vec3(uv,1.));\n    vec2 d = RM(ro,rd,c);\n    //col = d.xxx*0.006;\n    vec3 p=map(ro+rd*d.x).rgb;\n    //col = sin(d.xxx*0.8+time)*0.5+0.5;\n    //col = d.xxx*0.001;\n    //col += 1.-d.xxx*0.007;\n    //col.r -= d.y;\n    //col = sin(d.yyy);\n    //col = sin(p.zzz*0.02)*0.5+0.5;\n    float pzn = p.z-ro.z;\n    //d.x = clamp(d.x*0.05,0.,1.);\n    col = hsv2rgb(vec3(p.y*0.04+p.z*0.004+d.x*0.01-0.05,1.-d.y*0.03,sin(p.z*0.2-ro.z*0.12)*0.6+0.4));\n    //col = hsv2rgb(vec3(p.z*0.05,sin(p.x*0.002-c*4)*0.5+0.5,sin(d.x*0.1-ro.z*0+c)*0.5+0.5));\n    //vec3 bak = texture(prevFrame,inData.v_texcoord).rgb;\n    if (d.x > MAXD+(c+0.5)) {\n        col *= 0.;\n    }\n    //col = fract(col*1.5+time*0.04);\n    //col = sin(col*6.);\n    //bak = fract(bak+col*0.01);\n    //col = mix(col,bak,0.93);\n    //col = hsv2rgb(vec3(d.x*0.009,d.x*0.005,d.x*0.1));\n    //col = hsv2rgb(vec3(d.x*0.0025,0.6,d.y*4.-19.5));\n    fragColor = vec4(col,1.);\n}\n\n    \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/slSXRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[37, 37, 56, 56, 105], [107, 166, 188, 188, 519], [523, 582, 604, 604, 773], [845, 919, 972, 972, 1031], [1032, 1032, 1102, 1102, 1236], [1238, 1238, 1256, 1278, 1915], [1917, 1917, 1952, 1952, 2227], [2228, 2228, 2285, 2285, 3614]]}
{"id": "slSXWd", "name": "particle test 101", "author": "lasoy", "description": "particle", "tags": ["particle"], "likes": 3, "viewed": 150, "date": "1628859413", "time_retrieved": "2024-06-20T20:48:15.346789", "image_code": "#define NUM 20.0\n#define PI 3.1415926\nvec3 color(float t) {\n    // from IQ's color pattern\n    return .3 + .7 * cos(6.283 * (vec3(1., .5, .0) * (1. - t) + vec3(.7, .75, .3)));\n}\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv.y += .4;\n    vec3 col = vec3(0, 0, 0);\n    for(float i = 0.;i < NUM; i ++) {\n        float id = i;\n        float h0 = hash11(id);\n        float h1 = hash11(h0);\n        float h2 = hash11(h1);\n        float h3 = hash11(h2);\n        vec2 pos = uv;\n        pos.x += cos(iTime * 3. * h0 + h0 * PI * 2.) * .2 * (.5 + h0 * 2.) * (.2 + pow(pos.y, .8));\n        pos.y -= fract(iTime * .3 + h1) * .8 * (.5 + h1);\n        vec3 c =  color(h3);\n        col += 0.012 * h2 /length(pos) * c;\n    }\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/slSXWd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[38, 38, 59, 90, 177], [178, 178, 201, 201, 286], [288, 288, 345, 345, 966]]}
{"id": "slSXzV", "name": "Happy Chinese Valentine!", "author": "letian", "description": "Happy Chinese Valentine!", "tags": ["basedonotherscreation"], "likes": 7, "viewed": 167, "date": "1628074475", "time_retrieved": "2024-06-20T20:48:17.873707", "image_code": "#define SHADERTOY\n\n// -- Uniforms -----------------------------------------------------------------\n\n#ifndef SHADERTOY\nuniform vec3 iResolution;\nuniform vec3 iMouse;\nuniform float iTime;\nuniform sampler2D iChannel0;\n#endif\n\n// -- Constants ----------------------------------------------------------------\n\n// Camera constants\n\nconst float kFOV = 0.785398;                           // Camera field of view \n\n// RayMarching constants\n\nconst int kMaxSteps = 100;                              // Max number of raymarching steps\nconst float kMaxDistance = 55.0;                       // Max raymarching distance\nconst float kBias = 0.01;                              // Bias offset for normal estimation\nconst float kNoHit = -1.0;                             // No intersection distance.\n\n// Scene constants.\nconst vec3 kSkyColor = vec3(0.5, 0.12, 0.5);          // Night sky color.\nconst vec3 kSkyHorzColor = vec3(0.4, 0.2, 0.87);       // Night sky horizon color.\n\nconst vec3 kMoonDir = vec3(-0.18443, 0.3688, -0.9221); // Moon direction.\nconst vec3 kMoonColor = vec3(1.0, 1.0, 0.8);           // Moon color.\nconst vec3 kMoonSkyByColor = vec3(0.9, 0.6, 1);      // Moon glow color.\nconst float kMoonCosRange = 0.999;                     // Moon cosine range.\n\n// Material constants.\nconst float kMaterialNone = 0.0;\nconst float kMaterialHeart = 1.0;\nconst float kMaterialWater = 2.0;\n\n// Other constants\n\nconst vec3 kOnes = vec3(1.0, -1.0, 0.0);               // Helper vector with ones.\nconst float kPI = 3.14159265359;                       // PI\n\n// -- Global values ------------------------------------------------------------\n\nfloat gAnimTime;\n\nvec3  gHeartPos;\nfloat gHeartMorph;\nfloat gHeartColoring;\n\nfloat gWaveTime;\n\nfloat gMsgFadeInTime;\nfloat gFadeTime;\n\n\n// -- Structures ---------------------------------------------------------------\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct RayHit\n{\n    float time;\n    float material;\n};\n\nstruct DistanceSample\n{\n    float dist;\n    float stepRatio;\n    float material;\n};\n\n    \n// --- Math funcs --------------------------------------------------------------\n\n// Build quaternion from axis angle\nvec4 QuatFromAxisAngle(vec3 axis, float angle)\n{\n    float theta = 0.5 * angle;\n    float sine = sin(theta);\n    return vec4(sin(theta) * axis, cos(theta));\n}\n\n// Builds the conjugate quaternion\nvec4 QuatConjugate(vec4 q)\n{\n    return vec4(q.xyz, -q.w);\n}\n\n// Rotates a vector around the quaternion\nvec3 QuatTransformVec(vec3 v, vec4 q)\n{\n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n\n// -- Noise funcs --------------------------------------------------------------\n\n// Hash noise function from I. Quilez\nfloat Hash(float p)\n{\n    float h = p * 127.1;\n    return fract(sin(h)*43758.5453123);\n}\n\n// Hash noise function from I. Quilez\nfloat Hash(vec2 p)\n{\n    float h = dot(p, vec2(127.1,311.7));    \n    return fract(sin(h)*43758.5453123);\n}\n\n// Modified Hash noise function for 3D hashing.\nfloat Hash(vec3 p)\n{\n    float h = dot(p, vec3(127.1, 311.7, 511.9));    \n    return fract(sin(h)*43758.5453123);\n}\n\n// 2D Perlin Noise\nfloat PerlinNoise(vec2 p)\n{    \n    vec2 i = floor(p);\n    vec2 f = fract(p);  \n    vec2 u = smoothstep(0.0, 1.0, f);\n    \n    float f00 = mix(Hash(i + kOnes.zz), Hash(i + kOnes.xz), u.x);\n    float f01 = mix(Hash(i + kOnes.zx), Hash(i + kOnes.xx), u.x);\n    float f1 = mix(f00, f01, u.y);\n    \n    return 2.0 * f1 - 1.0;\n}\n\n// 3D Perlin Noise\nfloat PerlinNoise(vec3 p)\n{    \n    vec3 i = floor(p);\n    vec3 f = fract(p);  \n    vec3 u = smoothstep(0.0, 1.0, f);\n    \n    float f00 = mix(Hash(i + kOnes.zzz), Hash(i + kOnes.xzz), u.x);\n    float f01 = mix(Hash(i + kOnes.zxz), Hash(i + kOnes.xxz), u.x);\n    float f02 = mix(Hash(i + kOnes.zzx), Hash(i + kOnes.xzx), u.x);\n    float f03 = mix(Hash(i + kOnes.zxx), Hash(i + kOnes.xxx), u.x);\n    \n    float f10 = mix(f00, f01, u.y);\n    float f11 = mix(f02, f03, u.y);\n    \n    float f2 = mix(f10, f11, u.z);\n    \n    return 2.0 * f2 - 1.0;\n}\n\n// Fractional Brownian Motion from I. Quilez\n// http://www.iquilezles.org/www/articles/warp/warp.htm\n// In the end, it's a sum of Perlin Noise functions with increasing frequencies\n// and decreasing amplitudes. To enhance the noise, a rotation matrix is applied\n// at each step.\n\nconst mat2 FBM_M2 = mat2(0.84147, 0.54030, 0.54030, -0.84147);\nconst mat3 FBM_M3 = mat3(0.00, 0.90, 0.60, -0.90, 0.36, -0.48, -0.60, -0.48, 0.34 );\n\nfloat FBM(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000*PerlinNoise(p); p = FBM_M2 * p * 2.02;\n    f += 0.2500*PerlinNoise(p); p = FBM_M2 * p * 2.03;\n    f += 0.1250*PerlinNoise(p); p = FBM_M2 * p * 2.01;\n    //f += 0.0625*PerlinNoise(p);\n    //return f/(0.9375);\n    return f/(0.8750);\n}\n\nfloat FBM(vec3 p)\n{\n    float f = 0.0;\n    f += 0.5000*PerlinNoise(p); p = FBM_M3 * p * 2.02;\n    f += 0.2500*PerlinNoise(p); p = FBM_M3 * p * 2.33;\n    f += 0.1250*PerlinNoise(p); p = FBM_M3 * p * 2.01;\n    f += 0.0625*PerlinNoise(p); \n    return f/(0.9175);\n}\n\n// -- Camera funcs -------------------------------------------------------------\n\nRay ViewportToRay(vec2 uv, vec3 offs, vec4 rot)\n{\n    Ray ray;\n    ray.direction = QuatTransformVec(normalize(vec3(uv * tan(kFOV * 0.5), -1.0)), rot);\n    ray.origin = offs;\n    \n    return ray;\n}\n\nRay ReflectRay(Ray ray, float d, vec3 n)\n{\n    ray.origin += ray.direction * d;\n    ray.direction = reflect(ray.direction, n);\n    return ray;\n}\n\nDistanceSample NewDistanceSample(float d, float s, float m)\n{\n    DistanceSample h;\n    h.dist = d;\n    h.stepRatio = s;\n    h.material = m;\n    return h;\n}\n\nRayHit NewRayHit(float t, float m)\n{\n    RayHit h;\n    h.time = t;\n    h.material = m;\n    return h;\n}\n\n// -- Water funcs --------------------------------------------------------------\n\n// Computes the height of a wave at the specified point\nfloat WaveDirectional(vec2 p, float wavelength, float speed, vec2 direction, float amplitude)\n{\n    float freq = 2.0 * kPI / wavelength;\n    float phase = speed * freq;\n    float theta = dot(direction, p);\n\n    return amplitude * pow(sin(theta * freq + gAnimTime * phase), 3.0);\n}\n\nfloat WavePunctual(vec2 p, float wavelength, float speed, vec2 perturb, float amplitude, float waveTime)\n{\n    float freq = 2.0 * kPI / wavelength;\n    float phase = speed * freq;\n    float dist = -length(p - perturb);\n    amplitude /= 1.0 + (0.3 * -dist) + (0.15 * waveTime * waveTime);\n\n    return amplitude * pow(sin(max(0.0, dist * freq + waveTime * phase)), 3.0);\n}\n\n// -- SDF funcs ----------------------------------------------------------------\n\n// Signed Distance Field of a point to a heart located at the origin. It works by computing\n// the SDF of a sphere whose space has been distorted by a polar function\nDistanceSample SDFHeart(vec3 p)\n{\n    // Apply noise to position when it's a drop.\n    if (gHeartMorph < 1.0)\n        p += 0.16 * FBM(p + vec3(0, gAnimTime * 2.5, 0)) * (1.0 - gHeartMorph);\n    \n    // Apply domain distortion for heart.\n    float a0 = atan(p.x, p.y);\n    float a1 = atan(p.x, p.z);\n    float b0 = abs(a0 / kPI);\n    float b1 = abs(a1);\n    float l = length(p.xy);\n    \n    // Constants computed with Octave:\n    // x = [   0; 0.35;  0.53;   1; ];\n    // y = [ 0.6;  1.0;  0.9; 1.2; ];\n    // K = polyfit(x, y, 3);\n    const vec4 K = vec4(6.34975, -9.8705, 4.39112, 0.4);\n    vec4 B = vec4(b0 * b0 * b0, b0 * b0, b0, 1.0);\n    \n    float d0 = dot(K, B);\n    d0 = mix(1.0, d0, smoothstep(0.0, 0.7, l));\n    float d1 = 1.0 - 0.5*abs(cos(a1));\n    \n    p.xy /= mix(1.0, d0, gHeartMorph);\n    p.z  /= mix(1.0, d1, gHeartMorph);\n    \n    // Increase size whenever the mouse is close.\n\tfloat mouseOverSize = 1.0+0.7*smoothstep(0.2, 0.0, length((iMouse.xy / iResolution.xy) - 0.5));\n\t\n    // Compute sphere's SDF\n    return NewDistanceSample(length(p) - 0.8 - 0.5 * gHeartMorph * mouseOverSize, 0.5, kMaterialHeart);\n}\n\n// Signed Distance Field of a point to the water plane located at the origin.\n// It's simply the distance to a plane distorted by the wave field.\nDistanceSample SDFWater(vec3 p)\n{\n    const float overallSpeed = 0.7;\n    float height = 0.0;\n    height -= FBM(vec3(p.xz * 0.5, 0.75 * gAnimTime)) * 0.05;\n    height += WavePunctual(p.xz, 12.0, 1.5, vec2(0.0, -12.0), 2.0, gWaveTime);\n    \n    return NewDistanceSample(p.y - 1.5 * height, 1.0, kMaterialWater);\n}\n\n// -- SDF CGS funcs ------------------------------------------------------------\n\nDistanceSample OpUnion(DistanceSample d1, DistanceSample d2)\n{\n    if (d1.dist < d2.dist) return d1; return d2;\n}\n\nDistanceSample OpSubstract(DistanceSample d1, DistanceSample d2)\n{\n    d2.dist = -d2.dist;\n    if (d1.dist > d2.dist) return d1; return d2;\n}\n\nDistanceSample OpIntersect(DistanceSample d1, DistanceSample d2)\n{\n    if (d1.dist > d2.dist) return d1; return d2;\n}\n\nDistanceSample OpSmoothMin(DistanceSample d1, DistanceSample d2, float k)\n{\n    float h = clamp(0.5+0.5*(d2.dist - d1.dist)/k, 0.0, 1.0);\n    \n    DistanceSample d;\n    d.dist = mix(d2.dist, d1.dist, h) - k * h * (1.0-h);\n    d.stepRatio = min(d2.stepRatio, d1.stepRatio);\n    d.material = mix(d2.material, d1.material, h);\n    \n    return d;\n}\n\n// -- Transform funcs ----------------------------------------------------------\n\nvec3 Tx(vec3 p, vec3 tx)\n{\n    return (p - tx);\n}\n\nvec3 Tx(vec3 p, vec3 tx, vec4 q)\n{\n    p -= tx;\n    return QuatTransformVec(p, QuatConjugate(q));\n}\n\n// --- Scene funcs -------------------------------------------------------------\n\nDistanceSample Scene(vec3 position)\n{\n    // Evaluate scene distances.\n    DistanceSample d0 = SDFHeart(Tx(position, gHeartPos, QuatFromAxisAngle(vec3(0.,1.,0.), gAnimTime*1.7)));\n    DistanceSample d1 = SDFWater(Tx(position, vec3(0,-2,0)));\n    return OpSmoothMin(d0, d1, 0.8);\n}\n\nvec3 SceneNormal(vec3 position)\n{\n    vec2 offset = vec2(kBias, 0.0);\n    float d = Scene(position).dist;\n    \n    return normalize(vec3\n    (\n        Scene(position + offset.xyy).dist - d,\n        Scene(position + offset.yxy).dist - d,\n        Scene(position + offset.yyx).dist - d\n    ));\n}\n\nvec3 SkyColor(vec3 n)\n{\n    // Compute the sky color from hemisphere. \n    float h = 1.0 - pow(abs(n.y), 0.4);\n    vec3 color = mix(kSkyColor, kSkyHorzColor, h);\n    \n    // Add stars.\n    float s = pow(max(0.0, PerlinNoise(n * 4e2)), 18.0);\n    color.rgb += vec3(s, s, s);\n    \n    // Add moon and moon light.\n    float dotNM = dot(n, kMoonDir);\n    color = mix(color, kMoonColor, smoothstep(0.0, 0.0001, dotNM - kMoonCosRange));\n    color += kMoonSkyByColor * pow(max(0.0, dotNM), 100.0);\n    \n    return color;\n}\n\nRayHit Raymarch(Ray ray)\n{\n    float t = 0.0;\n    DistanceSample d;\n    \n    for (int i = 0; (i < kMaxSteps); i++)\n    {\n        d = Scene(ray.origin + ray.direction * t);\n        t += d.dist * d.stepRatio;\n        \n        if ((d.dist < 0.0) || (t >= kMaxDistance))\n            break;\n    }\n    \n    if (t < kMaxDistance)\n        return NewRayHit(t, d.material);\n    \n    return NewRayHit(kNoHit, kMaterialNone);\n}\n\nfloat SparkCircle(vec2 uv, vec2 center, float rad)\n{\n    float d = length(uv - center);\n    return smoothstep(rad, 0.0, d);\n}\n\nfloat SparkRect(vec2 uv, vec2 center, vec2 size, float ang)\n{\n    vec2 cs = vec2(cos(ang), sin(ang));\n    uv -= center;\n    uv = vec2(dot(uv, cs), dot(uv.yx * vec2(-1.0, 1.0), cs));\n    \n    vec2 x = smoothstep(size*0.5, vec2(0.0, 0.0), abs(uv));\n    return pow(x.x * x.y, 3.0);\n}\n\nfloat Spark(vec2 uv, vec2 center, float ang)\n{\n    float f = 0.0;\n    f += SparkRect(uv, center, vec2(0.4, 0.008), ang);\n    f += SparkRect(uv, center, vec2(0.4, 0.008), ang+radians(60.0));\n    f += SparkRect(uv, center, vec2(0.4, 0.008), ang+radians(120.0));\n    f += SparkCircle(uv, center, 0.01);\n    return f;\n} \n\nvec3 Colorize(Ray ray, RayHit hit)\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);   \n    color.rgb = SkyColor(ray.direction);\n    \n    // If there was an intersection, compute normal and the hit surface color.\n    if (hit.material != kMaterialNone)\n    {\n        vec3 p = ray.direction * hit.time + ray.origin;\n        vec3 n = SceneNormal(p);\n        \n        color.rgb = mix(vec3(0.0, 0.0, 0.0), SkyColor(reflect(ray.direction, n)), 1.0 - pow(length(n.xz), 16.0));\n        \n        if (hit.material == kMaterialHeart)\n        {\n            color.rgb += gHeartColoring * vec3(0.4, 0, 0);\n        }\n        \n        //color.rgb = SceneNormal(p);//0.3 + 0.7*pow(max(0., Normal(p).z), 30.0);\n    }\n    \n    return color;\n}\n                        \n// --- Main --------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Setup globals.\n\tgAnimTime      = mod(1.5 * iTime, 20.0);\n\tgHeartPos      = vec3(0.0, -3.5 + 5.0 * smoothstep(1.0, 3.0, gAnimTime), -12.0);\n\tgHeartMorph    = smoothstep(2.5, 4.0, gAnimTime);\n\tgHeartColoring = smoothstep(4.0, 6.0, gAnimTime);\n\tgWaveTime      = max(0.0, gAnimTime - 0.8);\n\tgMsgFadeInTime = smoothstep(7.0, 9.0, gAnimTime);\n\tgFadeTime      = smoothstep(0.0, 1.0, gAnimTime) * smoothstep(20.0, 19.0, gAnimTime);\n\n    // Get uvs in [-1 1] range and correct them with the aspect ratio.\n    vec2 uv = 2.0*(fragCoord.xy / iResolution.xy)-1.0;\n    uv *= vec2(iResolution.x / iResolution.y, 1.0);\n    \n    // Generate first ray and raymarch along scene.\n    Ray ray = ViewportToRay(uv, kOnes.zzz, QuatFromAxisAngle(vec3(1.0, 0.0, 0.0), radians(6.0)));\n    RayHit hit = Raymarch(ray);    \n\n    // Initialize background color.\n    vec3 color = Colorize(ray, hit);\n    \n    // Show sparks around the heart\n    for(int i = 0; i < 8; i++)\n    {\n        float t = max(0.0, (gAnimTime + (float(i)) * 0.2) - 6.0);\n        float s = floor(t / 0.4);\n        float sTime = fract(t / 0.4);\n        vec2 sPos = vec2(Hash(s * 61.0), Hash(s * 17.0));\n        sPos = 2.0 * sPos - 1.0;\n        sPos *= 0.15;\n        color.rgb += sin(sTime * kPI) * Spark(uv, sPos, 0.0) * vec3(1.0, 0.4, 0.4);\n    }\n    \n    // Show the valentine's message\n    /*\n    if (gMsgFadeInTime > 0.0)\n    {\n        vec2 texAspect = vec2(1.0, -4.0);\n        vec2 texUv = uv * texAspect;\n        texUv = clamp(texUv * 0.5 + 0.5, 0.0, 1.0);\n        \n        vec2 texMsg = texture(iChannel0, texUv).rg;\n        color.rgb += gMsgFadeInTime * (texMsg.y * vec3(0.4, 0.0, 0.0) + texMsg.xxx);        \n    }\n    */\n    \n    // Apply vignetting effect.\n    color.rgb -= color.rgb*0.2*dot(uv, uv);\n\n    fragColor = vec4(gFadeTime * color, 1.0);\n}\n\n#ifndef SHADERTOY\nvoid main()\n{\n    vec4 fragColor;\n    mainImage(fragColor, gl_FragCoord);\n    gl_FragColor = fragColor;\n}\n#endif", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/slSXzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[2130, 2166, 2214, 2214, 2324], [2326, 2361, 2389, 2389, 2421], [2423, 2465, 2504, 2504, 2584], [2668, 2706, 2727, 2727, 2794], [2796, 2834, 2854, 2854, 2941], [2943, 2991, 3011, 3011, 3106], [3108, 3127, 3154, 3154, 3450], [3452, 3471, 3498, 3498, 4016], [4018, 4447, 4466, 4466, 4734], [4736, 4736, 4755, 4755, 4997], [4999, 5081, 5130, 5130, 5277], [5279, 5279, 5321, 5321, 5423], [5425, 5425, 5486, 5486, 5581], [5583, 5583, 5619, 5619, 5685], [5769, 5825, 5920, 5920, 6105], [6107, 6107, 6213, 6213, 6477], [6561, 6727, 6760, 6809, 7854], [7856, 8002, 8035, 8035, 8314], [8316, 8398, 8460, 8460, 8511], [8513, 8513, 8579, 8579, 8654], [8656, 8656, 8722, 8722, 8773], [8775, 8775, 8850, 8850, 9119], [9121, 9203, 9229, 9229, 9252], [9254, 9254, 9288, 9288, 9353], [9355, 9437, 9474, 9507, 9717], [9719, 9719, 9752, 9752, 10011], [10013, 10013, 10036, 10083, 10528], [10530, 10530, 10556, 10556, 10945], [10947, 10947, 10999, 10999, 11072], [11074, 11074, 11135, 11135, 11354], [11356, 11356, 11402, 11402, 11671], [11674, 11674, 11710, 11710, 12387], [12413, 12495, 12550, 12569, 14353]]}
{"id": "ss33D7", "name": "3D Bézier Curve", "author": "wylm", "description": "3D Bézier Curve, evaluating surface position.", "tags": ["beziercurve"], "likes": 17, "viewed": 195, "date": "1629961720", "time_retrieved": "2024-06-20T20:48:18.710335", "image_code": "#define E 2.718281828459\n\n#define SAMPLE_SIZE 20\n\nfloat t(){\n    return pow(E,-1. * pow(2. * cos(iTime),2.));\n}\n\nfloat line(vec2 uv, vec3 p1, vec3 p2){\n    float k = (p1.y-p2.y)/(p1.x-p2.x);\n    float b = p1.y - k * p1.x;\n    return k*uv.x + b - uv.y;\n}\n\nvec3 line_pos(float t, vec3 b0, vec3 b1, vec3 b2){\n    return (1.-t)*(1.-t)*b0 + 2.*t*(1.-t)*b1 + t*t*b2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.8);\n    \n    \n    vec3 b0 = vec3(0.25 + 0.1 * sin(iTime),0.25 + 0.1 * sin(iTime),0.5);\n    vec3 b1 = vec3(0.8,0.5+ 0.1 * t(),0.7);\n    vec3 b2 = vec3(1.15 + 0.1 * sin(iTime),0.15 + 0.1 * sin(iTime),0.9);\n    \n    vec3 b3 = vec3(0.5,0.75,-0.1);\n    vec3 b4 = vec3(1.05,0.85 + 0.1 * t(),0.);\n    vec3 b5 = vec3(1.4,0.6,0.1);\n    \n    vec3 b6 = vec3(0.7,0.6 + 0.1 * sin(iTime),-0.9);\n    vec3 b7 = vec3(1.15,0.65+ 0.1 * t(),-0.7);\n    vec3 b8 = vec3(1.5 + 0.1 * cos(iTime),0.4 + 0.1 * cos(iTime),-0.5);\n    \n    //draw line\n    float d = abs(line(uv,b0,b1));\n    if(d < 0.005 && uv.x>b0.x && uv.x<b1.x){\n        col *= mix(col, vec3(0.1), smoothstep(-fwidth(d), fwidth(d), d));\n    }\n    \n    d = abs(line(uv,b1,b2));\n    if(d < 0.005 && uv.x>b1.x && uv.x<b2.x){\n        col *= mix(col, vec3(0.1), smoothstep(-fwidth(d), fwidth(d), d));\n    }\n    \n    d = abs(line(uv,b3,b4));\n    if(d < 0.005 && uv.x>b3.x && uv.x<b4.x){\n        col *= mix(col, vec3(0.1), smoothstep(-fwidth(d), fwidth(d), d));\n    }\n    \n    d = abs(line(uv,b4,b5));\n    if(d < 0.005 && uv.x>b4.x && uv.x<b5.x){\n        col *= mix(col, vec3(0.1), smoothstep(-fwidth(d), fwidth(d), d));\n    }\n    \n    d = abs(line(uv,b6,b7));\n    if(d < 0.005 && uv.x>b6.x && uv.x<b7.x){\n        col *= mix(col, vec3(0.1), smoothstep(-fwidth(d), fwidth(d), d));\n    }\n    \n    d = abs(line(uv,b7,b8));\n    if(d < 0.005 && uv.x>b7.x && uv.x<b8.x){\n        col *= mix(col, vec3(0.1), smoothstep(-fwidth(d), fwidth(d), d));\n    }\n    \n    d = abs(line(uv,b0,b3));\n    if(d < 0.005 && uv.x>b0.x && uv.x<b3.x){\n        col *= mix(col, vec3(0.1), smoothstep(-fwidth(d), fwidth(d), d));\n    }\n    \n    d = abs(line(uv,b3,b6));\n    if(d < 0.005 && uv.x>b3.x && uv.x<b6.x){\n        col *= mix(col, vec3(0.1), smoothstep(-fwidth(d), fwidth(d), d));\n    }\n    \n    d = abs(line(uv,b1,b4));\n    if(d < 0.005 && uv.x>b1.x && uv.x<b4.x){\n        col *= mix(col, vec3(0.1), smoothstep(-fwidth(d), fwidth(d), d));\n    }\n    \n    d = abs(line(uv,b4,b7));\n    if(d < 0.005 && uv.x>b4.x && uv.x<b7.x){\n        col *= mix(col, vec3(0.1), smoothstep(-fwidth(d), fwidth(d), d));\n    }\n    \n    d = abs(line(uv,b2,b5));\n    if(d < 0.005 && uv.x>b2.x && uv.x<b5.x){\n        col *= mix(col, vec3(0.1), smoothstep(-fwidth(d), fwidth(d), d));\n    }\n    \n    d = abs(line(uv,b5,b8));\n    if(d < 0.005 && uv.x>b5.x && uv.x<b8.x){\n        col *= mix(col, vec3(0.1), smoothstep(-fwidth(d), fwidth(d), d));\n    }\n    \n    // draw point\n    float ps = 0.02;\n    float r = length(uv-b0.xy);\n    if(r<ps){\n        col *= mix(col, vec3(0.1,0.1,0.1), smoothstep(-fwidth(r), fwidth(r), r));\n    }\n    \n    r = length(uv-b1.xy);\n    if(r<ps){\n        col *= mix(col, vec3(0.1,0.1,0.1), smoothstep(-fwidth(r), fwidth(r), r));\n    }\n    \n    r = length(uv-b2.xy);\n    if(r<ps){\n        col *= mix(col, vec3(0.1,0.1,0.1), smoothstep(-fwidth(r), fwidth(r), r));\n    }\n    \n    r = length(uv-b3.xy);\n    if(r<ps){\n        col *= mix(col, vec3(0.1,0.1,0.1), smoothstep(-fwidth(r), fwidth(r), r));\n    }\n    \n    r = length(uv-b4.xy);\n    if(r<ps){\n        col *= mix(col, vec3(0.1,0.1,0.1), smoothstep(-fwidth(r), fwidth(r), r));\n    }\n    \n    r = length(uv-b5.xy);\n    if(r<ps){\n        col *= mix(col, vec3(0.1,0.1,0.1), smoothstep(-fwidth(r), fwidth(r), r));\n    }\n    \n    r = length(uv-b6.xy);\n    if(r<ps){\n        col *= mix(col, vec3(0.1,0.1,0.1), smoothstep(-fwidth(r), fwidth(r), r));\n    }\n    \n    r = length(uv-b7.xy);\n    if(r<ps){\n        col *= mix(col, vec3(0.1,0.1,0.1), smoothstep(-fwidth(r), fwidth(r), r));\n    }\n    \n    r = length(uv-b8.xy);\n    if(r<ps){\n        col *= mix(col, vec3(0.1,0.1,0.1), smoothstep(-fwidth(r), fwidth(r), r));\n    }\n    \n    // traverse y axis\n    float pm = 1./float(SAMPLE_SIZE);\n    for(int i = 0; i<=SAMPLE_SIZE; i+=1){\n        vec3 c0 = line_pos(pm*float(i), b0, b3, b6);\n        vec3 c1 = line_pos(pm*float(i), b1, b4, b7);\n        vec3 c2 = line_pos(pm*float(i), b2, b5, b8);\n        \n        // traverse x axis\n        for(int j = 0; j<=SAMPLE_SIZE; j+=1){\n            vec3 p = line_pos(pm*float(j), c0, c1, c2);\n            r = length(uv-p.xy);\n            if(r< 0.2 * ps){\n                col *= mix(col, vec3(0.1,0.1,0.1), smoothstep(-fwidth(r), fwidth(r), r));\n            }\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ss33D7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[50, 50, 60, 60, 111], [113, 113, 151, 151, 253], [255, 255, 305, 305, 362], [364, 364, 421, 471, 4931]]}
{"id": "ss33Rf", "name": "Casino Carpet", "author": "104", "description": "watch & stare", "tags": ["quickndirty"], "likes": 6, "viewed": 160, "date": "1630341809", "time_retrieved": "2024-06-20T20:48:18.988953", "image_code": "const float Complexity = 10.;\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nmat2 rot2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n\nvoid mainImage(out vec4 o, vec2 C)\n{\n    vec2 uv = C/iResolution.x;\n    vec2 N = C/iResolution.xy;\n    float ND = min(N.x, min(N.y, min(1.-N.x, 1.-N.y))); // dist to edge of screen.\n    ND = 1.-pow(1.-ND,9.);\n    \n    uv += 2.;\n    o = vec4(0);\n\n    for (float i = 1.0; i <= Complexity;++i) {\n        vec2 cell = floor(uv);\n        vec2 p = fract(uv);\n        float Z = length(p-.5);\n        vec4 h = hash42(cell);\n        float sdsq = min(p.x, min(p.y, min(1.-p.x, 1.-p.y)));\n        o = mix(o,h/i,sdsq*sdsq*sdsq);\n        // rotating uv is pretty much the entire effect, though it destroys\n        // continuity between layers. voronoi would be a better basis tbh\n        uv = cell + (p * rot2D(Z+iTime *.1  * (i-1.) * (h.z-.5)));\n        uv *= 2.;\n        //uv *= 1.+ND; // cool variation imo\n    }\n    \n    o = smoothstep(0.,.07,o);\n    o = clamp(o,0.,1.);\n    N -= .5;\n    o *= 1.-dot(N,N*2.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ss33Rf.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[31, 31, 52, 52, 200], [202, 202, 222, 222, 274], [277, 277, 313, 313, 1177]]}
{"id": "ss33zn", "name": "Chain reaction", "author": "Flopine", "description": "One of the end result I came up with for my 15 minutes performance at SIGGRAPH Real Time Live Event!", "tags": ["raymarching", "palette", "animation", "isometric", "mograph"], "likes": 5, "viewed": 98, "date": "1628975091", "time_retrieved": "2024-06-20T20:48:19.546584", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings and FabriceNeyret for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n#define BPM 105./60.\n#define time iTime\n#define PI acos(-1.)\n#define TAU (2.*PI)\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define mo(p,d) p=abs(p)-d;if(p.y>p.x)p=p.yx\n#define rep(p,r) (p=mod(p,r)-r*0.5)\n#define crep(p,c,l) p=p-c*clamp(round(p/c),-l,l)\n#define pal(t,c,d) (vec3(0.9)+vec3(0.5)*cos(TAU*(c*t+d)))\n\n#define frt(sp,off) fract((time+off)*sp)\n#define flt(sp,off) floor((time+off)*sp)\n#define swi(sp,off) floor(sin(frt(sp,off)*TAU)+1.)\n\nfloat triprism (vec3 p, vec2 h)\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat cid;\nfloat column (vec3 p, float o)\n{\n    float per=1.1;\n    cid = floor(p.z/per);\n    float off = cid*o,\n    anim = PI/3.*(flt(BPM,off)+pow(frt(BPM,off),3.));\n   \n    rep(p.z,per);\n    mo(p.xy,vec2(.9));\n    p.y -= 2.;\n    p.xy*=rot(anim);\n  \n    return triprism(p,vec2(3.,per*.15));\n}\n\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(atan(1./sqrt(2.)));\n    if (swi(BPM/4.,0.)<0.5) p.xz*=rot(PI/4.);\n    \n    float id = round(p.x/9.);\n    crep(p.x,9.,4.);\n    float d = column(p,abs(id)-1.*0.2);\n    \n    return d;\n}\n\nvec3 gn (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n  vec2 a = vec2(abs(uv.x*0.5),0.25);\n  vec3 ro = vec3(uv*17.,-100.), rd=vec3(0.,0.,1.),p=ro,\n    col=vec3(0.),  \n    l=normalize(vec3(1.,2.,-3.));\n\n    bool hit=false;\n    for (float i=0.; i<64.;i++)\n    {\n        float d = SDF(p);\n        if (d<0.0001)\n        {hit = true; break;}\n        p += d*rd*0.5;\n    }    \n    if (hit)\n    {\n        vec3 n = gn(p);\n        float li = dot(n,l)*.5+.5;\n        col = pal(cid,vec3(0.1),vec3(0.1,0.8,0.3))*li;\n    }\n\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ss33zn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[208, 816, 849, 849, 932], [945, 945, 977, 977, 1226], [1228, 1228, 1248, 1248, 1447], [1449, 1449, 1467, 1467, 1580], [1582, 1582, 1638, 1638, 2193]]}
{"id": "ss3GRN", "name": "truchet district", "author": "sukupaper", "description": "The result isn't quite good as what I had in mind, but I'm pretty happy with the result ~", "tags": ["raymarching", "truchet"], "likes": 14, "viewed": 107, "date": "1629227542", "time_retrieved": "2024-06-20T20:48:20.473993", "image_code": "// Author: paperu\n// Title: truchet district\n\nfloat t;\n#define T 6.283185307\n\nvec3 SpectrumPoly(in float x) {\n    // https://www.shadertoy.com/view/wlSBzD\n    return (vec3( 1.220023e0,-1.933277e0, 1.623776e0)+(vec3(-2.965000e1, 6.806567e1,-3.606269e1)+(vec3( 5.451365e2,-7.921759e2, 6.966892e2)+(vec3(-4.121053e3, 4.432167e3,-4.463157e3)+(vec3( 1.501655e4,-1.264621e4, 1.375260e4)+(vec3(-2.904744e4, 1.969591e4,-2.330431e4)+(vec3( 3.068214e4,-1.698411e4, 2.229810e4)+(vec3(-1.675434e4, 7.594470e3,-1.131826e4)+ vec3( 3.707437e3,-1.366175e3, 2.372779e3)*x)*x)*x)*x)*x)*x)*x)*x)*x;\n}\nvec3 hsv2rgb(in vec3 c) { vec3 rgb = clamp(abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0,0.0,1.0); return c.z*mix(vec3(1.0),rgb,c.y); }\nfloat rand(in vec2 st) { return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.585); }\nmat2 rot(in float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nvec4 mod289(vec4 g){return g-floor(g*(1./289.))*289.;}vec4 permute(vec4 g){return mod289((g*34.+1.)*g);}vec4 taylorInvSqrt(vec4 g){return 1.79284-.853735*g;}vec2 fade(vec2 g){return g*g*g*(g*(g*6.-15.)+10.);}float cnoise(vec2 g){vec4 v=floor(g.rgrg)+vec4(0.,0.,1.,1.),d=fract(g.rgrg)-vec4(0.,0.,1.,1.);v=mod289(v);vec4 r=v.rbrb,a=v.ggaa,p=d.rbrb,e=d.ggaa,c=permute(permute(r)+a),f=fract(c*(1./41.))*2.-1.,t=abs(f)-.5,b=floor(f+.5);f=f-b;vec2 m=vec2(f.r,t.r),o=vec2(f.g,t.g),l=vec2(f.b,t.b),u=vec2(f.a,t.a);vec4 n=taylorInvSqrt(vec4(dot(m,m),dot(l,l),dot(o,o),dot(u,u)));m*=n.r;l*=n.g;o*=n.b;u*=n.a;float i=dot(m,vec2(p.r,e.r)),x=dot(o,vec2(p.g,e.g)),s=dot(l,vec2(p.b,e.b)),S=dot(u,vec2(p.a,e.a));vec2 I=fade(d.rg),y=mix(vec2(i,s),vec2(x,S),I.r);float q=mix(y.r,y.g,I.g);return 2.3*q;}\n\nfloat id_c_F;\nvec4 truchetMap(in vec2 st, in float div, in float div_a, in float div_b) {\n    vec2 P = floor(st*div);\n    vec2 p = fract(st*div) - .5;\n    \n    float mov = t*.25;\n    \n    if(floor(rand(P* + vec2(.123,.74))*10.) > 6.) {\n        float dir = sign(p.x*p.y);\n        p = abs(p);\n        vec2 v = vec2(min(p.x, p.y),max(p.x, p.y));\n        mov *= step(0.,-(length(v.x) - .04))*dir*.5;\n        id_c_F = floor((v.y - .1 + mov)/(2./div_b))/8.;\n        return vec4(v, vec2(mod(v.y - .1 + mov, 2./div_b) - 1./div_b,v.x - .1));\n    }\n    \n    p = mix(p, vec2(p.x,-p.y), floor(rand(P)*2.));\n    \n    float or = sign(float(p.x > -p.y) - .5);\n    p -= .5*or;\n    \n    float k = length(p) - .5; mov *= step(0.,-(abs(k) - .05))*sign(k)*or;\n    \n    vec2 pp = p*rot(mov);\n    div_a *= 2.;\n    float a = floor(((atan(pp.x, pp.y))/T + .5)*div_a);\n    id_c_F = a/8.;\n    a = (a/div_a)*T;\n    pp *= rot(-a - T/(div_a*2.));\n    pp.y = abs(pp.y + .5) - .1;\n    \n    p = vec2(abs(length(p) - .5), atan(p.x,p.y)/2.);\n    \n    return vec4(p, pp);\n}\n\nfloat cyl(in vec3 p, in float r, in float h) { return max(length(p.xy) - r, abs(p.z) - h); }\nfloat box(in vec3 p, in vec3 s) { p = abs(p) - s; return max(p.x,max(p.y,p.z)); }\nfloat box(in vec3 p, in float s) { p = abs(p) - s; return max(p.x,max(p.y,p.z)); }\nfloat box(in vec2 p, in vec2 s) { p = abs(p) - s; return max(p.x,p.y); }\nfloat invbox(in vec2 p, in vec2 s) { p = abs(p) - s; return min(p.x,p.y); }\n\nint id_h;\nfloat house(in vec3 p, in float s) {\n    p /= s;\n    p.xy = vec2(abs(p.x), p.y - .375);\n    float roof = dot(vec2(p.x, p.y - .5),normalize(vec2(1.,1.5)));\n    float windows = -max(max(box(mod(p.yz + vec2(.3,.225), .45) - .225,vec2(.12,.1)), p.y - .2),-p.x + .47);\n    float d = max(min(max(box(p, vec3(.5,.75,.7)), roof), box(p - vec3(0.,.5,.5), .1)),windows);\n    id_h = d == roof ? 1 : d == windows ? 2 : 0;\n    return d*s;\n}\nint id_c;\nfloat car(in vec3 p, in float s) {\n    p /= s;\n    p.y -= .6;\n    float wheels = cyl(vec3(abs(p.x) - .7,p.y + .5, abs(p.z) - .42), .2,.1);\n    float d = max(box(p, vec3(1.,.5,.5)), -box(vec3(abs(p.x - .1),p.yz) - vec3(1.1,.49,0.), vec3(.5,.5,1.)));\n    d = min(max(d, -max(invbox(p.xz, vec2(.4,.4)), abs(p.y - .24) - .2)), wheels);\n    id_c = d == wheels ? 1 : 0;\n    return d*s;\n}\nint id_p;\nfloat plane(in vec3 p, in float s) {\n    p /= s;\n    float k = smoothstep(-.6,1.,p.z);\n    p.y -= k*.1;\n    float d = min(cyl(p, .15 - k*.05,1.), box(vec3(p.x, abs(p.y - .06) - .2, p.z + .5), vec3(1.1,.025,.2)));\n    float k2 = cos(p.z*4. - t*30.);\n    float r = box(p - vec3(k2*.2,k2*.02,3.5), vec3(.01, .3, 2.))/2.;\n    d = min(d, r);\n    d = min(min(d, box(p - vec3(0.,.2,.9),vec3(.025,.25,.125))), box(p.yzx - vec3(0.,.9,0.),vec3(.025,.125,.5)));\n    float wheel = cyl(vec3(abs(p.x), p.yz).zyx + vec3(.5,.4,-.2), .1,.01);\n    d = min(d, wheel);\n    d = min(d, box(p + vec3(0.,.25,.5), vec3(.05,.15,.05)));\n    p.xz = abs(p.xz + vec2(0.,.5)) - vec2(1.05,.15);\n    p.y -= .04;\n    d = min(d, box(p, vec3(.01,.2,.01)));\n    id_p = d == r ? 1 : d == wheel ? 2 : 0;\n    return d*s;\n}\n\nint id;\nvec2 tp_xy;\nfloat df(in vec3 p) {\n    \n    float sz = .55;\n    \n    vec3 pl_pos = p;\n    pl_pos.xz *= rot(t);\n    \n    p.x += t*.5;\n    \n    p.y += cnoise(p.xz*sz)/sz*.2;\n    vec4 tp = truchetMap(p.xz*rot(T/6.), sz, 8., 10.);\n    tp_xy = tp.xy;\n    vec3 pp_b = vec3(tp.z, p.y*sz, tp.w);\n    \n    float h = house(pp_b.zyx, .05)/sz*.4;\n    float c = car(pp_b + vec3(0.,0.,0.08), .01)/sz;\n    float pl = plane(pl_pos + vec3(.75,-.4,0.), .05);\n    float f = p.y;\n    \n    float d = min(min(min(h,f),c),pl);\n    \n    id = d == f ? 1 : d == h ? 2 : d == c ? 3 : 4;\n    \n    return d;\n}\n\n#define LIM .0005\nvec3 normal(in vec3 p) { float d = df(p); vec2 u = vec2(0.,LIM); return normalize(vec3(df(p + u.yxx),df(p + u.xyx),df(p + u.xxy)) - d); }\n\n#define MAX_D 5.\n#define MIN_D 0.\n#define MAX_IT 180\nstruct rmr { vec3 p; int i; float d; };\nrmr rm(in vec3 c, in vec3 r) {\n    rmr res;\n    res.p = c + r*MIN_D, res.i = MAX_IT;\n    for(int i = 0; i < MAX_IT; i++) {\n        res.d = df(res.p);\n        if(res.d < LIM || distance(c,res.p) > MAX_D) { res.i = i; return res; }\n        res.p += res.d*r;\n    }\n    return res;\n}\n\nvec3 plane2sphere(in vec2 p) {\n    float t = -4./(dot(p,p) + 4.);\n    return vec3(-p*t, 1. + 2.*t);\n}\n\nfloat anim1(float x, float sm){\n  float xmd = mod(x,2.) - .5;\n  return smoothstep(-sm,sm,xmd) - smoothstep(-sm,sm,xmd - 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = (fragCoord.xy - iResolution.xy*.5)/iResolution.y;\n    t = iTime + 35.;\n    \n    vec3 c = vec3(0.,.4,0.);\n    float k = anim1(t/16. + floor(st.x*20.)/100., .02);\n    vec3 r = normalize(plane2sphere(st*4.*(1. + .75*k)));\n    r.xz *= rot(T/4.); r.xy *= rot(T/4.*(k*2. - 1.));\n\n    rmr res = rm(c,r);\n    \n    vec3 color = SpectrumPoly(clamp((-r.y+1.6)*.2,0.1,.32))*1.75;\n    if(res.d < LIM) {\n        vec3 n = normal(res.p);\n        vec3 color_m;\n        \n        if(id == 1) {\n            float d0 = step(tp_xy.x,0.05);\n            float d1 = step(tp_xy.x,0.04);\n            float d2 = step(max(tp_xy.x, mod(tp_xy.y,.02) - .01),0.0025);\n            color_m = mix(vec3(0.357,1.000,0.200),mix(vec3(.4),mix(vec3(.2),vec3(1.),d2),d1), d0);\n        } else if(id == 2)\n            color_m = id_h == 0 ? vec3(1.) : id_h == 1 ? vec3(0.900,0.124,0.099) : vec3(0.307,0.480,1.000);\n        else if(id == 3)\n            color_m = id_c == 0 ? hsv2rgb(vec3(rand(vec2(.12,id_c_F)),.8,1.)) : vec3(.1);\n        else\n            color_m = id_p == 1 ? vec3(.8) : id_p == 2 ? vec3(.1) : vec3(1.000,0.826,0.115);\n        \n        float k = distance(c, res.p);\n        color = mix(color_m, color, clamp(k*k*.05,0.,1.));\n        k = 1. - dot(n, -r);\n        color += vec3(k*k*k*.52);\n    }\n    \n    k = length(st);\n\n    fragColor = vec4(color - k*k,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ss3GRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 78, 109, 154, 581], [582, 582, 607, 607, 725], [726, 726, 750, 750, 814], [815, 815, 837, 837, 882], [883, 883, 903, 903, 937], [937, 937, 958, 958, 987], [987, 987, 1014, 1014, 1040], [1040, 1040, 1058, 1058, 1091], [1091, 1091, 1112, 1112, 1667], [1683, 1683, 1758, 1758, 2707], [2709, 2709, 2755, 2755, 2801], [2802, 2802, 2835, 2835, 2883], [2884, 2884, 2918, 2918, 2966], [2967, 2967, 3000, 3000, 3039], [3040, 3040, 3076, 3076, 3115], [3127, 3127, 3163, 3163, 3554], [3565, 3565, 3599, 3599, 3946], [3957, 3957, 3993, 3993, 4739], [4761, 4761, 4782, 4782, 5328], [5348, 5348, 5372, 5372, 5485], [5580, 5580, 5610, 5610, 5859], [5861, 5861, 5891, 5891, 5962], [5964, 5964, 5995, 5995, 6090], [6092, 6092, 6147, 6147, 7493]]}
{"id": "ssc3R4", "name": "psych tunnel", "author": "hikiko", "description": "distorting a voronoi tunnel", "tags": ["voronoi", "tunnel", "baddistortion"], "likes": 1, "viewed": 54, "date": "1629221491", "time_retrieved": "2024-06-20T20:48:20.480005", "image_code": "#define M_PI 3.141592653589793\n\nconst vec2 res = vec2(800.0, 600.0);\nconst float aspect = 1.3333333;\nconst vec2 center = vec2(0.5 * aspect, 0.5);\n\nvec4 voronoi(in vec2 uv);\n\nvec3 hsv2rgb(in vec3 c)\n{\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 gcolorhsv(in vec3 c)\n{\n\treturn c / vec3(360.0, 100.0, 100.0);\n}\n\nvec3 texture_(in vec2 uv)\n{\n\tvec4 v = voronoi(uv);\n\tvec3 chsv = gcolorhsv(vec3(201.0, 66.0, 93.0));\n\tchsv.x = chsv.x + v.x * 0.3;\n\tchsv = chsv * smoothstep(-1.0, 1.0, pow(v.w, 3.0) * 0.5 + 0.5);\n\n\treturn hsv2rgb(chsv);\n}\n\n// modification of this noise function by Inigo Quilez:\n// https://www.shadertoy.com/view/XsXfRH\n\nfloat hash(in vec2 p)\n{\n    p  = 50.0 * fract(p * 0.3183099 + vec2(0.71, 0.113));\n    return -1.0 + 2.0 * fract(p.x * p.y * (p.x + p.y));\n}\n\nfloat noised(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    \n#if 0\n    // quintic interpolation\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec2 du = 30.0*w*w*(w*(w-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = w*w*(3.0-2.0*w);\n    vec2 du = 6.0*w*(1.0-w);\n#endif    \n    \n    \n    float a = hash(p+vec2(0.0,0.0));\n    float b = hash(p+vec2(1.0,0.0));\n    float c = hash(p+vec2(0.0,1.0));\n    float d = hash(p+vec2(1.0,1.0));\n\t\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k3 = a - b - c + d;\n\n    return k0 + k1 * u.x + k2 * u.y + k3 * u.x * u.y;\n}\n\nvec2 v2noise(in vec2 uv)\n{\n\treturn vec2(noised(uv + vec2(132.47, 821.12)), noised(uv));\n}\n\nvec3 v3noise(in vec2 uv)\n{\n\treturn vec3(noised(uv + vec2(828.7, 21.12)),\n\t\t\t\tnoised(uv + vec2(13.258, 12.57)),\n\t\t\t\tnoised(uv + vec2(324.61, 57.8)));\n}\n\n// modified version of the following one by Inigo Quilez:\n// http://www.iquilezles.org/www/articles/smoothvoronoi/smoothvoronoi.htm\n\nvec4 voronoi(in vec2 uv)\n{\n\tivec2 p = ivec2(floor(uv));\n\tvec2 f = fract(uv);\n\n\tfloat res = 8.0;\n\tivec2 cell = p;\n\n\n\tfor(int j=-1; j<=1; j++) {\n\t\tfor(int i=-1; i<=1; i++) {\n\t\t\tivec2 b = ivec2(i, j);\n\t\t\tvec2 r = vec2(b) - f + v2noise(vec2(p + b)) * vec2(0.5, 0.5) + vec2(0.5, 0.5);\n\t\t\tfloat d = dot(r, r);\n\t\t\tif(d < res) {\n\t\t\t\tres = d;\n\t\t\t\tcell = (p + b);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn vec4(v3noise(vec2(cell)) * 0.6 * cos(iTime) + 0.8, sqrt(res));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * vec2(aspect, 1.0);\n    vec2 v = uv - center;\n\tfloat angle = atan(v.y, v.x);\n\tfloat polar_x = angle * 0.5 / M_PI + 0.5;\n\tfloat polar_y = sqrt(dot(v, v));\n\n\tfloat depth = 1.7 / polar_y;\n\tvec2 tex_uv;\n    float t = iTime;\n\ttex_uv.x = min(polar_x * 2.0, 2.0 - polar_x * 2.0) * 19.0 * cos(sin(cos(t) * 0.1) * 0.2 + 0.3 * sin(t));\n\ttex_uv.y = depth * 4.0 + sin(cos(t) + M_PI / 4.0);\n\n\tfloat fog = clamp(35.0 / pow(depth, 2.5), 0.0, 1.0);\n    \n \tfragColor.rgb = texture_(tex_uv + 2.0 * cos(sin(iTime) + 0.3 * cos(iTime)) + M_PI / 2.0) * fog;\n\tfragColor.a = 1.0;   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssc3R4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[174, 174, 199, 199, 362], [364, 364, 391, 391, 432], [434, 434, 461, 461, 654], [656, 754, 777, 777, 893], [895, 895, 920, 920, 1500], [1502, 1502, 1528, 1528, 1591], [1593, 1593, 1619, 1619, 1743], [1745, 1878, 1904, 1904, 2317], [2320, 2320, 2377, 2427, 3028]]}
{"id": "ssc3zf", "name": "Clouds with perlin noise", "author": "timattt", "description": "simple perlin noise for learning", "tags": ["clouds"], "likes": 6, "viewed": 136, "date": "1630351117", "time_retrieved": "2024-06-20T20:48:20.952774", "image_code": "// Constants\n//============================================\n#define TOTAL_OCTS 4\n#define RAY_MARCH_TOTAL_STEPS 100\n#define CAM_POS vec3(0., 1.0, 0.)\n//============================================\n\n\n// Global functions\n//============================================\n// randomizer with range [0, 1]\n//float rand(vec3 p) {\n//    return abs(fract((12346.*cos((87654.*sin(-1034560.*(dot(p, vec3(12345, 234567, 2345678) - 1100495.)))) - 1.))));\n//}\nfloat rand(vec3 p) {\n    return fract(sin(dot(p, vec3(12.345, 67.89, 412.12))) * 42123.45) * 2.0 - 1.0;\n}\n\n\n// perlin noise in 0-0-0 -> 1-1-1 cube\nfloat perlin(vec3 p) {\n    vec3 u = floor(p);\n    vec3 v = fract(p);\n    vec3 s = smoothstep(0.0, 1.0, v);\n    \n    float a = rand(u);\n    float b = rand(u + vec3(1.0, 0.0, 0.0));\n    float c = rand(u + vec3(0.0, 1.0, 0.0));\n    float d = rand(u + vec3(1.0, 1.0, 0.0));\n    float e = rand(u + vec3(0.0, 0.0, 1.0));\n    float f = rand(u + vec3(1.0, 0.0, 1.0));\n    float g = rand(u + vec3(0.0, 1.0, 1.0));\n    float h = rand(u + vec3(1.0, 1.0, 1.0));\n    \n    return mix(mix(mix(a, b, s.x), mix(c, d, s.x), s.y),\n               mix(mix(e, f, s.x), mix(g, h, s.x), s.y),\n               s.z);\n}\n\n\n// sums perlin noises by octs\n\n// sums perlin noises by octs\nfloat octs(vec3 p) {\n    vec3 arg = p - iTime * vec3(0, 0.1, 1.);\n    \n    float res = 0.;\n    float A = 0.5;\n    for (int i = 0; i < TOTAL_OCTS; i++) {\n        res += A*perlin(arg);\n        A /= 2.;\n        arg *= 2.;\n    }\n    \n    return clamp(res - p.y, 0.0, 1.0);\n}\n\n\n\n// ray marching\nvec3 rayMarch(vec3 s, vec3 d) {\n    vec4 res = vec4(0);\n    float depth = 0.;\n    for (int i = 0; i < RAY_MARCH_TOTAL_STEPS; i++) {\n        vec3 p = s + d * depth;\n        float density = octs(p);\n        if (density > 1e-3) {\n            vec4 color = vec4(mix(vec3(0.0), vec3(1.0), density), density);\n            color.w *= 0.4;\n            color.rgb *= color.w;\n            res += color * (1.0 - res.a);\n        }\n        depth += max(0.05, 0.02 * depth);\n    }\n    return res.rgb;\n}\n\n//============================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n \n    vec3 start = CAM_POS;\n    vec3 dir = normalize(vec3(uv.xy, 1.0));\n    \n    fragColor = vec4(rayMarch(start, dir).rgb, 1.);// + vec4(0., 0., 0.8, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssc3zf.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[198, 443, 463, 463, 548], [551, 590, 612, 612, 1181], [1215, 1245, 1265, 1265, 1515], [1519, 1535, 1566, 1566, 2021], [2023, 2071, 2128, 2128, 2351]]}
{"id": "sscGRS", "name": "3D Bézier Curve (Revise)", "author": "wylm", "description": "The orgin version is in https://www.shadertoy.com/view/ss33D7.  Revising by the remarks of @FabriceNeyret2.", "tags": ["beziercurve"], "likes": 2, "viewed": 62, "date": "1630046855", "time_retrieved": "2024-06-20T20:48:21.522506", "image_code": "#define SAMPLE_SIZE 30\n\nfloat t(){\n    return abs(cos(iTime));\n}\n\nfloat line(vec2 uv, vec2 p1, vec2 p2)\n{\n    float wid = 0.005;\n    vec2 dir0 = p2 -p1;\n    vec2 dir1 = uv - p1;\n    float h = clamp(dot(dir0, dir1)/dot(dir0, dir0), 0.0, 1.0);\n    return (length(dir1 - dir0 * h) - wid * 0.5);\n}\n\nfloat point(vec2 uv, vec2 p, float r){\n    vec2 offset = uv - p;\n    return sqrt((offset.x * offset.x) + (offset.y * offset.y)) - r;\n}\n\n\nvec2 line_pos(float t, vec2 b0, vec2 b1, vec2 b2){\n    vec2 r0 = mix(b0, b1, t);\n    vec2 r1 = mix(b1, b2, t);\n    return mix(r0, r1, t);\n}\n\nvec4 render(float d){\n    float stroke = fwidth(d) * 1.0;\n    float anti = fwidth(d) * 0.5;\n    vec4 strokeLayer = vec4(vec3(0.05), 1.0-smoothstep(-anti, anti, d - stroke));\n    vec4 colorLayer = vec4(vec3(0.1), 1.0-smoothstep(-anti, anti, d));\n\n    if (stroke < 0.000001) {\n    \treturn colorLayer;\n    }\n    return vec4(mix(strokeLayer.rgb, colorLayer.rgb, colorLayer.a), strokeLayer.a);\n}\n\n\nvec4 draw_line(vec2 uv, vec2 p1, vec2 p2)\n{\n    float d = line(uv,p1,p2);\n    return render(d);\n}\n\nvec4 draw_point(vec2 uv, vec2 p, float r )\n{\n    float d = point(uv,p,r);\n    return render(d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.8);\n    \n    vec2 apexes[9];\n    vec4 layer;\n    \n    apexes[0] = vec2(-0.65 + 0.1*sin(iTime),-0.25 - 0.1*sin(iTime));\n    apexes[1] = vec2(-0.1,0.);\n    apexes[2] = vec2(0.25 + 0.1*cos(iTime),-0.35+ 0.1*cos(iTime));\n    apexes[3] = vec2(-0.4,0.25);\n    apexes[4] = vec2(0.15,0.35+0.1*t());\n    apexes[5] = vec2(0.5,0.2);\n    apexes[6] = vec2(-0.2,0.1+0.1*cos(iTime));\n    apexes[7] = vec2(0.25,0.15+0.1*t());\n    apexes[8] = vec2(0.7 + 0.1*sin(iTime),0. + 0.1*sin(iTime));\n    \n#if 1\n    //draw line\n    for(int i = 1; i < 9; i+=2){\n        int p1 = i-3 < 0 ? 0 : i-3;\n        int p2 = 3-i < 0 ? i-1 : i+1;\n        int p3 = i+3 < 8 ? i+3 : 8;\n        \n        layer = draw_line(uv,apexes[p1],apexes[i]);\n        col = mix(col, layer.rgb,layer.a);\n        layer = draw_line(uv,apexes[i],apexes[p2]);\n        col = mix(col, layer.rgb,layer.a);\n        layer = draw_line(uv,apexes[i],apexes[p3]);\n        col = mix(col, layer.rgb,layer.a);\n    }\n    \n    // draw point\n    for(int i = 0; i < 9; i++){\n        layer = draw_point(uv,apexes[i],0.02);\n        col = mix(col, layer.rgb,layer.a);\n    }\n#endif\n\n    // traverse y axis\n    float pm = 1./float(SAMPLE_SIZE);\n    for(int i = 0; i<=SAMPLE_SIZE; i+=1){\n        vec2 c0 = line_pos(pm*float(i), apexes[0], apexes[3], apexes[6]);\n        vec2 c1 = line_pos(pm*float(i), apexes[1], apexes[4], apexes[7]);\n        vec2 c2 = line_pos(pm*float(i), apexes[2], apexes[5], apexes[8]);\n        \n        // traverse x axis\n        for(int j = 0; j<=SAMPLE_SIZE; j+=1){\n            vec2 p = line_pos(pm*float(j), c0, c1, c2);\n            layer = draw_point(uv,p,0.002);\n            col = mix(col, layer.rgb,layer.a);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sscGRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[24, 24, 34, 34, 64], [66, 66, 105, 105, 293], [295, 295, 333, 333, 429], [432, 432, 482, 482, 571], [573, 573, 594, 594, 963], [966, 966, 1009, 1009, 1063], [1065, 1065, 1109, 1109, 1162], [1164, 1164, 1221, 1271, 3157]]}
{"id": "sscGWM", "name": "liquidcolor", "author": "Caineluo", "description": "this is test demo", "tags": ["2dliquid"], "likes": 3, "viewed": 141, "date": "1629936137", "time_retrieved": "2024-06-20T20:48:21.528579", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 coord = 6.0 * fragCoord.xy / iResolution.xy;\n    for(int i = 1;i < 190;i++){\n        float n = float(i);\n        coord += vec2(0.7 / n * sin(n * coord.y + iTime  + 0.3) + 0.8, 0.4 / n * sin(n * coord.x + iTime + 0.3 ) + 0.6);\n    }\n    vec3 color = vec3(0.5 * sin(coord.x) + 0.5, 0.5 * sin(coord.y) + 0.5,sin(coord.x+coord.y));\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sscGWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 430]]}
{"id": "sscGz4", "name": "exodus", "author": "unjello", "description": "Source for Aberration Creations production - 4KB intro \"Exodus\", published at MAGFest Demoparty 2019. 3rd place in combined demo competition.\n\nCode: Angelo\nMusic: Argasek\n\nWatch the full production here: www.youtube.com/watch?v=HJA1xIevGl0", "tags": ["intro", "source"], "likes": 7, "viewed": 156, "date": "1629223976", "time_retrieved": "2024-06-20T20:48:23.183977", "image_code": "/// Exodus / Aberration Creations, a 4k intro\n/// 3rd place @ MAGFest 2019\n/// License: CC0\n///\n/// Effects inspired by:\n/// Octahedral Voxel Tracing / fizzer: https://www.shadertoy.com/view/4lcfDB\n/// Swirly Strands / Plento: https://www.shadertoy.com/view/MtKfWy\n/// InFX.1 / patu: https://www.shadertoy.com/view/llSSRm\n///\n/// Soundtrack: https://soundcloud.com/argasek/exodus-video\n/// Video: www.youtube.com/watch?v=HJA1xIevGl0\n///\n\n\nfloat MIN_DIST = 0.0;\nfloat MAX_DIST = 120.0;\nfloat EPSILON = 0.0001;\nvec3 K_a = vec3(1.);\nvec3 K_d = vec3(.6);\nvec3 K_s = vec3(0.5, 1.0, 0.5);\nvec3 lp = vec3(0.0, 1.0, -0.5);\nvec3 zero3 = vec3(0.);\n\nint MAX_STEPS = 80;\nint MODE_CROSS_CENTER = 1;\nint MODE_CROSS_JUMPING = 2;\nint MODE_METABALLS_CENTER = 3;\nint MODE_SWIRLS_CENTER = 5;\nint MODE_SWIRLS_SIDE = 6;\n\n// random took from\n// https://thebookofshaders.com/11/\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return 0.4*(mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y);\n}\n\nfloat sdfSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdfCubeCheap(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size;\n    return max(d.x, max(d.y, d.z));\n}\n\nfloat sdfOpUnion(float a, float b) {\n\treturn min(a,b);\n}\n\nvec3 sdfOpMod(vec3 p, vec3 size) {\n    vec3 halfsize = size * 0.5;\n    p = mod(p + halfsize, size) - halfsize;\n    return p;\n}\n\nvec3 opTwist( vec3 p, float r ) {\n    float  c = cos(r * p.y + r);\n    float  s = sin(r * p.y + r);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat opBlob(float d1, float d2, float d3, float d4, float d5, float d6) {\n    float k = 2.0;\n\treturn -log(exp(-k*d1)+exp(-k*d2)+exp(-k*d3)+exp(-k*d4)+exp(-k*d5)+exp(-k*d6))/k;\n}\n\n\n// https://www1.udel.edu/biology/rosewc/kaap427627/notes/matrices_rotations.pdf\nmat3 fullRotate(vec3 theta) {\n    float sx=sin(theta.x);\n    float cx=cos(theta.x);\n    float sy=sin(theta.y);\n    float cy=cos(theta.y);\n    float sz=sin(theta.z);\n    float cz=cos(theta.z);\n    return mat3(\n        vec3(cy*cz, -cy*sz, sy),\n        vec3(sx*sy*cz+cx*sz, -sx*sy*sz+cx*cz, -sx*cy),\n        vec3(-cx*sy*cz+sx*sz, cx*sy*sz+sx*cz, cx*cy)\n        );\n}\n\nfloat sdf_metaballs(vec3 p) {\n    float t = iTime / 4.;\n\tfloat p1 = sdfSphere(0.5*(p + vec3(cos(t*0.5),sin(t*0.3),cos(t))), 1.+0.5*cos(t*6.0));\n    float p2 = sdfSphere(2.0*(p + 3.0 * vec3(cos(t*1.1),cos(t*1.3),cos(t*1.7))), 3.+2.*sin(t))/2.0;\n    float p3 = sdfSphere(2.0*(p + 5.0 * vec3(cos(t*0.7),cos(t*1.9),cos(t*2.3))), 3.)/2.0;\n    float p4 = sdfSphere(2.0*(p + 3.0 * vec3(cos(t*0.3),cos(t*2.9),sin(t*1.1))), 3.+2.*sin(t))/2.0;\n    float p5 = sdfSphere(2.0*(p + 6.0 * vec3(sin(t*1.3),sin(t*1.7),sin(t*0.7))), 3.0+1.5*cos(t))/2.0;\n    float p6 = sdfSphere(2.0*(p + 3.0 * vec3(sin(t*2.3),sin(t*1.9),sin(t*2.9))), 3.0)/2.0;\n    return opBlob(p1, p2, p3, p4, p5, p6);\n}\n\nfloat sdf_swirls(vec3 p, int mode) {\n   p -= vec3(1.0, -0.25, 4.0);   \n   p *= fullRotate(vec3(\n       0.0,\n       0.0, \n       mode == MODE_SWIRLS_CENTER ? p.z*0.06+0.2*sin(iTime) : p.z*.06+iTime*0.25\n   ));\n   p.y += sin(p.z + iTime + p.x*1.0)*0.2;\n   p.x += cos(p.y - p.z * 2.0 + iTime)*0.3;\n   p = sdfOpMod(p, vec3(1.5, 1.5, 0.5+0.3*sin(iTime)));\n   \n   return sdfCubeCheap(p, vec3(0.033, 0.033, 2.0));\n}\n\nfloat sdfCross(vec3 p, float w ) {\n  float da = sdfCubeCheap(p.xyz,vec3(20., w, w));\n  float db = sdfCubeCheap(p.yzx,vec3(w, 20., w));\n  float dc = sdfCubeCheap(p.zxy,vec3(w, w , 20.));\n  return sdfOpUnion(sdfOpUnion(sdfOpUnion(db,dc), da), da);\n} \n\nfloat sdf_cross(vec3 p) {\n    float t = iTime / 4.;\n    float w = 1.7 - length(p) / 10.;\n   p = opTwist(p, 0.1*sin(iTime*0.02))*fullRotate(vec3(iTime*0.01, 0.0, iTime*0.02));\n   p *= fullRotate(vec3(sin(iTime*0.1), 0.0, cos(iTime*0.02)));\n   float res = sdfOpUnion(\n       \t\t\t\tsdfCross(p, w),\n       \t\t\t\tsdfCross(p * fullRotate(vec3(3.14/4.0, 0.0, 3.14/4.0)), w));\n   res = sdfOpUnion(res, sdfCross(p * fullRotate(vec3(3.14, 3.14/4.0, 3.14)), w));\n   return res;\n}\n\n\nvec2 render_raymarch(vec3 eye, vec3 dir, int mode) {\n    float dist = MIN_DIST;\n    float glow = 0.0;\n    float minDist = MAX_DIST;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 v = eye + dist * dir;\n        float step = 0.0;\n        if (mode == MODE_METABALLS_CENTER) {\n            step = sdf_metaballs(v);\n        }\n        if (mode == MODE_CROSS_CENTER || mode == MODE_CROSS_JUMPING) {\n        \tstep = sdf_cross(v);\n        }\n        if (mode == MODE_SWIRLS_CENTER || mode == MODE_SWIRLS_SIDE) {\n\t\t\tstep = sdf_swirls(v, mode);\n        }\n        \n        if (abs(step) < EPSILON) {\n        \treturn vec2(dist, glow);\n        }\n\n        dist += step;\n                \n        minDist = min(minDist, step * 4.);\n        glow = pow( 1. / minDist, 0.4);  \n\n        if (dist >= MAX_DIST) {\n            return vec2(dist, glow);\n        }\n    }\n\treturn vec2(dist, glow);\n}\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n// http://learnwebgl.brown37.net/09_lights/lights_attenuation.html\nvec3 getSunLightColor(vec3 eye, vec3 dir, vec3 p, vec3 lp) {\n    vec3 sun_pos = eye;\n\tvec3 L = sun_pos - p;\n    float d = max(length(L), EPSILON);\n    float atten = 1.0 / (1.0 + d*0.2 + d*d*0.1); \n    vec3 c = (K_a + K_d + K_s)*atten;\n\treturn c;\n}\n\nvec3 getFoggyColor(vec3 eye, float d, vec3 dir, vec3 lightPosition) {\n\t    vec3 p = eye + d * dir;\n        vec3 c = getSunLightColor(eye, dir, p, lightPosition);\n        \n        float fog = smoothstep(0.0, 0.68, d*0.005);\n        return mix(c, zero3, fog);\n}   \n\nvec4 effect_swirls(vec2 fragCoord, int mode) {\n        vec2 uv = vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; \n        vec3 eye = vec3(mode == MODE_SWIRLS_CENTER ? 0.0 : 0.0, 0.0, (mode == MODE_SWIRLS_CENTER ? -17.0 : 2.0)*iTime); \n    \tvec3 viewDir = rayDirection(mode == MODE_SWIRLS_CENTER ? 45.0 : 25.0, iResolution.xy, mode == MODE_SWIRLS_CENTER ? fragCoord : fragCoord.yx);//normalize(vec3(uv,2.0));\n\n        float d = render_raymarch(eye, viewDir, mode).x;\n\n        if (d >= MAX_DIST) {\n            return vec4(0.0);\n        } else {\n            return vec4(getFoggyColor(eye, d, viewDir, lp), 1.0);\n        }\n}\n\nvec4 effect_raymarch(vec2 fragCoord, int mode) {\n    float k = (iTime+150.)/ 2.0;\n    vec3 eye = vec3(\n        mode == MODE_METABALLS_CENTER ? 30. : sin(k) * 40.,\n        1. , \n        mode == MODE_METABALLS_CENTER ? -5.+sin(k) :cos(k) * -20.);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\tvec3 tt = vec3(10.,\n                   mode == MODE_CROSS_CENTER ? 0. : 20.\n                   , 0.);\n\n    if (mode == MODE_METABALLS_CENTER) {\n        tt.x/=2.;\n        tt.y = 2.5+sin(k);\n    }\n  \t\n    vec2 uv = fragCoord.xy / iResolution.xy - 1.0;\n    vec3 cc = vec3(1.0);\n    if (mode == MODE_CROSS_CENTER) {\n        uv.y += noise(uv)*sin(k*noise(uv*cos(k)));\n\t    uv.x -= sin(k*noise(uv*sin(k)));\n        float n = (ceil(uv.x * uv.y));\n\n        if (abs(n) < EPSILON) {\n        tt.y += 2.0 * sin(iTime);\n        cc = vec3(0.65);\n        }\n    } else {\n        float n, n2, n3;\n        float div = mode == MODE_CROSS_JUMPING ? 1. : -1.;\n        n = (ceil(uv.x*2.5 + div*uv.y*2.5 + div*2.0 - div*sin(k+noise(uv))));\n        n2 = (ceil(uv.x*2.5 + div*uv.y*2.5 +  2.0*sin(k)));\n        n3 = (ceil(uv.x*2.5 + div*uv.y*2.5 + div*2.0 - div*sin(k)*cos(k)));\n\t\t\n        vec3 cc = vec3(1.0);\n  \n        if (abs(n) < EPSILON) {\n            tt.y += 2.0 * sin(iTime);\n        }\n        if (abs(n2) < EPSILON) {\n            tt.y += 3.0 * cos(iTime);\n        }\n        if (abs(n3) < EPSILON) {\n            tt.y += 4.0 * cos(iTime);\n        }\n        cc = vec3(0.65);\n    }\n    \n    \n    vec3 up = vec3(0.2, 0.2, -1.);\n    if (mode == MODE_CROSS_JUMPING) {\n        up.z = -50.*cos(k);\n    } else if (mode == MODE_CROSS_CENTER) {\n        up.y = sin(k*5.);\n        up.z = cos(k*5.);\n    }\n    \n    mat4 viewToWorld = viewMatrix(eye, tt, up);\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    vec2 dd = render_raymarch(eye, worldDir, mode);\n    float d = dd.x;\n    float glow = dd.y;\n\n    vec3 c = zero3;\n    if (d >= MAX_DIST) {\n        float g = glow*glow;\n        c += K_s*glow*0.2 + K_d*g;\n    } else {\n        c = getFoggyColor(eye, d, worldDir, mode == 4 ? vec3(0.0, -10., -15.) : lp);\n    }\n    return vec4(c*cc, 1.0);\n}\n\n\nvec4 intro(vec2 fragCoord) {\n    if (iTime <= 4.7) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 9.6) {\n        return effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 16.1) {\n\t\treturn effect_raymarch(fragCoord, MODE_CROSS_JUMPING);\n    } else if (iTime <= 19.1) {\n        return effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 25.7) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 28.7) {\n        return effect_raymarch(fragCoord, MODE_CROSS_JUMPING);\n    } else if (iTime <= 33.7) {\n\t\treturn effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 38.3) {\n        return effect_raymarch(fragCoord, MODE_CROSS_JUMPING);\n    } else if (iTime <= 43.1) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 47.9) {\n        return effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 57.7) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 76.8) {\n        return  effect_raymarch(fragCoord, MODE_CROSS_CENTER);\n    } else {\n        return  effect_swirls(fragCoord, MODE_SWIRLS_CENTER);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy)/ iResolution.xy;\n    fragColor = intro(fragCoord);\n    // Vignette\n    fragColor.rgb *= 1. - (pow(abs(uv.x), 5.) + pow(abs(uv.y), 5.)) * .4;    \n    // Tonemapping\n    fragColor.rgb /= (fragColor.rgb + vec3(.5)) * .7;\n    // Gamma\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n\n    if (iTime > 94.0) {\n        fragColor /= (-93.9+iTime)*6.;\n    }\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sscGz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[800, 856, 883, 883, 958], [960, 960, 983, 983, 1506], [1508, 1508, 1542, 1542, 1570], [1572, 1603, 1642, 1642, 1708], [1710, 1710, 1746, 1746, 1766], [1768, 1768, 1802, 1802, 1894], [1896, 1896, 1929, 1929, 2057], [2059, 2059, 2133, 2133, 2237], [2240, 2320, 2349, 2349, 2682], [2684, 2684, 2713, 2713, 3355], [3357, 3357, 3393, 3393, 3765], [3767, 3767, 3801, 3801, 4014], [4017, 4017, 4042, 4042, 4481], [4484, 4484, 4536, 4536, 5364], [5367, 5367, 5432, 5432, 5564], [5566, 5566, 5615, 5650, 5876], [5878, 5945, 6005, 6005, 6192], [6194, 6194, 6263, 6263, 6453], [6458, 6458, 6504, 6504, 7085], [7087, 7087, 7135, 7135, 9229], [9232, 9232, 9260, 9260, 10458], [10461, 10461, 10518, 10518, 10925]]}
{"id": "ssd3WH", "name": "[TWITCH] Mind Trap", "author": "Flopine", "description": "A shader made partially during a (tired XD) stream.\nYou can watch all the VODs here: https://www.twitch.tv/flopine", "tags": ["3d", "raymarching", "animation", "glow", "isometric", "live", "twitch"], "likes": 17, "viewed": 136, "date": "1629751139", "time_retrieved": "2024-06-20T20:48:23.892902", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings and FabriceNeyret for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU (2.*PI)\n\n#define time iTime\n#define frt(sp,off) fract((time+off)*sp)\n#define flt(sp,off) floor((time+off)*sp)\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define crep(p,c,l) p-=(c*clamp(round(p/c),-l,l))\n#define mo(p,d) p=abs(p)-d;if(p.y>p.x)p=p.yx\n\nstruct obj{\n  float d;\n  vec3 sha;\n  vec3 li;\n};\n\nobj minobj(obj a, obj b)\n{\n  if (a.d<b.d) return a; else return b;\n}\n\n\nfloat box (vec3 p , vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nobj base (vec3 p)\n{\n    vec3 pp = p;\n    float per = 5.;\n    vec3 id = round(p/per);\n    float off = clamp(length(id*0.52),-3.,3.);\n    crep(p,per,2.);\n    float d = box(p,vec3(per*0.1+off));\n    float b = box(p,vec3(0.6));\n\n    p=pp;\n    d = max(-d,box(p-vec3(1.9,-1.9,1.8),vec3(11.)));\n    d = max(-box(p+vec3(1.,-3.,1.),vec3(8.)),d);\n\n    return obj(d, vec3(0.0,0.01,0.05),vec3(0.,0.1,0.2));\n}\n\nobj octas (vec3 p)\n{\n    p.y -= 2.;\n    mo(p.zx,vec2(5.5));\n    vec2 id = round(p.xy/3.);\n    crep(p.xy,3.,2.);\n    float off = length(id),\n    anim = (PI/4.)*(flt(2.,off)+pow(frt(2.,off),8.));\n    p.xz *= rot(anim);\n    float d = dot(p,normalize(sign(p)))-0.8;\n\n    return obj(d,vec3(0.2,0.,0.),vec3(1.,0.5,0.));\n}\n\nfloat g1=0.;\nobj pillars (vec3 p)\n{\n    p -= vec3(1.9,2.,1.8); \n    mo(p.xz,vec2(11.));\n    float d = box(p,vec3(.5,15.,.5));\n    g1 += 0.1/(0.1+d*d);\n\n    return obj(d,vec3(0.),vec3(0.1));\n}\n\nvec2 id;\nobj SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n\n    id = round(p.xz/29.);\n    crep(p.xz,29.,1.);\n    obj scene = base(p);\n    scene = minobj(scene, octas(p));\n    scene = minobj(scene, pillars(p));\n\n    return scene;\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(SDF(p).d-vec3(SDF(p-eps.xyy).d,SDF(p-eps.yxy).d,SDF(p-eps.yyx).d));\n}\n\nfloat AO (float eps, vec3 p, vec3 n)\n{return SDF(p+eps*n).d/eps;}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 ouv = fragCoord.xy/iResolution.xy;\n\n    vec3 ro=vec3(uv*20.,-50.), rd=vec3(0.,0.,1.),p=ro,\n    col=vec3(0.), l=normalize(vec3(2.,3.,-2.));\n\n    bool hit = false; obj O;\n    for (float i=0.; i<64.;i++)\n    {\n        O = SDF(p);\n        if (O.d<0.001)\n        {hit=true;break;}\n        p += O.d*rd;\n    }\n\n    if (hit)\n    {\n        vec3 n=getnorm(p);\n        float light = max(dot(n,l),0.);\n        float ao = AO(0.1,p,n)+AO(0.5,p,n)+AO(0.9,p,n);\n        col = mix(O.sha, O.li, light)*(ao/3.);\n    }\n\n    col += g1*(sin(length(id)-frt(.3,0.)*TAU)+1.);\n    fragColor = vec4(sqrt(col),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssd3WH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[208, 701, 727, 727, 769], [772, 772, 801, 801, 886], [888, 888, 907, 907, 1284], [1286, 1286, 1306, 1306, 1601], [1616, 1616, 1638, 1638, 1794], [1805, 1805, 1823, 1823, 2056], [2058, 2058, 2081, 2081, 2203], [2205, 2205, 2243, 2243, 2270], [2272, 2272, 2328, 2328, 2988]]}
{"id": "ssd3z7", "name": "Basic Tile(3)", "author": "chenxiaoleizi", "description": "move tile", "tags": ["tile"], "likes": 4, "viewed": 54, "date": "1629465316", "time_retrieved": "2024-06-20T20:48:24.104673", "image_code": "vec2 tile(vec2 st, float scale, float t){\n    st *= scale;\n    \n    float a;\n    float smoothT = fract(t); \n    smoothT = 3.0*pow(smoothT, 2.0) - 2.0*pow(smoothT, 3.0);\n    //smoothT *= smoothT*(3.-2.0*smoothT);\n    if (mod(t, 2.0) > 1.0) {\n        // Move vertical\n        a = mod(st.x, 2.0) > 1.0 ? 1.0 : -1.0;\n        st.y += a*smoothT;\n    } else {\n        // Move horizontal\n        a = mod(st.y, 2.0) > 1.0 ? 1.0 : -1.0;\n        st.x += a*smoothT;\n    }\n    \n    return fract(st);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    uv = tile(uv, 15.0, iTime);\n    \n    // Time varying pixel color\n    float d = length(uv - vec2(0.5, 0.5));\n    float pix = 22.0/iResolution.y;\n    vec3 col = vec3(smoothstep(0.3, 0.3 + pix, d));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssd3z7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 41, 41, 488], [490, 490, 547, 597, 899]]}
{"id": "ssdGD7", "name": "2d fake 3d DOF Grid test", "author": "foxic", "description": "IDK", "tags": ["2d", "grid", "dof", "plain"], "likes": 0, "viewed": 63, "date": "1629996622", "time_retrieved": "2024-06-20T20:48:24.104673", "image_code": "\nfloat map(in vec2 p) {\n\n    float depth = p.y+1.5;\n    \n    p.y += 6.;\n    //p.x += (p.y+12.)*0.2*p.x;\n    p.xy += vec2(p.y+12.)*0.2*p.xy;\n    \n    p.y += iTime*5.;\n    float s = sin(p.y+p.x) + sin(p.x-p.y);\n    \n    \n    \n    float w = fwidth(s);\n    w *= abs(depth)*1.25;\n    \n    s = smoothstep(-w, w, s);\n\n    return  s -abs((depth+3.5)*0.025);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y)*12.;\n    \n    float s = map(p);\n    s = max( map(p+vec2(0.,0.125))*0.25, s );\n\n\n    fragColor = vec4(vec3(s), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssdGD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 23, 23, 351], [354, 354, 409, 409, 609]]}
{"id": "ssdGzM", "name": "~Conformal Woobly Torus Mapping3", "author": "FabriceNeyret2", "description": "WIP\n  Right: naive tiling of the woobly torus\n  Left: vaguely conformal mapping\nThere is no strict conformal mapping on this things.\nI just separately reparameterize the u and v as in https://shadertoy.com/view/sdd3R4\n( tuned for mid crown on top view )", "tags": ["torus", "uv", "conformal", "short"], "likes": 27, "viewed": 298, "date": "1629459096", "time_retrieved": "2024-06-20T20:48:24.595561", "image_code": "//variant of https://shadertoy.com/view/sdd3R4\n\nfloat  R0 = 20., R1 = 10.,                                    // large and small radii\n        k = 2., // .9                                         // tile multiplier\n        S = .4;\n  #define T 0.\n//#define T iTime\n#define hue(v)  ( .6 + .6 * cos( v  + vec4(0,23,21,0)  ) )    // hue\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )              // rotation                  \n#define SQR(x)  ( (x)*(x) )\n\n#define f(x)  DX * sqrt( 1. + SQR( S*6.*R1/R0*cos(6.*x+T) ) )  \\\n                 / mix( 1.,sin(6.*x+T), S );\n\nfloat intX( float a ) {                                       // --- antiderivative of large circumference\n    a = mod(a,6.2832);   // if you know a close form ( or good approx ), welcome ! :-)\n // return  2.808*a + .32  *(cos(6.*a) -1.); // fitting for S = .4, N=6  https://www.desmos.com/calculator/uepjhnpyap\n // return  1.85 *a + .129 *(cos(6.*a) -1.); //             S = .3 \n // return  1.40 *a + .057 *(cos(6.*a) -1.); //             S = .2 \n // return  1.143*a + .002 *(cos(6.*a) -1.); //             S = .1 \n // return  2.516*a + .45  *(cos(6.*a) -1.); //             S = .4, N=4 \n    float x, s = 0., DX = 0.01;  // indeed, approx above better than DX=.01\n    for( x = 0.; x < a; x += DX )\n        s += f(x);\n    return s += ( a - (x-DX) )/DX * f(x) ;                    // smooth integral\n}\n\nfloat a,b,r1,d; vec3 M;\n\nfloat map(vec3 q) {                                           // --- shape\n    q.yz *= rot( .5+6.*M.y),                                  // rotations\n    q.xz *= rot( 2.-6.*M.x),\n    a = atan(q.z,q.x),\n    b = atan(q.y,d),\n    r1 = R1* mix( 1., sin(6.*a+T) , S);\n    return min( 9., length(vec2(d=length(q.xz)-R0,q.y)) - r1 ); // abs for inside + outside\n}\n\nvec3 normal( vec3 p ) { // --- smart gradient  https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n    float h = 1e-4; \n    vec2 k = vec2(1,-1);\n    return normalize( k.xyy* map( p + k.xyy*h ) + \n                      k.yyx* map( p + k.yyx*h ) + \n                      k.yxy* map( p + k.yxy*h ) + \n                      k.xxx* map( p + k.xxx*h ) );\n}\n\nvoid mainImage(out vec4 O, vec2 U) {    // ===================================\n    float t=9.;\n\n    vec3  R = iResolution,\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),          // ray direction\n          p = 90./R, q;                                       // marching point along ray \n       // M =  iMouse.xyz/R -.5;\n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0));\n     \n    for ( O=vec4(0) ; O.x < 1. && t > .01 ; O+=.01 )\n        t = map(p), // also set a,b,r1,d\n        p += .5*t*D;                                          // step forward = dist to obj          \n\n    O = O.x > 1. ? vec4(0.) : exp(-3.*O/4.);                  // luminance (depth + pseudo-shading )\n    if ( U.x < R.x/2. ) {                                     // left: conformal mapping\n        a = intX(a); \n        float// s = S*6.*cos(6.*a+T),\n             // r = r1/R0, //*sqrt(1.+s*s), \n                r = R1/R0,\n               ir = sqrt(1.-r*r);                   // antiderivative of 1/circonf(b) \n        b = .996*  2./ir* atan( (r-1.)/ir* tan(b/2.) );        \n     //                                NB: tan(b/2) = ( -d + sqrt(d*d+q.y*q.y) )/q.y )        \n    } \n    \n    if (O.x>0.) {\n        O = hue( mod(floor(k*R0*a/6.283),floor(k*R0*intX(-1e-5)/6.283)) \n                + 17.*mod(round(k*R1*b/6.283), floor(k*R1)) ); // colored tiles \n        a = sin(k*R0*a/2.), b = cos(k*R1*b/2.);\n        O *= sqrt( min(abs(a)/fwidth(a),1.) * min( abs(b)/fwidth(b),1.) );// tiles borders\n        O *= .3 + .7*max(0.,dot(normal(p),vec3(.58))); // shading\n    }\n    if (int(U)==int(R/2.) ) O++;                              // vertical separator\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssdGzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[247, 566, 589, 672, 1366], [1393, 1393, 1412, 1467, 1749], [1751, 1751, 1774, 1863, 2115], [2117, 2117, 2153, 2195, 3783]]}
{"id": "ssdGzN", "name": "Persian rug patterns 3", "author": "jarble", "description": "These rug-like patterns are generated using triangle waves with a pseudorandom hash function.", "tags": ["fractal", "rug"], "likes": 3, "viewed": 140, "date": "1629318040", "time_retrieved": "2024-06-20T20:48:25.019896", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 6.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    vec3 random3 = (hash31(2.+floor((iTime)/10.0+uv.x))-vec3(.5))/4.;\n    vec3 random4 = (hash31(3.+floor((iTime)/10.0+uv.x))-vec3(.5))/4.;\n    \n    float offset = .16+random4.z*.04;\n    float scale2 = 1.16+.04*random4.y;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            uv = triangle_wave(uv+offset,scale)+triangle_wave(uv.yx,scale);\n            uv.x *= -1.0;\n\n            uv = triangle_wave(uv+random1.x,scale+random3.z);\n            uv.x /= -1.0;\n            \n            uv = triangle_wave(uv+random1.y,scale+random3.y);\n            uv.x *= -1.0;\n \n            uv = triangle_wave(uv+random1.z,scale+random3.z);\n            uv.x /= -1.0;\n            \n            //uv.x *= -1.0;\n            //uv = triangle_wave(uv+c1.y,scale);\n            scale /= scale2+col.x/2.;\n            offset *= scale2/(1.+random4.x);\n            \n            //uv = uv.yx;\n            //uv = uv.yx;\n            scale2 += col.x/4.;\n            //random1 = random3+hash31(col.x/32.)/2.;\n            //random3 = random4+hash31(col.y/32.)/2.;\n            //random4 = random1+hash31(col.z/32.)/2.;\n            col[c] = fract((uv.y)-(uv.x));\n\n        }\n     \n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssdGzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[277, 387, 409, 455, 588], [591, 591, 630, 630, 675], [677, 677, 734, 734, 2304]]}
{"id": "ssdGzX", "name": "procedural walk", "author": "madware", "description": "Simple walking", "tags": ["procedural", "animation", "walk"], "likes": 16, "viewed": 141, "date": "1630409855", "time_retrieved": "2024-06-20T20:48:25.025967", "image_code": "const float movement_speed = 4.7;\n\nconst vec2 legs_origin = vec2(0.885, 0.06);\nconst float legs_radius = 0.068;\nconst float legs_height_clamp = 0.01;\n\nconst vec2 pelvis_origin_initial = vec2(0.7105, 0.637);\nconst float upper_knee_length = 0.32;\nconst float lower_knee_length = 0.32;\n\nconst float torso_height = 0.35;\nconst float neck_height = 0.13;\nconst float shoulder_length = 0.22;\nconst float forearm_length = 0.21;\n\nfloat circle(in vec2 uv, in vec2 p, in float rad)\n{\n    float linear_eps = 1.0 / iResolution.x;\n    vec2 puv = uv - p;\n    return smoothstep(rad + linear_eps, rad - linear_eps, length(puv));\n}\n\nfloat sd_segment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat line(in vec2 uv, in vec2 p1, in vec2 p2, in float rad)\n{\n    float linear_eps = 1.0 / iResolution.x;\n    return smoothstep(rad + linear_eps, rad - linear_eps, sd_segment(uv, p1, p2));\n}\n\nvec2 rotate(in vec2 v, in float theta)\n{\n    vec2 sincos = vec2(sin(theta), cos(theta));\n    mat2x2 rot = mat2x2(\n        sincos.y, sincos.x,\n        -sincos.x, sincos.y\n    );\n    return rot * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    \n    vec3 col = vec3(0.5, 0.5, 0.5);\n    \n    float l1 = lower_knee_length;\n    float l2 = upper_knee_length;\n    \n    vec2 k2 = vec2(l1*l1 - l2*l2);\n    \n    vec2 sincos = vec2(\n        sin(iTime * movement_speed), \n        cos(iTime * movement_speed)\n    );\n    vec2 sincos2 = vec2(\n        sin(iTime * movement_speed * 2.0),\n        cos(iTime * movement_speed * 2.0)\n    );\n    \n    vec2 fwd_v = normalize(vec2(-0.47, -1.0)) * (l1 + l2);\n    \n    \n    float shoulder_angle_left = -sincos.x / 7.0;\n    float forearm_angle_left = shoulder_angle_left + shoulder_angle_left;\n    float shoulder_angle_right = sincos.x / 7.0;\n    float forearm_angle_right = shoulder_angle_right + shoulder_angle_right;\n    \n    vec2 pelvis_origin = pelvis_origin_initial;\n    \n    vec2 v_left = legs_origin + sincos.xy * legs_radius;\n    vec2 v_right = legs_origin - sincos.xy * legs_radius;\n    \n    v_left = mix(v_left, pelvis_origin + fwd_v, (1.0 - sincos.x) / 2.0);\n    v_left.y = max(legs_height_clamp, v_left.y);\n    \n    \n    v_right = mix(v_right, pelvis_origin + fwd_v, (sincos.x + 1.0) / 2.0);\n    v_right.y = max(legs_height_clamp, v_right.y);\n    \n    pelvis_origin += \n        vec2(\n            sincos2.x * 0.001, \n            sincos2.y * 0.008\n        );\n    \n    vec2 dir_left = v_left - pelvis_origin;\n    vec2 dir_right = v_right - pelvis_origin;\n    \n    vec2 k1 = vec2(\n        length(dir_left),\n        length(dir_right)\n    );\n    \n    dir_left = normalize(dir_left);\n    dir_right = normalize(dir_right);\n    \n    \n    if (k1.x > l1 + l2) {\n        pelvis_origin = v_left - dir_left * (l1 + l1);\n        k1.x = l1 + l1;\n        k1.y = length(v_right - pelvis_origin);\n    }\n    \n    if (k1.y > l1 + l2) {\n        pelvis_origin = v_right - dir_right * (l1 + l1);\n        k1.y = l1 + l1;\n        k1.x = length(v_left - pelvis_origin);\n    }\n    \n    vec2 torso = pelvis_origin + vec2(0.0, torso_height);\n \n    vec2 neck = torso \n        + vec2(0.0, neck_height)\n        + vec2(\n            sincos2.x * 0.001, \n            sincos2.y * 0.001\n        );\n        \n    vec2 elbow_left = torso +\n        rotate(vec2(0.0, -shoulder_length), shoulder_angle_left);\n    vec2 palm_left = elbow_left +\n        rotate(vec2(0.0, -forearm_length), forearm_angle_left);\n    vec2 elbow_right = torso +\n        rotate(vec2(0.0, -shoulder_length), shoulder_angle_right);\n    vec2 palm_right = elbow_right +\n        rotate(vec2(0.0, -forearm_length), forearm_angle_right);\n  \n    vec2 d = (k1*k1 - k2) / (2.0 * k1);\n    vec2 cos_a = d / l2;\n    vec2 a = acos(cos_a);\n    \n    mat2x2 rot_left = mat2x2(\n        cos_a.x, sin(a.x),\n        -sin(a.x), cos_a.x\n    );\n    mat2x2 rot_right = mat2x2(\n        cos_a.y, sin(a.y),\n        -sin(a.y), cos_a.y\n    );\n    \n    vec2 knee_left = (rot_left * dir_left) * l2 + pelvis_origin;\n    vec2 knee_right = (rot_right * dir_right) * l2 + pelvis_origin;\n    \n    neck /= 2.2;\n    torso /= 2.2;\n    pelvis_origin /= 2.2;\n    knee_left /= 2.2;\n    knee_right /= 2.2;\n    v_left /= 2.2;\n    v_right /= 2.2;\n    elbow_left /= 2.2;\n    elbow_right /= 2.2;\n    palm_left /= 2.2;\n    palm_right /= 2.2;\n    \n    col = mix(\n        col, vec3(0.8, 0.8, 0.8), \n        line(uv, torso, neck, 0.002)\n    );\n    \n    col = mix(\n        col, vec3(0.8, 0.8, 0.8), \n        line(uv, pelvis_origin, torso, 0.002)\n    );\n    \n    col = mix(\n        col, vec3(0.8, 0.8, 0.8), \n        line(uv, pelvis_origin, knee_left, 0.002)\n    );\n    col = mix(\n        col, vec3(0.8, 0.8, 0.8), \n        line(uv, knee_left, v_left, 0.002)\n    );\n    \n    col = mix(\n        col, vec3(0.8, 0.8, 0.8), \n        line(uv, pelvis_origin, knee_right, 0.002)\n    );\n    col = mix(\n        col, vec3(0.8, 0.8, 0.8), \n        line(uv, knee_right, v_right, 0.002)\n    );\n    \n    col = mix(\n        col, vec3(0.8, 0.8, 0.8), \n        line(uv, torso, elbow_left, 0.002)\n    );\n    col = mix(\n        col, vec3(0.8, 0.8, 0.8), \n        line(uv, elbow_left, palm_left, 0.002)\n    );\n    col = mix(\n        col, vec3(0.8, 0.8, 0.8), \n        line(uv, torso, elbow_right, 0.002)\n    );\n    col = mix(\n        col, vec3(0.8, 0.8, 0.8), \n        line(uv, elbow_right, palm_right, 0.002)\n    );\n    \n    col = mix(col, vec3(1.0, 1.0, 1.0), circle(uv, neck, 0.04));\n    \n    col = mix(col, vec3(1.0, 1.0, 1.0), circle(uv, pelvis_origin, 0.01));\n    col = mix(col, vec3(1.0, 1.0, 1.0), circle(uv, torso, 0.01));\n    \n    col = mix(col, vec3(0.88, 0.4, 0.47), circle(uv, knee_left, 0.005));\n    col = mix(col, vec3(0.47, 0.4, 0.88), circle(uv, knee_right, 0.005));\n    \n    col = mix(col, vec3(0.88, 0.4, 0.47), circle(uv, elbow_left, 0.005));\n    col = mix(col, vec3(0.47, 0.4, 0.88), circle(uv, elbow_right, 0.005));\n    \n    col = mix(col, vec3(0.88, 0.4, 0.47), circle(uv, palm_left, 0.005));\n    col = mix(col, vec3(0.47, 0.4, 0.88), circle(uv, palm_right, 0.005));\n    \n    col = mix(col, vec3(0.88, 0.4, 0.47), circle(uv, v_left, 0.005));\n    col = mix(col, vec3(0.47, 0.4, 0.88), circle(uv, v_right, 0.005));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssdGzX.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[421, 421, 472, 472, 613], [615, 615, 668, 668, 787], [789, 789, 851, 851, 980], [982, 982, 1022, 1022, 1180], [1182, 1182, 1239, 1239, 6310]]}
{"id": "sst3RB", "name": "Seigaiha animated", "author": "sp0rk3d", "description": "inspired by Seigaiha, the pattern seen in some Japanese ceramics and textiles\ntrying a smoothed square wave for the circular pattern", "tags": ["waves", "scales", "seigaiha"], "likes": 9, "viewed": 77, "date": "1630113903", "time_retrieved": "2024-06-20T20:48:25.025967", "image_code": "float N21(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    float\n        scale = 15., \n        r = mix(.75, 1.5, sin(iTime*.1)*.5+.5), //radius\n        s_freq, //stripe per scale\n        s_thic, //stripe thickness\n        s_pattern, //stripe pattern \n        d, //testing distance\n        Dist,\n        mRes = max(iResolution.x, iResolution.y),\n        aa,\n        PI = 3.14159265359; \n\n    vec2 \n        R = iResolution.xy, \n        id, //local coord\n        oUV, //testing UV with offset\n        UV = fragCoord / mRes * scale;\n        \n    vec3\n        blue1 = vec3(36.,126.,246.)/255.,\n        blue2 = vec3(26.,88.,234.)/255.,\n        bg = vec3(.8),\n        s_color;\n    \n#define T(x,y)                          \\\n   oUV = round(UV) + vec2(x, y) / 2.,   \\\n   d = length(UV - oUV) / r;            \\\n   d < 1. ? Dist = d, id = oUV : id;    \n\n    T(-1, 1);\n    T( 1, 1);\n    T( 0, 0);\n    T(-1,-1);\n    T( 2, 0);\n    T( 1,-1);\n    T( 3,-1);\n    T( 0,-2);\n    T( 2,-2);\n    T(-1,-3);\n    T( 1,-3);\n    T( 3,-3);\n    T(-2,-4);\n    T( 0,-4);\n    T( 2,-4); \n\n    s_freq = r * (5. + sin(id.x / 2. + iTime*.3));\n    s_thic = sin(id.y / 3. + iTime * .5) * .4 + .5;\n    s_pattern = 2. * abs(mod(((1. - s_thic) / (2. * s_freq)) + 1.01 - Dist, 1. / s_freq) * 2. * s_freq - 1.) - (2. * s_thic);\n    s_color = mix(blue1, blue2, N21(id));\n    aa = fwidth(s_pattern);\n    fragColor = vec4(mix(bg, s_color, smoothstep(-aa, 0., s_pattern)), 1);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sst3RB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 19, 75, 218], [220, 220, 274, 274, 1650]]}
{"id": "sst3W8", "name": "double AA with fwidth (color)", "author": "FabriceNeyret2", "description": "left:   bottom:   no AA\n         top:         only the strip borders are AA with fwidth. Problem when strip themselves get too thin.\nright:                too thin strips are AA too with another fwidth.\n\ntry variant patterns for 'a' ", "tags": ["moire", "aa", "fwidth"], "likes": 13, "viewed": 199, "date": "1629734403", "time_retrieved": "2024-06-20T20:48:25.025967", "image_code": "// different pattern + color, from https://shadertoy.com/view/fdd3D8\n\n  #define SQR(v)     ( (v)*(v) )\n  #define fwidth2(v)  sqrt( SQR(dFdx(v)) + SQR(dFdy(v)) ) // for more isotropic\n//#define fwidth2(v)  fwidth(v)\n\nvoid mainImage(out vec4 O, vec2 u ) {    \n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y;\n          \n    float l = length(U), A = atan(U.y,U.x);\n    vec4  a = round(R.y/6.) * ( .00*sin(50.*U.x) + sin(4.*A -2.*l - iTime ) +cos(5.*l-A +iTime) - sin(l*l+ vec4(0,.1,.2,0)) ) , //  pattern\n          s = sin( a ),                                   // strip base\n          v = U.y > 0.\n                ? clamp(.5 + .5 * s/fwidth(s), 0.,1.)     // top: strip pattern with AA borders\n                : step( 0., s ),                          // bottom: no AA\n      aa = smoothstep(3.14/3., 6.28/3., fwidth2(a));      // detect param going too fast\n          \n     if (U.x > 0.) v = mix(  v, vec4(.5), aa );           // right: switch to grey to AA high strip freq\n    \n    O =  sqrt( v ) ;                                      // to sRGB\n\n    if ( int(u.x)==int(R.x)/2 ) O = vec4(1,0,0,1);        // vertical separator\n    if ( int(u.y)==int(R.y)/2 ) O = vec4(1,0,0,1);        // horizontal separator\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sst3W8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[183, 216, 253, 253, 1225]]}
{"id": "sstGW7", "name": "animating mandelbrot set", "author": "shouya", "description": "The mandelbrot set.", "tags": ["fractal", "math"], "likes": 3, "viewed": 52, "date": "1629991918", "time_retrieved": "2024-06-20T20:48:25.025967", "image_code": "float iter_max = 32.0;\nfloat bound = 50.0;\n\nvec2 iter(in vec2 z, in vec2 c) {\n  return vec2(z.x*z.x-z.y*z.y, 2.0*z.x*z.y) + c;\n}\n\nvec2 screenToClip(vec2 coord) {\n    vec2 uv = coord/iResolution.xy;\n    return (uv - vec2(0.6,0.5)) / (iResolution.yx / 3000.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 c = screenToClip(fragCoord);\n    vec2 z = vec2(0.0) + vec2(cos(iTime*0.3), sin(iTime*.2));\n\n    for (int n = 0; float(n) < iter_max; n++) {\n      z = iter(z, c);\n      if (length(z) > bound) {\n        fragColor = 1.0-vec4(float(n) / float(iter_max));\n        return;\n      }\n    }\n    \n    fragColor = vec4(1.0-abs(z), length(z), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sstGW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[44, 44, 77, 77, 128], [130, 130, 161, 161, 260], [262, 262, 319, 319, 666]]}
{"id": "sstGWM", "name": "Gyroid_1", "author": "rushalivshinde", "description": "gyroid", "tags": ["cube", "colour", "gyroid"], "likes": 1, "viewed": 64, "date": "1630148857", "time_retrieved": "2024-06-20T20:48:25.025967", "image_code": "\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S(a, b, t) smoothstep(a,b,t)\n#define T iTime(a, b, t)\n\nmat2 Rot(float a) {\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias){        \n    p *= scale;\n    return abs(dot(sin(p), cos(p.zxy))-bias)/scale-thickness;\n}\n\nvec3 Transform(vec3 p){\n    p.z -= iTime*.1;\n    p.y -+ .3;\n    return p;\n\n}\n\nfloat GetDist(vec3 p) {\n\n    p = Transform(p);\n    \n    float box = sdBox(p, vec3(1));\n\n    float g1 = sdGyroid(p, 5.23, .03, 1.3);\n    float g2 = sdGyroid(p, 10., .03, .3);\n    float g3 = sdGyroid(p, 20., .03, .3);\n    float g4 = sdGyroid(p, 40., .03, .3);\n    float g5 = sdGyroid(p, 60., .03, .3);\n    //float g = min(g1, g2);\n    g1 -= g2*.2;\n    g1 -= g3*.2;\n    g1 += g4*.1;\n    g1 += g5*.1;\n    float d =  g1*.8;\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.02, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    float t = iTime;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0, 0, -.03);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 lookat = vec3(0,0,0);\n    vec3 rd = GetRayDir(uv, ro, lookat, .8);\n    \n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        //vec3 r = reflect(rd, n);\n\n        p = Transform (p);\n        float dif = n.y*.5+.5;\n        col += dif*dif;\n        \n        float g2 = sdGyroid(p, 10.76, .03, .3);\n        \n        col *= S(-.1, .2, g2);\n        \n        float crackw = -.02+S(0.,-.5, n.y)*.04;\n        float cracks = S(crackw, -.03, g2);\n        \n        float g3 = sdGyroid(p+t*.1, 5.76, .03, .0);\n        \n        float g4 = sdGyroid(p-t*.15, 3.76, .03, .05);\n        cracks *= g3*g4*20.+.2*S(.2, .0, n.y);\n        col += cracks*vec3(1, .4, .1)*3.;\n    }\n    \n   \n    \n    d = sdGyroid(vec3(uv.x, uv.y, iTime*.1), 20., .01, 0.);\n    \n    fragColor = vec4(col,.1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sstGWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[133, 133, 152, 152, 224], [226, 226, 255, 255, 336], [338, 338, 403, 403, 491], [493, 493, 516, 516, 569], [571, 571, 594, 594, 1010], [1012, 1012, 1046, 1046, 1257], [1259, 1259, 1283, 1283, 1472], [1474, 1474, 1524, 1524, 1719], [1721, 1721, 1778, 1778, 2864]]}
{"id": "sstGzM", "name": "Chinese Ink-wash Paining", "author": "Delincoter", "description": "I have always wanted to implement ink style rendering in a computer,this is my first attempts in 2D.", "tags": ["2d"], "likes": 24, "viewed": 480, "date": "1629443127", "time_retrieved": "2024-06-20T20:48:25.025967", "image_code": "#define S smoothstep\n\n//noise funtion abstract from https://www.shadertoy.com/view/4sc3z2\nvec2 hash22(vec2 p)\n{\n    p = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)));\n    \n    //return normalize(-1.0 + 2.0 * fract(sin(p)*43758.5453123));\n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    \n    vec2 i = floor(p + (p.x + p.y) * K1);\n    \n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    vec2 b = a - (o - K2);\n    vec2 c = a - (1.0 - 2.0 * K2);\n    \n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n    \n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\nfloat noise_sum(vec2 p)\n{\n    float f = 0.0;\n    p = p * 4.0;\n    f += 1.0000 * simplex_noise(p); p = 2.0 * p;\n    f += 0.5000 * simplex_noise(p); p = 2.0 * p;\n\tf += 0.2500 * simplex_noise(p); p = 2.0 * p;\n\tf += 0.1250 * simplex_noise(p); p = 2.0 * p;\n\tf += 0.0625 * simplex_noise(p); p = 2.0 * p;\n    \n    return f;\n}\n\n\n\nvec2 drawMountain(vec2 uv, float f, float d)\n{\n    float Side = uv.y + noise_sum(vec2(uv.x, mix(uv.y,0.,uv.y))*f)*0.1;\n    float detal = noise_sum(vec2(uv.x, uv.y)*8.)*0.005;\n    Side += detal;\n\n    float Mountain = S(0.48, 0.49, Side);\n    float fog = S(d, noise_sum(vec2(uv.x+iTime*0.06, uv.y)*0.2)*0.2, Side);\n    \n    return clamp(vec2(Side+fog, Mountain),0.,1.);\n}\n\nfloat drawSun(vec2 uv)\n{\n    vec2 u = uv;\n    u -= 0.5;\n    u.x *= iResolution.x/iResolution.y;  \n    \n    float Sun = S(0.09, 0.1, length(vec2(u.x-.5, u.y-.3)));\n    \n    float fog = S(0.7,noise_sum(vec2(uv.x+iTime*0.001, uv.y)*2.)*0.05,u.y)*1.4;\n    \n    return clamp(Sun+fog,0.,1.);\n}\n\nfloat drawBird(vec2 uv)\n{\n    uv = (uv-.5)*20.;\n    uv.x -= uv.y;\n\n    uv.y = uv.y+.45+(sin((iTime*0.5-abs(uv.x))*3.)-1.)*abs(uv.x)*0.5;\n    \n    float S1 = smoothstep(0.45,0.4,length(uv));\n    \n    uv.y += .1;\n    float S2 = smoothstep(0.5,0.45,length(uv));\n    \n    float S = S1-S2;\n    return S;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float t = iTime*0.5;\n    \n    vec3 c = vec3(1.);\n    \n    \n    float Sun = drawSun(uv);\n    c = mix(vec3(1.,0.2,0.0), c, Sun);  \n    \n    float Bird = drawBird(vec2(uv.x-.15,uv.y-.4));\n    c = mix(c, vec3(1.)*.65, Bird);\n    \n    uv.y -= .2;\n    uv.x += t*0.001;\n    vec2 Mountain1 = drawMountain(uv, .4, 1.);\n    c = mix(vec3(Mountain1.r), c, Mountain1.g);\n    \n    uv.y += .1;\n    uv.x += 1.;\n    uv.x += t*0.005;\n    Mountain1 = drawMountain(uv, .3, .8);\n    c = mix(vec3(Mountain1.r), c, Mountain1.g);\n    \n    uv.y += .1;\n    uv.x += 2.42;\n    uv.x += t*0.01;\n    Mountain1 = drawMountain(uv, .2, 0.6);\n    c = mix(vec3(Mountain1.r), c, Mountain1.g);\n    \n    uv.y += .1;\n    uv.x += 12.84;\n    uv.x += t*0.05;\n    Mountain1 = drawMountain(uv, .2, 0.4);\n    c = mix(vec3(Mountain1.r)-0.01, c, Mountain1.g);\n \n       \n    vec3 col = vec3(c);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sstGzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[22, 90, 111, 111, 309], [311, 311, 340, 340, 884], [886, 886, 911, 911, 1204], [1208, 1208, 1254, 1254, 1577], [1579, 1579, 1603, 1603, 1866], [1868, 1868, 1893, 1893, 2168], [2170, 2170, 2227, 2227, 3156]]}
{"id": "st2SRK", "name": "Inverse Julia Fractal", "author": "Eriksonn", "description": "julia fractal using Az^2 - 0.04A/z^2 + C\n", "tags": ["fractal"], "likes": 11, "viewed": 118, "date": "1628120985", "time_retrieved": "2024-06-20T20:48:25.025967", "image_code": "vec2 Mult(vec2 A,vec2 B)\n{\n    return vec2(A.x*B.x-A.y*B.y,A.x*B.y+A.y*B.x);\n}\nvec2 Div(vec2 A, vec2 B)\n{\n    return vec2(A.x*B.x+A.y*B.y,-A.x*B.y+A.y*B.x)/dot(B,B);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 4.5*(fragCoord-iResolution.xy*0.5)/iResolution.x;\n    vec2 Z = vec2(uv);\n    \n    float angle1=iTime*0.2;\n    float angle2=angle1*0.4;\n    vec2 C = vec2(cos(angle2),sin(angle2))*0.30;\n    vec2 A=vec2(cos(angle1),sin(angle1));\n    vec2 B=-A*0.04;\n    fragColor = vec4(1,0,1,0);\n    vec2 Der =vec2(1,0);\n    for(int i =0;i<20;i++)\n    {\n        Z=Mult(A,Mult(Z,Z))+Div(B,Mult(Z,Z))+C;\n        Der =2.0*Mult(Der,Mult(A,Z)-Div(B,Mult(Z,Mult(Z,Z))));\n        float D = Z.x*Z.x+Z.y*Z.y;\n        if(D>20.0)\n        {\n            float e=-2.0+log(log(D)/(log(2.0)*2.0))/log(2.0);\n            float a=(float(i)-e)/20.0;\n            a=pow(a,0.8);\n            fragColor=vec4(a*a,0,a,1);\n            return;\n        }\n    }\n    float d = Der.x*Der.x+Der.y*Der.y;\n    d=pow(d,0.15);\n    fragColor = vec4(1,0,1,0)*d+vec4(0.3,0.2,0.8,0)*(1.0-d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/st2SRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 26, 26, 78], [79, 79, 105, 105, 167], [168, 168, 225, 225, 1072]]}
{"id": "st2SRt", "name": "For Winnie", "author": "caorenxxy", "description": "For Winnie", "tags": ["hearsurface"], "likes": 5, "viewed": 51, "date": "1628416571", "time_retrieved": "2024-06-20T20:48:25.692544", "image_code": "// http://mathworld.wolfram.com/HeartSurface.html\n\nfloat f(vec3 p) {\n    vec3 pp = p * p;\n    vec3 ppp = pp * p;\n    float a = pp.x + 2.25 * pp.y + pp.z - 1.0;\n    return a * a * a - (pp.x + 0.1125 * pp.y) * ppp.z;\n}\n\nfloat f1(vec3 p) {\n    p = p - vec3(-1.5, 0.0 , 0.0);\n    vec3 pp = p * p;\n    vec3 ppp = pp * p;\n    float a = pp.x + 2.25 * pp.y + pp.z - 1.0;\n    return a * a * a - (pp.x + 0.1125 * pp.y) * ppp.z;\n}\n\nfloat f2(vec3 p) {\n    p = p - vec3(1.5, 0.0 , 0.0);\n    vec3 pp = p * p;\n    vec3 ppp = pp * p;\n    float a = pp.x + 2.25 * pp.y + pp.z - 1.0;\n    return a * a * a - (pp.x + 0.1125 * pp.y) * ppp.z;\n}\n\nfloat bin(float x, float z){\n\tfloat left = 0.0, right = 1.0, mid;\n    for(int i = 0; i < 15; ++i){\n    \tmid = (left + right) * 0.5;\n        if(f(vec3(x, mid, z)) <= 0.0)\n            left = mid;\n        else \n            right = mid;\n    }\n    return mid;\n    \n}\n\n//binary search for intersection\nfloat bin1(float x, float z){\n\tfloat left = 0.0, right = 1.0, mid;\n    for(int i = 0; i < 15; ++i){\n    \tmid = (left + right) * 0.5;\n        if(f1(vec3(x, mid, z)) <= 0.0)\n            left = mid;\n        else \n            right = mid;\n    }\n    return mid;\n    \n}\n\nfloat bin2(float x, float z){\n\tfloat left = 0.0, right = 1.0, mid;\n    for(int i = 0; i < 15; ++i){\n    \tmid = (left + right) * 0.5;\n        if(f2(vec3(x, mid, z)) <= 0.0)\n            left = mid;\n        else \n            right = mid;\n    }\n    return mid;\n    \n}\n\n// Analytical gradient\n// (-2 x z^3+6 x (-1.+x^2+2.25 y^2+z^2)^2) \n// (-0.225 y z^3+13.5 y (-1.+x^2+2.25 y^2+z^2)^2)\n// (z (-3 x^2 z-0.3375 y^2 z+6 (-1.+x^2+2.25 y^2+z^2)^2))\nvec3 normal(vec2 p) {\n    vec3 v = vec3(p.x, bin(p.x, p.y), p.y);\n    vec3 vv = v * v;\n    vec3 vvv = vv * v;\n    float a = -1.0 + dot(vv, vec3(1, 2.25, 1));\n   \ta *= a;\n    \n  \treturn normalize(vec3(\n        -2.0 * v.x * vvv.z +  6.0 * v.x * a,\n      -0.225 * v.y * vvv.z + 13.5 * v.y * a,\n      v.z * (-3.0 * vv.x * v.z - 0.3375 * vv.y * v.z + 6.0 * a)));\n}\n\n//numeric gradient\nvec3 normal1(vec2 p){\n\tvec3 v = vec3(p.x, bin1(p.x, p.y), p.y);\n    float delta = 0.00005;\n    float gradx = (f1(vec3(v.x + delta, v.y, v.z)) - f1(vec3(v.x - delta, v.y, v.z))) / (2.0 * delta);\n    float grady = (f1(vec3(v.x, v.y + delta, v.z)) - f1(vec3(v.x, v.y - delta, v.z))) / (2.0 * delta);\n    float gradz = (f1(vec3(v.x, v.y, v.z + delta)) - f1(vec3(v.x, v.y, v.z - delta))) / (2.0 * delta);\n    return normalize(vec3(gradx, grady, gradz));\n}\n\nvec3 normal2(vec2 p){\n\tvec3 v = vec3(p.x, bin2(p.x, p.y), p.y);\n    float delta = 0.00005;\n    float gradx = (f2(vec3(v.x + delta, v.y, v.z)) - f2(vec3(v.x - delta, v.y, v.z))) / (2.0 * delta);\n    float grady = (f2(vec3(v.x, v.y + delta, v.z)) - f2(vec3(v.x, v.y - delta, v.z))) / (2.0 * delta);\n    float gradz = (f2(vec3(v.x, v.y, v.z + delta)) - f2(vec3(v.x, v.y, v.z - delta))) / (2.0 * delta);\n    return normalize(vec3(gradx, grady, gradz));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 p = vec3((2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x), 0);\n    \n    float s = sin(iTime * 5.0);\n    s *= s;\n    s *= s;\n    s *= 0.08;\n    vec3 tp = p * vec3(1.0 + s, 1.0 - s, 0.0) * 2.0;\n    \n    vec3 c;\n    if (f1(tp.xzy) <= 0.0) {\n        vec3 n = normal1(tp.xy);\n        float diffuse = dot(n, normalize(vec3(-1, 1, 1))) * 0.5 + 0.5;\n        float specular = pow(max(dot(n, normalize(vec3(-1, 2, 1))), 0.0), 32.0);\n        float rim = 1.0 - dot(n, vec3(0.0, 1.0, 0.0));\n        c = diffuse * vec3(1.0, 0.0, 0.0) + specular * vec3(0.8) + rim * vec3(0.5);\n    }\n\telse if (f2(tp.xzy) <= 0.0) {\n        vec3 n = normal2(tp.xy);\n        float diffuse = dot(n, normalize(vec3(-1, 1, 1))) * 0.5 + 0.5;\n        float specular = pow(max(dot(n, normalize(vec3(-1, 2, 1))), 0.0), 32.0);\n        float rim = 1.0 - dot(n, vec3(0.0, 1.0, 0.0));\n        c = diffuse * vec3(1., 0.0, 0.0) + specular * vec3(0.8) + rim * vec3(0.5);\n    }\n    else    c = vec3(1.0, 0.8, 0.7 - 0.07 * p.y) * (1.0 - 0.15 * length(p));\n    \n\tfragColor = vec4(c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/st2SRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 51, 68, 68, 216], [218, 218, 236, 236, 419], [421, 421, 439, 439, 621], [623, 623, 651, 651, 884], [886, 919, 948, 948, 1182], [1184, 1184, 1213, 1213, 1447], [1449, 1624, 1645, 1645, 1983], [1985, 2004, 2025, 2025, 2454], [2456, 2456, 2477, 2477, 2906], [2908, 2908, 2965, 2965, 4033]]}
{"id": "st2SzK", "name": "Maxnorm Distance to Tanglesquare", "author": "oneshade", "description": "Proof of concept (no quartics either, just quadratics!).", "tags": ["2d", "sdf", "distance", "quartic", "maxnorm", "goursat", "tanglesquare", "linf"], "likes": 18, "viewed": 130, "date": "1628135137", "time_retrieved": "2024-06-20T20:48:26.444182", "image_code": "// Almost forgot to link a desmos graph :D\n// https://www.desmos.com/calculator/xybvp7nzpg\n\n// Implicit definition (my own modification of the tanglecube formula here:\n// https://mathworld.wolfram.com/Tanglecube.html):\n// (x^4 + y^4)a + (x^2 + y^2)b + c\nfloat sdTanglesquare(in vec2 p, in float a, in float b, in float c) {\n    p = abs(p); // Quadrant symmetry\n    if (p.y > p.x) p = p.yx; // Diagonal symmetry\n\n    // Upper-right critical point in the top right quadrant \n    vec2 crit = p - vec2(sqrt((-b + sqrt(2.0 * b * b - 4.0 * a * c)) / (2.0 * a)), sqrt(-b / (2.0 * a)));\n    float d = max(abs(crit.x), abs(crit.y));\n\n    // Lower critical point in the top right quadrant\n    if (abs((b * b) / (a * c) - 3.0) < 1.0) {\n        crit = p - vec2(sqrt(-b / (2.0 * a)), sqrt((-b - sqrt(2.0 * b * b - 4.0 * a * c)) / (2.0 * a)));\n        d = min(d, max(abs(crit.x), abs(crit.y)));\n    }\n\n    else {\n        crit = p - vec2(sqrt((-b + sqrt(b * b - 4.0 * a * c)) / (2.0 * a)), 0.0); // Rightmost middle critical point\n        d = min(d, max(abs(crit.x), abs(crit.y)));\n\n        float h = b * b - 4.0 * a * c;\n        if (h > 0.0) {\n            float x = (-b - sqrt(h)) / (2.0 * a);\n            if (x > 0.0) {\n                crit = p - vec2(sqrt(x), 0.0); // Next critical point to the left\n                d = min(d, max(abs(crit.x), abs(crit.y)));\n            }\n        }\n    }\n\n    // Diagonal ray intersection\n    vec2 p2 = p * p, p4 = p2 * p2;\n    float sum1 = p.x + p.y, diff1 = p.x - p.y;\n    float sum2 = p2.x + p2.y, sum4 = p4.x + p4.y;\n\n    // (ux^2 + vx + w)^2 + t = 0 ---> ux^2 + vx + w = (+/-)sqrt(-t)\n    float u = sqrt(2.0 * a);\n    float v = sum1 * u;\n    float w = ((3.0 * sum2 - sum1 * sum1) * a + b) / u;\n    float t = sqrt(w * w - sum4 * a - sum2 * b - c);\n\n    // ux^2 + vx + w = +sqrt(-t)\n    float h = v * v - 4.0 * u * (w - t);\n    float k = 2.0 * u;\n    if (h > 0.0) {\n        h = sqrt(h);\n        d = min(d, min(abs(v - h), abs(v + h)) / k);\n    }\n\n    // ux^2 + vx + w = -sqrt(-t)\n    h = v * v - 4.0 * u * (w + t);\n    if (h > 0.0) {\n        h = sqrt(h);\n        d = min(d, min(abs(v - h), abs(v + h)) / k);\n    }\n\n    // Other diagonal ray intersection\n    v = diff1 * u;\n    w = ((3.0 * sum2 - diff1 * diff1) * a + b) / u;\n    t = sqrt(w * w - sum4 * a - sum2 * b - c);\n\n    // ux^2 + vx + w = +sqrt(-t)\n    h = v * v - 4.0 * u * (w - t);\n    if (h > 0.0) {\n        h = sqrt(h);\n        d = min(d, min(abs(v - h), abs(v + h)) / k);\n    }\n\n    // ux^2 + vx + w = -sqrt(-t)\n    h = v * v - 4.0 * u * (w + t);\n    if (h > 0.0) {\n        h = sqrt(h);\n        d = min(d, min(abs(v - h), abs(v + h)) / k);\n    }\n\n    return d * sign(sum4 * a + sum2 * b + c);\n}\n\n// Critical points visualization SDF\nfloat sdCritical(in vec2 p, in float a, in float b, in float c) {\n    p = abs(p);\n    if (p.y > p.x) p = p.yx;\n\n    float d = length(p - vec2(sqrt((-b + sqrt(2.0 * b * b - 4.0 * a * c)) / (2.0 * a)), sqrt(-b / (2.0 * a))));\n    vec2 crit;\n\n    if (abs((b * b) / (a * c) - 3.0) < 1.0) {\n        crit = vec2(sqrt(-b / (2.0 * a)), sqrt((-b - sqrt(2.0 * b * b - 4.0 * a * c)) / (2.0 * a)));\n        d = min(d, length(p - crit));\n    }\n\n    else {\n        crit = vec2(sqrt((-b + sqrt(b * b - 4.0 * a * c)) / (2.0 * a)), 0.0);\n        d = min(d, length(p - crit));\n\n        float h = b * b - 4.0 * a * c;\n        if (h > 0.0) {\n            float x = (-b - sqrt(h)) / (2.0 * a);\n            if (x > 0.0) {\n                crit = vec2(sqrt(x), 0.0);\n                d = min(d, length(p - crit));\n            }\n        }\n    }\n\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    float time = iTime * 0.5;\n\n    // Default before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(0.5, 0.5 * sin(time)) * cos(time) * 4.0;\n\n    float a = 16.0;\n    float b = -25.0;\n    float c = mix(-1.0, 12.0, 0.5 + 0.5 * cos(iTime));\n    float dist = sdTanglesquare(uv, a, b, c);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(dist) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-2.0 * abs(dist));\n\tcolor *= 0.8 + 0.2 * cos(100.0 * dist);\n\tcolor = mix(color, vec3(1.0), smoothstep(unit, 0.0, abs(dist * 1.25)));\n\n    // Critical points\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, sdCritical(uv, a, b, c) - 0.05));\n\n    // Visualize mouse distance\n    float mDist = abs(sdTanglesquare(mouse, a, b, c));\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - mouse) - 0.025));\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, abs(max(abs(uv.x - mouse.x), abs(uv.y - mouse.y)) - mDist) - 0.001));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/st2SzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[92, 254, 323, 323, 2682], [2684, 2721, 2786, 2786, 3555], [3557, 3557, 3612, 3631, 4852]]}
{"id": "st2XzK", "name": "Matter and Energy", "author": "conceptblend", "description": "Fun.", "tags": ["line", "glow", "harmonics"], "likes": 5, "viewed": 60, "date": "1628138106", "time_retrieved": "2024-06-20T20:48:26.917018", "image_code": "#define radius .3\n#define PI 3.14159265358979\n\n\nfloat sdfLine(vec2 P, vec2 A, vec2 B, float r) {\n    /**\n     * /ht Inigo Quilez\n     * https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n     **/ \n\n    vec2 pa = P-A, ba = B-A;\n    float h = clamp(\n                  dot(pa, ba)/\n                  dot(ba, ba),\n                  0.0,\n                  1.0);\n    /**\n     * Additional calc determine which side of the line we're on.\n     **/\n    vec2 norm = vec2( ba.y, -ba.x );\n    float d = dot( normalize( norm ), pa );\n    \n    /**\n     * Multiply by the sign so we can include 2 pieces\n     * of information in the return value.\n     *   -ve -> \"left side\" of the line\n     *   +ve -> \"right side\" of the line\n     **/\n    return (length(pa-ba*h) - r) * sign(d);\n}\n\nfloat glowBomb(vec2 uv, vec2 A, vec2 B) { \n    float strokeWidth = 0.;//24. * 1./iResolution.x; // Scale by N units of the X resolution\n    float line = sdfLine(uv, A, B, strokeWidth);\n    float lineSide = step(0., line); // Same as: line < 0. ? 0. : 1.;\n\n    return (1. - smoothstep( abs(line)/1.15, 0.0, .075 ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord -.5 * iResolution.xy)/iResolution.y;\n\n    float angle = (iTime + 1.) * .08;\n    \n    vec2 A = vec2(\n         sin(PI * angle * 7.) * radius,\n        -sin(PI * angle * 2.) * radius\n    );\n\n    vec2 B = vec2(\n        -sin(PI * angle * 3.) * radius,\n         sin(PI * angle * 2.) * radius\n    );\n\n    vec2 C = vec2(\n        -sin(PI * angle * 5.) * radius,\n         sin(PI * angle * 2.) * radius\n    );\n\n    vec2 Z = vec2(\n        cos(PI * angle * 2.) * radius * .3,\n        sin(PI * angle * 4.) * radius * .3\n    );\n    \n    vec3 col = vec3(0.);\n\n    float L = glowBomb(uv, Z, A);\n    col += L * vec3(.25, .55, 1.);\n    \n    L = glowBomb(uv, B, Z);\n    col += L * vec3(.75, 1., .88);\n    \n    L = glowBomb(uv, C, Z);\n    col += L * vec3(1., .65, .3);\n\n    col *= .8;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/st2XzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[48, 48, 96, 216, 788], [790, 790, 831, 831, 1106], [1109, 1109, 1166, 1166, 2012]]}
{"id": "stBSDc", "name": "Volumetric and bloom", "author": "TimurAB", "description": "Tried to replicate raymarched volumetric lighting. Don't know, what to do with it, and why it's so slow. Had a lot of fun tho", "tags": ["volumetric"], "likes": 0, "viewed": 51, "date": "1628765690", "time_retrieved": "2024-06-20T20:48:26.917018", "image_code": "float sphere (vec3 point, float r) {\n    return length(point)-r;\n}\n\nfloat cube (vec3 point, float side) {\n    point.x *= 1.5;\n    float _t = -.5 * iTime;\n    point.xz = vec2(\n        point.x * sin(_t) + point.z * cos(_t),\n        point.z * sin(_t) - point.x * cos(_t));\n\tvec3 q = abs(point) - side;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat torus(vec3 point, float r1, float r2) {\n    float _t = iTime;\n    point.xz = vec2(\n        point.x * sin(_t) + point.z * cos(_t),\n        point.z * sin(_t) - point.x * cos(_t));\n\treturn length( vec2(length(point.xy)-r1,point.z) )-r2;\n}\n\nfloat dist (vec3 p) {\n    float far = 2.;\n    float d0 = torus(p - vec3(0,0,far), .3, .15);\n    float d1 = sphere(p - vec3(0,.5 + sin(iTime),far),.15);\n    float d2 = sphere(p - vec3(.7 + .1 * sin(iTime),0,far),.3);\n    float d3 = cube(p - vec3(-.7,-.2,far), .2);\n    \n    float d = min(min(min(d0, d1), d2), d3);\n    \n    return d;\n}\n\nbool intersect (vec3 p, vec3 d) {\n    float d0 = .0, total = .0;\n    for(int i = 0; i < 20; i ++) {\n        vec3 point = p + total * d;\n        d0 = dist(point);\n        total += d0;\n        if (d0 < .01) return true;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2. * fragCoord/iResolution.xy - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy - .5;\n    m *= vec2(1.6, .6);\n    vec3 cam = vec3(m, 0);\n    vec3 dir = normalize(vec3(uv,1));\n    vec3 light = vec3(0,1,50);\n    vec3 col = vec3(.1,.4,1);\n    \n    float b = 0., st = 1.0 / length(light-cam);\n    vec3 l = normalize(light - cam);\n    for(int i = 0; i < 60; i ++) {\n        vec3 p = cam + st * float(i) * dir;\n        if (length(p) > length(light)) break;\n        if (!intersect(p, normalize(light - p))) {\n            b += st * pow(dot(l, dir), 4.);\n        } else col -= .2 * st;\n    }\n    b = smoothstep(0., 1.5, b);\n    col = clamp(col + b, .0, 1.);\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/stBSDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 36, 36, 66], [68, 68, 105, 105, 365], [367, 367, 412, 412, 608], [610, 610, 631, 631, 944], [946, 946, 979, 979, 1189], [1191, 1191, 1248, 1248, 1992]]}
{"id": "stBSWw", "name": "SpaceEYE2", "author": "jj99", "description": "color", "tags": ["fbm"], "likes": 3, "viewed": 154, "date": "1627776768", "time_retrieved": "2024-06-20T20:48:26.917018", "image_code": "float hash( float n )\n{\n    return fract(sin(n)*758.5453)*2.;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x); \n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + p.z*800.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n            mix(mix( hash(n+800.0), hash(n+801.0),f.x), mix( hash(n+857.0), hash(n+858.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm(vec3 p)\n{\n    float f = 0.0;\n    f += 0.50000*noise( p ); p = p*2.02+0.15;\n    f -= 0.25000*noise( p ); p = p*2.03+0.15;\n    f += 0.12500*noise( p ); p = p*2.01+0.15;\n    f += 0.06250*noise( p ); p = p*2.04+0.15;\n    f -= 0.03125*noise( p );\n    //return f/0.984375;\n    return f;\n}\n\nfloat cloud(vec3 p)\n{\n    p-=fbm(vec3(p.x,p.y,0.0)*0.5)*0.7;\n    \n    float a =0.0;\n    a-=fbm(p*3.0)*2.2-1.1;\n    if (a<0.0) a=0.0;\n    a=a*a;\n    return a;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\nvec3 hash33(vec3 p)\n{\n    const float UIF = (1.0/ float(0xffffffffU));\n    const uvec3 UI3 = uvec3(1597334673U, 3812015801U, 2798796415U);\n    uvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n\n// 3D Voronoi- (IQ)\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++)\n    {\n\t    for(int i = -1; i <= 1; i++)\n        {\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t    }\n\t}\n\treturn d;\n}\n\n// fbm layer\nfloat noiseLayers(in vec3 p) {\n\n    vec3 pp = vec3(0., 0., p.z + iTime*.09);\n    float t = 0.;\n    float s = 0.;\n    float amp = 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        t += voronoi(p + pp) * amp;\n        p *= 2.;\n        pp *= 1.5;\n        s += amp;\n        amp *= .5;\n    }\n    return t/s;\n}\n\nvec3 n2 (vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n        float dd = length(uv*uv)*.025;\n    \n\tvec3 rd = vec3(uv.x, uv.y, 1.0);\n    \n    float rip = 0.5+sin(length(uv)*20.0+iTime)*0.5;\n    rip = pow(rip*.38,4.15);\n    rd.z=1.0+rip*1.15;// apply a subtle ripple\n    rd = normalize(rd);\n    rd.xy *= rot(dd+iTime*.0125);\n    rd*=2.0;\n\t\n\tfloat c = noiseLayers(rd*1.85);\n    float oc = c;\n    c = max(c + dot(hash33(rd)*2. - 1., vec3(.006)), 0.);\n    c = pow(c*1.55,2.5);    \n    vec3 col =  vec3(.55,0.85,.25);\n    vec3 col2 =  vec3(1.4,1.4,1.4)*5.0;\n    float pulse2 = voronoi(vec3((rd.xy*1.5),iTime*.255));\n    float pulse = pow(oc*1.35,4.0);\n    col = mix(col,col2,pulse*pulse2)*c;\n    return col;\n\n}\n#define PI 3.14159\n\n\nfloat vDrop(vec2 uv,float t)\n{\nuv.y *= 0.25;\n    uv.x = uv.x*128.0;\t\t\t\t\t\t// H-Count\n    float dx = fract(uv.x);\n    uv.x = floor(uv.x);\n    uv.y *= 0.05;\t\t\t\t\t\t\t// stretch\n    float o=sin(uv.x*215.4);\t\t\t\t// offset\n    float s=cos(uv.x*33.1)*.3 +.7;\t\t\t// speed\n    float trail = mix(95.0,35.0,s);\t\t\t// trail length\n    float yv = fract(uv.y + t*s + o) * trail;\n    yv = 1.0/yv;\n    yv = smoothstep(0.0,1.0,yv*yv);\n    yv = sin(yv*PI)*(s*5.0);\n    float d2 = sin(dx*PI);\n    return yv*(d2*d2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n\tvec2 position = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tfloat ss = sin(length(position*2.2)+time*0.1)*3.5;\n\tss+=8.0;\n   \tvec2 coord = ss*position;\n    \n    coord.y *= 1.0+(sin(time*0.04+coord.x*.24)*0.3);\n    \n    coord*=rot(ss*0.04+time*0.017);\n    coord*=0.25;\n    coord+=fbm(sin(vec3(coord*8.0,time*0.001)))*0.05;\n    coord+=time*0.0171;\n    float q = cloud((vec3(coord*1.0,0.222)));\n    coord+=time*0.0171;\n    q += cloud((vec3(coord*0.6,0.722)));\n    coord+=time*0.0171;\n    q += cloud(vec3(coord*0.3,.722));\n    coord+=time*0.1171;\n    q += cloud((vec3(coord*0.1,0.722)));\n    \n    \n\tfloat vv1 = sin(time+ss+coord.x)*0.3;\n\tfloat vv2 = sin(time*0.9+ss+coord.y)*0.2;\n\n    vec3 col = vec3(1.7-vv2,1.7,1.7+vv1) + vec3(q*vec3(0.7+vv1,0.5,0.3+vv2*1.15));\n\tcol = pow(col,vec3(2.2))*0.08;\n\t\n\tfloat dd = length(col*.48)+vv1;\n\t\n\tfloat nn = 0.5+sin(ss*2.7+position.x*2.41+time*0.9)*0.5;\n\t\n    vec3 col2 = n2(fragCoord)*0.9;\n    \n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float d = length(p);\n\tp = vec2(atan(p.x, p.y) / PI, 2.5 / d);\n    float t = -time*0.04;\n    float drop = vDrop(p,t);\n    drop += vDrop(p,t+0.5);\n    drop*=d;\n    \n        col2+=(col*.965);\n    \n\tcol = mix(col,col2,nn);\n    col = mix(col,col*1.075,drop);\n    \n    col+=col*((d+dd)*0.28);\n    col *= d;\n    \n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/stBSWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 23, 23, 63], [65, 65, 91, 91, 438], [440, 440, 459, 459, 732], [734, 734, 755, 755, 893], [895, 895, 916, 916, 984], [987, 987, 1008, 1008, 1215], [1218, 1238, 1260, 1260, 1657], [1659, 1672, 1702, 1702, 1975], [1977, 1977, 2003, 2003, 2720], [2742, 2742, 2772, 2772, 3234], [3237, 3237, 3294, 3294, 4679]]}
{"id": "stBSzt", "name": "Circlescape [179 chars]", "author": "Xor", "description": "Another cute little circle shader. Definitely room for further golfing!", "tags": ["circles", "tiny", "golf"], "likes": 14, "viewed": 194, "date": "1628347362", "time_retrieved": "2024-06-20T20:48:27.056216", "image_code": "void mainImage(out vec4 O,vec2 I)\n{\n    //Make sure O = vec4(0).\n    O -= O;\n    //Iterate through layers.\n    for(float i=9.,r; i<2e2; i+=9.)\n    {\n        //Compute radius with pseudo randomness.\n        r = i+tan(i);\n        //Layer color and intensity.\n        O += (cos(i+vec4(1,2,3,0))+1.)*i/6e2*\n        //Circle rings.\n        max(0.,2.-abs(length(mod(I+=vec2(r,9)+iTime/.2,r+r)-r)-.8*r));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/stBSzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 35, 64, 405]]}
{"id": "stjSRd", "name": "Raymarching Max Norm Primitives", "author": "TheTurk", "description": "Maximum norm distance functions for some basic 3D shapes ([url]https://www.shadertoy.com/playlist/tX33Rr[/url]).", "tags": ["raymarching", "distancefield", "sdf", "sphere", "distance", "box", "plane", "ellipsoid", "cylinder", "capsule", "linfinity", "maximumnorm"], "likes": 9, "viewed": 143, "date": "1628429293", "time_retrieved": "2024-06-20T20:48:27.056216", "image_code": "float plane(vec3 position, vec3 planeNormal, float planeDistance) {\n    float d = dot(position, planeNormal) + planeDistance;\n    return d / dot(planeNormal, sign(planeNormal));\n}\n\nfloat box(vec3 position, vec3 halfSize) {\n    position = abs(position) - halfSize;\n    return max(max(position.x, position.y), position.z);\n}\n\nfloat sphere(vec3 position, float radius) {\n    position = abs(position);\n    float d = max(max(position.x - radius, position.y), position.z);\n    d = min(d, max(max(position.x, position.y - radius), position.z));\n    d = min(d, max(max(position.x, position.y), position.z - radius));\n    {\n        float b = dot(vec2(1.0), position.yz);\n        float c = dot(position.yz, position.yz) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.x));\n        }\n    }\n    {\n        float b = dot(vec2(1.0), position.xz);\n        float c = dot(position.xz, position.xz) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.y));\n       }\n    }\n    {\n        float b = dot(vec2(1.0), position.xy);\n        float c = dot(position.xy, position.xy) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.z));\n        }\n    }\n    float b = dot(vec3(1.0), position);\n    float c = dot(position, position) - (radius * radius);\n    float discriminant = b * b - 3.0 * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / 3.0;\n        d = min(d, t);\n    }\n    \n    return d;\n}\n\nfloat ellipsoid(vec3 position, vec3 radius) {\n    position = abs(position);\n    float d = max(max(abs(position.x - radius.x), position.y), position.z);\n    d = min(d, max(max(position.x, abs(position.y - radius.y)), position.z));\n    d = min(d, max(max(position.x, position.y), abs(position.z - radius.z)));\n    {\n        float a = dot(vec2(1.0), 1.0 / (radius.yz * radius.yz));\n        float b = dot(vec2(1.0), position.yz / (radius.yz * radius.yz));\n        float c = dot(vec2(1.0), (position.yz * position.yz) / (radius.yz * radius.yz)) - 1.0;\n        float discriminant = b * b - a * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / a;\n            d = min(d, max(t, position.x));\n        }\n    }\n    {\n        float a = dot(vec2(1.0), 1.0 / (radius.xz * radius.xz));\n        float b = dot(vec2(1.0), position.xz / (radius.xz * radius.xz));\n        float c = dot(vec2(1.0), (position.xz * position.xz) / (radius.xz * radius.xz)) - 1.0;\n        float discriminant = b * b - a * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / a;\n            d = min(d, max(t, position.y));\n       }\n    }\n    {\n        float a = dot(vec2(1.0), 1.0 / (radius.xy * radius.xy));\n        float b = dot(vec2(1.0), position.xy / (radius.xy * radius.xy));\n        float c = dot(vec2(1.0), (position.xy * position.xy) / (radius.xy * radius.xy)) - 1.0;\n        float discriminant = b * b - a * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / a;\n            d = min(d, max(t, position.z));\n        }\n    }\n    float a = dot(vec3(1.0), 1.0 / (radius * radius));\n    float b = dot(vec3(1.0), position / (radius * radius));\n    float c = dot(vec3(1.0), (position * position) / (radius * radius)) - 1.0;\n    float discriminant = b * b - a * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / a;\n        d = min(d, t);\n    }\n    return d;\n}\n\nfloat cylinder(vec3 position, float radius, float halfHeight) {\n    position = abs(position);\n    float d = max(position.x - radius, position.z);\n    d = min(d, max(position.x, position.z - radius));\n    float b = dot(vec2(1.0), position.xz);\n    float c = dot(position.xz, position.xz) - (radius * radius);\n    float discriminant = b * b - 2.0 * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / 2.0;\n        d = min(d, t);\n    }\n    d = max(d, position.y - halfHeight);\n    return d;\n}\n\nfloat capsule(vec3 position, float radius, float halfHeight) {\n    position = abs(position);\n    position.y -= halfHeight - radius;\n    float d = max(max(position.x - radius, position.y), position.z);\n    d = min(d, max(max(position.x, position.y - radius), position.z));\n    d = min(d, max(max(position.x, position.y), position.z - radius));\n    {\n        float b = dot(vec2(1.0), position.yz);\n        float c = dot(position.yz, position.yz) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.x));\n        }\n    }\n    {\n        float b = dot(vec2(1.0), position.xz);\n        float c = dot(position.xz, position.xz) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.y));\n       }\n    }\n    {\n        float b = dot(vec2(1.0), position.xy);\n        float c = dot(position.xy, position.xy) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.z));\n        }\n    }\n    float b = dot(vec3(1.0), position);\n    float c = dot(position, position) - (radius * radius);\n    float discriminant = b * b - 3.0 * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / 3.0;\n        d = min(d, t);\n    }\n    return d;\n}\n\nmat3 rotationMatrixAxisAngle(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    vec3 column1 = axis * axis.x * (1.0 - c) + vec3(c, axis.z * s, -axis.y * s);\n    vec3 column2 = axis * axis.y * (1.0 - c) + vec3(-axis.z * s, c, axis.x * s);\n    vec3 column3 = axis * axis.z * (1.0 - c) + vec3(axis.y * s, -axis.x * s, c);\n    return mat3(column1, column2, column3);\n}\n\nmat3 lookAtMatrix(vec3 from, vec3 to) {\n    vec3 forward = normalize(to - from);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nvec4 sdf(vec3 position) {\n    float material = 0.0;\n    float d = plane(position, vec3(0.0, 1.0, 0.0), 0.0);\n    float d1 = box(position - vec3(-4.0, 0.5, 0.0), vec3(0.5, 0.5, 0.5));\n    if (d1 < d) {\n        material = 1.0;\n        d = d1;\n    }\n    float d2 = cylinder(position - vec3(-2.0, 0.5, 0.0), 0.5, 0.5);\n    if (d2 < d) {\n        material = 2.0;\n        d = d2;\n    }\n    float d3 = capsule(position - vec3(0.0, 0.6, 0.0), 0.3, 0.6);\n    if (d3 < d) {\n        material = 3.0;\n        d = d3;\n    }\n    float d4 = sphere(position - vec3(2.0, 0.5,  0.0), 0.5);\n    if (d4 < d) {\n        material = 4.0;\n        d = d4;\n    }\n    float d5 = ellipsoid(position - vec3(4.0, 0.5, 0.0), vec3(0.75, 0.5, 0.5));\n    if (d5 < d) {\n        material = 5.0;\n        d = d5;\n    }\n    return vec4(d, material, 0.0, 0.0);\n}\n\nvec3 normal(vec3 position) {\n    float epsilon = 0.001;\n    vec3 gradient = vec3(\n        sdf(position + vec3(epsilon, 0, 0)).x - sdf(position + vec3(-epsilon, 0, 0)).x,\n        sdf(position + vec3(0, epsilon, 0)).x - sdf(position + vec3(0, -epsilon, 0)).x,\n        sdf(position + vec3(0, 0, epsilon)).x - sdf(position + vec3(0, 0, -epsilon).x)\n    );\n    return normalize(gradient);\n}\n\nfloat shadow(vec3 rayOrigin, vec3 rayDirection) {\n    int stepCount = 64;\n    float t = 0.03;\n    float maximumDistance = 20.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d = sdf(currentPosition).x;\n        if (d < 0.001) {\n            return 0.0;\n        }\n        t += d;\n    }\n    return 1.0;\n}\n\nvec4 raycast(vec3 rayOrigin, vec3 rayDirection) {\n    vec4 hitResult = vec4(0.0, 0.0, 0.0, 0.0);\n    int stepCount = 256;\n    float maximumDistance = 20.0;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        vec4 result = sdf(currentPosition);\n        if (result.x < 0.001) {\n            hitResult = vec4(t, result.y, 0.0, 0.0);\n            break;\n        }\n        t += result.x;\n    }\n    return hitResult;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv * 2.0) - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 mousePosition = iMouse.xy / iResolution.xy;\n\n    vec3 targetPosition = vec3(0.0, 0.0, 0.0);\n    float angle = sin(iTime * 0.2) * 1.0;\n    vec3 rayOrigin = targetPosition + vec3(5.0 * sin(angle + 2.0 * -mousePosition.x), 2.0 - 2.0 * mousePosition.y, 5.0 * cos(angle + 2.0 * -mousePosition.x));\n    vec3 rayDirection = normalize(vec3(uv, 2.5));\n    mat3 cameraTransform = lookAtMatrix(rayOrigin, targetPosition);\n    rayDirection = cameraTransform * rayDirection;\n   \n    vec3 color = mix(vec3(1.0), vec3(0.25, 0.5, 1.0) * 1.2, (rayDirection.y + 0.3) * 2.0);\n\n    vec4 hitResult = raycast(rayOrigin, rayDirection);\n    float t = hitResult.x;\n    float material = hitResult.y;\n    if (t > 0.0) {\n        vec3 position = rayOrigin + rayDirection * t;\n        vec3 lightDirection = normalize(vec3(-0.5, 0.8, 0.2));\n        vec3 n = normal(position);\n        float shadowAttenuation = shadow(position, lightDirection);\n        \n        float diffuseAngle = max(dot(n, lightDirection), 0.0);\n        vec3 halfwayDirection = normalize(lightDirection + -rayDirection);\n        float specularAngle = pow(max(dot(n, halfwayDirection), 0.0), 16.0);\n        \n        vec3 baseColor = vec3(0.2);\n        if (material == 0.0) {\n            float checkerboard = mod(floor(2.0 * position.z) + floor(2.0 * position.x), 2.0);\n            baseColor += vec3(0.1) * checkerboard;\n        } else {\n            baseColor = 0.2 + 0.2 * cos(6.28318 * (vec3(1.0, 1.0, 1.0) * (material / 6.0) + vec3(0.0, 0.33, 0.67)));\n        }\n        \n        // diffuse\n        color = 2.0 * vec3(1.0, 0.85, 0.55) * diffuseAngle * shadowAttenuation * baseColor;\n        // specular\n\t\tcolor += 1.0 * vec3(1.0, 0.85, 0.55) * specularAngle * diffuseAngle * shadowAttenuation * baseColor;\n        // ambient\n        color += 0.5 * vec3(0.25, 0.5, 1.0) * ((n.y + 1.0) * 0.5) * baseColor; // sky\n        color += 0.5 * vec3(0.25, 0.25, 0.25) * clamp(dot(n, normalize(vec3(-lightDirection.x, 0.0, -lightDirection.z))), 0.0, 1.0) * clamp(1.0 - position.y, 0.0, 1.0) * baseColor; // back\n        // fog\n        color = mix(color, vec3(0.7, 0.7, 0.9), 1.0 - exp(-0.0001 * t * t * t));\n    }\n    // gamma\n    color = pow(color, vec3(0.4545));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/stjSRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 67, 67, 179], [181, 181, 222, 222, 322], [324, 324, 367, 367, 1830], [1832, 1832, 1877, 1877, 3786], [3788, 3788, 3851, 3851, 4304], [4306, 4306, 4368, 4368, 5865], [5867, 5867, 5921, 5921, 6262], [6264, 6264, 6303, 6303, 6485], [6487, 6487, 6512, 6512, 7306], [7308, 7308, 7336, 7336, 7693], [7695, 7695, 7744, 7744, 8130], [8132, 8132, 8181, 8181, 8684], [8686, 8686, 8741, 8741, 11095]]}
{"id": "stjSRG", "name": "Tire tracks", "author": "jarble", "description": "This fractal looks like tire tracks in the sand.\n", "tags": ["procedural", "fractal", "terrain", "desert", "erosion"], "likes": 1, "viewed": 121, "date": "1627960742", "time_retrieved": "2024-06-20T20:48:28.050399", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\n\n//increase this constant to increase the amount of erosion\n#define OCTAVES 5\n\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    float value = 0.;\n    float factor = 5.;\n    uv *= factor;\n    //uv = uv.yx;\n    for (int i = 0; i < OCTAVES; i++)\n    {\n        uv.x *= factor;\n        uv += max(sin(uv*factor)/factor,cos(uv/factor)*factor);\n        value = min(value,sin((uv.x-uv.y-value))/factor);\n        uv.y /= factor;\n\n        uv= -uv.yx/(factor);\n        //factor /= 1.5;\n        value /= 1.5;\n    }\n    \n    return value+.5;\n}\n\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    float factor = 3.0;\n    return fbm(uv/factor)*factor;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*iTime);\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 0.05;\n    #endif\n    \n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/stjSRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[411, 489, 512, 561, 967], [1041, 1041, 1079, 1079, 1139], [1141, 1141, 1174, 1174, 1394], [1396, 1396, 1434, 1434, 1661], [1663, 1663, 1701, 1701, 1925], [1927, 1927, 1956, 1956, 2051], [2053, 2053, 2090, 2090, 2149], [2152, 2220, 2239, 2239, 2278], [2280, 2280, 2300, 2300, 2376], [2378, 2378, 2397, 2397, 2436], [2438, 2438, 2495, 2495, 2730], [2732, 2732, 2767, 2767, 3161], [3163, 3163, 3217, 3217, 3883], [3886, 3886, 3938, 3938, 4373], [4375, 4375, 4432, 4432, 5623]]}
{"id": "stjSRV", "name": "Shattered light", "author": "conceptblend", "description": "More fun.", "tags": ["lines", "glow", "harmonics"], "likes": 0, "viewed": 44, "date": "1628138647", "time_retrieved": "2024-06-20T20:48:28.511117", "image_code": "#define radius .3\n#define PI 3.14159265358979\n\n\nfloat sdfLine(vec2 P, vec2 A, vec2 B, float r) {\n    /**\n     * /ht Inigo Quilez\n     * https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n     **/ \n\n    vec2 pa = P-A, ba = B-A;\n    float h = clamp(\n                  dot(pa, ba)/\n                  dot(ba, ba),\n                  0.0,\n                  1.0);\n    /**\n     * Additional calc determine which side of the line we're on.\n     **/\n    vec2 norm = vec2( ba.y, -ba.x );\n    float d = dot( normalize( norm ), pa );\n    \n    /**\n     * Multiply by the sign so we can include 2 pieces\n     * of information in the return value.\n     *   -ve -> \"left side\" of the line\n     *   +ve -> \"right side\" of the line\n     **/\n    return (length(pa-ba*h) - r) * sign(d);\n}\n\nfloat glowBomb(vec2 uv, vec2 A, vec2 B) { \n    float strokeWidth = 0.;//24. * 1./iResolution.x; // Scale by N units of the X resolution\n    float line = sdfLine(uv, A, B, strokeWidth);\n    float lineSide = step(0., line); // Same as: line < 0. ? 0. : 1.;\n    \n    return (1. - smoothstep( abs(line)/1.15, 0.0, .075 )) * lineSide;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord -.5 * iResolution.xy)/iResolution.y;\n\n    float angle = (iTime + 1.) * .08;\n    \n    vec2 A = vec2(\n         sin(PI * angle * 7.) * radius,\n        -sin(PI * angle * 2.) * radius\n    );\n\n    vec2 B = vec2(\n        -sin(PI * angle * 3.) * radius,\n         sin(PI * angle * 2.) * radius\n    );\n\n    vec2 C = vec2(\n        -sin(PI * angle * 5.) * radius,\n         sin(PI * angle * 2.) * radius\n    );\n\n    vec2 Z = vec2(\n        cos(PI * angle * 2.) * radius * .3,\n        sin(PI * angle * 4.) * radius * .3\n    );\n    \n    vec3 col = vec3(0.);\n\n    float L = glowBomb(uv, Z, A);\n    col += L * vec3(.25, .55, 1.);\n    \n    L = glowBomb(uv, B, Z);\n    col += L * vec3(.75, 1., .88);\n    \n    L = glowBomb(uv, C, Z);\n    col += L * vec3(1., .65, .3);\n\n    col *= .8;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/stjSRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[48, 48, 96, 216, 788], [790, 790, 831, 831, 1121], [1124, 1124, 1181, 1181, 2027]]}
{"id": "stjSRy", "name": "Anti-aliased rectangle+rotation", "author": "modesty", "description": "anti-aliased shape", "tags": ["antialiasing"], "likes": 2, "viewed": 144, "date": "1628002124", "time_retrieved": "2024-06-20T20:48:28.741421", "image_code": "mat2 rotate2D(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co, -si, si, co);\n}\n\nfloat sdBox(in vec2 p, in vec2 size) {\n    p = abs(p) - size;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y)); // + min(0.0, max(p.x,p.y) to corrent\n                                                        // inretior distance which would otherwise\n                                                        // be zero\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    float aaWidth = 8.0 / iResolution.y; // Pixel width in normalized coordinates (x2 to make it smoother);\n    \n    vec3 color = vec3(1.0);\n    \n    uv *= rotate2D(iTime);\n    \n    float box = sdBox(uv, vec2(0.3, 0.3));\n    box = max(box, -sdBox(uv, vec2(0.15, 0.1))); // \"carve\" out some of the interior \n    \n    // Use smoothstep(aa width, 0.0, distance) to smoothly blend onto the background\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(aaWidth, 0.0, box));\n    color = mix(color, vec3(0.0), smoothstep(aaWidth, 0.0, abs(box) - 0.001)); // edges\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/stjSRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 27, 27, 99], [101, 101, 139, 139, 426], [428, 428, 485, 485, 1156]]}
{"id": "stjSzV", "name": "MRR_SoftShadow", "author": "MiguelRodRic", "description": "Casting soft shadows from a raymarched sphere using basic cone tracing", "tags": ["raymarching", "softshadows"], "likes": 0, "viewed": 50, "date": "1628146904", "time_retrieved": "2024-06-20T20:48:29.274783", "image_code": "#define MAXSTEPS 100\n#define MAXDISTANCE 100.0\n#define HITDISTANCE 0.01\n#define SURFACEOFFSET 0.1\n#define HSHADOWSAMPLES 8\n#define SAMPLINGWEIGHT 0.00390625  \n//SAMPLINGWEIGHT == 1 / (HSHADOWSAMPLES * 2 * HSHADOWSAMPLES * 2)\n#define SHADOWOFFSET 0.015\n\nfloat GetDistanceToSphere(vec3 point, vec3 center, float radius)\n{\n    float distance = length(point - center.xyz) - radius;\n    return distance;\n}\n\nfloat GetDistance(vec3 point)\n{\n    vec4 sphere = vec4(0.0, 1.0, 6.0, 1.0);\n    float planeDistance = point.y; //Plane is axis-aligned with y = 0\n    \n    float sphereDistance = GetDistanceToSphere(point, sphere.xyz, sphere.w);\n    \n    float distance = min(sphereDistance, planeDistance);\n    \n    return distance;\n}\n\nfloat RayMarch(vec3 rOrigin, vec3 rDirection)\n{\n    float distanceFromOrigin = 0.0;\n    \n    for(int i = 0; i < MAXSTEPS; ++i)\n    {\n        vec3 p = rOrigin + rDirection * distanceFromOrigin;\n        float distanceToScene = GetDistance(p);\n        distanceFromOrigin += distanceToScene;\n        \n        if (distanceFromOrigin > MAXDISTANCE || distanceToScene < HITDISTANCE) break;\n    }\n    \n    return distanceFromOrigin;\n}\n\nvec3 GetNormal(vec3 point)\n{\n    float distance = GetDistance(point);\n    vec2 offset = vec2(0.01, 0.0);\n    \n    vec3 normal = distance - vec3(GetDistance(point - offset.xyy), GetDistance(point - offset.yxy),  GetDistance(point - offset.yyx));\n        \n    return  normalize(normal);\n}\n\nfloat GetLight(vec3 point)\n{\n    vec3 lightPosition = vec3(3.0 * sin(iTime), 4.5, 5.0 + cos(iTime) * 3.0);\n    vec3 lightDirection = normalize(lightPosition - point);\n    vec3 surfaceNormal = GetNormal(point);\n    \n    float diffuse = clamp(dot(surfaceNormal, lightDirection), 0.0, 1.0);\n    \n    float shadow = 0.0;\n    \n    //Basic Cone Tracing\n    for (int x = -HSHADOWSAMPLES; x < HSHADOWSAMPLES; ++x)\n    {\n        for (int z = -HSHADOWSAMPLES; z < HSHADOWSAMPLES; ++z)\n        {\n            float shadowRay = RayMarch(point  + (surfaceNormal * SURFACEOFFSET), vec3(lightDirection.x + (float(x) * SHADOWOFFSET), lightDirection.y, lightDirection.z + (float(z) * SHADOWOFFSET)));\n            shadow += float(step(shadowRay, length(lightPosition - point)));\n        }\n    }\n    \n    shadow *= SAMPLINGWEIGHT;\n        \n    diffuse -= shadow * 0.9;\n    \n    return diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 rOrigin = vec3(0.0, 5.0, 0.0);\n    vec3 rDirection = normalize(vec3(uv.x, uv.y - 0.7, 1.0));\n\n    float d = RayMarch(rOrigin, rDirection);\n\n    vec3 point = rOrigin + rDirection * d;\n    \n    float diffuseLight = GetLight(point);\n    \n    vec3 col = vec3(diffuseLight);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/stjSzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[159, 253, 319, 319, 400], [402, 402, 433, 433, 719], [721, 721, 768, 768, 1147], [1149, 1149, 1177, 1177, 1435], [1437, 1437, 1465, 1465, 2312], [2314, 2314, 2371, 2421, 2829]]}
{"id": "stjSzy", "name": "Sphere (Max Norm Distance)", "author": "TheTurk", "description": "Maximum norm distance function for a sphere.", "tags": ["distancefield", "sdf", "sphere", "circle", "distance", "linfinity", "maximumnorm"], "likes": 3, "viewed": 73, "date": "1627992150", "time_retrieved": "2024-06-20T20:48:30.141395", "image_code": "/* \nTo compute the maximum norm distance between a point p and a \nprimitive we need to find the size of the smallest \naxis-aligned cube (compared to the size of the smallest \nsphere under Euclidian norm) centered at p that touches the \nsurface of the primitive. There are usually three cases that \nneed to be handled depending on whether the point that \ntouches the surface of the primitive lies on a corner, edge \nor face of the cube.\n*/\n\nfloat circle(vec2 position, float radius) {\n    position = abs(position);\n    float d = max(position.x - radius, position.y);\n    d = min(d, max(position.x, position.y - radius));\n    float b = dot(vec2(1.0), position);\n    float c = dot(position, position) - (radius * radius);\n    float discriminant = b * b - 2.0 * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / 2.0;\n        d = min(d, t);\n    }\n    return d;\n}\n\n// alternative geometric version\nfloat circle2(vec2 position, float radius) {\n    position = abs(position);\n    if (position.x < position.y - radius || position.y < position.x - radius) {\n        return max(position.x, position.y) - radius;\n    }\n    float p = dot(position, vec2(0.5));\n    float q = dot(position, position) * 0.5 - p * p;\n    float h = sqrt(radius * radius * 0.5 - q); \n    return p - h;\n}\n\nfloat sphere(vec3 position, float radius) {\n    position = abs(position);\n\n    // closest point lies on cube face\n    float d = max(max(position.x - radius, position.y), position.z);\n    d = min(d, max(max(position.x, position.y - radius), position.z));\n    d = min(d, max(max(position.x, position.y), position.z - radius));\n    \n    // closest point lies on cube edge\n    {\n        float b = dot(vec2(1.0), position.yz);\n        float c = dot(position.yz, position.yz) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.x));\n        }\n    }\n    \n    // closest point lies on cube edge\n    {\n        float b = dot(vec2(1.0), position.xz);\n        float c = dot(position.xz, position.xz) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.y));\n       }\n    }\n    \n    // closest point lies on cube edge\n    {\n        float b = dot(vec2(1.0), position.xy);;\n        float c = dot(position.xy, position.xy) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.z));\n        }\n    }\n\n    // closest point lies on cube corner\n    float b = dot(vec3(1.0), position);\n    float c = dot(position, position) - (radius * radius);\n    float discriminant = b * b - 3.0 * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / 3.0;\n        d = min(d, t);\n    }\n    \n    return d;\n}\n\n// alternative geometric version\nfloat sphere2(vec3 position, float radius) {\n    position = abs(position);\n\n    // closest point lies on cube face\n    if (position.y < position.x - radius && position.z < position.x - radius) {\n        return position.x - radius;\n    }\n    // closest point lies on cube face\n    if (position.x < position.y - radius && position.z < position.y - radius) {\n        return position.y - radius;\n    }\n    // closest point lies on cube face\n    if (position.x < position.z - radius && position.y < position.z - radius) {\n        return position.z - radius;\n    }\n\n    // closest point lies on cube edge\n    if (position.x < position.y && position.x < position.z) {\n        float p = dot(position.yz, vec2(0.5));\n        float q = dot(position.yz, position.yz) * 0.5 - p * p;\n        float h = sqrt(radius * radius * 0.5 - q); \n        float a = p - h;\n        if (position.x < a) {\n           return a;\n        }\n    }\n    // closest point lies on cube edge\n    if (position.y < position.x && position.y < position.z) {\n        float p = dot(position.xz, vec2(0.5));\n        float q = dot(position.xz, position.xz) * 0.5 - p * p;\n        float h = sqrt(radius * radius * 0.5 - q); \n        float a = p - h;\n        if (position.y < a) {\n            return a;\n        }\n    }\n    // closest point lies on cube edge\n    if (position.z < position.x && position.z < position.y) {\n        float p = dot(position.xy, vec2(0.5));\n        float q = dot(position.xy, position.xy) * 0.5 - p * p;\n        float h = sqrt(radius * radius * 0.5 - q); \n        float a = p - h;\n        if (position.z < a) {\n           return a;\n        } \n    }\n\n    // closest point lies on cube corner\n    vec3 rayDirection = vec3(sqrt(1.0 / 3.0));\n    float p = dot(position, rayDirection);\n    float q = dot(position, position) - p * p;\n    float h = sqrt(radius * radius - q); \n    float c = p - h;\n    float a = c * sqrt(1.0 / 3.0);\n    return a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = fragCoord / iResolution.xy;\n    position = (position * 2.0) - 1.0;\n    position.x *= iResolution.x / iResolution.y;\n    \n    vec2 mousePosition = iMouse.xy / iResolution.xy;\n    mousePosition = (mousePosition * 2.0) - 1.0;\n    mousePosition.x *= iResolution.x / iResolution.y;\n      \n    float z = (-1.0 + fract(iTime * 0.2) * 2.0) * 0.6;\n    float radius = 0.5;\n    // float d = circle(position, 0.5);\n    float d = sphere(vec3(position, z), radius);\n\n    // same colorization that Inigo Quilez uses in his shaders\n    vec3 color = vec3(1.0, 0.9, 1.0) + sign(d) * vec3(-0.3, 0.4, 0.3); // base color\n    color *= 1.0 - exp(-3.0 * abs(d)); // gradient\n\tcolor *= 0.8 + 0.2 * cos(180.0 * d); // ripples\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d))); // outline\n    fragColor = vec4(color, 1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/stjSzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 440, 483, 483, 886], [888, 921, 965, 965, 1295], [1297, 1297, 1340, 1340, 3018], [3020, 3053, 3097, 3097, 4972], [4974, 4974, 5029, 5029, 5866]]}
{"id": "stjXRK", "name": "Looping Rings", "author": "nbardy", "description": "Twisted tourii", "tags": ["torus", "twisted"], "likes": 0, "viewed": 57, "date": "1628123102", "time_retrieved": "2024-06-20T20:48:30.886916", "image_code": "// Author: Nicholas Bardy\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// This shader is forked from:\n// \"Torus Knot Tutorial\" \n// Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// https://youtu.be/2dzJZx0yngg\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBox2d(vec2 p, vec2 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, p.y), 0.);\n}\n\nfloat GetDist(vec3 p) {\n    float r1 = 2.9, r2=.4;\n    vec2 cp = vec2(length(p.xz)-r1, p.y);\n    float a = atan(p.x, p.z); // polar angle between -pi and pi\n    cp *= Rot(a*0.5 + iTime*0.5);\n    cp = abs(cp.xy)-.8;\n    \n    float d = length(cp)-r2;\n    \n    cp *= Rot(a*1.25-iTime*1.0);\n    cp.xy = abs(cp.xy)-.235;\n\n    \n    float d2 = length(cp)-0.17;\n    d = min(d,d2);\n    \n    //cp = abs(cp.xy)-.1;\n    \n    //float d = length(cp)-r2;\n    \n    return d*0.6;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvec3 Bg(vec3 rd) {\n\tfloat k = rd.y*.5+.5;\n    \n    vec3 col = mix(vec3(.2, .1, .1), vec3(.2, .5, 1), k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0.01, 10, 0);\n    //ro.yz *= Rot(sin(iTime*.1)*3.1415/2.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n\t\n    col += Bg(rd);\n    \n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        \n        float spec = pow(max(0., r.y), 30.);\n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \tcol = mix(Bg(r), vec3(dif), .5)+spec;\n        //col = vec3(spec);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/stjXRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 352, 371, 371, 437], [439, 439, 461, 461, 555], [557, 557, 586, 586, 667], [669, 669, 700, 700, 771], [773, 773, 796, 796, 1237], [1239, 1239, 1273, 1273, 1484], [1486, 1486, 1510, 1510, 1700], [1702, 1702, 1752, 1752, 1943], [1946, 1946, 1964, 1964, 2068], [2070, 2070, 2127, 2127, 2872]]}
{"id": "stjXWV", "name": "short infinite maze", "author": "FabriceNeyret2", "description": "WIP.\nTrying to mimick infinite zoom of https://www.shadertoy.com/view/fl2SDV\nwith the 65 chars procedural base of https://shadertoy.com/view/lt2cRR\nOf course I miss LOD connections + auto-solve", "tags": ["maze", "short", "golf"], "likes": 10, "viewed": 199, "date": "1628699905", "time_retrieved": "2024-06-20T20:48:31.056611", "image_code": "// Trying to mimick infinite zoom of https://www.shadertoy.com/view/fl2SDV\n// with the procedural base of \"shortest maze 5 (65 chars)\" https://shadertoy.com/view/lt2cRR\n\nvoid mainImage(out vec4 O, vec2 u) {\n\n    float s = .33 + .67* exp2( mod(iTime,2.) ), k = 1., z = 0.;\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y / s, I,V;\n          \n    for ( O-=O; z < 5.; U*=3., k*=3., z++ )         // fractal levels\n       I = floor(abs(U/1.5)+.5),\n       max(I.x,I.y) == 1.?                          // draw maze tile\n            V = ( U+z+floor(iTime/2.) ) *16. + 4.,  // offset level seed\n            O += mod( V [ int( 1e4*length(ceil(V/8.)) ) % 2 ] , 8. ) *s/k *R.y/72. :O;\n}               // heart of base golfed maze                         // 1 pixel width", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/stjXWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 170, 206, 206, 689]]}
{"id": "stjXzt", "name": "ancient horology", "author": "sukupaper", "description": "An advanced piece of technology from an ancient civilisation with some odd glyphs..\n\nI just wanted to make my own procedural glyphs generator, and it ended up like that", "tags": ["2d", "sdf", "abstract", "ancient", "horology", "astrology"], "likes": 17, "viewed": 101, "date": "1628424247", "time_retrieved": "2024-06-20T20:48:31.632432", "image_code": "// Author: paperu\n// Title: ancient horology\n\n#define P 6.283185307\n\nfloat t;\nmat2 rot(in float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat c(vec2 p, float s) { return length(p) - s; }\nconst int NS = 7;\nfloat S[NS];\n\nfloat mask(vec2 p) { p = abs(p) - .5; return max(p.x,p.y); }\n\nfloat a0(vec2 p) { p = abs(p) - 0.320; return max(c(p, 0.300),-c(p + -0.296, 0.658)); }\nfloat a1(vec2 p) { return max(c(p, .35),-c(p + -0.104, 0.250)); }\nfloat a2(vec2 p) { p = -p; return max(c(p, .35),-min(c(p + -0.104, 0.250),c(p + 0.120, 0.114)));}\nfloat a3(vec2 p) { p = p.yx; float px = p.x;p.x = abs(p.x);p.y -= sign(px)*-.1; return max(c(p, 0.230),-c(p +vec2(1,0)*0.096, .25)); }\nfloat a4(vec2 p) { vec2 pp = p; float px = p.x;p.x = abs(p.x);p.y -= sign(px)*-0.1; return min(c(pp,0.068), max(c(p, 0.230),-c(p +vec2(1,0)*0.096, .25))); }\nfloat a5(vec2 p) { vec2 pp = -p*1.624 + 0.172; pp *=rot(step(.24,length(pp))*5.504 + t*P/5.);return min(max(c(pp, .35),-c(vec2(abs(pp))-0.200, 0.210))/1.624, max(c(p, .35),-c(p + -0.104, 0.250))); }\nfloat a6(vec2 p) {\n    vec2 pp = p.yx*rot(-0.096)*2. + vec2(-0.250,0.010);\n    return min(\n        max(abs(c(p -  vec2(0.,.045),0.285)) - 0.042, abs(c(p + vec2(0.,.045),0.285)) - 0.042),\n        max(abs(c(pp - vec2(0.,.045),0.285)) - 0.042, abs(c(pp + vec2(0.5,0.),0.277)) - 0.042)\n    );\n}\n\nfloat shapesGen(vec2 p) {\n    const vec2 s = vec2(0.,1.);\n    S[0] = a0(p);\n    S[1] = a1(p+s*1.);\n    S[2] = a2(p+s*2.);\n    S[3] = a3(p+s*3.);\n    S[4] = a4(p+s*4.);\n    S[5] = a5(p+s*5.);\n    S[6] = a6(p+s*6.);\n    \n    float d = S[0];\n    for(int i = 1; i < NS; i++)\n        d = min(d, S[i]);\n    \n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = (fragCoord.xy - iResolution.xy*.5)/iResolution.y;\n    float aa = 1./iResolution.x;\n    \n    t = P*.515 + iTime;\n    \n    float scale1 = 20.;\n    vec2 p1 = st*scale1;\n    p1 += t*.5;\n    p1 = vec2(mod(p1.x, 1.) - .5, mod(floor(p1.x)*2.5 + p1.y, float(NS)) - float(NS) + .5);\n    float d_bg = shapesGen(p1);\n    d_bg = abs(d_bg) - .005;\n    d_bg /= scale1;\n    \n    float scale2 = 5.;\n    float nb = 7.;\n    vec2 ptemp = st;\n    float rot_s = -P/20.;\n    ptemp *= rot(t*rot_s);\n    float a = floor((atan(ptemp.x,ptemp.y)/P + .5)*nb);\n    float a_2 = (a/nb)*P + (P/nb)/2.;\n    float kk = (cos(-t*rot_s + a*3.5)*.5+.5)*1.;\n    ptemp *= scale2;\n    vec2 p2 = ptemp + vec2(sin(a_2),cos(a_2)) *(1.785 - kk*kk*kk*kk*kk*kk*kk*5.);\n    p2 *= rot(-t*rot_s);\n    \n    float d_ft = shapesGen(p2 + vec2(0.,-a));\n    d_ft = max(d_ft,mask(p2));\n    d_ft = max(d_ft, -c(ptemp, 1.436));\n    \n    p2 *= rot(t*rot_s - a_2);\n    float lines = max(abs(p2.x) - .01, -p2.y);\n    lines = max(-lines, (abs(c(ptemp, 1.300)) - 0.044));\n    d_ft = min(d_ft, lines);\n    \n    float d_ft2 = (abs(d_ft + .02)) - 0.01;\n    d_ft = max(d_ft, -d_ft2);\n    d_ft /= scale2;\n    \n    vec2 p = st;\n    \n    float S = 1.5;\n    p *= S;\n    float s = 0.408;\n    float d_set = a1(p);\n    s = 1.6;\n    float pdlm = cos(P*t*.25)*.5;\n    p = (p - .1)*s*rot(pdlm);\n    d_set = min(d_set, a2(p)/s);\n    float t_s = 1.72;\n    d_set = min(d_set, a5((p + .1)*t_s*rot(-pdlm))/s/t_s);\n    t_s = 4.;\n    d_set = min(d_set, a6((p - .12)*t_s*rot(-pdlm))/s/t_s);\n    d_set /= S;\n    d_set = max(d_set, -(abs(d_set + .005) - 0.002));\n    \n    float d = -min(d_bg, (d_ft));\n    d = max(d, -d_set);\n    \n    vec3 c = d == -d_set ? vec3(1.)\n        : d == -d_ft ? mix(vec3(0.880,0.584,0.077),vec3(1.000,0.994,0.000),st.y+.5)\n        : vec3(0.208,0.171,0.335);\n    vec3 color = smoothstep(-aa,aa, d)*c;\n    \n    float l = length(st);\n    fragColor = vec4(color - l*l*l*.3,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/stjXzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 78, 100, 100, 145], [146, 146, 172, 172, 196], [229, 229, 249, 249, 289], [291, 291, 309, 309, 378], [379, 379, 397, 397, 444], [445, 445, 463, 463, 542], [543, 543, 561, 561, 677], [678, 678, 696, 696, 834], [835, 835, 853, 853, 1033], [1034, 1034, 1052, 1052, 1324], [1326, 1326, 1351, 1351, 1643], [1645, 1645, 1700, 1700, 3631]]}
{"id": "stSSR3", "name": "Helix Cubes", "author": "lambmeow", "description": "Messing around with some more sdf.\n8-5-2021- Added some specular", "tags": ["sdf", "cube", "helix"], "likes": 6, "viewed": 189, "date": "1628193315", "time_retrieved": "2024-06-20T20:48:31.638501", "image_code": "mat2 rot(float a)\n{\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c, -s ,s, c);\n}\n\n//https://www.shadertoy.com/view/Xds3zN\nfloat cube (vec3 p, vec3 s)\n{\n\tvec3 d = abs(p) - s;\n\treturn min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nfloat scene(vec3 p)\n{\n\t\n\tfloat z = p.z;\n\t\n\t//p.z += time;\n\t\n\tp.z = mod(p.z - 2., 4.) -2.;\n\tp.x = mod(p.x - 3., 6.) -3.;\n\tp.xy /= 12.;\n\tp.xy *= rot(iTime + p.x * .3 * sin(iTime + z));\n\tp.xy *= 12.;\n\tp.y = abs(p.y);\n\t//return cube( p, vec3(1));\n\treturn cube(p , vec3(abs(sin(iTime - p.z * 0.44 + z)), 0., 1.)) - .5;\n}\n\nmat3 cam(vec3 E, vec3 l)\n{\n\tvec3 ww = normalize(l - E);\n\tvec3 uu = normalize(cross(ww, vec3(0,1,0)));\n\tvec3 vv = cross(uu,ww);\n\t\n\treturn mat3(uu,vv, ww);\n}\n\n\n//https://www.shadertoy.com/view/Xds3zN\nvec3 norm(vec3 value)\n{\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * scene(value+0.0005*e);\n    }\n    return normalize(n);\n}\n\n\nvec4 rc(vec3 ro, vec3 rd)\n{\n\tfloat len = 0.;\n\tfloat closest = 50.;\n\tfor(int i = 0; i < 255; i ++)\n\t{\n\t\tvec3 pos = ro + rd * len;\n\t\tfloat dist = scene(pos);\n\t\t\t\tclosest = min(closest, dist);\n\t\tif(dist < .001)\n\t\t\treturn vec4(ro + rd * len, closest);\n\t\t\t\n\n\t\tlen += dist;\n\t\t\n\t\tif(len > 50.)\n\t\treturn vec4(0,0,0, closest);\n\t\t\n\t}\n\treturn vec4(0,0,0, closest);\n}\n\nvec3 color(vec4 pos, vec3 cam, vec2 uv)\n{\n\tvec3 n = norm(pos.xyz);\n\tvec3 amb = vec3(1.-uv.y) * 0.2 * vec3( .4, .4, .7);\n\tvec3 dis = normalize(cam - pos.xyz);\n\tvec3 diff = (dot(n ,dis)) * vec3(0.1, .6, .7);\n\tvec3 glow =  1./(1.+clamp(pos.w, 0.,1.) * 10.) * 0.6* vec3(.4,.4,.7);\n\tvec3 ref = 2.*dot(n, dis) * n  - dis;\n\tvec3 spec = pow(dot(dis, ref), 3.0) * vec3(0.1,.6,.7);\n\tspec = clamp ( spec , 0.,1.);\n\tif(dot (pos,pos) == 0.)\n\t\treturn amb + vec3(1.,1.,1.) ;\n\t\n\treturn diff * pos.x + amb + glow +spec;\n}\n\n\nvoid mainImage( out vec4 fc, in vec2 uv )\n{\n\tvec2 r = iResolution.xy, u = (uv * 2. - r)/r.y;\n\t\n\tvec3 ro = vec3(0.,10.,0.);\n\n\t//ro.xz *= rot(time);\n\t\n\tvec3 rd = cam(ro, vec3(1)) * normalize(vec3(u, 2.));\n\t\n\tvec4 pos = rc(ro,rd);\n\t\n\tfc = vec4(color(pos, ro, u), 1.) ;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/stSSR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 19, 19, 79], [81, 121, 150, 150, 237], [239, 239, 260, 260, 554], [556, 556, 582, 582, 711], [714, 754, 777, 777, 982], [985, 985, 1012, 1012, 1340], [1342, 1342, 1383, 1383, 1846], [1849, 1849, 1892, 1892, 2116]]}
{"id": "stSSRd", "name": "Depth Texture Raytracer thingy", "author": "Peace", "description": "input = depth texture; output = nice 3D raytraced like image, I don't know what I made is maybe it's even new idk.", "tags": ["raymarching"], "likes": 7, "viewed": 180, "date": "1628354586", "time_retrieved": "2024-06-20T20:48:31.638501", "image_code": "vec2 pointToUV(vec3 p, vec3 n)\n{\n    vec3 e1 = normalize(cross(n, vec3(1, 0, 0)));\n    if(e1 == vec3(0))\n    e1 = normalize(cross(n, vec3(0, 0, 1)));\n    \n    vec3 e2 = normalize(cross(n, e1));\n    return vec2(dot(e1, p), dot(e2, p));\n}\n\nfloat getShadow(vec3 p, vec2 uv, vec3 lp)\n{\n    vec3 rd = normalize(lp - p);  \n    vec2 texel = vec2(1.0) / iResolution.xy * rd.xy;\n    float currDepth = texture(iChannel1, uv).r;\n    for(float i = 0.0; i < 256.0; ++i)\n    {\n        float nextDepth = texture(iChannel1, uv + texel * i).r;\n        currDepth += rd.z;\n        if(nextDepth > currDepth)\n        {\n            return .5;\n        }\n    }\n    \n\n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvn = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n\n    float d = texture(iChannel1, uv).r;\n    vec3 rd = normalize(vec3(uvn, 1.0));\n    vec3 ro = vec3(0, 0, 0);\n    vec3 p = ro + rd * d;\n    vec3 e = vec3(vec2(1.0) / iResolution.xy, 0);\n    float nx = (texture(iChannel1, uv + e.xz).r - texture(iChannel1, uv - e.xz).r) / (2.0 * e.x);\n    float ny = (texture(iChannel1, uv + e.zy).r - texture(iChannel1, uv - e.zy).r) / (2.0 * e.y);\n    vec3 n = normalize(vec3(-nx, -ny, 1.));\n    vec3 lp = vec3(cos(iTime) * 1.5, sin(iTime) * 1.5, 0.1);\n    vec3 ld = normalize(lp - p);\n    vec3 vd = normalize(ro - p);\n    float diff = max(dot(ld, n), 0.0)*2.;\n    float spec = pow(max(dot(reflect(-ld, n), vd), 0.0), 4.0) * 0.5;\n    float s = getShadow(p, uv, lp);\n    vec3 l = vec3(diff + spec + 0.5) * s;\n    l = pow(l, vec3(0.4545));\n    vec3 kd = texture(iChannel0, uv).rgb;\n    vec3 col = kd*vec3(l);\n    fragColor = vec4(col + 1. /pow(distance(ld.xy, uvn) * 2.0, 16.),1.0);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/stSSRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 32, 32, 236], [238, 238, 281, 281, 660], [662, 662, 719, 719, 1740]]}
{"id": "stSXDK", "name": "SDF Raymarching Grid Demo", "author": "Pseudonymous", "description": "First time writing a raymarcher. Testing lighting a virtual scene, move around camera with your mouse!", "tags": ["mouse", "raymarch", "sdf", "lighting", "hue", "dotproduct"], "likes": 0, "viewed": 43, "date": "1628616582", "time_retrieved": "2024-06-20T20:48:31.638501", "image_code": "#define MAX_STEPS 50\n#define MIN_DIST .001\n#define MAX_DIST 30.\n#define EPSILON .002\n\nfloat SphereSDF (vec3 point, vec3 center, float radius) {\n    return distance(point, center) - radius;\n}\n\nfloat Dist (vec3 point) {\n    \n    return max(\n        SphereSDF(point, vec3(0, 0, 1.), 3. ),\n        min(\n            max(\n                max(\n                    max(\n                        SphereSDF(point, vec3(0, 0, 1.), .5),\n                        -(distance(point.xy, vec2(0)) - .3)\n                    ),\n                    -(distance(point.xz, vec2(0, 1)) - .3)\n                ),\n                -(distance(point.yz, vec2(0, 1)) - .3)\n            ),\n            SphereSDF(point, round(point), .02)\n        )\n    );\n}\n\nvec3 estimateNormal (vec3 ray) {\n    float dist = Dist(ray);\n    return normalize(\n        vec3(\n            dist - Dist(vec3(ray.x - EPSILON, ray.y, ray.z)),\n            dist - Dist(vec3(ray.x, ray.y - EPSILON, ray.z)),\n            dist - Dist(vec3(ray.x, ray.y, ray.z - EPSILON))\n        )\n    );\n}\n\nvec3 RayMarch (vec3 ro, vec3 rd) {\n\n    float distTravelled = 0.;\n    rd = normalize(rd);\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        \n        vec3 pointAtEndOfMarchedRay = ro + rd * distTravelled;\n        float distToObj = Dist(pointAtEndOfMarchedRay);\n        \n        if (distToObj <= MIN_DIST) {\n            return pointAtEndOfMarchedRay;\n        }\n        \n        distTravelled += distToObj;\n        \n        if (distTravelled >= MAX_DIST) return vec3(-10000000.);\n    }\n    \n    return vec3(-100000.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = 2. * vec2(\n        (fragCoord.x - .5 * iResolution.x) / iResolution.y, \n        fragCoord.y / iResolution.y - .5\n        );\n    vec3 ro = vec3(0., 0., 0.);\n    //ro.x = uv.x;\n    //ro.y = uv.y;\n    \n    ro = vec3(sin(iTime), cos(iTime), -.5);\n    ro = vec3(3. * uv.x / 5. + sin(iTime), 3. * uv.y / 5. + cos(iTime), 0);\n    \n    \n    ro = vec3(\n        (iMouse.x - .5 * iResolution.x) / iResolution.y, \n        iMouse.y / iResolution.y, -.5\n    );\n    \n    \n    vec3 rd = vec3(uv.x, uv.y, 1.);\n    \n    vec3 closestPoint = RayMarch(ro, rd);\n    \n    vec3 n = estimateNormal(closestPoint);\n    \n    vec3 lightCoord = vec3(5. * cos(iTime), 3., 1. + 5. * sin(iTime));\n    \n    float lighting = dot(n, lightCoord);\n    \n    vec3 baseColor = vec3(.4 * cos(iTime) + .6, 2. * abs(fract(iTime / 3.) - .5), .3 * sin(iTime) + .7);\n    \n    baseColor = abs(normalize(closestPoint));\n    \n    vec3 col = baseColor + max(30. - distance(closestPoint, lightCoord), 0.) * lighting * .005;\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/stSXDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[86, 86, 143, 143, 190], [192, 192, 217, 217, 721], [723, 723, 755, 755, 1023], [1025, 1025, 1059, 1059, 1546], [1548, 1548, 1605, 1605, 2655]]}
{"id": "stSXDV", "name": "Trip - 2", "author": "birdbird", "description": "Using log polar-tiling (as described here https://www.osar.fr/notes/logspherical/) to create an infinitely zooming shader.", "tags": ["tiling", "infinite", "zooming"], "likes": 7, "viewed": 95, "date": "1628629094", "time_retrieved": "2024-06-20T20:48:31.990021", "image_code": "const float pi = acos(-1.);\n\n//https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\nfloat map_range(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n//https://gist.github.com/ayamflow/c06bc0c8a64f985dd431bd0ac5b557cd\nvec2 rotateUV(vec2 uv, float rotation)\n{\n    float mid = 0.5;\n    return vec2(\n        cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,\n        cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid\n    );\n}\n\nfloat map(vec2 uv) {\n    int iterations = 15;\n    vec2 ouv = uv;\n    \n    uv.y += iTime/16.;\n    uv = abs(mod(uv, 1.)*4. - 2.);\n    \n    for(int i = 0; i < iterations; i ++) {\n        float fi = float(i);\n        float fit = float(iterations);\n        \n        uv = abs(uv - (vec2(0.5 + (fi/fit)*0.6 )));\n        \n        uv *= 1.16;\n        \n        uv = rotateUV(uv, map_range(ouv.x,-1.,1., 0.2, 5.) );\n    }\n    \n    return sin(length(uv)*10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 uv_o = uv;\n    \n    //Log polar-tiling -> https://www.osar.fr/notes/logspherical/\n    vec2 pos = vec2(log(length(uv)), atan(uv.y, uv.x));\n    pos *= 1./pi;\n    pos = fract(pos) - 0.5;   \n    uv = pos;\n    uv.x -= iTime/5. + 5700.;\n    \n    //RGB offset\n    float offset_range = 0.005;\n    float offset = map_range(sin(iTime),-1.,1.,0.2,1.) * offset_range;\n    float offset_y = cos(iTime) * offset_range * 0.2;\n    \n    float cr = map(uv + vec2(offset, 0.));\n    float cg = map(uv + vec2(offset*2., offset_y*2.));\n    float cb = map(uv + vec2(offset*3., offset_y*3.));\n    vec3 color = vec3(cr, cg, cb)*3.;\n    \n    //Fade to black towards center to hide aliasing\n    float mask = (1. - pow(length(uv_o),0.96) )*3.;\n    color -= mask;\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/stSXDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[29, 97, 175, 175, 241], [243, 311, 351, 351, 547], [549, 549, 569, 569, 998], [1000, 1000, 1057, 1057, 1899]]}
{"id": "stSXRc", "name": "Sonic Hedgehog", "author": "zxcvm", "description": "Sonic the hedgehog", "tags": ["sonic"], "likes": 2, "viewed": 159, "date": "1628217182", "time_retrieved": "2024-06-20T20:48:31.990021", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = vec4(abs(uv.y-1.),abs(uv.y-1.),1.,1.);\n\n    float offset = mod(uv.x - iTime, 1.);\n\n    if ((offset <= 0.45 && offset >= 0.4 && uv.y >= 0.2 && uv.y <= 0.3))\n        fragColor = vec4(0.34,0.36,190./255.,1.);\n    if ((uv.x <= 1. && uv.x >= 0.0 && uv.y >= 0.0 && uv.y <= 0.2))\n        fragColor = vec4(0.9,0.5,19/255,1.);\n    if ((uv.x <= 1. && uv.x >= 0.0 && uv.y >= 0.15 && uv.y <= 0.2))\n        fragColor = vec4(0.0,0.9,19/255,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/stSXRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 55, 55, 545]]}
{"id": "stSXRd", "name": "Exponential", "author": "zxcvm", "description": "Exponential", "tags": ["exponential"], "likes": 1, "viewed": 151, "date": "1628357466", "time_retrieved": "2024-06-20T20:48:31.990021", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord/iResolution.xy;\n\n\tfloat coord = pow(uv.y * uv.y + uv.x, iTime);\n\t \n\tfragColor = vec4(tan(coord), sin(coord), cos(coord), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/stSXRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 55, 55, 203]]}
{"id": "stSXzV", "name": "MN_StarField", "author": "MarekNijaki", "description": "This is shader displaying multiple stars layers, giving sence of animation (pass through them). \nYou can look around by holding left mouse button.\nShader was created based on video from 'The Art of Code' youtube channel.", "tags": ["stars", "starfield"], "likes": 4, "viewed": 211, "date": "1628071929", "time_retrieved": "2024-06-20T20:48:34.111429", "image_code": "// Shadertoy uses GLSL language.\n\n// UV.\n// Default 'UV'.\n// vec2 uv = fragCoord/iResolution.xy; \n\n// Time varying pixel color.\n// vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n\n// Default background colour.\n// Output to screen\n// fragColor = vec4(col,1.0);\n\n\n\n// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n\n// Global constant PI value.\nfloat PI = 3.1415;\n// Global constant for UV.\nvec2 UV;\n\n// Example how to check 'UV' coordinates values.\n// fragColor = vec4(vec3(0)+UV.x,1.0);\n// fragColor = vec4(vec3(0)+UV.y,1.0);\nvec2 GetUV_WithOriginInTheCenter(in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1).\n    // Multiply by '0.5' so 'UV' coordinates have their origin/pivot in the middle/center of the screen.\n    // 'UV' values will go from '-0.5' to '0' to '0.5'. \n    vec2 UV = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    // Return value.\n    return UV;\n}\n\n// For 'numberOfGridTiles=3' 'UV' values will go from '-1.5' to '0' to '1.5'.\nvec2 SetGridTiles(vec2 UV, float numberOfGridTiles)\n{ \n    // Set tiles.\n    UV = UV * numberOfGridTiles;\n    // Return value.\n    return UV;\n}\n\n// Create grid ID's.\n// Can be visualised by 'col.rg +=  gridIDs;'.\n// Each cell will have diffrent colour.\nvec2 CreateGridIds(vec2 UV)\n{\n    // Get ID (truncate 'UV' coordinates numbers to only integer value, eg. '2.3' will give '2').\n    vec2 IDs = floor(UV);\n    // Return value.\n    return IDs;\n}\n\n// Create grid UV.\nvec2 CreateGridUV(vec2 UV)\n{\n    // WTF? not from -1.5 to 1.5 ???\n    // 'UV' goes from '-3' to '3', 'fract()' will return only fractual component of numbers. \n    // Each cell have values from '0' to '1'.\n    vec2 gridUV = fract(UV);\n    // Move origin of each cell from left bottom corner to middle of each cell.\n    // Each cell have values from '-0.5' to '0.5'.\n    gridUV = gridUV - 0.5;\n    // Return value.\n    return gridUV;\n}\n\n// Draw debug lines to show outline of the cells.\nvec3 DrawDebugCells(vec2 gridUV)\n{\n    // Create variable to store line colour.\n    vec3 col;\n    // Draw lines\n    if((gridUV.x > 0.49) || (gridUV.y > 0.49))\n      col.r = 1.0;\n    // Return value.\n    return col;\n}\n\n// Generate pseudo random value.\n// Can be Displayed by 'col = col + GeneratePseudoRandom_FromHash21(gridIDs);'\nfloat GeneratePseudoRandom_FromHash21(vec2 point)\n{\n    // Twist number so it will lok like random number.\n    point = fract(point * vec2(123.34, 456.21));\n    point = point + dot(point, point + 45.32);\n    // Get random value.\n    float randomVal = fract(point.x * point.y);\n    // Return value.\n    return randomVal;\n}\n\n// Randomize positions of grid 'UV' positions.\nvec2 RandomizeGridUVPositions(vec2 gridIDs, vec2 gridUV)\n{\n    // Get random value from '0' to '1'.\n    float randomOffsetX = GeneratePseudoRandom_FromHash21(gridIDs);\n    float randomOffsetY = fract(randomOffsetX * 34.0);\n    // Shift offset so shifted star will not go out of the cell completly (origin of the star was in '0.5, 0.5').\n    // Offsets will have values between '-0.5, -0.5' to '0.5, 0.5'.\n    randomOffsetX = randomOffsetX - 0.5;\n    randomOffsetY = randomOffsetY - 0.5;\n    // Randomize values of UV from '0' to '1' based od cells ID's.\n    gridUV = gridUV - vec2(randomOffsetX,randomOffsetY);    \n    // Return value.\n    return gridUV;\n}\n\n// Get distance to the center of 'UV'.\nfloat GetDistanceToTheCenter(vec2 UV)\n{\n    \n    // Origin is in the middle. \n    // 'length(UV)' will return distance for each pixel from UV to the middle.\n    // You can imagine this as a circle that is going from black to white (from middle to edges).\n    // For length value of '0' colour is black , for '1' colour is white.\n    float distanceToTheCenter = length(UV);\n    // Return value.\n    return distanceToTheCenter;\n}\n\n// Create smoothstep circle.\n// NOT USED BECAUSE: \n//   * In normal world, lighting fall off should go smoothly all the way to the screen edge.\n//   * 'smoothstep()' will have hard '0' or '1' values for areas outside of tresholds.\nfloat CreateSmoothstepWhiteCircle(vec2 UV, float lowerCutoff, float upperCutoff)\n{\n    // Get distance to the center of 'UV'.\n    float distanceToTheCenter = GetDistanceToTheCenter(UV); \n    // Smooth out the circle.    \n    // 'smoothstep()' takes two cutoff/edges parameters, which determine the lower and higher threshold values for the curve. \n    // When 'In' is lower than 'lowerCutoff', the output is '0', and when 'In' is above 'upperCutoff', the output is '1'.\n    // 'smoothstep()' will return interpolates between 'lowerCutoff' and 'upperCutoff' in a similar way to Lerp. \n    // However, the interpolation will gradually speed up from the start and slow down toward the end. \n    // This is useful for creating natural-looking animation, fading and other transitions.\n    float darkCircle = smoothstep(lowerCutoff, upperCutoff, distanceToTheCenter);\n    float whiteCircle = 1.0 - darkCircle;\n    // Return value.\n    return whiteCircle;\n}\n\nfloat CreateSmoothWhiteCircle(vec2 UV, float minInnerCircleRadius)\n{\n    // Get distance to the center of 'UV'.\n    float distanceToTheCenter = GetDistanceToTheCenter(UV); \n    \n    // Try not divide by 0?!!!\n    //if(distanceToTheCenter <> 0)\n    // 'clamp(x,min,max)' returns the value of 'x' constrained to the range 'min' to 'max'.\n    //whiteCircle = minInnerCircleRadius / clamp(distanceToTheCenter, -1.5, 1.5);\n    \n    // Create circle\n    float whiteCircle = minInnerCircleRadius / distanceToTheCenter;\n    // Return value.\n    return whiteCircle;\n}\n\n// Create cross/flares/rays.\nfloat CreateWhiteCross(vec2 UV, float crossIntensity)\n{    \n    // Gradient between '-0.5' to '0' to '0.5'.\n    float blackToWhiteGradientX = UV.x;\n    float blackToWhiteGradientY = UV.y;\n    // Gradient between '0.5' to '0' to '0.5'.\n    // This will look like vertical and horizontal black lines.\n    float whiteToBlackToWhiteGradientX = abs(blackToWhiteGradientX);\n    float whiteToBlackToWhiteGradientY = abs(blackToWhiteGradientY);\n    // Create cross/flare.\n    float blackCross = whiteToBlackToWhiteGradientX * whiteToBlackToWhiteGradientY; \n    // Set thickness/bluriness of cross/flare (higher value will result in clearer lines).\n    float crossSize = 1000.0;\n    blackCross = blackCross * crossSize;\n    // Clamp values between '0' and '1'.\n    blackCross = min(1.0, blackCross);\n    blackCross = max(0.0, blackCross);\n    // Create white cross.\n    float whiteCross = 1.0 - blackCross;\n    // Set intensity.\n    whiteCross = whiteCross * crossIntensity;\n    // Return value.\n    return whiteCross;\n}\n\n// Return rotation angle matrix.\n// 'PI' is aroung '3.1415'\n// '360' degrees is two 'PI' radians.\n// '180' degrees is 'PI' radians.\nmat2 RotationAngle(float angle)\n{\n    float sinus = sin(angle);\n    float cosinus = cos(angle);\n    return mat2(cosinus,-sinus,sinus,cosinus);\n}\n\n// Create star.\nvec3 CreateStars(vec2 gridIDs, vec2 UV, float starIntensity, float innerCircleRadius, float crossIntensity, \n                 float minRange, float maxRange, vec3 col)\n{\n    // Create circle.\n    float whiteStar = CreateSmoothWhiteCircle(UV, innerCircleRadius);\n        \n    // Applay first cross/flares/rays.\n    whiteStar = whiteStar + CreateWhiteCross(UV, crossIntensity);\n    // Rotate 'UV' around '45' degrees angle.\n    UV = UV * RotationAngle(PI / 4.0);\n    // Applay second cross/flares/rays.\n    whiteStar = whiteStar + CreateWhiteCross(UV, crossIntensity);\n    \n    // Get distance to the center of 'UV'.\n    float distanceToTheCenter = GetDistanceToTheCenter(UV); \n    // Cut star.\n    // Cut is needed, because in some cases, glow and flares could go out of the cell - for values bigger than '0.5'.\n    // That would be fine because neighbourhood cells will take care of drawing appropiate parts of star, but it can't go\n    // further - eg. 2 or more cells, because it would lead to artifacts.\n    minRange = clamp(minRange, 0.0, 0.5);\n    maxRange = clamp(maxRange, 0.0, 1.0);\n    whiteStar = whiteStar * smoothstep(maxRange, minRange, distanceToTheCenter); \n    \n    // Apply intensity.\n    whiteStar = whiteStar * starIntensity;\n    \n    \n    // Convert white star to star with colour.\n    vec3 star = vec3(whiteStar);\n    // Apply colour.    \n    star = star * col;\n    \n    // Return value.\n    return star;\n}\n\n// Create random colour.\nvec3 CreateRandomColour(vec2 gridIDs, float starIntensity)\n{\n    // Generate random value.\n    float randomVal = GeneratePseudoRandom_FromHash21(gridIDs);\n    // Rate of colour changes.\n    float colourChangeRate = 2.0;\n    \n    // Because small values are very close to each other, colour components will look almost the same.\n    // To avoid that we can multiply those components by some big number to disperse them all over 'sin()' method.\n    //float colourComponentsDispersionMagnifier = 1.0;\n    //vec3 col = sin(vec3(0.2, 0.3, 0.9) * randomVal * colourComponentsDispersionMagnifier) / 2.0 + 0.5;\n    \n    // Create random colour.\n    // 'sin(vec3(...))' will just do 'sin()' for each component separatly.\n    // '* iTime' will multiply 'sin()' outcomes over time value. \n    // Each colour component (RGB) will change with diffrent rates, because each have diffrent multiplication exponent (0.2, 0.3, 0.9). \n    // Colour components have values between '0.0' and '1.0'. 'Sin()' goes from '-1.0' to '1.0'.\n    // '/ 2.0' will result in values between '-0.5' and '0.5'.\n    // '+ 0.5' will result in values between '0.0' and '1.0', so appropiate for colour components.    \n    vec3 colour = sin(vec3(0.2, 0.3, 0.9) * randomVal * colourChangeRate * iTime) / 2.0 + 0.5;\n    \n    // Eliminate colours that we don't like (in this case remove most of green).\n    colour = colour * vec3(1.0, 0.3, 1.0);\n    // Set bigger stars more blue.\n    colour = colour * vec3(1.0, 1.0, 2.0 * starIntensity);\n    \n    // Return value.\n    return colour;\n}\n\n// Get mouse positon.\nvec2 GetMousePos()\n{\n  return (iMouse.xy - (iResolution.xy * 0.5)) / iResolution.y;\n}\n\n// Get mouse input.\nvec2 GetMouseInput()\n{\n  vec2 mousePos = GetMousePos();\n  return mousePos * 5.0;\n}\n\n// Create stars.\n// Also for each star draw parts of it that went out of the cell (neighbour cells will generate that star parts).\nvec3 CreateStarsWithNeighboursContributions(float densityOfStars, float layerRandomOffset, mat2 layerAngle)\n{\n    // Allow to look over star field (normal looking around).\n    //vec2 UVtmp = SetGridTiles(UV+GetMouseInput(), densityOfStars);\n    // Set grid tiles. \n    vec2 UVtmp = SetGridTiles(UV, densityOfStars);\n    // Allow to look over star field (paralax effect).\n    UVtmp = UVtmp + GetMouseInput();    \n    // Set rotation of layer.\n    UVtmp = UVtmp * layerAngle;\n    // Set random offset of layer.\n    UVtmp = UVtmp + layerRandomOffset;\n    // Create grid ID's.\n    vec2 gridIDs = CreateGridIds(UVtmp);\n    // Create grid 'UV'.\n    vec2 gridUV = CreateGridUV(UVtmp);    \n    // Create star variable.\n    vec3 stars;\n    // For each cell, add contributions from neighbourhood cells.\n    for(int x=-1; x<=1; x++)\n      for(int y=-1; y<=1; y++)\n      {\n        // Get neighbour offset.\n        vec2 offset = vec2(x,y);\n        // Compute offseted grid IDs and UV.\n        vec2 offsetedGridIDs = gridIDs+offset;\n        vec2 offsetedGridUV = gridUV-offset;\n        // Randomize grid 'UV' positions.\n        vec2 gridUV2 = RandomizeGridUVPositions(offsetedGridIDs, offsetedGridUV);\n        // Generate random star intensity (will also affect star size little bit).\n        float starIntensity = GeneratePseudoRandom_FromHash21(offsetedGridIDs);\n        starIntensity = max(0.5, starIntensity);\n        // Compute inner circle radius (below '0.01' stars become invisible).\n        // Big values make stars look like big glowy bulbs.\n        float innerCircleRadius = max(0.065, 0.065/densityOfStars);\n        // Compute star cross intensity (only stars with big intensity will have cross turn on).\n        float crossIntensity = smoothstep(0.8, 1.0, starIntensity);\n        crossIntensity = min(0.25, crossIntensity);        \n        // Set min and max range.\n        float minRange = 0.4; \n        float maxRange = 1.0;\n        // Create random colour.\n        vec3 col = CreateRandomColour(offsetedGridIDs, starIntensity);\n        // Create stars.\n        stars = stars + CreateStars(gridIDs, gridUV2, starIntensity, innerCircleRadius, crossIntensity, minRange, maxRange, col);\n      }    \n    // Draw debug cells.\n    //stars = stars + DrawDebugCells(gridUV);\n    // Return value.\n    return stars;\n}\n\n// Get fade factor, depending on layer depth.\nfloat GetFadeFactor(float depth)\n{\n    // This is only to show other way, how to achive similar result as smoothstep.\n    //if(depth > 0.9) \n    //{\n      // 0.9 * 10 => 9.0 => fract() => 0.0\n      // 0.91 * 10 => 9.1 => fract() => 0.1\n      // 0.92 * 10 => 9.2 => fract() => 0.2\n      // 0.99 * 10 => 9.9 => fract() => 0.9\n      //float interpolation = fract(depth*10.0);\n      // Fade out last part of animation (start will become more transparent whe they are very close to screen).\n      //fadeFactor = mix(fadeFactor, 0.0, fract(depth*10.0));\n    //}\n    \n    // Last part of depth should fade out again.\n    float fadeFactor = depth * smoothstep(1.0, 0.8, depth);\n    // Return value.\n    return fadeFactor;\n}\n\n// Create multiple layers of stars.\nvec3 CreateStarsLayers(float numOfLayers, float densityOfStars)\n{\n  // Caculate animation speed.\n  float passThroughAnimationSpeed = iTime * 0.1;\n  float rotateAnimationSpeed = iTime * 0.01;\n  // Stars layers.\n  vec3 starsLayers;\n  // Create layers of stars\n  for(float i=0.0; i<1.0; i += 1.0/numOfLayers)\n  {\n    // Depth of layer will change from small value to '1.0' over time. \n    // After it reach '1.0' depth will be shifted to small value and again start increasing.\n    float depth = fract(i+passThroughAnimationSpeed);\n    // Scale influence how many grid tiles is on given layer.\n    // To increase number of stars, scale must increase also.\n    // As for layers goes, each of them should have diffrent size of stars (from layers with low scale to high scale).\n    // Changing scale of each layer over time will give sense of passing through the stars.\n    float scale = mix(densityOfStars + numOfLayers, 0.5, depth);\n    // Compute layer random positon (so layers stars will not align into lines).\n    float layerRandomOffset = i * 453.23;\n    // Compute layer angle.\n    mat2 layerAngle = RotationAngle(PI * rotateAnimationSpeed);\n    // Layers that are far from screen (have low scale) should be fading from '0.0' to '1.0', as scale increase.\n    // This will prevent 'poping out' artifact when layers are shifted to the back (their scale is set to low number).\n    float fadeFactor = GetFadeFactor(depth);\n    // Create mulitple layers of stars.\n    starsLayers = starsLayers + CreateStarsWithNeighboursContributions(scale, layerRandomOffset, layerAngle) * fadeFactor;\n  }\n  // Return value.\n  return starsLayers;\n}\n\n\n// Main function.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Get UV with origin/pivot in the middle/center of the screen.\n    UV = GetUV_WithOriginInTheCenter(fragCoord);\n    // Create black colour.\n    vec3 col = vec3(0);\n    // Create stars layers.\n    col = col + CreateStarsLayers(7.0, 15.0);\n    // Output to screen.\n    fragColor = vec4(col,1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/stSXzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[480, 607, 660, 873, 977], [979, 1057, 1110, 1129, 1200], [1202, 1310, 1339, 1437, 1502], [1504, 1523, 1551, 1728, 1957], [1959, 2009, 2043, 2088, 2225], [2227, 2339, 2390, 2445, 2659], [2661, 2708, 2766, 2807, 3364], [3366, 3405, 3444, 3733, 3832], [3834, 4065, 4147, 4190, 5015], [5017, 5017, 5085, 5128, 5575], [5577, 5606, 5661, 5713, 6617], [6619, 6751, 6784, 6784, 6895], [6897, 6913, 7082, 7104, 8340], [8342, 8367, 8427, 8457, 9909], [9911, 9933, 9953, 9953, 10018], [10020, 10040, 10062, 10062, 10122], [10124, 10255, 10364, 10519, 12563], [12565, 12611, 12645, 13220, 13326], [13328, 13364, 13429, 13460, 14994], [14997, 15015, 15072, 15144, 15377]]}
{"id": "ttSGD1", "name": "Mandelbrot 0", "author": "hjd3481", "description": "Quick and dirty mandelbrot explorer with anti-aliasing.", "tags": ["mandelbrot"], "likes": 1, "viewed": 71, "date": "1630427633", "time_retrieved": "2024-06-20T20:48:34.444771", "image_code": "#define MAX_ITER 150\n\nfloat DoBrot(vec2 z, vec2 c)\n{\n    int iters = 0;\n    for( int i=0; i < MAX_ITER; ++i)\n    {\n        vec2 pw = z*z;\n        z = vec2( pw.x - pw.y, 2.0*z.x*z.y ) + c;\n        if( length(z) > 2.0 )\n            break;\n        ++iters;\n    }\n    \n    return float(iters)/float(MAX_ITER);\n}\n\nfloat GetSampleBrot(in vec2 fragCoord, float scaler, vec2 centre, vec2 z, vec2 offset )\n{\n    vec2 uv2 = ((fragCoord+offset)-iResolution.xy*0.5)/scaler;\n    vec2 c2 =  (uv2) + /*((iMouse.xy-iResolution.xy*0.5)/iResolution.xy)*/ + centre;\n    return DoBrot(z,c2); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float scaler = (iResolution.x*pow(2.0,iTime*0.25))*0.2;\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/scaler;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    col.xy = smoothstep(-1.9, -2.0, uv.xy);\n\n    vec2 z = uv;\n    z = vec2(0);\n    \n    vec2 centre = vec2(0.4027,0.303);\n    vec2 c =  (uv) + /*((iMouse.xy-iResolution.xy*0.5)/iResolution.xy)*/ + centre;\n           \n    float I = DoBrot(z,c) * 2.0; //centre pixel gets double influence, otherwise its just a blur op\n    \n    I += GetSampleBrot(fragCoord, scaler, centre, z, vec2(-0.5,-0.5));\n    I += GetSampleBrot(fragCoord, scaler, centre, z, vec2( 0.5,-0.5));\n    I += GetSampleBrot(fragCoord, scaler, centre, z, vec2(-0.5, 0.5));\n    I += GetSampleBrot(fragCoord, scaler, centre, z, vec2( 0.5, 0.5));\n\n    I *= 0.166666; // div by 5 samples\n\n    col.xyz = vec3( pow(I,4.0) );   \n    col.x = ( pow(I,1.0) );   \n    col.y = ( pow(I,2.0) );   \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttSGD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[22, 22, 52, 52, 307], [309, 309, 398, 398, 574], [576, 576, 633, 683, 1666]]}
{"id": "Wd2BRG", "name": "oil warping", "author": "foil", "description": "pulse and warp actually", "tags": ["pulse", "warp"], "likes": 7, "viewed": 75, "date": "1629127698", "time_retrieved": "2024-06-20T20:48:34.754375", "image_code": "\nfloat pulse(float time) {\n\tfloat x = mod(time*0.3, 1.0); // x will gradually increase from 0 to 1 in cycle\n    float y = smoothstep(0.0,0.13,x) - x; // pulsing function\n    \n    return 3.0+(-3.0*y); // adjustements\n}\n\nfloat hash(vec2 co){\n    return sin( 2355.44 * fract(sin(dot(co.xy ,vec2(12.9898,78.233)))  * 43758.5453));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    float strength = 0.35;\n    float t = iTime/35.0;\n    \n    vec3 col = vec3(0);\n    vec2 fC = fragCoord*1.5;\n\n    #ifdef AA\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n\n            fC = fragCoord+vec2(i,j)/2.0;\n            \n            #endif\n            \n            //Normalized pixel coordinates (from 0 to 1)\n            vec2 pos = fC/iResolution.xy;\n\n            pos.y /= iResolution.x/iResolution.y;\n            pos = 4.0*(vec2(0.5) - pos);\n\n            for(float k = 1.0; k < 6.0; k+=1.0){ \n                pos.x += strength * sin(2.0*t+k*1.5 * pos.y)+t*0.5;\n                pos.y += strength * cos(2.0*t+k*1.5 * pos.x);\n            }\n\n            //Time varying pixel colour\n            col += clamp(0.25 + 0.5*cos(t*0.5+pos.xyx*3.).xxx, 0.1, 0.99);\n            \n            #ifdef AA\n        }\n    }\n\n    col /= 9.0;\n    #endif\n    \n    //Fragment colour\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2BRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 26, 26, 217], [219, 219, 239, 239, 328], [330, 330, 386, 386, 1321]]}
{"id": "wdcSRr", "name": "Branching  Squares polar Mapping", "author": "TLC123", "description": "i couldn't fint it so i made it\nNow i'm obligated to make a truchet version?", "tags": ["polar", "chess", "specialmapping"], "likes": 3, "viewed": 64, "date": "1628172696", "time_retrieved": "2024-06-20T20:48:34.754375", "image_code": "// Fork of \"Root branching pattern\" by TLC123. https://shadertoy.com/view/tdV3Dd\n// 2019-10-17 07:28:02\n\nvec3  anytexture(vec2 uv){\nreturn vec3(0.7,1,.7)*(mod(floor(uv.x) + floor(uv.y *2. ), 2.));\n}\n\nvec3  anytextureNEW(vec2 uv){\n    uv.y *= 2.;\n    uv = sin(3.14*uv);\n    float a =uv.x*uv.y;\n    return vec3(1,.7,.7)* (.5 - .5 * a/fwidth(a));\n}\n\n\nvec3 fu(vec2 uv) {\n    float Y =  (  pow(1.56,uv.y ) ),\n          y = fract(Y),\n          o = exp2( floor(Y)),\n          x = abs( fract(   uv.x * o ) - .5 );\n        \n      vec3  p=anytexture(vec2(uv.x * o ,Y));\n         if(mod(floor(iTime),2.)==0.){   p=anytextureNEW(vec2(uv.x * o ,Y));}\n\n    //      p = 1. - abs(  x - smoothstep(0., 1., y) / 4.);\n    //p= mix( p, p * p, y * 1.333) + .15 / abs(Y - .5);\n    \n    return p;\n}\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n\n    float t = iTime;\n    U = U / iResolution.x - vec2(.5, .15);\n    U *= 7. + sin(t) * 5.;\n    U += 1.* vec2( sin(t*.17) , cos(t*.13) );\n    \n    float l =  length(U);\n      vec3    v = mod(iTime, 30.) < 25. \n              ?  fu( vec2(  ( atan(U.y,U.x) + sin(t*.1) * 4. ) / 6.28 \n                           * floor( 5. + sin(t*.4) *3. ) \n                          ,  l +1.\n                    )    )\n                   /  max(1., l*l*.125)\n              :  fu(U);\n\n    //v *= .75;\n\n    O = vec4( v,1. );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdcSRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 105, 131, 131, 198], [200, 200, 229, 229, 345], [348, 348, 366, 366, 775], [778, 778, 814, 814, 1321]]}
{"id": "WdycDz", "name": "newtons method 788989890", "author": "stonedape", "description": "837878", "tags": ["783278"], "likes": 2, "viewed": 34, "date": "1629271113", "time_retrieved": "2024-06-20T20:48:35.287352", "image_code": "float h=1e-3;\nfloat pi=3.1415926;\nvec2 I=vec2(0.,1.);\n\nvec2 cxMult(vec2 a,vec2 b){\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\n\nfloat atanz(float a){\n    if(a!=a) return pi/2.;\n    return atan(a);\n}\n\nfloat atan2(float y,float x){\n    if(x>0.) return atan(y/x);\n    if(y>=0. && x!=0.) return atan(y/x)+pi;\n    if(x==0.){\n        if(y>0.) return pi/2.;\n        return -pi/2.;\n    }\n    return atan(y/x)-pi;\n}\n\n\n\nvec2 cxPow(vec2 a,vec2 b){\n    float len=length(a);\n    float theta=b.x*atan2(a.y,a.x);\n    float phi=b.y*log(len);\n    return vec2(cos(theta)*cos(phi)-sin(theta)*sin(phi),\n                cos(theta)*sin(phi)+sin(theta)*cos(phi))\n        \t\t*pow(len,b.x)*exp(-b.y*atan2(a.y,a.x));\n}\n\nvec2 cxPow(vec2 a,float b){\n    return cxPow(a,vec2(b,0.));\n}\n\nvec2 conj(vec2 z){\n    return vec2(z.x,-z.y);\n}\n\nvec2 cxDiv(vec2 a,vec2 b){\n    return cxMult(a,conj(b))/(pow(b.x,2.)+pow(b.y,2.));\n}\n\nvec2 cxExp(vec2 a){\n    return exp(a.x)*vec2(cos(a.y),sin(a.y));\n}\n\nvec2 cxSin(vec2 a){\n    return cxDiv(cxExp(cxMult(I,a))-cxExp(cxMult(-I,a)),2.*I);\n}\n\n\n\nvec2 f(vec2 x){\n    float t=.25*iTime;\n    return cxPow(x,10.*sin(t))+vec2(1.,0.);\n}\n\nvec2 dfdx(vec2 x){\n    return cxDiv(f(x+vec2(h))-f(x-vec2(h)),2.*vec2(h));\n}\n\n\nvec2 newtmeth(vec2 x){\n    for(int i=0;i<100;i++){\n        x-=cxDiv(f(x),dfdx(x));\n    }\n    return x;\n}\n\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n    uv-=vec2(.5,.5*iResolution.y/iResolution.x);\n    uv*=pow(2.,2.5);\n    \n    vec2 c=newtmeth(uv);\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    vec3 col=hsb2rgb(vec3(1.*atan2(c.y,c.x)/pi/2.,1.,1.));\n    c=uv;\n    if(c.x!=c.x || c.y!=c.y) col=vec3(1.);\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdycDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[55, 55, 82, 82, 134], [136, 136, 157, 157, 206], [208, 208, 237, 237, 414], [418, 418, 444, 444, 699], [701, 701, 728, 728, 762], [764, 764, 782, 782, 811], [813, 813, 839, 839, 897], [899, 899, 918, 918, 965], [967, 967, 986, 986, 1051], [1055, 1055, 1070, 1070, 1139], [1141, 1141, 1159, 1159, 1217], [1220, 1220, 1242, 1242, 1324], [1327, 1327, 1353, 1353, 1585], [1588, 1588, 1645, 1695, 2095]]}
